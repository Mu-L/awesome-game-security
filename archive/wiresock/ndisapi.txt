Project Path: arc_wiresock_ndisapi__fbxccq8

Source Tree:

```txt
arc_wiresock_ndisapi__fbxccq8
├── LICENSE
├── README.md
├── cygwin
│   ├── Makefile
│   ├── README.md
│   └── build_all.bat
├── examples
│   ├── cpp
│   │   ├── capture
│   │   │   ├── README.md
│   │   │   ├── capture.vcxproj
│   │   │   ├── capture.vcxproj.filters
│   │   │   ├── pch.h
│   │   │   ├── vcpkg-configuration.json
│   │   │   └── vcpkg.json
│   │   ├── common
│   │   │   ├── README.md
│   │   │   ├── dhcp_typedefs.h
│   │   │   ├── iphelper
│   │   │   │   ├── network_adapter_info.h
│   │   │   │   └── process_lookup.h
│   │   │   ├── iphlp.h
│   │   │   ├── log
│   │   │   │   └── log.h
│   │   │   ├── ndisapi
│   │   │   │   ├── dual_packet_filter.h
│   │   │   │   ├── fastio_packet_filter.h
│   │   │   │   ├── local_redirect.h
│   │   │   │   ├── network_adapter.h
│   │   │   │   ├── queued_packet_filter.h
│   │   │   │   ├── simple_packet_filter.h
│   │   │   │   └── udp_proxy.h
│   │   │   ├── net
│   │   │   │   ├── ip_address.h
│   │   │   │   ├── ip_endpoint.h
│   │   │   │   ├── ip_subnet.h
│   │   │   │   ├── ipv6_helper.h
│   │   │   │   └── mac_address.h
│   │   │   ├── pcap
│   │   │   │   ├── pcap.h
│   │   │   │   └── pcap_file_storage.h
│   │   │   ├── proxy
│   │   │   │   ├── proxy_common.h
│   │   │   │   ├── socks5_common.h
│   │   │   │   ├── socks5_tcp_proxy_socket.h
│   │   │   │   ├── tcp_proxy_server.h
│   │   │   │   └── tcp_proxy_socket.h
│   │   │   ├── tools
│   │   │   │   └── strings.h
│   │   │   └── winsys
│   │   │       ├── event.h
│   │   │       ├── io_completion_port.h
│   │   │       └── object.h
│   │   ├── dns_proxy
│   │   │   ├── README.md
│   │   │   ├── dns_proxy.vcxproj
│   │   │   ├── dns_proxy.vcxproj.filters
│   │   │   ├── pch.h
│   │   │   ├── vcpkg-configuration.json
│   │   │   └── vcpkg.json
│   │   ├── dnstrace
│   │   │   ├── README.md
│   │   │   ├── dnstrace.vcxproj
│   │   │   ├── dnstrace.vcxproj.filters
│   │   │   ├── stdafx.h
│   │   │   ├── targetver.h
│   │   │   ├── vcpkg-configuration.json
│   │   │   └── vcpkg.json
│   │   ├── ethernet_bridge
│   │   │   ├── EthernetBridge.h
│   │   │   ├── NetworkAdapter.h
│   │   │   ├── README.md
│   │   │   ├── ebridge.h
│   │   │   ├── ebridge.vcxproj
│   │   │   ├── ebridge.vcxproj.filters
│   │   │   ├── stdafx.h
│   │   │   ├── targetver.h
│   │   │   ├── vcpkg-configuration.json
│   │   │   └── vcpkg.json
│   │   ├── hyperscan
│   │   │   ├── README.md
│   │   │   ├── hyperscan.vcxproj
│   │   │   ├── hyperscan.vcxproj.filters
│   │   │   ├── pch.h
│   │   │   ├── vcpkg-configuration.json
│   │   │   └── vcpkg.json
│   │   ├── ipv6_parser
│   │   │   ├── README.md
│   │   │   ├── ipv6_parser.vcxproj
│   │   │   ├── ipv6_parser.vcxproj.filters
│   │   │   ├── pch.h
│   │   │   ├── vcpkg-configuration.json
│   │   │   └── vcpkg.json
│   │   ├── pcapplusplus
│   │   │   ├── README.md
│   │   │   ├── pcapplusplus.vcxproj
│   │   │   ├── pcapplusplus.vcxproj.filters
│   │   │   ├── pch.h
│   │   │   ├── vcpkg-configuration.json
│   │   │   └── vcpkg.json
│   │   ├── rebind
│   │   │   ├── README.md
│   │   │   ├── pch.h
│   │   │   ├── rebind.vcxproj
│   │   │   ├── rebind.vcxproj.filters
│   │   │   ├── vcpkg-configuration.json
│   │   │   └── vcpkg.json
│   │   ├── sni_inspector
│   │   │   ├── README.md
│   │   │   ├── pch.h
│   │   │   ├── sni_inspector.vcxproj
│   │   │   ├── sni_inspector.vcxproj.filters
│   │   │   ├── vcpkg-configuration.json
│   │   │   └── vcpkg.json
│   │   ├── socksify
│   │   │   ├── README.md
│   │   │   ├── pch.h
│   │   │   ├── socksify.vcxproj
│   │   │   ├── socksify.vcxproj.filters
│   │   │   ├── vcpkg-configuration.json
│   │   │   └── vcpkg.json
│   │   └── udp2tcp
│   │       ├── README.md
│   │       ├── pch.h
│   │       ├── udp2tcp.vcxproj
│   │       ├── udp2tcp.vcxproj.filters
│   │       ├── vcpkg-configuration.json
│   │       └── vcpkg.json
│   ├── dotNet
│   │   └── TestDotNet
│   │       ├── App.config
│   │       ├── Properties
│   │       ├── README.md
│   │       ├── TestDotNet.csproj
│   │       └── packages.config
│   └── legacy
│       ├── CSharp
│       │   ├── CSharp.sln
│       │   ├── Filter
│       │   │   ├── Filter.csproj
│       │   │   └── Properties
│       │   ├── FilterStats
│       │   │   ├── FilterStats.csproj
│       │   │   └── Properties
│       │   ├── ListAdapters
│       │   │   ├── ListAdapters.csproj
│       │   │   └── Properties
│       │   ├── NdisApi
│       │   │   ├── NdisApiWrapper.csproj
│       │   │   └── Properties
│       │   ├── NdisRequest
│       │   │   ├── NdisRequest.csproj
│       │   │   └── Properties
│       │   ├── PacketSniffer
│       │   │   ├── PacketSniffer.csproj
│       │   │   └── Properties
│       │   └── PassThru
│       │       ├── PassThru.csproj
│       │       └── Properties
│       ├── Delphi
│       │   ├── ListAdapters
│       │   │   ├── ListAdapters.cfg
│       │   │   ├── ListAdapters.dof
│       │   │   └── ListAdapters.dpr
│       │   ├── PacketSniffer
│       │   │   ├── PacketSniffer.cfg
│       │   │   ├── PacketSniffer.dof
│       │   │   └── PacketSniffer.dpr
│       │   ├── PassThru
│       │   │   ├── PassThru.cfg
│       │   │   ├── PassThru.dof
│       │   │   └── PassThru.dpr
│       │   ├── iphlp.pas
│       │   ├── ndisrequest
│       │   │   ├── ndisrequest.cfg
│       │   │   ├── ndisrequest.dof
│       │   │   └── ndisrequest.dpr
│       │   └── winpkf.pas
│       └── MSVC
│           ├── filter
│           │   ├── StdAfx.h
│           │   ├── filter.dsp
│           │   ├── filter.vcxproj
│           │   ├── filter.vcxproj.filters
│           │   └── iphlp.h
│           ├── filterstats
│           │   ├── StdAfx.h
│           │   ├── filterstats.dsp
│           │   ├── filterstats.vcxproj
│           │   ├── filterstats.vcxproj.filters
│           │   └── iphlp.h
│           ├── gretunnel
│           │   ├── StdAfx.h
│           │   ├── gretunnel.dsp
│           │   ├── gretunnel.vcxproj
│           │   ├── gretunnel.vcxproj.filters
│           │   └── iphlp.h
│           ├── legacy.vc6.dsw
│           ├── legacy.vs2012.sln
│           ├── lfnemu
│           │   ├── AckTimerLayer.h
│           │   ├── Common.h
│           │   ├── Finalization.h
│           │   ├── Initialization.h
│           │   ├── PacketDelayerLayer.h
│           │   ├── PacketDropperLayer.h
│           │   ├── StdAfx.h
│           │   ├── iphlp.h
│           │   ├── lfnemu.dsp
│           │   ├── lfnemu.h
│           │   ├── lfnemu.rc
│           │   ├── lfnemu.vcproj
│           │   ├── lfnemu.vcxproj
│           │   ├── lfnemu.vcxproj.filters
│           │   ├── ndisInterfaceLayer.h
│           │   └── resource.h
│           ├── listadapters
│           │   ├── StdAfx.h
│           │   ├── listadapters.dsp
│           │   ├── listadapters.vcxproj
│           │   └── listadapters.vcxproj.filters
│           ├── ndisrequest
│           │   ├── StdAfx.h
│           │   ├── ndisrequest.dsp
│           │   ├── ndisrequest.vcxproj
│           │   └── ndisrequest.vcxproj.filters
│           ├── packetsniffer
│           │   ├── StdAfx.h
│           │   ├── iphlp.h
│           │   ├── packetsniffer.dsp
│           │   ├── packetsniffer.vcxproj
│           │   └── packetsniffer.vcxproj.filters
│           ├── packthru
│           │   ├── StdAfx.h
│           │   ├── iphlp.h
│           │   ├── packthru.dsp
│           │   ├── packthru.vcxproj
│           │   └── packthru.vcxproj.filters
│           ├── passthru
│           │   ├── StdAfx.h
│           │   ├── iphlp.h
│           │   ├── passthru.dsp
│           │   ├── passthru.vcxproj
│           │   └── passthru.vcxproj.filters
│           ├── snat
│           │   ├── NetcardProp.h
│           │   ├── NetworkInterface.h
│           │   ├── iphlp.h
│           │   ├── res
│           │   │   ├── main.ico
│           │   │   ├── modem.ico
│           │   │   ├── netcard.ico
│           │   │   ├── snat.ico
│           │   │   ├── snat.manifest
│           │   │   └── snat.rc2
│           │   ├── resource.h
│           │   ├── snat.h
│           │   ├── snat.rc
│           │   ├── snat.vcxproj
│           │   ├── snat.vcxproj.filters
│           │   ├── snatDlg.h
│           │   ├── stdafx.h
│           │   └── targetver.h
│           └── wwwcensor
│               ├── StdAfx.h
│               ├── iphlp.h
│               ├── wwwcensor.dsp
│               ├── wwwcensor.vcxproj
│               └── wwwcensor.vcxproj.filters
├── include
│   ├── Common.h
│   └── ndisapi.h
├── ndisapi
│   ├── iphlp.h
│   ├── ndisapi.rc
│   ├── precomp.h
│   └── resource.h
├── ndisapi.net
│   ├── Stdafx.h
│   ├── app.ico
│   ├── app.rc
│   ├── ndisapicl.h
│   ├── ndisapicl.vcxproj
│   ├── ndisapicl.vcxproj.filters
│   └── resource.h
├── ndisapi.sln
├── ndisapi.vc6
│   ├── ndisapi.def
│   └── ndisapi.dsp
├── ndisapi.vs2012
│   ├── ndisapi.def
│   ├── ndisapi.vcxproj
│   └── ndisapi.vcxproj.filters
└── tools.cmd

```

`LICENSE`:

```
MIT License

Copyright (c) 2018 Vadim Smirnov

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# NDISAPI

NDISAPI is a comprehensive user-mode interface library designed for seamless interaction with the [Windows Packet Filter](https://www.ntkernel.com/windows-packet-filter/) driver. It stands out by offering a straightforward, safe, and efficient interface for filtering (inspecting and modifying) raw network packets at the NDIS level of the network stack, ensuring minimal impact on network performance.

Windows Packet Filter (WinpkFilter) is a robust and efficient packet filtering framework tailored for Windows environments. It empowers developers to handle raw network packets at the NDIS level with ease, providing capabilities for packet inspection, modification, and control. WinpkFilter boasts user-friendly APIs, compatibility across various Windows versions, and streamlines network packet manipulation without the need for kernel-mode programming skills.

## Key Features

- **Network Adapter Management**: Enumerate and manage network adapter properties.
- **Packet Analysis and Modification**: Capture, filter, and modify network packets.
- **Packet Transmission**: Send raw packets directly through the network stack.

## Resources

- **Homepage**: [Windows Packet Filter](https://www.ntkernel.com/windows-packet-filter/)
- **Comprehensive Documentation**: [Windows Packet Filter Documentation](https://www.ntkernel.com/docs/windows-packet-filter-documentation/)

## Library Components

- **ndisapi.dll**: Native Win32 DLL wrapper (x86/x64/ARM64 versions).
- **ndisapi.lib**: Native Win32 static library wrapper (x86/x64/ARM64 versions).
- **ndisapi.net**: .NET C++/CLI mixed class library (x86/x64/ARM64 versions).
- **ndisapi.vs2012**: Visual Studio 2012 project for native Win32 DLL wrapper, supporting Windows XP/2003 (x86/x64).
- **ndisapi.vc6**: Visual C++ 6.0 project for native Win32 DLL wrapper, supporting legacy Windows versions prior to Windows XP/2003.

## Build Prerequisites for Examples

The example projects included with NDISAPI are set up to automatically manage their dependencies using vcpkg manifests when built with Visual Studio 2022. This process is designed to be straightforward and requires no additional manual installation of dependencies.

### Automated Dependency Management with Visual Studio 2022

- Building the examples in Visual Studio 2022 will automatically resolve and install the required dependencies through the vcpkg manifests. This approach is the simplest and is recommended for most users.

### Alternative: Standalone vcpkg Installation

For those using an environment other than Visual Studio 2022 or preferring manual installation, the following vcpkg commands with specific triplets can be used to install the necessary dependencies:

- **Microsoft GSL (Guideline Support Library)**: Required for all examples.
  ```bash
  vcpkg install ms-gsl:x86-windows ms-gsl:x64-windows ms-gsl:arm64-windows ms-gsl:x86-windows-static ms-gsl:x64-windows-static ms-gsl:arm64-windows-static
  ```

- **PcapPlusPlus**: Required only for the `pcapplusplus` example.
  ```bash
  vcpkg install pcapplusplus:x86-windows pcapplusplus:x64-windows
  ```

- **Hyperscan and llhttp**: Required only for the `hyperscan` example.
  - Install Hyperscan:
    ```bash
    vcpkg install hyperscan:x86-windows hyperscan:x64-windows
    ```
  - Install llhttp:
    ```bash
    vcpkg install llhttp:x86-windows llhttp:x64-windows
    ```

### Note

- Using Visual Studio 2022 with built-in vcpkg support is the preferred method for building the examples, as it greatly simplifies the process of dependency management.
- The standalone vcpkg commands with specific triplets are provided as an alternative for those who require manual installation or are working in different environments.

## Example Projects

### Basic C++ Examples

Ideal for beginners, these examples showcase the fundamental capabilities of NDISAPI. They are adaptable to different development environments and Windows versions:

- **With Visual C++ 6.0**: Binaries are compatible with Windows 95/NT and later operating systems.
- **With Visual Studio 2012**: Suitable for running on Windows XP/2003 and later.

The examples include:

- **listadapters**: Enumerates network adapters and their properties.
- **packetsniffer**: Introduces the basics of network packet sniffing.
- **passthru**: Demonstrates single packet processing techniques.
- **packthru**: Explores handling of multiple network packets simultaneously.
- **ndisrequest**: Shows how to send NDIS requests to network adapters.
- **filter**: Uses built-in static filters for selective packet filtering.
- **wwwcensor**: Implements content filtering in HTTP packets based on specific keywords.
- **gretunnel**: Demonstrates IP over GRE tunneling, modifying packet headers.

### Advanced C++ Examples (Visual Studio 2012)

Designed for users with advanced knowledge, these examples delve into more complex functionalities of NDISAPI.

- **snat**: A simple MFC Internet Connection sharing application.
- **lfnemu**: Long Fat Network (LFN) Emulator for simulating LFN behavior over local networks.

### Advanced C++ Examples (Visual Studio 2022)

These examples are intended for experienced users, showcasing sophisticated use of NDISAPI:

- **capture**: Captures and saves network packets in PCAP format.
- **dns_proxy**: Implements a transparent UDP proxy for the DNS protocol.
- **dnstrace**: Intercepts and decodes DNS responses.
- **ethernet_bridge**: Bridges wired and wireless network connections.
- **ipv6_parser**: Intercepts IPv6 packets and parses protocol headers.
- **sni_inspector**: Extracts SNI and Host headers from HTTPS and HTTP packets.
- **socksify**: Redirects TCP connections through a SOCKS5 proxy.
- **udp2tcp**: Converts between UDP and TCP protocols.
- **rebind**: Rebinds TCP/UDP connections to different network interfaces.
- **pcapplusplus**: Utilizes PcapPlusPlus for packet parsing and TLS fingerprinting.
- **hyperscan**: Detects HTTP sessions using Hyperscan and parses HTTP with llhttp.

### Very Advanced C++ Example

- **[ProxiFyre](https://github.com/wiresock/proxifyre)**: An advanced evolution of the Windows Packet Filter's socksify example, ProxiFyre enhances its capabilities by adding UDP support and facilitating the management of multiple proxy instances.

### C# Examples

For C# developers:

- **TestDotNet**: Showcases NDISAPI in filtering scenarios, using [PacketDotNet](https://github.com/chmorgan/packetnet) for network packet header analysis.
```

`cygwin/Makefile`:

```
# Compiler settings
CC = g++
CFLAGS = -I$(INCDIR) -Wall -std=c++11 -D_LIB -DCYGWIN_BUILD -D_UNICODE -DUNICODE

# Build configuration
ARCH ?= x64
CONFIG ?= Release

# Set architecture and configuration specific flags
ifeq ($(ARCH),x86)
	CFLAGS += -m32
	OUTPUT_DIR = bin/x86
else
	CFLAGS += -m64
	OUTPUT_DIR = bin/x64
endif

ifeq ($(CONFIG),Debug)
	CFLAGS += -g
	OUTPUT_DIR := $(OUTPUT_DIR)/Debug
else
	CFLAGS += -O2
	OUTPUT_DIR := $(OUTPUT_DIR)/Release
endif

# Directories
SRCDIR = ../ndisapi
INCDIR = ../include

# Source and header files for the library
LIB_SOURCES = $(SRCDIR)/ndisapi.cpp
LIB_HEADERS = $(INCDIR)/Common.h $(INCDIR)/ndisapi.h $(SRCDIR)/iphlp.h $(SRCDIR)/precomp.h $(SRCDIR)/resource.h
LIB_OBJECTS = $(patsubst $(SRCDIR)/%.cpp, $(OUTPUT_DIR)/%.o, $(LIB_SOURCES))
LIBRARY = $(OUTPUT_DIR)/libndisapi.a  # Renaming library file

# Source files for the listadapters example
LISTADAPTERS_SRCS = ../examples/legacy/MSVC/listadapters/listadapters.cpp ../examples/legacy/MSVC/listadapters/StdAfx.cpp
LISTADAPTERS_OBJS = $(patsubst ../examples/legacy/MSVC/listadapters/%.cpp, $(OUTPUT_DIR)/%.o, $(LISTADAPTERS_SRCS))
LISTADAPTERS_EXE = $(OUTPUT_DIR)/listadapters

# Source files for the packthru example
PACKTHRU_SRCS = ../examples/legacy/MSVC/packthru/packthru.cpp ../examples/legacy/MSVC/packthru/StdAfx.cpp
PACKTHRU_OBJS = $(patsubst ../examples/legacy/MSVC/packthru/%.cpp, $(OUTPUT_DIR)/%.o, $(PACKTHRU_SRCS))
PACKTHRU_EXE = $(OUTPUT_DIR)/packthru

# Source files for the filter example
FILTER_SRCS = ../examples/legacy/MSVC/filter/filter.cpp ../examples/legacy/MSVC/filter/StdAfx.cpp
FILTER_OBJS = $(patsubst ../examples/legacy/MSVC/filter/%.cpp, $(OUTPUT_DIR)/%.o, $(FILTER_SRCS))
FILTER_EXE = $(OUTPUT_DIR)/filter

# Source files for the filterstats example
FILTERSTATS_SRCS = ../examples/legacy/MSVC/filterstats/filterstats.cpp ../examples/legacy/MSVC/filterstats/StdAfx.cpp
FILTERSTATS_OBJS = $(patsubst ../examples/legacy/MSVC/filterstats/%.cpp, $(OUTPUT_DIR)/%.o, $(FILTERSTATS_SRCS))
FILTERSTATS_EXE = $(OUTPUT_DIR)/filterstats

# Source files for the gretunnel example
GRETUNNEL_SRCS = ../examples/legacy/MSVC/gretunnel/gretunnel.cpp ../examples/legacy/MSVC/gretunnel/StdAfx.cpp
GRETUNNEL_OBJS = $(patsubst ../examples/legacy/MSVC/gretunnel/%.cpp, $(OUTPUT_DIR)/%.o, $(GRETUNNEL_SRCS))
GRETUNNEL_EXE = $(OUTPUT_DIR)/gretunnel

# Source files for the ndisrequest example
NDISREQUEST_SRCS = ../examples/legacy/MSVC/ndisrequest/ndisrequest.cpp ../examples/legacy/MSVC/ndisrequest/StdAfx.cpp
NDISREQUEST_OBJS = $(patsubst ../examples/legacy/MSVC/ndisrequest/%.cpp, $(OUTPUT_DIR)/%.o, $(NDISREQUEST_SRCS))
NDISREQUEST_EXE = $(OUTPUT_DIR)/ndisrequest

# Source files for the packetsniffer example
PACKETSNIFFER_SRCS = ../examples/legacy/MSVC/packetsniffer/packetsniffer.cpp ../examples/legacy/MSVC/packetsniffer/StdAfx.cpp
PACKETSNIFFER_OBJS = $(patsubst ../examples/legacy/MSVC/packetsniffer/%.cpp, $(OUTPUT_DIR)/%.o, $(PACKETSNIFFER_SRCS))
PACKETSNIFFER_EXE = $(OUTPUT_DIR)/packetsniffer

# Source files for the passthru example
PASSTHRU_SRCS = ../examples/legacy/MSVC/passthru/passthru.cpp ../examples/legacy/MSVC/passthru/StdAfx.cpp
PASSTHRU_OBJS = $(patsubst ../examples/legacy/MSVC/passthru/%.cpp, $(OUTPUT_DIR)/%.o, $(PASSTHRU_SRCS))
PASSTHRU_EXE = $(OUTPUT_DIR)/passthru

# Source files for the wwwcensor example
WWWCENSOR_SRCS = ../examples/legacy/MSVC/wwwcensor/wwwcensor.cpp ../examples/legacy/MSVC/wwwcensor/StdAfx.cpp
WWWCENSOR_OBJS = $(patsubst ../examples/legacy/MSVC/wwwcensor/%.cpp, $(OUTPUT_DIR)/%.o, $(WWWCENSOR_SRCS))
WWWCENSOR_EXE = $(OUTPUT_DIR)/wwwcensor

# Targets
all: $(LIBRARY) $(LISTADAPTERS_EXE) $(PACKTHRU_EXE) $(FILTER_EXE) $(FILTERSTATS_EXE) $(GERTUNNEL_EXE) $(NDISREQUEST_EXE) $(PACKETSNIFFER_EXE) $(PASSTHRU_EXE) $(WWWCENSOR_EXE)

# Library compilation
$(LIBRARY): $(LIB_OBJECTS)
	ar rcs $(LIBRARY) $(LIB_OBJECTS)

$(OUTPUT_DIR)/%.o: $(SRCDIR)/%.cpp $(LIB_HEADERS)
	mkdir -p $(OUTPUT_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

# Listadapters example compilation
$(LISTADAPTERS_EXE): $(LISTADAPTERS_OBJS) $(LIBRARY)
	$(CC) $(CFLAGS) $^ -o $@ -L$(OUTPUT_DIR) -lndisapi  # Updated linker flag

$(OUTPUT_DIR)/%.o: ../examples/legacy/MSVC/listadapters/%.cpp
	mkdir -p $(OUTPUT_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

# PackThru example compilation
$(PACKTHRU_EXE): $(PACKTHRU_OBJS) $(LIBRARY)
	$(CC) $(CFLAGS) $^ -o $@ -L$(OUTPUT_DIR) -lndisapi  # Updated linker flag

$(OUTPUT_DIR)/%.o: ../examples/legacy/MSVC/packthru/%.cpp
	mkdir -p $(OUTPUT_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

# Filter example compilation
$(FILTER_EXE): $(FILTER_OBJS) $(LIBRARY)
	$(CC) $(CFLAGS) $^ -o $@ -L$(OUTPUT_DIR) -lndisapi

$(OUTPUT_DIR)/%.o: ../examples/legacy/MSVC/filter/%.cpp
	mkdir -p $(OUTPUT_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

# FilterStats example compilation
$(FILTERSTATS_EXE): $(FILTERSTATS_OBJS) $(LIBRARY)
	$(CC) $(CFLAGS) $^ -o $@ -L$(OUTPUT_DIR) -lndisapi

$(OUTPUT_DIR)/%.o: ../examples/legacy/MSVC/filterstats/%.cpp
	mkdir -p $(OUTPUT_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

# GRETunnel example compilation
$(GRETUNNEL_EXE): $(GRETUNNEL_OBJS) $(LIBRARY)
	$(CC) $(CFLAGS) $^ -o $@ -L$(OUTPUT_DIR) -lndisapi

$(OUTPUT_DIR)/%.o: ../examples/legacy/MSVC/gertunnel/%.cpp
	mkdir -p $(OUTPUT_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

# NdisRequest example compilation
$(NDISREQUEST_EXE): $(NDISREQUEST_OBJS) $(LIBRARY)
	$(CC) $(CFLAGS) $^ -o $@ -L$(OUTPUT_DIR) -lndisapi

$(OUTPUT_DIR)/%.o: ../examples/legacy/MSVC/ndisrequest/%.cpp
	mkdir -p $(OUTPUT_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

# PacketSniffer example compilation
$(PACKETSNIFFER_EXE): $(PACKETSNIFFER_OBJS) $(LIBRARY)
	$(CC) $(CFLAGS) $^ -o $@ -L$(OUTPUT_DIR) -lndisapi

$(OUTPUT_DIR)/%.o: ../examples/legacy/MSVC/packetsniffer/%.cpp
	mkdir -p $(OUTPUT_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

# PassThru example compilation
$(PASSTHRU_EXE): $(PASSTHRU_OBJS) $(LIBRARY)
	$(CC) $(CFLAGS) $^ -o $@ -L$(OUTPUT_DIR) -lndisapi

$(OUTPUT_DIR)/%.o: ../examples/legacy/MSVC/passthru/%.cpp
	mkdir -p $(OUTPUT_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

# WWWCensor example compilation 	
$(WWWCENSOR_EXE): $(WWWCENSOR_OBJS) $(LIBRARY)
	$(CC) $(CFLAGS) $^ -o $@ -L$(OUTPUT_DIR) -lndisapi

$(OUTPUT_DIR)/%.o: ../examples/legacy/MSVC/wwwcensor/%.cpp
	mkdir -p $(OUTPUT_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

# Clean
clean:
	rm -rf bin





```

`cygwin/README.md`:

```md
# NDISAPI Library for Cygwin

This directory contains the Makefile and instructions to build the Cygwin variant of the NDISAPI static library and basic example applications.

## Prerequisites

- Cygwin environment with `g++` and standard build tools installed.
- Source files for the `ndisapi` library and examples.

## Building the Library

1. Open your Cygwin terminal.
2. Navigate to the `cygwin` directory within the `ndisapi` library repository.
3. Run `make` to build the static library and all basic examples.

   ```bash
   make
   ```

This will compile the `ndisapi` static library and the following example applications:

- `listadapters`
- `packthru`
- `filter`
- `filterstats`
- `gretunnel`
- `ndisrequest`
- `packetsniffer`
- `passthru`
- `wwwcensor`

## Cleaning Build Artifacts

To clean up all build artifacts, run:

```bash
make clean
```

## Example Usage

After building, you can run the example applications directly from the `bin` directory. For instance, to run `listadapters`:

```bash
./bin/x64/Release/listadapters
```

(Adjust the path based on your build architecture and configuration.)

## Demo Output

Here are brief examples of the output you can expect from running the `listadapters` and `packthru` samples:

### listadapters

```bash
$ ./bin/x64/Release/listadapters
The following network interfaces are available to MSTCP:
1) Ethernet.
        Internal Name:   \DEVICE\{...}
        Current MAC:     B04F13FB9614
        ...
2) Local Area Connection* 2.
        Internal Name:   \DEVICE\{...}
        Current MAC:     3E219C3EC44D
        ...
... (additional interfaces listed here) ...
```

### packthru

```bash
$ ./bin/x64/Release/packthru 4 5
1 packet received from the driver

4 - Interface --> MSTCP
        Packet size = 42
        Source MAC:              50FF20902F15
        Destination MAC:         FFFFFFFFFFFF
        ... (packet details) ...
Sending 1 packets to protocols
... (additional packet details) ...
Filtering complete
```

These outputs are just excerpts to demonstrate the format. When you run these samples in your environment, you'll see detailed information specific to your network interfaces and traffic.

## Notes

- The provided Makefile is configured for the Cygwin environment. For other environments, modifications may be necessary.

```

`cygwin/build_all.bat`:

```bat
@echo off
SETLOCAL

ECHO Building for x86 Debug...
make ARCH=x86 CONFIG=Debug

ECHO Building for x86 Release...
make ARCH=x86 CONFIG=Release

ECHO Building for x64 Debug...
make ARCH=x64 CONFIG=Debug

ECHO Building for x64 Release...
make ARCH=x64 CONFIG=Release

ENDLOCAL
ECHO Build process completed.

```

`examples/cpp/capture/README.md`:

```md
# Capture Packet Filter

## Overview

This project is an example of how to intercept network packets, write packet data into a file, and pass them on, facilitating packet analysis and troubleshooting. The `Windows Packet Filter` driver must be loaded for the program to run.

## Code Description

The main function of this program initiates a unique pointer to a `ndisapi::fastio_packet_filter` object. This object has two main lambda functions:

1. The first lambda function is triggered for each incoming packet. It writes the packet data to a file and then passes the packet back to the filter.
2. The second lambda function is triggered for each outgoing packet. It writes the packet data to the file and then passes the packet back to the filter.

After initialization, the program checks whether the `Windows Packet Filter` driver is loaded. If not, the program exits. If the driver is loaded, the program displays a list of available network interfaces and prompts the user to select an interface for filtering.

The user is then prompted to enter a filename where the packet capture will be saved. If the file opens successfully, the program begins filtering traffic on the selected interface. The user can stop filtering at any time by pressing any key.

## Usage

Compile and run the program. Follow the prompts to choose a network interface and specify a filename for the capture. Press any key to stop filtering.


```

`examples/cpp/capture/capture.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{BB2DF044-0B37-4335-B705-3CA6BA95514F}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>fastiotest</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnableManifest>true</VcpkgEnableManifest>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\common\ndisapi\fastio_packet_filter.h" />
    <ClInclude Include="..\common\pcap\pcap.h" />
    <ClInclude Include="..\common\pcap\pcap_file_storage.h" />
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="capture.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg-configuration.json" />
    <None Include="vcpkg.json" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/cpp/capture/capture.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\common">
      <UniqueIdentifier>{f58d99f8-6dfc-44e1-9ff2-381efcda5d4d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\ndisapi">
      <UniqueIdentifier>{b7bffef8-2d56-4887-94c9-a3a5c019c40c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\pcap">
      <UniqueIdentifier>{f8f844ac-af18-47de-9cc8-a3859a76d08b}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\common\ndisapi\fastio_packet_filter.h">
      <Filter>Header Files\common\ndisapi</Filter>
    </ClInclude>
    <ClInclude Include="..\common\pcap\pcap.h">
      <Filter>Header Files\common\pcap</Filter>
    </ClInclude>
    <ClInclude Include="..\common\pcap\pcap_file_storage.h">
      <Filter>Header Files\common\pcap</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="capture.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg.json" />
    <None Include="vcpkg-configuration.json" />
  </ItemGroup>
</Project>
```

`examples/cpp/capture/pch.h`:

```h
// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

#ifndef PCH_H
#define PCH_H

#include <winsock2.h>
#include <in6addr.h>
#include <tchar.h>
#include <ws2ipdef.h>
#include <IPHlpApi.h>
#include <Mstcpip.h>
#include <conio.h>
#include <WinDNS.h>

#include <memory>
#include <iostream>
#include <iomanip>
#include <chrono>
#include <thread>
#include <limits>
#include <atomic>
#include <string>
#include <functional>
#include <vector>
#include <cassert>
#include <array>
#include <map>
#include <cctype>
#include <shared_mutex>
#include <variant>
#include <bitset>
#include <optional>
#include <algorithm>
#include <fstream>
#include <charconv>
#include <gsl/gsl>

#include "../../../include/common.h"
#include "../../../include/ndisapi.h"
#include "../common/pcap/pcap.h"
#include "../common/pcap/pcap_file_storage.h"
#include "../common/iphlp.h"
#include "../common/winsys/object.h"
#include "../common/winsys/event.h"
#include "../common/net/mac_address.h"
#include "../common/net/ip_address.h"
#include "../common/net/ip_subnet.h"
#include "../common/iphelper/network_adapter_info.h"
#include "../common/ndisapi/network_adapter.h"
#include "../common/ndisapi/fastio_packet_filter.h"

#endif //PCH_H

```

`examples/cpp/capture/vcpkg-configuration.json`:

```json
{
  "default-registry": {
    "kind": "git",
    "baseline": "10b7a178346f3f0abef60cecd5130e295afd8da4",
    "repository": "https://github.com/microsoft/vcpkg"
  },
  "registries": [
    {
      "kind": "artifact",
      "location": "https://github.com/microsoft/vcpkg-ce-catalog/archive/refs/heads/main.zip",
      "name": "microsoft"
    }
  ]
}

```

`examples/cpp/capture/vcpkg.json`:

```json
{
  "dependencies": [
    "ms-gsl"
  ]
}

```

`examples/cpp/common/README.md`:

```md
# netlib

Utility C++ classes used for the network development.

```

`examples/cpp/common/dhcp_typedefs.h`:

```h
// --------------------------------------------------------------------------------
/// <summary>
/// Module Name:  dhcp_typedefs.h
/// Abstract: DHCP protocol definitions
/// </summary>
// --------------------------------------------------------------------------------

#pragma once

/* options: */
#define DEFAULT_LEASE_TIME      (1 * 356 * 24 * 60 * 60) /* 1 year */
#define DEFAULT_SUBNET_MASK     "255.255.255.0"
//#define DEFAULT_SUBNET_MASK     "255.255.255.64"

enum { broadcast = 0xffffffff };

#ifndef s_addr
#define s_addr S_un.S_addr
#endif /* s_addr */

#ifndef INADDR_ANY
#define INADDR_ANY 0
#endif /* INADDR_ANY */

#define IPPORT_DHCPS            67
#define IPPORT_DHCPC            68

/* reference: http://tools.ietf.org/html/rfc2131 */

#define DHCP_UDP_OVERHEAD       (20 + /* IP header */                   \
                                8)   /* UDP header */
#define DHCP_ETHERNET_OVERHEAD  (14 +/* ETHERNET header */              \
                                20 + /* IP header */                    \
                                8)   /* UDP header */
#define DHCP_SNAME_LEN          64
#define DHCP_FILE_LEN           128
#define DHCP_FIXED_NON_UDP      236
#define DHCP_FIXED_LEN          (DHCP_FIXED_NON_UDP + DHCP_UDP_OVERHEAD)
                                            /* Everything but options. */
#define BOOTP_MIN_LEN           300

#define DHCP_MTU_MAX            1500
#define DHCP_MTU_MIN            576

#define DHCP_MAX_OPTION_LEN     (DHCP_MTU_MAX - DHCP_FIXED_LEN)
#define DHCP_MIN_OPTION_LEN     (DHCP_MTU_MIN - DHCP_FIXED_LEN)

/*
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     op (1)    |   htype (1)   |   hlen (1)    |   hops (1)    |
   +---------------+---------------+---------------+---------------+
   |                            xid (4)                            |
   +-------------------------------+-------------------------------+
   |           secs (2)            |           flags (2)           |
   +-------------------------------+-------------------------------+
   |                          ciaddr  (4)                          |
   +---------------------------------------------------------------+
   |                          yiaddr  (4)                          |
   +---------------------------------------------------------------+
   |                          siaddr  (4)                          |
   +---------------------------------------------------------------+
   |                          giaddr  (4)                          |
   +---------------------------------------------------------------+
   |                                                               |
   |                          chaddr  (16)                         |
   |                                                               |
   |                                                               |
   +---------------------------------------------------------------+
   |                                                               |
   |                          sname   (64)                         |
   +---------------------------------------------------------------+
   |                                                               |
   |                          file    (128)                        |
   +---------------------------------------------------------------+
   |                                                               |
   |                          options (variable)                   |
   +---------------------------------------------------------------+

*/

struct dhcp_packet {
  uint8_t        op;        /* Message op code / message type. 1 = BOOTREQUEST, 2 = BOOTREPLY */
  uint8_t        htype;     /* Hardware address type, see ARP section in "Assigned Numbers" RFC; e.g., '1' = 10mb ethernet. */
  uint8_t        hlen;      /* Hardware address length (e.g.  '6' for 10mb ethernet). */
  uint8_t        hops;      /* Client sets to zero, optionally used by relay agents when booting via a relay agent. */
  uint32_t       xid;       /* Transaction ID, a random number chosen by the client, used by the client and server to associate
                               messages and responses between a client and a server. */
  uint16_t       secs;      /* Filled in by client, seconds elapsed since client began address acquisition or renewal process. */
  uint16_t       flags;     /* Flags */
  struct in_addr ciaddr;    /* Client IP address; only filled in if client is in BOUND, RENEW or REBINDING state and can respond
                               to ARP requests.*/
  struct in_addr yiaddr;    /* 'your' (client) IP address. */
  struct in_addr siaddr;    /* IP address of next server to use in bootstrap; returned in DHCPOFFER, DHCPACK by server. */
  struct in_addr giaddr;    /* Relay agent IP address, used in booting via a relay agent. */
  uint8_t        chaddr[16];/* Client hardware (MAC) address. */ 
  char           sname[DHCP_SNAME_LEN]; 
                            /* Optional server host name, null terminated string. */
  char           file[DHCP_FILE_LEN]; 
                            /* Boot file name, null terminated string; "generic" name or null in DHCPDISCOVER, fully qualified
                               directory-path name in DHCPOFFER. */
  uint8_t        options[DHCP_MAX_OPTION_LEN]; 
                            /* Optional parameters, first bytes is magic numbers 99, 130, 83, 99 */
}; 

//#define dhcp_size (sizeof(ether_header) + sizeof(iphdr) + sizeof(udphdr) + sizeof(struct dhcp_packet))

/* BOOTP (rfc951) message types */
#define	BOOTREQUEST     1
#define BOOTREPLY       2

/* Possible values for flags field... */
#define BOOTP_BROADCAST 32768L

/* Possible values for hardware type (htype) field... */
#define HTYPE_ETHER     1               /* Ethernet 10Mbps              */
#define HTYPE_IEEE802   6               /* IEEE 802.2 Token Ring...     */
#define HTYPE_FDDI      8               /* FDDI...                      */

/* Magic cookie validating dhcp options field (and bootp vendor
   extensions field). */
#define DHCP_OPTIONS_COOKIE                     "\x63\x82\x53\x63"

#define DHCP_OPTIONS_OFFS (offsetof(struct dhcp_packet, options) + sizeof(DHCP_OPTIONS_COOKIE) - 1)

/* DHCP Option codes: */
#define DHO_PAD                                 0
#define DHO_SUBNET_MASK                         1
#define DHO_TIME_OFFSET                         2
#define DHO_ROUTERS                             3
#define DHO_TIME_SERVERS                        4
#define DHO_NAME_SERVERS                        5
#define DHO_DOMAIN_NAME_SERVERS                 6
#define DHO_LOG_SERVERS                         7
#define DHO_COOKIE_SERVERS                      8
#define DHO_LPR_SERVERS                         9
#define DHO_IMPRESS_SERVERS                     10
#define DHO_RESOURCE_LOCATION_SERVERS           11
#define DHO_HOST_NAME                           12
#define DHO_BOOT_SIZE                           13
#define DHO_MERIT_DUMP                          14
#define DHO_DOMAIN_NAME                         15
#define DHO_SWAP_SERVER                         16
#define DHO_ROOT_PATH                           17
#define DHO_EXTENSIONS_PATH                     18
#define DHO_IP_FORWARDING                       19
#define DHO_NON_LOCAL_SOURCE_ROUTING            20
#define DHO_POLICY_FILTER                       21
#define DHO_MAX_DGRAM_REASSEMBLY                22
#define DHO_DEFAULT_IP_TTL                      23
#define DHO_PATH_MTU_AGING_TIMEOUT              24
#define DHO_PATH_MTU_PLATEAU_TABLE              25
#define DHO_INTERFACE_MTU                       26
#define DHO_ALL_SUBNETS_LOCAL                   27
#define DHO_BROADCAST_ADDRESS                   28
#define DHO_PERFORM_MASK_DISCOVERY              29
#define DHO_MASK_SUPPLIER                       30
#define DHO_ROUTER_DISCOVERY                    31
#define DHO_ROUTER_SOLICITATION_ADDRESS         32
#define DHO_STATIC_ROUTES                       33
#define DHO_TRAILER_ENCAPSULATION               34
#define DHO_ARP_CACHE_TIMEOUT                   35
#define DHO_IEEE802_3_ENCAPSULATION             36
#define DHO_DEFAULT_TCP_TTL                     37
#define DHO_TCP_KEEPALIVE_INTERVAL              38
#define DHO_TCP_KEEPALIVE_GARBAGE               39
#define DHO_NIS_DOMAIN                          40
#define DHO_NIS_SERVERS                         41
#define DHO_NTP_SERVERS                         42
#define DHO_VENDOR_ENCAPSULATED_OPTIONS         43
#define DHO_NETBIOS_NAME_SERVERS                44
#define DHO_NETBIOS_DD_SERVER                   45
#define DHO_NETBIOS_NODE_TYPE                   46
#define DHO_NETBIOS_SCOPE                       47
#define DHO_FONT_SERVERS                        48
#define DHO_X_DISPLAY_MANAGER                   49
#define DHO_DHCP_REQUESTED_ADDRESS              50
#define DHO_DHCP_LEASE_TIME                     51
#define DHO_DHCP_OPTION_OVERLOAD                52
#define DHO_DHCP_MESSAGE_TYPE                   53
#define DHO_DHCP_SERVER_IDENTIFIER              54
#define DHO_DHCP_PARAMETER_REQUEST_LIST         55
#define DHO_DHCP_MESSAGE                        56
#define DHO_DHCP_MAX_MESSAGE_SIZE               57
#define DHO_DHCP_RENEWAL_TIME                   58
#define DHO_DHCP_REBINDING_TIME                 59
#define DHO_VENDOR_CLASS_IDENTIFIER             60
#define DHO_DHCP_CLIENT_IDENTIFIER              61
#define DHO_NWIP_DOMAIN_NAME                    62
#define DHO_NWIP_SUBOPTIONS                     63
#define DHO_USER_CLASS                          77
#define DHO_FQDN                                81
#define DHO_DHCP_AGENT_OPTIONS                  82
#define DHO_AUTHENTICATE                        90  /* RFC3118, was 210 */
#define DHO_CLIENT_LAST_TRANSACTION_TIME        91
#define DHO_ASSOCIATED_IP                       92
#define DHO_SUBNET_SELECTION                    118 /* RFC3011! */
#define DHO_DOMAIN_SEARCH                       119 /* RFC3397 */
#define DHO_VIVCO_SUBOPTIONS                    124
#define DHO_VIVSO_SUBOPTIONS                    125

#define DHO_END                                 255

/* DHCP message types. */
#define DHCPDISCOVER            1
#define DHCPOFFER               2
#define DHCPREQUEST             3
#define DHCPDECLINE             4
#define DHCPACK                 5
#define DHCPNAK                 6
#define DHCPRELEASE             7
#define DHCPINFORM              8
#define DHCPLEASEQUERY          10
#define DHCPLEASEUNASSIGNED     11
#define DHCPLEASEUNKNOWN        12
#define DHCPLEASEACTIVE         13

/* Relay Agent Information option subtypes: */
#define RAI_CIRCUIT_ID  1
#define RAI_REMOTE_ID   2
#define RAI_AGENT_ID    3
#define RAI_LINK_SELECT 5

/* FQDN suboptions: */
#define FQDN_NO_CLIENT_UPDATE           1
#define FQDN_SERVER_UPDATE              2
#define FQDN_ENCODED                    3
#define FQDN_RCODE1                     4
#define FQDN_RCODE2                     5
#define FQDN_HOSTNAME                   6
#define FQDN_DOMAINNAME                 7
#define FQDN_FQDN                       8
#define FQDN_SUBOPTION_COUNT            8

struct option {
  uint8_t code; 
  uint8_t len; 
  uint8_t *data; 
};

struct option_state {
  struct option *cache; 
  size_t count; 
};

/* A dhcp packet and the pointers to its option values. */
struct packet {
  struct dhcp_packet *raw; 
  size_t packet_length; 
  int packet_type; 

  bool options_valid; 
  struct in_addr client_addr; 
  uint16_t client_port; 
  struct ether_header hw;
  struct in_addr server_addr; 
  HANDLE hAdapter; 
  uint8_t direction;
  bool got_requested_address;

  struct option_state *options;
};

/* A dhcp lease declaration structure. */
struct lease {
  struct in_addr ip_addr; 
  struct in_addr subnet_addr; 
  struct in_addr subnet_mask; 
  struct in_addr dns_server; 
  time_t start; 
  time_t end; 
  char client_hostname[32];
};

/* [EOF] */

```

`examples/cpp/common/iphelper/network_adapter_info.h`:

```h
// ReSharper disable CppSpecialFunctionWithoutNoexceptSpecification
// ReSharper disable CppClangTidyClangDiagnosticMissingBraces
// ReSharper disable CppClangTidyClangDiagnosticMissingFieldInitializers
#pragma once

namespace iphelper
{
	/// <summary>
	/// Equality comparison operator for the IF_LUID type
	/// </summary>
	/// <param name="lhs">left hand parameter</param>
	/// <param name="rhs">right hand parameter</param>
	/// <returns>true if equal, false otherwise</returns>
	inline bool operator==(const IF_LUID& lhs, const IF_LUID& rhs)
	{
		return (lhs.Value == rhs.Value) && (lhs.Info.IfType == rhs.Info.IfType) && (lhs.Info.NetLuidIndex == rhs.Info.
			NetLuidIndex);
	}

	/// <summary>
	/// Non-equality comparison operator for the IF_LUID type
	/// </summary>
	/// <param name="lhs">left hand parameter</param>
	/// <param name="rhs">right hand parameter</param>
	/// <returns>true if non-equal, false otherwise</returns>
	inline bool operator!=(const IF_LUID& lhs, const IF_LUID& rhs) { return !(lhs == rhs); }

	/// <summary>
	/// Less comparison operator for the IF_LUID type
	/// </summary>
	/// <param name="lhs">left hand parameter</param>
	/// <param name="rhs">right hand parameter</param>
	/// <returns>true if left is less, false otherwise</returns>
	inline bool operator<(const IF_LUID& lhs, const IF_LUID& rhs)
	{
		return std::tie(lhs.Value, lhs.Info.IfType, lhs.Info.NetLuidIndex) < std::tie(
			rhs.Value, rhs.Info.IfType, rhs.Info.NetLuidIndex);
	}

	// --------------------------------------------------------------------------------
	/// <summary>
	/// Simple wrapper for SOCKADDR_STORAGE
	/// </summary>
	// --------------------------------------------------------------------------------
	struct ip_address_info : SOCKADDR_STORAGE
	{
		/// <summary>
		/// Default constructor
		/// </summary>
		ip_address_info() : SOCKADDR_STORAGE()
		{
		}

		/// <summary>
		/// Constructs ip_address_info from sockaddr
		/// </summary>
		/// <param name="address"></param>
		explicit ip_address_info(const sockaddr& address) : SOCKADDR_STORAGE()
		{
			*reinterpret_cast<sockaddr*>(this) = address;
		}

		/// <summary>
		/// Constructs ip_address_info from sockaddr_in
		/// </summary>
		/// <param name="address"></param>
		explicit ip_address_info(const sockaddr_in& address) : SOCKADDR_STORAGE()
		{
			*reinterpret_cast<sockaddr_in*>(this) = address;
		}

		/// <summary>
		/// Constructs ip_address_info from sockaddr_in6
		/// </summary>
		/// <param name="address"></param>
		explicit ip_address_info(const sockaddr_in6& address) : SOCKADDR_STORAGE()
		{
			*reinterpret_cast<sockaddr_in6*>(this) = address;
		}

		/// <summary>
		/// Constructs ip_address_info from SOCKET_ADDRESS
		/// </summary>
		/// <param name="address"></param>
		explicit ip_address_info(const SOCKET_ADDRESS& address) : SOCKADDR_STORAGE()
		{
			memcpy(this, address.lpSockaddr, address.iSockaddrLength);
		}

		/// <summary>
		/// Constructs ip_address_info from net::ip_address_v4
		/// </summary>
		/// <param name="address"></param>
		explicit ip_address_info(const net::ip_address_v4& address) : SOCKADDR_STORAGE()
		{
			ss_family = AF_INET;
			(reinterpret_cast<sockaddr_in*>(this))->sin_addr = address;
		}

		/// <summary>
		/// Constructs ip_address_info from net::ip_address_v6
		/// </summary>
		/// <param name="address"></param>
		explicit ip_address_info(const net::ip_address_v6& address) : SOCKADDR_STORAGE()
		{
			ss_family = AF_INET6;
			(reinterpret_cast<sockaddr_in6*>(this))->sin6_addr = address;
		}

		/// <summary>
		/// Typecast operator to sockaddr type
		/// </summary>
		explicit operator sockaddr() const { return *reinterpret_cast<sockaddr*>(const_cast<ip_address_info*>(this)); }

		/// <summary>
		/// Typecast operator to sockaddr_in
		/// </summary>
		explicit operator sockaddr_in() const
		{
			return *reinterpret_cast<sockaddr_in*>(const_cast<ip_address_info*>(this));
		}

		/// <summary>
		/// Typecast operator to sockaddr_in6
		/// </summary>
		explicit operator sockaddr_in6() const
		{
			return *reinterpret_cast<sockaddr_in6*>(const_cast<ip_address_info*>(this));
		}

		/// <summary>
		/// Equality operator
		/// </summary>
		/// <param name="rhs">ip_address_info to compare to</param>
		/// <returns>true if equal, false otherwise</returns>
		bool operator==(const ip_address_info& rhs) const
		{
			if (ss_family != rhs.ss_family)
				return false;

			switch (ss_family)
			{
			case AF_INET:
				return ((reinterpret_cast<const sockaddr_in*>(this))->sin_addr.S_un.S_addr == (reinterpret_cast<const
					sockaddr_in&>(rhs)).sin_addr.S_un.S_addr);
			case AF_INET6:
				return (0 == std::memcmp(reinterpret_cast<const sockaddr_in6*>(this)->sin6_addr.u.Word,
				                         reinterpret_cast<const sockaddr_in6&>(rhs).sin6_addr.u.Word,
				                         sizeof(sockaddr_in6::sin6_addr)));
			default:
				break;
			}

			return false;
		}

		/// <summary>
		/// Typecast operator to std::string
		/// </summary>
		explicit operator std::string() const
		{
			return (ss_family == AF_INET)
				       ? std::string(net::ip_address_v4((reinterpret_cast<const sockaddr_in*>(this))->sin_addr))
				       : std::string(net::ip_address_v6((reinterpret_cast<const sockaddr_in6*>(this)->sin6_addr)));
		}

		/// <summary>
		/// Typecast operator to std::wstring
		/// </summary>
		explicit operator std::wstring() const
		{
			return (ss_family == AF_INET)
				       ? std::wstring(net::ip_address_v4((reinterpret_cast<const sockaddr_in*>(this))->sin_addr))
				       : std::wstring(net::ip_address_v6(reinterpret_cast<const sockaddr_in6*>(this)->sin6_addr));
		}
	};

	/// <summary>
	/// Stores IP address and hardware (MAC) address to represent network gateway information
	/// </summary>
	struct ip_gateway_info : ip_address_info
	{
		/// <summary>
		/// Constructs ip_gateway_info from sockaddr and net::mac_address
		/// </summary>
		/// <param name="address">IP address represented as sockaddr</param>
		/// <param name="hardware_address">Hardware (MAC) address</param>
		explicit ip_gateway_info(const sockaddr& address,
		                         const net::mac_address& hardware_address = net::mac_address()) :
			ip_address_info(address), hardware_address(hardware_address)
		{
		}

		/// <summary>
		/// Constructs ip_gateway_info from SOCKET_ADDRESS and net::mac_address
		/// </summary>
		/// <param name="address">IP address represented as SOCKET_ADDRESS</param>
		/// <param name="hardware_address">Hardware (MAC) address</param>
		explicit ip_gateway_info(const SOCKET_ADDRESS& address,
		                         const net::mac_address& hardware_address = net::mac_address()) :
			ip_address_info(address), hardware_address(hardware_address)
		{
		}

		/// <summary>
		/// Hardware (MAC) address of the gateway
		/// </summary>
		net::mac_address hardware_address;
	};

	/// <summary>
	/// Simple wrapper for the GUID
	/// </summary>
	struct guid_wrapper : GUID
	{
		/// <summary>
		/// Default constructor
		/// </summary>
		guid_wrapper() = default;

		/// <summary>
		/// Constructs guid_wrapper from GUID
		/// </summary>
		/// <param name="guid"></param>
		explicit guid_wrapper(const GUID& guid) : GUID(guid)
		{
		}

		/// <summary>
		/// Converts GUID to string representation
		/// </summary>
		/// <typeparam name="T">Char type, e.g. char, wchar_t</typeparam>
		template <typename T>
		explicit operator std::basic_string<T>() const
		{
			std::basic_ostringstream<T> oss;
			oss << std::hex
				<< std::uppercase
				<< "{"
				<< std::setfill(T('0')) << std::setw(8)
				<< Data1 << "-"
				<< std::setfill(T('0')) << std::setw(4)
				<< Data2 << "-"
				<< std::setfill(T('0')) << std::setw(4)
				<< Data3 << "-"
				<< std::setfill(T('0')) << std::setw(2)
				<< static_cast<unsigned>(Data4[0])
				<< std::setfill(T('0')) << std::setw(2)
				<< static_cast<unsigned>(Data4[1]) << "-"
				<< std::setfill(T('0')) << std::setw(2)
				<< static_cast<unsigned>(Data4[2])
				<< std::setfill(T('0')) << std::setw(2)
				<< static_cast<unsigned>(Data4[3])
				<< std::setfill(T('0')) << std::setw(2)
				<< static_cast<unsigned>(Data4[4])
				<< std::setfill(T('0')) << std::setw(2)
				<< static_cast<unsigned>(Data4[5])
				<< std::setfill(T('0')) << std::setw(2)
				<< static_cast<unsigned>(Data4[6])
				<< std::setfill(T('0')) << std::setw(2)
				<< static_cast<unsigned>(Data4[7])
				<< "}";

			return oss.str();
		}
	};

	/// <summary>
	/// Network adapter information class
	/// </summary>
	class network_adapter_info
	{
		static constexpr std::string_view adapter_connection_name =
			R"(SYSTEM\CurrentControlSet\Control\Network\{4D36E972-E325-11CE-BFC1-08002BE10318}\)";

	public:
		/// <summary>
		/// Constructs object instance from IP HELPER API structures
		/// </summary>
		/// <param name="address">IP_ADAPTER_ADDRESSES pointer: 
		/// https://docs.microsoft.com/en-us/windows/win32/api/iptypes/ns-iptypes-ip_adapter_addresses_lh</param>
		/// <param name="if_table">MIB_IF_TABLE2 pointer: 
		/// https://docs.microsoft.com/en-us/windows/win32/api/netioapi/ns-netioapi-mib_if_table2</param>
		/// <param name="index">Network interface index in MIB_IF_TABLE2</param>
		network_adapter_info(PIP_ADAPTER_ADDRESSES address, PMIB_IF_TABLE2 if_table, const size_t index) :
			if_index_(address->IfIndex),
			ipv6_if_index_(address->Ipv6IfIndex),
			adapter_name_(address->AdapterName),
			description_(address->Description),
			friendly_name_(address->FriendlyName),
			physical_address_(address->PhysicalAddress),
			mtu_(static_cast<uint16_t>(address->Mtu)),
			if_type_(address->IfType),
			transmit_link_speed_(address->TransmitLinkSpeed),
			receive_link_speed_(address->ReceiveLinkSpeed),
			luid_(address->Luid),
			media_type_(if_table->Table[index].MediaType),
			physical_medium_type_(if_table->Table[index].PhysicalMediumType)
		{
			// Initialize from IP_ADAPTER_ADDRESSES
			auto* unicast_address = address->FirstUnicastAddress;
			while (unicast_address)
			{
				unicast_address_list_.emplace_back(unicast_address->Address);
				unicast_address = unicast_address->Next;
			}

			auto* dns_address = address->FirstDnsServerAddress;
			while (dns_address)
			{
				dns_server_address_list_.emplace_back(dns_address->Address);
				dns_address = dns_address->Next;
			}

			auto* gateway_address = address->FirstGatewayAddress;
			while (gateway_address)
			{
				gateway_address_list_.emplace_back(gateway_address->Address);
				gateway_address = gateway_address->Next;
			}

			// Initialize MAC addresses for the network gateways
			if ((address->IfType == IF_TYPE_ETHERNET_CSMACD) ||
				(address->IfType == IF_TYPE_IEEE80211))
				initialize_gateway_hw_address_list();

			if (if_table->Table[index].PhysicalMediumType == NdisPhysicalMediumUnspecified)
			{
				// For unknown physical media interface (usually virtual interfaces) try to lookup the underlying media
				for (size_t i = 0; i < if_table->NumEntries; ++i)
				{
					if ((i != index) && // different entry from the current one
						(if_table->Table[i].MediaConnectState == MediaConnectStateConnected) && // in connected state
						(if_table->Table[i].PhysicalAddressLength == ETH_ALEN) && // has ethernet address
						(if_table->Table[i].PhysicalMediumType != NdisPhysicalMediumUnspecified) &&
						// has real network media set
						(net::mac_address(if_table->Table[i].PhysicalAddress) == physical_address_) &&
						// and equal MAC address
						(if_table->Table[i].InterfaceAndOperStatusFlags.HardwareInterface)
							// and real hardware interface
					)
					{
						true_medium_type_ = if_table->Table[i].PhysicalMediumType;
						true_adapter_name_ = guid_wrapper(if_table->Table[i].InterfaceGuid);
					}
				}
			}
		}

		/// <summary>
		/// Default destructor
		/// </summary>
		~network_adapter_info() = default;

		/// <summary>
		/// Default copy constructor
		/// </summary>
		/// <param name="other">object instance to copy from</param>
		network_adapter_info(const network_adapter_info& other) = default;

		/// <summary>
		/// Default move constructor
		/// </summary>
		/// <param name="other">Object instance to move from</param>
		/// <returns></returns>
		network_adapter_info(network_adapter_info&& other) noexcept = default;

		/// <summary>
		/// Default copy assignment operator
		/// </summary>
		/// <param name="other">Object instance to assign to</param>
		/// <returns>this object pointer</returns>
		network_adapter_info& operator=(const network_adapter_info& other) = default;

		/// <summary>
		/// Default move assignment operator
		/// </summary>
		/// <param name="other">Object instance to assign from</param>
		/// <returns>this object instance</returns>
		network_adapter_info& operator=(network_adapter_info&& other) noexcept = default;

		/// <summary>
		/// Gets network interface IPv4 IF_INDEX
		/// </summary>
		/// <returns>Network interface IPv4 IF_INDEX</returns>
		[[nodiscard]] unsigned long get_if_index() const noexcept { return if_index_; }

		/// <summary>
		/// Gets network interface IPv6 IF_INDEX
		/// </summary>
		/// <returns>Network interface IPv6 IF_INDEX</returns>
		[[nodiscard]] unsigned long get_ipv6_if_index() const noexcept { return ipv6_if_index_; }

		/// <summary>
		/// Gets network interface name
		/// </summary>
		/// <returns>Network interface name as std::string reference</returns>
		[[nodiscard]] const std::string& get_adapter_name() const noexcept { return adapter_name_; }

		/// <summary>
		/// Gets network interface true (lowest level) network adapter name
		/// </summary>
		/// <returns>Network interface true name as std::string reference</returns>
		[[nodiscard]] std::string get_true_adapter_name() const { return std::string(true_adapter_name_); }

		/// <summary>
		/// Gets network interface description
		/// </summary>
		/// <returns>Network interface description as std::wstring reference</returns>
		[[nodiscard]] const std::wstring& get_description() const noexcept { return description_; }

		/// <summary>
		/// Gets network interface friendly name
		/// </summary>
		/// <returns>Network interface friendly name as std::wstring reference</returns>
		[[nodiscard]] const std::wstring& get_friendly_name() const noexcept { return friendly_name_; }

		/// <summary>
		/// Sets network interface friendly name
		/// </summary>
		/// <returns>Network interface friendly name as std::wstring reference</returns>
		[[nodiscard]] bool set_friendly_name(const std::string_view name) noexcept
		{
			const std::string key_name = std::string(adapter_connection_name) + adapter_name_ + "\\Connection";

			HKEY h_key;

			if (RegOpenKeyExA(HKEY_LOCAL_MACHINE,
				key_name.c_str(),
				0,
				KEY_WRITE,
				&h_key) != ERROR_SUCCESS)
				return false;

			const auto status = RegSetValueExA(
				h_key,
				"Name",
				0,
				REG_SZ,
				reinterpret_cast<const BYTE*>(name.data()),
				static_cast<DWORD>(name.size() + 1));

			RegCloseKey(h_key);

			if (status == ERROR_SUCCESS)
			{
				friendly_name_ = std::wstring(name.cbegin(), name.cend());
				return true;
			}

			return false;
		}

		/// <summary>
		/// Gets network interface unicast addresses
		/// </summary>
		/// <returns>Network interface unicast addresses as a vector of ip_address_info</returns>
		[[nodiscard]] const std::vector<ip_address_info>& get_unicast_address_list() const noexcept
		{
			return unicast_address_list_;
		}

		/// <summary>
		/// Gets network interface associated DNS servers
		/// </summary>
		/// <returns>Network interface associated DNS servers as a vector of ip_address_info</returns>
		[[nodiscard]] const std::vector<ip_address_info>& get_dns_server_address_list() const noexcept
		{
			return dns_server_address_list_;
		}

		/// <summary>
		/// Gets network interface configured gateway addresses
		/// </summary>
		/// <returns>Network interface configured gateway addresses as a vector of ip_gateway_info</returns>
		[[nodiscard]] const std::vector<ip_gateway_info>& get_gateway_address_list() const noexcept
		{
			return gateway_address_list_;
		}

		/// <summary>
		/// Checks if network interface has specified unicast IP address
		/// </summary>
		/// <returns>true if network interface has specified unicast IP address, false otherwise</returns>
		[[nodiscard]] bool has_address(const ip_address_info& address) const
		{
			return unicast_address_list_.cend() != std::find(unicast_address_list_.cbegin(),
			                                                 unicast_address_list_.cend(), address);
		}

		/// <summary>
		/// Gets network interface physical address
		/// </summary>
		/// <returns>Network interface physical address</returns>
		[[nodiscard]] const net::mac_address& get_physical_address() const noexcept { return physical_address_; }

		/// <summary>
		/// Gets network interface MTU
		/// </summary>
		/// <returns>Network interface MTU</returns>
		[[nodiscard]] uint16_t get_mtu() const noexcept { return mtu_; }

		/// <summary>
		/// Gets network interface IF_TYPE:
		/// https://docs.microsoft.com/en-us/windows-hardware/drivers/network/ndis-interface-types
		/// </summary>
		/// <returns>Network interface IF_TYPE</returns>
		[[nodiscard]] unsigned get_if_type() const noexcept { return if_type_; }

		/// <summary>
		/// Gets network interface LUID
		/// </summary>
		/// <returns>Network interface LUID</returns>
		[[nodiscard]] IF_LUID get_luid() const noexcept { return luid_; }

		/// <summary>
		/// Equality comparison operator (compares network adapter LUID)
		/// </summary>
		/// <param name="rhs">Object instance to compare to</param>
		/// <returns>true if both objects have the same LUID</returns>
		bool operator ==(const network_adapter_info& rhs) const { return luid_ == rhs.luid_; }

		/// <summary>
		/// Non-equality comparison operator (compares network adapter LUID)
		/// </summary>
		/// <param name="rhs">Object instance to compare to</param>
		/// <returns>true if both objects have different LUID</returns>
		bool operator !=(const network_adapter_info& rhs) const { return (luid_ != rhs.luid_); }

		/// <summary>
		/// Less comparison operator (compares network adapter LUID)
		/// </summary>
		/// <param name="rhs">Object instance to compare to</param>
		/// <returns>true if this object LUID is less than rhs</returns>
		bool operator <(const network_adapter_info& rhs) const { return (luid_ < rhs.luid_); }

		/// <summary>
		/// Checks if IP address information in the provided network_adapter_info is different
		/// from the current one.
		/// </summary>
		/// <typeparam name="BCheckGateway">If true also checks the gateway information</typeparam>
		/// <param name="rhs">network_adapter_info to compare to</param>
		/// <returns>true if provided network_adapter_info contains the same IP addresses, false otherwise</returns>
		template <bool BCheckGateway = true>
		[[nodiscard]] bool is_same_address_info(const network_adapter_info& rhs) const
		{
			auto ret_val = true;

			if (unicast_address_list_.size() != rhs.unicast_address_list_.size())
				return false;

			if constexpr (BCheckGateway)
			{
				if (gateway_address_list_.size() != rhs.gateway_address_list_.size())
					return false;
			}

			// Check if any of the unicast addresses have changed
			std::for_each(rhs.unicast_address_list_.cbegin(), rhs.unicast_address_list_.cend(),
			              [&ret_val, this](auto& address)
			              {
				              if (unicast_address_list_.cend() == std::find(
					              unicast_address_list_.cbegin(), unicast_address_list_.cend(), address))
					              ret_val = false;
			              });

			if (ret_val == false)
				return ret_val;

			// Check if any of the gateways have changed
			if constexpr (BCheckGateway)
			{
				std::for_each(rhs.gateway_address_list_.cbegin(), rhs.gateway_address_list_.cend(),
				              [&ret_val, this](auto& address)
				              {
					              if (gateway_address_list_.cend() == std::find(
						              gateway_address_list_.cbegin(), gateway_address_list_.cend(), address))
						              ret_val = false;
				              });
			}

			return ret_val;
		}

		/// <summary>
		/// Gets network interface NDIS_MEDIUM
		/// </summary>
		/// <returns>Network interface NDIS_MEDIUM</returns>
		[[nodiscard]] NDIS_MEDIUM get_media_type() const { return media_type_; }

		/// <summary>
		/// Gets network interface NDIS_PHYSICAL_MEDIUM
		/// </summary>
		/// <returns>Network interface NDIS_PHYSICAL_MEDIUM</returns>
		[[nodiscard]] NDIS_PHYSICAL_MEDIUM get_physical_medium_type() const { return physical_medium_type_; }

		/// <summary>
		/// Gets network interface lowest underlying layer NDIS_PHYSICAL_MEDIUM
		/// </summary>
		/// <returns>Network interface lowest underlying layer NDIS_PHYSICAL_MEDIUM</returns>
		[[nodiscard]] NDIS_PHYSICAL_MEDIUM get_true_physical_medium_type() const { return true_medium_type_; }

		/// <summary>
		/// Gets network interface transmit link speed
		/// </summary>
		/// <returns>Network interface transmit link speed</returns>
		[[nodiscard]] ULONG64 transmit_link_speed() const
		{
			return transmit_link_speed_;
		}

		/// <summary>
		/// Gets network interface receive link speed
		/// </summary>
		/// <returns>Network interface receive link speed</returns>
		[[nodiscard]] ULONG64 receive_link_speed() const
		{
			return receive_link_speed_;
		}

		/// <summary>
		/// Adds IPv4 unicast address to the network interface
		/// </summary>
		/// <param name="address">IPv4 address to assign</param>
		/// <param name="prefix_length">subnet prefix</param>
		/// <returns>pointer to MIB_UNICASTIPADDRESS_ROW</returns>
		[[nodiscard]] std::unique_ptr<MIB_UNICASTIPADDRESS_ROW> add_unicast_address(
			const net::ip_address_v4 address, const uint8_t prefix_length) const
		{
			auto address_row = std::make_unique<MIB_UNICASTIPADDRESS_ROW>();

			InitializeUnicastIpAddressEntry(address_row.get());

			address_row->Address.Ipv4.sin_family = AF_INET;
			address_row->Address.Ipv4.sin_addr = address;
			address_row->Address.si_family = AF_INET;

			address_row->InterfaceIndex = if_index_;
			address_row->InterfaceLuid = luid_;

			address_row->PrefixOrigin = IpPrefixOriginManual;
			address_row->SuffixOrigin = IpSuffixOriginManual;
			address_row->OnLinkPrefixLength = prefix_length;
			address_row->DadState = IpDadStatePreferred;

			SetLastError(ERROR_SUCCESS);

			const auto error_code = CreateUnicastIpAddressEntry(address_row.get());

			if (NO_ERROR == error_code)
				return address_row;

			SetLastError(error_code);

			return nullptr;
		}

		/// <summary>
		/// Adds IPv6 unicast address to the network interface
		/// </summary>
		/// <param name="address">IPv6 address to assign</param>
		/// <param name="prefix_length">subnet prefix</param>
		/// <returns>pointer to MIB_UNICASTIPADDRESS_ROW</returns>
		[[nodiscard]] std::unique_ptr<MIB_UNICASTIPADDRESS_ROW> add_unicast_address(
			const net::ip_address_v6& address, const uint8_t prefix_length) const
		{
			auto address_row = std::make_unique<MIB_UNICASTIPADDRESS_ROW>();

			InitializeUnicastIpAddressEntry(address_row.get());

			address_row->Address.Ipv6.sin6_family = AF_INET6;
			address_row->Address.Ipv6.sin6_addr = address;
			address_row->Address.si_family = AF_INET6;

			address_row->InterfaceIndex = ipv6_if_index_;
			address_row->InterfaceLuid = luid_;

			address_row->PrefixOrigin = IpPrefixOriginManual;
			address_row->SuffixOrigin = IpSuffixOriginManual;
			address_row->OnLinkPrefixLength = prefix_length;
			address_row->DadState = IpDadStatePreferred;

			SetLastError(ERROR_SUCCESS);

			const auto error_code = CreateUnicastIpAddressEntry(address_row.get());

			if (error_code == NO_ERROR || error_code == ERROR_OBJECT_ALREADY_EXISTS)
				return address_row;

			SetLastError(error_code);

			return nullptr;
		}

		/// <summary>
		/// Removes unicast IP address from the network adapter by MIB_UNICASTIPADDRESS_ROW pointer
		/// </summary>
		/// <param name="address">MIB_UNICASTIPADDRESS_ROW unique pointer</param>
		/// <returns>true if no error occurs, false otherwise</returns>
		[[nodiscard]] static bool delete_unicast_address(const std::unique_ptr<MIB_UNICASTIPADDRESS_ROW> address) noexcept
		{
			SetLastError(ERROR_SUCCESS);

			const auto error_code = DeleteUnicastIpAddressEntry(address.get());

			SetLastError(error_code);

			return NO_ERROR == error_code;
		}

		/// <summary>
		/// Adds default IPv4 gateway to network interface
		/// </summary>
		/// <param name="address">Default gateway IPv4 address</param>
		/// <returns>unique pointer to MIB_IPFORWARD_ROW2</returns>
		[[nodiscard]] std::unique_ptr<MIB_IPFORWARD_ROW2> add_default_gateway(const net::ip_address_v4& address) const
		{
			auto forward_row = std::make_unique<MIB_IPFORWARD_ROW2>();
			InitializeIpForwardEntry(forward_row.get());

			forward_row->InterfaceIndex = if_index_;
			forward_row->InterfaceLuid = luid_;
			forward_row->DestinationPrefix.Prefix.si_family = AF_INET;
			forward_row->DestinationPrefix.Prefix.Ipv4.sin_family = AF_INET;
			forward_row->NextHop.si_family = AF_INET;
			forward_row->NextHop.Ipv4.sin_family = AF_INET;
			forward_row->NextHop.Ipv4.sin_addr = address;
			forward_row->SitePrefixLength = 0;
			forward_row->Metric = 1;
			forward_row->Protocol = MIB_IPPROTO_NT_STATIC;
			forward_row->Origin = NlroManual;

			SetLastError(ERROR_SUCCESS);

			const auto error_code = CreateIpForwardEntry2(forward_row.get());

			if (error_code == NO_ERROR || error_code == ERROR_OBJECT_ALREADY_EXISTS)
				return forward_row;

			SetLastError(error_code);

			return nullptr;
		}

		/// <summary>
		/// Adds default IPv6 gateway to network interface
		/// </summary>
		/// <param name="address">Default gateway IPv6 address</param>
		/// <returns>unique pointer to MIB_IPFORWARD_ROW2</returns>
		[[nodiscard]] std::unique_ptr<MIB_IPFORWARD_ROW2> add_default_gateway(const net::ip_address_v6& address) const
		{
			auto forward_row = std::make_unique<MIB_IPFORWARD_ROW2>();
			InitializeIpForwardEntry(forward_row.get());

			forward_row->InterfaceIndex = ipv6_if_index_;
			forward_row->InterfaceLuid = luid_;
			forward_row->DestinationPrefix.Prefix.si_family = AF_INET6;
			forward_row->DestinationPrefix.Prefix.Ipv6.sin6_family = AF_INET6;
			forward_row->NextHop.si_family = AF_INET6;
			forward_row->NextHop.Ipv6.sin6_family = AF_INET6;
			forward_row->NextHop.Ipv6.sin6_addr = address;
			forward_row->SitePrefixLength = 0;
			forward_row->Metric = 1;
			forward_row->Protocol = MIB_IPPROTO_NT_STATIC;
			forward_row->Origin = NlroManual;

			SetLastError(ERROR_SUCCESS);

			const auto error_code = CreateIpForwardEntry2(forward_row.get());

			if (error_code == NO_ERROR || error_code == ERROR_OBJECT_ALREADY_EXISTS)
				return forward_row;

			SetLastError(error_code);

			return nullptr;
		}

		/// <summary>
		/// Configures network interface as a default IPv4 gateway with specified metric
		/// </summary>
		/// <param name="metric">network metric (priority)</param>
		/// <returns>unique pointer to MIB_IPFORWARD_ROW2</returns>
		[[nodiscard]] std::unique_ptr<MIB_IPFORWARD_ROW2> assign_default_gateway_v4(const uint32_t metric = 0) const
		{
			auto forward_row = std::make_unique<MIB_IPFORWARD_ROW2>();
			InitializeIpForwardEntry(forward_row.get());

			forward_row->InterfaceIndex = if_index_;
			forward_row->InterfaceLuid = luid_;
			forward_row->DestinationPrefix.Prefix.si_family = AF_INET;
			forward_row->DestinationPrefix.Prefix.Ipv4.sin_family = AF_INET;
			forward_row->NextHop.si_family = AF_INET;
			forward_row->NextHop.Ipv4.sin_family = AF_INET;
			forward_row->NextHop.Ipv4.sin_addr = net::ip_address_v4{};
			forward_row->SitePrefixLength = 0;
			forward_row->Metric = metric;
			forward_row->Protocol = MIB_IPPROTO_NT_STATIC;
			forward_row->Origin = NlroManual;

			SetLastError(ERROR_SUCCESS);

			const auto error_code = CreateIpForwardEntry2(forward_row.get());

			if (error_code == NO_ERROR || error_code == ERROR_OBJECT_ALREADY_EXISTS)
				return forward_row;

			SetLastError(error_code);

			return nullptr;
		}

		/// <summary>
		/// Configures network interface as a default IPv6 gateway with specified metric
		/// </summary>
		/// <param name="metric">network metric (priority)</param>
		/// <returns>unique pointer to MIB_IPFORWARD_ROW2</returns>
		[[nodiscard]] std::unique_ptr<MIB_IPFORWARD_ROW2> assign_default_gateway_v6(const uint32_t metric = 0) const
		{
			auto forward_row = std::make_unique<MIB_IPFORWARD_ROW2>();
			InitializeIpForwardEntry(forward_row.get());

			forward_row->InterfaceIndex = ipv6_if_index_;
			forward_row->InterfaceLuid = luid_;
			forward_row->DestinationPrefix.Prefix.si_family = AF_INET6;
			forward_row->DestinationPrefix.Prefix.Ipv6.sin6_family = AF_INET6;
			forward_row->NextHop.si_family = AF_INET6;
			forward_row->NextHop.Ipv6.sin6_family = AF_INET6;
			forward_row->NextHop.Ipv6.sin6_addr = net::ip_address_v6{};
			forward_row->SitePrefixLength = 0;
			forward_row->Metric = metric;
			forward_row->Protocol = MIB_IPPROTO_NT_STATIC;
			forward_row->Origin = NlroManual;

			SetLastError(ERROR_SUCCESS);

			const auto error_code = CreateIpForwardEntry2(forward_row.get());

			if (error_code == NO_ERROR || error_code == ERROR_OBJECT_ALREADY_EXISTS)
				return forward_row;

			SetLastError(error_code);

			return nullptr;
		}

		/// <summary>
		/// Configures IPv4 network interface routes (Wireguard AllowedIps parameter)
		/// </summary>
		/// <param name="ips">IPv4/IPv6 subnets to configure</param>
		/// <returns>vector of unique pointers to MIB_IPFORWARD_ROW2</returns>
		[[nodiscard]] std::vector<std::unique_ptr<MIB_IPFORWARD_ROW2>> configure_allowed_ips_v4(
			const std::vector<std::variant<net::ip_subnet<net::ip_address_v4>, net::ip_subnet<net::ip_address_v6>>>&
			ips) const
		{
			std::vector<std::unique_ptr<MIB_IPFORWARD_ROW2>> ret_val;

			std::for_each(ips.cbegin(), ips.cend(), [this, &ret_val](auto&& v)
			{
				if (auto subnet_v4_ptr = std::get_if<net::ip_subnet<net::ip_address_v4>>(&v); subnet_v4_ptr)
				{
					auto forward_row = std::make_unique<MIB_IPFORWARD_ROW2>();
					InitializeIpForwardEntry(forward_row.get());

					forward_row->InterfaceIndex = if_index_;
					forward_row->InterfaceLuid = luid_;
					forward_row->DestinationPrefix.Prefix.si_family = AF_INET;
					forward_row->DestinationPrefix.Prefix.Ipv4.sin_family = AF_INET;
					forward_row->DestinationPrefix.Prefix.Ipv4.sin_addr = subnet_v4_ptr->get_address();
					forward_row->DestinationPrefix.PrefixLength = subnet_v4_ptr->get_prefix();
					forward_row->NextHop.si_family = AF_INET;
					forward_row->NextHop.Ipv4.sin_family = AF_INET;
					forward_row->NextHop.Ipv4.sin_addr = net::ip_address_v4{};
					forward_row->SitePrefixLength = 0;
					forward_row->Metric = 0;
					forward_row->Protocol = MIB_IPPROTO_NT_STATIC;
					forward_row->Origin = NlroManual;

					SetLastError(ERROR_SUCCESS);

					if (const auto error_code = CreateIpForwardEntry2(forward_row.get()); error_code == NO_ERROR
						|| error_code == ERROR_OBJECT_ALREADY_EXISTS)
						ret_val.push_back(std::move(forward_row));
					else
						SetLastError(error_code);
				}
			});

			return ret_val;
		}

		/// <summary>
		/// Configures IPv6 network interface routes (Wireguard AllowedIps parameter)
		/// </summary>
		/// <param name="ips">IPv4/IPv6 subnets to configure</param>
		/// <returns>vector of unique pointers to MIB_IPFORWARD_ROW2</returns>
		[[nodiscard]] std::vector<std::unique_ptr<MIB_IPFORWARD_ROW2>> configure_allowed_ips_v6(
			const std::vector<std::variant<net::ip_subnet<net::ip_address_v4>, net::ip_subnet<net::ip_address_v6>>>&
			ips) const
		{
			std::vector<std::unique_ptr<MIB_IPFORWARD_ROW2>> return_value;

			std::for_each(ips.cbegin(), ips.cend(), [this, &return_value](auto&& v)
			{
				if (auto subnet_v6_ptr = std::get_if<net::ip_subnet<net::ip_address_v6>>(&v); subnet_v6_ptr)
				{
					auto forward_row = std::make_unique<MIB_IPFORWARD_ROW2>();
					InitializeIpForwardEntry(forward_row.get());

					forward_row->InterfaceIndex = ipv6_if_index_;
					forward_row->InterfaceLuid = luid_;
					forward_row->DestinationPrefix.Prefix.si_family = AF_INET6;
					forward_row->DestinationPrefix.Prefix.Ipv6.sin6_family = AF_INET6;
					forward_row->DestinationPrefix.Prefix.Ipv6.sin6_addr = subnet_v6_ptr->get_address();
					forward_row->DestinationPrefix.PrefixLength = subnet_v6_ptr->get_prefix();
					forward_row->NextHop.si_family = AF_INET6;
					forward_row->NextHop.Ipv6.sin6_family = AF_INET6;
					forward_row->NextHop.Ipv6.sin6_addr = net::ip_address_v6{};
					forward_row->SitePrefixLength = 0;
					forward_row->Metric = 0;
					forward_row->Protocol = MIB_IPPROTO_NT_STATIC;
					forward_row->Origin = NlroManual;

					if (const auto status = CreateIpForwardEntry2(forward_row.get()); status == NO_ERROR || status ==
						ERROR_OBJECT_ALREADY_EXISTS)
						return_value.push_back(std::move(forward_row));
				}
			});

			return return_value;
		}

		/// <summary>
		/// Deletes routing table entry by MIB_IPFORWARD_ROW2 pointer
		/// </summary>
		/// <param name="address">MIB_IPFORWARD_ROW2 unique pointer</param>
		/// <returns>true if successful, false otherwise</returns>
		[[nodiscard]] static bool delete_routes(const std::unique_ptr<MIB_IPFORWARD_ROW2> address) noexcept
		{
			SetLastError(ERROR_SUCCESS);

			const auto error_code = DeleteIpForwardEntry2(address.get());

			if (NO_ERROR == error_code)
				return true;

			SetLastError(error_code);

			return false;
		}

		/// <summary>
		/// Deletes routing table entries by MIB_IPFORWARD_ROW2 pointers
		/// </summary>
		/// <param name="address">vector of MIB_IPFORWARD_ROW2 unique pointers</param>
		/// <returns>true if successful, false otherwise</returns>
		[[nodiscard]] static bool delete_routes(std::vector<std::unique_ptr<MIB_IPFORWARD_ROW2>> address)
		{
			auto status = true;

			SetLastError(ERROR_SUCCESS);

			std::for_each(address.begin(), address.end(), [&status](auto&& a) noexcept
			{
				if (const auto error_code = ::DeleteIpForwardEntry2(a.get()); NOERROR != error_code)
				{
					status = false;
					::SetLastError(error_code);
				}
			});

			return status;
		}

		/// <summary>
		/// Removes all routing table entries associated with network interface
		/// </summary>
		/// <returns>true if successful, false otherwise</returns>
		[[nodiscard]] bool reset_adapter_routes() const
		{
			PMIB_IPFORWARD_TABLE2 table = nullptr;

			if (const auto error_code = GetIpForwardTable2(AF_UNSPEC, &table); NO_ERROR == error_code)
			{
				for (unsigned i = 0; i < table->NumEntries; ++i)
				{
					if (table->Table[i].InterfaceLuid == luid_)
					{
						DeleteIpForwardEntry2(&table->Table[i]);
					}
				}

				FreeMibTable(table);
				return true;
			}
			else
			{
				SetLastError(error_code);
			}

			return false;
		}

		/// <summary>
		/// Removes all unicast addresses associated with network interface
		/// </summary>
		/// <returns>true if successful, false otherwise</returns>
		[[nodiscard]] bool reset_unicast_addresses() const
		{
			PMIB_UNICASTIPADDRESS_TABLE table = nullptr;

			SetLastError(ERROR_SUCCESS);

			auto error_code = GetUnicastIpAddressTable(AF_UNSPEC, &table);

			if (NO_ERROR == error_code)
			{
				for (unsigned i = 0; i < table->NumEntries; ++i)
				{
					if (table->Table[i].InterfaceLuid == luid_)
					{
						error_code = DeleteUnicastIpAddressEntry(&table->Table[i]);
						if (NO_ERROR == error_code)
							SetLastError(error_code);
					}
				}

				FreeMibTable(table);
				return true;
			}

			SetLastError(error_code);

			return false;
		}

		/// <summary>
		/// Resets adapters addresses and routes
		/// </summary>
		/// <returns>true if successful, false otherwise</returns>
		[[nodiscard]] bool reset_adapter() const
		{
			return reset_unicast_addresses() && reset_adapter_routes();
		}

		/// <summary>
		/// Removes specified IPv4 address from the network interface
		/// </summary>
		/// <param name="address">IPv4 address to remove</param>
		/// <returns>true if successful, false otherwise</returns>
		[[nodiscard]] bool delete_unicast_address(const net::ip_address_v4 address) const
		{
			PMIB_UNICASTIPADDRESS_TABLE table = nullptr;

			SetLastError(ERROR_SUCCESS);

			auto error_code = GetUnicastIpAddressTable(AF_INET, &table);

			if (NO_ERROR == error_code)
			{
				for (unsigned i = 0; i < table->NumEntries; ++i)
				{
					if (table->Table[i].InterfaceLuid == luid_ && net::ip_address_v4(
						table->Table[i].Address.Ipv4.sin_addr) == address)
					{
						error_code = DeleteUnicastIpAddressEntry(&table->Table[i]);
						if (NO_ERROR == error_code)
							SetLastError(error_code);
					}
				}

				FreeMibTable(table);
				return true;
			}

			SetLastError(error_code);

			return false;
		}

		/// <summary>
		 /// Removes specified IPv6 address from the network interface
		 /// </summary>
		 /// <param name="address">IPv6 address to remove</param>
		 /// <returns>true if successful, false otherwise</returns>
		[[nodiscard]] bool delete_unicast_address(const net::ip_address_v6 address) const
		{
			PMIB_UNICASTIPADDRESS_TABLE table = nullptr;

			SetLastError(ERROR_SUCCESS);

			auto error_code = GetUnicastIpAddressTable(AF_INET6, &table);

			if (NO_ERROR == error_code)
			{
				for (unsigned i = 0; i < table->NumEntries; ++i)
				{
					if (table->Table[i].InterfaceLuid == luid_ && net::ip_address_v6(
						table->Table[i].Address.Ipv6.sin6_addr) == address)
					{
						error_code = DeleteUnicastIpAddressEntry(&table->Table[i]);
						if (NO_ERROR == error_code)
							SetLastError(error_code);
					}
				}

				FreeMibTable(table);
				return true;
			}

			SetLastError(error_code);

			return false;
		}

		/// <summary>
		/// Adds IPv4 NDP entry for the network interface
		/// </summary>
		/// <param name="address">IPv4 address</param>
		/// <param name="hw_address">hardware address</param>
		/// <returns>unique pointer to MIB_IPNET_ROW2</returns>
		[[nodiscard]] std::unique_ptr<MIB_IPNET_ROW2> add_ndp_entry(const net::ip_address_v4& address,
		                                                            const net::mac_address& hw_address) const
		{
			auto net_row = std::make_unique<MIB_IPNET_ROW2>();
			RtlSecureZeroMemory(net_row.get(), sizeof(MIB_IPNET_ROW2));

			net_row->Address.si_family = AF_INET;
			net_row->Address.Ipv4.sin_family = AF_INET;
			net_row->Address.Ipv4.sin_addr = address;
			net_row->InterfaceIndex = if_index_;
			net_row->InterfaceLuid = luid_;
			memmove(net_row->PhysicalAddress, hw_address.data.data(), ETH_ALEN);
			net_row->PhysicalAddressLength = ETH_ALEN;
			net_row->State = NlnsPermanent;
			net_row->IsRouter = TRUE;
			net_row->IsUnreachable = TRUE;

			SetLastError(ERROR_SUCCESS);

			const auto error_code = CreateIpNetEntry2(net_row.get());

			if (NO_ERROR == error_code)
				return net_row;

			SetLastError(error_code);

			return nullptr;
		}

		/// <summary>
		/// Adds IPv6 NDP entry for the network interface
		/// </summary>
		/// <param name="address">IPv6 address</param>
		/// <param name="hw_address">hardware address</param>
		/// <returns>unique pointer to MIB_IPNET_ROW2</returns>
		[[nodiscard]] std::unique_ptr<MIB_IPNET_ROW2> add_ndp_entry(const net::ip_address_v6& address,
		                                                            const net::mac_address& hw_address) const
		{
			auto net_row = std::make_unique<MIB_IPNET_ROW2>();
			RtlSecureZeroMemory(net_row.get(), sizeof(MIB_IPNET_ROW2));

			net_row->Address.si_family = AF_INET6;
			net_row->Address.Ipv6.sin6_family = AF_INET6;
			net_row->Address.Ipv6.sin6_addr = address;
			net_row->InterfaceIndex = ipv6_if_index_;
			net_row->InterfaceLuid = luid_;
			memmove(net_row->PhysicalAddress, hw_address.data.data(), ETH_ALEN);
			net_row->PhysicalAddressLength = ETH_ALEN;
			net_row->State = NlnsPermanent;
			net_row->IsRouter = TRUE;
			net_row->IsUnreachable = TRUE;

			SetLastError(ERROR_SUCCESS);

			const auto error_code = CreateIpNetEntry2(net_row.get());

			if (NO_ERROR == error_code)
				return net_row;

			SetLastError(error_code);

			return nullptr;
		}

		/// <summary>
		/// Removes NDP entry by MIB_IPNET_ROW2 pointer
		/// </summary>
		/// <param name="address">unique pointer to MIB_IPNET_ROW2</param>
		/// <returns>true if successful, false otherwise</returns>
		[[nodiscard]] static bool delete_ndp_entry(const std::unique_ptr<MIB_IPNET_ROW2> address) noexcept
		{
			SetLastError(ERROR_SUCCESS);

			const auto error_code = DeleteIpNetEntry2(address.get());
			if (NO_ERROR == error_code)
				return true;

			SetLastError(error_code);

			return false;
		}

	private:
		/// <summary>
		/// Initializes gateways address list (resolves hardware addresses)
		/// </summary>
		/// <returns>nothing</returns>
		void initialize_gateway_hw_address_list() noexcept
		{
			SetLastError(ERROR_SUCCESS);

			if (!gateway_address_list_.empty())
			{
				std::for_each(gateway_address_list_.begin(), gateway_address_list_.end(), [this](auto& address)
				{
					MIB_IPNET_ROW2 row = {0};

					row.Address.si_family = address.ss_family;
					row.InterfaceLuid = luid_;

					switch (address.ss_family)
					{
					case AF_INET:
						row.Address.Ipv4 = sockaddr_in(address);
						break;
					case AF_INET6:
						row.Address.Ipv6 = sockaddr_in6(address);
						break;
					default:
						break;
					}

					if (const auto error_code = ResolveIpNetEntry2(&row, nullptr); NO_ERROR == error_code)
					{
						address.hardware_address = net::mac_address(row.PhysicalAddress);
					}
					else
					{
						SetLastError(error_code);
					}
				});
			}
		}

		/// <summary>
		/// The index of the IPv4 interface
		/// </summary>
		unsigned long if_index_;
		/// <summary>
		/// The interface index for the IPv6 IP address. This member is zero if IPv6 is not available on the interface. 
		/// </summary>
		unsigned long ipv6_if_index_;
		/// <summary>
		/// Contains the name of the adapter. Unlike an adapter's friendly name, the adapter name specified in adapter_name_
		/// is permanent and cannot be modified by the user.
		/// </summary>
		std::string adapter_name_;
		/// <summary>
		/// Contains the name of the underlying hardware adapter.
		/// </summary>
		guid_wrapper true_adapter_name_{};
		/// <summary>
		/// A description for the adapter. 
		/// </summary>
		std::wstring description_;
		/// <summary>
		/// A user-friendly name for the adapter.
		/// </summary>
		std::wstring friendly_name_;
		/// <summary>
		///  List of IP unicast addresses for the adapter.
		/// </summary>
		std::vector<ip_address_info> unicast_address_list_;
		/// <summary>
		/// List of DNS server addresses for the adapter.
		/// </summary>
		std::vector<ip_address_info> dns_server_address_list_;
		/// <summary>
		/// List of gateways for the adapter.
		/// </summary>
		std::vector<ip_gateway_info> gateway_address_list_; // 
		/// <summary>
		/// The Media Access Control (MAC) address for the adapter.
		/// </summary>
		net::mac_address physical_address_;
		/// <summary>
		/// The maximum transmission unit (MTU) size, in bytes.
		/// </summary>
		uint16_t mtu_;
		/// <summary>
		/// The interface type as defined by the Internet Assigned Names Authority (IANA).
		/// Possible values for the interface type are listed in the Ipifcons.h header file. 
		/// </summary>
		unsigned if_type_;
		/// <summary>
		/// The current speed in bits per second of the transmit link for the adapter.
		/// </summary>
		ULONG64 transmit_link_speed_;
		/// <summary>
		/// The current speed in bits per second of the receive link for the adapter. 
		/// </summary>
		ULONG64 receive_link_speed_;
		/// <summary>
		/// The interface LUID for the adapter address. 
		/// </summary>
		IF_LUID luid_;
		/// <summary>
		/// The NDIS media type for the interface. This member can be one of the values from the NDIS_MEDIUM
		/// enumeration type defined in the Ntddndis.h header file.
		/// </summary>
		NDIS_MEDIUM media_type_;
		/// <summary>
		/// The NDIS physical medium type.This member can be one of the values from the NDIS_PHYSICAL_MEDIUM
		/// enumeration type defined in the Ntddndis.h header file.
		/// </summary>
		NDIS_PHYSICAL_MEDIUM physical_medium_type_;
		/// <summary>
		/// If value above is NdisPhysicalMediumUnspecified (virtual network interface on top of the real one)
		/// this one may contain real physical media
		/// </summary>
		NDIS_PHYSICAL_MEDIUM true_medium_type_ = NdisPhysicalMediumUnspecified;
		/// <summary>
		/// NDISWANIP associated MAC address
		/// </summary>
		net::mac_address ndis_wan_ip_link_;
		/// <summary>
		/// NDISWANIPV6 associated MAC address
		/// </summary>
		net::mac_address ndis_wan_ipv6_link_;

		// Static class members
	public:
		/// <summary>
		/// Returns list of network interfaces which are:
		/// 1. Have at least one unicast address assigned
		/// 2. Operational (IfOperStatusUp)
		/// 3. Not software loopback
		/// </summary>
		/// <returns>vector of network_adapter_info</returns>
		static std::vector<network_adapter_info> get_external_network_connections()
		{
			std::vector<network_adapter_info> ret_val;
			unsigned long dw_size = 0;
			PMIB_IF_TABLE2 mib_table = nullptr;

			SetLastError(ERROR_SUCCESS);

			// Query detailed information on available network interfaces
			auto error_code = GetIfTable2(&mib_table);
			if (NO_ERROR != error_code)
			{
				SetLastError(error_code);
				return ret_val;
			}

			error_code = GetAdaptersAddresses(AF_UNSPEC,
			                                  GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_MULTICAST |
			                                  GAA_FLAG_INCLUDE_GATEWAYS | GAA_FLAG_INCLUDE_ALL_INTERFACES,
			                                  nullptr, nullptr, &dw_size);

			// Get available unicast addresses
			if ((ERROR_BUFFER_OVERFLOW == error_code) && dw_size)
			{
				do
				{
					auto ip_address_info = std::make_unique<unsigned char[]>(dw_size);

					error_code = GetAdaptersAddresses(AF_UNSPEC,
					                                  GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_MULTICAST |
					                                  GAA_FLAG_INCLUDE_GATEWAYS | GAA_FLAG_INCLUDE_ALL_INTERFACES,
					                                  nullptr,
					                                  reinterpret_cast<PIP_ADAPTER_ADDRESSES>(ip_address_info.get()),
					                                  &dw_size);

					if (NO_ERROR == error_code)
					{
						auto* current_address = reinterpret_cast<PIP_ADAPTER_ADDRESSES>(ip_address_info.get());

						while (current_address)
						{
							if ((current_address->FirstUnicastAddress == nullptr) ||
								(current_address->OperStatus != IfOperStatusUp) ||
								(current_address->IfType == IF_TYPE_SOFTWARE_LOOPBACK)
							)
							{
								current_address = current_address->Next;
								continue;
							}

							// Lookup an advanced information on the network interface
							for (size_t i = 0; i < mib_table->NumEntries; ++i)
							{
								if (mib_table->Table[i].InterfaceLuid == current_address->Luid)
								{
									ret_val.emplace_back(current_address, mib_table, i);
									break;
								}
							}

							current_address = current_address->Next;
						}

						break;
					}
					// In case of insufficient buffer size we try to recover by reallocating buffer
					if (error_code != ERROR_BUFFER_OVERFLOW)
					{
						SetLastError(error_code);
						break;
					}
				}
				while (true);
			}
			else
			{
				// GetAdaptersAddresses has failed with status different from ERROR_BUFFER_OVERFLOW when obtaining required buffer size
				if (NO_ERROR != error_code)
				{
					SetLastError(error_code);
				}
			}

			// Free interface table
			FreeMibTable(mib_table);

			return ret_val;
		}

		/// <summary>
		/// Finds network interface by provided LUID
		/// </summary>
		/// <param name="luid">LUID to lookup</param>
		/// <returns>optional network_adapter_info class instance</returns>
		static std::optional<network_adapter_info> get_connection_by_luid(IF_LUID& luid)
		{
			unsigned long dw_size = 0;
			PMIB_IF_TABLE2 mib_table = nullptr;

			SetLastError(ERROR_SUCCESS);

			// Query detailed information on available network interfaces
			auto error_code = GetIfTable2(&mib_table);

			if (NO_ERROR != error_code)
			{
				SetLastError(error_code);
				return {};
			}

			// Get available unicast addresses
			error_code = GetAdaptersAddresses(AF_UNSPEC,
			                                  GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_MULTICAST |
			                                  GAA_FLAG_INCLUDE_GATEWAYS |
			                                  GAA_FLAG_INCLUDE_ALL_INTERFACES, nullptr, nullptr, &dw_size);

			if ((ERROR_BUFFER_OVERFLOW == error_code) && dw_size)
			{
				do
				{
					auto ip_address_info = std::make_unique<unsigned char[]>(dw_size);

					error_code = GetAdaptersAddresses(AF_UNSPEC,
					                                  GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_MULTICAST |
					                                  GAA_FLAG_INCLUDE_GATEWAYS | GAA_FLAG_INCLUDE_ALL_INTERFACES,
					                                  nullptr,
					                                  reinterpret_cast<PIP_ADAPTER_ADDRESSES>(ip_address_info.get()),
					                                  &dw_size);

					if (NO_ERROR == error_code)
					{
						auto* current_address = reinterpret_cast<PIP_ADAPTER_ADDRESSES>(ip_address_info.get());

						while (current_address)
						{
							if (current_address->Luid != luid)
							{
								current_address = current_address->Next;
								continue;
							}

							// Lookup an advanced information on the network interface
							for (size_t i = 0; i < mib_table->NumEntries; ++i)
							{
								if (mib_table->Table[i].InterfaceLuid == current_address->Luid)
								{
									network_adapter_info result{current_address, mib_table, i};
									FreeMibTable(mib_table);
									return std::move(result);
								}
							}

							current_address = current_address->Next;
						}

						break;
					}
					// In case of insufficient buffer size we try to recover by reallocating buffer
					if (error_code != ERROR_BUFFER_OVERFLOW)
					{
						SetLastError(error_code);
						break;
					}
				}
				while (true);
			}
			else
			{
				// GetAdaptersAddresses has failed with status different from ERROR_BUFFER_OVERFLOW when obtaining required buffer size
				if (NO_ERROR != error_code)
				{
					SetLastError(error_code);
				}
			}

			// Free interface table
			FreeMibTable(mib_table);

			return {};
		}

		/// <summary>
		/// Finds network interface by provided hardware address
		/// </summary>
		/// <param name="address">MAC address to lookup</param>
		/// <returns>optional network_adapter_info class instance</returns>
		static std::optional<network_adapter_info> get_connection_by_hw_address(const net::mac_address& address)
		{
			unsigned long dw_size = 0;
			PMIB_IF_TABLE2 mib_table = nullptr;

			SetLastError(ERROR_SUCCESS);

			// Query detailed information on available network interfaces
			auto error_code = GetIfTable2(&mib_table);

			if (NO_ERROR != error_code)
			{
				SetLastError(error_code);
				return {};
			}

			// Get available unicast addresses
			error_code = GetAdaptersAddresses(AF_UNSPEC,
			                                  GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_MULTICAST |
			                                  GAA_FLAG_INCLUDE_GATEWAYS |
			                                  GAA_FLAG_INCLUDE_ALL_INTERFACES, nullptr, nullptr, &dw_size);

			if ((ERROR_BUFFER_OVERFLOW == error_code) && dw_size)
			{
				do
				{
					auto ip_address_info = std::make_unique<unsigned char[]>(dw_size);

					error_code = GetAdaptersAddresses(AF_UNSPEC,
					                                  GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_MULTICAST |
					                                  GAA_FLAG_INCLUDE_GATEWAYS | GAA_FLAG_INCLUDE_ALL_INTERFACES,
					                                  nullptr,
					                                  reinterpret_cast<PIP_ADAPTER_ADDRESSES>(ip_address_info.get()),
					                                  &dw_size);

					if (NO_ERROR == error_code)
					{
						auto* current_address = reinterpret_cast<PIP_ADAPTER_ADDRESSES>(ip_address_info.get());

						while (current_address)
						{
							if (net::mac_address(current_address->PhysicalAddress) != address)
							{
								current_address = current_address->Next;
								continue;
							}

							// Lookup an advanced information on the network interface
							for (size_t i = 0; i < mib_table->NumEntries; ++i)
							{
								if (mib_table->Table[i].InterfaceLuid == current_address->Luid)
								{
									network_adapter_info result{current_address, mib_table, i};
									FreeMibTable(mib_table);
									return std::move(result);
								}
							}

							current_address = current_address->Next;
						}

						break;
					}

					// In case of insufficient buffer size we try to recover by reallocating buffer
					if (error_code != ERROR_BUFFER_OVERFLOW)
					{
						SetLastError(error_code);
						break;
					}
				}
				while (true);
			}
			else
			{
				// GetAdaptersAddresses has failed with status different from ERROR_BUFFER_OVERFLOW when obtaining required buffer size
				if (NO_ERROR != error_code)
				{
					SetLastError(error_code);
				}
			}

			// Free interface table
			FreeMibTable(mib_table);

			return {};
		}

		/// <summary>
		/// Finds network interface by provided GUID
		/// </summary>
		/// <param name="guid">GUID to lookup</param>
		/// <returns>optional network_adapter_info class instance</returns>
		static std::optional<network_adapter_info> get_connection_by_guid(const std::string& guid)
		{
			unsigned long dw_size = 0;
			PMIB_IF_TABLE2 mib_table = nullptr;

			SetLastError(ERROR_SUCCESS);

			// Query detailed information on available network interfaces
			auto error_code = GetIfTable2(&mib_table);

			if (NO_ERROR != error_code)
			{
				SetLastError(error_code);
				return {};
			}

			// Get available unicast addresses
			error_code = GetAdaptersAddresses(AF_UNSPEC,
			                                  GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_MULTICAST |
			                                  GAA_FLAG_INCLUDE_GATEWAYS |
			                                  GAA_FLAG_INCLUDE_ALL_INTERFACES, nullptr, nullptr, &dw_size);

			if ((ERROR_BUFFER_OVERFLOW == error_code) && dw_size)
			{
				do
				{
					auto ip_address_info = std::make_unique<unsigned char[]>(dw_size);

					error_code = GetAdaptersAddresses(AF_UNSPEC,
					                                  GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_MULTICAST |
					                                  GAA_FLAG_INCLUDE_GATEWAYS | GAA_FLAG_INCLUDE_ALL_INTERFACES,
					                                  nullptr,
					                                  reinterpret_cast<PIP_ADAPTER_ADDRESSES>(ip_address_info.get()),
					                                  &dw_size);

					if (NO_ERROR == error_code)
					{
						auto* current_address = reinterpret_cast<PIP_ADAPTER_ADDRESSES>(ip_address_info.get());

						while (current_address)
						{
							std::string adapter_name{current_address->AdapterName};
							std::transform(adapter_name.begin(), adapter_name.end(), adapter_name.begin(), toupper);
							if (adapter_name.find(guid) == std::string::npos)
							{
								current_address = current_address->Next;
								continue;
							}

							// Lookup an advanced information on the network interface
							for (size_t i = 0; i < mib_table->NumEntries; ++i)
							{
								if (mib_table->Table[i].InterfaceLuid == current_address->Luid)
								{
									network_adapter_info result{current_address, mib_table, i};
									FreeMibTable(mib_table);
									return std::move(result);
								}
							}

							current_address = current_address->Next;
						}

						break;
					}

					// In case of insufficient buffer size we try to recover by reallocating buffer
					if (error_code != ERROR_BUFFER_OVERFLOW)
					{
						SetLastError(error_code);
						break;
					}
				}
				while (true);
			}
			else
			{
				// GetAdaptersAddresses has failed with status different from ERROR_BUFFER_OVERFLOW when obtaining required buffer size
				if (NO_ERROR != error_code)
				{
					SetLastError(error_code);
				}
			}

			// Free interface table
			FreeMibTable(mib_table);

			return {};
		}
	};

	/// <summary>
	/// Base CRTP helper class to query best and routable interfaces
	/// and network changes callback notifications 
	/// </summary>
	/// <typeparam name="T">CRTP class</typeparam>
	template <typename T>
	class network_config_info
	{
		/// <summary>
		/// Lock type
		/// </summary>
		using mutex_type = std::mutex;
		/// <summary>
		/// Read lock type
		/// </summary>
		using read_lock = std::unique_lock<mutex_type>;
		/// <summary>
		/// Write lock type
		/// </summary>
		using write_lock = std::unique_lock<mutex_type>;
		/// <summary>
		/// NotifyIpInterfaceChange handle value
		/// </summary>
		HANDLE notify_ip_interface_change_{nullptr};
		/// <summary>
		/// Tracks callback enters/leaves
		/// </summary>
		std::atomic_uint32_t notify_ip_interface_ref_{0};
		/// <summary>
		/// Synchronization lock
		/// </summary>
		mutex_type lock_;

	public:
		/// <summary>
		/// Default constructor
		/// </summary>
		network_config_info() = default;

		/// <summary>
		/// Deleted copy constructor
		/// </summary>
		network_config_info(const network_config_info& other) = delete;

		/// <summary>
		/// Move constructor
		/// </summary>
		/// <param name="other">object instance to move from</param>
		network_config_info(network_config_info&& other) noexcept
		{
			write_lock rhs_lk(other.lock_);

			notify_ip_interface_change_ = other.notify_ip_interface_change_;
			other.notify_ip_interface_change_ = nullptr;
			notify_ip_interface_ref_ = other.notify_ip_interface_ref_.exchange(0);
		}

		/// <summary>
		/// Deleted copy assignment
		/// </summary>
		network_config_info& operator=(const network_config_info& other) = delete;

		/// <summary>
		/// Move assignment operator
		/// </summary>
		/// <param name="other">object instance to move from</param>
		/// <returns>this object reference</returns>
		network_config_info& operator=(network_config_info&& other)
		{
			if (this == &other)
				return *this;

			write_lock lhs_lk(lock_, std::defer_lock);
			write_lock rhs_lk(other.lock_, std::defer_lock);
			std::lock(lhs_lk, rhs_lk);

			notify_ip_interface_change_ = other.notify_ip_interface_change_;
			other.notify_ip_interface_change_ = nullptr;

			notify_ip_interface_ref_ = other.notify_ip_interface_ref_.exchange(0);
			return *this;
		}

		/// <summary>
		/// Destructor cancels NotifyIpInterfaceChange
		/// </summary>
		~network_config_info()
		{
			if (notify_ip_interface_change_)
				cancel_notify_ip_interface_change();
		}

		/// <summary>
		/// Determines best network interface to reach specified IPv4 address
		/// </summary>
		/// <param name="ip_address">IPv4 address</param>
		/// <returns>optional network_adapter_info</returns>
		static std::optional<network_adapter_info> get_best_interface(const net::ip_address_v4& ip_address)
		{
			unsigned long best_if_index = 0;
			sockaddr_in socket_address{};

			socket_address.sin_family = AF_INET;
			socket_address.sin_addr = ip_address;

			SetLastError(ERROR_SUCCESS);

			auto adapters = network_adapter_info::get_external_network_connections();

			const auto last_error_code = GetLastError();

			if (const auto error_code = GetBestInterfaceEx(reinterpret_cast<sockaddr*>(&socket_address), &best_if_index)
				; NO_ERROR == error_code)
			{
				for (auto& adapter : adapters)
				{
					if (adapter.get_if_index() == best_if_index)
						return adapter;
				}
				SetLastError(last_error_code);
			}
			else
			{
				SetLastError(error_code);
			}

			return {};
		}

		/// <summary>
		/// Determines best network interface to reach specified IPv6 address
		/// </summary>
		/// <param name="ip_address">IPv6 address</param>
		/// <returns>optional network_adapter_info</returns>
		static std::optional<network_adapter_info> get_best_interface(const net::ip_address_v6& ip_address)
		{
			unsigned long best_if_index = 0;
			sockaddr_in6 socket_address{};

			socket_address.sin6_family = AF_INET6;
			socket_address.sin6_addr = ip_address;

			auto adapters = network_adapter_info::get_external_network_connections();

			const auto last_error_code = GetLastError();

			if (const auto error_code = GetBestInterfaceEx(reinterpret_cast<sockaddr*>(&socket_address), &best_if_index)
				; NO_ERROR == error_code)
			{
				for (auto& adapter : adapters)
				{
					if (adapter.get_if_index() == best_if_index)
						return adapter;
				}
				SetLastError(last_error_code);
			}
			else
			{
				SetLastError(error_code);
			}

			return {};
		}

		/// <summary>
		/// Retrieves a list of routable network interfaces for the specified IPv4 address
		/// </summary>
		/// <param name="ip_address">IPv4 address</param>
		/// <returns>vector of network_adapter_info objects</returns>
		static std::vector<network_adapter_info> get_routable_interfaces(const net::ip_address_v4& ip_address)
		{
			auto is_valid_route = [&ip_address](auto adapter)
			{
				SOCKADDR_INET dest_address, best_route_address{};
				// ReSharper disable once CppAssignedValueIsNeverUsed
				dest_address.si_family = AF_INET;
				dest_address.Ipv4.sin_family = AF_INET;
				dest_address.Ipv4.sin_addr = ip_address;
				MIB_IPFORWARD_ROW2 forward_row{};

				if (auto error_code = GetBestRoute2(nullptr, adapter.get_if_index(), nullptr, &dest_address, 0,
				                                    &forward_row, &best_route_address); NO_ERROR != error_code)
				{
					::SetLastError(error_code);
					return true; // NOTE: shouldn't be this called is_invalid_route() instead?
				}
				return false;
			};

			auto adapters = network_adapter_info::get_external_network_connections();

			adapters.erase(std::remove_if(adapters.begin(), adapters.end(), [&is_valid_route](auto a)
			{
				return is_valid_route(a);
			}), adapters.end());

			return adapters;
		}

		/// <summary>
		/// Retrieves a list of routable network interfaces for the specified IPv6 address
		/// </summary>
		/// <param name="ip_address">IPv6 address</param>
		/// <returns>vector of network_adapter_info objects</returns>
		static std::vector<network_adapter_info> get_routable_interfaces(const net::ip_address_v6& ip_address)
		{
			auto is_valid_route = [&ip_address](auto adapter)
			{
				SOCKADDR_INET dest_address, best_route_address{};
				// ReSharper disable once CppAssignedValueIsNeverUsed
				dest_address.si_family = AF_INET6;
				dest_address.Ipv6.sin6_family = AF_INET6;
				dest_address.Ipv6.sin6_addr = ip_address;
				MIB_IPFORWARD_ROW2 forward_row{};

				if (auto error_code = GetBestRoute2(nullptr, adapter.get_if_index(), nullptr, &dest_address, 0,
				                                    &forward_row, &best_route_address); NO_ERROR != error_code)
				{
					::SetLastError(error_code);
					return true; // NOTE: shouldn't be this called is_invalid_route() instead?
				}
				return false;
			};

			auto adapters = network_adapter_info::get_external_network_connections();

			adapters.erase(std::remove_if(adapters.begin(), adapters.end(), [&is_valid_route](auto a)
			{
				return is_valid_route(a);
			}), adapters.end());

			return adapters;
		}

	protected:
		/// <summary>
		/// Sets callback for NotifyIpInterfaceChange
		/// </summary>
		/// <returns>true if successful, false otherwise</returns>
		bool set_notify_ip_interface_change() noexcept
		{
			SetLastError(ERROR_SUCCESS);

			auto error_code = ::NotifyIpInterfaceChange(AF_UNSPEC, &network_config_info::ip_interface_changed_callback,
			                                            this, FALSE, &notify_ip_interface_change_);

			if (NO_ERROR == error_code)
				return true;

			::SetLastError(error_code);

			return false;
		}

		/// <summary>
		/// Cancels callback for NotifyIpInterfaceChange
		/// </summary>
		/// <returns>true if successful, false otherwise</returns>
		bool cancel_notify_ip_interface_change() noexcept
		{
			SetLastError(ERROR_SUCCESS);

			const auto error_code = CancelMibChangeNotify2(notify_ip_interface_change_);

			notify_ip_interface_change_ = nullptr;

			if (NO_ERROR == error_code)
				return true;

			SetLastError(error_code);

			return false;
		}

		/// <summary>
		/// NotifyIpInterfaceChange callback. Calls ip_interface_changed_callback of CRTP derived class
		/// </summary>
		/// <param name="caller_context">this pointer</param>
		/// <param name="row">pointer to MIB_IPINTERFACE_ROW</param>
		/// <param name="notification_type">type of notification</param>
		/// <returns></returns>
		static void __stdcall ip_interface_changed_callback(void* caller_context, PMIB_IPINTERFACE_ROW row,
		                                                    MIB_NOTIFICATION_TYPE notification_type)
		{
			if (auto* const this_pointer = static_cast<T*>(caller_context); this_pointer)
			{
				this_pointer->notify_ip_interface_ref_.fetch_add(1);
				this_pointer->ip_interface_changed_callback(row, notification_type);
				this_pointer->notify_ip_interface_ref_.fetch_sub(1);
			}
		}

		/// <summary>
		/// Checks if enter/leave reference counter is zero and we can unload
		/// </summary>
		/// <returns>true if unload is possible, false otherwise</returns>
		bool notify_ip_interface_can_unload() const
		{
			return (notify_ip_interface_ref_ == 0);
		}
	};
}

```

`examples/cpp/common/iphelper/process_lookup.h`:

```h
#pragma once

namespace iphelper
{
	// --------------------------------------------------------------------------------
	/// <summary>
	/// Represents a networking application
	/// </summary>
	// --------------------------------------------------------------------------------
	struct network_process
	{
		/// <summary>
		/// Default constructor
		/// </summary>
		network_process() = default;

		/// <summary>
		/// Constructs object instance from provided process ID, name and path
		/// </summary>
		/// <param name="id">process ID</param>
		/// <param name="name">process name</param>
		/// <param name="path">path to the executable</param>
		network_process(const unsigned long id, std::wstring name, std::wstring path) :
			id(id), name(std::move(name)), path_name(std::move(path))
		{
		}

		unsigned long id{};
		std::wstring name;
		std::wstring path_name;
	};

	// --------------------------------------------------------------------------------
	/// <summary>
	/// process_lookup class utilizes IP Helper API to match TCP/UDP network packet to local process
	/// Designed as a singleton
	/// </summary>
	/// <typeparam name="T">net::ip_address_v4 or net::ip_address_v6</typeparam>
	// --------------------------------------------------------------------------------
	template <typename T>
	class process_lookup final
	{
		/// <summary>
		/// Type to store TCP sessions
		/// </summary>
		using tcp_hashtable_t = std::unordered_map<net::ip_session<T>, std::shared_ptr<network_process>>;
		/// <summary>
		/// Type to store UDP sessions
		/// </summary>
		using udp_hashtable_t = std::unordered_map<net::ip_endpoint<T>, std::shared_ptr<network_process>>;

		/// <summary>
		/// Private constructor. Initializes current state of TCP/UDP connections.
		/// </summary>
		process_lookup()
		{
			default_process_ = std::make_shared<network_process>(0, L"SYSTEM", L"SYSTEM");

			initialize_tcp_table();
			initialize_udp_table();
		}

	public:
		/// <summary>
		/// Deleted copy constructor
		/// </summary>
		process_lookup(const process_lookup& other) = delete;
		/// <summary>
		/// deleted move constructor
		/// </summary>
		process_lookup(process_lookup&& other) noexcept = delete;
		/// <summary>
		/// Deleted copy assignment
		/// </summary>
		process_lookup& operator=(const process_lookup& other) = delete;
		/// <summary>
		/// Deleted move assignment
		/// </summary>
		process_lookup& operator=(process_lookup&& other) noexcept = delete;

	private:
		/// <summary>
		/// TCP sessions hashtable
		/// </summary>
		tcp_hashtable_t tcp_to_app_;
		/// <summary>
		/// UDP sessions hashtable
		/// </summary>
		udp_hashtable_t udp_to_app_;

		/// <summary>
		/// Lock to control access to TCP sessions hashtable
		/// </summary>
		std::shared_mutex tcp_to_app_lock_;
		/// <summary>
		/// Lock to control access to UDP sessions hashtable
		/// </summary>
		std::shared_mutex udp_to_app_lock_;
		/// <summary>
		/// Default process used when process lookup in not possible via IP Helper API
		/// Usually IP Helper API fails for system processes
		/// </summary>
		std::shared_ptr<network_process> default_process_;
		/// <summary>
		/// Memory buffer to query TCP connection tables
		/// </summary>
		std::unique_ptr<char[]> table_buffer_tcp_{};
		/// <summary>
		/// Memory buffer to query UDP connection tables
		/// </summary>
		std::unique_ptr<char[]> table_buffer_udp_{};
		/// <summary>
		/// Current size of the memory buffer to query TCP connection tables
		/// </summary>
		DWORD table_buffer_size_tcp_{0};
		/// <summary>
		/// Current size of the memory buffer to query UDP connection tables
		/// </summary>
		DWORD table_buffer_size_udp_{ 0 };

	public:
		/// <summary>
		/// Constructs (only once) and returns process_lookup object reference
		/// </summary>
		/// <returns>process_lookup object reference</returns>
		static process_lookup& get_process_helper()
		{
			static process_lookup instance;
			return instance;
		}

		/// <summary>
		/// Default destructor
		/// </summary>
		~process_lookup() = default;

		/// <summary>
		/// Searches process by provided TCP session information
		/// </summary>
		/// <typeparam name="SetToDefault">when true and fail to lookup the process sets to default</typeparam>
		/// <param name="session">TCP session to lookup</param>
		/// <returns>shared pointer to network_process instance</returns>
		template <bool SetToDefault>
		std::shared_ptr<network_process> lookup_process_for_tcp(const net::ip_session<T>& session)
		{
			// Try to lookup in the current table
			std::shared_lock slock(tcp_to_app_lock_);

			if (auto it_first = tcp_to_app_.find(session); it_first != tcp_to_app_.end())
			{
				return it_first->second;
			}

			if constexpr (SetToDefault)
			{
				slock.unlock();

				std::unique_lock<std::shared_mutex> lock(tcp_to_app_lock_);
				tcp_to_app_[session] = default_process_;
				return default_process_;
			}
			else
			{
				return nullptr;
			}
		}

		/// <summary>
		/// Searches process by provided UDP endpoint information
		/// </summary>
		/// <typeparam name="SetToDefault">when true and fail to lookup the process sets to default</typeparam>
		/// <param name="endpoint">UDP endpoint to lookup</param>
		/// <returns>shared pointer to network_process instance</returns>
		template <bool SetToDefault>
		std::shared_ptr<network_process> lookup_process_for_udp(const net::ip_endpoint<T>& endpoint)
		{
			// UDP endpoints may have 0.0.0.0:137 form
			auto zero_ip_endpoint = endpoint;
			zero_ip_endpoint.ip = T{};

			// Try to lookup in the current table
			std::shared_lock<std::shared_mutex> slock(udp_to_app_lock_);

			if (auto it_first = udp_to_app_.find(endpoint); it_first != udp_to_app_.end())
			{
				return it_first->second;
			}
			else
			{
				// Search for 0.0.0.0:port
				it_first = udp_to_app_.find(zero_ip_endpoint);

				if (it_first != udp_to_app_.end())
				{
					return it_first->second;
				}
				if constexpr (SetToDefault)
				{
					slock.unlock();

					std::unique_lock<std::shared_mutex> lock(udp_to_app_lock_);
					udp_to_app_[endpoint] = default_process_;
					return default_process_;
				}
				else
				{
					return nullptr;
				}
			}
		}

		/// <summary>
		/// Updates TCP/UDP hash tables
		/// </summary>
		/// <param name="tcp">set to true to update TCP table</param>
		/// <param name="udp">set to true to update UDP table</param>
		/// <returns>true if successful, false if error occurred</returns>
		bool actualize(const bool tcp, const bool udp)
		{
			auto ret_tcp = true, ret_udp = true;

			if (tcp)
			{
				std::lock_guard<std::shared_mutex> lock(tcp_to_app_lock_);
				ret_tcp = initialize_tcp_table();
			}

			if (udp)
			{
				std::lock_guard<std::shared_mutex> lock(udp_to_app_lock_);
				ret_udp = initialize_udp_table();
			}

			return (ret_udp && ret_tcp);
		}

		/// <summary>
		/// Returns current TCP hash table string representation
		/// </summary>
		/// <returns>string with TCP hash table entries dumped</returns>
		std::string dump_tcp_table()
		{
			std::ostringstream oss;

			std::shared_lock<std::shared_mutex> lock(tcp_to_app_lock_);
			std::for_each(tcp_to_app_.begin(), tcp_to_app_.end(), [&oss](auto&& entry)
			{
				oss << std::string(entry.first.local.ip) << " : " << entry.first.local.port <<
					" <---> " << std::string(entry.first.remote.ip) << " : " << entry.first.remote.port <<
					" : " << entry.second->id << " : " << wstring_to_string(entry.second->name) << std::endl;
			});

			return oss.str();
		}

		/// <summary>
		/// Returns current UDP hash table string representation
		/// </summary>
		/// <returns>string with UDP hash table entries dumped</returns>
		std::string dump_udp_table()
		{
			std::ostringstream oss;

			std::shared_lock<std::shared_mutex> lock(udp_to_app_lock_);
			std::for_each(udp_to_app_.begin(), udp_to_app_.end(), [&oss](auto&& entry)
			{
				oss << std::string(entry.first.ip) << " : " << entry.first.port <<
					" : " << entry.second->id << " : " << wstring_to_string(entry.second->name) << std::endl;
			});

			return oss.str();
		}

	private:
		/// <summary>
		/// Convert wide char string to char string. Valid only for ASCII strings
		/// </summary>
		/// <param name="s">wide char string to convert</param>
		/// <returns></returns>
		static std::string wstring_to_string(const std::wstring& s)
		{
			std::string result;
			std::transform(s.begin(), s.end(), std::back_inserter(result),
			               [](auto&& e) { return static_cast<char>(e); });
			return result;
		}

		/// @brief Processes a TCP table entry for IPv4 and retrieves the owner module information.
		/// @details This function takes a PMIB_TCPROW_OWNER_MODULE entry for IPv4, retrieves owner module information, 
		///          and constructs a shared_ptr<network_process> object with the obtained information.
		/// @param table_entry The PMIB_TCPROW_OWNER_MODULE entry to be processed.
		/// @return A shared_ptr<network_process> object with the owner module information, or nullptr if the operation fails.
		std::shared_ptr<network_process> process_tcp_entry_v4(const PMIB_TCPROW_OWNER_MODULE table_entry) const
		{
			DWORD size = 0;
			std::shared_ptr<network_process> process_ptr(nullptr);

			if (ERROR_INSUFFICIENT_BUFFER == GetOwnerModuleFromTcpEntry(
				table_entry, TCPIP_OWNER_MODULE_INFO_BASIC, nullptr, &size)) {
				const auto module_ptr = std::make_unique<char[]>(size);

				if (auto* info = reinterpret_cast<PTCPIP_OWNER_MODULE_BASIC_INFO>(module_ptr.get());
					GetOwnerModuleFromTcpEntry(table_entry, TCPIP_OWNER_MODULE_INFO_BASIC, info, &size) == NO_ERROR &&
					info->pModuleName && info->pModulePath) {
					process_ptr = std::make_shared<network_process>(table_entry->dwOwningPid, info->pModuleName, info->pModulePath);
				}
			}

			return process_ptr;
		}

		/// @brief Processes a TCP table entry for IPv6 and retrieves the owner module information.
		/// @details This function takes a PMIB_TCP6ROW_OWNER_MODULE entry for IPv6, retrieves owner module information,
		///          and constructs a shared_ptr<network_process> object with the obtained information.
		/// @param table_entry The PMIB_TCP6ROW_OWNER_MODULE entry to be processed.
		/// @return A shared_ptr<network_process> object with the owner module information, or nullptr if the operation fails.
		std::shared_ptr<network_process> process_tcp_entry_v6(const PMIB_TCP6ROW_OWNER_MODULE table_entry) const
		{
			DWORD size = 0;
			std::shared_ptr<network_process> process_ptr(nullptr);

			if (ERROR_INSUFFICIENT_BUFFER == GetOwnerModuleFromTcp6Entry(
				table_entry, TCPIP_OWNER_MODULE_INFO_BASIC, nullptr, &size)) {
				const auto module_ptr = std::make_unique<char[]>(size);

				if (auto* info = reinterpret_cast<PTCPIP_OWNER_MODULE_BASIC_INFO>(module_ptr.get());
					GetOwnerModuleFromTcp6Entry(table_entry, TCPIP_OWNER_MODULE_INFO_BASIC, info, &size) == NO_ERROR &&
					info->pModuleName && info->pModulePath) {
					process_ptr = std::make_shared<network_process>(table_entry->dwOwningPid, info->pModuleName, info->pModulePath);
				}
			}

			return process_ptr;
		}

		/// @brief Initializes or updates the TCP hashtable by retrieving the extended TCP table for the selected IP address type.
		/// @details This function retrieves the extended TCP table and processes each entry to obtain owner module information. 
		///          It then updates the tcp_to_app_ map with the network_process information for each IP session.
		/// @returns true if successful, false otherwise.
		bool initialize_tcp_table()
		{
			try
			{
				auto table_size = table_buffer_size_tcp_;
				tcp_to_app_.clear();

				while (true) {
					if (const uint32_t result = ::GetExtendedTcpTable(table_buffer_tcp_.get(), &table_size, FALSE, T::af_type,
					                                                  TCP_TABLE_OWNER_MODULE_CONNECTIONS, 0); result == ERROR_INSUFFICIENT_BUFFER) {
						table_size *= 2;
						table_buffer_tcp_ = std::make_unique<char[]>(table_size);
						table_buffer_size_tcp_ = table_size;
					} else if (result == NO_ERROR) {
						break;
					} else {
						return false;
					}
				}
				if constexpr (std::is_same_v<T, net::ip_address_v4>) {
					auto* table = reinterpret_cast<PMIB_TCPTABLE_OWNER_MODULE>(table_buffer_tcp_.get());

					for (size_t i = 0; i < table->dwNumEntries; i++) {
						if (auto process_ptr = process_tcp_entry_v4(&table->table[i])) {
							tcp_to_app_[net::ip_session<T>(T{table->table[i].dwLocalAddr},
															T{table->table[i].dwRemoteAddr},
															ntohs(static_cast<uint16_t>(table->table[i].dwLocalPort)),
															ntohs(static_cast<uint16_t>(table->table[i].dwRemotePort)))] = std::move(process_ptr);
						}
					}
				} else {
					auto* table = reinterpret_cast<PMIB_TCP6TABLE_OWNER_MODULE>(table_buffer_tcp_.get());

					for (size_t i = 0; i < table->dwNumEntries; i++) {
						if (auto process_ptr = process_tcp_entry_v6(&table->table[i])) {
							tcp_to_app_[net::ip_session<T>(T{table->table[i].ucLocalAddr},
															T{table->table[i].ucRemoteAddr},
															ntohs(static_cast<uint16_t>(table->table[i].dwLocalPort)),
															ntohs(static_cast<uint16_t>(table->table[i].dwRemotePort)))] = std::move(process_ptr);
						}
					}
				}
			}
			catch (...)
			{
				return false;
			}

			return true;
		}

		/// @brief Processes an IPv4 UDP table entry
		/// @param entry An IPv4 UDP table entry
		/// @return A shared_ptr to a network_process object if successful, nullptr otherwise
		std::shared_ptr<network_process> process_udp_entry_v4(const PMIB_UDPROW_OWNER_MODULE entry) const
		{
			DWORD size = 0;
			std::shared_ptr<network_process> process_ptr(nullptr);

			if (ERROR_INSUFFICIENT_BUFFER == GetOwnerModuleFromUdpEntry(
				entry, TCPIP_OWNER_MODULE_INFO_BASIC, nullptr, &size)) {
				const auto module_ptr = std::make_unique<char[]>(size);

				if (auto* info = reinterpret_cast<PTCPIP_OWNER_MODULE_BASIC_INFO>(module_ptr.get());
					GetOwnerModuleFromUdpEntry(entry, TCPIP_OWNER_MODULE_INFO_BASIC, info, &size) == NO_ERROR &&
					info->pModuleName && info->pModulePath) {
					process_ptr = std::make_shared<network_process>(entry->dwOwningPid, info->pModuleName, info->pModulePath);
				}
			}

			return process_ptr;
		}

		/// @brief Processes an IPv6 UDP table entry
		/// @param entry An IPv6 UDP table entry
		/// @return A shared_ptr to a network_process object if successful, nullptr otherwise
		std::shared_ptr<network_process> process_udp_entry_v6(const PMIB_UDP6ROW_OWNER_MODULE entry) const
		{
			DWORD size = 0;
			std::shared_ptr<network_process> process_ptr(nullptr);

			if (ERROR_INSUFFICIENT_BUFFER == GetOwnerModuleFromUdp6Entry(
				entry, TCPIP_OWNER_MODULE_INFO_BASIC, nullptr, &size)) {
				const auto module_ptr = std::make_unique<char[]>(size);

				if (auto* info = reinterpret_cast<PTCPIP_OWNER_MODULE_BASIC_INFO>(module_ptr.get());
					GetOwnerModuleFromUdp6Entry(entry, TCPIP_OWNER_MODULE_INFO_BASIC, info, &size) == NO_ERROR &&
					info->pModuleName && info->pModulePath) {
					process_ptr = std::make_shared<network_process>(entry->dwOwningPid, info->pModuleName, info->pModulePath);
				}
			}

			return process_ptr;
		}

		/// @brief Initializes/updates UDP hashtable
		/// @details This function initializes or updates the UDP hashtable with network_process objects,
		///          mapping IP endpoints to their owner processes.
		/// @return true if successful, false otherwise
		bool initialize_udp_table() {
			auto table_size = table_buffer_size_udp_;
			udp_to_app_.clear();

			try {
				do {
					const uint32_t result = ::GetExtendedUdpTable(table_buffer_udp_.get(), &table_size, FALSE, T::af_type,
						UDP_TABLE_OWNER_MODULE, 0);

					if (result == ERROR_INSUFFICIENT_BUFFER) {
						table_size *= 2;
						table_buffer_udp_ = std::make_unique<char[]>(table_size);
						table_buffer_size_udp_ = table_size;
						continue;
					}

					if (result == NO_ERROR) {
						break;
					}

					return false;
				} while (true);

				if constexpr (std::is_same_v<T, net::ip_address_v4>) {
					auto* table = reinterpret_cast<PMIB_UDPTABLE_OWNER_MODULE>(table_buffer_udp_.get());

					for (size_t i = 0; i < table->dwNumEntries; i++) {
						if (auto process_ptr = process_udp_entry_v4(&table->table[i])) {
							udp_to_app_[net::ip_endpoint<T>(
								T{ table->table[i].dwLocalAddr },
								ntohs(static_cast<uint16_t>(table->table[i].dwLocalPort)))] = std::move(process_ptr);
						}
					}
				}
				else {
					auto* table = reinterpret_cast<PMIB_UDP6TABLE_OWNER_MODULE>(table_buffer_udp_.get());

					for (size_t i = 0; i < table->dwNumEntries; i++) {
						if (auto process_ptr = process_udp_entry_v6(&table->table[i])) {
							udp_to_app_[net::ip_endpoint<T>(
								T{ table->table[i].ucLocalAddr },
								ntohs(static_cast<uint16_t>(table->table[i].dwLocalPort)))] = std::move(process_ptr);
						}
					}
				}
			}
			catch (...) {
				return false;
			}

			return true;
		}

	};
}

```

`examples/cpp/common/iphlp.h`:

```h
// --------------------------------------------------------------------------------
/// <summary>
/// Module Name:  iphlp.h
/// Abstract: TCP/IP definitions
/// </summary>
// --------------------------------------------------------------------------------

#pragma once

#pragma pack(1) 

/// <summary>packet structures</summary>

typedef long n_long;
typedef short n_short;
typedef long n_time;
typedef unsigned short u_short;
typedef unsigned long u_long;
typedef unsigned char u_char;
typedef struct in_addr IN_ADDR, *PIN_ADDR;

#define ETH_ALEN				6		/* Octets in one ethernet addr	 */
#define ETHER_HEADER_LENGTH		14		/* Ethernet header length */

#define ETH_P_ARP		0x0806			/* Address Resolution packet	*/
#define ARPHRD_ETHER	0x01
#define ARPOP_REQUEST	0x01
#define ARPOP_REPLY		0x02

#define ETH_P_IP		0x0800			/* Internet Protocol packet	*/
#define ETH_P_IP_NET	0x0008			/* Internet Protocol packet	network order*/
#define ETH_P_RARP      0x8035			/* Reverse Addr Res packet	*/
#define ETH_P_ARP		0x0806			/* Address Resolution packet	*/

#define ETH_P_IPV6		0x86dd 			/* Internet Protocol V6 packet	*/
#define ETH_P_IPV6_NET	0xdd86 			/* Internet Protocol V6 packet network order*/

/// <summary>Protocols</summary>

#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_IGMP            2               /* group management protocol */
#define IPPROTO_GGP             3               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ICMPV6			58				/* control message protocol v6*/
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

// --------------------------------------------------------------------------------
/// <summary>
/// Ethernet Header
/// </summary>
// --------------------------------------------------------------------------------

typedef struct ether_header 
{
	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
	unsigned short	h_proto;		/* packet type ID field	*/
} ether_header, *ether_header_ptr;

// --------------------------------------------------------------------------------
/// <summary>
/// Address Resolution Protocol (ARP)
/// </summary>
// --------------------------------------------------------------------------------

typedef struct arphdr
{
	unsigned short	ar_hrd;		/* format of hardware address	*/
	unsigned short	ar_pro;		/* format of protocol address	*/
	unsigned char	ar_hln;		/* length of hardware address	*/
	unsigned char	ar_pln;		/* length of protocol address	*/
	unsigned short	ar_op;		/* ARP opcode (command)		*/
} arphdr, *arphdr_ptr;

typedef struct	ether_arp 
{
	struct	arphdr ea_hdr;	/* fixed-size header */
	u_char	arp_sha[ETH_ALEN];	/* sender hardware address */
	u_char	arp_spa[4];	/* sender protocol address */
	u_char	arp_tha[ETH_ALEN];	/* target hardware address */
	u_char	arp_tpa[4];	/* target protocol address */
} ether_arp, *ether_arp_ptr;

#define	arp_hrd	ea_hdr.ar_hrd
#define	arp_pro	ea_hdr.ar_pro
#define	arp_hln	ea_hdr.ar_hln
#define	arp_pln	ea_hdr.ar_pln
#define	arp_op	ea_hdr.ar_op

// --------------------------------------------------------------------------------
/// <summary>
/// IP Header in Little Endian
/// </summary>
// --------------------------------------------------------------------------------

typedef struct iphdr 
{
	u_char	ip_hl:4,		/* header length */
			ip_v:4;			/* version */
	u_char	ip_tos;			/* type of service */
	u_short	ip_len;			/* total length */
	u_short	ip_id;			/* identification */
	u_short	ip_off;			/* fragment offset field */
#define	IP_DF 0x4000		/* dont fragment flag */
#define	IP_MF 0x2000		/* more fragments flag */
	u_char	ip_ttl;			/* time to live */
	u_char	ip_p;			/* protocol */
	u_short	ip_sum;			/* checksum */
	struct	in_addr ip_src,ip_dst;	/* source and dest address */
} iphdr, *iphdr_ptr;

// --------------------------------------------------------------------------------
/// <summary>
/// UDP header
/// </summary>
// --------------------------------------------------------------------------------

typedef struct	udphdr
{
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	u_short	length;			/* data length */
	u_short	th_sum;			/* checksum */
} udphdr, *udphdr_ptr;

typedef	u_long	tcp_seq;

// --------------------------------------------------------------------------------
/// <summary>
/// TCP header. Per RFC 793, September, 1981. In Little Endian
/// </summary>
// --------------------------------------------------------------------------------

typedef struct tcphdr {
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	tcp_seq	th_seq;			/* sequence number */
	tcp_seq	th_ack;			/* acknowledgement number */
	u_char	th_x2:4,		/* (unused) */
			th_off:4;		/* data offset */
#define TCP_NO_OPTIONS	0x05
	u_char	th_flags;
#define	TH_FIN	0x01
#define	TH_SYN	0x02
#define	TH_RST	0x04
#define	TH_PSH	0x08
#define	TH_ACK	0x10
#define	TH_URG	0x20
	u_short	th_win;			/* window */
	u_short	th_sum;			/* checksum */
	u_short	th_urp;			/* urgent pointer */
} tcphdr, *tcphdr_ptr;

typedef struct pseudo_header
{
  struct in_addr source_address;
  struct in_addr dest_address;
  unsigned char placeholder;
  unsigned char protocol;
  unsigned short tcp_length;

}pseudo_header, *pseudo_header_ptr;

/// <summary>Protocols for IPv6</summary>

#define IPPROTO_HOPOPTS		0             // Hop by hop header for v6
#define IPPROTO_IPV6		41            // IPv6 encapsulated in IP
#define IPPROTO_ROUTING		43            // Routing header for IPv6
#define IPPROTO_FRAGMENT	44            // Fragment header for IPv6
#define IPPROTO_ICMPV6		58            // ICMP for IPv6
#define IPPROTO_NONE		59            // No next header for IPv6
#define IPPROTO_DSTOPTS		60            // Destinations options

// --------------------------------------------------------------------------------
/// <summary>
/// IPv6 header format
/// </summary>
// --------------------------------------------------------------------------------

typedef struct ipv6hdr 
{	
	unsigned char	ip6_class_hi : 4,
					ip6_v : 4;			// 4  bits = version #
	unsigned char	ip6_flow_hi : 4, 
					ip6_class_lo : 4;	// 8  bits = Traffic class,
	unsigned short	ip6_flow_lo;		// 20 bits = flow label
	unsigned short	ip6_len;			// Payload length
	unsigned char	ip6_next;			// Next Header
	unsigned char	ip6_hops;			// Hop Limit
	IN6_ADDR		ip6_src;			// Source Address
	IN6_ADDR		ip6_dst;			// Destination Address
} ipv6hdr, *ipv6hdr_ptr;

// --------------------------------------------------------------------------------
/// <summary>
/// IPv6 extension header format
/// </summary>
// --------------------------------------------------------------------------------

typedef struct ipv6ext {
	unsigned char    ip6_next;		// Next Header
	unsigned char    ip6_len;		// number of bytes in this header 
	unsigned char    ip6_data[2];	// optional data
}ipv6ext, *ipv6ext_ptr;

typedef struct ipv6ext_frag
{
    unsigned char		ip6_next;       // next header
    unsigned char		ip6_reserved;   // reserved field
    unsigned short		ip6_offlg;      // offset, reserved, and flag
    unsigned int		ip6_ident;      // identification
}ipv6ext_frag, *ipv6ext_frag_ptr;

typedef struct mss_tcp_options {
#define	MSS_TYPE	0x02
#define	SACK_TYPE	0x04
	u_char  mss_type;
	u_char  mss_option_length;
	u_short mss_value;
}mss_tcp_options, *mss_tcp_options_ptr;

// --------------------------------------------------------------------------------
/// <summary>
/// ICMP header
/// </summary>
// --------------------------------------------------------------------------------

typedef struct icmphdr {
	unsigned char type;          // ICMP packet type
	unsigned char code;          // Type sub code
	unsigned short checksum;
	unsigned short id;
	unsigned short seq;
}icmphdr, *icmphdr_ptr;

// --------------------------------------------------------------------------------
/// <summary>
/// ICMPv6 header
/// </summary>
// -------------------------------------------------------------------------------

typedef struct icmpv6hdr {
	unsigned char type;          // ICMP packet type
	unsigned char code;          // Type sub code
	unsigned short checksum;
}icmpv6hdr, * icmpv6hdr_ptr;

// --------------------------------------------------------------------------------
/// <summary>
/// http://www.nersc.gov/~scottc/software/snort/dns_head.html
/// Header
/// Question
/// Answer
/// Authority
/// Additional
/// </summary>
// --------------------------------------------------------------------------------

typedef struct dns_header {
	unsigned short id;
	unsigned short flags;
	unsigned short qdcount;
	unsigned short ancount;
	unsigned short nscount;
	unsigned short arcount;
}dns_header, *dns_header_ptr;

// --------------------------------------------------------------------------------
/// <summary>
/// Resource record
/// NAME		Name of the node to which this record pertains.	(variable)
/// TYPE		Type of RR. For example, MX is type 15.	(2 bytes)
/// CLASS		Class code.	2 bytes
/// TTL			Unsigned time in seconds that RR stays valid, maximum is 2147483647. (4 bytes)
/// RDLENGTH	Length of RDATA field. (2 bytes)
/// RDATA		Additional RR-specific data. (variable)
/// </summary>
// --------------------------------------------------------------------------------

typedef struct qr_record {
	uint16_t type;
	uint16_t clas;
} qr_record, *qr_record_ptr;

typedef struct res_record {
	uint16_t type;
	uint16_t clas;
	uint32_t ttl;
	uint16_t rdlength;
} res_record, *res_record_ptr;

#pragma pack()

```

`examples/cpp/common/log/log.h`:

```h
#pragma once

namespace netlib::log
{
	enum class log_level : uint32_t
	{
		error = 0,
		info = 1,
		debug = 2,
		all = 3,
	};
}

```

`examples/cpp/common/ndisapi/dual_packet_filter.h`:

```h
// --------------------------------------------------------------------------------
/// <summary>
/// Module Name:  dual_packet_filter.h 
/// Abstract: Dual interface packet filter class
/// </summary>
// --------------------------------------------------------------------------------

#pragma once

namespace ndisapi
{
	// --------------------------------------------------------------------------------
	/// <summary>
	/// Dual interface winpkfilter based filter class for quick prototyping 
	/// </summary>
	// --------------------------------------------------------------------------------
	class dual_packet_filter final : public CNdisApi
	{
	public:
		/// <summary>
		/// Defines packet action
		/// </summary>
		enum class packet_action
		{
			/// <summary>
			/// pass the packet over
			/// </summary>
			pass,
			/// <summary>
			/// drop the packet
			/// </summary>
			drop,
			/// <summary>
			/// change packet direction (e.g. forward incoming packet out)
			/// </summary>
			revert,
			/// <summary>
			/// forward packet via another network interface
			/// </summary>
			route,
			/// <summary>
			/// forward packet via another network interface and change its direction
			/// </summary>
			route_revert
		};

	private:
		/// <summary>
		/// Defines maximum number of network packets to read via one I/O operation
		/// </summary>
		static constexpr size_t maximum_packet_block = 510;

		/// <summary>
		/// Storage type for the I/O operations
		/// </summary>
		using request_storage_type_t = std::aligned_storage_t<sizeof(ETH_M_REQUEST) +
		                                                      sizeof(NDISRD_ETH_Packet) * (maximum_packet_block - 1),
		                                                      0x1000>;

		/// <summary>
		/// Defines current NDIS filtering state
		/// </summary>
		enum class filter_state
		{
			stopped,
			starting,
			running,
			stopping
		};

		/// <summary>
		/// Constructor
		/// </summary>
		dual_packet_filter():
			adapter_event_(CreateEvent(nullptr, TRUE, FALSE, nullptr))
		{
			SetAdapterListChangeEvent(static_cast<HANDLE>(adapter_event_));
			allocate_storage();
			initialize_network_interfaces();

			adapter_watch_thread_ = std::thread([this]()
			{
				while (!adapter_watch_exit_.load())
				{
					[[maybe_unused]] auto wait_result = adapter_event_.wait(INFINITE);
					[[maybe_unused]] auto reset_result = adapter_event_.reset_event();

					if (adapter_watch_exit_.load())
						return;

					TCP_AdapterList ad_list;

					GetTcpipBoundAdaptersInfo(&ad_list);

					std::pair adapter_flags{false, false};

					for (size_t i = 0; i < ad_list.m_nAdapterCount; ++i)
					{
						if (adapter_[0].load() == ad_list.m_nAdapterHandle[i])
						{
							adapter_flags.first = true;
						}
						else if (adapter_[1].load() == ad_list.m_nAdapterHandle[i])
						{
							adapter_flags.second = true;
						}
					}

					if (const auto adapter_handle = adapter_[0].load(); adapter_handle && !adapter_flags.first)
					{
						if (auto adapter_idx = get_adapter_by_handle(adapter_handle); adapter_idx.has_value())
						{
							std::cout << "[dual_packet_filter] : " << network_interfaces_[adapter_idx.value()]->
								get_friendly_name() << " : removed. Stopping filter!\n";
						}
						stop_filter(0);
					}

					if (const auto adapter_handle = adapter_[1].load(); adapter_handle && !adapter_flags.second)
					{
						if (auto adapter_idx = get_adapter_by_handle(adapter_handle); adapter_idx.has_value())
						{
							std::cout << "[dual_packet_filter] : " << network_interfaces_[adapter_idx.value()]->
								get_friendly_name() << " : removed. Stopping filter!\n";
						}
						stop_filter(1);
					}

					if (!adapter_flags.second || !adapter_flags.first)
						update_network_interfaces();

					std::shared_lock lock(lock_);
					for (auto& callback : adapters_change_callback_)
					{
						if (callback != nullptr)
						{
							callback();
						}
					}
				}
			});
		}

	public:
		// ********************************************************************************
		/// <summary>
		/// Destructor: stops filtering and releases resources
		/// </summary>
		~dual_packet_filter() override
		{
			adapter_watch_exit_.store(true);
			[[maybe_unused]] auto signal_result = adapter_event_.signal();

			stop_filter(0);
			stop_filter(1);

			if (adapter_watch_thread_.joinable())
				adapter_watch_thread_.join();
		}

		/// <summary>
		/// Deleted copy constructor
		/// </summary>
		dual_packet_filter(const dual_packet_filter& other) = delete;
		/// <summary>
		/// Deleted move constructor
		/// </summary>
		dual_packet_filter(dual_packet_filter&& other) noexcept = delete;
		/// <summary>
		/// Deleted copy assignment
		/// </summary>
		dual_packet_filter& operator=(const dual_packet_filter& other) = delete;
		/// <summary>
		/// Deleted move assignment
		/// </summary>
		dual_packet_filter& operator=(dual_packet_filter&& other) noexcept = delete;

		// ********************************************************************************
		/// <summary>
		/// Constructs dual_packet_filter
		/// </summary>
		/// <param name="first_in">primary incoming packets handling routine</param>
		/// <param name="first_out">primary outgoing packet handling routine</param>
		/// <param name="second_in">secondary incoming packets handling routine</param>
		/// <param name="second_out">secondary outgoing packet handling routine</param>
		/// <returns></returns>
		// ********************************************************************************
		template <typename F1, typename F2, typename F3, typename F4>
		dual_packet_filter(F1 first_in, F2 first_out, F3 second_in, F4 second_out) : dual_packet_filter()
		{
			filter_incoming_packet_[0] = first_in;
			filter_outgoing_packet_[0] = first_out;
			filter_incoming_packet_[1] = second_in;
			filter_outgoing_packet_[1] = second_out;
		}

		// ********************************************************************************
		/// <summary>
		/// Updates available network interfaces.
		/// </summary>
		/// <returns>status of the operation</returns>
		// ********************************************************************************
		bool reconfigure();

		// ********************************************************************************
		/// <summary>
		/// Starts packet filtering
		/// </summary>
		/// <param name="adapter">network interface handle to filter</param>
		/// <param name="index">0 for primary adapter, 1 for secondary</param>
		/// <returns>status of the operation</returns>
		// ********************************************************************************
		bool start_filter(HANDLE adapter, size_t index);

		// ********************************************************************************
		/// <summary>
		/// Stops packet filtering
		/// </summary>
		/// <param name="index">0 for primary adapter, 1 for secondary</param>
		/// <returns>status of the operation</returns>
		// ********************************************************************************
		bool stop_filter(size_t index);

		// ********************************************************************************
		/// <summary>
		/// Queries the list of the names for the available network interfaces
		/// </summary>
		/// <returns>list of network adapters friendly names</returns>
		// ********************************************************************************
		std::vector<std::string> get_interface_names_list() const;

		// ********************************************************************************
		/// <summary>
		/// Queries the list of the available network interfaces
		/// </summary>
		/// <returns>vector of available network adapters</returns>
		// ********************************************************************************
		const std::vector<std::shared_ptr<network_adapter>>& get_interface_list() const;

		// ********************************************************************************
		/// <summary>
		/// Resets adapter filter mode for the specified network interface
		/// </summary>
		/// <param name="adapter">adapter handle to reset</param>
		/// <returns>boolean result of the operation</returns>
		// ********************************************************************************
		bool reset_adapter_mode(HANDLE adapter) const
		{
			ADAPTER_MODE mode = {adapter, 0};
			return SetAdapterMode(&mode);
		}

		// ********************************************************************************
		/// <summary>
		/// Checks if adapter is in non-default filter mode for the specified network interface
		/// </summary>
		/// <param name="adapter">adapter handle </param>
		/// <returns>false if adapter is in filter mode, true otherwise</returns>
		// ********************************************************************************
		bool is_default_adapter_mode(HANDLE adapter) const
		{
			ADAPTER_MODE mode = {adapter, 0};
			if (GetAdapterMode(&mode))
			{
				return (mode.dwFlags == 0);
			}

			return true;
		}

		// ********************************************************************************
		/// <summary>
		/// Registers adapter change callback
		/// </summary>
		/// <param name="callback">callback function</param>
		/// <returns>true if successful, false otherwise</returns>
		// ********************************************************************************
		bool register_adapters_callback(std::function<void()> callback)
		{
			try
			{
				std::lock_guard lock(lock_);
				adapters_change_callback_.emplace_back(std::move(callback));
			}
			catch (...)
			{
				return false;
			}

			return true;
		}

		// ********************************************************************************
		/// <summary>
		/// Updates available network interface list
		/// </summary>
		// ********************************************************************************
		bool update_network_interfaces();

	private:
		// ********************************************************************************
		/// <summary>
		/// Working thread routine
		/// </summary>
		/// <param name="index">0 for primary adapter, 1 for secondary</param>
		/// <param name="adapter">network_adapter class instance</param>
		// ********************************************************************************
		void filter_working_thread(size_t index, std::shared_ptr<network_adapter> adapter);

		// ********************************************************************************
		/// <summary>
		/// Initializes available network interface list
		/// </summary>
		// ********************************************************************************
		void initialize_network_interfaces();

		// ********************************************************************************
		/// <summary>
		/// Allocates memory for packets storage
		/// </summary>
		// ********************************************************************************
		void allocate_storage();

		// ********************************************************************************
		/// <summary>
		/// Initialize interface and associated data structures required for packet filtering
		/// </summary>
		/// <param name="index">0 for primary adapter, 1 for secondary</param>
		/// <returns>true is success, false otherwise</returns>
		// ********************************************************************************
		bool init_filter(size_t index);

		// ********************************************************************************
		/// <summary>
		/// Release interface and associated data structures required for packet filtering
		/// </summary>
		/// <param name="index">0 for primary adapter, 1 for secondary</param>
		// ********************************************************************************
		void release_filter(size_t index);

		// ********************************************************************************
		/// <summary>
		/// Returns network_adapter object pointer by provided adapter handle
		/// </summary>
		/// <param name="adapter_handle"></param>
		/// <returns>network_adapter handle index in network_interfaces</returns>
		// ********************************************************************************
		std::optional<size_t> get_adapter_by_handle(HANDLE adapter_handle);

		/// <summary>adapter list monitoring event</summary>
		std::thread adapter_watch_thread_;
		/// <summary>adapter list exit flag</summary>
		std::atomic_bool adapter_watch_exit_{false};
		/// <summary>adapter list monitoring event</summary>
		winsys::safe_event adapter_event_;
		/// <summary>outgoing packet processing functor</summary>
		std::function<packet_action(HANDLE, INTERMEDIATE_BUFFER&)> filter_outgoing_packet_[2] = {nullptr, nullptr};
		/// <summary>incoming packet processing functor</summary>
		std::function<packet_action(HANDLE, INTERMEDIATE_BUFFER&)> filter_incoming_packet_[2] = {nullptr, nullptr};
		/// <summary>working thread running status</summary>
		std::atomic<filter_state> filter_state_[2] = {filter_state::stopped, filter_state::stopped};
		/// <summary>list of available network interfaces</summary>
		std::vector<std::shared_ptr<network_adapter>> network_interfaces_{};
		/// <summary>object state lock</summary>
		mutable std::shared_mutex lock_;
		/// <summary>working thread object</summary>
		std::thread working_thread_[2];
		/// <summary>filtered adapter handle</summary>
		std::atomic<HANDLE> adapter_[2]{nullptr, nullptr};
		/// <summary>array of INTERMEDIATE_BUFFER structures</summary>
		std::unique_ptr<INTERMEDIATE_BUFFER[]> packet_buffer_[2]{};
		/// <summary>driver request for reading packets</summary>
		std::unique_ptr<request_storage_type_t> read_request_ptr_[2]{};
		/// <summary>driver request for writing packets to adapter</summary>
		std::unique_ptr<request_storage_type_t> write_adapter_request_ptr_[2]{};
		/// <summary>driver request for writing packets up to protocol stack</summary>
		std::unique_ptr<request_storage_type_t> write_mstcp_request_ptr_[2]{};
		/// <summary>driver request for writing routed packets to adapter</summary>
		std::unique_ptr<request_storage_type_t> routed_write_adapter_request_ptr_[2]{};
		/// <summary>driver request for writing routed packets up to protocol stack</summary>
		std::unique_ptr<request_storage_type_t> routed_write_mstcp_request_ptr_[2]{};
		/// <summary>callback to notify for adapters changes</summary>
		std::vector<std::function<void()>> adapters_change_callback_{};
	};

	inline bool dual_packet_filter::init_filter(const size_t index)
	{
		auto* read_request = reinterpret_cast<PETH_M_REQUEST>(read_request_ptr_[index].get());
		auto* const write_adapter_request = reinterpret_cast<PETH_M_REQUEST>(write_adapter_request_ptr_[index].get());
		auto* const write_mstcp_request = reinterpret_cast<PETH_M_REQUEST>(write_mstcp_request_ptr_[index].get());
		auto* const routed_write_adapter_request = reinterpret_cast<PETH_M_REQUEST>(routed_write_adapter_request_ptr_[
			index].get());
		auto* const routed_write_mstcp_request = reinterpret_cast<PETH_M_REQUEST>(routed_write_mstcp_request_ptr_[index]
			.get());

		read_request->hAdapterHandle = adapter_[index];
		write_adapter_request->hAdapterHandle = adapter_[index];
		write_mstcp_request->hAdapterHandle = adapter_[index];

		read_request->dwPacketsNumber = maximum_packet_block;
		write_adapter_request->dwPacketsNumber = 0;
		write_mstcp_request->dwPacketsNumber = 0;
		routed_write_adapter_request->dwPacketsNumber = 0;
		routed_write_mstcp_request->dwPacketsNumber = 0;

		//
		// Initialize packet buffers
		//
		ZeroMemory(packet_buffer_[index].get(), sizeof(INTERMEDIATE_BUFFER) * maximum_packet_block);

		for (unsigned i = 0; i < maximum_packet_block; ++i)
		{
			read_request->EthPacket[i].Buffer = &packet_buffer_[index][i];
		}

		if (const auto adapter_idx = get_adapter_by_handle(adapter_[index]); adapter_idx.has_value())
		{
			//
			// Set events for helper driver
			//
			if (!network_interfaces_[adapter_idx.value()]->set_packet_event())
			{
				return false;
			}

			network_interfaces_[adapter_idx.value()]->set_mode(MSTCP_FLAG_SENT_TUNNEL | MSTCP_FLAG_RECV_TUNNEL);

			return true;
		}

		return false;
	}

	inline void dual_packet_filter::release_filter(const size_t index)
	{
		if (const auto adapter_idx = get_adapter_by_handle(adapter_[index]); adapter_idx.has_value())
		{
			network_interfaces_[adapter_idx.value()]->release();
		}

		// Wait for working thread to exit
		if (working_thread_[index].joinable())
			working_thread_[index].join();
	}

	inline std::optional<size_t> dual_packet_filter::get_adapter_by_handle(HANDLE adapter_handle)
	{
		const auto it = std::find_if(network_interfaces_.cbegin(), network_interfaces_.cend(),
		                             [adapter_handle](auto&& a)
		                             {
			                             if (a->get_adapter() == adapter_handle)
				                             return true;
			                             return false;
		                             });

		if (it == network_interfaces_.end())
			return {};

		return std::distance(network_interfaces_.cbegin(), it);
	}

	inline bool dual_packet_filter::reconfigure()
	{
		return update_network_interfaces();
	}

	inline bool dual_packet_filter::start_filter(HANDLE adapter_handle, const size_t index)
	{
		std::unique_lock lock(lock_);

		if (filter_state_[index] == filter_state::running)
			return true;

		adapter_[index] = adapter_handle;

		if (init_filter(index))
		{
			std::shared_ptr<network_adapter> adapter;
			if (const auto adapter_idx = get_adapter_by_handle(adapter_[index]); !adapter_idx.has_value())
				return false;
			else
				adapter = network_interfaces_[adapter_idx.value()];

			try
			{
				working_thread_[index] = std::thread(&dual_packet_filter::filter_working_thread, this, index,
				                                     std::move(adapter));
			}
			catch (...)
			{
				return false;
			}
		}
		else
		{
			return false;
		}
		filter_state_[index] = filter_state::running;
		return true;
	}

	inline bool dual_packet_filter::stop_filter(const size_t index)
	{
		std::unique_lock lock(lock_);

		if (filter_state_[index] == filter_state::stopped)
			return true;

		filter_state_[index] = filter_state::stopped;

		release_filter(index);

		adapter_[index].store(nullptr);

		return true;
	}

	inline std::vector<std::string> dual_packet_filter::get_interface_names_list() const
	{
		std::shared_lock lock(lock_);

		std::vector<std::string> result;
		result.reserve(network_interfaces_.size());

		for (auto&& e : network_interfaces_)
		{
			result.push_back(e->get_friendly_name());
		}

		return result;
	}

	inline const std::vector<std::shared_ptr<network_adapter>>& dual_packet_filter::get_interface_list() const
	{
		return network_interfaces_;
	}

	inline void dual_packet_filter::initialize_network_interfaces()
	{
		TCP_AdapterList ad_list;
		std::vector<char> friendly_name(MAX_PATH * 4);

		GetTcpipBoundAdaptersInfo(&ad_list);

		for (size_t i = 0; i < ad_list.m_nAdapterCount; ++i)
		{
			ConvertWindows2000AdapterName(reinterpret_cast<const char*>(ad_list.m_szAdapterNameList[i]),
			                              friendly_name.data(), static_cast<DWORD>(friendly_name.size()));

			network_interfaces_.push_back(
				std::make_shared<network_adapter>(
					this,
					ad_list.m_nAdapterHandle[i],
					ad_list.m_czCurrentAddress[i],
					std::string(reinterpret_cast<const char*>(ad_list.m_szAdapterNameList[i])),
					std::string(friendly_name.data()),
					ad_list.m_nAdapterMediumList[i],
					ad_list.m_usMTU[i]));
		}
	}

	inline bool dual_packet_filter::update_network_interfaces()
	{
		TCP_AdapterList ad_list;
		std::vector<char> friendly_name(MAX_PATH * 4);

		if (!GetTcpipBoundAdaptersInfo(&ad_list))
			return false;

		std::unique_lock lock(lock_);

		for (size_t i = 0; i < ad_list.m_nAdapterCount; ++i)
		{
			ConvertWindows2000AdapterName(reinterpret_cast<const char*>(ad_list.m_szAdapterNameList[i]),
			                              friendly_name.data(), static_cast<DWORD>(friendly_name.size()));

			if (const auto it = std::find_if(network_interfaces_.cbegin(), network_interfaces_.cend(),
			                                 [handle = ad_list.m_nAdapterHandle[i]](auto&& a)
			                                 {
				                                 return (a->get_adapter() == handle);
			                                 }); it == network_interfaces_.cend())
			{
				// we have not seen this adapter, add it
				network_interfaces_.push_back(
					std::make_shared<network_adapter>(
						this,
						ad_list.m_nAdapterHandle[i],
						ad_list.m_czCurrentAddress[i],
						std::string(reinterpret_cast<const char*>(ad_list.m_szAdapterNameList[i])),
						std::string(friendly_name.data()),
						ad_list.m_nAdapterMediumList[i],
						ad_list.m_usMTU[i]));
			}
			else if (it->operator->()->get_internal_name() != std::string(
					reinterpret_cast<const char*>(ad_list.m_szAdapterNameList[i])) ||
				it->operator->()->get_friendly_name() != std::string(friendly_name.data()))
			{
				// handle case when adapter with existing handle has different name (internal driver level substitution has happened)
				// or friendly name has changed (dynamic change)
				// erase old adapter entry and add a new one
				network_interfaces_.erase(it);

				network_interfaces_.push_back(
					std::make_shared<network_adapter>(
						this,
						ad_list.m_nAdapterHandle[i],
						ad_list.m_czCurrentAddress[i],
						std::string(reinterpret_cast<const char*>(ad_list.m_szAdapterNameList[i])),
						std::string(friendly_name.data()),
						ad_list.m_nAdapterMediumList[i],
						ad_list.m_usMTU[i]));
			}
		}

		// erase all adapters with unknown handles
		network_interfaces_.erase(std::remove_if(network_interfaces_.begin(), network_interfaces_.end(),
		                                         [&ad_list](auto&& a)
		                                         {
			                                         for (size_t i = 0; i < ad_list.m_nAdapterCount; ++i)
			                                         {
				                                         if (ad_list.m_nAdapterHandle[i] == a->get_adapter())
					                                         return false;
			                                         }

			                                         return true;
		                                         }), network_interfaces_.end());

		return true;
	}

	inline void dual_packet_filter::allocate_storage()
	{
		for (size_t index = 0; index < 2; ++index)
		{
			packet_buffer_[index] = std::make_unique<INTERMEDIATE_BUFFER[]>(maximum_packet_block);
			read_request_ptr_[index] = std::make_unique<request_storage_type_t>();
			write_adapter_request_ptr_[index] = std::make_unique<request_storage_type_t>();
			write_mstcp_request_ptr_[index] = std::make_unique<request_storage_type_t>();
			routed_write_adapter_request_ptr_[index] = std::make_unique<request_storage_type_t>();
			routed_write_mstcp_request_ptr_[index] = std::make_unique<request_storage_type_t>();
		}
	}

	inline void dual_packet_filter::filter_working_thread(const size_t index, std::shared_ptr<network_adapter> adapter)
	{
		auto* read_request = reinterpret_cast<PETH_M_REQUEST>(read_request_ptr_[index].get());
		auto* write_adapter_request = reinterpret_cast<PETH_M_REQUEST>(write_adapter_request_ptr_[index].get());
		auto* write_mstcp_request = reinterpret_cast<PETH_M_REQUEST>(write_mstcp_request_ptr_[index].get());
		auto* routed_write_adapter_request = reinterpret_cast<PETH_M_REQUEST>(routed_write_adapter_request_ptr_[index].
			get());
		auto* routed_write_mstcp_request = reinterpret_cast<PETH_M_REQUEST>(routed_write_mstcp_request_ptr_[index].
			get());

		while (filter_state_[index] == filter_state::running)
		{
			[[maybe_unused]] auto wait_result = adapter->wait_event(INFINITE);

			[[maybe_unused]] auto reset_result = adapter->reset_event();

			while (filter_state_[index] == filter_state::running && ReadPackets(read_request))
			{
				for (size_t i = 0; i < read_request->dwPacketsSuccess; ++i)
				{
					auto packet_action = packet_action::pass;

					if (packet_buffer_[index][i].m_dwDeviceFlags == PACKET_FLAG_ON_SEND)
					{
						if (filter_outgoing_packet_[index] != nullptr)
							packet_action = filter_outgoing_packet_[index](
								read_request->hAdapterHandle, packet_buffer_[index][i]);
					}
					else
					{
						if (filter_incoming_packet_[index] != nullptr)
							packet_action = filter_incoming_packet_[index](
								read_request->hAdapterHandle, packet_buffer_[index][i]);
					}

					// Place packet back into the flow if was allowed to
					switch (packet_action)
					{
					case packet_action::pass:
						if (packet_buffer_[index][i].m_dwDeviceFlags == PACKET_FLAG_ON_SEND)
						{
							write_adapter_request->EthPacket[write_adapter_request->dwPacketsNumber].Buffer = &
								packet_buffer_[index][i];
							++write_adapter_request->dwPacketsNumber;
						}
						else
						{
							write_mstcp_request->EthPacket[write_mstcp_request->dwPacketsNumber].Buffer = &
								packet_buffer_[index][i];
							++write_mstcp_request->dwPacketsNumber;
						}
						break;
					case packet_action::revert:
						if (packet_buffer_[index][i].m_dwDeviceFlags == PACKET_FLAG_ON_RECEIVE)
						{
							write_adapter_request->EthPacket[write_adapter_request->dwPacketsNumber].Buffer = &
								packet_buffer_[index][i];
							++write_adapter_request->dwPacketsNumber;
						}
						else
						{
							write_mstcp_request->EthPacket[write_mstcp_request->dwPacketsNumber].Buffer = &
								packet_buffer_[index][i];
							++write_mstcp_request->dwPacketsNumber;
						}
						break;
					case packet_action::route:
						if (packet_buffer_[index][i].m_dwDeviceFlags == PACKET_FLAG_ON_SEND)
						{
							routed_write_adapter_request->EthPacket[routed_write_adapter_request->dwPacketsNumber].
								Buffer = &packet_buffer_[index][i];
							++routed_write_adapter_request->dwPacketsNumber;
						}
						else
						{
							routed_write_mstcp_request->EthPacket[routed_write_mstcp_request->dwPacketsNumber].Buffer =
								&packet_buffer_[index][i];
							++routed_write_mstcp_request->dwPacketsNumber;
						}
						break;
					case packet_action::route_revert:
						if (packet_buffer_[index][i].m_dwDeviceFlags == PACKET_FLAG_ON_RECEIVE)
						{
							routed_write_adapter_request->EthPacket[routed_write_adapter_request->dwPacketsNumber].
								Buffer = &packet_buffer_[index][i];
							++routed_write_adapter_request->dwPacketsNumber;
						}
						else
						{
							routed_write_mstcp_request->EthPacket[routed_write_mstcp_request->dwPacketsNumber].Buffer =
								&packet_buffer_[index][i];
							++routed_write_mstcp_request->dwPacketsNumber;
						}
						break;
					case packet_action::drop:
						break;
					}
				}

				if (write_adapter_request->dwPacketsNumber)
				{
					SendPacketsToAdapter(write_adapter_request);
					write_adapter_request->dwPacketsNumber = 0;
				}

				if (write_mstcp_request->dwPacketsNumber)
				{
					SendPacketsToMstcp(write_mstcp_request);
					write_mstcp_request->dwPacketsNumber = 0;
				}

				if (routed_write_adapter_request->dwPacketsNumber && filter_state_[(index + 1) % 2] ==
					filter_state::running)
				{
					routed_write_adapter_request->hAdapterHandle = adapter_[(index + 1) % 2];
					SendPacketsToAdapter(routed_write_adapter_request);
					routed_write_adapter_request->dwPacketsNumber = 0;
				}

				if (routed_write_mstcp_request->dwPacketsNumber && filter_state_[(index + 1) % 2] ==
					filter_state::running)
				{
					routed_write_mstcp_request->hAdapterHandle = adapter_[(index + 1) % 2];
					SendPacketsToMstcp(routed_write_mstcp_request);
					routed_write_mstcp_request->dwPacketsNumber = 0;
				}

				read_request->dwPacketsSuccess = 0;
			}
		}
	}
}

```

`examples/cpp/common/ndisapi/fastio_packet_filter.h`:

```h
// --------------------------------------------------------------------------------
/// <summary>
/// Module Name:  fastio_packet_filter.h 
/// Abstract: Simple packet filter class declaration
/// </summary>
// --------------------------------------------------------------------------------

#pragma once

namespace ndisapi
{
	inline constexpr size_t fast_io_size = 0x300000;
	inline constexpr uint32_t fast_io_packets_num = (fast_io_size - sizeof(FAST_IO_SECTION_HEADER)) / sizeof(
		INTERMEDIATE_BUFFER);
	inline constexpr size_t maximum_packet_block = 2048 * 3;

	// --------------------------------------------------------------------------------
	/// <summary>
	/// simple winpkfilter based filter class for quick prototyping 
	/// </summary>
	// --------------------------------------------------------------------------------
	class fastio_packet_filter final : public CNdisApi
	{
	public:
		enum class packet_action
		{
			pass,
			drop,
			revert
		};

	private:
		using request_storage_type_t = std::aligned_storage_t<
			sizeof(PINTERMEDIATE_BUFFER) * maximum_packet_block, 0x1000>;
		using fast_io_storage_type_t = std::aligned_storage_t<fast_io_size, 0x1000>;

		enum class filter_state
		{
			stopped,
			starting,
			running,
			stopping
		};

		explicit fastio_packet_filter(const bool wait_on_poll = false) :
			wait_on_poll_(wait_on_poll)
		{
			initialize_network_interfaces();
		}

	public:
		~fastio_packet_filter() override { stop_filter(); }

		fastio_packet_filter(const fastio_packet_filter& other) = delete;
		fastio_packet_filter(fastio_packet_filter&& other) noexcept = delete;
		fastio_packet_filter& operator=(const fastio_packet_filter& other) = delete;
		fastio_packet_filter& operator=(fastio_packet_filter&& other) noexcept = delete;

		// ********************************************************************************
		/// <summary>
		/// Constructs fastio_packet_filter
		/// </summary>
		/// <param name="in">incoming packets handling routine</param>
		/// <param name="out">outgoing packet handling routine</param>
		/// <returns></returns>
		// ********************************************************************************
		template <typename F1, typename F2>
		fastio_packet_filter(F1 in, F2 out, const bool sleep_on_poll = false):
			fastio_packet_filter(sleep_on_poll)
		{
			filter_incoming_packet_ = in;
			filter_outgoing_packet_ = out;
		}

		// ********************************************************************************
		/// <summary>
		/// Updates available network interfaces. Should be called when the filter is inactive. 
		/// </summary>
		/// <returns>status of the operation</returns>
		// ********************************************************************************
		bool reconfigure();
		// ********************************************************************************
		/// <summary>
		/// Starts packet filtering
		/// </summary>
		/// <param name="adapter">network interface index to filter</param>
		/// <returns>status of the operation</returns>
		// ********************************************************************************
		bool start_filter(size_t adapter);
		// ********************************************************************************
		/// <summary>
		/// Stops packet filtering
		/// </summary>
		/// <returns>status of the operation</returns>
		// ********************************************************************************
		bool stop_filter();
		// ********************************************************************************
		/// <summary>
		/// Queries the list of the names for the available network interfaces
		/// </summary>
		/// <returns>list of network adapters friendly names</returns>
		// ********************************************************************************
		std::vector<std::string> get_interface_names_list() const;

		// ********************************************************************************
		/// <summary>
		/// Queries the list of the available network interfaces
		/// </summary>
		/// <returns>vector of available network adapters</returns>
		// ********************************************************************************
		const std::vector<std::unique_ptr<network_adapter>>& get_interface_list() const;

		// ********************************************************************************
		/// <summary>
		/// Returns current filter state
		/// </summary>
		/// <returns>current filter state</returns>
		// ********************************************************************************
		[[nodiscard]] filter_state get_filter_state() const
		{
			return filter_state_.load();
		}

	private:
		// ********************************************************************************
		/// <summary>
		/// Working thread routine
		/// </summary>
		// ********************************************************************************
		void filter_working_thread();
		// ********************************************************************************
		/// <summary>
		/// Initializes available network interface list
		/// </summary>
		// ********************************************************************************
		void initialize_network_interfaces();
		// ********************************************************************************
		/// <summary>
		/// Initialize interface and associated data structures required for packet filtering
		/// </summary>
		/// <returns>true is success, false otherwise</returns>
		// ********************************************************************************
		bool init_filter();
		// ********************************************************************************
		/// <summary>
		/// Release interface and associated data structures required for packet filtering
		/// </summary>
		// ********************************************************************************
		void release_filter();

		/// <summary>outgoing packet processing functor</summary>
		std::function<packet_action(HANDLE, INTERMEDIATE_BUFFER&)> filter_outgoing_packet_ = nullptr;
		/// <summary>incoming packet processing functor</summary>
		std::function<packet_action(HANDLE, INTERMEDIATE_BUFFER&)> filter_incoming_packet_ = nullptr;

		/// <summary>working thread running status</summary>
		std::atomic<filter_state> filter_state_ = filter_state::stopped;
		/// <summary>list of available network interfaces</summary>
		std::vector<std::unique_ptr<network_adapter>> network_interfaces_;
		/// <summary>working thread object</summary>
		std::thread working_thread_;
		/// <summary>filtered adapter index</summary>
		size_t adapter_{0};
		/// <summary>specifies if sleep should be used on polling fas I/O</summary>
		bool wait_on_poll_{false};
		/// <summary>array of INTERMEDIATE_BUFFER structures</summary>
		std::unique_ptr<INTERMEDIATE_BUFFER[]> packet_buffer_;
		/// <summary>driver request for writing packets to adapter</summary>
		std::unique_ptr<request_storage_type_t> write_adapter_request_ptr_;
		/// <summary>driver request for writing packets up to protocol stack</summary>
		std::unique_ptr<request_storage_type_t> write_mstcp_request_ptr_;
		/// <summary>shared fast i/o memory</summary>
		std::unique_ptr<fast_io_storage_type_t[]> fast_io_ptr_;
	};

	inline bool fastio_packet_filter::init_filter()
	{
		try
		{
			packet_buffer_ = std::make_unique<INTERMEDIATE_BUFFER[]>(maximum_packet_block);

			write_adapter_request_ptr_ = std::make_unique<request_storage_type_t>();
			write_mstcp_request_ptr_ = std::make_unique<request_storage_type_t>();
			fast_io_ptr_ = std::make_unique<fast_io_storage_type_t[]>(4);
		}
		catch (const std::bad_alloc&)
		{
			return false;
		}

		//
		// Set events for helper driver
		//
		if (wait_on_poll_)
		{
			if (!network_interfaces_[adapter_]->set_packet_event())
			{
				packet_buffer_.reset();
				write_adapter_request_ptr_.reset();
				write_mstcp_request_ptr_.reset();
				fast_io_ptr_.reset();

				return false;
			}
		}

		auto fast_io_section = reinterpret_cast<PFAST_IO_SECTION>(&fast_io_ptr_.get()[0]);

		if (!InitializeFastIo(fast_io_section, fast_io_size))
		{
			packet_buffer_.reset();
			write_adapter_request_ptr_.reset();
			write_mstcp_request_ptr_.reset();
			fast_io_ptr_.reset();

			return false;
		}

		for (auto i = 1; i < 4; ++i)
		{
			fast_io_section = reinterpret_cast<PFAST_IO_SECTION>(&fast_io_ptr_.get()[i]);

			if (!AddSecondaryFastIo(fast_io_section, fast_io_size))
			{
				packet_buffer_.reset();
				write_adapter_request_ptr_.reset();
				write_mstcp_request_ptr_.reset();
				fast_io_ptr_.reset();

				return false;
			}
		}

		network_interfaces_[adapter_]->set_mode(MSTCP_FLAG_SENT_TUNNEL | MSTCP_FLAG_RECV_TUNNEL);

		return true;
	}

	inline void fastio_packet_filter::release_filter()
	{
		network_interfaces_[adapter_]->release();

		// Wait for working thread to exit
		if (working_thread_.joinable())
			working_thread_.join();

		packet_buffer_.reset();
		write_adapter_request_ptr_.reset();
		write_mstcp_request_ptr_.reset();
		fast_io_ptr_.reset();
	}

	inline bool fastio_packet_filter::reconfigure()
	{
		if (filter_state_ != filter_state::stopped)
			return false;

		network_interfaces_.clear();

		initialize_network_interfaces();

		return true;
	}

	inline bool fastio_packet_filter::start_filter(const size_t adapter)
	{
		if (filter_state_ != filter_state::stopped)
			return false;

		filter_state_ = filter_state::starting;

		adapter_ = adapter;

		if (init_filter())
			working_thread_ = std::thread(&fastio_packet_filter::filter_working_thread, this);
		else
			return false;

		return true;
	}

	inline bool fastio_packet_filter::stop_filter()
	{
		if (filter_state_ != filter_state::running)
			return false;

		filter_state_ = filter_state::stopping;

		release_filter();

		filter_state_ = filter_state::stopped;

		return true;
	}

	inline std::vector<std::string> fastio_packet_filter::get_interface_names_list() const
	{
		std::vector<std::string> result;
		result.reserve(network_interfaces_.size());

		for (auto&& e : network_interfaces_)
		{
			result.push_back(e->get_friendly_name());
		}

		return result;
	}

	inline const std::vector<std::unique_ptr<network_adapter>>& fastio_packet_filter::get_interface_list() const
	{
		return network_interfaces_;
	}

	inline void fastio_packet_filter::initialize_network_interfaces()
	{
		TCP_AdapterList ad_list;
		std::vector<char> friendly_name(MAX_PATH * 4);

		if (!GetTcpipBoundAdaptersInfo(&ad_list))
			return;

		for (size_t i = 0; i < ad_list.m_nAdapterCount; ++i)
		{
			ConvertWindows2000AdapterName(reinterpret_cast<const char*>(ad_list.m_szAdapterNameList[i]),
			                              friendly_name.data(), static_cast<DWORD>(friendly_name.size()));

			network_interfaces_.push_back(
				std::make_unique<network_adapter>(
					this,
					ad_list.m_nAdapterHandle[i],
					ad_list.m_czCurrentAddress[i],
					std::string(reinterpret_cast<const char*>(ad_list.m_szAdapterNameList[i])),
					std::string(friendly_name.data()),
					ad_list.m_nAdapterMediumList[i],
					ad_list.m_usMTU[i]));
		}
	}

	inline void fastio_packet_filter::filter_working_thread()
	{
		using namespace std::chrono_literals;

		filter_state_ = filter_state::running;

		DWORD sent_success = 0;
		DWORD fast_io_packets_success = 0;

		auto* const write_adapter_request = reinterpret_cast<PINTERMEDIATE_BUFFER*>(write_adapter_request_ptr_.get());
		auto* const write_mstcp_request = reinterpret_cast<PINTERMEDIATE_BUFFER*>(write_mstcp_request_ptr_.get());

		const PFAST_IO_SECTION fast_io_section[] = {
			reinterpret_cast<PFAST_IO_SECTION>(&fast_io_ptr_.get()[0]),
			reinterpret_cast<PFAST_IO_SECTION>(&fast_io_ptr_.get()[1]),
			reinterpret_cast<PFAST_IO_SECTION>(&fast_io_ptr_.get()[2]),
			reinterpret_cast<PFAST_IO_SECTION>(&fast_io_ptr_.get()[3]),
		};

#ifdef FAST_IO_MEASURE_STATS
		uint64_t fast_io_packets_total = 0;
		uint64_t queued_io_packets_total = 0;
		uint64_t fast_io_reads_total = 0;
		uint64_t queued_io_reads_total = 0;
#endif //FAST_IO_MEASURE_STATS

		while (filter_state_ == filter_state::running)
		{
			//
			// Fast I/O processing section
			//

			for (auto i : fast_io_section)
			{
				if (InterlockedCompareExchange(&i->fast_io_header.fast_io_write_union.union_.join, 0, 0))
				{
					InterlockedExchange(&i->fast_io_header.read_in_progress_flag, 1);

					auto write_union = InterlockedCompareExchange(&i->fast_io_header.fast_io_write_union.union_.join, 0,
					                                              0);

					auto current_packets_success = reinterpret_cast<PFAST_IO_WRITE_UNION>(&write_union)->union_.split.
						number_of_packets;

					//
					// Copy packets and reset section
					//

					memmove(&packet_buffer_[fast_io_packets_success], &i->fast_io_packets[0],
					        sizeof(INTERMEDIATE_BUFFER) * (current_packets_success - 1));

					// For the last packet(s) wait the write completion if in progress
					write_union = InterlockedCompareExchange(&i->fast_io_header.fast_io_write_union.union_.join, 0, 0);

					while (reinterpret_cast<PFAST_IO_WRITE_UNION>(&write_union)->union_.split.write_in_progress_flag)
					{
						write_union = InterlockedCompareExchange(&i->fast_io_header.fast_io_write_union.union_.join, 0,
						                                         0);
					}

					// Copy the last packet(s)
					memmove(
						&packet_buffer_[static_cast<uint64_t>(fast_io_packets_success) + current_packets_success - 1], &
						i->fast_io_packets[current_packets_success - 1], sizeof(INTERMEDIATE_BUFFER));
					if (current_packets_success < reinterpret_cast<PFAST_IO_WRITE_UNION>(&write_union)->union_.split.
						number_of_packets)
					{
						current_packets_success = reinterpret_cast<PFAST_IO_WRITE_UNION>(&write_union)->union_.split.
							number_of_packets;
						memmove(
							&packet_buffer_[static_cast<uint64_t>(fast_io_packets_success) + current_packets_success -
								1], &
							i->fast_io_packets[current_packets_success - 1], sizeof(INTERMEDIATE_BUFFER));
					}

					InterlockedExchange(&i->fast_io_header.fast_io_write_union.union_.join, 0);
					InterlockedExchange(&i->fast_io_header.read_in_progress_flag, 0);

					fast_io_packets_success += current_packets_success;
				}
			}

			auto send_to_adapter_num = 0;
			auto send_to_mstcp_num = 0;

#ifdef FAST_IO_MEASURE_STATS
			fast_io_packets_total += static_cast<uint64_t>(fast_io_packets_success);
			++fast_io_reads_total;
#endif //FAST_IO_MEASURE_STATS

			for (uint32_t i = 0; i < fast_io_packets_success; ++i)
			{
				auto packet_action = packet_action::pass;

				if (packet_buffer_[i].m_dwDeviceFlags == PACKET_FLAG_ON_SEND)
				{
					if (filter_outgoing_packet_ != nullptr)
						packet_action = filter_outgoing_packet_(packet_buffer_[i].m_hAdapter, packet_buffer_[i]);
				}
				else
				{
					if (filter_incoming_packet_ != nullptr)
						packet_action = filter_incoming_packet_(packet_buffer_[i].m_hAdapter, packet_buffer_[i]);
				}

				// Place packet back into the flow if was allowed to
				if (packet_action == packet_action::pass)
				{
					if (packet_buffer_[i].m_dwDeviceFlags == PACKET_FLAG_ON_SEND)
					{
						write_adapter_request[send_to_adapter_num] = &packet_buffer_[i];
						++send_to_adapter_num;
					}
					else
					{
						write_mstcp_request[send_to_mstcp_num] = &packet_buffer_[i];
						++send_to_mstcp_num;
					}
				}
				else if (packet_action == packet_action::revert)
				{
					if (packet_buffer_[i].m_dwDeviceFlags == PACKET_FLAG_ON_RECEIVE)
					{
						write_adapter_request[send_to_adapter_num] = &packet_buffer_[i];
						++send_to_adapter_num;
					}
					else
					{
						write_mstcp_request[send_to_mstcp_num] = &packet_buffer_[i];
						++send_to_mstcp_num;
					}
				}
			}

			if (send_to_adapter_num > 0)
			{
				SendPacketsToAdaptersUnsorted(write_adapter_request, send_to_adapter_num, &sent_success);
			}

			if (send_to_mstcp_num > 0)
			{
				SendPacketsToMstcpUnsorted(write_mstcp_request, send_to_mstcp_num, &sent_success);
			}

			if (fast_io_packets_success == 0 && wait_on_poll_)
			{
				auto [[maybe_unused]] result = network_interfaces_[adapter_]->wait_event(INFINITE);
				result = network_interfaces_[adapter_]->reset_event();
			}

			fast_io_packets_success = 0;
		}

#ifdef FAST_IO_MEASURE_STATS
		std::cout << "fast_io_packets_total = " << fast_io_packets_total << std::endl;
		std::cout << "fast_io_reads_total = " << fast_io_reads_total << std::endl;
		std::cout << "queued_io_packets_total = " << queued_io_packets_total << std::endl;
		std::cout << "queued_io_reads_total = " << queued_io_reads_total << std::endl;
		std::cout << "queued_io_reads_total/reads_total = " << static_cast<double>(queued_io_reads_total) / (fast_io_reads_total + queued_io_reads_total) * 100 << "%" << std::endl;
		std::cout << "queued_io_packets_total/packets_total = " << static_cast<double>(queued_io_packets_total) / (fast_io_packets_total + queued_io_packets_total) * 100 << "%" << std::endl;
#endif //FAST_IO_MEASURE_STATS
	}
}

```

`examples/cpp/common/ndisapi/local_redirect.h`:

```h
#pragma once

namespace ndisapi
{
	struct local_redirect_key
	{
		local_redirect_key() = default;

		local_redirect_key(const net::ip_address_v4& original_dest_ip, const u_short original_src_port)
			: original_dest_ip(original_dest_ip),
			  original_src_port(original_src_port)
		{
		}

		friend bool operator==(const local_redirect_key& lhs, const local_redirect_key& rhs)
		{
			return lhs.original_dest_ip == rhs.original_dest_ip
				&& lhs.original_src_port == rhs.original_src_port;
		}

		friend bool operator!=(const local_redirect_key& lhs, const local_redirect_key& rhs)
		{
			return !(lhs == rhs);
		}

		net::ip_address_v4 original_dest_ip{};
		u_short original_src_port = 0;
	};
}

namespace std
{
	template <>
	struct hash<ndisapi::local_redirect_key>
	{
		using argument_type = ndisapi::local_redirect_key;
		using result_type = size_t;

		result_type operator()(const argument_type& key) const noexcept
		{
			const auto h1(std::hash<net::ip_address_v4>{}(key.original_dest_ip) ^ key.original_src_port);

			return h1;
		}
	};
}

namespace ndisapi
{
	class local_redirector
	{
	public:
		explicit local_redirector(const u_short proxy_port)
			: proxy_port_(htons(proxy_port))
		{
		}

		[[nodiscard]] u_short get_proxy_port() const
		{
			return ntohs(proxy_port_);
		}

		bool process_client_to_server_packet(INTERMEDIATE_BUFFER& packet)
		{
			iphdr_ptr ip_header;
			tcphdr_ptr tcp_header;

			auto eth_header = reinterpret_cast<ether_header_ptr>(packet.m_IBuffer);

			if (ntohs(eth_header->h_proto) == ETH_P_IP)
			{
				ip_header = reinterpret_cast<iphdr_ptr>(packet.m_IBuffer + ETHER_HEADER_LENGTH);

				if (ip_header->ip_p == IPPROTO_TCP)
				{
					// This is TCP packet, get TCP header pointer
					tcp_header = reinterpret_cast<tcphdr_ptr>(reinterpret_cast<PUCHAR>(ip_header) + sizeof(DWORD) *
						ip_header->ip_hl);
				}
				else
				{
					return false;
				}
			}
			else
			{
				return false;
			}

			if ((tcp_header->th_flags & (TH_SYN | TH_ACK)) == TH_SYN)
			{
				if (const auto [it, result] = redirected_connections_.emplace(
					local_redirect_key{net::ip_address_v4{ip_header->ip_dst}, tcp_header->th_sport},
					tcp_header->th_dport); !result)
					return false;
			}
			else
			{
				if (const auto it = redirected_connections_.find(local_redirect_key{
					net::ip_address_v4{ip_header->ip_dst}, tcp_header->th_sport
				}); it == redirected_connections_.cend())
					return false;
			}

			// 1. Swap Ethernet addresses
			std::swap(eth_header->h_dest, eth_header->h_source);

			// 2. Swap IP addresses
			std::swap(ip_header->ip_dst.S_un.S_addr, ip_header->ip_src.S_un.S_addr);

			tcp_header->th_dport = proxy_port_;

			return true;
		}

		bool process_server_to_client_packet(INTERMEDIATE_BUFFER& packet)
		{
			iphdr_ptr ip_header;
			tcphdr_ptr tcp_header;

			auto eth_header = reinterpret_cast<ether_header_ptr>(packet.m_IBuffer);

			if (ntohs(eth_header->h_proto) == ETH_P_IP)
			{
				ip_header = reinterpret_cast<iphdr_ptr>(packet.m_IBuffer + ETHER_HEADER_LENGTH);

				if (ip_header->ip_p == IPPROTO_TCP)
				{
					// This is TCP packet, get TCP header pointer
					tcp_header = reinterpret_cast<tcphdr_ptr>(reinterpret_cast<PUCHAR>(ip_header) + sizeof(DWORD) *
						ip_header->ip_hl);
				}
				else
				{
					return false;
				}
			}
			else
			{
				return false;
			}

			const auto it = redirected_connections_.find(local_redirect_key{
				net::ip_address_v4{ip_header->ip_dst}, tcp_header->th_dport
			});
			if (it == redirected_connections_.cend())
				return false;

			// Swap Ethernet addresses
			std::swap(eth_header->h_dest, eth_header->h_source);

			// Swap IP addresses
			std::swap(ip_header->ip_dst.S_un.S_addr, ip_header->ip_src.S_un.S_addr);

			tcp_header->th_sport = it->second;

			return true;
		}

	private:
		std::unordered_map<local_redirect_key, u_short> redirected_connections_;
		/// <summary>proxy port in network byte order</summary>
		u_short proxy_port_;
	};
}

```

`examples/cpp/common/ndisapi/network_adapter.h`:

```h
/// <summary>
/// Module Name:  network_adapter.h 
/// Abstract: Network interface wrapper class 
/// </summary>
// --------------------------------------------------------------------------------
// ReSharper disable CppClangTidyModernizeUseNodiscard
#pragma once

namespace ndisapi
{
	/// <summary>
	/// Offset to the IPv4 address in the protocol buffer block
	/// </summary>
	constexpr unsigned ipv4_address_offset = 584;

	/// <summary>
	/// Offset to the IPv6 address in the protocol buffer block
	/// </summary>
	constexpr unsigned ipv6_address_offset = 588;

	/// <summary>
	/// NDISWAN network interface common types
	/// </summary>
	enum class ndis_wan_type
	{
		/// <summary>
		/// Undefined
		/// </summary>
		ndis_wan_none,
		/// <summary>
		/// \Device\NDISWANIP
		/// </summary>
		ndis_wan_ip,
		/// <summary>
		/// \Device\NDISWANIPV6
		/// </summary>
		ndis_wan_ipv6,
		/// <summary>
		/// \Device\NDISWANBH
		/// </summary>
		ndis_wan_bh
	};

	/// <summary>
	/// NDISWAN connection wrapper struct
	/// </summary>
	struct ndis_wan_link_info
	{
		/// <summary>
		/// Constructs ndis_wan_link_info from the RAS_LINK_INFO provided information
		/// </summary>
		/// <param name="family">Address family</param>
		/// <param name="link_info_ptr">RAS_LINK_INFO pointer</param>
		ndis_wan_link_info(const ADDRESS_FAMILY family, PRAS_LINK_INFO link_info_ptr) :
			link_speed(link_info_ptr->LinkSpeed),
			mtu(static_cast<uint16_t>(link_info_ptr->MaximumTotalSize)),
			remote_hw_address(link_info_ptr->RemoteAddress),
			local_hw_address(link_info_ptr->LocalAddress)
		{
			sockaddr_in address_v4{};
			sockaddr_in6 address_v6{};

			address_v4.sin_family = AF_INET;
			address_v6.sin6_family = AF_INET6;

			switch (family)
			{
			case AF_INET:
				address_v4.sin_addr.S_un.S_un_b.s_b1 = link_info_ptr->ProtocolBuffer[ipv4_address_offset];
				address_v4.sin_addr.S_un.S_un_b.s_b2 = link_info_ptr->ProtocolBuffer[ipv4_address_offset + 1];
				address_v4.sin_addr.S_un.S_un_b.s_b3 = link_info_ptr->ProtocolBuffer[ipv4_address_offset + 2];
				address_v4.sin_addr.S_un.S_un_b.s_b4 = link_info_ptr->ProtocolBuffer[ipv4_address_offset + 3];
				ip_address = iphelper::ip_address_info(address_v4);
				break;
			case AF_INET6:
				address_v6.sin6_addr.u.Byte[8] = link_info_ptr->ProtocolBuffer[ipv6_address_offset];
				address_v6.sin6_addr.u.Byte[9] = link_info_ptr->ProtocolBuffer[ipv6_address_offset + 1];
				address_v6.sin6_addr.u.Byte[10] = link_info_ptr->ProtocolBuffer[ipv6_address_offset + 2];
				address_v6.sin6_addr.u.Byte[11] = link_info_ptr->ProtocolBuffer[ipv6_address_offset + 3];
				address_v6.sin6_addr.u.Byte[12] = link_info_ptr->ProtocolBuffer[ipv6_address_offset + 4];
				address_v6.sin6_addr.u.Byte[13] = link_info_ptr->ProtocolBuffer[ipv6_address_offset + 5];
				address_v6.sin6_addr.u.Byte[14] = link_info_ptr->ProtocolBuffer[ipv6_address_offset + 6];
				address_v6.sin6_addr.u.Byte[15] = link_info_ptr->ProtocolBuffer[ipv6_address_offset + 7];
				ip_address = iphelper::ip_address_info(address_v6);
				break;
			default:
				break;
			}
		}

		/// <summary>
		/// Specifies the speed of the link, in units of 100 bps.
		/// </summary>
		uint32_t link_speed;
		/// <summary
		/// >Specifies the maximum number of bytes per packet that the protocol can send over the network.
		/// </summary>
		uint16_t mtu;
		/// <summary>
		/// Represents the address of the remote node on the link in Ethernet-style format. NDISWAN supplies this value.
		/// </summary>
		net::mac_address remote_hw_address;
		/// <summary>
		/// Represents the protocol-determined context for indications on this link in Ethernet-style format.
		/// </summary>
		net::mac_address local_hw_address;
		/// <summary>
		/// Assigned IP address
		/// </summary>
		iphelper::ip_address_info ip_address{};
	};

	// --------------------------------------------------------------------------------
	/// <summary>
	/// Class representing network NDIS level interface
	/// </summary>
	// --------------------------------------------------------------------------------
	class network_adapter
	{
	public:
		/// <summary>
		/// Default constructor
		/// </summary>
		network_adapter() = default;

		/// <summary>
		/// Constructs network_adapter instance using the provided parameters
		/// </summary>
		/// <param name="api">NDISAPI instance to associate with</param>
		/// <param name="adapter_handle">NDISAPI adapter handle</param>
		/// <param name="mac_addr">network adapter hardware address</param>
		/// <param name="internal_name">Network adapter internal name, typically GUID</param>
		/// <param name="friendly_name">Network adapter user friendly name</param>
		/// <param name="medium">Network adapter NDIS medium</param>
		/// <param name="mtu">Network adapter MTU</param>
		network_adapter(
			CNdisApi* api,
			HANDLE adapter_handle,
			unsigned char* mac_addr,
			std::string internal_name,
			std::string friendly_name,
			const uint32_t medium,
			const uint16_t mtu
		) : api_(api),
		    hardware_address_{mac_addr},
		    packet_event_(::CreateEvent(nullptr, TRUE, FALSE, nullptr)),
		    internal_name_(std::move(internal_name)),
		    friendly_name_(std::move(friendly_name)),
		    medium_{medium},
		    mtu_{mtu},
		    current_mode_({adapter_handle, 0})
		{
			//
			// Initialize NDISWAN type
			//
			if (CNdisApi::IsNdiswanIp(internal_name_.c_str()))
			{
				ndis_wan_type_ = ndis_wan_type::ndis_wan_ip;
			}
			else if (CNdisApi::IsNdiswanIpv6(internal_name_.c_str()))
			{
				ndis_wan_type_ = ndis_wan_type::ndis_wan_ipv6;
			}
			else if (CNdisApi::IsNdiswanBh(internal_name_.c_str()))
			{
				ndis_wan_type_ = ndis_wan_type::ndis_wan_bh;
			}
		}

		/// <summary>
		/// Default destructor
		/// </summary>
		~network_adapter() = default;

		/// <summary>
		/// Deleted copy constructor
		/// </summary>
		/// <param name="other"></param>
		network_adapter(const network_adapter& other) = delete;

		/// <summary>
		/// Move constructor
		/// </summary>
		/// <param name="other"></param>
		/// <returns></returns>
		network_adapter(network_adapter&& other) noexcept
			: api_{other.api_},
			  hardware_address_{other.hardware_address_},
			  packet_event_{std::move(other.packet_event_)},
			  internal_name_{std::move(other.internal_name_)},
			  friendly_name_{std::move(other.friendly_name_)},
			  medium_{other.medium_},
			  mtu_{other.mtu_},
			  current_mode_{other.current_mode_}
		{
		}

		/// <summary>
		/// Deleted copy assignment
		/// </summary>
		network_adapter& operator=(const network_adapter& other) = delete;

		/// <summary>
		/// Move assignment operator
		/// </summary>
		/// <param name="other">network_adapter instance to move from</param>
		/// <returns>this object reference</returns>
		network_adapter& operator=(network_adapter&& other) noexcept
		{
			if (this == &other)
				return *this;
			api_ = other.api_;
			hardware_address_ = other.hardware_address_;
			packet_event_ = std::move(other.packet_event_);
			internal_name_ = std::move(other.internal_name_);
			friendly_name_ = std::move(other.friendly_name_);
			medium_ = other.medium_;
			mtu_ = other.mtu_;
			current_mode_ = other.current_mode_;
			return *this;
		}

		// ********************************************************************************
		/// <summary>
		/// Returns network interface handle value
		/// </summary>
		/// <returns>network adapter handle</returns>
		// ********************************************************************************
		[[nodiscard]] HANDLE get_adapter() const { return current_mode_.hAdapterHandle; }
		// ********************************************************************************
		/// <summary>
		/// Stops filtering the network interface and tries tor restore its original state
		/// </summary>
		// ********************************************************************************
		void release();
		// ********************************************************************************
		/// <summary>
		/// Set filtering mode for the network interface
		/// </summary>
		/// <param name="flags">filter mode flags value</param>
		// ********************************************************************************
		void set_mode(unsigned flags);
		// ********************************************************************************
		/// <summary>
		/// Queries the list of RAS connections for NDISWAN interface
		/// </summary>
		/// <returns>list of RAS connections</returns>
		// ********************************************************************************
		[[nodiscard]] std::optional<std::vector<ndis_wan_link_info>> get_ras_links() const;
		// ********************************************************************************
		/// <summary>
		/// Waits for network interface event to be signaled
		/// </summary>
		/// <param name="milliseconds"></param>
		/// <returns>wait status</returns>
		// ********************************************************************************
		[[maybe_unused]] unsigned wait_event(const unsigned milliseconds) const
		{
			return packet_event_.wait(milliseconds);
		}

		// ********************************************************************************
		/// <summary>
		/// Signals packet event
		/// </summary>
		/// <returns>status of the operation</returns>
		// ********************************************************************************
		[[maybe_unused]] bool signal_event() const { return packet_event_.signal(); }
		// ********************************************************************************
		/// <summary>
		/// resets packet event
		/// </summary>
		/// <returns>status of the operation</returns>
		// ********************************************************************************
		[[maybe_unused]] bool reset_event() const { return packet_event_.reset_event(); }
		// ********************************************************************************
		/// <summary>
		/// submits packet event into the driver
		/// </summary>
		/// <returns>status of the operation</returns>
		// ********************************************************************************
		[[maybe_unused]] bool set_packet_event() const
		{
			return api_->SetPacketEvent(current_mode_.hAdapterHandle, static_cast<HANDLE>(packet_event_))
				       ? true
				       : false;
		}

		// ********************************************************************************
		/// <summary>
		/// Network adapter internal name getter
		/// </summary>
		/// <returns>internal name string reference</returns>
		// ********************************************************************************
		[[nodiscard]] const std::string& get_internal_name() const { return internal_name_; }
		// ********************************************************************************
		/// <summary>
		/// Network adapter user friendly name getter
		/// </summary>
		/// <returns>user friendly name string reference</returns>
		// ********************************************************************************
		[[nodiscard]] const std::string& get_friendly_name() const { return friendly_name_; }
		// ********************************************************************************
		/// <summary>
		/// Queries network adapter hardware address
		/// </summary>
		/// <returns>network adapter MAC address</returns>
		// ********************************************************************************
		[[nodiscard]] net::mac_address get_hw_address() const { return hardware_address_; }
		// --------------------------------------------------------------------------------
		/// <summary>
		/// Returns network adapter NDIS medium
		/// </summary>
		// --------------------------------------------------------------------------------
		[[nodiscard]] uint32_t get_medium() const { return medium_; }
		// --------------------------------------------------------------------------------
		/// <summary>
		/// Returns network adapter maximum transmission unit
		/// </summary>
		// --------------------------------------------------------------------------------
		[[nodiscard]] uint16_t get_mtu() const { return mtu_; }
		// ********************************************************************************
		/// <summary>
		/// Returns network adapter NDISWAN type
		/// </summary>
		/// <returns></returns>
		// ********************************************************************************
		[[nodiscard]] ndis_wan_type get_ndis_wan_type() const { return ndis_wan_type_; }

	protected:
		/// <summary>
		/// Driver interface pointer
		/// </summary>
		CNdisApi* api_{nullptr};
		/// <summary>
		/// Network interface current MAC address
		/// </summary>
		net::mac_address hardware_address_;
		/// <summary>
		/// Packet in the adapter queue event
		/// </summary>
		winsys::safe_event packet_event_;
		/// <summary>
		/// Internal network interface name
		/// </summary>
		std::string internal_name_;
		/// <summary>
		/// User-friendly name
		/// </summary>
		std::string friendly_name_;
		/// <summary>
		/// Network medium
		/// </summary>
		uint32_t medium_{};
		/// <summary>
		/// Maximum Transmission Unit
		/// </summary>
		uint16_t mtu_{};
		/// <summary>
		/// Used to manipulate network interface mode
		/// </summary>
		ADAPTER_MODE current_mode_{};
		/// <summary>
		/// NDISWAN adapter type
		/// </summary>
		ndis_wan_type ndis_wan_type_{ndis_wan_type::ndis_wan_none};
	};

	inline void network_adapter::release()
	{
		[[maybe_unused]] auto result = packet_event_.signal();

		// Reset adapter mode and flush the packet queue
		current_mode_.dwFlags = 0;

		api_->SetAdapterMode(&current_mode_);
		api_->FlushAdapterPacketQueue(current_mode_.hAdapterHandle);
	}

	inline void network_adapter::set_mode(const unsigned flags)
	{
		current_mode_.dwFlags = flags;

		api_->SetAdapterMode(&current_mode_);
	}

	inline std::optional<std::vector<ndis_wan_link_info>> network_adapter::get_ras_links() const
	{
		if (get_ndis_wan_type() == ndis_wan_type::ndis_wan_none)
			return {};

		const auto ras_links_storage = std::make_unique<std::aligned_storage_t<sizeof(RAS_LINKS)>>();
		const auto ras_links = reinterpret_cast<PRAS_LINKS>(ras_links_storage.get());

		std::vector<ndis_wan_link_info> result;

		if (api_->GetRasLinks(get_adapter(), ras_links))
		{
			for (size_t i = 0; i < ras_links->nNumberOfLinks; ++i)
			{
				switch (get_ndis_wan_type())
				{
				case ndis_wan_type::ndis_wan_ip:
					{
						result.emplace_back(AF_INET, &ras_links->RasLinks[i]);
						break;
					}
				case ndis_wan_type::ndis_wan_ipv6:
					{
						result.emplace_back(AF_INET6, &ras_links->RasLinks[i]);
						break;
					}
				case ndis_wan_type::ndis_wan_none:
				case ndis_wan_type::ndis_wan_bh:
					break;
				}
			}
		}

		if (!result.empty())
			return {result};

		return {};
	}
}

```

`examples/cpp/common/ndisapi/queued_packet_filter.h`:

```h
// --------------------------------------------------------------------------------
/// <summary>
/// Module Name:  queued_packet_filter.h 
/// Abstract: Simple packet filter class declaration
/// </summary>
// --------------------------------------------------------------------------------

#pragma once

namespace ndisapi
{
	template <uint32_t Size>
	class packet_block
	{
		using request_storage_type_t = std::aligned_storage_t<sizeof(ETH_M_REQUEST) +
		                                                      sizeof(NDISRD_ETH_Packet) * (Size - 1),
		                                                      0x1000>;

		/// <summary>array of INTERMEDIATE_BUFFER structures</summary>
		std::unique_ptr<INTERMEDIATE_BUFFER[]> packet_buffer_;
		/// <summary>driver request for reading packets</summary>
		std::unique_ptr<request_storage_type_t> read_request_ptr_;
		/// <summary>driver request for writing packets to adapter</summary>
		std::unique_ptr<request_storage_type_t> write_adapter_request_ptr_;
		/// <summary>driver request for writing packets up to protocol stack</summary>
		std::unique_ptr<request_storage_type_t> write_mstcp_request_ptr_;

	public:
		explicit packet_block(HANDLE adapter)
		{
			packet_buffer_ = std::make_unique<INTERMEDIATE_BUFFER[]>(Size);

			read_request_ptr_ = std::make_unique<request_storage_type_t>();
			write_adapter_request_ptr_ = std::make_unique<request_storage_type_t>();
			write_mstcp_request_ptr_ = std::make_unique<request_storage_type_t>();

			auto* read_request = reinterpret_cast<PETH_M_REQUEST>(read_request_ptr_.get());
			auto* write_adapter_request = reinterpret_cast<PETH_M_REQUEST>(write_adapter_request_ptr_.get());
			auto* write_mstcp_request = reinterpret_cast<PETH_M_REQUEST>(write_mstcp_request_ptr_.get());

			read_request->hAdapterHandle = adapter;
			write_adapter_request->hAdapterHandle = adapter;
			write_mstcp_request->hAdapterHandle = adapter;

			read_request->dwPacketsNumber = Size;

			//
			// Initialize packet buffers
			//
			ZeroMemory(packet_buffer_.get(), sizeof(INTERMEDIATE_BUFFER) * Size);

			for (unsigned i = 0; i < Size; ++i)
			{
				read_request->EthPacket[i].Buffer = &packet_buffer_[i];
			}
		}

		[[nodiscard]] PETH_M_REQUEST get_read_request() const
		{
			return reinterpret_cast<PETH_M_REQUEST>(read_request_ptr_.get());
		}

		[[nodiscard]] PETH_M_REQUEST get_write_adapter_request() const
		{
			return reinterpret_cast<PETH_M_REQUEST>(write_adapter_request_ptr_.get());
		}

		[[nodiscard]] PETH_M_REQUEST get_write_mstcp_request() const
		{
			return reinterpret_cast<PETH_M_REQUEST>(write_mstcp_request_ptr_.get());
		}

		INTERMEDIATE_BUFFER& operator[](const std::size_t idx)
		{
			return packet_buffer_[idx];
		}

		const INTERMEDIATE_BUFFER& operator[](const std::size_t idx) const
		{
			return packet_buffer_[idx];
		}
	};

	// --------------------------------------------------------------------------------
	/// <summary>
	/// simple winpkfilter based filter class for quick prototyping 
	/// </summary>
	// --------------------------------------------------------------------------------
	class queued_packet_filter final : public CNdisApi
	{
	public:
		enum class packet_action
		{
			pass,
			drop,
			revert
		};

	private:
		static constexpr uint32_t maximum_packet_block = 510;
		static constexpr uint32_t maximum_block_num = 10;

		queued_packet_filter()
		{
			if (!IsDriverLoaded())
				throw std::runtime_error("Windows Packet Filter driver is not available!");

			initialize_network_interfaces();
		}

	public:
		enum class filter_state
		{
			stopped,
			starting,
			running,
			stopping
		};

		~queued_packet_filter() override { stop_filter(); }

		queued_packet_filter(const queued_packet_filter& other) = delete;
		queued_packet_filter(queued_packet_filter&& other) noexcept = delete;
		queued_packet_filter& operator=(const queued_packet_filter& other) = delete;
		queued_packet_filter& operator=(queued_packet_filter&& other) noexcept = delete;

		// ********************************************************************************
		/// <summary>
		/// Constructs queued_packet_filter
		/// </summary>
		/// <param name="in">incoming packets handling routine</param>
		/// <param name="out">outgoing packet handling routine</param>
		/// <returns></returns>
		// ********************************************************************************
		template <typename F1, typename F2>
		queued_packet_filter(F1 in, F2 out) : queued_packet_filter()
		{
			filter_incoming_packet_ = in;
			filter_outgoing_packet_ = out;
		}

		// ********************************************************************************
		/// <summary>
		/// Updates available network interfaces. Should be called when the filter is inactive. 
		/// </summary>
		/// <returns>status of the operation</returns>
		// ********************************************************************************
		bool reconfigure();

		// ********************************************************************************
		/// <summary>
		/// Starts packet filtering
		/// </summary>
		/// <param name="adapter">network interface index to filter</param>
		/// <returns>status of the operation</returns>
		// ********************************************************************************
		bool start_filter(size_t adapter);

		// ********************************************************************************
		/// <summary>
		/// Stops packet filtering
		/// </summary>
		/// <returns>status of the operation</returns>
		// ********************************************************************************
		bool stop_filter();

		// ********************************************************************************
		/// <summary>
		/// Queries the list of the names for the available network interfaces
		/// </summary>
		/// <returns>list of network adapters friendly names</returns>
		// ********************************************************************************
		std::vector<std::string> get_interface_names_list() const;

		// ********************************************************************************
		/// <summary>
		/// Queries the list of the available network interfaces
		/// </summary>
		/// <returns>vector of available network adapters</returns>
		// ********************************************************************************
		const std::vector<std::unique_ptr<network_adapter>>& get_interface_list() const;

		// ********************************************************************************
		/// <summary>
		/// Returns current filter state
		/// </summary>
		/// <returns>current filter state</returns>
		// ********************************************************************************
		[[nodiscard]] filter_state get_filter_state() const
		{
			return filter_state_.load();
		}

	private:
		// ********************************************************************************
		/// <summary>
		/// Reading thread routine
		/// </summary>
		// ********************************************************************************
		void packet_read_thread();

		// ********************************************************************************
		/// <summary>
		/// Processing thread routine
		/// </summary>
		// ********************************************************************************
		void packet_process_thread();

		// ********************************************************************************
		/// <summary>
		/// Writing to mstcp thread routine
		/// </summary>
		// ********************************************************************************
		void packet_write_mstcp_thread();

		// ********************************************************************************
		/// <summary>
		/// Writing to adapter thread routine
		/// </summary>
		// ********************************************************************************
		void packet_write_adapter_thread();

		// ********************************************************************************
		/// <summary>
		/// Initializes available network interface list
		/// </summary>
		// ********************************************************************************
		void initialize_network_interfaces();

		// ********************************************************************************
		/// <summary>
		/// Initialize interface and associated data structures required for packet filtering
		/// </summary>
		/// <returns>true is success, false otherwise</returns>
		// ********************************************************************************
		bool init_filter();

		// ********************************************************************************
		/// <summary>
		/// Release interface and associated data structures required for packet filtering
		/// </summary>
		// ********************************************************************************
		void release_filter();

		/// <summary>outgoing packet processing functor</summary>
		std::function<packet_action(HANDLE, INTERMEDIATE_BUFFER&)> filter_outgoing_packet_ = nullptr;
		/// <summary>incoming packet processing functor</summary>
		std::function<packet_action(HANDLE, INTERMEDIATE_BUFFER&)> filter_incoming_packet_ = nullptr;
		/// <summary>working thread running status</summary>
		std::atomic<filter_state> filter_state_ = filter_state::stopped;
		/// <summary>list of available network interfaces</summary>
		std::vector<std::unique_ptr<network_adapter>> network_interfaces_;

		/// <summary>reading thread object</summary>
		std::thread packet_read_thread_;
		/// <summary>processing thread object</summary>
		std::thread packet_process_thread_;
		/// <summary>writing to mstcp thread object</summary>
		std::thread packet_write_mstcp_thread_;
		/// <summary>writing to adapter thread object</summary>
		std::thread packet_write_adapter_thread_;

		/// <summary>filtered adapter index</summary>
		size_t adapter_{0};

		std::queue<std::unique_ptr<packet_block<maximum_packet_block>>> packet_read_queue_;
		std::queue<std::unique_ptr<packet_block<maximum_packet_block>>> packet_process_queue_;
		std::queue<std::unique_ptr<packet_block<maximum_packet_block>>> packet_write_mstcp_queue_;
		std::queue<std::unique_ptr<packet_block<maximum_packet_block>>> packet_write_adapter_queue_;

		std::condition_variable packet_read_queue_cv_;
		std::condition_variable packet_process_queue_cv_;
		std::condition_variable packet_write_mstcp_queue_cv_;
		std::condition_variable packet_write_adapter_queue_cv_;

		std::mutex packet_read_queue_lock_;
		std::mutex packet_process_queue_lock_;
		std::mutex packet_write_mstcp_queue_lock_;
		std::mutex packet_write_adapter_queue_lock_;
	};

	inline bool queued_packet_filter::init_filter()
	{
		try
		{
			for (uint32_t i = 0; i < maximum_block_num; ++i)
			{
				auto packet_block_ptr = std::make_unique<packet_block<maximum_packet_block>>(
					network_interfaces_[adapter_]->get_adapter());
				packet_read_queue_.push(std::move(packet_block_ptr));
			}
		}
		catch (const std::bad_alloc&)
		{
			return false;
		}

		//
		// Set events for helper driver
		//
		if (!network_interfaces_[adapter_]->set_packet_event())
		{
			while (!packet_read_queue_.empty())
			{
				packet_read_queue_.pop();
			}

			return false;
		}

		network_interfaces_[adapter_]->set_mode(
			(filter_outgoing_packet_ != nullptr ? MSTCP_FLAG_SENT_TUNNEL : 0) |
			(filter_incoming_packet_ != nullptr ? MSTCP_FLAG_RECV_TUNNEL : 0));

		return true;
	}

	inline void queued_packet_filter::release_filter()
	{
		network_interfaces_[adapter_]->release();

		packet_read_queue_cv_.notify_all();
		packet_process_queue_cv_.notify_all();
		packet_write_mstcp_queue_cv_.notify_all();
		packet_write_adapter_queue_cv_.notify_all();

		// Wait for working threads to exit
		if (packet_read_thread_.joinable())
			packet_read_thread_.join();
		if (packet_process_thread_.joinable())
			packet_process_thread_.join();
		if (packet_write_mstcp_thread_.joinable())
			packet_write_mstcp_thread_.join();
		if (packet_write_adapter_thread_.joinable())
			packet_write_adapter_thread_.join();

		while (!packet_read_queue_.empty())
		{
			packet_read_queue_.pop();
		}

		while (!packet_process_queue_.empty())
		{
			packet_process_queue_.pop();
		}

		while (!packet_write_mstcp_queue_.empty())
		{
			packet_write_mstcp_queue_.pop();
		}

		while (!packet_write_adapter_queue_.empty())
		{
			packet_write_adapter_queue_.pop();
		}
	}

	inline bool queued_packet_filter::reconfigure()
	{
		if (filter_state_ != filter_state::stopped)
			return false;

		network_interfaces_.clear();

		initialize_network_interfaces();

		return true;
	}

	inline bool queued_packet_filter::start_filter(const size_t adapter)
	{
		if (filter_state_ != filter_state::stopped)
			return false;

		filter_state_ = filter_state::starting;

		adapter_ = adapter;

		if (init_filter())
		{
			filter_state_ = filter_state::running;
			packet_read_thread_ = std::thread(&queued_packet_filter::packet_read_thread, this);
			packet_process_thread_ = std::thread(&queued_packet_filter::packet_process_thread, this);
			packet_write_mstcp_thread_ = std::thread(&queued_packet_filter::packet_write_mstcp_thread, this);
			packet_write_adapter_thread_ = std::thread(&queued_packet_filter::packet_write_adapter_thread, this);
		}
		else
			return false;

		return true;
	}

	inline bool queued_packet_filter::stop_filter()
	{
		if (filter_state_ != filter_state::running)
			return false;

		filter_state_ = filter_state::stopping;

		release_filter();

		filter_state_ = filter_state::stopped;

		return true;
	}

	inline std::vector<std::string> queued_packet_filter::get_interface_names_list() const
	{
		std::vector<std::string> result;
		result.reserve(network_interfaces_.size());

		for (auto&& e : network_interfaces_)
		{
			result.push_back(e->get_friendly_name());
		}

		return result;
	}

	inline const std::vector<std::unique_ptr<network_adapter>>& queued_packet_filter::get_interface_list() const
	{
		return network_interfaces_;
	}

	inline void queued_packet_filter::initialize_network_interfaces()
	{
		TCP_AdapterList ad_list;
		std::vector<char> friendly_name(MAX_PATH * 4);

		GetTcpipBoundAdaptersInfo(&ad_list);

		for (size_t i = 0; i < ad_list.m_nAdapterCount; ++i)
		{
			ConvertWindows2000AdapterName(reinterpret_cast<const char*>(ad_list.m_szAdapterNameList[i]),
			                              friendly_name.data(), static_cast<DWORD>(friendly_name.size()));

			network_interfaces_.push_back(
				std::make_unique<network_adapter>(
					this,
					ad_list.m_nAdapterHandle[i],
					ad_list.m_czCurrentAddress[i],
					std::string(reinterpret_cast<const char*>(ad_list.m_szAdapterNameList[i])),
					std::string(friendly_name.data()),
					ad_list.m_nAdapterMediumList[i],
					ad_list.m_usMTU[i]));
		}
	}

	inline void queued_packet_filter::packet_read_thread()
	{
		while (filter_state_ == filter_state::running)
		{
			std::unique_ptr<packet_block<maximum_packet_block>> packet_block_ptr;

			std::unique_lock lock(packet_read_queue_lock_);

			if (!packet_read_queue_.empty())
			{
				packet_block_ptr = std::move(packet_read_queue_.front());
				packet_read_queue_.pop();
			}
			else
			{
				packet_read_queue_cv_.wait(lock, [this]
				{
					return filter_state_ != filter_state::running || !packet_read_queue_.
						empty();
				});

				if (filter_state_ != filter_state::running)
					return;

				packet_block_ptr = std::move(packet_read_queue_.front());
				packet_read_queue_.pop();
			}

			lock.unlock();

			auto* read_request = packet_block_ptr->get_read_request();

			do
			{
				[[maybe_unused]] auto wait_result = network_interfaces_[adapter_]->wait_event(INFINITE);

				[[maybe_unused]] auto reset_result = network_interfaces_[adapter_]->reset_event();
			}
			while (!ReadPackets(read_request) && filter_state_ == filter_state::running);

			std::lock_guard lk(packet_process_queue_lock_);
			packet_process_queue_.push(std::move(packet_block_ptr));
			packet_process_queue_cv_.notify_one();
		}
	}

	inline void queued_packet_filter::packet_process_thread()
	{
		while (filter_state_ == filter_state::running)
		{
			std::unique_lock lock(packet_process_queue_lock_);

			packet_process_queue_cv_.wait(lock, [this]
			{
				return filter_state_ != filter_state::running || !packet_process_queue_.
					empty();
			});

			if (filter_state_ != filter_state::running)
				return;

			auto packet_block_ptr = std::move(packet_process_queue_.front());
			packet_process_queue_.pop();

			lock.unlock();

			auto* read_request = packet_block_ptr->get_read_request();
			auto* write_adapter_request = packet_block_ptr->get_write_adapter_request();
			auto* write_mstcp_request = packet_block_ptr->get_write_mstcp_request();

			for (size_t i = 0; i < read_request->dwPacketsSuccess; ++i)
			{
				auto packet_action = packet_action::pass;

				if ((*packet_block_ptr)[i].m_dwDeviceFlags == PACKET_FLAG_ON_SEND)
				{
					if (filter_outgoing_packet_ != nullptr)
						packet_action = filter_outgoing_packet_(read_request->hAdapterHandle, (*packet_block_ptr)[i]);
				}
				else
				{
					if (filter_incoming_packet_ != nullptr)
						packet_action = filter_incoming_packet_(read_request->hAdapterHandle, (*packet_block_ptr)[i]);
				}

				// Place packet back into the flow if was allowed to
				if (packet_action == packet_action::pass)
				{
					if ((*packet_block_ptr)[i].m_dwDeviceFlags == PACKET_FLAG_ON_SEND)
					{
						write_adapter_request->EthPacket[write_adapter_request->dwPacketsNumber].Buffer = &
							(*packet_block_ptr)[i];
						++write_adapter_request->dwPacketsNumber;
					}
					else
					{
						write_mstcp_request->EthPacket[write_mstcp_request->dwPacketsNumber].Buffer = &
							(*packet_block_ptr)[i];
						++write_mstcp_request->dwPacketsNumber;
					}
				}
				else if (packet_action == packet_action::revert)
				{
					if ((*packet_block_ptr)[i].m_dwDeviceFlags == PACKET_FLAG_ON_RECEIVE)
					{
						write_adapter_request->EthPacket[write_adapter_request->dwPacketsNumber].Buffer = &
							(*packet_block_ptr)[i];
						++write_adapter_request->dwPacketsNumber;
					}
					else
					{
						write_mstcp_request->EthPacket[write_mstcp_request->dwPacketsNumber].Buffer = &
							(*packet_block_ptr)[i];
						++write_mstcp_request->dwPacketsNumber;
					}
				}
			}

			read_request->dwPacketsSuccess = 0;

			std::lock_guard lk(packet_write_mstcp_queue_lock_);
			packet_write_mstcp_queue_.push(std::move(packet_block_ptr));
			packet_write_mstcp_queue_cv_.notify_one();
		}
	}

	inline void queued_packet_filter::packet_write_mstcp_thread()
	{
		while (filter_state_ == filter_state::running)
		{
			std::unique_lock lock(packet_write_mstcp_queue_lock_);

			packet_write_mstcp_queue_cv_.wait(lock, [this]
			{
				return filter_state_ != filter_state::running || !
					packet_write_mstcp_queue_.empty();
			});

			if (filter_state_ != filter_state::running)
				return;

			auto packet_block_ptr = std::move(packet_write_mstcp_queue_.front());
			packet_write_mstcp_queue_.pop();

			lock.unlock();

			if (auto* write_mstcp_request = packet_block_ptr->get_write_mstcp_request(); write_mstcp_request->
				dwPacketsNumber)
			{
				SendPacketsToMstcp(write_mstcp_request);
				write_mstcp_request->dwPacketsNumber = 0;
			}

			std::lock_guard lk(packet_write_adapter_queue_lock_);
			packet_write_adapter_queue_.push(std::move(packet_block_ptr));
			packet_write_adapter_queue_cv_.notify_one();
		}
	}

	inline void queued_packet_filter::packet_write_adapter_thread()
	{
		while (filter_state_ == filter_state::running)
		{
			std::unique_lock lock(packet_write_adapter_queue_lock_);

			packet_write_adapter_queue_cv_.wait(lock, [this]
			{
				return filter_state_ != filter_state::running || !
					packet_write_adapter_queue_.empty();
			});

			if (filter_state_ != filter_state::running)
				return;

			auto packet_block_ptr = std::move(packet_write_adapter_queue_.front());
			packet_write_adapter_queue_.pop();

			lock.unlock();

			if (auto* write_adapter_request = packet_block_ptr->get_write_adapter_request(); write_adapter_request->
				dwPacketsNumber)
			{
				SendPacketsToAdapter(write_adapter_request);
				write_adapter_request->dwPacketsNumber = 0;
			}

			std::lock_guard lk(packet_read_queue_lock_);
			packet_read_queue_.push(std::move(packet_block_ptr));
			packet_read_queue_cv_.notify_one();
		}
	}
}

```

`examples/cpp/common/ndisapi/simple_packet_filter.h`:

```h
// --------------------------------------------------------------------------------
/// <summary>
/// Module Name:  simple_packet_filter.h 
/// Abstract: Simple packet filter class declaration
/// </summary>
// --------------------------------------------------------------------------------

#pragma once

namespace ndisapi
{
	// --------------------------------------------------------------------------------
	/// <summary>
	/// simple winpkfilter based filter class for quick prototyping 
	/// </summary>
	// --------------------------------------------------------------------------------
	class simple_packet_filter final : public CNdisApi
	{
	public:
		enum class packet_action
		{
			pass,
			drop,
			revert
		};

	private:
		static constexpr size_t maximum_packet_block = 510;

		using request_storage_type_t = std::aligned_storage_t<sizeof(ETH_M_REQUEST) +
		                                                      sizeof(NDISRD_ETH_Packet) * (maximum_packet_block - 1),
		                                                      0x1000>;

		simple_packet_filter()
		{
			initialize_network_interfaces();
		}

	public:
		enum class filter_state
		{
			stopped,
			starting,
			running,
			stopping
		};

		~simple_packet_filter() override { stop_filter(); }

		simple_packet_filter(const simple_packet_filter& other) = delete;
		simple_packet_filter(simple_packet_filter&& other) noexcept = delete;
		simple_packet_filter& operator=(const simple_packet_filter& other) = delete;
		simple_packet_filter& operator=(simple_packet_filter&& other) noexcept = delete;

		// ********************************************************************************
		/// <summary>
		/// Constructs simple_packet_filter
		/// </summary>
		/// <param name="in">incoming packets handling routine</param>
		/// <param name="out">outgoing packet handling routine</param>
		/// <returns></returns>
		// ********************************************************************************
		template <typename F1, typename F2>
		simple_packet_filter(F1 in, F2 out) : simple_packet_filter()
		{
			filter_incoming_packet_ = in;
			filter_outgoing_packet_ = out;
		}

		// ********************************************************************************
		/// <summary>
		/// Updates available network interfaces. Should be called when the filter is inactive. 
		/// </summary>
		/// <returns>status of the operation</returns>
		// ********************************************************************************
		bool reconfigure();
		// ********************************************************************************
		/// <summary>
		/// Starts packet filtering
		/// </summary>
		/// <param name="adapter">network interface index to filter</param>
		/// <returns>status of the operation</returns>
		// ********************************************************************************
		bool start_filter(size_t adapter);
		// ********************************************************************************
		/// <summary>
		/// Stops packet filtering
		/// </summary>
		/// <returns>status of the operation</returns>
		// ********************************************************************************
		bool stop_filter();
		// ********************************************************************************
		/// <summary>
		/// Queries the list of the names for the available network interfaces
		/// </summary>
		/// <returns>list of network adapters friendly names</returns>
		// ********************************************************************************
		std::vector<std::string> get_interface_names_list() const;

		// ********************************************************************************
		/// <summary>
		/// Queries the list of the available network interfaces
		/// </summary>
		/// <returns>vector of available network adapters</returns>
		// ********************************************************************************
		const std::vector<std::unique_ptr<network_adapter>>& get_interface_list() const;

		// ********************************************************************************
		/// <summary>
		/// Returns current filter state
		/// </summary>
		/// <returns>current filter state</returns>
		// ********************************************************************************
		[[nodiscard]] filter_state get_filter_state() const
		{
			return filter_state_.load();
		}

	private:
		// ********************************************************************************
		/// <summary>
		/// Working thread routine
		/// </summary>
		// ********************************************************************************
		void filter_working_thread();
		// ********************************************************************************
		/// <summary>
		/// Initializes available network interface list
		/// </summary>
		// ********************************************************************************
		void initialize_network_interfaces();
		// ********************************************************************************
		/// <summary>
		/// Initialize interface and associated data structures required for packet filtering
		/// </summary>
		/// <returns>true is success, false otherwise</returns>
		// ********************************************************************************
		bool init_filter();
		// ********************************************************************************
		/// <summary>
		/// Release interface and associated data structures required for packet filtering
		/// </summary>
		// ********************************************************************************
		void release_filter();

		/// <summary>outgoing packet processing functor</summary>
		std::function<packet_action(HANDLE, INTERMEDIATE_BUFFER&)> filter_outgoing_packet_ = nullptr;
		/// <summary>incoming packet processing functor</summary>
		std::function<packet_action(HANDLE, INTERMEDIATE_BUFFER&)> filter_incoming_packet_ = nullptr;
		/// <summary>working thread running status</summary>
		std::atomic<filter_state> filter_state_ = filter_state::stopped;
		/// <summary>list of available network interfaces</summary>
		std::vector<std::unique_ptr<network_adapter>> network_interfaces_;
		/// <summary>working thread object</summary>
		std::thread working_thread_;
		/// <summary>filtered adapter index</summary>
		size_t adapter_{0};
		/// <summary>array of INTERMEDIATE_BUFFER structures</summary>
		std::unique_ptr<INTERMEDIATE_BUFFER[]> packet_buffer_;
		/// <summary>driver request for reading packets</summary>
		std::unique_ptr<request_storage_type_t> read_request_ptr_;
		/// <summary>driver request for writing packets to adapter</summary>
		std::unique_ptr<request_storage_type_t> write_adapter_request_ptr_;
		/// <summary>driver request for writing packets up to protocol stack</summary>
		std::unique_ptr<request_storage_type_t> write_mstcp_request_ptr_;
	};

	inline bool simple_packet_filter::init_filter()
	{
		try
		{
			packet_buffer_ = std::make_unique<INTERMEDIATE_BUFFER[]>(maximum_packet_block);

			read_request_ptr_ = std::make_unique<request_storage_type_t>();
			write_adapter_request_ptr_ = std::make_unique<request_storage_type_t>();
			write_mstcp_request_ptr_ = std::make_unique<request_storage_type_t>();
		}
		catch (const std::bad_alloc&)
		{
			return false;
		}

		auto* read_request = reinterpret_cast<PETH_M_REQUEST>(read_request_ptr_.get());
		auto* write_adapter_request = reinterpret_cast<PETH_M_REQUEST>(write_adapter_request_ptr_.get());
		auto* write_mstcp_request = reinterpret_cast<PETH_M_REQUEST>(write_mstcp_request_ptr_.get());

		read_request->hAdapterHandle = network_interfaces_[adapter_]->get_adapter();
		write_adapter_request->hAdapterHandle = network_interfaces_[adapter_]->get_adapter();
		write_mstcp_request->hAdapterHandle = network_interfaces_[adapter_]->get_adapter();

		read_request->dwPacketsNumber = maximum_packet_block;

		//
		// Initialize packet buffers
		//
		ZeroMemory(packet_buffer_.get(), sizeof(INTERMEDIATE_BUFFER) * maximum_packet_block);

		for (unsigned i = 0; i < maximum_packet_block; ++i)
		{
			read_request->EthPacket[i].Buffer = &packet_buffer_[i];
		}

		//
		// Set events for helper driver
		//
		if (!network_interfaces_[adapter_]->set_packet_event())
		{
			packet_buffer_.reset();
			read_request_ptr_.reset();
			write_adapter_request_ptr_.reset();
			write_mstcp_request_ptr_.reset();

			return false;
		}

		network_interfaces_[adapter_]->set_mode(MSTCP_FLAG_SENT_TUNNEL | MSTCP_FLAG_RECV_TUNNEL);

		return true;
	}

	inline void simple_packet_filter::release_filter()
	{
		network_interfaces_[adapter_]->release();

		// Wait for working thread to exit
		if (working_thread_.joinable())
			working_thread_.join();

		packet_buffer_.reset();
		read_request_ptr_.reset();
		write_adapter_request_ptr_.reset();
		write_mstcp_request_ptr_.reset();
	}

	inline bool simple_packet_filter::reconfigure()
	{
		if (filter_state_ != filter_state::stopped)
			return false;

		network_interfaces_.clear();

		initialize_network_interfaces();

		return true;
	}

	inline bool simple_packet_filter::start_filter(const size_t adapter)
	{
		if (filter_state_ != filter_state::stopped)
			return false;

		filter_state_ = filter_state::starting;

		adapter_ = adapter;

		if (init_filter())
			working_thread_ = std::thread(&simple_packet_filter::filter_working_thread, this);
		else
			return false;

		return true;
	}

	inline bool simple_packet_filter::stop_filter()
	{
		if (filter_state_ != filter_state::running)
			return false;

		filter_state_ = filter_state::stopping;

		release_filter();

		filter_state_ = filter_state::stopped;

		return true;
	}

	inline std::vector<std::string> simple_packet_filter::get_interface_names_list() const
	{
		std::vector<std::string> result;
		result.reserve(network_interfaces_.size());

		for (auto&& e : network_interfaces_)
		{
			result.push_back(e->get_friendly_name());
		}

		return result;
	}

	inline const std::vector<std::unique_ptr<network_adapter>>& simple_packet_filter::get_interface_list() const
	{
		return network_interfaces_;
	}

	inline void simple_packet_filter::initialize_network_interfaces()
	{
		TCP_AdapterList ad_list;
		std::vector<char> friendly_name(MAX_PATH * 4);

		GetTcpipBoundAdaptersInfo(&ad_list);

		for (size_t i = 0; i < ad_list.m_nAdapterCount; ++i)
		{
			ConvertWindows2000AdapterName(reinterpret_cast<const char*>(ad_list.m_szAdapterNameList[i]),
			                              friendly_name.data(), static_cast<DWORD>(friendly_name.size()));

			network_interfaces_.push_back(
				std::make_unique<network_adapter>(
					this,
					ad_list.m_nAdapterHandle[i],
					ad_list.m_czCurrentAddress[i],
					std::string(reinterpret_cast<const char*>(ad_list.m_szAdapterNameList[i])),
					std::string(friendly_name.data()),
					ad_list.m_nAdapterMediumList[i],
					ad_list.m_usMTU[i]));
		}
	}

	inline void simple_packet_filter::filter_working_thread()
	{
		filter_state_ = filter_state::running;

		auto* read_request = reinterpret_cast<PETH_M_REQUEST>(read_request_ptr_.get());
		auto* write_adapter_request = reinterpret_cast<PETH_M_REQUEST>(write_adapter_request_ptr_.get());
		auto* write_mstcp_request = reinterpret_cast<PETH_M_REQUEST>(write_mstcp_request_ptr_.get());

		while (filter_state_ == filter_state::running)
		{
			[[maybe_unused]] auto wait_result = network_interfaces_[adapter_]->wait_event(INFINITE);

			[[maybe_unused]] auto reset_result = network_interfaces_[adapter_]->reset_event();

			while (filter_state_ == filter_state::running && ReadPackets(read_request))
			{
				for (size_t i = 0; i < read_request->dwPacketsSuccess; ++i)
				{
					auto packet_action = packet_action::pass;

					if (packet_buffer_[i].m_dwDeviceFlags == PACKET_FLAG_ON_SEND)
					{
						if (filter_outgoing_packet_ != nullptr)
							packet_action = filter_outgoing_packet_(read_request->hAdapterHandle, packet_buffer_[i]);
					}
					else
					{
						if (filter_incoming_packet_ != nullptr)
							packet_action = filter_incoming_packet_(read_request->hAdapterHandle, packet_buffer_[i]);
					}

					// Place packet back into the flow if was allowed to
					if (packet_action == packet_action::pass)
					{
						if (packet_buffer_[i].m_dwDeviceFlags == PACKET_FLAG_ON_SEND)
						{
							write_adapter_request->EthPacket[write_adapter_request->dwPacketsNumber].Buffer = &
								packet_buffer_[i];
							++write_adapter_request->dwPacketsNumber;
						}
						else
						{
							write_mstcp_request->EthPacket[write_mstcp_request->dwPacketsNumber].Buffer = &
								packet_buffer_[i];
							++write_mstcp_request->dwPacketsNumber;
						}
					}
					else if (packet_action == packet_action::revert)
					{
						if (packet_buffer_[i].m_dwDeviceFlags == PACKET_FLAG_ON_RECEIVE)
						{
							write_adapter_request->EthPacket[write_adapter_request->dwPacketsNumber].Buffer = &
								packet_buffer_[i];
							++write_adapter_request->dwPacketsNumber;
						}
						else
						{
							write_mstcp_request->EthPacket[write_mstcp_request->dwPacketsNumber].Buffer = &
								packet_buffer_[i];
							++write_mstcp_request->dwPacketsNumber;
						}
					}
				}

				if (write_adapter_request->dwPacketsNumber)
				{
					SendPacketsToAdapter(write_adapter_request);
					write_adapter_request->dwPacketsNumber = 0;
				}

				if (write_mstcp_request->dwPacketsNumber)
				{
					SendPacketsToMstcp(write_mstcp_request);
					write_mstcp_request->dwPacketsNumber = 0;
				}

				read_request->dwPacketsSuccess = 0;
			}
		}
	}
}

```

`examples/cpp/common/ndisapi/udp_proxy.h`:

```h
#pragma once

namespace ndisapi
{
	// ********************************************************************************
	/// <summary>
	/// erase_if template for associative containers
	/// </summary>
	// ********************************************************************************
	template <typename ContainerT, class FwdIt, class Pr>
	void erase_if(ContainerT& items, FwdIt it, FwdIt last, Pr predicate)
	{
		for (; it != last;)
		{
			if (predicate(*it)) it = items.erase(it);
			else ++it;
		}
	}

	enum class log_level
	{
		none = 0,
		info = 1,
		debug = 2,
		all = 3,
	};

	enum class proxy_status
	{
		starting,
		started,
		stopping,
		stopped
	};

	template <typename T>
	class udp_proxy_server;

	template <typename T>
	class udp_proxy_socket
	{
		friend udp_proxy_server;

	public:
		using address_type_t = T;
		using negotiate_context_t = proxy::negotiate_context<T>;

		udp_proxy_socket(
			CNdisApi* ndis_api,
			const uint16_t local_port,
			address_type_t remote_peer_address,
			const uint16_t remote_peer_port,
			address_type_t original_peer_address,
			const uint16_t original_peer_port,
			std::unique_ptr<negotiate_context_t> negotiate_ctx)
			: ndis_api_(ndis_api),
			  local_port_(local_port),
			  remote_peer_address_(remote_peer_address),
			  remote_peer_port_(remote_peer_port),
			  original_peer_address_(original_peer_address),
			  original_peer_port_(original_peer_port),
			  negotiate_ctx_(std::move(negotiate_ctx))
		{
			lock_ = std::make_unique<std::mutex>();

			using namespace std::chrono_literals;
			timeout_ = 300s;
		}

		udp_proxy_socket(const udp_proxy_socket& other) = delete;

		udp_proxy_socket(udp_proxy_socket&& other) noexcept
			: ndis_api_(other.ndis_api_),
			  local_port_(other.local_port_),
			  remote_peer_address_(std::move(other.remote_peer_address_)),
			  remote_peer_port_(other.remote_peer_port_),
			  original_peer_address_(std::move(other.original_peer_address_)),
			  original_peer_port_(other.original_peer_port_),
			  negotiate_ctx_(std::move(other.negotiate_ctx_)),
			  relay_started_(std::move(other.relay_started_)), timeout_(std::move(other.timeout_)),
			  lock_(std::move(other.lock_)),
			  to_remote_queue_(std::move(other.to_remote_queue_))
		{
		}

		udp_proxy_socket& operator=(const udp_proxy_socket& other) = delete;

		udp_proxy_socket& operator=(udp_proxy_socket&& other) noexcept
		{
			if (this == &other)
				return *this;
			ndis_api_ = other.ndis_api_;
			local_port_ = other.local_port_;
			remote_peer_address_ = std::move(other.remote_peer_address_);
			remote_peer_port_ = other.remote_peer_port_;
			original_peer_address_ = std::move(other.original_peer_address_);
			original_peer_port_ = other.original_peer_port_;
			negotiate_ctx_ = std::move(other.negotiate_ctx_);
			relay_started_ = std::move(other.relay_started_);
			timeout_ = std::move(other.timeout_);
			lock_ = std::move(other.lock_);
			to_remote_queue_ = std::move(other.to_remote_queue_);
			return *this;
		}

		virtual ~udp_proxy_socket() = default;

		size_t get_maximum_queue_size() const
		{
			return maximum_queue_size_;
		}

		void set_maximum_queue_size(const size_t maximum_queue_size)
		{
			maximum_queue_size_ = maximum_queue_size;
		}


		std::chrono::steady_clock::duration get_timeout() const
		{
			return timeout_;
		}

		void set_timeout(const std::chrono::steady_clock::duration timeout)
		{
			timeout_ = timeout;
		}


		T get_original_peer_address() const
		{
			return original_peer_address_;
		}

		uint16_t get_original_peer_port() const
		{
			return original_peer_port_;
		}

		// ********************************************************************************
		/// <summary>
		/// Attempts to negotiate credentials with remote peer and starts data relay
		/// </summary>
		/// <param name="adapter_handle">Associated ndisapi adapter handle </param>
		/// <param name="packet">First outgoing UDP packet on the wire</param>
		/// <returns>true is relay was started, false otherwise</returns>
		// ********************************************************************************
		bool start(HANDLE adapter_handle, INTERMEDIATE_BUFFER& packet)
		{
			const auto ether_header = reinterpret_cast<ether_header_ptr>(packet.m_IBuffer);

			timestamp_ = std::chrono::steady_clock::now();
			adapter_handle_ = adapter_handle;
			local_mac_address_ = net::mac_address(ether_header->h_source);
			remote_mac_address_ = net::mac_address(ether_header->h_dest);

			if constexpr (std::is_same_v<address_type_t, net::ip_address_v4>)
			{
				if (ntohs(ether_header->h_proto) == ETH_P_IP)
				{
					const auto ip_header = reinterpret_cast<iphdr_ptr>(ether_header + 1);

					if (ip_header->ip_p == IPPROTO_UDP)
					{
						const auto udp_header = reinterpret_cast<udphdr_ptr>(reinterpret_cast<PUCHAR>(ip_header) +
							sizeof(DWORD) * ip_header->ip_hl);
						local_ip_address_ = ip_header->ip_src;
						local_udp_port_ = ntohs(udp_header->th_sport);
					}
				}
			}
			else if constexpr (std::is_same_v<address_type_t, net::ip_address_v6>)
			{
				if (ntohs(ether_header->h_proto) == ETH_P_IPV6)
				{
					const auto ip_header = reinterpret_cast<ipv6hdr_ptr>(ether_header + 1);
					auto [header, protocol] = net::ipv6_helper::find_transport_header(
						ip_header, packet.m_Length - ETHER_HEADER_LENGTH);

					if (protocol == IPPROTO_UDP)
					{
						const auto udp_header = reinterpret_cast<udphdr_ptr>(header);
						local_ip_address_ = ip_header->ip6_src;
						local_udp_port_ = ntohs(udp_header->th_sport);
					}
				}
			}

			if (remote_negotiate())
			{
				// if negotiate phase can be complete immediately (or not needed at all)
				// start data relay here
				return start_data_relay();
			}

			// otherwise start_data_relay should be called from process_in_packet
			return false;
		}

		// ********************************************************************************
		/// <summary>
		/// Called for incoming packets
		/// </summary>
		/// <param name="packet">network packet to process</param>
		/// <returns>action to be taken for the packet</returns>
		// ********************************************************************************
		simple_packet_filter::packet_action process_in_packet(INTERMEDIATE_BUFFER& packet)
		{
			if (!relay_started_.load(std::memory_order_acquire))
			{
				return process_in_packet_internal(packet);
			}

			const auto ether_header = reinterpret_cast<ether_header_ptr>(packet.m_IBuffer);
			auto result = simple_packet_filter::packet_action::pass;

			if constexpr (std::is_same_v<address_type_t, net::ip_address_v4>)
			{
				if (ntohs(ether_header->h_proto) == ETH_P_IP)
				{
					if (const auto ip_header = reinterpret_cast<iphdr_ptr>(ether_header + 1); ip_header->ip_p ==
						IPPROTO_UDP)
					{
						const auto udp_header = reinterpret_cast<udphdr_ptr>(reinterpret_cast<PUCHAR>(ip_header) +
							sizeof(DWORD) * ip_header->ip_hl);

						ip_header->ip_src = original_peer_address_;
						udp_header->th_sport = htons(original_peer_port_);

						result = process_in_packet_internal(packet);

						CNdisApi::RecalculateUDPChecksum(&packet);
						CNdisApi::RecalculateIPChecksum(&packet);
					}
				}
			}
			else if constexpr (std::is_same_v<address_type_t, net::ip_address_v6>)
			{
				if (ntohs(ether_header->h_proto) == ETH_P_IPV6)
				{
					const auto ip_header = reinterpret_cast<ipv6hdr_ptr>(ether_header + 1);

					if (auto [header, protocol] = net::ipv6_helper::find_transport_header(
						ip_header, packet.m_Length - ETHER_HEADER_LENGTH); protocol == IPPROTO_UDP)
					{
						const auto udp_header = static_cast<udphdr_ptr>(header);

						ip_header->ip6_src = original_peer_address_;
						udp_header->th_sport = htons(original_peer_port_);

						result = process_in_packet_internal(packet);

						net::ipv6_helper::recalculate_tcp_udp_checksum(&packet);
					}
				}
			}

			timestamp_ = std::chrono::steady_clock::now();

			return result;
		}

		// ********************************************************************************
		/// <summary>
		/// Called for outgoing packets
		/// </summary>
		/// <param name="packet">network packet to process</param>
		/// <returns>action to be taken for the packet</returns>
		// ********************************************************************************
		simple_packet_filter::packet_action process_out_packet(INTERMEDIATE_BUFFER& packet)
		{
			if (!relay_started_.load(std::memory_order_acquire))
			{
				std::lock_guard<std::mutex> lock(*lock_);
				if (maximum_queue_size_ > to_remote_queue_.size())
					to_remote_queue_.emplace_back(std::make_unique<INTERMEDIATE_BUFFER>(packet));

				// call packet processing but don't re-inject because packet is already queued
				process_out_packet_internal(packet);

				return simple_packet_filter::packet_action::drop;
			}

			const auto ether_header = reinterpret_cast<ether_header_ptr>(packet.m_IBuffer);
			auto result = simple_packet_filter::packet_action::pass;

			if constexpr (std::is_same_v<address_type_t, net::ip_address_v4>)
			{
				if (ntohs(ether_header->h_proto) == ETH_P_IP)
				{
					if (const auto ip_header = reinterpret_cast<iphdr_ptr>(ether_header + 1); ip_header->ip_p ==
						IPPROTO_UDP)
					{
						const auto udp_header = reinterpret_cast<udphdr_ptr>(reinterpret_cast<PUCHAR>(ip_header) +
							sizeof(DWORD) * ip_header->ip_hl);

						ip_header->ip_dst = remote_peer_address_;
						udp_header->th_dport = htons(remote_peer_port_);

						result = process_out_packet_internal(packet);

						CNdisApi::RecalculateUDPChecksum(&packet);
						CNdisApi::RecalculateIPChecksum(&packet);
					}
				}
			}
			else if constexpr (std::is_same_v<address_type_t, net::ip_address_v6>)
			{
				if (ntohs(ether_header->h_proto) == ETH_P_IPV6)
				{
					const auto ip_header = reinterpret_cast<ipv6hdr_ptr>(ether_header + 1);

					if (auto [header, protocol] = net::ipv6_helper::find_transport_header(
						ip_header, packet.m_Length - ETHER_HEADER_LENGTH); protocol == IPPROTO_UDP)
					{
						const auto udp_header = static_cast<udphdr_ptr>(header);

						ip_header->ip6_dst = remote_peer_address_;
						udp_header->th_dport = htons(remote_peer_port_);

						result = process_out_packet_internal(packet);

						net::ipv6_helper::recalculate_tcp_udp_checksum(&packet);
					}
				}
			}

			timestamp_ = std::chrono::steady_clock::now();

			return result;
		}

		virtual bool keep_alive(const std::chrono::steady_clock::time_point now)
		{
			if ((now - timestamp_) > timeout_)
				return false;

			return true;
		}

	protected:
		// ********************************************************************************
		/// <summary>
		/// Switches on the relay flag and processes all queued packets
		/// </summary>
		/// <returns>status of the operation</returns>
		// ********************************************************************************
		bool start_data_relay()
		{
			if (auto expected = false; relay_started_.
				compare_exchange_strong(expected, true, std::memory_order_acq_rel))
			{
				std::lock_guard<std::mutex> lock(*lock_);

				std::for_each(to_remote_queue_.begin(), to_remote_queue_.end(), [this](auto&& packet)
				{
					ETH_REQUEST request = {adapter_handle_, packet.get()};
					if (simple_packet_filter::packet_action::pass == process_out_packet(*packet.get()))
						ndis_api_->SendPacketToAdapter(&request);
				});

				// Clear the queues
				to_remote_queue_.clear();

				// Release memory from the queues
				to_remote_queue_.shrink_to_fit();

				return true;
			}

			return false;
		}

		// ********************************************************************************
		/// <summary>
		/// Generates an outgoing UDP packet associated with proxy session
		/// </summary>
		/// <param name="data">UDP payload adata pointer</param>
		/// <param name="length">length of the data</param>
		/// <returns>pointer to the generated INTERMEDIATE_BUFFER</returns>
		// ********************************************************************************
		std::unique_ptr<INTERMEDIATE_BUFFER> forge_outgoing_udp_packet(uint8_t* data, const size_t length) const
		{
			auto packet = std::make_unique<INTERMEDIATE_BUFFER>();

			const auto ether_hdr = reinterpret_cast<ether_header_ptr>(packet->m_IBuffer);
			memcpy_s(ether_hdr->h_dest, ETHER_ADDR_LENGTH, &remote_mac_address_[0], ETHER_ADDR_LENGTH);
			memcpy_s(ether_hdr->h_source, ETHER_ADDR_LENGTH, &local_mac_address_[0], ETHER_ADDR_LENGTH);

			if constexpr (std::is_same_v<address_type_t, net::ip_address_v4>)
			{
				if (length > (MAX_ETHER_FRAME - sizeof(ether_header) - sizeof(iphdr) - sizeof(udphdr)))
					return nullptr;

				ether_hdr->h_proto = ETH_P_IP_NET;

				const auto ip_header = reinterpret_cast<iphdr_ptr>(ether_hdr + 1);
				const auto udp_header = reinterpret_cast<udphdr_ptr>(reinterpret_cast<PUCHAR>(ip_header) + sizeof(
					uint32_t) * 5);

				// Copy data payload
				memcpy_s(udp_header + 1,
				         MAX_ETHER_FRAME - (sizeof(ether_header) + sizeof(iphdr) + sizeof(udphdr)),
				         data,
				         length
				);

				// Set new packet buffer length
				packet->m_Length =
					static_cast<unsigned long>(sizeof(ether_header) + // NOLINT(bugprone-misplaced-widening-cast)
						sizeof(uint32_t) * 5 + sizeof(udphdr) + length);

				ip_header->ip_v = 4;
				ip_header->ip_hl = 5;
				ip_header->ip_id = static_cast<uint16_t>(std::rand());
				ip_header->ip_p = IPPROTO_UDP;
				ip_header->ip_src = local_ip_address_;
				ip_header->ip_dst = remote_peer_address_;
				ip_header->ip_len = htons(static_cast<short>(packet->m_Length - sizeof(ether_header)));
				ip_header->ip_ttl = 128;

				udp_header->th_sport = htons(local_port_);
				udp_header->th_dport = htons(remote_peer_port_);
				udp_header->length = htons(
					static_cast<short>(packet->m_Length - sizeof(ether_header) - 4 * ip_header->ip_hl));

				// Recalculate checksum
				CNdisApi::RecalculateUDPChecksum(packet.get());
				CNdisApi::RecalculateIPChecksum(packet.get());
			}
			else if constexpr (std::is_same_v<address_type_t, net::ip_address_v6>)
			{
				if (length > (MAX_ETHER_FRAME - sizeof(ether_header) - sizeof(ipv6hdr) - sizeof(udphdr)))
					return nullptr;

				ether_hdr->h_proto = ETH_P_IPV6_NET;

				const auto ip_header = reinterpret_cast<ipv6hdr_ptr>(ether_hdr + 1);
				const auto udp_header = reinterpret_cast<udphdr_ptr>(ip_header + 1);

				// Copy data payload
				memcpy_s(udp_header + 1,
				         MAX_ETHER_FRAME - (sizeof(ether_header) + sizeof(ipv6hdr) + sizeof(udphdr)),
				         data,
				         length
				);

				// Set new packet buffer length
				packet->m_Length =
					static_cast<unsigned long>(sizeof(ether_header) + // NOLINT(bugprone-misplaced-widening-cast)
						sizeof(ipv6hdr) + sizeof(udphdr) + length);

				ip_header->ip6_v = 6;
				ip_header->ip6_len = htons(
					static_cast<short>(packet->m_Length - sizeof(ether_header) - sizeof(ipv6hdr)));
				ip_header->ip6_next = IPPROTO_UDP;
				ip_header->ip6_src = local_ip_address_;
				ip_header->ip6_dst = remote_peer_address_;
				ip_header->ip6_hops = 128;

				udp_header->th_sport = htons(local_port_);
				udp_header->th_dport = htons(remote_peer_port_);
				udp_header->length = htons(
					static_cast<short>(packet->m_Length - sizeof(ether_header) - sizeof(ipv6hdr)));

				// Recalculate checksum
				net::ipv6_helper::recalculate_tcp_udp_checksum(packet.get());
			}
			else
			{
				return nullptr;
			}

			return packet;
		}

		// ********************************************************************************
		/// <summary>
		/// Called for proxy specific negotiate/authenticate with remote proxy/host
		/// </summary>
		/// <returns>true is successful</returns>
		// ********************************************************************************
		virtual bool remote_negotiate()
		{
			return true;
		}

		// ********************************************************************************
		/// <summary>
		/// Called for proxy specific incoming packet processing
		/// </summary>
		/// <param name="packet">packet to process</param>
		/// <returns>action to be taken for the packet</returns>
		// ********************************************************************************
		virtual simple_packet_filter::packet_action process_in_packet_internal(INTERMEDIATE_BUFFER& packet)
		{
			return simple_packet_filter::packet_action::pass;
		}

		// ********************************************************************************
		/// <summary>
		/// Called for proxy specific outgoing packets processing
		/// </summary>
		/// <param name="packet">packet to process</param>
		/// <returns>action to be taken for the packet</returns>
		// ********************************************************************************
		virtual simple_packet_filter::packet_action process_out_packet_internal(INTERMEDIATE_BUFFER& packet)
		{
			return simple_packet_filter::packet_action::pass;
		}

		// ********************************************************************************
		/// <summary>
		/// Queries a pointer to the negotiate_context
		/// </summary>
		/// <returns> raw pointer to the negotiate_context</returns>
		// ********************************************************************************
		negotiate_context_t* get_negotiate_ctx() const
		{
			return negotiate_ctx_.get();
		}

		CNdisApi* ndis_api_;
		uint16_t local_port_;
		address_type_t remote_peer_address_;
		uint16_t remote_peer_port_;
		address_type_t original_peer_address_;
		uint16_t original_peer_port_;
		std::unique_ptr<negotiate_context_t> negotiate_ctx_;
		std::atomic_bool relay_started_{false};

		std::chrono::steady_clock::time_point timestamp_{};
		HANDLE adapter_handle_{nullptr};
		net::mac_address local_mac_address_{};
		net::mac_address remote_mac_address_{};
		address_type_t local_ip_address_{};
		uint16_t local_udp_port_{};

		size_t maximum_queue_size_{510};
		std::chrono::steady_clock::duration timeout_;

		/// <summary>provides synchronization for the I/O operations</summary>
		std::unique_ptr<std::mutex> lock_;

		std::vector<std::unique_ptr<INTERMEDIATE_BUFFER>> to_remote_queue_;
	};

	template <typename T>
	class udp_proxy_server : public iphelper::network_config_info<udp_proxy_server<T>>
	{
		friend iphelper::network_config_info<udp_proxy_server<T>>;

	public:
		using negotiate_context_t = typename T::negotiate_context_t;
		using address_type_t = typename T::address_type_t;

		using query_remote_peer_t = std::tuple<address_type_t, uint16_t, std::unique_ptr<negotiate_context_t>>(
			address_type_t,
			uint16_t,
			address_type_t,
			uint16_t);

		udp_proxy_server(const std::function<query_remote_peer_t> query_remote_peer_fn,
		                 const address_type_t& server_address, void (*log_printer)(const char*), const log_level level)
			: query_remote_peer_{query_remote_peer_fn}, command_server_address_{server_address},
			  log_printer_{log_printer}, log_level_{level}

		{
			lock_ = std::make_unique<std::shared_mutex>();
			set_packet_filter();
		}

		~udp_proxy_server()
		{
			stop();
		}


		udp_proxy_server(const udp_proxy_server& other) = delete;

		udp_proxy_server(udp_proxy_server&& other) noexcept
			: iphelper::network_config_info<udp_proxy_server<T>>(std::move(other)),
			  lock_(std::move(other.lock_)),
			  keep_alive_thread_(std::move(other.keep_alive_thread_)),
			  proxy_sockets_(std::move(other.proxy_sockets_)),
			  query_remote_peer_(std::move(other.query_remote_peer_)),
			  packet_filter_(std::move(other.packet_filter_)),
			  network_interfaces_(std::move(other.network_interfaces_)),
			  default_adapter_(std::move(other.default_adapter_)),
			  mtu_(other.mtu_),
			  if_index_(other.if_index_),
			  if_handle_(other.if_handle_),
			  command_server_address_(std::move(other.command_server_address_)),
			  log_printer_(std::move(other.log_printer_)),
			  log_level_(other.log_level_),
			  status_(other.status_.load()),
			  remote_address_(std::move(other.remote_address_))
		{
		}

		udp_proxy_server& operator=(const udp_proxy_server& other) = delete;

		udp_proxy_server& operator=(udp_proxy_server&& other) noexcept
		{
			if (this == &other)
				return *this;
			iphelper::network_config_info<udp_proxy_server<T>>::operator =(std::move(other));
			lock_ = std::move(other.lock_);
			keep_alive_thread_ = std::move(other.keep_alive_thread_);
			proxy_sockets_ = std::move(other.proxy_sockets_);
			query_remote_peer_ = std::move(other.query_remote_peer_);
			packet_filter_ = std::move(other.packet_filter_);
			network_interfaces_ = std::move(other.network_interfaces_);
			default_adapter_ = std::move(other.default_adapter_);
			mtu_ = other.mtu_;
			if_index_ = other.if_index_;
			if_handle_ = other.if_handle_;
			command_server_address_ = std::move(other.command_server_address_);
			log_printer_ = std::move(other.log_printer_);
			log_level_ = other.log_level_;
			status_ = other.status_.load();
			remote_address_ = std::move(other.remote_address_);
			return *this;
		}

		std::optional<proxy_status> start()
		{
			if (!this->iphelper::network_config_info<udp_proxy_server<T>>::set_notify_ip_interface_change())
			{
				print_log(log_level::info, "udp_proxy_server::start: set_notify_ip_interface_change has failed!");
			}

			return start_internal();
		}

		void stop()
		{
			if (!this->iphelper::network_config_info<udp_proxy_server<T>>::cancel_notify_ip_interface_change())
			{
				print_log(log_level::info, "udp_proxy_server::start: cancel_notify_ip_interface_change has failed!");
			}

			using namespace std::chrono_literals;

			while (status_ != proxy_status::stopped)
			{
				stop_internal();
				std::this_thread::sleep_for(1ms);
			}
		}

		std::vector<negotiate_context_t> query_current_sessions_ctx()
		{
			std::shared_lock<std::shared_mutex> lock(*lock_);
			std::vector<negotiate_context_t> result;
			result.reserve(proxy_sockets_.size());

			std::transform(proxy_sockets_.cbegin(), proxy_sockets_.cend(), std::back_inserter(result), [](auto&& e)
			{
				return *reinterpret_cast<negotiate_context_t*>(e.second->get_negotiate_ctx());
			});

			return result;
		}

	private:
		std::optional<proxy_status> start_internal()
		{
			auto expected = proxy_status::stopped;
			if (!status_.compare_exchange_strong(expected, proxy_status::starting))
				return {};

			if (!update_network_configuration())
			{
				status_ = proxy_status::stopped;
				return status_;
			}

			// start_internal keep-alive thread here
			keep_alive_thread_ = std::thread(&udp_proxy_server::keep_alive_thread, this);

			if (packet_filter_->start_filter(if_index_))
			{
				status_ = proxy_status::started;
			}
			else
			{
				status_ = proxy_status::stopped;

				if (keep_alive_thread_.joinable())
					keep_alive_thread_.join();
			}

			return status_;
		}

		std::optional<proxy_status> stop_internal()
		{
			auto expected = proxy_status::started;
			if (!status_.compare_exchange_strong(expected, proxy_status::stopping))
				return {};

			if (packet_filter_)
				packet_filter_->stop_filter();

			if (keep_alive_thread_.joinable())
				keep_alive_thread_.join();

			proxy_sockets_.clear();

			status_ = proxy_status::stopped;

			return status_;
		}

		void keep_alive_thread()
		{
			while (status_ == proxy_status::started)
			{
				{
					std::lock_guard<std::shared_mutex> lock(*lock_);
					erase_if(proxy_sockets_, proxy_sockets_.begin(), proxy_sockets_.end(),
					         [now = std::chrono::steady_clock::now() ](auto&& socket)
					         {
						         return !socket.second->keep_alive(now);
					         });
				}

				using namespace std::chrono_literals;
				std::this_thread::sleep_for(1000ms);
			}
		}

		void set_packet_filter()
		{
			packet_filter_ = std::make_unique<simple_packet_filter>(
				[this](HANDLE adapter_handle, INTERMEDIATE_BUFFER& buffer)
				{
					auto packet_action = simple_packet_filter::packet_action::pass;

					if constexpr (const auto ether_header = reinterpret_cast<ether_header_ptr>(buffer.m_IBuffer);
						std::is_same_v<address_type_t, net::ip_address_v4>)
					{
						if (ntohs(ether_header->h_proto) == ETH_P_IP)
						{
							if (const auto ip_header = reinterpret_cast<iphdr_ptr>(ether_header + 1); ip_header->ip_p ==
								IPPROTO_UDP)
							{
								const auto udp_header = reinterpret_cast<udphdr_ptr>(reinterpret_cast<PUCHAR>(ip_header)
									+ sizeof(DWORD) * ip_header->ip_hl);

								std::shared_lock<std::shared_mutex> lock(*lock_);

								if (auto it = proxy_sockets_.find(ntohs(udp_header->th_dport)); it != proxy_sockets_.
									end())
								{
									packet_action = it->second->process_in_packet(buffer);
								}
							}
						}
					}
					else if constexpr (std::is_same_v<address_type_t, net::ip_address_v6>)
					{
						if (ntohs(ether_header->h_proto) == ETH_P_IPV6)
						{
							const auto ip_header = reinterpret_cast<ipv6hdr_ptr>(ether_header + 1);

							if (auto [header, protocol] = net::ipv6_helper::find_transport_header(
								ip_header, buffer.m_Length - ETHER_HEADER_LENGTH); protocol == IPPROTO_UDP)
							{
								const auto udp_header = static_cast<udphdr_ptr>(header);

								std::shared_lock<std::shared_mutex> lock(*lock_);

								if (auto it = proxy_sockets_.find(ntohs(udp_header->th_dport)); it != proxy_sockets_.
									end())
								{
									packet_action = it->second->process_in_packet(buffer);
								}
							}
						}
					}
					return packet_action;
				},
				[this](HANDLE adapter_handle, INTERMEDIATE_BUFFER& buffer)
				{
					auto packet_action = simple_packet_filter::packet_action::pass;

					if constexpr (const auto ether_header = reinterpret_cast<ether_header_ptr>(buffer.m_IBuffer);
						std::is_same_v<address_type_t, net::ip_address_v4>)
					{
						if (ntohs(ether_header->h_proto) == ETH_P_IP)
						{
							if (const auto ip_header = reinterpret_cast<iphdr_ptr>(ether_header + 1); ip_header->ip_p ==
								IPPROTO_UDP)
							{
								const auto udp_header = reinterpret_cast<udphdr_ptr>(reinterpret_cast<PUCHAR>(ip_header)
									+ sizeof(DWORD) * ip_header->ip_hl);

								std::shared_lock<std::shared_mutex> lock(*lock_);

								if (auto it = proxy_sockets_.find(ntohs(udp_header->th_sport)); (it != proxy_sockets_.
										end()) &&
									(it->second->get_original_peer_address() == address_type_t(ip_header->ip_dst)) &&
									(it->second->get_original_peer_port() == ntohs(udp_header->th_dport)))
								{
									packet_action = it->second->process_out_packet(buffer);
								}
								else
								{
									lock.unlock();
									if (query_remote_peer_ != nullptr)
									{
										if (auto [address, port, context] = query_remote_peer_(
											ip_header->ip_src, ntohs(udp_header->th_sport), ip_header->ip_dst,
											ntohs(udp_header->th_dport)); port != 0)
										{
											std::lock_guard<std::shared_mutex> guard_lock(*lock_);
											proxy_sockets_[ntohs(udp_header->th_sport)] =
												std::make_unique<T>(
													packet_filter_.get(),
													ntohs(udp_header->th_sport),
													address,
													port,
													ip_header->ip_dst,
													ntohs(udp_header->th_dport),
													std::move(context));

											proxy_sockets_[ntohs(udp_header->th_sport)]->start(if_handle_, buffer);
											packet_action = proxy_sockets_[ntohs(udp_header->th_sport)]->
												process_out_packet(buffer);
										}
									}
								}
							}
						}
					}
					else if constexpr (std::is_same_v<address_type_t, net::ip_address_v6>)
					{
						if (ntohs(ether_header->h_proto) == ETH_P_IPV6)
						{
							const auto ip_header = reinterpret_cast<ipv6hdr_ptr>(ether_header + 1);

							if (auto [header, protocol] = net::ipv6_helper::find_transport_header(
								ip_header, buffer.m_Length - ETHER_HEADER_LENGTH); protocol == IPPROTO_UDP)
							{
								const auto udp_header = static_cast<udphdr_ptr>(header);

								std::shared_lock<std::shared_mutex> lock(*lock_);

								if (auto it = proxy_sockets_.find(ntohs(udp_header->th_sport)); (it != proxy_sockets_.
										end()) &&
									(it->second->get_original_peer_address() == address_type_t(ip_header->ip6_dst)) &&
									(it->second->get_original_peer_port() == ntohs(udp_header->th_dport)))
								{
									packet_action = it->second->process_out_packet(buffer);
								}
								else
								{
									lock.unlock();
									if (query_remote_peer_ != nullptr)
									{
										if (auto [address, port, context] = query_remote_peer_(
											ip_header->ip6_src, ntohs(udp_header->th_sport), ip_header->ip6_dst,
											ntohs(udp_header->th_dport)); port != 0)
										{
											std::lock_guard<std::shared_mutex> guard_lock(*lock_);
											proxy_sockets_[ntohs(udp_header->th_sport)] =
												std::make_unique<T>(
													packet_filter_.get(),
													ntohs(udp_header->th_sport),
													address,
													port,
													ip_header->ip6_dst,
													ntohs(udp_header->th_dport),
													std::move(context));

											proxy_sockets_[ntohs(udp_header->th_sport)]->start(if_handle_, buffer);
											packet_action = proxy_sockets_[ntohs(udp_header->th_sport)]->
												process_out_packet(buffer);
										}
									}
								}
							}
						}
					}
					return packet_action;
				});
		}

		bool update_network_configuration()
		{
			if (!packet_filter_->reconfigure())
			{
				print_log(log_level::info,
				          "udp_proxy_server::update_network_configuration: Failed to update WinpkFilter network interfaces");
			}

			auto& ndis_adapters = packet_filter_->get_interface_list();
			default_adapter_ = iphelper::network_config_info<udp_proxy_server>::get_best_interface(
				command_server_address_);

			if (!default_adapter_)
			{
				//log_printer_("wg_tunnel: Failed to figure out the route to the server \n");
				return false;
			}

			{
				std::ostringstream oss;
				oss << "udp_proxy_server::update_network_configuration: detected default interface " << default_adapter_
					->get_adapter_name() << std::endl;
				print_log(log_level::info, oss.str());
			}

			if (default_adapter_->get_if_type() != IF_TYPE_PPP)
			{
				if (auto it = std::find_if(ndis_adapters.cbegin(), ndis_adapters.cend(), [this](auto& ndis_adapter)
				{
					return (std::string::npos != ndis_adapter->get_internal_name().find(
						default_adapter_->get_adapter_name()));
				}); it != ndis_adapters.cend())
				{
					if_index_ = it - ndis_adapters.begin();
					if_handle_ = (*it)->get_adapter();
					mtu_ = default_adapter_->get_mtu();
					return true;
				}
			}
			else
			{
				if (auto it = std::find_if(ndis_adapters.cbegin(), ndis_adapters.cend(), [this](auto& ndis_adapter)
				{
					if (auto wan_info = ndis_adapter->get_ras_links(); wan_info)
					{
						if (auto ras_it = std::find_if(wan_info->cbegin(), wan_info->cend(), [this](auto& ras_link)
						{
							return default_adapter_->has_address(ras_link.ip_address);
						}); ras_it != wan_info->cend())
						{
							// Store the remote MAC address (as may have multiply RAS connections)
							remote_address_ = ras_it->remote_hw_address;
							return true;
						}
					}

					return false;
				}); it != ndis_adapters.cend())
				{
					if_index_ = it - ndis_adapters.begin();
					if_handle_ = (*it)->get_adapter();
					mtu_ = default_adapter_->get_mtu();
					return true;
				}
			}

			{
				std::ostringstream oss;
				oss <<
					"udp_proxy_server::update_network_configuration: Failed to find a matching WinpkFilter interface for the "
					<< default_adapter_->get_adapter_name() << std::endl;
				print_log(log_level::info, oss.str());
			}

			return false;
		}

		void ip_interface_changed_callback(PMIB_IPINTERFACE_ROW row, MIB_NOTIFICATION_TYPE notification_type)
		{
			auto adapter = iphelper::network_config_info<udp_proxy_server>::get_best_interface(command_server_address_);

			if (!adapter && (status_ != proxy_status::stopping) && (status_ != proxy_status::stopped))
			{
				if (stop_internal())
				{
					default_adapter_ = adapter;
					print_log(log_level::info,
					          "udp_proxy_server::ip_interface_changed_callback: Internet is unreachable. Proxy is stopped.");
				}
				return;
			}

			if (*adapter == *default_adapter_ && adapter->is_same_address_info < false > (*default_adapter_))
			{
				// nothing has changed, no reaction needed
				return;
			}

			if (auto result = stop_internal(); result && (result.value() == proxy_status::stopped))
			{
				print_log(log_level::info,
				          "udp_proxy_server::ip_interface_changed_callback: UDP proxy was stopped successfully.");
			}

			if (auto result = start_internal(); result && (result.value() == proxy_status::started))
			{
				print_log(log_level::info,
				          "udp_proxy_server::ip_interface_changed_callback: UDP proxy was started successfully.");
			}
		}

		void print_log(const log_level level, const std::string& message) const
		{
			if ((level < log_level_) && log_printer_)
			{
				log_printer_(message.c_str());
			}
		}

		/// <summary>guards proxy_sockets_ access</summary>
		std::unique_ptr<std::shared_mutex> lock_;

		/// <summary>keep alive thread object</summary>
		std::thread keep_alive_thread_;

		/// <summary>maps local UDP port to proxy socket object</summary>
		std::unordered_map<uint16_t, std::unique_ptr<T>> proxy_sockets_;

		/// <summary>routine provided by the client to supply the information for proxy socket creation</summary>
		std::function<query_remote_peer_t> query_remote_peer_;

		/// <summary>packet filter object</summary>
		std::unique_ptr<simple_packet_filter> packet_filter_;

		/// <summary>list of available network interfaces</summary>
		std::vector<std::unique_ptr<network_adapter>> network_interfaces_;

		/// <summary>filtered adapter</summary>
		std::optional<iphelper::network_adapter_info> default_adapter_{};

		/// <summary>default network interface MTU</summary>
		uint16_t mtu_{MAX_ETHER_FRAME};

		/// <summary>default network interface adapter index</summary>
		size_t if_index_{};

		/// <summary>default network interface adapter handle</summary>
		HANDLE if_handle_{nullptr};

		/// <summary>this address is used to figure out the default interface</summary>
		address_type_t command_server_address_;

		/// <summary>log printer</summary>
		std::function<void(const char*)> log_printer_{};

		/// <summary>logging level for the log printer</summary>
		log_level log_level_{log_level::all};

		/// <summary>Current status of the proxy</summary>
		std::atomic<proxy_status> status_{proxy_status::stopped};

		/// <summary>remote hardware address for the RAS connection</summary>
		std::optional<net::mac_address> remote_address_{};
	};
}

```

`examples/cpp/common/net/ip_address.h`:

```h
// --------------------------------------------------------------------------------
/// <summary>
/// Module Name:  ip_address.h
/// Abstract: IP address wrappers definitions
/// </summary>
// --------------------------------------------------------------------------------

#pragma once

#include <in6addr.h>
#include <ip2string.h>
#include <cassert>

#pragma comment(lib, "ntdll.lib")

#pragma warning( push )
#pragma warning( disable : 26490 ) // disable reinterpret_cast warning

namespace net
{
	// --------------------------------------------------------------------------------
	/// <summary>
	/// Wrapper for in_addr. Represents IP version 4 address.
	/// </summary>
	// --------------------------------------------------------------------------------
	struct ip_address_v4 : in_addr
	{
		/// <summary>
		/// Maximum size of IPv4 address string representation
		/// </summary>
		static constexpr size_t ipv4_address_max_length = 16;

		/// <summary>
		/// IPv4 address family
		/// </summary>
		static constexpr ADDRESS_FAMILY af_type = AF_INET;

		/// <summary>
		/// Constructs from 32 bit unsigned (by default initializes to 0.0.0.0).
		/// </summary>
		/// <param name="address">IPv4 address as unsigned 32 bit in network byte order</param>
		explicit constexpr ip_address_v4(const uint32_t address = 0) noexcept: in_addr() { S_un.S_addr = address; }

		/// <summary>
		/// Constructs object from in_addr.
		/// </summary>
		/// <param name="ip">IPv4 address as in_addr</param>
		// ReSharper disable once CppNonExplicitConvertingConstructor
		ip_address_v4(const in_addr& ip) noexcept: in_addr(ip)
		{
		}

		/// <summary>
		/// Constructs from std::string if possible to parse
		/// </summary>
		/// <param name="ip">IPv4 address represented as std::string</param>
		explicit ip_address_v4(const std::string& ip) noexcept: in_addr()
		{
			PCSTR terminator = nullptr;

			[[maybe_unused]] const auto result = RtlIpv4StringToAddressA(ip.c_str(), TRUE, &terminator, this);
		}

		/// <summary>
		/// Constructs from std::wstring if possible to parse
		/// </summary>
		/// <param name="ip">IPv4 address represented as std::wstring</param>
		explicit ip_address_v4(const std::wstring& ip) noexcept: in_addr()
		{
			LPCWSTR terminator = nullptr;

			[[maybe_unused]] const auto result = RtlIpv4StringToAddressW(ip.c_str(), TRUE, &terminator, this);
		}

		/// <summary>
		/// Converts IPv4 address to the string representation
		/// </summary>
		explicit operator std::string() const
		{
			std::vector<char> ip_vec(ipv4_address_max_length, 0);
			RtlIpv4AddressToStringA(this, &gsl::at(ip_vec, 0));

			return {&gsl::at(ip_vec, 0)};
		}

		/// <summary>
		/// Converts IPv4 address to the wide char string representation
		/// </summary>
		explicit operator std::wstring() const
		{
			std::vector<wchar_t> ip_vec(ipv4_address_max_length, 0);
			RtlIpv4AddressToStringW(this, &gsl::at(ip_vec, 0));

			return {&gsl::at(ip_vec, 0)};
		}

		/// <summary>
		/// Attempts to parse std::string and create ip_address_v4 object value
		/// </summary>
		/// <param name="ip">IPv4 address represented as std::string</param>
		/// <returns>pair of boolean and ip_address_v4, if boolean is true</returns>
		static std::pair<bool, ip_address_v4> from_string(const std::string& ip) noexcept
		{
			PCSTR terminator = nullptr;
			ip_address_v4 address{};

			[[maybe_unused]] const auto result = RtlIpv4StringToAddressA(ip.c_str(), TRUE, &terminator, &address);

			return {0 == result, address};
		}

		/// <summary>
		/// Attempts to parse std::wstring and create ip_address_v4 object value
		/// </summary>
		/// <param name="ip">IPv4 address represented as std::wstring</param>
		/// <returns>pair of boolean and ip_address_v4, if boolean is true</returns>
		static std::pair<bool, ip_address_v4> from_wstring(const std::wstring& ip) noexcept
		{
			LPCWSTR terminator = nullptr;
			ip_address_v4 address{};

			[[maybe_unused]] const auto result = RtlIpv4StringToAddressW(ip.c_str(), TRUE, &terminator, &address);

			return {0 == result, address};
		}

		/// <summary>
		/// Equality operator (compares as 32 bit unsigned in network byte order)
		/// </summary>
		/// <param name="rhs">Value reference to compare to</param>
		/// <returns>true if equal</returns>
		bool operator ==(const ip_address_v4& rhs) const noexcept { return (S_un.S_addr == rhs.S_un.S_addr); }

		/// <summary>
		/// Non-equality operator (compares as 32 bit unsigned in network byte order)
		/// </summary>
		/// <param name="rhs">Value reference to compare to</param>
		/// <returns>true if non-equal</returns>
		bool operator !=(const ip_address_v4& rhs) const noexcept { return (S_un.S_addr != rhs.S_un.S_addr); }

		/// <summary>
		/// Less operator (compares as 32 bit unsigned in network byte order)
		/// </summary>
		/// <param name="rhs">Value reference to compare to</param>
		/// <returns>true if less</returns>
		bool operator <(const ip_address_v4& rhs) const noexcept { return (S_un.S_addr < rhs.S_un.S_addr); }

		/// <summary>
		/// Checks if contains an IPv4 auto-configuration address(169.254.xxx.xxx)
		/// </summary>
		/// <returns>true if assigned IPv4 is auto-configuration address</returns>
		[[nodiscard]] bool is_auto_config() const noexcept
		{
			if (S_un.S_un_b.s_b1 == 169 && S_un.S_un_b.s_b2 == 254)
				return true;

			return false;
		}

		/// <summary>
		/// Char stream output operator
		/// </summary>
		/// <param name="os">stream instance reference</param>
		/// <param name="dt">ip_address_v4 value</param>
		/// <returns>stream instance reference</returns>
		friend std::ostream& operator<<(std::ostream& os, const ip_address_v4& dt);

		/// <summary>
		/// Wide char stream output operator
		/// </summary>
		/// <param name="os">stream instance reference</param>
		/// <param name="dt">ip_address_v4 value</param>
		/// <returns>stream instance reference</returns>
		friend std::wostream& operator<<(std::wostream& os, const ip_address_v4& dt);
	};

	inline std::ostream& operator<<(std::ostream& os, const ip_address_v4& dt)
	{
		os << std::string(dt);
		return os;
	}

	inline std::wostream& operator<<(std::wostream& os, const ip_address_v4& dt)
	{
		os << std::wstring(dt);
		return os;
	}

	// --------------------------------------------------------------------------------
	/// <summary>
	/// Wrapper for in_addr6. Represents IP version 6 address.
	/// </summary>
	// --------------------------------------------------------------------------------
	struct ip_address_v6 : in6_addr
	{
		/// <summary>
		/// Maximum size of IPv6 address string representation
		/// </summary>
		static constexpr size_t ipv6_address_max_string_length = 48;

		/// <summary>
		/// Size of IPv6 address in bytes
		/// </summary>
		static constexpr size_t ipv6_address_max_length = 16;

		/// <summary>
		/// IPv6 address family
		/// </summary>
		static constexpr ADDRESS_FAMILY af_type = AF_INET6;

		/// <summary>
		/// Constructs zero IPv6 address
		/// </summary>
		constexpr ip_address_v6() noexcept : in6_addr()
		{
			this->u.Word[0] = 0;
			this->u.Word[1] = 0;
			this->u.Word[2] = 0;
			this->u.Word[3] = 0;
			this->u.Word[4] = 0;
			this->u.Word[5] = 0;
			this->u.Word[6] = 0;
			this->u.Word[7] = 0;
		}

		/// <summary>
		/// Constructs IPv6 address from the provided byte array
		/// </summary>
		/// <param name="address">16 bytes array</param>
		explicit ip_address_v6(const uint8_t (&address)[ipv6_address_max_length]) noexcept: in6_addr()
		{
			memmove(this, address, sizeof(in_addr6));
		}

		/// <summary>
		/// Constructs IPv6 address from in_addr6
		/// </summary>
		/// <param name="ip">in_addr6 object reference</param>
		// ReSharper disable once CppNonExplicitConvertingConstructor
		ip_address_v6(const in_addr6& ip) noexcept : in6_addr(ip)
		{
		}

		/// <summary>
		/// Constructs IPv6 address from std::string representation
		/// </summary>
		/// <param name="ip">IPv6 address in string representation</param>
		explicit ip_address_v6(const std::string& ip) noexcept : in6_addr()
		{
			PCSTR terminator = nullptr;

			[[maybe_unused]] const auto result = RtlIpv6StringToAddressA(ip.c_str(), &terminator, this);

			assert(0 == result);
		}

		/// <summary>
		/// Constructs IPv6 address from std::wstring representation
		/// </summary>
		/// <param name="ip">IPv6 address in wide char string representation</param>
		explicit ip_address_v6(const std::wstring& ip) noexcept : in6_addr()
		{
			LPCWSTR terminator = nullptr;

			[[maybe_unused]] const auto result = RtlIpv6StringToAddressW(ip.c_str(), &terminator, this);

			assert(0 == result);
		}

		/// <summary>
		/// Converts IPv6 address into the string representation
		/// </summary>
		explicit operator std::string() const
		{
			std::vector<char> ip_vec(ipv6_address_max_string_length, 0);
			RtlIpv6AddressToStringA(this, &gsl::at(ip_vec, 0));

			return {&gsl::at(ip_vec, 0)};
		}

		/// <summary>
		/// Converts IPv6 address into the wide char string representation
		/// </summary>
		explicit operator std::wstring() const
		{
			std::vector<wchar_t> ip_vec(ipv6_address_max_string_length, 0);
			RtlIpv6AddressToStringW(this, &gsl::at(ip_vec, 0));

			return {&gsl::at(ip_vec, 0)};
		}

		/// <summary>
		/// Tries to parse IPv6 address string to ip_address_v6
		/// </summary>
		/// <param name="ip">IPv6 address represented as std::string</param>
		/// <returns>pair of boolean and ip_address_v6, if boolean is true</returns>
		static std::pair<bool, ip_address_v6> from_string(const std::string& ip) noexcept
		{
			PCSTR terminator = nullptr;
			ip_address_v6 address{};

			[[maybe_unused]] const auto result = RtlIpv6StringToAddressA(ip.c_str(), &terminator, &address);

			return {0 == result, address};
		}

		/// <summary>
		/// Tries to parse IPv6 address wide char string to ip_address_v6
		/// </summary>
		/// <param name="ip">IPv6 address represented as std::wstring</param>
		/// <returns>pair of boolean and ip_address_v6, if boolean is true</returns>
		static std::pair<bool, ip_address_v6> from_wstring(const std::wstring& ip) noexcept
		{
			LPCWSTR terminator = nullptr;
			ip_address_v6 address{};

			[[maybe_unused]] const auto result = RtlIpv6StringToAddressW(ip.c_str(), &terminator, &address);

			return {0 == result, address};
		}

		/// <summary>
		/// Equality operator (compares as array of bytes)
		/// </summary>
		/// <param name="rhs">Value reference to compare to</param>
		/// <returns>true if equal</returns>
		bool operator ==(const ip_address_v6& rhs) const noexcept
		{
			return !memcmp(this, &rhs, sizeof(ip_address_v6));
		}

		/// <summary>
		/// Non-equality operator (compares as array of bytes)
		/// </summary>
		/// <param name="rhs">Value reference to compare to</param>
		/// <returns>true if non-equal</returns>
		bool operator !=(const ip_address_v6& rhs) const noexcept
		{
			return memcmp(this, &rhs, sizeof(ip_address_v6));
		}

		/// <summary>
		/// Less operator (compares as array of bytes)
		/// </summary>
		/// <param name="rhs">Value reference to compare to</param>
		/// <returns>true if less</returns>
		bool operator <(const ip_address_v6& rhs) const noexcept { return (memcmp(this, &rhs, sizeof(in_addr6)) < 0); }

		/// <summary>
		/// Calculates 32 bit hash from IPv6 address
		/// </summary>
		explicit operator uint32_t() const noexcept
		{
			const auto sp = gsl::span(reinterpret_cast<const uint32_t*>(this), 4);
			return sp[0] ^ sp[1] ^ sp[2] ^ sp[3];
		}

		/// <summary>
		/// Checks if IPv6 address is global unicast
		/// </summary>
		/// <returns>true if IPv6 address is global unicast</returns>
		[[nodiscard]] bool is_global_unicast() const noexcept
		{
			return ((u.Byte[0] & 0x3F) == u.Byte[0]);
		}

		/// <summary>
		/// Char stream output operator
		/// </summary>
		/// <param name="os">stream instance reference</param>
		/// <param name="dt">ip_address_v6 value</param>
		/// <returns>stream instance reference</returns>
		friend std::ostream& operator<<(std::ostream& os, const ip_address_v6& dt);

		/// <summary>
		/// Wide char stream output operator
		/// </summary>
		/// <param name="os">stream instance reference</param>
		/// <param name="dt">ip_address_v6 value</param>
		/// <returns>stream instance reference</returns>
		friend std::wostream& operator<<(std::wostream& os, const ip_address_v6& dt);
	};

	inline std::ostream& operator<<(std::ostream& os, const ip_address_v6& dt)
	{
		os << std::string(dt);
		return os;
	}

	inline std::wostream& operator<<(std::wostream& os, const ip_address_v6& dt)
	{
		os << std::wstring(dt);
		return os;
	}

	/// <summary>
	/// Zero value IPv4 address
	/// </summary>
	static constexpr ip_address_v4 zero_ip_address_v4;

	/// <summary>
	/// Zero value IPv6 address
	/// </summary>
	static constexpr ip_address_v6 zero_ip_address_v6;
}

namespace std
{
	/// <summary>
	/// Hash for net::ip_address_v6
	/// </summary>
	template <>
	struct hash<net::ip_address_v6>
	{
		using argument_type = net::ip_address_v6;
		using result_type = size_t;

		result_type operator()(const argument_type& ip) const noexcept
		{
			const auto h1(std::hash<uint32_t>{}(static_cast<uint32_t>(ip)));

			return h1;
		}
	};

	/// <summary>
	/// Hash for net::ip_address_v4
	/// </summary>
	template <>
	struct hash<net::ip_address_v4>
	{
		using argument_type = net::ip_address_v4;
		using result_type = size_t;

		result_type operator()(const argument_type& ip) const noexcept
		{
			const auto h1(std::hash<uint32_t>{}(ip.S_un.S_addr));

			return h1;
		}
	};
}

#pragma warning( pop )

```

`examples/cpp/common/net/ip_endpoint.h`:

```h
#pragma once

namespace net
{
	// --------------------------------------------------------------------------------
	/// <summary>
	/// Represents IPv4 TCP/UDP endpoint
	/// </summary>
	/// <typeparam name="T">net::ip_address_v4 or net::ip_address_v6</typeparam>
	// --------------------------------------------------------------------------------
	template <typename T>
	struct ip_endpoint
	{
		/// <summary>
		/// Default constructor
		/// </summary>
		ip_endpoint() = default;

		/// <summary>
		/// Constructs endpoint from provided IP address and port
		/// </summary>
		/// <param name="ip"></param>
		/// <param name="port"></param>
		ip_endpoint(const T& ip, const unsigned short port) : ip(ip), port(port)
		{
		}

		/// <summary>
		/// Returns endpoint IP address as string
		/// </summary>
		/// <returns>endpoint IP address as string</returns>
		[[nodiscard]] std::string ip_to_string() const noexcept { return std::string(ip); }

		/// <summary>
		/// Returns endpoint port as string
		/// </summary>
		/// <returns>endpoint port as string</returns>
		[[nodiscard]] std::string port_to_string() const noexcept { return std::to_string(port); }

		/// <summary>
		/// Returns endpoint as string (e.g. '192.168.1.1:443')
		/// </summary>
		/// <returns>endpoint as string</returns>
		[[nodiscard]] std::string to_string() const noexcept { return ip_to_string() + ":" + port_to_string(); }

		/// <summary>
		/// Equality operator
		/// </summary>
		/// <param name="rhs">endpoint to compare to</param>
		/// <returns>true if endpoints are equal</returns>
		bool operator ==(const ip_endpoint& rhs) const noexcept{ return (ip == rhs.ip) && (port == rhs.port); }

		/// <summary>
		/// Non-equality operator
		/// </summary>
		/// <param name="rhs">endpoint to compare to</param>
		/// <returns>true if endpoints are not equal</returns>
		bool operator !=(const ip_endpoint& rhs) const { return (ip != rhs.ip) || (port != rhs.port); }

		/// <summary>
		/// Endpoint IP address
		/// </summary>
		T ip;

		/// <summary>
		/// Endpoint port value
		/// </summary>
		uint16_t port{0};
	};

	// --------------------------------------------------------------------------------
	/// <summary>
	/// Represents IPv4 TCP/UDP session
	/// </summary>
	/// <typeparam name="T">net::ip_address_v4 or net::ip_address_v6</typeparam>
	// --------------------------------------------------------------------------------
	template <typename T>
	struct ip_session
	{
		/// <summary>
		/// Constructs object from provided local and remote IP addresses and ports
		/// </summary>
		/// <param name="local_ip">local IP address</param>
		/// <param name="remote_ip">remote IP address</param>
		/// <param name="local_port">local port</param>
		/// <param name="remote_port">remote port</param>
		ip_session(
			const T& local_ip,
			const T& remote_ip,
			const unsigned short local_port,
			const unsigned short remote_port) :
			local(local_ip, local_port),
			remote(remote_ip, remote_port)
		{
		}

		/// <summary>
		/// Constructs object from provided local and remote endpoints
		/// </summary>
		/// <param name="local_endpoint">local endpoint</param>
		/// <param name="remote_endpoint">remote endpoint</param>
		ip_session(
			const ip_endpoint<T>& local_endpoint,
			const ip_endpoint<T>& remote_endpoint) :
			local{local_endpoint},
			remote{remote_endpoint}
		{
		}

		/// <summary>
		/// Equality operator for ip_session
		/// </summary>
		/// <param name="rhs">ip_session to compare to</param>
		/// <returns>true if endpoints are equal</returns>
		bool operator ==(const ip_session& rhs) const noexcept { return (local == rhs.local) && (remote == rhs.remote); }

		/// <summary>
		/// Non-equality operator for ip_session
		/// </summary>
		/// <param name="rhs">ip_session to compare to</param>
		/// <returns>true if endpoints are not equal</returns>
		bool operator !=(const ip_session& rhs) const { return (local != rhs.local) || (remote != rhs.remote); }

		/// <summary>
		/// Local endpoint
		/// </summary>
		ip_endpoint<T> local;

		/// <summary>
		/// Remote endpoint
		/// </summary>
		ip_endpoint<T> remote;
	};
}

namespace std
{
	/// <summary>
	/// Hash function for ip_endpoint
	/// </summary>
	/// <typeparam name="T">net::ip_address_v4 or net::ip_address_v6</typeparam>
	template <typename T>
	struct hash<net::ip_endpoint<T>>
	{
		using argument_type = net::ip_endpoint<T>;
		using result_type = std::size_t;

		result_type operator()(const argument_type& endpoint) const noexcept
		{
			const auto h1(std::hash<std::size_t>{}(
				std::hash<T>{}(endpoint.ip) ^
				static_cast<unsigned long>(endpoint.port)
			));

			return h1;
		}
	};

	/// <summary>
	/// Hash for ip_session
	/// </summary>
	/// <typeparam name="T">net::ip_address_v4 or net::ip_address_v6</typeparam>
	template <typename T>
	struct hash<net::ip_session<T>>
	{
		using argument_type = net::ip_session<T>;
		using result_type = std::size_t;

		result_type operator()(const argument_type& endpoint) const noexcept
		{
			const auto h1(std::hash<std::size_t>{}(
				std::hash<net::ip_endpoint<T>>{}(endpoint.local) ^
				static_cast<unsigned long>(endpoint.local.port) ^
				std::hash<net::ip_endpoint<T>>{}(endpoint.remote) ^
				static_cast<unsigned long>(endpoint.remote.port)
			));

			return h1;
		}
	};
}

```

`examples/cpp/common/net/ip_subnet.h`:

```h
#pragma once

namespace net
{
	/// <summary>
	/// Represents IPv4/IPv6 subnet
	/// </summary>
	/// <typeparam name="T">net::ip_address_v4 or net::ip_address_v6</typeparam>
	template <typename T>
	struct ip_subnet
	{
		// --------------------------------------------------------------------------------
		/// <summary>
		/// Helper struct for IPv6 calculations
		/// </summary>
		// --------------------------------------------------------------------------------
		struct ip6_addr
		{
			union
			{
				uint8_t byte[16];
				uint16_t word[8];
				uint32_t dword[4];
				uint64_t qword[2];
			} u;
		};

		/// <summary>
		/// IP subnet address
		/// </summary>
		T address;

		/// <summary>
		/// IP subnet network mask
		/// </summary>
		T mask;

		/// <summary>
		/// Default constructor
		/// </summary>
		ip_subnet() = default;

		/// <summary>
		/// Constructs single IP subnet from IP address (192.168.1.1/32 or 2001::1/128)
		/// </summary>
		/// <param name="ip">IP address to create the subnet</param>
		explicit ip_subnet(const T& ip) : address(ip) { memset(reinterpret_cast<char*>(&mask), 0xFF, sizeof(T)); }

		/// <summary>
		/// Constructs single IP subnet from IP address string representation (192.168.1.1/32 or 2001::1/128)
		/// </summary>
		/// <param name="ip">string with IP address to create the subnet</param>
		explicit ip_subnet(const std::string& ip) : address(ip)
		{
			memset(reinterpret_cast<char*>(&mask), 0xFF, sizeof(T));
		}

		/// <summary>
		/// Constructs single IP subnet from IP address wide char string representation (192.168.1.1/32 or 2001::1/128)
		/// </summary>
		/// <param name="ip">wide char string with IP address to create the subnet</param>
		explicit ip_subnet(const std::wstring& ip) : address(ip)
		{
			memset(reinterpret_cast<char*>(&mask), 0xFF, sizeof(T));
		}

		/// <summary>
		/// Constructs object from provided IP address and mask
		/// </summary>
		/// <param name="ip">subnet IP address</param>
		/// <param name="mask">subnet network mask</param>
		ip_subnet(const T& ip, const T& mask) : address(ip), mask(mask)
		{
		}

		/// <summary>
		/// Constructs object from provided IP address and mask strings
		/// </summary>
		/// <param name="ip">string with subnet IP address</param>
		/// <param name="mask">string with subnet network mask</param>
		ip_subnet(const std::string& ip, const std::string& mask) : address(ip), mask(mask)
		{
		}

		/// <summary>
		/// Constructs object from provided IP address and mask wide char strings
		/// </summary>
		/// <param name="ip">wide char string with subnet IP address</param>
		/// <param name="mask">wide char string with subnet network mask</param>
		ip_subnet(const std::wstring& ip, const std::wstring& mask) : address(ip), mask(mask)
		{
		}

		/// <summary>
		/// Gets subnet address
		/// </summary>
		/// <returns>subnet IP address</returns>
		[[nodiscard]] T get_address() const { return address; }

		/// <summary>
		/// Gets subnet network mask
		/// </summary>
		/// <returns>subnet network mask</returns>
		[[nodiscard]] T get_mask() const { return mask; }

		/// <summary>
		/// Gets subnet mask as network prefix
		/// </summary>
		/// <returns></returns>
		[[nodiscard]] uint8_t get_prefix() const
		{
			if constexpr (std::is_same_v<std::decay_t<T>, ip_address_v6>)
			{
				auto ip_subnet_mask_ptr = reinterpret_cast<const ip6_addr*>(&mask);
				return static_cast<uint8_t>(std::bitset<32>(ip_subnet_mask_ptr->u.dword[0]).count() + std::bitset<
						32>(ip_subnet_mask_ptr->u.dword[1]).count() +
					std::bitset<32>(ip_subnet_mask_ptr->u.dword[2]).count() + std::bitset<32>(ip_subnet_mask_ptr
						->u.dword[3]).count());
			}
			else if constexpr (std::is_same_v<std::decay_t<T>, ip_address_v4>)
			{
				const auto ip_subnet_mask_ptr = reinterpret_cast<const in_addr*>(&mask);
				return static_cast<uint8_t>(std::bitset<32>(ip_subnet_mask_ptr->S_un.S_addr).count());
			}
			return 0;
		}

		/// <summary>
		/// Gets string representation of subnet as IP/prefix (e.g. '192.168.1.0/24')
		/// </summary>
		explicit operator std::string() const
		{
			return std::string(get_address()) + "/" + std::to_string(get_prefix());
		}

		/// <summary>
		/// Gets wide char string representation of subnet as IP/prefix (e.g. '192.168.1.0/24')
		/// </summary>
		explicit operator std::wstring() const
		{
			return std::wstring(get_address()) + L"/" + std::to_wstring(get_prefix());
		}

		/// <summary>
		/// Equality operator for ip_subnet
		/// </summary>
		/// <param name="rhs">value to compare to</param>
		/// <returns>true if subnets are equal</returns>
		bool operator ==(const ip_subnet<T>& rhs) const { return (address == rhs.address) && (mask == rhs.mask); }

		/// <summary>
		/// Checks if specified IP address belongs to this subnet
		/// </summary>
		/// <param name="ip">IP address to check</param>
		/// <returns>true if specified IP address belongs to this subnet</returns>
		[[nodiscard]] bool address_in_subnet(T ip) const
		{
			if constexpr (std::is_same_v<std::decay_t<T>, ip_address_v6>)
			{
				auto ip_ptr = reinterpret_cast<ip6_addr*>(&ip);
				auto ip_subnet_ptr = reinterpret_cast<const ip6_addr*>(this);

				if (auto ip_subnet_mask_ptr = reinterpret_cast<const ip6_addr*>(&mask); ((ip_ptr->u.qword[0] &
						ip_subnet_mask_ptr->u.qword[0]) == (ip_subnet_ptr->u.qword[0] &
						ip_subnet_mask_ptr->u.qword[0])) &&
					((ip_ptr->u.qword[1] & ip_subnet_mask_ptr->u.qword[1]) == (ip_subnet_ptr->u.qword[1] &
						ip_subnet_mask_ptr->u.qword[1])))
					return true;
			}
			else if constexpr (std::is_same_v<std::decay_t<T>, ip_address_v4>)
			{
				const auto ip_ptr = reinterpret_cast<in_addr*>(&ip);
				const auto ip_subnet_ptr = reinterpret_cast<const in_addr*>(this);

				if (const auto ip_subnet_mask_ptr = reinterpret_cast<const in_addr*>(&mask); (ip_ptr->S_un.S_addr &
					ip_subnet_mask_ptr->S_un.S_addr) == (ip_subnet_ptr->S_un.S_addr &
					ip_subnet_mask_ptr->S_un.S_addr))
					return true;
			}

			return false;
		}

		static std::optional<ip_subnet<T>> from_cidr(const std::string& subnet)
		{
			if (const auto pos = subnet.find('/'); pos != std::string::npos)
			{
				if constexpr (std::is_same_v<T, net::ip_address_v4>)
				{
					if (const auto [result_v4, address_v4] = ip_address_v4::from_string(subnet.substr(0, pos));
						result_v4)
					{
						uint8_t mask = 0;

						if (auto [p, ec] = std::from_chars(subnet.data() + pos + 1, subnet.data() + subnet.size(), mask); ec ==
							std::errc())
						{
							if (mask <= 32)
							{
								uint32_t net_mask = 0;
								while (mask--)
								{
									net_mask >>= 1;
									net_mask = net_mask | 0x80000000;
								}

								return { net::ip_subnet{
									address_v4, ip_address_v4(htonl(net_mask))
								} };
							}
						}
					}
				}
				else
				{
					if (const auto [result_v6, address_v6] = net::ip_address_v6::from_string(subnet.substr(0, pos));
						result_v6)
					{
						uint8_t mask = 0;

						if (auto [p, ec] = std::from_chars(subnet.data() + pos + 1, subnet.data() + subnet.size(), mask); ec ==
							std::errc())
						{
							if (mask <= 128)
							{
								uint8_t address_mask[ip_address_v6::ipv6_address_max_length] = { 0 };

								const auto maxed_bytes = mask / 8;
								auto last_byte_bits = mask % 8;

								uint8_t net_mask = 0;
								while (last_byte_bits--)
								{
									net_mask >>= 1;
									net_mask = net_mask | 0x80;
								}

								memset(&address_mask[0], 0xFF, maxed_bytes);

								if (maxed_bytes < 16)
									gsl::at(address_mask, maxed_bytes) = net_mask;

								return { net::ip_subnet{
									address_v6, ip_address_v6(address_mask)
								} };
							}
						}
					}
				}
			}
			else
			{
				if constexpr (std::is_same_v<T, net::ip_address_v4>)
				{
					if (const auto [result_v4, address_v4] = ip_address_v4::from_string(subnet);
						result_v4)
					{
						return { net::ip_subnet{
							address_v4, ip_address_v4("255.255.255.255") } };
					}
				}
				else
				{
					if (const auto [result_v6, address_v6] = net::ip_address_v6::from_string(subnet);
						result_v6)
					{
						constexpr uint8_t address_mask[net::ip_address_v6::ipv6_address_max_length] =
						{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };

						return { net::ip_subnet{
							address_v6, ip_address_v6(address_mask) } };
					}
				}
			}
			return {};
		}
	};
}

```

`examples/cpp/common/net/ipv6_helper.h`:

```h
#pragma once

#pragma warning( push )
#pragma warning( disable : 26490 ) // disable reinterpret_cast warning

namespace net
{
	/// <summary>
	/// IPv6 helper functions for parsing IPv6 headers, checksum and etc..
	/// </summary>
	struct ipv6_helper
	{
		// ********************************************************************************
		/// <summary>
		/// Parses IP headers until the transport payload
		/// </summary>
		/// <param name="ip_header">pointer to IP header</param>
		/// <param name="packet_size">size of IP packet in octets</param>
		/// <returns>pointer to IP packet payload (TCP, UDP, ICMPv6 and etc..) and protocol value</returns>
		// ********************************************************************************
		static std::pair<void*, unsigned char> find_transport_header(
			const ipv6hdr* ip_header,
			const unsigned packet_size
		) noexcept
		{
			unsigned char next_proto = 0;
			void* the_header = nullptr;

			//
			// Parse IPv6 headers
			//

			// Check if this IPv6 packet
			if (ip_header->ip6_v != 6)
			{
				return {nullptr, next_proto};
			}

			// Find the first header
			next_proto = ip_header->ip6_next;
			auto* next_header = reinterpret_cast<const ipv6ext*>(ip_header + 1);

			// Loop until we find the last IP header
			while (true)
			{
				// Ensure that current header is still within the packet
				if (reinterpret_cast<const char*>(next_header) > reinterpret_cast<const char*>(ip_header) + packet_size - sizeof(
					ipv6ext))
				{
					return {nullptr, next_proto};
				}

				switch (next_proto)
				{
					// Fragmentation
				case IPPROTO_FRAGMENT:
					{
						const auto frag = reinterpret_cast<const ipv6ext_frag*>(next_header);

						// If this isn't the FIRST fragment, there won't be a TCP/UDP header anyway
						if ((frag->ip6_offlg & 0xFC) != 0)
						{
							// The offset is non-zero
							next_proto = frag->ip6_next;

							return {nullptr, next_proto};
						}

						// Otherwise it's either an entire segment or the first fragment
						next_proto = frag->ip6_next;

						// Return next octet following the fragmentation header
						next_header = reinterpret_cast<const ipv6ext*>(reinterpret_cast<const char*>(next_header) + sizeof(
							ipv6ext_frag));

						return { const_cast<void*>(static_cast<const void*>(next_header)), next_proto };
					}

					// Headers we just skip over
				case IPPROTO_HOPOPTS:
				case IPPROTO_ROUTING:
				case IPPROTO_DSTOPTS:
					next_proto = next_header->ip6_next;

					// As per RFC 2460 : ip6ext_len specifies the extended
					// header length, in units of 8 octets *not including* the
					// first 8 octets.

					next_header = reinterpret_cast<const ipv6ext*>(reinterpret_cast<const char*>(next_header) + 8 + static_cast<ULONG_PTR>(next_header
						->ip6_len) * 8);
					break;

				default:
					// No more IPv6 headers to skip
					return { const_cast<void*>(static_cast<const void*>(next_header)), next_proto };
				}
			}
		}

		// ********************************************************************************
		/// <summary>
		/// Recalculates TCP/UDP checksum for IPv6 packet in INTERMEDIATE_BUFFER container 
		/// </summary>
		/// <param name="packet">pinter to INTERMEDIATE_BUFFER structure</param>
		// ********************************************************************************
		static void recalculate_tcp_udp_checksum(PINTERMEDIATE_BUFFER packet)
		{
			tcphdr_ptr tcp_header = nullptr;
			udphdr_ptr udp_header = nullptr;
			icmpv6hdr_ptr icmp_header = nullptr;

			const auto ipv6_header = reinterpret_cast<ipv6hdr_ptr>(&packet->m_IBuffer[ETHER_HEADER_LENGTH]);
			auto [header, protocol] = find_transport_header(ipv6_header, packet->m_Length - ETHER_HEADER_LENGTH);

			if (header == nullptr)
				return;

			if (protocol == IPPROTO_TCP)
			{
				tcp_header = static_cast<tcphdr_ptr>(header);
				tcp_header->th_sum = 0;
			}
			else if (protocol == IPPROTO_UDP)
			{
				udp_header = static_cast<udphdr_ptr>(header);
				udp_header->th_sum = 0;
			}
			else if (protocol == IPPROTO_ICMPV6)
			{
				icmp_header = static_cast<icmpv6hdr_ptr>(header);
				icmp_header->checksum = 0;
			}

			if (const auto checksum = tcp_udp_v6_checksum(
					&ipv6_header->ip6_src,
					&ipv6_header->ip6_dst,
					protocol,
					header,
					packet->m_Length - static_cast<uint32_t>(static_cast<uint8_t*>(header) - packet->m_IBuffer));
				protocol
				== IPPROTO_TCP)
			{
				tcp_header->th_sum = checksum;
			}
			else if (protocol == IPPROTO_UDP)
			{
				udp_header->th_sum = checksum;
			}
			else if (protocol == IPPROTO_ICMPV6)
			{
				icmp_header->checksum = checksum;
			}
		}

	private:
		/// <summary>
		/// Calculates partial IP checksum
		/// </summary>
		/// <param name="p">buffer pointer to calculate the checksum</param>
		/// <param name="len">length of data buffer</param>
		/// <param name="sum">pre-calculated checksum</param>
		/// <returns></returns>
		static uint64_t ip_checksum_partial(const void* p, size_t len, uint64_t sum)
		{
			/*Main loop: 32 bits at a time.
			We take advantage of intel's ability to do unaligned memory
			accesses with minimal additional cost. Other architectures
			probably want to be more careful here.*/

			auto p32 = static_cast<const uint32_t*>(p);
			for (; len >= sizeof(*p32); len -= sizeof(*p32))
				sum += *p32++;

			/*Handle un-32bit-aligned trailing bytes*/
			auto p16 = reinterpret_cast<const uint16_t*>(p32);
			if (len >= 2)
			{
				sum += *p16++;
				len -= sizeof(*p16);
			}
			if (len > 0)
			{
				const auto p8 = reinterpret_cast<const uint8_t*>(p16);
				sum += ntohs(*p8 << 8); /* RFC says pad last byte */
			}

			return sum;
		}

		/// <summary>
		/// Fold 64 bit checksum into 16 bit value
		/// </summary>
		/// <param name="sum"></param>
		/// <returns></returns>
		static uint16_t ip_checksum_fold(uint64_t sum)
		{
			while (sum & ~0xffffffffULL)
				sum = (sum >> 32) + (sum & 0xffffffffULL);
			while (sum & 0xffff0000ULL)
				sum = (sum >> 16) + (sum & 0xffffULL);

			return static_cast<uint16_t>(~sum);
		}

		/// <summary>
		/// Calculates partial (pseudo-header) TCP/UDP checksum
		/// </summary>
		/// <param name="src_ip">source IP address</param>
		/// <param name="dst_ip">destination IP address</param>
		/// <param name="protocol">IP protocol</param>
		/// <param name="len">length of the TCP/UDP packet including header</param>
		/// <returns>64 bit checksum value</returns>
		static uint64_t tcp_udp_v6_header_checksum_partial(const in6_addr* src_ip, const in6_addr* dst_ip,
		                                                   const uint8_t protocol, const uint32_t len)
		{
			/* The IPv6 pseudo-header is defined in RFC 2460, Section 8.1. */
			struct ipv6_pseudo_header_t
			{
				union
				{
					struct header
					{
						in6_addr src_ip;
						in6_addr dst_ip;
						uint32_t length;
						uint8_t mbz[3];
						uint8_t next_header;
					} fields;

					uint32_t words[10];
				};
			};

			ipv6_pseudo_header_t pseudo_header{};
			assert(sizeof(pseudo_header) == 40);

			/* Fill in the pseudo-header. */
			pseudo_header.fields.src_ip = *src_ip;
			pseudo_header.fields.dst_ip = *dst_ip;
			pseudo_header.fields.length = htonl(len);
			memset(pseudo_header.fields.mbz, 0, sizeof(pseudo_header.fields.mbz));
			pseudo_header.fields.next_header = protocol;
			return ip_checksum_partial(&pseudo_header, sizeof(pseudo_header), 0);
		}

		// ********************************************************************************
		/// <summary>
		/// Calculates TCP/UDP checksum for IPv6 packet. Current checksum in the packet 
		/// must be zeroed.
		/// </summary>
		/// <param name="src_ip">source IPv6 address</param>
		/// <param name="dst_ip">destination IPv6 address</param>
		/// <param name="protocol">network protocol</param>
		/// <param name="payload">pointer to transport header</param>
		/// <param name="len">length of the TCP/UDP packet including header</param>
		/// <returns>calculated checksum in network order</returns>
		// ********************************************************************************
		static uint16_t tcp_udp_v6_checksum(const struct in6_addr* src_ip, const struct in6_addr* dst_ip,
		                                    const uint8_t protocol, const void* payload, const uint32_t len)
		{
			auto sum = tcp_udp_v6_header_checksum_partial(src_ip, dst_ip, protocol, len);
			sum = ip_checksum_partial(payload, len, sum);
			return ip_checksum_fold(sum);
		}
	};
}

#pragma warning( pop )
```

`examples/cpp/common/net/mac_address.h`:

```h
#pragma once
#include <iomanip>
#include <sstream>

namespace net
{
	// --------------------------------------------------------------------------------
	/// <summary>
	/// Simple wrapper for hardware MAC address
	/// </summary>
	// --------------------------------------------------------------------------------
	struct mac_address
	{
		/// <summary>
		/// Hardware MAC address size
		/// </summary>
		static constexpr int eth_address_length = 6;

		/// <summary>
		/// MAC address storage
		/// </summary>
		std::array<unsigned char, eth_address_length> data{0};
		using size_type = std::array<unsigned char, eth_address_length>::size_type;

		/// <summary>
		/// Default constructor creates zero MAC address
		/// </summary>
		mac_address() = default;

		/// <summary>
		/// Constructs MAC address object from the provided bytes
		/// </summary>
		/// <param name="ptr">pointer to data buffer with MAC address</param>
		explicit mac_address(const unsigned char* ptr) noexcept { memmove(&data.at(0), ptr, eth_address_length); }

		/// <summary>
		/// Constructs MAC address by parsing its string representation
		/// </summary>
		/// <param name="address">MAC address represented as string, e.g. '01:02:03:04:05:06'</param>
		explicit mac_address(const std::string& address)
		{
			std::stringstream mss(address);
			std::string hex;
			std::vector<unsigned char> mac;
			while (getline(mss, hex, ':'))
			{
				std::stringstream hss(hex);
				unsigned int b;
				hss >> std::hex >> b;
				mac.push_back(static_cast<unsigned char>(b));
			}

			if (mac.size() == eth_address_length)
			{
				std::copy_n(mac.cbegin(), eth_address_length, data.begin());
			}
		}

		/// <summary>
		/// Index operator to retrieve MAC address byte reference by specifying its index
		/// </summary>
		/// <param name="index">index of MAC address array</param>
		/// <returns>modifiable MAC address byte reference by its index</returns>
		unsigned char& operator[](const size_type index) noexcept { return data.at(index); }

		/// <summary>
		/// Index operator to retrieve MAC address byte reference by specifying its index
		/// </summary>
		/// <param name="index">index of MAC address array</param>
		/// <returns>constant MAC address byte reference by its index</returns>
		const unsigned char& operator[](const size_type index) const noexcept { return data.at(index); }

		/// <summary>
		/// Equality operator
		/// </summary>
		/// <param name="rhs">MAC address to compare to</param>
		/// <returns>true is MAC addresses are equal</returns>
		bool operator ==(const mac_address& rhs) const
		{
			return data == rhs.data;
		}

		/// <summary>
		/// Non-equality operator
		/// </summary>
		/// <param name="rhs">MAC address to compare to</param>
		/// <returns>true is MAC addresses are non-equal</returns>
		bool operator !=(const mac_address& rhs) const
		{
			return !(*this == rhs);
		}

		/// <summary>
		/// Less operator (lexicographic)
		/// </summary>
		/// <param name="rhs">MAC address to compare to</param>
		/// <returns>true is MAC addresses is lexicographically less than specified</returns>
		bool operator <(const mac_address& rhs) const noexcept
		{
			return (memcmp(&data.at(0), &rhs.data.at(0), eth_address_length) < 0);
		}

		/// <summary>
		/// Checks if MAC address is zero initialized
		/// </summary>
		explicit operator bool() const { return *this != mac_address{}; }

		/// <summary>
		/// Returns MAC address as std::array
		/// </summary>
		explicit operator std::array<unsigned char, eth_address_length>() const noexcept { return data; }

		/// <summary>
		/// Template to_string conversion operator for MAC address
		/// </summary>
		template <typename T>
		explicit operator std::basic_string<T>() const
		{
			std::basic_ostringstream<T> oss;
			oss << std::hex
				<< std::uppercase
				<< std::setfill(T{'0'}) << std::setw(2)
				<< static_cast<unsigned>(data.at(0))
				<< std::setfill(T{'0'}) << std::setw(2)
				<< static_cast<unsigned>(data.at(1))
				<< std::setfill(T{'0'}) << std::setw(2)
				<< static_cast<unsigned>(data.at(2))
				<< std::setfill(T{'0'}) << std::setw(2)
				<< static_cast<unsigned>(data.at(3))
				<< std::setfill(T{'0'}) << std::setw(2)
				<< static_cast<unsigned>(data.at(4))
				<< std::setfill(T{'0'}) << std::setw(2)
				<< static_cast<unsigned>(data.at(5));
			return oss.str();
		}

		/// <summary>
		/// Reverses bytes in MAC address
		/// </summary>
		/// <returns>MAC address with reversed bytes order</returns>
		const mac_address& reverse()
		{
			std::reverse(data.begin(), data.end());
			return *this;
		}

		/// <summary>
		/// Checks if MAC address is broadcast
		/// </summary>
		/// <returns>true if broadcast</returns>
		[[nodiscard]] bool is_broadcast() const
		{
			auto broadcast = mac_address{};
			broadcast.data.fill(0xFF);
			if (broadcast == *this)
				return true;
			return false;
		}

		/// <summary>
		/// Checks if MAC address is multicast
		/// </summary>
		/// <returns>true if multicast</returns>
		[[nodiscard]] bool is_multicast() const noexcept
		{
			if ((data.at(0) & 0x01) == 0x01)
				return true;
			return false;
		}

		/// <summary>
		/// Get underlying storage reference
		/// </summary>
		/// <returns>underlying storage reference</returns>
		[[nodiscard]] std::array<unsigned char, eth_address_length>& get_data() noexcept
		{
			return data;
		}

		/// <summary>
		/// Get underlying storage reference (const)
		/// </summary>
		/// <returns>underlying storage reference</returns>
		[[nodiscard]] const std::array<unsigned char, eth_address_length>& get_data() const noexcept
		{
			return data;
		}
	};

	/// <summary>
	/// Char stream output operator
	/// </summary>
	/// <param name="os">stream instance reference</param>
	/// <param name="dt">mac_address value</param>
	/// <returns>stream instance reference</returns>
	inline std::ostream& operator<<(std::ostream& os, const mac_address& dt)
	{
		os << std::string(dt);
		return os;
	}

	/// <summary>
	/// Wide char stream output operator
	/// </summary>
	/// <param name="os">stream instance reference</param>
	/// <param name="dt">mac_address value</param>
	/// <returns>stream instance reference</returns>
	inline std::wostream& operator<<(std::wostream& os, const mac_address& dt)
	{
		os << std::wstring(dt);
		return os;
	}
}

// ReSharper disable once CppRedundantNamespaceDefinition
namespace std
{
	/// <summary>
	/// Hash for mac_address
	/// </summary>
	template <>
	struct hash<net::mac_address>
	{
		using argument_type = net::mac_address;
		using result_type = std::size_t;

		result_type operator()(const argument_type& mac) const noexcept
		{
			const auto arg = (static_cast<uint64_t>(mac.get_data().at(0)) << 40) +
				(static_cast<uint64_t>(mac.get_data().at(1)) << 32) +
				(static_cast<uint64_t>(mac.get_data().at(2)) << 24) +
				(static_cast<uint64_t>(mac.get_data().at(3)) << 16) +
				(static_cast<uint64_t>(mac.get_data().at(4)) << 8) +
				(static_cast<uint64_t>(mac.get_data().at(5)));

			const auto h1(
				std::hash<uint64_t>{}(arg)
			);

			return h1;
		}
	};
}

```

`examples/cpp/common/pcap/pcap.h`:

```h
// ReSharper disable CppInconsistentNaming
#pragma once

namespace pcap
{
	// --------------------------------------------------------------------------------
	/// <summary>
	/// Link layer types
	/// </summary>
	// --------------------------------------------------------------------------------
	enum link_layer_type: uint32_t
	{
		/// <summary>BSD loopback encapsulation</summary>
		LINKTYPE_NULL = 0,
		/// <summary>IEEE 802.3 Ethernet</summary>
		LINKTYPE_ETHERNET = 1,
		/// <summary>AX.25 packet</summary>
		LINKTYPE_AX25 = 3,
		/// <summary>IEEE 802.5 Token Ring</summary>
		LINKTYPE_IEEE802_5 = 6,
		/// <summary>ARCNET Data Packets</summary>
		LINKTYPE_ARCNET_BSD = 7,
		/// <summary>SLIP, encapsulated with a LINKTYPE_SLIP header</summary>
		LINKTYPE_SLIP = 8,
		/// <summary>PPP, as per RFC 1661 and RFC 1662</summary>
		LINKTYPE_PPP = 9,
		/// <summary>FDDI, as specified by ANSI INCITS 239-1994</summary>
		LINKTYPE_FDDI = 10,
		/// <summary>Raw IP</summary>
		LINKTYPE_DLT_RAW1 = 12,
		/// <summary>Raw IP (OpenBSD)</summary>
		LINKTYPE_DLT_RAW2 = 14,
		/// <summary>PPP in HDLC-like framing, as per RFC 1662, or Cisco PPP with HDLC
		/// framing, as per section 4.3.1 of RFC 1547</summary>
		LINKTYPE_PPP_HDLC = 50,
		/// <summary>PPPoE</summary>
		LINKTYPE_PPP_ETHER = 51,
		/// <summary>RFC 1483 LLC/SNAP-encapsulated ATM</summary>
		LINKTYPE_ATM_RFC1483 = 100,
		/// <summary>Raw IP</summary>
		LINKTYPE_RAW = 101,
		/// <summary>Cisco PPP with HDLC framing</summary>
		LINKTYPE_C_HDLC = 104,
		/// <summary>IEEE 802.11 wireless LAN</summary>
		LINKTYPE_IEEE802_11 = 105,
		/// <summary>Frame Relay</summary>
		LINKTYPE_FRELAY = 107,
		/// <summary>OpenBSD loopback encapsulation</summary>
		LINKTYPE_LOOP = 108,
		/// <summary>Linux "cooked" capture encapsulation</summary>
		LINKTYPE_LINUX_SLL = 113,
		/// <summary>Apple LocalTalk</summary>
		LINKTYPE_LTALK = 114,
		/// <summary>OpenBSD pflog</summary>
		LINKTYPE_PFLOG = 117,
		/// <summary>Prism monitor mode information followed by an 802.11 header</summary>
		LINKTYPE_IEEE802_11_PRISM = 119,
		/// <summary>RFC 2625 IP-over-Fibre Channel</summary>
		LINKTYPE_IP_OVER_FC = 122,
		/// <summary>ATM traffic, encapsulated as per the scheme used by SunATM devices</summary>
		LINKTYPE_SUNATM = 123,
		/// <summary>Radiotap link-layer information followed by an 802.11 header</summary>
		LINKTYPE_IEEE802_11_RADIOTAP = 127,
		/// <summary>ARCNET Data Packets, as described by the ARCNET Trade Association
		/// standard ATA 878.1-1999</summary>
		LINKTYPE_ARCNET_LINUX = 129,
		/// <summary>Apple IP-over-IEEE 1394 cooked header</summary>
		LINKTYPE_APPLE_IP_OVER_IEEE1394 = 138,
		/// <summary>Signaling System 7 Message Transfer Part Level 2</summary>
		LINKTYPE_MTP2_WITH_PHDR = 139,
		/// <summary>Signaling System 7 Message Transfer Part Level 2</summary>
		LINKTYPE_MTP2 = 140,
		/// <summary>Signaling System 7 Message Transfer Part Level 3</summary>
		LINKTYPE_MTP3 = 141,
		/// <summary>Signaling System 7 Signalling Connection Control Part</summary>
		LINKTYPE_SCCP = 142,
		/// <summary>Signaling System 7 Signalling Connection Control Part</summary>
		LINKTYPE_DOCSIS = 143,
		/// <summary>Linux-IrDA packets</summary>
		LINKTYPE_LINUX_IRDA = 144,
		/// <summary>AVS monitor mode information followed by an 802.11 header</summary>
		LINKTYPE_IEEE802_11_AVS = 163,
		/// <summary>BACnet MS/TP frames</summary>
		LINKTYPE_BACNET_MS_TP = 165,
		/// <summary>PPP in HDLC-like encapsulation, like LINKTYPE_PPP_HDLC, but with the
		/// 0xff address byte replaced by a direction indication - 0x00 for incoming and 0x01 for outgoing</summary>
		LINKTYPE_PPP_PPPD = 166,
		/// <summary>General Packet Radio Service Logical Link Control</summary>
		LINKTYPE_GPRS_LLC = 169,
		/// <summary>Transparent-mapped generic framing procedure</summary>
		LINKTYPE_GPF_T = 170,
		/// <summary>Frame-mapped generic framing procedure</summary>
		LINKTYPE_GPF_F = 171,
		/// <summary>Link Access Procedures on the D Channel (LAPD) frames</summary>
		LINKTYPE_LINUX_LAPD = 177,
		/// <summary>Bluetooth HCI UART transport layer</summary>
		LINKTYPE_BLUETOOTH_HCI_H4 = 187,
		/// <summary>USB packets, beginning with a Linux USB header</summary>
		LINKTYPE_USB_LINUX = 189,
		/// <summary>Per-Packet Information information</summary>
		LINKTYPE_PPI = 192,
		/// <summary>IEEE 802.15.4 wireless Personal Area Network</summary>
		LINKTYPE_IEEE802_15_4 = 195,
		/// <summary>Various link-layer types, with a pseudo-header, for SITA</summary>
		LINKTYPE_SITA = 196,
		/// <summary>Various link-layer types, with a pseudo-header, for Endace DAG cards;
		/// encapsulates Endace ERF record</summary>
		LINKTYPE_ERF = 197,
		/// <summary>Bluetooth HCI UART transport layer</summary>
		LINKTYPE_BLUETOOTH_HCI_H4_WITH_PHDR = 201,
		/// <summary>AX.25 packet, with a 1-byte KISS header containing a type indicator</summary>
		LINKTYPE_AX25_KISS = 202,
		/// <summary>Link Access Procedures on the D Channel (LAPD) frames</summary>
		LINKTYPE_LAPD = 203,
		/// <summary>PPP, as per RFC 1661 and RFC 1662, preceded with a one-byte pseudo-header
		/// with a zero value meaning "received by this host" and a non-zero value meaning
		/// "sent by this host" </summary>
		LINKTYPE_PPP_WITH_DIR = 204,
		/// <summary>Cisco PPP with HDLC framing</summary>
		LINKTYPE_C_HDLC_WITH_DIR = 205,
		/// <summary>Frame Relay</summary>
		LINKTYPE_FRELAY_WITH_DIR = 206,
		/// <summary>IPMB over an I2C circuit</summary>
		LINKTYPE_IPMB_LINUX = 209,
		/// <summary>IEEE 802.15.4 wireless Personal Area Network</summary>
		LINKTYPE_IEEE802_15_4_NONASK_PHY = 215,
		/// <summary>USB packets, beginning with a Linux USB header</summary>
		LINKTYPE_USB_LINUX_MMAPPED = 220,
		/// <summary>Fibre Channel FC-2 frames, beginning with a Frame_Header</summary>
		LINKTYPE_FC_2 = 224,
		/// <summary>Fibre Channel FC-2 frames</summary>
		LINKTYPE_FC_2_WITH_FRAME_DELIMS = 225,
		/// <summary>Solaris ipnet pseudo-header</summary>
		LINKTYPE_IPNET = 226,
		/// <summary>CAN (Controller Area Network) frames, with a pseudo-header as supplied
		/// by Linux SocketCAN</summary>
		LINKTYPE_CAN_SOCKETCAN = 227,
		/// <summary>Raw IPv4; the packet begins with an IPv4 header</summary>
		LINKTYPE_IPV4 = 228,
		/// <summary>Raw IPv6; the packet begins with an IPv6 header</summary>
		LINKTYPE_IPV6 = 229,
		/// <summary>IEEE 802.15.4 wireless Personal Area Network, without the FCS at the
		/// end of the frame</summary>
		LINKTYPE_IEEE802_15_4_NOFCS = 230,
		/// <summary>Raw D-Bus messages, starting with the endianness flag, followed by the
		/// message type, etc., but without the authentication handshake before the message
		/// sequence</summary>
		LINKTYPE_DBUS = 231,
		/// <summary>DVB-CI (DVB Common Interface for communication between a PC Card module
		/// and a DVB receiver), with the message format specified by the PCAP format for DVB-CI
		/// specification</summary>
		LINKTYPE_DVB_CI = 235,
		/// <summary>Variant of 3GPP TS 27.010 multiplexing protocol (similar to, but not the
		/// same as, 27.010)</summary>
		LINKTYPE_MUX27010 = 236,
		/// <summary>D_PDUs as described by NATO standard STANAG 5066, starting with the
		/// synchronization sequence, and including both header and data CRCs</summary>
		LINKTYPE_STANAG_5066_D_PDU = 237,
		/// <summary>Linux netlink NETLINK NFLOG socket log messages</summary>
		LINKTYPE_NFLOG = 239,
		/// <summary>Pseudo-header for Hilscher Gesellschaft für Systemautomation mbH netANALYZER devices,
		/// followed by an Ethernet frame, beginning with the MAC header and ending with the FCS</summary>
		LINKTYPE_NETANALYZER = 240,
		/// <summary>Pseudo-header for Hilscher Gesellschaft für Systemautomation mbH netANALYZER devices,
		/// followed by an Ethernet frame, beginning with the preamble, SFD, and MAC header, and ending
		/// with the FCS</summary>
		LINKTYPE_NETANALYZER_TRANSPARENT = 241,
		/// <summary>IP-over-InfiniBand, as specified by RFC 4391 section 6</summary>
		LINKTYPE_IPOIB = 242,
		/// <summary>MPEG-2 Transport Stream transport packets, as specified by ISO 13818-1/ITU-T
		/// Recommendation H.222.0</summary>
		LINKTYPE_MPEG_2_TS = 243,
		/// <summary>Pseudo-header for ng4T GmbH's UMTS Iub/Iur-over-ATM and Iub/Iur-over-IP format
		/// as used by their ng40 protocol tester</summary>
		LINKTYPE_NG40 = 244,
		/// <summary>Pseudo-header for NFC LLCP packet captures, followed by frame data for the LLCP
		/// Protocol as specified by NFCForum-TS-LLCP_1.1</summary>
		LINKTYPE_NFC_LLCP = 245,
		/// <summary>Raw InfiniBand frames, starting with the Local Routing Header</summary>
		LINKTYPE_INFINIBAND = 247,
		/// <summary>SCTP packets, as defined by RFC 4960, with no lower-level protocols such
		/// as IPv4 or IPv6</summary>
		LINKTYPE_SCTP = 248,
		/// <summary>USB packets, beginning with a USBPcap header</summary>
		LINKTYPE_USBPCAP = 249,
		/// <summary>Serial-line packet header for the Schweitzer Engineering Laboratories
		/// "RTAC" product</summary>
		LINKTYPE_RTAC_SERIAL = 250,
		/// <summary>Bluetooth Low Energy air interface Link Layer packets</summary>
		LINKTYPE_BLUETOOTH_LE_LL = 251,
		/// <summary>Linux Netlink capture encapsulation</summary>
		LINKTYPE_NETLINK = 253,
		/// <summary>Bluetooth Linux Monitor encapsulation of traffic for the BlueZ stack</summary>
		LINKTYPE_BLUETOOTH_LINUX_MONITOR = 254,
		/// <summary>Bluetooth Basic Rate and Enhanced Data Rate baseband packets</summary>
		LINKTYPE_BLUETOOTH_BREDR_BB = 255,
		/// <summary>Bluetooth Low Energy link-layer packets</summary>
		LINKTYPE_BLUETOOTH_LE_LL_WITH_PHDR = 256,
		/// <summary>PROFIBUS data link layer packets, as specified by IEC standard 61158-6-3</summary>
		LINKTYPE_PROFIBUS_DL = 257,
		/// <summary>Apple PKTAP capture encapsulation</summary>
		LINKTYPE_PKTAP = 258,
		/// <summary>Ethernet-over-passive-optical-network packets</summary>
		LINKTYPE_EPON = 259,
		/// <summary>IPMI trace packets, as specified by Table 3-20 "Trace Data Block Format" in
		/// the PICMG HPM.2 specification</summary>
		LINKTYPE_IPMI_HPM_2 = 260,
		/// <summary>Per Joshua Wright, formats for Z-Wave RF profiles
		/// R1 and R2 captures</summary>
		LINKTYPE_ZWAVE_R1_R2 = 261,
		/// <summary>Per Joshua Wright, formats for Z-Wave RF profile
		/// R3 captures</summary>
		LINKTYPE_ZWAVE_R3 = 262,
		/// <summary>Formats for WattStopper Digital Lighting Management (DLM) and Legrand Nitoo
		/// Open protocol common packet structure captures</summary>
		LINKTYPE_WATTSTOPPER_DLM = 263,
		/// <summary>Messages between ISO 14443 contactless smartcards (Proximity Integrated
		/// Circuit Card, PICC) and card readers (Proximity Coupling Device, PCD), with the message
		/// format specified by the PCAP format for ISO14443 specification</summary>
		LINKTYPE_ISO_14443 = 264
	};

	/// <summary>
	/// PCAP file header representation
	/// </summary>
	using pcap_hdr_t = struct pcap_hdr_s
	{
		/// <summary>magic number</summary>
		uint32_t magic_number;
		/// <summary>major version number</summary>
		uint16_t version_major;
		/// <summary>minor version number</summary>
		uint16_t version_minor;
		/// <summary>GMT to local correction</summary>
		int32_t thiszone;
		/// <summary>accuracy of timestamps</summary>
		uint32_t sigfigs;
		/// <summary>max length of captured packets, in octets</summary>
		uint32_t snaplen;
		/// <summary>data link type</summary>
		uint32_t network;
	};

	/// <summary>
	/// PCAP record header
	/// </summary>
	using pcaprec_hdr_t = struct pcaprec_hdr_s
	{
		/// <summary>timestamp seconds</summary>
		uint32_t ts_sec;
		/// <summary>timestamp microseconds</summary>
		uint32_t ts_usec;
		/// <summary>number of octets of packet saved in file</summary>
		uint32_t incl_len;
		/// <summary>actual length of packet</summary>
		uint32_t orig_len;
	};

	/// <summary>
	/// Class wrapper for the pcap_hdr_t
	/// </summary>
	class pcap_file_header
	{
	public:
		/// <summary>
		/// Constructs PCAP header object instance
		/// </summary>
		/// <param name="version_major">major version number</param>
		/// <param name="version_minor">minor version number</param>
		/// <param name="this_zone">GMT to local correction</param>
		/// <param name="sig_figs">accuracy of timestamps</param>
		/// <param name="snap_len">max length of captured packets, in octets</param>
		/// <param name="network">data link type</param>
		pcap_file_header(const uint16_t version_major, const uint16_t version_minor, const int32_t this_zone,
		                 const uint32_t sig_figs,
		                 const uint32_t snap_len, const link_layer_type network) noexcept
			: header_{0xa1b2c3d4, version_major, version_minor, this_zone, sig_figs, snap_len, network}
		{
		}

		/// <summary>
		/// Writes pcap_file_header into the specified stream
		/// </summary>
		/// <param name="os">std::ostream instance reference</param>
		/// <param name="obj">pcap_file_header object instance</param>
		/// <returns>std::ostream instance reference</returns>
		friend std::ostream& operator<<(std::ostream& os, const pcap_file_header& obj)
		{
			return os.write(reinterpret_cast<const char*>(&obj.header_), sizeof(pcap_hdr_t));
		}

	private:
		/// <summary>
		/// PCAP header structure
		/// </summary>
		pcap_hdr_t header_;
	};

	/// <summary>
	/// Class wrapper for the PCAP record
	/// </summary>
	class pcap_record_header
	{
	public:
		/// <summary>
		/// Constructs PCAP file record
		/// </summary>
		/// <param name="timestamp_sec">timestamp seconds</param>
		/// <param name="timestamp_usec">timestamp microseconds</param>
		/// <param name="incl_len">number of octets of packet saved in file</param>
		/// <param name="orig_len">actual length of packet</param>
		/// <param name="data">packet content pointer</param>
		pcap_record_header(const uint32_t timestamp_sec, const uint32_t timestamp_usec, const uint32_t incl_len,
		                   const uint32_t orig_len, const char* data) noexcept
			: header_{timestamp_sec, timestamp_usec, incl_len, orig_len}, data_{data}
		{
		}

		/// <summary>
		/// Writes PCAP record into the specified stream
		/// </summary>
		/// <param name="os">std::ostream instance reference</param>
		/// <param name="obj">pcap_record_header object instance</param>
		/// <returns>std::ostream instance reference</returns>
		friend std::ostream& operator<<(std::ostream& os, const pcap_record_header& obj)
		{
			return os.write(reinterpret_cast<const char*>(&obj.header_), sizeof(pcaprec_hdr_t)).write(
				obj.data_, obj.header_.incl_len);
		}

	private:
		/// <summary>
		/// PCAP record header structure
		/// </summary>
		pcaprec_hdr_t header_;
		/// <summary>
		/// PCAP network packet data pointer
		/// </summary>
		const char* data_;
	};
}

```

`examples/cpp/common/pcap/pcap_file_storage.h`:

```h
#pragma once

#include "pcap.h"

namespace pcap
{
	// --------------------------------------------------------------------------------
	/// <summary>
	/// PCAP format packet file logger
	/// </summary>
	// --------------------------------------------------------------------------------
	class pcap_file_storage
	{
	public:
		/// <summary>
		/// Constructs object instance and opens the file for the output
		/// </summary>
		/// <param name="file_name">PCAP file name</param>
		explicit pcap_file_storage(const std::string& file_name)
		{
			open(file_name);
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		pcap_file_storage() = default;

		/// <summary>
		/// Deleted copy constructor
		/// </summary>
		pcap_file_storage(const pcap_file_storage& other) = delete;

		/// <summary>
		/// Default move constructor
		/// </summary>
		/// <param name="other">Object instance to move from</param>
		pcap_file_storage(pcap_file_storage&& other) noexcept = default;

		/// <summary>
		/// Deleted copy assignment
		/// </summary>
		pcap_file_storage& operator=(const pcap_file_storage& other) = delete;

		/// <summary>
		/// Default move assignment
		/// </summary>
		/// <param name="other">Object instance to move from</param>
		/// <returns></returns>
		pcap_file_storage& operator=(pcap_file_storage&& other) noexcept = default;

		/// <summary>
		/// Destructor: closes the output file stream
		/// </summary>
		~pcap_file_storage()
		{
			try
			{
				if (file_stream_)
					file_stream_.close();
			}
			catch (...)
			{
			}
		}

		/// <summary>
		/// Typecast to bool returns true is file was successfully opened
		/// </summary>
		// ReSharper disable once CppNonExplicitConversionOperator
		operator bool() const { return file_stream_ ? true : false; }

		/// <summary>
		/// Opens specified PCAP file and writes out the PCAP file header
		/// </summary>
		/// <param name="file_name">PCAP file to open</param>
		void open(const std::string& file_name)
		{
			if (file_stream_)
				file_stream_.close();

			file_stream_.open(file_name, std::ofstream::binary | std::ofstream::out | std::ofstream::trunc);

			if (file_stream_)
			{
				const pcap_file_header header{2, 4, 0, 0,MAX_ETHER_FRAME, LINKTYPE_ETHERNET};
				file_stream_ << header;
			}
		}

		/// <summary>
		/// Writes network packet stored in INTERMEDIATE_BUFFER into the PCAP file
		/// </summary>
		/// <param name="buffer">Network packet to write into the PCAP file</param>
		/// <returns></returns>
		pcap_file_storage& operator<<(const INTERMEDIATE_BUFFER& buffer)
		{
			static std::mutex lock; // NOLINT(clang-diagnostic-exit-time-destructors)
			static const auto start_time = std::chrono::high_resolution_clock::now();
			static const auto seconds_since_epoch =
				gsl::narrow_cast<uint32_t>(std::chrono::duration_cast<std::chrono::seconds>(
					std::chrono::system_clock::now().time_since_epoch()
				).count());

			std::lock_guard<std::mutex> write_lock(lock);

			const auto milliseconds =
				std::chrono::duration_cast<std::chrono::milliseconds>(
					std::chrono::high_resolution_clock::now() - start_time
				);

			const auto seconds = gsl::narrow_cast<uint32_t>(milliseconds.count() / 1000) + seconds_since_epoch;
			const auto microseconds_remain = gsl::narrow_cast<uint32_t>((milliseconds.count() % 1000) * 1000);

			const auto* const ethernet_header = reinterpret_cast<const char*>(buffer.m_IBuffer);

			file_stream_ << pcap_record_header(seconds, microseconds_remain,
			                                   buffer.m_Length, buffer.m_Length, ethernet_header);

			file_stream_.flush();

			return *this;
		}

	private:
		/// <summary>
		/// PCAP file associated file stream object instance
		/// </summary>
		std::ofstream file_stream_;
	};
}

```

`examples/cpp/common/proxy/proxy_common.h`:

```h
#pragma once

namespace proxy
{
	template <typename...>
	constexpr bool false_v = false;

	enum class proxy_io_operation
	{
		relay_io_read,
		relay_io_write,
		negotiate_io_read,
		negotiate_io_write,
		inject_io_write
	};

	// --------------------------------------------------------------------------------
	/// <summary>
	/// Used to pass data required to negotiate connection to the remote proxy
	/// </summary>
	// --------------------------------------------------------------------------------
	template <typename T>
	struct negotiate_context
	{
		negotiate_context(const T& remote_address, const uint16_t remote_port)
			: remote_address(remote_address),
			  remote_port(remote_port)
		{
		}

		virtual ~negotiate_context() = default;


		negotiate_context(const negotiate_context& other)
			: remote_address(other.remote_address),
			  remote_port(other.remote_port)
		{
		}

		negotiate_context(negotiate_context&& other) noexcept
			: remote_address(std::move(other.remote_address)),
			  remote_port(other.remote_port)
		{
		}

		negotiate_context& operator=(const negotiate_context& other)
		{
			if (this == &other)
				return *this;

			remote_address = other.remote_address;
			remote_port = other.remote_port;
			return *this;
		}

		negotiate_context& operator=(negotiate_context&& other) noexcept
		{
			if (this == &other)
				return *this;

			remote_address = std::move(other.remote_address);
			remote_port = other.remote_port;
			return *this;
		}

		T remote_address;
		uint16_t remote_port;
	};
}

```

`examples/cpp/common/proxy/socks5_common.h`:

```h
#pragma once

namespace proxy
{
#pragma pack(push,1)
	static constexpr uint8_t socks5_protocol_version = 5;
	static constexpr uint8_t socks5_username_auth_version = 1;
	static constexpr uint8_t socks5_username_max_length = 255;

	template <uint8_t NumberOfMethods = 1>
	struct socks5_ident_req
	{
		unsigned char version = socks5_protocol_version;
		unsigned char number_of_methods = NumberOfMethods;
		unsigned char methods[NumberOfMethods]{};
	};

	struct socks5_ident_resp
	{
		unsigned char version = socks5_protocol_version;
		unsigned char method;
	};

	struct socks5_username_auth
	{
		socks5_username_auth() = default;

		socks5_username_auth(const std::string& username, const std::string& password)
		{
			if (0 == init(username, password))
				throw std::runtime_error("SOCKS5: username or password length exceeds the limits");
		}

		[[nodiscard]] uint32_t init(const std::string& username, const std::string& password)
		{
			if (username.length() > 255 || password.length() > 255)
				return 0;

			username_length = static_cast<unsigned char>(username.length());

			unsigned char* password_length_ptr = reinterpret_cast<unsigned char*>(username_reserved) + username_length;
			char* password_ptr = reinterpret_cast<char*>(password_length_ptr) + 1;

			strcpy_s(username_reserved, 255, username.c_str());

			*password_length_ptr = static_cast<unsigned char>(password.length());
			strcpy_s(password_ptr, 255, password.c_str());

			return (3 + static_cast<int>(username.length()) + static_cast<int>(password.length()));
		}

		unsigned char version = socks5_username_auth_version;
		unsigned char username_length{};
		char username_reserved[socks5_username_max_length + 1 + socks5_username_max_length]{}; // RFC 1929
	};

	template <typename T>
	struct socks5_req
	{
		unsigned char version = socks5_protocol_version;
		unsigned char cmd{};
		unsigned char reserved{};
		unsigned char address_type{};
		/*union {
			in_addr ip_v4;
				in6_addr ip_v6;
				struct {
					unsigned char domain_len;
					char domain[256];
				};
		} dest_address;*/
		T dest_address;
		unsigned short dest_port{};
	};

	template <typename T>
	struct socks5_resp
	{
		unsigned char version = socks5_protocol_version;
		unsigned char reply{};
		unsigned char reserved{};
		unsigned char address_type{};
		/*union {
			in_addr ip_v4;
			in6_addr ip_v6;
			struct {
				unsigned char domain_len;
				char domain[256];
			};
		} bind_address;*/
		T bind_address;
		unsigned short bind_port{};
	};

	template <typename T>
	struct socks5_udp_header
	{
		unsigned short reserved;
		unsigned char fragment;
		unsigned char address_type;
		/*union {
			in_addr ip_v4;
			in6_addr ip_v6;
			struct {
				unsigned char domain_len;
				char domain[256];
			};
		} dest_address;*/
		T dest_address;
		unsigned short dest_port;
	};
#pragma pack(pop)

	template <typename T>
	struct socks5_negotiate_context final : negotiate_context<T>
	{
		socks5_negotiate_context(const T& remote_address, uint16_t remote_port)
			: negotiate_context<T>(remote_address, remote_port)
		{
		}

		socks5_negotiate_context(const T& remote_srv_address, uint16_t remote_srv_port,
			std::optional<std::string> socks5_username, std::optional<std::string> socks5_password)
			: negotiate_context<T>(remote_srv_address, remote_srv_port),
			socks5_username(std::move(socks5_username)),
			socks5_password(std::move(socks5_password))
		{
		}

		socks5_negotiate_context(const T& remote_address, uint16_t remote_port,
			std::string socks5_username, std::string socks5_password)
			: negotiate_context<T>(remote_address, remote_port),
			socks5_username(std::move(socks5_username)),
			socks5_password(std::move(socks5_password))
		{
		}

		std::optional<std::string> socks5_username{ std::nullopt };
		std::optional<std::string> socks5_password{ std::nullopt };
	};
}

```

`examples/cpp/common/proxy/socks5_tcp_proxy_socket.h`:

```h
// ReSharper disable CppExpressionWithoutSideEffects
// ReSharper disable CppClangTidyClangDiagnosticUnusedValue
#pragma once

namespace proxy
{
	template <typename T>
	class socks5_tcp_proxy_socket final : public tcp_proxy_socket<T>
	{
		enum class socks5_state
		{
			pre_login,
			login_sent,
			login_responded,
			password_sent,
			password_responded,
			connect_sent
		};

	public:
		using address_type_t = T;
		using negotiate_context_t = socks5_negotiate_context<T>;
		using per_io_context_t = tcp_per_io_context<T>;

		socks5_tcp_proxy_socket(const SOCKET local_socket, const SOCKET remote_socket,
		                        std::unique_ptr<negotiate_context_t> negotiate_ctx,
		                        std::function<void(const char*)> log_printer, const netlib::log::log_level log_level)
			: tcp_proxy_socket<T>(local_socket, remote_socket, std::move(negotiate_ctx), std::move(log_printer),
			                      log_level)
		{
		}

		void process_receive_negotiate_complete(const uint32_t io_size, per_io_context_t* io_context) override
		{
			if (io_context->is_local == false)
			{
				if (current_state_ == socks5_state::login_sent)
				{
					current_state_ = socks5_state::login_responded;

					if ((ident_resp_.version != 5) ||
						(ident_resp_.method == 0xFF))
					{
						// SOCKS v5 identification or authentication failed
						tcp_proxy_socket<T>::close_client(true, false);
					}
					else
					{
						// USERNAME/PASSWORD is chosen
						if (ident_resp_.method == 0x2)
						{
							if (auto* negotiate_context_ptr = dynamic_cast<negotiate_context_t*>(tcp_proxy_socket<
									T>::negotiate_ctx_.get()); !negotiate_context_ptr->socks5_username.has_value() ||
								// [SOCKS5]: associate_to_socks5_proxy: RFC 1928: X'02' USERNAME/PASSWORD is chosen but USERNAME is not provided
								(negotiate_context_ptr->socks5_username.value().length() > socks5_username_max_length ||
									negotiate_context_ptr->socks5_username.value().length() < 1) ||
								// [SOCKS5]: associate_to_socks5_proxy: RFC 1928: X'02' USERNAME/PASSWORD is chosen but USERNAME exceeds maximum possible length
								!negotiate_context_ptr->socks5_password.has_value() ||
								// [SOCKS5]: associate_to_socks5_proxy: RFC 1928: X'02' USERNAME/PASSWORD is chosen but PASSWORD is not provided
								(negotiate_context_ptr->socks5_password.value().length() > socks5_username_max_length ||
									negotiate_context_ptr->socks5_password.value().length() < 1)
								// [SOCKS5]: associate_to_socks5_proxy: RFC 1928: X'02' USERNAME/PASSWORD is chosen but USERNAME exceeds maximum possible length
							)
							{
								tcp_proxy_socket<T>::close_client(true, false);
							}
							else
							{
								if (auto auth_size = username_auth_.init(
									negotiate_context_ptr->socks5_username.value(),
									negotiate_context_ptr->socks5_password.value()); auth_size != 0)
								{
									io_context_send_negotiate_.wsa_buf.buf = reinterpret_cast<char*>(&username_auth_);
									io_context_send_negotiate_.wsa_buf.len = auth_size;
									io_context_recv_negotiate_.wsa_buf.buf = reinterpret_cast<char*>(&ident_resp_);
									io_context_recv_negotiate_.wsa_buf.len = sizeof(socks5_ident_resp);

									DWORD flags = 0;

									if ((::WSASend(
										tcp_proxy_socket<T>::remote_socket_,
										&io_context_send_negotiate_.wsa_buf,
										1,
										nullptr,
										0,
										&io_context_send_negotiate_,
										nullptr) == SOCKET_ERROR) && (ERROR_IO_PENDING != WSAGetLastError()))
									{
										tcp_proxy_socket<T>::close_client(false, false);
									}

									current_state_ = socks5_state::password_sent;

									if ((::WSARecv(
										tcp_proxy_socket<T>::remote_socket_,
										&io_context_recv_negotiate_.wsa_buf,
										1,
										nullptr,
										&flags,
										&io_context_recv_negotiate_,
										nullptr) == SOCKET_ERROR) && (ERROR_IO_PENDING != WSAGetLastError()))
									{
										tcp_proxy_socket<T>::close_client(true, false);
									}
								}
							}
						}
						else // NO AUTHENTICATION REQUIRED is chosen
						{
							connect_request_.cmd = 1;
							connect_request_.reserved = 0;
							connect_request_.address_type = 1;
							connect_request_.dest_address = tcp_proxy_socket<T>::negotiate_ctx_->remote_address;
							connect_request_.dest_port = htons(tcp_proxy_socket<T>::negotiate_ctx_->remote_port);

							io_context_send_negotiate_.wsa_buf.buf = reinterpret_cast<char*>(&connect_request_);
							io_context_send_negotiate_.wsa_buf.len = sizeof(socks5_req<T>);
							io_context_recv_negotiate_.wsa_buf.buf = reinterpret_cast<char*>(&connect_response_);
							io_context_recv_negotiate_.wsa_buf.len = sizeof(socks5_resp<T>);

							DWORD flags = 0;

							if ((::WSASend(
								tcp_proxy_socket<T>::remote_socket_,
								&io_context_send_negotiate_.wsa_buf,
								1,
								nullptr,
								0,
								&io_context_send_negotiate_,
								nullptr) == SOCKET_ERROR) && (ERROR_IO_PENDING != WSAGetLastError()))
							{
								tcp_proxy_socket<T>::close_client(false, false);
							}

							current_state_ = socks5_state::connect_sent;

							if ((::WSARecv(
								tcp_proxy_socket<T>::remote_socket_,
								&io_context_recv_negotiate_.wsa_buf,
								1,
								nullptr,
								&flags,
								&io_context_recv_negotiate_,
								nullptr) == SOCKET_ERROR) && (ERROR_IO_PENDING != WSAGetLastError()))
							{
								tcp_proxy_socket<T>::close_client(true, false);
							}
						}
					}
				}
				else if (current_state_ == socks5_state::password_sent)
				{
					current_state_ = socks5_state::password_responded;

					if (ident_resp_.method != 0)
					{
						// SOCKS v5 identification or authentication failed
						tcp_proxy_socket<T>::close_client(true, false);
					}
					else
					{
						connect_request_.cmd = 1;
						connect_request_.reserved = 0;
						connect_request_.address_type = 1;
						connect_request_.dest_address = tcp_proxy_socket<T>::negotiate_ctx_->remote_address;
						connect_request_.dest_port = htons(tcp_proxy_socket<T>::negotiate_ctx_->remote_port);

						io_context_send_negotiate_.wsa_buf.buf = reinterpret_cast<char*>(&connect_request_);
						io_context_send_negotiate_.wsa_buf.len = sizeof(socks5_req<T>);
						io_context_recv_negotiate_.wsa_buf.buf = reinterpret_cast<char*>(&connect_response_);
						io_context_recv_negotiate_.wsa_buf.len = sizeof(socks5_resp<T>);

						DWORD flags = 0;

						if ((::WSASend(
							tcp_proxy_socket<T>::remote_socket_,
							&io_context_send_negotiate_.wsa_buf,
							1,
							nullptr,
							0,
							&io_context_send_negotiate_,
							nullptr) == SOCKET_ERROR) && (ERROR_IO_PENDING != WSAGetLastError()))
						{
							tcp_proxy_socket<T>::close_client(false, false);
						}

						current_state_ = socks5_state::connect_sent;

						if ((::WSARecv(
							tcp_proxy_socket<T>::remote_socket_,
							&io_context_recv_negotiate_.wsa_buf,
							1,
							nullptr,
							&flags,
							&io_context_recv_negotiate_,
							nullptr) == SOCKET_ERROR) && (ERROR_IO_PENDING != WSAGetLastError()))
						{
							tcp_proxy_socket<T>::close_client(true, false);
						}
					}
				}
				else if (current_state_ == socks5_state::connect_sent)
				{
					if (connect_response_.reply != 0)
					{
						// SOCKS v5 connect failed
						tcp_proxy_socket<T>::close_client(true, false);
					}
					else
					{
						tcp_proxy_socket<T>::start_data_relay();
					}
				}
			}
		}

	private:
		per_io_context_t io_context_recv_negotiate_{proxy_io_operation::negotiate_io_read, this, false};
		per_io_context_t io_context_send_negotiate_{proxy_io_operation::negotiate_io_write, this, false};

		socks5_state current_state_{socks5_state::pre_login};
		socks5_ident_req<2> ident_req_{};
		socks5_ident_resp ident_resp_{};
		socks5_req<address_type_t> connect_request_;
		socks5_resp<address_type_t> connect_response_;
		socks5_username_auth username_auth_{};

	protected:
		bool local_negotiate() override
		{
			return true;
		}

		bool remote_negotiate() override
		{
			if (tcp_proxy_socket<T>::negotiate_ctx_)
			{
				if (current_state_ == socks5_state::pre_login)
				{
					ident_req_.methods[0] = 0x0; // RFC 1928: X'00' NO AUTHENTICATION REQUIRED
					ident_req_.methods[1] = 0x2; // RFC 1928: X'02' USERNAME/PASSWORD

					io_context_send_negotiate_.wsa_buf.buf = reinterpret_cast<char*>(&ident_req_);
					io_context_send_negotiate_.wsa_buf.len = sizeof(ident_req_);
					io_context_recv_negotiate_.wsa_buf.buf = reinterpret_cast<char*>(&ident_resp_);
					io_context_recv_negotiate_.wsa_buf.len = sizeof(socks5_ident_resp);

					DWORD flags = 0;

					if ((::WSASend(
						tcp_proxy_socket<T>::remote_socket_,
						&io_context_send_negotiate_.wsa_buf,
						1,
						nullptr,
						0,
						&io_context_send_negotiate_,
						nullptr) == SOCKET_ERROR) && (ERROR_IO_PENDING != WSAGetLastError()))
					{
						tcp_proxy_socket<T>::close_client(false, false);
					}

					current_state_ = socks5_state::login_sent;

					if ((::WSARecv(
						tcp_proxy_socket<T>::remote_socket_,
						&io_context_recv_negotiate_.wsa_buf,
						1,
						nullptr,
						&flags,
						&io_context_recv_negotiate_,
						nullptr) == SOCKET_ERROR) && (ERROR_IO_PENDING != WSAGetLastError()))
					{
						tcp_proxy_socket<T>::close_client(true, false);
					}
				}

				return false;
			}

			return true;
		}
	};
}

```

`examples/cpp/common/proxy/tcp_proxy_server.h`:

```h
#pragma once
namespace proxy
{
	template <typename T>
	class tcp_proxy_server
	{
	public:
		using negotiate_context_t = typename T::negotiate_context_t;
		using address_type_t = typename T::address_type_t;
		using per_io_context_t = typename T::per_io_context_t;

		using query_remote_peer_t = std::tuple<address_type_t, uint16_t, std::unique_ptr<negotiate_context_t>>(
			address_type_t, uint16_t);

	private:
		constexpr static size_t connections_array_size = 64;

		uint16_t proxy_port_;
		winsys::io_completion_port& completion_port_;
		std::function<query_remote_peer_t> query_remote_peer_;

		/// <summary>message logging function</summary>
		std::function<void(const char*)> log_printer_;
		/// <summary>logging level</summary>
		netlib::log::log_level log_level_;

		std::shared_mutex lock_;

		std::thread proxy_server_;
		std::thread check_clients_thread_;
		std::thread connect_to_remote_host_thread_;

		std::vector<std::unique_ptr<T>> proxy_sockets_;
		std::vector<std::tuple<WSAEVENT, SOCKET, SOCKET, std::unique_ptr<negotiate_context_t>>> sock_array_events_;

		std::atomic_bool end_server_{true}; // set to true on proxy termination
		SOCKET server_socket_{INVALID_SOCKET};

		ULONG_PTR completion_key_{0};

	public:
		tcp_proxy_server(const uint16_t proxy_port, winsys::io_completion_port& completion_port,
		                 const std::function<query_remote_peer_t> query_remote_peer_fn,
		                 std::function<void(const char*)> log_printer, const netlib::log::log_level log_level)
			: proxy_port_(proxy_port),
			  completion_port_(completion_port),
			  query_remote_peer_(query_remote_peer_fn),
			  log_printer_(std::move(log_printer)), log_level_(log_level)
		{
			if (!create_server_socket())
			{
				throw std::runtime_error("tcp_proxy_server: failed to create server socket.");
			}
		}

		~tcp_proxy_server()
		{
			if (server_socket_ != INVALID_SOCKET)
			{
				shutdown(server_socket_, SD_BOTH);
				closesocket(server_socket_);
				server_socket_ = INVALID_SOCKET;
			}

			if (end_server_ == false)
				stop();
		}

		tcp_proxy_server(const tcp_proxy_server& other) = delete;

		tcp_proxy_server(tcp_proxy_server&& other) noexcept = delete;

		tcp_proxy_server& operator=(const tcp_proxy_server& other) = delete;

		tcp_proxy_server& operator=(tcp_proxy_server&& other) noexcept = delete;

		[[nodiscard]] uint16_t proxy_port() const
		{
			return proxy_port_;
		}

		bool start()
		{
			if (end_server_ == false)
			{
				// already running
				return true;
			}

			end_server_ = false;

			sock_array_events_.reserve(connections_array_size);

			sock_array_events_.push_back(std::make_tuple(WSACreateEvent(),
			                                             WSASocket(address_type_t::af_type, SOCK_STREAM,
			                                                       IPPROTO_TCP, nullptr, 0,
			                                                       WSA_FLAG_OVERLAPPED), INVALID_SOCKET, nullptr));

			if (std::get<1>(sock_array_events_[0]) != INVALID_SOCKET)
			{
				auto [success, io_key] = completion_port_.associate_socket(
					std::get<1>(sock_array_events_[0]),
					[this](const DWORD num_bytes, OVERLAPPED* povlp, const BOOL status)
					{
						if (end_server_)
							return false;

						auto io_context = static_cast<per_io_context_t*>(povlp);

						if (!status || (status && (num_bytes == 0)))
						{
							if ((io_context->io_operation == proxy_io_operation::relay_io_read) ||
								(io_context->io_operation == proxy_io_operation::negotiate_io_read))
							{
								io_context->proxy_socket_ptr->close_client(true, io_context->is_local);
								return false;
							}

							if (!status)
							{
								io_context->proxy_socket_ptr->close_client(false, io_context->is_local);
								return false;
							}
						}

						switch (io_context->io_operation)
						{
						case proxy_io_operation::relay_io_read:
							io_context->proxy_socket_ptr->process_receive_buffer_complete(num_bytes, io_context);
							break;

						case proxy_io_operation::relay_io_write:
							io_context->proxy_socket_ptr->process_send_buffer_complete(num_bytes, io_context);
							break;

						case proxy_io_operation::negotiate_io_read:
							io_context->proxy_socket_ptr->process_receive_negotiate_complete(num_bytes, io_context);
							break;

						case proxy_io_operation::negotiate_io_write:
							io_context->proxy_socket_ptr->process_send_negotiate_complete(num_bytes, io_context);
							break;

						case proxy_io_operation::inject_io_write:
							T::process_inject_buffer_complete(io_context);
							break;
						default: break; // NOLINT(clang-diagnostic-covered-switch-default)
						}

						return true;
					});

				if (success == true)
				{
					completion_key_ = io_key;
				}
				else
				{
					if (std::get<0>(sock_array_events_[0]) != INVALID_HANDLE_VALUE)
					{
						WSACloseEvent(std::get<0>(sock_array_events_[0]));
					}

					if (std::get<1>(sock_array_events_[0]) != INVALID_SOCKET)
					{
						closesocket(std::get<1>(sock_array_events_[0]));
					}

					sock_array_events_.clear();
					end_server_ = true;
					return false;
				}
			}

			proxy_server_ = std::thread(&tcp_proxy_server<T>::start_proxy_thread, this);
			check_clients_thread_ = std::thread(&tcp_proxy_server<T>::clear_thread, this);
			connect_to_remote_host_thread_ = std::thread(&tcp_proxy_server<T>::connect_to_remote_host_thread, this);

			return true;
		}

		void stop()
		{
			if (end_server_ == true)
			{
				// already stopped
				return;
			}

			end_server_ = true;

			closesocket(server_socket_);
			server_socket_ = INVALID_SOCKET;

			{
				std::shared_lock<std::shared_mutex> lock(lock_);
				::WSASetEvent(std::get<0>(sock_array_events_[0]));
			}

			if (proxy_server_.joinable())
			{
				proxy_server_.join();
			}

			if (check_clients_thread_.joinable())
			{
				check_clients_thread_.join();
			}

			if (connect_to_remote_host_thread_.joinable())
			{
				connect_to_remote_host_thread_.join();
			}

			if (!sock_array_events_.empty())
			{
				sock_array_events_.clear();
			}

			if (!proxy_sockets_.empty())
			{
				proxy_sockets_.clear();
			}
		}

		std::vector<negotiate_context_t> query_current_sessions_ctx()
		{
			std::shared_lock lock(lock_);
			std::vector<negotiate_context_t> result;
			result.reserve(proxy_sockets_.size());

			std::transform(proxy_sockets_.cbegin(), proxy_sockets_.cend(), std::back_inserter(result), [](auto&& e)
			{
				return *reinterpret_cast<negotiate_context_t*>(e->get_negotiate_ctx());
			});

			return result;
		}

	private:
		// ********************************************************************************
		/// <summary>
		/// Queries remote host information for outgoing connection by locally accepted socket
		/// </summary>
		/// <param name="accepted">locally accepted TCP socket</param>
		/// <returns>tuple of information required to connect to the remote peer</returns>
		// ********************************************************************************
		std::tuple<address_type_t, uint16_t, std::unique_ptr<negotiate_context_t>> get_remote_peer(
			const SOCKET accepted) const
		{
			SOCKADDR_STORAGE name;
			int len = sizeof(SOCKADDR_STORAGE);

			if (!getpeername(accepted, reinterpret_cast<sockaddr*>(&name), &len))
			{
				uint16_t accepted_peer_port = 0;
				address_type_t accepted_peer_address{};

				if constexpr (address_type_t::af_type == AF_INET)
				{
					accepted_peer_port = ntohs(reinterpret_cast<sockaddr_in*>(&name)->sin_port);
					accepted_peer_address = address_type_t(reinterpret_cast<sockaddr_in*>(&name)->sin_addr);
				}
				else if constexpr (address_type_t::af_type == AF_INET6)
				{
					accepted_peer_port = ntohs(reinterpret_cast<sockaddr_in6*>(&name)->sin6_port);
					accepted_peer_address = address_type_t(reinterpret_cast<sockaddr_in6*>(&name)->sin6_addr);
				}
				else
				{
					static_assert(false_v<T>, "Unsupported address family used as a template parameter!");
				}

				if (query_remote_peer_)
				{
					return query_remote_peer_(accepted_peer_address, accepted_peer_port);
				}
			}
			else
			{
				return std::make_tuple(address_type_t{}, 0, nullptr);
			}

			return std::make_tuple(address_type_t{}, 0, nullptr);
		}

		bool create_server_socket()
		{
			server_socket_ = WSASocket(address_type_t::af_type, SOCK_STREAM, IPPROTO_TCP, nullptr, 0,
			                           WSA_FLAG_OVERLAPPED);

			if (server_socket_ == INVALID_SOCKET)
			{
				return false;
			}

			if constexpr (address_type_t::af_type == AF_INET)
			{
				sockaddr_in service{};
				service.sin_family = address_type_t::af_type;
				service.sin_addr.s_addr = INADDR_ANY;
				service.sin_port = htons(proxy_port_);

				if (const auto status = bind(server_socket_, reinterpret_cast<SOCKADDR*>(&service), sizeof(service));
					status == SOCKET_ERROR)
				{
					closesocket(server_socket_);
					server_socket_ = INVALID_SOCKET;
					return false;
				}

				if (proxy_port_ == 0)
				{
					int name_length = sizeof(service);
					if (0 == getsockname(server_socket_, reinterpret_cast<SOCKADDR*>(&service), &name_length))
					{
						proxy_port_ = ntohs(service.sin_port);
					}
					else
					{
						closesocket(server_socket_);
						server_socket_ = INVALID_SOCKET;
						return false;
					}
				}
			}
			else
			{
				sockaddr_in6 service{};
				service.sin6_family = address_type_t::af_type;
				service.sin6_addr = in6addr_any;
				service.sin6_port = htons(proxy_port_);

				if (const auto status = bind(server_socket_, reinterpret_cast<SOCKADDR*>(&service), sizeof(service));
					status == SOCKET_ERROR)
				{
					closesocket(server_socket_);
					server_socket_ = INVALID_SOCKET;
					return false;
				}

				if (proxy_port_ == 0)
				{
					int name_length = sizeof(service);
					if (0 == getsockname(server_socket_, reinterpret_cast<SOCKADDR*>(&service), &name_length))
					{
						proxy_port_ = ntohs(service.sin6_port);
					}
					else
					{
						closesocket(server_socket_);
						server_socket_ = INVALID_SOCKET;
						return false;
					}
				}
			}

			if (const auto status = listen(server_socket_, SOMAXCONN); status == SOCKET_ERROR)
			{
				closesocket(server_socket_);
				server_socket_ = INVALID_SOCKET;
				return false;
			}

			return true;
		}

		bool connect_to_remote_host(SOCKET accepted)
		{
			auto [remote_ip, remote_port, negotiate_ctx] = get_remote_peer(accepted);

			if (!remote_port)
				return false;

			if (log_level_ > netlib::log::log_level::debug)
				log_printer(std::string("connect_to_remote_host:  ") + std::string{remote_ip} + " : " +
					std::to_string(remote_port));

			auto remote_socket = WSASocket(address_type_t::af_type, SOCK_STREAM, IPPROTO_TCP, nullptr, 0,
			                               WSA_FLAG_OVERLAPPED);

			if (remote_socket == INVALID_SOCKET)
			{
				return false;
			}

			if constexpr (address_type_t::af_type == AF_INET)
			{
				sockaddr_in sa_local{};
				sa_local.sin_family = address_type_t::af_type;
				sa_local.sin_port = htons(0);
				sa_local.sin_addr.s_addr = htonl(INADDR_ANY);

				// bind socket's name
				const auto status = bind(remote_socket, reinterpret_cast<sockaddr*>(&sa_local), sizeof(sockaddr));

				if (status == SOCKET_ERROR)
				{
					shutdown(remote_socket, SD_BOTH);
					closesocket(remote_socket);

					return false;
				}
			}
			else
			{
				sockaddr_in6 sa_local{};
				sa_local.sin6_family = address_type_t::af_type;
				sa_local.sin6_port = htons(0);
				sa_local.sin6_addr = in6addr_any;

				// bind socket's name
				const auto status = bind(remote_socket, reinterpret_cast<sockaddr*>(&sa_local), sizeof(sockaddr));

				if (status == SOCKET_ERROR)
				{
					shutdown(remote_socket, SD_BOTH);
					closesocket(remote_socket);

					return false;
				}
			}

			// enable non-blocking mode
			u_long mode = 1;
			auto ret = ioctlsocket(remote_socket, FIONBIO, &mode);

			// The client_service structure specifies the address family,
			// IP address, and port of the server to be connected to.
			{
				std::lock_guard lock(lock_);

				sock_array_events_.push_back(
					std::make_tuple(WSACreateEvent(), accepted, remote_socket, std::move(negotiate_ctx)));

				WSAEventSelect(remote_socket, std::get<0>(sock_array_events_.back()), FD_CONNECT);

				WSASetEvent(std::get<0>(sock_array_events_[0]));
			}

			// connect to server
			if constexpr (address_type_t::af_type == AF_INET)
			{
				sockaddr_in sa_service{};
				sa_service.sin_family = address_type_t::af_type;
				sa_service.sin_addr = remote_ip;
				sa_service.sin_port = htons(remote_port);

				if (connect(remote_socket, reinterpret_cast<SOCKADDR*>(&sa_service), sizeof(sa_service)) ==
					SOCKET_ERROR)
				{
					if (WSAGetLastError() != WSAEWOULDBLOCK)
					{
						shutdown(remote_socket, SD_BOTH);
						closesocket(remote_socket);

						return false;
					}
				}
			}
			else
			{
				sockaddr_in6 sa_service{};
				sa_service.sin6_family = address_type_t::af_type;
				sa_service.sin6_addr = remote_ip;
				sa_service.sin6_port = htons(remote_port);

				if (connect(remote_socket, reinterpret_cast<SOCKADDR*>(&sa_service), sizeof(sa_service)) ==
					SOCKET_ERROR)
				{
					if (WSAGetLastError() != WSAEWOULDBLOCK)
					{
						shutdown(remote_socket, SD_BOTH);
						closesocket(remote_socket);

						return false;
					}
				}
			}

			return true;
		}

		void start_proxy_thread()
		{
			while (end_server_ == false)
			{
				//
				// loop accepting connections from clients until proxy shuts down
				//
				const auto accepted = WSAAccept(server_socket_, nullptr, nullptr, nullptr, 0);

				if ((accepted == static_cast<UINT_PTR>(SOCKET_ERROR)) || end_server_)
				{
					break;
				}

				if (const auto connected = connect_to_remote_host(accepted); !connected)
				{
					closesocket(accepted);
				}
			}
		}

		void connect_to_remote_host_thread()
		{
			std::vector<WSAEVENT> wait_events;
			wait_events.reserve(connections_array_size);

			while (end_server_ == false)
			{
				// initialize wait events array
				wait_events.clear();

				{
					std::shared_lock lock(lock_);

					std::transform(sock_array_events_.cbegin(), sock_array_events_.cend(),
					               std::back_inserter(wait_events), [](auto&& e)
					               {
						               return std::get<0>(e);
					               });
				}

				const auto event_index = wait_for_multiple_objects(static_cast<DWORD>(wait_events.size()),
				                                                  wait_events.data(), INFINITE);

				if (end_server_ == true)
					break;

				if (event_index != 0)
				{
					std::lock_guard<std::shared_mutex> lock(lock_);

					WSACloseEvent(wait_events[event_index]);

					proxy_sockets_.push_back(std::make_unique<T>(
						std::get<1>(sock_array_events_[event_index]),
						std::get<2>(sock_array_events_[event_index]),
						std::move(std::get<3>(sock_array_events_[event_index])),
						log_printer_, log_level_));

					proxy_sockets_.back()->associate_to_completion_port(completion_key_, completion_port_);
					proxy_sockets_.back()->start();

					sock_array_events_.erase(sock_array_events_.begin() + event_index);
				}
				else
				{
					WSAResetEvent(wait_events[event_index]);
				}
			}

			// cleanup on exit
			std::shared_lock lock(lock_);

			for (auto&& a : sock_array_events_)
			{
				if (std::get<0>(a) != INVALID_HANDLE_VALUE)
				{
					WSACloseEvent(std::get<0>(a));
				}

				if (std::get<1>(a) != INVALID_SOCKET)
				{
					shutdown(std::get<1>(a), SD_BOTH);
					closesocket(std::get<1>(a));
					std::get<1>(a) = INVALID_SOCKET;
				}

				if (std::get<2>(a) != INVALID_SOCKET)
				{
					shutdown(std::get<2>(a), SD_BOTH);
					closesocket(std::get<2>(a));
					std::get<2>(a) = INVALID_SOCKET;
				}
			}
		}

		void clear_thread()
		{
			while (end_server_ == false)
			{
				{
					std::lock_guard lock(lock_);

					proxy_sockets_.erase(std::remove_if(proxy_sockets_.begin(), proxy_sockets_.end(), [](auto&& a)
					{
						return a->is_ready_for_removal();
					}), proxy_sockets_.end());
				}

				using namespace std::chrono_literals;
				std::this_thread::sleep_for(1000ms);
			}
		}

		void log_printer(const std::string& message) const
		{
			if (log_printer_)
			{
				log_printer_((std::string("tcp_proxy_server: ") + message).c_str());
			}
		}

		/**
		 * Function that waits for multiple objects (e.g. threads or processes)
		 * @param count Number of objects to wait for
		 * @param handles Array of handles to the objects
		 * @param ms Maximum time to wait for, in milliseconds
		 * @return WAIT_OBJECT_0 if the function succeeds, WAIT_TIMEOUT if the function times out
		 */
		static DWORD wait_for_multiple_objects(const DWORD count, const HANDLE* handles, const DWORD ms)
		{
			// Thread local seed for rand_r
			static thread_local auto seed = static_cast<uint32_t>(time(nullptr));

			// Initial result set to timeout
			DWORD result = WAIT_TIMEOUT;

			// If the number of objects is greater than the maximum allowed...
			if (count >= MAXIMUM_WAIT_OBJECTS)
			{
				// Loop until a handle is signaled or until the timeout is reached if timeout is infinite
				do
				{
					// Divide the number of handles in half
					const DWORD split = count / 2;

					// Divide the wait time in half, if timeout is infinite, use a default wait time of 2000ms
					const DWORD wait = (ms == INFINITE ? 2000 : ms) / 2;
					const int random = rand_s(&seed);

					// Recurse on both halves in a random order until a handle is signaled or all handles are checked
					for (short branch = 0; branch < 2 && result == WAIT_TIMEOUT; branch++)
					{
						if (random % 2 == branch)
						{
							// Wait for the lower half of handles
							result = wait_for_multiple_objects(split, handles, wait);
						}
						else
						{
							// Wait for the upper half of handles, adjust result if a handle is signaled
							result = wait_for_multiple_objects(count - split, handles + split, wait);
							if (result >= WAIT_OBJECT_0 && result < WAIT_OBJECT_0 + split) result += split;
						}
					}
				} while (ms == INFINITE && result == WAIT_TIMEOUT);
			}
			else
			{
				// If the number of handles is within limit, use the native win32 function
				result = ::WaitForMultipleObjects(count, handles, FALSE, ms);
			}

			// Return the result
			return result;
		}

	};
}

```

`examples/cpp/common/proxy/tcp_proxy_socket.h`:

```h
#pragma once

namespace proxy
{
	enum class connection_status
	{
		client_no_change = 0,
		client_connected,
		client_established,
		client_completed,
	};

	template <typename T>
	class tcp_proxy_socket;

	template <typename T>
	struct tcp_per_io_context : WSAOVERLAPPED
	{
		tcp_per_io_context(const proxy_io_operation io_operation, tcp_proxy_socket<T>* socket, const bool is_local)
			: WSAOVERLAPPED{0, 0, {{0, 0}}, nullptr},
			  io_operation(io_operation),
			  proxy_socket_ptr(socket),
			  is_local(is_local)
		{
		}

		proxy_io_operation io_operation;
		tcp_proxy_socket<T>* proxy_socket_ptr;
		WSABUF wsa_buf{0, nullptr};
		bool is_local;
	};

	template <typename T>
	class tcp_proxy_server;

	// ReSharper disable once CppClassCanBeFinal
	template <typename T>
	class tcp_proxy_socket
	{
		friend tcp_proxy_server<tcp_proxy_socket<T>>;

	public:
		using address_type_t = T;
		using negotiate_context_t = negotiate_context<T>;
		using per_io_context_t = tcp_per_io_context<T>;

	protected:
		constexpr static size_t send_receive_buffer_size = 65536;

		/// <summary>local connection socket</summary>
		SOCKET local_socket_;
		/// <summary>remote connection socket</summary>
		SOCKET remote_socket_;

		std::unique_ptr<negotiate_context_t> negotiate_ctx_;

		/// <summary>message logging function</summary>
		std::function<void(const char*)> log_printer_;
		/// <summary>logging level</summary>
		netlib::log::log_level log_level_;

		bool is_disable_nagle_;

		/// <summary>provides synchronization for the I/O operations</summary>
		std::mutex lock_;
		connection_status connection_status_{connection_status::client_connected};

		std::array<char, send_receive_buffer_size> from_local_to_remote_buffer_{};
		std::array<char, send_receive_buffer_size> from_remote_to_local_buffer_{};

		WSABUF local_recv_buf_{
			static_cast<ULONG>(from_local_to_remote_buffer_.size()), from_local_to_remote_buffer_.data()
		};
		WSABUF local_send_buf_{0, nullptr};
		WSABUF remote_recv_buf_{
			static_cast<ULONG>(from_remote_to_local_buffer_.size()), from_remote_to_local_buffer_.data()
		};
		WSABUF remote_send_buf_{0, nullptr};

		std::chrono::steady_clock::time_point timestamp_{ std::chrono::steady_clock::now() };

		per_io_context_t io_context_recv_from_local_{proxy_io_operation::relay_io_read, this, true};
		per_io_context_t io_context_recv_from_remote_{proxy_io_operation::relay_io_read, this, false};
		per_io_context_t io_context_send_to_local_{proxy_io_operation::relay_io_write, this, true};
		per_io_context_t io_context_send_to_remote_{proxy_io_operation::relay_io_write, this, false};

	public:
		tcp_proxy_socket(const SOCKET local_socket, const SOCKET remote_socket,
		                 std::unique_ptr<negotiate_context_t> negotiate_ctx,
		                 std::function<void(const char*)> log_printer, const netlib::log::log_level log_level,
		                 const bool disable_nagle = false)
			: local_socket_(local_socket),
			  remote_socket_(remote_socket),
			  negotiate_ctx_(std::move(negotiate_ctx)),
			  log_printer_(std::move(log_printer)),
			  log_level_(log_level),
			  is_disable_nagle_(disable_nagle)
		{}

		virtual ~tcp_proxy_socket()
		{
			std::lock_guard lock(lock_);

			if (local_socket_ != INVALID_SOCKET)
			{
				shutdown(local_socket_, SD_BOTH);

				closesocket(local_socket_);

				local_socket_ = INVALID_SOCKET;
			}

			if (remote_socket_ != INVALID_SOCKET)
			{
				shutdown(remote_socket_, SD_BOTH);

				closesocket(remote_socket_);

				remote_socket_ = INVALID_SOCKET;
			}
		}

		tcp_proxy_socket(const tcp_proxy_socket& other) = delete;

		tcp_proxy_socket& operator=(const tcp_proxy_socket& other) = delete;

		// ReSharper disable once CppSpecialFunctionWithoutNoexceptSpecification
		tcp_proxy_socket(tcp_proxy_socket&& other)
		{
			std::scoped_lock lock(lock_, other.lock_);
			
			local_socket_ = other.local_socket_;
			other.local_socket_ = INVALID_SOCKET;
			remote_socket_ = other.remote_socket_;
			other.remote_socket_ = INVALID_SOCKET;
			negotiate_ctx_ = std::move(other.negotiate_ctx_);
			log_printer_ = std::move(other.log_printer_);
			log_level_ = other.log_level_;
			is_disable_nagle_ = other.is_disable_nagle_;
			connection_status_ = other.connection_status_;
			from_local_to_remote_buffer_ = std::move(other.from_local_to_remote_buffer_);
			from_remote_to_local_buffer_ = std::move(other.from_remote_to_local_buffer_);
			local_recv_buf_ = std::move(other.local_recv_buf_);
			local_send_buf_ = std::move(other.local_send_buf_);
			remote_recv_buf_ = std::move(other.remote_recv_buf_);
			remote_send_buf_ = std::move(other.remote_send_buf_);
			timestamp_ = std::move(other.timestamp_);
			io_context_recv_from_local_ = std::move(other.io_context_recv_from_local_);
			io_context_recv_from_remote_ = std::move(other.io_context_recv_from_remote_);
			io_context_send_to_local_ = std::move(other.io_context_send_to_local_);
			io_context_send_to_remote_ = std::move(other.io_context_send_to_remote_);
		}

		// ReSharper disable once CppSpecialFunctionWithoutNoexceptSpecification
		tcp_proxy_socket& operator=(tcp_proxy_socket&& other)
		{
			using std::swap;
			swap(*this, other);
			return *this;
		}

		bool associate_to_completion_port(const ULONG_PTR completion_key, winsys::io_completion_port& completion_port)
		{
			connection_status_ = connection_status::client_established;

			if ((local_socket_ != INVALID_SOCKET) && (remote_socket_ != INVALID_SOCKET))
				return completion_port.associate_socket(local_socket_, completion_key) &&
					completion_port.associate_socket(remote_socket_, completion_key);
			return false;
		}

		template <bool AlreadyLocked = false>
		void close_client(const bool is_receive, const bool is_local)
		{
			std::unique_lock lock(lock_, std::defer_lock);

			if constexpr (!AlreadyLocked)
			{
				lock.lock();
			}

			if (is_local)
			{
				if (local_socket_ != INVALID_SOCKET)
				{
					shutdown(local_socket_, SD_BOTH);
					closesocket(local_socket_);
					local_socket_ = INVALID_SOCKET;
					connection_status_ = connection_status::client_completed;
				}

				if (is_receive)
				{
					local_recv_buf_.len = 0;
				}
				else
				{
					local_send_buf_.len = 0;
				}

				if (remote_socket_ != INVALID_SOCKET)
				{
					shutdown(remote_socket_, SD_BOTH);
					closesocket(remote_socket_);
					remote_socket_ = INVALID_SOCKET;
				}
			}
			else
			{
				if (remote_socket_ != INVALID_SOCKET)
				{
					shutdown(remote_socket_, SD_BOTH);
					closesocket(remote_socket_);
					remote_socket_ = INVALID_SOCKET;
					connection_status_ = connection_status::client_completed;
				}

				if (is_receive)
				{
					remote_recv_buf_.len = 0;
				}
				else
				{
					remote_send_buf_.len = 0;
				}

				if (local_socket_ != INVALID_SOCKET)
				{
					shutdown(local_socket_, SD_BOTH);
					closesocket(local_socket_);
					local_socket_ = INVALID_SOCKET;
				}
			}
		}

		bool is_ready_for_removal()
		{
			using namespace std::chrono_literals;

			std::lock_guard lock(lock_);

			if ((remote_socket_ == INVALID_SOCKET) && 
				(local_socket_ == INVALID_SOCKET))
			{
				if ((remote_send_buf_.len == 0 &&
					local_send_buf_.len == 0 &&
					remote_recv_buf_.len == 0 &&
					local_recv_buf_.len == 0))
				{
					return true;
				}
			}

			if (std::chrono::steady_clock::now() - timestamp_ > 120s)
			{
				if ((remote_socket_ == INVALID_SOCKET) &&
					(local_socket_ == INVALID_SOCKET))
				{
					close_client<true>(true, true);
					close_client<true>(true, false);
				}
				else
				{
					close_client<true>(false, true);
					close_client<true>(false, false);
					timestamp_ += 10s;
				}
			}

			return false;
		}

		// ********************************************************************************
		/// <summary>
		/// Attempts to negotiate credentials for local and remote sockets and starts 
		/// data relay between them
		/// </summary>
		/// <returns>true is relay was started, false otherwise</returns>
		// ********************************************************************************
		virtual bool start()
		{
			if (is_disable_nagle_)
			{
				auto i = 1;
				setsockopt(remote_socket_, IPPROTO_TCP, TCP_NODELAY, reinterpret_cast<char*>(&i), sizeof(i));
			}

			if (local_negotiate() && (remote_negotiate()))
			{
				// if negotiate phase can be complete immediately (or not needed at all)
				// start data relay here
				return start_data_relay();
			}
			// otherwise start_data_relay should be called from 
			// process_receive_negotiate_complete/process_send_negotiate_complete
			return false;
		}

		virtual void process_receive_negotiate_complete(const uint32_t io_size, per_io_context_t* io_context)
		{
			std::lock_guard lock(lock_);
			timestamp_ = std::chrono::steady_clock::now();
		}

		virtual void process_send_negotiate_complete(const uint32_t io_size, per_io_context_t* io_context)
		{
			std::lock_guard lock(lock_);
			timestamp_ = std::chrono::steady_clock::now();
		}

		virtual void process_receive_buffer_complete(const uint32_t io_size, per_io_context_t* io_context)
		{
			std::lock_guard lock(lock_);

			timestamp_ = std::chrono::steady_clock::now();

			switch (connection_status_)
			{
			case connection_status::client_completed:
				{
					if (io_context->is_local)
					{
						local_recv_buf_.len = 0;
					}
					else
					{
						remote_recv_buf_.len = 0;
					}

					break;
				}
			case connection_status::client_established:
				{
					if (io_context->is_local)
					{
						if (log_level_ > netlib::log::log_level::debug)
							log_printer(
								std::string(
									"process_receive_buffer_complete: data received from locally connected socket: ")
								+ std::to_string(io_size));

						// data received from locally connected socket
						if (remote_send_buf_.len == 0)
						{
							// if there is no "send to remotely connected socket" in progress
							// then forward the received data to remote host
							remote_send_buf_.buf = local_recv_buf_.buf;
							remote_send_buf_.len = io_size;

							if (log_level_ > netlib::log::log_level::debug)
								log_printer(
									std::string(
										"process_receive_buffer_complete: sending data to remotely connected socket: ")
									+ std::to_string(io_size));

							if ((::WSASend(
								remote_socket_,
								&remote_send_buf_,
								1,
								nullptr,
								0,
								&io_context_send_to_remote_,
								nullptr) == SOCKET_ERROR) && (ERROR_IO_PENDING != WSAGetLastError()))
							{
								// Close connection to remote peer in case of error
								close_client<true>(false, false);
							}
						}

						// shift the receive buffer for the amount of received data
						// buffer is cyclic, adjust the available buffer size
						// if end of the buffer is reached then go from the start
						local_recv_buf_.buf += io_size;

						if (local_recv_buf_.buf > remote_send_buf_.buf)
						{
							if (local_recv_buf_.buf < from_local_to_remote_buffer_.data() + from_local_to_remote_buffer_
								.size())
							{
								local_recv_buf_.len = static_cast<ULONG>(from_local_to_remote_buffer_.data() +
									from_local_to_remote_buffer_.size() - local_recv_buf_.buf);
							}
							else
							{
								local_recv_buf_.buf = from_local_to_remote_buffer_.data();
								local_recv_buf_.len = static_cast<ULONG>(remote_send_buf_.buf -
									from_local_to_remote_buffer_.data());
							}
						}
						else
						{
							local_recv_buf_.len = static_cast<ULONG>(remote_send_buf_.buf - local_recv_buf_.buf);
						}

						// initiate the new receive if we have space in receive buffer
						if (local_recv_buf_.len)
						{
							DWORD flags = 0;

							if ((::WSARecv(
								local_socket_,
								&local_recv_buf_,
								1,
								nullptr,
								&flags,
								&io_context_recv_from_local_,
								nullptr) == SOCKET_ERROR) && (ERROR_IO_PENDING != WSAGetLastError()))
							{
								// Close connection to local peer in case of error
								close_client<true>(true, true);
							}
						}
					}
					else
					{
						if (log_level_ > netlib::log::log_level::debug)
							log_printer(
								std::string(
									"process_receive_buffer_complete: data received from remotely connected socket: ")
								+ std::to_string(io_size));

						// data received from remotely connected socket
						if (local_send_buf_.len == 0)
						{
							// if there is no "send to locally connected socket" in progress
							// then forward the received data to local host
							local_send_buf_.buf = remote_recv_buf_.buf;
							local_send_buf_.len = io_size;

							if (log_level_ > netlib::log::log_level::debug)
								log_printer(
									std::string(
										"process_receive_buffer_complete: sending data to locally connected socket: ")
									+ std::to_string(io_size));

							if ((::WSASend(
								local_socket_,
								&local_send_buf_,
								1,
								nullptr,
								0,
								&io_context_send_to_local_,
								nullptr) == SOCKET_ERROR) && (ERROR_IO_PENDING != WSAGetLastError()))
							{
								// Close connection to local peer in case of error
								close_client<true>(false, true);
							}
						}

						// shift the receive buffer for the amount of received data
						// buffer is cyclic, adjust the available buffer size
						// if end of the buffer is reached then go from the start
						remote_recv_buf_.buf += io_size;

						if (remote_recv_buf_.buf > local_send_buf_.buf)
						{
							if (remote_recv_buf_.buf < from_remote_to_local_buffer_.data() +
								from_remote_to_local_buffer_.size())
							{
								remote_recv_buf_.len = static_cast<DWORD>(from_remote_to_local_buffer_.data() +
									from_remote_to_local_buffer_.size() - remote_recv_buf_.buf
								);
							}
							else
							{
								remote_recv_buf_.buf = from_remote_to_local_buffer_.data();
								remote_recv_buf_.len = static_cast<DWORD>(local_send_buf_.buf -
									from_remote_to_local_buffer_.data());
							}
						}
						else
						{
							remote_recv_buf_.len = static_cast<DWORD>(local_send_buf_.buf - remote_recv_buf_.buf);
						}

						// initiate the new receive if we have space in receive buffer
						if (remote_recv_buf_.len)
						{
							DWORD flags = 0;

							if ((::WSARecv(
								remote_socket_,
								&remote_recv_buf_,
								1,
								nullptr,
								&flags,
								&io_context_recv_from_remote_,
								nullptr) == SOCKET_ERROR) && (ERROR_IO_PENDING != WSAGetLastError()))
							{
								// Close connection to remote peer in case of error
								close_client<true>(true, false);
							}
						}
					}

					break;
				}
			case connection_status::client_no_change:
			case connection_status::client_connected:
				break;
			}
		}

		virtual void process_send_buffer_complete(const uint32_t io_size, per_io_context_t* io_context)
		{
			std::lock_guard lock(lock_);

			timestamp_ = std::chrono::steady_clock::now();

			if (io_context->is_local)
			{
				if (log_level_ > netlib::log::log_level::debug)
					log_printer(std::string("process_send_buffer_complete: send complete to locally connected socket: ")
						+ std::to_string(io_size));

				if (connection_status_ != connection_status::client_completed)
				{
					if (remote_recv_buf_.len == 0)
					{
						DWORD flags = 0;

						remote_recv_buf_.buf = local_send_buf_.buf;
						remote_recv_buf_.len = io_size;

						if (remote_recv_buf_.len > 0)
						{
							if ((::WSARecv(
								remote_socket_,
								&remote_recv_buf_,
								1,
								nullptr,
								&flags,
								&io_context_recv_from_remote_,
								nullptr) == SOCKET_ERROR) && (ERROR_IO_PENDING != WSAGetLastError()))
							{
								close_client<true>(true, false);
							}
						}
					}
				}

				local_send_buf_.buf += io_size;

				if (local_send_buf_.buf == from_remote_to_local_buffer_.data() + from_remote_to_local_buffer_.size())
				{
					local_send_buf_.buf = from_remote_to_local_buffer_.data();
				}

				if (local_send_buf_.buf == remote_recv_buf_.buf)
				{
					if (connection_status_ == connection_status::client_completed)
					{
						close_client<true>(false, false);
					}

					local_send_buf_.len = 0;
				}
				else
				{
					if (local_send_buf_.buf < remote_recv_buf_.buf)
					{
						local_send_buf_.len = static_cast<ULONG>(remote_recv_buf_.buf - local_send_buf_.buf);
					}
					else
					{
						local_send_buf_.len = static_cast<ULONG>(from_remote_to_local_buffer_.data() +
							from_remote_to_local_buffer_.size() - local_send_buf_.buf);
					}

					if (local_send_buf_.len)
					{
						if (log_level_ > netlib::log::log_level::debug)
							log_printer(
								std::string("process_send_buffer_complete: sending data to locally connected socket: ")
								+ std::to_string(io_size));

						if ((::WSASend(
							local_socket_,
							&local_send_buf_,
							1,
							nullptr,
							0,
							&io_context_send_to_local_,
							nullptr) == SOCKET_ERROR) && (ERROR_IO_PENDING != WSAGetLastError()))
						{
							close_client<true>(false, true);
						}
					}
				}
			}
			else
			{
				if (log_level_ > netlib::log::log_level::debug)
					log_printer(
						std::string("process_send_buffer_complete: send complete to remotely connected socket: ")
						+ std::to_string(io_size));

				if (connection_status_ != connection_status::client_completed)
				{
					if (local_recv_buf_.len == 0)
					{
						DWORD flags = 0;

						local_recv_buf_.buf = remote_send_buf_.buf;
						local_recv_buf_.len = io_size;

						if (local_recv_buf_.len)
						{
							if ((::WSARecv(
								local_socket_,
								&local_recv_buf_,
								1,
								nullptr,
								&flags,
								&io_context_recv_from_local_,
								nullptr) == SOCKET_ERROR) && (ERROR_IO_PENDING != WSAGetLastError()))
							{
								close_client<true>(true, true);
							}
						}
					}
				}

				remote_send_buf_.buf += io_size;

				if (remote_send_buf_.buf == from_local_to_remote_buffer_.data() + from_local_to_remote_buffer_.size())
				{
					remote_send_buf_.buf = from_local_to_remote_buffer_.data();
				}

				if (remote_send_buf_.buf == local_recv_buf_.buf)
				{
					if (connection_status_ == connection_status::client_completed)
					{
						close_client<true>(false, false);
					}

					remote_send_buf_.len = 0;
				}
				else
				{
					if (remote_send_buf_.buf < local_recv_buf_.buf)
					{
						remote_send_buf_.len = static_cast<ULONG>(local_recv_buf_.buf - remote_send_buf_.buf);
					}
					else
					{
						remote_send_buf_.len = static_cast<ULONG>(from_local_to_remote_buffer_.data() +
							from_local_to_remote_buffer_.size() - remote_send_buf_.buf);
					}

					if (remote_send_buf_.len)
					{
						if (log_level_ > netlib::log::log_level::debug)
							log_printer(
								std::string("process_send_buffer_complete: sending data to remotely connected socket: ")
								+ std::to_string(io_size));

						if ((::WSASend(
							remote_socket_,
							&remote_send_buf_,
							1,
							nullptr,
							0,
							&io_context_send_to_remote_,
							nullptr) == SOCKET_ERROR) && (ERROR_IO_PENDING != WSAGetLastError()))
						{
							close_client<true>(false, false);
						}
					}
				}
			}
		}

		static void process_inject_buffer_complete(per_io_context_t* context)
		{
			if (context->wsa_buf.buf != nullptr)
				delete[] context->wsa_buf.buf;

			delete context;
		}

		// ********************************************************************************
		/// <summary>
		/// Sends block of data into local socket
		/// </summary>
		/// <param name="data">data buffer</param>
		/// <param name="length">length of the data to send</param>
		/// <param name="type">type of operation</param>
		/// <returns>pre-status of the operation</returns>
		// ********************************************************************************
		bool inject_to_local(const char* data, const uint32_t length,
		                     proxy_io_operation type = proxy_io_operation::inject_io_write)
		{
			auto context = new(std::nothrow) per_io_context_t{type, this, true};

			if (context == nullptr)
				return false;

			context->wsa_buf.buf = new(std::nothrow) char[length];

			if (context->wsa_buf.buf == nullptr)
			{
				delete context;
				return false;
			}

			memmove(context->wsa_buf.buf, data, length);

			context->wsa_buf.len = length;

			if ((::WSASend(
				local_socket_,
				&context->wsa_buf,
				1,
				nullptr,
				0,
				context,
				nullptr) == SOCKET_ERROR) && (ERROR_IO_PENDING != WSAGetLastError()))
			{
				close_client(false, true);
				return false;
			}

			return true;
		}

		// ********************************************************************************
		/// <summary>
		/// Sends block of data into remote socket
		/// </summary>
		/// <param name="data">data buffer</param>
		/// <param name="length">length of the data to send</param>
		/// <param name="type">type of operation</param>
		/// <returns>pre-status of the operation</returns>
		// ********************************************************************************
		bool inject_to_remote(const char* data, const uint32_t length,
		                      proxy_io_operation type = proxy_io_operation::inject_io_write)
		{
			auto context = new(std::nothrow) per_io_context_t{type, this, false};

			if (context == nullptr)
				return false;

			context->wsa_buf.buf = new(std::nothrow) char[length];

			if (context->wsa_buf.buf == nullptr)
			{
				delete context;
				return false;
			}

			memmove(context->wsa_buf.buf, data, length);

			context->wsa_buf.len = length;

			if ((::WSASend(
				remote_socket_,
				&context->wsa_buf,
				1,
				nullptr,
				0,
				context,
				nullptr) == SOCKET_ERROR) && (ERROR_IO_PENDING != WSAGetLastError()))
			{
				close_client(false, false);
				return false;
			}

			return true;
		}

	protected:
		// ********************************************************************************
		/// <summary>
		/// Queries a pointer to the negotiate_context
		/// </summary>
		/// <returns> raw pointer to the negotiate_context</returns>
		// ********************************************************************************
		[[nodiscard]] negotiate_context_t* get_negotiate_ctx() const
		{
			return negotiate_ctx_.get();
		}

		virtual bool local_negotiate()
		{
			return true;
		}

		virtual bool remote_negotiate()
		{
			return true;
		}

		bool start_data_relay()
		{
			DWORD flags = 0;

			auto ret = WSARecv(local_socket_, &local_recv_buf_, 1,
			                   nullptr, &flags, &io_context_recv_from_local_, nullptr);

			if (const auto wsa_error = WSAGetLastError(); ret == SOCKET_ERROR && (ERROR_IO_PENDING != wsa_error))
			{
				close_client(true, true);

				remote_recv_buf_.len = 0;

				return false;
			}

			ret = WSARecv(remote_socket_, &remote_recv_buf_, 1,
			              nullptr, &flags, &io_context_recv_from_remote_, nullptr);

			if (const auto wsa_error = WSAGetLastError(); ret == SOCKET_ERROR && (ERROR_IO_PENDING != wsa_error))
			{
				closesocket(local_socket_);

				close_client(true, false);

				return false;
			}

			return true;
		}

	private:
		void log_printer(const std::string& message) const
		{
			if (log_printer_)
			{
				log_printer_((std::string("tcp_proxy_socket: ") + message).c_str());
			}
		}
	};
}

```

`examples/cpp/common/tools/strings.h`:

```h
#pragma once
#include <string>
#include <vector>
#include <sstream>

namespace tools::strings
{
	inline std::wstring to_wstring(const std::string& str)
	{
		int requiredSize = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, NULL, 0);
		if (requiredSize == 0)
		{
			// Handle error
			return L"";
		}

		std::wstring wstr(requiredSize - 1, '\0');
		int result = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, &wstr[0], requiredSize);
		if (result == 0)
		{
			// Handle error
			return L"";
		}

		return wstr;
	}

	inline std::string to_string(const std::wstring& wstr)
	{
		int requiredSize = WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, NULL, 0, NULL, NULL);
		if (requiredSize == 0)
		{
			// Handle error
			return "";
		}

		std::string str(requiredSize - 1, '\0');
		int result = WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, &str[0], requiredSize, NULL, NULL);
		if (result == 0)
		{
			// Handle error
			return "";
		}

		return str;
	}

	inline std::vector<std::string> split_string(const std::string& input, const char sep)
	{
		std::stringstream ss(input);
		std::string segment;
		std::vector<std::string> strings;

		while (std::getline(ss, segment, sep))
		{
			strings.push_back(segment);
		}

		return strings;
	}

	inline std::vector<std::wstring> split_string(const std::wstring& input, const wchar_t sep)
	{
		std::wstringstream wss(input);
		std::wstring segment;
		std::vector<std::wstring> strings;

		while (std::getline(wss, segment, sep))
		{
			strings.push_back(segment);
		}

		return strings;
	}
}

```

`examples/cpp/common/winsys/event.h`:

```h
#pragma once

#pragma warning( push )
#pragma warning( disable : 26456 )

namespace winsys
{
	// --------------------------------------------------------------------------------
	/// <summary>
	/// Simple wrapper for Windows event object
	/// </summary>
	// --------------------------------------------------------------------------------
	class safe_event final : public safe_object_handle
	{
	public:
		/// <summary>
		/// Constructs safe_event from the even object handle
		/// </summary>
		// ReSharper disable once CppParameterMayBeConst
		explicit safe_event(HANDLE handle = nullptr) noexcept: safe_object_handle(handle)
		{
		}

		/// <summary>
		/// Deleted copy constructor
		/// </summary>
		safe_event(const safe_event& other) = delete;

		/// <summary>
		/// Move constructor
		/// </summary>
		/// <param name="other">Object instance to move from</param>
		safe_event(safe_event&& other) noexcept
			: safe_object_handle{std::move(other)}
		{
		}

		/// <summary>
		/// Deleted copy assignment
		/// </summary>
		safe_event& operator=(const safe_event& other) = delete;

		/// <summary>
		/// Move assignment
		/// </summary>
		/// <param name="other">Object instance to move from</param>
		/// <returns>this object instance</returns>
		safe_event& operator=(safe_event&& other) noexcept
		{
			if (this == &other)
				return *this;
			safe_object_handle::operator =(std::move(other));
			return *this;
		}

		/// <summary>
		/// Default destructor 
		/// </summary>
		~safe_event() = default;

		/// <summary>
		/// Waits on the event 
		/// </summary>
		/// <param name="dw_milliseconds">Wait timeout in milliseconds</param>
		/// <returns>value returned by WaitForSingleObject</returns>
		[[nodiscard]] unsigned wait(const unsigned dw_milliseconds) const noexcept
		{
			return WaitForSingleObject(get(), dw_milliseconds);
		}

		/// <summary>
		/// Signals the event object
		/// </summary>
		/// <returns>true if the function succeeds, false otherwise</returns>
		[[nodiscard]] bool signal() const noexcept
		{
			return SetEvent(get()) ? true : false;
		}

		/// <summary>
		/// Resets event
		/// </summary>
		/// <returns>true if the function succeeds, false otherwise</returns>
		[[nodiscard]] bool reset_event() const noexcept
		{
			return ResetEvent(get()) ? true : false;
		}
	};
}
#pragma warning( pop )

```

`examples/cpp/common/winsys/io_completion_port.h`:

```h
#pragma once

namespace winsys
{
	// --------------------------------------------------------------------------------
	/// <summary>
	/// represents a thread pool for the derived CRTP classes
	/// \tparam T CRTP derived class should provide start_thread and stop_thread routines
	/// </summary>
	// --------------------------------------------------------------------------------
	template <typename T>
	class thread_pool
	{
		/// <summary>working threads container</summary>
		std::vector<std::thread> threads_;

	protected:
		/// <summary>thread pool termination flag</summary>
		std::atomic_bool active_{false};
		/// <summary>number of concurrent threads in the pool</summary>
		uint32_t concurrent_threads_;

	public:
		thread_pool(const thread_pool& other) = delete;

		thread_pool(thread_pool&& other) noexcept
			: threads_(std::move(other.threads_)),
			  active_(other.active_.load()),
			  concurrent_threads_(other.concurrent_threads_)
		{
		}

		thread_pool& operator=(const thread_pool& other) = delete;

		thread_pool& operator=(thread_pool&& other) noexcept
		{
			if (this == &other)
				return *this;
			threads_ = std::move(other.threads_);
			active_ = other.active_.load();
			concurrent_threads_ = other.concurrent_threads_;
			return *this;
		}

		~thread_pool() = default;

		// ********************************************************************************
		/// <summary>
		/// initializes thread_pool with specified number of concurrent threads
		/// </summary>
		/// <param name="concurrent_threads">number of concurrent threads in the pool</param>
		/// <returns></returns>
		// ********************************************************************************
		explicit thread_pool(const uint32_t concurrent_threads = 0) noexcept:
			concurrent_threads_{(concurrent_threads == 0) ? std::thread::hardware_concurrency() : concurrent_threads}
		{
		}

		// ********************************************************************************
		/// <summary>
		/// starts threads in the pool if not already started
		/// </summary>
		// ********************************************************************************
		void start_thread_pool()
		{
			if (active_ == true)
				return;

			active_ = true;

			// Create twice as many threads as may run concurrently
			for (size_t i = 0; i < concurrent_threads_ * 2; ++i)
			{
				threads_.push_back(std::thread(&T::start_thread, static_cast<T*>(this)));
			}
		}

		// ********************************************************************************
		/// <summary>
		/// stops threads in the pool using CRTP derived class stop_thread method
		/// </summary>
		// ********************************************************************************
		void stop_thread_pool()
		{
			if (active_ == false)
				return;

			active_ = false;

			for (size_t i = 0; i < threads_.size(); ++i)
			{
				static_cast<T&>(*this).stop_thread();
			}

			for (auto&& thread: threads_)
			{
				if (thread.joinable())
					thread.join();
			}
		}
	};

	// --------------------------------------------------------------------------------
	/// <summary>
	/// Windows I/O completion port wrapper with internal thread pool
	/// </summary>
	// --------------------------------------------------------------------------------
	class io_completion_port final : public safe_object_handle, public thread_pool<io_completion_port>
	{
		friend thread_pool;

		using mutex_type = std::shared_mutex;
		using read_lock = std::shared_lock<mutex_type>;
		using write_lock = std::unique_lock<mutex_type>;
	public:
		// ********************************************************************************
		/// <summary>
		/// type of completion key callback
		/// </summary>
		/// <param name="DWORD"></param>
		/// <param name="OVERLAPPED*"></param>
		/// <returns>boolean status of operation</returns>
		// ********************************************************************************
		using callback_t = bool(DWORD, OVERLAPPED*, BOOL);

		io_completion_port(const io_completion_port& other) = delete;

		io_completion_port(io_completion_port&& other) noexcept // NOLINT(bugprone-exception-escape)
			: safe_object_handle(std::move(static_cast<safe_object_handle&>(other))),
			  thread_pool<io_completion_port>(std::move(static_cast<thread_pool<io_completion_port>&>(other)))
			  
		{
			write_lock rhs_lk(other.handlers_lock_);
			handlers_ = std::move(other.handlers_);
			handlers_keys_ = std::move(other.handlers_keys_);
		}

		io_completion_port& operator=(const io_completion_port& other) = delete;

		io_completion_port& operator=(io_completion_port&& other) noexcept  // NOLINT(bugprone-exception-escape)
		{
			if (this == &other)
				return *this;

			write_lock lhs_lk(handlers_lock_, std::defer_lock);
			write_lock rhs_lk(other.handlers_lock_, std::defer_lock);
			std::lock(lhs_lk, rhs_lk);

			safe_object_handle::operator =(std::move(static_cast<safe_object_handle&>(other)));
			thread_pool<io_completion_port>::operator
				=(std::move(static_cast<thread_pool<io_completion_port>&>(other)));
			handlers_ = std::move(other.handlers_);
			handlers_keys_ = std::move(other.handlers_keys_);
			return *this;
		}

	private:
		/// <summary>synchronization lock for handlers below (accessed concurrently)</summary>
		mutex_type handlers_lock_;
		/// <summary>callback handlers storage</summary>
		std::vector<std::unique_ptr<std::function<callback_t>>> handlers_;
		/// <summary>callback keys (convertible to pointers in the storage above)</summary>
		std::set<ULONG_PTR> handlers_keys_;

		// ********************************************************************************
		/// <summary>
		/// working thread routine (calls stored functions by the I/O completion key)
		/// </summary>
		// ********************************************************************************
		void start_thread() const
		{
			DWORD num_bytes;
			ULONG_PTR completion_key;
			OVERLAPPED* overlapped_ptr;

			do
			{
				const auto ok =
					GetQueuedCompletionStatus(get(), &num_bytes, &completion_key, &overlapped_ptr, INFINITE);

				if (!active_)
					return;

				if (completion_key)
				{
					if (const auto* const handler = reinterpret_cast<std::function<callback_t>*>(completion_key); *handler)  // NOLINT(performance-no-int-to-ptr)
					{
						(*handler)(num_bytes, overlapped_ptr, ok);
					}
				}
			}
			while (active_);
		}

		// ********************************************************************************
		/// <summary>
		/// signals threads in the thread pool to check for exit
		/// </summary>
		// ********************************************************************************
		void stop_thread() const noexcept
		{
			OVERLAPPED overlapped{};
			PostQueuedCompletionStatus(get(), 0, 0, &overlapped);
		}

	public:
		// ********************************************************************************
		/// <summary>
		/// constructs io_completion_port object from the existing HANDLE
		/// </summary>
		/// <param name="handle">existing I/O completion port handle</param>
		/// <param name="concurrent_threads">number of concurrent threads for I/O completion port (zero means as many threads as cores)</param>
		/// <returns></returns>
		// ********************************************************************************
		explicit io_completion_port(HANDLE handle, const uint32_t concurrent_threads = 0) :
			safe_object_handle(handle),
			thread_pool<io_completion_port>(concurrent_threads)
		{
		}

		// ********************************************************************************
		/// <summary>
		/// constructs a new I/O completion port
		/// </summary>
		/// <param name="concurrent_threads">number of concurrent threads for I/O completion port</param>
		/// <returns></returns>
		// ********************************************************************************
		explicit io_completion_port(const uint32_t concurrent_threads = 0):
			io_completion_port(
				CreateIoCompletionPort(
					INVALID_HANDLE_VALUE,
					nullptr,
					0,
					static_cast<DWORD>(concurrent_threads)),
				concurrent_threads
			)
		{
		}

		// ********************************************************************************
		/// <summary>
		/// destructor terminates the internal thread pool
		/// </summary>
		/// <returns></returns>
		// ********************************************************************************
		~io_completion_port()
		{
			if (active_ == false)
				return;

			try {
				stop_thread_pool();
			}
			catch(...)
			{
			}
		}

		// ********************************************************************************
		/// <summary>
		/// returns number of concurrent threads for I/O completion port
		/// </summary>
		/// <returns>number of concurrent threads for I/O completion port</returns>
		// ********************************************************************************
		uint32_t get_concurrent_threads_num() const noexcept { return concurrent_threads_; }

		// ********************************************************************************
		/// <summary>
		/// returns number of concurrent threads in the internal thread pool
		/// </summary>
		/// <returns>number of concurrent threads in the internal thread pool</returns>
		// ********************************************************************************
		uint32_t get_working_threads_num() const noexcept { return concurrent_threads_ * 2; }

		// ********************************************************************************
		/// <summary>
		/// associates the device with I/O completion port
		/// </summary>
		/// <param name="file_object">device file object</param>
		/// <param name="io_handler">callback handler for the device associated I/O</param>
		/// <returns>pair of status of the operation and associated I/O completion port key value</returns>
		// ********************************************************************************
		std::pair<bool, ULONG_PTR> associate_device(HANDLE file_object, const std::function<callback_t>& io_handler)
		{
			// handler can't be null
			if (!io_handler)
				return std::make_pair(false, 0);

			// Create storage for the callback and use pointer to that storage as an I/O completion port key
			auto handler_ptr = std::make_unique<std::function<callback_t>>(io_handler);
			auto handler_key = reinterpret_cast<ULONG_PTR>(handler_ptr.get());

			const auto h = CreateIoCompletionPort(file_object, get(), handler_key, 0);

			if (h == get())
			{
				{
					// Store the key and pointer for the handler
					std::lock_guard lock(handlers_lock_);
					handlers_keys_.insert(handler_key);
					handlers_.push_back(std::move(handler_ptr));
				}

				return std::make_pair(true, handler_key);
			}
			return std::make_pair(false, 0);
		}

		// ********************************************************************************
		/// <summary>
		/// associates the device with I/O completion port for the existing key (and thus for the existing stored callback handler)
		/// </summary>
		/// <param name="file_object">device file object</param>
		/// <param name="key">I/O completion port key value</param>
		/// <returns>boolean status of the operation</returns>
		// ********************************************************************************
		bool associate_device(HANDLE file_object, const ULONG_PTR key)
		{
			std::shared_lock lock(handlers_lock_);

			if (const auto it = handlers_keys_.find(key); it != handlers_keys_.end())
			{
				if (const auto h = CreateIoCompletionPort(file_object, get(), key, 0); h == get())
				{
					return true;
				}
			}

			return false;
		}

		// ********************************************************************************
		/// <summary>
		/// associates the socket with I/O completion port
		/// </summary>
		/// <param name="socket">socket to associate</param>
		/// <param name="io_handler">callback handler to process socket I/O operation</param>
		/// <returns>pair of status of the operation and associated I/O completion port key value</returns>
		// ********************************************************************************
		std::pair<bool, ULONG_PTR> associate_socket(const SOCKET socket, const std::function<callback_t>& io_handler)
		{
			return associate_device(reinterpret_cast<HANDLE>(socket), io_handler);  // NOLINT(performance-no-int-to-ptr)
		}

		// ********************************************************************************
		/// <summary>
		/// associates the socket with I/O completion port with the existing key (and thus stored callback)
		/// </summary>
		/// <param name="socket">socket to associate</param>
		/// <param name="key">key I/O completion port key value</param>
		/// <returns>boolean status of the operation</returns>
		// ********************************************************************************
		bool associate_socket(const SOCKET socket, const ULONG_PTR key)
		{
			return associate_device(reinterpret_cast<HANDLE>(socket), key);  // NOLINT(performance-no-int-to-ptr)
		}
	};
}

```

`examples/cpp/common/winsys/object.h`:

```h
#pragma once

#pragma warning( push )
#pragma warning( disable : 26456 )

namespace winsys
{
	// --------------------------------------------------------------------------------
	/// <summary>
	/// simple wrapper class for Windows handle
	/// </summary>
	// --------------------------------------------------------------------------------
	class safe_object_handle : public std::unique_ptr<std::remove_pointer_t<HANDLE>, void(*)(HANDLE)>
	{
	public:
		/// <summary>
		/// Constructs the object from the existing handle value
		/// </summary>
		/// <param name="handle"></param>
		// ReSharper disable once CppParameterMayBeConst
		explicit safe_object_handle(HANDLE handle) noexcept: unique_ptr(handle, &safe_object_handle::close)
		{
		}

		/// <summary>
		/// Deleted copy constructor
		/// </summary>
		safe_object_handle(const safe_object_handle& other) = delete;

		/// <summary>
		/// Move constructor
		/// </summary>
		/// <param name="other">Object instance to move from</param>
		safe_object_handle(safe_object_handle&& other) noexcept
			: std::unique_ptr<std::remove_pointer_t<HANDLE>, void(*)(HANDLE)>{std::move(other)}
		{
		}

		/// <summary>
		/// Deleted copy assignment
		/// </summary>
		safe_object_handle& operator=(const safe_object_handle& other) = delete;

		/// <summary>
		/// Move assignment
		/// </summary>
		/// <param name="other">Object instance to move from</param>
		/// <returns>this object reference</returns>
		safe_object_handle& operator=(safe_object_handle&& other) noexcept
		{
			if (this == &other)
				return *this;
			std::unique_ptr<std::remove_pointer_t<HANDLE>, void(*)(HANDLE)>::operator =(std::move(other));
			return *this;
		}

		/// <summary>
		/// Default destructor
		/// </summary>
		/// <returns></returns>
		~safe_object_handle() = default;

		/// <summary>
		/// Returns the stored handle value
		/// </summary>
		explicit operator HANDLE() const noexcept
		{
			return get();
		}

		/// <summary>
		/// Checks the stored handle value for validity
		/// </summary>
		/// <returns>true if valid, false otherwise</returns>
		[[nodiscard]] bool valid() const noexcept
		{
			return ((get() != INVALID_HANDLE_VALUE) && (get() != nullptr));
		}

	private:
		/// <summary>
		/// deleter for the stored windows handle (calls CloseHandle for the handle)
		/// </summary>
		/// <param name="handle">windows handle to close</param>
		// ReSharper disable once CppParameterMayBeConst
		static void close(HANDLE handle) noexcept
		{
			if ((handle != INVALID_HANDLE_VALUE) && (handle != nullptr))
				CloseHandle(handle);
		}
	};
}
#pragma warning( pop )

```

`examples/cpp/dns_proxy/README.md`:

```md
# DNS Proxy Server

## Overview

This is a basic DNS Proxy Server application implemented in C++. It allows you to intercept and redirect all DNS packets to a specified DNS server. This is useful for network monitoring, debugging, and other networking tasks.

## Code Description

The `main()` function of the program begins by prompting the user to input the IP address of the DNS server where the DNS requests will be forwarded.

The application then creates an instance of `ndisapi::udp_proxy_server` which is designed to handle the redirection of UDP traffic. The main logic of redirection is encapsulated in a lambda function passed to the `ndisapi::udp_proxy_server` constructor. This function checks whether the remote port is 53 (the standard DNS port). If it is, it redirects the request to the specified DNS server. If not, it simply returns without any redirection.

The application also sets up a logging function, `log_printer`, to display messages about the status of the application. This function is thread-safe.

Finally, the application starts the proxy server and waits for the user to press any key to stop the filtering process.

If any exception occurs during the execution, it is caught and displayed in the console.

## Usage

Compile and run the program. You will be prompted to enter the IP address of the DNS server where the DNS requests should be forwarded. Press any key to stop filtering.

```

`examples/cpp/dns_proxy/dns_proxy.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{3C0FDE50-2F34-447A-B453-A2720C125563}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>fastiotest</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>dns_proxy</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnableManifest>true</VcpkgEnableManifest>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\common\ndisapi\udp_proxy.h" />
    <ClInclude Include="..\common\net\ip_address.h" />
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dns_proxy.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg-configuration.json" />
    <None Include="vcpkg.json" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/cpp/dns_proxy/dns_proxy.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\common">
      <UniqueIdentifier>{f58d99f8-6dfc-44e1-9ff2-381efcda5d4d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\ndisapi">
      <UniqueIdentifier>{b7bffef8-2d56-4887-94c9-a3a5c019c40c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\net">
      <UniqueIdentifier>{eb22a31a-14c4-4b91-91b0-c92764cf0635}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\common\net\ip_address.h">
      <Filter>Header Files\common\net</Filter>
    </ClInclude>
    <ClInclude Include="..\common\ndisapi\udp_proxy.h">
      <Filter>Header Files\common\ndisapi</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="dns_proxy.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg.json" />
    <None Include="vcpkg-configuration.json" />
  </ItemGroup>
</Project>
```

`examples/cpp/dns_proxy/pch.h`:

```h
// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

#ifndef PCH_H
#define PCH_H

#include <winsock2.h>
#include <in6addr.h>
#include <tchar.h>
#include <ws2ipdef.h>
#include <IPHlpApi.h>
#include <Mstcpip.h>
#include <conio.h>
#include <WinDNS.h>

#include <memory>
#include <iostream>
#include <iomanip>
#include <chrono>
#include <thread>
#include <limits>
#include <atomic>
#include <string>
#include <functional>
#include <vector>
#include <cassert>
#include <array>
#include <map>
#include <cctype>
#include <mutex>
#include <shared_mutex>
#include <variant>
#include <bitset>
#include <optional>
#include <algorithm>
#include <charconv>
#include <gsl/gsl>

#include "../../../include/common.h"
#include "../../../include/ndisapi.h"
#include "../common/iphlp.h"
#include "../common/winsys/object.h"
#include "../common/winsys/event.h"
#include "../common/net/mac_address.h"
#include "../common/net/ip_address.h"
#include "../common/net/ipv6_helper.h"
#include "../common/net/ip_subnet.h"
#include "../common/iphelper/network_adapter_info.h"
#include "../common/ndisapi/network_adapter.h"
#include "../common/ndisapi/simple_packet_filter.h"
#include "../common/proxy/proxy_common.h"
#include "../common/ndisapi/udp_proxy.h"

#endif //PCH_H

```

`examples/cpp/dns_proxy/vcpkg-configuration.json`:

```json
{
  "default-registry": {
    "kind": "git",
    "baseline": "10b7a178346f3f0abef60cecd5130e295afd8da4",
    "repository": "https://github.com/microsoft/vcpkg"
  },
  "registries": [
    {
      "kind": "artifact",
      "location": "https://github.com/microsoft/vcpkg-ce-catalog/archive/refs/heads/main.zip",
      "name": "microsoft"
    }
  ]
}

```

`examples/cpp/dns_proxy/vcpkg.json`:

```json
{
  "dependencies": [
    "ms-gsl"
  ]
}

```

`examples/cpp/dnstrace/README.md`:

```md
# DNS Tracer

`dnstrace` is a console application written in C++. It provides a detailed trace of DNS (Domain Name System) responses by parsing the DNS packet structure. This can be useful for network debugging, security monitoring, and research purposes.This sample also demonstares how to link NDISAPI statically and dynamically (using corresponding congigurations).

## Features

- Parses and prints out key elements from IP, UDP, and DNS headers.
- Extracts and displays DNS response data, including record types like A, NS, CNAME, SOA, WKS, PTR, MX, AAA, SRV and ANY.
- Uses `Windows Packet Filter` to filter the network traffic.
- Allows the user to select a network interface to filter.
- Handles IPv4 and IPv6 addresses.
  
## How it works

The application captures packets coming from the DNS server (port 53) using `Windows Packet Filter`. It then parses these packets, extracting the IP, UDP, and DNS headers. For each DNS response, it extracts and prints out the DNS record type and data. The application continues to run until the user interrupts it.

## Prerequisites

- The `Windows Packet Filter` driver must be loaded on your system to use this application.

## Usage

Run the application from the command line with:

```bash
./dnstrace
```

If the `Windows Packet Filter` driver is loaded, the application will print a list of available network interfaces. Select the interface you want to filter by entering its number. The application will start capturing and parsing DNS responses on that interface.





```

`examples/cpp/dnstrace/dnstrace.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug DLL|ARM64">
      <Configuration>Debug DLL</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug DLL|Win32">
      <Configuration>Debug DLL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug DLL|x64">
      <Configuration>Debug DLL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release DLL|ARM64">
      <Configuration>Release DLL</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release DLL|Win32">
      <Configuration>Release DLL</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release DLL|x64">
      <Configuration>Release DLL</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{D0BB9E0A-F561-47C6-94C2-6CF68817F251}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>dnstrace</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug DLL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release DLL|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug DLL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug DLL|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release DLL|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release DLL|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug DLL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release DLL|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug DLL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug DLL|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release DLL|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release DLL|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug DLL|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>false</RunCodeAnalysis>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>false</RunCodeAnalysis>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug DLL|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug DLL|ARM64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release DLL|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release DLL|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release DLL|ARM64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnableManifest>true</VcpkgEnableManifest>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug DLL|ARM64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release DLL|ARM64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug DLL|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release DLL|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug DLL|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release DLL|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Dnsapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug DLL|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Dnsapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\dll\$(Platform)\Debug</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <EnablePREfast>false</EnablePREfast>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Dnsapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <EnablePREfast>false</EnablePREfast>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Dnsapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug DLL|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Dnsapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\dll\$(Platform)\Debug</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug DLL|ARM64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Dnsapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\dll\$(Platform)\Debug</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Dnsapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release DLL|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Dnsapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\dll\$(Platform)\Release</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Dnsapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Dnsapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release DLL|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Dnsapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\dll\$(Platform)\Release</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release DLL|ARM64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Dnsapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\dll\$(Platform)\Release</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\common\iphlp.h" />
    <ClInclude Include="..\common\ndisapi\network_adapter.h" />
    <ClInclude Include="..\common\ndisapi\simple_packet_filter.h" />
    <ClInclude Include="..\common\net\ip_address.h" />
    <ClInclude Include="..\common\net\mac_address.h" />
    <ClInclude Include="..\common\winsys\event.h" />
    <ClInclude Include="..\common\winsys\object.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dnstrace.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug DLL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug DLL|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug DLL|ARM64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release DLL|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release DLL|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release DLL|ARM64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg-configuration.json" />
    <None Include="vcpkg.json" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/cpp/dnstrace/dnstrace.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\common">
      <UniqueIdentifier>{9960ff66-54ef-4b8a-85fe-c498ba096f26}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\net">
      <UniqueIdentifier>{59f322fa-1d78-4e8f-beb8-ae04922a0d8d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\ndisapi">
      <UniqueIdentifier>{2e08aa19-4065-47eb-b59f-7787cf771c51}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\winsys">
      <UniqueIdentifier>{d6d18142-abe7-4e6d-ab90-14ac2613636a}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\common\net\ip_address.h">
      <Filter>Header Files\common\net</Filter>
    </ClInclude>
    <ClInclude Include="..\common\ndisapi\network_adapter.h">
      <Filter>Header Files\common\ndisapi</Filter>
    </ClInclude>
    <ClInclude Include="..\common\ndisapi\simple_packet_filter.h">
      <Filter>Header Files\common\ndisapi</Filter>
    </ClInclude>
    <ClInclude Include="..\common\iphlp.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
    <ClInclude Include="..\common\net\mac_address.h">
      <Filter>Header Files\common\net</Filter>
    </ClInclude>
    <ClInclude Include="..\common\winsys\event.h">
      <Filter>Header Files\common\winsys</Filter>
    </ClInclude>
    <ClInclude Include="..\common\winsys\object.h">
      <Filter>Header Files\common\winsys</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="dnstrace.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg.json" />
    <None Include="vcpkg-configuration.json" />
  </ItemGroup>
</Project>
```

`examples/cpp/dnstrace/stdafx.h`:

```h
/*************************************************************************/
/*              Copyright (c) 2000-2018 NT Kernel Resources.             */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/*                                                                       */
/* Module Name:  stdafx.h                                                */
/*                                                                       */
/* Abstract: include file for standard system include files,             */
/* or project specific include files that are used frequently, but       */
/* are changed infrequently                                              */
/*                                                                       */
/* Environment:                                                          */
/*   User mode                                                           */
/*                                                                       */
/*************************************************************************/

#pragma once

#include "targetver.h"

#include <winsock2.h>
#include <in6addr.h>
#include <tchar.h>
#include <ws2ipdef.h>
#include <IPHlpApi.h>
#include <Mstcpip.h>
#include <conio.h>
#include <WinDNS.h>

#include <memory>
#include <iostream>
#include <iomanip>
#include <chrono>
#include <thread>
#include <limits>
#include <atomic>
#include <string>
#include <functional>
#include <vector>
#include <cassert>
#include <array>
#include <map>
#include <cctype>
#include <variant>
#include <bitset>
#include <optional>
#include <algorithm>
#include <mutex>
#include <charconv>
#include <gsl/gsl>

#include "../../../include/common.h"
#include "../../../include/ndisapi.h"
#include "../common/iphlp.h"
#include "../common/winsys/object.h"
#include "../common/winsys/event.h"
#include "../common/net/mac_address.h"
#include "../common/net/ip_address.h"
#include "../common/net/ip_subnet.h"
#include "../common/iphelper/network_adapter_info.h"
#include "../common/ndisapi/network_adapter.h"
#include "../common/ndisapi/simple_packet_filter.h"


```

`examples/cpp/dnstrace/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#define WINVER 0x0600  
#define _WIN32_WINNT 0x0600 

#include <SDKDDKVer.h>

```

`examples/cpp/dnstrace/vcpkg-configuration.json`:

```json
{
  "default-registry": {
    "kind": "git",
    "baseline": "10b7a178346f3f0abef60cecd5130e295afd8da4",
    "repository": "https://github.com/microsoft/vcpkg"
  },
  "registries": [
    {
      "kind": "artifact",
      "location": "https://github.com/microsoft/vcpkg-ce-catalog/archive/refs/heads/main.zip",
      "name": "microsoft"
    }
  ]
}

```

`examples/cpp/dnstrace/vcpkg.json`:

```json
{
  "dependencies": [
    "ms-gsl"
  ]
}

```

`examples/cpp/ethernet_bridge/EthernetBridge.h`:

```h
// --------------------------------------------------------------------------------
/// <summary>
/// Module Name:  EthernetBridge.h 
/// Abstract: EthernetBridge class interface
/// </summary>
// --------------------------------------------------------------------------------

#pragma once

//
// Medium the Ndis Driver is running on (OID_GEN_MEDIA_SUPPORTED/ OID_GEN_MEDIA_IN_USE).
//
enum class NdisMedium
{
	NdisMedium802_3,
	NdisMedium802_5,
	NdisMediumFddi,
	NdisMediumWan,
	NdisMediumLocalTalk,
	NdisMediumDix,              // defined for convenience, not a real medium
	NdisMediumArcnetRaw,
	NdisMediumArcnet878_2,
	NdisMediumAtm,
	NdisMediumWirelessWan,
	NdisMediumIrda,
	NdisMediumBpc,
	NdisMediumCoWan,
	NdisMedium1394,
	NdisMediumInfiniBand,
	NdisMediumTunnel,
	NdisMediumNative802_11,
	NdisMediumLoopback,
	NdisMediumWiMAX,
	NdisMediumIP,
	NdisMediumMax               // Not a real medium, defined as an upper-bound
};

//
// Physical Medium Type definitions. Used with OID_GEN_PHYSICAL_MEDIUM.
//
enum class NdisPhysicalMedium
{
	NdisPhysicalMediumUnspecified,
	NdisPhysicalMediumWirelessLan,
	NdisPhysicalMediumCableModem,
	NdisPhysicalMediumPhoneLine,
	NdisPhysicalMediumPowerLine,
	NdisPhysicalMediumDSL,      // includes ADSL and UADSL (G.Lite)
	NdisPhysicalMediumFibreChannel,
	NdisPhysicalMedium1394,
	NdisPhysicalMediumWirelessWan,
	NdisPhysicalMediumNative802_11,
	NdisPhysicalMediumBluetooth,
	NdisPhysicalMediumInfiniband,
	NdisPhysicalMediumWiMax,
	NdisPhysicalMediumUWB,
	NdisPhysicalMedium802_3,
	NdisPhysicalMedium802_5,
	NdisPhysicalMediumIrda,
	NdisPhysicalMediumWiredWAN,
	NdisPhysicalMediumWiredCoWan,
	NdisPhysicalMediumOther,
	NdisPhysicalMediumMax       // Not a real physical type, defined as an upper-bound
};


class ethernet_bridge final : public CNdisApi
{
public:
	ethernet_bridge() noexcept : CNdisApi() { initialize_network_interfaces(); }
	virtual ~ethernet_bridge() { stop_bridge(); }

	// ********************************************************************************
	/// <summary>
	/// Starts bridging for the selected interfaces
	/// </summary>
	/// <param name="interfaces">indexes of network interfaces to bridge</param>
	/// <returns>boolean status of the operation</returns>
	// ********************************************************************************
	bool start_bridge(std::vector<size_t> const& interfaces);

	// ********************************************************************************
	/// <summary>
	/// Stops bridging
	/// </summary>
	// ********************************************************************************
	void stop_bridge();

	// ********************************************************************************
	/// <summary>
	/// Queries list of available network interfaces
	/// </summary>
	/// <returns>vector of pairs of strings representing internal and friendly network 
	/// interface names</returns>
	// ********************************************************************************
	std::vector<std::pair<string, string>> get_interface_list();

private:
	// ********************************************************************************
	/// <summary>
	/// Queries the index of the network interface to forward packet with the supplied 
	/// destination MAC address
	/// </summary>
	/// <param name="address">MAC address reference</param>
	/// <returns></returns>
	// ********************************************************************************
	std::optional<std::size_t> find_target_adapter_by_mac(net::mac_address const& address);

	// ********************************************************************************
	/// <summary>
	/// Stores network interface index for the supplied MAC address
	/// </summary>
	/// <param name="index">index of the network interface</param>
	/// <param name="address">MAC address to store behind the interface index</param>
	/// <returns></returns>
	// ********************************************************************************
	bool update_target_adapter_by_mac(std::size_t index, net::mac_address const& address);

	// ********************************************************************************
	/// <summary>
	/// Packet reading and forwarding thread
	/// </summary>
	/// <param name="index">network interface index to read packets from</param>
	// ********************************************************************************
	void bridge_working_thread(size_t index);

	// ********************************************************************************
	/// <summary>
	/// Initializes available network interfaces
	/// </summary>
	// ********************************************************************************
	void initialize_network_interfaces();

	/// <summary>Bridge running flag</summary>
	std::atomic_flag is_running_ = ATOMIC_FLAG_INIT;

	/// <summary>List of network interfaces available for bridging</summary>
	std::vector<unique_ptr<network_adapter>> network_interfaces_;
	
	/// <summary>vector of working threads</summary>
	std::vector<std::thread> working_threads_;

	/// <summary>vector of bridged network interfaces</summary>
	std::vector<std::size_t> bridged_interfaces_;
	
	/// <summary>has table to store MAC address -> adapter index association</summary>
	std::unordered_map<net::mac_address, std::size_t> mac_table_;

	/// <summary>synchronization lock for the hash table above</summary>
	std::shared_mutex mac_table_lock_;
};

```

`examples/cpp/ethernet_bridge/NetworkAdapter.h`:

```h
// --------------------------------------------------------------------------------
/// <summary>
/// Module Name:  NetworkAdapter.h
/// Network interface wrapper class declaration
/// </summary>
// --------------------------------------------------------------------------------

#pragma once

// --------------------------------------------------------------------------------
/// <summary>
/// Class representing network interface
/// </summary>
// --------------------------------------------------------------------------------
class network_adapter {
public:
	network_adapter(
		CNdisApi& api,
		HANDLE adapter,
		unsigned char* mac_addr,
		std::string const& internal_name,
		std::string const& friendly_name,
		const unsigned filter = 0
	) :	api_(api),
		hardware_address_(mac_addr),
		network_filter_(filter),
		event_(::CreateEvent(nullptr, TRUE, FALSE, nullptr)),
		internal_name_(internal_name),
		friendly_name_(friendly_name),
		current_mode_({ adapter, 0})
	{
		initialize_interface();
	}

	~network_adapter() {}
	// ********************************************************************************
	/// <summary>
	/// Initialize additional network interface parameters
	/// </summary>
	// ********************************************************************************
	void initialize_interface() noexcept;

	// ********************************************************************************
	/// <summary>
	/// Returns network interface handle value
	/// </summary>
	/// <returns>network interface driver handle</returns>
	// ********************************************************************************
	HANDLE get_adapter() const { return current_mode_.hAdapterHandle; }

	// ********************************************************************************
	/// <summary>
	/// Set network filter for the interface
	/// </summary>
	/// <param name="filter">hardware filter to set</param>
	/// <returns>boolean status of the operation</returns>
	// ********************************************************************************
	bool set_hw_filter(const unsigned filter) const { return api_.SetHwPacketFilter(current_mode_.hAdapterHandle, filter)?true:false; }

	// ********************************************************************************
	/// <summary>
	/// Get current network filter
	/// </summary>
	/// <returns>current hardware filter value</returns>
	// ********************************************************************************
	unsigned long get_hw_filter() const;

	// ********************************************************************************
	/// <summary>
	/// Stops filtering the network interface and tries tor restore its original state
	/// </summary>
	// ********************************************************************************
	void release();

	// ********************************************************************************
	/// <summary>
	/// Set filtering mode for the network interface
	/// </summary>
	/// <param name="flags">filter mode to set</param>
	// ********************************************************************************
	void set_mode(unsigned flags);

	// ********************************************************************************
	/// <summary>
	/// Check is provided MAC address belongs to this adapter
	/// </summary>
	/// <param name="ptr">pointer to 6 bytes of MAC address</param>
	/// <returns>true if MAC address belongs to this network adapter</returns>
	// ********************************************************************************
	bool is_local(unsigned char* ptr) const { return (net::mac_address(ptr) == hardware_address_); }

	// ********************************************************************************
	/// <summary>
	/// Waits for network interface event to be signaled
	/// </summary>
	/// <param name="milliseconds">timeout value in milliseconds</param>
	/// <returns>wait status</returns>
	// ********************************************************************************
	unsigned wait_event(const unsigned milliseconds) const {return event_.wait(milliseconds);}

	// ********************************************************************************
	/// <summary>
	/// Resets packet event to non-signaled state
	/// </summary>
	/// <returns>boolean status of the operation</returns>
	// ********************************************************************************
	bool reset_event() const { return event_.reset_event(); }

	// ********************************************************************************
	/// <summary>
	/// Loads packet event into the driver
	/// </summary>
	/// <returns>boolean status of the operation</returns>
	// ********************************************************************************
	bool set_packet_event() const { return api_.SetPacketEvent(current_mode_.hAdapterHandle, static_cast<HANDLE>(event_))?true:false; }

	// ********************************************************************************
	/// <summary>
	/// Network interface internal name getter
	/// </summary>
	/// <returns>string reference to the internal name</returns>
	// ********************************************************************************
	const std::string& get_internal_name() const { return internal_name_; }

	// ********************************************************************************
	/// <summary>
	/// Network interface friendly name getter
	/// </summary>
	/// <returns>string reference to the user friendly name</returns>
	// ********************************************************************************
	const std::string& get_friendly_name() const { return friendly_name_; }

	// ********************************************************************************
	/// <summary>
	/// Checks if this network adapter is Wi-Fi
	/// </summary>
	/// <returns>true for Wi-Fi adapter, false otherwise</returns>
	// ********************************************************************************
	bool is_wlan() const { return is_wlan_; }

	// ********************************************************************************
	/// <summary>
	/// Network adapter hardware address getter
	/// </summary>
	/// <returns>network interface hardware address</returns>
	// ********************************************************************************
	const net::mac_address& get_hw_address() const { return hardware_address_; }

	// ********************************************************************************
	/// <summary>
	/// Returns MAC address by the supplied IP address
	/// </summary>
	/// <param name="ip">IP address</param>
	/// <returns>MAC address associated with IP above if available, zero initialized
	/// otherwise</returns>
	// ********************************************************************************
	net::mac_address get_mac_by_ip (net::ip_address_v4 const& ip);

	// ********************************************************************************
	/// <summary>
	/// Stores IP to MAC address association
	/// </summary>
	/// <param name="ip">IP address</param>
	/// <param name="mac">pointer to 6 bytes of MAC address</param>
	// ********************************************************************************
	void set_mac_for_ip(net::ip_address_v4 const& ip, unsigned char* mac);

private:
	/// <summary>Driver interface reference</summary>
	CNdisApi& api_;
	/// <summary>Network interface current MAC address</summary>
	net::mac_address hardware_address_;	
	/// <summary>Network interface original filter value</summary>
	unsigned long network_filter_;	
	/// <summary>Packet in the adapter queue event</summary>
	winsys::safe_event event_;			
	/// <summary>Internal network interface name</summary>
	std::string internal_name_;		
	/// <summary>User-friendly name</summary>
	std::string friendly_name_;		
	/// <summary>Used to manipulate network interface mode</summary>
	ADAPTER_MODE current_mode_;		
	/// <summary>True for WLAN media type</summary>
	bool is_wlan_ = false;	
	/// <summary>ARP table</summary>
	std::unordered_map<net::ip_address_v4, net::mac_address> ip_to_mac_;			
	/// <summary>Synchronization object to control access to ARP table</summary>
	std::mutex ip_to_mac_mutex_;		
};

```

`examples/cpp/ethernet_bridge/README.md`:

```md
# EthernetBridge

The EthernetBridge example is a simple C++ program that implements an Ethernet bridge. An Ethernet bridge is a network device that connects two or more Ethernet networks together by forwarding frames between the networks based on their MAC addresses.

## Code Overview

init() - This function initializes the bridge. It performs the following operations:

1. Opens the network interfaces.
2. Creates a list of MAC addresses for each network interface.
3. Creates a table of MAC addresses to network interfaces.

run() - This function is the main loop of the bridge. It continuously receives frames from the network interfaces and forwards them to the appropriate network. It performs the following operations:

1. Receives a frame from a network interface.
2. Looks up the destination MAC address in the table of MAC addresses to network interfaces.
3. If the destination MAC address is found, forwards the frame to the network interface associated with the destination MAC address.
4. If the destination MAC address is not found, drops the frame.

## Acknowledgments

- The code uses the NDISAPI to open and manage network interfaces.
- The code uses a table of MAC addresses to network interfaces to keep track of which network interface is associated with each MAC address.
- The code uses a loop to continuously receive frames from the network interfaces and forward them to the appropriate network.
- The code drops frames that do not have a destination MAC address.

## More information
Please read this [blog post](https://www.ntkernel.com/bridging-networks-with-windows-packet-filter/)




```

`examples/cpp/ethernet_bridge/ebridge.h`:

```h
/*************************************************************************/
/*              Copyright (c) 2000-2018 NT Kernel Resources.             */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/*                                                                       */
/* Module Name:  ebridge.h                                               */
/*                                                                       */
/* Abstract: Some NDIS helper definitions                                */
/*                                                                       */
/* Environment:                                                          */
/*   User mode                                                           */
/*                                                                       */
/*************************************************************************/
#pragma once

//
// Medium the Ndis Driver is running on (OID_GEN_MEDIA_SUPPORTED/ OID_GEN_MEDIA_IN_USE).
//
enum class NdisMedium
{
	NdisMedium802_3,
	NdisMedium802_5,
	NdisMediumFddi,
	NdisMediumWan,
	NdisMediumLocalTalk,
	NdisMediumDix,              // defined for convenience, not a real medium
	NdisMediumArcnetRaw,
	NdisMediumArcnet878_2,
	NdisMediumAtm,
	NdisMediumWirelessWan,
	NdisMediumIrda,
	NdisMediumBpc,
	NdisMediumCoWan,
	NdisMedium1394,
	NdisMediumInfiniBand,
	NdisMediumTunnel,
	NdisMediumNative802_11,
	NdisMediumLoopback,
	NdisMediumWiMAX,
	NdisMediumIP,
	NdisMediumMax               // Not a real medium, defined as an upper-bound
};

//
// Physical Medium Type definitions. Used with OID_GEN_PHYSICAL_MEDIUM.
//
enum class NdisPhysicalMedium
{
	NdisPhysicalMediumUnspecified,
	NdisPhysicalMediumWirelessLan,
	NdisPhysicalMediumCableModem,
	NdisPhysicalMediumPhoneLine,
	NdisPhysicalMediumPowerLine,
	NdisPhysicalMediumDSL,      // includes ADSL and UADSL (G.Lite)
	NdisPhysicalMediumFibreChannel,
	NdisPhysicalMedium1394,
	NdisPhysicalMediumWirelessWan,
	NdisPhysicalMediumNative802_11,
	NdisPhysicalMediumBluetooth,
	NdisPhysicalMediumInfiniband,
	NdisPhysicalMediumWiMax,
	NdisPhysicalMediumUWB,
	NdisPhysicalMedium802_3,
	NdisPhysicalMedium802_5,
	NdisPhysicalMediumIrda,
	NdisPhysicalMediumWiredWAN,
	NdisPhysicalMediumWiredCoWan,
	NdisPhysicalMediumOther,
	NdisPhysicalMediumMax       // Not a real physical type, defined as an upper-bound
};


class EthernetBridge : public CNdisApi
{
public:
	EthernetBridge() noexcept: CNdisApi() { InitializeNetworkInterfaces(); }
	virtual ~EthernetBridge() { StopBridge(); }

	void StartBridge(size_t First, size_t Second);
	void StopBridge();
	std::vector<string> GetInterfaceList();

private:
	static const size_t ThreadCount = 2;
	static void BridgeWorkingThread(EthernetBridge*, size_t, size_t);

	void InitializeNetworkInterfaces();

	std::atomic_flag m_bIsRunning = ATOMIC_FLAG_INIT;
	std::vector<unique_ptr<CNetworkAdapter>> m_NetworkInterfaces; // List of network interfaces available for bridging
	std::vector<std::thread> m_WorkingThreads;
	std::pair<std::size_t, std::size_t> m_BridgedInterfaces;
};
```

`examples/cpp/ethernet_bridge/ebridge.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{39D26CA7-DCD7-4BE0-A97A-18940BAF0AD8}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>ebridge</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <CodeAnalysisRuleSet>MixedRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>false</RunCodeAnalysis>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <CodeAnalysisRuleSet>MixedRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>false</RunCodeAnalysis>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnableManifest>true</VcpkgEnableManifest>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <EnablePREfast>false</EnablePREfast>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <EnablePREfast>false</EnablePREfast>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\common\dhcp_typedefs.h" />
    <ClInclude Include="..\common\iphlp.h" />
    <ClInclude Include="..\common\net\ip_address.h" />
    <ClInclude Include="..\common\net\mac_address.h" />
    <ClInclude Include="..\common\pcap\pcap.h" />
    <ClInclude Include="..\common\pcap\pcap_file_storage.h" />
    <ClInclude Include="..\common\winsys\event.h" />
    <ClInclude Include="..\common\winsys\object.h" />
    <ClInclude Include="EthernetBridge.h" />
    <ClInclude Include="NetworkAdapter.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ebridge.cpp" />
    <ClCompile Include="EthernetBridge.cpp" />
    <ClCompile Include="NetworkAdapter.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg-configuration.json" />
    <None Include="vcpkg.json" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/cpp/ethernet_bridge/ebridge.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\common">
      <UniqueIdentifier>{bafe7c7f-32c1-4b01-8ccb-9c4958c37018}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\net">
      <UniqueIdentifier>{9a3fba64-caf7-4829-b676-ec7a78959f72}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\winsys">
      <UniqueIdentifier>{5c8484d0-7242-4fa9-a116-0e3796fad6ed}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\pcap">
      <UniqueIdentifier>{45646586-0d2f-4559-be2c-08a2c2412fee}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="NetworkAdapter.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="EthernetBridge.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\common\dhcp_typedefs.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
    <ClInclude Include="..\common\iphlp.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
    <ClInclude Include="..\common\net\ip_address.h">
      <Filter>Header Files\common\net</Filter>
    </ClInclude>
    <ClInclude Include="..\common\net\mac_address.h">
      <Filter>Header Files\common\net</Filter>
    </ClInclude>
    <ClInclude Include="..\common\winsys\event.h">
      <Filter>Header Files\common\winsys</Filter>
    </ClInclude>
    <ClInclude Include="..\common\winsys\object.h">
      <Filter>Header Files\common\winsys</Filter>
    </ClInclude>
    <ClInclude Include="..\common\pcap\pcap.h">
      <Filter>Header Files\common\pcap</Filter>
    </ClInclude>
    <ClInclude Include="..\common\pcap\pcap_file_storage.h">
      <Filter>Header Files\common\pcap</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ebridge.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="NetworkAdapter.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="EthernetBridge.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg.json" />
    <None Include="vcpkg-configuration.json" />
  </ItemGroup>
</Project>
```

`examples/cpp/ethernet_bridge/stdafx.h`:

```h
// --------------------------------------------------------------------------------
/// <summary>
/// include file for standard system include files,or project specific include 
/// files that are used frequently, but are changed infrequently 
/// </summary>
// --------------------------------------------------------------------------------

#pragma once

#include "targetver.h"

#include <winsock2.h>
#include <tchar.h>
#include <ws2ipdef.h>
#include <IPHlpApi.h>
#include <conio.h>

#include <utility>
#include <vector>
#include <array>
#include <unordered_map>
#include <memory>
#include <tuple>
#include <iostream>
#include <string>
#include <thread>
#include <mutex>
#include <atomic>
#include <algorithm>
#include <shared_mutex>
#include <optional>
#include <map>
#include <fstream>
#include <charconv>
#include <gsl/gsl>

using namespace std;

#include "../../../include/common.h"
#include "../../../include/ndisapi.h"
#include "../common/iphlp.h"
#include "../common/dhcp_typedefs.h"
#include "../common/net/ip_address.h"
#include "../common/net/mac_address.h"
#include "../common/winsys/object.h"
#include "../common/winsys/event.h"
#include "../common/pcap/pcap.h"
#include "../common/pcap/pcap_file_storage.h"
#include "NetworkAdapter.h"
#include "EthernetBridge.h"


```

`examples/cpp/ethernet_bridge/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`examples/cpp/ethernet_bridge/vcpkg-configuration.json`:

```json
{
  "default-registry": {
    "kind": "git",
    "baseline": "10b7a178346f3f0abef60cecd5130e295afd8da4",
    "repository": "https://github.com/microsoft/vcpkg"
  },
  "registries": [
    {
      "kind": "artifact",
      "location": "https://github.com/microsoft/vcpkg-ce-catalog/archive/refs/heads/main.zip",
      "name": "microsoft"
    }
  ]
}

```

`examples/cpp/ethernet_bridge/vcpkg.json`:

```json
{
  "dependencies": [
    "ms-gsl"
  ]
}

```

`examples/cpp/hyperscan/README.md`:

```md
# Hyperscan: Network Packet Analysis Example

## Overview

`Hyperscan` is a high-performance example application showcasing the integration of the [Hyperscan](https://github.com/intel/hyperscan) and [llhttp](https://github.com/nodejs/llhttp) libraries. This application intercepts network packets, parses them, detects HTTP protocol sessions, and applies the HTTP protocol parsing on the detected sessions using `llhttp`.

This practical application can significantly contribute to network security and monitoring efforts, enabling the identification and in-depth analysis of HTTP traffic within a network. 

## Key Features

- High-performance network packet interception
- HTTP protocol session detection
- In-depth HTTP protocol parsing for detected sessions
- Utilization of Hyperscan and llhttp libraries

## Limitations

Please note that this example application is not engineered to handle TCP packet retransmissions or reordering. Therefore, it might not perform optimally on unreliable connections. It is specifically designed and optimized for high-quality, reliable connections.

## Installation

### Prerequisites

Ensure you have the following installed on your system:

- Hyperscan 5.2 or later (including headers and libraries)
- llhttp headers and libraries

### Installation Steps

You can use `vcpkg` to install the required Hyperscan and llhttp libraries:

Install Hyperscan:

```bash
vcpkg install hyperscan:x86-windows-static hyperscan:x64-windows-static
```

Install llhttp:

```bash
vcpkg install llhttp:x86-windows-static llhttp:x64-windows-static
```

With these libraries installed, you're ready to compile and run the hyperscan application.

```

`examples/cpp/hyperscan/hyperscan.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{F9BAFDFC-851F-40F2-B3D9-20ABFC23DD68}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>fastiotest</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <VcpkgUseStatic>false</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <VcpkgUseStatic>false</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <VcpkgUseStatic>false</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Vcpkg">
    <VcpkgUseStatic>false</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <VcpkgUseStatic>false</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Vcpkg">
    <VcpkgUseStatic>false</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnableManifest>true</VcpkgEnableManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\dll\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\dll\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\dll\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\dll\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\dll\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\dll\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\common\ndisapi\queued_packet_filter.h" />
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="hyperscan.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg-configuration.json" />
    <None Include="vcpkg.json" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/cpp/hyperscan/hyperscan.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\common">
      <UniqueIdentifier>{f58d99f8-6dfc-44e1-9ff2-381efcda5d4d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\ndisapi">
      <UniqueIdentifier>{b7bffef8-2d56-4887-94c9-a3a5c019c40c}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\common\ndisapi\queued_packet_filter.h">
      <Filter>Header Files\common\ndisapi</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hyperscan.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg.json" />
    <None Include="vcpkg-configuration.json" />
  </ItemGroup>
</Project>
```

`examples/cpp/hyperscan/pch.h`:

```h
// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

#ifndef PCH_H
#define PCH_H

#include <winsock2.h>
#include <in6addr.h>
#include <tchar.h>
#include <ws2ipdef.h>
#include <IPHlpApi.h>
#include <Mstcpip.h>
#include <conio.h>
#include <WinDNS.h>

#include <memory>
#include <iostream>
#include <iomanip>
#include <chrono>
#include <thread>
#include <limits>
#include <atomic>
#include <string>
#include <functional>
#include <vector>
#include <cassert>
#include <array>
#include <map>
#include <cctype>
#include <variant>
#include <bitset>
#include <optional>
#include <algorithm>
#include <mutex>
#include <charconv>
#include <shared_mutex>
#include <queue>
#include <gsl/gsl>
#include <hs/hs.h>
#include <llhttp.h>

#include "../../../include/common.h"
#include "../../../include/ndisapi.h"
#include "../common/iphlp.h"
#include "../common/winsys/object.h"
#include "../common/winsys/event.h"
#include "../common/net/mac_address.h"
#include "../common/net/ip_address.h"
#include "../common/net/ip_subnet.h"
#include "../common/net/ip_endpoint.h"
#include "../common/iphelper/network_adapter_info.h"
#include "../common/ndisapi/network_adapter.h"
#include "../common/ndisapi/queued_packet_filter.h"

#endif //PCH_H

```

`examples/cpp/hyperscan/vcpkg-configuration.json`:

```json
{
  "default-registry": {
    "kind": "git",
    "baseline": "10b7a178346f3f0abef60cecd5130e295afd8da4",
    "repository": "https://github.com/microsoft/vcpkg"
  },
  "registries": [
    {
      "kind": "artifact",
      "location": "https://github.com/microsoft/vcpkg-ce-catalog/archive/refs/heads/main.zip",
      "name": "microsoft"
    }
  ]
}

```

`examples/cpp/hyperscan/vcpkg.json`:

```json
{
  "dependencies": [
    "ms-gsl",
    "hyperscan",
    "llhttp"
  ]
}

```

`examples/cpp/ipv6_parser/README.md`:

```md
# IPv6 Parser

This project demonstrates the useage of `ipv6_parser` class for parsing IPv6 headers and finding the transport payload.

## Main Functionality

The `ipv6_parser::find_transport_header` function is used to parse IP headers until the transport payload. It takes a pointer to the IP header and the size of the IP packet in octets as inputs, and returns a pointer to the IP packet payload (TCP, UDP, ICMPv6, etc.) and protocol.

The `main` function uses `ndisapi::fastio_packet_filter` to intercept IPv6 packets. It then uses the `find_transport_header` function to parse the IP headers, and if the protocol is TCP, it performs process lookups.

## Dependencies

- You must have `Windows Packet Filter` installed on your machine to build and run this project. 




```

`examples/cpp/ipv6_parser/ipv6_parser.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{B3074F8E-D987-43C8-AE76-589A57DCF7CF}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>fastiotest</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnableManifest>true</VcpkgEnableManifest>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\common\iphelper\process_lookup.h" />
    <ClInclude Include="..\common\ndisapi\fastio_packet_filter.h" />
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ipv6_parser.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg-configuration.json" />
    <None Include="vcpkg.json" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/cpp/ipv6_parser/ipv6_parser.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\common">
      <UniqueIdentifier>{f58d99f8-6dfc-44e1-9ff2-381efcda5d4d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\ndisapi">
      <UniqueIdentifier>{b7bffef8-2d56-4887-94c9-a3a5c019c40c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\iphelper">
      <UniqueIdentifier>{2af56194-a0fc-4538-b6b1-050933047be6}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\common\ndisapi\fastio_packet_filter.h">
      <Filter>Header Files\common\ndisapi</Filter>
    </ClInclude>
    <ClInclude Include="..\common\iphelper\process_lookup.h">
      <Filter>Header Files\common\iphelper</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ipv6_parser.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg.json" />
    <None Include="vcpkg-configuration.json" />
  </ItemGroup>
</Project>
```

`examples/cpp/ipv6_parser/pch.h`:

```h
// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

#ifndef PCH_H
#define PCH_H

#include <winsock2.h>
#include <in6addr.h>
#include <tchar.h>
#include <ws2ipdef.h>
#include <IPHlpApi.h>
#include <Mstcpip.h>
#include <conio.h>
#include <WinDNS.h>

#include <memory>
#include <iostream>
#include <iomanip>
#include <chrono>
#include <thread>
#include <limits>
#include <atomic>
#include <string>
#include <functional>
#include <vector>
#include <cassert>
#include <array>
#include <map>
#include <cctype>
#include <shared_mutex>
#include <algorithm>
#include <variant>
#include <bitset>
#include <optional>
#include <charconv>
#include <gsl/gsl>

#include "../../../include/common.h"
#include "../../../include/ndisapi.h"
#include "../common/iphlp.h"
#include "../common/winsys/object.h"
#include "../common/winsys/event.h"
#include "../common/net/mac_address.h"
#include "../common/net/ip_address.h"
#include "../common/net/ip_subnet.h"
#include "../common/net/ip_endpoint.h"
#include "../common/iphelper/process_lookup.h"
#include "../common/iphelper/network_adapter_info.h"
#include "../common/ndisapi/network_adapter.h"
#include "../common/ndisapi/fastio_packet_filter.h"

#endif //PCH_H

```

`examples/cpp/ipv6_parser/vcpkg-configuration.json`:

```json
{
  "default-registry": {
    "kind": "git",
    "baseline": "10b7a178346f3f0abef60cecd5130e295afd8da4",
    "repository": "https://github.com/microsoft/vcpkg"
  },
  "registries": [
    {
      "kind": "artifact",
      "location": "https://github.com/microsoft/vcpkg-ce-catalog/archive/refs/heads/main.zip",
      "name": "microsoft"
    }
  ]
}

```

`examples/cpp/ipv6_parser/vcpkg.json`:

```json
{
  "dependencies": [
    "ms-gsl"
  ]
}

```

`examples/cpp/pcapplusplus/README.md`:

```md
# PcapPlusPlus Demo

This project leverages the [PcapPlusPlus](https://github.com/seladb/PcapPlusPlus) library to intercept network packets, specifically focusing on extracting the Server Name Indication (SNI) from HTTPS packets. The program also performs Transport Layer Security (TLS) fingerprinting to identify the specific version of TLS being utilized.

## Getting Started

These instructions will get you a copy of the project up and running on your local machine for development and testing purposes.

### Prerequisites

- The `Windows Packet Filter` driver must be loaded on your system to use this application.
- This project depends on the PcapPlusPlus library. You will need to install this library and its static triplets using [vcpkg](https://github.com/microsoft/vcpkg), a C++ library manager.

For a 32-bit Windows system, you can install the necessary triplet with the following command:

```bash
vcpkg install pcapplusplus --triplet x86-windows-static
```

For a 64-bit Windows system, use the following command instead:

```bash
vcpkg install pcapplusplus --triplet x64-windows-static
```

### Running the Project

After you've installed the PcapPlusPlus library, you can now build and run the project to start intercepting network packets and extracting SNI information from HTTPS packets.

## Features

- Network Packet Interception: The application captures and analyzes network packets in real-time.
- SNI Extraction: It can extract the Server Name Indication (SNI) from HTTPS packets.
- TLS Fingerprinting: The application can also identify the specific version of Transport Layer Security (TLS) being used.




```

`examples/cpp/pcapplusplus/pcapplusplus.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{139FD3A5-D0F3-4068-81C9-A94FB58DC626}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>fastiotest</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <VcpkgUseStatic>false</VcpkgUseStatic>
    <VcpkgUseMD>false</VcpkgUseMD>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <VcpkgUseStatic>false</VcpkgUseStatic>
    <VcpkgUseMD>false</VcpkgUseMD>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <VcpkgUseStatic>false</VcpkgUseStatic>
    <VcpkgUseMD>false</VcpkgUseMD>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Vcpkg">
    <VcpkgUseStatic>false</VcpkgUseStatic>
    <VcpkgUseMD>false</VcpkgUseMD>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <VcpkgUseStatic>false</VcpkgUseStatic>
    <VcpkgUseMD>false</VcpkgUseMD>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Vcpkg">
    <VcpkgUseStatic>false</VcpkgUseStatic>
    <VcpkgUseMD>false</VcpkgUseMD>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnableManifest>true</VcpkgEnableManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\dll\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\dll\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\dll\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\dll\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\dll\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\dll\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\common\ndisapi\simple_packet_filter.h" />
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pcapplusplus.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg-configuration.json" />
    <None Include="vcpkg.json" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/cpp/pcapplusplus/pcapplusplus.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\common">
      <UniqueIdentifier>{f58d99f8-6dfc-44e1-9ff2-381efcda5d4d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\ndisapi">
      <UniqueIdentifier>{b7bffef8-2d56-4887-94c9-a3a5c019c40c}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\common\ndisapi\simple_packet_filter.h">
      <Filter>Header Files\common\ndisapi</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pcapplusplus.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg.json" />
    <None Include="vcpkg-configuration.json" />
  </ItemGroup>
</Project>
```

`examples/cpp/pcapplusplus/pch.h`:

```h
// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

#ifndef PCH_H
#define PCH_H

#include <winsock2.h>
#include <in6addr.h>
#include <tchar.h>
#include <ws2ipdef.h>
#include <IPHlpApi.h>
#include <Mstcpip.h>
#include <conio.h>
#include <WinDNS.h>

#include <memory>
#include <iostream>
#include <iomanip>
#include <chrono>
#include <thread>
#include <limits>
#include <atomic>
#include <string>
#include <functional>
#include <vector>
#include <cassert>
#include <array>
#include <map>
#include <cctype>
#include <variant>
#include <bitset>
#include <optional>
#include <algorithm>
#include <mutex>
#include <charconv>
#include <gsl/gsl>

#include "../../../include/common.h"
#include "../../../include/ndisapi.h"
#include "../common/iphlp.h"
#include "../common/winsys/object.h"
#include "../common/winsys/event.h"
#include "../common/net/mac_address.h"
#include "../common/net/ip_address.h"
#include "../common/net/ip_subnet.h"
#include "../common/iphelper/network_adapter_info.h"
#include "../common/ndisapi/network_adapter.h"
#include "../common/ndisapi/simple_packet_filter.h"

#endif //PCH_H

```

`examples/cpp/pcapplusplus/vcpkg-configuration.json`:

```json
{
  "default-registry": {
    "kind": "git",
    "baseline": "10b7a178346f3f0abef60cecd5130e295afd8da4",
    "repository": "https://github.com/microsoft/vcpkg"
  },
  "registries": [
    {
      "kind": "artifact",
      "location": "https://github.com/microsoft/vcpkg-ce-catalog/archive/refs/heads/main.zip",
      "name": "microsoft"
    }
  ]
}

```

`examples/cpp/pcapplusplus/vcpkg.json`:

```json
{
  "dependencies": [
    "ms-gsl",
    "pcapplusplus"
  ],
  "builtin-baseline": "7476f0d4e77d3333fbb249657df8251c28c4faae",
  "overrides": [
    {
      "name": "winpcap",
      "version": "4.1.3#10"
    }
  ]
}

```

`examples/cpp/rebind/README.md`:

```md
# Windows Packet Filter Rebind Example

This is an example application that demonstrates how to use the [Windows Packet Filter](https://www.ntkernel.com/windows-packet-filter/) driver to rebind outgoing TCP/UDP connections for the specified application from the default network interface to a different one. 

## Description

For instance, consider a host on our home network connected to both LAN (192.168.100.25/24) and Wi-Fi (192.168.100.165/24) simultaneously. By default, Windows prioritizes the LAN interface (192.168.100.25) for internet connectivity, leaving the Wi-Fi interface idle. Rebind enables the redirection of TCP/UDP connections for a chosen application, such as Firefox, to utilize the Wi-Fi interface instead of the LAN, while allowing other applications to continue operating on the LAN.

Another use case for Rebind can be bypassing a WireGuard VPN tunnel. Imagine you have a host running WireGuard, with all traffic being routed through the VPN tunnel. However, you want to use a specific application, like a video streaming service, without routing its traffic through the VPN for improved performance or to bypass geo-restrictions. In this scenario, you can use Rebind to redirect the traffic from that application to use the original, non-VPN network interface, bypassing the WireGuard tunnel, while all other applications remain connected through the VPN. This allows for more control over your network traffic and helps optimize connection performance for specific applications.

## Prerequisites

- Windows 10 (or Windows Server 2019)
- Visual Studio 2022
- Windows Packet Filter driver (download [here](https://www.ntkernel.com/windows-packet-filter/))

## How to Run

1. Download and install the Windows Packet Filter driver.
2. Open the `ndisapi.sln` solution in Visual Studio 2022.
3. Build the `rebind` project.
4. Run the `rebind.exe` application.

## Usage

The `rebind.exe` application performs network interface rebinding for a specified application running on a Windows computer. The following steps outline how to use this example:

1. Upon starting the application, the user is presented with a list of available network interfaces that are connected to the Internet. The user can select the default interface or any of the other available interfaces to perform the rebinding operation.

2. The user is then prompted to enter the name of the application to rebind. The application name can be obtained from the Task Manager.

3. Once the user has selected the interface and entered the application name, the application performs the rebinding operation and prints the new configuration parameters, including the source and destination MAC and IP addresses.

4. The user can stop the filtering operation at any time by pressing any key.

## Example Output

Rebinding chrome.exe from the default (Ethernet) network interface to the Wi-Fi interface:

```
WinpkFilter is loaded

Default Internet connected network interface:
    Ethernet	:	Intel(R) Ethernet Connection I219-LM
            10.0.0.9/8
            fdcf:7044:4b4d:3210:1875:8cd8:e40f:d31c/64
            00:1f:16:83:1a:9e
Alternative Internet connected network interfaces:
    1. Wi-Fi	:	Microsoft Wi-Fi Direct Virtual Adapter #2
            192.168.3.3/24
            fe80::d56a:fcf6:8206:f42c/64
            fa:71:3e:3b:21:e6
Application name to rebind: chrome

Select network interface to rebind: 1

Rebind parameters:

Application name: chrome
Rebind adapter source MAC: 00:1f:16:83:1a:9e
Default adapter source MAC: 00:1f:16:83:1a:9e
Rebind adapter gateway MAC: 38:60:77:85:18:22
Rebind adapter source IP address: 192.168.3.3
Default adapter source IP address: 10.0.0.9

Press any key to stop filtering
Exiting...
```

Rebinding chrome.exe from the default (WireGuard) network interface to the Wi-Fi interface. In this demo chrome.exe bypasses WireGuard tunnel:

```
WinpkFilter is loaded

Default Internet connected network interface:

        hp-fruct-nuccel :       WireGuard Tunnel #2
                fd42:42:42::3
                10.66.66.3
        Gateway:

Alternative Internet connected network interfaces:

1.      vEthernet (WLAN Virtual Switch) :       Hyper-V Virtual Ethernet Adapter #2
                fd42:42:42::5
                fe80::2e91:54ce:3a6:2823
                172.16.3.229
        Gateway:
                fd42:42:42::1 : 000000000000
                172.16.0.1 : 64D154C25BEE

Application name to rebind: chrome

Rebind parameters:

Application name: chrome
Rebind adapter source MAC: 18473D60269D
Default adapter source MAC: 000000000000
Rebind adapter gateway MAC: 64D154C25BEE
Rebind adapter source IP address: 172.16.3.229
Default adapter source IP address: 10.66.66.3


Press any key to stop filtering
Exiting...
```

## License

This example is licensed under the MIT License.

```

`examples/cpp/rebind/pch.h`:

```h
// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

#ifndef PCH_H
#define PCH_H

#include <winsock2.h>
#include <in6addr.h>
#include <tchar.h>
#include <ws2ipdef.h>
#include <IPHlpApi.h>
#include <Mstcpip.h>
#include <conio.h>
#include <WinDNS.h>

#include <memory>
#include <iostream>
#include <iomanip>
#include <chrono>
#include <thread>
#include <limits>
#include <atomic>
#include <string>
#include <functional>
#include <vector>
#include <cassert>
#include <array>
#include <map>
#include <cctype>
#include <mutex>
#include <shared_mutex>
#include <variant>
#include <bitset>
#include <optional>
#include <algorithm>
#include <fstream>
#include <charconv>
#include <gsl/gsl>

#include "../../../include/common.h"
#include "../../../include/ndisapi.h"
#include "../common/iphlp.h"
#include "../common/winsys/object.h"
#include "../common/winsys/event.h"
#include "../common/net/mac_address.h"
#include "../common/net/ip_address.h"
#include "../common/net/ip_endpoint.h"
#include "../common/pcap/pcap.h"
#include "../common/pcap/pcap_file_storage.h"
#include "../common/net/ip_subnet.h"
#include "../common/iphelper/network_adapter_info.h"
#include "../common/iphelper/process_lookup.h"
#include "../common/ndisapi/network_adapter.h"
#include "../common/ndisapi/dual_packet_filter.h"
#include "../common/tools/strings.h"

#endif //PCH_H

```

`examples/cpp/rebind/rebind.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{23F95304-9B53-4513-BA4F-4F388F9A8AF8}</ProjectGuid>
    <RootNamespace>rebind</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnableManifest>true</VcpkgEnableManifest>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING;_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeader>Create</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING;_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeader>Create</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING;_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeader>Create</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING;_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeader>Create</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING;_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeader>Create</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING;_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeader>Create</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp" />
    <ClCompile Include="rebind.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\common\iphelper\network_adapter_info.h" />
    <ClInclude Include="..\common\iphelper\process_lookup.h" />
    <ClInclude Include="..\common\iphlp.h" />
    <ClInclude Include="..\common\ndisapi\dual_packet_filter.h" />
    <ClInclude Include="..\common\ndisapi\network_adapter.h" />
    <ClInclude Include="..\common\net\ip_address.h" />
    <ClInclude Include="..\common\net\ip_endpoint.h" />
    <ClInclude Include="..\common\net\ip_subnet.h" />
    <ClInclude Include="..\common\net\mac_address.h" />
    <ClInclude Include="..\common\pcap\pcap.h" />
    <ClInclude Include="..\common\pcap\pcap_file_storage.h" />
    <ClInclude Include="..\common\tools\strings.h" />
    <ClInclude Include="..\common\winsys\event.h" />
    <ClInclude Include="..\common\winsys\object.h" />
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg-configuration.json" />
    <None Include="vcpkg.json" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/cpp/rebind/rebind.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\common">
      <UniqueIdentifier>{25864d8f-a290-4062-b452-9f1490202192}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\ndisapi">
      <UniqueIdentifier>{418f2a31-cc4e-4d65-913d-309b1e5f2c31}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\winsys">
      <UniqueIdentifier>{136897ef-45c2-4cf4-8b03-c125b2d3d307}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\net">
      <UniqueIdentifier>{ea769500-0685-4898-a174-c322bb76c28c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\pcap">
      <UniqueIdentifier>{2f93a9a5-6ea5-4451-8c1a-34dceae6e367}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\iphelper">
      <UniqueIdentifier>{db9faeb3-f7e4-492e-bfa4-11feb3654d44}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\tools">
      <UniqueIdentifier>{8c50e370-bc6d-4fee-b2b3-a5b168a1dd5c}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="rebind.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\common\ndisapi\dual_packet_filter.h">
      <Filter>Header Files\common\ndisapi</Filter>
    </ClInclude>
    <ClInclude Include="..\common\iphlp.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
    <ClInclude Include="..\common\ndisapi\network_adapter.h">
      <Filter>Header Files\common\ndisapi</Filter>
    </ClInclude>
    <ClInclude Include="..\common\net\ip_address.h">
      <Filter>Header Files\common\net</Filter>
    </ClInclude>
    <ClInclude Include="..\common\net\ip_subnet.h">
      <Filter>Header Files\common\net</Filter>
    </ClInclude>
    <ClInclude Include="..\common\net\mac_address.h">
      <Filter>Header Files\common\net</Filter>
    </ClInclude>
    <ClInclude Include="..\common\iphelper\network_adapter_info.h">
      <Filter>Header Files\common\iphelper</Filter>
    </ClInclude>
    <ClInclude Include="..\common\iphelper\process_lookup.h">
      <Filter>Header Files\common\iphelper</Filter>
    </ClInclude>
    <ClInclude Include="..\common\pcap\pcap.h">
      <Filter>Header Files\common\pcap</Filter>
    </ClInclude>
    <ClInclude Include="..\common\pcap\pcap_file_storage.h">
      <Filter>Header Files\common\pcap</Filter>
    </ClInclude>
    <ClInclude Include="..\common\winsys\event.h">
      <Filter>Header Files\common\winsys</Filter>
    </ClInclude>
    <ClInclude Include="..\common\winsys\object.h">
      <Filter>Header Files\common\winsys</Filter>
    </ClInclude>
    <ClInclude Include="..\common\net\ip_endpoint.h">
      <Filter>Header Files\common\net</Filter>
    </ClInclude>
    <ClInclude Include="..\common\tools\strings.h">
      <Filter>Header Files\common\tools</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg.json" />
    <None Include="vcpkg-configuration.json" />
  </ItemGroup>
</Project>
```

`examples/cpp/rebind/vcpkg-configuration.json`:

```json
{
  "default-registry": {
    "kind": "git",
    "baseline": "10b7a178346f3f0abef60cecd5130e295afd8da4",
    "repository": "https://github.com/microsoft/vcpkg"
  },
  "registries": [
    {
      "kind": "artifact",
      "location": "https://github.com/microsoft/vcpkg-ce-catalog/archive/refs/heads/main.zip",
      "name": "microsoft"
    }
  ]
}

```

`examples/cpp/rebind/vcpkg.json`:

```json
{
  "dependencies": [
    "ms-gsl"
  ]
}

```

`examples/cpp/sni_inspector/README.md`:

```md
# SNI Inspector

The `sni_inspector` is a C++ program that inspects the Server Name Indication (SNI) extension of TLS/SSL connections and Host from HTTP packets. This program utilizes the Windows Packet Filter driver to intercept and analyze network traffic.

## Overview

This program follows these steps:

1. It checks if the WinpkFilter driver is loaded.
2. If the driver is loaded, it displays a list of available network interfaces.
3. The user can select an interface to filter.
4. It starts filtering traffic on the selected interface and writes the hostnames from the SNI extension of each TLS/SSL connection and Host from HTTP packets to the console.
5. The program continues filtering until the user presses a key.

This tool can be valuable for troubleshooting TLS/SSL connection issues or for monitoring server traffic.

## Prerequisites

The program depends on the the Windows Packet Filter (WinpkFilter) driver. Ensure you have the WinpkFilter driver installed and loaded on your system.

```

`examples/cpp/sni_inspector/pch.h`:

```h
// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

#ifndef PCH_H
#define PCH_H

#include <winsock2.h>
#include <in6addr.h>
#include <tchar.h>
#include <ws2ipdef.h>
#include <IPHlpApi.h>
#include <Mstcpip.h>
#include <conio.h>
#include <WinDNS.h>

#include <memory>
#include <iostream>
#include <iomanip>
#include <chrono>
#include <thread>
#include <limits>
#include <atomic>
#include <string>
#include <functional>
#include <vector>
#include <cassert>
#include <array>
#include <map>
#include <cctype>
#include <variant>
#include <bitset>
#include <optional>
#include <algorithm>
#include <mutex>
#include <charconv>
#include <gsl/gsl>

#include "../../../include/common.h"
#include "../../../include/ndisapi.h"
#include "../common/iphlp.h"
#include "../common/winsys/object.h"
#include "../common/winsys/event.h"
#include "../common/net/mac_address.h"
#include "../common/net/ip_address.h"
#include "../common/net/ip_subnet.h"
#include "../common/iphelper/network_adapter_info.h"
#include "../common/ndisapi/network_adapter.h"
#include "../common/ndisapi/fastio_packet_filter.h"
#include "../common/ndisapi/local_redirect.h"

#endif //PCH_H

```

`examples/cpp/sni_inspector/sni_inspector.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{74C8277F-1507-45D7-B95A-1DC9E04C932A}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>fastiotest</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnableManifest>true</VcpkgEnableManifest>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\common\ndisapi\fastio_packet_filter.h" />
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="sni_inspector.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg-configuration.json" />
    <None Include="vcpkg.json" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/cpp/sni_inspector/sni_inspector.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\common">
      <UniqueIdentifier>{f58d99f8-6dfc-44e1-9ff2-381efcda5d4d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\ndisapi">
      <UniqueIdentifier>{b7bffef8-2d56-4887-94c9-a3a5c019c40c}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\common\ndisapi\fastio_packet_filter.h">
      <Filter>Header Files\common\ndisapi</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="sni_inspector.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg.json" />
    <None Include="vcpkg-configuration.json" />
  </ItemGroup>
</Project>
```

`examples/cpp/sni_inspector/vcpkg-configuration.json`:

```json
{
  "default-registry": {
    "kind": "git",
    "baseline": "10b7a178346f3f0abef60cecd5130e295afd8da4",
    "repository": "https://github.com/microsoft/vcpkg"
  },
  "registries": [
    {
      "kind": "artifact",
      "location": "https://github.com/microsoft/vcpkg-ce-catalog/archive/refs/heads/main.zip",
      "name": "microsoft"
    }
  ]
}

```

`examples/cpp/sni_inspector/vcpkg.json`:

```json
{
  "dependencies": [
    "ms-gsl"
  ]
}

```

`examples/cpp/socksify/README.md`:

```md
# Windows Packet Filter Socksify Example

This example demonstrates how to use the Windows Packet Filter to redirect the selected local process through a specified SOCKS5 proxy. In this case, we will redirect Firefox browser traffic through an SSH tunnel.

## Prerequisites

* Local SOCKS5 proxy (e.g., using an SSH command such as `ssh user@domain.com -D 8080`)

## Usage

1. Start your local SOCKS5 proxy. For example, using an SSH command:

```
ssh user@domain.com -D 8080
```

This command will expose a SOCKS5 proxy on localhost 127.0.0.1:8080.

2. Run the socksify.exe tool and follow the prompts:

```
D:\projects\winpkfilter\ndisapi\tools_bin_x64\tools\amd64>socksify.exe
WinpkFilter is loaded

Available network interfaces:

<numbered list of available network interfaces>

Select interface to filter: <interface number>

Application name to socksify: <application name>

SOCKS5 proxy IP address: <proxy IP address>

SOCKS5 proxy port: <proxy port>

Local port for the transparent TCP proxy server: <local port>

SOCKS5 USERNAME[optional]: <username>

SOCKS5 PASSWORD[optional]: <password>
```

Example:

```
Select interface to filter: 12

Application name to socksify: firefox

SOCKS5 proxy IP address: 127.0.0.1

SOCKS5 proxy port: 8080

Local port for the transparent TCP proxy server: 9000

SOCKS5 USERNAME[optional]:

SOCKS5 PASSWORD[optional]:
No suitable username or password specified, using anonymous authentication with SOCKS5 proxy
Press any key to stop filtering
Redirect entry was found for the port 50946 is 13.32.110.25:443
Redirect entry was found for the port 50948 is 34.160.90.233:443
Redirect entry was found for the port 50949 is 34.160.90.233:443
Redirect entry was found for the port 50950 is 34.160.90.233:443
...
```
After completing these steps, all traffic from the specified application (in this case, the Firefox browser) will be redirected through the transparent local proxy running on the specified local port (e.g., 9000), and then through the SOCKS5 proxy exposed by the SSH command at 127.0.0.1:8080.

```

`examples/cpp/socksify/pch.h`:

```h
// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

#ifndef PCH_H
#define PCH_H

#include <winsock2.h>
#include <in6addr.h>
#include <tchar.h>
#include <ws2ipdef.h>
#include <IPHlpApi.h>
#include <Mstcpip.h>
#include <conio.h>
#include <WinDNS.h>

#include <memory>
#include <iostream>
#include <iomanip>
#include <chrono>
#include <thread>
#include <limits>
#include <atomic>
#include <string>
#include <functional>
#include <vector>
#include <cassert>
#include <array>
#include <map>
#include <cctype>
#include <shared_mutex>
#include <set>
#include <algorithm>
#include <variant>
#include <bitset>
#include <optional>
#include <charconv>
#include <gsl/gsl>

#include "../../../include/common.h"
#include "../../../include/ndisapi.h"
#include "../common/iphlp.h"
#include "../common/winsys/object.h"
#include "../common/winsys/event.h"
#include "../common/winsys/io_completion_port.h"
#include "../common/net/mac_address.h"
#include "../common/net/ip_address.h"
#include "../common/net/ip_subnet.h"
#include "../common/net/ip_endpoint.h"
#include "../common/log/log.h"
#include "../common/iphelper/network_adapter_info.h"
#include "../common/ndisapi/network_adapter.h"
#include "../common/ndisapi/simple_packet_filter.h"
#include "../common/ndisapi/local_redirect.h"
#include "../common/proxy/proxy_common.h"
#include "../common/proxy/tcp_proxy_socket.h"
#include "../common/proxy/socks5_common.h"
#include "../common/proxy/socks5_tcp_proxy_socket.h"
#include "../common/proxy/tcp_proxy_server.h"
#include "../common/iphelper/process_lookup.h"

#endif //PCH_H

```

`examples/cpp/socksify/socksify.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{E20B38ED-BA56-4ED0-A06D-76396F2857D1}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>fastiotest</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>socksify</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnableManifest>true</VcpkgEnableManifest>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_RAND_S;NOMINMAX;_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_RAND_S;NOMINMAX;_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_RAND_S;NOMINMAX;_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_RAND_S;NOMINMAX;_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_RAND_S;NOMINMAX;_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_RAND_S;NOMINMAX;_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\common\iphelper\process_lookup.h" />
    <ClInclude Include="..\common\ndisapi\local_redirect.h" />
    <ClInclude Include="..\common\ndisapi\simple_packet_filter.h" />
    <ClInclude Include="..\common\proxy\proxy_common.h" />
    <ClInclude Include="..\common\proxy\socks5_common.h" />
    <ClInclude Include="..\common\proxy\socks5_tcp_proxy_socket.h" />
    <ClInclude Include="..\common\proxy\tcp_proxy_server.h" />
    <ClInclude Include="..\common\proxy\tcp_proxy_socket.h" />
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="socksify.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg-configuration.json" />
    <None Include="vcpkg.json" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/cpp/socksify/socksify.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\common">
      <UniqueIdentifier>{f58d99f8-6dfc-44e1-9ff2-381efcda5d4d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\ndisapi">
      <UniqueIdentifier>{b7bffef8-2d56-4887-94c9-a3a5c019c40c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\proxy">
      <UniqueIdentifier>{d2c8bd97-dd78-4184-a752-bea62281490c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\iphelper">
      <UniqueIdentifier>{1c70c634-1a25-4ca7-8a49-fd48b2225e0e}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\common\proxy\proxy_common.h">
      <Filter>Header Files\common\proxy</Filter>
    </ClInclude>
    <ClInclude Include="..\common\proxy\socks5_tcp_proxy_socket.h">
      <Filter>Header Files\common\proxy</Filter>
    </ClInclude>
    <ClInclude Include="..\common\proxy\tcp_proxy_server.h">
      <Filter>Header Files\common\proxy</Filter>
    </ClInclude>
    <ClInclude Include="..\common\proxy\tcp_proxy_socket.h">
      <Filter>Header Files\common\proxy</Filter>
    </ClInclude>
    <ClInclude Include="..\common\iphelper\process_lookup.h">
      <Filter>Header Files\common\iphelper</Filter>
    </ClInclude>
    <ClInclude Include="..\common\ndisapi\local_redirect.h">
      <Filter>Header Files\common\ndisapi</Filter>
    </ClInclude>
    <ClInclude Include="..\common\proxy\socks5_common.h">
      <Filter>Header Files\common\proxy</Filter>
    </ClInclude>
    <ClInclude Include="..\common\ndisapi\simple_packet_filter.h">
      <Filter>Header Files\common\ndisapi</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="socksify.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg.json" />
    <None Include="vcpkg-configuration.json" />
  </ItemGroup>
</Project>
```

`examples/cpp/socksify/vcpkg-configuration.json`:

```json
{
  "default-registry": {
    "kind": "git",
    "baseline": "10b7a178346f3f0abef60cecd5130e295afd8da4",
    "repository": "https://github.com/microsoft/vcpkg"
  },
  "registries": [
    {
      "kind": "artifact",
      "location": "https://github.com/microsoft/vcpkg-ce-catalog/archive/refs/heads/main.zip",
      "name": "microsoft"
    }
  ]
}

```

`examples/cpp/socksify/vcpkg.json`:

```json
{
  "dependencies": [
    "ms-gsl"
  ]
}

```

`examples/cpp/udp2tcp/README.md`:

```md
# UDP to TCP Converter

This C++ program acts as a UDP to TCP (and vice versa) converter, using Windows Packet Filter to intercept and modify network packets. 

## Running the Application

After building the project, you can run the application with the following command:

`./udp2tcp`

The application will prompt you to select a network interface and specify the server or client mode as well as the UDP port number.

## How it Works

The application uses the Windows Packet Filter (WinpkFilter) library to intercept network packets. The `load_filters` function sets up three filters:

1. Incoming TCP packets with a specific port are redirected and processed to convert TCP to UDP.
2. Outgoing UDP packets with a specific port are redirected and processed to convert UDP to TCP.
3. All other packets are passed without processing in user mode.

In the `main` function, the application creates a `simple_packet_filter` object with two lambda functions. The first lambda function handles incoming TCP packets and converts them to UDP. The second lambda function handles outgoing UDP packets and converts them to TCP.

```

`examples/cpp/udp2tcp/pch.h`:

```h
// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

#ifndef PCH_H
#define PCH_H

#include <winsock2.h>
#include <in6addr.h>
#include <tchar.h>
#include <ws2ipdef.h>
#include <IPHlpApi.h>
#include <Mstcpip.h>
#include <conio.h>
#include <WinDNS.h>

#include <memory>
#include <iostream>
#include <iomanip>
#include <chrono>
#include <thread>
#include <limits>
#include <atomic>
#include <string>
#include <functional>
#include <vector>
#include <cassert>
#include <array>
#include <map>
#include <cctype>
#include <mutex>
#include <shared_mutex>
#include <variant>
#include <bitset>
#include <optional>
#include <algorithm>
#include <fstream>
#include <charconv>
#include <gsl/gsl>

#include "../../../include/common.h"
#include "../../../include/ndisapi.h"
#include "../common/iphlp.h"
#include "../common/winsys/object.h"
#include "../common/winsys/event.h"
#include "../common/net/mac_address.h"
#include "../common/net/ip_address.h"
#include "../common/pcap/pcap.h"
#include "../common/pcap/pcap_file_storage.h"
#include "../common/net/ip_subnet.h"
#include "../common/iphelper/network_adapter_info.h"
#include "../common/ndisapi/network_adapter.h"
#include "../common/ndisapi/simple_packet_filter.h"

#endif //PCH_H

```

`examples/cpp/udp2tcp/udp2tcp.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{dab189fd-2137-4947-a215-cb714ef875df}</ProjectGuid>
    <RootNamespace>udp2tcp</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\examples\native\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnableManifest>true</VcpkgEnableManifest>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeader>Create</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeader>Create</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeader>Create</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeader>Create</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeader>Create</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_ENABLE_EXTENDED_ALIGNED_STORAGE;_LIB;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PrecompiledHeader>Create</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Iphlpapi.lib;ws2_32.lib;ndisapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)\bin\lib\$(Platform)\$(Configuration)\</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp" />
    <ClCompile Include="udp2tcp.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\common\iphelper\network_adapter_info.h" />
    <ClInclude Include="..\common\iphlp.h" />
    <ClInclude Include="..\common\ndisapi\network_adapter.h" />
    <ClInclude Include="..\common\ndisapi\simple_packet_filter.h" />
    <ClInclude Include="..\common\net\ip_address.h" />
    <ClInclude Include="..\common\net\ip_subnet.h" />
    <ClInclude Include="..\common\net\mac_address.h" />
    <ClInclude Include="..\common\pcap\pcap.h" />
    <ClInclude Include="..\common\pcap\pcap_file_storage.h" />
    <ClInclude Include="..\common\winsys\event.h" />
    <ClInclude Include="..\common\winsys\object.h" />
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg-configuration.json" />
    <None Include="vcpkg.json" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/cpp/udp2tcp/udp2tcp.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\common">
      <UniqueIdentifier>{25864d8f-a290-4062-b452-9f1490202192}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\ndisapi">
      <UniqueIdentifier>{418f2a31-cc4e-4d65-913d-309b1e5f2c31}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\iphelper">
      <UniqueIdentifier>{8545995d-8fc7-4763-8b43-3bf586db635d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\winsys">
      <UniqueIdentifier>{31776040-4792-49fa-bd6f-843789f0807b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\net">
      <UniqueIdentifier>{58bd7a97-2bed-4d0d-b86e-b4297e662218}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\common\pcap">
      <UniqueIdentifier>{db1b4cc4-4b6b-4172-9bf1-2b998be91cc6}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="udp2tcp.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\common\ndisapi\simple_packet_filter.h">
      <Filter>Header Files\common\ndisapi</Filter>
    </ClInclude>
    <ClInclude Include="..\common\iphelper\network_adapter_info.h">
      <Filter>Header Files\common\iphelper</Filter>
    </ClInclude>
    <ClInclude Include="..\common\winsys\event.h">
      <Filter>Header Files\common\winsys</Filter>
    </ClInclude>
    <ClInclude Include="..\common\winsys\object.h">
      <Filter>Header Files\common\winsys</Filter>
    </ClInclude>
    <ClInclude Include="..\common\pcap\pcap.h">
      <Filter>Header Files\common\pcap</Filter>
    </ClInclude>
    <ClInclude Include="..\common\pcap\pcap_file_storage.h">
      <Filter>Header Files\common\pcap</Filter>
    </ClInclude>
    <ClInclude Include="..\common\net\ip_address.h">
      <Filter>Header Files\common\net</Filter>
    </ClInclude>
    <ClInclude Include="..\common\net\ip_subnet.h">
      <Filter>Header Files\common\net</Filter>
    </ClInclude>
    <ClInclude Include="..\common\net\mac_address.h">
      <Filter>Header Files\common\net</Filter>
    </ClInclude>
    <ClInclude Include="..\common\ndisapi\network_adapter.h">
      <Filter>Header Files\common\ndisapi</Filter>
    </ClInclude>
    <ClInclude Include="..\common\iphlp.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="vcpkg.json" />
    <None Include="vcpkg-configuration.json" />
  </ItemGroup>
</Project>
```

`examples/cpp/udp2tcp/vcpkg-configuration.json`:

```json
{
  "default-registry": {
    "kind": "git",
    "baseline": "10b7a178346f3f0abef60cecd5130e295afd8da4",
    "repository": "https://github.com/microsoft/vcpkg"
  },
  "registries": [
    {
      "kind": "artifact",
      "location": "https://github.com/microsoft/vcpkg-ce-catalog/archive/refs/heads/main.zip",
      "name": "microsoft"
    }
  ]
}

```

`examples/cpp/udp2tcp/vcpkg.json`:

```json
{
  "dependencies": [
    "ms-gsl"
  ]
}

```

`examples/dotNet/TestDotNet/App.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.8.1"/>
    </startup>
</configuration>

```

`examples/dotNet/TestDotNet/README.md`:

```md
# TestDotNet

C# sample demonstrates the NDISAPI usage in several filtering scenarios. Available ion x86 and x64 configurations. AnyCPU configuration is not available due to the C++/CLI nature of ndisapi.net wrapper (see https://github.com/kevin-marshall/Managed.AnyCPU for the workaround). Projects references PacketDotNet (https://github.com/chmorgan/packetnet) for dumping network packets headers.



```

`examples/dotNet/TestDotNet/TestDotNet.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{C5AD5596-0073-4453-B8DE-63659B9F0004}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <RootNamespace>TestDotNet</RootNamespace>
    <AssemblyName>TestDotNet</AssemblyName>
    <TargetFrameworkVersion>v4.8.1</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>..\..\..\bin\examples\.net\x64\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>..\..\..\bin\examples\.net\x64\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>..\..\..\bin\examples\.net\x86\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <OutputPath>..\..\..\bin\examples\.net\x86\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|ARM64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>..\..\..\bin\examples\.net\ARM64\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>ARM64</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|ARM64'">
    <OutputPath>..\..\..\bin\examples\.net\ARM64\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>ARM64</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="log4net, Version=2.0.15.0, Culture=neutral, PublicKeyToken=669e0ddf0bb1aa2a, processorArchitecture=MSIL">
      <HintPath>..\..\..\packages\log4net.2.0.15\lib\net45\log4net.dll</HintPath>
    </Reference>
    <Reference Include="PacketDotNet, Version=1.4.7.0, Culture=neutral, PublicKeyToken=451414c7667b2a58, processorArchitecture=MSIL">
      <HintPath>..\..\..\packages\PacketDotNet.1.4.7\lib\net47\PacketDotNet.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Configuration" />
    <Reference Include="System.Core" />
    <Reference Include="System.Runtime.CompilerServices.Unsafe, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\..\..\packages\System.Runtime.CompilerServices.Unsafe.6.0.0\lib\net461\System.Runtime.CompilerServices.Unsafe.dll</HintPath>
    </Reference>
    <Reference Include="System.Web" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
    <None Include="packages.config" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\..\..\ndisapi.net\ndisapicl.vcxproj">
      <Project>{4403c695-9939-4402-9eab-43e88cf47997}</Project>
      <Name>ndisapi.net</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
```

`examples/dotNet/TestDotNet/packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="log4net" version="2.0.15" targetFramework="net481" />
  <package id="PacketDotNet" version="1.4.7" targetFramework="net481" />
  <package id="System.Runtime.CompilerServices.Unsafe" version="6.0.0" targetFramework="net461" />
</packages>
```

`examples/legacy/CSharp/CSharp.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2012
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "PassThru", "PassThru\PassThru.csproj", "{79600DBD-517F-4EEA-9C47-7AAF5D0BC862}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ListAdapters", "ListAdapters\ListAdapters.csproj", "{85B1406A-F58E-429F-97DF-79AC394D82C4}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "PacketSniffer", "PacketSniffer\PacketSniffer.csproj", "{EE907D70-7D34-4A21-8DB3-895D7815BC58}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "NdisApiWrapper", "NdisApi\NdisApiWrapper.csproj", "{188C7EE3-7CD5-44CA-819A-C400474493BF}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "NdisRequest", "NdisRequest\NdisRequest.csproj", "{87CEFC9E-FDD5-4499-8844-AACCE1A8A99B}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "FilterStats", "FilterStats\FilterStats.csproj", "{9D8EB301-283C-4EA1-A07C-3BAFD433C82A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Filter", "Filter\Filter.csproj", "{2B8D476E-F615-4015-83A3-A10BB93A6C9F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{79600DBD-517F-4EEA-9C47-7AAF5D0BC862}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{79600DBD-517F-4EEA-9C47-7AAF5D0BC862}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{79600DBD-517F-4EEA-9C47-7AAF5D0BC862}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{79600DBD-517F-4EEA-9C47-7AAF5D0BC862}.Release|Any CPU.Build.0 = Release|Any CPU
		{85B1406A-F58E-429F-97DF-79AC394D82C4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{85B1406A-F58E-429F-97DF-79AC394D82C4}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{85B1406A-F58E-429F-97DF-79AC394D82C4}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{85B1406A-F58E-429F-97DF-79AC394D82C4}.Release|Any CPU.Build.0 = Release|Any CPU
		{EE907D70-7D34-4A21-8DB3-895D7815BC58}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{EE907D70-7D34-4A21-8DB3-895D7815BC58}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{EE907D70-7D34-4A21-8DB3-895D7815BC58}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{EE907D70-7D34-4A21-8DB3-895D7815BC58}.Release|Any CPU.Build.0 = Release|Any CPU
		{188C7EE3-7CD5-44CA-819A-C400474493BF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{188C7EE3-7CD5-44CA-819A-C400474493BF}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{188C7EE3-7CD5-44CA-819A-C400474493BF}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{188C7EE3-7CD5-44CA-819A-C400474493BF}.Release|Any CPU.Build.0 = Release|Any CPU
		{87CEFC9E-FDD5-4499-8844-AACCE1A8A99B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{87CEFC9E-FDD5-4499-8844-AACCE1A8A99B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{87CEFC9E-FDD5-4499-8844-AACCE1A8A99B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{87CEFC9E-FDD5-4499-8844-AACCE1A8A99B}.Release|Any CPU.Build.0 = Release|Any CPU
		{9D8EB301-283C-4EA1-A07C-3BAFD433C82A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9D8EB301-283C-4EA1-A07C-3BAFD433C82A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9D8EB301-283C-4EA1-A07C-3BAFD433C82A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9D8EB301-283C-4EA1-A07C-3BAFD433C82A}.Release|Any CPU.Build.0 = Release|Any CPU
		{2B8D476E-F615-4015-83A3-A10BB93A6C9F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{2B8D476E-F615-4015-83A3-A10BB93A6C9F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{2B8D476E-F615-4015-83A3-A10BB93A6C9F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{2B8D476E-F615-4015-83A3-A10BB93A6C9F}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`examples/legacy/CSharp/Filter/Filter.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{2B8D476E-F615-4015-83A3-A10BB93A6C9F}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>Filter</RootNamespace>
    <AssemblyName>Filter</AssemblyName>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <PublishUrl>publish\</PublishUrl>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateMode>Foreground</UpdateMode>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <MapFileExtensions>true</MapFileExtensions>
    <ApplicationRevision>0</ApplicationRevision>
    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
    <UseApplicationTrust>false</UseApplicationTrust>
    <BootstrapperEnabled>true</BootstrapperEnabled>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <Prefer32Bit>false</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include=".NETFramework,Version=v4.5">
      <Visible>False</Visible>
      <ProductName>Microsoft .NET Framework 4.5 %28x86 and x64%29</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\NdisApi\NdisApiWrapper.csproj">
      <Project>{188c7ee3-7cd5-44ca-819a-c400474493bf}</Project>
      <Name>NdisApiWrapper</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`examples/legacy/CSharp/FilterStats/FilterStats.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{9D8EB301-283C-4EA1-A07C-3BAFD433C82A}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>FilterStats</RootNamespace>
    <AssemblyName>FilterStats</AssemblyName>
    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <UseVSHostingProcess>false</UseVSHostingProcess>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\NdisApi\NdisApiWrapper.csproj">
      <Project>{188c7ee3-7cd5-44ca-819a-c400474493bf}</Project>
      <Name>NdisApiWrapper</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`examples/legacy/CSharp/ListAdapters/ListAdapters.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.50727</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{85B1406A-F58E-429F-97DF-79AC394D82C4}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>ListAdapters</RootNamespace>
    <AssemblyName>ListAdapters</AssemblyName>
    <FileUpgradeFlags>
    </FileUpgradeFlags>
    <UpgradeBackupLocation>
    </UpgradeBackupLocation>
    <OldToolsVersion>3.5</OldToolsVersion>
    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <PlatformTarget>AnyCPU</PlatformTarget>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\NdisApi\NdisApiWrapper.csproj">
      <Project>{188c7ee3-7cd5-44ca-819a-c400474493bf}</Project>
      <Name>NdisApiWrapper</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`examples/legacy/CSharp/NdisApi/NdisApiWrapper.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.30703</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{188C7EE3-7CD5-44CA-819A-C400474493BF}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>NdisApiWrapper</RootNamespace>
    <AssemblyName>NdisApiWrapper</AssemblyName>
    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="IPStructs.cs" />
    <Compile Include="Ndisapi.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Win32Api.cs" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`examples/legacy/CSharp/NdisRequest/NdisRequest.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{87CEFC9E-FDD5-4499-8844-AACCE1A8A99B}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>NdisRequest</RootNamespace>
    <AssemblyName>NdisRequest</AssemblyName>
    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>false</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\NdisApi\NdisApiWrapper.csproj">
      <Project>{188c7ee3-7cd5-44ca-819a-c400474493bf}</Project>
      <Name>NdisApiWrapper</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`examples/legacy/CSharp/PacketSniffer/PacketSniffer.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.50727</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{EE907D70-7D34-4A21-8DB3-895D7815BC58}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>PacketSniffer</RootNamespace>
    <AssemblyName>PacketSniffer</AssemblyName>
    <FileUpgradeFlags>
    </FileUpgradeFlags>
    <UpgradeBackupLocation>
    </UpgradeBackupLocation>
    <OldToolsVersion>3.5</OldToolsVersion>
    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <PlatformTarget>AnyCPU</PlatformTarget>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\NdisApi\NdisApiWrapper.csproj">
      <Project>{188c7ee3-7cd5-44ca-819a-c400474493bf}</Project>
      <Name>NdisApiWrapper</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`examples/legacy/CSharp/PassThru/PassThru.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>8.0.50727</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{79600DBD-517F-4EEA-9C47-7AAF5D0BC862}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>PassThru</RootNamespace>
    <AssemblyName>PassThru</AssemblyName>
    <FileUpgradeFlags>
    </FileUpgradeFlags>
    <UpgradeBackupLocation>
    </UpgradeBackupLocation>
    <OldToolsVersion>3.5</OldToolsVersion>
    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <PlatformTarget>AnyCPU</PlatformTarget>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>..\bin\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\NdisApi\NdisApiWrapper.csproj">
      <Project>{188c7ee3-7cd5-44ca-819a-c400474493bf}</Project>
      <Name>NdisApiWrapper</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
</Project>
```

`examples/legacy/Delphi/ListAdapters/ListAdapters.cfg`:

```cfg
-$A8
-$B-
-$C+
-$D+
-$E-
-$F-
-$G+
-$H+
-$I+
-$J-
-$K-
-$L+
-$M-
-$N+
-$O+
-$P+
-$Q-
-$R-
-$S-
-$T-
-$U-
-$V+
-$W-
-$X+
-$YD
-$Z1
-cg
-AWinTypes=Windows;WinProcs=Windows;DbiTypes=BDE;DbiProcs=BDE;DbiErrs=BDE;
-H+
-W+
-M
-$M16384,1048576
-K$00400000
-E"..\bin"
-LE"c:\program files\borland\delphi7\Projects\Bpl"
-LN"c:\program files\borland\delphi7\Projects\Bpl"
-w-UNSAFE_TYPE
-w-UNSAFE_CODE
-w-UNSAFE_CAST

```

`examples/legacy/Delphi/ListAdapters/ListAdapters.dof`:

```dof
[FileVersion]
Version=7.0
[Compiler]
A=8
B=0
C=1
D=1
E=0
F=0
G=1
H=1
I=1
J=0
K=0
L=1
M=0
N=1
O=1
P=1
Q=0
R=0
S=0
T=0
U=0
V=1
W=0
X=1
Y=1
Z=1
ShowHints=1
ShowWarnings=1
UnitAliases=WinTypes=Windows;WinProcs=Windows;DbiTypes=BDE;DbiProcs=BDE;DbiErrs=BDE;
NamespacePrefix=
SymbolDeprecated=1
SymbolLibrary=1
SymbolPlatform=1
UnitLibrary=1
UnitPlatform=1
UnitDeprecated=1
HResultCompat=1
HidingMember=1
HiddenVirtual=1
Garbage=1
BoundsError=1
ZeroNilCompat=1
StringConstTruncated=1
ForLoopVarVarPar=1
TypedConstVarPar=1
AsgToTypedConst=1
CaseLabelRange=1
ForVariable=1
ConstructingAbstract=1
ComparisonFalse=1
ComparisonTrue=1
ComparingSignedUnsigned=1
CombiningSignedUnsigned=1
UnsupportedConstruct=1
FileOpen=1
FileOpenUnitSrc=1
BadGlobalSymbol=1
DuplicateConstructorDestructor=1
InvalidDirective=1
PackageNoLink=1
PackageThreadVar=1
ImplicitImport=1
HPPEMITIgnored=1
NoRetVal=1
UseBeforeDef=1
ForLoopVarUndef=1
UnitNameMismatch=1
NoCFGFileFound=1
MessageDirective=1
ImplicitVariants=1
UnicodeToLocale=1
LocaleToUnicode=1
ImagebaseMultiple=1
SuspiciousTypecast=1
PrivatePropAccessor=1
UnsafeType=0
UnsafeCode=0
UnsafeCast=0
[Linker]
MapFile=0
OutputObjs=0
ConsoleApp=1
DebugInfo=0
RemoteSymbols=0
MinStackSize=16384
MaxStackSize=1048576
ImageBase=4194304
ExeDescription=
[Directories]
OutputDir=..\bin
UnitOutputDir=
PackageDLLOutputDir=
PackageDCPOutputDir=
SearchPath=
Packages=vcl;rtl;vclx;indy;inet;xmlrtl;vclie;inetdbbde;inetdbxpress;dbrtl;dsnap;dsnapcon;vcldb;soaprtl;VclSmp;dbexpress;dbxcds;inetdb;bdertl;vcldbx;webdsnap;websnap;adortl;ibxpress;teeui;teedb;tee;dss;visualclx;visualdbclx;vclactnband;vclshlctrls;IntrawebDB_50_70;Intraweb_50_70;Rave50CLX;Rave50VCL;dclOffice2k
Conditionals=
DebugSourceDirs=
UsePackages=0
[Parameters]
RunParams=
HostApplication=
Launcher=
UseLauncher=0
DebugCWD=
[Language]
ActiveLang=
ProjectLang=
RootDir=
[Version Info]
IncludeVerInfo=0
AutoIncBuild=0
MajorVer=1
MinorVer=0
Release=0
Build=0
Debug=0
PreRelease=0
Special=0
Private=0
DLL=0
Locale=1049
CodePage=1251
[Version Info Keys]
CompanyName=
FileDescription=
FileVersion=1.0.0.0
InternalName=
LegalCopyright=
LegalTrademarks=
OriginalFilename=
ProductName=
ProductVersion=1.0.0.0
Comments=
[HistoryLists\hlUnitAliases]
Count=1
Item0=WinTypes=Windows;WinProcs=Windows;DbiTypes=BDE;DbiProcs=BDE;DbiErrs=BDE;
[HistoryLists\hlOutputDirectorry]
Count=1
Item0=..\bin

```

`examples/legacy/Delphi/ListAdapters/ListAdapters.dpr`:

```dpr
{                        Windows Packet Filter Kit 3.0                }
{                 Copyright(C) 2000-2010 NT Kernel Resources          }
{                         mailto: ndisrd@ntkernel.com                 }

program ListAdapters;

{$APPTYPE CONSOLE}

uses
  SysUtils, Windows,
  winpkf in '..\winpkf.pas';

var
  i: integer;
  hFilt: THANDLE;
  Adapts: PTCP_AdapterList;
  Mode: PADAPTER_MODE;
  aname: array[0..1023] of char;
  VerInfo: TOSVersionInfo;
  dwMTUDec: DWORD;
  dwAdapterStartupMode: DWORD;
begin
  // Allocate TCP_AdapterList record
  new(Adapts);

  // Allocate ADAPTER_MODE
  new(Mode);

  VerInfo.dwOSVersionInfoSize := SizeOf(TOSVersionInfo);
  GetVersionEx(VerInfo);

  // Initialize NDISAPI
  InitNDISAPI();

  dwMTUDec := GetMTUDecrement();
  dwAdapterStartupMode := GetAdaptersStartupMode();

  // Create driver object
  hFilt := OpenFilterDriver('NDISRD');

  // Check if driver loaded
  if IsDriverLoaded(hFilt) then begin

    GetTcpipBoundAdaptersInfo (hFilt, Adapts);
    for i := 1 to Adapts.m_nAdapterCount do begin
          // Convert internal network interface name to user-friendly one depending of the OS
          if VerInfo.dwPlatformId = VER_PLATFORM_WIN32_NT then
              if VerInfo.dwMajorVersion = 4 then
                ConvertWindowsNTAdapterName(PAnsiChar(string(Adapts.m_szAdapterNameList[i])), aname, 1024)
              else
                ConvertWindows2000AdapterName(PAnsiChar(string(Adapts.m_szAdapterNameList[i])), aname, 1024)
          else
            ConvertWindows9xAdapterName(PAnsiChar(string(Adapts.m_szAdapterNameList[i])), aname, 1024);

          // Dump some network interface information
          Writeln(i, ') ', string(aname));
          Writeln('     Internal Name: ', Pchar(string(Adapts.m_szAdapterNameList[i])));
          Writeln(Format('     Current MAC:   %.2x%.2x%.2x%.2x%.2x%.2x', [Adapts.m_czCurrentAddress[i][1], Adapts.m_czCurrentAddress[i][2], Adapts.m_czCurrentAddress[i][3], Adapts.m_czCurrentAddress[i][4], Adapts.m_czCurrentAddress[i][5], Adapts.m_czCurrentAddress[i][6]]));
          Writeln(Format('     Medium:        0x%.8X', [Adapts.m_nAdapterMediumList[i]]));
			    Writeln(Format('     Current MTU:   %d', [Adapts.m_usMTU[i]]));

          Mode.hAdapterHandle := Adapts.m_nAdapterHandle[i];
          GetAdapterMode(hFilt, Mode);

          Writeln(Format('     Current adapter mode:   %d', [Mode.dwFlags]));

          Writeln;
    end;
    Writeln('Current system wide MTU decrement = ', dwMTUDec);
    Writeln('Default adapter startup mode = ', dwAdapterStartupMode);
  end
  else
    Writeln('Helper driver failed to load or was not installed.');

  // Perform cleanup
  dispose(Adapts);
  CloseFilterDriver (hFilt);

  // Release NDISAPI
  FreeNDISAPI();
end.

```

`examples/legacy/Delphi/PacketSniffer/PacketSniffer.cfg`:

```cfg
-$A8
-$B-
-$C+
-$D+
-$E-
-$F-
-$G+
-$H+
-$I+
-$J-
-$K-
-$L+
-$M-
-$N+
-$O+
-$P+
-$Q-
-$R-
-$S-
-$T-
-$U-
-$V+
-$W-
-$X+
-$YD
-$Z1
-cg
-AWinTypes=Windows;WinProcs=Windows;DbiTypes=BDE;DbiProcs=BDE;DbiErrs=BDE;
-H+
-W+
-M
-$M16384,1048576
-K$00400000
-E"..\bin"
-LE"c:\program files\borland\delphi7\Projects\Bpl"
-LN"c:\program files\borland\delphi7\Projects\Bpl"
-w-UNSAFE_TYPE
-w-UNSAFE_CODE
-w-UNSAFE_CAST

```

`examples/legacy/Delphi/PacketSniffer/PacketSniffer.dof`:

```dof
[FileVersion]
Version=7.0
[Compiler]
A=8
B=0
C=1
D=1
E=0
F=0
G=1
H=1
I=1
J=0
K=0
L=1
M=0
N=1
O=1
P=1
Q=0
R=0
S=0
T=0
U=0
V=1
W=0
X=1
Y=1
Z=1
ShowHints=1
ShowWarnings=1
UnitAliases=WinTypes=Windows;WinProcs=Windows;DbiTypes=BDE;DbiProcs=BDE;DbiErrs=BDE;
NamespacePrefix=
SymbolDeprecated=1
SymbolLibrary=1
SymbolPlatform=1
UnitLibrary=1
UnitPlatform=1
UnitDeprecated=1
HResultCompat=1
HidingMember=1
HiddenVirtual=1
Garbage=1
BoundsError=1
ZeroNilCompat=1
StringConstTruncated=1
ForLoopVarVarPar=1
TypedConstVarPar=1
AsgToTypedConst=1
CaseLabelRange=1
ForVariable=1
ConstructingAbstract=1
ComparisonFalse=1
ComparisonTrue=1
ComparingSignedUnsigned=1
CombiningSignedUnsigned=1
UnsupportedConstruct=1
FileOpen=1
FileOpenUnitSrc=1
BadGlobalSymbol=1
DuplicateConstructorDestructor=1
InvalidDirective=1
PackageNoLink=1
PackageThreadVar=1
ImplicitImport=1
HPPEMITIgnored=1
NoRetVal=1
UseBeforeDef=1
ForLoopVarUndef=1
UnitNameMismatch=1
NoCFGFileFound=1
MessageDirective=1
ImplicitVariants=1
UnicodeToLocale=1
LocaleToUnicode=1
ImagebaseMultiple=1
SuspiciousTypecast=1
PrivatePropAccessor=1
UnsafeType=0
UnsafeCode=0
UnsafeCast=0
[Linker]
MapFile=0
OutputObjs=0
ConsoleApp=1
DebugInfo=0
RemoteSymbols=0
MinStackSize=16384
MaxStackSize=1048576
ImageBase=4194304
ExeDescription=
[Directories]
OutputDir=..\bin
UnitOutputDir=
PackageDLLOutputDir=
PackageDCPOutputDir=
SearchPath=
Packages=vcl;rtl;vclx;indy;inet;xmlrtl;vclie;inetdbbde;inetdbxpress;dbrtl;dsnap;dsnapcon;vcldb;soaprtl;VclSmp;dbexpress;dbxcds;inetdb;bdertl;vcldbx;webdsnap;websnap;adortl;ibxpress;teeui;teedb;tee;dss;visualclx;visualdbclx;vclactnband;vclshlctrls;IntrawebDB_50_70;Intraweb_50_70;Rave50CLX;Rave50VCL;dclOffice2k
Conditionals=
DebugSourceDirs=
UsePackages=0
[Parameters]
RunParams=1 100 -promisc
HostApplication=
Launcher=
UseLauncher=0
DebugCWD=
[Language]
ActiveLang=
ProjectLang=
RootDir=
[Version Info]
IncludeVerInfo=0
AutoIncBuild=0
MajorVer=1
MinorVer=0
Release=0
Build=0
Debug=0
PreRelease=0
Special=0
Private=0
DLL=0
Locale=1049
CodePage=1251
[Version Info Keys]
CompanyName=
FileDescription=
FileVersion=1.0.0.0
InternalName=
LegalCopyright=
LegalTrademarks=
OriginalFilename=
ProductName=
ProductVersion=1.0.0.0
Comments=
[HistoryLists\hlUnitAliases]
Count=1
Item0=WinTypes=Windows;WinProcs=Windows;DbiTypes=BDE;DbiProcs=BDE;DbiErrs=BDE;
[HistoryLists\hlOutputDirectorry]
Count=1
Item0=..\bin

```

`examples/legacy/Delphi/PacketSniffer/PacketSniffer.dpr`:

```dpr
{                        Windows Packet Filter Kit 3.0                }
{                 Copyright(C) 2000-2010 NT Kernel Resources          }
{                         mailto: ndisrd@ntkernel.com                 }

program PacketSniffer;

{$APPTYPE CONSOLE}

uses
  SysUtils,
  Windows,
  Winsock,
  winpkf in '..\winpkf.pas',
  iphlp in '..\iphlp.pas';

const
// Packet filter definitions from DDK
NDIS_PACKET_TYPE_DIRECTED         = $1;
NDIS_PACKET_TYPE_MULTICAST        = $2;
NDIS_PACKET_TYPE_ALL_MULTICAST    = $4;
NDIS_PACKET_TYPE_BROADCAST	      = $8;
NDIS_PACKET_TYPE_SOURCE_ROUTING   = $10;
NDIS_PACKET_TYPE_PROMISCUOUS	    = $20;
NDIS_PACKET_TYPE_SMT	            = $40;
NDIS_PACKET_TYPE_ALL_LOCAL        = $80;
NDIS_PACKET_TYPE_GROUP            = $1000;
NDIS_PACKET_TYPE_ALL_FUNCTIONAL   = $2000;
NDIS_PACKET_TYPE_FUNCTIONAL				= $4000;
NDIS_PACKET_TYPE_MAC_FRAME				= $8000;

var
  iIndex, counter: DWORD;
  hFilt: THANDLE;
  Adapts: TCP_AdapterList;
  AdapterMode: ADAPTER_MODE;
  Buffer: INTERMEDIATE_BUFFER;
  ReadRequest: ETH_REQUEST;
  hAdapter: THANDLE;
  pEtherHeader: TEtherHeaderPtr;
  bSetPromisc: Boolean;
  dwFilter: DWORD;
  pIPHeader: TIPHeaderPtr;
  pTcpHeader: TTCPHeaderPtr;
  pUdpHeader: TUDPHeaderPtr;
  SourceIP, DestIP: TInAddr;

procedure ReleaseInterface();
begin
  // Restore old packet filter
	if bSetPromisc then
			SetHwPacketFilter ( hFilt, hAdapter, dwFilter );

  // Restore default mode
  AdapterMode.dwFlags := 0;
  AdapterMode.hAdapterHandle := hAdapter;
  SetAdapterMode ( hFilt, @AdapterMode );

  // Close driver object
  CloseFilterDriver (hFilt);

  // Release NDISAPI
  FreeNDISAPI();
end;

begin
  bSetPromisc := False;

  // Check the number of parameters
  if ParamCount() < 2 then begin
    Writeln('Command line syntax:');
    Writeln('   PacketSniffer.exe index num [-promisc]');
    Writeln('   index - network interface index.');
    Writeln('   num - number or packets to capture');
    Writeln('   -promisc - optional parameter. ');
    Writeln('   When specified network interface is switched to the promiscuous mode.');
    Writeln('You can use ListAdapters to determine correct index.');
    Exit;
  end;

  // Initialize NDISAPI
  InitNDISAPI();

  // Create driver object
  hFilt := OpenFilterDriver('NDISRD');

  if IsDriverLoaded(hFilt) then begin

      // Get parameters from command line
      iIndex := StrToInt(ParamStr(1));
      counter := StrToInt(ParamStr(2));

      if ParamCount() = 3 then begin
          if StrComp(Pchar(ParamStr(3)), '-promisc') = 0 then bSetPromisc := True;
      end;

      // Set exit procedure
      ExitProcessProc := ReleaseInterface;

      // Get TCP/IP bound interfaces
      GetTcpipBoundAdaptersInfo (hFilt, @Adapts);

      // Check paramer values
      if iIndex > Adapts.m_nAdapterCount then begin
        Writeln ('There is no network interface with such index on this system.');
        Exit;
      end;

      hAdapter := Adapts.m_nAdapterHandle[iIndex];

      // Set promiscuous mode if specified from command line
      if bSetPromisc then begin
        if GetHwPacketFilter ( hFilt, hAdapter, dwFilter ) = 0 then
            Writeln ('Failed to get current packet filter from the network interface.');
        if SetHwPacketFilter ( hFilt, hAdapter, NDIS_PACKET_TYPE_PROMISCUOUS ) = 0 then
            Writeln('Failed to set promiscuous mode fro the network interface.');
      end;

      // Initialize adapter mode
      if bSetPromisc then
          AdapterMode.dwFlags := MSTCP_FLAG_SENT_LISTEN or MSTCP_FLAG_RECV_LISTEN or MSTCP_FLAG_FILTER_DIRECT or MSTCP_FLAG_LOOPBACK_BLOCK
      else
          AdapterMode.dwFlags := MSTCP_FLAG_SENT_LISTEN or MSTCP_FLAG_RECV_LISTEN;

      AdapterMode.hAdapterHandle := hAdapter;

       // Initialize request
       ReadRequest.EthPacket.Buffer := @Buffer;
       ReadRequest.hAdapterHandle := hAdapter;

       // Set adapter mode
       SetAdapterMode ( hFilt, @AdapterMode );

       // Capture 'counter' packets from the interface
       while counter <> 0 do begin
            while ReadPacket (hFilt, @ReadRequest) <> 0 do begin
              Dec (counter);
              Writeln;
              if Buffer.m_dwDeviceFlags = PACKET_FLAG_ON_SEND then
                  Writeln(counter, ') - MSTCP --> Interface' )
              else
                  Writeln(counter, ') - Interface --> MSTCP' );

              Writeln ('     Packet size =    ', Buffer.m_Length);
              pEtherHeader := TEtherHeaderPtr (@Buffer.m_IBuffer);

              Writeln (Format('     Source MAC:      %.2x%.2x%.2x%.2x%.2x%.2x',
				        [pEtherHeader.h_source[1],
				        pEtherHeader.h_source[2],
				        pEtherHeader.h_source[3],
				        pEtherHeader.h_source[4],
				        pEtherHeader.h_source[5],
				        pEtherHeader.h_source[6]]));

              Writeln (Format('     Destination MAC: %.2x%.2x%.2x%.2x%.2x%.2x',
				        [pEtherHeader.h_dest[1],
				        pEtherHeader.h_dest[2],
				        pEtherHeader.h_dest[3],
				        pEtherHeader.h_dest[4],
				        pEtherHeader.h_dest[5],
				        pEtherHeader.h_dest[6]]));

              if ntohs(pEtherHeader.h_proto) = ETH_P_IP then
                begin
                  pIPHeader := TIPHeaderPtr(Integer(pEtherHeader) +
                    SizeOf(TEtherHeader));

                  SourceIP.S_addr := pIPHeader.SourceIp;
                  DestIP.S_addr := pIPHeader.DestIp;

                  Writeln (Format('     IP %.3u.%.3u.%.3u.%.3u --> %.3u.%.3u.%.3u.%.3u PROTOCOL: %u',
					          [byte(SourceIP.S_un_b.s_b1),
					          byte(SourceIP.S_un_b.s_b2),
					          byte(SourceIP.S_un_b.s_b3),
					          byte(SourceIP.S_un_b.s_b4),
					          byte(DestIP.S_un_b.s_b1),
					          byte(DestIP.S_un_b.s_b2),
					          byte(DestIP.S_un_b.s_b3),
					          byte(DestIP.S_un_b.s_b4),
					          byte(pIPHeader.Protocol)]
					          ));

                    if pIPHeader.Protocol = IPPROTO_TCP then
                      begin
                        pTcpHeader  := TTCPHeaderPtr(Integer(pIPHeader) + (pIPHeader.VerLen and $F) * 4);
                        Writeln (Format('     TCP SRC PORT: %d DST PORT: %d',
                            [ntohs(pTcpHeader.SourcePort),
						                ntohs(pTcpHeader.DestPort)]));
                      end;

                    if pIPHeader.Protocol = IPPROTO_UDP then
                      begin
                        pUdpHeader  := TUDPHeaderPtr(Integer(pIPHeader) + (pIPHeader.VerLen and $F) * 4);
                        Writeln (Format('     UDP SRC PORT: %d DST PORT: %d',
                            [ntohs(pUdpHeader.SourcePort),
						                ntohs(pUdpHeader.DestPort)]));
                      end;
                end;

              if ntohs(pEtherHeader.h_proto) = ETH_P_RARP then
                  Writeln('     Reverse Addr Res packet');

			        if ntohs(pEtherHeader.h_proto) = ETH_P_ARP  then
                  Writeln('     Address Resolution packet');

              Writeln;

              if counter = 0 then begin
				        Writeln ('Filtering complete');
				        break;
              end;
            end;
            Write ('.');
			      Sleep(100);
       end;
  end;
end.

```

`examples/legacy/Delphi/PassThru/PassThru.cfg`:

```cfg
-$A8
-$B-
-$C+
-$D+
-$E-
-$F-
-$G+
-$H+
-$I+
-$J-
-$K-
-$L+
-$M-
-$N+
-$O+
-$P+
-$Q-
-$R-
-$S-
-$T-
-$U-
-$V+
-$W-
-$X+
-$YD
-$Z1
-cg
-AWinTypes=Windows;WinProcs=Windows;DbiTypes=BDE;DbiProcs=BDE;DbiErrs=BDE;
-H+
-W+
-M
-$M16384,1048576
-K$00400000
-E"..\bin"
-LE"c:\program files\borland\delphi7\Projects\Bpl"
-LN"c:\program files\borland\delphi7\Projects\Bpl"
-w-UNSAFE_TYPE
-w-UNSAFE_CODE
-w-UNSAFE_CAST

```

`examples/legacy/Delphi/PassThru/PassThru.dof`:

```dof
[FileVersion]
Version=7.0
[Compiler]
A=8
B=0
C=1
D=1
E=0
F=0
G=1
H=1
I=1
J=0
K=0
L=1
M=0
N=1
O=1
P=1
Q=0
R=0
S=0
T=0
U=0
V=1
W=0
X=1
Y=1
Z=1
ShowHints=1
ShowWarnings=1
UnitAliases=WinTypes=Windows;WinProcs=Windows;DbiTypes=BDE;DbiProcs=BDE;DbiErrs=BDE;
NamespacePrefix=
SymbolDeprecated=1
SymbolLibrary=1
SymbolPlatform=1
UnitLibrary=1
UnitPlatform=1
UnitDeprecated=1
HResultCompat=1
HidingMember=1
HiddenVirtual=1
Garbage=1
BoundsError=1
ZeroNilCompat=1
StringConstTruncated=1
ForLoopVarVarPar=1
TypedConstVarPar=1
AsgToTypedConst=1
CaseLabelRange=1
ForVariable=1
ConstructingAbstract=1
ComparisonFalse=1
ComparisonTrue=1
ComparingSignedUnsigned=1
CombiningSignedUnsigned=1
UnsupportedConstruct=1
FileOpen=1
FileOpenUnitSrc=1
BadGlobalSymbol=1
DuplicateConstructorDestructor=1
InvalidDirective=1
PackageNoLink=1
PackageThreadVar=1
ImplicitImport=1
HPPEMITIgnored=1
NoRetVal=1
UseBeforeDef=1
ForLoopVarUndef=1
UnitNameMismatch=1
NoCFGFileFound=1
MessageDirective=1
ImplicitVariants=1
UnicodeToLocale=1
LocaleToUnicode=1
ImagebaseMultiple=1
SuspiciousTypecast=1
PrivatePropAccessor=1
UnsafeType=0
UnsafeCode=0
UnsafeCast=0
[Linker]
MapFile=0
OutputObjs=0
ConsoleApp=1
DebugInfo=0
RemoteSymbols=0
MinStackSize=16384
MaxStackSize=1048576
ImageBase=4194304
ExeDescription=
[Directories]
OutputDir=..\bin
UnitOutputDir=
PackageDLLOutputDir=
PackageDCPOutputDir=
SearchPath=
Packages=vcl;rtl;vclx;indy;inet;xmlrtl;vclie;inetdbbde;inetdbxpress;dbrtl;dsnap;dsnapcon;vcldb;soaprtl;VclSmp;dbexpress;dbxcds;inetdb;bdertl;vcldbx;webdsnap;websnap;adortl;ibxpress;teeui;teedb;tee;dss;visualclx;visualdbclx;vclactnband;vclshlctrls;IntrawebDB_50_70;Intraweb_50_70;Rave50CLX;Rave50VCL;dclOffice2k
Conditionals=
DebugSourceDirs=
UsePackages=0
[Parameters]
RunParams=3 10
HostApplication=D:\Projects\Packet Redirector SDK 1.1\Delphi\bin\PassThru.exe
Launcher=
UseLauncher=0
DebugCWD=..\bin
[Language]
ActiveLang=
ProjectLang=
RootDir=
[Version Info]
IncludeVerInfo=0
AutoIncBuild=0
MajorVer=1
MinorVer=0
Release=0
Build=0
Debug=0
PreRelease=0
Special=0
Private=0
DLL=0
Locale=1049
CodePage=1251
[Version Info Keys]
CompanyName=
FileDescription=
FileVersion=1.0.0.0
InternalName=
LegalCopyright=
LegalTrademarks=
OriginalFilename=
ProductName=
ProductVersion=1.0.0.0
Comments=
[HistoryLists\hlUnitAliases]
Count=1
Item0=WinTypes=Windows;WinProcs=Windows;DbiTypes=BDE;DbiProcs=BDE;DbiErrs=BDE;
[HistoryLists\hlOutputDirectorry]
Count=1
Item0=..\bin

```

`examples/legacy/Delphi/PassThru/PassThru.dpr`:

```dpr
{                        Windows Packet Filter Kit 3.0                }
{                 Copyright(C) 2000-2010 NT Kernel Resources          }
{                         mailto: ndisrd@ntkernel.com                 }

program PassThru;

{$APPTYPE CONSOLE}

uses
  SysUtils,
  Windows,
  Winsock,
  winpkf in '..\winpkf.pas',
  iphlp in '..\iphlp.pas';

var
  iIndex, counter: DWORD;
  hFilt: THANDLE;
  Adapts: TCP_AdapterList;
  AdapterMode: ADAPTER_MODE;
  Buffer: INTERMEDIATE_BUFFER;
  ReadRequest: ETH_REQUEST;
  hEvent: THANDLE;
  hAdapter: THANDLE;
  pEtherHeader: TEtherHeaderPtr;
  pIPHeader: TIPHeaderPtr;
  pTcpHeader: TTCPHeaderPtr;
  pUdpHeader: TUDPHeaderPtr;
  SourceIP, DestIP: TInAddr;

procedure ReleaseInterface();
begin
  // Restore default mode
  AdapterMode.dwFlags := 0;
  AdapterMode.hAdapterHandle := hAdapter;
  SetAdapterMode ( hFilt, @AdapterMode );

  // Set NULL event to release previously set event object
  SetPacketEvent (hFilt, hAdapter, 0);

  // Close Event
  if hEvent <> 0 then CloseHandle(hEvent);

  // Close driver object
  CloseFilterDriver (hFilt);

  // Release NDISAPI
  FreeNDISAPI();
end;

begin

  // Check the number of parameters
  if ParamCount() < 2 then begin
    Writeln('Command line syntax:');
    Writeln('   PassThru.exe index num');
    Writeln('   index - network interface index.');
    Writeln('   num - number or packets to filter');
    Writeln('You can use ListAdapters to determine correct index.');
    Exit;
  end;

  // Initialize NDISAPI
  InitNDISAPI();

  // Create driver object
  hFilt := OpenFilterDriver('NDISRD');

  if IsDriverLoaded(hFilt) then begin

      // Get parameters from command line
      iIndex := StrToInt(ParamStr(1));
      counter := StrToInt(ParamStr(2));

      // Set exit procedure
      ExitProcessProc := ReleaseInterface;

      // Get TCP/IP bound interfaces
      GetTcpipBoundAdaptersInfo (hFilt, @Adapts);

      // Check paramer values
      if iIndex > Adapts.m_nAdapterCount then begin
        Writeln ('There is no network interface with such index on this system.');
        Exit;
      end;

      hAdapter := Adapts.m_nAdapterHandle[iIndex];

      AdapterMode.dwFlags := MSTCP_FLAG_SENT_TUNNEL or MSTCP_FLAG_RECV_TUNNEL;
      AdapterMode.hAdapterHandle := hAdapter;

      // Create notification event
	    hEvent := CreateEvent(Nil, TRUE, FALSE, Nil);

      if hEvent <> 0 then
        if SetPacketEvent (hFilt, hAdapter, hEvent) <> 0 then begin
          // Initialize request
          ReadRequest.EthPacket.Buffer := @Buffer;
	        ReadRequest.hAdapterHandle := hAdapter;

          SetAdapterMode ( hFilt, @AdapterMode );

          while counter <> 0 do begin
            WaitForSingleObject ( hEvent, INFINITE );
            while ReadPacket (hFilt, @ReadRequest) <> 0 do begin
              Dec (counter);
              if Buffer.m_dwDeviceFlags = PACKET_FLAG_ON_SEND then
                  Writeln(counter, ') - MSTCP --> Interface' )
              else
                  Writeln(counter, ') - Interface --> MSTCP' );

              Writeln ('     Packet size =    ', Buffer.m_Length);
              pEtherHeader := TEtherHeaderPtr (@Buffer.m_IBuffer);

              Writeln (Format('     Source MAC:      %.2x%.2x%.2x%.2x%.2x%.2x',
				        [pEtherHeader.h_source[1],
				        pEtherHeader.h_source[2],
				        pEtherHeader.h_source[3],
				        pEtherHeader.h_source[4],
				        pEtherHeader.h_source[5],
				        pEtherHeader.h_source[6]]));

              Writeln (Format('     Destination MAC: %.2x%.2x%.2x%.2x%.2x%.2x',
				        [pEtherHeader.h_dest[1],
				        pEtherHeader.h_dest[2],
				        pEtherHeader.h_dest[3],
				        pEtherHeader.h_dest[4],
				        pEtherHeader.h_dest[5],
				        pEtherHeader.h_dest[6]]));

               if ntohs(pEtherHeader.h_proto) = ETH_P_IP then
                begin
                  pIPHeader := TIPHeaderPtr(Integer(pEtherHeader) +
                    SizeOf(TEtherHeader));

                  SourceIP.S_addr := pIPHeader.SourceIp;
                  DestIP.S_addr := pIPHeader.DestIp;

                  Writeln (Format('     IP %.3u.%.3u.%.3u.%.3u --> %.3u.%.3u.%.3u.%.3u PROTOCOL: %u',
					          [byte(SourceIP.S_un_b.s_b1),
					          byte(SourceIP.S_un_b.s_b2),
					          byte(SourceIP.S_un_b.s_b3),
					          byte(SourceIP.S_un_b.s_b4),
					          byte(DestIP.S_un_b.s_b1),
					          byte(DestIP.S_un_b.s_b2),
					          byte(DestIP.S_un_b.s_b3),
					          byte(DestIP.S_un_b.s_b4),
					          byte(pIPHeader.Protocol)]
					          ));

                    if pIPHeader.Protocol = IPPROTO_TCP then
                      begin
                        pTcpHeader  := TTCPHeaderPtr(Integer(pIPHeader) + (pIPHeader.VerLen and $F) * 4);
                        Writeln (Format('     TCP SRC PORT: %d DST PORT: %d',
                            [ntohs(pTcpHeader.SourcePort),
						                ntohs(pTcpHeader.DestPort)]));
                      end;

                    if pIPHeader.Protocol = IPPROTO_UDP then
                      begin
                        pUdpHeader  := TUDPHeaderPtr(Integer(pIPHeader) + (pIPHeader.VerLen and $F) * 4);
                        Writeln (Format('     UDP SRC PORT: %d DST PORT: %d',
                            [ntohs(pUdpHeader.SourcePort),
						                ntohs(pUdpHeader.DestPort)]));
                      end;
                end;

			        if ntohs(pEtherHeader.h_proto) = ETH_P_RARP then
                  Writeln('     Reverse Addr Res packet');

			        if ntohs(pEtherHeader.h_proto) = ETH_P_ARP  then
                  Writeln('     Address Resolution packet');

              Writeln;

              if Buffer.m_dwDeviceFlags = PACKET_FLAG_ON_SEND then
                  // Place packet on the network interface
				          SendPacketToAdapter(hFilt, @ReadRequest)
              else
                  // Indicate packet to MSTCP
				          SendPacketToMstcp(hFilt, @ReadRequest);

              if counter = 0 then begin
				        Writeln ('Filtering complete');
				        break;
              end;
            end;
            ResetEvent(hEvent);
          end;
        end;
  end;
end.

```

`examples/legacy/Delphi/iphlp.pas`:

```pas
{                        Windows Packet Filter Kit 3.0                }
{                 Copyright(C) 2000-2010 NT Kernel Resources          }
{                         mailto: ndisrd@ntkernel.com                 }

unit iphlp;

interface

uses Windows;

const
ETH_ALEN      = 6;		  // Octets in one ethernet addr
ARPHRD_ETHER  = $01;
ARPOP_REQUEST =	$01;
ARPOP_REPLY	  = $02;

ETH_P_IP		= $0800;	// Internet Protocol packet
ETH_P_RARP    		= $8035;	// Reverse Addr Res packet
ETH_P_ARP		= $0806;	// Address Resolution packet

// Protocols

IPPROTO_IP    = 0;      // dummy for IP
IPPROTO_ICMP  = 1;      // control message protocol
IPPROTO_IGMP  = 2;      // group management protocol
IPPROTO_GGP   = 3;      // gateway^2 (deprecated)
IPPROTO_TCP   = 6;      // tcp
IPPROTO_PUP   = 12;     // pup
IPPROTO_UDP   = 17;     // user datagram protocol
IPPROTO_IDP   = 22;     // xns idp
IPPROTO_ND    = 77;     // UNOFFICIAL net disk proto

IPPROTO_RAW   = 255;    // raw IP packet
IPPROTO_MAX   = 256;

//
// Ethernet Header
//
type
  TEtherHeaderPtr = ^TEtherHeader;
  TEtherHeader = packed record
      h_dest: array [1..ETH_ALEN] of Byte;	{ destination eth addr	}
	    h_source: array [1..ETH_ALEN] of Byte;	{ source ether addr	}
	    h_proto: Word;		{ packet type ID field }
end;

//
// IP header
//
type
  TIPHeaderPtr = ^TIPHeader;
  TIPHeader = packed record
      VerLen: Byte;
      TOS: Byte;
      TotalLen: Word;
      Identifer: Word;
      FragOffsets: Word;
      TTL: Byte;
      Protocol: Byte;
      CheckSum: Word;
      SourceIp: DWORD;
      DestIp: DWORD;
      Options: DWORD;
end;

//
// TCP header
//
TTCPHeaderPtr = ^TTCPHeader;
  TTCPHeader = packed record
       SourcePort:Word;
       DestPort:Word;
       SequenceNumber:DWord;
       AcknowledgementNumber:DWord;
       Offset:Byte; //only left 4 bits. Header length in 32-bit segments
       Flags:Byte;
       Window:Word;
       Checksum:Word;  //includes speudo header instead of TCP header.
       UrgentPointer:Word;
  end; 

//
// UDP header
//
TUDPHeaderPtr = ^TUDPHeader;
  TUDPHeader = packed record
       SourcePort:Word;
       DestPort:Word;
       Length:Word;
       Checksum:Word;  
  end; 


implementation

end.

```

`examples/legacy/Delphi/ndisrequest/ndisrequest.cfg`:

```cfg
-$A8
-$B-
-$C+
-$D+
-$E-
-$F-
-$G+
-$H+
-$I+
-$J-
-$K-
-$L+
-$M-
-$N+
-$O+
-$P+
-$Q-
-$R-
-$S-
-$T-
-$U-
-$V+
-$W-
-$X+
-$YD
-$Z1
-cg
-AWinTypes=Windows;WinProcs=Windows;DbiTypes=BDE;DbiProcs=BDE;DbiErrs=BDE;
-H+
-W+
-M
-$M16384,1048576
-K$00400000
-E"..\bin"
-LE"c:\program files\borland\delphi7\Projects\Bpl"
-LN"c:\program files\borland\delphi7\Projects\Bpl"
-w-UNSAFE_TYPE
-w-UNSAFE_CODE
-w-UNSAFE_CAST

```

`examples/legacy/Delphi/ndisrequest/ndisrequest.dof`:

```dof
[FileVersion]
Version=7.0
[Compiler]
A=8
B=0
C=1
D=1
E=0
F=0
G=1
H=1
I=1
J=0
K=0
L=1
M=0
N=1
O=1
P=1
Q=0
R=0
S=0
T=0
U=0
V=1
W=0
X=1
Y=1
Z=1
ShowHints=1
ShowWarnings=1
UnitAliases=WinTypes=Windows;WinProcs=Windows;DbiTypes=BDE;DbiProcs=BDE;DbiErrs=BDE;
NamespacePrefix=
SymbolDeprecated=1
SymbolLibrary=1
SymbolPlatform=1
UnitLibrary=1
UnitPlatform=1
UnitDeprecated=1
HResultCompat=1
HidingMember=1
HiddenVirtual=1
Garbage=1
BoundsError=1
ZeroNilCompat=1
StringConstTruncated=1
ForLoopVarVarPar=1
TypedConstVarPar=1
AsgToTypedConst=1
CaseLabelRange=1
ForVariable=1
ConstructingAbstract=1
ComparisonFalse=1
ComparisonTrue=1
ComparingSignedUnsigned=1
CombiningSignedUnsigned=1
UnsupportedConstruct=1
FileOpen=1
FileOpenUnitSrc=1
BadGlobalSymbol=1
DuplicateConstructorDestructor=1
InvalidDirective=1
PackageNoLink=1
PackageThreadVar=1
ImplicitImport=1
HPPEMITIgnored=1
NoRetVal=1
UseBeforeDef=1
ForLoopVarUndef=1
UnitNameMismatch=1
NoCFGFileFound=1
MessageDirective=1
ImplicitVariants=1
UnicodeToLocale=1
LocaleToUnicode=1
ImagebaseMultiple=1
SuspiciousTypecast=1
PrivatePropAccessor=1
UnsafeType=0
UnsafeCode=0
UnsafeCast=0
[Linker]
MapFile=0
OutputObjs=0
ConsoleApp=1
DebugInfo=0
RemoteSymbols=0
MinStackSize=16384
MaxStackSize=1048576
ImageBase=4194304
ExeDescription=
[Directories]
OutputDir=..\bin
UnitOutputDir=
PackageDLLOutputDir=
PackageDCPOutputDir=
SearchPath=
Packages=vcl;rtl;vclx;indy;inet;xmlrtl;vclie;inetdbbde;inetdbxpress;dbrtl;dsnap;dsnapcon;vcldb;soaprtl;VclSmp;dbexpress;dbxcds;inetdb;bdertl;vcldbx;webdsnap;websnap;adortl;ibxpress;teeui;teedb;tee;dss;visualclx;visualdbclx;vclactnband;vclshlctrls;IntrawebDB_50_70;Intraweb_50_70;Rave50CLX;Rave50VCL;dclOffice2k
Conditionals=
DebugSourceDirs=
UsePackages=0
[Parameters]
RunParams=
HostApplication=
Launcher=
UseLauncher=0
DebugCWD=
[Language]
ActiveLang=
ProjectLang=
RootDir=
[Version Info]
IncludeVerInfo=0
AutoIncBuild=0
MajorVer=1
MinorVer=0
Release=0
Build=0
Debug=0
PreRelease=0
Special=0
Private=0
DLL=0
Locale=1049
CodePage=1251
[Version Info Keys]
CompanyName=
FileDescription=
FileVersion=1.0.0.0
InternalName=
LegalCopyright=
LegalTrademarks=
OriginalFilename=
ProductName=
ProductVersion=1.0.0.0
Comments=
[HistoryLists\hlUnitAliases]
Count=1
Item0=WinTypes=Windows;WinProcs=Windows;DbiTypes=BDE;DbiProcs=BDE;DbiErrs=BDE;
[HistoryLists\hlOutputDirectorry]
Count=1
Item0=..\bin

```

`examples/legacy/Delphi/ndisrequest/ndisrequest.dpr`:

```dpr
{                        Windows Packet Filter Kit 3.0                }
{                 Copyright(C) 2000-2010 NT Kernel Resources          }
{                         mailto: ndisrd@ntkernel.com                 }

program ndisrequest;

{$APPTYPE CONSOLE}

uses
  SysUtils,
  Windows,
  winpkf in '..\winpkf.pas';

const

// Network interface current address
OID_802_3_CURRENT_ADDRESS	=	$01010102;

//	Required network interface statistics
OID_GEN_XMIT_OK	      = $00020101;
OID_GEN_RCV_OK        = $00020102;
OID_GEN_XMIT_ERROR    = $00020103;
OID_GEN_RCV_ERROR	    = $00020104;
OID_GEN_RCV_NO_BUFFER	= $00020105;

type
    TEtherAddrPtr = ^TEtherAddr;
    TEtherAddr = packed record
      Data: array[1..6] of Byte;
    end;

var
  hFilt: THANDLE;
  Adapts: TCP_AdapterList;
  pCurrentMacRequest, pStatRequest: PPACKET_OID_DATA;
  i: DWORD;
  ethAddr: TEtherAddrPtr;
  pdwStat: ^DWORD;

begin
  // Initialize NDISAPI
  InitNDISAPI();

  // Create driver object
  hFilt := OpenFilterDriver('NDISRD');

  // Allocate request structures
  GetMem( pCurrentMacRequest, SizeOf(PACKET_OID_DATA) + 5);
  GetMem( pStatRequest, SizeOf(PACKET_OID_DATA) + SizeOf(DWORD) - 1);

  // Get TCP/IP bound interfaces
  GetTcpipBoundAdaptersInfo (hFilt, @Adapts);

  // Pre-initialize requests
  pCurrentMacRequest.Length := 6;
	pCurrentMacRequest.Oid := OID_802_3_CURRENT_ADDRESS;
  pStatRequest.Length := sizeof(DWORD);

  for i:=1 to Adapts.m_nAdapterCount do begin
    // Set handle field
    pCurrentMacRequest.hAdapterHandle := Adapts.m_nAdapterHandle[i];
		pStatRequest.hAdapterHandle := Adapts.m_nAdapterHandle[i];

    NdisrdRequest ( hFilt, pCurrentMacRequest, 0 );

    ethAddr := @pCurrentMacRequest.Data;
    Writeln(Format('%d) Current MAC is %.2x-%.2x-%.2x-%.2x-%.2x-%.2x', [i, ethAddr.Data[1], ethAddr.Data[2], ethAddr.Data[3], ethAddr.Data[4], ethAddr.Data[5], ethAddr.Data[6]]));

    pdwStat := @pStatRequest.Data;
    pStatRequest.Oid := OID_GEN_XMIT_OK;

		if NdisrdRequest(hFilt, pStatRequest, 0) <> 0 then
			Writeln(Format('     Frames transmitted without errors = %d', [pdwStat^]));

		pStatRequest.Oid := OID_GEN_RCV_OK;

    if NdisrdRequest(hFilt, pStatRequest, 0) <> 0 then
			Writeln(Format('     Frames received without errors = %d', [pdwStat^]));

		pStatRequest.Oid := OID_GEN_XMIT_ERROR;

    if NdisrdRequest(hFilt, pStatRequest, 0) <> 0 then
			Writeln(Format('     Frames that a NIC failed to transmit = %d', [pdwStat^]));

		pStatRequest.Oid := OID_GEN_RCV_ERROR;

    if NdisrdRequest(hFilt, pStatRequest, 0) <> 0 then
			Writeln(Format('     Frames that a NIC have not indicated due to errors = %d', [pdwStat^]));

  end;

  // Deallocate request structures
  FreeMem (pCurrentMacRequest);
  FreeMem (pStatRequest);

  // Close driver object
  CloseFilterDriver (hFilt);

  // Release NDISAPI
  FreeNDISAPI();
end.

```

`examples/legacy/Delphi/winpkf.pas`:

```pas
{                 Windows Packet Filter Kit 3.4 interface             }
{                 Copyright(C) 2000-2023 NT Kernel Resources          }
{                         mailto: ndisrd@ntkernel.com                 }
{                                                                     }
{                 Delphi import unit fixed on 2003-02-21 by           }
{                 Federico Simonetti (aka BackDream)                  }
{                 Reworked to load library dinamically on 2006-06-23  }
{                 by Alex Shakhaylo                                   }

unit winpkf;

interface

uses
  Windows, SysUtils;

const

// Some size constants
  ADAPTER_NAME_SIZE = 256;
  ADAPTER_LIST_SIZE = 32;
  ETHER_ADDR_LENGTH = 6;
  MAX_ETHER_FRAME = 1514;

// Adapter flags
  MSTCP_FLAG_SENT_TUNNEL = $1;    // Receive packets sent by MSTCP
  MSTCP_FLAG_RECV_TUNNEL = $2;    // Receive packets instead MSTCP
  MSTCP_FLAG_SENT_LISTEN = $4;    // Receive packets sent by MSTCP, original ones delivered to the network
  MSTCP_FLAG_RECV_LISTEN = $8;    // Receive packets received by MSTCP
  MSTCP_FLAG_FILTER_DIRECT = $10; // In promiscuous mode TCP/IP stack receives all
			          // packets in the ethernet segment, to prevent this set this flag
			          // All packets with destination MAC different from FF-FF-FF-FF-FF-FF and
			          // network interface current MAC will be blocked

// By default loopback packets are passed to original MSTCP handlers without processing,
// to change this behavior use the flags below
  MSTCP_FLAG_LOOPBACK_FILTER = $20;  // Pass loopback packet for processing
  MSTCP_FLAG_LOOPBACK_BLOCK  = $40;  // Silently drop loopback packets, this flag
				     // is recommended for usage in combination with
			             // promiscuous mode

// Device flags for intermediate buffer
  PACKET_FLAG_ON_SEND = 1;
  PACKET_FLAG_ON_RECEIVE = 2;

// RAS connections relative definitions
  RAS_LINK_BUFFER_LENGTH = 1024;
  RAS_LINKS_MAX = 256;

// filter flags
  FILTER_PACKET_PASS = 1;     // Pass packet if if matches the filter
  FILTER_PACKET_DROP = 2;     // Drop packet if it matches the filter
  FILTER_PACKET_REDIRECT = 3; // Redirect packet to WinpkFilter client application

  DATA_LINK_LAYER_VALID = 1;  // Match packet against data link layer filter
  NETWORK_LAYER_VALID = 2;    // Match packet against network layer filter
  TRANSPORT_LAYER_VALID = 4;  // Match packet against transport layer filter

  ETH_802_3 = 1;

  ETH_802_3_SRC_ADDRESS = 1;
  ETH_802_3_DEST_ADDRESS = 2;
  ETH_802_3_PROTOCOL = 4;

  IPV4 = 1;
  IPV6 = 2;

  IP_V4_FILTER_SRC_ADDRESS = 1;
  IP_V4_FILTER_DST_ADDRESS = 2;
  IP_V4_FILTER_PROTOCOL = 4;

  IP_SUBNET_V4_TYPE = 1;
  IP_RANGE_V4_TYPE = 2;

  IP_V6_FILTER_SRC_ADDRESS = 1;
  IP_V6_FILTER_DST_ADDRESS = 2;
  IP_V6_FILTER_PROTOCOL = 4;

  IP_SUBNET_V6_TYPE = 1;
  IP_RANGE_V6_TYPE = 2;

  TCPUDP = 1;

  TCPUDP_SRC_PORT = 1;
  TCPUDP_DST_PORT = 2;
  TCPUDP_TCP_FLAGS = 4;

type

  PTCP_AdapterList = ^TCP_AdapterList;
  TCP_AdapterList = packed record
    m_nAdapterCount: DWORD; // Number of adapters
    m_szAdapterNameList: array[1..ADAPTER_LIST_SIZE, 1..ADAPTER_NAME_SIZE] of AnsiChar; // Array of adapter names
    m_nAdapterHandle: array[1..ADAPTER_LIST_SIZE] of THANDLE; // Array of adapter handles, this are key handles for any adapter relative operation
    m_nAdapterMediumList: array[1..ADAPTER_LIST_SIZE] of DWORD; // List of adapter mediums
    m_czCurrentAddress: array[1..ADAPTER_LIST_SIZE, 1..ETHER_ADDR_LENGTH] of Byte; // current (configured) ethernet address
    m_usMTU: array[1..ADAPTER_LIST_SIZE] of Word; // current adapter MTU
  end;

  PLIST_ENTRY = ^LIST_ENTRY;
  LIST_ENTRY = record
    Flink: PLIST_ENTRY;
    Blink: PLIST_ENTRY;
  end;

  PINTERMEDIATE_BUFFER = ^INTERMEDIATE_BUFFER;
  INTERMEDIATE_BUFFER = packed record
    m_qLink: LIST_ENTRY;
    m_dwDeviceFlags: DWORD;
    m_Length: DWORD;
    m_Flags: DWORD;
    m_8021q: DWORD;
    m_FilterID: DWORD;
    m_Reserved: array[1..4] of DWORD;
    m_IBuffer: array[1..MAX_ETHER_FRAME] of Byte;
  end;

  PNDISRD_ETH_Packet = ^NDISRD_ETH_Packet;
  NDISRD_ETH_Packet = packed record
    Buffer: PINTERMEDIATE_BUFFER;
  end;

  PETH_REQUEST = ^ETH_REQUEST;
  ETH_REQUEST = packed record
    hAdapterHandle: THANDLE;
    EthPacket: NDISRD_ETH_Packet;
  end;

  PETH_M_REQUEST = ^ETH_M_REQUEST;
  ETH_M_REQUEST = packed record 
    hAdapterHandle: THANDLE;
    dwPacketsNumber: DWORD;
    dwPacketsSuccess: DWORD;
    EthPacket: array[0..0] of NDISRD_ETH_Packet;
  end;

  PADAPTER_MODE = ^ADAPTER_MODE;
  ADAPTER_MODE = packed record
    hAdapterHandle: THANDLE;
    dwFlags: DWORD;
  end;

  PADAPTER_EVENT = ^ADAPTER_EVENT;
  ADAPTER_EVENT = packed record
    hAdapterHandle: THANDLE;
    hEvent: THANDLE;
  end;

  PPACKET_OID_DATA = ^PACKET_OID_DATA;
  PACKET_OID_DATA = packed record
    hAdapterHandle: THANDLE;
    Oid: DWORD;
    Length: DWORD;
    Data: array[0..0] of Byte;
  end;

  PRAS_LINK_INFO = ^RAS_LINK_INFO;
  RAS_LINK_INFO = packed record
    LinkSpeed: DWORD;
    RemoteAddress: array[1..ETHER_ADDR_LENGTH] of byte;
    LocalAddress: array[1..ETHER_ADDR_LENGTH] of byte;
    ProtocolBufferLength: DWORD;
    ProtocolBuffer: array[1..RAS_LINK_BUFFER_LENGTH] of byte;
  end;

  PRAS_LINKS = ^RAS_LINKS;
  RAS_LINKS = packed record
    nNumberOfLinks: DWORD;
    RasLinks: array[1..RAS_LINKS_MAX] of RAS_LINK_INFO;
  end;

  TETH_802_3_FILTER = packed record
	  m_ValidFields: Cardinal;                            // Specifies which of the fileds below contain valid values and should be matched against the packet
	  m_SrcAddress: array[1..ETHER_ADDR_LENGTH] of byte;	// Source MAC address
	  m_DstAddress: array[1..ETHER_ADDR_LENGTH] of byte;	// Destination MAC address
	  m_Protocol: system.Word;                            // EtherType
	  Padding:system.Word;
  end;

  TDATA_LINK_LAYER_FILTER = packed record
    m_dwUnionSelector: Cardinal;
	  m_Eth8023Filter: TETH_802_3_FILTER;
  end;

  TIP_SUBNET_V4 = packed record
    m_Ip: Cardinal;     // IPv4 address expressed as ULONG
	  m_IpMask: Cardinal; // IPv4 mask expressed as ULONG
  end;

  TIP_RANGE_V4 = packed record
	  m_StartIp: Cardinal; // IPv4 address expressed as ULONG
	  m_EndIp: Cardinal;   // IPv4 address expressed as ULONG
  end;

  TIP_ADDRESS_V4 = packed record
	  m_AddressType: Cardinal; // Specifies which of the IP v4 address types is used below
    case integer of
      0: (m_IpSubnet: TIP_SUBNET_V4);
      1: (m_IpRange: TIP_RANGE_V4);
  end;

  TIP_V4_FILTER = packed record
	  m_ValidFields: Cardinal;	     // Specifies which of the fileds below contain valid values and should be matched against the packet
	  m_SrcAddress: TIP_ADDRESS_V4;	 // IP v4 source address
	  m_DstAddress: TIP_ADDRESS_V4;  // IP v4 destination address
	  m_Protocol: byte;         		 // Specifies next protocol
	  Padding: array[1..3] of byte;
  end;

  TIP_IN6_ADDR = packed record
	m_Byte: array[1..16] of byte; // IPv6 address 
  end;

  TIP_SUBNET_V6 = packed record
    m_Ip: TIP_IN6_ADDR;     // IPv6 address
    m_IpMask: TIP_IN6_ADDR; // IPv6 mask
  end;

  TIP_RANGE_V6 = packed record
	  m_StartIp: TIP_IN6_ADDR; // IPv6 address 
	  m_EndIp: TIP_IN6_ADDR;   // IPv6 address 
  end;

  TIP_ADDRESS_V6 = packed record
	  m_AddressType: Cardinal; // Specifies which of the IP v6 address types is used below
    case integer of
      0: (m_IpSubnet: TIP_SUBNET_V6);
      1: (m_IpRange: TIP_RANGE_V6);
  end;

  TIP_V6_FILTER = packed record
	  m_ValidFields: Cardinal;	     // Specifies which of the fileds below contain valid values and should be matched against the packet
	  m_SrcAddress: TIP_ADDRESS_V6;	 // IP v6 source address
	  m_DstAddress: TIP_ADDRESS_V6;  // IP v6 destination address
	  m_Protocol: byte;         		 // Specifies next protocol
	  Padding: array[1..3] of byte;
  end;


  TNETWORK_LAYER_FILTER = packed record
  m_dwUnionSelector: Cardinal;
    case integer of
      0: (m_IPv4: TIP_V4_FILTER);
      1: (m_IPv6: TIP_V6_FILTER);
  end;

  TPORT_RANGE = packed record
	  m_StartRange: System.Word;
	  m_EndRange: System.Word;
  end;

  TTCPUDP_FILTER = packed record
	  m_ValidFields: Cardinal; // Specifies which of the fileds below contain valid values and should be matched against the packet
	  m_SrcPort: TPORT_RANGE;	 // Source port
	  m_DstPort: TPORT_RANGE;	 // Destination port
    m_TcpFalgs: byte;        // TCP flags combination
    Padding: array[1..3] of byte;
  end;

  TRANSPORT_LAYER_FILTER = packed record
	  m_dwUnionSelector: Cardinal;
		m_TcpUdp: TTCPUDP_FILTER;
  end;

  TSTATIC_FILTER = packed record
    m_Adapter: Int64;             // Adapter handle extended to 64 bit size for structure compatibility across x64 and x86
	  m_dwDirectionFlags: Cardinal;	// PACKET_FLAG_ON_SEND or/and PACKET_FLAG_ON_RECEIVE
	  m_FilterAction: Cardinal;	    // FILTER_PACKET_XXX
	  m_ValidFields: Cardinal;  		// Specifies which of the fileds below contain valid values and should be matched against the packet

    m_LastReset: Cardinal;    		// Time of the last counters reset (in seconds passed since 1 Jan 1980)
	  m_PacketsIn: Int64;       			// Incoming packets passed through this filter
	  m_BytesIn: Int64;         			// Incoming bytes passed through this filter
	  m_PacketsOut: Int64;       			// Outgoing packets passed through this filter
	  m_BytesOut: Int64;         			// Outgoing bytes passed through this filter
	  m_DataLinkFilter: TDATA_LINK_LAYER_FILTER;
	  m_NetworkFilter: TNETWORK_LAYER_FILTER;
	  m_TransportFilter: TRANSPORT_LAYER_FILTER;
  end;

  PSTATIC_FILTER_TABLE =^TSTATIC_FILTER_TABLE;
  TSTATIC_FILTER_TABLE = packed record
 	  m_TableSize: Cardinal; // number of STATIC_FILTER entries
    Padding: Cardinal;
	  m_StaticFilters: array[0..0] of TSTATIC_FILTER;
  end;

procedure InitNDISAPI;
procedure FreeNDISAPI;

var
  NDISAPIHandle: THandle = 0;

  OpenFilterDriver: function(pszFileName : Pchar): THANDLE; stdcall;
  CloseFilterDriver: procedure(hOpen: THANDLE); stdcall;
  GetDriverVersion: function(hOpen: THANDLE): DWORD; stdcall;
  GetTcpipBoundAdaptersInfo: function(hOpen: THANDLE; pAdapters: PTCP_AdapterList): DWORD; stdcall;
  SendPacketToMstcp: function(hOpen: THANDLE; pPacket: PETH_REQUEST): DWORD; stdcall;
  SendPacketToAdapter: function(hOpen: THANDLE; pPacket: PETH_REQUEST): DWORD; stdcall;
  ReadPacket: function(hOpen: THANDLE; pPacket: PETH_REQUEST): DWORD; stdcall;
  SendPacketsToMstcp: function(hOpen: THANDLE; pPackets: PETH_M_REQUEST): DWORD; stdcall;
  SendPacketsToAdapter: function(hOpen: THANDLE; pPackets: PETH_M_REQUEST): DWORD; stdcall;
  ReadPackets: function(hOpen: THANDLE; pPackets: PETH_M_REQUEST): DWORD; stdcall;
  SetAdapterMode: function(hOpen: THANDLE; pMode: PADAPTER_MODE): DWORD; stdcall;
  GetAdapterMode: function(hOpen: THANDLE; pMode: PADAPTER_MODE): DWORD; stdcall;
  FlushAdapterPacketQueue: function(hOpen: THANDLE; hAdapter: THANDLE): DWORD; stdcall;
  GetAdapterPacketQueueSize: function(hOpen: THANDLE; hAdapter: THANDLE; pdwSize: PDWORD): DWORD; stdcall;
  SetPacketEvent: function(hOpen: THANDLE; hAdapter: THANDLE; hWin32Event: THANDLE): DWORD; stdcall;
  SetWANEvent: function(hOpen: THANDLE; hWin32Event: THANDLE): DWORD; stdcall;
  SetAdapterListChangeEvent: function(hOpen: THANDLE; hWin32Event: THANDLE): DWORD; stdcall;
  NdisrdRequest: function(hOpen: THANDLE; OidData: PPACKET_OID_DATA; dwSet: DWORD): DWORD; stdcall;
  GetRasLinks: function(hOpen: THANDLE; hAdapter: THANDLE; pLinks: PRAS_LINKS): DWORD; stdcall;
  SetHwPacketFilter: function(hOpen: THANDLE; hAdapter: THANDLE; dwFilter: DWORD):DWORD; stdcall;
  GetHwPacketFilter: function(hOpen: THANDLE; hAdapter: THANDLE; var dwFilter: DWORD):DWORD; stdcall;
  SetMTUDecrement: function(dwMTUDecrement: DWORD): DWORD; stdcall;
  GetMTUDecrement: function(): DWORD; stdcall;
  SetAdaptersStartupMode : function(dwStartupMode: DWORD): DWORD; stdcall;
  GetAdaptersStartupMode: function(): DWORD; stdcall;
  IsDriverLoaded: function(hOpen: THANDLE): Boolean; stdcall;
  GetBytesReturned: function(hOpen: THANDLE): DWORD; stdcall;
  SetPacketFilterTable: function(hOpen: THANDLE; pFilterList: PSTATIC_FILTER_TABLE): Boolean; stdcall;
  GetPacketFilterTable: function(hOpen: THANDLE; pFilterList: PSTATIC_FILTER_TABLE): Boolean; stdcall;
  GetPacketFilterTableResetStats: function(hOpen: THANDLE; pFilterList: PSTATIC_FILTER_TABLE): Boolean; stdcall;
  ResetPacketFilterTable: function(hOpen: THANDLE): Boolean; stdcall;
  GetPacketFilterTableSize: function(hOpen: THANDLE; pSize: PDWORD): Boolean; stdcall;
  ConvertWindowsNTAdapterName: function(szAdapterName: Pchar; szUserFriendlyName: Pchar; dwUserFriendlyNameLength: DWORD): DWORD; stdcall;
  ConvertWindows2000AdapterName: function(szAdapterName: Pchar; szUserFriendlyName: Pchar; dwUserFriendlyNameLength: DWORD): DWORD; stdcall;
  ConvertWindows9xAdapterName: function(szAdapterName: Pchar; szUserFriendlyName: Pchar; dwUserFriendlyNameLength: DWORD): DWORD; stdcall;

implementation

procedure InitNDISAPI;
begin
  if NDISAPIHandle = 0 then
  begin
    NDISAPIHandle := LoadLibrary('NdisApi.dll');
    if NDISAPIHandle <> 0 then
    begin
      OpenFilterDriver := GetProcAddress(NDISAPIHandle, 'OpenFilterDriver');
      CloseFilterDriver := GetProcAddress(NDISAPIHandle, 'CloseFilterDriver');
      GetDriverVersion := GetProcAddress(NDISAPIHandle, 'GetDriverVersion');
      GetTcpipBoundAdaptersInfo := GetProcAddress(NDISAPIHandle, 'GetTcpipBoundAdaptersInfo');
      SendPacketToMstcp := GetProcAddress(NDISAPIHandle, 'SendPacketToMstcp');
      SendPacketToAdapter := GetProcAddress(NDISAPIHandle, 'SendPacketToAdapter');
      ReadPacket := GetProcAddress(NDISAPIHandle, 'ReadPacket');
      SendPacketsToMstcp := GetProcAddress(NDISAPIHandle, 'SendPacketsToMstcp');
      SendPacketsToAdapter := GetProcAddress(NDISAPIHandle, 'SendPacketsToAdapter');
      ReadPackets := GetProcAddress(NDISAPIHandle, 'ReadPackets');
      SetAdapterMode := GetProcAddress(NDISAPIHandle, 'SetAdapterMode');
      GetAdapterMode := GetProcAddress(NDISAPIHandle, 'GetAdapterMode');
      FlushAdapterPacketQueue := GetProcAddress(NDISAPIHandle, 'FlushAdapterPacketQueue');
      GetAdapterPacketQueueSize := GetProcAddress(NDISAPIHandle, 'GetAdapterPacketQueueSize');
      SetPacketEvent := GetProcAddress(NDISAPIHandle, 'SetPacketEvent');
      SetWANEvent := GetProcAddress(NDISAPIHandle, 'SetWANEvent');
      SetAdapterListChangeEvent := GetProcAddress(NDISAPIHandle, 'SetAdapterListChangeEvent');
      NdisrdRequest := GetProcAddress(NDISAPIHandle, 'NdisrdRequest');
      GetRasLinks := GetProcAddress(NDISAPIHandle, 'GetRasLinks');
      SetHwPacketFilter := GetProcAddress(NDISAPIHandle, 'SetHwPacketFilter');
      GetHwPacketFilter := GetProcAddress(NDISAPIHandle, 'GetHwPacketFilter');
      SetMTUDecrement := GetProcAddress(NDISAPIHandle, 'SetMTUDecrement');
      GetMTUDecrement := GetProcAddress(NDISAPIHandle, 'GetMTUDecrement');
      SetAdaptersStartupMode := GetProcAddress(NDISAPIHandle, 'SetAdaptersStartupMode');
      GetAdaptersStartupMode := GetProcAddress(NDISAPIHandle, 'GetAdaptersStartupMode');
      IsDriverLoaded := GetProcAddress(NDISAPIHandle, 'IsDriverLoaded');
      GetBytesReturned := GetProcAddress(NDISAPIHandle, 'GetBytesReturned');
      SetPacketFilterTable := GetProcAddress(NDISAPIHandle, 'SetPacketFilterTable');
      GetPacketFilterTable := GetProcAddress(NDISAPIHandle, 'GetPacketFilterTable');
      GetPacketFilterTableResetStats := GetProcAddress(NDISAPIHandle, 'GetPacketFilterTableResetStats');
      ResetPacketFilterTable := GetProcAddress(NDISAPIHandle, 'ResetPacketFilterTable');
      GetPacketFilterTableSize := GetProcAddress(NDISAPIHandle, 'GetPacketFilterTableSize');
      ConvertWindowsNTAdapterName := GetProcAddress(NDISAPIHandle, 'ConvertWindowsNTAdapterName');
      ConvertWindows2000AdapterName := GetProcAddress(NDISAPIHandle, 'ConvertWindows2000AdapterName');
      ConvertWindows9xAdapterName := GetProcAddress(NDISAPIHandle, 'ConvertWindows9xAdapterName');
    end
    else
    begin
      raise Exception.Create('Cannot load library "NDISAPI.DLL"');
    end;
  end;
end;

procedure FreeNDISAPI;
begin
  if NDISAPIHandle <> 0 then
  begin
    FreeLibrary(NDISAPIHandle);
    NDISAPIHandle := 0;
  end;
end;

end.


```

`examples/legacy/MSVC/filter/StdAfx.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2016 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/*                                                                       */
/* Module Name:  stdafx.h                                                */
/*                                                                       */
/* Abstract: include file for standard system include files,             */
/*  or project specific include files that are used frequently, but      */
/*  are changed infrequently                                             */
/*                                                                       */
/*************************************************************************/

#if !defined(AFX_STDAFX_H__8CD24513_169B_47A9_859B_9A99FF8266DA__INCLUDED_)
#define AFX_STDAFX_H__8CD24513_169B_47A9_859B_9A99FF8266DA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif // WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <iphlpapi.h>

#include "..\..\..\..\include\common.h"
#include "..\..\..\..\include\ndisapi.h"
#include "iphlp.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8CD24513_169B_47A9_859B_9A99FF8266DA__INCLUDED_)

```

`examples/legacy/MSVC/filter/filter.dsp`:

```dsp
# Microsoft Developer Studio Project File - Name="filter" - Package Owner=<4>
# Microsoft Developer Studio Generated Build File, Format Version 6.00
# ** DO NOT EDIT **

# TARGTYPE "Win32 (x86) Console Application" 0x0103

CFG=filter - Win32 Release
!MESSAGE This is not a valid makefile. To build this project using NMAKE,
!MESSAGE use the Export Makefile command and run
!MESSAGE 
!MESSAGE NMAKE /f "filter.mak".
!MESSAGE 
!MESSAGE You can specify a configuration when running NMAKE
!MESSAGE by defining the macro CFG on the command line. For example:
!MESSAGE 
!MESSAGE NMAKE /f "filter.mak" CFG="filter - Win32 Release"
!MESSAGE 
!MESSAGE Possible choices for configuration are:
!MESSAGE 
!MESSAGE "filter - Win32 Release" (based on "Win32 (x86) Console Application")
!MESSAGE "filter - Win32 Debug" (based on "Win32 (x86) Console Application")
!MESSAGE 

# Begin Project
# PROP AllowPerConfigDependencies 0
# PROP Scc_ProjName ""
# PROP Scc_LocalPath ""
CPP=cl.exe
RSC=rc.exe

!IF  "$(CFG)" == "filter - Win32 Release"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 0
# PROP BASE Output_Dir "Release"
# PROP BASE Intermediate_Dir "Release"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 0
# PROP Output_Dir "Release"
# PROP Intermediate_Dir "Release"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /c
# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /FR /Yu"stdafx.h" /FD /c
# ADD BASE RSC /l 0x419 /d "NDEBUG"
# ADD RSC /l 0x409 /d "NDEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ndisapi.lib /nologo /subsystem:console /machine:I386 /out:"../bin/vc6/filter.exe" /libpath:"..\..\..\..\bin\dll.vc6\i386"

!ELSEIF  "$(CFG)" == "filter - Win32 Debug"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 1
# PROP BASE Output_Dir "Debug"
# PROP BASE Intermediate_Dir "Debug"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 1
# PROP Output_Dir "Debug"
# PROP Intermediate_Dir "Debug"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FR /Yu"stdafx.h" /FD /GZ /c
# ADD BASE RSC /l 0x419 /d "_DEBUG"
# ADD RSC /l 0x409 /d "_DEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ndisapi.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept /libpath:"..\..\..\..\bin\dll.vc6\i386"

!ENDIF 

# Begin Target

# Name "filter - Win32 Release"
# Name "filter - Win32 Debug"
# Begin Group "Source Files"

# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
# Begin Source File

SOURCE=.\filter.cpp
# End Source File
# Begin Source File

SOURCE=.\StdAfx.cpp
# ADD CPP /Yc"stdafx.h"
# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl"
# Begin Source File

SOURCE=.\iphlp.h
# End Source File
# Begin Source File

SOURCE=.\StdAfx.h
# End Source File
# End Group
# Begin Group "Resource Files"

# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
# End Group
# End Target
# End Project

```

`examples/legacy/MSVC/filter/filter.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{B2567E0A-49EF-4BDA-AD9B-730B5E1C537E}</ProjectGuid>
    <RootNamespace>filter</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>11.0.50727.1</_ProjectFileVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>..\bin\i386\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>..\bin\amd64\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Midl>
      <TypeLibraryName>.\Release/filter.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <BrowseInformation>true</BrowseInformation>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>.\Release/filter.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <BrowseInformation>true</BrowseInformation>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Midl>
      <TypeLibraryName>.\Debug/filter.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>.\Debug/filter.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="filter.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">EnableFastChecks</BasicRuntimeChecks>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">EnableFastChecks</BasicRuntimeChecks>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">MaxSpeed</Optimization>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</BrowseInformation>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</BrowseInformation>
    </ClCompile>
    <ClCompile Include="StdAfx.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">MaxSpeed</Optimization>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</BrowseInformation>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</BrowseInformation>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="iphlp.h" />
    <ClInclude Include="StdAfx.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/legacy/MSVC/filter/filter.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{f38ef434-04cb-4288-9908-c83b44e5888c}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{6f573063-1e7b-4500-b980-d7817a1a8dbd}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{cd950b59-825f-4363-9273-d7408a8582bd}</UniqueIdentifier>
      <Extensions>ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="filter.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="StdAfx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="iphlp.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="StdAfx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`examples/legacy/MSVC/filter/iphlp.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2016 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/* Module Name:  iphlp.h				                                 */
/*                                                                       */
/* Abstract: IP helper definitions			        	                 */
/*                                                                       */
/* Environment:                                                          */
/*                                                                       */
/*   Kernel mode, NDIS-hooking driver                                    */
/*                                                                       */
/* Revision History:                                                     */
/*                                                                       */
/*************************************************************************/

#ifndef __IPHLP_H__
#define __IPHLP_H__

#pragma pack(1) 

///////////////////////////////////////////////////////////////////////////
// packet structures
///////////////////////////////////////////////////////////////////////////
typedef long n_long;
typedef short n_short;
typedef long n_time;
typedef unsigned short u_short;
typedef unsigned long u_long;
typedef unsigned char u_char;
typedef struct in_addr IN_ADDR, *PIN_ADDR;

#define ETH_ALEN				6		/* Octets in one ethernet addr	 */
#define ETHER_HEADER_LENGTH		14		/* Ethernet header length */

#define ETH_P_ARP		0x0806			/* Address Resolution packet	*/
#define ARPHRD_ETHER	0x01
#define ARPOP_REQUEST	0x01
#define ARPOP_REPLY		0x02

#define ETH_P_IP		0x0800			/* Internet Protocol packet	*/
#define ETH_P_IP_NET	0x0008			/* Internet Protocol packet	network order*/
#define ETH_P_RARP      0x8035			/* Reverse Addr Res packet	*/
#define ETH_P_ARP		0x0806			/* Address Resolution packet	*/

#define ETH_P_IPV6		0x86dd 			/* Internet Protocol V6 packet	*/
#define ETH_P_IPV6_NET	0xdd86 			/* Internet Protocol V6 packet network order*/

/*
 * Protocols
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_IGMP            2               /* group management protocol */
#define IPPROTO_GGP             3               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

// Ethernet Header
typedef struct ether_header 
{
	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
	unsigned short	h_proto;		/* packet type ID field	*/
} ether_header, *ether_header_ptr;

typedef struct arphdr
{
	unsigned short	ar_hrd;		/* format of hardware address	*/
	unsigned short	ar_pro;		/* format of protocol address	*/
	unsigned char	ar_hln;		/* length of hardware address	*/
	unsigned char	ar_pln;		/* length of protocol address	*/
	unsigned short	ar_op;		/* ARP opcode (command)		*/
} arphdr, *arphdr_ptr;

typedef struct	ether_arp 
{
	struct	arphdr ea_hdr;	/* fixed-size header */
	u_char	arp_sha[ETH_ALEN];	/* sender hardware address */
	u_char	arp_spa[4];	/* sender protocol address */
	u_char	arp_tha[ETH_ALEN];	/* target hardware address */
	u_char	arp_tpa[4];	/* target protocol address */
} ether_arp, *ether_arp_ptr;

#define	arp_hrd	ea_hdr.ar_hrd
#define	arp_pro	ea_hdr.ar_pro
#define	arp_hln	ea_hdr.ar_hln
#define	arp_pln	ea_hdr.ar_pln
#define	arp_op	ea_hdr.ar_op

/* IP Header in Little Endian */
typedef struct iphdr 
{
	u_char	ip_hl:4,		/* header length */
			ip_v:4;			/* version */
	u_char	ip_tos;			/* type of service */
	short	ip_len;			/* total length */
	u_short	ip_id;			/* identification */
	short	ip_off;			/* fragment offset field */
#define	IP_DF 0x4000		/* dont fragment flag */
#define	IP_MF 0x2000		/* more fragments flag */
	u_char	ip_ttl;			/* time to live */
	u_char	ip_p;			/* protocol */
	u_short	ip_sum;			/* checksum */
	struct	in_addr ip_src,ip_dst;	/* source and dest address */
} iphdr, *iphdr_ptr;
/////////////////////////////////////////////////////////////////////////
/* UDP header  */
typedef struct	udphdr
{
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	u_short	length;			/* data length */
	u_short	th_sum;			/* checksum */
} udphdr, *udphdr_ptr;
/////////////////////////////////////////////////////////////////////////
typedef	u_long	tcp_seq;

// TCP header. Per RFC 793, September, 1981. In Little Endian
typedef struct tcphdr {
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	tcp_seq	th_seq;			/* sequence number */
	tcp_seq	th_ack;			/* acknowledgement number */
	u_char	th_x2:4,		/* (unused) */
		    th_off:4;		/* data offset */
	u_char	th_flags;
#define	TH_FIN	0x01
#define	TH_SYN	0x02
#define	TH_RST	0x04
#define	TH_PSH	0x08
#define	TH_ACK	0x10
#define	TH_URG	0x20
	u_short	th_win;			/* window */
	u_short	th_sum;			/* checksum */
	u_short	th_urp;			/* urgent pointer */
} tcphdr, *tcphdr_ptr;

typedef struct pseudo_header
{
  struct in_addr source_address;
  struct in_addr dest_address;
  unsigned char placeholder;
  unsigned char protocol;
  unsigned short tcp_length;

}pseudo_header, *pseudo_header_ptr;

/////////////////////////////////////////////////////////////////////////

//
// Protocols for IPv6
//
#define IPPROTO_HOPOPTS		0             // Hop by hop header for v6
#define IPPROTO_IPV6		41            // IPv6 encapsulated in IP
#define IPPROTO_ROUTING		43            // Routing header for IPv6
#define IPPROTO_FRAGMENT	44            // Fragment header for IPv6
#define IPPROTO_ICMPV6		58            // ICMP for IPv6
#define IPPROTO_NONE		59            // No next header for IPv6
#define IPPROTO_DSTOPTS		60            // Destinations options

//
// IPv6 header format
//
typedef struct ipv6hdr 
{
	unsigned int	ip6_flow;	// 4  bits = version #, 
								// 8  bits = Trafic class,
								// 20 bits = flow label
	unsigned short	ip6_len;    // Payload length
	unsigned char	ip6_next;	// Next Header
	unsigned char	ip6_hops;	// Hop Limit
	IN6_ADDR		ip6_src;	// Source Address
	IN6_ADDR		ip6_dst;	// Destination Address
} ipv6hdr, *ipv6hdr_ptr;

//
// IPv6 extension header format
//
typedef struct ipv6ext {
	unsigned char    ip6_next;		// Next Header
	unsigned char    ip6_len;		// number of bytes in this header 
	unsigned char    ip6_data[2];	// optional data
}ipv6ext, *ipv6ext_ptr;

typedef struct ipv6ext_frag
{
    unsigned char		ip6_next;       // next header
    unsigned char		ip6_reserved;   // reserved field
    unsigned short		ip6_offlg;      // offset, reserved, and flag
    unsigned int		ip6_ident;      // identification
}ipv6ext_frag, *ipv6ext_frag_ptr;

#pragma pack()

#endif // __IPHLP_H__
```

`examples/legacy/MSVC/filterstats/StdAfx.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2016 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/*                                                                       */
/* Module Name:  stdafx.h                                                */
/*                                                                       */
/* Abstract: include file for standard system include files,             */
/*  or project specific include files that are used frequently, but      */
/*  are changed infrequently                                             */
/*                                                                       */
/*************************************************************************/

#if !defined(AFX_STDAFX_H__8CD24513_169B_47A9_859B_9A99FF8266DA__INCLUDED_)
#define AFX_STDAFX_H__8CD24513_169B_47A9_859B_9A99FF8266DA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif // WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <iphlpapi.h>

#include "..\..\..\..\include\common.h"
#include "..\..\..\..\include\ndisapi.h"
#include "iphlp.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8CD24513_169B_47A9_859B_9A99FF8266DA__INCLUDED_)

```

`examples/legacy/MSVC/filterstats/filterstats.dsp`:

```dsp
# Microsoft Developer Studio Project File - Name="filterstats" - Package Owner=<4>
# Microsoft Developer Studio Generated Build File, Format Version 6.00
# ** DO NOT EDIT **

# TARGTYPE "Win32 (x86) Console Application" 0x0103

CFG=filterstats - Win32 Release
!MESSAGE This is not a valid makefile. To build this project using NMAKE,
!MESSAGE use the Export Makefile command and run
!MESSAGE 
!MESSAGE NMAKE /f "filterstats.mak".
!MESSAGE 
!MESSAGE You can specify a configuration when running NMAKE
!MESSAGE by defining the macro CFG on the command line. For example:
!MESSAGE 
!MESSAGE NMAKE /f "filterstats.mak" CFG="filterstats - Win32 Release"
!MESSAGE 
!MESSAGE Possible choices for configuration are:
!MESSAGE 
!MESSAGE "filterstats - Win32 Release" (based on "Win32 (x86) Console Application")
!MESSAGE "filterstats - Win32 Debug" (based on "Win32 (x86) Console Application")
!MESSAGE 

# Begin Project
# PROP AllowPerConfigDependencies 0
# PROP Scc_ProjName ""
# PROP Scc_LocalPath ""
CPP=cl.exe
RSC=rc.exe

!IF  "$(CFG)" == "filterstats - Win32 Release"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 0
# PROP BASE Output_Dir "Release"
# PROP BASE Intermediate_Dir "Release"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 0
# PROP Output_Dir "Release"
# PROP Intermediate_Dir "Release"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /c
# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /FR /Yu"stdafx.h" /FD /c
# ADD BASE RSC /l 0x419 /d "NDEBUG"
# ADD RSC /l 0x409 /d "NDEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ndisapi.lib /nologo /subsystem:console /machine:I386 /out:"../bin/vc6/filterstats.exe" /libpath:"..\..\..\..\bin\dll.vc6\i386"

!ELSEIF  "$(CFG)" == "filterstats - Win32 Debug"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 1
# PROP BASE Output_Dir "Debug"
# PROP BASE Intermediate_Dir "Debug"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 1
# PROP Output_Dir "Debug"
# PROP Intermediate_Dir "Debug"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
# ADD BASE RSC /l 0x419 /d "_DEBUG"
# ADD RSC /l 0x409 /d "_DEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ndisapi.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept /libpath:"..\..\..\..\bin\dll.vc6\i386"

!ENDIF 

# Begin Target

# Name "filterstats - Win32 Release"
# Name "filterstats - Win32 Debug"
# Begin Group "Source Files"

# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
# Begin Source File

SOURCE=.\filterstats.cpp
# End Source File
# Begin Source File

SOURCE=.\StdAfx.cpp
# ADD CPP /Yc"stdafx.h"
# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl"
# Begin Source File

SOURCE=.\iphlp.h
# End Source File
# Begin Source File

SOURCE=.\StdAfx.h
# End Source File
# End Group
# Begin Group "Resource Files"

# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
# End Group
# End Target
# End Project

```

`examples/legacy/MSVC/filterstats/filterstats.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{E10D2A23-831A-41D7-9CB7-FBDC63C59A28}</ProjectGuid>
    <RootNamespace>filterstats</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>11.0.50727.1</_ProjectFileVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>..\bin\i386\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>..\bin\amd64\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Midl>
      <TypeLibraryName>.\Release/filterstats.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <BrowseInformation>true</BrowseInformation>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>.\Release/filterstats.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <BrowseInformation>true</BrowseInformation>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Midl>
      <TypeLibraryName>.\Debug/filterstats.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>.\Debug/filterstats.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="filterstats.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">EnableFastChecks</BasicRuntimeChecks>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">EnableFastChecks</BasicRuntimeChecks>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">MaxSpeed</Optimization>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</BrowseInformation>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</BrowseInformation>
    </ClCompile>
    <ClCompile Include="StdAfx.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">MaxSpeed</Optimization>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</BrowseInformation>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</BrowseInformation>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="iphlp.h" />
    <ClInclude Include="StdAfx.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/legacy/MSVC/filterstats/filterstats.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{a870b09a-08d1-426f-aebe-bbf91f9d0bb2}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{cb648a7a-7c73-4291-bf83-5f80e4b9f7b8}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{e0c42497-f018-49e6-8451-e44c93f6e62d}</UniqueIdentifier>
      <Extensions>ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="filterstats.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="StdAfx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="iphlp.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="StdAfx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`examples/legacy/MSVC/filterstats/iphlp.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2016 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/* Module Name:  iphlp.h				                                 */
/*                                                                       */
/* Abstract: IP helper definitions			        	                 */
/*                                                                       */
/*                                                                       */
/*************************************************************************/

#ifndef __IPHLP_H__
#define __IPHLP_H__

#pragma pack(1) 

///////////////////////////////////////////////////////////////////////////
// packet structures
///////////////////////////////////////////////////////////////////////////
typedef long n_long;
typedef short n_short;
typedef long n_time;
typedef unsigned short u_short;
typedef unsigned long u_long;
typedef unsigned char u_char;
typedef struct in_addr IN_ADDR, *PIN_ADDR;

#define ETH_ALEN		6		/* Octets in one ethernet addr	 */
#define ETH_P_ARP		0x0806	/* Address Resolution packet	*/
#define ARPHRD_ETHER	0x01
#define ARPOP_REQUEST	0x01
#define ARPOP_REPLY		0x02

#define ETH_P_IP		0x0800	/* Internet Protocol packet	*/
#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
#define ETH_P_ARP		0x0806		/* Address Resolution packet	*/

/*
 * Protocols
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_IGMP            2               /* group management protocol */
#define IPPROTO_GGP             3               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

// Ethernet Header
typedef struct ether_header 
{
	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
	unsigned short	h_proto;		/* packet type ID field	*/
} ether_header, *ether_header_ptr;

typedef struct arphdr
{
	unsigned short	ar_hrd;		/* format of hardware address	*/
	unsigned short	ar_pro;		/* format of protocol address	*/
	unsigned char	ar_hln;		/* length of hardware address	*/
	unsigned char	ar_pln;		/* length of protocol address	*/
	unsigned short	ar_op;		/* ARP opcode (command)		*/
} arphdr, *arphdr_ptr;

typedef struct	ether_arp 
{
	struct	arphdr ea_hdr;	/* fixed-size header */
	u_char	arp_sha[ETH_ALEN];	/* sender hardware address */
	u_char	arp_spa[4];	/* sender protocol address */
	u_char	arp_tha[ETH_ALEN];	/* target hardware address */
	u_char	arp_tpa[4];	/* target protocol address */
} ether_arp, *ether_arp_ptr;

#define	arp_hrd	ea_hdr.ar_hrd
#define	arp_pro	ea_hdr.ar_pro
#define	arp_hln	ea_hdr.ar_hln
#define	arp_pln	ea_hdr.ar_pln
#define	arp_op	ea_hdr.ar_op

/* IP Header in Little Endian */
typedef struct iphdr 
{
	u_char	ip_hl:4,		/* header length */
			ip_v:4;			/* version */
	u_char	ip_tos;			/* type of service */
	short	ip_len;			/* total length */
	u_short	ip_id;			/* identification */
	short	ip_off;			/* fragment offset field */
#define	IP_DF 0x4000		/* dont fragment flag */
#define	IP_MF 0x2000		/* more fragments flag */
	u_char	ip_ttl;			/* time to live */
	u_char	ip_p;			/* protocol */
	u_short	ip_sum;			/* checksum */
	struct	in_addr ip_src,ip_dst;	/* source and dest address */
} iphdr, *iphdr_ptr;
/////////////////////////////////////////////////////////////////////////
/* UDP header  */
typedef struct	udphdr
{
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	u_short	length;			/* data length */
	u_short	th_sum;			/* checksum */
} udphdr, *udphdr_ptr;
/////////////////////////////////////////////////////////////////////////
typedef	u_long	tcp_seq;

// TCP header. Per RFC 793, September, 1981. In Little Endian
typedef struct tcphdr {
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	tcp_seq	th_seq;			/* sequence number */
	tcp_seq	th_ack;			/* acknowledgement number */
	u_char	th_x2:4,		/* (unused) */
		    th_off:4;		/* data offset */
	u_char	th_flags;
#define	TH_FIN	0x01
#define	TH_SYN	0x02
#define	TH_RST	0x04
#define	TH_PSH	0x08
#define	TH_ACK	0x10
#define	TH_URG	0x20
	u_short	th_win;			/* window */
	u_short	th_sum;			/* checksum */
	u_short	th_urp;			/* urgent pointer */
} tcphdr, *tcphdr_ptr;

typedef struct pseudo_header
{
  struct in_addr source_address;
  struct in_addr dest_address;
  unsigned char placeholder;
  unsigned char protocol;
  unsigned short tcp_length;

}pseudo_header, *pseudo_header_ptr;

#pragma pack()

#endif // __IPHLP_H__
```

`examples/legacy/MSVC/gretunnel/StdAfx.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2016 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/*                                                                       */
/* Module Name:  stdafx.h                                                */
/*                                                                       */
/* Abstract: include file for standard system include files,             */
/*  or project specific include files that are used frequently, but      */
/*  are changed infrequently                                             */
/*                                                                       */
/*************************************************************************/

#if !defined(AFX_STDAFX_H__8CD24513_169B_47A9_859B_9A99FF8266DA__INCLUDED_)
#define AFX_STDAFX_H__8CD24513_169B_47A9_859B_9A99FF8266DA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif // WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <iphlpapi.h>

#include "..\..\..\..\include\common.h"
#include "..\..\..\..\include\ndisapi.h"
#include "iphlp.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8CD24513_169B_47A9_859B_9A99FF8266DA__INCLUDED_)

```

`examples/legacy/MSVC/gretunnel/gretunnel.dsp`:

```dsp
# Microsoft Developer Studio Project File - Name="gretunnel" - Package Owner=<4>
# Microsoft Developer Studio Generated Build File, Format Version 6.00
# ** DO NOT EDIT **

# TARGTYPE "Win32 (x86) Console Application" 0x0103

CFG=gretunnel - Win32 Release
!MESSAGE This is not a valid makefile. To build this project using NMAKE,
!MESSAGE use the Export Makefile command and run
!MESSAGE 
!MESSAGE NMAKE /f "gretunnel.mak".
!MESSAGE 
!MESSAGE You can specify a configuration when running NMAKE
!MESSAGE by defining the macro CFG on the command line. For example:
!MESSAGE 
!MESSAGE NMAKE /f "gretunnel.mak" CFG="gretunnel - Win32 Release"
!MESSAGE 
!MESSAGE Possible choices for configuration are:
!MESSAGE 
!MESSAGE "gretunnel - Win32 Release" (based on "Win32 (x86) Console Application")
!MESSAGE "gretunnel - Win32 Debug" (based on "Win32 (x86) Console Application")
!MESSAGE 

# Begin Project
# PROP AllowPerConfigDependencies 0
# PROP Scc_ProjName ""
# PROP Scc_LocalPath ""
CPP=cl.exe
RSC=rc.exe

!IF  "$(CFG)" == "gretunnel - Win32 Release"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 0
# PROP BASE Output_Dir "Release"
# PROP BASE Intermediate_Dir "Release"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 0
# PROP Output_Dir "Release"
# PROP Intermediate_Dir "Release"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /c
# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /FR /Yu"stdafx.h" /FD /c
# ADD BASE RSC /l 0x419 /d "NDEBUG"
# ADD RSC /l 0x409 /d "NDEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ndisapi.lib /nologo /subsystem:console /machine:I386 /out:"../bin/vc6/gretunnel.exe" /libpath:"..\..\..\..\bin\dll.vc6\i386"

!ELSEIF  "$(CFG)" == "gretunnel - Win32 Debug"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 1
# PROP BASE Output_Dir "Debug"
# PROP BASE Intermediate_Dir "Debug"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 1
# PROP Output_Dir "Debug"
# PROP Intermediate_Dir "Debug"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
# ADD BASE RSC /l 0x419 /d "_DEBUG"
# ADD RSC /l 0x409 /d "_DEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ndisapi.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept /libpath:"..\..\..\..\bin\dll.vc6\i386"

!ENDIF 

# Begin Target

# Name "gretunnel - Win32 Release"
# Name "gretunnel - Win32 Debug"
# Begin Group "Source Files"

# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
# Begin Source File

SOURCE=.\gretunnel.cpp
# End Source File
# Begin Source File

SOURCE=.\StdAfx.cpp
# ADD CPP /Yc"stdafx.h"
# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl"
# Begin Source File

SOURCE=.\iphlp.h
# End Source File
# Begin Source File

SOURCE=.\StdAfx.h
# End Source File
# End Group
# Begin Group "Resource Files"

# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
# End Group
# End Target
# End Project

```

`examples/legacy/MSVC/gretunnel/gretunnel.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{D0C8D11B-2F87-4E44-97E5-D17B7C6E238B}</ProjectGuid>
    <RootNamespace>gretunnel</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>11.0.50727.1</_ProjectFileVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>..\bin\i386\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>..\bin\amd64\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Midl>
      <TypeLibraryName>.\Release/gretunnel.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <BrowseInformation>true</BrowseInformation>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>.\Release/gretunnel.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <BrowseInformation>true</BrowseInformation>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Midl>
      <TypeLibraryName>.\Debug/gretunnel.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>.\Debug/gretunnel.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="gretunnel.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">EnableFastChecks</BasicRuntimeChecks>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">EnableFastChecks</BasicRuntimeChecks>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">MaxSpeed</Optimization>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</BrowseInformation>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</BrowseInformation>
    </ClCompile>
    <ClCompile Include="StdAfx.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">MaxSpeed</Optimization>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</BrowseInformation>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</BrowseInformation>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="iphlp.h" />
    <ClInclude Include="StdAfx.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/legacy/MSVC/gretunnel/gretunnel.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{62cf1c17-5339-432a-9f69-9db8ded394fc}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{70b38b6b-c589-4a2d-b229-e81988c98bc6}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{07e0bdbf-40c7-4951-bcc2-5e3fee31925a}</UniqueIdentifier>
      <Extensions>ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="gretunnel.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="StdAfx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="iphlp.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="StdAfx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`examples/legacy/MSVC/gretunnel/iphlp.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2016 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/* Module Name:  iphlp.h				                                 */
/*                                                                       */
/* Abstract: IP helper definitions			        	                 */
/*                                                                       */
/*                                                                       */
/*************************************************************************/

#ifndef __IPHLP_H__
#define __IPHLP_H__

#pragma pack(1) 

///////////////////////////////////////////////////////////////////////////
// packet structures
///////////////////////////////////////////////////////////////////////////
typedef long n_long;
typedef short n_short;
typedef long n_time;
typedef unsigned short u_short;
typedef unsigned long u_long;
typedef unsigned char u_char;
typedef struct in_addr IN_ADDR, *PIN_ADDR;

#define ETH_ALEN		6		/* Octets in one ethernet addr	 */
#define ETH_P_ARP		0x0806	/* Address Resolution packet	*/
#define ARPHRD_ETHER	0x01
#define ARPOP_REQUEST	0x01
#define ARPOP_REPLY		0x02

#define ETH_P_IP		0x0800	/* Internet Protocol packet	*/
#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
#define ETH_P_ARP		0x0806		/* Address Resolution packet	*/

/*
 * Protocols
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_IGMP            2               /* group management protocol */
#define IPPROTO_GGP             3               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_GRE				47				/* GRE protocol */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

// Ethernet Header
typedef struct ether_header 
{
	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
	unsigned short	h_proto;		/* packet type ID field	*/
} ether_header, *ether_header_ptr;

typedef struct arphdr
{
	unsigned short	ar_hrd;		/* format of hardware address	*/
	unsigned short	ar_pro;		/* format of protocol address	*/
	unsigned char	ar_hln;		/* length of hardware address	*/
	unsigned char	ar_pln;		/* length of protocol address	*/
	unsigned short	ar_op;		/* ARP opcode (command)		*/
} arphdr, *arphdr_ptr;

typedef struct	ether_arp 
{
	struct	arphdr ea_hdr;	/* fixed-size header */
	u_char	arp_sha[ETH_ALEN];	/* sender hardware address */
	u_char	arp_spa[4];	/* sender protocol address */
	u_char	arp_tha[ETH_ALEN];	/* target hardware address */
	u_char	arp_tpa[4];	/* target protocol address */
} ether_arp, *ether_arp_ptr;

#define	arp_hrd	ea_hdr.ar_hrd
#define	arp_pro	ea_hdr.ar_pro
#define	arp_hln	ea_hdr.ar_hln
#define	arp_pln	ea_hdr.ar_pln
#define	arp_op	ea_hdr.ar_op

/* IP Header in Little Endian */
typedef struct iphdr 
{
	u_char	ip_hl:4,		/* header length */
			ip_v:4;			/* version */
	u_char	ip_tos;			/* type of service */
	short	ip_len;			/* total length */
	u_short	ip_id;			/* identification */
	short	ip_off;			/* fragment offset field */
#define	IP_DF 0x4000		/* dont fragment flag */
#define	IP_MF 0x2000		/* more fragments flag */
	u_char	ip_ttl;			/* time to live */
	u_char	ip_p;			/* protocol */
	u_short	ip_sum;			/* checksum */
	struct	in_addr ip_src,ip_dst;	/* source and dest address */
} iphdr, *iphdr_ptr;
/////////////////////////////////////////////////////////////////////////
/* UDP header  */
typedef struct	udphdr
{
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	u_short	length;			/* data length */
	u_short	th_sum;			/* checksum */
} udphdr, *udphdr_ptr;
/////////////////////////////////////////////////////////////////////////
typedef	u_long	tcp_seq;

// TCP header. Per RFC 793, September, 1981. In Little Endian
typedef struct tcphdr {
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	tcp_seq	th_seq;			/* sequence number */
	tcp_seq	th_ack;			/* acknowledgement number */
	u_char	th_x2:4,		/* (unused) */
		    th_off:4;		/* data offset */
	u_char	th_flags;
#define	TH_FIN	0x01
#define	TH_SYN	0x02
#define	TH_RST	0x04
#define	TH_PSH	0x08
#define	TH_ACK	0x10
#define	TH_URG	0x20
	u_short	th_win;			/* window */
	u_short	th_sum;			/* checksum */
	u_short	th_urp;			/* urgent pointer */
} tcphdr, *tcphdr_ptr;

typedef struct pseudo_header
{
  struct in_addr source_address;
  struct in_addr dest_address;
  unsigned char placeholder;
  unsigned char protocol;
  unsigned short tcp_length;

}pseudo_header, *pseudo_header_ptr;

typedef struct gre_simple
{
	unsigned short flags;
	unsigned short protocol;
}gre_simple, *gre_simple_ptr;

typedef struct ipgre_hdr
{
	iphdr		ip_header;
	gre_simple	gre_header;
} ipgre_hdr, *ipgre_hdr_ptr;

#pragma pack()

#endif // __IPHLP_H__
```

`examples/legacy/MSVC/legacy.vc6.dsw`:

```dsw
Microsoft Developer Studio Workspace File, Format Version 6.00
# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!

###############################################################################

Project: "filter"=.\filter\filter.dsp - Package Owner=<4>

Package=<5>
{{{
}}}

Package=<4>
{{{
    Begin Project Dependency
    Project_Dep_Name ndisapi
    End Project Dependency
}}}

###############################################################################

Project: "filterstats"=.\filterstats\filterstats.dsp - Package Owner=<4>

Package=<5>
{{{
}}}

Package=<4>
{{{
    Begin Project Dependency
    Project_Dep_Name ndisapi
    End Project Dependency
}}}

###############################################################################

Project: "gretunnel"=.\gretunnel\gretunnel.dsp - Package Owner=<4>

Package=<5>
{{{
}}}

Package=<4>
{{{
    Begin Project Dependency
    Project_Dep_Name ndisapi
    End Project Dependency
}}}

###############################################################################

Project: "listadapters"=.\listadapters\listadapters.dsp - Package Owner=<4>

Package=<5>
{{{
}}}

Package=<4>
{{{
    Begin Project Dependency
    Project_Dep_Name ndisapi
    End Project Dependency
}}}

###############################################################################

Project: "ndisapi"=..\..\..\ndisapi.vc6\ndisapi.dsp - Package Owner=<4>

Package=<5>
{{{
}}}

Package=<4>
{{{
}}}

###############################################################################

Project: "ndisrequest"=.\ndisrequest\ndisrequest.dsp - Package Owner=<4>

Package=<5>
{{{
}}}

Package=<4>
{{{
    Begin Project Dependency
    Project_Dep_Name ndisapi
    End Project Dependency
}}}

###############################################################################

Project: "packetsniffer"=.\packetsniffer\packetsniffer.dsp - Package Owner=<4>

Package=<5>
{{{
}}}

Package=<4>
{{{
    Begin Project Dependency
    Project_Dep_Name ndisapi
    End Project Dependency
}}}

###############################################################################

Project: "packthru"=.\packthru\packthru.dsp - Package Owner=<4>

Package=<5>
{{{
}}}

Package=<4>
{{{
}}}

###############################################################################

Project: "passthru"=.\passthru\passthru.dsp - Package Owner=<4>

Package=<5>
{{{
}}}

Package=<4>
{{{
    Begin Project Dependency
    Project_Dep_Name ndisapi
    End Project Dependency
}}}

###############################################################################

Project: "wwwcensor"=.\wwwcensor\wwwcensor.dsp - Package Owner=<4>

Package=<5>
{{{
}}}

Package=<4>
{{{
    Begin Project Dependency
    Project_Dep_Name ndisapi
    End Project Dependency
}}}

###############################################################################

Global:

Package=<5>
{{{
}}}

Package=<3>
{{{
}}}

###############################################################################


```

`examples/legacy/MSVC/legacy.vs2012.sln`:

```sln
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2012
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "filter", "filter\filter.vcxproj", "{B2567E0A-49EF-4BDA-AD9B-730B5E1C537E}"
	ProjectSection(ProjectDependencies) = postProject
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6} = {B6004DA5-A081-4FF8-9D3C-7438530B8CF6}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "filterstats", "filterstats\filterstats.vcxproj", "{E10D2A23-831A-41D7-9CB7-FBDC63C59A28}"
	ProjectSection(ProjectDependencies) = postProject
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6} = {B6004DA5-A081-4FF8-9D3C-7438530B8CF6}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "gretunnel", "gretunnel\gretunnel.vcxproj", "{D0C8D11B-2F87-4E44-97E5-D17B7C6E238B}"
	ProjectSection(ProjectDependencies) = postProject
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6} = {B6004DA5-A081-4FF8-9D3C-7438530B8CF6}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "listadapters", "listadapters\listadapters.vcxproj", "{7D9BDE38-CEA2-491A-9AD9-51487436B60E}"
	ProjectSection(ProjectDependencies) = postProject
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6} = {B6004DA5-A081-4FF8-9D3C-7438530B8CF6}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ndisrequest", "ndisrequest\ndisrequest.vcxproj", "{21AB27A5-0D1F-49A2-9790-7B38572BB830}"
	ProjectSection(ProjectDependencies) = postProject
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6} = {B6004DA5-A081-4FF8-9D3C-7438530B8CF6}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "packetsniffer", "packetsniffer\packetsniffer.vcxproj", "{BDC5FDDF-C344-4D19-90E9-5A0B7320D24B}"
	ProjectSection(ProjectDependencies) = postProject
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6} = {B6004DA5-A081-4FF8-9D3C-7438530B8CF6}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "passthru", "passthru\passthru.vcxproj", "{E6157A81-9E3D-497A-8C14-1EFA4A7CAD84}"
	ProjectSection(ProjectDependencies) = postProject
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6} = {B6004DA5-A081-4FF8-9D3C-7438530B8CF6}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "wwwcensor", "wwwcensor\wwwcensor.vcxproj", "{1305B673-0D79-400C-AFC2-9B2FA9105EA8}"
	ProjectSection(ProjectDependencies) = postProject
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6} = {B6004DA5-A081-4FF8-9D3C-7438530B8CF6}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "snat", "snat\snat.vcxproj", "{34EEFA7A-7669-44F7-83B0-838B9CE25F70}"
	ProjectSection(ProjectDependencies) = postProject
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6} = {B6004DA5-A081-4FF8-9D3C-7438530B8CF6}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "packthru", "packthru\packthru.vcxproj", "{D6FB0278-A7DD-4A77-88FA-476B3082D418}"
	ProjectSection(ProjectDependencies) = postProject
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6} = {B6004DA5-A081-4FF8-9D3C-7438530B8CF6}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "lfnemu", "lfnemu\lfnemu.vcxproj", "{B0B38A85-9E3D-4349-B5F3-BDCA76E5E0EF}"
	ProjectSection(ProjectDependencies) = postProject
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6} = {B6004DA5-A081-4FF8-9D3C-7438530B8CF6}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ndisapi", "..\..\..\ndisapi.vs2012\ndisapi.vcxproj", "{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B2567E0A-49EF-4BDA-AD9B-730B5E1C537E}.Debug|Win32.ActiveCfg = Debug|Win32
		{B2567E0A-49EF-4BDA-AD9B-730B5E1C537E}.Debug|Win32.Build.0 = Debug|Win32
		{B2567E0A-49EF-4BDA-AD9B-730B5E1C537E}.Debug|x64.ActiveCfg = Debug|x64
		{B2567E0A-49EF-4BDA-AD9B-730B5E1C537E}.Debug|x64.Build.0 = Debug|x64
		{B2567E0A-49EF-4BDA-AD9B-730B5E1C537E}.Release|Win32.ActiveCfg = Release|Win32
		{B2567E0A-49EF-4BDA-AD9B-730B5E1C537E}.Release|Win32.Build.0 = Release|Win32
		{B2567E0A-49EF-4BDA-AD9B-730B5E1C537E}.Release|x64.ActiveCfg = Release|x64
		{B2567E0A-49EF-4BDA-AD9B-730B5E1C537E}.Release|x64.Build.0 = Release|x64
		{E10D2A23-831A-41D7-9CB7-FBDC63C59A28}.Debug|Win32.ActiveCfg = Debug|Win32
		{E10D2A23-831A-41D7-9CB7-FBDC63C59A28}.Debug|Win32.Build.0 = Debug|Win32
		{E10D2A23-831A-41D7-9CB7-FBDC63C59A28}.Debug|x64.ActiveCfg = Debug|x64
		{E10D2A23-831A-41D7-9CB7-FBDC63C59A28}.Debug|x64.Build.0 = Debug|x64
		{E10D2A23-831A-41D7-9CB7-FBDC63C59A28}.Release|Win32.ActiveCfg = Release|Win32
		{E10D2A23-831A-41D7-9CB7-FBDC63C59A28}.Release|Win32.Build.0 = Release|Win32
		{E10D2A23-831A-41D7-9CB7-FBDC63C59A28}.Release|x64.ActiveCfg = Release|x64
		{E10D2A23-831A-41D7-9CB7-FBDC63C59A28}.Release|x64.Build.0 = Release|x64
		{D0C8D11B-2F87-4E44-97E5-D17B7C6E238B}.Debug|Win32.ActiveCfg = Debug|Win32
		{D0C8D11B-2F87-4E44-97E5-D17B7C6E238B}.Debug|Win32.Build.0 = Debug|Win32
		{D0C8D11B-2F87-4E44-97E5-D17B7C6E238B}.Debug|x64.ActiveCfg = Debug|x64
		{D0C8D11B-2F87-4E44-97E5-D17B7C6E238B}.Debug|x64.Build.0 = Debug|x64
		{D0C8D11B-2F87-4E44-97E5-D17B7C6E238B}.Release|Win32.ActiveCfg = Release|Win32
		{D0C8D11B-2F87-4E44-97E5-D17B7C6E238B}.Release|Win32.Build.0 = Release|Win32
		{D0C8D11B-2F87-4E44-97E5-D17B7C6E238B}.Release|x64.ActiveCfg = Release|x64
		{D0C8D11B-2F87-4E44-97E5-D17B7C6E238B}.Release|x64.Build.0 = Release|x64
		{7D9BDE38-CEA2-491A-9AD9-51487436B60E}.Debug|Win32.ActiveCfg = Debug|Win32
		{7D9BDE38-CEA2-491A-9AD9-51487436B60E}.Debug|Win32.Build.0 = Debug|Win32
		{7D9BDE38-CEA2-491A-9AD9-51487436B60E}.Debug|x64.ActiveCfg = Debug|x64
		{7D9BDE38-CEA2-491A-9AD9-51487436B60E}.Debug|x64.Build.0 = Debug|x64
		{7D9BDE38-CEA2-491A-9AD9-51487436B60E}.Release|Win32.ActiveCfg = Release|Win32
		{7D9BDE38-CEA2-491A-9AD9-51487436B60E}.Release|Win32.Build.0 = Release|Win32
		{7D9BDE38-CEA2-491A-9AD9-51487436B60E}.Release|x64.ActiveCfg = Release|x64
		{7D9BDE38-CEA2-491A-9AD9-51487436B60E}.Release|x64.Build.0 = Release|x64
		{21AB27A5-0D1F-49A2-9790-7B38572BB830}.Debug|Win32.ActiveCfg = Debug|Win32
		{21AB27A5-0D1F-49A2-9790-7B38572BB830}.Debug|Win32.Build.0 = Debug|Win32
		{21AB27A5-0D1F-49A2-9790-7B38572BB830}.Debug|x64.ActiveCfg = Debug|x64
		{21AB27A5-0D1F-49A2-9790-7B38572BB830}.Debug|x64.Build.0 = Debug|x64
		{21AB27A5-0D1F-49A2-9790-7B38572BB830}.Release|Win32.ActiveCfg = Release|Win32
		{21AB27A5-0D1F-49A2-9790-7B38572BB830}.Release|Win32.Build.0 = Release|Win32
		{21AB27A5-0D1F-49A2-9790-7B38572BB830}.Release|x64.ActiveCfg = Release|x64
		{21AB27A5-0D1F-49A2-9790-7B38572BB830}.Release|x64.Build.0 = Release|x64
		{BDC5FDDF-C344-4D19-90E9-5A0B7320D24B}.Debug|Win32.ActiveCfg = Debug|Win32
		{BDC5FDDF-C344-4D19-90E9-5A0B7320D24B}.Debug|Win32.Build.0 = Debug|Win32
		{BDC5FDDF-C344-4D19-90E9-5A0B7320D24B}.Debug|x64.ActiveCfg = Debug|x64
		{BDC5FDDF-C344-4D19-90E9-5A0B7320D24B}.Debug|x64.Build.0 = Debug|x64
		{BDC5FDDF-C344-4D19-90E9-5A0B7320D24B}.Release|Win32.ActiveCfg = Release|Win32
		{BDC5FDDF-C344-4D19-90E9-5A0B7320D24B}.Release|Win32.Build.0 = Release|Win32
		{BDC5FDDF-C344-4D19-90E9-5A0B7320D24B}.Release|x64.ActiveCfg = Release|x64
		{BDC5FDDF-C344-4D19-90E9-5A0B7320D24B}.Release|x64.Build.0 = Release|x64
		{E6157A81-9E3D-497A-8C14-1EFA4A7CAD84}.Debug|Win32.ActiveCfg = Debug|Win32
		{E6157A81-9E3D-497A-8C14-1EFA4A7CAD84}.Debug|Win32.Build.0 = Debug|Win32
		{E6157A81-9E3D-497A-8C14-1EFA4A7CAD84}.Debug|x64.ActiveCfg = Debug|x64
		{E6157A81-9E3D-497A-8C14-1EFA4A7CAD84}.Debug|x64.Build.0 = Debug|x64
		{E6157A81-9E3D-497A-8C14-1EFA4A7CAD84}.Release|Win32.ActiveCfg = Release|Win32
		{E6157A81-9E3D-497A-8C14-1EFA4A7CAD84}.Release|Win32.Build.0 = Release|Win32
		{E6157A81-9E3D-497A-8C14-1EFA4A7CAD84}.Release|x64.ActiveCfg = Release|x64
		{E6157A81-9E3D-497A-8C14-1EFA4A7CAD84}.Release|x64.Build.0 = Release|x64
		{1305B673-0D79-400C-AFC2-9B2FA9105EA8}.Debug|Win32.ActiveCfg = Debug|Win32
		{1305B673-0D79-400C-AFC2-9B2FA9105EA8}.Debug|Win32.Build.0 = Debug|Win32
		{1305B673-0D79-400C-AFC2-9B2FA9105EA8}.Debug|x64.ActiveCfg = Debug|x64
		{1305B673-0D79-400C-AFC2-9B2FA9105EA8}.Debug|x64.Build.0 = Debug|x64
		{1305B673-0D79-400C-AFC2-9B2FA9105EA8}.Release|Win32.ActiveCfg = Release|Win32
		{1305B673-0D79-400C-AFC2-9B2FA9105EA8}.Release|Win32.Build.0 = Release|Win32
		{1305B673-0D79-400C-AFC2-9B2FA9105EA8}.Release|x64.ActiveCfg = Release|x64
		{1305B673-0D79-400C-AFC2-9B2FA9105EA8}.Release|x64.Build.0 = Release|x64
		{34EEFA7A-7669-44F7-83B0-838B9CE25F70}.Debug|Win32.ActiveCfg = Debug|Win32
		{34EEFA7A-7669-44F7-83B0-838B9CE25F70}.Debug|Win32.Build.0 = Debug|Win32
		{34EEFA7A-7669-44F7-83B0-838B9CE25F70}.Debug|x64.ActiveCfg = Debug|x64
		{34EEFA7A-7669-44F7-83B0-838B9CE25F70}.Debug|x64.Build.0 = Debug|x64
		{34EEFA7A-7669-44F7-83B0-838B9CE25F70}.Release|Win32.ActiveCfg = Release|Win32
		{34EEFA7A-7669-44F7-83B0-838B9CE25F70}.Release|Win32.Build.0 = Release|Win32
		{34EEFA7A-7669-44F7-83B0-838B9CE25F70}.Release|x64.ActiveCfg = Release|x64
		{34EEFA7A-7669-44F7-83B0-838B9CE25F70}.Release|x64.Build.0 = Release|x64
		{D6FB0278-A7DD-4A77-88FA-476B3082D418}.Debug|Win32.ActiveCfg = Debug|Win32
		{D6FB0278-A7DD-4A77-88FA-476B3082D418}.Debug|Win32.Build.0 = Debug|Win32
		{D6FB0278-A7DD-4A77-88FA-476B3082D418}.Debug|x64.ActiveCfg = Debug|x64
		{D6FB0278-A7DD-4A77-88FA-476B3082D418}.Debug|x64.Build.0 = Debug|x64
		{D6FB0278-A7DD-4A77-88FA-476B3082D418}.Release|Win32.ActiveCfg = Release|Win32
		{D6FB0278-A7DD-4A77-88FA-476B3082D418}.Release|Win32.Build.0 = Release|Win32
		{D6FB0278-A7DD-4A77-88FA-476B3082D418}.Release|x64.ActiveCfg = Release|x64
		{D6FB0278-A7DD-4A77-88FA-476B3082D418}.Release|x64.Build.0 = Release|x64
		{B0B38A85-9E3D-4349-B5F3-BDCA76E5E0EF}.Debug|Win32.ActiveCfg = Debug|Win32
		{B0B38A85-9E3D-4349-B5F3-BDCA76E5E0EF}.Debug|Win32.Build.0 = Debug|Win32
		{B0B38A85-9E3D-4349-B5F3-BDCA76E5E0EF}.Debug|x64.ActiveCfg = Debug|x64
		{B0B38A85-9E3D-4349-B5F3-BDCA76E5E0EF}.Debug|x64.Build.0 = Debug|x64
		{B0B38A85-9E3D-4349-B5F3-BDCA76E5E0EF}.Release|Win32.ActiveCfg = Release|Win32
		{B0B38A85-9E3D-4349-B5F3-BDCA76E5E0EF}.Release|Win32.Build.0 = Release|Win32
		{B0B38A85-9E3D-4349-B5F3-BDCA76E5E0EF}.Release|x64.ActiveCfg = Release|x64
		{B0B38A85-9E3D-4349-B5F3-BDCA76E5E0EF}.Release|x64.Build.0 = Release|x64
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}.Debug|Win32.ActiveCfg = Debug|Win32
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}.Debug|Win32.Build.0 = Debug|Win32
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}.Debug|x64.ActiveCfg = Debug|x64
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}.Debug|x64.Build.0 = Debug|x64
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}.Release|Win32.ActiveCfg = Release|Win32
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}.Release|Win32.Build.0 = Release|Win32
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}.Release|x64.ActiveCfg = Release|x64
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`examples/legacy/MSVC/lfnemu/AckTimerLayer.h`:

```h
#ifndef _ACKTIMERLAYER_H
#define _ACKTIMERLAYER_H

#include "Common.h"

namespace acktl {

	int initLayer(UINT aTimeout, void* aNextLayer, void* aNextLayerUp);
	int haltLayer(void);
	void AckTimerLayer(PETH_REQUEST pRequest);
}

#endif //_ACKTIMERLAYER_H
```

`examples/legacy/MSVC/lfnemu/Common.h`:

```h
#ifndef _COMMON_DEFINITIONS_H
#define _COMMON_DEFINITIONS_H

#define E_INITHANDLES		0x00000001
#define E_INVALIDOPTION		0x00000002
#define E_DRIVERNOTPRESENT	0x00000003
#define E_INITEVENT			0x00000004
#define E_ATENTIONTHREAD	0x00000005

#define ALL_PACKETS INFINITE

extern TCP_AdapterList		AdList;
extern CNdisApi				api;
extern DWORD				dwAdapterCount;
extern HANDLE				hEvent[33];
extern BOOL					bPausing;
extern BOOL					bExitSignal;
extern BOOL					bUsePAcketCount;

extern DWORD				dwDelayFrecuency;
extern DWORD				dwDelayPktCount;
extern DWORD				dwDelayLength;		
extern DWORD				dwDelayDelta;		
extern DWORD				dwPktRemaining;
extern HANDLE				hCountPktsSentEv;
extern std::vector <PETH_REQUEST> vFlushBuffer;

extern CRITICAL_SECTION	csMapLock;

extern bool usePacketDropperLayer;
extern bool usePacketDelayerLayer;
//extern bool useAckTimerLayer;

extern void (*topLayerDownward)(PETH_REQUEST pRequest);
extern void (*bottomLayerUpward)(PETH_REQUEST pRequest);

extern void ReleaseInterface();
extern DWORD FlushNBufferedPackets(BOOL bSend, UINT count);

#endif //_COMMON_DEFINITIONS_H
```

`examples/legacy/MSVC/lfnemu/Finalization.h`:

```h
#ifndef _FINALIZATION_H
#define _FINALIZATION_H

#include "Common.h"
#include "PacketDelayerLayer.h"
#include "PacketDropperLayer.h"

void ReleaseHandles();
void ReleaseInterface();

#endif //_FINALIZATION_H
```

`examples/legacy/MSVC/lfnemu/Initialization.h`:

```h
#ifndef _INITIALIZATION_H
#define _INITIALIZATION_H

#include "Common.h"
#include "ndisInterfaceLayer.h"
#include "PacketDelayerLayer.h"
#include "PacketDropperLayer.h"

int initialize(int argc, LPCTSTR argv[]);
int InitHandles();

#endif //_INITIALIZATION_H
```

`examples/legacy/MSVC/lfnemu/PacketDelayerLayer.h`:

```h
#ifndef _PACKET_DELAYER_LAYER_H
#define _PACKET_DELAYER_LAYER_H

#include "Common.h"

namespace pdl {

	int initLayer(UINT aDownwardDelayLapse, UINT anUpwardDelayLapse,
		void* aNextLayerDown, void* aNextLayerUp);
	int haltLayer(void);
	void PacketDelayerLayer(PETH_REQUEST pRequest);
}

#endif //_PACKET_DELAYER_LAYER_H
```

`examples/legacy/MSVC/lfnemu/PacketDropperLayer.h`:

```h
#ifndef _PACKETDROPPERLAYER_H
#define _PACKETDROPPERLAYER_H

#include "Common.h"

namespace pdropl {

	int initLayer(UINT anIncomingDropThreshold, UINT anIncomingDropCount,
		UINT anOutgoingDropThreshold, UINT anOutgoingDropCount,
		void* aNextLayerDown, void* aNextLayerUp);
	int haltLayer(void);
	void PacketDropperLayer(PETH_REQUEST pRequest);
}

#endif //_PACKETDROPPERLAYER_H
```

`examples/legacy/MSVC/lfnemu/StdAfx.h`:

```h
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__52478BAB_A15E_4C0E_B3C8_A4AC56BCCCCF__INCLUDED_)
#define AFX_STDAFX_H__52478BAB_A15E_4C0E_B3C8_A4AC56BCCCCF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

// TODO: reference additional headers your program requires here
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <signal.h>
#include <vector>
#include <process.h>
#include <iphlpapi.h>

#include "..\..\..\..\include\common.h"
#include "..\..\..\..\include\ndisapi.h"
#include "iphlp.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__52478BAB_A15E_4C0E_B3C8_A4AC56BCCCCF__INCLUDED_)

```

`examples/legacy/MSVC/lfnemu/iphlp.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2004 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/* Module Name:  iphlp.h				                                 */
/*                                                                       */
/* Abstract: IP helper definitions			        	                 */
/*                                                                       */
/*                                                                       */
/*************************************************************************/

#ifndef __IPHLP_H__
#define __IPHLP_H__

#include <winsock2.h>

#pragma pack(1) 

///////////////////////////////////////////////////////////////////////////
// packet structures
///////////////////////////////////////////////////////////////////////////
typedef long n_long;
typedef short n_short;
typedef long n_time;
typedef unsigned short u_short;
typedef unsigned long u_long;
typedef unsigned char u_char;
typedef struct in_addr IN_ADDR, *PIN_ADDR;

#define ETHER_HEADER_LENGTH		14
#define ID_TIME_LIMIT			60000
#define TCP_TIME_LIMIT			60000

#define ETH_ALEN		6		/* Octets in one ethernet addr	 */
#define ETH_P_ARP		0x0806	/* Address Resolution packet	*/
#define ARPHRD_ETHER	0x01
#define ARPOP_REQUEST	0x01
#define ARPOP_REPLY		0x02

#define ETH_P_IP		0x0800	/* Internet Protocol packet	*/
#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
#define ETH_P_ARP		0x0806		/* Address Resolution packet	*/

/*
 * Protocols
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_IGMP            2               /* group management protocol */
#define IPPROTO_GGP             3               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256


/*struct   in_addr {
    union   {
         struct{
             unsigned  char   s_b1,
                              s_b2,
                              s_b3,
                              s_b4;
        }  S_un_b;
             struct  {
             unsigned  short  s_w1,
                              s_w2;
              }  S_un_w;
               unsigned long  S_addr;
     } S_un;
};*/

/*struct sockaddr {
    unsigned short sa_family;
    char           sa_data[14];
};*/


// Ethernet Header
typedef struct ether_header 
{
	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
	unsigned short	h_proto;		/* packet type ID field	*/
} ether_header, *ether_header_ptr;

typedef struct arphdr
{
	unsigned short	ar_hrd;		/* format of hardware address	*/
	unsigned short	ar_pro;		/* format of protocol address	*/
	unsigned char	ar_hln;		/* length of hardware address	*/
	unsigned char	ar_pln;		/* length of protocol address	*/
	unsigned short	ar_op;		/* ARP opcode (command)		*/
} arphdr, *arphdr_ptr;

typedef struct	ether_arp 
{
	struct	arphdr ea_hdr;	/* fixed-size header */
	u_char	arp_sha[ETH_ALEN];	/* sender hardware address */
	u_char	arp_spa[4];	/* sender protocol address */
	u_char	arp_tha[ETH_ALEN];	/* target hardware address */
	u_char	arp_tpa[4];	/* target protocol address */
} ether_arp, *ether_arp_ptr;

#define	arp_hrd	ea_hdr.ar_hrd
#define	arp_pro	ea_hdr.ar_pro
#define	arp_hln	ea_hdr.ar_hln
#define	arp_pln	ea_hdr.ar_pln
#define	arp_op	ea_hdr.ar_op

/* IP Header in Little Endian */
typedef struct iphdr 
{
	u_char	ip_hl:4,		/* header length */
			ip_v:4;			/* version */
	u_char	ip_tos;			/* type of service */
	short	ip_len;			/* total length */
	u_short	ip_id;			/* identification */
	short	ip_off;			/* fragment offset field */
#define	IP_DF 0x4000		/* dont fragment flag */
#define	IP_MF 0x2000		/* more fragments flag */
	u_char	ip_ttl;			/* time to live */
	u_char	ip_p;			/* protocol */
	u_short	ip_sum;			/* checksum */
	struct	in_addr ip_src,ip_dst;	/* source and dest address */
} iphdr, *iphdr_ptr;
/////////////////////////////////////////////////////////////////////////
/* UDP header  */
typedef struct	udphdr
{
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	u_short	length;			/* data length */
	u_short	th_sum;			/* checksum */
} udphdr, *udphdr_ptr;
/////////////////////////////////////////////////////////////////////////
typedef	u_long	tcp_seq;


// TCP header. Per RFC 793, September, 1981. In Little Endian
typedef struct tcphdr {
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	tcp_seq	th_seq;			/* sequence number */
	tcp_seq	th_ack;			/* acknowledgement number */
	u_char	th_x2:4,		/* (unused) */
		    th_off:4;		/* data offset */
	u_char	th_flags;
#define	TH_FIN	0x01
#define	TH_SYN	0x02
#define	TH_RST	0x04
#define	TH_PSH	0x08
#define	TH_ACK	0x10
#define	TH_URG	0x20
	u_short	th_win;			/* window */
	u_short	th_sum;			/* checksum */
	u_short	th_urp;			/* urgent pointer */
} tcphdr, *tcphdr_ptr;

// ICMP header
typedef struct icmphdr {
    unsigned char type;          // ICMP packet type
    unsigned char code;          // Type sub code
    unsigned short checksum;
    unsigned short id;
    unsigned short seq;
}icmphdr, *icmphdr_ptr;

typedef struct pseudo_header
{
  struct in_addr source_address;
  struct in_addr dest_address;
  unsigned char placeholder;
  unsigned char protocol;
  unsigned short tcp_length;

}pseudo_header, *pseudo_header_ptr;

#pragma pack()

#endif // __IPHLP_H__
```

`examples/legacy/MSVC/lfnemu/lfnemu.dsp`:

```dsp
# Microsoft Developer Studio Project File - Name="lfnemu" - Package Owner=<4>
# Microsoft Developer Studio Generated Build File, Format Version 6.00
# ** DO NOT EDIT **

# TARGTYPE "Win32 (x86) Console Application" 0x0103

CFG=lfnemu - Win32 Release
!MESSAGE This is not a valid makefile. To build this project using NMAKE,
!MESSAGE use the Export Makefile command and run
!MESSAGE 
!MESSAGE NMAKE /f "lfnemu.mak".
!MESSAGE 
!MESSAGE You can specify a configuration when running NMAKE
!MESSAGE by defining the macro CFG on the command line. For example:
!MESSAGE 
!MESSAGE NMAKE /f "lfnemu.mak" CFG="lfnemu - Win32 Release"
!MESSAGE 
!MESSAGE Possible choices for configuration are:
!MESSAGE 
!MESSAGE "lfnemu - Win32 Release" (based on "Win32 (x86) Console Application")
!MESSAGE "lfnemu - Win32 Debug" (based on "Win32 (x86) Console Application")
!MESSAGE 

# Begin Project
# PROP AllowPerConfigDependencies 0
# PROP Scc_ProjName ""
# PROP Scc_LocalPath ""
CPP=cl.exe
RSC=rc.exe

!IF  "$(CFG)" == "lfnemu - Win32 Release"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 0
# PROP BASE Output_Dir "Release"
# PROP BASE Intermediate_Dir "Release"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 0
# PROP Output_Dir "Release"
# PROP Intermediate_Dir "Release"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /c
# ADD CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /FR /Yu"stdafx.h" /FD /c
# ADD BASE RSC /l 0x419 /d "NDEBUG"
# ADD RSC /l 0x409 /d "NDEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ndisapi.lib Ws2_32.lib /nologo /subsystem:console /machine:I386 /out:"../bin/i386/lfnemu.exe" /libpath:"..\..\..\kernel\bin\dll\i386"

!ELSEIF  "$(CFG)" == "lfnemu - Win32 Debug"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 1
# PROP BASE Output_Dir "Debug"
# PROP BASE Intermediate_Dir "Debug"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 1
# PROP Output_Dir "Debug"
# PROP Intermediate_Dir "Debug"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
# ADD BASE RSC /l 0x419 /d "_DEBUG"
# ADD RSC /l 0x409 /d "_DEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ndisapi.lib Ws2_32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept /libpath:"..\..\..\kernel\bin\dll\i386"

!ENDIF 

# Begin Target

# Name "lfnemu - Win32 Release"
# Name "lfnemu - Win32 Debug"
# Begin Group "Source Files"

# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
# Begin Source File

SOURCE=.\AckTimerLayer.cpp
# End Source File
# Begin Source File

SOURCE=.\Common.cpp
# End Source File
# Begin Source File

SOURCE=.\Finalization.cpp
# End Source File
# Begin Source File

SOURCE=.\Initialization.cpp
# End Source File
# Begin Source File

SOURCE=.\lfnemu.cpp
# End Source File
# Begin Source File

SOURCE=.\ndisInterfaceLayer.cpp
# End Source File
# Begin Source File

SOURCE=.\PacketDelayerLayer.cpp
# End Source File
# Begin Source File

SOURCE=.\PacketDropperLayer.cpp
# End Source File
# Begin Source File

SOURCE=.\StdAfx.cpp
# ADD CPP /Yc"stdafx.h"
# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl"
# Begin Source File

SOURCE=.\AckTimerLayer.h
# End Source File
# Begin Source File

SOURCE=.\Common.h
# End Source File
# Begin Source File

SOURCE=.\Finalization.h
# End Source File
# Begin Source File

SOURCE=.\Initialization.h
# End Source File
# Begin Source File

SOURCE=.\iphlp.h
# End Source File
# Begin Source File

SOURCE=.\lfnemu.h
# End Source File
# Begin Source File

SOURCE=.\ndisInterfaceLayer.h
# End Source File
# Begin Source File

SOURCE=.\PacketDelayerLayer.h
# End Source File
# Begin Source File

SOURCE=.\PacketDropperLayer.h
# End Source File
# Begin Source File

SOURCE=.\StdAfx.h
# End Source File
# End Group
# Begin Group "Resource Files"

# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
# End Group
# End Target
# End Project

```

`examples/legacy/MSVC/lfnemu/lfnemu.h`:

```h
#ifndef _FLNEMULATOR_H
#define _FLNEMULATOR_H

#include "Common.h"
#include "Finalization.h"
#include "Initialization.h"

#endif //_FLNEMULATOR_H
```

`examples/legacy/MSVC/lfnemu/lfnemu.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "afxres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Russian (Russia) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_RUS)
LANGUAGE LANG_RUSSIAN, SUBLANG_DEFAULT

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""afxres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // Russian (Russia) resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// Neutral (Default) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_NEUD)
LANGUAGE LANG_NEUTRAL, SUBLANG_DEFAULT

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040004b0"
        BEGIN
            VALUE "CompanyName", "NT Kernel Resources"
            VALUE "FileDescription", "WAN over LAN  Emulator"
            VALUE "FileVersion", "1.0.0.1"
            VALUE "InternalName", "lfnemu.exe"
            VALUE "LegalCopyright", "Copyright NT Kernel Resources (C) 2000-2017"
            VALUE "OriginalFilename", "lfnemu.exe"
            VALUE "ProductName", "WAN Emulator"
            VALUE "ProductVersion", "1.0.0.1"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x400, 1200
    END
END

#endif    // Neutral (Default) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`examples/legacy/MSVC/lfnemu/lfnemu.vcproj`:

```vcproj
<?xml version="1.0" encoding="windows-1251"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9,00"
	Name="lfnemu"
	ProjectGUID="{E6157A81-9E3D-497A-8C14-1EFA4A7CAD84}"
	RootNamespace="lfnemu"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
		<Platform
			Name="x64"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="..\bin\i386"
			IntermediateDirectory=".\Release\i386"
			ConfigurationType="1"
			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
			UseOfMFC="0"
			ATLMinimizesCRunTimeLibraryUsage="false"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TypeLibraryName=".\Release/lfnemu.tlb"
				HeaderFileName=""
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="2"
				InlineFunctionExpansion="1"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
				StringPooling="true"
				RuntimeLibrary="0"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="2"
				PrecompiledHeaderThrough="stdafx.h"
				PrecompiledHeaderFile=".\Release/lfnemu.pch"
				AssemblerListingLocation=".\Release/"
				ObjectFile=".\Release/"
				ProgramDataBaseFileName=".\Release/"
				BrowseInformation="1"
				WarningLevel="3"
				SuppressStartupBanner="true"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="NDEBUG"
				Culture="1033"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalDependencies="Ws2_32.lib $(SolutionDir)\kernel\bin\dll\i386\ndisapi.lib"
				OutputFile="../bin/i386/lfnemu.exe"
				LinkIncremental="1"
				SuppressStartupBanner="true"
				ProgramDatabaseFile=".\Release/lfnemu.pdb"
				SubSystem="1"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="0"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|x64"
			OutputDirectory="..\bin\amd64"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
			ConfigurationType="1"
			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
			UseOfMFC="0"
			ATLMinimizesCRunTimeLibraryUsage="false"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
				TypeLibraryName=".\Release/lfnemu.tlb"
				HeaderFileName=""
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="2"
				InlineFunctionExpansion="1"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
				StringPooling="true"
				RuntimeLibrary="0"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="2"
				PrecompiledHeaderThrough="stdafx.h"
				PrecompiledHeaderFile=".\Release/lfnemu.pch"
				AssemblerListingLocation=".\Release/"
				ObjectFile=".\Release/"
				ProgramDataBaseFileName=".\Release/"
				BrowseInformation="1"
				WarningLevel="3"
				SuppressStartupBanner="true"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="NDEBUG"
				Culture="1033"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalDependencies="Ws2_32.lib $(SolutionDir)\kernel\bin\dll\amd64\ndisapi.lib"
				OutputFile="../bin/amd64/lfnemu.exe"
				LinkIncremental="1"
				SuppressStartupBanner="true"
				ProgramDatabaseFile=".\Release/lfnemu.pdb"
				SubSystem="1"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="0"
				TargetMachine="17"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Debug|Win32"
			OutputDirectory=".\Debug\i386"
			IntermediateDirectory=".\Debug\i386"
			ConfigurationType="1"
			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
			UseOfMFC="0"
			ATLMinimizesCRunTimeLibraryUsage="false"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TypeLibraryName=".\Debug/lfnemu.tlb"
				HeaderFileName=""
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
				BasicRuntimeChecks="3"
				RuntimeLibrary="1"
				UsePrecompiledHeader="2"
				PrecompiledHeaderThrough="stdafx.h"
				PrecompiledHeaderFile=".\Debug/lfnemu.pch"
				AssemblerListingLocation=".\Debug/"
				ObjectFile=".\Debug/"
				ProgramDataBaseFileName=".\Debug/"
				WarningLevel="3"
				SuppressStartupBanner="true"
				DebugInformationFormat="4"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="_DEBUG"
				Culture="1033"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalDependencies="Ws2_32.lib $(SolutionDir)\kernel\bin\dll\i386\ndisapi.lib"
				OutputFile="Debug/i386/lfnemu.exe"
				LinkIncremental="1"
				SuppressStartupBanner="true"
				GenerateDebugInformation="true"
				ProgramDatabaseFile=".\Debug/lfnemu.pdb"
				SubSystem="1"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="0"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Debug|x64"
			OutputDirectory="Debug\amd64"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
			ConfigurationType="1"
			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
			UseOfMFC="0"
			ATLMinimizesCRunTimeLibraryUsage="false"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
				TypeLibraryName=".\Debug/lfnemu.tlb"
				HeaderFileName=""
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
				BasicRuntimeChecks="3"
				RuntimeLibrary="1"
				UsePrecompiledHeader="2"
				PrecompiledHeaderThrough="stdafx.h"
				PrecompiledHeaderFile=".\Debug/lfnemu.pch"
				AssemblerListingLocation=".\Debug/"
				ObjectFile=".\Debug/"
				ProgramDataBaseFileName=".\Debug/"
				WarningLevel="3"
				SuppressStartupBanner="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="_DEBUG"
				Culture="1033"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalDependencies="Ws2_32.lib $(SolutionDir)\kernel\bin\dll\amd64\ndisapi.lib"
				OutputFile="Debug/amd64/lfnemu.exe"
				LinkIncremental="1"
				SuppressStartupBanner="true"
				GenerateDebugInformation="true"
				ProgramDatabaseFile=".\Debug/lfnemu.pdb"
				SubSystem="1"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="0"
				TargetMachine="17"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
			>
			<File
				RelativePath=".\AckTimerLayer.cpp"
				>
			</File>
			<File
				RelativePath=".\Common.cpp"
				>
			</File>
			<File
				RelativePath=".\Finalization.cpp"
				>
			</File>
			<File
				RelativePath=".\Initialization.cpp"
				>
			</File>
			<File
				RelativePath="lfnemu.cpp"
				>
				<FileConfiguration
					Name="Release|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						Optimization="2"
						PreprocessorDefinitions=""
						BrowseInformation="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						Optimization="2"
						PreprocessorDefinitions=""
						BrowseInformation="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Debug|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						Optimization="0"
						PreprocessorDefinitions=""
						BasicRuntimeChecks="3"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Debug|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						Optimization="0"
						PreprocessorDefinitions=""
						BasicRuntimeChecks="3"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Silent_Release|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						Optimization="2"
						PreprocessorDefinitions=""
						BrowseInformation="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Silent_Release|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						Optimization="2"
						PreprocessorDefinitions=""
						BrowseInformation="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Silent_Debug|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						Optimization="0"
						PreprocessorDefinitions=""
						BasicRuntimeChecks="3"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Silent_Debug|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						Optimization="0"
						PreprocessorDefinitions=""
						BasicRuntimeChecks="3"
					/>
				</FileConfiguration>
			</File>
			<File
				RelativePath=".\ndisInterfaceLayer.cpp"
				>
			</File>
			<File
				RelativePath=".\PacketDelayerLayer.cpp"
				>
			</File>
			<File
				RelativePath=".\PacketDropperLayer.cpp"
				>
			</File>
			<File
				RelativePath="StdAfx.cpp"
				>
				<FileConfiguration
					Name="Release|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						Optimization="2"
						PreprocessorDefinitions=""
						UsePrecompiledHeader="1"
						BrowseInformation="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						Optimization="2"
						PreprocessorDefinitions=""
						UsePrecompiledHeader="1"
						BrowseInformation="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Debug|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						Optimization="0"
						PreprocessorDefinitions=""
						BasicRuntimeChecks="3"
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Debug|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						Optimization="0"
						PreprocessorDefinitions=""
						BasicRuntimeChecks="3"
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Silent_Release|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						Optimization="2"
						PreprocessorDefinitions=""
						UsePrecompiledHeader="1"
						BrowseInformation="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Silent_Release|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						Optimization="2"
						PreprocessorDefinitions=""
						UsePrecompiledHeader="1"
						BrowseInformation="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Silent_Debug|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						Optimization="0"
						PreprocessorDefinitions=""
						BasicRuntimeChecks="3"
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Silent_Debug|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						Optimization="0"
						PreprocessorDefinitions=""
						BasicRuntimeChecks="3"
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl"
			>
			<File
				RelativePath=".\AckTimerLayer.h"
				>
			</File>
			<File
				RelativePath=".\Common.h"
				>
			</File>
			<File
				RelativePath=".\Finalization.h"
				>
			</File>
			<File
				RelativePath=".\Initialization.h"
				>
			</File>
			<File
				RelativePath="iphlp.h"
				>
			</File>
			<File
				RelativePath=".\lfnemu.h"
				>
			</File>
			<File
				RelativePath=".\ndisInterfaceLayer.h"
				>
			</File>
			<File
				RelativePath=".\PacketDelayerLayer.h"
				>
			</File>
			<File
				RelativePath=".\PacketDropperLayer.h"
				>
			</File>
			<File
				RelativePath="StdAfx.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`examples/legacy/MSVC/lfnemu/lfnemu.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{B0B38A85-9E3D-4349-B5F3-BDCA76E5E0EF}</ProjectGuid>
    <RootNamespace>lfnemu</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>11.0.51106.1</_ProjectFileVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>..\bin\i386\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>..\bin\amd64\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Midl>
      <TypeLibraryName>.\Release/lfnemu.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>.\Release/lfnemu.pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>.\Release/</AssemblerListingLocation>
      <ObjectFileName>.\Release/</ObjectFileName>
      <ProgramDataBaseFileName>.\Release/</ProgramDataBaseFileName>
      <BrowseInformation>true</BrowseInformation>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>Ws2_32.lib;$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <ProgramDatabaseFile>.\Release/lfnemu.pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>.\Release/lfnemu.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>.\Release/lfnemu.pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>.\Release/</AssemblerListingLocation>
      <ObjectFileName>.\Release/</ObjectFileName>
      <ProgramDataBaseFileName>.\Release/</ProgramDataBaseFileName>
      <BrowseInformation>true</BrowseInformation>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>Ws2_32.lib;$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <ProgramDatabaseFile>.\Release/lfnemu.pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Midl>
      <TypeLibraryName>.\Debug/lfnemu.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>.\Debug/lfnemu.pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>.\Debug/</AssemblerListingLocation>
      <ObjectFileName>.\Debug/</ObjectFileName>
      <ProgramDataBaseFileName>.\Debug/</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>Ws2_32.lib;$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>.\Debug/lfnemu.pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>.\Debug/lfnemu.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>.\Debug/lfnemu.pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>.\Debug/</AssemblerListingLocation>
      <ObjectFileName>.\Debug/</ObjectFileName>
      <ProgramDataBaseFileName>.\Debug/</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>Ws2_32.lib;$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>.\Debug/lfnemu.pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="AckTimerLayer.cpp" />
    <ClCompile Include="Common.cpp" />
    <ClCompile Include="Finalization.cpp" />
    <ClCompile Include="Initialization.cpp" />
    <ClCompile Include="lfnemu.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">EnableFastChecks</BasicRuntimeChecks>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">EnableFastChecks</BasicRuntimeChecks>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">MaxSpeed</Optimization>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</BrowseInformation>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</BrowseInformation>
    </ClCompile>
    <ClCompile Include="ndisInterfaceLayer.cpp" />
    <ClCompile Include="PacketDelayerLayer.cpp" />
    <ClCompile Include="PacketDropperLayer.cpp" />
    <ClCompile Include="StdAfx.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">MaxSpeed</Optimization>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</BrowseInformation>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</BrowseInformation>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="AckTimerLayer.h" />
    <ClInclude Include="Common.h" />
    <ClInclude Include="Finalization.h" />
    <ClInclude Include="Initialization.h" />
    <ClInclude Include="iphlp.h" />
    <ClInclude Include="lfnemu.h" />
    <ClInclude Include="ndisInterfaceLayer.h" />
    <ClInclude Include="PacketDelayerLayer.h" />
    <ClInclude Include="PacketDropperLayer.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="StdAfx.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="lfnemu.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/legacy/MSVC/lfnemu/lfnemu.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{a20f53b1-56cb-4ef1-8ac8-762bfad02845}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{c4955f39-45f8-4005-820c-ced7582313af}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{7ed13d6b-73e1-4c88-9150-219277795bae}</UniqueIdentifier>
      <Extensions>ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="AckTimerLayer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Common.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Finalization.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Initialization.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="lfnemu.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ndisInterfaceLayer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PacketDelayerLayer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PacketDropperLayer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="StdAfx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="AckTimerLayer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Finalization.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Initialization.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="iphlp.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="lfnemu.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ndisInterfaceLayer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PacketDelayerLayer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PacketDropperLayer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="StdAfx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="lfnemu.rc">
      <Filter>Source Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`examples/legacy/MSVC/lfnemu/ndisInterfaceLayer.h`:

```h
#ifndef _NDISINTERFACELAYER_H
#define _NDISINTERFACELAYER_H

#include "Common.h"

// NDIS Lower Layer variables and functions
void ndisBottomLayer(PETH_REQUEST pRequest);
void ndisTopLayer(PETH_REQUEST pRequest);

#endif //_NDISINTERFACELAYER_H
```

`examples/legacy/MSVC/lfnemu/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by lfnemu.rc

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`examples/legacy/MSVC/listadapters/StdAfx.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2016 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/*                                                                       */
/* Module Name:  stdafx.h                                                */
/*                                                                       */
/* Abstract: include file for standard system include files,             */
/*  or project specific include files that are used frequently, but      */
/*  are changed infrequently                                             */
/*                                                                       */
/*************************************************************************/

#if !defined(AFX_STDAFX_H__95FC7C90_B16C_4D28_94EA_FEBE5E608D6F__INCLUDED_)
#define AFX_STDAFX_H__95FC7C90_B16C_4D28_94EA_FEBE5E608D6F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <iphlpapi.h>

#include "..\..\..\..\include\common.h"
#include "..\..\..\..\include\ndisapi.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__95FC7C90_B16C_4D28_94EA_FEBE5E608D6F__INCLUDED_)

```

`examples/legacy/MSVC/listadapters/listadapters.dsp`:

```dsp
# Microsoft Developer Studio Project File - Name="listadapters" - Package Owner=<4>
# Microsoft Developer Studio Generated Build File, Format Version 6.00
# ** DO NOT EDIT **

# TARGTYPE "Win32 (x86) Console Application" 0x0103

CFG=listadapters - Win32 Debug
!MESSAGE This is not a valid makefile. To build this project using NMAKE,
!MESSAGE use the Export Makefile command and run
!MESSAGE 
!MESSAGE NMAKE /f "listadapters.mak".
!MESSAGE 
!MESSAGE You can specify a configuration when running NMAKE
!MESSAGE by defining the macro CFG on the command line. For example:
!MESSAGE 
!MESSAGE NMAKE /f "listadapters.mak" CFG="listadapters - Win32 Debug"
!MESSAGE 
!MESSAGE Possible choices for configuration are:
!MESSAGE 
!MESSAGE "listadapters - Win32 Release" (based on "Win32 (x86) Console Application")
!MESSAGE "listadapters - Win32 Debug" (based on "Win32 (x86) Console Application")
!MESSAGE 

# Begin Project
# PROP AllowPerConfigDependencies 0
# PROP Scc_ProjName ""
# PROP Scc_LocalPath ""
CPP=cl.exe
RSC=rc.exe

!IF  "$(CFG)" == "listadapters - Win32 Release"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 0
# PROP BASE Output_Dir "Release"
# PROP BASE Intermediate_Dir "Release"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 0
# PROP Output_Dir "Release"
# PROP Intermediate_Dir "Release"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /c
# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /FR /Yu"stdafx.h" /FD /c
# ADD BASE RSC /l 0x419 /d "NDEBUG"
# ADD RSC /l 0x409 /d "NDEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ndisapi.lib /nologo /subsystem:console /machine:I386 /out:"../bin/vc6/listadapters.exe" /libpath:"..\..\..\..\bin\dll.vc6\i386"

!ELSEIF  "$(CFG)" == "listadapters - Win32 Debug"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 1
# PROP BASE Output_Dir "Debug"
# PROP BASE Intermediate_Dir "Debug"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 1
# PROP Output_Dir "Debug"
# PROP Intermediate_Dir "Debug"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
# ADD BASE RSC /l 0x419 /d "_DEBUG"
# ADD RSC /l 0x409 /d "_DEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ndisapi.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept /libpath:"..\..\..\..\bin\dll.vc6\i386"

!ENDIF 

# Begin Target

# Name "listadapters - Win32 Release"
# Name "listadapters - Win32 Debug"
# Begin Group "Source Files"

# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
# Begin Source File

SOURCE=.\listadapters.cpp
# End Source File
# Begin Source File

SOURCE=.\StdAfx.cpp
# ADD CPP /Yc"stdafx.h"
# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl"
# Begin Source File

SOURCE=.\StdAfx.h
# End Source File
# End Group
# Begin Group "Resource Files"

# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
# End Group
# End Target
# End Project

```

`examples/legacy/MSVC/listadapters/listadapters.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{7D9BDE38-CEA2-491A-9AD9-51487436B60E}</ProjectGuid>
    <RootNamespace>listadapters</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>11.0.50727.1</_ProjectFileVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>../bin/i386/</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>../bin/amd64/</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Midl>
      <TypeLibraryName>.\Debug/listadapters.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>.\Debug/listadapters.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AddModuleNamesToAssembly>../kernel/bin/dll/amd64/ndisapi.lib;%(AddModuleNamesToAssembly)</AddModuleNamesToAssembly>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Midl>
      <TypeLibraryName>.\Release/listadapters.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <BrowseInformation>true</BrowseInformation>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AddModuleNamesToAssembly>../kernel/bin/dll/i386/ndisapi.lib;%(AddModuleNamesToAssembly)</AddModuleNamesToAssembly>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>.\Release/listadapters.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <BrowseInformation>true</BrowseInformation>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AddModuleNamesToAssembly>../kernel/bin/dll/amd64/ndisapi.lib;%(AddModuleNamesToAssembly)</AddModuleNamesToAssembly>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="listadapters.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">EnableFastChecks</BasicRuntimeChecks>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">EnableFastChecks</BasicRuntimeChecks>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">MaxSpeed</Optimization>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</BrowseInformation>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</BrowseInformation>
    </ClCompile>
    <ClCompile Include="StdAfx.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">MaxSpeed</Optimization>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</BrowseInformation>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</BrowseInformation>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="StdAfx.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/legacy/MSVC/listadapters/listadapters.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{2630330f-5e8d-4aa7-8970-ac3edad63f4c}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{91efea92-825e-4356-8cba-2d143d7ed690}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{cd4911bd-5cdf-43fc-b098-8e2d430c316c}</UniqueIdentifier>
      <Extensions>ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="listadapters.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="StdAfx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="StdAfx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`examples/legacy/MSVC/ndisrequest/StdAfx.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2016 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/*                                                                       */
/* Module Name:  stdafx.h                                                */
/*                                                                       */
/* Abstract: include file for standard system include files,             */
/*  or project specific include files that are used frequently, but      */
/*  are changed infrequently                                             */
/*                                                                       */
/*************************************************************************/

#if !defined(AFX_STDAFX_H__5C1BE8DE_CD55_45F0_B27F_8CF89E9FFE21__INCLUDED_)
#define AFX_STDAFX_H__5C1BE8DE_CD55_45F0_B27F_8CF89E9FFE21__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif // WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <iphlpapi.h>

#include "..\..\..\..\include\common.h"
#include "..\..\..\..\include\ndisapi.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5C1BE8DE_CD55_45F0_B27F_8CF89E9FFE21__INCLUDED_)

```

`examples/legacy/MSVC/ndisrequest/ndisrequest.dsp`:

```dsp
# Microsoft Developer Studio Project File - Name="ndisrequest" - Package Owner=<4>
# Microsoft Developer Studio Generated Build File, Format Version 6.00
# ** DO NOT EDIT **

# TARGTYPE "Win32 (x86) Console Application" 0x0103

CFG=ndisrequest - Win32 Debug
!MESSAGE This is not a valid makefile. To build this project using NMAKE,
!MESSAGE use the Export Makefile command and run
!MESSAGE 
!MESSAGE NMAKE /f "ndisrequest.mak".
!MESSAGE 
!MESSAGE You can specify a configuration when running NMAKE
!MESSAGE by defining the macro CFG on the command line. For example:
!MESSAGE 
!MESSAGE NMAKE /f "ndisrequest.mak" CFG="ndisrequest - Win32 Debug"
!MESSAGE 
!MESSAGE Possible choices for configuration are:
!MESSAGE 
!MESSAGE "ndisrequest - Win32 Release" (based on "Win32 (x86) Console Application")
!MESSAGE "ndisrequest - Win32 Debug" (based on "Win32 (x86) Console Application")
!MESSAGE 

# Begin Project
# PROP AllowPerConfigDependencies 0
# PROP Scc_ProjName ""
# PROP Scc_LocalPath ""
CPP=cl.exe
RSC=rc.exe

!IF  "$(CFG)" == "ndisrequest - Win32 Release"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 0
# PROP BASE Output_Dir "Release"
# PROP BASE Intermediate_Dir "Release"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 0
# PROP Output_Dir "Release"
# PROP Intermediate_Dir "Release"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /c
# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /c
# ADD BASE RSC /l 0x419 /d "NDEBUG"
# ADD RSC /l 0x419 /d "NDEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ndisapi.lib /nologo /subsystem:console /machine:I386 /out:"../bin/vc6/ndisrequest.exe" /libpath:"..\..\..\..\bin\dll.vc6\i386"

!ELSEIF  "$(CFG)" == "ndisrequest - Win32 Debug"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 1
# PROP BASE Output_Dir "Debug"
# PROP BASE Intermediate_Dir "Debug"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 1
# PROP Output_Dir "Debug"
# PROP Intermediate_Dir "Debug"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FR /Yu"stdafx.h" /FD /GZ /c
# ADD BASE RSC /l 0x419 /d "_DEBUG"
# ADD RSC /l 0x419 /d "_DEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ndisapi.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept /libpath:"..\..\..\..\bin\dll.vc6\i386"

!ENDIF 

# Begin Target

# Name "ndisrequest - Win32 Release"
# Name "ndisrequest - Win32 Debug"
# Begin Group "Source Files"

# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
# Begin Source File

SOURCE=.\ndisrequest.cpp
# End Source File
# Begin Source File

SOURCE=.\StdAfx.cpp
# ADD CPP /Yc"stdafx.h"
# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl"
# Begin Source File

SOURCE=.\StdAfx.h
# End Source File
# End Group
# Begin Group "Resource Files"

# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
# End Group
# End Target
# End Project

```

`examples/legacy/MSVC/ndisrequest/ndisrequest.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{21AB27A5-0D1F-49A2-9790-7B38572BB830}</ProjectGuid>
    <RootNamespace>ndisrequest</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>11.0.50727.1</_ProjectFileVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>../bin/i386/</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>../bin/amd64/</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Midl>
      <TypeLibraryName>.\Debug/ndisrequest.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <BrowseInformation>true</BrowseInformation>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0419</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>.\Debug/ndisrequest.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <BrowseInformation>true</BrowseInformation>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0419</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Midl>
      <TypeLibraryName>.\Release/ndisrequest.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0419</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>.\Release/ndisrequest.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0419</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="ndisrequest.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">EnableFastChecks</BasicRuntimeChecks>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</BrowseInformation>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">EnableFastChecks</BasicRuntimeChecks>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</BrowseInformation>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">MaxSpeed</Optimization>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
    </ClCompile>
    <ClCompile Include="StdAfx.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</BrowseInformation>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</BrowseInformation>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">MaxSpeed</Optimization>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="StdAfx.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/legacy/MSVC/ndisrequest/ndisrequest.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{0524854c-9ef2-4013-a50d-db7c674516de}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{ae0ff05c-ee2f-4d0c-81ec-2c02fd40c7d8}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{557eac6e-b237-4273-87aa-0c2f0c2da481}</UniqueIdentifier>
      <Extensions>ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ndisrequest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="StdAfx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="StdAfx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`examples/legacy/MSVC/packetsniffer/StdAfx.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2016 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/*                                                                       */
/* Module Name:  stdafx.h                                                */
/*                                                                       */
/* Abstract: include file for standard system include files,             */
/*  or project specific include files that are used frequently, but      */
/*  are changed infrequently                                             */
/*                                                                       */
/*************************************************************************/

#if !defined(AFX_STDAFX_H__090BD577_3479_4129_82EA_36B3F0A5D7E9__INCLUDED_)
#define AFX_STDAFX_H__090BD577_3479_4129_82EA_36B3F0A5D7E9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif // WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <iphlpapi.h>

#include "..\..\..\..\include\common.h"
#include "..\..\..\..\include\ndisapi.h"
#include "iphlp.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__090BD577_3479_4129_82EA_36B3F0A5D7E9__INCLUDED_)

```

`examples/legacy/MSVC/packetsniffer/iphlp.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2016 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/* Module Name:  iphlp.h				                                 */
/*                                                                       */
/* Abstract: IP helper definitions			        	                 */
/*                                                                       */
/* Environment:                                                          */
/*                                                                       */
/*   Kernel mode, NDIS-hooking driver                                    */
/*                                                                       */
/* Revision History:                                                     */
/*                                                                       */
/*************************************************************************/

#ifndef __IPHLP_H__
#define __IPHLP_H__

#pragma pack(1) 

///////////////////////////////////////////////////////////////////////////
// packet structures
///////////////////////////////////////////////////////////////////////////
typedef long n_long;
typedef short n_short;
typedef long n_time;
typedef unsigned short u_short;
typedef unsigned long u_long;
typedef unsigned char u_char;
typedef struct in_addr IN_ADDR, *PIN_ADDR;

#define ETH_ALEN				6		/* Octets in one ethernet addr	 */
#define ETHER_HEADER_LENGTH		14		/* Ethernet header length */

#define ETH_P_ARP		0x0806			/* Address Resolution packet	*/
#define ARPHRD_ETHER	0x01
#define ARPOP_REQUEST	0x01
#define ARPOP_REPLY		0x02

#define ETH_P_IP		0x0800			/* Internet Protocol packet	*/
#define ETH_P_IP_NET	0x0008			/* Internet Protocol packet	network order*/
#define ETH_P_RARP      0x8035			/* Reverse Addr Res packet	*/
#define ETH_P_ARP		0x0806			/* Address Resolution packet	*/

#define ETH_P_IPV6		0x86dd 			/* Internet Protocol V6 packet	*/
#define ETH_P_IPV6_NET	0xdd86 			/* Internet Protocol V6 packet network order*/

/*
 * Protocols
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_IGMP            2               /* group management protocol */
#define IPPROTO_GGP             3               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

// Ethernet Header
typedef struct ether_header 
{
	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
	unsigned short	h_proto;		/* packet type ID field	*/
} ether_header, *ether_header_ptr;

typedef struct arphdr
{
	unsigned short	ar_hrd;		/* format of hardware address	*/
	unsigned short	ar_pro;		/* format of protocol address	*/
	unsigned char	ar_hln;		/* length of hardware address	*/
	unsigned char	ar_pln;		/* length of protocol address	*/
	unsigned short	ar_op;		/* ARP opcode (command)		*/
} arphdr, *arphdr_ptr;

typedef struct	ether_arp 
{
	struct	arphdr ea_hdr;	/* fixed-size header */
	u_char	arp_sha[ETH_ALEN];	/* sender hardware address */
	u_char	arp_spa[4];	/* sender protocol address */
	u_char	arp_tha[ETH_ALEN];	/* target hardware address */
	u_char	arp_tpa[4];	/* target protocol address */
} ether_arp, *ether_arp_ptr;

#define	arp_hrd	ea_hdr.ar_hrd
#define	arp_pro	ea_hdr.ar_pro
#define	arp_hln	ea_hdr.ar_hln
#define	arp_pln	ea_hdr.ar_pln
#define	arp_op	ea_hdr.ar_op

/* IP Header in Little Endian */
typedef struct iphdr 
{
	u_char	ip_hl:4,		/* header length */
			ip_v:4;			/* version */
	u_char	ip_tos;			/* type of service */
	short	ip_len;			/* total length */
	u_short	ip_id;			/* identification */
	short	ip_off;			/* fragment offset field */
#define	IP_DF 0x4000		/* dont fragment flag */
#define	IP_MF 0x2000		/* more fragments flag */
	u_char	ip_ttl;			/* time to live */
	u_char	ip_p;			/* protocol */
	u_short	ip_sum;			/* checksum */
	struct	in_addr ip_src,ip_dst;	/* source and dest address */
} iphdr, *iphdr_ptr;
/////////////////////////////////////////////////////////////////////////
/* UDP header  */
typedef struct	udphdr
{
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	u_short	length;			/* data length */
	u_short	th_sum;			/* checksum */
} udphdr, *udphdr_ptr;
/////////////////////////////////////////////////////////////////////////
typedef	u_long	tcp_seq;

// TCP header. Per RFC 793, September, 1981. In Little Endian
typedef struct tcphdr {
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	tcp_seq	th_seq;			/* sequence number */
	tcp_seq	th_ack;			/* acknowledgement number */
	u_char	th_x2:4,		/* (unused) */
		    th_off:4;		/* data offset */
	u_char	th_flags;
#define	TH_FIN	0x01
#define	TH_SYN	0x02
#define	TH_RST	0x04
#define	TH_PSH	0x08
#define	TH_ACK	0x10
#define	TH_URG	0x20
	u_short	th_win;			/* window */
	u_short	th_sum;			/* checksum */
	u_short	th_urp;			/* urgent pointer */
} tcphdr, *tcphdr_ptr;

typedef struct pseudo_header
{
  struct in_addr source_address;
  struct in_addr dest_address;
  unsigned char placeholder;
  unsigned char protocol;
  unsigned short tcp_length;

}pseudo_header, *pseudo_header_ptr;

/////////////////////////////////////////////////////////////////////////

//
// Protocols for IPv6
//
#define IPPROTO_HOPOPTS		0             // Hop by hop header for v6
#define IPPROTO_IPV6		41            // IPv6 encapsulated in IP
#define IPPROTO_ROUTING		43            // Routing header for IPv6
#define IPPROTO_FRAGMENT	44            // Fragment header for IPv6
#define IPPROTO_ICMPV6		58            // ICMP for IPv6
#define IPPROTO_NONE		59            // No next header for IPv6
#define IPPROTO_DSTOPTS		60            // Destinations options

//
// IPv6 header format
//
typedef struct ipv6hdr 
{
	unsigned int	ip6_flow;	// 4  bits = version #, 
								// 8  bits = Trafic class,
								// 20 bits = flow label
	unsigned short	ip6_len;    // Payload length
	unsigned char	ip6_next;	// Next Header
	unsigned char	ip6_hops;	// Hop Limit
	IN6_ADDR		ip6_src;	// Source Address
	IN6_ADDR		ip6_dst;	// Destination Address
} ipv6hdr, *ipv6hdr_ptr;

//
// IPv6 extension header format
//
typedef struct ipv6ext {
	unsigned char    ip6_next;		// Next Header
	unsigned char    ip6_len;		// number of bytes in this header 
	unsigned char    ip6_data[2];	// optional data
}ipv6ext, *ipv6ext_ptr;

typedef struct ipv6ext_frag
{
    unsigned char		ip6_next;       // next header
    unsigned char		ip6_reserved;   // reserved field
    unsigned short		ip6_offlg;      // offset, reserved, and flag
    unsigned int		ip6_ident;      // identification
}ipv6ext_frag, *ipv6ext_frag_ptr;

#pragma pack()

#endif // __IPHLP_H__
```

`examples/legacy/MSVC/packetsniffer/packetsniffer.dsp`:

```dsp
# Microsoft Developer Studio Project File - Name="packetsniffer" - Package Owner=<4>
# Microsoft Developer Studio Generated Build File, Format Version 6.00
# ** DO NOT EDIT **

# TARGTYPE "Win32 (x86) Console Application" 0x0103

CFG=packetsniffer - Win32 Debug
!MESSAGE This is not a valid makefile. To build this project using NMAKE,
!MESSAGE use the Export Makefile command and run
!MESSAGE 
!MESSAGE NMAKE /f "packetsniffer.mak".
!MESSAGE 
!MESSAGE You can specify a configuration when running NMAKE
!MESSAGE by defining the macro CFG on the command line. For example:
!MESSAGE 
!MESSAGE NMAKE /f "packetsniffer.mak" CFG="packetsniffer - Win32 Debug"
!MESSAGE 
!MESSAGE Possible choices for configuration are:
!MESSAGE 
!MESSAGE "packetsniffer - Win32 Release" (based on "Win32 (x86) Console Application")
!MESSAGE "packetsniffer - Win32 Debug" (based on "Win32 (x86) Console Application")
!MESSAGE 

# Begin Project
# PROP AllowPerConfigDependencies 0
# PROP Scc_ProjName ""
# PROP Scc_LocalPath ""
CPP=cl.exe
RSC=rc.exe

!IF  "$(CFG)" == "packetsniffer - Win32 Release"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 0
# PROP BASE Output_Dir "Release"
# PROP BASE Intermediate_Dir "Release"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 0
# PROP Output_Dir "Release"
# PROP Intermediate_Dir "Release"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /c
# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /c
# ADD BASE RSC /l 0x419 /d "NDEBUG"
# ADD RSC /l 0x409 /d "NDEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ndisapi.lib /nologo /subsystem:console /machine:I386 /out:"../bin/vc6/packetsniffer.exe" /libpath:"..\..\..\..\bin\dll.vc6\i386"

!ELSEIF  "$(CFG)" == "packetsniffer - Win32 Debug"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 1
# PROP BASE Output_Dir "Debug"
# PROP BASE Intermediate_Dir "Debug"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 1
# PROP Output_Dir "Debug"
# PROP Intermediate_Dir "Debug"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
# ADD BASE RSC /l 0x419 /d "_DEBUG"
# ADD RSC /l 0x409 /d "_DEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ndisapi.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept /libpath:"..\..\..\..\bin\dll.vc6\i386"

!ENDIF 

# Begin Target

# Name "packetsniffer - Win32 Release"
# Name "packetsniffer - Win32 Debug"
# Begin Group "Source Files"

# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
# Begin Source File

SOURCE=.\packetsniffer.cpp
# End Source File
# Begin Source File

SOURCE=.\StdAfx.cpp
# ADD CPP /Yc"stdafx.h"
# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl"
# Begin Source File

SOURCE=.\iphlp.h
# End Source File
# Begin Source File

SOURCE=.\StdAfx.h
# End Source File
# End Group
# Begin Group "Resource Files"

# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
# End Group
# End Target
# End Project

```

`examples/legacy/MSVC/packetsniffer/packetsniffer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{BDC5FDDF-C344-4D19-90E9-5A0B7320D24B}</ProjectGuid>
    <RootNamespace>packetsniffer</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>11.0.50727.1</_ProjectFileVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>../bin/i386/</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>../bin/amd64/</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Midl>
      <TypeLibraryName>.\Debug/packetsniffer.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>.\Debug/packetsniffer.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Midl>
      <TypeLibraryName>.\Release/packetsniffer.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>.\Release/packetsniffer.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="packetsniffer.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">EnableFastChecks</BasicRuntimeChecks>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">EnableFastChecks</BasicRuntimeChecks>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">MaxSpeed</Optimization>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
    </ClCompile>
    <ClCompile Include="StdAfx.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">MaxSpeed</Optimization>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="iphlp.h" />
    <ClInclude Include="StdAfx.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/legacy/MSVC/packetsniffer/packetsniffer.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{39727a77-02e6-474e-8d5e-36c618f934e6}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{e025a8bc-8f75-40fd-b9c9-78128e52f83c}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{e350fb76-394f-4928-88ba-d14fae4db01f}</UniqueIdentifier>
      <Extensions>ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="packetsniffer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="StdAfx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="iphlp.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="StdAfx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`examples/legacy/MSVC/packthru/StdAfx.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2016 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/*                                                                       */
/* Module Name:  stdafx.h                                                */
/*                                                                       */
/* Abstract: include file for standard system include files,             */
/*  or project specific include files that are used frequently, but      */
/*  are changed infrequently                                             */
/*                                                                       */
/*************************************************************************/

#if !defined(AFX_STDAFX_H__8CD24513_169B_47A9_859B_9A99FF8266DA__INCLUDED_)
#define AFX_STDAFX_H__8CD24513_169B_47A9_859B_9A99FF8266DA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif // WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <iphlpapi.h>

#include "..\..\..\..\include\common.h"
#include "..\..\..\..\include\ndisapi.h"
#include "iphlp.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8CD24513_169B_47A9_859B_9A99FF8266DA__INCLUDED_)

```

`examples/legacy/MSVC/packthru/iphlp.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2016 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/* Module Name:  iphlp.h				                                 */
/*                                                                       */
/* Abstract: IP helper definitions			        	                 */
/*                                                                       */
/* Environment:                                                          */
/*                                                                       */
/*   Kernel mode, NDIS-hooking driver                                    */
/*                                                                       */
/* Revision History:                                                     */
/*                                                                       */
/*************************************************************************/

#ifndef __IPHLP_H__
#define __IPHLP_H__

#pragma pack(1) 

///////////////////////////////////////////////////////////////////////////
// packet structures
///////////////////////////////////////////////////////////////////////////
typedef long n_long;
typedef short n_short;
typedef long n_time;
typedef unsigned short u_short;
typedef unsigned long u_long;
typedef unsigned char u_char;
typedef struct in_addr IN_ADDR, *PIN_ADDR;

#define ETH_ALEN				6		/* Octets in one ethernet addr	 */
#define ETHER_HEADER_LENGTH		14		/* Ethernet header length */

#define ETH_P_ARP		0x0806			/* Address Resolution packet	*/
#define ARPHRD_ETHER	0x01
#define ARPOP_REQUEST	0x01
#define ARPOP_REPLY		0x02

#define ETH_P_IP		0x0800			/* Internet Protocol packet	*/
#define ETH_P_IP_NET	0x0008			/* Internet Protocol packet	network order*/
#define ETH_P_RARP      0x8035			/* Reverse Addr Res packet	*/
#define ETH_P_ARP		0x0806			/* Address Resolution packet	*/

#define ETH_P_IPV6		0x86dd 			/* Internet Protocol V6 packet	*/
#define ETH_P_IPV6_NET	0xdd86 			/* Internet Protocol V6 packet network order*/

/*
 * Protocols
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_IGMP            2               /* group management protocol */
#define IPPROTO_GGP             3               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

// Ethernet Header
typedef struct ether_header 
{
	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
	unsigned short	h_proto;		/* packet type ID field	*/
} ether_header, *ether_header_ptr;

typedef struct arphdr
{
	unsigned short	ar_hrd;		/* format of hardware address	*/
	unsigned short	ar_pro;		/* format of protocol address	*/
	unsigned char	ar_hln;		/* length of hardware address	*/
	unsigned char	ar_pln;		/* length of protocol address	*/
	unsigned short	ar_op;		/* ARP opcode (command)		*/
} arphdr, *arphdr_ptr;

typedef struct	ether_arp 
{
	struct	arphdr ea_hdr;	/* fixed-size header */
	u_char	arp_sha[ETH_ALEN];	/* sender hardware address */
	u_char	arp_spa[4];	/* sender protocol address */
	u_char	arp_tha[ETH_ALEN];	/* target hardware address */
	u_char	arp_tpa[4];	/* target protocol address */
} ether_arp, *ether_arp_ptr;

#define	arp_hrd	ea_hdr.ar_hrd
#define	arp_pro	ea_hdr.ar_pro
#define	arp_hln	ea_hdr.ar_hln
#define	arp_pln	ea_hdr.ar_pln
#define	arp_op	ea_hdr.ar_op

/* IP Header in Little Endian */
typedef struct iphdr 
{
	u_char	ip_hl:4,		/* header length */
			ip_v:4;			/* version */
	u_char	ip_tos;			/* type of service */
	short	ip_len;			/* total length */
	u_short	ip_id;			/* identification */
	short	ip_off;			/* fragment offset field */
#define	IP_DF 0x4000		/* dont fragment flag */
#define	IP_MF 0x2000		/* more fragments flag */
	u_char	ip_ttl;			/* time to live */
	u_char	ip_p;			/* protocol */
	u_short	ip_sum;			/* checksum */
	struct	in_addr ip_src,ip_dst;	/* source and dest address */
} iphdr, *iphdr_ptr;
/////////////////////////////////////////////////////////////////////////
/* UDP header  */
typedef struct	udphdr
{
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	u_short	length;			/* data length */
	u_short	th_sum;			/* checksum */
} udphdr, *udphdr_ptr;
/////////////////////////////////////////////////////////////////////////
typedef	u_long	tcp_seq;

// TCP header. Per RFC 793, September, 1981. In Little Endian
typedef struct tcphdr {
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	tcp_seq	th_seq;			/* sequence number */
	tcp_seq	th_ack;			/* acknowledgement number */
	u_char	th_x2:4,		/* (unused) */
		    th_off:4;		/* data offset */
	u_char	th_flags;
#define	TH_FIN	0x01
#define	TH_SYN	0x02
#define	TH_RST	0x04
#define	TH_PSH	0x08
#define	TH_ACK	0x10
#define	TH_URG	0x20
	u_short	th_win;			/* window */
	u_short	th_sum;			/* checksum */
	u_short	th_urp;			/* urgent pointer */
} tcphdr, *tcphdr_ptr;

typedef struct pseudo_header
{
  struct in_addr source_address;
  struct in_addr dest_address;
  unsigned char placeholder;
  unsigned char protocol;
  unsigned short tcp_length;

}pseudo_header, *pseudo_header_ptr;

/////////////////////////////////////////////////////////////////////////

//
// Protocols for IPv6
//
#define IPPROTO_HOPOPTS		0             // Hop by hop header for v6
#define IPPROTO_IPV6		41            // IPv6 encapsulated in IP
#define IPPROTO_ROUTING		43            // Routing header for IPv6
#define IPPROTO_FRAGMENT	44            // Fragment header for IPv6
#define IPPROTO_ICMPV6		58            // ICMP for IPv6
#define IPPROTO_NONE		59            // No next header for IPv6
#define IPPROTO_DSTOPTS		60            // Destinations options

//
// IPv6 header format
//
typedef struct ipv6hdr 
{
	unsigned int	ip6_flow;	// 4  bits = version #, 
								// 8  bits = Trafic class,
								// 20 bits = flow label
	unsigned short	ip6_len;    // Payload length
	unsigned char	ip6_next;	// Next Header
	unsigned char	ip6_hops;	// Hop Limit
	IN6_ADDR		ip6_src;	// Source Address
	IN6_ADDR		ip6_dst;	// Destination Address
} ipv6hdr, *ipv6hdr_ptr;

//
// IPv6 extension header format
//
typedef struct ipv6ext {
	unsigned char    ip6_next;		// Next Header
	unsigned char    ip6_len;		// number of bytes in this header 
	unsigned char    ip6_data[2];	// optional data
}ipv6ext, *ipv6ext_ptr;

typedef struct ipv6ext_frag
{
    unsigned char		ip6_next;       // next header
    unsigned char		ip6_reserved;   // reserved field
    unsigned short		ip6_offlg;      // offset, reserved, and flag
    unsigned int		ip6_ident;      // identification
}ipv6ext_frag, *ipv6ext_frag_ptr;

#pragma pack()

#endif // __IPHLP_H__
```

`examples/legacy/MSVC/packthru/packthru.dsp`:

```dsp
# Microsoft Developer Studio Project File - Name="packthru" - Package Owner=<4>
# Microsoft Developer Studio Generated Build File, Format Version 6.00
# ** DO NOT EDIT **

# TARGTYPE "Win32 (x86) Console Application" 0x0103

CFG=packthru - Win32 Release
!MESSAGE This is not a valid makefile. To build this project using NMAKE,
!MESSAGE use the Export Makefile command and run
!MESSAGE 
!MESSAGE NMAKE /f "packthru.mak".
!MESSAGE 
!MESSAGE You can specify a configuration when running NMAKE
!MESSAGE by defining the macro CFG on the command line. For example:
!MESSAGE 
!MESSAGE NMAKE /f "packthru.mak" CFG="packthru - Win32 Release"
!MESSAGE 
!MESSAGE Possible choices for configuration are:
!MESSAGE 
!MESSAGE "packthru - Win32 Release" (based on "Win32 (x86) Console Application")
!MESSAGE "packthru - Win32 Debug" (based on "Win32 (x86) Console Application")
!MESSAGE 

# Begin Project
# PROP AllowPerConfigDependencies 0
# PROP Scc_ProjName ""
# PROP Scc_LocalPath ""
CPP=cl.exe
RSC=rc.exe

!IF  "$(CFG)" == "packthru - Win32 Release"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 0
# PROP BASE Output_Dir "Release"
# PROP BASE Intermediate_Dir "Release"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 0
# PROP Output_Dir "Release"
# PROP Intermediate_Dir "Release"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /c
# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /FR /Yu"stdafx.h" /FD /c
# ADD BASE RSC /l 0x419 /d "NDEBUG"
# ADD RSC /l 0x409 /d "NDEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ndisapi.lib /nologo /subsystem:console /machine:I386 /out:"../bin/vc6/packthru.exe" /libpath:"..\..\..\..\bin\dll.vc6\i386"

!ELSEIF  "$(CFG)" == "packthru - Win32 Debug"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 1
# PROP BASE Output_Dir "Debug"
# PROP BASE Intermediate_Dir "Debug"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 1
# PROP Output_Dir "Debug"
# PROP Intermediate_Dir "Debug"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
# ADD BASE RSC /l 0x419 /d "_DEBUG"
# ADD RSC /l 0x409 /d "_DEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ndisapi.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept /libpath:"..\..\..\..\bin\dll.vc6\i386"

!ENDIF 

# Begin Target

# Name "packthru - Win32 Release"
# Name "packthru - Win32 Debug"
# Begin Group "Source Files"

# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
# Begin Source File

SOURCE=.\packthru.cpp
# End Source File
# Begin Source File

SOURCE=.\StdAfx.cpp
# ADD CPP /Yc"stdafx.h"
# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl"
# Begin Source File

SOURCE=.\iphlp.h
# End Source File
# Begin Source File

SOURCE=.\StdAfx.h
# End Source File
# End Group
# Begin Group "Resource Files"

# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
# End Group
# End Target
# End Project

```

`examples/legacy/MSVC/packthru/packthru.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{D6FB0278-A7DD-4A77-88FA-476B3082D418}</ProjectGuid>
    <RootNamespace>packthru</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>11.0.50727.1</_ProjectFileVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>..\bin\i386\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>..\bin\amd64\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Midl>
      <TypeLibraryName>.\Release/packthru.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <BrowseInformation>true</BrowseInformation>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>.\Release/packthru.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <BrowseInformation>true</BrowseInformation>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Midl>
      <TypeLibraryName>.\Debug/packthru.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>.\Debug/packthru.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="packthru.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">EnableFastChecks</BasicRuntimeChecks>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">EnableFastChecks</BasicRuntimeChecks>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">MaxSpeed</Optimization>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</BrowseInformation>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</BrowseInformation>
    </ClCompile>
    <ClCompile Include="StdAfx.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">MaxSpeed</Optimization>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</BrowseInformation>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</BrowseInformation>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="iphlp.h" />
    <ClInclude Include="StdAfx.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/legacy/MSVC/packthru/packthru.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{fe27ab83-bf1c-4679-9147-a1845a52c37b}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{f3999c5f-3130-4df2-99d2-58e40806c43e}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{be9549a9-4c13-4339-9be8-5b6591420f6f}</UniqueIdentifier>
      <Extensions>ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="packthru.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="StdAfx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="iphlp.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="StdAfx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`examples/legacy/MSVC/passthru/StdAfx.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2016 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/*                                                                       */
/* Module Name:  stdafx.h                                                */
/*                                                                       */
/* Abstract: include file for standard system include files,             */
/*  or project specific include files that are used frequently, but      */
/*  are changed infrequently                                             */
/*                                                                       */
/*************************************************************************/

#if !defined(AFX_STDAFX_H__8CD24513_169B_47A9_859B_9A99FF8266DA__INCLUDED_)
#define AFX_STDAFX_H__8CD24513_169B_47A9_859B_9A99FF8266DA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif // WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <iphlpapi.h>

#include "..\..\..\..\include\common.h"
#include "..\..\..\..\include\ndisapi.h"
#include "iphlp.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8CD24513_169B_47A9_859B_9A99FF8266DA__INCLUDED_)

```

`examples/legacy/MSVC/passthru/iphlp.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2016 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/* Module Name:  iphlp.h				                                 */
/*                                                                       */
/* Abstract: IP helper definitions			        	                 */
/*                                                                       */
/* Environment:                                                          */
/*                                                                       */
/*   Kernel mode, NDIS-hooking driver                                    */
/*                                                                       */
/* Revision History:                                                     */
/*                                                                       */
/*************************************************************************/

#ifndef __IPHLP_H__
#define __IPHLP_H__

#pragma pack(1) 

///////////////////////////////////////////////////////////////////////////
// packet structures
///////////////////////////////////////////////////////////////////////////
typedef long n_long;
typedef short n_short;
typedef long n_time;
typedef unsigned short u_short;
typedef unsigned long u_long;
typedef unsigned char u_char;
typedef struct in_addr IN_ADDR, *PIN_ADDR;

#define ETH_ALEN				6		/* Octets in one ethernet addr	 */
#define ETHER_HEADER_LENGTH		14		/* Ethernet header length */

#define ETH_P_ARP		0x0806			/* Address Resolution packet	*/
#define ARPHRD_ETHER	0x01
#define ARPOP_REQUEST	0x01
#define ARPOP_REPLY		0x02

#define ETH_P_IP		0x0800			/* Internet Protocol packet	*/
#define ETH_P_IP_NET	0x0008			/* Internet Protocol packet	network order*/
#define ETH_P_RARP      0x8035			/* Reverse Addr Res packet	*/
#define ETH_P_ARP		0x0806			/* Address Resolution packet	*/

#define ETH_P_IPV6		0x86dd 			/* Internet Protocol V6 packet	*/
#define ETH_P_IPV6_NET	0xdd86 			/* Internet Protocol V6 packet network order*/

/*
 * Protocols
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_IGMP            2               /* group management protocol */
#define IPPROTO_GGP             3               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

// Ethernet Header
typedef struct ether_header 
{
	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
	unsigned short	h_proto;		/* packet type ID field	*/
} ether_header, *ether_header_ptr;

typedef struct arphdr
{
	unsigned short	ar_hrd;		/* format of hardware address	*/
	unsigned short	ar_pro;		/* format of protocol address	*/
	unsigned char	ar_hln;		/* length of hardware address	*/
	unsigned char	ar_pln;		/* length of protocol address	*/
	unsigned short	ar_op;		/* ARP opcode (command)		*/
} arphdr, *arphdr_ptr;

typedef struct	ether_arp 
{
	struct	arphdr ea_hdr;	/* fixed-size header */
	u_char	arp_sha[ETH_ALEN];	/* sender hardware address */
	u_char	arp_spa[4];	/* sender protocol address */
	u_char	arp_tha[ETH_ALEN];	/* target hardware address */
	u_char	arp_tpa[4];	/* target protocol address */
} ether_arp, *ether_arp_ptr;

#define	arp_hrd	ea_hdr.ar_hrd
#define	arp_pro	ea_hdr.ar_pro
#define	arp_hln	ea_hdr.ar_hln
#define	arp_pln	ea_hdr.ar_pln
#define	arp_op	ea_hdr.ar_op

/* IP Header in Little Endian */
typedef struct iphdr 
{
	u_char	ip_hl:4,		/* header length */
			ip_v:4;			/* version */
	u_char	ip_tos;			/* type of service */
	short	ip_len;			/* total length */
	u_short	ip_id;			/* identification */
	short	ip_off;			/* fragment offset field */
#define	IP_DF 0x4000		/* dont fragment flag */
#define	IP_MF 0x2000		/* more fragments flag */
	u_char	ip_ttl;			/* time to live */
	u_char	ip_p;			/* protocol */
	u_short	ip_sum;			/* checksum */
	struct	in_addr ip_src,ip_dst;	/* source and dest address */
} iphdr, *iphdr_ptr;
/////////////////////////////////////////////////////////////////////////
/* UDP header  */
typedef struct	udphdr
{
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	u_short	length;			/* data length */
	u_short	th_sum;			/* checksum */
} udphdr, *udphdr_ptr;
/////////////////////////////////////////////////////////////////////////
typedef	u_long	tcp_seq;

// TCP header. Per RFC 793, September, 1981. In Little Endian
typedef struct tcphdr {
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	tcp_seq	th_seq;			/* sequence number */
	tcp_seq	th_ack;			/* acknowledgement number */
	u_char	th_x2:4,		/* (unused) */
		    th_off:4;		/* data offset */
	u_char	th_flags;
#define	TH_FIN	0x01
#define	TH_SYN	0x02
#define	TH_RST	0x04
#define	TH_PSH	0x08
#define	TH_ACK	0x10
#define	TH_URG	0x20
	u_short	th_win;			/* window */
	u_short	th_sum;			/* checksum */
	u_short	th_urp;			/* urgent pointer */
} tcphdr, *tcphdr_ptr;

typedef struct pseudo_header
{
  struct in_addr source_address;
  struct in_addr dest_address;
  unsigned char placeholder;
  unsigned char protocol;
  unsigned short tcp_length;

}pseudo_header, *pseudo_header_ptr;

/////////////////////////////////////////////////////////////////////////

//
// Protocols for IPv6
//
#define IPPROTO_HOPOPTS		0             // Hop by hop header for v6
#define IPPROTO_IPV6		41            // IPv6 encapsulated in IP
#define IPPROTO_ROUTING		43            // Routing header for IPv6
#define IPPROTO_FRAGMENT	44            // Fragment header for IPv6
#define IPPROTO_ICMPV6		58            // ICMP for IPv6
#define IPPROTO_NONE		59            // No next header for IPv6
#define IPPROTO_DSTOPTS		60            // Destinations options

//
// IPv6 header format
//
typedef struct ipv6hdr 
{
	unsigned int	ip6_flow;	// 4  bits = version #, 
								// 8  bits = Trafic class,
								// 20 bits = flow label
	unsigned short	ip6_len;    // Payload length
	unsigned char	ip6_next;	// Next Header
	unsigned char	ip6_hops;	// Hop Limit
	IN6_ADDR		ip6_src;	// Source Address
	IN6_ADDR		ip6_dst;	// Destination Address
} ipv6hdr, *ipv6hdr_ptr;

//
// IPv6 extension header format
//
typedef struct ipv6ext {
	unsigned char    ip6_next;		// Next Header
	unsigned char    ip6_len;		// number of bytes in this header 
	unsigned char    ip6_data[2];	// optional data
}ipv6ext, *ipv6ext_ptr;

typedef struct ipv6ext_frag
{
    unsigned char		ip6_next;       // next header
    unsigned char		ip6_reserved;   // reserved field
    unsigned short		ip6_offlg;      // offset, reserved, and flag
    unsigned int		ip6_ident;      // identification
}ipv6ext_frag, *ipv6ext_frag_ptr;

#pragma pack()

#endif // __IPHLP_H__
```

`examples/legacy/MSVC/passthru/passthru.dsp`:

```dsp
# Microsoft Developer Studio Project File - Name="passthru" - Package Owner=<4>
# Microsoft Developer Studio Generated Build File, Format Version 6.00
# ** DO NOT EDIT **

# TARGTYPE "Win32 (x86) Console Application" 0x0103

CFG=passthru - Win32 Release
!MESSAGE This is not a valid makefile. To build this project using NMAKE,
!MESSAGE use the Export Makefile command and run
!MESSAGE 
!MESSAGE NMAKE /f "passthru.mak".
!MESSAGE 
!MESSAGE You can specify a configuration when running NMAKE
!MESSAGE by defining the macro CFG on the command line. For example:
!MESSAGE 
!MESSAGE NMAKE /f "passthru.mak" CFG="passthru - Win32 Release"
!MESSAGE 
!MESSAGE Possible choices for configuration are:
!MESSAGE 
!MESSAGE "passthru - Win32 Release" (based on "Win32 (x86) Console Application")
!MESSAGE "passthru - Win32 Debug" (based on "Win32 (x86) Console Application")
!MESSAGE 

# Begin Project
# PROP AllowPerConfigDependencies 0
# PROP Scc_ProjName ""
# PROP Scc_LocalPath ""
CPP=cl.exe
RSC=rc.exe

!IF  "$(CFG)" == "passthru - Win32 Release"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 0
# PROP BASE Output_Dir "Release"
# PROP BASE Intermediate_Dir "Release"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 0
# PROP Output_Dir "Release"
# PROP Intermediate_Dir "Release"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /c
# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /FR /Yu"stdafx.h" /FD /c
# ADD BASE RSC /l 0x419 /d "NDEBUG"
# ADD RSC /l 0x409 /d "NDEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ndisapi.lib /nologo /subsystem:console /machine:I386 /out:"../bin/vc6/passthru.exe" /libpath:"..\..\..\..\bin\dll.vc6\i386"

!ELSEIF  "$(CFG)" == "passthru - Win32 Debug"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 1
# PROP BASE Output_Dir "Debug"
# PROP BASE Intermediate_Dir "Debug"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 1
# PROP Output_Dir "Debug"
# PROP Intermediate_Dir "Debug"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
# ADD BASE RSC /l 0x419 /d "_DEBUG"
# ADD RSC /l 0x409 /d "_DEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ndisapi.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept /libpath:"..\..\..\..\bin\dll.vc6\i386"

!ENDIF 

# Begin Target

# Name "passthru - Win32 Release"
# Name "passthru - Win32 Debug"
# Begin Group "Source Files"

# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
# Begin Source File

SOURCE=.\passthru.cpp
# End Source File
# Begin Source File

SOURCE=.\StdAfx.cpp
# ADD CPP /Yc"stdafx.h"
# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl"
# Begin Source File

SOURCE=.\iphlp.h
# End Source File
# Begin Source File

SOURCE=.\StdAfx.h
# End Source File
# End Group
# Begin Group "Resource Files"

# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
# End Group
# End Target
# End Project

```

`examples/legacy/MSVC/passthru/passthru.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{E6157A81-9E3D-497A-8C14-1EFA4A7CAD84}</ProjectGuid>
    <RootNamespace>passthru</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>11.0.50727.1</_ProjectFileVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>..\bin\i386\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>..\bin\amd64\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Midl>
      <TypeLibraryName>.\Release/passthru.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <BrowseInformation>true</BrowseInformation>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>.\Release/passthru.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <BrowseInformation>true</BrowseInformation>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Midl>
      <TypeLibraryName>.\Debug/passthru.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>.\Debug/passthru.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="passthru.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">EnableFastChecks</BasicRuntimeChecks>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">EnableFastChecks</BasicRuntimeChecks>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">MaxSpeed</Optimization>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</BrowseInformation>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</BrowseInformation>
    </ClCompile>
    <ClCompile Include="StdAfx.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">MaxSpeed</Optimization>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</BrowseInformation>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</BrowseInformation>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="iphlp.h" />
    <ClInclude Include="StdAfx.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/legacy/MSVC/passthru/passthru.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{0dbb96b2-1c5d-461b-a5a5-facf2ca91571}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{10e919ea-4840-4e19-9804-3587ce652b6d}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{0facd835-345a-437e-ba1e-f11ddf190288}</UniqueIdentifier>
      <Extensions>ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="passthru.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="StdAfx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="iphlp.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="StdAfx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`examples/legacy/MSVC/snat/NetcardProp.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2016 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/* Module Name:  NetcardProp.h			                                 */
/*                                                                       */
/* Abstract: CNetcardProp dialog declarations	      	                 */
/*                                                                       */
/*                                                                       */
/*************************************************************************/

#pragma once
#include "NetworkInterface.h"
#include "afxcmn.h"
#include "afxwin.h"

// CNetcardProp dialog

class CNetcardProp : public CDialog
{
	DECLARE_DYNAMIC(CNetcardProp)

public:
	CNetcardProp(CWnd* pParent = NULL);   // standard constructor
	virtual ~CNetcardProp();

// Dialog Data
	enum { IDD = IDD_INTERFACE_PROPERTIES };

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

	DECLARE_MESSAGE_MAP()
public:
	virtual BOOL OnInitDialog();
	
	CNetworkInterface*	m_pNetworkInterface; // points to associated CNetworkInterface structure
	CListCtrl			m_IpList; // control for the list of IP's
	CIPAddressCtrl		m_NATIp; // control for configuring NAT IP
	CComboBox			m_NATStatus; // control for setting NAT status for the interface
	CIPAddressCtrl		m_NatDNS;// control for setting NAT DNS ip address for the interface
	CButton				m_ClientDNS;// control for setting DNS spoofing status for the interface

	afx_msg void OnCbnSelchangeCombonat();
	afx_msg void OnNMDblclkListIp(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnIpnFieldchangedIpaddress1(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnBnClickedCheck1();
	
	
	afx_msg void OnBnClickedOk();
};

```

`examples/legacy/MSVC/snat/NetworkInterface.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2016 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/* Module Name:  NetworkInterface.h		                                 */
/*                                                                       */
/* Abstract: CNetworkInterface declaration		      	                 */
/*                                                                       */
/*                                                                       */
/*************************************************************************/

#pragma once
#include <afxtempl.h>
#include "ipexport.h"

// We keep IP addresses in this structure to avoid unnecessary
// conversions
class CIpAddr
{
public:
	CString m_szIp;
	CString m_szMask;
	in_addr m_Ip;
};

// Possible interface states
// NONE - adapter works usual
// PROVIDER - this interface connection is shared by all connections configured as CLIENT (usually Internet connection interface)
// CLIENT - usually interface in the home network
typedef enum
{
	NONE,
	PROVIDER,
	CLIENT
} NAT_STATUS;

// CIpAddrList is used for keeping all IP's associated with network interface
typedef CTypedPtrList<CPtrList, CIpAddr*> CIpAddrList;

struct CNetworkInterface
{
	CNetworkInterface(void);
	~CNetworkInterface(void);

	CString			m_szInternalName; // Internal interface name (as it is seen by WinpkFilter driver)
	CString			m_szUserFriendlyName; // User friendly interface (network connection) name as it is seen in Network Connections
	bool			m_bIsWan; // TRUE for WAN (dial-up) interfaces
	unsigned char	m_chMACAddr[ETHER_ADDR_LENGTH]; // MAC (Ethernet) address for the network interface
	CIpAddrList		m_IpList; // List of configured IP addresses
	NAT_STATUS		m_NATState; // NONE, PROVIDER or CLIENT (see description above)
	in_addr			m_NATIp; // IP address used for NAT'ing (makes sense only if adapter configured as PROVIDER)
	HANDLE			m_hAdapter; // Network interface handle (required for any operations using WinpkFilter driver)
	in_addr			m_LocalDNS; // Used for redirecting DNS requests, usually should be equal to the one of the interfcae local IP's
								// makes sense only for adapters configured as CLIENT
	DWORD			m_Index;	//Index of this interface 
	USHORT			m_MTU;		//MTU of this interface

	BOOL	IsLocalAddress (in_addr* pIp); // Returns TRUE is specified IP belongs (configured) to this network interface
	int		InitIPInformation (void); // Initializes IP address list for this interface though IP helper API
	void	InitMTUInformation(void); //Initializes MTU information for this interface
};

// Type for list of network interfaces
typedef CTypedPtrList<CPtrList, CNetworkInterface*> CNetworkInterfacesList;


```

`examples/legacy/MSVC/snat/iphlp.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2009 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/* Module Name:  iphlp.h				                                 */
/*                                                                       */
/* Abstract: IP helper definitions			        	                 */
/*                                                                       */
/*                                                                       */
/*************************************************************************/

#ifndef __IPHLP_H__
#define __IPHLP_H__

#pragma pack(1) 

///////////////////////////////////////////////////////////////////////////
// packet structures
///////////////////////////////////////////////////////////////////////////
typedef long n_long;
typedef short n_short;
typedef long n_time;
typedef unsigned short u_short;
typedef unsigned long u_long;
typedef unsigned char u_char;
typedef struct in_addr IN_ADDR, *PIN_ADDR;

#define ETHER_HEADER_LENGTH		14
#define ETH_ALEN		6		/* Octets in one ethernet addr	 */
#define ETH_P_ARP		0x0806	/* Address Resolution packet	*/
#define ARPHRD_ETHER	0x01
#define ARPOP_REQUEST	0x01
#define ARPOP_REPLY		0x02

#define ETH_P_IP		0x0800	/* Internet Protocol packet	*/
#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
#define ETH_P_ARP		0x0806		/* Address Resolution packet	*/

/*
 * Protocols
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_IGMP            2               /* group management protocol */
#define IPPROTO_GGP             3               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256


// Ethernet Header
typedef struct ether_header 
{
	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
	unsigned short	h_proto;		/* packet type ID field	*/
} ether_header, *ether_header_ptr;

typedef struct arphdr
{
	unsigned short	ar_hrd;		/* format of hardware address	*/
	unsigned short	ar_pro;		/* format of protocol address	*/
	unsigned char	ar_hln;		/* length of hardware address	*/
	unsigned char	ar_pln;		/* length of protocol address	*/
	unsigned short	ar_op;		/* ARP opcode (command)		*/
} arphdr, *arphdr_ptr;

typedef struct	ether_arp 
{
	struct	arphdr ea_hdr;	/* fixed-size header */
	u_char	arp_sha[ETH_ALEN];	/* sender hardware address */
	u_char	arp_spa[4];	/* sender protocol address */
	u_char	arp_tha[ETH_ALEN];	/* target hardware address */
	u_char	arp_tpa[4];	/* target protocol address */
} ether_arp, *ether_arp_ptr;

#define	arp_hrd	ea_hdr.ar_hrd
#define	arp_pro	ea_hdr.ar_pro
#define	arp_hln	ea_hdr.ar_hln
#define	arp_pln	ea_hdr.ar_pln
#define	arp_op	ea_hdr.ar_op

/* IP Header in Little Endian */
typedef struct iphdr 
{
	u_char	ip_hl:4,		/* header length */
			ip_v:4;			/* version */
	u_char	ip_tos;			/* type of service */
	short	ip_len;			/* total length */
	u_short	ip_id;			/* identification */
	short	ip_off;			/* fragment offset field */
#define	IP_DF 0x4000		/* dont fragment flag */
#define	IP_MF 0x2000		/* more fragments flag */
	u_char	ip_ttl;			/* time to live */
	u_char	ip_p;			/* protocol */
	u_short	ip_sum;			/* checksum */
	struct	in_addr ip_src,ip_dst;	/* source and dest address */
} iphdr, *iphdr_ptr;
/////////////////////////////////////////////////////////////////////////
/* UDP header  */
typedef struct	udphdr
{
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	u_short	length;			/* data length */
	u_short	th_sum;			/* checksum */
} udphdr, *udphdr_ptr;
/////////////////////////////////////////////////////////////////////////
typedef	u_long	tcp_seq;

// TCP header. Per RFC 793, September, 1981. In Little Endian
typedef struct tcphdr {
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	tcp_seq	th_seq;			/* sequence number */
	tcp_seq	th_ack;			/* acknowledgement number */
	u_char	th_x2:4,		/* (unused) */
		    th_off:4;		/* data offset */
#define TCP_NO_OPTIONS	0x05
	u_char	th_flags;
#define	TH_FIN	0x01
#define	TH_SYN	0x02
#define	TH_RST	0x04
#define	TH_PSH	0x08
#define	TH_ACK	0x10
#define	TH_URG	0x20
	u_short	th_win;			/* window */
	u_short	th_sum;			/* checksum */
	u_short	th_urp;			/* urgent pointer */
} tcphdr, *tcphdr_ptr;

typedef struct mss_tcp_options {
#define	MSS_TYPE	0x02
#define	SACK_TYPE	0x04
	u_char  mss_type;
	u_char  mss_option_length;
	u_short mss_value;
	/*u_char  no_options0;
	u_char  no_options1;
	u_char	sack_permitted;
	u_char	sack_permitted_length;*/
}mss_tcp_options, *mss_tcp_options_ptr;

typedef struct pseudo_header
{
  struct in_addr source_address;
  struct in_addr dest_address;
  unsigned char placeholder;
  unsigned char protocol;
  unsigned short tcp_length;

}pseudo_header, *pseudo_header_ptr;

// ICMP header
typedef struct icmphdr {
    unsigned char type;          // ICMP packet type
    unsigned char code;          // Type sub code
    unsigned short checksum;
    unsigned short id;
    unsigned short seq;
}icmphdr, *icmphdr_ptr;

#pragma pack()

#endif // __IPHLP_H__
```

`examples/legacy/MSVC/snat/res/snat.manifest`:

```manifest
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0"> 
<assemblyIdentity 
    version="1.0.0.0" 
    processorArchitecture="X86" 
    name="Microsoft.Windows.snat"
    type="win32" 
/> 
<description>Your app description here</description> 
<dependency> 
    <dependentAssembly> 
        <assemblyIdentity 
            type="win32" 
            name="Microsoft.Windows.Common-Controls" 
            version="6.0.0.0" 
            processorArchitecture="X86" 
            publicKeyToken="6595b64144ccf1df" 
            language="*" 
        /> 
    </dependentAssembly> 
</dependency> 
</assembly>

```

`examples/legacy/MSVC/snat/res/snat.rc2`:

```rc2
//
// snat.RC2 - resources Microsoft Visual C++ does not edit directly
//

#ifdef APSTUDIO_INVOKED
#error this file is not editable by Microsoft Visual C++
#endif //APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
// Add manually edited resources here...

/////////////////////////////////////////////////////////////////////////////

```

`examples/legacy/MSVC/snat/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by snat.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_SNAT_DIALOG                 102
#define IDR_MAINFRAME                   128
#define IDI_NETCARD                     129
#define IDI_MODEM                       130
#define IDD_INTERFACE_PROPERTIES        131
#define IDC_ADAPTERS                    1000
#define IDC_NETCARD                     1001
#define IDC_MACADDR                     1002
#define IDC_INTNAME                     1003
#define IDC_LIST1                       1004
#define IDC_LISTIP                      1004
#define IDC_IPADDRESSNAT                1005
#define IDC_COMBONAT                    1007
#define IDC_BUTTONSTART                 1008
#define IDC_STATICIP                    1010
#define IDC_CHECK_DNS                   1012
#define IDC_IPADDRESSDNS                1014
#define IDC_STATIC_DNS                  1015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        136
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1016
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`examples/legacy/MSVC/snat/snat.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2016 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/* Module Name:  snat.h					                                 */
/*                                                                       */
/* Abstract: main header file for the SNAT application 	                 */
/*                                                                       */
/*                                                                       */
/*************************************************************************/

#pragma once

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols


// CsnatApp:
// See snat.cpp for the implementation of this class
//

class CsnatApp : public CWinApp
{
public:
	CsnatApp();

// Overrides
	public:
	virtual BOOL InitInstance();

// Implementation

	DECLARE_MESSAGE_MAP()
};

extern CsnatApp theApp;
```

`examples/legacy/MSVC/snat/snat.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "afxres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Russian (Russia) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_RUS)
LANGUAGE LANG_RUSSIAN, SUBLANG_DEFAULT
#pragma code_page(1251)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""afxres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "#define _AFX_NO_SPLITTER_RESOURCES\r\n"
    "#define _AFX_NO_OLE_RESOURCES\r\n"
    "#define _AFX_NO_TRACKER_RESOURCES\r\n"
    "#define _AFX_NO_PROPERTY_RESOURCES\r\n"
    "\r\n"
    "#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)\r\n"
    "LANGUAGE 9, 1\r\n"
    "#pragma code_page(1252)\r\n"
    "#include ""res\\snat.rc2""  // non-Microsoft Visual C++ edited resources\r\n"
    "#include ""afxres.rc""         // Standard components\r\n"
    "#endif\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // Russian (Russia) resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// Neutral resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_NEU)
LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
#pragma code_page(1252)

/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDR_MAINFRAME           ICON                    "res\\main.ico"
IDI_NETCARD             ICON                    "res\\netcard.ico"
IDI_MODEM               ICON                    "res\\modem.ico"

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_INTERFACE_PROPERTIES DIALOGEX 0, 0, 275, 202
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Dialog"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    DEFPUSHBUTTON   "OK",IDOK,218,181,50,14
    PUSHBUTTON      "Cancel",IDCANCEL,7,181,50,14
    LTEXT           "MAC address:",IDC_NETCARD,7,19,51,8
    LTEXT           "Static",IDC_MACADDR,76,19,192,8
    LTEXT           "Internal Name:",IDC_STATIC,7,7,57,8
    LTEXT           "Static",IDC_INTNAME,76,7,192,8
    GROUPBOX        "IP addresses",IDC_STATIC,7,37,261,72
    CONTROL         "",IDC_LISTIP,"SysListView32",LVS_REPORT | LVS_ALIGNLEFT | WS_BORDER | WS_TABSTOP,7,49,261,59
    CONTROL         "",IDC_IPADDRESSNAT,"SysIPAddress32",NOT WS_VISIBLE | WS_DISABLED | WS_TABSTOP,76,130,100,15
    LTEXT           "IP address for NAT",IDC_STATICIP,7,135,62,8,NOT WS_VISIBLE
    COMBOBOX        IDC_COMBONAT,76,113,102,59,CBS_DROPDOWNLIST | CBS_SORT | WS_VSCROLL | WS_TABSTOP
    LTEXT           "NAT Status",IDC_STATIC,7,115,48,10
    CONTROL         "Use Client DNS",IDC_CHECK_DNS,"Button",BS_AUTOCHECKBOX | NOT WS_VISIBLE | WS_TABSTOP,189,153,68,10
    CONTROL         "",IDC_IPADDRESSDNS,"SysIPAddress32",NOT WS_VISIBLE | WS_TABSTOP,76,149,100,15
    LTEXT           "DNS for NAT",IDC_STATIC_DNS,7,154,58,8,NOT WS_VISIBLE
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_INTERFACE_PROPERTIES, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 268
        VERTGUIDE, 76
        VERTGUIDE, 176
        TOPMARGIN, 7
        BOTTOMMARGIN, 195
        HORZGUIDE, 14
        HORZGUIDE, 27
        HORZGUIDE, 125
        HORZGUIDE, 130
        HORZGUIDE, 143
        HORZGUIDE, 163
    END
END
#endif    // APSTUDIO_INVOKED

#endif    // Neutral resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_ABOUTBOX DIALOGEX 0, 0, 235, 55
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION " NT Kernel Resources Internet Gateway"
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    ICON            IDR_MAINFRAME,IDC_STATIC,11,17,20,20
    LTEXT           "Internet Gateway Version 1.0",IDC_STATIC,40,10,119,8,SS_NOPREFIX
    LTEXT           "Copyright NT Kernel Resources (C) 2005",IDC_STATIC,40,25,149,8
    DEFPUSHBUTTON   "OK",IDOK,178,7,50,16,WS_GROUP
END

IDD_SNAT_DIALOG DIALOGEX 0, 0, 320, 194
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
EXSTYLE WS_EX_APPWINDOW
CAPTION "snat"
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    CONTROL         "",IDC_ADAPTERS,"SysListView32",LVS_REPORT | LVS_SORTASCENDING | LVS_AUTOARRANGE | LVS_ALIGNLEFT | WS_BORDER | WS_TABSTOP,7,7,306,150
    PUSHBUTTON      "Start NAT",IDC_BUTTONSTART,7,173,306,14,WS_DISABLED
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_ABOUTBOX, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 228
        TOPMARGIN, 7
        BOTTOMMARGIN, 48
    END

    IDD_SNAT_DIALOG, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 313
        TOPMARGIN, 7
        BOTTOMMARGIN, 187
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,2,0,1
 PRODUCTVERSION 1,2,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x4L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "000004e4"
        BEGIN
            VALUE "CompanyName", "NT Kernel Resources"
            VALUE "FileDescription", "Simple NAT application"
            VALUE "FileVersion", "1.2.0.1"
            VALUE "InternalName", "snat.exe"
            VALUE "LegalCopyright", "Copyright (c) 2000-2017 NT Kernel Resources.  All rights reserved."
            VALUE "OriginalFilename", "snat.exe"
            VALUE "ProductName", "Internet Gateway"
            VALUE "ProductVersion", "1.2.0.1"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0, 1252
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE
BEGIN
    IDS_ABOUTBOX            "&About snat..."
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define _AFX_NO_SPLITTER_RESOURCES
#define _AFX_NO_OLE_RESOURCES
#define _AFX_NO_TRACKER_RESOURCES
#define _AFX_NO_PROPERTY_RESOURCES

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE 9, 1
#pragma code_page(1252)
#include "res\snat.rc2"  // non-Microsoft Visual C++ edited resources
#include "afxres.rc"         // Standard components
#endif

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`examples/legacy/MSVC/snat/snat.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{34EEFA7A-7669-44F7-83B0-838B9CE25F70}</ProjectGuid>
    <RootNamespace>snat</RootNamespace>
    <Keyword>MFCProj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>Static</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>Static</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>Static</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>Static</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>11.0.50727.1</_ProjectFileVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>..\bin\i386\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>..\bin\amd64\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Midl>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MkTypLibCompatible>false</MkTypLibCompatible>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>true</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;iphlpapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>true</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>iphlpapi.lib;$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Midl>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MkTypLibCompatible>false</MkTypLibCompatible>
    </Midl>
    <ClCompile>
      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;iphlpapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>iphlpapi.lib;$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="NetcardProp.cpp" />
    <ClCompile Include="NetworkInterface.cpp" />
    <ClCompile Include="snat.cpp" />
    <ClCompile Include="snatDlg.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="NetcardProp.h" />
    <ClInclude Include="NetworkInterface.h" />
    <ClInclude Include="Resource.h" />
    <ClInclude Include="snat.h" />
    <ClInclude Include="snatDlg.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="res\idr_main.ico" />
    <Image Include="res\main.ico" />
    <Image Include="res\modem.ico" />
    <Image Include="res\netcard.ico" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="snat.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include="res\snat.rc2" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
  <ProjectExtensions>
    <VisualStudio>
      <UserProperties RESOURCE_FILE="snat.rc" />
    </VisualStudio>
  </ProjectExtensions>
</Project>
```

`examples/legacy/MSVC/snat/snat.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="NetcardProp.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="NetworkInterface.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="snat.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="snatDlg.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="NetcardProp.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="NetworkInterface.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="snat.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="snatDlg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Image Include="res\idr_main.ico">
      <Filter>Resource Files</Filter>
    </Image>
    <Image Include="res\main.ico">
      <Filter>Resource Files</Filter>
    </Image>
    <Image Include="res\modem.ico">
      <Filter>Resource Files</Filter>
    </Image>
    <Image Include="res\netcard.ico">
      <Filter>Resource Files</Filter>
    </Image>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="snat.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="res\snat.rc2">
      <Filter>Resource Files</Filter>
    </None>
  </ItemGroup>
</Project>
```

`examples/legacy/MSVC/snat/snatDlg.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2016 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/* Module Name:  snatDlg.h				                                 */
/*                                                                       */
/* Abstract: CsnatDlg dialog and NAT tables declarations                 */
/*                                                                       */
/*                                                                       */
/*************************************************************************/

#pragma once
#include "afxcmn.h"
#include "NetworkInterface.h"
#include "netcardprop.h"
#include "ipexport.h"
#include "iphlp.h"

#define NAT_TABLE_SIZE 256*256 // Size of NAT table
#define NAT_TIMEOUT 600 //This is timeout in seconds for which we keep the inactive entry in the NAT table until removal (10 minutes)
#define MAX_STRING 512
// CNATEntry describes single NAT entry
struct CNATEntry
{
	CNATEntry();
	in_addr			m_IpSrc;	// Source IP address
	in_addr			m_IpDst;	// Destination IP address
	in_addr			m_IpNAT;	// IP for NAT

	ULARGE_INTEGER	m_ulTimeStamp; // Last packet this entry was applied to
 
	CNATEntry*		prevEntry; // Previous NAT entry
	CNATEntry*		nextEntry; // Next NAT entry
};

// Describes single UDP/TCP NAT entry
struct CPortNATEntry: public CNATEntry
{
	CPortNATEntry();
	unsigned short m_usSrcPort; // Source port address
	unsigned short m_usDstPort; // Destination port address
	unsigned short m_usNATPort; // Port for NAT
};

// TCP/UDP NAT table
class CPortNATTable
{
	// Hash table for TCP connections
	CPortNATEntry**		m_Table; // Used for allocating and searching NAT entries for outgoing packets
	CPortNATEntry**		m_PortTable; // Used for mapping incoming packets to NAT entries
public:
	CPortNATTable ();
	~CPortNATTable ();

	// Outgoing NAT methods
	CPortNATEntry* Allocate (in_addr ip_src, unsigned short port_src, in_addr ip_dst, unsigned short port_dst);
	CPortNATEntry* Find (in_addr ip_src, unsigned short port_src, in_addr ip_dst, unsigned short port_dst);

	// Incoming NAT methods
	CPortNATEntry* Map (unsigned short port_dst);

	// Deleting entries methods
	void Free(CPortNATEntry* pNE);
	void RemoveAll();
};

// Describes single ICMP NAT entry
struct CIcmpNATEntry: public CNATEntry
{
	CIcmpNATEntry();
	unsigned short m_usIcmpId;		// Original ICMP ID
	unsigned short m_usNATIcmpId;	// NAT ICMP ID
};

// ICMP NAT table
class CIcmpNATTable
{
	// Hash table for TCP connections
	CIcmpNATEntry**		m_Table; // Used for allocating and searching NAT entries for outgoing packets
	CIcmpNATEntry**		m_PortTable; // Used for mapping incoming packets to NAT entries
public:
	CIcmpNATTable ();
	~CIcmpNATTable ();

	// Outgoing NAT methods
	CIcmpNATEntry* Allocate (in_addr ip_src, in_addr ip_dst, unsigned short icmp_id);
	CIcmpNATEntry* Find (in_addr ip_src, in_addr ip_dst, unsigned short icmp_id);

	// Incoming NAT methods
	CIcmpNATEntry* Map (unsigned short icmp_id);

	// Deleting entries methods
	void Free(CIcmpNATEntry* pNE);
	void RemoveAll();
};

// CsnatDlg dialog
class CsnatDlg : public CDialog
{
	OVERLAPPED	m_ovlp;
	HANDLE		m_hRoutingEvent_;
// Construction
public:
	CsnatDlg(CWnd* pParent = NULL);	// standard constructor
	~CsnatDlg();

// Dialog Data
	enum { IDD = IDD_SNAT_DIALOG };

protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support


// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	DECLARE_MESSAGE_MAP()
public:
	CListCtrl	m_AdaptersList; // List control for network adapters
	CImageList* m_pImageList;	// Image list for m_AdaptersList
	CNdisApi	m_NdisApi;		// API object for communicating with WinpkFilter driver
private:
	int InitAdapterList(void);	// Initializes network interfaces list

	TCP_AdapterList m_AdList; // Adapters list structure filled by WinpkFilter driver
public:
	CNetworkInterfacesList		m_NetCardsList; // Network interfaces list
	CNetcardProp				m_NetcardProp;	// Netcard properties dialog
	unsigned int				m_dwAdapterCount; // Number of found adapters
	HANDLE						m_hNATThread;	// Packet processing thread handle
	HANDLE						m_hNATTerminateEvent; // This event is used for signalling packet processing thread termination
	CPortNATTable				m_TcpNatTable; // TCP NAT table
	CPortNATTable				m_UdpNatTable; // UDP NAT table
	CIcmpNATTable				m_IcmpNatTable; // ICMP NAT table
	in_addr						m_DNSIp; // DNS server IP address

	USHORT						m_ProviderMTU; // MTU of Provider interface
	USHORT						m_ClientMTU; //MTU of client interface
	
	BOOL						m_ForceRouting; //TRUE if Windows 7 or higher is used in case with WAN provider interface

	int InitializeAdapters(void);	// Initializes list of network adapters
	int	GetDNSIp(void);				// Uses IP helper API to obtain DNS IP address
	int UpdateDNSByIp(int nIp); //Uses registry search to obtain DNS corresponded with ip address of provider interface
	
	BOOL IsNeedToForceRouting(BYTE *MACAddress, DWORD dwDestIp, DWORD dwProviderIndex);

	void CheckMTUCorrelation(PINTERMEDIATE_BUFFER pBuffer, iphdr_ptr pIpHeader, tcphdr_ptr pTcpHeader);
	
	BOOL IsAddressExternal(int nDestIpAddress); 
	
	static unsigned __stdcall StartNAT ( void* pArguments ); // Main packet processing thread

	afx_msg void OnNMDblclkAdapters(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnBnClickedButtonstart();
public:
	afx_msg void OnClose();
};

```

`examples/legacy/MSVC/snat/stdafx.h`:

```h

// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently,
// but are changed infrequently

#pragma once

#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN            // Exclude rarely-used stuff from Windows headers
#endif

#include "targetver.h"

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS      // some CString constructors will be explicit

// turns off MFC's hiding of some common and often safely ignored warning messages
#define _AFX_ALL_WARNINGS

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions


#include <afxdisp.h>        // MFC Automation classes



#ifndef _AFX_NO_OLE_SUPPORT
#include <afxdtctl.h>           // MFC support for Internet Explorer 4 Common Controls
#endif
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>             // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxcontrolbars.h>     // MFC support for ribbons and control bars


#include <winsock2.h>

#include <iphlpapi.h>

#include "..\..\..\..\include\common.h"
#include "..\..\..\..\include\ndisapi.h"

#ifdef _UNICODE
#if defined _M_IX86
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\"")
#elif defined _M_X64
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\"")
#else
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
#endif
#endif



```

`examples/legacy/MSVC/snat/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

//#include <WinSDKVer.h>

#define _WIN32_WINNT 0x4000

#include <SDKDDKVer.h>

```

`examples/legacy/MSVC/wwwcensor/StdAfx.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2016 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/*                                                                       */
/* Module Name:  stdafx.h                                                */
/*                                                                       */
/* Abstract: include file for standard system include files,             */
/*  or project specific include files that are used frequently, but      */
/*  are changed infrequently                                             */
/*                                                                       */
/*************************************************************************/

#if !defined(AFX_STDAFX_H__8CD24513_169B_47A9_859B_9A99FF8266DA__INCLUDED_)
#define AFX_STDAFX_H__8CD24513_169B_47A9_859B_9A99FF8266DA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif // WIN32_LEAN_AND_MEAN

#define _CRT_SECURE_NO_WARNINGS

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <iphlpapi.h>

#include "..\..\..\..\include\common.h"
#include "..\..\..\..\include\ndisapi.h"
#include "iphlp.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8CD24513_169B_47A9_859B_9A99FF8266DA__INCLUDED_)

```

`examples/legacy/MSVC/wwwcensor/iphlp.h`:

```h
/*************************************************************************/
/*				Copyright (c) 2000-2016 NT Kernel Resources.		     */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/* Module Name:  iphlp.h				                                 */
/*                                                                       */
/* Abstract: IP helper definitions			        	                 */
/*                                                                       */
/*                                                                       */
/*************************************************************************/

#ifndef __IPHLP_H__
#define __IPHLP_H__

#pragma pack(1) 

///////////////////////////////////////////////////////////////////////////
// packet structures
///////////////////////////////////////////////////////////////////////////
typedef long n_long;
typedef short n_short;
typedef long n_time;
typedef unsigned short u_short;
typedef unsigned long u_long;
typedef unsigned char u_char;
typedef struct in_addr IN_ADDR, *PIN_ADDR;

#define ETH_ALEN		6		/* Octets in one ethernet addr	 */
#define ETH_P_ARP		0x0806	/* Address Resolution packet	*/
#define ARPHRD_ETHER	0x01
#define ARPOP_REQUEST	0x01
#define ARPOP_REPLY		0x02

#define ETH_P_IP		0x0800	/* Internet Protocol packet	*/
#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
#define ETH_P_ARP		0x0806		/* Address Resolution packet	*/

/*
 * Protocols
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_IGMP            2               /* group management protocol */
#define IPPROTO_GGP             3               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

// Ethernet Header
typedef struct ether_header 
{
	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
	unsigned short	h_proto;		/* packet type ID field	*/
} ether_header, *ether_header_ptr;

typedef struct arphdr
{
	unsigned short	ar_hrd;		/* format of hardware address	*/
	unsigned short	ar_pro;		/* format of protocol address	*/
	unsigned char	ar_hln;		/* length of hardware address	*/
	unsigned char	ar_pln;		/* length of protocol address	*/
	unsigned short	ar_op;		/* ARP opcode (command)		*/
} arphdr, *arphdr_ptr;

typedef struct	ether_arp 
{
	struct	arphdr ea_hdr;	/* fixed-size header */
	u_char	arp_sha[ETH_ALEN];	/* sender hardware address */
	u_char	arp_spa[4];	/* sender protocol address */
	u_char	arp_tha[ETH_ALEN];	/* target hardware address */
	u_char	arp_tpa[4];	/* target protocol address */
} ether_arp, *ether_arp_ptr;

#define	arp_hrd	ea_hdr.ar_hrd
#define	arp_pro	ea_hdr.ar_pro
#define	arp_hln	ea_hdr.ar_hln
#define	arp_pln	ea_hdr.ar_pln
#define	arp_op	ea_hdr.ar_op

/* IP Header in Little Endian */
typedef struct iphdr 
{
	u_char	ip_hl:4,		/* header length */
			ip_v:4;			/* version */
	u_char	ip_tos;			/* type of service */
	short	ip_len;			/* total length */
	u_short	ip_id;			/* identification */
	short	ip_off;			/* fragment offset field */
#define	IP_DF 0x4000		/* dont fragment flag */
#define	IP_MF 0x2000		/* more fragments flag */
	u_char	ip_ttl;			/* time to live */
	u_char	ip_p;			/* protocol */
	u_short	ip_sum;			/* checksum */
	struct	in_addr ip_src,ip_dst;	/* source and dest address */
} iphdr, *iphdr_ptr;
/////////////////////////////////////////////////////////////////////////
/* UDP header  */
typedef struct	udphdr
{
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	u_short	length;			/* data length */
	u_short	th_sum;			/* checksum */
} udphdr, *udphdr_ptr;
/////////////////////////////////////////////////////////////////////////
typedef	u_long	tcp_seq;

// TCP header. Per RFC 793, September, 1981. In Little Endian
typedef struct tcphdr {
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	tcp_seq	th_seq;			/* sequence number */
	tcp_seq	th_ack;			/* acknowledgement number */
	u_char	th_x2:4,		/* (unused) */
		    th_off:4;		/* data offset */
	u_char	th_flags;
#define	TH_FIN	0x01
#define	TH_SYN	0x02
#define	TH_RST	0x04
#define	TH_PSH	0x08
#define	TH_ACK	0x10
#define	TH_URG	0x20
	u_short	th_win;			/* window */
	u_short	th_sum;			/* checksum */
	u_short	th_urp;			/* urgent pointer */
} tcphdr, *tcphdr_ptr;

typedef struct pseudo_header
{
  struct in_addr source_address;
  struct in_addr dest_address;
  unsigned char placeholder;
  unsigned char protocol;
  unsigned short tcp_length;

}pseudo_header, *pseudo_header_ptr;

#pragma pack()

#endif // __IPHLP_H__
```

`examples/legacy/MSVC/wwwcensor/wwwcensor.dsp`:

```dsp
# Microsoft Developer Studio Project File - Name="wwwcensor" - Package Owner=<4>
# Microsoft Developer Studio Generated Build File, Format Version 6.00
# ** DO NOT EDIT **

# TARGTYPE "Win32 (x86) Console Application" 0x0103

CFG=wwwcensor - Win32 Release
!MESSAGE This is not a valid makefile. To build this project using NMAKE,
!MESSAGE use the Export Makefile command and run
!MESSAGE 
!MESSAGE NMAKE /f "wwwcensor.mak".
!MESSAGE 
!MESSAGE You can specify a configuration when running NMAKE
!MESSAGE by defining the macro CFG on the command line. For example:
!MESSAGE 
!MESSAGE NMAKE /f "wwwcensor.mak" CFG="wwwcensor - Win32 Release"
!MESSAGE 
!MESSAGE Possible choices for configuration are:
!MESSAGE 
!MESSAGE "wwwcensor - Win32 Release" (based on "Win32 (x86) Console Application")
!MESSAGE "wwwcensor - Win32 Debug" (based on "Win32 (x86) Console Application")
!MESSAGE 

# Begin Project
# PROP AllowPerConfigDependencies 0
# PROP Scc_ProjName ""
# PROP Scc_LocalPath ""
CPP=cl.exe
RSC=rc.exe

!IF  "$(CFG)" == "wwwcensor - Win32 Release"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 0
# PROP BASE Output_Dir "Release"
# PROP BASE Intermediate_Dir "Release"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 0
# PROP Output_Dir "Release"
# PROP Intermediate_Dir "Release"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /c
# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /FR /Yu"stdafx.h" /FD /c
# ADD BASE RSC /l 0x419 /d "NDEBUG"
# ADD RSC /l 0x409 /d "NDEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ndisapi.lib /nologo /subsystem:console /machine:I386 /out:"../bin/vc6/wwwcensor.exe" /libpath:"..\..\..\..\bin\dll.vc6\i386"

!ELSEIF  "$(CFG)" == "wwwcensor - Win32 Debug"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 1
# PROP BASE Output_Dir "Debug"
# PROP BASE Intermediate_Dir "Debug"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 1
# PROP Output_Dir "Debug"
# PROP Intermediate_Dir "Debug"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
# ADD BASE RSC /l 0x419 /d "_DEBUG"
# ADD RSC /l 0x409 /d "_DEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ndisapi.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept /libpath:"..\..\..\..\bin\dll.vc6\i386"

!ENDIF 

# Begin Target

# Name "wwwcensor - Win32 Release"
# Name "wwwcensor - Win32 Debug"
# Begin Group "Source Files"

# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
# Begin Source File

SOURCE=.\StdAfx.cpp
# ADD CPP /Yc"stdafx.h"
# End Source File
# Begin Source File

SOURCE=.\wwwcensor.cpp
# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl"
# Begin Source File

SOURCE=.\iphlp.h
# End Source File
# Begin Source File

SOURCE=.\StdAfx.h
# End Source File
# End Group
# Begin Group "Resource Files"

# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
# End Group
# End Target
# End Project

```

`examples/legacy/MSVC/wwwcensor/wwwcensor.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{1305B673-0D79-400C-AFC2-9B2FA9105EA8}</ProjectGuid>
    <RootNamespace>wwwcensor</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>11.0.50727.1</_ProjectFileVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>..\bin\i386\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>..\bin\amd64\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Midl>
      <TypeLibraryName>.\Release/wwwcensor.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <BrowseInformation>true</BrowseInformation>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>.\Release/wwwcensor.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>.\Release/</AssemblerListingLocation>
      <ObjectFileName>.\Release/</ObjectFileName>
      <ProgramDataBaseFileName>.\Release/</ProgramDataBaseFileName>
      <BrowseInformation>true</BrowseInformation>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Midl>
      <TypeLibraryName>.\Debug/wwwcensor.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\i386\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>.\Debug/wwwcensor.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName).pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>.\Debug/</AssemblerListingLocation>
      <ObjectFileName>.\Debug/</ObjectFileName>
      <ProgramDataBaseFileName>.\Debug/</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>$(SolutionDir)\bin\dll.vs2012\amd64\ndisapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)$(TargetName).pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="StdAfx.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">EnableFastChecks</BasicRuntimeChecks>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">MaxSpeed</Optimization>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</BrowseInformation>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</BrowseInformation>
    </ClCompile>
    <ClCompile Include="wwwcensor.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">EnableFastChecks</BasicRuntimeChecks>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Disabled</Optimization>
      <BasicRuntimeChecks Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">EnableFastChecks</BasicRuntimeChecks>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">MaxSpeed</Optimization>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</BrowseInformation>
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MaxSpeed</Optimization>
      <BrowseInformation Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</BrowseInformation>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="iphlp.h" />
    <ClInclude Include="StdAfx.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/legacy/MSVC/wwwcensor/wwwcensor.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{a776016f-b729-452e-8acd-bef74d949601}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{bc987f04-ce8b-4714-b97c-4fc083c4fe95}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{8f8c7378-af83-4964-b208-0c7d25665ca7}</UniqueIdentifier>
      <Extensions>ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="StdAfx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="wwwcensor.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="iphlp.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="StdAfx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`include/Common.h`:

```h
/**************************************************************************/
/*                   Copyright (c) 2000-2024 NT KERNEL.                   */
/*                           All Rights Reserved.                         */
/*                          https://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                          */
/*                                                                        */
/* Module Name:  common.h                                                 */
/*                                                                        */
/* Abstract: Definitions common to kernel-mode driver and Win32 app.      */
/*                                                                        */
/* Environment:                                                           */
/*   User mode, Kernel mode                                               */
/*                                                                        */
/* Description: This header file contains definitions and data structures */
/*              that are common to both the kernel-mode driver and the    */
/*              Win32 application. This includes constants, structure     */
/*              definitions, and function prototypes.                     */
/*                                                                        */
/**************************************************************************/

#ifndef COMMON_H
#define COMMON_H

#ifdef _WINDOWS
#include <WinIoctl.h>   // Compiling Win32 Applications Or DLL's
#endif // _WINDOWS

// The following definitions are used to customize the driver build
// In you would like to redefine these for the custom build do that in the user_settings.h file
#ifdef USER_NAMES
#include "user_settings.h"
#else

// Define NDISRD name once in both ASCII and Unicode formats
#define NDISRD_NAME_A "NDISRD"
#define NDISRD_NAME_U L"NDISRD"

// Define lowercase NDISRD name for registry paths
#define NDISRD_NAME_LOWER_A "ndisrd"
#define NDISRD_NAME_LOWER_U L"ndisrd"

// FILTER_FRIENDLY_NAME is the friendly name of the NDISRD filter
#define FILTER_FRIENDLY_NAME L"WinpkFilter NDIS LightWeight Filter"

// FILTER_UNIQUE_NAME is the unique name (GUID) of the NDISRD filter
#define FILTER_UNIQUE_NAME L"{CD75C963-E19F-4139-BC3B-14019EF72F19}"

#endif // USER_NAMES

#ifndef ANY_SIZE
#define ANY_SIZE 1
#endif

// NDISRD_VERSION is the version number of the NDISRD driver
#define NDISRD_VERSION             0x06013000

// NDISRD_MAJOR_VERSION is the major version number of the NDISRD driver
#define NDISRD_MAJOR_VERSION       0x0003

// NDISRD_MINOR_VERSION is the minor version number of the NDISRD driver
#define NDISRD_MINOR_VERSION       0x0601

// DRIVER_NAME_A is the ASCII name of the NDISRD driver
#define DRIVER_NAME_A NDISRD_NAME_A

// DRIVER_NAME_U is the Unicode name of the NDISRD driver
#define DRIVER_NAME_U NDISRD_NAME_U

// DEVICE_NAME is the device name of the NDISRD driver in the device namespace
#define DEVICE_PREFIX L"\\Device\\"
#define DEVICE_NAME DEVICE_PREFIX NDISRD_NAME_U

// SYMLINK_NAME is the symbolic link name of the NDISRD driver in the DOS namespace
#define SYMLINK_PREFIX L"\\DosDevices\\"
#define SYMLINK_NAME SYMLINK_PREFIX NDISRD_NAME_U

// WIN9X_REG_PARAM is the registry path for the NDISRD driver parameters on Windows 9x systems
#define WIN9X_REG_BASE "System\\CurrentControlSet\\Services\\VxD\\"
#define WIN9X_REG_PARAM WIN9X_REG_BASE NDISRD_NAME_LOWER_A "\\Parameters"

// WINNT_REG_PARAM is the registry path for the NDISRD driver parameters on Windows NT systems
#define WINNT_REG_BASE TEXT("SYSTEM\\CurrentControlSet\\Services\\")
#define WINNT_REG_PARAM WINNT_REG_BASE TEXT(NDISRD_NAME_LOWER_A) TEXT("\\Parameters")

// FILTER_SERVICE_NAME is the service name of the NDISRD filter
#define FILTER_SERVICE_NAME NDISRD_NAME_U

// Some size constants
#define ADAPTER_NAME_SIZE          256 // Maximum size of the adapter name
#define ADAPTER_LIST_SIZE          32  // Maximum number of adapters in the list
#define ETHER_ADDR_LENGTH          6   // Length of the Ethernet address

#ifdef JUMBO_FRAME_SUPPORTED
#define MAX_ETHER_FRAME            9014 // Maximum size of the Ethernet frame when Jumbo Frames are supported
#else
#define MAX_ETHER_FRAME            1514 // Maximum size of the Ethernet frame when Jumbo Frames are not supported
#endif 

// Adapter flags
#define MSTCP_FLAG_SENT_TUNNEL     0x00000001 // Flag to receive packets sent by MSTCP
#define MSTCP_FLAG_RECV_TUNNEL     0x00000002 // Flag to receive packets instead of MSTCP
#define MSTCP_FLAG_SENT_LISTEN     0x00000004 // Flag to receive packets sent by MSTCP, original ones delivered to the network
#define MSTCP_FLAG_RECV_LISTEN     0x00000008 // Flag to receive packets received by MSTCP

#define MSTCP_FLAG_FILTER_DIRECT   0x00000010 // Flag to filter packets in promiscuous mode. 
                                              // In promiscuous mode, TCP/IP stack receives all packets in the ethernet segment. 
                                              // To prevent this, set this flag. 
                                              // All packets with destination MAC different from FF-FF-FF-FF-FF-FF and
                                              // network interface current MAC will be blocked

// By default, loopback packets are passed to original MSTCP handlers without processing.
// To change this behavior, use the flags below
#define MSTCP_FLAG_LOOPBACK_FILTER 0x00000020 // Flag to pass loopback packet for processing 
#define MSTCP_FLAG_LOOPBACK_BLOCK  0x00000040 // Flag to silently drop loopback packets. 
                                              // This flag is recommended for usage in combination with promiscuous mode

// Device flags for intermediate buffer
#define PACKET_FLAG_ON_SEND        0x00000001 // Flag to indicate packet is on send
#define PACKET_FLAG_ON_RECEIVE     0x00000002 // Flag to indicate packet is on receive

// Specify Structure Packing
#pragma pack(push,1)

/**
 * @brief TCP_AdapterList structure is used for requesting information about currently bound TCPIP adapters.
 *
 * @param m_nAdapterCount This field stores the number of adapters.
 * @param m_szAdapterNameList This is an array of adapter names. The size of the array is defined by the ADAPTER_LIST_SIZE constant,
 * and each name is a string of characters with a maximum length defined by the ADAPTER_NAME_SIZE constant.
 * @param m_nAdapterHandle This is an array of adapter handles. These handles are key for any adapter relative operation.
 * @param m_nAdapterMediumList This is a list of adapter mediums. Each medium is represented as an unsigned integer.
 * @param m_czCurrentAddress This is an array of current (configured) Ethernet addresses. Each address is represented as an array of bytes
 * with a length defined by the ETHER_ADDR_LENGTH constant.
 * @param m_usMTU This is an array of the current MTU (Maximum Transmission Unit) for each adapter. Each MTU is represented as an unsigned short.
 */
typedef struct _TCP_AdapterList
{
    DWORD           m_nAdapterCount;
    unsigned char   m_szAdapterNameList[ADAPTER_LIST_SIZE][ADAPTER_NAME_SIZE];
    HANDLE          m_nAdapterHandle[ADAPTER_LIST_SIZE];
    unsigned int    m_nAdapterMediumList[ADAPTER_LIST_SIZE];
    unsigned char   m_czCurrentAddress[ADAPTER_LIST_SIZE][ETHER_ADDR_LENGTH];
    unsigned short  m_usMTU[ADAPTER_LIST_SIZE];
} TCP_AdapterList, * PTCP_AdapterList;

/**
 * @brief TCP_AdapterList_WOW64 structure is similar to TCP_AdapterList, but it's used in a WOW64 environment.
 * WOW64 is a subsystem of the Windows operating system capable of running 32-bit applications and is included on all 64-bit versions of Windows.
 * In the TCP_AdapterList_WOW64 structure, the m_nAdapterHandle field is an array of ULARGE_INTEGER to accommodate the larger pointer size
 * in a 64-bit environment.
 *
 * @param m_nAdapterCount This field stores the number of adapters.
 * @param m_szAdapterNameList This is an array of adapter names. The size of the array is defined by the ADAPTER_LIST_SIZE constant,
 * and each name is a string of characters with a maximum length defined by the ADAPTER_NAME_SIZE constant.
 * @param m_nAdapterHandle This is an array of adapter handles. These handles are key for any adapter relative operation.
 * @param m_nAdapterMediumList This is a list of adapter mediums. Each medium is represented as an unsigned integer.
 * @param m_czCurrentAddress This is an array of current (configured) Ethernet addresses. Each address is represented as an array of bytes
 * with a length defined by the ETHER_ADDR_LENGTH constant.
 * @param m_usMTU This is an array of the current MTU (Maximum Transmission Unit) for each adapter. Each MTU is represented as an unsigned short.
 */
typedef struct _TCP_AdapterList_WOW64
{
    DWORD           m_nAdapterCount;
    unsigned char   m_szAdapterNameList[ADAPTER_LIST_SIZE][ADAPTER_NAME_SIZE];
    ULARGE_INTEGER  m_nAdapterHandle[ADAPTER_LIST_SIZE];
    unsigned int    m_nAdapterMediumList[ADAPTER_LIST_SIZE];
    unsigned char   m_czCurrentAddress[ADAPTER_LIST_SIZE][ETHER_ADDR_LENGTH];
    unsigned short  m_usMTU[ADAPTER_LIST_SIZE];
} TCP_AdapterList_WOW64, * PTCP_AdapterList_WOW64;

/**
 * @brief INTERMEDIATE_BUFFER structure is used for storing packet data and related information.
 *
 * @param m_hAdapter/m_qLink This is a union of two fields. m_hAdapter is a handle to the adapter. m_qLink is a link to the next packet in the queue.
 * @param m_dwDeviceFlags This field stores device-specific flags. These flags can be used to indicate whether the packet is on send or receive.
 * @param m_Length This field stores the length of the packet.
 * @param m_Flags This field stores NDIS_PACKET flags. These flags provide information about the packet, such as whether it's a loopback
 * packet or a broadcast packet.
 * @param m_8021q This field stores 802.1q information. 802.1q is a networking standard that supports virtual LANs (VLANs) on an Ethernet network.
 * @param m_FilterID This field stores the filter ID. This can be used to identify the filter that the packet passed through.
 * @param m_Reserved This field is reserved for future use.
 * @param m_IBuffer This field is a buffer that contains the packet data. The size of the buffer is defined by the MAX_ETHER_FRAME constant.
 */
typedef struct _INTERMEDIATE_BUFFER
{
    union {
        HANDLE          m_hAdapter;
        LIST_ENTRY      m_qLink;
    };
    DWORD               m_dwDeviceFlags;
    DWORD               m_Length;
    DWORD               m_Flags; // NDIS_PACKET flags
    DWORD               m_8021q; // 802.1q info
    DWORD               m_FilterID;
    DWORD               m_Reserved[4];
    UCHAR               m_IBuffer[MAX_ETHER_FRAME];
} INTERMEDIATE_BUFFER, * PINTERMEDIATE_BUFFER;

/**
 * @brief INTERMEDIATE_BUFFER_WOW64 structure is similar to INTERMEDIATE_BUFFER, but it's used in a WOW64 environment.
 * WOW64 is a subsystem of the Windows operating system capable of running 32-bit applications and is included on all 64-bit versions of Windows.
 * In the INTERMEDIATE_BUFFER_WOW64 structure, the m_hAdapter and m_qLink fields are arrays of two handles to accommodate the larger pointer
 * size in a 64-bit environment.
 *
 * @param m_hAdapter/m_qLink This is a union of two fields. m_hAdapter is a handle to the adapter. m_qLink is a link to the next packet in the queue.
 * @param m_dwDeviceFlags This field stores device-specific flags. These flags can be used to indicate whether the packet is on send or receive.
 * @param m_Length This field stores the length of the packet.
 * @param m_Flags This field stores NDIS_PACKET flags. These flags provide information about the packet, such as whether it's a loopback packet
 * or a broadcast packet.
 * @param m_8021q This field stores 802.1q information. 802.1q is a networking standard that supports virtual LANs (VLANs) on an Ethernet network.
 * @param m_FilterID This field stores the filter ID. This can be used to identify the filter that the packet passed through.
 * @param m_Reserved This field is reserved for future use.
 * @param m_IBuffer This field is a buffer that contains the packet data. The size of the buffer is defined by the MAX_ETHER_FRAME constant.
 */
typedef struct _INTERMEDIATE_BUFFER_WOW64
{
    union {
        HANDLE          m_hAdapter[2];
        LIST_ENTRY      m_qLink[2];
    };
    DWORD               m_dwDeviceFlags;
    DWORD               m_Length;
    DWORD               m_Flags; // NDIS_PACKET flags
    DWORD               m_8021q; // 802.1q tag
    DWORD               m_FilterID;
    DWORD               m_Reserved[4];
    UCHAR               m_IBuffer[MAX_ETHER_FRAME];
} INTERMEDIATE_BUFFER_WOW64, * PINTERMEDIATE_BUFFER_WOW64;

/**
 * @brief NDISRD_ETH_Packet structure is a container for INTERMEDIATE_BUFFER pointer.
 * This structure can be extended in future versions.
 *
 * @param Buffer This field is a pointer to an INTERMEDIATE_BUFFER structure that contains the packet data and related information.
 */
typedef struct _NDISRD_ETH_Packet
{
    PINTERMEDIATE_BUFFER Buffer;
} NDISRD_ETH_Packet, * PNDISRD_ETH_Packet;

/**
 * @brief NDISRD_ETH_Packet_WOW64 structure is similar to NDISRD_ETH_Packet, but it's used in a WOW64 environment.
 * WOW64 is a subsystem of the Windows operating system capable of running 32-bit applications and is included on all 64-bit versions of Windows.
 *
 * @param Buffer This field is a ULARGE_INTEGER that contains the address of an INTERMEDIATE_BUFFER structure that contains the packet data
 * and related information.
 */
typedef struct _NDISRD_ETH_Packet_WOW64
{
    ULARGE_INTEGER Buffer;
} NDISRD_ETH_Packet_WOW64, * PNDISRD_ETH_Packet_WOW64;

/**
 * @brief ETH_REQUEST structure is used for both reading a single packet from the driver and sending packets to the driver.
 *
 * @param hAdapterHandle This field is a handle to the adapter. It's used to identify the adapter that the packet is being read from or sent to.
 * @param EthPacket This field is an NDISRD_ETH_Packet structure that contains the packet data and related information. When reading, this
 * structure will be filled with the packet data retrieved from the driver. When sending, this structure should be filled with the packet data to be sent.
 */
typedef struct _ETH_REQUEST
{
    HANDLE hAdapterHandle;
    NDISRD_ETH_Packet EthPacket;
} ETH_REQUEST, * PETH_REQUEST;

/**
 * @brief ETH_REQUEST_WOW64 structure is similar to ETH_REQUEST, but it's used in a WOW64 environment.
 * WOW64 is a subsystem of the Windows operating system capable of running 32-bit applications and is included on all 64-bit versions of Windows.
 * In the ETH_REQUEST_WOW64 structure, the hAdapterHandle field is a ULARGE_INTEGER and the EthPacket field is an NDISRD_ETH_Packet_WOW64 structure
 * to accommodate the larger pointer size in a 64-bit environment.
 *
 * @param hAdapterHandle This field is a ULARGE_INTEGER that represents a handle to the adapter. It's used to identify the adapter that the packet
 * is being read from or sent to.
 * @param EthPacket This field is an NDISRD_ETH_Packet_WOW64 structure that contains the packet data and related information. When reading, this
 * structure will be filled with the packet data retrieved from the driver. When sending, this structure should be filled with the packet data to be sent.
 */
typedef struct _ETH_REQUEST_WOW64
{
    ULARGE_INTEGER hAdapterHandle;
    NDISRD_ETH_Packet_WOW64 EthPacket;
} ETH_REQUEST_WOW64, * PETH_REQUEST_WOW64;
/**
 * @brief ETH_M_REQUEST structure is used for both reading multiple packets from the driver and sending multiple packets to the driver.
 *
 * @param hAdapterHandle This field is a handle to the adapter. It's used to identify the adapter that the packets are being read from or sent to.
 * @param dwPacketsNumber This field stores the number of packets.
 * @param dwPacketsSuccess This field stores the number of successfully processed packets.
 * @param EthPacket This is an array of NDISRD_ETH_Packet structures that contain the packet data and related information. When reading, these
 * structures will be filled with the packet data retrieved from the driver. When sending, these structures should be filled with the packet data
 * to be sent.
 */
typedef struct _ETH_M_REQUEST
{
    HANDLE              hAdapterHandle;
    unsigned            dwPacketsNumber;
    unsigned            dwPacketsSuccess;
    NDISRD_ETH_Packet   EthPacket[ANY_SIZE];
} ETH_M_REQUEST, * PETH_M_REQUEST;

/**
 * @brief ETH_M_REQUEST_WOW64 structure is similar to ETH_M_REQUEST, but it's used in a WOW64 environment.
 * WOW64 is a subsystem of the Windows operating system capable of running 32-bit applications and is included on all 64-bit versions of Windows.
 * In the ETH_M_REQUEST_WOW64 structure, the hAdapterHandle field is a ULARGE_INTEGER and the EthPacket field is an array of NDISRD_ETH_Packet_WOW64
 * structures to accommodate the larger pointer size in a 64-bit environment.
 *
 * @param hAdapterHandle This field is a ULARGE_INTEGER that represents a handle to the adapter. It's used to identify the adapter that the packets
 * are being read from or sent to.
 * @param dwPacketsNumber This field stores the number of packets.
 * @param dwPacketsSuccess This field stores the number of successfully processed packets.
 * @param EthPacket This is an array of NDISRD_ETH_Packet_WOW64 structures that contain the packet data and related information. When reading,
 * these structures will be filled with the packet data retrieved from the driver. When sending, these structures should be filled with the packet
 * data to be sent.
 */
typedef struct _ETH_M_REQUEST_WOW64
{
    ULARGE_INTEGER          hAdapterHandle;
    unsigned                dwPacketsNumber;
    unsigned                dwPacketsSuccess;
    NDISRD_ETH_Packet_WOW64 EthPacket[ANY_SIZE];
} ETH_M_REQUEST_WOW64, * PETH_M_REQUEST_WOW64;

/**
 * @brief ADAPTER_MODE structure is used for setting the working mode of the network adapter.
 *
 * @param hAdapterHandle This field is a handle to the adapter. It's used to identify the adapter that the mode is being set for.
 * @param dwFlags This field stores the mode flags. These flags determine the working mode of the adapter. The flags can be a combination of
 * the following values: MSTCP_FLAG_SENT_TUNNEL, MSTCP_FLAG_RECV_TUNNEL, MSTCP_FLAG_SENT_LISTEN, MSTCP_FLAG_RECV_LISTEN, MSTCP_FLAG_FILTER_DIRECT,
 * MSTCP_FLAG_TUNNEL, MSTCP_FLAG_LISTEN, and MSTCP_FLAG_FILTER.
 */
typedef struct _ADAPTER_MODE
{
    HANDLE          hAdapterHandle;
    DWORD           dwFlags;
} ADAPTER_MODE, * PADAPTER_MODE;

/**
 * @brief ADAPTER_MODE_WOW64 structure is similar to ADAPTER_MODE, but it's used in a WOW64 environment.
 * WOW64 is a subsystem of the Windows operating system capable of running 32-bit applications and is included on all 64-bit versions of Windows.
 * In the ADAPTER_MODE_WOW64 structure, the hAdapterHandle field is a ULARGE_INTEGER to accommodate the larger pointer size in a 64-bit environment.
 *
 * @param hAdapterHandle This field is a ULARGE_INTEGER that represents a handle to the adapter. It's used to identify the adapter that the mode
 * is being set for.
 * @param dwFlags This field stores the mode flags. These flags determine the working mode of the adapter. The flags can be a combination of the
 * following values: MSTCP_FLAG_SENT_TUNNEL, MSTCP_FLAG_RECV_TUNNEL, MSTCP_FLAG_SENT_LISTEN, MSTCP_FLAG_RECV_LISTEN, MSTCP_FLAG_FILTER_DIRECT,
 * MSTCP_FLAG_TUNNEL, MSTCP_FLAG_LISTEN, and MSTCP_FLAG_FILTER.
 */
typedef struct _ADAPTER_MODE_WOW64
{
    ULARGE_INTEGER  hAdapterHandle;
    DWORD           dwFlags;
} ADAPTER_MODE_WOW64, * PADAPTER_MODE_WOW64;

/**
 * @brief ADAPTER_EVENT structure is used for setting up the event which driver sets once having packet in the queue for the processing.
 *
 * @param hAdapterHandle This field is a handle to the adapter. It's used to identify the adapter that the event is being set for.
 * @param hEvent This field is a handle to the event that will be signaled when a packet is received.
 */
typedef struct _ADAPTER_EVENT
{
    HANDLE  hAdapterHandle;
    HANDLE  hEvent;
} ADAPTER_EVENT, * PADAPTER_EVENT;

/**
 * @brief ADAPTER_EVENT_WOW64 structure is similar to ADAPTER_EVENT, but it's used in a WOW64 environment.
 * WOW64 is a subsystem of the Windows operating system capable of running 32-bit applications and is included on all 64-bit versions of Windows.
 * In the ADAPTER_EVENT_WOW64 structure, the hAdapterHandle and hEvent fields are ULARGE_INTEGER to accommodate the larger pointer size in a
 * 64-bit environment.
 *
 * @param hAdapterHandle This field is a ULARGE_INTEGER that represents a handle to the adapter. It's used to identify the adapter that the
 * event is being set for.
 * @param hEvent This field is a ULARGE_INTEGER that represents a handle to the event that will be signaled when a packet is received.
 */
typedef struct _ADAPTER_EVENT_WOW64
{
    ULARGE_INTEGER  hAdapterHandle;
    ULARGE_INTEGER  hEvent;
} ADAPTER_EVENT_WOW64, * PADAPTER_EVENT_WOW64;

/**
 * @brief PACKET_OID_DATA structure is used for making query or set requests on the underlying network adapter driver.
 *
 * @param hAdapterHandle This field is a handle to the adapter. It's used to identify the adapter that the request is being made on.
 * @param Oid This field stores the OID (Object Identifier) of the request. The OID is a code that identifies the network parameter that
 * is being queried or set.
 * @param Length This field stores the length of the data being queried or set.
 * @param Data This is an array of bytes that contains the data being queried or set. The size of the array is defined by the ANY_SIZE constant.
 */
typedef struct _PACKET_OID_DATA
{
    HANDLE      hAdapterHandle;
    DWORD       Oid;
    DWORD       Length;
    UCHAR       Data[ANY_SIZE];
} PACKET_OID_DATA, * PPACKET_OID_DATA;

/**
 * @brief PACKET_OID_DATA_WOW64 structure is similar to PACKET_OID_DATA, but it's used in a WOW64 environment.
 * WOW64 is a subsystem of the Windows operating system capable of running 32-bit applications and is included on all 64-bit versions of Windows.
 * In the PACKET_OID_DATA_WOW64 structure, the hAdapterHandle field is a ULARGE_INTEGER to accommodate the larger pointer size in a
 * 64-bit environment.
 *
 * @param hAdapterHandle This field is a ULARGE_INTEGER that represents a handle to the adapter. It's used to identify the adapter that
 * the request is being made on.
 * @param Oid This field stores the OID (Object Identifier) of the request. The OID is a code that identifies the network parameter that
 * is being queried or set.
 * @param Length This field stores the length of the data being queried or set.
 * @param Data This is an array of bytes that contains the data being queried or set. The size of the array is defined by the ANY_SIZE constant.
 */
typedef struct _PACKET_OID_DATA_WOW64
{
    ULARGE_INTEGER  hAdapterHandle;
    DWORD           Oid;
    DWORD           Length;
    UCHAR           Data[ANY_SIZE];
} PACKET_OID_DATA_WOW64, * PPACKET_OID_DATA_WOW64;


/**
 * @brief RAS_LINK_INFO structure is used to provide information about a RAS (Remote Access Service) link.
 *
 * @param LinkSpeed This field stores the link speed in units of 100 bps. Zero indicates no change from the speed returned when the protocol
 * called NdisRequest with OID_GEN_LINK_SPEED.
 * @param MaximumTotalSize This field stores the maximum number of bytes per packet that the protocol can send over the network. Zero indicates
 * no change from the value returned when the protocol called NdisRequest with OID_GEN_MAXIMUM_TOTAL_SIZE.
 * @param RemoteAddress This field stores the remote address for the link in Ethernet-style format. NDISWAN supplies this value.
 * @param LocalAddress This field stores the local address for the link in Ethernet-style format.
 * @param ProtocolBufferLength This field specifies the number of bytes in the buffer at ProtocolBuffer.
 * @param ProtocolBuffer This field is a buffer containing protocol-specific information supplied by a higher-level component that makes
 * connections through NDISWAN to the appropriate protocol(s). Maximum observed size is 600 bytes on Windows Vista, 1200 on Windows 10.
 */
typedef struct _RAS_LINK_INFO
{
#define RAS_LINK_BUFFER_LENGTH 2048
    DWORD  LinkSpeed;
    DWORD  MaximumTotalSize;
    UCHAR  RemoteAddress[ETHER_ADDR_LENGTH];
    UCHAR  LocalAddress[ETHER_ADDR_LENGTH];
    DWORD  ProtocolBufferLength;
    UCHAR  ProtocolBuffer[RAS_LINK_BUFFER_LENGTH];
} RAS_LINK_INFO, * PRAS_LINK_INFO;

/**
 * @brief RAS_LINKS structure is used to store an array of RAS_LINK_INFO structures.
 *
 * @param nNumberOfLinks This field stores the number of RAS_LINK_INFO structures in the RasLinks array.
 * @param RasLinks This is an array of RAS_LINK_INFO structures.
 */
typedef struct _RAS_LINKS
{
#define RAS_LINKS_MAX    256
    DWORD nNumberOfLinks;
    RAS_LINK_INFO RasLinks[RAS_LINKS_MAX];
} RAS_LINKS, * PRAS_LINKS;

/**********************************************************************************
                        Static packet filter definitions
***********************************************************************************/

/**
 * @brief ETH_802_3_FILTER structure is used to set the Ethernet 802.3 filter for the network adapter.
 *
 * @param m_ValidFields This field stores the valid fields flags. These flags determine which fields in the structure are valid. The flags
 * can be a combination of the following values: ETH_802_3_SRC_ADDRESS, ETH_802_3_DEST_ADDRESS, ETH_802_3_PROTOCOL.
 * @param m_SrcAddress This field stores the source address for the filter. It is an array of bytes representing the MAC address.
 * @param m_DestAddress This field stores the destination address for the filter. It is an array of bytes representing the MAC address.
 * @param m_Protocol This field stores the protocol for the filter. It is a 16-bit value representing the EtherType of the protocol.
 */
typedef struct _ETH_802_3_FILTER
{
#define ETH_802_3_SRC_ADDRESS    0x00000001
#define ETH_802_3_DEST_ADDRESS   0x00000002
#define ETH_802_3_PROTOCOL       0x00000004
    DWORD           m_ValidFields;                    // Specifies which of the fields below contain valid values and should be matched against the packet
    unsigned char   m_SrcAddress[ETHER_ADDR_LENGTH];  // Source MAC address
    unsigned char   m_DestAddress[ETHER_ADDR_LENGTH]; // Destination MAC address
    unsigned short  m_Protocol;                       // EtherType
    unsigned short  Padding;
} ETH_802_3_FILTER, * PETH_802_3_FILTER;

/**
 * @brief IP_SUBNET_V4 structure is used to represent an IPv4 subnet.
 *
 * @param m_Ip This field stores the IPv4 address expressed as an DWORD.
 * @param m_IpMask This field stores the IPv4 subnet mask expressed as an DWORD.
 */
typedef struct _IP_SUBNET_V4
{
    DWORD   m_Ip;       // IPv4 address expressed as DWORD
    DWORD   m_IpMask;   // IPv4 mask expressed as DWORD
} IP_SUBNET_V4, * PIP_SUBNET_V4;

/**
 * @brief IP_RANGE_V4 structure is used to represent a range of IPv4 addresses.
 *
 * @param m_StartIp This field stores the starting IPv4 address of the range expressed as an DWORD.
 * @param m_EndIp This field stores the ending IPv4 address of the range expressed as an DWORD.
 */
typedef struct _IP_RANGE_V4
{
    DWORD   m_StartIp;  // Start of IPv4 address range expressed as DWORD
    DWORD   m_EndIp;    // End of IPv4 address range expressed as DWORD
} IP_RANGE_V4, * PIP_RANGE_V4;

/**
 * @brief IP_ADDRESS_V4 structure is used to represent an IPv4 address which can be either a subnet or a range.
 *
 * @param m_AddressType This field specifies the type of the IPv4 address. It can be either IP_SUBNET_V4_TYPE or IP_RANGE_V4_TYPE.
 * @param m_IpSubnet This field is an IP_SUBNET_V4 structure that represents an IPv4 subnet.
 * @param m_IpRange This field is an IP_RANGE_V4 structure that represents a range of IPv4 addresses.
 */
typedef struct _IP_ADDRESS_V4
{
#define IP_SUBNET_V4_TYPE    0x00000001
#define IP_RANGE_V4_TYPE     0x00000002
    DWORD m_AddressType; // Specifies which of the IP v4 address types is used below
    union
    {
        IP_SUBNET_V4    m_IpSubnet;
        IP_RANGE_V4     m_IpRange;
    };
} IP_ADDRESS_V4, * PIP_ADDRESS_V4;

/**
 * @brief IP_V4_FILTER structure is used to set the IPv4 filter for the network adapter.
 *
 * @param m_ValidFields This field stores the valid fields flags. These flags determine which fields in the structure are valid. The flags
 * can be a combination of the following values: IP_V4_FILTER_SRC_ADDRESS, IP_V4_FILTER_DEST_ADDRESS, IP_V4_FILTER_PROTOCOL.
 * @param m_SrcAddress This field is an IP_ADDRESS_V4 structure that stores the source address for the filter.
 * @param m_DestAddress This field is an IP_ADDRESS_V4 structure that stores the destination address for the filter.
 * @param m_Protocol This field stores the protocol for the filter. It is an unsigned char representing the protocol number.
 */
typedef struct _IP_V4_FILTER
{
#define IP_V4_FILTER_SRC_ADDRESS    0x00000001
#define IP_V4_FILTER_DEST_ADDRESS   0x00000002
#define IP_V4_FILTER_PROTOCOL       0x00000004
    DWORD           m_ValidFields;   // Specifies which of the fields below contain valid values and should be matched against the packet
    IP_ADDRESS_V4   m_SrcAddress;    // IP v4 source address
    IP_ADDRESS_V4   m_DestAddress;   // IP v4 destination address
    unsigned char   m_Protocol;      // Specifies next protocol
    unsigned char   Padding[3];
} IP_V4_FILTER, * PIP_V4_FILTER;

/**
 * @brief IP_SUBNET_V6 structure is used to represent an IPv6 subnet.
 *
 * @param m_Ip This field stores the IPv6 address expressed as an IN6_ADDR structure.
 * @param m_IpMask This field stores the IPv6 subnet mask expressed as an IN6_ADDR structure.
 */
typedef struct _IP_SUBNET_V6
{
    IN6_ADDR        m_Ip;       // IPv6 address
    IN6_ADDR        m_IpMask;   // IPv6 mask
} IP_SUBNET_V6, * PIP_SUBNET_V6;

/**
 * @brief IP_RANGE_V6 structure is used to represent a range of IPv6 addresses.
 *
 * @param m_StartIp This field stores the starting IPv6 address of the range expressed as an IN6_ADDR structure.
 * @param m_EndIp This field stores the ending IPv6 address of the range expressed as an IN6_ADDR structure.
 */
typedef struct _IP_RANGE_V6
{
    IN6_ADDR        m_StartIp;  // Start of IPv6 address range
    IN6_ADDR        m_EndIp;    // End of IPv6 address range
} IP_RANGE_V6, * PIP_RANGE_V6;

/**
 * @brief IP_ADDRESS_V6 structure is used to represent an IPv6 address which can be either a subnet or a range.
 *
 * @param m_AddressType This field specifies the type of the IPv6 address. It can be either IP_SUBNET_V6_TYPE or IP_RANGE_V6_TYPE.
 * @param m_IpSubnet This field is an IP_SUBNET_V6 structure that represents an IPv6 subnet.
 * @param m_IpRange This field is an IP_RANGE_V6 structure that represents a range of IPv6 addresses.
 */
typedef struct _IP_ADDRESS_V6
{
#define IP_SUBNET_V6_TYPE    0x00000001
#define IP_RANGE_V6_TYPE     0x00000002
    DWORD   m_AddressType; // Specifies which of the IP v6 address types is used below
    union
    {
        IP_SUBNET_V6    m_IpSubnet;
        IP_RANGE_V6     m_IpRange;
    };
} IP_ADDRESS_V6, * PIP_ADDRESS_V6;

/**
 * @brief IP_V6_FILTER structure is used to set the IPv6 filter for the network adapter.
 *
 * @param m_ValidFields This field stores the valid fields flags. These flags determine which fields in the structure are valid. The flags
 * can be a combination of the following values: IP_V6_FILTER_SRC_ADDRESS, IP_V6_FILTER_DEST_ADDRESS, IP_V6_FILTER_PROTOCOL.
 * @param m_SrcAddress This field is an IP_ADDRESS_V6 structure that stores the source address for the filter.
 * @param m_DestAddress This field is an IP_ADDRESS_V6 structure that stores the destination address for the filter.
 * @param m_Protocol This field stores the protocol for the filter. It is an unsigned char representing the protocol number.
 */
typedef struct _IP_V6_FILTER
{
#define IP_V6_FILTER_SRC_ADDRESS    0x00000001
#define IP_V6_FILTER_DEST_ADDRESS   0x00000002
#define IP_V6_FILTER_PROTOCOL       0x00000004
    DWORD           m_ValidFields;   // Specifies which of the fields below contain valid values and should be matched against the packet
    IP_ADDRESS_V6   m_SrcAddress;    // IP v6 source address
    IP_ADDRESS_V6   m_DestAddress;   // IP v6 destination address
    unsigned char   m_Protocol;      // Specifies next protocol
    unsigned char   Padding[3];
} IP_V6_FILTER, * PIP_V6_FILTER;

/**
 * @brief PORT_RANGE structure is used to represent a range of ports.
 *
 * @param m_StartRange This field stores the starting port of the range. It is an unsigned short. The port is specified in host byte order.
 * @param m_EndRange This field stores the ending port of the range. It is also an unsigned short. The port is specified in host byte order.
 */
typedef struct _PORT_RANGE
{
    unsigned short  m_StartRange;  // Starting port of the range in host byte order
    unsigned short  m_EndRange;    // Ending port of the range in host byte order
} PORT_RANGE, * PPORT_RANGE;

/**
 * @brief TCPUDP_FILTER structure is used to set the TCP/UDP filter for the network adapter.
 *
 * @param m_ValidFields This field stores the valid fields flags. These flags determine which fields in the structure are valid. The flags
 * can be a combination of the following values: TCPUDP_SRC_PORT, TCPUDP_DEST_PORT, TCPUDP_TCP_FLAGS.
 * @param m_SourcePort This field is a PORT_RANGE structure that stores the source port range for the filter.
 * @param m_DestPort This field is a PORT_RANGE structure that stores the destination port range for the filter.
 * @param m_TCPFlags This field stores the TCP flags for the filter. It is an unsigned char representing the TCP flags combination.
 */
typedef struct _TCPUDP_FILTER
{
#define TCPUDP_SRC_PORT   0x00000001
#define TCPUDP_DEST_PORT  0x00000002
#define TCPUDP_TCP_FLAGS  0x00000004
    DWORD           m_ValidFields;  // Specifies which of the fields below contain valid values and should be matched against the packet
    PORT_RANGE      m_SourcePort;   // Source port
    PORT_RANGE      m_DestPort;     // Destination port
    unsigned char   m_TCPFlags;     // TCP flags combination
    unsigned char   Padding[3];
} TCPUDP_FILTER, * PTCPUDP_FILTER;

/**
 * @brief BYTE_RANGE structure is used to represent a range of bytes.
 *
 * @param m_StartRange This field stores the starting byte of the range. It is an unsigned char.
 * @param m_EndRange This field stores the ending byte of the range. It is also an unsigned char.
 */
typedef struct _BYTE_RANGE
{
    unsigned char m_StartRange;  // Starting byte of the range
    unsigned char m_EndRange;    // Ending byte of the range
} BYTE_RANGE, * PBYTE_RANGE;

/**
 * @brief ICMP_FILTER structure is used to set the ICMP filter for the network adapter.
 *
 * @param m_ValidFields This field stores the valid fields flags. These flags determine which fields in the structure are valid. The flags
 * can be a combination of the following values: ICMP_TYPE, ICMP_CODE.
 * @param m_TypeRange This field is a BYTE_RANGE structure that stores the ICMP Type range for the filter.
 * @param m_CodeRange This field is a BYTE_RANGE structure that stores the ICMP Code range for the filter.
 */
typedef struct _ICMP_FILTER
{
#define ICMP_TYPE        0x00000001
#define ICMP_CODE        0x00000002
    DWORD           m_ValidFields;  // Specifies which of the fields below contain valid values and should be matched against the packet
    BYTE_RANGE      m_TypeRange;    // ICMP Type range
    BYTE_RANGE      m_CodeRange;    // ICMP Code range
} ICMP_FILTER, * PICMP_FILTER;

/**
 * @brief DATA_LINK_LAYER_FILTER structure is used to set the data link layer filter for the network adapter.
 *
 * @param m_dwUnionSelector This field stores the valid fields flags. These flags determine which fields in the structure are valid. The flags
 * can be a combination of the following values: ETH_802_3.
 * @param m_Eth8023Filter This field is an ETH_802_3_FILTER structure that stores the Ethernet 802.3 filter.
 */
typedef struct _DATA_LINK_LAYER_FILTER
{
#define ETH_802_3    0x00000001
    DWORD    m_dwUnionSelector; // Specifies which of the fields below contain valid values and should be matched against the packet
    union
    {
        ETH_802_3_FILTER   m_Eth8023Filter; // Ethernet 802.3 filter
    };
} DATA_LINK_LAYER_FILTER, * PDATA_LINK_LAYER_FILTER;

/**
 * @brief NETWORK_LAYER_FILTER structure is used to set the network layer filter for the network adapter.
 *
 * @param m_dwUnionSelector This field stores the valid fields flags. These flags determine which fields in the structure are valid. The flags
 * can be a combination of the following values: IPV4, IPV6.
 * @param m_IPv4 This field is an IP_V4_FILTER structure that stores the IPv4 filter.
 * @param m_IPv6 This field is an IP_V6_FILTER structure that stores the IPv6 filter.
 */
typedef struct _NETWORK_LAYER_FILTER
{
#define IPV4    0x00000001
#define IPV6    0x00000002
    DWORD    m_dwUnionSelector; // Specifies which of the fields below contain valid values and should be matched against the packet
    union
    {
        IP_V4_FILTER   m_IPv4; // IPv4 filter
        IP_V6_FILTER   m_IPv6; // IPv6 filter
    };
} NETWORK_LAYER_FILTER, * PNETWORK_LAYER_FILTER;

/**
 * @brief TRANSPORT_LAYER_FILTER structure is used to set the transport layer filter for the network adapter.
 *
 * @param m_dwUnionSelector This field stores the valid fields flags. These flags determine which fields in the structure are valid. The flags
 * can be a combination of the following values: TCPUDP, ICMP.
 * @param m_TcpUdp This field is a TCPUDP_FILTER structure that stores the TCP/UDP filter.
 * @param m_Icmp This field is an ICMP_FILTER structure that stores the ICMP filter.
 */
typedef struct _TRANSPORT_LAYER_FILTER
{
#define TCPUDP  0x00000001
#define ICMP    0x00000002
    DWORD    m_dwUnionSelector; // Specifies which of the fields below contain valid values and should be matched against the packet
    union
    {
        TCPUDP_FILTER    m_TcpUdp; // TCP/UDP filter
        ICMP_FILTER      m_Icmp;   // ICMP filter
    };
} TRANSPORT_LAYER_FILTER, * PTRANSPORT_LAYER_FILTER;

/**
 * @brief STATIC_FILTER structure is used to define a static filter for the network adapter.
 *
 * @param m_Adapter This field is a handle to the adapter. It's used to identify the adapter that the filter is associated with.
 * @param m_dwDirectionFlags This field stores direction flags. These flags can be used to indicate whether the filter applies to sent packets,
 * received packets, or both.
 * @param m_FilterAction This field specifies the action to be taken when the filter conditions are met. It can be one of the following values:
 * FILTER_PACKET_PASS, FILTER_PACKET_DROP, FILTER_PACKET_REDIRECT, FILTER_PACKET_PASS_RDR, FILTER_PACKET_DROP_RDR.
 * @param m_ValidFields This field stores the valid fields flags. These flags determine which fields in the structure are valid. The flags can
 * be a combination of the following values: DATA_LINK_LAYER_VALID, NETWORK_LAYER_VALID, TRANSPORT_LAYER_VALID.
 * @param m_LastReset This field stores the time of the last counters reset in seconds passed since 1 Jan 1980.
 * @param m_PacketsIn This field stores the number of incoming packets that passed through this filter.
 * @param m_BytesIn This field stores the number of incoming bytes that passed through this filter.
 * @param m_PacketsOut This field stores the number of outgoing packets that passed through this filter.
 * @param m_BytesOut This field stores the number of outgoing bytes that passed through this filter.
 * @param m_DataLinkFilter This field is a DATA_LINK_LAYER_FILTER structure that stores the data link layer filter.
 * @param m_NetworkFilter This field is a NETWORK_LAYER_FILTER structure that stores the network layer filter.
 * @param m_TransportFilter This field is a TRANSPORT_LAYER_FILTER structure that stores the transport layer filter.
 */
typedef struct _STATIC_FILTER
{
#define FILTER_PACKET_PASS      0x00000001 // Pass packet if it matches the filter
#define FILTER_PACKET_DROP      0x00000002 // Drop packet if it matches the filter
#define FILTER_PACKET_REDIRECT  0x00000003 // Redirect packet to WinpkFilter client application
#define FILTER_PACKET_PASS_RDR  0x00000004 // Redirect packet to WinpkFilter client application and pass over network (listen mode)
#define FILTER_PACKET_DROP_RDR  0x00000005 // Redirect packet to WinpkFilter client application and drop it, e.g. log but remove from the flow (listen mode)

#define DATA_LINK_LAYER_VALID   0x00000001 // Match packet against data link layer filter
#define NETWORK_LAYER_VALID     0x00000002 // Match packet against network layer filter
#define TRANSPORT_LAYER_VALID   0x00000004 // Match packet against transport layer filter

    ULARGE_INTEGER   m_Adapter; // Adapter handle extended to 64 bit size for structure compatibility across x64 and x86
    DWORD            m_dwDirectionFlags; // PACKET_FLAG_ON_SEND or/and PACKET_FLAG_ON_RECEIVE
    DWORD            m_FilterAction; // FILTER_PACKET_XXX
    DWORD            m_ValidFields; // Specifies which of the fields below contain valid values and should be matched against the packet

    // Statistics for the filter
    DWORD            m_LastReset; // Time of the last counters reset (in seconds passed since 1 Jan 1980)
    ULARGE_INTEGER   m_PacketsIn; // Incoming packets passed through this filter
    ULARGE_INTEGER   m_BytesIn; // Incoming bytes passed through this filter
    ULARGE_INTEGER   m_PacketsOut; // Outgoing packets passed through this filter
    ULARGE_INTEGER   m_BytesOut; // Outgoing bytes passed through this filter

    DATA_LINK_LAYER_FILTER   m_DataLinkFilter;
    NETWORK_LAYER_FILTER     m_NetworkFilter;
    TRANSPORT_LAYER_FILTER   m_TransportFilter;
} STATIC_FILTER, * PSTATIC_FILTER;

/**
 * @brief Defines a table of static filters to be applied on network traffic.
 *
 * This structure is used to hold a collection of static filters that determine how network packets are processed.
 * Each filter in the table can specify actions like pass, drop, or redirect packets based on various criteria such as
 * source and destination IP addresses, port numbers, and protocol types. The table size is dynamic, allowing for
 * a variable number of filters to be defined based on the needs of the application.
 *
 * @param m_TableSize The number of STATIC_FILTER entries in the table. This determines the number of filters
 *                    currently defined and active for processing network packets.
 * @param Padding     Reserved for future use, ensuring proper alignment of the structure in memory.
 * @param m_StaticFilters An array of STATIC_FILTER structures, each defining a specific filter with its own
 *                        set of criteria and actions. The size of this array is determined by m_TableSize.
 */
typedef struct _STATIC_FILTER_TABLE
{
    DWORD          m_TableSize; // number of STATIC_FILTER entries
    DWORD          Padding;
    STATIC_FILTER  m_StaticFilters[ANY_SIZE];
} STATIC_FILTER_TABLE, * PSTATIC_FILTER_TABLE;

/**
 * @brief Structure to define a static filter with a specific insertion position.
 *
 * This structure combines a STATIC_FILTER with a position value to specify where in the filter list the static filter should be inserted.
 * The position determines the order of filter application, with lower values indicating higher priority. This allows for precise control
 * over the packet filtering process, enabling the insertion of filters at specific points in the filter chain.
 *
 * @param m_Position The position in the filter list where the new filter should be inserted. Filters are processed in ascending order based
 * on this value.
 * @param m_StaticFilter The STATIC_FILTER structure that defines the filter criteria and actions. This includes details such as the direction
 * of traffic to filter, the protocol to filter, and the action to take when a packet matches the filter criteria.
 */
typedef struct _STATIC_FILTER_WITH_POSITION
{
    unsigned long   m_Position; // position to insert new filter
    STATIC_FILTER   m_StaticFilter;
} STATIC_FILTER_WITH_POSITION, * PSTATIC_FILTER_WITH_POSITION;

/**********************************************************************************
                        Fast I/O structures definitions
***********************************************************************************/

/**
 * @brief FAST_IO_WRITE_UNION structure is used to store the number of packets and the write-in-progress flag in a union.
 *
 * @param union_ This is a union of two fields. The split field is a structure that contains the number_of_packets and write_in_progress_flag fields.
 * The join field is an DWORD that can store the combined value of the two fields in the split structure.
 */
typedef struct _FAST_IO_WRITE_UNION {
    union {
        struct {
            USHORT number_of_packets;
            USHORT write_in_progress_flag;
        } split;
        DWORD join;
    } union_;
}FAST_IO_WRITE_UNION, * PFAST_IO_WRITE_UNION;

/**
 * @brief FAST_IO_SECTION_HEADER structure is used to store the fast I/O write union and the read in progress flag.
 *
 * @param fast_io_write_union This field is a FAST_IO_WRITE_UNION structure that stores the number of packets and the write-in-progress flag.
 * @param read_in_progress_flag This field is an DWORD that stores the read in progress flag.
 */
typedef struct _FAST_IO_SECTION_HEADER {
    FAST_IO_WRITE_UNION fast_io_write_union;
    DWORD               read_in_progress_flag;
} FAST_IO_SECTION_HEADER, * PFAST_IO_SECTION_HEADER;

/**
 * @brief FAST_IO_SECTION structure is used to store the fast I/O section header and the fast I/O packets.
 *
 * @param fast_io_header This field is a volatile FAST_IO_SECTION_HEADER structure that stores the fast I/O write union and the
 * read-in-progress flag.
 * @param fast_io_packets This field is an array of INTERMEDIATE_BUFFER structures that store the fast I/O packets. The size of the array
 * is defined by the ANY_SIZE constant.
 */
typedef struct _FAST_IO_SECTION
{
    volatile FAST_IO_SECTION_HEADER fast_io_header;
    INTERMEDIATE_BUFFER            fast_io_packets[ANY_SIZE];
} FAST_IO_SECTION, * PFAST_IO_SECTION;

/**
 * @brief INITIALIZE_FAST_IO_PARAMS structure is used to store the header pointer and the data size for initializing fast I/O.
 *
 * @param header_ptr This field is a pointer to a FAST_IO_SECTION structure that stores the fast I/O section header and the fast I/O packets.
 * @param data_size This field is an DWORD that stores the data size.
 */
typedef struct _INITIALIZE_FAST_IO_PARAMS
{
    PFAST_IO_SECTION header_ptr;
    DWORD            data_size;
}INITIALIZE_FAST_IO_PARAMS, * PINITIALIZE_FAST_IO_PARAMS;

/**********************************************************************************
                            Unsorted Read/Send packets
***********************************************************************************/

/**
 * @brief UNSORTED_READ_SEND_REQUEST structure is used for storing an array of packets for reading or sending.
 *
 * @param packets This field is a pointer to an array of PINTERMEDIATE_BUFFER structures. Each PINTERMEDIATE_BUFFER structure contains the
 * packet data and related information.
 * @param packets_num This field stores the number of packets in the array.
 */
typedef struct _UNSORTED_READ_SEND_REQUEST
{
    PINTERMEDIATE_BUFFER* packets;
    DWORD                 packets_num;
} UNSORTED_READ_SEND_REQUEST, * PUNSORTED_READ_SEND_REQUEST;

// Restore Default Structure Packing
#pragma pack(pop)

/**********************************************************************************
                 Standard IOCTL Codes For NDIS Packet Redirector Driver
***********************************************************************************/

#define FILE_DEVICE_NDISRD  0x00008300
#define NDISRD_IOCTL_INDEX  0x830

#define IOCTL_NDISRD_GET_VERSION\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_GET_TCPIP_INTERFACES\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+1, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_SEND_PACKET_TO_ADAPTER\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+2, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_SEND_PACKET_TO_MSTCP\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+3, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_READ_PACKET\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+4, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_SET_ADAPTER_MODE\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+5, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_FLUSH_ADAPTER_QUEUE\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+6, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_SET_EVENT\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+7, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_NDIS_SET_REQUEST\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+8, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_NDIS_GET_REQUEST\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+9, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_SET_WAN_EVENT\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+10, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_SET_ADAPTER_EVENT\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+11, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_ADAPTER_QUEUE_SIZE\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+12, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_GET_ADAPTER_MODE\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+13, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_SET_PACKET_FILTERS\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+14, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_RESET_PACKET_FILTERS\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+15, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_GET_PACKET_FILTERS_TABLESIZE\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+16, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_GET_PACKET_FILTERS\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+17, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_GET_PACKET_FILTERS_RESET_STATS\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+18, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_GET_RAS_LINKS\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+19, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_SEND_PACKETS_TO_ADAPTER\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+20, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_SEND_PACKETS_TO_MSTCP\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+21, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_READ_PACKETS\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+22, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_SET_ADAPTER_HWFILTER_EVENT\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+23, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_INITIALIZE_FAST_IO\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+24, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_READ_PACKETS_UNSORTED\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+25, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_SEND_PACKET_TO_ADAPTER_UNSORTED\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+26, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_SEND_PACKET_TO_MSTCP_UNSORTED\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+27, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_ADD_SECOND_FAST_IO_SECTION\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+28, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_QUERY_IB_POOL_SIZE\
   CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+29, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_ADD_PACKET_FILTER_FRONT\
    CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+30, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_ADD_PACKET_FILTER_BACK\
    CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+31, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_REMOVE_FILTER_BY_INDEX\
    CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+32, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_GET_ADP_FILTERS_LIST\
    CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+33, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_INSERT_FILTER_BY_INDEX\
    CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+34, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_SET_FILTER_CACHE_STATE\
    CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+35, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISRD_SET_FRAGMENT_CACHE_STATE\
    CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_IOCTL_INDEX+36, METHOD_BUFFERED, FILE_ANY_ACCESS)

/**********************************************************************************
                 Conditional Inclusion of Custom IOCTLs
***********************************************************************************/

/**
 * @brief This section allows for the inclusion of user-defined IOCTLs.
 *
 * User-defined IOCTLs can be defined starting from NDISRD_USER_IOCTL_INDEX in the user_ioctls.h file.
 * This provides flexibility for extending the functionality of the Windows Packet Filter Driver
 * with custom operations as needed.
 *
 * Example:
 * #ifndef USER_IOCTLS_H
 * #define USER_IOCTLS_H
 *
 * #define IOCTL_NDISRD_CUSTOM_OPERATION_1\
 *     CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_USER_IOCTL_INDEX, METHOD_BUFFERED, FILE_ANY_ACCESS)
 *
 * #define IOCTL_NDISRD_CUSTOM_OPERATION_2\
 *     CTL_CODE(FILE_DEVICE_NDISRD, NDISRD_USER_IOCTL_INDEX + 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
 *
 * // Add more custom IOCTLs here...
 *
 * #endif // USER_IOCTLS_H
 */

#ifdef USER_IOCTLS
 // User-defined IOCTL range, reserve the range from 0x80 to 0xFF for user-defined IOCTLs
#define NDISRD_USER_IOCTL_INDEX  NDISRD_IOCTL_INDEX + 0x80
#include "user_ioctls.h"
#endif

#endif // COMMON_H
```

`include/ndisapi.h`:

```h
/*************************************************************************/
/*                    Copyright (c) 2000-2024 NT KERNEL.                 */
/*                           All Rights Reserved.                        */
/*                          https://www.ntkernel.com                     */
/*                           ndisrd@ntkernel.com                         */
/*                                                                       */
/* Module Name:  ndisapi.h                                               */
/*                                                                       */
/* Description: API exported C++ class and C API declarations            */
/*                                                                       */
/* Environment:                                                          */
/*   User mode                                                           */
/*                                                                       */
/*************************************************************************/
#pragma once

#ifdef _LIB // must be defined when linking static library version of ndisapi.dll
#define NDISAPI_API 
#else
// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the NDISAPI_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// NDISAPI_API functions as being imported from a DLL, whereas this DLL sees symbols
// defined with this macro as being exported.
#ifdef NDISAPI_EXPORTS
#define NDISAPI_API __declspec(dllexport)
#else
#define NDISAPI_API __declspec(dllimport)
#endif //NDISAPI_EXPORTS
#endif //_LIB

#if _MSC_VER >= 1700 
#ifdef _USING_V110_SDK71_
#define _USE_LEGACY_VERSION_INFO
#endif //_USING_V110_SDK71_
#endif // _MSC_VER

#if _MSC_VER < 1700
#define _USE_LEGACY_VERSION_INFO
#endif //_MSC_VER

#ifndef _USE_LEGACY_VERSION_INFO // Use VersionHelpers for 2012 and later toolsets only
#include <VersionHelpers.h>
#endif // _USE_LEGACY_VERSION_INFO

enum
{
    FILE_NAME_SIZE = 1000
};

typedef BOOL(__stdcall* IsWow64ProcessPtr)(HANDLE hProcess, PBOOL Wow64Process);

/**
 * @struct CVersionInfo
 * @brief An extension of the OSVERSIONINFO structure for retrieving and
 *        comparing operating system version information.
 *
 * This structure provides a set of functions to check whether the current
 * operating system version is equal to or greater than a specific version,
 * such as Windows XP, Windows 7, or Windows 10.
 *
 * Usage:
 * CVersionInfo versionInfo;
 * if (versionInfo.IsWindows7OrGreater()) {
 *     // Code for Windows 7 or later
 * }
 */
struct NDISAPI_API CVersionInfo : private OSVERSIONINFO
{
#ifdef _USE_LEGACY_VERSION_INFO
    /**
     * @brief Constructor that initializes the OSVERSIONINFO structure.
     */
    CVersionInfo()
    {
        dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        ::GetVersionEx(this);
    }

    /**
     * @brief Checks if the operating system is Windows Vista or greater.
     * @return TRUE if Windows Vista or greater, FALSE otherwise.
     */
    BOOL IsWindowsVistaOrGreater() { return (dwMajorVersion >= 6); }

    /**
     * @brief Checks if the operating system is Windows 7 or greater.
     * @return TRUE if Windows 7 or greater, FALSE otherwise.
     */
    BOOL IsWindows7OrGreater() { return (dwMajorVersion > 6) || ((dwMajorVersion == 6) && (dwMinorVersion > 0)); }

    /**
     * @brief Checks if the operating system is Windows XP or greater.
     * @return TRUE if Windows XP or greater, FALSE otherwise.
     */
    BOOL IsWindowsXPOrGreater() { return ((dwMajorVersion == 5) && (dwMinorVersion >= 1)) || (dwMajorVersion > 5); }

    /**
     * @brief Checks if the operating system is Windows 10 or greater.
     * @return TRUE if Windows 10 or greater, FALSE otherwise.
     */
    BOOL IsWindows10OrGreater() { return (dwMajorVersion >= 10); }

    /**
     * @brief Checks if the operating system is of the Windows NT platform.
     * @return TRUE if Windows NT platform, FALSE otherwise.
     */
    BOOL IsWindowsNTPlatform() { return (dwPlatformId == VER_PLATFORM_WIN32_NT); }
#else
    /**
     * @brief Static function to check if the operating system is Windows Vista or greater.
     * @return TRUE if Windows Vista or greater, FALSE otherwise.
     */
    static BOOL IsWindowsVistaOrGreater() { return ::IsWindowsVistaOrGreater(); }

    /**
     * @brief Static function to check if the operating system is Windows XP or greater.
     * @return TRUE if Windows XP or greater, FALSE otherwise.
     */
    static BOOL IsWindowsXPOrGreater() { return ::IsWindowsXPOrGreater(); }

    /**
     * @brief Static function to check if the operating system is Windows 7 or greater.
     * @return TRUE if Windows 7 or greater, FALSE otherwise.
     */
    static BOOL IsWindows7OrGreater() { return ::IsWindows7OrGreater(); }

    /**
     * @brief Static function to check if the operating system is Windows 10 or greater.
     * @return TRUE if Windows 10 or greater, FALSE otherwise.
     */
    static BOOL IsWindows10OrGreater() { return ::IsWindowsVersionOrGreater(10, 0, 0); }

    /**
     * @brief Static function to check if the operating system is of the Windows NT platform.
     * @return TRUE if Windows NT platform, FALSE otherwise.
     */
    static BOOL IsWindowsNTPlatform() { return IsWindowsXPOrGreater(); }
#endif //  _MSC_VER >= 1700
};

class NDISAPI_API CNdisApi
{
    class CWow64Helper;

public:
    CNdisApi(const TCHAR* pszFileName = _T(DRIVER_NAME_A));
    virtual ~CNdisApi();

#if _MSC_VER >= 1800 && !defined(_USING_V110_SDK71_)
    CNdisApi(const CNdisApi& other) = delete;
    CNdisApi(CNdisApi&& other) = delete;
    CNdisApi& operator=(const CNdisApi& other) = delete;
    CNdisApi& operator=(CNdisApi&& other) = delete;
#endif // _MSC_VER >= 1800 && !defined(_USING_V110_SDK71_)

private:
    // Private member functions
    BOOL SetPacketFilterCacheState(BOOL bState) const;
    BOOL SetPacketFragmentCacheState(BOOL bState) const;
    // Private static functions
    static BOOL IsNdiswanInterface(LPCSTR adapterName, LPCSTR ndiswanName);

public:
    // Driver services
    BOOL    DeviceIoControl(DWORD dwService, void* BuffIn, int SizeIn, void* BuffOut, int SizeOut, LPDWORD SizeRet = NULL, LPOVERLAPPED povlp = NULL) const;
    ULONG   GetVersion() const;
    BOOL    GetTcpipBoundAdaptersInfo(PTCP_AdapterList pAdapters) const;
    BOOL    SendPacketToMstcp(PETH_REQUEST pPacket) const;
    BOOL    SendPacketToAdapter(PETH_REQUEST pPacket) const;
    BOOL    ReadPacket(PETH_REQUEST pPacket) const;
    BOOL    SendPacketsToMstcp(PETH_M_REQUEST pPackets) const;
    BOOL    SendPacketsToAdapter(PETH_M_REQUEST pPackets) const;
    BOOL    ReadPackets(PETH_M_REQUEST pPackets) const;
    BOOL    SetAdapterMode(PADAPTER_MODE pMode) const;
    BOOL    GetAdapterMode(PADAPTER_MODE pMode) const;
    BOOL    FlushAdapterPacketQueue(HANDLE hAdapter) const;
    BOOL    GetAdapterPacketQueueSize(HANDLE hAdapter, PDWORD pdwSize) const;
    BOOL    SetPacketEvent(HANDLE hAdapter, HANDLE hWin32Event) const;
    BOOL    SetWANEvent(HANDLE hWin32Event) const;
    BOOL    SetAdapterListChangeEvent(HANDLE hWin32Event) const;
    BOOL    NdisrdRequest(PPACKET_OID_DATA OidData, BOOL Set) const;
    BOOL    GetRasLinks(HANDLE hAdapter, PRAS_LINKS pLinks) const;
    BOOL    SetHwPacketFilter(HANDLE hAdapter, DWORD Filter) const;
    BOOL    GetHwPacketFilter(HANDLE hAdapter, PDWORD pFilter) const;
    BOOL    SetHwPacketFilterEvent(HANDLE hAdapter, HANDLE hWin32Event) const;
    BOOL    SetPacketFilterTable(PSTATIC_FILTER_TABLE pFilterList) const;
    BOOL    AddStaticFilterFront(PSTATIC_FILTER pFilter) const;
    BOOL    AddStaticFilterBack(PSTATIC_FILTER pFilter) const;
    BOOL    InsertStaticFilter(PSTATIC_FILTER pFilter, unsigned long Position) const;
    BOOL    RemoveStaticFilter(DWORD dwFilterId) const;
    BOOL    ResetPacketFilterTable() const;
    BOOL    GetPacketFilterTableSize(PDWORD pdwTableSize) const;
    BOOL    GetPacketFilterTable(PSTATIC_FILTER_TABLE pFilterList) const;
    BOOL    GetPacketFilterTableResetStats(PSTATIC_FILTER_TABLE pFilterList) const;
    BOOL    EnablePacketFilterCache() const;
    BOOL    DisablePacketFilterCache() const;
    BOOL    EnablePacketFragmentCache() const;
    BOOL    DisablePacketFragmentCache() const;
    BOOL    IsDriverLoaded() const;
    BOOL    InitializeFastIo(PFAST_IO_SECTION pFastIo, DWORD dwSize) const;
    BOOL    AddSecondaryFastIo(PFAST_IO_SECTION pFastIo, DWORD dwSize) const;
    BOOL    ReadPacketsUnsorted(PINTERMEDIATE_BUFFER* Packets, DWORD dwPacketsNum, PDWORD pdwPacketsSuccess) const;
    BOOL    SendPacketsToAdaptersUnsorted(PINTERMEDIATE_BUFFER* Packets, DWORD dwPacketsNum, PDWORD pdwPacketSuccess) const;
    BOOL    SendPacketsToMstcpUnsorted(PINTERMEDIATE_BUFFER* Packets, DWORD dwPacketsNum, PDWORD pdwPacketSuccess) const;
    BOOL    GetIntermediateBufferPoolSize(PDWORD pdwSize) const;
    DWORD   GetBytesReturned() const;

    // Static helper routines

    static BOOL  SetMTUDecrement(DWORD dwMTUDecrement);
    static DWORD GetMTUDecrement();

    static BOOL  SetAdaptersStartupMode(DWORD dwStartupMode);
    static DWORD GetAdaptersStartupMode();

    static BOOL  SetPoolSize(DWORD dwPoolSize);
    static DWORD GetPoolSize();

    static BOOL  IsNdiswanIp(LPCSTR adapterName);
    static BOOL  IsNdiswanIpv6(LPCSTR adapterName);
    static BOOL  IsNdiswanBh(LPCSTR adapterName);

    static BOOL
        ConvertWindowsNTAdapterName(
            LPCSTR szAdapterName,
            LPSTR szUserFriendlyName,
            DWORD dwUserFriendlyNameLength
        );

    static BOOL
        ConvertWindows2000AdapterName(
            LPCSTR szAdapterName,
            LPSTR szUserFriendlyName,
            DWORD dwUserFriendlyNameLength
        );

    static BOOL
        ConvertWindows9xAdapterName(
            LPCSTR szAdapterName,
            LPSTR szUserFriendlyName,
            DWORD dwUserFriendlyNameLength
        );

    static void
        RecalculateIPChecksum(
            PINTERMEDIATE_BUFFER pPacket
        );

    static void
        RecalculateICMPChecksum(
            PINTERMEDIATE_BUFFER pPacket
        );

    static void
        RecalculateTCPChecksum(
            PINTERMEDIATE_BUFFER pPacket
        );

    static void
        RecalculateUDPChecksum(
            PINTERMEDIATE_BUFFER pPacket
        );

    static BOOL IsWindowsVistaOrLater()
    {
        return ms_Version.IsWindowsVistaOrGreater();
    }

    static BOOL IsWindows7OrLater()
    {
        return ms_Version.IsWindows7OrGreater();
    }

private:
    // Private member variables
    mutable OVERLAPPED  m_ovlp;
    mutable DWORD       m_BytesReturned;

    HANDLE              m_hFileHandle;
    BOOL                m_bIsLoadSuccessfully;

    IsWow64ProcessPtr   m_pfnIsWow64Process;
    BOOL                m_bIsWow64Process;
    CWow64Helper& m_Wow64Helper;

    static CVersionInfo ms_Version;
};

extern "C"
{
    HANDLE  __stdcall        OpenFilterDriver(const TCHAR* pszFileName = _T(DRIVER_NAME_A));
    VOID    __stdcall        CloseFilterDriver(HANDLE hOpen);
    DWORD    __stdcall       GetDriverVersion(HANDLE hOpen);
    BOOL    __stdcall        GetTcpipBoundAdaptersInfo(HANDLE hOpen, PTCP_AdapterList pAdapters);
    BOOL    __stdcall        SendPacketToMstcp(HANDLE hOpen, PETH_REQUEST pPacket);
    BOOL    __stdcall        SendPacketToAdapter(HANDLE hOpen, PETH_REQUEST pPacket);
    BOOL    __stdcall        ReadPacket(HANDLE hOpen, PETH_REQUEST pPacket);
    BOOL    __stdcall        SendPacketsToMstcp(HANDLE hOpen, PETH_M_REQUEST pPackets);
    BOOL    __stdcall        SendPacketsToAdapter(HANDLE hOpen, PETH_M_REQUEST pPackets);
    BOOL    __stdcall        ReadPackets(HANDLE hOpen, PETH_M_REQUEST pPackets);
    BOOL    __stdcall        SetAdapterMode(HANDLE hOpen, PADAPTER_MODE pMode);
    BOOL    __stdcall        GetAdapterMode(HANDLE hOpen, PADAPTER_MODE pMode);
    BOOL    __stdcall        FlushAdapterPacketQueue(HANDLE hOpen, HANDLE hAdapter);
    BOOL    __stdcall        GetAdapterPacketQueueSize(HANDLE hOpen, HANDLE hAdapter, PDWORD pdwSize);
    BOOL    __stdcall        SetPacketEvent(HANDLE hOpen, HANDLE hAdapter, HANDLE hWin32Event);
    BOOL    __stdcall        SetWANEvent(HANDLE hOpen, HANDLE hWin32Event);
    BOOL    __stdcall        SetAdapterListChangeEvent(HANDLE hOpen, HANDLE hWin32Event);
    BOOL    __stdcall        NdisrdRequest(HANDLE hOpen, PPACKET_OID_DATA OidData, BOOL Set);
    BOOL    __stdcall        GetRasLinks(HANDLE hOpen, HANDLE hAdapter, PRAS_LINKS pLinks);
    BOOL    __stdcall        SetHwPacketFilter(HANDLE hOpen, HANDLE hAdapter, DWORD Filter);
    BOOL    __stdcall        GetHwPacketFilter(HANDLE hOpen, HANDLE hAdapter, PDWORD pFilter);
    BOOL    __stdcall        SetHwPacketFilterEvent(HANDLE hOpen, HANDLE hAdapter, HANDLE hWin32Event);
    BOOL    __stdcall        SetPacketFilterTable(HANDLE hOpen, PSTATIC_FILTER_TABLE pFilterList);
    BOOL    __stdcall        AddStaticFilterFront(HANDLE hOpen, PSTATIC_FILTER pFilter);
    BOOL    __stdcall        AddStaticFilterBack(HANDLE hOpen, PSTATIC_FILTER pFilter);
    BOOL    __stdcall        InsertStaticFilter(HANDLE hOpen, PSTATIC_FILTER pFilter, unsigned long Position);
    BOOL    __stdcall        RemoveStaticFilter(HANDLE hOpen, DWORD dwFilterId);
    BOOL    __stdcall        ResetPacketFilterTable(HANDLE hOpen);
    BOOL    __stdcall        GetPacketFilterTableSize(HANDLE hOpen, PDWORD pdwTableSize);
    BOOL    __stdcall        GetPacketFilterTable(HANDLE hOpen, PSTATIC_FILTER_TABLE pFilterList);
    BOOL    __stdcall        GetPacketFilterTableResetStats(HANDLE hOpen, PSTATIC_FILTER_TABLE pFilterList);
    BOOL    __stdcall        EnablePacketFilterCache(HANDLE hOpen);
    BOOL    __stdcall        DisablePacketFilterCache(HANDLE hOpen);
    BOOL    __stdcall        EnablePacketFragmentCache(HANDLE hOpen);
    BOOL    __stdcall        DisablePacketFragmentCache(HANDLE hOpen);
    BOOL    __stdcall        SetMTUDecrement(DWORD dwMTUDecrement);
    DWORD   __stdcall        GetMTUDecrement();
    BOOL    __stdcall        SetAdaptersStartupMode(DWORD dwStartupMode);
    DWORD   __stdcall        GetAdaptersStartupMode();
    BOOL    __stdcall        SetPoolSize(DWORD dwPoolSize);
    DWORD   __stdcall        GetPoolSize();
    BOOL    __stdcall        IsDriverLoaded(HANDLE hOpen);
    BOOL    __stdcall        InitializeFastIo(HANDLE hOpen, PFAST_IO_SECTION pFastIo, DWORD dwSize);
    BOOL    __stdcall        AddSecondaryFastIo(HANDLE hOpen, PFAST_IO_SECTION pFastIo, DWORD dwSize);
    BOOL    __stdcall        ReadPacketsUnsorted(HANDLE hOpen, PINTERMEDIATE_BUFFER* Packets, DWORD dwPacketsNum, PDWORD pdwPacketsSuccess);
    BOOL    __stdcall        SendPacketsToAdaptersUnsorted(HANDLE hOpen, PINTERMEDIATE_BUFFER* Packets, DWORD dwPacketsNum, PDWORD pdwPacketSuccess);
    BOOL    __stdcall        SendPacketsToMstcpUnsorted(HANDLE hOpen, PINTERMEDIATE_BUFFER* Packets, DWORD dwPacketsNum, PDWORD pdwPacketSuccess);
    BOOL    __stdcall        GetIntermediateBufferPoolSize(HANDLE hOpen, PDWORD pdwSize);
    DWORD   __stdcall        GetBytesReturned(HANDLE hOpen);

    BOOL    __stdcall        IsNdiswanIp(LPCSTR adapterName);
    BOOL    __stdcall        IsNdiswanIpv6(LPCSTR adapterName);
    BOOL    __stdcall        IsNdiswanBh(LPCSTR adapterName);

    BOOL __stdcall
        ConvertWindowsNTAdapterName(
            LPCSTR szAdapterName,
            LPSTR szUserFriendlyName,
            DWORD dwUserFriendlyNameLength
        );

    BOOL __stdcall
        ConvertWindows2000AdapterName(
            LPCSTR szAdapterName,
            LPSTR szUserFriendlyName,
            DWORD dwUserFriendlyNameLength
        );

    BOOL __stdcall
        ConvertWindows9xAdapterName(
            LPCSTR szAdapterName,
            LPSTR szUserFriendlyName,
            DWORD dwUserFriendlyNameLength
        );

    void __stdcall
        RecalculateIPChecksum(
            PINTERMEDIATE_BUFFER pPacket
        );

    void __stdcall
        RecalculateICMPChecksum(
            PINTERMEDIATE_BUFFER pPacket
        );

    void __stdcall
        RecalculateTCPChecksum(
            PINTERMEDIATE_BUFFER pPacket
        );

    void __stdcall
        RecalculateUDPChecksum(
            PINTERMEDIATE_BUFFER pPacket
        );
}
```

`ndisapi.net/Stdafx.h`:

```h
/*************************************************************************/
/*                Copyright (c) 2000-2018 NT Kernel Resources.           */
/*                           All Rights Reserved.                        */
/*                          http://www.ntkernel.com                      */
/*                           ndisrd@ntkernel.com                         */
/*                                                                       */
/* Module Name:  stdafx.h                                                */
/*                                                                       */
/* Abstract: include file for standard system include files,             */
/* or project specific include files that are used frequently,           */
/* but are changed infrequently                                          */
/*                                                                       */
/* Environment:                                                          */
/*   .NET User mode                                                      */
/*                                                                       */
/*************************************************************************/

#pragma once

#include <WinSock2.h>
#include <ws2ipdef.h>
#include <Mstcpip.h>
#include <tchar.h>

#include <msclr\marshal.h>
#include <msclr\marshal_cppstd.h>

#include <vector>
#include <algorithm>

#include "ndisapicl.h"
#include "../include/common.h"
#include "../include/ndisapi.h"





```

`ndisapi.net/app.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//
// Icon placed first or with lowest ID value becomes application icon
LANGUAGE 9, 1
1           ICON         "app.ico"

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE  
BEGIN
    "resource.h\0"
    "\0"
END

2 TEXTINCLUDE  
BEGIN
    "#include ""afxres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE  
BEGIN
    "\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`ndisapi.net/ndisapicl.h`:

```h
/*************************************************************************/
/*                    Copyright (c) 2000-2024 NT KERNEL.                 */
/*                           All Rights Reserved.                        */
/*                          https://www.ntkernel.com                     */
/*                           ndisrd@ntkernel.com                         */
/*                                                                       */
/* Module Name:  ndisapicl.h                                             */
/*                                                                       */
/* Abstract: .NET NdisApi interface                                      */
/*                                                                       */
/* Environment:                                                          */
/*   .NET User mode                                                      */
/*                                                                       */
/*************************************************************************/

#pragma once

using namespace System;
using namespace System::Net;
using namespace System::Net::NetworkInformation;
using namespace System::Net::Sockets; 
using namespace System::Collections::Generic;
using namespace System::Runtime::InteropServices;
using namespace System::Threading;
using namespace msclr::interop;

// Forward declaration of CNdisApi class
class CNdisApi;
struct _INTERMEDIATE_BUFFER;
struct _ETH_REQUEST;
struct _ETH_M_REQUEST;
struct _STATIC_FILTER_TABLE;

namespace NdisApi {
	
	[FlagsAttribute]
	public enum class MSTCP_FLAGS : UInt32
	{
		/// <summary>
		/// Receive packets sent by MSTCP to network interface.
		/// The original packet is dropped.
		/// </summary>
		MSTCP_FLAG_SENT_TUNNEL = 0x00000001,

		/// <summary>
		/// Receive packets sent from network interface to MSTCP.
		/// The original packet is dropped.
		/// </summary>
		MSTCP_FLAG_RECV_TUNNEL = 0x00000002,

		/// <summary>
		/// Receive packets sent from and to MSTCP and network interface.
		/// The original packet is dropped.
		/// </summary>
		MSTCP_FLAG_TUNNEL = MSTCP_FLAG_SENT_TUNNEL | MSTCP_FLAG_RECV_TUNNEL,

		/// <summary>
		/// Receive packets sent by MSTCP to network interface.
		/// The original packet is still delivered to the network.
		/// </summary>
		MSTCP_FLAG_SENT_LISTEN = 0x00000004,

		/// <summary>
		/// Receive packets sent from network interface to MSTCP
		/// The original packet is still delivered to the network.
		/// </summary>
		MSTCP_FLAG_RECV_LISTEN = 0x00000008,

		/// <summary>
		/// Receive packets sent from and to MSTCP and network interface.
		/// The original packet is dropped.
		/// </summary>
		MSTCP_FLAG_LISTEN = MSTCP_FLAG_SENT_LISTEN | MSTCP_FLAG_RECV_LISTEN,

		/// <summary>
		/// In promiscuous mode TCP/IP stack receives all.
		/// </summary>
		MSTCP_FLAG_FILTER_DIRECT = 0x00000010,

		/// <summary>
		/// Passes loopback packet for processing.
		/// </summary>
		MSTCP_FLAG_LOOPBACK_FILTER = 0x00000020,

		/// <summary>
		/// Silently drop loopback packets.
		/// </summary>
		MSTCP_FLAG_LOOPBACK_BLOCK = 0x00000040

	};

	[FlagsAttribute]
	public enum struct PACKET_FLAG : UInt32
	{
		/// <summary>
		/// The packet was intercepted from MSTCP.
		/// </summary>
		PACKET_FLAG_ON_SEND = 0x00000001,

		/// <summary>
		/// The packet was intercepted from the network interface.
		/// </summary>
		PACKET_FLAG_ON_RECEIVE = 0x00000002,

		/// <summary>
		/// Directional flag, can be applied in filter
		/// </summary>
		PACKET_FLAG_ON_SEND_RECEIVE = PACKET_FLAG_ON_SEND | PACKET_FLAG_ON_RECEIVE
	};

	public enum struct NDIS_MEDIUM : UInt32
	{
		NdisMediumDefault, // Extra added default value
		NdisMedium802_3,
		NdisMedium802_5,
		NdisMediumFddi,
		NdisMediumWan,
		NdisMediumLocalTalk,
		NdisMediumDix,
		NdisMediumArcnetRaw,
		NdisMediumArcnet878_2,
		NdisMediumAtm,
		NdisMediumWirelessWan,
		NdisMediumIrda,
		NdisMediumBpc,
		NdisMediumCoWan,
		NdisMedium1394,
		NdisMediumInfiniBand,
		NdisMediumTunnel,
		NdisMediumNative802_11,
		NdisMediumLoopback,
		NdisMediumWiMAX,
		NdisMediumIP,
		NdisMediumMax
	};

	/**
	 * \brief Represents basic information for the network interface.
	 */
	public ref class NetworkAdapter
	{
		/// <summary>
		/// Network adapter system (internal) name.
		/// </summary>
		String^ _adapterName;
		/// <summary>
		/// Network adapter user-friendly name.
		/// </summary>
		String^ _adapterFriendlyName;
		/// <summary>
		/// Network adapter handle value.
		/// </summary>
		IntPtr _adapterHandle;
		/// <summary>
		/// Network adapter NDIS medium (NdisMedium802_3, NdisMediumWirelessWan etc…).
		/// </summary>
		NDIS_MEDIUM _adapterMedium;
		/// <summary>
		/// Network adapter current physical address.
		/// </summary>
		PhysicalAddress^ _adapterCurrentAddress;
		/// <summary>
		/// A maximum transmission unit (MTU). MTU – the largest frame size, specified in octets (eight-bit bytes)
		/// that can be sent through the network interface. 
		/// </summary>
		UInt16 _adapterMtu;

	public:
		NetworkAdapter(
			String^	adapterName,
			String^ adapterFriendlyName,
			IntPtr	adapterHandle,
			NDIS_MEDIUM	adapterMedium,
			PhysicalAddress^ adapterCurrentAddress,
			UInt16	adapterMtu) : 
				_adapterName(adapterName),
				_adapterFriendlyName(adapterFriendlyName),
				_adapterHandle(adapterHandle),
				_adapterMedium(adapterMedium),
				_adapterCurrentAddress(adapterCurrentAddress),
				_adapterMtu(adapterMtu) {}

		/// <summary>
		/// Network adapter system (internal) name.
		/// </summary>
		property String^ Name { String^ get() { return _adapterName; } }
		/// <summary>
		/// Network adapter user-friendly name.
		/// </summary>
		property String^ FriendlyName { String^ get() { return _adapterFriendlyName; } }
		/// <summary>
		/// Network adapter handle value.
		/// </summary>
		property IntPtr Handle { IntPtr get() { return _adapterHandle; } }
		/// <summary>
		/// Network adapter NDIS medium (NdisMedium802_3, NdisMediumWirelessWan etc…).
		/// </summary>
		property NDIS_MEDIUM Medium { NDIS_MEDIUM get() { return _adapterMedium; } }
		/// <summary>
		/// Network adapter current physical address.
		/// </summary>
		property PhysicalAddress^ CurrentAddress { PhysicalAddress^ get() { return _adapterCurrentAddress; } }
		/// <summary>
		/// A maximum transmission unit (MTU). MTU – the largest frame size, specified in octets (eight-bit bytes)
		/// that can be sent through the network interface. 
		/// </summary>
		property UInt16 Mtu { UInt16 get() { return _adapterMtu; } }
	};

	/**
	 * \brief Represents raw network packet.
	 */
	public ref class RawPacket
	{
	public:
		[FlagsAttribute]
		enum struct CHECKSUM_FLAG : UInt32 
		{
			/// <summary>
			/// Recalculate IP version 4 checksum
			/// </summary>
			RECALCULATE_IP_V4 = 0x00000001,
			/// <summary>
			/// Recalculate ICMP checksum for IP version 4 packet
			/// </summary>
			RECALCULATE_ICMP_V4 = 0x00000002,
			/// <summary>
			/// Recalculate TCP checksum for IP version 4 packet
			/// </summary>
			RECALCULATE_TCP_V4 = 0x00000004,
			/// <summary>
			/// Recalculate UDP checksum for IP version 4 packet
			/// </summary>
			RECALCULATE_UDP_V4 = 0x00000008
		};
	private:
		/// <summary>
		/// Packet direction flags(PACKET_FLAG_ON_SEND, PACKET_FLAG_ON_RECEIVE).
		/// </summary>
		PACKET_FLAG _deviceFlags;
		/// <summary>
		/// NDIS level flags of the network packet. This field can be a combination of the NDIS_FLAGS_XXX (defined in ndis.h).
		/// </summary>
		UInt32 _flags;
		/// <summary>
		/// 802.1q VLAN Tag.
		/// </summary>
		UInt32 _dot1q;
		/// <summary>
		/// Filter ID value for incoming packets specifies the filter index which redirected the packet for processing.
		/// </summary>
		UInt32 _filterId;
		/// <summary>
		/// Combination of checksum recalculate flags (RECALCULATE_IP_V4, RECALCULATE_ICMP_V4, RECALCULATE_TCP_V4, RECALCULATE_UDP_V4).
		/// </summary>
		CHECKSUM_FLAG _checksums;
		/// <summary>
		/// Raw packet data buffer.
		/// </summary>
		array<Byte>^ _buffer;

	public:
		/// <summary>
		/// Packet direction flags(PACKET_FLAG_ON_SEND, PACKET_FLAG_ON_RECEIVE).
		/// </summary>
		property PACKET_FLAG DeviceFlags {
			PACKET_FLAG get() { return _deviceFlags; }
			void set(PACKET_FLAG deviceFlags) { _deviceFlags = deviceFlags; }
		}

		/// <summary>
		/// NDIS level flags of the network packet. This field can be a combination of the NDIS_FLAGS_XXX (defined in ndis.h).
		/// </summary>
		property UInt32	NdisFlags {
			UInt32 get() { return _flags; } 
			void set(UInt32 flags) { _flags = flags; }
		}

		/// <summary>
		/// 802.1q VLAN Tag.
		/// </summary>
		property UInt32	Dot1q {
			UInt32 get() { return _dot1q; }
			void set(UInt32 dot1q) { _dot1q = dot1q;	}
		}

		/// <summary>
		/// Filter ID value for incoming packets specifies the filter index which redirected the packet for processing.
		/// </summary>
		property UInt32	FilterId {
			UInt32 get() { return _filterId; } 
			void set(UInt32 filterId) { _filterId = filterId; }
		}

		/// <summary>
		/// Combination of checksum recalculate flags (RECALCULATE_IP_V4, RECALCULATE_ICMP_V4, RECALCULATE_TCP_V4, RECALCULATE_UDP_V4).
		/// </summary>
		property CHECKSUM_FLAG Checksums {
			CHECKSUM_FLAG get() { return _checksums; }
			void set(CHECKSUM_FLAG checksums) { _checksums = checksums; }
		}

		/// <summary>
		/// Raw packet data buffer.
		/// </summary>
		property array<Byte>^ Data { 
			array<Byte>^ get() { return _buffer; } 
			void set(array<Byte>^ buffer) { _buffer = buffer; }
		}
	};

	/**
	 * \brief Wrapper for an array of _INTERMEDIATE_BUFFER and associated _ETH_M_REQUEST
	 */
	public ref class NdisBufferResource
	{
		static const Int32 defaultBufferSize = 32;
	public:
		NdisBufferResource() : NdisBufferResource(defaultBufferSize) {}
		NdisBufferResource(Int32 size);
		!NdisBufferResource();
		~NdisBufferResource();
		property _INTERMEDIATE_BUFFER* Buffer {_INTERMEDIATE_BUFFER* get() { return _intermediateBufferPtr; }}
		property _ETH_M_REQUEST* Request {_ETH_M_REQUEST* get() { return reinterpret_cast<_ETH_M_REQUEST*>(_dataRequest); }}
		property Int32 Size {Int32 get() { return _size; }}
	private:
		_INTERMEDIATE_BUFFER* _intermediateBufferPtr;
		uint8_t* _dataRequest;
		Int32	_size;
	};

	/**
	 * \brief Wrapper class for the PACKET_OID_DATA used to set/query information via NDIS_REQUEST.
	 */
	public ref class PacketOidData
	{
		/// <summary>
		/// The adapter’s handle value for set/query operation.
		/// </summary>
		IntPtr			_hAdapter;
		/// <summary>
		/// his is a numeric identifier that indicates the type of query/set function to perform on
		/// the adapter through the PacketRequest function.
		/// </summary>
		UInt32			_oid;
		/// <summary>
		/// Data buffer to pass or receive information from the network interface.
		/// </summary>
		array<Byte>^ 	_buffer;
	public:
		/// <summary>
		/// The adapter’s handle value for set/query operation.
		/// </summary>
		property IntPtr Adapter {
			IntPtr get() { return _hAdapter; }
			void set(IntPtr value) { _hAdapter = value; }
		}

		/// <summary>
		/// his is a numeric identifier that indicates the type of query/set function to perform on
		/// the adapter through the PacketRequest function.
		/// </summary>
		property UInt32 Oid {
			UInt32 get() { return _oid; }
			void set(UInt32 value) { _oid = value; }
		}

		/// <summary>
		/// Data buffer to pass or receive information from the network interface.
		/// </summary>
		property array<Byte>^ Data {
			array<Byte>^ get() { return _buffer; }
			void set(array<Byte>^ buffer) { _buffer = buffer; }
		}
	};

	public ref class RasLinkInfo{

		UInt32				_linkSpeed;
		UInt32				_maximumTotalSize;
		PhysicalAddress^	_remoteAddress;
		PhysicalAddress^	_localAddress;		
		array<Byte>^ 		_buffer;

	public:
		RasLinkInfo(
			UInt32				linkSpeed,
			UInt32				maximumTotalSize,
			PhysicalAddress^	remoteAddress,
			PhysicalAddress^	localAddress,
			array<Byte>^ 		buffer) :
			_linkSpeed(linkSpeed),
			_maximumTotalSize(maximumTotalSize),
			_remoteAddress(remoteAddress),
			_localAddress(localAddress),
			_buffer(buffer) {}

		// Specifies the speed of the link, in units of 100 bps.
		// Zero indicates no change from the speed returned when the protocol called NdisRequest with OID_GEN_LINK_SPEED. 
		property UInt32  LinkSpeed {UInt32 get() { return _linkSpeed; }}

		// Specifies the maximum number of bytes per packet that the protocol can send over the network.
		// Zero indicates no change from the value returned when the protocol called NdisRequest with OID_GEN_MAXIMUM_TOTAL_SIZE. 
		property UInt32  MaximumTotalSize {UInt32 get() { return _maximumTotalSize; }}

		// Represents the address of the remote node on the link in Ethernet-style format. NDISWAN supplies this value.
		property PhysicalAddress^  RemoteAddress {PhysicalAddress^ get() { return _remoteAddress; }}
		
		// Represents the protocol-determined context for indications on this link in Ethernet-style format.
		property PhysicalAddress^  LocalAddress {PhysicalAddress^ get() { return _localAddress; }}
	
		// Containing protocol-specific information supplied by a higher-level component that makes connections through NDISWAN
		// to the appropriate protocol(s). Maximum observed size is 600 bytes on Windows Vista, 1200 on Windows 10
		property array<Byte>^  ProtocolBuffer {array<Byte>^ get() { return _buffer; }} 
	};

	// Represents 802.3 header filter
	public ref class Eth802dot3Filter
	{
	public:
		[FlagsAttribute]
		enum struct ETH_802_3_FLAGS : UInt32
		{
			/// <summary>
			/// The eth 802 3 source address.
			/// </summary>
			ETH_802_3_SRC_ADDRESS = 0x00000001,

			/// <summary>
			/// The eth 802 3 destination address.
			/// </summary>
			ETH_802_3_DEST_ADDRESS = 0x00000002,

			/// <summary>
			/// The eth 802 3 protocol.
			/// </summary>
			ETH_802_3_PROTOCOL = 0x00000004
		};

	private:
		ETH_802_3_FLAGS		_validFields;
		PhysicalAddress^	_sourceAddress;
		PhysicalAddress^	_destinationAddress;
		UInt16				_networkProtocol;

	public:

		String^ ToString() override
		{
			return "Eth802dot3Filter [ " + ((_sourceAddress != nullptr) ? ("SourceAddress = " + _sourceAddress->ToString()):"") +
				((_destinationAddress != nullptr) ? (" DestinationAddress = " + _destinationAddress->ToString()):"") +
				(((_validFields & ETH_802_3_FLAGS::ETH_802_3_PROTOCOL) == ETH_802_3_FLAGS::ETH_802_3_PROTOCOL) ? 
				(" Protocol = " + _networkProtocol.ToString()):"") + " ]";
		}

		// Specifies which of the fields below contain valid values and should be matched against the packet
		property ETH_802_3_FLAGS ValidFields {
			ETH_802_3_FLAGS get() { return _validFields; }
			void set(ETH_802_3_FLAGS value) { _validFields = value; }
		};

		// Source MAC address
		property PhysicalAddress^ SrcAddress {
			PhysicalAddress^ get() { return _sourceAddress; }
			void set(PhysicalAddress^ value) { _sourceAddress = value; }
		}

		// Destination MAC address
		property PhysicalAddress^ DestAddress {
			PhysicalAddress^ get() { return _destinationAddress; }
			void set(PhysicalAddress^ value) { _destinationAddress = value; }
		}

		// EtherType
		property UInt16 Protocol {
			UInt16 get() { return _networkProtocol; }
			void set(UInt16 value) { _networkProtocol = value; }
		}

		Eth802dot3Filter(
			ETH_802_3_FLAGS	validFields,
			PhysicalAddress^ sourceAddress,
			PhysicalAddress^ destinationAddress,
			UInt16	networkProtocol) :
			_validFields(validFields),
			_sourceAddress(sourceAddress),
			_destinationAddress(destinationAddress),
			_networkProtocol(networkProtocol) {}
	};

	// Represents IP subnet or range of IP addresses
	public ref class IpNetRange
	{
	public:
		enum struct ADDRESS_TYPE : UInt32
		{
			IP_SUBNET_TYPE = 0x00000001,
			IP_RANGE_TYPE = 0x00000002
		};

	private:
		ADDRESS_TYPE	_addressType;
		IPAddress^		_firstIp;
		IPAddress^		_secondIp;

	public:
		String^ ToString() override
		{
			if (_addressType == ADDRESS_TYPE::IP_SUBNET_TYPE)
			{
				return "IpNetRange [ " + "network: " + _firstIp->ToString() + " mask: " + _secondIp->ToString() + " ]";
			}
			else if (_addressType == ADDRESS_TYPE::IP_RANGE_TYPE)
			{
				return "IpNetRange [ " + "start IP: " + _firstIp->ToString() + " end IP: " + _secondIp->ToString() + " ]";
			}
			else
			{
				return "IpNetRange: UNDEFINED TYPE";
			}
		}
		
		// Specifies which of the IP v4 address types is used below
		property ADDRESS_TYPE AddressType {
			ADDRESS_TYPE get() { return _addressType; }
			void set(ADDRESS_TYPE value) { _addressType = value; }
		}

		property IPAddress^	NetworkAddress {
			IPAddress^ get() { return _firstIp; }
			void set(IPAddress^ value) { _firstIp = value; }
		}

		property IPAddress^	NetworkMask {
			IPAddress^ get() { return _secondIp; }
			void set(IPAddress^ value) { _secondIp = value; }
		}

		property IPAddress^	StartRange {
			IPAddress^ get() { return _firstIp; }
			void set(IPAddress^ value) { _firstIp = value; }
		}

		property IPAddress^	EndRange {
			IPAddress^ get() { return _secondIp; }
			void set(IPAddress^ value) { _secondIp = value; }
		}

		IpNetRange(
			ADDRESS_TYPE addressType,
			IPAddress^ firstIp,
			IPAddress^ secondIp) :
			_addressType(addressType),
			_firstIp(firstIp),
			_secondIp(secondIp) {}
	};

	// Represent IP level filter
	public ref class IpAddressFilter
	{
	public:
		[FlagsAttribute]
		enum struct IP_FILTER_FIELDS : UInt32
		{
			IP_FILTER_SRC_ADDRESS = 0x00000001,
			IP_FILTER_DEST_ADDRESS = 0x00000002,
			IP_FILTER_PROTOCOL = 0x00000004
		};
	private:
		AddressFamily		_addressFamily;
		IP_FILTER_FIELDS	_validFields;
		IpNetRange^			_sourceAddress;
		IpNetRange^			_destinationAddress;
		Byte				_nextProtocol;		
	public:
		String^ ToString() override
		{
			return "IpAddressFilter [ " + ((_sourceAddress != nullptr) ? ("SourceAddress = " + _sourceAddress->ToString()) : "") +
				((_destinationAddress != nullptr) ? (" DestinationAddress = " + _destinationAddress->ToString()) : "") +
				(((_validFields & IP_FILTER_FIELDS::IP_FILTER_PROTOCOL) == IP_FILTER_FIELDS::IP_FILTER_PROTOCOL) ? 
				(" Protocol = " + _nextProtocol.ToString()) : "") + " ]";
		}

		// Specifies IP address family (IPv6/IPv4)
		property AddressFamily	IpAddressFamily {
			AddressFamily get() { return _addressFamily; }
			void set(AddressFamily value) { _addressFamily = value; }
		}

		// Specifies which of the fields below contain valid values and should be matched against the packet
		property IP_FILTER_FIELDS	ValidFields {
			IP_FILTER_FIELDS get() { return _validFields; }
			void set(IP_FILTER_FIELDS value) { _validFields = value; }
		}

		// Source IP address
		property IpNetRange^ SrcAddress {
			IpNetRange^ get() { return _sourceAddress; }
			void set(IpNetRange^ value) { _sourceAddress = value; }
		}

		// Destination IP address	
		property IpNetRange^ DestAddress {
			IpNetRange^ get() { return _destinationAddress; }
			void set(IpNetRange^ value) { _destinationAddress = value; }
		}

		// Specifies next protocol
		property Byte Protocol {
			Byte get() { return _nextProtocol; }
			void set(Byte value) { _nextProtocol = value; }
		}

		IpAddressFilter(
			AddressFamily addressFamily,
			IP_FILTER_FIELDS	validFields,
			IpNetRange^	sourceAddress,
			IpNetRange^ destinationAddress,
			Byte nextProtocol):
			_addressFamily(addressFamily),
			_validFields(validFields),
			_sourceAddress(sourceAddress),
			_destinationAddress(destinationAddress),
			_nextProtocol(nextProtocol){}
	};

	// Represents TCP/UDP level filter
	public ref class TcpUdpFilter
	{
	public:
		[FlagsAttribute]
		enum struct TCPUDP_FILTER_FIELDS
		{
			/// <summary>
			/// The TCP/UDP source port.
			/// </summary>
			TCPUDP_SRC_PORT = 0x00000001,

			/// <summary>
			/// The TCP/UDP destination port.
			/// </summary>
			TCPUDP_DEST_PORT = 0x00000002,

			/// <summary>
			/// The TCP flags.
			/// </summary>
			TCPUDP_TCP_FLAGS = 0x00000004
		};

		value struct PortRange {
			UInt16 startRange;
			UInt16 endRange;

			String^ ToString() override
			{
				return "PortRange [ start = " + startRange.ToString() + " end = " + endRange.ToString() + " ]";
			}
		};

	private:
		TCPUDP_FILTER_FIELDS	_validFields;
		PortRange				_sourcePort;
		PortRange				_destPort;
		Byte					_tcpFlags;
	
	public:
		String^ ToString() override
		{
			return "TcpUdpFilter [ " + (((_validFields & TCPUDP_FILTER_FIELDS::TCPUDP_SRC_PORT) == TCPUDP_FILTER_FIELDS::TCPUDP_SRC_PORT) ? 
				("Source Port = " + _sourcePort.ToString()) : "") +
				(((_validFields & TCPUDP_FILTER_FIELDS::TCPUDP_DEST_PORT) == TCPUDP_FILTER_FIELDS::TCPUDP_DEST_PORT) ? 
				(" Destination Port = " + _destPort.ToString()) : "") +
				(((_validFields & TCPUDP_FILTER_FIELDS::TCPUDP_TCP_FLAGS) == TCPUDP_FILTER_FIELDS::TCPUDP_TCP_FLAGS) ? 
				(" Protocol = " + _tcpFlags.ToString()) : "") + " ]";
		}

		// Specifies which of the fields below contain valid values and should be matched against the packet
		property TCPUDP_FILTER_FIELDS ValidFields {
			TCPUDP_FILTER_FIELDS get() { return _validFields; }
			void set(TCPUDP_FILTER_FIELDS value) { _validFields = value; }
		};

		// Source port
		property PortRange	SrcPort {
			PortRange get() { return _sourcePort; }
			void set(PortRange value) { _sourcePort = value; }
		};

		// Destination port
		property PortRange	DestPort {
			PortRange get() { return _destPort; }
			void set(PortRange value) { _destPort = value; }
		};

		// TCP flags combination
		property Byte TCPFlags {
			Byte get() { return _tcpFlags; }
			void set(Byte value) { _tcpFlags = value; }
		}

		TcpUdpFilter(
			TCPUDP_FILTER_FIELDS validFields,
			PortRange sourcePort,
			PortRange destPort,
			Byte tcpFlags):
			_validFields(validFields),
			_sourcePort(sourcePort),
			_destPort(destPort),
			_tcpFlags(tcpFlags){}
	};

	public ref class StaticFilter
	{
	public:
		enum struct FILTER_PACKET_ACTION : UInt32
		{
			/// <summary>
			/// Pass packet if if matches the filter
			/// </summary>
			FILTER_PACKET_PASS = 0x00000001, 
			/// <summary>
			/// Drop packet if it matches the filter
			/// </summary>
			FILTER_PACKET_DROP = 0x00000002,
			/// <summary>
			/// Redirect packet to WinpkFilter client application
			/// </summary>
			FILTER_PACKET_REDIRECT = 0x00000003, 
			/// <summary>
			/// Redirect packet to WinpkFilter client application and pass over network (listen mode)
			/// </summary>
			FILTER_PACKET_PASS_RDR = 0x00000004, 
			/// <summary>
			/// Redirect packet to WinpkFilter client application and drop it, e.g. log but remove from the flow (listen mode)
			/// </summary>
			FILTER_PACKET_DROP_RDR = 0x00000005
		};

		[FlagsAttribute]
		enum struct STATIC_FILTER_FIELDS : UInt32
		{
			/// <summary>
			/// Match packet against data link layer filter.
			/// </summary>
			DATA_LINK_LAYER_VALID = 0x00000001,

			/// <summary>
			/// Match packet against network layer filter.
			/// </summary>
			NETWORK_LAYER_VALID = 0x00000002,

			/// <summary>
			/// Match packet against transport layer filter.
			/// </summary>
			TRANSPORT_LAYER_VALID = 0x00000004
		};
	
	private:
		IntPtr					_adapterHandle; 
		PACKET_FLAG				_directionFlags;
		FILTER_PACKET_ACTION	_filterAction;
		STATIC_FILTER_FIELDS	_validFields;
												
		UInt32				_lastReset;		
		UInt64				_packetsIn;		
		UInt64				_bytesIn;			
		UInt64				_packetsOut;		
		UInt64				_bytesOut;			

		Eth802dot3Filter^	_dataLinkFilter;
		IpAddressFilter^	_networkFilter;
		TcpUdpFilter^		_transportFilter;

	public:
		StaticFilter() {}

		StaticFilter(
			IntPtr adapterHandle,
			PACKET_FLAG directionFlags,
			FILTER_PACKET_ACTION filterAction,
			STATIC_FILTER_FIELDS validFields,
			Eth802dot3Filter^ dataLinkFilter,
			IpAddressFilter^ networkFilter,
			TcpUdpFilter^ transportFilter
			):	_adapterHandle(adapterHandle),
				_directionFlags(directionFlags),
				_filterAction(filterAction),
				_validFields(validFields),
				_dataLinkFilter(dataLinkFilter),
				_networkFilter(networkFilter),
				_transportFilter(transportFilter){}

		String^ ToString() override
		{
			return "StaticFilter [ adapter = " + _adapterHandle.ToString("x") + " direction = " + _directionFlags.ToString() +
				" action = " + _filterAction.ToString() + " reset_timestamp = " + _lastReset.ToString("x") +
				" packets_in = " + _packetsIn.ToString() + " bytes_in = " + _bytesIn.ToString() +
				" packets_out = " + _packetsOut.ToString() + " bytes_out = " + _bytesOut.ToString() + " " +
				((_dataLinkFilter != nullptr) ? (_dataLinkFilter->ToString() + " ") : "")  +
				((_networkFilter != nullptr) ? (_networkFilter->ToString() + " ") : "") + 
				((_transportFilter != nullptr) ? _transportFilter->ToString() : "") + " ]";
		}

		// Adapter handle extended to 64 bit size for structure compatibility across x64 and x86
		property IntPtr	Adapter {
			IntPtr get() { return _adapterHandle; }
			void set(IntPtr value) { _adapterHandle = value; }
		}

		// PACKET_FLAG_ON_SEND or/and PACKET_FLAG_ON_RECEIVE
		property PACKET_FLAG DirectionFlags {
			PACKET_FLAG get() { return _directionFlags; }
			void set(PACKET_FLAG value) { _directionFlags = value; }
		}

		// FILTER_PACKET_XXX
		property FILTER_PACKET_ACTION FilterAction {
			FILTER_PACKET_ACTION get() { return _filterAction; }
			void set(FILTER_PACKET_ACTION value) { _filterAction = value; }
		}

		// Specifies which of the fields below contain valid values and should be matched against the packet
		property STATIC_FILTER_FIELDS ValidFields {
			STATIC_FILTER_FIELDS get() { return _validFields; }
			void set(STATIC_FILTER_FIELDS value) { _validFields = value; }
		};
		
		// Statistics for the filter:
		// Time of the last counters reset (in seconds passed since 1 Jan 1980)
		property UInt32 LastReset {
			UInt32 get() { return _lastReset; }
			void set(UInt32 value) { _lastReset = value; }
		};

		// Incoming packets passed through this filter
		property UInt64	PacketsIn {
			UInt64 get() { return _packetsIn; }
			void set(UInt64 value) { _packetsIn = value; }
		};

		// Incoming bytes passed through this filter
		property UInt64	BytesIn {
			UInt64 get() { return _bytesIn; }
			void set(UInt64 value) { _bytesIn = value; }
		};

		// Outgoing packets passed through this filter
		property UInt64	PacketsOut {
			UInt64 get() { return _packetsOut; }
			void set(UInt64 value) { _packetsOut = value; }
		};

		// Outgoing bytes passed through this filter
		property UInt64	BytesOut {
			UInt64 get() { return _bytesOut; }
			void set(UInt64 value) { _bytesOut = value; }
		};

		property Eth802dot3Filter^	DataLinkFilter {
			Eth802dot3Filter^ get() { return _dataLinkFilter; }
			void set(Eth802dot3Filter^ value) { _dataLinkFilter = value; }
		}

		property IpAddressFilter^ NetworkFilter {
			IpAddressFilter^ get() { return _networkFilter; }
			void set(IpAddressFilter^ value) { _networkFilter = value; }
		}

		property TcpUdpFilter^ TransportFilter {
			TcpUdpFilter^ get() { return _transportFilter; }
			void set(TcpUdpFilter^ value) { _transportFilter = value; }
		}
	};

	public ref class NdisApiDotNet
	{
	private:
		CNdisApi * m_pNdisApi;

	public:
		NdisApiDotNet(String^ deviceName);
		!NdisApiDotNet();
		~NdisApiDotNet();

		UInt32									GetVersion();
		Tuple<Boolean, List<NetworkAdapter^>^>^	GetTcpipBoundAdaptersInfo();
		Boolean									SendPacketToMstcp(IntPtr hAdapter, RawPacket^ packet);
		Boolean									SendPacketToAdapter(IntPtr hAdapter, RawPacket^ packet);
		RawPacket^								ReadPacket(IntPtr hAdapter);
		Boolean									SendPacketsToMstcp(IntPtr hAdapter, NdisBufferResource^ packetBuffer, List<RawPacket^>^ packetList);
		Boolean									SendPacketsToAdapter(IntPtr hAdapter, NdisBufferResource^ packetBuffer, List<RawPacket^>^ packetList);
		Tuple<Boolean, List<RawPacket^>^>^		ReadPackets(IntPtr hAdapter, NdisBufferResource^ packetBuffer);
		Boolean									SetAdapterMode(IntPtr hAdapter, MSTCP_FLAGS filterFlags);
		Boolean									GetAdapterMode(IntPtr hAdapter, [Out]MSTCP_FLAGS% filterFlags);
		Boolean									FlushAdapterPacketQueue(IntPtr hAdapter);
		Boolean									GetAdapterPacketQueueSize(IntPtr hAdapter, [Out]UInt32% queueSize);
		Boolean									SetPacketEvent(IntPtr hAdapter, ManualResetEvent^ eventObject);
		Boolean									SetWANEvent(ManualResetEvent^ eventObject);
		Boolean									SetAdapterListChangeEvent(ManualResetEvent^ eventObject);
		Boolean									NdisrdRequest(PacketOidData^ oidData, Boolean bSet);
		Tuple<Boolean, List<RasLinkInfo^>^>^	GetRasLinks(IntPtr hAdapter);
		Boolean									SetHwPacketFilter(IntPtr hAdapter, UInt32 hwFilter);
		Boolean									GetHwPacketFilter(IntPtr hAdapter, [Out]UInt32% hwFilter);
		Boolean									SetHwPacketFilterEvent(IntPtr hAdapter, ManualResetEvent^ eventObject);
		Boolean									SetPacketFilterTable(List<StaticFilter^>^ filterList);
		Boolean									ResetPacketFilterTable();
		Boolean									GetPacketFilterTableSize(UInt32 % dwTableSize);
		Tuple<Boolean, List<StaticFilter^>^>^	GetPacketFilterTable();
		Tuple<Boolean, List<StaticFilter^>^>^	GetPacketFilterTableResetStats();
		Boolean									IsDriverLoaded();

		static Boolean							SetMTUDecrement(UInt32 dwMTUDecrement);
		static UInt32							GetMTUDecrement();

		static Boolean							SetAdaptersStartupMode(UInt32 dwStartupMode);
		static UInt32							GetAdaptersStartupMode();

		static Boolean							IsNdiswanIp(String^ adapterName);
		static Boolean							IsNdiswanIpv6(String^ adapterName);
		static Boolean							IsNdiswanBh(String^ adapterName);

	private:
		static String^					GetAdapterFriendlyName(std::string const& adapterName);
		static void						InitializeSendPacketRequest(IntPtr hAdapter, RawPacket ^ packet, _ETH_REQUEST& sendRequest, _INTERMEDIATE_BUFFER& intermediateBuffer);
		static void						InitializeSendPacketRequestList(IntPtr hAdapter, NdisBufferResource^ packetBuffer, List<RawPacket^>^ packetList);
		static void						ConvertToStaticFilterTable(_STATIC_FILTER_TABLE& staticFilterTable, List<StaticFilter^>^ filterList);
		static List<StaticFilter^>^		ConvertFromStaticFilterTable(_STATIC_FILTER_TABLE& staticFilterTable);
	};
}

```

`ndisapi.net/ndisapicl.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{4403C695-9939-4402-9EAB-43E88CF47997}</ProjectGuid>
    <TargetFrameworkVersion>v4.8.1</TargetFrameworkVersion>
    <Keyword>ManagedCProj</Keyword>
    <RootNamespace>ndisapicl</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>ndisapi.net</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CLRSupport>true</CLRSupport>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CLRSupport>true</CLRSupport>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CLRSupport>true</CLRSupport>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CLRSupport>true</CLRSupport>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CLRSupport>true</CLRSupport>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CLRSupport>true</CLRSupport>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <TargetName>$(SolutionName)</TargetName>
    <OutDir>$(SolutionDir)bin\.net\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <TargetName>$(SolutionName)</TargetName>
    <OutDir>$(SolutionDir)bin\.net\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <LinkIncremental>true</LinkIncremental>
    <TargetName>$(SolutionName)</TargetName>
    <OutDir>$(SolutionDir)bin\.net\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(SolutionName)</TargetName>
    <OutDir>$(SolutionDir)bin\.net\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(SolutionName)</TargetName>
    <OutDir>$(SolutionDir)bin\.net\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>$(SolutionName)</TargetName>
    <OutDir>$(SolutionDir)bin\.net\$(Platform)\$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg">
    <VcpkgEnabled>false</VcpkgEnabled>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_LIB;WIN32;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Ws2_32.lib;Advapi32.lib;</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_LIB;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Ws2_32.lib;Advapi32.lib;</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_LIB;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Ws2_32.lib;Advapi32.lib;</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>_LIB;WIN32;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Ws2_32.lib;Advapi32.lib;</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>_LIB;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Ws2_32.lib;Advapi32.lib;</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PreprocessorDefinitions>_LIB;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Ws2_32.lib;Advapi32.lib;</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\include\Common.h" />
    <ClInclude Include="..\include\ndisapi.h" />
    <ClInclude Include="..\ndisapi\iphlp.h" />
    <ClInclude Include="ndisapicl.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="Stdafx.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\ndisapi\ndisapi.cpp">
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</CompileAsManaged>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</CompileAsManaged>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</CompileAsManaged>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">false</CompileAsManaged>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</CompileAsManaged>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">false</CompileAsManaged>
    </ClCompile>
    <ClCompile Include="AssemblyInfo.cpp" />
    <ClCompile Include="ndisapicl.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="..\ndisapi\ndisapi.rc" />
    <ResourceCompile Include="app.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="app.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ndisapi.net/ndisapicl.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ndisapicl.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\ndisapi\iphlp.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\include\ndisapi.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\include\Common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ndisapicl.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AssemblyInfo.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\ndisapi\ndisapi.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="app.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
    <ResourceCompile Include="..\ndisapi\ndisapi.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="app.ico">
      <Filter>Resource Files</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`ndisapi.net/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by app.rc

```

`ndisapi.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.4.33213.308
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ndisapi.dll", "ndisapi.dll\ndisapidll.vcxproj", "{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ndisapi.lib", "ndisapi.lib\ndisapilib.vcxproj", "{7833A548-6556-4728-A28B-4F59C12CD8E7}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ndisapi.net", "ndisapi.net\ndisapicl.vcxproj", "{4403C695-9939-4402-9EAB-43E88CF47997}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "examples", "examples", "{BACE34D5-298C-42E3-84F6-28C689E469E1}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "lib", "lib", "{A7DF5839-29D7-4F6B-9CFE-6AD9AFD884CE}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "dnstrace", "examples\cpp\dnstrace\dnstrace.vcxproj", "{D0BB9E0A-F561-47C6-94C2-6CF68817F251}"
	ProjectSection(ProjectDependencies) = postProject
		{7833A548-6556-4728-A28B-4F59C12CD8E7} = {7833A548-6556-4728-A28B-4F59C12CD8E7}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ebridge", "examples\cpp\ethernet_bridge\ebridge.vcxproj", "{39D26CA7-DCD7-4BE0-A97A-18940BAF0AD8}"
	ProjectSection(ProjectDependencies) = postProject
		{7833A548-6556-4728-A28B-4F59C12CD8E7} = {7833A548-6556-4728-A28B-4F59C12CD8E7}
	EndProjectSection
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TestDotNet", "examples\dotNet\TestDotNet\TestDotNet.csproj", "{C5AD5596-0073-4453-B8DE-63659B9F0004}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "sni_inspector", "examples\cpp\sni_inspector\sni_inspector.vcxproj", "{74C8277F-1507-45D7-B95A-1DC9E04C932A}"
	ProjectSection(ProjectDependencies) = postProject
		{7833A548-6556-4728-A28B-4F59C12CD8E7} = {7833A548-6556-4728-A28B-4F59C12CD8E7}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ipv6_parser", "examples\cpp\ipv6_parser\ipv6_parser.vcxproj", "{B3074F8E-D987-43C8-AE76-589A57DCF7CF}"
	ProjectSection(ProjectDependencies) = postProject
		{7833A548-6556-4728-A28B-4F59C12CD8E7} = {7833A548-6556-4728-A28B-4F59C12CD8E7}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "capture", "examples\cpp\capture\capture.vcxproj", "{BB2DF044-0B37-4335-B705-3CA6BA95514F}"
	ProjectSection(ProjectDependencies) = postProject
		{7833A548-6556-4728-A28B-4F59C12CD8E7} = {7833A548-6556-4728-A28B-4F59C12CD8E7}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "dns_proxy", "examples\cpp\dns_proxy\dns_proxy.vcxproj", "{3C0FDE50-2F34-447A-B453-A2720C125563}"
	ProjectSection(ProjectDependencies) = postProject
		{7833A548-6556-4728-A28B-4F59C12CD8E7} = {7833A548-6556-4728-A28B-4F59C12CD8E7}
	EndProjectSection
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "C++", "C++", "{0239936A-C2D5-4F21-8494-BCA4B893911F}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "dotNet", "dotNet", "{A402BC8B-B32C-4851-B4A2-B8B84C0721E9}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "socksify", "examples\cpp\socksify\socksify.vcxproj", "{E20B38ED-BA56-4ED0-A06D-76396F2857D1}"
	ProjectSection(ProjectDependencies) = postProject
		{7833A548-6556-4728-A28B-4F59C12CD8E7} = {7833A548-6556-4728-A28B-4F59C12CD8E7}
	EndProjectSection
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{ECFD3EDE-84DB-454B-A294-9177AACF94A3}"
	ProjectSection(SolutionItems) = preProject
		README.md = README.md
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "udp2tcp", "examples\cpp\udp2tcp\udp2tcp.vcxproj", "{DAB189FD-2137-4947-A215-CB714EF875DF}"
	ProjectSection(ProjectDependencies) = postProject
		{7833A548-6556-4728-A28B-4F59C12CD8E7} = {7833A548-6556-4728-A28B-4F59C12CD8E7}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "rebind", "examples\cpp\rebind\rebind.vcxproj", "{23F95304-9B53-4513-BA4F-4F388F9A8AF8}"
	ProjectSection(ProjectDependencies) = postProject
		{7833A548-6556-4728-A28B-4F59C12CD8E7} = {7833A548-6556-4728-A28B-4F59C12CD8E7}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pcapplusplus", "examples\cpp\pcapplusplus\pcapplusplus.vcxproj", "{139FD3A5-D0F3-4068-81C9-A94FB58DC626}"
	ProjectSection(ProjectDependencies) = postProject
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6} = {B6004DA5-A081-4FF8-9D3C-7438530B8CF6}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "hyperscan", "examples\cpp\hyperscan\hyperscan.vcxproj", "{F9BAFDFC-851F-40F2-B3D9-20ABFC23DD68}"
	ProjectSection(ProjectDependencies) = postProject
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6} = {B6004DA5-A081-4FF8-9D3C-7438530B8CF6}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}.Debug|ARM64.Build.0 = Debug|ARM64
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}.Debug|x64.ActiveCfg = Debug|x64
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}.Debug|x64.Build.0 = Debug|x64
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}.Debug|x86.ActiveCfg = Debug|Win32
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}.Debug|x86.Build.0 = Debug|Win32
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}.Release|ARM64.ActiveCfg = Release|ARM64
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}.Release|ARM64.Build.0 = Release|ARM64
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}.Release|x64.ActiveCfg = Release|x64
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}.Release|x64.Build.0 = Release|x64
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}.Release|x86.ActiveCfg = Release|Win32
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}.Release|x86.Build.0 = Release|Win32
		{7833A548-6556-4728-A28B-4F59C12CD8E7}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{7833A548-6556-4728-A28B-4F59C12CD8E7}.Debug|ARM64.Build.0 = Debug|ARM64
		{7833A548-6556-4728-A28B-4F59C12CD8E7}.Debug|x64.ActiveCfg = Debug|x64
		{7833A548-6556-4728-A28B-4F59C12CD8E7}.Debug|x64.Build.0 = Debug|x64
		{7833A548-6556-4728-A28B-4F59C12CD8E7}.Debug|x86.ActiveCfg = Debug|Win32
		{7833A548-6556-4728-A28B-4F59C12CD8E7}.Debug|x86.Build.0 = Debug|Win32
		{7833A548-6556-4728-A28B-4F59C12CD8E7}.Release|ARM64.ActiveCfg = Release|ARM64
		{7833A548-6556-4728-A28B-4F59C12CD8E7}.Release|ARM64.Build.0 = Release|ARM64
		{7833A548-6556-4728-A28B-4F59C12CD8E7}.Release|x64.ActiveCfg = Release|x64
		{7833A548-6556-4728-A28B-4F59C12CD8E7}.Release|x64.Build.0 = Release|x64
		{7833A548-6556-4728-A28B-4F59C12CD8E7}.Release|x86.ActiveCfg = Release|Win32
		{7833A548-6556-4728-A28B-4F59C12CD8E7}.Release|x86.Build.0 = Release|Win32
		{4403C695-9939-4402-9EAB-43E88CF47997}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{4403C695-9939-4402-9EAB-43E88CF47997}.Debug|ARM64.Build.0 = Debug|ARM64
		{4403C695-9939-4402-9EAB-43E88CF47997}.Debug|x64.ActiveCfg = Debug|x64
		{4403C695-9939-4402-9EAB-43E88CF47997}.Debug|x64.Build.0 = Debug|x64
		{4403C695-9939-4402-9EAB-43E88CF47997}.Debug|x86.ActiveCfg = Debug|Win32
		{4403C695-9939-4402-9EAB-43E88CF47997}.Debug|x86.Build.0 = Debug|Win32
		{4403C695-9939-4402-9EAB-43E88CF47997}.Release|ARM64.ActiveCfg = Release|ARM64
		{4403C695-9939-4402-9EAB-43E88CF47997}.Release|ARM64.Build.0 = Release|ARM64
		{4403C695-9939-4402-9EAB-43E88CF47997}.Release|x64.ActiveCfg = Release|x64
		{4403C695-9939-4402-9EAB-43E88CF47997}.Release|x64.Build.0 = Release|x64
		{4403C695-9939-4402-9EAB-43E88CF47997}.Release|x86.ActiveCfg = Release|Win32
		{4403C695-9939-4402-9EAB-43E88CF47997}.Release|x86.Build.0 = Release|Win32
		{D0BB9E0A-F561-47C6-94C2-6CF68817F251}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{D0BB9E0A-F561-47C6-94C2-6CF68817F251}.Debug|ARM64.Build.0 = Debug|ARM64
		{D0BB9E0A-F561-47C6-94C2-6CF68817F251}.Debug|x64.ActiveCfg = Debug|x64
		{D0BB9E0A-F561-47C6-94C2-6CF68817F251}.Debug|x64.Build.0 = Debug|x64
		{D0BB9E0A-F561-47C6-94C2-6CF68817F251}.Debug|x86.ActiveCfg = Debug|Win32
		{D0BB9E0A-F561-47C6-94C2-6CF68817F251}.Debug|x86.Build.0 = Debug|Win32
		{D0BB9E0A-F561-47C6-94C2-6CF68817F251}.Release|ARM64.ActiveCfg = Release|ARM64
		{D0BB9E0A-F561-47C6-94C2-6CF68817F251}.Release|ARM64.Build.0 = Release|ARM64
		{D0BB9E0A-F561-47C6-94C2-6CF68817F251}.Release|x64.ActiveCfg = Release|x64
		{D0BB9E0A-F561-47C6-94C2-6CF68817F251}.Release|x64.Build.0 = Release|x64
		{D0BB9E0A-F561-47C6-94C2-6CF68817F251}.Release|x86.ActiveCfg = Release|Win32
		{D0BB9E0A-F561-47C6-94C2-6CF68817F251}.Release|x86.Build.0 = Release|Win32
		{39D26CA7-DCD7-4BE0-A97A-18940BAF0AD8}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{39D26CA7-DCD7-4BE0-A97A-18940BAF0AD8}.Debug|ARM64.Build.0 = Debug|ARM64
		{39D26CA7-DCD7-4BE0-A97A-18940BAF0AD8}.Debug|x64.ActiveCfg = Debug|x64
		{39D26CA7-DCD7-4BE0-A97A-18940BAF0AD8}.Debug|x64.Build.0 = Debug|x64
		{39D26CA7-DCD7-4BE0-A97A-18940BAF0AD8}.Debug|x86.ActiveCfg = Debug|Win32
		{39D26CA7-DCD7-4BE0-A97A-18940BAF0AD8}.Debug|x86.Build.0 = Debug|Win32
		{39D26CA7-DCD7-4BE0-A97A-18940BAF0AD8}.Release|ARM64.ActiveCfg = Release|ARM64
		{39D26CA7-DCD7-4BE0-A97A-18940BAF0AD8}.Release|ARM64.Build.0 = Release|ARM64
		{39D26CA7-DCD7-4BE0-A97A-18940BAF0AD8}.Release|x64.ActiveCfg = Release|x64
		{39D26CA7-DCD7-4BE0-A97A-18940BAF0AD8}.Release|x64.Build.0 = Release|x64
		{39D26CA7-DCD7-4BE0-A97A-18940BAF0AD8}.Release|x86.ActiveCfg = Release|Win32
		{39D26CA7-DCD7-4BE0-A97A-18940BAF0AD8}.Release|x86.Build.0 = Release|Win32
		{C5AD5596-0073-4453-B8DE-63659B9F0004}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{C5AD5596-0073-4453-B8DE-63659B9F0004}.Debug|ARM64.Build.0 = Debug|ARM64
		{C5AD5596-0073-4453-B8DE-63659B9F0004}.Debug|x64.ActiveCfg = Debug|x64
		{C5AD5596-0073-4453-B8DE-63659B9F0004}.Debug|x64.Build.0 = Debug|x64
		{C5AD5596-0073-4453-B8DE-63659B9F0004}.Debug|x86.ActiveCfg = Debug|x86
		{C5AD5596-0073-4453-B8DE-63659B9F0004}.Debug|x86.Build.0 = Debug|x86
		{C5AD5596-0073-4453-B8DE-63659B9F0004}.Release|ARM64.ActiveCfg = Release|ARM64
		{C5AD5596-0073-4453-B8DE-63659B9F0004}.Release|ARM64.Build.0 = Release|ARM64
		{C5AD5596-0073-4453-B8DE-63659B9F0004}.Release|x64.ActiveCfg = Release|x64
		{C5AD5596-0073-4453-B8DE-63659B9F0004}.Release|x64.Build.0 = Release|x64
		{C5AD5596-0073-4453-B8DE-63659B9F0004}.Release|x86.ActiveCfg = Release|x86
		{C5AD5596-0073-4453-B8DE-63659B9F0004}.Release|x86.Build.0 = Release|x86
		{74C8277F-1507-45D7-B95A-1DC9E04C932A}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{74C8277F-1507-45D7-B95A-1DC9E04C932A}.Debug|ARM64.Build.0 = Debug|ARM64
		{74C8277F-1507-45D7-B95A-1DC9E04C932A}.Debug|x64.ActiveCfg = Debug|x64
		{74C8277F-1507-45D7-B95A-1DC9E04C932A}.Debug|x64.Build.0 = Debug|x64
		{74C8277F-1507-45D7-B95A-1DC9E04C932A}.Debug|x86.ActiveCfg = Debug|Win32
		{74C8277F-1507-45D7-B95A-1DC9E04C932A}.Debug|x86.Build.0 = Debug|Win32
		{74C8277F-1507-45D7-B95A-1DC9E04C932A}.Release|ARM64.ActiveCfg = Release|ARM64
		{74C8277F-1507-45D7-B95A-1DC9E04C932A}.Release|ARM64.Build.0 = Release|ARM64
		{74C8277F-1507-45D7-B95A-1DC9E04C932A}.Release|x64.ActiveCfg = Release|x64
		{74C8277F-1507-45D7-B95A-1DC9E04C932A}.Release|x64.Build.0 = Release|x64
		{74C8277F-1507-45D7-B95A-1DC9E04C932A}.Release|x86.ActiveCfg = Release|Win32
		{74C8277F-1507-45D7-B95A-1DC9E04C932A}.Release|x86.Build.0 = Release|Win32
		{B3074F8E-D987-43C8-AE76-589A57DCF7CF}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{B3074F8E-D987-43C8-AE76-589A57DCF7CF}.Debug|ARM64.Build.0 = Debug|ARM64
		{B3074F8E-D987-43C8-AE76-589A57DCF7CF}.Debug|x64.ActiveCfg = Debug|x64
		{B3074F8E-D987-43C8-AE76-589A57DCF7CF}.Debug|x64.Build.0 = Debug|x64
		{B3074F8E-D987-43C8-AE76-589A57DCF7CF}.Debug|x86.ActiveCfg = Debug|Win32
		{B3074F8E-D987-43C8-AE76-589A57DCF7CF}.Debug|x86.Build.0 = Debug|Win32
		{B3074F8E-D987-43C8-AE76-589A57DCF7CF}.Release|ARM64.ActiveCfg = Release|ARM64
		{B3074F8E-D987-43C8-AE76-589A57DCF7CF}.Release|ARM64.Build.0 = Release|ARM64
		{B3074F8E-D987-43C8-AE76-589A57DCF7CF}.Release|x64.ActiveCfg = Release|x64
		{B3074F8E-D987-43C8-AE76-589A57DCF7CF}.Release|x64.Build.0 = Release|x64
		{B3074F8E-D987-43C8-AE76-589A57DCF7CF}.Release|x86.ActiveCfg = Release|Win32
		{B3074F8E-D987-43C8-AE76-589A57DCF7CF}.Release|x86.Build.0 = Release|Win32
		{BB2DF044-0B37-4335-B705-3CA6BA95514F}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{BB2DF044-0B37-4335-B705-3CA6BA95514F}.Debug|ARM64.Build.0 = Debug|ARM64
		{BB2DF044-0B37-4335-B705-3CA6BA95514F}.Debug|x64.ActiveCfg = Debug|x64
		{BB2DF044-0B37-4335-B705-3CA6BA95514F}.Debug|x64.Build.0 = Debug|x64
		{BB2DF044-0B37-4335-B705-3CA6BA95514F}.Debug|x86.ActiveCfg = Debug|Win32
		{BB2DF044-0B37-4335-B705-3CA6BA95514F}.Debug|x86.Build.0 = Debug|Win32
		{BB2DF044-0B37-4335-B705-3CA6BA95514F}.Release|ARM64.ActiveCfg = Release|ARM64
		{BB2DF044-0B37-4335-B705-3CA6BA95514F}.Release|ARM64.Build.0 = Release|ARM64
		{BB2DF044-0B37-4335-B705-3CA6BA95514F}.Release|x64.ActiveCfg = Release|x64
		{BB2DF044-0B37-4335-B705-3CA6BA95514F}.Release|x64.Build.0 = Release|x64
		{BB2DF044-0B37-4335-B705-3CA6BA95514F}.Release|x86.ActiveCfg = Release|Win32
		{BB2DF044-0B37-4335-B705-3CA6BA95514F}.Release|x86.Build.0 = Release|Win32
		{3C0FDE50-2F34-447A-B453-A2720C125563}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{3C0FDE50-2F34-447A-B453-A2720C125563}.Debug|ARM64.Build.0 = Debug|ARM64
		{3C0FDE50-2F34-447A-B453-A2720C125563}.Debug|x64.ActiveCfg = Debug|x64
		{3C0FDE50-2F34-447A-B453-A2720C125563}.Debug|x64.Build.0 = Debug|x64
		{3C0FDE50-2F34-447A-B453-A2720C125563}.Debug|x86.ActiveCfg = Debug|Win32
		{3C0FDE50-2F34-447A-B453-A2720C125563}.Debug|x86.Build.0 = Debug|Win32
		{3C0FDE50-2F34-447A-B453-A2720C125563}.Release|ARM64.ActiveCfg = Release|ARM64
		{3C0FDE50-2F34-447A-B453-A2720C125563}.Release|ARM64.Build.0 = Release|ARM64
		{3C0FDE50-2F34-447A-B453-A2720C125563}.Release|x64.ActiveCfg = Release|x64
		{3C0FDE50-2F34-447A-B453-A2720C125563}.Release|x64.Build.0 = Release|x64
		{3C0FDE50-2F34-447A-B453-A2720C125563}.Release|x86.ActiveCfg = Release|Win32
		{3C0FDE50-2F34-447A-B453-A2720C125563}.Release|x86.Build.0 = Release|Win32
		{E20B38ED-BA56-4ED0-A06D-76396F2857D1}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{E20B38ED-BA56-4ED0-A06D-76396F2857D1}.Debug|ARM64.Build.0 = Debug|ARM64
		{E20B38ED-BA56-4ED0-A06D-76396F2857D1}.Debug|x64.ActiveCfg = Debug|x64
		{E20B38ED-BA56-4ED0-A06D-76396F2857D1}.Debug|x64.Build.0 = Debug|x64
		{E20B38ED-BA56-4ED0-A06D-76396F2857D1}.Debug|x86.ActiveCfg = Debug|Win32
		{E20B38ED-BA56-4ED0-A06D-76396F2857D1}.Debug|x86.Build.0 = Debug|Win32
		{E20B38ED-BA56-4ED0-A06D-76396F2857D1}.Release|ARM64.ActiveCfg = Release|ARM64
		{E20B38ED-BA56-4ED0-A06D-76396F2857D1}.Release|ARM64.Build.0 = Release|ARM64
		{E20B38ED-BA56-4ED0-A06D-76396F2857D1}.Release|x64.ActiveCfg = Release|x64
		{E20B38ED-BA56-4ED0-A06D-76396F2857D1}.Release|x64.Build.0 = Release|x64
		{E20B38ED-BA56-4ED0-A06D-76396F2857D1}.Release|x86.ActiveCfg = Release|Win32
		{E20B38ED-BA56-4ED0-A06D-76396F2857D1}.Release|x86.Build.0 = Release|Win32
		{DAB189FD-2137-4947-A215-CB714EF875DF}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{DAB189FD-2137-4947-A215-CB714EF875DF}.Debug|ARM64.Build.0 = Debug|ARM64
		{DAB189FD-2137-4947-A215-CB714EF875DF}.Debug|x64.ActiveCfg = Debug|x64
		{DAB189FD-2137-4947-A215-CB714EF875DF}.Debug|x64.Build.0 = Debug|x64
		{DAB189FD-2137-4947-A215-CB714EF875DF}.Debug|x86.ActiveCfg = Debug|Win32
		{DAB189FD-2137-4947-A215-CB714EF875DF}.Debug|x86.Build.0 = Debug|Win32
		{DAB189FD-2137-4947-A215-CB714EF875DF}.Release|ARM64.ActiveCfg = Release|ARM64
		{DAB189FD-2137-4947-A215-CB714EF875DF}.Release|ARM64.Build.0 = Release|ARM64
		{DAB189FD-2137-4947-A215-CB714EF875DF}.Release|x64.ActiveCfg = Release|x64
		{DAB189FD-2137-4947-A215-CB714EF875DF}.Release|x64.Build.0 = Release|x64
		{DAB189FD-2137-4947-A215-CB714EF875DF}.Release|x86.ActiveCfg = Release|Win32
		{DAB189FD-2137-4947-A215-CB714EF875DF}.Release|x86.Build.0 = Release|Win32
		{23F95304-9B53-4513-BA4F-4F388F9A8AF8}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{23F95304-9B53-4513-BA4F-4F388F9A8AF8}.Debug|ARM64.Build.0 = Debug|ARM64
		{23F95304-9B53-4513-BA4F-4F388F9A8AF8}.Debug|x64.ActiveCfg = Debug|x64
		{23F95304-9B53-4513-BA4F-4F388F9A8AF8}.Debug|x64.Build.0 = Debug|x64
		{23F95304-9B53-4513-BA4F-4F388F9A8AF8}.Debug|x86.ActiveCfg = Debug|Win32
		{23F95304-9B53-4513-BA4F-4F388F9A8AF8}.Debug|x86.Build.0 = Debug|Win32
		{23F95304-9B53-4513-BA4F-4F388F9A8AF8}.Release|ARM64.ActiveCfg = Release|ARM64
		{23F95304-9B53-4513-BA4F-4F388F9A8AF8}.Release|ARM64.Build.0 = Release|ARM64
		{23F95304-9B53-4513-BA4F-4F388F9A8AF8}.Release|x64.ActiveCfg = Release|x64
		{23F95304-9B53-4513-BA4F-4F388F9A8AF8}.Release|x64.Build.0 = Release|x64
		{23F95304-9B53-4513-BA4F-4F388F9A8AF8}.Release|x86.ActiveCfg = Release|Win32
		{23F95304-9B53-4513-BA4F-4F388F9A8AF8}.Release|x86.Build.0 = Release|Win32
		{139FD3A5-D0F3-4068-81C9-A94FB58DC626}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{139FD3A5-D0F3-4068-81C9-A94FB58DC626}.Debug|x64.ActiveCfg = Debug|x64
		{139FD3A5-D0F3-4068-81C9-A94FB58DC626}.Debug|x64.Build.0 = Debug|x64
		{139FD3A5-D0F3-4068-81C9-A94FB58DC626}.Debug|x86.ActiveCfg = Debug|Win32
		{139FD3A5-D0F3-4068-81C9-A94FB58DC626}.Debug|x86.Build.0 = Debug|Win32
		{139FD3A5-D0F3-4068-81C9-A94FB58DC626}.Release|ARM64.ActiveCfg = Release|ARM64
		{139FD3A5-D0F3-4068-81C9-A94FB58DC626}.Release|x64.ActiveCfg = Release|x64
		{139FD3A5-D0F3-4068-81C9-A94FB58DC626}.Release|x64.Build.0 = Release|x64
		{139FD3A5-D0F3-4068-81C9-A94FB58DC626}.Release|x86.ActiveCfg = Release|Win32
		{139FD3A5-D0F3-4068-81C9-A94FB58DC626}.Release|x86.Build.0 = Release|Win32
		{F9BAFDFC-851F-40F2-B3D9-20ABFC23DD68}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{F9BAFDFC-851F-40F2-B3D9-20ABFC23DD68}.Debug|x64.ActiveCfg = Debug|x64
		{F9BAFDFC-851F-40F2-B3D9-20ABFC23DD68}.Debug|x64.Build.0 = Debug|x64
		{F9BAFDFC-851F-40F2-B3D9-20ABFC23DD68}.Debug|x86.ActiveCfg = Debug|Win32
		{F9BAFDFC-851F-40F2-B3D9-20ABFC23DD68}.Debug|x86.Build.0 = Debug|Win32
		{F9BAFDFC-851F-40F2-B3D9-20ABFC23DD68}.Release|ARM64.ActiveCfg = Release|ARM64
		{F9BAFDFC-851F-40F2-B3D9-20ABFC23DD68}.Release|x64.ActiveCfg = Release|x64
		{F9BAFDFC-851F-40F2-B3D9-20ABFC23DD68}.Release|x64.Build.0 = Release|x64
		{F9BAFDFC-851F-40F2-B3D9-20ABFC23DD68}.Release|x86.ActiveCfg = Release|Win32
		{F9BAFDFC-851F-40F2-B3D9-20ABFC23DD68}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{B6004DA5-A081-4FF8-9D3C-7438530B8CF6} = {A7DF5839-29D7-4F6B-9CFE-6AD9AFD884CE}
		{7833A548-6556-4728-A28B-4F59C12CD8E7} = {A7DF5839-29D7-4F6B-9CFE-6AD9AFD884CE}
		{4403C695-9939-4402-9EAB-43E88CF47997} = {A7DF5839-29D7-4F6B-9CFE-6AD9AFD884CE}
		{D0BB9E0A-F561-47C6-94C2-6CF68817F251} = {0239936A-C2D5-4F21-8494-BCA4B893911F}
		{39D26CA7-DCD7-4BE0-A97A-18940BAF0AD8} = {0239936A-C2D5-4F21-8494-BCA4B893911F}
		{C5AD5596-0073-4453-B8DE-63659B9F0004} = {A402BC8B-B32C-4851-B4A2-B8B84C0721E9}
		{74C8277F-1507-45D7-B95A-1DC9E04C932A} = {0239936A-C2D5-4F21-8494-BCA4B893911F}
		{B3074F8E-D987-43C8-AE76-589A57DCF7CF} = {0239936A-C2D5-4F21-8494-BCA4B893911F}
		{BB2DF044-0B37-4335-B705-3CA6BA95514F} = {0239936A-C2D5-4F21-8494-BCA4B893911F}
		{3C0FDE50-2F34-447A-B453-A2720C125563} = {0239936A-C2D5-4F21-8494-BCA4B893911F}
		{0239936A-C2D5-4F21-8494-BCA4B893911F} = {BACE34D5-298C-42E3-84F6-28C689E469E1}
		{A402BC8B-B32C-4851-B4A2-B8B84C0721E9} = {BACE34D5-298C-42E3-84F6-28C689E469E1}
		{E20B38ED-BA56-4ED0-A06D-76396F2857D1} = {0239936A-C2D5-4F21-8494-BCA4B893911F}
		{DAB189FD-2137-4947-A215-CB714EF875DF} = {0239936A-C2D5-4F21-8494-BCA4B893911F}
		{23F95304-9B53-4513-BA4F-4F388F9A8AF8} = {0239936A-C2D5-4F21-8494-BCA4B893911F}
		{139FD3A5-D0F3-4068-81C9-A94FB58DC626} = {0239936A-C2D5-4F21-8494-BCA4B893911F}
		{F9BAFDFC-851F-40F2-B3D9-20ABFC23DD68} = {0239936A-C2D5-4F21-8494-BCA4B893911F}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F27A9BD3-2781-4A72-AB94-EC892968DD7C}
	EndGlobalSection
EndGlobal

```

`ndisapi.vc6/ndisapi.def`:

```def
EXPORTS
OpenFilterDriver
CloseFilterDriver
GetDriverVersion
GetTcpipBoundAdaptersInfo
SendPacketToMstcp
SendPacketToAdapter
SendPacketsToMstcp
SendPacketsToAdapter
ReadPacket
ReadPackets
SetAdapterMode
GetAdapterMode
FlushAdapterPacketQueue
GetAdapterPacketQueueSize
SetPacketEvent
SetWANEvent
SetAdapterListChangeEvent
NdisrdRequest
GetRasLinks
SetHwPacketFilter
GetHwPacketFilter
SetHwPacketFilterEvent
SetPacketFilterTable
AddStaticFilterFront
AddStaticFilterBack
InsertStaticFilter
RemoveStaticFilter
ResetPacketFilterTable
GetPacketFilterTableSize
GetPacketFilterTable
GetPacketFilterTableResetStats
EnablePacketFilterCache
DisablePacketFilterCache
EnablePacketFragmentCache
DisablePacketFragmentCache
SetMTUDecrement
GetMTUDecrement
SetAdaptersStartupMode
GetAdaptersStartupMode
SetPoolSize
GetPoolSize
IsDriverLoaded
InitializeFastIo
AddSecondaryFastIo
ReadPacketsUnsorted
SendPacketsToAdaptersUnsorted
SendPacketsToMstcpUnsorted
GetIntermediateBufferPoolSize
GetBytesReturned
IsNdiswanIp
IsNdiswanIpv6
IsNdiswanBh
ConvertWindowsNTAdapterName
ConvertWindows2000AdapterName
ConvertWindows9xAdapterName
RecalculateIPChecksum
RecalculateICMPChecksum
RecalculateTCPChecksum
RecalculateUDPChecksum
```

`ndisapi.vc6/ndisapi.dsp`:

```dsp
# Microsoft Developer Studio Project File - Name="ndisapi" - Package Owner=<4>
# Microsoft Developer Studio Generated Build File, Format Version 6.00
# ** DO NOT EDIT **

# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102

CFG=ndisapi - Win32 Debug
!MESSAGE This is not a valid makefile. To build this project using NMAKE,
!MESSAGE use the Export Makefile command and run
!MESSAGE 
!MESSAGE NMAKE /f "ndisapi.mak".
!MESSAGE 
!MESSAGE You can specify a configuration when running NMAKE
!MESSAGE by defining the macro CFG on the command line. For example:
!MESSAGE 
!MESSAGE NMAKE /f "ndisapi.mak" CFG="ndisapi - Win32 Debug"
!MESSAGE 
!MESSAGE Possible choices for configuration are:
!MESSAGE 
!MESSAGE "ndisapi - Win32 Release" (based on "Win32 (x86) Dynamic-Link Library")
!MESSAGE "ndisapi - Win32 Debug" (based on "Win32 (x86) Dynamic-Link Library")
!MESSAGE 

# Begin Project
# PROP AllowPerConfigDependencies 0
# PROP Scc_ProjName ""
# PROP Scc_LocalPath ""
CPP=cl.exe
MTL=midl.exe
RSC=rc.exe

!IF  "$(CFG)" == "ndisapi - Win32 Release"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 0
# PROP BASE Output_Dir "Release"
# PROP BASE Intermediate_Dir "Release"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 0
# PROP Output_Dir "../bin/dll.vc6/i386"
# PROP Intermediate_Dir "Release"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "NDISAPI_EXPORTS" /Yu"stdafx.h" /FD /c
# ADD CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "NDISAPI_EXPORTS" /FR /FD /c
# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
# ADD BASE RSC /l 0x419 /d "NDEBUG"
# ADD RSC /l 0x409 /d "NDEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
# ADD LINK32 Ws2_32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386

!ELSEIF  "$(CFG)" == "ndisapi - Win32 Debug"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 1
# PROP BASE Output_Dir "Debug"
# PROP BASE Intermediate_Dir "Debug"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 1
# PROP Output_Dir "Debug"
# PROP Intermediate_Dir "Debug"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "NDISAPI_EXPORTS" /Yu"stdafx.h" /FD /GZ /c
# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "NDISAPI_EXPORTS" /FD /GZ /c
# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
# ADD BASE RSC /l 0x419 /d "_DEBUG"
# ADD RSC /l 0x409 /d "_DEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
# ADD LINK32 Ws2_32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept

!ENDIF 

# Begin Target

# Name "ndisapi - Win32 Release"
# Name "ndisapi - Win32 Debug"
# Begin Group "Source Files"

# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
# Begin Source File

SOURCE=..\ndisapi\ndisapi.cpp
# End Source File
# Begin Source File

SOURCE=.\ndisapi.def
# End Source File
# Begin Source File

SOURCE=..\ndisapi\ndisapi.rc
# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl"
# Begin Source File

SOURCE=..\include\Common.h
# End Source File
# Begin Source File

SOURCE=..\ndisapi\iphlp.h
# End Source File
# Begin Source File

SOURCE=..\include\ndisapi.h
# End Source File
# Begin Source File

SOURCE=..\ndisapi\precomp.h
# End Source File
# Begin Source File

SOURCE=..\ndisapi\resource.h
# End Source File
# End Group
# Begin Group "Resource Files"

# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
# End Group
# End Target
# End Project

```

`ndisapi.vs2012/ndisapi.def`:

```def
EXPORTS
OpenFilterDriver
CloseFilterDriver
GetDriverVersion
GetTcpipBoundAdaptersInfo
SendPacketToMstcp
SendPacketToAdapter
SendPacketsToMstcp
SendPacketsToAdapter
ReadPacket
ReadPackets
SetAdapterMode
GetAdapterMode
FlushAdapterPacketQueue
GetAdapterPacketQueueSize
SetPacketEvent
SetWANEvent
SetAdapterListChangeEvent
NdisrdRequest
GetRasLinks
SetHwPacketFilter
GetHwPacketFilter
SetHwPacketFilterEvent
SetPacketFilterTable
AddStaticFilterFront
AddStaticFilterBack
InsertStaticFilter
RemoveStaticFilter
ResetPacketFilterTable
GetPacketFilterTableSize
GetPacketFilterTable
GetPacketFilterTableResetStats
EnablePacketFilterCache
DisablePacketFilterCache
EnablePacketFragmentCache
DisablePacketFragmentCache
SetMTUDecrement
GetMTUDecrement
SetAdaptersStartupMode
GetAdaptersStartupMode
SetPoolSize
GetPoolSize
IsDriverLoaded
InitializeFastIo
AddSecondaryFastIo
ReadPacketsUnsorted
SendPacketsToAdaptersUnsorted
SendPacketsToMstcpUnsorted
GetIntermediateBufferPoolSize
GetBytesReturned
IsNdiswanIp
IsNdiswanIpv6
IsNdiswanBh
ConvertWindowsNTAdapterName
ConvertWindows2000AdapterName
ConvertWindows9xAdapterName
RecalculateIPChecksum
RecalculateICMPChecksum
RecalculateTCPChecksum
RecalculateUDPChecksum
```

`ndisapi.vs2012/ndisapi.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\include\Common.h" />
    <ClInclude Include="..\include\ndisapi.h" />
    <ClInclude Include="..\ndisapi\iphlp.h" />
    <ClInclude Include="..\ndisapi\precomp.h" />
    <ClInclude Include="..\ndisapi\resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\ndisapi\ndisapi.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="..\ndisapi\ndisapi.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include=".\ndisapi.def" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{B6004DA5-A081-4FF8-9D3C-7438530B8CF6}</ProjectGuid>
    <RootNamespace>ndisapi</RootNamespace>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>11.0.50727.1</_ProjectFileVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)bin\dll.vs2012\i386\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)bin\dll.vs2012\amd64\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;NDISAPI_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>true</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader />
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>ndisapi.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <AdditionalDependencies>Ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;NDISAPI_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>true</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader />
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>ndisapi.def</ModuleDefinitionFile>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <AdditionalDependencies>Ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;NDISAPI_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader />
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>ndisapi.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX86</TargetMachine>
      <AdditionalDependencies>Ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;NDISAPI_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader />
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>ndisapi.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <TargetMachine>MachineX64</TargetMachine>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <AdditionalDependencies>Ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ndisapi.vs2012/ndisapi.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\include\Common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\include\ndisapi.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\ndisapi\iphlp.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\ndisapi\precomp.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\ndisapi\resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\ndisapi\ndisapi.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="..\ndisapi\ndisapi.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include=".\ndisapi.def">
      <Filter>Source Files</Filter>
    </None>
  </ItemGroup>
</Project>
```

`ndisapi/iphlp.h`:

```h
//*************************************************************************/
/*                    Copyright (c) 2000-2024 NT KERNEL.                 */
/*                           All Rights Reserved.                        */
/*                          https://www.ntkernel.com                     */
/*                           ndisrd@ntkernel.com                         */
/* Module Name:  iphlp.h                                                 */
/*                                                                       */
/* Abstract: IP helper definitions                                       */
/*                                                                       */
/* Environment:                                                          */
/*   User mode, Kernel mode                                              */
/*                                                                       */
/*************************************************************************/

#ifndef __IPHLP_H__
#define __IPHLP_H__

#pragma pack(1) 

///////////////////////////////////////////////////////////////////////////
// packet structures
///////////////////////////////////////////////////////////////////////////
typedef long n_long;
typedef short n_short;
typedef long n_time;
typedef unsigned short u_short;
typedef unsigned long u_long;
typedef unsigned char u_char;
typedef struct in_addr IN_ADDR, *PIN_ADDR;

#define ETH_ALEN				6		/* Octets in one ethernet addr	 */
#define ETHER_HEADER_LENGTH		14		/* Ethernet header length */

#define ETH_P_ARP		0x0806			/* Address Resolution packet	*/
#define ARPHRD_ETHER	0x01
#define ARPOP_REQUEST	0x01
#define ARPOP_REPLY		0x02

#define ETH_P_IP		0x0800			/* Internet Protocol packet	*/
#define ETH_P_IP_NET	0x0008			/* Internet Protocol packet	network order*/
#define ETH_P_RARP      0x8035			/* Reverse Addr Res packet	*/
#define ETH_P_ARP		0x0806			/* Address Resolution packet	*/

#define ETH_P_IPV6		0x86dd 			/* Internet Protocol V6 packet	*/
#define ETH_P_IPV6_NET	0xdd86 			/* Internet Protocol V6 packet network order*/

/*
 * Protocols
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_IGMP            2               /* group management protocol */
#define IPPROTO_GGP             3               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

// Ethernet Header
typedef struct ether_header 
{
	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
	unsigned short	h_proto;		/* packet type ID field	*/
} ether_header, *ether_header_ptr;

typedef struct arphdr
{
	unsigned short	ar_hrd;		/* format of hardware address	*/
	unsigned short	ar_pro;		/* format of protocol address	*/
	unsigned char	ar_hln;		/* length of hardware address	*/
	unsigned char	ar_pln;		/* length of protocol address	*/
	unsigned short	ar_op;		/* ARP opcode (command)		*/
} arphdr, *arphdr_ptr;

typedef struct	ether_arp 
{
	struct	arphdr ea_hdr;	/* fixed-size header */
	u_char	arp_sha[ETH_ALEN];	/* sender hardware address */
	u_char	arp_spa[4];	/* sender protocol address */
	u_char	arp_tha[ETH_ALEN];	/* target hardware address */
	u_char	arp_tpa[4];	/* target protocol address */
} ether_arp, *ether_arp_ptr;

#define	arp_hrd	ea_hdr.ar_hrd
#define	arp_pro	ea_hdr.ar_pro
#define	arp_hln	ea_hdr.ar_hln
#define	arp_pln	ea_hdr.ar_pln
#define	arp_op	ea_hdr.ar_op

/* IP Header in Little Endian */
typedef struct iphdr 
{
	u_char	ip_hl:4,		/* header length */
			ip_v:4;			/* version */
	u_char	ip_tos;			/* type of service */
	u_short	ip_len;			/* total length */
	u_short	ip_id;			/* identification */
	u_short	ip_off;			/* fragment offset field */
#define	IP_DF 0x4000		/* dont fragment flag */
#define	IP_MF 0x2000		/* more fragments flag */
	u_char	ip_ttl;			/* time to live */
	u_char	ip_p;			/* protocol */
	u_short	ip_sum;			/* checksum */
	struct	in_addr ip_src,ip_dst;	/* source and dest address */
} iphdr, *iphdr_ptr;
/////////////////////////////////////////////////////////////////////////
/* UDP header  */
typedef struct	udphdr
{
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	u_short	length;			/* data length */
	u_short	th_sum;			/* checksum */
} udphdr, *udphdr_ptr;
/////////////////////////////////////////////////////////////////////////
typedef	u_long	tcp_seq;

// TCP header. Per RFC 793, September, 1981. In Little Endian
typedef struct tcphdr {
	u_short	th_sport;		/* source port */
	u_short	th_dport;		/* destination port */
	tcp_seq	th_seq;			/* sequence number */
	tcp_seq	th_ack;			/* acknowledgement number */
	u_char	th_x2:4,		/* (unused) */
			th_off:4;		/* data offset */
#define TCP_NO_OPTIONS	0x05
	u_char	th_flags;
#define	TH_FIN	0x01
#define	TH_SYN	0x02
#define	TH_RST	0x04
#define	TH_PSH	0x08
#define	TH_ACK	0x10
#define	TH_URG	0x20
	u_short	th_win;			/* window */
	u_short	th_sum;			/* checksum */
	u_short	th_urp;			/* urgent pointer */
} tcphdr, *tcphdr_ptr;

typedef struct pseudo_header
{
  struct in_addr source_address;
  struct in_addr dest_address;
  unsigned char placeholder;
  unsigned char protocol;
  unsigned short tcp_length;

}pseudo_header, *pseudo_header_ptr;

/////////////////////////////////////////////////////////////////////////

//
// Protocols for IPv6
//
#define IPPROTO_HOPOPTS		0             // Hop by hop header for v6
#define IPPROTO_IPV6		41            // IPv6 encapsulated in IP
#define IPPROTO_ROUTING		43            // Routing header for IPv6
#define IPPROTO_FRAGMENT	44            // Fragment header for IPv6
#define IPPROTO_ICMPV6		58            // ICMP for IPv6
#define IPPROTO_NONE		59            // No next header for IPv6
#define IPPROTO_DSTOPTS		60            // Destinations options

//
// IPv6 header format
//
typedef struct ipv6hdr 
{
	unsigned int	ip6_flow;	// 4  bits = version #, 
								// 8  bits = Trafic class,
								// 20 bits = flow label
	unsigned short	ip6_len;    // Payload length
	unsigned char	ip6_next;	// Next Header
	unsigned char	ip6_hops;	// Hop Limit
	IN6_ADDR		ip6_src;	// Source Address
	IN6_ADDR		ip6_dst;	// Destination Address
} ipv6hdr, *ipv6hdr_ptr;

//
// IPv6 extension header format
//
typedef struct ipv6ext {
	unsigned char    ip6_next;		// Next Header
	unsigned char    ip6_len;		// number of bytes in this header 
	unsigned char    ip6_data[2];	// optional data
}ipv6ext, *ipv6ext_ptr;

typedef struct ipv6ext_frag
{
    unsigned char		ip6_next;       // next header
    unsigned char		ip6_reserved;   // reserved field
    unsigned short		ip6_offlg;      // offset, reserved, and flag
    unsigned int		ip6_ident;      // identification
}ipv6ext_frag, *ipv6ext_frag_ptr;

typedef struct mss_tcp_options {
#define	MSS_TYPE	0x02
#define	SACK_TYPE	0x04
	u_char  mss_type;
	u_char  mss_option_length;
	u_short mss_value;
}mss_tcp_options, *mss_tcp_options_ptr;

//
// ICMP header
//
typedef struct icmphdr {
	unsigned char type;          // ICMP packet type
	unsigned char code;          // Type sub code
	unsigned short checksum;
	unsigned short id;
	unsigned short seq;
}icmphdr, *icmphdr_ptr;

#pragma pack()

#endif // __IPHLP_H__
```

`ndisapi/ndisapi.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 3,6,1,1
 PRODUCTVERSION 3,6,1,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040004b0"
        BEGIN
            VALUE "CompanyName", "NT KERNEL"
            VALUE "FileDescription", "Windows Packet Filter user interface library"
            VALUE "FileVersion", "3.6.1.1"
            VALUE "InternalName", "ndisapi.dll"
            VALUE "LegalCopyright", "Copyright © NT KERNEL 2000-2024"
            VALUE "OriginalFilename", "ndisapi.dll"
            VALUE "ProductName", "Windows Packet Filter Kit"
            VALUE "ProductVersion", "3.6.1.1"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x400, 1200
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`ndisapi/precomp.h`:

```h
/*************************************************************************/
/*                    Copyright (c) 2000-2024 NT KERNEL.                 */
/*                           All Rights Reserved.                        */
/*                          https://www.ntkernel.com                     */
/*                           ndisrd@ntkernel.com                         */
/*                                                                       */
/* Module Name:  precomp.h                                               */
/*                                                                       */
/* Description: Cumulative include header                                */
/*                                                                       */
/* Environment:                                                          */
/*   User mode                                                           */
/*                                                                       */
/*************************************************************************/

#pragma once

#include <tchar.h>
#include <stdlib.h>
#include <WinSock2.h>
#include <iphlpapi.h>

#include <memory>

#ifdef CYGWIN_BUILD
#include <strings.h> // For strcasecmp
#include <cstring>  // For strcpy, strcat
#include <cwchar>   // For wcscpy, wcscat
#define _stricmp strcasecmp
#ifdef UNICODE
// Define _tcscpy, etc. for Unicode under non-Windows
#define _tcscpy wcscpy
#define _tcscat wcscat
#define TCHAR wchar_t
// ... other wide character (wchar_t) functions as needed ...
#else
// Define _tcscpy, etc. for non-Unicode under non-Windows
#define _tcscpy strcpy
#define _tcscat strcat
// ... other single-byte (char) functions as needed ...
#endif // UNICODE
#endif // CYGWIN_BUILD

#include "../include/common.h"
#include "../include/ndisapi.h"
#include "iphlp.h"

```

`ndisapi/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by ndisapi.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`tools.cmd`:

```cmd
@echo off
mkdir tools
mkdir tools\i386
mkdir tools\amd64
mkdir tools\arm64
mkdir tools\vs2012
mkdir tools\vs2012\i386
mkdir tools\vs2012\amd64
mkdir tools\vc6

copy /Y .\bin\examples\native\Win32\Release\*.exe tools\i386\
for %%f in (tools\i386\*.exe) do signtool sign /fd sha1 /t http://timestamp.digicert.com /n "IP SMIRNOV VADIM VALERIEVICH" "%%f"
for %%f in (tools\i386\*.exe) do signtool sign /as /td sha256 /fd sha256 /tr http://timestamp.digicert.com /n "IP SMIRNOV VADIM VALERIEVICH" "%%f"

copy /Y .\bin\examples\native\x64\Release\*.exe tools\amd64\
for %%f in (tools\amd64\*.exe) do signtool sign /fd sha1 /t http://timestamp.digicert.com /n "IP SMIRNOV VADIM VALERIEVICH" "%%f"
for %%f in (tools\amd64\*.exe) do signtool sign /as /td sha256 /fd sha256 /tr http://timestamp.digicert.com /n "IP SMIRNOV VADIM VALERIEVICH" "%%f"

copy /Y .\bin\examples\native\arm64\Release\*.exe tools\arm64\
copy /Y .\bin\dll\ARM64\Release\*.dll tools\arm64\
for %%f in (tools\arm64\*.exe tools\arm64\*.dll) do signtool sign /fd sha1 /t http://timestamp.digicert.com /n "IP SMIRNOV VADIM VALERIEVICH" "%%f"
for %%f in (tools\arm64\*.exe tools\arm64\*.dll) do signtool sign /as /td sha256 /fd sha256 /tr http://timestamp.digicert.com /n "IP SMIRNOV VADIM VALERIEVICH" "%%f"

copy /Y .\bin\dll\Win32\Release\*.dll tools\i386\
for %%f in (tools\i386\*.dll) do signtool sign /fd sha1 /t http://timestamp.digicert.com /n "IP SMIRNOV VADIM VALERIEVICH" "%%f"
for %%f in (tools\i386\*.dll) do signtool sign /as /td sha256 /fd sha256 /tr http://timestamp.digicert.com /n "IP SMIRNOV VADIM VALERIEVICH" "%%f"

copy /Y .\bin\dll\x64\Release\*.dll tools\amd64\
for %%f in (tools\amd64\*.dll) do signtool sign /fd sha1 /t http://timestamp.digicert.com /n "IP SMIRNOV VADIM VALERIEVICH" "%%f"
for %%f in (tools\amd64\*.dll) do signtool sign /as /td sha256 /fd sha256 /tr http://timestamp.digicert.com /n "IP SMIRNOV VADIM VALERIEVICH" "%%f"

copy /Y .\examples\legacy\MSVC\bin\dll.vs2012\i386\ndisapi.dll tools\vs2012\i386\
copy /Y .\examples\legacy\MSVC\bin\dll.vs2012\amd64\ndisapi.dll tools\vs2012\amd64\
copy /Y .\examples\legacy\MSVC\bin\i386\*.exe tools\vs2012\i386\
copy /Y .\examples\legacy\MSVC\bin\amd64\*.exe tools\vs2012\amd64\
for %%f in (tools\vs2012\i386\*.exe tools\vs2012\i386\*.dll tools\vs2012\amd64\*.exe tools\vs2012\amd64\*.dll) do signtool sign /fd sha1 /t http://timestamp.digicert.com /n "IP SMIRNOV VADIM VALERIEVICH" "%%f"
for %%f in (tools\vs2012\i386\*.exe tools\vs2012\i386\*.dll tools\vs2012\amd64\*.exe tools\vs2012\amd64\*.dll) do signtool sign /as /td sha256 /fd sha256 /tr http://timestamp.digicert.com /n "IP SMIRNOV VADIM VALERIEVICH" "%%f"

copy /Y .\examples\legacy\MSVC\bin\vc6\*.exe tools\vc6\
copy /Y .\bin\dll.vc6\i386\ndisapi.dll tools\vc6\
for %%f in (tools\vc6\*.exe tools\vc6\*.dll) do signtool sign /fd sha1 /t http://timestamp.digicert.com /n "IP SMIRNOV VADIM VALERIEVICH" "%%f"
for %%f in (tools\vc6\*.exe tools\vc6\*.dll) do signtool sign /as /td sha256 /fd sha256 /tr http://timestamp.digicert.com /n "IP SMIRNOV VADIM VALERIEVICH" "%%f"

pushd tools\i386
"C:\Program Files\7-Zip\7z.exe" a ..\..\tools_bin_x86.zip *
popd

pushd tools\amd64
"C:\Program Files\7-Zip\7z.exe" a ..\..\tools_bin_x64.zip *
popd

pushd tools\arm64
"C:\Program Files\7-Zip\7z.exe" a ..\..\tools_bin_arm64.zip *
popd

pushd tools\vs2012
"C:\Program Files\7-Zip\7z.exe" a ..\..\tools_bin_x86_x64_vs2012.zip *
popd

pushd tools\vc6
"C:\Program Files\7-Zip\7z.exe" a ..\..\tools_bin_x86_vc6.zip *
popd

rmdir tools /s /q

```