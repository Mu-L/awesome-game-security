Project Path: arc_arlyon_azerust_zb66wiwz

Source Tree:

```txt
arc_arlyon_azerust_zb66wiwz
├── Cargo.lock
├── Cargo.toml
├── Dockerfile
├── Makefile.toml
├── crates
│   ├── assert-size-attribute
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── lib.rs
│   ├── axum
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── auth.rs
│   │       ├── lib.rs
│   │       └── world.rs
│   ├── game
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── accounts.rs
│   │       ├── characters.rs
│   │       ├── chat.rs
│   │       ├── lib.rs
│   │       ├── realms.rs
│   │       └── types.rs
│   ├── graphql-auth
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── lib.rs
│   │       ├── models
│   │       │   ├── account.rs
│   │       │   ├── mod.rs
│   │       │   └── realm.rs
│   │       └── schemas
│   │           ├── mod.rs
│   │           ├── mutation.rs
│   │           └── query.rs
│   ├── graphql-world
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── lib.rs
│   │       ├── models
│   │       │   ├── character.rs
│   │       │   ├── mod.rs
│   │       │   └── realm.rs
│   │       └── schemas
│   │           ├── mod.rs
│   │           ├── mutation.rs
│   │           └── query.rs
│   ├── pg-auth
│   │   ├── Cargo.toml
│   │   ├── queries
│   │   │   ├── accounts.sql
│   │   │   └── realms.sql
│   │   ├── schema.sql
│   │   └── src
│   │       ├── accounts.rs
│   │       ├── cornucopia.rs
│   │       ├── lib.rs
│   │       └── realms.rs
│   ├── pg-characters
│   │   ├── Cargo.toml
│   │   ├── queries
│   │   │   └── character.sql
│   │   ├── schema.sql
│   │   └── src
│   │       ├── characters.rs
│   │       ├── cornucopia.rs
│   │       └── lib.rs
│   ├── utils
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── lib.rs
│   └── wow-srp
│       ├── Cargo.toml
│       └── src
│           └── lib.rs
├── docker-compose.yaml
├── license.md
├── pg
│   └── Dockerfile
├── readme.md
├── rust-toolchain
├── rustfmt.toml
└── services
    ├── auth
    │   ├── Cargo.toml
    │   └── src
    │       ├── authserver.rs
    │       ├── conf.rs
    │       ├── main.rs
    │       └── opt.rs
    ├── mpqextract
    │   ├── Cargo.toml
    │   └── src
    │       └── main.rs
    └── world
        ├── Cargo.toml
        └── src
            ├── client.rs
            ├── conf.rs
            ├── main.rs
            ├── opt.rs
            ├── world
            │   └── mod.rs
            └── worldserver.rs

```

`Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "Inflector"
version = "0.11.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fe438c63458706e03479442743baae6c88256498e6431708f6dfc520a26515d3"
dependencies = [
 "lazy_static",
 "regex",
]

[[package]]
name = "addr2line"
version = "0.24.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfbe277e56a376000877090da837660b4427aad530e3028d44e0bffe4f89a1c1"
dependencies = [
 "gimli",
]

[[package]]
name = "adler2"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "512761e0bb2578dd7380c6baaa0f4ce03e84f95e960231d1dec8bf4d7d6e2627"

[[package]]
name = "adler32"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aae1277d39aeec15cb388266ecc24b11c80469deae6067e17a1a7aa9e5c1f234"

[[package]]
name = "ahash"
version = "0.8.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e89da841a80418a9b391ebaea17f5c112ffaaa96f621d2c285b5174da76b9011"
dependencies = [
 "cfg-if",
 "const-random",
 "getrandom",
 "once_cell",
 "version_check",
 "zerocopy",
]

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "allocator-api2"
version = "0.2.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "45862d1c77f2228b9e10bc609d5bc203d86ebc9b87ad8d5d5167a6c9abf739d9"

[[package]]
name = "android_log-sys"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5ecc8056bf6ab9892dcd53216c83d1597487d7dacac16c8df6b877d127df9937"

[[package]]
name = "ansi_term"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d52a9bb7ec0cf484c551830a7ce27bd20d67eac647e1befb56b0be4ee39a55d2"
dependencies = [
 "winapi",
]

[[package]]
name = "anstream"
version = "0.6.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8acc5369981196006228e28809f761875c0327210a891e941f4c683b3a99529b"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "55cc3b69f167a1ef2e161439aa98aed94e6028e5f9a59be9a6ffb47aef1651f9"

[[package]]
name = "anstyle-parse"
version = "0.2.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b2d16507662817a6a20a9ea92df6652ee4f94f914589377d69f3b21bc5798a9"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "79947af37f4177cfead1110013d678905c37501914fba0efea834c3fe9a8d60c"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2109dbce0e72be3ec00bed26e6a7479ca384ad226efdd66db8fa2e3a38c83125"
dependencies = [
 "anstyle",
 "windows-sys 0.59.0",
]

[[package]]
name = "anyhow"
version = "1.0.93"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c95c10ba0b00a02636238b814946408b1322d5ac4760326e6fb8ec956d85775"

[[package]]
name = "ascii_utils"
version = "0.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "71938f30533e4d95a6d17aa530939da3842c2ab6f4f84b9dae68447e4129f74a"

[[package]]
name = "assert-size-attribute"
version = "0.1.0"
dependencies = [
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "assert_type_match"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f548ad2c4031f2902e3edc1f29c29e835829437de49562d8eb5dc5584d3a1043"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.89",
]

[[package]]
name = "async-executor"
version = "1.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "30ca9a001c1e8ba5149f91a74362376cc6bc5b919d92d988668657bd570bdcec"
dependencies = [
 "async-task",
 "concurrent-queue",
 "fastrand",
 "futures-lite",
 "slab",
]

[[package]]
name = "async-graphql"
version = "7.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ba6d24703c5adc5ba9116901b92ee4e4c0643c01a56c4fd303f3818638d7449"
dependencies = [
 "async-graphql-derive",
 "async-graphql-parser",
 "async-graphql-value",
 "async-stream",
 "async-trait",
 "base64",
 "bytes",
 "fast_chemail",
 "fnv",
 "futures-timer",
 "futures-util",
 "handlebars",
 "http",
 "indexmap 2.6.0",
 "mime",
 "multer",
 "num-traits",
 "once_cell",
 "pin-project-lite",
 "regex",
 "serde",
 "serde_json",
 "serde_urlencoded",
 "static_assertions_next",
 "tempfile",
 "thiserror",
 "time 0.3.36",
]

[[package]]
name = "async-graphql-axum"
version = "7.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e9aa80e171205c6d562057fd5a49167c8fbe61f7db2bed6540f6d4f2234d7ff2"
dependencies = [
 "async-graphql",
 "async-trait",
 "axum",
 "bytes",
 "futures-util",
 "serde_json",
 "tokio",
 "tokio-stream",
 "tokio-util",
 "tower-service",
]

[[package]]
name = "async-graphql-derive"
version = "7.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a94c2d176893486bd37cd1b6defadd999f7357bf5804e92f510c08bcf16c538f"
dependencies = [
 "Inflector",
 "async-graphql-parser",
 "darling",
 "proc-macro-crate 3.2.0",
 "proc-macro2",
 "quote",
 "strum 0.26.3",
 "syn 2.0.89",
 "thiserror",
]

[[package]]
name = "async-graphql-parser"
version = "7.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "79272bdbf26af97866e149f05b2b546edb5c00e51b5f916289931ed233e208ad"
dependencies = [
 "async-graphql-value",
 "pest",
 "serde",
 "serde_json",
]

[[package]]
name = "async-graphql-value"
version = "7.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef5ec94176a12a8cbe985cd73f2e54dc9c702c88c766bdef12f1f3a67cedbee1"
dependencies = [
 "bytes",
 "indexmap 2.6.0",
 "serde",
 "serde_json",
]

[[package]]
name = "async-stream"
version = "0.3.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b5a71a6f37880a80d1d7f19efd781e4b5de42c88f0722cc13bcb6cc2cfe8476"
dependencies = [
 "async-stream-impl",
 "futures-core",
 "pin-project-lite",
]

[[package]]
name = "async-stream-impl"
version = "0.3.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c7c24de15d275a1ecfd47a380fb4d5ec9bfe0933f309ed5e705b775596a3574d"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.89",
]

[[package]]
name = "async-task"
version = "4.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b75356056920673b02621b35afd0f7dda9306d03c79a30f5c56c44cf256e3de"

[[package]]
name = "async-trait"
version = "0.1.83"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "721cae7de5c34fbb2acd27e21e6d2cf7b886dce0c27388d46c4e6c47ea4318dd"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.89",
]

[[package]]
name = "atty"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8"
dependencies = [
 "hermit-abi 0.1.19",
 "libc",
 "winapi",
]

[[package]]
name = "autocfg"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ace50bade8e6234aa140d9a2f552bbee1db4d353f69b8217bc503490fc1a9f26"

[[package]]
name = "axum"
version = "0.7.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "edca88bc138befd0323b20752846e6587272d3b03b0343c8ea28a6f819e6e71f"
dependencies = [
 "async-trait",
 "axum-core",
 "base64",
 "bytes",
 "futures-util",
 "http",
 "http-body",
 "http-body-util",
 "hyper",
 "hyper-util",
 "itoa",
 "matchit",
 "memchr",
 "mime",
 "percent-encoding",
 "pin-project-lite",
 "rustversion",
 "serde",
 "serde_json",
 "serde_path_to_error",
 "serde_urlencoded",
 "sha1",
 "sync_wrapper 1.0.2",
 "tokio",
 "tokio-tungstenite",
 "tower",
 "tower-layer",
 "tower-service",
 "tracing",
]

[[package]]
name = "axum-core"
version = "0.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09f2bd6146b97ae3359fa0cc6d6b376d9539582c7b4220f041a33ec24c226199"
dependencies = [
 "async-trait",
 "bytes",
 "futures-util",
 "http",
 "http-body",
 "http-body-util",
 "mime",
 "pin-project-lite",
 "rustversion",
 "sync_wrapper 1.0.2",
 "tower-layer",
 "tower-service",
 "tracing",
]

[[package]]
name = "azerust-auth"
version = "0.1.0"
dependencies = [
 "anyhow",
 "assert-size-attribute",
 "async-trait",
 "azerust-axum",
 "azerust-game",
 "azerust-pg-auth",
 "azerust-utils",
 "bincode",
 "ctrlc-async",
 "deadpool",
 "deadpool-postgres",
 "derivative",
 "derive_more 0.99.18",
 "enumflags2",
 "futures-util",
 "human-panic",
 "lazy_static",
 "num-bigint",
 "num_enum",
 "opentelemetry",
 "opentelemetry-jaeger",
 "postgres",
 "postgres-native-tls",
 "rand 0.8.5",
 "serde",
 "serde_yaml",
 "static_assertions",
 "structopt",
 "test-case",
 "thiserror",
 "tokio",
 "tokio-postgres",
 "tokio-stream",
 "tokio-util",
 "tracing",
 "tracing-opentelemetry",
 "tracing-subscriber",
 "wow-srp",
 "wow_login_messages",
]

[[package]]
name = "azerust-axum"
version = "0.1.0"
dependencies = [
 "anyhow",
 "async-graphql",
 "async-graphql-axum",
 "axum",
 "azerust-game",
 "azerust-graphql-auth",
 "azerust-graphql-world",
 "tokio",
]

[[package]]
name = "azerust-game"
version = "0.1.0"
dependencies = [
 "async-trait",
 "derive_more 0.99.18",
 "enumflags2",
 "num_enum",
 "rand 0.8.5",
 "serde",
 "sha-1 0.9.8",
 "strum 0.21.0",
 "strum_macros 0.21.1",
 "thiserror",
 "time 0.3.36",
 "wow-srp",
 "wow_login_messages",
 "wow_world_messages",
]

[[package]]
name = "azerust-graphql-auth"
version = "0.1.0"
dependencies = [
 "async-graphql",
 "azerust-game",
 "time 0.3.36",
]

[[package]]
name = "azerust-graphql-world"
version = "0.1.0"
dependencies = [
 "async-graphql",
 "azerust-game",
]

[[package]]
name = "azerust-pg-auth"
version = "0.1.0"
dependencies = [
 "async-trait",
 "azerust-game",
 "cornucopia_async",
 "deadpool-postgres",
 "futures",
 "lazy_static",
 "postgres-types",
 "rand 0.8.5",
 "sha-1 0.9.8",
 "time 0.3.36",
 "tokio",
 "tokio-postgres",
 "tracing",
 "wow-srp",
]

[[package]]
name = "azerust-pg-characters"
version = "0.1.0"
dependencies = [
 "async-trait",
 "azerust-game",
 "cornucopia_async",
 "deadpool-postgres",
 "futures",
 "lazy_static",
 "postgres-types",
 "rand 0.8.5",
 "sha-1 0.9.8",
 "time 0.3.36",
 "tokio",
 "tokio-postgres",
 "tracing",
 "wow-srp",
]

[[package]]
name = "azerust-utils"
version = "0.1.0"
dependencies = [
 "anyhow",
 "tokio",
]

[[package]]
name = "azerust-world"
version = "0.1.0"
dependencies = [
 "anyhow",
 "azerust-axum",
 "azerust-game",
 "azerust-pg-auth",
 "azerust-pg-characters",
 "azerust-utils",
 "bevy",
 "bincode",
 "ctrlc-async",
 "deadpool-postgres",
 "derive_more 0.99.18",
 "flate2 1.0.35",
 "futures",
 "generic-global-variables",
 "human-panic",
 "num_enum",
 "opentelemetry",
 "opentelemetry-jaeger",
 "rand 0.8.5",
 "rust-crypto",
 "serde",
 "serde_yaml",
 "sha-1 0.9.8",
 "structopt",
 "time 0.3.36",
 "tokio",
 "tokio-stream",
 "tokio-util",
 "tracing",
 "tracing-opentelemetry",
 "tracing-subscriber",
 "wow_srp",
 "wow_world_messages",
]

[[package]]
name = "backtrace"
version = "0.3.74"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8d82cb332cdfaed17ae235a638438ac4d4839913cc2af585c3c6746e8f8bee1a"
dependencies = [
 "addr2line",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
 "windows-targets",
]

[[package]]
name = "base64"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"

[[package]]
name = "bevy"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6a01cd51a5cd310e4e7aa6e1560b1aabf29efc6a095a01e6daa8bf0a19f1fea"
dependencies = [
 "bevy_internal",
]

[[package]]
name = "bevy_app"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "652574e4c10efcfa70f98036709dd5b67e5cb8d46c58087ef48c2ac6b62df9da"
dependencies = [
 "bevy_derive",
 "bevy_ecs",
 "bevy_reflect",
 "bevy_tasks",
 "bevy_utils",
 "console_error_panic_hook",
 "ctrlc",
 "derive_more 1.0.0",
 "downcast-rs",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "bevy_core"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ecccf7be33330f58d4c7033b212a25c414d388e3a8d55b61331346da5dbabf22"
dependencies = [
 "bevy_app",
 "bevy_ecs",
 "bevy_reflect",
 "bevy_tasks",
 "bevy_utils",
 "uuid",
]

[[package]]
name = "bevy_derive"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e141b7eda52a23bb88740b37a291e26394524cb9ee3b034c7014669671fc2bb5"
dependencies = [
 "bevy_macro_utils",
 "quote",
 "syn 2.0.89",
]

[[package]]
name = "bevy_diagnostic"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa97748337405089edfb2857f7608f21bcc648a7ad272c9209808aad252ed542"
dependencies = [
 "bevy_app",
 "bevy_core",
 "bevy_ecs",
 "bevy_tasks",
 "bevy_time",
 "bevy_utils",
 "const-fnv1a-hash",
]

[[package]]
name = "bevy_ecs"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb4c4b60d2a712c6d5cbe610bac7ecf0838fc56a095fd5b15f30230873e84f15"
dependencies = [
 "bevy_ecs_macros",
 "bevy_ptr",
 "bevy_reflect",
 "bevy_tasks",
 "bevy_utils",
 "bitflags 2.6.0",
 "concurrent-queue",
 "derive_more 1.0.0",
 "disqualified",
 "fixedbitset 0.5.7",
 "nonmax",
 "petgraph",
 "serde",
 "smallvec",
]

[[package]]
name = "bevy_ecs_macros"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb4296b3254b8bd29769f6a4512731b2e6c4b163343ca18b72316927315b6096"
dependencies = [
 "bevy_macro_utils",
 "proc-macro2",
 "quote",
 "syn 2.0.89",
]

[[package]]
name = "bevy_hierarchy"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6fe0b538beea7edbf30a6062242b99e67ff3bfa716566aacf91d5b5e027f02a2"
dependencies = [
 "bevy_app",
 "bevy_core",
 "bevy_ecs",
 "bevy_reflect",
 "bevy_utils",
 "disqualified",
 "smallvec",
]

[[package]]
name = "bevy_input"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46b4ea60095d1a1851e40cb12481ad3d5d234e14376d6b73142a85586c266b74"
dependencies = [
 "bevy_app",
 "bevy_core",
 "bevy_ecs",
 "bevy_math",
 "bevy_reflect",
 "bevy_utils",
 "derive_more 1.0.0",
 "smol_str",
]

[[package]]
name = "bevy_internal"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4237e6e9b03902321032f00f931f18a4a211093bd9a7cf81276a0228a2a4417"
dependencies = [
 "bevy_app",
 "bevy_core",
 "bevy_derive",
 "bevy_diagnostic",
 "bevy_ecs",
 "bevy_hierarchy",
 "bevy_input",
 "bevy_log",
 "bevy_math",
 "bevy_ptr",
 "bevy_reflect",
 "bevy_tasks",
 "bevy_time",
 "bevy_transform",
 "bevy_utils",
]

[[package]]
name = "bevy_log"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a0bdb42b00ac3752f0d6f531fbda8abf313603157a7b3163da8529412119a0a"
dependencies = [
 "android_log-sys",
 "bevy_app",
 "bevy_ecs",
 "bevy_utils",
 "tracing-log 0.2.0",
 "tracing-oslog",
 "tracing-subscriber",
 "tracing-wasm",
]

[[package]]
name = "bevy_macro_utils"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3954dbb56a66a6c09c783e767f6ceca0dc0492c22e536e2aeaefb5545eac33c6"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.89",
 "toml_edit 0.22.22",
]

[[package]]
name = "bevy_math"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ae26f952598e293acac783d947b21af1809673cbeba25d76b969a56f287160b"
dependencies = [
 "bevy_reflect",
 "derive_more 1.0.0",
 "glam",
 "itertools",
 "rand 0.8.5",
 "rand_distr",
 "serde",
 "smallvec",
]

[[package]]
name = "bevy_ptr"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2af9e30b40fb3f0a80a658419f670f2de1e743efcaca1952c43cdcc923287944"

[[package]]
name = "bevy_reflect"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "52a37e2ae5ed62df4a0e3f958076effe280b39bc81fe878587350897a89332a2"
dependencies = [
 "assert_type_match",
 "bevy_ptr",
 "bevy_reflect_derive",
 "bevy_utils",
 "derive_more 1.0.0",
 "disqualified",
 "downcast-rs",
 "erased-serde",
 "glam",
 "serde",
 "smallvec",
 "smol_str",
]

[[package]]
name = "bevy_reflect_derive"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94c683fc68c75fc26f90bb1e529590095380d7cec66f6610dbe6b93d9fd26f94"
dependencies = [
 "bevy_macro_utils",
 "proc-macro2",
 "quote",
 "syn 2.0.89",
 "uuid",
]

[[package]]
name = "bevy_tasks"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5171c605b462b4e3249e01986505e62e3933aa27642a9f793c841814fcbbfb4f"
dependencies = [
 "async-executor",
 "futures-channel",
 "futures-lite",
 "pin-project",
 "wasm-bindgen-futures",
]

[[package]]
name = "bevy_time"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "291b6993b899c04554fc034ebb9e0d7fde9cb9b2fb58dcd912bfa6247abdedbb"
dependencies = [
 "bevy_app",
 "bevy_ecs",
 "bevy_reflect",
 "bevy_utils",
 "crossbeam-channel",
]

[[package]]
name = "bevy_transform"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc35665624d0c728107ab0920d5ad2d352362b906a8c376eaf375ec9c751faf4"
dependencies = [
 "bevy_app",
 "bevy_ecs",
 "bevy_hierarchy",
 "bevy_math",
 "bevy_reflect",
 "derive_more 1.0.0",
]

[[package]]
name = "bevy_utils"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a0a48bad33c385a7818b7683a16c8b5c6930eded05cd3f176264fc1f5acea473"
dependencies = [
 "ahash",
 "bevy_utils_proc_macros",
 "getrandom",
 "hashbrown 0.14.5",
 "thread_local",
 "tracing",
 "web-time",
]

[[package]]
name = "bevy_utils_proc_macros"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3dfd8d4a525b8f04f85863e45ccad3e922d4c11ed4a8d54f7f62a40bf83fb90f"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.89",
]

[[package]]
name = "bincode"
version = "2.0.0-rc.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f11ea1a0346b94ef188834a65c068a03aec181c94896d481d7a0a40d85b0ce95"
dependencies = [
 "bincode_derive",
 "serde",
]

[[package]]
name = "bincode_derive"
version = "2.0.0-rc.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e30759b3b99a1b802a7a3aa21c85c3ded5c28e1c83170d82d70f08bbf7f3e4c"
dependencies = [
 "virtue",
]

[[package]]
name = "bindgen"
version = "0.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f49d8fed880d473ea71efb9bf597651e77201bdd4893efe54c9e5d65ae04ce6f"
dependencies = [
 "bitflags 2.6.0",
 "cexpr",
 "clang-sys",
 "itertools",
 "log",
 "prettyplease",
 "proc-macro2",
 "quote",
 "regex",
 "rustc-hash",
 "shlex",
 "syn 2.0.89",
]

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b048fb63fd8b5923fc5aa7b340d8e156aec7ec02f0c78fa8a6ddc2613f6f71de"

[[package]]
name = "block-buffer"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4152116fd6e9dadb291ae18fc1ec3575ed6d84c29642d97890f4b4a3417297e4"
dependencies = [
 "generic-array",
]

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "bumpalo"
version = "3.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "79296716171880943b8470b5f8d03aa55eb2e645a4874bdbb28adb49162e012c"

[[package]]
name = "bytemuck"
version = "1.20.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b37c88a63ffd85d15b406896cc343916d7cf57838a847b3a6f2ca5d39a5695a"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bytes"
version = "1.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "325918d6fe32f23b19878fe4b34794ae41fc19ddbe53b10571a4874d44ffd39b"
dependencies = [
 "serde",
]

[[package]]
name = "bzip2"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42b7c3cbf0fa9c1b82308d57191728ca0256cb821220f4e2fd410a72ade26e3b"
dependencies = [
 "bzip2-sys",
 "libc",
]

[[package]]
name = "bzip2-sys"
version = "0.1.11+1.0.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "736a955f3fa7875102d57c82b8cac37ec45224a07fd32d58f9f7a186b6cd4cdc"
dependencies = [
 "cc",
 "libc",
 "pkg-config",
]

[[package]]
name = "cc"
version = "1.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f34d93e62b03caf570cccc334cbc6c2fceca82f39211051345108adcba3eebdc"
dependencies = [
 "shlex",
]

[[package]]
name = "cexpr"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6fac387a98bb7c37292057cffc56d62ecb629900026402633ae9160df93a8766"
dependencies = [
 "nom",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "cfg_aliases"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "613afe47fcd5fac7ccf1db93babcb082c5994d996f20b8b159f2ad1658eb5724"

[[package]]
name = "clang-sys"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b023947811758c97c59bf9d1c188fd619ad4718dcaa767947df1cadb14f39f4"
dependencies = [
 "glob",
 "libc",
 "libloading",
]

[[package]]
name = "clap"
version = "2.34.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a0610544180c38b88101fecf2dd634b174a62eef6946f84dfc6a7127512b381c"
dependencies = [
 "ansi_term",
 "atty",
 "bitflags 1.3.2",
 "strsim 0.8.0",
 "textwrap 0.11.0",
 "unicode-width",
 "vec_map",
]

[[package]]
name = "clap"
version = "3.2.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ea181bf566f71cb9a5d17a59e1871af638180a18fb0035c92ae62b705207123"
dependencies = [
 "atty",
 "bitflags 1.3.2",
 "clap_derive",
 "clap_lex",
 "indexmap 1.9.3",
 "once_cell",
 "strsim 0.10.0",
 "termcolor",
 "textwrap 0.16.1",
]

[[package]]
name = "clap_derive"
version = "3.2.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae6371b8bdc8b7d3959e9cf7b22d4435ef3e79e138688421ec654acf8c81b008"
dependencies = [
 "heck 0.4.1",
 "proc-macro-error",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "clap_lex"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2850f2f5a82cbf437dd5af4d49848fbdfc27c157c3d010345776f952765261c5"
dependencies = [
 "os_str_bytes",
]

[[package]]
name = "colorchoice"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b63caa9aa9397e2d9480a9b13673856c78d8ac123288526c37d7839f2a86990"

[[package]]
name = "concurrent-queue"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ca0197aee26d1ae37445ee532fefce43251d24cc7c166799f4d46817f1d3973"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "console_error_panic_hook"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a06aeb73f470f66dcdbf7223caeebb85984942f22f1adb2a088cf9668146bbbc"
dependencies = [
 "cfg-if",
 "wasm-bindgen",
]

[[package]]
name = "const-fnv1a-hash"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32b13ea120a812beba79e34316b3942a857c86ec1593cb34f27bb28272ce2cca"

[[package]]
name = "const-random"
version = "0.1.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87e00182fe74b066627d63b85fd550ac2998d4b0bd86bfed477a0ae4c7c71359"
dependencies = [
 "const-random-macro",
]

[[package]]
name = "const-random-macro"
version = "0.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f9d839f2a20b0aee515dc581a6172f2321f96cab76c1a38a4c584a194955390e"
dependencies = [
 "getrandom",
 "once_cell",
 "tiny-keccak",
]

[[package]]
name = "convert_case"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6245d59a3e82a7fc217c5828a6692dbc6dfb63a0c8c90495621f7b9d79704a0e"

[[package]]
name = "core-foundation"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "cornucopia_async"
version = "0.6.0"
dependencies = [
 "async-trait",
 "cornucopia_client_core",
 "deadpool-postgres",
 "tokio-postgres",
]

[[package]]
name = "cornucopia_client_core"
version = "0.4.0"
dependencies = [
 "fallible-iterator",
 "postgres-protocol 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)",
 "postgres-types",
]

[[package]]
name = "cpufeatures"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "16b80225097f2e5ae4e7179dd2266824648f3e2f49d9134d584b76389d31c4c3"
dependencies = [
 "libc",
]

[[package]]
name = "crc32fast"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a97769d94ddab943e4510d138150169a2758b5ef3eb191a9ee688de3e23ef7b3"
dependencies = [
 "cfg-if",
]

[[package]]
name = "crossbeam-channel"
version = "0.5.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33480d6946193aa8033910124896ca395333cae7e2d1113d1fef6c3272217df2"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-deque"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "613f8cc01fe9cf1a3eb3d7f488fd2fa8388403e97039e2f73692932e291a770d"
dependencies = [
 "crossbeam-epoch",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22ec99545bb0ed0ea7bb9b8e1e9122ea386ff8a48c0922e43f36d45ab09e0e80"

[[package]]
name = "crunchy"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a81dae078cea95a014a339291cec439d2f232ebe854a9d672b796c6afafa9b7"

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "ctrlc"
version = "3.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "90eeab0aa92f3f9b4e87f258c72b139c207d251f9cbc1080a0086b86a8870dd3"
dependencies = [
 "nix 0.29.0",
 "windows-sys 0.59.0",
]

[[package]]
name = "ctrlc-async"
version = "3.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "598e9d68e769aa1283460a3b0ec0d049ccfb6170277aea37089fa3f58fd721a1"
dependencies = [
 "nix 0.23.2",
 "tokio",
 "winapi",
]

[[package]]
name = "darling"
version = "0.20.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f63b86c8a8826a49b8c21f08a2d07338eec8d900540f8630dc76284be802989"
dependencies = [
 "darling_core",
 "darling_macro",
]

[[package]]
name = "darling_core"
version = "0.20.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "95133861a8032aaea082871032f5815eb9e98cef03fa916ab4500513994df9e5"
dependencies = [
 "fnv",
 "ident_case",
 "proc-macro2",
 "quote",
 "strsim 0.11.1",
 "syn 2.0.89",
]

[[package]]
name = "darling_macro"
version = "0.20.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d336a2a514f6ccccaa3e09b02d41d35330c07ddf03a62165fcec10bb561c7806"
dependencies = [
 "darling_core",
 "quote",
 "syn 2.0.89",
]

[[package]]
name = "data-encoding"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8566979429cf69b49a5c740c60791108e86440e8be149bbea4fe54d2c32d6e2"

[[package]]
name = "deadpool"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fb84100978c1c7b37f09ed3ce3e5f843af02c2a2c431bae5b19230dad2c1b490"
dependencies = [
 "async-trait",
 "deadpool-runtime",
 "num_cpus",
 "tokio",
]

[[package]]
name = "deadpool-postgres"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bda39fa1cfff190d8924d447ad04fd22772c250438ca5ce1dfb3c80621c05aaa"
dependencies = [
 "deadpool",
 "tokio",
 "tokio-postgres",
 "tracing",
]

[[package]]
name = "deadpool-runtime"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "092966b41edc516079bdf31ec78a2e0588d1d0c08f78b91d8307215928642b2b"
dependencies = [
 "tokio",
]

[[package]]
name = "deranged"
version = "0.3.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b42b6fa04a440b495c8b04d0e71b707c585f83cb9cb28cf8cd0d976c315e31b4"
dependencies = [
 "powerfmt",
]

[[package]]
name = "derivative"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fcc3dd5e9e9c0b295d6e1e4d811fb6f157d5ffd784b8d202fc62eac8035a770b"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "derive_more"
version = "0.99.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f33878137e4dafd7fa914ad4e259e18a4e8e532b9617a2d0150262bf53abfce"
dependencies = [
 "convert_case",
 "proc-macro2",
 "quote",
 "rustc_version",
 "syn 2.0.89",
]

[[package]]
name = "derive_more"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a9b99b9cbbe49445b21764dc0625032a89b145a2642e67603e1c936f5458d05"
dependencies = [
 "derive_more-impl",
]

[[package]]
name = "derive_more-impl"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb7330aeadfbe296029522e6c40f315320aba36fc43a5b3632f3795348f3bd22"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.89",
 "unicode-xid",
]

[[package]]
name = "digest"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3dd60d1080a57a05ab032377049e0591415d2b31afd7028356dbf3cc6dcb066"
dependencies = [
 "generic-array",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer 0.10.4",
 "crypto-common",
 "subtle",
]

[[package]]
name = "disqualified"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c9c272297e804878a2a4b707cfcfc6d2328b5bb936944613b4fdf2b9269afdfd"

[[package]]
name = "downcast-rs"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75b325c5dbd37f80359721ad39aca5a29fb04c89279657cffdda8736d0c0b9d2"

[[package]]
name = "either"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60b1af1c220855b6ceac025d3f6ecdd2b7c4894bfe9cd9bda4fbb4bc7c0d4cf0"

[[package]]
name = "encoding_rs"
version = "0.8.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75030f3c4f45dafd7586dd6780965a8c7e8e285a5ecb86713e63a79c5b2766f3"
dependencies = [
 "cfg-if",
]

[[package]]
name = "enumflags2"
version = "0.7.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d232db7f5956f3f14313dc2f87985c58bd2c695ce124c8cdd984e08e15ac133d"
dependencies = [
 "enumflags2_derive",
]

[[package]]
name = "enumflags2_derive"
version = "0.7.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "de0d48a183585823424a4ce1aa132d174a6a81bd540895822eb4c8373a8e49e8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.89",
]

[[package]]
name = "equivalent"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5"

[[package]]
name = "erased-serde"
version = "0.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24e2389d65ab4fab27dc2a5de7b191e1f6617d1f1c8855c0dc569c94a4cbb18d"
dependencies = [
 "serde",
 "typeid",
]

[[package]]
name = "errno"
version = "0.3.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33d852cb9b869c2a9b3df2f71a3074817f01e1844f839a144f5fcef059a4eb5d"
dependencies = [
 "libc",
 "windows-sys 0.59.0",
]

[[package]]
name = "fallible-iterator"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4443176a9f2c162692bd3d352d745ef9413eec5782a80d8fd6f8a1ac692a07f7"

[[package]]
name = "fast_chemail"
version = "0.9.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "495a39d30d624c2caabe6312bfead73e7717692b44e0b32df168c275a2e8e9e4"
dependencies = [
 "ascii_utils",
]

[[package]]
name = "fastrand"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "486f806e73c5707928240ddc295403b1b93c96a02038563881c4a2fd84b81ac4"

[[package]]
name = "fixedbitset"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ce7134b9999ecaf8bcd65542e436736ef32ddca1b3e06094cb6ec5755203b80"

[[package]]
name = "fixedbitset"
version = "0.5.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d674e81391d1e1ab681a28d99df07927c6d4aa5b027d7da16ba32d1d21ecd99"

[[package]]
name = "flate2"
version = "0.2.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6234dd4468ae5d1e2dbb06fe2b058696fdc50a339c68a393aefbf00bc81e423"
dependencies = [
 "libc",
 "miniz-sys",
]

[[package]]
name = "flate2"
version = "1.0.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c936bfdafb507ebbf50b8074c54fa31c5be9a1e7e5f467dd659697041407d07c"
dependencies = [
 "crc32fast",
 "libz-sys",
 "miniz_oxide",
]

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "foreign-types"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
dependencies = [
 "foreign-types-shared",
]

[[package]]
name = "foreign-types-shared"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"

[[package]]
name = "form_urlencoded"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e13624c2627564efccf4934284bdd98cbaa14e79b0b5a141218e507b3a823456"
dependencies = [
 "percent-encoding",
]

[[package]]
name = "fuchsia-cprng"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a06f77d526c1a601b7c4cdd98f54b5eaabffc14d5f2f0296febdc7f357c6d3ba"

[[package]]
name = "futures"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "65bc07b1a8bc7c85c5f2e110c476c7389b4554ba72af57d8445ea63a576b0876"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-io",
 "futures-sink",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-channel"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10"
dependencies = [
 "futures-core",
 "futures-sink",
]

[[package]]
name = "futures-core"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"

[[package]]
name = "futures-executor"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e28d1d997f585e54aebc3f97d39e72338912123a67330d723fdbb564d646c9f"
dependencies = [
 "futures-core",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-io"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"

[[package]]
name = "futures-lite"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cef40d21ae2c515b51041df9ed313ed21e572df340ea58a922a0aefe7e8891a1"
dependencies = [
 "fastrand",
 "futures-core",
 "futures-io",
 "parking",
 "pin-project-lite",
]

[[package]]
name = "futures-macro"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "162ee34ebcb7c64a8abebc059ce0fee27c2262618d7b60ed8faf72fef13c3650"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.89",
]

[[package]]
name = "futures-sink"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e575fab7d1e0dcb8d0c7bcf9a63ee213816ab51902e6d244a95819acacf1d4f7"

[[package]]
name = "futures-task"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f90f7dce0722e95104fcb095585910c0977252f286e354b5e3bd38902cd99988"

[[package]]
name = "futures-timer"
version = "3.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f288b0a4f20f9a56b5d1da57e2227c661b7b16168e2f72365f57b63326e29b24"

[[package]]
name = "futures-util"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-macro",
 "futures-sink",
 "futures-task",
 "memchr",
 "pin-project-lite",
 "pin-utils",
 "slab",
]

[[package]]
name = "gcc"
version = "0.3.55"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f5f3913fa0bfe7ee1fd8248b6b9f42a5af4b9d65ec2dd2c3c26132b950ecfc2"

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "generic-global-variables"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8254927bae06bf12ca769e6a3520e8c13846d4dc0673aa6d2e4dcc5542cffba"
dependencies = [
 "parking_lot",
]

[[package]]
name = "getopts"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "14dbbfd5c71d70241ecf9e6f13737f7b5ce823821063188d7e46c41d371eebd5"
dependencies = [
 "unicode-width",
]

[[package]]
name = "getrandom"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7"
dependencies = [
 "cfg-if",
 "js-sys",
 "libc",
 "wasi 0.11.0+wasi-snapshot-preview1",
 "wasm-bindgen",
]

[[package]]
name = "gimli"
version = "0.31.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07e28edb80900c19c28f1072f2e8aeca7fa06b23cd4169cefe1af5aa3260783f"

[[package]]
name = "glam"
version = "0.29.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc46dd3ec48fdd8e693a98d2b8bafae273a2d54c1de02a2a7e3d57d501f39677"
dependencies = [
 "bytemuck",
 "rand 0.8.5",
 "serde",
]

[[package]]
name = "glob"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d2fabcfbdc87f4758337ca535fb41a6d701b65693ce38287d856d1674551ec9b"

[[package]]
name = "handlebars"
version = "5.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d08485b96a0e6393e9e4d1b8d48cf74ad6c063cd905eb33f42c1ce3f0377539b"
dependencies = [
 "log",
 "pest",
 "pest_derive",
 "serde",
 "serde_json",
 "thiserror",
]

[[package]]
name = "hashbrown"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888"

[[package]]
name = "hashbrown"
version = "0.14.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1"
dependencies = [
 "ahash",
 "allocator-api2",
 "serde",
]

[[package]]
name = "hashbrown"
version = "0.15.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf151400ff0baff5465007dd2f3e717f3fe502074ca563069ce3a6629d07b289"

[[package]]
name = "heck"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d621efb26863f0e9924c6ac577e8275e5e6b77455db64ffa6c65c904e9e132c"
dependencies = [
 "unicode-segmentation",
]

[[package]]
name = "heck"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "95505c38b4572b2d910cecb0281560f54b440a19336cbbcb27bf6ce6adc6f5a8"

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "hermit-abi"
version = "0.1.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33"
dependencies = [
 "libc",
]

[[package]]
name = "hermit-abi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d231dfb89cfffdbc30e7fc41579ed6066ad03abda9e567ccafae602b97ec5024"

[[package]]
name = "hmac"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c49c37c09c17a53d937dfbb742eb3a961d65a994e6bcdcf37e7399d0cc8ab5e"
dependencies = [
 "digest 0.10.7",
]

[[package]]
name = "http"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "21b9ddb458710bc376481b842f5da65cdf31522de232c1ca8146abce2a358258"
dependencies = [
 "bytes",
 "fnv",
 "itoa",
]

[[package]]
name = "http-body"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1efedce1fb8e6913f23e0c92de8e62cd5b772a67e7b3946df930a62566c93184"
dependencies = [
 "bytes",
 "http",
]

[[package]]
name = "http-body-util"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "793429d76616a256bcb62c2a2ec2bed781c8307e797e2598c50010f2bee2544f"
dependencies = [
 "bytes",
 "futures-util",
 "http",
 "http-body",
 "pin-project-lite",
]

[[package]]
name = "httparse"
version = "1.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7d71d3574edd2771538b901e6549113b4006ece66150fb69c0fb6d9a2adae946"

[[package]]
name = "httpdate"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df3b46402a9d5adb4c86a0cf463f42e19994e3ee891101b1841f30a545cb49a9"

[[package]]
name = "human-panic"
version = "2.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "80b84a66a325082740043a6c28bbea400c129eac0d3a27673a1de971e44bf1f7"
dependencies = [
 "anstream",
 "anstyle",
 "backtrace",
 "os_info",
 "serde",
 "serde_derive",
 "toml",
 "uuid",
]

[[package]]
name = "hyper"
version = "1.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97818827ef4f364230e16705d4706e2897df2bb60617d6ca15d598025a3c481f"
dependencies = [
 "bytes",
 "futures-channel",
 "futures-util",
 "http",
 "http-body",
 "httparse",
 "httpdate",
 "itoa",
 "pin-project-lite",
 "smallvec",
 "tokio",
]

[[package]]
name = "hyper-util"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df2dcfbe0677734ab2f3ffa7fa7bfd4706bfdc1ef393f2ee30184aed67e631b4"
dependencies = [
 "bytes",
 "futures-util",
 "http",
 "http-body",
 "hyper",
 "pin-project-lite",
 "tokio",
 "tower-service",
]

[[package]]
name = "ident_case"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39"

[[package]]
name = "implode"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "be6aed12e8500c350a4009ebdcf0098c89948617e9b846e3c9bbc56a48b56914"

[[package]]
name = "indexmap"
version = "1.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99"
dependencies = [
 "autocfg",
 "hashbrown 0.12.3",
]

[[package]]
name = "indexmap"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "707907fe3c25f5424cce2cb7e1cbcafee6bdbe735ca90ef77c29e84591e5b9da"
dependencies = [
 "equivalent",
 "hashbrown 0.15.2",
 "serde",
]

[[package]]
name = "integer-encoding"
version = "3.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8bb03732005da905c88227371639bf1ad885cc712789c011c31c5fb3ab3ccf02"

[[package]]
name = "is_terminal_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7943c866cc5cd64cbc25b2e01621d07fa8eb2a1a23160ee81ce38704e97b8ecf"

[[package]]
name = "itertools"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "413ee7dfc52ee1a4949ceeb7dbc8a33f2d6c088194d9f922fb8318faf1f01186"
dependencies = [
 "either",
]

[[package]]
name = "itoa"
version = "1.0.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d75a2a4b1b190afb6f5425f10f6a8f959d2ea0b9c2b1d79553551850539e4674"

[[package]]
name = "js-sys"
version = "0.3.72"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a88f1bda2bd75b0452a14784937d796722fdebfe50df998aeb3f0b7603019a9"
dependencies = [
 "wasm-bindgen",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "libc"
version = "0.2.167"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09d6582e104315a817dff97f75133544b2e094ee22447d2acf4a74e189ba06fc"

[[package]]
name = "libloading"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc2f4eb4bc735547cfed7c0a4922cbd04a4655978c09b54f1f7b228750664c34"
dependencies = [
 "cfg-if",
 "windows-targets",
]

[[package]]
name = "libm"
version = "0.2.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8355be11b20d696c8f18f6cc018c4e372165b1fa8126cef092399c9951984ffa"

[[package]]
name = "libz-sys"
version = "1.1.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d2d16453e800a8cf6dd2fc3eb4bc99b786a9b90c663b8559a5b1a041bf89e472"
dependencies = [
 "cc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "linux-raw-sys"
version = "0.4.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78b3ae25bc7c8c38cec158d1f2757ee79e9b3740fbc7ccf0e59e4b08d793fa89"

[[package]]
name = "lock_api"
version = "0.4.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7a70ba024b9dc04c27ea2f0c0548feb474ec5c54bba33a7f72f873a39d07b24"

[[package]]
name = "matchers"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8263075bb86c5a1b1427b5ae862e8889656f126e9f77c484496e8b47cf5c5558"
dependencies = [
 "regex-automata 0.1.10",
]

[[package]]
name = "matchit"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0e7465ac9959cc2b1404e8e2367b43684a6d13790fe23056cc8c6c5a6b7bcb94"

[[package]]
name = "md-5"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d89e7ee0cfbedfc4da3340218492196241d89eefb6dab27de5df917a6d2e78cf"
dependencies = [
 "cfg-if",
 "digest 0.10.7",
]

[[package]]
name = "memchr"
version = "2.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"

[[package]]
name = "memoffset"
version = "0.6.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5aa361d4faea93603064a027415f07bd8e1d5c88c9fbf68bf56a285428fd79ce"
dependencies = [
 "autocfg",
]

[[package]]
name = "mime"
version = "0.3.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"

[[package]]
name = "minimal-lexical"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"

[[package]]
name = "miniz-sys"
version = "0.1.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e9e3ae51cea1576ceba0dde3d484d30e6e5b86dee0b2d412fe3a16a15c98202"
dependencies = [
 "cc",
 "libc",
]

[[package]]
name = "miniz_oxide"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2d80299ef12ff69b16a84bb182e3b9df68b5a91574d3d4fa6e41b65deec4df1"
dependencies = [
 "adler2",
]

[[package]]
name = "mio"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "80e04d1dcff3aae0704555fe5fee3bcfaf3d1fdf8a7e521d5b9d2b42acb52cec"
dependencies = [
 "hermit-abi 0.3.9",
 "libc",
 "wasi 0.11.0+wasi-snapshot-preview1",
 "windows-sys 0.52.0",
]

[[package]]
name = "mpq"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd98ff6f9468e8d8dd80f1ef4c94b8e2ad81ea4f48604de8476e75cdf6b3f559"
dependencies = [
 "adler32",
 "byteorder",
 "bzip2",
 "flate2 0.2.20",
 "getopts",
 "implode",
]

[[package]]
name = "mpqextract"
version = "0.1.0"
dependencies = [
 "anyhow",
 "clap 3.2.25",
 "mpq",
 "rayon",
]

[[package]]
name = "multer"
version = "3.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "83e87776546dc87511aa5ee218730c92b666d7264ab6ed41f9d215af9cd5224b"
dependencies = [
 "bytes",
 "encoding_rs",
 "futures-util",
 "http",
 "httparse",
 "memchr",
 "mime",
 "spin",
 "version_check",
]

[[package]]
name = "native-tls"
version = "0.2.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8614eb2c83d59d1c8cc974dd3f920198647674a0a035e1af1fa58707e317466"
dependencies = [
 "libc",
 "log",
 "openssl",
 "openssl-probe",
 "openssl-sys",
 "schannel",
 "security-framework",
 "security-framework-sys",
 "tempfile",
]

[[package]]
name = "nix"
version = "0.23.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f3790c00a0150112de0f4cd161e3d7fc4b2d8a5542ffc35f099a2562aecb35c"
dependencies = [
 "bitflags 1.3.2",
 "cc",
 "cfg-if",
 "libc",
 "memoffset",
]

[[package]]
name = "nix"
version = "0.29.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "71e2746dc3a24dd78b3cfcb7be93368c6de9963d30f43a6a73998a9cf4b17b46"
dependencies = [
 "bitflags 2.6.0",
 "cfg-if",
 "cfg_aliases",
 "libc",
]

[[package]]
name = "nom"
version = "7.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
dependencies = [
 "memchr",
 "minimal-lexical",
]

[[package]]
name = "nonmax"
version = "0.5.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "610a5acd306ec67f907abe5567859a3c693fb9886eb1f012ab8f2a47bef3db51"

[[package]]
name = "nu-ansi-term"
version = "0.46.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77a8165726e8236064dbb45459242600304b42a5ea24ee2948e18e023bf7ba84"
dependencies = [
 "overload",
 "winapi",
]

[[package]]
name = "num-bigint"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a5e44f723f1133c9deac646763579fdb3ac745e418f2a7af9cd0c431da1f20b9"
dependencies = [
 "num-integer",
 "num-traits",
]

[[package]]
name = "num-conv"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "51d515d32fb182ee37cda2ccdcb92950d6a3c2893aa280e540671c2cd0f3b1d9"

[[package]]
name = "num-integer"
version = "0.1.46"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7969661fd2958a5cb096e56c8e1ad0444ac2bbcd0061bd28660485a44879858f"
dependencies = [
 "num-traits",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
 "libm",
]

[[package]]
name = "num_cpus"
version = "1.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4161fcb6d602d4d2081af7c3a45852d875a03dd337a6bfdd6e06407b61342a43"
dependencies = [
 "hermit-abi 0.3.9",
 "libc",
]

[[package]]
name = "num_enum"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f646caf906c20226733ed5b1374287eb97e3c2a5c227ce668c1f2ce20ae57c9"
dependencies = [
 "num_enum_derive",
]

[[package]]
name = "num_enum_derive"
version = "0.5.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dcbff9bc912032c62bf65ef1d5aea88983b420f4f839db1e9b0c281a25c9c799"
dependencies = [
 "proc-macro-crate 1.3.1",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "object"
version = "0.36.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aedf0a2d09c573ed1d8d85b30c119153926a2b36dce0ab28322c09a117a4683e"
dependencies = [
 "memchr",
]

[[package]]
name = "once_cell"
version = "1.20.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1261fe7e33c73b354eab43b1273a57c8f967d0391e80353e51f764ac02cf6775"

[[package]]
name = "opaque-debug"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08d65885ee38876c4f86fa503fb49d7b507c2b62552df7c70b2fce627e06381"

[[package]]
name = "openssl"
version = "0.10.68"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6174bc48f102d208783c2c84bf931bb75927a617866870de8a4ea85597f871f5"
dependencies = [
 "bitflags 2.6.0",
 "cfg-if",
 "foreign-types",
 "libc",
 "once_cell",
 "openssl-macros",
 "openssl-sys",
]

[[package]]
name = "openssl-macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a948666b637a0f465e8564c73e89d4dde00d72d4d473cc972f390fc3dcee7d9c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.89",
]

[[package]]
name = "openssl-probe"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff011a302c396a5197692431fc1948019154afc178baf7d8e37367442a4601cf"

[[package]]
name = "openssl-sys"
version = "0.9.104"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "45abf306cbf99debc8195b66b7346498d7b10c210de50418b5ccd7ceba08c741"
dependencies = [
 "cc",
 "libc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "opentelemetry"
version = "0.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6105e89802af13fdf48c49d7646d3b533a70e536d818aae7e78ba0433d01acb8"
dependencies = [
 "async-trait",
 "crossbeam-channel",
 "futures-channel",
 "futures-executor",
 "futures-util",
 "js-sys",
 "lazy_static",
 "percent-encoding",
 "pin-project",
 "rand 0.8.5",
 "thiserror",
 "tokio",
 "tokio-stream",
]

[[package]]
name = "opentelemetry-jaeger"
version = "0.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f8c0b12cd9e3f9b35b52f6e0dac66866c519b26f424f4bbf96e3fe8bfbdc5229"
dependencies = [
 "async-trait",
 "lazy_static",
 "opentelemetry",
 "opentelemetry-semantic-conventions",
 "thiserror",
 "thrift",
 "tokio",
]

[[package]]
name = "opentelemetry-semantic-conventions"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "985cc35d832d412224b2cffe2f9194b1b89b6aa5d0bef76d080dce09d90e62bd"
dependencies = [
 "opentelemetry",
]

[[package]]
name = "ordered-float"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3305af35278dd29f46fcdd139e0b1fbfae2153f0e5928b39b035542dd31e37b7"
dependencies = [
 "num-traits",
]

[[package]]
name = "os_info"
version = "3.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae99c7fa6dd38c7cafe1ec085e804f8f555a2f8659b0dbe03f1f9963a9b51092"
dependencies = [
 "log",
 "serde",
 "windows-sys 0.52.0",
]

[[package]]
name = "os_str_bytes"
version = "6.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2355d85b9a3786f481747ced0e0ff2ba35213a1f9bd406ed906554d7af805a1"

[[package]]
name = "overload"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b15813163c1d831bf4a13c3610c05c0d03b39feb07f7e09fa234dac9b15aaf39"

[[package]]
name = "parking"
version = "2.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f38d5652c16fde515bb1ecef450ab0f6a219d619a7274976324d5e377f7dceba"

[[package]]
name = "parking_lot"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1bf18183cf54e8d6059647fc3063646a1801cf30896933ec2311622cc4b9a27"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall",
 "smallvec",
 "windows-targets",
]

[[package]]
name = "percent-encoding"
version = "2.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"

[[package]]
name = "pest"
version = "2.7.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "879952a81a83930934cbf1786752d6dedc3b1f29e8f8fb2ad1d0a36f377cf442"
dependencies = [
 "memchr",
 "thiserror",
 "ucd-trie",
]

[[package]]
name = "pest_derive"
version = "2.7.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d214365f632b123a47fd913301e14c946c61d1c183ee245fa76eb752e59a02dd"
dependencies = [
 "pest",
 "pest_generator",
]

[[package]]
name = "pest_generator"
version = "2.7.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eb55586734301717aea2ac313f50b2eb8f60d2fc3dc01d190eefa2e625f60c4e"
dependencies = [
 "pest",
 "pest_meta",
 "proc-macro2",
 "quote",
 "syn 2.0.89",
]

[[package]]
name = "pest_meta"
version = "2.7.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b75da2a70cf4d9cb76833c990ac9cd3923c9a8905a8929789ce347c84564d03d"
dependencies = [
 "once_cell",
 "pest",
 "sha2",
]

[[package]]
name = "petgraph"
version = "0.6.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b4c5cc86750666a3ed20bdaf5ca2a0344f9c67674cae0515bec2da16fbaa47db"
dependencies = [
 "fixedbitset 0.4.2",
 "indexmap 2.6.0",
]

[[package]]
name = "phf"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ade2d8b8f33c7333b51bcf0428d37e217e9f32192ae4772156f65063b8ce03dc"
dependencies = [
 "phf_shared",
]

[[package]]
name = "phf_shared"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "90fcb95eef784c2ac79119d1dd819e162b5da872ce6f3c3abe1e8ca1c082f72b"
dependencies = [
 "siphasher",
]

[[package]]
name = "pin-project"
version = "1.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "be57f64e946e500c8ee36ef6331845d40a93055567ec57e8fae13efd33759b95"
dependencies = [
 "pin-project-internal",
]

[[package]]
name = "pin-project-internal"
version = "1.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c0f5fad0874fc7abcd4d750e76917eaebbecaa2c20bde22e1dbeeba8beb758c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.89",
]

[[package]]
name = "pin-project-lite"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "915a1e146535de9163f3987b8944ed8cf49a18bb0056bcebcdcece385cece4ff"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "pkg-config"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "953ec861398dccce10c670dfeaf3ec4911ca479e9c02154b3a215178c5f566f2"

[[package]]
name = "postgres"
version = "0.19.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "95c918733159f4d55d2ceb262950f00b0aebd6af4aa97b5a47bb0655120475ed"
dependencies = [
 "bytes",
 "fallible-iterator",
 "futures-util",
 "log",
 "tokio",
 "tokio-postgres",
]

[[package]]
name = "postgres-native-tls"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2d442770e2b1e244bb5eb03b31c79b65bb2568f413b899eaba850fa945a65954"
dependencies = [
 "futures",
 "native-tls",
 "tokio",
 "tokio-native-tls",
 "tokio-postgres",
]

[[package]]
name = "postgres-protocol"
version = "0.6.7"
dependencies = [
 "base64",
 "byteorder",
 "bytes",
 "fallible-iterator",
 "hmac",
 "md-5",
 "memchr",
 "rand 0.8.5",
 "sha2",
 "stringprep",
]

[[package]]
name = "postgres-protocol"
version = "0.6.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "acda0ebdebc28befa84bee35e651e4c5f09073d668c7aed4cf7e23c3cda84b23"
dependencies = [
 "base64",
 "byteorder",
 "bytes",
 "fallible-iterator",
 "hmac",
 "md-5",
 "memchr",
 "rand 0.8.5",
 "sha2",
 "stringprep",
]

[[package]]
name = "postgres-types"
version = "0.2.8"
dependencies = [
 "bytes",
 "fallible-iterator",
 "postgres-protocol 0.6.7",
 "time 0.3.36",
]

[[package]]
name = "powerfmt"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "439ee305def115ba05938db6eb1644ff94165c5ab5e9420d1c1bcedbba909391"

[[package]]
name = "ppv-lite86"
version = "0.2.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77957b295656769bb8ad2b6a6b09d897d94f05c41b069aede1fcdaa675eaea04"
dependencies = [
 "zerocopy",
]

[[package]]
name = "prettyplease"
version = "0.2.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "64d1ec885c64d0457d564db4ec299b2dae3f9c02808b8ad9c3a089c591b18033"
dependencies = [
 "proc-macro2",
 "syn 2.0.89",
]

[[package]]
name = "proc-macro-crate"
version = "1.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f4c021e1093a56626774e81216a4ce732a735e5bad4868a03f3ed65ca0c3919"
dependencies = [
 "once_cell",
 "toml_edit 0.19.15",
]

[[package]]
name = "proc-macro-crate"
version = "3.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ecf48c7ca261d60b74ab1a7b20da18bede46776b2e55535cb958eb595c5fa7b"
dependencies = [
 "toml_edit 0.22.22",
]

[[package]]
name = "proc-macro-error"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c"
dependencies = [
 "proc-macro-error-attr",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
 "version_check",
]

[[package]]
name = "proc-macro-error-attr"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869"
dependencies = [
 "proc-macro2",
 "quote",
 "version_check",
]

[[package]]
name = "proc-macro2"
version = "1.0.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37d3544b3f2748c54e147655edb5025752e2303145b5aefb3c3ea2c78b973bb0"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.37"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b5b9d34b8991d19d98081b46eacdd8eb58c6f2b201139f7c5f643cc155a633af"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "rand"
version = "0.3.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "64ac302d8f83c0c1974bf758f6b041c6c8ada916fbb44a609158ca8b064cc76c"
dependencies = [
 "libc",
 "rand 0.4.6",
]

[[package]]
name = "rand"
version = "0.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "552840b97013b1a26992c11eac34bdd778e464601a4c2054b5f0bff7c6761293"
dependencies = [
 "fuchsia-cprng",
 "libc",
 "rand_core 0.3.1",
 "rdrand",
 "winapi",
]

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha",
 "rand_core 0.6.4",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core 0.6.4",
]

[[package]]
name = "rand_core"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a6fdeb83b075e8266dcc8762c22776f6877a63111121f5f8c7411e5be7eed4b"
dependencies = [
 "rand_core 0.4.2",
]

[[package]]
name = "rand_core"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c33a3c44ca05fa6f1807d8e6743f3824e8509beca625669633be0acbdf509dc"

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom",
]

[[package]]
name = "rand_distr"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32cb0b9bc82b0a0876c2dd994a7e7a2683d3e7390ca40e6886785ef0c7e3ee31"
dependencies = [
 "num-traits",
 "rand 0.8.5",
]

[[package]]
name = "rayon"
version = "1.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b418a60154510ca1a002a752ca9714984e21e4241e804d32555251faf8b78ffa"
dependencies = [
 "either",
 "rayon-core",
]

[[package]]
name = "rayon-core"
version = "1.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1465873a3dfdaa8ae7cb14b4383657caab0b3e8a0aa9ae8e04b044854c8dfce2"
dependencies = [
 "crossbeam-deque",
 "crossbeam-utils",
]

[[package]]
name = "rdrand"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "678054eb77286b51581ba43620cc911abf02758c91f93f479767aed0f90458b2"
dependencies = [
 "rand_core 0.3.1",
]

[[package]]
name = "redox_syscall"
version = "0.5.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b6dfecf2c74bce2466cabf93f6664d6998a69eb21e39f4207930065b27b771f"
dependencies = [
 "bitflags 2.6.0",
]

[[package]]
name = "regex"
version = "1.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b544ef1b4eac5dc2db33ea63606ae9ffcfac26c1416a2806ae0bf5f56b201191"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata 0.4.9",
 "regex-syntax 0.8.5",
]

[[package]]
name = "regex-automata"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c230d73fb8d8c1b9c0b3135c5142a8acee3a0558fb8db5cf1cb65f8d7862132"
dependencies = [
 "regex-syntax 0.6.29",
]

[[package]]
name = "regex-automata"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "809e8dc61f6de73b46c85f4c96486310fe304c434cfa43669d7b40f711150908"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax 0.8.5",
]

[[package]]
name = "regex-syntax"
version = "0.6.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f162c6dd7b008981e4d40210aca20b4bd0f9b60ca9271061b07f78537722f2e1"

[[package]]
name = "regex-syntax"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c"

[[package]]
name = "rust-crypto"
version = "0.2.36"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f76d05d3993fd5f4af9434e8e436db163a12a9d40e1a58a726f27a01dfd12a2a"
dependencies = [
 "gcc",
 "libc",
 "rand 0.3.23",
 "rustc-serialize",
 "time 0.1.45",
]

[[package]]
name = "rustc-demangle"
version = "0.1.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"

[[package]]
name = "rustc-hash"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"

[[package]]
name = "rustc-serialize"
version = "0.3.25"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fe834bc780604f4674073badbad26d7219cadfb4a2275802db12cbae17498401"

[[package]]
name = "rustc_version"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfcb3a22ef46e85b45de6ee7e79d063319ebb6594faafcf1c225ea92ab6e9b92"
dependencies = [
 "semver",
]

[[package]]
name = "rustix"
version = "0.38.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d7f649912bc1495e167a6edee79151c84b1bad49748cb4f1f1167f459f6224f6"
dependencies = [
 "bitflags 2.6.0",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.52.0",
]

[[package]]
name = "rustversion"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0e819f2bc632f285be6d7cd36e25940d45b2391dd6d9b939e79de557f7014248"

[[package]]
name = "ryu"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3cb5ba0dc43242ce17de99c180e96db90b235b8a9fdc9543c96d2209116bd9f"

[[package]]
name = "schannel"
version = "0.1.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f29ebaa345f945cec9fbbc532eb307f0fdad8161f281b6369539c8d84876b3d"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "security-framework"
version = "2.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "897b2245f0b511c87893af39b033e5ca9cce68824c4d7e7630b5a1d339658d02"
dependencies = [
 "bitflags 2.6.0",
 "core-foundation",
 "core-foundation-sys",
 "libc",
 "security-framework-sys",
]

[[package]]
name = "security-framework-sys"
version = "2.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa39c7303dc58b5543c94d22c1766b0d31f2ee58306363ea622b10bbc075eaa2"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "semver"
version = "1.0.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "61697e0a1c7e512e84a621326239844a24d8207b4669b41bc18b32ea5cbf988b"

[[package]]
name = "serde"
version = "1.0.215"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6513c1ad0b11a9376da888e3e0baa0077f1aed55c17f50e7b2397136129fb88f"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.215"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ad1e866f866923f252f05c889987993144fb74e722403468a4ebd70c3cd756c0"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.89",
]

[[package]]
name = "serde_json"
version = "1.0.133"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c7fceb2473b9166b2294ef05efcb65a3db80803f0b03ef86a5fc88a2b85ee377"
dependencies = [
 "itoa",
 "memchr",
 "ryu",
 "serde",
]

[[package]]
name = "serde_path_to_error"
version = "0.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "af99884400da37c88f5e9146b7f1fd0fbcae8f6eec4e9da38b67d05486f814a6"
dependencies = [
 "itoa",
 "serde",
]

[[package]]
name = "serde_spanned"
version = "0.6.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87607cb1398ed59d48732e575a4c28a7a8ebf2454b964fe3f224f2afc07909e1"
dependencies = [
 "serde",
]

[[package]]
name = "serde_urlencoded"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3491c14715ca2294c4d6a88f15e84739788c1d030eed8c110436aafdaa2f3fd"
dependencies = [
 "form_urlencoded",
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "serde_yaml"
version = "0.9.34+deprecated"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a8b1a1a2ebf674015cc02edccce75287f1a0130d394307b36743c2f5d504b47"
dependencies = [
 "indexmap 2.6.0",
 "itoa",
 "ryu",
 "serde",
 "unsafe-libyaml",
]

[[package]]
name = "sha-1"
version = "0.9.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "99cd6713db3cf16b6c84e06321e049a9b9f699826e16096d23bbcc44d15d51a6"
dependencies = [
 "block-buffer 0.9.0",
 "cfg-if",
 "cpufeatures",
 "digest 0.9.0",
 "opaque-debug",
]

[[package]]
name = "sha-1"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f5058ada175748e33390e40e872bd0fe59a19f265d0158daa551c5a88a76009c"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest 0.10.7",
]

[[package]]
name = "sha1"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3bf829a2d51ab4a5ddf1352d8470c140cadc8301b2ae1789db023f01cedd6ba"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest 0.10.7",
]

[[package]]
name = "sha2"
version = "0.10.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "793db75ad2bcafc3ffa7c68b215fee268f537982cd901d132f89c6343f3a3dc8"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest 0.10.7",
]

[[package]]
name = "sharded-slab"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f40ca3c46823713e0d4209592e8d6e826aa57e928f09752619fc696c499637f6"
dependencies = [
 "lazy_static",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "siphasher"
version = "0.3.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38b58827f4464d87d377d175e90bf58eb00fd8716ff0a62f80356b5e61555d0d"

[[package]]
name = "slab"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f92a496fb766b417c996b9c5e57daf2f7ad3b0bebe1ccfca4856390e3d3bb67"
dependencies = [
 "autocfg",
]

[[package]]
name = "smallvec"
version = "1.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c5e1a9a646d36c3599cd173a41282daf47c44583ad367b8e6837255952e5c67"

[[package]]
name = "smol_str"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd538fb6910ac1099850255cf94a94df6551fbdd602454387d0adb2d1ca6dead"
dependencies = [
 "serde",
]

[[package]]
name = "socket2"
version = "0.5.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c970269d99b64e60ec3bd6ad27270092a5394c4e309314b18ae3fe575695fbe8"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "spin"
version = "0.9.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6980e8d7511241f8acf4aebddbb1ff938df5eebe98691418c4468d0b72a96a67"

[[package]]
name = "static_assertions"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"

[[package]]
name = "static_assertions_next"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d7beae5182595e9a8b683fa98c4317f956c9a2dec3b9716990d20023cc60c766"

[[package]]
name = "stringprep"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b4df3d392d81bd458a8a621b8bffbd2302a12ffe288a9d931670948749463b1"
dependencies = [
 "unicode-bidi",
 "unicode-normalization",
 "unicode-properties",
]

[[package]]
name = "strsim"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ea5119cdb4c55b55d432abb513a0429384878c15dde60cc77b1c99de1a95a6a"

[[package]]
name = "strsim"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623"

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "structopt"
version = "0.3.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c6b5c64445ba8094a6ab0c3cd2ad323e07171012d9c98b0b15651daf1787a10"
dependencies = [
 "clap 2.34.0",
 "lazy_static",
 "structopt-derive",
]

[[package]]
name = "structopt-derive"
version = "0.4.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dcb5ae327f9cc13b68763b5749770cb9e048a99bd9dfdfa58d0cf05d5f64afe0"
dependencies = [
 "heck 0.3.3",
 "proc-macro-error",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "strum"
version = "0.21.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aaf86bbcfd1fa9670b7a129f64fc0c9fcbbfe4f1bc4210e9e98fe71ffc12cde2"

[[package]]
name = "strum"
version = "0.26.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8fec0f0aef304996cf250b31b5a10dee7980c85da9d759361292b8bca5a18f06"
dependencies = [
 "strum_macros 0.26.4",
]

[[package]]
name = "strum_macros"
version = "0.21.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d06aaeeee809dbc59eb4556183dd927df67db1540de5be8d3ec0b6636358a5ec"
dependencies = [
 "heck 0.3.3",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
]

[[package]]
name = "strum_macros"
version = "0.26.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c6bee85a5a24955dc440386795aa378cd9cf82acd5f764469152d2270e581be"
dependencies = [
 "heck 0.5.0",
 "proc-macro2",
 "quote",
 "rustversion",
 "syn 2.0.89",
]

[[package]]
name = "subtle"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"

[[package]]
name = "syn"
version = "1.0.109"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "syn"
version = "2.0.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "44d46482f1c1c87acd84dea20c1bf5ebff4c757009ed6bf19cfd36fb10e92c4e"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "sync_wrapper"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2047c6ded9c721764247e62cd3b03c09ffc529b2ba5b10ec482ae507a4a70160"

[[package]]
name = "sync_wrapper"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0bf256ce5efdfa370213c1dabab5935a12e49f2c58d15e9eac2870d3b4f27263"

[[package]]
name = "tempfile"
version = "3.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28cce251fcbc87fac86a866eeb0d6c2d536fc16d06f184bb61aeae11aa4cee0c"
dependencies = [
 "cfg-if",
 "fastrand",
 "once_cell",
 "rustix",
 "windows-sys 0.59.0",
]

[[package]]
name = "termcolor"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06794f8f6c5c898b3275aebefa6b8a1cb24cd2c6c79397ab15774837a0bc5755"
dependencies = [
 "winapi-util",
]

[[package]]
name = "test-case"
version = "1.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e9e5f048404b43e8ae66dce036163515b6057024cf58c6377be501f250bd3c6a"
dependencies = [
 "cfg-if",
 "proc-macro2",
 "quote",
 "syn 1.0.109",
 "version_check",
]

[[package]]
name = "textwrap"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d326610f408c7a4eb6f51c37c330e496b08506c9457c9d34287ecc38809fb060"
dependencies = [
 "unicode-width",
]

[[package]]
name = "textwrap"
version = "0.16.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "23d434d3f8967a09480fb04132ebe0a3e088c173e6d0ee7897abbdf4eab0f8b9"

[[package]]
name = "thiserror"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.89",
]

[[package]]
name = "thread_local"
version = "1.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b9ef9bad013ada3808854ceac7b46812a6465ba368859a37e2100283d2d719c"
dependencies = [
 "cfg-if",
 "once_cell",
]

[[package]]
name = "threadpool"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d050e60b33d41c19108b32cea32164033a9013fe3b46cbd4457559bfbf77afaa"
dependencies = [
 "num_cpus",
]

[[package]]
name = "thrift"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b82ca8f46f95b3ce96081fe3dd89160fdea970c254bb72925255d1b62aae692e"
dependencies = [
 "byteorder",
 "integer-encoding",
 "log",
 "ordered-float",
 "threadpool",
]

[[package]]
name = "time"
version = "0.1.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b797afad3f312d1c66a56d11d0316f916356d11bd158fbc6ca6389ff6bf805a"
dependencies = [
 "libc",
 "wasi 0.10.0+wasi-snapshot-preview1",
 "winapi",
]

[[package]]
name = "time"
version = "0.3.36"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5dfd88e563464686c916c7e46e623e520ddc6d79fa6641390f2e3fa86e83e885"
dependencies = [
 "deranged",
 "itoa",
 "num-conv",
 "powerfmt",
 "serde",
 "time-core",
 "time-macros",
]

[[package]]
name = "time-core"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef927ca75afb808a4d64dd374f00a2adf8d0fcff8e7b184af886c3c87ec4a3f3"

[[package]]
name = "time-macros"
version = "0.2.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f252a68540fde3a3877aeea552b832b40ab9a69e318efd078774a01ddee1ccf"
dependencies = [
 "num-conv",
 "time-core",
]

[[package]]
name = "tiny-keccak"
version = "2.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c9d3793400a45f954c52e73d068316d76b6f4e36977e3fcebb13a2721e80237"
dependencies = [
 "crunchy",
]

[[package]]
name = "tinyvec"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "445e881f4f6d382d5f27c034e25eb92edd7c784ceab92a0937db7f2e9471b938"
dependencies = [
 "tinyvec_macros",
]

[[package]]
name = "tinyvec_macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"

[[package]]
name = "tokio"
version = "1.41.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22cfb5bee7a6a52939ca9224d6ac897bb669134078daa8735560897f69de4d33"
dependencies = [
 "backtrace",
 "bytes",
 "libc",
 "mio",
 "pin-project-lite",
 "socket2",
 "tokio-macros",
 "tracing",
 "windows-sys 0.52.0",
]

[[package]]
name = "tokio-macros"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "693d596312e88961bc67d7f1f97af8a70227d9f90c31bba5806eec004978d752"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.89",
]

[[package]]
name = "tokio-native-tls"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbae76ab933c85776efabc971569dd6119c580d8f5d448769dec1764bf796ef2"
dependencies = [
 "native-tls",
 "tokio",
]

[[package]]
name = "tokio-postgres"
version = "0.7.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b5d3742945bc7d7f210693b0c58ae542c6fd47b17adbbda0885f3dcb34a6bdb"
dependencies = [
 "async-trait",
 "byteorder",
 "bytes",
 "fallible-iterator",
 "futures-channel",
 "futures-util",
 "log",
 "parking_lot",
 "percent-encoding",
 "phf",
 "pin-project-lite",
 "postgres-protocol 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)",
 "postgres-types",
 "rand 0.8.5",
 "socket2",
 "tokio",
 "tokio-util",
 "whoami",
]

[[package]]
name = "tokio-stream"
version = "0.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4f4e6ce100d0eb49a2734f8c0812bcd324cf357d21810932c5df6b96ef2b86f1"
dependencies = [
 "futures-core",
 "pin-project-lite",
 "tokio",
]

[[package]]
name = "tokio-tungstenite"
version = "0.24.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "edc5f74e248dc973e0dbb7b74c7e0d6fcc301c694ff50049504004ef4d0cdcd9"
dependencies = [
 "futures-util",
 "log",
 "tokio",
 "tungstenite",
]

[[package]]
name = "tokio-util"
version = "0.7.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "61e7c3654c13bcd040d4a03abee2c75b1d14a37b423cf5a813ceae1cc903ec6a"
dependencies = [
 "bytes",
 "futures-core",
 "futures-io",
 "futures-sink",
 "pin-project-lite",
 "tokio",
]

[[package]]
name = "toml"
version = "0.8.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1ed1f98e3fdc28d6d910e6737ae6ab1a93bf1985935a1193e68f93eeb68d24e"
dependencies = [
 "serde",
 "serde_spanned",
 "toml_datetime",
 "toml_edit 0.22.22",
]

[[package]]
name = "toml_datetime"
version = "0.6.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0dd7358ecb8fc2f8d014bf86f6f638ce72ba252a2c3a2572f2a795f1d23efb41"
dependencies = [
 "serde",
]

[[package]]
name = "toml_edit"
version = "0.19.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b5bb770da30e5cbfde35a2d7b9b8a2c4b8ef89548a7a6aeab5c9a576e3e7421"
dependencies = [
 "indexmap 2.6.0",
 "toml_datetime",
 "winnow 0.5.40",
]

[[package]]
name = "toml_edit"
version = "0.22.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ae48d6208a266e853d946088ed816055e556cc6028c5e8e2b84d9fa5dd7c7f5"
dependencies = [
 "indexmap 2.6.0",
 "serde",
 "serde_spanned",
 "toml_datetime",
 "winnow 0.6.20",
]

[[package]]
name = "tower"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2873938d487c3cfb9aed7546dc9f2711d867c9f90c46b889989a2cb84eba6b4f"
dependencies = [
 "futures-core",
 "futures-util",
 "pin-project-lite",
 "sync_wrapper 0.1.2",
 "tokio",
 "tower-layer",
 "tower-service",
 "tracing",
]

[[package]]
name = "tower-layer"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "121c2a6cda46980bb0fcd1647ffaf6cd3fc79a013de288782836f6df9c48780e"

[[package]]
name = "tower-service"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8df9b6e13f2d32c91b9bd719c00d1958837bc7dec474d94952798cc8e69eeec3"

[[package]]
name = "tracing"
version = "0.1.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
dependencies = [
 "log",
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-attributes"
version = "0.1.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "395ae124c09f9e6918a2310af6038fba074bcf474ac352496d5910dd59a2226d"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.89",
]

[[package]]
name = "tracing-core"
version = "0.1.33"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e672c95779cf947c5311f83787af4fa8fffd12fb27e4993211a84bdfd9610f9c"
dependencies = [
 "once_cell",
 "valuable",
]

[[package]]
name = "tracing-log"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f751112709b4e791d8ce53e32c4ed2d353565a795ce84da2285393f41557bdf2"
dependencies = [
 "log",
 "once_cell",
 "tracing-core",
]

[[package]]
name = "tracing-log"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee855f1f400bd0e5c02d150ae5de3840039a3f54b025156404e34c23c03f47c3"
dependencies = [
 "log",
 "once_cell",
 "tracing-core",
]

[[package]]
name = "tracing-opentelemetry"
version = "0.17.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fbbe89715c1dbbb790059e2565353978564924ee85017b5fff365c872ff6721f"
dependencies = [
 "once_cell",
 "opentelemetry",
 "tracing",
 "tracing-core",
 "tracing-log 0.1.4",
 "tracing-subscriber",
]

[[package]]
name = "tracing-oslog"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "528bdd1f0e27b5dd9a4ededf154e824b0532731e4af73bb531de46276e0aab1e"
dependencies = [
 "bindgen",
 "cc",
 "cfg-if",
 "once_cell",
 "parking_lot",
 "tracing-core",
 "tracing-subscriber",
]

[[package]]
name = "tracing-subscriber"
version = "0.3.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ad0f048c97dbd9faa9b7df56362b8ebcaa52adb06b498c050d2f4e32f90a7a8b"
dependencies = [
 "matchers",
 "nu-ansi-term",
 "once_cell",
 "regex",
 "sharded-slab",
 "smallvec",
 "thread_local",
 "tracing",
 "tracing-core",
 "tracing-log 0.2.0",
]

[[package]]
name = "tracing-wasm"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4575c663a174420fa2d78f4108ff68f65bf2fbb7dd89f33749b6e826b3626e07"
dependencies = [
 "tracing",
 "tracing-subscriber",
 "wasm-bindgen",
]

[[package]]
name = "tungstenite"
version = "0.24.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "18e5b8366ee7a95b16d32197d0b2604b43a0be89dc5fac9f8e96ccafbaedda8a"
dependencies = [
 "byteorder",
 "bytes",
 "data-encoding",
 "http",
 "httparse",
 "log",
 "rand 0.8.5",
 "sha1",
 "thiserror",
 "utf-8",
]

[[package]]
name = "typeid"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0e13db2e0ccd5e14a544e8a246ba2312cd25223f616442d7f2cb0e3db614236e"

[[package]]
name = "typenum"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42ff0bf0c66b8238c6f3b578df37d0b7848e55df8577b3f74f92a69acceeb825"

[[package]]
name = "ucd-trie"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2896d95c02a80c6d6a5d6e953d479f5ddf2dfdb6a244441010e373ac0fb88971"

[[package]]
name = "unicode-bidi"
version = "0.3.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5ab17db44d7388991a428b2ee655ce0c212e862eff1768a455c58f9aad6e7893"

[[package]]
name = "unicode-ident"
version = "1.0.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "adb9e6ca4f869e1180728b7950e35922a7fc6397f7b641499e8f3ef06e50dc83"

[[package]]
name = "unicode-normalization"
version = "0.1.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5033c97c4262335cded6d6fc3e5c18ab755e1a3dc96376350f3d8e9f009ad956"
dependencies = [
 "tinyvec",
]

[[package]]
name = "unicode-properties"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e70f2a8b45122e719eb623c01822704c4e0907e7e426a05927e1a1cfff5b75d0"

[[package]]
name = "unicode-segmentation"
version = "1.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6ccf251212114b54433ec949fd6a7841275f9ada20dddd2f29e9ceea4501493"

[[package]]
name = "unicode-width"
version = "0.1.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7dd6e30e90baa6f72411720665d41d89b9a3d039dc45b8faea1ddd07f617f6af"

[[package]]
name = "unicode-xid"
version = "0.2.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ebc1c04c71510c7f702b52b7c350734c9ff1295c464a03335b00bb84fc54f853"

[[package]]
name = "unsafe-libyaml"
version = "0.2.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "673aac59facbab8a9007c7f6108d11f63b603f7cabff99fabf650fea5c32b861"

[[package]]
name = "utf-8"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09cc8ee72d2a9becf2f2febe0205bbed8fc6615b7cb429ad062dc7b7ddd036a9"

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "uuid"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f8c5f0a0af699448548ad1a2fbf920fb4bee257eae39953ba95cb84891a0446a"
dependencies = [
 "getrandom",
]

[[package]]
name = "valuable"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "830b7e5d4d90034032940e4ace0d9a9a057e7a45cd94e6c007832e39edb82f6d"

[[package]]
name = "vcpkg"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"

[[package]]
name = "vec_map"
version = "0.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1bddf1187be692e79c5ffeab891132dfb0f236ed36a43c7ed39f1165ee20191"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "virtue"
version = "0.0.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9dcc60c0624df774c82a0ef104151231d37da4962957d691c011c852b2473314"

[[package]]
name = "wasi"
version = "0.10.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a143597ca7c7793eff794def352d41792a93c481eb1042423ff7ff72ba2c31f"

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"

[[package]]
name = "wasite"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8dad83b4f25e74f184f64c43b150b91efe7647395b42289f38e50566d82855b"

[[package]]
name = "wasm-bindgen"
version = "0.2.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "128d1e363af62632b8eb57219c8fd7877144af57558fb2ef0368d0087bddeb2e"
dependencies = [
 "cfg-if",
 "once_cell",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb6dd4d3ca0ddffd1dd1c9c04f94b868c37ff5fac97c30b97cff2d74fce3a358"
dependencies = [
 "bumpalo",
 "log",
 "once_cell",
 "proc-macro2",
 "quote",
 "syn 2.0.89",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-futures"
version = "0.4.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cc7ec4f8827a71586374db3e87abdb5a2bb3a15afed140221307c3ec06b1f63b"
dependencies = [
 "cfg-if",
 "js-sys",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e79384be7f8f5a9dd5d7167216f022090cf1f9ec128e6e6a482a2cb5c5422c56"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26c6ab57572f7a24a4985830b120de1594465e5d500f24afe89e16b4e833ef68"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.89",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "65fc09f10666a9f147042251e0dda9c18f166ff7de300607007e96bdebc1068d"

[[package]]
name = "web-sys"
version = "0.3.72"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6488b90108c040df0fe62fa815cbdee25124641df01814dd7282749234c6112"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "web-time"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a6580f308b1fad9207618087a65c04e7a10bc77e02c8e84e9b00dd4b12fa0bb"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "whoami"
version = "1.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "372d5b87f58ec45c384ba03563b03544dc5fadc3983e434b286913f5b4a9bb6d"
dependencies = [
 "redox_syscall",
 "wasite",
 "web-sys",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cf221c93e13a30d793f7645a0e7762c55d169dbb0a49671918a2319d289b10bb"
dependencies = [
 "windows-sys 0.59.0",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "winnow"
version = "0.5.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f593a95398737aeed53e489c785df13f3618e41dbcd6718c6addbf1395aa6876"
dependencies = [
 "memchr",
]

[[package]]
name = "winnow"
version = "0.6.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36c1fec1a2bb5866f07c25f68c26e565c4c200aebb96d7e55710c19d3e8ac49b"
dependencies = [
 "memchr",
]

[[package]]
name = "wow-srp"
version = "0.1.0"
dependencies = [
 "lazy_static",
 "num-bigint",
 "rand 0.8.5",
 "serde",
 "sha-1 0.9.8",
 "tracing",
]

[[package]]
name = "wow_login_messages"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a14cd88676fe85517dded89085cd459c83ea8435bde22321ee181776236d61d8"
dependencies = [
 "tokio",
]

[[package]]
name = "wow_srp"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cc239609a34604bf1c3fc5c00ce4c9534acea0413f98af3a19d66184b0a3787d"
dependencies = [
 "hmac",
 "num-bigint",
 "rand 0.8.5",
 "sha-1 0.10.1",
]

[[package]]
name = "wow_world_base"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3e7f722a488637c33c707dc29de57a12908eba56b3f07db69ee476d1f7f3f8f"

[[package]]
name = "wow_world_messages"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7df703a8a402cd5fe84c8d560f2d6eefbaaaac66f6e3c49d9c93829e00964209"
dependencies = [
 "flate2 1.0.35",
 "tokio",
 "wow_srp",
 "wow_world_base",
]

[[package]]
name = "zerocopy"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b9b4fd18abc82b8136838da5d50bae7bdea537c574d8dc1a34ed098d6c166f0"
dependencies = [
 "byteorder",
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa4f8080344d4671fb4e831a13ad1e68092748387dfc4f55e356242fae12ce3e"
dependencies = [
 "proc-macro2",
 "quote",
 "syn 2.0.89",
]

```

`Cargo.toml`:

```toml
[workspace]
members = ["crates/*", "services/*"]
resolver = "2"

# Enable a small amount of optimization in the dev profile.
[profile.dev]
opt-level = 1

# Enable a large amount of optimization in the dev profile for dependencies.
[profile.dev.package."*"]
opt-level = 3

[patch.crates-io]
postgres-types = { path = "../rust-postgres/postgres-types" }
cornucopia_async = { path = "../cornucopia/crates/client_async" }

```

`Dockerfile`:

```
FROM clux/muslrust:nightly as chef
RUN cargo install cargo-chef
WORKDIR /app

FROM chef as planner
COPY . .
RUN cargo chef prepare

FROM chef as cacher
COPY --from=planner /app/recipe.json recipe.json
ENV RUSTFLAGS --cfg tokio_unstable
RUN cargo chef cook --release

FROM chef as auth-builder
COPY . .
COPY --from=cacher /app/target target
ENV SQLX_OFFLINE true
ENV RUSTFLAGS --cfg tokio_unstable
RUN cargo build --bin azerust-auth --release

FROM chef as world-builder
COPY . .
COPY --from=cacher /app/target target
ENV SQLX_OFFLINE true
ENV RUSTFLAGS --cfg tokio_unstable
RUN cargo build --bin azerust-world --release

FROM scratch as auth
COPY --from=auth-builder /app/target/x86_64-unknown-linux-musl/release/azerust-auth /auth
CMD ["/auth"]

FROM scratch as world
COPY --from=world-builder /app/target/x86_64-unknown-linux-musl/release/azerust-world /world
CMD ["/world"]

```

`Makefile.toml`:

```toml
[tasks.prepare]
# this is to handle this usecase: https://github.com/launchbadge/sqlx/issues/1223#issuecomment-923823274
script = '''
#!/usr/bin/env bash
rm -rf target/sqlx
touch {services,crates}/*/src/*.rs
env -u DATABASE_URL SQLX_OFFLINE=false cargo check --workspace
jq -s '{"db": "MySQL"} + INDEX(.hash)' target/sqlx/query-*.json > sqlx-data.json
'''

[tasks.fetch-db]
script = '''
#!/usr/bin/env bash
AUTH=auth
CHARACTERS=characters

mkdir -p schema
printf "use $AUTH;\n" > schema/01_$AUTH.sql
printf "use $CHARACTERS;\n" > schema/02_$CHARACTERS.sql
curl https://raw.githubusercontent.com/TrinityCore/TrinityCore/3.3.5/sql/create/create_mysql.sql > schema/00_databases.sql
curl https://raw.githubusercontent.com/TrinityCore/TrinityCore/3.3.5/sql/base/${AUTH}_database.sql >> schema/01_$AUTH.sql
curl https://raw.githubusercontent.com/TrinityCore/TrinityCore/3.3.5/sql/base/${CHARACTERS}_database.sql >> schema/02_$CHARACTERS.sql
'''

[tasks.world]
command = "cargo"
args = ["run", "-p", "azerust-world", "config-world.yaml", "${@}"]

[tasks.auth]
command = "cargo"
args = ["run", "-p", "azerust-auth", "config-auth.yaml", "${@}"]

[env]
RUST_LOG = "azerust_world=TRACE,azerust_auth=TRACE,azerust_pg_auth=TRACE,deadpool_postgres=TRACE,tokio-postgres=TRACE,azerust_pg_characters=TRACE,ERROR"

[config]
default_to_workspace = false

```

`crates/assert-size-attribute/Cargo.toml`:

```toml
[package]
name = "assert-size-attribute"
version = "0.1.0"
authors = ["Alexander Lyon <arlyon@me.com>"]
edition = "2024"
license = "MIT OR Apache-2.0"

[lib]
proc-macro = true

[dependencies]
quote = "1"
syn = "1"

```

`crates/assert-size-attribute/src/lib.rs`:

```rs
use proc_macro::TokenStream;
use quote::quote;
use syn::{ItemStruct, Type, parse_macro_input};

#[proc_macro_attribute]
pub fn assert_eq_size(attr: TokenStream, input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as ItemStruct);
    let attr = parse_macro_input!(attr as Type);
    let name = input.ident.clone();

    TokenStream::from(quote! {
        #input

        static_assertions::assert_eq_size!(
            #name,
            #attr
        );
    })
}

```

`crates/axum/Cargo.toml`:

```toml
[package]
authors = ["Alexander Lyon <arlyon@me.com>"]
edition = "2024"
license = "MIT OR Apache-2.0"
name = "azerust-axum"
version = "0.1.0"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
async-graphql = "7"
async-graphql-axum = "7"
axum = "0.7"

azerust-game = { path = "../game" }
azerust-graphql-auth = { path = "../graphql-auth" }
azerust-graphql-world = { version = "0.1.0", path = "../graphql-world" }
anyhow = "1.0.65"
tokio = "1.41.1"

```

`crates/axum/src/auth.rs`:

```rs
use std::net::SocketAddr;

use async_graphql::{EmptySubscription, Schema};
use async_graphql_axum::{GraphQLRequest, GraphQLResponse};
use axum::{Router, extract::Extension, routing::get};
use azerust_game::{accounts::AccountService, realms::RealmList};

use crate::graphql_playground;

async fn auth_handler<A: 'static + AccountService + Send + Sync, R: 'static + RealmList + Send + Sync>(
    schema: Extension<Schema<azerust_graphql_auth::Query<A, R>, azerust_graphql_auth::Mutation<A, R>, EmptySubscription>>,
    req: GraphQLRequest,
) -> GraphQLResponse {
    schema.execute(req.into_inner()).await.into()
}

pub async fn auth_api<T: 'static + AccountService + Send + Sync, R: 'static + RealmList + Send + Sync>(
    listen_addr: &SocketAddr,
    account: T,
    realms: R,
) -> anyhow::Result<()> {
    let schema = azerust_graphql_auth::create_schema(account, realms);

    let app = Router::new()
        .route("/", get(graphql_playground).post(auth_handler::<T, R>))
        .layer(Extension(schema));

    // run our app with hyper, listening globally on port 3000
    let listener = tokio::net::TcpListener::bind(listen_addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();

    Ok(())
}

```

`crates/axum/src/lib.rs`:

```rs
mod auth;
mod world;


use async_graphql::http::{GraphQLPlaygroundConfig, playground_source};
pub use auth::auth_api;
use axum::response::{self, IntoResponse};
pub use world::world_api;

async fn graphql_playground() -> impl IntoResponse {
    response::Html(playground_source(GraphQLPlaygroundConfig::new("/")))
}

```

`crates/axum/src/world.rs`:

```rs
use std::net::SocketAddr;

use async_graphql::{EmptySubscription, Schema};
use async_graphql_axum::{GraphQLRequest, GraphQLResponse};
use axum::{Router, extract::Extension, routing::get};
use azerust_game::characters::CharacterService;

use crate::graphql_playground;

async fn world_handler<C: 'static + CharacterService + Send + Sync>(
    schema: Extension<Schema<azerust_graphql_world::Query<C>, azerust_graphql_world::Mutation<C>, EmptySubscription>>,
    req: GraphQLRequest,
) -> GraphQLResponse {
    schema.execute(req.into_inner()).await.into()
}

pub async fn world_api<C: 'static + CharacterService + Send + Sync>(listen_addr: &SocketAddr, characters: C) -> Result<(), ()> {
    let schema = azerust_graphql_world::create_schema(characters);

    let app = Router::new()
        .route("/", get(graphql_playground).post(world_handler::<C>))
        .layer(Extension(schema));

    // run our app with hyper, listening globally on port 3000
    let listener = tokio::net::TcpListener::bind(listen_addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();

    Ok(())
}

```

`crates/game/Cargo.toml`:

```toml
[package]
name = "azerust-game"
version = "0.1.0"
authors = ["Alexander Lyon <arlyon@me.com>"]
edition = "2024"
license = "MIT OR Apache-2.0"

[dependencies]
async-trait = "0.1"
derive_more = "0.99"
enumflags2 = "0.7.0-preview1"
num_enum = "0.5"
rand = "0.8"
serde = { version = "1.0.130", features = ["derive"] }
sha-1 = "0.9"
strum = "0.21"
strum_macros = "0.21"
thiserror = "1"
time = "0.3.36"
wow-srp = { path = "../wow-srp" }
wow_login_messages = "0.5.0"
wow_world_messages = { version = "0.3.0", features = ["wrath", "tokio"] }

```

`crates/game/src/accounts.rs`:

```rs
//! accounts
//!
//! The accounts module handles the basic manipulation
//! of accounts such as login and creation / deletion.

use std::{future::Future, time::Duration};

use derive_more::Display;
use rand::Rng;
use sha1::Digest;
use thiserror::Error;
use time::PrimitiveDateTime;
use wow_login_messages::version_8::CMD_AUTH_LOGON_CHALLENGE_Server;
use wow_srp::{Salt, Verifier, WowSRPServer};

/// An id for an account.
#[derive(Debug, Display, PartialEq, Eq, Clone, Copy, Hash)]
pub struct AccountId(pub u32);

/// A basic account object.
#[derive(Debug, PartialEq, Clone)]
pub struct Account {
    pub id: AccountId,
    pub username: String,
    pub email: String,
    pub ban_status: Option<BanStatus>,

    pub salt: Salt,
    pub verifier: Verifier,
    pub session_key: Option<[u8; 40]>,

    pub joindate: PrimitiveDateTime,
    pub last_login: Option<PrimitiveDateTime>,
    pub online: bool,
}

/// Models the status of someone's ban.
#[derive(PartialEq, Eq, Debug, Clone, Copy)]
#[repr(u8)]
pub enum BanStatus {
    Temporary,
    Permanent,
}

#[derive(Copy, Debug, Clone, PartialEq)]
/// Handles the verification step of logging in.
pub struct ConnectToken {
    server: WowSRPServer,
    security_flags: u8,
}

impl ConnectToken {
    pub fn new(username: &str, salt: Salt, verifier: Verifier) -> Self {
        Self {
            server: WowSRPServer::new(username, salt, verifier),
            security_flags: 0,
        }
    }

    /// Get the g parameter in use by this server.
    pub fn get_g(&self) -> Vec<u8> {
        self.server.get_g()
    }

    /// Get the n parameter in use by this server.
    pub fn get_n(&self) -> Vec<u8> {
        self.server.get_n()
    }

    /// Get the random salt in use by this server.
    pub fn get_salt(&self) -> &Salt {
        self.server.get_salt()
    }

    /// Get the ephemeral public key for this server.
    pub fn get_b_pub(&self) -> &[u8; 32] {
        self.server.get_b_pub()
    }

    /// Get the security flags set for this login.
    pub fn get_security_flags(&self) -> u8 {
        self.security_flags
    }

    /// Handle the keys for the public key and proof.
    pub fn accept(&self, public_key: &[u8; 32], client_proof: &[u8; 20]) -> Result<([u8; 20], [u8; 40]), LoginFailure> {
        self.server
            .verify_challenge_response(public_key, client_proof)
            .map(|session_key| (self.server.get_server_proof(public_key, client_proof, &session_key), session_key))
            .ok_or(LoginFailure::IncorrectPassword)
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct ReconnectToken {
    pub reconnect_proof: [u8; 16],
    pub account: Account,
    pub session_key: [u8; 40],
}

impl ReconnectToken {
    pub fn new(account: Account, session_key: [u8; 40]) -> Self {
        Self {
            reconnect_proof: rand::thread_rng().r#gen(),
            account,
            session_key,
        }
    }

    pub fn accept(&self, proof_data: &[u8; 16], client_proof: &[u8; 20]) -> Result<(), LoginFailure> {
        let mut sha = sha1::Sha1::new();
        sha.update(&self.account.username);
        sha.update(proof_data);
        sha.update(self.reconnect_proof);
        sha.update(self.session_key);
        let server_proof = sha.finalize();

        if server_proof.as_slice() == client_proof {
            Ok(())
        } else {
            Err(LoginFailure::IncorrectPassword)
        }
    }
}

/// An account service handles all the business logic for accounts.
pub trait AccountService: Send + Sync {
    fn list_account(&self) -> impl Future<Output = Result<Vec<Account>, AccountFetchError>> + Send;

    /// Creates a new account in the system.
    fn create_account(&self, username: &str, password: &str, email: &str) -> impl Future<Output = Result<AccountId, AccountOpError>> + Send;

    /// Deletes an account from the system along with all associated
    /// information and characters.
    fn delete_account(&self, id: AccountId) -> impl Future<Output = Result<(), AccountOpError>> + Send;

    fn get(&self, id: AccountId) -> impl Future<Output = Result<Account, AccountOpError>> + Send;

    /// Gets an account from the system by its username.
    fn get_by_username(&self, username: &str) -> impl Future<Output = Result<Option<Account>, AccountOpError>> + Send;

    /// Start a login in the system. This function returns a LoginVerifier
    /// which can be used to handle the second stage of the login.
    fn initiate_login(&self, username: &str) -> impl Future<Output = Result<ConnectToken, LoginFailure>> + Send;

    /// Logs the user in with the given public key and proof.
    fn complete_login(
        &self,
        username: String,
        token: &ConnectToken,
        public_key: &[u8; 32],
        proof: &[u8; 20],
    ) -> impl Future<Output = Result<[u8; 20], LoginFailure>> + Send;

    fn initiate_relogin(&self, username: &str) -> impl Future<Output = Result<ReconnectToken, LoginFailure>> + Send;

    fn complete_relogin(
        &self,
        token: &ReconnectToken,
        proof_data: &[u8; 16],
        client_proof: &[u8; 20],
    ) -> impl Future<Output = Result<[u8; 20], LoginFailure>> + Send;

    fn set_ban(&self, id: AccountId, author: &str, duration: Option<Duration>, reason: Option<&str>)
    -> impl Future<Output = Result<(), AccountOpError>> + Send;
}

/// Errors that may occur when running account operations.
#[derive(Error, Debug, Display)]
pub enum AccountOpError {
    UsernameTooLong,
    PasswordTooLong,
    PersistError(String),
    InvalidAccount(AccountId),
}

/// Errors that may occur when accessing accounts.
#[derive(Error, Debug, Display)]
pub enum AccountFetchError {
    IO(String),
}

/// Errors that may occur when logging in.
#[derive(Copy, Clone, Debug)]
pub enum LoginFailure {
    Suspended,
    Banned,
    UnknownAccount,
    IncorrectPassword,
    DatabaseError,
}

impl From<LoginFailure> for CMD_AUTH_LOGON_CHALLENGE_Server {
    fn from(value: LoginFailure) -> Self {
        match value {
            LoginFailure::Suspended => CMD_AUTH_LOGON_CHALLENGE_Server::FailSuspended,
            LoginFailure::Banned => CMD_AUTH_LOGON_CHALLENGE_Server::FailBanned,
            LoginFailure::UnknownAccount => CMD_AUTH_LOGON_CHALLENGE_Server::FailUnknownAccount,
            LoginFailure::IncorrectPassword => CMD_AUTH_LOGON_CHALLENGE_Server::FailIncorrectPassword,
            LoginFailure::DatabaseError => CMD_AUTH_LOGON_CHALLENGE_Server::FailDbBusy,
        }
    }
}

```

`crates/game/src/characters.rs`:

```rs
use thiserror::Error;
pub use wow_world_messages::wrath::{Area, Class, Gender, Level, Map, Race};

use crate::{EntityType, Guid, accounts::AccountId, new_guid};

#[derive(Error, Debug, Clone, Copy)]
pub enum TryFromWowIdError {
    #[error("invalid entity {0}")]
    InvalidEntityType(u16),
}

#[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]
pub struct CharacterId(pub u32);

impl TryFrom<Guid> for CharacterId {
    type Error = TryFromWowIdError;

    fn try_from(value: Guid) -> Result<Self, Self::Error> {
        let e_type = (value.guid() >> 48) as u16;
        if e_type == EntityType::Player as u16 {
            Ok(CharacterId(value.guid() as u32))
        } else {
            Err(TryFromWowIdError::InvalidEntityType(e_type))
        }
    }
}

impl From<CharacterId> for Guid {
    fn from(id: CharacterId) -> Self {
        new_guid(EntityType::Player, id.0, 0)
    }
}

impl From<&CharacterId> for Guid {
    fn from(id: &CharacterId) -> Self {
        (*id).into()
    }
}

#[derive(Debug, Clone)]
pub struct Character {
    pub id: CharacterId,
    pub account: AccountId,
    pub name: String,
    pub level: Level,
    pub race: Race,
    pub class: Class,
    pub gender: Gender,

    pub skin_color: u8,
    pub face: u8,
    pub hair_style: u8,
    pub hair_color: u8,
    pub facial_style: u8,

    pub zone: Area,
    pub map: Map,
    pub position_x: f32,
    pub position_y: f32,
    pub position_z: f32,
}

// position_x: -8949.94f32, //
// position_y: -132.50f32,  // human start zone
// position_z: 83.53f32,    //

#[derive(Debug, Clone)]
pub struct CharacterCreate {
    pub name: String,
    pub race: Race,
    pub class: Class,
    pub gender: Gender,

    pub skin_color: u8,
    pub face: u8,
    pub hair_style: u8,
    pub hair_color: u8,
    pub facial_style: u8,

    pub zone: u16,
    pub map: u16,
    pub position_x: f32,
    pub position_y: f32,
    pub position_z: f32,
}

#[derive(Debug, Clone)]
pub struct AccountDataCache {
    pub time: u32,
    pub data: Vec<u8>,
}

pub trait CharacterService {
    fn get(&self, id: CharacterId) -> impl Future<Output = Result<Option<Character>, CharacterServiceError>> + Send;
    fn get_by_name(&self, name: &str) -> impl Future<Output = Result<Option<Character>, CharacterServiceError>> + Send;
    /// Get list of friends, flags and notes for a given character
    fn get_friends(&self, id: CharacterId) -> impl Future<Output = Result<Vec<(CharacterId, u32, String)>, CharacterServiceError>> + Send;
    fn add_friend_by_name(
        &self,
        id: CharacterId,
        name: &str,
        note: Option<&str>,
    ) -> impl Future<Output = Result<Option<CharacterId>, CharacterServiceError>> + Send;
    fn list(&self) -> impl Future<Output = Result<Vec<Character>, CharacterServiceError>> + Send;
    fn get_by_account(&self, id: AccountId) -> impl Future<Output = Result<Vec<Character>, CharacterServiceError>> + Send;
    fn account_data(&self, id: AccountId) -> impl Future<Output = Result<Vec<(i16, AccountDataCache)>, CharacterServiceError>> + Send;
    fn character_account_data(&self, id: CharacterId) -> impl Future<Output = Result<Vec<(i16, AccountDataCache)>, CharacterServiceError>> + Send;
    fn count_by_account(&self, id: AccountId) -> impl Future<Output = Result<usize, CharacterServiceError>> + Send;
    fn name_available(&self, name: &str) -> impl Future<Output = Result<bool, CharacterServiceError>> + Send;
    fn create_character(&self, account: AccountId, create: CharacterCreate) -> impl Future<Output = Result<CharacterId, CharacterServiceError>> + Send;
    fn delete_character(&self, id: CharacterId) -> impl Future<Output = Result<(), CharacterServiceError>> + Send;
}

/// Errors that may occur when running character operations.
#[derive(Error, Debug)]
pub enum CharacterServiceError {
    #[error("no such account {0:?}")]
    NoSuchAccount(AccountId),
    #[error("no such character {0:?}")]
    NoSuchCharacter(CharacterId),
    #[error("persistence error {0:?}")]
    PersistError(String),
}

```

`crates/game/src/lib.rs`:

```rs
//! game
//!
//! This crate models much of the core gameplay systems of
//! World of Warcraft.

#![deny(
    missing_debug_implementations,
    missing_copy_implementations,
    trivial_casts,
    trivial_numeric_casts,
    unsafe_code,
    unused_import_braces,
    unused_qualifications,
    clippy::useless_conversion,
    clippy::unwrap_used,
    clippy::todo,
    clippy::unimplemented
)]

pub mod accounts;
pub mod characters;
pub mod realms;
pub mod types;

pub use wow_world_messages::Guid;

#[derive(Debug, Clone, Copy)]
pub enum EntityType {
    Player = 0x0000,
    ItemOrContainer = 0x4000,
    GameObject = 0xF110,
    Transport = 0xF120,
    Unit = 0xF130,
    Pet = 0xF140,
    Vehicle = 0xF150,
    DynamicObject = 0xF100,
    Corpse = 0xF101,
    MoTransport = 0x1FC0,
    Group = 0x1F50,
    Instance = 0x1F42,
}

pub fn new_guid(r#type: EntityType, low: u32, mid: u32) -> Guid {
    Guid::from((low as u64) | ((mid as u64) << 24) | ((r#type as u64) << 48))
}

```

`crates/game/src/realms.rs`:

```rs
//! realms
//!
//! The realms module handles everything regarding managing
//! realm and realmlists.

use std::net::IpAddr;

use derive_more::{From, Into};
use enumflags2::bitflags;
use num_enum::IntoPrimitive;
use serde::{Deserialize, Serialize};
use strum_macros::ToString;
use thiserror::Error;
use time::OffsetDateTime;

/// The various flags that a realm can have.
/// They are implemented as BitFlags.
#[repr(u8)]
#[bitflags]
#[derive(Clone, Copy, Debug)]
pub enum RealmFlags {
    Invalid = 0b0000_0001,
    Offline = 0b0000_0010,
    SpecifyBuild = 0b0000_0100,
    Unknown1 = 0b0000_1000,
    Unknown2 = 0b0001_0000,
    Recommended = 0b0010_0000,
    New = 0b0100_0000,
    Full = 0b1000_0000,
}

/// The various types of realm.
/// For more, see <https://wow.tools/dbc/?dbc=cfg_configs&build=3.3.5.12340>
#[repr(u8)]
#[derive(Clone, Copy, Debug, IntoPrimitive, ToString)]
pub enum RealmType {
    Normal = 0,
    PVP = 1,
    RP = 6,
    RPPvP = 8,
}

/// A marker for a realm id.
#[derive(Clone, Debug, From, Into, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub struct RealmId(pub u32);

/// The basic realm object.
#[derive(Clone, Debug)]
pub struct Realm {
    pub id: RealmId,
    pub name: String,
    pub realm_type: RealmType,
    pub build: u32,
    pub external_address: IpAddr,
    pub local_address: IpAddr,
    pub local_subnet_mask: IpAddr,
    pub port: u16,
    pub flags: u8,
    pub timezone: u8,
    pub population: f32,
}

/// A trait that models a realmlist.
pub trait RealmList: Send + Sync {
    /// Return the list of realms sorted by id.
    fn realms(&self) -> impl Future<Output = Result<Vec<Realm>, RealmListError>> + Send;

    fn update_status(&self, online: Vec<(u8, RealmFlags)>) -> impl Future<Output = Result<(), RealmListError>> + Send;

    /// Update the uptime counter for a server that started
    /// at the given `start` time.
    fn set_uptime(&self, id: RealmId, start: OffsetDateTime, population: u16) -> impl Future<Output = Result<(), RealmListError>> + Send;

    /// Create a new realm in the realmlist.
    fn create_realm(
        &self,
        name: &str,
        address: &IpAddr,
        local_address: &IpAddr,
        local_subnet_mask: &IpAddr,
        port: u16,
    ) -> impl Future<Output = Result<Realm, RealmListError>> + Send;
}

/// Errors that may occur when running realmlist operations.
#[derive(Error, Debug)]
pub enum RealmListError {
    #[error("start time is in the future")]
    StartTimeInFuture,
    #[error("start time is too large to be stored")]
    StartTimeTooLarge,
    #[error("error in persistence layer: {0}")]
    PersistError(String),
}

```

`crates/game/src/types.rs`:

```rs
//! types
//!
//! This module contains types that don't really fit elsewhere.

use num_enum::IntoPrimitive;
use strum_macros::EnumString;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(EnumString, IntoPrimitive, Copy, Clone, Debug)]
pub enum Locale {
    enUS = 0,
    koKR,
    frFR,
    deDE,
    zhCN,
    esES,
    esMX,
    ruRU,
}

```

`crates/graphql-auth/Cargo.toml`:

```toml
[package]
authors = ["Alexander Lyon <arlyon@me.com>"]
edition = "2024"
license = "MIT OR Apache-2.0"
name = "azerust-graphql-auth"
version = "0.1.0"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
async-graphql = { version = "7", features = ["time"] }

azerust-game = { path = "../game" }
time = "0.3.36"

```

`crates/graphql-auth/src/lib.rs`:

```rs
use async_graphql::{EmptySubscription, Schema};
use azerust_game::{accounts::AccountService, realms::RealmList};
pub use schemas::{Mutation, Query};

mod models;
mod schemas;

pub fn create_schema<A: 'static + AccountService + Send + Sync, R: 'static + RealmList + Send + Sync>(
    accounts: A,
    realms: R,
) -> Schema<Query<A, R>, Mutation<A, R>, EmptySubscription> {
    Schema::build(Query::new(), Mutation::new(), EmptySubscription)
        .data(accounts)
        .data(realms)
        .finish()
}

```

`crates/graphql-auth/src/models/account.rs`:

```rs
use async_graphql::Object;
use azerust_game::accounts;
use time::PrimitiveDateTime;

pub struct Account(pub accounts::Account);

#[Object]
impl Account {
    async fn username(&self) -> &str {
        &self.0.username
    }
    async fn email(&self) -> &str {
        &self.0.email
    }
    async fn joindate(&self) -> &PrimitiveDateTime {
        &self.0.joindate
    }
    async fn last_login(&self) -> &Option<PrimitiveDateTime> {
        &self.0.last_login
    }
    async fn online(&self) -> bool {
        self.0.online
    }
}

```

`crates/graphql-auth/src/models/mod.rs`:

```rs
mod account;
mod realm;

pub use account::Account;
pub use realm::Realm;

```

`crates/graphql-auth/src/models/realm.rs`:

```rs
use async_graphql::Object;
use azerust_game::realms;

pub struct Realm(pub realms::Realm);

#[Object]
impl Realm {
    async fn name(&self) -> &str {
        &self.0.name
    }
    async fn realm_type(&self) -> String {
        self.0.realm_type.to_string()
    }
    async fn build(&self) -> u32 {
        self.0.build
    }
    async fn ip(&self) -> String {
        self.0.external_address.to_string()
    }
    async fn port(&self) -> u16 {
        self.0.port
    }
    async fn timezone(&self) -> u8 {
        self.0.timezone
    }
}

```

`crates/graphql-auth/src/schemas/mod.rs`:

```rs
mod mutation;
mod query;

pub use mutation::Mutation;
pub use query::Query;

```

`crates/graphql-auth/src/schemas/mutation.rs`:

```rs
use std::{marker::PhantomData, net::IpAddr, str::FromStr, time::Duration};

use async_graphql::{Context, FieldResult, InputObject, Object};
use azerust_game::{
    accounts::{AccountId, AccountService},
    realms::RealmList,
};

use crate::models::Realm;

pub struct Mutation<A, R> {
    _accounts: PhantomData<A>,
    _realms: PhantomData<R>,
}

#[derive(InputObject)]
struct UserCreate {
    username: String,
    email: String,
    password: String,
}

impl<A, R> Default for Mutation<A, R> {
    fn default() -> Self {
        Self::new()
    }
}

impl<A, R> Mutation<A, R> {
    pub fn new() -> Self {
        Self {
            _accounts: PhantomData,
            _realms: PhantomData,
        }
    }
}

#[Object]
impl<A, R> Mutation<A, R>
where
    A: 'static + AccountService + Send + Sync,
    R: 'static + RealmList + Send + Sync,
{
    /// Creates a new user account.
    async fn register_user(&self, ctx: &Context<'_>, user: UserCreate) -> FieldResult<u32> {
        let service = ctx.data::<A>()?;
        let id = service.create_account(&user.username, &user.password, &user.email).await?;
        Ok(id.0)
    }

    async fn set_ban_status(&self, ctx: &Context<'_>, id: u32, duration: Option<BanDuration>, reason: Option<String>) -> FieldResult<bool> {
        let service = ctx.data::<A>()?;
        service
            .set_ban(
                AccountId(id),
                "arlyon",
                duration.map(|d| Duration::from_secs(d.days * 86400)),
                reason.as_deref(),
            )
            .await?;
        Ok(true)
    }

    async fn create_realm(
        &self,
        ctx: &Context<'_>,
        name: String,
        address: String,
        local_address: String,
        local_subnet_mask: String,
        port: u16,
    ) -> FieldResult<Realm> {
        let realms = ctx.data::<R>()?;

        let address = IpAddr::from_str(&address)?;
        let local_address = IpAddr::from_str(&local_address)?;
        let local_subnet_mask = IpAddr::from_str(&local_subnet_mask)?;

        let realm = realms.create_realm(&name, &address, &local_address, &local_subnet_mask, port).await?;

        Ok(Realm(realm))
    }
}

#[derive(InputObject)]
struct BanDuration {
    days: u64,
}

```

`crates/graphql-auth/src/schemas/query.rs`:

```rs
use std::marker::PhantomData;

use async_graphql::{Context, FieldResult, Object};
use azerust_game::{accounts::AccountService, realms::RealmList};

use crate::models::{Account, Realm};

pub struct Query<A, R> {
    account: PhantomData<A>,
    realm: PhantomData<R>,
}

impl<A, R> Default for Query<A, R> {
    fn default() -> Self {
        Self::new()
    }
}

impl<A, R> Query<A, R> {
    pub fn new() -> Self {
        Self {
            account: PhantomData,
            realm: PhantomData,
        }
    }
}

#[Object]
impl<A, R> Query<A, R>
where
    A: 'static + AccountService + Send + Sync,
    R: 'static + RealmList + Send + Sync,
{
    async fn get_users(&self, ctx: &Context<'_>) -> FieldResult<Vec<Account>> {
        let service = ctx.data::<A>()?;
        let accounts = service.list_account().await?;
        Ok(accounts.into_iter().map(Account).collect())
    }

    async fn get_user(&self, ctx: &Context<'_>, username: String) -> FieldResult<Option<Account>> {
        let service = ctx.data::<A>()?;
        let account = service.get_by_username(&username).await?;
        Ok(account.map(Account))
    }

    async fn get_realms(&self, ctx: &Context<'_>) -> FieldResult<Vec<Realm>> {
        let service = ctx.data::<R>()?;
        Ok(service.realms().await?.into_iter().map(Realm).collect())
    }
}

```

`crates/graphql-world/Cargo.toml`:

```toml
[package]
authors = ["Alexander Lyon <arlyon@me.com>"]
edition = "2024"
license = "MIT OR Apache-2.0"
name = "azerust-graphql-world"
version = "0.1.0"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
async-graphql = { version = "7", features = ["time"] }

azerust-game = { path = "../game" }

```

`crates/graphql-world/src/lib.rs`:

```rs
use async_graphql::{EmptySubscription, Schema};
use azerust_game::characters::CharacterService;
pub use schemas::{Mutation, Query};

mod models;
mod schemas;

pub fn create_schema<C: 'static + CharacterService + Send + Sync>(characters: C) -> Schema<Query<C>, Mutation<C>, EmptySubscription> {
    Schema::build(Query::new(), Mutation::new(), EmptySubscription).data(characters).finish()
}

```

`crates/graphql-world/src/models/character.rs`:

```rs
use async_graphql::Object;
use azerust_game::characters;

pub struct Character(pub characters::Character);

#[Object]
impl Character {
    async fn name(&self) -> &str {
        &self.0.name
    }
    async fn level(&self) -> u8 {
        self.0.level.as_int()
    }
}

```

`crates/graphql-world/src/models/mod.rs`:

```rs
mod character;

pub use character::Character;

```

`crates/graphql-world/src/models/realm.rs`:

```rs
use async_graphql::Object;
use azerust_game::realms;

#[derive(Clone)]
pub struct Realm(pub realms::Realm);

#[Object]
impl Realm {
    async fn name(&self) -> &str {
        &self.0.name
    }
    async fn realm_type(&self) -> String {
        self.0.realm_type.to_string()
    }
    async fn build(&self) -> u32 {
        self.0.build
    }
    async fn ip(&self) -> &str {
        &self.0.external_address
    }
    async fn port(&self) -> u16 {
        self.0.port
    }
    async fn timezone(&self) -> u8 {
        self.0.timezone
    }
}

```

`crates/graphql-world/src/schemas/mod.rs`:

```rs
mod mutation;
mod query;

pub use mutation::Mutation;
pub use query::Query;

```

`crates/graphql-world/src/schemas/mutation.rs`:

```rs
use std::marker::PhantomData;

use async_graphql::{Context, FieldResult, InputObject, Object};
use azerust_game::{
    accounts::AccountId,
    characters::{CharacterCreate, CharacterService, Class, Gender, Race},
};

pub struct Mutation<C> {
    marker: PhantomData<C>,
}

#[derive(InputObject)]
struct UserCreate {
    username: String,
    email: String,
    password: String,
}

impl<C> Default for Mutation<C> {
    fn default() -> Self {
        Self::new()
    }
}

impl<C> Mutation<C> {
    pub fn new() -> Self {
        Self { marker: PhantomData }
    }
}

#[Object]
impl<C> Mutation<C>
where
    C: 'static + CharacterService + Send + Sync,
{
    /// Creates a new user account.
    async fn create_character(&self, ctx: &Context<'_>, account: u32, name: String) -> FieldResult<u32> {
        let characters = ctx.data::<C>()?;
        let id = characters
            .create_character(AccountId(account as u32), CharacterCreate {
                class: Class::Warrior,
                face: 0,
                facial_style: 0,
                hair_color: 0,
                hair_style: 0,
                skin_color: 0,
                gender: Gender::Male,
                map: 0,               //
                zone: 1,              //
                position_x: -6240.32, // dwarf start zone
                position_y: 331.033,  //
                position_z: 382.758,  //
                name: name.clone(),
                race: Race::Human,
            })
            .await?;

        Ok(id.0)
    }
}

#[derive(InputObject)]
struct BanDuration {
    days: u64,
}

```

`crates/graphql-world/src/schemas/query.rs`:

```rs
use std::marker::PhantomData;

use async_graphql::{Context, FieldResult, Object};
use azerust_game::characters::CharacterService;

use crate::models::Character;

pub struct Query<C> {
    character: PhantomData<C>,
}

impl<C> Default for Query<C> {
    fn default() -> Self {
        Self::new()
    }
}

impl<C> Query<C> {
    pub fn new() -> Self {
        Self { character: PhantomData }
    }
}

#[Object]
impl<C> Query<C>
where
    C: 'static + CharacterService + Send + Sync,
{
    async fn get_characters(&self, ctx: &Context<'_>) -> FieldResult<Vec<Character>> {
        let service = ctx.data::<C>()?;
        let accounts = service.list().await?;
        Ok(accounts.into_iter().map(Character).collect())
    }
}

```

`crates/pg-auth/Cargo.toml`:

```toml
[package]
name = "azerust-pg-auth"
version = "0.1.0"
authors = ["Alexander Lyon <arlyon@me.com>"]
edition = "2024"
license = "MIT OR Apache-2.0"

[dependencies]
tracing = "0.1"
async-trait = "0.1"
wow-srp = { path = "../wow-srp" }
azerust-game = { path = "../game" }
lazy_static = "1.4"
rand = "0.8"
sha-1 = "0.9"
tokio = "1"
cornucopia_async = "0.6.0"
tokio-postgres = { version = "0.7.12", features = ["with-time-0_3"] }
deadpool-postgres = "0.12.0"
postgres-types = "0.2.8"
time = "0.3.36"
futures = "0.3.31"

```

`crates/pg-auth/queries/accounts.sql`:

```sql
--! list_account: (last_login?, session_key_auth?)
SELECT id, username, session_key_auth, salt, verifier, email, joindate, last_login, online from account;

--! create_account
INSERT INTO account(username, salt, verifier, reg_mail, email, joindate) VALUES(:username, :salt, :verifier, :reg_main, :email, NOW());

--! insert_realmchars_entry
INSERT INTO realmcharacters (realmid, acctid, numchars) SELECT realmlist.id, account.id, 0 FROM realmlist, account LEFT JOIN realmcharacters ON acctid = account.id WHERE acctid IS NULL;

--! account_exists
SELECT id FROM account WHERE id = :id;

--! select_account_by_id: (session_key_auth?, last_login?)
SELECT id, username, session_key_auth, salt, verifier, email, joindate, last_login, online FROM account WHERE id = :id;

--! select_account_by_username : (last_login?, session_key_auth?)
SELECT id, username, session_key_auth, salt, verifier, email, joindate, last_login, online FROM account WHERE username = :username;

--! select_account_banned
SELECT  (ab.unbandate > now() OR ab.unbandate = ab.bandate) as is_banned, (ab.unbandate = ab.bandate) as is_permabanned FROM account_banned ab where ab.id = :id;

--! initiate_relogin
SELECT a.id, a.username, a.locked, a.lock_country, a.last_ip, a.failed_logins, (ab.unbandate > now() OR ab.unbandate = ab.bandate) as is_banned, (ab.unbandate = ab.bandate) as is_permabanned, aa.security_level, a.session_key_auth as session_key FROM account a LEFT JOIN account_access aa ON a.id = aa.account_id LEFT JOIN account_banned ab ON ab.id = a.id AND ab.active = true WHERE a.username = :username AND a.session_key_auth IS NOT NULL;

--! update_session_information
UPDATE account SET session_key_auth = :session_key, last_ip = :last_ip, last_login = now(), locale = :locale, failed_logins = 0, os = :os WHERE username = :username;

--! ban_user
INSERT INTO account_banned (id, bandate, unbandate, bannedby, banreason) values (:id, now(), :unban_date, :banned_by, :ban_reason);

```

`crates/pg-auth/queries/realms.sql`:

```sql
--! refresh_realmlist
SELECT id, name, icon as realm_type, gamebuild as build, address as external_address, local_address, local_subnet_mask, port, flag as flags, timezone, population FROM realmlist WHERE flag <> 3 ORDER BY id;

--! update_realmlist_status
update realmlist set flag = :flag where id = :id;

--! create_realm
insert into realmlist (name, address, local_address, local_subnet_mask, port) values (:name, :address, :local_address, :local_subnet_mask, :port) returning *;

--! set_uptime
INSERT INTO uptime (realmid, starttime, uptime, maxplayers, revision)
VALUES (:id, :start, :uptime, :maxplayers, :version)
ON CONFLICT (realmid)
DO UPDATE SET
    uptime = EXCLUDED.uptime,
    maxplayers = EXCLUDED.maxplayers;

```

`crates/pg-auth/schema.sql`:

```sql
CREATE EXTENSION uint;

-- Table: account
CREATE TABLE account (
    id SERIAL PRIMARY KEY,
    username VARCHAR(32) NOT NULL UNIQUE,
    salt BYTEA NOT NULL,
    verifier BYTEA NOT NULL,
    session_key_auth BYTEA,
    session_key_bnet BYTEA,
    totp_secret BYTEA,
    email VARCHAR(255) NOT NULL CHECK (email != ''),
    reg_mail VARCHAR(255) NOT NULL CHECK (reg_mail != ''),
    joindate TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    last_ip INET NOT NULL DEFAULT '127.0.0.1',
    last_attempt_ip INET NOT NULL DEFAULT '127.0.0.1',
    failed_logins uint4 NOT NULL DEFAULT 0,
    locked BOOLEAN NOT NULL DEFAULT FALSE,
    lock_country VARCHAR(2) NOT NULL DEFAULT '00',
    last_login TIMESTAMP NULL,
    online BOOLEAN NOT NULL DEFAULT FALSE,
    expansion uint1 NOT NULL DEFAULT 2,
    mutetime uint8 NOT NULL DEFAULT 0,
    mutereason VARCHAR(255) NOT NULL DEFAULT '',
    muteby VARCHAR(50) NOT NULL DEFAULT '',
    locale uint1 NOT NULL DEFAULT 0,
    os VARCHAR(3) NOT NULL DEFAULT '',
    timezone_offset SMALLINT NOT NULL DEFAULT 0,
    recruiter uint4 NOT NULL DEFAULT 0
);

COMMENT ON TABLE account IS 'Account information for authentication.';

-- Table: account_access
CREATE TABLE account_access (
    account_id uint4 NOT NULL,
    security_level uint1 NOT NULL,
    realm_id INT NOT NULL DEFAULT -1,
    comment VARCHAR(255),
    PRIMARY KEY (account_id, realm_id)
);

COMMENT ON TABLE account_access IS 'Access levels for accounts per realm.';

-- Table: account_banned
CREATE TABLE account_banned (
    id uint4 NOT NULL,
    bandate TIMESTAMP NOT NULL,
    unbandate TIMESTAMP NOT NULL,
    bannedby VARCHAR(50) NOT NULL,
    banreason VARCHAR(255) NOT NULL,
    active BOOLEAN NOT NULL DEFAULT TRUE,
    PRIMARY KEY (id, bandate)
);

COMMENT ON TABLE account_banned IS 'Ban records for accounts.';

-- Table: autobroadcast
CREATE TABLE autobroadcast (
    realmid INT NOT NULL DEFAULT -1,
    id SERIAL PRIMARY KEY,
    weight uint1 DEFAULT 1,
    text TEXT NOT NULL
);

COMMENT ON TABLE autobroadcast IS 'Automatic broadcast messages.';

-- Table: build_auth_key
CREATE TABLE build_auth_key (
    build INT NOT NULL,
    platform CHAR(4) NOT NULL,
    arch CHAR(4) NOT NULL,
    type CHAR(4) NOT NULL,
    key BYTEA NOT NULL,
    PRIMARY KEY (build, platform, arch, type)
);

COMMENT ON TABLE build_auth_key IS 'Keys for authenticating specific builds.';

-- Table: ip_banned
CREATE TABLE ip_banned (
    ip INET NOT NULL DEFAULT '127.0.0.1',
    bandate TIMESTAMP NOT NULL,
    unbandate TIMESTAMP NOT NULL,
    bannedby VARCHAR(50) NOT NULL DEFAULT '[Console]',
    banreason VARCHAR(255) NOT NULL DEFAULT 'No reason',
    PRIMARY KEY (ip, bandate)
);

COMMENT ON TABLE ip_banned IS 'Ban records for IP addresses.';

-- Table: logs
CREATE TABLE logs (
    time uint4 NOT NULL,
    realm uint4 NOT NULL,
    type VARCHAR(250) NOT NULL,
    level uint1 NOT NULL DEFAULT 0,
    message TEXT
);

COMMENT ON TABLE logs IS 'Log records for events.';

-- Table: rbac_account_permissions
CREATE TABLE rbac_account_permissions (
    account_id uint4 NOT NULL,
    permission_id uint4 NOT NULL,
    test uint8,
    granted BOOLEAN NOT NULL DEFAULT TRUE,
    realm_id INT NOT NULL DEFAULT -1,
    PRIMARY KEY (account_id, permission_id, realm_id)
);

COMMENT ON TABLE rbac_account_permissions IS 'Role-based account permissions.';

CREATE TABLE realmcharacters (
    realmid uint4 NOT NULL,
    acctid uint4 NOT NULL,
    numchars uint1 NOT NULL DEFAULT 0,
    PRIMARY KEY (realmid, acctid)
);

COMMENT ON TABLE realmcharacters IS 'Tracks the number of characters for each account in each realm.';

-- Table: realmlist
CREATE TABLE realmlist (
    id SERIAL PRIMARY KEY,
    name VARCHAR(32) NOT NULL UNIQUE,
    address INET NOT NULL DEFAULT '127.0.0.1',
    local_address INET NOT NULL DEFAULT '127.0.0.1',
    local_subnet_mask INET NOT NULL DEFAULT '255.255.255.0',
    port uint2 NOT NULL DEFAULT 8085,
    icon uint1 NOT NULL DEFAULT 0,
    flag uint1 NOT NULL DEFAULT 2,
    timezone uint1 NOT NULL DEFAULT 0,
    allowed_security_level uint1 NOT NULL DEFAULT 0,
    population real NOT NULL DEFAULT 0 CHECK (population >= 0),
    gamebuild uint4 NOT NULL DEFAULT 12340
);

COMMENT ON TABLE realmlist IS 'List of game realms.';

CREATE TABLE uptime (
    realmid uint4 NOT NULL,
    starttime timestamp NOT NULL DEFAULT now (),
    uptime uint4 NOT NULL DEFAULT 0,
    maxplayers uint2 NOT NULL DEFAULT 0,
    revision VARCHAR(255) NOT NULL DEFAULT 'azerust',
    PRIMARY KEY (realmid, starttime)
);

COMMENT ON TABLE uptime IS 'Uptime system';

```

`crates/pg-auth/src/accounts.rs`:

```rs
use std::{
    convert::TryInto,
    net::{IpAddr, Ipv4Addr},
    time::Duration,
};

use azerust_game::{
    accounts::{Account, AccountFetchError, AccountId, AccountOpError, AccountService, BanStatus, ConnectToken, LoginFailure, ReconnectToken},
    types::Locale,
};
use time::{OffsetDateTime, PrimitiveDateTime};
use tracing::{debug, error, info, instrument, warn};
use wow_srp::{Salt, Verifier, WowSRPServer};

use crate::cornucopia::queries::accounts;

#[derive(Debug, Clone)]
pub struct PgAccountService {
    pool: deadpool_postgres::Pool,
}

impl PgAccountService {
    pub fn new(pool: deadpool_postgres::Pool) -> Self {
        debug!("Starting accounts service");
        Self { pool }
    }
}

impl AccountService for PgAccountService {
    async fn list_account(&self) -> Result<Vec<Account>, AccountFetchError> {
        accounts::list_account()
            .bind(&self.pool.get().await.map_err(|e| AccountFetchError::IO(e.to_string()))?)
            .map(|account| Account {
                id: AccountId(account.id as u32),
                username: account.username.to_owned(),
                email: account.email.to_owned(),
                ban_status: None,
                joindate: account.joindate,
                last_login: account.last_login,
                online: account.online,
                salt: Salt(account.salt.try_into().expect("salt is 32 bytes")),
                verifier: Verifier(account.verifier.try_into().expect("verifier is 32 bytes")),
                session_key: account.session_key_auth.map(|s| s.try_into().expect("session key is 40 bytes")),
            })
            .all()
            .await
            .map_err(|e| AccountFetchError::IO(e.to_string()))
    }

    #[instrument(skip(self))]
    async fn create_account(&self, username: &str, password: &str, email: &str) -> Result<AccountId, AccountOpError> {
        if username.len() > 16 {
            return Err(AccountOpError::UsernameTooLong);
        } else if password.len() > 16 {
            return Err(AccountOpError::PasswordTooLong);
        }

        // convert to uppercase
        let username = username.to_ascii_uppercase();
        let password = password.to_ascii_uppercase();

        let (verifier, salt) = WowSRPServer::register(&username, &password);

        let id = accounts::create_account()
            .bind(
                &self.pool.get().await.map_err(|e| AccountOpError::PersistError(e.to_string()))?,
                &username,
                &salt.0,
                &verifier.0,
                &email,
                &email,
            )
            .await
            .map_err(|e| AccountOpError::PersistError(e.to_string()))?;

        let id = AccountId(id as u32);

        accounts::insert_realmchars_entry()
            .bind(&self.pool.get().await.map_err(|e| AccountOpError::PersistError(e.to_string()))?)
            .await
            .map_err(|e| AccountOpError::PersistError(e.to_string()))?;

        Ok(id)
    }

    #[instrument(skip(self))]
    async fn delete_account(&self, id: AccountId) -> Result<(), AccountOpError> {
        accounts::account_exists()
            .bind(&self.pool.get().await.map_err(|e| AccountOpError::PersistError(e.to_string()))?, &(id.0 as i32))
            .one()
            .await
            .map_err(|_| AccountOpError::InvalidAccount(id))?;

        let characters: Vec<u8> = vec![];

        for _character in characters {
            // delete
        }

        // delete tutorials
        // delete account data
        // delete character bans

        // delete account
        // delete access history
        // delete characters
        // delete bans
        // delete muted

        Ok(())
    }

    #[instrument(skip(self))]
    async fn get(&self, id: AccountId) -> Result<Account, AccountOpError> {
        accounts::select_account_by_id()
            .bind(&self.pool.get().await.map_err(|e| AccountOpError::PersistError(e.to_string()))?, &(id.0 as i32))
            .map(|acc| Account {
                id: AccountId(acc.id as u32),
                email: acc.email.to_string(),
                username: acc.username.to_string(),
                salt: Salt(acc.salt.try_into().expect("right length")),
                verifier: Verifier(acc.verifier.try_into().expect("right length")),
                session_key: acc.session_key_auth.map(|sk| sk.try_into().expect("right length")),
                joindate: acc.joindate,
                last_login: acc.last_login,
                online: acc.online,
                ban_status: None,
            })
            .one()
            .await
            .map_err(|_| AccountOpError::InvalidAccount(id))
    }

    #[instrument(skip(self))]
    async fn get_by_username(&self, username: &str) -> Result<Option<Account>, AccountOpError> {
        let conn = self.pool.get().await.map_err(|e| AccountOpError::PersistError(e.to_string()))?;

        let Some(mut account) = accounts::select_account_by_username()
            .bind(&conn, &username)
            .map(|acc| Account {
                id: AccountId(acc.id as u32),
                email: acc.email.to_string(),
                username: acc.username.to_string(),
                salt: Salt(acc.salt.try_into().expect("right length")),
                verifier: Verifier(acc.verifier.try_into().expect("right length")),
                session_key: acc.session_key_auth.map(|sk| sk.try_into().expect("right length")),
                joindate: acc.joindate,
                last_login: acc.last_login,
                online: acc.online,
                ban_status: None,
            })
            .opt()
            .await
            .map_err(|e| {
                tracing::error!("failed to load account: {e}");
                AccountOpError::PersistError(e.to_string())
            })?
        else {
            info!("no account found");
            return Ok(None);
        };

        info!("getting ban status");

        if let Some(ban) = accounts::select_account_banned()
            .bind(
                &self.pool.get().await.map_err(|e| AccountOpError::PersistError(e.to_string()))?,
                &(account.id.0),
            )
            .opt()
            .await
            .map_err(|e| {
                tracing::error!("Error persisting account: {:?}", e);
                AccountOpError::PersistError(e.to_string())
            })?
        {
            account.ban_status = match (ban.is_banned, ban.is_permabanned) {
                (_, true) => Some(BanStatus::Permanent),
                (true, _) => Some(BanStatus::Temporary),
                _ => None,
            };
        }

        Ok(Some(account))
    }

    #[instrument(skip(self))]
    async fn initiate_login(&self, username: &str) -> Result<ConnectToken, LoginFailure> {
        tracing::info!("login attempt for {username}");
        let account = self
            .get_by_username(username)
            .await
            .map_err(|_| LoginFailure::DatabaseError)?
            .ok_or(LoginFailure::UnknownAccount)?;

        match account.ban_status {
            Some(BanStatus::Permanent) => {
                warn!("permanently banned user {username} tried to login");
                Err(LoginFailure::Banned)
            }
            Some(BanStatus::Temporary) => {
                warn!("banned user {username} tried to login");
                Err(LoginFailure::Suspended)
            }
            None => Ok(ConnectToken::new(&account.username, account.salt, account.verifier)),
        }
    }

    async fn initiate_relogin(&self, username: &str) -> Result<ReconnectToken, LoginFailure> {
        let request = accounts::initiate_relogin()
            .bind(&self.pool.get().await.map_err(|_| LoginFailure::DatabaseError)?, &username)
            .one()
            .await
            .map_err(|_| LoginFailure::DatabaseError)?;

        let ban_status = match (request.is_banned, request.is_permabanned) {
            (_, true) => Some(BanStatus::Permanent),
            (true, _) => Some(BanStatus::Temporary),
            _ => None,
        };

        let account = Account {
            id: AccountId(request.id as u32),
            username: request.username,
            salt: Salt([0u8; 32]),
            verifier: Verifier([0u8; 32]),
            ban_status,

            // todo(arlyon): fill in
            session_key: None,
            email: "".to_string(),
            online: false,
            joindate: {
                let now = OffsetDateTime::now_utc();
                PrimitiveDateTime::new(now.date(), now.time())
            },
            last_login: None,
        };

        // get session key

        Ok(ReconnectToken::new(
            account,
            request.session_key.as_slice().try_into().ok().ok_or(LoginFailure::DatabaseError)?,
        ))
    }

    async fn complete_login(&self, username: String, token: &ConnectToken, public_key: &[u8; 32], client_proof: &[u8; 20]) -> Result<[u8; 20], LoginFailure> {
        let (server_proof, session_key) = token.accept(public_key, client_proof)?;

        // update session information
        // todo(arlyon) set this information
        accounts::update_session_information()
            .bind(
                &self.pool.get().await.map_err(|_| LoginFailure::DatabaseError)?,
                &session_key,
                &IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)),
                &u8::from(Locale::enUS),
                &"Win",
                &&username,
            )
            .await
            .map_err(|e| {
                error!("error updating session: {e}");
                LoginFailure::DatabaseError
            })?;

        info!("logged in {username}");

        Ok(server_proof)
    }

    async fn complete_relogin(&self, token: &ReconnectToken, proof_data: &[u8; 16], client_proof: &[u8; 20]) -> Result<[u8; 20], LoginFailure> {
        token.accept(proof_data, client_proof).map(|_| client_proof.to_owned())
    }

    /// Set a ban for a given account.
    ///
    /// duration: the duration of the ban. If `None`, the ban is permanent.
    ///
    /// note: permabans are represented by a unbandate of the same value as the bandate.
    async fn set_ban(&self, id: AccountId, author: &str, duration: Option<Duration>, reason: Option<&str>) -> Result<(), AccountOpError> {
        let bandate = OffsetDateTime::now_utc();
        let now_pdt = PrimitiveDateTime::new(bandate.date(), bandate.time());
        let unbandate = match duration {
            Some(d) => now_pdt + d,
            None => now_pdt,
        };

        accounts::ban_user()
            .bind(
                &self.pool.get().await.map_err(|e| AccountOpError::PersistError(e.to_string()))?,
                &id.0,
                &unbandate,
                &author,
                &reason.unwrap_or(""),
            )
            .await
            .map_err(|e| AccountOpError::PersistError(e.to_string()))?;

        info!("banned {id} for {duration:?}");

        Ok(())
    }
}

```

`crates/pg-auth/src/cornucopia.rs`:

```rs
// This file was generated with `cornucopia`. Do not modify.

 #[allow(clippy::all, clippy::pedantic)] #[allow(unused_variables)]
#[allow(unused_imports)] #[allow(dead_code)] pub mod types { } #[allow(clippy::all, clippy::pedantic)] #[allow(unused_variables)]
#[allow(unused_imports)] #[allow(dead_code)] pub mod queries
{  pub mod accounts
{  #[derive( Debug)] pub struct CreateAccountParams<T1: cornucopia_async::StringSql,T2: cornucopia_async::BytesSql,T3: cornucopia_async::BytesSql,T4: cornucopia_async::StringSql,T5: cornucopia_async::StringSql,> { pub username: T1,pub salt: T2,pub verifier: T3,pub reg_main: T4,pub email: T5,} #[derive( Debug)] pub struct UpdateSessionInformationParams<T1: cornucopia_async::BytesSql,T2: cornucopia_async::StringSql,T3: cornucopia_async::StringSql,> { pub session_key: T1,pub last_ip: std::net::IpAddr,pub locale: u8,pub os: T2,pub username: T3,} #[derive( Debug)] pub struct BanUserParams<T1: cornucopia_async::StringSql,T2: cornucopia_async::StringSql,> { pub id: u32,pub unban_date: time::PrimitiveDateTime,pub banned_by: T1,pub ban_reason: T2,} #[derive( Debug, Clone, PartialEq,)] pub struct ListAccount
{ pub id : i32,pub username : String,pub session_key_auth : Option<Vec<u8>>,pub salt : Vec<u8>,pub verifier : Vec<u8>,pub email : String,pub joindate : time::PrimitiveDateTime,pub last_login : Option<time::PrimitiveDateTime>,pub online : bool,} pub struct ListAccountBorrowed<'a> { pub id : i32,pub username : &'a str,pub session_key_auth : Option<&'a [u8]>,pub salt : &'a [u8],pub verifier : &'a [u8],pub email : &'a str,pub joindate : time::PrimitiveDateTime,pub last_login : Option<time::PrimitiveDateTime>,pub online : bool,}
impl<'a> From<ListAccountBorrowed<'a>> for ListAccount
{
    fn from(ListAccountBorrowed { id,username,session_key_auth,salt,verifier,email,joindate,last_login,online,}: ListAccountBorrowed<'a>) ->
    Self { Self { id,username: username.into(),session_key_auth: session_key_auth.map(|v| v.into()),salt: salt.into(),verifier: verifier.into(),email: email.into(),joindate,last_login,online,} }
} #[derive( Debug, Clone, PartialEq,)] pub struct SelectAccountById
{ pub id : i32,pub username : String,pub session_key_auth : Option<Vec<u8>>,pub salt : Vec<u8>,pub verifier : Vec<u8>,pub email : String,pub joindate : time::PrimitiveDateTime,pub last_login : Option<time::PrimitiveDateTime>,pub online : bool,} pub struct SelectAccountByIdBorrowed<'a> { pub id : i32,pub username : &'a str,pub session_key_auth : Option<&'a [u8]>,pub salt : &'a [u8],pub verifier : &'a [u8],pub email : &'a str,pub joindate : time::PrimitiveDateTime,pub last_login : Option<time::PrimitiveDateTime>,pub online : bool,}
impl<'a> From<SelectAccountByIdBorrowed<'a>> for SelectAccountById
{
    fn from(SelectAccountByIdBorrowed { id,username,session_key_auth,salt,verifier,email,joindate,last_login,online,}: SelectAccountByIdBorrowed<'a>) ->
    Self { Self { id,username: username.into(),session_key_auth: session_key_auth.map(|v| v.into()),salt: salt.into(),verifier: verifier.into(),email: email.into(),joindate,last_login,online,} }
} #[derive( Debug, Clone, PartialEq,)] pub struct SelectAccountByUsername
{ pub id : i32,pub username : String,pub session_key_auth : Option<Vec<u8>>,pub salt : Vec<u8>,pub verifier : Vec<u8>,pub email : String,pub joindate : time::PrimitiveDateTime,pub last_login : Option<time::PrimitiveDateTime>,pub online : bool,} pub struct SelectAccountByUsernameBorrowed<'a> { pub id : i32,pub username : &'a str,pub session_key_auth : Option<&'a [u8]>,pub salt : &'a [u8],pub verifier : &'a [u8],pub email : &'a str,pub joindate : time::PrimitiveDateTime,pub last_login : Option<time::PrimitiveDateTime>,pub online : bool,}
impl<'a> From<SelectAccountByUsernameBorrowed<'a>> for SelectAccountByUsername
{
    fn from(SelectAccountByUsernameBorrowed { id,username,session_key_auth,salt,verifier,email,joindate,last_login,online,}: SelectAccountByUsernameBorrowed<'a>) ->
    Self { Self { id,username: username.into(),session_key_auth: session_key_auth.map(|v| v.into()),salt: salt.into(),verifier: verifier.into(),email: email.into(),joindate,last_login,online,} }
} #[derive( Debug, Clone, PartialEq,Copy)] pub struct SelectAccountBanned
{ pub is_banned : bool,pub is_permabanned : bool,} #[derive( Debug, Clone, PartialEq,)] pub struct InitiateRelogin
{ pub id : i32,pub username : String,pub locked : bool,pub lock_country : String,pub last_ip : std::net::IpAddr,pub failed_logins : u32,pub is_banned : bool,pub is_permabanned : bool,pub security_level : u8,pub session_key : Vec<u8>,} pub struct InitiateReloginBorrowed<'a> { pub id : i32,pub username : &'a str,pub locked : bool,pub lock_country : &'a str,pub last_ip : std::net::IpAddr,pub failed_logins : u32,pub is_banned : bool,pub is_permabanned : bool,pub security_level : u8,pub session_key : &'a [u8],}
impl<'a> From<InitiateReloginBorrowed<'a>> for InitiateRelogin
{
    fn from(InitiateReloginBorrowed { id,username,locked,lock_country,last_ip,failed_logins,is_banned,is_permabanned,security_level,session_key,}: InitiateReloginBorrowed<'a>) ->
    Self { Self { id,username: username.into(),locked,lock_country: lock_country.into(),last_ip,failed_logins,is_banned,is_permabanned,security_level,session_key: session_key.into(),} }
}  use futures::{StreamExt, TryStreamExt};use futures; use cornucopia_async::GenericClient; pub struct ListAccountQuery<'a, C: GenericClient, T, const N: usize>
{
    client: &'a  C, params:
    [&'a (dyn postgres_types::ToSql + Sync); N], stmt: &'a mut
    cornucopia_async::private::Stmt, extractor: fn(&tokio_postgres::Row) -> ListAccountBorrowed,
    mapper: fn(ListAccountBorrowed) -> T,
} impl<'a, C, T:'a, const N: usize> ListAccountQuery<'a, C, T, N> where C:
GenericClient
{
    pub fn map<R>(self, mapper: fn(ListAccountBorrowed) -> R) ->
    ListAccountQuery<'a,C,R,N>
    {
        ListAccountQuery
        {
            client: self.client, params: self.params, stmt: self.stmt,
            extractor: self.extractor, mapper,
        }
    } pub async fn one(self) -> Result<T, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let row =
        self.client.query_one(stmt, &self.params).await?;
        Ok((self.mapper)((self.extractor)(&row)))
    } pub async fn all(self) -> Result<Vec<T>, tokio_postgres::Error>
    { self.iter().await?.try_collect().await } pub async fn opt(self) ->
    Result<Option<T>, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?;
        Ok(self.client.query_opt(stmt, &self.params) .await?
        .map(|row| (self.mapper)((self.extractor)(&row))))
    } pub async fn iter(self,) -> Result<impl futures::Stream<Item = Result<T,
    tokio_postgres::Error>> + 'a, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let it =
        self.client.query_raw(stmt,
        cornucopia_async::private::slice_iter(&self.params)) .await?
        .map(move |res|
        res.map(|row| (self.mapper)((self.extractor)(&row)))) .into_stream();
        Ok(it)
    }
} pub struct I32Query<'a, C: GenericClient, T, const N: usize>
{
    client: &'a  C, params:
    [&'a (dyn postgres_types::ToSql + Sync); N], stmt: &'a mut
    cornucopia_async::private::Stmt, extractor: fn(&tokio_postgres::Row) -> i32,
    mapper: fn(i32) -> T,
} impl<'a, C, T:'a, const N: usize> I32Query<'a, C, T, N> where C:
GenericClient
{
    pub fn map<R>(self, mapper: fn(i32) -> R) ->
    I32Query<'a,C,R,N>
    {
        I32Query
        {
            client: self.client, params: self.params, stmt: self.stmt,
            extractor: self.extractor, mapper,
        }
    } pub async fn one(self) -> Result<T, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let row =
        self.client.query_one(stmt, &self.params).await?;
        Ok((self.mapper)((self.extractor)(&row)))
    } pub async fn all(self) -> Result<Vec<T>, tokio_postgres::Error>
    { self.iter().await?.try_collect().await } pub async fn opt(self) ->
    Result<Option<T>, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?;
        Ok(self.client.query_opt(stmt, &self.params) .await?
        .map(|row| (self.mapper)((self.extractor)(&row))))
    } pub async fn iter(self,) -> Result<impl futures::Stream<Item = Result<T,
    tokio_postgres::Error>> + 'a, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let it =
        self.client.query_raw(stmt,
        cornucopia_async::private::slice_iter(&self.params)) .await?
        .map(move |res|
        res.map(|row| (self.mapper)((self.extractor)(&row)))) .into_stream();
        Ok(it)
    }
} pub struct SelectAccountByIdQuery<'a, C: GenericClient, T, const N: usize>
{
    client: &'a  C, params:
    [&'a (dyn postgres_types::ToSql + Sync); N], stmt: &'a mut
    cornucopia_async::private::Stmt, extractor: fn(&tokio_postgres::Row) -> SelectAccountByIdBorrowed,
    mapper: fn(SelectAccountByIdBorrowed) -> T,
} impl<'a, C, T:'a, const N: usize> SelectAccountByIdQuery<'a, C, T, N> where C:
GenericClient
{
    pub fn map<R>(self, mapper: fn(SelectAccountByIdBorrowed) -> R) ->
    SelectAccountByIdQuery<'a,C,R,N>
    {
        SelectAccountByIdQuery
        {
            client: self.client, params: self.params, stmt: self.stmt,
            extractor: self.extractor, mapper,
        }
    } pub async fn one(self) -> Result<T, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let row =
        self.client.query_one(stmt, &self.params).await?;
        Ok((self.mapper)((self.extractor)(&row)))
    } pub async fn all(self) -> Result<Vec<T>, tokio_postgres::Error>
    { self.iter().await?.try_collect().await } pub async fn opt(self) ->
    Result<Option<T>, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?;
        Ok(self.client.query_opt(stmt, &self.params) .await?
        .map(|row| (self.mapper)((self.extractor)(&row))))
    } pub async fn iter(self,) -> Result<impl futures::Stream<Item = Result<T,
    tokio_postgres::Error>> + 'a, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let it =
        self.client.query_raw(stmt,
        cornucopia_async::private::slice_iter(&self.params)) .await?
        .map(move |res|
        res.map(|row| (self.mapper)((self.extractor)(&row)))) .into_stream();
        Ok(it)
    }
} pub struct SelectAccountByUsernameQuery<'a, C: GenericClient, T, const N: usize>
{
    client: &'a  C, params:
    [&'a (dyn postgres_types::ToSql + Sync); N], stmt: &'a mut
    cornucopia_async::private::Stmt, extractor: fn(&tokio_postgres::Row) -> SelectAccountByUsernameBorrowed,
    mapper: fn(SelectAccountByUsernameBorrowed) -> T,
} impl<'a, C, T:'a, const N: usize> SelectAccountByUsernameQuery<'a, C, T, N> where C:
GenericClient
{
    pub fn map<R>(self, mapper: fn(SelectAccountByUsernameBorrowed) -> R) ->
    SelectAccountByUsernameQuery<'a,C,R,N>
    {
        SelectAccountByUsernameQuery
        {
            client: self.client, params: self.params, stmt: self.stmt,
            extractor: self.extractor, mapper,
        }
    } pub async fn one(self) -> Result<T, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let row =
        self.client.query_one(stmt, &self.params).await?;
        Ok((self.mapper)((self.extractor)(&row)))
    } pub async fn all(self) -> Result<Vec<T>, tokio_postgres::Error>
    { self.iter().await?.try_collect().await } pub async fn opt(self) ->
    Result<Option<T>, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?;
        Ok(self.client.query_opt(stmt, &self.params) .await?
        .map(|row| (self.mapper)((self.extractor)(&row))))
    } pub async fn iter(self,) -> Result<impl futures::Stream<Item = Result<T,
    tokio_postgres::Error>> + 'a, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let it =
        self.client.query_raw(stmt,
        cornucopia_async::private::slice_iter(&self.params)) .await?
        .map(move |res|
        res.map(|row| (self.mapper)((self.extractor)(&row)))) .into_stream();
        Ok(it)
    }
} pub struct SelectAccountBannedQuery<'a, C: GenericClient, T, const N: usize>
{
    client: &'a  C, params:
    [&'a (dyn postgres_types::ToSql + Sync); N], stmt: &'a mut
    cornucopia_async::private::Stmt, extractor: fn(&tokio_postgres::Row) -> SelectAccountBanned,
    mapper: fn(SelectAccountBanned) -> T,
} impl<'a, C, T:'a, const N: usize> SelectAccountBannedQuery<'a, C, T, N> where C:
GenericClient
{
    pub fn map<R>(self, mapper: fn(SelectAccountBanned) -> R) ->
    SelectAccountBannedQuery<'a,C,R,N>
    {
        SelectAccountBannedQuery
        {
            client: self.client, params: self.params, stmt: self.stmt,
            extractor: self.extractor, mapper,
        }
    } pub async fn one(self) -> Result<T, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let row =
        self.client.query_one(stmt, &self.params).await?;
        Ok((self.mapper)((self.extractor)(&row)))
    } pub async fn all(self) -> Result<Vec<T>, tokio_postgres::Error>
    { self.iter().await?.try_collect().await } pub async fn opt(self) ->
    Result<Option<T>, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?;
        Ok(self.client.query_opt(stmt, &self.params) .await?
        .map(|row| (self.mapper)((self.extractor)(&row))))
    } pub async fn iter(self,) -> Result<impl futures::Stream<Item = Result<T,
    tokio_postgres::Error>> + 'a, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let it =
        self.client.query_raw(stmt,
        cornucopia_async::private::slice_iter(&self.params)) .await?
        .map(move |res|
        res.map(|row| (self.mapper)((self.extractor)(&row)))) .into_stream();
        Ok(it)
    }
} pub struct InitiateReloginQuery<'a, C: GenericClient, T, const N: usize>
{
    client: &'a  C, params:
    [&'a (dyn postgres_types::ToSql + Sync); N], stmt: &'a mut
    cornucopia_async::private::Stmt, extractor: fn(&tokio_postgres::Row) -> InitiateReloginBorrowed,
    mapper: fn(InitiateReloginBorrowed) -> T,
} impl<'a, C, T:'a, const N: usize> InitiateReloginQuery<'a, C, T, N> where C:
GenericClient
{
    pub fn map<R>(self, mapper: fn(InitiateReloginBorrowed) -> R) ->
    InitiateReloginQuery<'a,C,R,N>
    {
        InitiateReloginQuery
        {
            client: self.client, params: self.params, stmt: self.stmt,
            extractor: self.extractor, mapper,
        }
    } pub async fn one(self) -> Result<T, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let row =
        self.client.query_one(stmt, &self.params).await?;
        Ok((self.mapper)((self.extractor)(&row)))
    } pub async fn all(self) -> Result<Vec<T>, tokio_postgres::Error>
    { self.iter().await?.try_collect().await } pub async fn opt(self) ->
    Result<Option<T>, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?;
        Ok(self.client.query_opt(stmt, &self.params) .await?
        .map(|row| (self.mapper)((self.extractor)(&row))))
    } pub async fn iter(self,) -> Result<impl futures::Stream<Item = Result<T,
    tokio_postgres::Error>> + 'a, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let it =
        self.client.query_raw(stmt,
        cornucopia_async::private::slice_iter(&self.params)) .await?
        .map(move |res|
        res.map(|row| (self.mapper)((self.extractor)(&row)))) .into_stream();
        Ok(it)
    }
} pub fn list_account() -> ListAccountStmt
{ ListAccountStmt(cornucopia_async::private::Stmt::new("SELECT id, username, session_key_auth, salt, verifier, email, joindate, last_login, online from account")) } pub struct
ListAccountStmt(cornucopia_async::private::Stmt); impl ListAccountStmt
{  pub fn bind<'a, C:
GenericClient,>(&'a mut self, client: &'a  C,
) -> ListAccountQuery<'a,C,
ListAccount, 0>
{
    ListAccountQuery
    {
        client, params: [], stmt: &mut self.0, extractor:
        |row| {  ListAccountBorrowed { id: row.get(0),username: row.get(1),session_key_auth: row.get(2),salt: row.get(3),verifier: row.get(4),email: row.get(5),joindate: row.get(6),last_login: row.get(7),online: row.get(8),} }, mapper: |it| { <ListAccount>::from(it) },
    }
} } pub fn create_account() -> CreateAccountStmt
{ CreateAccountStmt(cornucopia_async::private::Stmt::new("INSERT INTO account(username, salt, verifier, reg_mail, email, joindate) VALUES($1, $2, $3, $4, $5, NOW())")) } pub struct
CreateAccountStmt(cornucopia_async::private::Stmt); impl CreateAccountStmt
{  pub async fn bind<'a, C:
GenericClient,T1:
cornucopia_async::StringSql,T2:
cornucopia_async::BytesSql,T3:
cornucopia_async::BytesSql,T4:
cornucopia_async::StringSql,T5:
cornucopia_async::StringSql,>(&'a mut self, client: &'a  C,
username: &'a T1,salt: &'a T2,verifier: &'a T3,reg_main: &'a T4,email: &'a T5,) -> Result<u64, tokio_postgres::Error>
{
    let stmt = self.0.prepare(client).await?;
    client.execute(stmt, &[username,salt,verifier,reg_main,email,]).await
} } impl <'a, C: GenericClient + Send + Sync, T1: cornucopia_async::StringSql,T2: cornucopia_async::BytesSql,T3: cornucopia_async::BytesSql,T4: cornucopia_async::StringSql,T5: cornucopia_async::StringSql,>
cornucopia_async::Params<'a, CreateAccountParams<T1,T2,T3,T4,T5,>, std::pin::Pin<Box<dyn futures::Future<Output = Result<u64,
tokio_postgres::Error>> + Send + 'a>>, C> for CreateAccountStmt
{
    fn
    params(&'a mut self, client: &'a  C, params: &'a
    CreateAccountParams<T1,T2,T3,T4,T5,>) -> std::pin::Pin<Box<dyn futures::Future<Output = Result<u64,
    tokio_postgres::Error>> + Send + 'a>>
    { Box::pin(self.bind(client, &params.username,&params.salt,&params.verifier,&params.reg_main,&params.email,)) }
} pub fn insert_realmchars_entry() -> InsertRealmcharsEntryStmt
{ InsertRealmcharsEntryStmt(cornucopia_async::private::Stmt::new("INSERT INTO realmcharacters (realmid, acctid, numchars) SELECT realmlist.id, account.id, 0 FROM realmlist, account LEFT JOIN realmcharacters ON acctid = account.id WHERE acctid IS NULL")) } pub struct
InsertRealmcharsEntryStmt(cornucopia_async::private::Stmt); impl InsertRealmcharsEntryStmt
{  pub async fn bind<'a, C:
GenericClient,>(&'a mut self, client: &'a  C,
) -> Result<u64, tokio_postgres::Error>
{
    let stmt = self.0.prepare(client).await?;
    client.execute(stmt, &[]).await
} } pub fn account_exists() -> AccountExistsStmt
{ AccountExistsStmt(cornucopia_async::private::Stmt::new("SELECT id FROM account WHERE id = $1")) } pub struct
AccountExistsStmt(cornucopia_async::private::Stmt); impl AccountExistsStmt
{  pub fn bind<'a, C:
GenericClient,>(&'a mut self, client: &'a  C,
id: &'a i32,) -> I32Query<'a,C,
i32, 1>
{
    I32Query
    {
        client, params: [id,], stmt: &mut self.0, extractor:
        |row| {  row.get(0) }, mapper: |it| { it },
    }
} } pub fn select_account_by_id() -> SelectAccountByIdStmt
{ SelectAccountByIdStmt(cornucopia_async::private::Stmt::new("SELECT id, username, session_key_auth, salt, verifier, email, joindate, last_login, online FROM account WHERE id = $1")) } pub struct
SelectAccountByIdStmt(cornucopia_async::private::Stmt); impl SelectAccountByIdStmt
{  pub fn bind<'a, C:
GenericClient,>(&'a mut self, client: &'a  C,
id: &'a i32,) -> SelectAccountByIdQuery<'a,C,
SelectAccountById, 1>
{
    SelectAccountByIdQuery
    {
        client, params: [id,], stmt: &mut self.0, extractor:
        |row| {  SelectAccountByIdBorrowed { id: row.get(0),username: row.get(1),session_key_auth: row.get(2),salt: row.get(3),verifier: row.get(4),email: row.get(5),joindate: row.get(6),last_login: row.get(7),online: row.get(8),} }, mapper: |it| { <SelectAccountById>::from(it) },
    }
} } pub fn select_account_by_username() -> SelectAccountByUsernameStmt
{ SelectAccountByUsernameStmt(cornucopia_async::private::Stmt::new("SELECT id, username, session_key_auth, salt, verifier, email, joindate, last_login, online FROM account WHERE username = $1")) } pub struct
SelectAccountByUsernameStmt(cornucopia_async::private::Stmt); impl SelectAccountByUsernameStmt
{  pub fn bind<'a, C:
GenericClient,T1:
cornucopia_async::StringSql,>(&'a mut self, client: &'a  C,
username: &'a T1,) -> SelectAccountByUsernameQuery<'a,C,
SelectAccountByUsername, 1>
{
    SelectAccountByUsernameQuery
    {
        client, params: [username,], stmt: &mut self.0, extractor:
        |row| {  SelectAccountByUsernameBorrowed { id: row.get(0),username: row.get(1),session_key_auth: row.get(2),salt: row.get(3),verifier: row.get(4),email: row.get(5),joindate: row.get(6),last_login: row.get(7),online: row.get(8),} }, mapper: |it| { <SelectAccountByUsername>::from(it) },
    }
} } pub fn select_account_banned() -> SelectAccountBannedStmt
{ SelectAccountBannedStmt(cornucopia_async::private::Stmt::new("SELECT  (ab.unbandate > now() OR ab.unbandate = ab.bandate) as is_banned, (ab.unbandate = ab.bandate) as is_permabanned FROM account_banned ab where ab.id = $1")) } pub struct
SelectAccountBannedStmt(cornucopia_async::private::Stmt); impl SelectAccountBannedStmt
{  pub fn bind<'a, C:
GenericClient,>(&'a mut self, client: &'a  C,
id: &'a u32,) -> SelectAccountBannedQuery<'a,C,
SelectAccountBanned, 1>
{
    SelectAccountBannedQuery
    {
        client, params: [id,], stmt: &mut self.0, extractor:
        |row| {  SelectAccountBanned { is_banned: row.get(0),is_permabanned: row.get(1),} }, mapper: |it| { <SelectAccountBanned>::from(it) },
    }
} } pub fn initiate_relogin() -> InitiateReloginStmt
{ InitiateReloginStmt(cornucopia_async::private::Stmt::new("SELECT a.id, a.username, a.locked, a.lock_country, a.last_ip, a.failed_logins, (ab.unbandate > now() OR ab.unbandate = ab.bandate) as is_banned, (ab.unbandate = ab.bandate) as is_permabanned, aa.security_level, a.session_key_auth as session_key FROM account a LEFT JOIN account_access aa ON a.id = aa.account_id LEFT JOIN account_banned ab ON ab.id = a.id AND ab.active = true WHERE a.username = $1 AND a.session_key_auth IS NOT NULL")) } pub struct
InitiateReloginStmt(cornucopia_async::private::Stmt); impl InitiateReloginStmt
{  pub fn bind<'a, C:
GenericClient,T1:
cornucopia_async::StringSql,>(&'a mut self, client: &'a  C,
username: &'a T1,) -> InitiateReloginQuery<'a,C,
InitiateRelogin, 1>
{
    InitiateReloginQuery
    {
        client, params: [username,], stmt: &mut self.0, extractor:
        |row| {  InitiateReloginBorrowed { id: row.get(0),username: row.get(1),locked: row.get(2),lock_country: row.get(3),last_ip: row.get(4),failed_logins: row.get(5),is_banned: row.get(6),is_permabanned: row.get(7),security_level: row.get(8),session_key: row.get(9),} }, mapper: |it| { <InitiateRelogin>::from(it) },
    }
} } pub fn update_session_information() -> UpdateSessionInformationStmt
{ UpdateSessionInformationStmt(cornucopia_async::private::Stmt::new("UPDATE account SET session_key_auth = $1, last_ip = $2, last_login = now(), locale = $3, failed_logins = 0, os = $4 WHERE username = $5")) } pub struct
UpdateSessionInformationStmt(cornucopia_async::private::Stmt); impl UpdateSessionInformationStmt
{  pub async fn bind<'a, C:
GenericClient,T1:
cornucopia_async::BytesSql,T2:
cornucopia_async::StringSql,T3:
cornucopia_async::StringSql,>(&'a mut self, client: &'a  C,
session_key: &'a T1,last_ip: &'a std::net::IpAddr,locale: &'a u8,os: &'a T2,username: &'a T3,) -> Result<u64, tokio_postgres::Error>
{
    let stmt = self.0.prepare(client).await?;
    client.execute(stmt, &[session_key,last_ip,locale,os,username,]).await
} } impl <'a, C: GenericClient + Send + Sync, T1: cornucopia_async::BytesSql,T2: cornucopia_async::StringSql,T3: cornucopia_async::StringSql,>
cornucopia_async::Params<'a, UpdateSessionInformationParams<T1,T2,T3,>, std::pin::Pin<Box<dyn futures::Future<Output = Result<u64,
tokio_postgres::Error>> + Send + 'a>>, C> for UpdateSessionInformationStmt
{
    fn
    params(&'a mut self, client: &'a  C, params: &'a
    UpdateSessionInformationParams<T1,T2,T3,>) -> std::pin::Pin<Box<dyn futures::Future<Output = Result<u64,
    tokio_postgres::Error>> + Send + 'a>>
    { Box::pin(self.bind(client, &params.session_key,&params.last_ip,&params.locale,&params.os,&params.username,)) }
} pub fn ban_user() -> BanUserStmt
{ BanUserStmt(cornucopia_async::private::Stmt::new("INSERT INTO account_banned (id, bandate, unbandate, bannedby, banreason) values ($1, now(), $2, $3, $4)")) } pub struct
BanUserStmt(cornucopia_async::private::Stmt); impl BanUserStmt
{  pub async fn bind<'a, C:
GenericClient,T1:
cornucopia_async::StringSql,T2:
cornucopia_async::StringSql,>(&'a mut self, client: &'a  C,
id: &'a u32,unban_date: &'a time::PrimitiveDateTime,banned_by: &'a T1,ban_reason: &'a T2,) -> Result<u64, tokio_postgres::Error>
{
    let stmt = self.0.prepare(client).await?;
    client.execute(stmt, &[id,unban_date,banned_by,ban_reason,]).await
} } impl <'a, C: GenericClient + Send + Sync, T1: cornucopia_async::StringSql,T2: cornucopia_async::StringSql,>
cornucopia_async::Params<'a, BanUserParams<T1,T2,>, std::pin::Pin<Box<dyn futures::Future<Output = Result<u64,
tokio_postgres::Error>> + Send + 'a>>, C> for BanUserStmt
{
    fn
    params(&'a mut self, client: &'a  C, params: &'a
    BanUserParams<T1,T2,>) -> std::pin::Pin<Box<dyn futures::Future<Output = Result<u64,
    tokio_postgres::Error>> + Send + 'a>>
    { Box::pin(self.bind(client, &params.id,&params.unban_date,&params.banned_by,&params.ban_reason,)) }
} } pub mod realms
{  #[derive(Clone,Copy, Debug)] pub struct UpdateRealmlistStatusParams<> { pub flag: u8,pub id: i32,} #[derive( Debug)] pub struct CreateRealmParams<T1: cornucopia_async::StringSql,> { pub name: T1,pub address: std::net::IpAddr,pub local_address: std::net::IpAddr,pub local_subnet_mask: std::net::IpAddr,pub port: u16,} #[derive( Debug)] pub struct SetUptimeParams<T1: cornucopia_async::StringSql,> { pub id: u32,pub start: time::PrimitiveDateTime,pub uptime: u32,pub maxplayers: u16,pub version: T1,} #[derive( Debug, Clone, PartialEq,)] pub struct RefreshRealmlist
{ pub id : i32,pub name : String,pub realm_type : u8,pub build : u32,pub external_address : std::net::IpAddr,pub local_address : std::net::IpAddr,pub local_subnet_mask : std::net::IpAddr,pub port : u16,pub flags : u8,pub timezone : u8,pub population : f32,} pub struct RefreshRealmlistBorrowed<'a> { pub id : i32,pub name : &'a str,pub realm_type : u8,pub build : u32,pub external_address : std::net::IpAddr,pub local_address : std::net::IpAddr,pub local_subnet_mask : std::net::IpAddr,pub port : u16,pub flags : u8,pub timezone : u8,pub population : f32,}
impl<'a> From<RefreshRealmlistBorrowed<'a>> for RefreshRealmlist
{
    fn from(RefreshRealmlistBorrowed { id,name,realm_type,build,external_address,local_address,local_subnet_mask,port,flags,timezone,population,}: RefreshRealmlistBorrowed<'a>) ->
    Self { Self { id,name: name.into(),realm_type,build,external_address,local_address,local_subnet_mask,port,flags,timezone,population,} }
} #[derive( Debug, Clone, PartialEq,)] pub struct CreateRealm
{ pub id : i32,pub name : String,pub address : std::net::IpAddr,pub local_address : std::net::IpAddr,pub local_subnet_mask : std::net::IpAddr,pub port : u16,pub icon : u8,pub flag : u8,pub timezone : u8,pub allowed_security_level : u8,pub population : f32,pub gamebuild : u32,} pub struct CreateRealmBorrowed<'a> { pub id : i32,pub name : &'a str,pub address : std::net::IpAddr,pub local_address : std::net::IpAddr,pub local_subnet_mask : std::net::IpAddr,pub port : u16,pub icon : u8,pub flag : u8,pub timezone : u8,pub allowed_security_level : u8,pub population : f32,pub gamebuild : u32,}
impl<'a> From<CreateRealmBorrowed<'a>> for CreateRealm
{
    fn from(CreateRealmBorrowed { id,name,address,local_address,local_subnet_mask,port,icon,flag,timezone,allowed_security_level,population,gamebuild,}: CreateRealmBorrowed<'a>) ->
    Self { Self { id,name: name.into(),address,local_address,local_subnet_mask,port,icon,flag,timezone,allowed_security_level,population,gamebuild,} }
}  use futures::{StreamExt, TryStreamExt};use futures; use cornucopia_async::GenericClient; pub struct RefreshRealmlistQuery<'a, C: GenericClient, T, const N: usize>
{
    client: &'a  C, params:
    [&'a (dyn postgres_types::ToSql + Sync); N], stmt: &'a mut
    cornucopia_async::private::Stmt, extractor: fn(&tokio_postgres::Row) -> RefreshRealmlistBorrowed,
    mapper: fn(RefreshRealmlistBorrowed) -> T,
} impl<'a, C, T:'a, const N: usize> RefreshRealmlistQuery<'a, C, T, N> where C:
GenericClient
{
    pub fn map<R>(self, mapper: fn(RefreshRealmlistBorrowed) -> R) ->
    RefreshRealmlistQuery<'a,C,R,N>
    {
        RefreshRealmlistQuery
        {
            client: self.client, params: self.params, stmt: self.stmt,
            extractor: self.extractor, mapper,
        }
    } pub async fn one(self) -> Result<T, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let row =
        self.client.query_one(stmt, &self.params).await?;
        Ok((self.mapper)((self.extractor)(&row)))
    } pub async fn all(self) -> Result<Vec<T>, tokio_postgres::Error>
    { self.iter().await?.try_collect().await } pub async fn opt(self) ->
    Result<Option<T>, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?;
        Ok(self.client.query_opt(stmt, &self.params) .await?
        .map(|row| (self.mapper)((self.extractor)(&row))))
    } pub async fn iter(self,) -> Result<impl futures::Stream<Item = Result<T,
    tokio_postgres::Error>> + 'a, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let it =
        self.client.query_raw(stmt,
        cornucopia_async::private::slice_iter(&self.params)) .await?
        .map(move |res|
        res.map(|row| (self.mapper)((self.extractor)(&row)))) .into_stream();
        Ok(it)
    }
} pub struct CreateRealmQuery<'a, C: GenericClient, T, const N: usize>
{
    client: &'a  C, params:
    [&'a (dyn postgres_types::ToSql + Sync); N], stmt: &'a mut
    cornucopia_async::private::Stmt, extractor: fn(&tokio_postgres::Row) -> CreateRealmBorrowed,
    mapper: fn(CreateRealmBorrowed) -> T,
} impl<'a, C, T:'a, const N: usize> CreateRealmQuery<'a, C, T, N> where C:
GenericClient
{
    pub fn map<R>(self, mapper: fn(CreateRealmBorrowed) -> R) ->
    CreateRealmQuery<'a,C,R,N>
    {
        CreateRealmQuery
        {
            client: self.client, params: self.params, stmt: self.stmt,
            extractor: self.extractor, mapper,
        }
    } pub async fn one(self) -> Result<T, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let row =
        self.client.query_one(stmt, &self.params).await?;
        Ok((self.mapper)((self.extractor)(&row)))
    } pub async fn all(self) -> Result<Vec<T>, tokio_postgres::Error>
    { self.iter().await?.try_collect().await } pub async fn opt(self) ->
    Result<Option<T>, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?;
        Ok(self.client.query_opt(stmt, &self.params) .await?
        .map(|row| (self.mapper)((self.extractor)(&row))))
    } pub async fn iter(self,) -> Result<impl futures::Stream<Item = Result<T,
    tokio_postgres::Error>> + 'a, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let it =
        self.client.query_raw(stmt,
        cornucopia_async::private::slice_iter(&self.params)) .await?
        .map(move |res|
        res.map(|row| (self.mapper)((self.extractor)(&row)))) .into_stream();
        Ok(it)
    }
} pub fn refresh_realmlist() -> RefreshRealmlistStmt
{ RefreshRealmlistStmt(cornucopia_async::private::Stmt::new("SELECT id, name, icon as realm_type, gamebuild as build, address as external_address, local_address, local_subnet_mask, port, flag as flags, timezone, population FROM realmlist WHERE flag <> 3 ORDER BY id")) } pub struct
RefreshRealmlistStmt(cornucopia_async::private::Stmt); impl RefreshRealmlistStmt
{  pub fn bind<'a, C:
GenericClient,>(&'a mut self, client: &'a  C,
) -> RefreshRealmlistQuery<'a,C,
RefreshRealmlist, 0>
{
    RefreshRealmlistQuery
    {
        client, params: [], stmt: &mut self.0, extractor:
        |row| {  RefreshRealmlistBorrowed { id: row.get(0),name: row.get(1),realm_type: row.get(2),build: row.get(3),external_address: row.get(4),local_address: row.get(5),local_subnet_mask: row.get(6),port: row.get(7),flags: row.get(8),timezone: row.get(9),population: row.get(10),} }, mapper: |it| { <RefreshRealmlist>::from(it) },
    }
} } pub fn update_realmlist_status() -> UpdateRealmlistStatusStmt
{ UpdateRealmlistStatusStmt(cornucopia_async::private::Stmt::new("update realmlist set flag = $1 where id = $2")) } pub struct
UpdateRealmlistStatusStmt(cornucopia_async::private::Stmt); impl UpdateRealmlistStatusStmt
{  pub async fn bind<'a, C:
GenericClient,>(&'a mut self, client: &'a  C,
flag: &'a u8,id: &'a i32,) -> Result<u64, tokio_postgres::Error>
{
    let stmt = self.0.prepare(client).await?;
    client.execute(stmt, &[flag,id,]).await
} } impl <'a, C: GenericClient + Send + Sync, >
cornucopia_async::Params<'a, UpdateRealmlistStatusParams<>, std::pin::Pin<Box<dyn futures::Future<Output = Result<u64,
tokio_postgres::Error>> + Send + 'a>>, C> for UpdateRealmlistStatusStmt
{
    fn
    params(&'a mut self, client: &'a  C, params: &'a
    UpdateRealmlistStatusParams<>) -> std::pin::Pin<Box<dyn futures::Future<Output = Result<u64,
    tokio_postgres::Error>> + Send + 'a>>
    { Box::pin(self.bind(client, &params.flag,&params.id,)) }
} pub fn create_realm() -> CreateRealmStmt
{ CreateRealmStmt(cornucopia_async::private::Stmt::new("insert into realmlist (name, address, local_address, local_subnet_mask, port) values ($1, $2, $3, $4, $5) returning *")) } pub struct
CreateRealmStmt(cornucopia_async::private::Stmt); impl CreateRealmStmt
{  pub fn bind<'a, C:
GenericClient,T1:
cornucopia_async::StringSql,>(&'a mut self, client: &'a  C,
name: &'a T1,address: &'a std::net::IpAddr,local_address: &'a std::net::IpAddr,local_subnet_mask: &'a std::net::IpAddr,port: &'a u16,) -> CreateRealmQuery<'a,C,
CreateRealm, 5>
{
    CreateRealmQuery
    {
        client, params: [name,address,local_address,local_subnet_mask,port,], stmt: &mut self.0, extractor:
        |row| {  CreateRealmBorrowed { id: row.get(0),name: row.get(1),address: row.get(2),local_address: row.get(3),local_subnet_mask: row.get(4),port: row.get(5),icon: row.get(6),flag: row.get(7),timezone: row.get(8),allowed_security_level: row.get(9),population: row.get(10),gamebuild: row.get(11),} }, mapper: |it| { <CreateRealm>::from(it) },
    }
} } impl <'a, C: GenericClient,T1: cornucopia_async::StringSql,> cornucopia_async::Params<'a,
CreateRealmParams<T1,>, CreateRealmQuery<'a, C,
CreateRealm, 5>, C> for CreateRealmStmt
{
    fn
    params(&'a mut self, client: &'a  C, params: &'a
    CreateRealmParams<T1,>) -> CreateRealmQuery<'a, C,
    CreateRealm, 5>
    { self.bind(client, &params.name,&params.address,&params.local_address,&params.local_subnet_mask,&params.port,) }
} pub fn set_uptime() -> SetUptimeStmt
{ SetUptimeStmt(cornucopia_async::private::Stmt::new("INSERT INTO uptime (realmid, starttime, uptime, maxplayers, revision)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (realmid)
DO UPDATE SET
    uptime = EXCLUDED.uptime,
    maxplayers = EXCLUDED.maxplayers")) } pub struct
SetUptimeStmt(cornucopia_async::private::Stmt); impl SetUptimeStmt
{  pub async fn bind<'a, C:
GenericClient,T1:
cornucopia_async::StringSql,>(&'a mut self, client: &'a  C,
id: &'a u32,start: &'a time::PrimitiveDateTime,uptime: &'a u32,maxplayers: &'a u16,version: &'a T1,) -> Result<u64, tokio_postgres::Error>
{
    let stmt = self.0.prepare(client).await?;
    client.execute(stmt, &[id,start,uptime,maxplayers,version,]).await
} } impl <'a, C: GenericClient + Send + Sync, T1: cornucopia_async::StringSql,>
cornucopia_async::Params<'a, SetUptimeParams<T1,>, std::pin::Pin<Box<dyn futures::Future<Output = Result<u64,
tokio_postgres::Error>> + Send + 'a>>, C> for SetUptimeStmt
{
    fn
    params(&'a mut self, client: &'a  C, params: &'a
    SetUptimeParams<T1,>) -> std::pin::Pin<Box<dyn futures::Future<Output = Result<u64,
    tokio_postgres::Error>> + Send + 'a>>
    { Box::pin(self.bind(client, &params.id,&params.start,&params.uptime,&params.maxplayers,&params.version,)) }
} }}
```

`crates/pg-auth/src/lib.rs`:

```rs
#![forbid(unsafe_code)]
#![deny(clippy::unwrap_used)]

mod accounts;
mod cornucopia;
mod realms;

pub use accounts::PgAccountService;
pub use realms::PgRealmList;

```

`crates/pg-auth/src/realms.rs`:

```rs
use std::{
    net::IpAddr,
    sync::Arc,
    time::{Duration, SystemTime},
};

use azerust_game::realms::{Realm, RealmFlags, RealmId, RealmList, RealmListError, RealmType};
use time::{OffsetDateTime, PrimitiveDateTime, UtcOffset};
use tokio::sync::RwLock;
use tracing::{debug, instrument, trace};

use crate::cornucopia::queries::realms;

#[derive(Clone)]
pub struct PgRealmList {
    next_update: Arc<RwLock<SystemTime>>,
    update_interval: Duration,
    pool: deadpool_postgres::Pool,
    realms: Arc<RwLock<Vec<Realm>>>,
}

impl PgRealmList {
    pub fn new(pool: deadpool_postgres::Pool, update_interval: Duration) -> Self {
        debug!("Starting realmlist service");
        Self {
            pool,
            update_interval,
            next_update: Arc::new(RwLock::new(SystemTime::now())),
            realms: Arc::new(RwLock::new(vec![])),
        }
    }
}

impl RealmList for PgRealmList {
    #[instrument(skip(self))]
    async fn realms(&self) -> Result<Vec<Realm>, RealmListError> {
        let now = SystemTime::now();
        if now > *self.next_update.read().await {
            debug!("Refreshing realm list");

            if let Ok(realms) = realms::refresh_realmlist()
                .bind(&self.pool.get().await.map_err(|e| RealmListError::PersistError(e.to_string()))?)
                .map(|realm| Realm {
                    id: RealmId(realm.id as u32),
                    build: realm.build,
                    external_address: realm.external_address.to_owned(),
                    local_address: realm.local_address.to_owned(),
                    local_subnet_mask: realm.local_subnet_mask.to_owned(),
                    name: realm.name.to_owned(),
                    flags: realm.flags,
                    port: realm.port,
                    population: realm.population,
                    realm_type: match realm.realm_type {
                        0 => RealmType::Normal,
                        1 => RealmType::PVP,
                        6 => RealmType::RP,
                        8 => RealmType::RPPvP,
                        _ => panic!(),
                    },
                    timezone: realm.timezone,
                })
                .all()
                .await
            {
                debug!(realms = realms.len(), "Refreshed realm list");
                let (mut self_realms, mut self_next_update) = futures::join!(self.realms.write(), self.next_update.write());
                *self_realms = realms;
                *self_next_update = now + self.update_interval;
            }
        };

        Ok(self.realms.read().await.clone())
    }

    #[instrument(skip(self))]
    async fn update_status(&self, online: Vec<(u8, RealmFlags)>) -> Result<(), RealmListError> {
        for (id, flag) in online {
            realms::update_realmlist_status()
                .bind(
                    &self.pool.get().await.map_err(|e| RealmListError::PersistError(e.to_string()))?,
                    &(flag as u8),
                    &id.into(),
                )
                .await
                .map_err(|e| RealmListError::PersistError(e.to_string()))?;
        }

        Ok(())
    }

    #[instrument(skip(self))]
    async fn set_uptime(&self, id: RealmId, start: OffsetDateTime, population: u16) -> Result<(), RealmListError> {
        let utc = start.to_offset(UtcOffset::UTC);
        let uptime = OffsetDateTime::now_utc() - start;

        let uptime_u32: u32 = uptime.whole_seconds().try_into().expect("server won't be up for 40 years");

        trace!("setting uptime for realm {:?} to {:?}", id, uptime);

        realms::set_uptime()
            .bind(
                &self.pool.get().await.map_err(|e| RealmListError::PersistError(e.to_string()))?,
                &id.0,
                &PrimitiveDateTime::new(utc.date(), utc.time()),
                &uptime_u32,
                &population,
                &"azerust-0.1.0",
            )
            .await
            .map_err(|e| RealmListError::PersistError(e.to_string()))?;

        Ok(())
    }

    #[instrument(skip(self))]
    async fn create_realm(&self, name: &str, address: &IpAddr, local_address: &IpAddr, local_subnet_mask: &IpAddr, port: u16) -> Result<Realm, RealmListError> {
        realms::create_realm()
            .bind(
                &mut self.pool.get().await.map_err(|e| RealmListError::PersistError(e.to_string()))?,
                &name,
                address,
                local_address,
                local_subnet_mask,
                &port,
            )
            .map(|r| Realm {
                id: RealmId(r.id as u32),
                build: r.gamebuild,
                external_address: r.address,
                local_address: r.local_address,
                local_subnet_mask: r.local_subnet_mask,
                flags: r.flag,
                timezone: r.timezone,
                name: r.name.to_owned(),
                population: r.population,
                port: r.port,
                realm_type: match r.icon {
                    0 => RealmType::Normal,
                    1 => RealmType::PVP,
                    6 => RealmType::RP,
                    8 => RealmType::RPPvP,
                    _ => panic!(),
                },
            })
            .one()
            .await
            .map_err(|e| RealmListError::PersistError(e.to_string()))
    }
}

```

`crates/pg-characters/Cargo.toml`:

```toml
[package]
name = "azerust-pg-characters"
version = "0.1.0"
authors = ["Alexander Lyon <arlyon@me.com>"]
edition = "2024"
license = "MIT OR Apache-2.0"

[dependencies]
tracing = "0.1"
async-trait = "0.1"
wow-srp = { path = "../wow-srp" }
azerust-game = { path = "../game" }
lazy_static = "1.4"
rand = "0.8"
sha-1 = "0.9"
tokio = "1"
cornucopia_async = "0.6.0"
tokio-postgres = { version = "0.7.12", features = ["with-time-0_3"] }
deadpool-postgres = "0.12.0"
postgres-types = "0.2.8"
time = "0.3.36"
futures = "0.3.31"

```

`crates/pg-characters/queries/character.sql`:

```sql
--! get_character_by_id
SELECT guid as id, account, name, level, race, class, gender, skin as skin_color, face, hair_style, hair_color, facial_style, zone, map, position_x, position_y, position_z FROM characters where guid = :guid;

--! get_character_by_name
SELECT guid as id, account, name, level, race, class, gender, skin as skin_color, face, hair_style, hair_color, facial_style, zone, map, position_x, position_y, position_z FROM characters where name = :name;

--! get_character_by_account
SELECT guid as id, account, name, level, race, class, gender, skin as skin_color, face, hair_style, hair_color, facial_style, zone, map, position_x, position_y, position_z FROM characters where account = :account;

--! count_by_account
SELECT count(*) as count FROM characters where account = :account;

--! name_available
SELECT count(*) = 0 as available FROM characters where name = :name;

--! insert_character
INSERT INTO characters
    (account, guid, level, name, race, class, gender, skin, face, hair_style, hair_color, facial_style, zone, map, position_x, position_y, position_z, taxi_mask, taxi_path, explored_zones, equipment_cache, known_titles)
values
    (:account, :guid, 1, :name, :race, :class, :gender, :skin, :face, :hair_style, :hair_color, :facial_style, :zone, :map, :position_x, :position_y, :position_z, '','', '', '', '')
returning
    guid;

--! delete_character
DELETE FROM characters where guid = :id;

--! account_data
SELECT type, time, data FROM account_data WHERE account_id = :id;

--! character_account_data
SELECT type, time, data FROM character_account_data WHERE guid = :id;

--! list_characters
SELECT guid as id, account, name, level, race, class, gender, skin as skin_color, face, hair_style, hair_color, facial_style, zone, map, position_x, position_y, position_z FROM characters;

--! get_friends
select friend, flags, note from character_social where guid = :id;

--! add_friend_by_name (note?)
INSERT INTO character_social (guid, friend, note) values (:id, :friend_id, :note);

```

`crates/pg-characters/schema.sql`:

```sql
CREATE EXTENSION uint;

CREATE TABLE account_data (
    account_id uint4 NOT NULL DEFAULT 0,
    type SMALLINT NOT NULL DEFAULT 0,
    time uint4 NOT NULL DEFAULT 0,
    data BYTEA NOT NULL,
    PRIMARY KEY (account_id, type)
);

CREATE TABLE account_instance_times (
    account_id INT NOT NULL,
    instance_id INT NOT NULL DEFAULT 0,
    release_time BIGINT NOT NULL DEFAULT 0,
    PRIMARY KEY (account_id, instance_id)
);

CREATE TABLE account_tutorial (
    account_id INT NOT NULL DEFAULT 0,
    tut0 INT NOT NULL DEFAULT 0,
    tut1 INT NOT NULL DEFAULT 0,
    tut2 INT NOT NULL DEFAULT 0,
    tut3 INT NOT NULL DEFAULT 0,
    tut4 INT NOT NULL DEFAULT 0,
    tut5 INT NOT NULL DEFAULT 0,
    tut6 INT NOT NULL DEFAULT 0,
    tut7 INT NOT NULL DEFAULT 0,
    PRIMARY KEY (account_id)
);

CREATE TABLE addons (
    name VARCHAR(120) NOT NULL DEFAULT '',
    crc INT NOT NULL DEFAULT 0,
    PRIMARY KEY (name)
);

CREATE TABLE arena_team (
    arena_team_id INT NOT NULL DEFAULT 0,
    name VARCHAR(24) NOT NULL,
    captain_guid INT NOT NULL DEFAULT 0,
    type SMALLINT NOT NULL DEFAULT 0,
    rating SMALLINT NOT NULL DEFAULT 0,
    season_games SMALLINT NOT NULL DEFAULT 0,
    season_wins SMALLINT NOT NULL DEFAULT 0,
    week_games SMALLINT NOT NULL DEFAULT 0,
    week_wins SMALLINT NOT NULL DEFAULT 0,
    rank INT NOT NULL DEFAULT 0,
    background_color INT NOT NULL DEFAULT 0,
    emblem_style SMALLINT NOT NULL DEFAULT 0,
    emblem_color INT NOT NULL DEFAULT 0,
    border_style SMALLINT NOT NULL DEFAULT 0,
    border_color INT NOT NULL DEFAULT 0,
    PRIMARY KEY (arena_team_id)
);

CREATE TABLE arena_team_member (
    arena_team_id INT NOT NULL DEFAULT 0,
    guid uint4 NOT NULL DEFAULT 0,
    week_games SMALLINT NOT NULL DEFAULT 0,
    week_wins SMALLINT NOT NULL DEFAULT 0,
    season_games SMALLINT NOT NULL DEFAULT 0,
    season_wins SMALLINT NOT NULL DEFAULT 0,
    personal_rating SMALLINT NOT NULL DEFAULT 0,
    PRIMARY KEY (arena_team_id, guid)
);

CREATE TABLE auctionbidders (
    id INT NOT NULL DEFAULT 0,
    bidder_guid INT NOT NULL DEFAULT 0,
    PRIMARY KEY (id, bidder_guid)
);

CREATE TABLE auctionhouse (
    id INT NOT NULL DEFAULT 0,
    house_id SMALLINT NOT NULL DEFAULT 7,
    item_guid INT NOT NULL DEFAULT 0,
    item_owner INT NOT NULL DEFAULT 0,
    buyout_price INT NOT NULL DEFAULT 0,
    time INT NOT NULL DEFAULT 0,
    buy_guid INT NOT NULL DEFAULT 0,
    last_bid INT NOT NULL DEFAULT 0,
    start_bid INT NOT NULL DEFAULT 0,
    deposit INT NOT NULL DEFAULT 0,
    flags SMALLINT NOT NULL DEFAULT 0,
    PRIMARY KEY (id),
    UNIQUE (item_guid)
);

CREATE TABLE banned_addons (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    version VARCHAR(255) NOT NULL DEFAULT '',
    timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE battleground_deserters (
    guid INT NOT NULL,
    type SMALLINT NOT NULL,
    datetime TIMESTAMP NOT NULL
);

CREATE TABLE bugreport (
    id SERIAL PRIMARY KEY,
    type TEXT NOT NULL,
    content TEXT NOT NULL
);

CREATE TABLE calendar_events (
    id BIGINT NOT NULL DEFAULT 0,
    creator INT NOT NULL DEFAULT 0,
    title VARCHAR(255) NOT NULL DEFAULT '',
    description VARCHAR(255) NOT NULL DEFAULT '',
    type SMALLINT NOT NULL DEFAULT 4,
    dungeon INT NOT NULL DEFAULT -1,
    event_time INT NOT NULL DEFAULT 0,
    flags INT NOT NULL DEFAULT 0,
    time2 INT NOT NULL DEFAULT 0,
    PRIMARY KEY (id)
);

CREATE TABLE calendar_invites (
    id BIGINT NOT NULL DEFAULT 0,
    event BIGINT NOT NULL DEFAULT 0,
    invitee INT NOT NULL DEFAULT 0,
    sender INT NOT NULL DEFAULT 0,
    status SMALLINT NOT NULL DEFAULT 0,
    status_time INT NOT NULL DEFAULT 0,
    rank SMALLINT NOT NULL DEFAULT 0,
    text VARCHAR(255) NOT NULL DEFAULT '',
    PRIMARY KEY (id)
);

CREATE TABLE channels (
    name VARCHAR(128) NOT NULL,
    team INT NOT NULL,
    announce SMALLINT NOT NULL DEFAULT 1,
    ownership SMALLINT NOT NULL DEFAULT 1,
    password VARCHAR(32),
    banned_list TEXT,
    last_used INT NOT NULL,
    PRIMARY KEY (name, team)
);

CREATE TABLE character_account_data (
    guid uint4 NOT NULL DEFAULT 0,
    type SMALLINT NOT NULL DEFAULT 0,
    time uint4 NOT NULL DEFAULT 0,
    data BYTEA NOT NULL,
    PRIMARY KEY (guid, type)
);

CREATE TABLE character_achievement (
    guid INT NOT NULL,
    achievement SMALLINT NOT NULL,
    date INT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid, achievement)
);

CREATE TABLE character_achievement_progress (
    guid INT NOT NULL,
    criteria SMALLINT NOT NULL,
    counter INT NOT NULL,
    date INT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid, criteria)
);

CREATE TABLE character_action (
    guid INT NOT NULL DEFAULT 0,
    spec SMALLINT NOT NULL DEFAULT 0,
    button SMALLINT NOT NULL DEFAULT 0,
    action INT NOT NULL DEFAULT 0,
    type SMALLINT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid, spec, button)
);

CREATE TABLE character_arena_stats (
    guid INT NOT NULL DEFAULT 0,
    slot SMALLINT NOT NULL DEFAULT 0,
    match_maker_rating SMALLINT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid, slot)
);

CREATE TABLE character_aura (
    guid INT NOT NULL DEFAULT 0,
    caster_guid BIGINT NOT NULL DEFAULT 0,
    item_guid BIGINT NOT NULL DEFAULT 0,
    spell INT NOT NULL DEFAULT 0,
    effect_mask SMALLINT NOT NULL DEFAULT 0,
    recalculate_mask SMALLINT NOT NULL DEFAULT 0,
    stack_count SMALLINT NOT NULL DEFAULT 1,
    amount0 INT NOT NULL DEFAULT 0,
    amount1 INT NOT NULL DEFAULT 0,
    amount2 INT NOT NULL DEFAULT 0,
    base_amount0 INT NOT NULL DEFAULT 0,
    base_amount1 INT NOT NULL DEFAULT 0,
    base_amount2 INT NOT NULL DEFAULT 0,
    max_duration INT NOT NULL DEFAULT 0,
    remain_time INT NOT NULL DEFAULT 0,
    remain_charges SMALLINT NOT NULL DEFAULT 0,
    crit_chance FLOAT NOT NULL DEFAULT 0,
    apply_resilience SMALLINT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid, caster_guid, item_guid, spell, effect_mask)
);

CREATE TABLE character_banned (
    guid INT NOT NULL DEFAULT 0,
    ban_date INT NOT NULL DEFAULT 0,
    unban_date INT NOT NULL DEFAULT 0,
    banned_by VARCHAR(50) NOT NULL,
    ban_reason VARCHAR(255) NOT NULL,
    active SMALLINT NOT NULL DEFAULT 1,
    PRIMARY KEY (guid, ban_date)
);

CREATE TABLE character_battleground_data (
    guid INT NOT NULL DEFAULT 0,
    instance_id INT NOT NULL,
    team SMALLINT NOT NULL,
    join_x FLOAT NOT NULL DEFAULT 0,
    join_y FLOAT NOT NULL DEFAULT 0,
    join_z FLOAT NOT NULL DEFAULT 0,
    join_o FLOAT NOT NULL DEFAULT 0,
    join_map_id SMALLINT NOT NULL DEFAULT 0,
    taxi_start INT NOT NULL DEFAULT 0,
    taxi_end INT NOT NULL DEFAULT 0,
    mount_spell INT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid)
);

CREATE TABLE character_battleground_random (guid INT NOT NULL DEFAULT 0, PRIMARY KEY (guid));

CREATE TABLE character_declinedname (
    guid INT NOT NULL DEFAULT 0,
    genitive VARCHAR(15) NOT NULL DEFAULT '',
    dative VARCHAR(15) NOT NULL DEFAULT '',
    accusative VARCHAR(15) NOT NULL DEFAULT '',
    instrumental VARCHAR(15) NOT NULL DEFAULT '',
    prepositional VARCHAR(15) NOT NULL DEFAULT '',
    PRIMARY KEY (guid)
);

CREATE TABLE character_equipmentsets (
    guid INT NOT NULL DEFAULT 0,
    set_guid BIGSERIAL PRIMARY KEY,
    set_index SMALLINT NOT NULL DEFAULT 0,
    name VARCHAR(31) NOT NULL,
    icon_name VARCHAR(100) NOT NULL,
    ignore_mask INT NOT NULL DEFAULT 0,
    item0 INT NOT NULL DEFAULT 0,
    item1 INT NOT NULL DEFAULT 0,
    item2 INT NOT NULL DEFAULT 0,
    item3 INT NOT NULL DEFAULT 0,
    item4 INT NOT NULL DEFAULT 0,
    item5 INT NOT NULL DEFAULT 0,
    item6 INT NOT NULL DEFAULT 0,
    item7 INT NOT NULL DEFAULT 0,
    item8 INT NOT NULL DEFAULT 0,
    item9 INT NOT NULL DEFAULT 0,
    item10 INT NOT NULL DEFAULT 0,
    item11 INT NOT NULL DEFAULT 0,
    item12 INT NOT NULL DEFAULT 0,
    item13 INT NOT NULL DEFAULT 0,
    item14 INT NOT NULL DEFAULT 0,
    item15 INT NOT NULL DEFAULT 0,
    item16 INT NOT NULL DEFAULT 0,
    item17 INT NOT NULL DEFAULT 0,
    item18 INT NOT NULL DEFAULT 0,
    UNIQUE (guid, set_guid, set_index)
);

CREATE TABLE character_fishingsteps (
    guid INT NOT NULL DEFAULT 0,
    fishing_steps SMALLINT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid)
);

CREATE TABLE character_gifts (
    guid INT NOT NULL DEFAULT 0,
    item_guid INT NOT NULL DEFAULT 0,
    entry INT NOT NULL DEFAULT 0,
    flags INT NOT NULL DEFAULT 0,
    PRIMARY KEY (item_guid)
);

CREATE TABLE character_glyphs (
    guid INT NOT NULL,
    talent_group SMALLINT NOT NULL DEFAULT 0,
    glyph1 SMALLINT DEFAULT 0,
    glyph2 SMALLINT DEFAULT 0,
    glyph3 SMALLINT DEFAULT 0,
    glyph4 SMALLINT DEFAULT 0,
    glyph5 SMALLINT DEFAULT 0,
    glyph6 SMALLINT DEFAULT 0,
    PRIMARY KEY (guid, talent_group)
);

CREATE TABLE character_homebind (
    guid INT NOT NULL DEFAULT 0,
    map_id SMALLINT NOT NULL DEFAULT 0,
    zone_id SMALLINT NOT NULL DEFAULT 0,
    pos_x FLOAT NOT NULL DEFAULT 0,
    pos_y FLOAT NOT NULL DEFAULT 0,
    pos_z FLOAT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid)
);

CREATE TABLE character_instance (
    guid INT NOT NULL DEFAULT 0,
    instance INT NOT NULL DEFAULT 0,
    permanent SMALLINT NOT NULL DEFAULT 0,
    extend_state SMALLINT NOT NULL DEFAULT 1,
    PRIMARY KEY (guid, instance)
);

CREATE TABLE character_inventory (
    guid INT NOT NULL DEFAULT 0,
    bag INT NOT NULL DEFAULT 0,
    slot SMALLINT NOT NULL DEFAULT 0,
    item INT NOT NULL DEFAULT 0,
    PRIMARY KEY (item),
    UNIQUE (guid, bag, slot)
);

CREATE TABLE character_pet (
    id INT NOT NULL DEFAULT 0,
    entry INT NOT NULL DEFAULT 0,
    owner INT NOT NULL DEFAULT 0,
    model_id INT DEFAULT 0,
    created_by_spell INT NOT NULL DEFAULT 0,
    pet_type SMALLINT NOT NULL DEFAULT 0,
    level SMALLINT NOT NULL DEFAULT 1,
    exp INT NOT NULL DEFAULT 0,
    react_state SMALLINT NOT NULL DEFAULT 0,
    name VARCHAR(21) NOT NULL DEFAULT 'Pet',
    renamed SMALLINT NOT NULL DEFAULT 0,
    slot SMALLINT NOT NULL DEFAULT 0,
    cur_health INT NOT NULL DEFAULT 1,
    cur_mana INT NOT NULL DEFAULT 0,
    cur_happiness INT NOT NULL DEFAULT 0,
    save_time INT NOT NULL DEFAULT 0,
    ab_data TEXT,
    PRIMARY KEY (id)
);

CREATE TABLE character_pet_declinedname (
    id INT NOT NULL DEFAULT 0,
    owner INT NOT NULL DEFAULT 0,
    genitive VARCHAR(12) NOT NULL DEFAULT '',
    dative VARCHAR(12) NOT NULL DEFAULT '',
    accusative VARCHAR(12) NOT NULL DEFAULT '',
    instrumental VARCHAR(12) NOT NULL DEFAULT '',
    prepositional VARCHAR(12) NOT NULL DEFAULT '',
    PRIMARY KEY (id)
);

CREATE TABLE character_queststatus (
    guid INT NOT NULL DEFAULT 0,
    quest INT NOT NULL DEFAULT 0,
    status SMALLINT NOT NULL DEFAULT 0,
    explored SMALLINT NOT NULL DEFAULT 0,
    timer INT NOT NULL DEFAULT 0,
    mob_count1 SMALLINT NOT NULL DEFAULT 0,
    mob_count2 SMALLINT NOT NULL DEFAULT 0,
    mob_count3 SMALLINT NOT NULL DEFAULT 0,
    mob_count4 SMALLINT NOT NULL DEFAULT 0,
    item_count1 SMALLINT NOT NULL DEFAULT 0,
    item_count2 SMALLINT NOT NULL DEFAULT 0,
    item_count3 SMALLINT NOT NULL DEFAULT 0,
    item_count4 SMALLINT NOT NULL DEFAULT 0,
    item_count5 SMALLINT NOT NULL DEFAULT 0,
    item_count6 SMALLINT NOT NULL DEFAULT 0,
    player_count SMALLINT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid, quest)
);

CREATE TABLE character_queststatus_daily (
    guid INT NOT NULL DEFAULT 0,
    quest INT NOT NULL DEFAULT 0,
    time INT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid, quest)
);

CREATE TABLE character_queststatus_monthly (
    guid INT NOT NULL DEFAULT 0,
    quest INT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid, quest)
);

CREATE TABLE character_queststatus_rewarded (
    guid INT NOT NULL DEFAULT 0,
    quest INT NOT NULL DEFAULT 0,
    active SMALLINT NOT NULL DEFAULT 1,
    PRIMARY KEY (guid, quest)
);

CREATE TABLE character_queststatus_seasonal (
    guid INT NOT NULL DEFAULT 0,
    quest INT NOT NULL DEFAULT 0,
    event INT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid, quest)
);

CREATE TABLE character_queststatus_weekly (
    guid INT NOT NULL DEFAULT 0,
    quest INT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid, quest)
);

CREATE TABLE character_reputation (
    guid INT NOT NULL DEFAULT 0,
    faction SMALLINT NOT NULL DEFAULT 0,
    standing INT NOT NULL DEFAULT 0,
    flags SMALLINT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid, faction)
);

CREATE TABLE character_skills (
    guid INT NOT NULL,
    skill SMALLINT NOT NULL,
    value SMALLINT NOT NULL,
    max SMALLINT NOT NULL,
    PRIMARY KEY (guid, skill)
);

CREATE TABLE character_social (
    guid uint4 NOT NULL DEFAULT 0,
    friend uint4 NOT NULL DEFAULT 0,
    flags uint4 NOT NULL DEFAULT 0,
    note VARCHAR(48) NOT NULL DEFAULT '',
    PRIMARY KEY (guid, friend, flags)
);

CREATE TABLE character_spell (
    guid INT NOT NULL DEFAULT 0,
    spell INT NOT NULL DEFAULT 0,
    active SMALLINT NOT NULL DEFAULT 1,
    disabled SMALLINT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid, spell)
);

CREATE TABLE character_spell_cooldown (
    guid INT NOT NULL DEFAULT 0,
    spell INT NOT NULL DEFAULT 0,
    item INT NOT NULL DEFAULT 0,
    time INT NOT NULL DEFAULT 0,
    category_id INT NOT NULL DEFAULT 0,
    category_end INT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid, spell)
);

CREATE TABLE character_stats (
    guid INT NOT NULL DEFAULT 0,
    max_health INT NOT NULL DEFAULT 0,
    max_power1 INT NOT NULL DEFAULT 0,
    max_power2 INT NOT NULL DEFAULT 0,
    max_power3 INT NOT NULL DEFAULT 0,
    max_power4 INT NOT NULL DEFAULT 0,
    max_power5 INT NOT NULL DEFAULT 0,
    max_power6 INT NOT NULL DEFAULT 0,
    max_power7 INT NOT NULL DEFAULT 0,
    strength INT NOT NULL DEFAULT 0,
    agility INT NOT NULL DEFAULT 0,
    stamina INT NOT NULL DEFAULT 0,
    intellect INT NOT NULL DEFAULT 0,
    spirit INT NOT NULL DEFAULT 0,
    armor INT NOT NULL DEFAULT 0,
    res_holy INT NOT NULL DEFAULT 0,
    res_fire INT NOT NULL DEFAULT 0,
    res_nature INT NOT NULL DEFAULT 0,
    res_frost INT NOT NULL DEFAULT 0,
    res_shadow INT NOT NULL DEFAULT 0,
    res_arcane INT NOT NULL DEFAULT 0,
    block_pct FLOAT NOT NULL DEFAULT 0,
    dodge_pct FLOAT NOT NULL DEFAULT 0,
    parry_pct FLOAT NOT NULL DEFAULT 0,
    crit_pct FLOAT NOT NULL DEFAULT 0,
    ranged_crit_pct FLOAT NOT NULL DEFAULT 0,
    spell_crit_pct FLOAT NOT NULL DEFAULT 0,
    attack_power INT NOT NULL DEFAULT 0,
    ranged_attack_power INT NOT NULL DEFAULT 0,
    spell_power INT NOT NULL DEFAULT 0,
    resilience INT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid)
);

CREATE TABLE character_talent (
    guid INT NOT NULL,
    spell INT NOT NULL,
    talent_group SMALLINT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid, spell, talent_group)
);

CREATE TABLE characters (
    guid uint4 NOT NULL DEFAULT 0,
    account uint4 NOT NULL DEFAULT 0,
    name VARCHAR(12),
    race uint1 NOT NULL DEFAULT 0,
    class uint1 NOT NULL DEFAULT 0,
    gender uint1 NOT NULL DEFAULT 0,
    level uint1 NOT NULL DEFAULT 0,
    xp INT NOT NULL DEFAULT 0,
    money INT NOT NULL DEFAULT 0,
    skin uint1 NOT NULL DEFAULT 0,
    face uint1 NOT NULL DEFAULT 0,
    hair_style uint1 NOT NULL DEFAULT 0,
    hair_color uint1 NOT NULL DEFAULT 0,
    facial_style uint1 NOT NULL DEFAULT 0,
    bank_slots SMALLINT NOT NULL DEFAULT 0,
    rest_state SMALLINT NOT NULL DEFAULT 0,
    player_flags INT NOT NULL DEFAULT 0,
    position_x REAL NOT NULL DEFAULT 0,
    position_y REAL NOT NULL DEFAULT 0,
    position_z REAL NOT NULL DEFAULT 0,
    map uint2 NOT NULL DEFAULT 0,
    instance_id INT NOT NULL DEFAULT 0,
    instance_mode_mask SMALLINT NOT NULL DEFAULT 0,
    orientation FLOAT NOT NULL DEFAULT 0,
    taxi_mask TEXT NOT NULL,
    online bool NOT NULL DEFAULT false,
    cinematic SMALLINT NOT NULL DEFAULT 0,
    total_time INT NOT NULL DEFAULT 0,
    level_time INT NOT NULL DEFAULT 0,
    logout_time INT NOT NULL DEFAULT 0,
    is_logout_resting SMALLINT NOT NULL DEFAULT 0,
    rest_bonus FLOAT NOT NULL DEFAULT 0,
    reset_talents_cost INT NOT NULL DEFAULT 0,
    reset_talents_time INT NOT NULL DEFAULT 0,
    trans_x FLOAT NOT NULL DEFAULT 0,
    trans_y FLOAT NOT NULL DEFAULT 0,
    trans_z FLOAT NOT NULL DEFAULT 0,
    trans_o FLOAT NOT NULL DEFAULT 0,
    trans_guid INT NOT NULL DEFAULT 0,
    extra_flags SMALLINT NOT NULL DEFAULT 0,
    stable_slots SMALLINT NOT NULL DEFAULT 0,
    at_login SMALLINT NOT NULL DEFAULT 0,
    zone uint2 NOT NULL DEFAULT 0,
    death_expire_time INT NOT NULL DEFAULT 0,
    taxi_path TEXT,
    arena_points INT NOT NULL DEFAULT 0,
    total_honor_points INT NOT NULL DEFAULT 0,
    today_honor_points INT NOT NULL DEFAULT 0,
    yesterday_honor_points INT NOT NULL DEFAULT 0,
    total_kills INT NOT NULL DEFAULT 0,
    today_kills SMALLINT NOT NULL DEFAULT 0,
    yesterday_kills SMALLINT NOT NULL DEFAULT 0,
    chosen_title INT NOT NULL DEFAULT 0,
    known_currencies BIGINT NOT NULL DEFAULT 0,
    watched_faction INT NOT NULL DEFAULT 0,
    drunk SMALLINT NOT NULL DEFAULT 0,
    health INT NOT NULL DEFAULT 0,
    power1 INT NOT NULL DEFAULT 0,
    power2 INT NOT NULL DEFAULT 0,
    power3 INT NOT NULL DEFAULT 0,
    power4 INT NOT NULL DEFAULT 0,
    power5 INT NOT NULL DEFAULT 0,
    power6 INT NOT NULL DEFAULT 0,
    power7 INT NOT NULL DEFAULT 0,
    latency INT NOT NULL DEFAULT 0,
    talent_groups_count SMALLINT NOT NULL DEFAULT 1,
    active_talent_group SMALLINT NOT NULL DEFAULT 0,
    explored_zones TEXT,
    equipment_cache TEXT,
    ammo_id INT NOT NULL DEFAULT 0,
    known_titles TEXT,
    action_bars SMALLINT NOT NULL DEFAULT 0,
    grantable_levels SMALLINT NOT NULL DEFAULT 0,
    delete_infos_account INT,
    delete_infos_name VARCHAR(12),
    delete_date INT,
    PRIMARY KEY (guid),
    UNIQUE (name)
);

CREATE TABLE corpse (
    guid INT NOT NULL DEFAULT 0,
    pos_x FLOAT NOT NULL DEFAULT 0,
    pos_y FLOAT NOT NULL DEFAULT 0,
    pos_z FLOAT NOT NULL DEFAULT 0,
    orientation FLOAT NOT NULL DEFAULT 0,
    map_id SMALLINT NOT NULL DEFAULT 0,
    phase_mask INT NOT NULL DEFAULT 1,
    display_id INT NOT NULL DEFAULT 0,
    item_cache TEXT NOT NULL,
    bytes1 INT NOT NULL DEFAULT 0,
    bytes2 INT NOT NULL DEFAULT 0,
    guild_id INT NOT NULL DEFAULT 0,
    flags SMALLINT NOT NULL DEFAULT 0,
    dyn_flags SMALLINT NOT NULL DEFAULT 0,
    time INT NOT NULL DEFAULT 0,
    corpse_type SMALLINT NOT NULL DEFAULT 0,
    instance_id INT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid)
);

CREATE TABLE game_event_condition_save (
    event_entry SMALLINT NOT NULL,
    condition_id INT NOT NULL DEFAULT 0,
    done FLOAT DEFAULT 0,
    PRIMARY KEY (event_entry, condition_id)
);

CREATE TABLE game_event_save (
    event_entry SMALLINT NOT NULL,
    state SMALLINT NOT NULL DEFAULT 1,
    next_start INT NOT NULL DEFAULT 0,
    PRIMARY KEY (event_entry)
);

CREATE TABLE gm_subsurvey (
    survey_id SERIAL,
    question_id INT NOT NULL DEFAULT 0,
    answer INT NOT NULL DEFAULT 0,
    answer_comment TEXT NOT NULL,
    PRIMARY KEY (survey_id, question_id)
);

CREATE TABLE gm_survey (
    survey_id SERIAL PRIMARY KEY,
    guid INT NOT NULL DEFAULT 0,
    main_survey INT NOT NULL DEFAULT 0,
    comment TEXT NOT NULL,
    create_time INT NOT NULL DEFAULT 0
);

CREATE TABLE gm_ticket (
    id SERIAL PRIMARY KEY,
    type SMALLINT NOT NULL DEFAULT 0,
    player_guid INT NOT NULL DEFAULT 0,
    name VARCHAR(12) NOT NULL,
    description TEXT NOT NULL,
    create_time INT NOT NULL DEFAULT 0,
    map_id SMALLINT NOT NULL DEFAULT 0,
    pos_x FLOAT NOT NULL DEFAULT 0,
    pos_y FLOAT NOT NULL DEFAULT 0,
    pos_z FLOAT NOT NULL DEFAULT 0,
    last_modified_time INT NOT NULL DEFAULT 0,
    closed_by INT NOT NULL DEFAULT 0,
    assigned_to INT NOT NULL DEFAULT 0,
    comment TEXT NOT NULL,
    response TEXT NOT NULL,
    completed SMALLINT NOT NULL DEFAULT 0,
    escalated SMALLINT NOT NULL DEFAULT 0,
    viewed SMALLINT NOT NULL DEFAULT 0,
    need_more_help SMALLINT NOT NULL DEFAULT 0,
    resolved_by INT NOT NULL DEFAULT 0
);

CREATE TABLE group_instance (
    guid INT NOT NULL DEFAULT 0,
    instance INT NOT NULL DEFAULT 0,
    permanent SMALLINT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid, instance)
);

CREATE TABLE group_member (
    guid INT NOT NULL,
    member_guid INT NOT NULL,
    member_flags SMALLINT NOT NULL DEFAULT 0,
    subgroup SMALLINT NOT NULL DEFAULT 0,
    roles SMALLINT NOT NULL DEFAULT 0,
    PRIMARY KEY (member_guid)
);

CREATE TABLE groups (
    guid INT NOT NULL,
    leader_guid INT NOT NULL,
    loot_method SMALLINT NOT NULL,
    looter_guid INT NOT NULL,
    loot_threshold SMALLINT NOT NULL,
    icon1 BIGINT NOT NULL,
    icon2 BIGINT NOT NULL,
    icon3 BIGINT NOT NULL,
    icon4 BIGINT NOT NULL,
    icon5 BIGINT NOT NULL,
    icon6 BIGINT NOT NULL,
    icon7 BIGINT NOT NULL,
    icon8 BIGINT NOT NULL,
    group_type SMALLINT NOT NULL,
    difficulty SMALLINT NOT NULL DEFAULT 0,
    raid_difficulty SMALLINT NOT NULL DEFAULT 0,
    master_looter_guid INT NOT NULL,
    PRIMARY KEY (guid)
);

CREATE TABLE guild (
    guild_id INT NOT NULL DEFAULT 0,
    name VARCHAR(24) NOT NULL DEFAULT '',
    leader_guid INT NOT NULL DEFAULT 0,
    emblem_style SMALLINT NOT NULL DEFAULT 0,
    emblem_color SMALLINT NOT NULL DEFAULT 0,
    border_style SMALLINT NOT NULL DEFAULT 0,
    border_color SMALLINT NOT NULL DEFAULT 0,
    background_color SMALLINT NOT NULL DEFAULT 0,
    info VARCHAR(500) NOT NULL DEFAULT '',
    motd VARCHAR(128) NOT NULL DEFAULT '',
    create_date INT NOT NULL DEFAULT 0,
    bank_money BIGINT NOT NULL DEFAULT 0,
    PRIMARY KEY (guild_id)
);

CREATE TABLE guild_bank_eventlog (
    guild_id INT NOT NULL DEFAULT 0,
    log_guid INT NOT NULL DEFAULT 0,
    tab_id SMALLINT NOT NULL DEFAULT 0,
    event_type SMALLINT NOT NULL DEFAULT 0,
    player_guid INT NOT NULL DEFAULT 0,
    item_or_money INT NOT NULL DEFAULT 0,
    item_stack_count SMALLINT NOT NULL DEFAULT 0,
    dest_tab_id SMALLINT NOT NULL DEFAULT 0,
    timestamp INT NOT NULL DEFAULT 0,
    PRIMARY KEY (guild_id, log_guid, tab_id)
);

CREATE TABLE guild_bank_item (
    guild_id INT NOT NULL DEFAULT 0,
    tab_id SMALLINT NOT NULL DEFAULT 0,
    slot_id SMALLINT NOT NULL DEFAULT 0,
    item_guid INT NOT NULL DEFAULT 0,
    PRIMARY KEY (guild_id, tab_id, slot_id)
);

CREATE TABLE guild_bank_right (
    guild_id INT NOT NULL DEFAULT 0,
    tab_id SMALLINT NOT NULL DEFAULT 0,
    rid SMALLINT NOT NULL DEFAULT 0,
    gb_right SMALLINT NOT NULL DEFAULT 0,
    slot_per_day INT NOT NULL DEFAULT 0,
    PRIMARY KEY (guild_id, tab_id, rid)
);

CREATE TABLE guild_bank_tab (
    guild_id INT NOT NULL DEFAULT 0,
    tab_id SMALLINT NOT NULL DEFAULT 0,
    tab_name VARCHAR(16) NOT NULL DEFAULT '',
    tab_icon VARCHAR(100) NOT NULL DEFAULT '',
    tab_text VARCHAR(500),
    PRIMARY KEY (guild_id, tab_id)
);

CREATE TABLE guild_eventlog (
    guild_id INT NOT NULL,
    log_guid INT NOT NULL,
    event_type SMALLINT NOT NULL,
    player_guid1 INT NOT NULL,
    player_guid2 INT NOT NULL,
    new_rank SMALLINT NOT NULL,
    timestamp INT NOT NULL
);

CREATE TABLE guild_member (
    guild_id INT NOT NULL,
    guid INT NOT NULL,
    rank SMALLINT NOT NULL,
    pnote VARCHAR(31) NOT NULL DEFAULT '',
    offnote VARCHAR(31) NOT NULL DEFAULT '',
    UNIQUE (guid)
);

CREATE TABLE guild_member_withdraw (
    guid INT NOT NULL,
    tab0 INT NOT NULL DEFAULT 0,
    tab1 INT NOT NULL DEFAULT 0,
    tab2 INT NOT NULL DEFAULT 0,
    tab3 INT NOT NULL DEFAULT 0,
    tab4 INT NOT NULL DEFAULT 0,
    tab5 INT NOT NULL DEFAULT 0,
    money INT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid)
);

CREATE TABLE guild_rank (
    guild_id INT NOT NULL DEFAULT 0,
    rid SMALLINT NOT NULL,
    rname VARCHAR(20) NOT NULL DEFAULT '',
    rights INT NOT NULL DEFAULT 0,
    bank_money_per_day INT NOT NULL DEFAULT 0,
    PRIMARY KEY (guild_id, rid)
);

CREATE TABLE instance (
    id INT NOT NULL DEFAULT 0,
    map SMALLINT NOT NULL DEFAULT 0,
    reset_time BIGINT NOT NULL DEFAULT 0,
    difficulty SMALLINT NOT NULL DEFAULT 0,
    completed_encounters INT NOT NULL DEFAULT 0,
    data TEXT NOT NULL,
    PRIMARY KEY (id)
);

CREATE TABLE instance_reset (
    map_id SMALLINT NOT NULL DEFAULT 0,
    difficulty SMALLINT NOT NULL DEFAULT 0,
    reset_time BIGINT NOT NULL DEFAULT 0,
    PRIMARY KEY (map_id, difficulty)
);

CREATE TABLE item_instance (
    guid INT NOT NULL DEFAULT 0,
    item_entry SMALLINT NOT NULL DEFAULT 0,
    owner_guid INT NOT NULL DEFAULT 0,
    creator_guid INT NOT NULL DEFAULT 0,
    gift_creator_guid INT NOT NULL DEFAULT 0,
    count INT NOT NULL DEFAULT 1,
    duration INT NOT NULL DEFAULT 0,
    charges TEXT,
    flags INT NOT NULL DEFAULT 0,
    enchantments TEXT NOT NULL,
    random_property_id SMALLINT NOT NULL DEFAULT 0,
    durability SMALLINT NOT NULL DEFAULT 0,
    played_time INT NOT NULL DEFAULT 0,
    text TEXT,
    PRIMARY KEY (guid)
);

CREATE TABLE item_loot_items (
    container_id INT NOT NULL DEFAULT 0,
    item_id INT NOT NULL DEFAULT 0,
    item_count INT NOT NULL DEFAULT 0,
    item_index INT NOT NULL DEFAULT 0,
    follow_rules SMALLINT NOT NULL DEFAULT 0,
    ffa SMALLINT NOT NULL DEFAULT 0,
    blocked SMALLINT NOT NULL DEFAULT 0,
    counted SMALLINT NOT NULL DEFAULT 0,
    under_threshold SMALLINT NOT NULL DEFAULT 0,
    needs_quest SMALLINT NOT NULL DEFAULT 0,
    rnd_prop INT NOT NULL DEFAULT 0,
    rnd_suffix INT NOT NULL DEFAULT 0,
    PRIMARY KEY (container_id, item_id)
);

CREATE TABLE item_loot_money (
    container_id INT NOT NULL DEFAULT 0,
    money INT NOT NULL DEFAULT 0,
    PRIMARY KEY (container_id)
);

CREATE TABLE item_refund_instance (
    item_guid INT NOT NULL,
    player_guid INT NOT NULL,
    paid_money INT NOT NULL DEFAULT 0,
    paid_extended_cost SMALLINT NOT NULL DEFAULT 0,
    PRIMARY KEY (item_guid, player_guid)
);

CREATE TABLE item_soulbound_trade_data (
    item_guid INT NOT NULL,
    allowed_players TEXT NOT NULL,
    PRIMARY KEY (item_guid)
);

CREATE TABLE lag_reports (
    report_id SERIAL PRIMARY KEY,
    guid INT NOT NULL DEFAULT 0,
    lag_type SMALLINT NOT NULL DEFAULT 0,
    map_id SMALLINT NOT NULL DEFAULT 0,
    pos_x FLOAT NOT NULL DEFAULT 0,
    pos_y FLOAT NOT NULL DEFAULT 0,
    pos_z FLOAT NOT NULL DEFAULT 0,
    latency INT NOT NULL DEFAULT 0,
    create_time INT NOT NULL DEFAULT 0
);

CREATE TABLE lfg_data (
    guid INT NOT NULL DEFAULT 0,
    dungeon INT NOT NULL DEFAULT 0,
    state SMALLINT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid)
);

CREATE TABLE mail (
    id INT NOT NULL DEFAULT 0,
    message_type SMALLINT NOT NULL DEFAULT 0,
    stationery SMALLINT NOT NULL DEFAULT 41,
    mail_template_id SMALLINT NOT NULL DEFAULT 0,
    sender INT NOT NULL DEFAULT 0,
    receiver INT NOT NULL DEFAULT 0,
    subject TEXT,
    body TEXT,
    has_items SMALLINT NOT NULL DEFAULT 0,
    expire_time INT NOT NULL DEFAULT 0,
    deliver_time INT NOT NULL DEFAULT 0,
    money INT NOT NULL DEFAULT 0,
    cod INT NOT NULL DEFAULT 0,
    checked SMALLINT NOT NULL DEFAULT 0,
    PRIMARY KEY (id)
);

CREATE TABLE mail_items (
    mail_id INT NOT NULL DEFAULT 0,
    item_guid INT NOT NULL DEFAULT 0,
    receiver INT NOT NULL DEFAULT 0,
    PRIMARY KEY (item_guid)
);

CREATE TABLE pet_aura (
    guid INT NOT NULL DEFAULT 0,
    caster_guid BIGINT NOT NULL DEFAULT 0,
    spell INT NOT NULL DEFAULT 0,
    effect_mask SMALLINT NOT NULL DEFAULT 0,
    recalculate_mask SMALLINT NOT NULL DEFAULT 0,
    stack_count SMALLINT NOT NULL DEFAULT 1,
    amount0 INT NOT NULL,
    amount1 INT NOT NULL,
    amount2 INT NOT NULL,
    base_amount0 INT NOT NULL,
    base_amount1 INT NOT NULL,
    base_amount2 INT NOT NULL,
    max_duration INT NOT NULL DEFAULT 0,
    remain_time INT NOT NULL DEFAULT 0,
    remain_charges SMALLINT NOT NULL DEFAULT 0,
    crit_chance FLOAT NOT NULL DEFAULT 0,
    apply_resilience SMALLINT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid, caster_guid, spell, effect_mask)
);

CREATE TABLE pet_spell (
    guid INT NOT NULL DEFAULT 0,
    spell INT NOT NULL DEFAULT 0,
    active SMALLINT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid, spell)
);

CREATE TABLE pet_spell_cooldown (
    guid INT NOT NULL DEFAULT 0,
    spell INT NOT NULL DEFAULT 0,
    time INT NOT NULL DEFAULT 0,
    category_id INT NOT NULL DEFAULT 0,
    category_end INT NOT NULL DEFAULT 0,
    PRIMARY KEY (guid, spell)
);

CREATE TABLE petition (
    owner_guid INT NOT NULL,
    petition_guid INT DEFAULT 0,
    name VARCHAR(24) NOT NULL,
    type SMALLINT NOT NULL DEFAULT 0,
    PRIMARY KEY (owner_guid, type),
    UNIQUE (owner_guid, petition_guid)
);

CREATE TABLE petition_sign (
    owner_guid INT NOT NULL,
    petition_guid INT NOT NULL DEFAULT 0,
    player_guid INT NOT NULL DEFAULT 0,
    player_account INT NOT NULL DEFAULT 0,
    type SMALLINT NOT NULL DEFAULT 0,
    PRIMARY KEY (petition_guid, player_guid)
);

CREATE TABLE pool_quest_save (
    pool_id INT NOT NULL DEFAULT 0,
    quest_id INT NOT NULL DEFAULT 0,
    PRIMARY KEY (pool_id, quest_id)
);

CREATE TABLE pvpstats_battlegrounds (
    id BIGSERIAL PRIMARY KEY,
    winner_faction SMALLINT NOT NULL,
    bracket_id SMALLINT NOT NULL,
    type SMALLINT NOT NULL,
    date TIMESTAMP NOT NULL
);

CREATE TABLE pvpstats_players (
    battleground_id BIGINT NOT NULL,
    character_guid INT NOT NULL,
    winner BOOLEAN NOT NULL,
    score_killing_blows SMALLINT NOT NULL,
    score_deaths SMALLINT NOT NULL,
    score_honorable_kills SMALLINT NOT NULL,
    score_bonus_honor SMALLINT NOT NULL,
    score_damage_done INT NOT NULL,
    score_healing_done INT NOT NULL,
    attr_1 INT NOT NULL DEFAULT 0,
    attr_2 INT NOT NULL DEFAULT 0,
    attr_3 INT NOT NULL DEFAULT 0,
    attr_4 INT NOT NULL DEFAULT 0,
    attr_5 INT NOT NULL DEFAULT 0,
    PRIMARY KEY (battleground_id, character_guid)
);

CREATE TABLE quest_tracker (
    id SMALLINT NOT NULL DEFAULT 0,
    character_guid INT NOT NULL DEFAULT 0,
    quest_accept_time TIMESTAMP NOT NULL,
    quest_complete_time TIMESTAMP DEFAULT NULL,
    quest_abandon_time TIMESTAMP DEFAULT NULL,
    completed_by_gm SMALLINT NOT NULL DEFAULT 0,
    core_hash VARCHAR(120) NOT NULL DEFAULT '0',
    core_revision VARCHAR(120) NOT NULL DEFAULT '0'
);

CREATE TABLE reserved_name (name VARCHAR(12) NOT NULL, PRIMARY KEY (name));

CREATE TABLE respawn (
    type SMALLINT NOT NULL,
    spawn_id INT NOT NULL,
    respawn_time BIGINT NOT NULL,
    map_id SMALLINT NOT NULL,
    instance_id INT NOT NULL,
    PRIMARY KEY (type, spawn_id, instance_id)
);

CREATE TABLE updates (
    name VARCHAR(200) NOT NULL,
    hash CHAR(40) DEFAULT '',
    state TEXT NOT NULL DEFAULT 'RELEASED',
    timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    speed INT NOT NULL DEFAULT 0,
    PRIMARY KEY (name)
);

CREATE TABLE updates_include (
    path VARCHAR(200) NOT NULL,
    state TEXT NOT NULL DEFAULT 'RELEASED',
    PRIMARY KEY (path)
);

CREATE TABLE warden_action (
    warden_id SMALLINT NOT NULL,
    action SMALLINT DEFAULT NULL,
    PRIMARY KEY (warden_id)
);

CREATE TABLE worldstates (
    entry INT NOT NULL DEFAULT 0,
    value INT NOT NULL DEFAULT 0,
    comment TEXT,
    PRIMARY KEY (entry)
);

```

`crates/pg-characters/src/characters.rs`:

```rs
use azerust_game::{
    EntityType,
    accounts::AccountId,
    characters::{AccountDataCache, Character, CharacterCreate, CharacterId, CharacterService, CharacterServiceError},
    new_guid,
};
use rand::Rng;
use tracing::{debug, instrument};

use crate::cornucopia::queries::character;

#[derive(Clone)]
pub struct PgCharacterService {
    pool: deadpool_postgres::Pool,
}

impl PgCharacterService {
    pub fn new(pool: deadpool_postgres::Pool) -> Self {
        debug!("Starting character service");
        Self { pool }
    }
}

impl CharacterService for PgCharacterService {
    async fn get(&self, id: CharacterId) -> Result<Option<Character>, CharacterServiceError> {
        character::get_character_by_id()
            .bind(&self.pool.get().await.unwrap(), &id.0)
            .map(|c| Character {
                id: CharacterId(c.id),
                account: AccountId(c.account),
                class: c.class.try_into().unwrap(),
                face: c.face.try_into().unwrap(),
                facial_style: c.facial_style.try_into().unwrap(),
                gender: c.gender.try_into().unwrap(),
                hair_color: c.hair_color.try_into().unwrap(),
                hair_style: c.hair_style.try_into().unwrap(),
                level: c.level.into(),
                map: c.map.try_into().unwrap(),
                name: c.name.to_owned(),
                position_x: c.position_x,
                position_y: c.position_y,
                position_z: c.position_z,
                race: c.race.try_into().unwrap(),
                skin_color: c.skin_color.try_into().unwrap(),
                zone: c.zone.try_into().unwrap(),
            })
            .opt()
            .await
            .map_err(|e| CharacterServiceError::PersistError(e.to_string()))
    }

    async fn get_by_name(&self, name: &str) -> Result<Option<Character>, CharacterServiceError> {
        character::get_character_by_name()
            .bind(&self.pool.get().await.unwrap(), &name)
            .map(|c| Character {
                id: CharacterId(c.id),
                account: AccountId(c.account),
                class: c.class.try_into().unwrap(),
                face: c.face.try_into().unwrap(),
                facial_style: c.facial_style.try_into().unwrap(),
                gender: c.gender.try_into().unwrap(),
                hair_color: c.hair_color.try_into().unwrap(),
                hair_style: c.hair_style.try_into().unwrap(),
                level: c.level.into(),
                map: c.map.try_into().unwrap(),
                name: c.name.to_owned(),
                position_x: c.position_x,
                position_y: c.position_y,
                position_z: c.position_z,
                race: c.race.try_into().unwrap(),
                skin_color: c.skin_color.try_into().unwrap(),
                zone: c.zone.try_into().unwrap(),
            })
            .opt()
            .await
            .map_err(|e| CharacterServiceError::PersistError(e.to_string()))
    }

    async fn get_friends(&self, id: CharacterId) -> Result<Vec<(CharacterId, u32, String)>, CharacterServiceError> {
        character::get_friends()
            .bind(&self.pool.get().await.unwrap(), &id.0)
            .map(|r| (CharacterId(r.friend), r.flags, r.note.to_owned()))
            .all()
            .await
            .map_err(|e| CharacterServiceError::PersistError(e.to_string()))
    }

    async fn add_friend_by_name(&self, id: CharacterId, name: &str, note: Option<&str>) -> Result<Option<CharacterId>, CharacterServiceError> {
        let Some(other) = self.get_by_name(name).await.unwrap() else {
            return Ok(None);
        };

        character::add_friend_by_name()
            .bind(&self.pool.get().await.unwrap(), &id.0, &other.id.0, &note)
            .await
            .map_err(|e| CharacterServiceError::PersistError(e.to_string()))
            .and(Ok(Some(other.id)))
    }

    #[instrument(skip(self))]
    async fn get_by_account(&self, id: AccountId) -> Result<Vec<Character>, CharacterServiceError> {
        character::get_character_by_account()
            .bind(&self.pool.get().await.unwrap(), &id.0)
            .map(|c| Character {
                id: CharacterId(c.id),
                account: AccountId(c.account),
                class: c.class.try_into().unwrap(),
                face: c.face.try_into().unwrap(),
                facial_style: c.facial_style.try_into().unwrap(),
                gender: c.gender.try_into().unwrap(),
                hair_color: c.hair_color.try_into().unwrap(),
                hair_style: c.hair_style.try_into().unwrap(),
                level: c.level.into(),
                map: c.map.try_into().unwrap(),
                name: c.name.to_owned(),
                position_x: c.position_x,
                position_y: c.position_y,
                position_z: c.position_z,
                race: c.race.try_into().unwrap(),
                skin_color: c.skin_color.try_into().unwrap(),
                zone: c.zone.try_into().unwrap(),
            })
            .all()
            .await
            .map_err(|e| CharacterServiceError::PersistError(e.to_string()))
    }

    async fn count_by_account(&self, id: AccountId) -> Result<usize, CharacterServiceError> {
        character::count_by_account()
            .bind(&self.pool.get().await.unwrap(), &id.0)
            .one()
            .await
            .map(|c| c as usize)
            .map_err(|e| CharacterServiceError::PersistError(e.to_string()))
    }

    async fn name_available(&self, name: &str) -> Result<bool, CharacterServiceError> {
        let avaialble = character::name_available()
            .bind(&self.pool.get().await.unwrap(), &name)
            .one()
            .await
            .map_err(|e| CharacterServiceError::PersistError(e.to_string()))?;

        tracing::trace!("name available: {avaialble}");
        Ok(avaialble)
    }

    #[instrument(skip(self))]
    async fn create_character(&self, account: AccountId, create: CharacterCreate) -> Result<CharacterId, CharacterServiceError> {
        let CharacterCreate {
            name,
            race,
            class,
            gender,
            face,
            facial_style,
            hair_color,
            hair_style,
            map,
            position_x,
            position_y,
            position_z,
            skin_color,
            zone,
        } = create;
        let id = {
            let mut rng = rand::thread_rng();
            new_guid(EntityType::Player, rng.r#gen(), 0)
        };

        tracing::info!("creating character {name}");

        // todo taximask, taxi_path, exploredZones, equipmentCache, knownTitles

        character::insert_character()
            .bind(
                &self.pool.get().await.unwrap(),
                &account.0,
                &CharacterId::try_from(id).unwrap().0,
                &name,
                &race.as_int(),
                &class.as_int(),
                &gender.as_int(),
                &skin_color,
                &face,
                &hair_style,
                &hair_color,
                &facial_style,
                &(zone),
                &(map),
                &position_x,
                &position_y,
                &position_z,
            )
            .one()
            .await
            .map(CharacterId)
            .map_err(|e| CharacterServiceError::PersistError(e.to_string()))
    }

    async fn delete_character(&self, id: CharacterId) -> Result<(), CharacterServiceError> {
        character::delete_character()
            .bind(&self.pool.get().await.unwrap(), &id.0)
            .await
            .map(|_| ())
            .map_err(|e| CharacterServiceError::PersistError(e.to_string()))
    }

    async fn account_data(&self, id: AccountId) -> Result<Vec<(i16, AccountDataCache)>, CharacterServiceError> {
        character::account_data()
            .bind(&self.pool.get().await.unwrap(), &id.0)
            .map(|r| {
                (r.r#type, AccountDataCache {
                    time: r.time,
                    data: r.data.to_owned(),
                })
            })
            .all()
            .await
            .map_err(|e| CharacterServiceError::PersistError(e.to_string()))
    }

    async fn character_account_data(&self, id: CharacterId) -> Result<Vec<(i16, AccountDataCache)>, CharacterServiceError> {
        character::character_account_data()
            .bind(&self.pool.get().await.unwrap(), &id.0)
            .map(|r| {
                (r.r#type, AccountDataCache {
                    time: r.time,
                    data: r.data.to_owned(),
                })
            })
            .all()
            .await
            .map_err(|e| CharacterServiceError::PersistError(e.to_string()))
    }

    async fn list(&self) -> Result<Vec<Character>, CharacterServiceError> {
        character::list_characters()
            .bind(&self.pool.get().await.unwrap())
            .map(|c| Character {
                id: CharacterId(c.id),
                account: AccountId(c.account),
                class: c.class.try_into().unwrap(),
                face: c.face.try_into().unwrap(),
                facial_style: c.facial_style.try_into().unwrap(),
                gender: c.gender.try_into().unwrap(),
                hair_color: c.hair_color.try_into().unwrap(),
                hair_style: c.hair_style.try_into().unwrap(),
                level: c.level.into(),
                map: c.map.try_into().unwrap(),
                name: c.name.to_owned(),
                position_x: c.position_x,
                position_y: c.position_y,
                position_z: c.position_z,
                race: c.race.try_into().unwrap(),
                skin_color: c.skin_color.try_into().unwrap(),
                zone: c.zone.try_into().unwrap(),
            })
            .all()
            .await
            .map_err(|e| CharacterServiceError::PersistError(e.to_string()))
    }
}

```

`crates/pg-characters/src/cornucopia.rs`:

```rs
// This file was generated with `cornucopia`. Do not modify.

 #[allow(clippy::all, clippy::pedantic)] #[allow(unused_variables)]
#[allow(unused_imports)] #[allow(dead_code)] pub mod types { } #[allow(clippy::all, clippy::pedantic)] #[allow(unused_variables)]
#[allow(unused_imports)] #[allow(dead_code)] pub mod queries
{  pub mod character
{  #[derive( Debug)] pub struct InsertCharacterParams<T1: cornucopia_async::StringSql,> { pub account: u32,pub guid: u32,pub name: T1,pub race: u8,pub class: u8,pub gender: u8,pub skin: u8,pub face: u8,pub hair_style: u8,pub hair_color: u8,pub facial_style: u8,pub zone: u16,pub map: u16,pub position_x: f32,pub position_y: f32,pub position_z: f32,} #[derive( Debug)] pub struct AddFriendByNameParams<T1: cornucopia_async::StringSql,> { pub id: u32,pub friend_id: u32,pub note: Option<T1>,} #[derive( Debug, Clone, PartialEq,)] pub struct GetCharacterById
{ pub id : u32,pub account : u32,pub name : String,pub level : u8,pub race : u8,pub class : u8,pub gender : u8,pub skin_color : u8,pub face : u8,pub hair_style : u8,pub hair_color : u8,pub facial_style : u8,pub zone : u16,pub map : u16,pub position_x : f32,pub position_y : f32,pub position_z : f32,} pub struct GetCharacterByIdBorrowed<'a> { pub id : u32,pub account : u32,pub name : &'a str,pub level : u8,pub race : u8,pub class : u8,pub gender : u8,pub skin_color : u8,pub face : u8,pub hair_style : u8,pub hair_color : u8,pub facial_style : u8,pub zone : u16,pub map : u16,pub position_x : f32,pub position_y : f32,pub position_z : f32,}
impl<'a> From<GetCharacterByIdBorrowed<'a>> for GetCharacterById
{
    fn from(GetCharacterByIdBorrowed { id,account,name,level,race,class,gender,skin_color,face,hair_style,hair_color,facial_style,zone,map,position_x,position_y,position_z,}: GetCharacterByIdBorrowed<'a>) ->
    Self { Self { id,account,name: name.into(),level,race,class,gender,skin_color,face,hair_style,hair_color,facial_style,zone,map,position_x,position_y,position_z,} }
} #[derive( Debug, Clone, PartialEq,)] pub struct GetCharacterByName
{ pub id : u32,pub account : u32,pub name : String,pub level : u8,pub race : u8,pub class : u8,pub gender : u8,pub skin_color : u8,pub face : u8,pub hair_style : u8,pub hair_color : u8,pub facial_style : u8,pub zone : u16,pub map : u16,pub position_x : f32,pub position_y : f32,pub position_z : f32,} pub struct GetCharacterByNameBorrowed<'a> { pub id : u32,pub account : u32,pub name : &'a str,pub level : u8,pub race : u8,pub class : u8,pub gender : u8,pub skin_color : u8,pub face : u8,pub hair_style : u8,pub hair_color : u8,pub facial_style : u8,pub zone : u16,pub map : u16,pub position_x : f32,pub position_y : f32,pub position_z : f32,}
impl<'a> From<GetCharacterByNameBorrowed<'a>> for GetCharacterByName
{
    fn from(GetCharacterByNameBorrowed { id,account,name,level,race,class,gender,skin_color,face,hair_style,hair_color,facial_style,zone,map,position_x,position_y,position_z,}: GetCharacterByNameBorrowed<'a>) ->
    Self { Self { id,account,name: name.into(),level,race,class,gender,skin_color,face,hair_style,hair_color,facial_style,zone,map,position_x,position_y,position_z,} }
} #[derive( Debug, Clone, PartialEq,)] pub struct GetCharacterByAccount
{ pub id : u32,pub account : u32,pub name : String,pub level : u8,pub race : u8,pub class : u8,pub gender : u8,pub skin_color : u8,pub face : u8,pub hair_style : u8,pub hair_color : u8,pub facial_style : u8,pub zone : u16,pub map : u16,pub position_x : f32,pub position_y : f32,pub position_z : f32,} pub struct GetCharacterByAccountBorrowed<'a> { pub id : u32,pub account : u32,pub name : &'a str,pub level : u8,pub race : u8,pub class : u8,pub gender : u8,pub skin_color : u8,pub face : u8,pub hair_style : u8,pub hair_color : u8,pub facial_style : u8,pub zone : u16,pub map : u16,pub position_x : f32,pub position_y : f32,pub position_z : f32,}
impl<'a> From<GetCharacterByAccountBorrowed<'a>> for GetCharacterByAccount
{
    fn from(GetCharacterByAccountBorrowed { id,account,name,level,race,class,gender,skin_color,face,hair_style,hair_color,facial_style,zone,map,position_x,position_y,position_z,}: GetCharacterByAccountBorrowed<'a>) ->
    Self { Self { id,account,name: name.into(),level,race,class,gender,skin_color,face,hair_style,hair_color,facial_style,zone,map,position_x,position_y,position_z,} }
} #[derive( Debug, Clone, PartialEq,)] pub struct AccountData
{ pub r#type : i16,pub time : u32,pub data : Vec<u8>,} pub struct AccountDataBorrowed<'a> { pub r#type : i16,pub time : u32,pub data : &'a [u8],}
impl<'a> From<AccountDataBorrowed<'a>> for AccountData
{
    fn from(AccountDataBorrowed { r#type,time,data,}: AccountDataBorrowed<'a>) ->
    Self { Self { r#type,time,data: data.into(),} }
} #[derive( Debug, Clone, PartialEq,)] pub struct CharacterAccountData
{ pub r#type : i16,pub time : u32,pub data : Vec<u8>,} pub struct CharacterAccountDataBorrowed<'a> { pub r#type : i16,pub time : u32,pub data : &'a [u8],}
impl<'a> From<CharacterAccountDataBorrowed<'a>> for CharacterAccountData
{
    fn from(CharacterAccountDataBorrowed { r#type,time,data,}: CharacterAccountDataBorrowed<'a>) ->
    Self { Self { r#type,time,data: data.into(),} }
} #[derive( Debug, Clone, PartialEq,)] pub struct ListCharacters
{ pub id : u32,pub account : u32,pub name : String,pub level : u8,pub race : u8,pub class : u8,pub gender : u8,pub skin_color : u8,pub face : u8,pub hair_style : u8,pub hair_color : u8,pub facial_style : u8,pub zone : u16,pub map : u16,pub position_x : f32,pub position_y : f32,pub position_z : f32,} pub struct ListCharactersBorrowed<'a> { pub id : u32,pub account : u32,pub name : &'a str,pub level : u8,pub race : u8,pub class : u8,pub gender : u8,pub skin_color : u8,pub face : u8,pub hair_style : u8,pub hair_color : u8,pub facial_style : u8,pub zone : u16,pub map : u16,pub position_x : f32,pub position_y : f32,pub position_z : f32,}
impl<'a> From<ListCharactersBorrowed<'a>> for ListCharacters
{
    fn from(ListCharactersBorrowed { id,account,name,level,race,class,gender,skin_color,face,hair_style,hair_color,facial_style,zone,map,position_x,position_y,position_z,}: ListCharactersBorrowed<'a>) ->
    Self { Self { id,account,name: name.into(),level,race,class,gender,skin_color,face,hair_style,hair_color,facial_style,zone,map,position_x,position_y,position_z,} }
} #[derive( Debug, Clone, PartialEq,)] pub struct GetFriends
{ pub friend : u32,pub flags : u32,pub note : String,} pub struct GetFriendsBorrowed<'a> { pub friend : u32,pub flags : u32,pub note : &'a str,}
impl<'a> From<GetFriendsBorrowed<'a>> for GetFriends
{
    fn from(GetFriendsBorrowed { friend,flags,note,}: GetFriendsBorrowed<'a>) ->
    Self { Self { friend,flags,note: note.into(),} }
}  use futures::{StreamExt, TryStreamExt};use futures; use cornucopia_async::GenericClient; pub struct GetCharacterByIdQuery<'a, C: GenericClient, T, const N: usize>
{
    client: &'a  C, params:
    [&'a (dyn postgres_types::ToSql + Sync); N], stmt: &'a mut
    cornucopia_async::private::Stmt, extractor: fn(&tokio_postgres::Row) -> GetCharacterByIdBorrowed,
    mapper: fn(GetCharacterByIdBorrowed) -> T,
} impl<'a, C, T:'a, const N: usize> GetCharacterByIdQuery<'a, C, T, N> where C:
GenericClient
{
    pub fn map<R>(self, mapper: fn(GetCharacterByIdBorrowed) -> R) ->
    GetCharacterByIdQuery<'a,C,R,N>
    {
        GetCharacterByIdQuery
        {
            client: self.client, params: self.params, stmt: self.stmt,
            extractor: self.extractor, mapper,
        }
    } pub async fn one(self) -> Result<T, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let row =
        self.client.query_one(stmt, &self.params).await?;
        Ok((self.mapper)((self.extractor)(&row)))
    } pub async fn all(self) -> Result<Vec<T>, tokio_postgres::Error>
    { self.iter().await?.try_collect().await } pub async fn opt(self) ->
    Result<Option<T>, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?;
        Ok(self.client.query_opt(stmt, &self.params) .await?
        .map(|row| (self.mapper)((self.extractor)(&row))))
    } pub async fn iter(self,) -> Result<impl futures::Stream<Item = Result<T,
    tokio_postgres::Error>> + 'a, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let it =
        self.client.query_raw(stmt,
        cornucopia_async::private::slice_iter(&self.params)) .await?
        .map(move |res|
        res.map(|row| (self.mapper)((self.extractor)(&row)))) .into_stream();
        Ok(it)
    }
} pub struct GetCharacterByNameQuery<'a, C: GenericClient, T, const N: usize>
{
    client: &'a  C, params:
    [&'a (dyn postgres_types::ToSql + Sync); N], stmt: &'a mut
    cornucopia_async::private::Stmt, extractor: fn(&tokio_postgres::Row) -> GetCharacterByNameBorrowed,
    mapper: fn(GetCharacterByNameBorrowed) -> T,
} impl<'a, C, T:'a, const N: usize> GetCharacterByNameQuery<'a, C, T, N> where C:
GenericClient
{
    pub fn map<R>(self, mapper: fn(GetCharacterByNameBorrowed) -> R) ->
    GetCharacterByNameQuery<'a,C,R,N>
    {
        GetCharacterByNameQuery
        {
            client: self.client, params: self.params, stmt: self.stmt,
            extractor: self.extractor, mapper,
        }
    } pub async fn one(self) -> Result<T, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let row =
        self.client.query_one(stmt, &self.params).await?;
        Ok((self.mapper)((self.extractor)(&row)))
    } pub async fn all(self) -> Result<Vec<T>, tokio_postgres::Error>
    { self.iter().await?.try_collect().await } pub async fn opt(self) ->
    Result<Option<T>, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?;
        Ok(self.client.query_opt(stmt, &self.params) .await?
        .map(|row| (self.mapper)((self.extractor)(&row))))
    } pub async fn iter(self,) -> Result<impl futures::Stream<Item = Result<T,
    tokio_postgres::Error>> + 'a, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let it =
        self.client.query_raw(stmt,
        cornucopia_async::private::slice_iter(&self.params)) .await?
        .map(move |res|
        res.map(|row| (self.mapper)((self.extractor)(&row)))) .into_stream();
        Ok(it)
    }
} pub struct GetCharacterByAccountQuery<'a, C: GenericClient, T, const N: usize>
{
    client: &'a  C, params:
    [&'a (dyn postgres_types::ToSql + Sync); N], stmt: &'a mut
    cornucopia_async::private::Stmt, extractor: fn(&tokio_postgres::Row) -> GetCharacterByAccountBorrowed,
    mapper: fn(GetCharacterByAccountBorrowed) -> T,
} impl<'a, C, T:'a, const N: usize> GetCharacterByAccountQuery<'a, C, T, N> where C:
GenericClient
{
    pub fn map<R>(self, mapper: fn(GetCharacterByAccountBorrowed) -> R) ->
    GetCharacterByAccountQuery<'a,C,R,N>
    {
        GetCharacterByAccountQuery
        {
            client: self.client, params: self.params, stmt: self.stmt,
            extractor: self.extractor, mapper,
        }
    } pub async fn one(self) -> Result<T, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let row =
        self.client.query_one(stmt, &self.params).await?;
        Ok((self.mapper)((self.extractor)(&row)))
    } pub async fn all(self) -> Result<Vec<T>, tokio_postgres::Error>
    { self.iter().await?.try_collect().await } pub async fn opt(self) ->
    Result<Option<T>, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?;
        Ok(self.client.query_opt(stmt, &self.params) .await?
        .map(|row| (self.mapper)((self.extractor)(&row))))
    } pub async fn iter(self,) -> Result<impl futures::Stream<Item = Result<T,
    tokio_postgres::Error>> + 'a, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let it =
        self.client.query_raw(stmt,
        cornucopia_async::private::slice_iter(&self.params)) .await?
        .map(move |res|
        res.map(|row| (self.mapper)((self.extractor)(&row)))) .into_stream();
        Ok(it)
    }
} pub struct I64Query<'a, C: GenericClient, T, const N: usize>
{
    client: &'a  C, params:
    [&'a (dyn postgres_types::ToSql + Sync); N], stmt: &'a mut
    cornucopia_async::private::Stmt, extractor: fn(&tokio_postgres::Row) -> i64,
    mapper: fn(i64) -> T,
} impl<'a, C, T:'a, const N: usize> I64Query<'a, C, T, N> where C:
GenericClient
{
    pub fn map<R>(self, mapper: fn(i64) -> R) ->
    I64Query<'a,C,R,N>
    {
        I64Query
        {
            client: self.client, params: self.params, stmt: self.stmt,
            extractor: self.extractor, mapper,
        }
    } pub async fn one(self) -> Result<T, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let row =
        self.client.query_one(stmt, &self.params).await?;
        Ok((self.mapper)((self.extractor)(&row)))
    } pub async fn all(self) -> Result<Vec<T>, tokio_postgres::Error>
    { self.iter().await?.try_collect().await } pub async fn opt(self) ->
    Result<Option<T>, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?;
        Ok(self.client.query_opt(stmt, &self.params) .await?
        .map(|row| (self.mapper)((self.extractor)(&row))))
    } pub async fn iter(self,) -> Result<impl futures::Stream<Item = Result<T,
    tokio_postgres::Error>> + 'a, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let it =
        self.client.query_raw(stmt,
        cornucopia_async::private::slice_iter(&self.params)) .await?
        .map(move |res|
        res.map(|row| (self.mapper)((self.extractor)(&row)))) .into_stream();
        Ok(it)
    }
} pub struct BoolQuery<'a, C: GenericClient, T, const N: usize>
{
    client: &'a  C, params:
    [&'a (dyn postgres_types::ToSql + Sync); N], stmt: &'a mut
    cornucopia_async::private::Stmt, extractor: fn(&tokio_postgres::Row) -> bool,
    mapper: fn(bool) -> T,
} impl<'a, C, T:'a, const N: usize> BoolQuery<'a, C, T, N> where C:
GenericClient
{
    pub fn map<R>(self, mapper: fn(bool) -> R) ->
    BoolQuery<'a,C,R,N>
    {
        BoolQuery
        {
            client: self.client, params: self.params, stmt: self.stmt,
            extractor: self.extractor, mapper,
        }
    } pub async fn one(self) -> Result<T, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let row =
        self.client.query_one(stmt, &self.params).await?;
        Ok((self.mapper)((self.extractor)(&row)))
    } pub async fn all(self) -> Result<Vec<T>, tokio_postgres::Error>
    { self.iter().await?.try_collect().await } pub async fn opt(self) ->
    Result<Option<T>, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?;
        Ok(self.client.query_opt(stmt, &self.params) .await?
        .map(|row| (self.mapper)((self.extractor)(&row))))
    } pub async fn iter(self,) -> Result<impl futures::Stream<Item = Result<T,
    tokio_postgres::Error>> + 'a, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let it =
        self.client.query_raw(stmt,
        cornucopia_async::private::slice_iter(&self.params)) .await?
        .map(move |res|
        res.map(|row| (self.mapper)((self.extractor)(&row)))) .into_stream();
        Ok(it)
    }
} pub struct U32Query<'a, C: GenericClient, T, const N: usize>
{
    client: &'a  C, params:
    [&'a (dyn postgres_types::ToSql + Sync); N], stmt: &'a mut
    cornucopia_async::private::Stmt, extractor: fn(&tokio_postgres::Row) -> u32,
    mapper: fn(u32) -> T,
} impl<'a, C, T:'a, const N: usize> U32Query<'a, C, T, N> where C:
GenericClient
{
    pub fn map<R>(self, mapper: fn(u32) -> R) ->
    U32Query<'a,C,R,N>
    {
        U32Query
        {
            client: self.client, params: self.params, stmt: self.stmt,
            extractor: self.extractor, mapper,
        }
    } pub async fn one(self) -> Result<T, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let row =
        self.client.query_one(stmt, &self.params).await?;
        Ok((self.mapper)((self.extractor)(&row)))
    } pub async fn all(self) -> Result<Vec<T>, tokio_postgres::Error>
    { self.iter().await?.try_collect().await } pub async fn opt(self) ->
    Result<Option<T>, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?;
        Ok(self.client.query_opt(stmt, &self.params) .await?
        .map(|row| (self.mapper)((self.extractor)(&row))))
    } pub async fn iter(self,) -> Result<impl futures::Stream<Item = Result<T,
    tokio_postgres::Error>> + 'a, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let it =
        self.client.query_raw(stmt,
        cornucopia_async::private::slice_iter(&self.params)) .await?
        .map(move |res|
        res.map(|row| (self.mapper)((self.extractor)(&row)))) .into_stream();
        Ok(it)
    }
} pub struct AccountDataQuery<'a, C: GenericClient, T, const N: usize>
{
    client: &'a  C, params:
    [&'a (dyn postgres_types::ToSql + Sync); N], stmt: &'a mut
    cornucopia_async::private::Stmt, extractor: fn(&tokio_postgres::Row) -> AccountDataBorrowed,
    mapper: fn(AccountDataBorrowed) -> T,
} impl<'a, C, T:'a, const N: usize> AccountDataQuery<'a, C, T, N> where C:
GenericClient
{
    pub fn map<R>(self, mapper: fn(AccountDataBorrowed) -> R) ->
    AccountDataQuery<'a,C,R,N>
    {
        AccountDataQuery
        {
            client: self.client, params: self.params, stmt: self.stmt,
            extractor: self.extractor, mapper,
        }
    } pub async fn one(self) -> Result<T, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let row =
        self.client.query_one(stmt, &self.params).await?;
        Ok((self.mapper)((self.extractor)(&row)))
    } pub async fn all(self) -> Result<Vec<T>, tokio_postgres::Error>
    { self.iter().await?.try_collect().await } pub async fn opt(self) ->
    Result<Option<T>, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?;
        Ok(self.client.query_opt(stmt, &self.params) .await?
        .map(|row| (self.mapper)((self.extractor)(&row))))
    } pub async fn iter(self,) -> Result<impl futures::Stream<Item = Result<T,
    tokio_postgres::Error>> + 'a, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let it =
        self.client.query_raw(stmt,
        cornucopia_async::private::slice_iter(&self.params)) .await?
        .map(move |res|
        res.map(|row| (self.mapper)((self.extractor)(&row)))) .into_stream();
        Ok(it)
    }
} pub struct CharacterAccountDataQuery<'a, C: GenericClient, T, const N: usize>
{
    client: &'a  C, params:
    [&'a (dyn postgres_types::ToSql + Sync); N], stmt: &'a mut
    cornucopia_async::private::Stmt, extractor: fn(&tokio_postgres::Row) -> CharacterAccountDataBorrowed,
    mapper: fn(CharacterAccountDataBorrowed) -> T,
} impl<'a, C, T:'a, const N: usize> CharacterAccountDataQuery<'a, C, T, N> where C:
GenericClient
{
    pub fn map<R>(self, mapper: fn(CharacterAccountDataBorrowed) -> R) ->
    CharacterAccountDataQuery<'a,C,R,N>
    {
        CharacterAccountDataQuery
        {
            client: self.client, params: self.params, stmt: self.stmt,
            extractor: self.extractor, mapper,
        }
    } pub async fn one(self) -> Result<T, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let row =
        self.client.query_one(stmt, &self.params).await?;
        Ok((self.mapper)((self.extractor)(&row)))
    } pub async fn all(self) -> Result<Vec<T>, tokio_postgres::Error>
    { self.iter().await?.try_collect().await } pub async fn opt(self) ->
    Result<Option<T>, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?;
        Ok(self.client.query_opt(stmt, &self.params) .await?
        .map(|row| (self.mapper)((self.extractor)(&row))))
    } pub async fn iter(self,) -> Result<impl futures::Stream<Item = Result<T,
    tokio_postgres::Error>> + 'a, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let it =
        self.client.query_raw(stmt,
        cornucopia_async::private::slice_iter(&self.params)) .await?
        .map(move |res|
        res.map(|row| (self.mapper)((self.extractor)(&row)))) .into_stream();
        Ok(it)
    }
} pub struct ListCharactersQuery<'a, C: GenericClient, T, const N: usize>
{
    client: &'a  C, params:
    [&'a (dyn postgres_types::ToSql + Sync); N], stmt: &'a mut
    cornucopia_async::private::Stmt, extractor: fn(&tokio_postgres::Row) -> ListCharactersBorrowed,
    mapper: fn(ListCharactersBorrowed) -> T,
} impl<'a, C, T:'a, const N: usize> ListCharactersQuery<'a, C, T, N> where C:
GenericClient
{
    pub fn map<R>(self, mapper: fn(ListCharactersBorrowed) -> R) ->
    ListCharactersQuery<'a,C,R,N>
    {
        ListCharactersQuery
        {
            client: self.client, params: self.params, stmt: self.stmt,
            extractor: self.extractor, mapper,
        }
    } pub async fn one(self) -> Result<T, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let row =
        self.client.query_one(stmt, &self.params).await?;
        Ok((self.mapper)((self.extractor)(&row)))
    } pub async fn all(self) -> Result<Vec<T>, tokio_postgres::Error>
    { self.iter().await?.try_collect().await } pub async fn opt(self) ->
    Result<Option<T>, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?;
        Ok(self.client.query_opt(stmt, &self.params) .await?
        .map(|row| (self.mapper)((self.extractor)(&row))))
    } pub async fn iter(self,) -> Result<impl futures::Stream<Item = Result<T,
    tokio_postgres::Error>> + 'a, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let it =
        self.client.query_raw(stmt,
        cornucopia_async::private::slice_iter(&self.params)) .await?
        .map(move |res|
        res.map(|row| (self.mapper)((self.extractor)(&row)))) .into_stream();
        Ok(it)
    }
} pub struct GetFriendsQuery<'a, C: GenericClient, T, const N: usize>
{
    client: &'a  C, params:
    [&'a (dyn postgres_types::ToSql + Sync); N], stmt: &'a mut
    cornucopia_async::private::Stmt, extractor: fn(&tokio_postgres::Row) -> GetFriendsBorrowed,
    mapper: fn(GetFriendsBorrowed) -> T,
} impl<'a, C, T:'a, const N: usize> GetFriendsQuery<'a, C, T, N> where C:
GenericClient
{
    pub fn map<R>(self, mapper: fn(GetFriendsBorrowed) -> R) ->
    GetFriendsQuery<'a,C,R,N>
    {
        GetFriendsQuery
        {
            client: self.client, params: self.params, stmt: self.stmt,
            extractor: self.extractor, mapper,
        }
    } pub async fn one(self) -> Result<T, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let row =
        self.client.query_one(stmt, &self.params).await?;
        Ok((self.mapper)((self.extractor)(&row)))
    } pub async fn all(self) -> Result<Vec<T>, tokio_postgres::Error>
    { self.iter().await?.try_collect().await } pub async fn opt(self) ->
    Result<Option<T>, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?;
        Ok(self.client.query_opt(stmt, &self.params) .await?
        .map(|row| (self.mapper)((self.extractor)(&row))))
    } pub async fn iter(self,) -> Result<impl futures::Stream<Item = Result<T,
    tokio_postgres::Error>> + 'a, tokio_postgres::Error>
    {
        let stmt = self.stmt.prepare(self.client).await?; let it =
        self.client.query_raw(stmt,
        cornucopia_async::private::slice_iter(&self.params)) .await?
        .map(move |res|
        res.map(|row| (self.mapper)((self.extractor)(&row)))) .into_stream();
        Ok(it)
    }
} pub fn get_character_by_id() -> GetCharacterByIdStmt
{ GetCharacterByIdStmt(cornucopia_async::private::Stmt::new("SELECT guid as id, account, name, level, race, class, gender, skin as skin_color, face, hair_style, hair_color, facial_style, zone, map, position_x, position_y, position_z FROM characters where guid = $1")) } pub struct
GetCharacterByIdStmt(cornucopia_async::private::Stmt); impl GetCharacterByIdStmt
{  pub fn bind<'a, C:
GenericClient,>(&'a mut self, client: &'a  C,
guid: &'a u32,) -> GetCharacterByIdQuery<'a,C,
GetCharacterById, 1>
{
    GetCharacterByIdQuery
    {
        client, params: [guid,], stmt: &mut self.0, extractor:
        |row| {  GetCharacterByIdBorrowed { id: row.get(0),account: row.get(1),name: row.get(2),level: row.get(3),race: row.get(4),class: row.get(5),gender: row.get(6),skin_color: row.get(7),face: row.get(8),hair_style: row.get(9),hair_color: row.get(10),facial_style: row.get(11),zone: row.get(12),map: row.get(13),position_x: row.get(14),position_y: row.get(15),position_z: row.get(16),} }, mapper: |it| { <GetCharacterById>::from(it) },
    }
} } pub fn get_character_by_name() -> GetCharacterByNameStmt
{ GetCharacterByNameStmt(cornucopia_async::private::Stmt::new("SELECT guid as id, account, name, level, race, class, gender, skin as skin_color, face, hair_style, hair_color, facial_style, zone, map, position_x, position_y, position_z FROM characters where name = $1")) } pub struct
GetCharacterByNameStmt(cornucopia_async::private::Stmt); impl GetCharacterByNameStmt
{  pub fn bind<'a, C:
GenericClient,T1:
cornucopia_async::StringSql,>(&'a mut self, client: &'a  C,
name: &'a T1,) -> GetCharacterByNameQuery<'a,C,
GetCharacterByName, 1>
{
    GetCharacterByNameQuery
    {
        client, params: [name,], stmt: &mut self.0, extractor:
        |row| {  GetCharacterByNameBorrowed { id: row.get(0),account: row.get(1),name: row.get(2),level: row.get(3),race: row.get(4),class: row.get(5),gender: row.get(6),skin_color: row.get(7),face: row.get(8),hair_style: row.get(9),hair_color: row.get(10),facial_style: row.get(11),zone: row.get(12),map: row.get(13),position_x: row.get(14),position_y: row.get(15),position_z: row.get(16),} }, mapper: |it| { <GetCharacterByName>::from(it) },
    }
} } pub fn get_character_by_account() -> GetCharacterByAccountStmt
{ GetCharacterByAccountStmt(cornucopia_async::private::Stmt::new("SELECT guid as id, account, name, level, race, class, gender, skin as skin_color, face, hair_style, hair_color, facial_style, zone, map, position_x, position_y, position_z FROM characters where account = $1")) } pub struct
GetCharacterByAccountStmt(cornucopia_async::private::Stmt); impl GetCharacterByAccountStmt
{  pub fn bind<'a, C:
GenericClient,>(&'a mut self, client: &'a  C,
account: &'a u32,) -> GetCharacterByAccountQuery<'a,C,
GetCharacterByAccount, 1>
{
    GetCharacterByAccountQuery
    {
        client, params: [account,], stmt: &mut self.0, extractor:
        |row| {  GetCharacterByAccountBorrowed { id: row.get(0),account: row.get(1),name: row.get(2),level: row.get(3),race: row.get(4),class: row.get(5),gender: row.get(6),skin_color: row.get(7),face: row.get(8),hair_style: row.get(9),hair_color: row.get(10),facial_style: row.get(11),zone: row.get(12),map: row.get(13),position_x: row.get(14),position_y: row.get(15),position_z: row.get(16),} }, mapper: |it| { <GetCharacterByAccount>::from(it) },
    }
} } pub fn count_by_account() -> CountByAccountStmt
{ CountByAccountStmt(cornucopia_async::private::Stmt::new("SELECT count(*) as count FROM characters where account = $1")) } pub struct
CountByAccountStmt(cornucopia_async::private::Stmt); impl CountByAccountStmt
{  pub fn bind<'a, C:
GenericClient,>(&'a mut self, client: &'a  C,
account: &'a u32,) -> I64Query<'a,C,
i64, 1>
{
    I64Query
    {
        client, params: [account,], stmt: &mut self.0, extractor:
        |row| {  row.get(0) }, mapper: |it| { it },
    }
} } pub fn name_available() -> NameAvailableStmt
{ NameAvailableStmt(cornucopia_async::private::Stmt::new("SELECT count(*) = 0 as available FROM characters where name = $1")) } pub struct
NameAvailableStmt(cornucopia_async::private::Stmt); impl NameAvailableStmt
{  pub fn bind<'a, C:
GenericClient,T1:
cornucopia_async::StringSql,>(&'a mut self, client: &'a  C,
name: &'a T1,) -> BoolQuery<'a,C,
bool, 1>
{
    BoolQuery
    {
        client, params: [name,], stmt: &mut self.0, extractor:
        |row| {  row.get(0) }, mapper: |it| { it },
    }
} } pub fn insert_character() -> InsertCharacterStmt
{ InsertCharacterStmt(cornucopia_async::private::Stmt::new("INSERT INTO characters
    (account, guid, level, name, race, class, gender, skin, face, hair_style, hair_color, facial_style, zone, map, position_x, position_y, position_z, taxi_mask, taxi_path, explored_zones, equipment_cache, known_titles)
values
    ($1, $2, 1, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, '','', '', '', '')
returning
    guid")) } pub struct
InsertCharacterStmt(cornucopia_async::private::Stmt); impl InsertCharacterStmt
{  pub fn bind<'a, C:
GenericClient,T1:
cornucopia_async::StringSql,>(&'a mut self, client: &'a  C,
account: &'a u32,guid: &'a u32,name: &'a T1,race: &'a u8,class: &'a u8,gender: &'a u8,skin: &'a u8,face: &'a u8,hair_style: &'a u8,hair_color: &'a u8,facial_style: &'a u8,zone: &'a u16,map: &'a u16,position_x: &'a f32,position_y: &'a f32,position_z: &'a f32,) -> U32Query<'a,C,
u32, 16>
{
    U32Query
    {
        client, params: [account,guid,name,race,class,gender,skin,face,hair_style,hair_color,facial_style,zone,map,position_x,position_y,position_z,], stmt: &mut self.0, extractor:
        |row| {  row.get(0) }, mapper: |it| { it },
    }
} } impl <'a, C: GenericClient,T1: cornucopia_async::StringSql,> cornucopia_async::Params<'a,
InsertCharacterParams<T1,>, U32Query<'a, C,
u32, 16>, C> for InsertCharacterStmt
{
    fn
    params(&'a mut self, client: &'a  C, params: &'a
    InsertCharacterParams<T1,>) -> U32Query<'a, C,
    u32, 16>
    { self.bind(client, &params.account,&params.guid,&params.name,&params.race,&params.class,&params.gender,&params.skin,&params.face,&params.hair_style,&params.hair_color,&params.facial_style,&params.zone,&params.map,&params.position_x,&params.position_y,&params.position_z,) }
} pub fn delete_character() -> DeleteCharacterStmt
{ DeleteCharacterStmt(cornucopia_async::private::Stmt::new("DELETE FROM characters where guid = $1")) } pub struct
DeleteCharacterStmt(cornucopia_async::private::Stmt); impl DeleteCharacterStmt
{  pub async fn bind<'a, C:
GenericClient,>(&'a mut self, client: &'a  C,
id: &'a u32,) -> Result<u64, tokio_postgres::Error>
{
    let stmt = self.0.prepare(client).await?;
    client.execute(stmt, &[id,]).await
} } pub fn account_data() -> AccountDataStmt
{ AccountDataStmt(cornucopia_async::private::Stmt::new("SELECT type, time, data FROM account_data WHERE account_id = $1")) } pub struct
AccountDataStmt(cornucopia_async::private::Stmt); impl AccountDataStmt
{  pub fn bind<'a, C:
GenericClient,>(&'a mut self, client: &'a  C,
id: &'a u32,) -> AccountDataQuery<'a,C,
AccountData, 1>
{
    AccountDataQuery
    {
        client, params: [id,], stmt: &mut self.0, extractor:
        |row| {  AccountDataBorrowed { r#type: row.get(0),time: row.get(1),data: row.get(2),} }, mapper: |it| { <AccountData>::from(it) },
    }
} } pub fn character_account_data() -> CharacterAccountDataStmt
{ CharacterAccountDataStmt(cornucopia_async::private::Stmt::new("SELECT type, time, data FROM character_account_data WHERE guid = $1")) } pub struct
CharacterAccountDataStmt(cornucopia_async::private::Stmt); impl CharacterAccountDataStmt
{  pub fn bind<'a, C:
GenericClient,>(&'a mut self, client: &'a  C,
id: &'a u32,) -> CharacterAccountDataQuery<'a,C,
CharacterAccountData, 1>
{
    CharacterAccountDataQuery
    {
        client, params: [id,], stmt: &mut self.0, extractor:
        |row| {  CharacterAccountDataBorrowed { r#type: row.get(0),time: row.get(1),data: row.get(2),} }, mapper: |it| { <CharacterAccountData>::from(it) },
    }
} } pub fn list_characters() -> ListCharactersStmt
{ ListCharactersStmt(cornucopia_async::private::Stmt::new("SELECT guid as id, account, name, level, race, class, gender, skin as skin_color, face, hair_style, hair_color, facial_style, zone, map, position_x, position_y, position_z FROM characters")) } pub struct
ListCharactersStmt(cornucopia_async::private::Stmt); impl ListCharactersStmt
{  pub fn bind<'a, C:
GenericClient,>(&'a mut self, client: &'a  C,
) -> ListCharactersQuery<'a,C,
ListCharacters, 0>
{
    ListCharactersQuery
    {
        client, params: [], stmt: &mut self.0, extractor:
        |row| {  ListCharactersBorrowed { id: row.get(0),account: row.get(1),name: row.get(2),level: row.get(3),race: row.get(4),class: row.get(5),gender: row.get(6),skin_color: row.get(7),face: row.get(8),hair_style: row.get(9),hair_color: row.get(10),facial_style: row.get(11),zone: row.get(12),map: row.get(13),position_x: row.get(14),position_y: row.get(15),position_z: row.get(16),} }, mapper: |it| { <ListCharacters>::from(it) },
    }
} } pub fn get_friends() -> GetFriendsStmt
{ GetFriendsStmt(cornucopia_async::private::Stmt::new("select friend, flags, note from character_social where guid = $1")) } pub struct
GetFriendsStmt(cornucopia_async::private::Stmt); impl GetFriendsStmt
{  pub fn bind<'a, C:
GenericClient,>(&'a mut self, client: &'a  C,
id: &'a u32,) -> GetFriendsQuery<'a,C,
GetFriends, 1>
{
    GetFriendsQuery
    {
        client, params: [id,], stmt: &mut self.0, extractor:
        |row| {  GetFriendsBorrowed { friend: row.get(0),flags: row.get(1),note: row.get(2),} }, mapper: |it| { <GetFriends>::from(it) },
    }
} } pub fn add_friend_by_name() -> AddFriendByNameStmt
{ AddFriendByNameStmt(cornucopia_async::private::Stmt::new("INSERT INTO character_social (guid, friend, note) values ($1, $2, $3)")) } pub struct
AddFriendByNameStmt(cornucopia_async::private::Stmt); impl AddFriendByNameStmt
{  pub async fn bind<'a, C:
GenericClient,T1:
cornucopia_async::StringSql,>(&'a mut self, client: &'a  C,
id: &'a u32,friend_id: &'a u32,note: &'a Option<T1>,) -> Result<u64, tokio_postgres::Error>
{
    let stmt = self.0.prepare(client).await?;
    client.execute(stmt, &[id,friend_id,note,]).await
} } impl <'a, C: GenericClient + Send + Sync, T1: cornucopia_async::StringSql,>
cornucopia_async::Params<'a, AddFriendByNameParams<T1,>, std::pin::Pin<Box<dyn futures::Future<Output = Result<u64,
tokio_postgres::Error>> + Send + 'a>>, C> for AddFriendByNameStmt
{
    fn
    params(&'a mut self, client: &'a  C, params: &'a
    AddFriendByNameParams<T1,>) -> std::pin::Pin<Box<dyn futures::Future<Output = Result<u64,
    tokio_postgres::Error>> + Send + 'a>>
    { Box::pin(self.bind(client, &params.id,&params.friend_id,&params.note,)) }
} }}
```

`crates/pg-characters/src/lib.rs`:

```rs
pub mod characters;
mod cornucopia;

pub use characters::PgCharacterService;

```

`crates/utils/Cargo.toml`:

```toml
[package]
edition = "2024"
name = "azerust-utils"
version = "0.1.0"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
anyhow = "1.0.55"
tokio = "1.17.0"

```

`crates/utils/src/lib.rs`:

```rs
use anyhow::{Result, anyhow};
use tokio::task::JoinHandle;

pub async fn flatten<T>(handle: JoinHandle<Result<T>>) -> Result<T> {
    match handle.await {
        Ok(Ok(result)) => Ok(result),
        Ok(Err(err)) => Err(err),
        Err(err) => Err(anyhow!("join failed: {err}")),
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}

```

`crates/wow-srp/Cargo.toml`:

```toml
[package]
name = "wow-srp"
version = "0.1.0"
authors = ["Alexander Lyon <arlyon@me.com>"]
edition = "2024"
license = "MIT OR Apache-2.0"

[dependencies]
lazy_static = "1.4"
num-bigint = "0.4"
rand = "0.8"
serde = { version = "1", features = ["derive"] }
sha-1 = "0.9"
tracing = "0.1"

```

`crates/wow-srp/src/lib.rs`:

```rs
//! wow-srp
//!
//! This crate implements the SRP variation that is used in
//! the World of Warcraft authentication protocol. It provides
//! currently only provides a [`WowSRPServer`].

#![deny(
    missing_docs,
    missing_debug_implementations,
    missing_copy_implementations,
    trivial_casts,
    trivial_numeric_casts,
    unsafe_code,
    unstable_features,
    unused_import_braces,
    unused_qualifications
)]

use std::convert::TryInto;

use lazy_static::lazy_static;
use num_bigint::BigUint;
use rand::{
    Rng,
    distributions::{Distribution, Standard},
};
use serde::Serialize;
use sha1::{Digest, Sha1};
use tracing::instrument;

lazy_static! {
    static ref G: BigUint = BigUint::from_bytes_be(&[7]);
    static ref N: BigUint = BigUint::from_bytes_be(&[
        0x89, 0x4B, 0x64, 0x5E, 0x89, 0xE1, 0x53, 0x5B, 0xBD, 0xAD, 0x5B, 0x8B, 0x29, 0x06, 0x50, 0x53, 0x08, 0x01, 0xB1, 0x8E, 0xBF, 0xBF, 0x5E, 0x8F, 0xAB,
        0x3C, 0x82, 0x87, 0x2A, 0x3E, 0x9B, 0xB7,
    ]);
}

/// A salt is used to prevent dictionary attacks,
#[derive(Copy, Clone, Debug, PartialEq, Eq, Serialize)]
pub struct Salt(pub [u8; 32]);

impl Distribution<Salt> for Standard {
    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Salt {
        let inner = rng.r#gen();
        Salt(inner)
    }
}

/// A verifier allows the server to check the
/// validity of a password proof provided to it
/// by a client.
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub struct Verifier(pub [u8; 32]);

impl From<&Verifier> for BigUint {
    fn from(v: &Verifier) -> Self {
        Self::from_bytes_le(&v.0)
    }
}

impl Verifier {
    /// Create a verifier from a set of credentials and salt.
    pub fn from_credentials(username: &str, password: &str, salt: &Salt) -> Self {
        let inner = {
            let mut d = Sha1::new();
            d.update(username.as_bytes());
            d.update(":");
            d.update(password.as_bytes());
            d.finalize()
        };

        let mut hash = Sha1::new();
        hash.update(salt.0);
        hash.update(inner);
        let hash = BigUint::from_bytes_le(&hash.finalize());

        Self(G.modpow(&hash, &N).to_bytes_le().try_into().expect("correct size"))
    }

    /// Create a verifier from raw bytes.
    pub fn from_raw(data: [u8; 32]) -> Self {
        Self(data)
    }
}

/// Provides the server-side functionality of the WoW
/// SRP protocol.
///
/// ```rust
/// use wow_srp::WowSRPServer;
///
/// // register a new user
/// let (verifier, salt) = WowSRPServer::register("ARLYON", "TEST");
///
/// // some time later, load the username,
/// // salt and verifier from the database.
/// let server = WowSRPServer::new("ARLYON", salt, verifier);
/// ```
#[derive(Copy, Clone, Debug, PartialEq)]
pub struct WowSRPServer {
    salt: Salt,
    verifier: Verifier,
    identity_hash: [u8; 20],
    b: [u8; 32],
    b_pub: [u8; 32],
}

impl WowSRPServer {
    /// Create a new instance of a server verifier.
    pub fn new(username: &str, salt: Salt, verifier: Verifier) -> Self {
        let mut rng = rand::thread_rng();
        let b = rng.r#gen();
        WowSRPServer::new_with_b(username, salt, verifier, b)
    }

    pub(crate) fn new_with_b(username: &str, salt: Salt, verifier: Verifier, b: [u8; 32]) -> Self {
        Self {
            salt,
            b_pub: Self::calculate_b_pub(&b, &verifier),
            identity_hash: Sha1::digest(username.as_bytes()).into(),
            verifier,
            b,
        }
    }

    /// Get the g parameter in use by this server.
    pub fn get_g(&self) -> Vec<u8> {
        G.to_bytes_le()
    }

    /// Get the n parameter in use by this server.
    pub fn get_n(&self) -> Vec<u8> {
        N.to_bytes_le()
    }

    /// Get the random salt in use by this server.
    pub fn get_salt(&self) -> &Salt {
        &self.salt
    }

    /// Get the ephemeral public key for this server.
    pub fn get_b_pub(&self) -> &[u8; 32] {
        &self.b_pub
    }

    /// Does the registration calculations, returning a verifier and
    /// a salt that can be stored in the database.
    pub fn register(username: &str, password: &str) -> (Verifier, Salt) {
        let mut rng = rand::thread_rng();
        let salt = rng.r#gen();
        (Verifier::from_credentials(username, password, &salt), salt)
    }

    /// Get the server proof (M2). This is derived from the client
    /// public key and client proof (M1), as well as the session key.
    pub fn get_server_proof(&self, a_pub: &[u8; 32], client_proof: &[u8; 20], session_key: &[u8; 40]) -> [u8; 20] {
        let mut sha = Sha1::new();
        sha.update(a_pub);
        sha.update(client_proof);
        sha.update(session_key);
        sha.finalize().into()
    }

    /// Verify the challenge response, returning a verified key if
    /// it is valid.
    #[instrument]
    pub fn verify_challenge_response(self, a_pub: &[u8; 32], client_m: &[u8; 20]) -> Option<[u8; 40]> {
        let a_pub_num = BigUint::from_bytes_le(a_pub);
        let verifier = BigUint::from(&self.verifier);
        let b = BigUint::from_bytes_be(&self.b);

        if (&a_pub_num % &*N).eq(&0u8.into()) {
            return None;
        };

        let a_b = {
            let mut sha = Sha1::new();
            sha.update(a_pub);
            sha.update(self.b_pub);
            sha.finalize()
        };

        let u = BigUint::from_bytes_le(&a_b);
        let premaster_secret = (&a_pub_num * verifier.modpow(&u, &N)).modpow(&b, &N);

        // todo(arlyon): this can panic
        let session_key = WowSRPServer::derive_session_key(&premaster_secret.to_bytes_le().try_into().expect("correct size"));

        let hn_xor_hg: Vec<_> = Sha1::digest(&N.to_bytes_le())
            .iter()
            .zip(Sha1::digest(&G.to_bytes_le()))
            .map(|(f, s)| f ^ s)
            .collect();

        let server_m = {
            let mut sha = Sha1::new();
            sha.update(&hn_xor_hg);
            sha.update(self.identity_hash);
            sha.update(self.salt.0);
            sha.update(a_pub);
            sha.update(self.b_pub);
            sha.update(session_key);
            sha.finalize()
        };

        if server_m.as_slice() == client_m { Some(session_key) } else { None }
    }

    /// Calculate the server's public key from a combination of the private key
    /// and the verifier.
    fn calculate_b_pub(b: &[u8; 32], v: &Verifier) -> [u8; 32] {
        let fst = G.modpow(&BigUint::from_bytes_be(b), &N);
        let snd = BigUint::from(v) * BigUint::from(3u8);

        ((fst + snd) % &*N).to_bytes_le().try_into().expect("correct size")
    }

    /// Calculates the session key by running it through a SHA1 interleave.
    fn derive_session_key(premaster_secret: &[u8; 32]) -> [u8; 40] {
        let mut left = [0u8; 16];
        let mut right = [0u8; 16];
        for (i, split) in premaster_secret.chunks(2).enumerate() {
            left[i] = split[0];
            right[i] = split[1];
        }

        let start = premaster_secret
            .iter()
            .enumerate()
            .find(|&(_, &v)| v != 0)
            .map(|(i, &v)| if v == 0 { i } else { i + 1 })
            .unwrap_or(premaster_secret.len())
            / 2;

        let left = Sha1::digest(&left[start..]);
        let right = Sha1::digest(&right[start..]);

        let mut k = [0u8; 40];
        for (i, original) in k.chunks_mut(2).enumerate() {
            original[0] = left[i];
            original[1] = right[i];
        }
        k
    }
}

#[cfg(test)]
mod test {
    use crate::{Salt, Verifier, WowSRPServer};

    #[test]
    pub fn test_session_key_derivation() {
        let s: [u8; 32] = [
            19, 10, 81, 2, 224, 175, 69, 69, 84, 172, 123, 122, 83, 70, 70, 11, 104, 26, 227, 161, 13, 124, 152, 156, 116, 130, 69, 161, 134, 49, 47, 87,
        ];

        let k = WowSRPServer::derive_session_key(&s);

        let k_expected: [u8; 40] = [
            250, 249, 162, 120, 246, 212, 243, 32, 54, 127, 15, 13, 84, 137, 96, 197, 162, 197, 95, 221, 107, 218, 252, 23, 37, 95, 250, 83, 182, 53, 105, 254,
            23, 14, 207, 191, 85, 207, 209, 111,
        ];

        assert_eq!(k, k_expected);
    }

    #[test]
    pub fn test_challenge_response() {
        let a_pub: [u8; 32] = [
            177, 187, 117, 101, 30, 135, 85, 86, 180, 130, 85, 39, 48, 20, 11, 106, 214, 92, 84, 103, 232, 177, 228, 146, 224, 172, 207, 133, 107, 59, 208, 18,
        ];

        let client_m: [u8; 20] = [146, 204, 135, 140, 185, 242, 195, 134, 82, 178, 161, 241, 103, 186, 206, 104, 255, 211, 141, 6];

        let server = WowSRPServer::new_with_b(
            "ARLYON",
            Salt([
                224, 222, 178, 127, 204, 184, 244, 126, 70, 90, 69, 35, 84, 22, 9, 131, 253, 198, 54, 56, 240, 56, 90, 214, 234, 20, 89, 54, 177, 3, 71, 245,
            ]),
            Verifier::from_raw([
                83, 39, 153, 164, 62, 235, 129, 78, 56, 219, 154, 148, 34, 246, 103, 86, 198, 149, 125, 69, 184, 96, 172, 156, 203, 86, 185, 27, 161, 55, 61, 8,
            ]),
            [
                0xF0, 0xA4, 0xBB, 0x60, 0x1C, 0xB3, 0xE5, 0x03, 0x41, 0x26, 0xD0, 0xC7, 0x95, 0x73, 0x19, 0xD3, 0xCB, 0x0D, 0x7B, 0xD6, 0xFE, 0x2E, 0x3C, 0x9F,
                0x6F, 0x0C, 0x27, 0x28, 0x17, 0x55, 0x76, 0x1F,
            ],
        );

        server.verify_challenge_response(&a_pub, &client_m).unwrap();
    }

    #[test]
    pub fn test_calculate_b_pub() {
        let b_pub = [
            207, 248, 81, 226, 241, 107, 212, 253, 104, 21, 206, 66, 202, 67, 72, 65, 242, 27, 42, 111, 204, 187, 209, 246, 130, 204, 13, 78, 184, 205, 74, 56,
        ];

        let b = [
            240, 164, 187, 96, 28, 179, 229, 3, 65, 38, 208, 199, 149, 115, 25, 211, 203, 13, 123, 214, 254, 46, 60, 159, 111, 12, 39, 40, 23, 85, 118, 31,
        ];

        let v = Verifier::from_raw([
            110, 114, 108, 105, 100, 115, 110, 114, 100, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ]);

        assert_eq!(WowSRPServer::calculate_b_pub(&b, &v), b_pub)
    }

    #[test]
    pub fn verifier_from_credentials() {
        let salt: [u8; 32] = [
            187, 90, 185, 129, 207, 201, 1, 39, 118, 43, 185, 47, 102, 19, 75, 54, 17, 102, 255, 182, 144, 248, 239, 202, 238, 158, 71, 164, 216, 195, 53, 226,
        ];

        let v_expected: [u8; 32] = [
            44, 42, 171, 164, 129, 208, 59, 156, 50, 148, 246, 223, 12, 222, 85, 21, 129, 251, 36, 170, 7, 130, 79, 109, 238, 227, 72, 88, 196, 33, 67, 90,
        ];

        let v = Verifier::from_credentials("ARLYON", "TEST", &Salt(salt));

        assert_eq!(v.0, v_expected);
    }
}

```

`docker-compose.yaml`:

```yaml
version: "3.9"
x-log-level: &log-level
  RUST_LOG: "azerust_world,azerust_auth"
services:
  world:
    image: ghcr.io/arlyon/azerust-world:master
    profiles: ["server"]
    build:
      context: .
      target: world
    depends_on: [database]
    environment: *log-level
    volumes:
      - ./config-world-compose.yaml:/config.yaml:Z
    ports:
      - "8085:8085"
      - "9001:9001"
  auth:
    image: ghcr.io/arlyon/azerust-auth:master
    profiles: ["server"]
    build:
      context: .
      target: auth
    depends_on: [database]
    environment: *log-level
    volumes:
      - ./config-auth-compose.yaml:/config.yaml:Z
    ports:
      - "3724:3724"
      - "8000:8000"
      - "9000:9000"
  database:
    image: "mariadb:10"
    environment:
      MYSQL_ROOT_PASSWORD: azerust
    ports:
      - "3306:3306"
    volumes:
      - ./schema:/docker-entrypoint-initdb.d:Z
      - ./data:/var/lib/mysql:Z
  jaeger:
    image: "jaegertracing/all-in-one"
    ports:
      - "6831:6831/udp"
      - "16686:16686"

```

`license.md`:

```md
# The MIT License (MIT)

Copyright © `2020` `Alexander Lyon`

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the “Software”), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

```

`pg/Dockerfile`:

```
FROM postgres:17

RUN apt-get update && apt-get install -y \
    build-essential \
    git \
    postgresql-server-dev-all \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /tmp
RUN git clone https://github.com/arlyon/pguint.git

WORKDIR /tmp/pguint
RUN make
RUN make install

```

`readme.md`:

```md
# azerust

Azerust is an experimental WoW server emulator for patch 3.3.5
written in Rust. Currently, it only implements the auth server.
It is currently being built to be compatible (read: piggy back
on top of) the TrinityCore database. Note, however, that we use
mariadb in the docker-compose file. Our goals are:

- fast
- readable
- safe
- concise

> **Note:** For the time being this relies on nightly for the
> `arbitrary_enum_discriminant` feature, which simplifies
> serialization / deserialization.

## Getting Started

This project uses [`cargo-make`](https://github.com/sagiegurari/cargo-make)
for scripting / tasks. It also uses the latest nightly compiler
however this is only to speed up compilation.

### Configuration

You will need to provide some configs. Run the `init` command on
the world and auth server to generate configs for them.

### Docker

The simplest method to kickstart is to just use docker compose.
To set up the database, you can use a docker compose file we have
available. We need to populate a schema, for which we piggy back
off the incredible Trinitycore project.

```bash
> cargo make fetch-db
> docker compose --profile server up
```

The downloaded SQL scripts will be used to set up the databases.
You will also need to create a `config-auth-compose.yml` and a
`confit-world-compose.yml` file which are used by docker-compose.

### Building

We statically check our queries against the database to ensure
type safety across the board. This means we depend on access to
certain information from our database. Obviously spinning up a
db every time you build is cumbersome, so there are two options:

`.env`

```bash
DATABASE_URL=mysql://localhost/auth
# or
SQLX_OFFLINE=true
```

Setting `DATABASE_URL` dynamically updates queries as we go, while
the `SQLX_OFFLINE` option uses the data in `sqlx-data.json`. This
should always be up to date. If the queries change at any time, we
will need to regenerate this file from the live database. To do
this, use the make command:

```bash
cargo make prepare
```

The next part is easy. Provide the `--release` flag if you want to
make it go fast.

```bash
cargo make auth
# or
cargo run --bin azerust-auth --release
```

### Logging

You can use the [RUST_LOG env var](https://rust-lang-nursery.github.io/rust-cookbook/development_tools/debugging/config_log.html) to configure log levels.
For example, we can enable debug mode for the azerust packages:

```bash
RUST_LOG=azerust_auth,azerust_world=debug
```

## Account Creation

To create a command, you can use the `exec` command to run commands
against the database.

```bash
cargo make auth exec account create <username> <password> <email>
```

```

`rust-toolchain`:

```
nightly
```

`rustfmt.toml`:

```toml
reorder_imports = true
imports_granularity = "Crate"
newline_style = "Unix"
group_imports = "StdExternalCrate"
max_width = 160

```

`services/auth/Cargo.toml`:

```toml
[package]
authors = ["Alexander Lyon <arlyon@me.com>"]
edition = "2024"
license = "MIT OR Apache-2.0"
name = "azerust-auth"
version = "0.1.0"

[dependencies]
async-trait = "0.1"
tokio = { version = "1", features = ["macros", "rt-multi-thread", "tracing"] }

bincode = "2.0.0-dev"
serde = { version = "1", features = ["derive"] }
serde_yaml = "0.9"

derivative = "2"
derive_more = "0.99"

anyhow = "1"
human-panic = "2"
thiserror = "1"

assert-size-attribute = { path = "../../crates/assert-size-attribute" }
lazy_static = "1"
num-bigint = "0.4"
num_enum = "0.5"
rand = "0.8"
static_assertions = "1"
structopt = "0.3"

opentelemetry = "0.17.0"
opentelemetry-jaeger = { version = "0.16.0", features = ["rt-tokio"] }
tracing = "0.1"
tracing-opentelemetry = "0.17"
tracing-subscriber = "0.3"

azerust-axum = { path = "../../crates/axum" }
azerust-game = { path = "../../crates/game" }
azerust-pg-auth = { path = "../../crates/pg-auth" }
azerust-utils = { path = "../../crates/utils" }
# console-subscriber = "0.1.1"
enumflags2 = "0.7.0-preview1"
futures-util = "0.3.19"
tokio-stream = { version = "0.1.8", features = ["net", "time"] }
wow-srp = { path = "../../crates/wow-srp" }
ctrlc-async = "3.2.2"
tokio-util = "0.7.4"
wow_login_messages = { version = "0.5.0", features = ["tokio"] }
deadpool-postgres = "0.12.0"
tokio-postgres = "0.7.12"
deadpool = "0.10"
postgres = "0.19.9"
postgres-native-tls = "0.5.0"
# console-subscriber = "0.4.1"

[dev-dependencies]
test-case = "1"

```

`services/auth/src/authserver.rs`:

```rs
use std::{
    collections::HashMap,
    fmt, iter,
    net::Ipv4Addr,
    sync::Arc,
    time::{Duration, Instant},
};

use anyhow::{Context, Result, bail};
use azerust_game::{
    accounts::{AccountService, ConnectToken, ReconnectToken},
    realms::{RealmFlags, RealmList},
};
use azerust_utils::flatten;
use derivative::Derivative;
use derive_more::Display;
use futures_util::StreamExt;
use tokio::{
    net::{TcpListener, TcpStream},
    sync::RwLock,
    time::interval,
    try_join,
};
use tokio_stream::{
    iter,
    wrappers::{IntervalStream, TcpListenerStream},
};
use tokio_util::sync::CancellationToken;
use tracing::{Level, debug, error, info, instrument, trace, warn};
use wow_login_messages::{
    Message,
    all::{CMD_AUTH_LOGON_CHALLENGE_Client, CMD_AUTH_RECONNECT_CHALLENGE_Client},
    version_8::{
        self, AccountFlag, CMD_AUTH_LOGON_CHALLENGE_Server, CMD_AUTH_LOGON_CHALLENGE_Server_SecurityFlag, CMD_AUTH_LOGON_PROOF_Client,
        CMD_AUTH_LOGON_PROOF_Server, CMD_AUTH_RECONNECT_CHALLENGE_Server, CMD_AUTH_RECONNECT_PROOF_Client, CMD_AUTH_RECONNECT_PROOF_Server,
        CMD_REALM_LIST_Server, LoginResult,
        opcodes::{ClientOpcodeMessage, ServerOpcodeMessage},
    },
};

pub const VERSION_CHALLENGE: [u8; 16] = [0xBA, 0xA3, 0x1E, 0x99, 0xA0, 0x0B, 0x21, 0x57, 0xFC, 0x37, 0x3F, 0xB3, 0x69, 0xCD, 0xD2, 0xF1];

/// Models the various valid states of the server.
#[derive(Derivative, Display)]
#[derivative(PartialEq, Debug)]
pub enum RequestState {
    /// The initial state, nothing has been provided.
    Start,

    /// The server receives a connect request and generates a challenge.
    #[display(fmt = "ConnectChallenge")]
    ConnectChallenge {
        #[derivative(Debug = "ignore")]
        token: ConnectToken,
        username: String,
    },

    #[display(fmt = "ReconnectChallenge")]
    ReconnectChallenge { token: ReconnectToken },

    // the server sends the challenge and gets a proof. this results
    // in either the authenticated or rejected states.
    /// The server has accepted the request.
    Realmlist,

    /// The server has rejected the request.
    #[display(fmt = "Rejected")]
    Rejected(ServerOpcodeMessage),
}

/// Implements a WoW authentication server.
#[derive(Debug)]
pub struct AuthServer<T: AccountService + fmt::Debug, R: RealmList> {
    accounts: T,
    realms: R,
    heartbeat: Arc<RwLock<HashMap<u8, Instant>>>,
}

impl<T: Clone + AccountService + fmt::Debug, R: Clone + RealmList> Clone for AuthServer<T, R> {
    fn clone(&self) -> Self {
        Self {
            accounts: self.accounts.clone(),
            realms: self.realms.clone(),
            heartbeat: self.heartbeat.clone(),
        }
    }
}

impl<T: AccountService + fmt::Debug + Clone + 'static, R: RealmList + Clone + 'static> AuthServer<T, R> {
    pub fn new(accounts: T, realms: R) -> Self {
        Self {
            accounts,
            realms,
            heartbeat: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    #[instrument(skip(self, host))]
    pub async fn world_server_heartbeat(&self, host: Ipv4Addr, port: u16) -> Result<()> {
        let socket = tokio::net::UdpSocket::bind((host, port)).await?;

        let mut buffer = [0u8; 6];

        fn parse([a, b, c, d, e, f]: [u8; 6]) -> (u8, u8, u32) {
            (a, b, u32::from_be_bytes([c, d, e, f]))
        }

        loop {
            if socket.recv(&mut buffer).await.is_err() {
                warn!("received larger packet than expected");
                continue;
            };

            match parse(buffer) {
                (0u8, realm_id, realm_pop) => {
                    self.heartbeat.write().await.insert(realm_id, Instant::now());
                    trace!("got heartbeat for {realm_id} with realm pop {realm_pop}")
                }
                _ => debug!("received bad buffer: {:02X?}", &buffer),
            };
        }
    }

    /// updates the realmlist based on recently received heartbeats
    #[instrument(skip(self))]
    pub async fn realmlist_updater(&self) -> Result<()> {
        let instant = iter(iter::from_fn(|| Some(Instant::now())));
        let mut interval = IntervalStream::new(interval(Duration::from_secs(5))).zip(instant);
        while let Some((_, now)) = interval.next().await {
            let span = tracing::span!(Level::TRACE, "update_realmlist");
            let _guard = span.enter();
            let data = {
                let mut write = self.heartbeat.write().await;
                let mut data = Vec::with_capacity(write.len());
                data.extend(
                    write
                        .extract_if(|_, v| now.saturating_duration_since(*v).as_secs() > 15)
                        .map(|(k, _)| (k, RealmFlags::Offline)),
                );
                data.extend(write.keys().map(|&k| (k, RealmFlags::Recommended)));
                data
            };
            trace!("updating realm populations: {:?}", data);
            if let Err(r) = self.realms.update_status(data).await {
                error!("error while updating realm populations: {r}");
            }
        }
        Ok(())
    }

    #[instrument(skip(self, host, port))]
    pub async fn authentication(&self, host: Ipv4Addr, port: u16) -> Result<()> {
        let addr = (host, port);
        let listener = TcpListener::bind(&addr).await?;

        info!("listening on {:?}", &addr);

        let mut connections = TcpListenerStream::new(listener);
        // let id = Span::current().id().unwrap();
        while let Some(Ok(mut stream)) = connections.next().await {
            tokio::task::Builder::new()
                .name(&format!(
                    "auth::connect[{}]",
                    stream.peer_addr().map(|a| a.to_string()).unwrap_or_else(|_| "unknown".to_string())
                ))
                .spawn({
                    let server = self.to_owned();
                    // let id = id.clone();
                    async move {
                        if let Err(e) = server.connect_loop(&mut stream).await {
                            error!("error handling request: {e}")
                        }
                    }
                })?;
        }

        Ok(())
    }

    #[instrument(skip(self, stream))]
    async fn connect_loop(&self, mut stream: &mut TcpStream) -> Result<()> {
        let mut state = RequestState::Start;

        loop {
            let message = ClientOpcodeMessage::tokio_read(&mut stream).await?;

            debug!("received message {message} in state {state}");
            state = match (state, message) {
                (_, ClientOpcodeMessage::CMD_AUTH_LOGON_CHALLENGE(r)) => handle_connect_request(&r, &self.accounts, stream).await?,
                (_, ClientOpcodeMessage::CMD_AUTH_RECONNECT_CHALLENGE(r)) => handle_reconnect_request(&r, &self.accounts, stream).await?,
                (RequestState::ConnectChallenge { token, username }, ClientOpcodeMessage::CMD_AUTH_LOGON_PROOF(proof)) => {
                    handle_connect_proof(username, &proof, &self.accounts, &token, stream).await?
                }
                (RequestState::ReconnectChallenge { token }, ClientOpcodeMessage::CMD_AUTH_RECONNECT_PROOF(proof)) => {
                    handle_reconnect_proof(&proof, &self.accounts, &token, stream).await?
                }
                (RequestState::Realmlist, ClientOpcodeMessage::CMD_REALM_LIST(_)) => handle_realmlist(&self.realms, stream).await?,
                (_, ClientOpcodeMessage::CMD_AUTH_LOGON_PROOF(_) | ClientOpcodeMessage::CMD_AUTH_RECONNECT_PROOF(_)) => {
                    bail!("received proof before request")
                }
                _ => bail!("received message in bad state"),
            };

            if let RequestState::Rejected(message) = state {
                match message {
                    ServerOpcodeMessage::CMD_AUTH_LOGON_CHALLENGE(msg) => {
                        msg.tokio_write(stream).await?;
                    }
                    ServerOpcodeMessage::CMD_AUTH_LOGON_PROOF(msg) => {
                        msg.tokio_write(stream).await?;
                    }
                    ServerOpcodeMessage::CMD_AUTH_RECONNECT_CHALLENGE(msg) => {
                        msg.tokio_write(stream).await?;
                    }
                    ServerOpcodeMessage::CMD_AUTH_RECONNECT_PROOF(msg) => {
                        msg.tokio_write(stream).await?;
                    }
                    _ => bail!("received message in bad state"),
                }

                // wait a little before closing the connection, otherwise the client will
                // display a connection error rather than our rejection
                tokio::time::sleep(Duration::from_secs(10)).await;

                break;
            }
        }

        Ok(())
    }
}

impl<T: 'static + AccountService + fmt::Debug + Send + Sync + Clone, R: 'static + RealmList + Send + Sync + Clone> AuthServer<T, R> {
    pub async fn start(self, host: Ipv4Addr, port: u16, heartbeat_port: u16, stop: CancellationToken) -> Result<()> {
        let server = Arc::new(self);

        let a = flatten(tokio::task::Builder::new().name("auth::server").spawn({
            let server = server.clone();
            async move { server.authentication(host, port).await.context("server error") }
        })?);
        let b = flatten(tokio::task::Builder::new().name("auth::heartbeat").spawn({
            let server = server.clone();
            async move { server.world_server_heartbeat(host, heartbeat_port).await.context("hearthbeat error") }
        })?);
        let c = flatten(tokio::task::Builder::new().name("auth::realmlist").spawn({
            let server = server.clone();
            async move { server.realmlist_updater().await.context("realmlist error") }
        })?);

        let d = async {
            stop.cancelled().await;
            Result::<()>::Err(anyhow::anyhow!("cancelled"))
        };

        try_join!(a, b, c, d)?;

        Ok(())
    }
}

#[instrument(skip(request, accounts, stream))]
async fn handle_connect_request(request: &CMD_AUTH_LOGON_CHALLENGE_Client, accounts: &impl AccountService, stream: &mut TcpStream) -> Result<RequestState> {
    if request.version.build != 12340 {
        return Ok(RequestState::Rejected(ServerOpcodeMessage::CMD_AUTH_LOGON_CHALLENGE(
            CMD_AUTH_LOGON_CHALLENGE_Server::FailVersionInvalid,
        )));
    };

    debug!("auth challenge for {}", request.account_name);

    let (state, response) = match accounts.initiate_login(&request.account_name).await {
        Ok(token) => (
            RequestState::ConnectChallenge {
                token,
                username: request.account_name.to_owned(),
            },
            CMD_AUTH_LOGON_CHALLENGE_Server::Success {
                security_flag: CMD_AUTH_LOGON_CHALLENGE_Server_SecurityFlag::new(token.get_security_flags(), None, None, None),
                salt: token.get_salt().0,
                server_public_key: *token.get_b_pub(),
                generator: token.get_g(),
                large_safe_prime: token.get_n(),
                crc_salt: VERSION_CHALLENGE,
            },
        ),
        Err(reason) => {
            trace!("rejecting due to {:?}", reason);
            return Ok(RequestState::Rejected(ServerOpcodeMessage::CMD_AUTH_LOGON_CHALLENGE(reason.into())));
        }
    };

    trace!("writing response");
    response.tokio_write(stream).await?;
    trace!("written");

    Ok(state)
}

#[instrument(skip(proof, accounts, token, stream))]
async fn handle_connect_proof(
    username: String,
    proof: &CMD_AUTH_LOGON_PROOF_Client,
    accounts: &impl AccountService,
    token: &ConnectToken,
    stream: &mut TcpStream,
) -> Result<RequestState> {
    let (state, response) = match accounts.complete_login(username, token, &proof.client_public_key, &proof.client_proof).await {
        Ok(server_proof) => (RequestState::Realmlist, CMD_AUTH_LOGON_PROOF_Server::Success {
            account_flag: AccountFlag::new_propass(), // same a MANGOS
            hardware_survey_id: 0,
            unknown: 0,
            server_proof,
        }),
        Err(reason) => {
            return Ok(RequestState::Rejected(ServerOpcodeMessage::CMD_AUTH_LOGON_CHALLENGE(reason.into())));
        }
    };

    response.tokio_write(stream).await?;

    Ok(state)
}

#[instrument(skip(request, accounts))]
async fn handle_reconnect_request(
    request: &CMD_AUTH_RECONNECT_CHALLENGE_Client,
    accounts: &impl AccountService,
    stream: &mut TcpStream,
) -> Result<RequestState> {
    if request.version.build != 12340 {
        return Ok(RequestState::Rejected(ServerOpcodeMessage::CMD_AUTH_RECONNECT_CHALLENGE(
            CMD_AUTH_RECONNECT_CHALLENGE_Server::FailVersionInvalid,
        )));
    };

    let token = match accounts.initiate_relogin(&request.account_name).await {
        Ok(token) => token,
        Err(reason) => {
            return Ok(RequestState::Rejected(ServerOpcodeMessage::CMD_AUTH_LOGON_CHALLENGE(reason.into())));
        }
    };

    CMD_AUTH_RECONNECT_CHALLENGE_Server::Success {
        challenge_data: token.reconnect_proof,
        checksum_salt: VERSION_CHALLENGE,
    }
    .tokio_write(stream)
    .await?;

    Ok(RequestState::ReconnectChallenge { token })
}

#[instrument(skip(proof, accounts, token, stream))]
async fn handle_reconnect_proof(
    proof: &CMD_AUTH_RECONNECT_PROOF_Client,
    accounts: &impl AccountService,
    token: &ReconnectToken,
    stream: &mut TcpStream,
) -> Result<RequestState> {
    let (state, response) = match accounts.complete_relogin(token, &proof.proof_data, &proof.client_proof).await {
        Ok(_) => (RequestState::Realmlist, CMD_AUTH_RECONNECT_PROOF_Server { result: LoginResult::Success }),
        Err(reason) => {
            return Ok(RequestState::Rejected(ServerOpcodeMessage::CMD_AUTH_LOGON_CHALLENGE(reason.into())));
        }
    };

    debug!("user has reauthenticated");
    response.tokio_write(stream).await?;

    Ok(state)
}

#[instrument(skip(realms, stream))]
async fn handle_realmlist(realms: &impl RealmList, stream: &mut TcpStream) -> Result<RequestState> {
    let realms = realms
        .realms()
        .await?
        .iter()
        .map(|r| version_8::Realm {
            realm_type: match r.realm_type {
                azerust_game::realms::RealmType::Normal => version_8::RealmType::PlayerVsEnvironment,
                azerust_game::realms::RealmType::PVP => version_8::RealmType::PlayerVsPlayer,
                azerust_game::realms::RealmType::RP => version_8::RealmType::Roleplaying,
                azerust_game::realms::RealmType::RPPvP => version_8::RealmType::RoleplayingPlayerVsPlayer,
            },
            address: format!("{}:{}", r.external_address, r.port),
            name: r.name.clone(),
            locked: false, // todo: calculate this
            realm_id: r.id.0 as u8,
            number_of_characters_on_realm: 0, // todo: calculate this
            category: version_8::RealmCategory::One,
            ..Default::default()
        })
        .collect::<Vec<_>>();

    tracing::trace!("sending {} realms", realms.len());

    CMD_REALM_LIST_Server { realms }.tokio_write(stream).await?;

    Ok(RequestState::Realmlist)
}

```

`services/auth/src/conf.rs`:

```rs
use std::{net::Ipv4Addr, path::PathBuf};

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug)]
pub struct AuthServerConfig {
    pub bind_address: Ipv4Addr,
    pub port: u16,
    pub heartbeat_port: u16,
    pub api_port: Option<u16>,
    pub console_port: Option<u16>,

    pub auth_database: String,
}

impl AuthServerConfig {
    pub async fn read(path: &PathBuf) -> Result<Self> {
        let file = std::fs::File::open(path).with_context(|| format!("could not open config at {:?}", path.as_os_str()))?;
        serde_yaml::from_reader(file).context("could not read yaml file")
    }

    pub async fn write(&self, path: &PathBuf) -> Result<()> {
        let file = std::fs::File::create(path)?;
        serde_yaml::to_writer(file, self).context("could not write yaml file")
    }
}

```

`services/auth/src/main.rs`:

```rs
#![feature(hash_extract_if)]
#![forbid(unsafe_code)]
#![deny(
    missing_debug_implementations,
    missing_copy_implementations,
    trivial_casts,
    trivial_numeric_casts,
    unused_import_braces,
    unused_qualifications,
    clippy::useless_conversion,
    clippy::unwrap_used,
    clippy::todo,
    clippy::unimplemented
)]

use std::{
    net::{Ipv4Addr, SocketAddr},
    time::Duration,
};

use anyhow::{Result, anyhow};
use azerust_axum::auth_api;
use azerust_game::accounts::AccountService;
use azerust_pg_auth::{PgAccountService, PgRealmList};
use azerust_utils::flatten;
use conf::AuthServerConfig;
use deadpool_postgres::{Runtime, tokio_postgres::NoTls};
use human_panic::setup_panic;
use structopt::StructOpt;
use tokio::try_join;
use tokio_util::sync::CancellationToken;
use tracing::{error, info};
use tracing_subscriber::{filter, prelude::*};

use crate::{
    authserver::AuthServer,
    opt::{AccountCommand, Opt},
};

mod authserver;
mod conf;
mod opt;

#[tokio::main]
async fn main() -> Result<()> {
    setup_panic!();

    let opts = Opt::from_args();
    let config = AuthServerConfig::read(&opts.config).await?;

    // let tracer = opentelemetry_jaeger::new_pipeline()
    //     .with_service_name("auth")
    //     .install_simple()?;

    let fmt_filter = std::env::var("RUST_LOG")
        .ok()
        .and_then(|log_filter| match log_filter.parse::<filter::Targets>() {
            Ok(targets) => Some(targets),
            Err(e) => {
                eprintln!("failed to parse filter environment variable `RUST_LOG={:?}`: {}", log_filter, e);
                None
            }
        })
        .unwrap_or_else(|| "error".parse::<filter::Targets>().expect("`error` filter should always parse successfully"));

    if let Some(_port) = config.console_port {
        tracing_subscriber::registry()
            // .with(console_subscriber::ConsoleLayer::builder().server_addr((config.bind_address, port)).spawn())
            // .with(tracing_opentelemetry::layer().with_tracer(tracer))
            .with(tracing_subscriber::fmt::layer().with_filter(fmt_filter))
            .init();
    } else {
        tracing_subscriber::registry()
            // .with(tracing_opentelemetry::layer().with_tracer(tracer))
            .with(tracing_subscriber::fmt::layer().with_filter(fmt_filter))
            .init();
    };

    match opts.command {
        Some(opt::OptCommand::Exec(c)) => match c {
            opt::Command::Account {
                command: AccountCommand::Create { username, password, email },
            } => {
                let mut pool_cfg = deadpool_postgres::Config::new();
                pool_cfg.url = Some(config.auth_database);
                pool_cfg.connect_timeout = Some(Duration::from_secs(1));
                let pool = pool_cfg.create_pool(Some(Runtime::Tokio1), NoTls).unwrap();
                let accounts = PgAccountService::new(pool);
                match accounts.create_account(&username, &password, &email).await {
                    Ok(id) => println!("created account {id}"),
                    Err(e) => eprintln!("failed to create account: {e}"),
                };
            }
        },
        Some(opt::OptCommand::Init) => {
            let auth = AuthServerConfig {
                bind_address: "0.0.0.0".parse::<Ipv4Addr>().expect("Valid IP"),
                port: 3724,
                heartbeat_port: 1234,
                api_port: None,
                console_port: None,
                auth_database: "postgresql://postgres:postgres@localhost/postgres".to_string(),
            };
            auth.write(&opts.config).await?;
        }
        None => match start_server(config).await {
            Ok(_) => {}
            Err(e) => error!("server shutting down: {}", e),
        },
    };

    info!("uploading spans");
    opentelemetry::global::shutdown_tracer_provider(); // export remaining spans

    Ok(())
}

async fn start_server(
    AuthServerConfig {
        bind_address,
        api_port,
        heartbeat_port,
        port,
        auth_database,
        ..
    }: AuthServerConfig,
) -> Result<()> {
    let mut pool_cfg = deadpool_postgres::Config::new();
    pool_cfg.url = Some(auth_database.clone());
    pool_cfg.connect_timeout = Some(Duration::from_secs(3));
    let pool = pool_cfg.create_pool(Some(Runtime::Tokio1), NoTls).unwrap();

    let accounts = PgAccountService::new(pool.clone());
    let realms = PgRealmList::new(pool.clone(), Duration::from_secs(10));

    let server = AuthServer::new(accounts.clone(), realms.clone());

    let cancel = CancellationToken::new();

    let c2 = cancel.clone();
    ctrlc_async::set_handler(move || c2.cancel())?;

    if let Some(api_port) = api_port {
        let addr = SocketAddr::new(bind_address.into(), api_port);
        let api = flatten(tokio::task::Builder::new().name("auth::graphql").spawn(async move {
            auth_api(&addr, accounts.clone(), realms.clone())
                .await
                .map_err(|_| anyhow!("failed to start graphql api"))
        })?);

        try_join!(server.start(bind_address, port, heartbeat_port, cancel), api)?;
    } else {
        server.start(bind_address, port, heartbeat_port, cancel).await?;
    }

    Ok(())
}

```

`services/auth/src/opt.rs`:

```rs
use std::path::PathBuf;

use structopt::StructOpt;

/// An authentication server for Wrath of the Lich King.
/// Run with no arguments to start the server.
#[derive(StructOpt, Debug)]
pub struct Opt {
    #[structopt(default_value = "config.yaml")]
    pub config: PathBuf,

    #[structopt(subcommand)]
    pub command: Option<OptCommand>,
}

#[derive(StructOpt, Debug)]
pub enum OptCommand {
    /// Execute a command directly.
    Exec(Command),
    /// Generate a new config file.
    Init,
}

#[derive(StructOpt, Debug)]
pub enum Command {
    Account {
        #[structopt(subcommand)]
        command: AccountCommand,
    },
}

/// Commands for managing accounts
#[derive(StructOpt, Debug)]
pub enum AccountCommand {
    /// Create a new account
    Create {
        /// The username of the new account
        username: String,
        /// The password to use
        password: String,
        /// The email address
        email: String,
    },
}

```

`services/mpqextract/Cargo.toml`:

```toml
[package]
name = "mpqextract"
version = "0.1.0"
edition = "2024"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
anyhow = "1.0.65"
clap = { version = "3.2.22", features = ["clap_derive", "derive"] }
mpq = "0.7.0"
rayon = "1.5.3"

```

`services/mpqextract/src/main.rs`:

```rs
use std::{ffi::OsStr, path::PathBuf};

use clap::{Parser, Subcommand};
use mpq::Archive;
use rayon::prelude::*;

/// Extract data from MPQ files
#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct Opts {
    #[clap(subcommand)]
    command: Command,

    /// Plain output (useful for other tools)
    #[clap(short)]
    plain: bool,
}

#[derive(Debug, Subcommand)]
enum Command {
    /// List the (merged) files and exit
    List {
        /// Paths to ignore
        #[clap(short)]
        exclude: Vec<String>,

        /// Paths to include
        #[clap(short)]
        include: Vec<String>,

        paths: Vec<PathBuf>,
    },
    /// Extract the files to a destination.
    Extract {
        /// Paths to ignore
        #[clap(short)]
        exclude: Vec<String>,

        /// Paths to include
        #[clap(short)]
        include: Vec<String>,

        /// The destination folder to extract into.
        dest: PathBuf,

        /// The mpq files to extract.
        paths: Vec<PathBuf>,
    },
}

fn main() -> anyhow::Result<()> {
    let opts = Opts::parse();

    match opts.command {
        Command::List { paths, exclude: _, include } => {
            for path in paths {
                let mut header_written = false;

                let mut a = Archive::open(&path).unwrap();
                let file = a.open_file("(listfile)")?;

                let mut buf: Vec<u8> = vec![0; file.size() as usize];
                file.read(&mut a, &mut buf).unwrap();
                let string = std::str::from_utf8(&buf)?;

                for file in string
                    .lines()
                    // .filter(|p| exclude.iter().any(|test| !p.contains(test)))
                    .filter(|p| {
                        if include.is_empty() {
                            true
                        } else {
                            include.iter().all(|test| p.contains(test))
                        }
                    })
                {
                    if !header_written {
                        if let Some(name) = path.file_name().and_then(OsStr::to_str) {
                            println!("\u{001b}[32m{}\u{001b}[0m", name)
                        }
                        header_written = true;
                    }

                    println!("\u{001b}[30m- {}\u{001b}[0m", file);
                }
            }
        }
        Command::Extract {
            paths,
            dest,
            exclude: _,
            include,
        } => {
            paths
                .par_iter()
                .map(|path| {
                    // let header_written = false;

                    let mut a = Archive::open(path)?;

                    let buf = {
                        let file = a.open_file("(listfile)")?;
                        let mut buf: Vec<u8> = vec![0; file.size() as usize];
                        file.read(&mut a, &mut buf).unwrap();
                        buf
                    };

                    let string = std::str::from_utf8(&buf)?;
                    for file_name in string
                        .lines()
                        // .filter(|p| exclude.iter().any(|test| !p.contains(test)))
                        .filter(|p| {
                            if include.is_empty() {
                                true
                            } else {
                                include.iter().all(|test| p.contains(test))
                            }
                        })
                    {
                        println!("extracting {}", file_name);
                        let file = a.open_file(file_name)?;
                        file.extract(&mut a, dest.join(file_name.replace("\\", "/"))).unwrap();
                    }

                    Ok(())
                })
                .collect::<anyhow::Result<Vec<_>>>()
                .unwrap();
        }
    }

    Ok(())
}

```

`services/world/Cargo.toml`:

```toml
[package]
authors = ["Alexander Lyon <arlyon@me.com>"]
edition = "2024"
license = "MIT OR Apache-2.0"
name = "azerust-world"
version = "0.1.0"

[dependencies]
anyhow = "1"
azerust-axum = { version = "0.1.0", path = "../../crates/axum" }
azerust-game = { path = "../../crates/game" }
azerust-pg-auth = { path = "../../crates/pg-auth" }
azerust-pg-characters = { path = "../../crates/pg-characters" }
azerust-utils = { path = "../../crates/utils" }
bevy = { version = "0.15.0", default-features = false }
bincode = "2.0.0-dev"
# console-subscriber = "0.1.1"
ctrlc-async = "3.2.2"
deadpool-postgres = "0.12.0"
derive_more = "0.99.16"
flate2 = "1.0.22"
futures = "0.3.17"
generic-global-variables = "0.1.2"
human-panic = "2"
num_enum = "0.5.4"
opentelemetry = "0.17.0"
opentelemetry-jaeger = { version = "0.16.0", features = ["rt-tokio"] }
rand = "0.8.4"
rust-crypto = "0.2"
serde = "1"
serde_yaml = "0.9"
sha-1 = "0.9"
structopt = "0.3"
time = "0.3.36"
tokio = { version = "1", features = ["macros", "rt-multi-thread", "tracing"] }
tokio-stream = { version = "0.1.8", features = ["net", "time"] }
tokio-util = "0.7.4"
tracing = "0.1"
tracing-opentelemetry = "0.17"
tracing-subscriber = "0.3"
wow_srp = "0.7"
wow_world_messages = { version = "0.3.0", features = ["tokio", "wrath"] }

```

`services/world/src/client.rs`:

```rs
use azerust_game::accounts::AccountId;
use rand::{distributions::Standard, prelude::Distribution};

#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub struct ClientId(pub u64);

impl Distribution<ClientId> for Standard {
    fn sample<R: rand::Rng + ?Sized>(&self, rng: &mut R) -> ClientId {
        ClientId(rng.r#gen())
    }
}

/// contains identifying information about a connected client
#[derive(Copy, Clone)]
#[allow(unused)]
pub struct Client {
    pub id: ClientId,
    pub account: Option<AccountId>,
}

```

`services/world/src/conf.rs`:

```rs
use std::{net::Ipv4Addr, path::PathBuf};

use anyhow::{Context, Result};
use azerust_game::realms::RealmId;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug)]
pub struct WorldServerConfig {
    pub bind_address: Ipv4Addr,
    pub port: u32,
    pub console_port: Option<u16>,
    pub api_port: Option<u16>,

    pub auth_server_address: String,

    pub character_database: String,
    pub auth_database: String,
    pub world_database: String,

    pub realm_id: RealmId,
    pub data_dir: u32,
}

impl WorldServerConfig {
    pub async fn read(path: &PathBuf) -> Result<Self> {
        let file = std::fs::File::open(path).with_context(|| format!("could not open config at {:?}", path.as_os_str()))?;
        serde_yaml::from_reader(file).context("could not read yaml file")
    }

    pub async fn write(&self, path: &PathBuf) -> Result<()> {
        let file = std::fs::File::create(path)?;
        serde_yaml::to_writer(file, self).context("could not write yaml file")
    }
}

```

`services/world/src/main.rs`:

```rs
#![feature(box_patterns)]
#![forbid(unsafe_code)]
#![deny(
    missing_debug_implementations,
    missing_copy_implementations,
    trivial_casts,
    trivial_numeric_casts,
    unused_import_braces,
    unused_qualifications,
    clippy::useless_conversion,
    clippy::unwrap_used,
    clippy::todo,
    clippy::unimplemented
)]

use std::{
    net::{Ipv4Addr, SocketAddr},
    time::Duration,
};

use anyhow::Result;
use azerust_axum::world_api;
use azerust_game::realms::RealmId;
use azerust_pg_auth::{PgAccountService, PgRealmList};
use azerust_pg_characters::PgCharacterService;
use azerust_utils::flatten;
use deadpool_postgres::{Runtime, tokio_postgres::NoTls};
use human_panic::setup_panic;
use structopt::StructOpt;
use tokio::try_join;
use tokio_util::sync::CancellationToken;
use tracing::{debug, error, info};
use tracing_subscriber::{Layer, filter, prelude::*};

use crate::{conf::WorldServerConfig, opt::Opt, worldserver::WorldServer};

mod client;
mod conf;
mod opt;
mod world;
mod worldserver;

#[tokio::main]
async fn main() -> Result<()> {
    setup_panic!();

    let opts: Opt = Opt::from_args();
    let config = WorldServerConfig::read(&opts.config).await?;

    // let tracer = opentelemetry_jaeger::new_pipeline().with_service_name("auth").install_simple()?;

    let fmt_filter = std::env::var("RUST_LOG")
        .ok()
        .and_then(|log_filter| match log_filter.parse::<filter::Targets>() {
            Ok(targets) => Some(targets),
            Err(e) => {
                eprintln!("failed to parse filter environment variable `RUST_LOG={:?}`: {}", log_filter, e);
                None
            }
        })
        .unwrap_or_else(|| "error".parse::<filter::Targets>().expect("`error` filter should always parse successfully"));

    if let Some(_port) = config.console_port {
        tracing_subscriber::registry()
            // .with(console_subscriber::ConsoleLayer::builder().server_addr((config.bind_address, port)).spawn())
            // .with(tracing_opentelemetry::layer().with_tracer(tracer))
            .with(tracing_subscriber::fmt::layer().with_filter(fmt_filter))
            .init();
    } else {
        tracing_subscriber::registry()
            // .with(tracing_opentelemetry::layer().with_tracer(tracer))
            .with(tracing_subscriber::fmt::layer().with_filter(fmt_filter))
            .init();
    };

    match opts.command {
        Some(opt::OptCommand::Init) => {
            let auth = WorldServerConfig {
                bind_address: "0.0.0.0".parse::<Ipv4Addr>().expect("Valid IP"),
                port: 3724,
                console_port: None,
                api_port: None,
                auth_server_address: "localhost:1234".to_string(),

                realm_id: RealmId(1),
                data_dir: 0,

                character_database: "postgresql://postgres:postgres@localhost/postgres".to_string(),
                auth_database: "postgresql://postgres:postgres@localhost/postgres".to_string(),
                world_database: "postgresql://postgres:postgres@localhost/postgres".to_string(),
            };
            auth.write(&opts.config).await?;
        }
        None => match start_server(config).await {
            Ok(_) => {}
            Err(e) => error!("server shutting down: {}", e),
        },
    };

    info!("uploading spans");
    opentelemetry::global::shutdown_tracer_provider(); // export remaining spans

    Ok(())
}

async fn start_server(config: WorldServerConfig) -> Result<()> {
    let mut pool_cfg = deadpool_postgres::Config::new();
    pool_cfg.url = Some(config.auth_database.clone());
    pool_cfg.connect_timeout = Some(Duration::from_secs(3));
    let auth_pool = pool_cfg.create_pool(Some(Runtime::Tokio1), NoTls).unwrap();

    let mut pool_cfg = deadpool_postgres::Config::new();
    pool_cfg.url = Some(config.character_database.clone());
    pool_cfg.connect_timeout = Some(Duration::from_secs(3));
    let character_pool = pool_cfg.create_pool(Some(Runtime::Tokio1), NoTls).unwrap();

    debug!("Loaded config {:?}", config);

    let accounts = PgAccountService::new(auth_pool.clone());
    let realms = PgRealmList::new(auth_pool.clone(), Duration::from_secs(60));
    let characters = PgCharacterService::new(character_pool.clone());

    let server = WorldServer::new(config.realm_id, accounts, realms, characters.clone(), config.auth_server_address);

    let cancel = CancellationToken::new();

    let c2 = cancel.clone();
    ctrlc_async::set_handler(move || c2.cancel())?;

    if let Some(api_port) = config.api_port {
        let addr = SocketAddr::new("0.0.0.0".parse().unwrap(), api_port);
        let api = flatten(
            tokio::task::Builder::new()
                .name("auth::graphql")
                .spawn(async move { world_api(&addr, characters).await.map_err(|_| anyhow::anyhow!("failed to start graphql api")) })?,
        );

        try_join!(server.start(cancel), api)?;
    } else {
        server.start(cancel).await?;
    }

    Ok(())
}

```

`services/world/src/opt.rs`:

```rs
use std::path::PathBuf;

use structopt::StructOpt;

/// A world server for Wrath of the Lich King.
/// Run with no arguments to start the server.
#[derive(StructOpt, Debug)]
pub struct Opt {
    #[structopt(default_value = "config.yaml")]
    pub config: PathBuf,

    #[structopt(subcommand)]
    pub command: Option<OptCommand>,
}

#[derive(StructOpt, Debug)]
pub enum OptCommand {
    /// Generate a new config file.
    Init,
}

```

`services/world/src/world/mod.rs`:

```rs
//! world
//!
//! This module defines a bevy ECS world that is used to drive the game.

use std::{collections::HashMap, sync::Arc, time::Duration};

use anyhow::{Result, anyhow};
use azerust_game::{
    Guid as GameGuid,
    accounts::AccountService,
    characters::{Character, CharacterId, CharacterService},
    realms::{RealmId, RealmList},
};
use bevy::{app::ScheduleRunnerPlugin, prelude::*, utils::HashSet};
use time::OffsetDateTime;
use tokio::{
    io::AsyncWriteExt,
    sync::{
        Mutex, RwLock,
        mpsc::{UnboundedReceiver, UnboundedSender},
    },
    task::JoinHandle,
};
use wow_srp::wrath_header::ServerEncrypterHalf;
use wow_world_messages::wrath::{
    MovementBlock, MovementBlock_UpdateFlag, MovementInfo, MovementInfo_MovementFlags, Object, ObjectType, Power, SMSG_UPDATE_OBJECT, UpdateMask, UpdatePlayer,
    Vector3d, opcodes::ServerOpcodeMessage,
};

#[allow(unused)]
pub struct World<A: AccountService, R: RealmList, C: CharacterService, W: AsyncWriteExt> {
    id: RealmId,
    accounts: A,
    realms: R,
    characters: C,
    sessions: Arc<RwLock<HashMap<CharacterId, Arc<Mutex<(ServerEncrypterHalf, W)>>>>>,
    start: OffsetDateTime,
    ecs_handle: JoinHandle<()>,
    connection_updates: UnboundedSender<ConnectionEvent>,
    movement_updates: UnboundedSender<MovementUpdate>,
    send_packets: UnboundedSender<(CharacterId, ServerOpcodeMessage)>,
    dump_packets: Mutex<Option<UnboundedReceiver<(CharacterId, ServerOpcodeMessage)>>>,
}

#[derive(Resource)]
struct ReceiverResource<T>(UnboundedReceiver<T>);

impl<A: AccountService, R: RealmList, C: CharacterService, W: AsyncWriteExt + Send + Unpin> World<A, R, C, W> {
    pub fn new(id: RealmId, accounts: A, realms: R, characters: C) -> Self {
        let (s_1, r_1) = tokio::sync::mpsc::unbounded_channel();
        let (s_2, r_2) = tokio::sync::mpsc::unbounded_channel();

        let handle = tokio::task::Builder::new().name("world::bevy").spawn_blocking(|| run_world(r_1, r_2)).unwrap();
        let (send_packets, dump_packets) = tokio::sync::mpsc::unbounded_channel();

        Self {
            id,
            accounts,
            realms,
            characters,
            sessions: Default::default(),
            start: OffsetDateTime::now_utc(),
            ecs_handle: handle,
            connection_updates: s_1,
            movement_updates: s_2,
            send_packets,
            dump_packets: Mutex::new(Some(dump_packets)),
        }
    }

    pub async fn packet_handler(&self) {
        let mut dump_packets = {
            let mut dump_packets = self.dump_packets.lock().await;
            dump_packets.take().unwrap()
        };

        while let Some((character_id, packet)) = dump_packets.recv().await {
            let sessions = self.sessions.read().await;
            if let Some(writer) = sessions.get(&character_id) {
                let (encrypter, writer) = &mut *writer.lock().await;
                packet.tokio_write_encrypted_server(writer, encrypter).await.unwrap();
            }
        }
    }

    pub async fn create_session(
        &self,
        character: Character,
        writer: Arc<Mutex<(ServerEncrypterHalf, W)>>,
    ) -> Result<(), (anyhow::Error, Arc<Mutex<(ServerEncrypterHalf, W)>>)> {
        {
            let mut sessions = self.sessions.write().await;
            if sessions.contains_key(&character.id) {
                return Err((anyhow!("account already logged in"), writer));
            }

            sessions.insert(character.id, writer);
        }

        tracing::info!("inserting connection");
        self.connection_updates
            .send(ConnectionEvent::Connection(
                Connection {
                    id: character.id,
                    class: character.class,
                    face: character.face,
                    facial_style: character.facial_style,
                    gender: character.gender,
                    hair_color: character.hair_color,
                    hair_style: character.hair_style,
                    map: character.map.as_int(),
                    name: character.name,
                    orientation: 0.0f32,
                    race: character.race,
                    skin_color: character.skin_color,
                    x: character.position_x,
                    y: character.position_y,
                    z: character.position_z,
                    zone: character.zone.as_int(),
                },
                PlayerBroadcast(character.id, self.send_packets.clone()),
            ))
            .unwrap();

        Ok(())
    }

    pub(crate) fn movement_update(&self, guid: CharacterId, data: MovementInfo) {
        self.movement_updates.send(MovementUpdate(guid, data)).unwrap();
    }

    pub(crate) async fn take_session(&self, id: CharacterId) {
        tracing::info!("removing connection");
        self.sessions.write().await.remove(&id);
        self.connection_updates.send(ConnectionEvent::Disconnection(id)).unwrap();
    }
}

fn run_world(receiver: UnboundedReceiver<ConnectionEvent>, receiver2: UnboundedReceiver<MovementUpdate>) {
    trace!("running world");
    App::new()
        .add_plugins(MinimalPlugins.set(ScheduleRunnerPlugin::run_loop(Duration::from_secs_f64(1.0 / 60.0))))
        .add_systems(FixedUpdate, update_position)
        .add_event::<ConnectionEvent>()
        .add_event::<MovementUpdate>()
        .add_systems(FixedUpdate, movement_update)
        .add_systems(FixedPreUpdate, drain_connection_updates)
        .add_systems(FixedPreUpdate, drain_movement_updates)
        .insert_resource(Time::<Fixed>::from_hz(10.0))
        .insert_resource(CharacterEntities(Default::default()))
        .insert_resource(ReceiverResource(receiver))
        .insert_resource(ReceiverResource(receiver2))
        .run();
    trace!("closing world");
}

fn drain_connection_updates(mut queue: ResMut<ReceiverResource<ConnectionEvent>>, mut events: EventWriter<ConnectionEvent>) {
    while let Ok(event) = queue.0.try_recv() {
        events.send(event);
    }
}

fn drain_movement_updates(mut queue: ResMut<ReceiverResource<MovementUpdate>>, mut events: EventWriter<MovementUpdate>) {
    while let Ok(event) = queue.0.try_recv() {
        events.send(event);
    }
}

pub struct Connection {
    pub id: CharacterId,
    pub name: String,
    pub race: wow_world_messages::wrath::Race,
    pub class: wow_world_messages::wrath::Class,
    pub gender: wow_world_messages::wrath::Gender,
    pub skin_color: u8,
    pub face: u8,
    pub hair_style: u8,
    pub hair_color: u8,
    pub facial_style: u8,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub orientation: f32,
    pub map: u32,
    pub zone: u32,
}

#[derive(Event)]
pub enum ConnectionEvent {
    Connection(Connection, PlayerBroadcast),
    Disconnection(CharacterId),
}

#[derive(Event)]
pub struct MovementUpdate(pub CharacterId, pub MovementInfo);

#[derive(Component, Eq, PartialEq, Hash)]
struct GameObject(GameGuid, UpdatePlayer);

impl Default for GameObject {
    fn default() -> Self {
        panic!("entities must have a guid")
    }
}

impl GameObject {
    pub fn update_mask(&self) -> UpdateMask {
        UpdateMask::Player(self.1.clone())
    }
}

#[derive(Resource)]
struct CharacterEntities(HashMap<CharacterId, Entity>);

type ServerMessageEvent = (CharacterId, ServerOpcodeMessage);

#[derive(Clone)]
pub struct PlayerBroadcast(pub CharacterId, pub UnboundedSender<ServerMessageEvent>);

impl PlayerBroadcast {
    pub fn send(&self, message: ServerOpcodeMessage) {
        if let Err(e) = self.1.send((self.0, message)) {
            tracing::error!("failed to send message: {e}");
        }
    }
}

#[derive(Component)]
#[require(Name, Position, GameObject)]
#[allow(unused)]
struct Player {
    broadcast: PlayerBroadcast,
    // this is infrequently updated
    tracked_guids: HashSet<GameGuid>,
    race: wow_world_messages::wrath::Race,
    class: wow_world_messages::wrath::Class,
    gender: wow_world_messages::wrath::Gender,
    skin_color: u8,
    face: u8,
    hair_style: u8,
    hair_color: u8,
    facial_style: u8,
}

#[derive(Component, Default)]
#[allow(unused)]
struct Name(String);

#[derive(Component)]
#[allow(unused)]
struct Position {
    x: f32,
    y: f32,
    z: f32,
    orientation: f32,
    #[allow(unused)]
    map: u32,
    #[allow(unused)]
    zone: u32,
}

impl Default for Position {
    fn default() -> Self {
        Self {
            x: -8949.94f32,
            y: -132.50f32,
            z: 83.53f32,
            orientation: 0.0,
            map: 0,
            zone: 1,
        }
    }
}

/// Add and remove players from the world
#[tracing::instrument(skip_all)]
fn update_position(
    mut commands: Commands,
    mut events: EventReader<ConnectionEvent>,
    mut movement: EventWriter<MovementUpdate>,
    mut players: ResMut<CharacterEntities>,
) {
    for event in events.read() {
        tracing::info!("connection event");
        match &event {
            ConnectionEvent::Connection(conn, broadcast) => {
                info!(id = conn.id.0, name = conn.name, "adding player");
                let _player = commands.spawn((
                    Player {
                        broadcast: broadcast.to_owned(),
                        class: conn.class,
                        race: conn.race,
                        gender: conn.gender,
                        skin_color: conn.skin_color,
                        face: conn.face,
                        hair_style: conn.hair_style,
                        hair_color: conn.hair_color,
                        facial_style: conn.facial_style,
                        tracked_guids: Default::default(),
                    },
                    Name(conn.name.to_owned()),
                    Position {
                        map: conn.map,
                        zone: conn.zone,
                        orientation: conn.orientation,
                        x: conn.x,
                        y: conn.y,
                        z: conn.z,
                    },
                    GameObject(
                        conn.id.into(),
                        UpdatePlayer::builder()
                            .set_object_guid(conn.id.into())
                            .set_unit_bytes_0(conn.race, conn.class, conn.gender, Power::Mana)
                            .set_object_scale_x(1.0)
                            .set_unit_health(100)
                            .set_unit_base_mana(100)
                            .set_unit_maxhealth(100)
                            .set_unit_level(1)
                            .set_unit_factiontemplate(1)
                            .set_unit_displayid(50)
                            .set_unit_nativedisplayid(50)
                            .finalize(),
                    ),
                ));

                movement.send(MovementUpdate(conn.id, MovementInfo {
                    fall_time: 0.0,
                    orientation: conn.orientation,
                    position: Vector3d {
                        x: conn.x,
                        y: conn.y,
                        z: conn.z,
                    },
                    flags: MovementInfo_MovementFlags::empty(),
                    timestamp: 0, // why??
                }));
            }
            ConnectionEvent::Disconnection(id) => {
                let character_entity = players.0.remove(id);
                info!(id = id.0, "removing player");
                if let Some(character_entity) = character_entity {
                    commands.entity(character_entity).despawn();
                }
            }
        }
    }
}

fn movement_update(mut events: EventReader<MovementUpdate>, mut players: Query<(&mut Position, &mut Player, &GameObject)>) {
    let events: Vec<_> = events.read().collect();

    for (mut pos, mut player, gameobject) in players.iter_mut() {
        let mut objects = Vec::new();

        for event in events.iter() {
            // TODO: limit to players in range
            let moved_guid = event.0.into();
            let player_guid = gameobject.0;

            let creating_self = player_guid == moved_guid;

            if creating_self {
                pos.x = event.1.position.x;
                pos.y = event.1.position.y;
                pos.z = event.1.position.z;
                pos.orientation = event.1.orientation;
            }

            let new_guid = player.tracked_guids.insert(moved_guid);

            if new_guid {
                tracing::debug!(
                    moved = moved_guid.guid(),
                    player = player_guid.guid(),
                    self = creating_self,
                    "tracking for first time"
                );
            }

            let movement_info = event.1.clone();

            let mut update_flag = MovementBlock_UpdateFlag::empty()
                .set_living(movement_info.to_movement_block_update_flag_living(
                    0.0,                  /* backwards_flight_speed */
                    4.5,                  /* backwards_running_speed */
                    0.0,                  /* backwards_swimming_speed */
                    0.0,                  /* flight_speed */
                    0.0,                  /* pitch_rate */
                    7.0,                  /* running_speed */
                    0.0,                  /* swimming_speed */
                    std::f32::consts::PI, /* turn_rate */
                    1.0,                  /* walking_speed */
                    None,                 /* spline_enabled */
                                          // 4.5,                  // MOVE_FLIGHT_BACK
                                          // 4.5,                  // MOVE_RUN_BACK
                                          // 2.5,                  // MOVE_SWIM_BACK
                                          // 7.0,                  // MOVE_FLIGHT
                                          // 3.14,                 // MOVE_PITCH_RATE
                                          // 7.0,                  // MOVE_RUN
                                          // 4.722222,             // MOVE_SWIM
                                          // std::f32::consts::PI, // MOVE_TURN_RATE
                                          // 2.5,                  // MOVE_WALK
                                          // None,                 /* spline_enabled */
                ))
                .set_high_guid(wow_world_messages::wrath::MovementBlock_UpdateFlag_HighGuid {
                    unknown0: if creating_self { 0x2F } else { 0x08 },
                });
            /*.set_LOW_GUID(wow_world_messages::wrath::MovementBlock_UpdateFlag_LowGuid {
            unknown1: object_guid.guid() as u32,
            })*/

            if creating_self {
                update_flag = update_flag.set_self()
            }

            //Copy the update mask and mark every field dirty, so that we send everything we need to know
            let mut all_dirty_update_mask = gameobject.update_mask();
            match all_dirty_update_mask {
                UpdateMask::Player(ref mut inner) => inner.mark_fully_dirty(),
                _ => unimplemented!(),
            }

            let update_type = if creating_self {
                Object::CreateObject2 {
                    guid3: moved_guid,
                    mask2: all_dirty_update_mask,
                    movement2: MovementBlock { update_flag },
                    object_type: ObjectType::Player,
                }
            } else {
                Object::CreateObject {
                    guid3: moved_guid,
                    mask2: all_dirty_update_mask,
                    movement2: MovementBlock { update_flag },
                    object_type: ObjectType::Player,
                }
            };

            objects.push(update_type);
        }
        player
            .broadcast
            .send(ServerOpcodeMessage::SMSG_UPDATE_OBJECT(Box::new(SMSG_UPDATE_OBJECT { objects })));
    }
}

```

`services/world/src/worldserver.rs`:

```rs
use std::{
    collections::HashMap,
    convert::TryInto,
    sync::{Arc, atomic::AtomicBool},
    time::{Duration, SystemTime, UNIX_EPOCH},
};

use anyhow::{Context, Result};
use azerust_game::{
    Guid,
    accounts::AccountService,
    characters::{CharacterCreate, CharacterId, CharacterService},
    realms::{RealmId, RealmList},
};
use azerust_utils::flatten;
use rand::Rng;
use tokio::{
    net::{TcpListener, TcpStream, UdpSocket, tcp::OwnedWriteHalf},
    sync::{Mutex, RwLock},
    time::interval,
    try_join,
};
use tokio_stream::{StreamExt, wrappers::TcpListenerStream};
use tokio_util::sync::CancellationToken;
use tracing::{error, info, instrument, warn};
use wow_srp::{normalized_string::NormalizedString, wrath_header::ProofSeed};
use wow_world_messages::{
    errors::ExpectedOpcodeError,
    wrath::{
        ActionButton, Area, ArenaType, BattlegroundType, BillingPlanFlags, CMSG_AUTH_SESSION, CacheMask, ClientMessage, ComplaintStatus, CreatureFamily,
        DungeonDifficulty, Expansion, FactionInitializer, Level, LogoutResult, LogoutSpeed, MSG_MOVE_FALL_LAND, MSG_MOVE_HEARTBEAT, MSG_MOVE_JUMP,
        MSG_MOVE_SET_FACING, MSG_MOVE_SET_RUN_MODE, MSG_MOVE_SET_WALK_MODE, MSG_MOVE_START_BACKWARD, MSG_MOVE_START_FORWARD, MSG_MOVE_START_PITCH_DOWN,
        MSG_MOVE_START_PITCH_UP, MSG_MOVE_START_STRAFE_LEFT, MSG_MOVE_START_STRAFE_RIGHT, MSG_MOVE_START_SWIM, MSG_MOVE_START_TURN_LEFT,
        MSG_MOVE_START_TURN_RIGHT, MSG_MOVE_STOP, MSG_MOVE_STOP_PITCH, MSG_MOVE_STOP_STRAFE, MSG_MOVE_STOP_SWIM, MSG_MOVE_STOP_TURN,
        MSG_SET_DUNGEON_DIFFICULTY_Server, MovementBlock, MovementBlock_MovementFlags, MovementBlock_UpdateFlag, MovementBlock_UpdateFlag_Living, MovementInfo,
        Object, ObjectType, Power, RealmSplitState, Relation, Relation_RelationType, RelationType, SMSG_ACCOUNT_DATA_TIMES, SMSG_ACTION_BUTTONS,
        SMSG_AUTH_CHALLENGE, SMSG_AUTH_RESPONSE, SMSG_BATTLEFIELD_STATUS, SMSG_BATTLEFIELD_STATUS_StatusId, SMSG_BINDPOINTUPDATE, SMSG_CHAR_CREATE,
        SMSG_CHAR_ENUM, SMSG_CONTACT_LIST, SMSG_FEATURE_SYSTEM_STATUS, SMSG_FRIEND_STATUS, SMSG_GMTICKET_GETTICKET, SMSG_INIT_WORLD_STATES,
        SMSG_INITIALIZE_FACTIONS, SMSG_LOGIN_SETTIMESPEED, SMSG_LOGIN_VERIFY_WORLD, SMSG_LOGOUT_COMPLETE, SMSG_LOGOUT_RESPONSE, SMSG_MESSAGECHAT,
        SMSG_MESSAGECHAT_ChatType, SMSG_NAME_QUERY_RESPONSE, SMSG_PLAYED_TIME, SMSG_PONG, SMSG_QUERY_TIME_RESPONSE, SMSG_REALM_SPLIT, SMSG_TIME_SYNC_REQ,
        SMSG_TUTORIAL_FLAGS, SMSG_UPDATE_OBJECT, SMSG_WORLD_STATE_UI_TIMER_UPDATE, ServerMessage, UpdateMask, UpdatePlayer, Vector3d, WorldResult, WorldState,
        opcodes::ClientOpcodeMessage, tokio_expect_client_message,
    },
};

use crate::{
    client::{Client, ClientId},
    world::World,
};

#[allow(unused)]
pub struct WorldServer<A: AccountService + Sync, R: RealmList + Sync, C: CharacterService + Sync> {
    id: RealmId,
    accounts: A,
    realms: R,
    characters: C,
    auth_server_address: String,
    world: World<A, R, C, OwnedWriteHalf>,

    // TODO: use
    realm_seed: [u8; 4],
    clients: RwLock<HashMap<ClientId, Arc<RwLock<Client>>>>,
    running: AtomicBool,
}

impl<A: AccountService + Sync + Send + 'static + Clone, R: RealmList + Sync + Send + 'static + Clone, C: CharacterService + Sync + Send + 'static + Clone>
    WorldServer<A, R, C>
{
    pub fn new(realm_id: RealmId, accounts: A, realms: R, characters: C, auth_server_address: String) -> Self {
        WorldServer::with_world(
            realm_id,
            accounts.clone(),
            realms.clone(),
            characters.clone(),
            World::new(RealmId(0), accounts, realms, characters),
            auth_server_address,
        )
    }

    pub fn with_world(realm_id: RealmId, accounts: A, realms: R, characters: C, world: World<A, R, C, OwnedWriteHalf>, auth_server_address: String) -> Self {
        Self {
            world,
            accounts,
            realms,
            characters,
            auth_server_address,
            id: realm_id,
            realm_seed: rand::thread_rng().r#gen(),
            clients: Default::default(),

            running: AtomicBool::new(true),
        }
    }

    /// Sends periodic heartbeat packets to the auth server
    #[instrument(skip(self))]
    pub async fn auth_server_heartbeat(&self) -> Result<()> {
        let socket = UdpSocket::bind("127.0.0.1:0").await?;
        socket.connect(&self.auth_server_address).await?;

        let mut interval = interval(Duration::from_secs(5));
        loop {
            interval.tick().await;
            let [a, b, c, d] = 0u32.to_be_bytes();
            if let Err(_e) = socket.send(&[0u8, self.id.0 as u8, a, b, c, d]).await {
                warn!("could not send heartbeat to {}", self.auth_server_address);
            }
        }
    }

    /// Allows the world server to accept new clients
    #[instrument(skip(self))]
    pub async fn accept_clients(self: Arc<Self>) -> Result<()> {
        let addr = ("0.0.0.0", 8085);
        let listener = TcpListener::bind(&addr).await?;

        info!("listening on {:?}", &addr);

        let mut connections = TcpListenerStream::new(listener).filter_map(|s| s.ok());
        while let Some(stream) = connections.next().await {
            tokio::task::Builder::new()
                .name(&format!(
                    "world::connect[{}]",
                    stream.peer_addr().map(|a| a.to_string()).unwrap_or_else(|_| "unknown".to_string())
                ))
                .spawn({
                    let server = self.to_owned();
                    async move {
                        if let Err(e) = server.connect_loop(stream).await {
                            error!("error handling request: {e}")
                        }
                    }
                })?;
        }

        Ok(())
    }

    async fn connect_loop(self: Arc<Self>, mut stream: TcpStream) -> Result<()> {
        let seed = ProofSeed::new();

        SMSG_AUTH_CHALLENGE {
            unknown1: 0,
            server_seed: seed.seed(),
            seed: [0; 32],
        }
        .tokio_write_unencrypted_server(&mut stream)
        .await
        .unwrap();

        let c = tokio_expect_client_message::<CMSG_AUTH_SESSION, _>(&mut stream).await.unwrap();

        let account = self.accounts.get_by_username(&c.username).await.unwrap().unwrap();

        let session_key = account.session_key.unwrap();

        let (mut encryption, decryption) = seed
            .into_server_header_crypto(&NormalizedString::new(&c.username).unwrap(), session_key, c.client_proof, c.client_seed)
            .unwrap()
            .split();

        SMSG_AUTH_RESPONSE::AuthOk {
            billing_flags: BillingPlanFlags::empty(),
            billing_rested: 0,
            billing_time: 0,
            expansion: Expansion::WrathOfTheLichKing,
        }
        .tokio_write_encrypted_server(&mut stream, &mut encryption)
        .await
        .unwrap();

        #[derive(Debug)]
        enum State {
            Login,
            LoggedIn(CharacterId),
        }

        let mut state = State::Login;

        let (reader, writer) = stream.into_split();

        let reader = Arc::new(Mutex::new((decryption, reader)));
        let writer = Arc::new(Mutex::new((encryption, writer)));

        loop {
            let opcode = {
                let (decrypter, reader) = &mut *reader.lock().await;
                match ClientOpcodeMessage::tokio_read_encrypted(reader, decrypter).await {
                    Ok(opcode) => opcode,
                    Err(ExpectedOpcodeError::Io(e)) if e.kind() == std::io::ErrorKind::UnexpectedEof => {
                        tracing::trace!("client disconnected");
                        if let State::LoggedIn(character_id) = state {
                            self.world.take_session(character_id).await;
                        }
                        break;
                    }
                    Err(e) => {
                        error!("{:?}", e);
                        if let State::LoggedIn(character_id) = state {
                            self.world.take_session(character_id).await;
                        }
                        break;
                    }
                }
            };

            match (&state, opcode) {
                // loggging in
                (_, ClientOpcodeMessage::CMSG_PING(c)) => {
                    let (encrypter, writer) = &mut *writer.lock().await;
                    SMSG_PONG { sequence_id: c.sequence_id }
                        .tokio_write_encrypted_server(writer, encrypter)
                        .await
                        .unwrap();
                }
                (_, ClientOpcodeMessage::CMSG_CHAR_ENUM) => {
                    let characters = self
                        .characters
                        .get_by_account(account.id)
                        .await
                        .unwrap()
                        .into_iter()
                        .map(|c| wow_world_messages::wrath::Character {
                            guid: c.id.into(),
                            name: c.name,
                            race: c.race,
                            class: c.class,
                            gender: c.gender,
                            skin: c.skin_color,
                            face: c.face,
                            hair_style: c.hair_style,
                            hair_color: c.hair_color,
                            facial_hair: c.facial_style,
                            level: c.level,
                            area: c.zone,
                            map: c.map,
                            position: Vector3d {
                                x: c.position_x,
                                y: c.position_y,
                                z: c.position_z,
                            },
                            guild_id: 0,
                            flags: Default::default(),
                            recustomization_flags: 0,
                            first_login: false,
                            pet_display_id: 0,
                            pet_level: Level::zero(),
                            pet_family: CreatureFamily::None,
                            equipment: [Default::default(); 23],
                        })
                        .collect();

                    let (encrypter, writer) = &mut *writer.lock().await;
                    SMSG_CHAR_ENUM { characters }.tokio_write_encrypted_server(writer, encrypter).await.unwrap();
                }
                (_, ClientOpcodeMessage::CMSG_CHAR_CREATE(c)) => {
                    let available = self.characters.name_available(&c.name).await.unwrap();

                    let response = match available {
                        true => {
                            let mut name_proper = c.name.to_ascii_lowercase();
                            if let Some(r) = name_proper.get_mut(0..1) {
                                r.make_ascii_uppercase();
                            };

                            match &c.name {
                                n if name_proper.ne(n) => WorldResult::CharNameFailure,
                                n if n.is_empty() => WorldResult::CharNameNoName,
                                n if n.len() < 2 => WorldResult::CharNameTooShort,
                                _ => {
                                    self.characters
                                        .create_character(account.id, CharacterCreate {
                                            name: c.name,
                                            race: c.race,
                                            class: c.class,
                                            gender: c.gender,
                                            skin_color: c.skin_color,
                                            face: c.face,
                                            hair_style: c.hair_style,
                                            hair_color: c.hair_color,
                                            facial_style: c.facial_hair,
                                            map: 0,               //
                                            zone: 1,              //
                                            position_x: -6240.32, // dwarf start zone
                                            position_y: 331.033,  //
                                            position_z: 382.758,  //
                                        })
                                        .await
                                        .map(|_| WorldResult::CharCreateSuccess)
                                        .unwrap_or_else(|e| {
                                            tracing::error!("unable to create character: {e}");
                                            WorldResult::AuthSystemError
                                        })
                                }
                            }
                        }
                        false => WorldResult::CharCreateNameInUse,
                    };

                    let (encrypter, writer) = &mut *writer.lock().await;
                    SMSG_CHAR_CREATE { result: response }
                        .tokio_write_encrypted_server(writer, encrypter)
                        .await
                        .unwrap();
                }
                (_, ClientOpcodeMessage::CMSG_PLAYER_LOGIN(login)) => {
                    let character = self.characters.get(login.guid.try_into().unwrap()).await.unwrap().unwrap();
                    let friends = self.characters.get_friends(login.guid.try_into().unwrap()).await.unwrap();

                    {
                        let (encrypter, writer) = &mut *writer.lock().await;

                        SMSG_BINDPOINTUPDATE {
                            position: Vector3d {
                                x: character.position_x,
                                y: character.position_y,
                                z: character.position_z,
                            },
                            map: character.map,
                            area: character.zone,
                        }
                        .tokio_write_encrypted_server(&mut *writer, encrypter)
                        .await
                        .unwrap();

                        let mask = RelationType::empty().set_friend().set_ignored().set_muted().set_recruitafriend();
                        SMSG_CONTACT_LIST {
                            list_mask: mask,
                            relations: friends
                                .into_iter()
                                .map(|(friend, flags, note)| Relation {
                                    guid: friend.into(),
                                    note,
                                    relation_mask: Relation_RelationType::new(flags, None),
                                })
                                .collect(),
                        }
                        .tokio_write_encrypted_server(&mut *writer, encrypter)
                        .await
                        .unwrap();
                        SMSG_ACTION_BUTTONS::Initial {
                            data: [ActionButton::default(); 144],
                        }
                        .tokio_write_encrypted_server(&mut *writer, encrypter)
                        .await
                        .unwrap();

                        SMSG_INIT_WORLD_STATES {
                            area: character.zone,
                            map: character.map,
                            sub_area: Area::Teldrassil, // TODO: sub areas
                            states: vec![
                                WorldState {
                                    state: 3191, //Arena season
                                    value: 1,
                                },
                                WorldState {
                                    state: 3901, //Arena season progress
                                    value: 1,
                                },
                            ],
                        }
                        .tokio_write_encrypted_server(&mut *writer, encrypter)
                        .await
                        .unwrap();
                        MSG_SET_DUNGEON_DIFFICULTY_Server {
                            difficulty: DungeonDifficulty::Normal,
                            unknown1: 1,
                            is_in_group: false,
                        }
                        .tokio_write_encrypted_server(&mut *writer, encrypter)
                        .await
                        .unwrap();

                        SMSG_LOGIN_SETTIMESPEED {
                            datetime: wow_world_messages::DateTime::new(23, wow_world_messages::Month::July, 15, wow_world_messages::Weekday::Saturday, 12, 12),
                            timescale: 0.01667f32,
                            unknown1: 0,
                        }
                        .tokio_write_encrypted_server(&mut *writer, encrypter)
                        .await
                        .unwrap();

                        let factions = (0..128).map(|_| FactionInitializer::default()).collect();
                        SMSG_INITIALIZE_FACTIONS { factions }
                            .tokio_write_encrypted_server(&mut *writer, encrypter)
                            .await
                            .unwrap();

                        SMSG_FEATURE_SYSTEM_STATUS {
                            complaint_status: ComplaintStatus::EnabledWithAutoIgnore,
                            voice_chat_enabled: false,
                        }
                        .tokio_write_encrypted_server(&mut *writer, encrypter)
                        .await
                        .unwrap();

                        SMSG_LOGIN_VERIFY_WORLD {
                            map: character.map,
                            position: Vector3d {
                                x: character.position_x,
                                y: character.position_y,
                                z: character.position_z,
                            },
                            orientation: 0.0, // todo
                        }
                        .tokio_write_encrypted_server(&mut *writer, encrypter)
                        .await
                        .unwrap();

                        SMSG_TUTORIAL_FLAGS {
                            tutorial_data: [0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF],
                        }
                        .tokio_write_encrypted_server(&mut *writer, encrypter)
                        .await
                        .unwrap();

                        {
                            let unix_time = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as u32;

                            let data = self.characters.character_account_data(character.id).await.unwrap();

                            let mask = CacheMask::PER_CHARACTER_CACHE;
                            let mut cache_mask = CacheMask::default();
                            let cache_data = cache_mask.data_mut();
                            let mut idx = 0;

                            for (dtype, row) in data {
                                if mask & (1 << dtype) > 0 {
                                    *cache_data.get_mut(idx).unwrap() = Some(row.time);
                                    idx += 1;
                                }
                            }

                            SMSG_ACCOUNT_DATA_TIMES {
                                mask: cache_mask,
                                unix_time,
                                unknown1: 1,
                            }
                            .tokio_write_encrypted_server(&mut *writer, encrypter)
                            .await
                            .unwrap();
                        }

                        // this NEEDS to be set before we send packets
                        {
                            let guid = login.guid;
                            let update_mask = UpdatePlayer::builder()
                                .set_object_guid(guid)
                                .set_unit_bytes_0(character.race, character.class, character.gender, Power::Mana)
                                .set_unit_base_mana(100)
                                .set_object_scale_x(1.0)
                                .set_unit_health(100)
                                .set_unit_maxhealth(100)
                                .set_unit_level(character.level.as_int() as i32)
                                .set_unit_factiontemplate(1)
                                .set_unit_displayid(50)
                                .set_unit_nativedisplayid(50)
                                .finalize();

                            let update_flag = MovementBlock_UpdateFlag::empty()
                                .set_living(MovementBlock_UpdateFlag_Living::Living {
                                    backwards_running_speed: 4.5,
                                    backwards_swimming_speed: 0.0,
                                    fall_time: 0.0,
                                    flags: MovementBlock_MovementFlags::empty(),
                                    flight_speed: 0.0,
                                    backwards_flight_speed: 0.0,
                                    orientation: 0.0,
                                    position: Vector3d {
                                        x: character.position_x,
                                        y: character.position_y,
                                        z: character.position_z,
                                    },
                                    pitch_rate: 0.0,
                                    running_speed: 7.0,
                                    swimming_speed: 0.0,
                                    timestamp: 0,
                                    turn_rate: std::f32::consts::PI,
                                    walking_speed: 1.0,
                                })
                                .set_high_guid(wow_world_messages::wrath::MovementBlock_UpdateFlag_HighGuid {
                                    unknown0: if guid == login.guid { 0x2F } else { 0x08 },
                                })
                                .set_self();

                            SMSG_UPDATE_OBJECT {
                                objects: vec![Object::CreateObject2 {
                                    guid3: guid,
                                    mask2: UpdateMask::Player(update_mask),
                                    movement2: MovementBlock { update_flag },
                                    object_type: ObjectType::Player,
                                }],
                            }
                            .tokio_write_encrypted_server(writer, encrypter)
                            .await
                            .unwrap();
                        }
                    }

                    {
                        let (encrypter, writer) = &mut *writer.lock().await;
                        SMSG_TIME_SYNC_REQ { time_sync: 0 }
                            .tokio_write_encrypted_server(writer, encrypter)
                            .await
                            .unwrap();
                    }

                    self.world.create_session(character, writer.clone()).await.unwrap();

                    let cid: CharacterId = login.guid.try_into().unwrap();
                    tracing::trace!(guid = login.guid.guid(), character = cid.0, "logged in");
                    state = State::LoggedIn(cid);
                }
                (State::LoggedIn(_), ClientOpcodeMessage::CMSG_LOGOUT_REQUEST) => {
                    {
                        let (encrypter, writer) = &mut *writer.lock().await;
                        SMSG_LOGOUT_RESPONSE {
                            result: LogoutResult::Success,
                            speed: LogoutSpeed::Instant,
                        }
                        .tokio_write_encrypted_server(&mut *writer, encrypter)
                        .await
                        .unwrap();

                        SMSG_LOGOUT_COMPLETE {}.tokio_write_encrypted_server(writer, encrypter).await.unwrap();
                    }

                    if let State::LoggedIn(character_id) = state {
                        self.world.take_session(character_id).await;
                    }

                    state = State::Login;
                }
                (State::LoggedIn(_), ClientOpcodeMessage::CMSG_GMTICKET_GETTICKET) => {
                    let (encrypter, writer) = &mut *writer.lock().await;
                    SMSG_GMTICKET_GETTICKET::Default.tokio_write_encrypted_server(writer, encrypter).await.unwrap();
                }
                (_, ClientOpcodeMessage::CMSG_READY_FOR_ACCOUNT_DATA_TIMES) => {
                    let unix_time = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as u32;

                    let data = self.characters.account_data(account.id).await.unwrap();

                    let mask = CacheMask::GLOBAL_CACHE;
                    let mut cache_mask = CacheMask::default();
                    let cache_data = cache_mask.data_mut();
                    let mut idx = 0;

                    for (dtype, row) in data {
                        if mask & (1 << dtype) > 0 {
                            *cache_data.get_mut(idx).unwrap() = Some(row.time);
                            idx += 1;
                        }
                    }

                    let (encrypter, writer) = &mut *writer.lock().await;
                    SMSG_ACCOUNT_DATA_TIMES {
                        mask: cache_mask,
                        unix_time,
                        unknown1: 1,
                    }
                    .tokio_write_encrypted_server(writer, encrypter)
                    .await
                    .unwrap();
                }
                (State::LoggedIn(_), ClientOpcodeMessage::CMSG_PLAYED_TIME(pt)) => {
                    let (encrypter, writer) = &mut *writer.lock().await;
                    SMSG_PLAYED_TIME {
                        show_on_ui: pt.show_on_ui,
                        total_played_time: 0, // TODO
                        level_played_time: 0, // TODO
                    }
                    .tokio_write_encrypted_server(writer, encrypter)
                    .await
                    .unwrap()
                }
                (_, ClientOpcodeMessage::CMSG_NAME_QUERY(nq)) => {
                    if let Some(character) = self.characters.get(nq.guid.try_into().unwrap()).await.unwrap() {
                        let (encrypter, writer) = &mut *writer.lock().await;

                        SMSG_NAME_QUERY_RESPONSE {
                            guid: nq.guid,
                            character_name: character.name,
                            class: character.class,
                            gender: character.gender,
                            has_declined_names: wow_world_messages::wrath::SMSG_NAME_QUERY_RESPONSE_DeclinedNames::No,
                            race: character.race,
                            realm_name: "Realm".to_string(), // todo
                        }
                        .tokio_write_encrypted_server(writer, encrypter)
                        .await
                        .unwrap();
                    }
                }
                (_, ClientOpcodeMessage::CMSG_QUERY_TIME) => {
                    let unix_time = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as u32;

                    // seconds since mignight
                    let seconds_since_mignight = unix_time % 86400;
                    let seconds_to_next_mignight = 86400 - seconds_since_mignight;

                    let (encrypter, writer) = &mut *writer.lock().await;
                    SMSG_QUERY_TIME_RESPONSE {
                        time: unix_time,
                        time_until_daily_quest_reset: seconds_to_next_mignight,
                    }
                    .tokio_write_encrypted_server(writer, encrypter)
                    .await
                    .unwrap();
                }
                (_, ClientOpcodeMessage::CMSG_WORLD_STATE_UI_TIMER_UPDATE) => {
                    let unix_time = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as u32;

                    let (encrypter, writer) = &mut *writer.lock().await;
                    SMSG_WORLD_STATE_UI_TIMER_UPDATE { time: unix_time }
                        .tokio_write_encrypted_server(writer, encrypter)
                        .await
                        .unwrap();
                }
                (State::LoggedIn(guid), ClientOpcodeMessage::CMSG_MESSAGECHAT(chat)) => {
                    let chat_type = match &chat.chat_type {
                        wow_world_messages::wrath::CMSG_MESSAGECHAT_ChatType::Say => Some(SMSG_MESSAGECHAT_ChatType::Say { target6: (*guid).into() }),
                        wow_world_messages::wrath::CMSG_MESSAGECHAT_ChatType::Afk => Some(SMSG_MESSAGECHAT_ChatType::Afk { target6: (*guid).into() }),
                        _ => {
                            tracing::trace!("unhandled message {:?}", chat);
                            None
                        }
                    };

                    if let Some(chat_type) = chat_type {
                        let (encrypter, writer) = &mut *writer.lock().await;
                        SMSG_MESSAGECHAT {
                            chat_type,
                            language: chat.language,
                            message: chat.message,
                            sender: (*guid).into(),
                            ..Default::default()
                        }
                        .tokio_write_encrypted_server(writer, encrypter)
                        .await
                        .unwrap();
                    }
                }
                (State::LoggedIn(_), ClientOpcodeMessage::CMSG_SET_ACTIONBAR_TOGGLES(_)) => {
                    // TODO: set toggles on character
                }
                (State::LoggedIn(_), ClientOpcodeMessage::CMSG_TIME_SYNC_RESP(_)) => {
                    // TODO: set time sync on character
                }
                (State::LoggedIn(guid), ClientOpcodeMessage::CMSG_ZONEUPDATE(_)) => {
                    let character = self.characters.get((*guid).try_into().unwrap()).await.unwrap().unwrap();

                    let (encrypter, writer) = &mut *writer.lock().await;

                    // TODO: set zone on character
                    SMSG_INIT_WORLD_STATES {
                        area: character.zone,
                        map: character.map,
                        sub_area: Area::Teldrassil, // TODO: sub areas
                        states: vec![
                            WorldState {
                                state: 3191, //Arena season
                                value: 1,
                            },
                            WorldState {
                                state: 3901, //Arena season progress
                                value: 1,
                            },
                        ],
                    }
                    .tokio_write_encrypted_server(writer, encrypter)
                    .await
                    .unwrap();
                }
                (State::LoggedIn(character_id), ClientOpcodeMessage::CMSG_SET_ACTIVE_MOVER(mover)) => {
                    // TODO: we probably want to do something with this
                    if Guid::from(character_id) != mover.guid {
                        warn!(active = mover.guid.guid(), player = character_id.0, "received mover for non-player");
                    }
                }
                (State::LoggedIn(_), ClientOpcodeMessage::CMSG_BATTLEFIELD_STATUS) => {
                    // TODO: integrate battlegrounds

                    let (encrypter, writer) = &mut *writer.lock().await;
                    SMSG_BATTLEFIELD_STATUS {
                        status_id: SMSG_BATTLEFIELD_STATUS_StatusId::None,
                        arena_type: ArenaType::NotArena,
                        battleground_type: BattlegroundType::None,
                        client_instance_id: 0,
                        is_arena: 0,
                        rated: false,
                        unknown1: 0x1F90,
                        maximum_level: 0,
                        minimum_level: 0,
                        queue_slot: 0,
                    }
                    .tokio_write_encrypted_server(writer, encrypter)
                    .await
                    .unwrap();
                }
                (State::LoggedIn(_), ClientOpcodeMessage::CMSG_STANDSTATECHANGE(_)) => {
                    // TODO: get sit / stand in bevy
                }
                (State::LoggedIn(guid), ClientOpcodeMessage::MSG_MOVE_START_FORWARD(box data)) => self.handle_movement(guid, data.clone()).await,
                (State::LoggedIn(guid), ClientOpcodeMessage::MSG_MOVE_START_BACKWARD(box data)) => self.handle_movement(guid, data.clone()).await,
                (State::LoggedIn(guid), ClientOpcodeMessage::MSG_MOVE_STOP(box data)) => self.handle_movement(guid, data.clone()).await,
                (State::LoggedIn(guid), ClientOpcodeMessage::MSG_MOVE_START_STRAFE_LEFT(box data)) => self.handle_movement(guid, data.clone()).await,
                (State::LoggedIn(guid), ClientOpcodeMessage::MSG_MOVE_START_STRAFE_RIGHT(box data)) => self.handle_movement(guid, data.clone()).await,
                (State::LoggedIn(guid), ClientOpcodeMessage::MSG_MOVE_STOP_STRAFE(box data)) => self.handle_movement(guid, data.clone()).await,
                (State::LoggedIn(guid), ClientOpcodeMessage::MSG_MOVE_JUMP(box data)) => self.handle_movement(guid, data.clone()).await,
                (State::LoggedIn(guid), ClientOpcodeMessage::MSG_MOVE_START_TURN_LEFT(box data)) => self.handle_movement(guid, data.clone()).await,
                (State::LoggedIn(guid), ClientOpcodeMessage::MSG_MOVE_START_TURN_RIGHT(box data)) => self.handle_movement(guid, data.clone()).await,
                (State::LoggedIn(guid), ClientOpcodeMessage::MSG_MOVE_START_PITCH_UP(box data)) => self.handle_movement(guid, data.clone()).await,
                (State::LoggedIn(guid), ClientOpcodeMessage::MSG_MOVE_START_PITCH_DOWN(box data)) => self.handle_movement(guid, data.clone()).await,
                (State::LoggedIn(guid), ClientOpcodeMessage::MSG_MOVE_STOP_PITCH(box data)) => self.handle_movement(guid, data.clone()).await,
                (State::LoggedIn(guid), ClientOpcodeMessage::MSG_MOVE_SET_RUN_MODE(box data)) => self.handle_movement(guid, data.clone()).await,
                (State::LoggedIn(guid), ClientOpcodeMessage::MSG_MOVE_SET_WALK_MODE(box data)) => self.handle_movement(guid, data.clone()).await,
                (State::LoggedIn(guid), ClientOpcodeMessage::MSG_MOVE_FALL_LAND(box data)) => self.handle_movement(guid, data.clone()).await,
                (State::LoggedIn(guid), ClientOpcodeMessage::MSG_MOVE_START_SWIM(box data)) => self.handle_movement(guid, data.clone()).await,
                (State::LoggedIn(guid), ClientOpcodeMessage::MSG_MOVE_STOP_SWIM(box data)) => self.handle_movement(guid, data.clone()).await,
                (State::LoggedIn(guid), ClientOpcodeMessage::MSG_MOVE_STOP_TURN(box data)) => self.handle_movement(guid, data.clone()).await,
                (State::LoggedIn(guid), ClientOpcodeMessage::MSG_MOVE_SET_FACING(box data)) => self.handle_movement(guid, data.clone()).await,
                (State::LoggedIn(guid), ClientOpcodeMessage::MSG_MOVE_HEARTBEAT(box data)) => self.handle_movement(guid, data.clone()).await,
                (
                    _,
                    ClientOpcodeMessage::CMSG_CHANNEL_VOICE_ON
                    | ClientOpcodeMessage::CMSG_VOICE_SESSION_ENABLE(_)
                    | ClientOpcodeMessage::CMSG_SET_ACTIVE_VOICE_CHANNEL(_),
                ) => {
                    // voice is not supported
                }
                (State::LoggedIn(guid), ClientOpcodeMessage::CMSG_CONTACT_LIST(_)) => {
                    let friends = self.characters.get_friends((*guid).try_into().unwrap()).await.unwrap();
                    let mask = RelationType::empty().set_friend().set_ignored().set_muted().set_recruitafriend();

                    let (encrypter, writer) = &mut *writer.lock().await;
                    SMSG_CONTACT_LIST {
                        list_mask: mask,
                        relations: friends
                            .into_iter()
                            .map(|(friend, flags, note)| Relation {
                                guid: friend.into(),
                                note,
                                relation_mask: Relation_RelationType::new(flags, None),
                            })
                            .collect(),
                    }
                    .tokio_write_encrypted_server(writer, encrypter)
                    .await
                    .unwrap();
                }
                (State::LoggedIn(character_id), ClientOpcodeMessage::CMSG_ADD_FRIEND(friend)) => {
                    let response = match self
                        .characters
                        .add_friend_by_name(*character_id, &friend.name, Some(&friend.note))
                        .await
                        .unwrap()
                    {
                        Some(friend) => SMSG_FRIEND_STATUS {
                            guid: friend.into(),
                            result: wow_world_messages::wrath::FriendResult::AddedOffline,
                        },
                        None => SMSG_FRIEND_STATUS {
                            guid: Guid::zero(),
                            result: wow_world_messages::wrath::FriendResult::NotFound,
                        },
                    };

                    let (encrypter, writer) = &mut *writer.lock().await;

                    response.tokio_write_encrypted_server(writer, encrypter).await.unwrap();
                }
                (_, ClientOpcodeMessage::CMSG_REALM_SPLIT(rs)) => {
                    let (encrypter, writer) = &mut *writer.lock().await;
                    SMSG_REALM_SPLIT {
                        realm_id: rs.realm_id,
                        state: RealmSplitState::Normal,
                        split_date: "01/01/01".into(),
                    }
                    .tokio_write_encrypted_server(writer, encrypter)
                    .await
                    .unwrap()
                }
                (state, e) => {
                    tracing::trace!(state = match state {
                        State::Login => "login",
                        State::LoggedIn(_) => "logged in",
                    }, opcode = ?e);
                }
            }
        }

        Ok(())
    }

    async fn handle_movement(&self, guid: &CharacterId, data: impl MovementMessage) {
        let update = data.get_movement_info();
        self.world.movement_update(*guid, update);
    }

    /// Start the world server, running the various tasks that it is comprised of
    pub async fn start(self, cancel: CancellationToken) -> Result<()> {
        let server = Arc::new(self);

        try_join!(
            flatten(tokio::task::Builder::new().name("world::heartbeat").spawn({
                let cloned = server.clone();
                async move { cloned.auth_server_heartbeat().await.context("heartbeat error") }
            })?),
            flatten(tokio::task::Builder::new().name("world::clients").spawn({
                let cloned = server.clone();
                async move { cloned.accept_clients().await.context("client error") }
            })?),
            flatten(tokio::task::Builder::new().name("world::packets").spawn({
                let cloned = server.clone();
                async move {
                    cloned.world.packet_handler().await;
                    Ok(())
                }
            })?),
            async {
                cancel.cancelled().await;
                Result::<()>::Err(anyhow::anyhow!("cancelled"))
            }
        )?;

        Ok(())
    }
}

// just ripped this from wrath-rs for now. lets replace it once we have it working
pub trait MovementMessage: Sync + ServerMessage + ClientMessage {
    #[allow(unused)]
    fn get_guid(&self) -> Guid;
    fn get_movement_info(&self) -> MovementInfo;
}

macro_rules! define_movement_packet {
    ($packet_type:ty) => {
        impl MovementMessage for $packet_type {
            fn get_guid(&self) -> Guid {
                self.guid
            }

            fn get_movement_info(&self) -> MovementInfo {
                self.info.clone()
            }
        }
    };
}

define_movement_packet!(MSG_MOVE_START_FORWARD);
define_movement_packet!(MSG_MOVE_START_BACKWARD);
define_movement_packet!(MSG_MOVE_STOP);
define_movement_packet!(MSG_MOVE_STOP_TURN);
define_movement_packet!(MSG_MOVE_START_STRAFE_LEFT);
define_movement_packet!(MSG_MOVE_START_STRAFE_RIGHT);
define_movement_packet!(MSG_MOVE_STOP_STRAFE);
define_movement_packet!(MSG_MOVE_JUMP);
define_movement_packet!(MSG_MOVE_START_TURN_LEFT);
define_movement_packet!(MSG_MOVE_START_TURN_RIGHT);
define_movement_packet!(MSG_MOVE_START_PITCH_UP);
define_movement_packet!(MSG_MOVE_START_PITCH_DOWN);
define_movement_packet!(MSG_MOVE_STOP_PITCH);
define_movement_packet!(MSG_MOVE_SET_RUN_MODE);
define_movement_packet!(MSG_MOVE_SET_WALK_MODE);
define_movement_packet!(MSG_MOVE_FALL_LAND);
define_movement_packet!(MSG_MOVE_START_SWIM);
define_movement_packet!(MSG_MOVE_STOP_SWIM);
define_movement_packet!(MSG_MOVE_SET_FACING);
define_movement_packet!(MSG_MOVE_HEARTBEAT);

```