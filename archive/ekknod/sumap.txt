Project Path: arc_ekknod_sumap_67fy_y48

Source Tree:

```txt
arc_ekknod_sumap_67fy_y48
├── README.md
├── poc-driver
│   ├── crc32.c
│   ├── crc32.h
│   ├── driver_base.sln
│   ├── driver_base.vcxproj
│   ├── driver_base.vcxproj.filters
│   ├── driver_base.vcxproj.user
│   ├── globals.h
│   └── main.c
├── poc.png
└── umap-uefi
    ├── boot.default.props
    ├── boot.props
    ├── boot.sln
    ├── boot.vcxproj
    ├── boot.vcxproj.filters
    ├── boot.vcxproj.user
    ├── main.c
    ├── stdafx.h
    ├── util.c
    └── util.h

```

`README.md`:

```md
# sumap
manually map driver for a signed driver memory space  

# precompiled binaries  
https://www.unknowncheats.me/forum/downloads.php?do=file&id=32686

# credits
https://github.com/btbd/umap  

# tested system
Windows 10 Education 20H2 UEFI  

# installation
fat32 format USB  
copy files from inside "precompiled" folder to the USB  
boot system, press F8/F11 repeatly and select USB : UEFI from boot menu  


```

`poc-driver/crc32.c`:

```c
#ifdef _KERNEL_MODE
#include <ntifs.h>
#else
#include <windows.h>
#endif
#include "crc32.h"

static const unsigned int crc32_table[] = {
	0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,
	0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
	0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
	0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
	0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,
	0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
	0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,
	0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
	0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
	0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
	0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,
	0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
	0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,
	0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
	0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
	0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
	0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,
	0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
	0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
	0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
	0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
	0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
	0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,
	0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
	0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,
	0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
	0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
	0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
	0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
	0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
	0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,
	0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
	0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
	0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
	0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,
	0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
	0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,
	0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
	0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
	0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
	0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,
	0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
	0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,
	0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
	0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
	0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
	0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,
	0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
	0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
	0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
	0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
	0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
	0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,
	0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
	0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,
	0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
	0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
	0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
	0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
	0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
	0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,
	0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
	0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
	0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
} ;

DWORD crc32(PCSTR buf, DWORD len, DWORD init)
{
	DWORD crc = init;
	while (len--) {
		crc = (crc << 8) ^ crc32_table[((crc >> 24) ^ *buf) & 255];
		buf++;
	}
	return crc;
}

```

`poc-driver/crc32.h`:

```h
#ifndef CRC32_H
#define CRC32_H

#ifdef _KERNEL_MODE

typedef unsigned __int8  BYTE;
typedef unsigned __int16 WORD;
typedef unsigned __int32 DWORD;
typedef unsigned __int64 QWORD;
typedef int BOOL;

#endif

DWORD crc32(PCSTR buf, DWORD len, DWORD init);

extern DWORD g_encryption_key;

#endif

```

`poc-driver/driver_base.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31005.135
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "driver_base", "driver_base.vcxproj", "{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Debug|ARM.ActiveCfg = Debug|ARM
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Debug|ARM.Build.0 = Debug|ARM
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Debug|ARM.Deploy.0 = Debug|ARM
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Debug|ARM64.Build.0 = Debug|ARM64
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Debug|x64.ActiveCfg = Debug|x64
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Debug|x64.Build.0 = Debug|x64
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Debug|x64.Deploy.0 = Debug|x64
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Debug|x86.ActiveCfg = Debug|Win32
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Debug|x86.Build.0 = Debug|Win32
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Debug|x86.Deploy.0 = Debug|Win32
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Release|ARM.ActiveCfg = Release|ARM
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Release|ARM.Build.0 = Release|ARM
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Release|ARM.Deploy.0 = Release|ARM
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Release|ARM64.ActiveCfg = Release|ARM64
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Release|ARM64.Build.0 = Release|ARM64
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Release|ARM64.Deploy.0 = Release|ARM64
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Release|x64.ActiveCfg = Release|x64
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Release|x64.Build.0 = Release|x64
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Release|x64.Deploy.0 = Release|x64
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Release|x86.ActiveCfg = Release|Win32
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Release|x86.Build.0 = Release|Win32
		{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {94CC0611-AC34-4B70-90E0-9F2FEA32D203}
	EndGlobalSection
EndGlobal

```

`poc-driver/driver_base.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{1D3E11A5-FB30-4F65-97EB-E2AFE533F8C7}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>driver_base</RootNamespace>
    <ProjectName>driver_base</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <GenerateMapFile>true</GenerateMapFile>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="crc32.c" />
    <ClCompile Include="main.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="crc32.h" />
    <ClInclude Include="globals.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`poc-driver/driver_base.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="crc32.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="crc32.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="globals.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`poc-driver/driver_base.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`poc-driver/globals.h`:

```h
#ifndef GLOBALS_H
#define GLOBALS_H

#ifdef _KERNEL_MODE
#include <ntifs.h>
#else
#include <windows.h>
#include <winternl.h>
typedef struct _CLIENT_ID *PCLIENT_ID;
typedef void *PKSTART_ROUTINE;
typedef void *PEPROCESS;
#endif

// #define OLD_WINDOWS

PLIST_ENTRY _PsInitialSystemProcess;
NTSTATUS(NTAPI* _RtlInitUnicodeString)(PUNICODE_STRING, PCWSTR);


#ifdef _KERNEL_MODE
NTSTATUS(NTAPI* _KeDelayExecutionThread)(KPROCESSOR_MODE, BOOLEAN, PLARGE_INTEGER);
NTSTATUS(NTAPI* _PsCreateSystemThread)(PHANDLE, ULONG, POBJECT_ATTRIBUTES, HANDLE, PCLIENT_ID, PKSTART_ROUTINE, PVOID);
PVOID(__fastcall* _MmMapIoSpace)(QWORD, SIZE_T, MEMORY_CACHING_TYPE);
VOID(__fastcall* _MmUnmapIoSpace)(PVOID, SIZE_T);
NTSTATUS(__fastcall* _MmCopyMemory)(PVOID, SIZE_T, SIZE_T, ULONG, SIZE_T*);
PCSTR(*_PsGetProcessImageFileName)(PEPROCESS);
BOOLEAN(*_PsGetProcessExitProcessCalled)(PEPROCESS);
PVOID(*_PsGetProcessWow64Process)(PEPROCESS);
PVOID(*_PsGetProcessPeb)(PEPROCESS);
ULONG(*_PsGetProcessSessionId)(PEPROCESS);
ULONG(NTAPI* _RtlRandomEx)(_Inout_ PULONG);
LARGE_INTEGER(NTAPI*_KeQueryPerformanceCounter)(PLARGE_INTEGER);
PVOID(__fastcall* _ExAllocatePoolWithTag)(POOL_TYPE, SIZE_T, unsigned int);
VOID(__fastcall* _ExFreePoolWithTag)(PVOID, ULONG);


ULONG
(__cdecl *
_DbgPrint) (
    _In_z_ _Printf_format_string_ PCSTR Format,
    ...
    );

NTSTATUS (NTAPI *_ObReferenceObjectByName)(
	_In_ PUNICODE_STRING ObjectName,
	_In_ ULONG Attributes,
	_In_opt_ PACCESS_STATE AccessState,
	_In_opt_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_TYPE ObjectType,
	_In_ KPROCESSOR_MODE AccessMode,
	_Inout_opt_ PVOID ParseContext,
	_Out_ PVOID* Object
);

POBJECT_TYPE* _IoDriverObjectType;

PIRP (__stdcall *_IoBuildDeviceIoControlRequest)(
    _In_  ULONG IoControlCode,
    _In_  PDEVICE_OBJECT DeviceObject,
    _In_opt_  PVOID InputBuffer,
    _In_  ULONG InputBufferLength,
    _Out_opt_ PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength,
    _In_ BOOLEAN InternalDeviceIoControl,
    _In_opt_ PKEVENT Event,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock
    );

NTSTATUS (__fastcall *_IofCallDriver)(
    _In_ PDEVICE_OBJECT DeviceObject,
    _Inout_ __drv_aliasesMem PIRP Irp
    );

PVOID(__stdcall* _PsGetThreadId)(PVOID);

NTSTATUS(__stdcall*_PsLookupThreadByThreadId)(
	_In_ HANDLE ThreadId,
	_Outptr_ PETHREAD* Thread
	);

__int64(__fastcall* _ExDestroyHandle)(__int64 a1, __int64 a2, __int64 a3);
volatile signed __int64* (__fastcall* _ExMapHandleToPointer)(unsigned int* a1, __int64 a2);
unsigned int (* _PsGetThreadExitStatus)(__int64 a1);
NTSTATUS(NTAPI* _ZwClose)(HANDLE);

extern DWORD       g_encryption_key;
extern ULONG_PTR   g_PsTerminatedThread;
extern ULONG       g_PsGetThreadIdOffset;
extern ULONG       g_PsActiveProcessLink;
extern PLIST_ENTRY g_PsThreadListEntry;

#endif

#endif


```

`poc-driver/main.c`:

```c
#include <ntifs.h>
#include "crc32.h"
#include "globals.h"

#define MAPPER_SIZE 14 + 7
#define MAPPER_BASE MAPPER_SIZE
__declspec(dllexport) volatile BYTE qwerty[MAPPER_SIZE + 16];

DWORD       g_encryption_key = 0x726D0100;


BOOL LoadExports(PDRIVER_OBJECT driver);
QWORD GetSystemBaseAddressQ(PDRIVER_OBJECT DriverObject, DWORD crc, DWORD crc_len);
BOOLEAN MemCopyWP(PVOID dest, PVOID src, ULONG length);
QWORD ResolveEntryAddress(PDRIVER_OBJECT driver);
void clear_pe_header(QWORD map_driver_base);

void NtSleep(DWORD milliseconds)
{
#ifdef _KERNEL_MODE
	QWORD ms = milliseconds;
	ms = (ms * 1000) * 10;
	ms = ms * -1;
	_KeDelayExecutionThread(KernelMode, 0, (PLARGE_INTEGER)&ms);
#else
	QWORD ms = milliseconds;
	ms = (ms * 1000) * 10;
	ms = ms * -1;


	Sleep(milliseconds);
#endif
}

void NotifyRoutine(void)
{
	while (1) {
		NtSleep(50);
		_DbgPrint("[+] called from TID: %ld\n", _PsGetThreadId((PVOID)__readgsqword(0x188)));
	}
}

NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING registryPath)
{
	NTSTATUS ( *func )(
	    _In_ struct _DRIVER_OBJECT *DriverObject,
	    _In_ PUNICODE_STRING RegistryPath
	    );

	if (!LoadExports(driver)) {
		/* fail to load exports, cause bluescreen */
		*(int*)(0x10A0) = 0;
	}

	*(QWORD*)&func = ResolveEntryAddress(driver);
	if (func == 0)
		*(int*)(0x10A0) = 0;

	if (!MemCopyWP((PVOID)func, (PVOID)qwerty, MAPPER_SIZE)) {
		/* fail to load fix entry, cause bluescreen */
		*(int*)(0x10A0) = 0;
	}
	
	QWORD current_driver_base = *(QWORD*)((char*)qwerty + MAPPER_BASE);
	clear_pe_header(current_driver_base);

	HANDLE thread;
	CLIENT_ID threadid;
	_PsCreateSystemThread(&thread, STANDARD_RIGHTS_ALL, NULL, NULL, &threadid, (PKSTART_ROUTINE)NotifyRoutine, (PVOID)0);
	_ZwClose(thread);

	return func(driver, registryPath);
}

QWORD GetProcAddressQ(QWORD base, DWORD crc, DWORD length)
{
	QWORD a0;
	DWORD a1[4];

	a0 = base + *(USHORT*)(base + 0x3C);
	a0 = base + *(DWORD*)(a0 + 0x88);
	a1[0] = *(DWORD*)(a0 + 0x18);
	a1[1] = *(DWORD*)(a0 + 0x1C);
	a1[2] = *(DWORD*)(a0 + 0x20);
	a1[3] = *(DWORD*)(a0 + 0x24);
	while (a1[0]--) {
		a0 = base + *(DWORD*)(base + a1[2] + (a1[0] * 4));
		if (crc32((PCSTR)a0, length, g_encryption_key) == crc) {
			return (base + *(DWORD*)(base + a1[1] +
				(*(USHORT*)(base + a1[3] + (a1[0] * 2)) * 4)));
		}
	}
	return 0;
}

#define CRC32_EXPORT(var, crc, crc_length) \
	*(QWORD*)&var = GetProcAddressQ(ntosrknl_base, crc, crc_length); \
	if (var == 0) return 0; \

#define CRC32_EXPORT_HAL(var, crc, crc_length) \
	*(QWORD*)&var = GetProcAddressQ(hal_base, crc, crc_length); \
	if (var == 0) return 0; \


PMDL(*_IoAllocateMdl)(
	_In_opt_ __drv_aliasesMem PVOID VirtualAddress,
	_In_ ULONG Length,
	_In_ BOOLEAN SecondaryBuffer,
	_In_ BOOLEAN ChargeQuota,
	_Inout_opt_ PIRP Irp
	);

VOID(*_MmProbeAndLockPages)(
	_Inout_ PMDL MemoryDescriptorList,
	_In_ KPROCESSOR_MODE AccessMode,
	_In_ LOCK_OPERATION Operation
	);

PVOID
(*_MmMapLockedPagesSpecifyCache)(
	_Inout_ PMDL MemoryDescriptorList,
	_In_ __drv_strictType(KPROCESSOR_MODE / enum _MODE, __drv_typeConst)
	KPROCESSOR_MODE AccessMode,
	_In_ __drv_strictTypeMatch(__drv_typeCond) MEMORY_CACHING_TYPE CacheType,
	_In_opt_ PVOID RequestedAddress,
	_In_     ULONG BugCheckOnFailure,
	_In_     ULONG Priority  // MM_PAGE_PRIORITY logically OR'd with MdlMapping*

	);

VOID
(*_MmUnlockPages)(
	_Inout_ PMDL MemoryDescriptorList
	);

VOID
(*_IoFreeMdl)(
	PMDL Mdl
	);

VOID
(*_MmUnmapLockedPages)(
	_In_ PVOID BaseAddress,
	_Inout_ PMDL MemoryDescriptorList
	);

void* (__cdecl* _memcpy)(_Out_writes_bytes_all_(_MaxCount) void* _Dst, _In_reads_bytes_(_MaxCount) const void* _Src, _In_ size_t _MaxCount);

BOOL LoadExports(PDRIVER_OBJECT driver)
{
	QWORD ntosrknl_base = GetSystemBaseAddressQ(driver, 0x59f44bf0, 26);
#ifdef _KERNEL_MODE
	CRC32_EXPORT(_PsInitialSystemProcess, 0xf5acb841, 23);
#endif
	CRC32_EXPORT(_RtlInitUnicodeString, 0x93970a42, 21);
	CRC32_EXPORT(_ZwClose, 0x78e9da22, 8);
#ifdef _KERNEL_MODE
	CRC32_EXPORT(_KeDelayExecutionThread, 0x6be39931, 23);
	CRC32_EXPORT(_PsCreateSystemThread, 0xa7342b8a, 21);
	CRC32_EXPORT(_MmMapIoSpace, 0xe3e97fc8, 13);
	CRC32_EXPORT(_MmUnmapIoSpace, 0x61dd59d8, 15);
	CRC32_EXPORT(_MmCopyMemory, 0x447b9e0c, 13);
	CRC32_EXPORT(_RtlRandomEx, 0x212bf249, 12);
	CRC32_EXPORT(_DbgPrint, 0xbb9e4a14, 9);
	CRC32_EXPORT(_ExAllocatePoolWithTag, 0x3d274aca, 22);
	CRC32_EXPORT(_ExFreePoolWithTag, 0xbf55cf42, 18);
	CRC32_EXPORT(_IoDriverObjectType, 0x4929b432, 19);
	CRC32_EXPORT(_ObReferenceObjectByName, 0xb4cde7b1, 24);
	CRC32_EXPORT(_IoBuildDeviceIoControlRequest, 0x486b6f47, 30);
	CRC32_EXPORT(_IofCallDriver, 0x2bfbfcc3, 14);
	CRC32_EXPORT(_PsGetThreadId, 0xb0fd823, 14);
	CRC32_EXPORT(_PsLookupThreadByThreadId, 0xff312af1, 25);
	CRC32_EXPORT(_IoAllocateMdl, 0x16833110, 14);
	CRC32_EXPORT(_MmProbeAndLockPages, 0xbc7855a4, 20);
	CRC32_EXPORT(_MmMapLockedPagesSpecifyCache, 0xd7bc7957, 29);
	CRC32_EXPORT(_MmUnlockPages, 0x85af60ed, 14);
	CRC32_EXPORT(_IoFreeMdl, 0xd0afdf3e, 10);
	CRC32_EXPORT(_MmUnmapLockedPages, 0xb38e8b38, 19);
	CRC32_EXPORT(_memcpy, 0xe2003a33, 7);
	CRC32_EXPORT(_PsGetThreadExitStatus, 0x981a33d, 22);
#endif

	return 1;
}

BOOLEAN MemCopyWP(PVOID dest, PVOID src, ULONG length)
{
	PMDL mdl = _IoAllocateMdl(dest, length, FALSE, FALSE, NULL);
	if (!mdl) {
		return FALSE;
	}

	_MmProbeAndLockPages(mdl, KernelMode, IoModifyAccess);

	PVOID mapped = _MmMapLockedPagesSpecifyCache(mdl, KernelMode, MmNonCached, NULL, 0, HighPagePriority);
	if (!mapped) {
		_MmUnlockPages(mdl);
		_IoFreeMdl(mdl);
		return FALSE;
	}

	_memcpy(mapped, src, length);

	_MmUnmapLockedPages(mapped, mdl);
	_MmUnlockPages(mdl);
	_IoFreeMdl(mdl);
	return TRUE;
}

#pragma warning(disable : 4201)
typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	WORD LoadCount;
	WORD TlsIndex;
	union
	{
		LIST_ENTRY HashLinks;
		struct
		{
			PVOID SectionPointer;
			ULONG CheckSum;
		};
	};
	union
	{
		ULONG TimeDateStamp;
		PVOID LoadedImports;
	};
	PVOID* EntryPointActivationContext;
	PVOID PatchInformation;
	LIST_ENTRY ForwarderLinks;
	LIST_ENTRY ServiceTagLinks;
	LIST_ENTRY StaticLinks;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

QWORD GetSystemBaseAddressQ(PDRIVER_OBJECT DriverObject, DWORD crc, DWORD crc_len)
{
	PLDR_DATA_TABLE_ENTRY ldr = (PLDR_DATA_TABLE_ENTRY)DriverObject->DriverSection;
	for (PLIST_ENTRY pListEntry = ldr->InLoadOrderLinks.Flink; pListEntry != &ldr->InLoadOrderLinks; pListEntry = pListEntry->Flink)
	{
		PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

		if (pEntry->BaseDllName.Buffer && crc32((PCSTR)pEntry->BaseDllName.Buffer, crc_len, g_encryption_key) == crc) {
			return (QWORD)pEntry->DllBase;
		}

	}
	return 0;
}

#ifdef _KERNEL_MODE
typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
    WORD        Magic;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint;
    DWORD       BaseOfCode;
    ULONGLONG   ImageBase;
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage;
    DWORD       SizeOfHeaders;
    DWORD       CheckSum;
    WORD        Subsystem;
    WORD        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_NT_HEADERS64 {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_SECTION_HEADER {
    BYTE    Name[8];
    union {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#endif
QWORD ResolveEntryAddress(PDRIVER_OBJECT driver)
{
	PLDR_DATA_TABLE_ENTRY ldr = (PLDR_DATA_TABLE_ENTRY)driver->DriverSection;
	// ldr->DllBase

	unsigned char *ldr_base = (unsigned char* )ldr->DllBase;

        IMAGE_NT_HEADERS64* ntHeaders =
                (IMAGE_NT_HEADERS64*)(ldr_base +
                        ((IMAGE_DOS_HEADER*)ldr_base)->e_lfanew);

	return (QWORD)(ldr_base + ntHeaders->OptionalHeader.AddressOfEntryPoint);
}

void clear_pe_header(QWORD map_driver_base)
{
	IMAGE_NT_HEADERS64* nt_headers =
		(IMAGE_NT_HEADERS64*)(map_driver_base +
			((IMAGE_DOS_HEADER*)map_driver_base)->e_lfanew);

	for (DWORD i = nt_headers->OptionalHeader.SizeOfHeaders; i--;)
		((unsigned char*)map_driver_base)[i] = 0;
}

```

`umap-uefi/boot.default.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup Label="UserMacros">
    <EDK_PATH>..\edk2</EDK_PATH>
  </PropertyGroup>
  <PropertyGroup>
    <IncludePath>$(EDK_PATH)\MdePkg\Include;$(EDK_PATH)\MdePkg\Include\X64;$(EDK_PATH)\ShellPkg\Include;$(EDK_PATH)\CryptoPkg\Include</IncludePath>
    <LibraryPath>$(EDK_PATH)\$(Platform)\$(Configuration)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>$(DefaultPlatformToolset)</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <ItemGroup>
    <BuildMacro Include="EDK_PATH">
      <Value>$(EDK_PATH)</Value>
      <EnvironmentVariable>true</EnvironmentVariable>
    </BuildMacro>
  </ItemGroup>
</Project>

```

`umap-uefi/boot.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup>
    <GenerateManifest />
    <IntDir>$(SolutionDir)$(Platform)\$(Configuration)\obj\$(TargetName)\</IntDir>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <TargetExt>.efi</TargetExt>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <WarningLevel>Level4</WarningLevel>
      <TreatWarningAsError>true</TreatWarningAsError>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <OmitFramePointers>true</OmitFramePointers>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <ExceptionHandling>SyncCThrow</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <ForcedIncludeFiles>..\edk2\BaseLib\vshacks.h</ForcedIncludeFiles>
      <CallingConvention />
      <TreatWChar_tAsBuiltInType />
      <StringPooling>true</StringPooling>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <ForceConformanceInForLoopScope />
      <AdditionalOptions>/Gs32768 %(AdditionalOptions)</AdditionalOptions>
      <ErrorReporting />
      <FloatingPointModel />
    </ClCompile>
    <Link>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>UefiHiiLib.lib;UefiHiiServicesLib.lib;UefiSortLib.lib;UefiShellLib.lib;GlueLib.lib;BaseLib.lib;BaseDebugPrintErrorLevelLib.lib;BasePrintLib.lib;UefiLib.lib;UefiBootServicesTableLib.lib;UefiRuntimeServicesTableLib.lib;UefiDevicePathLibDevicePathProtocol.lib;UefiDebugLibConOut.lib;UefiMemoryLib.lib;UefiMemoryAllocationLib.lib;BaseSynchronizationLib.lib;UefiFileHandleLib.lib</AdditionalDependencies>
      <GenerateDebugInformation>DebugFastLink</GenerateDebugInformation>
      <SubSystem>EFI Boot Service Driver</SubSystem>
      <Driver>Driver</Driver>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding />
      <LinkTimeCodeGeneration>UseFastLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <BaseAddress>0</BaseAddress>
      <SectionAlignment>32</SectionAlignment>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <RandomizedBaseAddress />
      <DataExecutionPrevention />
      <ManifestFile />
      <AllowIsolation />
      <EnableUAC />
      <UACExecutionLevel />
      <UACUIAccess />
      <TypeLibraryResourceID />
      <AdditionalOptions>/OPT:ICF=10 /IGNORE:4001 /IGNORE:4254 /IGNORE:4281 %(AdditionalOptions)</AdditionalOptions>
      <MergeSections>.rdata=.data</MergeSections>
      <SpecifySectionAttributes>.xdata,D</SpecifySectionAttributes>
      <LinkErrorReporting />
      <ProfileGuidedDatabase />
      <EntryPointSymbol>EfiMain</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
</Project>

```

`umap-uefi/boot.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30413.136
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "boot", "boot.vcxproj", "{79D78FD5-8F41-442F-944E-81774DC9DF39}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{79D78FD5-8F41-442F-944E-81774DC9DF39}.Release|x64.ActiveCfg = Release|x64
		{79D78FD5-8F41-442F-944E-81774DC9DF39}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {8B81D542-88C7-4CE0-B921-E6F43D1B2D9F}
	EndGlobalSection
EndGlobal

```

`umap-uefi/boot.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{79D78FD5-8F41-442F-944E-81774DC9DF39}</ProjectGuid>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>bootx64</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(SolutionDir)\boot.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <Import Project="$(SolutionDir)\boot.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
  <ItemDefinitionGroup>
    <Link>
      <AdditionalDependencies>UefiApplicationEntryPoint.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <SubSystem>EFI Application</SubSystem>
      <GenerateDebugInformation Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</GenerateDebugInformation>
    </Link>
    <ClCompile>
      <TreatWarningAsError Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</TreatWarningAsError>
      <RuntimeLibrary Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</BufferSecurityCheck>
      <ControlFlowGuard Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
    <ClCompile Include="util.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="util.h" />
  </ItemGroup>
</Project>
```

`umap-uefi/boot.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Header Files">
      <UniqueIdentifier>{1bb1e3e7-3d88-45c4-861a-b3afcff9fd29}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files">
      <UniqueIdentifier>{dcae272e-95fb-445d-bcde-4502ced9bcae}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{297f9290-d3fe-4cca-b1fb-43cb37aa1c6b}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="util.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="main.c" />
  </ItemGroup>
</Project>
```

`umap-uefi/boot.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`umap-uefi/main.c`:

```c
#include "stdafx.h"

/*
 * project based on umap
 * - load driver for extended signed driver ( MICROCODE driver ) address space
 * - load driver from USB filesystem
 * - (map driver must have enough zeroes at end, correct binary size: ~10-25KB for bug free load)
 * - :waving: FACEIT AC team
 */

CHAR8* gEfiCallerBaseName = "";
UINT32 _gUefiDriverRevision = 0;

EFI_EXIT_BOOT_SERVICES ExitBootServicesOriginal;
UINT8 ImgArchStartBootApplicationOriginal[JMP_SIZE];
IMG_ARCH_START_BOOT_APPLICATION ImgArchStartBootApplication;

UINT8 BlImgAllocateImageBufferOriginal[JMP_SIZE];
BL_IMG_ALLOCATE_IMAGE_BUFFER BlImgAllocateImageBuffer;

UINT8 OslFwpKernelSetupPhase1Original[JMP_SIZE];
OSL_FWP_KERNEL_SETUP_PHASE_1 OslFwpKernelSetupPhase1;

struct {
        VOID* Base;
        UINT32 Size;
        CHAR16* ProtectedModeError;
        EFI_STATUS ProtectedModeStatus;
} winload = { NULL };


struct {
    VOID *AllocatedBuffer;
    EFI_STATUS AllocatedBufferStatus;
} mapper = { NULL };

#define EFI_FILE_INFO_ID \
   { \
     0x9576e92, 0x6d3f, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b } \
   }

typedef struct {
        ///
        /// The size of the EFI_FILE_INFO structure, including the Null-terminated FileName string.
        ///
        UINT64    Size;
        ///
        /// The size of the file in bytes.
        ///
        UINT64    FileSize;
        ///
        /// PhysicalSize The amount of physical space the file consumes on the file system volume.
        ///
        UINT64    PhysicalSize;
        ///
        /// The time the file was created.
        ///
        EFI_TIME  CreateTime;
        ///
        /// The time when the file was last accessed.
        ///
        EFI_TIME  LastAccessTime;
        ///
        /// The time when the file's contents were last modified.
        ///
        EFI_TIME  ModificationTime;
        ///
        /// The attribute bits for the file.
        ///
        UINT64    Attribute;
        ///
        /// The Null-terminated name of the file.
        ///
        CHAR16    FileName[1];
} EFI_FILE_INFO;


static EFI_GUID fileInfoId = EFI_FILE_INFO_ID;
static UINT64 getInfoSize(EFI_FILE* file) {
        UINTN infoSize = 0;
        if (file->GetInfo(file, &fileInfoId, &infoSize, NULL) != EFI_BUFFER_TOO_SMALL)
                return 1;

        return (UINT64)infoSize;
}

static unsigned int getInfo(EFI_FILE* file, EFI_FILE_INFO* info, UINT64 size) {
        return
                size > 1 &&
                file->GetInfo(file, &fileInfoId, (UINTN*)&size, info) == EFI_SUCCESS;
}

unsigned char* MAPPER_BUFFER;
UINTN map_driver_size;



unsigned char* load_mapped_image()
{
        void* file_buffer = NULL;
        EFI_BOOT_SERVICES* bs = gBS;
        EFI_GUID sfspGuid = EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID;
        EFI_HANDLE* handles = NULL;
        UINTN handleCount = 0;

        EFI_STATUS Status = bs->LocateHandleBuffer(ByProtocol,
                &sfspGuid,
                NULL,
                &handleCount,
                &handles);
        if (EFI_ERROR(Status)) {
                return NULL;
        }


        EFI_FILE_PROTOCOL* file = NULL;
        EFI_FILE_PROTOCOL* root = NULL;

        for (int index = 0; index < (int)handleCount; ++index) {
                EFI_SIMPLE_FILE_SYSTEM_PROTOCOL* fs = NULL;
                Status = bs->HandleProtocol(
                        handles[index],
                        &sfspGuid,
                        (void**)&fs);

                if (EFI_ERROR(Status))
                        continue;


                Status = fs->OpenVolume(fs, &root);

                if (EFI_ERROR(Status))
                        continue;

                Status = root->Open(
                        root,
                        &file,
                        L"g2ldr",
                        EFI_FILE_MODE_READ,
                        EFI_FILE_READ_ONLY | EFI_FILE_HIDDEN | EFI_FILE_SYSTEM);

                if (EFI_ERROR(Status))
                        continue;

                break;
        }

        if (!EFI_ERROR(Status)) {
                if (file == 0)
                        return file_buffer;

                UINT64 file_info_size = getInfoSize(file);

                if (file_info_size == 0)
                        return NULL;

                EFI_FILE_INFO* info = AllocatePool(file_info_size);

                if (getInfo(file, info, file_info_size) == 0)
                        return NULL;

                UINTN file_size = info->FileSize;

                for (int i = 0; i < file_info_size; i++)
                        *(char*)((char*)info + i) = 0;

                FreePool(info);

                file_buffer = AllocatePool(file_size);


                if (EFI_ERROR(file->Read(file, &file_size, file_buffer))) {
                        root->Close(file);
                        FreePool(file_buffer);
                        return NULL;
                }

                map_driver_size = file_size;

                root->Close(file);
        }
        return file_buffer;
}

unsigned int usb_device_exists()
{
        EFI_BOOT_SERVICES* bs = gBS;
        EFI_GUID sfspGuid = EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID;
        EFI_HANDLE* handles = NULL;
        UINTN handleCount = 0;

        EFI_STATUS Status = bs->LocateHandleBuffer(ByProtocol,
                &sfspGuid,
                NULL,
                &handleCount,
                &handles);

        if (EFI_ERROR(Status)) {
                return 0;
        }


        EFI_FILE_PROTOCOL* file = NULL;
        EFI_FILE_PROTOCOL* root = NULL;

        for (int index = 0; index < (int)handleCount; ++index) {
                EFI_SIMPLE_FILE_SYSTEM_PROTOCOL* fs = NULL;
                Status = bs->HandleProtocol(
                        handles[index],
                        &sfspGuid,
                        (void**)&fs);

                if (EFI_ERROR(Status))
                        continue;


                Status = fs->OpenVolume(fs, &root);

                if (EFI_ERROR(Status))
                        continue;

                Status = root->Open(
                        root,
                        &file,
                        L"g2ldr",
                        EFI_FILE_MODE_READ,
                        EFI_FILE_READ_ONLY | EFI_FILE_HIDDEN | EFI_FILE_SYSTEM);

                if (EFI_ERROR(Status))
                        continue;

                break;
        }

        if (!EFI_ERROR(Status)) {
                root->Close(file);

                return 1;
        }


        return 0;
}

// UEFI entrypoint
EFI_STATUS EFIAPI UefiMain(EFI_HANDLE imageHandle,
        EFI_SYSTEM_TABLE* systemTable) {
        gST->ConOut->ClearScreen(gST->ConOut);
        gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);


        Print(L"[+] SMAP loaded\n");
        winload.ProtectedModeError = L"failed to inject";

        MAPPER_BUFFER = load_mapped_image();
        if (MAPPER_BUFFER == NULL)
                return EFI_NOT_FOUND;


        // gBS->AllocatePool(EfiRuntimeServicesCode , FAKE_BUFFER_SIZE, &FAKE_BUFFER);
        // Locate the Windows EFI bootmgr
        EFI_DEVICE_PATH* bootmgrPath = GetWindowsBootmgrDevicePath();
        if (!bootmgrPath) {
                Print(L"Windows UEFI loader not found (0x00), pleace install windows as UEFI\n");
                gBS->Stall(SEC_TO_MICRO(2));

                return EFI_NOT_FOUND;
        }

        EFI_STATUS status = SetBootCurrentToWindowsBootmgr();
        if (EFI_ERROR(status)) {
                Print(L"Windows UEFI loader not found (0x01), pleace install windows as UEFI\n");
                gBS->Stall(SEC_TO_MICRO(2));

                FreePool(bootmgrPath);
                return status;
        }

        // Load the Windows EFI bootmgr
        EFI_HANDLE bootmgrHandle;
        status =
                gBS->LoadImage(TRUE, imageHandle, bootmgrPath, NULL, 0, &bootmgrHandle);

        if (EFI_ERROR(status)) {
                Print(L"Unknown error: 0x10\n");
                gBS->Stall(SEC_TO_MICRO(2));

                FreePool(bootmgrPath);
                return status;
        }

        FreePool(bootmgrPath);

        // Setup the hook chain
        status = SetupHooks(bootmgrHandle);
        if (EFI_ERROR(status)) {
                Print(L"Unknown error: 0x09\n");
                gBS->Stall(SEC_TO_MICRO(2));
                gBS->UnloadImage(bootmgrHandle);
                return status;
        }
        
        EFI_STATUS         Status;
        EFI_EVENT          WaitList;
        EFI_INPUT_KEY      Key;
        UINTN              Index;
        Print(L"Unplug USB device\n");
        Print(L"Press any key to continue . . .");
        do {
                WaitList = gST->ConIn->WaitForKey;
                Status = gBS->WaitForEvent(1, &WaitList, &Index);
                gST->ConIn->ReadKeyStroke(gST->ConIn, &Key);

                Print(L"\n");
                if (usb_device_exists()) {
                        Print(L"Unplug USB device\n");
                        Print(L"Press any key to continue . . .");
                }
                else {
                        break;
                }
        } while (Key.ScanCode != SCAN_F11);

        // Start the Windows EFI bootmgr
        status = gBS->StartImage(bootmgrHandle, NULL, NULL);
        if (EFI_ERROR(status)) {
                Print(L"Unknown error: 0x08\n");
                gBS->Stall(SEC_TO_MICRO(2));

                gBS->UnloadImage(bootmgrHandle);
                return status;
        }

        return EFI_SUCCESS;
}

// Sets up the hook chain from bootmgr -> winload -> ntoskrnl
EFI_STATUS EFIAPI SetupHooks(EFI_HANDLE bootmgrHandle) {
        // Get the bootmgr image from the image handle
        EFI_LOADED_IMAGE* bootmgr;
        EFI_STATUS status = gBS->HandleProtocol(
                bootmgrHandle, &gEfiLoadedImageProtocolGuid, (VOID**)&bootmgr);

        if (EFI_ERROR(status)) {
                Print(L"Unknown error: 0x07\n");
                return status;
        }

        // Hook ImgArchStartBootApplication to setup winload hooks
        VOID* func = FindPattern(bootmgr->ImageBase, bootmgr->ImageSize,
                "\x48\x8B\xC4\x48\x89\x58\x20\x44\x89\x40\x18\x48"
                "\x89\x50\x10\x48\x89\x48\x08\x55\x56\x57\x41\x54",
                "xxxxxxxxxxxxxxxxxxxxxxxx");

        if (!func) {            
                 func = FindPattern(bootmgr->ImageBase, bootmgr->ImageSize,
                                "\xE8\x00\x00\x00\x00\x48\x8B\xCE\x8B\xD8\xE8\x00\x00\x00\x00\x41\x8B\xCF",
                                "x????xxxxxx????xxx");
                 if (!func) {
                        Print(L"Unknown error: 0x06\n");
                        return EFI_NOT_FOUND;
                 }
                 func = RELATIVE_ADDR((UINT8*)func, 5);
        }

        ImgArchStartBootApplication =
                (IMG_ARCH_START_BOOT_APPLICATION)TrampolineHook(
                        (VOID*)ImgArchStartBootApplicationHook, func,
                        ImgArchStartBootApplicationOriginal);

        return EFI_SUCCESS;
}

// Called from bootmgr to start the winload image
EFI_STATUS EFIAPI ImgArchStartBootApplicationHook(VOID* appEntry,
        VOID* imageBase,
        UINT32 imageSize,
        UINT8 bootOption,
        VOID* returnArguments) {

        TrampolineUnHook((VOID*)ImgArchStartBootApplication,
                ImgArchStartBootApplicationOriginal);

        winload.Base = imageBase;
        winload.Size = imageSize;
        VOID* funcCall =
                FindPattern(imageBase, imageSize,
                        "\x74\x07\xE8\x00\x00\x00\x00\x8B\xD8", "xxx????xx");


        if (!funcCall) {
                funcCall = FindPattern(imageBase, imageSize,
                        "\x40\x55\x53\x56\x57\x41\x54\x41\x55\x41\x56\x41\x57\x48\x8B\xEC"
                        "\x48\x83\xEC\x68\x48\x8B\xF9\x48\x8D\x4D\x60",
                        "xxxxxxxxxxxxxxxxxxxxxxxxxxx");

                if (!funcCall) {
                        funcCall = FindPattern(imageBase, imageSize,
                                "\x48\x89\x4C\x24\x08\x55\x53\x56\x57\x41\x54\x41\x55\x41"
                                "\x56\x41\x57\x48\x8D\x6C\x24\xE1\x48\x81\xEC\xB8\x00\x00"
                                "\x00\x48\x8B\xF1\x33\xFF\x48\x8D\x4D\x6F\x48\x89",
                                "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx");

                        if (!funcCall) {
                                ExitBootServicesOriginal = gBS->ExitBootServices;
                                gBS->ExitBootServices = ExitBootServicesHook;
                                return ImgArchStartBootApplication(appEntry, imageBase, imageSize,
                                        bootOption, returnArguments);
                        }
                }
        } else {
                funcCall = FindPattern(RELATIVE_ADDR((UINT8 *)funcCall + 2, 5), 0x4F,
                        "\x48\x8B\xCF\xE8", "xxxx");

                funcCall = RELATIVE_ADDR((UINT8 *)funcCall + 3, 5);

                
        }

        OslFwpKernelSetupPhase1 = (OSL_FWP_KERNEL_SETUP_PHASE_1)TrampolineHook(
                (VOID*)OslFwpKernelSetupPhase1Hook,
                funcCall,
                OslFwpKernelSetupPhase1Original);

        // Hook BlImgAllocateImageBuffer to allocate the mapper's buffer
        funcCall =
                FindPattern(imageBase, imageSize,
                        "\xE8\x00\x00\x00\x00\x4C\x8B\x6D\x60", "x????xxxx");

        if (!funcCall) {
                funcCall =
                        FindPattern(imageBase, imageSize,
                                "\xE8\x00\x00\x00\x00\x4C\x8B\x65\x60", "x????xxxx");
        }

        BlImgAllocateImageBuffer = (BL_IMG_ALLOCATE_IMAGE_BUFFER)TrampolineHook(
                (VOID*)BlImgAllocateImageBufferHook, RELATIVE_ADDR(funcCall, 5),
                BlImgAllocateImageBufferOriginal);

        // Hook ExitBootServices
        ExitBootServicesOriginal = gBS->ExitBootServices;
        gBS->ExitBootServices = ExitBootServicesHook;


        return ImgArchStartBootApplication(appEntry, imageBase, imageSize,
                bootOption, returnArguments);
}

// Called by winload to allocate image buffers in protected mode, use it to
// allocate the mapper's buffer as well Hooking this instead of calling it
// within another hook alleviates some tedious setup (credits to sa413x)

#define PAGE_SIZE   4096
#define ROUND_TO_PAGES(Size) (((UINT64) (Size) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

UINT64 map_previous_address;
UINT64 map_previous_size;

EFI_STATUS EFIAPI BlImgAllocateImageBufferHook(
        VOID** imageBuffer,
        UINTN imageSize,
        UINT32 memoryType,
        UINT32 attributes,
        VOID* unused,
        UINT32 flags)
{

        TrampolineUnHook((VOID*)BlImgAllocateImageBuffer,
                BlImgAllocateImageBufferOriginal);

        /*
         * if winload is allocating signed driver memory, extend it ( create own memory space end of the page )
         */

        if (memoryType == BL_MEMORY_TYPE_APPLICATION) {
                map_previous_size = imageSize;
                imageSize += MAPPER_BUFFER_SIZE;
        }

        EFI_STATUS status = BlImgAllocateImageBuffer(
                imageBuffer, imageSize, memoryType, attributes, unused, flags);

        if (!EFI_ERROR(status) && memoryType == BL_MEMORY_TYPE_APPLICATION && map_previous_size != 0) {

                mapper.AllocatedBuffer = (void *)*(UINT64 *)imageBuffer;
                mapper.AllocatedBuffer = (void *)((UINT64)mapper.AllocatedBuffer + imageSize - MAPPER_BUFFER_SIZE);
                mapper.AllocatedBufferStatus = (EFI_STATUS)0;
                map_previous_address = *(UINT64*)imageBuffer;
                return status;
        }

        TrampolineHook((VOID*)BlImgAllocateImageBufferHook,
                (VOID*)BlImgAllocateImageBuffer,
                BlImgAllocateImageBufferOriginal);

        return status;
}

// Called by winload with a valid LPB in protected mode before calling
// ExitBootServices
EFI_STATUS EFIAPI
OslFwpKernelSetupPhase1Hook(LOADER_PARAMETER_BLOCK* loaderParameterBlock) {
        TrampolineUnHook((VOID*)OslFwpKernelSetupPhase1,
                OslFwpKernelSetupPhase1Original);

        /*
         * 
         * find that extended driver address, and change loader block driver size to correct length
         */

        KLDR_DATA_TABLE_ENTRY* target_driver = GetModuleEntryAddr(&loaderParameterBlock->LoadOrderListHead, (UINT64)map_previous_address);
        if (target_driver) {
                target_driver->SizeOfImage = target_driver->SizeOfImage + MAPPER_BUFFER_SIZE;
        } else {
                mapper.AllocatedBuffer = 0;
        }

        if (mapper.AllocatedBuffer) {
                KLDR_DATA_TABLE_ENTRY* ntoskrnl = GetModuleEntry(
                        &loaderParameterBlock->LoadOrderListHead, L"ntoskrnl.exe");

                KLDR_DATA_TABLE_ENTRY* hal = GetModuleEntry(
                        &loaderParameterBlock->LoadOrderListHead, L"hal.dll");

                if (ntoskrnl) {
                        KLDR_DATA_TABLE_ENTRY* targetModule = GetModuleEntry(
                                &loaderParameterBlock->LoadOrderListHead, L"acpiex.sys");

                        if (targetModule) {
                                winload.ProtectedModeStatus =
                                        SetupMapper(ntoskrnl, hal, targetModule);
                        } else {
                                winload.ProtectedModeStatus = EFI_NOT_FOUND;
                                winload.ProtectedModeError =
                                        L"Unknown error: 0x05";
                        }
                } else {
                        winload.ProtectedModeStatus = EFI_NOT_FOUND;
                        winload.ProtectedModeError =
                                L"Unknown error: 0x04";
                }
        } else {
                winload.ProtectedModeStatus = EFI_NOT_FOUND;
                winload.ProtectedModeError = L"Unknown error: 0x03";
        }

        return OslFwpKernelSetupPhase1(loaderParameterBlock);
}

// Sets up the mapper (in protected mode)
EFI_STATUS EFIAPI SetupMapper(KLDR_DATA_TABLE_ENTRY* ntoskrnl,
        KLDR_DATA_TABLE_ENTRY* hal,
        KLDR_DATA_TABLE_ENTRY* targetModule) {
        // Map the mapper
        VOID* mapperEntryPoint;
        EFI_STATUS status = MapMapper(ntoskrnl->ImageBase, hal, &mapperEntryPoint,
                targetModule->EntryPoint);

        if (EFI_ERROR(status)) {
                return status;
        }

        MemCopy(targetModule->EntryPoint, "\x4C\x8D\x05\xF9\xFF\xFF\xFF", // lea r8, [rip - 7]
                7);

        TrampolineHook(mapperEntryPoint, (UINT8*)targetModule->EntryPoint + 7,
                NULL);

        return EFI_SUCCESS;
}

// Maps the driver manual mapper (in protected mode)
EFI_STATUS EFIAPI MapMapper(VOID* ntoskrnlBase, KLDR_DATA_TABLE_ENTRY *hal, VOID** entryPoint, VOID* targetFunction)
{
        UINT8* mapperBase =  mapper.AllocatedBuffer;
        UINT8* mapperBuffer = MAPPER_BUFFER;

        // No point in checking signature when it's controlled
        IMAGE_NT_HEADERS64* ntHeaders =
                (IMAGE_NT_HEADERS64*)(mapperBuffer +
                        ((IMAGE_DOS_HEADER*)mapperBuffer)->e_lfanew);

        // Map headers
        MemCopy(mapperBase, mapperBuffer, ntHeaders->OptionalHeader.SizeOfHeaders);

        // Map sections
        IMAGE_SECTION_HEADER* sections =
                (IMAGE_SECTION_HEADER*)((UINT8*)&ntHeaders->OptionalHeader +
                        ntHeaders->FileHeader.SizeOfOptionalHeader);

        for (UINT16 i = 0; i < ntHeaders->FileHeader.NumberOfSections; ++i) {
                IMAGE_SECTION_HEADER* section = &sections[i];
                if (section->SizeOfRawData) {
                        MemCopy(mapperBase + section->VirtualAddress,
                                mapperBuffer + section->PointerToRawData,
                                section->SizeOfRawData);
                }
        }

        // Resolve ntoskrnl imports
        UINT32 importsRva =
                ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]
                .VirtualAddress;

        if (importsRva) {
                IMAGE_IMPORT_DESCRIPTOR* importDescriptor =
                        (IMAGE_IMPORT_DESCRIPTOR*)(mapperBase + importsRva);
       


                for (; importDescriptor->FirstThunk; ++importDescriptor) {

                        if (importDescriptor->FirstThunk == 0)
                                break;

                        IMAGE_THUNK_DATA64* thunk =
                                (IMAGE_THUNK_DATA64*)(mapperBase +
                                        importDescriptor->FirstThunk);

                        if (thunk == 0)
                                break;

                        if (importDescriptor->OriginalFirstThunk == 0)
                                break;

                        IMAGE_THUNK_DATA64* thunkOriginal =
                                (IMAGE_THUNK_DATA64*)(mapperBase +
                                        importDescriptor->OriginalFirstThunk);

                        for (; thunk->u1.AddressOfData; ++thunk, ++thunkOriginal) {
                                UINT64 import = GetExport(
                                        ntoskrnlBase,
                                        ((IMAGE_IMPORT_BY_NAME*)(mapperBase +
                                                thunkOriginal->u1.AddressOfData))
                                        ->Name);

                                if (!import) {
                                        import = GetExport(
                                                hal->ImageBase,
                                                ((IMAGE_IMPORT_BY_NAME*)(mapperBase +
                                                        thunkOriginal->u1.AddressOfData))
                                                ->Name);

                                        if (!import) {
                                                winload.ProtectedModeError =
                                                        L"Unknown error: 0x02";
                                                return EFI_NOT_FOUND;
                                        }
                                }

                                thunk->u1.Function = import;
                        }
                }
                
        }

        // Resolve relocations
        IMAGE_DATA_DIRECTORY* baseRelocDir =
                &ntHeaders->OptionalHeader
                .DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];

        if (baseRelocDir->VirtualAddress) {
                IMAGE_BASE_RELOCATION* reloc =
                        (IMAGE_BASE_RELOCATION*)(mapperBase +
                                baseRelocDir->VirtualAddress);

                for (UINT32 currentSize = 0; currentSize < baseRelocDir->Size;) {
                        UINT32 relocCount =
                                (reloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) /
                                sizeof(UINT16);

                        UINT16* relocData =
                                (UINT16*)((UINT8*)reloc + sizeof(IMAGE_BASE_RELOCATION));

                        UINT8* relocBase = mapperBase + reloc->VirtualAddress;

                        for (UINT32 i = 0; i < relocCount; ++i, ++relocData) {
                                UINT16 data = *relocData;
                                UINT16 type = data >> 12;
                                UINT16 offset = data & 0xFFF;

                                switch (type) {
                                case IMAGE_REL_BASED_ABSOLUTE:
                                        break;
                                case IMAGE_REL_BASED_DIR64: {
                                        UINT64* rva = (UINT64*)(relocBase + offset);
                                        *rva =
                                                (UINT64)(mapperBase +
                                                        (*rva - ntHeaders->OptionalHeader.ImageBase));
                                        break;
                                }
                                default:
                                        winload.ProtectedModeError = L"Unknown error: 0x01\n";
                                        return EFI_UNSUPPORTED;
                                }
                        }

                        currentSize += reloc->SizeOfBlock;
                        reloc = (IMAGE_BASE_RELOCATION*)relocData;
                }
        }

        // Copy mapper data
        UINT32 exportsRva =
                ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]
                .VirtualAddress;

        if (exportsRva) {
                IMAGE_EXPORT_DIRECTORY* exports =
                        (IMAGE_EXPORT_DIRECTORY*)(mapperBase + exportsRva);

                if (exports->NumberOfNames) {
                        UINT32* funcRva =
                                (UINT32*)(mapperBase + exports->AddressOfFunctions);

                        UINT16* ordinalRva =
                                (UINT16*)(mapperBase + exports->AddressOfNameOrdinals);

                        MemCopy(mapperBase + funcRva[ordinalRva[0]], targetFunction,
                                MAPPER_DATA_SIZE);

                        *(UINT64*)(mapperBase + funcRva[ordinalRva[0]] + MAPPER_DATA_SIZE) = (UINT64)(mapperBase);
                }
        }

        winload.ProtectedModeError = L"injected";

        *entryPoint = mapperBase + ntHeaders->OptionalHeader.AddressOfEntryPoint;

        return EFI_SUCCESS;
}

// Called by winload to unload boot services
EFI_STATUS EFIAPI ExitBootServicesHook(EFI_HANDLE imageHandle, UINTN mapKey) {
        gST->ConOut->ClearScreen(gST->ConOut);
        gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

        Print(L"smap status: %s\n", winload.ProtectedModeError);
        for (int i = MAPPER_BUFFER_SIZE; i--;)
                ((unsigned char*)MAPPER_BUFFER)[i]=0;
        FreePool(MAPPER_BUFFER);
        gBS->ExitBootServices = ExitBootServicesOriginal;
        return gBS->ExitBootServices(imageHandle, mapKey);
}

// Locates the device path for the Windows bootmgr
EFI_DEVICE_PATH* EFIAPI GetWindowsBootmgrDevicePath() {
        UINTN handleCount;
        EFI_HANDLE* handles;
        EFI_DEVICE_PATH* devicePath = NULL;

        // Retrieve filesystem handles
        EFI_STATUS status =
                gBS->LocateHandleBuffer(ByProtocol, &gEfiSimpleFileSystemProtocolGuid,
                        NULL, &handleCount, &handles);

        if (EFI_ERROR(status)) {
                Print(L"Unknown error: 0x00\n");
                return devicePath;
        }

        // Check each FS for the bootmgr
        for (UINTN i = 0; i < handleCount && !devicePath; ++i) {
                EFI_FILE_IO_INTERFACE* fileSystem;
                status = gBS->OpenProtocol(
                        handles[i], &gEfiSimpleFileSystemProtocolGuid, (VOID**)&fileSystem,
                        gImageHandle, NULL, EFI_OPEN_PROTOCOL_GET_PROTOCOL);

                if (EFI_ERROR(status)) {
                        continue;
                }

                EFI_FILE_HANDLE volume;
                status = fileSystem->OpenVolume(fileSystem, &volume);
                if (!EFI_ERROR(status)) {
                        EFI_FILE_HANDLE file;
                        status = volume->Open(volume, &file, WINDOWS_BOOTMGR_PATH,
                                EFI_FILE_MODE_READ, EFI_FILE_READ_ONLY);

                        if (!EFI_ERROR(status)) {
                                volume->Close(file);

                                devicePath = FileDevicePath(handles[i], WINDOWS_BOOTMGR_PATH);
                        }
                }

                gBS->CloseProtocol(handles[i], &gEfiSimpleFileSystemProtocolGuid,
                        gImageHandle, NULL);
        }

        gBS->FreePool(handles);
        return devicePath;
}

// Sets BootCurrent to Windows bootmgr option
EFI_STATUS EFIAPI SetBootCurrentToWindowsBootmgr() {
        // Query boot order array
        UINTN bootOrderSize = 0;
        EFI_STATUS status =
                gRT->GetVariable(EFI_BOOT_ORDER_VARIABLE_NAME, &gEfiGlobalVariableGuid,
                        NULL, &bootOrderSize, NULL);

        if (status != EFI_BUFFER_TOO_SMALL) {
                return status;
        }

        UINT16* bootOrder = AllocatePool(bootOrderSize);
        if (!bootOrder) {
                return EFI_OUT_OF_RESOURCES;
        }

        status =
                gRT->GetVariable(EFI_BOOT_ORDER_VARIABLE_NAME, &gEfiGlobalVariableGuid,
                        NULL, &bootOrderSize, bootOrder);

        if (EFI_ERROR(status)) {
                FreePool(bootOrder);
                return status;
        }

        // Try each boot option to find Windows boot manager
        BOOLEAN found = FALSE;
        for (UINTN i = 0; i < bootOrderSize / sizeof(bootOrder[0]) && !found; ++i) {
                CHAR16 variableName[0xFF];
                UnicodeSPrint(variableName, sizeof(variableName), L"Boot%04x",
                        bootOrder[i]);

                UINTN bufferSize = 0;
                status = gRT->GetVariable(variableName, &gEfiGlobalVariableGuid, NULL,
                        &bufferSize, NULL);

                if (status != EFI_BUFFER_TOO_SMALL) {
                        break;
                }

                UINT8* buffer = AllocatePool(bufferSize);
                if (!buffer) {
                        status = EFI_OUT_OF_RESOURCES;
                        break;
                }

                status = gRT->GetVariable(variableName, &gEfiGlobalVariableGuid, NULL,
                        &bufferSize, buffer);

                if (EFI_ERROR(status)) {
                        FreePool(buffer);
                        break;
                }

                // Check the option file path list
                EFI_LOAD_OPTION* bootOption = (EFI_LOAD_OPTION*)buffer;
                CHAR16* bootOptionDescription =
                        (CHAR16*)(buffer + sizeof(EFI_LOAD_OPTION));

                EFI_DEVICE_PATH_PROTOCOL* bootOptionPaths =
                        (EFI_DEVICE_PATH_PROTOCOL*)(bootOptionDescription +
                                StrLen(bootOptionDescription) + 1);

                if (bootOption->FilePathListLength) {
                        // Only the first path is needed
                        CHAR16* bootOptionPath =
                                ConvertDevicePathToText(&bootOptionPaths[0], FALSE, TRUE);

                        if (bootOptionPath) {
                                // Convert it to lowercase
                                for (CHAR16* c = bootOptionPath; *c; ++c) {
                                        if (*c >= 'A' && *c <= 'Z') {
                                                *c += ('a' - 'A');
                                        }
                                }

                                // Check if it contains the bootmgr path
                                if (StrStr(bootOptionPath, WINDOWS_BOOTMGR_PATH)) {
                                        // If so, update BootCurrent to this option
                                        status = gRT->SetVariable(EFI_BOOT_CURRENT_VARIABLE_NAME,
                                                &gEfiGlobalVariableGuid,
                                                EFI_VARIABLE_BOOTSERVICE_ACCESS |
                                                EFI_VARIABLE_RUNTIME_ACCESS,
                                                sizeof(UINT16), &bootOrder[i]);

                                        if (!EFI_ERROR(status)) {
                                                found = TRUE;
                                        }
                                }

                                FreePool(bootOptionPath);
                        }
                }

                FreePool(buffer);
        }

        FreePool(bootOrder);

        if (!EFI_ERROR(status) && !found) {
                status = EFI_NOT_FOUND;
        }

        return status;
}

EFI_STATUS EFIAPI UefiUnload(EFI_HANDLE imageHandle)
{
        return EFI_SUCCESS;
}

```

`umap-uefi/stdafx.h`:

```h
#pragma once

#include <Uefi.h>
#include <Library/UefiLib.h>
#include <Library/DebugLib.h>
#include <Library/MemoryAllocationLib.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Library/UefiRuntimeServicesTableLib.h>
#include <Library/DevicePathLib.h>
#include <Library/PrintLib.h>
#include <Protocol/SimpleFileSystem.h>
#include <Protocol/LoadedImage.h>
#include <IndustryStandard/PeImage.h>
#include <Guid/GlobalVariable.h>

#include "util.h"

STATIC CHAR16 *WINDOWS_BOOTMGR_PATH = L"\\efi\\microsoft\\boot\\bootmgfw.efi";

#define MAPPER_DATA_SIZE (JMP_SIZE + 7)
#define MAPPER_BUFFER_SIZE (((IMAGE_NT_HEADERS64 *)(MAPPER_BUFFER + ((IMAGE_DOS_HEADER *)MAPPER_BUFFER)->e_lfanew))->OptionalHeader.SizeOfImage)

typedef EFI_STATUS(EFIAPI *IMG_ARCH_START_BOOT_APPLICATION)(VOID *, VOID *, UINT32, UINT8, VOID *);
typedef EFI_STATUS(EFIAPI *BL_IMG_ALLOCATE_IMAGE_BUFFER)(VOID **, UINTN, UINT32, UINT32, VOID *, UINT32);
typedef EFI_STATUS(EFIAPI *OSL_FWP_KERNEL_SETUP_PHASE_1)(LOADER_PARAMETER_BLOCK *);
typedef VOID(*BLP_ARCH_SWITCH_CONTEXT)(BL_ARCH_MODE);

EFI_STATUS EFIAPI SetupHooks(EFI_HANDLE bootmgrHandle);
EFI_STATUS EFIAPI ImgArchStartBootApplicationHook(VOID *appEntry, VOID *imageBase, UINT32 imageSize, UINT8 bootOption, VOID *returnArguments);
EFI_STATUS EFIAPI BlImgAllocateImageBufferHook(VOID **imageBuffer, UINTN imageSize, UINT32 memoryType, UINT32 attributes, VOID *unused, UINT32 flags);
EFI_STATUS EFIAPI OslFwpKernelSetupPhase1Hook(LOADER_PARAMETER_BLOCK *loaderParameterBlock);
EFI_STATUS EFIAPI SetupMapper(KLDR_DATA_TABLE_ENTRY *ntoskrnl, KLDR_DATA_TABLE_ENTRY *hal, KLDR_DATA_TABLE_ENTRY *targetModule);
EFI_STATUS EFIAPI MapMapper(VOID *ntoskrnlBase, KLDR_DATA_TABLE_ENTRY *hal, VOID **entryPoint, VOID *targetFunction);
EFI_STATUS EFIAPI ExitBootServicesHook(EFI_HANDLE imageHandle, UINTN mapKey);

EFI_DEVICE_PATH *EFIAPI GetWindowsBootmgrDevicePath();
EFI_STATUS EFIAPI SetBootCurrentToWindowsBootmgr();
```

`umap-uefi/util.c`:

```c
#include "stdafx.h"

VOID MemCopy(VOID* dest, VOID* src, UINTN size) {
        for (UINT8* d = dest, *s = src; size--; *d++ = *s++)
                ;
}

BOOLEAN CheckMask(unsigned char* base, unsigned char* pattern, unsigned char* mask) {
        for (; *mask; ++base, ++pattern, ++mask) {
                if (*mask == 'x' && *base != *pattern) {
                        return FALSE;
                }
        }

        return TRUE;
}

VOID* FindPattern(unsigned char* base, UINTN size, unsigned char* pattern, unsigned char* mask) {
        size -= AsciiStrLen(mask);

        for (UINTN i = 0; i <= size; ++i) {
                VOID* addr = &base[i];
                if (CheckMask(addr, pattern, mask)) {
                        return addr;
                }
        }

        return NULL;
}

VOID* TrampolineHook(VOID* dest, VOID* src, UINT8 original[JMP_SIZE]) {
        if (original) {
                MemCopy(original, src, JMP_SIZE);
        }

        
        MemCopy(src, "\xFF\x25\x00\x00\x00\x00", 6);
        *(VOID**)((UINT8*)src + 6) = dest;
        

        /*
        MemCopy(src, "\x48\xB8", 2);
        *(VOID**)((UINT8*)src + 2) = dest;
        MemCopy(((char *)src + 10), "\xFF\xE0", 2);
        */


        return src;
}

VOID TrampolineUnHook(VOID* src, UINT8 original[JMP_SIZE]) {
        MemCopy(src, original, JMP_SIZE);
}


INTN
EFIAPI
StrnCmpA (
  IN      CONST CHAR16              *FirstString,
  IN      CONST CHAR16              *SecondString,
  IN      UINTN                     Length
  )
{
        while ((*FirstString != L'\0') &&
                (*SecondString != L'\0') &&
                (AsciiCharToUpper((CHAR8)*FirstString) == AsciiCharToUpper((CHAR8)*SecondString)) &&
                (Length > 1)) {
                FirstString++;
                SecondString++;
                Length--;
        }
        return *FirstString - *SecondString;
}

KLDR_DATA_TABLE_ENTRY* GetModuleEntry(LIST_ENTRY* entry, CHAR16* name)
{
        LIST_ENTRY *list = entry;
        while ((list = list->ForwardLink) != entry) {
                KLDR_DATA_TABLE_ENTRY *module =
                        CONTAINING_RECORD(list, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

                if (module && StrnCmpA(name, module->BaseImageName.Buffer,
                        module->BaseImageName.Length) == 0) {
                        
                        return module;
                }
        }
        return NULL;
}

KLDR_DATA_TABLE_ENTRY* GetModuleEntryAddr(LIST_ENTRY* entry, UINT64 base)
{
        LIST_ENTRY *list = entry;
        while ((list = list->ForwardLink) != entry) {
                KLDR_DATA_TABLE_ENTRY *module =
                        CONTAINING_RECORD(list, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

                
                if (module && (UINT64)module->ImageBase == base) {
                        
                        return module;
                }
        }
        return NULL;
}

KLDR_DATA_TABLE_ENTRY* GetModuleEntry2(LIST_ENTRY* entry, CHAR8* name)
{
        LIST_ENTRY *list = entry;
        while ((list = list->ForwardLink) != entry) {
                KLDR_DATA_TABLE_ENTRY *module =
                        CONTAINING_RECORD(list, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

                if (module && GetExport(module->ImageBase, name))
                {
                        return module;
                }
        }

        return NULL;
}

UINT64 GetExport(UINT8* base, CHAR8* export) {
        IMAGE_DOS_HEADER* dosHeaders = (IMAGE_DOS_HEADER*)base;
        if (dosHeaders->e_magic != IMAGE_DOS_SIGNATURE) {
                return 0;
        }

        IMAGE_NT_HEADERS64* ntHeaders =
                (IMAGE_NT_HEADERS64*)(base + dosHeaders->e_lfanew);

        UINT32 exportsRva =
                ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]
                .VirtualAddress;

        if (!exportsRva) {
                return 0;
        }

        IMAGE_EXPORT_DIRECTORY* exports =
                (IMAGE_EXPORT_DIRECTORY*)(base + exportsRva);

        UINT32* nameRva = (UINT32*)(base + exports->AddressOfNames);

        for (UINT32 i = 0; i < exports->NumberOfNames; ++i) {
                CHAR8* func = (CHAR8*)(base + nameRva[i]);

                if (AsciiStrCmp(func, export) == 0) {
                        UINT32* funcRva = (UINT32*)(base + exports->AddressOfFunctions);
                        UINT16* ordinalRva =
                                (UINT16*)(base + exports->AddressOfNameOrdinals);

                        return (UINT64)base + funcRva[ordinalRva[i]];
                }
        }

        return 0;
}

```

`umap-uefi/util.h`:

```h
#pragma once

#define SEC_TO_MICRO(s) ((s) * 1000000)
#define RELATIVE_ADDR(addr, size) ((VOID *)((UINT8 *)(addr) + *(INT32 *)((UINT8 *)(addr) + ((size) - (INT32)sizeof(INT32))) + (size)))
#define CONTAINING_RECORD(address, type, field) ((type *)((UINT8 *)(address) - (UINTN)(&((type *)0)->field)))

#define JMP_SIZE (14)

#define IMAGE_REL_BASED_ABSOLUTE (0)
#define IMAGE_REL_BASED_DIR64 (10)
#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES (16)
#define IMAGE_SIZEOF_SHORT_NAME (8)
#define IMAGE_DIRECTORY_ENTRY_EXPORT (0)
#define IMAGE_DIRECTORY_ENTRY_IMPORT (1)
#define IMAGE_DIRECTORY_ENTRY_BASERELOC (5)
#define IMAGE_DOS_SIGNATURE (0x5A4D)

#define BL_MEMORY_TYPE_APPLICATION (0xE0000012)
#define BL_MEMORY_ATTRIBUTE_RWX (0x424000)

typedef struct _UNICODE_STRING {
        UINT16 Length;
        UINT16 MaximumLength;
        CHAR16* Buffer;
} UNICODE_STRING;

typedef struct _KLDR_DATA_TABLE_ENTRY {
        LIST_ENTRY InLoadOrderLinks;
        VOID* ExceptionTable;
        UINT32 ExceptionTableSize;
        VOID* GpValue;
        VOID* NonPagedDebugInfo;
        VOID* ImageBase;
        VOID* EntryPoint;
        UINT32 SizeOfImage;
        UNICODE_STRING FullImageName;
        UNICODE_STRING BaseImageName;
} KLDR_DATA_TABLE_ENTRY;

struct _VIRTUAL_EFI_RUNTIME_SERVICES
{
    UINT64 GetTime;                                                      //0x0
    UINT64 SetTime;                                                      //0x8
    UINT64 GetWakeupTime;                                                //0x10
    UINT64 SetWakeupTime;                                                //0x18
    UINT64 SetVirtualAddressMap;                                         //0x20
    UINT64 ConvertPointer;                                               //0x28
    UINT64 GetVariable;                                                  //0x30
    UINT64 GetNextVariableName;                                          //0x38
    UINT64 SetVariable;                                                  //0x40
    UINT64 GetNextHighMonotonicCount;                                    //0x48
    UINT64 ResetSystem;                                                  //0x50
    UINT64 UpdateCapsule;                                                //0x58
    UINT64 QueryCapsuleCapabilities;                                     //0x60
    UINT64 QueryVariableInfo;                                            //0x68
}; 

struct _EFI_FIRMWARE_INFORMATION
{
    UINT32 FirmwareVersion;                                                 //0x0
    struct _VIRTUAL_EFI_RUNTIME_SERVICES* VirtualEfiRuntimeServices;        //0x8
    UINT32 SetVirtualAddressMapStatus;                                      //0x10
    UINT32 MissedMappingsCount;                                             //0x14
    struct _LIST_ENTRY FirmwareResourceList;                                //0x18
    VOID* EfiMemoryMap;                                                     //0x28
    UINT32 EfiMemoryMapSize;                                                 //0x30
    UINT32 EfiMemoryMapDescriptorSize;                                       //0x34
}; 

struct _PCAT_FIRMWARE_INFORMATION
{
    UINT32 PlaceHolder;                                                      //0x0
}; 

struct _FIRMWARE_INFORMATION_LOADER_BLOCK
{
    UINT32 FirmwareTypeUefi:1;                                               //0x0
    UINT32 EfiRuntimeUseIum:1;                                               //0x0
    UINT32 EfiRuntimePageProtectionSupported:1;                              //0x0
    UINT32 Reserved:29;                                                      //0x0
    union
    {
        struct _EFI_FIRMWARE_INFORMATION EfiInformation;                    //0x8
        struct _PCAT_FIRMWARE_INFORMATION PcatInformation;                  //0x8
    } u;                                                                    //0x8
}; 

struct _I386_LOADER_BLOCK
{
    VOID* CommonDataArea;                                                   //0x0
    UINT32 MachineType;                                                      //0x8
    UINT32 VirtualBias;                                                      //0xc
};

struct _ARM_LOADER_BLOCK
{
    UINT32 PlaceHolder;                                                      //0x0
};

typedef struct _LOADER_PARAMETER_BLOCK
{
    UINT32 OsMajorVersion;                                                   //0x0
    UINT32 OsMinorVersion;                                                   //0x4
    UINT32 Size;                                                             //0x8
    UINT32 OsLoaderSecurityVersion;                                          //0xc
    struct _LIST_ENTRY LoadOrderListHead;                                   //0x10
    struct _LIST_ENTRY MemoryDescriptorListHead;                            //0x20
    struct _LIST_ENTRY BootDriverListHead;                                  //0x30
    struct _LIST_ENTRY EarlyLaunchListHead;                                 //0x40
    struct _LIST_ENTRY CoreDriverListHead;                                  //0x50
    struct _LIST_ENTRY CoreExtensionsDriverListHead;                        //0x60
    struct _LIST_ENTRY TpmCoreDriverListHead;                               //0x70
    UINT64 KernelStack;                                                     //0x80
    UINT64 Prcb;                                                            //0x88
    UINT64 Process;                                                         //0x90
    UINT64 Thread;                                                          //0x98
    UINT32 KernelStackSize;                                                 //0xa0
    UINT32 RegistryLength;                                                  //0xa4
    VOID* RegistryBase;                                                     //0xa8
    struct _CONFIGURATION_COMPONENT_DATA* ConfigurationRoot;                //0xb0
    char* ArcBootDeviceName;                                                //0xb8
    char* ArcHalDeviceName;                                                 //0xc0
    char* NtBootPathName;                                                   //0xc8
    char* NtHalPathName;                                                    //0xd0
    char* LoadOptions;                                                      //0xd8
    struct _NLS_DATA_BLOCK* NlsData;                                        //0xe0
    struct _ARC_DISK_INFORMATION* ArcDiskInformation;                       //0xe8
    struct _LOADER_PARAMETER_EXTENSION* Extension;                          //0xf0
    union
    {
        struct _I386_LOADER_BLOCK I386;                                     //0xf8
        struct _ARM_LOADER_BLOCK Arm;                                       //0xf8
    } u;                                                                    //0xf8
    struct _FIRMWARE_INFORMATION_LOADER_BLOCK FirmwareInformation;          //0x108
    char* OsBootstatPathName;                                               //0x148
    char* ArcOSDataDeviceName;                                              //0x150
    char* ArcWindowsSysPartName;                                            //0x158
} LOADER_PARAMETER_BLOCK ; 

typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
        UINT16 e_magic;                     // Magic number
        UINT16 e_cblp;                      // Bytes on last page of file
        UINT16 e_cp;                        // Pages in file
        UINT16 e_crlc;                      // Relocations
        UINT16 e_cparhdr;                   // Size of header in paragraphs
        UINT16 e_minalloc;                  // Minimum extra paragraphs needed
        UINT16 e_maxalloc;                  // Maximum extra paragraphs needed
        UINT16 e_ss;                        // Initial (relative) SS value
        UINT16 e_sp;                        // Initial SP value
        UINT16 e_csum;                      // Checksum
        UINT16 e_ip;                        // Initial IP value
        UINT16 e_cs;                        // Initial (relative) CS value
        UINT16 e_lfarlc;                    // File address of relocation table
        UINT16 e_ovno;                      // Overlay number
        UINT16 e_res[4];                    // Reserved words
        UINT16 e_oemid;                     // OEM identifier (for e_oeminfo)
        UINT16 e_oeminfo;                   // OEM information; e_oemid specific
        UINT16 e_res2[10];                  // Reserved words
        UINT32 e_lfanew;                    // File address of new exe header
} IMAGE_DOS_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY {
        UINT32   VirtualAddress;
        UINT32   Size;
} IMAGE_DATA_DIRECTORY, * PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
        UINT16               Magic;
        UINT8                MajorLinkerVersion;
        UINT8                MinorLinkerVersion;
        UINT32               SizeOfCode;
        UINT32               SizeOfInitializedData;
        UINT32               SizeOfUninitializedData;
        UINT32               AddressOfEntryPoint;
        UINT32               BaseOfCode;
        UINT64               ImageBase;
        UINT32               SectionAlignment;
        UINT32               FileAlignment;
        UINT16               MajorOperatingSystemVersion;
        UINT16               MinorOperatingSystemVersion;
        UINT16               MajorImageVersion;
        UINT16               MinorImageVersion;
        UINT16               MajorSubsystemVersion;
        UINT16               MinorSubsystemVersion;
        UINT32               Win32VersionValue;
        UINT32               SizeOfImage;
        UINT32               SizeOfHeaders;
        UINT32               CheckSum;
        UINT16               Subsystem;
        UINT16               DllCharacteristics;
        UINT64               SizeOfStackReserve;
        UINT64               SizeOfStackCommit;
        UINT64               SizeOfHeapReserve;
        UINT64               SizeOfHeapCommit;
        UINT32               LoaderFlags;
        UINT32               NumberOfRvaAndSizes;
        IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_FILE_HEADER {
        UINT16  Machine;
        UINT16  NumberOfSections;
        UINT32  TimeDateStamp;
        UINT32  PointerToSymbolTable;
        UINT32  NumberOfSymbols;
        UINT16  SizeOfOptionalHeader;
        UINT16  Characteristics;
} IMAGE_FILE_HEADER;

typedef struct _IMAGE_NT_HEADERS64 {
        UINT32 Signature;
        IMAGE_FILE_HEADER FileHeader;
        IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64;

typedef struct _IMAGE_SECTION_HEADER {
        UINT8    Name[IMAGE_SIZEOF_SHORT_NAME];
        union {
                UINT32   PhysicalAddress;
                UINT32   VirtualSize;
        } Misc;
        UINT32   VirtualAddress;
        UINT32   SizeOfRawData;
        UINT32   PointerToRawData;
        UINT32   PointerToRelocations;
        UINT32   PointerToLinenumbers;
        UINT16   NumberOfRelocations;
        UINT16   NumberOfLinenumbers;
        UINT32   Characteristics;
} IMAGE_SECTION_HEADER, * PIMAGE_SECTION_HEADER;

#pragma warning(push)
#pragma warning(disable: 4201)
typedef struct _IMAGE_IMPORT_DESCRIPTOR {
        union {
                UINT32   Characteristics;
                UINT32   OriginalFirstThunk;
        };

        UINT32   TimeDateStamp;
        UINT32   ForwarderChain;
        UINT32   Name;
        UINT32   FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR;
#pragma warning(pop)

typedef struct _IMAGE_THUNK_DATA64 {
        union {
                UINT64 ForwarderString;
                UINT64 Function;
                UINT64 Ordinal;
                UINT64 AddressOfData;
        } u1;
} IMAGE_THUNK_DATA64;

typedef struct _IMAGE_IMPORT_BY_NAME {
        UINT16 Hint;
        CHAR8  Name[1];
} IMAGE_IMPORT_BY_NAME;

typedef struct _IMAGE_EXPORT_DIRECTORY {
        UINT32 Characteristics;
        UINT32 TimeDateStamp;
        UINT16 MajorVersion;
        UINT16 MinorVersion;
        UINT32 Name;
        UINT32 Base;
        UINT32 NumberOfFunctions;
        UINT32 NumberOfNames;
        UINT32 AddressOfFunctions;
        UINT32 AddressOfNames;
        UINT32 AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY;

typedef struct _IMAGE_BASE_RELOCATION {
        UINT32 VirtualAddress;
        UINT32 SizeOfBlock;
} IMAGE_BASE_RELOCATION;

VOID MemCopy(VOID* dest, VOID* src, UINTN size);
VOID* FindPattern(unsigned char* base, UINTN size, unsigned char *pattern, unsigned char* mask);
VOID* TrampolineHook(VOID* dest, VOID* src, UINT8 original[JMP_SIZE]);
VOID TrampolineUnHook(VOID* src, UINT8 original[JMP_SIZE]);
KLDR_DATA_TABLE_ENTRY* GetModuleEntry(LIST_ENTRY* entry, CHAR16* name);
KLDR_DATA_TABLE_ENTRY* GetModuleEntryAddr(LIST_ENTRY* entry, UINT64 base);
KLDR_DATA_TABLE_ENTRY* GetModuleEntry2(LIST_ENTRY* entry, CHAR8* name);
UINT64 GetExport(UINT8* base, CHAR8* export);
```