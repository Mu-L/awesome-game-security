Project Path: arc_ekknod_CSGO-AC_qohavzi7

Source Tree:

```txt
arc_ekknod_CSGO-AC_qohavzi7
├── CS2
│   ├── honeypot
│   │   ├── anti-cheat.sln
│   │   ├── client
│   │   │   ├── client.vcxproj
│   │   │   ├── client.vcxproj.filters
│   │   │   ├── client.vcxproj.user
│   │   │   └── main.cpp
│   │   └── dll
│   │       ├── dll.vcxproj
│   │       ├── dll.vcxproj.filters
│   │       ├── dll.vcxproj.user
│   │       ├── main.cpp
│   │       └── main.h
│   └── mouse_input
│       ├── anti-cheat.sln
│       ├── client
│       │   ├── client.vcxproj
│       │   ├── client.vcxproj.filters
│       │   ├── client.vcxproj.user
│       │   └── main.cpp
│       └── dll
│           ├── dll.vcxproj
│           ├── dll.vcxproj.filters
│           ├── dll.vcxproj.user
│           ├── main.cpp
│           └── main.h
├── CSGO
│   ├── anti-cheat.sln
│   ├── client
│   │   ├── client.vcxproj
│   │   ├── client.vcxproj.filters
│   │   ├── client.vcxproj.user
│   │   └── main.cpp
│   └── dll
│       ├── dll.vcxproj
│       ├── dll.vcxproj.filters
│       ├── dll.vcxproj.user
│       ├── main.cpp
│       └── main.h
└── README.md

```

`CS2/honeypot/anti-cheat.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.7.34031.279
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "client", "client\client.vcxproj", "{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "dll", "dll\dll.vcxproj", "{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Debug|x64.ActiveCfg = Debug|x64
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Debug|x64.Build.0 = Debug|x64
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Debug|x86.ActiveCfg = Debug|Win32
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Debug|x86.Build.0 = Debug|Win32
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Release|x64.ActiveCfg = Release|x64
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Release|x64.Build.0 = Release|x64
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Release|x86.ActiveCfg = Release|Win32
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Release|x86.Build.0 = Release|Win32
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Debug|x64.ActiveCfg = Debug|x64
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Debug|x64.Build.0 = Debug|x64
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Debug|x86.ActiveCfg = Debug|Win32
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Debug|x86.Build.0 = Debug|Win32
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Release|x64.ActiveCfg = Release|x64
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Release|x64.Build.0 = Release|x64
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Release|x86.ActiveCfg = Release|Win32
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {1AB74244-596C-45FF-B87B-C04E93886684}
	EndGlobalSection
EndGlobal

```

`CS2/honeypot/client/client.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{1962b56a-16f7-4b69-bff8-517b06a5be7e}</ProjectGuid>
    <RootNamespace>client</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetName>ec-guard</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetName>ec-guard</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CS2/honeypot/client/client.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`CS2/honeypot/client/client.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerWorkingDirectory>$(OutDir)</LocalDebuggerWorkingDirectory>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LocalDebuggerWorkingDirectory>$(OutDir)</LocalDebuggerWorkingDirectory>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`CS2/honeypot/client/main.cpp`:

```cpp
#include <windows.h>
#include <stdio.h>
#include <TlHelp32.h>
#include <string>
#include <filesystem>

#define DEBUG
#define LOG(...) printf("[ec-guard.exe] " __VA_ARGS__)
#define TARGET_GAME "cs2.exe"
#define TARGET_DLL  "ec-guard.dll"






typedef enum
{
	NotRunning = 0,
	RunningWithoutAC = 1,
	Running = 2
} GameState ;

typedef struct
{
	DWORD       pid;
	std::string path;
} PROCESS_INFO ;

BOOL        load_library(HANDLE process, std::string dll_path);
BOOL        get_process_info(PCSTR process_name, PROCESS_INFO *info);
DWORD       get_process_id(PCSTR process_name);
GameState   get_game_state(PCSTR process_name, PCSTR dll_name);
BOOL        terminate_process(PCSTR process_name);
std::string get_process_cmd(HANDLE process_handle, std::string path);

int main(void)
{
	char buffer[260]{};
	GetCurrentDirectoryA(260, buffer);
	std::string dll_path = buffer + std::string("\\") + std::string(TARGET_DLL);
	if (!std::filesystem::exists(dll_path))
	{
		LOG("Anti-Cheat file is missing: %s\n", dll_path.c_str());
		return 0;
	}

	GameState state = get_game_state(TARGET_GAME, TARGET_DLL);

	if (state == GameState::Running)
	{
		LOG("is already running\n");
		return getchar();
	}

	else if (state == GameState::RunningWithoutAC)
	{
		LOG("please close the game before starting Anti-Cheat\n");
		while (get_process_id(TARGET_GAME))
			Sleep(100);
	}

	LOG("Anti-Cheat is started\n");

	LOG("Waiting for the game...\n");

	PROCESS_INFO info{};

	while (!get_process_info(TARGET_GAME, &info))
	{
		Sleep(100);
	}

	HANDLE process_handle = OpenProcess(PROCESS_ALL_ACCESS, 0, info.pid);
	
	//
	// get command line
	//
	std::string command_line = get_process_cmd(process_handle, info.path) + " -insecure +sv_lan 1";


	while (!TerminateProcess(process_handle, EXIT_SUCCESS))
		break;
	CloseHandle(process_handle);


	PROCESS_INFORMATION pi  = {};
	STARTUPINFOA        si  = {};

	si.cb = sizeof(STARTUPINFO);
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_NORMAL;

	if (!CreateProcessA(
			0,
			(LPSTR)command_line.c_str(),
			0,
			0,
			0,
			CREATE_SUSPENDED,
			0,
			0,
			&si,
			&pi
		))
	{
		LOG("unknown error 404\n");
		return getchar();
	}


	BOOL status = 0;
	if (!load_library(pi.hProcess, dll_path))
	{
		TerminateProcess(pi.hProcess, 0);
	}
	else
	{
		ResumeThread(pi.hThread);
		status = 1;
	}

	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);

	if (status)
		LOG("Anti-Cheat is successfully launched\n");
	else
		LOG("Anti-Cheat failed to launch\n");

	return 0;
}

#pragma comment(lib, "ntdll.lib")

extern "C" __kernel_entry NTSTATUS NtQueryInformationProcess(
	HANDLE           ProcessHandle,
	ULONG            ProcessInformationClass,
	PVOID            ProcessInformation,
	ULONG            ProcessInformationLength,
	PULONG           ReturnLength
);

ULONG_PTR get_peb(HANDLE process)
{
	ULONG_PTR peb[6]{};

	if (NtQueryInformationProcess(process, 0, &peb, 48, 0) != 0)
	{
		return 0;
	}

	return peb[1];
}

ULONG_PTR get_wow64_process(HANDLE process)
{
	ULONG_PTR wow64_process = 0;

	if (process == 0)
		return wow64_process;

	if (NtQueryInformationProcess(process, 26, &wow64_process, 8, 0) != 0)
	{
		return 0;
	}

	return wow64_process;
}

inline void wcs2str(short *buffer, ULONG_PTR length)
{
	for (ULONG_PTR i = 0; i < length; i++)
	{
		((char*)buffer)[i] = (char)buffer[i];
	}
}

std::string get_process_cmd(HANDLE process_handle, std::string path)
{
	ULONG_PTR peb = get_wow64_process(process_handle);

	ULONG_PTR off_0 = 0, off_1 = 0, rsize = 0;

	if (peb == 0)
	{
		off_0 = 0x20;
		off_1 = 0x70;
		rsize = 8;
		peb   = get_peb(process_handle);
	}
	else
	{
		off_0 = 0x10;
		off_1 = 0x40;
		rsize = 4;
	}

	if (peb == 0)
	{
		return path + " -steam -insecure";
	}

	ULONG_PTR a0 = 0;
	ReadProcessMemory(process_handle, (LPCVOID)(peb + off_0), &a0, rsize, 0);

	a0 = a0 + off_1;

	USHORT len = 0;
	ReadProcessMemory(process_handle, (LPCVOID)(a0  + 0x02), &len, sizeof(USHORT), 0);
	ReadProcessMemory(process_handle, (LPCVOID)(a0  + rsize), &a0, rsize, 0);

	char parameters[512]{};
	ReadProcessMemory(process_handle, (LPCVOID)a0, parameters, len, 0);

	wcs2str((short*)parameters, len);

	return std::string(parameters);
}

BOOL load_library(HANDLE process, std::string dll_path)
{
	BOOL status = 0;
	HANDLE thread_handle = 0;



	PVOID dll_name_address = VirtualAllocEx(process, 0, 0x1000, MEM_COMMIT, PAGE_READWRITE);
		
	if (dll_name_address == 0)
		return 0;

	if (!WriteProcessMemory(process, dll_name_address, dll_path.c_str(), dll_path.size(), 0))
	{
		goto E0;
	}

	thread_handle = CreateRemoteThread(process, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, (LPVOID)dll_name_address, 0, NULL);
	if (thread_handle == 0)
	{
		goto E0;
	}

	if (WaitForSingleObject(thread_handle, INFINITE) == WAIT_FAILED)
	{
		goto E2;
	}
	status = 1;
E2:
	CloseHandle(thread_handle);
E0:
	VirtualFreeEx(process, dll_name_address, MAX_PATH, MEM_RELEASE);
	
	return status;
}

DWORD get_process_id(PCSTR process_name)
{
	DWORD pid = 0;
	HANDLE snp = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	PROCESSENTRY32 entry{};
	entry.dwSize = sizeof(PROCESSENTRY32);

	while (Process32Next(snp, &entry))
	{
		CHAR  uc_name[260]{};
		for (int i = 0; i < 260; i++)
		{
			uc_name[i] = (char)entry.szExeFile[i];
		}
		if (!_strcmpi(uc_name, process_name))
		{
			pid = entry.th32ProcessID;
			break;
		}
	}
	CloseHandle(snp);

	return pid;
}

ULONG_PTR get_process_dll(DWORD process_id, PCSTR dll_name)
{
	ULONG_PTR dll = 0;
	HANDLE snp = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, process_id);

	if (snp == 0)
		return 0;

	MODULEENTRY32 entry{};
	entry.dwSize = sizeof(MODULEENTRY32);

	while (Module32Next(snp, &entry))
	{
		CHAR uc_name[256]{};
		for (int i = 0; i < 256; i++)
		{
			uc_name[i] = (char)entry.szModule[i];
		}

		if (!_strcmpi(uc_name, dll_name))
		{
			dll = (ULONG_PTR)entry.hModule;
			break;
		}
	}

	CloseHandle(snp);
	return dll;
}

BOOL get_process_info(PCSTR process_name, PROCESS_INFO *info)
{
	BOOL status = 0;

	DWORD pid = get_process_id(process_name);
	if (pid == 0)
		return 0;

	HANDLE snp = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pid);
	if (snp == 0)
		return 0;

	MODULEENTRY32 entry{};
	entry.dwSize = sizeof(MODULEENTRY32);
	if (Module32First(snp, &entry))
	{
		CHAR uc_name[260]{};
		for (int i = 0; i < 260; i++)
		{
			uc_name[i] = (char)entry.szExePath[i];
		}

		info->pid  = pid;
		info->path = std::string(uc_name);

		status = 1;
	}
	CloseHandle(snp);

	return status;
}

GameState get_game_state(PCSTR process_name, PCSTR dll_name)
{
	DWORD process_id = get_process_id(process_name);
	if (process_id == 0)
		return GameState::NotRunning;

	if (get_process_dll(process_id, dll_name) == 0)
		return GameState::RunningWithoutAC;

	return GameState::Running;
}

BOOL terminate_process(PCSTR process_name)
{
	DWORD process_id      = get_process_id(process_name);
	HANDLE process_handle = OpenProcess(PROCESS_ALL_ACCESS, 0, process_id);

	if (process_handle == 0)
		return 0;

	BOOL status = TerminateProcess(process_handle, EXIT_SUCCESS);

	CloseHandle(process_handle);

	return status;
}


```

`CS2/honeypot/dll/dll.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{d0d9d557-7160-4ccb-87cd-d306e3e7cc57}</ProjectGuid>
    <RootNamespace>dll</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetName>ec-guard</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetName>ec-guard</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;DLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;DLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;DLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;DLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableUAC>false</EnableUAC>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="main.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`CS2/honeypot/dll/dll.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="main.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`CS2/honeypot/dll/dll.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`CS2/honeypot/dll/main.cpp`:

```cpp
#include "main.h"
#include <intrin.h>

QWORD FindPattern(QWORD base, unsigned char* pattern, unsigned char* mask);

namespace globals
{
	QWORD local_player;
}

static void MainThread(void)
{
	LOG("plugin is installed\n");
}

namespace resourcesystem
{
	QWORD get_access_time(unsigned int* junk)
	{
		_mm_lfence();
		QWORD ret = __rdtscp(junk);
		_mm_lfence();
		return ret;
	}


	char *resourcesystem_table_original;
	QWORD resource_system_original;
	QWORD resourcesystem_address;
	char *resource_system;



	#pragma section("PAGE",read,write,nopage)
	__declspec(allocate("PAGE"))
	char entitylist_cached[0x2000]{};

	BOOLEAN trap_set = 0;

	PVOID assemble_func(QWORD original_func)
	{
		unsigned char payload[] =
		{
			0x48, 0xB9, 0x00, 0x00, 0x95, 0xB9, 0xF7, 0x7F, 0x00, 0x00, 0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		};

		// movabs rcx, clone_vtable   ; we redirect vtable .data to somewhere else
		// jmp    QWORD PTR [rip+0x0] ; jmp to original vtable_func

		*(QWORD*)(payload + 0x02)        = (QWORD)resourcesystem_table_original;
		*(QWORD*)(payload + 0x0A + 0x06) = original_func;

		PVOID mem = VirtualAlloc(0, sizeof(payload), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		memcpy(mem, payload, sizeof(payload));
		return mem;
	}

	void __fastcall initialize_entitylist(QWORD rcx, QWORD rdx)
	{
		// entitylist_cached = (QWORD)VirtualAlloc(0, 0x2000, MEM_COMMIT, PAGE_READWRITE);  //(QWORD)malloc(0x1570);
		memcpy((void*)entitylist_cached, (const void*)rdx, 0x1570);
		*(QWORD*)(resourcesystem_table_original + 0x58) = rdx;
		*(QWORD*)(rcx + 0x58) = (QWORD)entitylist_cached;
		trap_set = 1;

		//
		// unhook
		//
		*(QWORD*)(resource_system + 0x110) = (QWORD)assemble_func(*(QWORD*)(resource_system_original + 0x110));
	}

	BOOL update_entitylist(void)
	{
		static UINT64 earlier_ms = 0;


		UINT64 ms = std::chrono::duration_cast<std::chrono::milliseconds>(
			std::chrono::system_clock::now().time_since_epoch()
		).count();


		if (ms - earlier_ms > 5000)
		{
			//
			// updating entitylist
			//
			memcpy((void*)entitylist_cached, (const void*)*(QWORD*)(resourcesystem_table_original + 0x58), 0x1570);
			earlier_ms = ms;

			_mm_clflush((const void *)(entitylist_cached + 0x10));

			return 1;
		}

		return 0;
	}

	BOOL is_alive(void)
	{
		if (!globals::local_player)
			return 0;

		QWORD controller = *(QWORD*)(globals::local_player);
		if (!controller)
			return 0;

		return *(BYTE*)(controller + 0x7F4) == 1;
	}

	void trap_thread(void)
	{
		BOOL  task  = 0;
		unsigned int junk  = 0;

		int   access_counter=0;


		while (1)
		{
			if (!trap_set)
			{
				Sleep(1);
				continue;
			}

			if (update_entitylist())
			{
				if (is_alive())
				{
					LOG("past 5 seconds, total of %ld memory accesses\n", access_counter);
				}
				access_counter = 0;
				continue;
			}

			_mm_clflush((const void *)(entitylist_cached + 0x10));

			Sleep(1);

			QWORD t1 = get_access_time(&junk);
			volatile DWORD not_used = *(DWORD*)(entitylist_cached + 0x10);
			QWORD t2 = get_access_time(&junk) - t1;

			if (t2 < 315)
			{
				access_counter++;
			}
		}
	}

	void initialize(QWORD engine2)
	{
		resource_system = (char *)malloc(0x168);


		resourcesystem_address =
			FindPattern(engine2,
				(PBYTE)"\x48\x89\x43\x40\x48\x8B\x05\x00\x00\x00\x00",
				(PBYTE)"xxxxxxx????"
				);

		if (!resourcesystem_address)
		{
			ExitProcess(0);
			return;
		}

		resourcesystem_address = resourcesystem_address + 0x04;
		resourcesystem_address = (resourcesystem_address + 7) + *(int*)(resourcesystem_address + 3);


		resource_system_original = *(QWORD*)resourcesystem_address;

		memcpy(resource_system, (const void *)resource_system_original, 0x168);

		//
		// hook pointer set
		//
		*(QWORD*)resourcesystem_address = (QWORD)resource_system;

		resourcesystem_table_original = (char *)malloc(0x60);
		memcpy(resourcesystem_table_original, (void*)resourcesystem_address, 0x60);
		
		for (QWORD i = 0; i < 0x160; i+= 8)
		{
			*(QWORD*)(resource_system + i) = (QWORD)assemble_func(*(QWORD*)(resource_system_original + i));
		}

		*(QWORD*)(resource_system + 0x110) = (QWORD)initialize_entitylist;


		CreateThread(0, 0, (LPTHREAD_START_ROUTINE)trap_thread, 0, 0, 0);

		LOG("memory monitor is ready\n");
		
		LOG("anti-cheat is running\n");
	}
}

VOID CALLBACK DllCallback(
  _In_      ULONG NotificationReason,
  _In_      PCLDR_DLL_NOTIFICATION_DATA NotificationData,
  _In_opt_  PVOID Context
)
{
	UNREFERENCED_PARAMETER(Context);
	if (NotificationReason == LDR_DLL_NOTIFICATION_REASON_LOADED)
	{
		if (!wcscmp(NotificationData->Loaded.BaseDllName->Buffer, L"client.dll"))
		{
			globals::local_player =
				FindPattern((QWORD)NotificationData->Loaded.DllBase,
					(PBYTE)"\x48\x83\x3D\x00\x00\x00\x00\x00\x0F\x95\xC0\xC3", (PBYTE)"xxx????xxxxx");

			if (globals::local_player)
				globals::local_player = (globals::local_player + 8) + *(int*)(globals::local_player + 3);
		}

		if (!wcscmp(NotificationData->Loaded.BaseDllName->Buffer, L"engine2.dll"))
		{
			resourcesystem::initialize((QWORD)NotificationData->Loaded.DllBase);

			/*
			LOG("Press F10 key to continue . . .\n");
			while (!GetAsyncKeyState(VK_F10))
			{
				Sleep(1);
			}
			*/
		}
	}
	else if (NotificationReason == LDR_DLL_NOTIFICATION_REASON_UNLOADED)
	{
	}
}

BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, LPVOID Reserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		AllocConsole();
		freopen("CONOUT$", "w", stdout);
		CloseHandle(CreateThread(0, 0, (LPTHREAD_START_ROUTINE)MainThread, 0, 0, 0));
		NTSTATUS (NTAPI *LdrRegisterDllNotification)(
		  _In_     ULONG                          Flags,
		  _In_     PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,
		  _In_opt_ PVOID                          Context,
		  _Out_    PVOID                          *Cookie
		);
		VOID *dll_callback_handle = 0;
		*(void**)&LdrRegisterDllNotification = (void*)GetProcAddress(LoadLibraryA("ntdll.dll"), "LdrRegisterDllNotification");
		LdrRegisterDllNotification(0, DllCallback, 0, &dll_callback_handle);
	}
	return 1;
}

static int CheckMask(unsigned char* base, unsigned char* pattern, unsigned char* mask)
{
	for (; *mask; ++base, ++pattern, ++mask)
		if (*mask == 'x' && *base != *pattern)
			return 0;
	return 1;
}

void *FindPatternEx(unsigned char* base, QWORD size, unsigned char* pattern, unsigned char* mask)
{
	size -= strlen((const char *)mask);
	for (QWORD i = 0; i <= size; ++i) {
		void* addr = &base[i];
		if (CheckMask((unsigned char *)addr, pattern, mask))
			return addr;
	}
	return 0;
}

QWORD FindPattern(QWORD base, unsigned char* pattern, unsigned char* mask)
{
	if (base == 0)
	{
		return 0;
	}

	QWORD nt_header = (QWORD)*(DWORD*)(base + 0x03C) + base;
	if (nt_header == base)
	{
		return 0;
	}

	WORD machine = *(WORD*)(nt_header + 0x4);
	QWORD section_header = machine == 0x8664 ?
		nt_header + 0x0108 :
		nt_header + 0x00F8;

	for (WORD i = 0; i < *(WORD*)(nt_header + 0x06); i++) {
		QWORD section = section_header + ((QWORD)i * 40);

		DWORD section_characteristics = *(DWORD*)(section + 0x24);

		if (section_characteristics & 0x00000020 && !(section_characteristics & 0x02000000))
		{
			QWORD virtual_address = base + (QWORD)*(DWORD*)(section + 0x0C);
			DWORD virtual_size = *(DWORD*)(section + 0x08);

			void *found_pattern = FindPatternEx( (unsigned char*)virtual_address, virtual_size, pattern, mask);
			if (found_pattern)
			{
				return (QWORD)found_pattern;
			}
		}
	}
	return 0;
}


```

`CS2/honeypot/dll/main.h`:

```h
#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <stdio.h>
#include <Ntsecapi.h>
#include <vector>
#include <chrono>

typedef const UNICODE_STRING * PCUNICODE_STRING;
typedef struct _LDR_DLL_LOADED_NOTIFICATION_DATA {
    ULONG Flags;                    //Reserved.
    PCUNICODE_STRING FullDllName;   //The full path name of the DLL module.
    PCUNICODE_STRING BaseDllName;   //The base file name of the DLL module.
    PVOID DllBase;                  //A pointer to the base address for the DLL in memory.
    ULONG SizeOfImage;              //The size of the DLL image, in bytes.
} LDR_DLL_LOADED_NOTIFICATION_DATA, *PLDR_DLL_LOADED_NOTIFICATION_DATA;

typedef union _LDR_DLL_NOTIFICATION_DATA {
    LDR_DLL_LOADED_NOTIFICATION_DATA Loaded;
    LDR_DLL_LOADED_NOTIFICATION_DATA Unloaded;
} LDR_DLL_NOTIFICATION_DATA, *PLDR_DLL_NOTIFICATION_DATA;

typedef const _LDR_DLL_NOTIFICATION_DATA * PCLDR_DLL_NOTIFICATION_DATA;

typedef VOID (CALLBACK * PLDR_DLL_NOTIFICATION_FUNCTION)(
  _In_      ULONG NotificationReason,
  _In_      PCLDR_DLL_NOTIFICATION_DATA NotificationData,
  _In_opt_  PVOID Context
);

typedef struct {
	HANDLE handle;
	UINT64 total_calls;
	UINT64 timestamp;
} DEVICE_INFO ;

#define LDR_DLL_NOTIFICATION_REASON_LOADED 1
#define LDR_DLL_NOTIFICATION_REASON_UNLOADED 2


inline void FontColor(int color=0x07) { SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color); }


#define DEBUG

#define LOG(...) \
FontColor(3); \
printf("[ec-guard.dll] "); \
FontColor(7); \
printf(__VA_ARGS__); \


typedef ULONG_PTR QWORD;


```

`CS2/mouse_input/anti-cheat.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.7.34031.279
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "client", "client\client.vcxproj", "{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "dll", "dll\dll.vcxproj", "{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Debug|x64.ActiveCfg = Debug|x64
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Debug|x64.Build.0 = Debug|x64
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Debug|x86.ActiveCfg = Debug|Win32
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Debug|x86.Build.0 = Debug|Win32
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Release|x64.ActiveCfg = Release|x64
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Release|x64.Build.0 = Release|x64
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Release|x86.ActiveCfg = Release|Win32
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Release|x86.Build.0 = Release|Win32
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Debug|x64.ActiveCfg = Debug|x64
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Debug|x64.Build.0 = Debug|x64
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Debug|x86.ActiveCfg = Debug|Win32
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Debug|x86.Build.0 = Debug|Win32
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Release|x64.ActiveCfg = Release|x64
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Release|x64.Build.0 = Release|x64
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Release|x86.ActiveCfg = Release|Win32
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {1AB74244-596C-45FF-B87B-C04E93886684}
	EndGlobalSection
EndGlobal

```

`CS2/mouse_input/client/client.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{1962b56a-16f7-4b69-bff8-517b06a5be7e}</ProjectGuid>
    <RootNamespace>client</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetName>ec-guard</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetName>ec-guard</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CS2/mouse_input/client/client.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`CS2/mouse_input/client/client.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerWorkingDirectory>$(OutDir)</LocalDebuggerWorkingDirectory>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LocalDebuggerWorkingDirectory>$(OutDir)</LocalDebuggerWorkingDirectory>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`CS2/mouse_input/client/main.cpp`:

```cpp
#include <windows.h>
#include <stdio.h>
#include <TlHelp32.h>
#include <string>
#include <filesystem>

#define DEBUG
#define LOG(...) printf("[ec-guard.exe] " __VA_ARGS__)
#define TARGET_GAME "cs2.exe"
#define TARGET_DLL  "ec-guard.dll"






typedef enum
{
	NotRunning = 0,
	RunningWithoutAC = 1,
	Running = 2
} GameState ;

typedef struct
{
	DWORD       pid;
	std::string path;
} PROCESS_INFO ;

BOOL        load_library(HANDLE process, std::string dll_path);
BOOL        get_process_info(PCSTR process_name, PROCESS_INFO *info);
DWORD       get_process_id(PCSTR process_name);
GameState   get_game_state(PCSTR process_name, PCSTR dll_name);
BOOL        terminate_process(PCSTR process_name);
std::string get_process_cmd(HANDLE process_handle, std::string path);

int main(void)
{
	char buffer[260]{};
	GetCurrentDirectoryA(260, buffer);
	std::string dll_path = buffer + std::string("\\") + std::string(TARGET_DLL);
	if (!std::filesystem::exists(dll_path))
	{
		LOG("Anti-Cheat file is missing: %s\n", dll_path.c_str());
		return 0;
	}

	GameState state = get_game_state(TARGET_GAME, TARGET_DLL);

	if (state == GameState::Running)
	{
		LOG("is already running\n");
		return getchar();
	}

	else if (state == GameState::RunningWithoutAC)
	{
		LOG("please close the game before starting Anti-Cheat\n");
		while (get_process_id(TARGET_GAME))
			Sleep(100);
	}

	LOG("Anti-Cheat is started\n");

	LOG("Waiting for the game...\n");

	PROCESS_INFO info{};

	while (!get_process_info(TARGET_GAME, &info))
	{
		Sleep(100);
	}

	HANDLE process_handle = OpenProcess(PROCESS_ALL_ACCESS, 0, info.pid);
	
	//
	// get command line
	//
	std::string command_line = get_process_cmd(process_handle, info.path) + " -insecure +sv_lan 1";


	while (!TerminateProcess(process_handle, EXIT_SUCCESS))
		break;
	CloseHandle(process_handle);


	PROCESS_INFORMATION pi  = {};
	STARTUPINFOA        si  = {};

	si.cb = sizeof(STARTUPINFO);
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_NORMAL;

	if (!CreateProcessA(
			0,
			(LPSTR)command_line.c_str(),
			0,
			0,
			0,
			CREATE_SUSPENDED,
			0,
			0,
			&si,
			&pi
		))
	{
		LOG("unknown error 404\n");
		return getchar();
	}


	BOOL status = 0;
	if (!load_library(pi.hProcess, dll_path))
	{
		TerminateProcess(pi.hProcess, 0);
	}
	else
	{
		ResumeThread(pi.hThread);
		status = 1;
	}

	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);

	if (status)
		LOG("Anti-Cheat is successfully launched\n");
	else
		LOG("Anti-Cheat failed to launch\n");

	return 0;
}

#pragma comment(lib, "ntdll.lib")

extern "C" __kernel_entry NTSTATUS NtQueryInformationProcess(
	HANDLE           ProcessHandle,
	ULONG            ProcessInformationClass,
	PVOID            ProcessInformation,
	ULONG            ProcessInformationLength,
	PULONG           ReturnLength
);

ULONG_PTR get_peb(HANDLE process)
{
	ULONG_PTR peb[6]{};

	if (NtQueryInformationProcess(process, 0, &peb, 48, 0) != 0)
	{
		return 0;
	}

	return peb[1];
}

ULONG_PTR get_wow64_process(HANDLE process)
{
	ULONG_PTR wow64_process = 0;

	if (process == 0)
		return wow64_process;

	if (NtQueryInformationProcess(process, 26, &wow64_process, 8, 0) != 0)
	{
		return 0;
	}

	return wow64_process;
}

inline void wcs2str(short *buffer, ULONG_PTR length)
{
	for (ULONG_PTR i = 0; i < length; i++)
	{
		((char*)buffer)[i] = (char)buffer[i];
	}
}

std::string get_process_cmd(HANDLE process_handle, std::string path)
{
	ULONG_PTR peb = get_wow64_process(process_handle);

	ULONG_PTR off_0 = 0, off_1 = 0, rsize = 0;

	if (peb == 0)
	{
		off_0 = 0x20;
		off_1 = 0x70;
		rsize = 8;
		peb   = get_peb(process_handle);
	}
	else
	{
		off_0 = 0x10;
		off_1 = 0x40;
		rsize = 4;
	}

	if (peb == 0)
	{
		return path + " -steam -insecure";
	}

	ULONG_PTR a0 = 0;
	ReadProcessMemory(process_handle, (LPCVOID)(peb + off_0), &a0, rsize, 0);

	a0 = a0 + off_1;

	USHORT len = 0;
	ReadProcessMemory(process_handle, (LPCVOID)(a0  + 0x02), &len, sizeof(USHORT), 0);
	ReadProcessMemory(process_handle, (LPCVOID)(a0  + rsize), &a0, rsize, 0);

	char parameters[512]{};
	ReadProcessMemory(process_handle, (LPCVOID)a0, parameters, len, 0);

	wcs2str((short*)parameters, len);

	return std::string(parameters);
}

BOOL load_library(HANDLE process, std::string dll_path)
{
	BOOL status = 0;
	HANDLE thread_handle = 0;



	PVOID dll_name_address = VirtualAllocEx(process, 0, 0x1000, MEM_COMMIT, PAGE_READWRITE);
		
	if (dll_name_address == 0)
		return 0;

	if (!WriteProcessMemory(process, dll_name_address, dll_path.c_str(), dll_path.size(), 0))
	{
		goto E0;
	}

	thread_handle = CreateRemoteThread(process, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, (LPVOID)dll_name_address, 0, NULL);
	if (thread_handle == 0)
	{
		goto E0;
	}

	if (WaitForSingleObject(thread_handle, INFINITE) == WAIT_FAILED)
	{
		goto E2;
	}
	status = 1;
E2:
	CloseHandle(thread_handle);
E0:
	VirtualFreeEx(process, dll_name_address, MAX_PATH, MEM_RELEASE);
	
	return status;
}

DWORD get_process_id(PCSTR process_name)
{
	DWORD pid = 0;
	HANDLE snp = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	PROCESSENTRY32 entry{};
	entry.dwSize = sizeof(PROCESSENTRY32);

	while (Process32Next(snp, &entry))
	{
		CHAR  uc_name[260]{};
		for (int i = 0; i < 260; i++)
		{
			uc_name[i] = (char)entry.szExeFile[i];
		}
		if (!_strcmpi(uc_name, process_name))
		{
			pid = entry.th32ProcessID;
			break;
		}
	}
	CloseHandle(snp);

	return pid;
}

ULONG_PTR get_process_dll(DWORD process_id, PCSTR dll_name)
{
	ULONG_PTR dll = 0;
	HANDLE snp = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, process_id);

	if (snp == 0)
		return 0;

	MODULEENTRY32 entry{};
	entry.dwSize = sizeof(MODULEENTRY32);

	while (Module32Next(snp, &entry))
	{
		CHAR uc_name[256]{};
		for (int i = 0; i < 256; i++)
		{
			uc_name[i] = (char)entry.szModule[i];
		}

		if (!_strcmpi(uc_name, dll_name))
		{
			dll = (ULONG_PTR)entry.hModule;
			break;
		}
	}

	CloseHandle(snp);
	return dll;
}

BOOL get_process_info(PCSTR process_name, PROCESS_INFO *info)
{
	BOOL status = 0;

	DWORD pid = get_process_id(process_name);
	if (pid == 0)
		return 0;

	HANDLE snp = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pid);
	if (snp == 0)
		return 0;

	MODULEENTRY32 entry{};
	entry.dwSize = sizeof(MODULEENTRY32);
	if (Module32First(snp, &entry))
	{
		CHAR uc_name[260]{};
		for (int i = 0; i < 260; i++)
		{
			uc_name[i] = (char)entry.szExePath[i];
		}

		info->pid  = pid;
		info->path = std::string(uc_name);

		status = 1;
	}
	CloseHandle(snp);

	return status;
}

GameState get_game_state(PCSTR process_name, PCSTR dll_name)
{
	DWORD process_id = get_process_id(process_name);
	if (process_id == 0)
		return GameState::NotRunning;

	if (get_process_dll(process_id, dll_name) == 0)
		return GameState::RunningWithoutAC;

	return GameState::Running;
}

BOOL terminate_process(PCSTR process_name)
{
	DWORD process_id      = get_process_id(process_name);
	HANDLE process_handle = OpenProcess(PROCESS_ALL_ACCESS, 0, process_id);

	if (process_handle == 0)
		return 0;

	BOOL status = TerminateProcess(process_handle, EXIT_SUCCESS);

	CloseHandle(process_handle);

	return status;
}


```

`CS2/mouse_input/dll/dll.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{d0d9d557-7160-4ccb-87cd-d306e3e7cc57}</ProjectGuid>
    <RootNamespace>dll</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetName>ec-guard</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetName>ec-guard</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;DLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;DLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;DLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;DLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="main.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
</Project>
```

`CS2/mouse_input/dll/dll.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="main.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`CS2/mouse_input/dll/dll.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`CS2/mouse_input/dll/main.cpp`:

```cpp
#include "main.h"

//
// current components:
// - usermode input inject detection
//
// missing components:
// - validating mouse packets to game camera (this would cause harm for internal cheats)
//

std::vector<DEVICE_INFO> get_input_devices(void);
QWORD FindPattern(QWORD base, unsigned char* pattern, unsigned char* mask);

namespace globals
{
	std::vector<DEVICE_INFO> device_list;
	WNDPROC game_window_proc = 0;
	DWORD invalid_cnt = 0;
}

//
// missing component: validating incoming input to game camera
//
static LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	//
	// detect injected messages
	// https://stackoverflow.com/questions/69193249/how-to-distinguish-mouse-and-touchpad-events-using-getcurrentinputmessagesource
	//
	if ((uMsg >= WM_MOUSEFIRST && uMsg <= WM_MOUSELAST) || (uMsg >= WM_KEYFIRST && uMsg <= WM_KEYLAST) || (uMsg >= WM_TOUCH && uMsg <= WM_POINTERWHEEL))
	{
		INPUT_MESSAGE_SOURCE src;
		if (GetCurrentInputMessageSource(&src))
		{
			if (src.originId == IMO_INJECTED)
			{
				LOG("invalid mouse input detected %d\n", ++globals::invalid_cnt);
				uMsg = WM_NULL;
			}
		}
	}
	return CallWindowProc(globals::game_window_proc, hwnd, uMsg, wParam, lParam );
}

__int64 (__fastcall *oWIN_HandleRawMouseInput)(QWORD timestamp, QWORD param1, HANDLE hDevice, RAWMOUSE *rawmouse);
__int64 __fastcall WIN_HandleRawMouseInput(QWORD timestamp, QWORD param1, HANDLE hDevice, RAWMOUSE *rawmouse)
{
	static DEVICE_INFO new_device{};

	//
	// block all non used devices
	//
	if (globals::device_list.size() > 1)
	{
		DEVICE_INFO primary_dev{};
		UINT64      max_calls = 0;

		for (DEVICE_INFO &dev : globals::device_list)
		{
			if (dev.total_calls > max_calls)
			{
				max_calls   = dev.total_calls;
				primary_dev = dev;
			}
		}

		if (max_calls > 50)
		{
			primary_dev.timestamp = timestamp;
			globals::device_list.clear();
			globals::device_list.push_back(primary_dev);
			LOG("primary input device has been now selected\n");
		}
	}


	//
	// validate incoming rawinput device
	//
	BOOLEAN found = 0;
	for (DEVICE_INFO& dev : globals::device_list)
	{
		if (dev.handle == hDevice)
		{
			found = 1;
			dev.total_calls++;
			/*
			https://github.com/ekknod/acdrv.git this feature can be found from acdrv project
			if (timestamp - dev.timestamp < 500000) // if latency is less than 500000  ns (2000 Hz). tested with 1000hz mice.
			{
				//
				// https://www.unitjuggler.com/convert-frequency-from-Hz-to-ns(p).html?val=1550
				//
				LOG("Device: 0x%llx, timestamp: %lld, delta: [%lld]\n", (QWORD)hDevice, timestamp, timestamp - dev.timestamp);
			}
			*/
			dev.timestamp = timestamp;
			break;
		}
	}

	if (found)
	{
		//
		// did someone send empty mouse packet?
		//
		BOOL empty = 1;
		for (int i = sizeof(RAWMOUSE); i--;)
		{
			if (((BYTE*)rawmouse)[i] != 0)
			{
				empty = 0;
				break;
			}
		}


		if (empty)
		{
			LOG("Device: 0x%llx, timestamp: %lld, empty mouse packet\n", (QWORD)hDevice, timestamp);
		}
	}

	if (found == 0)
	{
		LOG("Device: 0x%llx, timestamp: %lld, multiple inputs\n", (QWORD)hDevice, timestamp);

		memset(rawmouse, 0, sizeof(RAWMOUSE));

		if (new_device.handle == hDevice)
		{
			new_device.total_calls++;
		}
		else
		{
			if (new_device.handle)
			{
				new_device.total_calls = 0;
			}
		}

		//
		// initialize new device if invalid cnt reaches 150
		// - in case player decide to change mouse mid game
		// - this function is going to change the primary device
		//
		if (new_device.total_calls > 150)
		{
			std::vector<DEVICE_INFO> devices = get_input_devices();
			for (DEVICE_INFO &device : devices)
			{
				if (device.handle == hDevice)
				{
					//
					// select new primary device
					//
					device.timestamp = timestamp;
					globals::device_list.clear();
					globals::device_list.push_back(device);
					new_device.total_calls = 0;
					LOG("primary input device has been now selected\n");
				}
			}
		}
		new_device.handle = hDevice;
	}
	else
	{
		new_device.total_calls = 0;
	}
	return oWIN_HandleRawMouseInput(timestamp, param1, hDevice, rawmouse);
}

static void MainThread(void)
{
	HWND window = 0;
	while (1)
	{
		window = FindWindowA("SDL_app", "Counter-Strike 2");

		if (window != 0)
		{
			break;
		}

		Sleep(100);
	}
	globals::device_list = get_input_devices();

	QWORD sdl = 0;
	while (!(sdl = (QWORD)GetModuleHandleA("SDL3.dll"))) Sleep(100);

	// sdl + 0xE5B40;
	QWORD sdl_rawinput = FindPattern(sdl, (PBYTE)"\x48\x89\x4C\x24\x08\x53\x55\x56\x41\x56\x48\x83\xEC\x68\x83\xBA", (PBYTE)"xxxxxxxxxxxxxxxx");
	if (sdl_rawinput == 0)
	{
		LOG("plugin is outdated\n");
		return;
	}

	MH_Initialize();
	MH_CreateHook((LPVOID)sdl_rawinput, &WIN_HandleRawMouseInput, (LPVOID*)&oWIN_HandleRawMouseInput);
	MH_EnableHook((LPVOID)sdl_rawinput);

	globals::game_window_proc = (WNDPROC)SetWindowLongPtrW(window, (-4), (LONG_PTR)WindowProc);

	LOG("plugin is installed\n");
}

VOID CALLBACK DllCallback(
  _In_      ULONG NotificationReason,
  _In_      PCLDR_DLL_NOTIFICATION_DATA NotificationData,
  _In_opt_  PVOID Context
)
{
	UNREFERENCED_PARAMETER(Context);
	if (NotificationReason == LDR_DLL_NOTIFICATION_REASON_LOADED)
	{
		// LOG("%ws\n", NotificationData->Loaded.BaseDllName->Buffer);
	}
	else if (NotificationReason == LDR_DLL_NOTIFICATION_REASON_UNLOADED)
	{
	}
}

BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, LPVOID Reserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		AllocConsole();
		freopen("CONOUT$", "w", stdout);
		CloseHandle(CreateThread(0, 0, (LPTHREAD_START_ROUTINE)MainThread, 0, 0, 0));
		NTSTATUS (NTAPI *LdrRegisterDllNotification)(
		  _In_     ULONG                          Flags,
		  _In_     PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,
		  _In_opt_ PVOID                          Context,
		  _Out_    PVOID                          *Cookie
		);
		VOID *dll_callback_handle = 0;
		*(void**)&LdrRegisterDllNotification = (void*)GetProcAddress(LoadLibraryA("ntdll.dll"), "LdrRegisterDllNotification");
		LdrRegisterDllNotification(0, DllCallback, 0, &dll_callback_handle);

	}
	return 1;
}

std::vector<DEVICE_INFO> get_input_devices(void)
{
	std::vector<DEVICE_INFO> devices;


	//
	// get number of devices
	//
	UINT device_count = 0;
	GetRawInputDeviceList(0, &device_count, sizeof(RAWINPUTDEVICELIST));


	//
	// allocate space for device list
	//
	RAWINPUTDEVICELIST *device_list = (RAWINPUTDEVICELIST *)malloc(sizeof(RAWINPUTDEVICELIST) * device_count);


	//
	// get list of input devices
	//
	GetRawInputDeviceList(device_list, &device_count, sizeof(RAWINPUTDEVICELIST));


	for (UINT i = 0; i < device_count; i++)
	{
		//
		// skip non mouse devices ; we can adjust this in future
		//
		if (device_list[i].dwType != RIM_TYPEMOUSE)
		{
			continue;
		}


		//
		// add new device to our dynamic list
		//
		DEVICE_INFO info{};
		info.handle = device_list[i].hDevice;
		devices.push_back(info);
	}


	//
	// touchpad / mouse_event
	//
	DEVICE_INFO touchpad{};
	touchpad.handle = 0;
	devices.push_back(touchpad);


	//
	// free resources
	//
	free(device_list);


	return devices;
}

static int CheckMask(unsigned char* base, unsigned char* pattern, unsigned char* mask)
{
	for (; *mask; ++base, ++pattern, ++mask)
		if (*mask == 'x' && *base != *pattern)
			return 0;
	return 1;
}

void *FindPatternEx(unsigned char* base, QWORD size, unsigned char* pattern, unsigned char* mask)
{
	size -= strlen((const char *)mask);
	for (QWORD i = 0; i <= size; ++i) {
		void* addr = &base[i];
		if (CheckMask((unsigned char *)addr, pattern, mask))
			return addr;
	}
	return 0;
}

QWORD FindPattern(QWORD base, unsigned char* pattern, unsigned char* mask)
{
	if (base == 0)
	{
		return 0;
	}

	QWORD nt_header = (QWORD)*(DWORD*)(base + 0x03C) + base;
	if (nt_header == base)
	{
		return 0;
	}

	WORD machine = *(WORD*)(nt_header + 0x4);
	QWORD section_header = machine == 0x8664 ?
		nt_header + 0x0108 :
		nt_header + 0x00F8;

	for (WORD i = 0; i < *(WORD*)(nt_header + 0x06); i++) {
		QWORD section = section_header + ((QWORD)i * 40);

		DWORD section_characteristics = *(DWORD*)(section + 0x24);

		if (section_characteristics & 0x00000020 && !(section_characteristics & 0x02000000))
		{
			QWORD virtual_address = base + (QWORD)*(DWORD*)(section + 0x0C);
			DWORD virtual_size = *(DWORD*)(section + 0x08);

			void *found_pattern = FindPatternEx( (unsigned char*)virtual_address, virtual_size, pattern, mask);
			if (found_pattern)
			{
				return (QWORD)found_pattern;
			}
		}
	}
	return 0;
}


```

`CS2/mouse_input/dll/main.h`:

```h
#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <stdio.h>
#include <Ntsecapi.h>
#include <vector>
#include <chrono>
#include <MinHook.h>

typedef const UNICODE_STRING * PCUNICODE_STRING;
typedef struct _LDR_DLL_LOADED_NOTIFICATION_DATA {
    ULONG Flags;                    //Reserved.
    PCUNICODE_STRING FullDllName;   //The full path name of the DLL module.
    PCUNICODE_STRING BaseDllName;   //The base file name of the DLL module.
    PVOID DllBase;                  //A pointer to the base address for the DLL in memory.
    ULONG SizeOfImage;              //The size of the DLL image, in bytes.
} LDR_DLL_LOADED_NOTIFICATION_DATA, *PLDR_DLL_LOADED_NOTIFICATION_DATA;

typedef union _LDR_DLL_NOTIFICATION_DATA {
    LDR_DLL_LOADED_NOTIFICATION_DATA Loaded;
    LDR_DLL_LOADED_NOTIFICATION_DATA Unloaded;
} LDR_DLL_NOTIFICATION_DATA, *PLDR_DLL_NOTIFICATION_DATA;

typedef const _LDR_DLL_NOTIFICATION_DATA * PCLDR_DLL_NOTIFICATION_DATA;

typedef VOID (CALLBACK * PLDR_DLL_NOTIFICATION_FUNCTION)(
  _In_      ULONG NotificationReason,
  _In_      PCLDR_DLL_NOTIFICATION_DATA NotificationData,
  _In_opt_  PVOID Context
);

typedef struct {
	HANDLE handle;
	UINT64 total_calls;
	UINT64 timestamp;
} DEVICE_INFO ;

#define LDR_DLL_NOTIFICATION_REASON_LOADED 1
#define LDR_DLL_NOTIFICATION_REASON_UNLOADED 2


inline void FontColor(int color=0x07) { SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color); }


#define DEBUG

#define LOG(...) \
FontColor(3); \
printf("[ec-guard.dll] "); \
FontColor(7); \
printf(__VA_ARGS__); \


typedef ULONG_PTR QWORD;


```

`CSGO/anti-cheat.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.7.34031.279
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "client", "client\client.vcxproj", "{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "dll", "dll\dll.vcxproj", "{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Debug|x64.ActiveCfg = Debug|x64
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Debug|x64.Build.0 = Debug|x64
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Debug|x86.ActiveCfg = Debug|Win32
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Debug|x86.Build.0 = Debug|Win32
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Release|x64.ActiveCfg = Release|x64
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Release|x64.Build.0 = Release|x64
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Release|x86.ActiveCfg = Release|Win32
		{1962B56A-16F7-4B69-BFF8-517B06A5BE7E}.Release|x86.Build.0 = Release|Win32
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Debug|x64.ActiveCfg = Debug|x64
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Debug|x64.Build.0 = Debug|x64
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Debug|x86.ActiveCfg = Debug|Win32
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Debug|x86.Build.0 = Debug|Win32
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Release|x64.ActiveCfg = Release|x64
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Release|x64.Build.0 = Release|x64
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Release|x86.ActiveCfg = Release|Win32
		{D0D9D557-7160-4CCB-87CD-D306E3E7CC57}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {1AB74244-596C-45FF-B87B-C04E93886684}
	EndGlobalSection
EndGlobal

```

`CSGO/client/client.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{1962b56a-16f7-4b69-bff8-517b06a5be7e}</ProjectGuid>
    <RootNamespace>client</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetName>ec-guard</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetName>ec-guard</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CSGO/client/client.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`CSGO/client/client.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerWorkingDirectory>$(OutDir)</LocalDebuggerWorkingDirectory>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LocalDebuggerWorkingDirectory>$(OutDir)</LocalDebuggerWorkingDirectory>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LocalDebuggerWorkingDirectory>$(OutDir)</LocalDebuggerWorkingDirectory>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LocalDebuggerWorkingDirectory>$(OutDir)</LocalDebuggerWorkingDirectory>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`CSGO/client/main.cpp`:

```cpp
#include <windows.h>
#include <stdio.h>
#include <TlHelp32.h>
#include <string>
#include <filesystem>

#define DEBUG
#define LOG(...) printf("[ec-guard.exe] " __VA_ARGS__)
#define TARGET_GAME "csgo.exe"
#define TARGET_DLL  "ec-guard.dll"






typedef enum
{
	NotRunning = 0,
	RunningWithoutAC = 1,
	Running = 2
} GameState ;

typedef struct
{
	DWORD       pid;
	std::string path;
} PROCESS_INFO ;

BOOL        load_library(HANDLE process, std::string dll_path);
BOOL        get_process_info(PCSTR process_name, PROCESS_INFO *info);
DWORD       get_process_id(PCSTR process_name);
GameState   get_game_state(PCSTR process_name, PCSTR dll_name);
BOOL        terminate_process(PCSTR process_name);
std::string get_process_cmd(HANDLE process_handle, std::string path);

int main(void)
{
	char buffer[260]{};
	GetCurrentDirectoryA(260, buffer);
	std::string dll_path = buffer + std::string("\\") + std::string(TARGET_DLL);
	if (!std::filesystem::exists(dll_path))
	{
		LOG("Anti-Cheat file is missing: %s\n", dll_path.c_str());
		return 0;
	}

	GameState state = get_game_state(TARGET_GAME, TARGET_DLL);

	if (state == GameState::Running)
	{
		LOG("is already running\n");
		return getchar();
	}

	else if (state == GameState::RunningWithoutAC)
	{
		LOG("please close the game before starting Anti-Cheat\n");
		while (get_process_id(TARGET_GAME))
			Sleep(100);
	}

	LOG("Anti-Cheat is started\n");

	LOG("Waiting for the game...\n");

	PROCESS_INFO info{};

	while (!get_process_info(TARGET_GAME, &info))
	{
		Sleep(100);
	}

	HANDLE process_handle = OpenProcess(PROCESS_ALL_ACCESS, 0, info.pid);
	
	//
	// get command line
	//
	std::string command_line = get_process_cmd(process_handle, info.path);


	while (!TerminateProcess(process_handle, EXIT_SUCCESS))
		break;
	CloseHandle(process_handle);


	PROCESS_INFORMATION pi  = {};
	STARTUPINFOA        si  = {};

	si.cb = sizeof(STARTUPINFO);
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_NORMAL;

	if (!CreateProcessA(
			0,
			(LPSTR)command_line.c_str(),
			0,
			0,
			0,
			CREATE_SUSPENDED,
			0,
			0,
			&si,
			&pi
		))
	{
		LOG("unknown error 404\n");
		return getchar();
	}


	BOOL status = 0;
	if (!load_library(pi.hProcess, dll_path))
	{
		TerminateProcess(pi.hProcess, 0);
	}
	else
	{
		ResumeThread(pi.hThread);
		status = 1;
	}

	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);

	if (status)
		LOG("Anti-Cheat is successfully launched\n");
	else
		LOG("Anti-Cheat failed to launch\n");

	return 0;
}

#pragma comment(lib, "ntdll.lib")

NTSTATUS (__stdcall *NtQueryInformationProcess)(
	HANDLE           ProcessHandle,
	ULONG            ProcessInformationClass,
	PVOID            ProcessInformation,
	ULONG            ProcessInformationLength,
	PULONG           ReturnLength
);

ULONG_PTR get_peb(HANDLE process)
{
	ULONG_PTR peb[6]{};

	if ( NtQueryInformationProcess == 0 )
		*(FARPROC*)&NtQueryInformationProcess =
		GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQueryInformationProcess");

	return NtQueryInformationProcess(process, 0, &peb, 48, 0) == 0 ? peb[1] : 0;
}

ULONG_PTR get_wow64_process(HANDLE process)
{
	ULONG_PTR wow64_process = 0;

	if (process == 0)
		return wow64_process;

	if ( NtQueryInformationProcess == 0 )
		*(FARPROC*)&NtQueryInformationProcess =
		GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQueryInformationProcess");

	return NtQueryInformationProcess(process, 26, &wow64_process, sizeof(wow64_process), 0) == 0 ? wow64_process : 0;
}

inline void wcs2str(short *buffer, ULONG_PTR length)
{
	for (ULONG_PTR i = 0; i < length; i++)
	{
		((char*)buffer)[i] = (char)buffer[i];
	}
}

std::string get_process_cmd(HANDLE process_handle, std::string path)
{
	ULONG_PTR peb = get_wow64_process(process_handle);

	ULONG_PTR off_0 = 0, off_1 = 0, rsize = 0;

	if (peb == 0)
	{
		off_0 = 0x20;
		off_1 = 0x70;
		rsize = 8;
		peb   = get_peb(process_handle);
	}
	else
	{
		off_0 = 0x10;
		off_1 = 0x40;
		rsize = 4;
	}

	if (peb == 0)
	{
		return path + " -steam -insecure";
	}

	ULONG_PTR a0 = 0;
	ReadProcessMemory(process_handle, (LPCVOID)(peb + off_0), &a0, rsize, 0);

	a0 = a0 + off_1;

	USHORT len = 0;
	ReadProcessMemory(process_handle, (LPCVOID)(a0  + 0x02), &len, sizeof(USHORT), 0);
	ReadProcessMemory(process_handle, (LPCVOID)(a0  + rsize), &a0, rsize, 0);

	char parameters[512]{};
	ReadProcessMemory(process_handle, (LPCVOID)a0, parameters, len, 0);

	wcs2str((short*)parameters, len);

	return std::string(parameters);
}

BOOL load_library(HANDLE process, std::string dll_path)
{
	BOOL status = 0;
	HANDLE thread_handle = 0;



	PVOID dll_name_address = VirtualAllocEx(process, 0, 0x1000, MEM_COMMIT, PAGE_READWRITE);
		
	if (dll_name_address == 0)
		return 0;

	if (!WriteProcessMemory(process, dll_name_address, dll_path.c_str(), dll_path.size(), 0))
	{
		goto E0;
	}

	thread_handle = CreateRemoteThread(process, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, (LPVOID)dll_name_address, 0, NULL);
	if (thread_handle == 0)
	{
		goto E0;
	}

	if (WaitForSingleObject(thread_handle, INFINITE) == WAIT_FAILED)
	{
		goto E2;
	}
	status = 1;
E2:
	CloseHandle(thread_handle);
E0:
	VirtualFreeEx(process, dll_name_address, MAX_PATH, MEM_RELEASE);
	
	return status;
}

DWORD get_process_id(PCSTR process_name)
{
	DWORD pid = 0;
	HANDLE snp = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	PROCESSENTRY32 entry{};
	entry.dwSize = sizeof(PROCESSENTRY32);

	while (Process32Next(snp, &entry))
	{
		CHAR  uc_name[260]{};
		for (int i = 0; i < 260; i++)
		{
			uc_name[i] = (char)entry.szExeFile[i];
		}
		if (!_strcmpi(uc_name, process_name))
		{
			pid = entry.th32ProcessID;
			break;
		}
	}
	CloseHandle(snp);

	return pid;
}

ULONG_PTR get_process_dll(DWORD process_id, PCSTR dll_name)
{
	ULONG_PTR dll = 0;
	HANDLE snp = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, process_id);

	if (snp == 0)
		return 0;

	MODULEENTRY32 entry{};
	entry.dwSize = sizeof(MODULEENTRY32);

	while (Module32Next(snp, &entry))
	{
		CHAR uc_name[256]{};
		for (int i = 0; i < 256; i++)
		{
			uc_name[i] = (char)entry.szModule[i];
		}

		if (!_strcmpi(uc_name, dll_name))
		{
			dll = (ULONG_PTR)entry.hModule;
			break;
		}
	}

	CloseHandle(snp);
	return dll;
}

BOOL get_process_info(PCSTR process_name, PROCESS_INFO *info)
{
	BOOL status = 0;

	DWORD pid = get_process_id(process_name);
	if (pid == 0)
		return 0;

	HANDLE snp = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pid);
	if (snp == 0)
		return 0;

	MODULEENTRY32 entry{};
	entry.dwSize = sizeof(MODULEENTRY32);
	if (Module32First(snp, &entry))
	{
		CHAR uc_name[260]{};
		for (int i = 0; i < 260; i++)
		{
			uc_name[i] = (char)entry.szExePath[i];
		}

		info->pid  = pid;
		info->path = std::string(uc_name);

		status = 1;
	}
	CloseHandle(snp);

	return status;
}

GameState get_game_state(PCSTR process_name, PCSTR dll_name)
{
	DWORD process_id = get_process_id(process_name);
	if (process_id == 0)
		return GameState::NotRunning;

	if (get_process_dll(process_id, dll_name) == 0)
		return GameState::RunningWithoutAC;

	return GameState::Running;
}

BOOL terminate_process(PCSTR process_name)
{
	DWORD process_id      = get_process_id(process_name);
	HANDLE process_handle = OpenProcess(PROCESS_ALL_ACCESS, 0, process_id);

	if (process_handle == 0)
		return 0;

	BOOL status = TerminateProcess(process_handle, EXIT_SUCCESS);

	CloseHandle(process_handle);

	return status;
}


```

`CSGO/dll/dll.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{d0d9d557-7160-4ccb-87cd-d306e3e7cc57}</ProjectGuid>
    <RootNamespace>dll</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetName>ec-guard</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetName>ec-guard</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <TargetName>ec-guard</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <TargetName>ec-guard</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;DLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;DLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;DLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;DLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="main.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
</Project>
```

`CSGO/dll/dll.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="main.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`CSGO/dll/dll.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`CSGO/dll/main.cpp`:

```cpp
#include "main.h"

//
// current components:
// - usermode input inject detection
//
// missing components:
// - validating mouse packets to game camera (this would cause harm for internal cheats)
// - .data encryption/decryption (block external/DMA cheats)
//

std::vector<DEVICE_INFO> get_input_devices(void);

namespace globals
{
	std::vector<DEVICE_INFO> device_list;
	WNDPROC game_window_proc = 0;
}

//
// missing component: validating incoming input to game camera
//
static LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	static DWORD  invalid_cnt     = 0;


	//
	// block all non used devices
	//
	if (globals::device_list.size() > 1)
	{
		DEVICE_INFO primary_dev{};
		UINT64      max_calls = 0;

		for (DEVICE_INFO &dev : globals::device_list)
		{
			if (dev.total_calls > max_calls)
			{
				max_calls   = dev.total_calls;
				primary_dev = dev;
			}
		}

		if (max_calls > 50)
		{
			globals::device_list.clear();
			globals::device_list.push_back(primary_dev);
			LOG("primary input device has been now selected\n");
		}
	}


	//
	// validate incoming rawinput device
	//
	if (uMsg == WM_INPUT)
	{
		RAWINPUT data{};
		UINT size = sizeof(RAWINPUT);
		GetRawInputData((HRAWINPUT)lParam, RID_INPUT, &data, &size, sizeof(RAWINPUTHEADER));


		if (data.header.dwType != RIM_TYPEMOUSE)
		{
			return CallWindowProc(globals::game_window_proc, hwnd, uMsg, wParam, lParam );
		}


		BOOLEAN found = 0;
		for (DEVICE_INFO &dev : globals::device_list)
		{
			if (dev.handle == data.header.hDevice)
			{
				found = 1;
				dev.total_calls++;
				break;
			}
		}


		if (found == 0)
		{
			LOG("invalid mouse input detected %d\n", ++invalid_cnt);
			uMsg = WM_NULL;
		}
	}


	//
	// detect injected messages
	// https://stackoverflow.com/questions/69193249/how-to-distinguish-mouse-and-touchpad-events-using-getcurrentinputmessagesource
	//
	if ((uMsg >= WM_MOUSEFIRST && uMsg <= WM_MOUSELAST) || (uMsg >= WM_KEYFIRST && uMsg <= WM_KEYLAST) || (uMsg >= WM_TOUCH && uMsg <= WM_POINTERWHEEL))
	{
		INPUT_MESSAGE_SOURCE src;
		if (GetCurrentInputMessageSource(&src))
		{
			if (src.originId == IMO_INJECTED)
			{
				LOG("invalid mouse input detected %d\n", ++invalid_cnt);
				uMsg = WM_NULL;
			}
		}
	}
	return CallWindowProc(globals::game_window_proc, hwnd, uMsg, wParam, lParam );
}

static void MainThread(void)
{
	HWND window = 0;
	while (1)
	{
		window = FindWindowA("Valve001", 0);

		if (window != 0)
		{
			break;
		}

		Sleep(100);
	}
	globals::device_list      = get_input_devices();
	globals::game_window_proc = (WNDPROC)SetWindowLongPtrW(window, GWL_WNDPROC, (LONG)WindowProc);
	LOG("plugin is installed\n");
}

VOID CALLBACK DllCallback(
  _In_      ULONG NotificationReason,
  _In_      PCLDR_DLL_NOTIFICATION_DATA NotificationData,
  _In_opt_  PVOID Context
)
{
	UNREFERENCED_PARAMETER(Context);
	if (NotificationReason == LDR_DLL_NOTIFICATION_REASON_LOADED)
	{
		LOG("%ws\n", NotificationData->Loaded.BaseDllName->Buffer);
	}
	else if (NotificationReason == LDR_DLL_NOTIFICATION_REASON_UNLOADED)
	{
	}
}

BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, LPVOID Reserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		AllocConsole();
		freopen("CONOUT$", "w", stdout);
		CloseHandle(CreateThread(0, 0, (LPTHREAD_START_ROUTINE)MainThread, 0, 0, 0));

		NTSTATUS (NTAPI *LdrRegisterDllNotification)(
		  _In_     ULONG                          Flags,
		  _In_     PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,
		  _In_opt_ PVOID                          Context,
		  _Out_    PVOID                          *Cookie
		);
		VOID *dll_callback_handle = 0;
		*(void**)&LdrRegisterDllNotification = (void*)GetProcAddress(LoadLibraryA("ntdll.dll"), "LdrRegisterDllNotification");
		LdrRegisterDllNotification(0, DllCallback, 0, &dll_callback_handle);

	}
	return 1;
}

std::vector<DEVICE_INFO> get_input_devices(void)
{
	std::vector<DEVICE_INFO> devices;


	//
	// get number of devices
	//
	UINT device_count = 0;
	GetRawInputDeviceList(0, &device_count, sizeof(RAWINPUTDEVICELIST));


	//
	// allocate space for device list
	//
	RAWINPUTDEVICELIST *device_list = (RAWINPUTDEVICELIST *)malloc(sizeof(RAWINPUTDEVICELIST) * device_count);


	//
	// get list of input devices
	//
	GetRawInputDeviceList(device_list, &device_count, sizeof(RAWINPUTDEVICELIST));


	for (UINT i = 0; i < device_count; i++)
	{
		//
		// skip non mouse devices ; we can adjust this in future
		//
		if (device_list[i].dwType != RIM_TYPEMOUSE)
		{
			continue;
		}


		//
		// add new device to our dynamic list
		//
		DEVICE_INFO info{};
		info.handle = device_list[i].hDevice;
		devices.push_back(info);
	}


	//
	// free resources
	//
	free(device_list);


	return devices;
}


```

`CSGO/dll/main.h`:

```h
#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <stdio.h>
#include <Ntsecapi.h>
#include <vector>
#include <chrono>

typedef const UNICODE_STRING * PCUNICODE_STRING;
typedef struct _LDR_DLL_LOADED_NOTIFICATION_DATA {
    ULONG Flags;                    //Reserved.
    PCUNICODE_STRING FullDllName;   //The full path name of the DLL module.
    PCUNICODE_STRING BaseDllName;   //The base file name of the DLL module.
    PVOID DllBase;                  //A pointer to the base address for the DLL in memory.
    ULONG SizeOfImage;              //The size of the DLL image, in bytes.
} LDR_DLL_LOADED_NOTIFICATION_DATA, *PLDR_DLL_LOADED_NOTIFICATION_DATA;

typedef union _LDR_DLL_NOTIFICATION_DATA {
    LDR_DLL_LOADED_NOTIFICATION_DATA Loaded;
    LDR_DLL_LOADED_NOTIFICATION_DATA Unloaded;
} LDR_DLL_NOTIFICATION_DATA, *PLDR_DLL_NOTIFICATION_DATA;

typedef const _LDR_DLL_NOTIFICATION_DATA * PCLDR_DLL_NOTIFICATION_DATA;

typedef VOID (CALLBACK * PLDR_DLL_NOTIFICATION_FUNCTION)(
  _In_      ULONG NotificationReason,
  _In_      PCLDR_DLL_NOTIFICATION_DATA NotificationData,
  _In_opt_  PVOID Context
);

typedef struct {
	HANDLE handle;
	UINT64 total_calls;
} DEVICE_INFO ;

#define LDR_DLL_NOTIFICATION_REASON_LOADED 1
#define LDR_DLL_NOTIFICATION_REASON_UNLOADED 2

#define DEBUG
#define LOG(...) printf("[ec-guard.dll] " __VA_ARGS__)


```

`README.md`:

```md
# ec-guard
Proof of concept Anti-Cheat plugin.

```