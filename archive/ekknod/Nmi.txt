Project Path: arc_ekknod_Nmi_epzk5oc9

Source Tree:

```txt
arc_ekknod_Nmi_epzk5oc9
├── README.md
└── boot - loader
    ├── boot.default.props
    ├── boot.props
    ├── boot.sln
    ├── boot.vcxproj
    ├── boot.vcxproj.filters
    ├── boot.vcxproj.user
    ├── main.c
    ├── stdafx.h
    ├── util.c
    └── util.h

```

`README.md`:

```md
# Nmi
Old way for blocking NMI interrupts

```

`boot - loader/boot.default.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup Label="UserMacros">
    <EDK_PATH>..\edk2</EDK_PATH>
  </PropertyGroup>
  <PropertyGroup>
    <IncludePath>$(EDK_PATH)\MdePkg\Include;$(EDK_PATH)\MdePkg\Include\X64;$(EDK_PATH)\ShellPkg\Include;$(EDK_PATH)\CryptoPkg\Include</IncludePath>
    <LibraryPath>$(EDK_PATH)\</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>$(DefaultPlatformToolset)</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <ItemGroup>
    <BuildMacro Include="EDK_PATH">
      <Value>$(EDK_PATH)</Value>
      <EnvironmentVariable>true</EnvironmentVariable>
    </BuildMacro>
  </ItemGroup>
</Project>

```

`boot - loader/boot.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup>
    <GenerateManifest />
    <IntDir>$(SolutionDir)$(Platform)\$(Configuration)\obj\$(TargetName)\</IntDir>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <TargetExt>.efi</TargetExt>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <WarningLevel>Level4</WarningLevel>
      <TreatWarningAsError>true</TreatWarningAsError>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <OmitFramePointers>true</OmitFramePointers>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <ExceptionHandling>SyncCThrow</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <ForcedIncludeFiles>..\edk2\BaseLib\vshacks.h</ForcedIncludeFiles>
      <CallingConvention />
      <TreatWChar_tAsBuiltInType />
      <StringPooling>true</StringPooling>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <ForceConformanceInForLoopScope />
      <AdditionalOptions>/Gs32768 %(AdditionalOptions)</AdditionalOptions>
      <ErrorReporting />
      <FloatingPointModel />
    </ClCompile>
    <Link>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <AdditionalDependencies>UefiHiiLib.lib;UefiHiiServicesLib.lib;UefiSortLib.lib;UefiShellLib.lib;GlueLib.lib;BaseLib.lib;BaseDebugPrintErrorLevelLib.lib;BasePrintLib.lib;UefiLib.lib;UefiBootServicesTableLib.lib;UefiRuntimeServicesTableLib.lib;UefiDevicePathLibDevicePathProtocol.lib;UefiDebugLibConOut.lib;UefiMemoryLib.lib;UefiMemoryAllocationLib.lib;BaseSynchronizationLib.lib;UefiFileHandleLib.lib</AdditionalDependencies>
      <GenerateDebugInformation>DebugFastLink</GenerateDebugInformation>
      <SubSystem>EFI Boot Service Driver</SubSystem>
      <Driver>Driver</Driver>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding />
      <LinkTimeCodeGeneration>UseFastLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <BaseAddress>0</BaseAddress>
      <SectionAlignment>32</SectionAlignment>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <RandomizedBaseAddress />
      <DataExecutionPrevention />
      <ManifestFile />
      <AllowIsolation />
      <EnableUAC />
      <UACExecutionLevel />
      <UACUIAccess />
      <TypeLibraryResourceID />
      <AdditionalOptions>/OPT:ICF=10 /IGNORE:4001 /IGNORE:4254 /IGNORE:4281 %(AdditionalOptions)</AdditionalOptions>
      <MergeSections>.rdata=.data</MergeSections>
      <SpecifySectionAttributes>.xdata,D</SpecifySectionAttributes>
      <LinkErrorReporting />
      <ProfileGuidedDatabase />
      <EntryPointSymbol>EfiMain</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
</Project>

```

`boot - loader/boot.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30413.136
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "boot", "boot.vcxproj", "{79D78FD5-8F41-442F-944E-81774DC9DF39}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{79D78FD5-8F41-442F-944E-81774DC9DF39}.Release|x64.ActiveCfg = Release|x64
		{79D78FD5-8F41-442F-944E-81774DC9DF39}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {8B81D542-88C7-4CE0-B921-E6F43D1B2D9F}
	EndGlobalSection
EndGlobal

```

`boot - loader/boot.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
    <ClCompile Include="util.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="util.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{79D78FD5-8F41-442F-944E-81774DC9DF39}</ProjectGuid>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>bootx64</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <PlatformToolset>v142</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(SolutionDir)\boot.default.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <Import Project="$(SolutionDir)\boot.props" />
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
  <ItemDefinitionGroup>
    <Link>
      <AdditionalDependencies>UefiApplicationEntryPoint.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <SubSystem>EFI Application</SubSystem>
      <GenerateDebugInformation Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</GenerateDebugInformation>
      <GenerateMapFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</GenerateMapFile>
    </Link>
    <ClCompile>
      <TreatWarningAsError Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</TreatWarningAsError>
      <RuntimeLibrary Condition="'$(Configuration)|$(Platform)'=='Release|x64'">MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</BufferSecurityCheck>
      <ControlFlowGuard Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ControlFlowGuard>
      <DebugInformationFormat Condition="'$(Configuration)|$(Platform)'=='Release|x64'">None</DebugInformationFormat>
      <WholeProgramOptimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</WholeProgramOptimization>
    </ClCompile>
  </ItemDefinitionGroup>
</Project>
```

`boot - loader/boot.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Header Files">
      <UniqueIdentifier>{1bb1e3e7-3d88-45c4-861a-b3afcff9fd29}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files">
      <UniqueIdentifier>{dcae272e-95fb-445d-bcde-4502ced9bcae}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{297f9290-d3fe-4cca-b1fb-43cb37aa1c6b}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
    <ClCompile Include="util.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="util.h" />
  </ItemGroup>
</Project>
```

`boot - loader/boot.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`boot - loader/main.c`:

```c
#include "stdafx.h"

const UINT32 _gUefiDriverRevision = 0x200;
CHAR8 *gEfiCallerBaseName = "";
EFI_STATUS LoadWindows(EFI_HANDLE ImageHandle);

enum WinloadContext
{
	ApplicationContext,
	FirmwareContext
};

QWORD ResolveRelativeAddress(
	QWORD Instruction,
	DWORD OffsetOffset,
	DWORD InstructionSize
)
{

	QWORD Instr = (QWORD)Instruction;
	INT32 RipOffset = *(INT32*)(Instr + OffsetOffset);
	QWORD ResolvedAddr = (QWORD)(Instr + InstructionSize + RipOffset);
	return ResolvedAddr;
}

EFI_EXIT_BOOT_SERVICES oExitBootServices;
EFI_STATUS EFIAPI ExitBootServices(EFI_HANDLE ImageHandle, UINTN MapKey)
{
	gBS->ExitBootServices = oExitBootServices;

	BOOLEAN nmi_blocked = 0;

	QWORD returnAddress = (QWORD)_ReturnAddress();
	while (*(unsigned short*)returnAddress != IMAGE_DOS_SIGNATURE)
		returnAddress = returnAddress - 1;

	IMAGE_DOS_HEADER* dos = (IMAGE_DOS_HEADER*)returnAddress;
	IMAGE_NT_HEADERS64* nt = (IMAGE_NT_HEADERS64*)((char*)dos + dos->e_lfanew);
	DWORD imageSize = nt->OptionalHeader.SizeOfImage;

	QWORD loaderBlockScan = (QWORD)FindPattern((unsigned char*)returnAddress, imageSize,
		"\x48\x8B\x3D\x00\x00\x00\x00\x48\x8B\x8F\x00\x00\x00\x00", "xxx????xxx????");

	if (loaderBlockScan == 0)
	{
		//
		// 1909
		//

		loaderBlockScan = (UINT64)FindPattern((unsigned char*)returnAddress, imageSize,
			"\x0F\x31\x48\x8B\x3D\x00\x00\x00\x00", "xxxxx????");

		//
		// 1809
		//
		if (loaderBlockScan == 0)
			loaderBlockScan = (UINT64)FindPattern((unsigned char*)returnAddress, imageSize,
				"\x48\x8B\x3D\x00\x00\x00\x00\x48\x8B\xCF", "xxx????xxx");

		//
		// 1607
		//
		if (loaderBlockScan == 0)
			loaderBlockScan = (UINT64)FindPattern((unsigned char*)returnAddress, imageSize,
				"\x48\x8B\x35\x00\x00\x00\x00\x48\x8B\x45\xF7", "xxx????xxxx");

	}

	if (loaderBlockScan == 0)
		goto E0;

	QWORD resolvedAddress = *(QWORD*)((loaderBlockScan + 7) + *(int*)(loaderBlockScan + 3));

	typedef void(__stdcall* BlpArchSwitchContext_t)(int target);
	BlpArchSwitchContext_t BlpArchSwitchContext;

	BlpArchSwitchContext = (BlpArchSwitchContext_t)(FindPattern((unsigned char*)returnAddress, imageSize,
		"\x40\x53\x48\x83\xEC\x20\x48\x8B\x15", "xxxxxxxxx"));

	if (BlpArchSwitchContext == 0)
		goto E0;

	BlpArchSwitchContext(ApplicationContext);

	LOADER_PARAMETER_BLOCK *loaderBlock = (LOADER_PARAMETER_BLOCK*)(resolvedAddress);
	KLDR_DATA_TABLE_ENTRY* ntosrknl = GetModuleEntry(&loaderBlock->LoadOrderListHead, L"ntoskrnl.exe");

	// E8 ?? ?? ?? ?? 83 CB FF 48 8B D6
	QWORD pattern_idt = (QWORD)FindPattern((unsigned char*)ntosrknl->ImageBase, ntosrknl->SizeOfImage,
		"\xE8\x00\x00\x00\x00\x83\xCB\xFF\x48\x8B\xD6", "x????xxxxxx");

	if (pattern_idt)
	{
		pattern_idt = ResolveRelativeAddress(pattern_idt, 1, 5); //KiInitializeIdt
		pattern_idt += 0x1a;
		pattern_idt = ResolveRelativeAddress(pattern_idt, 3, 7); //KiInterruptInitTable

		//https://xem.github.io/minix86/manual/intel-x86-and-64-manual-vol3/o_fe12b1e2a880e0ce-220.html
		*(QWORD*)(pattern_idt + 0x38) = *(QWORD*)(pattern_idt + 0x1A0); //KiInterruptInitTable[2].Handler = KiInterruptInitTable[11].Handler(#NP)
		*(QWORD*)(pattern_idt + 0x40) = *(QWORD*)(pattern_idt + 0x1A8); //KiInterruptInitTable[2].ShadowHandler = KiInterruptInitTable[11].ShadowHandler(#NP)

		nmi_blocked = 1;
	}

	BlpArchSwitchContext(FirmwareContext);

E0:

	if (nmi_blocked)
	{
		Print(L"[bootx64.efi] NMI is succesfully blocked\n");
	}
	else
	{
		Print(L"[bootx64.efi] failed to find addresses\n");
	}

	PressAnyKey();

	return oExitBootServices(ImageHandle, MapKey);
}

EFI_STATUS EFIAPI UefiMain(EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable)
{
        gST->ConOut->ClearScreen(gST->ConOut);
        gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);

	oExitBootServices = gBS->ExitBootServices;
	gBS->ExitBootServices = ExitBootServices;

	EFI_STATUS status = LoadWindows(ImageHandle);
	if (EFI_ERROR(status))
	{
		gBS->ExitBootServices = oExitBootServices;
		PressAnyKey();
		return status;
	}

	return status;
}

EFI_STATUS EFIAPI UefiUnload(EFI_HANDLE ImageHandle)
{
	return 0;
}

// Locates the device path for the Windows bootmgr
EFI_DEVICE_PATH* EFIAPI GetWindowsBootmgrDevicePath()
{
	UINTN handleCount;
	EFI_HANDLE* handles;
	EFI_DEVICE_PATH* devicePath = NULL;

	// Retrieve filesystem handles
	EFI_STATUS status =
		gBS->LocateHandleBuffer(ByProtocol, &gEfiSimpleFileSystemProtocolGuid,
			NULL, &handleCount, &handles);

	if (EFI_ERROR(status)) {
		return devicePath;
	}

	// Check each FS for the bootmgr
	for (UINTN i = 0; i < handleCount && !devicePath; ++i) {
		EFI_FILE_IO_INTERFACE* fileSystem;
		status = gBS->OpenProtocol(
			handles[i], &gEfiSimpleFileSystemProtocolGuid, (VOID**)&fileSystem,
			gImageHandle, NULL, EFI_OPEN_PROTOCOL_GET_PROTOCOL);

		if (EFI_ERROR(status)) {
			continue;
		}

		EFI_FILE_HANDLE volume;
		status = fileSystem->OpenVolume(fileSystem, &volume);
		if (!EFI_ERROR(status)) {
			EFI_FILE_HANDLE file;
			status = volume->Open(volume, &file, L"\\efi\\microsoft\\boot\\bootmgfw.efi",
				EFI_FILE_MODE_READ, EFI_FILE_READ_ONLY);

			if (!EFI_ERROR(status)) {
				volume->Close(file);

				devicePath = FileDevicePath(handles[i], L"\\efi\\microsoft\\boot\\bootmgfw.efi");
			}
		}

		gBS->CloseProtocol(handles[i], &gEfiSimpleFileSystemProtocolGuid,
			gImageHandle, NULL);
	}

	gBS->FreePool(handles);
	return devicePath;
}

// Sets BootCurrent to Windows bootmgr option
EFI_STATUS EFIAPI SetBootCurrentToWindowsBootmgr()
{
	// Query boot order array
	UINTN bootOrderSize = 0;
	EFI_STATUS status =
		gRT->GetVariable(EFI_BOOT_ORDER_VARIABLE_NAME, &gEfiGlobalVariableGuid,
			NULL, &bootOrderSize, NULL);

	if (status != EFI_BUFFER_TOO_SMALL) {
		return status;
	}

	UINT16* bootOrder = AllocatePool(bootOrderSize);
	if (!bootOrder) {
		return EFI_OUT_OF_RESOURCES;
	}

	status =
		gRT->GetVariable(EFI_BOOT_ORDER_VARIABLE_NAME, &gEfiGlobalVariableGuid,
			NULL, &bootOrderSize, bootOrder);

	if (EFI_ERROR(status)) {
		FreePool(bootOrder);
		return status;
	}

	// Try each boot option to find Windows boot manager
	BOOLEAN found = FALSE;
	for (UINTN i = 0; i < bootOrderSize / sizeof(bootOrder[0]) && !found; ++i) {
		CHAR16 variableName[0xFF];
		UnicodeSPrint(variableName, sizeof(variableName), L"Boot%04x",
			bootOrder[i]);

		UINTN bufferSize = 0;
		status = gRT->GetVariable(variableName, &gEfiGlobalVariableGuid, NULL,
			&bufferSize, NULL);

		if (status != EFI_BUFFER_TOO_SMALL) {
			break;
		}

		UINT8* buffer = AllocatePool(bufferSize);
		if (!buffer) {
			status = EFI_OUT_OF_RESOURCES;
			break;
		}

		status = gRT->GetVariable(variableName, &gEfiGlobalVariableGuid, NULL,
			&bufferSize, buffer);

		if (EFI_ERROR(status)) {
			FreePool(buffer);
			break;
		}

		// Check the option file path list
		EFI_LOAD_OPTION* bootOption = (EFI_LOAD_OPTION*)buffer;
		CHAR16* bootOptionDescription =
			(CHAR16*)(buffer + sizeof(EFI_LOAD_OPTION));

		EFI_DEVICE_PATH_PROTOCOL* bootOptionPaths =
			(EFI_DEVICE_PATH_PROTOCOL*)(bootOptionDescription +
				StrLen(bootOptionDescription) + 1);

		if (bootOption->FilePathListLength) {
			// Only the first path is needed
			CHAR16* bootOptionPath =
				ConvertDevicePathToText(&bootOptionPaths[0], FALSE, TRUE);

			if (bootOptionPath) {
				// Convert it to lowercase
				for (CHAR16* c = bootOptionPath; *c; ++c) {
					if (*c >= 'A' && *c <= 'Z') {
						*c += ('a' - 'A');
					}
				}

				// Check if it contains the bootmgr path
				if (StrStr(bootOptionPath, L"\\efi\\microsoft\\boot\\bootmgfw.efi")) {
					// If so, update BootCurrent to this option
					status = gRT->SetVariable(EFI_BOOT_CURRENT_VARIABLE_NAME,
						&gEfiGlobalVariableGuid,
						EFI_VARIABLE_BOOTSERVICE_ACCESS |
						EFI_VARIABLE_RUNTIME_ACCESS,
						sizeof(UINT16), &bootOrder[i]);

					if (!EFI_ERROR(status)) {
						found = TRUE;
					}
				}

				FreePool(bootOptionPath);
			}
		}

		FreePool(buffer);
	}

	FreePool(bootOrder);

	if (!EFI_ERROR(status) && !found) {
		status = EFI_NOT_FOUND;
	}

	return status;
}

EFI_STATUS LoadWindows(EFI_HANDLE ImageHandle)
{
	EFI_DEVICE_PATH* bootmgrPath = GetWindowsBootmgrDevicePath();
	if (!bootmgrPath)
	{
		Print(L"Windows UEFI loader not found (0x00), pleace install windows as UEFI\n");
		return EFI_NOT_FOUND;
	}

	EFI_STATUS status = SetBootCurrentToWindowsBootmgr();
	if (EFI_ERROR(status))
	{
		Print(L"Windows UEFI loader not found (0x01), pleace install windows as UEFI\n");
		return EFI_NOT_FOUND;
	}

	EFI_HANDLE bootmgrHandle;
	status = gBS->LoadImage(TRUE, ImageHandle, bootmgrPath, NULL, 0, &bootmgrHandle);

	if (EFI_ERROR(status)) {
		Print(L"Failed to load bootmgfw.efi\n");
		return EFI_NOT_FOUND;
	}

	return gBS->StartImage(bootmgrHandle, NULL, NULL);
}

```

`boot - loader/stdafx.h`:

```h
#pragma once
#include <Uefi.h>
#include <Library/UefiLib.h>
#include <Library/DebugLib.h>
#include <Library/MemoryAllocationLib.h>
#include <Library/UefiBootServicesTableLib.h>
#include <Library/UefiRuntimeServicesTableLib.h>
#include <Library/DevicePathLib.h>
#include <Library/PrintLib.h>
#include <Protocol/SimpleFileSystem.h>
#include <Protocol/LoadedImage.h>
#include <IndustryStandard/PeImage.h>
#include <Guid/GlobalVariable.h>
#include "util.h"

```

`boot - loader/util.c`:

```c
#include "stdafx.h"

VOID MemCopy(VOID* dest, VOID* src, UINTN size)
{
	for (UINT8* d = dest, *s = src; size--; *d++ = *s++)
		;
}

static BOOLEAN CheckMask(unsigned char* base, unsigned char* pattern, unsigned char* mask)
{
	for (; *mask; ++base, ++pattern, ++mask)
		if (*mask == 'x' && *base != *pattern)
			return FALSE;
	return TRUE;
}

VOID* FindPattern(unsigned char* base, UINTN size, unsigned char* pattern, unsigned char* mask)
{
	size -= AsciiStrLen(mask);
	for (UINTN i = 0; i <= size; ++i) {
		VOID* addr = &base[i];
		if (CheckMask(addr, pattern, mask))
			return addr;
	}
	return NULL;
}

VOID* TrampolineHook(VOID* dest, VOID* src, UINT8 original[JMP_SIZE])
{
	if (original)
		MemCopy(original, src, JMP_SIZE);
	MemCopy(src, "\xFF\x25\x00\x00\x00\x00", 6);
	*(VOID**)((UINT8*)src + 6) = dest;
	return src;
}

VOID TrampolineUnHook(VOID* src, UINT8 original[JMP_SIZE])
{
	MemCopy(src, original, JMP_SIZE);
}

INTN
EFIAPI
StrnCmpA(
	IN      CONST CHAR16* FirstString,
	IN      CONST CHAR16* SecondString,
	IN      UINTN                     Length
)
{
	while ((*FirstString != L'\0') &&
		(*SecondString != L'\0') &&
		(AsciiCharToUpper((CHAR8)*FirstString) == AsciiCharToUpper((CHAR8)*SecondString)) &&
		(Length > 1)) {
		FirstString++;
		SecondString++;
		Length--;
	}
	return *FirstString - *SecondString;
}

KLDR_DATA_TABLE_ENTRY* GetModuleEntry(LIST_ENTRY* entry, CHAR16* name)
{
	LIST_ENTRY* list = entry;
	while ((list = list->ForwardLink) != entry) {
		KLDR_DATA_TABLE_ENTRY* module =
			CONTAINING_RECORD(list, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

		if (module && StrnCmpA(name, module->BaseImageName.Buffer,
			module->BaseImageName.Length) == 0) {

			return module;
		}
	}
	return NULL;
}

UINT64 GetExport(QWORD base, CHAR8* export)
{
	QWORD a0;
	DWORD a1[4];

	a0 = base + *(unsigned short*)(base + 0x3C);
	a0 = base + *(DWORD*)(a0 + 0x88);
	a1[0] = *(DWORD*)(a0 + 0x18);
	a1[1] = *(DWORD*)(a0 + 0x1C);
	a1[2] = *(DWORD*)(a0 + 0x20);
	a1[3] = *(DWORD*)(a0 + 0x24);
	while (a1[0]--) {
		a0 = base + *(DWORD*)(base + a1[2] + (a1[0] * 4));
		if (AsciiStrCmp((const CHAR8*)a0, export) == 0) {
			return (base + *(DWORD*)(base + a1[1] +
				(*(unsigned short*)(base + a1[3] + (a1[0] * 2)) * 4)));
		}
	}
	return 0;
}


```

`boot - loader/util.h`:

```h
#pragma once

#define CONTAINING_RECORD(address, type, field) ((type *)((UINT8 *)(address) - (UINTN)(&((type *)0)->field)))
#define RELATIVE_ADDR(addr, size) ((VOID *)((UINT8 *)(addr) + *(INT32 *)((UINT8 *)(addr) + ((size) - (INT32)sizeof(INT32))) + (size)))
#define JMP_SIZE (14)
#define IMAGE_REL_BASED_ABSOLUTE (0)
#define IMAGE_REL_BASED_DIR64 (10)
#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES (16)
#define IMAGE_SIZEOF_SHORT_NAME (8)
#define IMAGE_DIRECTORY_ENTRY_EXPORT (0)
#define IMAGE_DIRECTORY_ENTRY_IMPORT (1)
#define IMAGE_DIRECTORY_ENTRY_BASERELOC (5)
#define IMAGE_DOS_SIGNATURE (0x5A4D)

typedef UINTN QWORD;
typedef UINT32 DWORD;
typedef long NTSTATUS;

struct _VIRTUAL_EFI_RUNTIME_SERVICES
{
	UINT64 GetTime;                                                      //0x0
	UINT64 SetTime;                                                      //0x8
	UINT64 GetWakeupTime;                                                //0x10
	UINT64 SetWakeupTime;                                                //0x18
	UINT64 SetVirtualAddressMap;                                         //0x20
	UINT64 ConvertPointer;                                               //0x28
	UINT64 GetVariable;                                                  //0x30
	UINT64 GetNextVariableName;                                          //0x38
	UINT64 SetVariable;                                                  //0x40
	UINT64 GetNextHighMonotonicCount;                                    //0x48
	UINT64 ResetSystem;                                                  //0x50
	UINT64 UpdateCapsule;                                                //0x58
	UINT64 QueryCapsuleCapabilities;                                     //0x60
	UINT64 QueryVariableInfo;                                            //0x68
};

struct _EFI_FIRMWARE_INFORMATION
{
	UINT32 FirmwareVersion;                                                 //0x0
	struct _VIRTUAL_EFI_RUNTIME_SERVICES* VirtualEfiRuntimeServices;        //0x8
	UINT32 SetVirtualAddressMapStatus;                                      //0x10
	UINT32 MissedMappingsCount;                                             //0x14
	struct _LIST_ENTRY FirmwareResourceList;                                //0x18
	VOID* EfiMemoryMap;                                                     //0x28
	UINT32 EfiMemoryMapSize;                                                 //0x30
	UINT32 EfiMemoryMapDescriptorSize;                                       //0x34
};

struct _PCAT_FIRMWARE_INFORMATION
{
	UINT32 PlaceHolder;                                                      //0x0
};

struct _FIRMWARE_INFORMATION_LOADER_BLOCK
{
	UINT32 FirmwareTypeUefi:1;                                               //0x0
	UINT32 EfiRuntimeUseIum:1;                                               //0x0
	UINT32 EfiRuntimePageProtectionSupported:1;                              //0x0
	UINT32 Reserved:29;                                                      //0x0
	union
	{
		struct _EFI_FIRMWARE_INFORMATION EfiInformation;                 //0x8
		struct _PCAT_FIRMWARE_INFORMATION PcatInformation;               //0x8
	} u;                                                                     //0x8
};

struct _I386_LOADER_BLOCK
{
	VOID* CommonDataArea;                                                   //0x0
	UINT32 MachineType;                                                      //0x8
	UINT32 VirtualBias;                                                      //0xc
};

struct _ARM_LOADER_BLOCK
{
	UINT32 PlaceHolder;                                                      //0x0
};

typedef struct _LOADER_PARAMETER_BLOCK {
	UINT32 OsMajorVersion;                                                   //0x0
	UINT32 OsMinorVersion;                                                   //0x4
	UINT32 Size;                                                             //0x8
	UINT32 OsLoaderSecurityVersion;                                          //0xc
	struct _LIST_ENTRY LoadOrderListHead;                                   //0x10
	struct _LIST_ENTRY MemoryDescriptorListHead;                            //0x20
	struct _LIST_ENTRY BootDriverListHead;                                  //0x30
	struct _LIST_ENTRY EarlyLaunchListHead;                                 //0x40
	struct _LIST_ENTRY CoreDriverListHead;                                  //0x50
	struct _LIST_ENTRY CoreExtensionsDriverListHead;                        //0x60
	struct _LIST_ENTRY TpmCoreDriverListHead;                               //0x70
	UINT64 KernelStack;                                                     //0x80
	UINT64 Prcb;                                                            //0x88
	UINT64 Process;                                                         //0x90
	UINT64 Thread;                                                          //0x98
	UINT32 KernelStackSize;                                                 //0xa0
	UINT32 RegistryLength;                                                  //0xa4
	VOID* RegistryBase;                                                     //0xa8
	struct _CONFIGURATION_COMPONENT_DATA* ConfigurationRoot;                //0xb0
	char* ArcBootDeviceName;                                                //0xb8
	char* ArcHalDeviceName;                                                 //0xc0
	char* NtBootPathName;                                                   //0xc8
	char* NtHalPathName;                                                    //0xd0
	char* LoadOptions;                                                      //0xd8
	struct _NLS_DATA_BLOCK* NlsData;                                        //0xe0
	struct _ARC_DISK_INFORMATION* ArcDiskInformation;                       //0xe8
	struct _LOADER_PARAMETER_EXTENSION* Extension;                          //0xf0
	union
	{
		struct _I386_LOADER_BLOCK I386;                                         //0xf8
		struct _ARM_LOADER_BLOCK Arm;                                           //0xf8
	} u;                                                                    //0xf8
	struct _FIRMWARE_INFORMATION_LOADER_BLOCK FirmwareInformation;          //0x108
	char* OsBootstatPathName;                                               //0x148
	char* ArcOSDataDeviceName;                                              //0x150
	char* ArcWindowsSysPartName;                                            //0x158
} LOADER_PARAMETER_BLOCK  ;

typedef struct _UNICODE_STRING {
	UINT16 Length;
	UINT16 MaximumLength;
	CHAR16 *Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef struct _KLDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderLinks;
	VOID* ExceptionTable;
	UINT32 ExceptionTableSize;
	VOID* GpValue;
	VOID* NonPagedDebugInfo;
	VOID* ImageBase;
	VOID* EntryPoint;
	UINT32 SizeOfImage;
	UNICODE_STRING FullImageName;
	UNICODE_STRING BaseImageName;
} KLDR_DATA_TABLE_ENTRY;

typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
	UINT16 e_magic;                     // Magic number
	UINT16 e_cblp;                      // Bytes on last page of file
	UINT16 e_cp;                        // Pages in file
	UINT16 e_crlc;                      // Relocations
	UINT16 e_cparhdr;                   // Size of header in paragraphs
	UINT16 e_minalloc;                  // Minimum extra paragraphs needed
	UINT16 e_maxalloc;                  // Maximum extra paragraphs needed
	UINT16 e_ss;                        // Initial (relative) SS value
	UINT16 e_sp;                        // Initial SP value
	UINT16 e_csum;                      // Checksum
	UINT16 e_ip;                        // Initial IP value
	UINT16 e_cs;                        // Initial (relative) CS value
	UINT16 e_lfarlc;                    // File address of relocation table
	UINT16 e_ovno;                      // Overlay number
	UINT16 e_res[4];                    // Reserved words
	UINT16 e_oemid;                     // OEM identifier (for e_oeminfo)
	UINT16 e_oeminfo;                   // OEM information; e_oemid specific
	UINT16 e_res2[10];                  // Reserved words
	UINT32 e_lfanew;                    // File address of new exe header
} IMAGE_DOS_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY {
	UINT32   VirtualAddress;
	UINT32   Size;
} IMAGE_DATA_DIRECTORY, * PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
	UINT16               Magic;
	UINT8                MajorLinkerVersion;
	UINT8                MinorLinkerVersion;
	UINT32               SizeOfCode;
	UINT32               SizeOfInitializedData;
	UINT32               SizeOfUninitializedData;
	UINT32               AddressOfEntryPoint;
	UINT32               BaseOfCode;
	UINT64               ImageBase;
	UINT32               SectionAlignment;
	UINT32               FileAlignment;
	UINT16               MajorOperatingSystemVersion;
	UINT16               MinorOperatingSystemVersion;
	UINT16               MajorImageVersion;
	UINT16               MinorImageVersion;
	UINT16               MajorSubsystemVersion;
	UINT16               MinorSubsystemVersion;
	UINT32               Win32VersionValue;
	UINT32               SizeOfImage;
	UINT32               SizeOfHeaders;
	UINT32               CheckSum;
	UINT16               Subsystem;
	UINT16               DllCharacteristics;
	UINT64               SizeOfStackReserve;
	UINT64               SizeOfStackCommit;
	UINT64               SizeOfHeapReserve;
	UINT64               SizeOfHeapCommit;
	UINT32               LoaderFlags;
	UINT32               NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_FILE_HEADER {
	UINT16  Machine;
	UINT16  NumberOfSections;
	UINT32  TimeDateStamp;
	UINT32  PointerToSymbolTable;
	UINT32  NumberOfSymbols;
	UINT16  SizeOfOptionalHeader;
	UINT16  Characteristics;
} IMAGE_FILE_HEADER;

typedef struct _IMAGE_NT_HEADERS64 {
	UINT32 Signature;
	IMAGE_FILE_HEADER FileHeader;
	IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64;

typedef struct _IMAGE_SECTION_HEADER {
	UINT8    Name[IMAGE_SIZEOF_SHORT_NAME];
	union {
		UINT32   PhysicalAddress;
		UINT32   VirtualSize;
	} Misc;
	UINT32   VirtualAddress;
	UINT32   SizeOfRawData;
	UINT32   PointerToRawData;
	UINT32   PointerToRelocations;
	UINT32   PointerToLinenumbers;
	UINT16   NumberOfRelocations;
	UINT16   NumberOfLinenumbers;
	UINT32   Characteristics;
} IMAGE_SECTION_HEADER, * PIMAGE_SECTION_HEADER;

#pragma warning(push)
#pragma warning(disable: 4201)
typedef struct _IMAGE_IMPORT_DESCRIPTOR {
	union {
		UINT32   Characteristics;
		UINT32   OriginalFirstThunk;
	};

	UINT32   TimeDateStamp;
	UINT32   ForwarderChain;
	UINT32   Name;
	UINT32   FirstThunk;
	} IMAGE_IMPORT_DESCRIPTOR;
#pragma warning(pop)

typedef struct _IMAGE_THUNK_DATA64 {
	union {
		UINT64 ForwarderString;
		UINT64 Function;
		UINT64 Ordinal;
		UINT64 AddressOfData;
	} u1;
} IMAGE_THUNK_DATA64;

typedef struct _IMAGE_IMPORT_BY_NAME {
	UINT16 Hint;
	CHAR8  Name[1];
} IMAGE_IMPORT_BY_NAME;

typedef struct _IMAGE_EXPORT_DIRECTORY {
	UINT32 Characteristics;
	UINT32 TimeDateStamp;
	UINT16 MajorVersion;
	UINT16 MinorVersion;
	UINT32 Name;
	UINT32 Base;
	UINT32 NumberOfFunctions;
	UINT32 NumberOfNames;
	UINT32 AddressOfFunctions;
	UINT32 AddressOfNames;
	UINT32 AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY;

typedef struct _IMAGE_BASE_RELOCATION {
	UINT32 VirtualAddress;
	UINT32 SizeOfBlock;
} IMAGE_BASE_RELOCATION;

VOID MemCopy(VOID* dest, VOID* src, UINTN size);
VOID* FindPattern(unsigned char* base, UINTN size, unsigned char* pattern, unsigned char* mask);
VOID* TrampolineHook(VOID* dest, VOID* src, UINT8 original[JMP_SIZE]);
VOID TrampolineUnHook(VOID* src, UINT8 original[JMP_SIZE]);
INTN
EFIAPI
StrnCmpA(
	IN      CONST CHAR16* FirstString,
	IN      CONST CHAR16* SecondString,
	IN      UINTN                     Length
);

KLDR_DATA_TABLE_ENTRY* GetModuleEntry(LIST_ENTRY* entry, CHAR16* name);
UINT64 GetExport(QWORD base, CHAR8* export);

inline void PressAnyKey()
{
	EFI_STATUS         Status;
	EFI_EVENT          WaitList;
	EFI_INPUT_KEY      Key;
	UINTN              Index;
	
	Print(L"Press any key to continue . . .");
	do {
		WaitList = gST->ConIn->WaitForKey;
		Status = gBS->WaitForEvent(1, &WaitList, &Index);
		gST->ConIn->ReadKeyStroke(gST->ConIn, &Key);
		if (Key.ScanCode != SCAN_PAUSE)
			break;
	} while ( 1 );
	gST->ConOut->ClearScreen(gST->ConOut);
	gST->ConOut->SetAttribute(gST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLACK);
}


```