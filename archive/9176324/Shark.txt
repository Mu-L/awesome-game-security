Project Path: arc_9176324_Shark_9gq94qts

Source Tree:

```txt
arc_9176324_Shark_9gq94qts
├── Commit.ps1
├── CreateISO.cmd
├── Doc
│   ├── Logical.pdf
│   ├── Logical.vsdx
│   ├── PatchGuard Documentation.pdf
│   ├── PatchGuard init code and comparefeilds.png
│   ├── Tetrane_PatchGuard_Analysis_RS4_v1.01.pdf
│   ├── Windows_81_Kernel_Patch_Protection_Analysis.pdf
│   ├── win11 disable virus.png
│   └── xrefs to CmpAppendDllSection.png
├── FastBuild.cmd
├── Include
│   ├── Defs.h
│   ├── DeviceDefs.h
│   ├── Warning.h
│   ├── dump.h
│   ├── guarddefs.h
│   ├── listdefs.h
│   ├── statusdefs.h
│   ├── supdefs.h
│   ├── typesdefs.h
│   ├── ver.h
│   └── wow64.h
├── LICENSE
├── Lib
│   ├── amd64
│   │   ├── detours.obj
│   │   ├── disasm.obj
│   │   ├── gshandler.obj
│   │   ├── gshandlerseh.obj
│   │   ├── nt_process_startup.obj
│   │   └── vDbgPrint.obj
│   └── i386
│       ├── detours.obj
│       ├── disasm.obj
│       ├── eh3.obj
│       ├── nt_process_startup.obj
│       └── vDbgPrint.obj
├── Projects
│   ├── Sea
│   │   ├── AMD64
│   │   │   └── AMD64.asm
│   │   ├── I386
│   │   │   └── I386.asm
│   │   ├── Makefile
│   │   ├── Sea.c
│   │   ├── Sea.def
│   │   ├── Sea.h
│   │   ├── Sea.ico
│   │   ├── Sea.rc
│   │   ├── Sea.vcxproj
│   │   ├── Sea.vcxproj.filters
│   │   ├── Sea.vcxproj.user
│   │   ├── Support.c
│   │   └── Support.h
│   └── Shark
│       ├── AMD64
│       │   ├── AMD64.asm
│       │   ├── CmpAMD64.asm
│       │   ├── ContextAMD64.asm
│       │   ├── ExceptAMD64.c
│       │   ├── PatchGuardAMD64.c
│       │   ├── SpaceAMD64.c
│       │   └── StackAMD64.c
│       ├── Ctx.c
│       ├── Ctx.h
│       ├── Except.c
│       ├── Except.h
│       ├── Guard.c
│       ├── Guard.h
│       ├── I386
│       │   ├── CmpI386.asm
│       │   ├── ContextI386.asm
│       │   ├── ExceptI386.c
│       │   ├── I386.asm
│       │   ├── PatchGuardI386.c
│       │   ├── SpaceI386.c
│       │   └── StackI386.c
│       ├── Makefile
│       ├── PatchGuard.c
│       ├── PatchGuard.h
│       ├── Reload.c
│       ├── Reload.h
│       ├── Rtx.c
│       ├── Rtx.h
│       ├── Scan.c
│       ├── Scan.h
│       ├── Shark.c
│       ├── Shark.def
│       ├── Shark.h
│       ├── Shark.rc
│       ├── Shark.vcxproj
│       ├── Shark.vcxproj.filters
│       ├── Shark.vcxproj.user
│       ├── Space.c
│       ├── Space.h
│       ├── Stack.c
│       └── Stack.h
├── Publisher.cmd
├── README.md
├── Rebuild.cmd
├── Redist
│   ├── amd64
│   │   └── VBoxDrv.sys
│   └── i386
│       └── VBoxDrv.sys
├── Shark.sln
└── VSBuild.cmd

```

`Commit.ps1`:

```ps1
#
#
# Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
#
# The contents of this file are subject to the Mozilla Public License Version
# 2.0 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
# for the specific language governing rights and limitations under the
# License.
#
# The Initial Developer of the Original Code is blindtiger.
#
#

git add *
git commit -m (Get-Date -Format "dddd MM/dd/yyyy HH:mm:ss:fff")
pause

```

`CreateISO.cmd`:

```cmd
@rem
@rem
@rem Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
@rem
@rem The contents of this file are subject to the Mozilla Disk License Version
@rem 2.0 (the "License"); you may not use this file except in compliance with
@rem the License. You may obtain a copy of the License at
@rem http://www.mozilla.org/MPL/
@rem
@rem Software distributed under the License is distributed on an "AS IS" basis,
@rem WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
@rem for the specific language governing rights and limitations under the
@rem License.
@rem
@rem The Initial Developer of the Original Code is blindtiger.
@rem
@rem

@if exist Publisher.iso del /F /Q Publisher.iso
@oscdimgx64 -lPublisher -u1 .\Publisher Publisher.iso

```

`FastBuild.cmd`:

```cmd
@rem 
@rem 
@rem Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
@rem 
@rem The contents of this file are subject to the Mozilla Public License Version
@rem 2.0 (the "License"); you may not use this file except in compliance with
@rem the License. You may obtain a copy of the License at
@rem http://www.mozilla.org/MPL/
@rem 
@rem Software distributed under the License is distributed on an "AS IS" basis,
@rem WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
@rem for the specific language governing rights and limitations under the
@rem License.
@rem 
@rem The Initial Developer of the Original Code is blindtiger.
@rem 
@rem 

@rem set LABS=%~dp0..\
@rem cd /d "%LABS%"
@rem git clone https://github.com/9176324/Shark
@rem git clone https://github.com/9176324/MiniSDK

@set SLND=%~dp0
@if not exist "%SLND%Build\Bins\AMD64" md "%SLND%Build\Bins\AMD64"
@if not exist "%SLND%Build\Bins\I386" md "%SLND%Build\Bins\I386"

@if not exist "%SLND%Build\Objs\Shark" md "%SLND%Build\Objs\Shark"
@if not exist "%SLND%Build\Objs\Sea" md "%SLND%Build\Objs\Sea"

@echo building x86

:CheckOS
@if exist "%PROGRAMFILES(X86)%" (goto x64x86) ELSE (goto x86x86)

:x86x86
@set path=C:\Windows;C:\Windows\System32;%~dp0..\MiniSDK\bin\Hostx86\x86
@goto x86

:x64x86
@set path=C:\Windows;C:\Windows\System32;%~dp0..\MiniSDK\bin\Hostx64\x86
@goto x86

:x86
@cd /d "%SLND%Projects\Shark"
@NMAKE /NOLOGO PLATFORM=x86 PROJ=Shark

@cd /d "%SLND%Projects\Sea"
@NMAKE /NOLOGO PLATFORM=x86 PROJ=Sea

@cd /d "%SLND%"

@echo building x64

:CheckOS
@if exist "%PROGRAMFILES(X86)%" (goto x64x64) ELSE (goto x86x64)

:x86x64
@set path=C:\Windows;C:\Windows\System32;%~dp0..\MiniSDK\bin\Hostx86\x64
@goto x64

:x64x64
@set path=C:\Windows;C:\Windows\System32;%~dp0..\MiniSDK\bin\Hostx64\x64
@goto x64

:x64
@cd /d "%SLND%Projects\Shark"
@NMAKE /NOLOGO PLATFORM=x64 PROJ=Shark

@cd /d "%SLND%Projects\Sea"
@NMAKE /NOLOGO PLATFORM=x64 PROJ=Sea

@cd /d "%SLND%"

```

`Include/Defs.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _DEFS_H_
#define _DEFS_H_

#ifndef PUBLIC
// #define PUBLIC
#endif // !PUBLIC

#define _WIN32_WINNT 0x0500

#include <typesdefs.h>
#include <statusdefs.h>
#include <listdefs.h>

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

#ifndef DEBUG
#define DEBUG
#endif // !DEBUG

#ifndef NTOS_KERNEL_RUNTIME
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#define PAGE_SIZE 0x1000

    void
        CDECL
        vDbgPrint(
            __in tcptr Format,
            ...
        );

#ifndef _DebugBreak
#define _DebugBreak \
    if (FALSE != NtCurrentPeb()->BeingDebugged) __debugbreak
#endif // !_DebugBreak

#ifndef __malloc
#define __malloc(size) RtlAllocateHeap(RtlProcessHeap(), 0, size);
#endif // !__malloc

#ifndef __free
#define __free(pointer) RtlFreeHeap(RtlProcessHeap(), 0, pointer)
#endif // !__free
#else
#include <ntos.h>
#include <zwapi.h>

#define vDbgPrint DbgPrint

#ifndef _DebugBreak
#define _DebugBreak \
    if (FALSE == KdDebuggerNotPresent) __debugbreak
#endif // !_DebugBreak

#ifndef __malloc
#define __malloc(size) ExAllocatePool(NonPagedPool, size);
#endif // !__malloc

#ifndef __free
#define __free(pointer) ExFreePool(pointer);
#endif // !__free
#endif // !NTOS_KERNEL_RUNTIME

#ifdef _WIN64
#include <wow64t.h>
#include <wow64.h>
#endif // _WIN64

#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include <arccodes.h>
#include <ntddkbd.h>
#include <ntddmou.h>

    char *
        __cdecl
        strcpy_s(
            char * strDestination,
            size_t numberOfElements,
            const char * strSource
        );

    wchar_t *
        __cdecl
        wcscpy_s(
            wchar_t * strDestination,
            size_t numberOfElements,
            const wchar_t * strSource
        );

#ifndef DEBUG
#define TRACE(exp) (((status)exp) >= 0)
#else
#ifndef NTOS_KERNEL_RUNTIME
#define TRACE(exp) \
            (((status)exp) >= 0) ? \
                TRUE : \
                (vDbgPrint( \
                    _T("[SHARK] %hs[%d] %hs failed < %08x >\n"), \
                    __FILE__, \
                    __LINE__, \
                    __FUNCDNAME__, \
                    exp),/* _DebugBreak(),*/ FALSE)
#else
#define TRACE(exp) \
            (((status)exp) >= 0) ? \
                TRUE : \
                (vDbgPrint( \
                    "[SHARK] %hs[%d] %hs failed < %08x >\n", \
                    __FILE__, \
                    __LINE__, \
                    __FUNCDNAME__, \
                    exp),/* _DebugBreak(),*/ FALSE)
#endif // !NTOS_KERNEL_RUNTIME
#endif // !DEBUG

#define SystemRootDirectory L"\\SystemRoot\\System32\\"
#define Wow64SystemRootDirectory L"\\SystemRoot\\SysWOW64\\"

#define ServicesDirectory L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_DEFS_H_

```

`Include/DeviceDefs.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger ( blindtiger@foxmail.com )
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _DEVICEDEFS_H_
#define _DEVICEDEFS_H_

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

#include <devioctl.h>      
#include <supdefs.h>

#define KernelString L"Shark.sys"
#define SupportString L"VBoxDrv.sys"
#define KernelPortString L"\\{41F4CD92-4AF0-4447-903D-CD994368059A}"

#define CmdClose                0x00000000ul
#define CmdNull                 0x00000001ul
#define CmdPgClear              0x00000002ul
#define CmdVmxOn                0x00000004ul
#define CmdBugCheck             0x00008000ul
#define CmdReload               0x00010000ul

#define MAXIMUM_USER_FUNCTION_TABLE_SIZE 512
#define MAXIMUM_KERNEL_FUNCTION_TABLE_SIZE 256

    typedef struct _FUNCTION_TABLE_ENTRY32 {
        u32 FunctionTable;
        u32 ImageBase;
        u32 SizeOfImage;
        u32 SizeOfTable;
    } FUNCTION_TABLE_ENTRY32, *PFUNCTION_TABLE_ENTRY32;

    C_ASSERT(sizeof(FUNCTION_TABLE_ENTRY32) == 0x10);

    typedef struct _FUNCTION_TABLE_ENTRY64 {
        u64 FunctionTable;
        u64 ImageBase;
        u32 SizeOfImage;
        u32 SizeOfTable;
    } FUNCTION_TABLE_ENTRY64, *PFUNCTION_TABLE_ENTRY64;

    C_ASSERT(sizeof(FUNCTION_TABLE_ENTRY64) == 0x18);

    typedef struct _FUNCTION_TABLE {
        u32 CurrentSize;
        u32 MaximumSize;
        u32 Epoch;
        u8 Overflow;
        u32 TableEntry[1];
    } FUNCTION_TABLE, *PFUNCTION_TABLE;

    C_ASSERT(FIELD_OFFSET(FUNCTION_TABLE, TableEntry) == 0x10);

    typedef struct _FUNCTION_TABLE_LEGACY {
        u32 CurrentSize;
        u32 MaximumSize;
        u8 Overflow;
        u32 TableEntry[1];
    } FUNCTION_TABLE_LEGACY, *PFUNCTION_TABLE_LEGACY;

    C_ASSERT(FIELD_OFFSET(FUNCTION_TABLE_LEGACY, TableEntry) == 0xc);

    FORCEINLINE
        u
        NTAPI
        GuardCall(
            __in_opt PGKERNEL_ROUTINE KernelRoutine,
            __in_opt PGSYSTEM_ROUTINE SystemRoutine,
            __in_opt PGRUNDOWN_ROUTINE RundownRoutine,
            __in_opt PGNORMAL_ROUTINE NormalRoutine
        )
    {
        u Result = 0;

        __try {
            if (NULL != KernelRoutine) {
                Result = KernelRoutine(SystemRoutine, RundownRoutine, NormalRoutine);
            }
            else if (NULL != SystemRoutine) {
                Result = SystemRoutine(RundownRoutine, NormalRoutine);
            }
            else if (NULL != RundownRoutine) {
                Result = RundownRoutine(NormalRoutine);
            }
            else if (NULL != NormalRoutine) {
                Result = NormalRoutine();
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            NOTHING;
        }

        return Result;
    }

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_DEVICEDEFS_H_

```

`Include/Warning.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger ( blindtiger@foxmail.com )
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#pragma warning(disable:4015)	// type of bit field must be integral
#pragma warning(disable:4133)	// incompatible types
#pragma warning(disable:4242)	// return type and variable type do not match
#pragma warning(disable:4244)	// conversion' conversion from 'type1' to 'type2', possible loss of data
#pragma warning(disable:4090)	// different 'const' qualifiers
#pragma warning(disable:4391)	// incorrect return type for intrinsic function
#pragma warning(disable:4091)	// 'typedef ': ignored on left of xxx when no variable is declared
#pragma warning(disable:4330)   // attribute 'write' for section xxx ignored

```

`Include/dump.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _DUMP_H_
#define _DUMP_H_

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

#define USERMODE_CRASHDUMP_SIGNATURE    'RESU'
#define USERMODE_CRASHDUMP_VALID_DUMP32 'PMUD'
#define USERMODE_CRASHDUMP_VALID_DUMP64 '46UD'

    //
    // usermode crash dump data types
    //
#define DMP_EXCEPTION                 1 // obsolete
#define DMP_MEMORY_BASIC_INFORMATION  2
#define DMP_THREAD_CONTEXT            3
#define DMP_MODULE                    4
#define DMP_MEMORY_DATA               5
#define DMP_DEBUG_EVENT               6
#define DMP_THREAD_STATE              7
#define DMP_DUMP_FILE_HANDLE          8

    //
    // Define the information required to process memory dumps.
    //

    typedef enum _DUMP_TYPES {
        DUMP_TYPE_INVALID = -1,
        DUMP_TYPE_UNKNOWN = 0,
        DUMP_TYPE_FULL = 1,
        DUMP_TYPE_SUMMARY = 2,
        DUMP_TYPE_HEADER = 3,
        DUMP_TYPE_TRIAGE = 4,
    } DUMP_TYPE;

    //
    // Signature and Valid fields.
    //

#define DUMP_SIGNATURE32   ('EGAP')
#define DUMP_VALID_DUMP32  ('PMUD')

#define DUMP_SIGNATURE64   ('EGAP')
#define DUMP_VALID_DUMP64  ('46UD')

#define DUMP_SUMMARY_SIGNATURE  ('PMDS')
#define DUMP_SUMMARY_VALID      ('PMUD')

#define DUMP_SUMMARY_VALID_KERNEL_VA                     (1)
#define DUMP_SUMMARY_VALID_CURRENT_USER_VA               (2)

    //
    // Define the dump header structure. You cannot change these
    // defines without breaking the debuggers, so don't.
    //

#define DMP_PHYSICAL_MEMORY_BLOCK_SIZE_32   (700)
#define DMP_CONTEXT_RECORD_SIZE_32          (1200)
#define DMP_RESERVED_0_SIZE_32              (1768)
#define DMP_RESERVED_2_SIZE_32              (16)
#define DMP_RESERVED_3_SIZE_32              (56)

#define DMP_PHYSICAL_MEMORY_BLOCK_SIZE_64   (700)
#define DMP_CONTEXT_RECORD_SIZE_64          (3000)
#define DMP_RESERVED_0_SIZE_64              (4016)

#define DMP_HEADER_COMMENT_SIZE             (128)

    // Unset WriterStatus value from the header fill.
#define DUMP_WRITER_STATUS_UNINITIALIZED    DUMP_SIGNATURE32

    // WriterStatus codes for the dbgeng.dll dump writers.
    enum {
        DUMP_DBGENG_SUCCESS,
        DUMP_DBGENG_NO_MODULE_LIST,
        DUMP_DBGENG_CORRUPT_MODULE_LIST,
    };

#ifndef _WIN64
#define DUMP_BLOCK_SIZE 0x20000
#else
#define DUMP_BLOCK_SIZE 0x40000
#endif // !_WIN64

#ifdef NTOS_KERNEL_RUNTIME
#define NOEXTAPI
#endif // NTOS_KERNEL_RUNTIME

#include <wdbgexts.h>

    typedef struct _KDDEBUGGER_DATA_ADDITION64 {

        // Longhorn addition

        ULONG64   VfCrashDataBlock;
        ULONG64   MmBadPagesDetected;
        ULONG64   MmZeroedPageSingleBitErrorsDetected;

        // Windows 7 addition

        ULONG64   EtwpDebuggerData;
        USHORT    OffsetPrcbContext;

        // Windows 8 addition

        USHORT    OffsetPrcbMaxBreakpoints;
        USHORT    OffsetPrcbMaxWatchpoints;

        ULONG     OffsetKThreadStackLimit;
        ULONG     OffsetKThreadStackBase;
        ULONG     OffsetKThreadQueueListEntry;
        ULONG     OffsetEThreadIrpList;

        USHORT    OffsetPrcbIdleThread;
        USHORT    OffsetPrcbNormalDpcState;
        USHORT    OffsetPrcbDpcStack;
        USHORT    OffsetPrcbIsrStack;

        USHORT    SizeKDPC_STACK_FRAME;

        // Windows 8.1 Addition

        USHORT    OffsetKPriQueueThreadListHead;
        USHORT    OffsetKThreadWaitReason;

        // Windows 10 RS1 Addition

        USHORT    Padding;
        ULONG64   PteBase;

        // Windows 10 RS5 Addition

        ULONG64 RetpolineStubFunctionTable;
        ULONG RetpolineStubFunctionTableSize;
        ULONG RetpolineStubOffset;
        ULONG RetpolineStubSize;

    }KDDEBUGGER_DATA_ADDITION64, *PKDDEBUGGER_DATA_ADDITION64;

    typedef struct _DUMP_HEADER {
        ULONG Signature;
        ULONG ValidDump;
        ULONG MajorVersion;
        ULONG MinorVersion;
        ULONG_PTR DirectoryTableBase;
        ULONG_PTR PfnDataBase;
        PLIST_ENTRY PsLoadedModuleList;
        PLIST_ENTRY PsActiveProcessHead;
        ULONG MachineImageType;
        ULONG NumberProcessors;
        ULONG BugCheckCode;
        ULONG_PTR BugCheckParameter1;
        ULONG_PTR BugCheckParameter2;
        ULONG_PTR BugCheckParameter3;
        ULONG_PTR BugCheckParameter4;
        CHAR VersionUser[32];

#ifndef _WIN64
        ULONG PaeEnabled;
#endif // !_WIN64

        struct _KDDEBUGGER_DATA64 * KdDebuggerDataBlock;
    } DUMP_HEADER, *PDUMP_HEADER;

#ifndef _WIN64
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, Signature) == 0);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, ValidDump) == 4);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, MajorVersion) == 8);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, MinorVersion) == 0xc);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, DirectoryTableBase) == 0x10);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, PfnDataBase) == 0x14);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, PsLoadedModuleList) == 0x18);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, PsActiveProcessHead) == 0x1c);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, MachineImageType) == 0x20);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, NumberProcessors) == 0x24);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckCode) == 0x28);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckParameter1) == 0x2c);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckParameter2) == 0x30);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckParameter3) == 0x34);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckParameter4) == 0x38);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, PaeEnabled) == 92);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, KdDebuggerDataBlock) == 96);
#else
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, Signature) == 0);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, ValidDump) == 4);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, MajorVersion) == 8);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, MinorVersion) == 0xc);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, DirectoryTableBase) == 0x10);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, PfnDataBase) == 0x18);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, PsLoadedModuleList) == 0x20);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, PsActiveProcessHead) == 0x28);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, MachineImageType) == 0x30);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, NumberProcessors) == 0x34);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckCode) == 0x38);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckParameter1) == 0x40);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckParameter2) == 0x48);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckParameter3) == 0x50);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, BugCheckParameter4) == 0x58);
    C_ASSERT(FIELD_OFFSET(DUMP_HEADER, KdDebuggerDataBlock) == 0x80);
#endif // !_WIN64

#ifndef _WIN64
#define KDDEBUGGER_DATA_OFFSET 0x1068
#else
#define KDDEBUGGER_DATA_OFFSET 0x2080
#endif // !_WIN64

#ifdef NTOS_KERNEL_RUNTIME
    ULONG
        NTAPI
        KeCapturePersistentThreadState(
            __in PCONTEXT Context,
            __in_opt PKTHREAD Thread,
            __in ULONG BugCheckCode,
            __in ULONG_PTR BugCheckParameter1,
            __in ULONG_PTR BugCheckParameter2,
            __in ULONG_PTR BugCheckParameter3,
            __in ULONG_PTR BugCheckParameter4,
            __in PDUMP_HEADER DumpHeader
        );
#endif // NTOS_KERNEL_RUNTIME

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_DUMP_H_

```

`Include/guarddefs.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _GUARDDEFS_H_
#define _GUARDDEFS_H_

#include <typesdefs.h>

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

#ifndef __rva_to_va_ex
#define __rva_to_va_ex(p, offset) \
            ((ptr)((s8ptr)(p) + *(s32ptr)(p) + sizeof(s32) + (offset)))
#endif // !__rva_to_va_ex

#ifndef __rva_to_va
#define __rva_to_va(p) __rva_to_va_ex((p), 0)
#endif // !__rva_to_va

#define JUMP_SELF 0x0000feebUI32

    typedef struct  _PATCH_HEADER {
        u Length;
        ptr Entry;
        ptr ProgramCounter;
        ptr Target;
    }PATCH_HEADER, *PPATCH_HEADER;

#define RETURN_CODE32 "\xc3"
#define RETURN_CODE32_LENGTH (sizeof(RETURN_CODE32) - 1)

#define RETURN_CODE64 "\xc3"
#define RETURN_CODE64_LENGTH (sizeof(RETURN_CODE64) - 1)

#ifndef _WIN64
#define RETURN_CODE RETURN_CODE32
#define RETURN_CODE_LENGTH RETURN_CODE32_LENGTH
#else
#define RETURN_CODE RETURN_CODE64
#define RETURN_CODE_LENGTH RETURN_CODE64_LENGTH
#endif // !_WIN64

#define COUNTER_BODY_CODE32 "\x68\xff\xff\xff\xff"
#define COUNTER_BODY_CODE32_LENGTH (sizeof(COUNTER_BODY_CODE32) - 1)

#define COUNTER_BODY_CODE64 "\x68\xff\xff\xff\xff\xc7\x44\x24\x04\xff\xff\xff\xff"
#define COUNTER_BODY_CODE64_LENGTH (sizeof(COUNTER_BODY_CODE64) - 1)

#ifndef _WIN64
#define COUNTER_BODY_CODE COUNTER_BODY_CODE32
#define COUNTER_BODY_CODE_LENGTH COUNTER_BODY_CODE32_LENGTH
#else
#define COUNTER_BODY_CODE COUNTER_BODY_CODE64
#define COUNTER_BODY_CODE_LENGTH COUNTER_BODY_CODE64_LENGTH
#endif // !_WIN64

    typedef struct _COUNTER_BODY {
        u8 Push[1];
        u8 Address[4];

#ifdef _WIN64
        u8 Move[4];
        u8 AddressExtend[4];
#endif // _WIN64
    }COUNTER_BODY, *PCOUNTER_BODY;

#ifndef _WIN64
#define SetCounterBody(body, address) \
            *(s32ptr)(body)->Address = *(s32ptr)&(address), \
            (body)->Push[0] = 0x68

#define GetCounterBody(body, address) \
           *(s32ptr)(address) = *(s32ptr)(body)->Address
#else
#define SetCounterBody(body, address) \
            *(s32ptr)(body)->Address = *(s32ptr)&(address), \
            *(s32ptr)(body)->AddressExtend = *((s32ptr)&(address) + 1), \
            (body)->Move[0] = 0xc7, \
            (body)->Move[1] = 0x44, \
            (body)->Move[2] = 0x24, \
            (body)->Move[3] = 0x04, \
            (body)->Push[0] = 0x68

#define GetCounterBody(body, address) \
           *(s32ptr)(address) = *(s32ptr)(body)->Address, \
           *((s32ptr)(address) + 1) = *(s32ptr)(body)->AddressExtend
#endif // !_WIN64

#define SetReturnCode(ret) \
            RtlCopyMemory((ret), RETURN_CODE, RETURN_CODE_LENGTH)

#ifndef _WIN64
#define HOTPATCH_MASK "\x8b\xff"
#define HOTPATCH_MASK_LENGTH (sizeof(HOTPATCH_MASK) - 1)

#define HOTPATCH_BODY_CODE "\xe9\xff\xff\xff\xff\xeb\xf9"
#define HOTPATCH_BODY_CODE_LENGTH (sizeof(HOTPATCH_BODY_CODE) - 1)

    typedef struct _HOTPATCH_BODY {
        u8 Jmp[1];
        u8 Hotpatch[4];
        u8 JmpSelf[2];
    }HOTPATCH_BODY, *PHOTPATCH_BODY;

    C_ASSERT(sizeof(HOTPATCH_BODY) == HOTPATCH_BODY_CODE_LENGTH);

    ////////////////////////////////
    //
    // hotpatch header
    //
    ////////////////////////////////

    typedef struct  _HOTPATCH_OBJECT {
        PATCH_HEADER Header;
    }HOTPATCH_OBJECT, *PHOTPATCH_OBJECT;
#endif // !_WIN64

#define GUARD_BODY_CODE32 "\x68\xff\xff\xff\xff\xc3"
#define GUARD_BODY_CODE32_LENGTH (sizeof(GUARD_BODY_CODE32) - 1)

#define GUARD_BODY_CODE64 "\x68\xff\xff\xff\xff\xc7\x44\x24\x04\xff\xff\xff\xff\xc3"
#define GUARD_BODY_CODE64_LENGTH (sizeof(GUARD_BODY_CODE64) - 1)

#ifndef _WIN64
#define GUARD_BODY_CODE GUARD_BODY_CODE32
#define GUARD_BODY_CODE_LENGTH GUARD_BODY_CODE32_LENGTH
#else
#define GUARD_BODY_CODE GUARD_BODY_CODE64
#define GUARD_BODY_CODE_LENGTH GUARD_BODY_CODE64_LENGTH
#endif // !_WIN64

    typedef struct _GUARD_BODY {
        COUNTER_BODY Guard;
        u8 Ret[1];
    }GUARD_BODY, *PGUARD_BODY;

#ifndef _WIN64
    C_ASSERT(sizeof(GUARD_BODY) == GUARD_BODY_CODE32_LENGTH);
#else
    C_ASSERT(sizeof(GUARD_BODY) == GUARD_BODY_CODE64_LENGTH);
#endif // !_WIN64

#define SetGuardBody(body, address) \
            SetCounterBody(&(body)->Guard,(address)), \
            SetReturnCode(&(body)->Ret)

    ////////////////////////////////
    //
    // patch header
    // original
    // code
    // import
    //
    ////////////////////////////////

    typedef struct  _GUARD_OBJECT {
        PATCH_HEADER Header;

        ptr Original;
        u32 Length;
    }GUARD_OBJECT, *PGUARD_OBJECT;

    ////////////////////////////////
    //
    // stack header
    // stack code
    // original
    // code
    //
    ////////////////////////////////

    typedef
        void
        (NTAPI * PGUARD_CALLBACK)(
            __in PCONTEXT Context,
            __in_opt ptr ProgramCounter,
            __in_opt ptr Parameter,
            __in_opt ptr Reserved
            );

#ifndef _WIN64
#define GuardReturn(context) (*(uptr)__utop((context)->Esp))
#define GuardArgv(context, index) (*(uptr)__utop((context)->Esp + 4 + 4 * (index)))
#else
#define GuardReturn(context) (*(uptr)(context)->Rsp)
#define GuardArgv(context, index) \
            0 == (index) ? (context)->Rcx : \
            (1 == (index) ? (context)->Rdx : \
            (2 == (index) ? (context)->R8 : \
            (3 == (index) ? (context)->R9 : \
            (*(uptr)((context)->Rsp + 8 + 8 * (index))))))
#endif // !_WIN64

    typedef struct  _SAFEGUARD_BODY {
        COUNTER_BODY Reserved; // reserved
        COUNTER_BODY Parameter; // parameter
        COUNTER_BODY Callback; // filter
        COUNTER_BODY Guard; // guard code
        COUNTER_BODY ProgramCounter; // original address
        COUNTER_BODY CaptureContext; // capture context
        u8 Ret[1];
    }SAFEGUARD_BODY, *PSAFEGUARD_BODY;

#ifndef _WIN64
    C_ASSERT(sizeof(SAFEGUARD_BODY) == 6 * COUNTER_BODY_CODE32_LENGTH + 1);
#else
    C_ASSERT(sizeof(SAFEGUARD_BODY) == 6 * COUNTER_BODY_CODE64_LENGTH + 1);
#endif // !_WIN64

#define SetStackBody( \
            body, reserved, parameter, callback, guard, programcounter, capturecontext) \
                SetCounterBody(&((PSAFEGUARD_BODY)(body))->Reserved, (reserved)), \
                SetCounterBody(&((PSAFEGUARD_BODY)(body))->Parameter, (parameter)), \
                SetCounterBody(&((PSAFEGUARD_BODY)(body))->Callback, (callback)), \
                SetCounterBody(&((PSAFEGUARD_BODY)(body))->Guard, (guard)), \
                SetCounterBody(&((PSAFEGUARD_BODY)(body))->ProgramCounter, (programcounter)), \
                SetCounterBody(&((PSAFEGUARD_BODY)(body))->CaptureContext, (capturecontext)), \
                SetReturnCode(&((PSAFEGUARD_BODY)(body))->Ret)

    typedef struct  _SAFEGUARD_OBJECT {
        PATCH_HEADER Header;

        ptr Original;
        u32 Length;

        SAFEGUARD_BODY Body;
    }SAFEGUARD_OBJECT, *PSAFEGUARD_OBJECT;

#if defined(DETOURS_X86)
#elif defined(DETOURS_X64)
#elif defined(DETOURS_IA64)
#elif defined(DETOURS_ARM)
#else
#error Must define one of DETOURS_X86, DETOURS_X64, DETOURS_IA64, or DETOURS_ARM
#endif

    u32
        NTAPI
        DetourGetInstructionLength(
            __in ptr ControlPc
        );

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_GUARDDEFS_H_

```

`Include/listdefs.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _LISTDEFS_H_
#define _LISTDEFS_H_

#include <typesdefs.h>

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

    typedef struct _list {
        struct _list * front;
        struct _list * back;
    } list;

#define __is_list_empty(head) \
            ((head)->front == (head))

    __inline
        void
        __empty_list(
            list * head
        )
    {
        head->front = head->back = head;
    }

    __inline
        u8
        __remove_node(
            list * node
        )
    {
        list * back;
        list * front;

        front = node->front;
        back = node->back;
        back->front = front;
        front->back = back;

        return (u8)(front == back);
    }

    __inline
        void
        __insert_head(
            list * head,
            list * node
        )
    {
        list * front;

        front = head->front;

        node->front = front;
        node->back = head;

        head->front = node;
        front->back = node;
    }

    __inline
        list *
        __remove_head(
            list * head
        )
    {
        list * front;
        list * node;

        node = head->front;
        front = node->front;
        head->front = front;
        front->back = head;

        return node;
    }

    __inline
        void
        __insert_tail(
            list * head,
            list * node
        )
    {
        list * back;

        back = head->back;

        node->front = head;
        node->back = back;

        back->front = node;
        head->back = node;
    }

    __inline
        list *
        __remove_tail(
            list * head
        )
    {
        list * back;
        list * node;

        node = head->back;
        back = node->back;
        head->back = back;
        back->front = head;

        return node;
    }

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_LISTDEFS_H_

```

`Include/statusdefs.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRAY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _STATUSDEFS_H_
#define _STATUSDEFS_H_

#include <typesdefs.h>

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

    //
    // STATUS
    //

    typedef s32 status;

    /*lint -save -e624 */  // Don't complain about different typedefs.
    /*lint -restore */  // Resume checking for different typedefs.

    //
    //  st values are 32 bit values layed out as follows:
    //
    //   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
    //   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    //  +---+-+-------------------------+-------------------------------+
    //  |Sev|C|       Facility          |               Code            |
    //  +---+-+-------------------------+-------------------------------+
    //
    //  where
    //
    //      Sev - is the severity code
    //
    //          00 - Success
    //          01 - Informational
    //          10 - Warning
    //          11 - Error
    //
    //      C - is the Customer code flag
    //
    //      Facility - is the facility code
    //
    //      Code - is the facility's status code
    //

    //
    // Generic test for success on any status value (non-negative numbers
    // indicate success).
    //

#define ST_SUCCESS(st) ((s32)(st) >= 0)

//
// Generic test for information on any status value.
//

#define ST_INFORMATION(st) ((u32)(st) >> 30 == 1)

//
// Generic test for warning on any status value.
//

#define ST_WARNING(st) ((u32)(st) >> 30 == 2)

//
// Generic test for error on any status value.
//

#define ST_ERROR(st) ((u32)(st) >> 30 == 3)

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_STATUSDEFS_H_

```

`Include/supdefs.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _SUPDEFS_H_
#define _SUPDEFS_H_

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

    /** Internal error - we're screwed if this happens. */
#define ERR_INTERNAL_ERROR (-32)

/*******************************************************************************
* Defined Constants And Macros *
*******************************************************************************/
/** The support service name. */
#define ServiceString L"VBoxDrv"
/** NT Device name. */
#define DeviceString L"\\Device\\VBoxDrv"
/** Win Symlink name. */
#define SymbolicString L"\\DosDevices\\VBoxDrv"
/** soft registry. */
#define RegistryString L"\\Registry\\Machine\\Software\\Oracle\\VirtualBox"

/*
* IOCtl numbers.
* We're using the Win32 type of numbers here, thus the macros below.
* The SUP_IOCTL_FLAG macro is used to separate requests from 32-bit
* and 64-bit processes.
*/
#ifndef _WIN64 
# define SUP_IOCTL_FLAG 0
#else 
# define SUP_IOCTL_FLAG 128
#endif // !_WIN64

/* Automatic buffering, size not encoded. */
# define SUP_CTL_CODE_SIZE(Function, Size) \
CTL_CODE(FILE_DEVICE_UNKNOWN, (Function) | SUP_IOCTL_FLAG, METHOD_BUFFERED, FILE_WRITE_ACCESS)
# define SUP_CTL_CODE_BIG(Function) \
CTL_CODE(FILE_DEVICE_UNKNOWN, (Function) | SUP_IOCTL_FLAG, METHOD_BUFFERED, FILE_WRITE_ACCESS)
# define SUP_CTL_CODE_FAST(Function) \
CTL_CODE(FILE_DEVICE_UNKNOWN, (Function) | SUP_IOCTL_FLAG, METHOD_NEITHER, FILE_WRITE_ACCESS)
# define SUP_CTL_CODE_NO_SIZE(uIOCtl) (uIOCtl)

/** Fast path IOCtl: VMMR0_DO_RAW_RUN */
#define SUP_IOCTL_FAST_DO_RAW_RUN SUP_CTL_CODE_FAST(64)
/** Fast path IOCtl: VMMR0_DO_HWACC_RUN */
#define SUP_IOCTL_FAST_DO_HWACC_RUN SUP_CTL_CODE_FAST(65)
/** Just a NOP call for profiling the latency of a fast ioctl call to VMMR0. */
#define SUP_IOCTL_FAST_DO_NOP SUP_CTL_CODE_FAST(66)

/*******************************************************************************
* Structures and Typedefs *
*******************************************************************************/
#ifndef _WIN64 
# pragma pack(4) /* paranoia. */
#else 
# pragma pack(8) /* paranoia. */
#endif // !_WIN64

/**
* The paging mode.
*/
    typedef enum _SUPPAGINGMODE {
        /** The usual invalid entry.
        * This is returned by SUPGetPagingMode() */
        SUPPAGINGMODE_INVALID = 0,
        /** Normal 32-bit paging, no global pages */
        SUPPAGINGMODE_32_BIT,
        /** Normal 32-bit paging with global pages. */
        SUPPAGINGMODE_32_BIT_GLOBAL,
        /** PAE mode, no global pages, no NX. */
        SUPPAGINGMODE_PAE,
        /** PAE mode with global pages. */
        SUPPAGINGMODE_PAE_GLOBAL,
        /** PAE mode with NX, no global pages. */
        SUPPAGINGMODE_PAE_NX,
        /** PAE mode with global pages and NX. */
        SUPPAGINGMODE_PAE_GLOBAL_NX,
        /** AMD64 mode, no global pages. */
        SUPPAGINGMODE_AMD64,
        /** AMD64 mode with global pages, no NX. */
        SUPPAGINGMODE_AMD64_GLOBAL,
        /** AMD64 mode with NX, no global pages. */
        SUPPAGINGMODE_AMD64_NX,
        /** AMD64 mode with global pages and NX. */
        SUPPAGINGMODE_AMD64_GLOBAL_NX
    } SUPPAGINGMODE;

    /**
    * Common In/Out header.
    */
    typedef struct _SUPREQHDR {
        /** Cookie. */
        u32 u32Cookie;
        /** Session cookie. */
        u32 u32SessionCookie;
        /** The size of the input. */
        u32 cbIn;
        /** The size of the output. */
        u32 cbOut;
        /** Flags. See SUPREQHDR_FLAGS_* for details and values. */
        u32 fFlags;
        /** The VBox status code of the operation, out direction only. */
        s32 rc;
    } SUPREQHDR, *PSUPREQHDR;

    /** @name SUPREQHDR::fFlags values
    * @{ */
    /** Masks out the magic value. */
#define SUPREQHDR_FLAGS_MAGIC_MASK u32c(0xff0000ff)
/** The generic mask. */
#define SUPREQHDR_FLAGS_GEN_MASK u32c(0x0000ff00)
/** The request specific mask. */
#define SUPREQHDR_FLAGS_REQ_MASK u32c(0x00ff0000)

/** There is extra input that needs copying on some platforms. */
#define SUPREQHDR_FLAGS_EXTRA_IN u32c(0x00000100)
/** There is extra output that needs copying on some platforms. */
#define SUPREQHDR_FLAGS_EXTRA_OUT u32c(0x00000200)

/** The magic value. */
#define SUPREQHDR_FLAGS_MAGIC u32c(0x42000042)
/** The default value. Use this when no special stuff is requested. */
#define SUPREQHDR_FLAGS_DEFAULT SUPREQHDR_FLAGS_MAGIC
/** @} */

/** @name SUP_IOCTL_COOKIE
* @{
*/
/** The request size. */
#define SUP_IOCTL_COOKIE_SIZE sizeof(SUPCOOKIE)
/** Negotiate cookie. */
#define SUP_IOCTL_COOKIE SUP_CTL_CODE_SIZE(1, SUP_IOCTL_COOKIE_SIZE)
/** The SUPREQHDR::cbIn value. */
#define SUP_IOCTL_COOKIE_SIZE_IN sizeof(SUPREQHDR) + RTL_FIELD_SIZE(SUPCOOKIE, u.In)
/** The SUPREQHDR::cbOut value. */
#define SUP_IOCTL_COOKIE_SIZE_OUT sizeof(SUPREQHDR) + RTL_FIELD_SIZE(SUPCOOKIE, u.Out)
/** SUPCOOKIE_IN magic word. */
#define SUPCOOKIE_MAGIC "The Magic Word!"
/** The initial cookie. */
#define SUPCOOKIE_INITIAL_COOKIE 0x69726f74 /* 'tori' */

/** Current interface version.
* The upper 16-bit is the major version, the the lower the minor version.
* When incompatible changes are made, the upper major number has to be changed. */
#define SUPDRVIOC_VERSION 0x00070002

/** SUP_IOCTL_COOKIE. */
    typedef struct _SUPCOOKIE {
        /** The header.
        * u32Cookie must be set to SUPCOOKIE_INITIAL_COOKIE.
        * u32SessionCookie should be set to some random value. */
        SUPREQHDR Hdr;

        union {
            struct {
                /** Magic word. */
                char szMagic[16];
                /** The requested interface version number. */
                u32 u32ReqVersion;
                /** The minimum interface version number. */
                u32 u32MinVersion;
            } In;

            struct {
                /** Cookie. */
                u32 u32Cookie;
                /** Session cookie. */
                u32 u32SessionCookie;
                /** Interface version for this session. */
                u32 u32SessionVersion;
                /** The actual interface version in the driver. */
                u32 u32DriverVersion;
                /** Number of functions available for the SUP_IOCTL_QUERY_FUNCS request. */
                u32 cFunctions;
                /** Session handle. */
                ptr pSession;
            } Out;
        } u;
    } SUPCOOKIE, *PSUPCOOKIE;
    /** @} */

    /** @name SUP_IOCTL_QUERY_FUNCS
    * Query SUPR0 functions.
    * @{
    */
#define SUP_IOCTL_QUERY_FUNCS_SIZE(cFuncs) FIELD_OFFSET(SUPQUERYFUNCS, u.Out.aFunctions[(cFuncs)])
#define SUP_IOCTL_QUERY_FUNCS(cFuncs) SUP_CTL_CODE_SIZE(2, SUP_IOCTL_QUERY_FUNCS_SIZE(cFuncs))
#define SUP_IOCTL_QUERY_FUNCS_SIZE_IN sizeof(SUPREQHDR)
#define SUP_IOCTL_QUERY_FUNCS_SIZE_OUT(cFuncs) SUP_IOCTL_QUERY_FUNCS_SIZE(cFuncs)

    /** A function. */
    typedef struct SUPFUNC {
        /** Name - mangled. */
        char szName[32];
        /** Address. */
        ptr pfn;
    } SUPFUNC, *PSUPFUNC;

    typedef struct SUPQUERYFUNCS {
        /** The header. */
        SUPREQHDR Hdr;

        union {
            struct {
                /** Number of functions returned. */
                u32 cFunctions;
                /** Array of functions. */
                SUPFUNC aFunctions[1];
            } Out;
        } u;
    } SUPQUERYFUNCS, *PSUPQUERYFUNCS;
    /** @} */

    /** @name SUP_IOCTL_IDT_INSTALL
    * Install IDT patch for calling processor.
    * @{
    */
#define SUP_IOCTL_IDT_INSTALL_SIZE sizeof(SUPIDTINSTALL)
#define SUP_IOCTL_IDT_INSTALL SUP_CTL_CODE_SIZE(3, SUP_IOCTL_IDT_INSTALL_SIZE)
#define SUP_IOCTL_IDT_INSTALL_SIZE_IN sizeof(SUPREQHDR)
#define SUP_IOCTL_IDT_INSTALL_SIZE_OUT sizeof(SUPIDTINSTALL)

    typedef struct SUPIDTINSTALL {
        /** The header. */
        SUPREQHDR Hdr;

        union {
            struct {
                /** The IDT entry number. */
                u8 u8Idt;
            } Out;
        } u;
    } SUPIDTINSTALL, *PSUPIDTINSTALL;
    /** @} */

    /** @name SUP_IOCTL_IDT_REMOVE
    * Remove IDT patch for calling processor.
    * @{
    */
#define SUP_IOCTL_IDT_REMOVE_SIZE sizeof(SUPIDTREMOVE)
#define SUP_IOCTL_IDT_REMOVE SUP_CTL_CODE_SIZE(4, SUP_IOCTL_IDT_REMOVE_SIZE)
#define SUP_IOCTL_IDT_REMOVE_SIZE_IN sizeof(SUPIDTREMOVE)
#define SUP_IOCTL_IDT_REMOVE_SIZE_OUT sizeof(SUPIDTREMOVE)

    typedef struct SUPIDTREMOVE {
        /** The header. */
        SUPREQHDR Hdr;
    } SUPIDTREMOVE, *PSUPIDTREMOVE;
    /** @}*/

    /** @name SUP_IOCTL_LDR_OPEN
    * Open an image.
    * @{
    */
#define SUP_IOCTL_LDR_OPEN_SIZE sizeof(SUPLDROPEN)
#define SUP_IOCTL_LDR_OPEN SUP_CTL_CODE_SIZE(5, SUP_IOCTL_LDR_OPEN_SIZE)
#define SUP_IOCTL_LDR_OPEN_SIZE_IN sizeof(SUPLDROPEN)
#define SUP_IOCTL_LDR_OPEN_SIZE_OUT (sizeof(SUPREQHDR) + RTL_FIELD_SIZE(SUPLDROPEN, u.Out))

    typedef struct _SUPLDROPEN {
        /** The header. */
        SUPREQHDR Hdr;

        union {
            struct {
                /** Size of the image we'll be loading. */
                u32 cbImage;
                /** Image name.
                * This is the NAME of the image, not the file name. It is used
                * to share code with other processes. (Max len is 32 chars!) */
                c szName[32];
            } In;

            struct {
                /** The base address of the image. */
                ptr pvImageBase;
                /** Indicate whether or not the image requires loading. */
                b fNeedsLoading;
            } Out;
        } u;
    } SUPLDROPEN, *PSUPLDROPEN;
    /** @} */

    /** @name SUP_IOCTL_LDR_LOAD
    * Upload the image bits.
    * @{
    */
#define SUP_IOCTL_LDR_LOAD SUP_CTL_CODE_BIG(6)
#define SUP_IOCTL_LDR_LOAD_SIZE(cbImage) FIELD_OFFSET(SUPLDRLOAD, u.In.achImage[cbImage])
#define SUP_IOCTL_LDR_LOAD_SIZE_IN(cbImage) FIELD_OFFSET(SUPLDRLOAD, u.In.achImage[cbImage])
#define SUP_IOCTL_LDR_LOAD_SIZE_OUT sizeof(SUPREQHDR)

    /**
    * Symbol table entry.
    */
    typedef struct _SUPLDRSYM {
        /** Offset into of the string table. */
        u32 offName;
        /** Offset of the symbol relative to the image load address. */
        u32 offSymbol;
    } SUPLDRSYM, *PSUPLDRSYM;

    /**
    * SUPLDRLOAD::u::In::EP type.
    */
    typedef enum _SUPLDRLOADEP {
        SUPLDRLOADEP_NOTHING = 0,
        SUPLDRLOADEP_VMMR0,
        SUPLDRLOADEP_32BIT_HACK = 0x7fffffff
    } SUPLDRLOADEP;

    typedef struct _SUPLDRLOAD {
        /** The header. */
        SUPREQHDR Hdr;

        union {
            struct {
                /** The address of module initialization function. Similar to _DLL_InitTerm(hmod, 0). */
                ptr pfnModuleInit;
                /** The address of module termination function. Similar to _DLL_InitTerm(hmod, 1). */
                ptr pfnModuleTerm;
                /** Special entry points. */

                union {
                    struct {
                        /** The module handle (i.e. address). */
                        ptr pvVMMR0;
                        /** Address of VMMR0EntryInt function. */
                        ptr pvVMMR0EntryInt;
                        /** Address of VMMR0EntryFast function. */
                        ptr pvVMMR0EntryFast;
                        /** Address of VMMR0EntryEx function. */
                        ptr pvVMMR0EntryEx;
                    } VMMR0;
                } EP;

                /** Address. */
                ptr pvImageBase;
                /** Entry point type. */
                SUPLDRLOADEP eEPType;
                /** The offset of the symbol table. */
                u32 offSymbols;
                /** The number of entries in the symbol table. */
                u32 cSymbols;
                /** The offset of the string table. */
                u32 offStrTab;
                /** Size of the string table. */
                u32 cbStrTab;
                /** Size of image (including string and symbol tables). */
                u32 cbImage;
                /** The image data. */
                c achImage[1];
            } In;
        } u;
    } SUPLDRLOAD, *PSUPLDRLOAD;
    /** @} */

    /** @name SUP_IOCTL_LDR_FREE
    * Free an image.
    * @{
    */
#define SUP_IOCTL_LDR_FREE_SIZE sizeof(SUPLDRFREE)
#define SUP_IOCTL_LDR_FREE SUP_CTL_CODE_SIZE(7, SUP_IOCTL_LDR_FREE_SIZE)
#define SUP_IOCTL_LDR_FREE_SIZE_IN sizeof(SUPLDRFREE)
#define SUP_IOCTL_LDR_FREE_SIZE_OUT sizeof(SUPREQHDR)

    typedef struct _SUPLDRFREE {
        /** The header. */
        SUPREQHDR Hdr;

        union {
            struct {
                /** Address. */
                ptr pvImageBase;
            } In;
        } u;
    } SUPLDRFREE, *PSUPLDRFREE;
    /** @} */

    /** @name SUP_IOCTL_LDR_GET_SYMBOL
    * Get address of a symbol within an image.
    * @{
    */
#define SUP_IOCTL_LDR_GET_SYMBOL_SIZE sizeof(SUPLDRGETSYMBOL)
#define SUP_IOCTL_LDR_GET_SYMBOL SUP_CTL_CODE_SIZE(8, SUP_IOCTL_LDR_GET_SYMBOL_SIZE)
#define SUP_IOCTL_LDR_GET_SYMBOL_SIZE_IN sizeof(SUPLDRGETSYMBOL)
#define SUP_IOCTL_LDR_GET_SYMBOL_SIZE_OUT (sizeof(SUPREQHDR) + RTL_FIELD_SIZE(SUPLDRGETSYMBOL, u.Out))

    typedef struct _SUPLDRGETSYMBOL {
        /** The header. */
        SUPREQHDR Hdr;

        union {
            struct {
                /** Address. */
                ptr pvImageBase;
                /** The symbol name. */
                c szSymbol[64];
            } In;

            struct {
                /** The symbol address. */
                ptr pvSymbol;
            } Out;
        } u;
    } SUPLDRGETSYMBOL, *PSUPLDRGETSYMBOL;
    /** @} */

    /** @name SUP_IOCTL_CALL_VMMR0
    * Call the R0 VMM Entry point.
    *
    * @todo Might have to convert this to a big request...
    * @{
    */
#define SUP_IOCTL_CALL_VMMR0_SIZE(cbReq) FIELD_OFFSET(SUPCALLVMMR0, abReqPkt[cbReq])
#define SUP_IOCTL_CALL_VMMR0(cbReq) SUP_CTL_CODE_SIZE(9, SUP_IOCTL_CALL_VMMR0_SIZE(cbReq))
#define SUP_IOCTL_CALL_VMMR0_SIZE_IN(cbReq) SUP_IOCTL_CALL_VMMR0_SIZE(cbReq)
#define SUP_IOCTL_CALL_VMMR0_SIZE_OUT(cbReq) SUP_IOCTL_CALL_VMMR0_SIZE(cbReq)

    typedef struct SUPCALLVMMR0 {
        /** The header. */
        SUPREQHDR Hdr;

        union {
            struct {
                /** The VM handle. */
                ptr pVMR0;
                /** Which operation to execute. */
                u32 uOperation;
#if R0_ARCH_BITS == 64
                /** Alignment. */
                u32 u32Reserved;
#endif
                /** Argument to use when no request packet is supplied. */
                u64 u64Arg;
            } In;
        } u;
        /** The VMMR0Entry request packet. */
        u8 abReqPkt[1];
    } SUPCALLVMMR0, *PSUPCALLVMMR0;
    /** @} */

    /** @name SUP_IOCTL_LOW_ALLOC
    * Allocate memory below 4GB (physically).
    * @{
    */
#define SUP_IOCTL_LOW_ALLOC SUP_CTL_CODE_BIG(10)
#define SUP_IOCTL_LOW_ALLOC_SIZE(cPages) ((u32)FIELD_OFFSET(SUPLOWALLOC, u.Out.aPages[cPages]))
#define SUP_IOCTL_LOW_ALLOC_SIZE_IN (sizeof(SUPREQHDR) + RTL_FIELD_SIZE(SUPLOWALLOC, u.In))
#define SUP_IOCTL_LOW_ALLOC_SIZE_OUT(cPages) SUP_IOCTL_LOW_ALLOC_SIZE(cPages)

    typedef struct SUPLOWALLOC {
        /** The header. */
        SUPREQHDR Hdr;

        union {
            struct {
                /** Number of pages to allocate. */
                u32 cPages;
            } In;

            struct {
                /** The ring-3 address of the allocated memory. */
                ptr pvR3;
                /** The ring-0 address of the allocated memory. */
                ptr pvR0;
                /** Array of pages. */
                u64 aPages[1];
            } Out;
        } u;
    } SUPLOWALLOC, *PSUPLOWALLOC;
    /** @} */

    /** @name SUP_IOCTL_LOW_FREE
    * Free low memory.
    * @{
    */
#define SUP_IOCTL_LOW_FREE SUP_CTL_CODE_SIZE(11, SUP_IOCTL_LOW_FREE_SIZE)
#define SUP_IOCTL_LOW_FREE_SIZE sizeof(SUPLOWFREE)
#define SUP_IOCTL_LOW_FREE_SIZE_IN sizeof(SUPLOWFREE)
#define SUP_IOCTL_LOW_FREE_SIZE_OUT sizeof(SUPREQHDR)
    typedef struct SUPLOWFREE {
        /** The header. */
        SUPREQHDR Hdr;

        union {
            struct {
                /** The ring-3 address of the memory to free. */
                ptr pvR3;
            } In;
        } u;
    } SUPLOWFREE, *PSUPLOWFREE;
    /** @} */

    /** @name SUP_IOCTL_PAGE_ALLOC
    * Allocate memory and map into the user process.
    * The memory is of course locked.
    * @{
    */
#define SUP_IOCTL_PAGE_ALLOC SUP_CTL_CODE_BIG(12)
#define SUP_IOCTL_PAGE_ALLOC_SIZE(cPages) FIELD_OFFSET(SUPPAGEALLOC, u.Out.aPages[cPages])
#define SUP_IOCTL_PAGE_ALLOC_SIZE_IN (sizeof(SUPREQHDR) + RTL_FIELD_SIZE(SUPPAGEALLOC, u.In))
#define SUP_IOCTL_PAGE_ALLOC_SIZE_OUT(cPages) SUP_IOCTL_PAGE_ALLOC_SIZE(cPages)

    typedef struct SUPPAGEALLOC {
        /** The header. */
        SUPREQHDR Hdr;

        union {
            struct {
                /** Number of pages to allocate */
                u32 cPages;
            } In;

            struct {
                /** Returned ring-3 address. */
                ptr pvR3;
                /** The physical addresses of the allocated pages. */
                u64 aPages[1];
            } Out;
        } u;
    } SUPPAGEALLOC, *PSUPPAGEALLOC;
    /** @} */

    /** @name SUP_IOCTL_PAGE_FREE
    * Free memory allocated with SUP_IOCTL_PAGE_ALLOC.
    * @{
    */
#define SUP_IOCTL_PAGE_FREE_SIZE_IN sizeof(SUPPAGEFREE)
#define SUP_IOCTL_PAGE_FREE SUP_CTL_CODE_SIZE(13, SUP_IOCTL_PAGE_FREE_SIZE_IN)
#define SUP_IOCTL_PAGE_FREE_SIZE sizeof(SUPPAGEFREE)
#define SUP_IOCTL_PAGE_FREE_SIZE_OUT sizeof(SUPREQHDR) 

    typedef struct SUPPAGEFREE {
        /** The header. */
        SUPREQHDR Hdr;

        union {
            struct {
                /** Address of memory range to free. */
                ptr pvR3;
            } In;
        } u;
    } SUPPAGEFREE, *PSUPPAGEFREE;
    /** @} */

    /** @name SUP_IOCTL_PAGE_LOCK
    * Pin down physical pages.
    * @{
    */
#define SUP_IOCTL_PAGE_LOCK SUP_CTL_CODE_BIG(14) 
#define SUP_IOCTL_PAGE_LOCK_SIZE_IN (sizeof(SUPREQHDR) + RTL_FIELD_SIZE(SUPPAGELOCK, u.In))
#define SUP_IOCTL_PAGE_LOCK_SIZE_OUT(cPages) FIELD_OFFSET(SUPPAGELOCK, u.Out.aPages[cPages])
#define SUP_IOCTL_PAGE_LOCK_SIZE(cPages) \
           (__max((size_t)SUP_IOCTL_PAGE_LOCK_SIZE_IN, (size_t)SUP_IOCTL_PAGE_LOCK_SIZE_OUT(cPages)))

    typedef struct SUPPAGELOCK {
        /** The header. */
        SUPREQHDR Hdr;

        union {
            struct {
                /** Start of page range. Must be PAGE aligned. */
                ptr pvR3;
                /** The range size given as a page count. */
                u32 cPages;
            } In;

            struct {
                /** Array of pages. */
                u64 aPages[1];
            } Out;
        } u;
    } SUPPAGELOCK, *PSUPPAGELOCK;
    /** @} */

    /** @name SUP_IOCTL_PAGE_UNLOCK
    * Unpin physical pages.
    * @{ */
#define SUP_IOCTL_PAGE_UNLOCK_SIZE sizeof(SUPPAGEUNLOCK)
#define SUP_IOCTL_PAGE_UNLOCK SUP_CTL_CODE_SIZE(15, SUP_IOCTL_PAGE_UNLOCK_SIZE)
#define SUP_IOCTL_PAGE_UNLOCK_SIZE_IN sizeof(SUPPAGEUNLOCK)
#define SUP_IOCTL_PAGE_UNLOCK_SIZE_OUT sizeof(SUPREQHDR)

    typedef struct SUPPAGEUNLOCK {
        /** The header. */
        SUPREQHDR Hdr;

        union {
            struct {
                /** Start of page range of a range previuosly pinned. */
                ptr pvR3;
            } In;
        } u;
    } SUPPAGEUNLOCK, *PSUPPAGEUNLOCK;
    /** @} */

    /** @name SUP_IOCTL_CONT_ALLOC
    * Allocate contious memory.
    * @{
    */
#define SUP_IOCTL_CONT_ALLOC_SIZE sizeof(SUPCONTALLOC)
#define SUP_IOCTL_CONT_ALLOC SUP_CTL_CODE_SIZE(16, SUP_IOCTL_CONT_ALLOC_SIZE)
#define SUP_IOCTL_CONT_ALLOC_SIZE_IN (sizeof(SUPREQHDR) + RTL_FIELD_SIZE(SUPCONTALLOC, u.In))
#define SUP_IOCTL_CONT_ALLOC_SIZE_OUT sizeof(SUPCONTALLOC)

    typedef struct SUPCONTALLOC {
        /** The header. */
        SUPREQHDR Hdr;

        union {
            struct {
                /** The allocation size given as a page count. */
                u32 cPages;
            } In;

            struct {
                /** The address of the ring-0 mapping of the allocated memory. */
                ptr pvR0;
                /** The address of the ring-3 mapping of the allocated memory. */
                ptr pvR3;
                /** The physical address of the allocation. */
                u64 HCPhys;
            } Out;
        } u;
    } SUPCONTALLOC, *PSUPCONTALLOC;
    /** @} */

    /** @name SUP_IOCTL_CONT_FREE Input.
    * @{
    */
    /** Free contious memory. */
#define SUP_IOCTL_CONT_FREE_SIZE sizeof(SUPCONTFREE)
#define SUP_IOCTL_CONT_FREE SUP_CTL_CODE_SIZE(17, SUP_IOCTL_CONT_FREE_SIZE)
#define SUP_IOCTL_CONT_FREE_SIZE_IN sizeof(SUPCONTFREE)
#define SUP_IOCTL_CONT_FREE_SIZE_OUT sizeof(SUPREQHDR)

    typedef struct SUPCONTFREE {
        /** The header. */
        SUPREQHDR Hdr;

        union {
            struct {
                /** The ring-3 address of the memory to free. */
                ptr pvR3;
            } In;
        } u;
    } SUPCONTFREE, *PSUPCONTFREE;
    /** @} */

    /** @name SUP_IOCTL_GET_PAGING_MODE
    * Get the host paging mode.
    * @{
    */
#define SUP_IOCTL_GET_PAGING_MODE_SIZE sizeof(SUPGETPAGINGMODE)
#define SUP_IOCTL_GET_PAGING_MODE SUP_CTL_CODE_SIZE(18, SUP_IOCTL_GET_PAGING_MODE_SIZE)
#define SUP_IOCTL_GET_PAGING_MODE_SIZE_IN sizeof(SUPREQHDR)
#define SUP_IOCTL_GET_PAGING_MODE_SIZE_OUT sizeof(SUPGETPAGINGMODE)

    typedef struct SUPGETPAGINGMODE {
        /** The header. */
        SUPREQHDR Hdr;

        union {
            struct {
                /** The paging mode. */
                SUPPAGINGMODE enmMode;
            } Out;
        } u;
    } SUPGETPAGINGMODE, *PSUPGETPAGINGMODE;
    /** @} */

    /** @name SUP_IOCTL_SET_VM_FOR_FAST
    * Set the VM handle for doing fast call ioctl calls.
    * @{
    */
#define SUP_IOCTL_SET_VM_FOR_FAST_SIZE sizeof(SUPSETVMFORFAST)
#define SUP_IOCTL_SET_VM_FOR_FAST SUP_CTL_CODE_SIZE(19, SUP_IOCTL_SET_VM_FOR_FAST_SIZE)
#define SUP_IOCTL_SET_VM_FOR_FAST_SIZE_IN sizeof(SUPSETVMFORFAST)
#define SUP_IOCTL_SET_VM_FOR_FAST_SIZE_OUT sizeof(SUPREQHDR)

    typedef struct SUPSETVMFORFAST {
        /** The header. */
        SUPREQHDR Hdr;

        union {
            struct {
                /** The ring-0 VM handle (pointer). */
                ptr pVMR0;
            } In;
        } u;
    } SUPSETVMFORFAST, *PSUPSETVMFORFAST;
    /** @} */

    /** @name SUP_IOCTL_GIP_MAP
    * Map the GIP into user space.
    * @{
    */
#define SUP_IOCTL_GIP_MAP_SIZE sizeof(SUPGIPMAP)
#define SUP_IOCTL_GIP_MAP SUP_CTL_CODE_SIZE(20, SUP_IOCTL_GIP_MAP_SIZE)
#define SUP_IOCTL_GIP_MAP_SIZE_IN sizeof(SUPREQHDR)
#define SUP_IOCTL_GIP_MAP_SIZE_OUT sizeof(SUPGIPMAP)

    typedef struct SUPGIPMAP {
        /** The header. */
        SUPREQHDR Hdr;

        union {
            struct {
                /** The physical address of the GIP. */
                u64 HCPhysGip;
                /** Pointer to the read-only usermode GIP mapping for this session. */
                ptr pGipR3;
                /** Pointer to the supervisor mode GIP mapping. */
                ptr pGipR0;
            } Out;
        } u;
    } SUPGIPMAP, *PSUPGIPMAP;
    /** @} */

    /** @name SUP_IOCTL_GIP_UNMAP
    * Unmap the GIP.
    * @{
    */
#define SUP_IOCTL_GIP_UNMAP_SIZE sizeof(SUPGIPUNMAP)
#define SUP_IOCTL_GIP_UNMAP SUP_CTL_CODE_SIZE(21, SUP_IOCTL_GIP_UNMAP_SIZE)
#define SUP_IOCTL_GIP_UNMAP_SIZE_IN sizeof(SUPGIPUNMAP)
#define SUP_IOCTL_GIP_UNMAP_SIZE_OUT sizeof(SUPGIPUNMAP)

    typedef struct SUPGIPUNMAP {
        /** The header. */
        SUPREQHDR Hdr;
    } SUPGIPUNMAP, *PSUPGIPUNMAP;
    /** @} */

    /**
    * Header which heading all memory blocks.
    */
    typedef struct _MEMHDR {
        /** Magic (RTMEMHDR_MAGIC). */
        u32 u32Magic;
        /** Block flags (RTMEMHDR_FLAG_*). */
        u32 fFlags;
        /** The actual size of the block. */
        u32 cb;
        /** The request allocation size. */
        u32 cbReq;
    } MEMHDR, *PMEMHDR;

    /**
    * Loaded image.
    */
    typedef struct _SUPDRVLDRIMAGE {
        /** Next in chain. */
        struct SUPDRVLDRIMAGE * volatile pNext;
        /** Pointer to the image. */
        ptr pvImage;
        /** Pointer to the optional module initialization callback. */
        ptr pfnModuleInit;
        /** Pointer to the optional module termination callback. */
        ptr pfnModuleTerm;
        /** Size of the image. */
        u32 cbImage;
        /** The offset of the symbol table. */
        u32 offSymbols;
        /** The number of entries in the symbol table. */
        u32 cSymbols;
        /** The offset of the string table. */
        u32 offStrTab;
        /** Size of the string table. */
        u32 cbStrTab;
        /** The ldr image state. (IOCtl code of last opration.) */
        u32 uState;
        /** Usage count. */
        u32 volatile cUsage;
        /** Image name. */
        char szName[32];
    } SUPDRVLDRIMAGE, *PSUPDRVLDRIMAGE;

#ifndef _WIN64               
# define MEM_FENCE_EXTRA 4 
#else                                 
# define MEM_FENCE_EXTRA 16  
#endif // !_WIN64

#pragma pack() /* paranoia */

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_SUPDEFS_H_

```

`Include/typesdefs.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _TYPESDEFS_H_
#define _TYPESDEFS_H_

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

    typedef signed __int8 s8, *s8ptr;
    typedef signed __int16 s16, *s16ptr;
    typedef signed __int32 s32, *s32ptr;
    typedef signed __int64 s64, *s64ptr;

    typedef unsigned __int8 u8, *u8ptr;
    typedef unsigned __int16 u16, *u16ptr;
    typedef unsigned __int32 u32, *u32ptr;
    typedef unsigned __int64 u64, *u64ptr;

    typedef void * ptr;

    typedef unsigned char c, *cptr;
    typedef unsigned __int16 wc, *wcptr;
    typedef unsigned __int8 b, *bptr;

#ifndef __cplusplus
    typedef * __ptr32 ptr32;
    typedef * __ptr64 ptr64;
#endif // !__cplusplus

#else
#ifndef _UNICODE
#define tc c
#define tcptr cptr
#else
#define tc wc
#define tcptr wcptr
#endif // !_UNICODE

#ifndef _WIN64
typedef __int32 s, *sptr;
typedef unsigned __int32 u, *uptr;
#else
typedef __int64 s, *sptr;
typedef unsigned __int64 u, *uptr;
#endif // !_WIN64

#define s8c(v) (v)
#define s16c(v) (v)
#define s32c(v) (v)
#define s64c(v) (v ## LL)

#define u8c(v) (v)
#define u16c(v) (v)
#define u32c(v) (v ## U)
#define u64c(v) (v ## ULL)

#define __rds8(p) (*(s8ptr)(ptr)(u)(p))
#define __rds16(p) (*(s16ptr)(ptr)(u)(p))
#define __rds32(p) (*(s32ptr)(ptr)(u)(p))
#define __rds64(p) (*(s64ptr)(ptr)(u)(p))
#define __rdsptr(p) (*(sptr)(ptr)(u)(p))

#define __rdu8(p) (*(u8ptr)(ptr)(u)(p))
#define __rdu16(p) (*(u16ptr)(ptr)(u)(p))
#define __rdu32(p) (*(u32ptr)(ptr)(u)(p))
#define __rdu64(p) (*(u64ptr)(ptr)(u)(p))
#define __rduptr(p) (*(uptr)(ptr)(u)(p))

#define __rdfloat(p) (*(float *)(ptr)(u)(p)
#define __rddouble(p) (*(double *)(ptr)(u)(p)

#define __wrs8(p, v) (*(s8ptr)(ptr)(u)(p) = (s8)(v))
#define __wrs16(p, v) (*(s16ptr)(ptr)(u)(p) = (s16)(v))
#define __wrs32(p, v) (*(s32ptr)(ptr)(u)(p) = (s32)(v))
#define __wrs64(p, v) (*(s64ptr)(ptr)(u)(p) = (s64)(v))
#define __wrsptr(p, v) (*(sptr)(ptr)(u)(p) = (s)(v))

#define __wru8(p, v) (*(u8ptr)(ptr)(u)(p) = (u8)(v))
#define __wru16(p, v) (*(u16ptr)(ptr)(u)(p) = (u16)(v))
#define __wru32(p, v) (*(u32ptr)(ptr)(u)(p) = (u32)(v))
#define __wru64(p, v) (*(u64ptr)(ptr)(u)(p) = (u64)(v))
#define __wruptr(p, v) (*(uptr)(ptr)(u)(p) = (u)(v))

#define __wrfloat(p, v) (*(float *)(ptr)(u)(p) = (float)(v))
#define __wrdouble(p, v) (*(double *)(ptr)(u)(p) = (double)(v))

#define __max(a, b) (((a) > (b)) ? (a) : (b))
#define __min(a, b) (((a) < (b)) ? (a) : (b))

#define __makeu16(a, b) (((u16)(a) & 0xff) | (((u16)(b) & 0xff) << 8))
#define __makeu32(a, b) (((u32)(a) & 0xffff) | (((u32)(b) & 0xffff) << 16))
#define __makeu64(a, b) (((u64)(a) & 0xffffffff) | (((u64)(b) & 0xffffffff) << 32))

#define __hiu8(w) ((u8)((u16)(w) >> 8))
#define __lou8(w) ((u8)((u16)(w) & 0xff))
#define __hiu16(l) ((u16)((u32)(l) >> 16))
#define __lou16(l) ((u16)((u32)(l) & 0xffff))
#define __hiu32(l) ((u32)((u64)(l) >> 32))
#define __lou32(l) ((u32)((u64)(l) & 0xffffffff))

#ifndef _WIN64
#define __gcall __stdcall
#else
#define __gcall __fastcall
#endif // !_WIN64

#ifndef GCALL
#define GCALL __gcall
#endif // !GCALL

typedef
u
(GCALL * PGSUPPORT_ROUTINE) (
    ptr Argument1,
    ptr Argument2,
    ptr Argument3,
    ptr Argument4
    );

typedef
u
(GCALL * PGKERNEL_ROUTINE) (
    ptr Argument1,
    ptr Argument2,
    ptr Argument3
    );

typedef
u
(GCALL * PGSYSTEM_ROUTINE) (
    ptr Argument1,
    ptr Argument2
    );

typedef
u
(GCALL * PGRUNDOWN_ROUTINE) (
    ptr Argument
    );

typedef
u
(GCALL * PGNORMAL_ROUTINE) (
    void
    );

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_TYPESDEFS_H_

```

`Include/ver.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger ( blindtiger@foxmail.com )
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _VER_H_
#define _VER_H_

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

#define VER_DEBUG                   2
#define VER_PRERELEASE              0
#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_NT_WINDOWS32
#define VER_FILEFLAGS               (VER_PRERELEASE|VER_DEBUG)

#define VER_FILETYPE                VFT_DRV
#define VER_FILESUBTYPE             VFT2_DRV_SYSTEM

#define VER_COMPANYNAME_STR         "blindtiger"
#define VER_PRODUCTNAME_STR         "Shark"
#define VER_LEGALCOPYRIGHT_YEARS    "2019"
#define VER_LEGALCOPYRIGHT_STR      "Copyright (c) " VER_LEGALCOPYRIGHT_YEARS " " VER_COMPANYNAME_STR
#define VER_LEGALTRADEMARKS_STR     "Copyright (c) " VER_LEGALCOPYRIGHT_YEARS " " VER_COMPANYNAME_STR

#define VER_PRODUCTVERSION          1.0.0.0
#define VER_PRODUCTVERSION_STR      "1.0.0.0"
#define VER_PRODUCTVERSION_W        (0x0200)
#define VER_PRODUCTVERSION_DW       (0x0200)

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_VER_H_

```

`Include/wow64.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger ( blindtiger@foxmail.com )
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _WOW64_H_
#define _WOW64_H_

#ifdef __cplusplus
/* Assume C declarations for C++ */
extern "C" {
#endif	/* __cplusplus */

#ifdef _WIN64

#if !defined(RC_INVOKED)

#define WOW64_CONTEXT_i386      0x00010000    // this assumes that i386 and
#define WOW64_CONTEXT_i486      0x00010000    // i486 have identical context records

#define WOW64_CONTEXT_CONTROL               (WOW64_CONTEXT_i386 | 0x00000001L) // SS:SP, CS:IP, FLAGS, BP
#define WOW64_CONTEXT_INTEGER               (WOW64_CONTEXT_i386 | 0x00000002L) // AX, BX, CX, DX, SI, DI
#define WOW64_CONTEXT_SEGMENTS              (WOW64_CONTEXT_i386 | 0x00000004L) // DS, ES, FS, GS
#define WOW64_CONTEXT_FLOATING_POINT        (WOW64_CONTEXT_i386 | 0x00000008L) // 387 state
#define WOW64_CONTEXT_DEBUG_REGISTERS       (WOW64_CONTEXT_i386 | 0x00000010L) // DB 0-3,6,7
#define WOW64_CONTEXT_EXTENDED_REGISTERS    (WOW64_CONTEXT_i386 | 0x00000020L) // cpu specific extensions

#define WOW64_CONTEXT_FULL      (WOW64_CONTEXT_CONTROL | WOW64_CONTEXT_INTEGER | WOW64_CONTEXT_SEGMENTS)

#define WOW64_CONTEXT_ALL       (WOW64_CONTEXT_CONTROL | WOW64_CONTEXT_INTEGER | WOW64_CONTEXT_SEGMENTS | \
                                 WOW64_CONTEXT_FLOATING_POINT | WOW64_CONTEXT_DEBUG_REGISTERS | \
                                 WOW64_CONTEXT_EXTENDED_REGISTERS)

#define WOW64_CONTEXT_XSTATE                (WOW64_CONTEXT_i386 | 0x00000040L)

#endif // !defined(RC_INVOKED)

    //
    //  Define the size of the 80387 save area, which is in the context frame.
    //

#define WOW64_SIZE_OF_80387_REGISTERS      80

#define WOW64_MAXIMUM_SUPPORTED_EXTENSION     512

    typedef struct _WOW64_FLOATING_SAVE_AREA {
        u32 ControlWord;
        u32 StatusWord;
        u32 TagWord;
        u32 ErrorOffset;
        u32 ErrorSelector;
        u32 DataOffset;
        u32 DataSelector;
        b RegisterArea[WOW64_SIZE_OF_80387_REGISTERS];
        u32 Cr0NpxState;
    } WOW64_FLOATING_SAVE_AREA;

    typedef WOW64_FLOATING_SAVE_AREA *PWOW64_FLOATING_SAVE_AREA;

#include "pshpack4.h"

    //
    // Context Frame
    //
    //  This frame has a several purposes: 1) it is used as an argument to
    //  NtContinue, 2) is is used to constuct a call frame for APC delivery,
    //  and 3) it is used in the user level thread creation routines.
    //
    //  The layout of the record conforms to a standard call frame.
    //

    typedef struct _WOW64_CONTEXT {

        //
        // The flags values within this flag control the contents of
        // a CONTEXT record.
        //
        // If the context record is used as an input parameter, then
        // for each portion of the context record controlled by a flag
        // whose value is set, it is assumed that that portion of the
        // context record contains valid context. If the context record
        // is being used to modify a threads context, then only that
        // portion of the threads context will be modified.
        //
        // If the context record is used as an IN OUT parameter to capture
        // the context of a thread, then only those portions of the thread's
        // context corresponding to set flags will be returned.
        //
        // The context record is never used as an OUT only parameter.
        //

        u32 ContextFlags;

        //
        // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
        // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
        // included in CONTEXT_FULL.
        //

        u32 Dr0;
        u32 Dr1;
        u32 Dr2;
        u32 Dr3;
        u32 Dr6;
        u32 Dr7;

        //
        // This section is specified/returned if the
        // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
        //

        WOW64_FLOATING_SAVE_AREA FloatSave;

        //
        // This section is specified/returned if the
        // ContextFlags word contians the flag CONTEXT_SEGMENTS.
        //

        u32 SegGs;
        u32 SegFs;
        u32 SegEs;
        u32 SegDs;

        //
        // This section is specified/returned if the
        // ContextFlags word contians the flag CONTEXT_INTEGER.
        //

        u32 Edi;
        u32 Esi;
        u32 Ebx;
        u32 Edx;
        u32 Ecx;
        u32 Eax;

        //
        // This section is specified/returned if the
        // ContextFlags word contians the flag CONTEXT_CONTROL.
        //

        u32 Ebp;
        u32 Eip;
        u32 SegCs;              // MUST BE SANITIZED
        u32 EFlags;             // MUST BE SANITIZED
        u32 Esp;
        u32 SegSs;

        //
        // This section is specified/returned if the ContextFlags word
        // contains the flag CONTEXT_EXTENDED_REGISTERS.
        // The format and contexts are processor specific
        //

        b ExtendedRegisters[WOW64_MAXIMUM_SUPPORTED_EXTENSION];

    } WOW64_CONTEXT;

    typedef WOW64_CONTEXT *PWOW64_CONTEXT;

    C_ASSERT(sizeof(WOW64_CONTEXT) == 0x2cc);

#define WOW64_CONTEXT_TO_PROGRAM_COUNTER(Context) ((Context)->Eip)
#define WOW64_PROGRAM_COUNTER_TO_CONTEXT(Context, ProgramCounter) ((Context)->Eip = (ProgramCounter))

#define WOW64_CONTEXT_LENGTH  (sizeof(WOW64_CONTEXT))
#define WOW64_CONTEXT_ALIGN   (sizeof(u32))
#define WOW64_CONTEXT_ROUND   (WOW64_CONTEXT_ALIGN - 1)

#define ThreadWow64Context 29

#include "poppack.h"

    typedef struct _WOW64_LDT_ENTRY {
        u16 LimitLow;
        u16 BaseLow;

        union {
            struct {
                b BaseMid;
                b Flags1;     // Declare as bytes to avoid alignment
                b Flags2;     // Problems.
                b BaseHi;
            } Bytes;

            struct {
                u32 BaseMid : 8;
                u32 Type : 5;
                u32 Dpl : 2;
                u32 Pres : 1;
                u32 LimitHi : 4;
                u32 Sys : 1;
                u32 Reserved_0 : 1;
                u32 Default_Big : 1;
                u32 Granularity : 1;
                u32 BaseHi : 8;
            } Bits;
        } HighWord;
    } WOW64_LDT_ENTRY, *PWOW64_LDT_ENTRY;

    typedef struct _WOW64_DESCRIPTOR_TABLE_ENTRY {
        u32 Selector;
        WOW64_LDT_ENTRY Descriptor;
    } WOW64_DESCRIPTOR_TABLE_ENTRY, *PWOW64_DESCRIPTOR_TABLE_ENTRY;

    NTSYSCALLAPI
        NTSTATUS
        NTAPI
        RtlWow64SuspendThread(
            __in ptr ThreadHandle,
            __out_opt u32ptr PreviousSuspendCount
        );

    NTSYSCALLAPI
        NTSTATUS
        NTAPI
        RtlWow64GetThreadContext(
            __in ptr ThreadHandle,
            __inout PWOW64_CONTEXT ThreadContext
        );

    NTSYSCALLAPI
        NTSTATUS
        NTAPI
        RtlWow64SetThreadContext(
            __in ptr ThreadHandle,
            __in PWOW64_CONTEXT ThreadContext
        );

#endif // _WIN64

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_WOW64_H_

```

`LICENSE`:

```
MIT License

Copyright (c) 2018 blindtiger

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Projects/Sea/AMD64/AMD64.asm`:

```asm
;
;
; Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
;
; The contents of this file are subject to the Mozilla Public License Version
; 2.0 (the "License"); you may not use this file except in compliance with
; the License. You may obtain a copy of the License at
; http://www.mozilla.org/MPL/
;
; Software distributed under the License is distributed on an "AS IS" basis,
; WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
; for the specific language governing rights and limitations under the
; License.
;
; The Initial Developer of the Original Code is blindtiger.
;
;

include macamd64.inc



        end

```

`Projects/Sea/I386/I386.asm`:

```asm
;
;
; Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
;
; The contents of this file are subject to the Mozilla Public License Version
; 2.0 (the "License"); you may not use this file except in compliance with
; the License. You may obtain a copy of the License at
; http://www.mozilla.org/MPL/
;
; Software distributed under the License is distributed on an "AS IS" basis,
; WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
; for the specific language governing rights and limitations under the
; License.
;
; The Initial Developer of the Original Code is blindtiger.
;
;

.686

        .xlist
include callconv.inc
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING
        
    __ValidateEH3RN :
 
        mov edi, edi
 
        push ebp
        mov ebp, esp
 
        mov eax, [ebp + 8]
        test byte ptr [eax + 8], 3
        mov eax, 0
        setz al
 
        mov esp, ebp
        pop ebp
 
        ret
    
    PUBLIC __ValidateEH3RN
    
_TEXT   ends

        end

```

`Projects/Sea/Makefile`:

```
#
#
# Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
#
# The contents of this file are subject to the Mozilla Public License Version
# 2.0 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
# for the specific language governing rights and limitations under the
# License.
#
# The Initial Developer of the Original Code is blindtiger.
#
#

LABS=..\..\..

!if "$(PLATFORM)" == "x86"
ARCTARG = I386
!if "$(PROCESSOR_ARCHITEW6432)" == "AMD64"
PATH = C:\Windows;C:\Windows\System32;$(LABS)\MiniSDK\bin\Hostx64\x86
!else
PATH = C:\Windows;C:\Windows\System32;$(LABS)\MiniSDK\bin\Hostx86\x86
!endif
!else if "$(PLATFORM)" == "x64"
ARCTARG = AMD64
!if "$(PROCESSOR_ARCHITEW6432)" == "AMD64"
PATH = C:\Windows;C:\Windows\System32;$(LABS)\MiniSDK\bin\Hostx64\x64
!else
PATH = C:\Windows;C:\Windows\System32;$(LABS)\MiniSDK\bin\Hostx86\x64
!endif
!else
!ERROR Usage: nmake (PLATFORM=x86|x64) (PROJ=ProjectName) (SLND=SolutionDir) [build|clean|rebuild]
!endif

BIND = $(SLND)Build\Bins\$(ARCTARG)

PROJTARG = $(BIND)\$(PROJ)
PROJD = $(SLND)Projects\$(PROJ)

BUILD: $(PROJTARG).exe

OBJD = $(SLND)Build\Objs\$(PROJ)\$(ARCTARG)

!if "$(ARCTARG)" == "I386"
PROJENTRY = NtProcessStartupForGS@4
!else if "$(ARCTARG)" == "AMD64"
PROJENTRY = NtProcessStartupForGS
!endif

ASOBJS = \
    $(OBJD)\$(ARCTARG).obj

CCARCHOBJS = \
    

CCOBJS = \
    $(OBJD)\$(PROJ).obj \
    $(OBJD)\Support.obj
    
RCOBJS = $(OBJD)\$(PROJ).res

PROJOBJS = $(ASOBJS) $(CCARCHOBJS) $(CCOBJS) $(RCOBJS)

!if "$(ARCTARG)" == "I386"
TARGDEFS = /D_X86_=1 /Di386=1 /DSTD_CALL /DFPO=0 /DDOSWIN32 /DDETOURS_X86 /DDETOURS_32BIT
TARGAOPTS = /safeseh /coff /Zm
TARGCOPTS = /Gz /Gm- /EHs-c- /Od /Oy-
TARGLOPTS = 
HOTPATCH = /stub:$(LABS)\WRK\base\ntos\BUILD\PREBUILT\$(ARCTARG)\STUB512.com
ARCH = X86
ARCHML = ml
!else if "$(ARCTARG)" == "AMD64"
TARGDEFS = /D_WIN64 /D_AMD64_ /DAMD64 /DDETOURS_X64 /DDETOURS_64BIT
TARGAOPTS = 
TARGCOPTS = /Od /EHs-c- /Gs12288
TARGLOPTS = /IGNORE:4108,4088,4218,4218,4235
HOTPATCH = $(LABS)\WRK\base\ntos\BUILD\PREBUILT\$(ARCTARG)\HOTPATCH.obj
ARCH = AMD64
ARCHML = ml64
!endif

PROJLOPTS = /SUBSYSTEM:CONSOLE /ENTRY:$(PROJENTRY) /DEF:$(PROJ).def
  
INCS = \
    /I$(LABS)\MiniSDK\inc\ddk \
    /I$(LABS)\MiniSDK\inc\halkit \
    /I$(LABS)\MiniSDK\inc\internal\base \
    /I$(LABS)\MiniSDK\inc\internal\ds \
    /I$(LABS)\MiniSDK\inc\internal\sdktools \
    /I$(LABS)\MiniSDK\inc\sdk \
    /I$(LABS)\MiniSDK\inc\sdk\crt \
    /I$(LABS)\MiniSDK\inc\sdk\crt\gl \
    /I$(LABS)\MiniSDK\inc\sdk\crt\sys \
    /I$(LABS)\MiniSDK\inc\base \
    /I$(LABS)\MiniSDK\inc\base\ntos \
    /I$(LABS)\MiniSDK\inc\debuggers \
    /I$(SLND)\Include \
    /I$(PROJD)

DEFS = /DUNICODE /D_UNICODE $(TARGDEFS) -D_$(ARCH)_ -D$(ARCH) -DDBG=1

COPTS = /Z7 /Zl /Zp8 /Gy /cbstring /W3 /WX /GR- /GF /GS $(TARGCOPTS)
COMPILERWARNINGS = /FI$(LABS)\WRK\base\ntos\BUILD\WARNING.h /FI$(SLND)\Include\WARNING.h

AOPTS = /Cx /Zi /Zd $(TARGAOPTS)
AS = $(ARCHML).exe /nologo
AFLAGS = $(AOPTS) $(INCS) /Fo$(OBJD)\ $(DEFS) $(SPECIALAFLAGS)

CC = cl.exe /nologo
CFLAGS = $(COPTS) $(INCS) /Fo$(OBJD)\ $(DEFS) $(SPECIALCFLAGS) $(COMPILERWARNINGS)

RC = rc.exe /nologo
RFLAGS = $(INCS) /fo$(RCOBJS)
                  
LINKLIBPATH = \
    /LIBPATH:$(LABS)\MiniSDK\lib\$(ARCTARG) \
    /LIBPATH:$(LABS)\MiniSDK\lib\Crt\$(ARCTARG) \
    /LIBPATH:$(SLND)\Lib\$(ARCTARG)

LINKIGNORE = /IGNORE:4087,4001,4010,4037,4039,4065,4070,4078,4087,4089,4221,4198
BUILDLIBS = ntdllp.lib bufferoverflow.lib \
!if "$(ARCTARG)" == "I386"
    \
!else if "$(ARCTARG)" == "AMD64"
    gshandler.obj gshandlerseh.obj \
!endif
    kernl32p.lib msvcrt.lib shell32.lib user32.lib gdi32.lib \
    nt_process_startup.obj \
    vDbgPrint.obj

LINK = link.exe /nologo
LINKFLAGS = $(LINKIGNORE) /WX /NODEFAULTLIB /machine:$(ARCH) /debug /debugtype:cv,fixup

LINKPROJNAMES = /out:$(PROJTARG).exe /map:$(PROJTARG).map /pdb:$(PROJTARG).pdb

$(PROJTARG).exe: $(PROJOBJS)
    @$(LINK) $(LINKFLAGS) $(PROJLOPTS) $(LINKPROJNAMES) $** $(HOTPATCH) $(LINKLIBPATH) $(BUILDLIBS)

# assembly files
{$(ARCTARG)\}.asm{$(OBJD)\}.obj::
    @$(AS) $(AFLAGS) /c $<

# arch-specific C files
{$(ARCTARG)\}.c{$(OBJD)\}.obj::
    @$(CC) $(CFLAGS) /c $<

# C files
.c{$(OBJD)\}.obj::
    @$(CC) $(CFLAGS) /c $<

# RC files
.rc{$(OBJD)\}.res::
    @$(RC) $(RFLAGS) $<

# CLEAN pseudo targets

CLEAN:
    @if exist $(OBJD)\*.res del /F /Q $(OBJD)\*.res
    @if exist $(OBJD)\*.obj del /F /Q $(OBJD)\*.obj
    @if exist $(PROJTARG).exe del /F /Q $(PROJTARG).exe
    @if exist $(PROJTARG).sys del /F /Q $(PROJTARG).sys
    @if exist $(PROJTARG).dll del /F /Q $(PROJTARG).dll
    @if exist $(PROJTARG).lib del /F /Q $(PROJTARG).lib
    @if exist $(PROJTARG).exe del /F /Q $(PROJTARG).exe
    @if exist $(PROJTARG).exp del /F /Q $(PROJTARG).exp
    @if exist $(PROJTARG).map del /F /Q $(PROJTARG).map
    @if exist $(PROJTARG).pdb del /F /Q $(PROJTARG).pdb

REBUILD: CLEAN BUILD

```

`Projects/Sea/Sea.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>
#include <devicedefs.h>

#include "Sea.h"

#include "Support.h"

NTSTATUS
NTAPI
NtProcessStartup(
    __in PPEB PebBase
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = SupInstall();

    if (ST_SUCCESS(Status)) {
        Status = SupInit();

        if (ST_SUCCESS(Status)) {
            Status = SupLdrLoad(KernelString, "Shark", CmdReload | CmdPgClear);

            SupTerm();
        }
        else {
            printf(
                TEXT("load driver error code < %08x >\n"),
                Status);

            _getwch();
        }

        SupUninstall();
    }
    else {
        printf(
            TEXT("load driver error code < %08x >\n"),
            Status);

        _getwch();
    }

    return  NtTerminateProcess(
        NtCurrentProcess(),
        STATUS_SUCCESS);
}

```

`Projects/Sea/Sea.def`:

```def
;
;
; Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
;
; The contents of this file are subject to the Mozilla Public License Version
; 2.0 (the "License"); you may not use this file except in compliance with
; the License. You may obtain a copy of the License at
; http://www.mozilla.org/MPL/
;
; Software distributed under the License is distributed on an "AS IS" basis,
; WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
; for the specific language governing rights and limitations under the
; License.
;
; The Initial Developer of the Original Code is blindtiger.
;
;

LIBRARY
    EXPORTS

```

`Projects/Sea/Sea.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _SEA_H_
#define _SEA_H_

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */



#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_SEA_H_

```

`Projects/Sea/Sea.rc`:

```rc
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <winver.h>
#include <ver.h>

#define VER_FILEDESCRIPTION_STR     "Sea"
#define VER_INTERNALNAME_STR        "Sea"
#define VER_ORIGINALFILENAME_STR    "Sea.exe"

ICON_SMALL ICON "Sea.ico"
ICON_BIG ICON "Sea.ico"

#include <common.ver>

```

`Projects/Sea/Sea.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Optimized|Win32">
      <Configuration>Optimized</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Optimized|x64">
      <Configuration>Optimized</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{CFDA5888-9D8D-4EFF-90E6-DA739486E10F}</ProjectGuid>
    <Keyword>MakeFileProj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'" Label="Configuration">
    <ConfigurationType>Makefile</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'" Label="Configuration">
    <ConfigurationType>Makefile</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">
    <NMakeBuildCommandLine>NMAKE /NOLOGO BUILD PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeBuildCommandLine>
    <NMakeCleanCommandLine>NMAKE /NOLOGO CLEAN PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeCleanCommandLine>
    <NMakeReBuildCommandLine>NMAKE /NOLOGO REBUILD PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeReBuildCommandLine>
    <NMakeOutput>$(SolutionDir)Build\Bins\I386\$(ProjectName).exe</NMakeOutput>
    <NMakePreprocessorDefinitions>UNICODE;_UNICODE;DOSWIN32;_X86_</NMakePreprocessorDefinitions>
    <NMakeIncludeSearchPath>..\..\..\MiniSDK\inc\ddk;..\..\..\MiniSDK\inc\halkit;..\..\..\MiniSDK\inc\internal\base;..\..\..\MiniSDK\inc\internal\ds;..\..\..\MiniSDK\inc\internal\sdktools;..\..\..\MiniSDK\inc\sdk;..\..\..\MiniSDK\inc\sdk\inc\crt;..\..\..\MiniSDK\inc\base;..\..\..\MiniSDK\inc\base\ntos;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt;..\..\..\MiniSDK\inc\sdk\crt\gl;..\..\..\MiniSDK\inc\sdk\crt\sys;..\..\..\MiniSDK\inc\debuggers;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt\gl;\$(SolutionDir)Include;$(ProjectDir)</NMakeIncludeSearchPath>
    <OutDir>$(SolutionDir)Build\Bins\I386\</OutDir>
    <IntDir>$(SolutionDir)Build\Objs\$(ProjectName)\I386\</IntDir>
    <IncludePath>..\..\..\MiniSDK\inc\ddk;..\..\..\MiniSDK\inc\halkit;..\..\..\MiniSDK\inc\internal\base;..\..\..\MiniSDK\inc\internal\ds;..\..\..\MiniSDK\inc\internal\sdktools;..\..\..\MiniSDK\inc\sdk;..\..\..\MiniSDK\inc\sdk\inc\crt;..\..\..\MiniSDK\inc\base;..\..\..\MiniSDK\inc\base\ntos;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt;..\..\..\MiniSDK\inc\sdk\crt\gl;..\..\..\MiniSDK\inc\sdk\crt\sys;..\..\..\MiniSDK\inc\debuggers;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt\gl;$(SolutionDir)Include;$(ProjectDir)</IncludePath>
    <ReferencePath />
    <LibraryPath>..\..\..\MiniSDK\lib\i386;..\..\..\MiniSDK\lib\crt\i386</LibraryPath>
    <LibraryWPath />
    <SourcePath />
    <ExcludePath />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">
    <NMakeBuildCommandLine>NMAKE /NOLOGO BUILD PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeBuildCommandLine>
    <NMakeCleanCommandLine>NMAKE /NOLOGO CLEAN PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeCleanCommandLine>
    <NMakeReBuildCommandLine>NMAKE /NOLOGO REBUILD PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeReBuildCommandLine>
    <NMakeOutput>$(SolutionDir)Build\Bins\AMD64\$(ProjectName).exe</NMakeOutput>
    <NMakePreprocessorDefinitions>UNICODE;_UNICODE;_AMD64_</NMakePreprocessorDefinitions>
    <NMakeIncludeSearchPath>..\..\..\MiniSDK\inc\ddk;..\..\..\MiniSDK\inc\halkit;..\..\..\MiniSDK\inc\internal\base;..\..\..\MiniSDK\inc\internal\ds;..\..\..\MiniSDK\inc\internal\sdktools;..\..\..\MiniSDK\inc\sdk;..\..\..\MiniSDK\inc\sdk\inc\crt;..\..\..\MiniSDK\inc\base;..\..\..\MiniSDK\inc\base\ntos;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt;..\..\..\MiniSDK\inc\sdk\crt\gl;..\..\..\MiniSDK\inc\sdk\crt\sys;..\..\..\MiniSDK\inc\debuggers;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt\gl;$(SolutionDir)Include;$(ProjectDir)</NMakeIncludeSearchPath>
    <OutDir>$(SolutionDir)Build\Bins\AMD64\</OutDir>
    <IntDir>$(SolutionDir)Build\Objs\$(ProjectName)\AMD64\</IntDir>
    <IncludePath>..\..\..\MiniSDK\inc\ddk;..\..\..\MiniSDK\inc\halkit;..\..\..\MiniSDK\inc\internal\base;..\..\..\MiniSDK\inc\internal\ds;..\..\..\MiniSDK\inc\internal\sdktools;..\..\..\MiniSDK\inc\sdk;..\..\..\MiniSDK\inc\sdk\inc\crt;..\..\..\MiniSDK\inc\base;..\..\..\MiniSDK\inc\base\ntos;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt;..\..\..\MiniSDK\inc\sdk\crt\gl;..\..\..\MiniSDK\inc\sdk\crt\sys;..\..\..\MiniSDK\inc\debuggers;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt\gl;$(SolutionDir)Include;$(ProjectDir)</IncludePath>
    <ReferencePath />
    <LibraryPath>..\..\..\MiniSDK\lib\amd64;..\..\..\MiniSDK\lib\crt\amd64</LibraryPath>
    <LibraryWPath />
    <SourcePath />
    <ExcludePath />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
  <ItemGroup>
    <ClCompile Include="Sea.c" />
    <ClCompile Include="Support.c" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="AMD64\AMD64.asm">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">false</ExcludedFromBuild>
      <FileType>Document</FileType>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">false</UseSafeExceptionHandlers>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">true</ExcludedFromBuild>
    </MASM>
    <MASM Include="I386\I386.asm">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">false</ExcludedFromBuild>
      <FileType>Document</FileType>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">true</UseSafeExceptionHandlers>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">true</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">true</UseSafeExceptionHandlers>
    </MASM>
    <None Include="Sea.def" />
    <None Include="Makefile" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Sea.rc" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Sea.h" />
    <ClInclude Include="Support.h" />
  </ItemGroup>
</Project>
```

`Projects/Sea/Sea.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Source Files\AMD64">
      <UniqueIdentifier>{6cc352ef-8d01-46ce-8869-0b5e9c731c9d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\I386">
      <UniqueIdentifier>{ef34afe2-89bf-4075-b93c-6850345cfe9a}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Sea.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Support.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Sea.def">
      <Filter>Source Files</Filter>
    </None>
    <None Include="Makefile" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Sea.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="AMD64\AMD64.asm">
      <Filter>Source Files\AMD64</Filter>
    </MASM>
    <MASM Include="I386\I386.asm">
      <Filter>Source Files\I386</Filter>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Sea.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Support.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Projects/Sea/Sea.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Projects/Sea/Support.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>
#include <devicedefs.h>

#include "Support.h"

u32 Cookie;
u32 SessionCookie;
ptr Session;
ptr SUPHandle;

static
u16
NTAPI
LdrGetOsPlatform(
    void
)
{
    status Status = STATUS_SUCCESS;
    SYSTEM_PROCESSOR_INFORMATION ProcessorInformation = { 0 };
    u ProcessInformation = 0;
    u32 ReturnLength = 0;
    u16 Platform = 0;

    Status = NtQuerySystemInformation(
        SystemProcessorInformation,
        &ProcessorInformation,
        sizeof(SYSTEM_PROCESSOR_INFORMATION),
        &ReturnLength);

    if (TRACE(Status)) {
        if (PROCESSOR_ARCHITECTURE_AMD64 ==
            ProcessorInformation.ProcessorArchitecture) {
            Platform = IMAGE_NT_OPTIONAL_HDR64_MAGIC;
        }
        else if (PROCESSOR_ARCHITECTURE_INTEL ==
            ProcessorInformation.ProcessorArchitecture) {
            Status = NtQueryInformationProcess(
                NtCurrentProcess(),
                ProcessWow64Information,
                &ProcessInformation,
                sizeof(ProcessInformation),
                &ReturnLength);

            if (TRACE(Status)) {
                if (ProcessInformation) {
                    Platform = IMAGE_NT_OPTIONAL_HDR64_MAGIC;
                }
                else {
                    Platform = IMAGE_NT_OPTIONAL_HDR32_MAGIC;
                }
            }
        }
    }

    return Platform;
}

status
NTAPI
RegistryCreateKey(
    __out ptr * KeyHandle,
    __in ACCESS_MASK DesiredAccess,
    __in wcptr KeyList,
    __in u32 CreateOptions
)
{
    status Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    UNICODE_STRING KeyPath = { 0 };

    RtlInitUnicodeString(&KeyPath, KeyList);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = NtCreateKey(
        KeyHandle,
        DesiredAccess,
        &ObjectAttributes,
        0,
        NULL,
        CreateOptions,
        NULL);

    return Status;
}

status
NTAPI
RegistryOpenKey(
    __out ptr * KeyHandle,
    __in ACCESS_MASK DesiredAccess,
    __in wcptr KeyList
)
{
    status Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    UNICODE_STRING KeyPath = { 0 };

    RtlInitUnicodeString(&KeyPath, KeyList);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = NtOpenKey(
        KeyHandle,
        DesiredAccess,
        &ObjectAttributes);

    return Status;
}

status
NTAPI
RegistrySetValueKey(
    __in ptr KeyHandle,
    __in wcptr ValueName,
    __in u32 Type,
    __in_bcount_opt(DataSize) ptr Data,
    __in u32 DataSize
)
{
    status Status = STATUS_SUCCESS;
    UNICODE_STRING KeyValueName = { 0 };

    RtlInitUnicodeString(&KeyValueName, ValueName);

    Status = NtSetValueKey(
        KeyHandle,
        &KeyValueName,
        0,
        Type,
        Data,
        DataSize);

    return Status;
}

void
NTAPI
RegistryDeleteKey(
    __in PUNICODE_STRING KeyPath
)
{
    status Status = STATUS_SUCCESS;
    ptr KeyHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    PKEY_BASIC_INFORMATION BasicInformation = NULL;
    PKEY_VALUE_BASIC_INFORMATION ValueBasicInformation = NULL;
    UNICODE_STRING KeyName = { 0 };
    UNICODE_STRING Separator = { 0 };
    UNICODE_STRING SubKeyName = { 0 };
    wcptr KeyNameBuffer = NULL;
    u32 Length = 0;
    u32 ResultLength = 0;

    InitializeObjectAttributes(
        &ObjectAttributes,
        KeyPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = NtOpenKey(
        &KeyHandle,
        KEY_ALL_ACCESS,
        &ObjectAttributes);

    if (NT_SUCCESS(Status)) {
        Length =
            MAXIMUM_FILENAME_LENGTH * sizeof(wc) +
            FIELD_OFFSET(KEY_BASIC_INFORMATION, Name);

        BasicInformation =
            __malloc(Length
                + MAXIMUM_FILENAME_LENGTH * sizeof(wc)
                + MAXIMUM_FILENAME_LENGTH * sizeof(wc)
                + FIELD_OFFSET(KEY_VALUE_BASIC_INFORMATION, Name));

        if (NULL != BasicInformation) {
            KeyNameBuffer = (PCHAR)BasicInformation + Length;
            ValueBasicInformation = KeyNameBuffer + MAXIMUM_FILENAME_LENGTH;

            do {
                Status = NtEnumerateKey(
                    KeyHandle,
                    0,
                    KeyBasicInformation,
                    BasicInformation,
                    Length,
                    &ResultLength);

                if (NT_SUCCESS(Status)) {
                    SubKeyName.Buffer = KeyNameBuffer;
                    SubKeyName.Length = 0;
                    SubKeyName.MaximumLength = (u16)MAXIMUM_FILENAME_LENGTH * sizeof(wc);

                    KeyName.Buffer = BasicInformation->Name;
                    KeyName.Length = (u16)BasicInformation->NameLength;
                    KeyName.MaximumLength = (u16)MAXIMUM_FILENAME_LENGTH * sizeof(wc);

                    RtlInitUnicodeString(&Separator, L"\\");

                    RtlAppendStringToString(&SubKeyName, KeyPath);
                    RtlAppendStringToString(&SubKeyName, &Separator);
                    RtlAppendStringToString(&SubKeyName, &KeyName);

                    RegistryDeleteKey(&SubKeyName);
                }
            } while (NT_SUCCESS(Status));

            do {
                Status = NtEnumerateValueKey(
                    KeyHandle,
                    0,
                    KeyValueBasicInformation,
                    ValueBasicInformation,
                    Length,
                    &ResultLength);

                if (NT_SUCCESS(Status)) {
                    KeyName.Buffer = ValueBasicInformation->Name;
                    KeyName.Length = (u16)ValueBasicInformation->NameLength;
                    KeyName.MaximumLength = (u16)MAXIMUM_FILENAME_LENGTH * sizeof(wc);

                    TRACE(NtDeleteValueKey(
                        KeyHandle,
                        &KeyName));
                }
            } while (NT_SUCCESS(Status));

            __free(BasicInformation);
        }

        TRACE(NtDeleteKey(KeyHandle));
        TRACE(NtClose(KeyHandle));
    }
}

status
NTAPI
RegistryCreateSevice(
    __in wcptr ImageFileName,
    __in wcptr ServiceName
)
{
    status Status = STATUS_SUCCESS;
    ptr KeyHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    UNICODE_STRING KeyPath = { 0 };
    wcptr KeyPathBuffer = NULL;
    UNICODE_STRING KeyName = { 0 };
    UNICODE_STRING ImagePath = { 0 };
    u32 Type = 1;
    u32 Start = 3;
    u32 ErrorControl = 1;
    b WasEnabled = FALSE;

    Status = RtlAdjustPrivilege(
        SE_LOAD_DRIVER_PRIVILEGE,
        TRUE,
        FALSE,
        &WasEnabled);

    if (TRACE(Status)) {
        KeyPathBuffer =
            __malloc(MAXIMUM_FILENAME_LENGTH * sizeof(wc));

        if (NULL != KeyPathBuffer) {
            KeyPath.Buffer = KeyPathBuffer;
            KeyPath.Length = 0;
            KeyPath.MaximumLength = MAXIMUM_FILENAME_LENGTH * sizeof(wc);

            RtlInitUnicodeString(&KeyName, ServicesDirectory);
            RtlAppendStringToString(&KeyPath, &KeyName);
            RtlInitUnicodeString(&KeyName, ServiceName);
            RtlAppendStringToString(&KeyPath, &KeyName);

            InitializeObjectAttributes(
                &ObjectAttributes,
                &KeyPath,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);

            Status = NtCreateKey(
                &KeyHandle,
                KEY_ALL_ACCESS,
                &ObjectAttributes,
                0,
                NULL,
                REG_OPTION_VOLATILE,
                NULL);

            if (TRACE(Status)) {
                TRACE(RegistrySetValueKey(
                    KeyHandle,
                    L"Type",
                    REG_DWORD,
                    &Type,
                    sizeof(Type)));

                TRACE(RegistrySetValueKey(
                    KeyHandle,
                    L"ErrorControl",
                    REG_DWORD,
                    &ErrorControl,
                    sizeof(ErrorControl)));

                TRACE(RegistrySetValueKey(
                    KeyHandle,
                    L"Start",
                    REG_DWORD,
                    &Start,
                    sizeof(Start)));

                TRACE(RegistrySetValueKey(
                    KeyHandle,
                    L"DisplayName",
                    REG_SZ,
                    ServiceName,
                    wcslen(ServiceName) * sizeof(wc) + sizeof(UNICODE_NULL)));

                RtlInitUnicodeString(&ImagePath, ImageFileName);

                TRACE(RegistrySetValueKey(
                    KeyHandle,
                    L"ImagePath",
                    REG_EXPAND_SZ,
                    ImagePath.Buffer,
                    ImagePath.Length + sizeof(UNICODE_NULL)));

                Status = NtLoadDriver(&KeyPath);

                TRACE(NtClose(KeyHandle));
            }

            __free(KeyPathBuffer);
        }

        if (FALSE == WasEnabled) {
            TRACE(RtlAdjustPrivilege(
                SE_LOAD_DRIVER_PRIVILEGE,
                FALSE,
                FALSE,
                &WasEnabled));
        }
    }

    return Status;
}

status
NTAPI
RegistryDeleteSevice(
    __in wcptr ServiceName
)
{
    status Status = STATUS_SUCCESS;
    ptr KeyHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    UNICODE_STRING KeyPath = { 0 };
    wcptr KeyPathBuffer = NULL;
    UNICODE_STRING KeyName = { 0 };
    b WasEnabled = FALSE;

    Status = RtlAdjustPrivilege(
        SE_LOAD_DRIVER_PRIVILEGE,
        TRUE,
        FALSE,
        &WasEnabled);

    if (TRACE(Status)) {
        KeyPathBuffer =
            __malloc(MAXIMUM_FILENAME_LENGTH * sizeof(wc));

        if (NULL != KeyPathBuffer) {
            KeyPath.Buffer = KeyPathBuffer;
            KeyPath.Length = 0;
            KeyPath.MaximumLength = MAXIMUM_FILENAME_LENGTH * sizeof(wc);

            RtlInitUnicodeString(&KeyName, ServicesDirectory);
            RtlAppendStringToString(&KeyPath, &KeyName);
            RtlInitUnicodeString(&KeyName, ServiceName);
            RtlAppendStringToString(&KeyPath, &KeyName);

            InitializeObjectAttributes(
                &ObjectAttributes,
                &KeyPath,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);

            Status = NtOpenKey(
                &KeyHandle,
                KEY_ALL_ACCESS,
                &ObjectAttributes);

            if (TRACE(Status)) {
                Status = NtUnloadDriver(&KeyPath);

                if (TRACE(Status)) {
                    RegistryDeleteKey(&KeyPath);
                }

                TRACE(NtClose(KeyHandle));
            }

            __free(KeyPathBuffer);
        }

        if (FALSE == WasEnabled) {
            TRACE(RtlAdjustPrivilege(
                SE_LOAD_DRIVER_PRIVILEGE,
                FALSE,
                FALSE,
                &WasEnabled));
        }
    }

    return Status;
}

FORCEINLINE
u32
NTAPI
LdrGetRelocCount(
    __in u32 SizeOfBlock
)
{
    u32 Count = 0;

    Count = (SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(u16);

    return Count;
}

PIMAGE_BASE_RELOCATION
NTAPI
LdrRelocBlock(
    __in ptr VA,
    __in u32 Count,
    __in u16ptr NextOffset,
    __in s Diff
)
{
    u16ptr FixupVA = NULL;
    u16 Offset = 0;
    u16 Type = 0;

    while (Count--) {
        Offset = *NextOffset & 0xfff;
        FixupVA = (u8ptr)VA + Offset;
        Type = (*NextOffset >> 12) & 0xf;

        switch (Type) {
        case IMAGE_REL_BASED_ABSOLUTE: {
            break;
        }

        case IMAGE_REL_BASED_HIGH: {
            FixupVA[1] += (u16)((Diff >> 16) & 0xffff);
            break;
        }

        case IMAGE_REL_BASED_LOW: {
            FixupVA[0] += (u16)(Diff & 0xffff);
            break;
        }

        case IMAGE_REL_BASED_HIGHLOW: {
            *(u32ptr)FixupVA += (u32)Diff;
            break;
        }

        case IMAGE_REL_BASED_HIGHADJ: {
            FixupVA[0] += NextOffset[1] & 0xffff;
            FixupVA[1] += (u16)((Diff >> 16) & 0xffff);

            ++NextOffset;
            --Count;
            break;
        }

        case IMAGE_REL_BASED_MIPS_JMPADDR:
        case IMAGE_REL_BASED_SECTION:
        case IMAGE_REL_BASED_REL32:
            // case IMAGE_REL_BASED_VXD_RELATIVE:
            // case IMAGE_REL_BASED_MIPS_JMPADDR16: 

        case IMAGE_REL_BASED_IA64_IMM64: {
            break;
        }

        case IMAGE_REL_BASED_DIR64: {
            *(uptr)FixupVA += Diff;
            break;
        }

        default: {
            return NULL;
        }
        }

        ++NextOffset;
    }

    return (PIMAGE_BASE_RELOCATION)NextOffset;
}

void
NTAPI
LdrRelocImage(
    __in ptr ImageBase,
    __in s Diff
)
{
    PIMAGE_BASE_RELOCATION RelocDirectory = NULL;
    u32 Size = 0;
    ptr VA = 0;

    RelocDirectory = RtlImageDirectoryEntryToData(
        ImageBase,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_BASERELOC,
        &Size);

    if (0 != Size) {
        if (0 != Diff) {
            while (0 != Size) {
                VA = (u8ptr)ImageBase + RelocDirectory->VirtualAddress;
                Size -= RelocDirectory->SizeOfBlock;

                RelocDirectory = LdrRelocBlock(
                    VA,
                    LdrGetRelocCount(RelocDirectory->SizeOfBlock),
                    (u16ptr)(RelocDirectory + 1),
                    Diff);
            }
        }
    }
}

status
NTAPI
LdrMapSectionOffline(
    __in cptr ImageFileName,
    __out ptr * ImageViewBase
)
{
    status Status = STATUS_SUCCESS;
    ptr Handle = NULL;
    ptr Section = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    ptr ViewBase = NULL;
    u ViewSize = 0;
    STRING String = { 0 };
    UNICODE_STRING FullPath = { 0 };

    RtlInitString(&String, ImageFileName);

    Status = RtlAnsiStringToUnicodeString(
        &FullPath,
        &String,
        TRUE);

    if (NT_SUCCESS(Status)) {
        InitializeObjectAttributes(
            &ObjectAttributes,
            &FullPath,
            (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE),
            NULL,
            NULL);

        Status = NtOpenFile(
            &Handle,
            FILE_EXECUTE,
            &ObjectAttributes,
            &IoStatusBlock,
            FILE_SHARE_READ | FILE_SHARE_DELETE,
            0);

        if (NT_SUCCESS(Status)) {
            InitializeObjectAttributes(
                &ObjectAttributes,
                NULL,
                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                NULL,
                NULL);

            Status = NtCreateSection(
                &Section,
                SECTION_MAP_READ | SECTION_MAP_EXECUTE,
                &ObjectAttributes,
                NULL,
                PAGE_EXECUTE,
                SEC_IMAGE,
                Handle);

            if (NT_SUCCESS(Status)) {
                Status = NtMapViewOfSection(
                    Section,
                    NtCurrentProcess(),
                    &ViewBase,
                    0L,
                    0L,
                    NULL,
                    &ViewSize,
                    ViewShare,
                    0L,
                    PAGE_EXECUTE);

                if (NT_SUCCESS(Status)) {
                    *ImageViewBase = ViewBase;
                }

                TRACE(NtClose(Section));
            }

            TRACE(NtClose(Handle));
        }

        RtlFreeUnicodeString(&FullPath);
    }

    return Status;
}

status
NTAPI
LdrLoadImportOffline(
    __in PSTRING ImageFileName,
    __out ptr * ImageBase,
    __out ptr * ImportViewBase
)
{
    status Status = STATUS_SUCCESS;
    PRTL_PROCESS_MODULES Modules = NULL;
    u32 BufferSize = PAGE_SIZE;
    u32 Index = 0;
    u32 ReturnLength = 0;
    STRING String = { 0 };
    c FullName[MAXIMUM_FILENAME_LENGTH] = { 0 };

retry:
    Modules = __malloc(BufferSize);

    if (NULL != Modules) {
        RtlZeroMemory(Modules, BufferSize);

        Status = NtQuerySystemInformation(
            SystemModuleInformation,
            Modules,
            BufferSize,
            &ReturnLength);

        if (NT_SUCCESS(Status)) {
            Status = STATUS_NOT_FOUND;

            for (Index = 0;
                Index < Modules->NumberOfModules;
                Index++) {
                _splitpath(
                    Modules->Modules[Index].FullPathName,
                    NULL,
                    NULL,
                    FullName,
                    NULL);

                _splitpath(
                    Modules->Modules[Index].FullPathName,
                    NULL,
                    NULL,
                    NULL,
                    FullName + strlen(FullName));

                RtlInitString(&String, FullName);

                if (FALSE != RtlPrefixString(
                    ImageFileName,
                    &String,
                    TRUE)) {
                    *ImageBase = Modules->Modules[Index].ImageBase;

                    Status = LdrMapSectionOffline(
                        Modules->Modules[Index].FullPathName,
                        ImportViewBase);

                    break;
                }
            }
        }

        __free(Modules);

        Modules = NULL;

        if (STATUS_INFO_LENGTH_MISMATCH == Status) {
            BufferSize = ReturnLength;

            goto retry;
        }
    }
    else {
        Status = STATUS_NO_MEMORY;
    }

    return Status;
}

ptr
NTAPI
LdrForwardOffline(
    __in cptr ForwarderData
)
{
    status Status = STATUS_SUCCESS;
    ptr ImageBase = NULL;
    ptr ImageViewBase = NULL;
    cptr Separator = NULL;
    cptr ImageName = NULL;
    cptr ProcedureName = NULL;
    u32 ProcedureNumber = 0;
    ptr ProcedureAddress = NULL;
    STRING String = { 0 };

    Separator = strchr(ForwarderData, '.');

    if (NULL != Separator) {
        ImageName = __malloc(Separator - ForwarderData);

        if (NULL != ImageName) {
            RtlCopyMemory(
                ImageName,
                ForwarderData,
                Separator - ForwarderData);

            String.Buffer = ImageName;
            String.Length = Separator - ForwarderData;
            String.MaximumLength = Separator - ForwarderData;

            Status = LdrLoadImportOffline(
                &String,
                &ImageBase,
                &ImageViewBase);

            if (TRACE(Status)) {
                Status = STATUS_NO_MORE_ENTRIES;

                Separator += 1;
                ProcedureName = Separator;

                if (Separator[0] != '@') {
                    ProcedureAddress = LdrGetSymbolOffline(
                        ImageBase,
                        ImageViewBase,
                        ProcedureName,
                        0);
                }
                else {
                    Separator += 1;

                    if (RtlCharToInteger(
                        Separator,
                        0,
                        &ProcedureNumber) >= 0) {
                        ProcedureAddress = LdrGetSymbolOffline(
                            ImageBase,
                            ImageViewBase,
                            NULL,
                            ProcedureNumber);
                    }
                }

                TRACE(NtUnmapViewOfSection(
                    NtCurrentProcess(),
                    ImageBase));
            }

            __free(ImageName);
        }
    }

    return ProcedureAddress;
}

ptr
NTAPI
LdrGetSymbolOffline(
    __in ptr ImageBase,
    __in ptr ImageViewBase,
    __in_opt cptr ProcedureName,
    __in_opt u32 ProcedureNumber
)
{
    PIMAGE_EXPORT_DIRECTORY ExportDirectory = NULL;
    u32 Size = 0;
    u32ptr NameTable = NULL;
    u16ptr OrdinalTable = NULL;
    u32ptr AddressTable = NULL;
    cptr NameTableName = NULL;
    u16 HintIndex = 0;
    ptr ProcedureAddress = NULL;

    ExportDirectory = RtlImageDirectoryEntryToData(
        ImageViewBase,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_EXPORT,
        &Size);

    if (NULL != ExportDirectory) {
        NameTable = (u8ptr)ImageViewBase + ExportDirectory->AddressOfNames;
        OrdinalTable = (u8ptr)ImageViewBase + ExportDirectory->AddressOfNameOrdinals;
        AddressTable = (u8ptr)ImageViewBase + ExportDirectory->AddressOfFunctions;

        if (NULL != NameTable &&
            NULL != OrdinalTable &&
            NULL != AddressTable) {
            if (ProcedureNumber >= ExportDirectory->Base &&
                ProcedureNumber < MAXSHORT) {
                ProcedureAddress = (u8ptr)ImageBase
                    + AddressTable[ProcedureNumber - ExportDirectory->Base];
            }
            else {
                for (HintIndex = 0;
                    HintIndex < ExportDirectory->NumberOfNames;
                    HintIndex++) {
                    NameTableName = (u8ptr)ImageViewBase + NameTable[HintIndex];

                    if (0 == _stricmp(
                        ProcedureName,
                        NameTableName)) {
                        ProcedureAddress = (u8ptr)ImageBase
                            + AddressTable[OrdinalTable[HintIndex]];
                    }
                }
            }
        }

        if ((u)ProcedureAddress >= (u)ExportDirectory &&
            (u)ProcedureAddress < (u)ExportDirectory + Size) {
            ProcedureAddress = LdrForwardOffline(ProcedureAddress);
        }
    }

    return ProcedureAddress;
}

void
NTAPI
LdrSnapThunkOffline(
    __in ptr ImageBase
)
{
    status Status = STATUS_SUCCESS;
    PIMAGE_IMPORT_DESCRIPTOR ImportDirectory = NULL;
    u32 Size = 0;
    PIMAGE_THUNK_DATA OriginalThunk = NULL;
    PIMAGE_THUNK_DATA Thunk = NULL;
    PIMAGE_IMPORT_BY_NAME ImportByName = NULL;
    u16 Ordinal = 0;
    cptr ImportName = NULL;
    ptr ImportBase = NULL;
    ptr ImportViewBase = NULL;
    ptr FunctionAddress = NULL;
    u32 Index = 0;
    STRING String = { 0 };

    ImportDirectory = RtlImageDirectoryEntryToData(
        ImageBase,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_IMPORT,
        &Size);

    if (0 != Size) {
        do {
            OriginalThunk = (u8ptr)ImageBase + ImportDirectory->OriginalFirstThunk;
            Thunk = (u8ptr)ImageBase + ImportDirectory->FirstThunk;
            ImportName = (u8ptr)ImageBase + ImportDirectory->Name;

            RtlInitString(&String, ImportName);

            Status = LdrLoadImportOffline(&String, &ImportBase, &ImportViewBase);

            if (TRACE(Status)) {
                do {
                    if (IMAGE_SNAP_BY_ORDINAL(OriginalThunk->u1.Ordinal)) {
                        Ordinal = (u16)IMAGE_ORDINAL(OriginalThunk->u1.Ordinal);

                        FunctionAddress = LdrGetSymbolOffline(
                            ImportBase,
                            ImportViewBase,
                            NULL,
                            Ordinal);

                        if (NULL != FunctionAddress) {
                            Thunk->u1.Function = (u)FunctionAddress;
                        }
                        else {
                            DbgPrint(
                                "[SHARK] import procedure ordinal@%d not found\n",
                                Ordinal);
                        }
                    }
                    else {
                        ImportByName = (u8ptr)ImageBase + OriginalThunk->u1.AddressOfData;

                        FunctionAddress = LdrGetSymbolOffline(
                            ImportBase,
                            ImportViewBase,
                            ImportByName->Name,
                            0);

                        if (NULL != FunctionAddress) {
                            Thunk->u1.Function = (u)FunctionAddress;
                        }
                        else {
                            DbgPrint(
                                "[SHARK] import procedure %hs not found\n",
                                ImportByName->Name);
                        }
                    }

                    OriginalThunk++;
                    Thunk++;
                } while (OriginalThunk->u1.Function);

                TRACE(NtUnmapViewOfSection(
                    NtCurrentProcess(),
                    ImportViewBase));
            }
            else {
                DbgPrint(
                    "[SHARK] import dll %hs not found\n",
                    ImportName);
            }

            ImportDirectory++;
        } while (0 != ImportDirectory->Characteristics);
    }
}

ptr64
NTAPI
LdrGetEntryPointOffline(
    __in ptr ImageBase,
    __in ptr ViewBase
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    u32 Offset = 0;
    ptr64 EntryPoint = NULL;

    NtHeaders = RtlImageNtHeader(ViewBase);

    if (NULL != NtHeaders) {
        if (IMAGE_NT_OPTIONAL_HDR32_MAGIC == NtHeaders->OptionalHeader.Magic) {
            Offset = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.AddressOfEntryPoint;
        }

        if (IMAGE_NT_OPTIONAL_HDR64_MAGIC == NtHeaders->OptionalHeader.Magic) {
            Offset = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.AddressOfEntryPoint;
        }

        if (0 != Offset) {
            EntryPoint = (u8ptr)ImageBase + Offset;
        }
    }

    return EntryPoint;
}

u32
NTAPI
LdrGetSize(
    __in ptr ImageBase
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    u32 SizeOfImage = 0;

    NtHeaders = RtlImageNtHeader(ImageBase);

    if (NULL != NtHeaders) {
        if (IMAGE_NT_OPTIONAL_HDR32_MAGIC == NtHeaders->OptionalHeader.Magic) {
            SizeOfImage = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.SizeOfImage;
        }

        if (IMAGE_NT_OPTIONAL_HDR64_MAGIC == NtHeaders->OptionalHeader.Magic) {
            SizeOfImage = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.SizeOfImage;
        }
    }

    return SizeOfImage;
}

s
NTAPI
LdrSetImageBase(
    __in ptr ViewBase,
    __in ptr ImageBase
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    s Diff = 0;

    NtHeaders = RtlImageNtHeader(ViewBase);

    if (NULL != NtHeaders) {
        if (IMAGE_NT_OPTIONAL_HDR32_MAGIC == NtHeaders->OptionalHeader.Magic) {
            Diff = (s)ImageBase
                - (s)((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.ImageBase;

            ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.ImageBase =
                (u)ImageBase;
        }

        if (IMAGE_NT_OPTIONAL_HDR64_MAGIC == NtHeaders->OptionalHeader.Magic) {
            Diff = (s64)ImageBase
                - (s64)((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.ImageBase;

            ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.ImageBase =
                (u64)ImageBase;
        }
    }

    return Diff;
}

status
NTAPI
SupLdrMapSection(
    __in wcptr ImageFileName,
    __out ptr * ViewBase,
    __out u * ViewSize
)
{
    status Status = STATUS_SUCCESS;
    ptr Handle = NULL;
    ptr Section = NULL;
    UNICODE_STRING FilePath = { 0 };
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    FILE_STANDARD_INFORMATION StandardInformation = { 0 };
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    PIMAGE_SECTION_HEADER NtSection = NULL;
    LARGE_INTEGER ByteOffset = { 0 };
    ptr FileCache = NULL;
    u Index = 0;

    Status = RtlDosPathNameToNtPathName_U_WithStatus(
        ImageFileName,
        &FilePath,
        NULL,
        NULL);

    if (NT_SUCCESS(Status)) {
        InitializeObjectAttributes(
            &ObjectAttributes,
            &FilePath,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

        Status = NtOpenFile(
            &Handle,
            FILE_READ_DATA,
            &ObjectAttributes,
            &IoStatusBlock,
            FILE_SHARE_READ | FILE_SHARE_DELETE,
            0);

        if (NT_SUCCESS(Status)) {
            Status = NtQueryInformationFile(
                Handle,
                &IoStatusBlock,
                &StandardInformation,
                sizeof(FILE_STANDARD_INFORMATION),
                FileStandardInformation);

            if (TRACE(Status)) {
                FileCache = __malloc(StandardInformation.EndOfFile.LowPart);

                if (NULL != FileCache) {
                    Status = NtReadFile(
                        Handle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        FileCache,
                        StandardInformation.EndOfFile.LowPart,
                        &ByteOffset,
                        NULL);

                    if (NT_SUCCESS(Status)) {
                        *ViewSize = LdrGetSize(FileCache);

                        *ViewBase = __malloc(*ViewSize);

                        if (NULL != *ViewBase) {
                            NtHeaders = RtlImageNtHeader(FileCache);
                            NtSection = IMAGE_FIRST_SECTION(NtHeaders);

                            RtlCopyMemory(
                                *ViewBase,
                                FileCache,
                                NtSection->VirtualAddress);

                            for (Index = 0;
                                Index < NtHeaders->FileHeader.NumberOfSections;
                                Index++) {
                                if (0 != NtSection[Index].VirtualAddress) {
                                    RtlCopyMemory(
                                        (ptr)((u)*ViewBase + NtSection[Index].VirtualAddress),
                                        (ptr)((u)FileCache + NtSection[Index].PointerToRawData),
                                        NtSection[Index].SizeOfRawData);
                                }
                            }
                        }
                        else {
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    }

                    __free(FileCache);
                }
                else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            TRACE(NtClose(Handle));
        }

        RtlFreeUnicodeString(&FilePath);
    }

    return Status;
}

status
NTAPI
SupInstall(
    void
)
{
    status Status = STATUS_SUCCESS;
    ptr Handle = NULL;
    u DiskSize = 0;
    UNICODE_STRING ImagePath = { 0 };
    wc ImagePathBuffer[MAXIMUM_FILENAME_LENGTH] = { 0 };

    Status = RegistryOpenKey(
        &Handle,
        KEY_READ,
        RegistryString);

    if (Status < 0) {
        Status = RtlDosPathNameToNtPathName_U_WithStatus(
            SupportString,
            &ImagePath,
            NULL,
            NULL);

        if (TRACE(Status)) {
            RtlCopyMemory(
                ImagePathBuffer, ImagePath.Buffer, ImagePath.Length);

            Status = RegistryCreateSevice(
                ImagePathBuffer, ServiceString);

            RtlFreeUnicodeString(&ImagePath);
        }
    }
    else {
        Status = STATUS_NOT_SUPPORTED;
    }

    return Status;
}

void
NTAPI
SupUninstall(
    void
)
{
    TRACE(RegistryDeleteSevice(ServiceString));
}

status
NTAPI
SupInit(
    void
)
{
    status Status = STATUS_SUCCESS;
    ptr Handle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    UNICODE_STRING String = { 0 };
    SUPCOOKIE Req = { 0 };

    RtlInitUnicodeString(&String, DeviceString);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &String,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = NtOpenFile(
        &Handle,
        FILE_ALL_ACCESS,
        &ObjectAttributes,
        &IoStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

    if (TRACE(Status)) {
        RtlFillMemory(&Req, sizeof(Req), 0xff);

        Req.Hdr.u32Cookie = SUPCOOKIE_INITIAL_COOKIE;
        Req.Hdr.u32SessionCookie = __rdtsc();
        Req.Hdr.cbIn = SUP_IOCTL_COOKIE_SIZE_IN;
        Req.Hdr.cbOut = SUP_IOCTL_COOKIE_SIZE_OUT;
        Req.Hdr.fFlags = SUPREQHDR_FLAGS_DEFAULT;
        Req.Hdr.rc = ERR_INTERNAL_ERROR;
        Req.u.In.u32MinVersion =
            (SUPDRVIOC_VERSION & 0xffff0000) == 0x00070000 ?
            0x00070002 :
            SUPDRVIOC_VERSION & 0xffff0000;

        strcpy(Req.u.In.szMagic, SUPCOOKIE_MAGIC);

        Status = NtDeviceIoControlFile(
            Handle,
            NULL,
            NULL,
            NULL,
            &IoStatusBlock,
            SUP_IOCTL_COOKIE,
            &Req,
            SUP_IOCTL_COOKIE_SIZE_IN,
            &Req,
            SUP_IOCTL_COOKIE_SIZE_OUT);

        if (TRACE(Status)) {
            Cookie = Req.u.Out.u32Cookie;
            SessionCookie = Req.u.Out.u32SessionCookie;
            Session = Req.u.Out.pSession;
            SUPHandle = Handle;
        }
    }

    return Status;
}

void
NTAPI
SupTerm(
    void
)
{
    TRACE(NtClose(SUPHandle));

    Cookie = 0;
    SessionCookie = 0;
    Session = SUPHandle;
    SUPHandle = NULL;
}

status
NTAPI
SupLdrUnload(
    __in ptr ImageBase
)
{
    status Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    SUPLDRFREE Req = { 0 };

    Req.Hdr.u32Cookie = Cookie;
    Req.Hdr.u32SessionCookie = SessionCookie;
    Req.Hdr.cbIn = SUP_IOCTL_LDR_FREE_SIZE_IN;
    Req.Hdr.cbOut = SUP_IOCTL_LDR_FREE_SIZE_OUT;
    Req.Hdr.fFlags = SUPREQHDR_FLAGS_DEFAULT;
    Req.Hdr.rc = ERR_INTERNAL_ERROR;
    Req.u.In.pvImageBase = ImageBase;

    Status = NtDeviceIoControlFile(
        SUPHandle,
        NULL,
        NULL,
        NULL,
        &IoStatusBlock,
        SUP_IOCTL_LDR_FREE,
        &Req,
        SUP_IOCTL_LDR_FREE_SIZE_IN,
        &Req,
        SUP_IOCTL_LDR_FREE_SIZE_OUT);

    return Status;
}

status
NTAPI
SupLdrLoad(
    __in wcptr ImageFileName,
    __in cptr BaseName,
    __in u32 Operation
)
{
    status Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    ptr ViewBase = NULL;
    u ViewSize = 0;
    PSUPLDRLOAD LoadReq = NULL;
    SUPLDROPEN OpenReq = { 0 };
    SUPCALLVMMR0 CallReq = { 0 };
    s Diff = 0;

    Status = SupLdrMapSection(
        ImageFileName,
        &ViewBase,
        &ViewSize);

    if (TRACE(Status)) {
        OpenReq.Hdr.u32Cookie = Cookie;
        OpenReq.Hdr.u32SessionCookie = SessionCookie;
        OpenReq.Hdr.cbIn = SUP_IOCTL_LDR_OPEN_SIZE_IN;
        OpenReq.Hdr.cbOut = SUP_IOCTL_LDR_OPEN_SIZE_OUT;
        OpenReq.Hdr.fFlags = SUPREQHDR_FLAGS_DEFAULT;
        OpenReq.Hdr.rc = ERR_INTERNAL_ERROR;
        OpenReq.u.In.cbImage = ViewSize;

        strcpy(OpenReq.u.In.szName, BaseName);

        Status = NtDeviceIoControlFile(
            SUPHandle,
            NULL,
            NULL,
            NULL,
            &IoStatusBlock,
            SUP_IOCTL_LDR_OPEN,
            &OpenReq,
            OpenReq.Hdr.cbIn,
            &OpenReq,
            OpenReq.Hdr.cbOut);

        if (TRACE(Status)) {
            LoadReq = __malloc(SUP_IOCTL_LDR_LOAD_SIZE(ViewSize));

            if (NULL != LoadReq) {
                RtlZeroMemory(LoadReq, SUP_IOCTL_LDR_LOAD_SIZE(ViewSize));

                LoadReq->Hdr.u32Cookie = Cookie;
                LoadReq->Hdr.u32SessionCookie = SessionCookie;
                LoadReq->Hdr.cbIn = SUP_IOCTL_LDR_LOAD_SIZE_IN(ViewSize);
                LoadReq->Hdr.cbOut = SUP_IOCTL_LDR_LOAD_SIZE_OUT;
                LoadReq->Hdr.fFlags = SUPREQHDR_FLAGS_MAGIC | SUPREQHDR_FLAGS_EXTRA_IN;
                LoadReq->Hdr.rc = ERR_INTERNAL_ERROR;
                LoadReq->u.In.eEPType = SUPLDRLOADEP_VMMR0;
                LoadReq->u.In.pvImageBase = OpenReq.u.Out.pvImageBase;
                LoadReq->u.In.cbImage = ViewSize;

                RtlCopyMemory(
                    LoadReq->u.In.achImage,
                    ViewBase,
                    ViewSize);

                Diff = LdrSetImageBase(
                    LoadReq->u.In.achImage,
                    LoadReq->u.In.pvImageBase);

                LdrRelocImage(LoadReq->u.In.achImage, Diff);
                LdrSnapThunkOffline(LoadReq->u.In.achImage);

                LoadReq->u.In.pfnModuleTerm =
                    LoadReq->u.In.pfnModuleInit = LdrGetEntryPointOffline(
                        LoadReq->u.In.pvImageBase,
                        LoadReq->u.In.achImage);

                // pass unset
                LoadReq->u.In.EP.VMMR0.pvVMMR0 = (ptr)((u)OpenReq.u.Out.pvImageBase + 1);

                LoadReq->u.In.EP.VMMR0.pvVMMR0EntryInt = LdrGetEntryPointOffline(
                    LoadReq->u.In.pvImageBase,
                    LoadReq->u.In.achImage);;

                LoadReq->u.In.EP.VMMR0.pvVMMR0EntryFast = LdrGetSymbolOffline(
                    LoadReq->u.In.pvImageBase,
                    LoadReq->u.In.achImage,
                    "KernelFastCall",
                    0);

                LoadReq->u.In.EP.VMMR0.pvVMMR0EntryEx = LdrGetSymbolOffline(
                    LoadReq->u.In.pvImageBase,
                    LoadReq->u.In.achImage,
                    "KernelEntry",
                    0);

                Status = NtDeviceIoControlFile(
                    SUPHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    SUP_IOCTL_LDR_LOAD,
                    LoadReq,
                    LoadReq->Hdr.cbIn,
                    LoadReq,
                    LoadReq->Hdr.cbOut);

                if (NT_SUCCESS(Status)) {
                    CallReq.Hdr.u32Cookie = Cookie;
                    CallReq.Hdr.u32SessionCookie = SessionCookie;
                    CallReq.Hdr.cbIn = SUP_IOCTL_CALL_VMMR0_SIZE_IN(0);
                    CallReq.Hdr.cbOut = SUP_IOCTL_CALL_VMMR0_SIZE_OUT(0);
                    CallReq.Hdr.fFlags = SUPREQHDR_FLAGS_DEFAULT;
                    CallReq.Hdr.rc = ERR_INTERNAL_ERROR;
                    CallReq.u.In.pVMR0 = (ptr)((u)OpenReq.u.Out.pvImageBase
                        - MEM_FENCE_EXTRA - sizeof(SUPDRVLDRIMAGE)/* - sizeof(MEMHDR) */);
                    CallReq.u.In.uOperation = Operation;
                    CallReq.u.In.u64Arg = 0;

                    DbgPrint(
                        ".reload /i %s=%p < %p - %08x >\n",
                        BaseName,
                        OpenReq.u.Out.pvImageBase,
                        OpenReq.u.Out.pvImageBase,
                        ViewSize);

                    Status = NtDeviceIoControlFile(
                        SUPHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        SUP_IOCTL_CALL_VMMR0(0),
                        &CallReq,
                        CallReq.Hdr.cbIn,
                        &CallReq,
                        CallReq.Hdr.cbOut);

                    SupLdrUnload(OpenReq.u.Out.pvImageBase);
                }

                __free(LoadReq);
            }
            else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        __free(ViewBase);
    }

    return Status;
}

```

`Projects/Sea/Support.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _SUPPORT_H_
#define _SUPPORT_H_

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

    status
        NTAPI
        RegistryOpenKey(
            __out ptr * KeyHandle,
            __in ACCESS_MASK DesiredAccess,
            __in wcptr KeyList
        );

    status
        NTAPI
        RegistryCreateSevice(
            __in wcptr ImageFileName,
            __in wcptr ServiceName
        );

    status
        NTAPI
        RegistryDeleteSevice(
            __in wcptr ServiceName
        );

    ptr
        NTAPI
        LdrGetSymbolOffline(
            __in ptr ImageBase,
            __in ptr ImageViewBase,
            __in_opt cptr ProcedureName,
            __in_opt u32 ProcedureNumber
        );

    status
        NTAPI
        SupInstall(
            void
        );

    void
        NTAPI
        SupUninstall(
            void
        );

    status
        NTAPI
        SupInit(
            void
        );

    void
        NTAPI
        SupTerm(
            void
        );

    status
        NTAPI
        SupLdrUnload(
            __in ptr ImageBase
        );

    status
        NTAPI
        SupSetVMForFastIoCtl(
            __in ptr Handler
        );

    status
        NTAPI
        SupLdrLoad(
            __in wcptr ImageFileName,
            __in cptr BaseName,
            __in u32 Operation
        );

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_SUPPORT_H_

```

`Projects/Shark/AMD64/AMD64.asm`:

```asm
;
;
; Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
;
; The contents of this file are subject to the Mozilla Public License Version
; 2.0 (the "License"); you may not use this file except in compliance with
; the License. You may obtain a copy of the License at
; http://www.mozilla.org/MPL/
;
; Software distributed under the License is distributed on an "AS IS" basis,
; WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
; for the specific language governing rights and limitations under the
; License.
;
; The Initial Developer of the Original Code is blindtiger.
;
;

include ksamd64.inc
include macamd64.inc
                            
    LEAF_ENTRY DriverEntry, _TEXT$00
        
        xor rax, rax
        ret

    LEAF_END DriverEntry, _TEXT$00
        
    LEAF_ENTRY _FlushSingleTb, _TEXT$00
        
        mov rax, rcx
        invlpg [rax]
        ret

    LEAF_END _FlushSingleTb, _TEXT$00
                                     
        end

```

`Projects/Shark/AMD64/CmpAMD64.asm`:

```asm
;
;
; Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
;
; The contents of this file are subject to the Mozilla Public License Version
; 2.0 (the "License"); you may not use this file except in compliance with
; the License. You may obtain a copy of the License at
; http://www.mozilla.org/MPL/
;
; Software distributed under the License is distributed on an "AS IS" basis,
; WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
; for the specific language governing rights and limitations under the
; License.
;
; The Initial Developer of the Original Code is blindtiger.
;
;

include macamd64.inc

; b
;     NTAPI
;     _cmpbyte(
;         __in s8 b1,
;         __in s8 b2
;     );

    LEAF_ENTRY _cmpbyte, _TEXT$00
        
        cmp cl, dl
        setnz al
        ret

    LEAF_END _cmpbyte, _TEXT$00
        
; b
;     NTAPI
;     _cmpword(
;         __in s16 s1,
;         __in s16 s2
;     );

    LEAF_ENTRY _cmpword, _TEXT$00
        
        cmp cx, dx
        setnz al
        ret

    LEAF_END _cmpword, _TEXT$00
    
; b
;     NTAPI
;     _cmpdword(
;         __in s32 l1,
;         __in s32 l2
;     );

    LEAF_ENTRY _cmpdword, _TEXT$00
        
        cmp ecx, edx
        setnz al
        ret

    LEAF_END _cmpdword, _TEXT$00
    
; b
;     NTAPI
;     _cmpqword(
;         __in s64 ll1,
;         __in s64 ll2
;     );

    LEAF_ENTRY _cmpqword, _TEXT$00
        
        cmp rcx, rdx
        setnz al
        ret

    LEAF_END _cmpqword, _TEXT$00

        end

```

`Projects/Shark/AMD64/ContextAMD64.asm`:

```asm
;
;
; Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
;
; The contents of this file are subject to the Mozilla Public License Version
; 2.0 (the "License"); you may not use this file except in compliance with
; the License. You may obtain a copy of the License at
; http://www.mozilla.org/MPL/
;
; Software distributed under the License is distributed on an "AS IS" basis,
; WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
; for the specific language governing rights and limitations under the
; License.
;
; The Initial Developer of the Original Code is blindtiger.
;
;

include ksamd64.inc
include macamd64.inc

; DECLSPEC_NORETURN
;     void
;     STDCALL
;     _CaptureContext(
;         __in u32 ProgramCounter,
;         __in ptr Guard,
;         __in PGUARD_CALLBACK Callback,
;         __in_opt ptr Parameter,
;         __in_opt ptr Reserved
;     );

StackPointer EQU 28h
Reserved EQU 20h
Parameter EQU 18h
Callback EQU 10h
Guard EQU 8
ProgramCounter EQU 0

    LEAF_ENTRY _CaptureContext, _TEXT$00
        
        pushfq

        sub rsp, CONTEXT_FRAME_LENGTH - 8

        push rcx

        lea rcx, [rsp]

        and rcx, not 0fh

        pop CxRcx [rcx]
        
        mov CxSegCs [rcx], cs
        mov CxSegDs [rcx], ds
        mov CxSegEs [rcx], es
        mov CxSegSs [rcx], ss
        mov CxSegFs [rcx], fs
        mov CxSegGs [rcx], gs

        mov CxRax [rcx], rax
        mov CxRdx [rcx], rdx
        mov CxRbx [rcx], rbx

        lea rax, CONTEXT_FRAME_LENGTH + StackPointer [rsp]

        mov CxRsp [rcx], rax
        mov CxRbp [rcx], rbp
        mov CxRsi [rcx], rsi
        mov CxRdi [rcx], rdi
        mov CxR8 [rcx], r8
        mov CxR9 [rcx], r9
        mov CxR10 [rcx], r10
        mov CxR11 [rcx], r11
        mov CxR12 [rcx], r12
        mov CxR13 [rcx], r13
        mov CxR14 [rcx], r14
        mov CxR15 [rcx], r15
        
        movdqa CxXmm0 [rcx], xmm0
        movdqa CxXmm1 [rcx], xmm1
        movdqa CxXmm2 [rcx], xmm2
        movdqa CxXmm3 [rcx], xmm3
        movdqa CxXmm4 [rcx], xmm4
        movdqa CxXmm5 [rcx], xmm5
        movdqa CxXmm6 [rcx], xmm6
        movdqa CxXmm7 [rcx], xmm7
        movdqa CxXmm8 [rcx], xmm8
        movdqa CxXmm9 [rcx], xmm9
        movdqa CxXmm10 [rcx], xmm10
        movdqa CxXmm11 [rcx], xmm11
        movdqa CxXmm12 [rcx], xmm12
        movdqa CxXmm13 [rcx], xmm13
        movdqa CxXmm14 [rcx], xmm14
        movdqa CxXmm15 [rcx], xmm15

        stmxcsr CxMxCsr [rcx]
        
        mov rax, CONTEXT_FRAME_LENGTH [rsp - 8]
        mov CxEFlags [rcx], rax

        mov rax, CONTEXT_FRAME_LENGTH + Guard [rsp]
        mov CxRip [rcx], rax

        mov eax, CONTEXT_FULL
        mov CxContextFlags [rcx], eax
        
        mov r9, CONTEXT_FRAME_LENGTH + Reserved [rsp]
        mov r8, CONTEXT_FRAME_LENGTH + Parameter [rsp]
        mov rdx, CONTEXT_FRAME_LENGTH + ProgramCounter [rsp]
        lea rcx, [rcx]
        mov rax, CONTEXT_FRAME_LENGTH + Callback [rsp]

        call rax

    LEAF_END _CaptureContext, _TEXT$00
   
        end

```

`Projects/Shark/AMD64/ExceptAMD64.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>
#include <devicedefs.h>

#include "Except.h"

#include "Scan.h"
#include "Guard.h"
#include "Space.h"

//
// ****** temp - define elsewhere ******
//

#define SIZE64_PREFIX 0x48
#define ADD_IMM8_OP 0x83
#define ADD_IMM32_OP 0x81
#define JMP_IMM8_OP 0xeb
#define JMP_IMM32_OP 0xe9
#define LEA_OP 0x8d
#define POP_OP 0x58
#define RET_OP 0xc3

//
// Define unwind operation codes.
//

typedef enum _AMD64_UNWIND_OP_CODES {
    AMD64_UWOP_PUSH_NONVOL = 0,
    AMD64_UWOP_ALLOC_LARGE,
    AMD64_UWOP_ALLOC_SMALL,
    AMD64_UWOP_SET_FPREG,
    AMD64_UWOP_SAVE_NONVOL,
    AMD64_UWOP_SAVE_NONVOL_FAR,
    AMD64_UWOP_SAVE_XMM,
    AMD64_UWOP_SAVE_XMM_FAR,
    AMD64_UWOP_SAVE_XMM128,
    AMD64_UWOP_SAVE_XMM128_FAR,
    AMD64_UWOP_PUSH_MACHFRAME
} AMD64_UNWIND_OP_CODES, *PAMD64_UNWIND_OP_CODES;

//
// Define lookup table for providing the number of slots used by each unwind
// code.
// 

u8 UnwindOpSlotTable[] = {
    1, // UWOP_PUSH_NONVOL
    2, // UWOP_ALLOC_LARGE (or 3, special cased in lookup code)
    1, // UWOP_ALLOC_SMALL
    1, // UWOP_SET_FPREG
    2, // UWOP_SAVE_NONVOL
    3, // UWOP_SAVE_NONVOL_FAR
    2, // UWOP_SAVE_XMM
    3, // UWOP_SAVE_XMM_FAR
    2, // UWOP_SAVE_XMM128
    3, // UWOP_SAVE_XMM128_FAR
    1 // UWOP_PUSH_MACHFRAME
};

void
NTAPI
InitializeExcept(
    __inout PRTB Block
)
{
    NOTHING;
}

void
NTAPI
InsertInvertedFunctionTable(
    __in ptr ImageBase,
    __in u32 SizeOfImage
)
{
    u32 CurrentSize = 0;
    u32 SizeOfTable = 0;
    u32 Index = 0;
    ptr FunctionTable = NULL;
    PFUNCTION_TABLE_ENTRY64 FunctionTableEntry = NULL;

    if (IPI_LEVEL != KeGetCurrentIrql()) {
        RtBlock.KeEnterCriticalRegion();

        ExAcquireResourceExclusiveLite(RtBlock.PsLoadedModuleResource, TRUE);
    }

    FunctionTableEntry = (PFUNCTION_TABLE_ENTRY64)
        &RtBlock.PsInvertedFunctionTable->TableEntry;

    CurrentSize = RtBlock.PsInvertedFunctionTable->CurrentSize;

    if (RtBlock.DebuggerDataBlock.KernBase ==
        FunctionTableEntry[0].ImageBase) {
        Index = 1;
    }

    if (CurrentSize != RtBlock.PsInvertedFunctionTable->MaximumSize) {
        if (0 != CurrentSize) {
            for (;
                Index < CurrentSize;
                Index++) {
                if ((u)ImageBase < FunctionTableEntry[Index].ImageBase) {
                    RtlMoveMemory(
                        &FunctionTableEntry[Index + 1],
                        &FunctionTableEntry[Index],
                        (CurrentSize - Index) * sizeof(FUNCTION_TABLE_ENTRY64));

                    break;
                }
            }
        }

        CaptureImageExceptionValues(
            ImageBase,
            &FunctionTable,
            &SizeOfTable);

        FunctionTableEntry[Index].ImageBase = (u)ImageBase;
        FunctionTableEntry[Index].SizeOfImage = SizeOfImage;
        FunctionTableEntry[Index].FunctionTable = (u)FunctionTable;
        FunctionTableEntry[Index].SizeOfTable = SizeOfTable;

        RtBlock.PsInvertedFunctionTable->CurrentSize += 1;
    }
    else {
        RtBlock.PsInvertedFunctionTable->Overflow = TRUE;
    }

    if (IPI_LEVEL != KeGetCurrentIrql()) {
        ExReleaseResourceLite(RtBlock.PsLoadedModuleResource);

        RtBlock.KeLeaveCriticalRegion();
    }
}

void
NTAPI
RemoveInvertedFunctionTable(
    __in ptr ImageBase
)
{
    u32 CurrentSize = 0;
    u32 Index = 0;
    PFUNCTION_TABLE_ENTRY64 FunctionTableEntry = NULL;

    if (IPI_LEVEL != KeGetCurrentIrql()) {
        RtBlock.KeEnterCriticalRegion();

        ExAcquireResourceExclusiveLite(RtBlock.PsLoadedModuleResource, TRUE);
    }

    FunctionTableEntry = (PFUNCTION_TABLE_ENTRY64)
        &RtBlock.PsInvertedFunctionTable->TableEntry;

    CurrentSize = RtBlock.PsInvertedFunctionTable->CurrentSize;

    for (Index = 0;
        Index < CurrentSize;
        Index += 1) {
        if ((u)ImageBase == FunctionTableEntry[Index].ImageBase) {
            RtlMoveMemory(
                &FunctionTableEntry[Index],
                &FunctionTableEntry[Index + 1],
                (CurrentSize - Index - 1) * sizeof(FUNCTION_TABLE_ENTRY64));

            RtBlock.PsInvertedFunctionTable->CurrentSize -= 1;

            break;
        }
    }

    if (IPI_LEVEL != KeGetCurrentIrql()) {
        ExReleaseResourceLite(RtBlock.PsLoadedModuleResource);

        RtBlock.KeLeaveCriticalRegion();
    }
}

PRUNTIME_FUNCTION
NTAPI
UnwindPrologue(
    __in u64 ImageBase,
    __in u64 ControlPc,
    __in u64 FrameBase,
    __in PRUNTIME_FUNCTION FunctionEntry,
    __inout PCONTEXT ContextRecord,
    __inout_opt PKNONVOLATILE_CONTEXT_POINTERS ContextPointers
)
/*++

Routine Description:

    This function processes unwind codes and reverses the state change
    effects of a prologue. If the specified unwind information contains
    chained unwind information, then that prologue is unwound recursively.
    As the prologue is unwound state changes are recorded in the specified
    context structure and optionally in the specified context pointers
    structures.

Arguments:

    ImageBase - Supplies the base address of the image that contains the
        function being unwound.

    ControlPc - Supplies the address where control left the specified
        function.

    FrameBase - Supplies the base of the stack frame subject function stack
         frame.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    ContextRecord - Supplies the address of a context record.

    ContextPointers - Supplies an optional pointer to a context pointers
        record.

Return Value:

--*/
{
    PM128A FloatingAddress;
    PM128A FloatingRegister;
    u32 FrameOffset;
    u32 Index;
    u64ptr IntegerAddress;
    u64ptr IntegerRegister;
    b MachineFrame;
    u32 OpInfo;
    u32 PrologOffset;
    u64ptr RegisterAddress;
    u64ptr ReturnAddress;
    u64ptr StackAddress;
    PUNWIND_CODE UnwindCode;
    PUNWIND_INFO UnwindInfo;
    u32 UnwindOp;

    //
    // Process the unwind codes.
    //

    FloatingRegister = &ContextRecord->Xmm0;
    IntegerRegister = &ContextRecord->Rax;
    Index = 0;
    MachineFrame = FALSE;
    PrologOffset = (u32)(ControlPc - (FunctionEntry->BeginAddress + ImageBase));
    UnwindInfo = (PUNWIND_INFO)(FunctionEntry->UnwindData + ImageBase);

    while (Index < UnwindInfo->CountOfCodes) {
        //
        // If the prologue offset is greater than the next unwind code offset,
        // then simulate the effect of the unwind code.
        //

        UnwindOp = UnwindInfo->UnwindCode[Index].UnwindOp;
        OpInfo = UnwindInfo->UnwindCode[Index].OpInfo;

        if (PrologOffset >= UnwindInfo->UnwindCode[Index].CodeOffset) {
            switch (UnwindOp) {
                //
                // Push nonvolatile integer register.
                //
                // The operation information is the register number of the
                // register than was pushed.
                //

            case AMD64_UWOP_PUSH_NONVOL:
                IntegerAddress = (u64ptr)(ContextRecord->Rsp);
                IntegerRegister[OpInfo] = *IntegerAddress;

                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->IntegerContext[OpInfo] = IntegerAddress;
                }

                ContextRecord->Rsp += 8;

                break;

                //
                // Allocate a large sized area on the stack.
                //
                // The operation information determines if the size is
                // 16- or 32-bits.
                //

            case AMD64_UWOP_ALLOC_LARGE:
                Index += 1;
                FrameOffset = UnwindInfo->UnwindCode[Index].FrameOffset;

                if (OpInfo != 0) {
                    Index += 1;
                    FrameOffset += (UnwindInfo->UnwindCode[Index].FrameOffset << 16);
                }
                else {
                    FrameOffset *= 8;
                }

                ContextRecord->Rsp += FrameOffset;

                break;

                //
                // Allocate a small sized area on the stack.
                //
                // The operation information is the size of the unscaled
                // allocation size (8 is the scale factor) minus 8.
                //

            case AMD64_UWOP_ALLOC_SMALL:
                ContextRecord->Rsp += (OpInfo * 8) + 8;

                break;

                //
                // Establish the the frame pointer register.
                //
                // The operation information is not used.
                //

            case AMD64_UWOP_SET_FPREG:
                ContextRecord->Rsp = IntegerRegister[UnwindInfo->FrameRegister];
                ContextRecord->Rsp -= UnwindInfo->FrameOffset * 16;

                break;

                //
                // Save nonvolatile integer register on the stack using a
                // 16-bit displacment.
                //
                // The operation information is the register number.
                //

            case AMD64_UWOP_SAVE_NONVOL:
                Index += 1;
                FrameOffset = UnwindInfo->UnwindCode[Index].FrameOffset * 8;
                IntegerAddress = (u64ptr)(FrameBase + FrameOffset);
                IntegerRegister[OpInfo] = *IntegerAddress;

                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->IntegerContext[OpInfo] = IntegerAddress;
                }

                break;

                //
                // Save nonvolatile integer register on the stack using a
                // 32-bit displacment.
                //
                // The operation information is the register number.
                //

            case AMD64_UWOP_SAVE_NONVOL_FAR:
                Index += 2;
                FrameOffset = UnwindInfo->UnwindCode[Index - 1].FrameOffset;
                FrameOffset += (UnwindInfo->UnwindCode[Index].FrameOffset << 16);
                IntegerAddress = (u64ptr)(FrameBase + FrameOffset);
                IntegerRegister[OpInfo] = *IntegerAddress;

                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->IntegerContext[OpInfo] = IntegerAddress;
                }

                break;

                //
                // Save a nonvolatile XMM(64) register on the stack using a
                // 16-bit displacement.
                //
                // The operation information is the register number.
                //

            case AMD64_UWOP_SAVE_XMM:
                Index += 1;
                FrameOffset = UnwindInfo->UnwindCode[Index].FrameOffset * 8;
                FloatingAddress = (PM128A)(FrameBase + FrameOffset);
                FloatingRegister[OpInfo].Low = FloatingAddress->Low;
                FloatingRegister[OpInfo].High = 0;

                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->FloatingContext[OpInfo] = FloatingAddress;
                }

                break;

                //
                // Save a nonvolatile XMM(64) register on the stack using a
                // 32-bit displacement.
                //
                // The operation information is the register number.
                //

            case AMD64_UWOP_SAVE_XMM_FAR:
                Index += 2;
                FrameOffset = UnwindInfo->UnwindCode[Index - 1].FrameOffset;
                FrameOffset += (UnwindInfo->UnwindCode[Index].FrameOffset << 16);
                FloatingAddress = (PM128A)(FrameBase + FrameOffset);
                FloatingRegister[OpInfo].Low = FloatingAddress->Low;
                FloatingRegister[OpInfo].High = 0;

                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->FloatingContext[OpInfo] = FloatingAddress;
                }

                break;

                //
                // Save a nonvolatile XMM(128) register on the stack using a
                // 16-bit displacement.
                //
                // The operation information is the register number.
                //

            case AMD64_UWOP_SAVE_XMM128:
                Index += 1;
                FrameOffset = UnwindInfo->UnwindCode[Index].FrameOffset * 16;
                FloatingAddress = (PM128A)(FrameBase + FrameOffset);
                FloatingRegister[OpInfo].Low = FloatingAddress->Low;
                FloatingRegister[OpInfo].High = FloatingAddress->High;

                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->FloatingContext[OpInfo] = FloatingAddress;
                }

                break;

                //
                // Save a nonvolatile XMM(128) register on the stack using a
                // 32-bit displacement.
                //
                // The operation information is the register number.
                //

            case AMD64_UWOP_SAVE_XMM128_FAR:
                Index += 2;
                FrameOffset = UnwindInfo->UnwindCode[Index - 1].FrameOffset;
                FrameOffset += (UnwindInfo->UnwindCode[Index].FrameOffset << 16);
                FloatingAddress = (PM128A)(FrameBase + FrameOffset);
                FloatingRegister[OpInfo].Low = FloatingAddress->Low;
                FloatingRegister[OpInfo].High = FloatingAddress->High;

                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->FloatingContext[OpInfo] = FloatingAddress;
                }

                break;

                //
                // Push a machine frame on the stack.
                //
                // The operation information determines whether the machine
                // frame contains an error code or not.
                //

            case AMD64_UWOP_PUSH_MACHFRAME:
                MachineFrame = TRUE;
                ReturnAddress = (u64ptr)(ContextRecord->Rsp);
                StackAddress = (u64ptr)(ContextRecord->Rsp + (3 * 8));

                if (OpInfo != 0) {
                    ReturnAddress += 1;
                    StackAddress += 1;
                }

                ContextRecord->Rip = *ReturnAddress;
                ContextRecord->Rsp = *StackAddress;

                break;

                //
                // Unused codes.
                //

            default:
                break;
            }

            Index += 1;

        }
        else {
            //
            // Skip this unwind operation by advancing the slot index by the
            // number of slots consumed by this operation.
            //

            Index += UnwindOpSlotTable[UnwindOp];

            //
            // Special case any unwind operations that can consume a variable
            // number of slots.
            // 

            switch (UnwindOp) {
                //
                // A non-zero operation information indicates that an
                // additional slot is consumed.
                //

            case AMD64_UWOP_ALLOC_LARGE:
                if (OpInfo != 0) {
                    Index += 1;
                }

                break;

                //
                // No other special cases.
                //

            default:
                break;
            }
        }
    }

    //
    // If chained unwind information is specified, then recursively unwind
    // the chained information. Otherwise, determine the return address if
    // a machine frame was not encountered during the scan of the unwind
    // codes.
    //

    if ((UnwindInfo->Flags & UNW_FLAG_CHAININFO) != 0) {
        Index = UnwindInfo->CountOfCodes;

        if ((Index & 1) != 0) {
            Index += 1;
        }

        FunctionEntry = (PRUNTIME_FUNCTION)(*(u32ptr *)(&UnwindInfo->UnwindCode[Index]) + ImageBase);

        return UnwindPrologue(ImageBase,
            ControlPc,
            FrameBase,
            FunctionEntry,
            ContextRecord,
            ContextPointers);

    }
    else {
        if (MachineFrame == FALSE) {
            ContextRecord->Rip = *(u64ptr)(ContextRecord->Rsp);
            ContextRecord->Rsp += 8;
        }

        return FunctionEntry;
    }
}

PEXCEPTION_ROUTINE
NTAPI
VirtualUnwind(
    __in u32 HandlerType,
    __in u64 ImageBase,
    __in u64 ControlPc,
    __in PRUNTIME_FUNCTION FunctionEntry,
    __inout PCONTEXT ContextRecord,
    __out ptr * HandlerData,
    __out u64ptr EstablisherFrame,
    __inout_opt PKNONVOLATILE_CONTEXT_POINTERS ContextPointers
)
/*++

Routine Description:

    This function virtually unwinds the specified function by executing its
    prologue code backward or its epilogue code forward.

    If a context pointers record is specified, then the address where each
    nonvolatile registers is restored from is recorded in the appropriate
    element of the context pointers record.

Arguments:

    HandlerType - Supplies the handler type expected for the virtual unwind.
        This may be either an exception or an unwind handler.

    ImageBase - Supplies the base address of the image that contains the
        function being unwound.

    ControlPc - Supplies the address where control left the specified
        function.

    FunctionEntry - Supplies the address of the function table entry for the
        specified function.

    ContextRecord - Supplies the address of a context record.

    HandlerData - Supplies a pointer to a variable that receives a pointer
        the the language handler data.

    EstablisherFrame - Supplies a pointer to a variable that receives the
        the establisher frame pointer value.

    ContextPointers - Supplies an optional pointer to a context pointers
        record.

Return Value:

    If control did not leave the specified function in either the prologue
    or an epilogue and a handler of the proper type is associated with the
    function, then the address of the language specific exception handler
    is returned. Otherwise, NULL is returned.

--*/
{
    u64 BranchTarget;
    s32 Displacement;
    u32 FrameRegister;
    u32 Index;
    u32 InEpilogue;
    u64ptr IntegerAddress;
    u64ptr IntegerRegister;
    cptr NextByte;
    u32 PrologOffset;
    u32 RegisterNumber;
    PUNWIND_INFO UnwindInfo;

    //
    // If the specified function does not use a frame pointer, then the
    // establisher frame is the contents of the stack pointer. This may
    // not actually be the real establisher frame if control left the
    // function from within the prologue. In this case the establisher
    // frame may be not required since control has not actually entered
    // the function and prologue entries cannot refer to the establisher
    // frame before it has been established, i.e., if it has not been
    // established, then no save unwind codes should be encountered during
    // the unwind operation.
    //
    // If the specified function uses a frame pointer and control left the
    // function outside of the prologue or the unwind information contains
    // a chained information structure, then the establisher frame is the
    // contents of the frame pointer.
    //
    // If the specified function uses a frame pointer and control left the
    // function from within the prologue, then the set frame pointer unwind
    // code must be looked up in the unwind codes to detetermine if the
    // contents of the stack pointer or the contents of the frame pointer
    // should be used for the establisher frame. This may not atually be
    // the real establisher frame. In this case the establisher frame may
    // not be required since control has not actually entered the function
    // and prologue entries cannot refer to the establisher frame before it
    // has been established, i.e., if it has not been established, then no
    // save unwind codes should be encountered during the unwind operation.
    //
    // N.B. The correctness of these assumptions is based on the ordering of
    //      unwind codes.
    //

    UnwindInfo = (PUNWIND_INFO)(FunctionEntry->UnwindData + ImageBase);
    PrologOffset = (u32)(ControlPc - (FunctionEntry->BeginAddress + ImageBase));

    if (UnwindInfo->FrameRegister == 0) {
        *EstablisherFrame = ContextRecord->Rsp;
    }
    else if ((PrologOffset >= UnwindInfo->SizeOfProlog) ||
        ((UnwindInfo->Flags &  UNW_FLAG_CHAININFO) != 0)) {
        *EstablisherFrame = (&ContextRecord->Rax)[UnwindInfo->FrameRegister];
        *EstablisherFrame -= UnwindInfo->FrameOffset * 16;
    }
    else {
        Index = 0;

        while (Index < UnwindInfo->CountOfCodes) {
            if (UnwindInfo->UnwindCode[Index].UnwindOp == UWOP_SET_FPREG) {
                break;
            }

            Index += 1;
        }

        if (PrologOffset >= UnwindInfo->UnwindCode[Index].CodeOffset) {
            *EstablisherFrame = (&ContextRecord->Rax)[UnwindInfo->FrameRegister];
            *EstablisherFrame -= UnwindInfo->FrameOffset * 16;
        }
        else {
            *EstablisherFrame = ContextRecord->Rsp;
        }
    }

    //
    // Check for epilogue.
    //
    // If the point at which control left the specified function is in an
    // epilogue, then emulate the execution of the epilogue forward and
    // return no exception handler.
    //

    IntegerRegister = &ContextRecord->Rax;
    NextByte = (cptr)ControlPc;

    //
    // Check for one of:
    //
    //   add rsp, imm8
    //       or
    //   add rsp, imm32
    //       or
    //   lea rsp, -disp8[fp]
    //       or
    //   lea rsp, -disp32[fp]
    //

    if ((NextByte[0] == SIZE64_PREFIX) &&
        (NextByte[1] == ADD_IMM8_OP) &&
        (NextByte[2] == 0xc4)) {
        //
        // add rsp, imm8.
        //

        NextByte += 4;

    }
    else if ((NextByte[0] == SIZE64_PREFIX) &&
        (NextByte[1] == ADD_IMM32_OP) &&
        (NextByte[2] == 0xc4)) {
        //
        // add rsp, imm32.
        //

        NextByte += 7;

    }
    else if (((NextByte[0] & 0xf8) == SIZE64_PREFIX) &&
        (NextByte[1] == LEA_OP)) {
        FrameRegister = ((NextByte[0] & 0x7) << 3) | (NextByte[2] & 0x7);

        if ((FrameRegister != 0) &&
            (FrameRegister == UnwindInfo->FrameRegister)) {
            if ((NextByte[2] & 0xf8) == 0x60) {
                //
                // lea rsp, disp8[fp].
                //

                NextByte += 4;

            }
            else if ((NextByte[2] & 0xf8) == 0xa0) {
                //
                // lea rsp, disp32[fp].
                //

                NextByte += 7;
            }
        }
    }

    //
    // Check for any number of:
    //
    //   pop nonvolatile-integer-register[0..15].
    //

    while (TRUE) {
        if ((NextByte[0] & 0xf8) == POP_OP) {
            NextByte += 1;
        }
        else if (((NextByte[0] & 0xf8) == SIZE64_PREFIX) &&
            ((NextByte[1] & 0xf8) == POP_OP)) {
            NextByte += 2;
        }
        else {
            break;
        }
    }

    //
    // If the next instruction is a return, then control is currently in
    // an epilogue and execution of the epilogue should be emulated.
    // Otherwise, execution is not in an epilogue and the prologue should
    // be unwound.
    //

    InEpilogue = FALSE;
    if (NextByte[0] == RET_OP) {
        //
        // A return is an unambiguous indication of an epilogue
        //

        InEpilogue = TRUE;
    }
    else if (NextByte[0] == JMP_IMM8_OP || NextByte[0] == JMP_IMM32_OP) {
        //
        // An unconditional branch to a target that is equal to the start of
        // or outside of this routine is logically a call to another function.
        // 

        BranchTarget = (u64)NextByte - ImageBase;

        if (NextByte[0] == JMP_IMM8_OP) {
            BranchTarget += 2 + (CHAR)NextByte[1];
        }
        else {
            BranchTarget += 5 + *((s32 UNALIGNED *)&NextByte[1]);
        }

        //
        // Now determine whether the branch target refers to code within this
        // function. If not, then it is an epilogue indicator.
        //

        if (BranchTarget <= FunctionEntry->BeginAddress ||
            BranchTarget > FunctionEntry->EndAddress) {
            InEpilogue = TRUE;
        }
    }

    if (InEpilogue != FALSE) {
        NextByte = (cptr)ControlPc;

        //
        // Emulate one of (if any):
        //
        //   add rsp, imm8
        //       or
        //   add rsp, imm32
        //       or                
        //   lea rsp, disp8[frame-register]
        //       or
        //   lea rsp, disp32[frame-register]
        //

        if ((NextByte[0] & 0xf8) == SIZE64_PREFIX) {
            if (NextByte[1] == ADD_IMM8_OP) {
                //
                // add rsp, imm8.
                //

                ContextRecord->Rsp += (CHAR)NextByte[3];
                NextByte += 4;
            }
            else if (NextByte[1] == ADD_IMM32_OP) {
                //
                // add rsp, imm32.
                //

                Displacement = NextByte[3] | (NextByte[4] << 8);
                Displacement |= (NextByte[5] << 16) | (NextByte[6] << 24);
                ContextRecord->Rsp += Displacement;
                NextByte += 7;
            }
            else if (NextByte[1] == LEA_OP) {
                if ((NextByte[2] & 0xf8) == 0x60) {
                    //
                    // lea rsp, disp8[frame-register].
                    //

                    ContextRecord->Rsp = IntegerRegister[FrameRegister];
                    ContextRecord->Rsp += (CHAR)NextByte[3];
                    NextByte += 4;
                }
                else if ((NextByte[2] & 0xf8) == 0xa0) {
                    //
                    // lea rsp, disp32[frame-register].
                    //

                    Displacement = NextByte[3] | (NextByte[4] << 8);
                    Displacement |= (NextByte[5] << 16) | (NextByte[6] << 24);
                    ContextRecord->Rsp = IntegerRegister[FrameRegister];
                    ContextRecord->Rsp += Displacement;
                    NextByte += 7;
                }
            }
        }

        //
        // Emulate any number of (if any):
        //
        //   pop nonvolatile-integer-register.
        //

        while (TRUE) {
            if ((NextByte[0] & 0xf8) == POP_OP) {
                //
                // pop nonvolatile-integer-register[0..7]
                //

                RegisterNumber = NextByte[0] & 0x7;
                IntegerAddress = (u64ptr)ContextRecord->Rsp;
                IntegerRegister[RegisterNumber] = *IntegerAddress;

                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->IntegerContext[RegisterNumber] = IntegerAddress;
                }

                ContextRecord->Rsp += 8;
                NextByte += 1;
            }
            else if (((NextByte[0] & 0xf8) == SIZE64_PREFIX) &&
                ((NextByte[1] & 0xf8) == POP_OP)) {
                //
                // pop nonvolatile-integer-regiser[8..15]
                //

                RegisterNumber = ((NextByte[0] & 1) << 3) | (NextByte[1] & 0x7);
                IntegerAddress = (u64ptr)ContextRecord->Rsp;
                IntegerRegister[RegisterNumber] = *IntegerAddress;

                if (ARGUMENT_PRESENT(ContextPointers)) {
                    ContextPointers->IntegerContext[RegisterNumber] = IntegerAddress;
                }

                ContextRecord->Rsp += 8;
                NextByte += 2;

            }
            else {
                break;
            }
        }

        //
        // Emulate return and return null exception handler.
        //
        // Note: this instruction might in fact be a jmp, however
        //       we want to emulate a return regardless.
        //

        ContextRecord->Rip = *(u64ptr)(ContextRecord->Rsp);
        ContextRecord->Rsp += 8;
        return NULL;
    }

    //
    // Control left the specified function outside an epilogue. Unwind the
    // subject function and any chained unwind information.
    //

    FunctionEntry = UnwindPrologue(ImageBase,
        ControlPc,
        *EstablisherFrame,
        FunctionEntry,
        ContextRecord,
        ContextPointers);

    //
    // If control left the specified function outside of the prologue and
    // the function has a handler that matches the specified type, then
    // return the address of the language specific exception handler.
    // Otherwise, return NULL.
    //

    UnwindInfo = (PUNWIND_INFO)(FunctionEntry->UnwindData + ImageBase);
    PrologOffset = (u32)(ControlPc - (FunctionEntry->BeginAddress + ImageBase));

    if ((PrologOffset >= UnwindInfo->SizeOfProlog) &&
        ((UnwindInfo->Flags & HandlerType) != 0)) {
        Index = UnwindInfo->CountOfCodes;

        if ((Index & 1) != 0) {
            Index += 1;
        }

        *HandlerData = &UnwindInfo->UnwindCode[Index + 2];

        return (PEXCEPTION_ROUTINE)(*((u32ptr)&UnwindInfo->UnwindCode[Index]) + ImageBase);
    }
    else {
        return NULL;
    }
}

```

`Projects/Shark/AMD64/PatchGuardAMD64.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "PatchGuard.h"

#include "Ctx.h"  
#include "Except.h"
#include "Guard.h"
#include "Rtx.h"
#include "Scan.h"
#include "Space.h"
#include "Stack.h"

void
NTAPI
PgFreeWorker(
    __in PPGOBJECT Object
)
{
    PPGBLOCK Block = NULL;

    GetCounterBody(
        &Object->Body.Reserved,
        &Block);

    if (PgPoolBigPage == Object->Type) {
        GetRtBlock(Block)->ExFreePoolWithTag(
            Object->BaseAddress,
            0);
    }
    else if (PgSystemPtes == Object->Type) {
        Block->MmFreeIndependentPages(
            Object->BaseAddress,
            Object->RegionSize);
    }
    else if (PgMaximumType == Object->Type) {
        NOTHING;
    }

    GetRtBlock(Block)->ExFreePoolWithTag(Object, 0);
}

void
NTAPI
PgClearCallback(
    __in PCONTEXT Context,
    __in_opt ptr ProgramCounter,
    __in_opt PPGOBJECT Object,
    __in_opt PPGBLOCK Block
)
{
    PETHREAD Thread = NULL;
    PKSTART_FRAME StartFrame = NULL;
    PKSWITCH_FRAME SwitchFrame = NULL;
    PKTRAP_FRAME TrapFrame = NULL;

    if (NULL != Object) {
        GetCounterBody(
            &Object->Body.Reserved,
            &Block);

#ifdef DEBUG
        GetRtBlock(Block)->vDbgPrint(
            Block->ClearMessage[Object->Encrypted],
            Object);
#endif // DEBUG

        GetRtBlock(Block)->ExInterlockedRemoveHeadList(
            Object->Entry.Blink,
            &Block->Lock);

        if (PgDoubleEncrypted == Object->Encrypted) {
            Context->Rip = __rduptr(Context->Rsp);
            Context->Rsp += sizeof(ptr);

            ExInitializeWorkItem(
                &Object->Worker, Block->FreeWorker, Object);

            Block->ExQueueWorkItem(
                &Object->Worker, CriticalWorkQueue);
        }
        else if (PgEncrypted == Object->Encrypted) {
            Context->Rip = __rduptr(Context->Rsp + KSTART_FRAME_LENGTH);
            Context->Rsp += KSTART_FRAME_LENGTH + sizeof(ptr);

            ExInitializeWorkItem(
                &Object->Worker, Block->FreeWorker, Object);

            Block->ExQueueWorkItem(
                &Object->Worker, CriticalWorkQueue);
        }
        else {
            Thread = (PETHREAD)__readgsqword(FIELD_OFFSET(KPCR, Prcb.CurrentThread));

            if (GetRtBlock(Block)->BuildNumber >= 18362) {
                // ETHREAD->ReservedCrossThreadFlags
                // clear SameThreadPassiveFlags Bit 0 (BugCheck 139)

                *((u8 *)Thread + Block->OffsetSameThreadPassive) &= 0xFFFFFFFE;
            }

            StartFrame =
                (PKSTART_FRAME)(
                (*(u64ptr)((u64)Thread +
                    GetRtBlock(Block)->DebuggerDataBlock.OffsetKThreadInitialStack)) -
                    KSTART_FRAME_LENGTH);

            StartFrame->P1Home = (u64)Block->WorkerContext;
            StartFrame->P2Home = (u64)Block->ExpWorkerThread;
            StartFrame->P3Home = (u64)Block->PspSystemThreadStartup;
            StartFrame->Return = 0;

            SwitchFrame = (PKSWITCH_FRAME)((u64)StartFrame - KSWITCH_FRAME_LENGTH);

            SwitchFrame->Return = (u64)Block->KiStartSystemThread;
            SwitchFrame->ApcBypass = APC_LEVEL;
            SwitchFrame->Rbp = (u64)TrapFrame + FIELD_OFFSET(KTRAP_FRAME, Xmm1);

            Context->Rsp = (u64)StartFrame;
            Context->Rip = (u64)Block->KiStartSystemThread;

            ExInitializeWorkItem(
                &Object->Worker, Block->FreeWorker, Object);

            Block->ExQueueWorkItem(
                &Object->Worker, CriticalWorkQueue);
        }

        GetRtBlock(Block)->RtlRestoreContext(Context, NULL);
    }
    else {
        __debugbreak();
    }
}

void
NTAPI
InitializePgBlock(
    __inout PPGBLOCK Block
)
{
    status Status = STATUS_SUCCESS;
    ptr FileHandle = NULL;
    ptr SectionHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    ptr ViewBase = NULL;
    u ViewSize = 0;
    u64 ImageBase = 0;
    u8ptr ControlPc = NULL;
    u8ptr TargetPc = NULL;
    u32 Length = 0;
    u Index = 0;
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    PIMAGE_SECTION_HEADER NtSection = NULL;
    ptr EndToLock = NULL;
    PRUNTIME_FUNCTION FunctionEntry = NULL;
    LONG64 Diff = 0;
    UNICODE_STRING RoutineString = { 0 };
    ptr RoutineAddress = NULL;
    u8 Selector = 0;

    PPOOL_BIG_PAGES * PageTable = NULL;
    uptr PageTableSize = NULL;
    PRTL_BITMAP BitMap = NULL;

    ptr Address = NULL;
    PMMPTE PointerPte = NULL;

    u TempField = 0;

    s8 CmpAppendDllSection[] = "2E 48 31 11 48 31 51 08 48 31 51 10 48 31 51 18";

    // Fields
    s8 Fields[] = "FB 48 8D 05";
    s8 FirstField[] = "?? 89 ?? 00 01 00 00 48 8D 05 ?? ?? ?? ?? ?? 89 ?? 08 01 00 00";
    s8 NextField[] = "48 8D 05 ?? ?? ?? ?? ?? 89 86 ?? ?? 00 00";

    // BranchKey

    // 48 8D 05 B7 08 72 FF                     lea     rax, KiDispatchCallout
    // 49 89 86 E8 09 00 00                     mov     [r14 + 9E8h], rax
    // 48 8D 05 39 DD 79 FF                     lea     rax, xHalTimerWatchdogStop
    // 49 89 86 F0 09 00 00                     mov     [r14 + 9F0h], rax
    // 41 C7 86 54 09 00 00 60 68 00 59         mov     dword ptr [r14 + 954h], 59006860h
    // E9 4F 02 00 00                           jmp     loc_1409D48BD
    // 83 F8 05                                 cmp     eax, 5
    // 0F 85 3C 02 00 00                        jnz     loc_1409D48B3
    // 45 8B 86 10 08 00 00                     mov     r8d, [r14 + 810h]
    // 0F 31                                    rdtsc

    // 8B 84 24 60 24 00 00                     mov     eax, [rsp + 2458h + arg_0]
    // BA 05 00 00 00                           mov     edx, 5
    // 3B C2                                    cmp     eax, edx
    // 0F 86 C8 06 00 00                        jbe     loc_1409E5933
    // 48 8D 3D 8E 4A 98 FF                     lea     rdi, KiTimerDispatch
    // 83 F8 06                                 cmp     eax, 6
    // 0F 84 8E 0A 00 00                        jz      loc_1409E5D09
    // 83 F8 07                                 cmp     eax, 7
    // 0F 84 77 0A 00 00                        jz      loc_1409E5CFB
    // 83 F8 08                                 cmp     eax, 8
    // 0F 84 60 0A 00 00                        jz      loc_1409E5CED
    // 83 F8 09                                 cmp     eax, 9
    // 0F 84 49 0A 00 00                        jz      loc_1409E5CDF
    // 0F 31                                    rdtsc

    // 48 F7 E1                                 mul     rcx
    // 48 8B C1                                 mov     rax, rcx
    // 48 2B C2                                 sub     rax, rdx
    // 48 D1 E8                                 shr     rax, 1
    // 48 03 C2                                 add     rax, rdx
    // 48 C1 E8 02                              shr     rax, 2
    // 48 6B C0 07                              imul    rax, 7
    // 48 2B C8                                 sub     rcx, rax
    // 8B C1                                    mov     eax, ecx
    // 48 8D 15 B1 52 05 00                     lea     rdx, off_140A3EE80
    // 48 8B 14 C2                              mov     rdx, [rdx+rax*8]
    // 48 8B 86 90 06 00 00                     mov     rax, [rsi+690h]
    // 48 8B 4C 24 40                           mov     rcx, [rsp+0A8h+var_68]
    // 48 89 14 01                              mov     [rcx+rax], rdx
    // 48 8B 86 A0 06 00 00                     mov     rax, [rsi+6A0h]
    // 48 89 14 01                              mov     [rcx+rax], rdx
    // 48 89 8E 98 09 00 00                     mov     [rsi+998h], rcx
    // C7 86 54 09 00 00 72 68 80 F8            mov     dword ptr [rsi+954h], 0F8806872h
    // 0F 31                                    rdtsc
    // 48 C1 E2 20                              shl     rdx, 20h

    s8ptr BranchKey[] = {
        "48 8D 05 ?? ?? ?? ?? 49 89 86 ?? ?? 00 00 41 C7 86 ?? ?? 00 00 ?? ?? ?? ?? E9 ?? ?? ?? ?? 83 F8 05",
        "8B 84 24 ?? ?? ?? ?? ?? 05 00 00 00 3B ?? 0F 86 ?? ?? ?? ?? ?? 8D ?? ?? ?? ?? ?? 83 F8 06",
        "48 F7 E1 48 8B C1 48 2B C2 48 D1 E8 48 03 C2 48 C1 E8 02 48 6B C0 07 48 2B C8 8B C1 48 8D"
    };

    // only 9600 and later
    // KeSetTimerEx
    // 48 8B 05 18 50 22 00                     mov     rax, cs:KiWaitNever

    s8 KiWaitNever[] = "48 B8 00 00 00 00 80 F7 FF FF";

    // 48 8B 1D E9 50 22 00                     mov     rbx, cs:KiWaitAlways

    s8 KiWaitAlways[] = "FB B8 00 00 14 00 33 D2 F7";

    s8 KiStartSystemThread[] = "B9 01 00 00 00 44 0F 22 C1 48 8B 14 24 48 8B 4C 24 08";
    s8 PspSystemThreadStartup[] = "EB ?? B9 1E 00 00 00 E8";

    // 7600 ~ 7601
    // 48 83 3D F5 DF 0C 00 00                  cmp     cs:PoolBigPageTable, 0
    // 75 10                                    jnz     short loc_140150235
    // 4D 85 C0                                 test    r8, r8
    // 74 04                                    jz      short loc_14015022E
    // 41 83 20 00                              and     dword ptr [r8], 0
    // 33 C0                                    xor     eax, eax
    // E9 DB 02 00 00                           jmp     loc_140150510
    // 48 8B 35 D4 DF 0C 00                     mov     rsi, cs:PoolBigPageTableSize

    // 9200 ~ 18950
    // 83 FE 01                                 cmp     esi, 1
    // 75 10                                    jnz     short loc_1401BDE4E
    // 48 8B 15 8B 36 0D 00                     mov     rdx, cs:PoolBigPageTable
    // 48 8B 35 9C 36 0D 00                     mov     rsi, cs:PoolBigPageTableSize
    // EB 29                                    jmp     short loc_1401BDE77

    // 19041
    // 40 8A F0                                 mov     sil, al
    // 83 BC 24 B0 00 00 00 01                  cmp     dword ptr [rsp+0B0h], 1
    // 75 15                                    jnz     short loc_1405BBE06
    // 48 8B 15 60 AA 65 00                     mov     rdx, cs:PoolBigPageTable
    // 48 8B 0D 71 AA 65 00                     mov     rcx, cs:PoolBigPageTableSize
    // 48 89 4C 24 40                           mov     [rsp+40h], rcx
    // EB 1A                                    jmp     short loc_1405BBE20

    // 20279
    // 40 8A F0                                 mov     sil, al
    // 41 83 FE 01                              cmp     r14d, 1
    // 75 10                                    jnz     short loc_14061C6D5
    // 48 8B 15 2C 0D 60 00                     mov     rdx, cs:qword_140C1D3F8
    // 4C 8B 35 3D 0D 60 00                     mov     r14, cs:qword_140C1D410
    // EB 15                                    jmp     short loc_14061C6EA

    // 21327
    // 40 8A F0                                 mov     sil, al
    // 41 83 FE 01                              cmp     r14d, 1
    // 75 1A                                    jnz     short loc_140624CCE
    // 48 8B 15 BD C8 5E 00                     mov     rdx, cs:PoolBigPageTable
    // 48 89 54 24 48                           mov     [rsp+98h+Src], rdx
    // 48 8B 0D C9 C8 5E 00                     mov     rcx, cs:PoolBigPageTableSize
    // 48 89 4C 24 40                           mov     [rsp+98h+var_58], rcx
    // EB 19                                    jmp     short loc_140624CE7

    struct {
        u8 Offset[4];
        u8ptr Signature;
    } ExGetBigPoolInfo[] = {
        { 3, 1, 0x1D, 0, "48 83 3D ?? ?? ?? ?? 00 75 10 4D 85 C0 74 04 41 83 20 00 33 C0" },
        { 8, 0, 0xF, 0, "83 ?? 01 75 10 48 8B 15 ?? ?? ?? ?? ?? 8B ?? ?? ?? ?? ?? EB" },
        { 0xD, 0, 0x14, 0, "83 BC 24 ?? 00 00 00 01 75 15 48 8B 15 ?? ?? ?? ?? 48 8B" },
        { 0xC, 0, 0x13, 0, "40 8A F0 41 83 FE 01 75 ?? 48 8B 15" },
        { 0xC, 0, 0x18, 0, "40 8A F0 41 83 FE 01 75 ?? 48 8B 15" }
    };

    // 48 B8 00 00 00 00 00 80 FF FF	        mov     rax, 0FFFF800000000000h
    // 48 3B C8                     	        cmp     rcx, rax
    // 72 1D                        	        jb      short loc_14020A90C
    // 48 C1 E9 27                  	        shr     rcx, 27h
    // 81 E1 FF 01 00 00            	        and     ecx, 1FFh
    // 8D 81 00 FF FF FF            	        lea     eax, [rcx-100h]
    // 48 8D 0D 02 7F A4 00         	        lea     rcx, unk_140C52808
    // 0F B6 04 08                  	        movzx   eax, byte ptr [rax+rcx]

    s8 MiGetSystemRegionType[] =
        "48 c1 e9 27 81 e1 ff 01 00 00 8d 81 00 ff ff ff 48 8d 0d";

    // 55                                       push    rbp
    // 41 54                                    push    r12
    // 41 55                                    push    r13
    // 41 56                                    push    r14
    // 41 57                                    push    r15
    // 48 81 EC C0 02 00 00                     sub     rsp, 2C0h
    // 48 8D A8 D8 FD FF FF                     lea     rbp, [rax - 228h]
    // 48 83 E5 80                              and     rbp, 0FFFFFFFFFFFFFF80h

    // 55                                       push    rbp
    // 41 54                                    push    r12
    // 41 55                                    push    r13
    // 41 56                                    push    r14
    // 41 57                                    push    r15
    // 48 8d 68 a1                              lea     rbp, [rax - 5Fh]
    // 48 81 ec b0 00 00 00                     sub     rsp, 0B0h
    // 8b 82 58 09 00 00                        mov     eax, dword ptr [rdx + 958h]

    u8ptr Header[2] = {
        "55 41 54 41 55 41 56 41 57 48 81 EC C0 02 00 00 48 8D A8 D8 FD FF FF 48 83 E5 80",
        "55 41 54 41 55 41 56 41 57 48 8D 68 A1 48 81 EC B0 00 00 00 8B 82"
    };

    s8 ReservedCrossThreadFlags[] =
        "89 83 ?? ?? F0 83 0C 24 00 80 3D ?? ?? ?? ?? ?? 0F";

    u64 Ror64[] = { 0xC3C8D348CA869148 };
    u64 Rol64[] = { 0xC3C0D348CA869148 };
    u64 RorWithBtc64[] = { 0x48C8D348CA869148, 0xCCCCCCCCC3C0BB0F };

    // 4892            xchg    rax, rdx
    // 4801c8          add     rax, rcx
    // c3              ret

    // 4892            xchg    rax, rdx
    // 480fafc1        imul    rax, rcx
    // c3              ret

    u64 PostCache[] = { 0xCCCCC3C801489248, 0xCCC3C1AF0F489248 };

    // 48c7c0c8000000  mov     rax, 0C8h
    // 482bc1          sub     rax, rcx
    // 4833c1          xor     rax, rcx
    // 4887ca          xchg    rcx, rdx
    // 48f7d1          not     rcx
    // 80e13f          and     cl, 3Fh
    // 48d3c8          ror     rax, cl
    // c3              ret

    // 48c7c0c8000000  mov     rax, 0C8h
    // 482bc1          sub     rax, rcx
    // 480fafc1        imul    rax, rcx
    // 4887ca          xchg    rcx, rdx
    // 48f7d1          not     rcx
    // 80e13f          and     cl, 3Fh
    // 48d3c8          ror     rax, cl
    // c3              ret

    u64 PostKey[] = {
        0x48000000C8C0C748, 0xCA8748C13348C12B, 0xD3483FE180D1F748, 0xCCCCCCCCCCCCC3C8,
        0x48000000C8C0C748, 0x8748C1AF0F48C12B, 0x483FE180D1F748CA, 0xCCCCCCCCCCC3C8D3
    };

    cptr ClearMessage[3] = {
        "[SHARK] < %p > declassified context cleared\n",
        "[SHARK] < %p > encrypted context cleared\n",
        "[SHARK] < %p > double encrypted context cleared\n"
    };

#ifdef DEBUG
    vDbgPrint(
        "[SHARK] < %p > Block\n",
        Block);
#endif // DEBUG

    InitializeListHead(&Block->Object);
    KeInitializeSpinLock(&Block->Lock);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &GetRtBlock(Block)->KernelDataTableEntry->FullDllName,
        (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE),
        NULL,
        NULL);

    Status = ZwOpenFile(
        &FileHandle,
        FILE_EXECUTE,
        &ObjectAttributes,
        &IoStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_DELETE,
        0);

    if (NT_SUCCESS(Status)) {
        InitializeObjectAttributes(
            &ObjectAttributes,
            NULL,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL);

        Status = ZwCreateSection(
            &SectionHandle,
            SECTION_MAP_READ | SECTION_MAP_EXECUTE,
            &ObjectAttributes,
            NULL,
            PAGE_EXECUTE,
            SEC_IMAGE,
            FileHandle);

        if (NT_SUCCESS(Status)) {
            Status = ZwMapViewOfSection(
                SectionHandle,
                ZwCurrentProcess(),
                &ViewBase,
                0L,
                0L,
                NULL,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_EXECUTE);

            if (NT_SUCCESS(Status)) {
                Diff =
                    (u64)GetRtBlock(Block)->DebuggerDataBlock.KernBase -
                    (u64)ViewBase;

                ControlPc = ScanBytes(
                    ViewBase,
                    (u8ptr)ViewBase + ViewSize,
                    CmpAppendDllSection);

                if (NULL != ControlPc) {
                    TargetPc = ControlPc;

                    while (0 != _cmpbyte(TargetPc[0], 0x41) &&
                        0 != _cmpbyte(TargetPc[1], 0xff) &&
                        0 != _cmpbyte(TargetPc[2], 0xe0)) {
                        Length = DetourGetInstructionLength(TargetPc);

                        if (0 == Block->SizeCmpAppendDllSection) {
                            if (8 == Length) {
                                if (0 == _cmpbyte(TargetPc[0], 0x48) &&
                                    0 == _cmpbyte(TargetPc[1], 0x31) &&
                                    0 == _cmpbyte(TargetPc[2], 0x84) &&
                                    0 == _cmpbyte(TargetPc[3], 0xca)) {
                                    Block->SizeCmpAppendDllSection = *(u32ptr)(TargetPc + 4);

#ifdef DEBUG
                                    vDbgPrint(
                                        "[SHARK] < %p > SizeCmpAppendDllSection\n",
                                        Block->SizeCmpAppendDllSection);
#endif // DEBUG

                                    if (0 == _cmpbyte(TargetPc[11], 0x48) ||
                                        0 == _cmpbyte(TargetPc[12], 0x0f) ||
                                        0 == _cmpbyte(TargetPc[13], 0xbb) ||
                                        0 == _cmpbyte(TargetPc[14], 0xc0)) {
                                        Block->BtcEnable = TRUE;

#ifdef DEBUG
                                        vDbgPrint(
                                            "[SHARK] < %p > BtcEnable\n",
                                            Block->BtcEnable);
#endif // DEBUG
                                    }

                                    while (0 != _cmpqword(
                                        0x085131481131482E,
                                        *(uptr)TargetPc)) {
                                        TargetPc--;
                                    }

                                    RtlCopyMemory(
                                        Block->_OriginalCmpAppendDllSection,
                                        TargetPc,
                                        sizeof(Block->_OriginalCmpAppendDllSection));

                                    Block->OriginalCmpAppendDllSection =
                                        (ptr)Block->_OriginalCmpAppendDllSection;

#ifdef DEBUG
                                    vDbgPrint(
                                        "[SHARK] < %p > OriginalCmpAppendDllSection\n",
                                        Block->OriginalCmpAppendDllSection);
#endif // DEBUG
                                }
                            }
                        }

                        if (6 == Length) {
                            if (0 == _cmpbyte(TargetPc[0], 0x8b) &&
                                0 == _cmpbyte(TargetPc[1], 0x82)) {
                                Block->OffsetEntryPoint = *(u32ptr)(TargetPc + 2);

#ifdef DEBUG
                                vDbgPrint(
                                    "[SHARK] < %p > OffsetEntryPoint\n",
                                    Block->OffsetEntryPoint);
#endif // DEBUG
                                break;
                            }
                        }

                        TargetPc += Length;
                    }
                }

                ControlPc = ScanBytes(
                    ViewBase,
                    (u8ptr)ViewBase + ViewSize,
                    Header[GetRtBlock(Block)->BuildNumber >= 18362 ? 1 : 0]);

                if (NULL != ControlPc) {
                    TargetPc = ControlPc + Diff;

                    FunctionEntry = RtlLookupFunctionEntry(
                        (u64)TargetPc,
                        (u64ptr)&ImageBase,
                        NULL);

                    if (NULL != FunctionEntry) {
                        TargetPc =
                            (u8ptr)GetRtBlock(Block)->DebuggerDataBlock.KernBase +
                            FunctionEntry->BeginAddress - Diff;

                        RtlCopyMemory(
                            Block->Header,
                            TargetPc,
                            sizeof(Block->Header));
                    }

                    NtSection = SectionTableFromVirtualAddress(
                        ViewBase,
                        ControlPc);

                    if (NULL != NtSection) {
                        Block->SizeINITKDBG =
                            max(NtSection->SizeOfRawData, NtSection->Misc.VirtualSize);

#ifdef DEBUG
                        vDbgPrint(
                            "[SHARK] < %p > SizeINITKDBG\n",
                            Block->SizeINITKDBG);
#endif // DEBUG

                        Block->INITKDBG = __malloc(Block->SizeINITKDBG);

                        if (NULL != Block->INITKDBG) {
                            RtlCopyMemory(
                                Block->INITKDBG,
                                (u8ptr)ViewBase + NtSection->VirtualAddress,
                                Block->SizeINITKDBG);
#ifdef DEBUG
                            vDbgPrint(
                                "[SHARK] < %p > INITKDBG\n",
                                Block->INITKDBG);
#endif // DEBUG
                        }
                    }
                }

                ControlPc = ViewBase;

                while (NULL != ControlPc) {
                    ControlPc = ScanBytes(
                        ControlPc,
                        (u8ptr)ViewBase + ViewSize,
                        Fields);

                    if (NULL != ControlPc) {
                        TargetPc = ScanBytes(
                            ControlPc,
                            ControlPc + Block->OffsetEntryPoint,
                            FirstField);

                        if (NULL != TargetPc) {
                            Block->Fields[0] =
                                (u64)__rva_to_va(TargetPc - 4) + Diff;

#ifdef DEBUG
                            FindAndPrintSymbol(
                                "[SHARK]",
                                (ptr)Block->Fields[0]);
#endif // DEBUG

                            Block->Fields[1] =
                                (u64)__rva_to_va(TargetPc + 10) + Diff;

#ifdef DEBUG
                            FindAndPrintSymbol(
                                "[SHARK]",
                                (ptr)Block->Fields[1]);
#endif // DEBUG

                            Block->Fields[2] =
                                (u64)__rva_to_va(TargetPc + 24) + Diff;

#ifdef DEBUG
                            FindAndPrintSymbol(
                                "[SHARK]",
                                (ptr)Block->Fields[2]);
#endif // DEBUG

                            Block->Fields[3] =
                                (u64)__rva_to_va(TargetPc + 38) + Diff;

#ifdef DEBUG
                            FindAndPrintSymbol(
                                "[SHARK]",
                                (ptr)Block->Fields[3]);
#endif // DEBUG

                            if (GetRtBlock(Block)->BuildNumber >= 9200) {
                                while (TRUE) {
                                    TargetPc = ScanBytes(
                                        TargetPc,
                                        (u8ptr)ViewBase + ViewSize,
                                        NextField);

                                    TempField = (u64)__rva_to_va(TargetPc + 3) + Diff;

                                    if ((u)TempField ==
                                        (u)GetRtBlock(Block)->DbgPrint) {
                                        TempField = (u64)__rva_to_va(TargetPc + 17) + Diff;

                                        RtlCopyMemory(
                                            &Block->MmAllocateIndependentPages,
                                            &TempField,
                                            sizeof(ptr));

#ifdef DEBUG
                                        vDbgPrint(
                                            "[SHARK] < %p > MmAllocateIndependentPages\n",
                                            Block->MmAllocateIndependentPages);
#endif // DEBUG                                         

                                        TempField = (u64)__rva_to_va(TargetPc + 31) + Diff;

                                        RtlCopyMemory(
                                            &Block->MmFreeIndependentPages,
                                            &TempField,
                                            sizeof(ptr));

#ifdef DEBUG
                                        vDbgPrint(
                                            "[SHARK] < %p > MmFreeIndependentPages\n",
                                            Block->MmFreeIndependentPages);
#endif // DEBUG

                                        TempField = (u64)__rva_to_va(TargetPc + 45) + Diff;

                                        RtlCopyMemory(
                                            &Block->MmSetPageProtection,
                                            &TempField,
                                            sizeof(ptr));

#ifdef DEBUG
                                        vDbgPrint(
                                            "[SHARK] < %p > MmSetPageProtection\n",
                                            Block->MmSetPageProtection);
#endif // DEBUG                                

                                        if (NULL != Block->MmAllocateIndependentPages &&
                                            NULL != Block->MmFreeIndependentPages) {
                                            Address =
                                                Block->MmAllocateIndependentPages(PAGE_SIZE, 0);

                                            if (NULL != Address) {
                                                PointerPte = GetPteAddress(Address);

#ifdef DEBUG
                                                vDbgPrint(
                                                    "[SHARK] < %p > test independent page < %p - %08x >\n",
                                                    PointerPte,
                                                    Address,
                                                    PAGE_SIZE);
#endif // DEBUG

                                                PointerPte = NULL;

                                                Block->MmFreeIndependentPages(Address, PAGE_SIZE);

                                                Address = NULL;
                                            }
                                        }
                                    }

                                    if ((u)TempField ==
                                        (u)GetRtBlock(Block)->KeWaitForSingleObject) {
                                        TempField = (u64)__rva_to_va(TargetPc + 59) + Diff;

                                        FunctionEntry = RtlLookupFunctionEntry(
                                            (u64)TempField,
                                            (u64ptr)&ImageBase,
                                            NULL);

                                        if (NULL != FunctionEntry) {
                                            Block->KiScbQueueScanWorker.BeginAddress =
                                                ImageBase + FunctionEntry->BeginAddress;

#ifdef DEBUG
                                            vDbgPrint(
                                                "[SHARK] < %p > KiScbQueueScanWorker\n",
                                                Block->KiScbQueueScanWorker.BeginAddress);
#endif // DEBUG

                                            Block->KiScbQueueScanWorker.EndAddress =
                                                ImageBase + FunctionEntry->EndAddress;

#ifdef DEBUG
                                            vDbgPrint(
                                                "[SHARK] < %p > KiScbQueueScanWorker end\n",
                                                Block->KiScbQueueScanWorker.EndAddress);
#endif // DEBUG
                                        }

                                        break;
                                    }

                                    TargetPc++;
                                }
                            }

                            while (TRUE) {
                                TargetPc = ScanBytes(
                                    TargetPc,
                                    (u8ptr)ViewBase + ViewSize,
                                    NextField);

                                TempField = (u64)__rva_to_va(TargetPc + 3) + Diff;

                                if ((u)TempField ==
                                    (u)GetRtBlock(Block)->PsLoadedModuleList) {
                                    TempField = (u64)__rva_to_va(TargetPc - 11) + Diff;

                                    RtlCopyMemory(
                                        &GetRtBlock(Block)->PsInvertedFunctionTable,
                                        &TempField,
                                        sizeof(ptr));

#ifdef DEBUG
                                    vDbgPrint(
                                        "[SHARK] < %p > PsInvertedFunctionTable\n",
                                        GetRtBlock(Block)->PsInvertedFunctionTable);
#endif // DEBUG

                                    break;
                                }

                                TargetPc++;
                            }

                            if (GetRtBlock(Block)->BuildNumber >= 18362) {
                                TargetPc = ScanBytes(
                                    TargetPc,
                                    (u8ptr)ViewBase + ViewSize,
                                    BranchKey[0]);

                                if (NULL != TargetPc) {
                                    Block->BranchKey[10] = __rds32(TargetPc + 0x15);

#ifdef DEBUG
                                    vDbgPrint(
                                        "[SHARK] < %p > BranchKey[10]\n",
                                        Block->BranchKey[10]);
#endif // DEBUG
                                }

                                TargetPc = ScanBytes(
                                    TargetPc,
                                    (u8ptr)ViewBase + ViewSize,
                                    BranchKey[1]);

                                if (NULL != TargetPc) {
                                    ControlPc = __rva_to_va(TargetPc + 0x10);

                                    Block->BranchKey[0] =
                                        __rds32((u)(__rva_to_va(ControlPc + 0xA)) + 8);

#ifdef DEBUG
                                    vDbgPrint(
                                        "[SHARK] < %p > BranchKey[0]\n",
                                        Block->BranchKey[0]);
#endif // DEBUG

                                    Block->BranchKey[1] =
                                        __rds32((u)(__rva_to_va(ControlPc + 0x13)) + 8);

#ifdef DEBUG
                                    vDbgPrint(
                                        "[SHARK] < %p > BranchKey[1]\n",
                                        Block->BranchKey[1]);
#endif // DEBUG

                                    Block->BranchKey[2] =
                                        __rds32((u)(__rva_to_va(ControlPc + 0x1C)) + 8);

#ifdef DEBUG
                                    vDbgPrint(
                                        "[SHARK] < %p > BranchKey[2]\n",
                                        Block->BranchKey[2]);
#endif // DEBUG

                                    Block->BranchKey[3] =
                                        __rds32((u)(__rva_to_va(ControlPc + 0x25)) + 8);

#ifdef DEBUG
                                    vDbgPrint(
                                        "[SHARK] < %p > BranchKey[3]\n",
                                        Block->BranchKey[3]);
#endif // DEBUG

                                    Block->BranchKey[4] = __rds32(ControlPc + 0x31);

#ifdef DEBUG
                                    vDbgPrint(
                                        "[SHARK] < %p > BranchKey[4]\n",
                                        Block->BranchKey[4]);
#endif // DEBUG

                                    Block->BranchKey[5] =
                                        __rds32((u)(__rva_to_va(ControlPc + 2)) + 8);

#ifdef DEBUG
                                    vDbgPrint(
                                        "[SHARK] < %p > BranchKey[5]\n",
                                        Block->BranchKey[5]);
#endif // DEBUG

                                    ControlPc = TargetPc + 0x1B;

                                    // Block->BranchKey[6] = Block->BranchKey[5];

                                    Block->BranchKey[6] = 0; // same with 5, here use 0.

#ifdef DEBUG
                                    vDbgPrint(
                                        "[SHARK] < %p > BranchKey[6]\n",
                                        Block->BranchKey[6]);
#endif // DEBUG

                                    Block->BranchKey[7] =
                                        __rds32((u)(__rva_to_va(ControlPc + 0xE)) + 8);

#ifdef DEBUG
                                    vDbgPrint(
                                        "[SHARK] < %p > BranchKey[7]\n",
                                        Block->BranchKey[7]);
#endif // DEBUG

                                    Block->BranchKey[8] =
                                        __rds32((u)(__rva_to_va(ControlPc + 0x17)) + 8);

#ifdef DEBUG
                                    vDbgPrint(
                                        "[SHARK] < %p > BranchKey[8]\n",
                                        Block->BranchKey[8]);
#endif // DEBUG

                                    Block->BranchKey[9] =
                                        __rds32((u)(__rva_to_va(ControlPc + 0x20)) + 8);

#ifdef DEBUG
                                    vDbgPrint(
                                        "[SHARK] < %p > BranchKey[9]\n",
                                        Block->BranchKey[9]);
#endif // DEBUG
                                }

                                TargetPc = ScanBytes(
                                    TargetPc,
                                    (u8ptr)ViewBase + ViewSize,
                                    BranchKey[2]);

                                if (NULL != TargetPc) {
                                    Block->BranchKey[11] = __rds32(TargetPc + 0x4A);

#ifdef DEBUG
                                    vDbgPrint(
                                        "[SHARK] < %p > BranchKey[11]\n",
                                        Block->BranchKey[11]);
#endif // DEBUG
                                }
                            }

                            break;
                        }

                        ControlPc++;
                    }
                    else {
                        break;
                    }
                }

                ControlPc = ScanBytes(
                    ViewBase,
                    (u8ptr)ViewBase + ViewSize,
                    KiStartSystemThread);

                if (NULL != ControlPc) {
                    TargetPc = ControlPc;

                    Block->KiStartSystemThread = (ptr)(TargetPc + Diff);

#ifdef DEBUG
                    vDbgPrint(
                        "[SHARK] < %p > KiStartSystemThread\n",
                        Block->KiStartSystemThread);
#endif // DEBUG
                }

                ControlPc = ScanBytes(
                    ViewBase,
                    (u8ptr)ViewBase + ViewSize,
                    PspSystemThreadStartup);

                if (NULL != ControlPc) {
                    TargetPc = (ptr)(ControlPc + Diff);

                    FunctionEntry = RtlLookupFunctionEntry(
                        (u64)TargetPc,
                        (u64ptr)&ImageBase,
                        NULL);

                    if (NULL != FunctionEntry) {
                        Block->PspSystemThreadStartup =
                            (ptr)((u8ptr)GetRtBlock(Block)->DebuggerDataBlock.KernBase +
                                FunctionEntry->BeginAddress);

#ifdef DEBUG
                        vDbgPrint(
                            "[SHARK] < %p > PspSystemThreadStartup\n",
                            Block->PspSystemThreadStartup);
#endif // DEBUG
                    }
                }

                ZwUnmapViewOfSection(ZwCurrentProcess(), ViewBase);
            }

            ZwClose(SectionHandle);
        }

        ZwClose(FileHandle);
    }

    if (GetRtBlock(Block)->BuildNumber >= 9600) {
        RtlInitUnicodeString(&RoutineString, L"KeSetTimerEx");

        TargetPc = MmGetSystemRoutineAddress(&RoutineString);

        if (NULL != TargetPc) {
            FunctionEntry = RtlLookupFunctionEntry(
                (u64)TargetPc,
                (u64ptr)&ImageBase,
                NULL);

            if (NULL != FunctionEntry) {
                do {
                    Length = DetourGetInstructionLength(TargetPc);

                    if (7 == Length) {
                        if (0 == _cmpbyte(TargetPc[0], 0x48) &&
                            0 == _cmpbyte(TargetPc[1], 0x8B)) {
                            ControlPc = __rva_to_va(TargetPc + 3);

                            if (NULL == Block->KiWaitNever) {
                                Block->KiWaitNever = ControlPc;

#ifdef DEBUG
                                vDbgPrint(
                                    "[SHARK] < %p > KiWaitNever\n",
                                    Block->KiWaitNever);
#endif // DEBUG
                            }
                            else {
                                Block->KiWaitAlways = ControlPc;

#ifdef DEBUG
                                vDbgPrint(
                                    "[SHARK] < %p > KiWaitAlways\n",
                                    Block->KiWaitAlways);
#endif // DEBUG

                                break;
                            }
                        }
                    }

                    TargetPc += Length;
                } while (TargetPc < ((u8ptr)ImageBase + FunctionEntry->EndAddress));
            }
        }
    }

    RtlInitUnicodeString(&RoutineString, L"MmIsNonPagedSystemAddressValid");

    Block->Pool.MmIsNonPagedSystemAddressValid = MmGetSystemRoutineAddress(&RoutineString);

#ifdef DEBUG
    vDbgPrint(
        "[SHARK] < %p > MmIsNonPagedSystemAddressValid\n",
        Block->Pool.MmIsNonPagedSystemAddressValid);
#endif // DEBUG

    NtSection = LdrFindSection(
        (ptr)GetRtBlock(Block)->DebuggerDataBlock.KernBase,
        ".text");

    if (NULL != NtSection) {
        ControlPc =
            (u8ptr)GetRtBlock(Block)->DebuggerDataBlock.KernBase +
            NtSection->VirtualAddress;

        EndToLock =
            (u8ptr)GetRtBlock(Block)->DebuggerDataBlock.KernBase +
            NtSection->VirtualAddress +
            max(NtSection->SizeOfRawData, NtSection->Misc.VirtualSize);

        if (GetRtBlock(Block)->BuildNumber >= 7600 &&
            GetRtBlock(Block)->BuildNumber < 9200) {
            Selector = 0;
        }
        else if (GetRtBlock(Block)->BuildNumber >= 9200 &&
            GetRtBlock(Block)->BuildNumber < 19041) {
            Selector = 1;
        }
        else if (GetRtBlock(Block)->BuildNumber >= 19041 &&
            GetRtBlock(Block)->BuildNumber < 20000) {
            Selector = 2;
        }
        else if (GetRtBlock(Block)->BuildNumber >= 20000 &&
            GetRtBlock(Block)->BuildNumber < 21000) {
            Selector = 3;
        }
        else if (GetRtBlock(Block)->BuildNumber >= 21000 &&
            GetRtBlock(Block)->BuildNumber < 22000) {
            Selector = 4;
        }
        else if (GetRtBlock(Block)->BuildNumber >= 22000) {
            Selector = 3;
        }

        ControlPc = ScanBytes(
            ControlPc,
            EndToLock,
            ExGetBigPoolInfo[Selector].Signature);

        if (NULL != ControlPc) {
            Block->Pool.PoolBigPageTable =
                __rva_to_va_ex(
                    ControlPc + ExGetBigPoolInfo[Selector].Offset[0],
                    ExGetBigPoolInfo[Selector].Offset[1]);

#ifdef DEBUG
            vDbgPrint(
                "[SHARK] < %p > PoolBigPageTable\n",
                Block->Pool.PoolBigPageTable);
#endif // DEBUG

            Block->Pool.PoolBigPageTableSize =
                __rva_to_va_ex(
                    ControlPc + ExGetBigPoolInfo[Selector].Offset[2],
                    +ExGetBigPoolInfo[Selector].Offset[3]);

#ifdef DEBUG
            vDbgPrint(
                "[SHARK] < %p > PoolBigPageTableSize\n",
                Block->Pool.PoolBigPageTableSize);
#endif // DEBUG
        }
    }

    RtlInitUnicodeString(&RoutineString, L"MmAllocateMappingAddressEx");

    RoutineAddress = MmGetSystemRoutineAddress(&RoutineString);

    if (NULL == RoutineAddress) {
        RtlInitUnicodeString(&RoutineString, L"MmAllocateMappingAddress");

        RoutineAddress = MmGetSystemRoutineAddress(&RoutineString);
    }

    if (NULL != RoutineAddress) {
        ControlPc = RoutineAddress;

        while (TRUE) {
            Length = DetourGetInstructionLength(ControlPc);

            if (1 == Length) {
                if (0 == _cmpbyte(ControlPc[0], 0xc3)) {
                    break;
                }
            }

            if (7 == Length) {
                if (0 == _cmpbyte(ControlPc[0], 0x48) &&
                    0 == _cmpbyte(ControlPc[1], 0x8d) &&
                    0 == _cmpbyte(ControlPc[2], 0x0d)) {
                    TargetPc = __rva_to_va(ControlPc + 3);

                    // struct _MI_SYSTEM_PTE_TYPE *
                    BitMap = TargetPc;

                    Block->SystemPtes.NumberOfPtes = BitMap->SizeOfBitMap * 8;
#ifdef DEBUG
                    vDbgPrint(
                        "[SHARK] < %p > NumberOfPtes\n",
                        Block->SystemPtes.NumberOfPtes);
#endif // DEBUG

                    if (GetRtBlock(Block)->BuildNumber < 9600) {
                        Block->SystemPtes.BasePte =
                            *(PMMPTE *)((u8ptr)(BitMap + 1) + sizeof(u32) * 2);
                    }
                    else {
                        Block->SystemPtes.BasePte = *(PMMPTE *)(BitMap + 1);
                    }

#ifdef DEBUG
                    vDbgPrint(
                        "[SHARK] < %p > BasePte\n",
                        Block->SystemPtes.BasePte);
#endif // DEBUG

                    break;
                }
            }

            ControlPc += Length;
        }
    }

    RtlCopyMemory(
        Block->_Ror64,
        Ror64,
        sizeof(Block->_Ror64));

    Block->Ror64 = (ptr)Block->_Ror64;

    RtlCopyMemory(
        Block->_Rol64,
        Rol64,
        sizeof(Block->_Rol64));

    Block->Rol64 = (ptr)Block->_Rol64;

    RtlCopyMemory(
        Block->_RorWithBtc64,
        RorWithBtc64,
        sizeof(Block->_RorWithBtc64));

    Block->RorWithBtc64 = (ptr)Block->_RorWithBtc64;

    Block->CmpDecode =
        Block->BtcEnable ?
        (ptr)Block->RorWithBtc64 : (ptr)Block->Ror64;

    if (GetRtBlock(Block)->BuildNumber > 20000) {
        Block->BuildKey = 0x00000009UL;
    }
    else if (GetRtBlock(Block)->BuildNumber == 18362) {
        Block->BuildKey = 0xFFFFFFE6UL;
    }

    Block->CacheCmpAppendDllSection = Block->_CacheCmpAppendDllSection;

    RtlCopyMemory(
        Block->_PostCache,
        PostCache,
        sizeof(Block->_PostCache));

    Block->PostCache =
        GetRtBlock(Block)->BuildNumber > 18362 ?
        (ptr)Block->_PostCache : (ptr)(Block->_PostCache + 8);

    RtlCopyMemory(
        Block->_PostKey,
        PostKey,
        sizeof(Block->_PostKey));

    Block->PostKey =
        GetRtBlock(Block)->BuildNumber >= 18362 ?
        (ptr)Block->_PostKey : (ptr)(Block->_PostKey + 0x20);

    RtlInitUnicodeString(&RoutineString, L"MmIsAddressValid");

    Block->MmIsAddressValid = MmGetSystemRoutineAddress(&RoutineString);

#ifdef DEBUG
    vDbgPrint(
        "[SHARK] < %p > MmIsAddressValid\n",
        Block->MmIsAddressValid);
#endif // DEBUG

    RtlInitUnicodeString(&RoutineString, L"RtlLookupFunctionEntry");

    Block->RtlLookupFunctionEntry = MmGetSystemRoutineAddress(&RoutineString);

#ifdef DEBUG
    vDbgPrint(
        "[SHARK] < %p > RtlLookupFunctionEntry\n",
        Block->RtlLookupFunctionEntry);
#endif // DEBUG

    RtlInitUnicodeString(&RoutineString, L"RtlVirtualUnwind");

    Block->RtlVirtualUnwind = MmGetSystemRoutineAddress(&RoutineString);

#ifdef DEBUG
    vDbgPrint(
        "[SHARK] < %p > RtlVirtualUnwind\n",
        Block->RtlVirtualUnwind);
#endif // DEBUG

    RtlInitUnicodeString(&RoutineString, L"ExQueueWorkItem");

    Block->ExQueueWorkItem = MmGetSystemRoutineAddress(&RoutineString);

#ifdef DEBUG
    vDbgPrint(
        "[SHARK] < %p > ExQueueWorkItem\n",
        Block->ExQueueWorkItem);
#endif // DEBUG

    if (1 != Block->IsDebug) {
        RtlCopyMemory(
            &Block->_CaptureContext[0],
            _CaptureContext,
            RTL_NUMBER_OF(Block->_CaptureContext));

        Block->CaptureContext = (ptr)(u)&Block->_CaptureContext[0];
    }
    else {
        Block->CaptureContext = _CaptureContext;
    }

#ifdef DEBUG
    vDbgPrint(
        "[SHARK] < %p > CaptureContext\n",
        Block->CaptureContext);
#endif // DEBUG

    if (1 != Block->IsDebug) {
        RtlCopyMemory(
            &Block->_ClearMessage[0],
            ClearMessage[0],
            strlen(ClearMessage[0]));

        Block->ClearMessage[0] = &Block->_ClearMessage[0];

        RtlCopyMemory(
            &Block->_ClearMessage[0x40],
            ClearMessage[1],
            strlen(ClearMessage[1]));

        Block->ClearMessage[1] = &Block->_ClearMessage[0x40];

        RtlCopyMemory(
            &Block->_ClearMessage[0x80],
            ClearMessage[2],
            strlen(ClearMessage[2]));

        Block->ClearMessage[2] = &Block->_ClearMessage[0x80];
    }
    else {
        Block->ClearMessage[0] = ClearMessage[0];
        Block->ClearMessage[1] = ClearMessage[1];
        Block->ClearMessage[2] = ClearMessage[2];
    }

    if (1 != Block->IsDebug) {
        RtlCopyMemory(
            &Block->_FreeWorker[0],
            PgFreeWorker,
            RTL_NUMBER_OF(Block->_FreeWorker));

        Block->FreeWorker = (ptr)(u)&Block->_FreeWorker[0];
    }
    else {
        Block->FreeWorker = PgFreeWorker;
    }

#ifdef DEBUG
    vDbgPrint(
        "[SHARK] < %p > FreeWorker\n",
        Block->FreeWorker);
#endif // DEBUG

    if (1 != Block->IsDebug) {
        RtlCopyMemory(
            &Block->_ClearCallback[0],
            PgClearCallback,
            RTL_NUMBER_OF(Block->_ClearCallback));

        Block->ClearCallback = (ptr)(u)&Block->_ClearCallback[0];
    }
    else {
        Block->ClearCallback = PgClearCallback;
    }

#ifdef DEBUG
    vDbgPrint(
        "[SHARK] < %p > ClearCallback\n",
        Block->ClearCallback);
#endif // DEBUG
}

PPGOBJECT
NTAPI
PgCreateObject(
    __in_opt u8 Encrypted,
    __in u8 Type,
    __in ptr BaseAddress,
    __in_opt u RegionSize,
    __in PPGBLOCK Block,
    __in ptr Return,
    __in ptr Callback,
    __in_opt ptr ProgramCounter,
    __in ptr CaptureContext
)
{
    PPGOBJECT Object = NULL;

    Object = __malloc(sizeof(PGOBJECT));

    if (NULL != Object) {
        RtlZeroMemory(Object, sizeof(PGOBJECT));

        Object->Encrypted = Encrypted;
        Object->Type = Type;
        Object->BaseAddress = BaseAddress;
        Object->RegionSize = RegionSize;

        SetStackBody(
            &Object->Body,
            Block,
            Object,
            Callback,
            Return,
            ProgramCounter,
            CaptureContext);

        ExInterlockedInsertTailList(
            &Block->Object, &Object->Entry, &Block->Lock);
    }

    return Object;
}

void
NTAPI
PgSetNewEntry(
    __inout PPGBLOCK Block,
    __in PPGOBJECT Object,
    __in ptr PatchGuardContext,
    __in u64 RorKey
)
{
    u64 LastRorKey = 0;
    u32 RvaOfEntry = 0;
    u64 FieldBuffer[PG_COMPARE_FIELDS_COUNT] = { 0 };
    u32 FieldIndex = 0;
    u32 Index = 0;
    ptr Pointer = NULL;

    // xor code must be align 8 byte;
    // get PatchGuard entry offset in encrypted code

    FieldIndex = (Block->OffsetEntryPoint -
        Block->SizeCmpAppendDllSection) / sizeof(u64);

    RtlCopyMemory(
        FieldBuffer,
        (u8ptr)PatchGuardContext + (Block->OffsetEntryPoint & ~7),
        sizeof(FieldBuffer));

    LastRorKey = RorKey;

    for (Index = 0;
        Index < FieldIndex;
        Index++) {
        LastRorKey = Block->Rol64(LastRorKey, Index);
    }

    for (Index = 0;
        Index < RTL_NUMBER_OF(FieldBuffer);
        Index++) {
        LastRorKey = Block->Rol64(LastRorKey, FieldIndex + Index);
        FieldBuffer[Index] = FieldBuffer[Index] ^ LastRorKey;
    }

    RvaOfEntry = *(u32ptr)((u8ptr)FieldBuffer + (Block->OffsetEntryPoint & 7));

    // copy PatchGuard entry head code to temp bufer and decode

    FieldIndex = (RvaOfEntry - Block->SizeCmpAppendDllSection) / sizeof(u64);

    RtlCopyMemory(
        FieldBuffer,
        (u8ptr)PatchGuardContext + (RvaOfEntry & ~7),
        sizeof(FieldBuffer));

    LastRorKey = RorKey;

    for (Index = 0;
        Index < FieldIndex;
        Index++) {
        LastRorKey = Block->Rol64(LastRorKey, Index);
    }

    for (Index = 0;
        Index < RTL_NUMBER_OF(FieldBuffer);
        Index++) {
        LastRorKey = Block->Rol64(LastRorKey, FieldIndex + Index);
        FieldBuffer[Index] = FieldBuffer[Index] ^ LastRorKey;
    }

    // set temp buffer PatchGuard entry head jmp to PgClearCallback and encrypt

    Pointer = (u8ptr)FieldBuffer + (RvaOfEntry & 7);

    LockedBuildJumpCode(&Pointer, &Object->Body);

    while (Index--) {
        FieldBuffer[Index] = FieldBuffer[Index] ^ LastRorKey;
        LastRorKey = Block->Ror64(LastRorKey, FieldIndex + Index);
    }

    // copy temp buffer PatchGuard entry head to old address, 
    // when PatchGuard code decrypt self jmp PgClearCallback.

    RtlCopyMemory(
        (u8ptr)PatchGuardContext + (RvaOfEntry & ~7),
        FieldBuffer,
        sizeof(FieldBuffer));

#ifdef DEBUG
    vDbgPrint(
        "[SHARK] < %p > set new entry for encrypted context\n",
        Object);
#endif // DEBUG
}

u
NTAPI
PgScanEntryWithBtc(
    __inout PPGBLOCK Block,
    __in PPGOBJECT Object,
    __out u32ptr AlignOffset,
    __out uptr LastKey
)
{
    u Result = 0;
    u64 RorKey = 0;
    u32 Index = 0;
    u32 Align = 0;
    u64ptr ControlPc = NULL;
    u64ptr TargetPc = NULL;
    u32 CompareCount = 0;

    // xor decrypt must align 8 bytes
    CompareCount = (Object->ContextSize - Block->SizeCmpAppendDllSection) / 8 - 1;
    TargetPc = (ptr)((u)Object->Context + Block->SizeCmpAppendDllSection);

    do {
        ControlPc = (ptr)(Block->Header + Align);

        for (Index = 0;
            Index < CompareCount;
            Index++) {
            RorKey = TargetPc[Index + 1] ^ ControlPc[1];

            *LastKey = RorKey;

            RorKey = Block->CmpDecode(RorKey, Index + 1);

            if ((TargetPc[Index] ^ RorKey) == ControlPc[0]) {
                Result = Index;
                *AlignOffset = Align;

                break;
            }
        }

        Align++;
    } while (Align < 8 && Index == CompareCount);

    return Result;
}

void
NTAPI
PgSetNewEntryWithBtc(
    __inout PPGBLOCK Block,
    __in PPGOBJECT Object
)
{
    u64 RorKey = 0;
    u64 LastRorKey = 0;
    u32 LastRorKeyOffset = 0;
    u64 FieldBuffer[PG_COMPARE_FIELDS_COUNT] = { 0 };
    u32 FieldIndex = 0;
    u32 AlignOffset = 0;
    u32 Index = 0;
    u64ptr ControlPc = NULL;
    u64ptr TargetPc = NULL;
    u32 CompareCount = 0;
    ptr Pointer = NULL;

    Index = PgScanEntryWithBtc(
        Block,
        Object,
        &AlignOffset,
        &LastRorKey);

    if (0 == Index) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > entrypoint not found!\n",
            Object);
#endif // DEBUG
    }
    else {
        FieldIndex = Index - (0 == (AlignOffset & 7) ? 0 : 1);
        LastRorKeyOffset = 2 + (0 == (AlignOffset & 7) ? 0 : 1);

        RtlCopyMemory(
            FieldBuffer,
            (u8ptr)Object->Context + Block->SizeCmpAppendDllSection + FieldIndex * sizeof(u),
            sizeof(FieldBuffer));

        RorKey = LastRorKey;
        Index = LastRorKeyOffset;

        while (Index--) {
            FieldBuffer[Index] = FieldBuffer[Index] ^ RorKey;
            RorKey = Block->CmpDecode(RorKey, FieldIndex + Index);
        }

        // set temp buffer PatchGuard entry head jmp to PgClearCallback and encrypt

        Pointer = (PGUARD_BODY)((u8ptr)FieldBuffer + sizeof(u) - AlignOffset);

        LockedBuildJumpCode(&Pointer, &Object->Body);

        RorKey = LastRorKey;
        Index = LastRorKeyOffset;

        while (Index--) {
            FieldBuffer[Index] = FieldBuffer[Index] ^ RorKey;
            RorKey = Block->CmpDecode(RorKey, FieldIndex + Index);
        }

        RtlCopyMemory(
            (u8ptr)Object->Context + Block->SizeCmpAppendDllSection + FieldIndex * sizeof(u),
            FieldBuffer,
            sizeof(FieldBuffer));

#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > set new entry for btc encrypted context\n",
            Object);
#endif // DEBUG
    }
}

b
NTAPI
PgFastScanTimer(
    __inout PPGBLOCK Block,
    __in ptr Context
)
{
    b Result = 0;
    u ControlPc = 0;
    u Original = 0;
    u Key = 0;
    u ControlKey = 0;
    u Index = 0;
    u KeyIndex = 0;
    u Count = 3;
    u XorKey = 0;
    u Cache = 0;

    u8 KeyTable[] = {
        0x00, 0x03, 0x05, 0x08, 0x06, 0x09, 0x0C, 0x07, 0x0D, 0x0A, 0x0E, 0x04, 0x01, 0x0F, 0x0B, 0x02
    };

    ControlKey = (u)Context;
    ControlKey = Block->Ror64(ControlKey, ControlKey & 0x3F);

    do {
        ControlPc = (u)Context + Index * 8;
        Cache = Original = __rdu64(ControlPc);
        Cache = Original ^ ControlKey;
        Cache += Block->PostCache(Index, Context);

        ControlKey ^= Block->PostKey(Index, Original);

        ControlKey = Block->Rol64(
            ControlKey,
            (0 == Block->BuildKey ? ~Original : Original ^ Block->BuildKey) & 0x3F);

        ControlKey += (u)Context;

        for (KeyIndex = 0;
            KeyIndex < 0x10;
            KeyIndex++) {
            Cache = Block->Rol64(Cache, 4);

            Key = KeyTable[Cache & 0xF];

            Cache &= 0xFFFFFFFFFFFFFFF0ULL;
            Cache |= Key;
        }

        __wruptr(Block->CacheCmpAppendDllSection + Index, Cache);

        Index++;
    } while (Index < Count);

    XorKey =
        Block->OriginalCmpAppendDllSection[1] ^ Block->CacheCmpAppendDllSection[1];

    if ((Block->OriginalCmpAppendDllSection[2] ^ Block->CacheCmpAppendDllSection[2]) == XorKey) {
        Result = TRUE;
    }

    return Result;
}

u
NTAPI
PgFastScanBranch(
    __inout PPGBLOCK Block,
    __in ptr Context,
    __inout u32 BranchKey
)
{
    u Result = 0;
    u ControlPc = 0;
    u Original = 0;
    u Key = 0;
    u ControlKey = 0;
    u Index = 0;
    u KeyIndex = 0;
    u Count = 3;
    u XorKey = 0;
    u Cache = 0;

    u8 KeyTable[] = {
        0x00, 0x03, 0x05, 0x08, 0x06, 0x09, 0x0C, 0x07, 0x0D, 0x0A, 0x0E, 0x04, 0x01, 0x0F, 0x0B, 0x02
    };

    ControlKey = (u)Context;
    ControlKey = Block->Ror64(ControlKey, ControlKey & 0x3F);

    do {
        ControlPc = (u)Context + Index * 8;
        Cache = Original = __rdu64(ControlPc);

        Cache ^= *Block->KiWaitNever;

        Cache =
            Block->Rol64(Cache, *Block->KiWaitNever) ^ ControlKey;

        Cache =
            _byteswap_uint64(Cache);

        Cache ^= *Block->KiWaitAlways;
        Cache += Block->PostCache(Index, Context);

        ControlKey ^= Block->PostKey(Index, Original);

        ControlKey = Block->Rol64(
            ControlKey,
            (0 == Block->BuildKey ? ~Original : Original ^ Block->BuildKey) & 0x3F);

        ControlKey += (u)Context;
        ControlKey ^= BranchKey;

        for (KeyIndex = 0;
            KeyIndex < 0x10;
            KeyIndex++) {
            Cache = Block->Rol64(Cache, 4);

            Key = KeyTable[Cache & 0xF];

            Cache &= 0xFFFFFFFFFFFFFFF0ULL;
            Cache |= Key;
        }

        __wruptr(Block->CacheCmpAppendDllSection + Index, Cache);

        Index++;
    } while (Index < Count);

    XorKey =
        Block->OriginalCmpAppendDllSection[1] ^ Block->CacheCmpAppendDllSection[1];

    if ((Block->OriginalCmpAppendDllSection[2] ^ Block->CacheCmpAppendDllSection[2]) == XorKey) {
        Result = TRUE;
    }

    return Result;
}

void
NTAPI
PgSetTimerNewEntry(
    __inout PPGBLOCK Block,
    __in PPGOBJECT Object
)
{
    u Original = 0;
    u Key = 0;
    u ControlKey = 0;
    u Index = 0;
    u KeyIndex = 0;
    u Count = 0;
    u Cache = 0;
    ptr Pointer = NULL;
    b Pass = FALSE;

    u8 KeyTable[] = {
        0x00, 0x03, 0x05, 0x08, 0x06, 0x09, 0x0C, 0x07, 0x0D, 0x0A, 0x0E, 0x04, 0x01, 0x0F, 0x0B, 0x02,
        0x00, 0x0C, 0x0F, 0x01, 0x0B, 0x02, 0x04, 0x07, 0x03, 0x05, 0x09, 0x0E, 0x06, 0x08, 0x0A, 0x0D
    };

    Count = 0xC8 / 8;

    ControlKey = (u)(Object->Context);
    ControlKey = Block->Ror64(ControlKey, ControlKey & 0x3F);

    do {
        Cache = Original = __rdu64((u)(Object->Context) + Index * 8);
        Cache = Original ^ ControlKey;
        Cache += Block->PostCache(Index, Object->Context);

        ControlKey ^= Block->PostKey(Index, Original);

        ControlKey = Block->Rol64(
            ControlKey,
            (0 == Block->BuildKey ? ~Original : Original ^ Block->BuildKey) & 0x3F);

        ControlKey += (u)(Object->Context);

        for (KeyIndex = 0;
            KeyIndex < 0x10;
            KeyIndex++) {
            Cache = Block->Rol64(Cache, 4);

            Key = KeyTable[Cache & 0xF];

            Cache &= 0xFFFFFFFFFFFFFFF0ULL;
            Cache |= Key;

            if (FALSE != Pass) break;
        }

        __wru64((u)(Object->Context) + Index * 8, Cache);

        Index++;

        if (Index == (0xC8 / 8)) {
            Object->Key =
                Block->OriginalCmpAppendDllSection[1] ^ Block->CacheCmpAppendDllSection[1];

            Count = Cache ^ Object->Key;
            Count >>= 0x20;
            Count &= 0xFFFFFFFFUL;
            Count += 0xC8 / 8;

            Object->ContextSize = sizeof(u) * Count;

            Pass = TRUE;
        }
    } while (Index < Count);

    Object->Context[2] ^= Object->Key;
    Object->Context[3] ^= Object->Key;

    Pointer = &Object->Context[2];

    LockedBuildJumpCode(&Pointer, &Object->Body);

    Object->Context[2] ^= Object->Key;
    Object->Context[3] ^= Object->Key;

#ifdef DEBUG
    vDbgPrint(
        "[SHARK] < %p > set new entry for double encrypted context\n",
        Object);
#endif // DEBUG

    Index = 0;
    Pass = FALSE;
    ControlKey = (u)(Object->Context);
    ControlKey = Block->Ror64(ControlKey, ControlKey & 0x3F);

    do {
        Cache = __rdu64((u)(Object->Context) + Index * 8);

        for (KeyIndex = 0;
            KeyIndex < 0x10;
            KeyIndex++) {
            Key = KeyTable[0x10 + (Cache & 0xF)];

            Cache &= 0xFFFFFFFFFFFFFFF0ULL;
            Cache |= Key;

            Cache = Block->Ror64(Cache, 4);

            if (FALSE != Pass) break;
        }

        Cache -= Block->PostCache(Index, Object->Context);

        Cache ^= ControlKey;

        ControlKey ^= Block->PostKey(Index, Cache);

        ControlKey = Block->Rol64(
            ControlKey,
            (0 == Block->BuildKey ? ~Cache : Cache ^ Block->BuildKey) & 0x3F);

        ControlKey += (u)(Object->Context);

        __wru64((u)(Object->Context) + Index * 8, Cache);

        Index++;

        if (Index == (0xC8 / 8)) {
            Pass = TRUE;
        }
    } while (Index < Count);
}

void
NTAPI
PgSetBranchNewEntry(
    __inout PPGBLOCK Block,
    __inout PPGOBJECT Object,
    __in u32 BranchKey
)
{
    u Original = 0;
    u Key = 0;
    u ControlKey = 0;
    u Index = 0;
    u KeyIndex = 0;
    u Count = 0;
    u Cache = 0;
    ptr Pointer = NULL;
    b Pass = FALSE;

    u8 KeyTable[] = {
        0x00, 0x03, 0x05, 0x08, 0x06, 0x09, 0x0C, 0x07, 0x0D, 0x0A, 0x0E, 0x04, 0x01, 0x0F, 0x0B, 0x02,
        0x00, 0x0C, 0x0F, 0x01, 0x0B, 0x02, 0x04, 0x07, 0x03, 0x05, 0x09, 0x0E, 0x06, 0x08, 0x0A, 0x0D
    };

    Count = 0xC8 / 8;

    ControlKey = (u)(Object->Context);
    ControlKey = Block->Ror64(ControlKey, ControlKey & 0x3F);

    do {
        Cache = Original = __rdu64((u)(Object->Context) + Index * 8);

        Cache ^= *Block->KiWaitNever;
        Cache = Block->Rol64(Cache, *Block->KiWaitNever) ^ ControlKey;
        Cache = _byteswap_uint64(Cache);
        Cache ^= *Block->KiWaitAlways;
        Cache += Block->PostCache(Index, Object->Context);

        ControlKey ^= Block->PostKey(Index, Original);

        ControlKey = Block->Rol64(
            ControlKey,
            (0 == Block->BuildKey ? ~Original : Original ^ Block->BuildKey) & 0x3F);

        ControlKey += (u)(Object->Context);
        ControlKey ^= BranchKey;

        for (KeyIndex = 0;
            KeyIndex < 0x10;
            KeyIndex++) {
            Cache = Block->Rol64(Cache, 4);

            Key = KeyTable[Cache & 0xF];

            Cache &= 0xFFFFFFFFFFFFFFF0ULL;
            Cache |= Key;

            if (FALSE != Pass) break;
        }

        __wru64((u)(Object->Context) + Index * 8, Cache);

        Index++;

        if (Index == (0xC8 / 8)) {
            Object->Key =
                Block->OriginalCmpAppendDllSection[1] ^ Block->CacheCmpAppendDllSection[1];

            Count = Cache ^ Object->Key;
            Count >>= 0x20;
            Count &= 0xFFFFFFFFUL;
            Count += 0xC8 / 8;

            Object->ContextSize = sizeof(u) * Count;

            Pass = TRUE;
        }
    } while (Index < Count);

    Object->Context[2] ^= Object->Key;
    Object->Context[3] ^= Object->Key;

    Pointer = &Object->Context[2];

    LockedBuildJumpCode(&Pointer, &Object->Body);

    Object->Context[2] ^= Object->Key;
    Object->Context[3] ^= Object->Key;

#ifdef DEBUG
    vDbgPrint(
        "[SHARK] < %p > set new entry for double encrypted context\n",
        Object);
#endif // DEBUG

    Index = 0;
    Pass = FALSE;
    ControlKey = (u)(Object->Context);
    ControlKey = Block->Ror64(ControlKey, ControlKey & 0x3F);

    do {
        Cache = __rdu64((u)(Object->Context) + Index * 8);

        for (KeyIndex = 0;
            KeyIndex < 0x10;
            KeyIndex++) {
            Key = KeyTable[0x10 + (Cache & 0xF)];

            Cache &= 0xFFFFFFFFFFFFFFF0ULL;
            Cache |= Key;

            Cache = Block->Ror64(Cache, 4);

            if (FALSE != Pass) break;
        }

        Cache -= Block->PostCache(Index, Object->Context);
        Cache ^= *Block->KiWaitAlways;
        Cache = _byteswap_uint64(Cache);
        Cache ^= ControlKey;
        Cache = Block->Ror64(Cache, *Block->KiWaitNever);
        Cache ^= *Block->KiWaitNever;

        ControlKey ^= Block->PostKey(Index, Cache);

        ControlKey = Block->Rol64(
            ControlKey,
            (0 == Block->BuildKey ? ~Cache : Cache ^ Block->BuildKey) & 0x3F);

        ControlKey += (u)(Object->Context);
        ControlKey ^= BranchKey;

        __wru64((u)(Object->Context) + Index * 8, Cache);

        Index++;

        if (Index == (0xC8 / 8)) {
            Pass = TRUE;
        }
    } while (Index < Count);
}

PPGOBJECT
NTAPI
PgCompareDoubleEncryptedFields(
    __inout PPGBLOCK Block,
    __in u8 Type,
    __in ptr BaseAddress,
    __in u RegionSize
)
{
    ptr EndAddress = NULL;
    u8ptr TargetPc = NULL;
    u Index = 0;
    PPGOBJECT Object = NULL;
    u Result = 0;

    // search first page
    EndAddress = (u8ptr)BaseAddress
        + PAGE_SIZE + Block->SizeCmpAppendDllSection;

    for (Index = 0;
        Index < RTL_NUMBER_OF(Block->BranchKey) && 0 == Result;
        Index++) {
        TargetPc = BaseAddress;

        do {
            Result = PgFastScanBranch(
                Block,
                TargetPc,
                Block->BranchKey[Index]);

            if (0 != Result) {
                Object = PgCreateObject(
                    PgDoubleEncrypted,
                    Type,
                    BaseAddress,
                    RegionSize,
                    Block,
                    NULL,
                    Block->ClearCallback,
                    NULL,
                    Block->CaptureContext);

                if (NULL != Object) {
                    Object->Context = TargetPc;

                    PgSetBranchNewEntry(
                        Block,
                        Object,
                        Block->BranchKey[Index]);
                }

                break;
            }
            else {
                Result = PgFastScanTimer(Block, TargetPc);

                if (0 != Result) {
                    Object = PgCreateObject(
                        PgDoubleEncrypted,
                        Type,
                        BaseAddress,
                        RegionSize,
                        Block,
                        NULL,
                        Block->ClearCallback,
                        NULL,
                        Block->CaptureContext);

                    if (NULL != Object) {
                        Object->Context = TargetPc;

                        PgSetTimerNewEntry(Block, Object);
                    }

                    break;
                }
            }
        } while ((u)TargetPc++ < (u)EndAddress);
    }

    return Object;
}

void
NTAPI
PgCompareFields(
    __inout PPGBLOCK Block,
    __in u8 Type,
    __in ptr BaseAddress,
    __in u RegionSize
)
{
    ptr EndAddress = NULL;
    u8ptr TargetPc = NULL;
    u Index = 0;
    u64 RorKey = 0;
    u32 RorKeyIndex = 0;
    u64ptr Fields = NULL;
    ptr Context = NULL;
    PPGOBJECT Object = NULL;
    b Result = 0;

    if (FALSE != MmIsAddressValid(BaseAddress)) {
        if (((u)Block >= (u)BaseAddress) &&
            ((u)Block < ((u)BaseAddress + RegionSize))) {
            // pass self
        }
        else {
            if (GetRtBlock(Block)->BuildNumber >= 18362) {
                Object = PgCompareDoubleEncryptedFields(
                    Block,
                    Type,
                    BaseAddress,
                    RegionSize);

                if (NULL != Object) {
#ifdef DEBUG
                    vDbgPrint(
                        "[SHARK] < %p > found encrypted context < %p - %08x >\n",
                        Object->Context,
                        BaseAddress,
                        RegionSize);
#endif // DEBUG
                }
            }
            else {
                TargetPc = BaseAddress;

                // only search one page
                EndAddress = (u8ptr)BaseAddress + PAGE_SIZE - sizeof(Block->Fields);

                do {
                    Fields = TargetPc;

                    if ((u64)Fields == (u64)Block->Fields) {
                        break;
                    }

                    RorKey = Fields[3] ^ Block->Fields[3];

                    // CmpAppendDllSection + 98

                    // xor [rdx + rcx * 8 + 0c0h], rax
                    // ror rax, cl

                    // if >= win10 17134 btc rax, rax here

                    // loop CmpAppendDllSection + 98

                    if (0 == RorKey) {
                        if (Fields[2] == Block->Fields[2] &&
                            Fields[1] == Block->Fields[1] &&
                            Fields[0] == Block->Fields[0]) {
                            Context = TargetPc - PG_FIRST_FIELD_OFFSET;

#ifdef DEBUG
                            vDbgPrint(
                                "[SHARK] < %p > found declassified context\n",
                                Context);
#endif // DEBUG
                            break;
                        }
                    }
                    else {
                        RorKeyIndex = 0;

                        RorKey = Block->CmpDecode(RorKey, PG_FIELD_BITS);

                        RorKeyIndex++;

                        if ((u64)(Fields[2] ^ RorKey) == (u64)Block->Fields[2]) {
                            RorKey = Block->CmpDecode(RorKey, PG_FIELD_BITS - RorKeyIndex);

                            RorKeyIndex++;

                            if ((u64)(Fields[1] ^ RorKey) == (u64)Block->Fields[1]) {
                                RorKey = Block->CmpDecode(RorKey, PG_FIELD_BITS - RorKeyIndex);

                                RorKeyIndex++;

                                if ((u64)(Fields[0] ^ RorKey) == (u64)Block->Fields[0]) {
                                    Context = TargetPc - PG_FIRST_FIELD_OFFSET;

                                    RorKey = Fields[0] ^ Block->Fields[0];

#ifdef DEBUG
                                    vDbgPrint(
                                        "[SHARK] < %p > found encrypted context < %p - %08x >\n",
                                        Context,
                                        BaseAddress,
                                        RegionSize);
#endif // DEBUG

                                    Object = PgCreateObject(
                                        PgEncrypted,
                                        Type,
                                        BaseAddress,
                                        RegionSize,
                                        Block,
                                        NULL,
                                        Block->ClearCallback,
                                        NULL,
                                        Block->CaptureContext);

                                    if (NULL != Object) {
                                        Block->Count++;

                                        Object->Context = Context;

                                        Object->ContextSize =
                                            RegionSize - ((u)Context - (u)BaseAddress);

                                        if (FALSE != Block->BtcEnable) {
                                            PgSetNewEntryWithBtc(Block, Object);
                                        }
                                        else {
                                            for (;
                                                RorKeyIndex < PG_FIELD_BITS;
                                                RorKeyIndex++) {
                                                RorKey = Block->Ror64(RorKey, PG_FIELD_BITS - RorKeyIndex);
                                            }

                                            Object->Key = RorKey;

#ifdef DEBUG
                                            vDbgPrint(
                                                "[SHARK] < %p > first rorkey\n",
                                                RorKey);
#endif // DEBUG
                                            PgSetNewEntry(Block, Object, Context, RorKey);
                                        }
                                    }

                                    break;
                                }
                            }
                        }
                    }

                    TargetPc++;
                } while ((u64)TargetPc < (u64)EndAddress);
            }
        }
    }
}

void
NTAPI
InitializeSystemPtesBitMap(
    __inout PMMPTE BasePte,
    __in PFN_NUMBER NumberOfPtes,
    __out PRTL_BITMAP BitMap
)
{
    PMMPTE PointerPxe = NULL;
    PMMPTE PointerPpe = NULL;
    PMMPTE PointerPde = NULL;
    PMMPTE PointerPte = NULL;
    ptr PointerAddress = NULL;
    u32 BitNumber = 0;
    ptr BeginAddress = NULL;
    ptr EndAddress = NULL;

    /*
    PatchGuard Context pages allocate by MmAllocateIndependentPages

    PTE field like this

    nt!_MMPTE
    [+0x000] Long             : 0x2da963 [Type: unsigned __int64]
    [+0x000] VolatileLong     : 0x2da963 [Type: unsigned __int64]
    [+0x000] Hard             [Type: _MMPTE_HARDWARE]

        [+0x000 ( 0: 0)] Valid            : 0x1     [Type: unsigned __int64] <- MM_PTE_VALID_MASK
        [+0x000 ( 1: 1)] Dirty1           : 0x1     [Type: unsigned __int64] <- MM_PTE_DIRTY_MASK
        [+0x000 ( 2: 2)] Owner            : 0x0     [Type: unsigned __int64]
        [+0x000 ( 3: 3)] WriteThrough     : 0x0     [Type: unsigned __int64]
        [+0x000 ( 4: 4)] CacheDisable     : 0x0     [Type: unsigned __int64]
        [+0x000 ( 5: 5)] Accessed         : 0x1     [Type: unsigned __int64] <- MM_PTE_ACCESS_MASK
        [+0x000 ( 6: 6)] Dirty            : 0x1     [Type: unsigned __int64] <- MM_PTE_DIRTY_MASK
        [+0x000 ( 7: 7)] LargePage        : 0x0     [Type: unsigned __int64]
        [+0x000 ( 8: 8)] Global           : 0x1     [Type: unsigned __int64] <- MM_PTE_GLOBAL_MASK
        [+0x000 ( 9: 9)] CopyOnWrite      : 0x0     [Type: unsigned __int64]
        [+0x000 (10:10)] Unused           : 0x0     [Type: unsigned __int64]
        [+0x000 (11:11)] Write            : 0x1     [Type: unsigned __int64] <- MM_PTE_WRITE_MASK
        [+0x000 (47:12)] PageFrameNumber  : 0x2da   [Type: unsigned __int64] <- pfndata index
        [+0x000 (51:48)] reserved1        : 0x0     [Type: unsigned __int64]
        [+0x000 (62:52)] SoftwareWsIndex  : 0x0     [Type: unsigned __int64]
        [+0x000 (63:63)] NoExecute        : 0x0     [Type: unsigned __int64] <- page can executable

    [+0x000] Flush            [Type: _HARDWARE_PTE]
    [+0x000] Proto            [Type: _MMPTE_PROTOTYPE]
    [+0x000] Soft             [Type: _MMPTE_SOFTWARE]
    [+0x000] TimeStamp        [Type: _MMPTE_TIMESTAMP]
    [+0x000] Trans            [Type: _MMPTE_TRANSITION]
    [+0x000] Subsect          [Type: _MMPTE_SUBSECTION]
    [+0x000] List             [Type: _MMPTE_LIST]
    */

#define VALID_PTE_SET_BITS \
            ( MM_PTE_VALID_MASK | MM_PTE_DIRTY_MASK | MM_PTE_WRITE_MASK | MM_PTE_ACCESS_MASK)

#define VALID_PTE_UNSET_BITS \
            ( MM_PTE_WRITE_THROUGH_MASK | MM_PTE_CACHE_DISABLE_MASK | MM_PTE_COPY_ON_WRITE_MASK )

    BeginAddress = GetVaMappedByPte(BasePte);
    EndAddress = GetVaMappedByPte(BasePte + NumberOfPtes);

    PointerAddress = BeginAddress;

    do {
        PointerPxe = GetPxeAddress(PointerAddress);

        if (0 != PointerPxe->u.Hard.Valid) {
            PointerPpe = GetPpeAddress(PointerAddress);

            if (0 != PointerPpe->u.Hard.Valid) {
                PointerPde = GetPdeAddress(PointerAddress);

                if (0 != PointerPde->u.Hard.Valid) {
                    if (0 == PointerPde->u.Hard.LargePage) {
                        PointerPte = GetPteAddress(PointerAddress);

                        if (0 != PointerPte->u.Hard.Valid) {
                            if (0 == PointerPte->u.Hard.NoExecute) {
                                if (VALID_PTE_SET_BITS == (PointerPte->u.Long & VALID_PTE_SET_BITS)) {
                                    if (0 == (PointerPte->u.Long & VALID_PTE_UNSET_BITS)) {
                                        BitNumber = PointerPte - BasePte;

                                        RtlSetBit(BitMap, BitNumber);
                                    }
                                }
                            }
                        }

                        PointerAddress = GetVaMappedByPte(PointerPte + 1);
                    }
                    else {
                        PointerAddress = GetVaMappedByPde(PointerPde + 1);
                    }
                }
                else {
                    PointerAddress = GetVaMappedByPde(PointerPde + 1);
                }
            }
            else {
                PointerAddress = GetVaMappedByPpe(PointerPpe + 1);
            }
        }
        else {
            PointerAddress = GetVaMappedByPxe(PointerPxe + 1);
        }
    } while ((u)PointerAddress < (u)EndAddress);
}

void
NTAPI
PgClearSystemPtesEncryptedContext(
    __inout PPGBLOCK Block
)
{
    PRTL_BITMAP BitMap = NULL;
    u32 BitMapSize = 0;
    PFN_NUMBER NumberOfPtes = 0;
    u32 HintIndex = 0;
    u32 StartingRunIndex = 0;

    NumberOfPtes = Block->SystemPtes.NumberOfPtes;

#ifdef DEBUG
    vDbgPrint(
        "[SHARK] < %p > SystemPtes < %p - %p >\n",
        KeGetCurrentProcessorNumber(),
        Block->SystemPtes.BasePte,
        Block->SystemPtes.BasePte + NumberOfPtes);
#endif // DEBUG

    BitMapSize =
        sizeof(RTL_BITMAP) + (u32)((((NumberOfPtes + 1) + 31) / 32) * 4);

    BitMap = __malloc(BitMapSize);

    if (NULL != BitMap) {
        RtlInitializeBitMap(
            BitMap,
            (u32ptr)(BitMap + 1),
            (u32)(NumberOfPtes + 1));

        RtlClearAllBits(BitMap);

        InitializeSystemPtesBitMap(
            Block->SystemPtes.BasePte,
            NumberOfPtes,
            BitMap);

        do {
            HintIndex = RtlFindSetBits(
                BitMap,
                1,
                HintIndex);

            if (MAXULONG != HintIndex) {
                RtlFindNextForwardRunClear(
                    BitMap,
                    HintIndex,
                    &StartingRunIndex);

                RtlClearBits(BitMap, HintIndex, StartingRunIndex - HintIndex);

                if (((StartingRunIndex - HintIndex)
                    >= BYTES_TO_PAGES(Block->SizeINITKDBG)) &&
                    (StartingRunIndex - HintIndex)
                    == BYTES_TO_PAGES(
                        __rduptr(GetVaMappedByPte(Block->SystemPtes.BasePte + HintIndex)))) {
#ifdef DEBUG
                    vDbgPrint(
                        "[SHARK] < %p > scan < %p - %08x > < %p, %p, %p, %p...>\n",
                        KeGetCurrentProcessorNumber(),
                        GetVaMappedByPte(Block->SystemPtes.BasePte + HintIndex),
                        (StartingRunIndex - HintIndex) * PAGE_SIZE,
                        __rduptr(GetVaMappedByPte(Block->SystemPtes.BasePte + HintIndex)),
                        __rduptr((u)GetVaMappedByPte(Block->SystemPtes.BasePte + HintIndex) + 8),
                        __rduptr((u)GetVaMappedByPte(Block->SystemPtes.BasePte + HintIndex) + 0x10),
                        __rduptr((u)GetVaMappedByPte(Block->SystemPtes.BasePte + HintIndex) + 0x18));
#endif // DEBUG

                    PgCompareFields(
                        Block,
                        PgSystemPtes,
                        GetVaMappedByPte(Block->SystemPtes.BasePte + HintIndex),
                        (StartingRunIndex - HintIndex) * PAGE_SIZE);
                }

                HintIndex = StartingRunIndex;
            }
        } while (HintIndex < NumberOfPtes);

        __free(BitMap);
    }
}

b
NTAPI
FastScanPool(
    __inout PPGBLOCK Block,
    __in PPOOL_BIG_PAGES PoolBigPage
)
{
    b Result = FALSE;
    u Index = 0;

    if (POOL_BIG_TABLE_ENTRY_FREE !=
        ((u64)PoolBigPage->Va & POOL_BIG_TABLE_ENTRY_FREE)) {
        if (0 == BYTE_OFFSET(PoolBigPage->NumberOfPages) &&
            PoolBigPage->NumberOfPages >= Block->SizeINITKDBG) {
            if (0 !=
                Block->Pool.MmIsNonPagedSystemAddressValid(PoolBigPage->Va)) {
                Result = TRUE;

                for (Index = 0;
                    Index < PG_COMPARE_FIELDS_COUNT;
                    Index++) {
                    if (0 == __rduptr((u)PoolBigPage->Va + Index * 8) ||
                        -1 == __rdsptr((u)PoolBigPage->Va + Index * 8) ||
                        -2 == __rdsptr((u)PoolBigPage->Va + Index * 8) ||
                        0 == ((__rduptr((u)PoolBigPage->Va + Index * 8) >> VIRTUAL_ADDRESS_BITS) & 0xffff) ||
                        0xffff == ((__rduptr((u)PoolBigPage->Va + Index * 8) >> VIRTUAL_ADDRESS_BITS) & 0xffff)) {
                        Result = FALSE;

                        break;
                    }
                }
            }
        }
    }

    return Result;
}

void
NTAPI
PgClearPoolEncryptedContext(
    __inout PPGBLOCK Block
)
{
    PPOOL_BIG_PAGES PoolBigPage = NULL;
    u Index = 0;
    u Offset = 0;

    Offset =
        GetRtBlock(Block)->BuildNumber > 20000 ?
        sizeof(POOL_BIG_PAGESEX) : sizeof(POOL_BIG_PAGES);

#ifdef DEBUG
    vDbgPrint(
        "[SHARK] < %p > BigPool < %p - %08x >\n",
        KeGetCurrentProcessorNumber(),
        *Block->Pool.PoolBigPageTable,
        *Block->Pool.PoolBigPageTableSize);
#endif // DEBUG

    for (Index = 0;
        Index < *Block->Pool.PoolBigPageTableSize;
        Index++) {
        PoolBigPage =
            (ptr)((u)*Block->Pool.PoolBigPageTable
                + Index * Offset);

        if (FALSE != FastScanPool(Block, PoolBigPage)) {
#ifdef DEBUG
            vDbgPrint(
                "[SHARK] < %p > scan < %p - %08x > < %p, %p, %p, %p...>\n",
                KeGetCurrentProcessorNumber(),
                PoolBigPage->Va,
                PoolBigPage->NumberOfPages,
                __rduptr((u)PoolBigPage->Va),
                __rduptr((u)PoolBigPage->Va + 8),
                __rduptr((u)PoolBigPage->Va + 0x10),
                __rduptr((u)PoolBigPage->Va + 0x18));
#endif // DEBUG

            PgCompareFields(
                Block,
                PgPoolBigPage,
                PoolBigPage->Va,
                PoolBigPage->NumberOfPages);
        }
    }
}

void
NTAPI
PgLocatePoolObject(
    __inout PPGBLOCK Block,
    __in ptr Establisher,
    __in PPGOBJECT Object
)
{
    PPOOL_BIG_PAGES PoolBigPage = NULL;
    u Index = 0;
    u Offset = 0;

    Offset =
        GetRtBlock(Block)->BuildNumber > 20000 ?
        sizeof(POOL_BIG_PAGESEX) : sizeof(POOL_BIG_PAGES);

    for (Index = 0;
        Index < *Block->Pool.PoolBigPageTableSize;
        Index++) {
        PoolBigPage =
            (ptr)((u)*Block->Pool.PoolBigPageTable
                + Index * Offset);

        if (POOL_BIG_TABLE_ENTRY_FREE !=
            ((u64)PoolBigPage->Va & POOL_BIG_TABLE_ENTRY_FREE)) {
            if (FALSE !=
                Block->Pool.MmIsNonPagedSystemAddressValid(
                    PoolBigPage->Va)) {
                if (PoolBigPage->NumberOfPages > Block->SizeINITKDBG) {
                    if ((u64)Establisher >= (u64)PoolBigPage->Va &&
                        (u64)Establisher < (u64)PoolBigPage->Va +
                        PoolBigPage->NumberOfPages) {
                        Object->BaseAddress = PoolBigPage->Va;
                        Object->RegionSize = PoolBigPage->NumberOfPages;

#ifdef DEBUG
                        GetRtBlock(Block)->vDbgPrint(
                            "[SHARK] < %p > found region in pool < %p - %08x >\n",
                            Establisher,
                            Object->BaseAddress,
                            Object->RegionSize);
#endif // DEBUG

                        Object->Type = PgPoolBigPage;

                        break;
                    }
                }
            }
        }
    }
}

void
NTAPI
PgLocateSystemPtesObject(
    __inout PPGBLOCK Block,
    __in ptr ProgramCounter,
    __in PPGOBJECT Object
)
{
    PRTL_BITMAP BitMap = NULL;
    u32 BitMapSize = 0;
    PFN_NUMBER NumberOfPtes = 0;
    u32 HintIndex = 0;
    u32 StartingRunIndex = 0;

    NumberOfPtes = Block->SystemPtes.NumberOfPtes;

    BitMapSize =
        sizeof(RTL_BITMAP) +
        (u32)((((NumberOfPtes + 1) + 31) / 32) * 4);

    BitMap = __malloc(BitMapSize);

    if (NULL != BitMap) {
        RtlInitializeBitMap(
            BitMap,
            (u32ptr)(BitMap + 1),
            (u32)(NumberOfPtes + 1));

        RtlClearAllBits(BitMap);

        InitializeSystemPtesBitMap(
            Block->SystemPtes.BasePte,
            NumberOfPtes,
            BitMap);

        do {
            HintIndex = RtlFindSetBits(
                BitMap,
                1,
                HintIndex);

            if (MAXULONG != HintIndex) {
                RtlFindNextForwardRunClear(
                    BitMap,
                    HintIndex,
                    &StartingRunIndex);

                RtlClearBits(BitMap, HintIndex, StartingRunIndex - HintIndex);

                if ((u64)ProgramCounter >=
                    (u64)GetVaMappedByPte(
                        Block->SystemPtes.BasePte + HintIndex) &&
                        (u64)ProgramCounter <
                    (u64)GetVaMappedByPte(
                        Block->SystemPtes.BasePte + StartingRunIndex) - Block->SizeCmpAppendDllSection) {
                    // align clear execute mask region

                    if (GetRtBlock(Block)->BuildNumber >= 18362) {
                        Object->BaseAddress =
                            GetVaMappedByPte(Block->SystemPtes.BasePte + HintIndex - 1);

                        Object->RegionSize =
                            (u)(StartingRunIndex - HintIndex + 1) * PAGE_SIZE;
                    }
                    else {
                        Object->BaseAddress =
                            GetVaMappedByPte(Block->SystemPtes.BasePte + HintIndex);

                        Object->RegionSize =
                            (u)(StartingRunIndex - HintIndex) * PAGE_SIZE;
                    }
#ifdef DEBUG
                    vDbgPrint(
                        "[SHARK] < %p > found region in system ptes < %p - %08x >\n",
                        ProgramCounter,
                        Object->BaseAddress,
                        Object->RegionSize);
#endif // DEBUG

                    Object->Type = PgSystemPtes;

                    break;
                }

                HintIndex = StartingRunIndex;
            }
        } while (HintIndex < NumberOfPtes);

        __free(BitMap);
    }
}

void
NTAPI
PgLocateAllObject(
    __inout PPGBLOCK Block,
    __in ptr Establisher,
    __out PPGOBJECT Object
)
{
    PgLocatePoolObject(Block, Establisher, Object);

    if (-1 == Object->Type) {
        PgLocateSystemPtesObject(Block, Establisher, Object);
    }
}

void
NTAPI
PgCheckAllWorkerThread(
    __inout PPGBLOCK Block
)
{
    PETHREAD Thread = NULL;
    PEXCEPTION_FRAME ExceptionFrame = NULL;
    u64 EstablisherFrame = 0;
    u64 ReturnAddress = 0;
    u64 Stack = 0;
    u Index = 0;
    PPGOBJECT Object = NULL;
    b Chance = FALSE;
    PGOBJECT ObjectRecord = { 0 };

    if (NULL != Block->INITKDBG) {
        Thread = GetProcessFirstThread(
            GetRtBlock(Block),
            PsGetCurrentThreadProcess());

        while (GetThreadListEntry(GetRtBlock(Block),
            Thread) != GetProcessThreadListHead(
                GetRtBlock(Block),
                PsGetCurrentThreadProcess())) {
            if (PsGetCurrentThreadId() != PsGetThreadId(Thread) &&
                (u64)Block->ExpWorkerThread == __rduptr(
                (u8ptr)Thread +
                    GetRtBlock(Block)->OffsetKThreadWin32StartAddress)) {
                Chance = FALSE;

                Stack = __rduptr((u8ptr)Thread
                    + GetRtBlock(Block)->DebuggerDataBlock.OffsetKThreadInitialStack);

                // protect: 1f - outswapped kernel stack
                if (FALSE != MmIsAddressValid((ptr)Stack)) {
                    // KiScbQueueScanWorker 
                    // this function decrypt pg worker context
                    // only pg code use it

                    // 7600 1 level                                                
                    // ExpWorkerThread -> FsRtlUninitializeSmallMcb -> FsRtlMdlReadCompleteDevEx

                    // 9200 ~ 15063 1 level                     
                    // ExpWorkerThread -> KiScbQueueScanWorker(jmp) 
                    //     -> FsRtlUninitializeSmallMcb -> FsRtlMdlReadCompleteDevEx

                    // 16299 ~ later 2 level                    
                    // ExpWorkerThread -> KiScbQueueScanWorker(call) 
                    //     -> FsRtlUninitializeSmallMcb -> FsRtlMdlReadCompleteDevEx

                    if (GetRtBlock(Block)->BuildNumber >= 16299) {
                        // check KiScbQueueScanWorker

                        if (Block->ExpWorkerThreadReturn ==
                            (ptr)__rduptr(Stack - Block->OffsetExpWorkerThreadReturn)) {

                            ReturnAddress =
                                __rduptr(Stack
                                    - Block->OffsetExpWorkerThreadReturn
                                    - KSTART_FRAME_LENGTH);

                            if (FALSE != MmIsAddressValid((ptr)ReturnAddress)) {
                                if (ReturnAddress >= Block->KiScbQueueScanWorker.BeginAddress &&
                                    ReturnAddress < Block->KiScbQueueScanWorker.EndAddress) {
                                    Chance = TRUE;
                                }
                            }
                        }
                    }
                    else {
                        // check FsRtlUninitializeSmallMcb     

                        if (Block->ExpWorkerThreadReturn ==
                            (ptr)__rduptr(Stack - Block->OffsetExpWorkerThreadReturn)) {

                            // 48 83 EC 48      sub     rsp, 48h
                            // E8 5B CB FF FF   call    FsRtlMdlReadCompleteDevEx

                            ReturnAddress =
                                __rduptr(Stack
                                    - Block->OffsetExpWorkerThreadReturn - 0x50);

                            if (FALSE != MmIsAddressValid((ptr)ReturnAddress) &&
                                FALSE != MmIsAddressValid((ptr)(ReturnAddress + PG_COMPARE_BYTE_COUNT))) {
                                for (Index = 0;
                                    Index < Block->SizeINITKDBG - PG_COMPARE_BYTE_COUNT;
                                    Index++) {
                                    if (PG_COMPARE_BYTE_COUNT == RtlCompareMemory(
                                        (u8ptr)Block->INITKDBG + Index,
                                        (ptr)ReturnAddress,
                                        PG_COMPARE_BYTE_COUNT)) {
                                        Chance = TRUE;

                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                if (FALSE != Chance) {
                    // SwapContext
                    ExceptionFrame = (PEXCEPTION_FRAME)__rduptr(
                        (u8ptr)Thread +
                        GetRtBlock(Block)->DebuggerDataBlock.OffsetKThreadKernelStack);

                    EstablisherFrame =
                        ((u64)(ExceptionFrame + 1) + KSTART_FRAME_LENGTH + sizeof(ptr));

#ifdef DEBUG
                    vDbgPrint(
                        "[SHARK] < %p > found patchguard address in worker thread stack\n",
                        __rduptr(EstablisherFrame));
#endif // DEBUG

                    ObjectRecord.Type = -1;

                    PgLocateAllObject(
                        Block,
                        (ptr)__rduptr(EstablisherFrame),
                        &ObjectRecord);

                    if (-1 != ObjectRecord.Type) {
                        Object = PgCreateObject(
                            PgDeclassified,
                            ObjectRecord.Type,
                            ObjectRecord.BaseAddress,
                            ObjectRecord.RegionSize,
                            Block,
                            NULL,
                            Block->ClearCallback,
                            NULL,
                            Block->CaptureContext);

                        if (NULL != Object) {
                            Block->Count++;

                            // align stack 
                            // must start at Body.Parameter
                            __wruptr(
                                EstablisherFrame,
                                &Object->Body.Parameter);

#ifdef DEBUG
                            vDbgPrint(
                                "[SHARK] < %p > insert worker restart code\n",
                                Object);
#endif // DEBUG
                        }
                    }
                }
            }

            Thread = GetNexThread(GetRtBlock(Block), Thread);
        }
    }
}

void
NTAPI
PgClearAll(
    __inout PPGBLOCK Block
)
{

    // init self ldr
    CaptureImageExceptionValues(
        GetRtBlock(Block)->Self->DataTableEntry.DllBase,
        &GetRtBlock(Block)->Self->DataTableEntry.ExceptionTable,
        &GetRtBlock(Block)->Self->DataTableEntry.ExceptionTableSize);

    InsertTailList(
        &GetRtBlock(Block)->LoadedModuleList,
        &GetRtBlock(Block)->Self->DataTableEntry.InLoadOrderLinks);

    // init self exception
    InsertInvertedFunctionTable(
        GetRtBlock(Block)->Self->DataTableEntry.DllBase,
        GetRtBlock(Block)->Self->DataTableEntry.SizeOfImage);

    PgClearPoolEncryptedContext(Block);

    if (GetRtBlock(Block)->BuildNumber >= 9200) {
        PgClearSystemPtesEncryptedContext(Block);
    }

    if (NULL != Block->INITKDBG) {
        PgCheckAllWorkerThread(Block);

        __free(Block->INITKDBG);

        Block->INITKDBG = NULL;
    }
}

void
NTAPI
PgClearWorker(
    __inout ptr Argument
)
{
    u32 Index = 0;
    u64ptr Stack = 0;
    DISPATCHER_HEADER * Header = NULL;
    u32 ReturnLength = 0;
    u8ptr TargetPc = NULL;
    u32 Length = 0;
    b Chance = TRUE;

    struct {
        PPGBLOCK Block;
        KEVENT Notify;
        WORK_QUEUE_ITEM Worker;
    }*Context = Argument;

    Context->Block->ExpWorkerThreadReturn = _ReturnAddress();

    InitializePgBlock(Context->Block);

    Stack = IoGetInitialStack();

    while (*Stack != (u64)_ReturnAddress()) {
        Stack--;
    }

    Context->Block->OffsetExpWorkerThreadReturn =
        (u64)IoGetInitialStack() - (u64)Stack;

    if (GetRtBlock(Context->Block)->BuildNumber >= 9600) {
        // Header->Type = 0x15
        // Header->Hand = 0xac

        // WorkerContext = struct _DISPATCHER_HEADER

        while ((u64)Stack != (u64)&Argument) {
            Header = *(ptr *)Stack;

            if (FALSE != MmIsAddressValid(Header)) {
                if (FALSE != MmIsAddressValid((u8ptr)(Header + 1) - 1)) {
                    if (0x15 == Header->Type &&
                        0xac == Header->Hand) {
                        Context->Block->WorkerContext = Header;

                        break;
                    }
                }
            }

            Stack--;
        }
    }
    else {
        // CriticalWorkQueue = 0
        // DelayedWorkQueue = 1

        // WorkerContext = enum _WORK_QUEUE_TYPE

        Context->Block->WorkerContext = UlongToPtr(CriticalWorkQueue);
    }

    if (NT_SUCCESS(ZwQueryInformationThread(
        ZwCurrentThread(),
        ThreadQuerySetWin32StartAddress,
        &Context->Block->ExpWorkerThread,
        sizeof(ptr),
        &ReturnLength))) {
        for (Index = 0;
            Index < GetRtBlock(Context->Block)->DebuggerDataBlock.SizeEThread;
            Index += 8) {
            if ((u)Context->Block->ExpWorkerThread ==
                __rduptr((u8ptr)KeGetCurrentThread() + Index)) {
                GetRtBlock(Context->Block)->OffsetKThreadWin32StartAddress = Index;

                break;
            }
        }

        if (GetRtBlock(Context->Block)->BuildNumber >= 18362) {
            TargetPc = (u8ptr)Context->Block->ExpWorkerThread;

            while (TRUE) {
                Length = DetourGetInstructionLength(TargetPc);

                if (6 == Length) {
                    if (0 == _cmpbyte(TargetPc[0], 0x8b) &&
                        0 == _cmpbyte(TargetPc[1], 0x83)) {
                        Context->Block->OffsetSameThreadPassive = *(u32ptr)(TargetPc + 2);

#ifdef DEBUG
                        vDbgPrint(
                            "[SHARK] < %p > OffsetSameThreadPassive\n",
                            Context->Block->OffsetSameThreadPassive);
#endif // DEBUG

                        break;
                    }
                }

                TargetPc += Length;
            }
        }
    }

    if (0 == Context->Block->SizeCmpAppendDllSection ||
        0 == Context->Block->OffsetEntryPoint ||
        0 == Context->Block->SizeINITKDBG ||
        NULL == GetRtBlock(Context->Block)->PsInvertedFunctionTable ||
        NULL == Context->Block->KiStartSystemThread ||
        NULL == Context->Block->PspSystemThreadStartup ||
        NULL == Context->Block->Pool.PoolBigPageTable ||
        NULL == Context->Block->Pool.PoolBigPageTableSize ||
        NULL == Context->Block->ExpWorkerThread) {
        Chance = FALSE;
    }

    if (GetRtBlock(Context->Block)->BuildNumber >= 9200) {
        if (0 == Context->Block->SystemPtes.NumberOfPtes ||
            NULL == Context->Block->SystemPtes.BasePte ||
            NULL == Context->Block->MmAllocateIndependentPages ||
            NULL == Context->Block->MmFreeIndependentPages ||
            NULL == Context->Block->MmSetPageProtection ||
            0 == Context->Block->KiScbQueueScanWorker.BeginAddress ||
            0 == Context->Block->KiScbQueueScanWorker.BeginAddress) {
            Chance = FALSE;
        }
    }

    if (GetRtBlock(Context->Block)->BuildNumber >= 9600) {
        if (0 == Context->Block->WorkerContext ||
            NULL == Context->Block->KiWaitNever ||
            NULL == Context->Block->KiWaitAlways) {
            Chance = FALSE;
        }
    }

    if (GetRtBlock(Context->Block)->BuildNumber >= 18362) {
        if (0 == Context->Block->OffsetSameThreadPassive) {
            Chance = FALSE;
        }
    }

    if (FALSE != Chance) {
        IpiSingleCall(
            (PGKERNEL_ROUTINE)NULL,
            (PGSYSTEM_ROUTINE)NULL,
            (PGRUNDOWN_ROUTINE)PgClearAll,
            (PGNORMAL_ROUTINE)Context->Block);
    }

    KeSetEvent(&Context->Notify, LOW_PRIORITY, FALSE);
}

void
NTAPI
PgClear(
    __inout PPGBLOCK Block
)
{
    struct {
        PPGBLOCK Block;
        KEVENT Notify;
        WORK_QUEUE_ITEM Worker;
    }Context = { Block, {0}, {0} };

    KeInitializeEvent(&Context.Notify, SynchronizationEvent, FALSE);
    ExInitializeWorkItem(&Context.Worker, PgClearWorker, &Context);
    ExQueueWorkItem(&Context.Worker, CriticalWorkQueue);

    KeWaitForSingleObject(
        &Context.Notify,
        Executive,
        KernelMode,
        FALSE,
        NULL);
}

```

`Projects/Shark/AMD64/SpaceAMD64.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "Space.h"

#include "Guard.h"
#include "Reload.h"
#include "Rtx.h"
#include "Scan.h"

void
NTAPI
InitializeSpace(
    __inout PRTB Block
)
{
    if (Block->BuildNumber >= 10586) {
        Block->PteBase = (PMMPTE)Block->DebuggerDataAdditionBlock.PteBase;

        Block->PteTop = (PMMPTE)
            ((s64)Block->PteBase |
            (((((s64)1 << (VIRTUAL_ADDRESS_BITS + 1)) >> PTI_SHIFT) << PTE_SHIFT) - 1));

        Block->PdeBase = (PMMPTE)
            (((s64)Block->PteBase & ~(((s64)1 << (PHYSICAL_ADDRESS_BITS - 1)) - 1)) |
            (((s64)Block->PteBase >> 9) & (((s64)1 << (PHYSICAL_ADDRESS_BITS - 1)) - 1)));

        Block->PdeTop = (PMMPTE)
            ((s64)Block->PdeBase |
            (((((s64)1 << (VIRTUAL_ADDRESS_BITS + 1)) >> PDI_SHIFT) << PTE_SHIFT) - 1));

        Block->PpeBase = (PMMPTE)
            (((s64)Block->PdeBase & ~(((s64)1 << (PHYSICAL_ADDRESS_BITS - 1)) - 1)) |
            (((s64)Block->PdeBase >> 9) & (((s64)1 << (PHYSICAL_ADDRESS_BITS - 1)) - 1)));

        Block->PpeTop = (PMMPTE)
            ((s64)Block->PpeBase |
            (((((s64)1 << (VIRTUAL_ADDRESS_BITS + 1)) >> PPI_SHIFT) << PTE_SHIFT) - 1));

        Block->PxeBase = (PMMPTE)
            (((s64)Block->PpeBase & ~(((s64)1 << (PHYSICAL_ADDRESS_BITS - 1)) - 1)) |
            (((s64)Block->PpeBase >> 9) & (((s64)1 << (PHYSICAL_ADDRESS_BITS - 1)) - 1)));

        Block->PxeTop = (PMMPTE)
            ((s64)Block->PxeBase |
            (((((s64)1 << (VIRTUAL_ADDRESS_BITS + 1)) >> PXI_SHIFT) << PTE_SHIFT) - 1));
    }
    else {
        Block->PteBase = (PMMPTE)PTE_BASE;
        Block->PteTop = (PMMPTE)PTE_TOP;
        Block->PdeBase = (PMMPTE)PDE_BASE;
        Block->PdeTop = (PMMPTE)PDE_TOP;
        Block->PpeBase = (PMMPTE)PPE_BASE;
        Block->PpeTop = (PMMPTE)PPE_TOP;
        Block->PxeBase = (PMMPTE)PXE_BASE;
        Block->PxeTop = (PMMPTE)PXE_TOP;
    }
}

PMMPTE
NTAPI
GetPxeAddress(
    __in ptr VirtualAddress
)
{
    return RtBlock.PxeBase + MiGetPxeOffset(VirtualAddress);
}

PMMPTE
NTAPI
GetPpeAddress(
    __in ptr VirtualAddress
)
{
    return (PMMPTE)
        (((((s64)VirtualAddress & VIRTUAL_ADDRESS_MASK)
            >> PPI_SHIFT)
            << PTE_SHIFT) + (s64)RtBlock.PpeBase);
}

PMMPTE
NTAPI
GetPdeAddress(
    __in ptr VirtualAddress
)
{
    return (PMMPTE)
        (((((s64)VirtualAddress & VIRTUAL_ADDRESS_MASK)
            >> PDI_SHIFT)
            << PTE_SHIFT) + (s64)RtBlock.PdeBase);
}

PMMPTE
NTAPI
GetPteAddress(
    __in ptr VirtualAddress
)
{
    return (PMMPTE)
        (((((s64)VirtualAddress & VIRTUAL_ADDRESS_MASK)
            >> PTI_SHIFT)
            << PTE_SHIFT) + (s64)RtBlock.PteBase);
}

ptr
NTAPI
GetVaMappedByPte(
    __in PMMPTE Pte
)
{
    return (ptr)((((s64)Pte - (s64)RtBlock.PteBase) <<
        (PAGE_SHIFT + VA_SHIFT - PTE_SHIFT)) >> VA_SHIFT);
}

ptr
NTAPI
GetVaMappedByPde(
    __in PMMPTE Pde
)
{
    return GetVaMappedByPte(GetVaMappedByPte(Pde));
}

ptr
NTAPI
GetVaMappedByPpe(
    __in PMMPTE Ppe
)
{
    return GetVaMappedByPte(GetVaMappedByPde(Ppe));
}

ptr
NTAPI
GetVaMappedByPxe(
    __in PMMPTE Pxe
)
{
    return GetVaMappedByPde(GetVaMappedByPde(Pxe));
}

```

`Projects/Shark/AMD64/StackAMD64.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "Stack.h"

#include "Except.h"

DECLSPEC_NOINLINE
u32
NTAPI
WalkFrameChain(
    __out PCALLERS Callers,
    __in u32 Count
)
{
    CONTEXT ContextRecord = { 0 };
    ptr HandlerData = NULL;
    u32 Index = 0;
    PRUNTIME_FUNCTION FunctionEntry = NULL;
    u64 ImageBase = 0;
    u64 EstablisherFrame = 0;
    u64 Top = 0;
    u64 Bottom = 0;

    RtlCaptureContext(&ContextRecord);
    IoGetStackLimits(&Bottom, &Top);

    while (Index < Count) {
        FunctionEntry = RtlLookupFunctionEntry(
            ContextRecord.Rip,
            &ImageBase,
            NULL);

        if (NULL != FunctionEntry) {
            RtlVirtualUnwind(
                UNW_FLAG_NHANDLER,
                ImageBase,
                ContextRecord.Rip,
                FunctionEntry,
                &ContextRecord,
                &HandlerData,
                &EstablisherFrame,
                NULL);

            if (EstablisherFrame >= Bottom &&
                EstablisherFrame < Top) {
                Callers[Index].Establisher = (ptr)ContextRecord.Rip;
                Callers[Index].EstablisherFrame = (ptr *)EstablisherFrame;
            }
            else {
                break;
            }

            Index += 1;
        }
        else {
            break;
        }
    }

    return Index;
}

```

`Projects/Shark/Ctx.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "Ctx.h"

#include "Guard.h"
#include "Reload.h"
#include "Scan.h"

```

`Projects/Shark/Ctx.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _CTX_H_
#define _CTX_H_

#include "Reload.h"

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

#ifdef _WIN64
    typedef struct _EXCEPTION_FRAME {
        //
        // Home address for the parameter registers.
        //

        u64 P1Home;
        u64 P2Home;
        u64 P3Home;
        u64 P4Home;
        u64 P5;

        //
        // Kernel callout initial stack value.
        //

        u64 InitialStack;

        //
        // Saved nonvolatile floating registers.
        //

        M128A Xmm6;
        M128A Xmm7;
        M128A Xmm8;
        M128A Xmm9;
        M128A Xmm10;
        M128A Xmm11;
        M128A Xmm12;
        M128A Xmm13;
        M128A Xmm14;
        M128A Xmm15;

        //
        // Kernel callout frame variables.
        //

        u64 TrapFrame;
        u64 CallbackStack;
        u64 OutputBuffer;
        u64 OutputLength;

        //
        // Saved MXCSR when a thread is interrupted in kernel mode via a dispatch
        // interrupt.
        //

        u64 MxCsr;

        //
        // Saved nonvolatile register - not always saved.
        //

        u64 Rbp;

        //
        // Saved nonvolatile registers.
        //

        u64 Rbx;
        u64 Rdi;
        u64 Rsi;
        u64 R12;
        u64 R13;
        u64 R14;
        u64 R15;

        //
        // EFLAGS and return address.
        //

        u64 Return;
    }EXCEPTION_FRAME, *PEXCEPTION_FRAME;

#define EXCEPTION_FRAME_LENGTH sizeof(EXCEPTION_FRAME)

    C_ASSERT((sizeof(EXCEPTION_FRAME) & STACK_ROUND) == 0);

#endif // _WIN64

#define GetBaseTrapFrame(Thread) GetBaseTrapFrameThread(Thread)

    PKTRAP_FRAME
        NTAPI
        GetBaseTrapFrameThread(
            __in PETHREAD Thread
        );

    FORCEINLINE
        PKAPC_STATE
        NTAPI
        GetApcStateThread(
            __in PKTHREAD Thread
        )
    {
        return CONTAINING_RECORD(
            (u)Thread +
            RtBlock.DebuggerDataBlock.OffsetKThreadApcProcess,
            KAPC_STATE,
            Process);
    }

    FORCEINLINE
        KTHREAD_STATE
        NTAPI
        GetThreadState(
            __in PKTHREAD Thread
        )
    {
        return *(PCCHAR)((u)Thread +
            RtBlock.DebuggerDataBlock.OffsetKThreadState);
    }

    FORCEINLINE
        PLIST_ENTRY
        NTAPI
        GetProcessThreadListHead(
            __inout PRTB RtBlock,
            __inout PEPROCESS Process
        )
    {
        return (PLIST_ENTRY)((u8ptr)Process +
            RtBlock->OffsetKProcessThreadListHead);
    }

    FORCEINLINE
        PETHREAD
        NTAPI
        GetProcessFirstThread(
            __inout PRTB RtBlock,
            __inout PEPROCESS Process
        )
    {
        return (PETHREAD)
            ((u8ptr)GetProcessThreadListHead(
                RtBlock, Process)->Flink -
                RtBlock->OffsetKThreadThreadListEntry);
    }

    FORCEINLINE
        PLIST_ENTRY
        NTAPI
        GetThreadListEntry(
            __inout PRTB RtBlock,
            __inout PETHREAD Thread
        )
    {
        return (PLIST_ENTRY)((u8ptr)Thread +
            RtBlock->OffsetKThreadThreadListEntry);
    }

    FORCEINLINE
        PETHREAD
        NTAPI
        GetNexThread(
            __inout PRTB RtBlock,
            __inout PETHREAD Thread
        )
    {
        return (PETHREAD)
            ((u8ptr)(((PLIST_ENTRY)((u8ptr)Thread +
                RtBlock->OffsetKThreadThreadListEntry))->Flink) -
                RtBlock->OffsetKThreadThreadListEntry);
    }

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_CTX_H_

```

`Projects/Shark/Except.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "Except.h"

void
NTAPI
CaptureImageExceptionValues(
    __in ptr Base,
    __out ptr * FunctionTable,
    __out u32ptr TableSize
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    PIMAGE_LOAD_CONFIG_DIRECTORY32 LoadConfig = NULL;
    u32 LoadConfigSize = 0;
    PIMAGE_COR20_HEADER Cor20Header = NULL;
    u32 Cor20HeaderSize = 0;

    NtHeaders = RtlImageNtHeader(Base);

    if (NULL != NtHeaders) {
        if (IMAGE_NT_OPTIONAL_HDR32_MAGIC == NtHeaders->OptionalHeader.Magic) {
            if (IMAGE_DLLCHARACTERISTICS_NO_SEH ==
                (((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.DllCharacteristics &
                    IMAGE_DLLCHARACTERISTICS_NO_SEH)) {
                *FunctionTable = LongToPtr(-1);
                *TableSize = -1;
            }
            else {
                LoadConfig = (PIMAGE_LOAD_CONFIG_DIRECTORY32)
                    RtlImageDirectoryEntryToData(
                        Base,
                        TRUE,
                        IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
                        &LoadConfigSize);

                if (NULL != LoadConfig &&
                    LoadConfig->Size >= RTL_SIZEOF_THROUGH_FIELD(
                        IMAGE_LOAD_CONFIG_DIRECTORY32,
                        SEHandlerCount) &&
                    0 != LoadConfig->SEHandlerTable &&
                    0 != LoadConfig->SEHandlerCount) {
                    *FunctionTable = UlongToPtr(LoadConfig->SEHandlerTable);
                    *TableSize = LoadConfig->SEHandlerCount;
                }
                else {
                    Cor20Header = RtlImageDirectoryEntryToData(
                        Base,
                        TRUE,
                        IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR,
                        &Cor20HeaderSize);

                    if (Cor20Header && ((Cor20Header->Flags & COMIMAGE_FLAGS_ILONLY) ==
                        COMIMAGE_FLAGS_ILONLY)) {
                        *FunctionTable = LongToPtr(-1);
                        *TableSize = -1;
                    }
                    else {
                        *FunctionTable = NULL;
                        *TableSize = 0;
                    }
                }
            }
        }
        else if (IMAGE_NT_OPTIONAL_HDR64_MAGIC == NtHeaders->OptionalHeader.Magic) {
            *FunctionTable = RtlImageDirectoryEntryToData(
                Base,
                TRUE,
                IMAGE_DIRECTORY_ENTRY_EXCEPTION,
                TableSize);
        }
    }
}

```

`Projects/Shark/Except.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _EXCEPT_H_
#define _EXCEPT_H_

#include "Reload.h"

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

    void
        NTAPI
        CaptureImageExceptionValues(
            __in ptr Base,
            __out ptr * FunctionTable,
            __out u32ptr TableSize
        );

    void
        NTAPI
        InitializeExcept(
            __inout PRTB Block
        );

#ifndef _WIN64
    typedef struct _DISPATCHER_CONTEXT {
        PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;
    } DISPATCHER_CONTEXT;
#else
    void
        NTAPI
        InsertInvertedFunctionTable(
            __in ptr ImageBase,
            __in u32 SizeOfImage
        );

    void
        NTAPI
        RemoveInvertedFunctionTable(
            __in ptr ImageBase
        );

    PRUNTIME_FUNCTION
        NTAPI
        UnwindPrologue(
            __in u64 ImageBase,
            __in u64 ControlPc,
            __in u64 FrameBase,
            __in PRUNTIME_FUNCTION FunctionEntry,
            __inout PCONTEXT ContextRecord,
            __inout_opt PKNONVOLATILE_CONTEXT_POINTERS ContextPointers
        );

    PEXCEPTION_ROUTINE
        NTAPI
        VirtualUnwind(
            __in u32 HandlerType,
            __in u64 ImageBase,
            __in u64 ControlPc,
            __in PRUNTIME_FUNCTION FunctionEntry,
            __inout PCONTEXT ContextRecord,
            __out ptr * HandlerData,
            __out u64ptr EstablisherFrame,
            __inout_opt PKNONVOLATILE_CONTEXT_POINTERS ContextPointers
        );
#endif // !_WIN64

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_EXCEPT_H_

```

`Projects/Shark/Guard.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "Guard.h"

#include "Scan.h"
#include "Reload.h"

ptr
NTAPI
GuardAllocateTrampoline(
    __in u8 NumberOfBytes
)
{
    ptr Result = NULL;

    Result = __malloc(NumberOfBytes);

    if (NULL != Result) {
        RtlZeroMemory(Result, NumberOfBytes);
    }

    return Result;
}

void
NTAPI
GuardFreeTrampoline(
    __in ptr BaseAddress,
    __in u8 NumberOfBytes
)
{
    __free(BaseAddress);
}

void
NTAPI
MapLockedCopyInstruction(
    __in ptr Destination,
    __in ptr Source,
    __in u32 Length
)
{
    s8 Instruction[4] = { 0 };
    PHYSICAL_ADDRESS PhysicalAddress = { 0 };
    ptr VirtualAddress = NULL;

    if (Length > sizeof(u32)) {
        RtlCopyMemory(Instruction, Source, sizeof(u32));
    }
    else {
        RtlCopyMemory(Instruction, Source, Length);

        RtlCopyMemory(
            Instruction + Length,
            (u8ptr)Destination + Length,
            sizeof(u32) - Length);
    }

    PhysicalAddress = MmGetPhysicalAddress(Destination);

    VirtualAddress = MmMapIoSpace(
        PhysicalAddress,
        Length,
        MmNonCached);

    if (NULL != VirtualAddress) {
        if (Length > sizeof(u32)) {
            InterlockedExchange(VirtualAddress, JUMP_SELF);

            RtlCopyMemory(
                (u8ptr)VirtualAddress + sizeof(u32),
                (u8ptr)Source + sizeof(u32),
                Length - sizeof(u32));
        }

        InterlockedExchange(VirtualAddress, *(u32ptr)Instruction);

        MmUnmapIoSpace(VirtualAddress, Length);
    }
}

void
NTAPI
MapLockedBuildJumpCode(
    __inout ptr * Pointer,
    __in ptr Guard
)
{
    GUARD_BODY GuardBody = { 0 };

    SetGuardBody(&GuardBody, Guard);

    MapLockedCopyInstruction(
        *Pointer,
        &GuardBody,
        GUARD_BODY_CODE_LENGTH);
}

void
NTAPI
LockedCopyInstruction(
    __in ptr Destination,
    __in ptr Source,
    __in u32 Length
)
{
    s8 Instruction[4] = { 0 };

    if (Length > sizeof(s32)) {
        RtlCopyMemory(Instruction, Source, sizeof(s32));
    }
    else {
        RtlCopyMemory(Instruction, Source, Length);

        RtlCopyMemory(
            Instruction + Length,
            (u8ptr)Destination + Length,
            sizeof(s32) - Length);
    }

    if (Length > sizeof(s32)) {
        InterlockedExchange(Destination, JUMP_SELF);

        RtlCopyMemory(
            (u8ptr)Destination + sizeof(s32),
            (u8ptr)Source + sizeof(s32),
            Length - sizeof(s32));
    }

    InterlockedExchange(Destination, *(s32ptr)Instruction);
}

void
NTAPI
LockedBuildJumpCode(
    __inout ptr * Pointer,
    __in ptr Guard
)
{
    GUARD_BODY GuardBody = { 0 };

    SetGuardBody(&GuardBody, Guard);

    LockedCopyInstruction(
        *Pointer,
        &GuardBody,
        GUARD_BODY_CODE_LENGTH);
}

void
NTAPI
BuildJumpCode(
    __inout ptr * Pointer,
    __in ptr Guard
)
{
    GUARD_BODY GuardBody = { 0 };

    SetGuardBody(&GuardBody, Guard);

    RtlCopyMemory(
        *Pointer,
        &GuardBody,
        GUARD_BODY_CODE_LENGTH);
}

#ifdef _WIN64
ptr
NTAPI
DisCopy8B(
    __in_opt ptr Dst,
    __in_opt ptr * DstPool,
    __in ptr Src,
    __out_opt ptr * Target,
    __out s32 * Extra
)
{
    PCHAR Instruction = NULL;
    u8 Prefix = 0;
    u8 Code = 0;
    u32 Length = 0;
    u32 GpReg = 0;
    ptr RealAddress = 0;
    ptr ReturnAddress = NULL;

    struct {
        u8 Source : 3;
        u8 Destination : 3;
        u8 Mod : 2;
    }*ModRM;

    C_ASSERT(sizeof(*ModRM) == 1);

    struct DECLSPEC_ALIGN(1) {
        u8 Prefix;

        struct {
            u8 GpReg : 3;
            u8 Inst : 5;
        }Code;

        u8 RealAddress[8];

        u8 CopyPrefix;
        u8 CopyInst;

        struct {
            u8 Source : 3;
            u8 Destination : 3;
            u8 Mod : 2;
        }CopyMod;
    }*CopyOpCode;

    C_ASSERT(sizeof(*CopyOpCode) == 13);

    Instruction = Src;

    Prefix = Instruction[0];
    Code = Instruction[1];
    ModRM = &Instruction[2];

    Instruction += 3;

    if (0 == ModRM->Mod &&
        5 == ModRM->Source) {
        // [--][--]
        // [--][--] + disp8
        // [--][--] + disp32

        GpReg = ModRM->Destination;
        RealAddress = __rva_to_va(Instruction);

        if (NULL != Target) {
            *Target = NULL;
        }

        if (NULL != Extra) {
            *Extra += 6;
        }

        if (NULL != Dst && NULL != DstPool) {
            if ((u8ptr)*DstPool - (u8ptr)Dst >= sizeof(CopyOpCode)) {
                CopyOpCode = Dst;

                CopyOpCode->Prefix = Prefix;
                CopyOpCode->Code.Inst = 0x17; // Reg <- Immediate
                CopyOpCode->Code.GpReg = GpReg;

                *(ptr *)&CopyOpCode->RealAddress = RealAddress;

                CopyOpCode->CopyPrefix = Prefix;
                CopyOpCode->CopyInst = 0x8b; // Reg <- [Reg]
                CopyOpCode->CopyMod.Destination = GpReg;
                CopyOpCode->CopyMod.Source = GpReg;
                CopyOpCode->CopyMod.Mod = 0;
            }
        }

        ReturnAddress = Instruction + sizeof(s32);
    }

    return ReturnAddress;
}
#endif // _WIN64

#ifndef _WIN64
PPATCH_HEADER
NTAPI
HotpatchAttach(
    __inout ptr * Pointer,
    __in ptr Hotpatch
)
{
    PHOTPATCH_OBJECT HotpatchObjct = NULL;
    PHOTPATCH_BODY HotpatchBody = NULL;
    s32 Relative = 0;

    HotpatchObjct = GuardAllocateTrampoline(sizeof(HOTPATCH_OBJECT));

    if (NULL != HotpatchObjct) {
        RtlZeroMemory(HotpatchObjct, sizeof(HOTPATCH_OBJECT));

        HotpatchObjct->Header.Length = sizeof(HOTPATCH_OBJECT);

        HotpatchBody = CONTAINING_RECORD(
            *Pointer,
            HOTPATCH_BODY,
            JmpSelf);

        MapLockedCopyInstruction(
            &HotpatchBody->Jmp,
            HOTPATCH_BODY_CODE,
            HOTPATCH_BODY_CODE_LENGTH - HOTPATCH_MASK_LENGTH);

        Relative =
            PtrToLong(Hotpatch) - PtrToLong(&HotpatchBody->JmpSelf);

        MapLockedCopyInstruction(
            &HotpatchBody->Hotpatch,
            &Relative,
            sizeof(s32));

        MapLockedCopyInstruction(
            &HotpatchBody->JmpSelf,
            HOTPATCH_BODY_CODE + FIELD_OFFSET(HOTPATCH_BODY, JmpSelf),
            RTL_FIELD_SIZE(HOTPATCH_BODY, JmpSelf));

        HotpatchObjct->Header.Entry = HotpatchBody + 1;
        HotpatchObjct->Header.ProgramCounter = *Pointer;
        HotpatchObjct->Header.Target = Hotpatch;

        MapLockedCopyInstruction(
            Pointer,
            &HotpatchObjct->Header.Entry,
            sizeof(ptr));
    }

    return HotpatchObjct;
}

void
NTAPI
HotpatchDetach(
    __inout ptr * Pointer,
    __in PPATCH_HEADER PatchHeader,
    __in ptr Hotpatch
)
{
    PHOTPATCH_OBJECT HotpatchObjct = NULL;
    PHOTPATCH_BODY HotpatchBody = NULL;

    HotpatchObjct = CONTAINING_RECORD(
        PatchHeader,
        HOTPATCH_OBJECT,
        Header);

    HotpatchBody = CONTAINING_RECORD(
        HotpatchObjct->Header.ProgramCounter,
        HOTPATCH_BODY,
        JmpSelf);

    MapLockedCopyInstruction(
        &HotpatchBody->JmpSelf,
        HOTPATCH_MASK,
        HOTPATCH_MASK_LENGTH);

    MapLockedCopyInstruction(
        Pointer,
        &HotpatchObjct->Header.ProgramCounter,
        sizeof(ptr));

    GuardFreeTrampoline(HotpatchObjct, HotpatchObjct->Header.Length);
}
#endif // !_WIN64

PPATCH_HEADER
NTAPI
GuardAttach(
    __inout ptr * Pointer,
    __in ptr Guard
)
{
    PGUARD_OBJECT GuardObject = NULL;
    u8ptr GuardBody = NULL;
    u8ptr Import = NULL;
    ptr Address = NULL;
    u8ptr ControlPc = NULL;
    u8ptr TargetPc = NULL;
    u32 Length = 0;
    s32 Extra = 0;
    u8ptr Target = NULL;
    u32 BytesCopied = 0;
    u8ptr Header = NULL;
    u32 FunctionCount = 1;
    u32 CodeLength = 0;

#ifdef _WIN64
    u32 FunctionIndex = 1;
    u8ptr FunctionEntry = NULL;
    u32 Index = 0;
    u8ptr Instruction = NULL;
    u32 InstructionLength = 0;
    u8ptr RealAddress = NULL;
#endif // _WIN64

    struct {
        u8 B : 1;
        u8 X : 1;
        u8 R : 1;

        // 0 = Operand size determined by CS.D
        // 1 = 64 Bit Operand Size

        u8 W : 1;
        u8 Reserved : 4; // always 0100
    }*Rex;

    struct {
        u8 Source : 3;
        u8 Destination : 3;
        u8 Mod : 2;
    }*ModRM;

    C_ASSERT(sizeof(*ModRM) == 1);

    Address = *Pointer;
    *Pointer = NULL;

    ControlPc = Address;

    while (Length < GUARD_BODY_CODE_LENGTH) {
        TargetPc = DetourCopyInstruction(
            NULL,
            NULL,
            ControlPc,
            &Target,
            &Extra);

        if (NULL != TargetPc) {
#ifdef _WIN64
            if (7 == TargetPc - ControlPc) {
                Rex = ControlPc;

                if ((4 == Rex->Reserved && 1 == Rex->W) &&
                    0 == _cmpbyte(ControlPc[1], 0x8b)) {
                    ModRM = &ControlPc[2];

                    if (0 == ModRM->Mod &&
                        5 == ModRM->Source) {
                        // [--][--]
                        // [--][--] + disp8
                        // [--][--] + disp32

                        TargetPc = DisCopy8B(
                            NULL,
                            NULL,
                            ControlPc,
                            &Target,
                            &Extra);
                    }
                }
            }
#endif // _WIN64

#ifdef _WIN64
            if (NULL != Target) {
                FunctionCount++;
            }
#endif // _WIN64

            Length += TargetPc - ControlPc;
            CodeLength += TargetPc - ControlPc + Extra;

            if (Length >= GUARD_BODY_CODE_LENGTH) {
                GuardObject = GuardAllocateTrampoline(
                    sizeof(GUARD_OBJECT) +
                    Length +
                    CodeLength +
                    GUARD_BODY_CODE_LENGTH * FunctionCount);

                if (NULL != GuardObject) {
                    RtlZeroMemory(
                        GuardObject,
                        sizeof(GUARD_OBJECT)
                        + Length
                        + CodeLength
                        + GUARD_BODY_CODE_LENGTH * FunctionCount);

                    GuardObject->Header.Length = sizeof(GUARD_OBJECT)
                        + Length
                        + CodeLength
                        + GUARD_BODY_CODE_LENGTH * FunctionCount;

                    GuardObject->Original = GuardObject + 1;
                    GuardObject->Length = Length;

                    GuardBody = (u8ptr)GuardObject->Original + GuardObject->Length;
                    Import = GuardBody + CodeLength;

                    RtlCopyMemory(GuardObject->Original, Address, GuardObject->Length);

                    ControlPc = Address;
                    Length = 0;

                    while (Length < GUARD_BODY_CODE_LENGTH) {
                        TargetPc = DetourCopyInstruction(
                            GuardBody + BytesCopied,
                            &Import,
                            ControlPc,
                            &Target,
                            &Extra);

                        if (NULL != TargetPc) {
#ifdef _WIN64
                            if (7 == TargetPc - ControlPc) {
                                Rex = ControlPc;

                                if ((4 == Rex->Reserved && 1 == Rex->W) &&
                                    0 == _cmpbyte(ControlPc[1], 0x8b)) {
                                    ModRM = &ControlPc[2];

                                    if (0 == ModRM->Mod &&
                                        5 == ModRM->Source) {
                                        // [--][--]
                                        // [--][--] + disp8
                                        // [--][--] + disp32

                                        TargetPc = DisCopy8B(
                                            GuardBody + BytesCopied,
                                            &Import,
                                            ControlPc,
                                            &Target,
                                            &Extra);
                                    }
                                }
                            }
#endif // _WIN64

#ifdef _WIN64
                            if (NULL != Target) {
                                Instruction = GuardBody + BytesCopied;
                                InstructionLength = TargetPc - ControlPc + Extra;

                                FunctionEntry =
                                    Import + GUARD_BODY_CODE_LENGTH * FunctionIndex;

                                LockedBuildJumpCode(&FunctionEntry, Target);

                                for (Index = 0;
                                    Index <= InstructionLength - sizeof(s32);
                                    Index++) {
                                    RealAddress = __rva_to_va(Instruction + Index);

                                    if (*(s32ptr)&Target == *(s32ptr)&RealAddress) {
                                        *(s32ptr)(Instruction + Index) =
                                            FunctionEntry - ((Instruction + Index) + sizeof(s32));
                                    }
                                }

                                FunctionIndex++;
                            }
#endif // _WIN64

                            Length += TargetPc - ControlPc;
                            BytesCopied += TargetPc - ControlPc + Extra;

                            if (Length >= GUARD_BODY_CODE_LENGTH) {
                                LockedBuildJumpCode(&Import, TargetPc);
                                MapLockedBuildJumpCode(&Address, Guard);

                                GuardObject->Header.Entry = GuardBody;
                                GuardObject->Header.ProgramCounter = Address;
                                GuardObject->Header.Target = Guard;

                                LockedCopyInstruction(
                                    Pointer,
                                    &GuardObject->Header.Entry,
                                    sizeof(ptr));

                                break;
                            }

                            ControlPc = TargetPc;
                        }
                        else {
                            break;
                        }
                    }
                }

                break;
            }

            ControlPc = TargetPc;
        }
        else {
            break;
        }
    }

    return GuardObject;
}

void
NTAPI
GuardDetach(
    __inout ptr * Pointer,
    __in PPATCH_HEADER PatchHeader,
    __in ptr Guard
)
{
    PGUARD_OBJECT GuardObject = NULL;

    GuardObject = CONTAINING_RECORD(
        PatchHeader,
        GUARD_OBJECT,
        Header);

    if (PatchHeader->Target == Guard &&
        *Pointer == GuardObject->Header.Entry) {
        MapLockedCopyInstruction(
            GuardObject->Header.ProgramCounter,
            GuardObject->Original,
            GuardObject->Length);

        LockedCopyInstruction(
            Pointer,
            &GuardObject->Header.ProgramCounter,
            sizeof(ptr));

        GuardFreeTrampoline(GuardObject, GuardObject->Header.Length);
    }
}

PPATCH_HEADER
NTAPI
SafeGuardAttach(
    __inout ptr * Pointer,
    __in PGUARD_CALLBACK Callback,
    __in_opt ptr CaptureContext,
    __in_opt ptr Parameter,
    __in_opt ptr Reserved
)
{
    PSAFEGUARD_OBJECT GuardObject = NULL;
    u8ptr GuardBody = NULL;
    u8ptr Import = NULL;
    ptr Address = NULL;
    u8ptr ControlPc = NULL;
    u8ptr TargetPc = NULL;
    u32 Length = 0;
    s32 Extra = 0;
    u8ptr Target = NULL;
    u32 BytesCopied = 0;
    u8ptr Header = NULL;
    u32 FunctionCount = 1;
    u32 CodeLength = 0;

#ifdef _WIN64
    u32 FunctionIndex = 1;
    u8ptr FunctionEntry = NULL;
    u32 Index = 0;
    u8ptr Instruction = NULL;
    u32 InstructionLength = 0;
    u8ptr RealAddress = NULL;
#endif // _WIN64

    struct {
        u8 B : 1;
        u8 X : 1;
        u8 R : 1;

        // 0 = Operand size determined by CS.D
        // 1 = 64 Bit Operand Size

        u8 W : 1;
        u8 Reserved : 4; // always 0100
    }*Rex;

    struct {
        u8 Source : 3;
        u8 Destination : 3;
        u8 Mod : 2;
    }*ModRM;

    C_ASSERT(sizeof(*ModRM) == 1);

    Address = *Pointer;
    *Pointer = NULL;

    ControlPc = Address;

    while (Length < GUARD_BODY_CODE_LENGTH) {
        TargetPc = DetourCopyInstruction(
            NULL,
            NULL,
            ControlPc,
            &Target,
            &Extra);

        if (NULL != TargetPc) {
#ifdef _WIN64
            if (7 == TargetPc - ControlPc) {
                Rex = ControlPc;

                if ((4 == Rex->Reserved && 1 == Rex->W) &&
                    0 == _cmpbyte(ControlPc[1], 0x8b)) {
                    ModRM = &ControlPc[2];

                    if (0 == ModRM->Mod &&
                        5 == ModRM->Source) {
                        // [--][--]
                        // [--][--] + disp8
                        // [--][--] + disp32

                        TargetPc = DisCopy8B(
                            NULL,
                            NULL,
                            ControlPc,
                            &Target,
                            &Extra);
                    }
                }
            }
#endif // _WIN64

#ifdef _WIN64
            if (NULL != Target) {
                FunctionCount++;
            }
#endif // _WIN64

            Length += TargetPc - ControlPc;
            CodeLength += TargetPc - ControlPc + Extra;

            if (Length >= GUARD_BODY_CODE_LENGTH) {
                GuardObject = GuardAllocateTrampoline(
                    sizeof(SAFEGUARD_OBJECT) +
                    Length +
                    CodeLength +
                    GUARD_BODY_CODE_LENGTH * FunctionCount);

                if (NULL != GuardObject) {
                    RtlZeroMemory(
                        GuardObject,
                        sizeof(SAFEGUARD_OBJECT)
                        + Length
                        + CodeLength
                        + GUARD_BODY_CODE_LENGTH * FunctionCount);

                    GuardObject->Header.Length = sizeof(SAFEGUARD_OBJECT)
                        + Length
                        + CodeLength
                        + GUARD_BODY_CODE_LENGTH * FunctionCount;

                    GuardObject->Original = GuardObject + 1;
                    GuardObject->Length = Length;

                    GuardBody = (u8ptr)GuardObject->Original + GuardObject->Length;
                    Import = GuardBody + CodeLength;

                    RtlCopyMemory(GuardObject->Original, Address, GuardObject->Length);

                    ControlPc = Address;
                    Length = 0;

                    while (Length < GUARD_BODY_CODE_LENGTH) {
                        TargetPc = DetourCopyInstruction(
                            GuardBody + BytesCopied,
                            &Import,
                            ControlPc,
                            &Target,
                            &Extra);

                        if (NULL != TargetPc) {
#ifdef _WIN64
                            if (7 == TargetPc - ControlPc) {
                                Rex = ControlPc;

                                if ((4 == Rex->Reserved && 1 == Rex->W) &&
                                    0 == _cmpbyte(ControlPc[1], 0x8b)) {
                                    ModRM = &ControlPc[2];

                                    if (0 == ModRM->Mod &&
                                        5 == ModRM->Source) {
                                        // [--][--]
                                        // [--][--] + disp8
                                        // [--][--] + disp32

                                        TargetPc = DisCopy8B(
                                            GuardBody + BytesCopied,
                                            &Import,
                                            ControlPc,
                                            &Target,
                                            &Extra);
                                    }
                                }
                            }
#endif // _WIN64

#ifdef _WIN64
                            if (NULL != Target) {
                                Instruction = GuardBody + BytesCopied;
                                InstructionLength = TargetPc - ControlPc + Extra;

                                FunctionEntry =
                                    Import + GUARD_BODY_CODE_LENGTH * FunctionIndex;

                                LockedBuildJumpCode(&FunctionEntry, Target);

                                for (Index = 0;
                                    Index <= InstructionLength - sizeof(s32);
                                    Index++) {
                                    RealAddress = __rva_to_va(Instruction + Index);

                                    if (*(s32ptr)&Target == *(s32ptr)&RealAddress) {
                                        *(s32ptr)(Instruction + Index) =
                                            FunctionEntry - ((Instruction + Index) + sizeof(s32));
                                    }
                                }

                                FunctionIndex++;
                            }
#endif // _WIN64

                            Length += TargetPc - ControlPc;
                            BytesCopied += TargetPc - ControlPc + Extra;

                            if (Length >= GUARD_BODY_CODE_LENGTH) {
                                LockedBuildJumpCode(&Import, TargetPc);

                                CaptureContext =
                                    NULL == CaptureContext ?
                                    _CaptureContext : CaptureContext;

                                SetStackBody(
                                    &GuardObject->Body,
                                    Reserved,
                                    Parameter,
                                    Callback,
                                    GuardBody,
                                    Address,
                                    CaptureContext);

                                MapLockedBuildJumpCode(&Address, &GuardObject->Body);

                                GuardObject->Header.Entry = GuardBody;
                                GuardObject->Header.ProgramCounter = Address;
                                GuardObject->Header.Target = Callback;

                                LockedCopyInstruction(
                                    Pointer,
                                    &GuardObject->Header.Entry,
                                    sizeof(ptr));

                                break;
                            }

                            ControlPc = TargetPc;
                        }
                        else {
                            break;
                        }
                    }
                }

                break;
            }

            ControlPc = TargetPc;
        }
        else {
            break;
        }
    }

    return GuardObject;
}

void
NTAPI
SafeGuardDetach(
    __inout ptr * Pointer,
    __in PPATCH_HEADER PatchHeader,
    __in PGUARD_CALLBACK Callback
)
{
    PSAFEGUARD_OBJECT GuardObject = NULL;

    GuardObject = CONTAINING_RECORD(
        PatchHeader,
        SAFEGUARD_OBJECT,
        Header);

    if (PatchHeader->Target == Callback &&
        *Pointer == GuardObject->Header.Entry) {
        MapLockedCopyInstruction(
            GuardObject->Header.ProgramCounter,
            GuardObject->Original,
            GuardObject->Length);

        LockedCopyInstruction(
            Pointer,
            &GuardObject->Header.ProgramCounter,
            sizeof(ptr));

        GuardFreeTrampoline(GuardObject, GuardObject->Header.Length);
    }
}

```

`Projects/Shark/Guard.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _GUARD_H_
#define _GUARD_H_

#include <guarddefs.h>

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

    //////////////////////////////////////////////////////////////////////////////
    //
    //  Function:
    //      DetourCopyInstruction(ptr pDst,
    //                            ptr *ppDstPool
    //                            ptr pSrc,
    //                            ptr *ppTarget,
    //                            s32 *plExtra)
    //  Purpose:
    //      Copy a single instruction from pSrc to pDst.
    //
    //  Arguments:
    //      pDst:
    //          Destination address for the instruction.  May be NULL in which
    //          case DetourCopyInstruction is used to measure an instruction.
    //          If not NULL then the source instruction is copied to the
    //          destination instruction and any relative arguments are adjusted.
    //      ppDstPool:
    //          Destination address for the end of the constant pool.  The
    //          constant pool works backwards toward pDst.  All memory between
    //          pDst and *ppDstPool must be available for use by this function.
    //          ppDstPool may be NULL if pDst is NULL.
    //      pSrc:
    //          Source address of the instruction.
    //      ppTarget:
    //          Out parameter for any target instruction address pointed to by
    //          the instruction.  For example, a branch or a jump insruction has
    //          a target, but a load or store instruction doesn't.  A target is
    //          another instruction that may be executed as a result of this
    //          instruction.  ppTarget may be NULL.
    //      plExtra:
    //          Out parameter for the number of extra bytes needed by the
    //          instruction to reach the target.  For example, lExtra = 3 if the
    //          instruction had an 8-bit relative offset, but needs a 32-bit
    //          relative offset.
    //
    //  Returns:
    //      Returns the address of the next instruction (following in the source)
    //      instruction.  By subtracting pSrc from the return value, the caller
    //      can determinte the size of the instruction copied.
    //
    //  Comments:
    //      By following the pTarget, the caller can follow alternate
    //      instruction streams.  However, it is not always possible to determine
    //      the target based on static analysis.  For example, the destination of
    //      a jump relative to a register cannot be determined from just the
    //      instruction stream.  The output value, pTarget, can have any of the
    //      following outputs:
    //          DETOUR_INSTRUCTION_TARGET_NONE:
    //              The instruction has no targets.
    //          DETOUR_INSTRUCTION_TARGET_DYNAMIC:
    //              The instruction has a non-deterministic (dynamic) target.
    //              (i.e. the jump is to an address held in a register.)
    //          Address:   The instruction has the specified target.
    //
    //      When copying instructions, DetourCopyInstruction insures that any
    //      targets remain constant.  It does so by adjusting any IP relative
    //      offsets.
    //
    //////////////////////////////////////////////////////////////////////////////

    ptr
        NTAPI
        DetourCopyInstruction(
            __in_opt ptr pDst,
            __in_opt ptr * ppDstPool,
            __in ptr pSrc,
            __out_opt ptr * ppTarget,
            __out s32 * plExtra
        );

    DECLSPEC_NORETURN
        void
        NTAPI
        _CaptureContext(
            __in u32 ProgramCounter,
            __in ptr Guard,
            __in PGUARD_CALLBACK Callback,
            __in_opt ptr Parameter,
            __in_opt ptr Reserved
        );

    void
        NTAPI
        MapLockedCopyInstruction(
            __in ptr Destination,
            __in ptr Source,
            __in u32 Length
        );

    void
        NTAPI
        MapLockedBuildJumpCode(
            __inout ptr * Pointer,
            __in ptr Guard
        );

    void
        NTAPI
        LockedCopyInstruction(
            __in ptr Destination,
            __in ptr Source,
            __in u32 Length
        );

    void
        NTAPI
        LockedBuildJumpCode(
            __inout ptr * Pointer,
            __in ptr Guard
        );

    void
        NTAPI
        BuildJumpCode(
            __inout ptr * Pointer,
            __in ptr Guard
        );

#ifndef _WIN64
    PPATCH_HEADER
        NTAPI
        HotpatchAttach(
            __inout ptr * Pointer,
            __in ptr Hotpatch
        );

    void
        NTAPI
        HotpatchDetach(
            __inout ptr * Pointer,
            __in PPATCH_HEADER PatchHeader,
            __in ptr Hotpatch
        );
#endif // !_WIN64

    PPATCH_HEADER
        NTAPI
        GuardAttach(
            __inout ptr * Pointer,
            __in ptr Guard
        );

    void
        NTAPI
        GuardDetach(
            __inout ptr * Pointer,
            __in PPATCH_HEADER PatchHeader,
            __in ptr Guard
        );

    PPATCH_HEADER
        NTAPI
        SafeGuardAttach(
            __inout ptr * Pointer,
            __in PGUARD_CALLBACK Callback,
            __in_opt ptr CaptureContext,
            __in_opt ptr Parameter,
            __in_opt ptr Reserved
        );

    void
        NTAPI
        SafeGuardDetach(
            __inout ptr * Pointer,
            __in PPATCH_HEADER PatchHeader,
            __in PGUARD_CALLBACK Callback
        );

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_GUARD_H_

```

`Projects/Shark/I386/CmpI386.asm`:

```asm
;
;
; Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
;
; The contents of this file are subject to the Mozilla Public License Version
; 2.0 (the "License"); you may not use this file except in compliance with
; the License. You may obtain a copy of the License at
; http://www.mozilla.org/MPL/
;
; Software distributed under the License is distributed on an "AS IS" basis,
; WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
; for the specific language governing rights and limitations under the
; License.
;
; The Initial Developer of the Original Code is blindtiger.
;
;

.686

        .xlist
include callconv.inc
        .list
        
_TEXT$00    SEGMENT PAGE 'CODE'

; b
;     NTAPI
;     _cmpbyte(
;         __in s8 b1,
;         __in s8 b2
;     );

    cPublicProc __cmpbyte, 2

        mov cl, [esp + 4]
        mov dl, [esp + 8]
        cmp cl, dl
        setnz al

        stdRET __cmpbyte

    stdENDP __cmpbyte
    
; b
;     NTAPI
;     _cmpword(
;         __in s16 s1,
;         __in s16 s2
;     );

    cPublicProc __cmpword, 2

        mov cx, [esp + 4]
        mov dx, [esp + 8]
        cmp cx, dx
        setnz al
        
        stdRET __cmpword

    stdENDP __cmpword

; b
;     NTAPI
;     _cmpdword(
;         __in s32 l1,
;         __in s32 l2
;     );

    cPublicProc __cmpdword, 2

        mov ecx, [esp + 4]
        mov edx, [esp + 8]
        cmp ecx, edx
        setnz al
        
        stdRET __cmpdword

    stdENDP __cmpdword
    
; b
;     NTAPI
;     _cmpqword(
;         __in s64 ll1,
;         __in s64 ll2
;     );

    cPublicProc __cmpqword, 4

        mov ecx, [esp + 4]
        mov edx, [esp + 0ch]
        cmp ecx, edx

        jnz @f
    
        mov ecx, [esp + 8h]
        mov edx, [esp + 10h]
        cmp ecx, edx

    @@ :
        setnz al
        
        stdRET __cmpqword

    stdENDP __cmpqword

_TEXT$00    ends

        end

```

`Projects/Shark/I386/ContextI386.asm`:

```asm
;
;
; Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
;
; The contents of this file are subject to the Mozilla Public License Version
; 2.0 (the "License"); you may not use this file except in compliance with
; the License. You may obtain a copy of the License at
; http://www.mozilla.org/MPL/
;
; Software distributed under the License is distributed on an "AS IS" basis,
; WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
; for the specific language governing rights and limitations under the
; License.
;
; The Initial Developer of the Original Code is blindtiger.
;
;

.686p

        .xlist
include ks386.inc
include callconv.inc
        .list
        
_TEXT$00    SEGMENT PAGE 'CODE'

; DECLSPEC_NORETURN
;     void
;     STDCALL
;     _CaptureContext(
;         __in u32 ProgramCounter,
;         __in ptr Guard,
;         __in PGUARD_CALLBACK Callback,
;         __in_opt ptr Parameter,
;         __in_opt ptr Reserved
;     );

StackPointer EQU 14h
Reserved EQU 10h
Parameter EQU 0ch
Callback EQU 8
Guard EQU 4
ProgramCounter EQU 0

    cPublicProc __CaptureContext, 5
    
        pushfd

        sub esp, ContextFrameLength - 4
        
        push ebx
        
        lea ebx, [esp]

        and ebx, not 7

        pop [ebx].CsEbx

        mov [ebx].CsSegEs, es
        mov [ebx].CsSegCs, cs
        mov [ebx].CsSegSs, ss
        mov [ebx].CsSegDs, ds
        mov [ebx].CsSegFs, fs
        mov [ebx].CsSegGs, gs
        
        mov [ebx].CsEax, eax
        mov [ebx].CsEcx, ecx
        mov [ebx].CsEdx, edx

        mov [ebx].CsEbp, ebp
        mov [ebx].CsEsi, esi
        mov [ebx].CsEdi, edi
        
        mov eax, [esp - 4].ContextFrameLength
        mov [ebx].CsEFlags, eax

        lea eax, [esp].ContextFrameLength.StackPointer
        mov [ebx].CsEsp, eax

        mov eax, [esp].ContextFrameLength.Guard
        mov [ebx].CsEip, eax
        
        mov eax, CONTEXT_FULL
        mov [ebx].CsContextFlags, eax
        
        mov edx, [esp].ContextFrameLength.ProgramCounter
        lea ecx, [ebx]
        mov edi, [esp].ContextFrameLength.Reserved
        mov esi, [esp].ContextFrameLength.Parameter
        mov eax, [esp].ContextFrameLength.Callback
        
        push edi
        push esi
        push edx
        push ecx

        call eax

    stdENDP __CaptureContext
    
_TEXT$00    ends

        end

```

`Projects/Shark/I386/ExceptI386.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "Except.h"

#include "Guard.h"
#include "Scan.h"
#include "Space.h"

void
NTAPI
InitializeExcept(
    __inout PRTB Block
)
{
    ptr ImageBase = NULL;
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    PIMAGE_SECTION_HEADER NtSection = NULL;
    u32 SizeToLock = 0;
    u8ptr ControlPc = NULL;
    u8ptr TargetPc = NULL;
    u32 Length = 0;
    ptr RoutineAddress = NULL;
    u32 Count = 0;
    UNICODE_STRING String = { 0 };

    s8 RtlDispatchException[] =
        { 0xc7, 0x41, 0x04, 0x01, 0x00, 0x00, 0x00, 0x54, 0x51 };

    s8 Hotpatch[] =
        { 0xb8, 0x01, 0x00, 0x00, 0x00, 0x90, 0x90 , 0x90 };

    s8 RtlIsValidHandler[] = "8B ?? ?? E8 ?? ?? ?? ?? 84 C0";
    s8 RtlpIsValidExceptionChain[] = "8B ?? E8 ?? ?? ?? ?? 84 C0";

    RtlInitUnicodeString(&String, L"ExRaiseStatus");

    RoutineAddress = MmGetSystemRoutineAddress(&String);

    if (NULL != RoutineAddress) {
        ControlPc = RoutineAddress;

        while (TRUE) {
            Length = DetourGetInstructionLength(ControlPc);

            if (7 == Length) {
                if (sizeof(RtlDispatchException) == RtlCompareMemory(
                    ControlPc,
                    RtlDispatchException,
                    sizeof(RtlDispatchException))) {
                    RoutineAddress =
                        __rva_to_va((ControlPc
                            + sizeof(RtlDispatchException)) + 1);

#ifdef DEBUG
                    vDbgPrint(
                        "[SHARK] < %p > RtlDispatchException\n",
                        RoutineAddress);
#endif // DEBUG

                    break;
                }
            }

            ControlPc += Length;
        }

        ControlPc = ScanBytes(
            RoutineAddress,
            (u8ptr)RoutineAddress + PAGE_SIZE,
            RtlIsValidHandler);

        if (NULL != ControlPc) {
            TargetPc = __rva_to_va(ControlPc + 4);

#ifdef DEBUG
            vDbgPrint(
                "[SHARK] < %p > RtlIsValidHandler\n",
                TargetPc);
#endif // DEBUG

            ControlPc = TargetPc;

            while (TRUE) {
                Length = DetourGetInstructionLength(ControlPc);

                if (0 == _cmpbyte(ControlPc[0], 0xc3) ||
                    0 == _cmpbyte(ControlPc[0], 0xc2)) {
                    RtlCopyMemory(
                        Hotpatch + 5,
                        ControlPc,
                        Length);

                    MapLockedCopyInstruction(
                        TargetPc,
                        Hotpatch,
                        RTL_NUMBER_OF(Hotpatch));

                    break;
                }

                ControlPc += Length;
            }
        }

        if (RtBlock.BuildNumber >= 9600) {
            ControlPc = ScanBytes(
                RoutineAddress,
                (u8ptr)RoutineAddress + PAGE_SIZE,
                RtlpIsValidExceptionChain);

            if (NULL != ControlPc) {
                TargetPc = __rva_to_va(ControlPc + 3);

#ifdef DEBUG
                vDbgPrint(
                    "[SHARK] < %p > RtlpIsValidExceptionChain\n",
                    TargetPc);
#endif // DEBUG

                ControlPc = TargetPc;

                while (TRUE) {
                    Length = DetourGetInstructionLength(ControlPc);

                    if (0 == _cmpbyte(ControlPc[0], 0xc3) ||
                        0 == _cmpbyte(ControlPc[0], 0xc2)) {
                        RtlCopyMemory(
                            Hotpatch + 5,
                            ControlPc,
                            Length);

                        MapLockedCopyInstruction(
                            TargetPc,
                            Hotpatch,
                            RTL_NUMBER_OF(Hotpatch));

                        break;
                    }

                    ControlPc += Length;
                }
            }
        }
    }
}

```

`Projects/Shark/I386/I386.asm`:

```asm
;
;
; Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
;
; The contents of this file are subject to the Mozilla Public License Version
; 2.0 (the "License"); you may not use this file except in compliance with
; the License. You may obtain a copy of the License at
; http://www.mozilla.org/MPL/
;
; Software distributed under the License is distributed on an "AS IS" basis,
; WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
; for the specific language governing rights and limitations under the
; License.
;
; The Initial Developer of the Original Code is blindtiger.
;
;

.686p

        .xlist
include ks386.inc
include callconv.inc
        .list
        
_TEXT$00    SEGMENT PAGE 'CODE'
                              
    cPublicProc _DriverEntry, 2
        
        xor eax, eax

        stdRET _DriverEntry
        
    stdENDP _DriverEntry
        
    cPublicProc __FlushSingleTb, 1
        
        mov eax, [esp + 4]
        invlpg [eax]

        stdRET __FlushSingleTb
        
    stdENDP __FlushSingleTb
        
    cPublicProc __GetPdeAddress, 2
    
        mov eax, [esp + 4]
        shr eax, 15h
        shl eax, 3
        add eax, [esp + 8]

        stdRET __GetPdeAddress
        
    stdENDP __GetPdeAddress
    
    cPublicProc __GetPdeAddressPae, 2
    
        mov eax, [esp + 4]
        shr eax, 16h
        shl eax, 2
        add eax, [esp + 8]

        stdRET __GetPdeAddressPae
        
    stdENDP __GetPdeAddressPae
    
    cPublicProc __GetPteAddress, 2
    
        mov eax, [esp + 4]
        shr eax, 0ch
        shl eax, 2
        add eax, [esp + 8]

        stdRET __GetPteAddress
        
    stdENDP __GetPteAddress
    
    cPublicProc __GetPteAddressPae, 2
    
        mov eax, [esp + 4]
        shr eax, 0ch
        shl eax, 3
        add eax, [esp + 8]

        stdRET __GetPteAddressPae
        
    stdENDP __GetPteAddressPae
    
    cPublicProc __GetVaMappedByPte, 1
    
        mov eax, [esp + 4]
        shl eax, 0ah

        stdRET __GetVaMappedByPte
        
    stdENDP __GetVaMappedByPte
    
    cPublicProc __GetVaMappedByPtePae, 1
    
        mov eax, [esp + 4]
        shl eax, 9

        stdRET __GetVaMappedByPtePae
        
    stdENDP __GetVaMappedByPtePae
    
    cPublicProc __GetVaMappedByPde, 1
    
        mov eax, [esp + 4]
        shl eax, 14h

        stdRET __GetVaMappedByPde
        
    stdENDP __GetVaMappedByPde
    
    cPublicProc __GetVaMappedByPdePae, 1
    
        mov eax, [esp + 4]
        shl eax, 12h

        stdRET __GetVaMappedByPdePae
        
    stdENDP __GetVaMappedByPdePae
    
_TEXT$00    ends

        end

```

`Projects/Shark/I386/PatchGuardI386.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "PatchGuard.h"

VOID
NTAPI
PgClear(
    __inout PPGBLOCK PgBlock
)
{
    NOTHING;
}

```

`Projects/Shark/I386/SpaceI386.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "Space.h"

#include "Guard.h"
#include "Reload.h"
#include "Rtx.h"
#include "Scan.h"

void
NTAPI
InitializeSpace(
    __inout PRTB Block
)
{
    Block->PteBase = (PMMPTE)PTE_BASE;
    Block->PteTop = (PMMPTE)PTE_TOP;

    if (Block->DebuggerDataBlock.PaeEnabled) {
        Block->PdeBase = (PMMPTE)PDE_BASE_X86PAE;
    }
    else {
        Block->PdeBase = (PMMPTE)PDE_BASE_X86;
    }

    Block->PdeTop = (PMMPTE)PDE_TOP;
}

PMMPTE
NTAPI
GetPdeAddress(
    __in ptr VirtualAddress
)
{
    return (PMMPTE)(0 != RtBlock.DebuggerDataBlock.PaeEnabled ?
        _GetPdeAddressPae(VirtualAddress, RtBlock.PdeBase) :
        _GetPdeAddress(VirtualAddress, RtBlock.PdeBase));
}

PMMPTE
NTAPI
GetPteAddress(
    __in ptr VirtualAddress
)
{
    return (PMMPTE)(0 != RtBlock.DebuggerDataBlock.PaeEnabled ?
        _GetPteAddressPae(VirtualAddress, RtBlock.PteBase) :
        _GetPteAddress(VirtualAddress, RtBlock.PteBase));
}

ptr
NTAPI
GetVaMappedByPte(
    __in PMMPTE Pte
)
{
    return (ptr)(0 != RtBlock.DebuggerDataBlock.PaeEnabled ?
        _GetVaMappedByPtePae(Pte) :
        _GetVaMappedByPte(Pte));
}

ptr
NTAPI
GetVaMappedByPde(
    __in PMMPTE Pde
)
{
    return (ptr)(0 != RtBlock.DebuggerDataBlock.PaeEnabled ?
        _GetVaMappedByPdePae(Pde) :
        _GetVaMappedByPde(Pde));
}

```

`Projects/Shark/I386/StackI386.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "Stack.h"

DECLSPEC_NOINLINE
u32
NTAPI
WalkFrameChain(
    __out PCALLERS Callers,
    __in u32 Count
)
{
    u32 Fp = 0;
    u32 Index = 0;
    u32 Top = 0;
    u32 Bottom = 0;

    IoGetStackLimits(&Bottom, &Top);

    _asm mov Fp, ebp;

    while (Index < Count &&
        Fp >= Bottom &&
        Fp < Top) {
        Callers[Index].Establisher = (ptr)(*(u32ptr)(Fp + 4));
        Callers[Index].EstablisherFrame = (ptr *)(Fp + 8);

        Index += 1;
        Fp = *(u32ptr)Fp;
    }

    return Index;
}

```

`Projects/Shark/Makefile`:

```
#
#
# Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
#
# The contents of this file are subject to the Mozilla Public License Version
# 2.0 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
# for the specific language governing rights and limitations under the
# License.
#
# The Initial Developer of the Original Code is blindtiger.
#
#

LABS=..\..\..

!if "$(PLATFORM)" == "x86"
ARCTARG = I386
!if "$(PROCESSOR_ARCHITEW6432)" == "AMD64"
PATH = C:\Windows;C:\Windows\System32;$(LABS)\MiniSDK\bin\Hostx64\x86
!else
PATH = C:\Windows;C:\Windows\System32;$(LABS)\MiniSDK\bin\Hostx86\x86
!endif
!else if "$(PLATFORM)" == "x64"
ARCTARG = AMD64
!if "$(PROCESSOR_ARCHITEW6432)" == "AMD64"
PATH = C:\Windows;C:\Windows\System32;$(LABS)\MiniSDK\bin\Hostx64\x64
!else
PATH = C:\Windows;C:\Windows\System32;$(LABS)\MiniSDK\bin\Hostx86\x64
!endif
!else
!ERROR Usage: nmake (PLATFORM=x86|x64) (PROJ=ProjectName) (SLND=SolutionDir) [build|clean|rebuild]
!endif

BIND = $(SLND)Build\Bins\$(ARCTARG)

PROJTARG = $(BIND)\$(PROJ)
PROJD = $(SLND)Projects\$(PROJ)

BUILD: $(PROJTARG).sys

OBJD = $(SLND)Build\Objs\$(PROJ)\$(ARCTARG)
                           
PROJENTRY = __security_init_cookie

ASOBJS = \
    $(OBJD)\$(ARCTARG).obj \
    $(OBJD)\Cmp$(ARCTARG).obj

CCARCHOBJS = \
    $(OBJD)\Context$(ARCTARG).obj \
    $(OBJD)\Except$(ARCTARG).obj \
    $(OBJD)\PatchGuard$(ARCTARG).obj \
    $(OBJD)\Space$(ARCTARG).obj \
    $(OBJD)\Stack$(ARCTARG).obj

CCOBJS = \
    $(OBJD)\$(PROJ).obj \
    $(OBJD)\Ctx.obj \
    $(OBJD)\Guard.obj \
    $(OBJD)\Except.obj \
    $(OBJD)\PatchGuard.obj \
    $(OBJD)\Reload.obj \
    $(OBJD)\Rtx.obj \
    $(OBJD)\Scan.obj \
    $(OBJD)\Space.obj \
    $(OBJD)\Stack.obj
    
RCOBJS = $(OBJD)\$(PROJ).res

PROJOBJS = $(ASOBJS) $(CCARCHOBJS) $(CCOBJS) $(RCOBJS)

!if "$(ARCTARG)" == "I386"
TARGDEFS = /D_X86_=1 /Di386=1 /DSTD_CALL /DFPO=0 /DDOSWIN32 /DDETOURS_X86 /DDETOURS_32BIT
TARGAOPTS = /safeseh /coff /Zm
TARGCOPTS = /Gz /Gm- /EHs-c- /Od /Oy-
TARGLOPTS = 
HOTPATCH = /stub:$(LABS)\WRK\base\ntos\BUILD\PREBUILT\$(ARCTARG)\STUB512.com
ARCH = X86
ARCHML = ml
!else if "$(ARCTARG)" == "AMD64"
TARGDEFS = /D_WIN64 /D_AMD64_ /DAMD64 /DDETOURS_X64 /DDETOURS_64BIT
TARGAOPTS = 
TARGCOPTS = /Od /EHs-c- /Gs12288
TARGLOPTS = /IGNORE:4108,4088,4218,4218,4235
HOTPATCH = $(LABS)\WRK\base\ntos\BUILD\PREBUILT\$(ARCTARG)\HOTPATCH.obj
ARCH = AMD64
ARCHML = ml64
!endif

PROJLOPTS = /SUBSYSTEM:NATIVE /ENTRY:$(PROJENTRY) /DEF:$(PROJ).def

INCS = \
    /I$(LABS)\MiniSDK\inc\ddk \
    /I$(LABS)\MiniSDK\inc\halkit \
    /I$(LABS)\MiniSDK\inc\internal\base \
    /I$(LABS)\MiniSDK\inc\internal\ds \
    /I$(LABS)\MiniSDK\inc\internal\sdktools \
    /I$(LABS)\MiniSDK\inc\sdk \
    /I$(LABS)\MiniSDK\inc\sdk\crt \
    /I$(LABS)\MiniSDK\inc\sdk\crt\gl \
    /I$(LABS)\MiniSDK\inc\sdk\crt\sys \
    /I$(LABS)\MiniSDK\inc\base \
    /I$(LABS)\MiniSDK\inc\base\ntos \
    /I$(LABS)\MiniSDK\inc\base\ntos\VERIFIER \
    /I$(SLND)\Include \
    /I$(PROJD)

DEFS = /DUNICODE /D_UNICODE $(TARGDEFS) /DCONDITION_HANDLING=1 /DNT_INST=0 /DWIN32=100 /D_NT1X_=100 /DWINNT=1 \
    /DDEVL=1 /DNDEBUG /D_NTSYSTEM_ /DNT_SMT /DNTOS_KERNEL_RUNTIME=1 /D_NTDRIVER_

COPTS = /Z7 /Zl /Zp8 /Gy /cbstring /W3 /WX /GR- /GF /GS $(TARGCOPTS)
COMPILERWARNINGS = /FI$(LABS)\WRK\base\ntos\BUILD\WARNING.h /FI$(SLND)\Include\WARNING.h

AOPTS = /Cx /Zi /Zd $(TARGAOPTS)
AS = $(ARCHML).exe /nologo
AFLAGS = $(AOPTS) $(INCS) /Fo$(OBJD)\ $(DEFS) $(SPECIALAFLAGS)

CC = cl.exe /nologo
CFLAGS = $(COPTS) $(INCS) /Fo$(OBJD)\ $(DEFS) $(SPECIALCFLAGS) $(COMPILERWARNINGS)

RC = rc.exe /nologo
RFLAGS = $(INCS) /fo$(RCOBJS)
                  
LINKLIBPATH = \
    /LIBPATH:$(LABS)\MiniSDK\lib\$(ARCTARG) \
    /LIBPATH:$(LABS)\MiniSDK\lib\Crt\$(ARCTARG) \
    /LIBPATH:$(SLND)\Lib\$(ARCTARG)

LINKIGNORE = /IGNORE:4087,4001,4010,4037,4039,4065,4070,4078,4087,4089,4221,4198
BUILDLIBS = hal.lib ntoskrnl.lib bufferoverflowk.lib \
!if "$(ARCTARG)" == "I386"
    \
!else if "$(ARCTARG)" == "AMD64"
    gshandler.obj gshandlerseh.obj \
!endif
    disasm.obj detours.obj

LINK = link.exe /nologo
LINKFLAGS = $(LINKIGNORE) /WX /NODEFAULTLIB /machine:$(ARCH) /debug /debugtype:cv,fixup

LINKPROJNAMES = /out:$(PROJTARG).sys /map:$(PROJTARG).map /pdb:$(PROJTARG).pdb

$(PROJTARG).sys: $(PROJOBJS)
    @$(LINK) $(LINKFLAGS) $(PROJLOPTS) $(LINKPROJNAMES) $** $(HOTPATCH) $(LINKLIBPATH) $(BUILDLIBS)

# assembly files
{$(ARCTARG)\}.asm{$(OBJD)\}.obj::
    @$(AS) $(AFLAGS) /c $<

# arch-specific C files
{$(ARCTARG)\}.c{$(OBJD)\}.obj::
    @$(CC) $(CFLAGS) /c $<

# C files
.c{$(OBJD)\}.obj::
    @$(CC) $(CFLAGS) /c $<
    
# RC files
.rc{$(OBJD)\}.res::
    @$(RC) $(RFLAGS) $<

# CLEAN pseudo targets

CLEAN:
    @if exist $(OBJD)\*.res del /F /Q $(OBJD)\*.res
    @if exist $(OBJD)\*.obj del /F /Q $(OBJD)\*.obj
    @if exist $(PROJTARG).exe del /F /Q $(PROJTARG).exe
    @if exist $(PROJTARG).sys del /F /Q $(PROJTARG).sys
    @if exist $(PROJTARG).dll del /F /Q $(PROJTARG).dll
    @if exist $(PROJTARG).lib del /F /Q $(PROJTARG).lib
    @if exist $(PROJTARG).simg del /F /Q $(PROJTARG).simg
    @if exist $(PROJTARG).exp del /F /Q $(PROJTARG).exp
    @if exist $(PROJTARG).map del /F /Q $(PROJTARG).map
    @if exist $(PROJTARG).pdb del /F /Q $(PROJTARG).pdb

REBUILD: CLEAN BUILD

```

`Projects/Shark/PatchGuard.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "PatchGuard.h"


```

`Projects/Shark/PatchGuard.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _PATCHGUARD_H_
#define _PATCHGUARD_H_

#include "..\..\WRK\base\ntos\mm\mi.h"

#include "Guard.h"
#include "Reload.h"

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

#define POOL_BIG_TABLE_ENTRY_FREE 0x1

    typedef struct _POOL_BIG_PAGES {
        ptr Va;
        u32 Key;
        u32 PoolType;
        u NumberOfPages;
    } POOL_BIG_PAGES, *PPOOL_BIG_PAGES;

#ifdef _WIN64                                           
    C_ASSERT(sizeof(POOL_BIG_PAGES) == sizeof(u) * 3);
#endif // _WIN64

    typedef struct _POOL_BIG_PAGESEX {
        ptr Va;
        u32 Key;
        u32 PoolType;
        u NumberOfPages;
        u Unuse;
    } POOL_BIG_PAGESEX, *PPOOL_BIG_PAGESEX;

#ifdef _WIN64                                       
    C_ASSERT(sizeof(POOL_BIG_PAGES) == sizeof(u) * 3);
#endif // _WIN64

    enum {
        PgPoolBigPage,
        PgSystemPtes,
        PgMaximumType
    };

    enum {
        PgDeclassified,
        PgEncrypted,
        PgDoubleEncrypted
    };

    typedef struct _PGOBJECT {
        LIST_ENTRY Entry;
        WORK_QUEUE_ITEM Worker;
        b Encrypted;
        u64 Key;
        uptr Context;
        u ContextSize;
        u8 Type;
        ptr BaseAddress;
        u RegionSize;
        SAFEGUARD_BODY Body;
    }PGOBJECT, *PPGOBJECT;

    // build number > 20000
    typedef enum _MI_SYSTEM_VA_TYPE {
        MiVaUnused = 0,
        MiVaSessionSpace = 1,
        MiVaProcessSpace = 2,
        MiVaBootLoaded = 3,
        MiVaPfnDatabase = 4,
        MiVaNonPagedPool = 5,
        MiVaPagedPool = 6,
        MiVaSpecialPoolPaged = 7,
        MiVaSystemCache = 8,
        MiVaSystemPtes = 9,
        MiVaHal = 10,
        MiVaSessionGlobalSpace = 11,
        MiVaDriverImages = 12,
        MiVaSystemPtesLarge = 13,
        MiVaKernelStacks = 14,
        MiVaSecureNonPagedPool = 15,
        MiVaKernelShadowStacks = 16,
        MiVaMaximumType
    }MI_SYSTEM_VA_TYPE, *PMI_SYSTEM_VA_TYPE;

    typedef struct _PGBLOCK {
        struct _RTB * RtBlock;

#define GetRtBlock(pgb) (pgb->RtBlock)

#define PG_MAXIMUM_CONTEXT_COUNT 0x00000003UI32 // The maximum number of context that may exist
#define PG_FIRST_FIELD_OFFSET 0x00000100UI32 // offset of the first context member used by the search
#define PG_CMP_APPEND_DLL_SECTION_END 0x000000c0UI32 // CmpAppendDllSection length
#define PG_COMPARE_FIELDS_COUNT 0x00000004UI32 // number of context members compared during search
#define PG_COMPARE_BYTE_COUNT 0x00000010UI32 // number of bytes compared when searching for workers

        // EntryPoint cache size used to search the code fragment of the header 
        // (minimum length = max(2 * 8 + 7, sizeof(GUARD_BODY)))
#define PG_MAXIMUM_EP_BUFFER_COUNT ((max(2 * 8 + 7, sizeof(GUARD_BODY)) + 7) & ~7)

#define PG_FIELD_BITS \
            ((u32)((((PG_FIRST_FIELD_OFFSET + PG_COMPARE_FIELDS_COUNT * sizeof(ptr)) \
                - PG_CMP_APPEND_DLL_SECTION_END) / sizeof(ptr)) - 1))

        struct {
            u8 Count : 3;
            b BtcEnable : 1;
            b IsDebug : 1;
        };

        u32 OffsetEntryPoint;
        u32 SizeCmpAppendDllSection;
        u32 SizeINITKDBG;
        ptr INITKDBG;
        s32 BuildKey;
        s32 BranchKey[12];

        uptr OriginalCmpAppendDllSection;
        uptr CacheCmpAppendDllSection;

        uptr KiWaitNever;
        uptr KiWaitAlways;

        struct {
            union {
                PPOOL_BIG_PAGES * PoolBigPageTable;
                PPOOL_BIG_PAGESEX * PoolBigPageTableEx;
            };

            uptr PoolBigPageTableSize;

            b
            (NTAPI * MmIsNonPagedSystemAddressValid)(
                __in ptr VirtualAddress
                );
        }Pool; // pool big page

        struct {
            u NumberOfPtes;
            PMMPTE BasePte;
        }SystemPtes; // system ptes       

        struct {
            ptr WorkerContext;

            void
            (NTAPI * ExpWorkerThread)(
                __in ptr StartContext
                );

            void
            (NTAPI * PspSystemThreadStartup)(
                __in PKSTART_ROUTINE StartRoutine,
                __in ptr StartContext
                );

            void
            (NTAPI * KiStartSystemThread)(
                void
                );

            u32 OffsetSameThreadPassive;
            u32 OffsetExpWorkerThreadReturn;
            ptr ExpWorkerThreadReturn;

            struct {
                u64 BeginAddress;
                u64 EndAddress;
            } KiScbQueueScanWorker;
        }; // restart ExpWorkerThread

        ptr
        (NTAPI * MmAllocateIndependentPages)(
            __in u NumberOfBytes,
            __in u32 Node
            );

        void
        (NTAPI * MmFreeIndependentPages)(
            __in ptr VirtualAddress,
            __in u NumberOfBytes
            );

        b
        (NTAPI * MmSetPageProtection)(
            __in_bcount(NumberOfBytes) ptr VirtualAddress,
            __in u NumberOfBytes,
            __in u32 NewProtect
            );

        b
        (NTAPI * MmIsAddressValid)(
            __in ptr VirtualAddress
            );

        ptr
        (NTAPI * RtlLookupFunctionEntry)(
            __in u64 ControlPc,
            __out u64ptr ImageBase,
            __inout_opt ptr HistoryTable
            );

        PEXCEPTION_ROUTINE
        (NTAPI * RtlVirtualUnwind)(
            __in u32 HandlerType,
            __in u64 ImageBase,
            __in u64 ControlPc,
            __in ptr FunctionEntry,
            __inout PCONTEXT ContextRecord,
            __out ptr * HandlerData,
            __out u64ptr EstablisherFrame,
            __inout_opt ptr ContextPointers
            );

        void
        (NTAPI * ExQueueWorkItem)(
            __inout PWORK_QUEUE_ITEM WorkItem,
            __in WORK_QUEUE_TYPE QueueType
            );

        void
        (NTAPI * FreeWorker)(
            __in struct _PGOBJECT * Object
            );

        void
        (NTAPI * ClearCallback)(
            __in PCONTEXT Context,
            __in_opt ptr ProgramCounter,
            __in_opt ptr Parameter,
            __in_opt ptr Reserved
            );

        u
        (FASTCALL * CmpDecode)(
            __in u Value,
            __in u8 Count
            );

        u
        (FASTCALL * Ror64)(
            __in u Value,
            __in u8 Count
            );

        u
        (FASTCALL * Rol64)(
            __in u Value,
            __in u8 Count
            );

        u64
        (FASTCALL *  RorWithBtc64)(
            __in u64 Value,
            __in u64 Count
            );

        void
        (NTAPI * CaptureContext)(
            __in u32 ProgramCounter,
            __in ptr Guard,
            __in ptr Stack,
            __in_opt ptr Parameter,
            __in_opt ptr Reserved
            );

        u
        (FASTCALL * PostCache)(
            __in u Index,
            __in ptr Context
            );

        u
        (FASTCALL * PostKey)(
            __in u Index,
            __in u Original
            );

        cptr ClearMessage[3];

        LIST_ENTRY Object;
        KSPIN_LOCK Lock;

        u64 Fields[PG_COMPARE_FIELDS_COUNT];
        u8 Header[PG_MAXIMUM_EP_BUFFER_COUNT];
        u8 _Ror64[8];
        u8 _Rol64[8];
        u8 _RorWithBtc64[16];
        u8 _PostCache[16];
        u8 _PostKey[64];

#ifndef _WIN64
        u8 _CaptureContext[0x100];
#else
        u8 _CaptureContext[0x200];
#endif // !_WIN64

        u8 _ClearMessage[0x120];
        u8 _FreeWorker[0xB0];
        u8 _ClearCallback[0x380];

        u8 _OriginalCmpAppendDllSection[0xC8];
        u8 _CacheCmpAppendDllSection[0xC8];
    }PGBLOCK, *PPGBLOCK;

    void
        NTAPI
        PgClear(
            __inout PPGBLOCK Block
        );

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_PATCHGUARD_H_

```

`Projects/Shark/Reload.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "Reload.h"

#include "Ctx.h"
#include "Guard.h"
#include "Except.h"
#include "Scan.h"

void
NTAPI
InitializeGpBlock(
    __in PRTB Rtb
)
{
    PKLDR_DATA_TABLE_ENTRY DataTableEntry = NULL;
    PIMAGE_SECTION_HEADER NtSection = NULL;
    PCHAR SectionBase = NULL;
    u32 SizeToLock = 0;
    u8ptr ControlPc = NULL;
    PDUMP_HEADER DumpHeader = NULL;
    PKDDEBUGGER_DATA64 KdDebuggerDataBlock = NULL;
    PKDDEBUGGER_DATA_ADDITION64 KdDebuggerDataAdditionBlock = NULL;
    ptr RoutineAddress = NULL;
    PLIST_ENTRY ActiveProcessEntry = NULL;
    s32 Number = -1;
    u8ptr TargetPc = NULL;
    u32 FirstLength = 0;
    u32 Length = 0;
    CONTEXT Context = { 0 };
    UNICODE_STRING String = { 0 };

#ifndef _WIN64
    // 6A 01                            push 1
    // 68 A0 D7 69 00                   push offset _PsLoadedModuleResource
    // E8 FB E4 E9 FF                   call _ExAcquireResourceSharedLite@8

    u8 PsLoadedModuleResource[] = "6A 01 68 ?? ?? ?? ?? E8";

    // 8B DA                            mov ebx, edx
    // F6 05 C8 E0 52 00 40             test byte ptr ds:dword_52E0C8, 40h
    // 0F 95 45 12                      setnz byte ptr [ebp + 12h]
    // 0F 85 8C 03 00 00                jnz loc_435C04
    // FF D3                            call ebx

    u8 PerfGlobalGroupMask[] =
        "8B DA F6 05 ?? ?? ?? ?? 40 0F 95 45 ?? 0F 85 ?? ?? ?? ?? FF D3";
#else
    // 48 89 A3 D8 01 00 00             mov [rbx + 1D8h], rsp
    // 8B F8                            mov edi, eax
    // C1 EF 07                         shr edi, 7
    // 83 E7 20                         and edi, 20h
    // 25 FF 0F 00 00                   and eax, 0FFFh
    // 4C 8D 15 C7 20 23 00             lea r10, KeServiceDescriptorTable
    // 4C 8D 1D 00 21 23 00             lea r11, KeServiceDescriptorTableShadow

    u8 KiSystemCall64[] =
        "48 89 A3 ?? ?? ?? ?? 8B F8 C1 EF 07 83 E7 20 25 FF 0F 00 00 4C 8D 15 ?? ?? ?? ?? 4C 8D 1D";

    // F7 05 3E C0 2D 00 40 00 00 00    test dword ptr cs:PerfGlobalGroupMask + 8, 40h
    // 0F 85 56 02 00 00                jnz loc_14007A2A6
    // 41 FF D2                         call r10

    u8 PerfGlobalGroupMask[] =
        "F7 05 ?? ?? ?? ?? 40 00 00 00 0F 85";

    // 48 8D 0D FD DA 19 00             rcx, PsLoadedModuleResource
    // E8 B8 B8 E3 FF call              ExReleaseResourceLite

    u8 PsLoadedModuleResource[] = "48 8D 0D ?? ?? ?? ?? E8";
#endif // !_WIN64

    Rtb->Linkage[0] = 0x33;
    Rtb->Linkage[1] = 0xc0;
    Rtb->Linkage[2] = 0xc3;

    PsGetVersion(NULL, NULL, &Rtb->BuildNumber, NULL);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > BuildNumber\n",
            Rtb->BuildNumber);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"PsInitialSystemProcess");

    RoutineAddress = MmGetSystemRoutineAddress(&String);

    RtlCopyMemory(
        &Rtb->PsInitialSystemProcess,
        RoutineAddress,
        sizeof(ptr));

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > PsInitialSystemProcess\n",
            Rtb->PsInitialSystemProcess);
#endif // DEBUG                              
    }

    RtlInitUnicodeString(&String, L"KeNumberProcessors");

    RoutineAddress = MmGetSystemRoutineAddress(&String);

    RtlCopyMemory(
        &Rtb->NumberProcessors,
        RoutineAddress,
        sizeof(u8));

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > NumberProcessors\n",
            Rtb->NumberProcessors);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"KeEnterCriticalRegion");

    Rtb->KeEnterCriticalRegion = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > KeEnterCriticalRegion\n",
            Rtb->KeEnterCriticalRegion);
#endif // DEBUG                              
    }

    RtlInitUnicodeString(&String, L"KeLeaveCriticalRegion");

    Rtb->KeLeaveCriticalRegion = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > KeLeaveCriticalRegion\n",
            Rtb->KeLeaveCriticalRegion);
#endif // DEBUG              
    }

    RtlInitUnicodeString(&String, L"ExAcquireSpinLockShared");

    Rtb->ExAcquireSpinLockShared = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > ExAcquireSpinLockShared\n",
            Rtb->ExAcquireSpinLockShared);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"ExReleaseSpinLockShared");

    Rtb->ExReleaseSpinLockShared = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > ExReleaseSpinLockShared\n",
            Rtb->ExReleaseSpinLockShared);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"DbgPrint");

    Rtb->DbgPrint = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > DbgPrint\n",
            Rtb->DbgPrint);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"KeWaitForSingleObject");

    Rtb->KeWaitForSingleObject = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > KeWaitForSingleObject\n",
            Rtb->KeWaitForSingleObject);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"RtlCompareMemory");

    Rtb->RtlCompareMemory = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > RtlCompareMemory\n",
            Rtb->RtlCompareMemory);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"RtlRestoreContext");

    Rtb->RtlRestoreContext = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > RtlRestoreContext\n",
            Rtb->RtlRestoreContext);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"ExQueueWorkItem");

    Rtb->ExQueueWorkItem = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > ExQueueWorkItem\n",
            Rtb->ExQueueWorkItem);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"ExFreePoolWithTag");

    Rtb->ExFreePoolWithTag = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > ExFreePoolWithTag\n",
            Rtb->ExFreePoolWithTag);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"KeBugCheckEx");

    Rtb->KeBugCheckEx = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > KeBugCheckEx\n",
            Rtb->KeBugCheckEx);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"ExInterlockedRemoveHeadList");

    Rtb->ExInterlockedRemoveHeadList = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > ExInterlockedRemoveHeadList\n",
            Rtb->ExInterlockedRemoveHeadList);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"ExAcquireRundownProtection");

    Rtb->ExAcquireRundownProtection = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > ExAcquireRundownProtection\n",
            Rtb->ExAcquireRundownProtection);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"ExReleaseRundownProtection");

    Rtb->ExReleaseRundownProtection = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > ExReleaseRundownProtection\n",
            Rtb->ExReleaseRundownProtection);
#endif // DEBUG
    }

    RtlInitUnicodeString(&String, L"ExWaitForRundownProtectionRelease");

    Rtb->ExWaitForRundownProtectionRelease = MmGetSystemRoutineAddress(&String);

    if (CmdReload !=
        (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > ExWaitForRundownProtectionRelease\n",
            Rtb->ExWaitForRundownProtectionRelease);
#endif // DEBUG
    }

    Context.ContextFlags = CONTEXT_FULL;

    RtlCaptureContext(&Context);

    DumpHeader = __malloc(DUMP_BLOCK_SIZE);

    if (NULL != DumpHeader) {
        KeCapturePersistentThreadState(
            &Context,
            NULL,
            0,
            0,
            0,
            0,
            0,
            DumpHeader);

        KdDebuggerDataBlock = (u8ptr)DumpHeader + KDDEBUGGER_DATA_OFFSET;

        RtlCopyMemory(
            &Rtb->DebuggerDataBlock,
            KdDebuggerDataBlock,
            sizeof(KDDEBUGGER_DATA64));

        KdDebuggerDataAdditionBlock = (PKDDEBUGGER_DATA_ADDITION64)(KdDebuggerDataBlock + 1);

        RtlCopyMemory(
            &Rtb->DebuggerDataAdditionBlock,
            KdDebuggerDataAdditionBlock,
            sizeof(KDDEBUGGER_DATA_ADDITION64));

        Rtb->PsLoadedModuleList =
            (PLIST_ENTRY)Rtb->DebuggerDataBlock.PsLoadedModuleList;

        Rtb->KernelDataTableEntry = CONTAINING_RECORD(
            Rtb->PsLoadedModuleList->Flink,
            KLDR_DATA_TABLE_ENTRY,
            InLoadOrderLinks);

        if (CmdReload !=
            (Rtb->Operation & CmdReload)) {
#ifdef DEBUG
            /// vDbgPrint("[SHARK] < %p > Header\n", KdDebuggerDataBlock->Header);
            //vDbgPrint("[SHARK] < %p > KernBase\n", KdDebuggerDataBlock->KernBase);
            /// vDbgPrint("[SHARK] < %p > BreakpointWithStatus\n", KdDebuggerDataBlock->BreakpointWithStatus);
            /// vDbgPrint("[SHARK] < %p > SavedContext\n", KdDebuggerDataBlock->SavedContext);
            /// vDbgPrint("[SHARK] < %p > ThCallbackStack\n", KdDebuggerDataBlock->ThCallbackStack);
            /// vDbgPrint("[SHARK] < %p > NextCallback\n", KdDebuggerDataBlock->NextCallback);
            /// vDbgPrint("[SHARK] < %p > FramePointer\n", KdDebuggerDataBlock->FramePointer);
            // vDbgPrint("[SHARK] < %p > PaeEnabled\n", KdDebuggerDataBlock->PaeEnabled);
            /// vDbgPrint("[SHARK] < %p > KiCallUserMode\n", KdDebuggerDataBlock->KiCallUserMode);
            /// vDbgPrint("[SHARK] < %p > KeUserCallbackDispatcher\n", KdDebuggerDataBlock->KeUserCallbackDispatcher);
            // vDbgPrint("[SHARK] < %p > PsLoadedModuleList\n", KdDebuggerDataBlock->PsLoadedModuleList);
            // vDbgPrint("[SHARK] < %p > PsActiveProcessHead\n", KdDebuggerDataBlock->PsActiveProcessHead);
            // vDbgPrint("[SHARK] < %p > PspCidTable\n", KdDebuggerDataBlock->PspCidTable);
            /// vDbgPrint("[SHARK] < %p > ExpSystemResourcesList\n", KdDebuggerDataBlock->ExpSystemResourcesList);
            /// vDbgPrint("[SHARK] < %p > ExpPagedPoolDescriptor\n", KdDebuggerDataBlock->ExpPagedPoolDescriptor);
            /// vDbgPrint("[SHARK] < %p > ExpNumberOfPagedPools\n", KdDebuggerDataBlock->ExpNumberOfPagedPools);
            /// vDbgPrint("[SHARK] < %p > KeTimeIncrement\n", KdDebuggerDataBlock->KeTimeIncrement);
            /// vDbgPrint("[SHARK] < %p > KeBugCheckCallbackListHead\n", KdDebuggerDataBlock->KeBugCheckCallbackListHead);
            /// vDbgPrint("[SHARK] < %p > KiBugcheckData\n", KdDebuggerDataBlock->KiBugcheckData);
            /// vDbgPrint("[SHARK] < %p > IopErrorLogListHead\n", KdDebuggerDataBlock->IopErrorLogListHead);
            /// vDbgPrint("[SHARK] < %p > ObpRootDirectoryObject\n", KdDebuggerDataBlock->ObpRootDirectoryObject);
            /// vDbgPrint("[SHARK] < %p > ObpTypeObjectType\n", KdDebuggerDataBlock->ObpTypeObjectType);
            /// vDbgPrint("[SHARK] < %p > MmSystemCacheStart\n", KdDebuggerDataBlock->MmSystemCacheStart);
            /// vDbgPrint("[SHARK] < %p > MmSystemCacheEnd\n", KdDebuggerDataBlock->MmSystemCacheEnd);
            /// vDbgPrint("[SHARK] < %p > MmSystemCacheWs\n", KdDebuggerDataBlock->MmSystemCacheWs);
            // vDbgPrint("[SHARK] < %p > MmPfnDatabase\n", KdDebuggerDataBlock->MmPfnDatabase);
            /// vDbgPrint("[SHARK] < %p > MmSystemPtesStart\n", KdDebuggerDataBlock->MmSystemPtesStart);
            /// vDbgPrint("[SHARK] < %p > MmSystemPtesEnd\n", KdDebuggerDataBlock->MmSystemPtesEnd);
            /// vDbgPrint("[SHARK] < %p > MmSubsectionBase\n", KdDebuggerDataBlock->MmSubsectionBase);
            /// vDbgPrint("[SHARK] < %p > MmNumberOfPagingFiles\n", KdDebuggerDataBlock->MmNumberOfPagingFiles);
            /// vDbgPrint("[SHARK] < %p > MmLowestPhysicalPage\n", KdDebuggerDataBlock->MmLowestPhysicalPage);
            /// vDbgPrint("[SHARK] < %p > MmHighestPhysicalPage\n", KdDebuggerDataBlock->MmHighestPhysicalPage);
            /// vDbgPrint("[SHARK] < %p > MmNumberOfPhysicalPages\n", KdDebuggerDataBlock->MmNumberOfPhysicalPages);
            /// vDbgPrint("[SHARK] < %p > MmMaximumNonPagedPoolInBytes\n", KdDebuggerDataBlock->MmMaximumNonPagedPoolInBytes);
            /// vDbgPrint("[SHARK] < %p > MmNonPagedSystemStart\n", KdDebuggerDataBlock->MmNonPagedSystemStart);
            /// vDbgPrint("[SHARK] < %p > MmNonPagedPoolStart\n", KdDebuggerDataBlock->MmNonPagedPoolStart);
            /// vDbgPrint("[SHARK] < %p > MmNonPagedPoolEnd\n", KdDebuggerDataBlock->MmNonPagedPoolEnd);
            /// vDbgPrint("[SHARK] < %p > MmPagedPoolStart\n", KdDebuggerDataBlock->MmPagedPoolStart);
            /// vDbgPrint("[SHARK] < %p > MmPagedPoolEnd\n", KdDebuggerDataBlock->MmPagedPoolEnd);
            /// vDbgPrint("[SHARK] < %p > MmPagedPoolInformation\n", KdDebuggerDataBlock->MmPagedPoolInformation);
            /// vDbgPrint("[SHARK] < %p > MmPageSize\n", KdDebuggerDataBlock->MmPageSize);
            /// vDbgPrint("[SHARK] < %p > MmSizeOfPagedPoolInBytes\n", KdDebuggerDataBlock->MmSizeOfPagedPoolInBytes);
            /// vDbgPrint("[SHARK] < %p > MmTotalCommitLimit\n", KdDebuggerDataBlock->MmTotalCommitLimit);
            /// vDbgPrint("[SHARK] < %p > MmTotalCommittedPages\n", KdDebuggerDataBlock->MmTotalCommittedPages);
            /// vDbgPrint("[SHARK] < %p > MmSharedCommit\n", KdDebuggerDataBlock->MmSharedCommit);
            /// vDbgPrint("[SHARK] < %p > MmDriverCommit\n", KdDebuggerDataBlock->MmDriverCommit);
            /// vDbgPrint("[SHARK] < %p > MmProcessCommit\n", KdDebuggerDataBlock->MmProcessCommit);
            /// vDbgPrint("[SHARK] < %p > MmPagedPoolCommit\n", KdDebuggerDataBlock->MmPagedPoolCommit);
            /// vDbgPrint("[SHARK] < %p > MmExtendedCommit\n", KdDebuggerDataBlock->MmExtendedCommit);
            /// vDbgPrint("[SHARK] < %p > MmZeroedPageListHead\n", KdDebuggerDataBlock->MmZeroedPageListHead);
            /// vDbgPrint("[SHARK] < %p > MmFreePageListHead\n", KdDebuggerDataBlock->MmFreePageListHead);
            /// vDbgPrint("[SHARK] < %p > MmStandbyPageListHead\n", KdDebuggerDataBlock->MmStandbyPageListHead);
            /// vDbgPrint("[SHARK] < %p > MmModifiedPageListHead\n", KdDebuggerDataBlock->MmModifiedPageListHead);
            /// vDbgPrint("[SHARK] < %p > MmModifiedNoWritePageListHead\n", KdDebuggerDataBlock->MmModifiedNoWritePageListHead);
            /// vDbgPrint("[SHARK] < %p > MmAvailablePages\n", KdDebuggerDataBlock->MmAvailablePages);
            /// vDbgPrint("[SHARK] < %p > MmResidentAvailablePages\n", KdDebuggerDataBlock->MmResidentAvailablePages);
            /// vDbgPrint("[SHARK] < %p > PoolTrackTable\n", KdDebuggerDataBlock->PoolTrackTable);
            /// vDbgPrint("[SHARK] < %p > NonPagedPoolDescriptor\n", KdDebuggerDataBlock->NonPagedPoolDescriptor);
            /// vDbgPrint("[SHARK] < %p > MmHighestUserAddress\n", KdDebuggerDataBlock->MmHighestUserAddress);
            /// vDbgPrint("[SHARK] < %p > MmSystemRangeStart\n", KdDebuggerDataBlock->MmSystemRangeStart);
            /// vDbgPrint("[SHARK] < %p > MmUserProbeAddress\n", KdDebuggerDataBlock->MmUserProbeAddress);
            /// vDbgPrint("[SHARK] < %p > KdPrintCircularBuffer\n", KdDebuggerDataBlock->KdPrintCircularBuffer);
            /// vDbgPrint("[SHARK] < %p > KdPrintCircularBufferEnd\n", KdDebuggerDataBlock->KdPrintCircularBufferEnd);
            /// vDbgPrint("[SHARK] < %p > KdPrintWritePointer\n", KdDebuggerDataBlock->KdPrintWritePointer);
            /// vDbgPrint("[SHARK] < %p > KdPrintRolloverCount\n", KdDebuggerDataBlock->KdPrintRolloverCount);
            /// vDbgPrint("[SHARK] < %p > MmLoadedUserImageList\n", KdDebuggerDataBlock->MmLoadedUserImageList);
            /// vDbgPrint("[SHARK] < %p > NtBuildLab\n", KdDebuggerDataBlock->NtBuildLab);
            /// vDbgPrint("[SHARK] < %p > KiNormalSystemCall\n", KdDebuggerDataBlock->KiNormalSystemCall);
            /// vDbgPrint("[SHARK] < %p > KiProcessorBlock\n", KdDebuggerDataBlock->KiProcessorBlock);
            /// vDbgPrint("[SHARK] < %p > MmUnloadedDrivers\n", KdDebuggerDataBlock->MmUnloadedDrivers);
            /// vDbgPrint("[SHARK] < %p > MmLastUnloadedDriver\n", KdDebuggerDataBlock->MmLastUnloadedDriver);
            /// vDbgPrint("[SHARK] < %p > MmTriageActionTaken\n", KdDebuggerDataBlock->MmTriageActionTaken);
            /// vDbgPrint("[SHARK] < %p > MmSpecialPoolTag\n", KdDebuggerDataBlock->MmSpecialPoolTag);
            /// vDbgPrint("[SHARK] < %p > KernelVerifier\n", KdDebuggerDataBlock->KernelVerifier);
            /// vDbgPrint("[SHARK] < %p > MmVerifierData\n", KdDebuggerDataBlock->MmVerifierData);
            /// vDbgPrint("[SHARK] < %p > MmAllocatedNonPagedPool\n", KdDebuggerDataBlock->MmAllocatedNonPagedPool);
            /// vDbgPrint("[SHARK] < %p > MmPeakCommitment\n", KdDebuggerDataBlock->MmPeakCommitment);
            /// vDbgPrint("[SHARK] < %p > MmTotalCommitLimitMaximum\n", KdDebuggerDataBlock->MmTotalCommitLimitMaximum);
            /// vDbgPrint("[SHARK] < %p > CmNtCSDVersion\n", KdDebuggerDataBlock->CmNtCSDVersion);
            /// vDbgPrint("[SHARK] < %p > MmPhysicalMemoryBlock\n", KdDebuggerDataBlock->MmPhysicalMemoryBlock);
            /// vDbgPrint("[SHARK] < %p > MmSessionBase\n", KdDebuggerDataBlock->MmSessionBase);
            /// vDbgPrint("[SHARK] < %p > MmSessionSize\n", KdDebuggerDataBlock->MmSessionSize);
            /// vDbgPrint("[SHARK] < %p > MmSystemParentTablePage\n", KdDebuggerDataBlock->MmSystemParentTablePage);
            /// vDbgPrint("[SHARK] < %p > MmVirtualTranslationBase\n", KdDebuggerDataBlock->MmVirtualTranslationBase);
            // vDbgPrint("[SHARK] < %p > OffsetKThreadNextProcessor\n", KdDebuggerDataBlock->OffsetKThreadNextProcessor);
            // vDbgPrint("[SHARK] < %p > OffsetKThreadTeb\n", KdDebuggerDataBlock->OffsetKThreadTeb);
            // vDbgPrint("[SHARK] < %p > OffsetKThreadKernelStack\n", KdDebuggerDataBlock->OffsetKThreadKernelStack);
            // vDbgPrint("[SHARK] < %p > OffsetKThreadInitialStack\n", KdDebuggerDataBlock->OffsetKThreadInitialStack);
            // vDbgPrint("[SHARK] < %p > OffsetKThreadApcProcess\n", KdDebuggerDataBlock->OffsetKThreadApcProcess);
            // vDbgPrint("[SHARK] < %p > OffsetKThreadState\n", KdDebuggerDataBlock->OffsetKThreadState);
            // vDbgPrint("[SHARK] < %p > OffsetKThreadBStore\n", KdDebuggerDataBlock->OffsetKThreadBStore);
            // vDbgPrint("[SHARK] < %p > OffsetKThreadBStoreLimit\n", KdDebuggerDataBlock->OffsetKThreadBStoreLimit);
            // vDbgPrint("[SHARK] < %p > SizeEProcess\n", KdDebuggerDataBlock->SizeEProcess);
            // vDbgPrint("[SHARK] < %p > OffsetEprocessPeb\n", KdDebuggerDataBlock->OffsetEprocessPeb);
            // vDbgPrint("[SHARK] < %p > OffsetEprocessParentCID\n", KdDebuggerDataBlock->OffsetEprocessParentCID);
            // vDbgPrint("[SHARK] < %p > OffsetEprocessDirectoryTableBase\n", KdDebuggerDataBlock->OffsetEprocessDirectoryTableBase);
            // vDbgPrint("[SHARK] < %p > SizePrcb\n", KdDebuggerDataBlock->SizePrcb);
            // vDbgPrint("[SHARK] < %p > OffsetPrcbDpcRoutine\n", KdDebuggerDataBlock->OffsetPrcbDpcRoutine);
            // vDbgPrint("[SHARK] < %p > OffsetPrcbCurrentThread\n", KdDebuggerDataBlock->OffsetPrcbCurrentThread);
            // vDbgPrint("[SHARK] < %p > OffsetPrcbMhz\n", KdDebuggerDataBlock->OffsetPrcbMhz);
            // vDbgPrint("[SHARK] < %p > OffsetPrcbCpuType\n", KdDebuggerDataBlock->OffsetPrcbCpuType);
            // vDbgPrint("[SHARK] < %p > OffsetPrcbVendorString\n", KdDebuggerDataBlock->OffsetPrcbVendorString);
            // vDbgPrint("[SHARK] < %p > OffsetPrcbProcStateContext\n", KdDebuggerDataBlock->OffsetPrcbProcStateContext);
            // vDbgPrint("[SHARK] < %p > OffsetPrcbNumber\n", KdDebuggerDataBlock->OffsetPrcbNumber);
            // vDbgPrint("[SHARK] < %p > SizeEThread\n", KdDebuggerDataBlock->SizeEThread);
            /// vDbgPrint("[SHARK] < %p > KdPrintCircularBufferPtr\n", KdDebuggerDataBlock->KdPrintCircularBufferPtr);
            /// vDbgPrint("[SHARK] < %p > KdPrintBufferSize\n", KdDebuggerDataBlock->KdPrintBufferSize);
            /// vDbgPrint("[SHARK] < %p > KeLoaderBlock\n", KdDebuggerDataBlock->KeLoaderBlock);
            // vDbgPrint("[SHARK] < %p > SizePcr\n", KdDebuggerDataBlock->SizePcr);
            // vDbgPrint("[SHARK] < %p > OffsetPcrSelfPcr\n", KdDebuggerDataBlock->OffsetPcrSelfPcr);
            // vDbgPrint("[SHARK] < %p > OffsetPcrCurrentPrcb\n", KdDebuggerDataBlock->OffsetPcrCurrentPrcb);
            // vDbgPrint("[SHARK] < %p > OffsetPcrContainedPrcb\n", KdDebuggerDataBlock->OffsetPcrContainedPrcb);
            // vDbgPrint("[SHARK] < %p > OffsetPcrInitialBStore\n", KdDebuggerDataBlock->OffsetPcrInitialBStore);
            // vDbgPrint("[SHARK] < %p > OffsetPcrBStoreLimit\n", KdDebuggerDataBlock->OffsetPcrBStoreLimit);
            // vDbgPrint("[SHARK] < %p > OffsetPcrInitialStack\n", KdDebuggerDataBlock->OffsetPcrInitialStack);
            // vDbgPrint("[SHARK] < %p > OffsetPcrStackLimit\n", KdDebuggerDataBlock->OffsetPcrStackLimit);
            // vDbgPrint("[SHARK] < %p > OffsetPrcbPcrPage\n", KdDebuggerDataBlock->OffsetPrcbPcrPage);
            // vDbgPrint("[SHARK] < %p > OffsetPrcbProcStateSpecialReg\n", KdDebuggerDataBlock->OffsetPrcbProcStateSpecialReg);
            // vDbgPrint("[SHARK] < %p > GdtR0Code\n", KdDebuggerDataBlock->GdtR0Code);
            // vDbgPrint("[SHARK] < %p > GdtR0Data\n", KdDebuggerDataBlock->GdtR0Data);
            // vDbgPrint("[SHARK] < %p > GdtR0Pcr\n", KdDebuggerDataBlock->GdtR0Pcr);
            // vDbgPrint("[SHARK] < %p > GdtR3Code\n", KdDebuggerDataBlock->GdtR3Code);
            // vDbgPrint("[SHARK] < %p > GdtR3Data\n", KdDebuggerDataBlock->GdtR3Data);
            // vDbgPrint("[SHARK] < %p > GdtR3Teb\n", KdDebuggerDataBlock->GdtR3Teb);
            // vDbgPrint("[SHARK] < %p > GdtLdt\n", KdDebuggerDataBlock->GdtLdt);
            // vDbgPrint("[SHARK] < %p > GdtTss\n", KdDebuggerDataBlock->GdtTss);
            // vDbgPrint("[SHARK] < %p > Gdt64R3CmCode\n", KdDebuggerDataBlock->Gdt64R3CmCode);
            // vDbgPrint("[SHARK] < %p > Gdt64R3CmTeb\n", KdDebuggerDataBlock->Gdt64R3CmTeb);
            /// vDbgPrint("[SHARK] < %p > IopNumTriageDumpDataBlocks\n", KdDebuggerDataBlock->IopNumTriageDumpDataBlocks);
            /// vDbgPrint("[SHARK] < %p > IopTriageDumpDataBlocks\n", KdDebuggerDataBlock->IopTriageDumpDataBlocks);

            if (Rtb->BuildNumber >= 10586) {
                // vDbgPrint("[SHARK] < %p > PteBase\n", KdDebuggerDataAdditionBlock->PteBase);
            }
#endif // DEBUG
        }

        __free(DumpHeader);
    }

#ifndef _WIN64
    Rtb->OffsetKProcessThreadListHead = 0x2c;

    if (Rtb->BuildNumber < 9200) {
        Rtb->OffsetKThreadThreadListEntry = 0x1e0;
    }
    else {
        Rtb->OffsetKThreadThreadListEntry = 0x1d4;
    }
#else
    Rtb->OffsetKProcessThreadListHead = 0x30;
    Rtb->OffsetKThreadThreadListEntry = 0x2f8;
#endif // !_WIN64

#ifndef _WIN64
    RtlInitUnicodeString(&String, L"KeCapturePersistentThreadState");

    ControlPc = MmGetSystemRoutineAddress(&String);

    ControlPc = ScanBytes(
        ControlPc,
        ControlPc + PAGE_SIZE,
        PsLoadedModuleResource);

    if (NULL != ControlPc) {
        Rtb->PsLoadedModuleResource = *(PERESOURCE *)(ControlPc + 3);
    }

    RtlInitUnicodeString(&String, L"KeServiceDescriptorTable");

    Rtb->KeServiceDescriptorTable = MmGetSystemRoutineAddress(&String);

    NtSection = LdrFindSection(
        (ptr)Rtb->DebuggerDataBlock.KernBase,
        ".text");

    if (NULL != NtSection) {
        SectionBase =
            (u8ptr)Rtb->DebuggerDataBlock.KernBase + NtSection->VirtualAddress;

        SizeToLock = max(
            NtSection->SizeOfRawData,
            NtSection->Misc.VirtualSize);

        ControlPc = ScanBytes(
            SectionBase,
            (u8ptr)SectionBase + SizeToLock,
            PerfGlobalGroupMask);

        if (NULL != ControlPc) {
            Rtb->PerfInfoLogSysCallEntry = ControlPc + 0xd;

            RtlCopyMemory(
                Rtb->KiSystemServiceCopyEnd,
                Rtb->PerfInfoLogSysCallEntry,
                sizeof(Rtb->KiSystemServiceCopyEnd));

            Rtb->PerfGlobalGroupMask = UlongToPtr(*(u32 *)(ControlPc + 4) - 8);
        }
    }
#else
    RtlInitUnicodeString(&String, L"KeCapturePersistentThreadState");

    ControlPc = MmGetSystemRoutineAddress(&String);

    ControlPc = ScanBytes(
        ControlPc,
        ControlPc + PAGE_SIZE,
        PsLoadedModuleResource);

    if (NULL != ControlPc) {
        Rtb->PsLoadedModuleResource = (PERESOURCE)__rva_to_va(ControlPc + 3);
    }

    NtSection = LdrFindSection(
        (ptr)Rtb->DebuggerDataBlock.KernBase,
        ".text");

    if (NULL != NtSection) {
        SectionBase =
            (u8ptr)Rtb->DebuggerDataBlock.KernBase + NtSection->VirtualAddress;

        SizeToLock = max(
            NtSection->SizeOfRawData,
            NtSection->Misc.VirtualSize);

        ControlPc = ScanBytes(
            SectionBase,
            (u8ptr)SectionBase + SizeToLock,
            KiSystemCall64);

        if (NULL != ControlPc) {
            Rtb->KeServiceDescriptorTable = __rva_to_va(ControlPc + 23);
            Rtb->KeServiceDescriptorTableShadow = __rva_to_va(ControlPc + 30);

            ControlPc = ScanBytes(
                ControlPc,
                (u8ptr)SectionBase + SizeToLock,
                PerfGlobalGroupMask);

            if (NULL != ControlPc) {
                Rtb->PerfInfoLogSysCallEntry = ControlPc + 0xa;

                RtlCopyMemory(
                    Rtb->KiSystemServiceCopyEnd,
                    Rtb->PerfInfoLogSysCallEntry,
                    sizeof(Rtb->KiSystemServiceCopyEnd));

                Rtb->PerfGlobalGroupMask = __rva_to_va_ex(ControlPc + 2, 0 - sizeof(s32));
            }
        }
    }
#endif // !_WIN64

    RtlInitUnicodeString(&String, L"PsGetThreadProcessId");

    ControlPc = MmGetSystemRoutineAddress(&String);

    if (NULL != ControlPc) {
#ifndef _WIN64
        Rtb->OffsetKThreadProcessId = *(u32*)(ControlPc + 10);
#else
        Rtb->OffsetKThreadProcessId = *(u32*)(ControlPc + 3);
#endif // !_WIN64
    }

    InitializeListHead(&Rtb->LoadedModuleList);

    if (FALSE == IsListEmpty(
        (PLIST_ENTRY)Rtb->DebuggerDataBlock.PsActiveProcessHead)) {
        ActiveProcessEntry =
            ((PLIST_ENTRY)Rtb->DebuggerDataBlock.PsActiveProcessHead)->Flink;

        while ((u)ActiveProcessEntry !=
            (u)Rtb->DebuggerDataBlock.PsActiveProcessHead) {
            if ((u)PsGetCurrentThreadProcessId() ==
                __rduptr((u)ActiveProcessEntry - sizeof(u))) {

                Rtb->OffsetEProcessActiveProcessLinks =
                    (u)ActiveProcessEntry - (u)PsGetCurrentThreadProcess();

                break;
            }

            ActiveProcessEntry = ActiveProcessEntry->Flink;
        }
    }

    RtlInitUnicodeString(&String, L"ZwClose");

    ControlPc = MmGetSystemRoutineAddress(&String);

    FirstLength = DetourGetInstructionLength(ControlPc);

    TargetPc = ControlPc + FirstLength;

    while (TRUE) {
        Length = DetourGetInstructionLength(TargetPc);

        if (FirstLength == Length) {
#ifndef _WIN64
            if (0 == _cmpbyte(TargetPc[0], ControlPc[0]) &&
                1 == *(u32ptr)&TargetPc[1] - *(u32ptr)&ControlPc[1]) {
                Rtb->NameInterval = TargetPc - ControlPc;

                break;
            }
#else
            if (FirstLength == RtlCompareMemory(
                TargetPc,
                ControlPc,
                FirstLength)) {
                Rtb->NameInterval = TargetPc - ControlPc;

                break;
            }
#endif // !_WIN64
        }

        TargetPc += Length;
    }
}

u32
NTAPI
LdrGetPlatform(
    __in ptr ImageBase
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    u32 Platform = 0;

    NtHeaders = RtlImageNtHeader(ImageBase);

    if (NULL != NtHeaders) {
        Platform = NtHeaders->OptionalHeader.Magic;
    }

    return Platform;
}

ptr
NTAPI
LdrGetEntryPoint(
    __in ptr ImageBase
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    u32 Offset = 0;
    ptr EntryPoint = NULL;

    NtHeaders = RtlImageNtHeader(ImageBase);

    if (NULL != NtHeaders) {
        if (IMAGE_NT_OPTIONAL_HDR32_MAGIC == NtHeaders->OptionalHeader.Magic) {
            Offset = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.AddressOfEntryPoint;
        }

        if (IMAGE_NT_OPTIONAL_HDR64_MAGIC == NtHeaders->OptionalHeader.Magic) {
            Offset = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.AddressOfEntryPoint;
        }

        if (0 != Offset) {
            EntryPoint = (u8ptr)ImageBase + Offset;
        }
    }

    return EntryPoint;
}

u32
NTAPI
LdrGetTimeStamp(
    __in ptr ImageBase
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    u32 TimeStamp = 0;

    NtHeaders = RtlImageNtHeader(ImageBase);

    if (NULL != NtHeaders) {
        TimeStamp = NtHeaders->FileHeader.TimeDateStamp;
    }

    return TimeStamp;
}

u16
NTAPI
LdrGetSubsystem(
    __in ptr ImageBase
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    u16 Subsystem = 0;

    NtHeaders = RtlImageNtHeader(ImageBase);

    if (NULL != NtHeaders) {
        if (IMAGE_NT_OPTIONAL_HDR32_MAGIC == NtHeaders->OptionalHeader.Magic) {
            Subsystem = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.Subsystem;
        }

        if (IMAGE_NT_OPTIONAL_HDR64_MAGIC == NtHeaders->OptionalHeader.Magic) {
            Subsystem = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.Subsystem;
        }
    }

    return Subsystem;
}

u32
NTAPI
LdrGetSize(
    __in ptr ImageBase
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    u32 SizeOfImage = 0;

    NtHeaders = RtlImageNtHeader(ImageBase);

    if (NULL != NtHeaders) {
        if (IMAGE_NT_OPTIONAL_HDR32_MAGIC == NtHeaders->OptionalHeader.Magic) {
            SizeOfImage = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.SizeOfImage;
        }

        if (IMAGE_NT_OPTIONAL_HDR64_MAGIC == NtHeaders->OptionalHeader.Magic) {
            SizeOfImage = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.SizeOfImage;
        }
    }

    return SizeOfImage;
}

PIMAGE_SECTION_HEADER
NTAPI
SectionTableFromVirtualAddress(
    __in ptr ImageBase,
    __in ptr Address
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    u32 Index = 0;
    u32 Offset = 0;
    PIMAGE_SECTION_HEADER FoundSection = NULL;
    PIMAGE_SECTION_HEADER NtSection = NULL;
    u32 SizeToLock = 0;

    NtHeaders = RtlImageNtHeader(ImageBase);

    if (NULL != NtHeaders) {
        FoundSection = IMAGE_FIRST_SECTION(NtHeaders);
        Offset = (u32)((u)Address - (u)ImageBase);

        for (Index = 0;
            Index < NtHeaders->FileHeader.NumberOfSections;
            Index++) {
            SizeToLock = max(
                FoundSection[Index].SizeOfRawData,
                FoundSection[Index].Misc.VirtualSize);

            if (Offset >= FoundSection[Index].VirtualAddress &&
                Offset < FoundSection[Index].VirtualAddress + SizeToLock) {
                NtSection = &FoundSection[Index];

                break;
            }
        }
    }

    return NtSection;
}

PIMAGE_SECTION_HEADER
NTAPI
LdrFindSection(
    __in ptr ImageBase,
    __in u8ptr SectionName
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    PIMAGE_SECTION_HEADER NtSection = NULL;
    PIMAGE_SECTION_HEADER FoundSection = NULL;
    u32 Index = 0;
    u32 Maximun = 0;
    u8 Name[IMAGE_SIZEOF_SHORT_NAME] = { 0 };

    strcpy_s(Name, IMAGE_SIZEOF_SHORT_NAME, SectionName);

    NtHeaders = RtlImageNtHeader(ImageBase);

    if (NULL != NtHeaders) {
        FoundSection = IMAGE_FIRST_SECTION(NtHeaders);

        for (Index = 0;
            Index < NtHeaders->FileHeader.NumberOfSections;
            Index++) {
            if (0 == _strnicmp(
                FoundSection[Index].Name,
                Name,
                IMAGE_SIZEOF_SHORT_NAME)) {
                NtSection = &FoundSection[Index];

                break;
            }
        }
    }

    return NtSection;
}

FORCEINLINE
u32
NTAPI
LdrGetRelocCount(
    __in u32 SizeOfBlock
)
{
    u32 Count = 0;

    Count = (SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(u16);

    return Count;
}

PIMAGE_BASE_RELOCATION
NTAPI
LdrRelocBlock(
    __in ptr VA,
    __in u32 Count,
    __in u16ptr NextOffset,
    __in s Diff
)
{
    u16ptr FixupVA = NULL;
    u16 Offset = 0;
    u16 Type = 0;

    while (Count--) {
        Offset = *NextOffset & 0xfff;
        FixupVA = (u8ptr)VA + Offset;
        Type = (*NextOffset >> 12) & 0xf;

        switch (Type) {
        case IMAGE_REL_BASED_ABSOLUTE: {
            break;
        }

        case IMAGE_REL_BASED_HIGH: {
            FixupVA[1] += (u16)((Diff >> 16) & 0xffff);
            break;
        }

        case IMAGE_REL_BASED_LOW: {
            FixupVA[0] += (u16)(Diff & 0xffff);
            break;
        }

        case IMAGE_REL_BASED_HIGHLOW: {
            *(u32ptr)FixupVA += (u32)Diff;
            break;
        }

        case IMAGE_REL_BASED_HIGHADJ: {
            FixupVA[0] += NextOffset[1] & 0xffff;
            FixupVA[1] += (u16)((Diff >> 16) & 0xffff);

            ++NextOffset;
            --Count;
            break;
        }

        case IMAGE_REL_BASED_MIPS_JMPADDR:
        case IMAGE_REL_BASED_SECTION:
        case IMAGE_REL_BASED_REL32:
            // case IMAGE_REL_BASED_VXD_RELATIVE:
            // case IMAGE_REL_BASED_MIPS_JMPADDR16: 

        case IMAGE_REL_BASED_IA64_IMM64: {
            break;
        }

        case IMAGE_REL_BASED_DIR64: {
            *(uptr)FixupVA += Diff;
            break;
        }

        default: {
            return NULL;
        }
        }

        ++NextOffset;
    }

    return (PIMAGE_BASE_RELOCATION)NextOffset;
}

void
NTAPI
LdrRelocImage(
    __in ptr ImageBase,
    __in s Diff
)
{
    PIMAGE_BASE_RELOCATION RelocDirectory = NULL;
    u32 Size = 0;
    ptr VA = 0;

    RelocDirectory = RtlImageDirectoryEntryToData(
        ImageBase,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_BASERELOC,
        &Size);

    if (0 != Size) {
        if (0 != Diff) {
            while (0 != Size) {
                VA = (u8ptr)ImageBase + RelocDirectory->VirtualAddress;
                Size -= RelocDirectory->SizeOfBlock;

                RelocDirectory = LdrRelocBlock(
                    VA,
                    LdrGetRelocCount(RelocDirectory->SizeOfBlock),
                    (u16ptr)(RelocDirectory + 1),
                    Diff);
            }
        }
    }
}

status
NTAPI
FindEntryForImage(
    __in PUNICODE_STRING ImageFileName,
    __out PKLDR_DATA_TABLE_ENTRY * DataTableEntry
)
{
    status Status = STATUS_NO_MORE_ENTRIES;
    PKLDR_DATA_TABLE_ENTRY FoundDataTableEntry = NULL;

    RtBlock.KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(RtBlock.PsLoadedModuleResource, TRUE);

    if (FALSE == IsListEmpty(RtBlock.PsLoadedModuleList)) {
        FoundDataTableEntry = CONTAINING_RECORD(
            RtBlock.PsLoadedModuleList->Flink,
            KLDR_DATA_TABLE_ENTRY,
            InLoadOrderLinks);

        while ((u)FoundDataTableEntry !=
            (u)RtBlock.PsLoadedModuleList) {
            if (FALSE != RtlEqualUnicodeString(
                ImageFileName,
                &FoundDataTableEntry->BaseDllName,
                TRUE)) {
                *DataTableEntry = FoundDataTableEntry;
                Status = STATUS_SUCCESS;
                break;
            }

            FoundDataTableEntry = CONTAINING_RECORD(
                FoundDataTableEntry->InLoadOrderLinks.Flink,
                KLDR_DATA_TABLE_ENTRY,
                InLoadOrderLinks);
        }
    }

    if (Status < 0) {
        if (FALSE == IsListEmpty(&RtBlock.LoadedModuleList)) {
            FoundDataTableEntry = CONTAINING_RECORD(
                RtBlock.LoadedModuleList.Flink,
                KLDR_DATA_TABLE_ENTRY,
                InLoadOrderLinks);

            while ((u)FoundDataTableEntry != (u)&RtBlock.LoadedModuleList) {
                if (FALSE != RtlEqualUnicodeString(
                    ImageFileName,
                    &FoundDataTableEntry->BaseDllName,
                    TRUE)) {
                    *DataTableEntry = FoundDataTableEntry;
                    Status = STATUS_SUCCESS;
                    break;
                }

                FoundDataTableEntry = CONTAINING_RECORD(
                    FoundDataTableEntry->InLoadOrderLinks.Flink,
                    KLDR_DATA_TABLE_ENTRY,
                    InLoadOrderLinks);
            }
        }
    }

    ExReleaseResourceLite(RtBlock.PsLoadedModuleResource);
    RtBlock.KeLeaveCriticalRegion();

    return Status;
}

status
NTAPI
FindEntryForImageAddress(
    __in ptr Address,
    __out PKLDR_DATA_TABLE_ENTRY * DataTableEntry
)
{
    status Status = STATUS_NO_MORE_ENTRIES;
    PKLDR_DATA_TABLE_ENTRY FoundDataTableEntry = NULL;

    RtBlock.KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(RtBlock.PsLoadedModuleResource, TRUE);

    if (FALSE == IsListEmpty(RtBlock.PsLoadedModuleList)) {
        FoundDataTableEntry = CONTAINING_RECORD(
            (RtBlock.PsLoadedModuleList)->Flink,
            KLDR_DATA_TABLE_ENTRY,
            InLoadOrderLinks);

        while ((u)FoundDataTableEntry !=
            (u)RtBlock.PsLoadedModuleList) {
            if ((u)Address >= (u)FoundDataTableEntry->DllBase &&
                (u)Address < (u)FoundDataTableEntry->DllBase +
                FoundDataTableEntry->SizeOfImage) {
                *DataTableEntry = FoundDataTableEntry;
                Status = STATUS_SUCCESS;
                break;
            }

            FoundDataTableEntry = CONTAINING_RECORD(
                FoundDataTableEntry->InLoadOrderLinks.Flink,
                KLDR_DATA_TABLE_ENTRY,
                InLoadOrderLinks);
        }
    }

    if (Status < 0) {
        if (FALSE == IsListEmpty(&RtBlock.LoadedModuleList)) {
            FoundDataTableEntry = CONTAINING_RECORD(
                RtBlock.LoadedModuleList.Flink,
                KLDR_DATA_TABLE_ENTRY,
                InLoadOrderLinks);

            while ((u)FoundDataTableEntry != (u)&RtBlock.LoadedModuleList) {
                if ((u)Address >= (u)FoundDataTableEntry->DllBase &&
                    (u)Address < (u)FoundDataTableEntry->DllBase +
                    FoundDataTableEntry->SizeOfImage) {
                    *DataTableEntry = FoundDataTableEntry;
                    Status = STATUS_SUCCESS;
                    break;
                }

                FoundDataTableEntry = CONTAINING_RECORD(
                    FoundDataTableEntry->InLoadOrderLinks.Flink,
                    KLDR_DATA_TABLE_ENTRY,
                    InLoadOrderLinks);
            }
        }
    }

    ExReleaseResourceLite(RtBlock.PsLoadedModuleResource);
    RtBlock.KeLeaveCriticalRegion();

    return Status;
}

ptr
NTAPI
LdrForward(
    __in cptr ForwarderData
)
{
    status Status = STATUS_SUCCESS;
    cptr Separator = NULL;
    cptr ImageName = NULL;
    cptr ProcedureName = NULL;
    u32 ProcedureNumber = 0;
    ptr ProcedureAddress = NULL;
    PKLDR_DATA_TABLE_ENTRY FoundDataTableEntry = NULL;
    PLDR_DATA_TABLE_ENTRY DataTableEntry = NULL;
    ANSI_STRING String = { 0 };
    UNICODE_STRING ImageFileName = { 0 };

    Separator = strchr(ForwarderData, '.');

    if (NULL != Separator) {
        ImageName = __malloc(Separator - ForwarderData);

        if (NULL != ImageName) {
            RtlCopyMemory(
                ImageName,
                ForwarderData,
                Separator - ForwarderData);

            String.Buffer = ImageName;
            String.Length = Separator - ForwarderData;
            String.MaximumLength = Separator - ForwarderData;

            Status = RtlAnsiStringToUnicodeString(
                &ImageFileName,
                &String,
                TRUE);

            if (TRACE(Status)) {
                RtBlock.KeEnterCriticalRegion();
                ExAcquireResourceExclusiveLite(RtBlock.PsLoadedModuleResource, TRUE);

                if (FALSE == IsListEmpty(RtBlock.PsLoadedModuleList)) {
                    FoundDataTableEntry = CONTAINING_RECORD(
                        RtBlock.PsLoadedModuleList->Flink,
                        KLDR_DATA_TABLE_ENTRY,
                        InLoadOrderLinks);

                    while ((u)FoundDataTableEntry !=
                        (u)RtBlock.PsLoadedModuleList) {
                        if (FALSE != RtlPrefixUnicodeString(
                            &ImageFileName,
                            &FoundDataTableEntry->BaseDllName,
                            TRUE)) {
                            DataTableEntry = FoundDataTableEntry;
                            Status = STATUS_SUCCESS;

                            break;
                        }

                        FoundDataTableEntry = CONTAINING_RECORD(
                            FoundDataTableEntry->InLoadOrderLinks.Flink,
                            KLDR_DATA_TABLE_ENTRY,
                            InLoadOrderLinks);
                    }
                }

                if (Status < 0) {
                    if (FALSE == IsListEmpty(&RtBlock.LoadedModuleList)) {
                        FoundDataTableEntry = CONTAINING_RECORD(
                            RtBlock.LoadedModuleList.Flink,
                            KLDR_DATA_TABLE_ENTRY,
                            InLoadOrderLinks);

                        while ((u)FoundDataTableEntry != (u)&RtBlock.LoadedModuleList) {
                            if (FALSE != RtlPrefixUnicodeString(
                                &ImageFileName,
                                &FoundDataTableEntry->BaseDllName,
                                TRUE)) {
                                DataTableEntry = FoundDataTableEntry;
                                Status = STATUS_SUCCESS;

                                break;
                            }

                            FoundDataTableEntry = CONTAINING_RECORD(
                                FoundDataTableEntry->InLoadOrderLinks.Flink,
                                KLDR_DATA_TABLE_ENTRY,
                                InLoadOrderLinks);
                        }
                    }
                }

                ExReleaseResourceLite(RtBlock.PsLoadedModuleResource);
                RtBlock.KeLeaveCriticalRegion();

                if (NT_SUCCESS(Status)) {
                    Separator += 1;
                    ProcedureName = Separator;

                    if (Separator[0] != '@') {
                        ProcedureAddress = LdrGetSymbol(
                            DataTableEntry->DllBase,
                            ProcedureName,
                            0);
                    }
                    else {
                        Separator += 1;

                        if (RtlCharToInteger(
                            Separator,
                            0,
                            &ProcedureNumber) >= 0) {
                            ProcedureAddress = LdrGetSymbol(
                                DataTableEntry->DllBase,
                                NULL,
                                ProcedureNumber);
                        }
                    }
                }

                RtlFreeUnicodeString(&ImageFileName);
            }

            __free(ImageName);
        }
    }

    return ProcedureAddress;
}

ptr
NTAPI
LdrGetSymbol(
    __in ptr ImageBase,
    __in_opt cptr ProcedureName,
    __in_opt u32 ProcedureNumber
)
{
    PIMAGE_EXPORT_DIRECTORY ExportDirectory = NULL;
    u32 Size = 0;
    u32ptr NameTable = NULL;
    u16ptr OrdinalTable = NULL;
    u32ptr AddressTable = NULL;
    cptr NameTableName = NULL;
    u16 HintIndex = 0;
    ptr ProcedureAddress = NULL;

    ExportDirectory = RtlImageDirectoryEntryToData(
        ImageBase,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_EXPORT,
        &Size);

    if (NULL != ExportDirectory) {
        NameTable = (u8ptr)ImageBase + ExportDirectory->AddressOfNames;
        OrdinalTable = (u8ptr)ImageBase + ExportDirectory->AddressOfNameOrdinals;
        AddressTable = (u8ptr)ImageBase + ExportDirectory->AddressOfFunctions;

        if (NULL != NameTable &&
            NULL != OrdinalTable &&
            NULL != AddressTable) {
            if (ProcedureNumber >= ExportDirectory->Base &&
                ProcedureNumber < MAXSHORT) {
                ProcedureAddress = (u8ptr)ImageBase +
                    AddressTable[ProcedureNumber - ExportDirectory->Base];
            }
            else {
                for (HintIndex = 0;
                    HintIndex < ExportDirectory->NumberOfNames;
                    HintIndex++) {
                    NameTableName = (u8ptr)ImageBase + NameTable[HintIndex];

                    if (0 == _stricmp(
                        ProcedureName,
                        NameTableName)) {
                        ProcedureAddress = (u8ptr)ImageBase +
                            AddressTable[OrdinalTable[HintIndex]];
                    }
                }
            }
        }

        if ((u)ProcedureAddress >= (u)ExportDirectory &&
            (u)ProcedureAddress < (u)ExportDirectory + Size) {
            ProcedureAddress = LdrForward(ProcedureAddress);
        }
    }

    return ProcedureAddress;
}

s32
NTAPI
LdrNameToNumber(
    __in cptr String
)
{
    status Status = STATUS_SUCCESS;
    ptr Handle = NULL;
    ptr Section = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    UNICODE_STRING ImageFileName = { 0 };
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    ptr ViewBase = NULL;
    u ViewSize = 0;
    u8ptr TargetPc = NULL;
    s32 Number = -1;

    RtlInitUnicodeString(
        &ImageFileName,
        L"\\SystemRoot\\System32\\ntdll.dll");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &ImageFileName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL);

    Status = ZwOpenFile(
        &Handle,
        FILE_EXECUTE,
        &ObjectAttributes,
        &IoStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_DELETE,
        0);

    if (TRACE(Status)) {
        InitializeObjectAttributes(
            &ObjectAttributes,
            NULL,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL);

        Status = ZwCreateSection(
            &Section,
            SECTION_MAP_READ | SECTION_MAP_EXECUTE,
            &ObjectAttributes,
            NULL,
            PAGE_EXECUTE,
            SEC_IMAGE,
            Handle);

        if (TRACE(Status)) {
            Status = ZwMapViewOfSection(
                Section,
                ZwCurrentProcess(),
                &ViewBase,
                0L,
                0L,
                NULL,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_EXECUTE);

            if (TRACE(Status)) {
                TargetPc = LdrGetSymbol(
                    ViewBase,
                    String,
                    0);

                if (NULL != TargetPc) {

#ifndef _WIN64
                    Number = __rds32(TargetPc + 1);
#else
                    Number = __rds32(TargetPc + 4);
#endif // !_WIN64
                }

                ZwUnmapViewOfSection(NtCurrentProcess(), ViewBase);
            }

            ZwClose(Section);
        }

        ZwClose(Handle);
    }

    return Number;
}

ptr
NTAPI
LdrNameToAddress(
    __in cptr String
)
{
    ptr RoutineAddress = NULL;
    UNICODE_STRING RoutineString = { 0 };
    s32 Number = -1;
    u8ptr ControlPc = NULL;
    u8ptr TargetPc = NULL;
    u32 FirstLength = 0;
    u32 Length = 0;

    if (0 == _cmpbyte(String[0], 'Z') &&
        0 == _cmpbyte(String[1], 'w')) {
        RtlInitUnicodeString(&RoutineString, L"ZwClose");

        ControlPc = MmGetSystemRoutineAddress(&RoutineString);

        if (NULL != ControlPc) {
            Number = LdrNameToNumber("NtClose");

            RoutineAddress = ControlPc +
                RtBlock.NameInterval * (s)(LdrNameToNumber(String) - Number);
        }
    }
    else if (0 == _cmpbyte(String[0], 'N') &&
        0 == _cmpbyte(String[1], 't')) {
        Number = LdrNameToNumber(String);

#ifndef _WIN64
        RoutineAddress = UlongToPtr(RtBlock.KeServiceDescriptorTable[0].Base[Number]);
#else
        RoutineAddress = (u8ptr)RtBlock.KeServiceDescriptorTable[0].Base +
            (((s32ptr)RtBlock.KeServiceDescriptorTable[0].Base)[Number] >> 4);
#endif // !_WIN64
    }

    return RoutineAddress;
}

ptr
NTAPI
LdrLoadImport(
    __in cptr ImageName
)
{
    status Status = STATUS_SUCCESS;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry = NULL;
    ANSI_STRING String = { 0 };
    UNICODE_STRING ImageFileName = { 0 };
    ptr ImageBase = NULL;

    RtlInitAnsiString(&String, ImageName);

    Status = RtlAnsiStringToUnicodeString(
        &ImageFileName,
        &String,
        TRUE);

    if (TRACE(Status)) {
        Status = FindEntryForImage(
            &ImageFileName,
            &DataTableEntry);

        if (NT_SUCCESS(Status)) {
            ImageBase = DataTableEntry->DllBase;
        }

        RtlFreeUnicodeString(&ImageFileName);
    }

    return ImageBase;
}

void
NTAPI
LdrSnapThunk(
    __in ptr ImageBase
)
{
    status Status = STATUS_SUCCESS;
    PIMAGE_IMPORT_DESCRIPTOR ImportDirectory = NULL;
    u32 Size = 0;
    PIMAGE_THUNK_DATA OriginalThunk = NULL;
    PIMAGE_THUNK_DATA Thunk = NULL;
    PIMAGE_IMPORT_BY_NAME ImportByName = NULL;
    cptr ImageName = NULL;
    ptr ImportBase = NULL;
    u16 Ordinal = 0;
    ptr FunctionAddress = NULL;

    ImportDirectory = RtlImageDirectoryEntryToData(
        ImageBase,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_IMPORT,
        &Size);

    if (0 != Size) {
        do {
            OriginalThunk = (u8ptr)ImageBase + ImportDirectory->OriginalFirstThunk;
            Thunk = (u8ptr)ImageBase + ImportDirectory->FirstThunk;
            ImageName = (u8ptr)ImageBase + ImportDirectory->Name;

            ImportBase = LdrLoadImport(ImageName);

            if (NULL != ImportBase) {
                do {
                    if (IMAGE_SNAP_BY_ORDINAL(OriginalThunk->u1.Ordinal)) {
                        Ordinal = (u16)IMAGE_ORDINAL(OriginalThunk->u1.Ordinal);

                        FunctionAddress = LdrGetSymbol(
                            ImportBase,
                            NULL,
                            Ordinal);

                        if (NULL != FunctionAddress) {
                            Thunk->u1.Function = (u)FunctionAddress;
                        }
                        else {
                            vDbgPrint(
                                "[SHARK] import procedure ordinal@%d not found\n",
                                Ordinal);
                        }
                    }
                    else {
                        ImportByName = (u8ptr)ImageBase + OriginalThunk->u1.AddressOfData;

                        if ((0 == _cmpbyte(ImportByName->Name[0], 'Z') &&
                            0 == _cmpbyte(ImportByName->Name[1], 'w')) ||
                            (0 == _cmpbyte(ImportByName->Name[0], 'N') &&
                                0 == _cmpbyte(ImportByName->Name[1], 't'))) {
                            FunctionAddress = LdrNameToAddress(ImportByName->Name);
                        }
                        else {
                            FunctionAddress = LdrGetSymbol(
                                ImportBase,
                                ImportByName->Name,
                                0);
                        }

                        if (NULL != FunctionAddress) {
                            Thunk->u1.Function = (u)FunctionAddress;
                        }
                        else {
                            vDbgPrint(
                                "[SHARK] import procedure %hs not found\n",
                                ImportByName->Name);
                        }
                    }

                    OriginalThunk++;
                    Thunk++;
                } while (OriginalThunk->u1.Function);
            }
            else {
                vDbgPrint(
                    "[SHARK] import %hs not found\n",
                    ImageName);
            }

            ImportDirectory++;
        } while (0 != ImportDirectory->Characteristics);
    }
}

void
NTAPI
LdrEnumerateThunk(
    __in ptr ImageBase
)
{
    PIMAGE_IMPORT_DESCRIPTOR ImportDirectory = NULL;
    u32 Size = 0;
    PIMAGE_THUNK_DATA OriginalThunk = NULL;
    PIMAGE_THUNK_DATA Thunk = NULL;
    PIMAGE_IMPORT_BY_NAME ImportByName = NULL;
    cptr ImportImageName = NULL;
    u16 Ordinal = 0;

    ImportDirectory = RtlImageDirectoryEntryToData(
        ImageBase,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_IMPORT,
        &Size);

    if (0 != Size) {
        do {
            OriginalThunk = (u8ptr)ImageBase + ImportDirectory->OriginalFirstThunk;
            Thunk = (u8ptr)ImageBase + ImportDirectory->FirstThunk;
            ImportImageName = (u8ptr)ImageBase + ImportDirectory->Name;

            do {
                if (IMAGE_SNAP_BY_ORDINAL(OriginalThunk->u1.Ordinal)) {
                    Ordinal = (u16)IMAGE_ORDINAL(OriginalThunk->u1.Ordinal);

                    vDbgPrint(
                        "[SHARK] < %p > %s @%d\n",
                        Thunk->u1.Function,
                        ImportImageName,
                        Ordinal);
                }
                else {
                    ImportByName = (u8ptr)ImageBase + OriginalThunk->u1.AddressOfData;

                    vDbgPrint(
                        "[SHARK] < %p > %s %s\n",
                        Thunk->u1.Function,
                        ImportImageName,
                        ImportByName->Name);
                }

                OriginalThunk++;
                Thunk++;
            } while (OriginalThunk->u1.Function);

            ImportDirectory++;
        } while (0 != ImportDirectory->Characteristics);
    }
}

void
NTAPI
LdrReplaceThunk(
    __in ptr ImageBase,
    __in_opt cptr ImageName,
    __in_opt cptr ProcedureName,
    __in_opt u32 ProcedureNumber,
    __in ptr ProcedureAddress
)
{
    PIMAGE_IMPORT_DESCRIPTOR ImportDirectory = NULL;
    u32 Size = 0;
    PIMAGE_THUNK_DATA OriginalThunk = NULL;
    PIMAGE_THUNK_DATA Thunk = NULL;
    PIMAGE_IMPORT_BY_NAME ImportByName = NULL;
    cptr ImportImageName = NULL;
    u16 Ordinal = 0;

    ImportDirectory = RtlImageDirectoryEntryToData(
        ImageBase,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_IMPORT,
        &Size);

    if (0 != Size) {
        do {
            OriginalThunk = (u8ptr)ImageBase + ImportDirectory->OriginalFirstThunk;
            Thunk = (u8ptr)ImageBase + ImportDirectory->FirstThunk;
            ImportImageName = (u8ptr)ImageBase + ImportDirectory->Name;

            if (NULL != ImageName) {
                if (0 != _stricmp(ImportImageName, ImageName)) {
                    ImportDirectory++;

                    continue;
                }
            }

            do {
                if (IMAGE_SNAP_BY_ORDINAL(OriginalThunk->u1.Ordinal)) {
                    Ordinal = (u16)IMAGE_ORDINAL(OriginalThunk->u1.Ordinal);

                    if (0 != ProcedureNumber &&
                        Ordinal == ProcedureNumber) {
                        MapLockedCopyInstruction(
                            &Thunk->u1.Function, &ProcedureAddress, sizeof(ptr));
                    }
                }
                else {
                    ImportByName = (u8ptr)ImageBase + OriginalThunk->u1.AddressOfData;

                    if (NULL != ProcedureName &&
                        0 == _stricmp(
                            ImportByName->Name,
                            ProcedureName)) {
                        MapLockedCopyInstruction(
                            &Thunk->u1.Function, &ProcedureAddress, sizeof(ptr));
                    }
                }

                OriginalThunk++;
                Thunk++;
            } while (OriginalThunk->u1.Function);

            ImportDirectory++;
        } while (0 != ImportDirectory->Characteristics);
    }
}

ptr
NTAPI
LdrAllocate(
    __in ptr ViewBase
)
{
    ptr ImageBase = NULL;
    u32 SizeOfEntry = 0;

    SizeOfEntry = LdrGetSize(ViewBase) + PAGE_SIZE;

    ImageBase = __malloc(SizeOfEntry);

    if (NULL != ImageBase) {
        ImageBase = (u8ptr)ImageBase + PAGE_SIZE;
    }

    return ImageBase;
}

u32
NTAPI
LdrMakeProtection(
    __in PIMAGE_SECTION_HEADER NtSection
)
{
    u8 Protection[] = {
        PAGE_NOACCESS,
        PAGE_EXECUTE,
        PAGE_READONLY,
        PAGE_EXECUTE_READ,
        PAGE_READWRITE,
        PAGE_EXECUTE_READWRITE,
        PAGE_READWRITE,
        PAGE_EXECUTE_READWRITE
    };

    return Protection[NtSection->Characteristics >> 29];
}

s
NTAPI
LdrSetImageBase(
    __in ptr ImageBase
)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    s Diff = 0;

    NtHeaders = RtlImageNtHeader(ImageBase);

    if (NULL != NtHeaders) {
        if (IMAGE_NT_OPTIONAL_HDR32_MAGIC == NtHeaders->OptionalHeader.Magic) {
            Diff = (s)ImageBase
                - (s)((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.ImageBase;

            ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.ImageBase =
                (u)ImageBase;
        }

        if (IMAGE_NT_OPTIONAL_HDR64_MAGIC == NtHeaders->OptionalHeader.Magic) {
            Diff = (s64)ImageBase
                - (s64)((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.ImageBase;

            ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.ImageBase =
                (u64)ImageBase;
        }
    }

    return Diff;
}

ptr
NTAPI
LdrMapSection(
    __in ptr ViewBase,
    __in u32 Flags
)
{
    ptr ImageBase = NULL;
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    PIMAGE_SECTION_HEADER NtSection = NULL;
    s Diff = 0;
    u Index = 0;
    u32 SizeToLock = 0;

    NtHeaders = RtlImageNtHeader(ViewBase);

    if (NULL != NtHeaders) {
        ImageBase = LdrAllocate(ViewBase);

        if (NULL != ImageBase) {
            RtlZeroMemory(
                ImageBase,
                NtHeaders->OptionalHeader.SizeOfImage);

            NtSection = IMAGE_FIRST_SECTION(NtHeaders);

            RtlCopyMemory(
                ImageBase,
                ViewBase,
                NtSection->VirtualAddress);

            for (Index = 0;
                Index < NtHeaders->FileHeader.NumberOfSections;
                Index++) {
                if (0 != NtSection[Index].VirtualAddress) {
                    SizeToLock = max(
                        NtSection[Index].SizeOfRawData,
                        NtSection[Index].Misc.VirtualSize);

                    RtlCopyMemory(
                        (u8ptr)ImageBase + NtSection[Index].VirtualAddress,
                        (u8ptr)ViewBase
                        + (LDRP_REDIRECTED == (Flags & LDRP_REDIRECTED) ?
                            NtSection[Index].VirtualAddress : NtSection[Index].PointerToRawData),
                        SizeToLock);
                }
            }

            Diff = LdrSetImageBase(ImageBase);

            if (0 != Diff) {
                LdrRelocImage(ImageBase, Diff);
            }

            LdrSnapThunk(ImageBase);
        }
    }

    return ImageBase;
}

PKLDR_DATA_TABLE_ENTRY
NTAPI
LdrLoad(
    __in ptr ViewBase,
    __in wcptr ImageName,
    __in u32 Flags
)
{
    status Status = STATUS_SUCCESS;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry = NULL;
    UNICODE_STRING ImageFileName = { 0 };
    ptr ImageBase = NULL;
    wcptr BaseName = NULL;

    BaseName = wcsrchr(ImageName, L'\\');

    if (NULL == BaseName) {
        BaseName = ImageName;
    }
    else {
        BaseName++;
    }

    RtlInitUnicodeString(&ImageFileName, BaseName);

    Status = FindEntryForImage(
        &ImageFileName,
        &DataTableEntry);

    if (NT_SUCCESS(Status)) {
        DataTableEntry->LoadCount++;
    }
    else {
        ImageBase = LdrMapSection(ViewBase, Flags);

        if (NULL != ImageBase) {
            DataTableEntry = (PKLDR_DATA_TABLE_ENTRY)
                ((u8ptr)ImageBase - PAGE_SIZE);

            RtlZeroMemory(
                DataTableEntry,
                sizeof(KLDR_DATA_TABLE_ENTRY) +
                MAXIMUM_FILENAME_LENGTH * sizeof(wc) * 2);

            DataTableEntry->DllBase = ImageBase;
            DataTableEntry->SizeOfImage = LdrGetSize(ImageBase);
            DataTableEntry->EntryPoint = LdrGetEntryPoint(ImageBase);
            DataTableEntry->Flags = Flags & ~LDRP_ENTRY_INSERTED;
            DataTableEntry->LoadCount = 0;

            DataTableEntry->FullDllName.Buffer = DataTableEntry + 1;

            DataTableEntry->FullDllName.MaximumLength =
                MAXIMUM_FILENAME_LENGTH * sizeof(wc);

            wcscpy(DataTableEntry->FullDllName.Buffer, SystemRootDirectory);
            wcscat(DataTableEntry->FullDllName.Buffer, BaseName);

            DataTableEntry->FullDllName.Length =
                wcslen(DataTableEntry->FullDllName.Buffer) * sizeof(wc);

            DataTableEntry->BaseDllName.Buffer =
                DataTableEntry->FullDllName.Buffer + MAXIMUM_FILENAME_LENGTH;

            DataTableEntry->BaseDllName.MaximumLength =
                MAXIMUM_FILENAME_LENGTH * sizeof(wc);

            wcscpy(DataTableEntry->BaseDllName.Buffer, BaseName);

            DataTableEntry->BaseDllName.Length =
                wcslen(DataTableEntry->BaseDllName.Buffer) * sizeof(wc);

            if (LDRP_ENTRY_INSERTED == (Flags & LDRP_ENTRY_INSERTED)) {
                if (CmdPgClear ==
                    (RtBlock.Operation & CmdPgClear)) {
                    CaptureImageExceptionValues(
                        DataTableEntry->DllBase,
                        &DataTableEntry->ExceptionTable,
                        &DataTableEntry->ExceptionTableSize);

#ifdef _WIN64
                    InsertInvertedFunctionTable(
                        DataTableEntry->DllBase,
                        DataTableEntry->SizeOfImage);
#endif // _WIN64
                }

                RtBlock.KeEnterCriticalRegion();
                ExAcquireResourceExclusiveLite(RtBlock.PsLoadedModuleResource, TRUE);

                InsertTailList(
                    &RtBlock.LoadedModuleList,
                    &DataTableEntry->InLoadOrderLinks);

                ExReleaseResourceLite(RtBlock.PsLoadedModuleResource);
                RtBlock.KeLeaveCriticalRegion();

                DataTableEntry->LoadCount++;
            }
        }
    }

    return DataTableEntry;
}

void
NTAPI
LdrUnload(
    __in PKLDR_DATA_TABLE_ENTRY DataTableEntry
)
{
    status Status = STATUS_SUCCESS;

    DataTableEntry->LoadCount--;

    if (0 == DataTableEntry->LoadCount) {
        RtBlock.KeEnterCriticalRegion();
        ExAcquireResourceExclusiveLite(RtBlock.PsLoadedModuleResource, TRUE);

        RemoveEntryList(&DataTableEntry->InLoadOrderLinks);

        ExReleaseResourceLite(RtBlock.PsLoadedModuleResource);
        RtBlock.KeLeaveCriticalRegion();

        if (CmdPgClear ==
            (RtBlock.Operation & CmdPgClear)) {
#ifdef _WIN64
            RemoveInvertedFunctionTable(DataTableEntry->DllBase);
#endif // _WIN64
        }

        __free(DataTableEntry);
    }
}

void
NTAPI
DumpImageWorker(
    __in ptr ImageBase,
    __in u32 SizeOfImage,
    __in PUNICODE_STRING ImageFIleName
)
{
    status Status = STATUS_SUCCESS;
    ptr FileHandle = NULL;
    UNICODE_STRING FilePath = { 0 };
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    PIMAGE_NT_HEADERS NtHeaders = NULL;
    PIMAGE_SECTION_HEADER NtSection = NULL;
    u Index = 0;
    u32 SizeToLock = 0;
    GUID Guid = { 0 };
    wc FilePathBuffer[MAXIMUM_FILENAME_LENGTH] = { 0 };
    wc FileBaseBuffer[MAXIMUM_FILENAME_LENGTH] = { 0 };
    u32 FileBaseNumberOfElements = 0;
    wc FileExtBuffer[MAXIMUM_FILENAME_LENGTH] = { 0 };
    u32 FileExtNumberOfElements = 0;
    LARGE_INTEGER ByteOffset = { 0 };
    PMMPTE PointerPde = NULL;
    PMMPTE PointerPte = NULL;

    NtHeaders = RtlImageNtHeader(ImageBase);

    if (NULL != NtHeaders) {
        Status = ExUuidCreate(&Guid);

        if (TRACE(Status)) {
            Index = ImageFIleName->Length / sizeof(wc);

            do {
                Index--;

                if (L'.' == ImageFIleName->Buffer[Index]) {
                    FileExtNumberOfElements =
                        ImageFIleName->Length - Index * sizeof(wc);

                    RtlCopyMemory(
                        FileExtBuffer,
                        &ImageFIleName->Buffer[Index],
                        FileExtNumberOfElements);

                    break;
                }
            } while (Index > 0);

            Index = ImageFIleName->Length / sizeof(wc);

            do {
                Index--;

                if (L'\\' == ImageFIleName->Buffer[Index]) {
                    FileBaseNumberOfElements =
                        ImageFIleName->Length - Index * sizeof(wc);

                    RtlCopyMemory(
                        FileBaseBuffer,
                        &ImageFIleName->Buffer[Index],
                        FileBaseNumberOfElements);

                    break;
                }
            } while (Index > 0);

            swprintf(
                FilePathBuffer,
                L"\\??\\c:");

            RtlInitUnicodeString(&FilePath, FilePathBuffer);

            RtlCopyMemory(
                (u8ptr)FilePath.Buffer + FilePath.Length,
                FileBaseBuffer,
                FileBaseNumberOfElements - FileExtNumberOfElements);

            RtlInitUnicodeString(&FilePath, FilePathBuffer);

            swprintf(
                (u8ptr)FilePath.Buffer + FilePath.Length,
                L".{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
                Guid.Data1,
                Guid.Data2,
                Guid.Data3,
                Guid.Data4[0],
                Guid.Data4[1],
                Guid.Data4[2],
                Guid.Data4[3],
                Guid.Data4[4],
                Guid.Data4[5],
                Guid.Data4[6],
                Guid.Data4[7]);

            RtlInitUnicodeString(&FilePath, FilePathBuffer);

            RtlCopyMemory(
                (u8ptr)FilePath.Buffer + FilePath.Length,
                FileExtBuffer,
                FileExtNumberOfElements);

            RtlInitUnicodeString(&FilePath, FilePathBuffer);

            for (Index = 0;
                Index < (FilePath.Length / sizeof(wc));
                Index++) {
                FilePath.Buffer[Index] = towlower(FilePath.Buffer[Index]);
            }

            InitializeObjectAttributes(
                &ObjectAttributes,
                &FilePath,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);

            Status = ZwCreateFile(
                &FileHandle,
                FILE_ALL_ACCESS,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_OVERWRITE_IF,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE,
                NULL,
                0);

            if (TRACE(Status)) {
                NtSection = IMAGE_FIRST_SECTION(NtHeaders);

                ByteOffset.QuadPart = 0;

                TRACE(ZwWriteFile(
                    FileHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    ImageBase,
                    NtSection->VirtualAddress,
                    &ByteOffset,
                    NULL));

                for (Index = 0;
                    Index < NtHeaders->FileHeader.NumberOfSections;
                    Index++) {
                    if (0 != NtSection[Index].VirtualAddress) {
                        ByteOffset.QuadPart = NtSection[Index].PointerToRawData;

                        SizeToLock = max(
                            NtSection[Index].SizeOfRawData,
                            NtSection[Index].Misc.VirtualSize);

                        PointerPte =
                            GetPteAddress((u8ptr)ImageBase +
                                NtSection[Index].VirtualAddress);

                        PointerPde =
                            GetPdeAddress((u8ptr)ImageBase +
                                NtSection[Index].VirtualAddress);

                        if (0 != PointerPde->u.Hard.Valid) {
                            if (0 != PointerPde->u.Hard.LargePage ||
                                (0 == PointerPde->u.Hard.LargePage && 0 != PointerPte->u.Hard.Valid)) {
                                TRACE(ZwWriteFile(
                                    FileHandle,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    (u8ptr)ImageBase + NtSection[Index].VirtualAddress,
                                    SizeToLock,
                                    &ByteOffset,
                                    NULL));
                            }
                        }
                    }
                }

                TRACE(ZwClose(FileHandle));

#ifdef DEBUG
                vDbgPrint(
                    "[SHARK] dumped < %p - %08x > %wZ\n",
                    ImageBase,
                    SizeOfImage,
                    &FilePath);
#endif // DEBUG
            }
        }
    }
}

status
NTAPI
DumpFileWorker(
    __in PUNICODE_STRING ImageFIleName
)
{
    status Status = STATUS_SUCCESS;
    ptr SourceFileHandle = NULL;
    ptr DestinationFileHandle = NULL;
    UNICODE_STRING FilePath = { 0 };
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    FILE_STANDARD_INFORMATION StandardInformation = { 0 };
    LARGE_INTEGER ByteOffset = { 0 };
    ptr Buffer = NULL;
    GUID Guid = { 0 };
    wc FilePathBuffer[MAXIMUM_FILENAME_LENGTH] = { 0 };
    wc FileBaseBuffer[MAXIMUM_FILENAME_LENGTH] = { 0 };
    u32 FileBaseNumberOfElements = 0;
    wc FileExtBuffer[MAXIMUM_FILENAME_LENGTH] = { 0 };
    u32 FileExtNumberOfElements = 0;
    u32 Index = 0;

    InitializeObjectAttributes(
        &ObjectAttributes,
        ImageFIleName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL);

    Status = ZwOpenFile(
        &SourceFileHandle,
        FILE_EXECUTE | FILE_READ_DATA,
        &ObjectAttributes,
        &IoStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_DELETE,
        0);

    if (TRACE(Status)) {
        Status = ZwQueryInformationFile(
            SourceFileHandle,
            &IoStatusBlock,
            &StandardInformation,
            sizeof(FILE_STANDARD_INFORMATION),
            FileStandardInformation);

        if (TRACE(Status)) {
            Buffer =
                __malloc(StandardInformation.EndOfFile.LowPart);

            if (NULL != Buffer) {
                ByteOffset.QuadPart = 0;

                Status = ZwReadFile(
                    SourceFileHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    Buffer,
                    StandardInformation.EndOfFile.LowPart,
                    &ByteOffset,
                    NULL);

                if (TRACE(Status)) {
                    Status = ExUuidCreate(&Guid);

                    if (TRACE(Status)) {
                        Index = ImageFIleName->Length / sizeof(wc);

                        do {
                            Index--;

                            if (L'.' == ImageFIleName->Buffer[Index]) {
                                FileExtNumberOfElements =
                                    ImageFIleName->Length - Index * sizeof(wc);

                                RtlCopyMemory(
                                    FileExtBuffer,
                                    &ImageFIleName->Buffer[Index],
                                    FileExtNumberOfElements);

                                break;
                            }
                        } while (Index > 0);

                        Index = ImageFIleName->Length / sizeof(wc);

                        do {
                            Index--;

                            if (L'\\' == ImageFIleName->Buffer[Index]) {
                                FileBaseNumberOfElements =
                                    ImageFIleName->Length - Index * sizeof(wc);

                                RtlCopyMemory(
                                    FileBaseBuffer,
                                    &ImageFIleName->Buffer[Index],
                                    FileBaseNumberOfElements);

                                break;
                            }
                        } while (Index > 0);

                        swprintf(
                            FilePathBuffer,
                            L"\\??\\c:");

                        RtlInitUnicodeString(&FilePath, FilePathBuffer);

                        RtlCopyMemory(
                            (u8ptr)FilePath.Buffer + FilePath.Length,
                            FileBaseBuffer,
                            FileBaseNumberOfElements - FileExtNumberOfElements);

                        RtlInitUnicodeString(&FilePath, FilePathBuffer);

                        swprintf(
                            (u8ptr)FilePath.Buffer + FilePath.Length,
                            L".{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
                            Guid.Data1,
                            Guid.Data2,
                            Guid.Data3,
                            Guid.Data4[0],
                            Guid.Data4[1],
                            Guid.Data4[2],
                            Guid.Data4[3],
                            Guid.Data4[4],
                            Guid.Data4[5],
                            Guid.Data4[6],
                            Guid.Data4[7]);

                        RtlInitUnicodeString(&FilePath, FilePathBuffer);

                        RtlCopyMemory(
                            (u8ptr)FilePath.Buffer + FilePath.Length,
                            FileExtBuffer,
                            FileExtNumberOfElements);

                        RtlInitUnicodeString(&FilePath, FilePathBuffer);

                        for (Index = 0;
                            Index < (FilePath.Length / sizeof(wc));
                            Index++) {
                            FilePath.Buffer[Index] = towlower(FilePath.Buffer[Index]);
                        }

                        InitializeObjectAttributes(
                            &ObjectAttributes,
                            &FilePath,
                            OBJ_CASE_INSENSITIVE,
                            NULL,
                            NULL);

                        Status = ZwCreateFile(
                            &DestinationFileHandle,
                            FILE_ALL_ACCESS,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            NULL,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ,
                            FILE_OVERWRITE_IF,
                            FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE,
                            NULL,
                            0);

                        if (TRACE(Status)) {
                            ByteOffset.QuadPart = 0;

                            TRACE(ZwWriteFile(
                                DestinationFileHandle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                Buffer,
                                StandardInformation.EndOfFile.LowPart,
                                &ByteOffset,
                                NULL));

                            TRACE(ZwFlushBuffersFile(DestinationFileHandle, &IoStatusBlock));
                            TRACE(ZwClose(DestinationFileHandle));

#ifdef DEBUG
                            vDbgPrint(
                                "[SHARK] dumped %wZ to %wZ\n",
                                ImageFIleName,
                                &FilePath);
#endif // DEBUG
                        }
                    }
                }

                __free(Buffer);
            }
        }

        ZwClose(SourceFileHandle);
    }

    return Status;
}

```

`Projects/Shark/Reload.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _RELOAD_H_
#define _RELOAD_H_

#include <devicedefs.h>
#include <guarddefs.h>
#include <dump.h>

#include "Space.h"

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

    typedef s32 EX_SPIN_LOCK, *PEX_SPIN_LOCK;

    typedef enum _OB_PREOP_CALLBACK_STATUS OB_PREOP_CALLBACK_STATUS;
    typedef struct _OB_PRE_OPERATION_INFORMATION *POB_PRE_OPERATION_INFORMATION;
    typedef struct _OB_POST_OPERATION_INFORMATION *POB_POST_OPERATION_INFORMATION;

    // runtime state block
    typedef struct _RTB {
        PLIST_ENTRY PsLoadedModuleList;
        PEPROCESS PsInitialSystemProcess;
        PERESOURCE PsLoadedModuleResource;
        struct _FUNCTION_TABLE * PsInvertedFunctionTable;
        KSERVICE_TABLE_DESCRIPTOR * KeServiceDescriptorTable;
        KSERVICE_TABLE_DESCRIPTOR * KeServiceDescriptorTableShadow;
        PKLDR_DATA_TABLE_ENTRY KernelDataTableEntry; // ntoskrnl.exe

        union {
            SUPDRVLDRIMAGE SupImage;

            struct {
                KLDR_DATA_TABLE_ENTRY DataTableEntry;
                wc FullDllName[MAXIMUM_FILENAME_LENGTH];
                wc BaseDllName[MAXIMUM_FILENAME_LENGTH];
            };
        }*Self;

        ptr CpuControlBlock; // hypervisor

        ptr NativeObject;

#ifdef _WIN64
        ptr Wx86NativeObject;
#endif // _WIN64

        LIST_ENTRY LoadedModuleList;

        LIST_ENTRY Object;
        KSPIN_LOCK Lock;

        s8 NumberProcessors;
        s8 Linkage[3];// { 0x33, 0xc0, 0xc3 };

        u32 BuildNumber;
        u32 Operation;
        u64 * PerfGlobalGroupMask;
        s8 KiSystemServiceCopyEnd[6];
        cptr PerfInfoLogSysCallEntry;
        ptr KeUserExceptionDispatcher;

#ifdef _WIN64
        PMMPTE PxeBase;
        PMMPTE PxeTop;

        PMMPTE PpeBase;
        PMMPTE PpeTop;
#endif // _WIN64

        PMMPTE PdeBase;
        PMMPTE PdeTop;

        PMMPTE PteBase;
        PMMPTE PteTop;

        void
        (NTAPI * KiDispatchException)(
            __in PEXCEPTION_RECORD ExceptionRecord,
            __in PKEXCEPTION_FRAME ExceptionFrame,
            __in PKTRAP_FRAME TrapFrame,
            __in KPROCESSOR_MODE PreviousMode,
            __in b FirstChance
            );

        void
        (NTAPI * KeContextFromKframes)(
            __in PKTRAP_FRAME TrapFrame,
#if defined(_X86_)
            __in_opt PKEXCEPTION_FRAME ExceptionFrame,
#else
            __in PKEXCEPTION_FRAME ExceptionFrame,
#endif
            __inout PCONTEXT ContextFrame
            );

        void
        (NTAPI * KeContextToKframes)(
            __inout PKTRAP_FRAME TrapFrame,

#if defined(_X86_)
            __inout_opt PKEXCEPTION_FRAME ExceptionFrame,
#else
            __inout PKEXCEPTION_FRAME ExceptionFrame,
#endif
            __in PCONTEXT ContextFrame,
            __in u32 ContextFlags,
            __in KPROCESSOR_MODE PreviousMode
            );

#ifndef _WIN64
        status
        (NTAPI * DbgkpSendApiMessageLpc)(
            __inout ptr ApiMsg,
            __in ptr Port,
            __in b SuspendProcess
            );

        status
        (FASTCALL * FastDbgkpSendApiMessageLpc)(
            __inout ptr ApiMsg,
            __in ptr Port,
            __in b SuspendProcess
            );
#else
        status
        (FASTCALL * DbgkpSendApiMessageLpc)(
            __inout ptr ApiMsg,
            __in ptr Port,
            __in b SuspendProcess
            );
#endif // !_WIN64

        status
        (NTAPI * ProcessOpen)(
            __in OB_OPEN_REASON OpenReason,
            __in KPROCESSOR_MODE PreviousMode,
            __in_opt PEPROCESS Process,
            __in ptr ProcessObject,
            __in ACCESS_MASK * GrantedAccess,
            __in u32 HandleCount
            );

        void
        (NTAPI * ProcessDelete)(
            __in ptr ProcessObject
            );

        status
        (NTAPI * ThreadOpen)(
            __in OB_OPEN_REASON OpenReason,
            __in KPROCESSOR_MODE PreviousMode,
            __in_opt PEPROCESS Process,
            __in ptr ThreadObject,
            __in ACCESS_MASK * GrantedAccess,
            __in u32 HandleCount
            );

        void
        (NTAPI * ThreadDelete)(
            __in ptr ThreadObject
            );

        status
        (NTAPI * FileOpen)(
            __in OB_OPEN_REASON OpenReason,
            __in KPROCESSOR_MODE PreviousMode,
            __in_opt PEPROCESS Process,
            __in ptr FileObject,
            __in ACCESS_MASK * GrantedAccess,
            __in u32 HandleCount
            );

        status
        (NTAPI * FileParse)(
            __in ptr ParseObject,
            __in ptr ObjectType,
            __in PACCESS_STATE AccessState,
            __in KPROCESSOR_MODE AccessMode,
            __in u32 Attributes,
            __inout PUNICODE_STRING CompleteName,
            __inout PUNICODE_STRING RemainingName,
            __inout_opt ptr Context,
            __in_opt PSECURITY_QUALITY_OF_SERVICE SecurityQos,
            __out ptr * FileObject
            );

        void
        (NTAPI * FileDelete)(
            __in ptr FileObject
            );

        status
        (NTAPI * DriverOpen)(
            __in OB_OPEN_REASON OpenReason,
            __in KPROCESSOR_MODE PreviousMode,
            __in_opt PEPROCESS Process,
            __in ptr DriverObject,
            __in ACCESS_MASK * GrantedAccess,
            __in u32 HandleCount
            );

        void
        (NTAPI * DriverDelete)(
            __in ptr DriverObject
            );

        OB_PREOP_CALLBACK_STATUS
        (NTAPI * GlobalObjectPreCallback)(
            __in ptr RegistrationContext,
            __in POB_PRE_OPERATION_INFORMATION OperationInformation
            );

        void
        (NTAPI * GlobalObjectPostCallback)(
            __in ptr RegistrationContext,
            __in POB_POST_OPERATION_INFORMATION OperationInformation
            );

        void
        (NTAPI * GlobalProcessNotify)(
            __in ptr ParentId,
            __in ptr ProcessId,
            __in b Create
            );

        void
        (NTAPI * GlobalThreadNotify)(
            __in ptr ProcessId,
            __in ptr ThreadId,
            __in b Create
            );

        void
        (NTAPI * GlobalImageNotify)(
            __in PUNICODE_STRING FullImageName,
            __in ptr ProcessId,
            __in PIMAGE_INFO ImageInfo
            );

        void
        (NTAPI * KeEnterCriticalRegion)(
            void
            );

        void
        (NTAPI * KeLeaveCriticalRegion)(
            void
            );

        status
        (NTAPI * PspCreateThread)(
            __out ptr * ThreadHandle,
            __in ACCESS_MASK DesiredAccess,
            __in_opt POBJECT_ATTRIBUTES ObjectAttributes,
            __in ptr ProcessHandle,
            __in PEPROCESS ProcessPointer,
            __in_opt ptr Reserved,
            __in_opt PLARGE_INTEGER Cookie,
            __out_opt PCLIENT_ID ClientId,
            __in_opt PCONTEXT ThreadContext,
            __in_opt PINITIAL_TEB InitialTeb,
            __in b CreateSuspended,
            __in_opt PKSTART_ROUTINE StartRoutine,
            __in ptr StartContext
            );

        void
        (NTAPI * PspInitializeThunkContext)(
            void
            );

        b
        (FASTCALL * ExAcquireRundownProtection)(
            __inout PEX_RUNDOWN_REF RunRef
            );

        void
        (FASTCALL * ExReleaseRundownProtection)(
            __inout PEX_RUNDOWN_REF RunRef
            );

        void
        (FASTCALL * ExWaitForRundownProtectionRelease)(
            __inout PEX_RUNDOWN_REF RunRef
            );

        KIRQL
        (NTAPI * ExAcquireSpinLockShared)(
            __inout PEX_SPIN_LOCK SpinLock
            );

        void
        (NTAPI * ExReleaseSpinLockShared)(
            __inout PEX_SPIN_LOCK SpinLock,
            __in KIRQL OldIrql
            );

        u32
        (NTAPI * DbgPrint)(
            __in PCH Format,
            ...
            );

        NTSTATUS
        (NTAPI *  KeWaitForSingleObject)(
            __in PVOID Object,
            __in KWAIT_REASON WaitReason,
            __in KPROCESSOR_MODE WaitMode,
            __in BOOLEAN Alertable,
            __in_opt PLARGE_INTEGER Timeout
            );

        u
        (NTAPI * RtlCompareMemory)(
            const void * Destination,
            const void * Source,
            u Length
            );

        void
        (NTAPI * RtlRestoreContext)(
            __in PCONTEXT ContextRecord,
            __in_opt struct _EXCEPTION_RECORD *ExceptionRecord
            );

        void
        (NTAPI * ExQueueWorkItem)(
            __inout PWORK_QUEUE_ITEM WorkItem,
            __in WORK_QUEUE_TYPE QueueType
            );

        void
        (NTAPI * ExFreePoolWithTag)(
            __in ptr P,
            __in u32 Tag
            );

        PSAFEGUARD_OBJECT BugCheckHandle;

        void
        (NTAPI * KeBugCheckEx)(
            __in u32 BugCheckCode,
            __in u P1,
            __in u P2,
            __in u P3,
            __in u P4
            );

        PLIST_ENTRY
        (FASTCALL * ExInterlockedRemoveHeadList)(
            __inout PLIST_ENTRY ListHead,
            __inout PKSPIN_LOCK Lock
            );

        ptr ObjectCallback;

        KDDEBUGGER_DATA64 DebuggerDataBlock;
        KDDEBUGGER_DATA_ADDITION64 DebuggerDataAdditionBlock;

        u32 NameInterval;

        u16 OffsetKProcessThreadListHead;
        u16 OffsetKThreadThreadListEntry;
        u16 OffsetKThreadWin32StartAddress;
        u32 OffsetKThreadProcessId;
        u16 OffsetEProcessActiveProcessLinks;

        struct _PGBLOCK * PgBlock;
    } RTB, *PRTB;

    NTKERNELAPI
        status
        NTAPI
        PsAcquireProcessExitSynchronization(
            __in PEPROCESS Process
        );

    NTKERNELAPI
        void
        NTAPI
        PsReleaseProcessExitSynchronization(
            __in PEPROCESS Process
        );

#define FastAcquireRundownProtection(ref) \
            RtBlock.ExAcquireRundownProtection((ref))

#define FastReleaseRundownProtection(ref) \
            RtBlock.ExReleaseRundownProtection((ref))

#define FastWaitForRundownProtectionRelease(ref) \
            RtBlock.ExWaitForRundownProtectionRelease((ref))

#define FastAcquireObjectLock(irql) \
            *(irql) = RtBlock.ExAcquireSpinLockShared(&RtBlock.Lock)

#define FastReleaseObjectLock(irql) \
            RtBlock.ExReleaseSpinLockShared(&RtBlock.Lock, (irql))

    void
        NTAPI
        InitializeGpBlock(
            __in PRTB Block
        );

    u32
        NTAPI
        LdrMakeProtection(
            __in PIMAGE_SECTION_HEADER NtSection
        );

    u32
        NTAPI
        LdrGetPlatform(
            __in ptr ImageBase
        );

    u32
        NTAPI
        LdrGetTimeStamp(
            __in ptr ImageBase
        );

    u16
        NTAPI
        LdrGetSubsystem(
            __in ptr ImageBase
        );

    u32
        NTAPI
        LdrGetSize(
            __in ptr ImageBase
        );

    ptr
        NTAPI
        LdrGetEntryPoint(
            __in ptr ImageBase
        );

    PIMAGE_SECTION_HEADER
        NTAPI
        SectionTableFromVirtualAddress(
            __in ptr ImageBase,
            __in ptr Address
        );

    PIMAGE_SECTION_HEADER
        NTAPI
        LdrFindSection(
            __in ptr ImageBase,
            __in u8ptr SectionName
        );

    void
        NTAPI
        LdrRelocImage(
            __in ptr ImageBase,
            __in s Diff
        );

    status
        NTAPI
        FindEntryForImage(
            __in PUNICODE_STRING ImageFileName,
            __out PKLDR_DATA_TABLE_ENTRY * DataTableEntry
        );

    status
        NTAPI
        FindEntryForImageAddress(
            __in ptr Address,
            __out PKLDR_DATA_TABLE_ENTRY * DataTableEntry
        );

    ptr
        NTAPI
        LdrGetSymbol(
            __in ptr ImageBase,
            __in_opt cptr ProcedureName,
            __in_opt u32 ProcedureNumber
        );

    ptr
        NTAPI
        LdrNameToAddress(
            __in cptr String
        );

    void
        NTAPI
        LdrSnapThunk(
            __in ptr ImageBase
        );

    void
        NTAPI
        LdrEnumerateThunk(
            __in ptr ImageBase
        );

    void
        NTAPI
        LdrReplaceThunk(
            __in ptr ImageBase,
            __in_opt cptr ImageName,
            __in_opt cptr ProcedureName,
            __in_opt u32 ProcedureNumber,
            __in ptr ProcedureAddress
        );

    s
        NTAPI
        LdrSetImageBase(
            __in ptr ImageBase
        );

    PKLDR_DATA_TABLE_ENTRY
        NTAPI
        LdrLoad(
            __in ptr ViewBase,
            __in wcptr ImageName,
            __in u32 Flags
        );

    void
        NTAPI
        LdrUnload(
            __in PKLDR_DATA_TABLE_ENTRY DataTableEntry
        );

    void
        NTAPI
        DumpImageWorker(
            __in ptr ImageBase,
            __in u32 SizeOfImage,
            __in PUNICODE_STRING ImageFIleName
        );

    status
        NTAPI
        DumpFileWorker(
            __in PUNICODE_STRING ImageFIleName
        );

    extern RTB RtBlock;

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_RELOAD_H_

```

`Projects/Shark/Rtx.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "Rtx.h"

#include "Ctx.h"
#include "Guard.h"
#include "Scan.h"

void
NTAPI
AsyncDispatcher(
    __in PKAPC Apc,
    __in PKNORMAL_ROUTINE * NormalRoutine,
    __in ptr * NormalContext,
    __in ptr * SystemArgument1,
    __in ptr * SystemArgument2
)
{
    PATX Atx = NULL;

    Atx = CONTAINING_RECORD(Apc, ATX, Apc);

    Atx->Rtx.Routines.Result = GuardCall(
        Atx->Rtx.Routines.KernelRoutine,
        Atx->Rtx.Routines.SystemRoutine,
        Atx->Rtx.Routines.RundownRoutine,
        Atx->Rtx.Routines.NormalRoutine);

    KeSetEvent(&Atx->Rtx.Notify, LOW_PRIORITY, FALSE);
}

status
NTAPI
AsyncCall(
    __in ptr UniqueThread,
    __in_opt PGKERNEL_ROUTINE KernelRoutine,
    __in_opt PGSYSTEM_ROUTINE SystemRoutine,
    __in_opt PGRUNDOWN_ROUTINE RundownRoutine,
    __in_opt PGNORMAL_ROUTINE NormalRoutine
)
{
    status Status = STATUS_SUCCESS;
    PETHREAD Thread = NULL;
    ATX Atx = { 0 };
    LARGE_INTEGER Timeout = { 0 };

    Status = PsLookupThreadByThreadId(
        UniqueThread,
        &Thread);

    if (TRACE(Status)) {
        Atx.Rtx.Routines.KernelRoutine = KernelRoutine;
        Atx.Rtx.Routines.SystemRoutine = SystemRoutine;
        Atx.Rtx.Routines.RundownRoutine = RundownRoutine;
        Atx.Rtx.Routines.NormalRoutine = NormalRoutine;

        KeInitializeEvent(
            &Atx.Rtx.Notify,
            SynchronizationEvent,
            FALSE);

        if ((u)KeGetCurrentThread() != (u)Thread) {
            KeInitializeApc(
                &Atx.Apc,
                Thread,
                OriginalApcEnvironment,
                AsyncDispatcher,
                NULL,
                NULL,
                KernelMode,
                NULL);

            Timeout.QuadPart = Int32x32To64(10, -10 * 1000 * 1000);

            if (FALSE != KeInsertQueueApc(
                &Atx.Apc,
                NULL,
                NULL,
                LOW_PRIORITY)) {
                Status = KeWaitForSingleObject(
                    &Atx.Rtx.Notify,
                    Executive,
                    KernelMode,
                    FALSE,
                    &Timeout);

                if (STATUS_SUCCESS == Status) {
                    Status = Atx.Rtx.Routines.Result;
                }
            }
            else {
                Status = STATUS_UNSUCCESSFUL;
            }
        }
        else {
            AsyncDispatcher(&Atx.Apc, NULL, NULL, NULL, NULL);

            Status = Atx.Rtx.Routines.Result;
        }

        ObDereferenceObject(Thread);
    }

    return Status;
}

void
NTAPI
IpiDispatcher(
    __in PRTX Rtx
)
{
    if (-1 == Rtx->Processor) {
        GuardCall(
            Rtx->Routines.KernelRoutine,
            Rtx->Routines.SystemRoutine,
            Rtx->Routines.RundownRoutine,
            Rtx->Routines.NormalRoutine);
    }
    else {
        if (KeGetCurrentProcessorNumber() == Rtx->Processor) {
            Rtx->Routines.Result = GuardCall(
                Rtx->Routines.KernelRoutine,
                Rtx->Routines.SystemRoutine,
                Rtx->Routines.RundownRoutine,
                Rtx->Routines.NormalRoutine);
        }
    }
}

u
NTAPI
IpiSingleCall(
    __in_opt PGKERNEL_ROUTINE KernelRoutine,
    __in_opt PGSYSTEM_ROUTINE SystemRoutine,
    __in_opt PGRUNDOWN_ROUTINE RundownRoutine,
    __in_opt PGNORMAL_ROUTINE NormalRoutine
)
{
    u Result = 0;
    RTX Rtx = { 0 };

    Rtx.Processor = KeGetCurrentProcessorNumber();

    Rtx.Routines.KernelRoutine = KernelRoutine;
    Rtx.Routines.SystemRoutine = SystemRoutine;
    Rtx.Routines.RundownRoutine = RundownRoutine;
    Rtx.Routines.NormalRoutine = NormalRoutine;

    KeIpiGenericCall(
        (PKIPI_BROADCAST_WORKER)IpiDispatcher,
        (u)&Rtx);

    Result = Rtx.Routines.Result;

    return Result;
}

void
NTAPI
IpiGenericCall(
    __in_opt PGKERNEL_ROUTINE KernelRoutine,
    __in_opt PGSYSTEM_ROUTINE SystemRoutine,
    __in_opt PGRUNDOWN_ROUTINE RundownRoutine,
    __in_opt PGNORMAL_ROUTINE NormalRoutine
)
{
    RTX Rtx = { 0 };

    Rtx.Processor = -1;

    Rtx.Routines.KernelRoutine = KernelRoutine;
    Rtx.Routines.SystemRoutine = SystemRoutine;
    Rtx.Routines.RundownRoutine = RundownRoutine;
    Rtx.Routines.NormalRoutine = NormalRoutine;

    KeIpiGenericCall(
        (PKIPI_BROADCAST_WORKER)IpiDispatcher,
        (u)&Rtx);
}

```

`Projects/Shark/Rtx.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _RTX_H_
#define _RTX_H_

#include <devicedefs.h>

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

    typedef struct _OBJECT *POBJECT;

    typedef struct _ROUTINES32 {
        u32 KernelRoutine;
        u32 SystemRoutine;
        u32 RundownRoutine;
        u32 NormalRoutine;
        u32 Result;
    }ROUTINES32, *PROUTINES32;

    typedef struct _ROUTINES64 {
        u64 KernelRoutine;
        u64 SystemRoutine;
        u64 RundownRoutine;
        u64 NormalRoutine;
        u64 Result;
    }ROUTINES64, *PROUTINES64;

    typedef struct _ROUTINES {
        PGKERNEL_ROUTINE KernelRoutine;
        PGSYSTEM_ROUTINE SystemRoutine;
        PGRUNDOWN_ROUTINE RundownRoutine;
        PGNORMAL_ROUTINE NormalRoutine;
        u Result;
    }ROUTINES, *PROUTINES;

    typedef struct _WORKER_OBJECT {
        SINGLE_LIST_ENTRY NextEntry;
        ROUTINES Routines;
    }WORKER_OBJECT, *PWORKER_OBJECT;

    typedef struct _RTX {
        POBJECT Object;
        POBJECT Target;
        ptr ApiMessage;
        KEVENT Notify;

        u16 Platform;
        u32 Processor;

        union {
            ROUTINES Routines;
            ROUTINES32 Routines32;
            ROUTINES64 Routines64;
        };

        KPROCESSOR_MODE Mode;
    } RTX, *PRTX;

    typedef struct _ATX {
        KAPC Apc;
        RTX Rtx;
    } ATX, *PATX;

#define MAXIMUM_COMPARE_INSTRUCTION_COUNT 8

    status
        NTAPI
        AsyncCall(
            __in ptr UniqueThread,
            __in_opt PGKERNEL_ROUTINE KernelRoutine,
            __in_opt PGSYSTEM_ROUTINE SystemRoutine,
            __in_opt PGRUNDOWN_ROUTINE RundownRoutine,
            __in_opt PGNORMAL_ROUTINE NormalRoutine
        );

    u
        NTAPI
        IpiSingleCall(
            __in_opt PGKERNEL_ROUTINE KernelRoutine,
            __in_opt PGSYSTEM_ROUTINE SystemRoutine,
            __in_opt PGRUNDOWN_ROUTINE RundownRoutine,
            __in_opt PGNORMAL_ROUTINE NormalRoutine
        );

    void
        NTAPI
        IpiGenericCall(
            __in_opt PGKERNEL_ROUTINE KernelRoutine,
            __in_opt PGSYSTEM_ROUTINE SystemRoutine,
            __in_opt PGRUNDOWN_ROUTINE RundownRoutine,
            __in_opt PGNORMAL_ROUTINE NormalRoutine
        );

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_RTX_H_

```

`Projects/Shark/Scan.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "Scan.h"

u
NTAPI
TrimBytes(
    __in u8ptr Sig,
    __in_opt u8ptr Coll,
    __in_bcount(Coll) u CollSize,
    __out bptr Selector
)
{
    status Status = STATUS_SUCCESS;
    u Result = 0;
    u8ptr Buffer = NULL;
    u BufferSize = 0;
    u8 Single[3] = { 0 };
    u32 Digit = 0;
    u Index = 0;
    u32 Length = 0;

    Length = strlen(Sig);

    for (Index = 0;
        Index < Length;
        Index++) {
        if (0 != isxdigit(*(Sig + Index)) ||
            0 == _cmpbyte(*(Sig + Index), '?')) {
            BufferSize++;
        }
    }

    if (0 != BufferSize) {
        Buffer = __malloc(BufferSize);

        if (NULL != Buffer) {
            RtlZeroMemory(
                Buffer,
                BufferSize);

            for (Index = 0;
                Index < Length;
                Index++) {
                if (0 != isxdigit(*(Sig + Index)) ||
                    0 == _cmpbyte(*(Sig + Index), '?')) {
                    RtlCopyMemory(
                        Buffer + strlen(Buffer),
                        Sig + Index,
                        2);

                    Index++;
                }
            }

            if (0 != (BufferSize & 1)) {
                Result = -1;
            }
            else {
                if (NULL == Coll) {
                    Result = BufferSize / 2;
                }
                else {
                    Result = BufferSize / 2;

                    if (CollSize >= BufferSize / 2) {
                        for (Index = 0;
                            Index < BufferSize;
                            Index += 2) {
                            if (0 == _cmpbyte(*(Buffer + Index), '?') &&
                                0 == _cmpbyte(*(Buffer + Index + 1), '?')) {
                                *(Coll + Index / 2) = '?';

                                *Selector = TRUE;
                            }
                            else if (0 != isxdigit(*(Buffer + Index)) &&
                                0 != isxdigit(*(Buffer + Index + 1))) {
                                RtlCopyMemory(
                                    Single,
                                    Buffer + Index,
                                    sizeof(u8) * 2);

                                Status = RtlCharToInteger(
                                    Single,
                                    16,
                                    &Digit);

                                if (TRACE(Status)) {
                                    *(Coll + Index / 2) = (u8)Digit;

                                    *Selector =
                                        FALSE != *Selector ? TRUE : FALSE;
                                }
                                else {
                                    Result = -1;

                                    break;
                                }
                            }
                            else {
                                Result = -1;

                                break;
                            }
                        }
                    }
                    else {
                        Result = -1;
                    }
                }
            }

            __free(Buffer);
        }
    }

    return Result;
}

u
NTAPI
CompareBytes(
    __in u8ptr Destination,
    __in u8ptr Source,
    __in u Length,
    __in b Selector
)
{
    u Count = 0;

    if (FALSE == Selector) {
        Count = RtlCompareMemory(
            Destination,
            Source,
            Length);
    }
    else {
        for (Count = 0;
            Count < Length;
            Count++) {
            if (0 != _cmpbyte(*(Destination + Count), *(Source + Count)) &&
                0 != _cmpbyte(*(Source + Count), '?')) {
                break;
            }
        }
    }

    return Count;
}

ptr
NTAPI
ScanBytes(
    __in u8ptr Begin,
    __in u8ptr End,
    __in u8ptr Sig
)
{
    b Selector = FALSE;
    u8ptr Coll = NULL;
    u CollSize = 0;
    ptr Result = NULL;
    u Index = 0;

    CollSize = TrimBytes(
        Sig,
        NULL,
        CollSize,
        &Selector);

    if (-1 != CollSize) {
        if ((s)(End - Begin - CollSize) >= 0) {
            Coll = __malloc(CollSize);

            if (NULL != Coll) {
                CollSize = TrimBytes(
                    Sig,
                    Coll,
                    CollSize,
                    &Selector);

                if (-1 != CollSize) {
                    for (Index = 0;
                        Index < End - Begin - CollSize;
                        Index++) {
                        if (CollSize == CompareBytes(
                            Begin + Index,
                            Coll,
                            CollSize,
                            Selector)) {
                            Result = Begin + Index;
                            break;
                        }
                    }
                }

                __free(Coll);
            }
        }
    }

    return Result;
}

```

`Projects/Shark/Scan.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _SCAN_H_
#define _SCAN_H_

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

    b
        NTAPI
        _cmpbyte(
            __in s8 b1,
            __in s8 b2
        );

    b
        NTAPI
        _cmpword(
            __in s16 s1,
            __in s16 s2
        );

    b
        NTAPI
        _cmpdword(
            __in s32 l1,
            __in s32 l2
        );

    b
        NTAPI
        _cmpqword(
            __in s64 ll1,
            __in s64 ll2
        );

    ptr
        NTAPI
        ScanBytes(
            __in u8ptr Begin,
            __in u8ptr End,
            __in u8ptr Sig
        );

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_SCAN_H_

```

`Projects/Shark/Shark.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>
#include <devicedefs.h>

#include "Shark.h"

#include "Except.h"
#include "Guard.h"
#include "Reload.h"
#include "PatchGuard.h"
#include "Space.h"

#pragma section( ".block", read, write, execute )

__declspec(allocate(".block")) RTB RtBlock = { 0 };
__declspec(allocate(".block")) PGBLOCK PgBlock = { 0 };

status
NTAPI
KernelFastCall(
    __in ptr Reserve,
    __in u32 Operation
)
{
    status Status = STATUS_SUCCESS;

#ifdef DEBUG
    vDbgPrint(
        "[Shark] KernelFastCall\n");
#endif // DEBUG

    switch (Operation) {
    case 0: {
        break;
    }

    case 1: {
        break;
    }

    case 2: {
        break;
    }

    default: {
        break;
    }
    }

    return Status;
}

status
NTAPI
ReloadSelf(
    __in PRTB RtBlock,
    __in u32 Operation
)
{
    status Status = STATUS_SUCCESS;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry = NULL;
    PGNORMAL_ROUTINE GsInitialize = NULL;
    PGSUPPORT_ROUTINE KernelEntry = NULL;

    DataTableEntry = LdrLoad(
        RtBlock->Self->SupImage.pvImage,
        KernelString,
        LDRP_SYSTEM_MAPPED | LDRP_REDIRECTED);

    if (NULL != DataTableEntry) {
#ifdef DEBUG
        vDbgPrint(
            ".reload /i %wZ=%p < %p - %08x >\n",
            &DataTableEntry->BaseDllName,
            DataTableEntry->DllBase,
            DataTableEntry->DllBase,
            DataTableEntry->SizeOfImage);
#endif // DEBUG

        GsInitialize = DataTableEntry->EntryPoint;

        if (NULL != GsInitialize) {
            GsInitialize();

            KernelEntry =
                LdrGetSymbol(
                    DataTableEntry->DllBase,
                    "KernelEntry",
                    0);

            if (NULL != KernelEntry) {
                Status = KernelEntry(
                    (ptr)DataTableEntry,
                    (ptr)(u)Operation,
                    NULL,
                    NULL);
            }
            else {
                __free(DataTableEntry);

                Status = STATUS_UNSUCCESSFUL;
            }
        }
        else {
            __free(DataTableEntry);

            Status = STATUS_UNSUCCESSFUL;
        }
    }
    else {
        Status = STATUS_UNSUCCESSFUL;

#ifdef DEBUG
        vDbgPrint(
            "[Shark] reload failed\n");
#endif // DEBUG
    }

    return Status;
}

status
NTAPI
KernelEntry(
    __in ptr Self,
    __in u32 Operation,
    __in ptr Reserve, // do not use
    __in ptr Nothing
)
{
    status Status = STATUS_SUCCESS;

    RtBlock.PgBlock = &PgBlock;
    PgBlock.RtBlock = &RtBlock;

    RtBlock.Self = Self;
    RtBlock.Operation = Operation;

    InitializeGpBlock(&RtBlock);

    if (CmdReload ==
        (RtBlock.Operation & CmdReload)) {
        ReloadSelf(&RtBlock, Operation & ~CmdReload);
    }
    else {
        InitializeSpace(&RtBlock);

        if (CmdPgClear ==
            (RtBlock.Operation & CmdPgClear)) {
            PgBlock.IsDebug = 1;

#ifndef _WIN64
            InitializeExcept(&RtBlock);
#else                             
            PgClear(&PgBlock);
            InitializeExcept(&RtBlock);
#endif // !_WIN64

            __try {
                *(volatile u8ptr)NULL;
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
#ifdef DEBUG
                vDbgPrint(
                    "[SHARK] < %p > test exception code\n",
                    GetExceptionCode());
#endif // DEBUG    
            }
        }

        if (CmdVmxOn ==
            (RtBlock.Operation & CmdVmxOn)) {
            // VmxStartAllProcessors(&RtBlock.CpuControlBlock);
        }

#ifdef DEBUG
        vDbgPrint(
            "[SHARK] < %p > shark load success\n",
            RtBlock.Self);
#endif // DEBUG
    }

    return Status;
}

```

`Projects/Shark/Shark.def`:

```def
;
;
; Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
;
; The contents of this file are subject to the Mozilla Public License Version
; 2.0 (the "License"); you may not use this file except in compliance with
; the License. You may obtain a copy of the License at
; http://www.mozilla.org/MPL/
;
; Software distributed under the License is distributed on an "AS IS" basis,
; WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
; for the specific language governing rights and limitations under the
; License.
;
; The Initial Developer of the Original Code is blindtiger.
;
;

LIBRARY
    EXPORTS
           
    KernelFastCall
    KernelEntry

```

`Projects/Shark/Shark.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _SHARK_H_
#define _SHARK_H_

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */



#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_SHARK_H_

```

`Projects/Shark/Shark.rc`:

```rc
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <winver.h>
#include <ver.h>

#define VER_FILEDESCRIPTION_STR     "Shark"
#define VER_INTERNALNAME_STR        "Shark"
#define VER_ORIGINALFILENAME_STR    "Shark.sys"

#include <common.ver>

```

`Projects/Shark/Shark.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Optimized|Win32">
      <Configuration>Optimized</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Optimized|x64">
      <Configuration>Optimized</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{389A3E87-9607-4515-9937-F2C5BAA1E268}</ProjectGuid>
    <Keyword>MakeFileProj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'" Label="Configuration">
    <ConfigurationType>Makefile</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'" Label="Configuration">
    <ConfigurationType>Makefile</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">
    <NMakeBuildCommandLine>NMAKE /NOLOGO BUILD PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeBuildCommandLine>
    <NMakeCleanCommandLine>NMAKE /NOLOGO CLEAN PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeCleanCommandLine>
    <NMakeReBuildCommandLine>NMAKE /NOLOGO REBUILD PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeReBuildCommandLine>
    <NMakeOutput>$(SolutionDir)Build\Bins\I386\$(ProjectName).sys</NMakeOutput>
    <NMakePreprocessorDefinitions>UNICODE;_UNICODE;DOSWIN32;_X86_;NTOS_KERNEL_RUNTIME;_NTDRIVER_;DETOURS_X86;DETOURS_32BIT</NMakePreprocessorDefinitions>
    <NMakeIncludeSearchPath>..\..\..\MiniSDK\inc\ddk;..\..\..\MiniSDK\inc\halkit;..\..\..\MiniSDK\inc\internal\base;..\..\..\MiniSDK\inc\internal\ds;..\..\..\MiniSDK\inc\internal\sdktools;..\..\..\MiniSDK\inc\sdk;..\..\..\MiniSDK\inc\sdk\inc\crt;..\..\..\MiniSDK\inc\base;..\..\..\MiniSDK\inc\base\ntos;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt;..\..\..\MiniSDK\inc\sdk\crt\gl;..\..\..\MiniSDK\inc\sdk\crt\sys;..\..\..\MiniSDK\inc\debuggers;$(SolutionDir)Include;$(ProjectDir)</NMakeIncludeSearchPath>
    <OutDir>$(SolutionDir)Build\Bins\I386\</OutDir>
    <IntDir>$(SolutionDir)Build\Objs\$(ProjectName)\I386\</IntDir>
    <IncludePath>..\..\..\MiniSDK\inc\ddk;..\..\..\MiniSDK\inc\halkit;..\..\..\MiniSDK\inc\internal\base;..\..\..\MiniSDK\inc\internal\ds;..\..\..\MiniSDK\inc\internal\sdktools;..\..\..\MiniSDK\inc\sdk;..\..\..\MiniSDK\inc\sdk\inc\crt;..\..\..\MiniSDK\inc\base;..\..\..\MiniSDK\inc\base\ntos;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt;..\..\..\MiniSDK\inc\sdk\crt\gl;..\..\..\MiniSDK\inc\sdk\crt\sys;..\..\..\MiniSDK\inc\debuggers;$(SolutionDir)Include;$(ProjectDir)</IncludePath>
    <ReferencePath />
    <LibraryPath>..\..\..\MiniSDK\lib\I386;..\..\..\MiniSDK\lib\Crt\I386</LibraryPath>
    <LibraryWPath />
    <SourcePath />
    <ExcludePath />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">
    <NMakeBuildCommandLine>NMAKE /NOLOGO BUILD PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeBuildCommandLine>
    <NMakeCleanCommandLine>NMAKE /NOLOGO CLEAN PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeCleanCommandLine>
    <NMakeReBuildCommandLine>NMAKE /NOLOGO REBUILD PLATFORM=$(PlatformShortName) PROJ=$(ProjectName) SLND=$(SolutionDir)</NMakeReBuildCommandLine>
    <NMakeOutput>$(SolutionDir)Build\Bins\AMD64\$(ProjectName).sys</NMakeOutput>
    <NMakePreprocessorDefinitions>UNICODE;_UNICODE;_AMD64_;NTOS_KERNEL_RUNTIME;_NTDRIVER_;DETOURS_X64;DETOURS_64BIT</NMakePreprocessorDefinitions>
    <NMakeIncludeSearchPath>..\..\..\MiniSDK\inc\ddk;..\..\..\MiniSDK\inc\halkit;..\..\..\MiniSDK\inc\internal\base;..\..\..\MiniSDK\inc\internal\ds;..\..\..\MiniSDK\inc\internal\sdktools;..\..\..\MiniSDK\inc\sdk;..\..\..\MiniSDK\inc\sdk\inc\crt;..\..\..\MiniSDK\inc\base;..\..\..\MiniSDK\inc\base\ntos;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt;..\..\..\MiniSDK\inc\sdk\crt\gl;..\..\..\MiniSDK\inc\sdk\crt\sys;..\..\..\MiniSDK\inc\debuggers;$(SolutionDir)Include;$(ProjectDir)</NMakeIncludeSearchPath>
    <OutDir>$(SolutionDir)Build\Bins\AMD64\</OutDir>
    <IntDir>$(SolutionDir)Build\Objs\$(ProjectName)\AMD64\</IntDir>
    <IncludePath>..\..\..\MiniSDK\inc\ddk;..\..\..\MiniSDK\inc\halkit;..\..\..\MiniSDK\inc\internal\base;..\..\..\MiniSDK\inc\internal\ds;..\..\..\MiniSDK\inc\internal\sdktools;..\..\..\MiniSDK\inc\sdk;..\..\..\MiniSDK\inc\sdk\inc\crt;..\..\..\MiniSDK\inc\base;..\..\..\MiniSDK\inc\base\ntos;..\..\..\MiniSDK\inc\sdk\wnet;..\..\..\MiniSDK\inc\sdk\crt;..\..\..\MiniSDK\inc\sdk\crt\gl;..\..\..\MiniSDK\inc\sdk\crt\sys;..\..\..\MiniSDK\inc\debuggers;$(SolutionDir)Include;$(ProjectDir)</IncludePath>
    <ReferencePath />
    <LibraryPath>..\..\..\MiniSDK\lib\AMD64;..\..\..\MiniSDK\lib\Crt\AMD64</LibraryPath>
    <LibraryWPath />
    <SourcePath />
    <ExcludePath />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
  <ItemGroup>
    <MASM Include="AMD64\AMD64.asm">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">true</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">false</UseSafeExceptionHandlers>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">false</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">true</UseSafeExceptionHandlers>
    </MASM>
    <MASM Include="AMD64\ContextAMD64.asm" />
    <MASM Include="I386\ContextI386.asm" />
    <MASM Include="I386\I386.asm">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">false</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">true</UseSafeExceptionHandlers>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">true</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">false</UseSafeExceptionHandlers>
    </MASM>
    <MASM Include="AMD64\CmpAMD64.asm">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">true</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">false</UseSafeExceptionHandlers>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">false</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">true</UseSafeExceptionHandlers>
    </MASM>
    <MASM Include="I386\CmpI386.asm">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">false</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">true</UseSafeExceptionHandlers>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">true</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">false</UseSafeExceptionHandlers>
    </MASM>
    <ClCompile Include="AMD64\ExceptAMD64.c" />
    <ClCompile Include="AMD64\PatchGuardAMD64.c">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">true</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">false</UseSafeExceptionHandlers>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">false</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">true</UseSafeExceptionHandlers>
    </ClCompile>
    <ClCompile Include="AMD64\SpaceAMD64.c" />
    <ClCompile Include="AMD64\StackAMD64.c" />
    <ClCompile Include="Except.c" />
    <ClCompile Include="Guard.c" />
    <ClCompile Include="I386\ExceptI386.c" />
    <ClCompile Include="I386\PatchGuardI386.c">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">false</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|Win32'">true</UseSafeExceptionHandlers>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">true</ExcludedFromBuild>
      <UseSafeExceptionHandlers Condition="'$(Configuration)|$(Platform)'=='Optimized|x64'">false</UseSafeExceptionHandlers>
    </ClCompile>
    <ClCompile Include="I386\SpaceI386.c" />
    <ClCompile Include="Ctx.c" />
    <ClCompile Include="I386\StackI386.c" />
    <ClCompile Include="Reload.c" />
    <ClCompile Include="Rtx.c" />
    <ClCompile Include="Shark.c" />
    <ClCompile Include="PatchGuard.c" />
    <ClCompile Include="Scan.c" />
    <ClCompile Include="Space.c" />
    <ClCompile Include="Stack.c" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Shark.def" />
    <None Include="Makefile" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Shark.rc" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Except.h" />
    <ClInclude Include="Guard.h" />
    <ClInclude Include="Reload.h" />
    <ClInclude Include="Rtx.h" />
    <ClInclude Include="Shark.h" />
    <ClInclude Include="PatchGuard.h" />
    <ClInclude Include="Ctx.h" />
    <ClInclude Include="Scan.h" />
    <ClInclude Include="Space.h" />
    <ClInclude Include="Stack.h" />
  </ItemGroup>
</Project>
```

`Projects/Shark/Shark.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Source Files\AMD64">
      <UniqueIdentifier>{6cc352ef-8d01-46ce-8869-0b5e9c731c9d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\I386">
      <UniqueIdentifier>{ef34afe2-89bf-4075-b93c-6850345cfe9a}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Shark.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PatchGuard.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AMD64\PatchGuardAMD64.c">
      <Filter>Source Files\AMD64</Filter>
    </ClCompile>
    <ClCompile Include="I386\PatchGuardI386.c">
      <Filter>Source Files\I386</Filter>
    </ClCompile>
    <ClCompile Include="Ctx.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Scan.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Stack.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Except.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Reload.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Space.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AMD64\SpaceAMD64.c">
      <Filter>Source Files\AMD64</Filter>
    </ClCompile>
    <ClCompile Include="I386\SpaceI386.c">
      <Filter>Source Files\I386</Filter>
    </ClCompile>
    <ClCompile Include="Rtx.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AMD64\StackAMD64.c">
      <Filter>Source Files\AMD64</Filter>
    </ClCompile>
    <ClCompile Include="I386\StackI386.c">
      <Filter>Source Files\I386</Filter>
    </ClCompile>
    <ClCompile Include="Guard.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AMD64\ExceptAMD64.c">
      <Filter>Source Files\AMD64</Filter>
    </ClCompile>
    <ClCompile Include="I386\ExceptI386.c">
      <Filter>Source Files\I386</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Shark.def">
      <Filter>Source Files</Filter>
    </None>
    <None Include="Makefile" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Shark.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="AMD64\AMD64.asm">
      <Filter>Source Files\AMD64</Filter>
    </MASM>
    <MASM Include="I386\I386.asm">
      <Filter>Source Files\I386</Filter>
    </MASM>
    <MASM Include="AMD64\CmpAMD64.asm">
      <Filter>Source Files\AMD64</Filter>
    </MASM>
    <MASM Include="I386\CmpI386.asm">
      <Filter>Source Files\I386</Filter>
    </MASM>
    <MASM Include="AMD64\ContextAMD64.asm">
      <Filter>Source Files\AMD64</Filter>
    </MASM>
    <MASM Include="I386\ContextI386.asm">
      <Filter>Source Files\I386</Filter>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Shark.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PatchGuard.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Ctx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Scan.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Stack.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Except.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Reload.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Space.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Rtx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Guard.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Projects/Shark/Shark.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Projects/Shark/Space.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "Space.h"

#include "Reload.h"
#include "Rtx.h"

void
NTAPI
FlushSingleTb(
    __in ptr VirtualAddress
)
{
    IpiSingleCall(
        (PGKERNEL_ROUTINE)NULL,
        (PGSYSTEM_ROUTINE)NULL,
        (PGRUNDOWN_ROUTINE)_FlushSingleTb,
        (PGNORMAL_ROUTINE)VirtualAddress);
}

void
NTAPI
FlushMultipleTb(
    __in ptr VirtualAddress,
    __in u RegionSize,
    __in b AllProcesors
)
{
    if (FALSE != AllProcesors) {
        IpiGenericCall(
            (PGKERNEL_ROUTINE)NULL,
            (PGSYSTEM_ROUTINE)_FlushMultipleTb,
            (PGRUNDOWN_ROUTINE)VirtualAddress,
            (PGNORMAL_ROUTINE)RegionSize);
    }
    else {
        IpiSingleCall(
            (PGKERNEL_ROUTINE)NULL,
            (PGSYSTEM_ROUTINE)_FlushMultipleTb,
            (PGRUNDOWN_ROUTINE)VirtualAddress,
            (PGNORMAL_ROUTINE)RegionSize);
    }
}

```

`Projects/Shark/Space.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _SPACE_H_
#define _SPACE_H_

#include "..\..\WRK\base\ntos\mm\mi.h"

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

#ifndef _WIN64
#define GetPxeAddress(va) (NULL);
#define GetPpeAddress(va) (NULL);
#define GetVaMappedByPxe(Pxe) (NULL);
#define GetVaMappedByPpe(Ppe) (NULL);

    PMMPTE
        NTAPI
        _GetPdeAddress(
            __in ptr VirtualAddress,
            __in PMMPTE PdeBase
        );

    PMMPTE
        NTAPI
        _GetPdeAddressPae(
            __in ptr VirtualAddress,
            __in PMMPTE PdeBase
        );

    PMMPTE
        NTAPI
        _GetPteAddress(
            __in ptr VirtualAddress,
            __in PMMPTE PteBase
        );

    PMMPTE
        NTAPI
        _GetPteAddressPae(
            __in ptr VirtualAddress,
            __in PMMPTE PteBase
        );

    ptr
        NTAPI
        _GetVaMappedByPte(
            __in PMMPTE Pte
        );

    ptr
        NTAPI
        _GetVaMappedByPtePae(
            __in PMMPTE Pte
        );

    ptr
        NTAPI
        _GetVaMappedByPde(
            __in PMMPTE Pde
        );

    ptr
        NTAPI
        _GetVaMappedByPdePae(
            __in PMMPTE Pde
        );
#else
    PMMPTE
        NTAPI
        GetPxeAddress(
            __in ptr VirtualAddress
        );

    PMMPTE
        NTAPI
        GetPpeAddress(
            __in ptr VirtualAddress
        );

    ptr
        NTAPI
        GetVaMappedByPxe(
            __in PMMPTE Pxe
        );

    ptr
        NTAPI
        GetVaMappedByPpe(
            __in PMMPTE Ppe
        );
#endif // !_WIN64

    void
        NTAPI
        InitializeSpace(
            __inout ptr Block
        );

    PMMPTE
        NTAPI
        GetPdeAddress(
            __in ptr VirtualAddress
        );

    PMMPTE
        NTAPI
        GetPteAddress(
            __in ptr VirtualAddress
        );

    ptr
        NTAPI
        GetVaMappedByPde(
            __in PMMPTE Pde
        );

    ptr
        NTAPI
        GetVaMappedByPte(
            __in PMMPTE Pte
        );

    //
    //  Miscellaneous support macros.
    //
    //      u32
    //      FlagOn (
    //          IN u32 Flags,
    //          IN u32 SingleFlag
    //          );
    //
    //      b
    //      BooleanFlagOn (
    //          IN u32 Flags,
    //          IN u32 SingleFlag
    //          );
    //
    //      void
    //      SetFlag (
    //          IN u32 Flags,
    //          IN u32 SingleFlag
    //          );
    //
    //      void
    //      ClearFlag (
    //          IN u32 Flags,
    //          IN u32 SingleFlag
    //          );
    //
    //      u32
    //      QuadAlign (
    //          IN u32 Pointer
    //          );
    //

#define FlagOn(F,SF) ( \
    (((F) & (SF)))     \
)

#define BooleanFlagOn(F,SF) (    \
    (b)(((F) & (SF)) != 0) \
)

#define SetFlag(F,SF) { \
    (F) |= (SF);        \
}

#define ClearFlag(F,SF) { \
    (F) &= ~(SF);         \
}

#define QuadAlign(P) (             \
    ((((P)) + 7) & (-8)) \
)

#undef MM_PTE_WRITE_MASK
#define MM_PTE_WRITE_MASK 0x2

#ifndef _WIN64
#define MM_PTE_EXECUTE_MASK 0x8000000000000000UI64

#define PAE_ENABLE (FALSE != GpBlock.DebuggerDataBlock.PaeEnabled)

#define INSERT_EXECUTE_TO_VALID_PTE(PPTE) { \
            if(FALSE != PAE_ENABLE) \
                *(u64ptr)(PPTE) &= ~MM_PTE_EXECUTE_MASK; \
        }
#define REMOVE_EXECUTE_TO_VALID_PTE(PPTE) { \
            if(FALSE != PAE_ENABLE) \
                *(u64ptr)(PPTE) |= MM_PTE_EXECUTE_MASK; \
        }
#else
#define INSERT_EXECUTE_TO_VALID_PTE(PPTE) (PPTE)->u.Hard.NoExecute = 0;
#define REMOVE_EXECUTE_TO_VALID_PTE(PPTE) (PPTE)->u.Hard.NoExecute = 1;
#endif // !_WIN64

    void
        NTAPI
        _FlushSingleTb(
            __in ptr VirtualAddress
        );

    void
        NTAPI
        FlushSingleTb(
            __in ptr VirtualAddress
        );

    FORCEINLINE
        void
        NTAPI
        _FlushMultipleTb(
            __in ptr VirtualAddress,
            __in u RegionSize
        )
    {
        PFN_NUMBER NumberOfPages = 0;
        PFN_NUMBER PageFrameIndex = 0;

        NumberOfPages =
            BYTES_TO_PAGES(RegionSize +
            ((u8ptr)VirtualAddress - (u8ptr)PAGE_ALIGN(VirtualAddress)));

        for (PageFrameIndex = 0;
            PageFrameIndex < NumberOfPages;
            PageFrameIndex++) {
            _FlushSingleTb(
                (u8ptr)PAGE_ALIGN(VirtualAddress) + PAGE_SIZE * PageFrameIndex);
        }
    }

    void
        NTAPI
        FlushMultipleTb(
            __in ptr VirtualAddress,
            __in u RegionSize,
            __in b AllProcesors
        );

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_SPACE_H_

```

`Projects/Shark/Stack.c`:

```c
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License")); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#include <defs.h>

#include "Stack.h"

#include "Reload.h"

void
NTAPI
PrintSymbol(
    __in u8ptr Prefix,
    __in PSYMBOL Symbol
)
{
    if (NULL != Symbol->String) {
        if (0 == Symbol->Offset) {
#ifdef DEBUG
            vDbgPrint(
                "%s < %p > %wZ!%hs\n",
                Prefix,
                Symbol->Address,
                &Symbol->DataTableEntry->BaseDllName,
                Symbol->String);
#endif // DEBUG
        }
        else {
#ifdef DEBUG
            vDbgPrint(
                "%s < %p > %wZ!%hs + %x\n",
                Prefix,
                Symbol->Address,
                &Symbol->DataTableEntry->BaseDllName,
                Symbol->String,
                Symbol->Offset);
#endif // DEBUG
        }
    }
    else if (0 != Symbol->Ordinal) {
        if (0 == Symbol->Offset) {
#ifdef DEBUG
            vDbgPrint(
                "%s < %p > %wZ!@%d\n",
                Prefix,
                Symbol->Address,
                &Symbol->DataTableEntry->BaseDllName,
                Symbol->Ordinal);
#endif // DEBUG
        }
        else {
#ifdef DEBUG
            vDbgPrint(
                "%s < %p > %wZ!@%d + %x\n",
                Prefix,
                Symbol->Address,
                &Symbol->DataTableEntry->BaseDllName,
                Symbol->Ordinal,
                Symbol->Offset);
#endif // DEBUG
        }
    }
    else if (NULL != Symbol->DataTableEntry) {
#ifdef DEBUG
        vDbgPrint(
            "%s < %p > %wZ + %x\n",
            Prefix,
            Symbol->Address,
            &Symbol->DataTableEntry->BaseDllName,
            Symbol->Offset);
#endif // DEBUG
    }
    else {
#ifdef DEBUG
        vDbgPrint(
            "%s < %p > symbol not found\n",
            Prefix,
            Symbol->Address);
#endif // DEBUG
    }
}

void
NTAPI
WalkImageSymbol(
    __in ptr Address,
    __inout PSYMBOL Symbol
)
{
    status Status = STATUS_SUCCESS;
    PIMAGE_EXPORT_DIRECTORY ExportDirectory = NULL;
    u32 Size = 0;
    u32ptr NameTable = NULL;
    u16ptr OrdinalTable = NULL;
    u32ptr AddressTable = NULL;
    cptr NameTableName = NULL;
    u16 HintIndex = 0;
    u16 NameIndex = 0;
    ptr ProcedureAddress = NULL;
    ptr NearAddress = NULL;

    Symbol->Address = Address;

    Symbol->Offset =
        (u)Address - (u)Symbol->DataTableEntry->DllBase;

    ExportDirectory = RtlImageDirectoryEntryToData(
        Symbol->DataTableEntry->DllBase,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_EXPORT,
        &Size);

    if (NULL != ExportDirectory) {
        NameTable =
            (u8ptr)Symbol->DataTableEntry->DllBase + ExportDirectory->AddressOfNames;

        OrdinalTable =
            (u8ptr)Symbol->DataTableEntry->DllBase + ExportDirectory->AddressOfNameOrdinals;

        AddressTable =
            (u8ptr)Symbol->DataTableEntry->DllBase + ExportDirectory->AddressOfFunctions;

        if (NULL != NameTable &&
            NULL != OrdinalTable &&
            NULL != AddressTable) {
            for (HintIndex = 0;
                HintIndex < ExportDirectory->NumberOfFunctions;
                HintIndex++) {
                ProcedureAddress =
                    (u8ptr)Symbol->DataTableEntry->DllBase + AddressTable[HintIndex];

                if ((u)ProcedureAddress <= (u)Symbol->Address &&
                    (u)ProcedureAddress > (u)NearAddress) {
                    NearAddress = ProcedureAddress;

                    for (NameIndex = 0;
                        NameIndex < ExportDirectory->NumberOfNames;
                        NameIndex++) {
                        if (HintIndex == OrdinalTable[NameIndex]) {
                            Symbol->String =
                                (u8ptr)Symbol->DataTableEntry->DllBase + NameTable[HintIndex];
                        }
                    }

                    Symbol->Ordinal =
                        HintIndex + ExportDirectory->Base;

                    Symbol->Offset =
                        (u)Symbol->Address - (u)ProcedureAddress;
                }
            }
        }
    }
}

void
NTAPI
FindSymbol(
    __in ptr Address,
    __inout PSYMBOL Symbol
)
{
    status Status = STATUS_SUCCESS;

    Status = FindEntryForImageAddress(
        Address,
        &Symbol->DataTableEntry);

    if (NT_SUCCESS(Status)) {
        WalkImageSymbol(Address, Symbol);
    }
}

void
NTAPI
FindAndPrintSymbol(
    __in u8ptr Prefix,
    __in ptr Address
)
{
    SYMBOL Symbol = { 0 };

    FindSymbol(Address, &Symbol);
    PrintSymbol(Prefix, &Symbol);
}

void
NTAPI
PrintFrameChain(
    __in u8ptr Prefix,
    __in PCALLERS Callers,
    __in_opt u32 FramesToSkip,
    __in u32 Count
)
{
    u32 Index = 0;

    for (Index = FramesToSkip;
        Index < Count;
        Index++) {
        FindAndPrintSymbol(
            Prefix,
            Callers[Index].Establisher);
    }
}

```

`Projects/Shark/Stack.h`:

```h
/*
*
* Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
*
* The contents of this file are subject to the Mozilla Public License Version
* 2.0 (the "License"); you may not use this file except in compliance with
* the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS" basis,
* WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
* for the specific language governing rights and limitations under the
* License.
*
* The Initial Developer of the Original Code is blindtiger.
*
*/

#ifndef _STACK_H_
#define _STACK_H_

#ifdef __cplusplus
/* Assume byte packing throughout */
extern "C" {
#endif	/* __cplusplus */

    typedef struct _CALLERS {
        ptr * EstablisherFrame;
        ptr Establisher;
    }CALLERS, *PCALLERS;

    DECLSPEC_NOINLINE
        u32
        NTAPI
        WalkFrameChain(
            __out PCALLERS Callers,
            __in u32 Count
        );

    typedef struct _SYMBOL {
        PKLDR_DATA_TABLE_ENTRY DataTableEntry;
        ptr Address;
        cptr String;
        u16 Ordinal;
        s32 Offset;
    }SYMBOL, *PSYMBOL;

    void
        NTAPI
        PrintSymbol(
            __in u8ptr Prefix,
            __in PSYMBOL Symbol
        );

    void
        NTAPI
        WalkImageSymbol(
            __in ptr Address,
            __inout PSYMBOL Symbol
        );

    void
        NTAPI
        FindSymbol(
            __in ptr Address,
            __inout PSYMBOL Symbol
        );

    void
        NTAPI
        FindAndPrintSymbol(
            __in u8ptr Prefix,
            __in ptr Address
        );

    void
        NTAPI
        PrintFrameChain(
            __in u8ptr Prefix,
            __in PCALLERS Callers,
            __in_opt u32 FramesToSkip,
            __in u32 Count
        );

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif // !_STACK_H_

```

`Publisher.cmd`:

```cmd
@set PATH=%PATH%
@set SLNDIR=H:\Labs\Shark\
@set SRCDIR=H:\Labs\Shark\Projects\
@set BINDIR=H:\Labs\Shark\Build\Bins\
@set REDISTDIR=H:\Labs\Shark\Redist\
@set WORKDIR=.\Publisher\

@if not exist %WORKDIR% md %WORKDIR%

@if exist %WORKDIR%AMD64\Sea.exe del /F /Q %WORKDIR%AMD64\Sea.exe
@if exist %WORKDIR%AMD64\Sea.pdb del /F /Q %WORKDIR%AMD64\Sea.pdb
@if exist %WORKDIR%AMD64\Shark.sys del /F /Q %WORKDIR%AMD64\Shark.sys
@if exist %WORKDIR%AMD64\Shark.pdb del /F /Q %WORKDIR%AMD64\Shark.pdb
@if exist %WORKDIR%AMD64\VBoxDrv.sys del /F /Q %WORKDIR%AMD64\VBoxDrv.sys

@if exist %WORKDIR%I386\Sea.exe del /F /Q %WORKDIR%I386\Sea.exe
@if exist %WORKDIR%I386\Sea.pdb del /F /Q %WORKDIR%I386\Sea.pdb
@if exist %WORKDIR%I386\Shark.sys del /F /Q %WORKDIR%I386\Shark.sys
@if exist %WORKDIR%I386\Shark.pdb del /F /Q %WORKDIR%I386\Shark.pdb
@if exist %WORKDIR%I386\VBoxDrv.sys del /F /Q %WORKDIR%I386\VBoxDrv.sys

@if not exist %WORKDIR%AMD64\ md %WORKDIR%AMD64

@if not exist %BINDIR%AMD64\Sea.exe (echo AMD64\Sea.exe not found) else copy /Y %BINDIR%AMD64\Sea.exe %WORKDIR%AMD64\
@if not exist %BINDIR%AMD64\Sea.pdb (echo AMD64\Sea.pdb not found) else copy /Y %BINDIR%AMD64\Sea.pdb %WORKDIR%AMD64\
@if not exist %BINDIR%AMD64\Shark.sys (echo AMD64\Shark.sys not found) else copy /Y %BINDIR%AMD64\Shark.sys %WORKDIR%AMD64\
@if not exist %BINDIR%AMD64\Shark.pdb (echo AMD64\Shark.pdb not found) else copy /Y %BINDIR%AMD64\Shark.pdb %WORKDIR%AMD64\
@if not exist %REDISTDIR%AMD64\VBoxDrv.sys (echo AMD64\VBoxDrv.sys not found) else copy /Y %REDISTDIR%AMD64\VBoxDrv.sys %WORKDIR%AMD64\

@if not exist %WORKDIR%I386\ md %WORKDIR%I386

@if not exist %BINDIR%I386\Sea.exe (echo I386\Sea.exe not found) else copy /Y %BINDIR%I386\Sea.exe %WORKDIR%I386\
@if not exist %BINDIR%I386\Sea.pdb (echo I386\Sea.pdb not found) else copy /Y %BINDIR%I386\Sea.pdb %WORKDIR%I386\
@if not exist %BINDIR%I386\Shark.sys (echo I386\Shark.sys not found) else copy /Y %BINDIR%I386\Shark.sys %WORKDIR%I386\
@if not exist %BINDIR%I386\Shark.pdb (echo I386\Shark.pdb not found) else copy /Y %BINDIR%I386\Shark.pdb %WORKDIR%I386\
@if not exist %REDISTDIR%I386\VBoxDrv.sys (echo I386\VBoxDrv.sys not found) else copy /Y %REDISTDIR%I386\VBoxDrv.sys %WORKDIR%I386\

```

`README.md`:

```md
# Shark
    Turn off PatchGuard in real time for win7 (7600) ~ later.

# Create labs
    md X:\Labs
    cd /d X:\Labs
    git clone https://github.com/9176324/Shark
    git clone https://github.com/9176324/MiniSDK

# Build
    Method 1: run FastBuild.cmd or Rebuild.cmd
    Method 2: MSBuild "Shark.sln" -t:Rebuild -p:Platform="x86"
              MSBuild "Shark.sln" -t:Rebuild -p:Platform="x64"
    Method 3: open "Shark.sln" with VisualStudio

# Install
    run Sea.exe (use vbox exploit to load)
![win11 disable virus](https://user-images.githubusercontent.com/4614528/139319409-1c3773f7-4c72-48bf-a415-29d018555bee.png)
    
# Uninstall
    restart windows

# Other projects link
    DisableWin10PatchguardPoc, https://github.com/killvxk/DisableWin10PatchguardPoc
    EfiGuard, https://github.com/Mattiwatti/EfiGuard
    findpg, https://github.com/tandasat/findpg
    PgResarch, https://github.com/tandasat/PgResarch
    UPGDSED, https://github.com/hfiref0x/UPGDSED
    
```

`Rebuild.cmd`:

```cmd
@rem 
@rem 
@rem Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
@rem 
@rem The contents of this file are subject to the Mozilla Public License Version
@rem 2.0 (the "License"); you may not use this file except in compliance with
@rem the License. You may obtain a copy of the License at
@rem http://www.mozilla.org/MPL/
@rem 
@rem Software distributed under the License is distributed on an "AS IS" basis,
@rem WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
@rem for the specific language governing rights and limitations under the
@rem License.
@rem 
@rem The Initial Developer of the Original Code is blindtiger.
@rem 
@rem 

@rem set LABS=%~dp0..\
@rem cd /d "%LABS%"
@rem git clone https://github.com/9176324/Shark
@rem git clone https://github.com/9176324/MiniSDK

@set SLND=%~dp0
@if not exist "%SLND%Build\Bins\AMD64" md "%SLND%Build\Bins\AMD64"
@if not exist "%SLND%Build\Bins\I386" md "%SLND%Build\Bins\I386"

@if not exist "%SLND%Build\Objs\Shark" md "%SLND%Build\Objs\Shark"
@if not exist "%SLND%Build\Objs\Sea" md "%SLND%Build\Objs\Sea"

@echo building x86

:CheckOS
@if exist "%PROGRAMFILES(X86)%" (goto x64x86) ELSE (goto x86x86)

:x86x86
@set path=C:\Windows;C:\Windows\System32;%~dp0..\MiniSDK\bin\Hostx86\x86
@goto x86

:x64x86
@set path=C:\Windows;C:\Windows\System32;%~dp0..\MiniSDK\bin\Hostx64\x86
@goto x86

:x86
@cd /d "%SLND%Projects\Shark"
@NMAKE /NOLOGO REBUILD PLATFORM=x86 PROJ=Shark

@cd /d "%SLND%Projects\Sea"
@NMAKE /NOLOGO REBUILD PLATFORM=x86 PROJ=Sea

@cd /d "%SLND%"

@echo building x64

:CheckOS
@if exist "%PROGRAMFILES(X86)%" (goto x64x64) ELSE (goto x86x64)

:x86x64
@set path=C:\Windows;C:\Windows\System32;%~dp0..\MiniSDK\bin\Hostx86\x64
@goto x64

:x64x64
@set path=C:\Windows;C:\Windows\System32;%~dp0..\MiniSDK\bin\Hostx64\x64
@goto x64

:x64
@cd /d "%SLND%Projects\Shark"
@NMAKE /NOLOGO REBUILD PLATFORM=x64 PROJ=Shark

@cd /d "%SLND%Projects\Sea"
@NMAKE /NOLOGO REBUILD PLATFORM=x64 PROJ=Sea

@cd /d "%SLND%"

```

`Shark.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Shark", "Projects\Shark\Shark.vcxproj", "{389A3E87-9607-4515-9937-F2C5BAA1E268}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Include", "Include", "{2655FCA3-FA7E-4E4A-86CE-A8FCE1787952}"
	ProjectSection(SolutionItems) = preProject
		Include\defs.h = Include\defs.h
		Include\devicedefs.h = Include\devicedefs.h
		Include\dump.h = Include\dump.h
		Include\guarddefs.h = Include\guarddefs.h
		Include\listdefs.h = Include\listdefs.h
		Include\statusdefs.h = Include\statusdefs.h
		Include\supdefs.h = Include\supdefs.h
		Include\typesdefs.h = Include\typesdefs.h
		Include\ver.h = Include\ver.h
		Include\WARNING.h = Include\WARNING.h
		Include\wow64.h = Include\wow64.h
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Sea", "Projects\Sea\Sea.vcxproj", "{CFDA5888-9D8D-4EFF-90E6-DA739486E10F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Optimized|x64 = Optimized|x64
		Optimized|x86 = Optimized|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{389A3E87-9607-4515-9937-F2C5BAA1E268}.Optimized|x64.ActiveCfg = Optimized|x64
		{389A3E87-9607-4515-9937-F2C5BAA1E268}.Optimized|x64.Build.0 = Optimized|x64
		{389A3E87-9607-4515-9937-F2C5BAA1E268}.Optimized|x86.ActiveCfg = Optimized|Win32
		{389A3E87-9607-4515-9937-F2C5BAA1E268}.Optimized|x86.Build.0 = Optimized|Win32
		{CFDA5888-9D8D-4EFF-90E6-DA739486E10F}.Optimized|x64.ActiveCfg = Optimized|x64
		{CFDA5888-9D8D-4EFF-90E6-DA739486E10F}.Optimized|x64.Build.0 = Optimized|x64
		{CFDA5888-9D8D-4EFF-90E6-DA739486E10F}.Optimized|x86.ActiveCfg = Optimized|Win32
		{CFDA5888-9D8D-4EFF-90E6-DA739486E10F}.Optimized|x86.Build.0 = Optimized|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`VSBuild.cmd`:

```cmd
@rem 
@rem 
@rem Copyright (c) 2015 - 2021 by blindtiger. All rights reserved.
@rem 
@rem The contents of this file are subject to the Mozilla Public License Version
@rem 2.0 (the "License"); you may not use this file except in compliance with
@rem the License. You may obtain a copy of the License at
@rem http://www.mozilla.org/MPL/
@rem 
@rem Software distributed under the License is distributed on an "AS IS" basis,
@rem WITHOUT WARRANTY OF ANY KIND, either express or implied. SEe the License
@rem for the specific language governing rights and limitations under the
@rem License.
@rem 
@rem The Initial Developer of the Original Code is blindtiger.
@rem 
@rem 

@rem set LABS=%~dp0..\
@rem cd /d "%LABS%"
@rem git clone https://github.com/9176324/Shark
@rem git clone https://github.com/9176324/MiniSDK

@rem MSBuild %~dp0Shark.sln -t:Build /p:Platform="x86"
MSBuild %~dp0Shark.sln -t:Build -p:Platform="x64"

```