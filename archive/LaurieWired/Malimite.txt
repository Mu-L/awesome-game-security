Project Path: arc_LaurieWired_Malimite_ivguf05b

Source Tree:

```txt
arc_LaurieWired_Malimite_ivguf05b
├── Casks
│   └── malimite.rb
├── DecompilerBridge
│   └── ghidra
│       └── DumpClassData.java
├── LICENSE
├── README.md
├── media
│   ├── gatekeeper_allow.png
│   ├── malimite_dependencies.png
│   ├── malimite_features_github.png
│   ├── malimite_gatekeeper.png
│   ├── malimite_ghidra_path.png
│   ├── malimite_logo.png
│   └── malimite_open.png
├── pom.xml
└── src
    └── main
        ├── antlr4
        │   ├── CPP14Lexer.g4
        │   └── CPP14Parser.g4
        ├── java
        │   └── com
        │       └── lauriewired
        │           └── malimite
        │               ├── Malimite.java
        │               ├── configuration
        │               │   ├── Config.java
        │               │   ├── LibraryDefinitions.java
        │               │   └── Project.java
        │               ├── database
        │               │   └── SQLiteDBHandler.java
        │               ├── decompile
        │               │   ├── DemangleSwift.java
        │               │   ├── DynamicDecompile.java
        │               │   ├── GhidraProject.java
        │               │   ├── SyntaxParser.java
        │               │   └── antlr
        │               │       ├── CPP14Lexer.interp
        │               │       ├── CPP14Lexer.java
        │               │       ├── CPP14Lexer.tokens
        │               │       ├── CPP14Parser.interp
        │               │       ├── CPP14Parser.java
        │               │       ├── CPP14Parser.tokens
        │               │       ├── CPP14ParserBase.java
        │               │       ├── CPP14ParserBaseListener.java
        │               │       ├── CPP14ParserBaseVisitor.java
        │               │       ├── CPP14ParserListener.java
        │               │       └── CPP14ParserVisitor.java
        │               ├── files
        │               │   ├── InfoPlist.java
        │               │   ├── Macho.java
        │               │   └── MobileProvision.java
        │               ├── security
        │               │   └── KeyEncryption.java
        │               ├── tools
        │               │   ├── AIBackend.java
        │               │   └── RuntimeMethodHandler.java
        │               ├── ui
        │               │   ├── AnalysisWindow.java
        │               │   ├── ApplicationMenu.java
        │               │   ├── CustomTokenMaker.java
        │               │   ├── EntrypointsDialog.java
        │               │   ├── KeyboardShortcuts.java
        │               │   ├── LibraryConfigDialog.java
        │               │   ├── PreferencesDialog.java
        │               │   ├── ReferenceHandler.java
        │               │   ├── ReferencesDialog.java
        │               │   ├── SafeMenuAction.java
        │               │   ├── SearchResultsDialog.java
        │               │   ├── SelectFile.java
        │               │   ├── SyntaxHighlighter.java
        │               │   └── WrapLayout.java
        │               └── utils
        │                   ├── FileProcessing.java
        │                   ├── GhidraSetup.java
        │                   ├── NodeOperations.java
        │                   ├── PlistUtils.java
        │                   └── ResourceParser.java
        └── resources
            └── icons
                └── app-icon.png

```

`Casks/malimite.rb`:

```rb
cask "malimite" do
  version "1.1"
  sha256 "a74fd75844aedec13b523da6f8faaf9ec0c2a37027c4e372f74294ea07069528"

  url "https://github.com/LaurieWired/Malimite/releases/download/#{version}/Malimite-1-1.zip"
  name "Malimite"
  desc "Decompiler for Apple applications"
  homepage "https://github.com/LaurieWired/Malimite"

  depends_on formula: "java"

  postflight do
    libexec = "#{HOMEBREW_PREFIX}/libexec/malimite"
    bin = "#{HOMEBREW_PREFIX}/bin/malimite"

    FileUtils.mkdir_p libexec
    FileUtils.mv Dir["#{staged_path}/*"], libexec

    File.write(bin, <<~EOS)
      #!/bin/bash
      exec java -jar "#{libexec}/Malimite-1-1.jar" "$@"
    EOS
    FileUtils.chmod("+x", bin)
  end

  uninstall delete: [
    "#{HOMEBREW_PREFIX}/bin/malimite",
    "#{HOMEBREW_PREFIX}/libexec/malimite",
  ]

  zap trash: [
    "~/Library/Application Support/Malimite",
    "~/Library/Caches/Malimite",
    "~/Library/Logs/Malimite",
    "~/Library/Preferences/com.lauriewired.malimite.plist",
    "~/Library/Saved Application State/com.lauriewired.malimite.savedState",
  ]

  caveats <<~EOS
    Ghidra is a recommended dependency for Malimite. You can install it via:
      brew install --cask ghidra
  EOS
end

```

`DecompilerBridge/ghidra/DumpClassData.java`:

```java
import ghidra.app.decompiler.DecompInterface;
import ghidra.app.script.GhidraScript;
import ghidra.program.model.symbol.Namespace;
import ghidra.program.model.mem.Memory;
import ghidra.program.model.mem.MemoryBlock;
import ghidra.program.model.address.Address;
import ghidra.util.task.ConsoleTaskMonitor;
import ghidra.program.model.listing.*;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.StringDataType;

import java.io.IOException;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.*;
import org.json.JSONObject;
import org.json.JSONArray;

public class DumpClassData extends GhidraScript {

    private int port;
    private List<String> libraryPrefixes;

    private void parseArgs() {
        String[] args = getScriptArgs();
        if (args.length < 2) {
            println("Insufficient arguments. Expected: <port> <libraries>");
            return;
        }
        this.port = Integer.parseInt(args[0]);
        // Parse libraries from comma-separated string
        this.libraryPrefixes = Arrays.asList(args[1].split(","));
    }

    private boolean isLibraryNamespace(String namespace) {
        return libraryPrefixes.stream()
            .anyMatch(prefix -> namespace.startsWith(prefix));
    }

    private int getPort() {
        String[] args = getScriptArgs();
        if (args.length > 0) {
            return Integer.parseInt(args[0]);
        }
        println("No port provided. Exiting script.");
        return -1;
    }

    private String formatNamespaceName(String namespaceName) {
        if ("<global>".equals(namespaceName)) {
            return "Global";
        } else if ("<EXTERNAL>".equals(namespaceName)) {
            return "External";
        }
        return namespaceName;
    }

    private JSONArray extractClassFunctionData(Program program) {
        FunctionManager functionManager = program.getFunctionManager();
        List<JSONObject> classFunctionData = new ArrayList<>();

        Map<String, List<String>> namespaceFunctionData = new HashMap<>();

        for (Function function : functionManager.getFunctions(true)) {
            Namespace namespace = function.getParentNamespace();
            String namespaceName = formatNamespaceName(namespace != null ? namespace.getName() : "<global>");

            namespaceFunctionData.computeIfAbsent(namespaceName, k -> new ArrayList<>()).add(function.getName());
        }

        for (Map.Entry<String, List<String>> entry : namespaceFunctionData.entrySet()) {
            JSONObject classObject = new JSONObject();
            classObject.put("ClassName", entry.getKey());
            classObject.put("Functions", new JSONArray(entry.getValue()));
            classFunctionData.add(classObject);
        }

        return new JSONArray(classFunctionData);
    }

    private JSONObject listDefinedDataInAllSegments(Program program) {
        Memory memory = program.getMemory();
        Listing listing = program.getListing();
        Map<String, JSONObject> dataStructure = new HashMap<>();

        for (MemoryBlock block : memory.getBlocks()) {
            Address start = block.getStart();
            Address end = block.getEnd();
            String name = block.getName();

            JSONObject segmentData = new JSONObject();
            segmentData.put("start", start.toString());
            segmentData.put("end", end.toString());
            JSONArray dataArray = new JSONArray();

            DataIterator dataIterator = listing.getDefinedData(start, true);
            while (dataIterator.hasNext()) {
                Data data = dataIterator.next();
                if (!block.contains(data.getAddress())) {
                    continue;
                }

                String label = data.getLabel();
                String value = data.getDefaultValueRepresentation();
                String address = data.getAddress().toString();

                JSONObject dataEntry = new JSONObject();
                dataEntry.put("label", label != null ? label : "Unnamed");
                dataEntry.put("value", value);
                dataEntry.put("address", address);
                dataArray.put(dataEntry);
            }

            segmentData.put("data", dataArray);
            dataStructure.put(name, segmentData);
        }

        return new JSONObject(dataStructure);
    }

    private JSONArray listFunctionsAndNamespaces(Program program) {
        DecompInterface decompInterface = new DecompInterface();
        FunctionManager functionManager = program.getFunctionManager();
        Map<String, List<Function>> namespaceFunctionsMap = new HashMap<>();
        JSONArray jsonOutput = new JSONArray();

        decompInterface.openProgram(program);

        // Collect functions for each namespace
        for (Function function : functionManager.getFunctions(true)) {
            Namespace namespace = function.getParentNamespace();
            String namespaceName = formatNamespaceName(namespace != null ? namespace.getName() : "<global>");
            
            // Skip decompilation if namespace is a library
            if (isLibraryNamespace(namespaceName)) {
                // Add basic function info without decompilation
                JSONObject jsonEntry = new JSONObject();
                jsonEntry.put("FunctionName", function.getName());
                jsonEntry.put("ClassName", namespaceName);
                jsonEntry.put("DecompiledCode", ""); // Empty string for library functions
                jsonOutput.put(jsonEntry);
                continue;
            }

            // Add function to namespace map for non-library functions
            namespaceFunctionsMap.computeIfAbsent(namespaceName, k -> new ArrayList<>()).add(function);
        }

        // Decompile non-library functions
        for (Map.Entry<String, List<Function>> entry : namespaceFunctionsMap.entrySet()) {
            String namespace = entry.getKey();
            List<Function> functions = entry.getValue();

            for (Function function : functions) {
                var decompiledFunction = decompInterface.decompileFunction(function, 0, new ConsoleTaskMonitor());
                if (decompiledFunction.decompileCompleted()) {
                    String decompiledCode = decompiledFunction.getDecompiledFunction().getC();

                    JSONObject jsonEntry = new JSONObject();
                    jsonEntry.put("FunctionName", function.getName());
                    jsonEntry.put("ClassName", namespace);
                    jsonEntry.put("DecompiledCode", decompiledCode);
                    jsonOutput.put(jsonEntry);
                }
            }
        }

        decompInterface.dispose();
        return jsonOutput;
    }

    private JSONArray extractStrings(Program program) {
        Memory memory = program.getMemory();
        Listing listing = program.getListing();
        JSONArray stringsArray = new JSONArray();
        
        for (MemoryBlock block : memory.getBlocks()) {
            if (!block.isInitialized()) continue;
            
            DataIterator dataIterator = listing.getDefinedData(block.getStart(), true);
            while (dataIterator.hasNext()) {
                Data data = dataIterator.next();
                if (!block.contains(data.getAddress())) continue;
                
                // Check if the data type is a string
                DataType dataType = data.getDataType();
                if (dataType instanceof StringDataType) {
                    String value = data.getDefaultValueRepresentation(); // Retrieves the string value
                    // Only include strings of length 5 or more
                    if (value.length() >= 5) {
                        JSONObject stringObj = new JSONObject();
                        stringObj.put("address", data.getAddress().toString());
                        stringObj.put("value", value);
                        stringObj.put("segment", block.getName());
                        stringObj.put("label", data.getLabel() != null ? data.getLabel() : "");
                        stringsArray.put(stringObj);
                    }
                }
            }
        }
        return stringsArray;
    }

    private void sendDataViaSocket(JSONArray classData, JSONObject machoData, JSONArray functionData) {
        int port = getPort();
        if (port == -1) return;

        try (Socket socket = new Socket("localhost", port);
             PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {
            
            out.println("CONNECTED");
            println("Beginning analysis...");
            
            // Send class data
            out.println(classData.toString(4));
            out.println("END_CLASS_DATA");

            // Send Macho data
            out.println(machoData.toString(4));
            out.println("END_MACHO_DATA");

            // Send function decompilation data
            out.println(functionData.toString(4));
            out.println("END_DATA");

            // Send string data
            JSONArray stringData = extractStrings(currentProgram);
            out.println(stringData.toString(4));
            out.println("END_STRING_DATA");

        } catch (IOException e) {
            printerr("Error sending data via socket: " + e.getMessage());
        }
    }

    @Override
    public void run() throws Exception {
        System.err.println("Running DumpCombinedData script");
        parseArgs();
        
        if (port == -1) {
            return;
        }

        // Perform heartbeat check first
        try (Socket heartbeatSocket = new Socket("localhost", port);
             PrintWriter heartbeatOut = new PrintWriter(heartbeatSocket.getOutputStream(), true)) {
            
            heartbeatOut.println("HEARTBEAT");
            println("Heartbeat sent successfully, proceeding with analysis...");
        } catch (IOException e) {
            printerr("Failed to establish initial connection: " + e.getMessage());
            return;
        }

        // Continue with analysis after successful heartbeat
        JSONArray classData = extractClassFunctionData(currentProgram);
        JSONObject machoData = listDefinedDataInAllSegments(currentProgram);
        JSONArray functionData = listFunctionsAndNamespaces(currentProgram);

        sendDataViaSocket(classData, machoData, functionData);
    }
}

```

`LICENSE`:

```

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
```

`README.md`:

```md
![Malimite logo](https://github.com/LaurieWired/Malimite/blob/main/media/malimite_logo.png)
[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://www.apache.org/licenses/LICENSE-2.0)
[![GitHub release (latest by date)](https://img.shields.io/github/v/release/LaurieWired/Malimite)](https://github.com/LaurieWired/Malimite/releases)
[![GitHub stars](https://img.shields.io/github/stars/LaurieWired/Malimite)](https://github.com/LaurieWired/Malimite/stargazers)
[![GitHub forks](https://img.shields.io/github/forks/LaurieWired/Malimite)](https://github.com/LaurieWired/Malimite/network/members)
[![GitHub contributors](https://img.shields.io/github/contributors/LaurieWired/Malimite)](https://github.com/LaurieWired/Malimite/graphs/contributors)
[![Follow @lauriewired](https://img.shields.io/twitter/follow/lauriewired?style=social)](https://twitter.com/lauriewired)

# Description

Malimite is an iOS and macOS decompiler designed to help researchers analyze and decode IPA files and Application Bundles.

Built on top of Ghidra decompilation to offer direct support for Swift, Objective-C, and Apple resources.


![Malimite Features](https://github.com/LaurieWired/Malimite/blob/main/media/malimite_features_github.png)


# Features
- Multi-Platform
  - Mac, Windows, Linux
- Direct support for IPA and bundle files
- Auto decodes iOS resources
- Avoids lib code decompilation
- Reconstructs Swift classes
- **Built-in LLM method translation**


# Installation

A precompiled JAR file is provided in the [Releases Page](https://github.com/LaurieWired/Malimite/releases/)

For full Installation steps consult the Wiki.

# Usage + Prequisites

### Check out the **[Wiki](https://github.com/LaurieWired/Malimite/wiki)** for more details.


# Contribute
- Make a pull request
- Add an Example to our Wiki
- Report an error/issue
- Suggest an improvement
- Share with others or give a star!

Your contributions are greatly appreciated and will help make Malimite an even more powerful and versatile tool for the iOS and macOS Reverse Engineering community.

# License

Malimite is licensed under the Apache 2.0 License. See the [LICENSE](https://www.apache.org/licenses/LICENSE-2.0) file for more information.

```

`pom.xml`:

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.lauriewired.malimite</groupId>
  <artifactId>malimite</artifactId>
  <packaging>jar</packaging>
  <version>1.0-SNAPSHOT</version>
  <name>malimite</name>
  <url>http://maven.apache.org</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>11</maven.compiler.source>
    <maven.compiler.target>11</maven.compiler.target>
  </properties>
  
  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>3.8.1</version>
      <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>com.googlecode.plist</groupId>
        <artifactId>dd-plist</artifactId>
        <version>1.27</version>
    </dependency>
    <dependency>
      <groupId>com.google.code.gson</groupId>
      <artifactId>gson</artifactId>
      <version>2.10.1</version>
    </dependency>
    <dependency>
        <groupId>org.xerial</groupId>
        <artifactId>sqlite-jdbc</artifactId>
        <version>3.44.1.0</version>
    </dependency>
    <dependency>
        <groupId>org.json</groupId>
        <artifactId>json</artifactId>
        <version>20231013</version>
    </dependency>
    <dependency>
        <groupId>org.antlr</groupId>
        <artifactId>antlr4-runtime</artifactId>
        <version>4.13.1</version>
    </dependency>
    <dependency>
        <groupId>com.fifesoft</groupId>
        <artifactId>rsyntaxtextarea</artifactId>
        <version>3.4.0</version>
    </dependency>
    <dependency>
      <groupId>com.formdev</groupId>
      <artifactId>flatlaf</artifactId>
      <version>3.5.2</version>
    </dependency>
    <dependency>
      <groupId>org.bouncycastle</groupId>
      <artifactId>bcprov-jdk15on</artifactId>
      <version>1.70</version>
    </dependency>
    <dependency>
      <groupId>org.bouncycastle</groupId>
      <artifactId>bcpkix-jdk15on</artifactId>
      <version>1.70</version>
    </dependency>
    <dependency>
      <groupId>com.vladsch.flexmark</groupId>
      <artifactId>flexmark-all</artifactId>
      <version>0.64.8</version>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <!-- ANTLR Plugin -->
      <plugin>
        <groupId>org.antlr</groupId>
        <artifactId>antlr4-maven-plugin</artifactId>
        <version>4.13.1</version>
        <executions>
          <execution>
            <id>antlr</id>
            <phase>generate-sources</phase>
            <goals>
              <goal>antlr4</goal>
            </goals>
            <configuration>
              <sourceDirectory>src/main/antlr4</sourceDirectory>
              <outputDirectory>src/main/java/com/lauriewired/malimite/decompile/antlr</outputDirectory>
              <arguments>
                <argument>-package</argument>
                <argument>com.lauriewired.malimite.decompile.antlr</argument>
                <argument>-visitor</argument>
              </arguments>
            </configuration>
          </execution>
        </executions>
      </plugin>

      <!-- Build Helper Plugin -->
      <plugin>
        <groupId>org.codehaus.mojo</groupId>
        <artifactId>build-helper-maven-plugin</artifactId>
        <version>3.3.0</version>
        <executions>
          <execution>
            <id>add-source</id>
            <phase>generate-sources</phase>
            <goals>
              <goal>add-source</goal>
            </goals>
            <configuration>
              <sources>
                <source>src/main/java/com/lauriewired/malimite/decompile/antlr</source>
              </sources>
            </configuration>
          </execution>
        </executions>
      </plugin>

      <!-- Compiler Plugin -->
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.13.0</version>
        <configuration>
          <source>11</source>
          <target>11</target>
          <release>11</release>
        </configuration>
      </plugin>

      <!-- Shade Plugin -->
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-shade-plugin</artifactId>
  <version>3.5.0</version>
  <executions>
    <execution>
      <phase>package</phase>
      <goals>
        <goal>shade</goal>
      </goals>
      <configuration>
        <filters>
          <filter>
            <artifact>*:*</artifact>
            <!-- Exclude signature files -->
            <excludes>
              <exclude>META-INF/*.SF</exclude>
              <exclude>META-INF/*.DSA</exclude>
              <exclude>META-INF/*.RSA</exclude>
            </excludes>
          </filter>
        </filters>
        <transformers>
          <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
            <mainClass>com.lauriewired.malimite.Malimite</mainClass>
          </transformer>
        </transformers>
      </configuration>
    </execution>
        </executions>
      </plugin>
    </plugins>
    <resources>
      <resource>
        <directory>src/main/resources</directory>
        <includes>
          <include>**/*</include>
        </includes>
      </resource>
    </resources>
  </build>
</project>

```

`src/main/antlr4/CPP14Lexer.g4`:

```g4
// $antlr-format alignTrailingComments true, columnLimit 150, maxEmptyLinesToKeep 1, reflowComments false, useTab false
// $antlr-format allowShortRulesOnASingleLine true, allowShortBlocksOnASingleLine true, minEmptyLines 0, alignSemicolons ownLine
// $antlr-format alignColons trailing, singleLineOverrulesHangingColon true, alignLexerCommands true, alignLabels true, alignTrailers true

lexer grammar CPP14Lexer;

IntegerLiteral:
    DecimalLiteral Integersuffix?
    | OctalLiteral Integersuffix?
    | HexadecimalLiteral Integersuffix?
    | BinaryLiteral Integersuffix?
;

CharacterLiteral: ('u' | 'U' | 'L')? '\'' Cchar+ '\'';

FloatingLiteral:
    Fractionalconstant Exponentpart? Floatingsuffix?
    | Digitsequence Exponentpart Floatingsuffix?
;

StringLiteral: Encodingprefix? (Rawstring | '"' Schar* '"');

BooleanLiteral: False_ | True_;

PointerLiteral: Nullptr;

UserDefinedLiteral:
    UserDefinedIntegerLiteral
    | UserDefinedFloatingLiteral
    | UserDefinedStringLiteral
    | UserDefinedCharacterLiteral
;

MultiLineMacro: '#' (~[\n]*? '\\' '\r'? '\n')+ ~ [\n]+ -> channel (HIDDEN);

Directive: '#' ~ [\n]* -> channel (HIDDEN);
/*Keywords*/

Alignas: 'alignas';

Alignof: 'alignof';

Asm: 'asm';

Auto: 'auto';

Bool: 'bool';

Break: 'break';

Case: 'case';

Catch: 'catch';

Char: 'char';

Char16: 'char16_t';

Char32: 'char32_t';

Class: 'class';

Const: 'const';

Constexpr: 'constexpr';

Const_cast: 'const_cast';

Continue: 'continue';

Decltype: 'decltype';

Default: 'default';

Delete: 'delete';

Do: 'do';

Double: 'double';

Dynamic_cast: 'dynamic_cast';

Else: 'else';

Enum: 'enum';

Explicit: 'explicit';

Export: 'export';

Extern: 'extern';

//DO NOT RENAME - PYTHON NEEDS True and False
False_: 'false';

Final: 'final';

Float: 'float';

For: 'for';

Friend: 'friend';

Goto: 'goto';

If: 'if';

Inline: 'inline';

Int: 'int';

Long: 'long';

Mutable: 'mutable';

Namespace: 'namespace';

New: 'new';

Noexcept: 'noexcept';

Nullptr: 'nullptr';

Operator: 'operator';

Override: 'override';

Private: 'private';

Protected: 'protected';

Public: 'public';

Register: 'register';

Reinterpret_cast: 'reinterpret_cast';

Return: 'return';

Short: 'short';

Signed: 'signed';

Sizeof: 'sizeof';

Static: 'static';

Static_assert: 'static_assert';

Static_cast: 'static_cast';

Struct: 'struct';

Switch: 'switch';

Template: 'template';

This: 'this';

Thread_local: 'thread_local';

Throw: 'throw';

//DO NOT RENAME - PYTHON NEEDS True and False
True_: 'true';

Try: 'try';

Typedef: 'typedef';

Typeid_: 'typeid';

Typename_: 'typename';

Union: 'union';

Unsigned: 'unsigned';

Using: 'using';

Virtual: 'virtual';

Void: 'void';

Volatile: 'volatile';

Wchar: 'wchar_t';

While: 'while';
/*Operators*/

LeftParen: '(';

RightParen: ')';

LeftBracket: '[';

RightBracket: ']';

LeftBrace: '{';

RightBrace: '}';

Plus: '+';

Minus: '-';

Star: '*';

Div: '/';

Mod: '%';

Caret: '^';

And: '&';

Or: '|';

Tilde: '~';

Not: '!' | 'not';

Assign: '=';

Less: '<';

Greater: '>';

PlusAssign: '+=';

MinusAssign: '-=';

StarAssign: '*=';

DivAssign: '/=';

ModAssign: '%=';

XorAssign: '^=';

AndAssign: '&=';

OrAssign: '|=';

LeftShiftAssign: '<<=';

RightShiftAssign: '>>=';

Equal: '==';

NotEqual: '!=';

LessEqual: '<=';

GreaterEqual: '>=';

AndAnd: '&&' | 'and';

OrOr: '||' | 'or';

PlusPlus: '++';

MinusMinus: '--';

Comma: ',';

ArrowStar: '->*';

Arrow: '->';

Question: '?';

Colon: ':';

Doublecolon: '::';

Semi: ';';

Dot: '.';

DotStar: '.*';

Ellipsis: '...';

fragment Hexquad: HEXADECIMALDIGIT HEXADECIMALDIGIT HEXADECIMALDIGIT HEXADECIMALDIGIT;

fragment Universalcharactername: '\\u' Hexquad | '\\U' Hexquad Hexquad;

Identifier:
    /*
	 Identifiernondigit | Identifier Identifiernondigit | Identifier DIGIT
	 */ Identifiernondigit (Identifiernondigit | DIGIT)*
;

fragment Identifiernondigit: NONDIGIT | Universalcharactername;

fragment NONDIGIT: [a-zA-Z_];

fragment DIGIT: [0-9];

DecimalLiteral: NONZERODIGIT ('\''? DIGIT)*;

OctalLiteral: '0' ('\''? OCTALDIGIT)*;

HexadecimalLiteral: ('0x' | '0X') HEXADECIMALDIGIT ( '\''? HEXADECIMALDIGIT)*;

BinaryLiteral: ('0b' | '0B') BINARYDIGIT ('\''? BINARYDIGIT)*;

fragment NONZERODIGIT: [1-9];

fragment OCTALDIGIT: [0-7];

fragment HEXADECIMALDIGIT: [0-9a-fA-F];

fragment BINARYDIGIT: [01];

Integersuffix:
    Unsignedsuffix Longsuffix?
    | Unsignedsuffix Longlongsuffix?
    | Longsuffix Unsignedsuffix?
    | Longlongsuffix Unsignedsuffix?
;

fragment Unsignedsuffix: [uU];

fragment Longsuffix: [lL];

fragment Longlongsuffix: 'll' | 'LL';

fragment Cchar: ~ ['\\\r\n] | Escapesequence | Universalcharactername;

fragment Escapesequence: Simpleescapesequence | Octalescapesequence | Hexadecimalescapesequence;

fragment Simpleescapesequence:
    '\\\''
    | '\\"'
    | '\\?'
    | '\\\\'
    | '\\a'
    | '\\b'
    | '\\f'
    | '\\n'
    | '\\r'
    | '\\' ('\r' '\n'? | '\n')
    | '\\t'
    | '\\v'
;

fragment Octalescapesequence:
    '\\' OCTALDIGIT
    | '\\' OCTALDIGIT OCTALDIGIT
    | '\\' OCTALDIGIT OCTALDIGIT OCTALDIGIT
;

fragment Hexadecimalescapesequence: '\\x' HEXADECIMALDIGIT+;

fragment Fractionalconstant: Digitsequence? '.' Digitsequence | Digitsequence '.';

fragment Exponentpart: 'e' SIGN? Digitsequence | 'E' SIGN? Digitsequence;

fragment SIGN: [+-];

fragment Digitsequence: DIGIT ('\''? DIGIT)*;

fragment Floatingsuffix: [flFL];

fragment Encodingprefix: 'u8' | 'u' | 'U' | 'L';

fragment Schar: ~ ["\\\r\n] | Escapesequence | Universalcharactername;

fragment Rawstring: 'R"' ( '\\' ["()] | ~[\r\n (])*? '(' ~[)]*? ')' ( '\\' ["()] | ~[\r\n "])*? '"';

UserDefinedIntegerLiteral:
    DecimalLiteral Udsuffix
    | OctalLiteral Udsuffix
    | HexadecimalLiteral Udsuffix
    | BinaryLiteral Udsuffix
;

UserDefinedFloatingLiteral:
    Fractionalconstant Exponentpart? Udsuffix
    | Digitsequence Exponentpart Udsuffix
;

UserDefinedStringLiteral: StringLiteral Udsuffix;

UserDefinedCharacterLiteral: CharacterLiteral Udsuffix;

fragment Udsuffix: Identifier;

Whitespace: [ \t]+ -> skip;

Newline: ('\r' '\n'? | '\n') -> skip;

BlockComment: '/*' .*? '*/' -> skip;

LineComment: '//' ~ [\r\n]* -> skip;
```

`src/main/antlr4/CPP14Parser.g4`:

```g4
/*******************************************************************************
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Camilo Sanchez (Camiloasc1) 2020 Martin Mirchev (Marti2203)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
 * NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ****************************************************************************
 */

// $antlr-format alignTrailingComments true, columnLimit 150, minEmptyLines 1, maxEmptyLinesToKeep 1, reflowComments false, useTab false
// $antlr-format allowShortRulesOnASingleLine false, allowShortBlocksOnASingleLine true, alignSemicolons hanging, alignColons hanging

parser grammar CPP14Parser;

options {
    superClass = CPP14ParserBase;
    tokenVocab = CPP14Lexer;
}

// Insert here @header for C++ parser.

/*Basic concepts*/

translationUnit
    : declarationseq? EOF
    ;

/*Expressions*/

primaryExpression
    : literal+
    | This
    | LeftParen expression RightParen
    | idExpression
    | lambdaExpression
    ;

idExpression
    : unqualifiedId
    | qualifiedId
    ;

unqualifiedId
    : Identifier
    | operatorFunctionId
    | conversionFunctionId
    | literalOperatorId
    | Tilde (className | decltypeSpecifier)
    | templateId
    ;

qualifiedId
    : nestedNameSpecifier Template? unqualifiedId
    ;

nestedNameSpecifier
    : (theTypeName | namespaceName | decltypeSpecifier)? Doublecolon
    | nestedNameSpecifier ( Identifier | Template? simpleTemplateId) Doublecolon
    ;

lambdaExpression
    : lambdaIntroducer lambdaDeclarator? compoundStatement
    ;

lambdaIntroducer
    : LeftBracket lambdaCapture? RightBracket
    ;

lambdaCapture
    : captureList
    | captureDefault (Comma captureList)?
    ;

captureDefault
    : And
    | Assign
    ;

captureList
    : capture (Comma capture)* Ellipsis?
    ;

capture
    : simpleCapture
    | initcapture
    ;

simpleCapture
    : And? Identifier
    | This
    ;

initcapture
    : And? Identifier initializer
    ;

lambdaDeclarator
    : LeftParen parameterDeclarationClause? RightParen Mutable? exceptionSpecification? attributeSpecifierSeq? trailingReturnType?
    ;

postfixExpression
    : primaryExpression
    | postfixExpression LeftBracket (expression | bracedInitList) RightBracket
    | postfixExpression LeftParen expressionList? RightParen
    | (simpleTypeSpecifier | typeNameSpecifier) (
        LeftParen expressionList? RightParen
        | bracedInitList
    )
    | postfixExpression (Dot | Arrow) (Template? idExpression | pseudoDestructorName)
    | postfixExpression (PlusPlus | MinusMinus)
    | (Dynamic_cast | Static_cast | Reinterpret_cast | Const_cast) Less theTypeId Greater LeftParen expression RightParen
    | typeIdOfTheTypeId LeftParen (expression | theTypeId) RightParen
    ;

/*
 add a middle layer to eliminate duplicated function declarations
 */

typeIdOfTheTypeId
    : Typeid_
    ;

expressionList
    : initializerList
    ;

pseudoDestructorName
    : nestedNameSpecifier? (theTypeName Doublecolon)? Tilde theTypeName
    | nestedNameSpecifier Template simpleTemplateId Doublecolon Tilde theTypeName
    | Tilde decltypeSpecifier
    ;

unaryExpression
    : postfixExpression
    | (PlusPlus | MinusMinus | unaryOperator | Sizeof) unaryExpression
    | Sizeof (LeftParen theTypeId RightParen | Ellipsis LeftParen Identifier RightParen)
    | Alignof LeftParen theTypeId RightParen
    | noExceptExpression
    | newExpression_
    | deleteExpression
    ;

unaryOperator
    : Or
    | Star
    | And
    | Plus
    | Tilde
    | Minus
    | Not
    ;

newExpression_
    : Doublecolon? New newPlacement? (newTypeId | LeftParen theTypeId RightParen) newInitializer_?
    ;

newPlacement
    : LeftParen expressionList RightParen
    ;

newTypeId
    : typeSpecifierSeq newDeclarator_?
    ;

newDeclarator_
    : pointerOperator newDeclarator_?
    | noPointerNewDeclarator
    ;

noPointerNewDeclarator
    : LeftBracket expression RightBracket attributeSpecifierSeq?
    | noPointerNewDeclarator LeftBracket constantExpression RightBracket attributeSpecifierSeq?
    ;

newInitializer_
    : LeftParen expressionList? RightParen
    | bracedInitList
    ;

deleteExpression
    : Doublecolon? Delete (LeftBracket RightBracket)? castExpression
    ;

noExceptExpression
    : Noexcept LeftParen expression RightParen
    ;

castExpression
    : unaryExpression
    | LeftParen theTypeId RightParen castExpression
    ;

pointerMemberExpression
    : castExpression ((DotStar | ArrowStar) castExpression)*
    ;

multiplicativeExpression
    : pointerMemberExpression ((Star | Div | Mod) pointerMemberExpression)*
    ;

additiveExpression
    : multiplicativeExpression ((Plus | Minus) multiplicativeExpression)*
    ;

shiftExpression
    : additiveExpression (shiftOperator additiveExpression)*
    ;

shiftOperator
    : Greater Greater
    | Less Less
    ;

relationalExpression
    : shiftExpression ((Less | Greater | LessEqual | GreaterEqual) shiftExpression)*
    ;

equalityExpression
    : relationalExpression ((Equal | NotEqual) relationalExpression)*
    ;

andExpression
    : equalityExpression (And equalityExpression)*
    ;

exclusiveOrExpression
    : andExpression (Caret andExpression)*
    ;

inclusiveOrExpression
    : exclusiveOrExpression (Or exclusiveOrExpression)*
    ;

logicalAndExpression
    : inclusiveOrExpression (AndAnd inclusiveOrExpression)*
    ;

logicalOrExpression
    : logicalAndExpression (OrOr logicalAndExpression)*
    ;

conditionalExpression
    : logicalOrExpression (Question expression Colon assignmentExpression)?
    ;

assignmentExpression
    : conditionalExpression
    | logicalOrExpression assignmentOperator initializerClause
    | throwExpression
    ;

assignmentOperator
    : Assign
    | StarAssign
    | DivAssign
    | ModAssign
    | PlusAssign
    | MinusAssign
    | RightShiftAssign
    | LeftShiftAssign
    | AndAssign
    | XorAssign
    | OrAssign
    ;

expression
    : assignmentExpression (Comma assignmentExpression)*
    ;

constantExpression
    : conditionalExpression
    ;

/*Statements*/

statement
    : labeledStatement
    | declarationStatement
    | attributeSpecifierSeq? (
        expressionStatement
        | compoundStatement
        | selectionStatement
        | iterationStatement
        | jumpStatement
        | tryBlock
    )
    ;

labeledStatement
    : attributeSpecifierSeq? (Identifier | Case constantExpression | Default) Colon statement
    ;

expressionStatement
    : expression? Semi
    ;

compoundStatement
    : LeftBrace statementSeq? RightBrace
    ;

statementSeq
    : statement+
    ;

selectionStatement
    : If LeftParen condition RightParen statement (Else statement)?
    | Switch LeftParen condition RightParen statement
    ;

condition
    : expression
    | attributeSpecifierSeq? declSpecifierSeq declarator (
        Assign initializerClause
        | bracedInitList
    )
    ;

iterationStatement
    : While LeftParen condition RightParen statement
    | Do statement While LeftParen expression RightParen Semi
    | For LeftParen (
        forInitStatement condition? Semi expression?
        | forRangeDeclaration Colon forRangeInitializer
    ) RightParen statement
    ;

forInitStatement
    : expressionStatement
    | simpleDeclaration
    ;

forRangeDeclaration
    : attributeSpecifierSeq? declSpecifierSeq declarator
    ;

forRangeInitializer
    : expression
    | bracedInitList
    ;

jumpStatement
    : (Break | Continue | Return (expression | bracedInitList)? | Goto Identifier) Semi
    ;

declarationStatement
    : blockDeclaration
    ;

/*Declarations*/

declarationseq
    : declaration+
    ;

declaration
    : blockDeclaration
    | functionDefinition
    | templateDeclaration
    | explicitInstantiation
    | explicitSpecialization
    | linkageSpecification
    | namespaceDefinition
    | emptyDeclaration_
    | attributeDeclaration
    ;

blockDeclaration
    : simpleDeclaration
    | asmDefinition
    | namespaceAliasDefinition
    | usingDeclaration
    | usingDirective
    | staticAssertDeclaration
    | aliasDeclaration
    | opaqueEnumDeclaration
    ;

aliasDeclaration
    : Using Identifier attributeSpecifierSeq? Assign theTypeId Semi
    ;

simpleDeclaration
    : declSpecifierSeq? initDeclaratorList? Semi
    | attributeSpecifierSeq declSpecifierSeq? initDeclaratorList Semi
    ;

staticAssertDeclaration
    : Static_assert LeftParen constantExpression Comma StringLiteral RightParen Semi
    ;

emptyDeclaration_
    : Semi
    ;

attributeDeclaration
    : attributeSpecifierSeq Semi
    ;

declSpecifier
    : storageClassSpecifier
    | typeSpecifier
    | functionSpecifier
    | Friend
    | Typedef
    | Constexpr
    ;

declSpecifierSeq
    : declSpecifier+? attributeSpecifierSeq?
    ;

storageClassSpecifier
    : Register
    | Static
    | Thread_local
    | Extern
    | Mutable
    ;

functionSpecifier
    : Inline
    | Virtual
    | Explicit
    ;

typedefName
    : Identifier
    ;

typeSpecifier
    : trailingTypeSpecifier
    | classSpecifier
    | enumSpecifier
    ;

trailingTypeSpecifier
    : simpleTypeSpecifier
    | elaboratedTypeSpecifier
    | typeNameSpecifier
    | cvQualifier
    ;

typeSpecifierSeq
    : typeSpecifier+ attributeSpecifierSeq?
    ;

trailingTypeSpecifierSeq
    : trailingTypeSpecifier+ attributeSpecifierSeq?
    ;

simpleTypeLengthModifier
    : Short
    | Long
    ;

simpleTypeSignednessModifier
    : Unsigned
    | Signed
    ;

simpleTypeSpecifier
    : nestedNameSpecifier? theTypeName
    | nestedNameSpecifier Template simpleTemplateId
    | Char
    | Char16
    | Char32
    | Wchar
    | Bool
    | Short
    | Int
    | Long
    | Float
    | Signed
    | Unsigned
    | Float
    | Double
    | Void
    | Auto
    | decltypeSpecifier
    ;

theTypeName
    : className
    | enumName
    | typedefName
    | simpleTemplateId
    ;

decltypeSpecifier
    : Decltype LeftParen (expression | Auto) RightParen
    ;

elaboratedTypeSpecifier
    : classKey (
        attributeSpecifierSeq? nestedNameSpecifier? Identifier
        | simpleTemplateId
        | nestedNameSpecifier Template? simpleTemplateId
    )
    | Enum nestedNameSpecifier? Identifier
    ;

enumName
    : Identifier
    ;

enumSpecifier
    : enumHead LeftBrace (enumeratorList Comma?)? RightBrace
    ;

enumHead
    : enumkey attributeSpecifierSeq? (nestedNameSpecifier? Identifier)? enumbase?
    ;

opaqueEnumDeclaration
    : enumkey attributeSpecifierSeq? Identifier enumbase? Semi
    ;

enumkey
    : Enum (Class | Struct)?
    ;

enumbase
    : Colon typeSpecifierSeq
    ;

enumeratorList
    : enumeratorDefinition (Comma enumeratorDefinition)*
    ;

enumeratorDefinition
    : enumerator (Assign constantExpression)?
    ;

enumerator
    : Identifier
    ;

namespaceName
    : originalNamespaceName
    | namespaceAlias
    ;

originalNamespaceName
    : Identifier
    ;

namespaceDefinition
    : Inline? Namespace (Identifier | originalNamespaceName)? LeftBrace namespaceBody = declarationseq? RightBrace
    ;

namespaceAlias
    : Identifier
    ;

namespaceAliasDefinition
    : Namespace Identifier Assign qualifiednamespacespecifier Semi
    ;

qualifiednamespacespecifier
    : nestedNameSpecifier? namespaceName
    ;

usingDeclaration
    : Using (Typename_? nestedNameSpecifier | Doublecolon) unqualifiedId Semi
    ;

usingDirective
    : attributeSpecifierSeq? Using Namespace nestedNameSpecifier? namespaceName Semi
    ;

asmDefinition
    : Asm LeftParen StringLiteral RightParen Semi
    ;

linkageSpecification
    : Extern StringLiteral (LeftBrace declarationseq? RightBrace | declaration)
    ;

attributeSpecifierSeq
    : attributeSpecifier+
    ;

attributeSpecifier
    : LeftBracket LeftBracket attributeList? RightBracket RightBracket
    | alignmentspecifier
    ;

alignmentspecifier
    : Alignas LeftParen (theTypeId | constantExpression) Ellipsis? RightParen
    ;

attributeList
    : attribute (Comma attribute)* Ellipsis?
    ;

attribute
    : (attributeNamespace Doublecolon)? Identifier attributeArgumentClause?
    ;

attributeNamespace
    : Identifier
    ;

attributeArgumentClause
    : LeftParen balancedTokenSeq? RightParen
    ;

balancedTokenSeq
    : balancedtoken+
    ;

balancedtoken
    : LeftParen balancedTokenSeq RightParen
    | LeftBracket balancedTokenSeq RightBracket
    | LeftBrace balancedTokenSeq RightBrace
    | ~(LeftParen | RightParen | LeftBrace | RightBrace | LeftBracket | RightBracket)+
    ;

/*Declarators*/

initDeclaratorList
    : initDeclarator (Comma initDeclarator)*
    ;

initDeclarator
    : declarator initializer?
    ;

declarator
    : pointerDeclarator
    | noPointerDeclarator parametersAndQualifiers trailingReturnType
    ;

pointerDeclarator
    : (pointerOperator Const?)* noPointerDeclarator
    ;

noPointerDeclarator
    : declaratorid attributeSpecifierSeq?
    | noPointerDeclarator (
        parametersAndQualifiers
        | LeftBracket constantExpression? RightBracket attributeSpecifierSeq?
    )
    | LeftParen pointerDeclarator RightParen
    ;

parametersAndQualifiers
    : LeftParen parameterDeclarationClause? RightParen cvqualifierseq? refqualifier? exceptionSpecification? attributeSpecifierSeq?
    ;

trailingReturnType
    : Arrow trailingTypeSpecifierSeq abstractDeclarator?
    ;

pointerOperator
    : (And | AndAnd) attributeSpecifierSeq?
    | nestedNameSpecifier? Star attributeSpecifierSeq? cvqualifierseq?
    ;

cvqualifierseq
    : cvQualifier+
    ;

cvQualifier
    : Const
    | Volatile
    ;

refqualifier
    : And
    | AndAnd
    ;

declaratorid
    : Ellipsis? idExpression
    ;

theTypeId
    : typeSpecifierSeq abstractDeclarator?
    ;

abstractDeclarator
    : pointerAbstractDeclarator
    | noPointerAbstractDeclarator? parametersAndQualifiers trailingReturnType
    | abstractPackDeclarator
    ;

pointerAbstractDeclarator
    : pointerOperator* (noPointerAbstractDeclarator | pointerOperator)
    ;

noPointerAbstractDeclarator
    : (parametersAndQualifiers | LeftParen pointerAbstractDeclarator RightParen) (
        parametersAndQualifiers
        | LeftBracket constantExpression? RightBracket attributeSpecifierSeq?
    )*
    ;

abstractPackDeclarator
    : pointerOperator* noPointerAbstractPackDeclarator
    ;

noPointerAbstractPackDeclarator
    : Ellipsis (
        parametersAndQualifiers
        | LeftBracket constantExpression? RightBracket attributeSpecifierSeq?
    )*
    ;

parameterDeclarationClause
    : parameterDeclarationList (Comma? Ellipsis)?
    ;

parameterDeclarationList
    : parameterDeclaration (Comma parameterDeclaration)*
    ;

parameterDeclaration
    : attributeSpecifierSeq? declSpecifierSeq (declarator | abstractDeclarator?) (
        Assign initializerClause
    )?
    ;

functionDefinition
    : attributeSpecifierSeq? declSpecifierSeq? declarator virtualSpecifierSeq? functionBody
    ;

functionBody
    : constructorInitializer? compoundStatement
    | functionTryBlock
    | Assign (Default | Delete) Semi
    ;

initializer
    : braceOrEqualInitializer
    | LeftParen expressionList RightParen
    ;

braceOrEqualInitializer
    : Assign initializerClause
    | bracedInitList
    ;

initializerClause
    : assignmentExpression
    | bracedInitList
    ;

initializerList
    : initializerClause Ellipsis? (Comma initializerClause Ellipsis?)*
    ;

bracedInitList
    : LeftBrace (initializerList Comma?)? RightBrace
    ;

/*Classes*/

className
    : Identifier
    | simpleTemplateId
    ;

classSpecifier
    : classHead LeftBrace memberSpecification? RightBrace
    ;

classHead
    : classKey attributeSpecifierSeq? (classHeadName classVirtSpecifier?)? baseClause?
    | Union attributeSpecifierSeq? ( classHeadName classVirtSpecifier?)?
    ;

classHeadName
    : nestedNameSpecifier? className
    ;

classVirtSpecifier
    : Final
    ;

classKey
    : Class
    | Struct
    ;

memberSpecification
    : (memberdeclaration | accessSpecifier Colon)+
    ;

memberdeclaration
    : attributeSpecifierSeq? declSpecifierSeq? memberDeclaratorList? Semi
    | functionDefinition
    | usingDeclaration
    | staticAssertDeclaration
    | templateDeclaration
    | aliasDeclaration
    | emptyDeclaration_
    ;

memberDeclaratorList
    : memberDeclarator (Comma memberDeclarator)*
    ;

memberDeclarator
    : declarator (
        virtualSpecifierSeq
        | { this.IsPureSpecifierAllowed() }? pureSpecifier
        | { this.IsPureSpecifierAllowed() }? virtualSpecifierSeq pureSpecifier
        | braceOrEqualInitializer
    )
    | declarator
    | Identifier? attributeSpecifierSeq? Colon constantExpression
    ;

virtualSpecifierSeq
    : virtualSpecifier+
    ;

virtualSpecifier
    : Override
    | Final
    ;

/*
 purespecifier: Assign '0'//Conflicts with the lexer ;
 */

pureSpecifier
    : Assign IntegerLiteral
    ;

/*Derived classes*/

baseClause
    : Colon baseSpecifierList
    ;

baseSpecifierList
    : baseSpecifier Ellipsis? (Comma baseSpecifier Ellipsis?)*
    ;

baseSpecifier
    : attributeSpecifierSeq? (
        baseTypeSpecifier
        | Virtual accessSpecifier? baseTypeSpecifier
        | accessSpecifier Virtual? baseTypeSpecifier
    )
    ;

classOrDeclType
    : nestedNameSpecifier? className
    | decltypeSpecifier
    ;

baseTypeSpecifier
    : classOrDeclType
    ;

accessSpecifier
    : Private
    | Protected
    | Public
    ;

/*Special member functions*/

conversionFunctionId
    : Operator conversionTypeId
    ;

conversionTypeId
    : typeSpecifierSeq conversionDeclarator?
    ;

conversionDeclarator
    : pointerOperator conversionDeclarator?
    ;

constructorInitializer
    : Colon memInitializerList
    ;

memInitializerList
    : memInitializer Ellipsis? (Comma memInitializer Ellipsis?)*
    ;

memInitializer
    : meminitializerid (LeftParen expressionList? RightParen | bracedInitList)
    ;

meminitializerid
    : classOrDeclType
    | Identifier
    ;

/*Overloading*/

operatorFunctionId
    : Operator theOperator
    ;

literalOperatorId
    : Operator (StringLiteral Identifier | UserDefinedStringLiteral)
    ;

/*Templates*/

templateDeclaration
    : Template Less templateparameterList Greater declaration
    ;

templateparameterList
    : templateParameter (Comma templateParameter)*
    ;

templateParameter
    : typeParameter
    | parameterDeclaration
    ;

typeParameter
    : ((Template Less templateparameterList Greater)? Class | Typename_) (
        Ellipsis? Identifier?
        | Identifier? Assign theTypeId
    )
    ;

simpleTemplateId
    : templateName Less templateArgumentList? Greater
    ;

templateId
    : simpleTemplateId
    | (operatorFunctionId | literalOperatorId) Less templateArgumentList? Greater
    ;

templateName
    : Identifier
    ;

templateArgumentList
    : templateArgument Ellipsis? (Comma templateArgument Ellipsis?)*
    ;

templateArgument
    : theTypeId
    | constantExpression
    | idExpression
    ;

typeNameSpecifier
    : Typename_ nestedNameSpecifier (Identifier | Template? simpleTemplateId)
    ;

explicitInstantiation
    : Extern? Template declaration
    ;

explicitSpecialization
    : Template Less Greater declaration
    ;

/*Exception handling*/

tryBlock
    : Try compoundStatement handlerSeq
    ;

functionTryBlock
    : Try constructorInitializer? compoundStatement handlerSeq
    ;

handlerSeq
    : handler+
    ;

handler
    : Catch LeftParen exceptionDeclaration RightParen compoundStatement
    ;

exceptionDeclaration
    : attributeSpecifierSeq? typeSpecifierSeq (declarator | abstractDeclarator)?
    | Ellipsis
    ;

throwExpression
    : Throw assignmentExpression?
    ;

exceptionSpecification
    : dynamicExceptionSpecification
    | noeExceptSpecification
    ;

dynamicExceptionSpecification
    : Throw LeftParen typeIdList? RightParen
    ;

typeIdList
    : theTypeId Ellipsis? (Comma theTypeId Ellipsis?)*
    ;

noeExceptSpecification
    : Noexcept LeftParen constantExpression RightParen
    | Noexcept
    ;

/*Preprocessing directives*/

/*Lexer*/

theOperator
    : New (LeftBracket RightBracket)?
    | Delete (LeftBracket RightBracket)?
    | Plus
    | Minus
    | Star
    | Div
    | Mod
    | Caret
    | And
    | Or
    | Tilde
    | Not
    | Assign
    | Greater
    | Less
    | GreaterEqual
    | PlusAssign
    | MinusAssign
    | StarAssign
    | ModAssign
    | XorAssign
    | AndAssign
    | OrAssign
    | Less Less
    | Greater Greater
    | RightShiftAssign
    | LeftShiftAssign
    | Equal
    | NotEqual
    | LessEqual
    | AndAnd
    | OrOr
    | PlusPlus
    | MinusMinus
    | Comma
    | ArrowStar
    | Arrow
    | LeftParen RightParen
    | LeftBracket RightBracket
    ;

literal
    : IntegerLiteral
    | CharacterLiteral
    | FloatingLiteral
    | StringLiteral
    | BooleanLiteral
    | PointerLiteral
    | UserDefinedLiteral
    ;
```

`src/main/java/com/lauriewired/malimite/Malimite.java`:

```java
package com.lauriewired.malimite;

import com.formdev.flatlaf.FlatLightLaf;
import com.formdev.flatlaf.FlatDarkLaf;
import com.formdev.flatlaf.FlatLaf;
import com.lauriewired.malimite.configuration.Config;
import com.lauriewired.malimite.ui.AnalysisWindow;
import com.lauriewired.malimite.ui.SyntaxHighlighter;
import com.lauriewired.malimite.ui.SafeMenuAction;
import com.lauriewired.malimite.ui.ApplicationMenu;
import com.lauriewired.malimite.ui.PreferencesDialog;
import com.lauriewired.malimite.utils.FileProcessing;

import javax.swing.*;

import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;

import java.awt.*;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DnDConstants;
import java.awt.dnd.DropTarget;
import java.awt.dnd.DropTargetAdapter;
import java.awt.dnd.DropTargetDropEvent;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;

public class Malimite {
    private static final Logger LOGGER = Logger.getLogger(Malimite.class.getName());

    public static void main(String[] args) {
        // Load or create config immediately
        Config config = new Config();
        
        // Enable macOS-specific properties if on Mac
        if (config.isMac()) {
            System.setProperty("apple.laf.useScreenMenuBar", "true");
            System.setProperty("apple.awt.application.appearance", "system");
            System.setProperty("apple.awt.application.name", "Malimite");
        }
        
        // Set initial FlatLaf theme based on config
        if (config.getTheme().equals("dark")) {
            FlatDarkLaf.setup();
        } else {
            FlatLightLaf.setup();
        }

        FlatLaf.setUseNativeWindowDecorations(true);
    
        SwingUtilities.invokeLater(() -> createAndShowGUI(config));
    }

    private static void createAndShowGUI(Config config) {
        SafeMenuAction.execute(() -> {
            JFrame frame = new JFrame("Malimite");
            
            // Add application icon
            try {
                ImageIcon icon = new ImageIcon(Malimite.class.getResource("/icons/app-icon.png"));
                frame.setIconImage(icon.getImage());
                
                // For macOS dock icon
                if (config.isMac()) {
                    Taskbar.getTaskbar().setIconImage(icon.getImage());
                }
            } catch (Exception e) {
                LOGGER.warning("Could not load application icon: " + e.getMessage());
            }
            
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(600, 400);
            frame.setLocationRelativeTo(null);
        
            // Config is now passed in from main
        
            // Add the menu bar
            ApplicationMenu applicationMenu = new ApplicationMenu(
                frame, 
                null,  // null since main window might not have a file tree
                config
            );
            frame.setJMenuBar(applicationMenu.createMenuBar());
        
            JPanel panel = new JPanel(new BorderLayout(10, 10));
            frame.add(panel);
        
            FileProcessing.setConfig(config);
        
            setupComponents(panel, frame, config);
        
            frame.setVisible(true);
        });
    }
    
    public static void updateTheme(String theme) {
        SafeMenuAction.execute(() -> {
            // Mirror exactly what happens in main()
            if (theme.equals("dark")) {
                FlatDarkLaf.setup();
            } else {
                FlatLightLaf.setup();
            }
            
            // Update all windows' look-and-feel
            for (Window window : Window.getWindows()) {
                SwingUtilities.updateComponentTreeUI(window);
                
                // After updating UI, reapply custom syntax theme to any RSyntaxTextArea
                for (Component comp : getAllComponents((Container)window)) {
                    if (comp instanceof RSyntaxTextArea) {
                        RSyntaxTextArea textArea = (RSyntaxTextArea)comp;
                        // Force a clean reset of the syntax theme
                        textArea.setBackground(UIManager.getColor("Panel.background"));
                        SyntaxHighlighter.applyCustomTheme(textArea);
                    }
                }
            }
        });
    }    

    // Add this utility method to get all components recursively
    private static List<Component> getAllComponents(Container container) {
        List<Component> components = new ArrayList<>();
        for (Component comp : container.getComponents()) {
            components.add(comp);
            if (comp instanceof Container) {
                components.addAll(getAllComponents((Container)comp));
            }
        }
        return components;
    }  

    private static void setupComponents(JPanel panel, JFrame frame, Config config) {
        // Use BorderLayout for the main panel
        panel.setLayout(new BorderLayout(10, 10));
        
        // Create panel for file selection
        JPanel mainPanel = new JPanel(new GridBagLayout());
        GridBagConstraints constraints = new GridBagConstraints();
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.insets = new Insets(15, 15, 15, 15);

        // File path text field
        JTextField filePathText = new JTextField();
        filePathText.setFont(new Font("Verdana", Font.PLAIN, 16));
        filePathText.setEditable(false);
        filePathText.setPreferredSize(new Dimension(400, 30));
        constraints.gridx = 0;
        constraints.gridy = 0;
        constraints.gridwidth = 3;
        mainPanel.add(filePathText, constraints);

        // "Select File" button
        JButton fileButton = new JButton("Select File");
        constraints.gridx = 3;
        constraints.gridy = 0;
        constraints.gridwidth = 1;
        mainPanel.add(fileButton, constraints);

        // "Analyze" button
        JButton analyzeButton = new JButton("Analyze File");
        constraints.gridx = 0;
        constraints.gridy = 1;
        constraints.gridwidth = 4;
        mainPanel.add(analyzeButton, constraints);

        // Add components to main panel
        panel.add(mainPanel, BorderLayout.NORTH);

        // Add recent projects panel
        JPanel recentProjectsPanel = new JPanel(new BorderLayout());
        recentProjectsPanel.setBorder(BorderFactory.createTitledBorder("Recent Projects"));
        
        JPanel projectsListPanel = new JPanel();
        projectsListPanel.setLayout(new BoxLayout(projectsListPanel, BoxLayout.Y_AXIS));
        
        // Get and add recent projects
        List<String> projectPaths = config.getProjectPaths();
        LOGGER.info("Retrieved project paths: " + projectPaths);
        
        for (String path : projectPaths) {
            LOGGER.info("Processing project path: " + path);
            JButton projectButton = new JButton(path);
            projectButton.setHorizontalAlignment(SwingConstants.LEFT);
            projectButton.setBorderPainted(false);
            projectButton.setContentAreaFilled(false);
            projectButton.setCursor(new Cursor(Cursor.HAND_CURSOR));
            
            projectButton.addActionListener(e -> {
                File originalFile = new File(path);
                String parentDir = originalFile.getParent();
                String fileName = originalFile.getName();
                
                // Remove file extension from fileName if it exists
                int lastDotIndex = fileName.lastIndexOf('.');
                if (lastDotIndex > 0) {
                    fileName = fileName.substring(0, lastDotIndex);
                }
                
                File projectFile = new File(parentDir + File.separator + fileName + "_malimite" + File.separator + "project.json");
                
                if (projectFile.exists()) {
                    // Close existing window before opening new one
                    AnalysisWindow.closeWindow();
                    LOGGER.info("Opening analysis window for: " + path);
                    AnalysisWindow.show(new File(path), config);
                } else {
                    LOGGER.warning("Project directory not found at: " + projectFile.getAbsolutePath());
                    JOptionPane.showMessageDialog(frame,
                        "Project directory no longer exists.",
                        "Error",
                        JOptionPane.ERROR_MESSAGE);
                }
            });
            
            projectsListPanel.add(projectButton);
        }
        
        JScrollPane scrollPane = new JScrollPane(projectsListPanel);
        scrollPane.setPreferredSize(new Dimension(0, 150));
        recentProjectsPanel.add(scrollPane, BorderLayout.CENTER);
        
        panel.add(recentProjectsPanel, BorderLayout.CENTER);

        // Set up file listeners
        setupDragAndDrop(filePathText);
        setupFileButtonListener(fileButton, filePathText);
        setupAnalyzeButtonListener(analyzeButton, filePathText, config);
    }

    private static void setupDragAndDrop(JTextField filePathText) {
        new DropTarget(filePathText, new DropTargetAdapter() {
            @Override
            public void drop(DropTargetDropEvent evt) {
                try {
                    evt.acceptDrop(DnDConstants.ACTION_COPY);
                    List<File> droppedFiles = (List<File>) evt.getTransferable().getTransferData(DataFlavor.javaFileListFlavor);
                    if (!droppedFiles.isEmpty()) {
                        File file = droppedFiles.get(0);
                        filePathText.setText(file.getAbsolutePath());
                    }
                } catch (Exception ex) {
                    LOGGER.severe("Error during file drop: " + ex.getMessage());
                }
            }
        });
    }

    private static void setupFileButtonListener(JButton fileButton, JTextField filePathText) {
        fileButton.addActionListener(e -> {
            JFileChooser fileChooser = new JFileChooser();
            fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
            int option = fileChooser.showOpenDialog(null);
            if (option == JFileChooser.APPROVE_OPTION) {
                File selectedFile = fileChooser.getSelectedFile();
                filePathText.setText(selectedFile.getAbsolutePath());
            }
        });
    }

    private static void setupAnalyzeButtonListener(JButton analyzeButton, JTextField filePathText, Config config) {
        analyzeButton.addActionListener(e -> {
            // First check if Ghidra path is set
            if (config.getGhidraPath() == null || config.getGhidraPath().trim().isEmpty()) {
                int choice = JOptionPane.showConfirmDialog(null,
                    "Ghidra path is not set. Would you like to set it in preferences?\nNote: This is required for analysis",
                    "Ghidra Path Required",
                    JOptionPane.YES_NO_OPTION,
                    JOptionPane.WARNING_MESSAGE);
                    
                if (choice == JOptionPane.YES_OPTION) {
                    SwingUtilities.invokeLater(() -> PreferencesDialog.show((JFrame)SwingUtilities.getWindowAncestor(analyzeButton), config));
                }
                return;
            }

            // Proceed with existing analysis logic
            String filePath = filePathText.getText();
            if (!filePath.isEmpty() && Files.exists(Paths.get(filePath))) {
                // Close existing window before opening new one
                AnalysisWindow.closeWindow();
                AnalysisWindow.show(new File(filePath), config);
            } else {
                JOptionPane.showMessageDialog(null, 
                    "Please select a valid file path.", 
                    "Invalid File", 
                    JOptionPane.WARNING_MESSAGE);
            }
        });
    }    
}

```

`src/main/java/com/lauriewired/malimite/configuration/Config.java`:

```java
package com.lauriewired.malimite.configuration;

import java.io.*;
import java.util.Properties;
import java.util.logging.Logger;
import java.util.logging.Level;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;

import com.lauriewired.malimite.security.KeyEncryption;

public class Config {
    private static final Logger LOGGER = Logger.getLogger(Config.class.getName());
    private static final String CONFIG_FILE = "malimite.properties";
    private static final String GHIDRA_PATH_KEY = "ghidra.path";
    private static final String THEME_KEY = "app.theme";
    private static final String OS_TYPE_KEY = "os.type";
    private static final String ENCRYPTED_OPENAI_API_KEY = "openai.api.key.encrypted";
    private static final String ENCRYPTED_CLAUDE_API_KEY = "claude.api.key.encrypted";
    private static final String LOCAL_MODEL_URL = "local.model.url";
    private static final String PROJECTS_LIST_KEY = "projects.list";
    private static final String ADDED_LIBRARIES_KEY = "libraries.added";
    private static final String REMOVED_LIBRARIES_KEY = "libraries.removed";
    
    private String osType;
    private String ghidraPath;
    private String theme;
    private Properties properties;
    private String configDirectory;
    private String encryptedOpenAIApiKey;
    private String encryptedClaudeApiKey;

    public Config() {
        this.osType = System.getProperty("os.name").toLowerCase();
        this.properties = new Properties();
        this.configDirectory = ".";
        loadConfig();
        
        properties.setProperty(OS_TYPE_KEY, this.osType);
        
        if (this.theme == null) {
            this.theme = "dark";
            properties.setProperty(THEME_KEY, this.theme);
            saveConfig();
        }
    }

    public void loadConfig() {
        File configFile = new File(CONFIG_FILE);
        if (configFile.exists()) {
            try (FileInputStream fis = new FileInputStream(configFile)) {
                properties.load(fis);
                this.configDirectory = configFile.getParent() != null ? configFile.getParent() : ".";
                this.ghidraPath = properties.getProperty(GHIDRA_PATH_KEY);
                this.theme = properties.getProperty(THEME_KEY);
                this.osType = properties.getProperty(OS_TYPE_KEY, System.getProperty("os.name").toLowerCase());
                this.encryptedOpenAIApiKey = properties.getProperty(ENCRYPTED_OPENAI_API_KEY);
                this.encryptedClaudeApiKey = properties.getProperty(ENCRYPTED_CLAUDE_API_KEY);
            } catch (IOException e) {
                LOGGER.log(Level.WARNING, "Failed to load configuration file", e);
            }
        }
    }

    public void saveConfig() {
        try (FileOutputStream fos = new FileOutputStream(CONFIG_FILE)) {
            properties.store(fos, "Malimite Configuration");
        } catch (IOException e) {
            LOGGER.log(Level.WARNING, "Failed to save configuration file", e);
        }
    }

    public String getGhidraPath() {
        return ghidraPath;
    }

    public void setGhidraPath(String ghidraPath) {
        this.ghidraPath = ghidraPath;
        properties.setProperty(GHIDRA_PATH_KEY, ghidraPath);
        saveConfig();
    }

    public boolean isWindows() {
        return osType.contains("win");
    }

    public boolean isMac() {
        return osType.contains("mac");
    }

    public boolean isUnix() {
        return osType.contains("nix") || osType.contains("nux") || osType.contains("aix");
    }

    public String getTheme() {
        return theme;
    }

    public void setTheme(String theme) {
        this.theme = theme;
        properties.setProperty(THEME_KEY, theme);
        saveConfig();
    }

    public String getConfigDirectory() {
        return configDirectory;
    }

    public String getOpenAIApiKey() {
        return encryptedOpenAIApiKey;
    }

    public void setOpenAIApiKey(String key) {
        this.encryptedOpenAIApiKey = KeyEncryption.encrypt(key);
        properties.setProperty(ENCRYPTED_OPENAI_API_KEY, this.encryptedOpenAIApiKey);
        saveConfig();
    }

    public String getClaudeApiKey() {
        return encryptedClaudeApiKey;
    }

    public void setClaudeApiKey(String key) {
        this.encryptedClaudeApiKey = KeyEncryption.encrypt(key);
        properties.setProperty(ENCRYPTED_CLAUDE_API_KEY, this.encryptedClaudeApiKey);
        saveConfig();
    }

    public String getLocalModelUrl() {
        return properties.getProperty(LOCAL_MODEL_URL, "http://localhost:1234/v1/chat/completions");
    }

    public void setLocalModelUrl(String url) {
        properties.setProperty(LOCAL_MODEL_URL, url);
        saveConfig();
    }

    public List<String> getProjectPaths() {
        String projectsStr = properties.getProperty(PROJECTS_LIST_KEY, "");
        if (projectsStr.isEmpty()) {
            return new ArrayList<>();
        }
        return new ArrayList<>(Arrays.asList(projectsStr.split("\\|")));
    }

    public void addProjectPath(String path) {
        List<String> projects = getProjectPaths();
        if (!projects.contains(path)) {
            projects.add(path);
            properties.setProperty(PROJECTS_LIST_KEY, String.join("|", projects));
            saveConfig();
        }
    }

    public List<String> getAddedLibraries() {
        String addedStr = properties.getProperty(ADDED_LIBRARIES_KEY, "");
        if (addedStr.isEmpty()) {
            return new ArrayList<>();
        }
        return new ArrayList<>(Arrays.asList(addedStr.split("\\|")));
    }

    public List<String> getRemovedLibraries() {
        String removedStr = properties.getProperty(REMOVED_LIBRARIES_KEY, "");
        if (removedStr.isEmpty()) {
            return new ArrayList<>();
        }
        return new ArrayList<>(Arrays.asList(removedStr.split("\\|")));
    }

    public void addLibrary(String library) {
        List<String> addedLibraries = getAddedLibraries();
        List<String> removedLibraries = getRemovedLibraries();
        
        if (removedLibraries.contains(library)) {
            // If it was previously removed, just remove it from the removed list
            removedLibraries.remove(library);
            properties.setProperty(REMOVED_LIBRARIES_KEY, String.join("|", removedLibraries));
        } else if (!LibraryDefinitions.getDefaultLibraries().contains(library) 
                   && !addedLibraries.contains(library)) {
            // Only add to added list if it's not a default library and not already added
            addedLibraries.add(library);
            properties.setProperty(ADDED_LIBRARIES_KEY, String.join("|", addedLibraries));
        }
        saveConfig();
    }

    public void removeLibrary(String library) {
        List<String> addedLibraries = getAddedLibraries();
        List<String> removedLibraries = getRemovedLibraries();
        
        if (addedLibraries.contains(library)) {
            // If it was previously added, just remove it from the added list
            addedLibraries.remove(library);
            properties.setProperty(ADDED_LIBRARIES_KEY, String.join("|", addedLibraries));
        } else if (LibraryDefinitions.getDefaultLibraries().contains(library) 
                   && !removedLibraries.contains(library)) {
            // Only add to removed list if it's a default library and not already removed
            removedLibraries.add(library);
            properties.setProperty(REMOVED_LIBRARIES_KEY, String.join("|", removedLibraries));
        }
        saveConfig();
    }

    public void clearLibraryConfigurations() {
        properties.remove(ADDED_LIBRARIES_KEY);
        properties.remove(REMOVED_LIBRARIES_KEY);
        saveConfig();
    }
}

```

`src/main/java/com/lauriewired/malimite/configuration/LibraryDefinitions.java`:

```java
package com.lauriewired.malimite.configuration;

import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import java.util.ArrayList;

public class LibraryDefinitions {
    // Common iOS frameworks to avoid decompiling
    private static final List<String> DEFAULT_LIBRARIES = Arrays.asList(
        "UIKit",
        "Foundation",
        "CoreData",
        "CoreGraphics",
        "CoreLocation",
        "AVFoundation",
        "WebKit",
        "Security",
        "NetworkExtension",
        "SystemConfiguration",
        "CoreBluetooth",
        "CoreMotion",
        "Photos",
        "Contacts",
        "HealthKit",
        "HomeKit",
        "MapKit",
        "MessageUI",
        "StoreKit",
        "UserNotifications",
        "SwiftStandardLibrary",
        "SwiftUI",
        "Combine",
        "CoreFoundation",
        "QuartzCore",
        "CFNetwork",
        "CoreImage",
        "Metal",
        "SceneKit",
        "ARKit",
        "SpriteKit",
        "GameKit",
        "BackgroundTasks",
        "CloudKit",
        "FileProvider",
        "CoreText",
        "Vision",
        "TextKit",
        "CoreML",
        "NaturalLanguage",
        "AppTrackingTransparency",
        "AuthenticationServices",
        "Intents",
        "CallKit",
        "MediaPlayer",
        "PassKit"
    );
    

    public static List<String> getDefaultLibraries() {
        return DEFAULT_LIBRARIES;
    }

    public static List<String> getActiveLibraries(Config config) {
        Set<String> activeLibraries = new HashSet<>(DEFAULT_LIBRARIES);
        
        // Remove any libraries that the user has explicitly removed
        activeLibraries.removeAll(config.getRemovedLibraries());
        
        // Add any custom libraries the user has added
        activeLibraries.addAll(config.getAddedLibraries());
        
        // Convert back to sorted list for consistent ordering
        List<String> sortedLibraries = new ArrayList<>(activeLibraries);
        Collections.sort(sortedLibraries);
        return sortedLibraries;
    }
} 
```

`src/main/java/com/lauriewired/malimite/configuration/Project.java`:

```java
package com.lauriewired.malimite.configuration;

import com.lauriewired.malimite.files.Macho;

public class Project {
    private String fileName;
    private String filePath;
    private String fileType;
    private boolean isMachO;
    private Macho machoInfo;
    private String bundleIdentifier;
    private boolean isSwift;
    private long size;
    
    public Project() {
    }
    
    // Basic file info getters/setters
    public String getFileName() { return fileName; }
    public void setFileName(String fileName) { this.fileName = fileName; }
    
    public String getFilePath() { return filePath; }
    public void setFilePath(String filePath) { this.filePath = filePath; }
    
    public String getFileType() { return fileType; }
    public void setFileType(String fileType) { this.fileType = fileType; }
    
    public boolean isMachO() { return isMachO; }
    public void setIsMachO(boolean isMachO) { this.isMachO = isMachO; }
    
    public Macho getMachoInfo() { return machoInfo; }
    public void setMachoInfo(Macho machoInfo) { this.machoInfo = machoInfo; }
    
    public String getBundleIdentifier() { return bundleIdentifier; }
    public void setBundleIdentifier(String bundleIdentifier) { this.bundleIdentifier = bundleIdentifier; }
    
    public boolean isSwift() { return isSwift; }
    public void setIsSwift(boolean isSwift) { this.isSwift = isSwift; }
    
    public long getSize() { return size; }
    public void setSize(long size) { this.size = size; }
    
    public String generateInfoString() {
        StringBuilder info = new StringBuilder("<html>");
        info.append("<h3>File Analysis Report</h3>");
        info.append("<p><b>File:</b> ").append(fileName).append("</p>");
        info.append("<p><b>Size:</b> ").append(size / 1024).append(" KB</p>");
        info.append("<p><b>Type:</b> ").append(fileType).append("</p>");
        
        if (bundleIdentifier != null && !bundleIdentifier.isEmpty()) {
            info.append("<p><b>Bundle ID:</b> ").append(bundleIdentifier).append("</p>");
        }
        
        if (isMachO && machoInfo != null) {
            info.append("<h4>Mach-O Analysis</h4>");
            info.append("<p><b>Language:</b> ").append(this.isSwift ? "Swift" : "Objective-C").append("</p>");
            if (machoInfo.isUniversalBinary()) {
                info.append("<p><b>Universal Binary:</b> Yes</p>");
                info.append("<p><b>Architectures:</b></p><ul>");
                for (Macho.Architecture arch : machoInfo.getArchitectures()) {
                    info.append("<li>").append(arch.toString()).append("</li>");
                }
                info.append("</ul>");
            }
        }
        
        info.append("</html>");
        return info.toString();
    }
}

```

`src/main/java/com/lauriewired/malimite/database/SQLiteDBHandler.java`:

```java
package com.lauriewired.malimite.database;

import java.io.File;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONTokener;

import com.lauriewired.malimite.decompile.SyntaxParser;

public class SQLiteDBHandler {
    private String url;
    private static final Logger LOGGER = Logger.getLogger(SQLiteDBHandler.class.getName());
    private Connection transaction;

    /*
     *  SQLiteDBHandler dbHandler = new SQLiteDBHandler("mydatabase.db");
        dbHandler.insertClass("example.c", "ExampleClass", "[function1, function2]", "void function1() {...}");
        dbHandler.readClasses();
     */

    public SQLiteDBHandler(String dbPath, String dbName) {
        this.url = "jdbc:sqlite:" + dbPath + dbName;
        initializeDatabase();
    }

    private void initializeDatabase() {
        try {

            Connection transaction = DriverManager.getConnection(url);
            try (Statement walStmt = transaction.createStatement()) {
                walStmt.execute("PRAGMA journal_mode=WAL;");
                walStmt.execute("PRAGMA synchronous=OFF;");
            }
            transaction.setAutoCommit(false);
            this.transaction = transaction;
        } catch (SQLException e) {
            String msg = "Failed to create database transaction connection";
            LOGGER.log(Level.SEVERE, msg, e);
            throw new RuntimeException(msg, e);
        }

        String sqlClasses = "CREATE TABLE IF NOT EXISTS Classes ("
                + "ClassName TEXT,"
                + "Functions TEXT,"
                + "ExecutableName TEXT,"
                + "PRIMARY KEY (ClassName, ExecutableName));";

        String sqlFunctions = "CREATE TABLE IF NOT EXISTS Functions ("
                + "FunctionName TEXT,"
                + "ParentClass TEXT,"
                + "DecompilationCode TEXT,"
                + "ExecutableName TEXT,"
                + "PRIMARY KEY (FunctionName, ParentClass, ExecutableName));";

        String sqlMachoStrings = "CREATE TABLE IF NOT EXISTS MachoStrings ("
                + "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                + "address TEXT,"
                + "value TEXT,"
                + "segment TEXT,"
                + "label TEXT,"
                + "ExecutableName TEXT);";

        String sqlResourceStrings = "CREATE TABLE IF NOT EXISTS ResourceStrings ("
                + "id INTEGER PRIMARY KEY AUTOINCREMENT,"
                + "resourceId TEXT,"
                + "value TEXT,"
                + "type TEXT"
                + ");";

        String sqlFunctionReferences = "CREATE TABLE IF NOT EXISTS FunctionReferences ("
            + "id INTEGER PRIMARY KEY AUTOINCREMENT,"
            + "sourceFunction TEXT,"
            + "sourceClass TEXT,"
            + "targetFunction TEXT,"
            + "targetClass TEXT,"
            + "lineNumber INTEGER,"
            + "ExecutableName TEXT,"
            + "FOREIGN KEY(sourceFunction, sourceClass) REFERENCES Functions(FunctionName, ParentClass),"
            + "FOREIGN KEY(targetFunction, targetClass) REFERENCES Functions(FunctionName, ParentClass)"
            + ");";

        String sqlLocalVariableReferences = "CREATE TABLE IF NOT EXISTS LocalVariableReferences ("
            + "id INTEGER PRIMARY KEY AUTOINCREMENT,"
            + "variableName TEXT,"
            + "containingFunction TEXT,"
            + "containingClass TEXT,"
            + "lineNumber INTEGER,"
            + "ExecutableName TEXT,"
            + "FOREIGN KEY(containingFunction, containingClass) REFERENCES Functions(FunctionName, ParentClass)"
            + ");";

        String sqlTypeInformation = "CREATE TABLE IF NOT EXISTS TypeInformation ("
            + "id INTEGER PRIMARY KEY AUTOINCREMENT,"
            + "variableName TEXT,"
            + "variableType TEXT,"
            + "functionName TEXT,"
            + "className TEXT,"
            + "lineNumber INTEGER,"
            + "ExecutableName TEXT,"
            + "FOREIGN KEY(functionName, className) REFERENCES Functions(FunctionName, ParentClass)"
            + ");";

        try (Connection conn = DriverManager.getConnection(url);
             Statement stmt = conn.createStatement()) {
            stmt.execute(sqlClasses);
            stmt.execute(sqlFunctions);
            stmt.execute(sqlMachoStrings);
            stmt.execute(sqlResourceStrings);
            stmt.execute(sqlFunctionReferences);
            stmt.execute(sqlLocalVariableReferences);
            stmt.execute(sqlTypeInformation);
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Database initialization error", e);
        }
    }

    public Connection GetTransaction() {
        return this.transaction;
    }

    public Map<String, List<String>> getAllClassesAndFunctions() {
        Map<String, List<String>> classFunctionMap = new HashMap<>();
        String sql = "SELECT ClassName, Functions, ExecutableName FROM Classes";

        try (Statement stmt = this.transaction.createStatement();
                ResultSet rs = stmt.executeQuery(sql)) {

            while (rs.next()) {
                String className = rs.getString("ClassName");
                String functionsJson = rs.getString("Functions");
                List<String> functions = parseFunctions(functionsJson);
                classFunctionMap.put(className, functions);
            }
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error getting all classes and functions", e);
        }
        return classFunctionMap;
    }

    private List<String> parseFunctions(String json) {
        // Assuming the JSON is in the format: ["function1", "function2", ...]
        try {
            JSONArray jsonArray = new JSONArray(json);
            List<String> functions = new ArrayList<>();
            for (int i = 0; i < jsonArray.length(); i++) {
                functions.add(jsonArray.getString(i));
            }
            return functions;
        } catch (JSONException e) {
            e.printStackTrace();
            return new ArrayList<>();
        }
    }

    public void populateFunctionData(String pathToClassFiles, String pathToFunctionDataJson) {
        try {
            // Read the entire JSON file into a String
            String jsonData = new String(Files.readAllBytes(new File(pathToFunctionDataJson).toPath()), StandardCharsets.UTF_8);

            // Parse the JSON data
            JSONArray functionsArray = new JSONArray(new JSONTokener(jsonData));

            // Iterate over each class in the JSON array
            for (int i = 0; i < functionsArray.length(); i++) {
                JSONObject classObject = functionsArray.getJSONObject(i);
                String functionName = classObject.getString("FunctionName");
                String className = classObject.getString("ClassName");
                String executableName = classObject.getString("executableFile");

                // Insert each function into the database
                insertFunction(functionName, className, executableName);
            }

        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("Error reading or parsing JSON class data file: " + e.getMessage());
        }
    }

    public void insertFunction(String functionName, String parentClass, String decompiledCode, String executableName) {
        String sql = "INSERT INTO Functions(FunctionName, ParentClass, DecompilationCode, ExecutableName) "
                + "VALUES(?,?,?,?) "
                + "ON CONFLICT(FunctionName, ParentClass, ExecutableName) "
                + "DO UPDATE SET DecompilationCode = ?";

        try (PreparedStatement pstmt = this.transaction.prepareStatement(sql)) {
            pstmt.setString(1, functionName);
            pstmt.setString(2, parentClass);
            pstmt.setString(3, decompiledCode);
            pstmt.setString(4, executableName);
            pstmt.setString(5, decompiledCode);
            pstmt.executeUpdate();
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error inserting function", e);
        }
    }

    public void insertFunction(String functionName, String parentClass, int decompilationLine) {
        String sql = "INSERT INTO Functions(FunctionName, ParentClass, DecompilationLine) VALUES(?,?,?)";

        try (PreparedStatement pstmt = this.transaction.prepareStatement(sql)) {
            pstmt.setString(1, functionName);
            pstmt.setString(2, parentClass);
            pstmt.setInt(3, decompilationLine);
            pstmt.executeUpdate();
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error inserting function", e);
        }
    }

    public void insertClass(String className, String functions, String executableName) {
        String sql = "INSERT INTO Classes(ClassName, Functions, ExecutableName) VALUES(?,?,?)";

        try (PreparedStatement pstmt = this.transaction.prepareStatement(sql)) {
            pstmt.setString(1, className);
            pstmt.setString(2, functions);
            pstmt.setString(3, executableName);
            pstmt.executeUpdate();
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error inserting class", e);
        }
    }

    public void readClasses() {
        String sql = "SELECT * FROM Classes";

        try (Statement stmt = this.transaction.createStatement();
                ResultSet rs = stmt.executeQuery(sql)) {

            while (rs.next()) {
                System.out.println(rs.getString("ExecutableName") + "\t" +
                        rs.getString("ClassName") + "\t" +
                        rs.getString("Functions"));
            }
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error getting classes", e);
        }
    }

    public static class DecompilationResult {
        public String functionName;
        public String className;
        public String decompiledCode;
        public String executableName;

        public DecompilationResult(String functionName, String className, String decompiledCode, String executableName) {
            this.functionName = functionName;
            this.className = className;
            this.decompiledCode = decompiledCode;
            this.executableName = executableName;
        }
    }

    public void insertFunctionDecompilations(List<DecompilationResult> results) {
        String sql = "INSERT INTO Functions(FunctionName, ParentClass, DecompilationCode, ExecutableName) "
                + "VALUES (?, ?, ?, ?) "
                + "ON CONFLICT(FunctionName, ParentClass, ExecutableName) "
                + "DO UPDATE SET DecompilationCode = excluded.DecompilationCode";

        try (PreparedStatement pstmt = this.transaction.prepareStatement(sql)) {
            for (DecompilationResult result : results) {
                pstmt.setString(1, result.functionName);
                pstmt.setString(2, result.className);
                pstmt.setString(3, result.decompiledCode);
                pstmt.setString(4, result.executableName);
                pstmt.addBatch();
            }
            pstmt.executeBatch();
            this.transaction.commit();
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error inserting function decompilations", e);
        }
    }

    public void updateFunctionDecompilation(String functionName, String className, String decompiledCode,
            String executableName) {
        updateFunctionDecompilation(this.transaction, functionName, className, decompiledCode, executableName);
    }

    public void updateFunctionDecompilation(Connection transaction, String functionName, String className,
            String decompiledCode, String executableName) {
        // First, clear all existing references for this function
        clearFunctionReferences(transaction, functionName, className, executableName);

        // Update the function's decompilation code
        String sql = "INSERT INTO Functions(FunctionName, ParentClass, DecompilationCode, ExecutableName) "
                + "VALUES (?, ?, ?, ?) "
                + "ON CONFLICT(FunctionName, ParentClass, ExecutableName) "
                + "DO UPDATE SET DecompilationCode = excluded.DecompilationCode";

        try (PreparedStatement pstmt = transaction.prepareStatement(sql)) {
            pstmt.setString(1, functionName);
            pstmt.setString(2, className);
            pstmt.setString(3, decompiledCode);
            pstmt.setString(4, executableName);
            pstmt.executeUpdate();

            // Create a new SyntaxParser and reparse the updated function
            if (decompiledCode != null && !decompiledCode.trim().isEmpty()) {
                SyntaxParser parser = new SyntaxParser(executableName);
                parser.setContext(functionName, className);
                parser.collectCrossReferences(decompiledCode);
                this.insertFunctionReferences(parser.getFunctionRefResults());
                this.insertLocalVariableReferences(parser.getVariableRefResults());
                this.insertTypeInformations(parser.getTypeInfoResults());
            }

            transaction.commit();

        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error updating function decompilation", e);
            e.printStackTrace();
        }
    }

    private void clearFunctionReferences(Connection transaction, String functionName, String className, String executableName) {
        String sqlFuncRefs = "DELETE FROM FunctionReferences WHERE sourceFunction = ? AND sourceClass = ? AND ExecutableName = ?";
        String sqlVarRefs = "DELETE FROM LocalVariableReferences WHERE containingFunction = ? AND containingClass = ? AND ExecutableName = ?";
        String sqlTypeInfo = "DELETE FROM TypeInformation WHERE functionName = ? AND className = ? AND ExecutableName = ?";

        for (String sql : new String[] { sqlFuncRefs, sqlVarRefs, sqlTypeInfo }) {
            try (PreparedStatement pstmt = transaction.prepareStatement(sql)) {
                pstmt.setString(1, functionName);
                pstmt.setString(2, className);
                pstmt.setString(3, executableName);
                pstmt.executeUpdate();
            } catch (SQLException e) {
                LOGGER.log(Level.SEVERE, "Error clearing function references", e);
                e.printStackTrace();
            }
        }
    }

    public String getFunctionDecompilation(String functionName, String className, String executableName) {
        String sql = "SELECT DecompilationCode FROM Functions WHERE FunctionName = ? AND ParentClass = ? AND ExecutableName = ?";

        try (PreparedStatement pstmt = this.transaction.prepareStatement(sql)) {
            pstmt.setString(1, functionName);
            pstmt.setString(2, className);
            pstmt.setString(3, executableName);

            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    return rs.getString("DecompilationCode");
                }
            }
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error retrieving function decompilation", e);
        }
        return null;
    }

    public void insertMachoString(String address, String value, String segment, String label, String executableName) {
        String sql = "INSERT INTO MachoStrings(address, value, segment, label, ExecutableName) VALUES(?,?,?,?,?)";

        try (PreparedStatement pstmt = this.transaction.prepareStatement(sql)) {
            pstmt.setString(1, address);
            pstmt.setString(2, value);
            pstmt.setString(3, segment);
            pstmt.setString(4, label);
            pstmt.setString(5, executableName);
            pstmt.executeUpdate();
            this.transaction.commit();
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error inserting Mach-O string", e);
        }
    }

    public List<Map<String, String>> getMachoStrings() {
        List<Map<String, String>> strings = new ArrayList<>();
        String sql = "SELECT * FROM MachoStrings";

        try (Statement stmt = this.transaction.createStatement();
                ResultSet rs = stmt.executeQuery(sql)) {

            while (rs.next()) {
                Map<String, String> string = new HashMap<>();
                string.put("address", rs.getString("address"));
                string.put("value", rs.getString("value"));
                string.put("segment", rs.getString("segment"));
                string.put("label", rs.getString("label"));
                string.put("ExecutableName", rs.getString("ExecutableName"));
                strings.add(string);
            }
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error getting Mach-O strings", e);
        }
        return strings;
    }

    public void insertResourceString(String resourceId, String value, String type) {
        String sql = "INSERT INTO ResourceStrings(resourceId, value, type) VALUES(?,?,?)";

        try (PreparedStatement pstmt = this.transaction.prepareStatement(sql)) {
            pstmt.setString(1, resourceId);
            pstmt.setString(2, value);
            pstmt.setString(3, type);
            pstmt.executeUpdate();
            this.transaction.commit();
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error inserting resource string", e);
        }
    }

    public List<Map<String, String>> getResourceStrings() {
        List<Map<String, String>> strings = new ArrayList<>();
        String sql = "SELECT * FROM ResourceStrings";

        try (Statement stmt = this.transaction.createStatement();
                ResultSet rs = stmt.executeQuery(sql)) {

            while (rs.next()) {
                Map<String, String> string = new HashMap<>();
                string.put("resourceId", rs.getString("resourceId"));
                string.put("value", rs.getString("value"));
                string.put("type", rs.getString("type"));
                strings.add(string);
            }
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error getting resource strings", e);
        }
        return strings;
    }

    public void insertFunctionReferences(List<SyntaxParser.FunctionRefResult> functionRefs) {
        Connection conn = this.transaction;
        try {
            String sql = "INSERT INTO FunctionReferences(sourceFunction, sourceClass, "
                    + "targetFunction, targetClass, lineNumber, ExecutableName) "
                    + "SELECT ?, ?, ?, ?, ?, ? "
                    + "WHERE NOT EXISTS (SELECT 1 FROM FunctionReferences "
                    + "WHERE sourceFunction = ? AND sourceClass = ? "
                    + "AND targetFunction = ? AND targetClass = ? "
                    + "AND lineNumber = ? AND ExecutableName = ?)";
            try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
                for (SyntaxParser.FunctionRefResult ref : functionRefs) {
                    // Parameters for INSERT
                    pstmt.setString(1, ref.sourceFunction);
                    pstmt.setString(2, ref.sourceClass);
                    pstmt.setString(3, ref.targetFunction);
                    pstmt.setString(4, ref.targetClass);
                    pstmt.setInt(5, ref.lineNumber);
                    pstmt.setString(6, ref.executableName);
                    // Parameters for WHERE NOT EXISTS
                    pstmt.setString(7, ref.sourceFunction);
                    pstmt.setString(8, ref.sourceClass);
                    pstmt.setString(9, ref.targetFunction);
                    pstmt.setString(10, ref.targetClass);
                    pstmt.setInt(11, ref.lineNumber);
                    pstmt.setString(12, ref.executableName);
                    pstmt.addBatch();
                }
                pstmt.executeBatch();
            }

            conn.commit();
        } catch (

        SQLException e) {
            LOGGER.log(Level.SEVERE, "Error inserting function references", e);
        }
    }

    public void insertFunctionReference(Connection transaction, String sourceFunction, String sourceClass,
            String targetFunction, String targetClass, int lineNumber, String executableName) {
        String sql = "INSERT INTO FunctionReferences(sourceFunction, sourceClass, "
                + "targetFunction, targetClass, lineNumber, ExecutableName) "
                + "SELECT ?, ?, ?, ?, ?, ? "
                + "WHERE NOT EXISTS (SELECT 1 FROM FunctionReferences "
                + "WHERE sourceFunction = ? AND sourceClass = ? "
                + "AND targetFunction = ? AND targetClass = ? "
                + "AND lineNumber = ? AND ExecutableName = ?)";

        try (PreparedStatement pstmt = transaction.prepareStatement(sql)) {
            // Parameters for INSERT
            pstmt.setString(1, sourceFunction);
            pstmt.setString(2, sourceClass);
            pstmt.setString(3, targetFunction);
            pstmt.setString(4, targetClass);
            pstmt.setInt(5, lineNumber);
            pstmt.setString(6, executableName);
            // Parameters for WHERE NOT EXISTS
            pstmt.setString(7, sourceFunction);
            pstmt.setString(8, sourceClass);
            pstmt.setString(9, targetFunction);
            pstmt.setString(10, targetClass);
            pstmt.setInt(11, lineNumber);
            pstmt.setString(12, executableName);
            pstmt.executeUpdate();
            this.transaction.commit();
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error inserting function reference", e);
        }
    }

    public void insertLocalVariableReferences(List<SyntaxParser.VariableRefResult> refs) {
        String sql = "INSERT OR IGNORE INTO LocalVariableReferences(variableName, containingFunction, "
                + "containingClass, lineNumber, ExecutableName) VALUES (?, ?, ?, ?, ?)";

        try (PreparedStatement pstmt = this.transaction.prepareStatement(sql)) {
            for (SyntaxParser.VariableRefResult ref : refs) {
                pstmt.setString(1, ref.variableName);
                pstmt.setString(2, ref.functionName);
                pstmt.setString(3, ref.className);
                pstmt.setInt(4, ref.lineNumber);
                pstmt.setString(5, ref.executableName);
                pstmt.addBatch();
            }
            pstmt.executeBatch();
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error inserting local variable references", e);
        }
    }

    public void insertLocalVariableReference(Connection transaction, String variableName, String containingFunction,
            String containingClass, int lineNumber, String executableName) {
        String sql = "INSERT INTO LocalVariableReferences(variableName, containingFunction, "
                + "containingClass, lineNumber, ExecutableName) "
                + "SELECT ?, ?, ?, ?, ? "
                + "WHERE NOT EXISTS (SELECT 1 FROM LocalVariableReferences "
                + "WHERE variableName = ? AND containingFunction = ? "
                + "AND containingClass = ? AND lineNumber = ? AND ExecutableName = ?)";

        try (PreparedStatement pstmt = transaction.prepareStatement(sql)) {
            // Parameters for INSERT
            pstmt.setString(1, variableName);
            pstmt.setString(2, containingFunction);
            pstmt.setString(3, containingClass);
            pstmt.setInt(4, lineNumber);
            pstmt.setString(5, executableName);
            // Parameters for WHERE NOT EXISTS
            pstmt.setString(6, variableName);
            pstmt.setString(7, containingFunction);
            pstmt.setString(8, containingClass);
            pstmt.setInt(9, lineNumber);
            pstmt.setString(10, executableName);
            pstmt.executeUpdate();
            this.transaction.commit();
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error inserting local variable reference", e);
        }
    }

    public List<Map<String, String>> getFunctionCrossReferences(String functionName) {
        List<Map<String, String>> references = new ArrayList<>();

        String sql = "SELECT 'FUNCTION' as refType, sourceFunction, sourceClass, "
                + "targetFunction as target, targetClass, lineNumber FROM FunctionReferences WHERE "
                + "targetFunction = ?";

        try (PreparedStatement pstmt = this.transaction.prepareStatement(sql)) {

            pstmt.setString(1, functionName);

            try (ResultSet rs = pstmt.executeQuery()) {
                while (rs.next()) {
                    Map<String, String> reference = new HashMap<>();
                    reference.put("referenceType", rs.getString("refType"));
                    reference.put("sourceFunction", rs.getString("sourceFunction"));
                    reference.put("sourceClass", rs.getString("sourceClass"));
                    reference.put("targetFunction", rs.getString("target"));
                    reference.put("targetClass", rs.getString("targetClass"));
                    reference.put("lineNumber", String.valueOf(rs.getInt("lineNumber")));
                    references.add(reference);
                }
            }
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error getting function cross references", e);
        }
        return references;
    }

    public List<Map<String, String>> getTypeInformation(String functionName, String className, String executableName) {
        List<Map<String, String>> types = new ArrayList<>();
        String sql = "SELECT * FROM TypeInformation WHERE functionName = ? AND className = ? AND ExecutableName = ?";

        try (PreparedStatement pstmt = this.transaction.prepareStatement(sql)) {
            pstmt.setString(1, functionName);
            pstmt.setString(2, className);
            pstmt.setString(3, executableName);

            try (ResultSet rs = pstmt.executeQuery()) {
                while (rs.next()) {
                    Map<String, String> type = new HashMap<>();
                    type.put("variableName", rs.getString("variableName"));
                    type.put("variableType", rs.getString("variableType"));
                    type.put("lineNumber", String.valueOf(rs.getInt("lineNumber")));
                    types.add(type);
                }
            }
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error getting type information", e);
        }
        return types;
    }

    public void insertTypeInformations(List<SyntaxParser.TypeInfoResult> typeInfos) {
        String sql = "INSERT INTO TypeInformation(variableName, variableType, functionName, "
                + "className, lineNumber, ExecutableName) VALUES(?,?,?,?,?,?)";

        try (PreparedStatement pstmt = this.transaction.prepareStatement(sql)) {
            for (SyntaxParser.TypeInfoResult info : typeInfos) {
                pstmt.setString(1, info.variableName);
                pstmt.setString(2, info.variableType);
                pstmt.setString(3, info.functionName);
                pstmt.setString(4, info.className);
                pstmt.setInt(5, info.lineNumber);
                pstmt.setString(6, info.executableName);
                pstmt.addBatch();
            }
            pstmt.executeBatch();
            this.transaction.commit();
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error inserting type information", e);
        }
    }

    public void insertTypeInformation(Connection transaction, String variableName, String variableType,
            String functionName, String className, int lineNumber, String executableName) {
        String sql = "INSERT INTO TypeInformation(variableName, variableType, functionName, "
                + "className, lineNumber, ExecutableName) VALUES(?,?,?,?,?,?)";

        try (PreparedStatement pstmt = transaction.prepareStatement(sql)) {
            pstmt.setString(1, variableName);
            pstmt.setString(2, variableType);
            pstmt.setString(3, functionName);
            pstmt.setString(4, className);
            pstmt.setInt(5, lineNumber);
            pstmt.setString(6, executableName);
            pstmt.executeUpdate();
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error inserting type information", e);
        }
    }

    public List<Map<String, String>> getLocalVariableReferences(String variableName, String className,
            String functionName, String executableName) {
        List<Map<String, String>> references = new ArrayList<>();
        String sql = "SELECT * FROM LocalVariableReferences WHERE variableName = ? "
                + "AND containingClass = ? "
                + "AND containingFunction = ?";

        try (PreparedStatement pstmt = this.transaction.prepareStatement(sql)) {
            pstmt.setString(1, variableName);
            pstmt.setString(2, className);
            pstmt.setString(3, functionName);

            try (ResultSet rs = pstmt.executeQuery()) {
                while (rs.next()) {
                    Map<String, String> reference = new HashMap<>();
                    reference.put("variableName", rs.getString("variableName"));
                    reference.put("containingFunction", rs.getString("containingFunction"));
                    reference.put("containingClass", rs.getString("containingClass"));
                    reference.put("lineNumber", String.valueOf(rs.getInt("lineNumber")));
                    references.add(reference);
                }
            }
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error getting local variable references", e);
            e.printStackTrace();
        }
        return references;
    }

    public boolean isFunctionName(String functionName) {
        String sql = "SELECT 1 FROM Functions WHERE FunctionName = ?";

        try (PreparedStatement pstmt = this.transaction.prepareStatement(sql)) {
            pstmt.setString(1, functionName);

            try (ResultSet rs = pstmt.executeQuery()) {
                return rs.next();
            }
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error checking function name", e);
            return false;
        }
    }

    public void insertFunction(String functionName, String parentClass, String executableName) {
        String sql = "INSERT INTO Functions(FunctionName, ParentClass, ExecutableName) VALUES(?,?,?)";

        try (PreparedStatement pstmt = this.transaction.prepareStatement(sql)) {
            pstmt.setString(1, functionName);
            pstmt.setString(2, parentClass);
            pstmt.setString(3, executableName);
            pstmt.executeUpdate();
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error inserting function", e);
        }
    }

    public String getExecutableNameForClass(String className) {
        String sql = "SELECT ExecutableName FROM Classes WHERE ClassName = ?";

        try (PreparedStatement pstmt = this.transaction.prepareStatement(sql)) {
            pstmt.setString(1, className);

            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    return rs.getString("ExecutableName");
                }
            }
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error retrieving executable name for class", e);
        }
        return null;
    }

    public List<Map<String, String>> searchCodebase(String searchTerm) {
        List<Map<String, String>> results = new ArrayList<>();
        String termPattern = "%" + searchTerm.toLowerCase() + "%";

        // Search in Functions
        String sqlFunctions = "SELECT 'Function' as type, FunctionName as name, "
                + "ParentClass as container, ExecutableName "
                + "FROM Functions WHERE LOWER(FunctionName) LIKE ?";

        // Search in LocalVariableReferences
        String sqlVariables = "SELECT 'Variable' as type, variableName as name, "
                + "containingFunction || ' in ' || containingClass as container, "
                + "ExecutableName, lineNumber "
                + "FROM LocalVariableReferences WHERE LOWER(variableName) LIKE ?";

        // Search in Classes
        String sqlClasses = "SELECT 'Class' as type, ClassName as name, "
                + "ExecutableName as container, ExecutableName "
                + "FROM Classes WHERE LOWER(ClassName) LIKE ?";

        Connection conn = this.transaction;
        try {
            // Search Functions
            try (PreparedStatement pstmt = this.transaction.prepareStatement(sqlFunctions)) {
                pstmt.setString(1, termPattern);
                try (ResultSet rs = pstmt.executeQuery()) {
                    while (rs.next()) {
                        Map<String, String> result = new HashMap<>();
                        result.put("type", rs.getString("type"));
                        result.put("name", rs.getString("name"));
                        result.put("container", rs.getString("container"));
                        result.put("executable", rs.getString("ExecutableName"));
                        result.put("line", "");
                        results.add(result);
                    }
                }
            }

            // Search Variables
            try (PreparedStatement pstmt = conn.prepareStatement(sqlVariables)) {
                pstmt.setString(1, termPattern);
                try (ResultSet rs = pstmt.executeQuery()) {
                    while (rs.next()) {
                        Map<String, String> result = new HashMap<>();
                        result.put("type", rs.getString("type"));
                        result.put("name", rs.getString("name"));
                        result.put("container", rs.getString("container"));
                        result.put("executable", rs.getString("ExecutableName"));
                        result.put("line", rs.getString("lineNumber"));
                        results.add(result);
                    }
                }
            }

            // Search Classes
            try (PreparedStatement pstmt = conn.prepareStatement(sqlClasses)) {
                pstmt.setString(1, termPattern);
                try (ResultSet rs = pstmt.executeQuery()) {
                    while (rs.next()) {
                        Map<String, String> result = new HashMap<>();
                        result.put("type", rs.getString("type"));
                        result.put("name", rs.getString("name"));
                        result.put("container", rs.getString("container"));
                        result.put("executable", rs.getString("ExecutableName"));
                        result.put("line", "");
                        results.add(result);
                    }
                }
            }
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error searching codebase", e);
        }

        return results;
    }

    public Map<String, List<String>> getMainExecutableClasses(String infoPlistExecutableName) {
        Map<String, List<String>> classFunctionMap = new HashMap<>();
        String sql = "SELECT ClassName, Functions FROM Classes WHERE ExecutableName = ?";

        Connection conn = this.transaction;
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setString(1, infoPlistExecutableName);

            try (ResultSet rs = pstmt.executeQuery()) {
                while (rs.next()) {
                    String className = rs.getString("ClassName");
                    String functionsJson = rs.getString("Functions");
                    List<String> functions = parseFunctions(functionsJson);
                    classFunctionMap.put(className, functions);
                }
            }
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, "Error getting main executable classes", e);
        }
        return classFunctionMap;
    }
}

```

`src/main/java/com/lauriewired/malimite/decompile/DemangleSwift.java`:

```java
package com.lauriewired.malimite.decompile;

import java.util.logging.Logger;
import java.util.logging.Level;

public class DemangleSwift {
    private static final Logger LOGGER = Logger.getLogger(DemangleSwift.class.getName());

    public static class DemangledName {
        public final String className;
        public final String fullMethodName;

        public DemangledName(String className, String fullMethodName) {
            this.className = className;
            this.fullMethodName = fullMethodName;
        }
    }

    public static DemangledName demangleSwiftName(String mangledName) {
        if (mangledName == null || !mangledName.startsWith("_$s")) {
            return null; // Not a valid Swift mangled name
        }

        try {
            // Drop the _$s prefix
            String remaining = mangledName.substring(3);

            // Extract the class name
            int classNameLength = extractNumber(remaining);
            String className = remaining.substring(String.valueOf(classNameLength).length(),
                                                   String.valueOf(classNameLength).length() + classNameLength);

            // Move past the class name
            remaining = remaining.substring(String.valueOf(classNameLength).length() + classNameLength);

            // Extract the method name
            StringBuilder methodNameBuilder = new StringBuilder();

            while (!remaining.isEmpty()) {
                // Skip leading zeros and extract the next number
                int numberIndex = findNextNumberIndex(remaining);
                if (numberIndex == -1) break; // No more numbers, exit loop

                String remainingAfterNumber = remaining.substring(numberIndex);
                int length = extractNumber(remainingAfterNumber);

                // Skip the number itself in the string
                int numberLength = String.valueOf(length).length();
                String segment = remainingAfterNumber.substring(numberLength, numberLength + length);
                methodNameBuilder.append(segment);

                // Update the remaining string
                remaining = remainingAfterNumber.substring(numberLength + length);
            }

            String methodName = methodNameBuilder.toString();
            return new DemangledName(className, methodName);
        } catch (Exception e) {
            System.err.println("Failed to demangle Swift name: " + mangledName);
            e.printStackTrace();
        }

        return null;
    }

    private static int findNextNumberIndex(String str) {
        for (int i = 0; i < str.length(); i++) {
            if (Character.isDigit(str.charAt(i)) && str.charAt(i) != '0') {
                return i; // Return index of the first non-zero digit
            }
        }
        return -1; // No valid number found
    }

    private static int extractNumber(String str) {
        StringBuilder numberBuilder = new StringBuilder();
        boolean leadingZeroSkipped = false;

        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            if (Character.isDigit(c)) {
                if (c != '0' || leadingZeroSkipped) {
                    numberBuilder.append(c);
                    leadingZeroSkipped = true;
                }
            } else {
                break; // Stop when we reach a non-digit
            }
        }
        return numberBuilder.length() > 0 ? Integer.parseInt(numberBuilder.toString()) : 0;
    }
} 
```

`src/main/java/com/lauriewired/malimite/decompile/DynamicDecompile.java`:

```java
package com.lauriewired.malimite.decompile;

import com.lauriewired.malimite.ui.AnalysisWindow;
import com.lauriewired.malimite.configuration.Config;
import com.lauriewired.malimite.database.SQLiteDBHandler;
import com.lauriewired.malimite.files.Macho;
import com.lauriewired.malimite.utils.FileProcessing;
import java.io.File;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import java.util.HashMap;
import java.util.Enumeration;
import javax.swing.JTree;
import javax.swing.tree.TreePath;
import javax.swing.JDialog;
import javax.swing.JPanel;
import javax.swing.JProgressBar;
import javax.swing.JLabel;
import javax.swing.JTextArea;
import javax.swing.JScrollPane;
import javax.swing.BorderFactory;
import javax.swing.SwingUtilities;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import java.awt.BorderLayout;
import java.util.logging.Level;
import javax.swing.SwingWorker;

public class DynamicDecompile {
    private static final Logger LOGGER = Logger.getLogger(DynamicDecompile.class.getName());

    public static void decompileFile(String filePath, String projectDirectoryPath, String fullFilePath, Config config, 
            SQLiteDBHandler dbHandler, String infoPlistExecutableName, DefaultTreeModel treeModel, JTree fileTree) {
                
        // Create and configure progress dialog
        JDialog progressDialog = new JDialog((JFrame)SwingUtilities.getWindowAncestor(fileTree), "Analyzing File", false);
        progressDialog.setAlwaysOnTop(true);
        progressDialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);
        JPanel panel = new JPanel(new BorderLayout(10, 10));
        panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        
        // Add progress components
        JProgressBar progressBar = new JProgressBar();
        progressBar.setIndeterminate(true);
        JLabel statusLabel = new JLabel("Analyzing file...");
        
        // Add console output area
        JTextArea consoleOutput = new JTextArea(10, 50);
        consoleOutput.setEditable(false);
        JScrollPane scrollPane = new JScrollPane(consoleOutput);
        
        // Add components to panel
        panel.add(statusLabel, BorderLayout.NORTH);
        panel.add(progressBar, BorderLayout.CENTER);
        panel.add(scrollPane, BorderLayout.SOUTH);
        
        progressDialog.add(panel);
        progressDialog.pack();
        progressDialog.setLocationRelativeTo(fileTree);

        // Create SwingWorker for background processing
        SwingWorker<Void, String> worker = new SwingWorker<Void, String>() {
            @Override
            protected Void doInBackground() throws Exception {
                try {
                    publish("Starting analysis of: " + fullFilePath);
                    LOGGER.info("Decompiling: " + fullFilePath);
                    
                    File file = new File(fullFilePath);
                    String fileName = file.getName();
                    
                    publish("Opening project...");
                    FileProcessing.openProject(
                        filePath,
                        projectDirectoryPath, 
                        fileName,
                        config.getConfigDirectory(),
                        true
                    );

                    String extractedMachoPath = projectDirectoryPath + File.separator + fileName;
                    publish("Creating Macho object...");
                    Macho targetMacho = new Macho(extractedMachoPath, projectDirectoryPath, fileName);

                    publish("Starting Ghidra analysis...");
                    GhidraProject ghidraProject = new GhidraProject(
                        infoPlistExecutableName, 
                        extractedMachoPath, 
                        config, 
                        dbHandler,
                        // Pass console output callback
                        message -> publish(message)
                    );
                    
                    ghidraProject.decompileMacho(extractedMachoPath, projectDirectoryPath, targetMacho, true);
                    
                    return null;
                } catch (Exception e) {
                    publish("Error: " + e.getMessage());
                    throw e;
                }
            }

            @Override
            protected void process(List<String> chunks) {
                // Update console with new messages
                for (String message : chunks) {
                    consoleOutput.append(message + "\n");
                    consoleOutput.setCaretPosition(consoleOutput.getDocument().getLength());
                }
            }

            @Override
            protected void done() {
                try {
                    get(); // Check for exceptions
                    
                    // Update tree on success
                    SwingUtilities.invokeLater(() -> {
                        DefaultMutableTreeNode decompiledNode = addDecompiledNode(treeModel);
                        populateDecompiledNode(decompiledNode, dbHandler, infoPlistExecutableName);
                        AnalysisWindow.populateMachoStringsPanel();

                        // Expand nodes
                        TreePath decompiledPath = new TreePath(decompiledNode.getPath());
                        fileTree.expandPath(decompiledPath);
                        Enumeration<?> decompiledChildren = decompiledNode.children();
                        while (decompiledChildren.hasMoreElements()) {
                            DefaultMutableTreeNode childNode = (DefaultMutableTreeNode) decompiledChildren.nextElement();
                            TreePath childPath = new TreePath(childNode.getPath());
                            fileTree.expandPath(childPath);
                        }
                    });
                    
                } catch (Exception e) {
                    LOGGER.log(Level.SEVERE, "Error during decompilation", e);
                    JOptionPane.showMessageDialog(progressDialog,
                        "Error during decompilation: " + e.getMessage(),
                        "Decompilation Error",
                        JOptionPane.ERROR_MESSAGE);
                } finally {
                    progressDialog.dispose();
                }
            }
        };

        // Start the worker and show dialog
        worker.execute();
        progressDialog.setVisible(true);
    }

    private static DefaultMutableTreeNode addDecompiledNode(DefaultTreeModel treeModel) {
        // Get the invisible root node
        DefaultMutableTreeNode rootNode = (DefaultMutableTreeNode) treeModel.getRoot();
        
        // Check if the "Decompiled" node already exists
        Enumeration<?> children = rootNode.children();
        while (children.hasMoreElements()) {
            DefaultMutableTreeNode child = (DefaultMutableTreeNode) children.nextElement();
            if ("Decompiled".equals(child.getUserObject().toString())) {
                return child; // Return the existing "Decompiled" node
            }
        }
        
        // If not found, create a new "Decompiled" node
        DefaultMutableTreeNode decompiledNode = new DefaultMutableTreeNode("Decompiled");
        rootNode.add(decompiledNode);
        treeModel.reload(rootNode);
        return decompiledNode;
    }

    private static void populateDecompiledNode(DefaultMutableTreeNode decompiledNode, SQLiteDBHandler dbHandler, String infoPlistExecutableName) {
        Map<String, List<String>> classesAndFunctions = dbHandler.getAllClassesAndFunctions();
        Map<String, DefaultMutableTreeNode> executableNodes = new HashMap<>();
        
        for (Map.Entry<String, List<String>> entry : classesAndFunctions.entrySet()) {
            String className = entry.getKey();
            List<String> functions = entry.getValue();
            
            // Retrieve the executable name for the current class
            String executableName = dbHandler.getExecutableNameForClass(className);
            
            // Check if the class belongs to the specified executable
            if (!infoPlistExecutableName.equals(executableName)) {
                // Get or create the node for this executable
                DefaultMutableTreeNode executableNode = executableNodes.computeIfAbsent(executableName, k -> {
                    DefaultMutableTreeNode node = new DefaultMutableTreeNode(executableName);
                    decompiledNode.add(node);
                    return node;
                });
                
                // Create a node for the class
                DefaultMutableTreeNode classNode = new DefaultMutableTreeNode(className);
                
                // Add function nodes under the class node
                for (String function : functions) {
                    classNode.add(new DefaultMutableTreeNode(function));
                }
                
                // Add the class node under the executable node
                executableNode.add(classNode);
            }
        }
    }

    public static void repopulateDecompiledNode(DefaultTreeModel treeModel, SQLiteDBHandler dbHandler, String infoPlistExecutableName) {
        DefaultMutableTreeNode decompiledNode = addDecompiledNode(treeModel);
        decompiledNode.removeAllChildren(); // Clear existing children before repopulating
        populateDecompiledNode(decompiledNode, dbHandler, infoPlistExecutableName);

        // Only add the "Decompiled" node if it has children
        if (decompiledNode.getChildCount() > 0) {
            treeModel.reload(decompiledNode);
        } else {
            // Remove the "Decompiled" node if it has no children
            ((DefaultMutableTreeNode) treeModel.getRoot()).remove(decompiledNode);
            treeModel.reload();
        }
    }
}

```

`src/main/java/com/lauriewired/malimite/decompile/GhidraProject.java`:

```java
package com.lauriewired.malimite.decompile;

import com.lauriewired.malimite.files.Macho;
import com.lauriewired.malimite.configuration.Config;
import com.lauriewired.malimite.configuration.LibraryDefinitions;
import com.lauriewired.malimite.database.SQLiteDBHandler;

import java.nio.file.Paths;
import java.net.ServerSocket;
import java.net.Socket;
import java.io.*;

import org.json.JSONArray;
import org.json.JSONObject;

import java.util.logging.Logger;
import java.util.logging.Level;

import java.util.function.Consumer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.List;

public class GhidraProject {
    private static final Logger LOGGER = Logger.getLogger(GhidraProject.class.getName());
    private String ghidraProjectName;
    private Config config;
    private String scriptPath;
    private SQLiteDBHandler dbHandler;
    private static final int BASE_PORT = 8765;
    private static final int MAX_PORT_ATTEMPTS = 10;
    private Consumer<String> consoleOutputCallback;

    public GhidraProject(String infoPlistBundleExecutable, String executableFilePath, Config config, SQLiteDBHandler dbHandler, Consumer<String> consoleOutputCallback) {
        this.ghidraProjectName = infoPlistBundleExecutable + "_malimite";
        this.config = config;
        this.dbHandler = dbHandler;
        this.consoleOutputCallback = consoleOutputCallback;
        // Set script path based on current directory and OS
        String currentDir = System.getProperty("user.dir");
        this.scriptPath = Paths.get(currentDir, "DecompilerBridge", "ghidra").toString();

        LOGGER.info("Initializing GhidraProject with executable: " + infoPlistBundleExecutable);
        LOGGER.info("Script path: " + scriptPath);
    }

    public void decompileMacho(String executableFilePath, String projectDirectoryPath, Macho targetMacho, boolean dynamicFile) {
        LOGGER.info("Starting Ghidra decompilation for: " + executableFilePath);
        
        // Try ports until we find an available one
        ServerSocket serverSocket = null;
        int port = BASE_PORT;
        int attempts = 0;
        
        while (attempts < MAX_PORT_ATTEMPTS && serverSocket == null) {
            try {
                serverSocket = new ServerSocket(port);
                LOGGER.info("Successfully bound to port " + port);
            } catch (IOException e) {
                LOGGER.warning("Port " + port + " is in use, trying next port");
                port++;
                attempts++;
                if (attempts >= MAX_PORT_ATTEMPTS) {
                    throw new RuntimeException("Unable to find available port after " + MAX_PORT_ATTEMPTS + " attempts");
                }
            }
        }

        try (ServerSocket finalServerSocket = serverSocket) {  // Ensure socket gets closed
            String analyzeHeadless = getAnalyzeHeadlessPath();
            
            // Get active libraries and join them with commas
            List<String> activeLibraries = LibraryDefinitions.getActiveLibraries(config);
            String librariesArg = String.join(",", activeLibraries);

            ProcessBuilder builder = new ProcessBuilder(    
                analyzeHeadless,
                projectDirectoryPath,
                this.ghidraProjectName,
                "-import",
                executableFilePath,
                "-scriptPath",
                scriptPath,
                "-postScript",
                "DumpClassData.java",
                String.valueOf(port),  // Use the port we found
                librariesArg,
                "-enableAnalyzer", "Objective-C",
                "-enableAnalyzer", "String Extraction",
                "-disableAnalyzer", "Decompiler Parameter ID",
                "-disableAnalyzer", "DWARF",
                "-skipAnalysisPrompt",
                "-deleteProject"
            );
            
            // Redirect Ghidra's output and error streams
            builder.redirectErrorStream(true);
            Process process = builder.start();

            // Read Ghidra's output in a separate thread
            Thread outputThread = new Thread(() -> {
                try (BufferedReader ghidraOutput = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
                    String line;
                    while ((line = ghidraOutput.readLine()) != null) {
                        final String outputLine = line;
                        if (consoleOutputCallback != null) {
                            consoleOutputCallback.accept("Ghidra: " + outputLine);
                        }
                        System.out.println("Ghidra Output: " + line);
                    }
                } catch (IOException e) {
                    LOGGER.log(Level.SEVERE, "Error reading Ghidra output", e);
                }
            });
            outputThread.start();

            LOGGER.info("Starting Ghidra headless analyzer with command: " + String.join(" ", builder.command()));
            LOGGER.info("Waiting for Ghidra script connection on port " + port);
            
            Socket socket = serverSocket.accept();
            socket.setSoTimeout(60000); // 1 minute timeout for heartbeat
            LOGGER.info("Connection established with Ghidra script");

            try (BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {
                // Wait for heartbeat
                String heartbeat = in.readLine();
                if (!"HEARTBEAT".equals(heartbeat)) {
                    throw new RuntimeException("Did not receive heartbeat from Ghidra script");
                }
                LOGGER.info("Received heartbeat from Ghidra script");
                
                // Close the initial heartbeat connection
                socket.close();
                
                // Accept the new connection for actual data transfer
                socket = serverSocket.accept();
                socket.setSoTimeout(0); // No timeout for data transfer
            }

            // Start new try-with-resources for data transfer
            try (BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {
                // Continue with the rest of the connection handling
                String connectionConfirmation = in.readLine();
                if (!"CONNECTED".equals(connectionConfirmation)) {
                    throw new RuntimeException("Did not receive proper connection confirmation from Ghidra script");
                }
                LOGGER.info("Ghidra script confirmed connection, beginning analysis");

                LOGGER.info("Reading class data from Ghidra script");
                String line;
                StringBuilder classDataBuilder = new StringBuilder();
                while (!(line = in.readLine()).equals("END_CLASS_DATA")) {
                    classDataBuilder.append(line).append("\n");
                }

                LOGGER.info("Reading Mach-O data from Ghidra script");
                StringBuilder machoDataBuilder = new StringBuilder();
                while (!(line = in.readLine()).equals("END_MACHO_DATA")) {
                    machoDataBuilder.append(line).append("\n");
                }

                LOGGER.info("Reading function decompilation data from Ghidra script");
                StringBuilder functionDataBuilder = new StringBuilder();
                while (!(line = in.readLine()).equals("END_DATA")) {
                    functionDataBuilder.append(line).append("\n");
                }

                // Add this new section to process strings
                LOGGER.info("Reading string data from Ghidra script");
                StringBuilder stringDataBuilder = new StringBuilder();
                while (!(line = in.readLine()).equals("END_STRING_DATA")) {
                    stringDataBuilder.append(line).append("\n");
                }

                // Process and store the received data
                JSONArray classData = new JSONArray(classDataBuilder.toString());
                JSONArray functionData = new JSONArray(functionDataBuilder.toString());
                JSONArray stringData = new JSONArray(stringDataBuilder.toString());
                LOGGER.info("Processing " + classData.length() + " classes and " + functionData.length() + " functions from Ghidra analysis");
                
                // Process both class and function data together
                Map<String, JSONArray> classToFunctions = new HashMap<>();
                Map<String, String> classNameMapping = new HashMap<>();

                // First pass: organize functions by class and demangle class names
                // Use parallelStream to process functionData in parallel
                ArrayList<SQLiteDBHandler.DecompilationResult> decompilationResults = new ArrayList<>();
                ArrayList<SyntaxParser> syntaxParsers = new ArrayList<>();

                functionData.toList().parallelStream().forEach(obj -> {
                    JSONObject functionObj = new JSONObject((Map<?, ?>) obj);
                    String functionName = functionObj.getString("FunctionName");
                    String className = functionObj.getString("ClassName");
                    String decompiledCode = functionObj.getString("DecompiledCode");

                    // For Swift binaries, get the class name from the function name
                    if (!config.isMac() && targetMacho.isSwift() && functionName.startsWith("_$s")) {
                        DemangleSwift.DemangledName demangledName = DemangleSwift.demangleSwiftName(functionName);
                        if (demangledName != null) {
                            LOGGER.info("Demangled function name from " + functionName + " to " + demangledName.fullMethodName);
                            className = demangledName.className;
                            functionName = demangledName.fullMethodName;
                            LOGGER.info("Using class name from demangled function: " + className);
                        } else {
                            LOGGER.warning("Failed to demangle Swift symbol: " + functionName);
                        }
                    }

                    // Replace empty class name with "Global" after demangling
                    if (className == null || className.trim().isEmpty()) {
                        className = "Global";
                    }

                    // Check if this class should be treated as a library
                    final String finalClassName = className;
                    boolean isLibrary = activeLibraries.stream()
                            .anyMatch(library -> finalClassName.startsWith(library));

                    if (!isLibrary) {
                        // Process and store the decompiled code only for non-library classes
                        decompiledCode = decompiledCode.replaceAll("/\\*.*\\*/", "");  // Remove Ghidra comments

                        // Add headers with the correct class name
                        if (!decompiledCode.trim().startsWith("// Class:") && !decompiledCode.trim().startsWith("// Function:")) {
                            StringBuilder contentBuilder = new StringBuilder();
                            contentBuilder.append("// Class: ").append(className).append("\n");
                            contentBuilder.append("// Function: ").append(functionName).append("\n\n");
                            contentBuilder.append(decompiledCode.trim());
                            decompiledCode = contentBuilder.toString();
                        }

                        String message = "Storing decompilation for " + className + "::" + functionName;
                        LOGGER.info(message);
                        if (consoleOutputCallback != null) {
                            consoleOutputCallback.accept(message);
                        }

                        // Store function decompilation with the correct class name and executable name
                        synchronized (decompilationResults) {
                            decompilationResults.add(new SQLiteDBHandler.DecompilationResult(functionName, className, decompiledCode, targetMacho.getMachoExecutableName()));
                        }
                        if (decompiledCode != null && !decompiledCode.trim().isEmpty()) {
                            // Parse the decompiled code for syntax information
                            SyntaxParser syntaxParser = new SyntaxParser(targetMacho.getMachoExecutableName());
                            syntaxParser.setContext(functionName, className);
                            syntaxParser.collectCrossReferences(decompiledCode);
                            synchronized (syntaxParsers) {
                                syntaxParsers.add(syntaxParser);
                            }
                        }

                        // Add to class functions map
                        synchronized (classToFunctions) {
                            classToFunctions.computeIfAbsent(className, k -> new JSONArray())
                                            .put(functionName);
                        }
                    } else {
                        // For library functions, combine class and function names and store under "Libraries"
                        String libraryFunctionName = className + "::" + functionName;
                        String message = "Storing library function: " + libraryFunctionName;
                        LOGGER.info(message);
                        if (consoleOutputCallback != null) {
                            consoleOutputCallback.accept(message);
                        }
                        functionName = libraryFunctionName;

                        // Store the mapping of original class name to "Libraries"
                        synchronized (classNameMapping) {
                            classNameMapping.put(className, "Libraries");
                        }


                        synchronized (decompilationResults) {
                            decompilationResults.add(new SQLiteDBHandler.DecompilationResult(libraryFunctionName, "Libraries", targetMacho.getMachoExecutableName(), targetMacho.getMachoExecutableName()));
                        }

                        // Add to class functions map under "Libraries"
                        synchronized (classToFunctions) {
                            classToFunctions.computeIfAbsent("Libraries", k -> new JSONArray())
                                            .put(libraryFunctionName);
                        }
                    }
                });

                ArrayList<SyntaxParser.TypeInfoResult> typeInfoResults = new ArrayList<>();
                ArrayList<SyntaxParser.FunctionRefResult> functionRefResults = new ArrayList<>();
                ArrayList<SyntaxParser.VariableRefResult> varRefs = new ArrayList<>();
                for (SyntaxParser parser : syntaxParsers) {
                    typeInfoResults.addAll(parser.getTypeInfoResults());
                    functionRefResults.addAll(parser.getFunctionRefResults());
                    varRefs.addAll(parser.getVariableRefResults());
                }
                dbHandler.insertFunctionDecompilations(decompilationResults);
                dbHandler.insertTypeInformations(typeInfoResults);
                dbHandler.insertFunctionReferences(functionRefResults);
                dbHandler.insertLocalVariableReferences(varRefs);

                // Store class data for all classes (including libraries)
                for (Map.Entry<String, JSONArray> entry : classToFunctions.entrySet()) {
                    String className = entry.getKey();
                    JSONArray functions = entry.getValue();
                    LOGGER.info("Inserting class: " + className + " with " + functions.length() + " functions");
                    dbHandler.insertClass(className, functions.toString(), targetMacho.getMachoExecutableName());
                }

                // Process string data
                LOGGER.info("Processing " + stringData.length() + " strings from Ghidra analysis");

                for (int i = 0; i < stringData.length(); i++) {
                    JSONObject stringObj = stringData.getJSONObject(i);
                    String address = stringObj.getString("address");
                    String value = stringObj.getString("value");
                    String segment = stringObj.getString("segment");
                    String label = stringObj.getString("label");
                    LOGGER.info("Inserting string: " + value + " at address: " + address);
                    dbHandler.insertMachoString(address, value, segment, label, targetMacho.getMachoExecutableName());
                }

                LOGGER.info("Finished processing all data");
            }

            process.waitFor();
            LOGGER.info("Ghidra analysis completed successfully");

        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error during Ghidra decompilation", e);
            throw new RuntimeException("Ghidra decompilation failed: " + e.getMessage(), e);
        }
    }    

    private String getAnalyzeHeadlessPath() {
        String analyzeHeadless = Paths.get(config.getGhidraPath(), "support", "analyzeHeadless").toString();
        if (config.isWindows()) {
            analyzeHeadless += ".bat";
        }
        LOGGER.info("Using analyzeHeadless path: " + analyzeHeadless);
        return analyzeHeadless;
    }

}

```

`src/main/java/com/lauriewired/malimite/decompile/SyntaxParser.java`:

```java
package com.lauriewired.malimite.decompile;

import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;

import com.lauriewired.malimite.decompile.antlr.CPP14ParserBaseVisitor;
import com.lauriewired.malimite.decompile.antlr.CPP14Lexer;
import com.lauriewired.malimite.decompile.antlr.CPP14Parser;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

public class SyntaxParser {
    private CPP14Lexer lexer = new CPP14Lexer(null);
    private CPP14Parser parser = new CPP14Parser(new CommonTokenStream(lexer));
    private static final Logger LOGGER = Logger.getLogger(SyntaxParser.class.getName());
    private String currentFunction;
    private String currentClass;
    private String formattedCode;
    private String executableName;
    private ArrayList<FunctionRefResult> funcRefs = new ArrayList<>();
    private ArrayList<TypeInfoResult> typeInfos = new ArrayList<>();
    private ArrayList<VariableRefResult> varRefs = new ArrayList<>();

    public SyntaxParser(String executableName) {
        this.executableName = executableName;
        lexer.removeErrorListeners();
        parser.removeErrorListeners();
    }

    public void setContext(String functionName, String className) {
        this.currentFunction = functionName;
        this.currentClass = className;
    }

    public String parseAndFormatCode(String code) {
        try {
            CharStream input = CharStreams.fromString(code);
            lexer.setInputStream(input);

            CommonTokenStream tokens = new CommonTokenStream(lexer);
            parser.setTokenStream(tokens);

            // Temporarily return unformatted code while testing performance
            return code;
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error parsing code", e);
            return code;
        }
    }

    public void collectCrossReferences(String formattedCode) {
        if (currentFunction == null || currentClass == null) {
            LOGGER.warning("Cannot collect cross-references: missing context");
            return;
        }

        this.formattedCode = formattedCode;
        try {
            CharStream input = CharStreams.fromString(formattedCode);
            lexer.setInputStream(input);

            CommonTokenStream tokens = new CommonTokenStream(lexer);
            parser.setTokenStream(tokens);

            ParseTree tree = parser.translationUnit();
            if (tree == null) {
                LOGGER.warning("Failed to parse code for cross-references");
                return;
            }

            new CrossReferenceVisitor().visit(tree);
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error collecting cross-references", e);
        }
    }

    public ArrayList<SyntaxParser.FunctionRefResult> getFunctionRefResults() {
        return funcRefs;
    }

    public ArrayList<SyntaxParser.TypeInfoResult> getTypeInfoResults() {
        return typeInfos;
    }

    public ArrayList<SyntaxParser.VariableRefResult> getVariableRefResults() {
        return varRefs;
    }

    public class FunctionRefResult {
        public String sourceFunction;
        public String sourceClass;
        public String targetFunction;
        public String targetClass;
        public int lineNumber;
        public String executableName;

        public FunctionRefResult(String sourceFunction, String sourceClass, String targetFunction, String targetClass,
                int lineNumber, String executableName) {
            this.sourceFunction = sourceFunction;
            this.sourceClass = sourceClass;
            this.targetFunction = targetFunction;
            this.targetClass = targetClass;
            this.lineNumber = lineNumber;
            this.executableName = executableName;
        }
    }

    public class TypeInfoResult {
        public String variableName;
        public String variableType;
        public String functionName;
        public String className;
        public int lineNumber;
        public String executableName;

        public TypeInfoResult(String variableName, String variableType, String functionName, String className,
                int lineNumber, String executableName) {
            this.variableName = variableName;
            this.variableType = variableType;
            this.functionName = functionName;
            this.className = className;
            this.lineNumber = lineNumber;
            this.executableName = executableName;
        }
    }

    public class VariableRefResult {
        public String variableName;
        public String functionName;
        public String className;
        public int lineNumber;
        public String executableName;

        public VariableRefResult(String variableName, String functionName, String className, int lineNumber,
                String executableName) {
            this.variableName = variableName;
            this.functionName = functionName;
            this.className = className;
            this.lineNumber = lineNumber;
            this.executableName = executableName;
        }
    }

    private class CrossReferenceVisitor extends CPP14ParserBaseVisitor<Void> {
        @Override
        public Void visitPostfixExpression(CPP14Parser.PostfixExpressionContext ctx) {
            // Only handle function calls
            if (ctx.getChildCount() >= 2 && ctx.getChild(1).getText().equals("(")) {
                String calledFunction = ctx.getChild(0).getText();
                String calledClass = null;

                // Extract the class name if it's a method call (contains ::)
                if (calledFunction.contains("::")) {
                    String[] parts = calledFunction.split("::");
                    calledClass = parts[0];
                    calledFunction = parts[1];
                }

                // Calculate adjusted line number
                int actualLine = calculateActualLineNumber(ctx.getStart().getLine());

                // Store the function reference with adjusted line number
                funcRefs.add(new FunctionRefResult(currentFunction, currentClass, calledFunction,
                        calledClass != null ? calledClass : "Unknown", actualLine, executableName));
            }
            return visitChildren(ctx);
        }

        @Override
        public Void visitDeclarationStatement(CPP14Parser.DeclarationStatementContext ctx) {
            if (ctx.blockDeclaration() != null &&
                    ctx.blockDeclaration().simpleDeclaration() != null) {

                CPP14Parser.SimpleDeclarationContext simpleDecl = ctx.blockDeclaration().simpleDeclaration();

                // Add null check for declSpecifierSeq
                String variableType = "";
                if (simpleDecl.declSpecifierSeq() != null) {
                    variableType = simpleDecl.declSpecifierSeq().getText();
                }

                // Process each declarator in the declaration
                if (simpleDecl.initDeclaratorList() != null) {
                    for (CPP14Parser.InitDeclaratorContext initDecl : simpleDecl.initDeclaratorList()
                            .initDeclarator()) {

                        String variableName = initDecl.declarator().getText();
                        // Clean up variable name (remove initialization if present)
                        if (variableName.contains("=")) {
                            variableName = variableName.substring(0,
                                    variableName.indexOf("=")).trim();
                        }

                        // Use adjusted line numbers when storing references
                        int actualLine = calculateActualLineNumber(ctx.getStart().getLine());

                        // Store the type information
                        typeInfos.add(new TypeInfoResult(variableName, variableType, currentFunction, currentClass, actualLine, executableName));

                        // Store initial local variable reference
                        varRefs.add(new VariableRefResult(variableName, currentFunction, currentClass, actualLine, executableName));
                    }
                }
            }
            return visitChildren(ctx);
        }

        @Override
        public Void visitIdExpression(CPP14Parser.IdExpressionContext ctx) {
            String identifier = ctx.getText();

            // Use adjusted line numbers
            int actualLine = calculateActualLineNumber(ctx.getStart().getLine());

            // Handle class references (contains ::)
            if (identifier.contains("::")) {
                String[] parts = identifier.split("::");
                String referencedClass = parts[0];

                // Store class usage reference
                funcRefs.add(new FunctionRefResult(
                        currentFunction,
                        currentClass,
                        null, // No specific function
                        referencedClass,
                        actualLine,
                        executableName));
            }
            // Handle local variable references
            else {
                // Check if this identifier is in a function call context
                if (!isPartOfFunctionCall(ctx)) {
                    varRefs.add(new VariableRefResult(
                            identifier,
                            currentFunction,
                            currentClass,
                            actualLine,
                            executableName));
                }
            }

            return visitChildren(ctx);
        }

        private boolean isPartOfFunctionCall(CPP14Parser.IdExpressionContext ctx) {
            // Check if this identifier is immediately followed by (
            ParseTree parent = ctx.getParent();
            while (parent != null) {
                if (parent instanceof CPP14Parser.PostfixExpressionContext) {
                    CPP14Parser.PostfixExpressionContext postfix = (CPP14Parser.PostfixExpressionContext) parent;
                    // Check if this is a function call
                    return postfix.getChildCount() >= 2 &&
                            postfix.getChild(1).getText().equals("(");
                }
                parent = parent.getParent();
            }
            return false;
        }

        private int calculateActualLineNumber(int parsedLineNumber) {
            // Count actual code lines up to the parsed line number
            String[] lines = formattedCode.split("\n", parsedLineNumber + 1);
            int actualLineNumber = 0;

            for (int i = 0; i < Math.min(lines.length, parsedLineNumber); i++) {
                actualLineNumber++; // Every line, including empty ones and comments, counts
                String line = lines[i].trim();

                // For multi-line comments, add the additional lines
                if (line.contains("/*")) {
                    int currentLine = i;
                    while (currentLine < lines.length && !lines[currentLine].contains("*/")) {
                        if (currentLine != i) { // Don't double-count the first line
                            actualLineNumber++;
                        }
                        currentLine++;
                    }
                    if (currentLine < lines.length && lines[currentLine].contains("*/")) {
                        if (currentLine != i) { // Don't double-count if comment ends on same line
                            actualLineNumber++;
                        }
                    }
                    i = currentLine;
                }
            }

            return actualLineNumber;
        }
    }
}
```

`src/main/java/com/lauriewired/malimite/decompile/antlr/CPP14Lexer.interp`:

```interp
token literal names:
null
null
null
null
null
null
null
null
null
null
'alignas'
'alignof'
'asm'
'auto'
'bool'
'break'
'case'
'catch'
'char'
'char16_t'
'char32_t'
'class'
'const'
'constexpr'
'const_cast'
'continue'
'decltype'
'default'
'delete'
'do'
'double'
'dynamic_cast'
'else'
'enum'
'explicit'
'export'
'extern'
'false'
'final'
'float'
'for'
'friend'
'goto'
'if'
'inline'
'int'
'long'
'mutable'
'namespace'
'new'
'noexcept'
'nullptr'
'operator'
'override'
'private'
'protected'
'public'
'register'
'reinterpret_cast'
'return'
'short'
'signed'
'sizeof'
'static'
'static_assert'
'static_cast'
'struct'
'switch'
'template'
'this'
'thread_local'
'throw'
'true'
'try'
'typedef'
'typeid'
'typename'
'union'
'unsigned'
'using'
'virtual'
'void'
'volatile'
'wchar_t'
'while'
'('
')'
'['
']'
'{'
'}'
'+'
'-'
'*'
'/'
'%'
'^'
'&'
'|'
'~'
null
'='
'<'
'>'
'+='
'-='
'*='
'/='
'%='
'^='
'&='
'|='
'<<='
'>>='
'=='
'!='
'<='
'>='
null
null
'++'
'--'
','
'->*'
'->'
'?'
':'
'::'
';'
'.'
'.*'
'...'
null
null
null
null
null
null
null
null
null
null
null
null
null
null

token symbolic names:
null
IntegerLiteral
CharacterLiteral
FloatingLiteral
StringLiteral
BooleanLiteral
PointerLiteral
UserDefinedLiteral
MultiLineMacro
Directive
Alignas
Alignof
Asm
Auto
Bool
Break
Case
Catch
Char
Char16
Char32
Class
Const
Constexpr
Const_cast
Continue
Decltype
Default
Delete
Do
Double
Dynamic_cast
Else
Enum
Explicit
Export
Extern
False_
Final
Float
For
Friend
Goto
If
Inline
Int
Long
Mutable
Namespace
New
Noexcept
Nullptr
Operator
Override
Private
Protected
Public
Register
Reinterpret_cast
Return
Short
Signed
Sizeof
Static
Static_assert
Static_cast
Struct
Switch
Template
This
Thread_local
Throw
True_
Try
Typedef
Typeid_
Typename_
Union
Unsigned
Using
Virtual
Void
Volatile
Wchar
While
LeftParen
RightParen
LeftBracket
RightBracket
LeftBrace
RightBrace
Plus
Minus
Star
Div
Mod
Caret
And
Or
Tilde
Not
Assign
Less
Greater
PlusAssign
MinusAssign
StarAssign
DivAssign
ModAssign
XorAssign
AndAssign
OrAssign
LeftShiftAssign
RightShiftAssign
Equal
NotEqual
LessEqual
GreaterEqual
AndAnd
OrOr
PlusPlus
MinusMinus
Comma
ArrowStar
Arrow
Question
Colon
Doublecolon
Semi
Dot
DotStar
Ellipsis
Identifier
DecimalLiteral
OctalLiteral
HexadecimalLiteral
BinaryLiteral
Integersuffix
UserDefinedIntegerLiteral
UserDefinedFloatingLiteral
UserDefinedStringLiteral
UserDefinedCharacterLiteral
Whitespace
Newline
BlockComment
LineComment

rule names:
IntegerLiteral
CharacterLiteral
FloatingLiteral
StringLiteral
BooleanLiteral
PointerLiteral
UserDefinedLiteral
MultiLineMacro
Directive
Alignas
Alignof
Asm
Auto
Bool
Break
Case
Catch
Char
Char16
Char32
Class
Const
Constexpr
Const_cast
Continue
Decltype
Default
Delete
Do
Double
Dynamic_cast
Else
Enum
Explicit
Export
Extern
False_
Final
Float
For
Friend
Goto
If
Inline
Int
Long
Mutable
Namespace
New
Noexcept
Nullptr
Operator
Override
Private
Protected
Public
Register
Reinterpret_cast
Return
Short
Signed
Sizeof
Static
Static_assert
Static_cast
Struct
Switch
Template
This
Thread_local
Throw
True_
Try
Typedef
Typeid_
Typename_
Union
Unsigned
Using
Virtual
Void
Volatile
Wchar
While
LeftParen
RightParen
LeftBracket
RightBracket
LeftBrace
RightBrace
Plus
Minus
Star
Div
Mod
Caret
And
Or
Tilde
Not
Assign
Less
Greater
PlusAssign
MinusAssign
StarAssign
DivAssign
ModAssign
XorAssign
AndAssign
OrAssign
LeftShiftAssign
RightShiftAssign
Equal
NotEqual
LessEqual
GreaterEqual
AndAnd
OrOr
PlusPlus
MinusMinus
Comma
ArrowStar
Arrow
Question
Colon
Doublecolon
Semi
Dot
DotStar
Ellipsis
Hexquad
Universalcharactername
Identifier
Identifiernondigit
NONDIGIT
DIGIT
DecimalLiteral
OctalLiteral
HexadecimalLiteral
BinaryLiteral
NONZERODIGIT
OCTALDIGIT
HEXADECIMALDIGIT
BINARYDIGIT
Integersuffix
Unsignedsuffix
Longsuffix
Longlongsuffix
Cchar
Escapesequence
Simpleescapesequence
Octalescapesequence
Hexadecimalescapesequence
Fractionalconstant
Exponentpart
SIGN
Digitsequence
Floatingsuffix
Encodingprefix
Schar
Rawstring
UserDefinedIntegerLiteral
UserDefinedFloatingLiteral
UserDefinedStringLiteral
UserDefinedCharacterLiteral
Udsuffix
Whitespace
Newline
BlockComment
LineComment

channel names:
DEFAULT_TOKEN_CHANNEL
HIDDEN

mode names:
DEFAULT_MODE

atn:
[4, 0, 145, 1460, 6, -1, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7, 99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2, 104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7, 108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2, 113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7, 117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2, 122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7, 126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2, 131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7, 135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2, 140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7, 144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2, 149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7, 153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2, 158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7, 162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2, 167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 1, 0, 1, 0, 3, 0, 346, 8, 0, 1, 0, 1, 0, 3, 0, 350, 8, 0, 1, 0, 1, 0, 3, 0, 354, 8, 0, 1, 0, 1, 0, 3, 0, 358, 8, 0, 3, 0, 360, 8, 0, 1, 1, 3, 1, 363, 8, 1, 1, 1, 1, 1, 4, 1, 367, 8, 1, 11, 1, 12, 1, 368, 1, 1, 1, 1, 1, 2, 1, 2, 3, 2, 375, 8, 2, 1, 2, 3, 2, 378, 8, 2, 1, 2, 1, 2, 1, 2, 3, 2, 383, 8, 2, 3, 2, 385, 8, 2, 1, 3, 3, 3, 388, 8, 3, 1, 3, 1, 3, 1, 3, 5, 3, 393, 8, 3, 10, 3, 12, 3, 396, 9, 3, 1, 3, 3, 3, 399, 8, 3, 1, 4, 1, 4, 3, 4, 403, 8, 4, 1, 5, 1, 5, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 411, 8, 6, 1, 7, 1, 7, 5, 7, 415, 8, 7, 10, 7, 12, 7, 418, 9, 7, 1, 7, 1, 7, 3, 7, 422, 8, 7, 1, 7, 4, 7, 425, 8, 7, 11, 7, 12, 7, 426, 1, 7, 4, 7, 430, 8, 7, 11, 7, 12, 7, 431, 1, 7, 1, 7, 1, 8, 1, 8, 5, 8, 438, 8, 8, 10, 8, 12, 8, 441, 9, 8, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 39, 1, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 44, 1, 44, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 85, 1, 85, 1, 86, 1, 86, 1, 87, 1, 87, 1, 88, 1, 88, 1, 89, 1, 89, 1, 90, 1, 90, 1, 91, 1, 91, 1, 92, 1, 92, 1, 93, 1, 93, 1, 94, 1, 94, 1, 95, 1, 95, 1, 96, 1, 96, 1, 97, 1, 97, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 99, 3, 99, 1029, 8, 99, 1, 100, 1, 100, 1, 101, 1, 101, 1, 102, 1, 102, 1, 103, 1, 103, 1, 103, 1, 104, 1, 104, 1, 104, 1, 105, 1, 105, 1, 105, 1, 106, 1, 106, 1, 106, 1, 107, 1, 107, 1, 107, 1, 108, 1, 108, 1, 108, 1, 109, 1, 109, 1, 109, 1, 110, 1, 110, 1, 110, 1, 111, 1, 111, 1, 111, 1, 111, 1, 112, 1, 112, 1, 112, 1, 112, 1, 113, 1, 113, 1, 113, 1, 114, 1, 114, 1, 114, 1, 115, 1, 115, 1, 115, 1, 116, 1, 116, 1, 116, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 3, 117, 1086, 8, 117, 1, 118, 1, 118, 1, 118, 1, 118, 3, 118, 1092, 8, 118, 1, 119, 1, 119, 1, 119, 1, 120, 1, 120, 1, 120, 1, 121, 1, 121, 1, 122, 1, 122, 1, 122, 1, 122, 1, 123, 1, 123, 1, 123, 1, 124, 1, 124, 1, 125, 1, 125, 1, 126, 1, 126, 1, 126, 1, 127, 1, 127, 1, 128, 1, 128, 1, 129, 1, 129, 1, 129, 1, 130, 1, 130, 1, 130, 1, 130, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 3, 132, 1142, 8, 132, 1, 133, 1, 133, 1, 133, 5, 133, 1147, 8, 133, 10, 133, 12, 133, 1150, 9, 133, 1, 134, 1, 134, 3, 134, 1154, 8, 134, 1, 135, 1, 135, 1, 136, 1, 136, 1, 137, 1, 137, 3, 137, 1162, 8, 137, 1, 137, 5, 137, 1165, 8, 137, 10, 137, 12, 137, 1168, 9, 137, 1, 138, 1, 138, 3, 138, 1172, 8, 138, 1, 138, 5, 138, 1175, 8, 138, 10, 138, 12, 138, 1178, 9, 138, 1, 139, 1, 139, 1, 139, 1, 139, 3, 139, 1184, 8, 139, 1, 139, 1, 139, 3, 139, 1188, 8, 139, 1, 139, 5, 139, 1191, 8, 139, 10, 139, 12, 139, 1194, 9, 139, 1, 140, 1, 140, 1, 140, 1, 140, 3, 140, 1200, 8, 140, 1, 140, 1, 140, 3, 140, 1204, 8, 140, 1, 140, 5, 140, 1207, 8, 140, 10, 140, 12, 140, 1210, 9, 140, 1, 141, 1, 141, 1, 142, 1, 142, 1, 143, 1, 143, 1, 144, 1, 144, 1, 145, 1, 145, 3, 145, 1222, 8, 145, 1, 145, 1, 145, 3, 145, 1226, 8, 145, 1, 145, 1, 145, 3, 145, 1230, 8, 145, 1, 145, 1, 145, 3, 145, 1234, 8, 145, 3, 145, 1236, 8, 145, 1, 146, 1, 146, 1, 147, 1, 147, 1, 148, 1, 148, 1, 148, 1, 148, 3, 148, 1246, 8, 148, 1, 149, 1, 149, 1, 149, 3, 149, 1251, 8, 149, 1, 150, 1, 150, 1, 150, 3, 150, 1256, 8, 150, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 3, 151, 1279, 8, 151, 1, 151, 3, 151, 1282, 8, 151, 1, 151, 1, 151, 1, 151, 1, 151, 3, 151, 1288, 8, 151, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 3, 152, 1301, 8, 152, 1, 153, 1, 153, 1, 153, 1, 153, 4, 153, 1307, 8, 153, 11, 153, 12, 153, 1308, 1, 154, 3, 154, 1312, 8, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 3, 154, 1319, 8, 154, 1, 155, 1, 155, 3, 155, 1323, 8, 155, 1, 155, 1, 155, 1, 155, 3, 155, 1328, 8, 155, 1, 155, 3, 155, 1331, 8, 155, 1, 156, 1, 156, 1, 157, 1, 157, 3, 157, 1337, 8, 157, 1, 157, 5, 157, 1340, 8, 157, 10, 157, 12, 157, 1343, 9, 157, 1, 158, 1, 158, 1, 159, 1, 159, 1, 159, 3, 159, 1350, 8, 159, 1, 160, 1, 160, 1, 160, 3, 160, 1355, 8, 160, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 5, 161, 1363, 8, 161, 10, 161, 12, 161, 1366, 9, 161, 1, 161, 1, 161, 5, 161, 1370, 8, 161, 10, 161, 12, 161, 1373, 9, 161, 1, 161, 1, 161, 1, 161, 1, 161, 5, 161, 1379, 8, 161, 10, 161, 12, 161, 1382, 9, 161, 1, 161, 1, 161, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 3, 162, 1398, 8, 162, 1, 163, 1, 163, 3, 163, 1402, 8, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 3, 163, 1410, 8, 163, 1, 164, 1, 164, 1, 164, 1, 165, 1, 165, 1, 165, 1, 166, 1, 166, 1, 167, 4, 167, 1421, 8, 167, 11, 167, 12, 167, 1422, 1, 167, 1, 167, 1, 168, 1, 168, 3, 168, 1429, 8, 168, 1, 168, 3, 168, 1432, 8, 168, 1, 168, 1, 168, 1, 169, 1, 169, 1, 169, 1, 169, 5, 169, 1440, 8, 169, 10, 169, 12, 169, 1443, 9, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 170, 1, 170, 1, 170, 1, 170, 5, 170, 1454, 8, 170, 10, 170, 12, 170, 1457, 9, 170, 1, 170, 1, 170, 5, 416, 1364, 1371, 1380, 1441, 0, 171, 1, 1, 3, 2, 5, 3, 7, 4, 9, 5, 11, 6, 13, 7, 15, 8, 17, 9, 19, 10, 21, 11, 23, 12, 25, 13, 27, 14, 29, 15, 31, 16, 33, 17, 35, 18, 37, 19, 39, 20, 41, 21, 43, 22, 45, 23, 47, 24, 49, 25, 51, 26, 53, 27, 55, 28, 57, 29, 59, 30, 61, 31, 63, 32, 65, 33, 67, 34, 69, 35, 71, 36, 73, 37, 75, 38, 77, 39, 79, 40, 81, 41, 83, 42, 85, 43, 87, 44, 89, 45, 91, 46, 93, 47, 95, 48, 97, 49, 99, 50, 101, 51, 103, 52, 105, 53, 107, 54, 109, 55, 111, 56, 113, 57, 115, 58, 117, 59, 119, 60, 121, 61, 123, 62, 125, 63, 127, 64, 129, 65, 131, 66, 133, 67, 135, 68, 137, 69, 139, 70, 141, 71, 143, 72, 145, 73, 147, 74, 149, 75, 151, 76, 153, 77, 155, 78, 157, 79, 159, 80, 161, 81, 163, 82, 165, 83, 167, 84, 169, 85, 171, 86, 173, 87, 175, 88, 177, 89, 179, 90, 181, 91, 183, 92, 185, 93, 187, 94, 189, 95, 191, 96, 193, 97, 195, 98, 197, 99, 199, 100, 201, 101, 203, 102, 205, 103, 207, 104, 209, 105, 211, 106, 213, 107, 215, 108, 217, 109, 219, 110, 221, 111, 223, 112, 225, 113, 227, 114, 229, 115, 231, 116, 233, 117, 235, 118, 237, 119, 239, 120, 241, 121, 243, 122, 245, 123, 247, 124, 249, 125, 251, 126, 253, 127, 255, 128, 257, 129, 259, 130, 261, 131, 263, 0, 265, 0, 267, 132, 269, 0, 271, 0, 273, 0, 275, 133, 277, 134, 279, 135, 281, 136, 283, 0, 285, 0, 287, 0, 289, 0, 291, 137, 293, 0, 295, 0, 297, 0, 299, 0, 301, 0, 303, 0, 305, 0, 307, 0, 309, 0, 311, 0, 313, 0, 315, 0, 317, 0, 319, 0, 321, 0, 323, 0, 325, 138, 327, 139, 329, 140, 331, 141, 333, 0, 335, 142, 337, 143, 339, 144, 341, 145, 1, 0, 20, 3, 0, 76, 76, 85, 85, 117, 117, 1, 0, 10, 10, 3, 0, 65, 90, 95, 95, 97, 122, 1, 0, 48, 57, 1, 0, 49, 57, 1, 0, 48, 55, 3, 0, 48, 57, 65, 70, 97, 102, 1, 0, 48, 49, 2, 0, 85, 85, 117, 117, 2, 0, 76, 76, 108, 108, 4, 0, 10, 10, 13, 13, 39, 39, 92, 92, 2, 0, 43, 43, 45, 45, 4, 0, 70, 70, 76, 76, 102, 102, 108, 108, 4, 0, 10, 10, 13, 13, 34, 34, 92, 92, 2, 0, 34, 34, 40, 41, 4, 0, 10, 10, 13, 13, 32, 32, 40, 40, 1, 0, 41, 41, 4, 0, 10, 10, 13, 13, 32, 32, 34, 34, 2, 0, 9, 9, 32, 32, 2, 0, 10, 10, 13, 13, 1528, 0, 1, 1, 0, 0, 0, 0, 3, 1, 0, 0, 0, 0, 5, 1, 0, 0, 0, 0, 7, 1, 0, 0, 0, 0, 9, 1, 0, 0, 0, 0, 11, 1, 0, 0, 0, 0, 13, 1, 0, 0, 0, 0, 15, 1, 0, 0, 0, 0, 17, 1, 0, 0, 0, 0, 19, 1, 0, 0, 0, 0, 21, 1, 0, 0, 0, 0, 23, 1, 0, 0, 0, 0, 25, 1, 0, 0, 0, 0, 27, 1, 0, 0, 0, 0, 29, 1, 0, 0, 0, 0, 31, 1, 0, 0, 0, 0, 33, 1, 0, 0, 0, 0, 35, 1, 0, 0, 0, 0, 37, 1, 0, 0, 0, 0, 39, 1, 0, 0, 0, 0, 41, 1, 0, 0, 0, 0, 43, 1, 0, 0, 0, 0, 45, 1, 0, 0, 0, 0, 47, 1, 0, 0, 0, 0, 49, 1, 0, 0, 0, 0, 51, 1, 0, 0, 0, 0, 53, 1, 0, 0, 0, 0, 55, 1, 0, 0, 0, 0, 57, 1, 0, 0, 0, 0, 59, 1, 0, 0, 0, 0, 61, 1, 0, 0, 0, 0, 63, 1, 0, 0, 0, 0, 65, 1, 0, 0, 0, 0, 67, 1, 0, 0, 0, 0, 69, 1, 0, 0, 0, 0, 71, 1, 0, 0, 0, 0, 73, 1, 0, 0, 0, 0, 75, 1, 0, 0, 0, 0, 77, 1, 0, 0, 0, 0, 79, 1, 0, 0, 0, 0, 81, 1, 0, 0, 0, 0, 83, 1, 0, 0, 0, 0, 85, 1, 0, 0, 0, 0, 87, 1, 0, 0, 0, 0, 89, 1, 0, 0, 0, 0, 91, 1, 0, 0, 0, 0, 93, 1, 0, 0, 0, 0, 95, 1, 0, 0, 0, 0, 97, 1, 0, 0, 0, 0, 99, 1, 0, 0, 0, 0, 101, 1, 0, 0, 0, 0, 103, 1, 0, 0, 0, 0, 105, 1, 0, 0, 0, 0, 107, 1, 0, 0, 0, 0, 109, 1, 0, 0, 0, 0, 111, 1, 0, 0, 0, 0, 113, 1, 0, 0, 0, 0, 115, 1, 0, 0, 0, 0, 117, 1, 0, 0, 0, 0, 119, 1, 0, 0, 0, 0, 121, 1, 0, 0, 0, 0, 123, 1, 0, 0, 0, 0, 125, 1, 0, 0, 0, 0, 127, 1, 0, 0, 0, 0, 129, 1, 0, 0, 0, 0, 131, 1, 0, 0, 0, 0, 133, 1, 0, 0, 0, 0, 135, 1, 0, 0, 0, 0, 137, 1, 0, 0, 0, 0, 139, 1, 0, 0, 0, 0, 141, 1, 0, 0, 0, 0, 143, 1, 0, 0, 0, 0, 145, 1, 0, 0, 0, 0, 147, 1, 0, 0, 0, 0, 149, 1, 0, 0, 0, 0, 151, 1, 0, 0, 0, 0, 153, 1, 0, 0, 0, 0, 155, 1, 0, 0, 0, 0, 157, 1, 0, 0, 0, 0, 159, 1, 0, 0, 0, 0, 161, 1, 0, 0, 0, 0, 163, 1, 0, 0, 0, 0, 165, 1, 0, 0, 0, 0, 167, 1, 0, 0, 0, 0, 169, 1, 0, 0, 0, 0, 171, 1, 0, 0, 0, 0, 173, 1, 0, 0, 0, 0, 175, 1, 0, 0, 0, 0, 177, 1, 0, 0, 0, 0, 179, 1, 0, 0, 0, 0, 181, 1, 0, 0, 0, 0, 183, 1, 0, 0, 0, 0, 185, 1, 0, 0, 0, 0, 187, 1, 0, 0, 0, 0, 189, 1, 0, 0, 0, 0, 191, 1, 0, 0, 0, 0, 193, 1, 0, 0, 0, 0, 195, 1, 0, 0, 0, 0, 197, 1, 0, 0, 0, 0, 199, 1, 0, 0, 0, 0, 201, 1, 0, 0, 0, 0, 203, 1, 0, 0, 0, 0, 205, 1, 0, 0, 0, 0, 207, 1, 0, 0, 0, 0, 209, 1, 0, 0, 0, 0, 211, 1, 0, 0, 0, 0, 213, 1, 0, 0, 0, 0, 215, 1, 0, 0, 0, 0, 217, 1, 0, 0, 0, 0, 219, 1, 0, 0, 0, 0, 221, 1, 0, 0, 0, 0, 223, 1, 0, 0, 0, 0, 225, 1, 0, 0, 0, 0, 227, 1, 0, 0, 0, 0, 229, 1, 0, 0, 0, 0, 231, 1, 0, 0, 0, 0, 233, 1, 0, 0, 0, 0, 235, 1, 0, 0, 0, 0, 237, 1, 0, 0, 0, 0, 239, 1, 0, 0, 0, 0, 241, 1, 0, 0, 0, 0, 243, 1, 0, 0, 0, 0, 245, 1, 0, 0, 0, 0, 247, 1, 0, 0, 0, 0, 249, 1, 0, 0, 0, 0, 251, 1, 0, 0, 0, 0, 253, 1, 0, 0, 0, 0, 255, 1, 0, 0, 0, 0, 257, 1, 0, 0, 0, 0, 259, 1, 0, 0, 0, 0, 261, 1, 0, 0, 0, 0, 267, 1, 0, 0, 0, 0, 275, 1, 0, 0, 0, 0, 277, 1, 0, 0, 0, 0, 279, 1, 0, 0, 0, 0, 281, 1, 0, 0, 0, 0, 291, 1, 0, 0, 0, 0, 325, 1, 0, 0, 0, 0, 327, 1, 0, 0, 0, 0, 329, 1, 0, 0, 0, 0, 331, 1, 0, 0, 0, 0, 335, 1, 0, 0, 0, 0, 337, 1, 0, 0, 0, 0, 339, 1, 0, 0, 0, 0, 341, 1, 0, 0, 0, 1, 359, 1, 0, 0, 0, 3, 362, 1, 0, 0, 0, 5, 384, 1, 0, 0, 0, 7, 387, 1, 0, 0, 0, 9, 402, 1, 0, 0, 0, 11, 404, 1, 0, 0, 0, 13, 410, 1, 0, 0, 0, 15, 412, 1, 0, 0, 0, 17, 435, 1, 0, 0, 0, 19, 444, 1, 0, 0, 0, 21, 452, 1, 0, 0, 0, 23, 460, 1, 0, 0, 0, 25, 464, 1, 0, 0, 0, 27, 469, 1, 0, 0, 0, 29, 474, 1, 0, 0, 0, 31, 480, 1, 0, 0, 0, 33, 485, 1, 0, 0, 0, 35, 491, 1, 0, 0, 0, 37, 496, 1, 0, 0, 0, 39, 505, 1, 0, 0, 0, 41, 514, 1, 0, 0, 0, 43, 520, 1, 0, 0, 0, 45, 526, 1, 0, 0, 0, 47, 536, 1, 0, 0, 0, 49, 547, 1, 0, 0, 0, 51, 556, 1, 0, 0, 0, 53, 565, 1, 0, 0, 0, 55, 573, 1, 0, 0, 0, 57, 580, 1, 0, 0, 0, 59, 583, 1, 0, 0, 0, 61, 590, 1, 0, 0, 0, 63, 603, 1, 0, 0, 0, 65, 608, 1, 0, 0, 0, 67, 613, 1, 0, 0, 0, 69, 622, 1, 0, 0, 0, 71, 629, 1, 0, 0, 0, 73, 636, 1, 0, 0, 0, 75, 642, 1, 0, 0, 0, 77, 648, 1, 0, 0, 0, 79, 654, 1, 0, 0, 0, 81, 658, 1, 0, 0, 0, 83, 665, 1, 0, 0, 0, 85, 670, 1, 0, 0, 0, 87, 673, 1, 0, 0, 0, 89, 680, 1, 0, 0, 0, 91, 684, 1, 0, 0, 0, 93, 689, 1, 0, 0, 0, 95, 697, 1, 0, 0, 0, 97, 707, 1, 0, 0, 0, 99, 711, 1, 0, 0, 0, 101, 720, 1, 0, 0, 0, 103, 728, 1, 0, 0, 0, 105, 737, 1, 0, 0, 0, 107, 746, 1, 0, 0, 0, 109, 754, 1, 0, 0, 0, 111, 764, 1, 0, 0, 0, 113, 771, 1, 0, 0, 0, 115, 780, 1, 0, 0, 0, 117, 797, 1, 0, 0, 0, 119, 804, 1, 0, 0, 0, 121, 810, 1, 0, 0, 0, 123, 817, 1, 0, 0, 0, 125, 824, 1, 0, 0, 0, 127, 831, 1, 0, 0, 0, 129, 845, 1, 0, 0, 0, 131, 857, 1, 0, 0, 0, 133, 864, 1, 0, 0, 0, 135, 871, 1, 0, 0, 0, 137, 880, 1, 0, 0, 0, 139, 885, 1, 0, 0, 0, 141, 898, 1, 0, 0, 0, 143, 904, 1, 0, 0, 0, 145, 909, 1, 0, 0, 0, 147, 913, 1, 0, 0, 0, 149, 921, 1, 0, 0, 0, 151, 928, 1, 0, 0, 0, 153, 937, 1, 0, 0, 0, 155, 943, 1, 0, 0, 0, 157, 952, 1, 0, 0, 0, 159, 958, 1, 0, 0, 0, 161, 966, 1, 0, 0, 0, 163, 971, 1, 0, 0, 0, 165, 980, 1, 0, 0, 0, 167, 988, 1, 0, 0, 0, 169, 994, 1, 0, 0, 0, 171, 996, 1, 0, 0, 0, 173, 998, 1, 0, 0, 0, 175, 1000, 1, 0, 0, 0, 177, 1002, 1, 0, 0, 0, 179, 1004, 1, 0, 0, 0, 181, 1006, 1, 0, 0, 0, 183, 1008, 1, 0, 0, 0, 185, 1010, 1, 0, 0, 0, 187, 1012, 1, 0, 0, 0, 189, 1014, 1, 0, 0, 0, 191, 1016, 1, 0, 0, 0, 193, 1018, 1, 0, 0, 0, 195, 1020, 1, 0, 0, 0, 197, 1022, 1, 0, 0, 0, 199, 1028, 1, 0, 0, 0, 201, 1030, 1, 0, 0, 0, 203, 1032, 1, 0, 0, 0, 205, 1034, 1, 0, 0, 0, 207, 1036, 1, 0, 0, 0, 209, 1039, 1, 0, 0, 0, 211, 1042, 1, 0, 0, 0, 213, 1045, 1, 0, 0, 0, 215, 1048, 1, 0, 0, 0, 217, 1051, 1, 0, 0, 0, 219, 1054, 1, 0, 0, 0, 221, 1057, 1, 0, 0, 0, 223, 1060, 1, 0, 0, 0, 225, 1064, 1, 0, 0, 0, 227, 1068, 1, 0, 0, 0, 229, 1071, 1, 0, 0, 0, 231, 1074, 1, 0, 0, 0, 233, 1077, 1, 0, 0, 0, 235, 1085, 1, 0, 0, 0, 237, 1091, 1, 0, 0, 0, 239, 1093, 1, 0, 0, 0, 241, 1096, 1, 0, 0, 0, 243, 1099, 1, 0, 0, 0, 245, 1101, 1, 0, 0, 0, 247, 1105, 1, 0, 0, 0, 249, 1108, 1, 0, 0, 0, 251, 1110, 1, 0, 0, 0, 253, 1112, 1, 0, 0, 0, 255, 1115, 1, 0, 0, 0, 257, 1117, 1, 0, 0, 0, 259, 1119, 1, 0, 0, 0, 261, 1122, 1, 0, 0, 0, 263, 1126, 1, 0, 0, 0, 265, 1141, 1, 0, 0, 0, 267, 1143, 1, 0, 0, 0, 269, 1153, 1, 0, 0, 0, 271, 1155, 1, 0, 0, 0, 273, 1157, 1, 0, 0, 0, 275, 1159, 1, 0, 0, 0, 277, 1169, 1, 0, 0, 0, 279, 1183, 1, 0, 0, 0, 281, 1199, 1, 0, 0, 0, 283, 1211, 1, 0, 0, 0, 285, 1213, 1, 0, 0, 0, 287, 1215, 1, 0, 0, 0, 289, 1217, 1, 0, 0, 0, 291, 1235, 1, 0, 0, 0, 293, 1237, 1, 0, 0, 0, 295, 1239, 1, 0, 0, 0, 297, 1245, 1, 0, 0, 0, 299, 1250, 1, 0, 0, 0, 301, 1255, 1, 0, 0, 0, 303, 1287, 1, 0, 0, 0, 305, 1300, 1, 0, 0, 0, 307, 1302, 1, 0, 0, 0, 309, 1318, 1, 0, 0, 0, 311, 1330, 1, 0, 0, 0, 313, 1332, 1, 0, 0, 0, 315, 1334, 1, 0, 0, 0, 317, 1344, 1, 0, 0, 0, 319, 1349, 1, 0, 0, 0, 321, 1354, 1, 0, 0, 0, 323, 1356, 1, 0, 0, 0, 325, 1397, 1, 0, 0, 0, 327, 1409, 1, 0, 0, 0, 329, 1411, 1, 0, 0, 0, 331, 1414, 1, 0, 0, 0, 333, 1417, 1, 0, 0, 0, 335, 1420, 1, 0, 0, 0, 337, 1431, 1, 0, 0, 0, 339, 1435, 1, 0, 0, 0, 341, 1449, 1, 0, 0, 0, 343, 345, 3, 275, 137, 0, 344, 346, 3, 291, 145, 0, 345, 344, 1, 0, 0, 0, 345, 346, 1, 0, 0, 0, 346, 360, 1, 0, 0, 0, 347, 349, 3, 277, 138, 0, 348, 350, 3, 291, 145, 0, 349, 348, 1, 0, 0, 0, 349, 350, 1, 0, 0, 0, 350, 360, 1, 0, 0, 0, 351, 353, 3, 279, 139, 0, 352, 354, 3, 291, 145, 0, 353, 352, 1, 0, 0, 0, 353, 354, 1, 0, 0, 0, 354, 360, 1, 0, 0, 0, 355, 357, 3, 281, 140, 0, 356, 358, 3, 291, 145, 0, 357, 356, 1, 0, 0, 0, 357, 358, 1, 0, 0, 0, 358, 360, 1, 0, 0, 0, 359, 343, 1, 0, 0, 0, 359, 347, 1, 0, 0, 0, 359, 351, 1, 0, 0, 0, 359, 355, 1, 0, 0, 0, 360, 2, 1, 0, 0, 0, 361, 363, 7, 0, 0, 0, 362, 361, 1, 0, 0, 0, 362, 363, 1, 0, 0, 0, 363, 364, 1, 0, 0, 0, 364, 366, 5, 39, 0, 0, 365, 367, 3, 299, 149, 0, 366, 365, 1, 0, 0, 0, 367, 368, 1, 0, 0, 0, 368, 366, 1, 0, 0, 0, 368, 369, 1, 0, 0, 0, 369, 370, 1, 0, 0, 0, 370, 371, 5, 39, 0, 0, 371, 4, 1, 0, 0, 0, 372, 374, 3, 309, 154, 0, 373, 375, 3, 311, 155, 0, 374, 373, 1, 0, 0, 0, 374, 375, 1, 0, 0, 0, 375, 377, 1, 0, 0, 0, 376, 378, 3, 317, 158, 0, 377, 376, 1, 0, 0, 0, 377, 378, 1, 0, 0, 0, 378, 385, 1, 0, 0, 0, 379, 380, 3, 315, 157, 0, 380, 382, 3, 311, 155, 0, 381, 383, 3, 317, 158, 0, 382, 381, 1, 0, 0, 0, 382, 383, 1, 0, 0, 0, 383, 385, 1, 0, 0, 0, 384, 372, 1, 0, 0, 0, 384, 379, 1, 0, 0, 0, 385, 6, 1, 0, 0, 0, 386, 388, 3, 319, 159, 0, 387, 386, 1, 0, 0, 0, 387, 388, 1, 0, 0, 0, 388, 398, 1, 0, 0, 0, 389, 399, 3, 323, 161, 0, 390, 394, 5, 34, 0, 0, 391, 393, 3, 321, 160, 0, 392, 391, 1, 0, 0, 0, 393, 396, 1, 0, 0, 0, 394, 392, 1, 0, 0, 0, 394, 395, 1, 0, 0, 0, 395, 397, 1, 0, 0, 0, 396, 394, 1, 0, 0, 0, 397, 399, 5, 34, 0, 0, 398, 389, 1, 0, 0, 0, 398, 390, 1, 0, 0, 0, 399, 8, 1, 0, 0, 0, 400, 403, 3, 73, 36, 0, 401, 403, 3, 143, 71, 0, 402, 400, 1, 0, 0, 0, 402, 401, 1, 0, 0, 0, 403, 10, 1, 0, 0, 0, 404, 405, 3, 101, 50, 0, 405, 12, 1, 0, 0, 0, 406, 411, 3, 325, 162, 0, 407, 411, 3, 327, 163, 0, 408, 411, 3, 329, 164, 0, 409, 411, 3, 331, 165, 0, 410, 406, 1, 0, 0, 0, 410, 407, 1, 0, 0, 0, 410, 408, 1, 0, 0, 0, 410, 409, 1, 0, 0, 0, 411, 14, 1, 0, 0, 0, 412, 424, 5, 35, 0, 0, 413, 415, 8, 1, 0, 0, 414, 413, 1, 0, 0, 0, 415, 418, 1, 0, 0, 0, 416, 417, 1, 0, 0, 0, 416, 414, 1, 0, 0, 0, 417, 419, 1, 0, 0, 0, 418, 416, 1, 0, 0, 0, 419, 421, 5, 92, 0, 0, 420, 422, 5, 13, 0, 0, 421, 420, 1, 0, 0, 0, 421, 422, 1, 0, 0, 0, 422, 423, 1, 0, 0, 0, 423, 425, 5, 10, 0, 0, 424, 416, 1, 0, 0, 0, 425, 426, 1, 0, 0, 0, 426, 424, 1, 0, 0, 0, 426, 427, 1, 0, 0, 0, 427, 429, 1, 0, 0, 0, 428, 430, 8, 1, 0, 0, 429, 428, 1, 0, 0, 0, 430, 431, 1, 0, 0, 0, 431, 429, 1, 0, 0, 0, 431, 432, 1, 0, 0, 0, 432, 433, 1, 0, 0, 0, 433, 434, 6, 7, 0, 0, 434, 16, 1, 0, 0, 0, 435, 439, 5, 35, 0, 0, 436, 438, 8, 1, 0, 0, 437, 436, 1, 0, 0, 0, 438, 441, 1, 0, 0, 0, 439, 437, 1, 0, 0, 0, 439, 440, 1, 0, 0, 0, 440, 442, 1, 0, 0, 0, 441, 439, 1, 0, 0, 0, 442, 443, 6, 8, 0, 0, 443, 18, 1, 0, 0, 0, 444, 445, 5, 97, 0, 0, 445, 446, 5, 108, 0, 0, 446, 447, 5, 105, 0, 0, 447, 448, 5, 103, 0, 0, 448, 449, 5, 110, 0, 0, 449, 450, 5, 97, 0, 0, 450, 451, 5, 115, 0, 0, 451, 20, 1, 0, 0, 0, 452, 453, 5, 97, 0, 0, 453, 454, 5, 108, 0, 0, 454, 455, 5, 105, 0, 0, 455, 456, 5, 103, 0, 0, 456, 457, 5, 110, 0, 0, 457, 458, 5, 111, 0, 0, 458, 459, 5, 102, 0, 0, 459, 22, 1, 0, 0, 0, 460, 461, 5, 97, 0, 0, 461, 462, 5, 115, 0, 0, 462, 463, 5, 109, 0, 0, 463, 24, 1, 0, 0, 0, 464, 465, 5, 97, 0, 0, 465, 466, 5, 117, 0, 0, 466, 467, 5, 116, 0, 0, 467, 468, 5, 111, 0, 0, 468, 26, 1, 0, 0, 0, 469, 470, 5, 98, 0, 0, 470, 471, 5, 111, 0, 0, 471, 472, 5, 111, 0, 0, 472, 473, 5, 108, 0, 0, 473, 28, 1, 0, 0, 0, 474, 475, 5, 98, 0, 0, 475, 476, 5, 114, 0, 0, 476, 477, 5, 101, 0, 0, 477, 478, 5, 97, 0, 0, 478, 479, 5, 107, 0, 0, 479, 30, 1, 0, 0, 0, 480, 481, 5, 99, 0, 0, 481, 482, 5, 97, 0, 0, 482, 483, 5, 115, 0, 0, 483, 484, 5, 101, 0, 0, 484, 32, 1, 0, 0, 0, 485, 486, 5, 99, 0, 0, 486, 487, 5, 97, 0, 0, 487, 488, 5, 116, 0, 0, 488, 489, 5, 99, 0, 0, 489, 490, 5, 104, 0, 0, 490, 34, 1, 0, 0, 0, 491, 492, 5, 99, 0, 0, 492, 493, 5, 104, 0, 0, 493, 494, 5, 97, 0, 0, 494, 495, 5, 114, 0, 0, 495, 36, 1, 0, 0, 0, 496, 497, 5, 99, 0, 0, 497, 498, 5, 104, 0, 0, 498, 499, 5, 97, 0, 0, 499, 500, 5, 114, 0, 0, 500, 501, 5, 49, 0, 0, 501, 502, 5, 54, 0, 0, 502, 503, 5, 95, 0, 0, 503, 504, 5, 116, 0, 0, 504, 38, 1, 0, 0, 0, 505, 506, 5, 99, 0, 0, 506, 507, 5, 104, 0, 0, 507, 508, 5, 97, 0, 0, 508, 509, 5, 114, 0, 0, 509, 510, 5, 51, 0, 0, 510, 511, 5, 50, 0, 0, 511, 512, 5, 95, 0, 0, 512, 513, 5, 116, 0, 0, 513, 40, 1, 0, 0, 0, 514, 515, 5, 99, 0, 0, 515, 516, 5, 108, 0, 0, 516, 517, 5, 97, 0, 0, 517, 518, 5, 115, 0, 0, 518, 519, 5, 115, 0, 0, 519, 42, 1, 0, 0, 0, 520, 521, 5, 99, 0, 0, 521, 522, 5, 111, 0, 0, 522, 523, 5, 110, 0, 0, 523, 524, 5, 115, 0, 0, 524, 525, 5, 116, 0, 0, 525, 44, 1, 0, 0, 0, 526, 527, 5, 99, 0, 0, 527, 528, 5, 111, 0, 0, 528, 529, 5, 110, 0, 0, 529, 530, 5, 115, 0, 0, 530, 531, 5, 116, 0, 0, 531, 532, 5, 101, 0, 0, 532, 533, 5, 120, 0, 0, 533, 534, 5, 112, 0, 0, 534, 535, 5, 114, 0, 0, 535, 46, 1, 0, 0, 0, 536, 537, 5, 99, 0, 0, 537, 538, 5, 111, 0, 0, 538, 539, 5, 110, 0, 0, 539, 540, 5, 115, 0, 0, 540, 541, 5, 116, 0, 0, 541, 542, 5, 95, 0, 0, 542, 543, 5, 99, 0, 0, 543, 544, 5, 97, 0, 0, 544, 545, 5, 115, 0, 0, 545, 546, 5, 116, 0, 0, 546, 48, 1, 0, 0, 0, 547, 548, 5, 99, 0, 0, 548, 549, 5, 111, 0, 0, 549, 550, 5, 110, 0, 0, 550, 551, 5, 116, 0, 0, 551, 552, 5, 105, 0, 0, 552, 553, 5, 110, 0, 0, 553, 554, 5, 117, 0, 0, 554, 555, 5, 101, 0, 0, 555, 50, 1, 0, 0, 0, 556, 557, 5, 100, 0, 0, 557, 558, 5, 101, 0, 0, 558, 559, 5, 99, 0, 0, 559, 560, 5, 108, 0, 0, 560, 561, 5, 116, 0, 0, 561, 562, 5, 121, 0, 0, 562, 563, 5, 112, 0, 0, 563, 564, 5, 101, 0, 0, 564, 52, 1, 0, 0, 0, 565, 566, 5, 100, 0, 0, 566, 567, 5, 101, 0, 0, 567, 568, 5, 102, 0, 0, 568, 569, 5, 97, 0, 0, 569, 570, 5, 117, 0, 0, 570, 571, 5, 108, 0, 0, 571, 572, 5, 116, 0, 0, 572, 54, 1, 0, 0, 0, 573, 574, 5, 100, 0, 0, 574, 575, 5, 101, 0, 0, 575, 576, 5, 108, 0, 0, 576, 577, 5, 101, 0, 0, 577, 578, 5, 116, 0, 0, 578, 579, 5, 101, 0, 0, 579, 56, 1, 0, 0, 0, 580, 581, 5, 100, 0, 0, 581, 582, 5, 111, 0, 0, 582, 58, 1, 0, 0, 0, 583, 584, 5, 100, 0, 0, 584, 585, 5, 111, 0, 0, 585, 586, 5, 117, 0, 0, 586, 587, 5, 98, 0, 0, 587, 588, 5, 108, 0, 0, 588, 589, 5, 101, 0, 0, 589, 60, 1, 0, 0, 0, 590, 591, 5, 100, 0, 0, 591, 592, 5, 121, 0, 0, 592, 593, 5, 110, 0, 0, 593, 594, 5, 97, 0, 0, 594, 595, 5, 109, 0, 0, 595, 596, 5, 105, 0, 0, 596, 597, 5, 99, 0, 0, 597, 598, 5, 95, 0, 0, 598, 599, 5, 99, 0, 0, 599, 600, 5, 97, 0, 0, 600, 601, 5, 115, 0, 0, 601, 602, 5, 116, 0, 0, 602, 62, 1, 0, 0, 0, 603, 604, 5, 101, 0, 0, 604, 605, 5, 108, 0, 0, 605, 606, 5, 115, 0, 0, 606, 607, 5, 101, 0, 0, 607, 64, 1, 0, 0, 0, 608, 609, 5, 101, 0, 0, 609, 610, 5, 110, 0, 0, 610, 611, 5, 117, 0, 0, 611, 612, 5, 109, 0, 0, 612, 66, 1, 0, 0, 0, 613, 614, 5, 101, 0, 0, 614, 615, 5, 120, 0, 0, 615, 616, 5, 112, 0, 0, 616, 617, 5, 108, 0, 0, 617, 618, 5, 105, 0, 0, 618, 619, 5, 99, 0, 0, 619, 620, 5, 105, 0, 0, 620, 621, 5, 116, 0, 0, 621, 68, 1, 0, 0, 0, 622, 623, 5, 101, 0, 0, 623, 624, 5, 120, 0, 0, 624, 625, 5, 112, 0, 0, 625, 626, 5, 111, 0, 0, 626, 627, 5, 114, 0, 0, 627, 628, 5, 116, 0, 0, 628, 70, 1, 0, 0, 0, 629, 630, 5, 101, 0, 0, 630, 631, 5, 120, 0, 0, 631, 632, 5, 116, 0, 0, 632, 633, 5, 101, 0, 0, 633, 634, 5, 114, 0, 0, 634, 635, 5, 110, 0, 0, 635, 72, 1, 0, 0, 0, 636, 637, 5, 102, 0, 0, 637, 638, 5, 97, 0, 0, 638, 639, 5, 108, 0, 0, 639, 640, 5, 115, 0, 0, 640, 641, 5, 101, 0, 0, 641, 74, 1, 0, 0, 0, 642, 643, 5, 102, 0, 0, 643, 644, 5, 105, 0, 0, 644, 645, 5, 110, 0, 0, 645, 646, 5, 97, 0, 0, 646, 647, 5, 108, 0, 0, 647, 76, 1, 0, 0, 0, 648, 649, 5, 102, 0, 0, 649, 650, 5, 108, 0, 0, 650, 651, 5, 111, 0, 0, 651, 652, 5, 97, 0, 0, 652, 653, 5, 116, 0, 0, 653, 78, 1, 0, 0, 0, 654, 655, 5, 102, 0, 0, 655, 656, 5, 111, 0, 0, 656, 657, 5, 114, 0, 0, 657, 80, 1, 0, 0, 0, 658, 659, 5, 102, 0, 0, 659, 660, 5, 114, 0, 0, 660, 661, 5, 105, 0, 0, 661, 662, 5, 101, 0, 0, 662, 663, 5, 110, 0, 0, 663, 664, 5, 100, 0, 0, 664, 82, 1, 0, 0, 0, 665, 666, 5, 103, 0, 0, 666, 667, 5, 111, 0, 0, 667, 668, 5, 116, 0, 0, 668, 669, 5, 111, 0, 0, 669, 84, 1, 0, 0, 0, 670, 671, 5, 105, 0, 0, 671, 672, 5, 102, 0, 0, 672, 86, 1, 0, 0, 0, 673, 674, 5, 105, 0, 0, 674, 675, 5, 110, 0, 0, 675, 676, 5, 108, 0, 0, 676, 677, 5, 105, 0, 0, 677, 678, 5, 110, 0, 0, 678, 679, 5, 101, 0, 0, 679, 88, 1, 0, 0, 0, 680, 681, 5, 105, 0, 0, 681, 682, 5, 110, 0, 0, 682, 683, 5, 116, 0, 0, 683, 90, 1, 0, 0, 0, 684, 685, 5, 108, 0, 0, 685, 686, 5, 111, 0, 0, 686, 687, 5, 110, 0, 0, 687, 688, 5, 103, 0, 0, 688, 92, 1, 0, 0, 0, 689, 690, 5, 109, 0, 0, 690, 691, 5, 117, 0, 0, 691, 692, 5, 116, 0, 0, 692, 693, 5, 97, 0, 0, 693, 694, 5, 98, 0, 0, 694, 695, 5, 108, 0, 0, 695, 696, 5, 101, 0, 0, 696, 94, 1, 0, 0, 0, 697, 698, 5, 110, 0, 0, 698, 699, 5, 97, 0, 0, 699, 700, 5, 109, 0, 0, 700, 701, 5, 101, 0, 0, 701, 702, 5, 115, 0, 0, 702, 703, 5, 112, 0, 0, 703, 704, 5, 97, 0, 0, 704, 705, 5, 99, 0, 0, 705, 706, 5, 101, 0, 0, 706, 96, 1, 0, 0, 0, 707, 708, 5, 110, 0, 0, 708, 709, 5, 101, 0, 0, 709, 710, 5, 119, 0, 0, 710, 98, 1, 0, 0, 0, 711, 712, 5, 110, 0, 0, 712, 713, 5, 111, 0, 0, 713, 714, 5, 101, 0, 0, 714, 715, 5, 120, 0, 0, 715, 716, 5, 99, 0, 0, 716, 717, 5, 101, 0, 0, 717, 718, 5, 112, 0, 0, 718, 719, 5, 116, 0, 0, 719, 100, 1, 0, 0, 0, 720, 721, 5, 110, 0, 0, 721, 722, 5, 117, 0, 0, 722, 723, 5, 108, 0, 0, 723, 724, 5, 108, 0, 0, 724, 725, 5, 112, 0, 0, 725, 726, 5, 116, 0, 0, 726, 727, 5, 114, 0, 0, 727, 102, 1, 0, 0, 0, 728, 729, 5, 111, 0, 0, 729, 730, 5, 112, 0, 0, 730, 731, 5, 101, 0, 0, 731, 732, 5, 114, 0, 0, 732, 733, 5, 97, 0, 0, 733, 734, 5, 116, 0, 0, 734, 735, 5, 111, 0, 0, 735, 736, 5, 114, 0, 0, 736, 104, 1, 0, 0, 0, 737, 738, 5, 111, 0, 0, 738, 739, 5, 118, 0, 0, 739, 740, 5, 101, 0, 0, 740, 741, 5, 114, 0, 0, 741, 742, 5, 114, 0, 0, 742, 743, 5, 105, 0, 0, 743, 744, 5, 100, 0, 0, 744, 745, 5, 101, 0, 0, 745, 106, 1, 0, 0, 0, 746, 747, 5, 112, 0, 0, 747, 748, 5, 114, 0, 0, 748, 749, 5, 105, 0, 0, 749, 750, 5, 118, 0, 0, 750, 751, 5, 97, 0, 0, 751, 752, 5, 116, 0, 0, 752, 753, 5, 101, 0, 0, 753, 108, 1, 0, 0, 0, 754, 755, 5, 112, 0, 0, 755, 756, 5, 114, 0, 0, 756, 757, 5, 111, 0, 0, 757, 758, 5, 116, 0, 0, 758, 759, 5, 101, 0, 0, 759, 760, 5, 99, 0, 0, 760, 761, 5, 116, 0, 0, 761, 762, 5, 101, 0, 0, 762, 763, 5, 100, 0, 0, 763, 110, 1, 0, 0, 0, 764, 765, 5, 112, 0, 0, 765, 766, 5, 117, 0, 0, 766, 767, 5, 98, 0, 0, 767, 768, 5, 108, 0, 0, 768, 769, 5, 105, 0, 0, 769, 770, 5, 99, 0, 0, 770, 112, 1, 0, 0, 0, 771, 772, 5, 114, 0, 0, 772, 773, 5, 101, 0, 0, 773, 774, 5, 103, 0, 0, 774, 775, 5, 105, 0, 0, 775, 776, 5, 115, 0, 0, 776, 777, 5, 116, 0, 0, 777, 778, 5, 101, 0, 0, 778, 779, 5, 114, 0, 0, 779, 114, 1, 0, 0, 0, 780, 781, 5, 114, 0, 0, 781, 782, 5, 101, 0, 0, 782, 783, 5, 105, 0, 0, 783, 784, 5, 110, 0, 0, 784, 785, 5, 116, 0, 0, 785, 786, 5, 101, 0, 0, 786, 787, 5, 114, 0, 0, 787, 788, 5, 112, 0, 0, 788, 789, 5, 114, 0, 0, 789, 790, 5, 101, 0, 0, 790, 791, 5, 116, 0, 0, 791, 792, 5, 95, 0, 0, 792, 793, 5, 99, 0, 0, 793, 794, 5, 97, 0, 0, 794, 795, 5, 115, 0, 0, 795, 796, 5, 116, 0, 0, 796, 116, 1, 0, 0, 0, 797, 798, 5, 114, 0, 0, 798, 799, 5, 101, 0, 0, 799, 800, 5, 116, 0, 0, 800, 801, 5, 117, 0, 0, 801, 802, 5, 114, 0, 0, 802, 803, 5, 110, 0, 0, 803, 118, 1, 0, 0, 0, 804, 805, 5, 115, 0, 0, 805, 806, 5, 104, 0, 0, 806, 807, 5, 111, 0, 0, 807, 808, 5, 114, 0, 0, 808, 809, 5, 116, 0, 0, 809, 120, 1, 0, 0, 0, 810, 811, 5, 115, 0, 0, 811, 812, 5, 105, 0, 0, 812, 813, 5, 103, 0, 0, 813, 814, 5, 110, 0, 0, 814, 815, 5, 101, 0, 0, 815, 816, 5, 100, 0, 0, 816, 122, 1, 0, 0, 0, 817, 818, 5, 115, 0, 0, 818, 819, 5, 105, 0, 0, 819, 820, 5, 122, 0, 0, 820, 821, 5, 101, 0, 0, 821, 822, 5, 111, 0, 0, 822, 823, 5, 102, 0, 0, 823, 124, 1, 0, 0, 0, 824, 825, 5, 115, 0, 0, 825, 826, 5, 116, 0, 0, 826, 827, 5, 97, 0, 0, 827, 828, 5, 116, 0, 0, 828, 829, 5, 105, 0, 0, 829, 830, 5, 99, 0, 0, 830, 126, 1, 0, 0, 0, 831, 832, 5, 115, 0, 0, 832, 833, 5, 116, 0, 0, 833, 834, 5, 97, 0, 0, 834, 835, 5, 116, 0, 0, 835, 836, 5, 105, 0, 0, 836, 837, 5, 99, 0, 0, 837, 838, 5, 95, 0, 0, 838, 839, 5, 97, 0, 0, 839, 840, 5, 115, 0, 0, 840, 841, 5, 115, 0, 0, 841, 842, 5, 101, 0, 0, 842, 843, 5, 114, 0, 0, 843, 844, 5, 116, 0, 0, 844, 128, 1, 0, 0, 0, 845, 846, 5, 115, 0, 0, 846, 847, 5, 116, 0, 0, 847, 848, 5, 97, 0, 0, 848, 849, 5, 116, 0, 0, 849, 850, 5, 105, 0, 0, 850, 851, 5, 99, 0, 0, 851, 852, 5, 95, 0, 0, 852, 853, 5, 99, 0, 0, 853, 854, 5, 97, 0, 0, 854, 855, 5, 115, 0, 0, 855, 856, 5, 116, 0, 0, 856, 130, 1, 0, 0, 0, 857, 858, 5, 115, 0, 0, 858, 859, 5, 116, 0, 0, 859, 860, 5, 114, 0, 0, 860, 861, 5, 117, 0, 0, 861, 862, 5, 99, 0, 0, 862, 863, 5, 116, 0, 0, 863, 132, 1, 0, 0, 0, 864, 865, 5, 115, 0, 0, 865, 866, 5, 119, 0, 0, 866, 867, 5, 105, 0, 0, 867, 868, 5, 116, 0, 0, 868, 869, 5, 99, 0, 0, 869, 870, 5, 104, 0, 0, 870, 134, 1, 0, 0, 0, 871, 872, 5, 116, 0, 0, 872, 873, 5, 101, 0, 0, 873, 874, 5, 109, 0, 0, 874, 875, 5, 112, 0, 0, 875, 876, 5, 108, 0, 0, 876, 877, 5, 97, 0, 0, 877, 878, 5, 116, 0, 0, 878, 879, 5, 101, 0, 0, 879, 136, 1, 0, 0, 0, 880, 881, 5, 116, 0, 0, 881, 882, 5, 104, 0, 0, 882, 883, 5, 105, 0, 0, 883, 884, 5, 115, 0, 0, 884, 138, 1, 0, 0, 0, 885, 886, 5, 116, 0, 0, 886, 887, 5, 104, 0, 0, 887, 888, 5, 114, 0, 0, 888, 889, 5, 101, 0, 0, 889, 890, 5, 97, 0, 0, 890, 891, 5, 100, 0, 0, 891, 892, 5, 95, 0, 0, 892, 893, 5, 108, 0, 0, 893, 894, 5, 111, 0, 0, 894, 895, 5, 99, 0, 0, 895, 896, 5, 97, 0, 0, 896, 897, 5, 108, 0, 0, 897, 140, 1, 0, 0, 0, 898, 899, 5, 116, 0, 0, 899, 900, 5, 104, 0, 0, 900, 901, 5, 114, 0, 0, 901, 902, 5, 111, 0, 0, 902, 903, 5, 119, 0, 0, 903, 142, 1, 0, 0, 0, 904, 905, 5, 116, 0, 0, 905, 906, 5, 114, 0, 0, 906, 907, 5, 117, 0, 0, 907, 908, 5, 101, 0, 0, 908, 144, 1, 0, 0, 0, 909, 910, 5, 116, 0, 0, 910, 911, 5, 114, 0, 0, 911, 912, 5, 121, 0, 0, 912, 146, 1, 0, 0, 0, 913, 914, 5, 116, 0, 0, 914, 915, 5, 121, 0, 0, 915, 916, 5, 112, 0, 0, 916, 917, 5, 101, 0, 0, 917, 918, 5, 100, 0, 0, 918, 919, 5, 101, 0, 0, 919, 920, 5, 102, 0, 0, 920, 148, 1, 0, 0, 0, 921, 922, 5, 116, 0, 0, 922, 923, 5, 121, 0, 0, 923, 924, 5, 112, 0, 0, 924, 925, 5, 101, 0, 0, 925, 926, 5, 105, 0, 0, 926, 927, 5, 100, 0, 0, 927, 150, 1, 0, 0, 0, 928, 929, 5, 116, 0, 0, 929, 930, 5, 121, 0, 0, 930, 931, 5, 112, 0, 0, 931, 932, 5, 101, 0, 0, 932, 933, 5, 110, 0, 0, 933, 934, 5, 97, 0, 0, 934, 935, 5, 109, 0, 0, 935, 936, 5, 101, 0, 0, 936, 152, 1, 0, 0, 0, 937, 938, 5, 117, 0, 0, 938, 939, 5, 110, 0, 0, 939, 940, 5, 105, 0, 0, 940, 941, 5, 111, 0, 0, 941, 942, 5, 110, 0, 0, 942, 154, 1, 0, 0, 0, 943, 944, 5, 117, 0, 0, 944, 945, 5, 110, 0, 0, 945, 946, 5, 115, 0, 0, 946, 947, 5, 105, 0, 0, 947, 948, 5, 103, 0, 0, 948, 949, 5, 110, 0, 0, 949, 950, 5, 101, 0, 0, 950, 951, 5, 100, 0, 0, 951, 156, 1, 0, 0, 0, 952, 953, 5, 117, 0, 0, 953, 954, 5, 115, 0, 0, 954, 955, 5, 105, 0, 0, 955, 956, 5, 110, 0, 0, 956, 957, 5, 103, 0, 0, 957, 158, 1, 0, 0, 0, 958, 959, 5, 118, 0, 0, 959, 960, 5, 105, 0, 0, 960, 961, 5, 114, 0, 0, 961, 962, 5, 116, 0, 0, 962, 963, 5, 117, 0, 0, 963, 964, 5, 97, 0, 0, 964, 965, 5, 108, 0, 0, 965, 160, 1, 0, 0, 0, 966, 967, 5, 118, 0, 0, 967, 968, 5, 111, 0, 0, 968, 969, 5, 105, 0, 0, 969, 970, 5, 100, 0, 0, 970, 162, 1, 0, 0, 0, 971, 972, 5, 118, 0, 0, 972, 973, 5, 111, 0, 0, 973, 974, 5, 108, 0, 0, 974, 975, 5, 97, 0, 0, 975, 976, 5, 116, 0, 0, 976, 977, 5, 105, 0, 0, 977, 978, 5, 108, 0, 0, 978, 979, 5, 101, 0, 0, 979, 164, 1, 0, 0, 0, 980, 981, 5, 119, 0, 0, 981, 982, 5, 99, 0, 0, 982, 983, 5, 104, 0, 0, 983, 984, 5, 97, 0, 0, 984, 985, 5, 114, 0, 0, 985, 986, 5, 95, 0, 0, 986, 987, 5, 116, 0, 0, 987, 166, 1, 0, 0, 0, 988, 989, 5, 119, 0, 0, 989, 990, 5, 104, 0, 0, 990, 991, 5, 105, 0, 0, 991, 992, 5, 108, 0, 0, 992, 993, 5, 101, 0, 0, 993, 168, 1, 0, 0, 0, 994, 995, 5, 40, 0, 0, 995, 170, 1, 0, 0, 0, 996, 997, 5, 41, 0, 0, 997, 172, 1, 0, 0, 0, 998, 999, 5, 91, 0, 0, 999, 174, 1, 0, 0, 0, 1000, 1001, 5, 93, 0, 0, 1001, 176, 1, 0, 0, 0, 1002, 1003, 5, 123, 0, 0, 1003, 178, 1, 0, 0, 0, 1004, 1005, 5, 125, 0, 0, 1005, 180, 1, 0, 0, 0, 1006, 1007, 5, 43, 0, 0, 1007, 182, 1, 0, 0, 0, 1008, 1009, 5, 45, 0, 0, 1009, 184, 1, 0, 0, 0, 1010, 1011, 5, 42, 0, 0, 1011, 186, 1, 0, 0, 0, 1012, 1013, 5, 47, 0, 0, 1013, 188, 1, 0, 0, 0, 1014, 1015, 5, 37, 0, 0, 1015, 190, 1, 0, 0, 0, 1016, 1017, 5, 94, 0, 0, 1017, 192, 1, 0, 0, 0, 1018, 1019, 5, 38, 0, 0, 1019, 194, 1, 0, 0, 0, 1020, 1021, 5, 124, 0, 0, 1021, 196, 1, 0, 0, 0, 1022, 1023, 5, 126, 0, 0, 1023, 198, 1, 0, 0, 0, 1024, 1029, 5, 33, 0, 0, 1025, 1026, 5, 110, 0, 0, 1026, 1027, 5, 111, 0, 0, 1027, 1029, 5, 116, 0, 0, 1028, 1024, 1, 0, 0, 0, 1028, 1025, 1, 0, 0, 0, 1029, 200, 1, 0, 0, 0, 1030, 1031, 5, 61, 0, 0, 1031, 202, 1, 0, 0, 0, 1032, 1033, 5, 60, 0, 0, 1033, 204, 1, 0, 0, 0, 1034, 1035, 5, 62, 0, 0, 1035, 206, 1, 0, 0, 0, 1036, 1037, 5, 43, 0, 0, 1037, 1038, 5, 61, 0, 0, 1038, 208, 1, 0, 0, 0, 1039, 1040, 5, 45, 0, 0, 1040, 1041, 5, 61, 0, 0, 1041, 210, 1, 0, 0, 0, 1042, 1043, 5, 42, 0, 0, 1043, 1044, 5, 61, 0, 0, 1044, 212, 1, 0, 0, 0, 1045, 1046, 5, 47, 0, 0, 1046, 1047, 5, 61, 0, 0, 1047, 214, 1, 0, 0, 0, 1048, 1049, 5, 37, 0, 0, 1049, 1050, 5, 61, 0, 0, 1050, 216, 1, 0, 0, 0, 1051, 1052, 5, 94, 0, 0, 1052, 1053, 5, 61, 0, 0, 1053, 218, 1, 0, 0, 0, 1054, 1055, 5, 38, 0, 0, 1055, 1056, 5, 61, 0, 0, 1056, 220, 1, 0, 0, 0, 1057, 1058, 5, 124, 0, 0, 1058, 1059, 5, 61, 0, 0, 1059, 222, 1, 0, 0, 0, 1060, 1061, 5, 60, 0, 0, 1061, 1062, 5, 60, 0, 0, 1062, 1063, 5, 61, 0, 0, 1063, 224, 1, 0, 0, 0, 1064, 1065, 5, 62, 0, 0, 1065, 1066, 5, 62, 0, 0, 1066, 1067, 5, 61, 0, 0, 1067, 226, 1, 0, 0, 0, 1068, 1069, 5, 61, 0, 0, 1069, 1070, 5, 61, 0, 0, 1070, 228, 1, 0, 0, 0, 1071, 1072, 5, 33, 0, 0, 1072, 1073, 5, 61, 0, 0, 1073, 230, 1, 0, 0, 0, 1074, 1075, 5, 60, 0, 0, 1075, 1076, 5, 61, 0, 0, 1076, 232, 1, 0, 0, 0, 1077, 1078, 5, 62, 0, 0, 1078, 1079, 5, 61, 0, 0, 1079, 234, 1, 0, 0, 0, 1080, 1081, 5, 38, 0, 0, 1081, 1086, 5, 38, 0, 0, 1082, 1083, 5, 97, 0, 0, 1083, 1084, 5, 110, 0, 0, 1084, 1086, 5, 100, 0, 0, 1085, 1080, 1, 0, 0, 0, 1085, 1082, 1, 0, 0, 0, 1086, 236, 1, 0, 0, 0, 1087, 1088, 5, 124, 0, 0, 1088, 1092, 5, 124, 0, 0, 1089, 1090, 5, 111, 0, 0, 1090, 1092, 5, 114, 0, 0, 1091, 1087, 1, 0, 0, 0, 1091, 1089, 1, 0, 0, 0, 1092, 238, 1, 0, 0, 0, 1093, 1094, 5, 43, 0, 0, 1094, 1095, 5, 43, 0, 0, 1095, 240, 1, 0, 0, 0, 1096, 1097, 5, 45, 0, 0, 1097, 1098, 5, 45, 0, 0, 1098, 242, 1, 0, 0, 0, 1099, 1100, 5, 44, 0, 0, 1100, 244, 1, 0, 0, 0, 1101, 1102, 5, 45, 0, 0, 1102, 1103, 5, 62, 0, 0, 1103, 1104, 5, 42, 0, 0, 1104, 246, 1, 0, 0, 0, 1105, 1106, 5, 45, 0, 0, 1106, 1107, 5, 62, 0, 0, 1107, 248, 1, 0, 0, 0, 1108, 1109, 5, 63, 0, 0, 1109, 250, 1, 0, 0, 0, 1110, 1111, 5, 58, 0, 0, 1111, 252, 1, 0, 0, 0, 1112, 1113, 5, 58, 0, 0, 1113, 1114, 5, 58, 0, 0, 1114, 254, 1, 0, 0, 0, 1115, 1116, 5, 59, 0, 0, 1116, 256, 1, 0, 0, 0, 1117, 1118, 5, 46, 0, 0, 1118, 258, 1, 0, 0, 0, 1119, 1120, 5, 46, 0, 0, 1120, 1121, 5, 42, 0, 0, 1121, 260, 1, 0, 0, 0, 1122, 1123, 5, 46, 0, 0, 1123, 1124, 5, 46, 0, 0, 1124, 1125, 5, 46, 0, 0, 1125, 262, 1, 0, 0, 0, 1126, 1127, 3, 287, 143, 0, 1127, 1128, 3, 287, 143, 0, 1128, 1129, 3, 287, 143, 0, 1129, 1130, 3, 287, 143, 0, 1130, 264, 1, 0, 0, 0, 1131, 1132, 5, 92, 0, 0, 1132, 1133, 5, 117, 0, 0, 1133, 1134, 1, 0, 0, 0, 1134, 1142, 3, 263, 131, 0, 1135, 1136, 5, 92, 0, 0, 1136, 1137, 5, 85, 0, 0, 1137, 1138, 1, 0, 0, 0, 1138, 1139, 3, 263, 131, 0, 1139, 1140, 3, 263, 131, 0, 1140, 1142, 1, 0, 0, 0, 1141, 1131, 1, 0, 0, 0, 1141, 1135, 1, 0, 0, 0, 1142, 266, 1, 0, 0, 0, 1143, 1148, 3, 269, 134, 0, 1144, 1147, 3, 269, 134, 0, 1145, 1147, 3, 273, 136, 0, 1146, 1144, 1, 0, 0, 0, 1146, 1145, 1, 0, 0, 0, 1147, 1150, 1, 0, 0, 0, 1148, 1146, 1, 0, 0, 0, 1148, 1149, 1, 0, 0, 0, 1149, 268, 1, 0, 0, 0, 1150, 1148, 1, 0, 0, 0, 1151, 1154, 3, 271, 135, 0, 1152, 1154, 3, 265, 132, 0, 1153, 1151, 1, 0, 0, 0, 1153, 1152, 1, 0, 0, 0, 1154, 270, 1, 0, 0, 0, 1155, 1156, 7, 2, 0, 0, 1156, 272, 1, 0, 0, 0, 1157, 1158, 7, 3, 0, 0, 1158, 274, 1, 0, 0, 0, 1159, 1166, 3, 283, 141, 0, 1160, 1162, 5, 39, 0, 0, 1161, 1160, 1, 0, 0, 0, 1161, 1162, 1, 0, 0, 0, 1162, 1163, 1, 0, 0, 0, 1163, 1165, 3, 273, 136, 0, 1164, 1161, 1, 0, 0, 0, 1165, 1168, 1, 0, 0, 0, 1166, 1164, 1, 0, 0, 0, 1166, 1167, 1, 0, 0, 0, 1167, 276, 1, 0, 0, 0, 1168, 1166, 1, 0, 0, 0, 1169, 1176, 5, 48, 0, 0, 1170, 1172, 5, 39, 0, 0, 1171, 1170, 1, 0, 0, 0, 1171, 1172, 1, 0, 0, 0, 1172, 1173, 1, 0, 0, 0, 1173, 1175, 3, 285, 142, 0, 1174, 1171, 1, 0, 0, 0, 1175, 1178, 1, 0, 0, 0, 1176, 1174, 1, 0, 0, 0, 1176, 1177, 1, 0, 0, 0, 1177, 278, 1, 0, 0, 0, 1178, 1176, 1, 0, 0, 0, 1179, 1180, 5, 48, 0, 0, 1180, 1184, 5, 120, 0, 0, 1181, 1182, 5, 48, 0, 0, 1182, 1184, 5, 88, 0, 0, 1183, 1179, 1, 0, 0, 0, 1183, 1181, 1, 0, 0, 0, 1184, 1185, 1, 0, 0, 0, 1185, 1192, 3, 287, 143, 0, 1186, 1188, 5, 39, 0, 0, 1187, 1186, 1, 0, 0, 0, 1187, 1188, 1, 0, 0, 0, 1188, 1189, 1, 0, 0, 0, 1189, 1191, 3, 287, 143, 0, 1190, 1187, 1, 0, 0, 0, 1191, 1194, 1, 0, 0, 0, 1192, 1190, 1, 0, 0, 0, 1192, 1193, 1, 0, 0, 0, 1193, 280, 1, 0, 0, 0, 1194, 1192, 1, 0, 0, 0, 1195, 1196, 5, 48, 0, 0, 1196, 1200, 5, 98, 0, 0, 1197, 1198, 5, 48, 0, 0, 1198, 1200, 5, 66, 0, 0, 1199, 1195, 1, 0, 0, 0, 1199, 1197, 1, 0, 0, 0, 1200, 1201, 1, 0, 0, 0, 1201, 1208, 3, 289, 144, 0, 1202, 1204, 5, 39, 0, 0, 1203, 1202, 1, 0, 0, 0, 1203, 1204, 1, 0, 0, 0, 1204, 1205, 1, 0, 0, 0, 1205, 1207, 3, 289, 144, 0, 1206, 1203, 1, 0, 0, 0, 1207, 1210, 1, 0, 0, 0, 1208, 1206, 1, 0, 0, 0, 1208, 1209, 1, 0, 0, 0, 1209, 282, 1, 0, 0, 0, 1210, 1208, 1, 0, 0, 0, 1211, 1212, 7, 4, 0, 0, 1212, 284, 1, 0, 0, 0, 1213, 1214, 7, 5, 0, 0, 1214, 286, 1, 0, 0, 0, 1215, 1216, 7, 6, 0, 0, 1216, 288, 1, 0, 0, 0, 1217, 1218, 7, 7, 0, 0, 1218, 290, 1, 0, 0, 0, 1219, 1221, 3, 293, 146, 0, 1220, 1222, 3, 295, 147, 0, 1221, 1220, 1, 0, 0, 0, 1221, 1222, 1, 0, 0, 0, 1222, 1236, 1, 0, 0, 0, 1223, 1225, 3, 293, 146, 0, 1224, 1226, 3, 297, 148, 0, 1225, 1224, 1, 0, 0, 0, 1225, 1226, 1, 0, 0, 0, 1226, 1236, 1, 0, 0, 0, 1227, 1229, 3, 295, 147, 0, 1228, 1230, 3, 293, 146, 0, 1229, 1228, 1, 0, 0, 0, 1229, 1230, 1, 0, 0, 0, 1230, 1236, 1, 0, 0, 0, 1231, 1233, 3, 297, 148, 0, 1232, 1234, 3, 293, 146, 0, 1233, 1232, 1, 0, 0, 0, 1233, 1234, 1, 0, 0, 0, 1234, 1236, 1, 0, 0, 0, 1235, 1219, 1, 0, 0, 0, 1235, 1223, 1, 0, 0, 0, 1235, 1227, 1, 0, 0, 0, 1235, 1231, 1, 0, 0, 0, 1236, 292, 1, 0, 0, 0, 1237, 1238, 7, 8, 0, 0, 1238, 294, 1, 0, 0, 0, 1239, 1240, 7, 9, 0, 0, 1240, 296, 1, 0, 0, 0, 1241, 1242, 5, 108, 0, 0, 1242, 1246, 5, 108, 0, 0, 1243, 1244, 5, 76, 0, 0, 1244, 1246, 5, 76, 0, 0, 1245, 1241, 1, 0, 0, 0, 1245, 1243, 1, 0, 0, 0, 1246, 298, 1, 0, 0, 0, 1247, 1251, 8, 10, 0, 0, 1248, 1251, 3, 301, 150, 0, 1249, 1251, 3, 265, 132, 0, 1250, 1247, 1, 0, 0, 0, 1250, 1248, 1, 0, 0, 0, 1250, 1249, 1, 0, 0, 0, 1251, 300, 1, 0, 0, 0, 1252, 1256, 3, 303, 151, 0, 1253, 1256, 3, 305, 152, 0, 1254, 1256, 3, 307, 153, 0, 1255, 1252, 1, 0, 0, 0, 1255, 1253, 1, 0, 0, 0, 1255, 1254, 1, 0, 0, 0, 1256, 302, 1, 0, 0, 0, 1257, 1258, 5, 92, 0, 0, 1258, 1288, 5, 39, 0, 0, 1259, 1260, 5, 92, 0, 0, 1260, 1288, 5, 34, 0, 0, 1261, 1262, 5, 92, 0, 0, 1262, 1288, 5, 63, 0, 0, 1263, 1264, 5, 92, 0, 0, 1264, 1288, 5, 92, 0, 0, 1265, 1266, 5, 92, 0, 0, 1266, 1288, 5, 97, 0, 0, 1267, 1268, 5, 92, 0, 0, 1268, 1288, 5, 98, 0, 0, 1269, 1270, 5, 92, 0, 0, 1270, 1288, 5, 102, 0, 0, 1271, 1272, 5, 92, 0, 0, 1272, 1288, 5, 110, 0, 0, 1273, 1274, 5, 92, 0, 0, 1274, 1288, 5, 114, 0, 0, 1275, 1281, 5, 92, 0, 0, 1276, 1278, 5, 13, 0, 0, 1277, 1279, 5, 10, 0, 0, 1278, 1277, 1, 0, 0, 0, 1278, 1279, 1, 0, 0, 0, 1279, 1282, 1, 0, 0, 0, 1280, 1282, 5, 10, 0, 0, 1281, 1276, 1, 0, 0, 0, 1281, 1280, 1, 0, 0, 0, 1282, 1288, 1, 0, 0, 0, 1283, 1284, 5, 92, 0, 0, 1284, 1288, 5, 116, 0, 0, 1285, 1286, 5, 92, 0, 0, 1286, 1288, 5, 118, 0, 0, 1287, 1257, 1, 0, 0, 0, 1287, 1259, 1, 0, 0, 0, 1287, 1261, 1, 0, 0, 0, 1287, 1263, 1, 0, 0, 0, 1287, 1265, 1, 0, 0, 0, 1287, 1267, 1, 0, 0, 0, 1287, 1269, 1, 0, 0, 0, 1287, 1271, 1, 0, 0, 0, 1287, 1273, 1, 0, 0, 0, 1287, 1275, 1, 0, 0, 0, 1287, 1283, 1, 0, 0, 0, 1287, 1285, 1, 0, 0, 0, 1288, 304, 1, 0, 0, 0, 1289, 1290, 5, 92, 0, 0, 1290, 1301, 3, 285, 142, 0, 1291, 1292, 5, 92, 0, 0, 1292, 1293, 3, 285, 142, 0, 1293, 1294, 3, 285, 142, 0, 1294, 1301, 1, 0, 0, 0, 1295, 1296, 5, 92, 0, 0, 1296, 1297, 3, 285, 142, 0, 1297, 1298, 3, 285, 142, 0, 1298, 1299, 3, 285, 142, 0, 1299, 1301, 1, 0, 0, 0, 1300, 1289, 1, 0, 0, 0, 1300, 1291, 1, 0, 0, 0, 1300, 1295, 1, 0, 0, 0, 1301, 306, 1, 0, 0, 0, 1302, 1303, 5, 92, 0, 0, 1303, 1304, 5, 120, 0, 0, 1304, 1306, 1, 0, 0, 0, 1305, 1307, 3, 287, 143, 0, 1306, 1305, 1, 0, 0, 0, 1307, 1308, 1, 0, 0, 0, 1308, 1306, 1, 0, 0, 0, 1308, 1309, 1, 0, 0, 0, 1309, 308, 1, 0, 0, 0, 1310, 1312, 3, 315, 157, 0, 1311, 1310, 1, 0, 0, 0, 1311, 1312, 1, 0, 0, 0, 1312, 1313, 1, 0, 0, 0, 1313, 1314, 5, 46, 0, 0, 1314, 1319, 3, 315, 157, 0, 1315, 1316, 3, 315, 157, 0, 1316, 1317, 5, 46, 0, 0, 1317, 1319, 1, 0, 0, 0, 1318, 1311, 1, 0, 0, 0, 1318, 1315, 1, 0, 0, 0, 1319, 310, 1, 0, 0, 0, 1320, 1322, 5, 101, 0, 0, 1321, 1323, 3, 313, 156, 0, 1322, 1321, 1, 0, 0, 0, 1322, 1323, 1, 0, 0, 0, 1323, 1324, 1, 0, 0, 0, 1324, 1331, 3, 315, 157, 0, 1325, 1327, 5, 69, 0, 0, 1326, 1328, 3, 313, 156, 0, 1327, 1326, 1, 0, 0, 0, 1327, 1328, 1, 0, 0, 0, 1328, 1329, 1, 0, 0, 0, 1329, 1331, 3, 315, 157, 0, 1330, 1320, 1, 0, 0, 0, 1330, 1325, 1, 0, 0, 0, 1331, 312, 1, 0, 0, 0, 1332, 1333, 7, 11, 0, 0, 1333, 314, 1, 0, 0, 0, 1334, 1341, 3, 273, 136, 0, 1335, 1337, 5, 39, 0, 0, 1336, 1335, 1, 0, 0, 0, 1336, 1337, 1, 0, 0, 0, 1337, 1338, 1, 0, 0, 0, 1338, 1340, 3, 273, 136, 0, 1339, 1336, 1, 0, 0, 0, 1340, 1343, 1, 0, 0, 0, 1341, 1339, 1, 0, 0, 0, 1341, 1342, 1, 0, 0, 0, 1342, 316, 1, 0, 0, 0, 1343, 1341, 1, 0, 0, 0, 1344, 1345, 7, 12, 0, 0, 1345, 318, 1, 0, 0, 0, 1346, 1347, 5, 117, 0, 0, 1347, 1350, 5, 56, 0, 0, 1348, 1350, 7, 0, 0, 0, 1349, 1346, 1, 0, 0, 0, 1349, 1348, 1, 0, 0, 0, 1350, 320, 1, 0, 0, 0, 1351, 1355, 8, 13, 0, 0, 1352, 1355, 3, 301, 150, 0, 1353, 1355, 3, 265, 132, 0, 1354, 1351, 1, 0, 0, 0, 1354, 1352, 1, 0, 0, 0, 1354, 1353, 1, 0, 0, 0, 1355, 322, 1, 0, 0, 0, 1356, 1357, 5, 82, 0, 0, 1357, 1358, 5, 34, 0, 0, 1358, 1364, 1, 0, 0, 0, 1359, 1360, 5, 92, 0, 0, 1360, 1363, 7, 14, 0, 0, 1361, 1363, 8, 15, 0, 0, 1362, 1359, 1, 0, 0, 0, 1362, 1361, 1, 0, 0, 0, 1363, 1366, 1, 0, 0, 0, 1364, 1365, 1, 0, 0, 0, 1364, 1362, 1, 0, 0, 0, 1365, 1367, 1, 0, 0, 0, 1366, 1364, 1, 0, 0, 0, 1367, 1371, 5, 40, 0, 0, 1368, 1370, 8, 16, 0, 0, 1369, 1368, 1, 0, 0, 0, 1370, 1373, 1, 0, 0, 0, 1371, 1372, 1, 0, 0, 0, 1371, 1369, 1, 0, 0, 0, 1372, 1374, 1, 0, 0, 0, 1373, 1371, 1, 0, 0, 0, 1374, 1380, 5, 41, 0, 0, 1375, 1376, 5, 92, 0, 0, 1376, 1379, 7, 14, 0, 0, 1377, 1379, 8, 17, 0, 0, 1378, 1375, 1, 0, 0, 0, 1378, 1377, 1, 0, 0, 0, 1379, 1382, 1, 0, 0, 0, 1380, 1381, 1, 0, 0, 0, 1380, 1378, 1, 0, 0, 0, 1381, 1383, 1, 0, 0, 0, 1382, 1380, 1, 0, 0, 0, 1383, 1384, 5, 34, 0, 0, 1384, 324, 1, 0, 0, 0, 1385, 1386, 3, 275, 137, 0, 1386, 1387, 3, 333, 166, 0, 1387, 1398, 1, 0, 0, 0, 1388, 1389, 3, 277, 138, 0, 1389, 1390, 3, 333, 166, 0, 1390, 1398, 1, 0, 0, 0, 1391, 1392, 3, 279, 139, 0, 1392, 1393, 3, 333, 166, 0, 1393, 1398, 1, 0, 0, 0, 1394, 1395, 3, 281, 140, 0, 1395, 1396, 3, 333, 166, 0, 1396, 1398, 1, 0, 0, 0, 1397, 1385, 1, 0, 0, 0, 1397, 1388, 1, 0, 0, 0, 1397, 1391, 1, 0, 0, 0, 1397, 1394, 1, 0, 0, 0, 1398, 326, 1, 0, 0, 0, 1399, 1401, 3, 309, 154, 0, 1400, 1402, 3, 311, 155, 0, 1401, 1400, 1, 0, 0, 0, 1401, 1402, 1, 0, 0, 0, 1402, 1403, 1, 0, 0, 0, 1403, 1404, 3, 333, 166, 0, 1404, 1410, 1, 0, 0, 0, 1405, 1406, 3, 315, 157, 0, 1406, 1407, 3, 311, 155, 0, 1407, 1408, 3, 333, 166, 0, 1408, 1410, 1, 0, 0, 0, 1409, 1399, 1, 0, 0, 0, 1409, 1405, 1, 0, 0, 0, 1410, 328, 1, 0, 0, 0, 1411, 1412, 3, 7, 3, 0, 1412, 1413, 3, 333, 166, 0, 1413, 330, 1, 0, 0, 0, 1414, 1415, 3, 3, 1, 0, 1415, 1416, 3, 333, 166, 0, 1416, 332, 1, 0, 0, 0, 1417, 1418, 3, 267, 133, 0, 1418, 334, 1, 0, 0, 0, 1419, 1421, 7, 18, 0, 0, 1420, 1419, 1, 0, 0, 0, 1421, 1422, 1, 0, 0, 0, 1422, 1420, 1, 0, 0, 0, 1422, 1423, 1, 0, 0, 0, 1423, 1424, 1, 0, 0, 0, 1424, 1425, 6, 167, 1, 0, 1425, 336, 1, 0, 0, 0, 1426, 1428, 5, 13, 0, 0, 1427, 1429, 5, 10, 0, 0, 1428, 1427, 1, 0, 0, 0, 1428, 1429, 1, 0, 0, 0, 1429, 1432, 1, 0, 0, 0, 1430, 1432, 5, 10, 0, 0, 1431, 1426, 1, 0, 0, 0, 1431, 1430, 1, 0, 0, 0, 1432, 1433, 1, 0, 0, 0, 1433, 1434, 6, 168, 1, 0, 1434, 338, 1, 0, 0, 0, 1435, 1436, 5, 47, 0, 0, 1436, 1437, 5, 42, 0, 0, 1437, 1441, 1, 0, 0, 0, 1438, 1440, 9, 0, 0, 0, 1439, 1438, 1, 0, 0, 0, 1440, 1443, 1, 0, 0, 0, 1441, 1442, 1, 0, 0, 0, 1441, 1439, 1, 0, 0, 0, 1442, 1444, 1, 0, 0, 0, 1443, 1441, 1, 0, 0, 0, 1444, 1445, 5, 42, 0, 0, 1445, 1446, 5, 47, 0, 0, 1446, 1447, 1, 0, 0, 0, 1447, 1448, 6, 169, 1, 0, 1448, 340, 1, 0, 0, 0, 1449, 1450, 5, 47, 0, 0, 1450, 1451, 5, 47, 0, 0, 1451, 1455, 1, 0, 0, 0, 1452, 1454, 8, 19, 0, 0, 1453, 1452, 1, 0, 0, 0, 1454, 1457, 1, 0, 0, 0, 1455, 1453, 1, 0, 0, 0, 1455, 1456, 1, 0, 0, 0, 1456, 1458, 1, 0, 0, 0, 1457, 1455, 1, 0, 0, 0, 1458, 1459, 6, 170, 1, 0, 1459, 342, 1, 0, 0, 0, 74, 0, 345, 349, 353, 357, 359, 362, 368, 374, 377, 382, 384, 387, 394, 398, 402, 410, 416, 421, 426, 431, 439, 1028, 1085, 1091, 1141, 1146, 1148, 1153, 1161, 1166, 1171, 1176, 1183, 1187, 1192, 1199, 1203, 1208, 1221, 1225, 1229, 1233, 1235, 1245, 1250, 1255, 1278, 1281, 1287, 1300, 1308, 1311, 1318, 1322, 1327, 1330, 1336, 1341, 1349, 1354, 1362, 1364, 1371, 1378, 1380, 1397, 1401, 1409, 1422, 1428, 1431, 1441, 1455, 2, 0, 1, 0, 6, 0, 0]
```

`src/main/java/com/lauriewired/malimite/decompile/antlr/CPP14Lexer.java`:

```java
// Generated from CPP14Lexer.g4 by ANTLR 4.13.1
package com.lauriewired.malimite.decompile.antlr;
import org.antlr.v4.runtime.Lexer;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.TokenStream;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.atn.*;
import org.antlr.v4.runtime.dfa.DFA;
import org.antlr.v4.runtime.misc.*;

@SuppressWarnings({"all", "warnings", "unchecked", "unused", "cast", "CheckReturnValue", "this-escape"})
public class CPP14Lexer extends Lexer {
	static { RuntimeMetaData.checkVersion("4.13.1", RuntimeMetaData.VERSION); }

	protected static final DFA[] _decisionToDFA;
	protected static final PredictionContextCache _sharedContextCache =
		new PredictionContextCache();
	public static final int
		IntegerLiteral=1, CharacterLiteral=2, FloatingLiteral=3, StringLiteral=4, 
		BooleanLiteral=5, PointerLiteral=6, UserDefinedLiteral=7, MultiLineMacro=8, 
		Directive=9, Alignas=10, Alignof=11, Asm=12, Auto=13, Bool=14, Break=15, 
		Case=16, Catch=17, Char=18, Char16=19, Char32=20, Class=21, Const=22, 
		Constexpr=23, Const_cast=24, Continue=25, Decltype=26, Default=27, Delete=28, 
		Do=29, Double=30, Dynamic_cast=31, Else=32, Enum=33, Explicit=34, Export=35, 
		Extern=36, False_=37, Final=38, Float=39, For=40, Friend=41, Goto=42, 
		If=43, Inline=44, Int=45, Long=46, Mutable=47, Namespace=48, New=49, Noexcept=50, 
		Nullptr=51, Operator=52, Override=53, Private=54, Protected=55, Public=56, 
		Register=57, Reinterpret_cast=58, Return=59, Short=60, Signed=61, Sizeof=62, 
		Static=63, Static_assert=64, Static_cast=65, Struct=66, Switch=67, Template=68, 
		This=69, Thread_local=70, Throw=71, True_=72, Try=73, Typedef=74, Typeid_=75, 
		Typename_=76, Union=77, Unsigned=78, Using=79, Virtual=80, Void=81, Volatile=82, 
		Wchar=83, While=84, LeftParen=85, RightParen=86, LeftBracket=87, RightBracket=88, 
		LeftBrace=89, RightBrace=90, Plus=91, Minus=92, Star=93, Div=94, Mod=95, 
		Caret=96, And=97, Or=98, Tilde=99, Not=100, Assign=101, Less=102, Greater=103, 
		PlusAssign=104, MinusAssign=105, StarAssign=106, DivAssign=107, ModAssign=108, 
		XorAssign=109, AndAssign=110, OrAssign=111, LeftShiftAssign=112, RightShiftAssign=113, 
		Equal=114, NotEqual=115, LessEqual=116, GreaterEqual=117, AndAnd=118, 
		OrOr=119, PlusPlus=120, MinusMinus=121, Comma=122, ArrowStar=123, Arrow=124, 
		Question=125, Colon=126, Doublecolon=127, Semi=128, Dot=129, DotStar=130, 
		Ellipsis=131, Identifier=132, DecimalLiteral=133, OctalLiteral=134, HexadecimalLiteral=135, 
		BinaryLiteral=136, Integersuffix=137, UserDefinedIntegerLiteral=138, UserDefinedFloatingLiteral=139, 
		UserDefinedStringLiteral=140, UserDefinedCharacterLiteral=141, Whitespace=142, 
		Newline=143, BlockComment=144, LineComment=145;
	public static String[] channelNames = {
		"DEFAULT_TOKEN_CHANNEL", "HIDDEN"
	};

	public static String[] modeNames = {
		"DEFAULT_MODE"
	};

	private static String[] makeRuleNames() {
		return new String[] {
			"IntegerLiteral", "CharacterLiteral", "FloatingLiteral", "StringLiteral", 
			"BooleanLiteral", "PointerLiteral", "UserDefinedLiteral", "MultiLineMacro", 
			"Directive", "Alignas", "Alignof", "Asm", "Auto", "Bool", "Break", "Case", 
			"Catch", "Char", "Char16", "Char32", "Class", "Const", "Constexpr", "Const_cast", 
			"Continue", "Decltype", "Default", "Delete", "Do", "Double", "Dynamic_cast", 
			"Else", "Enum", "Explicit", "Export", "Extern", "False_", "Final", "Float", 
			"For", "Friend", "Goto", "If", "Inline", "Int", "Long", "Mutable", "Namespace", 
			"New", "Noexcept", "Nullptr", "Operator", "Override", "Private", "Protected", 
			"Public", "Register", "Reinterpret_cast", "Return", "Short", "Signed", 
			"Sizeof", "Static", "Static_assert", "Static_cast", "Struct", "Switch", 
			"Template", "This", "Thread_local", "Throw", "True_", "Try", "Typedef", 
			"Typeid_", "Typename_", "Union", "Unsigned", "Using", "Virtual", "Void", 
			"Volatile", "Wchar", "While", "LeftParen", "RightParen", "LeftBracket", 
			"RightBracket", "LeftBrace", "RightBrace", "Plus", "Minus", "Star", "Div", 
			"Mod", "Caret", "And", "Or", "Tilde", "Not", "Assign", "Less", "Greater", 
			"PlusAssign", "MinusAssign", "StarAssign", "DivAssign", "ModAssign", 
			"XorAssign", "AndAssign", "OrAssign", "LeftShiftAssign", "RightShiftAssign", 
			"Equal", "NotEqual", "LessEqual", "GreaterEqual", "AndAnd", "OrOr", "PlusPlus", 
			"MinusMinus", "Comma", "ArrowStar", "Arrow", "Question", "Colon", "Doublecolon", 
			"Semi", "Dot", "DotStar", "Ellipsis", "Hexquad", "Universalcharactername", 
			"Identifier", "Identifiernondigit", "NONDIGIT", "DIGIT", "DecimalLiteral", 
			"OctalLiteral", "HexadecimalLiteral", "BinaryLiteral", "NONZERODIGIT", 
			"OCTALDIGIT", "HEXADECIMALDIGIT", "BINARYDIGIT", "Integersuffix", "Unsignedsuffix", 
			"Longsuffix", "Longlongsuffix", "Cchar", "Escapesequence", "Simpleescapesequence", 
			"Octalescapesequence", "Hexadecimalescapesequence", "Fractionalconstant", 
			"Exponentpart", "SIGN", "Digitsequence", "Floatingsuffix", "Encodingprefix", 
			"Schar", "Rawstring", "UserDefinedIntegerLiteral", "UserDefinedFloatingLiteral", 
			"UserDefinedStringLiteral", "UserDefinedCharacterLiteral", "Udsuffix", 
			"Whitespace", "Newline", "BlockComment", "LineComment"
		};
	}
	public static final String[] ruleNames = makeRuleNames();

	private static String[] makeLiteralNames() {
		return new String[] {
			null, null, null, null, null, null, null, null, null, null, "'alignas'", 
			"'alignof'", "'asm'", "'auto'", "'bool'", "'break'", "'case'", "'catch'", 
			"'char'", "'char16_t'", "'char32_t'", "'class'", "'const'", "'constexpr'", 
			"'const_cast'", "'continue'", "'decltype'", "'default'", "'delete'", 
			"'do'", "'double'", "'dynamic_cast'", "'else'", "'enum'", "'explicit'", 
			"'export'", "'extern'", "'false'", "'final'", "'float'", "'for'", "'friend'", 
			"'goto'", "'if'", "'inline'", "'int'", "'long'", "'mutable'", "'namespace'", 
			"'new'", "'noexcept'", "'nullptr'", "'operator'", "'override'", "'private'", 
			"'protected'", "'public'", "'register'", "'reinterpret_cast'", "'return'", 
			"'short'", "'signed'", "'sizeof'", "'static'", "'static_assert'", "'static_cast'", 
			"'struct'", "'switch'", "'template'", "'this'", "'thread_local'", "'throw'", 
			"'true'", "'try'", "'typedef'", "'typeid'", "'typename'", "'union'", 
			"'unsigned'", "'using'", "'virtual'", "'void'", "'volatile'", "'wchar_t'", 
			"'while'", "'('", "')'", "'['", "']'", "'{'", "'}'", "'+'", "'-'", "'*'", 
			"'/'", "'%'", "'^'", "'&'", "'|'", "'~'", null, "'='", "'<'", "'>'", 
			"'+='", "'-='", "'*='", "'/='", "'%='", "'^='", "'&='", "'|='", "'<<='", 
			"'>>='", "'=='", "'!='", "'<='", "'>='", null, null, "'++'", "'--'", 
			"','", "'->*'", "'->'", "'?'", "':'", "'::'", "';'", "'.'", "'.*'", "'...'"
		};
	}
	private static final String[] _LITERAL_NAMES = makeLiteralNames();
	private static String[] makeSymbolicNames() {
		return new String[] {
			null, "IntegerLiteral", "CharacterLiteral", "FloatingLiteral", "StringLiteral", 
			"BooleanLiteral", "PointerLiteral", "UserDefinedLiteral", "MultiLineMacro", 
			"Directive", "Alignas", "Alignof", "Asm", "Auto", "Bool", "Break", "Case", 
			"Catch", "Char", "Char16", "Char32", "Class", "Const", "Constexpr", "Const_cast", 
			"Continue", "Decltype", "Default", "Delete", "Do", "Double", "Dynamic_cast", 
			"Else", "Enum", "Explicit", "Export", "Extern", "False_", "Final", "Float", 
			"For", "Friend", "Goto", "If", "Inline", "Int", "Long", "Mutable", "Namespace", 
			"New", "Noexcept", "Nullptr", "Operator", "Override", "Private", "Protected", 
			"Public", "Register", "Reinterpret_cast", "Return", "Short", "Signed", 
			"Sizeof", "Static", "Static_assert", "Static_cast", "Struct", "Switch", 
			"Template", "This", "Thread_local", "Throw", "True_", "Try", "Typedef", 
			"Typeid_", "Typename_", "Union", "Unsigned", "Using", "Virtual", "Void", 
			"Volatile", "Wchar", "While", "LeftParen", "RightParen", "LeftBracket", 
			"RightBracket", "LeftBrace", "RightBrace", "Plus", "Minus", "Star", "Div", 
			"Mod", "Caret", "And", "Or", "Tilde", "Not", "Assign", "Less", "Greater", 
			"PlusAssign", "MinusAssign", "StarAssign", "DivAssign", "ModAssign", 
			"XorAssign", "AndAssign", "OrAssign", "LeftShiftAssign", "RightShiftAssign", 
			"Equal", "NotEqual", "LessEqual", "GreaterEqual", "AndAnd", "OrOr", "PlusPlus", 
			"MinusMinus", "Comma", "ArrowStar", "Arrow", "Question", "Colon", "Doublecolon", 
			"Semi", "Dot", "DotStar", "Ellipsis", "Identifier", "DecimalLiteral", 
			"OctalLiteral", "HexadecimalLiteral", "BinaryLiteral", "Integersuffix", 
			"UserDefinedIntegerLiteral", "UserDefinedFloatingLiteral", "UserDefinedStringLiteral", 
			"UserDefinedCharacterLiteral", "Whitespace", "Newline", "BlockComment", 
			"LineComment"
		};
	}
	private static final String[] _SYMBOLIC_NAMES = makeSymbolicNames();
	public static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);

	/**
	 * @deprecated Use {@link #VOCABULARY} instead.
	 */
	@Deprecated
	public static final String[] tokenNames;
	static {
		tokenNames = new String[_SYMBOLIC_NAMES.length];
		for (int i = 0; i < tokenNames.length; i++) {
			tokenNames[i] = VOCABULARY.getLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = VOCABULARY.getSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}
	}

	@Override
	@Deprecated
	public String[] getTokenNames() {
		return tokenNames;
	}

	@Override

	public Vocabulary getVocabulary() {
		return VOCABULARY;
	}


	public CPP14Lexer(CharStream input) {
		super(input);
		_interp = new LexerATNSimulator(this,_ATN,_decisionToDFA,_sharedContextCache);
	}

	@Override
	public String getGrammarFileName() { return "CPP14Lexer.g4"; }

	@Override
	public String[] getRuleNames() { return ruleNames; }

	@Override
	public String getSerializedATN() { return _serializedATN; }

	@Override
	public String[] getChannelNames() { return channelNames; }

	@Override
	public String[] getModeNames() { return modeNames; }

	@Override
	public ATN getATN() { return _ATN; }

	public static final String _serializedATN =
		"\u0004\u0000\u0091\u05b4\u0006\uffff\uffff\u0002\u0000\u0007\u0000\u0002"+
		"\u0001\u0007\u0001\u0002\u0002\u0007\u0002\u0002\u0003\u0007\u0003\u0002"+
		"\u0004\u0007\u0004\u0002\u0005\u0007\u0005\u0002\u0006\u0007\u0006\u0002"+
		"\u0007\u0007\u0007\u0002\b\u0007\b\u0002\t\u0007\t\u0002\n\u0007\n\u0002"+
		"\u000b\u0007\u000b\u0002\f\u0007\f\u0002\r\u0007\r\u0002\u000e\u0007\u000e"+
		"\u0002\u000f\u0007\u000f\u0002\u0010\u0007\u0010\u0002\u0011\u0007\u0011"+
		"\u0002\u0012\u0007\u0012\u0002\u0013\u0007\u0013\u0002\u0014\u0007\u0014"+
		"\u0002\u0015\u0007\u0015\u0002\u0016\u0007\u0016\u0002\u0017\u0007\u0017"+
		"\u0002\u0018\u0007\u0018\u0002\u0019\u0007\u0019\u0002\u001a\u0007\u001a"+
		"\u0002\u001b\u0007\u001b\u0002\u001c\u0007\u001c\u0002\u001d\u0007\u001d"+
		"\u0002\u001e\u0007\u001e\u0002\u001f\u0007\u001f\u0002 \u0007 \u0002!"+
		"\u0007!\u0002\"\u0007\"\u0002#\u0007#\u0002$\u0007$\u0002%\u0007%\u0002"+
		"&\u0007&\u0002\'\u0007\'\u0002(\u0007(\u0002)\u0007)\u0002*\u0007*\u0002"+
		"+\u0007+\u0002,\u0007,\u0002-\u0007-\u0002.\u0007.\u0002/\u0007/\u0002"+
		"0\u00070\u00021\u00071\u00022\u00072\u00023\u00073\u00024\u00074\u0002"+
		"5\u00075\u00026\u00076\u00027\u00077\u00028\u00078\u00029\u00079\u0002"+
		":\u0007:\u0002;\u0007;\u0002<\u0007<\u0002=\u0007=\u0002>\u0007>\u0002"+
		"?\u0007?\u0002@\u0007@\u0002A\u0007A\u0002B\u0007B\u0002C\u0007C\u0002"+
		"D\u0007D\u0002E\u0007E\u0002F\u0007F\u0002G\u0007G\u0002H\u0007H\u0002"+
		"I\u0007I\u0002J\u0007J\u0002K\u0007K\u0002L\u0007L\u0002M\u0007M\u0002"+
		"N\u0007N\u0002O\u0007O\u0002P\u0007P\u0002Q\u0007Q\u0002R\u0007R\u0002"+
		"S\u0007S\u0002T\u0007T\u0002U\u0007U\u0002V\u0007V\u0002W\u0007W\u0002"+
		"X\u0007X\u0002Y\u0007Y\u0002Z\u0007Z\u0002[\u0007[\u0002\\\u0007\\\u0002"+
		"]\u0007]\u0002^\u0007^\u0002_\u0007_\u0002`\u0007`\u0002a\u0007a\u0002"+
		"b\u0007b\u0002c\u0007c\u0002d\u0007d\u0002e\u0007e\u0002f\u0007f\u0002"+
		"g\u0007g\u0002h\u0007h\u0002i\u0007i\u0002j\u0007j\u0002k\u0007k\u0002"+
		"l\u0007l\u0002m\u0007m\u0002n\u0007n\u0002o\u0007o\u0002p\u0007p\u0002"+
		"q\u0007q\u0002r\u0007r\u0002s\u0007s\u0002t\u0007t\u0002u\u0007u\u0002"+
		"v\u0007v\u0002w\u0007w\u0002x\u0007x\u0002y\u0007y\u0002z\u0007z\u0002"+
		"{\u0007{\u0002|\u0007|\u0002}\u0007}\u0002~\u0007~\u0002\u007f\u0007\u007f"+
		"\u0002\u0080\u0007\u0080\u0002\u0081\u0007\u0081\u0002\u0082\u0007\u0082"+
		"\u0002\u0083\u0007\u0083\u0002\u0084\u0007\u0084\u0002\u0085\u0007\u0085"+
		"\u0002\u0086\u0007\u0086\u0002\u0087\u0007\u0087\u0002\u0088\u0007\u0088"+
		"\u0002\u0089\u0007\u0089\u0002\u008a\u0007\u008a\u0002\u008b\u0007\u008b"+
		"\u0002\u008c\u0007\u008c\u0002\u008d\u0007\u008d\u0002\u008e\u0007\u008e"+
		"\u0002\u008f\u0007\u008f\u0002\u0090\u0007\u0090\u0002\u0091\u0007\u0091"+
		"\u0002\u0092\u0007\u0092\u0002\u0093\u0007\u0093\u0002\u0094\u0007\u0094"+
		"\u0002\u0095\u0007\u0095\u0002\u0096\u0007\u0096\u0002\u0097\u0007\u0097"+
		"\u0002\u0098\u0007\u0098\u0002\u0099\u0007\u0099\u0002\u009a\u0007\u009a"+
		"\u0002\u009b\u0007\u009b\u0002\u009c\u0007\u009c\u0002\u009d\u0007\u009d"+
		"\u0002\u009e\u0007\u009e\u0002\u009f\u0007\u009f\u0002\u00a0\u0007\u00a0"+
		"\u0002\u00a1\u0007\u00a1\u0002\u00a2\u0007\u00a2\u0002\u00a3\u0007\u00a3"+
		"\u0002\u00a4\u0007\u00a4\u0002\u00a5\u0007\u00a5\u0002\u00a6\u0007\u00a6"+
		"\u0002\u00a7\u0007\u00a7\u0002\u00a8\u0007\u00a8\u0002\u00a9\u0007\u00a9"+
		"\u0002\u00aa\u0007\u00aa\u0001\u0000\u0001\u0000\u0003\u0000\u015a\b\u0000"+
		"\u0001\u0000\u0001\u0000\u0003\u0000\u015e\b\u0000\u0001\u0000\u0001\u0000"+
		"\u0003\u0000\u0162\b\u0000\u0001\u0000\u0001\u0000\u0003\u0000\u0166\b"+
		"\u0000\u0003\u0000\u0168\b\u0000\u0001\u0001\u0003\u0001\u016b\b\u0001"+
		"\u0001\u0001\u0001\u0001\u0004\u0001\u016f\b\u0001\u000b\u0001\f\u0001"+
		"\u0170\u0001\u0001\u0001\u0001\u0001\u0002\u0001\u0002\u0003\u0002\u0177"+
		"\b\u0002\u0001\u0002\u0003\u0002\u017a\b\u0002\u0001\u0002\u0001\u0002"+
		"\u0001\u0002\u0003\u0002\u017f\b\u0002\u0003\u0002\u0181\b\u0002\u0001"+
		"\u0003\u0003\u0003\u0184\b\u0003\u0001\u0003\u0001\u0003\u0001\u0003\u0005"+
		"\u0003\u0189\b\u0003\n\u0003\f\u0003\u018c\t\u0003\u0001\u0003\u0003\u0003"+
		"\u018f\b\u0003\u0001\u0004\u0001\u0004\u0003\u0004\u0193\b\u0004\u0001"+
		"\u0005\u0001\u0005\u0001\u0006\u0001\u0006\u0001\u0006\u0001\u0006\u0003"+
		"\u0006\u019b\b\u0006\u0001\u0007\u0001\u0007\u0005\u0007\u019f\b\u0007"+
		"\n\u0007\f\u0007\u01a2\t\u0007\u0001\u0007\u0001\u0007\u0003\u0007\u01a6"+
		"\b\u0007\u0001\u0007\u0004\u0007\u01a9\b\u0007\u000b\u0007\f\u0007\u01aa"+
		"\u0001\u0007\u0004\u0007\u01ae\b\u0007\u000b\u0007\f\u0007\u01af\u0001"+
		"\u0007\u0001\u0007\u0001\b\u0001\b\u0005\b\u01b6\b\b\n\b\f\b\u01b9\t\b"+
		"\u0001\b\u0001\b\u0001\t\u0001\t\u0001\t\u0001\t\u0001\t\u0001\t\u0001"+
		"\t\u0001\t\u0001\n\u0001\n\u0001\n\u0001\n\u0001\n\u0001\n\u0001\n\u0001"+
		"\n\u0001\u000b\u0001\u000b\u0001\u000b\u0001\u000b\u0001\f\u0001\f\u0001"+
		"\f\u0001\f\u0001\f\u0001\r\u0001\r\u0001\r\u0001\r\u0001\r\u0001\u000e"+
		"\u0001\u000e\u0001\u000e\u0001\u000e\u0001\u000e\u0001\u000e\u0001\u000f"+
		"\u0001\u000f\u0001\u000f\u0001\u000f\u0001\u000f\u0001\u0010\u0001\u0010"+
		"\u0001\u0010\u0001\u0010\u0001\u0010\u0001\u0010\u0001\u0011\u0001\u0011"+
		"\u0001\u0011\u0001\u0011\u0001\u0011\u0001\u0012\u0001\u0012\u0001\u0012"+
		"\u0001\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0001\u0012"+
		"\u0001\u0013\u0001\u0013\u0001\u0013\u0001\u0013\u0001\u0013\u0001\u0013"+
		"\u0001\u0013\u0001\u0013\u0001\u0013\u0001\u0014\u0001\u0014\u0001\u0014"+
		"\u0001\u0014\u0001\u0014\u0001\u0014\u0001\u0015\u0001\u0015\u0001\u0015"+
		"\u0001\u0015\u0001\u0015\u0001\u0015\u0001\u0016\u0001\u0016\u0001\u0016"+
		"\u0001\u0016\u0001\u0016\u0001\u0016\u0001\u0016\u0001\u0016\u0001\u0016"+
		"\u0001\u0016\u0001\u0017\u0001\u0017\u0001\u0017\u0001\u0017\u0001\u0017"+
		"\u0001\u0017\u0001\u0017\u0001\u0017\u0001\u0017\u0001\u0017\u0001\u0017"+
		"\u0001\u0018\u0001\u0018\u0001\u0018\u0001\u0018\u0001\u0018\u0001\u0018"+
		"\u0001\u0018\u0001\u0018\u0001\u0018\u0001\u0019\u0001\u0019\u0001\u0019"+
		"\u0001\u0019\u0001\u0019\u0001\u0019\u0001\u0019\u0001\u0019\u0001\u0019"+
		"\u0001\u001a\u0001\u001a\u0001\u001a\u0001\u001a\u0001\u001a\u0001\u001a"+
		"\u0001\u001a\u0001\u001a\u0001\u001b\u0001\u001b\u0001\u001b\u0001\u001b"+
		"\u0001\u001b\u0001\u001b\u0001\u001b\u0001\u001c\u0001\u001c\u0001\u001c"+
		"\u0001\u001d\u0001\u001d\u0001\u001d\u0001\u001d\u0001\u001d\u0001\u001d"+
		"\u0001\u001d\u0001\u001e\u0001\u001e\u0001\u001e\u0001\u001e\u0001\u001e"+
		"\u0001\u001e\u0001\u001e\u0001\u001e\u0001\u001e\u0001\u001e\u0001\u001e"+
		"\u0001\u001e\u0001\u001e\u0001\u001f\u0001\u001f\u0001\u001f\u0001\u001f"+
		"\u0001\u001f\u0001 \u0001 \u0001 \u0001 \u0001 \u0001!\u0001!\u0001!\u0001"+
		"!\u0001!\u0001!\u0001!\u0001!\u0001!\u0001\"\u0001\"\u0001\"\u0001\"\u0001"+
		"\"\u0001\"\u0001\"\u0001#\u0001#\u0001#\u0001#\u0001#\u0001#\u0001#\u0001"+
		"$\u0001$\u0001$\u0001$\u0001$\u0001$\u0001%\u0001%\u0001%\u0001%\u0001"+
		"%\u0001%\u0001&\u0001&\u0001&\u0001&\u0001&\u0001&\u0001\'\u0001\'\u0001"+
		"\'\u0001\'\u0001(\u0001(\u0001(\u0001(\u0001(\u0001(\u0001(\u0001)\u0001"+
		")\u0001)\u0001)\u0001)\u0001*\u0001*\u0001*\u0001+\u0001+\u0001+\u0001"+
		"+\u0001+\u0001+\u0001+\u0001,\u0001,\u0001,\u0001,\u0001-\u0001-\u0001"+
		"-\u0001-\u0001-\u0001.\u0001.\u0001.\u0001.\u0001.\u0001.\u0001.\u0001"+
		".\u0001/\u0001/\u0001/\u0001/\u0001/\u0001/\u0001/\u0001/\u0001/\u0001"+
		"/\u00010\u00010\u00010\u00010\u00011\u00011\u00011\u00011\u00011\u0001"+
		"1\u00011\u00011\u00011\u00012\u00012\u00012\u00012\u00012\u00012\u0001"+
		"2\u00012\u00013\u00013\u00013\u00013\u00013\u00013\u00013\u00013\u0001"+
		"3\u00014\u00014\u00014\u00014\u00014\u00014\u00014\u00014\u00014\u0001"+
		"5\u00015\u00015\u00015\u00015\u00015\u00015\u00015\u00016\u00016\u0001"+
		"6\u00016\u00016\u00016\u00016\u00016\u00016\u00016\u00017\u00017\u0001"+
		"7\u00017\u00017\u00017\u00017\u00018\u00018\u00018\u00018\u00018\u0001"+
		"8\u00018\u00018\u00018\u00019\u00019\u00019\u00019\u00019\u00019\u0001"+
		"9\u00019\u00019\u00019\u00019\u00019\u00019\u00019\u00019\u00019\u0001"+
		"9\u0001:\u0001:\u0001:\u0001:\u0001:\u0001:\u0001:\u0001;\u0001;\u0001"+
		";\u0001;\u0001;\u0001;\u0001<\u0001<\u0001<\u0001<\u0001<\u0001<\u0001"+
		"<\u0001=\u0001=\u0001=\u0001=\u0001=\u0001=\u0001=\u0001>\u0001>\u0001"+
		">\u0001>\u0001>\u0001>\u0001>\u0001?\u0001?\u0001?\u0001?\u0001?\u0001"+
		"?\u0001?\u0001?\u0001?\u0001?\u0001?\u0001?\u0001?\u0001?\u0001@\u0001"+
		"@\u0001@\u0001@\u0001@\u0001@\u0001@\u0001@\u0001@\u0001@\u0001@\u0001"+
		"@\u0001A\u0001A\u0001A\u0001A\u0001A\u0001A\u0001A\u0001B\u0001B\u0001"+
		"B\u0001B\u0001B\u0001B\u0001B\u0001C\u0001C\u0001C\u0001C\u0001C\u0001"+
		"C\u0001C\u0001C\u0001C\u0001D\u0001D\u0001D\u0001D\u0001D\u0001E\u0001"+
		"E\u0001E\u0001E\u0001E\u0001E\u0001E\u0001E\u0001E\u0001E\u0001E\u0001"+
		"E\u0001E\u0001F\u0001F\u0001F\u0001F\u0001F\u0001F\u0001G\u0001G\u0001"+
		"G\u0001G\u0001G\u0001H\u0001H\u0001H\u0001H\u0001I\u0001I\u0001I\u0001"+
		"I\u0001I\u0001I\u0001I\u0001I\u0001J\u0001J\u0001J\u0001J\u0001J\u0001"+
		"J\u0001J\u0001K\u0001K\u0001K\u0001K\u0001K\u0001K\u0001K\u0001K\u0001"+
		"K\u0001L\u0001L\u0001L\u0001L\u0001L\u0001L\u0001M\u0001M\u0001M\u0001"+
		"M\u0001M\u0001M\u0001M\u0001M\u0001M\u0001N\u0001N\u0001N\u0001N\u0001"+
		"N\u0001N\u0001O\u0001O\u0001O\u0001O\u0001O\u0001O\u0001O\u0001O\u0001"+
		"P\u0001P\u0001P\u0001P\u0001P\u0001Q\u0001Q\u0001Q\u0001Q\u0001Q\u0001"+
		"Q\u0001Q\u0001Q\u0001Q\u0001R\u0001R\u0001R\u0001R\u0001R\u0001R\u0001"+
		"R\u0001R\u0001S\u0001S\u0001S\u0001S\u0001S\u0001S\u0001T\u0001T\u0001"+
		"U\u0001U\u0001V\u0001V\u0001W\u0001W\u0001X\u0001X\u0001Y\u0001Y\u0001"+
		"Z\u0001Z\u0001[\u0001[\u0001\\\u0001\\\u0001]\u0001]\u0001^\u0001^\u0001"+
		"_\u0001_\u0001`\u0001`\u0001a\u0001a\u0001b\u0001b\u0001c\u0001c\u0001"+
		"c\u0001c\u0003c\u0405\bc\u0001d\u0001d\u0001e\u0001e\u0001f\u0001f\u0001"+
		"g\u0001g\u0001g\u0001h\u0001h\u0001h\u0001i\u0001i\u0001i\u0001j\u0001"+
		"j\u0001j\u0001k\u0001k\u0001k\u0001l\u0001l\u0001l\u0001m\u0001m\u0001"+
		"m\u0001n\u0001n\u0001n\u0001o\u0001o\u0001o\u0001o\u0001p\u0001p\u0001"+
		"p\u0001p\u0001q\u0001q\u0001q\u0001r\u0001r\u0001r\u0001s\u0001s\u0001"+
		"s\u0001t\u0001t\u0001t\u0001u\u0001u\u0001u\u0001u\u0001u\u0003u\u043e"+
		"\bu\u0001v\u0001v\u0001v\u0001v\u0003v\u0444\bv\u0001w\u0001w\u0001w\u0001"+
		"x\u0001x\u0001x\u0001y\u0001y\u0001z\u0001z\u0001z\u0001z\u0001{\u0001"+
		"{\u0001{\u0001|\u0001|\u0001}\u0001}\u0001~\u0001~\u0001~\u0001\u007f"+
		"\u0001\u007f\u0001\u0080\u0001\u0080\u0001\u0081\u0001\u0081\u0001\u0081"+
		"\u0001\u0082\u0001\u0082\u0001\u0082\u0001\u0082\u0001\u0083\u0001\u0083"+
		"\u0001\u0083\u0001\u0083\u0001\u0083\u0001\u0084\u0001\u0084\u0001\u0084"+
		"\u0001\u0084\u0001\u0084\u0001\u0084\u0001\u0084\u0001\u0084\u0001\u0084"+
		"\u0001\u0084\u0003\u0084\u0476\b\u0084\u0001\u0085\u0001\u0085\u0001\u0085"+
		"\u0005\u0085\u047b\b\u0085\n\u0085\f\u0085\u047e\t\u0085\u0001\u0086\u0001"+
		"\u0086\u0003\u0086\u0482\b\u0086\u0001\u0087\u0001\u0087\u0001\u0088\u0001"+
		"\u0088\u0001\u0089\u0001\u0089\u0003\u0089\u048a\b\u0089\u0001\u0089\u0005"+
		"\u0089\u048d\b\u0089\n\u0089\f\u0089\u0490\t\u0089\u0001\u008a\u0001\u008a"+
		"\u0003\u008a\u0494\b\u008a\u0001\u008a\u0005\u008a\u0497\b\u008a\n\u008a"+
		"\f\u008a\u049a\t\u008a\u0001\u008b\u0001\u008b\u0001\u008b\u0001\u008b"+
		"\u0003\u008b\u04a0\b\u008b\u0001\u008b\u0001\u008b\u0003\u008b\u04a4\b"+
		"\u008b\u0001\u008b\u0005\u008b\u04a7\b\u008b\n\u008b\f\u008b\u04aa\t\u008b"+
		"\u0001\u008c\u0001\u008c\u0001\u008c\u0001\u008c\u0003\u008c\u04b0\b\u008c"+
		"\u0001\u008c\u0001\u008c\u0003\u008c\u04b4\b\u008c\u0001\u008c\u0005\u008c"+
		"\u04b7\b\u008c\n\u008c\f\u008c\u04ba\t\u008c\u0001\u008d\u0001\u008d\u0001"+
		"\u008e\u0001\u008e\u0001\u008f\u0001\u008f\u0001\u0090\u0001\u0090\u0001"+
		"\u0091\u0001\u0091\u0003\u0091\u04c6\b\u0091\u0001\u0091\u0001\u0091\u0003"+
		"\u0091\u04ca\b\u0091\u0001\u0091\u0001\u0091\u0003\u0091\u04ce\b\u0091"+
		"\u0001\u0091\u0001\u0091\u0003\u0091\u04d2\b\u0091\u0003\u0091\u04d4\b"+
		"\u0091\u0001\u0092\u0001\u0092\u0001\u0093\u0001\u0093\u0001\u0094\u0001"+
		"\u0094\u0001\u0094\u0001\u0094\u0003\u0094\u04de\b\u0094\u0001\u0095\u0001"+
		"\u0095\u0001\u0095\u0003\u0095\u04e3\b\u0095\u0001\u0096\u0001\u0096\u0001"+
		"\u0096\u0003\u0096\u04e8\b\u0096\u0001\u0097\u0001\u0097\u0001\u0097\u0001"+
		"\u0097\u0001\u0097\u0001\u0097\u0001\u0097\u0001\u0097\u0001\u0097\u0001"+
		"\u0097\u0001\u0097\u0001\u0097\u0001\u0097\u0001\u0097\u0001\u0097\u0001"+
		"\u0097\u0001\u0097\u0001\u0097\u0001\u0097\u0001\u0097\u0001\u0097\u0003"+
		"\u0097\u04ff\b\u0097\u0001\u0097\u0003\u0097\u0502\b\u0097\u0001\u0097"+
		"\u0001\u0097\u0001\u0097\u0001\u0097\u0003\u0097\u0508\b\u0097\u0001\u0098"+
		"\u0001\u0098\u0001\u0098\u0001\u0098\u0001\u0098\u0001\u0098\u0001\u0098"+
		"\u0001\u0098\u0001\u0098\u0001\u0098\u0001\u0098\u0003\u0098\u0515\b\u0098"+
		"\u0001\u0099\u0001\u0099\u0001\u0099\u0001\u0099\u0004\u0099\u051b\b\u0099"+
		"\u000b\u0099\f\u0099\u051c\u0001\u009a\u0003\u009a\u0520\b\u009a\u0001"+
		"\u009a\u0001\u009a\u0001\u009a\u0001\u009a\u0001\u009a\u0003\u009a\u0527"+
		"\b\u009a\u0001\u009b\u0001\u009b\u0003\u009b\u052b\b\u009b\u0001\u009b"+
		"\u0001\u009b\u0001\u009b\u0003\u009b\u0530\b\u009b\u0001\u009b\u0003\u009b"+
		"\u0533\b\u009b\u0001\u009c\u0001\u009c\u0001\u009d\u0001\u009d\u0003\u009d"+
		"\u0539\b\u009d\u0001\u009d\u0005\u009d\u053c\b\u009d\n\u009d\f\u009d\u053f"+
		"\t\u009d\u0001\u009e\u0001\u009e\u0001\u009f\u0001\u009f\u0001\u009f\u0003"+
		"\u009f\u0546\b\u009f\u0001\u00a0\u0001\u00a0\u0001\u00a0\u0003\u00a0\u054b"+
		"\b\u00a0\u0001\u00a1\u0001\u00a1\u0001\u00a1\u0001\u00a1\u0001\u00a1\u0001"+
		"\u00a1\u0005\u00a1\u0553\b\u00a1\n\u00a1\f\u00a1\u0556\t\u00a1\u0001\u00a1"+
		"\u0001\u00a1\u0005\u00a1\u055a\b\u00a1\n\u00a1\f\u00a1\u055d\t\u00a1\u0001"+
		"\u00a1\u0001\u00a1\u0001\u00a1\u0001\u00a1\u0005\u00a1\u0563\b\u00a1\n"+
		"\u00a1\f\u00a1\u0566\t\u00a1\u0001\u00a1\u0001\u00a1\u0001\u00a2\u0001"+
		"\u00a2\u0001\u00a2\u0001\u00a2\u0001\u00a2\u0001\u00a2\u0001\u00a2\u0001"+
		"\u00a2\u0001\u00a2\u0001\u00a2\u0001\u00a2\u0001\u00a2\u0003\u00a2\u0576"+
		"\b\u00a2\u0001\u00a3\u0001\u00a3\u0003\u00a3\u057a\b\u00a3\u0001\u00a3"+
		"\u0001\u00a3\u0001\u00a3\u0001\u00a3\u0001\u00a3\u0001\u00a3\u0003\u00a3"+
		"\u0582\b\u00a3\u0001\u00a4\u0001\u00a4\u0001\u00a4\u0001\u00a5\u0001\u00a5"+
		"\u0001\u00a5\u0001\u00a6\u0001\u00a6\u0001\u00a7\u0004\u00a7\u058d\b\u00a7"+
		"\u000b\u00a7\f\u00a7\u058e\u0001\u00a7\u0001\u00a7\u0001\u00a8\u0001\u00a8"+
		"\u0003\u00a8\u0595\b\u00a8\u0001\u00a8\u0003\u00a8\u0598\b\u00a8\u0001"+
		"\u00a8\u0001\u00a8\u0001\u00a9\u0001\u00a9\u0001\u00a9\u0001\u00a9\u0005"+
		"\u00a9\u05a0\b\u00a9\n\u00a9\f\u00a9\u05a3\t\u00a9\u0001\u00a9\u0001\u00a9"+
		"\u0001\u00a9\u0001\u00a9\u0001\u00a9\u0001\u00aa\u0001\u00aa\u0001\u00aa"+
		"\u0001\u00aa\u0005\u00aa\u05ae\b\u00aa\n\u00aa\f\u00aa\u05b1\t\u00aa\u0001"+
		"\u00aa\u0001\u00aa\u0005\u01a0\u0554\u055b\u0564\u05a1\u0000\u00ab\u0001"+
		"\u0001\u0003\u0002\u0005\u0003\u0007\u0004\t\u0005\u000b\u0006\r\u0007"+
		"\u000f\b\u0011\t\u0013\n\u0015\u000b\u0017\f\u0019\r\u001b\u000e\u001d"+
		"\u000f\u001f\u0010!\u0011#\u0012%\u0013\'\u0014)\u0015+\u0016-\u0017/"+
		"\u00181\u00193\u001a5\u001b7\u001c9\u001d;\u001e=\u001f? A!C\"E#G$I%K"+
		"&M\'O(Q)S*U+W,Y-[.]/_0a1c2e3g4i5k6m7o8q9s:u;w<y={>}?\u007f@\u0081A\u0083"+
		"B\u0085C\u0087D\u0089E\u008bF\u008dG\u008fH\u0091I\u0093J\u0095K\u0097"+
		"L\u0099M\u009bN\u009dO\u009fP\u00a1Q\u00a3R\u00a5S\u00a7T\u00a9U\u00ab"+
		"V\u00adW\u00afX\u00b1Y\u00b3Z\u00b5[\u00b7\\\u00b9]\u00bb^\u00bd_\u00bf"+
		"`\u00c1a\u00c3b\u00c5c\u00c7d\u00c9e\u00cbf\u00cdg\u00cfh\u00d1i\u00d3"+
		"j\u00d5k\u00d7l\u00d9m\u00dbn\u00ddo\u00dfp\u00e1q\u00e3r\u00e5s\u00e7"+
		"t\u00e9u\u00ebv\u00edw\u00efx\u00f1y\u00f3z\u00f5{\u00f7|\u00f9}\u00fb"+
		"~\u00fd\u007f\u00ff\u0080\u0101\u0081\u0103\u0082\u0105\u0083\u0107\u0000"+
		"\u0109\u0000\u010b\u0084\u010d\u0000\u010f\u0000\u0111\u0000\u0113\u0085"+
		"\u0115\u0086\u0117\u0087\u0119\u0088\u011b\u0000\u011d\u0000\u011f\u0000"+
		"\u0121\u0000\u0123\u0089\u0125\u0000\u0127\u0000\u0129\u0000\u012b\u0000"+
		"\u012d\u0000\u012f\u0000\u0131\u0000\u0133\u0000\u0135\u0000\u0137\u0000"+
		"\u0139\u0000\u013b\u0000\u013d\u0000\u013f\u0000\u0141\u0000\u0143\u0000"+
		"\u0145\u008a\u0147\u008b\u0149\u008c\u014b\u008d\u014d\u0000\u014f\u008e"+
		"\u0151\u008f\u0153\u0090\u0155\u0091\u0001\u0000\u0014\u0003\u0000LLU"+
		"Uuu\u0001\u0000\n\n\u0003\u0000AZ__az\u0001\u000009\u0001\u000019\u0001"+
		"\u000007\u0003\u000009AFaf\u0001\u000001\u0002\u0000UUuu\u0002\u0000L"+
		"Lll\u0004\u0000\n\n\r\r\'\'\\\\\u0002\u0000++--\u0004\u0000FFLLffll\u0004"+
		"\u0000\n\n\r\r\"\"\\\\\u0002\u0000\"\"()\u0004\u0000\n\n\r\r  ((\u0001"+
		"\u0000))\u0004\u0000\n\n\r\r  \"\"\u0002\u0000\t\t  \u0002\u0000\n\n\r"+
		"\r\u05f8\u0000\u0001\u0001\u0000\u0000\u0000\u0000\u0003\u0001\u0000\u0000"+
		"\u0000\u0000\u0005\u0001\u0000\u0000\u0000\u0000\u0007\u0001\u0000\u0000"+
		"\u0000\u0000\t\u0001\u0000\u0000\u0000\u0000\u000b\u0001\u0000\u0000\u0000"+
		"\u0000\r\u0001\u0000\u0000\u0000\u0000\u000f\u0001\u0000\u0000\u0000\u0000"+
		"\u0011\u0001\u0000\u0000\u0000\u0000\u0013\u0001\u0000\u0000\u0000\u0000"+
		"\u0015\u0001\u0000\u0000\u0000\u0000\u0017\u0001\u0000\u0000\u0000\u0000"+
		"\u0019\u0001\u0000\u0000\u0000\u0000\u001b\u0001\u0000\u0000\u0000\u0000"+
		"\u001d\u0001\u0000\u0000\u0000\u0000\u001f\u0001\u0000\u0000\u0000\u0000"+
		"!\u0001\u0000\u0000\u0000\u0000#\u0001\u0000\u0000\u0000\u0000%\u0001"+
		"\u0000\u0000\u0000\u0000\'\u0001\u0000\u0000\u0000\u0000)\u0001\u0000"+
		"\u0000\u0000\u0000+\u0001\u0000\u0000\u0000\u0000-\u0001\u0000\u0000\u0000"+
		"\u0000/\u0001\u0000\u0000\u0000\u00001\u0001\u0000\u0000\u0000\u00003"+
		"\u0001\u0000\u0000\u0000\u00005\u0001\u0000\u0000\u0000\u00007\u0001\u0000"+
		"\u0000\u0000\u00009\u0001\u0000\u0000\u0000\u0000;\u0001\u0000\u0000\u0000"+
		"\u0000=\u0001\u0000\u0000\u0000\u0000?\u0001\u0000\u0000\u0000\u0000A"+
		"\u0001\u0000\u0000\u0000\u0000C\u0001\u0000\u0000\u0000\u0000E\u0001\u0000"+
		"\u0000\u0000\u0000G\u0001\u0000\u0000\u0000\u0000I\u0001\u0000\u0000\u0000"+
		"\u0000K\u0001\u0000\u0000\u0000\u0000M\u0001\u0000\u0000\u0000\u0000O"+
		"\u0001\u0000\u0000\u0000\u0000Q\u0001\u0000\u0000\u0000\u0000S\u0001\u0000"+
		"\u0000\u0000\u0000U\u0001\u0000\u0000\u0000\u0000W\u0001\u0000\u0000\u0000"+
		"\u0000Y\u0001\u0000\u0000\u0000\u0000[\u0001\u0000\u0000\u0000\u0000]"+
		"\u0001\u0000\u0000\u0000\u0000_\u0001\u0000\u0000\u0000\u0000a\u0001\u0000"+
		"\u0000\u0000\u0000c\u0001\u0000\u0000\u0000\u0000e\u0001\u0000\u0000\u0000"+
		"\u0000g\u0001\u0000\u0000\u0000\u0000i\u0001\u0000\u0000\u0000\u0000k"+
		"\u0001\u0000\u0000\u0000\u0000m\u0001\u0000\u0000\u0000\u0000o\u0001\u0000"+
		"\u0000\u0000\u0000q\u0001\u0000\u0000\u0000\u0000s\u0001\u0000\u0000\u0000"+
		"\u0000u\u0001\u0000\u0000\u0000\u0000w\u0001\u0000\u0000\u0000\u0000y"+
		"\u0001\u0000\u0000\u0000\u0000{\u0001\u0000\u0000\u0000\u0000}\u0001\u0000"+
		"\u0000\u0000\u0000\u007f\u0001\u0000\u0000\u0000\u0000\u0081\u0001\u0000"+
		"\u0000\u0000\u0000\u0083\u0001\u0000\u0000\u0000\u0000\u0085\u0001\u0000"+
		"\u0000\u0000\u0000\u0087\u0001\u0000\u0000\u0000\u0000\u0089\u0001\u0000"+
		"\u0000\u0000\u0000\u008b\u0001\u0000\u0000\u0000\u0000\u008d\u0001\u0000"+
		"\u0000\u0000\u0000\u008f\u0001\u0000\u0000\u0000\u0000\u0091\u0001\u0000"+
		"\u0000\u0000\u0000\u0093\u0001\u0000\u0000\u0000\u0000\u0095\u0001\u0000"+
		"\u0000\u0000\u0000\u0097\u0001\u0000\u0000\u0000\u0000\u0099\u0001\u0000"+
		"\u0000\u0000\u0000\u009b\u0001\u0000\u0000\u0000\u0000\u009d\u0001\u0000"+
		"\u0000\u0000\u0000\u009f\u0001\u0000\u0000\u0000\u0000\u00a1\u0001\u0000"+
		"\u0000\u0000\u0000\u00a3\u0001\u0000\u0000\u0000\u0000\u00a5\u0001\u0000"+
		"\u0000\u0000\u0000\u00a7\u0001\u0000\u0000\u0000\u0000\u00a9\u0001\u0000"+
		"\u0000\u0000\u0000\u00ab\u0001\u0000\u0000\u0000\u0000\u00ad\u0001\u0000"+
		"\u0000\u0000\u0000\u00af\u0001\u0000\u0000\u0000\u0000\u00b1\u0001\u0000"+
		"\u0000\u0000\u0000\u00b3\u0001\u0000\u0000\u0000\u0000\u00b5\u0001\u0000"+
		"\u0000\u0000\u0000\u00b7\u0001\u0000\u0000\u0000\u0000\u00b9\u0001\u0000"+
		"\u0000\u0000\u0000\u00bb\u0001\u0000\u0000\u0000\u0000\u00bd\u0001\u0000"+
		"\u0000\u0000\u0000\u00bf\u0001\u0000\u0000\u0000\u0000\u00c1\u0001\u0000"+
		"\u0000\u0000\u0000\u00c3\u0001\u0000\u0000\u0000\u0000\u00c5\u0001\u0000"+
		"\u0000\u0000\u0000\u00c7\u0001\u0000\u0000\u0000\u0000\u00c9\u0001\u0000"+
		"\u0000\u0000\u0000\u00cb\u0001\u0000\u0000\u0000\u0000\u00cd\u0001\u0000"+
		"\u0000\u0000\u0000\u00cf\u0001\u0000\u0000\u0000\u0000\u00d1\u0001\u0000"+
		"\u0000\u0000\u0000\u00d3\u0001\u0000\u0000\u0000\u0000\u00d5\u0001\u0000"+
		"\u0000\u0000\u0000\u00d7\u0001\u0000\u0000\u0000\u0000\u00d9\u0001\u0000"+
		"\u0000\u0000\u0000\u00db\u0001\u0000\u0000\u0000\u0000\u00dd\u0001\u0000"+
		"\u0000\u0000\u0000\u00df\u0001\u0000\u0000\u0000\u0000\u00e1\u0001\u0000"+
		"\u0000\u0000\u0000\u00e3\u0001\u0000\u0000\u0000\u0000\u00e5\u0001\u0000"+
		"\u0000\u0000\u0000\u00e7\u0001\u0000\u0000\u0000\u0000\u00e9\u0001\u0000"+
		"\u0000\u0000\u0000\u00eb\u0001\u0000\u0000\u0000\u0000\u00ed\u0001\u0000"+
		"\u0000\u0000\u0000\u00ef\u0001\u0000\u0000\u0000\u0000\u00f1\u0001\u0000"+
		"\u0000\u0000\u0000\u00f3\u0001\u0000\u0000\u0000\u0000\u00f5\u0001\u0000"+
		"\u0000\u0000\u0000\u00f7\u0001\u0000\u0000\u0000\u0000\u00f9\u0001\u0000"+
		"\u0000\u0000\u0000\u00fb\u0001\u0000\u0000\u0000\u0000\u00fd\u0001\u0000"+
		"\u0000\u0000\u0000\u00ff\u0001\u0000\u0000\u0000\u0000\u0101\u0001\u0000"+
		"\u0000\u0000\u0000\u0103\u0001\u0000\u0000\u0000\u0000\u0105\u0001\u0000"+
		"\u0000\u0000\u0000\u010b\u0001\u0000\u0000\u0000\u0000\u0113\u0001\u0000"+
		"\u0000\u0000\u0000\u0115\u0001\u0000\u0000\u0000\u0000\u0117\u0001\u0000"+
		"\u0000\u0000\u0000\u0119\u0001\u0000\u0000\u0000\u0000\u0123\u0001\u0000"+
		"\u0000\u0000\u0000\u0145\u0001\u0000\u0000\u0000\u0000\u0147\u0001\u0000"+
		"\u0000\u0000\u0000\u0149\u0001\u0000\u0000\u0000\u0000\u014b\u0001\u0000"+
		"\u0000\u0000\u0000\u014f\u0001\u0000\u0000\u0000\u0000\u0151\u0001\u0000"+
		"\u0000\u0000\u0000\u0153\u0001\u0000\u0000\u0000\u0000\u0155\u0001\u0000"+
		"\u0000\u0000\u0001\u0167\u0001\u0000\u0000\u0000\u0003\u016a\u0001\u0000"+
		"\u0000\u0000\u0005\u0180\u0001\u0000\u0000\u0000\u0007\u0183\u0001\u0000"+
		"\u0000\u0000\t\u0192\u0001\u0000\u0000\u0000\u000b\u0194\u0001\u0000\u0000"+
		"\u0000\r\u019a\u0001\u0000\u0000\u0000\u000f\u019c\u0001\u0000\u0000\u0000"+
		"\u0011\u01b3\u0001\u0000\u0000\u0000\u0013\u01bc\u0001\u0000\u0000\u0000"+
		"\u0015\u01c4\u0001\u0000\u0000\u0000\u0017\u01cc\u0001\u0000\u0000\u0000"+
		"\u0019\u01d0\u0001\u0000\u0000\u0000\u001b\u01d5\u0001\u0000\u0000\u0000"+
		"\u001d\u01da\u0001\u0000\u0000\u0000\u001f\u01e0\u0001\u0000\u0000\u0000"+
		"!\u01e5\u0001\u0000\u0000\u0000#\u01eb\u0001\u0000\u0000\u0000%\u01f0"+
		"\u0001\u0000\u0000\u0000\'\u01f9\u0001\u0000\u0000\u0000)\u0202\u0001"+
		"\u0000\u0000\u0000+\u0208\u0001\u0000\u0000\u0000-\u020e\u0001\u0000\u0000"+
		"\u0000/\u0218\u0001\u0000\u0000\u00001\u0223\u0001\u0000\u0000\u00003"+
		"\u022c\u0001\u0000\u0000\u00005\u0235\u0001\u0000\u0000\u00007\u023d\u0001"+
		"\u0000\u0000\u00009\u0244\u0001\u0000\u0000\u0000;\u0247\u0001\u0000\u0000"+
		"\u0000=\u024e\u0001\u0000\u0000\u0000?\u025b\u0001\u0000\u0000\u0000A"+
		"\u0260\u0001\u0000\u0000\u0000C\u0265\u0001\u0000\u0000\u0000E\u026e\u0001"+
		"\u0000\u0000\u0000G\u0275\u0001\u0000\u0000\u0000I\u027c\u0001\u0000\u0000"+
		"\u0000K\u0282\u0001\u0000\u0000\u0000M\u0288\u0001\u0000\u0000\u0000O"+
		"\u028e\u0001\u0000\u0000\u0000Q\u0292\u0001\u0000\u0000\u0000S\u0299\u0001"+
		"\u0000\u0000\u0000U\u029e\u0001\u0000\u0000\u0000W\u02a1\u0001\u0000\u0000"+
		"\u0000Y\u02a8\u0001\u0000\u0000\u0000[\u02ac\u0001\u0000\u0000\u0000]"+
		"\u02b1\u0001\u0000\u0000\u0000_\u02b9\u0001\u0000\u0000\u0000a\u02c3\u0001"+
		"\u0000\u0000\u0000c\u02c7\u0001\u0000\u0000\u0000e\u02d0\u0001\u0000\u0000"+
		"\u0000g\u02d8\u0001\u0000\u0000\u0000i\u02e1\u0001\u0000\u0000\u0000k"+
		"\u02ea\u0001\u0000\u0000\u0000m\u02f2\u0001\u0000\u0000\u0000o\u02fc\u0001"+
		"\u0000\u0000\u0000q\u0303\u0001\u0000\u0000\u0000s\u030c\u0001\u0000\u0000"+
		"\u0000u\u031d\u0001\u0000\u0000\u0000w\u0324\u0001\u0000\u0000\u0000y"+
		"\u032a\u0001\u0000\u0000\u0000{\u0331\u0001\u0000\u0000\u0000}\u0338\u0001"+
		"\u0000\u0000\u0000\u007f\u033f\u0001\u0000\u0000\u0000\u0081\u034d\u0001"+
		"\u0000\u0000\u0000\u0083\u0359\u0001\u0000\u0000\u0000\u0085\u0360\u0001"+
		"\u0000\u0000\u0000\u0087\u0367\u0001\u0000\u0000\u0000\u0089\u0370\u0001"+
		"\u0000\u0000\u0000\u008b\u0375\u0001\u0000\u0000\u0000\u008d\u0382\u0001"+
		"\u0000\u0000\u0000\u008f\u0388\u0001\u0000\u0000\u0000\u0091\u038d\u0001"+
		"\u0000\u0000\u0000\u0093\u0391\u0001\u0000\u0000\u0000\u0095\u0399\u0001"+
		"\u0000\u0000\u0000\u0097\u03a0\u0001\u0000\u0000\u0000\u0099\u03a9\u0001"+
		"\u0000\u0000\u0000\u009b\u03af\u0001\u0000\u0000\u0000\u009d\u03b8\u0001"+
		"\u0000\u0000\u0000\u009f\u03be\u0001\u0000\u0000\u0000\u00a1\u03c6\u0001"+
		"\u0000\u0000\u0000\u00a3\u03cb\u0001\u0000\u0000\u0000\u00a5\u03d4\u0001"+
		"\u0000\u0000\u0000\u00a7\u03dc\u0001\u0000\u0000\u0000\u00a9\u03e2\u0001"+
		"\u0000\u0000\u0000\u00ab\u03e4\u0001\u0000\u0000\u0000\u00ad\u03e6\u0001"+
		"\u0000\u0000\u0000\u00af\u03e8\u0001\u0000\u0000\u0000\u00b1\u03ea\u0001"+
		"\u0000\u0000\u0000\u00b3\u03ec\u0001\u0000\u0000\u0000\u00b5\u03ee\u0001"+
		"\u0000\u0000\u0000\u00b7\u03f0\u0001\u0000\u0000\u0000\u00b9\u03f2\u0001"+
		"\u0000\u0000\u0000\u00bb\u03f4\u0001\u0000\u0000\u0000\u00bd\u03f6\u0001"+
		"\u0000\u0000\u0000\u00bf\u03f8\u0001\u0000\u0000\u0000\u00c1\u03fa\u0001"+
		"\u0000\u0000\u0000\u00c3\u03fc\u0001\u0000\u0000\u0000\u00c5\u03fe\u0001"+
		"\u0000\u0000\u0000\u00c7\u0404\u0001\u0000\u0000\u0000\u00c9\u0406\u0001"+
		"\u0000\u0000\u0000\u00cb\u0408\u0001\u0000\u0000\u0000\u00cd\u040a\u0001"+
		"\u0000\u0000\u0000\u00cf\u040c\u0001\u0000\u0000\u0000\u00d1\u040f\u0001"+
		"\u0000\u0000\u0000\u00d3\u0412\u0001\u0000\u0000\u0000\u00d5\u0415\u0001"+
		"\u0000\u0000\u0000\u00d7\u0418\u0001\u0000\u0000\u0000\u00d9\u041b\u0001"+
		"\u0000\u0000\u0000\u00db\u041e\u0001\u0000\u0000\u0000\u00dd\u0421\u0001"+
		"\u0000\u0000\u0000\u00df\u0424\u0001\u0000\u0000\u0000\u00e1\u0428\u0001"+
		"\u0000\u0000\u0000\u00e3\u042c\u0001\u0000\u0000\u0000\u00e5\u042f\u0001"+
		"\u0000\u0000\u0000\u00e7\u0432\u0001\u0000\u0000\u0000\u00e9\u0435\u0001"+
		"\u0000\u0000\u0000\u00eb\u043d\u0001\u0000\u0000\u0000\u00ed\u0443\u0001"+
		"\u0000\u0000\u0000\u00ef\u0445\u0001\u0000\u0000\u0000\u00f1\u0448\u0001"+
		"\u0000\u0000\u0000\u00f3\u044b\u0001\u0000\u0000\u0000\u00f5\u044d\u0001"+
		"\u0000\u0000\u0000\u00f7\u0451\u0001\u0000\u0000\u0000\u00f9\u0454\u0001"+
		"\u0000\u0000\u0000\u00fb\u0456\u0001\u0000\u0000\u0000\u00fd\u0458\u0001"+
		"\u0000\u0000\u0000\u00ff\u045b\u0001\u0000\u0000\u0000\u0101\u045d\u0001"+
		"\u0000\u0000\u0000\u0103\u045f\u0001\u0000\u0000\u0000\u0105\u0462\u0001"+
		"\u0000\u0000\u0000\u0107\u0466\u0001\u0000\u0000\u0000\u0109\u0475\u0001"+
		"\u0000\u0000\u0000\u010b\u0477\u0001\u0000\u0000\u0000\u010d\u0481\u0001"+
		"\u0000\u0000\u0000\u010f\u0483\u0001\u0000\u0000\u0000\u0111\u0485\u0001"+
		"\u0000\u0000\u0000\u0113\u0487\u0001\u0000\u0000\u0000\u0115\u0491\u0001"+
		"\u0000\u0000\u0000\u0117\u049f\u0001\u0000\u0000\u0000\u0119\u04af\u0001"+
		"\u0000\u0000\u0000\u011b\u04bb\u0001\u0000\u0000\u0000\u011d\u04bd\u0001"+
		"\u0000\u0000\u0000\u011f\u04bf\u0001\u0000\u0000\u0000\u0121\u04c1\u0001"+
		"\u0000\u0000\u0000\u0123\u04d3\u0001\u0000\u0000\u0000\u0125\u04d5\u0001"+
		"\u0000\u0000\u0000\u0127\u04d7\u0001\u0000\u0000\u0000\u0129\u04dd\u0001"+
		"\u0000\u0000\u0000\u012b\u04e2\u0001\u0000\u0000\u0000\u012d\u04e7\u0001"+
		"\u0000\u0000\u0000\u012f\u0507\u0001\u0000\u0000\u0000\u0131\u0514\u0001"+
		"\u0000\u0000\u0000\u0133\u0516\u0001\u0000\u0000\u0000\u0135\u0526\u0001"+
		"\u0000\u0000\u0000\u0137\u0532\u0001\u0000\u0000\u0000\u0139\u0534\u0001"+
		"\u0000\u0000\u0000\u013b\u0536\u0001\u0000\u0000\u0000\u013d\u0540\u0001"+
		"\u0000\u0000\u0000\u013f\u0545\u0001\u0000\u0000\u0000\u0141\u054a\u0001"+
		"\u0000\u0000\u0000\u0143\u054c\u0001\u0000\u0000\u0000\u0145\u0575\u0001"+
		"\u0000\u0000\u0000\u0147\u0581\u0001\u0000\u0000\u0000\u0149\u0583\u0001"+
		"\u0000\u0000\u0000\u014b\u0586\u0001\u0000\u0000\u0000\u014d\u0589\u0001"+
		"\u0000\u0000\u0000\u014f\u058c\u0001\u0000\u0000\u0000\u0151\u0597\u0001"+
		"\u0000\u0000\u0000\u0153\u059b\u0001\u0000\u0000\u0000\u0155\u05a9\u0001"+
		"\u0000\u0000\u0000\u0157\u0159\u0003\u0113\u0089\u0000\u0158\u015a\u0003"+
		"\u0123\u0091\u0000\u0159\u0158\u0001\u0000\u0000\u0000\u0159\u015a\u0001"+
		"\u0000\u0000\u0000\u015a\u0168\u0001\u0000\u0000\u0000\u015b\u015d\u0003"+
		"\u0115\u008a\u0000\u015c\u015e\u0003\u0123\u0091\u0000\u015d\u015c\u0001"+
		"\u0000\u0000\u0000\u015d\u015e\u0001\u0000\u0000\u0000\u015e\u0168\u0001"+
		"\u0000\u0000\u0000\u015f\u0161\u0003\u0117\u008b\u0000\u0160\u0162\u0003"+
		"\u0123\u0091\u0000\u0161\u0160\u0001\u0000\u0000\u0000\u0161\u0162\u0001"+
		"\u0000\u0000\u0000\u0162\u0168\u0001\u0000\u0000\u0000\u0163\u0165\u0003"+
		"\u0119\u008c\u0000\u0164\u0166\u0003\u0123\u0091\u0000\u0165\u0164\u0001"+
		"\u0000\u0000\u0000\u0165\u0166\u0001\u0000\u0000\u0000\u0166\u0168\u0001"+
		"\u0000\u0000\u0000\u0167\u0157\u0001\u0000\u0000\u0000\u0167\u015b\u0001"+
		"\u0000\u0000\u0000\u0167\u015f\u0001\u0000\u0000\u0000\u0167\u0163\u0001"+
		"\u0000\u0000\u0000\u0168\u0002\u0001\u0000\u0000\u0000\u0169\u016b\u0007"+
		"\u0000\u0000\u0000\u016a\u0169\u0001\u0000\u0000\u0000\u016a\u016b\u0001"+
		"\u0000\u0000\u0000\u016b\u016c\u0001\u0000\u0000\u0000\u016c\u016e\u0005"+
		"\'\u0000\u0000\u016d\u016f\u0003\u012b\u0095\u0000\u016e\u016d\u0001\u0000"+
		"\u0000\u0000\u016f\u0170\u0001\u0000\u0000\u0000\u0170\u016e\u0001\u0000"+
		"\u0000\u0000\u0170\u0171\u0001\u0000\u0000\u0000\u0171\u0172\u0001\u0000"+
		"\u0000\u0000\u0172\u0173\u0005\'\u0000\u0000\u0173\u0004\u0001\u0000\u0000"+
		"\u0000\u0174\u0176\u0003\u0135\u009a\u0000\u0175\u0177\u0003\u0137\u009b"+
		"\u0000\u0176\u0175\u0001\u0000\u0000\u0000\u0176\u0177\u0001\u0000\u0000"+
		"\u0000\u0177\u0179\u0001\u0000\u0000\u0000\u0178\u017a\u0003\u013d\u009e"+
		"\u0000\u0179\u0178\u0001\u0000\u0000\u0000\u0179\u017a\u0001\u0000\u0000"+
		"\u0000\u017a\u0181\u0001\u0000\u0000\u0000\u017b\u017c\u0003\u013b\u009d"+
		"\u0000\u017c\u017e\u0003\u0137\u009b\u0000\u017d\u017f\u0003\u013d\u009e"+
		"\u0000\u017e\u017d\u0001\u0000\u0000\u0000\u017e\u017f\u0001\u0000\u0000"+
		"\u0000\u017f\u0181\u0001\u0000\u0000\u0000\u0180\u0174\u0001\u0000\u0000"+
		"\u0000\u0180\u017b\u0001\u0000\u0000\u0000\u0181\u0006\u0001\u0000\u0000"+
		"\u0000\u0182\u0184\u0003\u013f\u009f\u0000\u0183\u0182\u0001\u0000\u0000"+
		"\u0000\u0183\u0184\u0001\u0000\u0000\u0000\u0184\u018e\u0001\u0000\u0000"+
		"\u0000\u0185\u018f\u0003\u0143\u00a1\u0000\u0186\u018a\u0005\"\u0000\u0000"+
		"\u0187\u0189\u0003\u0141\u00a0\u0000\u0188\u0187\u0001\u0000\u0000\u0000"+
		"\u0189\u018c\u0001\u0000\u0000\u0000\u018a\u0188\u0001\u0000\u0000\u0000"+
		"\u018a\u018b\u0001\u0000\u0000\u0000\u018b\u018d\u0001\u0000\u0000\u0000"+
		"\u018c\u018a\u0001\u0000\u0000\u0000\u018d\u018f\u0005\"\u0000\u0000\u018e"+
		"\u0185\u0001\u0000\u0000\u0000\u018e\u0186\u0001\u0000\u0000\u0000\u018f"+
		"\b\u0001\u0000\u0000\u0000\u0190\u0193\u0003I$\u0000\u0191\u0193\u0003"+
		"\u008fG\u0000\u0192\u0190\u0001\u0000\u0000\u0000\u0192\u0191\u0001\u0000"+
		"\u0000\u0000\u0193\n\u0001\u0000\u0000\u0000\u0194\u0195\u0003e2\u0000"+
		"\u0195\f\u0001\u0000\u0000\u0000\u0196\u019b\u0003\u0145\u00a2\u0000\u0197"+
		"\u019b\u0003\u0147\u00a3\u0000\u0198\u019b\u0003\u0149\u00a4\u0000\u0199"+
		"\u019b\u0003\u014b\u00a5\u0000\u019a\u0196\u0001\u0000\u0000\u0000\u019a"+
		"\u0197\u0001\u0000\u0000\u0000\u019a\u0198\u0001\u0000\u0000\u0000\u019a"+
		"\u0199\u0001\u0000\u0000\u0000\u019b\u000e\u0001\u0000\u0000\u0000\u019c"+
		"\u01a8\u0005#\u0000\u0000\u019d\u019f\b\u0001\u0000\u0000\u019e\u019d"+
		"\u0001\u0000\u0000\u0000\u019f\u01a2\u0001\u0000\u0000\u0000\u01a0\u01a1"+
		"\u0001\u0000\u0000\u0000\u01a0\u019e\u0001\u0000\u0000\u0000\u01a1\u01a3"+
		"\u0001\u0000\u0000\u0000\u01a2\u01a0\u0001\u0000\u0000\u0000\u01a3\u01a5"+
		"\u0005\\\u0000\u0000\u01a4\u01a6\u0005\r\u0000\u0000\u01a5\u01a4\u0001"+
		"\u0000\u0000\u0000\u01a5\u01a6\u0001\u0000\u0000\u0000\u01a6\u01a7\u0001"+
		"\u0000\u0000\u0000\u01a7\u01a9\u0005\n\u0000\u0000\u01a8\u01a0\u0001\u0000"+
		"\u0000\u0000\u01a9\u01aa\u0001\u0000\u0000\u0000\u01aa\u01a8\u0001\u0000"+
		"\u0000\u0000\u01aa\u01ab\u0001\u0000\u0000\u0000\u01ab\u01ad\u0001\u0000"+
		"\u0000\u0000\u01ac\u01ae\b\u0001\u0000\u0000\u01ad\u01ac\u0001\u0000\u0000"+
		"\u0000\u01ae\u01af\u0001\u0000\u0000\u0000\u01af\u01ad\u0001\u0000\u0000"+
		"\u0000\u01af\u01b0\u0001\u0000\u0000\u0000\u01b0\u01b1\u0001\u0000\u0000"+
		"\u0000\u01b1\u01b2\u0006\u0007\u0000\u0000\u01b2\u0010\u0001\u0000\u0000"+
		"\u0000\u01b3\u01b7\u0005#\u0000\u0000\u01b4\u01b6\b\u0001\u0000\u0000"+
		"\u01b5\u01b4\u0001\u0000\u0000\u0000\u01b6\u01b9\u0001\u0000\u0000\u0000"+
		"\u01b7\u01b5\u0001\u0000\u0000\u0000\u01b7\u01b8\u0001\u0000\u0000\u0000"+
		"\u01b8\u01ba\u0001\u0000\u0000\u0000\u01b9\u01b7\u0001\u0000\u0000\u0000"+
		"\u01ba\u01bb\u0006\b\u0000\u0000\u01bb\u0012\u0001\u0000\u0000\u0000\u01bc"+
		"\u01bd\u0005a\u0000\u0000\u01bd\u01be\u0005l\u0000\u0000\u01be\u01bf\u0005"+
		"i\u0000\u0000\u01bf\u01c0\u0005g\u0000\u0000\u01c0\u01c1\u0005n\u0000"+
		"\u0000\u01c1\u01c2\u0005a\u0000\u0000\u01c2\u01c3\u0005s\u0000\u0000\u01c3"+
		"\u0014\u0001\u0000\u0000\u0000\u01c4\u01c5\u0005a\u0000\u0000\u01c5\u01c6"+
		"\u0005l\u0000\u0000\u01c6\u01c7\u0005i\u0000\u0000\u01c7\u01c8\u0005g"+
		"\u0000\u0000\u01c8\u01c9\u0005n\u0000\u0000\u01c9\u01ca\u0005o\u0000\u0000"+
		"\u01ca\u01cb\u0005f\u0000\u0000\u01cb\u0016\u0001\u0000\u0000\u0000\u01cc"+
		"\u01cd\u0005a\u0000\u0000\u01cd\u01ce\u0005s\u0000\u0000\u01ce\u01cf\u0005"+
		"m\u0000\u0000\u01cf\u0018\u0001\u0000\u0000\u0000\u01d0\u01d1\u0005a\u0000"+
		"\u0000\u01d1\u01d2\u0005u\u0000\u0000\u01d2\u01d3\u0005t\u0000\u0000\u01d3"+
		"\u01d4\u0005o\u0000\u0000\u01d4\u001a\u0001\u0000\u0000\u0000\u01d5\u01d6"+
		"\u0005b\u0000\u0000\u01d6\u01d7\u0005o\u0000\u0000\u01d7\u01d8\u0005o"+
		"\u0000\u0000\u01d8\u01d9\u0005l\u0000\u0000\u01d9\u001c\u0001\u0000\u0000"+
		"\u0000\u01da\u01db\u0005b\u0000\u0000\u01db\u01dc\u0005r\u0000\u0000\u01dc"+
		"\u01dd\u0005e\u0000\u0000\u01dd\u01de\u0005a\u0000\u0000\u01de\u01df\u0005"+
		"k\u0000\u0000\u01df\u001e\u0001\u0000\u0000\u0000\u01e0\u01e1\u0005c\u0000"+
		"\u0000\u01e1\u01e2\u0005a\u0000\u0000\u01e2\u01e3\u0005s\u0000\u0000\u01e3"+
		"\u01e4\u0005e\u0000\u0000\u01e4 \u0001\u0000\u0000\u0000\u01e5\u01e6\u0005"+
		"c\u0000\u0000\u01e6\u01e7\u0005a\u0000\u0000\u01e7\u01e8\u0005t\u0000"+
		"\u0000\u01e8\u01e9\u0005c\u0000\u0000\u01e9\u01ea\u0005h\u0000\u0000\u01ea"+
		"\"\u0001\u0000\u0000\u0000\u01eb\u01ec\u0005c\u0000\u0000\u01ec\u01ed"+
		"\u0005h\u0000\u0000\u01ed\u01ee\u0005a\u0000\u0000\u01ee\u01ef\u0005r"+
		"\u0000\u0000\u01ef$\u0001\u0000\u0000\u0000\u01f0\u01f1\u0005c\u0000\u0000"+
		"\u01f1\u01f2\u0005h\u0000\u0000\u01f2\u01f3\u0005a\u0000\u0000\u01f3\u01f4"+
		"\u0005r\u0000\u0000\u01f4\u01f5\u00051\u0000\u0000\u01f5\u01f6\u00056"+
		"\u0000\u0000\u01f6\u01f7\u0005_\u0000\u0000\u01f7\u01f8\u0005t\u0000\u0000"+
		"\u01f8&\u0001\u0000\u0000\u0000\u01f9\u01fa\u0005c\u0000\u0000\u01fa\u01fb"+
		"\u0005h\u0000\u0000\u01fb\u01fc\u0005a\u0000\u0000\u01fc\u01fd\u0005r"+
		"\u0000\u0000\u01fd\u01fe\u00053\u0000\u0000\u01fe\u01ff\u00052\u0000\u0000"+
		"\u01ff\u0200\u0005_\u0000\u0000\u0200\u0201\u0005t\u0000\u0000\u0201("+
		"\u0001\u0000\u0000\u0000\u0202\u0203\u0005c\u0000\u0000\u0203\u0204\u0005"+
		"l\u0000\u0000\u0204\u0205\u0005a\u0000\u0000\u0205\u0206\u0005s\u0000"+
		"\u0000\u0206\u0207\u0005s\u0000\u0000\u0207*\u0001\u0000\u0000\u0000\u0208"+
		"\u0209\u0005c\u0000\u0000\u0209\u020a\u0005o\u0000\u0000\u020a\u020b\u0005"+
		"n\u0000\u0000\u020b\u020c\u0005s\u0000\u0000\u020c\u020d\u0005t\u0000"+
		"\u0000\u020d,\u0001\u0000\u0000\u0000\u020e\u020f\u0005c\u0000\u0000\u020f"+
		"\u0210\u0005o\u0000\u0000\u0210\u0211\u0005n\u0000\u0000\u0211\u0212\u0005"+
		"s\u0000\u0000\u0212\u0213\u0005t\u0000\u0000\u0213\u0214\u0005e\u0000"+
		"\u0000\u0214\u0215\u0005x\u0000\u0000\u0215\u0216\u0005p\u0000\u0000\u0216"+
		"\u0217\u0005r\u0000\u0000\u0217.\u0001\u0000\u0000\u0000\u0218\u0219\u0005"+
		"c\u0000\u0000\u0219\u021a\u0005o\u0000\u0000\u021a\u021b\u0005n\u0000"+
		"\u0000\u021b\u021c\u0005s\u0000\u0000\u021c\u021d\u0005t\u0000\u0000\u021d"+
		"\u021e\u0005_\u0000\u0000\u021e\u021f\u0005c\u0000\u0000\u021f\u0220\u0005"+
		"a\u0000\u0000\u0220\u0221\u0005s\u0000\u0000\u0221\u0222\u0005t\u0000"+
		"\u0000\u02220\u0001\u0000\u0000\u0000\u0223\u0224\u0005c\u0000\u0000\u0224"+
		"\u0225\u0005o\u0000\u0000\u0225\u0226\u0005n\u0000\u0000\u0226\u0227\u0005"+
		"t\u0000\u0000\u0227\u0228\u0005i\u0000\u0000\u0228\u0229\u0005n\u0000"+
		"\u0000\u0229\u022a\u0005u\u0000\u0000\u022a\u022b\u0005e\u0000\u0000\u022b"+
		"2\u0001\u0000\u0000\u0000\u022c\u022d\u0005d\u0000\u0000\u022d\u022e\u0005"+
		"e\u0000\u0000\u022e\u022f\u0005c\u0000\u0000\u022f\u0230\u0005l\u0000"+
		"\u0000\u0230\u0231\u0005t\u0000\u0000\u0231\u0232\u0005y\u0000\u0000\u0232"+
		"\u0233\u0005p\u0000\u0000\u0233\u0234\u0005e\u0000\u0000\u02344\u0001"+
		"\u0000\u0000\u0000\u0235\u0236\u0005d\u0000\u0000\u0236\u0237\u0005e\u0000"+
		"\u0000\u0237\u0238\u0005f\u0000\u0000\u0238\u0239\u0005a\u0000\u0000\u0239"+
		"\u023a\u0005u\u0000\u0000\u023a\u023b\u0005l\u0000\u0000\u023b\u023c\u0005"+
		"t\u0000\u0000\u023c6\u0001\u0000\u0000\u0000\u023d\u023e\u0005d\u0000"+
		"\u0000\u023e\u023f\u0005e\u0000\u0000\u023f\u0240\u0005l\u0000\u0000\u0240"+
		"\u0241\u0005e\u0000\u0000\u0241\u0242\u0005t\u0000\u0000\u0242\u0243\u0005"+
		"e\u0000\u0000\u02438\u0001\u0000\u0000\u0000\u0244\u0245\u0005d\u0000"+
		"\u0000\u0245\u0246\u0005o\u0000\u0000\u0246:\u0001\u0000\u0000\u0000\u0247"+
		"\u0248\u0005d\u0000\u0000\u0248\u0249\u0005o\u0000\u0000\u0249\u024a\u0005"+
		"u\u0000\u0000\u024a\u024b\u0005b\u0000\u0000\u024b\u024c\u0005l\u0000"+
		"\u0000\u024c\u024d\u0005e\u0000\u0000\u024d<\u0001\u0000\u0000\u0000\u024e"+
		"\u024f\u0005d\u0000\u0000\u024f\u0250\u0005y\u0000\u0000\u0250\u0251\u0005"+
		"n\u0000\u0000\u0251\u0252\u0005a\u0000\u0000\u0252\u0253\u0005m\u0000"+
		"\u0000\u0253\u0254\u0005i\u0000\u0000\u0254\u0255\u0005c\u0000\u0000\u0255"+
		"\u0256\u0005_\u0000\u0000\u0256\u0257\u0005c\u0000\u0000\u0257\u0258\u0005"+
		"a\u0000\u0000\u0258\u0259\u0005s\u0000\u0000\u0259\u025a\u0005t\u0000"+
		"\u0000\u025a>\u0001\u0000\u0000\u0000\u025b\u025c\u0005e\u0000\u0000\u025c"+
		"\u025d\u0005l\u0000\u0000\u025d\u025e\u0005s\u0000\u0000\u025e\u025f\u0005"+
		"e\u0000\u0000\u025f@\u0001\u0000\u0000\u0000\u0260\u0261\u0005e\u0000"+
		"\u0000\u0261\u0262\u0005n\u0000\u0000\u0262\u0263\u0005u\u0000\u0000\u0263"+
		"\u0264\u0005m\u0000\u0000\u0264B\u0001\u0000\u0000\u0000\u0265\u0266\u0005"+
		"e\u0000\u0000\u0266\u0267\u0005x\u0000\u0000\u0267\u0268\u0005p\u0000"+
		"\u0000\u0268\u0269\u0005l\u0000\u0000\u0269\u026a\u0005i\u0000\u0000\u026a"+
		"\u026b\u0005c\u0000\u0000\u026b\u026c\u0005i\u0000\u0000\u026c\u026d\u0005"+
		"t\u0000\u0000\u026dD\u0001\u0000\u0000\u0000\u026e\u026f\u0005e\u0000"+
		"\u0000\u026f\u0270\u0005x\u0000\u0000\u0270\u0271\u0005p\u0000\u0000\u0271"+
		"\u0272\u0005o\u0000\u0000\u0272\u0273\u0005r\u0000\u0000\u0273\u0274\u0005"+
		"t\u0000\u0000\u0274F\u0001\u0000\u0000\u0000\u0275\u0276\u0005e\u0000"+
		"\u0000\u0276\u0277\u0005x\u0000\u0000\u0277\u0278\u0005t\u0000\u0000\u0278"+
		"\u0279\u0005e\u0000\u0000\u0279\u027a\u0005r\u0000\u0000\u027a\u027b\u0005"+
		"n\u0000\u0000\u027bH\u0001\u0000\u0000\u0000\u027c\u027d\u0005f\u0000"+
		"\u0000\u027d\u027e\u0005a\u0000\u0000\u027e\u027f\u0005l\u0000\u0000\u027f"+
		"\u0280\u0005s\u0000\u0000\u0280\u0281\u0005e\u0000\u0000\u0281J\u0001"+
		"\u0000\u0000\u0000\u0282\u0283\u0005f\u0000\u0000\u0283\u0284\u0005i\u0000"+
		"\u0000\u0284\u0285\u0005n\u0000\u0000\u0285\u0286\u0005a\u0000\u0000\u0286"+
		"\u0287\u0005l\u0000\u0000\u0287L\u0001\u0000\u0000\u0000\u0288\u0289\u0005"+
		"f\u0000\u0000\u0289\u028a\u0005l\u0000\u0000\u028a\u028b\u0005o\u0000"+
		"\u0000\u028b\u028c\u0005a\u0000\u0000\u028c\u028d\u0005t\u0000\u0000\u028d"+
		"N\u0001\u0000\u0000\u0000\u028e\u028f\u0005f\u0000\u0000\u028f\u0290\u0005"+
		"o\u0000\u0000\u0290\u0291\u0005r\u0000\u0000\u0291P\u0001\u0000\u0000"+
		"\u0000\u0292\u0293\u0005f\u0000\u0000\u0293\u0294\u0005r\u0000\u0000\u0294"+
		"\u0295\u0005i\u0000\u0000\u0295\u0296\u0005e\u0000\u0000\u0296\u0297\u0005"+
		"n\u0000\u0000\u0297\u0298\u0005d\u0000\u0000\u0298R\u0001\u0000\u0000"+
		"\u0000\u0299\u029a\u0005g\u0000\u0000\u029a\u029b\u0005o\u0000\u0000\u029b"+
		"\u029c\u0005t\u0000\u0000\u029c\u029d\u0005o\u0000\u0000\u029dT\u0001"+
		"\u0000\u0000\u0000\u029e\u029f\u0005i\u0000\u0000\u029f\u02a0\u0005f\u0000"+
		"\u0000\u02a0V\u0001\u0000\u0000\u0000\u02a1\u02a2\u0005i\u0000\u0000\u02a2"+
		"\u02a3\u0005n\u0000\u0000\u02a3\u02a4\u0005l\u0000\u0000\u02a4\u02a5\u0005"+
		"i\u0000\u0000\u02a5\u02a6\u0005n\u0000\u0000\u02a6\u02a7\u0005e\u0000"+
		"\u0000\u02a7X\u0001\u0000\u0000\u0000\u02a8\u02a9\u0005i\u0000\u0000\u02a9"+
		"\u02aa\u0005n\u0000\u0000\u02aa\u02ab\u0005t\u0000\u0000\u02abZ\u0001"+
		"\u0000\u0000\u0000\u02ac\u02ad\u0005l\u0000\u0000\u02ad\u02ae\u0005o\u0000"+
		"\u0000\u02ae\u02af\u0005n\u0000\u0000\u02af\u02b0\u0005g\u0000\u0000\u02b0"+
		"\\\u0001\u0000\u0000\u0000\u02b1\u02b2\u0005m\u0000\u0000\u02b2\u02b3"+
		"\u0005u\u0000\u0000\u02b3\u02b4\u0005t\u0000\u0000\u02b4\u02b5\u0005a"+
		"\u0000\u0000\u02b5\u02b6\u0005b\u0000\u0000\u02b6\u02b7\u0005l\u0000\u0000"+
		"\u02b7\u02b8\u0005e\u0000\u0000\u02b8^\u0001\u0000\u0000\u0000\u02b9\u02ba"+
		"\u0005n\u0000\u0000\u02ba\u02bb\u0005a\u0000\u0000\u02bb\u02bc\u0005m"+
		"\u0000\u0000\u02bc\u02bd\u0005e\u0000\u0000\u02bd\u02be\u0005s\u0000\u0000"+
		"\u02be\u02bf\u0005p\u0000\u0000\u02bf\u02c0\u0005a\u0000\u0000\u02c0\u02c1"+
		"\u0005c\u0000\u0000\u02c1\u02c2\u0005e\u0000\u0000\u02c2`\u0001\u0000"+
		"\u0000\u0000\u02c3\u02c4\u0005n\u0000\u0000\u02c4\u02c5\u0005e\u0000\u0000"+
		"\u02c5\u02c6\u0005w\u0000\u0000\u02c6b\u0001\u0000\u0000\u0000\u02c7\u02c8"+
		"\u0005n\u0000\u0000\u02c8\u02c9\u0005o\u0000\u0000\u02c9\u02ca\u0005e"+
		"\u0000\u0000\u02ca\u02cb\u0005x\u0000\u0000\u02cb\u02cc\u0005c\u0000\u0000"+
		"\u02cc\u02cd\u0005e\u0000\u0000\u02cd\u02ce\u0005p\u0000\u0000\u02ce\u02cf"+
		"\u0005t\u0000\u0000\u02cfd\u0001\u0000\u0000\u0000\u02d0\u02d1\u0005n"+
		"\u0000\u0000\u02d1\u02d2\u0005u\u0000\u0000\u02d2\u02d3\u0005l\u0000\u0000"+
		"\u02d3\u02d4\u0005l\u0000\u0000\u02d4\u02d5\u0005p\u0000\u0000\u02d5\u02d6"+
		"\u0005t\u0000\u0000\u02d6\u02d7\u0005r\u0000\u0000\u02d7f\u0001\u0000"+
		"\u0000\u0000\u02d8\u02d9\u0005o\u0000\u0000\u02d9\u02da\u0005p\u0000\u0000"+
		"\u02da\u02db\u0005e\u0000\u0000\u02db\u02dc\u0005r\u0000\u0000\u02dc\u02dd"+
		"\u0005a\u0000\u0000\u02dd\u02de\u0005t\u0000\u0000\u02de\u02df\u0005o"+
		"\u0000\u0000\u02df\u02e0\u0005r\u0000\u0000\u02e0h\u0001\u0000\u0000\u0000"+
		"\u02e1\u02e2\u0005o\u0000\u0000\u02e2\u02e3\u0005v\u0000\u0000\u02e3\u02e4"+
		"\u0005e\u0000\u0000\u02e4\u02e5\u0005r\u0000\u0000\u02e5\u02e6\u0005r"+
		"\u0000\u0000\u02e6\u02e7\u0005i\u0000\u0000\u02e7\u02e8\u0005d\u0000\u0000"+
		"\u02e8\u02e9\u0005e\u0000\u0000\u02e9j\u0001\u0000\u0000\u0000\u02ea\u02eb"+
		"\u0005p\u0000\u0000\u02eb\u02ec\u0005r\u0000\u0000\u02ec\u02ed\u0005i"+
		"\u0000\u0000\u02ed\u02ee\u0005v\u0000\u0000\u02ee\u02ef\u0005a\u0000\u0000"+
		"\u02ef\u02f0\u0005t\u0000\u0000\u02f0\u02f1\u0005e\u0000\u0000\u02f1l"+
		"\u0001\u0000\u0000\u0000\u02f2\u02f3\u0005p\u0000\u0000\u02f3\u02f4\u0005"+
		"r\u0000\u0000\u02f4\u02f5\u0005o\u0000\u0000\u02f5\u02f6\u0005t\u0000"+
		"\u0000\u02f6\u02f7\u0005e\u0000\u0000\u02f7\u02f8\u0005c\u0000\u0000\u02f8"+
		"\u02f9\u0005t\u0000\u0000\u02f9\u02fa\u0005e\u0000\u0000\u02fa\u02fb\u0005"+
		"d\u0000\u0000\u02fbn\u0001\u0000\u0000\u0000\u02fc\u02fd\u0005p\u0000"+
		"\u0000\u02fd\u02fe\u0005u\u0000\u0000\u02fe\u02ff\u0005b\u0000\u0000\u02ff"+
		"\u0300\u0005l\u0000\u0000\u0300\u0301\u0005i\u0000\u0000\u0301\u0302\u0005"+
		"c\u0000\u0000\u0302p\u0001\u0000\u0000\u0000\u0303\u0304\u0005r\u0000"+
		"\u0000\u0304\u0305\u0005e\u0000\u0000\u0305\u0306\u0005g\u0000\u0000\u0306"+
		"\u0307\u0005i\u0000\u0000\u0307\u0308\u0005s\u0000\u0000\u0308\u0309\u0005"+
		"t\u0000\u0000\u0309\u030a\u0005e\u0000\u0000\u030a\u030b\u0005r\u0000"+
		"\u0000\u030br\u0001\u0000\u0000\u0000\u030c\u030d\u0005r\u0000\u0000\u030d"+
		"\u030e\u0005e\u0000\u0000\u030e\u030f\u0005i\u0000\u0000\u030f\u0310\u0005"+
		"n\u0000\u0000\u0310\u0311\u0005t\u0000\u0000\u0311\u0312\u0005e\u0000"+
		"\u0000\u0312\u0313\u0005r\u0000\u0000\u0313\u0314\u0005p\u0000\u0000\u0314"+
		"\u0315\u0005r\u0000\u0000\u0315\u0316\u0005e\u0000\u0000\u0316\u0317\u0005"+
		"t\u0000\u0000\u0317\u0318\u0005_\u0000\u0000\u0318\u0319\u0005c\u0000"+
		"\u0000\u0319\u031a\u0005a\u0000\u0000\u031a\u031b\u0005s\u0000\u0000\u031b"+
		"\u031c\u0005t\u0000\u0000\u031ct\u0001\u0000\u0000\u0000\u031d\u031e\u0005"+
		"r\u0000\u0000\u031e\u031f\u0005e\u0000\u0000\u031f\u0320\u0005t\u0000"+
		"\u0000\u0320\u0321\u0005u\u0000\u0000\u0321\u0322\u0005r\u0000\u0000\u0322"+
		"\u0323\u0005n\u0000\u0000\u0323v\u0001\u0000\u0000\u0000\u0324\u0325\u0005"+
		"s\u0000\u0000\u0325\u0326\u0005h\u0000\u0000\u0326\u0327\u0005o\u0000"+
		"\u0000\u0327\u0328\u0005r\u0000\u0000\u0328\u0329\u0005t\u0000\u0000\u0329"+
		"x\u0001\u0000\u0000\u0000\u032a\u032b\u0005s\u0000\u0000\u032b\u032c\u0005"+
		"i\u0000\u0000\u032c\u032d\u0005g\u0000\u0000\u032d\u032e\u0005n\u0000"+
		"\u0000\u032e\u032f\u0005e\u0000\u0000\u032f\u0330\u0005d\u0000\u0000\u0330"+
		"z\u0001\u0000\u0000\u0000\u0331\u0332\u0005s\u0000\u0000\u0332\u0333\u0005"+
		"i\u0000\u0000\u0333\u0334\u0005z\u0000\u0000\u0334\u0335\u0005e\u0000"+
		"\u0000\u0335\u0336\u0005o\u0000\u0000\u0336\u0337\u0005f\u0000\u0000\u0337"+
		"|\u0001\u0000\u0000\u0000\u0338\u0339\u0005s\u0000\u0000\u0339\u033a\u0005"+
		"t\u0000\u0000\u033a\u033b\u0005a\u0000\u0000\u033b\u033c\u0005t\u0000"+
		"\u0000\u033c\u033d\u0005i\u0000\u0000\u033d\u033e\u0005c\u0000\u0000\u033e"+
		"~\u0001\u0000\u0000\u0000\u033f\u0340\u0005s\u0000\u0000\u0340\u0341\u0005"+
		"t\u0000\u0000\u0341\u0342\u0005a\u0000\u0000\u0342\u0343\u0005t\u0000"+
		"\u0000\u0343\u0344\u0005i\u0000\u0000\u0344\u0345\u0005c\u0000\u0000\u0345"+
		"\u0346\u0005_\u0000\u0000\u0346\u0347\u0005a\u0000\u0000\u0347\u0348\u0005"+
		"s\u0000\u0000\u0348\u0349\u0005s\u0000\u0000\u0349\u034a\u0005e\u0000"+
		"\u0000\u034a\u034b\u0005r\u0000\u0000\u034b\u034c\u0005t\u0000\u0000\u034c"+
		"\u0080\u0001\u0000\u0000\u0000\u034d\u034e\u0005s\u0000\u0000\u034e\u034f"+
		"\u0005t\u0000\u0000\u034f\u0350\u0005a\u0000\u0000\u0350\u0351\u0005t"+
		"\u0000\u0000\u0351\u0352\u0005i\u0000\u0000\u0352\u0353\u0005c\u0000\u0000"+
		"\u0353\u0354\u0005_\u0000\u0000\u0354\u0355\u0005c\u0000\u0000\u0355\u0356"+
		"\u0005a\u0000\u0000\u0356\u0357\u0005s\u0000\u0000\u0357\u0358\u0005t"+
		"\u0000\u0000\u0358\u0082\u0001\u0000\u0000\u0000\u0359\u035a\u0005s\u0000"+
		"\u0000\u035a\u035b\u0005t\u0000\u0000\u035b\u035c\u0005r\u0000\u0000\u035c"+
		"\u035d\u0005u\u0000\u0000\u035d\u035e\u0005c\u0000\u0000\u035e\u035f\u0005"+
		"t\u0000\u0000\u035f\u0084\u0001\u0000\u0000\u0000\u0360\u0361\u0005s\u0000"+
		"\u0000\u0361\u0362\u0005w\u0000\u0000\u0362\u0363\u0005i\u0000\u0000\u0363"+
		"\u0364\u0005t\u0000\u0000\u0364\u0365\u0005c\u0000\u0000\u0365\u0366\u0005"+
		"h\u0000\u0000\u0366\u0086\u0001\u0000\u0000\u0000\u0367\u0368\u0005t\u0000"+
		"\u0000\u0368\u0369\u0005e\u0000\u0000\u0369\u036a\u0005m\u0000\u0000\u036a"+
		"\u036b\u0005p\u0000\u0000\u036b\u036c\u0005l\u0000\u0000\u036c\u036d\u0005"+
		"a\u0000\u0000\u036d\u036e\u0005t\u0000\u0000\u036e\u036f\u0005e\u0000"+
		"\u0000\u036f\u0088\u0001\u0000\u0000\u0000\u0370\u0371\u0005t\u0000\u0000"+
		"\u0371\u0372\u0005h\u0000\u0000\u0372\u0373\u0005i\u0000\u0000\u0373\u0374"+
		"\u0005s\u0000\u0000\u0374\u008a\u0001\u0000\u0000\u0000\u0375\u0376\u0005"+
		"t\u0000\u0000\u0376\u0377\u0005h\u0000\u0000\u0377\u0378\u0005r\u0000"+
		"\u0000\u0378\u0379\u0005e\u0000\u0000\u0379\u037a\u0005a\u0000\u0000\u037a"+
		"\u037b\u0005d\u0000\u0000\u037b\u037c\u0005_\u0000\u0000\u037c\u037d\u0005"+
		"l\u0000\u0000\u037d\u037e\u0005o\u0000\u0000\u037e\u037f\u0005c\u0000"+
		"\u0000\u037f\u0380\u0005a\u0000\u0000\u0380\u0381\u0005l\u0000\u0000\u0381"+
		"\u008c\u0001\u0000\u0000\u0000\u0382\u0383\u0005t\u0000\u0000\u0383\u0384"+
		"\u0005h\u0000\u0000\u0384\u0385\u0005r\u0000\u0000\u0385\u0386\u0005o"+
		"\u0000\u0000\u0386\u0387\u0005w\u0000\u0000\u0387\u008e\u0001\u0000\u0000"+
		"\u0000\u0388\u0389\u0005t\u0000\u0000\u0389\u038a\u0005r\u0000\u0000\u038a"+
		"\u038b\u0005u\u0000\u0000\u038b\u038c\u0005e\u0000\u0000\u038c\u0090\u0001"+
		"\u0000\u0000\u0000\u038d\u038e\u0005t\u0000\u0000\u038e\u038f\u0005r\u0000"+
		"\u0000\u038f\u0390\u0005y\u0000\u0000\u0390\u0092\u0001\u0000\u0000\u0000"+
		"\u0391\u0392\u0005t\u0000\u0000\u0392\u0393\u0005y\u0000\u0000\u0393\u0394"+
		"\u0005p\u0000\u0000\u0394\u0395\u0005e\u0000\u0000\u0395\u0396\u0005d"+
		"\u0000\u0000\u0396\u0397\u0005e\u0000\u0000\u0397\u0398\u0005f\u0000\u0000"+
		"\u0398\u0094\u0001\u0000\u0000\u0000\u0399\u039a\u0005t\u0000\u0000\u039a"+
		"\u039b\u0005y\u0000\u0000\u039b\u039c\u0005p\u0000\u0000\u039c\u039d\u0005"+
		"e\u0000\u0000\u039d\u039e\u0005i\u0000\u0000\u039e\u039f\u0005d\u0000"+
		"\u0000\u039f\u0096\u0001\u0000\u0000\u0000\u03a0\u03a1\u0005t\u0000\u0000"+
		"\u03a1\u03a2\u0005y\u0000\u0000\u03a2\u03a3\u0005p\u0000\u0000\u03a3\u03a4"+
		"\u0005e\u0000\u0000\u03a4\u03a5\u0005n\u0000\u0000\u03a5\u03a6\u0005a"+
		"\u0000\u0000\u03a6\u03a7\u0005m\u0000\u0000\u03a7\u03a8\u0005e\u0000\u0000"+
		"\u03a8\u0098\u0001\u0000\u0000\u0000\u03a9\u03aa\u0005u\u0000\u0000\u03aa"+
		"\u03ab\u0005n\u0000\u0000\u03ab\u03ac\u0005i\u0000\u0000\u03ac\u03ad\u0005"+
		"o\u0000\u0000\u03ad\u03ae\u0005n\u0000\u0000\u03ae\u009a\u0001\u0000\u0000"+
		"\u0000\u03af\u03b0\u0005u\u0000\u0000\u03b0\u03b1\u0005n\u0000\u0000\u03b1"+
		"\u03b2\u0005s\u0000\u0000\u03b2\u03b3\u0005i\u0000\u0000\u03b3\u03b4\u0005"+
		"g\u0000\u0000\u03b4\u03b5\u0005n\u0000\u0000\u03b5\u03b6\u0005e\u0000"+
		"\u0000\u03b6\u03b7\u0005d\u0000\u0000\u03b7\u009c\u0001\u0000\u0000\u0000"+
		"\u03b8\u03b9\u0005u\u0000\u0000\u03b9\u03ba\u0005s\u0000\u0000\u03ba\u03bb"+
		"\u0005i\u0000\u0000\u03bb\u03bc\u0005n\u0000\u0000\u03bc\u03bd\u0005g"+
		"\u0000\u0000\u03bd\u009e\u0001\u0000\u0000\u0000\u03be\u03bf\u0005v\u0000"+
		"\u0000\u03bf\u03c0\u0005i\u0000\u0000\u03c0\u03c1\u0005r\u0000\u0000\u03c1"+
		"\u03c2\u0005t\u0000\u0000\u03c2\u03c3\u0005u\u0000\u0000\u03c3\u03c4\u0005"+
		"a\u0000\u0000\u03c4\u03c5\u0005l\u0000\u0000\u03c5\u00a0\u0001\u0000\u0000"+
		"\u0000\u03c6\u03c7\u0005v\u0000\u0000\u03c7\u03c8\u0005o\u0000\u0000\u03c8"+
		"\u03c9\u0005i\u0000\u0000\u03c9\u03ca\u0005d\u0000\u0000\u03ca\u00a2\u0001"+
		"\u0000\u0000\u0000\u03cb\u03cc\u0005v\u0000\u0000\u03cc\u03cd\u0005o\u0000"+
		"\u0000\u03cd\u03ce\u0005l\u0000\u0000\u03ce\u03cf\u0005a\u0000\u0000\u03cf"+
		"\u03d0\u0005t\u0000\u0000\u03d0\u03d1\u0005i\u0000\u0000\u03d1\u03d2\u0005"+
		"l\u0000\u0000\u03d2\u03d3\u0005e\u0000\u0000\u03d3\u00a4\u0001\u0000\u0000"+
		"\u0000\u03d4\u03d5\u0005w\u0000\u0000\u03d5\u03d6\u0005c\u0000\u0000\u03d6"+
		"\u03d7\u0005h\u0000\u0000\u03d7\u03d8\u0005a\u0000\u0000\u03d8\u03d9\u0005"+
		"r\u0000\u0000\u03d9\u03da\u0005_\u0000\u0000\u03da\u03db\u0005t\u0000"+
		"\u0000\u03db\u00a6\u0001\u0000\u0000\u0000\u03dc\u03dd\u0005w\u0000\u0000"+
		"\u03dd\u03de\u0005h\u0000\u0000\u03de\u03df\u0005i\u0000\u0000\u03df\u03e0"+
		"\u0005l\u0000\u0000\u03e0\u03e1\u0005e\u0000\u0000\u03e1\u00a8\u0001\u0000"+
		"\u0000\u0000\u03e2\u03e3\u0005(\u0000\u0000\u03e3\u00aa\u0001\u0000\u0000"+
		"\u0000\u03e4\u03e5\u0005)\u0000\u0000\u03e5\u00ac\u0001\u0000\u0000\u0000"+
		"\u03e6\u03e7\u0005[\u0000\u0000\u03e7\u00ae\u0001\u0000\u0000\u0000\u03e8"+
		"\u03e9\u0005]\u0000\u0000\u03e9\u00b0\u0001\u0000\u0000\u0000\u03ea\u03eb"+
		"\u0005{\u0000\u0000\u03eb\u00b2\u0001\u0000\u0000\u0000\u03ec\u03ed\u0005"+
		"}\u0000\u0000\u03ed\u00b4\u0001\u0000\u0000\u0000\u03ee\u03ef\u0005+\u0000"+
		"\u0000\u03ef\u00b6\u0001\u0000\u0000\u0000\u03f0\u03f1\u0005-\u0000\u0000"+
		"\u03f1\u00b8\u0001\u0000\u0000\u0000\u03f2\u03f3\u0005*\u0000\u0000\u03f3"+
		"\u00ba\u0001\u0000\u0000\u0000\u03f4\u03f5\u0005/\u0000\u0000\u03f5\u00bc"+
		"\u0001\u0000\u0000\u0000\u03f6\u03f7\u0005%\u0000\u0000\u03f7\u00be\u0001"+
		"\u0000\u0000\u0000\u03f8\u03f9\u0005^\u0000\u0000\u03f9\u00c0\u0001\u0000"+
		"\u0000\u0000\u03fa\u03fb\u0005&\u0000\u0000\u03fb\u00c2\u0001\u0000\u0000"+
		"\u0000\u03fc\u03fd\u0005|\u0000\u0000\u03fd\u00c4\u0001\u0000\u0000\u0000"+
		"\u03fe\u03ff\u0005~\u0000\u0000\u03ff\u00c6\u0001\u0000\u0000\u0000\u0400"+
		"\u0405\u0005!\u0000\u0000\u0401\u0402\u0005n\u0000\u0000\u0402\u0403\u0005"+
		"o\u0000\u0000\u0403\u0405\u0005t\u0000\u0000\u0404\u0400\u0001\u0000\u0000"+
		"\u0000\u0404\u0401\u0001\u0000\u0000\u0000\u0405\u00c8\u0001\u0000\u0000"+
		"\u0000\u0406\u0407\u0005=\u0000\u0000\u0407\u00ca\u0001\u0000\u0000\u0000"+
		"\u0408\u0409\u0005<\u0000\u0000\u0409\u00cc\u0001\u0000\u0000\u0000\u040a"+
		"\u040b\u0005>\u0000\u0000\u040b\u00ce\u0001\u0000\u0000\u0000\u040c\u040d"+
		"\u0005+\u0000\u0000\u040d\u040e\u0005=\u0000\u0000\u040e\u00d0\u0001\u0000"+
		"\u0000\u0000\u040f\u0410\u0005-\u0000\u0000\u0410\u0411\u0005=\u0000\u0000"+
		"\u0411\u00d2\u0001\u0000\u0000\u0000\u0412\u0413\u0005*\u0000\u0000\u0413"+
		"\u0414\u0005=\u0000\u0000\u0414\u00d4\u0001\u0000\u0000\u0000\u0415\u0416"+
		"\u0005/\u0000\u0000\u0416\u0417\u0005=\u0000\u0000\u0417\u00d6\u0001\u0000"+
		"\u0000\u0000\u0418\u0419\u0005%\u0000\u0000\u0419\u041a\u0005=\u0000\u0000"+
		"\u041a\u00d8\u0001\u0000\u0000\u0000\u041b\u041c\u0005^\u0000\u0000\u041c"+
		"\u041d\u0005=\u0000\u0000\u041d\u00da\u0001\u0000\u0000\u0000\u041e\u041f"+
		"\u0005&\u0000\u0000\u041f\u0420\u0005=\u0000\u0000\u0420\u00dc\u0001\u0000"+
		"\u0000\u0000\u0421\u0422\u0005|\u0000\u0000\u0422\u0423\u0005=\u0000\u0000"+
		"\u0423\u00de\u0001\u0000\u0000\u0000\u0424\u0425\u0005<\u0000\u0000\u0425"+
		"\u0426\u0005<\u0000\u0000\u0426\u0427\u0005=\u0000\u0000\u0427\u00e0\u0001"+
		"\u0000\u0000\u0000\u0428\u0429\u0005>\u0000\u0000\u0429\u042a\u0005>\u0000"+
		"\u0000\u042a\u042b\u0005=\u0000\u0000\u042b\u00e2\u0001\u0000\u0000\u0000"+
		"\u042c\u042d\u0005=\u0000\u0000\u042d\u042e\u0005=\u0000\u0000\u042e\u00e4"+
		"\u0001\u0000\u0000\u0000\u042f\u0430\u0005!\u0000\u0000\u0430\u0431\u0005"+
		"=\u0000\u0000\u0431\u00e6\u0001\u0000\u0000\u0000\u0432\u0433\u0005<\u0000"+
		"\u0000\u0433\u0434\u0005=\u0000\u0000\u0434\u00e8\u0001\u0000\u0000\u0000"+
		"\u0435\u0436\u0005>\u0000\u0000\u0436\u0437\u0005=\u0000\u0000\u0437\u00ea"+
		"\u0001\u0000\u0000\u0000\u0438\u0439\u0005&\u0000\u0000\u0439\u043e\u0005"+
		"&\u0000\u0000\u043a\u043b\u0005a\u0000\u0000\u043b\u043c\u0005n\u0000"+
		"\u0000\u043c\u043e\u0005d\u0000\u0000\u043d\u0438\u0001\u0000\u0000\u0000"+
		"\u043d\u043a\u0001\u0000\u0000\u0000\u043e\u00ec\u0001\u0000\u0000\u0000"+
		"\u043f\u0440\u0005|\u0000\u0000\u0440\u0444\u0005|\u0000\u0000\u0441\u0442"+
		"\u0005o\u0000\u0000\u0442\u0444\u0005r\u0000\u0000\u0443\u043f\u0001\u0000"+
		"\u0000\u0000\u0443\u0441\u0001\u0000\u0000\u0000\u0444\u00ee\u0001\u0000"+
		"\u0000\u0000\u0445\u0446\u0005+\u0000\u0000\u0446\u0447\u0005+\u0000\u0000"+
		"\u0447\u00f0\u0001\u0000\u0000\u0000\u0448\u0449\u0005-\u0000\u0000\u0449"+
		"\u044a\u0005-\u0000\u0000\u044a\u00f2\u0001\u0000\u0000\u0000\u044b\u044c"+
		"\u0005,\u0000\u0000\u044c\u00f4\u0001\u0000\u0000\u0000\u044d\u044e\u0005"+
		"-\u0000\u0000\u044e\u044f\u0005>\u0000\u0000\u044f\u0450\u0005*\u0000"+
		"\u0000\u0450\u00f6\u0001\u0000\u0000\u0000\u0451\u0452\u0005-\u0000\u0000"+
		"\u0452\u0453\u0005>\u0000\u0000\u0453\u00f8\u0001\u0000\u0000\u0000\u0454"+
		"\u0455\u0005?\u0000\u0000\u0455\u00fa\u0001\u0000\u0000\u0000\u0456\u0457"+
		"\u0005:\u0000\u0000\u0457\u00fc\u0001\u0000\u0000\u0000\u0458\u0459\u0005"+
		":\u0000\u0000\u0459\u045a\u0005:\u0000\u0000\u045a\u00fe\u0001\u0000\u0000"+
		"\u0000\u045b\u045c\u0005;\u0000\u0000\u045c\u0100\u0001\u0000\u0000\u0000"+
		"\u045d\u045e\u0005.\u0000\u0000\u045e\u0102\u0001\u0000\u0000\u0000\u045f"+
		"\u0460\u0005.\u0000\u0000\u0460\u0461\u0005*\u0000\u0000\u0461\u0104\u0001"+
		"\u0000\u0000\u0000\u0462\u0463\u0005.\u0000\u0000\u0463\u0464\u0005.\u0000"+
		"\u0000\u0464\u0465\u0005.\u0000\u0000\u0465\u0106\u0001\u0000\u0000\u0000"+
		"\u0466\u0467\u0003\u011f\u008f\u0000\u0467\u0468\u0003\u011f\u008f\u0000"+
		"\u0468\u0469\u0003\u011f\u008f\u0000\u0469\u046a\u0003\u011f\u008f\u0000"+
		"\u046a\u0108\u0001\u0000\u0000\u0000\u046b\u046c\u0005\\\u0000\u0000\u046c"+
		"\u046d\u0005u\u0000\u0000\u046d\u046e\u0001\u0000\u0000\u0000\u046e\u0476"+
		"\u0003\u0107\u0083\u0000\u046f\u0470\u0005\\\u0000\u0000\u0470\u0471\u0005"+
		"U\u0000\u0000\u0471\u0472\u0001\u0000\u0000\u0000\u0472\u0473\u0003\u0107"+
		"\u0083\u0000\u0473\u0474\u0003\u0107\u0083\u0000\u0474\u0476\u0001\u0000"+
		"\u0000\u0000\u0475\u046b\u0001\u0000\u0000\u0000\u0475\u046f\u0001\u0000"+
		"\u0000\u0000\u0476\u010a\u0001\u0000\u0000\u0000\u0477\u047c\u0003\u010d"+
		"\u0086\u0000\u0478\u047b\u0003\u010d\u0086\u0000\u0479\u047b\u0003\u0111"+
		"\u0088\u0000\u047a\u0478\u0001\u0000\u0000\u0000\u047a\u0479\u0001\u0000"+
		"\u0000\u0000\u047b\u047e\u0001\u0000\u0000\u0000\u047c\u047a\u0001\u0000"+
		"\u0000\u0000\u047c\u047d\u0001\u0000\u0000\u0000\u047d\u010c\u0001\u0000"+
		"\u0000\u0000\u047e\u047c\u0001\u0000\u0000\u0000\u047f\u0482\u0003\u010f"+
		"\u0087\u0000\u0480\u0482\u0003\u0109\u0084\u0000\u0481\u047f\u0001\u0000"+
		"\u0000\u0000\u0481\u0480\u0001\u0000\u0000\u0000\u0482\u010e\u0001\u0000"+
		"\u0000\u0000\u0483\u0484\u0007\u0002\u0000\u0000\u0484\u0110\u0001\u0000"+
		"\u0000\u0000\u0485\u0486\u0007\u0003\u0000\u0000\u0486\u0112\u0001\u0000"+
		"\u0000\u0000\u0487\u048e\u0003\u011b\u008d\u0000\u0488\u048a\u0005\'\u0000"+
		"\u0000\u0489\u0488\u0001\u0000\u0000\u0000\u0489\u048a\u0001\u0000\u0000"+
		"\u0000\u048a\u048b\u0001\u0000\u0000\u0000\u048b\u048d\u0003\u0111\u0088"+
		"\u0000\u048c\u0489\u0001\u0000\u0000\u0000\u048d\u0490\u0001\u0000\u0000"+
		"\u0000\u048e\u048c\u0001\u0000\u0000\u0000\u048e\u048f\u0001\u0000\u0000"+
		"\u0000\u048f\u0114\u0001\u0000\u0000\u0000\u0490\u048e\u0001\u0000\u0000"+
		"\u0000\u0491\u0498\u00050\u0000\u0000\u0492\u0494\u0005\'\u0000\u0000"+
		"\u0493\u0492\u0001\u0000\u0000\u0000\u0493\u0494\u0001\u0000\u0000\u0000"+
		"\u0494\u0495\u0001\u0000\u0000\u0000\u0495\u0497\u0003\u011d\u008e\u0000"+
		"\u0496\u0493\u0001\u0000\u0000\u0000\u0497\u049a\u0001\u0000\u0000\u0000"+
		"\u0498\u0496\u0001\u0000\u0000\u0000\u0498\u0499\u0001\u0000\u0000\u0000"+
		"\u0499\u0116\u0001\u0000\u0000\u0000\u049a\u0498\u0001\u0000\u0000\u0000"+
		"\u049b\u049c\u00050\u0000\u0000\u049c\u04a0\u0005x\u0000\u0000\u049d\u049e"+
		"\u00050\u0000\u0000\u049e\u04a0\u0005X\u0000\u0000\u049f\u049b\u0001\u0000"+
		"\u0000\u0000\u049f\u049d\u0001\u0000\u0000\u0000\u04a0\u04a1\u0001\u0000"+
		"\u0000\u0000\u04a1\u04a8\u0003\u011f\u008f\u0000\u04a2\u04a4\u0005\'\u0000"+
		"\u0000\u04a3\u04a2\u0001\u0000\u0000\u0000\u04a3\u04a4\u0001\u0000\u0000"+
		"\u0000\u04a4\u04a5\u0001\u0000\u0000\u0000\u04a5\u04a7\u0003\u011f\u008f"+
		"\u0000\u04a6\u04a3\u0001\u0000\u0000\u0000\u04a7\u04aa\u0001\u0000\u0000"+
		"\u0000\u04a8\u04a6\u0001\u0000\u0000\u0000\u04a8\u04a9\u0001\u0000\u0000"+
		"\u0000\u04a9\u0118\u0001\u0000\u0000\u0000\u04aa\u04a8\u0001\u0000\u0000"+
		"\u0000\u04ab\u04ac\u00050\u0000\u0000\u04ac\u04b0\u0005b\u0000\u0000\u04ad"+
		"\u04ae\u00050\u0000\u0000\u04ae\u04b0\u0005B\u0000\u0000\u04af\u04ab\u0001"+
		"\u0000\u0000\u0000\u04af\u04ad\u0001\u0000\u0000\u0000\u04b0\u04b1\u0001"+
		"\u0000\u0000\u0000\u04b1\u04b8\u0003\u0121\u0090\u0000\u04b2\u04b4\u0005"+
		"\'\u0000\u0000\u04b3\u04b2\u0001\u0000\u0000\u0000\u04b3\u04b4\u0001\u0000"+
		"\u0000\u0000\u04b4\u04b5\u0001\u0000\u0000\u0000\u04b5\u04b7\u0003\u0121"+
		"\u0090\u0000\u04b6\u04b3\u0001\u0000\u0000\u0000\u04b7\u04ba\u0001\u0000"+
		"\u0000\u0000\u04b8\u04b6\u0001\u0000\u0000\u0000\u04b8\u04b9\u0001\u0000"+
		"\u0000\u0000\u04b9\u011a\u0001\u0000\u0000\u0000\u04ba\u04b8\u0001\u0000"+
		"\u0000\u0000\u04bb\u04bc\u0007\u0004\u0000\u0000\u04bc\u011c\u0001\u0000"+
		"\u0000\u0000\u04bd\u04be\u0007\u0005\u0000\u0000\u04be\u011e\u0001\u0000"+
		"\u0000\u0000\u04bf\u04c0\u0007\u0006\u0000\u0000\u04c0\u0120\u0001\u0000"+
		"\u0000\u0000\u04c1\u04c2\u0007\u0007\u0000\u0000\u04c2\u0122\u0001\u0000"+
		"\u0000\u0000\u04c3\u04c5\u0003\u0125\u0092\u0000\u04c4\u04c6\u0003\u0127"+
		"\u0093\u0000\u04c5\u04c4\u0001\u0000\u0000\u0000\u04c5\u04c6\u0001\u0000"+
		"\u0000\u0000\u04c6\u04d4\u0001\u0000\u0000\u0000\u04c7\u04c9\u0003\u0125"+
		"\u0092\u0000\u04c8\u04ca\u0003\u0129\u0094\u0000\u04c9\u04c8\u0001\u0000"+
		"\u0000\u0000\u04c9\u04ca\u0001\u0000\u0000\u0000\u04ca\u04d4\u0001\u0000"+
		"\u0000\u0000\u04cb\u04cd\u0003\u0127\u0093\u0000\u04cc\u04ce\u0003\u0125"+
		"\u0092\u0000\u04cd\u04cc\u0001\u0000\u0000\u0000\u04cd\u04ce\u0001\u0000"+
		"\u0000\u0000\u04ce\u04d4\u0001\u0000\u0000\u0000\u04cf\u04d1\u0003\u0129"+
		"\u0094\u0000\u04d0\u04d2\u0003\u0125\u0092\u0000\u04d1\u04d0\u0001\u0000"+
		"\u0000\u0000\u04d1\u04d2\u0001\u0000\u0000\u0000\u04d2\u04d4\u0001\u0000"+
		"\u0000\u0000\u04d3\u04c3\u0001\u0000\u0000\u0000\u04d3\u04c7\u0001\u0000"+
		"\u0000\u0000\u04d3\u04cb\u0001\u0000\u0000\u0000\u04d3\u04cf\u0001\u0000"+
		"\u0000\u0000\u04d4\u0124\u0001\u0000\u0000\u0000\u04d5\u04d6\u0007\b\u0000"+
		"\u0000\u04d6\u0126\u0001\u0000\u0000\u0000\u04d7\u04d8\u0007\t\u0000\u0000"+
		"\u04d8\u0128\u0001\u0000\u0000\u0000\u04d9\u04da\u0005l\u0000\u0000\u04da"+
		"\u04de\u0005l\u0000\u0000\u04db\u04dc\u0005L\u0000\u0000\u04dc\u04de\u0005"+
		"L\u0000\u0000\u04dd\u04d9\u0001\u0000\u0000\u0000\u04dd\u04db\u0001\u0000"+
		"\u0000\u0000\u04de\u012a\u0001\u0000\u0000\u0000\u04df\u04e3\b\n\u0000"+
		"\u0000\u04e0\u04e3\u0003\u012d\u0096\u0000\u04e1\u04e3\u0003\u0109\u0084"+
		"\u0000\u04e2\u04df\u0001\u0000\u0000\u0000\u04e2\u04e0\u0001\u0000\u0000"+
		"\u0000\u04e2\u04e1\u0001\u0000\u0000\u0000\u04e3\u012c\u0001\u0000\u0000"+
		"\u0000\u04e4\u04e8\u0003\u012f\u0097\u0000\u04e5\u04e8\u0003\u0131\u0098"+
		"\u0000\u04e6\u04e8\u0003\u0133\u0099\u0000\u04e7\u04e4\u0001\u0000\u0000"+
		"\u0000\u04e7\u04e5\u0001\u0000\u0000\u0000\u04e7\u04e6\u0001\u0000\u0000"+
		"\u0000\u04e8\u012e\u0001\u0000\u0000\u0000\u04e9\u04ea\u0005\\\u0000\u0000"+
		"\u04ea\u0508\u0005\'\u0000\u0000\u04eb\u04ec\u0005\\\u0000\u0000\u04ec"+
		"\u0508\u0005\"\u0000\u0000\u04ed\u04ee\u0005\\\u0000\u0000\u04ee\u0508"+
		"\u0005?\u0000\u0000\u04ef\u04f0\u0005\\\u0000\u0000\u04f0\u0508\u0005"+
		"\\\u0000\u0000\u04f1\u04f2\u0005\\\u0000\u0000\u04f2\u0508\u0005a\u0000"+
		"\u0000\u04f3\u04f4\u0005\\\u0000\u0000\u04f4\u0508\u0005b\u0000\u0000"+
		"\u04f5\u04f6\u0005\\\u0000\u0000\u04f6\u0508\u0005f\u0000\u0000\u04f7"+
		"\u04f8\u0005\\\u0000\u0000\u04f8\u0508\u0005n\u0000\u0000\u04f9\u04fa"+
		"\u0005\\\u0000\u0000\u04fa\u0508\u0005r\u0000\u0000\u04fb\u0501\u0005"+
		"\\\u0000\u0000\u04fc\u04fe\u0005\r\u0000\u0000\u04fd\u04ff\u0005\n\u0000"+
		"\u0000\u04fe\u04fd\u0001\u0000\u0000\u0000\u04fe\u04ff\u0001\u0000\u0000"+
		"\u0000\u04ff\u0502\u0001\u0000\u0000\u0000\u0500\u0502\u0005\n\u0000\u0000"+
		"\u0501\u04fc\u0001\u0000\u0000\u0000\u0501\u0500\u0001\u0000\u0000\u0000"+
		"\u0502\u0508\u0001\u0000\u0000\u0000\u0503\u0504\u0005\\\u0000\u0000\u0504"+
		"\u0508\u0005t\u0000\u0000\u0505\u0506\u0005\\\u0000\u0000\u0506\u0508"+
		"\u0005v\u0000\u0000\u0507\u04e9\u0001\u0000\u0000\u0000\u0507\u04eb\u0001"+
		"\u0000\u0000\u0000\u0507\u04ed\u0001\u0000\u0000\u0000\u0507\u04ef\u0001"+
		"\u0000\u0000\u0000\u0507\u04f1\u0001\u0000\u0000\u0000\u0507\u04f3\u0001"+
		"\u0000\u0000\u0000\u0507\u04f5\u0001\u0000\u0000\u0000\u0507\u04f7\u0001"+
		"\u0000\u0000\u0000\u0507\u04f9\u0001\u0000\u0000\u0000\u0507\u04fb\u0001"+
		"\u0000\u0000\u0000\u0507\u0503\u0001\u0000\u0000\u0000\u0507\u0505\u0001"+
		"\u0000\u0000\u0000\u0508\u0130\u0001\u0000\u0000\u0000\u0509\u050a\u0005"+
		"\\\u0000\u0000\u050a\u0515\u0003\u011d\u008e\u0000\u050b\u050c\u0005\\"+
		"\u0000\u0000\u050c\u050d\u0003\u011d\u008e\u0000\u050d\u050e\u0003\u011d"+
		"\u008e\u0000\u050e\u0515\u0001\u0000\u0000\u0000\u050f\u0510\u0005\\\u0000"+
		"\u0000\u0510\u0511\u0003\u011d\u008e\u0000\u0511\u0512\u0003\u011d\u008e"+
		"\u0000\u0512\u0513\u0003\u011d\u008e\u0000\u0513\u0515\u0001\u0000\u0000"+
		"\u0000\u0514\u0509\u0001\u0000\u0000\u0000\u0514\u050b\u0001\u0000\u0000"+
		"\u0000\u0514\u050f\u0001\u0000\u0000\u0000\u0515\u0132\u0001\u0000\u0000"+
		"\u0000\u0516\u0517\u0005\\\u0000\u0000\u0517\u0518\u0005x\u0000\u0000"+
		"\u0518\u051a\u0001\u0000\u0000\u0000\u0519\u051b\u0003\u011f\u008f\u0000"+
		"\u051a\u0519\u0001\u0000\u0000\u0000\u051b\u051c\u0001\u0000\u0000\u0000"+
		"\u051c\u051a\u0001\u0000\u0000\u0000\u051c\u051d\u0001\u0000\u0000\u0000"+
		"\u051d\u0134\u0001\u0000\u0000\u0000\u051e\u0520\u0003\u013b\u009d\u0000"+
		"\u051f\u051e\u0001\u0000\u0000\u0000\u051f\u0520\u0001\u0000\u0000\u0000"+
		"\u0520\u0521\u0001\u0000\u0000\u0000\u0521\u0522\u0005.\u0000\u0000\u0522"+
		"\u0527\u0003\u013b\u009d\u0000\u0523\u0524\u0003\u013b\u009d\u0000\u0524"+
		"\u0525\u0005.\u0000\u0000\u0525\u0527\u0001\u0000\u0000\u0000\u0526\u051f"+
		"\u0001\u0000\u0000\u0000\u0526\u0523\u0001\u0000\u0000\u0000\u0527\u0136"+
		"\u0001\u0000\u0000\u0000\u0528\u052a\u0005e\u0000\u0000\u0529\u052b\u0003"+
		"\u0139\u009c\u0000\u052a\u0529\u0001\u0000\u0000\u0000\u052a\u052b\u0001"+
		"\u0000\u0000\u0000\u052b\u052c\u0001\u0000\u0000\u0000\u052c\u0533\u0003"+
		"\u013b\u009d\u0000\u052d\u052f\u0005E\u0000\u0000\u052e\u0530\u0003\u0139"+
		"\u009c\u0000\u052f\u052e\u0001\u0000\u0000\u0000\u052f\u0530\u0001\u0000"+
		"\u0000\u0000\u0530\u0531\u0001\u0000\u0000\u0000\u0531\u0533\u0003\u013b"+
		"\u009d\u0000\u0532\u0528\u0001\u0000\u0000\u0000\u0532\u052d\u0001\u0000"+
		"\u0000\u0000\u0533\u0138\u0001\u0000\u0000\u0000\u0534\u0535\u0007\u000b"+
		"\u0000\u0000\u0535\u013a\u0001\u0000\u0000\u0000\u0536\u053d\u0003\u0111"+
		"\u0088\u0000\u0537\u0539\u0005\'\u0000\u0000\u0538\u0537\u0001\u0000\u0000"+
		"\u0000\u0538\u0539\u0001\u0000\u0000\u0000\u0539\u053a\u0001\u0000\u0000"+
		"\u0000\u053a\u053c\u0003\u0111\u0088\u0000\u053b\u0538\u0001\u0000\u0000"+
		"\u0000\u053c\u053f\u0001\u0000\u0000\u0000\u053d\u053b\u0001\u0000\u0000"+
		"\u0000\u053d\u053e\u0001\u0000\u0000\u0000\u053e\u013c\u0001\u0000\u0000"+
		"\u0000\u053f\u053d\u0001\u0000\u0000\u0000\u0540\u0541\u0007\f\u0000\u0000"+
		"\u0541\u013e\u0001\u0000\u0000\u0000\u0542\u0543\u0005u\u0000\u0000\u0543"+
		"\u0546\u00058\u0000\u0000\u0544\u0546\u0007\u0000\u0000\u0000\u0545\u0542"+
		"\u0001\u0000\u0000\u0000\u0545\u0544\u0001\u0000\u0000\u0000\u0546\u0140"+
		"\u0001\u0000\u0000\u0000\u0547\u054b\b\r\u0000\u0000\u0548\u054b\u0003"+
		"\u012d\u0096\u0000\u0549\u054b\u0003\u0109\u0084\u0000\u054a\u0547\u0001"+
		"\u0000\u0000\u0000\u054a\u0548\u0001\u0000\u0000\u0000\u054a\u0549\u0001"+
		"\u0000\u0000\u0000\u054b\u0142\u0001\u0000\u0000\u0000\u054c\u054d\u0005"+
		"R\u0000\u0000\u054d\u054e\u0005\"\u0000\u0000\u054e\u0554\u0001\u0000"+
		"\u0000\u0000\u054f\u0550\u0005\\\u0000\u0000\u0550\u0553\u0007\u000e\u0000"+
		"\u0000\u0551\u0553\b\u000f\u0000\u0000\u0552\u054f\u0001\u0000\u0000\u0000"+
		"\u0552\u0551\u0001\u0000\u0000\u0000\u0553\u0556\u0001\u0000\u0000\u0000"+
		"\u0554\u0555\u0001\u0000\u0000\u0000\u0554\u0552\u0001\u0000\u0000\u0000"+
		"\u0555\u0557\u0001\u0000\u0000\u0000\u0556\u0554\u0001\u0000\u0000\u0000"+
		"\u0557\u055b\u0005(\u0000\u0000\u0558\u055a\b\u0010\u0000\u0000\u0559"+
		"\u0558\u0001\u0000\u0000\u0000\u055a\u055d\u0001\u0000\u0000\u0000\u055b"+
		"\u055c\u0001\u0000\u0000\u0000\u055b\u0559\u0001\u0000\u0000\u0000\u055c"+
		"\u055e\u0001\u0000\u0000\u0000\u055d\u055b\u0001\u0000\u0000\u0000\u055e"+
		"\u0564\u0005)\u0000\u0000\u055f\u0560\u0005\\\u0000\u0000\u0560\u0563"+
		"\u0007\u000e\u0000\u0000\u0561\u0563\b\u0011\u0000\u0000\u0562\u055f\u0001"+
		"\u0000\u0000\u0000\u0562\u0561\u0001\u0000\u0000\u0000\u0563\u0566\u0001"+
		"\u0000\u0000\u0000\u0564\u0565\u0001\u0000\u0000\u0000\u0564\u0562\u0001"+
		"\u0000\u0000\u0000\u0565\u0567\u0001\u0000\u0000\u0000\u0566\u0564\u0001"+
		"\u0000\u0000\u0000\u0567\u0568\u0005\"\u0000\u0000\u0568\u0144\u0001\u0000"+
		"\u0000\u0000\u0569\u056a\u0003\u0113\u0089\u0000\u056a\u056b\u0003\u014d"+
		"\u00a6\u0000\u056b\u0576\u0001\u0000\u0000\u0000\u056c\u056d\u0003\u0115"+
		"\u008a\u0000\u056d\u056e\u0003\u014d\u00a6\u0000\u056e\u0576\u0001\u0000"+
		"\u0000\u0000\u056f\u0570\u0003\u0117\u008b\u0000\u0570\u0571\u0003\u014d"+
		"\u00a6\u0000\u0571\u0576\u0001\u0000\u0000\u0000\u0572\u0573\u0003\u0119"+
		"\u008c\u0000\u0573\u0574\u0003\u014d\u00a6\u0000\u0574\u0576\u0001\u0000"+
		"\u0000\u0000\u0575\u0569\u0001\u0000\u0000\u0000\u0575\u056c\u0001\u0000"+
		"\u0000\u0000\u0575\u056f\u0001\u0000\u0000\u0000\u0575\u0572\u0001\u0000"+
		"\u0000\u0000\u0576\u0146\u0001\u0000\u0000\u0000\u0577\u0579\u0003\u0135"+
		"\u009a\u0000\u0578\u057a\u0003\u0137\u009b\u0000\u0579\u0578\u0001\u0000"+
		"\u0000\u0000\u0579\u057a\u0001\u0000\u0000\u0000\u057a\u057b\u0001\u0000"+
		"\u0000\u0000\u057b\u057c\u0003\u014d\u00a6\u0000\u057c\u0582\u0001\u0000"+
		"\u0000\u0000\u057d\u057e\u0003\u013b\u009d\u0000\u057e\u057f\u0003\u0137"+
		"\u009b\u0000\u057f\u0580\u0003\u014d\u00a6\u0000\u0580\u0582\u0001\u0000"+
		"\u0000\u0000\u0581\u0577\u0001\u0000\u0000\u0000\u0581\u057d\u0001\u0000"+
		"\u0000\u0000\u0582\u0148\u0001\u0000\u0000\u0000\u0583\u0584\u0003\u0007"+
		"\u0003\u0000\u0584\u0585\u0003\u014d\u00a6\u0000\u0585\u014a\u0001\u0000"+
		"\u0000\u0000\u0586\u0587\u0003\u0003\u0001\u0000\u0587\u0588\u0003\u014d"+
		"\u00a6\u0000\u0588\u014c\u0001\u0000\u0000\u0000\u0589\u058a\u0003\u010b"+
		"\u0085\u0000\u058a\u014e\u0001\u0000\u0000\u0000\u058b\u058d\u0007\u0012"+
		"\u0000\u0000\u058c\u058b\u0001\u0000\u0000\u0000\u058d\u058e\u0001\u0000"+
		"\u0000\u0000\u058e\u058c\u0001\u0000\u0000\u0000\u058e\u058f\u0001\u0000"+
		"\u0000\u0000\u058f\u0590\u0001\u0000\u0000\u0000\u0590\u0591\u0006\u00a7"+
		"\u0001\u0000\u0591\u0150\u0001\u0000\u0000\u0000\u0592\u0594\u0005\r\u0000"+
		"\u0000\u0593\u0595\u0005\n\u0000\u0000\u0594\u0593\u0001\u0000\u0000\u0000"+
		"\u0594\u0595\u0001\u0000\u0000\u0000\u0595\u0598\u0001\u0000\u0000\u0000"+
		"\u0596\u0598\u0005\n\u0000\u0000\u0597\u0592\u0001\u0000\u0000\u0000\u0597"+
		"\u0596\u0001\u0000\u0000\u0000\u0598\u0599\u0001\u0000\u0000\u0000\u0599"+
		"\u059a\u0006\u00a8\u0001\u0000\u059a\u0152\u0001\u0000\u0000\u0000\u059b"+
		"\u059c\u0005/\u0000\u0000\u059c\u059d\u0005*\u0000\u0000\u059d\u05a1\u0001"+
		"\u0000\u0000\u0000\u059e\u05a0\t\u0000\u0000\u0000\u059f\u059e\u0001\u0000"+
		"\u0000\u0000\u05a0\u05a3\u0001\u0000\u0000\u0000\u05a1\u05a2\u0001\u0000"+
		"\u0000\u0000\u05a1\u059f\u0001\u0000\u0000\u0000\u05a2\u05a4\u0001\u0000"+
		"\u0000\u0000\u05a3\u05a1\u0001\u0000\u0000\u0000\u05a4\u05a5\u0005*\u0000"+
		"\u0000\u05a5\u05a6\u0005/\u0000\u0000\u05a6\u05a7\u0001\u0000\u0000\u0000"+
		"\u05a7\u05a8\u0006\u00a9\u0001\u0000\u05a8\u0154\u0001\u0000\u0000\u0000"+
		"\u05a9\u05aa\u0005/\u0000\u0000\u05aa\u05ab\u0005/\u0000\u0000\u05ab\u05af"+
		"\u0001\u0000\u0000\u0000\u05ac\u05ae\b\u0013\u0000\u0000\u05ad\u05ac\u0001"+
		"\u0000\u0000\u0000\u05ae\u05b1\u0001\u0000\u0000\u0000\u05af\u05ad\u0001"+
		"\u0000\u0000\u0000\u05af\u05b0\u0001\u0000\u0000\u0000\u05b0\u05b2\u0001"+
		"\u0000\u0000\u0000\u05b1\u05af\u0001\u0000\u0000\u0000\u05b2\u05b3\u0006"+
		"\u00aa\u0001\u0000\u05b3\u0156\u0001\u0000\u0000\u0000J\u0000\u0159\u015d"+
		"\u0161\u0165\u0167\u016a\u0170\u0176\u0179\u017e\u0180\u0183\u018a\u018e"+
		"\u0192\u019a\u01a0\u01a5\u01aa\u01af\u01b7\u0404\u043d\u0443\u0475\u047a"+
		"\u047c\u0481\u0489\u048e\u0493\u0498\u049f\u04a3\u04a8\u04af\u04b3\u04b8"+
		"\u04c5\u04c9\u04cd\u04d1\u04d3\u04dd\u04e2\u04e7\u04fe\u0501\u0507\u0514"+
		"\u051c\u051f\u0526\u052a\u052f\u0532\u0538\u053d\u0545\u054a\u0552\u0554"+
		"\u055b\u0562\u0564\u0575\u0579\u0581\u058e\u0594\u0597\u05a1\u05af\u0002"+
		"\u0000\u0001\u0000\u0006\u0000\u0000";
	public static final ATN _ATN =
		new ATNDeserializer().deserialize(_serializedATN.toCharArray());
	static {
		_decisionToDFA = new DFA[_ATN.getNumberOfDecisions()];
		for (int i = 0; i < _ATN.getNumberOfDecisions(); i++) {
			_decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i);
		}
	}
}
```

`src/main/java/com/lauriewired/malimite/decompile/antlr/CPP14Lexer.tokens`:

```tokens
IntegerLiteral=1
CharacterLiteral=2
FloatingLiteral=3
StringLiteral=4
BooleanLiteral=5
PointerLiteral=6
UserDefinedLiteral=7
MultiLineMacro=8
Directive=9
Alignas=10
Alignof=11
Asm=12
Auto=13
Bool=14
Break=15
Case=16
Catch=17
Char=18
Char16=19
Char32=20
Class=21
Const=22
Constexpr=23
Const_cast=24
Continue=25
Decltype=26
Default=27
Delete=28
Do=29
Double=30
Dynamic_cast=31
Else=32
Enum=33
Explicit=34
Export=35
Extern=36
False_=37
Final=38
Float=39
For=40
Friend=41
Goto=42
If=43
Inline=44
Int=45
Long=46
Mutable=47
Namespace=48
New=49
Noexcept=50
Nullptr=51
Operator=52
Override=53
Private=54
Protected=55
Public=56
Register=57
Reinterpret_cast=58
Return=59
Short=60
Signed=61
Sizeof=62
Static=63
Static_assert=64
Static_cast=65
Struct=66
Switch=67
Template=68
This=69
Thread_local=70
Throw=71
True_=72
Try=73
Typedef=74
Typeid_=75
Typename_=76
Union=77
Unsigned=78
Using=79
Virtual=80
Void=81
Volatile=82
Wchar=83
While=84
LeftParen=85
RightParen=86
LeftBracket=87
RightBracket=88
LeftBrace=89
RightBrace=90
Plus=91
Minus=92
Star=93
Div=94
Mod=95
Caret=96
And=97
Or=98
Tilde=99
Not=100
Assign=101
Less=102
Greater=103
PlusAssign=104
MinusAssign=105
StarAssign=106
DivAssign=107
ModAssign=108
XorAssign=109
AndAssign=110
OrAssign=111
LeftShiftAssign=112
RightShiftAssign=113
Equal=114
NotEqual=115
LessEqual=116
GreaterEqual=117
AndAnd=118
OrOr=119
PlusPlus=120
MinusMinus=121
Comma=122
ArrowStar=123
Arrow=124
Question=125
Colon=126
Doublecolon=127
Semi=128
Dot=129
DotStar=130
Ellipsis=131
Identifier=132
DecimalLiteral=133
OctalLiteral=134
HexadecimalLiteral=135
BinaryLiteral=136
Integersuffix=137
UserDefinedIntegerLiteral=138
UserDefinedFloatingLiteral=139
UserDefinedStringLiteral=140
UserDefinedCharacterLiteral=141
Whitespace=142
Newline=143
BlockComment=144
LineComment=145
'alignas'=10
'alignof'=11
'asm'=12
'auto'=13
'bool'=14
'break'=15
'case'=16
'catch'=17
'char'=18
'char16_t'=19
'char32_t'=20
'class'=21
'const'=22
'constexpr'=23
'const_cast'=24
'continue'=25
'decltype'=26
'default'=27
'delete'=28
'do'=29
'double'=30
'dynamic_cast'=31
'else'=32
'enum'=33
'explicit'=34
'export'=35
'extern'=36
'false'=37
'final'=38
'float'=39
'for'=40
'friend'=41
'goto'=42
'if'=43
'inline'=44
'int'=45
'long'=46
'mutable'=47
'namespace'=48
'new'=49
'noexcept'=50
'nullptr'=51
'operator'=52
'override'=53
'private'=54
'protected'=55
'public'=56
'register'=57
'reinterpret_cast'=58
'return'=59
'short'=60
'signed'=61
'sizeof'=62
'static'=63
'static_assert'=64
'static_cast'=65
'struct'=66
'switch'=67
'template'=68
'this'=69
'thread_local'=70
'throw'=71
'true'=72
'try'=73
'typedef'=74
'typeid'=75
'typename'=76
'union'=77
'unsigned'=78
'using'=79
'virtual'=80
'void'=81
'volatile'=82
'wchar_t'=83
'while'=84
'('=85
')'=86
'['=87
']'=88
'{'=89
'}'=90
'+'=91
'-'=92
'*'=93
'/'=94
'%'=95
'^'=96
'&'=97
'|'=98
'~'=99
'='=101
'<'=102
'>'=103
'+='=104
'-='=105
'*='=106
'/='=107
'%='=108
'^='=109
'&='=110
'|='=111
'<<='=112
'>>='=113
'=='=114
'!='=115
'<='=116
'>='=117
'++'=120
'--'=121
','=122
'->*'=123
'->'=124
'?'=125
':'=126
'::'=127
';'=128
'.'=129
'.*'=130
'...'=131

```

`src/main/java/com/lauriewired/malimite/decompile/antlr/CPP14Parser.interp`:

```interp
token literal names:
null
null
null
null
null
null
null
null
null
null
'alignas'
'alignof'
'asm'
'auto'
'bool'
'break'
'case'
'catch'
'char'
'char16_t'
'char32_t'
'class'
'const'
'constexpr'
'const_cast'
'continue'
'decltype'
'default'
'delete'
'do'
'double'
'dynamic_cast'
'else'
'enum'
'explicit'
'export'
'extern'
'false'
'final'
'float'
'for'
'friend'
'goto'
'if'
'inline'
'int'
'long'
'mutable'
'namespace'
'new'
'noexcept'
'nullptr'
'operator'
'override'
'private'
'protected'
'public'
'register'
'reinterpret_cast'
'return'
'short'
'signed'
'sizeof'
'static'
'static_assert'
'static_cast'
'struct'
'switch'
'template'
'this'
'thread_local'
'throw'
'true'
'try'
'typedef'
'typeid'
'typename'
'union'
'unsigned'
'using'
'virtual'
'void'
'volatile'
'wchar_t'
'while'
'('
')'
'['
']'
'{'
'}'
'+'
'-'
'*'
'/'
'%'
'^'
'&'
'|'
'~'
null
'='
'<'
'>'
'+='
'-='
'*='
'/='
'%='
'^='
'&='
'|='
'<<='
'>>='
'=='
'!='
'<='
'>='
null
null
'++'
'--'
','
'->*'
'->'
'?'
':'
'::'
';'
'.'
'.*'
'...'
null
null
null
null
null
null
null
null
null
null
null
null
null
null

token symbolic names:
null
IntegerLiteral
CharacterLiteral
FloatingLiteral
StringLiteral
BooleanLiteral
PointerLiteral
UserDefinedLiteral
MultiLineMacro
Directive
Alignas
Alignof
Asm
Auto
Bool
Break
Case
Catch
Char
Char16
Char32
Class
Const
Constexpr
Const_cast
Continue
Decltype
Default
Delete
Do
Double
Dynamic_cast
Else
Enum
Explicit
Export
Extern
False_
Final
Float
For
Friend
Goto
If
Inline
Int
Long
Mutable
Namespace
New
Noexcept
Nullptr
Operator
Override
Private
Protected
Public
Register
Reinterpret_cast
Return
Short
Signed
Sizeof
Static
Static_assert
Static_cast
Struct
Switch
Template
This
Thread_local
Throw
True_
Try
Typedef
Typeid_
Typename_
Union
Unsigned
Using
Virtual
Void
Volatile
Wchar
While
LeftParen
RightParen
LeftBracket
RightBracket
LeftBrace
RightBrace
Plus
Minus
Star
Div
Mod
Caret
And
Or
Tilde
Not
Assign
Less
Greater
PlusAssign
MinusAssign
StarAssign
DivAssign
ModAssign
XorAssign
AndAssign
OrAssign
LeftShiftAssign
RightShiftAssign
Equal
NotEqual
LessEqual
GreaterEqual
AndAnd
OrOr
PlusPlus
MinusMinus
Comma
ArrowStar
Arrow
Question
Colon
Doublecolon
Semi
Dot
DotStar
Ellipsis
Identifier
DecimalLiteral
OctalLiteral
HexadecimalLiteral
BinaryLiteral
Integersuffix
UserDefinedIntegerLiteral
UserDefinedFloatingLiteral
UserDefinedStringLiteral
UserDefinedCharacterLiteral
Whitespace
Newline
BlockComment
LineComment

rule names:
translationUnit
primaryExpression
idExpression
unqualifiedId
qualifiedId
nestedNameSpecifier
lambdaExpression
lambdaIntroducer
lambdaCapture
captureDefault
captureList
capture
simpleCapture
initcapture
lambdaDeclarator
postfixExpression
typeIdOfTheTypeId
expressionList
pseudoDestructorName
unaryExpression
unaryOperator
newExpression_
newPlacement
newTypeId
newDeclarator_
noPointerNewDeclarator
newInitializer_
deleteExpression
noExceptExpression
castExpression
pointerMemberExpression
multiplicativeExpression
additiveExpression
shiftExpression
shiftOperator
relationalExpression
equalityExpression
andExpression
exclusiveOrExpression
inclusiveOrExpression
logicalAndExpression
logicalOrExpression
conditionalExpression
assignmentExpression
assignmentOperator
expression
constantExpression
statement
labeledStatement
expressionStatement
compoundStatement
statementSeq
selectionStatement
condition
iterationStatement
forInitStatement
forRangeDeclaration
forRangeInitializer
jumpStatement
declarationStatement
declarationseq
declaration
blockDeclaration
aliasDeclaration
simpleDeclaration
staticAssertDeclaration
emptyDeclaration_
attributeDeclaration
declSpecifier
declSpecifierSeq
storageClassSpecifier
functionSpecifier
typedefName
typeSpecifier
trailingTypeSpecifier
typeSpecifierSeq
trailingTypeSpecifierSeq
simpleTypeLengthModifier
simpleTypeSignednessModifier
simpleTypeSpecifier
theTypeName
decltypeSpecifier
elaboratedTypeSpecifier
enumName
enumSpecifier
enumHead
opaqueEnumDeclaration
enumkey
enumbase
enumeratorList
enumeratorDefinition
enumerator
namespaceName
originalNamespaceName
namespaceDefinition
namespaceAlias
namespaceAliasDefinition
qualifiednamespacespecifier
usingDeclaration
usingDirective
asmDefinition
linkageSpecification
attributeSpecifierSeq
attributeSpecifier
alignmentspecifier
attributeList
attribute
attributeNamespace
attributeArgumentClause
balancedTokenSeq
balancedtoken
initDeclaratorList
initDeclarator
declarator
pointerDeclarator
noPointerDeclarator
parametersAndQualifiers
trailingReturnType
pointerOperator
cvqualifierseq
cvQualifier
refqualifier
declaratorid
theTypeId
abstractDeclarator
pointerAbstractDeclarator
noPointerAbstractDeclarator
abstractPackDeclarator
noPointerAbstractPackDeclarator
parameterDeclarationClause
parameterDeclarationList
parameterDeclaration
functionDefinition
functionBody
initializer
braceOrEqualInitializer
initializerClause
initializerList
bracedInitList
className
classSpecifier
classHead
classHeadName
classVirtSpecifier
classKey
memberSpecification
memberdeclaration
memberDeclaratorList
memberDeclarator
virtualSpecifierSeq
virtualSpecifier
pureSpecifier
baseClause
baseSpecifierList
baseSpecifier
classOrDeclType
baseTypeSpecifier
accessSpecifier
conversionFunctionId
conversionTypeId
conversionDeclarator
constructorInitializer
memInitializerList
memInitializer
meminitializerid
operatorFunctionId
literalOperatorId
templateDeclaration
templateparameterList
templateParameter
typeParameter
simpleTemplateId
templateId
templateName
templateArgumentList
templateArgument
typeNameSpecifier
explicitInstantiation
explicitSpecialization
tryBlock
functionTryBlock
handlerSeq
handler
exceptionDeclaration
throwExpression
exceptionSpecification
dynamicExceptionSpecification
typeIdList
noeExceptSpecification
theOperator
literal


atn:
[4, 1, 145, 2062, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7, 99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2, 104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7, 108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2, 113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7, 117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2, 122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7, 126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2, 131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7, 135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2, 140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7, 144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2, 149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7, 153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2, 158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7, 162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2, 167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7, 171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2, 176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7, 180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2, 185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7, 189, 2, 190, 7, 190, 1, 0, 3, 0, 384, 8, 0, 1, 0, 1, 0, 1, 1, 4, 1, 389, 8, 1, 11, 1, 12, 1, 390, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 400, 8, 1, 1, 2, 1, 2, 3, 2, 404, 8, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 413, 8, 3, 1, 3, 3, 3, 416, 8, 3, 1, 4, 1, 4, 3, 4, 420, 8, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 428, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 435, 8, 5, 1, 5, 3, 5, 438, 8, 5, 1, 5, 5, 5, 441, 8, 5, 10, 5, 12, 5, 444, 9, 5, 1, 6, 1, 6, 3, 6, 448, 8, 6, 1, 6, 1, 6, 1, 7, 1, 7, 3, 7, 454, 8, 7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 462, 8, 8, 3, 8, 464, 8, 8, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 5, 10, 471, 8, 10, 10, 10, 12, 10, 474, 9, 10, 1, 10, 3, 10, 477, 8, 10, 1, 11, 1, 11, 3, 11, 481, 8, 11, 1, 12, 3, 12, 484, 8, 12, 1, 12, 1, 12, 3, 12, 488, 8, 12, 1, 13, 3, 13, 491, 8, 13, 1, 13, 1, 13, 1, 13, 1, 14, 1, 14, 3, 14, 498, 8, 14, 1, 14, 1, 14, 3, 14, 502, 8, 14, 1, 14, 3, 14, 505, 8, 14, 1, 14, 3, 14, 508, 8, 14, 1, 14, 3, 14, 511, 8, 14, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 517, 8, 15, 1, 15, 1, 15, 3, 15, 521, 8, 15, 1, 15, 1, 15, 3, 15, 525, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 539, 8, 15, 1, 15, 1, 15, 3, 15, 543, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 549, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 556, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 562, 8, 15, 1, 15, 1, 15, 3, 15, 566, 8, 15, 1, 15, 1, 15, 5, 15, 570, 8, 15, 10, 15, 12, 15, 573, 9, 15, 1, 16, 1, 16, 1, 17, 1, 17, 1, 18, 3, 18, 580, 8, 18, 1, 18, 1, 18, 1, 18, 3, 18, 585, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 598, 8, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 605, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 617, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 627, 8, 19, 1, 20, 1, 20, 1, 21, 3, 21, 632, 8, 21, 1, 21, 1, 21, 3, 21, 636, 8, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 643, 8, 21, 1, 21, 3, 21, 646, 8, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 3, 23, 654, 8, 23, 1, 24, 1, 24, 3, 24, 658, 8, 24, 1, 24, 3, 24, 661, 8, 24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 668, 8, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 675, 8, 25, 5, 25, 677, 8, 25, 10, 25, 12, 25, 680, 9, 25, 1, 26, 1, 26, 3, 26, 684, 8, 26, 1, 26, 1, 26, 3, 26, 688, 8, 26, 1, 27, 3, 27, 691, 8, 27, 1, 27, 1, 27, 1, 27, 3, 27, 696, 8, 27, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 711, 8, 29, 1, 30, 1, 30, 1, 30, 5, 30, 716, 8, 30, 10, 30, 12, 30, 719, 9, 30, 1, 31, 1, 31, 1, 31, 5, 31, 724, 8, 31, 10, 31, 12, 31, 727, 9, 31, 1, 32, 1, 32, 1, 32, 5, 32, 732, 8, 32, 10, 32, 12, 32, 735, 9, 32, 1, 33, 1, 33, 1, 33, 1, 33, 5, 33, 741, 8, 33, 10, 33, 12, 33, 744, 9, 33, 1, 34, 1, 34, 1, 34, 1, 34, 3, 34, 750, 8, 34, 1, 35, 1, 35, 1, 35, 5, 35, 755, 8, 35, 10, 35, 12, 35, 758, 9, 35, 1, 36, 1, 36, 1, 36, 5, 36, 763, 8, 36, 10, 36, 12, 36, 766, 9, 36, 1, 37, 1, 37, 1, 37, 5, 37, 771, 8, 37, 10, 37, 12, 37, 774, 9, 37, 1, 38, 1, 38, 1, 38, 5, 38, 779, 8, 38, 10, 38, 12, 38, 782, 9, 38, 1, 39, 1, 39, 1, 39, 5, 39, 787, 8, 39, 10, 39, 12, 39, 790, 9, 39, 1, 40, 1, 40, 1, 40, 5, 40, 795, 8, 40, 10, 40, 12, 40, 798, 9, 40, 1, 41, 1, 41, 1, 41, 5, 41, 803, 8, 41, 10, 41, 12, 41, 806, 9, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 814, 8, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 822, 8, 43, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 5, 45, 829, 8, 45, 10, 45, 12, 45, 832, 9, 45, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 3, 47, 839, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 847, 8, 47, 3, 47, 849, 8, 47, 1, 48, 3, 48, 852, 8, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 858, 8, 48, 1, 48, 1, 48, 1, 48, 1, 49, 3, 49, 864, 8, 49, 1, 49, 1, 49, 1, 50, 1, 50, 3, 50, 870, 8, 50, 1, 50, 1, 50, 1, 51, 4, 51, 875, 8, 51, 11, 51, 12, 51, 876, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 886, 8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 894, 8, 52, 1, 53, 1, 53, 3, 53, 898, 8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 905, 8, 53, 3, 53, 907, 8, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 927, 8, 54, 1, 54, 1, 54, 3, 54, 931, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 937, 8, 54, 1, 54, 1, 54, 1, 54, 3, 54, 942, 8, 54, 1, 55, 1, 55, 3, 55, 946, 8, 55, 1, 56, 3, 56, 949, 8, 56, 1, 56, 1, 56, 1, 56, 1, 57, 1, 57, 3, 57, 956, 8, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 963, 8, 58, 1, 58, 1, 58, 3, 58, 967, 8, 58, 1, 58, 1, 58, 1, 59, 1, 59, 1, 60, 4, 60, 974, 8, 60, 11, 60, 12, 60, 975, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 987, 8, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62, 997, 8, 62, 1, 63, 1, 63, 1, 63, 3, 63, 1002, 8, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 64, 3, 64, 1009, 8, 64, 1, 64, 3, 64, 1012, 8, 64, 1, 64, 1, 64, 1, 64, 3, 64, 1017, 8, 64, 1, 64, 1, 64, 1, 64, 3, 64, 1022, 8, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1, 67, 1, 67, 1, 67, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 1043, 8, 68, 1, 69, 4, 69, 1046, 8, 69, 11, 69, 12, 69, 1047, 1, 69, 3, 69, 1051, 8, 69, 1, 70, 1, 70, 1, 71, 1, 71, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 3, 73, 1062, 8, 73, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 1068, 8, 74, 1, 75, 4, 75, 1071, 8, 75, 11, 75, 12, 75, 1072, 1, 75, 3, 75, 1076, 8, 75, 1, 76, 4, 76, 1079, 8, 76, 11, 76, 12, 76, 1080, 1, 76, 3, 76, 1084, 8, 76, 1, 77, 1, 77, 1, 78, 1, 78, 1, 79, 3, 79, 1091, 8, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 1114, 8, 79, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80, 1120, 8, 80, 1, 81, 1, 81, 1, 81, 1, 81, 3, 81, 1126, 8, 81, 1, 81, 1, 81, 1, 82, 1, 82, 3, 82, 1132, 8, 82, 1, 82, 3, 82, 1135, 8, 82, 1, 82, 1, 82, 1, 82, 1, 82, 3, 82, 1141, 8, 82, 1, 82, 1, 82, 3, 82, 1145, 8, 82, 1, 82, 1, 82, 3, 82, 1149, 8, 82, 1, 82, 3, 82, 1152, 8, 82, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 1160, 8, 84, 3, 84, 1162, 8, 84, 1, 84, 1, 84, 1, 85, 1, 85, 3, 85, 1168, 8, 85, 1, 85, 3, 85, 1171, 8, 85, 1, 85, 3, 85, 1174, 8, 85, 1, 85, 3, 85, 1177, 8, 85, 1, 86, 1, 86, 3, 86, 1181, 8, 86, 1, 86, 1, 86, 3, 86, 1185, 8, 86, 1, 86, 1, 86, 1, 87, 1, 87, 3, 87, 1191, 8, 87, 1, 88, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89, 5, 89, 1199, 8, 89, 10, 89, 12, 89, 1202, 9, 89, 1, 90, 1, 90, 1, 90, 3, 90, 1207, 8, 90, 1, 91, 1, 91, 1, 92, 1, 92, 3, 92, 1213, 8, 92, 1, 93, 1, 93, 1, 94, 3, 94, 1218, 8, 94, 1, 94, 1, 94, 1, 94, 3, 94, 1223, 8, 94, 1, 94, 1, 94, 3, 94, 1227, 8, 94, 1, 94, 1, 94, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 97, 3, 97, 1240, 8, 97, 1, 97, 1, 97, 1, 98, 1, 98, 3, 98, 1246, 8, 98, 1, 98, 1, 98, 3, 98, 1250, 8, 98, 1, 98, 1, 98, 1, 98, 1, 99, 3, 99, 1256, 8, 99, 1, 99, 1, 99, 1, 99, 3, 99, 1261, 8, 99, 1, 99, 1, 99, 1, 99, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 101, 1, 101, 1, 101, 1, 101, 3, 101, 1276, 8, 101, 1, 101, 1, 101, 3, 101, 1280, 8, 101, 1, 102, 4, 102, 1283, 8, 102, 11, 102, 12, 102, 1284, 1, 103, 1, 103, 1, 103, 3, 103, 1290, 8, 103, 1, 103, 1, 103, 1, 103, 3, 103, 1295, 8, 103, 1, 104, 1, 104, 1, 104, 1, 104, 3, 104, 1301, 8, 104, 1, 104, 3, 104, 1304, 8, 104, 1, 104, 1, 104, 1, 105, 1, 105, 1, 105, 5, 105, 1311, 8, 105, 10, 105, 12, 105, 1314, 9, 105, 1, 105, 3, 105, 1317, 8, 105, 1, 106, 1, 106, 1, 106, 3, 106, 1322, 8, 106, 1, 106, 1, 106, 3, 106, 1326, 8, 106, 1, 107, 1, 107, 1, 108, 1, 108, 3, 108, 1332, 8, 108, 1, 108, 1, 108, 1, 109, 4, 109, 1337, 8, 109, 11, 109, 12, 109, 1338, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 4, 110, 1354, 8, 110, 11, 110, 12, 110, 1355, 3, 110, 1358, 8, 110, 1, 111, 1, 111, 1, 111, 5, 111, 1363, 8, 111, 10, 111, 12, 111, 1366, 9, 111, 1, 112, 1, 112, 3, 112, 1370, 8, 112, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 3, 113, 1377, 8, 113, 1, 114, 1, 114, 3, 114, 1381, 8, 114, 5, 114, 1383, 8, 114, 10, 114, 12, 114, 1386, 9, 114, 1, 114, 1, 114, 1, 115, 1, 115, 1, 115, 3, 115, 1393, 8, 115, 1, 115, 1, 115, 1, 115, 1, 115, 3, 115, 1399, 8, 115, 1, 115, 1, 115, 1, 115, 1, 115, 3, 115, 1405, 8, 115, 1, 115, 1, 115, 3, 115, 1409, 8, 115, 3, 115, 1411, 8, 115, 5, 115, 1413, 8, 115, 10, 115, 12, 115, 1416, 9, 115, 1, 116, 1, 116, 3, 116, 1420, 8, 116, 1, 116, 1, 116, 3, 116, 1424, 8, 116, 1, 116, 3, 116, 1427, 8, 116, 1, 116, 3, 116, 1430, 8, 116, 1, 116, 3, 116, 1433, 8, 116, 1, 117, 1, 117, 1, 117, 3, 117, 1438, 8, 117, 1, 118, 1, 118, 3, 118, 1442, 8, 118, 1, 118, 3, 118, 1445, 8, 118, 1, 118, 1, 118, 3, 118, 1449, 8, 118, 1, 118, 3, 118, 1452, 8, 118, 3, 118, 1454, 8, 118, 1, 119, 4, 119, 1457, 8, 119, 11, 119, 12, 119, 1458, 1, 120, 1, 120, 1, 121, 1, 121, 1, 122, 3, 122, 1466, 8, 122, 1, 122, 1, 122, 1, 123, 1, 123, 3, 123, 1472, 8, 123, 1, 124, 1, 124, 3, 124, 1476, 8, 124, 1, 124, 1, 124, 1, 124, 1, 124, 3, 124, 1482, 8, 124, 1, 125, 5, 125, 1485, 8, 125, 10, 125, 12, 125, 1488, 9, 125, 1, 125, 1, 125, 3, 125, 1492, 8, 125, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 3, 126, 1499, 8, 126, 1, 126, 1, 126, 1, 126, 3, 126, 1504, 8, 126, 1, 126, 1, 126, 3, 126, 1508, 8, 126, 5, 126, 1510, 8, 126, 10, 126, 12, 126, 1513, 9, 126, 1, 127, 5, 127, 1516, 8, 127, 10, 127, 12, 127, 1519, 9, 127, 1, 127, 1, 127, 1, 128, 1, 128, 1, 128, 1, 128, 3, 128, 1527, 8, 128, 1, 128, 1, 128, 3, 128, 1531, 8, 128, 5, 128, 1533, 8, 128, 10, 128, 12, 128, 1536, 9, 128, 1, 129, 1, 129, 3, 129, 1540, 8, 129, 1, 129, 3, 129, 1543, 8, 129, 1, 130, 1, 130, 1, 130, 5, 130, 1548, 8, 130, 10, 130, 12, 130, 1551, 9, 130, 1, 131, 3, 131, 1554, 8, 131, 1, 131, 1, 131, 1, 131, 3, 131, 1559, 8, 131, 3, 131, 1561, 8, 131, 1, 131, 1, 131, 3, 131, 1565, 8, 131, 1, 132, 3, 132, 1568, 8, 132, 1, 132, 3, 132, 1571, 8, 132, 1, 132, 1, 132, 3, 132, 1575, 8, 132, 1, 132, 1, 132, 1, 133, 3, 133, 1580, 8, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 3, 133, 1587, 8, 133, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 3, 134, 1594, 8, 134, 1, 135, 1, 135, 1, 135, 3, 135, 1599, 8, 135, 1, 136, 1, 136, 3, 136, 1603, 8, 136, 1, 137, 1, 137, 3, 137, 1607, 8, 137, 1, 137, 1, 137, 1, 137, 3, 137, 1612, 8, 137, 5, 137, 1614, 8, 137, 10, 137, 12, 137, 1617, 9, 137, 1, 138, 1, 138, 1, 138, 3, 138, 1622, 8, 138, 3, 138, 1624, 8, 138, 1, 138, 1, 138, 1, 139, 1, 139, 3, 139, 1630, 8, 139, 1, 140, 1, 140, 1, 140, 3, 140, 1635, 8, 140, 1, 140, 1, 140, 1, 141, 1, 141, 3, 141, 1641, 8, 141, 1, 141, 1, 141, 3, 141, 1645, 8, 141, 3, 141, 1647, 8, 141, 1, 141, 3, 141, 1650, 8, 141, 1, 141, 1, 141, 3, 141, 1654, 8, 141, 1, 141, 1, 141, 3, 141, 1658, 8, 141, 3, 141, 1660, 8, 141, 3, 141, 1662, 8, 141, 1, 142, 3, 142, 1665, 8, 142, 1, 142, 1, 142, 1, 143, 1, 143, 1, 144, 1, 144, 1, 145, 1, 145, 1, 145, 1, 145, 4, 145, 1677, 8, 145, 11, 145, 12, 145, 1678, 1, 146, 3, 146, 1682, 8, 146, 1, 146, 3, 146, 1685, 8, 146, 1, 146, 3, 146, 1688, 8, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 3, 146, 1697, 8, 146, 1, 147, 1, 147, 1, 147, 5, 147, 1702, 8, 147, 10, 147, 12, 147, 1705, 9, 147, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 3, 148, 1716, 8, 148, 1, 148, 1, 148, 3, 148, 1720, 8, 148, 1, 148, 3, 148, 1723, 8, 148, 1, 148, 1, 148, 3, 148, 1727, 8, 148, 1, 149, 4, 149, 1730, 8, 149, 11, 149, 12, 149, 1731, 1, 150, 1, 150, 1, 151, 1, 151, 1, 151, 1, 152, 1, 152, 1, 152, 1, 153, 1, 153, 3, 153, 1744, 8, 153, 1, 153, 1, 153, 1, 153, 3, 153, 1749, 8, 153, 5, 153, 1751, 8, 153, 10, 153, 12, 153, 1754, 9, 153, 1, 154, 3, 154, 1757, 8, 154, 1, 154, 1, 154, 1, 154, 3, 154, 1762, 8, 154, 1, 154, 1, 154, 1, 154, 3, 154, 1767, 8, 154, 1, 154, 1, 154, 3, 154, 1771, 8, 154, 1, 155, 3, 155, 1774, 8, 155, 1, 155, 1, 155, 3, 155, 1778, 8, 155, 1, 156, 1, 156, 1, 157, 1, 157, 1, 158, 1, 158, 1, 158, 1, 159, 1, 159, 3, 159, 1789, 8, 159, 1, 160, 1, 160, 3, 160, 1793, 8, 160, 1, 161, 1, 161, 1, 161, 1, 162, 1, 162, 3, 162, 1800, 8, 162, 1, 162, 1, 162, 1, 162, 3, 162, 1805, 8, 162, 5, 162, 1807, 8, 162, 10, 162, 12, 162, 1810, 9, 162, 1, 163, 1, 163, 1, 163, 3, 163, 1815, 8, 163, 1, 163, 1, 163, 3, 163, 1819, 8, 163, 1, 164, 1, 164, 3, 164, 1823, 8, 164, 1, 165, 1, 165, 1, 165, 1, 166, 1, 166, 1, 166, 1, 166, 3, 166, 1832, 8, 166, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 168, 1, 168, 1, 168, 5, 168, 1843, 8, 168, 10, 168, 12, 168, 1846, 9, 168, 1, 169, 1, 169, 3, 169, 1850, 8, 169, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 3, 170, 1857, 8, 170, 1, 170, 1, 170, 3, 170, 1861, 8, 170, 1, 170, 3, 170, 1864, 8, 170, 1, 170, 3, 170, 1867, 8, 170, 1, 170, 3, 170, 1870, 8, 170, 1, 170, 1, 170, 3, 170, 1874, 8, 170, 1, 171, 1, 171, 1, 171, 3, 171, 1879, 8, 171, 1, 171, 1, 171, 1, 172, 1, 172, 1, 172, 3, 172, 1886, 8, 172, 1, 172, 1, 172, 3, 172, 1890, 8, 172, 1, 172, 1, 172, 3, 172, 1894, 8, 172, 1, 173, 1, 173, 1, 174, 1, 174, 3, 174, 1900, 8, 174, 1, 174, 1, 174, 1, 174, 3, 174, 1905, 8, 174, 5, 174, 1907, 8, 174, 10, 174, 12, 174, 1910, 9, 174, 1, 175, 1, 175, 1, 175, 3, 175, 1915, 8, 175, 1, 176, 1, 176, 1, 176, 1, 176, 3, 176, 1921, 8, 176, 1, 176, 3, 176, 1924, 8, 176, 1, 177, 3, 177, 1927, 8, 177, 1, 177, 1, 177, 1, 177, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 179, 1, 179, 1, 179, 1, 179, 1, 180, 1, 180, 3, 180, 1943, 8, 180, 1, 180, 1, 180, 1, 180, 1, 181, 4, 181, 1949, 8, 181, 11, 181, 12, 181, 1950, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 183, 3, 183, 1960, 8, 183, 1, 183, 1, 183, 1, 183, 3, 183, 1965, 8, 183, 1, 183, 3, 183, 1968, 8, 183, 1, 184, 1, 184, 3, 184, 1972, 8, 184, 1, 185, 1, 185, 3, 185, 1976, 8, 185, 1, 186, 1, 186, 1, 186, 3, 186, 1981, 8, 186, 1, 186, 1, 186, 1, 187, 1, 187, 3, 187, 1987, 8, 187, 1, 187, 1, 187, 1, 187, 3, 187, 1992, 8, 187, 5, 187, 1994, 8, 187, 10, 187, 12, 187, 1997, 9, 187, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 3, 188, 2005, 8, 188, 1, 189, 1, 189, 1, 189, 3, 189, 2010, 8, 189, 1, 189, 1, 189, 1, 189, 3, 189, 2015, 8, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 3, 189, 2058, 8, 189, 1, 190, 1, 190, 1, 190, 1, 1047, 4, 10, 30, 50, 230, 191, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 0, 23, 2, 0, 97, 97, 101, 101, 4, 0, 24, 24, 31, 31, 58, 58, 65, 65, 2, 0, 124, 124, 129, 129, 1, 0, 120, 121, 2, 0, 91, 93, 97, 100, 2, 0, 123, 123, 130, 130, 1, 0, 93, 95, 1, 0, 91, 92, 2, 0, 102, 103, 116, 117, 1, 0, 114, 115, 2, 0, 101, 101, 104, 113, 5, 0, 36, 36, 47, 47, 57, 57, 63, 63, 70, 70, 3, 0, 34, 34, 44, 44, 80, 80, 2, 0, 46, 46, 60, 60, 2, 0, 61, 61, 78, 78, 2, 0, 21, 21, 66, 66, 1, 0, 85, 90, 2, 0, 97, 97, 118, 118, 2, 0, 22, 22, 82, 82, 1, 0, 27, 28, 2, 0, 38, 38, 53, 53, 1, 0, 54, 56, 1, 0, 1, 7, 2285, 0, 383, 1, 0, 0, 0, 2, 399, 1, 0, 0, 0, 4, 403, 1, 0, 0, 0, 6, 415, 1, 0, 0, 0, 8, 417, 1, 0, 0, 0, 10, 423, 1, 0, 0, 0, 12, 445, 1, 0, 0, 0, 14, 451, 1, 0, 0, 0, 16, 463, 1, 0, 0, 0, 18, 465, 1, 0, 0, 0, 20, 467, 1, 0, 0, 0, 22, 480, 1, 0, 0, 0, 24, 487, 1, 0, 0, 0, 26, 490, 1, 0, 0, 0, 28, 495, 1, 0, 0, 0, 30, 542, 1, 0, 0, 0, 32, 574, 1, 0, 0, 0, 34, 576, 1, 0, 0, 0, 36, 597, 1, 0, 0, 0, 38, 626, 1, 0, 0, 0, 40, 628, 1, 0, 0, 0, 42, 631, 1, 0, 0, 0, 44, 647, 1, 0, 0, 0, 46, 651, 1, 0, 0, 0, 48, 660, 1, 0, 0, 0, 50, 662, 1, 0, 0, 0, 52, 687, 1, 0, 0, 0, 54, 690, 1, 0, 0, 0, 56, 699, 1, 0, 0, 0, 58, 710, 1, 0, 0, 0, 60, 712, 1, 0, 0, 0, 62, 720, 1, 0, 0, 0, 64, 728, 1, 0, 0, 0, 66, 736, 1, 0, 0, 0, 68, 749, 1, 0, 0, 0, 70, 751, 1, 0, 0, 0, 72, 759, 1, 0, 0, 0, 74, 767, 1, 0, 0, 0, 76, 775, 1, 0, 0, 0, 78, 783, 1, 0, 0, 0, 80, 791, 1, 0, 0, 0, 82, 799, 1, 0, 0, 0, 84, 807, 1, 0, 0, 0, 86, 821, 1, 0, 0, 0, 88, 823, 1, 0, 0, 0, 90, 825, 1, 0, 0, 0, 92, 833, 1, 0, 0, 0, 94, 848, 1, 0, 0, 0, 96, 851, 1, 0, 0, 0, 98, 863, 1, 0, 0, 0, 100, 867, 1, 0, 0, 0, 102, 874, 1, 0, 0, 0, 104, 893, 1, 0, 0, 0, 106, 906, 1, 0, 0, 0, 108, 941, 1, 0, 0, 0, 110, 945, 1, 0, 0, 0, 112, 948, 1, 0, 0, 0, 114, 955, 1, 0, 0, 0, 116, 966, 1, 0, 0, 0, 118, 970, 1, 0, 0, 0, 120, 973, 1, 0, 0, 0, 122, 986, 1, 0, 0, 0, 124, 996, 1, 0, 0, 0, 126, 998, 1, 0, 0, 0, 128, 1021, 1, 0, 0, 0, 130, 1023, 1, 0, 0, 0, 132, 1031, 1, 0, 0, 0, 134, 1033, 1, 0, 0, 0, 136, 1042, 1, 0, 0, 0, 138, 1045, 1, 0, 0, 0, 140, 1052, 1, 0, 0, 0, 142, 1054, 1, 0, 0, 0, 144, 1056, 1, 0, 0, 0, 146, 1061, 1, 0, 0, 0, 148, 1067, 1, 0, 0, 0, 150, 1070, 1, 0, 0, 0, 152, 1078, 1, 0, 0, 0, 154, 1085, 1, 0, 0, 0, 156, 1087, 1, 0, 0, 0, 158, 1113, 1, 0, 0, 0, 160, 1119, 1, 0, 0, 0, 162, 1121, 1, 0, 0, 0, 164, 1151, 1, 0, 0, 0, 166, 1153, 1, 0, 0, 0, 168, 1155, 1, 0, 0, 0, 170, 1165, 1, 0, 0, 0, 172, 1178, 1, 0, 0, 0, 174, 1188, 1, 0, 0, 0, 176, 1192, 1, 0, 0, 0, 178, 1195, 1, 0, 0, 0, 180, 1203, 1, 0, 0, 0, 182, 1208, 1, 0, 0, 0, 184, 1212, 1, 0, 0, 0, 186, 1214, 1, 0, 0, 0, 188, 1217, 1, 0, 0, 0, 190, 1230, 1, 0, 0, 0, 192, 1232, 1, 0, 0, 0, 194, 1239, 1, 0, 0, 0, 196, 1243, 1, 0, 0, 0, 198, 1255, 1, 0, 0, 0, 200, 1265, 1, 0, 0, 0, 202, 1271, 1, 0, 0, 0, 204, 1282, 1, 0, 0, 0, 206, 1294, 1, 0, 0, 0, 208, 1296, 1, 0, 0, 0, 210, 1307, 1, 0, 0, 0, 212, 1321, 1, 0, 0, 0, 214, 1327, 1, 0, 0, 0, 216, 1329, 1, 0, 0, 0, 218, 1336, 1, 0, 0, 0, 220, 1357, 1, 0, 0, 0, 222, 1359, 1, 0, 0, 0, 224, 1367, 1, 0, 0, 0, 226, 1376, 1, 0, 0, 0, 228, 1384, 1, 0, 0, 0, 230, 1398, 1, 0, 0, 0, 232, 1417, 1, 0, 0, 0, 234, 1434, 1, 0, 0, 0, 236, 1453, 1, 0, 0, 0, 238, 1456, 1, 0, 0, 0, 240, 1460, 1, 0, 0, 0, 242, 1462, 1, 0, 0, 0, 244, 1465, 1, 0, 0, 0, 246, 1469, 1, 0, 0, 0, 248, 1481, 1, 0, 0, 0, 250, 1486, 1, 0, 0, 0, 252, 1498, 1, 0, 0, 0, 254, 1517, 1, 0, 0, 0, 256, 1522, 1, 0, 0, 0, 258, 1537, 1, 0, 0, 0, 260, 1544, 1, 0, 0, 0, 262, 1553, 1, 0, 0, 0, 264, 1567, 1, 0, 0, 0, 266, 1586, 1, 0, 0, 0, 268, 1593, 1, 0, 0, 0, 270, 1598, 1, 0, 0, 0, 272, 1602, 1, 0, 0, 0, 274, 1604, 1, 0, 0, 0, 276, 1618, 1, 0, 0, 0, 278, 1629, 1, 0, 0, 0, 280, 1631, 1, 0, 0, 0, 282, 1661, 1, 0, 0, 0, 284, 1664, 1, 0, 0, 0, 286, 1668, 1, 0, 0, 0, 288, 1670, 1, 0, 0, 0, 290, 1676, 1, 0, 0, 0, 292, 1696, 1, 0, 0, 0, 294, 1698, 1, 0, 0, 0, 296, 1726, 1, 0, 0, 0, 298, 1729, 1, 0, 0, 0, 300, 1733, 1, 0, 0, 0, 302, 1735, 1, 0, 0, 0, 304, 1738, 1, 0, 0, 0, 306, 1741, 1, 0, 0, 0, 308, 1756, 1, 0, 0, 0, 310, 1777, 1, 0, 0, 0, 312, 1779, 1, 0, 0, 0, 314, 1781, 1, 0, 0, 0, 316, 1783, 1, 0, 0, 0, 318, 1786, 1, 0, 0, 0, 320, 1790, 1, 0, 0, 0, 322, 1794, 1, 0, 0, 0, 324, 1797, 1, 0, 0, 0, 326, 1811, 1, 0, 0, 0, 328, 1822, 1, 0, 0, 0, 330, 1824, 1, 0, 0, 0, 332, 1827, 1, 0, 0, 0, 334, 1833, 1, 0, 0, 0, 336, 1839, 1, 0, 0, 0, 338, 1849, 1, 0, 0, 0, 340, 1860, 1, 0, 0, 0, 342, 1875, 1, 0, 0, 0, 344, 1893, 1, 0, 0, 0, 346, 1895, 1, 0, 0, 0, 348, 1897, 1, 0, 0, 0, 350, 1914, 1, 0, 0, 0, 352, 1916, 1, 0, 0, 0, 354, 1926, 1, 0, 0, 0, 356, 1931, 1, 0, 0, 0, 358, 1936, 1, 0, 0, 0, 360, 1940, 1, 0, 0, 0, 362, 1948, 1, 0, 0, 0, 364, 1952, 1, 0, 0, 0, 366, 1967, 1, 0, 0, 0, 368, 1969, 1, 0, 0, 0, 370, 1975, 1, 0, 0, 0, 372, 1977, 1, 0, 0, 0, 374, 1984, 1, 0, 0, 0, 376, 2004, 1, 0, 0, 0, 378, 2057, 1, 0, 0, 0, 380, 2059, 1, 0, 0, 0, 382, 384, 3, 120, 60, 0, 383, 382, 1, 0, 0, 0, 383, 384, 1, 0, 0, 0, 384, 385, 1, 0, 0, 0, 385, 386, 5, 0, 0, 1, 386, 1, 1, 0, 0, 0, 387, 389, 3, 380, 190, 0, 388, 387, 1, 0, 0, 0, 389, 390, 1, 0, 0, 0, 390, 388, 1, 0, 0, 0, 390, 391, 1, 0, 0, 0, 391, 400, 1, 0, 0, 0, 392, 400, 5, 69, 0, 0, 393, 394, 5, 85, 0, 0, 394, 395, 3, 90, 45, 0, 395, 396, 5, 86, 0, 0, 396, 400, 1, 0, 0, 0, 397, 400, 3, 4, 2, 0, 398, 400, 3, 12, 6, 0, 399, 388, 1, 0, 0, 0, 399, 392, 1, 0, 0, 0, 399, 393, 1, 0, 0, 0, 399, 397, 1, 0, 0, 0, 399, 398, 1, 0, 0, 0, 400, 3, 1, 0, 0, 0, 401, 404, 3, 6, 3, 0, 402, 404, 3, 8, 4, 0, 403, 401, 1, 0, 0, 0, 403, 402, 1, 0, 0, 0, 404, 5, 1, 0, 0, 0, 405, 416, 5, 132, 0, 0, 406, 416, 3, 330, 165, 0, 407, 416, 3, 316, 158, 0, 408, 416, 3, 332, 166, 0, 409, 412, 5, 99, 0, 0, 410, 413, 3, 278, 139, 0, 411, 413, 3, 162, 81, 0, 412, 410, 1, 0, 0, 0, 412, 411, 1, 0, 0, 0, 413, 416, 1, 0, 0, 0, 414, 416, 3, 344, 172, 0, 415, 405, 1, 0, 0, 0, 415, 406, 1, 0, 0, 0, 415, 407, 1, 0, 0, 0, 415, 408, 1, 0, 0, 0, 415, 409, 1, 0, 0, 0, 415, 414, 1, 0, 0, 0, 416, 7, 1, 0, 0, 0, 417, 419, 3, 10, 5, 0, 418, 420, 5, 68, 0, 0, 419, 418, 1, 0, 0, 0, 419, 420, 1, 0, 0, 0, 420, 421, 1, 0, 0, 0, 421, 422, 3, 6, 3, 0, 422, 9, 1, 0, 0, 0, 423, 427, 6, 5, -1, 0, 424, 428, 3, 160, 80, 0, 425, 428, 3, 184, 92, 0, 426, 428, 3, 162, 81, 0, 427, 424, 1, 0, 0, 0, 427, 425, 1, 0, 0, 0, 427, 426, 1, 0, 0, 0, 427, 428, 1, 0, 0, 0, 428, 429, 1, 0, 0, 0, 429, 430, 5, 127, 0, 0, 430, 442, 1, 0, 0, 0, 431, 437, 10, 1, 0, 0, 432, 438, 5, 132, 0, 0, 433, 435, 5, 68, 0, 0, 434, 433, 1, 0, 0, 0, 434, 435, 1, 0, 0, 0, 435, 436, 1, 0, 0, 0, 436, 438, 3, 342, 171, 0, 437, 432, 1, 0, 0, 0, 437, 434, 1, 0, 0, 0, 438, 439, 1, 0, 0, 0, 439, 441, 5, 127, 0, 0, 440, 431, 1, 0, 0, 0, 441, 444, 1, 0, 0, 0, 442, 440, 1, 0, 0, 0, 442, 443, 1, 0, 0, 0, 443, 11, 1, 0, 0, 0, 444, 442, 1, 0, 0, 0, 445, 447, 3, 14, 7, 0, 446, 448, 3, 28, 14, 0, 447, 446, 1, 0, 0, 0, 447, 448, 1, 0, 0, 0, 448, 449, 1, 0, 0, 0, 449, 450, 3, 100, 50, 0, 450, 13, 1, 0, 0, 0, 451, 453, 5, 87, 0, 0, 452, 454, 3, 16, 8, 0, 453, 452, 1, 0, 0, 0, 453, 454, 1, 0, 0, 0, 454, 455, 1, 0, 0, 0, 455, 456, 5, 88, 0, 0, 456, 15, 1, 0, 0, 0, 457, 464, 3, 20, 10, 0, 458, 461, 3, 18, 9, 0, 459, 460, 5, 122, 0, 0, 460, 462, 3, 20, 10, 0, 461, 459, 1, 0, 0, 0, 461, 462, 1, 0, 0, 0, 462, 464, 1, 0, 0, 0, 463, 457, 1, 0, 0, 0, 463, 458, 1, 0, 0, 0, 464, 17, 1, 0, 0, 0, 465, 466, 7, 0, 0, 0, 466, 19, 1, 0, 0, 0, 467, 472, 3, 22, 11, 0, 468, 469, 5, 122, 0, 0, 469, 471, 3, 22, 11, 0, 470, 468, 1, 0, 0, 0, 471, 474, 1, 0, 0, 0, 472, 470, 1, 0, 0, 0, 472, 473, 1, 0, 0, 0, 473, 476, 1, 0, 0, 0, 474, 472, 1, 0, 0, 0, 475, 477, 5, 131, 0, 0, 476, 475, 1, 0, 0, 0, 476, 477, 1, 0, 0, 0, 477, 21, 1, 0, 0, 0, 478, 481, 3, 24, 12, 0, 479, 481, 3, 26, 13, 0, 480, 478, 1, 0, 0, 0, 480, 479, 1, 0, 0, 0, 481, 23, 1, 0, 0, 0, 482, 484, 5, 97, 0, 0, 483, 482, 1, 0, 0, 0, 483, 484, 1, 0, 0, 0, 484, 485, 1, 0, 0, 0, 485, 488, 5, 132, 0, 0, 486, 488, 5, 69, 0, 0, 487, 483, 1, 0, 0, 0, 487, 486, 1, 0, 0, 0, 488, 25, 1, 0, 0, 0, 489, 491, 5, 97, 0, 0, 490, 489, 1, 0, 0, 0, 490, 491, 1, 0, 0, 0, 491, 492, 1, 0, 0, 0, 492, 493, 5, 132, 0, 0, 493, 494, 3, 268, 134, 0, 494, 27, 1, 0, 0, 0, 495, 497, 5, 85, 0, 0, 496, 498, 3, 258, 129, 0, 497, 496, 1, 0, 0, 0, 497, 498, 1, 0, 0, 0, 498, 499, 1, 0, 0, 0, 499, 501, 5, 86, 0, 0, 500, 502, 5, 47, 0, 0, 501, 500, 1, 0, 0, 0, 501, 502, 1, 0, 0, 0, 502, 504, 1, 0, 0, 0, 503, 505, 3, 370, 185, 0, 504, 503, 1, 0, 0, 0, 504, 505, 1, 0, 0, 0, 505, 507, 1, 0, 0, 0, 506, 508, 3, 204, 102, 0, 507, 506, 1, 0, 0, 0, 507, 508, 1, 0, 0, 0, 508, 510, 1, 0, 0, 0, 509, 511, 3, 234, 117, 0, 510, 509, 1, 0, 0, 0, 510, 511, 1, 0, 0, 0, 511, 29, 1, 0, 0, 0, 512, 513, 6, 15, -1, 0, 513, 543, 3, 2, 1, 0, 514, 517, 3, 158, 79, 0, 515, 517, 3, 352, 176, 0, 516, 514, 1, 0, 0, 0, 516, 515, 1, 0, 0, 0, 517, 524, 1, 0, 0, 0, 518, 520, 5, 85, 0, 0, 519, 521, 3, 34, 17, 0, 520, 519, 1, 0, 0, 0, 520, 521, 1, 0, 0, 0, 521, 522, 1, 0, 0, 0, 522, 525, 5, 86, 0, 0, 523, 525, 3, 276, 138, 0, 524, 518, 1, 0, 0, 0, 524, 523, 1, 0, 0, 0, 525, 543, 1, 0, 0, 0, 526, 527, 7, 1, 0, 0, 527, 528, 5, 102, 0, 0, 528, 529, 3, 246, 123, 0, 529, 530, 5, 103, 0, 0, 530, 531, 5, 85, 0, 0, 531, 532, 3, 90, 45, 0, 532, 533, 5, 86, 0, 0, 533, 543, 1, 0, 0, 0, 534, 535, 3, 32, 16, 0, 535, 538, 5, 85, 0, 0, 536, 539, 3, 90, 45, 0, 537, 539, 3, 246, 123, 0, 538, 536, 1, 0, 0, 0, 538, 537, 1, 0, 0, 0, 539, 540, 1, 0, 0, 0, 540, 541, 5, 86, 0, 0, 541, 543, 1, 0, 0, 0, 542, 512, 1, 0, 0, 0, 542, 516, 1, 0, 0, 0, 542, 526, 1, 0, 0, 0, 542, 534, 1, 0, 0, 0, 543, 571, 1, 0, 0, 0, 544, 545, 10, 7, 0, 0, 545, 548, 5, 87, 0, 0, 546, 549, 3, 90, 45, 0, 547, 549, 3, 276, 138, 0, 548, 546, 1, 0, 0, 0, 548, 547, 1, 0, 0, 0, 549, 550, 1, 0, 0, 0, 550, 551, 5, 88, 0, 0, 551, 570, 1, 0, 0, 0, 552, 553, 10, 6, 0, 0, 553, 555, 5, 85, 0, 0, 554, 556, 3, 34, 17, 0, 555, 554, 1, 0, 0, 0, 555, 556, 1, 0, 0, 0, 556, 557, 1, 0, 0, 0, 557, 570, 5, 86, 0, 0, 558, 559, 10, 4, 0, 0, 559, 565, 7, 2, 0, 0, 560, 562, 5, 68, 0, 0, 561, 560, 1, 0, 0, 0, 561, 562, 1, 0, 0, 0, 562, 563, 1, 0, 0, 0, 563, 566, 3, 4, 2, 0, 564, 566, 3, 36, 18, 0, 565, 561, 1, 0, 0, 0, 565, 564, 1, 0, 0, 0, 566, 570, 1, 0, 0, 0, 567, 568, 10, 3, 0, 0, 568, 570, 7, 3, 0, 0, 569, 544, 1, 0, 0, 0, 569, 552, 1, 0, 0, 0, 569, 558, 1, 0, 0, 0, 569, 567, 1, 0, 0, 0, 570, 573, 1, 0, 0, 0, 571, 569, 1, 0, 0, 0, 571, 572, 1, 0, 0, 0, 572, 31, 1, 0, 0, 0, 573, 571, 1, 0, 0, 0, 574, 575, 5, 75, 0, 0, 575, 33, 1, 0, 0, 0, 576, 577, 3, 274, 137, 0, 577, 35, 1, 0, 0, 0, 578, 580, 3, 10, 5, 0, 579, 578, 1, 0, 0, 0, 579, 580, 1, 0, 0, 0, 580, 584, 1, 0, 0, 0, 581, 582, 3, 160, 80, 0, 582, 583, 5, 127, 0, 0, 583, 585, 1, 0, 0, 0, 584, 581, 1, 0, 0, 0, 584, 585, 1, 0, 0, 0, 585, 586, 1, 0, 0, 0, 586, 587, 5, 99, 0, 0, 587, 598, 3, 160, 80, 0, 588, 589, 3, 10, 5, 0, 589, 590, 5, 68, 0, 0, 590, 591, 3, 342, 171, 0, 591, 592, 5, 127, 0, 0, 592, 593, 5, 99, 0, 0, 593, 594, 3, 160, 80, 0, 594, 598, 1, 0, 0, 0, 595, 596, 5, 99, 0, 0, 596, 598, 3, 162, 81, 0, 597, 579, 1, 0, 0, 0, 597, 588, 1, 0, 0, 0, 597, 595, 1, 0, 0, 0, 598, 37, 1, 0, 0, 0, 599, 627, 3, 30, 15, 0, 600, 605, 5, 120, 0, 0, 601, 605, 5, 121, 0, 0, 602, 605, 3, 40, 20, 0, 603, 605, 5, 62, 0, 0, 604, 600, 1, 0, 0, 0, 604, 601, 1, 0, 0, 0, 604, 602, 1, 0, 0, 0, 604, 603, 1, 0, 0, 0, 605, 606, 1, 0, 0, 0, 606, 627, 3, 38, 19, 0, 607, 616, 5, 62, 0, 0, 608, 609, 5, 85, 0, 0, 609, 610, 3, 246, 123, 0, 610, 611, 5, 86, 0, 0, 611, 617, 1, 0, 0, 0, 612, 613, 5, 131, 0, 0, 613, 614, 5, 85, 0, 0, 614, 615, 5, 132, 0, 0, 615, 617, 5, 86, 0, 0, 616, 608, 1, 0, 0, 0, 616, 612, 1, 0, 0, 0, 617, 627, 1, 0, 0, 0, 618, 619, 5, 11, 0, 0, 619, 620, 5, 85, 0, 0, 620, 621, 3, 246, 123, 0, 621, 622, 5, 86, 0, 0, 622, 627, 1, 0, 0, 0, 623, 627, 3, 56, 28, 0, 624, 627, 3, 42, 21, 0, 625, 627, 3, 54, 27, 0, 626, 599, 1, 0, 0, 0, 626, 604, 1, 0, 0, 0, 626, 607, 1, 0, 0, 0, 626, 618, 1, 0, 0, 0, 626, 623, 1, 0, 0, 0, 626, 624, 1, 0, 0, 0, 626, 625, 1, 0, 0, 0, 627, 39, 1, 0, 0, 0, 628, 629, 7, 4, 0, 0, 629, 41, 1, 0, 0, 0, 630, 632, 5, 127, 0, 0, 631, 630, 1, 0, 0, 0, 631, 632, 1, 0, 0, 0, 632, 633, 1, 0, 0, 0, 633, 635, 5, 49, 0, 0, 634, 636, 3, 44, 22, 0, 635, 634, 1, 0, 0, 0, 635, 636, 1, 0, 0, 0, 636, 642, 1, 0, 0, 0, 637, 643, 3, 46, 23, 0, 638, 639, 5, 85, 0, 0, 639, 640, 3, 246, 123, 0, 640, 641, 5, 86, 0, 0, 641, 643, 1, 0, 0, 0, 642, 637, 1, 0, 0, 0, 642, 638, 1, 0, 0, 0, 643, 645, 1, 0, 0, 0, 644, 646, 3, 52, 26, 0, 645, 644, 1, 0, 0, 0, 645, 646, 1, 0, 0, 0, 646, 43, 1, 0, 0, 0, 647, 648, 5, 85, 0, 0, 648, 649, 3, 34, 17, 0, 649, 650, 5, 86, 0, 0, 650, 45, 1, 0, 0, 0, 651, 653, 3, 150, 75, 0, 652, 654, 3, 48, 24, 0, 653, 652, 1, 0, 0, 0, 653, 654, 1, 0, 0, 0, 654, 47, 1, 0, 0, 0, 655, 657, 3, 236, 118, 0, 656, 658, 3, 48, 24, 0, 657, 656, 1, 0, 0, 0, 657, 658, 1, 0, 0, 0, 658, 661, 1, 0, 0, 0, 659, 661, 3, 50, 25, 0, 660, 655, 1, 0, 0, 0, 660, 659, 1, 0, 0, 0, 661, 49, 1, 0, 0, 0, 662, 663, 6, 25, -1, 0, 663, 664, 5, 87, 0, 0, 664, 665, 3, 90, 45, 0, 665, 667, 5, 88, 0, 0, 666, 668, 3, 204, 102, 0, 667, 666, 1, 0, 0, 0, 667, 668, 1, 0, 0, 0, 668, 678, 1, 0, 0, 0, 669, 670, 10, 1, 0, 0, 670, 671, 5, 87, 0, 0, 671, 672, 3, 92, 46, 0, 672, 674, 5, 88, 0, 0, 673, 675, 3, 204, 102, 0, 674, 673, 1, 0, 0, 0, 674, 675, 1, 0, 0, 0, 675, 677, 1, 0, 0, 0, 676, 669, 1, 0, 0, 0, 677, 680, 1, 0, 0, 0, 678, 676, 1, 0, 0, 0, 678, 679, 1, 0, 0, 0, 679, 51, 1, 0, 0, 0, 680, 678, 1, 0, 0, 0, 681, 683, 5, 85, 0, 0, 682, 684, 3, 34, 17, 0, 683, 682, 1, 0, 0, 0, 683, 684, 1, 0, 0, 0, 684, 685, 1, 0, 0, 0, 685, 688, 5, 86, 0, 0, 686, 688, 3, 276, 138, 0, 687, 681, 1, 0, 0, 0, 687, 686, 1, 0, 0, 0, 688, 53, 1, 0, 0, 0, 689, 691, 5, 127, 0, 0, 690, 689, 1, 0, 0, 0, 690, 691, 1, 0, 0, 0, 691, 692, 1, 0, 0, 0, 692, 695, 5, 28, 0, 0, 693, 694, 5, 87, 0, 0, 694, 696, 5, 88, 0, 0, 695, 693, 1, 0, 0, 0, 695, 696, 1, 0, 0, 0, 696, 697, 1, 0, 0, 0, 697, 698, 3, 58, 29, 0, 698, 55, 1, 0, 0, 0, 699, 700, 5, 50, 0, 0, 700, 701, 5, 85, 0, 0, 701, 702, 3, 90, 45, 0, 702, 703, 5, 86, 0, 0, 703, 57, 1, 0, 0, 0, 704, 711, 3, 38, 19, 0, 705, 706, 5, 85, 0, 0, 706, 707, 3, 246, 123, 0, 707, 708, 5, 86, 0, 0, 708, 709, 3, 58, 29, 0, 709, 711, 1, 0, 0, 0, 710, 704, 1, 0, 0, 0, 710, 705, 1, 0, 0, 0, 711, 59, 1, 0, 0, 0, 712, 717, 3, 58, 29, 0, 713, 714, 7, 5, 0, 0, 714, 716, 3, 58, 29, 0, 715, 713, 1, 0, 0, 0, 716, 719, 1, 0, 0, 0, 717, 715, 1, 0, 0, 0, 717, 718, 1, 0, 0, 0, 718, 61, 1, 0, 0, 0, 719, 717, 1, 0, 0, 0, 720, 725, 3, 60, 30, 0, 721, 722, 7, 6, 0, 0, 722, 724, 3, 60, 30, 0, 723, 721, 1, 0, 0, 0, 724, 727, 1, 0, 0, 0, 725, 723, 1, 0, 0, 0, 725, 726, 1, 0, 0, 0, 726, 63, 1, 0, 0, 0, 727, 725, 1, 0, 0, 0, 728, 733, 3, 62, 31, 0, 729, 730, 7, 7, 0, 0, 730, 732, 3, 62, 31, 0, 731, 729, 1, 0, 0, 0, 732, 735, 1, 0, 0, 0, 733, 731, 1, 0, 0, 0, 733, 734, 1, 0, 0, 0, 734, 65, 1, 0, 0, 0, 735, 733, 1, 0, 0, 0, 736, 742, 3, 64, 32, 0, 737, 738, 3, 68, 34, 0, 738, 739, 3, 64, 32, 0, 739, 741, 1, 0, 0, 0, 740, 737, 1, 0, 0, 0, 741, 744, 1, 0, 0, 0, 742, 740, 1, 0, 0, 0, 742, 743, 1, 0, 0, 0, 743, 67, 1, 0, 0, 0, 744, 742, 1, 0, 0, 0, 745, 746, 5, 103, 0, 0, 746, 750, 5, 103, 0, 0, 747, 748, 5, 102, 0, 0, 748, 750, 5, 102, 0, 0, 749, 745, 1, 0, 0, 0, 749, 747, 1, 0, 0, 0, 750, 69, 1, 0, 0, 0, 751, 756, 3, 66, 33, 0, 752, 753, 7, 8, 0, 0, 753, 755, 3, 66, 33, 0, 754, 752, 1, 0, 0, 0, 755, 758, 1, 0, 0, 0, 756, 754, 1, 0, 0, 0, 756, 757, 1, 0, 0, 0, 757, 71, 1, 0, 0, 0, 758, 756, 1, 0, 0, 0, 759, 764, 3, 70, 35, 0, 760, 761, 7, 9, 0, 0, 761, 763, 3, 70, 35, 0, 762, 760, 1, 0, 0, 0, 763, 766, 1, 0, 0, 0, 764, 762, 1, 0, 0, 0, 764, 765, 1, 0, 0, 0, 765, 73, 1, 0, 0, 0, 766, 764, 1, 0, 0, 0, 767, 772, 3, 72, 36, 0, 768, 769, 5, 97, 0, 0, 769, 771, 3, 72, 36, 0, 770, 768, 1, 0, 0, 0, 771, 774, 1, 0, 0, 0, 772, 770, 1, 0, 0, 0, 772, 773, 1, 0, 0, 0, 773, 75, 1, 0, 0, 0, 774, 772, 1, 0, 0, 0, 775, 780, 3, 74, 37, 0, 776, 777, 5, 96, 0, 0, 777, 779, 3, 74, 37, 0, 778, 776, 1, 0, 0, 0, 779, 782, 1, 0, 0, 0, 780, 778, 1, 0, 0, 0, 780, 781, 1, 0, 0, 0, 781, 77, 1, 0, 0, 0, 782, 780, 1, 0, 0, 0, 783, 788, 3, 76, 38, 0, 784, 785, 5, 98, 0, 0, 785, 787, 3, 76, 38, 0, 786, 784, 1, 0, 0, 0, 787, 790, 1, 0, 0, 0, 788, 786, 1, 0, 0, 0, 788, 789, 1, 0, 0, 0, 789, 79, 1, 0, 0, 0, 790, 788, 1, 0, 0, 0, 791, 796, 3, 78, 39, 0, 792, 793, 5, 118, 0, 0, 793, 795, 3, 78, 39, 0, 794, 792, 1, 0, 0, 0, 795, 798, 1, 0, 0, 0, 796, 794, 1, 0, 0, 0, 796, 797, 1, 0, 0, 0, 797, 81, 1, 0, 0, 0, 798, 796, 1, 0, 0, 0, 799, 804, 3, 80, 40, 0, 800, 801, 5, 119, 0, 0, 801, 803, 3, 80, 40, 0, 802, 800, 1, 0, 0, 0, 803, 806, 1, 0, 0, 0, 804, 802, 1, 0, 0, 0, 804, 805, 1, 0, 0, 0, 805, 83, 1, 0, 0, 0, 806, 804, 1, 0, 0, 0, 807, 813, 3, 82, 41, 0, 808, 809, 5, 125, 0, 0, 809, 810, 3, 90, 45, 0, 810, 811, 5, 126, 0, 0, 811, 812, 3, 86, 43, 0, 812, 814, 1, 0, 0, 0, 813, 808, 1, 0, 0, 0, 813, 814, 1, 0, 0, 0, 814, 85, 1, 0, 0, 0, 815, 822, 3, 84, 42, 0, 816, 817, 3, 82, 41, 0, 817, 818, 3, 88, 44, 0, 818, 819, 3, 272, 136, 0, 819, 822, 1, 0, 0, 0, 820, 822, 3, 368, 184, 0, 821, 815, 1, 0, 0, 0, 821, 816, 1, 0, 0, 0, 821, 820, 1, 0, 0, 0, 822, 87, 1, 0, 0, 0, 823, 824, 7, 10, 0, 0, 824, 89, 1, 0, 0, 0, 825, 830, 3, 86, 43, 0, 826, 827, 5, 122, 0, 0, 827, 829, 3, 86, 43, 0, 828, 826, 1, 0, 0, 0, 829, 832, 1, 0, 0, 0, 830, 828, 1, 0, 0, 0, 830, 831, 1, 0, 0, 0, 831, 91, 1, 0, 0, 0, 832, 830, 1, 0, 0, 0, 833, 834, 3, 84, 42, 0, 834, 93, 1, 0, 0, 0, 835, 849, 3, 96, 48, 0, 836, 849, 3, 118, 59, 0, 837, 839, 3, 204, 102, 0, 838, 837, 1, 0, 0, 0, 838, 839, 1, 0, 0, 0, 839, 846, 1, 0, 0, 0, 840, 847, 3, 98, 49, 0, 841, 847, 3, 100, 50, 0, 842, 847, 3, 104, 52, 0, 843, 847, 3, 108, 54, 0, 844, 847, 3, 116, 58, 0, 845, 847, 3, 358, 179, 0, 846, 840, 1, 0, 0, 0, 846, 841, 1, 0, 0, 0, 846, 842, 1, 0, 0, 0, 846, 843, 1, 0, 0, 0, 846, 844, 1, 0, 0, 0, 846, 845, 1, 0, 0, 0, 847, 849, 1, 0, 0, 0, 848, 835, 1, 0, 0, 0, 848, 836, 1, 0, 0, 0, 848, 838, 1, 0, 0, 0, 849, 95, 1, 0, 0, 0, 850, 852, 3, 204, 102, 0, 851, 850, 1, 0, 0, 0, 851, 852, 1, 0, 0, 0, 852, 857, 1, 0, 0, 0, 853, 858, 5, 132, 0, 0, 854, 855, 5, 16, 0, 0, 855, 858, 3, 92, 46, 0, 856, 858, 5, 27, 0, 0, 857, 853, 1, 0, 0, 0, 857, 854, 1, 0, 0, 0, 857, 856, 1, 0, 0, 0, 858, 859, 1, 0, 0, 0, 859, 860, 5, 126, 0, 0, 860, 861, 3, 94, 47, 0, 861, 97, 1, 0, 0, 0, 862, 864, 3, 90, 45, 0, 863, 862, 1, 0, 0, 0, 863, 864, 1, 0, 0, 0, 864, 865, 1, 0, 0, 0, 865, 866, 5, 128, 0, 0, 866, 99, 1, 0, 0, 0, 867, 869, 5, 89, 0, 0, 868, 870, 3, 102, 51, 0, 869, 868, 1, 0, 0, 0, 869, 870, 1, 0, 0, 0, 870, 871, 1, 0, 0, 0, 871, 872, 5, 90, 0, 0, 872, 101, 1, 0, 0, 0, 873, 875, 3, 94, 47, 0, 874, 873, 1, 0, 0, 0, 875, 876, 1, 0, 0, 0, 876, 874, 1, 0, 0, 0, 876, 877, 1, 0, 0, 0, 877, 103, 1, 0, 0, 0, 878, 879, 5, 43, 0, 0, 879, 880, 5, 85, 0, 0, 880, 881, 3, 106, 53, 0, 881, 882, 5, 86, 0, 0, 882, 885, 3, 94, 47, 0, 883, 884, 5, 32, 0, 0, 884, 886, 3, 94, 47, 0, 885, 883, 1, 0, 0, 0, 885, 886, 1, 0, 0, 0, 886, 894, 1, 0, 0, 0, 887, 888, 5, 67, 0, 0, 888, 889, 5, 85, 0, 0, 889, 890, 3, 106, 53, 0, 890, 891, 5, 86, 0, 0, 891, 892, 3, 94, 47, 0, 892, 894, 1, 0, 0, 0, 893, 878, 1, 0, 0, 0, 893, 887, 1, 0, 0, 0, 894, 105, 1, 0, 0, 0, 895, 907, 3, 90, 45, 0, 896, 898, 3, 204, 102, 0, 897, 896, 1, 0, 0, 0, 897, 898, 1, 0, 0, 0, 898, 899, 1, 0, 0, 0, 899, 900, 3, 138, 69, 0, 900, 904, 3, 226, 113, 0, 901, 902, 5, 101, 0, 0, 902, 905, 3, 272, 136, 0, 903, 905, 3, 276, 138, 0, 904, 901, 1, 0, 0, 0, 904, 903, 1, 0, 0, 0, 905, 907, 1, 0, 0, 0, 906, 895, 1, 0, 0, 0, 906, 897, 1, 0, 0, 0, 907, 107, 1, 0, 0, 0, 908, 909, 5, 84, 0, 0, 909, 910, 5, 85, 0, 0, 910, 911, 3, 106, 53, 0, 911, 912, 5, 86, 0, 0, 912, 913, 3, 94, 47, 0, 913, 942, 1, 0, 0, 0, 914, 915, 5, 29, 0, 0, 915, 916, 3, 94, 47, 0, 916, 917, 5, 84, 0, 0, 917, 918, 5, 85, 0, 0, 918, 919, 3, 90, 45, 0, 919, 920, 5, 86, 0, 0, 920, 921, 5, 128, 0, 0, 921, 942, 1, 0, 0, 0, 922, 923, 5, 40, 0, 0, 923, 936, 5, 85, 0, 0, 924, 926, 3, 110, 55, 0, 925, 927, 3, 106, 53, 0, 926, 925, 1, 0, 0, 0, 926, 927, 1, 0, 0, 0, 927, 928, 1, 0, 0, 0, 928, 930, 5, 128, 0, 0, 929, 931, 3, 90, 45, 0, 930, 929, 1, 0, 0, 0, 930, 931, 1, 0, 0, 0, 931, 937, 1, 0, 0, 0, 932, 933, 3, 112, 56, 0, 933, 934, 5, 126, 0, 0, 934, 935, 3, 114, 57, 0, 935, 937, 1, 0, 0, 0, 936, 924, 1, 0, 0, 0, 936, 932, 1, 0, 0, 0, 937, 938, 1, 0, 0, 0, 938, 939, 5, 86, 0, 0, 939, 940, 3, 94, 47, 0, 940, 942, 1, 0, 0, 0, 941, 908, 1, 0, 0, 0, 941, 914, 1, 0, 0, 0, 941, 922, 1, 0, 0, 0, 942, 109, 1, 0, 0, 0, 943, 946, 3, 98, 49, 0, 944, 946, 3, 128, 64, 0, 945, 943, 1, 0, 0, 0, 945, 944, 1, 0, 0, 0, 946, 111, 1, 0, 0, 0, 947, 949, 3, 204, 102, 0, 948, 947, 1, 0, 0, 0, 948, 949, 1, 0, 0, 0, 949, 950, 1, 0, 0, 0, 950, 951, 3, 138, 69, 0, 951, 952, 3, 226, 113, 0, 952, 113, 1, 0, 0, 0, 953, 956, 3, 90, 45, 0, 954, 956, 3, 276, 138, 0, 955, 953, 1, 0, 0, 0, 955, 954, 1, 0, 0, 0, 956, 115, 1, 0, 0, 0, 957, 967, 5, 15, 0, 0, 958, 967, 5, 25, 0, 0, 959, 962, 5, 59, 0, 0, 960, 963, 3, 90, 45, 0, 961, 963, 3, 276, 138, 0, 962, 960, 1, 0, 0, 0, 962, 961, 1, 0, 0, 0, 962, 963, 1, 0, 0, 0, 963, 967, 1, 0, 0, 0, 964, 965, 5, 42, 0, 0, 965, 967, 5, 132, 0, 0, 966, 957, 1, 0, 0, 0, 966, 958, 1, 0, 0, 0, 966, 959, 1, 0, 0, 0, 966, 964, 1, 0, 0, 0, 967, 968, 1, 0, 0, 0, 968, 969, 5, 128, 0, 0, 969, 117, 1, 0, 0, 0, 970, 971, 3, 124, 62, 0, 971, 119, 1, 0, 0, 0, 972, 974, 3, 122, 61, 0, 973, 972, 1, 0, 0, 0, 974, 975, 1, 0, 0, 0, 975, 973, 1, 0, 0, 0, 975, 976, 1, 0, 0, 0, 976, 121, 1, 0, 0, 0, 977, 987, 3, 124, 62, 0, 978, 987, 3, 264, 132, 0, 979, 987, 3, 334, 167, 0, 980, 987, 3, 354, 177, 0, 981, 987, 3, 356, 178, 0, 982, 987, 3, 202, 101, 0, 983, 987, 3, 188, 94, 0, 984, 987, 3, 132, 66, 0, 985, 987, 3, 134, 67, 0, 986, 977, 1, 0, 0, 0, 986, 978, 1, 0, 0, 0, 986, 979, 1, 0, 0, 0, 986, 980, 1, 0, 0, 0, 986, 981, 1, 0, 0, 0, 986, 982, 1, 0, 0, 0, 986, 983, 1, 0, 0, 0, 986, 984, 1, 0, 0, 0, 986, 985, 1, 0, 0, 0, 987, 123, 1, 0, 0, 0, 988, 997, 3, 128, 64, 0, 989, 997, 3, 200, 100, 0, 990, 997, 3, 192, 96, 0, 991, 997, 3, 196, 98, 0, 992, 997, 3, 198, 99, 0, 993, 997, 3, 130, 65, 0, 994, 997, 3, 126, 63, 0, 995, 997, 3, 172, 86, 0, 996, 988, 1, 0, 0, 0, 996, 989, 1, 0, 0, 0, 996, 990, 1, 0, 0, 0, 996, 991, 1, 0, 0, 0, 996, 992, 1, 0, 0, 0, 996, 993, 1, 0, 0, 0, 996, 994, 1, 0, 0, 0, 996, 995, 1, 0, 0, 0, 997, 125, 1, 0, 0, 0, 998, 999, 5, 79, 0, 0, 999, 1001, 5, 132, 0, 0, 1000, 1002, 3, 204, 102, 0, 1001, 1000, 1, 0, 0, 0, 1001, 1002, 1, 0, 0, 0, 1002, 1003, 1, 0, 0, 0, 1003, 1004, 5, 101, 0, 0, 1004, 1005, 3, 246, 123, 0, 1005, 1006, 5, 128, 0, 0, 1006, 127, 1, 0, 0, 0, 1007, 1009, 3, 138, 69, 0, 1008, 1007, 1, 0, 0, 0, 1008, 1009, 1, 0, 0, 0, 1009, 1011, 1, 0, 0, 0, 1010, 1012, 3, 222, 111, 0, 1011, 1010, 1, 0, 0, 0, 1011, 1012, 1, 0, 0, 0, 1012, 1013, 1, 0, 0, 0, 1013, 1022, 5, 128, 0, 0, 1014, 1016, 3, 204, 102, 0, 1015, 1017, 3, 138, 69, 0, 1016, 1015, 1, 0, 0, 0, 1016, 1017, 1, 0, 0, 0, 1017, 1018, 1, 0, 0, 0, 1018, 1019, 3, 222, 111, 0, 1019, 1020, 5, 128, 0, 0, 1020, 1022, 1, 0, 0, 0, 1021, 1008, 1, 0, 0, 0, 1021, 1014, 1, 0, 0, 0, 1022, 129, 1, 0, 0, 0, 1023, 1024, 5, 64, 0, 0, 1024, 1025, 5, 85, 0, 0, 1025, 1026, 3, 92, 46, 0, 1026, 1027, 5, 122, 0, 0, 1027, 1028, 5, 4, 0, 0, 1028, 1029, 5, 86, 0, 0, 1029, 1030, 5, 128, 0, 0, 1030, 131, 1, 0, 0, 0, 1031, 1032, 5, 128, 0, 0, 1032, 133, 1, 0, 0, 0, 1033, 1034, 3, 204, 102, 0, 1034, 1035, 5, 128, 0, 0, 1035, 135, 1, 0, 0, 0, 1036, 1043, 3, 140, 70, 0, 1037, 1043, 3, 146, 73, 0, 1038, 1043, 3, 142, 71, 0, 1039, 1043, 5, 41, 0, 0, 1040, 1043, 5, 74, 0, 0, 1041, 1043, 5, 23, 0, 0, 1042, 1036, 1, 0, 0, 0, 1042, 1037, 1, 0, 0, 0, 1042, 1038, 1, 0, 0, 0, 1042, 1039, 1, 0, 0, 0, 1042, 1040, 1, 0, 0, 0, 1042, 1041, 1, 0, 0, 0, 1043, 137, 1, 0, 0, 0, 1044, 1046, 3, 136, 68, 0, 1045, 1044, 1, 0, 0, 0, 1046, 1047, 1, 0, 0, 0, 1047, 1048, 1, 0, 0, 0, 1047, 1045, 1, 0, 0, 0, 1048, 1050, 1, 0, 0, 0, 1049, 1051, 3, 204, 102, 0, 1050, 1049, 1, 0, 0, 0, 1050, 1051, 1, 0, 0, 0, 1051, 139, 1, 0, 0, 0, 1052, 1053, 7, 11, 0, 0, 1053, 141, 1, 0, 0, 0, 1054, 1055, 7, 12, 0, 0, 1055, 143, 1, 0, 0, 0, 1056, 1057, 5, 132, 0, 0, 1057, 145, 1, 0, 0, 0, 1058, 1062, 3, 148, 74, 0, 1059, 1062, 3, 280, 140, 0, 1060, 1062, 3, 168, 84, 0, 1061, 1058, 1, 0, 0, 0, 1061, 1059, 1, 0, 0, 0, 1061, 1060, 1, 0, 0, 0, 1062, 147, 1, 0, 0, 0, 1063, 1068, 3, 158, 79, 0, 1064, 1068, 3, 164, 82, 0, 1065, 1068, 3, 352, 176, 0, 1066, 1068, 3, 240, 120, 0, 1067, 1063, 1, 0, 0, 0, 1067, 1064, 1, 0, 0, 0, 1067, 1065, 1, 0, 0, 0, 1067, 1066, 1, 0, 0, 0, 1068, 149, 1, 0, 0, 0, 1069, 1071, 3, 146, 73, 0, 1070, 1069, 1, 0, 0, 0, 1071, 1072, 1, 0, 0, 0, 1072, 1070, 1, 0, 0, 0, 1072, 1073, 1, 0, 0, 0, 1073, 1075, 1, 0, 0, 0, 1074, 1076, 3, 204, 102, 0, 1075, 1074, 1, 0, 0, 0, 1075, 1076, 1, 0, 0, 0, 1076, 151, 1, 0, 0, 0, 1077, 1079, 3, 148, 74, 0, 1078, 1077, 1, 0, 0, 0, 1079, 1080, 1, 0, 0, 0, 1080, 1078, 1, 0, 0, 0, 1080, 1081, 1, 0, 0, 0, 1081, 1083, 1, 0, 0, 0, 1082, 1084, 3, 204, 102, 0, 1083, 1082, 1, 0, 0, 0, 1083, 1084, 1, 0, 0, 0, 1084, 153, 1, 0, 0, 0, 1085, 1086, 7, 13, 0, 0, 1086, 155, 1, 0, 0, 0, 1087, 1088, 7, 14, 0, 0, 1088, 157, 1, 0, 0, 0, 1089, 1091, 3, 10, 5, 0, 1090, 1089, 1, 0, 0, 0, 1090, 1091, 1, 0, 0, 0, 1091, 1092, 1, 0, 0, 0, 1092, 1114, 3, 160, 80, 0, 1093, 1094, 3, 10, 5, 0, 1094, 1095, 5, 68, 0, 0, 1095, 1096, 3, 342, 171, 0, 1096, 1114, 1, 0, 0, 0, 1097, 1114, 5, 18, 0, 0, 1098, 1114, 5, 19, 0, 0, 1099, 1114, 5, 20, 0, 0, 1100, 1114, 5, 83, 0, 0, 1101, 1114, 5, 14, 0, 0, 1102, 1114, 5, 60, 0, 0, 1103, 1114, 5, 45, 0, 0, 1104, 1114, 5, 46, 0, 0, 1105, 1114, 5, 39, 0, 0, 1106, 1114, 5, 61, 0, 0, 1107, 1114, 5, 78, 0, 0, 1108, 1114, 5, 39, 0, 0, 1109, 1114, 5, 30, 0, 0, 1110, 1114, 5, 81, 0, 0, 1111, 1114, 5, 13, 0, 0, 1112, 1114, 3, 162, 81, 0, 1113, 1090, 1, 0, 0, 0, 1113, 1093, 1, 0, 0, 0, 1113, 1097, 1, 0, 0, 0, 1113, 1098, 1, 0, 0, 0, 1113, 1099, 1, 0, 0, 0, 1113, 1100, 1, 0, 0, 0, 1113, 1101, 1, 0, 0, 0, 1113, 1102, 1, 0, 0, 0, 1113, 1103, 1, 0, 0, 0, 1113, 1104, 1, 0, 0, 0, 1113, 1105, 1, 0, 0, 0, 1113, 1106, 1, 0, 0, 0, 1113, 1107, 1, 0, 0, 0, 1113, 1108, 1, 0, 0, 0, 1113, 1109, 1, 0, 0, 0, 1113, 1110, 1, 0, 0, 0, 1113, 1111, 1, 0, 0, 0, 1113, 1112, 1, 0, 0, 0, 1114, 159, 1, 0, 0, 0, 1115, 1120, 3, 278, 139, 0, 1116, 1120, 3, 166, 83, 0, 1117, 1120, 3, 144, 72, 0, 1118, 1120, 3, 342, 171, 0, 1119, 1115, 1, 0, 0, 0, 1119, 1116, 1, 0, 0, 0, 1119, 1117, 1, 0, 0, 0, 1119, 1118, 1, 0, 0, 0, 1120, 161, 1, 0, 0, 0, 1121, 1122, 5, 26, 0, 0, 1122, 1125, 5, 85, 0, 0, 1123, 1126, 3, 90, 45, 0, 1124, 1126, 5, 13, 0, 0, 1125, 1123, 1, 0, 0, 0, 1125, 1124, 1, 0, 0, 0, 1126, 1127, 1, 0, 0, 0, 1127, 1128, 5, 86, 0, 0, 1128, 163, 1, 0, 0, 0, 1129, 1144, 3, 288, 144, 0, 1130, 1132, 3, 204, 102, 0, 1131, 1130, 1, 0, 0, 0, 1131, 1132, 1, 0, 0, 0, 1132, 1134, 1, 0, 0, 0, 1133, 1135, 3, 10, 5, 0, 1134, 1133, 1, 0, 0, 0, 1134, 1135, 1, 0, 0, 0, 1135, 1136, 1, 0, 0, 0, 1136, 1145, 5, 132, 0, 0, 1137, 1145, 3, 342, 171, 0, 1138, 1140, 3, 10, 5, 0, 1139, 1141, 5, 68, 0, 0, 1140, 1139, 1, 0, 0, 0, 1140, 1141, 1, 0, 0, 0, 1141, 1142, 1, 0, 0, 0, 1142, 1143, 3, 342, 171, 0, 1143, 1145, 1, 0, 0, 0, 1144, 1131, 1, 0, 0, 0, 1144, 1137, 1, 0, 0, 0, 1144, 1138, 1, 0, 0, 0, 1145, 1152, 1, 0, 0, 0, 1146, 1148, 5, 33, 0, 0, 1147, 1149, 3, 10, 5, 0, 1148, 1147, 1, 0, 0, 0, 1148, 1149, 1, 0, 0, 0, 1149, 1150, 1, 0, 0, 0, 1150, 1152, 5, 132, 0, 0, 1151, 1129, 1, 0, 0, 0, 1151, 1146, 1, 0, 0, 0, 1152, 165, 1, 0, 0, 0, 1153, 1154, 5, 132, 0, 0, 1154, 167, 1, 0, 0, 0, 1155, 1156, 3, 170, 85, 0, 1156, 1161, 5, 89, 0, 0, 1157, 1159, 3, 178, 89, 0, 1158, 1160, 5, 122, 0, 0, 1159, 1158, 1, 0, 0, 0, 1159, 1160, 1, 0, 0, 0, 1160, 1162, 1, 0, 0, 0, 1161, 1157, 1, 0, 0, 0, 1161, 1162, 1, 0, 0, 0, 1162, 1163, 1, 0, 0, 0, 1163, 1164, 5, 90, 0, 0, 1164, 169, 1, 0, 0, 0, 1165, 1167, 3, 174, 87, 0, 1166, 1168, 3, 204, 102, 0, 1167, 1166, 1, 0, 0, 0, 1167, 1168, 1, 0, 0, 0, 1168, 1173, 1, 0, 0, 0, 1169, 1171, 3, 10, 5, 0, 1170, 1169, 1, 0, 0, 0, 1170, 1171, 1, 0, 0, 0, 1171, 1172, 1, 0, 0, 0, 1172, 1174, 5, 132, 0, 0, 1173, 1170, 1, 0, 0, 0, 1173, 1174, 1, 0, 0, 0, 1174, 1176, 1, 0, 0, 0, 1175, 1177, 3, 176, 88, 0, 1176, 1175, 1, 0, 0, 0, 1176, 1177, 1, 0, 0, 0, 1177, 171, 1, 0, 0, 0, 1178, 1180, 3, 174, 87, 0, 1179, 1181, 3, 204, 102, 0, 1180, 1179, 1, 0, 0, 0, 1180, 1181, 1, 0, 0, 0, 1181, 1182, 1, 0, 0, 0, 1182, 1184, 5, 132, 0, 0, 1183, 1185, 3, 176, 88, 0, 1184, 1183, 1, 0, 0, 0, 1184, 1185, 1, 0, 0, 0, 1185, 1186, 1, 0, 0, 0, 1186, 1187, 5, 128, 0, 0, 1187, 173, 1, 0, 0, 0, 1188, 1190, 5, 33, 0, 0, 1189, 1191, 7, 15, 0, 0, 1190, 1189, 1, 0, 0, 0, 1190, 1191, 1, 0, 0, 0, 1191, 175, 1, 0, 0, 0, 1192, 1193, 5, 126, 0, 0, 1193, 1194, 3, 150, 75, 0, 1194, 177, 1, 0, 0, 0, 1195, 1200, 3, 180, 90, 0, 1196, 1197, 5, 122, 0, 0, 1197, 1199, 3, 180, 90, 0, 1198, 1196, 1, 0, 0, 0, 1199, 1202, 1, 0, 0, 0, 1200, 1198, 1, 0, 0, 0, 1200, 1201, 1, 0, 0, 0, 1201, 179, 1, 0, 0, 0, 1202, 1200, 1, 0, 0, 0, 1203, 1206, 3, 182, 91, 0, 1204, 1205, 5, 101, 0, 0, 1205, 1207, 3, 92, 46, 0, 1206, 1204, 1, 0, 0, 0, 1206, 1207, 1, 0, 0, 0, 1207, 181, 1, 0, 0, 0, 1208, 1209, 5, 132, 0, 0, 1209, 183, 1, 0, 0, 0, 1210, 1213, 3, 186, 93, 0, 1211, 1213, 3, 190, 95, 0, 1212, 1210, 1, 0, 0, 0, 1212, 1211, 1, 0, 0, 0, 1213, 185, 1, 0, 0, 0, 1214, 1215, 5, 132, 0, 0, 1215, 187, 1, 0, 0, 0, 1216, 1218, 5, 44, 0, 0, 1217, 1216, 1, 0, 0, 0, 1217, 1218, 1, 0, 0, 0, 1218, 1219, 1, 0, 0, 0, 1219, 1222, 5, 48, 0, 0, 1220, 1223, 5, 132, 0, 0, 1221, 1223, 3, 186, 93, 0, 1222, 1220, 1, 0, 0, 0, 1222, 1221, 1, 0, 0, 0, 1222, 1223, 1, 0, 0, 0, 1223, 1224, 1, 0, 0, 0, 1224, 1226, 5, 89, 0, 0, 1225, 1227, 3, 120, 60, 0, 1226, 1225, 1, 0, 0, 0, 1226, 1227, 1, 0, 0, 0, 1227, 1228, 1, 0, 0, 0, 1228, 1229, 5, 90, 0, 0, 1229, 189, 1, 0, 0, 0, 1230, 1231, 5, 132, 0, 0, 1231, 191, 1, 0, 0, 0, 1232, 1233, 5, 48, 0, 0, 1233, 1234, 5, 132, 0, 0, 1234, 1235, 5, 101, 0, 0, 1235, 1236, 3, 194, 97, 0, 1236, 1237, 5, 128, 0, 0, 1237, 193, 1, 0, 0, 0, 1238, 1240, 3, 10, 5, 0, 1239, 1238, 1, 0, 0, 0, 1239, 1240, 1, 0, 0, 0, 1240, 1241, 1, 0, 0, 0, 1241, 1242, 3, 184, 92, 0, 1242, 195, 1, 0, 0, 0, 1243, 1249, 5, 79, 0, 0, 1244, 1246, 5, 76, 0, 0, 1245, 1244, 1, 0, 0, 0, 1245, 1246, 1, 0, 0, 0, 1246, 1247, 1, 0, 0, 0, 1247, 1250, 3, 10, 5, 0, 1248, 1250, 5, 127, 0, 0, 1249, 1245, 1, 0, 0, 0, 1249, 1248, 1, 0, 0, 0, 1250, 1251, 1, 0, 0, 0, 1251, 1252, 3, 6, 3, 0, 1252, 1253, 5, 128, 0, 0, 1253, 197, 1, 0, 0, 0, 1254, 1256, 3, 204, 102, 0, 1255, 1254, 1, 0, 0, 0, 1255, 1256, 1, 0, 0, 0, 1256, 1257, 1, 0, 0, 0, 1257, 1258, 5, 79, 0, 0, 1258, 1260, 5, 48, 0, 0, 1259, 1261, 3, 10, 5, 0, 1260, 1259, 1, 0, 0, 0, 1260, 1261, 1, 0, 0, 0, 1261, 1262, 1, 0, 0, 0, 1262, 1263, 3, 184, 92, 0, 1263, 1264, 5, 128, 0, 0, 1264, 199, 1, 0, 0, 0, 1265, 1266, 5, 12, 0, 0, 1266, 1267, 5, 85, 0, 0, 1267, 1268, 5, 4, 0, 0, 1268, 1269, 5, 86, 0, 0, 1269, 1270, 5, 128, 0, 0, 1270, 201, 1, 0, 0, 0, 1271, 1272, 5, 36, 0, 0, 1272, 1279, 5, 4, 0, 0, 1273, 1275, 5, 89, 0, 0, 1274, 1276, 3, 120, 60, 0, 1275, 1274, 1, 0, 0, 0, 1275, 1276, 1, 0, 0, 0, 1276, 1277, 1, 0, 0, 0, 1277, 1280, 5, 90, 0, 0, 1278, 1280, 3, 122, 61, 0, 1279, 1273, 1, 0, 0, 0, 1279, 1278, 1, 0, 0, 0, 1280, 203, 1, 0, 0, 0, 1281, 1283, 3, 206, 103, 0, 1282, 1281, 1, 0, 0, 0, 1283, 1284, 1, 0, 0, 0, 1284, 1282, 1, 0, 0, 0, 1284, 1285, 1, 0, 0, 0, 1285, 205, 1, 0, 0, 0, 1286, 1287, 5, 87, 0, 0, 1287, 1289, 5, 87, 0, 0, 1288, 1290, 3, 210, 105, 0, 1289, 1288, 1, 0, 0, 0, 1289, 1290, 1, 0, 0, 0, 1290, 1291, 1, 0, 0, 0, 1291, 1292, 5, 88, 0, 0, 1292, 1295, 5, 88, 0, 0, 1293, 1295, 3, 208, 104, 0, 1294, 1286, 1, 0, 0, 0, 1294, 1293, 1, 0, 0, 0, 1295, 207, 1, 0, 0, 0, 1296, 1297, 5, 10, 0, 0, 1297, 1300, 5, 85, 0, 0, 1298, 1301, 3, 246, 123, 0, 1299, 1301, 3, 92, 46, 0, 1300, 1298, 1, 0, 0, 0, 1300, 1299, 1, 0, 0, 0, 1301, 1303, 1, 0, 0, 0, 1302, 1304, 5, 131, 0, 0, 1303, 1302, 1, 0, 0, 0, 1303, 1304, 1, 0, 0, 0, 1304, 1305, 1, 0, 0, 0, 1305, 1306, 5, 86, 0, 0, 1306, 209, 1, 0, 0, 0, 1307, 1312, 3, 212, 106, 0, 1308, 1309, 5, 122, 0, 0, 1309, 1311, 3, 212, 106, 0, 1310, 1308, 1, 0, 0, 0, 1311, 1314, 1, 0, 0, 0, 1312, 1310, 1, 0, 0, 0, 1312, 1313, 1, 0, 0, 0, 1313, 1316, 1, 0, 0, 0, 1314, 1312, 1, 0, 0, 0, 1315, 1317, 5, 131, 0, 0, 1316, 1315, 1, 0, 0, 0, 1316, 1317, 1, 0, 0, 0, 1317, 211, 1, 0, 0, 0, 1318, 1319, 3, 214, 107, 0, 1319, 1320, 5, 127, 0, 0, 1320, 1322, 1, 0, 0, 0, 1321, 1318, 1, 0, 0, 0, 1321, 1322, 1, 0, 0, 0, 1322, 1323, 1, 0, 0, 0, 1323, 1325, 5, 132, 0, 0, 1324, 1326, 3, 216, 108, 0, 1325, 1324, 1, 0, 0, 0, 1325, 1326, 1, 0, 0, 0, 1326, 213, 1, 0, 0, 0, 1327, 1328, 5, 132, 0, 0, 1328, 215, 1, 0, 0, 0, 1329, 1331, 5, 85, 0, 0, 1330, 1332, 3, 218, 109, 0, 1331, 1330, 1, 0, 0, 0, 1331, 1332, 1, 0, 0, 0, 1332, 1333, 1, 0, 0, 0, 1333, 1334, 5, 86, 0, 0, 1334, 217, 1, 0, 0, 0, 1335, 1337, 3, 220, 110, 0, 1336, 1335, 1, 0, 0, 0, 1337, 1338, 1, 0, 0, 0, 1338, 1336, 1, 0, 0, 0, 1338, 1339, 1, 0, 0, 0, 1339, 219, 1, 0, 0, 0, 1340, 1341, 5, 85, 0, 0, 1341, 1342, 3, 218, 109, 0, 1342, 1343, 5, 86, 0, 0, 1343, 1358, 1, 0, 0, 0, 1344, 1345, 5, 87, 0, 0, 1345, 1346, 3, 218, 109, 0, 1346, 1347, 5, 88, 0, 0, 1347, 1358, 1, 0, 0, 0, 1348, 1349, 5, 89, 0, 0, 1349, 1350, 3, 218, 109, 0, 1350, 1351, 5, 90, 0, 0, 1351, 1358, 1, 0, 0, 0, 1352, 1354, 8, 16, 0, 0, 1353, 1352, 1, 0, 0, 0, 1354, 1355, 1, 0, 0, 0, 1355, 1353, 1, 0, 0, 0, 1355, 1356, 1, 0, 0, 0, 1356, 1358, 1, 0, 0, 0, 1357, 1340, 1, 0, 0, 0, 1357, 1344, 1, 0, 0, 0, 1357, 1348, 1, 0, 0, 0, 1357, 1353, 1, 0, 0, 0, 1358, 221, 1, 0, 0, 0, 1359, 1364, 3, 224, 112, 0, 1360, 1361, 5, 122, 0, 0, 1361, 1363, 3, 224, 112, 0, 1362, 1360, 1, 0, 0, 0, 1363, 1366, 1, 0, 0, 0, 1364, 1362, 1, 0, 0, 0, 1364, 1365, 1, 0, 0, 0, 1365, 223, 1, 0, 0, 0, 1366, 1364, 1, 0, 0, 0, 1367, 1369, 3, 226, 113, 0, 1368, 1370, 3, 268, 134, 0, 1369, 1368, 1, 0, 0, 0, 1369, 1370, 1, 0, 0, 0, 1370, 225, 1, 0, 0, 0, 1371, 1377, 3, 228, 114, 0, 1372, 1373, 3, 230, 115, 0, 1373, 1374, 3, 232, 116, 0, 1374, 1375, 3, 234, 117, 0, 1375, 1377, 1, 0, 0, 0, 1376, 1371, 1, 0, 0, 0, 1376, 1372, 1, 0, 0, 0, 1377, 227, 1, 0, 0, 0, 1378, 1380, 3, 236, 118, 0, 1379, 1381, 5, 22, 0, 0, 1380, 1379, 1, 0, 0, 0, 1380, 1381, 1, 0, 0, 0, 1381, 1383, 1, 0, 0, 0, 1382, 1378, 1, 0, 0, 0, 1383, 1386, 1, 0, 0, 0, 1384, 1382, 1, 0, 0, 0, 1384, 1385, 1, 0, 0, 0, 1385, 1387, 1, 0, 0, 0, 1386, 1384, 1, 0, 0, 0, 1387, 1388, 3, 230, 115, 0, 1388, 229, 1, 0, 0, 0, 1389, 1390, 6, 115, -1, 0, 1390, 1392, 3, 244, 122, 0, 1391, 1393, 3, 204, 102, 0, 1392, 1391, 1, 0, 0, 0, 1392, 1393, 1, 0, 0, 0, 1393, 1399, 1, 0, 0, 0, 1394, 1395, 5, 85, 0, 0, 1395, 1396, 3, 228, 114, 0, 1396, 1397, 5, 86, 0, 0, 1397, 1399, 1, 0, 0, 0, 1398, 1389, 1, 0, 0, 0, 1398, 1394, 1, 0, 0, 0, 1399, 1414, 1, 0, 0, 0, 1400, 1410, 10, 2, 0, 0, 1401, 1411, 3, 232, 116, 0, 1402, 1404, 5, 87, 0, 0, 1403, 1405, 3, 92, 46, 0, 1404, 1403, 1, 0, 0, 0, 1404, 1405, 1, 0, 0, 0, 1405, 1406, 1, 0, 0, 0, 1406, 1408, 5, 88, 0, 0, 1407, 1409, 3, 204, 102, 0, 1408, 1407, 1, 0, 0, 0, 1408, 1409, 1, 0, 0, 0, 1409, 1411, 1, 0, 0, 0, 1410, 1401, 1, 0, 0, 0, 1410, 1402, 1, 0, 0, 0, 1411, 1413, 1, 0, 0, 0, 1412, 1400, 1, 0, 0, 0, 1413, 1416, 1, 0, 0, 0, 1414, 1412, 1, 0, 0, 0, 1414, 1415, 1, 0, 0, 0, 1415, 231, 1, 0, 0, 0, 1416, 1414, 1, 0, 0, 0, 1417, 1419, 5, 85, 0, 0, 1418, 1420, 3, 258, 129, 0, 1419, 1418, 1, 0, 0, 0, 1419, 1420, 1, 0, 0, 0, 1420, 1421, 1, 0, 0, 0, 1421, 1423, 5, 86, 0, 0, 1422, 1424, 3, 238, 119, 0, 1423, 1422, 1, 0, 0, 0, 1423, 1424, 1, 0, 0, 0, 1424, 1426, 1, 0, 0, 0, 1425, 1427, 3, 242, 121, 0, 1426, 1425, 1, 0, 0, 0, 1426, 1427, 1, 0, 0, 0, 1427, 1429, 1, 0, 0, 0, 1428, 1430, 3, 370, 185, 0, 1429, 1428, 1, 0, 0, 0, 1429, 1430, 1, 0, 0, 0, 1430, 1432, 1, 0, 0, 0, 1431, 1433, 3, 204, 102, 0, 1432, 1431, 1, 0, 0, 0, 1432, 1433, 1, 0, 0, 0, 1433, 233, 1, 0, 0, 0, 1434, 1435, 5, 124, 0, 0, 1435, 1437, 3, 152, 76, 0, 1436, 1438, 3, 248, 124, 0, 1437, 1436, 1, 0, 0, 0, 1437, 1438, 1, 0, 0, 0, 1438, 235, 1, 0, 0, 0, 1439, 1441, 7, 17, 0, 0, 1440, 1442, 3, 204, 102, 0, 1441, 1440, 1, 0, 0, 0, 1441, 1442, 1, 0, 0, 0, 1442, 1454, 1, 0, 0, 0, 1443, 1445, 3, 10, 5, 0, 1444, 1443, 1, 0, 0, 0, 1444, 1445, 1, 0, 0, 0, 1445, 1446, 1, 0, 0, 0, 1446, 1448, 5, 93, 0, 0, 1447, 1449, 3, 204, 102, 0, 1448, 1447, 1, 0, 0, 0, 1448, 1449, 1, 0, 0, 0, 1449, 1451, 1, 0, 0, 0, 1450, 1452, 3, 238, 119, 0, 1451, 1450, 1, 0, 0, 0, 1451, 1452, 1, 0, 0, 0, 1452, 1454, 1, 0, 0, 0, 1453, 1439, 1, 0, 0, 0, 1453, 1444, 1, 0, 0, 0, 1454, 237, 1, 0, 0, 0, 1455, 1457, 3, 240, 120, 0, 1456, 1455, 1, 0, 0, 0, 1457, 1458, 1, 0, 0, 0, 1458, 1456, 1, 0, 0, 0, 1458, 1459, 1, 0, 0, 0, 1459, 239, 1, 0, 0, 0, 1460, 1461, 7, 18, 0, 0, 1461, 241, 1, 0, 0, 0, 1462, 1463, 7, 17, 0, 0, 1463, 243, 1, 0, 0, 0, 1464, 1466, 5, 131, 0, 0, 1465, 1464, 1, 0, 0, 0, 1465, 1466, 1, 0, 0, 0, 1466, 1467, 1, 0, 0, 0, 1467, 1468, 3, 4, 2, 0, 1468, 245, 1, 0, 0, 0, 1469, 1471, 3, 150, 75, 0, 1470, 1472, 3, 248, 124, 0, 1471, 1470, 1, 0, 0, 0, 1471, 1472, 1, 0, 0, 0, 1472, 247, 1, 0, 0, 0, 1473, 1482, 3, 250, 125, 0, 1474, 1476, 3, 252, 126, 0, 1475, 1474, 1, 0, 0, 0, 1475, 1476, 1, 0, 0, 0, 1476, 1477, 1, 0, 0, 0, 1477, 1478, 3, 232, 116, 0, 1478, 1479, 3, 234, 117, 0, 1479, 1482, 1, 0, 0, 0, 1480, 1482, 3, 254, 127, 0, 1481, 1473, 1, 0, 0, 0, 1481, 1475, 1, 0, 0, 0, 1481, 1480, 1, 0, 0, 0, 1482, 249, 1, 0, 0, 0, 1483, 1485, 3, 236, 118, 0, 1484, 1483, 1, 0, 0, 0, 1485, 1488, 1, 0, 0, 0, 1486, 1484, 1, 0, 0, 0, 1486, 1487, 1, 0, 0, 0, 1487, 1491, 1, 0, 0, 0, 1488, 1486, 1, 0, 0, 0, 1489, 1492, 3, 252, 126, 0, 1490, 1492, 3, 236, 118, 0, 1491, 1489, 1, 0, 0, 0, 1491, 1490, 1, 0, 0, 0, 1492, 251, 1, 0, 0, 0, 1493, 1499, 3, 232, 116, 0, 1494, 1495, 5, 85, 0, 0, 1495, 1496, 3, 250, 125, 0, 1496, 1497, 5, 86, 0, 0, 1497, 1499, 1, 0, 0, 0, 1498, 1493, 1, 0, 0, 0, 1498, 1494, 1, 0, 0, 0, 1499, 1511, 1, 0, 0, 0, 1500, 1510, 3, 232, 116, 0, 1501, 1503, 5, 87, 0, 0, 1502, 1504, 3, 92, 46, 0, 1503, 1502, 1, 0, 0, 0, 1503, 1504, 1, 0, 0, 0, 1504, 1505, 1, 0, 0, 0, 1505, 1507, 5, 88, 0, 0, 1506, 1508, 3, 204, 102, 0, 1507, 1506, 1, 0, 0, 0, 1507, 1508, 1, 0, 0, 0, 1508, 1510, 1, 0, 0, 0, 1509, 1500, 1, 0, 0, 0, 1509, 1501, 1, 0, 0, 0, 1510, 1513, 1, 0, 0, 0, 1511, 1509, 1, 0, 0, 0, 1511, 1512, 1, 0, 0, 0, 1512, 253, 1, 0, 0, 0, 1513, 1511, 1, 0, 0, 0, 1514, 1516, 3, 236, 118, 0, 1515, 1514, 1, 0, 0, 0, 1516, 1519, 1, 0, 0, 0, 1517, 1515, 1, 0, 0, 0, 1517, 1518, 1, 0, 0, 0, 1518, 1520, 1, 0, 0, 0, 1519, 1517, 1, 0, 0, 0, 1520, 1521, 3, 256, 128, 0, 1521, 255, 1, 0, 0, 0, 1522, 1534, 5, 131, 0, 0, 1523, 1533, 3, 232, 116, 0, 1524, 1526, 5, 87, 0, 0, 1525, 1527, 3, 92, 46, 0, 1526, 1525, 1, 0, 0, 0, 1526, 1527, 1, 0, 0, 0, 1527, 1528, 1, 0, 0, 0, 1528, 1530, 5, 88, 0, 0, 1529, 1531, 3, 204, 102, 0, 1530, 1529, 1, 0, 0, 0, 1530, 1531, 1, 0, 0, 0, 1531, 1533, 1, 0, 0, 0, 1532, 1523, 1, 0, 0, 0, 1532, 1524, 1, 0, 0, 0, 1533, 1536, 1, 0, 0, 0, 1534, 1532, 1, 0, 0, 0, 1534, 1535, 1, 0, 0, 0, 1535, 257, 1, 0, 0, 0, 1536, 1534, 1, 0, 0, 0, 1537, 1542, 3, 260, 130, 0, 1538, 1540, 5, 122, 0, 0, 1539, 1538, 1, 0, 0, 0, 1539, 1540, 1, 0, 0, 0, 1540, 1541, 1, 0, 0, 0, 1541, 1543, 5, 131, 0, 0, 1542, 1539, 1, 0, 0, 0, 1542, 1543, 1, 0, 0, 0, 1543, 259, 1, 0, 0, 0, 1544, 1549, 3, 262, 131, 0, 1545, 1546, 5, 122, 0, 0, 1546, 1548, 3, 262, 131, 0, 1547, 1545, 1, 0, 0, 0, 1548, 1551, 1, 0, 0, 0, 1549, 1547, 1, 0, 0, 0, 1549, 1550, 1, 0, 0, 0, 1550, 261, 1, 0, 0, 0, 1551, 1549, 1, 0, 0, 0, 1552, 1554, 3, 204, 102, 0, 1553, 1552, 1, 0, 0, 0, 1553, 1554, 1, 0, 0, 0, 1554, 1555, 1, 0, 0, 0, 1555, 1560, 3, 138, 69, 0, 1556, 1561, 3, 226, 113, 0, 1557, 1559, 3, 248, 124, 0, 1558, 1557, 1, 0, 0, 0, 1558, 1559, 1, 0, 0, 0, 1559, 1561, 1, 0, 0, 0, 1560, 1556, 1, 0, 0, 0, 1560, 1558, 1, 0, 0, 0, 1561, 1564, 1, 0, 0, 0, 1562, 1563, 5, 101, 0, 0, 1563, 1565, 3, 272, 136, 0, 1564, 1562, 1, 0, 0, 0, 1564, 1565, 1, 0, 0, 0, 1565, 263, 1, 0, 0, 0, 1566, 1568, 3, 204, 102, 0, 1567, 1566, 1, 0, 0, 0, 1567, 1568, 1, 0, 0, 0, 1568, 1570, 1, 0, 0, 0, 1569, 1571, 3, 138, 69, 0, 1570, 1569, 1, 0, 0, 0, 1570, 1571, 1, 0, 0, 0, 1571, 1572, 1, 0, 0, 0, 1572, 1574, 3, 226, 113, 0, 1573, 1575, 3, 298, 149, 0, 1574, 1573, 1, 0, 0, 0, 1574, 1575, 1, 0, 0, 0, 1575, 1576, 1, 0, 0, 0, 1576, 1577, 3, 266, 133, 0, 1577, 265, 1, 0, 0, 0, 1578, 1580, 3, 322, 161, 0, 1579, 1578, 1, 0, 0, 0, 1579, 1580, 1, 0, 0, 0, 1580, 1581, 1, 0, 0, 0, 1581, 1587, 3, 100, 50, 0, 1582, 1587, 3, 360, 180, 0, 1583, 1584, 5, 101, 0, 0, 1584, 1585, 7, 19, 0, 0, 1585, 1587, 5, 128, 0, 0, 1586, 1579, 1, 0, 0, 0, 1586, 1582, 1, 0, 0, 0, 1586, 1583, 1, 0, 0, 0, 1587, 267, 1, 0, 0, 0, 1588, 1594, 3, 270, 135, 0, 1589, 1590, 5, 85, 0, 0, 1590, 1591, 3, 34, 17, 0, 1591, 1592, 5, 86, 0, 0, 1592, 1594, 1, 0, 0, 0, 1593, 1588, 1, 0, 0, 0, 1593, 1589, 1, 0, 0, 0, 1594, 269, 1, 0, 0, 0, 1595, 1596, 5, 101, 0, 0, 1596, 1599, 3, 272, 136, 0, 1597, 1599, 3, 276, 138, 0, 1598, 1595, 1, 0, 0, 0, 1598, 1597, 1, 0, 0, 0, 1599, 271, 1, 0, 0, 0, 1600, 1603, 3, 86, 43, 0, 1601, 1603, 3, 276, 138, 0, 1602, 1600, 1, 0, 0, 0, 1602, 1601, 1, 0, 0, 0, 1603, 273, 1, 0, 0, 0, 1604, 1606, 3, 272, 136, 0, 1605, 1607, 5, 131, 0, 0, 1606, 1605, 1, 0, 0, 0, 1606, 1607, 1, 0, 0, 0, 1607, 1615, 1, 0, 0, 0, 1608, 1609, 5, 122, 0, 0, 1609, 1611, 3, 272, 136, 0, 1610, 1612, 5, 131, 0, 0, 1611, 1610, 1, 0, 0, 0, 1611, 1612, 1, 0, 0, 0, 1612, 1614, 1, 0, 0, 0, 1613, 1608, 1, 0, 0, 0, 1614, 1617, 1, 0, 0, 0, 1615, 1613, 1, 0, 0, 0, 1615, 1616, 1, 0, 0, 0, 1616, 275, 1, 0, 0, 0, 1617, 1615, 1, 0, 0, 0, 1618, 1623, 5, 89, 0, 0, 1619, 1621, 3, 274, 137, 0, 1620, 1622, 5, 122, 0, 0, 1621, 1620, 1, 0, 0, 0, 1621, 1622, 1, 0, 0, 0, 1622, 1624, 1, 0, 0, 0, 1623, 1619, 1, 0, 0, 0, 1623, 1624, 1, 0, 0, 0, 1624, 1625, 1, 0, 0, 0, 1625, 1626, 5, 90, 0, 0, 1626, 277, 1, 0, 0, 0, 1627, 1630, 5, 132, 0, 0, 1628, 1630, 3, 342, 171, 0, 1629, 1627, 1, 0, 0, 0, 1629, 1628, 1, 0, 0, 0, 1630, 279, 1, 0, 0, 0, 1631, 1632, 3, 282, 141, 0, 1632, 1634, 5, 89, 0, 0, 1633, 1635, 3, 290, 145, 0, 1634, 1633, 1, 0, 0, 0, 1634, 1635, 1, 0, 0, 0, 1635, 1636, 1, 0, 0, 0, 1636, 1637, 5, 90, 0, 0, 1637, 281, 1, 0, 0, 0, 1638, 1640, 3, 288, 144, 0, 1639, 1641, 3, 204, 102, 0, 1640, 1639, 1, 0, 0, 0, 1640, 1641, 1, 0, 0, 0, 1641, 1646, 1, 0, 0, 0, 1642, 1644, 3, 284, 142, 0, 1643, 1645, 3, 286, 143, 0, 1644, 1643, 1, 0, 0, 0, 1644, 1645, 1, 0, 0, 0, 1645, 1647, 1, 0, 0, 0, 1646, 1642, 1, 0, 0, 0, 1646, 1647, 1, 0, 0, 0, 1647, 1649, 1, 0, 0, 0, 1648, 1650, 3, 304, 152, 0, 1649, 1648, 1, 0, 0, 0, 1649, 1650, 1, 0, 0, 0, 1650, 1662, 1, 0, 0, 0, 1651, 1653, 5, 77, 0, 0, 1652, 1654, 3, 204, 102, 0, 1653, 1652, 1, 0, 0, 0, 1653, 1654, 1, 0, 0, 0, 1654, 1659, 1, 0, 0, 0, 1655, 1657, 3, 284, 142, 0, 1656, 1658, 3, 286, 143, 0, 1657, 1656, 1, 0, 0, 0, 1657, 1658, 1, 0, 0, 0, 1658, 1660, 1, 0, 0, 0, 1659, 1655, 1, 0, 0, 0, 1659, 1660, 1, 0, 0, 0, 1660, 1662, 1, 0, 0, 0, 1661, 1638, 1, 0, 0, 0, 1661, 1651, 1, 0, 0, 0, 1662, 283, 1, 0, 0, 0, 1663, 1665, 3, 10, 5, 0, 1664, 1663, 1, 0, 0, 0, 1664, 1665, 1, 0, 0, 0, 1665, 1666, 1, 0, 0, 0, 1666, 1667, 3, 278, 139, 0, 1667, 285, 1, 0, 0, 0, 1668, 1669, 5, 38, 0, 0, 1669, 287, 1, 0, 0, 0, 1670, 1671, 7, 15, 0, 0, 1671, 289, 1, 0, 0, 0, 1672, 1677, 3, 292, 146, 0, 1673, 1674, 3, 314, 157, 0, 1674, 1675, 5, 126, 0, 0, 1675, 1677, 1, 0, 0, 0, 1676, 1672, 1, 0, 0, 0, 1676, 1673, 1, 0, 0, 0, 1677, 1678, 1, 0, 0, 0, 1678, 1676, 1, 0, 0, 0, 1678, 1679, 1, 0, 0, 0, 1679, 291, 1, 0, 0, 0, 1680, 1682, 3, 204, 102, 0, 1681, 1680, 1, 0, 0, 0, 1681, 1682, 1, 0, 0, 0, 1682, 1684, 1, 0, 0, 0, 1683, 1685, 3, 138, 69, 0, 1684, 1683, 1, 0, 0, 0, 1684, 1685, 1, 0, 0, 0, 1685, 1687, 1, 0, 0, 0, 1686, 1688, 3, 294, 147, 0, 1687, 1686, 1, 0, 0, 0, 1687, 1688, 1, 0, 0, 0, 1688, 1689, 1, 0, 0, 0, 1689, 1697, 5, 128, 0, 0, 1690, 1697, 3, 264, 132, 0, 1691, 1697, 3, 196, 98, 0, 1692, 1697, 3, 130, 65, 0, 1693, 1697, 3, 334, 167, 0, 1694, 1697, 3, 126, 63, 0, 1695, 1697, 3, 132, 66, 0, 1696, 1681, 1, 0, 0, 0, 1696, 1690, 1, 0, 0, 0, 1696, 1691, 1, 0, 0, 0, 1696, 1692, 1, 0, 0, 0, 1696, 1693, 1, 0, 0, 0, 1696, 1694, 1, 0, 0, 0, 1696, 1695, 1, 0, 0, 0, 1697, 293, 1, 0, 0, 0, 1698, 1703, 3, 296, 148, 0, 1699, 1700, 5, 122, 0, 0, 1700, 1702, 3, 296, 148, 0, 1701, 1699, 1, 0, 0, 0, 1702, 1705, 1, 0, 0, 0, 1703, 1701, 1, 0, 0, 0, 1703, 1704, 1, 0, 0, 0, 1704, 295, 1, 0, 0, 0, 1705, 1703, 1, 0, 0, 0, 1706, 1715, 3, 226, 113, 0, 1707, 1716, 3, 298, 149, 0, 1708, 1709, 4, 148, 7, 0, 1709, 1716, 3, 302, 151, 0, 1710, 1711, 4, 148, 8, 0, 1711, 1712, 3, 298, 149, 0, 1712, 1713, 3, 302, 151, 0, 1713, 1716, 1, 0, 0, 0, 1714, 1716, 3, 270, 135, 0, 1715, 1707, 1, 0, 0, 0, 1715, 1708, 1, 0, 0, 0, 1715, 1710, 1, 0, 0, 0, 1715, 1714, 1, 0, 0, 0, 1716, 1727, 1, 0, 0, 0, 1717, 1727, 3, 226, 113, 0, 1718, 1720, 5, 132, 0, 0, 1719, 1718, 1, 0, 0, 0, 1719, 1720, 1, 0, 0, 0, 1720, 1722, 1, 0, 0, 0, 1721, 1723, 3, 204, 102, 0, 1722, 1721, 1, 0, 0, 0, 1722, 1723, 1, 0, 0, 0, 1723, 1724, 1, 0, 0, 0, 1724, 1725, 5, 126, 0, 0, 1725, 1727, 3, 92, 46, 0, 1726, 1706, 1, 0, 0, 0, 1726, 1717, 1, 0, 0, 0, 1726, 1719, 1, 0, 0, 0, 1727, 297, 1, 0, 0, 0, 1728, 1730, 3, 300, 150, 0, 1729, 1728, 1, 0, 0, 0, 1730, 1731, 1, 0, 0, 0, 1731, 1729, 1, 0, 0, 0, 1731, 1732, 1, 0, 0, 0, 1732, 299, 1, 0, 0, 0, 1733, 1734, 7, 20, 0, 0, 1734, 301, 1, 0, 0, 0, 1735, 1736, 5, 101, 0, 0, 1736, 1737, 5, 1, 0, 0, 1737, 303, 1, 0, 0, 0, 1738, 1739, 5, 126, 0, 0, 1739, 1740, 3, 306, 153, 0, 1740, 305, 1, 0, 0, 0, 1741, 1743, 3, 308, 154, 0, 1742, 1744, 5, 131, 0, 0, 1743, 1742, 1, 0, 0, 0, 1743, 1744, 1, 0, 0, 0, 1744, 1752, 1, 0, 0, 0, 1745, 1746, 5, 122, 0, 0, 1746, 1748, 3, 308, 154, 0, 1747, 1749, 5, 131, 0, 0, 1748, 1747, 1, 0, 0, 0, 1748, 1749, 1, 0, 0, 0, 1749, 1751, 1, 0, 0, 0, 1750, 1745, 1, 0, 0, 0, 1751, 1754, 1, 0, 0, 0, 1752, 1750, 1, 0, 0, 0, 1752, 1753, 1, 0, 0, 0, 1753, 307, 1, 0, 0, 0, 1754, 1752, 1, 0, 0, 0, 1755, 1757, 3, 204, 102, 0, 1756, 1755, 1, 0, 0, 0, 1756, 1757, 1, 0, 0, 0, 1757, 1770, 1, 0, 0, 0, 1758, 1771, 3, 312, 156, 0, 1759, 1761, 5, 80, 0, 0, 1760, 1762, 3, 314, 157, 0, 1761, 1760, 1, 0, 0, 0, 1761, 1762, 1, 0, 0, 0, 1762, 1763, 1, 0, 0, 0, 1763, 1771, 3, 312, 156, 0, 1764, 1766, 3, 314, 157, 0, 1765, 1767, 5, 80, 0, 0, 1766, 1765, 1, 0, 0, 0, 1766, 1767, 1, 0, 0, 0, 1767, 1768, 1, 0, 0, 0, 1768, 1769, 3, 312, 156, 0, 1769, 1771, 1, 0, 0, 0, 1770, 1758, 1, 0, 0, 0, 1770, 1759, 1, 0, 0, 0, 1770, 1764, 1, 0, 0, 0, 1771, 309, 1, 0, 0, 0, 1772, 1774, 3, 10, 5, 0, 1773, 1772, 1, 0, 0, 0, 1773, 1774, 1, 0, 0, 0, 1774, 1775, 1, 0, 0, 0, 1775, 1778, 3, 278, 139, 0, 1776, 1778, 3, 162, 81, 0, 1777, 1773, 1, 0, 0, 0, 1777, 1776, 1, 0, 0, 0, 1778, 311, 1, 0, 0, 0, 1779, 1780, 3, 310, 155, 0, 1780, 313, 1, 0, 0, 0, 1781, 1782, 7, 21, 0, 0, 1782, 315, 1, 0, 0, 0, 1783, 1784, 5, 52, 0, 0, 1784, 1785, 3, 318, 159, 0, 1785, 317, 1, 0, 0, 0, 1786, 1788, 3, 150, 75, 0, 1787, 1789, 3, 320, 160, 0, 1788, 1787, 1, 0, 0, 0, 1788, 1789, 1, 0, 0, 0, 1789, 319, 1, 0, 0, 0, 1790, 1792, 3, 236, 118, 0, 1791, 1793, 3, 320, 160, 0, 1792, 1791, 1, 0, 0, 0, 1792, 1793, 1, 0, 0, 0, 1793, 321, 1, 0, 0, 0, 1794, 1795, 5, 126, 0, 0, 1795, 1796, 3, 324, 162, 0, 1796, 323, 1, 0, 0, 0, 1797, 1799, 3, 326, 163, 0, 1798, 1800, 5, 131, 0, 0, 1799, 1798, 1, 0, 0, 0, 1799, 1800, 1, 0, 0, 0, 1800, 1808, 1, 0, 0, 0, 1801, 1802, 5, 122, 0, 0, 1802, 1804, 3, 326, 163, 0, 1803, 1805, 5, 131, 0, 0, 1804, 1803, 1, 0, 0, 0, 1804, 1805, 1, 0, 0, 0, 1805, 1807, 1, 0, 0, 0, 1806, 1801, 1, 0, 0, 0, 1807, 1810, 1, 0, 0, 0, 1808, 1806, 1, 0, 0, 0, 1808, 1809, 1, 0, 0, 0, 1809, 325, 1, 0, 0, 0, 1810, 1808, 1, 0, 0, 0, 1811, 1818, 3, 328, 164, 0, 1812, 1814, 5, 85, 0, 0, 1813, 1815, 3, 34, 17, 0, 1814, 1813, 1, 0, 0, 0, 1814, 1815, 1, 0, 0, 0, 1815, 1816, 1, 0, 0, 0, 1816, 1819, 5, 86, 0, 0, 1817, 1819, 3, 276, 138, 0, 1818, 1812, 1, 0, 0, 0, 1818, 1817, 1, 0, 0, 0, 1819, 327, 1, 0, 0, 0, 1820, 1823, 3, 310, 155, 0, 1821, 1823, 5, 132, 0, 0, 1822, 1820, 1, 0, 0, 0, 1822, 1821, 1, 0, 0, 0, 1823, 329, 1, 0, 0, 0, 1824, 1825, 5, 52, 0, 0, 1825, 1826, 3, 378, 189, 0, 1826, 331, 1, 0, 0, 0, 1827, 1831, 5, 52, 0, 0, 1828, 1829, 5, 4, 0, 0, 1829, 1832, 5, 132, 0, 0, 1830, 1832, 5, 140, 0, 0, 1831, 1828, 1, 0, 0, 0, 1831, 1830, 1, 0, 0, 0, 1832, 333, 1, 0, 0, 0, 1833, 1834, 5, 68, 0, 0, 1834, 1835, 5, 102, 0, 0, 1835, 1836, 3, 336, 168, 0, 1836, 1837, 5, 103, 0, 0, 1837, 1838, 3, 122, 61, 0, 1838, 335, 1, 0, 0, 0, 1839, 1844, 3, 338, 169, 0, 1840, 1841, 5, 122, 0, 0, 1841, 1843, 3, 338, 169, 0, 1842, 1840, 1, 0, 0, 0, 1843, 1846, 1, 0, 0, 0, 1844, 1842, 1, 0, 0, 0, 1844, 1845, 1, 0, 0, 0, 1845, 337, 1, 0, 0, 0, 1846, 1844, 1, 0, 0, 0, 1847, 1850, 3, 340, 170, 0, 1848, 1850, 3, 262, 131, 0, 1849, 1847, 1, 0, 0, 0, 1849, 1848, 1, 0, 0, 0, 1850, 339, 1, 0, 0, 0, 1851, 1852, 5, 68, 0, 0, 1852, 1853, 5, 102, 0, 0, 1853, 1854, 3, 336, 168, 0, 1854, 1855, 5, 103, 0, 0, 1855, 1857, 1, 0, 0, 0, 1856, 1851, 1, 0, 0, 0, 1856, 1857, 1, 0, 0, 0, 1857, 1858, 1, 0, 0, 0, 1858, 1861, 5, 21, 0, 0, 1859, 1861, 5, 76, 0, 0, 1860, 1856, 1, 0, 0, 0, 1860, 1859, 1, 0, 0, 0, 1861, 1873, 1, 0, 0, 0, 1862, 1864, 5, 131, 0, 0, 1863, 1862, 1, 0, 0, 0, 1863, 1864, 1, 0, 0, 0, 1864, 1866, 1, 0, 0, 0, 1865, 1867, 5, 132, 0, 0, 1866, 1865, 1, 0, 0, 0, 1866, 1867, 1, 0, 0, 0, 1867, 1874, 1, 0, 0, 0, 1868, 1870, 5, 132, 0, 0, 1869, 1868, 1, 0, 0, 0, 1869, 1870, 1, 0, 0, 0, 1870, 1871, 1, 0, 0, 0, 1871, 1872, 5, 101, 0, 0, 1872, 1874, 3, 246, 123, 0, 1873, 1863, 1, 0, 0, 0, 1873, 1869, 1, 0, 0, 0, 1874, 341, 1, 0, 0, 0, 1875, 1876, 3, 346, 173, 0, 1876, 1878, 5, 102, 0, 0, 1877, 1879, 3, 348, 174, 0, 1878, 1877, 1, 0, 0, 0, 1878, 1879, 1, 0, 0, 0, 1879, 1880, 1, 0, 0, 0, 1880, 1881, 5, 103, 0, 0, 1881, 343, 1, 0, 0, 0, 1882, 1894, 3, 342, 171, 0, 1883, 1886, 3, 330, 165, 0, 1884, 1886, 3, 332, 166, 0, 1885, 1883, 1, 0, 0, 0, 1885, 1884, 1, 0, 0, 0, 1886, 1887, 1, 0, 0, 0, 1887, 1889, 5, 102, 0, 0, 1888, 1890, 3, 348, 174, 0, 1889, 1888, 1, 0, 0, 0, 1889, 1890, 1, 0, 0, 0, 1890, 1891, 1, 0, 0, 0, 1891, 1892, 5, 103, 0, 0, 1892, 1894, 1, 0, 0, 0, 1893, 1882, 1, 0, 0, 0, 1893, 1885, 1, 0, 0, 0, 1894, 345, 1, 0, 0, 0, 1895, 1896, 5, 132, 0, 0, 1896, 347, 1, 0, 0, 0, 1897, 1899, 3, 350, 175, 0, 1898, 1900, 5, 131, 0, 0, 1899, 1898, 1, 0, 0, 0, 1899, 1900, 1, 0, 0, 0, 1900, 1908, 1, 0, 0, 0, 1901, 1902, 5, 122, 0, 0, 1902, 1904, 3, 350, 175, 0, 1903, 1905, 5, 131, 0, 0, 1904, 1903, 1, 0, 0, 0, 1904, 1905, 1, 0, 0, 0, 1905, 1907, 1, 0, 0, 0, 1906, 1901, 1, 0, 0, 0, 1907, 1910, 1, 0, 0, 0, 1908, 1906, 1, 0, 0, 0, 1908, 1909, 1, 0, 0, 0, 1909, 349, 1, 0, 0, 0, 1910, 1908, 1, 0, 0, 0, 1911, 1915, 3, 246, 123, 0, 1912, 1915, 3, 92, 46, 0, 1913, 1915, 3, 4, 2, 0, 1914, 1911, 1, 0, 0, 0, 1914, 1912, 1, 0, 0, 0, 1914, 1913, 1, 0, 0, 0, 1915, 351, 1, 0, 0, 0, 1916, 1917, 5, 76, 0, 0, 1917, 1923, 3, 10, 5, 0, 1918, 1924, 5, 132, 0, 0, 1919, 1921, 5, 68, 0, 0, 1920, 1919, 1, 0, 0, 0, 1920, 1921, 1, 0, 0, 0, 1921, 1922, 1, 0, 0, 0, 1922, 1924, 3, 342, 171, 0, 1923, 1918, 1, 0, 0, 0, 1923, 1920, 1, 0, 0, 0, 1924, 353, 1, 0, 0, 0, 1925, 1927, 5, 36, 0, 0, 1926, 1925, 1, 0, 0, 0, 1926, 1927, 1, 0, 0, 0, 1927, 1928, 1, 0, 0, 0, 1928, 1929, 5, 68, 0, 0, 1929, 1930, 3, 122, 61, 0, 1930, 355, 1, 0, 0, 0, 1931, 1932, 5, 68, 0, 0, 1932, 1933, 5, 102, 0, 0, 1933, 1934, 5, 103, 0, 0, 1934, 1935, 3, 122, 61, 0, 1935, 357, 1, 0, 0, 0, 1936, 1937, 5, 73, 0, 0, 1937, 1938, 3, 100, 50, 0, 1938, 1939, 3, 362, 181, 0, 1939, 359, 1, 0, 0, 0, 1940, 1942, 5, 73, 0, 0, 1941, 1943, 3, 322, 161, 0, 1942, 1941, 1, 0, 0, 0, 1942, 1943, 1, 0, 0, 0, 1943, 1944, 1, 0, 0, 0, 1944, 1945, 3, 100, 50, 0, 1945, 1946, 3, 362, 181, 0, 1946, 361, 1, 0, 0, 0, 1947, 1949, 3, 364, 182, 0, 1948, 1947, 1, 0, 0, 0, 1949, 1950, 1, 0, 0, 0, 1950, 1948, 1, 0, 0, 0, 1950, 1951, 1, 0, 0, 0, 1951, 363, 1, 0, 0, 0, 1952, 1953, 5, 17, 0, 0, 1953, 1954, 5, 85, 0, 0, 1954, 1955, 3, 366, 183, 0, 1955, 1956, 5, 86, 0, 0, 1956, 1957, 3, 100, 50, 0, 1957, 365, 1, 0, 0, 0, 1958, 1960, 3, 204, 102, 0, 1959, 1958, 1, 0, 0, 0, 1959, 1960, 1, 0, 0, 0, 1960, 1961, 1, 0, 0, 0, 1961, 1964, 3, 150, 75, 0, 1962, 1965, 3, 226, 113, 0, 1963, 1965, 3, 248, 124, 0, 1964, 1962, 1, 0, 0, 0, 1964, 1963, 1, 0, 0, 0, 1964, 1965, 1, 0, 0, 0, 1965, 1968, 1, 0, 0, 0, 1966, 1968, 5, 131, 0, 0, 1967, 1959, 1, 0, 0, 0, 1967, 1966, 1, 0, 0, 0, 1968, 367, 1, 0, 0, 0, 1969, 1971, 5, 71, 0, 0, 1970, 1972, 3, 86, 43, 0, 1971, 1970, 1, 0, 0, 0, 1971, 1972, 1, 0, 0, 0, 1972, 369, 1, 0, 0, 0, 1973, 1976, 3, 372, 186, 0, 1974, 1976, 3, 376, 188, 0, 1975, 1973, 1, 0, 0, 0, 1975, 1974, 1, 0, 0, 0, 1976, 371, 1, 0, 0, 0, 1977, 1978, 5, 71, 0, 0, 1978, 1980, 5, 85, 0, 0, 1979, 1981, 3, 374, 187, 0, 1980, 1979, 1, 0, 0, 0, 1980, 1981, 1, 0, 0, 0, 1981, 1982, 1, 0, 0, 0, 1982, 1983, 5, 86, 0, 0, 1983, 373, 1, 0, 0, 0, 1984, 1986, 3, 246, 123, 0, 1985, 1987, 5, 131, 0, 0, 1986, 1985, 1, 0, 0, 0, 1986, 1987, 1, 0, 0, 0, 1987, 1995, 1, 0, 0, 0, 1988, 1989, 5, 122, 0, 0, 1989, 1991, 3, 246, 123, 0, 1990, 1992, 5, 131, 0, 0, 1991, 1990, 1, 0, 0, 0, 1991, 1992, 1, 0, 0, 0, 1992, 1994, 1, 0, 0, 0, 1993, 1988, 1, 0, 0, 0, 1994, 1997, 1, 0, 0, 0, 1995, 1993, 1, 0, 0, 0, 1995, 1996, 1, 0, 0, 0, 1996, 375, 1, 0, 0, 0, 1997, 1995, 1, 0, 0, 0, 1998, 1999, 5, 50, 0, 0, 1999, 2000, 5, 85, 0, 0, 2000, 2001, 3, 92, 46, 0, 2001, 2002, 5, 86, 0, 0, 2002, 2005, 1, 0, 0, 0, 2003, 2005, 5, 50, 0, 0, 2004, 1998, 1, 0, 0, 0, 2004, 2003, 1, 0, 0, 0, 2005, 377, 1, 0, 0, 0, 2006, 2009, 5, 49, 0, 0, 2007, 2008, 5, 87, 0, 0, 2008, 2010, 5, 88, 0, 0, 2009, 2007, 1, 0, 0, 0, 2009, 2010, 1, 0, 0, 0, 2010, 2058, 1, 0, 0, 0, 2011, 2014, 5, 28, 0, 0, 2012, 2013, 5, 87, 0, 0, 2013, 2015, 5, 88, 0, 0, 2014, 2012, 1, 0, 0, 0, 2014, 2015, 1, 0, 0, 0, 2015, 2058, 1, 0, 0, 0, 2016, 2058, 5, 91, 0, 0, 2017, 2058, 5, 92, 0, 0, 2018, 2058, 5, 93, 0, 0, 2019, 2058, 5, 94, 0, 0, 2020, 2058, 5, 95, 0, 0, 2021, 2058, 5, 96, 0, 0, 2022, 2058, 5, 97, 0, 0, 2023, 2058, 5, 98, 0, 0, 2024, 2058, 5, 99, 0, 0, 2025, 2058, 5, 100, 0, 0, 2026, 2058, 5, 101, 0, 0, 2027, 2058, 5, 103, 0, 0, 2028, 2058, 5, 102, 0, 0, 2029, 2058, 5, 117, 0, 0, 2030, 2058, 5, 104, 0, 0, 2031, 2058, 5, 105, 0, 0, 2032, 2058, 5, 106, 0, 0, 2033, 2058, 5, 108, 0, 0, 2034, 2058, 5, 109, 0, 0, 2035, 2058, 5, 110, 0, 0, 2036, 2058, 5, 111, 0, 0, 2037, 2038, 5, 102, 0, 0, 2038, 2058, 5, 102, 0, 0, 2039, 2040, 5, 103, 0, 0, 2040, 2058, 5, 103, 0, 0, 2041, 2058, 5, 113, 0, 0, 2042, 2058, 5, 112, 0, 0, 2043, 2058, 5, 114, 0, 0, 2044, 2058, 5, 115, 0, 0, 2045, 2058, 5, 116, 0, 0, 2046, 2058, 5, 118, 0, 0, 2047, 2058, 5, 119, 0, 0, 2048, 2058, 5, 120, 0, 0, 2049, 2058, 5, 121, 0, 0, 2050, 2058, 5, 122, 0, 0, 2051, 2058, 5, 123, 0, 0, 2052, 2058, 5, 124, 0, 0, 2053, 2054, 5, 85, 0, 0, 2054, 2058, 5, 86, 0, 0, 2055, 2056, 5, 87, 0, 0, 2056, 2058, 5, 88, 0, 0, 2057, 2006, 1, 0, 0, 0, 2057, 2011, 1, 0, 0, 0, 2057, 2016, 1, 0, 0, 0, 2057, 2017, 1, 0, 0, 0, 2057, 2018, 1, 0, 0, 0, 2057, 2019, 1, 0, 0, 0, 2057, 2020, 1, 0, 0, 0, 2057, 2021, 1, 0, 0, 0, 2057, 2022, 1, 0, 0, 0, 2057, 2023, 1, 0, 0, 0, 2057, 2024, 1, 0, 0, 0, 2057, 2025, 1, 0, 0, 0, 2057, 2026, 1, 0, 0, 0, 2057, 2027, 1, 0, 0, 0, 2057, 2028, 1, 0, 0, 0, 2057, 2029, 1, 0, 0, 0, 2057, 2030, 1, 0, 0, 0, 2057, 2031, 1, 0, 0, 0, 2057, 2032, 1, 0, 0, 0, 2057, 2033, 1, 0, 0, 0, 2057, 2034, 1, 0, 0, 0, 2057, 2035, 1, 0, 0, 0, 2057, 2036, 1, 0, 0, 0, 2057, 2037, 1, 0, 0, 0, 2057, 2039, 1, 0, 0, 0, 2057, 2041, 1, 0, 0, 0, 2057, 2042, 1, 0, 0, 0, 2057, 2043, 1, 0, 0, 0, 2057, 2044, 1, 0, 0, 0, 2057, 2045, 1, 0, 0, 0, 2057, 2046, 1, 0, 0, 0, 2057, 2047, 1, 0, 0, 0, 2057, 2048, 1, 0, 0, 0, 2057, 2049, 1, 0, 0, 0, 2057, 2050, 1, 0, 0, 0, 2057, 2051, 1, 0, 0, 0, 2057, 2052, 1, 0, 0, 0, 2057, 2053, 1, 0, 0, 0, 2057, 2055, 1, 0, 0, 0, 2058, 379, 1, 0, 0, 0, 2059, 2060, 7, 22, 0, 0, 2060, 381, 1, 0, 0, 0, 291, 383, 390, 399, 403, 412, 415, 419, 427, 434, 437, 442, 447, 453, 461, 463, 472, 476, 480, 483, 487, 490, 497, 501, 504, 507, 510, 516, 520, 524, 538, 542, 548, 555, 561, 565, 569, 571, 579, 584, 597, 604, 616, 626, 631, 635, 642, 645, 653, 657, 660, 667, 674, 678, 683, 687, 690, 695, 710, 717, 725, 733, 742, 749, 756, 764, 772, 780, 788, 796, 804, 813, 821, 830, 838, 846, 848, 851, 857, 863, 869, 876, 885, 893, 897, 904, 906, 926, 930, 936, 941, 945, 948, 955, 962, 966, 975, 986, 996, 1001, 1008, 1011, 1016, 1021, 1042, 1047, 1050, 1061, 1067, 1072, 1075, 1080, 1083, 1090, 1113, 1119, 1125, 1131, 1134, 1140, 1144, 1148, 1151, 1159, 1161, 1167, 1170, 1173, 1176, 1180, 1184, 1190, 1200, 1206, 1212, 1217, 1222, 1226, 1239, 1245, 1249, 1255, 1260, 1275, 1279, 1284, 1289, 1294, 1300, 1303, 1312, 1316, 1321, 1325, 1331, 1338, 1355, 1357, 1364, 1369, 1376, 1380, 1384, 1392, 1398, 1404, 1408, 1410, 1414, 1419, 1423, 1426, 1429, 1432, 1437, 1441, 1444, 1448, 1451, 1453, 1458, 1465, 1471, 1475, 1481, 1486, 1491, 1498, 1503, 1507, 1509, 1511, 1517, 1526, 1530, 1532, 1534, 1539, 1542, 1549, 1553, 1558, 1560, 1564, 1567, 1570, 1574, 1579, 1586, 1593, 1598, 1602, 1606, 1611, 1615, 1621, 1623, 1629, 1634, 1640, 1644, 1646, 1649, 1653, 1657, 1659, 1661, 1664, 1676, 1678, 1681, 1684, 1687, 1696, 1703, 1715, 1719, 1722, 1726, 1731, 1743, 1748, 1752, 1756, 1761, 1766, 1770, 1773, 1777, 1788, 1792, 1799, 1804, 1808, 1814, 1818, 1822, 1831, 1844, 1849, 1856, 1860, 1863, 1866, 1869, 1873, 1878, 1885, 1889, 1893, 1899, 1904, 1908, 1914, 1920, 1923, 1926, 1942, 1950, 1959, 1964, 1967, 1971, 1975, 1980, 1986, 1991, 1995, 2004, 2009, 2014, 2057]
```

`src/main/java/com/lauriewired/malimite/decompile/antlr/CPP14Parser.java`:

```java
// Generated from CPP14Parser.g4 by ANTLR 4.13.1
package com.lauriewired.malimite.decompile.antlr;
import org.antlr.v4.runtime.atn.*;
import org.antlr.v4.runtime.dfa.DFA;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.misc.*;
import org.antlr.v4.runtime.tree.*;
import java.util.List;
import java.util.Iterator;
import java.util.ArrayList;

@SuppressWarnings({"all", "warnings", "unchecked", "unused", "cast", "CheckReturnValue"})
public class CPP14Parser extends CPP14ParserBase {
	static { RuntimeMetaData.checkVersion("4.13.1", RuntimeMetaData.VERSION); }

	protected static final DFA[] _decisionToDFA;
	protected static final PredictionContextCache _sharedContextCache =
		new PredictionContextCache();
	public static final int
		IntegerLiteral=1, CharacterLiteral=2, FloatingLiteral=3, StringLiteral=4, 
		BooleanLiteral=5, PointerLiteral=6, UserDefinedLiteral=7, MultiLineMacro=8, 
		Directive=9, Alignas=10, Alignof=11, Asm=12, Auto=13, Bool=14, Break=15, 
		Case=16, Catch=17, Char=18, Char16=19, Char32=20, Class=21, Const=22, 
		Constexpr=23, Const_cast=24, Continue=25, Decltype=26, Default=27, Delete=28, 
		Do=29, Double=30, Dynamic_cast=31, Else=32, Enum=33, Explicit=34, Export=35, 
		Extern=36, False_=37, Final=38, Float=39, For=40, Friend=41, Goto=42, 
		If=43, Inline=44, Int=45, Long=46, Mutable=47, Namespace=48, New=49, Noexcept=50, 
		Nullptr=51, Operator=52, Override=53, Private=54, Protected=55, Public=56, 
		Register=57, Reinterpret_cast=58, Return=59, Short=60, Signed=61, Sizeof=62, 
		Static=63, Static_assert=64, Static_cast=65, Struct=66, Switch=67, Template=68, 
		This=69, Thread_local=70, Throw=71, True_=72, Try=73, Typedef=74, Typeid_=75, 
		Typename_=76, Union=77, Unsigned=78, Using=79, Virtual=80, Void=81, Volatile=82, 
		Wchar=83, While=84, LeftParen=85, RightParen=86, LeftBracket=87, RightBracket=88, 
		LeftBrace=89, RightBrace=90, Plus=91, Minus=92, Star=93, Div=94, Mod=95, 
		Caret=96, And=97, Or=98, Tilde=99, Not=100, Assign=101, Less=102, Greater=103, 
		PlusAssign=104, MinusAssign=105, StarAssign=106, DivAssign=107, ModAssign=108, 
		XorAssign=109, AndAssign=110, OrAssign=111, LeftShiftAssign=112, RightShiftAssign=113, 
		Equal=114, NotEqual=115, LessEqual=116, GreaterEqual=117, AndAnd=118, 
		OrOr=119, PlusPlus=120, MinusMinus=121, Comma=122, ArrowStar=123, Arrow=124, 
		Question=125, Colon=126, Doublecolon=127, Semi=128, Dot=129, DotStar=130, 
		Ellipsis=131, Identifier=132, DecimalLiteral=133, OctalLiteral=134, HexadecimalLiteral=135, 
		BinaryLiteral=136, Integersuffix=137, UserDefinedIntegerLiteral=138, UserDefinedFloatingLiteral=139, 
		UserDefinedStringLiteral=140, UserDefinedCharacterLiteral=141, Whitespace=142, 
		Newline=143, BlockComment=144, LineComment=145;
	public static final int
		RULE_translationUnit = 0, RULE_primaryExpression = 1, RULE_idExpression = 2, 
		RULE_unqualifiedId = 3, RULE_qualifiedId = 4, RULE_nestedNameSpecifier = 5, 
		RULE_lambdaExpression = 6, RULE_lambdaIntroducer = 7, RULE_lambdaCapture = 8, 
		RULE_captureDefault = 9, RULE_captureList = 10, RULE_capture = 11, RULE_simpleCapture = 12, 
		RULE_initcapture = 13, RULE_lambdaDeclarator = 14, RULE_postfixExpression = 15, 
		RULE_typeIdOfTheTypeId = 16, RULE_expressionList = 17, RULE_pseudoDestructorName = 18, 
		RULE_unaryExpression = 19, RULE_unaryOperator = 20, RULE_newExpression_ = 21, 
		RULE_newPlacement = 22, RULE_newTypeId = 23, RULE_newDeclarator_ = 24, 
		RULE_noPointerNewDeclarator = 25, RULE_newInitializer_ = 26, RULE_deleteExpression = 27, 
		RULE_noExceptExpression = 28, RULE_castExpression = 29, RULE_pointerMemberExpression = 30, 
		RULE_multiplicativeExpression = 31, RULE_additiveExpression = 32, RULE_shiftExpression = 33, 
		RULE_shiftOperator = 34, RULE_relationalExpression = 35, RULE_equalityExpression = 36, 
		RULE_andExpression = 37, RULE_exclusiveOrExpression = 38, RULE_inclusiveOrExpression = 39, 
		RULE_logicalAndExpression = 40, RULE_logicalOrExpression = 41, RULE_conditionalExpression = 42, 
		RULE_assignmentExpression = 43, RULE_assignmentOperator = 44, RULE_expression = 45, 
		RULE_constantExpression = 46, RULE_statement = 47, RULE_labeledStatement = 48, 
		RULE_expressionStatement = 49, RULE_compoundStatement = 50, RULE_statementSeq = 51, 
		RULE_selectionStatement = 52, RULE_condition = 53, RULE_iterationStatement = 54, 
		RULE_forInitStatement = 55, RULE_forRangeDeclaration = 56, RULE_forRangeInitializer = 57, 
		RULE_jumpStatement = 58, RULE_declarationStatement = 59, RULE_declarationseq = 60, 
		RULE_declaration = 61, RULE_blockDeclaration = 62, RULE_aliasDeclaration = 63, 
		RULE_simpleDeclaration = 64, RULE_staticAssertDeclaration = 65, RULE_emptyDeclaration_ = 66, 
		RULE_attributeDeclaration = 67, RULE_declSpecifier = 68, RULE_declSpecifierSeq = 69, 
		RULE_storageClassSpecifier = 70, RULE_functionSpecifier = 71, RULE_typedefName = 72, 
		RULE_typeSpecifier = 73, RULE_trailingTypeSpecifier = 74, RULE_typeSpecifierSeq = 75, 
		RULE_trailingTypeSpecifierSeq = 76, RULE_simpleTypeLengthModifier = 77, 
		RULE_simpleTypeSignednessModifier = 78, RULE_simpleTypeSpecifier = 79, 
		RULE_theTypeName = 80, RULE_decltypeSpecifier = 81, RULE_elaboratedTypeSpecifier = 82, 
		RULE_enumName = 83, RULE_enumSpecifier = 84, RULE_enumHead = 85, RULE_opaqueEnumDeclaration = 86, 
		RULE_enumkey = 87, RULE_enumbase = 88, RULE_enumeratorList = 89, RULE_enumeratorDefinition = 90, 
		RULE_enumerator = 91, RULE_namespaceName = 92, RULE_originalNamespaceName = 93, 
		RULE_namespaceDefinition = 94, RULE_namespaceAlias = 95, RULE_namespaceAliasDefinition = 96, 
		RULE_qualifiednamespacespecifier = 97, RULE_usingDeclaration = 98, RULE_usingDirective = 99, 
		RULE_asmDefinition = 100, RULE_linkageSpecification = 101, RULE_attributeSpecifierSeq = 102, 
		RULE_attributeSpecifier = 103, RULE_alignmentspecifier = 104, RULE_attributeList = 105, 
		RULE_attribute = 106, RULE_attributeNamespace = 107, RULE_attributeArgumentClause = 108, 
		RULE_balancedTokenSeq = 109, RULE_balancedtoken = 110, RULE_initDeclaratorList = 111, 
		RULE_initDeclarator = 112, RULE_declarator = 113, RULE_pointerDeclarator = 114, 
		RULE_noPointerDeclarator = 115, RULE_parametersAndQualifiers = 116, RULE_trailingReturnType = 117, 
		RULE_pointerOperator = 118, RULE_cvqualifierseq = 119, RULE_cvQualifier = 120, 
		RULE_refqualifier = 121, RULE_declaratorid = 122, RULE_theTypeId = 123, 
		RULE_abstractDeclarator = 124, RULE_pointerAbstractDeclarator = 125, RULE_noPointerAbstractDeclarator = 126, 
		RULE_abstractPackDeclarator = 127, RULE_noPointerAbstractPackDeclarator = 128, 
		RULE_parameterDeclarationClause = 129, RULE_parameterDeclarationList = 130, 
		RULE_parameterDeclaration = 131, RULE_functionDefinition = 132, RULE_functionBody = 133, 
		RULE_initializer = 134, RULE_braceOrEqualInitializer = 135, RULE_initializerClause = 136, 
		RULE_initializerList = 137, RULE_bracedInitList = 138, RULE_className = 139, 
		RULE_classSpecifier = 140, RULE_classHead = 141, RULE_classHeadName = 142, 
		RULE_classVirtSpecifier = 143, RULE_classKey = 144, RULE_memberSpecification = 145, 
		RULE_memberdeclaration = 146, RULE_memberDeclaratorList = 147, RULE_memberDeclarator = 148, 
		RULE_virtualSpecifierSeq = 149, RULE_virtualSpecifier = 150, RULE_pureSpecifier = 151, 
		RULE_baseClause = 152, RULE_baseSpecifierList = 153, RULE_baseSpecifier = 154, 
		RULE_classOrDeclType = 155, RULE_baseTypeSpecifier = 156, RULE_accessSpecifier = 157, 
		RULE_conversionFunctionId = 158, RULE_conversionTypeId = 159, RULE_conversionDeclarator = 160, 
		RULE_constructorInitializer = 161, RULE_memInitializerList = 162, RULE_memInitializer = 163, 
		RULE_meminitializerid = 164, RULE_operatorFunctionId = 165, RULE_literalOperatorId = 166, 
		RULE_templateDeclaration = 167, RULE_templateparameterList = 168, RULE_templateParameter = 169, 
		RULE_typeParameter = 170, RULE_simpleTemplateId = 171, RULE_templateId = 172, 
		RULE_templateName = 173, RULE_templateArgumentList = 174, RULE_templateArgument = 175, 
		RULE_typeNameSpecifier = 176, RULE_explicitInstantiation = 177, RULE_explicitSpecialization = 178, 
		RULE_tryBlock = 179, RULE_functionTryBlock = 180, RULE_handlerSeq = 181, 
		RULE_handler = 182, RULE_exceptionDeclaration = 183, RULE_throwExpression = 184, 
		RULE_exceptionSpecification = 185, RULE_dynamicExceptionSpecification = 186, 
		RULE_typeIdList = 187, RULE_noeExceptSpecification = 188, RULE_theOperator = 189, 
		RULE_literal = 190;
	private static String[] makeRuleNames() {
		return new String[] {
			"translationUnit", "primaryExpression", "idExpression", "unqualifiedId", 
			"qualifiedId", "nestedNameSpecifier", "lambdaExpression", "lambdaIntroducer", 
			"lambdaCapture", "captureDefault", "captureList", "capture", "simpleCapture", 
			"initcapture", "lambdaDeclarator", "postfixExpression", "typeIdOfTheTypeId", 
			"expressionList", "pseudoDestructorName", "unaryExpression", "unaryOperator", 
			"newExpression_", "newPlacement", "newTypeId", "newDeclarator_", "noPointerNewDeclarator", 
			"newInitializer_", "deleteExpression", "noExceptExpression", "castExpression", 
			"pointerMemberExpression", "multiplicativeExpression", "additiveExpression", 
			"shiftExpression", "shiftOperator", "relationalExpression", "equalityExpression", 
			"andExpression", "exclusiveOrExpression", "inclusiveOrExpression", "logicalAndExpression", 
			"logicalOrExpression", "conditionalExpression", "assignmentExpression", 
			"assignmentOperator", "expression", "constantExpression", "statement", 
			"labeledStatement", "expressionStatement", "compoundStatement", "statementSeq", 
			"selectionStatement", "condition", "iterationStatement", "forInitStatement", 
			"forRangeDeclaration", "forRangeInitializer", "jumpStatement", "declarationStatement", 
			"declarationseq", "declaration", "blockDeclaration", "aliasDeclaration", 
			"simpleDeclaration", "staticAssertDeclaration", "emptyDeclaration_", 
			"attributeDeclaration", "declSpecifier", "declSpecifierSeq", "storageClassSpecifier", 
			"functionSpecifier", "typedefName", "typeSpecifier", "trailingTypeSpecifier", 
			"typeSpecifierSeq", "trailingTypeSpecifierSeq", "simpleTypeLengthModifier", 
			"simpleTypeSignednessModifier", "simpleTypeSpecifier", "theTypeName", 
			"decltypeSpecifier", "elaboratedTypeSpecifier", "enumName", "enumSpecifier", 
			"enumHead", "opaqueEnumDeclaration", "enumkey", "enumbase", "enumeratorList", 
			"enumeratorDefinition", "enumerator", "namespaceName", "originalNamespaceName", 
			"namespaceDefinition", "namespaceAlias", "namespaceAliasDefinition", 
			"qualifiednamespacespecifier", "usingDeclaration", "usingDirective", 
			"asmDefinition", "linkageSpecification", "attributeSpecifierSeq", "attributeSpecifier", 
			"alignmentspecifier", "attributeList", "attribute", "attributeNamespace", 
			"attributeArgumentClause", "balancedTokenSeq", "balancedtoken", "initDeclaratorList", 
			"initDeclarator", "declarator", "pointerDeclarator", "noPointerDeclarator", 
			"parametersAndQualifiers", "trailingReturnType", "pointerOperator", "cvqualifierseq", 
			"cvQualifier", "refqualifier", "declaratorid", "theTypeId", "abstractDeclarator", 
			"pointerAbstractDeclarator", "noPointerAbstractDeclarator", "abstractPackDeclarator", 
			"noPointerAbstractPackDeclarator", "parameterDeclarationClause", "parameterDeclarationList", 
			"parameterDeclaration", "functionDefinition", "functionBody", "initializer", 
			"braceOrEqualInitializer", "initializerClause", "initializerList", "bracedInitList", 
			"className", "classSpecifier", "classHead", "classHeadName", "classVirtSpecifier", 
			"classKey", "memberSpecification", "memberdeclaration", "memberDeclaratorList", 
			"memberDeclarator", "virtualSpecifierSeq", "virtualSpecifier", "pureSpecifier", 
			"baseClause", "baseSpecifierList", "baseSpecifier", "classOrDeclType", 
			"baseTypeSpecifier", "accessSpecifier", "conversionFunctionId", "conversionTypeId", 
			"conversionDeclarator", "constructorInitializer", "memInitializerList", 
			"memInitializer", "meminitializerid", "operatorFunctionId", "literalOperatorId", 
			"templateDeclaration", "templateparameterList", "templateParameter", 
			"typeParameter", "simpleTemplateId", "templateId", "templateName", "templateArgumentList", 
			"templateArgument", "typeNameSpecifier", "explicitInstantiation", "explicitSpecialization", 
			"tryBlock", "functionTryBlock", "handlerSeq", "handler", "exceptionDeclaration", 
			"throwExpression", "exceptionSpecification", "dynamicExceptionSpecification", 
			"typeIdList", "noeExceptSpecification", "theOperator", "literal"
		};
	}
	public static final String[] ruleNames = makeRuleNames();

	private static String[] makeLiteralNames() {
		return new String[] {
			null, null, null, null, null, null, null, null, null, null, "'alignas'", 
			"'alignof'", "'asm'", "'auto'", "'bool'", "'break'", "'case'", "'catch'", 
			"'char'", "'char16_t'", "'char32_t'", "'class'", "'const'", "'constexpr'", 
			"'const_cast'", "'continue'", "'decltype'", "'default'", "'delete'", 
			"'do'", "'double'", "'dynamic_cast'", "'else'", "'enum'", "'explicit'", 
			"'export'", "'extern'", "'false'", "'final'", "'float'", "'for'", "'friend'", 
			"'goto'", "'if'", "'inline'", "'int'", "'long'", "'mutable'", "'namespace'", 
			"'new'", "'noexcept'", "'nullptr'", "'operator'", "'override'", "'private'", 
			"'protected'", "'public'", "'register'", "'reinterpret_cast'", "'return'", 
			"'short'", "'signed'", "'sizeof'", "'static'", "'static_assert'", "'static_cast'", 
			"'struct'", "'switch'", "'template'", "'this'", "'thread_local'", "'throw'", 
			"'true'", "'try'", "'typedef'", "'typeid'", "'typename'", "'union'", 
			"'unsigned'", "'using'", "'virtual'", "'void'", "'volatile'", "'wchar_t'", 
			"'while'", "'('", "')'", "'['", "']'", "'{'", "'}'", "'+'", "'-'", "'*'", 
			"'/'", "'%'", "'^'", "'&'", "'|'", "'~'", null, "'='", "'<'", "'>'", 
			"'+='", "'-='", "'*='", "'/='", "'%='", "'^='", "'&='", "'|='", "'<<='", 
			"'>>='", "'=='", "'!='", "'<='", "'>='", null, null, "'++'", "'--'", 
			"','", "'->*'", "'->'", "'?'", "':'", "'::'", "';'", "'.'", "'.*'", "'...'"
		};
	}
	private static final String[] _LITERAL_NAMES = makeLiteralNames();
	private static String[] makeSymbolicNames() {
		return new String[] {
			null, "IntegerLiteral", "CharacterLiteral", "FloatingLiteral", "StringLiteral", 
			"BooleanLiteral", "PointerLiteral", "UserDefinedLiteral", "MultiLineMacro", 
			"Directive", "Alignas", "Alignof", "Asm", "Auto", "Bool", "Break", "Case", 
			"Catch", "Char", "Char16", "Char32", "Class", "Const", "Constexpr", "Const_cast", 
			"Continue", "Decltype", "Default", "Delete", "Do", "Double", "Dynamic_cast", 
			"Else", "Enum", "Explicit", "Export", "Extern", "False_", "Final", "Float", 
			"For", "Friend", "Goto", "If", "Inline", "Int", "Long", "Mutable", "Namespace", 
			"New", "Noexcept", "Nullptr", "Operator", "Override", "Private", "Protected", 
			"Public", "Register", "Reinterpret_cast", "Return", "Short", "Signed", 
			"Sizeof", "Static", "Static_assert", "Static_cast", "Struct", "Switch", 
			"Template", "This", "Thread_local", "Throw", "True_", "Try", "Typedef", 
			"Typeid_", "Typename_", "Union", "Unsigned", "Using", "Virtual", "Void", 
			"Volatile", "Wchar", "While", "LeftParen", "RightParen", "LeftBracket", 
			"RightBracket", "LeftBrace", "RightBrace", "Plus", "Minus", "Star", "Div", 
			"Mod", "Caret", "And", "Or", "Tilde", "Not", "Assign", "Less", "Greater", 
			"PlusAssign", "MinusAssign", "StarAssign", "DivAssign", "ModAssign", 
			"XorAssign", "AndAssign", "OrAssign", "LeftShiftAssign", "RightShiftAssign", 
			"Equal", "NotEqual", "LessEqual", "GreaterEqual", "AndAnd", "OrOr", "PlusPlus", 
			"MinusMinus", "Comma", "ArrowStar", "Arrow", "Question", "Colon", "Doublecolon", 
			"Semi", "Dot", "DotStar", "Ellipsis", "Identifier", "DecimalLiteral", 
			"OctalLiteral", "HexadecimalLiteral", "BinaryLiteral", "Integersuffix", 
			"UserDefinedIntegerLiteral", "UserDefinedFloatingLiteral", "UserDefinedStringLiteral", 
			"UserDefinedCharacterLiteral", "Whitespace", "Newline", "BlockComment", 
			"LineComment"
		};
	}
	private static final String[] _SYMBOLIC_NAMES = makeSymbolicNames();
	public static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);

	/**
	 * @deprecated Use {@link #VOCABULARY} instead.
	 */
	@Deprecated
	public static final String[] tokenNames;
	static {
		tokenNames = new String[_SYMBOLIC_NAMES.length];
		for (int i = 0; i < tokenNames.length; i++) {
			tokenNames[i] = VOCABULARY.getLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = VOCABULARY.getSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}
	}

	@Override
	@Deprecated
	public String[] getTokenNames() {
		return tokenNames;
	}

	@Override

	public Vocabulary getVocabulary() {
		return VOCABULARY;
	}

	@Override
	public String getGrammarFileName() { return "CPP14Parser.g4"; }

	@Override
	public String[] getRuleNames() { return ruleNames; }

	@Override
	public String getSerializedATN() { return _serializedATN; }

	@Override
	public ATN getATN() { return _ATN; }

	public CPP14Parser(TokenStream input) {
		super(input);
		_interp = new ParserATNSimulator(this,_ATN,_decisionToDFA,_sharedContextCache);
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TranslationUnitContext extends ParserRuleContext {
		public TerminalNode EOF() { return getToken(CPP14Parser.EOF, 0); }
		public DeclarationseqContext declarationseq() {
			return getRuleContext(DeclarationseqContext.class,0);
		}
		public TranslationUnitContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_translationUnit; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTranslationUnit(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTranslationUnit(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTranslationUnit(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TranslationUnitContext translationUnit() throws RecognitionException {
		TranslationUnitContext _localctx = new TranslationUnitContext(_ctx, getState());
		enterRule(_localctx, 0, RULE_translationUnit);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(383);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (((((_la - 10)) & ~0x3f) == 0 && ((1L << (_la - 10)) & 1543754443169808157L) != 0) || ((((_la - 74)) & ~0x3f) == 0 && ((1L << (_la - 74)) & 459384754220313597L) != 0)) {
				{
				setState(382);
				declarationseq();
				}
			}

			setState(385);
			match(EOF);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class PrimaryExpressionContext extends ParserRuleContext {
		public List<LiteralContext> literal() {
			return getRuleContexts(LiteralContext.class);
		}
		public LiteralContext literal(int i) {
			return getRuleContext(LiteralContext.class,i);
		}
		public TerminalNode This() { return getToken(CPP14Parser.This, 0); }
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public ExpressionContext expression() {
			return getRuleContext(ExpressionContext.class,0);
		}
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public IdExpressionContext idExpression() {
			return getRuleContext(IdExpressionContext.class,0);
		}
		public LambdaExpressionContext lambdaExpression() {
			return getRuleContext(LambdaExpressionContext.class,0);
		}
		public PrimaryExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_primaryExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterPrimaryExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitPrimaryExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitPrimaryExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final PrimaryExpressionContext primaryExpression() throws RecognitionException {
		PrimaryExpressionContext _localctx = new PrimaryExpressionContext(_ctx, getState());
		enterRule(_localctx, 2, RULE_primaryExpression);
		try {
			int _alt;
			setState(399);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case IntegerLiteral:
			case CharacterLiteral:
			case FloatingLiteral:
			case StringLiteral:
			case BooleanLiteral:
			case PointerLiteral:
			case UserDefinedLiteral:
				enterOuterAlt(_localctx, 1);
				{
				setState(388); 
				_errHandler.sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						setState(387);
						literal();
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					setState(390); 
					_errHandler.sync(this);
					_alt = getInterpreter().adaptivePredict(_input,1,_ctx);
				} while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			case This:
				enterOuterAlt(_localctx, 2);
				{
				setState(392);
				match(This);
				}
				break;
			case LeftParen:
				enterOuterAlt(_localctx, 3);
				{
				setState(393);
				match(LeftParen);
				setState(394);
				expression();
				setState(395);
				match(RightParen);
				}
				break;
			case Decltype:
			case Operator:
			case Tilde:
			case Doublecolon:
			case Identifier:
				enterOuterAlt(_localctx, 4);
				{
				setState(397);
				idExpression();
				}
				break;
			case LeftBracket:
				enterOuterAlt(_localctx, 5);
				{
				setState(398);
				lambdaExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class IdExpressionContext extends ParserRuleContext {
		public UnqualifiedIdContext unqualifiedId() {
			return getRuleContext(UnqualifiedIdContext.class,0);
		}
		public QualifiedIdContext qualifiedId() {
			return getRuleContext(QualifiedIdContext.class,0);
		}
		public IdExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_idExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterIdExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitIdExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitIdExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final IdExpressionContext idExpression() throws RecognitionException {
		IdExpressionContext _localctx = new IdExpressionContext(_ctx, getState());
		enterRule(_localctx, 4, RULE_idExpression);
		try {
			setState(403);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,3,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(401);
				unqualifiedId();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(402);
				qualifiedId();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class UnqualifiedIdContext extends ParserRuleContext {
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public OperatorFunctionIdContext operatorFunctionId() {
			return getRuleContext(OperatorFunctionIdContext.class,0);
		}
		public ConversionFunctionIdContext conversionFunctionId() {
			return getRuleContext(ConversionFunctionIdContext.class,0);
		}
		public LiteralOperatorIdContext literalOperatorId() {
			return getRuleContext(LiteralOperatorIdContext.class,0);
		}
		public TerminalNode Tilde() { return getToken(CPP14Parser.Tilde, 0); }
		public ClassNameContext className() {
			return getRuleContext(ClassNameContext.class,0);
		}
		public DecltypeSpecifierContext decltypeSpecifier() {
			return getRuleContext(DecltypeSpecifierContext.class,0);
		}
		public TemplateIdContext templateId() {
			return getRuleContext(TemplateIdContext.class,0);
		}
		public UnqualifiedIdContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_unqualifiedId; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterUnqualifiedId(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitUnqualifiedId(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitUnqualifiedId(this);
			else return visitor.visitChildren(this);
		}
	}

	public final UnqualifiedIdContext unqualifiedId() throws RecognitionException {
		UnqualifiedIdContext _localctx = new UnqualifiedIdContext(_ctx, getState());
		enterRule(_localctx, 6, RULE_unqualifiedId);
		try {
			setState(415);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,5,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(405);
				match(Identifier);
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(406);
				operatorFunctionId();
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(407);
				conversionFunctionId();
				}
				break;
			case 4:
				enterOuterAlt(_localctx, 4);
				{
				setState(408);
				literalOperatorId();
				}
				break;
			case 5:
				enterOuterAlt(_localctx, 5);
				{
				setState(409);
				match(Tilde);
				setState(412);
				_errHandler.sync(this);
				switch (_input.LA(1)) {
				case Identifier:
					{
					setState(410);
					className();
					}
					break;
				case Decltype:
					{
					setState(411);
					decltypeSpecifier();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 6:
				enterOuterAlt(_localctx, 6);
				{
				setState(414);
				templateId();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class QualifiedIdContext extends ParserRuleContext {
		public NestedNameSpecifierContext nestedNameSpecifier() {
			return getRuleContext(NestedNameSpecifierContext.class,0);
		}
		public UnqualifiedIdContext unqualifiedId() {
			return getRuleContext(UnqualifiedIdContext.class,0);
		}
		public TerminalNode Template() { return getToken(CPP14Parser.Template, 0); }
		public QualifiedIdContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_qualifiedId; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterQualifiedId(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitQualifiedId(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitQualifiedId(this);
			else return visitor.visitChildren(this);
		}
	}

	public final QualifiedIdContext qualifiedId() throws RecognitionException {
		QualifiedIdContext _localctx = new QualifiedIdContext(_ctx, getState());
		enterRule(_localctx, 8, RULE_qualifiedId);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(417);
			nestedNameSpecifier(0);
			setState(419);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Template) {
				{
				setState(418);
				match(Template);
				}
			}

			setState(421);
			unqualifiedId();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class NestedNameSpecifierContext extends ParserRuleContext {
		public TerminalNode Doublecolon() { return getToken(CPP14Parser.Doublecolon, 0); }
		public TheTypeNameContext theTypeName() {
			return getRuleContext(TheTypeNameContext.class,0);
		}
		public NamespaceNameContext namespaceName() {
			return getRuleContext(NamespaceNameContext.class,0);
		}
		public DecltypeSpecifierContext decltypeSpecifier() {
			return getRuleContext(DecltypeSpecifierContext.class,0);
		}
		public NestedNameSpecifierContext nestedNameSpecifier() {
			return getRuleContext(NestedNameSpecifierContext.class,0);
		}
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public SimpleTemplateIdContext simpleTemplateId() {
			return getRuleContext(SimpleTemplateIdContext.class,0);
		}
		public TerminalNode Template() { return getToken(CPP14Parser.Template, 0); }
		public NestedNameSpecifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_nestedNameSpecifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterNestedNameSpecifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitNestedNameSpecifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitNestedNameSpecifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final NestedNameSpecifierContext nestedNameSpecifier() throws RecognitionException {
		return nestedNameSpecifier(0);
	}

	private NestedNameSpecifierContext nestedNameSpecifier(int _p) throws RecognitionException {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = getState();
		NestedNameSpecifierContext _localctx = new NestedNameSpecifierContext(_ctx, _parentState);
		NestedNameSpecifierContext _prevctx = _localctx;
		int _startState = 10;
		enterRecursionRule(_localctx, 10, RULE_nestedNameSpecifier, _p);
		int _la;
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			{
			setState(427);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,7,_ctx) ) {
			case 1:
				{
				setState(424);
				theTypeName();
				}
				break;
			case 2:
				{
				setState(425);
				namespaceName();
				}
				break;
			case 3:
				{
				setState(426);
				decltypeSpecifier();
				}
				break;
			}
			setState(429);
			match(Doublecolon);
			}
			_ctx.stop = _input.LT(-1);
			setState(442);
			_errHandler.sync(this);
			_alt = getInterpreter().adaptivePredict(_input,10,_ctx);
			while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) triggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new NestedNameSpecifierContext(_parentctx, _parentState);
					pushNewRecursionContext(_localctx, _startState, RULE_nestedNameSpecifier);
					setState(431);
					if (!(precpred(_ctx, 1))) throw new FailedPredicateException(this, "precpred(_ctx, 1)");
					setState(437);
					_errHandler.sync(this);
					switch ( getInterpreter().adaptivePredict(_input,9,_ctx) ) {
					case 1:
						{
						setState(432);
						match(Identifier);
						}
						break;
					case 2:
						{
						setState(434);
						_errHandler.sync(this);
						_la = _input.LA(1);
						if (_la==Template) {
							{
							setState(433);
							match(Template);
							}
						}

						setState(436);
						simpleTemplateId();
						}
						break;
					}
					setState(439);
					match(Doublecolon);
					}
					} 
				}
				setState(444);
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,10,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			unrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class LambdaExpressionContext extends ParserRuleContext {
		public LambdaIntroducerContext lambdaIntroducer() {
			return getRuleContext(LambdaIntroducerContext.class,0);
		}
		public CompoundStatementContext compoundStatement() {
			return getRuleContext(CompoundStatementContext.class,0);
		}
		public LambdaDeclaratorContext lambdaDeclarator() {
			return getRuleContext(LambdaDeclaratorContext.class,0);
		}
		public LambdaExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_lambdaExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterLambdaExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitLambdaExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitLambdaExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final LambdaExpressionContext lambdaExpression() throws RecognitionException {
		LambdaExpressionContext _localctx = new LambdaExpressionContext(_ctx, getState());
		enterRule(_localctx, 12, RULE_lambdaExpression);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(445);
			lambdaIntroducer();
			setState(447);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==LeftParen) {
				{
				setState(446);
				lambdaDeclarator();
				}
			}

			setState(449);
			compoundStatement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class LambdaIntroducerContext extends ParserRuleContext {
		public TerminalNode LeftBracket() { return getToken(CPP14Parser.LeftBracket, 0); }
		public TerminalNode RightBracket() { return getToken(CPP14Parser.RightBracket, 0); }
		public LambdaCaptureContext lambdaCapture() {
			return getRuleContext(LambdaCaptureContext.class,0);
		}
		public LambdaIntroducerContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_lambdaIntroducer; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterLambdaIntroducer(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitLambdaIntroducer(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitLambdaIntroducer(this);
			else return visitor.visitChildren(this);
		}
	}

	public final LambdaIntroducerContext lambdaIntroducer() throws RecognitionException {
		LambdaIntroducerContext _localctx = new LambdaIntroducerContext(_ctx, getState());
		enterRule(_localctx, 14, RULE_lambdaIntroducer);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(451);
			match(LeftBracket);
			setState(453);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (((((_la - 69)) & ~0x3f) == 0 && ((1L << (_la - 69)) & -9223372032291373055L) != 0)) {
				{
				setState(452);
				lambdaCapture();
				}
			}

			setState(455);
			match(RightBracket);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class LambdaCaptureContext extends ParserRuleContext {
		public CaptureListContext captureList() {
			return getRuleContext(CaptureListContext.class,0);
		}
		public CaptureDefaultContext captureDefault() {
			return getRuleContext(CaptureDefaultContext.class,0);
		}
		public TerminalNode Comma() { return getToken(CPP14Parser.Comma, 0); }
		public LambdaCaptureContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_lambdaCapture; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterLambdaCapture(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitLambdaCapture(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitLambdaCapture(this);
			else return visitor.visitChildren(this);
		}
	}

	public final LambdaCaptureContext lambdaCapture() throws RecognitionException {
		LambdaCaptureContext _localctx = new LambdaCaptureContext(_ctx, getState());
		enterRule(_localctx, 16, RULE_lambdaCapture);
		int _la;
		try {
			setState(463);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,14,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(457);
				captureList();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(458);
				captureDefault();
				setState(461);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Comma) {
					{
					setState(459);
					match(Comma);
					setState(460);
					captureList();
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class CaptureDefaultContext extends ParserRuleContext {
		public TerminalNode And() { return getToken(CPP14Parser.And, 0); }
		public TerminalNode Assign() { return getToken(CPP14Parser.Assign, 0); }
		public CaptureDefaultContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_captureDefault; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterCaptureDefault(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitCaptureDefault(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitCaptureDefault(this);
			else return visitor.visitChildren(this);
		}
	}

	public final CaptureDefaultContext captureDefault() throws RecognitionException {
		CaptureDefaultContext _localctx = new CaptureDefaultContext(_ctx, getState());
		enterRule(_localctx, 18, RULE_captureDefault);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(465);
			_la = _input.LA(1);
			if ( !(_la==And || _la==Assign) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class CaptureListContext extends ParserRuleContext {
		public List<CaptureContext> capture() {
			return getRuleContexts(CaptureContext.class);
		}
		public CaptureContext capture(int i) {
			return getRuleContext(CaptureContext.class,i);
		}
		public List<TerminalNode> Comma() { return getTokens(CPP14Parser.Comma); }
		public TerminalNode Comma(int i) {
			return getToken(CPP14Parser.Comma, i);
		}
		public TerminalNode Ellipsis() { return getToken(CPP14Parser.Ellipsis, 0); }
		public CaptureListContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_captureList; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterCaptureList(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitCaptureList(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitCaptureList(this);
			else return visitor.visitChildren(this);
		}
	}

	public final CaptureListContext captureList() throws RecognitionException {
		CaptureListContext _localctx = new CaptureListContext(_ctx, getState());
		enterRule(_localctx, 20, RULE_captureList);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(467);
			capture();
			setState(472);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==Comma) {
				{
				{
				setState(468);
				match(Comma);
				setState(469);
				capture();
				}
				}
				setState(474);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			setState(476);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Ellipsis) {
				{
				setState(475);
				match(Ellipsis);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class CaptureContext extends ParserRuleContext {
		public SimpleCaptureContext simpleCapture() {
			return getRuleContext(SimpleCaptureContext.class,0);
		}
		public InitcaptureContext initcapture() {
			return getRuleContext(InitcaptureContext.class,0);
		}
		public CaptureContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_capture; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterCapture(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitCapture(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitCapture(this);
			else return visitor.visitChildren(this);
		}
	}

	public final CaptureContext capture() throws RecognitionException {
		CaptureContext _localctx = new CaptureContext(_ctx, getState());
		enterRule(_localctx, 22, RULE_capture);
		try {
			setState(480);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,17,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(478);
				simpleCapture();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(479);
				initcapture();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class SimpleCaptureContext extends ParserRuleContext {
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public TerminalNode And() { return getToken(CPP14Parser.And, 0); }
		public TerminalNode This() { return getToken(CPP14Parser.This, 0); }
		public SimpleCaptureContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_simpleCapture; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterSimpleCapture(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitSimpleCapture(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitSimpleCapture(this);
			else return visitor.visitChildren(this);
		}
	}

	public final SimpleCaptureContext simpleCapture() throws RecognitionException {
		SimpleCaptureContext _localctx = new SimpleCaptureContext(_ctx, getState());
		enterRule(_localctx, 24, RULE_simpleCapture);
		int _la;
		try {
			setState(487);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case And:
			case Identifier:
				enterOuterAlt(_localctx, 1);
				{
				setState(483);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==And) {
					{
					setState(482);
					match(And);
					}
				}

				setState(485);
				match(Identifier);
				}
				break;
			case This:
				enterOuterAlt(_localctx, 2);
				{
				setState(486);
				match(This);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class InitcaptureContext extends ParserRuleContext {
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public InitializerContext initializer() {
			return getRuleContext(InitializerContext.class,0);
		}
		public TerminalNode And() { return getToken(CPP14Parser.And, 0); }
		public InitcaptureContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_initcapture; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterInitcapture(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitInitcapture(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitInitcapture(this);
			else return visitor.visitChildren(this);
		}
	}

	public final InitcaptureContext initcapture() throws RecognitionException {
		InitcaptureContext _localctx = new InitcaptureContext(_ctx, getState());
		enterRule(_localctx, 26, RULE_initcapture);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(490);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==And) {
				{
				setState(489);
				match(And);
				}
			}

			setState(492);
			match(Identifier);
			setState(493);
			initializer();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class LambdaDeclaratorContext extends ParserRuleContext {
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public ParameterDeclarationClauseContext parameterDeclarationClause() {
			return getRuleContext(ParameterDeclarationClauseContext.class,0);
		}
		public TerminalNode Mutable() { return getToken(CPP14Parser.Mutable, 0); }
		public ExceptionSpecificationContext exceptionSpecification() {
			return getRuleContext(ExceptionSpecificationContext.class,0);
		}
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public TrailingReturnTypeContext trailingReturnType() {
			return getRuleContext(TrailingReturnTypeContext.class,0);
		}
		public LambdaDeclaratorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_lambdaDeclarator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterLambdaDeclarator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitLambdaDeclarator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitLambdaDeclarator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final LambdaDeclaratorContext lambdaDeclarator() throws RecognitionException {
		LambdaDeclaratorContext _localctx = new LambdaDeclaratorContext(_ctx, getState());
		enterRule(_localctx, 28, RULE_lambdaDeclarator);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(495);
			match(LeftParen);
			setState(497);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (((((_la - 10)) & ~0x3f) == 0 && ((1L << (_la - 10)) & 1237504995584196377L) != 0) || ((((_la - 74)) & ~0x3f) == 0 && ((1L << (_la - 74)) & 297237575406461917L) != 0)) {
				{
				setState(496);
				parameterDeclarationClause();
				}
			}

			setState(499);
			match(RightParen);
			setState(501);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Mutable) {
				{
				setState(500);
				match(Mutable);
				}
			}

			setState(504);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Noexcept || _la==Throw) {
				{
				setState(503);
				exceptionSpecification();
				}
			}

			setState(507);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Alignas || _la==LeftBracket) {
				{
				setState(506);
				attributeSpecifierSeq();
				}
			}

			setState(510);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Arrow) {
				{
				setState(509);
				trailingReturnType();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class PostfixExpressionContext extends ParserRuleContext {
		public PrimaryExpressionContext primaryExpression() {
			return getRuleContext(PrimaryExpressionContext.class,0);
		}
		public SimpleTypeSpecifierContext simpleTypeSpecifier() {
			return getRuleContext(SimpleTypeSpecifierContext.class,0);
		}
		public TypeNameSpecifierContext typeNameSpecifier() {
			return getRuleContext(TypeNameSpecifierContext.class,0);
		}
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public BracedInitListContext bracedInitList() {
			return getRuleContext(BracedInitListContext.class,0);
		}
		public ExpressionListContext expressionList() {
			return getRuleContext(ExpressionListContext.class,0);
		}
		public TerminalNode Less() { return getToken(CPP14Parser.Less, 0); }
		public TheTypeIdContext theTypeId() {
			return getRuleContext(TheTypeIdContext.class,0);
		}
		public TerminalNode Greater() { return getToken(CPP14Parser.Greater, 0); }
		public ExpressionContext expression() {
			return getRuleContext(ExpressionContext.class,0);
		}
		public TerminalNode Dynamic_cast() { return getToken(CPP14Parser.Dynamic_cast, 0); }
		public TerminalNode Static_cast() { return getToken(CPP14Parser.Static_cast, 0); }
		public TerminalNode Reinterpret_cast() { return getToken(CPP14Parser.Reinterpret_cast, 0); }
		public TerminalNode Const_cast() { return getToken(CPP14Parser.Const_cast, 0); }
		public TypeIdOfTheTypeIdContext typeIdOfTheTypeId() {
			return getRuleContext(TypeIdOfTheTypeIdContext.class,0);
		}
		public PostfixExpressionContext postfixExpression() {
			return getRuleContext(PostfixExpressionContext.class,0);
		}
		public TerminalNode LeftBracket() { return getToken(CPP14Parser.LeftBracket, 0); }
		public TerminalNode RightBracket() { return getToken(CPP14Parser.RightBracket, 0); }
		public TerminalNode Dot() { return getToken(CPP14Parser.Dot, 0); }
		public TerminalNode Arrow() { return getToken(CPP14Parser.Arrow, 0); }
		public IdExpressionContext idExpression() {
			return getRuleContext(IdExpressionContext.class,0);
		}
		public PseudoDestructorNameContext pseudoDestructorName() {
			return getRuleContext(PseudoDestructorNameContext.class,0);
		}
		public TerminalNode Template() { return getToken(CPP14Parser.Template, 0); }
		public TerminalNode PlusPlus() { return getToken(CPP14Parser.PlusPlus, 0); }
		public TerminalNode MinusMinus() { return getToken(CPP14Parser.MinusMinus, 0); }
		public PostfixExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_postfixExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterPostfixExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitPostfixExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitPostfixExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final PostfixExpressionContext postfixExpression() throws RecognitionException {
		return postfixExpression(0);
	}

	private PostfixExpressionContext postfixExpression(int _p) throws RecognitionException {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = getState();
		PostfixExpressionContext _localctx = new PostfixExpressionContext(_ctx, _parentState);
		PostfixExpressionContext _prevctx = _localctx;
		int _startState = 30;
		enterRecursionRule(_localctx, 30, RULE_postfixExpression, _p);
		int _la;
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			setState(542);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,30,_ctx) ) {
			case 1:
				{
				setState(513);
				primaryExpression();
				}
				break;
			case 2:
				{
				setState(516);
				_errHandler.sync(this);
				switch (_input.LA(1)) {
				case Auto:
				case Bool:
				case Char:
				case Char16:
				case Char32:
				case Decltype:
				case Double:
				case Float:
				case Int:
				case Long:
				case Short:
				case Signed:
				case Unsigned:
				case Void:
				case Wchar:
				case Doublecolon:
				case Identifier:
					{
					setState(514);
					simpleTypeSpecifier();
					}
					break;
				case Typename_:
					{
					setState(515);
					typeNameSpecifier();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				setState(524);
				_errHandler.sync(this);
				switch (_input.LA(1)) {
				case LeftParen:
					{
					setState(518);
					match(LeftParen);
					setState(520);
					_errHandler.sync(this);
					_la = _input.LA(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 8364979464334764286L) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & 4719772474400910417L) != 0) || _la==Identifier) {
						{
						setState(519);
						expressionList();
						}
					}

					setState(522);
					match(RightParen);
					}
					break;
				case LeftBrace:
					{
					setState(523);
					bracedInitList();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 3:
				{
				setState(526);
				_la = _input.LA(1);
				if ( !(((((_la - 24)) & ~0x3f) == 0 && ((1L << (_la - 24)) & 2216203124865L) != 0)) ) {
				_errHandler.recoverInline(this);
				}
				else {
					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
					_errHandler.reportMatch(this);
					consume();
				}
				setState(527);
				match(Less);
				setState(528);
				theTypeId();
				setState(529);
				match(Greater);
				setState(530);
				match(LeftParen);
				setState(531);
				expression();
				setState(532);
				match(RightParen);
				}
				break;
			case 4:
				{
				setState(534);
				typeIdOfTheTypeId();
				setState(535);
				match(LeftParen);
				setState(538);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,29,_ctx) ) {
				case 1:
					{
					setState(536);
					expression();
					}
					break;
				case 2:
					{
					setState(537);
					theTypeId();
					}
					break;
				}
				setState(540);
				match(RightParen);
				}
				break;
			}
			_ctx.stop = _input.LT(-1);
			setState(571);
			_errHandler.sync(this);
			_alt = getInterpreter().adaptivePredict(_input,36,_ctx);
			while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) triggerExitRuleEvent();
					_prevctx = _localctx;
					{
					setState(569);
					_errHandler.sync(this);
					switch ( getInterpreter().adaptivePredict(_input,35,_ctx) ) {
					case 1:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						pushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						setState(544);
						if (!(precpred(_ctx, 7))) throw new FailedPredicateException(this, "precpred(_ctx, 7)");
						setState(545);
						match(LeftBracket);
						setState(548);
						_errHandler.sync(this);
						switch (_input.LA(1)) {
						case IntegerLiteral:
						case CharacterLiteral:
						case FloatingLiteral:
						case StringLiteral:
						case BooleanLiteral:
						case PointerLiteral:
						case UserDefinedLiteral:
						case Alignof:
						case Auto:
						case Bool:
						case Char:
						case Char16:
						case Char32:
						case Const_cast:
						case Decltype:
						case Delete:
						case Double:
						case Dynamic_cast:
						case Float:
						case Int:
						case Long:
						case New:
						case Noexcept:
						case Operator:
						case Reinterpret_cast:
						case Short:
						case Signed:
						case Sizeof:
						case Static_cast:
						case This:
						case Throw:
						case Typeid_:
						case Typename_:
						case Unsigned:
						case Void:
						case Wchar:
						case LeftParen:
						case LeftBracket:
						case Plus:
						case Minus:
						case Star:
						case And:
						case Or:
						case Tilde:
						case Not:
						case PlusPlus:
						case MinusMinus:
						case Doublecolon:
						case Identifier:
							{
							setState(546);
							expression();
							}
							break;
						case LeftBrace:
							{
							setState(547);
							bracedInitList();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						setState(550);
						match(RightBracket);
						}
						break;
					case 2:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						pushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						setState(552);
						if (!(precpred(_ctx, 6))) throw new FailedPredicateException(this, "precpred(_ctx, 6)");
						setState(553);
						match(LeftParen);
						setState(555);
						_errHandler.sync(this);
						_la = _input.LA(1);
						if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 8364979464334764286L) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & 4719772474400910417L) != 0) || _la==Identifier) {
							{
							setState(554);
							expressionList();
							}
						}

						setState(557);
						match(RightParen);
						}
						break;
					case 3:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						pushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						setState(558);
						if (!(precpred(_ctx, 4))) throw new FailedPredicateException(this, "precpred(_ctx, 4)");
						setState(559);
						_la = _input.LA(1);
						if ( !(_la==Arrow || _la==Dot) ) {
						_errHandler.recoverInline(this);
						}
						else {
							if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
							_errHandler.reportMatch(this);
							consume();
						}
						setState(565);
						_errHandler.sync(this);
						switch ( getInterpreter().adaptivePredict(_input,34,_ctx) ) {
						case 1:
							{
							setState(561);
							_errHandler.sync(this);
							_la = _input.LA(1);
							if (_la==Template) {
								{
								setState(560);
								match(Template);
								}
							}

							setState(563);
							idExpression();
							}
							break;
						case 2:
							{
							setState(564);
							pseudoDestructorName();
							}
							break;
						}
						}
						break;
					case 4:
						{
						_localctx = new PostfixExpressionContext(_parentctx, _parentState);
						pushNewRecursionContext(_localctx, _startState, RULE_postfixExpression);
						setState(567);
						if (!(precpred(_ctx, 3))) throw new FailedPredicateException(this, "precpred(_ctx, 3)");
						setState(568);
						_la = _input.LA(1);
						if ( !(_la==PlusPlus || _la==MinusMinus) ) {
						_errHandler.recoverInline(this);
						}
						else {
							if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
							_errHandler.reportMatch(this);
							consume();
						}
						}
						break;
					}
					} 
				}
				setState(573);
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,36,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			unrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TypeIdOfTheTypeIdContext extends ParserRuleContext {
		public TerminalNode Typeid_() { return getToken(CPP14Parser.Typeid_, 0); }
		public TypeIdOfTheTypeIdContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_typeIdOfTheTypeId; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTypeIdOfTheTypeId(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTypeIdOfTheTypeId(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTypeIdOfTheTypeId(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TypeIdOfTheTypeIdContext typeIdOfTheTypeId() throws RecognitionException {
		TypeIdOfTheTypeIdContext _localctx = new TypeIdOfTheTypeIdContext(_ctx, getState());
		enterRule(_localctx, 32, RULE_typeIdOfTheTypeId);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(574);
			match(Typeid_);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ExpressionListContext extends ParserRuleContext {
		public InitializerListContext initializerList() {
			return getRuleContext(InitializerListContext.class,0);
		}
		public ExpressionListContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_expressionList; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterExpressionList(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitExpressionList(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitExpressionList(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ExpressionListContext expressionList() throws RecognitionException {
		ExpressionListContext _localctx = new ExpressionListContext(_ctx, getState());
		enterRule(_localctx, 34, RULE_expressionList);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(576);
			initializerList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class PseudoDestructorNameContext extends ParserRuleContext {
		public TerminalNode Tilde() { return getToken(CPP14Parser.Tilde, 0); }
		public List<TheTypeNameContext> theTypeName() {
			return getRuleContexts(TheTypeNameContext.class);
		}
		public TheTypeNameContext theTypeName(int i) {
			return getRuleContext(TheTypeNameContext.class,i);
		}
		public NestedNameSpecifierContext nestedNameSpecifier() {
			return getRuleContext(NestedNameSpecifierContext.class,0);
		}
		public TerminalNode Doublecolon() { return getToken(CPP14Parser.Doublecolon, 0); }
		public TerminalNode Template() { return getToken(CPP14Parser.Template, 0); }
		public SimpleTemplateIdContext simpleTemplateId() {
			return getRuleContext(SimpleTemplateIdContext.class,0);
		}
		public DecltypeSpecifierContext decltypeSpecifier() {
			return getRuleContext(DecltypeSpecifierContext.class,0);
		}
		public PseudoDestructorNameContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_pseudoDestructorName; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterPseudoDestructorName(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitPseudoDestructorName(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitPseudoDestructorName(this);
			else return visitor.visitChildren(this);
		}
	}

	public final PseudoDestructorNameContext pseudoDestructorName() throws RecognitionException {
		PseudoDestructorNameContext _localctx = new PseudoDestructorNameContext(_ctx, getState());
		enterRule(_localctx, 36, RULE_pseudoDestructorName);
		int _la;
		try {
			setState(597);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,39,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(579);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,37,_ctx) ) {
				case 1:
					{
					setState(578);
					nestedNameSpecifier(0);
					}
					break;
				}
				setState(584);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Identifier) {
					{
					setState(581);
					theTypeName();
					setState(582);
					match(Doublecolon);
					}
				}

				setState(586);
				match(Tilde);
				setState(587);
				theTypeName();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(588);
				nestedNameSpecifier(0);
				setState(589);
				match(Template);
				setState(590);
				simpleTemplateId();
				setState(591);
				match(Doublecolon);
				setState(592);
				match(Tilde);
				setState(593);
				theTypeName();
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(595);
				match(Tilde);
				setState(596);
				decltypeSpecifier();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class UnaryExpressionContext extends ParserRuleContext {
		public PostfixExpressionContext postfixExpression() {
			return getRuleContext(PostfixExpressionContext.class,0);
		}
		public UnaryExpressionContext unaryExpression() {
			return getRuleContext(UnaryExpressionContext.class,0);
		}
		public TerminalNode PlusPlus() { return getToken(CPP14Parser.PlusPlus, 0); }
		public TerminalNode MinusMinus() { return getToken(CPP14Parser.MinusMinus, 0); }
		public UnaryOperatorContext unaryOperator() {
			return getRuleContext(UnaryOperatorContext.class,0);
		}
		public TerminalNode Sizeof() { return getToken(CPP14Parser.Sizeof, 0); }
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public TheTypeIdContext theTypeId() {
			return getRuleContext(TheTypeIdContext.class,0);
		}
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public TerminalNode Ellipsis() { return getToken(CPP14Parser.Ellipsis, 0); }
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public TerminalNode Alignof() { return getToken(CPP14Parser.Alignof, 0); }
		public NoExceptExpressionContext noExceptExpression() {
			return getRuleContext(NoExceptExpressionContext.class,0);
		}
		public NewExpression_Context newExpression_() {
			return getRuleContext(NewExpression_Context.class,0);
		}
		public DeleteExpressionContext deleteExpression() {
			return getRuleContext(DeleteExpressionContext.class,0);
		}
		public UnaryExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_unaryExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterUnaryExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitUnaryExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitUnaryExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final UnaryExpressionContext unaryExpression() throws RecognitionException {
		UnaryExpressionContext _localctx = new UnaryExpressionContext(_ctx, getState());
		enterRule(_localctx, 38, RULE_unaryExpression);
		try {
			setState(626);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,42,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(599);
				postfixExpression(0);
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(604);
				_errHandler.sync(this);
				switch (_input.LA(1)) {
				case PlusPlus:
					{
					setState(600);
					match(PlusPlus);
					}
					break;
				case MinusMinus:
					{
					setState(601);
					match(MinusMinus);
					}
					break;
				case Plus:
				case Minus:
				case Star:
				case And:
				case Or:
				case Tilde:
				case Not:
					{
					setState(602);
					unaryOperator();
					}
					break;
				case Sizeof:
					{
					setState(603);
					match(Sizeof);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				setState(606);
				unaryExpression();
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(607);
				match(Sizeof);
				setState(616);
				_errHandler.sync(this);
				switch (_input.LA(1)) {
				case LeftParen:
					{
					setState(608);
					match(LeftParen);
					setState(609);
					theTypeId();
					setState(610);
					match(RightParen);
					}
					break;
				case Ellipsis:
					{
					setState(612);
					match(Ellipsis);
					setState(613);
					match(LeftParen);
					setState(614);
					match(Identifier);
					setState(615);
					match(RightParen);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 4:
				enterOuterAlt(_localctx, 4);
				{
				setState(618);
				match(Alignof);
				setState(619);
				match(LeftParen);
				setState(620);
				theTypeId();
				setState(621);
				match(RightParen);
				}
				break;
			case 5:
				enterOuterAlt(_localctx, 5);
				{
				setState(623);
				noExceptExpression();
				}
				break;
			case 6:
				enterOuterAlt(_localctx, 6);
				{
				setState(624);
				newExpression_();
				}
				break;
			case 7:
				enterOuterAlt(_localctx, 7);
				{
				setState(625);
				deleteExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class UnaryOperatorContext extends ParserRuleContext {
		public TerminalNode Or() { return getToken(CPP14Parser.Or, 0); }
		public TerminalNode Star() { return getToken(CPP14Parser.Star, 0); }
		public TerminalNode And() { return getToken(CPP14Parser.And, 0); }
		public TerminalNode Plus() { return getToken(CPP14Parser.Plus, 0); }
		public TerminalNode Tilde() { return getToken(CPP14Parser.Tilde, 0); }
		public TerminalNode Minus() { return getToken(CPP14Parser.Minus, 0); }
		public TerminalNode Not() { return getToken(CPP14Parser.Not, 0); }
		public UnaryOperatorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_unaryOperator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterUnaryOperator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitUnaryOperator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitUnaryOperator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final UnaryOperatorContext unaryOperator() throws RecognitionException {
		UnaryOperatorContext _localctx = new UnaryOperatorContext(_ctx, getState());
		enterRule(_localctx, 40, RULE_unaryOperator);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(628);
			_la = _input.LA(1);
			if ( !(((((_la - 91)) & ~0x3f) == 0 && ((1L << (_la - 91)) & 967L) != 0)) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class NewExpression_Context extends ParserRuleContext {
		public TerminalNode New() { return getToken(CPP14Parser.New, 0); }
		public NewTypeIdContext newTypeId() {
			return getRuleContext(NewTypeIdContext.class,0);
		}
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public TheTypeIdContext theTypeId() {
			return getRuleContext(TheTypeIdContext.class,0);
		}
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public TerminalNode Doublecolon() { return getToken(CPP14Parser.Doublecolon, 0); }
		public NewPlacementContext newPlacement() {
			return getRuleContext(NewPlacementContext.class,0);
		}
		public NewInitializer_Context newInitializer_() {
			return getRuleContext(NewInitializer_Context.class,0);
		}
		public NewExpression_Context(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_newExpression_; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterNewExpression_(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitNewExpression_(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitNewExpression_(this);
			else return visitor.visitChildren(this);
		}
	}

	public final NewExpression_Context newExpression_() throws RecognitionException {
		NewExpression_Context _localctx = new NewExpression_Context(_ctx, getState());
		enterRule(_localctx, 42, RULE_newExpression_);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(631);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Doublecolon) {
				{
				setState(630);
				match(Doublecolon);
				}
			}

			setState(633);
			match(New);
			setState(635);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,44,_ctx) ) {
			case 1:
				{
				setState(634);
				newPlacement();
				}
				break;
			}
			setState(642);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case Auto:
			case Bool:
			case Char:
			case Char16:
			case Char32:
			case Class:
			case Const:
			case Decltype:
			case Double:
			case Enum:
			case Float:
			case Int:
			case Long:
			case Short:
			case Signed:
			case Struct:
			case Typename_:
			case Union:
			case Unsigned:
			case Void:
			case Volatile:
			case Wchar:
			case Doublecolon:
			case Identifier:
				{
				setState(637);
				newTypeId();
				}
				break;
			case LeftParen:
				{
				setState(638);
				match(LeftParen);
				setState(639);
				theTypeId();
				setState(640);
				match(RightParen);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			setState(645);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==LeftParen || _la==LeftBrace) {
				{
				setState(644);
				newInitializer_();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class NewPlacementContext extends ParserRuleContext {
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public ExpressionListContext expressionList() {
			return getRuleContext(ExpressionListContext.class,0);
		}
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public NewPlacementContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_newPlacement; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterNewPlacement(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitNewPlacement(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitNewPlacement(this);
			else return visitor.visitChildren(this);
		}
	}

	public final NewPlacementContext newPlacement() throws RecognitionException {
		NewPlacementContext _localctx = new NewPlacementContext(_ctx, getState());
		enterRule(_localctx, 44, RULE_newPlacement);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(647);
			match(LeftParen);
			setState(648);
			expressionList();
			setState(649);
			match(RightParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class NewTypeIdContext extends ParserRuleContext {
		public TypeSpecifierSeqContext typeSpecifierSeq() {
			return getRuleContext(TypeSpecifierSeqContext.class,0);
		}
		public NewDeclarator_Context newDeclarator_() {
			return getRuleContext(NewDeclarator_Context.class,0);
		}
		public NewTypeIdContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_newTypeId; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterNewTypeId(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitNewTypeId(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitNewTypeId(this);
			else return visitor.visitChildren(this);
		}
	}

	public final NewTypeIdContext newTypeId() throws RecognitionException {
		NewTypeIdContext _localctx = new NewTypeIdContext(_ctx, getState());
		enterRule(_localctx, 46, RULE_newTypeId);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(651);
			typeSpecifierSeq();
			setState(653);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,47,_ctx) ) {
			case 1:
				{
				setState(652);
				newDeclarator_();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class NewDeclarator_Context extends ParserRuleContext {
		public PointerOperatorContext pointerOperator() {
			return getRuleContext(PointerOperatorContext.class,0);
		}
		public NewDeclarator_Context newDeclarator_() {
			return getRuleContext(NewDeclarator_Context.class,0);
		}
		public NoPointerNewDeclaratorContext noPointerNewDeclarator() {
			return getRuleContext(NoPointerNewDeclaratorContext.class,0);
		}
		public NewDeclarator_Context(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_newDeclarator_; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterNewDeclarator_(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitNewDeclarator_(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitNewDeclarator_(this);
			else return visitor.visitChildren(this);
		}
	}

	public final NewDeclarator_Context newDeclarator_() throws RecognitionException {
		NewDeclarator_Context _localctx = new NewDeclarator_Context(_ctx, getState());
		enterRule(_localctx, 48, RULE_newDeclarator_);
		try {
			setState(660);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case Decltype:
			case Star:
			case And:
			case AndAnd:
			case Doublecolon:
			case Identifier:
				enterOuterAlt(_localctx, 1);
				{
				setState(655);
				pointerOperator();
				setState(657);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,48,_ctx) ) {
				case 1:
					{
					setState(656);
					newDeclarator_();
					}
					break;
				}
				}
				break;
			case LeftBracket:
				enterOuterAlt(_localctx, 2);
				{
				setState(659);
				noPointerNewDeclarator(0);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class NoPointerNewDeclaratorContext extends ParserRuleContext {
		public TerminalNode LeftBracket() { return getToken(CPP14Parser.LeftBracket, 0); }
		public ExpressionContext expression() {
			return getRuleContext(ExpressionContext.class,0);
		}
		public TerminalNode RightBracket() { return getToken(CPP14Parser.RightBracket, 0); }
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public NoPointerNewDeclaratorContext noPointerNewDeclarator() {
			return getRuleContext(NoPointerNewDeclaratorContext.class,0);
		}
		public ConstantExpressionContext constantExpression() {
			return getRuleContext(ConstantExpressionContext.class,0);
		}
		public NoPointerNewDeclaratorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_noPointerNewDeclarator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterNoPointerNewDeclarator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitNoPointerNewDeclarator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitNoPointerNewDeclarator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final NoPointerNewDeclaratorContext noPointerNewDeclarator() throws RecognitionException {
		return noPointerNewDeclarator(0);
	}

	private NoPointerNewDeclaratorContext noPointerNewDeclarator(int _p) throws RecognitionException {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = getState();
		NoPointerNewDeclaratorContext _localctx = new NoPointerNewDeclaratorContext(_ctx, _parentState);
		NoPointerNewDeclaratorContext _prevctx = _localctx;
		int _startState = 50;
		enterRecursionRule(_localctx, 50, RULE_noPointerNewDeclarator, _p);
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			{
			setState(663);
			match(LeftBracket);
			setState(664);
			expression();
			setState(665);
			match(RightBracket);
			setState(667);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,50,_ctx) ) {
			case 1:
				{
				setState(666);
				attributeSpecifierSeq();
				}
				break;
			}
			}
			_ctx.stop = _input.LT(-1);
			setState(678);
			_errHandler.sync(this);
			_alt = getInterpreter().adaptivePredict(_input,52,_ctx);
			while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) triggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new NoPointerNewDeclaratorContext(_parentctx, _parentState);
					pushNewRecursionContext(_localctx, _startState, RULE_noPointerNewDeclarator);
					setState(669);
					if (!(precpred(_ctx, 1))) throw new FailedPredicateException(this, "precpred(_ctx, 1)");
					setState(670);
					match(LeftBracket);
					setState(671);
					constantExpression();
					setState(672);
					match(RightBracket);
					setState(674);
					_errHandler.sync(this);
					switch ( getInterpreter().adaptivePredict(_input,51,_ctx) ) {
					case 1:
						{
						setState(673);
						attributeSpecifierSeq();
						}
						break;
					}
					}
					} 
				}
				setState(680);
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,52,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			unrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class NewInitializer_Context extends ParserRuleContext {
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public ExpressionListContext expressionList() {
			return getRuleContext(ExpressionListContext.class,0);
		}
		public BracedInitListContext bracedInitList() {
			return getRuleContext(BracedInitListContext.class,0);
		}
		public NewInitializer_Context(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_newInitializer_; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterNewInitializer_(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitNewInitializer_(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitNewInitializer_(this);
			else return visitor.visitChildren(this);
		}
	}

	public final NewInitializer_Context newInitializer_() throws RecognitionException {
		NewInitializer_Context _localctx = new NewInitializer_Context(_ctx, getState());
		enterRule(_localctx, 52, RULE_newInitializer_);
		int _la;
		try {
			setState(687);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case LeftParen:
				enterOuterAlt(_localctx, 1);
				{
				setState(681);
				match(LeftParen);
				setState(683);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 8364979464334764286L) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & 4719772474400910417L) != 0) || _la==Identifier) {
					{
					setState(682);
					expressionList();
					}
				}

				setState(685);
				match(RightParen);
				}
				break;
			case LeftBrace:
				enterOuterAlt(_localctx, 2);
				{
				setState(686);
				bracedInitList();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class DeleteExpressionContext extends ParserRuleContext {
		public TerminalNode Delete() { return getToken(CPP14Parser.Delete, 0); }
		public CastExpressionContext castExpression() {
			return getRuleContext(CastExpressionContext.class,0);
		}
		public TerminalNode Doublecolon() { return getToken(CPP14Parser.Doublecolon, 0); }
		public TerminalNode LeftBracket() { return getToken(CPP14Parser.LeftBracket, 0); }
		public TerminalNode RightBracket() { return getToken(CPP14Parser.RightBracket, 0); }
		public DeleteExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_deleteExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterDeleteExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitDeleteExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitDeleteExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final DeleteExpressionContext deleteExpression() throws RecognitionException {
		DeleteExpressionContext _localctx = new DeleteExpressionContext(_ctx, getState());
		enterRule(_localctx, 54, RULE_deleteExpression);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(690);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Doublecolon) {
				{
				setState(689);
				match(Doublecolon);
				}
			}

			setState(692);
			match(Delete);
			setState(695);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,56,_ctx) ) {
			case 1:
				{
				setState(693);
				match(LeftBracket);
				setState(694);
				match(RightBracket);
				}
				break;
			}
			setState(697);
			castExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class NoExceptExpressionContext extends ParserRuleContext {
		public TerminalNode Noexcept() { return getToken(CPP14Parser.Noexcept, 0); }
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public ExpressionContext expression() {
			return getRuleContext(ExpressionContext.class,0);
		}
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public NoExceptExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_noExceptExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterNoExceptExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitNoExceptExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitNoExceptExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final NoExceptExpressionContext noExceptExpression() throws RecognitionException {
		NoExceptExpressionContext _localctx = new NoExceptExpressionContext(_ctx, getState());
		enterRule(_localctx, 56, RULE_noExceptExpression);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(699);
			match(Noexcept);
			setState(700);
			match(LeftParen);
			setState(701);
			expression();
			setState(702);
			match(RightParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class CastExpressionContext extends ParserRuleContext {
		public UnaryExpressionContext unaryExpression() {
			return getRuleContext(UnaryExpressionContext.class,0);
		}
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public TheTypeIdContext theTypeId() {
			return getRuleContext(TheTypeIdContext.class,0);
		}
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public CastExpressionContext castExpression() {
			return getRuleContext(CastExpressionContext.class,0);
		}
		public CastExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_castExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterCastExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitCastExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitCastExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final CastExpressionContext castExpression() throws RecognitionException {
		CastExpressionContext _localctx = new CastExpressionContext(_ctx, getState());
		enterRule(_localctx, 58, RULE_castExpression);
		try {
			setState(710);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,57,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(704);
				unaryExpression();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(705);
				match(LeftParen);
				setState(706);
				theTypeId();
				setState(707);
				match(RightParen);
				setState(708);
				castExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class PointerMemberExpressionContext extends ParserRuleContext {
		public List<CastExpressionContext> castExpression() {
			return getRuleContexts(CastExpressionContext.class);
		}
		public CastExpressionContext castExpression(int i) {
			return getRuleContext(CastExpressionContext.class,i);
		}
		public List<TerminalNode> DotStar() { return getTokens(CPP14Parser.DotStar); }
		public TerminalNode DotStar(int i) {
			return getToken(CPP14Parser.DotStar, i);
		}
		public List<TerminalNode> ArrowStar() { return getTokens(CPP14Parser.ArrowStar); }
		public TerminalNode ArrowStar(int i) {
			return getToken(CPP14Parser.ArrowStar, i);
		}
		public PointerMemberExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_pointerMemberExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterPointerMemberExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitPointerMemberExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitPointerMemberExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final PointerMemberExpressionContext pointerMemberExpression() throws RecognitionException {
		PointerMemberExpressionContext _localctx = new PointerMemberExpressionContext(_ctx, getState());
		enterRule(_localctx, 60, RULE_pointerMemberExpression);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(712);
			castExpression();
			setState(717);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==ArrowStar || _la==DotStar) {
				{
				{
				setState(713);
				_la = _input.LA(1);
				if ( !(_la==ArrowStar || _la==DotStar) ) {
				_errHandler.recoverInline(this);
				}
				else {
					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
					_errHandler.reportMatch(this);
					consume();
				}
				setState(714);
				castExpression();
				}
				}
				setState(719);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class MultiplicativeExpressionContext extends ParserRuleContext {
		public List<PointerMemberExpressionContext> pointerMemberExpression() {
			return getRuleContexts(PointerMemberExpressionContext.class);
		}
		public PointerMemberExpressionContext pointerMemberExpression(int i) {
			return getRuleContext(PointerMemberExpressionContext.class,i);
		}
		public List<TerminalNode> Star() { return getTokens(CPP14Parser.Star); }
		public TerminalNode Star(int i) {
			return getToken(CPP14Parser.Star, i);
		}
		public List<TerminalNode> Div() { return getTokens(CPP14Parser.Div); }
		public TerminalNode Div(int i) {
			return getToken(CPP14Parser.Div, i);
		}
		public List<TerminalNode> Mod() { return getTokens(CPP14Parser.Mod); }
		public TerminalNode Mod(int i) {
			return getToken(CPP14Parser.Mod, i);
		}
		public MultiplicativeExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_multiplicativeExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterMultiplicativeExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitMultiplicativeExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitMultiplicativeExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final MultiplicativeExpressionContext multiplicativeExpression() throws RecognitionException {
		MultiplicativeExpressionContext _localctx = new MultiplicativeExpressionContext(_ctx, getState());
		enterRule(_localctx, 62, RULE_multiplicativeExpression);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(720);
			pointerMemberExpression();
			setState(725);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (((((_la - 93)) & ~0x3f) == 0 && ((1L << (_la - 93)) & 7L) != 0)) {
				{
				{
				setState(721);
				_la = _input.LA(1);
				if ( !(((((_la - 93)) & ~0x3f) == 0 && ((1L << (_la - 93)) & 7L) != 0)) ) {
				_errHandler.recoverInline(this);
				}
				else {
					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
					_errHandler.reportMatch(this);
					consume();
				}
				setState(722);
				pointerMemberExpression();
				}
				}
				setState(727);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class AdditiveExpressionContext extends ParserRuleContext {
		public List<MultiplicativeExpressionContext> multiplicativeExpression() {
			return getRuleContexts(MultiplicativeExpressionContext.class);
		}
		public MultiplicativeExpressionContext multiplicativeExpression(int i) {
			return getRuleContext(MultiplicativeExpressionContext.class,i);
		}
		public List<TerminalNode> Plus() { return getTokens(CPP14Parser.Plus); }
		public TerminalNode Plus(int i) {
			return getToken(CPP14Parser.Plus, i);
		}
		public List<TerminalNode> Minus() { return getTokens(CPP14Parser.Minus); }
		public TerminalNode Minus(int i) {
			return getToken(CPP14Parser.Minus, i);
		}
		public AdditiveExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_additiveExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterAdditiveExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitAdditiveExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitAdditiveExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final AdditiveExpressionContext additiveExpression() throws RecognitionException {
		AdditiveExpressionContext _localctx = new AdditiveExpressionContext(_ctx, getState());
		enterRule(_localctx, 64, RULE_additiveExpression);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(728);
			multiplicativeExpression();
			setState(733);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==Plus || _la==Minus) {
				{
				{
				setState(729);
				_la = _input.LA(1);
				if ( !(_la==Plus || _la==Minus) ) {
				_errHandler.recoverInline(this);
				}
				else {
					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
					_errHandler.reportMatch(this);
					consume();
				}
				setState(730);
				multiplicativeExpression();
				}
				}
				setState(735);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ShiftExpressionContext extends ParserRuleContext {
		public List<AdditiveExpressionContext> additiveExpression() {
			return getRuleContexts(AdditiveExpressionContext.class);
		}
		public AdditiveExpressionContext additiveExpression(int i) {
			return getRuleContext(AdditiveExpressionContext.class,i);
		}
		public List<ShiftOperatorContext> shiftOperator() {
			return getRuleContexts(ShiftOperatorContext.class);
		}
		public ShiftOperatorContext shiftOperator(int i) {
			return getRuleContext(ShiftOperatorContext.class,i);
		}
		public ShiftExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_shiftExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterShiftExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitShiftExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitShiftExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ShiftExpressionContext shiftExpression() throws RecognitionException {
		ShiftExpressionContext _localctx = new ShiftExpressionContext(_ctx, getState());
		enterRule(_localctx, 66, RULE_shiftExpression);
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			setState(736);
			additiveExpression();
			setState(742);
			_errHandler.sync(this);
			_alt = getInterpreter().adaptivePredict(_input,61,_ctx);
			while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					setState(737);
					shiftOperator();
					setState(738);
					additiveExpression();
					}
					} 
				}
				setState(744);
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,61,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ShiftOperatorContext extends ParserRuleContext {
		public List<TerminalNode> Greater() { return getTokens(CPP14Parser.Greater); }
		public TerminalNode Greater(int i) {
			return getToken(CPP14Parser.Greater, i);
		}
		public List<TerminalNode> Less() { return getTokens(CPP14Parser.Less); }
		public TerminalNode Less(int i) {
			return getToken(CPP14Parser.Less, i);
		}
		public ShiftOperatorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_shiftOperator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterShiftOperator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitShiftOperator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitShiftOperator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ShiftOperatorContext shiftOperator() throws RecognitionException {
		ShiftOperatorContext _localctx = new ShiftOperatorContext(_ctx, getState());
		enterRule(_localctx, 68, RULE_shiftOperator);
		try {
			setState(749);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case Greater:
				enterOuterAlt(_localctx, 1);
				{
				setState(745);
				match(Greater);
				setState(746);
				match(Greater);
				}
				break;
			case Less:
				enterOuterAlt(_localctx, 2);
				{
				setState(747);
				match(Less);
				setState(748);
				match(Less);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class RelationalExpressionContext extends ParserRuleContext {
		public List<ShiftExpressionContext> shiftExpression() {
			return getRuleContexts(ShiftExpressionContext.class);
		}
		public ShiftExpressionContext shiftExpression(int i) {
			return getRuleContext(ShiftExpressionContext.class,i);
		}
		public List<TerminalNode> Less() { return getTokens(CPP14Parser.Less); }
		public TerminalNode Less(int i) {
			return getToken(CPP14Parser.Less, i);
		}
		public List<TerminalNode> Greater() { return getTokens(CPP14Parser.Greater); }
		public TerminalNode Greater(int i) {
			return getToken(CPP14Parser.Greater, i);
		}
		public List<TerminalNode> LessEqual() { return getTokens(CPP14Parser.LessEqual); }
		public TerminalNode LessEqual(int i) {
			return getToken(CPP14Parser.LessEqual, i);
		}
		public List<TerminalNode> GreaterEqual() { return getTokens(CPP14Parser.GreaterEqual); }
		public TerminalNode GreaterEqual(int i) {
			return getToken(CPP14Parser.GreaterEqual, i);
		}
		public RelationalExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_relationalExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterRelationalExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitRelationalExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitRelationalExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final RelationalExpressionContext relationalExpression() throws RecognitionException {
		RelationalExpressionContext _localctx = new RelationalExpressionContext(_ctx, getState());
		enterRule(_localctx, 70, RULE_relationalExpression);
		int _la;
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			setState(751);
			shiftExpression();
			setState(756);
			_errHandler.sync(this);
			_alt = getInterpreter().adaptivePredict(_input,63,_ctx);
			while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					setState(752);
					_la = _input.LA(1);
					if ( !(((((_la - 102)) & ~0x3f) == 0 && ((1L << (_la - 102)) & 49155L) != 0)) ) {
					_errHandler.recoverInline(this);
					}
					else {
						if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
						_errHandler.reportMatch(this);
						consume();
					}
					setState(753);
					shiftExpression();
					}
					} 
				}
				setState(758);
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,63,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class EqualityExpressionContext extends ParserRuleContext {
		public List<RelationalExpressionContext> relationalExpression() {
			return getRuleContexts(RelationalExpressionContext.class);
		}
		public RelationalExpressionContext relationalExpression(int i) {
			return getRuleContext(RelationalExpressionContext.class,i);
		}
		public List<TerminalNode> Equal() { return getTokens(CPP14Parser.Equal); }
		public TerminalNode Equal(int i) {
			return getToken(CPP14Parser.Equal, i);
		}
		public List<TerminalNode> NotEqual() { return getTokens(CPP14Parser.NotEqual); }
		public TerminalNode NotEqual(int i) {
			return getToken(CPP14Parser.NotEqual, i);
		}
		public EqualityExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_equalityExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterEqualityExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitEqualityExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitEqualityExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final EqualityExpressionContext equalityExpression() throws RecognitionException {
		EqualityExpressionContext _localctx = new EqualityExpressionContext(_ctx, getState());
		enterRule(_localctx, 72, RULE_equalityExpression);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(759);
			relationalExpression();
			setState(764);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==Equal || _la==NotEqual) {
				{
				{
				setState(760);
				_la = _input.LA(1);
				if ( !(_la==Equal || _la==NotEqual) ) {
				_errHandler.recoverInline(this);
				}
				else {
					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
					_errHandler.reportMatch(this);
					consume();
				}
				setState(761);
				relationalExpression();
				}
				}
				setState(766);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class AndExpressionContext extends ParserRuleContext {
		public List<EqualityExpressionContext> equalityExpression() {
			return getRuleContexts(EqualityExpressionContext.class);
		}
		public EqualityExpressionContext equalityExpression(int i) {
			return getRuleContext(EqualityExpressionContext.class,i);
		}
		public List<TerminalNode> And() { return getTokens(CPP14Parser.And); }
		public TerminalNode And(int i) {
			return getToken(CPP14Parser.And, i);
		}
		public AndExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_andExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterAndExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitAndExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitAndExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final AndExpressionContext andExpression() throws RecognitionException {
		AndExpressionContext _localctx = new AndExpressionContext(_ctx, getState());
		enterRule(_localctx, 74, RULE_andExpression);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(767);
			equalityExpression();
			setState(772);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==And) {
				{
				{
				setState(768);
				match(And);
				setState(769);
				equalityExpression();
				}
				}
				setState(774);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ExclusiveOrExpressionContext extends ParserRuleContext {
		public List<AndExpressionContext> andExpression() {
			return getRuleContexts(AndExpressionContext.class);
		}
		public AndExpressionContext andExpression(int i) {
			return getRuleContext(AndExpressionContext.class,i);
		}
		public List<TerminalNode> Caret() { return getTokens(CPP14Parser.Caret); }
		public TerminalNode Caret(int i) {
			return getToken(CPP14Parser.Caret, i);
		}
		public ExclusiveOrExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_exclusiveOrExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterExclusiveOrExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitExclusiveOrExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitExclusiveOrExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ExclusiveOrExpressionContext exclusiveOrExpression() throws RecognitionException {
		ExclusiveOrExpressionContext _localctx = new ExclusiveOrExpressionContext(_ctx, getState());
		enterRule(_localctx, 76, RULE_exclusiveOrExpression);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(775);
			andExpression();
			setState(780);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==Caret) {
				{
				{
				setState(776);
				match(Caret);
				setState(777);
				andExpression();
				}
				}
				setState(782);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class InclusiveOrExpressionContext extends ParserRuleContext {
		public List<ExclusiveOrExpressionContext> exclusiveOrExpression() {
			return getRuleContexts(ExclusiveOrExpressionContext.class);
		}
		public ExclusiveOrExpressionContext exclusiveOrExpression(int i) {
			return getRuleContext(ExclusiveOrExpressionContext.class,i);
		}
		public List<TerminalNode> Or() { return getTokens(CPP14Parser.Or); }
		public TerminalNode Or(int i) {
			return getToken(CPP14Parser.Or, i);
		}
		public InclusiveOrExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_inclusiveOrExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterInclusiveOrExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitInclusiveOrExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitInclusiveOrExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final InclusiveOrExpressionContext inclusiveOrExpression() throws RecognitionException {
		InclusiveOrExpressionContext _localctx = new InclusiveOrExpressionContext(_ctx, getState());
		enterRule(_localctx, 78, RULE_inclusiveOrExpression);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(783);
			exclusiveOrExpression();
			setState(788);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==Or) {
				{
				{
				setState(784);
				match(Or);
				setState(785);
				exclusiveOrExpression();
				}
				}
				setState(790);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class LogicalAndExpressionContext extends ParserRuleContext {
		public List<InclusiveOrExpressionContext> inclusiveOrExpression() {
			return getRuleContexts(InclusiveOrExpressionContext.class);
		}
		public InclusiveOrExpressionContext inclusiveOrExpression(int i) {
			return getRuleContext(InclusiveOrExpressionContext.class,i);
		}
		public List<TerminalNode> AndAnd() { return getTokens(CPP14Parser.AndAnd); }
		public TerminalNode AndAnd(int i) {
			return getToken(CPP14Parser.AndAnd, i);
		}
		public LogicalAndExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_logicalAndExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterLogicalAndExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitLogicalAndExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitLogicalAndExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final LogicalAndExpressionContext logicalAndExpression() throws RecognitionException {
		LogicalAndExpressionContext _localctx = new LogicalAndExpressionContext(_ctx, getState());
		enterRule(_localctx, 80, RULE_logicalAndExpression);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(791);
			inclusiveOrExpression();
			setState(796);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==AndAnd) {
				{
				{
				setState(792);
				match(AndAnd);
				setState(793);
				inclusiveOrExpression();
				}
				}
				setState(798);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class LogicalOrExpressionContext extends ParserRuleContext {
		public List<LogicalAndExpressionContext> logicalAndExpression() {
			return getRuleContexts(LogicalAndExpressionContext.class);
		}
		public LogicalAndExpressionContext logicalAndExpression(int i) {
			return getRuleContext(LogicalAndExpressionContext.class,i);
		}
		public List<TerminalNode> OrOr() { return getTokens(CPP14Parser.OrOr); }
		public TerminalNode OrOr(int i) {
			return getToken(CPP14Parser.OrOr, i);
		}
		public LogicalOrExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_logicalOrExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterLogicalOrExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitLogicalOrExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitLogicalOrExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final LogicalOrExpressionContext logicalOrExpression() throws RecognitionException {
		LogicalOrExpressionContext _localctx = new LogicalOrExpressionContext(_ctx, getState());
		enterRule(_localctx, 82, RULE_logicalOrExpression);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(799);
			logicalAndExpression();
			setState(804);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==OrOr) {
				{
				{
				setState(800);
				match(OrOr);
				setState(801);
				logicalAndExpression();
				}
				}
				setState(806);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ConditionalExpressionContext extends ParserRuleContext {
		public LogicalOrExpressionContext logicalOrExpression() {
			return getRuleContext(LogicalOrExpressionContext.class,0);
		}
		public TerminalNode Question() { return getToken(CPP14Parser.Question, 0); }
		public ExpressionContext expression() {
			return getRuleContext(ExpressionContext.class,0);
		}
		public TerminalNode Colon() { return getToken(CPP14Parser.Colon, 0); }
		public AssignmentExpressionContext assignmentExpression() {
			return getRuleContext(AssignmentExpressionContext.class,0);
		}
		public ConditionalExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_conditionalExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterConditionalExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitConditionalExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitConditionalExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ConditionalExpressionContext conditionalExpression() throws RecognitionException {
		ConditionalExpressionContext _localctx = new ConditionalExpressionContext(_ctx, getState());
		enterRule(_localctx, 84, RULE_conditionalExpression);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(807);
			logicalOrExpression();
			setState(813);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Question) {
				{
				setState(808);
				match(Question);
				setState(809);
				expression();
				setState(810);
				match(Colon);
				setState(811);
				assignmentExpression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class AssignmentExpressionContext extends ParserRuleContext {
		public ConditionalExpressionContext conditionalExpression() {
			return getRuleContext(ConditionalExpressionContext.class,0);
		}
		public LogicalOrExpressionContext logicalOrExpression() {
			return getRuleContext(LogicalOrExpressionContext.class,0);
		}
		public AssignmentOperatorContext assignmentOperator() {
			return getRuleContext(AssignmentOperatorContext.class,0);
		}
		public InitializerClauseContext initializerClause() {
			return getRuleContext(InitializerClauseContext.class,0);
		}
		public ThrowExpressionContext throwExpression() {
			return getRuleContext(ThrowExpressionContext.class,0);
		}
		public AssignmentExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_assignmentExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterAssignmentExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitAssignmentExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitAssignmentExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final AssignmentExpressionContext assignmentExpression() throws RecognitionException {
		AssignmentExpressionContext _localctx = new AssignmentExpressionContext(_ctx, getState());
		enterRule(_localctx, 86, RULE_assignmentExpression);
		try {
			setState(821);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,71,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(815);
				conditionalExpression();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(816);
				logicalOrExpression();
				setState(817);
				assignmentOperator();
				setState(818);
				initializerClause();
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(820);
				throwExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class AssignmentOperatorContext extends ParserRuleContext {
		public TerminalNode Assign() { return getToken(CPP14Parser.Assign, 0); }
		public TerminalNode StarAssign() { return getToken(CPP14Parser.StarAssign, 0); }
		public TerminalNode DivAssign() { return getToken(CPP14Parser.DivAssign, 0); }
		public TerminalNode ModAssign() { return getToken(CPP14Parser.ModAssign, 0); }
		public TerminalNode PlusAssign() { return getToken(CPP14Parser.PlusAssign, 0); }
		public TerminalNode MinusAssign() { return getToken(CPP14Parser.MinusAssign, 0); }
		public TerminalNode RightShiftAssign() { return getToken(CPP14Parser.RightShiftAssign, 0); }
		public TerminalNode LeftShiftAssign() { return getToken(CPP14Parser.LeftShiftAssign, 0); }
		public TerminalNode AndAssign() { return getToken(CPP14Parser.AndAssign, 0); }
		public TerminalNode XorAssign() { return getToken(CPP14Parser.XorAssign, 0); }
		public TerminalNode OrAssign() { return getToken(CPP14Parser.OrAssign, 0); }
		public AssignmentOperatorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_assignmentOperator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterAssignmentOperator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitAssignmentOperator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitAssignmentOperator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final AssignmentOperatorContext assignmentOperator() throws RecognitionException {
		AssignmentOperatorContext _localctx = new AssignmentOperatorContext(_ctx, getState());
		enterRule(_localctx, 88, RULE_assignmentOperator);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(823);
			_la = _input.LA(1);
			if ( !(((((_la - 101)) & ~0x3f) == 0 && ((1L << (_la - 101)) & 8185L) != 0)) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ExpressionContext extends ParserRuleContext {
		public List<AssignmentExpressionContext> assignmentExpression() {
			return getRuleContexts(AssignmentExpressionContext.class);
		}
		public AssignmentExpressionContext assignmentExpression(int i) {
			return getRuleContext(AssignmentExpressionContext.class,i);
		}
		public List<TerminalNode> Comma() { return getTokens(CPP14Parser.Comma); }
		public TerminalNode Comma(int i) {
			return getToken(CPP14Parser.Comma, i);
		}
		public ExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_expression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ExpressionContext expression() throws RecognitionException {
		ExpressionContext _localctx = new ExpressionContext(_ctx, getState());
		enterRule(_localctx, 90, RULE_expression);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(825);
			assignmentExpression();
			setState(830);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==Comma) {
				{
				{
				setState(826);
				match(Comma);
				setState(827);
				assignmentExpression();
				}
				}
				setState(832);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ConstantExpressionContext extends ParserRuleContext {
		public ConditionalExpressionContext conditionalExpression() {
			return getRuleContext(ConditionalExpressionContext.class,0);
		}
		public ConstantExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_constantExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterConstantExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitConstantExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitConstantExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ConstantExpressionContext constantExpression() throws RecognitionException {
		ConstantExpressionContext _localctx = new ConstantExpressionContext(_ctx, getState());
		enterRule(_localctx, 92, RULE_constantExpression);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(833);
			conditionalExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class StatementContext extends ParserRuleContext {
		public LabeledStatementContext labeledStatement() {
			return getRuleContext(LabeledStatementContext.class,0);
		}
		public DeclarationStatementContext declarationStatement() {
			return getRuleContext(DeclarationStatementContext.class,0);
		}
		public ExpressionStatementContext expressionStatement() {
			return getRuleContext(ExpressionStatementContext.class,0);
		}
		public CompoundStatementContext compoundStatement() {
			return getRuleContext(CompoundStatementContext.class,0);
		}
		public SelectionStatementContext selectionStatement() {
			return getRuleContext(SelectionStatementContext.class,0);
		}
		public IterationStatementContext iterationStatement() {
			return getRuleContext(IterationStatementContext.class,0);
		}
		public JumpStatementContext jumpStatement() {
			return getRuleContext(JumpStatementContext.class,0);
		}
		public TryBlockContext tryBlock() {
			return getRuleContext(TryBlockContext.class,0);
		}
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_statement; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterStatement(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitStatement(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitStatement(this);
			else return visitor.visitChildren(this);
		}
	}

	public final StatementContext statement() throws RecognitionException {
		StatementContext _localctx = new StatementContext(_ctx, getState());
		enterRule(_localctx, 94, RULE_statement);
		try {
			setState(848);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,75,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(835);
				labeledStatement();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(836);
				declarationStatement();
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(838);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,73,_ctx) ) {
				case 1:
					{
					setState(837);
					attributeSpecifierSeq();
					}
					break;
				}
				setState(846);
				_errHandler.sync(this);
				switch (_input.LA(1)) {
				case IntegerLiteral:
				case CharacterLiteral:
				case FloatingLiteral:
				case StringLiteral:
				case BooleanLiteral:
				case PointerLiteral:
				case UserDefinedLiteral:
				case Alignof:
				case Auto:
				case Bool:
				case Char:
				case Char16:
				case Char32:
				case Const_cast:
				case Decltype:
				case Delete:
				case Double:
				case Dynamic_cast:
				case Float:
				case Int:
				case Long:
				case New:
				case Noexcept:
				case Operator:
				case Reinterpret_cast:
				case Short:
				case Signed:
				case Sizeof:
				case Static_cast:
				case This:
				case Throw:
				case Typeid_:
				case Typename_:
				case Unsigned:
				case Void:
				case Wchar:
				case LeftParen:
				case LeftBracket:
				case Plus:
				case Minus:
				case Star:
				case And:
				case Or:
				case Tilde:
				case Not:
				case PlusPlus:
				case MinusMinus:
				case Doublecolon:
				case Semi:
				case Identifier:
					{
					setState(840);
					expressionStatement();
					}
					break;
				case LeftBrace:
					{
					setState(841);
					compoundStatement();
					}
					break;
				case If:
				case Switch:
					{
					setState(842);
					selectionStatement();
					}
					break;
				case Do:
				case For:
				case While:
					{
					setState(843);
					iterationStatement();
					}
					break;
				case Break:
				case Continue:
				case Goto:
				case Return:
					{
					setState(844);
					jumpStatement();
					}
					break;
				case Try:
					{
					setState(845);
					tryBlock();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class LabeledStatementContext extends ParserRuleContext {
		public TerminalNode Colon() { return getToken(CPP14Parser.Colon, 0); }
		public StatementContext statement() {
			return getRuleContext(StatementContext.class,0);
		}
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public TerminalNode Case() { return getToken(CPP14Parser.Case, 0); }
		public ConstantExpressionContext constantExpression() {
			return getRuleContext(ConstantExpressionContext.class,0);
		}
		public TerminalNode Default() { return getToken(CPP14Parser.Default, 0); }
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public LabeledStatementContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_labeledStatement; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterLabeledStatement(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitLabeledStatement(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitLabeledStatement(this);
			else return visitor.visitChildren(this);
		}
	}

	public final LabeledStatementContext labeledStatement() throws RecognitionException {
		LabeledStatementContext _localctx = new LabeledStatementContext(_ctx, getState());
		enterRule(_localctx, 96, RULE_labeledStatement);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(851);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Alignas || _la==LeftBracket) {
				{
				setState(850);
				attributeSpecifierSeq();
				}
			}

			setState(857);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case Identifier:
				{
				setState(853);
				match(Identifier);
				}
				break;
			case Case:
				{
				setState(854);
				match(Case);
				setState(855);
				constantExpression();
				}
				break;
			case Default:
				{
				setState(856);
				match(Default);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			setState(859);
			match(Colon);
			setState(860);
			statement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ExpressionStatementContext extends ParserRuleContext {
		public TerminalNode Semi() { return getToken(CPP14Parser.Semi, 0); }
		public ExpressionContext expression() {
			return getRuleContext(ExpressionContext.class,0);
		}
		public ExpressionStatementContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_expressionStatement; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterExpressionStatement(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitExpressionStatement(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitExpressionStatement(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ExpressionStatementContext expressionStatement() throws RecognitionException {
		ExpressionStatementContext _localctx = new ExpressionStatementContext(_ctx, getState());
		enterRule(_localctx, 98, RULE_expressionStatement);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(863);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 8364979464334764286L) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & 4719772474384133201L) != 0) || _la==Identifier) {
				{
				setState(862);
				expression();
				}
			}

			setState(865);
			match(Semi);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class CompoundStatementContext extends ParserRuleContext {
		public TerminalNode LeftBrace() { return getToken(CPP14Parser.LeftBrace, 0); }
		public TerminalNode RightBrace() { return getToken(CPP14Parser.RightBrace, 0); }
		public StatementSeqContext statementSeq() {
			return getRuleContext(StatementSeqContext.class,0);
		}
		public CompoundStatementContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_compoundStatement; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterCompoundStatement(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitCompoundStatement(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitCompoundStatement(this);
			else return visitor.visitChildren(this);
		}
	}

	public final CompoundStatementContext compoundStatement() throws RecognitionException {
		CompoundStatementContext _localctx = new CompoundStatementContext(_ctx, getState());
		enterRule(_localctx, 100, RULE_compoundStatement);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(867);
			match(LeftBrace);
			setState(869);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & -137360239606498050L) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & -8989184726396829969L) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & 25L) != 0)) {
				{
				setState(868);
				statementSeq();
				}
			}

			setState(871);
			match(RightBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class StatementSeqContext extends ParserRuleContext {
		public List<StatementContext> statement() {
			return getRuleContexts(StatementContext.class);
		}
		public StatementContext statement(int i) {
			return getRuleContext(StatementContext.class,i);
		}
		public StatementSeqContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_statementSeq; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterStatementSeq(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitStatementSeq(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitStatementSeq(this);
			else return visitor.visitChildren(this);
		}
	}

	public final StatementSeqContext statementSeq() throws RecognitionException {
		StatementSeqContext _localctx = new StatementSeqContext(_ctx, getState());
		enterRule(_localctx, 102, RULE_statementSeq);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(874); 
			_errHandler.sync(this);
			_la = _input.LA(1);
			do {
				{
				{
				setState(873);
				statement();
				}
				}
				setState(876); 
				_errHandler.sync(this);
				_la = _input.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & -137360239606498050L) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & -8989184726396829969L) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & 25L) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class SelectionStatementContext extends ParserRuleContext {
		public TerminalNode If() { return getToken(CPP14Parser.If, 0); }
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public ConditionContext condition() {
			return getRuleContext(ConditionContext.class,0);
		}
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public List<StatementContext> statement() {
			return getRuleContexts(StatementContext.class);
		}
		public StatementContext statement(int i) {
			return getRuleContext(StatementContext.class,i);
		}
		public TerminalNode Else() { return getToken(CPP14Parser.Else, 0); }
		public TerminalNode Switch() { return getToken(CPP14Parser.Switch, 0); }
		public SelectionStatementContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_selectionStatement; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterSelectionStatement(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitSelectionStatement(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitSelectionStatement(this);
			else return visitor.visitChildren(this);
		}
	}

	public final SelectionStatementContext selectionStatement() throws RecognitionException {
		SelectionStatementContext _localctx = new SelectionStatementContext(_ctx, getState());
		enterRule(_localctx, 104, RULE_selectionStatement);
		try {
			setState(893);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case If:
				enterOuterAlt(_localctx, 1);
				{
				setState(878);
				match(If);
				setState(879);
				match(LeftParen);
				setState(880);
				condition();
				setState(881);
				match(RightParen);
				setState(882);
				statement();
				setState(885);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,81,_ctx) ) {
				case 1:
					{
					setState(883);
					match(Else);
					setState(884);
					statement();
					}
					break;
				}
				}
				break;
			case Switch:
				enterOuterAlt(_localctx, 2);
				{
				setState(887);
				match(Switch);
				setState(888);
				match(LeftParen);
				setState(889);
				condition();
				setState(890);
				match(RightParen);
				setState(891);
				statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ConditionContext extends ParserRuleContext {
		public ExpressionContext expression() {
			return getRuleContext(ExpressionContext.class,0);
		}
		public DeclSpecifierSeqContext declSpecifierSeq() {
			return getRuleContext(DeclSpecifierSeqContext.class,0);
		}
		public DeclaratorContext declarator() {
			return getRuleContext(DeclaratorContext.class,0);
		}
		public TerminalNode Assign() { return getToken(CPP14Parser.Assign, 0); }
		public InitializerClauseContext initializerClause() {
			return getRuleContext(InitializerClauseContext.class,0);
		}
		public BracedInitListContext bracedInitList() {
			return getRuleContext(BracedInitListContext.class,0);
		}
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public ConditionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_condition; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterCondition(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitCondition(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitCondition(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ConditionContext condition() throws RecognitionException {
		ConditionContext _localctx = new ConditionContext(_ctx, getState());
		enterRule(_localctx, 106, RULE_condition);
		int _la;
		try {
			setState(906);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,85,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(895);
				expression();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(897);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Alignas || _la==LeftBracket) {
					{
					setState(896);
					attributeSpecifierSeq();
					}
				}

				setState(899);
				declSpecifierSeq();
				setState(900);
				declarator();
				setState(904);
				_errHandler.sync(this);
				switch (_input.LA(1)) {
				case Assign:
					{
					setState(901);
					match(Assign);
					setState(902);
					initializerClause();
					}
					break;
				case LeftBrace:
					{
					setState(903);
					bracedInitList();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class IterationStatementContext extends ParserRuleContext {
		public TerminalNode While() { return getToken(CPP14Parser.While, 0); }
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public ConditionContext condition() {
			return getRuleContext(ConditionContext.class,0);
		}
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public StatementContext statement() {
			return getRuleContext(StatementContext.class,0);
		}
		public TerminalNode Do() { return getToken(CPP14Parser.Do, 0); }
		public ExpressionContext expression() {
			return getRuleContext(ExpressionContext.class,0);
		}
		public TerminalNode Semi() { return getToken(CPP14Parser.Semi, 0); }
		public TerminalNode For() { return getToken(CPP14Parser.For, 0); }
		public ForInitStatementContext forInitStatement() {
			return getRuleContext(ForInitStatementContext.class,0);
		}
		public ForRangeDeclarationContext forRangeDeclaration() {
			return getRuleContext(ForRangeDeclarationContext.class,0);
		}
		public TerminalNode Colon() { return getToken(CPP14Parser.Colon, 0); }
		public ForRangeInitializerContext forRangeInitializer() {
			return getRuleContext(ForRangeInitializerContext.class,0);
		}
		public IterationStatementContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_iterationStatement; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterIterationStatement(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitIterationStatement(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitIterationStatement(this);
			else return visitor.visitChildren(this);
		}
	}

	public final IterationStatementContext iterationStatement() throws RecognitionException {
		IterationStatementContext _localctx = new IterationStatementContext(_ctx, getState());
		enterRule(_localctx, 108, RULE_iterationStatement);
		int _la;
		try {
			setState(941);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case While:
				enterOuterAlt(_localctx, 1);
				{
				setState(908);
				match(While);
				setState(909);
				match(LeftParen);
				setState(910);
				condition();
				setState(911);
				match(RightParen);
				setState(912);
				statement();
				}
				break;
			case Do:
				enterOuterAlt(_localctx, 2);
				{
				setState(914);
				match(Do);
				setState(915);
				statement();
				setState(916);
				match(While);
				setState(917);
				match(LeftParen);
				setState(918);
				expression();
				setState(919);
				match(RightParen);
				setState(920);
				match(Semi);
				}
				break;
			case For:
				enterOuterAlt(_localctx, 3);
				{
				setState(922);
				match(For);
				setState(923);
				match(LeftParen);
				setState(936);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,88,_ctx) ) {
				case 1:
					{
					setState(924);
					forInitStatement();
					setState(926);
					_errHandler.sync(this);
					_la = _input.LA(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & -714116761242538754L) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & 4719772474384301683L) != 0) || _la==Identifier) {
						{
						setState(925);
						condition();
						}
					}

					setState(928);
					match(Semi);
					setState(930);
					_errHandler.sync(this);
					_la = _input.LA(1);
					if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 8364979464334764286L) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & 4719772474384133201L) != 0) || _la==Identifier) {
						{
						setState(929);
						expression();
						}
					}

					}
					break;
				case 2:
					{
					setState(932);
					forRangeDeclaration();
					setState(933);
					match(Colon);
					setState(934);
					forRangeInitializer();
					}
					break;
				}
				setState(938);
				match(RightParen);
				setState(939);
				statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ForInitStatementContext extends ParserRuleContext {
		public ExpressionStatementContext expressionStatement() {
			return getRuleContext(ExpressionStatementContext.class,0);
		}
		public SimpleDeclarationContext simpleDeclaration() {
			return getRuleContext(SimpleDeclarationContext.class,0);
		}
		public ForInitStatementContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_forInitStatement; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterForInitStatement(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitForInitStatement(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitForInitStatement(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ForInitStatementContext forInitStatement() throws RecognitionException {
		ForInitStatementContext _localctx = new ForInitStatementContext(_ctx, getState());
		enterRule(_localctx, 110, RULE_forInitStatement);
		try {
			setState(945);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,90,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(943);
				expressionStatement();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(944);
				simpleDeclaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ForRangeDeclarationContext extends ParserRuleContext {
		public DeclSpecifierSeqContext declSpecifierSeq() {
			return getRuleContext(DeclSpecifierSeqContext.class,0);
		}
		public DeclaratorContext declarator() {
			return getRuleContext(DeclaratorContext.class,0);
		}
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public ForRangeDeclarationContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_forRangeDeclaration; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterForRangeDeclaration(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitForRangeDeclaration(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitForRangeDeclaration(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ForRangeDeclarationContext forRangeDeclaration() throws RecognitionException {
		ForRangeDeclarationContext _localctx = new ForRangeDeclarationContext(_ctx, getState());
		enterRule(_localctx, 112, RULE_forRangeDeclaration);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(948);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Alignas || _la==LeftBracket) {
				{
				setState(947);
				attributeSpecifierSeq();
				}
			}

			setState(950);
			declSpecifierSeq();
			setState(951);
			declarator();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ForRangeInitializerContext extends ParserRuleContext {
		public ExpressionContext expression() {
			return getRuleContext(ExpressionContext.class,0);
		}
		public BracedInitListContext bracedInitList() {
			return getRuleContext(BracedInitListContext.class,0);
		}
		public ForRangeInitializerContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_forRangeInitializer; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterForRangeInitializer(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitForRangeInitializer(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitForRangeInitializer(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ForRangeInitializerContext forRangeInitializer() throws RecognitionException {
		ForRangeInitializerContext _localctx = new ForRangeInitializerContext(_ctx, getState());
		enterRule(_localctx, 114, RULE_forRangeInitializer);
		try {
			setState(955);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case IntegerLiteral:
			case CharacterLiteral:
			case FloatingLiteral:
			case StringLiteral:
			case BooleanLiteral:
			case PointerLiteral:
			case UserDefinedLiteral:
			case Alignof:
			case Auto:
			case Bool:
			case Char:
			case Char16:
			case Char32:
			case Const_cast:
			case Decltype:
			case Delete:
			case Double:
			case Dynamic_cast:
			case Float:
			case Int:
			case Long:
			case New:
			case Noexcept:
			case Operator:
			case Reinterpret_cast:
			case Short:
			case Signed:
			case Sizeof:
			case Static_cast:
			case This:
			case Throw:
			case Typeid_:
			case Typename_:
			case Unsigned:
			case Void:
			case Wchar:
			case LeftParen:
			case LeftBracket:
			case Plus:
			case Minus:
			case Star:
			case And:
			case Or:
			case Tilde:
			case Not:
			case PlusPlus:
			case MinusMinus:
			case Doublecolon:
			case Identifier:
				enterOuterAlt(_localctx, 1);
				{
				setState(953);
				expression();
				}
				break;
			case LeftBrace:
				enterOuterAlt(_localctx, 2);
				{
				setState(954);
				bracedInitList();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class JumpStatementContext extends ParserRuleContext {
		public TerminalNode Semi() { return getToken(CPP14Parser.Semi, 0); }
		public TerminalNode Break() { return getToken(CPP14Parser.Break, 0); }
		public TerminalNode Continue() { return getToken(CPP14Parser.Continue, 0); }
		public TerminalNode Return() { return getToken(CPP14Parser.Return, 0); }
		public TerminalNode Goto() { return getToken(CPP14Parser.Goto, 0); }
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public ExpressionContext expression() {
			return getRuleContext(ExpressionContext.class,0);
		}
		public BracedInitListContext bracedInitList() {
			return getRuleContext(BracedInitListContext.class,0);
		}
		public JumpStatementContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_jumpStatement; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterJumpStatement(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitJumpStatement(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitJumpStatement(this);
			else return visitor.visitChildren(this);
		}
	}

	public final JumpStatementContext jumpStatement() throws RecognitionException {
		JumpStatementContext _localctx = new JumpStatementContext(_ctx, getState());
		enterRule(_localctx, 116, RULE_jumpStatement);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(966);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case Break:
				{
				setState(957);
				match(Break);
				}
				break;
			case Continue:
				{
				setState(958);
				match(Continue);
				}
				break;
			case Return:
				{
				setState(959);
				match(Return);
				setState(962);
				_errHandler.sync(this);
				switch (_input.LA(1)) {
				case IntegerLiteral:
				case CharacterLiteral:
				case FloatingLiteral:
				case StringLiteral:
				case BooleanLiteral:
				case PointerLiteral:
				case UserDefinedLiteral:
				case Alignof:
				case Auto:
				case Bool:
				case Char:
				case Char16:
				case Char32:
				case Const_cast:
				case Decltype:
				case Delete:
				case Double:
				case Dynamic_cast:
				case Float:
				case Int:
				case Long:
				case New:
				case Noexcept:
				case Operator:
				case Reinterpret_cast:
				case Short:
				case Signed:
				case Sizeof:
				case Static_cast:
				case This:
				case Throw:
				case Typeid_:
				case Typename_:
				case Unsigned:
				case Void:
				case Wchar:
				case LeftParen:
				case LeftBracket:
				case Plus:
				case Minus:
				case Star:
				case And:
				case Or:
				case Tilde:
				case Not:
				case PlusPlus:
				case MinusMinus:
				case Doublecolon:
				case Identifier:
					{
					setState(960);
					expression();
					}
					break;
				case LeftBrace:
					{
					setState(961);
					bracedInitList();
					}
					break;
				case Semi:
					break;
				default:
					break;
				}
				}
				break;
			case Goto:
				{
				setState(964);
				match(Goto);
				setState(965);
				match(Identifier);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			setState(968);
			match(Semi);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class DeclarationStatementContext extends ParserRuleContext {
		public BlockDeclarationContext blockDeclaration() {
			return getRuleContext(BlockDeclarationContext.class,0);
		}
		public DeclarationStatementContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_declarationStatement; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterDeclarationStatement(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitDeclarationStatement(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitDeclarationStatement(this);
			else return visitor.visitChildren(this);
		}
	}

	public final DeclarationStatementContext declarationStatement() throws RecognitionException {
		DeclarationStatementContext _localctx = new DeclarationStatementContext(_ctx, getState());
		enterRule(_localctx, 118, RULE_declarationStatement);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(970);
			blockDeclaration();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class DeclarationseqContext extends ParserRuleContext {
		public List<DeclarationContext> declaration() {
			return getRuleContexts(DeclarationContext.class);
		}
		public DeclarationContext declaration(int i) {
			return getRuleContext(DeclarationContext.class,i);
		}
		public DeclarationseqContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_declarationseq; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterDeclarationseq(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitDeclarationseq(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitDeclarationseq(this);
			else return visitor.visitChildren(this);
		}
	}

	public final DeclarationseqContext declarationseq() throws RecognitionException {
		DeclarationseqContext _localctx = new DeclarationseqContext(_ctx, getState());
		enterRule(_localctx, 120, RULE_declarationseq);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(973); 
			_errHandler.sync(this);
			_la = _input.LA(1);
			do {
				{
				{
				setState(972);
				declaration();
				}
				}
				setState(975); 
				_errHandler.sync(this);
				_la = _input.LA(1);
			} while ( ((((_la - 10)) & ~0x3f) == 0 && ((1L << (_la - 10)) & 1543754443169808157L) != 0) || ((((_la - 74)) & ~0x3f) == 0 && ((1L << (_la - 74)) & 459384754220313597L) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class DeclarationContext extends ParserRuleContext {
		public BlockDeclarationContext blockDeclaration() {
			return getRuleContext(BlockDeclarationContext.class,0);
		}
		public FunctionDefinitionContext functionDefinition() {
			return getRuleContext(FunctionDefinitionContext.class,0);
		}
		public TemplateDeclarationContext templateDeclaration() {
			return getRuleContext(TemplateDeclarationContext.class,0);
		}
		public ExplicitInstantiationContext explicitInstantiation() {
			return getRuleContext(ExplicitInstantiationContext.class,0);
		}
		public ExplicitSpecializationContext explicitSpecialization() {
			return getRuleContext(ExplicitSpecializationContext.class,0);
		}
		public LinkageSpecificationContext linkageSpecification() {
			return getRuleContext(LinkageSpecificationContext.class,0);
		}
		public NamespaceDefinitionContext namespaceDefinition() {
			return getRuleContext(NamespaceDefinitionContext.class,0);
		}
		public EmptyDeclaration_Context emptyDeclaration_() {
			return getRuleContext(EmptyDeclaration_Context.class,0);
		}
		public AttributeDeclarationContext attributeDeclaration() {
			return getRuleContext(AttributeDeclarationContext.class,0);
		}
		public DeclarationContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_declaration; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterDeclaration(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitDeclaration(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitDeclaration(this);
			else return visitor.visitChildren(this);
		}
	}

	public final DeclarationContext declaration() throws RecognitionException {
		DeclarationContext _localctx = new DeclarationContext(_ctx, getState());
		enterRule(_localctx, 122, RULE_declaration);
		try {
			setState(986);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,96,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(977);
				blockDeclaration();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(978);
				functionDefinition();
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(979);
				templateDeclaration();
				}
				break;
			case 4:
				enterOuterAlt(_localctx, 4);
				{
				setState(980);
				explicitInstantiation();
				}
				break;
			case 5:
				enterOuterAlt(_localctx, 5);
				{
				setState(981);
				explicitSpecialization();
				}
				break;
			case 6:
				enterOuterAlt(_localctx, 6);
				{
				setState(982);
				linkageSpecification();
				}
				break;
			case 7:
				enterOuterAlt(_localctx, 7);
				{
				setState(983);
				namespaceDefinition();
				}
				break;
			case 8:
				enterOuterAlt(_localctx, 8);
				{
				setState(984);
				emptyDeclaration_();
				}
				break;
			case 9:
				enterOuterAlt(_localctx, 9);
				{
				setState(985);
				attributeDeclaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class BlockDeclarationContext extends ParserRuleContext {
		public SimpleDeclarationContext simpleDeclaration() {
			return getRuleContext(SimpleDeclarationContext.class,0);
		}
		public AsmDefinitionContext asmDefinition() {
			return getRuleContext(AsmDefinitionContext.class,0);
		}
		public NamespaceAliasDefinitionContext namespaceAliasDefinition() {
			return getRuleContext(NamespaceAliasDefinitionContext.class,0);
		}
		public UsingDeclarationContext usingDeclaration() {
			return getRuleContext(UsingDeclarationContext.class,0);
		}
		public UsingDirectiveContext usingDirective() {
			return getRuleContext(UsingDirectiveContext.class,0);
		}
		public StaticAssertDeclarationContext staticAssertDeclaration() {
			return getRuleContext(StaticAssertDeclarationContext.class,0);
		}
		public AliasDeclarationContext aliasDeclaration() {
			return getRuleContext(AliasDeclarationContext.class,0);
		}
		public OpaqueEnumDeclarationContext opaqueEnumDeclaration() {
			return getRuleContext(OpaqueEnumDeclarationContext.class,0);
		}
		public BlockDeclarationContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_blockDeclaration; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterBlockDeclaration(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitBlockDeclaration(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitBlockDeclaration(this);
			else return visitor.visitChildren(this);
		}
	}

	public final BlockDeclarationContext blockDeclaration() throws RecognitionException {
		BlockDeclarationContext _localctx = new BlockDeclarationContext(_ctx, getState());
		enterRule(_localctx, 124, RULE_blockDeclaration);
		try {
			setState(996);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,97,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(988);
				simpleDeclaration();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(989);
				asmDefinition();
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(990);
				namespaceAliasDefinition();
				}
				break;
			case 4:
				enterOuterAlt(_localctx, 4);
				{
				setState(991);
				usingDeclaration();
				}
				break;
			case 5:
				enterOuterAlt(_localctx, 5);
				{
				setState(992);
				usingDirective();
				}
				break;
			case 6:
				enterOuterAlt(_localctx, 6);
				{
				setState(993);
				staticAssertDeclaration();
				}
				break;
			case 7:
				enterOuterAlt(_localctx, 7);
				{
				setState(994);
				aliasDeclaration();
				}
				break;
			case 8:
				enterOuterAlt(_localctx, 8);
				{
				setState(995);
				opaqueEnumDeclaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class AliasDeclarationContext extends ParserRuleContext {
		public TerminalNode Using() { return getToken(CPP14Parser.Using, 0); }
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public TerminalNode Assign() { return getToken(CPP14Parser.Assign, 0); }
		public TheTypeIdContext theTypeId() {
			return getRuleContext(TheTypeIdContext.class,0);
		}
		public TerminalNode Semi() { return getToken(CPP14Parser.Semi, 0); }
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public AliasDeclarationContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_aliasDeclaration; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterAliasDeclaration(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitAliasDeclaration(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitAliasDeclaration(this);
			else return visitor.visitChildren(this);
		}
	}

	public final AliasDeclarationContext aliasDeclaration() throws RecognitionException {
		AliasDeclarationContext _localctx = new AliasDeclarationContext(_ctx, getState());
		enterRule(_localctx, 126, RULE_aliasDeclaration);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(998);
			match(Using);
			setState(999);
			match(Identifier);
			setState(1001);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Alignas || _la==LeftBracket) {
				{
				setState(1000);
				attributeSpecifierSeq();
				}
			}

			setState(1003);
			match(Assign);
			setState(1004);
			theTypeId();
			setState(1005);
			match(Semi);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class SimpleDeclarationContext extends ParserRuleContext {
		public TerminalNode Semi() { return getToken(CPP14Parser.Semi, 0); }
		public DeclSpecifierSeqContext declSpecifierSeq() {
			return getRuleContext(DeclSpecifierSeqContext.class,0);
		}
		public InitDeclaratorListContext initDeclaratorList() {
			return getRuleContext(InitDeclaratorListContext.class,0);
		}
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public SimpleDeclarationContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_simpleDeclaration; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterSimpleDeclaration(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitSimpleDeclaration(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitSimpleDeclaration(this);
			else return visitor.visitChildren(this);
		}
	}

	public final SimpleDeclarationContext simpleDeclaration() throws RecognitionException {
		SimpleDeclarationContext _localctx = new SimpleDeclarationContext(_ctx, getState());
		enterRule(_localctx, 128, RULE_simpleDeclaration);
		int _la;
		try {
			setState(1021);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case Auto:
			case Bool:
			case Char:
			case Char16:
			case Char32:
			case Class:
			case Const:
			case Constexpr:
			case Decltype:
			case Double:
			case Enum:
			case Explicit:
			case Extern:
			case Float:
			case Friend:
			case Inline:
			case Int:
			case Long:
			case Mutable:
			case Operator:
			case Register:
			case Short:
			case Signed:
			case Static:
			case Struct:
			case Thread_local:
			case Typedef:
			case Typename_:
			case Union:
			case Unsigned:
			case Virtual:
			case Void:
			case Volatile:
			case Wchar:
			case LeftParen:
			case Star:
			case And:
			case Tilde:
			case AndAnd:
			case Doublecolon:
			case Semi:
			case Ellipsis:
			case Identifier:
				enterOuterAlt(_localctx, 1);
				{
				setState(1008);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,99,_ctx) ) {
				case 1:
					{
					setState(1007);
					declSpecifierSeq();
					}
					break;
				}
				setState(1011);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Decltype || _la==Operator || ((((_la - 85)) & ~0x3f) == 0 && ((1L << (_la - 85)) & 215512868999425L) != 0)) {
					{
					setState(1010);
					initDeclaratorList();
					}
				}

				setState(1013);
				match(Semi);
				}
				break;
			case Alignas:
			case LeftBracket:
				enterOuterAlt(_localctx, 2);
				{
				setState(1014);
				attributeSpecifierSeq();
				setState(1016);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,101,_ctx) ) {
				case 1:
					{
					setState(1015);
					declSpecifierSeq();
					}
					break;
				}
				setState(1018);
				initDeclaratorList();
				setState(1019);
				match(Semi);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class StaticAssertDeclarationContext extends ParserRuleContext {
		public TerminalNode Static_assert() { return getToken(CPP14Parser.Static_assert, 0); }
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public ConstantExpressionContext constantExpression() {
			return getRuleContext(ConstantExpressionContext.class,0);
		}
		public TerminalNode Comma() { return getToken(CPP14Parser.Comma, 0); }
		public TerminalNode StringLiteral() { return getToken(CPP14Parser.StringLiteral, 0); }
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public TerminalNode Semi() { return getToken(CPP14Parser.Semi, 0); }
		public StaticAssertDeclarationContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_staticAssertDeclaration; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterStaticAssertDeclaration(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitStaticAssertDeclaration(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitStaticAssertDeclaration(this);
			else return visitor.visitChildren(this);
		}
	}

	public final StaticAssertDeclarationContext staticAssertDeclaration() throws RecognitionException {
		StaticAssertDeclarationContext _localctx = new StaticAssertDeclarationContext(_ctx, getState());
		enterRule(_localctx, 130, RULE_staticAssertDeclaration);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1023);
			match(Static_assert);
			setState(1024);
			match(LeftParen);
			setState(1025);
			constantExpression();
			setState(1026);
			match(Comma);
			setState(1027);
			match(StringLiteral);
			setState(1028);
			match(RightParen);
			setState(1029);
			match(Semi);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class EmptyDeclaration_Context extends ParserRuleContext {
		public TerminalNode Semi() { return getToken(CPP14Parser.Semi, 0); }
		public EmptyDeclaration_Context(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_emptyDeclaration_; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterEmptyDeclaration_(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitEmptyDeclaration_(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitEmptyDeclaration_(this);
			else return visitor.visitChildren(this);
		}
	}

	public final EmptyDeclaration_Context emptyDeclaration_() throws RecognitionException {
		EmptyDeclaration_Context _localctx = new EmptyDeclaration_Context(_ctx, getState());
		enterRule(_localctx, 132, RULE_emptyDeclaration_);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1031);
			match(Semi);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class AttributeDeclarationContext extends ParserRuleContext {
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public TerminalNode Semi() { return getToken(CPP14Parser.Semi, 0); }
		public AttributeDeclarationContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_attributeDeclaration; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterAttributeDeclaration(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitAttributeDeclaration(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitAttributeDeclaration(this);
			else return visitor.visitChildren(this);
		}
	}

	public final AttributeDeclarationContext attributeDeclaration() throws RecognitionException {
		AttributeDeclarationContext _localctx = new AttributeDeclarationContext(_ctx, getState());
		enterRule(_localctx, 134, RULE_attributeDeclaration);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1033);
			attributeSpecifierSeq();
			setState(1034);
			match(Semi);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class DeclSpecifierContext extends ParserRuleContext {
		public StorageClassSpecifierContext storageClassSpecifier() {
			return getRuleContext(StorageClassSpecifierContext.class,0);
		}
		public TypeSpecifierContext typeSpecifier() {
			return getRuleContext(TypeSpecifierContext.class,0);
		}
		public FunctionSpecifierContext functionSpecifier() {
			return getRuleContext(FunctionSpecifierContext.class,0);
		}
		public TerminalNode Friend() { return getToken(CPP14Parser.Friend, 0); }
		public TerminalNode Typedef() { return getToken(CPP14Parser.Typedef, 0); }
		public TerminalNode Constexpr() { return getToken(CPP14Parser.Constexpr, 0); }
		public DeclSpecifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_declSpecifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterDeclSpecifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitDeclSpecifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitDeclSpecifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final DeclSpecifierContext declSpecifier() throws RecognitionException {
		DeclSpecifierContext _localctx = new DeclSpecifierContext(_ctx, getState());
		enterRule(_localctx, 136, RULE_declSpecifier);
		try {
			setState(1042);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case Extern:
			case Mutable:
			case Register:
			case Static:
			case Thread_local:
				enterOuterAlt(_localctx, 1);
				{
				setState(1036);
				storageClassSpecifier();
				}
				break;
			case Auto:
			case Bool:
			case Char:
			case Char16:
			case Char32:
			case Class:
			case Const:
			case Decltype:
			case Double:
			case Enum:
			case Float:
			case Int:
			case Long:
			case Short:
			case Signed:
			case Struct:
			case Typename_:
			case Union:
			case Unsigned:
			case Void:
			case Volatile:
			case Wchar:
			case Doublecolon:
			case Identifier:
				enterOuterAlt(_localctx, 2);
				{
				setState(1037);
				typeSpecifier();
				}
				break;
			case Explicit:
			case Inline:
			case Virtual:
				enterOuterAlt(_localctx, 3);
				{
				setState(1038);
				functionSpecifier();
				}
				break;
			case Friend:
				enterOuterAlt(_localctx, 4);
				{
				setState(1039);
				match(Friend);
				}
				break;
			case Typedef:
				enterOuterAlt(_localctx, 5);
				{
				setState(1040);
				match(Typedef);
				}
				break;
			case Constexpr:
				enterOuterAlt(_localctx, 6);
				{
				setState(1041);
				match(Constexpr);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class DeclSpecifierSeqContext extends ParserRuleContext {
		public List<DeclSpecifierContext> declSpecifier() {
			return getRuleContexts(DeclSpecifierContext.class);
		}
		public DeclSpecifierContext declSpecifier(int i) {
			return getRuleContext(DeclSpecifierContext.class,i);
		}
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public DeclSpecifierSeqContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_declSpecifierSeq; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterDeclSpecifierSeq(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitDeclSpecifierSeq(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitDeclSpecifierSeq(this);
			else return visitor.visitChildren(this);
		}
	}

	public final DeclSpecifierSeqContext declSpecifierSeq() throws RecognitionException {
		DeclSpecifierSeqContext _localctx = new DeclSpecifierSeqContext(_ctx, getState());
		enterRule(_localctx, 138, RULE_declSpecifierSeq);
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			setState(1045); 
			_errHandler.sync(this);
			_alt = 1+1;
			do {
				switch (_alt) {
				case 1+1:
					{
					{
					setState(1044);
					declSpecifier();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				setState(1047); 
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,104,_ctx);
			} while ( _alt!=1 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER );
			setState(1050);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,105,_ctx) ) {
			case 1:
				{
				setState(1049);
				attributeSpecifierSeq();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class StorageClassSpecifierContext extends ParserRuleContext {
		public TerminalNode Register() { return getToken(CPP14Parser.Register, 0); }
		public TerminalNode Static() { return getToken(CPP14Parser.Static, 0); }
		public TerminalNode Thread_local() { return getToken(CPP14Parser.Thread_local, 0); }
		public TerminalNode Extern() { return getToken(CPP14Parser.Extern, 0); }
		public TerminalNode Mutable() { return getToken(CPP14Parser.Mutable, 0); }
		public StorageClassSpecifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_storageClassSpecifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterStorageClassSpecifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitStorageClassSpecifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitStorageClassSpecifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final StorageClassSpecifierContext storageClassSpecifier() throws RecognitionException {
		StorageClassSpecifierContext _localctx = new StorageClassSpecifierContext(_ctx, getState());
		enterRule(_localctx, 140, RULE_storageClassSpecifier);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1052);
			_la = _input.LA(1);
			if ( !(((((_la - 36)) & ~0x3f) == 0 && ((1L << (_la - 36)) & 17316186113L) != 0)) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class FunctionSpecifierContext extends ParserRuleContext {
		public TerminalNode Inline() { return getToken(CPP14Parser.Inline, 0); }
		public TerminalNode Virtual() { return getToken(CPP14Parser.Virtual, 0); }
		public TerminalNode Explicit() { return getToken(CPP14Parser.Explicit, 0); }
		public FunctionSpecifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_functionSpecifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterFunctionSpecifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitFunctionSpecifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitFunctionSpecifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final FunctionSpecifierContext functionSpecifier() throws RecognitionException {
		FunctionSpecifierContext _localctx = new FunctionSpecifierContext(_ctx, getState());
		enterRule(_localctx, 142, RULE_functionSpecifier);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1054);
			_la = _input.LA(1);
			if ( !(((((_la - 34)) & ~0x3f) == 0 && ((1L << (_la - 34)) & 70368744178689L) != 0)) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TypedefNameContext extends ParserRuleContext {
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public TypedefNameContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_typedefName; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTypedefName(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTypedefName(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTypedefName(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TypedefNameContext typedefName() throws RecognitionException {
		TypedefNameContext _localctx = new TypedefNameContext(_ctx, getState());
		enterRule(_localctx, 144, RULE_typedefName);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1056);
			match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TypeSpecifierContext extends ParserRuleContext {
		public TrailingTypeSpecifierContext trailingTypeSpecifier() {
			return getRuleContext(TrailingTypeSpecifierContext.class,0);
		}
		public ClassSpecifierContext classSpecifier() {
			return getRuleContext(ClassSpecifierContext.class,0);
		}
		public EnumSpecifierContext enumSpecifier() {
			return getRuleContext(EnumSpecifierContext.class,0);
		}
		public TypeSpecifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_typeSpecifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTypeSpecifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTypeSpecifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTypeSpecifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TypeSpecifierContext typeSpecifier() throws RecognitionException {
		TypeSpecifierContext _localctx = new TypeSpecifierContext(_ctx, getState());
		enterRule(_localctx, 146, RULE_typeSpecifier);
		try {
			setState(1061);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,106,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(1058);
				trailingTypeSpecifier();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(1059);
				classSpecifier();
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(1060);
				enumSpecifier();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TrailingTypeSpecifierContext extends ParserRuleContext {
		public SimpleTypeSpecifierContext simpleTypeSpecifier() {
			return getRuleContext(SimpleTypeSpecifierContext.class,0);
		}
		public ElaboratedTypeSpecifierContext elaboratedTypeSpecifier() {
			return getRuleContext(ElaboratedTypeSpecifierContext.class,0);
		}
		public TypeNameSpecifierContext typeNameSpecifier() {
			return getRuleContext(TypeNameSpecifierContext.class,0);
		}
		public CvQualifierContext cvQualifier() {
			return getRuleContext(CvQualifierContext.class,0);
		}
		public TrailingTypeSpecifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_trailingTypeSpecifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTrailingTypeSpecifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTrailingTypeSpecifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTrailingTypeSpecifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TrailingTypeSpecifierContext trailingTypeSpecifier() throws RecognitionException {
		TrailingTypeSpecifierContext _localctx = new TrailingTypeSpecifierContext(_ctx, getState());
		enterRule(_localctx, 148, RULE_trailingTypeSpecifier);
		try {
			setState(1067);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case Auto:
			case Bool:
			case Char:
			case Char16:
			case Char32:
			case Decltype:
			case Double:
			case Float:
			case Int:
			case Long:
			case Short:
			case Signed:
			case Unsigned:
			case Void:
			case Wchar:
			case Doublecolon:
			case Identifier:
				enterOuterAlt(_localctx, 1);
				{
				setState(1063);
				simpleTypeSpecifier();
				}
				break;
			case Class:
			case Enum:
			case Struct:
				enterOuterAlt(_localctx, 2);
				{
				setState(1064);
				elaboratedTypeSpecifier();
				}
				break;
			case Typename_:
				enterOuterAlt(_localctx, 3);
				{
				setState(1065);
				typeNameSpecifier();
				}
				break;
			case Const:
			case Volatile:
				enterOuterAlt(_localctx, 4);
				{
				setState(1066);
				cvQualifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TypeSpecifierSeqContext extends ParserRuleContext {
		public List<TypeSpecifierContext> typeSpecifier() {
			return getRuleContexts(TypeSpecifierContext.class);
		}
		public TypeSpecifierContext typeSpecifier(int i) {
			return getRuleContext(TypeSpecifierContext.class,i);
		}
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public TypeSpecifierSeqContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_typeSpecifierSeq; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTypeSpecifierSeq(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTypeSpecifierSeq(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTypeSpecifierSeq(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TypeSpecifierSeqContext typeSpecifierSeq() throws RecognitionException {
		TypeSpecifierSeqContext _localctx = new TypeSpecifierSeqContext(_ctx, getState());
		enterRule(_localctx, 150, RULE_typeSpecifierSeq);
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			setState(1070); 
			_errHandler.sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					setState(1069);
					typeSpecifier();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				setState(1072); 
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,108,_ctx);
			} while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER );
			setState(1075);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,109,_ctx) ) {
			case 1:
				{
				setState(1074);
				attributeSpecifierSeq();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TrailingTypeSpecifierSeqContext extends ParserRuleContext {
		public List<TrailingTypeSpecifierContext> trailingTypeSpecifier() {
			return getRuleContexts(TrailingTypeSpecifierContext.class);
		}
		public TrailingTypeSpecifierContext trailingTypeSpecifier(int i) {
			return getRuleContext(TrailingTypeSpecifierContext.class,i);
		}
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public TrailingTypeSpecifierSeqContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_trailingTypeSpecifierSeq; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTrailingTypeSpecifierSeq(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTrailingTypeSpecifierSeq(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTrailingTypeSpecifierSeq(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TrailingTypeSpecifierSeqContext trailingTypeSpecifierSeq() throws RecognitionException {
		TrailingTypeSpecifierSeqContext _localctx = new TrailingTypeSpecifierSeqContext(_ctx, getState());
		enterRule(_localctx, 152, RULE_trailingTypeSpecifierSeq);
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			setState(1078); 
			_errHandler.sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					setState(1077);
					trailingTypeSpecifier();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				setState(1080); 
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,110,_ctx);
			} while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER );
			setState(1083);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,111,_ctx) ) {
			case 1:
				{
				setState(1082);
				attributeSpecifierSeq();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class SimpleTypeLengthModifierContext extends ParserRuleContext {
		public TerminalNode Short() { return getToken(CPP14Parser.Short, 0); }
		public TerminalNode Long() { return getToken(CPP14Parser.Long, 0); }
		public SimpleTypeLengthModifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_simpleTypeLengthModifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterSimpleTypeLengthModifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitSimpleTypeLengthModifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitSimpleTypeLengthModifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final SimpleTypeLengthModifierContext simpleTypeLengthModifier() throws RecognitionException {
		SimpleTypeLengthModifierContext _localctx = new SimpleTypeLengthModifierContext(_ctx, getState());
		enterRule(_localctx, 154, RULE_simpleTypeLengthModifier);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1085);
			_la = _input.LA(1);
			if ( !(_la==Long || _la==Short) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class SimpleTypeSignednessModifierContext extends ParserRuleContext {
		public TerminalNode Unsigned() { return getToken(CPP14Parser.Unsigned, 0); }
		public TerminalNode Signed() { return getToken(CPP14Parser.Signed, 0); }
		public SimpleTypeSignednessModifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_simpleTypeSignednessModifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterSimpleTypeSignednessModifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitSimpleTypeSignednessModifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitSimpleTypeSignednessModifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final SimpleTypeSignednessModifierContext simpleTypeSignednessModifier() throws RecognitionException {
		SimpleTypeSignednessModifierContext _localctx = new SimpleTypeSignednessModifierContext(_ctx, getState());
		enterRule(_localctx, 156, RULE_simpleTypeSignednessModifier);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1087);
			_la = _input.LA(1);
			if ( !(_la==Signed || _la==Unsigned) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class SimpleTypeSpecifierContext extends ParserRuleContext {
		public TheTypeNameContext theTypeName() {
			return getRuleContext(TheTypeNameContext.class,0);
		}
		public NestedNameSpecifierContext nestedNameSpecifier() {
			return getRuleContext(NestedNameSpecifierContext.class,0);
		}
		public TerminalNode Template() { return getToken(CPP14Parser.Template, 0); }
		public SimpleTemplateIdContext simpleTemplateId() {
			return getRuleContext(SimpleTemplateIdContext.class,0);
		}
		public TerminalNode Char() { return getToken(CPP14Parser.Char, 0); }
		public TerminalNode Char16() { return getToken(CPP14Parser.Char16, 0); }
		public TerminalNode Char32() { return getToken(CPP14Parser.Char32, 0); }
		public TerminalNode Wchar() { return getToken(CPP14Parser.Wchar, 0); }
		public TerminalNode Bool() { return getToken(CPP14Parser.Bool, 0); }
		public TerminalNode Short() { return getToken(CPP14Parser.Short, 0); }
		public TerminalNode Int() { return getToken(CPP14Parser.Int, 0); }
		public TerminalNode Long() { return getToken(CPP14Parser.Long, 0); }
		public TerminalNode Float() { return getToken(CPP14Parser.Float, 0); }
		public TerminalNode Signed() { return getToken(CPP14Parser.Signed, 0); }
		public TerminalNode Unsigned() { return getToken(CPP14Parser.Unsigned, 0); }
		public TerminalNode Double() { return getToken(CPP14Parser.Double, 0); }
		public TerminalNode Void() { return getToken(CPP14Parser.Void, 0); }
		public TerminalNode Auto() { return getToken(CPP14Parser.Auto, 0); }
		public DecltypeSpecifierContext decltypeSpecifier() {
			return getRuleContext(DecltypeSpecifierContext.class,0);
		}
		public SimpleTypeSpecifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_simpleTypeSpecifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterSimpleTypeSpecifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitSimpleTypeSpecifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitSimpleTypeSpecifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final SimpleTypeSpecifierContext simpleTypeSpecifier() throws RecognitionException {
		SimpleTypeSpecifierContext _localctx = new SimpleTypeSpecifierContext(_ctx, getState());
		enterRule(_localctx, 158, RULE_simpleTypeSpecifier);
		try {
			setState(1113);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,113,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(1090);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,112,_ctx) ) {
				case 1:
					{
					setState(1089);
					nestedNameSpecifier(0);
					}
					break;
				}
				setState(1092);
				theTypeName();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(1093);
				nestedNameSpecifier(0);
				setState(1094);
				match(Template);
				setState(1095);
				simpleTemplateId();
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(1097);
				match(Char);
				}
				break;
			case 4:
				enterOuterAlt(_localctx, 4);
				{
				setState(1098);
				match(Char16);
				}
				break;
			case 5:
				enterOuterAlt(_localctx, 5);
				{
				setState(1099);
				match(Char32);
				}
				break;
			case 6:
				enterOuterAlt(_localctx, 6);
				{
				setState(1100);
				match(Wchar);
				}
				break;
			case 7:
				enterOuterAlt(_localctx, 7);
				{
				setState(1101);
				match(Bool);
				}
				break;
			case 8:
				enterOuterAlt(_localctx, 8);
				{
				setState(1102);
				match(Short);
				}
				break;
			case 9:
				enterOuterAlt(_localctx, 9);
				{
				setState(1103);
				match(Int);
				}
				break;
			case 10:
				enterOuterAlt(_localctx, 10);
				{
				setState(1104);
				match(Long);
				}
				break;
			case 11:
				enterOuterAlt(_localctx, 11);
				{
				setState(1105);
				match(Float);
				}
				break;
			case 12:
				enterOuterAlt(_localctx, 12);
				{
				setState(1106);
				match(Signed);
				}
				break;
			case 13:
				enterOuterAlt(_localctx, 13);
				{
				setState(1107);
				match(Unsigned);
				}
				break;
			case 14:
				enterOuterAlt(_localctx, 14);
				{
				setState(1108);
				match(Float);
				}
				break;
			case 15:
				enterOuterAlt(_localctx, 15);
				{
				setState(1109);
				match(Double);
				}
				break;
			case 16:
				enterOuterAlt(_localctx, 16);
				{
				setState(1110);
				match(Void);
				}
				break;
			case 17:
				enterOuterAlt(_localctx, 17);
				{
				setState(1111);
				match(Auto);
				}
				break;
			case 18:
				enterOuterAlt(_localctx, 18);
				{
				setState(1112);
				decltypeSpecifier();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TheTypeNameContext extends ParserRuleContext {
		public ClassNameContext className() {
			return getRuleContext(ClassNameContext.class,0);
		}
		public EnumNameContext enumName() {
			return getRuleContext(EnumNameContext.class,0);
		}
		public TypedefNameContext typedefName() {
			return getRuleContext(TypedefNameContext.class,0);
		}
		public SimpleTemplateIdContext simpleTemplateId() {
			return getRuleContext(SimpleTemplateIdContext.class,0);
		}
		public TheTypeNameContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_theTypeName; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTheTypeName(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTheTypeName(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTheTypeName(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TheTypeNameContext theTypeName() throws RecognitionException {
		TheTypeNameContext _localctx = new TheTypeNameContext(_ctx, getState());
		enterRule(_localctx, 160, RULE_theTypeName);
		try {
			setState(1119);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,114,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(1115);
				className();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(1116);
				enumName();
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(1117);
				typedefName();
				}
				break;
			case 4:
				enterOuterAlt(_localctx, 4);
				{
				setState(1118);
				simpleTemplateId();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class DecltypeSpecifierContext extends ParserRuleContext {
		public TerminalNode Decltype() { return getToken(CPP14Parser.Decltype, 0); }
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public ExpressionContext expression() {
			return getRuleContext(ExpressionContext.class,0);
		}
		public TerminalNode Auto() { return getToken(CPP14Parser.Auto, 0); }
		public DecltypeSpecifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_decltypeSpecifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterDecltypeSpecifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitDecltypeSpecifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitDecltypeSpecifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final DecltypeSpecifierContext decltypeSpecifier() throws RecognitionException {
		DecltypeSpecifierContext _localctx = new DecltypeSpecifierContext(_ctx, getState());
		enterRule(_localctx, 162, RULE_decltypeSpecifier);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1121);
			match(Decltype);
			setState(1122);
			match(LeftParen);
			setState(1125);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,115,_ctx) ) {
			case 1:
				{
				setState(1123);
				expression();
				}
				break;
			case 2:
				{
				setState(1124);
				match(Auto);
				}
				break;
			}
			setState(1127);
			match(RightParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ElaboratedTypeSpecifierContext extends ParserRuleContext {
		public ClassKeyContext classKey() {
			return getRuleContext(ClassKeyContext.class,0);
		}
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public SimpleTemplateIdContext simpleTemplateId() {
			return getRuleContext(SimpleTemplateIdContext.class,0);
		}
		public NestedNameSpecifierContext nestedNameSpecifier() {
			return getRuleContext(NestedNameSpecifierContext.class,0);
		}
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public TerminalNode Template() { return getToken(CPP14Parser.Template, 0); }
		public TerminalNode Enum() { return getToken(CPP14Parser.Enum, 0); }
		public ElaboratedTypeSpecifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_elaboratedTypeSpecifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterElaboratedTypeSpecifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitElaboratedTypeSpecifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitElaboratedTypeSpecifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ElaboratedTypeSpecifierContext elaboratedTypeSpecifier() throws RecognitionException {
		ElaboratedTypeSpecifierContext _localctx = new ElaboratedTypeSpecifierContext(_ctx, getState());
		enterRule(_localctx, 164, RULE_elaboratedTypeSpecifier);
		int _la;
		try {
			setState(1151);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case Class:
			case Struct:
				enterOuterAlt(_localctx, 1);
				{
				setState(1129);
				classKey();
				setState(1144);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,119,_ctx) ) {
				case 1:
					{
					setState(1131);
					_errHandler.sync(this);
					_la = _input.LA(1);
					if (_la==Alignas || _la==LeftBracket) {
						{
						setState(1130);
						attributeSpecifierSeq();
						}
					}

					setState(1134);
					_errHandler.sync(this);
					switch ( getInterpreter().adaptivePredict(_input,117,_ctx) ) {
					case 1:
						{
						setState(1133);
						nestedNameSpecifier(0);
						}
						break;
					}
					setState(1136);
					match(Identifier);
					}
					break;
				case 2:
					{
					setState(1137);
					simpleTemplateId();
					}
					break;
				case 3:
					{
					setState(1138);
					nestedNameSpecifier(0);
					setState(1140);
					_errHandler.sync(this);
					_la = _input.LA(1);
					if (_la==Template) {
						{
						setState(1139);
						match(Template);
						}
					}

					setState(1142);
					simpleTemplateId();
					}
					break;
				}
				}
				break;
			case Enum:
				enterOuterAlt(_localctx, 2);
				{
				setState(1146);
				match(Enum);
				setState(1148);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,120,_ctx) ) {
				case 1:
					{
					setState(1147);
					nestedNameSpecifier(0);
					}
					break;
				}
				setState(1150);
				match(Identifier);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class EnumNameContext extends ParserRuleContext {
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public EnumNameContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_enumName; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterEnumName(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitEnumName(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitEnumName(this);
			else return visitor.visitChildren(this);
		}
	}

	public final EnumNameContext enumName() throws RecognitionException {
		EnumNameContext _localctx = new EnumNameContext(_ctx, getState());
		enterRule(_localctx, 166, RULE_enumName);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1153);
			match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class EnumSpecifierContext extends ParserRuleContext {
		public EnumHeadContext enumHead() {
			return getRuleContext(EnumHeadContext.class,0);
		}
		public TerminalNode LeftBrace() { return getToken(CPP14Parser.LeftBrace, 0); }
		public TerminalNode RightBrace() { return getToken(CPP14Parser.RightBrace, 0); }
		public EnumeratorListContext enumeratorList() {
			return getRuleContext(EnumeratorListContext.class,0);
		}
		public TerminalNode Comma() { return getToken(CPP14Parser.Comma, 0); }
		public EnumSpecifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_enumSpecifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterEnumSpecifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitEnumSpecifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitEnumSpecifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final EnumSpecifierContext enumSpecifier() throws RecognitionException {
		EnumSpecifierContext _localctx = new EnumSpecifierContext(_ctx, getState());
		enterRule(_localctx, 168, RULE_enumSpecifier);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1155);
			enumHead();
			setState(1156);
			match(LeftBrace);
			setState(1161);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Identifier) {
				{
				setState(1157);
				enumeratorList();
				setState(1159);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Comma) {
					{
					setState(1158);
					match(Comma);
					}
				}

				}
			}

			setState(1163);
			match(RightBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class EnumHeadContext extends ParserRuleContext {
		public EnumkeyContext enumkey() {
			return getRuleContext(EnumkeyContext.class,0);
		}
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public EnumbaseContext enumbase() {
			return getRuleContext(EnumbaseContext.class,0);
		}
		public NestedNameSpecifierContext nestedNameSpecifier() {
			return getRuleContext(NestedNameSpecifierContext.class,0);
		}
		public EnumHeadContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_enumHead; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterEnumHead(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitEnumHead(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitEnumHead(this);
			else return visitor.visitChildren(this);
		}
	}

	public final EnumHeadContext enumHead() throws RecognitionException {
		EnumHeadContext _localctx = new EnumHeadContext(_ctx, getState());
		enterRule(_localctx, 170, RULE_enumHead);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1165);
			enumkey();
			setState(1167);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Alignas || _la==LeftBracket) {
				{
				setState(1166);
				attributeSpecifierSeq();
				}
			}

			setState(1173);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Decltype || _la==Doublecolon || _la==Identifier) {
				{
				setState(1170);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,125,_ctx) ) {
				case 1:
					{
					setState(1169);
					nestedNameSpecifier(0);
					}
					break;
				}
				setState(1172);
				match(Identifier);
				}
			}

			setState(1176);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Colon) {
				{
				setState(1175);
				enumbase();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class OpaqueEnumDeclarationContext extends ParserRuleContext {
		public EnumkeyContext enumkey() {
			return getRuleContext(EnumkeyContext.class,0);
		}
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public TerminalNode Semi() { return getToken(CPP14Parser.Semi, 0); }
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public EnumbaseContext enumbase() {
			return getRuleContext(EnumbaseContext.class,0);
		}
		public OpaqueEnumDeclarationContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_opaqueEnumDeclaration; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterOpaqueEnumDeclaration(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitOpaqueEnumDeclaration(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitOpaqueEnumDeclaration(this);
			else return visitor.visitChildren(this);
		}
	}

	public final OpaqueEnumDeclarationContext opaqueEnumDeclaration() throws RecognitionException {
		OpaqueEnumDeclarationContext _localctx = new OpaqueEnumDeclarationContext(_ctx, getState());
		enterRule(_localctx, 172, RULE_opaqueEnumDeclaration);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1178);
			enumkey();
			setState(1180);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Alignas || _la==LeftBracket) {
				{
				setState(1179);
				attributeSpecifierSeq();
				}
			}

			setState(1182);
			match(Identifier);
			setState(1184);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Colon) {
				{
				setState(1183);
				enumbase();
				}
			}

			setState(1186);
			match(Semi);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class EnumkeyContext extends ParserRuleContext {
		public TerminalNode Enum() { return getToken(CPP14Parser.Enum, 0); }
		public TerminalNode Class() { return getToken(CPP14Parser.Class, 0); }
		public TerminalNode Struct() { return getToken(CPP14Parser.Struct, 0); }
		public EnumkeyContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_enumkey; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterEnumkey(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitEnumkey(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitEnumkey(this);
			else return visitor.visitChildren(this);
		}
	}

	public final EnumkeyContext enumkey() throws RecognitionException {
		EnumkeyContext _localctx = new EnumkeyContext(_ctx, getState());
		enterRule(_localctx, 174, RULE_enumkey);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1188);
			match(Enum);
			setState(1190);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Class || _la==Struct) {
				{
				setState(1189);
				_la = _input.LA(1);
				if ( !(_la==Class || _la==Struct) ) {
				_errHandler.recoverInline(this);
				}
				else {
					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
					_errHandler.reportMatch(this);
					consume();
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class EnumbaseContext extends ParserRuleContext {
		public TerminalNode Colon() { return getToken(CPP14Parser.Colon, 0); }
		public TypeSpecifierSeqContext typeSpecifierSeq() {
			return getRuleContext(TypeSpecifierSeqContext.class,0);
		}
		public EnumbaseContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_enumbase; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterEnumbase(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitEnumbase(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitEnumbase(this);
			else return visitor.visitChildren(this);
		}
	}

	public final EnumbaseContext enumbase() throws RecognitionException {
		EnumbaseContext _localctx = new EnumbaseContext(_ctx, getState());
		enterRule(_localctx, 176, RULE_enumbase);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1192);
			match(Colon);
			setState(1193);
			typeSpecifierSeq();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class EnumeratorListContext extends ParserRuleContext {
		public List<EnumeratorDefinitionContext> enumeratorDefinition() {
			return getRuleContexts(EnumeratorDefinitionContext.class);
		}
		public EnumeratorDefinitionContext enumeratorDefinition(int i) {
			return getRuleContext(EnumeratorDefinitionContext.class,i);
		}
		public List<TerminalNode> Comma() { return getTokens(CPP14Parser.Comma); }
		public TerminalNode Comma(int i) {
			return getToken(CPP14Parser.Comma, i);
		}
		public EnumeratorListContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_enumeratorList; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterEnumeratorList(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitEnumeratorList(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitEnumeratorList(this);
			else return visitor.visitChildren(this);
		}
	}

	public final EnumeratorListContext enumeratorList() throws RecognitionException {
		EnumeratorListContext _localctx = new EnumeratorListContext(_ctx, getState());
		enterRule(_localctx, 178, RULE_enumeratorList);
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			setState(1195);
			enumeratorDefinition();
			setState(1200);
			_errHandler.sync(this);
			_alt = getInterpreter().adaptivePredict(_input,131,_ctx);
			while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					setState(1196);
					match(Comma);
					setState(1197);
					enumeratorDefinition();
					}
					} 
				}
				setState(1202);
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,131,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class EnumeratorDefinitionContext extends ParserRuleContext {
		public EnumeratorContext enumerator() {
			return getRuleContext(EnumeratorContext.class,0);
		}
		public TerminalNode Assign() { return getToken(CPP14Parser.Assign, 0); }
		public ConstantExpressionContext constantExpression() {
			return getRuleContext(ConstantExpressionContext.class,0);
		}
		public EnumeratorDefinitionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_enumeratorDefinition; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterEnumeratorDefinition(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitEnumeratorDefinition(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitEnumeratorDefinition(this);
			else return visitor.visitChildren(this);
		}
	}

	public final EnumeratorDefinitionContext enumeratorDefinition() throws RecognitionException {
		EnumeratorDefinitionContext _localctx = new EnumeratorDefinitionContext(_ctx, getState());
		enterRule(_localctx, 180, RULE_enumeratorDefinition);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1203);
			enumerator();
			setState(1206);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Assign) {
				{
				setState(1204);
				match(Assign);
				setState(1205);
				constantExpression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class EnumeratorContext extends ParserRuleContext {
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public EnumeratorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_enumerator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterEnumerator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitEnumerator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitEnumerator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final EnumeratorContext enumerator() throws RecognitionException {
		EnumeratorContext _localctx = new EnumeratorContext(_ctx, getState());
		enterRule(_localctx, 182, RULE_enumerator);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1208);
			match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class NamespaceNameContext extends ParserRuleContext {
		public OriginalNamespaceNameContext originalNamespaceName() {
			return getRuleContext(OriginalNamespaceNameContext.class,0);
		}
		public NamespaceAliasContext namespaceAlias() {
			return getRuleContext(NamespaceAliasContext.class,0);
		}
		public NamespaceNameContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_namespaceName; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterNamespaceName(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitNamespaceName(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitNamespaceName(this);
			else return visitor.visitChildren(this);
		}
	}

	public final NamespaceNameContext namespaceName() throws RecognitionException {
		NamespaceNameContext _localctx = new NamespaceNameContext(_ctx, getState());
		enterRule(_localctx, 184, RULE_namespaceName);
		try {
			setState(1212);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,133,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(1210);
				originalNamespaceName();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(1211);
				namespaceAlias();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class OriginalNamespaceNameContext extends ParserRuleContext {
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public OriginalNamespaceNameContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_originalNamespaceName; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterOriginalNamespaceName(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitOriginalNamespaceName(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitOriginalNamespaceName(this);
			else return visitor.visitChildren(this);
		}
	}

	public final OriginalNamespaceNameContext originalNamespaceName() throws RecognitionException {
		OriginalNamespaceNameContext _localctx = new OriginalNamespaceNameContext(_ctx, getState());
		enterRule(_localctx, 186, RULE_originalNamespaceName);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1214);
			match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class NamespaceDefinitionContext extends ParserRuleContext {
		public DeclarationseqContext namespaceBody;
		public TerminalNode Namespace() { return getToken(CPP14Parser.Namespace, 0); }
		public TerminalNode LeftBrace() { return getToken(CPP14Parser.LeftBrace, 0); }
		public TerminalNode RightBrace() { return getToken(CPP14Parser.RightBrace, 0); }
		public TerminalNode Inline() { return getToken(CPP14Parser.Inline, 0); }
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public OriginalNamespaceNameContext originalNamespaceName() {
			return getRuleContext(OriginalNamespaceNameContext.class,0);
		}
		public DeclarationseqContext declarationseq() {
			return getRuleContext(DeclarationseqContext.class,0);
		}
		public NamespaceDefinitionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_namespaceDefinition; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterNamespaceDefinition(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitNamespaceDefinition(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitNamespaceDefinition(this);
			else return visitor.visitChildren(this);
		}
	}

	public final NamespaceDefinitionContext namespaceDefinition() throws RecognitionException {
		NamespaceDefinitionContext _localctx = new NamespaceDefinitionContext(_ctx, getState());
		enterRule(_localctx, 188, RULE_namespaceDefinition);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1217);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Inline) {
				{
				setState(1216);
				match(Inline);
				}
			}

			setState(1219);
			match(Namespace);
			setState(1222);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,135,_ctx) ) {
			case 1:
				{
				setState(1220);
				match(Identifier);
				}
				break;
			case 2:
				{
				setState(1221);
				originalNamespaceName();
				}
				break;
			}
			setState(1224);
			match(LeftBrace);
			setState(1226);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (((((_la - 10)) & ~0x3f) == 0 && ((1L << (_la - 10)) & 1543754443169808157L) != 0) || ((((_la - 74)) & ~0x3f) == 0 && ((1L << (_la - 74)) & 459384754220313597L) != 0)) {
				{
				setState(1225);
				((NamespaceDefinitionContext)_localctx).namespaceBody = declarationseq();
				}
			}

			setState(1228);
			match(RightBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class NamespaceAliasContext extends ParserRuleContext {
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public NamespaceAliasContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_namespaceAlias; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterNamespaceAlias(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitNamespaceAlias(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitNamespaceAlias(this);
			else return visitor.visitChildren(this);
		}
	}

	public final NamespaceAliasContext namespaceAlias() throws RecognitionException {
		NamespaceAliasContext _localctx = new NamespaceAliasContext(_ctx, getState());
		enterRule(_localctx, 190, RULE_namespaceAlias);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1230);
			match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class NamespaceAliasDefinitionContext extends ParserRuleContext {
		public TerminalNode Namespace() { return getToken(CPP14Parser.Namespace, 0); }
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public TerminalNode Assign() { return getToken(CPP14Parser.Assign, 0); }
		public QualifiednamespacespecifierContext qualifiednamespacespecifier() {
			return getRuleContext(QualifiednamespacespecifierContext.class,0);
		}
		public TerminalNode Semi() { return getToken(CPP14Parser.Semi, 0); }
		public NamespaceAliasDefinitionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_namespaceAliasDefinition; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterNamespaceAliasDefinition(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitNamespaceAliasDefinition(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitNamespaceAliasDefinition(this);
			else return visitor.visitChildren(this);
		}
	}

	public final NamespaceAliasDefinitionContext namespaceAliasDefinition() throws RecognitionException {
		NamespaceAliasDefinitionContext _localctx = new NamespaceAliasDefinitionContext(_ctx, getState());
		enterRule(_localctx, 192, RULE_namespaceAliasDefinition);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1232);
			match(Namespace);
			setState(1233);
			match(Identifier);
			setState(1234);
			match(Assign);
			setState(1235);
			qualifiednamespacespecifier();
			setState(1236);
			match(Semi);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class QualifiednamespacespecifierContext extends ParserRuleContext {
		public NamespaceNameContext namespaceName() {
			return getRuleContext(NamespaceNameContext.class,0);
		}
		public NestedNameSpecifierContext nestedNameSpecifier() {
			return getRuleContext(NestedNameSpecifierContext.class,0);
		}
		public QualifiednamespacespecifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_qualifiednamespacespecifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterQualifiednamespacespecifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitQualifiednamespacespecifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitQualifiednamespacespecifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final QualifiednamespacespecifierContext qualifiednamespacespecifier() throws RecognitionException {
		QualifiednamespacespecifierContext _localctx = new QualifiednamespacespecifierContext(_ctx, getState());
		enterRule(_localctx, 194, RULE_qualifiednamespacespecifier);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1239);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,137,_ctx) ) {
			case 1:
				{
				setState(1238);
				nestedNameSpecifier(0);
				}
				break;
			}
			setState(1241);
			namespaceName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class UsingDeclarationContext extends ParserRuleContext {
		public TerminalNode Using() { return getToken(CPP14Parser.Using, 0); }
		public UnqualifiedIdContext unqualifiedId() {
			return getRuleContext(UnqualifiedIdContext.class,0);
		}
		public TerminalNode Semi() { return getToken(CPP14Parser.Semi, 0); }
		public NestedNameSpecifierContext nestedNameSpecifier() {
			return getRuleContext(NestedNameSpecifierContext.class,0);
		}
		public TerminalNode Doublecolon() { return getToken(CPP14Parser.Doublecolon, 0); }
		public TerminalNode Typename_() { return getToken(CPP14Parser.Typename_, 0); }
		public UsingDeclarationContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_usingDeclaration; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterUsingDeclaration(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitUsingDeclaration(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitUsingDeclaration(this);
			else return visitor.visitChildren(this);
		}
	}

	public final UsingDeclarationContext usingDeclaration() throws RecognitionException {
		UsingDeclarationContext _localctx = new UsingDeclarationContext(_ctx, getState());
		enterRule(_localctx, 196, RULE_usingDeclaration);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1243);
			match(Using);
			setState(1249);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,139,_ctx) ) {
			case 1:
				{
				setState(1245);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Typename_) {
					{
					setState(1244);
					match(Typename_);
					}
				}

				setState(1247);
				nestedNameSpecifier(0);
				}
				break;
			case 2:
				{
				setState(1248);
				match(Doublecolon);
				}
				break;
			}
			setState(1251);
			unqualifiedId();
			setState(1252);
			match(Semi);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class UsingDirectiveContext extends ParserRuleContext {
		public TerminalNode Using() { return getToken(CPP14Parser.Using, 0); }
		public TerminalNode Namespace() { return getToken(CPP14Parser.Namespace, 0); }
		public NamespaceNameContext namespaceName() {
			return getRuleContext(NamespaceNameContext.class,0);
		}
		public TerminalNode Semi() { return getToken(CPP14Parser.Semi, 0); }
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public NestedNameSpecifierContext nestedNameSpecifier() {
			return getRuleContext(NestedNameSpecifierContext.class,0);
		}
		public UsingDirectiveContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_usingDirective; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterUsingDirective(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitUsingDirective(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitUsingDirective(this);
			else return visitor.visitChildren(this);
		}
	}

	public final UsingDirectiveContext usingDirective() throws RecognitionException {
		UsingDirectiveContext _localctx = new UsingDirectiveContext(_ctx, getState());
		enterRule(_localctx, 198, RULE_usingDirective);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1255);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Alignas || _la==LeftBracket) {
				{
				setState(1254);
				attributeSpecifierSeq();
				}
			}

			setState(1257);
			match(Using);
			setState(1258);
			match(Namespace);
			setState(1260);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,141,_ctx) ) {
			case 1:
				{
				setState(1259);
				nestedNameSpecifier(0);
				}
				break;
			}
			setState(1262);
			namespaceName();
			setState(1263);
			match(Semi);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class AsmDefinitionContext extends ParserRuleContext {
		public TerminalNode Asm() { return getToken(CPP14Parser.Asm, 0); }
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public TerminalNode StringLiteral() { return getToken(CPP14Parser.StringLiteral, 0); }
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public TerminalNode Semi() { return getToken(CPP14Parser.Semi, 0); }
		public AsmDefinitionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_asmDefinition; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterAsmDefinition(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitAsmDefinition(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitAsmDefinition(this);
			else return visitor.visitChildren(this);
		}
	}

	public final AsmDefinitionContext asmDefinition() throws RecognitionException {
		AsmDefinitionContext _localctx = new AsmDefinitionContext(_ctx, getState());
		enterRule(_localctx, 200, RULE_asmDefinition);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1265);
			match(Asm);
			setState(1266);
			match(LeftParen);
			setState(1267);
			match(StringLiteral);
			setState(1268);
			match(RightParen);
			setState(1269);
			match(Semi);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class LinkageSpecificationContext extends ParserRuleContext {
		public TerminalNode Extern() { return getToken(CPP14Parser.Extern, 0); }
		public TerminalNode StringLiteral() { return getToken(CPP14Parser.StringLiteral, 0); }
		public TerminalNode LeftBrace() { return getToken(CPP14Parser.LeftBrace, 0); }
		public TerminalNode RightBrace() { return getToken(CPP14Parser.RightBrace, 0); }
		public DeclarationContext declaration() {
			return getRuleContext(DeclarationContext.class,0);
		}
		public DeclarationseqContext declarationseq() {
			return getRuleContext(DeclarationseqContext.class,0);
		}
		public LinkageSpecificationContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_linkageSpecification; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterLinkageSpecification(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitLinkageSpecification(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitLinkageSpecification(this);
			else return visitor.visitChildren(this);
		}
	}

	public final LinkageSpecificationContext linkageSpecification() throws RecognitionException {
		LinkageSpecificationContext _localctx = new LinkageSpecificationContext(_ctx, getState());
		enterRule(_localctx, 202, RULE_linkageSpecification);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1271);
			match(Extern);
			setState(1272);
			match(StringLiteral);
			setState(1279);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case LeftBrace:
				{
				setState(1273);
				match(LeftBrace);
				setState(1275);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (((((_la - 10)) & ~0x3f) == 0 && ((1L << (_la - 10)) & 1543754443169808157L) != 0) || ((((_la - 74)) & ~0x3f) == 0 && ((1L << (_la - 74)) & 459384754220313597L) != 0)) {
					{
					setState(1274);
					declarationseq();
					}
				}

				setState(1277);
				match(RightBrace);
				}
				break;
			case Alignas:
			case Asm:
			case Auto:
			case Bool:
			case Char:
			case Char16:
			case Char32:
			case Class:
			case Const:
			case Constexpr:
			case Decltype:
			case Double:
			case Enum:
			case Explicit:
			case Extern:
			case Float:
			case Friend:
			case Inline:
			case Int:
			case Long:
			case Mutable:
			case Namespace:
			case Operator:
			case Register:
			case Short:
			case Signed:
			case Static:
			case Static_assert:
			case Struct:
			case Template:
			case Thread_local:
			case Typedef:
			case Typename_:
			case Union:
			case Unsigned:
			case Using:
			case Virtual:
			case Void:
			case Volatile:
			case Wchar:
			case LeftParen:
			case LeftBracket:
			case Star:
			case And:
			case Tilde:
			case AndAnd:
			case Doublecolon:
			case Semi:
			case Ellipsis:
			case Identifier:
				{
				setState(1278);
				declaration();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class AttributeSpecifierSeqContext extends ParserRuleContext {
		public List<AttributeSpecifierContext> attributeSpecifier() {
			return getRuleContexts(AttributeSpecifierContext.class);
		}
		public AttributeSpecifierContext attributeSpecifier(int i) {
			return getRuleContext(AttributeSpecifierContext.class,i);
		}
		public AttributeSpecifierSeqContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_attributeSpecifierSeq; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterAttributeSpecifierSeq(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitAttributeSpecifierSeq(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitAttributeSpecifierSeq(this);
			else return visitor.visitChildren(this);
		}
	}

	public final AttributeSpecifierSeqContext attributeSpecifierSeq() throws RecognitionException {
		AttributeSpecifierSeqContext _localctx = new AttributeSpecifierSeqContext(_ctx, getState());
		enterRule(_localctx, 204, RULE_attributeSpecifierSeq);
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			setState(1282); 
			_errHandler.sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					setState(1281);
					attributeSpecifier();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				setState(1284); 
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,144,_ctx);
			} while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class AttributeSpecifierContext extends ParserRuleContext {
		public List<TerminalNode> LeftBracket() { return getTokens(CPP14Parser.LeftBracket); }
		public TerminalNode LeftBracket(int i) {
			return getToken(CPP14Parser.LeftBracket, i);
		}
		public List<TerminalNode> RightBracket() { return getTokens(CPP14Parser.RightBracket); }
		public TerminalNode RightBracket(int i) {
			return getToken(CPP14Parser.RightBracket, i);
		}
		public AttributeListContext attributeList() {
			return getRuleContext(AttributeListContext.class,0);
		}
		public AlignmentspecifierContext alignmentspecifier() {
			return getRuleContext(AlignmentspecifierContext.class,0);
		}
		public AttributeSpecifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_attributeSpecifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterAttributeSpecifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitAttributeSpecifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitAttributeSpecifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final AttributeSpecifierContext attributeSpecifier() throws RecognitionException {
		AttributeSpecifierContext _localctx = new AttributeSpecifierContext(_ctx, getState());
		enterRule(_localctx, 206, RULE_attributeSpecifier);
		int _la;
		try {
			setState(1294);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case LeftBracket:
				enterOuterAlt(_localctx, 1);
				{
				setState(1286);
				match(LeftBracket);
				setState(1287);
				match(LeftBracket);
				setState(1289);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Identifier) {
					{
					setState(1288);
					attributeList();
					}
				}

				setState(1291);
				match(RightBracket);
				setState(1292);
				match(RightBracket);
				}
				break;
			case Alignas:
				enterOuterAlt(_localctx, 2);
				{
				setState(1293);
				alignmentspecifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class AlignmentspecifierContext extends ParserRuleContext {
		public TerminalNode Alignas() { return getToken(CPP14Parser.Alignas, 0); }
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public TheTypeIdContext theTypeId() {
			return getRuleContext(TheTypeIdContext.class,0);
		}
		public ConstantExpressionContext constantExpression() {
			return getRuleContext(ConstantExpressionContext.class,0);
		}
		public TerminalNode Ellipsis() { return getToken(CPP14Parser.Ellipsis, 0); }
		public AlignmentspecifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_alignmentspecifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterAlignmentspecifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitAlignmentspecifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitAlignmentspecifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final AlignmentspecifierContext alignmentspecifier() throws RecognitionException {
		AlignmentspecifierContext _localctx = new AlignmentspecifierContext(_ctx, getState());
		enterRule(_localctx, 208, RULE_alignmentspecifier);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1296);
			match(Alignas);
			setState(1297);
			match(LeftParen);
			setState(1300);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,147,_ctx) ) {
			case 1:
				{
				setState(1298);
				theTypeId();
				}
				break;
			case 2:
				{
				setState(1299);
				constantExpression();
				}
				break;
			}
			setState(1303);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Ellipsis) {
				{
				setState(1302);
				match(Ellipsis);
				}
			}

			setState(1305);
			match(RightParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class AttributeListContext extends ParserRuleContext {
		public List<AttributeContext> attribute() {
			return getRuleContexts(AttributeContext.class);
		}
		public AttributeContext attribute(int i) {
			return getRuleContext(AttributeContext.class,i);
		}
		public List<TerminalNode> Comma() { return getTokens(CPP14Parser.Comma); }
		public TerminalNode Comma(int i) {
			return getToken(CPP14Parser.Comma, i);
		}
		public TerminalNode Ellipsis() { return getToken(CPP14Parser.Ellipsis, 0); }
		public AttributeListContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_attributeList; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterAttributeList(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitAttributeList(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitAttributeList(this);
			else return visitor.visitChildren(this);
		}
	}

	public final AttributeListContext attributeList() throws RecognitionException {
		AttributeListContext _localctx = new AttributeListContext(_ctx, getState());
		enterRule(_localctx, 210, RULE_attributeList);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1307);
			attribute();
			setState(1312);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==Comma) {
				{
				{
				setState(1308);
				match(Comma);
				setState(1309);
				attribute();
				}
				}
				setState(1314);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			setState(1316);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Ellipsis) {
				{
				setState(1315);
				match(Ellipsis);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class AttributeContext extends ParserRuleContext {
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public AttributeNamespaceContext attributeNamespace() {
			return getRuleContext(AttributeNamespaceContext.class,0);
		}
		public TerminalNode Doublecolon() { return getToken(CPP14Parser.Doublecolon, 0); }
		public AttributeArgumentClauseContext attributeArgumentClause() {
			return getRuleContext(AttributeArgumentClauseContext.class,0);
		}
		public AttributeContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_attribute; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterAttribute(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitAttribute(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitAttribute(this);
			else return visitor.visitChildren(this);
		}
	}

	public final AttributeContext attribute() throws RecognitionException {
		AttributeContext _localctx = new AttributeContext(_ctx, getState());
		enterRule(_localctx, 212, RULE_attribute);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1321);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,151,_ctx) ) {
			case 1:
				{
				setState(1318);
				attributeNamespace();
				setState(1319);
				match(Doublecolon);
				}
				break;
			}
			setState(1323);
			match(Identifier);
			setState(1325);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==LeftParen) {
				{
				setState(1324);
				attributeArgumentClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class AttributeNamespaceContext extends ParserRuleContext {
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public AttributeNamespaceContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_attributeNamespace; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterAttributeNamespace(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitAttributeNamespace(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitAttributeNamespace(this);
			else return visitor.visitChildren(this);
		}
	}

	public final AttributeNamespaceContext attributeNamespace() throws RecognitionException {
		AttributeNamespaceContext _localctx = new AttributeNamespaceContext(_ctx, getState());
		enterRule(_localctx, 214, RULE_attributeNamespace);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1327);
			match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class AttributeArgumentClauseContext extends ParserRuleContext {
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public BalancedTokenSeqContext balancedTokenSeq() {
			return getRuleContext(BalancedTokenSeqContext.class,0);
		}
		public AttributeArgumentClauseContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_attributeArgumentClause; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterAttributeArgumentClause(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitAttributeArgumentClause(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitAttributeArgumentClause(this);
			else return visitor.visitChildren(this);
		}
	}

	public final AttributeArgumentClauseContext attributeArgumentClause() throws RecognitionException {
		AttributeArgumentClauseContext _localctx = new AttributeArgumentClauseContext(_ctx, getState());
		enterRule(_localctx, 216, RULE_attributeArgumentClause);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1329);
			match(LeftParen);
			setState(1331);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & -2L) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & -88080385L) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & 262143L) != 0)) {
				{
				setState(1330);
				balancedTokenSeq();
				}
			}

			setState(1333);
			match(RightParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class BalancedTokenSeqContext extends ParserRuleContext {
		public List<BalancedtokenContext> balancedtoken() {
			return getRuleContexts(BalancedtokenContext.class);
		}
		public BalancedtokenContext balancedtoken(int i) {
			return getRuleContext(BalancedtokenContext.class,i);
		}
		public BalancedTokenSeqContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_balancedTokenSeq; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterBalancedTokenSeq(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitBalancedTokenSeq(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitBalancedTokenSeq(this);
			else return visitor.visitChildren(this);
		}
	}

	public final BalancedTokenSeqContext balancedTokenSeq() throws RecognitionException {
		BalancedTokenSeqContext _localctx = new BalancedTokenSeqContext(_ctx, getState());
		enterRule(_localctx, 218, RULE_balancedTokenSeq);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1336); 
			_errHandler.sync(this);
			_la = _input.LA(1);
			do {
				{
				{
				setState(1335);
				balancedtoken();
				}
				}
				setState(1338); 
				_errHandler.sync(this);
				_la = _input.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & -2L) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & -88080385L) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & 262143L) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class BalancedtokenContext extends ParserRuleContext {
		public List<TerminalNode> LeftParen() { return getTokens(CPP14Parser.LeftParen); }
		public TerminalNode LeftParen(int i) {
			return getToken(CPP14Parser.LeftParen, i);
		}
		public BalancedTokenSeqContext balancedTokenSeq() {
			return getRuleContext(BalancedTokenSeqContext.class,0);
		}
		public List<TerminalNode> RightParen() { return getTokens(CPP14Parser.RightParen); }
		public TerminalNode RightParen(int i) {
			return getToken(CPP14Parser.RightParen, i);
		}
		public List<TerminalNode> LeftBracket() { return getTokens(CPP14Parser.LeftBracket); }
		public TerminalNode LeftBracket(int i) {
			return getToken(CPP14Parser.LeftBracket, i);
		}
		public List<TerminalNode> RightBracket() { return getTokens(CPP14Parser.RightBracket); }
		public TerminalNode RightBracket(int i) {
			return getToken(CPP14Parser.RightBracket, i);
		}
		public List<TerminalNode> LeftBrace() { return getTokens(CPP14Parser.LeftBrace); }
		public TerminalNode LeftBrace(int i) {
			return getToken(CPP14Parser.LeftBrace, i);
		}
		public List<TerminalNode> RightBrace() { return getTokens(CPP14Parser.RightBrace); }
		public TerminalNode RightBrace(int i) {
			return getToken(CPP14Parser.RightBrace, i);
		}
		public BalancedtokenContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_balancedtoken; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterBalancedtoken(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitBalancedtoken(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitBalancedtoken(this);
			else return visitor.visitChildren(this);
		}
	}

	public final BalancedtokenContext balancedtoken() throws RecognitionException {
		BalancedtokenContext _localctx = new BalancedtokenContext(_ctx, getState());
		enterRule(_localctx, 220, RULE_balancedtoken);
		int _la;
		try {
			int _alt;
			setState(1357);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case LeftParen:
				enterOuterAlt(_localctx, 1);
				{
				setState(1340);
				match(LeftParen);
				setState(1341);
				balancedTokenSeq();
				setState(1342);
				match(RightParen);
				}
				break;
			case LeftBracket:
				enterOuterAlt(_localctx, 2);
				{
				setState(1344);
				match(LeftBracket);
				setState(1345);
				balancedTokenSeq();
				setState(1346);
				match(RightBracket);
				}
				break;
			case LeftBrace:
				enterOuterAlt(_localctx, 3);
				{
				setState(1348);
				match(LeftBrace);
				setState(1349);
				balancedTokenSeq();
				setState(1350);
				match(RightBrace);
				}
				break;
			case IntegerLiteral:
			case CharacterLiteral:
			case FloatingLiteral:
			case StringLiteral:
			case BooleanLiteral:
			case PointerLiteral:
			case UserDefinedLiteral:
			case MultiLineMacro:
			case Directive:
			case Alignas:
			case Alignof:
			case Asm:
			case Auto:
			case Bool:
			case Break:
			case Case:
			case Catch:
			case Char:
			case Char16:
			case Char32:
			case Class:
			case Const:
			case Constexpr:
			case Const_cast:
			case Continue:
			case Decltype:
			case Default:
			case Delete:
			case Do:
			case Double:
			case Dynamic_cast:
			case Else:
			case Enum:
			case Explicit:
			case Export:
			case Extern:
			case False_:
			case Final:
			case Float:
			case For:
			case Friend:
			case Goto:
			case If:
			case Inline:
			case Int:
			case Long:
			case Mutable:
			case Namespace:
			case New:
			case Noexcept:
			case Nullptr:
			case Operator:
			case Override:
			case Private:
			case Protected:
			case Public:
			case Register:
			case Reinterpret_cast:
			case Return:
			case Short:
			case Signed:
			case Sizeof:
			case Static:
			case Static_assert:
			case Static_cast:
			case Struct:
			case Switch:
			case Template:
			case This:
			case Thread_local:
			case Throw:
			case True_:
			case Try:
			case Typedef:
			case Typeid_:
			case Typename_:
			case Union:
			case Unsigned:
			case Using:
			case Virtual:
			case Void:
			case Volatile:
			case Wchar:
			case While:
			case Plus:
			case Minus:
			case Star:
			case Div:
			case Mod:
			case Caret:
			case And:
			case Or:
			case Tilde:
			case Not:
			case Assign:
			case Less:
			case Greater:
			case PlusAssign:
			case MinusAssign:
			case StarAssign:
			case DivAssign:
			case ModAssign:
			case XorAssign:
			case AndAssign:
			case OrAssign:
			case LeftShiftAssign:
			case RightShiftAssign:
			case Equal:
			case NotEqual:
			case LessEqual:
			case GreaterEqual:
			case AndAnd:
			case OrOr:
			case PlusPlus:
			case MinusMinus:
			case Comma:
			case ArrowStar:
			case Arrow:
			case Question:
			case Colon:
			case Doublecolon:
			case Semi:
			case Dot:
			case DotStar:
			case Ellipsis:
			case Identifier:
			case DecimalLiteral:
			case OctalLiteral:
			case HexadecimalLiteral:
			case BinaryLiteral:
			case Integersuffix:
			case UserDefinedIntegerLiteral:
			case UserDefinedFloatingLiteral:
			case UserDefinedStringLiteral:
			case UserDefinedCharacterLiteral:
			case Whitespace:
			case Newline:
			case BlockComment:
			case LineComment:
				enterOuterAlt(_localctx, 4);
				{
				setState(1353); 
				_errHandler.sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						{
						setState(1352);
						_la = _input.LA(1);
						if ( _la <= 0 || (((((_la - 85)) & ~0x3f) == 0 && ((1L << (_la - 85)) & 63L) != 0)) ) {
						_errHandler.recoverInline(this);
						}
						else {
							if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
							_errHandler.reportMatch(this);
							consume();
						}
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					setState(1355); 
					_errHandler.sync(this);
					_alt = getInterpreter().adaptivePredict(_input,155,_ctx);
				} while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class InitDeclaratorListContext extends ParserRuleContext {
		public List<InitDeclaratorContext> initDeclarator() {
			return getRuleContexts(InitDeclaratorContext.class);
		}
		public InitDeclaratorContext initDeclarator(int i) {
			return getRuleContext(InitDeclaratorContext.class,i);
		}
		public List<TerminalNode> Comma() { return getTokens(CPP14Parser.Comma); }
		public TerminalNode Comma(int i) {
			return getToken(CPP14Parser.Comma, i);
		}
		public InitDeclaratorListContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_initDeclaratorList; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterInitDeclaratorList(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitInitDeclaratorList(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitInitDeclaratorList(this);
			else return visitor.visitChildren(this);
		}
	}

	public final InitDeclaratorListContext initDeclaratorList() throws RecognitionException {
		InitDeclaratorListContext _localctx = new InitDeclaratorListContext(_ctx, getState());
		enterRule(_localctx, 222, RULE_initDeclaratorList);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1359);
			initDeclarator();
			setState(1364);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==Comma) {
				{
				{
				setState(1360);
				match(Comma);
				setState(1361);
				initDeclarator();
				}
				}
				setState(1366);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class InitDeclaratorContext extends ParserRuleContext {
		public DeclaratorContext declarator() {
			return getRuleContext(DeclaratorContext.class,0);
		}
		public InitializerContext initializer() {
			return getRuleContext(InitializerContext.class,0);
		}
		public InitDeclaratorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_initDeclarator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterInitDeclarator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitInitDeclarator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitInitDeclarator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final InitDeclaratorContext initDeclarator() throws RecognitionException {
		InitDeclaratorContext _localctx = new InitDeclaratorContext(_ctx, getState());
		enterRule(_localctx, 224, RULE_initDeclarator);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1367);
			declarator();
			setState(1369);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (((((_la - 85)) & ~0x3f) == 0 && ((1L << (_la - 85)) & 65553L) != 0)) {
				{
				setState(1368);
				initializer();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class DeclaratorContext extends ParserRuleContext {
		public PointerDeclaratorContext pointerDeclarator() {
			return getRuleContext(PointerDeclaratorContext.class,0);
		}
		public NoPointerDeclaratorContext noPointerDeclarator() {
			return getRuleContext(NoPointerDeclaratorContext.class,0);
		}
		public ParametersAndQualifiersContext parametersAndQualifiers() {
			return getRuleContext(ParametersAndQualifiersContext.class,0);
		}
		public TrailingReturnTypeContext trailingReturnType() {
			return getRuleContext(TrailingReturnTypeContext.class,0);
		}
		public DeclaratorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_declarator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterDeclarator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitDeclarator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitDeclarator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final DeclaratorContext declarator() throws RecognitionException {
		DeclaratorContext _localctx = new DeclaratorContext(_ctx, getState());
		enterRule(_localctx, 226, RULE_declarator);
		try {
			setState(1376);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,159,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(1371);
				pointerDeclarator();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(1372);
				noPointerDeclarator(0);
				setState(1373);
				parametersAndQualifiers();
				setState(1374);
				trailingReturnType();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class PointerDeclaratorContext extends ParserRuleContext {
		public NoPointerDeclaratorContext noPointerDeclarator() {
			return getRuleContext(NoPointerDeclaratorContext.class,0);
		}
		public List<PointerOperatorContext> pointerOperator() {
			return getRuleContexts(PointerOperatorContext.class);
		}
		public PointerOperatorContext pointerOperator(int i) {
			return getRuleContext(PointerOperatorContext.class,i);
		}
		public List<TerminalNode> Const() { return getTokens(CPP14Parser.Const); }
		public TerminalNode Const(int i) {
			return getToken(CPP14Parser.Const, i);
		}
		public PointerDeclaratorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_pointerDeclarator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterPointerDeclarator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitPointerDeclarator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitPointerDeclarator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final PointerDeclaratorContext pointerDeclarator() throws RecognitionException {
		PointerDeclaratorContext _localctx = new PointerDeclaratorContext(_ctx, getState());
		enterRule(_localctx, 228, RULE_pointerDeclarator);
		int _la;
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			setState(1384);
			_errHandler.sync(this);
			_alt = getInterpreter().adaptivePredict(_input,161,_ctx);
			while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					setState(1378);
					pointerOperator();
					setState(1380);
					_errHandler.sync(this);
					_la = _input.LA(1);
					if (_la==Const) {
						{
						setState(1379);
						match(Const);
						}
					}

					}
					} 
				}
				setState(1386);
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,161,_ctx);
			}
			setState(1387);
			noPointerDeclarator(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class NoPointerDeclaratorContext extends ParserRuleContext {
		public DeclaratoridContext declaratorid() {
			return getRuleContext(DeclaratoridContext.class,0);
		}
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public PointerDeclaratorContext pointerDeclarator() {
			return getRuleContext(PointerDeclaratorContext.class,0);
		}
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public NoPointerDeclaratorContext noPointerDeclarator() {
			return getRuleContext(NoPointerDeclaratorContext.class,0);
		}
		public ParametersAndQualifiersContext parametersAndQualifiers() {
			return getRuleContext(ParametersAndQualifiersContext.class,0);
		}
		public TerminalNode LeftBracket() { return getToken(CPP14Parser.LeftBracket, 0); }
		public TerminalNode RightBracket() { return getToken(CPP14Parser.RightBracket, 0); }
		public ConstantExpressionContext constantExpression() {
			return getRuleContext(ConstantExpressionContext.class,0);
		}
		public NoPointerDeclaratorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_noPointerDeclarator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterNoPointerDeclarator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitNoPointerDeclarator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitNoPointerDeclarator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final NoPointerDeclaratorContext noPointerDeclarator() throws RecognitionException {
		return noPointerDeclarator(0);
	}

	private NoPointerDeclaratorContext noPointerDeclarator(int _p) throws RecognitionException {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = getState();
		NoPointerDeclaratorContext _localctx = new NoPointerDeclaratorContext(_ctx, _parentState);
		NoPointerDeclaratorContext _prevctx = _localctx;
		int _startState = 230;
		enterRecursionRule(_localctx, 230, RULE_noPointerDeclarator, _p);
		int _la;
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			setState(1398);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case Decltype:
			case Operator:
			case Tilde:
			case Doublecolon:
			case Ellipsis:
			case Identifier:
				{
				setState(1390);
				declaratorid();
				setState(1392);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,162,_ctx) ) {
				case 1:
					{
					setState(1391);
					attributeSpecifierSeq();
					}
					break;
				}
				}
				break;
			case LeftParen:
				{
				setState(1394);
				match(LeftParen);
				setState(1395);
				pointerDeclarator();
				setState(1396);
				match(RightParen);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			_ctx.stop = _input.LT(-1);
			setState(1414);
			_errHandler.sync(this);
			_alt = getInterpreter().adaptivePredict(_input,167,_ctx);
			while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) triggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new NoPointerDeclaratorContext(_parentctx, _parentState);
					pushNewRecursionContext(_localctx, _startState, RULE_noPointerDeclarator);
					setState(1400);
					if (!(precpred(_ctx, 2))) throw new FailedPredicateException(this, "precpred(_ctx, 2)");
					setState(1410);
					_errHandler.sync(this);
					switch (_input.LA(1)) {
					case LeftParen:
						{
						setState(1401);
						parametersAndQualifiers();
						}
						break;
					case LeftBracket:
						{
						setState(1402);
						match(LeftBracket);
						setState(1404);
						_errHandler.sync(this);
						_la = _input.LA(1);
						if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 8364979464334764286L) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & 4719772474384133137L) != 0) || _la==Identifier) {
							{
							setState(1403);
							constantExpression();
							}
						}

						setState(1406);
						match(RightBracket);
						setState(1408);
						_errHandler.sync(this);
						switch ( getInterpreter().adaptivePredict(_input,165,_ctx) ) {
						case 1:
							{
							setState(1407);
							attributeSpecifierSeq();
							}
							break;
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					} 
				}
				setState(1416);
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,167,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			unrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ParametersAndQualifiersContext extends ParserRuleContext {
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public ParameterDeclarationClauseContext parameterDeclarationClause() {
			return getRuleContext(ParameterDeclarationClauseContext.class,0);
		}
		public CvqualifierseqContext cvqualifierseq() {
			return getRuleContext(CvqualifierseqContext.class,0);
		}
		public RefqualifierContext refqualifier() {
			return getRuleContext(RefqualifierContext.class,0);
		}
		public ExceptionSpecificationContext exceptionSpecification() {
			return getRuleContext(ExceptionSpecificationContext.class,0);
		}
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public ParametersAndQualifiersContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_parametersAndQualifiers; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterParametersAndQualifiers(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitParametersAndQualifiers(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitParametersAndQualifiers(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ParametersAndQualifiersContext parametersAndQualifiers() throws RecognitionException {
		ParametersAndQualifiersContext _localctx = new ParametersAndQualifiersContext(_ctx, getState());
		enterRule(_localctx, 232, RULE_parametersAndQualifiers);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1417);
			match(LeftParen);
			setState(1419);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (((((_la - 10)) & ~0x3f) == 0 && ((1L << (_la - 10)) & 1237504995584196377L) != 0) || ((((_la - 74)) & ~0x3f) == 0 && ((1L << (_la - 74)) & 297237575406461917L) != 0)) {
				{
				setState(1418);
				parameterDeclarationClause();
				}
			}

			setState(1421);
			match(RightParen);
			setState(1423);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,169,_ctx) ) {
			case 1:
				{
				setState(1422);
				cvqualifierseq();
				}
				break;
			}
			setState(1426);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,170,_ctx) ) {
			case 1:
				{
				setState(1425);
				refqualifier();
				}
				break;
			}
			setState(1429);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,171,_ctx) ) {
			case 1:
				{
				setState(1428);
				exceptionSpecification();
				}
				break;
			}
			setState(1432);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,172,_ctx) ) {
			case 1:
				{
				setState(1431);
				attributeSpecifierSeq();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TrailingReturnTypeContext extends ParserRuleContext {
		public TerminalNode Arrow() { return getToken(CPP14Parser.Arrow, 0); }
		public TrailingTypeSpecifierSeqContext trailingTypeSpecifierSeq() {
			return getRuleContext(TrailingTypeSpecifierSeqContext.class,0);
		}
		public AbstractDeclaratorContext abstractDeclarator() {
			return getRuleContext(AbstractDeclaratorContext.class,0);
		}
		public TrailingReturnTypeContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_trailingReturnType; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTrailingReturnType(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTrailingReturnType(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTrailingReturnType(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TrailingReturnTypeContext trailingReturnType() throws RecognitionException {
		TrailingReturnTypeContext _localctx = new TrailingReturnTypeContext(_ctx, getState());
		enterRule(_localctx, 234, RULE_trailingReturnType);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1434);
			match(Arrow);
			setState(1435);
			trailingTypeSpecifierSeq();
			setState(1437);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,173,_ctx) ) {
			case 1:
				{
				setState(1436);
				abstractDeclarator();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class PointerOperatorContext extends ParserRuleContext {
		public TerminalNode And() { return getToken(CPP14Parser.And, 0); }
		public TerminalNode AndAnd() { return getToken(CPP14Parser.AndAnd, 0); }
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public TerminalNode Star() { return getToken(CPP14Parser.Star, 0); }
		public NestedNameSpecifierContext nestedNameSpecifier() {
			return getRuleContext(NestedNameSpecifierContext.class,0);
		}
		public CvqualifierseqContext cvqualifierseq() {
			return getRuleContext(CvqualifierseqContext.class,0);
		}
		public PointerOperatorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_pointerOperator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterPointerOperator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitPointerOperator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitPointerOperator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final PointerOperatorContext pointerOperator() throws RecognitionException {
		PointerOperatorContext _localctx = new PointerOperatorContext(_ctx, getState());
		enterRule(_localctx, 236, RULE_pointerOperator);
		int _la;
		try {
			setState(1453);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case And:
			case AndAnd:
				enterOuterAlt(_localctx, 1);
				{
				setState(1439);
				_la = _input.LA(1);
				if ( !(_la==And || _la==AndAnd) ) {
				_errHandler.recoverInline(this);
				}
				else {
					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
					_errHandler.reportMatch(this);
					consume();
				}
				setState(1441);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,174,_ctx) ) {
				case 1:
					{
					setState(1440);
					attributeSpecifierSeq();
					}
					break;
				}
				}
				break;
			case Decltype:
			case Star:
			case Doublecolon:
			case Identifier:
				enterOuterAlt(_localctx, 2);
				{
				setState(1444);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Decltype || _la==Doublecolon || _la==Identifier) {
					{
					setState(1443);
					nestedNameSpecifier(0);
					}
				}

				setState(1446);
				match(Star);
				setState(1448);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,176,_ctx) ) {
				case 1:
					{
					setState(1447);
					attributeSpecifierSeq();
					}
					break;
				}
				setState(1451);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,177,_ctx) ) {
				case 1:
					{
					setState(1450);
					cvqualifierseq();
					}
					break;
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class CvqualifierseqContext extends ParserRuleContext {
		public List<CvQualifierContext> cvQualifier() {
			return getRuleContexts(CvQualifierContext.class);
		}
		public CvQualifierContext cvQualifier(int i) {
			return getRuleContext(CvQualifierContext.class,i);
		}
		public CvqualifierseqContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_cvqualifierseq; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterCvqualifierseq(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitCvqualifierseq(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitCvqualifierseq(this);
			else return visitor.visitChildren(this);
		}
	}

	public final CvqualifierseqContext cvqualifierseq() throws RecognitionException {
		CvqualifierseqContext _localctx = new CvqualifierseqContext(_ctx, getState());
		enterRule(_localctx, 238, RULE_cvqualifierseq);
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			setState(1456); 
			_errHandler.sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					setState(1455);
					cvQualifier();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				setState(1458); 
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,179,_ctx);
			} while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class CvQualifierContext extends ParserRuleContext {
		public TerminalNode Const() { return getToken(CPP14Parser.Const, 0); }
		public TerminalNode Volatile() { return getToken(CPP14Parser.Volatile, 0); }
		public CvQualifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_cvQualifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterCvQualifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitCvQualifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitCvQualifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final CvQualifierContext cvQualifier() throws RecognitionException {
		CvQualifierContext _localctx = new CvQualifierContext(_ctx, getState());
		enterRule(_localctx, 240, RULE_cvQualifier);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1460);
			_la = _input.LA(1);
			if ( !(_la==Const || _la==Volatile) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class RefqualifierContext extends ParserRuleContext {
		public TerminalNode And() { return getToken(CPP14Parser.And, 0); }
		public TerminalNode AndAnd() { return getToken(CPP14Parser.AndAnd, 0); }
		public RefqualifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_refqualifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterRefqualifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitRefqualifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitRefqualifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final RefqualifierContext refqualifier() throws RecognitionException {
		RefqualifierContext _localctx = new RefqualifierContext(_ctx, getState());
		enterRule(_localctx, 242, RULE_refqualifier);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1462);
			_la = _input.LA(1);
			if ( !(_la==And || _la==AndAnd) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class DeclaratoridContext extends ParserRuleContext {
		public IdExpressionContext idExpression() {
			return getRuleContext(IdExpressionContext.class,0);
		}
		public TerminalNode Ellipsis() { return getToken(CPP14Parser.Ellipsis, 0); }
		public DeclaratoridContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_declaratorid; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterDeclaratorid(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitDeclaratorid(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitDeclaratorid(this);
			else return visitor.visitChildren(this);
		}
	}

	public final DeclaratoridContext declaratorid() throws RecognitionException {
		DeclaratoridContext _localctx = new DeclaratoridContext(_ctx, getState());
		enterRule(_localctx, 244, RULE_declaratorid);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1465);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Ellipsis) {
				{
				setState(1464);
				match(Ellipsis);
				}
			}

			setState(1467);
			idExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TheTypeIdContext extends ParserRuleContext {
		public TypeSpecifierSeqContext typeSpecifierSeq() {
			return getRuleContext(TypeSpecifierSeqContext.class,0);
		}
		public AbstractDeclaratorContext abstractDeclarator() {
			return getRuleContext(AbstractDeclaratorContext.class,0);
		}
		public TheTypeIdContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_theTypeId; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTheTypeId(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTheTypeId(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTheTypeId(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TheTypeIdContext theTypeId() throws RecognitionException {
		TheTypeIdContext _localctx = new TheTypeIdContext(_ctx, getState());
		enterRule(_localctx, 246, RULE_theTypeId);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1469);
			typeSpecifierSeq();
			setState(1471);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,181,_ctx) ) {
			case 1:
				{
				setState(1470);
				abstractDeclarator();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class AbstractDeclaratorContext extends ParserRuleContext {
		public PointerAbstractDeclaratorContext pointerAbstractDeclarator() {
			return getRuleContext(PointerAbstractDeclaratorContext.class,0);
		}
		public ParametersAndQualifiersContext parametersAndQualifiers() {
			return getRuleContext(ParametersAndQualifiersContext.class,0);
		}
		public TrailingReturnTypeContext trailingReturnType() {
			return getRuleContext(TrailingReturnTypeContext.class,0);
		}
		public NoPointerAbstractDeclaratorContext noPointerAbstractDeclarator() {
			return getRuleContext(NoPointerAbstractDeclaratorContext.class,0);
		}
		public AbstractPackDeclaratorContext abstractPackDeclarator() {
			return getRuleContext(AbstractPackDeclaratorContext.class,0);
		}
		public AbstractDeclaratorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_abstractDeclarator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterAbstractDeclarator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitAbstractDeclarator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitAbstractDeclarator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final AbstractDeclaratorContext abstractDeclarator() throws RecognitionException {
		AbstractDeclaratorContext _localctx = new AbstractDeclaratorContext(_ctx, getState());
		enterRule(_localctx, 248, RULE_abstractDeclarator);
		try {
			setState(1481);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,183,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(1473);
				pointerAbstractDeclarator();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(1475);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,182,_ctx) ) {
				case 1:
					{
					setState(1474);
					noPointerAbstractDeclarator();
					}
					break;
				}
				setState(1477);
				parametersAndQualifiers();
				setState(1478);
				trailingReturnType();
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(1480);
				abstractPackDeclarator();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class PointerAbstractDeclaratorContext extends ParserRuleContext {
		public NoPointerAbstractDeclaratorContext noPointerAbstractDeclarator() {
			return getRuleContext(NoPointerAbstractDeclaratorContext.class,0);
		}
		public List<PointerOperatorContext> pointerOperator() {
			return getRuleContexts(PointerOperatorContext.class);
		}
		public PointerOperatorContext pointerOperator(int i) {
			return getRuleContext(PointerOperatorContext.class,i);
		}
		public PointerAbstractDeclaratorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_pointerAbstractDeclarator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterPointerAbstractDeclarator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitPointerAbstractDeclarator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitPointerAbstractDeclarator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final PointerAbstractDeclaratorContext pointerAbstractDeclarator() throws RecognitionException {
		PointerAbstractDeclaratorContext _localctx = new PointerAbstractDeclaratorContext(_ctx, getState());
		enterRule(_localctx, 250, RULE_pointerAbstractDeclarator);
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			setState(1486);
			_errHandler.sync(this);
			_alt = getInterpreter().adaptivePredict(_input,184,_ctx);
			while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					setState(1483);
					pointerOperator();
					}
					} 
				}
				setState(1488);
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,184,_ctx);
			}
			setState(1491);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case LeftParen:
				{
				setState(1489);
				noPointerAbstractDeclarator();
				}
				break;
			case Decltype:
			case Star:
			case And:
			case AndAnd:
			case Doublecolon:
			case Identifier:
				{
				setState(1490);
				pointerOperator();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class NoPointerAbstractDeclaratorContext extends ParserRuleContext {
		public List<ParametersAndQualifiersContext> parametersAndQualifiers() {
			return getRuleContexts(ParametersAndQualifiersContext.class);
		}
		public ParametersAndQualifiersContext parametersAndQualifiers(int i) {
			return getRuleContext(ParametersAndQualifiersContext.class,i);
		}
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public PointerAbstractDeclaratorContext pointerAbstractDeclarator() {
			return getRuleContext(PointerAbstractDeclaratorContext.class,0);
		}
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public List<TerminalNode> LeftBracket() { return getTokens(CPP14Parser.LeftBracket); }
		public TerminalNode LeftBracket(int i) {
			return getToken(CPP14Parser.LeftBracket, i);
		}
		public List<TerminalNode> RightBracket() { return getTokens(CPP14Parser.RightBracket); }
		public TerminalNode RightBracket(int i) {
			return getToken(CPP14Parser.RightBracket, i);
		}
		public List<ConstantExpressionContext> constantExpression() {
			return getRuleContexts(ConstantExpressionContext.class);
		}
		public ConstantExpressionContext constantExpression(int i) {
			return getRuleContext(ConstantExpressionContext.class,i);
		}
		public List<AttributeSpecifierSeqContext> attributeSpecifierSeq() {
			return getRuleContexts(AttributeSpecifierSeqContext.class);
		}
		public AttributeSpecifierSeqContext attributeSpecifierSeq(int i) {
			return getRuleContext(AttributeSpecifierSeqContext.class,i);
		}
		public NoPointerAbstractDeclaratorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_noPointerAbstractDeclarator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterNoPointerAbstractDeclarator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitNoPointerAbstractDeclarator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitNoPointerAbstractDeclarator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final NoPointerAbstractDeclaratorContext noPointerAbstractDeclarator() throws RecognitionException {
		NoPointerAbstractDeclaratorContext _localctx = new NoPointerAbstractDeclaratorContext(_ctx, getState());
		enterRule(_localctx, 252, RULE_noPointerAbstractDeclarator);
		int _la;
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			setState(1498);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,186,_ctx) ) {
			case 1:
				{
				setState(1493);
				parametersAndQualifiers();
				}
				break;
			case 2:
				{
				setState(1494);
				match(LeftParen);
				setState(1495);
				pointerAbstractDeclarator();
				setState(1496);
				match(RightParen);
				}
				break;
			}
			setState(1511);
			_errHandler.sync(this);
			_alt = getInterpreter().adaptivePredict(_input,190,_ctx);
			while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					setState(1509);
					_errHandler.sync(this);
					switch (_input.LA(1)) {
					case LeftParen:
						{
						setState(1500);
						parametersAndQualifiers();
						}
						break;
					case LeftBracket:
						{
						setState(1501);
						match(LeftBracket);
						setState(1503);
						_errHandler.sync(this);
						_la = _input.LA(1);
						if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 8364979464334764286L) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & 4719772474384133137L) != 0) || _la==Identifier) {
							{
							setState(1502);
							constantExpression();
							}
						}

						setState(1505);
						match(RightBracket);
						setState(1507);
						_errHandler.sync(this);
						switch ( getInterpreter().adaptivePredict(_input,188,_ctx) ) {
						case 1:
							{
							setState(1506);
							attributeSpecifierSeq();
							}
							break;
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				setState(1513);
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,190,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class AbstractPackDeclaratorContext extends ParserRuleContext {
		public NoPointerAbstractPackDeclaratorContext noPointerAbstractPackDeclarator() {
			return getRuleContext(NoPointerAbstractPackDeclaratorContext.class,0);
		}
		public List<PointerOperatorContext> pointerOperator() {
			return getRuleContexts(PointerOperatorContext.class);
		}
		public PointerOperatorContext pointerOperator(int i) {
			return getRuleContext(PointerOperatorContext.class,i);
		}
		public AbstractPackDeclaratorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_abstractPackDeclarator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterAbstractPackDeclarator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitAbstractPackDeclarator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitAbstractPackDeclarator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final AbstractPackDeclaratorContext abstractPackDeclarator() throws RecognitionException {
		AbstractPackDeclaratorContext _localctx = new AbstractPackDeclaratorContext(_ctx, getState());
		enterRule(_localctx, 254, RULE_abstractPackDeclarator);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1517);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==Decltype || ((((_la - 93)) & ~0x3f) == 0 && ((1L << (_la - 93)) & 566969237521L) != 0)) {
				{
				{
				setState(1514);
				pointerOperator();
				}
				}
				setState(1519);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			setState(1520);
			noPointerAbstractPackDeclarator();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class NoPointerAbstractPackDeclaratorContext extends ParserRuleContext {
		public TerminalNode Ellipsis() { return getToken(CPP14Parser.Ellipsis, 0); }
		public List<ParametersAndQualifiersContext> parametersAndQualifiers() {
			return getRuleContexts(ParametersAndQualifiersContext.class);
		}
		public ParametersAndQualifiersContext parametersAndQualifiers(int i) {
			return getRuleContext(ParametersAndQualifiersContext.class,i);
		}
		public List<TerminalNode> LeftBracket() { return getTokens(CPP14Parser.LeftBracket); }
		public TerminalNode LeftBracket(int i) {
			return getToken(CPP14Parser.LeftBracket, i);
		}
		public List<TerminalNode> RightBracket() { return getTokens(CPP14Parser.RightBracket); }
		public TerminalNode RightBracket(int i) {
			return getToken(CPP14Parser.RightBracket, i);
		}
		public List<ConstantExpressionContext> constantExpression() {
			return getRuleContexts(ConstantExpressionContext.class);
		}
		public ConstantExpressionContext constantExpression(int i) {
			return getRuleContext(ConstantExpressionContext.class,i);
		}
		public List<AttributeSpecifierSeqContext> attributeSpecifierSeq() {
			return getRuleContexts(AttributeSpecifierSeqContext.class);
		}
		public AttributeSpecifierSeqContext attributeSpecifierSeq(int i) {
			return getRuleContext(AttributeSpecifierSeqContext.class,i);
		}
		public NoPointerAbstractPackDeclaratorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_noPointerAbstractPackDeclarator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterNoPointerAbstractPackDeclarator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitNoPointerAbstractPackDeclarator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitNoPointerAbstractPackDeclarator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final NoPointerAbstractPackDeclaratorContext noPointerAbstractPackDeclarator() throws RecognitionException {
		NoPointerAbstractPackDeclaratorContext _localctx = new NoPointerAbstractPackDeclaratorContext(_ctx, getState());
		enterRule(_localctx, 256, RULE_noPointerAbstractPackDeclarator);
		int _la;
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			setState(1522);
			match(Ellipsis);
			setState(1534);
			_errHandler.sync(this);
			_alt = getInterpreter().adaptivePredict(_input,195,_ctx);
			while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					setState(1532);
					_errHandler.sync(this);
					switch (_input.LA(1)) {
					case LeftParen:
						{
						setState(1523);
						parametersAndQualifiers();
						}
						break;
					case LeftBracket:
						{
						setState(1524);
						match(LeftBracket);
						setState(1526);
						_errHandler.sync(this);
						_la = _input.LA(1);
						if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 8364979464334764286L) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & 4719772474384133137L) != 0) || _la==Identifier) {
							{
							setState(1525);
							constantExpression();
							}
						}

						setState(1528);
						match(RightBracket);
						setState(1530);
						_errHandler.sync(this);
						switch ( getInterpreter().adaptivePredict(_input,193,_ctx) ) {
						case 1:
							{
							setState(1529);
							attributeSpecifierSeq();
							}
							break;
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				setState(1536);
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,195,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ParameterDeclarationClauseContext extends ParserRuleContext {
		public ParameterDeclarationListContext parameterDeclarationList() {
			return getRuleContext(ParameterDeclarationListContext.class,0);
		}
		public TerminalNode Ellipsis() { return getToken(CPP14Parser.Ellipsis, 0); }
		public TerminalNode Comma() { return getToken(CPP14Parser.Comma, 0); }
		public ParameterDeclarationClauseContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_parameterDeclarationClause; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterParameterDeclarationClause(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitParameterDeclarationClause(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitParameterDeclarationClause(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ParameterDeclarationClauseContext parameterDeclarationClause() throws RecognitionException {
		ParameterDeclarationClauseContext _localctx = new ParameterDeclarationClauseContext(_ctx, getState());
		enterRule(_localctx, 258, RULE_parameterDeclarationClause);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1537);
			parameterDeclarationList();
			setState(1542);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Comma || _la==Ellipsis) {
				{
				setState(1539);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Comma) {
					{
					setState(1538);
					match(Comma);
					}
				}

				setState(1541);
				match(Ellipsis);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ParameterDeclarationListContext extends ParserRuleContext {
		public List<ParameterDeclarationContext> parameterDeclaration() {
			return getRuleContexts(ParameterDeclarationContext.class);
		}
		public ParameterDeclarationContext parameterDeclaration(int i) {
			return getRuleContext(ParameterDeclarationContext.class,i);
		}
		public List<TerminalNode> Comma() { return getTokens(CPP14Parser.Comma); }
		public TerminalNode Comma(int i) {
			return getToken(CPP14Parser.Comma, i);
		}
		public ParameterDeclarationListContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_parameterDeclarationList; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterParameterDeclarationList(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitParameterDeclarationList(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitParameterDeclarationList(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ParameterDeclarationListContext parameterDeclarationList() throws RecognitionException {
		ParameterDeclarationListContext _localctx = new ParameterDeclarationListContext(_ctx, getState());
		enterRule(_localctx, 260, RULE_parameterDeclarationList);
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			setState(1544);
			parameterDeclaration();
			setState(1549);
			_errHandler.sync(this);
			_alt = getInterpreter().adaptivePredict(_input,198,_ctx);
			while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					setState(1545);
					match(Comma);
					setState(1546);
					parameterDeclaration();
					}
					} 
				}
				setState(1551);
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,198,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ParameterDeclarationContext extends ParserRuleContext {
		public DeclSpecifierSeqContext declSpecifierSeq() {
			return getRuleContext(DeclSpecifierSeqContext.class,0);
		}
		public DeclaratorContext declarator() {
			return getRuleContext(DeclaratorContext.class,0);
		}
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public TerminalNode Assign() { return getToken(CPP14Parser.Assign, 0); }
		public InitializerClauseContext initializerClause() {
			return getRuleContext(InitializerClauseContext.class,0);
		}
		public AbstractDeclaratorContext abstractDeclarator() {
			return getRuleContext(AbstractDeclaratorContext.class,0);
		}
		public ParameterDeclarationContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_parameterDeclaration; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterParameterDeclaration(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitParameterDeclaration(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitParameterDeclaration(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ParameterDeclarationContext parameterDeclaration() throws RecognitionException {
		ParameterDeclarationContext _localctx = new ParameterDeclarationContext(_ctx, getState());
		enterRule(_localctx, 262, RULE_parameterDeclaration);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1553);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Alignas || _la==LeftBracket) {
				{
				setState(1552);
				attributeSpecifierSeq();
				}
			}

			setState(1555);
			declSpecifierSeq();
			setState(1560);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,201,_ctx) ) {
			case 1:
				{
				setState(1556);
				declarator();
				}
				break;
			case 2:
				{
				setState(1558);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,200,_ctx) ) {
				case 1:
					{
					setState(1557);
					abstractDeclarator();
					}
					break;
				}
				}
				break;
			}
			setState(1564);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Assign) {
				{
				setState(1562);
				match(Assign);
				setState(1563);
				initializerClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class FunctionDefinitionContext extends ParserRuleContext {
		public DeclaratorContext declarator() {
			return getRuleContext(DeclaratorContext.class,0);
		}
		public FunctionBodyContext functionBody() {
			return getRuleContext(FunctionBodyContext.class,0);
		}
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public DeclSpecifierSeqContext declSpecifierSeq() {
			return getRuleContext(DeclSpecifierSeqContext.class,0);
		}
		public VirtualSpecifierSeqContext virtualSpecifierSeq() {
			return getRuleContext(VirtualSpecifierSeqContext.class,0);
		}
		public FunctionDefinitionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_functionDefinition; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterFunctionDefinition(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitFunctionDefinition(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitFunctionDefinition(this);
			else return visitor.visitChildren(this);
		}
	}

	public final FunctionDefinitionContext functionDefinition() throws RecognitionException {
		FunctionDefinitionContext _localctx = new FunctionDefinitionContext(_ctx, getState());
		enterRule(_localctx, 264, RULE_functionDefinition);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1567);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Alignas || _la==LeftBracket) {
				{
				setState(1566);
				attributeSpecifierSeq();
				}
			}

			setState(1570);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,204,_ctx) ) {
			case 1:
				{
				setState(1569);
				declSpecifierSeq();
				}
				break;
			}
			setState(1572);
			declarator();
			setState(1574);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Final || _la==Override) {
				{
				setState(1573);
				virtualSpecifierSeq();
				}
			}

			setState(1576);
			functionBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class FunctionBodyContext extends ParserRuleContext {
		public CompoundStatementContext compoundStatement() {
			return getRuleContext(CompoundStatementContext.class,0);
		}
		public ConstructorInitializerContext constructorInitializer() {
			return getRuleContext(ConstructorInitializerContext.class,0);
		}
		public FunctionTryBlockContext functionTryBlock() {
			return getRuleContext(FunctionTryBlockContext.class,0);
		}
		public TerminalNode Assign() { return getToken(CPP14Parser.Assign, 0); }
		public TerminalNode Semi() { return getToken(CPP14Parser.Semi, 0); }
		public TerminalNode Default() { return getToken(CPP14Parser.Default, 0); }
		public TerminalNode Delete() { return getToken(CPP14Parser.Delete, 0); }
		public FunctionBodyContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_functionBody; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterFunctionBody(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitFunctionBody(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitFunctionBody(this);
			else return visitor.visitChildren(this);
		}
	}

	public final FunctionBodyContext functionBody() throws RecognitionException {
		FunctionBodyContext _localctx = new FunctionBodyContext(_ctx, getState());
		enterRule(_localctx, 266, RULE_functionBody);
		int _la;
		try {
			setState(1586);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case LeftBrace:
			case Colon:
				enterOuterAlt(_localctx, 1);
				{
				setState(1579);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Colon) {
					{
					setState(1578);
					constructorInitializer();
					}
				}

				setState(1581);
				compoundStatement();
				}
				break;
			case Try:
				enterOuterAlt(_localctx, 2);
				{
				setState(1582);
				functionTryBlock();
				}
				break;
			case Assign:
				enterOuterAlt(_localctx, 3);
				{
				setState(1583);
				match(Assign);
				setState(1584);
				_la = _input.LA(1);
				if ( !(_la==Default || _la==Delete) ) {
				_errHandler.recoverInline(this);
				}
				else {
					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
					_errHandler.reportMatch(this);
					consume();
				}
				setState(1585);
				match(Semi);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class InitializerContext extends ParserRuleContext {
		public BraceOrEqualInitializerContext braceOrEqualInitializer() {
			return getRuleContext(BraceOrEqualInitializerContext.class,0);
		}
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public ExpressionListContext expressionList() {
			return getRuleContext(ExpressionListContext.class,0);
		}
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public InitializerContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_initializer; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterInitializer(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitInitializer(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitInitializer(this);
			else return visitor.visitChildren(this);
		}
	}

	public final InitializerContext initializer() throws RecognitionException {
		InitializerContext _localctx = new InitializerContext(_ctx, getState());
		enterRule(_localctx, 268, RULE_initializer);
		try {
			setState(1593);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case LeftBrace:
			case Assign:
				enterOuterAlt(_localctx, 1);
				{
				setState(1588);
				braceOrEqualInitializer();
				}
				break;
			case LeftParen:
				enterOuterAlt(_localctx, 2);
				{
				setState(1589);
				match(LeftParen);
				setState(1590);
				expressionList();
				setState(1591);
				match(RightParen);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class BraceOrEqualInitializerContext extends ParserRuleContext {
		public TerminalNode Assign() { return getToken(CPP14Parser.Assign, 0); }
		public InitializerClauseContext initializerClause() {
			return getRuleContext(InitializerClauseContext.class,0);
		}
		public BracedInitListContext bracedInitList() {
			return getRuleContext(BracedInitListContext.class,0);
		}
		public BraceOrEqualInitializerContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_braceOrEqualInitializer; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterBraceOrEqualInitializer(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitBraceOrEqualInitializer(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitBraceOrEqualInitializer(this);
			else return visitor.visitChildren(this);
		}
	}

	public final BraceOrEqualInitializerContext braceOrEqualInitializer() throws RecognitionException {
		BraceOrEqualInitializerContext _localctx = new BraceOrEqualInitializerContext(_ctx, getState());
		enterRule(_localctx, 270, RULE_braceOrEqualInitializer);
		try {
			setState(1598);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case Assign:
				enterOuterAlt(_localctx, 1);
				{
				setState(1595);
				match(Assign);
				setState(1596);
				initializerClause();
				}
				break;
			case LeftBrace:
				enterOuterAlt(_localctx, 2);
				{
				setState(1597);
				bracedInitList();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class InitializerClauseContext extends ParserRuleContext {
		public AssignmentExpressionContext assignmentExpression() {
			return getRuleContext(AssignmentExpressionContext.class,0);
		}
		public BracedInitListContext bracedInitList() {
			return getRuleContext(BracedInitListContext.class,0);
		}
		public InitializerClauseContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_initializerClause; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterInitializerClause(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitInitializerClause(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitInitializerClause(this);
			else return visitor.visitChildren(this);
		}
	}

	public final InitializerClauseContext initializerClause() throws RecognitionException {
		InitializerClauseContext _localctx = new InitializerClauseContext(_ctx, getState());
		enterRule(_localctx, 272, RULE_initializerClause);
		try {
			setState(1602);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case IntegerLiteral:
			case CharacterLiteral:
			case FloatingLiteral:
			case StringLiteral:
			case BooleanLiteral:
			case PointerLiteral:
			case UserDefinedLiteral:
			case Alignof:
			case Auto:
			case Bool:
			case Char:
			case Char16:
			case Char32:
			case Const_cast:
			case Decltype:
			case Delete:
			case Double:
			case Dynamic_cast:
			case Float:
			case Int:
			case Long:
			case New:
			case Noexcept:
			case Operator:
			case Reinterpret_cast:
			case Short:
			case Signed:
			case Sizeof:
			case Static_cast:
			case This:
			case Throw:
			case Typeid_:
			case Typename_:
			case Unsigned:
			case Void:
			case Wchar:
			case LeftParen:
			case LeftBracket:
			case Plus:
			case Minus:
			case Star:
			case And:
			case Or:
			case Tilde:
			case Not:
			case PlusPlus:
			case MinusMinus:
			case Doublecolon:
			case Identifier:
				enterOuterAlt(_localctx, 1);
				{
				setState(1600);
				assignmentExpression();
				}
				break;
			case LeftBrace:
				enterOuterAlt(_localctx, 2);
				{
				setState(1601);
				bracedInitList();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class InitializerListContext extends ParserRuleContext {
		public List<InitializerClauseContext> initializerClause() {
			return getRuleContexts(InitializerClauseContext.class);
		}
		public InitializerClauseContext initializerClause(int i) {
			return getRuleContext(InitializerClauseContext.class,i);
		}
		public List<TerminalNode> Ellipsis() { return getTokens(CPP14Parser.Ellipsis); }
		public TerminalNode Ellipsis(int i) {
			return getToken(CPP14Parser.Ellipsis, i);
		}
		public List<TerminalNode> Comma() { return getTokens(CPP14Parser.Comma); }
		public TerminalNode Comma(int i) {
			return getToken(CPP14Parser.Comma, i);
		}
		public InitializerListContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_initializerList; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterInitializerList(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitInitializerList(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitInitializerList(this);
			else return visitor.visitChildren(this);
		}
	}

	public final InitializerListContext initializerList() throws RecognitionException {
		InitializerListContext _localctx = new InitializerListContext(_ctx, getState());
		enterRule(_localctx, 274, RULE_initializerList);
		int _la;
		try {
			int _alt;
			enterOuterAlt(_localctx, 1);
			{
			setState(1604);
			initializerClause();
			setState(1606);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Ellipsis) {
				{
				setState(1605);
				match(Ellipsis);
				}
			}

			setState(1615);
			_errHandler.sync(this);
			_alt = getInterpreter().adaptivePredict(_input,213,_ctx);
			while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					setState(1608);
					match(Comma);
					setState(1609);
					initializerClause();
					setState(1611);
					_errHandler.sync(this);
					_la = _input.LA(1);
					if (_la==Ellipsis) {
						{
						setState(1610);
						match(Ellipsis);
						}
					}

					}
					} 
				}
				setState(1617);
				_errHandler.sync(this);
				_alt = getInterpreter().adaptivePredict(_input,213,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class BracedInitListContext extends ParserRuleContext {
		public TerminalNode LeftBrace() { return getToken(CPP14Parser.LeftBrace, 0); }
		public TerminalNode RightBrace() { return getToken(CPP14Parser.RightBrace, 0); }
		public InitializerListContext initializerList() {
			return getRuleContext(InitializerListContext.class,0);
		}
		public TerminalNode Comma() { return getToken(CPP14Parser.Comma, 0); }
		public BracedInitListContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_bracedInitList; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterBracedInitList(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitBracedInitList(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitBracedInitList(this);
			else return visitor.visitChildren(this);
		}
	}

	public final BracedInitListContext bracedInitList() throws RecognitionException {
		BracedInitListContext _localctx = new BracedInitListContext(_ctx, getState());
		enterRule(_localctx, 276, RULE_bracedInitList);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1618);
			match(LeftBrace);
			setState(1623);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 8364979464334764286L) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & 4719772474400910417L) != 0) || _la==Identifier) {
				{
				setState(1619);
				initializerList();
				setState(1621);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Comma) {
					{
					setState(1620);
					match(Comma);
					}
				}

				}
			}

			setState(1625);
			match(RightBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ClassNameContext extends ParserRuleContext {
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public SimpleTemplateIdContext simpleTemplateId() {
			return getRuleContext(SimpleTemplateIdContext.class,0);
		}
		public ClassNameContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_className; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterClassName(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitClassName(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitClassName(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ClassNameContext className() throws RecognitionException {
		ClassNameContext _localctx = new ClassNameContext(_ctx, getState());
		enterRule(_localctx, 278, RULE_className);
		try {
			setState(1629);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,216,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(1627);
				match(Identifier);
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(1628);
				simpleTemplateId();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ClassSpecifierContext extends ParserRuleContext {
		public ClassHeadContext classHead() {
			return getRuleContext(ClassHeadContext.class,0);
		}
		public TerminalNode LeftBrace() { return getToken(CPP14Parser.LeftBrace, 0); }
		public TerminalNode RightBrace() { return getToken(CPP14Parser.RightBrace, 0); }
		public MemberSpecificationContext memberSpecification() {
			return getRuleContext(MemberSpecificationContext.class,0);
		}
		public ClassSpecifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_classSpecifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterClassSpecifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitClassSpecifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitClassSpecifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ClassSpecifierContext classSpecifier() throws RecognitionException {
		ClassSpecifierContext _localctx = new ClassSpecifierContext(_ctx, getState());
		enterRule(_localctx, 280, RULE_classSpecifier);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1631);
			classHead();
			setState(1632);
			match(LeftBrace);
			setState(1634);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (((((_la - 10)) & ~0x3f) == 0 && ((1L << (_la - 10)) & 1543877313594212121L) != 0) || ((((_la - 74)) & ~0x3f) == 0 && ((1L << (_la - 74)) & 463888353847684093L) != 0)) {
				{
				setState(1633);
				memberSpecification();
				}
			}

			setState(1636);
			match(RightBrace);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ClassHeadContext extends ParserRuleContext {
		public ClassKeyContext classKey() {
			return getRuleContext(ClassKeyContext.class,0);
		}
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public ClassHeadNameContext classHeadName() {
			return getRuleContext(ClassHeadNameContext.class,0);
		}
		public BaseClauseContext baseClause() {
			return getRuleContext(BaseClauseContext.class,0);
		}
		public ClassVirtSpecifierContext classVirtSpecifier() {
			return getRuleContext(ClassVirtSpecifierContext.class,0);
		}
		public TerminalNode Union() { return getToken(CPP14Parser.Union, 0); }
		public ClassHeadContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_classHead; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterClassHead(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitClassHead(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitClassHead(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ClassHeadContext classHead() throws RecognitionException {
		ClassHeadContext _localctx = new ClassHeadContext(_ctx, getState());
		enterRule(_localctx, 282, RULE_classHead);
		int _la;
		try {
			setState(1661);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case Class:
			case Struct:
				enterOuterAlt(_localctx, 1);
				{
				setState(1638);
				classKey();
				setState(1640);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Alignas || _la==LeftBracket) {
					{
					setState(1639);
					attributeSpecifierSeq();
					}
				}

				setState(1646);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Decltype || _la==Doublecolon || _la==Identifier) {
					{
					setState(1642);
					classHeadName();
					setState(1644);
					_errHandler.sync(this);
					_la = _input.LA(1);
					if (_la==Final) {
						{
						setState(1643);
						classVirtSpecifier();
						}
					}

					}
				}

				setState(1649);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Colon) {
					{
					setState(1648);
					baseClause();
					}
				}

				}
				break;
			case Union:
				enterOuterAlt(_localctx, 2);
				{
				setState(1651);
				match(Union);
				setState(1653);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Alignas || _la==LeftBracket) {
					{
					setState(1652);
					attributeSpecifierSeq();
					}
				}

				setState(1659);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Decltype || _la==Doublecolon || _la==Identifier) {
					{
					setState(1655);
					classHeadName();
					setState(1657);
					_errHandler.sync(this);
					_la = _input.LA(1);
					if (_la==Final) {
						{
						setState(1656);
						classVirtSpecifier();
						}
					}

					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ClassHeadNameContext extends ParserRuleContext {
		public ClassNameContext className() {
			return getRuleContext(ClassNameContext.class,0);
		}
		public NestedNameSpecifierContext nestedNameSpecifier() {
			return getRuleContext(NestedNameSpecifierContext.class,0);
		}
		public ClassHeadNameContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_classHeadName; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterClassHeadName(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitClassHeadName(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitClassHeadName(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ClassHeadNameContext classHeadName() throws RecognitionException {
		ClassHeadNameContext _localctx = new ClassHeadNameContext(_ctx, getState());
		enterRule(_localctx, 284, RULE_classHeadName);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1664);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,226,_ctx) ) {
			case 1:
				{
				setState(1663);
				nestedNameSpecifier(0);
				}
				break;
			}
			setState(1666);
			className();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ClassVirtSpecifierContext extends ParserRuleContext {
		public TerminalNode Final() { return getToken(CPP14Parser.Final, 0); }
		public ClassVirtSpecifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_classVirtSpecifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterClassVirtSpecifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitClassVirtSpecifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitClassVirtSpecifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ClassVirtSpecifierContext classVirtSpecifier() throws RecognitionException {
		ClassVirtSpecifierContext _localctx = new ClassVirtSpecifierContext(_ctx, getState());
		enterRule(_localctx, 286, RULE_classVirtSpecifier);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1668);
			match(Final);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ClassKeyContext extends ParserRuleContext {
		public TerminalNode Class() { return getToken(CPP14Parser.Class, 0); }
		public TerminalNode Struct() { return getToken(CPP14Parser.Struct, 0); }
		public ClassKeyContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_classKey; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterClassKey(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitClassKey(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitClassKey(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ClassKeyContext classKey() throws RecognitionException {
		ClassKeyContext _localctx = new ClassKeyContext(_ctx, getState());
		enterRule(_localctx, 288, RULE_classKey);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1670);
			_la = _input.LA(1);
			if ( !(_la==Class || _la==Struct) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class MemberSpecificationContext extends ParserRuleContext {
		public List<MemberdeclarationContext> memberdeclaration() {
			return getRuleContexts(MemberdeclarationContext.class);
		}
		public MemberdeclarationContext memberdeclaration(int i) {
			return getRuleContext(MemberdeclarationContext.class,i);
		}
		public List<AccessSpecifierContext> accessSpecifier() {
			return getRuleContexts(AccessSpecifierContext.class);
		}
		public AccessSpecifierContext accessSpecifier(int i) {
			return getRuleContext(AccessSpecifierContext.class,i);
		}
		public List<TerminalNode> Colon() { return getTokens(CPP14Parser.Colon); }
		public TerminalNode Colon(int i) {
			return getToken(CPP14Parser.Colon, i);
		}
		public MemberSpecificationContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_memberSpecification; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterMemberSpecification(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitMemberSpecification(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitMemberSpecification(this);
			else return visitor.visitChildren(this);
		}
	}

	public final MemberSpecificationContext memberSpecification() throws RecognitionException {
		MemberSpecificationContext _localctx = new MemberSpecificationContext(_ctx, getState());
		enterRule(_localctx, 290, RULE_memberSpecification);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1676); 
			_errHandler.sync(this);
			_la = _input.LA(1);
			do {
				{
				setState(1676);
				_errHandler.sync(this);
				switch (_input.LA(1)) {
				case Alignas:
				case Auto:
				case Bool:
				case Char:
				case Char16:
				case Char32:
				case Class:
				case Const:
				case Constexpr:
				case Decltype:
				case Double:
				case Enum:
				case Explicit:
				case Extern:
				case Float:
				case Friend:
				case Inline:
				case Int:
				case Long:
				case Mutable:
				case Operator:
				case Register:
				case Short:
				case Signed:
				case Static:
				case Static_assert:
				case Struct:
				case Template:
				case Thread_local:
				case Typedef:
				case Typename_:
				case Union:
				case Unsigned:
				case Using:
				case Virtual:
				case Void:
				case Volatile:
				case Wchar:
				case LeftParen:
				case LeftBracket:
				case Star:
				case And:
				case Tilde:
				case AndAnd:
				case Colon:
				case Doublecolon:
				case Semi:
				case Ellipsis:
				case Identifier:
					{
					setState(1672);
					memberdeclaration();
					}
					break;
				case Private:
				case Protected:
				case Public:
					{
					setState(1673);
					accessSpecifier();
					setState(1674);
					match(Colon);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				setState(1678); 
				_errHandler.sync(this);
				_la = _input.LA(1);
			} while ( ((((_la - 10)) & ~0x3f) == 0 && ((1L << (_la - 10)) & 1543877313594212121L) != 0) || ((((_la - 74)) & ~0x3f) == 0 && ((1L << (_la - 74)) & 463888353847684093L) != 0) );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class MemberdeclarationContext extends ParserRuleContext {
		public TerminalNode Semi() { return getToken(CPP14Parser.Semi, 0); }
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public DeclSpecifierSeqContext declSpecifierSeq() {
			return getRuleContext(DeclSpecifierSeqContext.class,0);
		}
		public MemberDeclaratorListContext memberDeclaratorList() {
			return getRuleContext(MemberDeclaratorListContext.class,0);
		}
		public FunctionDefinitionContext functionDefinition() {
			return getRuleContext(FunctionDefinitionContext.class,0);
		}
		public UsingDeclarationContext usingDeclaration() {
			return getRuleContext(UsingDeclarationContext.class,0);
		}
		public StaticAssertDeclarationContext staticAssertDeclaration() {
			return getRuleContext(StaticAssertDeclarationContext.class,0);
		}
		public TemplateDeclarationContext templateDeclaration() {
			return getRuleContext(TemplateDeclarationContext.class,0);
		}
		public AliasDeclarationContext aliasDeclaration() {
			return getRuleContext(AliasDeclarationContext.class,0);
		}
		public EmptyDeclaration_Context emptyDeclaration_() {
			return getRuleContext(EmptyDeclaration_Context.class,0);
		}
		public MemberdeclarationContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_memberdeclaration; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterMemberdeclaration(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitMemberdeclaration(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitMemberdeclaration(this);
			else return visitor.visitChildren(this);
		}
	}

	public final MemberdeclarationContext memberdeclaration() throws RecognitionException {
		MemberdeclarationContext _localctx = new MemberdeclarationContext(_ctx, getState());
		enterRule(_localctx, 292, RULE_memberdeclaration);
		int _la;
		try {
			setState(1696);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,232,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(1681);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,229,_ctx) ) {
				case 1:
					{
					setState(1680);
					attributeSpecifierSeq();
					}
					break;
				}
				setState(1684);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,230,_ctx) ) {
				case 1:
					{
					setState(1683);
					declSpecifierSeq();
					}
					break;
				}
				setState(1687);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 4503599694480384L) != 0) || ((((_la - 85)) & ~0x3f) == 0 && ((1L << (_la - 85)) & 217711892254981L) != 0)) {
					{
					setState(1686);
					memberDeclaratorList();
					}
				}

				setState(1689);
				match(Semi);
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(1690);
				functionDefinition();
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(1691);
				usingDeclaration();
				}
				break;
			case 4:
				enterOuterAlt(_localctx, 4);
				{
				setState(1692);
				staticAssertDeclaration();
				}
				break;
			case 5:
				enterOuterAlt(_localctx, 5);
				{
				setState(1693);
				templateDeclaration();
				}
				break;
			case 6:
				enterOuterAlt(_localctx, 6);
				{
				setState(1694);
				aliasDeclaration();
				}
				break;
			case 7:
				enterOuterAlt(_localctx, 7);
				{
				setState(1695);
				emptyDeclaration_();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class MemberDeclaratorListContext extends ParserRuleContext {
		public List<MemberDeclaratorContext> memberDeclarator() {
			return getRuleContexts(MemberDeclaratorContext.class);
		}
		public MemberDeclaratorContext memberDeclarator(int i) {
			return getRuleContext(MemberDeclaratorContext.class,i);
		}
		public List<TerminalNode> Comma() { return getTokens(CPP14Parser.Comma); }
		public TerminalNode Comma(int i) {
			return getToken(CPP14Parser.Comma, i);
		}
		public MemberDeclaratorListContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_memberDeclaratorList; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterMemberDeclaratorList(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitMemberDeclaratorList(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitMemberDeclaratorList(this);
			else return visitor.visitChildren(this);
		}
	}

	public final MemberDeclaratorListContext memberDeclaratorList() throws RecognitionException {
		MemberDeclaratorListContext _localctx = new MemberDeclaratorListContext(_ctx, getState());
		enterRule(_localctx, 294, RULE_memberDeclaratorList);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1698);
			memberDeclarator();
			setState(1703);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==Comma) {
				{
				{
				setState(1699);
				match(Comma);
				setState(1700);
				memberDeclarator();
				}
				}
				setState(1705);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class MemberDeclaratorContext extends ParserRuleContext {
		public DeclaratorContext declarator() {
			return getRuleContext(DeclaratorContext.class,0);
		}
		public VirtualSpecifierSeqContext virtualSpecifierSeq() {
			return getRuleContext(VirtualSpecifierSeqContext.class,0);
		}
		public PureSpecifierContext pureSpecifier() {
			return getRuleContext(PureSpecifierContext.class,0);
		}
		public BraceOrEqualInitializerContext braceOrEqualInitializer() {
			return getRuleContext(BraceOrEqualInitializerContext.class,0);
		}
		public TerminalNode Colon() { return getToken(CPP14Parser.Colon, 0); }
		public ConstantExpressionContext constantExpression() {
			return getRuleContext(ConstantExpressionContext.class,0);
		}
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public MemberDeclaratorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_memberDeclarator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterMemberDeclarator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitMemberDeclarator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitMemberDeclarator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final MemberDeclaratorContext memberDeclarator() throws RecognitionException {
		MemberDeclaratorContext _localctx = new MemberDeclaratorContext(_ctx, getState());
		enterRule(_localctx, 296, RULE_memberDeclarator);
		int _la;
		try {
			setState(1726);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,237,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(1706);
				declarator();
				setState(1715);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,234,_ctx) ) {
				case 1:
					{
					setState(1707);
					virtualSpecifierSeq();
					}
					break;
				case 2:
					{
					setState(1708);
					if (!( this.IsPureSpecifierAllowed() )) throw new FailedPredicateException(this, " this.IsPureSpecifierAllowed() ");
					setState(1709);
					pureSpecifier();
					}
					break;
				case 3:
					{
					setState(1710);
					if (!( this.IsPureSpecifierAllowed() )) throw new FailedPredicateException(this, " this.IsPureSpecifierAllowed() ");
					setState(1711);
					virtualSpecifierSeq();
					setState(1712);
					pureSpecifier();
					}
					break;
				case 4:
					{
					setState(1714);
					braceOrEqualInitializer();
					}
					break;
				}
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(1717);
				declarator();
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(1719);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Identifier) {
					{
					setState(1718);
					match(Identifier);
					}
				}

				setState(1722);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Alignas || _la==LeftBracket) {
					{
					setState(1721);
					attributeSpecifierSeq();
					}
				}

				setState(1724);
				match(Colon);
				setState(1725);
				constantExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class VirtualSpecifierSeqContext extends ParserRuleContext {
		public List<VirtualSpecifierContext> virtualSpecifier() {
			return getRuleContexts(VirtualSpecifierContext.class);
		}
		public VirtualSpecifierContext virtualSpecifier(int i) {
			return getRuleContext(VirtualSpecifierContext.class,i);
		}
		public VirtualSpecifierSeqContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_virtualSpecifierSeq; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterVirtualSpecifierSeq(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitVirtualSpecifierSeq(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitVirtualSpecifierSeq(this);
			else return visitor.visitChildren(this);
		}
	}

	public final VirtualSpecifierSeqContext virtualSpecifierSeq() throws RecognitionException {
		VirtualSpecifierSeqContext _localctx = new VirtualSpecifierSeqContext(_ctx, getState());
		enterRule(_localctx, 298, RULE_virtualSpecifierSeq);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1729); 
			_errHandler.sync(this);
			_la = _input.LA(1);
			do {
				{
				{
				setState(1728);
				virtualSpecifier();
				}
				}
				setState(1731); 
				_errHandler.sync(this);
				_la = _input.LA(1);
			} while ( _la==Final || _la==Override );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class VirtualSpecifierContext extends ParserRuleContext {
		public TerminalNode Override() { return getToken(CPP14Parser.Override, 0); }
		public TerminalNode Final() { return getToken(CPP14Parser.Final, 0); }
		public VirtualSpecifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_virtualSpecifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterVirtualSpecifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitVirtualSpecifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitVirtualSpecifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final VirtualSpecifierContext virtualSpecifier() throws RecognitionException {
		VirtualSpecifierContext _localctx = new VirtualSpecifierContext(_ctx, getState());
		enterRule(_localctx, 300, RULE_virtualSpecifier);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1733);
			_la = _input.LA(1);
			if ( !(_la==Final || _la==Override) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class PureSpecifierContext extends ParserRuleContext {
		public TerminalNode Assign() { return getToken(CPP14Parser.Assign, 0); }
		public TerminalNode IntegerLiteral() { return getToken(CPP14Parser.IntegerLiteral, 0); }
		public PureSpecifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_pureSpecifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterPureSpecifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitPureSpecifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitPureSpecifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final PureSpecifierContext pureSpecifier() throws RecognitionException {
		PureSpecifierContext _localctx = new PureSpecifierContext(_ctx, getState());
		enterRule(_localctx, 302, RULE_pureSpecifier);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1735);
			match(Assign);
			setState(1736);
			match(IntegerLiteral);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class BaseClauseContext extends ParserRuleContext {
		public TerminalNode Colon() { return getToken(CPP14Parser.Colon, 0); }
		public BaseSpecifierListContext baseSpecifierList() {
			return getRuleContext(BaseSpecifierListContext.class,0);
		}
		public BaseClauseContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_baseClause; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterBaseClause(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitBaseClause(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitBaseClause(this);
			else return visitor.visitChildren(this);
		}
	}

	public final BaseClauseContext baseClause() throws RecognitionException {
		BaseClauseContext _localctx = new BaseClauseContext(_ctx, getState());
		enterRule(_localctx, 304, RULE_baseClause);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1738);
			match(Colon);
			setState(1739);
			baseSpecifierList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class BaseSpecifierListContext extends ParserRuleContext {
		public List<BaseSpecifierContext> baseSpecifier() {
			return getRuleContexts(BaseSpecifierContext.class);
		}
		public BaseSpecifierContext baseSpecifier(int i) {
			return getRuleContext(BaseSpecifierContext.class,i);
		}
		public List<TerminalNode> Ellipsis() { return getTokens(CPP14Parser.Ellipsis); }
		public TerminalNode Ellipsis(int i) {
			return getToken(CPP14Parser.Ellipsis, i);
		}
		public List<TerminalNode> Comma() { return getTokens(CPP14Parser.Comma); }
		public TerminalNode Comma(int i) {
			return getToken(CPP14Parser.Comma, i);
		}
		public BaseSpecifierListContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_baseSpecifierList; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterBaseSpecifierList(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitBaseSpecifierList(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitBaseSpecifierList(this);
			else return visitor.visitChildren(this);
		}
	}

	public final BaseSpecifierListContext baseSpecifierList() throws RecognitionException {
		BaseSpecifierListContext _localctx = new BaseSpecifierListContext(_ctx, getState());
		enterRule(_localctx, 306, RULE_baseSpecifierList);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1741);
			baseSpecifier();
			setState(1743);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Ellipsis) {
				{
				setState(1742);
				match(Ellipsis);
				}
			}

			setState(1752);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==Comma) {
				{
				{
				setState(1745);
				match(Comma);
				setState(1746);
				baseSpecifier();
				setState(1748);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Ellipsis) {
					{
					setState(1747);
					match(Ellipsis);
					}
				}

				}
				}
				setState(1754);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class BaseSpecifierContext extends ParserRuleContext {
		public BaseTypeSpecifierContext baseTypeSpecifier() {
			return getRuleContext(BaseTypeSpecifierContext.class,0);
		}
		public TerminalNode Virtual() { return getToken(CPP14Parser.Virtual, 0); }
		public AccessSpecifierContext accessSpecifier() {
			return getRuleContext(AccessSpecifierContext.class,0);
		}
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public BaseSpecifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_baseSpecifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterBaseSpecifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitBaseSpecifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitBaseSpecifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final BaseSpecifierContext baseSpecifier() throws RecognitionException {
		BaseSpecifierContext _localctx = new BaseSpecifierContext(_ctx, getState());
		enterRule(_localctx, 308, RULE_baseSpecifier);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1756);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Alignas || _la==LeftBracket) {
				{
				setState(1755);
				attributeSpecifierSeq();
				}
			}

			setState(1770);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case Decltype:
			case Doublecolon:
			case Identifier:
				{
				setState(1758);
				baseTypeSpecifier();
				}
				break;
			case Virtual:
				{
				setState(1759);
				match(Virtual);
				setState(1761);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 126100789566373888L) != 0)) {
					{
					setState(1760);
					accessSpecifier();
					}
				}

				setState(1763);
				baseTypeSpecifier();
				}
				break;
			case Private:
			case Protected:
			case Public:
				{
				setState(1764);
				accessSpecifier();
				setState(1766);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Virtual) {
					{
					setState(1765);
					match(Virtual);
					}
				}

				setState(1768);
				baseTypeSpecifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ClassOrDeclTypeContext extends ParserRuleContext {
		public ClassNameContext className() {
			return getRuleContext(ClassNameContext.class,0);
		}
		public NestedNameSpecifierContext nestedNameSpecifier() {
			return getRuleContext(NestedNameSpecifierContext.class,0);
		}
		public DecltypeSpecifierContext decltypeSpecifier() {
			return getRuleContext(DecltypeSpecifierContext.class,0);
		}
		public ClassOrDeclTypeContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_classOrDeclType; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterClassOrDeclType(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitClassOrDeclType(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitClassOrDeclType(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ClassOrDeclTypeContext classOrDeclType() throws RecognitionException {
		ClassOrDeclTypeContext _localctx = new ClassOrDeclTypeContext(_ctx, getState());
		enterRule(_localctx, 310, RULE_classOrDeclType);
		try {
			setState(1777);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,247,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(1773);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,246,_ctx) ) {
				case 1:
					{
					setState(1772);
					nestedNameSpecifier(0);
					}
					break;
				}
				setState(1775);
				className();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(1776);
				decltypeSpecifier();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class BaseTypeSpecifierContext extends ParserRuleContext {
		public ClassOrDeclTypeContext classOrDeclType() {
			return getRuleContext(ClassOrDeclTypeContext.class,0);
		}
		public BaseTypeSpecifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_baseTypeSpecifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterBaseTypeSpecifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitBaseTypeSpecifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitBaseTypeSpecifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final BaseTypeSpecifierContext baseTypeSpecifier() throws RecognitionException {
		BaseTypeSpecifierContext _localctx = new BaseTypeSpecifierContext(_ctx, getState());
		enterRule(_localctx, 312, RULE_baseTypeSpecifier);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1779);
			classOrDeclType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class AccessSpecifierContext extends ParserRuleContext {
		public TerminalNode Private() { return getToken(CPP14Parser.Private, 0); }
		public TerminalNode Protected() { return getToken(CPP14Parser.Protected, 0); }
		public TerminalNode Public() { return getToken(CPP14Parser.Public, 0); }
		public AccessSpecifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_accessSpecifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterAccessSpecifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitAccessSpecifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitAccessSpecifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final AccessSpecifierContext accessSpecifier() throws RecognitionException {
		AccessSpecifierContext _localctx = new AccessSpecifierContext(_ctx, getState());
		enterRule(_localctx, 314, RULE_accessSpecifier);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1781);
			_la = _input.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 126100789566373888L) != 0)) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ConversionFunctionIdContext extends ParserRuleContext {
		public TerminalNode Operator() { return getToken(CPP14Parser.Operator, 0); }
		public ConversionTypeIdContext conversionTypeId() {
			return getRuleContext(ConversionTypeIdContext.class,0);
		}
		public ConversionFunctionIdContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_conversionFunctionId; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterConversionFunctionId(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitConversionFunctionId(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitConversionFunctionId(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ConversionFunctionIdContext conversionFunctionId() throws RecognitionException {
		ConversionFunctionIdContext _localctx = new ConversionFunctionIdContext(_ctx, getState());
		enterRule(_localctx, 316, RULE_conversionFunctionId);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1783);
			match(Operator);
			setState(1784);
			conversionTypeId();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ConversionTypeIdContext extends ParserRuleContext {
		public TypeSpecifierSeqContext typeSpecifierSeq() {
			return getRuleContext(TypeSpecifierSeqContext.class,0);
		}
		public ConversionDeclaratorContext conversionDeclarator() {
			return getRuleContext(ConversionDeclaratorContext.class,0);
		}
		public ConversionTypeIdContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_conversionTypeId; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterConversionTypeId(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitConversionTypeId(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitConversionTypeId(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ConversionTypeIdContext conversionTypeId() throws RecognitionException {
		ConversionTypeIdContext _localctx = new ConversionTypeIdContext(_ctx, getState());
		enterRule(_localctx, 318, RULE_conversionTypeId);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1786);
			typeSpecifierSeq();
			setState(1788);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,248,_ctx) ) {
			case 1:
				{
				setState(1787);
				conversionDeclarator();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ConversionDeclaratorContext extends ParserRuleContext {
		public PointerOperatorContext pointerOperator() {
			return getRuleContext(PointerOperatorContext.class,0);
		}
		public ConversionDeclaratorContext conversionDeclarator() {
			return getRuleContext(ConversionDeclaratorContext.class,0);
		}
		public ConversionDeclaratorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_conversionDeclarator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterConversionDeclarator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitConversionDeclarator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitConversionDeclarator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ConversionDeclaratorContext conversionDeclarator() throws RecognitionException {
		ConversionDeclaratorContext _localctx = new ConversionDeclaratorContext(_ctx, getState());
		enterRule(_localctx, 320, RULE_conversionDeclarator);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1790);
			pointerOperator();
			setState(1792);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,249,_ctx) ) {
			case 1:
				{
				setState(1791);
				conversionDeclarator();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ConstructorInitializerContext extends ParserRuleContext {
		public TerminalNode Colon() { return getToken(CPP14Parser.Colon, 0); }
		public MemInitializerListContext memInitializerList() {
			return getRuleContext(MemInitializerListContext.class,0);
		}
		public ConstructorInitializerContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_constructorInitializer; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterConstructorInitializer(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitConstructorInitializer(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitConstructorInitializer(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ConstructorInitializerContext constructorInitializer() throws RecognitionException {
		ConstructorInitializerContext _localctx = new ConstructorInitializerContext(_ctx, getState());
		enterRule(_localctx, 322, RULE_constructorInitializer);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1794);
			match(Colon);
			setState(1795);
			memInitializerList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class MemInitializerListContext extends ParserRuleContext {
		public List<MemInitializerContext> memInitializer() {
			return getRuleContexts(MemInitializerContext.class);
		}
		public MemInitializerContext memInitializer(int i) {
			return getRuleContext(MemInitializerContext.class,i);
		}
		public List<TerminalNode> Ellipsis() { return getTokens(CPP14Parser.Ellipsis); }
		public TerminalNode Ellipsis(int i) {
			return getToken(CPP14Parser.Ellipsis, i);
		}
		public List<TerminalNode> Comma() { return getTokens(CPP14Parser.Comma); }
		public TerminalNode Comma(int i) {
			return getToken(CPP14Parser.Comma, i);
		}
		public MemInitializerListContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_memInitializerList; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterMemInitializerList(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitMemInitializerList(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitMemInitializerList(this);
			else return visitor.visitChildren(this);
		}
	}

	public final MemInitializerListContext memInitializerList() throws RecognitionException {
		MemInitializerListContext _localctx = new MemInitializerListContext(_ctx, getState());
		enterRule(_localctx, 324, RULE_memInitializerList);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1797);
			memInitializer();
			setState(1799);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Ellipsis) {
				{
				setState(1798);
				match(Ellipsis);
				}
			}

			setState(1808);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==Comma) {
				{
				{
				setState(1801);
				match(Comma);
				setState(1802);
				memInitializer();
				setState(1804);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Ellipsis) {
					{
					setState(1803);
					match(Ellipsis);
					}
				}

				}
				}
				setState(1810);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class MemInitializerContext extends ParserRuleContext {
		public MeminitializeridContext meminitializerid() {
			return getRuleContext(MeminitializeridContext.class,0);
		}
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public BracedInitListContext bracedInitList() {
			return getRuleContext(BracedInitListContext.class,0);
		}
		public ExpressionListContext expressionList() {
			return getRuleContext(ExpressionListContext.class,0);
		}
		public MemInitializerContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_memInitializer; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterMemInitializer(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitMemInitializer(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitMemInitializer(this);
			else return visitor.visitChildren(this);
		}
	}

	public final MemInitializerContext memInitializer() throws RecognitionException {
		MemInitializerContext _localctx = new MemInitializerContext(_ctx, getState());
		enterRule(_localctx, 326, RULE_memInitializer);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1811);
			meminitializerid();
			setState(1818);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case LeftParen:
				{
				setState(1812);
				match(LeftParen);
				setState(1814);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 8364979464334764286L) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & 4719772474400910417L) != 0) || _la==Identifier) {
					{
					setState(1813);
					expressionList();
					}
				}

				setState(1816);
				match(RightParen);
				}
				break;
			case LeftBrace:
				{
				setState(1817);
				bracedInitList();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class MeminitializeridContext extends ParserRuleContext {
		public ClassOrDeclTypeContext classOrDeclType() {
			return getRuleContext(ClassOrDeclTypeContext.class,0);
		}
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public MeminitializeridContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_meminitializerid; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterMeminitializerid(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitMeminitializerid(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitMeminitializerid(this);
			else return visitor.visitChildren(this);
		}
	}

	public final MeminitializeridContext meminitializerid() throws RecognitionException {
		MeminitializeridContext _localctx = new MeminitializeridContext(_ctx, getState());
		enterRule(_localctx, 328, RULE_meminitializerid);
		try {
			setState(1822);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,255,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(1820);
				classOrDeclType();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(1821);
				match(Identifier);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class OperatorFunctionIdContext extends ParserRuleContext {
		public TerminalNode Operator() { return getToken(CPP14Parser.Operator, 0); }
		public TheOperatorContext theOperator() {
			return getRuleContext(TheOperatorContext.class,0);
		}
		public OperatorFunctionIdContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_operatorFunctionId; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterOperatorFunctionId(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitOperatorFunctionId(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitOperatorFunctionId(this);
			else return visitor.visitChildren(this);
		}
	}

	public final OperatorFunctionIdContext operatorFunctionId() throws RecognitionException {
		OperatorFunctionIdContext _localctx = new OperatorFunctionIdContext(_ctx, getState());
		enterRule(_localctx, 330, RULE_operatorFunctionId);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1824);
			match(Operator);
			setState(1825);
			theOperator();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class LiteralOperatorIdContext extends ParserRuleContext {
		public TerminalNode Operator() { return getToken(CPP14Parser.Operator, 0); }
		public TerminalNode StringLiteral() { return getToken(CPP14Parser.StringLiteral, 0); }
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public TerminalNode UserDefinedStringLiteral() { return getToken(CPP14Parser.UserDefinedStringLiteral, 0); }
		public LiteralOperatorIdContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_literalOperatorId; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterLiteralOperatorId(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitLiteralOperatorId(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitLiteralOperatorId(this);
			else return visitor.visitChildren(this);
		}
	}

	public final LiteralOperatorIdContext literalOperatorId() throws RecognitionException {
		LiteralOperatorIdContext _localctx = new LiteralOperatorIdContext(_ctx, getState());
		enterRule(_localctx, 332, RULE_literalOperatorId);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1827);
			match(Operator);
			setState(1831);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case StringLiteral:
				{
				setState(1828);
				match(StringLiteral);
				setState(1829);
				match(Identifier);
				}
				break;
			case UserDefinedStringLiteral:
				{
				setState(1830);
				match(UserDefinedStringLiteral);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TemplateDeclarationContext extends ParserRuleContext {
		public TerminalNode Template() { return getToken(CPP14Parser.Template, 0); }
		public TerminalNode Less() { return getToken(CPP14Parser.Less, 0); }
		public TemplateparameterListContext templateparameterList() {
			return getRuleContext(TemplateparameterListContext.class,0);
		}
		public TerminalNode Greater() { return getToken(CPP14Parser.Greater, 0); }
		public DeclarationContext declaration() {
			return getRuleContext(DeclarationContext.class,0);
		}
		public TemplateDeclarationContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_templateDeclaration; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTemplateDeclaration(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTemplateDeclaration(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTemplateDeclaration(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TemplateDeclarationContext templateDeclaration() throws RecognitionException {
		TemplateDeclarationContext _localctx = new TemplateDeclarationContext(_ctx, getState());
		enterRule(_localctx, 334, RULE_templateDeclaration);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1833);
			match(Template);
			setState(1834);
			match(Less);
			setState(1835);
			templateparameterList();
			setState(1836);
			match(Greater);
			setState(1837);
			declaration();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TemplateparameterListContext extends ParserRuleContext {
		public List<TemplateParameterContext> templateParameter() {
			return getRuleContexts(TemplateParameterContext.class);
		}
		public TemplateParameterContext templateParameter(int i) {
			return getRuleContext(TemplateParameterContext.class,i);
		}
		public List<TerminalNode> Comma() { return getTokens(CPP14Parser.Comma); }
		public TerminalNode Comma(int i) {
			return getToken(CPP14Parser.Comma, i);
		}
		public TemplateparameterListContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_templateparameterList; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTemplateparameterList(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTemplateparameterList(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTemplateparameterList(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TemplateparameterListContext templateparameterList() throws RecognitionException {
		TemplateparameterListContext _localctx = new TemplateparameterListContext(_ctx, getState());
		enterRule(_localctx, 336, RULE_templateparameterList);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1839);
			templateParameter();
			setState(1844);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==Comma) {
				{
				{
				setState(1840);
				match(Comma);
				setState(1841);
				templateParameter();
				}
				}
				setState(1846);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TemplateParameterContext extends ParserRuleContext {
		public TypeParameterContext typeParameter() {
			return getRuleContext(TypeParameterContext.class,0);
		}
		public ParameterDeclarationContext parameterDeclaration() {
			return getRuleContext(ParameterDeclarationContext.class,0);
		}
		public TemplateParameterContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_templateParameter; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTemplateParameter(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTemplateParameter(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTemplateParameter(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TemplateParameterContext templateParameter() throws RecognitionException {
		TemplateParameterContext _localctx = new TemplateParameterContext(_ctx, getState());
		enterRule(_localctx, 338, RULE_templateParameter);
		try {
			setState(1849);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,258,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(1847);
				typeParameter();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(1848);
				parameterDeclaration();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TypeParameterContext extends ParserRuleContext {
		public TerminalNode Class() { return getToken(CPP14Parser.Class, 0); }
		public TerminalNode Typename_() { return getToken(CPP14Parser.Typename_, 0); }
		public TerminalNode Assign() { return getToken(CPP14Parser.Assign, 0); }
		public TheTypeIdContext theTypeId() {
			return getRuleContext(TheTypeIdContext.class,0);
		}
		public TerminalNode Template() { return getToken(CPP14Parser.Template, 0); }
		public TerminalNode Less() { return getToken(CPP14Parser.Less, 0); }
		public TemplateparameterListContext templateparameterList() {
			return getRuleContext(TemplateparameterListContext.class,0);
		}
		public TerminalNode Greater() { return getToken(CPP14Parser.Greater, 0); }
		public TerminalNode Ellipsis() { return getToken(CPP14Parser.Ellipsis, 0); }
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public TypeParameterContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_typeParameter; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTypeParameter(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTypeParameter(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTypeParameter(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TypeParameterContext typeParameter() throws RecognitionException {
		TypeParameterContext _localctx = new TypeParameterContext(_ctx, getState());
		enterRule(_localctx, 340, RULE_typeParameter);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1860);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case Class:
			case Template:
				{
				setState(1856);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Template) {
					{
					setState(1851);
					match(Template);
					setState(1852);
					match(Less);
					setState(1853);
					templateparameterList();
					setState(1854);
					match(Greater);
					}
				}

				setState(1858);
				match(Class);
				}
				break;
			case Typename_:
				{
				setState(1859);
				match(Typename_);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			setState(1873);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,264,_ctx) ) {
			case 1:
				{
				setState(1863);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Ellipsis) {
					{
					setState(1862);
					match(Ellipsis);
					}
				}

				setState(1866);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Identifier) {
					{
					setState(1865);
					match(Identifier);
					}
				}

				}
				break;
			case 2:
				{
				setState(1869);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Identifier) {
					{
					setState(1868);
					match(Identifier);
					}
				}

				setState(1871);
				match(Assign);
				setState(1872);
				theTypeId();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class SimpleTemplateIdContext extends ParserRuleContext {
		public TemplateNameContext templateName() {
			return getRuleContext(TemplateNameContext.class,0);
		}
		public TerminalNode Less() { return getToken(CPP14Parser.Less, 0); }
		public TerminalNode Greater() { return getToken(CPP14Parser.Greater, 0); }
		public TemplateArgumentListContext templateArgumentList() {
			return getRuleContext(TemplateArgumentListContext.class,0);
		}
		public SimpleTemplateIdContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_simpleTemplateId; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterSimpleTemplateId(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitSimpleTemplateId(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitSimpleTemplateId(this);
			else return visitor.visitChildren(this);
		}
	}

	public final SimpleTemplateIdContext simpleTemplateId() throws RecognitionException {
		SimpleTemplateIdContext _localctx = new SimpleTemplateIdContext(_ctx, getState());
		enterRule(_localctx, 342, RULE_simpleTemplateId);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1875);
			templateName();
			setState(1876);
			match(Less);
			setState(1878);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 8364979472930990334L) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & 4719772474384268307L) != 0) || _la==Identifier) {
				{
				setState(1877);
				templateArgumentList();
				}
			}

			setState(1880);
			match(Greater);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TemplateIdContext extends ParserRuleContext {
		public SimpleTemplateIdContext simpleTemplateId() {
			return getRuleContext(SimpleTemplateIdContext.class,0);
		}
		public TerminalNode Less() { return getToken(CPP14Parser.Less, 0); }
		public TerminalNode Greater() { return getToken(CPP14Parser.Greater, 0); }
		public OperatorFunctionIdContext operatorFunctionId() {
			return getRuleContext(OperatorFunctionIdContext.class,0);
		}
		public LiteralOperatorIdContext literalOperatorId() {
			return getRuleContext(LiteralOperatorIdContext.class,0);
		}
		public TemplateArgumentListContext templateArgumentList() {
			return getRuleContext(TemplateArgumentListContext.class,0);
		}
		public TemplateIdContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_templateId; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTemplateId(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTemplateId(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTemplateId(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TemplateIdContext templateId() throws RecognitionException {
		TemplateIdContext _localctx = new TemplateIdContext(_ctx, getState());
		enterRule(_localctx, 344, RULE_templateId);
		int _la;
		try {
			setState(1893);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case Identifier:
				enterOuterAlt(_localctx, 1);
				{
				setState(1882);
				simpleTemplateId();
				}
				break;
			case Operator:
				enterOuterAlt(_localctx, 2);
				{
				setState(1885);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,266,_ctx) ) {
				case 1:
					{
					setState(1883);
					operatorFunctionId();
					}
					break;
				case 2:
					{
					setState(1884);
					literalOperatorId();
					}
					break;
				}
				setState(1887);
				match(Less);
				setState(1889);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 8364979472930990334L) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & 4719772474384268307L) != 0) || _la==Identifier) {
					{
					setState(1888);
					templateArgumentList();
					}
				}

				setState(1891);
				match(Greater);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TemplateNameContext extends ParserRuleContext {
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public TemplateNameContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_templateName; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTemplateName(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTemplateName(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTemplateName(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TemplateNameContext templateName() throws RecognitionException {
		TemplateNameContext _localctx = new TemplateNameContext(_ctx, getState());
		enterRule(_localctx, 346, RULE_templateName);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1895);
			match(Identifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TemplateArgumentListContext extends ParserRuleContext {
		public List<TemplateArgumentContext> templateArgument() {
			return getRuleContexts(TemplateArgumentContext.class);
		}
		public TemplateArgumentContext templateArgument(int i) {
			return getRuleContext(TemplateArgumentContext.class,i);
		}
		public List<TerminalNode> Ellipsis() { return getTokens(CPP14Parser.Ellipsis); }
		public TerminalNode Ellipsis(int i) {
			return getToken(CPP14Parser.Ellipsis, i);
		}
		public List<TerminalNode> Comma() { return getTokens(CPP14Parser.Comma); }
		public TerminalNode Comma(int i) {
			return getToken(CPP14Parser.Comma, i);
		}
		public TemplateArgumentListContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_templateArgumentList; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTemplateArgumentList(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTemplateArgumentList(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTemplateArgumentList(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TemplateArgumentListContext templateArgumentList() throws RecognitionException {
		TemplateArgumentListContext _localctx = new TemplateArgumentListContext(_ctx, getState());
		enterRule(_localctx, 348, RULE_templateArgumentList);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1897);
			templateArgument();
			setState(1899);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Ellipsis) {
				{
				setState(1898);
				match(Ellipsis);
				}
			}

			setState(1908);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==Comma) {
				{
				{
				setState(1901);
				match(Comma);
				setState(1902);
				templateArgument();
				setState(1904);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Ellipsis) {
					{
					setState(1903);
					match(Ellipsis);
					}
				}

				}
				}
				setState(1910);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TemplateArgumentContext extends ParserRuleContext {
		public TheTypeIdContext theTypeId() {
			return getRuleContext(TheTypeIdContext.class,0);
		}
		public ConstantExpressionContext constantExpression() {
			return getRuleContext(ConstantExpressionContext.class,0);
		}
		public IdExpressionContext idExpression() {
			return getRuleContext(IdExpressionContext.class,0);
		}
		public TemplateArgumentContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_templateArgument; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTemplateArgument(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTemplateArgument(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTemplateArgument(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TemplateArgumentContext templateArgument() throws RecognitionException {
		TemplateArgumentContext _localctx = new TemplateArgumentContext(_ctx, getState());
		enterRule(_localctx, 350, RULE_templateArgument);
		try {
			setState(1914);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,272,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(1911);
				theTypeId();
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(1912);
				constantExpression();
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(1913);
				idExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TypeNameSpecifierContext extends ParserRuleContext {
		public TerminalNode Typename_() { return getToken(CPP14Parser.Typename_, 0); }
		public NestedNameSpecifierContext nestedNameSpecifier() {
			return getRuleContext(NestedNameSpecifierContext.class,0);
		}
		public TerminalNode Identifier() { return getToken(CPP14Parser.Identifier, 0); }
		public SimpleTemplateIdContext simpleTemplateId() {
			return getRuleContext(SimpleTemplateIdContext.class,0);
		}
		public TerminalNode Template() { return getToken(CPP14Parser.Template, 0); }
		public TypeNameSpecifierContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_typeNameSpecifier; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTypeNameSpecifier(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTypeNameSpecifier(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTypeNameSpecifier(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TypeNameSpecifierContext typeNameSpecifier() throws RecognitionException {
		TypeNameSpecifierContext _localctx = new TypeNameSpecifierContext(_ctx, getState());
		enterRule(_localctx, 352, RULE_typeNameSpecifier);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1916);
			match(Typename_);
			setState(1917);
			nestedNameSpecifier(0);
			setState(1923);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,274,_ctx) ) {
			case 1:
				{
				setState(1918);
				match(Identifier);
				}
				break;
			case 2:
				{
				setState(1920);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Template) {
					{
					setState(1919);
					match(Template);
					}
				}

				setState(1922);
				simpleTemplateId();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ExplicitInstantiationContext extends ParserRuleContext {
		public TerminalNode Template() { return getToken(CPP14Parser.Template, 0); }
		public DeclarationContext declaration() {
			return getRuleContext(DeclarationContext.class,0);
		}
		public TerminalNode Extern() { return getToken(CPP14Parser.Extern, 0); }
		public ExplicitInstantiationContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_explicitInstantiation; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterExplicitInstantiation(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitExplicitInstantiation(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitExplicitInstantiation(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ExplicitInstantiationContext explicitInstantiation() throws RecognitionException {
		ExplicitInstantiationContext _localctx = new ExplicitInstantiationContext(_ctx, getState());
		enterRule(_localctx, 354, RULE_explicitInstantiation);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1926);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Extern) {
				{
				setState(1925);
				match(Extern);
				}
			}

			setState(1928);
			match(Template);
			setState(1929);
			declaration();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ExplicitSpecializationContext extends ParserRuleContext {
		public TerminalNode Template() { return getToken(CPP14Parser.Template, 0); }
		public TerminalNode Less() { return getToken(CPP14Parser.Less, 0); }
		public TerminalNode Greater() { return getToken(CPP14Parser.Greater, 0); }
		public DeclarationContext declaration() {
			return getRuleContext(DeclarationContext.class,0);
		}
		public ExplicitSpecializationContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_explicitSpecialization; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterExplicitSpecialization(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitExplicitSpecialization(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitExplicitSpecialization(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ExplicitSpecializationContext explicitSpecialization() throws RecognitionException {
		ExplicitSpecializationContext _localctx = new ExplicitSpecializationContext(_ctx, getState());
		enterRule(_localctx, 356, RULE_explicitSpecialization);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1931);
			match(Template);
			setState(1932);
			match(Less);
			setState(1933);
			match(Greater);
			setState(1934);
			declaration();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TryBlockContext extends ParserRuleContext {
		public TerminalNode Try() { return getToken(CPP14Parser.Try, 0); }
		public CompoundStatementContext compoundStatement() {
			return getRuleContext(CompoundStatementContext.class,0);
		}
		public HandlerSeqContext handlerSeq() {
			return getRuleContext(HandlerSeqContext.class,0);
		}
		public TryBlockContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_tryBlock; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTryBlock(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTryBlock(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTryBlock(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TryBlockContext tryBlock() throws RecognitionException {
		TryBlockContext _localctx = new TryBlockContext(_ctx, getState());
		enterRule(_localctx, 358, RULE_tryBlock);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1936);
			match(Try);
			setState(1937);
			compoundStatement();
			setState(1938);
			handlerSeq();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class FunctionTryBlockContext extends ParserRuleContext {
		public TerminalNode Try() { return getToken(CPP14Parser.Try, 0); }
		public CompoundStatementContext compoundStatement() {
			return getRuleContext(CompoundStatementContext.class,0);
		}
		public HandlerSeqContext handlerSeq() {
			return getRuleContext(HandlerSeqContext.class,0);
		}
		public ConstructorInitializerContext constructorInitializer() {
			return getRuleContext(ConstructorInitializerContext.class,0);
		}
		public FunctionTryBlockContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_functionTryBlock; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterFunctionTryBlock(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitFunctionTryBlock(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitFunctionTryBlock(this);
			else return visitor.visitChildren(this);
		}
	}

	public final FunctionTryBlockContext functionTryBlock() throws RecognitionException {
		FunctionTryBlockContext _localctx = new FunctionTryBlockContext(_ctx, getState());
		enterRule(_localctx, 360, RULE_functionTryBlock);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1940);
			match(Try);
			setState(1942);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Colon) {
				{
				setState(1941);
				constructorInitializer();
				}
			}

			setState(1944);
			compoundStatement();
			setState(1945);
			handlerSeq();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class HandlerSeqContext extends ParserRuleContext {
		public List<HandlerContext> handler() {
			return getRuleContexts(HandlerContext.class);
		}
		public HandlerContext handler(int i) {
			return getRuleContext(HandlerContext.class,i);
		}
		public HandlerSeqContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_handlerSeq; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterHandlerSeq(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitHandlerSeq(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitHandlerSeq(this);
			else return visitor.visitChildren(this);
		}
	}

	public final HandlerSeqContext handlerSeq() throws RecognitionException {
		HandlerSeqContext _localctx = new HandlerSeqContext(_ctx, getState());
		enterRule(_localctx, 362, RULE_handlerSeq);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1948); 
			_errHandler.sync(this);
			_la = _input.LA(1);
			do {
				{
				{
				setState(1947);
				handler();
				}
				}
				setState(1950); 
				_errHandler.sync(this);
				_la = _input.LA(1);
			} while ( _la==Catch );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class HandlerContext extends ParserRuleContext {
		public TerminalNode Catch() { return getToken(CPP14Parser.Catch, 0); }
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public ExceptionDeclarationContext exceptionDeclaration() {
			return getRuleContext(ExceptionDeclarationContext.class,0);
		}
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public CompoundStatementContext compoundStatement() {
			return getRuleContext(CompoundStatementContext.class,0);
		}
		public HandlerContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_handler; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterHandler(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitHandler(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitHandler(this);
			else return visitor.visitChildren(this);
		}
	}

	public final HandlerContext handler() throws RecognitionException {
		HandlerContext _localctx = new HandlerContext(_ctx, getState());
		enterRule(_localctx, 364, RULE_handler);
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1952);
			match(Catch);
			setState(1953);
			match(LeftParen);
			setState(1954);
			exceptionDeclaration();
			setState(1955);
			match(RightParen);
			setState(1956);
			compoundStatement();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ExceptionDeclarationContext extends ParserRuleContext {
		public TypeSpecifierSeqContext typeSpecifierSeq() {
			return getRuleContext(TypeSpecifierSeqContext.class,0);
		}
		public AttributeSpecifierSeqContext attributeSpecifierSeq() {
			return getRuleContext(AttributeSpecifierSeqContext.class,0);
		}
		public DeclaratorContext declarator() {
			return getRuleContext(DeclaratorContext.class,0);
		}
		public AbstractDeclaratorContext abstractDeclarator() {
			return getRuleContext(AbstractDeclaratorContext.class,0);
		}
		public TerminalNode Ellipsis() { return getToken(CPP14Parser.Ellipsis, 0); }
		public ExceptionDeclarationContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_exceptionDeclaration; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterExceptionDeclaration(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitExceptionDeclaration(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitExceptionDeclaration(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ExceptionDeclarationContext exceptionDeclaration() throws RecognitionException {
		ExceptionDeclarationContext _localctx = new ExceptionDeclarationContext(_ctx, getState());
		enterRule(_localctx, 366, RULE_exceptionDeclaration);
		int _la;
		try {
			setState(1967);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case Alignas:
			case Auto:
			case Bool:
			case Char:
			case Char16:
			case Char32:
			case Class:
			case Const:
			case Decltype:
			case Double:
			case Enum:
			case Float:
			case Int:
			case Long:
			case Short:
			case Signed:
			case Struct:
			case Typename_:
			case Union:
			case Unsigned:
			case Void:
			case Volatile:
			case Wchar:
			case LeftBracket:
			case Doublecolon:
			case Identifier:
				enterOuterAlt(_localctx, 1);
				{
				setState(1959);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Alignas || _la==LeftBracket) {
					{
					setState(1958);
					attributeSpecifierSeq();
					}
				}

				setState(1961);
				typeSpecifierSeq();
				setState(1964);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,279,_ctx) ) {
				case 1:
					{
					setState(1962);
					declarator();
					}
					break;
				case 2:
					{
					setState(1963);
					abstractDeclarator();
					}
					break;
				}
				}
				break;
			case Ellipsis:
				enterOuterAlt(_localctx, 2);
				{
				setState(1966);
				match(Ellipsis);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ThrowExpressionContext extends ParserRuleContext {
		public TerminalNode Throw() { return getToken(CPP14Parser.Throw, 0); }
		public AssignmentExpressionContext assignmentExpression() {
			return getRuleContext(AssignmentExpressionContext.class,0);
		}
		public ThrowExpressionContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_throwExpression; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterThrowExpression(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitThrowExpression(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitThrowExpression(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ThrowExpressionContext throwExpression() throws RecognitionException {
		ThrowExpressionContext _localctx = new ThrowExpressionContext(_ctx, getState());
		enterRule(_localctx, 368, RULE_throwExpression);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1969);
			match(Throw);
			setState(1971);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 8364979464334764286L) != 0) || ((((_la - 65)) & ~0x3f) == 0 && ((1L << (_la - 65)) & 4719772474384133201L) != 0) || _la==Identifier) {
				{
				setState(1970);
				assignmentExpression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class ExceptionSpecificationContext extends ParserRuleContext {
		public DynamicExceptionSpecificationContext dynamicExceptionSpecification() {
			return getRuleContext(DynamicExceptionSpecificationContext.class,0);
		}
		public NoeExceptSpecificationContext noeExceptSpecification() {
			return getRuleContext(NoeExceptSpecificationContext.class,0);
		}
		public ExceptionSpecificationContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_exceptionSpecification; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterExceptionSpecification(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitExceptionSpecification(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitExceptionSpecification(this);
			else return visitor.visitChildren(this);
		}
	}

	public final ExceptionSpecificationContext exceptionSpecification() throws RecognitionException {
		ExceptionSpecificationContext _localctx = new ExceptionSpecificationContext(_ctx, getState());
		enterRule(_localctx, 370, RULE_exceptionSpecification);
		try {
			setState(1975);
			_errHandler.sync(this);
			switch (_input.LA(1)) {
			case Throw:
				enterOuterAlt(_localctx, 1);
				{
				setState(1973);
				dynamicExceptionSpecification();
				}
				break;
			case Noexcept:
				enterOuterAlt(_localctx, 2);
				{
				setState(1974);
				noeExceptSpecification();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class DynamicExceptionSpecificationContext extends ParserRuleContext {
		public TerminalNode Throw() { return getToken(CPP14Parser.Throw, 0); }
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public TypeIdListContext typeIdList() {
			return getRuleContext(TypeIdListContext.class,0);
		}
		public DynamicExceptionSpecificationContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_dynamicExceptionSpecification; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterDynamicExceptionSpecification(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitDynamicExceptionSpecification(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitDynamicExceptionSpecification(this);
			else return visitor.visitChildren(this);
		}
	}

	public final DynamicExceptionSpecificationContext dynamicExceptionSpecification() throws RecognitionException {
		DynamicExceptionSpecificationContext _localctx = new DynamicExceptionSpecificationContext(_ctx, getState());
		enterRule(_localctx, 372, RULE_dynamicExceptionSpecification);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1977);
			match(Throw);
			setState(1978);
			match(LeftParen);
			setState(1980);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (((((_la - 13)) & ~0x3f) == 0 && ((1L << (_la - 13)) & -9213942612181769245L) != 0) || ((((_la - 77)) & ~0x3f) == 0 && ((1L << (_la - 77)) & 37154696925806707L) != 0)) {
				{
				setState(1979);
				typeIdList();
				}
			}

			setState(1982);
			match(RightParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TypeIdListContext extends ParserRuleContext {
		public List<TheTypeIdContext> theTypeId() {
			return getRuleContexts(TheTypeIdContext.class);
		}
		public TheTypeIdContext theTypeId(int i) {
			return getRuleContext(TheTypeIdContext.class,i);
		}
		public List<TerminalNode> Ellipsis() { return getTokens(CPP14Parser.Ellipsis); }
		public TerminalNode Ellipsis(int i) {
			return getToken(CPP14Parser.Ellipsis, i);
		}
		public List<TerminalNode> Comma() { return getTokens(CPP14Parser.Comma); }
		public TerminalNode Comma(int i) {
			return getToken(CPP14Parser.Comma, i);
		}
		public TypeIdListContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_typeIdList; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTypeIdList(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTypeIdList(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTypeIdList(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TypeIdListContext typeIdList() throws RecognitionException {
		TypeIdListContext _localctx = new TypeIdListContext(_ctx, getState());
		enterRule(_localctx, 374, RULE_typeIdList);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(1984);
			theTypeId();
			setState(1986);
			_errHandler.sync(this);
			_la = _input.LA(1);
			if (_la==Ellipsis) {
				{
				setState(1985);
				match(Ellipsis);
				}
			}

			setState(1995);
			_errHandler.sync(this);
			_la = _input.LA(1);
			while (_la==Comma) {
				{
				{
				setState(1988);
				match(Comma);
				setState(1989);
				theTypeId();
				setState(1991);
				_errHandler.sync(this);
				_la = _input.LA(1);
				if (_la==Ellipsis) {
					{
					setState(1990);
					match(Ellipsis);
					}
				}

				}
				}
				setState(1997);
				_errHandler.sync(this);
				_la = _input.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class NoeExceptSpecificationContext extends ParserRuleContext {
		public TerminalNode Noexcept() { return getToken(CPP14Parser.Noexcept, 0); }
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public ConstantExpressionContext constantExpression() {
			return getRuleContext(ConstantExpressionContext.class,0);
		}
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public NoeExceptSpecificationContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_noeExceptSpecification; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterNoeExceptSpecification(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitNoeExceptSpecification(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitNoeExceptSpecification(this);
			else return visitor.visitChildren(this);
		}
	}

	public final NoeExceptSpecificationContext noeExceptSpecification() throws RecognitionException {
		NoeExceptSpecificationContext _localctx = new NoeExceptSpecificationContext(_ctx, getState());
		enterRule(_localctx, 376, RULE_noeExceptSpecification);
		try {
			setState(2004);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,287,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(1998);
				match(Noexcept);
				setState(1999);
				match(LeftParen);
				setState(2000);
				constantExpression();
				setState(2001);
				match(RightParen);
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(2003);
				match(Noexcept);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class TheOperatorContext extends ParserRuleContext {
		public TerminalNode New() { return getToken(CPP14Parser.New, 0); }
		public TerminalNode LeftBracket() { return getToken(CPP14Parser.LeftBracket, 0); }
		public TerminalNode RightBracket() { return getToken(CPP14Parser.RightBracket, 0); }
		public TerminalNode Delete() { return getToken(CPP14Parser.Delete, 0); }
		public TerminalNode Plus() { return getToken(CPP14Parser.Plus, 0); }
		public TerminalNode Minus() { return getToken(CPP14Parser.Minus, 0); }
		public TerminalNode Star() { return getToken(CPP14Parser.Star, 0); }
		public TerminalNode Div() { return getToken(CPP14Parser.Div, 0); }
		public TerminalNode Mod() { return getToken(CPP14Parser.Mod, 0); }
		public TerminalNode Caret() { return getToken(CPP14Parser.Caret, 0); }
		public TerminalNode And() { return getToken(CPP14Parser.And, 0); }
		public TerminalNode Or() { return getToken(CPP14Parser.Or, 0); }
		public TerminalNode Tilde() { return getToken(CPP14Parser.Tilde, 0); }
		public TerminalNode Not() { return getToken(CPP14Parser.Not, 0); }
		public TerminalNode Assign() { return getToken(CPP14Parser.Assign, 0); }
		public List<TerminalNode> Greater() { return getTokens(CPP14Parser.Greater); }
		public TerminalNode Greater(int i) {
			return getToken(CPP14Parser.Greater, i);
		}
		public List<TerminalNode> Less() { return getTokens(CPP14Parser.Less); }
		public TerminalNode Less(int i) {
			return getToken(CPP14Parser.Less, i);
		}
		public TerminalNode GreaterEqual() { return getToken(CPP14Parser.GreaterEqual, 0); }
		public TerminalNode PlusAssign() { return getToken(CPP14Parser.PlusAssign, 0); }
		public TerminalNode MinusAssign() { return getToken(CPP14Parser.MinusAssign, 0); }
		public TerminalNode StarAssign() { return getToken(CPP14Parser.StarAssign, 0); }
		public TerminalNode ModAssign() { return getToken(CPP14Parser.ModAssign, 0); }
		public TerminalNode XorAssign() { return getToken(CPP14Parser.XorAssign, 0); }
		public TerminalNode AndAssign() { return getToken(CPP14Parser.AndAssign, 0); }
		public TerminalNode OrAssign() { return getToken(CPP14Parser.OrAssign, 0); }
		public TerminalNode RightShiftAssign() { return getToken(CPP14Parser.RightShiftAssign, 0); }
		public TerminalNode LeftShiftAssign() { return getToken(CPP14Parser.LeftShiftAssign, 0); }
		public TerminalNode Equal() { return getToken(CPP14Parser.Equal, 0); }
		public TerminalNode NotEqual() { return getToken(CPP14Parser.NotEqual, 0); }
		public TerminalNode LessEqual() { return getToken(CPP14Parser.LessEqual, 0); }
		public TerminalNode AndAnd() { return getToken(CPP14Parser.AndAnd, 0); }
		public TerminalNode OrOr() { return getToken(CPP14Parser.OrOr, 0); }
		public TerminalNode PlusPlus() { return getToken(CPP14Parser.PlusPlus, 0); }
		public TerminalNode MinusMinus() { return getToken(CPP14Parser.MinusMinus, 0); }
		public TerminalNode Comma() { return getToken(CPP14Parser.Comma, 0); }
		public TerminalNode ArrowStar() { return getToken(CPP14Parser.ArrowStar, 0); }
		public TerminalNode Arrow() { return getToken(CPP14Parser.Arrow, 0); }
		public TerminalNode LeftParen() { return getToken(CPP14Parser.LeftParen, 0); }
		public TerminalNode RightParen() { return getToken(CPP14Parser.RightParen, 0); }
		public TheOperatorContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_theOperator; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterTheOperator(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitTheOperator(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitTheOperator(this);
			else return visitor.visitChildren(this);
		}
	}

	public final TheOperatorContext theOperator() throws RecognitionException {
		TheOperatorContext _localctx = new TheOperatorContext(_ctx, getState());
		enterRule(_localctx, 378, RULE_theOperator);
		try {
			setState(2057);
			_errHandler.sync(this);
			switch ( getInterpreter().adaptivePredict(_input,290,_ctx) ) {
			case 1:
				enterOuterAlt(_localctx, 1);
				{
				setState(2006);
				match(New);
				setState(2009);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,288,_ctx) ) {
				case 1:
					{
					setState(2007);
					match(LeftBracket);
					setState(2008);
					match(RightBracket);
					}
					break;
				}
				}
				break;
			case 2:
				enterOuterAlt(_localctx, 2);
				{
				setState(2011);
				match(Delete);
				setState(2014);
				_errHandler.sync(this);
				switch ( getInterpreter().adaptivePredict(_input,289,_ctx) ) {
				case 1:
					{
					setState(2012);
					match(LeftBracket);
					setState(2013);
					match(RightBracket);
					}
					break;
				}
				}
				break;
			case 3:
				enterOuterAlt(_localctx, 3);
				{
				setState(2016);
				match(Plus);
				}
				break;
			case 4:
				enterOuterAlt(_localctx, 4);
				{
				setState(2017);
				match(Minus);
				}
				break;
			case 5:
				enterOuterAlt(_localctx, 5);
				{
				setState(2018);
				match(Star);
				}
				break;
			case 6:
				enterOuterAlt(_localctx, 6);
				{
				setState(2019);
				match(Div);
				}
				break;
			case 7:
				enterOuterAlt(_localctx, 7);
				{
				setState(2020);
				match(Mod);
				}
				break;
			case 8:
				enterOuterAlt(_localctx, 8);
				{
				setState(2021);
				match(Caret);
				}
				break;
			case 9:
				enterOuterAlt(_localctx, 9);
				{
				setState(2022);
				match(And);
				}
				break;
			case 10:
				enterOuterAlt(_localctx, 10);
				{
				setState(2023);
				match(Or);
				}
				break;
			case 11:
				enterOuterAlt(_localctx, 11);
				{
				setState(2024);
				match(Tilde);
				}
				break;
			case 12:
				enterOuterAlt(_localctx, 12);
				{
				setState(2025);
				match(Not);
				}
				break;
			case 13:
				enterOuterAlt(_localctx, 13);
				{
				setState(2026);
				match(Assign);
				}
				break;
			case 14:
				enterOuterAlt(_localctx, 14);
				{
				setState(2027);
				match(Greater);
				}
				break;
			case 15:
				enterOuterAlt(_localctx, 15);
				{
				setState(2028);
				match(Less);
				}
				break;
			case 16:
				enterOuterAlt(_localctx, 16);
				{
				setState(2029);
				match(GreaterEqual);
				}
				break;
			case 17:
				enterOuterAlt(_localctx, 17);
				{
				setState(2030);
				match(PlusAssign);
				}
				break;
			case 18:
				enterOuterAlt(_localctx, 18);
				{
				setState(2031);
				match(MinusAssign);
				}
				break;
			case 19:
				enterOuterAlt(_localctx, 19);
				{
				setState(2032);
				match(StarAssign);
				}
				break;
			case 20:
				enterOuterAlt(_localctx, 20);
				{
				setState(2033);
				match(ModAssign);
				}
				break;
			case 21:
				enterOuterAlt(_localctx, 21);
				{
				setState(2034);
				match(XorAssign);
				}
				break;
			case 22:
				enterOuterAlt(_localctx, 22);
				{
				setState(2035);
				match(AndAssign);
				}
				break;
			case 23:
				enterOuterAlt(_localctx, 23);
				{
				setState(2036);
				match(OrAssign);
				}
				break;
			case 24:
				enterOuterAlt(_localctx, 24);
				{
				setState(2037);
				match(Less);
				setState(2038);
				match(Less);
				}
				break;
			case 25:
				enterOuterAlt(_localctx, 25);
				{
				setState(2039);
				match(Greater);
				setState(2040);
				match(Greater);
				}
				break;
			case 26:
				enterOuterAlt(_localctx, 26);
				{
				setState(2041);
				match(RightShiftAssign);
				}
				break;
			case 27:
				enterOuterAlt(_localctx, 27);
				{
				setState(2042);
				match(LeftShiftAssign);
				}
				break;
			case 28:
				enterOuterAlt(_localctx, 28);
				{
				setState(2043);
				match(Equal);
				}
				break;
			case 29:
				enterOuterAlt(_localctx, 29);
				{
				setState(2044);
				match(NotEqual);
				}
				break;
			case 30:
				enterOuterAlt(_localctx, 30);
				{
				setState(2045);
				match(LessEqual);
				}
				break;
			case 31:
				enterOuterAlt(_localctx, 31);
				{
				setState(2046);
				match(AndAnd);
				}
				break;
			case 32:
				enterOuterAlt(_localctx, 32);
				{
				setState(2047);
				match(OrOr);
				}
				break;
			case 33:
				enterOuterAlt(_localctx, 33);
				{
				setState(2048);
				match(PlusPlus);
				}
				break;
			case 34:
				enterOuterAlt(_localctx, 34);
				{
				setState(2049);
				match(MinusMinus);
				}
				break;
			case 35:
				enterOuterAlt(_localctx, 35);
				{
				setState(2050);
				match(Comma);
				}
				break;
			case 36:
				enterOuterAlt(_localctx, 36);
				{
				setState(2051);
				match(ArrowStar);
				}
				break;
			case 37:
				enterOuterAlt(_localctx, 37);
				{
				setState(2052);
				match(Arrow);
				}
				break;
			case 38:
				enterOuterAlt(_localctx, 38);
				{
				setState(2053);
				match(LeftParen);
				setState(2054);
				match(RightParen);
				}
				break;
			case 39:
				enterOuterAlt(_localctx, 39);
				{
				setState(2055);
				match(LeftBracket);
				setState(2056);
				match(RightBracket);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	@SuppressWarnings("CheckReturnValue")
	public static class LiteralContext extends ParserRuleContext {
		public TerminalNode IntegerLiteral() { return getToken(CPP14Parser.IntegerLiteral, 0); }
		public TerminalNode CharacterLiteral() { return getToken(CPP14Parser.CharacterLiteral, 0); }
		public TerminalNode FloatingLiteral() { return getToken(CPP14Parser.FloatingLiteral, 0); }
		public TerminalNode StringLiteral() { return getToken(CPP14Parser.StringLiteral, 0); }
		public TerminalNode BooleanLiteral() { return getToken(CPP14Parser.BooleanLiteral, 0); }
		public TerminalNode PointerLiteral() { return getToken(CPP14Parser.PointerLiteral, 0); }
		public TerminalNode UserDefinedLiteral() { return getToken(CPP14Parser.UserDefinedLiteral, 0); }
		public LiteralContext(ParserRuleContext parent, int invokingState) {
			super(parent, invokingState);
		}
		@Override public int getRuleIndex() { return RULE_literal; }
		@Override
		public void enterRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).enterLiteral(this);
		}
		@Override
		public void exitRule(ParseTreeListener listener) {
			if ( listener instanceof CPP14ParserListener ) ((CPP14ParserListener)listener).exitLiteral(this);
		}
		@Override
		public <T> T accept(ParseTreeVisitor<? extends T> visitor) {
			if ( visitor instanceof CPP14ParserVisitor ) return ((CPP14ParserVisitor<? extends T>)visitor).visitLiteral(this);
			else return visitor.visitChildren(this);
		}
	}

	public final LiteralContext literal() throws RecognitionException {
		LiteralContext _localctx = new LiteralContext(_ctx, getState());
		enterRule(_localctx, 380, RULE_literal);
		int _la;
		try {
			enterOuterAlt(_localctx, 1);
			{
			setState(2059);
			_la = _input.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 254L) != 0)) ) {
			_errHandler.recoverInline(this);
			}
			else {
				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;
				_errHandler.reportMatch(this);
				consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.reportError(this, re);
			_errHandler.recover(this, re);
		}
		finally {
			exitRule();
		}
		return _localctx;
	}

	public boolean sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 5:
			return nestedNameSpecifier_sempred((NestedNameSpecifierContext)_localctx, predIndex);
		case 15:
			return postfixExpression_sempred((PostfixExpressionContext)_localctx, predIndex);
		case 25:
			return noPointerNewDeclarator_sempred((NoPointerNewDeclaratorContext)_localctx, predIndex);
		case 115:
			return noPointerDeclarator_sempred((NoPointerDeclaratorContext)_localctx, predIndex);
		case 148:
			return memberDeclarator_sempred((MemberDeclaratorContext)_localctx, predIndex);
		}
		return true;
	}
	private boolean nestedNameSpecifier_sempred(NestedNameSpecifierContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0:
			return precpred(_ctx, 1);
		}
		return true;
	}
	private boolean postfixExpression_sempred(PostfixExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 1:
			return precpred(_ctx, 7);
		case 2:
			return precpred(_ctx, 6);
		case 3:
			return precpred(_ctx, 4);
		case 4:
			return precpred(_ctx, 3);
		}
		return true;
	}
	private boolean noPointerNewDeclarator_sempred(NoPointerNewDeclaratorContext _localctx, int predIndex) {
		switch (predIndex) {
		case 5:
			return precpred(_ctx, 1);
		}
		return true;
	}
	private boolean noPointerDeclarator_sempred(NoPointerDeclaratorContext _localctx, int predIndex) {
		switch (predIndex) {
		case 6:
			return precpred(_ctx, 2);
		}
		return true;
	}
	private boolean memberDeclarator_sempred(MemberDeclaratorContext _localctx, int predIndex) {
		switch (predIndex) {
		case 7:
			return  this.IsPureSpecifierAllowed() ;
		case 8:
			return  this.IsPureSpecifierAllowed() ;
		}
		return true;
	}

	public static final String _serializedATN =
		"\u0004\u0001\u0091\u080e\u0002\u0000\u0007\u0000\u0002\u0001\u0007\u0001"+
		"\u0002\u0002\u0007\u0002\u0002\u0003\u0007\u0003\u0002\u0004\u0007\u0004"+
		"\u0002\u0005\u0007\u0005\u0002\u0006\u0007\u0006\u0002\u0007\u0007\u0007"+
		"\u0002\b\u0007\b\u0002\t\u0007\t\u0002\n\u0007\n\u0002\u000b\u0007\u000b"+
		"\u0002\f\u0007\f\u0002\r\u0007\r\u0002\u000e\u0007\u000e\u0002\u000f\u0007"+
		"\u000f\u0002\u0010\u0007\u0010\u0002\u0011\u0007\u0011\u0002\u0012\u0007"+
		"\u0012\u0002\u0013\u0007\u0013\u0002\u0014\u0007\u0014\u0002\u0015\u0007"+
		"\u0015\u0002\u0016\u0007\u0016\u0002\u0017\u0007\u0017\u0002\u0018\u0007"+
		"\u0018\u0002\u0019\u0007\u0019\u0002\u001a\u0007\u001a\u0002\u001b\u0007"+
		"\u001b\u0002\u001c\u0007\u001c\u0002\u001d\u0007\u001d\u0002\u001e\u0007"+
		"\u001e\u0002\u001f\u0007\u001f\u0002 \u0007 \u0002!\u0007!\u0002\"\u0007"+
		"\"\u0002#\u0007#\u0002$\u0007$\u0002%\u0007%\u0002&\u0007&\u0002\'\u0007"+
		"\'\u0002(\u0007(\u0002)\u0007)\u0002*\u0007*\u0002+\u0007+\u0002,\u0007"+
		",\u0002-\u0007-\u0002.\u0007.\u0002/\u0007/\u00020\u00070\u00021\u0007"+
		"1\u00022\u00072\u00023\u00073\u00024\u00074\u00025\u00075\u00026\u0007"+
		"6\u00027\u00077\u00028\u00078\u00029\u00079\u0002:\u0007:\u0002;\u0007"+
		";\u0002<\u0007<\u0002=\u0007=\u0002>\u0007>\u0002?\u0007?\u0002@\u0007"+
		"@\u0002A\u0007A\u0002B\u0007B\u0002C\u0007C\u0002D\u0007D\u0002E\u0007"+
		"E\u0002F\u0007F\u0002G\u0007G\u0002H\u0007H\u0002I\u0007I\u0002J\u0007"+
		"J\u0002K\u0007K\u0002L\u0007L\u0002M\u0007M\u0002N\u0007N\u0002O\u0007"+
		"O\u0002P\u0007P\u0002Q\u0007Q\u0002R\u0007R\u0002S\u0007S\u0002T\u0007"+
		"T\u0002U\u0007U\u0002V\u0007V\u0002W\u0007W\u0002X\u0007X\u0002Y\u0007"+
		"Y\u0002Z\u0007Z\u0002[\u0007[\u0002\\\u0007\\\u0002]\u0007]\u0002^\u0007"+
		"^\u0002_\u0007_\u0002`\u0007`\u0002a\u0007a\u0002b\u0007b\u0002c\u0007"+
		"c\u0002d\u0007d\u0002e\u0007e\u0002f\u0007f\u0002g\u0007g\u0002h\u0007"+
		"h\u0002i\u0007i\u0002j\u0007j\u0002k\u0007k\u0002l\u0007l\u0002m\u0007"+
		"m\u0002n\u0007n\u0002o\u0007o\u0002p\u0007p\u0002q\u0007q\u0002r\u0007"+
		"r\u0002s\u0007s\u0002t\u0007t\u0002u\u0007u\u0002v\u0007v\u0002w\u0007"+
		"w\u0002x\u0007x\u0002y\u0007y\u0002z\u0007z\u0002{\u0007{\u0002|\u0007"+
		"|\u0002}\u0007}\u0002~\u0007~\u0002\u007f\u0007\u007f\u0002\u0080\u0007"+
		"\u0080\u0002\u0081\u0007\u0081\u0002\u0082\u0007\u0082\u0002\u0083\u0007"+
		"\u0083\u0002\u0084\u0007\u0084\u0002\u0085\u0007\u0085\u0002\u0086\u0007"+
		"\u0086\u0002\u0087\u0007\u0087\u0002\u0088\u0007\u0088\u0002\u0089\u0007"+
		"\u0089\u0002\u008a\u0007\u008a\u0002\u008b\u0007\u008b\u0002\u008c\u0007"+
		"\u008c\u0002\u008d\u0007\u008d\u0002\u008e\u0007\u008e\u0002\u008f\u0007"+
		"\u008f\u0002\u0090\u0007\u0090\u0002\u0091\u0007\u0091\u0002\u0092\u0007"+
		"\u0092\u0002\u0093\u0007\u0093\u0002\u0094\u0007\u0094\u0002\u0095\u0007"+
		"\u0095\u0002\u0096\u0007\u0096\u0002\u0097\u0007\u0097\u0002\u0098\u0007"+
		"\u0098\u0002\u0099\u0007\u0099\u0002\u009a\u0007\u009a\u0002\u009b\u0007"+
		"\u009b\u0002\u009c\u0007\u009c\u0002\u009d\u0007\u009d\u0002\u009e\u0007"+
		"\u009e\u0002\u009f\u0007\u009f\u0002\u00a0\u0007\u00a0\u0002\u00a1\u0007"+
		"\u00a1\u0002\u00a2\u0007\u00a2\u0002\u00a3\u0007\u00a3\u0002\u00a4\u0007"+
		"\u00a4\u0002\u00a5\u0007\u00a5\u0002\u00a6\u0007\u00a6\u0002\u00a7\u0007"+
		"\u00a7\u0002\u00a8\u0007\u00a8\u0002\u00a9\u0007\u00a9\u0002\u00aa\u0007"+
		"\u00aa\u0002\u00ab\u0007\u00ab\u0002\u00ac\u0007\u00ac\u0002\u00ad\u0007"+
		"\u00ad\u0002\u00ae\u0007\u00ae\u0002\u00af\u0007\u00af\u0002\u00b0\u0007"+
		"\u00b0\u0002\u00b1\u0007\u00b1\u0002\u00b2\u0007\u00b2\u0002\u00b3\u0007"+
		"\u00b3\u0002\u00b4\u0007\u00b4\u0002\u00b5\u0007\u00b5\u0002\u00b6\u0007"+
		"\u00b6\u0002\u00b7\u0007\u00b7\u0002\u00b8\u0007\u00b8\u0002\u00b9\u0007"+
		"\u00b9\u0002\u00ba\u0007\u00ba\u0002\u00bb\u0007\u00bb\u0002\u00bc\u0007"+
		"\u00bc\u0002\u00bd\u0007\u00bd\u0002\u00be\u0007\u00be\u0001\u0000\u0003"+
		"\u0000\u0180\b\u0000\u0001\u0000\u0001\u0000\u0001\u0001\u0004\u0001\u0185"+
		"\b\u0001\u000b\u0001\f\u0001\u0186\u0001\u0001\u0001\u0001\u0001\u0001"+
		"\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0003\u0001\u0190\b\u0001"+
		"\u0001\u0002\u0001\u0002\u0003\u0002\u0194\b\u0002\u0001\u0003\u0001\u0003"+
		"\u0001\u0003\u0001\u0003\u0001\u0003\u0001\u0003\u0001\u0003\u0003\u0003"+
		"\u019d\b\u0003\u0001\u0003\u0003\u0003\u01a0\b\u0003\u0001\u0004\u0001"+
		"\u0004\u0003\u0004\u01a4\b\u0004\u0001\u0004\u0001\u0004\u0001\u0005\u0001"+
		"\u0005\u0001\u0005\u0001\u0005\u0003\u0005\u01ac\b\u0005\u0001\u0005\u0001"+
		"\u0005\u0001\u0005\u0001\u0005\u0001\u0005\u0003\u0005\u01b3\b\u0005\u0001"+
		"\u0005\u0003\u0005\u01b6\b\u0005\u0001\u0005\u0005\u0005\u01b9\b\u0005"+
		"\n\u0005\f\u0005\u01bc\t\u0005\u0001\u0006\u0001\u0006\u0003\u0006\u01c0"+
		"\b\u0006\u0001\u0006\u0001\u0006\u0001\u0007\u0001\u0007\u0003\u0007\u01c6"+
		"\b\u0007\u0001\u0007\u0001\u0007\u0001\b\u0001\b\u0001\b\u0001\b\u0003"+
		"\b\u01ce\b\b\u0003\b\u01d0\b\b\u0001\t\u0001\t\u0001\n\u0001\n\u0001\n"+
		"\u0005\n\u01d7\b\n\n\n\f\n\u01da\t\n\u0001\n\u0003\n\u01dd\b\n\u0001\u000b"+
		"\u0001\u000b\u0003\u000b\u01e1\b\u000b\u0001\f\u0003\f\u01e4\b\f\u0001"+
		"\f\u0001\f\u0003\f\u01e8\b\f\u0001\r\u0003\r\u01eb\b\r\u0001\r\u0001\r"+
		"\u0001\r\u0001\u000e\u0001\u000e\u0003\u000e\u01f2\b\u000e\u0001\u000e"+
		"\u0001\u000e\u0003\u000e\u01f6\b\u000e\u0001\u000e\u0003\u000e\u01f9\b"+
		"\u000e\u0001\u000e\u0003\u000e\u01fc\b\u000e\u0001\u000e\u0003\u000e\u01ff"+
		"\b\u000e\u0001\u000f\u0001\u000f\u0001\u000f\u0001\u000f\u0003\u000f\u0205"+
		"\b\u000f\u0001\u000f\u0001\u000f\u0003\u000f\u0209\b\u000f\u0001\u000f"+
		"\u0001\u000f\u0003\u000f\u020d\b\u000f\u0001\u000f\u0001\u000f\u0001\u000f"+
		"\u0001\u000f\u0001\u000f\u0001\u000f\u0001\u000f\u0001\u000f\u0001\u000f"+
		"\u0001\u000f\u0001\u000f\u0001\u000f\u0003\u000f\u021b\b\u000f\u0001\u000f"+
		"\u0001\u000f\u0003\u000f\u021f\b\u000f\u0001\u000f\u0001\u000f\u0001\u000f"+
		"\u0001\u000f\u0003\u000f\u0225\b\u000f\u0001\u000f\u0001\u000f\u0001\u000f"+
		"\u0001\u000f\u0001\u000f\u0003\u000f\u022c\b\u000f\u0001\u000f\u0001\u000f"+
		"\u0001\u000f\u0001\u000f\u0003\u000f\u0232\b\u000f\u0001\u000f\u0001\u000f"+
		"\u0003\u000f\u0236\b\u000f\u0001\u000f\u0001\u000f\u0005\u000f\u023a\b"+
		"\u000f\n\u000f\f\u000f\u023d\t\u000f\u0001\u0010\u0001\u0010\u0001\u0011"+
		"\u0001\u0011\u0001\u0012\u0003\u0012\u0244\b\u0012\u0001\u0012\u0001\u0012"+
		"\u0001\u0012\u0003\u0012\u0249\b\u0012\u0001\u0012\u0001\u0012\u0001\u0012"+
		"\u0001\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0001\u0012\u0001\u0012"+
		"\u0001\u0012\u0001\u0012\u0003\u0012\u0256\b\u0012\u0001\u0013\u0001\u0013"+
		"\u0001\u0013\u0001\u0013\u0001\u0013\u0003\u0013\u025d\b\u0013\u0001\u0013"+
		"\u0001\u0013\u0001\u0013\u0001\u0013\u0001\u0013\u0001\u0013\u0001\u0013"+
		"\u0001\u0013\u0001\u0013\u0001\u0013\u0003\u0013\u0269\b\u0013\u0001\u0013"+
		"\u0001\u0013\u0001\u0013\u0001\u0013\u0001\u0013\u0001\u0013\u0001\u0013"+
		"\u0001\u0013\u0003\u0013\u0273\b\u0013\u0001\u0014\u0001\u0014\u0001\u0015"+
		"\u0003\u0015\u0278\b\u0015\u0001\u0015\u0001\u0015\u0003\u0015\u027c\b"+
		"\u0015\u0001\u0015\u0001\u0015\u0001\u0015\u0001\u0015\u0001\u0015\u0003"+
		"\u0015\u0283\b\u0015\u0001\u0015\u0003\u0015\u0286\b\u0015\u0001\u0016"+
		"\u0001\u0016\u0001\u0016\u0001\u0016\u0001\u0017\u0001\u0017\u0003\u0017"+
		"\u028e\b\u0017\u0001\u0018\u0001\u0018\u0003\u0018\u0292\b\u0018\u0001"+
		"\u0018\u0003\u0018\u0295\b\u0018\u0001\u0019\u0001\u0019\u0001\u0019\u0001"+
		"\u0019\u0001\u0019\u0003\u0019\u029c\b\u0019\u0001\u0019\u0001\u0019\u0001"+
		"\u0019\u0001\u0019\u0001\u0019\u0003\u0019\u02a3\b\u0019\u0005\u0019\u02a5"+
		"\b\u0019\n\u0019\f\u0019\u02a8\t\u0019\u0001\u001a\u0001\u001a\u0003\u001a"+
		"\u02ac\b\u001a\u0001\u001a\u0001\u001a\u0003\u001a\u02b0\b\u001a\u0001"+
		"\u001b\u0003\u001b\u02b3\b\u001b\u0001\u001b\u0001\u001b\u0001\u001b\u0003"+
		"\u001b\u02b8\b\u001b\u0001\u001b\u0001\u001b\u0001\u001c\u0001\u001c\u0001"+
		"\u001c\u0001\u001c\u0001\u001c\u0001\u001d\u0001\u001d\u0001\u001d\u0001"+
		"\u001d\u0001\u001d\u0001\u001d\u0003\u001d\u02c7\b\u001d\u0001\u001e\u0001"+
		"\u001e\u0001\u001e\u0005\u001e\u02cc\b\u001e\n\u001e\f\u001e\u02cf\t\u001e"+
		"\u0001\u001f\u0001\u001f\u0001\u001f\u0005\u001f\u02d4\b\u001f\n\u001f"+
		"\f\u001f\u02d7\t\u001f\u0001 \u0001 \u0001 \u0005 \u02dc\b \n \f \u02df"+
		"\t \u0001!\u0001!\u0001!\u0001!\u0005!\u02e5\b!\n!\f!\u02e8\t!\u0001\""+
		"\u0001\"\u0001\"\u0001\"\u0003\"\u02ee\b\"\u0001#\u0001#\u0001#\u0005"+
		"#\u02f3\b#\n#\f#\u02f6\t#\u0001$\u0001$\u0001$\u0005$\u02fb\b$\n$\f$\u02fe"+
		"\t$\u0001%\u0001%\u0001%\u0005%\u0303\b%\n%\f%\u0306\t%\u0001&\u0001&"+
		"\u0001&\u0005&\u030b\b&\n&\f&\u030e\t&\u0001\'\u0001\'\u0001\'\u0005\'"+
		"\u0313\b\'\n\'\f\'\u0316\t\'\u0001(\u0001(\u0001(\u0005(\u031b\b(\n(\f"+
		"(\u031e\t(\u0001)\u0001)\u0001)\u0005)\u0323\b)\n)\f)\u0326\t)\u0001*"+
		"\u0001*\u0001*\u0001*\u0001*\u0001*\u0003*\u032e\b*\u0001+\u0001+\u0001"+
		"+\u0001+\u0001+\u0001+\u0003+\u0336\b+\u0001,\u0001,\u0001-\u0001-\u0001"+
		"-\u0005-\u033d\b-\n-\f-\u0340\t-\u0001.\u0001.\u0001/\u0001/\u0001/\u0003"+
		"/\u0347\b/\u0001/\u0001/\u0001/\u0001/\u0001/\u0001/\u0003/\u034f\b/\u0003"+
		"/\u0351\b/\u00010\u00030\u0354\b0\u00010\u00010\u00010\u00010\u00030\u035a"+
		"\b0\u00010\u00010\u00010\u00011\u00031\u0360\b1\u00011\u00011\u00012\u0001"+
		"2\u00032\u0366\b2\u00012\u00012\u00013\u00043\u036b\b3\u000b3\f3\u036c"+
		"\u00014\u00014\u00014\u00014\u00014\u00014\u00014\u00034\u0376\b4\u0001"+
		"4\u00014\u00014\u00014\u00014\u00014\u00034\u037e\b4\u00015\u00015\u0003"+
		"5\u0382\b5\u00015\u00015\u00015\u00015\u00015\u00035\u0389\b5\u00035\u038b"+
		"\b5\u00016\u00016\u00016\u00016\u00016\u00016\u00016\u00016\u00016\u0001"+
		"6\u00016\u00016\u00016\u00016\u00016\u00016\u00016\u00016\u00036\u039f"+
		"\b6\u00016\u00016\u00036\u03a3\b6\u00016\u00016\u00016\u00016\u00036\u03a9"+
		"\b6\u00016\u00016\u00016\u00036\u03ae\b6\u00017\u00017\u00037\u03b2\b"+
		"7\u00018\u00038\u03b5\b8\u00018\u00018\u00018\u00019\u00019\u00039\u03bc"+
		"\b9\u0001:\u0001:\u0001:\u0001:\u0001:\u0003:\u03c3\b:\u0001:\u0001:\u0003"+
		":\u03c7\b:\u0001:\u0001:\u0001;\u0001;\u0001<\u0004<\u03ce\b<\u000b<\f"+
		"<\u03cf\u0001=\u0001=\u0001=\u0001=\u0001=\u0001=\u0001=\u0001=\u0001"+
		"=\u0003=\u03db\b=\u0001>\u0001>\u0001>\u0001>\u0001>\u0001>\u0001>\u0001"+
		">\u0003>\u03e5\b>\u0001?\u0001?\u0001?\u0003?\u03ea\b?\u0001?\u0001?\u0001"+
		"?\u0001?\u0001@\u0003@\u03f1\b@\u0001@\u0003@\u03f4\b@\u0001@\u0001@\u0001"+
		"@\u0003@\u03f9\b@\u0001@\u0001@\u0001@\u0003@\u03fe\b@\u0001A\u0001A\u0001"+
		"A\u0001A\u0001A\u0001A\u0001A\u0001A\u0001B\u0001B\u0001C\u0001C\u0001"+
		"C\u0001D\u0001D\u0001D\u0001D\u0001D\u0001D\u0003D\u0413\bD\u0001E\u0004"+
		"E\u0416\bE\u000bE\fE\u0417\u0001E\u0003E\u041b\bE\u0001F\u0001F\u0001"+
		"G\u0001G\u0001H\u0001H\u0001I\u0001I\u0001I\u0003I\u0426\bI\u0001J\u0001"+
		"J\u0001J\u0001J\u0003J\u042c\bJ\u0001K\u0004K\u042f\bK\u000bK\fK\u0430"+
		"\u0001K\u0003K\u0434\bK\u0001L\u0004L\u0437\bL\u000bL\fL\u0438\u0001L"+
		"\u0003L\u043c\bL\u0001M\u0001M\u0001N\u0001N\u0001O\u0003O\u0443\bO\u0001"+
		"O\u0001O\u0001O\u0001O\u0001O\u0001O\u0001O\u0001O\u0001O\u0001O\u0001"+
		"O\u0001O\u0001O\u0001O\u0001O\u0001O\u0001O\u0001O\u0001O\u0001O\u0001"+
		"O\u0003O\u045a\bO\u0001P\u0001P\u0001P\u0001P\u0003P\u0460\bP\u0001Q\u0001"+
		"Q\u0001Q\u0001Q\u0003Q\u0466\bQ\u0001Q\u0001Q\u0001R\u0001R\u0003R\u046c"+
		"\bR\u0001R\u0003R\u046f\bR\u0001R\u0001R\u0001R\u0001R\u0003R\u0475\b"+
		"R\u0001R\u0001R\u0003R\u0479\bR\u0001R\u0001R\u0003R\u047d\bR\u0001R\u0003"+
		"R\u0480\bR\u0001S\u0001S\u0001T\u0001T\u0001T\u0001T\u0003T\u0488\bT\u0003"+
		"T\u048a\bT\u0001T\u0001T\u0001U\u0001U\u0003U\u0490\bU\u0001U\u0003U\u0493"+
		"\bU\u0001U\u0003U\u0496\bU\u0001U\u0003U\u0499\bU\u0001V\u0001V\u0003"+
		"V\u049d\bV\u0001V\u0001V\u0003V\u04a1\bV\u0001V\u0001V\u0001W\u0001W\u0003"+
		"W\u04a7\bW\u0001X\u0001X\u0001X\u0001Y\u0001Y\u0001Y\u0005Y\u04af\bY\n"+
		"Y\fY\u04b2\tY\u0001Z\u0001Z\u0001Z\u0003Z\u04b7\bZ\u0001[\u0001[\u0001"+
		"\\\u0001\\\u0003\\\u04bd\b\\\u0001]\u0001]\u0001^\u0003^\u04c2\b^\u0001"+
		"^\u0001^\u0001^\u0003^\u04c7\b^\u0001^\u0001^\u0003^\u04cb\b^\u0001^\u0001"+
		"^\u0001_\u0001_\u0001`\u0001`\u0001`\u0001`\u0001`\u0001`\u0001a\u0003"+
		"a\u04d8\ba\u0001a\u0001a\u0001b\u0001b\u0003b\u04de\bb\u0001b\u0001b\u0003"+
		"b\u04e2\bb\u0001b\u0001b\u0001b\u0001c\u0003c\u04e8\bc\u0001c\u0001c\u0001"+
		"c\u0003c\u04ed\bc\u0001c\u0001c\u0001c\u0001d\u0001d\u0001d\u0001d\u0001"+
		"d\u0001d\u0001e\u0001e\u0001e\u0001e\u0003e\u04fc\be\u0001e\u0001e\u0003"+
		"e\u0500\be\u0001f\u0004f\u0503\bf\u000bf\ff\u0504\u0001g\u0001g\u0001"+
		"g\u0003g\u050a\bg\u0001g\u0001g\u0001g\u0003g\u050f\bg\u0001h\u0001h\u0001"+
		"h\u0001h\u0003h\u0515\bh\u0001h\u0003h\u0518\bh\u0001h\u0001h\u0001i\u0001"+
		"i\u0001i\u0005i\u051f\bi\ni\fi\u0522\ti\u0001i\u0003i\u0525\bi\u0001j"+
		"\u0001j\u0001j\u0003j\u052a\bj\u0001j\u0001j\u0003j\u052e\bj\u0001k\u0001"+
		"k\u0001l\u0001l\u0003l\u0534\bl\u0001l\u0001l\u0001m\u0004m\u0539\bm\u000b"+
		"m\fm\u053a\u0001n\u0001n\u0001n\u0001n\u0001n\u0001n\u0001n\u0001n\u0001"+
		"n\u0001n\u0001n\u0001n\u0001n\u0004n\u054a\bn\u000bn\fn\u054b\u0003n\u054e"+
		"\bn\u0001o\u0001o\u0001o\u0005o\u0553\bo\no\fo\u0556\to\u0001p\u0001p"+
		"\u0003p\u055a\bp\u0001q\u0001q\u0001q\u0001q\u0001q\u0003q\u0561\bq\u0001"+
		"r\u0001r\u0003r\u0565\br\u0005r\u0567\br\nr\fr\u056a\tr\u0001r\u0001r"+
		"\u0001s\u0001s\u0001s\u0003s\u0571\bs\u0001s\u0001s\u0001s\u0001s\u0003"+
		"s\u0577\bs\u0001s\u0001s\u0001s\u0001s\u0003s\u057d\bs\u0001s\u0001s\u0003"+
		"s\u0581\bs\u0003s\u0583\bs\u0005s\u0585\bs\ns\fs\u0588\ts\u0001t\u0001"+
		"t\u0003t\u058c\bt\u0001t\u0001t\u0003t\u0590\bt\u0001t\u0003t\u0593\b"+
		"t\u0001t\u0003t\u0596\bt\u0001t\u0003t\u0599\bt\u0001u\u0001u\u0001u\u0003"+
		"u\u059e\bu\u0001v\u0001v\u0003v\u05a2\bv\u0001v\u0003v\u05a5\bv\u0001"+
		"v\u0001v\u0003v\u05a9\bv\u0001v\u0003v\u05ac\bv\u0003v\u05ae\bv\u0001"+
		"w\u0004w\u05b1\bw\u000bw\fw\u05b2\u0001x\u0001x\u0001y\u0001y\u0001z\u0003"+
		"z\u05ba\bz\u0001z\u0001z\u0001{\u0001{\u0003{\u05c0\b{\u0001|\u0001|\u0003"+
		"|\u05c4\b|\u0001|\u0001|\u0001|\u0001|\u0003|\u05ca\b|\u0001}\u0005}\u05cd"+
		"\b}\n}\f}\u05d0\t}\u0001}\u0001}\u0003}\u05d4\b}\u0001~\u0001~\u0001~"+
		"\u0001~\u0001~\u0003~\u05db\b~\u0001~\u0001~\u0001~\u0003~\u05e0\b~\u0001"+
		"~\u0001~\u0003~\u05e4\b~\u0005~\u05e6\b~\n~\f~\u05e9\t~\u0001\u007f\u0005"+
		"\u007f\u05ec\b\u007f\n\u007f\f\u007f\u05ef\t\u007f\u0001\u007f\u0001\u007f"+
		"\u0001\u0080\u0001\u0080\u0001\u0080\u0001\u0080\u0003\u0080\u05f7\b\u0080"+
		"\u0001\u0080\u0001\u0080\u0003\u0080\u05fb\b\u0080\u0005\u0080\u05fd\b"+
		"\u0080\n\u0080\f\u0080\u0600\t\u0080\u0001\u0081\u0001\u0081\u0003\u0081"+
		"\u0604\b\u0081\u0001\u0081\u0003\u0081\u0607\b\u0081\u0001\u0082\u0001"+
		"\u0082\u0001\u0082\u0005\u0082\u060c\b\u0082\n\u0082\f\u0082\u060f\t\u0082"+
		"\u0001\u0083\u0003\u0083\u0612\b\u0083\u0001\u0083\u0001\u0083\u0001\u0083"+
		"\u0003\u0083\u0617\b\u0083\u0003\u0083\u0619\b\u0083\u0001\u0083\u0001"+
		"\u0083\u0003\u0083\u061d\b\u0083\u0001\u0084\u0003\u0084\u0620\b\u0084"+
		"\u0001\u0084\u0003\u0084\u0623\b\u0084\u0001\u0084\u0001\u0084\u0003\u0084"+
		"\u0627\b\u0084\u0001\u0084\u0001\u0084\u0001\u0085\u0003\u0085\u062c\b"+
		"\u0085\u0001\u0085\u0001\u0085\u0001\u0085\u0001\u0085\u0001\u0085\u0003"+
		"\u0085\u0633\b\u0085\u0001\u0086\u0001\u0086\u0001\u0086\u0001\u0086\u0001"+
		"\u0086\u0003\u0086\u063a\b\u0086\u0001\u0087\u0001\u0087\u0001\u0087\u0003"+
		"\u0087\u063f\b\u0087\u0001\u0088\u0001\u0088\u0003\u0088\u0643\b\u0088"+
		"\u0001\u0089\u0001\u0089\u0003\u0089\u0647\b\u0089\u0001\u0089\u0001\u0089"+
		"\u0001\u0089\u0003\u0089\u064c\b\u0089\u0005\u0089\u064e\b\u0089\n\u0089"+
		"\f\u0089\u0651\t\u0089\u0001\u008a\u0001\u008a\u0001\u008a\u0003\u008a"+
		"\u0656\b\u008a\u0003\u008a\u0658\b\u008a\u0001\u008a\u0001\u008a\u0001"+
		"\u008b\u0001\u008b\u0003\u008b\u065e\b\u008b\u0001\u008c\u0001\u008c\u0001"+
		"\u008c\u0003\u008c\u0663\b\u008c\u0001\u008c\u0001\u008c\u0001\u008d\u0001"+
		"\u008d\u0003\u008d\u0669\b\u008d\u0001\u008d\u0001\u008d\u0003\u008d\u066d"+
		"\b\u008d\u0003\u008d\u066f\b\u008d\u0001\u008d\u0003\u008d\u0672\b\u008d"+
		"\u0001\u008d\u0001\u008d\u0003\u008d\u0676\b\u008d\u0001\u008d\u0001\u008d"+
		"\u0003\u008d\u067a\b\u008d\u0003\u008d\u067c\b\u008d\u0003\u008d\u067e"+
		"\b\u008d\u0001\u008e\u0003\u008e\u0681\b\u008e\u0001\u008e\u0001\u008e"+
		"\u0001\u008f\u0001\u008f\u0001\u0090\u0001\u0090\u0001\u0091\u0001\u0091"+
		"\u0001\u0091\u0001\u0091\u0004\u0091\u068d\b\u0091\u000b\u0091\f\u0091"+
		"\u068e\u0001\u0092\u0003\u0092\u0692\b\u0092\u0001\u0092\u0003\u0092\u0695"+
		"\b\u0092\u0001\u0092\u0003\u0092\u0698\b\u0092\u0001\u0092\u0001\u0092"+
		"\u0001\u0092\u0001\u0092\u0001\u0092\u0001\u0092\u0001\u0092\u0003\u0092"+
		"\u06a1\b\u0092\u0001\u0093\u0001\u0093\u0001\u0093\u0005\u0093\u06a6\b"+
		"\u0093\n\u0093\f\u0093\u06a9\t\u0093\u0001\u0094\u0001\u0094\u0001\u0094"+
		"\u0001\u0094\u0001\u0094\u0001\u0094\u0001\u0094\u0001\u0094\u0001\u0094"+
		"\u0003\u0094\u06b4\b\u0094\u0001\u0094\u0001\u0094\u0003\u0094\u06b8\b"+
		"\u0094\u0001\u0094\u0003\u0094\u06bb\b\u0094\u0001\u0094\u0001\u0094\u0003"+
		"\u0094\u06bf\b\u0094\u0001\u0095\u0004\u0095\u06c2\b\u0095\u000b\u0095"+
		"\f\u0095\u06c3\u0001\u0096\u0001\u0096\u0001\u0097\u0001\u0097\u0001\u0097"+
		"\u0001\u0098\u0001\u0098\u0001\u0098\u0001\u0099\u0001\u0099\u0003\u0099"+
		"\u06d0\b\u0099\u0001\u0099\u0001\u0099\u0001\u0099\u0003\u0099\u06d5\b"+
		"\u0099\u0005\u0099\u06d7\b\u0099\n\u0099\f\u0099\u06da\t\u0099\u0001\u009a"+
		"\u0003\u009a\u06dd\b\u009a\u0001\u009a\u0001\u009a\u0001\u009a\u0003\u009a"+
		"\u06e2\b\u009a\u0001\u009a\u0001\u009a\u0001\u009a\u0003\u009a\u06e7\b"+
		"\u009a\u0001\u009a\u0001\u009a\u0003\u009a\u06eb\b\u009a\u0001\u009b\u0003"+
		"\u009b\u06ee\b\u009b\u0001\u009b\u0001\u009b\u0003\u009b\u06f2\b\u009b"+
		"\u0001\u009c\u0001\u009c\u0001\u009d\u0001\u009d\u0001\u009e\u0001\u009e"+
		"\u0001\u009e\u0001\u009f\u0001\u009f\u0003\u009f\u06fd\b\u009f\u0001\u00a0"+
		"\u0001\u00a0\u0003\u00a0\u0701\b\u00a0\u0001\u00a1\u0001\u00a1\u0001\u00a1"+
		"\u0001\u00a2\u0001\u00a2\u0003\u00a2\u0708\b\u00a2\u0001\u00a2\u0001\u00a2"+
		"\u0001\u00a2\u0003\u00a2\u070d\b\u00a2\u0005\u00a2\u070f\b\u00a2\n\u00a2"+
		"\f\u00a2\u0712\t\u00a2\u0001\u00a3\u0001\u00a3\u0001\u00a3\u0003\u00a3"+
		"\u0717\b\u00a3\u0001\u00a3\u0001\u00a3\u0003\u00a3\u071b\b\u00a3\u0001"+
		"\u00a4\u0001\u00a4\u0003\u00a4\u071f\b\u00a4\u0001\u00a5\u0001\u00a5\u0001"+
		"\u00a5\u0001\u00a6\u0001\u00a6\u0001\u00a6\u0001\u00a6\u0003\u00a6\u0728"+
		"\b\u00a6\u0001\u00a7\u0001\u00a7\u0001\u00a7\u0001\u00a7\u0001\u00a7\u0001"+
		"\u00a7\u0001\u00a8\u0001\u00a8\u0001\u00a8\u0005\u00a8\u0733\b\u00a8\n"+
		"\u00a8\f\u00a8\u0736\t\u00a8\u0001\u00a9\u0001\u00a9\u0003\u00a9\u073a"+
		"\b\u00a9\u0001\u00aa\u0001\u00aa\u0001\u00aa\u0001\u00aa\u0001\u00aa\u0003"+
		"\u00aa\u0741\b\u00aa\u0001\u00aa\u0001\u00aa\u0003\u00aa\u0745\b\u00aa"+
		"\u0001\u00aa\u0003\u00aa\u0748\b\u00aa\u0001\u00aa\u0003\u00aa\u074b\b"+
		"\u00aa\u0001\u00aa\u0003\u00aa\u074e\b\u00aa\u0001\u00aa\u0001\u00aa\u0003"+
		"\u00aa\u0752\b\u00aa\u0001\u00ab\u0001\u00ab\u0001\u00ab\u0003\u00ab\u0757"+
		"\b\u00ab\u0001\u00ab\u0001\u00ab\u0001\u00ac\u0001\u00ac\u0001\u00ac\u0003"+
		"\u00ac\u075e\b\u00ac\u0001\u00ac\u0001\u00ac\u0003\u00ac\u0762\b\u00ac"+
		"\u0001\u00ac\u0001\u00ac\u0003\u00ac\u0766\b\u00ac\u0001\u00ad\u0001\u00ad"+
		"\u0001\u00ae\u0001\u00ae\u0003\u00ae\u076c\b\u00ae\u0001\u00ae\u0001\u00ae"+
		"\u0001\u00ae\u0003\u00ae\u0771\b\u00ae\u0005\u00ae\u0773\b\u00ae\n\u00ae"+
		"\f\u00ae\u0776\t\u00ae\u0001\u00af\u0001\u00af\u0001\u00af\u0003\u00af"+
		"\u077b\b\u00af\u0001\u00b0\u0001\u00b0\u0001\u00b0\u0001\u00b0\u0003\u00b0"+
		"\u0781\b\u00b0\u0001\u00b0\u0003\u00b0\u0784\b\u00b0\u0001\u00b1\u0003"+
		"\u00b1\u0787\b\u00b1\u0001\u00b1\u0001\u00b1\u0001\u00b1\u0001\u00b2\u0001"+
		"\u00b2\u0001\u00b2\u0001\u00b2\u0001\u00b2\u0001\u00b3\u0001\u00b3\u0001"+
		"\u00b3\u0001\u00b3\u0001\u00b4\u0001\u00b4\u0003\u00b4\u0797\b\u00b4\u0001"+
		"\u00b4\u0001\u00b4\u0001\u00b4\u0001\u00b5\u0004\u00b5\u079d\b\u00b5\u000b"+
		"\u00b5\f\u00b5\u079e\u0001\u00b6\u0001\u00b6\u0001\u00b6\u0001\u00b6\u0001"+
		"\u00b6\u0001\u00b6\u0001\u00b7\u0003\u00b7\u07a8\b\u00b7\u0001\u00b7\u0001"+
		"\u00b7\u0001\u00b7\u0003\u00b7\u07ad\b\u00b7\u0001\u00b7\u0003\u00b7\u07b0"+
		"\b\u00b7\u0001\u00b8\u0001\u00b8\u0003\u00b8\u07b4\b\u00b8\u0001\u00b9"+
		"\u0001\u00b9\u0003\u00b9\u07b8\b\u00b9\u0001\u00ba\u0001\u00ba\u0001\u00ba"+
		"\u0003\u00ba\u07bd\b\u00ba\u0001\u00ba\u0001\u00ba\u0001\u00bb\u0001\u00bb"+
		"\u0003\u00bb\u07c3\b\u00bb\u0001\u00bb\u0001\u00bb\u0001\u00bb\u0003\u00bb"+
		"\u07c8\b\u00bb\u0005\u00bb\u07ca\b\u00bb\n\u00bb\f\u00bb\u07cd\t\u00bb"+
		"\u0001\u00bc\u0001\u00bc\u0001\u00bc\u0001\u00bc\u0001\u00bc\u0001\u00bc"+
		"\u0003\u00bc\u07d5\b\u00bc\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0003\u00bd"+
		"\u07da\b\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0003\u00bd\u07df\b"+
		"\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0001"+
		"\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0001"+
		"\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0001"+
		"\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0001"+
		"\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0001"+
		"\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0001"+
		"\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0001\u00bd\u0003"+
		"\u00bd\u080a\b\u00bd\u0001\u00be\u0001\u00be\u0001\u00be\u0001\u0417\u0004"+
		"\n\u001e2\u00e6\u00bf\u0000\u0002\u0004\u0006\b\n\f\u000e\u0010\u0012"+
		"\u0014\u0016\u0018\u001a\u001c\u001e \"$&(*,.02468:<>@BDFHJLNPRTVXZ\\"+
		"^`bdfhjlnprtvxz|~\u0080\u0082\u0084\u0086\u0088\u008a\u008c\u008e\u0090"+
		"\u0092\u0094\u0096\u0098\u009a\u009c\u009e\u00a0\u00a2\u00a4\u00a6\u00a8"+
		"\u00aa\u00ac\u00ae\u00b0\u00b2\u00b4\u00b6\u00b8\u00ba\u00bc\u00be\u00c0"+
		"\u00c2\u00c4\u00c6\u00c8\u00ca\u00cc\u00ce\u00d0\u00d2\u00d4\u00d6\u00d8"+
		"\u00da\u00dc\u00de\u00e0\u00e2\u00e4\u00e6\u00e8\u00ea\u00ec\u00ee\u00f0"+
		"\u00f2\u00f4\u00f6\u00f8\u00fa\u00fc\u00fe\u0100\u0102\u0104\u0106\u0108"+
		"\u010a\u010c\u010e\u0110\u0112\u0114\u0116\u0118\u011a\u011c\u011e\u0120"+
		"\u0122\u0124\u0126\u0128\u012a\u012c\u012e\u0130\u0132\u0134\u0136\u0138"+
		"\u013a\u013c\u013e\u0140\u0142\u0144\u0146\u0148\u014a\u014c\u014e\u0150"+
		"\u0152\u0154\u0156\u0158\u015a\u015c\u015e\u0160\u0162\u0164\u0166\u0168"+
		"\u016a\u016c\u016e\u0170\u0172\u0174\u0176\u0178\u017a\u017c\u0000\u0017"+
		"\u0002\u0000aaee\u0004\u0000\u0018\u0018\u001f\u001f::AA\u0002\u0000|"+
		"|\u0081\u0081\u0001\u0000xy\u0002\u0000[]ad\u0002\u0000{{\u0082\u0082"+
		"\u0001\u0000]_\u0001\u0000[\\\u0002\u0000fgtu\u0001\u0000rs\u0002\u0000"+
		"eehq\u0005\u0000$$//99??FF\u0003\u0000\"\",,PP\u0002\u0000..<<\u0002\u0000"+
		"==NN\u0002\u0000\u0015\u0015BB\u0001\u0000UZ\u0002\u0000aavv\u0002\u0000"+
		"\u0016\u0016RR\u0001\u0000\u001b\u001c\u0002\u0000&&55\u0001\u000068\u0001"+
		"\u0000\u0001\u0007\u08ed\u0000\u017f\u0001\u0000\u0000\u0000\u0002\u018f"+
		"\u0001\u0000\u0000\u0000\u0004\u0193\u0001\u0000\u0000\u0000\u0006\u019f"+
		"\u0001\u0000\u0000\u0000\b\u01a1\u0001\u0000\u0000\u0000\n\u01a7\u0001"+
		"\u0000\u0000\u0000\f\u01bd\u0001\u0000\u0000\u0000\u000e\u01c3\u0001\u0000"+
		"\u0000\u0000\u0010\u01cf\u0001\u0000\u0000\u0000\u0012\u01d1\u0001\u0000"+
		"\u0000\u0000\u0014\u01d3\u0001\u0000\u0000\u0000\u0016\u01e0\u0001\u0000"+
		"\u0000\u0000\u0018\u01e7\u0001\u0000\u0000\u0000\u001a\u01ea\u0001\u0000"+
		"\u0000\u0000\u001c\u01ef\u0001\u0000\u0000\u0000\u001e\u021e\u0001\u0000"+
		"\u0000\u0000 \u023e\u0001\u0000\u0000\u0000\"\u0240\u0001\u0000\u0000"+
		"\u0000$\u0255\u0001\u0000\u0000\u0000&\u0272\u0001\u0000\u0000\u0000("+
		"\u0274\u0001\u0000\u0000\u0000*\u0277\u0001\u0000\u0000\u0000,\u0287\u0001"+
		"\u0000\u0000\u0000.\u028b\u0001\u0000\u0000\u00000\u0294\u0001\u0000\u0000"+
		"\u00002\u0296\u0001\u0000\u0000\u00004\u02af\u0001\u0000\u0000\u00006"+
		"\u02b2\u0001\u0000\u0000\u00008\u02bb\u0001\u0000\u0000\u0000:\u02c6\u0001"+
		"\u0000\u0000\u0000<\u02c8\u0001\u0000\u0000\u0000>\u02d0\u0001\u0000\u0000"+
		"\u0000@\u02d8\u0001\u0000\u0000\u0000B\u02e0\u0001\u0000\u0000\u0000D"+
		"\u02ed\u0001\u0000\u0000\u0000F\u02ef\u0001\u0000\u0000\u0000H\u02f7\u0001"+
		"\u0000\u0000\u0000J\u02ff\u0001\u0000\u0000\u0000L\u0307\u0001\u0000\u0000"+
		"\u0000N\u030f\u0001\u0000\u0000\u0000P\u0317\u0001\u0000\u0000\u0000R"+
		"\u031f\u0001\u0000\u0000\u0000T\u0327\u0001\u0000\u0000\u0000V\u0335\u0001"+
		"\u0000\u0000\u0000X\u0337\u0001\u0000\u0000\u0000Z\u0339\u0001\u0000\u0000"+
		"\u0000\\\u0341\u0001\u0000\u0000\u0000^\u0350\u0001\u0000\u0000\u0000"+
		"`\u0353\u0001\u0000\u0000\u0000b\u035f\u0001\u0000\u0000\u0000d\u0363"+
		"\u0001\u0000\u0000\u0000f\u036a\u0001\u0000\u0000\u0000h\u037d\u0001\u0000"+
		"\u0000\u0000j\u038a\u0001\u0000\u0000\u0000l\u03ad\u0001\u0000\u0000\u0000"+
		"n\u03b1\u0001\u0000\u0000\u0000p\u03b4\u0001\u0000\u0000\u0000r\u03bb"+
		"\u0001\u0000\u0000\u0000t\u03c6\u0001\u0000\u0000\u0000v\u03ca\u0001\u0000"+
		"\u0000\u0000x\u03cd\u0001\u0000\u0000\u0000z\u03da\u0001\u0000\u0000\u0000"+
		"|\u03e4\u0001\u0000\u0000\u0000~\u03e6\u0001\u0000\u0000\u0000\u0080\u03fd"+
		"\u0001\u0000\u0000\u0000\u0082\u03ff\u0001\u0000\u0000\u0000\u0084\u0407"+
		"\u0001\u0000\u0000\u0000\u0086\u0409\u0001\u0000\u0000\u0000\u0088\u0412"+
		"\u0001\u0000\u0000\u0000\u008a\u0415\u0001\u0000\u0000\u0000\u008c\u041c"+
		"\u0001\u0000\u0000\u0000\u008e\u041e\u0001\u0000\u0000\u0000\u0090\u0420"+
		"\u0001\u0000\u0000\u0000\u0092\u0425\u0001\u0000\u0000\u0000\u0094\u042b"+
		"\u0001\u0000\u0000\u0000\u0096\u042e\u0001\u0000\u0000\u0000\u0098\u0436"+
		"\u0001\u0000\u0000\u0000\u009a\u043d\u0001\u0000\u0000\u0000\u009c\u043f"+
		"\u0001\u0000\u0000\u0000\u009e\u0459\u0001\u0000\u0000\u0000\u00a0\u045f"+
		"\u0001\u0000\u0000\u0000\u00a2\u0461\u0001\u0000\u0000\u0000\u00a4\u047f"+
		"\u0001\u0000\u0000\u0000\u00a6\u0481\u0001\u0000\u0000\u0000\u00a8\u0483"+
		"\u0001\u0000\u0000\u0000\u00aa\u048d\u0001\u0000\u0000\u0000\u00ac\u049a"+
		"\u0001\u0000\u0000\u0000\u00ae\u04a4\u0001\u0000\u0000\u0000\u00b0\u04a8"+
		"\u0001\u0000\u0000\u0000\u00b2\u04ab\u0001\u0000\u0000\u0000\u00b4\u04b3"+
		"\u0001\u0000\u0000\u0000\u00b6\u04b8\u0001\u0000\u0000\u0000\u00b8\u04bc"+
		"\u0001\u0000\u0000\u0000\u00ba\u04be\u0001\u0000\u0000\u0000\u00bc\u04c1"+
		"\u0001\u0000\u0000\u0000\u00be\u04ce\u0001\u0000\u0000\u0000\u00c0\u04d0"+
		"\u0001\u0000\u0000\u0000\u00c2\u04d7\u0001\u0000\u0000\u0000\u00c4\u04db"+
		"\u0001\u0000\u0000\u0000\u00c6\u04e7\u0001\u0000\u0000\u0000\u00c8\u04f1"+
		"\u0001\u0000\u0000\u0000\u00ca\u04f7\u0001\u0000\u0000\u0000\u00cc\u0502"+
		"\u0001\u0000\u0000\u0000\u00ce\u050e\u0001\u0000\u0000\u0000\u00d0\u0510"+
		"\u0001\u0000\u0000\u0000\u00d2\u051b\u0001\u0000\u0000\u0000\u00d4\u0529"+
		"\u0001\u0000\u0000\u0000\u00d6\u052f\u0001\u0000\u0000\u0000\u00d8\u0531"+
		"\u0001\u0000\u0000\u0000\u00da\u0538\u0001\u0000\u0000\u0000\u00dc\u054d"+
		"\u0001\u0000\u0000\u0000\u00de\u054f\u0001\u0000\u0000\u0000\u00e0\u0557"+
		"\u0001\u0000\u0000\u0000\u00e2\u0560\u0001\u0000\u0000\u0000\u00e4\u0568"+
		"\u0001\u0000\u0000\u0000\u00e6\u0576\u0001\u0000\u0000\u0000\u00e8\u0589"+
		"\u0001\u0000\u0000\u0000\u00ea\u059a\u0001\u0000\u0000\u0000\u00ec\u05ad"+
		"\u0001\u0000\u0000\u0000\u00ee\u05b0\u0001\u0000\u0000\u0000\u00f0\u05b4"+
		"\u0001\u0000\u0000\u0000\u00f2\u05b6\u0001\u0000\u0000\u0000\u00f4\u05b9"+
		"\u0001\u0000\u0000\u0000\u00f6\u05bd\u0001\u0000\u0000\u0000\u00f8\u05c9"+
		"\u0001\u0000\u0000\u0000\u00fa\u05ce\u0001\u0000\u0000\u0000\u00fc\u05da"+
		"\u0001\u0000\u0000\u0000\u00fe\u05ed\u0001\u0000\u0000\u0000\u0100\u05f2"+
		"\u0001\u0000\u0000\u0000\u0102\u0601\u0001\u0000\u0000\u0000\u0104\u0608"+
		"\u0001\u0000\u0000\u0000\u0106\u0611\u0001\u0000\u0000\u0000\u0108\u061f"+
		"\u0001\u0000\u0000\u0000\u010a\u0632\u0001\u0000\u0000\u0000\u010c\u0639"+
		"\u0001\u0000\u0000\u0000\u010e\u063e\u0001\u0000\u0000\u0000\u0110\u0642"+
		"\u0001\u0000\u0000\u0000\u0112\u0644\u0001\u0000\u0000\u0000\u0114\u0652"+
		"\u0001\u0000\u0000\u0000\u0116\u065d\u0001\u0000\u0000\u0000\u0118\u065f"+
		"\u0001\u0000\u0000\u0000\u011a\u067d\u0001\u0000\u0000\u0000\u011c\u0680"+
		"\u0001\u0000\u0000\u0000\u011e\u0684\u0001\u0000\u0000\u0000\u0120\u0686"+
		"\u0001\u0000\u0000\u0000\u0122\u068c\u0001\u0000\u0000\u0000\u0124\u06a0"+
		"\u0001\u0000\u0000\u0000\u0126\u06a2\u0001\u0000\u0000\u0000\u0128\u06be"+
		"\u0001\u0000\u0000\u0000\u012a\u06c1\u0001\u0000\u0000\u0000\u012c\u06c5"+
		"\u0001\u0000\u0000\u0000\u012e\u06c7\u0001\u0000\u0000\u0000\u0130\u06ca"+
		"\u0001\u0000\u0000\u0000\u0132\u06cd\u0001\u0000\u0000\u0000\u0134\u06dc"+
		"\u0001\u0000\u0000\u0000\u0136\u06f1\u0001\u0000\u0000\u0000\u0138\u06f3"+
		"\u0001\u0000\u0000\u0000\u013a\u06f5\u0001\u0000\u0000\u0000\u013c\u06f7"+
		"\u0001\u0000\u0000\u0000\u013e\u06fa\u0001\u0000\u0000\u0000\u0140\u06fe"+
		"\u0001\u0000\u0000\u0000\u0142\u0702\u0001\u0000\u0000\u0000\u0144\u0705"+
		"\u0001\u0000\u0000\u0000\u0146\u0713\u0001\u0000\u0000\u0000\u0148\u071e"+
		"\u0001\u0000\u0000\u0000\u014a\u0720\u0001\u0000\u0000\u0000\u014c\u0723"+
		"\u0001\u0000\u0000\u0000\u014e\u0729\u0001\u0000\u0000\u0000\u0150\u072f"+
		"\u0001\u0000\u0000\u0000\u0152\u0739\u0001\u0000\u0000\u0000\u0154\u0744"+
		"\u0001\u0000\u0000\u0000\u0156\u0753\u0001\u0000\u0000\u0000\u0158\u0765"+
		"\u0001\u0000\u0000\u0000\u015a\u0767\u0001\u0000\u0000\u0000\u015c\u0769"+
		"\u0001\u0000\u0000\u0000\u015e\u077a\u0001\u0000\u0000\u0000\u0160\u077c"+
		"\u0001\u0000\u0000\u0000\u0162\u0786\u0001\u0000\u0000\u0000\u0164\u078b"+
		"\u0001\u0000\u0000\u0000\u0166\u0790\u0001\u0000\u0000\u0000\u0168\u0794"+
		"\u0001\u0000\u0000\u0000\u016a\u079c\u0001\u0000\u0000\u0000\u016c\u07a0"+
		"\u0001\u0000\u0000\u0000\u016e\u07af\u0001\u0000\u0000\u0000\u0170\u07b1"+
		"\u0001\u0000\u0000\u0000\u0172\u07b7\u0001\u0000\u0000\u0000\u0174\u07b9"+
		"\u0001\u0000\u0000\u0000\u0176\u07c0\u0001\u0000\u0000\u0000\u0178\u07d4"+
		"\u0001\u0000\u0000\u0000\u017a\u0809\u0001\u0000\u0000\u0000\u017c\u080b"+
		"\u0001\u0000\u0000\u0000\u017e\u0180\u0003x<\u0000\u017f\u017e\u0001\u0000"+
		"\u0000\u0000\u017f\u0180\u0001\u0000\u0000\u0000\u0180\u0181\u0001\u0000"+
		"\u0000\u0000\u0181\u0182\u0005\u0000\u0000\u0001\u0182\u0001\u0001\u0000"+
		"\u0000\u0000\u0183\u0185\u0003\u017c\u00be\u0000\u0184\u0183\u0001\u0000"+
		"\u0000\u0000\u0185\u0186\u0001\u0000\u0000\u0000\u0186\u0184\u0001\u0000"+
		"\u0000\u0000\u0186\u0187\u0001\u0000\u0000\u0000\u0187\u0190\u0001\u0000"+
		"\u0000\u0000\u0188\u0190\u0005E\u0000\u0000\u0189\u018a\u0005U\u0000\u0000"+
		"\u018a\u018b\u0003Z-\u0000\u018b\u018c\u0005V\u0000\u0000\u018c\u0190"+
		"\u0001\u0000\u0000\u0000\u018d\u0190\u0003\u0004\u0002\u0000\u018e\u0190"+
		"\u0003\f\u0006\u0000\u018f\u0184\u0001\u0000\u0000\u0000\u018f\u0188\u0001"+
		"\u0000\u0000\u0000\u018f\u0189\u0001\u0000\u0000\u0000\u018f\u018d\u0001"+
		"\u0000\u0000\u0000\u018f\u018e\u0001\u0000\u0000\u0000\u0190\u0003\u0001"+
		"\u0000\u0000\u0000\u0191\u0194\u0003\u0006\u0003\u0000\u0192\u0194\u0003"+
		"\b\u0004\u0000\u0193\u0191\u0001\u0000\u0000\u0000\u0193\u0192\u0001\u0000"+
		"\u0000\u0000\u0194\u0005\u0001\u0000\u0000\u0000\u0195\u01a0\u0005\u0084"+
		"\u0000\u0000\u0196\u01a0\u0003\u014a\u00a5\u0000\u0197\u01a0\u0003\u013c"+
		"\u009e\u0000\u0198\u01a0\u0003\u014c\u00a6\u0000\u0199\u019c\u0005c\u0000"+
		"\u0000\u019a\u019d\u0003\u0116\u008b\u0000\u019b\u019d\u0003\u00a2Q\u0000"+
		"\u019c\u019a\u0001\u0000\u0000\u0000\u019c\u019b\u0001\u0000\u0000\u0000"+
		"\u019d\u01a0\u0001\u0000\u0000\u0000\u019e\u01a0\u0003\u0158\u00ac\u0000"+
		"\u019f\u0195\u0001\u0000\u0000\u0000\u019f\u0196\u0001\u0000\u0000\u0000"+
		"\u019f\u0197\u0001\u0000\u0000\u0000\u019f\u0198\u0001\u0000\u0000\u0000"+
		"\u019f\u0199\u0001\u0000\u0000\u0000\u019f\u019e\u0001\u0000\u0000\u0000"+
		"\u01a0\u0007\u0001\u0000\u0000\u0000\u01a1\u01a3\u0003\n\u0005\u0000\u01a2"+
		"\u01a4\u0005D\u0000\u0000\u01a3\u01a2\u0001\u0000\u0000\u0000\u01a3\u01a4"+
		"\u0001\u0000\u0000\u0000\u01a4\u01a5\u0001\u0000\u0000\u0000\u01a5\u01a6"+
		"\u0003\u0006\u0003\u0000\u01a6\t\u0001\u0000\u0000\u0000\u01a7\u01ab\u0006"+
		"\u0005\uffff\uffff\u0000\u01a8\u01ac\u0003\u00a0P\u0000\u01a9\u01ac\u0003"+
		"\u00b8\\\u0000\u01aa\u01ac\u0003\u00a2Q\u0000\u01ab\u01a8\u0001\u0000"+
		"\u0000\u0000\u01ab\u01a9\u0001\u0000\u0000\u0000\u01ab\u01aa\u0001\u0000"+
		"\u0000\u0000\u01ab\u01ac\u0001\u0000\u0000\u0000\u01ac\u01ad\u0001\u0000"+
		"\u0000\u0000\u01ad\u01ae\u0005\u007f\u0000\u0000\u01ae\u01ba\u0001\u0000"+
		"\u0000\u0000\u01af\u01b5\n\u0001\u0000\u0000\u01b0\u01b6\u0005\u0084\u0000"+
		"\u0000\u01b1\u01b3\u0005D\u0000\u0000\u01b2\u01b1\u0001\u0000\u0000\u0000"+
		"\u01b2\u01b3\u0001\u0000\u0000\u0000\u01b3\u01b4\u0001\u0000\u0000\u0000"+
		"\u01b4\u01b6\u0003\u0156\u00ab\u0000\u01b5\u01b0\u0001\u0000\u0000\u0000"+
		"\u01b5\u01b2\u0001\u0000\u0000\u0000\u01b6\u01b7\u0001\u0000\u0000\u0000"+
		"\u01b7\u01b9\u0005\u007f\u0000\u0000\u01b8\u01af\u0001\u0000\u0000\u0000"+
		"\u01b9\u01bc\u0001\u0000\u0000\u0000\u01ba\u01b8\u0001\u0000\u0000\u0000"+
		"\u01ba\u01bb\u0001\u0000\u0000\u0000\u01bb\u000b\u0001\u0000\u0000\u0000"+
		"\u01bc\u01ba\u0001\u0000\u0000\u0000\u01bd\u01bf\u0003\u000e\u0007\u0000"+
		"\u01be\u01c0\u0003\u001c\u000e\u0000\u01bf\u01be\u0001\u0000\u0000\u0000"+
		"\u01bf\u01c0\u0001\u0000\u0000\u0000\u01c0\u01c1\u0001\u0000\u0000\u0000"+
		"\u01c1\u01c2\u0003d2\u0000\u01c2\r\u0001\u0000\u0000\u0000\u01c3\u01c5"+
		"\u0005W\u0000\u0000\u01c4\u01c6\u0003\u0010\b\u0000\u01c5\u01c4\u0001"+
		"\u0000\u0000\u0000\u01c5\u01c6\u0001\u0000\u0000\u0000\u01c6\u01c7\u0001"+
		"\u0000\u0000\u0000\u01c7\u01c8\u0005X\u0000\u0000\u01c8\u000f\u0001\u0000"+
		"\u0000\u0000\u01c9\u01d0\u0003\u0014\n\u0000\u01ca\u01cd\u0003\u0012\t"+
		"\u0000\u01cb\u01cc\u0005z\u0000\u0000\u01cc\u01ce\u0003\u0014\n\u0000"+
		"\u01cd\u01cb\u0001\u0000\u0000\u0000\u01cd\u01ce\u0001\u0000\u0000\u0000"+
		"\u01ce\u01d0\u0001\u0000\u0000\u0000\u01cf\u01c9\u0001\u0000\u0000\u0000"+
		"\u01cf\u01ca\u0001\u0000\u0000\u0000\u01d0\u0011\u0001\u0000\u0000\u0000"+
		"\u01d1\u01d2\u0007\u0000\u0000\u0000\u01d2\u0013\u0001\u0000\u0000\u0000"+
		"\u01d3\u01d8\u0003\u0016\u000b\u0000\u01d4\u01d5\u0005z\u0000\u0000\u01d5"+
		"\u01d7\u0003\u0016\u000b\u0000\u01d6\u01d4\u0001\u0000\u0000\u0000\u01d7"+
		"\u01da\u0001\u0000\u0000\u0000\u01d8\u01d6\u0001\u0000\u0000\u0000\u01d8"+
		"\u01d9\u0001\u0000\u0000\u0000\u01d9\u01dc\u0001\u0000\u0000\u0000\u01da"+
		"\u01d8\u0001\u0000\u0000\u0000\u01db\u01dd\u0005\u0083\u0000\u0000\u01dc"+
		"\u01db\u0001\u0000\u0000\u0000\u01dc\u01dd\u0001\u0000\u0000\u0000\u01dd"+
		"\u0015\u0001\u0000\u0000\u0000\u01de\u01e1\u0003\u0018\f\u0000\u01df\u01e1"+
		"\u0003\u001a\r\u0000\u01e0\u01de\u0001\u0000\u0000\u0000\u01e0\u01df\u0001"+
		"\u0000\u0000\u0000\u01e1\u0017\u0001\u0000\u0000\u0000\u01e2\u01e4\u0005"+
		"a\u0000\u0000\u01e3\u01e2\u0001\u0000\u0000\u0000\u01e3\u01e4\u0001\u0000"+
		"\u0000\u0000\u01e4\u01e5\u0001\u0000\u0000\u0000\u01e5\u01e8\u0005\u0084"+
		"\u0000\u0000\u01e6\u01e8\u0005E\u0000\u0000\u01e7\u01e3\u0001\u0000\u0000"+
		"\u0000\u01e7\u01e6\u0001\u0000\u0000\u0000\u01e8\u0019\u0001\u0000\u0000"+
		"\u0000\u01e9\u01eb\u0005a\u0000\u0000\u01ea\u01e9\u0001\u0000\u0000\u0000"+
		"\u01ea\u01eb\u0001\u0000\u0000\u0000\u01eb\u01ec\u0001\u0000\u0000\u0000"+
		"\u01ec\u01ed\u0005\u0084\u0000\u0000\u01ed\u01ee\u0003\u010c\u0086\u0000"+
		"\u01ee\u001b\u0001\u0000\u0000\u0000\u01ef\u01f1\u0005U\u0000\u0000\u01f0"+
		"\u01f2\u0003\u0102\u0081\u0000\u01f1\u01f0\u0001\u0000\u0000\u0000\u01f1"+
		"\u01f2\u0001\u0000\u0000\u0000\u01f2\u01f3\u0001\u0000\u0000\u0000\u01f3"+
		"\u01f5\u0005V\u0000\u0000\u01f4\u01f6\u0005/\u0000\u0000\u01f5\u01f4\u0001"+
		"\u0000\u0000\u0000\u01f5\u01f6\u0001\u0000\u0000\u0000\u01f6\u01f8\u0001"+
		"\u0000\u0000\u0000\u01f7\u01f9\u0003\u0172\u00b9\u0000\u01f8\u01f7\u0001"+
		"\u0000\u0000\u0000\u01f8\u01f9\u0001\u0000\u0000\u0000\u01f9\u01fb\u0001"+
		"\u0000\u0000\u0000\u01fa\u01fc\u0003\u00ccf\u0000\u01fb\u01fa\u0001\u0000"+
		"\u0000\u0000\u01fb\u01fc\u0001\u0000\u0000\u0000\u01fc\u01fe\u0001\u0000"+
		"\u0000\u0000\u01fd\u01ff\u0003\u00eau\u0000\u01fe\u01fd\u0001\u0000\u0000"+
		"\u0000\u01fe\u01ff\u0001\u0000\u0000\u0000\u01ff\u001d\u0001\u0000\u0000"+
		"\u0000\u0200\u0201\u0006\u000f\uffff\uffff\u0000\u0201\u021f\u0003\u0002"+
		"\u0001\u0000\u0202\u0205\u0003\u009eO\u0000\u0203\u0205\u0003\u0160\u00b0"+
		"\u0000\u0204\u0202\u0001\u0000\u0000\u0000\u0204\u0203\u0001\u0000\u0000"+
		"\u0000\u0205\u020c\u0001\u0000\u0000\u0000\u0206\u0208\u0005U\u0000\u0000"+
		"\u0207\u0209\u0003\"\u0011\u0000\u0208\u0207\u0001\u0000\u0000\u0000\u0208"+
		"\u0209\u0001\u0000\u0000\u0000\u0209\u020a\u0001\u0000\u0000\u0000\u020a"+
		"\u020d\u0005V\u0000\u0000\u020b\u020d\u0003\u0114\u008a\u0000\u020c\u0206"+
		"\u0001\u0000\u0000\u0000\u020c\u020b\u0001\u0000\u0000\u0000\u020d\u021f"+
		"\u0001\u0000\u0000\u0000\u020e\u020f\u0007\u0001\u0000\u0000\u020f\u0210"+
		"\u0005f\u0000\u0000\u0210\u0211\u0003\u00f6{\u0000\u0211\u0212\u0005g"+
		"\u0000\u0000\u0212\u0213\u0005U\u0000\u0000\u0213\u0214\u0003Z-\u0000"+
		"\u0214\u0215\u0005V\u0000\u0000\u0215\u021f\u0001\u0000\u0000\u0000\u0216"+
		"\u0217\u0003 \u0010\u0000\u0217\u021a\u0005U\u0000\u0000\u0218\u021b\u0003"+
		"Z-\u0000\u0219\u021b\u0003\u00f6{\u0000\u021a\u0218\u0001\u0000\u0000"+
		"\u0000\u021a\u0219\u0001\u0000\u0000\u0000\u021b\u021c\u0001\u0000\u0000"+
		"\u0000\u021c\u021d\u0005V\u0000\u0000\u021d\u021f\u0001\u0000\u0000\u0000"+
		"\u021e\u0200\u0001\u0000\u0000\u0000\u021e\u0204\u0001\u0000\u0000\u0000"+
		"\u021e\u020e\u0001\u0000\u0000\u0000\u021e\u0216\u0001\u0000\u0000\u0000"+
		"\u021f\u023b\u0001\u0000\u0000\u0000\u0220\u0221\n\u0007\u0000\u0000\u0221"+
		"\u0224\u0005W\u0000\u0000\u0222\u0225\u0003Z-\u0000\u0223\u0225\u0003"+
		"\u0114\u008a\u0000\u0224\u0222\u0001\u0000\u0000\u0000\u0224\u0223\u0001"+
		"\u0000\u0000\u0000\u0225\u0226\u0001\u0000\u0000\u0000\u0226\u0227\u0005"+
		"X\u0000\u0000\u0227\u023a\u0001\u0000\u0000\u0000\u0228\u0229\n\u0006"+
		"\u0000\u0000\u0229\u022b\u0005U\u0000\u0000\u022a\u022c\u0003\"\u0011"+
		"\u0000\u022b\u022a\u0001\u0000\u0000\u0000\u022b\u022c\u0001\u0000\u0000"+
		"\u0000\u022c\u022d\u0001\u0000\u0000\u0000\u022d\u023a\u0005V\u0000\u0000"+
		"\u022e\u022f\n\u0004\u0000\u0000\u022f\u0235\u0007\u0002\u0000\u0000\u0230"+
		"\u0232\u0005D\u0000\u0000\u0231\u0230\u0001\u0000\u0000\u0000\u0231\u0232"+
		"\u0001\u0000\u0000\u0000\u0232\u0233\u0001\u0000\u0000\u0000\u0233\u0236"+
		"\u0003\u0004\u0002\u0000\u0234\u0236\u0003$\u0012\u0000\u0235\u0231\u0001"+
		"\u0000\u0000\u0000\u0235\u0234\u0001\u0000\u0000\u0000\u0236\u023a\u0001"+
		"\u0000\u0000\u0000\u0237\u0238\n\u0003\u0000\u0000\u0238\u023a\u0007\u0003"+
		"\u0000\u0000\u0239\u0220\u0001\u0000\u0000\u0000\u0239\u0228\u0001\u0000"+
		"\u0000\u0000\u0239\u022e\u0001\u0000\u0000\u0000\u0239\u0237\u0001\u0000"+
		"\u0000\u0000\u023a\u023d\u0001\u0000\u0000\u0000\u023b\u0239\u0001\u0000"+
		"\u0000\u0000\u023b\u023c\u0001\u0000\u0000\u0000\u023c\u001f\u0001\u0000"+
		"\u0000\u0000\u023d\u023b\u0001\u0000\u0000\u0000\u023e\u023f\u0005K\u0000"+
		"\u0000\u023f!\u0001\u0000\u0000\u0000\u0240\u0241\u0003\u0112\u0089\u0000"+
		"\u0241#\u0001\u0000\u0000\u0000\u0242\u0244\u0003\n\u0005\u0000\u0243"+
		"\u0242\u0001\u0000\u0000\u0000\u0243\u0244\u0001\u0000\u0000\u0000\u0244"+
		"\u0248\u0001\u0000\u0000\u0000\u0245\u0246\u0003\u00a0P\u0000\u0246\u0247"+
		"\u0005\u007f\u0000\u0000\u0247\u0249\u0001\u0000\u0000\u0000\u0248\u0245"+
		"\u0001\u0000\u0000\u0000\u0248\u0249\u0001\u0000\u0000\u0000\u0249\u024a"+
		"\u0001\u0000\u0000\u0000\u024a\u024b\u0005c\u0000\u0000\u024b\u0256\u0003"+
		"\u00a0P\u0000\u024c\u024d\u0003\n\u0005\u0000\u024d\u024e\u0005D\u0000"+
		"\u0000\u024e\u024f\u0003\u0156\u00ab\u0000\u024f\u0250\u0005\u007f\u0000"+
		"\u0000\u0250\u0251\u0005c\u0000\u0000\u0251\u0252\u0003\u00a0P\u0000\u0252"+
		"\u0256\u0001\u0000\u0000\u0000\u0253\u0254\u0005c\u0000\u0000\u0254\u0256"+
		"\u0003\u00a2Q\u0000\u0255\u0243\u0001\u0000\u0000\u0000\u0255\u024c\u0001"+
		"\u0000\u0000\u0000\u0255\u0253\u0001\u0000\u0000\u0000\u0256%\u0001\u0000"+
		"\u0000\u0000\u0257\u0273\u0003\u001e\u000f\u0000\u0258\u025d\u0005x\u0000"+
		"\u0000\u0259\u025d\u0005y\u0000\u0000\u025a\u025d\u0003(\u0014\u0000\u025b"+
		"\u025d\u0005>\u0000\u0000\u025c\u0258\u0001\u0000\u0000\u0000\u025c\u0259"+
		"\u0001\u0000\u0000\u0000\u025c\u025a\u0001\u0000\u0000\u0000\u025c\u025b"+
		"\u0001\u0000\u0000\u0000\u025d\u025e\u0001\u0000\u0000\u0000\u025e\u0273"+
		"\u0003&\u0013\u0000\u025f\u0268\u0005>\u0000\u0000\u0260\u0261\u0005U"+
		"\u0000\u0000\u0261\u0262\u0003\u00f6{\u0000\u0262\u0263\u0005V\u0000\u0000"+
		"\u0263\u0269\u0001\u0000\u0000\u0000\u0264\u0265\u0005\u0083\u0000\u0000"+
		"\u0265\u0266\u0005U\u0000\u0000\u0266\u0267\u0005\u0084\u0000\u0000\u0267"+
		"\u0269\u0005V\u0000\u0000\u0268\u0260\u0001\u0000\u0000\u0000\u0268\u0264"+
		"\u0001\u0000\u0000\u0000\u0269\u0273\u0001\u0000\u0000\u0000\u026a\u026b"+
		"\u0005\u000b\u0000\u0000\u026b\u026c\u0005U\u0000\u0000\u026c\u026d\u0003"+
		"\u00f6{\u0000\u026d\u026e\u0005V\u0000\u0000\u026e\u0273\u0001\u0000\u0000"+
		"\u0000\u026f\u0273\u00038\u001c\u0000\u0270\u0273\u0003*\u0015\u0000\u0271"+
		"\u0273\u00036\u001b\u0000\u0272\u0257\u0001\u0000\u0000\u0000\u0272\u025c"+
		"\u0001\u0000\u0000\u0000\u0272\u025f\u0001\u0000\u0000\u0000\u0272\u026a"+
		"\u0001\u0000\u0000\u0000\u0272\u026f\u0001\u0000\u0000\u0000\u0272\u0270"+
		"\u0001\u0000\u0000\u0000\u0272\u0271\u0001\u0000\u0000\u0000\u0273\'\u0001"+
		"\u0000\u0000\u0000\u0274\u0275\u0007\u0004\u0000\u0000\u0275)\u0001\u0000"+
		"\u0000\u0000\u0276\u0278\u0005\u007f\u0000\u0000\u0277\u0276\u0001\u0000"+
		"\u0000\u0000\u0277\u0278\u0001\u0000\u0000\u0000\u0278\u0279\u0001\u0000"+
		"\u0000\u0000\u0279\u027b\u00051\u0000\u0000\u027a\u027c\u0003,\u0016\u0000"+
		"\u027b\u027a\u0001\u0000\u0000\u0000\u027b\u027c\u0001\u0000\u0000\u0000"+
		"\u027c\u0282\u0001\u0000\u0000\u0000\u027d\u0283\u0003.\u0017\u0000\u027e"+
		"\u027f\u0005U\u0000\u0000\u027f\u0280\u0003\u00f6{\u0000\u0280\u0281\u0005"+
		"V\u0000\u0000\u0281\u0283\u0001\u0000\u0000\u0000\u0282\u027d\u0001\u0000"+
		"\u0000\u0000\u0282\u027e\u0001\u0000\u0000\u0000\u0283\u0285\u0001\u0000"+
		"\u0000\u0000\u0284\u0286\u00034\u001a\u0000\u0285\u0284\u0001\u0000\u0000"+
		"\u0000\u0285\u0286\u0001\u0000\u0000\u0000\u0286+\u0001\u0000\u0000\u0000"+
		"\u0287\u0288\u0005U\u0000\u0000\u0288\u0289\u0003\"\u0011\u0000\u0289"+
		"\u028a\u0005V\u0000\u0000\u028a-\u0001\u0000\u0000\u0000\u028b\u028d\u0003"+
		"\u0096K\u0000\u028c\u028e\u00030\u0018\u0000\u028d\u028c\u0001\u0000\u0000"+
		"\u0000\u028d\u028e\u0001\u0000\u0000\u0000\u028e/\u0001\u0000\u0000\u0000"+
		"\u028f\u0291\u0003\u00ecv\u0000\u0290\u0292\u00030\u0018\u0000\u0291\u0290"+
		"\u0001\u0000\u0000\u0000\u0291\u0292\u0001\u0000\u0000\u0000\u0292\u0295"+
		"\u0001\u0000\u0000\u0000\u0293\u0295\u00032\u0019\u0000\u0294\u028f\u0001"+
		"\u0000\u0000\u0000\u0294\u0293\u0001\u0000\u0000\u0000\u02951\u0001\u0000"+
		"\u0000\u0000\u0296\u0297\u0006\u0019\uffff\uffff\u0000\u0297\u0298\u0005"+
		"W\u0000\u0000\u0298\u0299\u0003Z-\u0000\u0299\u029b\u0005X\u0000\u0000"+
		"\u029a\u029c\u0003\u00ccf\u0000\u029b\u029a\u0001\u0000\u0000\u0000\u029b"+
		"\u029c\u0001\u0000\u0000\u0000\u029c\u02a6\u0001\u0000\u0000\u0000\u029d"+
		"\u029e\n\u0001\u0000\u0000\u029e\u029f\u0005W\u0000\u0000\u029f\u02a0"+
		"\u0003\\.\u0000\u02a0\u02a2\u0005X\u0000\u0000\u02a1\u02a3\u0003\u00cc"+
		"f\u0000\u02a2\u02a1\u0001\u0000\u0000\u0000\u02a2\u02a3\u0001\u0000\u0000"+
		"\u0000\u02a3\u02a5\u0001\u0000\u0000\u0000\u02a4\u029d\u0001\u0000\u0000"+
		"\u0000\u02a5\u02a8\u0001\u0000\u0000\u0000\u02a6\u02a4\u0001\u0000\u0000"+
		"\u0000\u02a6\u02a7\u0001\u0000\u0000\u0000\u02a73\u0001\u0000\u0000\u0000"+
		"\u02a8\u02a6\u0001\u0000\u0000\u0000\u02a9\u02ab\u0005U\u0000\u0000\u02aa"+
		"\u02ac\u0003\"\u0011\u0000\u02ab\u02aa\u0001\u0000\u0000\u0000\u02ab\u02ac"+
		"\u0001\u0000\u0000\u0000\u02ac\u02ad\u0001\u0000\u0000\u0000\u02ad\u02b0"+
		"\u0005V\u0000\u0000\u02ae\u02b0\u0003\u0114\u008a\u0000\u02af\u02a9\u0001"+
		"\u0000\u0000\u0000\u02af\u02ae\u0001\u0000\u0000\u0000\u02b05\u0001\u0000"+
		"\u0000\u0000\u02b1\u02b3\u0005\u007f\u0000\u0000\u02b2\u02b1\u0001\u0000"+
		"\u0000\u0000\u02b2\u02b3\u0001\u0000\u0000\u0000\u02b3\u02b4\u0001\u0000"+
		"\u0000\u0000\u02b4\u02b7\u0005\u001c\u0000\u0000\u02b5\u02b6\u0005W\u0000"+
		"\u0000\u02b6\u02b8\u0005X\u0000\u0000\u02b7\u02b5\u0001\u0000\u0000\u0000"+
		"\u02b7\u02b8\u0001\u0000\u0000\u0000\u02b8\u02b9\u0001\u0000\u0000\u0000"+
		"\u02b9\u02ba\u0003:\u001d\u0000\u02ba7\u0001\u0000\u0000\u0000\u02bb\u02bc"+
		"\u00052\u0000\u0000\u02bc\u02bd\u0005U\u0000\u0000\u02bd\u02be\u0003Z"+
		"-\u0000\u02be\u02bf\u0005V\u0000\u0000\u02bf9\u0001\u0000\u0000\u0000"+
		"\u02c0\u02c7\u0003&\u0013\u0000\u02c1\u02c2\u0005U\u0000\u0000\u02c2\u02c3"+
		"\u0003\u00f6{\u0000\u02c3\u02c4\u0005V\u0000\u0000\u02c4\u02c5\u0003:"+
		"\u001d\u0000\u02c5\u02c7\u0001\u0000\u0000\u0000\u02c6\u02c0\u0001\u0000"+
		"\u0000\u0000\u02c6\u02c1\u0001\u0000\u0000\u0000\u02c7;\u0001\u0000\u0000"+
		"\u0000\u02c8\u02cd\u0003:\u001d\u0000\u02c9\u02ca\u0007\u0005\u0000\u0000"+
		"\u02ca\u02cc\u0003:\u001d\u0000\u02cb\u02c9\u0001\u0000\u0000\u0000\u02cc"+
		"\u02cf\u0001\u0000\u0000\u0000\u02cd\u02cb\u0001\u0000\u0000\u0000\u02cd"+
		"\u02ce\u0001\u0000\u0000\u0000\u02ce=\u0001\u0000\u0000\u0000\u02cf\u02cd"+
		"\u0001\u0000\u0000\u0000\u02d0\u02d5\u0003<\u001e\u0000\u02d1\u02d2\u0007"+
		"\u0006\u0000\u0000\u02d2\u02d4\u0003<\u001e\u0000\u02d3\u02d1\u0001\u0000"+
		"\u0000\u0000\u02d4\u02d7\u0001\u0000\u0000\u0000\u02d5\u02d3\u0001\u0000"+
		"\u0000\u0000\u02d5\u02d6\u0001\u0000\u0000\u0000\u02d6?\u0001\u0000\u0000"+
		"\u0000\u02d7\u02d5\u0001\u0000\u0000\u0000\u02d8\u02dd\u0003>\u001f\u0000"+
		"\u02d9\u02da\u0007\u0007\u0000\u0000\u02da\u02dc\u0003>\u001f\u0000\u02db"+
		"\u02d9\u0001\u0000\u0000\u0000\u02dc\u02df\u0001\u0000\u0000\u0000\u02dd"+
		"\u02db\u0001\u0000\u0000\u0000\u02dd\u02de\u0001\u0000\u0000\u0000\u02de"+
		"A\u0001\u0000\u0000\u0000\u02df\u02dd\u0001\u0000\u0000\u0000\u02e0\u02e6"+
		"\u0003@ \u0000\u02e1\u02e2\u0003D\"\u0000\u02e2\u02e3\u0003@ \u0000\u02e3"+
		"\u02e5\u0001\u0000\u0000\u0000\u02e4\u02e1\u0001\u0000\u0000\u0000\u02e5"+
		"\u02e8\u0001\u0000\u0000\u0000\u02e6\u02e4\u0001\u0000\u0000\u0000\u02e6"+
		"\u02e7\u0001\u0000\u0000\u0000\u02e7C\u0001\u0000\u0000\u0000\u02e8\u02e6"+
		"\u0001\u0000\u0000\u0000\u02e9\u02ea\u0005g\u0000\u0000\u02ea\u02ee\u0005"+
		"g\u0000\u0000\u02eb\u02ec\u0005f\u0000\u0000\u02ec\u02ee\u0005f\u0000"+
		"\u0000\u02ed\u02e9\u0001\u0000\u0000\u0000\u02ed\u02eb\u0001\u0000\u0000"+
		"\u0000\u02eeE\u0001\u0000\u0000\u0000\u02ef\u02f4\u0003B!\u0000\u02f0"+
		"\u02f1\u0007\b\u0000\u0000\u02f1\u02f3\u0003B!\u0000\u02f2\u02f0\u0001"+
		"\u0000\u0000\u0000\u02f3\u02f6\u0001\u0000\u0000\u0000\u02f4\u02f2\u0001"+
		"\u0000\u0000\u0000\u02f4\u02f5\u0001\u0000\u0000\u0000\u02f5G\u0001\u0000"+
		"\u0000\u0000\u02f6\u02f4\u0001\u0000\u0000\u0000\u02f7\u02fc\u0003F#\u0000"+
		"\u02f8\u02f9\u0007\t\u0000\u0000\u02f9\u02fb\u0003F#\u0000\u02fa\u02f8"+
		"\u0001\u0000\u0000\u0000\u02fb\u02fe\u0001\u0000\u0000\u0000\u02fc\u02fa"+
		"\u0001\u0000\u0000\u0000\u02fc\u02fd\u0001\u0000\u0000\u0000\u02fdI\u0001"+
		"\u0000\u0000\u0000\u02fe\u02fc\u0001\u0000\u0000\u0000\u02ff\u0304\u0003"+
		"H$\u0000\u0300\u0301\u0005a\u0000\u0000\u0301\u0303\u0003H$\u0000\u0302"+
		"\u0300\u0001\u0000\u0000\u0000\u0303\u0306\u0001\u0000\u0000\u0000\u0304"+
		"\u0302\u0001\u0000\u0000\u0000\u0304\u0305\u0001\u0000\u0000\u0000\u0305"+
		"K\u0001\u0000\u0000\u0000\u0306\u0304\u0001\u0000\u0000\u0000\u0307\u030c"+
		"\u0003J%\u0000\u0308\u0309\u0005`\u0000\u0000\u0309\u030b\u0003J%\u0000"+
		"\u030a\u0308\u0001\u0000\u0000\u0000\u030b\u030e\u0001\u0000\u0000\u0000"+
		"\u030c\u030a\u0001\u0000\u0000\u0000\u030c\u030d\u0001\u0000\u0000\u0000"+
		"\u030dM\u0001\u0000\u0000\u0000\u030e\u030c\u0001\u0000\u0000\u0000\u030f"+
		"\u0314\u0003L&\u0000\u0310\u0311\u0005b\u0000\u0000\u0311\u0313\u0003"+
		"L&\u0000\u0312\u0310\u0001\u0000\u0000\u0000\u0313\u0316\u0001\u0000\u0000"+
		"\u0000\u0314\u0312\u0001\u0000\u0000\u0000\u0314\u0315\u0001\u0000\u0000"+
		"\u0000\u0315O\u0001\u0000\u0000\u0000\u0316\u0314\u0001\u0000\u0000\u0000"+
		"\u0317\u031c\u0003N\'\u0000\u0318\u0319\u0005v\u0000\u0000\u0319\u031b"+
		"\u0003N\'\u0000\u031a\u0318\u0001\u0000\u0000\u0000\u031b\u031e\u0001"+
		"\u0000\u0000\u0000\u031c\u031a\u0001\u0000\u0000\u0000\u031c\u031d\u0001"+
		"\u0000\u0000\u0000\u031dQ\u0001\u0000\u0000\u0000\u031e\u031c\u0001\u0000"+
		"\u0000\u0000\u031f\u0324\u0003P(\u0000\u0320\u0321\u0005w\u0000\u0000"+
		"\u0321\u0323\u0003P(\u0000\u0322\u0320\u0001\u0000\u0000\u0000\u0323\u0326"+
		"\u0001\u0000\u0000\u0000\u0324\u0322\u0001\u0000\u0000\u0000\u0324\u0325"+
		"\u0001\u0000\u0000\u0000\u0325S\u0001\u0000\u0000\u0000\u0326\u0324\u0001"+
		"\u0000\u0000\u0000\u0327\u032d\u0003R)\u0000\u0328\u0329\u0005}\u0000"+
		"\u0000\u0329\u032a\u0003Z-\u0000\u032a\u032b\u0005~\u0000\u0000\u032b"+
		"\u032c\u0003V+\u0000\u032c\u032e\u0001\u0000\u0000\u0000\u032d\u0328\u0001"+
		"\u0000\u0000\u0000\u032d\u032e\u0001\u0000\u0000\u0000\u032eU\u0001\u0000"+
		"\u0000\u0000\u032f\u0336\u0003T*\u0000\u0330\u0331\u0003R)\u0000\u0331"+
		"\u0332\u0003X,\u0000\u0332\u0333\u0003\u0110\u0088\u0000\u0333\u0336\u0001"+
		"\u0000\u0000\u0000\u0334\u0336\u0003\u0170\u00b8\u0000\u0335\u032f\u0001"+
		"\u0000\u0000\u0000\u0335\u0330\u0001\u0000\u0000\u0000\u0335\u0334\u0001"+
		"\u0000\u0000\u0000\u0336W\u0001\u0000\u0000\u0000\u0337\u0338\u0007\n"+
		"\u0000\u0000\u0338Y\u0001\u0000\u0000\u0000\u0339\u033e\u0003V+\u0000"+
		"\u033a\u033b\u0005z\u0000\u0000\u033b\u033d\u0003V+\u0000\u033c\u033a"+
		"\u0001\u0000\u0000\u0000\u033d\u0340\u0001\u0000\u0000\u0000\u033e\u033c"+
		"\u0001\u0000\u0000\u0000\u033e\u033f\u0001\u0000\u0000\u0000\u033f[\u0001"+
		"\u0000\u0000\u0000\u0340\u033e\u0001\u0000\u0000\u0000\u0341\u0342\u0003"+
		"T*\u0000\u0342]\u0001\u0000\u0000\u0000\u0343\u0351\u0003`0\u0000\u0344"+
		"\u0351\u0003v;\u0000\u0345\u0347\u0003\u00ccf\u0000\u0346\u0345\u0001"+
		"\u0000\u0000\u0000\u0346\u0347\u0001\u0000\u0000\u0000\u0347\u034e\u0001"+
		"\u0000\u0000\u0000\u0348\u034f\u0003b1\u0000\u0349\u034f\u0003d2\u0000"+
		"\u034a\u034f\u0003h4\u0000\u034b\u034f\u0003l6\u0000\u034c\u034f\u0003"+
		"t:\u0000\u034d\u034f\u0003\u0166\u00b3\u0000\u034e\u0348\u0001\u0000\u0000"+
		"\u0000\u034e\u0349\u0001\u0000\u0000\u0000\u034e\u034a\u0001\u0000\u0000"+
		"\u0000\u034e\u034b\u0001\u0000\u0000\u0000\u034e\u034c\u0001\u0000\u0000"+
		"\u0000\u034e\u034d\u0001\u0000\u0000\u0000\u034f\u0351\u0001\u0000\u0000"+
		"\u0000\u0350\u0343\u0001\u0000\u0000\u0000\u0350\u0344\u0001\u0000\u0000"+
		"\u0000\u0350\u0346\u0001\u0000\u0000\u0000\u0351_\u0001\u0000\u0000\u0000"+
		"\u0352\u0354\u0003\u00ccf\u0000\u0353\u0352\u0001\u0000\u0000\u0000\u0353"+
		"\u0354\u0001\u0000\u0000\u0000\u0354\u0359\u0001\u0000\u0000\u0000\u0355"+
		"\u035a\u0005\u0084\u0000\u0000\u0356\u0357\u0005\u0010\u0000\u0000\u0357"+
		"\u035a\u0003\\.\u0000\u0358\u035a\u0005\u001b\u0000\u0000\u0359\u0355"+
		"\u0001\u0000\u0000\u0000\u0359\u0356\u0001\u0000\u0000\u0000\u0359\u0358"+
		"\u0001\u0000\u0000\u0000\u035a\u035b\u0001\u0000\u0000\u0000\u035b\u035c"+
		"\u0005~\u0000\u0000\u035c\u035d\u0003^/\u0000\u035da\u0001\u0000\u0000"+
		"\u0000\u035e\u0360\u0003Z-\u0000\u035f\u035e\u0001\u0000\u0000\u0000\u035f"+
		"\u0360\u0001\u0000\u0000\u0000\u0360\u0361\u0001\u0000\u0000\u0000\u0361"+
		"\u0362\u0005\u0080\u0000\u0000\u0362c\u0001\u0000\u0000\u0000\u0363\u0365"+
		"\u0005Y\u0000\u0000\u0364\u0366\u0003f3\u0000\u0365\u0364\u0001\u0000"+
		"\u0000\u0000\u0365\u0366\u0001\u0000\u0000\u0000\u0366\u0367\u0001\u0000"+
		"\u0000\u0000\u0367\u0368\u0005Z\u0000\u0000\u0368e\u0001\u0000\u0000\u0000"+
		"\u0369\u036b\u0003^/\u0000\u036a\u0369\u0001\u0000\u0000\u0000\u036b\u036c"+
		"\u0001\u0000\u0000\u0000\u036c\u036a\u0001\u0000\u0000\u0000\u036c\u036d"+
		"\u0001\u0000\u0000\u0000\u036dg\u0001\u0000\u0000\u0000\u036e\u036f\u0005"+
		"+\u0000\u0000\u036f\u0370\u0005U\u0000\u0000\u0370\u0371\u0003j5\u0000"+
		"\u0371\u0372\u0005V\u0000\u0000\u0372\u0375\u0003^/\u0000\u0373\u0374"+
		"\u0005 \u0000\u0000\u0374\u0376\u0003^/\u0000\u0375\u0373\u0001\u0000"+
		"\u0000\u0000\u0375\u0376\u0001\u0000\u0000\u0000\u0376\u037e\u0001\u0000"+
		"\u0000\u0000\u0377\u0378\u0005C\u0000\u0000\u0378\u0379\u0005U\u0000\u0000"+
		"\u0379\u037a\u0003j5\u0000\u037a\u037b\u0005V\u0000\u0000\u037b\u037c"+
		"\u0003^/\u0000\u037c\u037e\u0001\u0000\u0000\u0000\u037d\u036e\u0001\u0000"+
		"\u0000\u0000\u037d\u0377\u0001\u0000\u0000\u0000\u037ei\u0001\u0000\u0000"+
		"\u0000\u037f\u038b\u0003Z-\u0000\u0380\u0382\u0003\u00ccf\u0000\u0381"+
		"\u0380\u0001\u0000\u0000\u0000\u0381\u0382\u0001\u0000\u0000\u0000\u0382"+
		"\u0383\u0001\u0000\u0000\u0000\u0383\u0384\u0003\u008aE\u0000\u0384\u0388"+
		"\u0003\u00e2q\u0000\u0385\u0386\u0005e\u0000\u0000\u0386\u0389\u0003\u0110"+
		"\u0088\u0000\u0387\u0389\u0003\u0114\u008a\u0000\u0388\u0385\u0001\u0000"+
		"\u0000\u0000\u0388\u0387\u0001\u0000\u0000\u0000\u0389\u038b\u0001\u0000"+
		"\u0000\u0000\u038a\u037f\u0001\u0000\u0000\u0000\u038a\u0381\u0001\u0000"+
		"\u0000\u0000\u038bk\u0001\u0000\u0000\u0000\u038c\u038d\u0005T\u0000\u0000"+
		"\u038d\u038e\u0005U\u0000\u0000\u038e\u038f\u0003j5\u0000\u038f\u0390"+
		"\u0005V\u0000\u0000\u0390\u0391\u0003^/\u0000\u0391\u03ae\u0001\u0000"+
		"\u0000\u0000\u0392\u0393\u0005\u001d\u0000\u0000\u0393\u0394\u0003^/\u0000"+
		"\u0394\u0395\u0005T\u0000\u0000\u0395\u0396\u0005U\u0000\u0000\u0396\u0397"+
		"\u0003Z-\u0000\u0397\u0398\u0005V\u0000\u0000\u0398\u0399\u0005\u0080"+
		"\u0000\u0000\u0399\u03ae\u0001\u0000\u0000\u0000\u039a\u039b\u0005(\u0000"+
		"\u0000\u039b\u03a8\u0005U\u0000\u0000\u039c\u039e\u0003n7\u0000\u039d"+
		"\u039f\u0003j5\u0000\u039e\u039d\u0001\u0000\u0000\u0000\u039e\u039f\u0001"+
		"\u0000\u0000\u0000\u039f\u03a0\u0001\u0000\u0000\u0000\u03a0\u03a2\u0005"+
		"\u0080\u0000\u0000\u03a1\u03a3\u0003Z-\u0000\u03a2\u03a1\u0001\u0000\u0000"+
		"\u0000\u03a2\u03a3\u0001\u0000\u0000\u0000\u03a3\u03a9\u0001\u0000\u0000"+
		"\u0000\u03a4\u03a5\u0003p8\u0000\u03a5\u03a6\u0005~\u0000\u0000\u03a6"+
		"\u03a7\u0003r9\u0000\u03a7\u03a9\u0001\u0000\u0000\u0000\u03a8\u039c\u0001"+
		"\u0000\u0000\u0000\u03a8\u03a4\u0001\u0000\u0000\u0000\u03a9\u03aa\u0001"+
		"\u0000\u0000\u0000\u03aa\u03ab\u0005V\u0000\u0000\u03ab\u03ac\u0003^/"+
		"\u0000\u03ac\u03ae\u0001\u0000\u0000\u0000\u03ad\u038c\u0001\u0000\u0000"+
		"\u0000\u03ad\u0392\u0001\u0000\u0000\u0000\u03ad\u039a\u0001\u0000\u0000"+
		"\u0000\u03aem\u0001\u0000\u0000\u0000\u03af\u03b2\u0003b1\u0000\u03b0"+
		"\u03b2\u0003\u0080@\u0000\u03b1\u03af\u0001\u0000\u0000\u0000\u03b1\u03b0"+
		"\u0001\u0000\u0000\u0000\u03b2o\u0001\u0000\u0000\u0000\u03b3\u03b5\u0003"+
		"\u00ccf\u0000\u03b4\u03b3\u0001\u0000\u0000\u0000\u03b4\u03b5\u0001\u0000"+
		"\u0000\u0000\u03b5\u03b6\u0001\u0000\u0000\u0000\u03b6\u03b7\u0003\u008a"+
		"E\u0000\u03b7\u03b8\u0003\u00e2q\u0000\u03b8q\u0001\u0000\u0000\u0000"+
		"\u03b9\u03bc\u0003Z-\u0000\u03ba\u03bc\u0003\u0114\u008a\u0000\u03bb\u03b9"+
		"\u0001\u0000\u0000\u0000\u03bb\u03ba\u0001\u0000\u0000\u0000\u03bcs\u0001"+
		"\u0000\u0000\u0000\u03bd\u03c7\u0005\u000f\u0000\u0000\u03be\u03c7\u0005"+
		"\u0019\u0000\u0000\u03bf\u03c2\u0005;\u0000\u0000\u03c0\u03c3\u0003Z-"+
		"\u0000\u03c1\u03c3\u0003\u0114\u008a\u0000\u03c2\u03c0\u0001\u0000\u0000"+
		"\u0000\u03c2\u03c1\u0001\u0000\u0000\u0000\u03c2\u03c3\u0001\u0000\u0000"+
		"\u0000\u03c3\u03c7\u0001\u0000\u0000\u0000\u03c4\u03c5\u0005*\u0000\u0000"+
		"\u03c5\u03c7\u0005\u0084\u0000\u0000\u03c6\u03bd\u0001\u0000\u0000\u0000"+
		"\u03c6\u03be\u0001\u0000\u0000\u0000\u03c6\u03bf\u0001\u0000\u0000\u0000"+
		"\u03c6\u03c4\u0001\u0000\u0000\u0000\u03c7\u03c8\u0001\u0000\u0000\u0000"+
		"\u03c8\u03c9\u0005\u0080\u0000\u0000\u03c9u\u0001\u0000\u0000\u0000\u03ca"+
		"\u03cb\u0003|>\u0000\u03cbw\u0001\u0000\u0000\u0000\u03cc\u03ce\u0003"+
		"z=\u0000\u03cd\u03cc\u0001\u0000\u0000\u0000\u03ce\u03cf\u0001\u0000\u0000"+
		"\u0000\u03cf\u03cd\u0001\u0000\u0000\u0000\u03cf\u03d0\u0001\u0000\u0000"+
		"\u0000\u03d0y\u0001\u0000\u0000\u0000\u03d1\u03db\u0003|>\u0000\u03d2"+
		"\u03db\u0003\u0108\u0084\u0000\u03d3\u03db\u0003\u014e\u00a7\u0000\u03d4"+
		"\u03db\u0003\u0162\u00b1\u0000\u03d5\u03db\u0003\u0164\u00b2\u0000\u03d6"+
		"\u03db\u0003\u00cae\u0000\u03d7\u03db\u0003\u00bc^\u0000\u03d8\u03db\u0003"+
		"\u0084B\u0000\u03d9\u03db\u0003\u0086C\u0000\u03da\u03d1\u0001\u0000\u0000"+
		"\u0000\u03da\u03d2\u0001\u0000\u0000\u0000\u03da\u03d3\u0001\u0000\u0000"+
		"\u0000\u03da\u03d4\u0001\u0000\u0000\u0000\u03da\u03d5\u0001\u0000\u0000"+
		"\u0000\u03da\u03d6\u0001\u0000\u0000\u0000\u03da\u03d7\u0001\u0000\u0000"+
		"\u0000\u03da\u03d8\u0001\u0000\u0000\u0000\u03da\u03d9\u0001\u0000\u0000"+
		"\u0000\u03db{\u0001\u0000\u0000\u0000\u03dc\u03e5\u0003\u0080@\u0000\u03dd"+
		"\u03e5\u0003\u00c8d\u0000\u03de\u03e5\u0003\u00c0`\u0000\u03df\u03e5\u0003"+
		"\u00c4b\u0000\u03e0\u03e5\u0003\u00c6c\u0000\u03e1\u03e5\u0003\u0082A"+
		"\u0000\u03e2\u03e5\u0003~?\u0000\u03e3\u03e5\u0003\u00acV\u0000\u03e4"+
		"\u03dc\u0001\u0000\u0000\u0000\u03e4\u03dd\u0001\u0000\u0000\u0000\u03e4"+
		"\u03de\u0001\u0000\u0000\u0000\u03e4\u03df\u0001\u0000\u0000\u0000\u03e4"+
		"\u03e0\u0001\u0000\u0000\u0000\u03e4\u03e1\u0001\u0000\u0000\u0000\u03e4"+
		"\u03e2\u0001\u0000\u0000\u0000\u03e4\u03e3\u0001\u0000\u0000\u0000\u03e5"+
		"}\u0001\u0000\u0000\u0000\u03e6\u03e7\u0005O\u0000\u0000\u03e7\u03e9\u0005"+
		"\u0084\u0000\u0000\u03e8\u03ea\u0003\u00ccf\u0000\u03e9\u03e8\u0001\u0000"+
		"\u0000\u0000\u03e9\u03ea\u0001\u0000\u0000\u0000\u03ea\u03eb\u0001\u0000"+
		"\u0000\u0000\u03eb\u03ec\u0005e\u0000\u0000\u03ec\u03ed\u0003\u00f6{\u0000"+
		"\u03ed\u03ee\u0005\u0080\u0000\u0000\u03ee\u007f\u0001\u0000\u0000\u0000"+
		"\u03ef\u03f1\u0003\u008aE\u0000\u03f0\u03ef\u0001\u0000\u0000\u0000\u03f0"+
		"\u03f1\u0001\u0000\u0000\u0000\u03f1\u03f3\u0001\u0000\u0000\u0000\u03f2"+
		"\u03f4\u0003\u00deo\u0000\u03f3\u03f2\u0001\u0000\u0000\u0000\u03f3\u03f4"+
		"\u0001\u0000\u0000\u0000\u03f4\u03f5\u0001\u0000\u0000\u0000\u03f5\u03fe"+
		"\u0005\u0080\u0000\u0000\u03f6\u03f8\u0003\u00ccf\u0000\u03f7\u03f9\u0003"+
		"\u008aE\u0000\u03f8\u03f7\u0001\u0000\u0000\u0000\u03f8\u03f9\u0001\u0000"+
		"\u0000\u0000\u03f9\u03fa\u0001\u0000\u0000\u0000\u03fa\u03fb\u0003\u00de"+
		"o\u0000\u03fb\u03fc\u0005\u0080\u0000\u0000\u03fc\u03fe\u0001\u0000\u0000"+
		"\u0000\u03fd\u03f0\u0001\u0000\u0000\u0000\u03fd\u03f6\u0001\u0000\u0000"+
		"\u0000\u03fe\u0081\u0001\u0000\u0000\u0000\u03ff\u0400\u0005@\u0000\u0000"+
		"\u0400\u0401\u0005U\u0000\u0000\u0401\u0402\u0003\\.\u0000\u0402\u0403"+
		"\u0005z\u0000\u0000\u0403\u0404\u0005\u0004\u0000\u0000\u0404\u0405\u0005"+
		"V\u0000\u0000\u0405\u0406\u0005\u0080\u0000\u0000\u0406\u0083\u0001\u0000"+
		"\u0000\u0000\u0407\u0408\u0005\u0080\u0000\u0000\u0408\u0085\u0001\u0000"+
		"\u0000\u0000\u0409\u040a\u0003\u00ccf\u0000\u040a\u040b\u0005\u0080\u0000"+
		"\u0000\u040b\u0087\u0001\u0000\u0000\u0000\u040c\u0413\u0003\u008cF\u0000"+
		"\u040d\u0413\u0003\u0092I\u0000\u040e\u0413\u0003\u008eG\u0000\u040f\u0413"+
		"\u0005)\u0000\u0000\u0410\u0413\u0005J\u0000\u0000\u0411\u0413\u0005\u0017"+
		"\u0000\u0000\u0412\u040c\u0001\u0000\u0000\u0000\u0412\u040d\u0001\u0000"+
		"\u0000\u0000\u0412\u040e\u0001\u0000\u0000\u0000\u0412\u040f\u0001\u0000"+
		"\u0000\u0000\u0412\u0410\u0001\u0000\u0000\u0000\u0412\u0411\u0001\u0000"+
		"\u0000\u0000\u0413\u0089\u0001\u0000\u0000\u0000\u0414\u0416\u0003\u0088"+
		"D\u0000\u0415\u0414\u0001\u0000\u0000\u0000\u0416\u0417\u0001\u0000\u0000"+
		"\u0000\u0417\u0418\u0001\u0000\u0000\u0000\u0417\u0415\u0001\u0000\u0000"+
		"\u0000\u0418\u041a\u0001\u0000\u0000\u0000\u0419\u041b\u0003\u00ccf\u0000"+
		"\u041a\u0419\u0001\u0000\u0000\u0000\u041a\u041b\u0001\u0000\u0000\u0000"+
		"\u041b\u008b\u0001\u0000\u0000\u0000\u041c\u041d\u0007\u000b\u0000\u0000"+
		"\u041d\u008d\u0001\u0000\u0000\u0000\u041e\u041f\u0007\f\u0000\u0000\u041f"+
		"\u008f\u0001\u0000\u0000\u0000\u0420\u0421\u0005\u0084\u0000\u0000\u0421"+
		"\u0091\u0001\u0000\u0000\u0000\u0422\u0426\u0003\u0094J\u0000\u0423\u0426"+
		"\u0003\u0118\u008c\u0000\u0424\u0426\u0003\u00a8T\u0000\u0425\u0422\u0001"+
		"\u0000\u0000\u0000\u0425\u0423\u0001\u0000\u0000\u0000\u0425\u0424\u0001"+
		"\u0000\u0000\u0000\u0426\u0093\u0001\u0000\u0000\u0000\u0427\u042c\u0003"+
		"\u009eO\u0000\u0428\u042c\u0003\u00a4R\u0000\u0429\u042c\u0003\u0160\u00b0"+
		"\u0000\u042a\u042c\u0003\u00f0x\u0000\u042b\u0427\u0001\u0000\u0000\u0000"+
		"\u042b\u0428\u0001\u0000\u0000\u0000\u042b\u0429\u0001\u0000\u0000\u0000"+
		"\u042b\u042a\u0001\u0000\u0000\u0000\u042c\u0095\u0001\u0000\u0000\u0000"+
		"\u042d\u042f\u0003\u0092I\u0000\u042e\u042d\u0001\u0000\u0000\u0000\u042f"+
		"\u0430\u0001\u0000\u0000\u0000\u0430\u042e\u0001\u0000\u0000\u0000\u0430"+
		"\u0431\u0001\u0000\u0000\u0000\u0431\u0433\u0001\u0000\u0000\u0000\u0432"+
		"\u0434\u0003\u00ccf\u0000\u0433\u0432\u0001\u0000\u0000\u0000\u0433\u0434"+
		"\u0001\u0000\u0000\u0000\u0434\u0097\u0001\u0000\u0000\u0000\u0435\u0437"+
		"\u0003\u0094J\u0000\u0436\u0435\u0001\u0000\u0000\u0000\u0437\u0438\u0001"+
		"\u0000\u0000\u0000\u0438\u0436\u0001\u0000\u0000\u0000\u0438\u0439\u0001"+
		"\u0000\u0000\u0000\u0439\u043b\u0001\u0000\u0000\u0000\u043a\u043c\u0003"+
		"\u00ccf\u0000\u043b\u043a\u0001\u0000\u0000\u0000\u043b\u043c\u0001\u0000"+
		"\u0000\u0000\u043c\u0099\u0001\u0000\u0000\u0000\u043d\u043e\u0007\r\u0000"+
		"\u0000\u043e\u009b\u0001\u0000\u0000\u0000\u043f\u0440\u0007\u000e\u0000"+
		"\u0000\u0440\u009d\u0001\u0000\u0000\u0000\u0441\u0443\u0003\n\u0005\u0000"+
		"\u0442\u0441\u0001\u0000\u0000\u0000\u0442\u0443\u0001\u0000\u0000\u0000"+
		"\u0443\u0444\u0001\u0000\u0000\u0000\u0444\u045a\u0003\u00a0P\u0000\u0445"+
		"\u0446\u0003\n\u0005\u0000\u0446\u0447\u0005D\u0000\u0000\u0447\u0448"+
		"\u0003\u0156\u00ab\u0000\u0448\u045a\u0001\u0000\u0000\u0000\u0449\u045a"+
		"\u0005\u0012\u0000\u0000\u044a\u045a\u0005\u0013\u0000\u0000\u044b\u045a"+
		"\u0005\u0014\u0000\u0000\u044c\u045a\u0005S\u0000\u0000\u044d\u045a\u0005"+
		"\u000e\u0000\u0000\u044e\u045a\u0005<\u0000\u0000\u044f\u045a\u0005-\u0000"+
		"\u0000\u0450\u045a\u0005.\u0000\u0000\u0451\u045a\u0005\'\u0000\u0000"+
		"\u0452\u045a\u0005=\u0000\u0000\u0453\u045a\u0005N\u0000\u0000\u0454\u045a"+
		"\u0005\'\u0000\u0000\u0455\u045a\u0005\u001e\u0000\u0000\u0456\u045a\u0005"+
		"Q\u0000\u0000\u0457\u045a\u0005\r\u0000\u0000\u0458\u045a\u0003\u00a2"+
		"Q\u0000\u0459\u0442\u0001\u0000\u0000\u0000\u0459\u0445\u0001\u0000\u0000"+
		"\u0000\u0459\u0449\u0001\u0000\u0000\u0000\u0459\u044a\u0001\u0000\u0000"+
		"\u0000\u0459\u044b\u0001\u0000\u0000\u0000\u0459\u044c\u0001\u0000\u0000"+
		"\u0000\u0459\u044d\u0001\u0000\u0000\u0000\u0459\u044e\u0001\u0000\u0000"+
		"\u0000\u0459\u044f\u0001\u0000\u0000\u0000\u0459\u0450\u0001\u0000\u0000"+
		"\u0000\u0459\u0451\u0001\u0000\u0000\u0000\u0459\u0452\u0001\u0000\u0000"+
		"\u0000\u0459\u0453\u0001\u0000\u0000\u0000\u0459\u0454\u0001\u0000\u0000"+
		"\u0000\u0459\u0455\u0001\u0000\u0000\u0000\u0459\u0456\u0001\u0000\u0000"+
		"\u0000\u0459\u0457\u0001\u0000\u0000\u0000\u0459\u0458\u0001\u0000\u0000"+
		"\u0000\u045a\u009f\u0001\u0000\u0000\u0000\u045b\u0460\u0003\u0116\u008b"+
		"\u0000\u045c\u0460\u0003\u00a6S\u0000\u045d\u0460\u0003\u0090H\u0000\u045e"+
		"\u0460\u0003\u0156\u00ab\u0000\u045f\u045b\u0001\u0000\u0000\u0000\u045f"+
		"\u045c\u0001\u0000\u0000\u0000\u045f\u045d\u0001\u0000\u0000\u0000\u045f"+
		"\u045e\u0001\u0000\u0000\u0000\u0460\u00a1\u0001\u0000\u0000\u0000\u0461"+
		"\u0462\u0005\u001a\u0000\u0000\u0462\u0465\u0005U\u0000\u0000\u0463\u0466"+
		"\u0003Z-\u0000\u0464\u0466\u0005\r\u0000\u0000\u0465\u0463\u0001\u0000"+
		"\u0000\u0000\u0465\u0464\u0001\u0000\u0000\u0000\u0466\u0467\u0001\u0000"+
		"\u0000\u0000\u0467\u0468\u0005V\u0000\u0000\u0468\u00a3\u0001\u0000\u0000"+
		"\u0000\u0469\u0478\u0003\u0120\u0090\u0000\u046a\u046c\u0003\u00ccf\u0000"+
		"\u046b\u046a\u0001\u0000\u0000\u0000\u046b\u046c\u0001\u0000\u0000\u0000"+
		"\u046c\u046e\u0001\u0000\u0000\u0000\u046d\u046f\u0003\n\u0005\u0000\u046e"+
		"\u046d\u0001\u0000\u0000\u0000\u046e\u046f\u0001\u0000\u0000\u0000\u046f"+
		"\u0470\u0001\u0000\u0000\u0000\u0470\u0479\u0005\u0084\u0000\u0000\u0471"+
		"\u0479\u0003\u0156\u00ab\u0000\u0472\u0474\u0003\n\u0005\u0000\u0473\u0475"+
		"\u0005D\u0000\u0000\u0474\u0473\u0001\u0000\u0000\u0000\u0474\u0475\u0001"+
		"\u0000\u0000\u0000\u0475\u0476\u0001\u0000\u0000\u0000\u0476\u0477\u0003"+
		"\u0156\u00ab\u0000\u0477\u0479\u0001\u0000\u0000\u0000\u0478\u046b\u0001"+
		"\u0000\u0000\u0000\u0478\u0471\u0001\u0000\u0000\u0000\u0478\u0472\u0001"+
		"\u0000\u0000\u0000\u0479\u0480\u0001\u0000\u0000\u0000\u047a\u047c\u0005"+
		"!\u0000\u0000\u047b\u047d\u0003\n\u0005\u0000\u047c\u047b\u0001\u0000"+
		"\u0000\u0000\u047c\u047d\u0001\u0000\u0000\u0000\u047d\u047e\u0001\u0000"+
		"\u0000\u0000\u047e\u0480\u0005\u0084\u0000\u0000\u047f\u0469\u0001\u0000"+
		"\u0000\u0000\u047f\u047a\u0001\u0000\u0000\u0000\u0480\u00a5\u0001\u0000"+
		"\u0000\u0000\u0481\u0482\u0005\u0084\u0000\u0000\u0482\u00a7\u0001\u0000"+
		"\u0000\u0000\u0483\u0484\u0003\u00aaU\u0000\u0484\u0489\u0005Y\u0000\u0000"+
		"\u0485\u0487\u0003\u00b2Y\u0000\u0486\u0488\u0005z\u0000\u0000\u0487\u0486"+
		"\u0001\u0000\u0000\u0000\u0487\u0488\u0001\u0000\u0000\u0000\u0488\u048a"+
		"\u0001\u0000\u0000\u0000\u0489\u0485\u0001\u0000\u0000\u0000\u0489\u048a"+
		"\u0001\u0000\u0000\u0000\u048a\u048b\u0001\u0000\u0000\u0000\u048b\u048c"+
		"\u0005Z\u0000\u0000\u048c\u00a9\u0001\u0000\u0000\u0000\u048d\u048f\u0003"+
		"\u00aeW\u0000\u048e\u0490\u0003\u00ccf\u0000\u048f\u048e\u0001\u0000\u0000"+
		"\u0000\u048f\u0490\u0001\u0000\u0000\u0000\u0490\u0495\u0001\u0000\u0000"+
		"\u0000\u0491\u0493\u0003\n\u0005\u0000\u0492\u0491\u0001\u0000\u0000\u0000"+
		"\u0492\u0493\u0001\u0000\u0000\u0000\u0493\u0494\u0001\u0000\u0000\u0000"+
		"\u0494\u0496\u0005\u0084\u0000\u0000\u0495\u0492\u0001\u0000\u0000\u0000"+
		"\u0495\u0496\u0001\u0000\u0000\u0000\u0496\u0498\u0001\u0000\u0000\u0000"+
		"\u0497\u0499\u0003\u00b0X\u0000\u0498\u0497\u0001\u0000\u0000\u0000\u0498"+
		"\u0499\u0001\u0000\u0000\u0000\u0499\u00ab\u0001\u0000\u0000\u0000\u049a"+
		"\u049c\u0003\u00aeW\u0000\u049b\u049d\u0003\u00ccf\u0000\u049c\u049b\u0001"+
		"\u0000\u0000\u0000\u049c\u049d\u0001\u0000\u0000\u0000\u049d\u049e\u0001"+
		"\u0000\u0000\u0000\u049e\u04a0\u0005\u0084\u0000\u0000\u049f\u04a1\u0003"+
		"\u00b0X\u0000\u04a0\u049f\u0001\u0000\u0000\u0000\u04a0\u04a1\u0001\u0000"+
		"\u0000\u0000\u04a1\u04a2\u0001\u0000\u0000\u0000\u04a2\u04a3\u0005\u0080"+
		"\u0000\u0000\u04a3\u00ad\u0001\u0000\u0000\u0000\u04a4\u04a6\u0005!\u0000"+
		"\u0000\u04a5\u04a7\u0007\u000f\u0000\u0000\u04a6\u04a5\u0001\u0000\u0000"+
		"\u0000\u04a6\u04a7\u0001\u0000\u0000\u0000\u04a7\u00af\u0001\u0000\u0000"+
		"\u0000\u04a8\u04a9\u0005~\u0000\u0000\u04a9\u04aa\u0003\u0096K\u0000\u04aa"+
		"\u00b1\u0001\u0000\u0000\u0000\u04ab\u04b0\u0003\u00b4Z\u0000\u04ac\u04ad"+
		"\u0005z\u0000\u0000\u04ad\u04af\u0003\u00b4Z\u0000\u04ae\u04ac\u0001\u0000"+
		"\u0000\u0000\u04af\u04b2\u0001\u0000\u0000\u0000\u04b0\u04ae\u0001\u0000"+
		"\u0000\u0000\u04b0\u04b1\u0001\u0000\u0000\u0000\u04b1\u00b3\u0001\u0000"+
		"\u0000\u0000\u04b2\u04b0\u0001\u0000\u0000\u0000\u04b3\u04b6\u0003\u00b6"+
		"[\u0000\u04b4\u04b5\u0005e\u0000\u0000\u04b5\u04b7\u0003\\.\u0000\u04b6"+
		"\u04b4\u0001\u0000\u0000\u0000\u04b6\u04b7\u0001\u0000\u0000\u0000\u04b7"+
		"\u00b5\u0001\u0000\u0000\u0000\u04b8\u04b9\u0005\u0084\u0000\u0000\u04b9"+
		"\u00b7\u0001\u0000\u0000\u0000\u04ba\u04bd\u0003\u00ba]\u0000\u04bb\u04bd"+
		"\u0003\u00be_\u0000\u04bc\u04ba\u0001\u0000\u0000\u0000\u04bc\u04bb\u0001"+
		"\u0000\u0000\u0000\u04bd\u00b9\u0001\u0000\u0000\u0000\u04be\u04bf\u0005"+
		"\u0084\u0000\u0000\u04bf\u00bb\u0001\u0000\u0000\u0000\u04c0\u04c2\u0005"+
		",\u0000\u0000\u04c1\u04c0\u0001\u0000\u0000\u0000\u04c1\u04c2\u0001\u0000"+
		"\u0000\u0000\u04c2\u04c3\u0001\u0000\u0000\u0000\u04c3\u04c6\u00050\u0000"+
		"\u0000\u04c4\u04c7\u0005\u0084\u0000\u0000\u04c5\u04c7\u0003\u00ba]\u0000"+
		"\u04c6\u04c4\u0001\u0000\u0000\u0000\u04c6\u04c5\u0001\u0000\u0000\u0000"+
		"\u04c6\u04c7\u0001\u0000\u0000\u0000\u04c7\u04c8\u0001\u0000\u0000\u0000"+
		"\u04c8\u04ca\u0005Y\u0000\u0000\u04c9\u04cb\u0003x<\u0000\u04ca\u04c9"+
		"\u0001\u0000\u0000\u0000\u04ca\u04cb\u0001\u0000\u0000\u0000\u04cb\u04cc"+
		"\u0001\u0000\u0000\u0000\u04cc\u04cd\u0005Z\u0000\u0000\u04cd\u00bd\u0001"+
		"\u0000\u0000\u0000\u04ce\u04cf\u0005\u0084\u0000\u0000\u04cf\u00bf\u0001"+
		"\u0000\u0000\u0000\u04d0\u04d1\u00050\u0000\u0000\u04d1\u04d2\u0005\u0084"+
		"\u0000\u0000\u04d2\u04d3\u0005e\u0000\u0000\u04d3\u04d4\u0003\u00c2a\u0000"+
		"\u04d4\u04d5\u0005\u0080\u0000\u0000\u04d5\u00c1\u0001\u0000\u0000\u0000"+
		"\u04d6\u04d8\u0003\n\u0005\u0000\u04d7\u04d6\u0001\u0000\u0000\u0000\u04d7"+
		"\u04d8\u0001\u0000\u0000\u0000\u04d8\u04d9\u0001\u0000\u0000\u0000\u04d9"+
		"\u04da\u0003\u00b8\\\u0000\u04da\u00c3\u0001\u0000\u0000\u0000\u04db\u04e1"+
		"\u0005O\u0000\u0000\u04dc\u04de\u0005L\u0000\u0000\u04dd\u04dc\u0001\u0000"+
		"\u0000\u0000\u04dd\u04de\u0001\u0000\u0000\u0000\u04de\u04df\u0001\u0000"+
		"\u0000\u0000\u04df\u04e2\u0003\n\u0005\u0000\u04e0\u04e2\u0005\u007f\u0000"+
		"\u0000\u04e1\u04dd\u0001\u0000\u0000\u0000\u04e1\u04e0\u0001\u0000\u0000"+
		"\u0000\u04e2\u04e3\u0001\u0000\u0000\u0000\u04e3\u04e4\u0003\u0006\u0003"+
		"\u0000\u04e4\u04e5\u0005\u0080\u0000\u0000\u04e5\u00c5\u0001\u0000\u0000"+
		"\u0000\u04e6\u04e8\u0003\u00ccf\u0000\u04e7\u04e6\u0001\u0000\u0000\u0000"+
		"\u04e7\u04e8\u0001\u0000\u0000\u0000\u04e8\u04e9\u0001\u0000\u0000\u0000"+
		"\u04e9\u04ea\u0005O\u0000\u0000\u04ea\u04ec\u00050\u0000\u0000\u04eb\u04ed"+
		"\u0003\n\u0005\u0000\u04ec\u04eb\u0001\u0000\u0000\u0000\u04ec\u04ed\u0001"+
		"\u0000\u0000\u0000\u04ed\u04ee\u0001\u0000\u0000\u0000\u04ee\u04ef\u0003"+
		"\u00b8\\\u0000\u04ef\u04f0\u0005\u0080\u0000\u0000\u04f0\u00c7\u0001\u0000"+
		"\u0000\u0000\u04f1\u04f2\u0005\f\u0000\u0000\u04f2\u04f3\u0005U\u0000"+
		"\u0000\u04f3\u04f4\u0005\u0004\u0000\u0000\u04f4\u04f5\u0005V\u0000\u0000"+
		"\u04f5\u04f6\u0005\u0080\u0000\u0000\u04f6\u00c9\u0001\u0000\u0000\u0000"+
		"\u04f7\u04f8\u0005$\u0000\u0000\u04f8\u04ff\u0005\u0004\u0000\u0000\u04f9"+
		"\u04fb\u0005Y\u0000\u0000\u04fa\u04fc\u0003x<\u0000\u04fb\u04fa\u0001"+
		"\u0000\u0000\u0000\u04fb\u04fc\u0001\u0000\u0000\u0000\u04fc\u04fd\u0001"+
		"\u0000\u0000\u0000\u04fd\u0500\u0005Z\u0000\u0000\u04fe\u0500\u0003z="+
		"\u0000\u04ff\u04f9\u0001\u0000\u0000\u0000\u04ff\u04fe\u0001\u0000\u0000"+
		"\u0000\u0500\u00cb\u0001\u0000\u0000\u0000\u0501\u0503\u0003\u00ceg\u0000"+
		"\u0502\u0501\u0001\u0000\u0000\u0000\u0503\u0504\u0001\u0000\u0000\u0000"+
		"\u0504\u0502\u0001\u0000\u0000\u0000\u0504\u0505\u0001\u0000\u0000\u0000"+
		"\u0505\u00cd\u0001\u0000\u0000\u0000\u0506\u0507\u0005W\u0000\u0000\u0507"+
		"\u0509\u0005W\u0000\u0000\u0508\u050a\u0003\u00d2i\u0000\u0509\u0508\u0001"+
		"\u0000\u0000\u0000\u0509\u050a\u0001\u0000\u0000\u0000\u050a\u050b\u0001"+
		"\u0000\u0000\u0000\u050b\u050c\u0005X\u0000\u0000\u050c\u050f\u0005X\u0000"+
		"\u0000\u050d\u050f\u0003\u00d0h\u0000\u050e\u0506\u0001\u0000\u0000\u0000"+
		"\u050e\u050d\u0001\u0000\u0000\u0000\u050f\u00cf\u0001\u0000\u0000\u0000"+
		"\u0510\u0511\u0005\n\u0000\u0000\u0511\u0514\u0005U\u0000\u0000\u0512"+
		"\u0515\u0003\u00f6{\u0000\u0513\u0515\u0003\\.\u0000\u0514\u0512\u0001"+
		"\u0000\u0000\u0000\u0514\u0513\u0001\u0000\u0000\u0000\u0515\u0517\u0001"+
		"\u0000\u0000\u0000\u0516\u0518\u0005\u0083\u0000\u0000\u0517\u0516\u0001"+
		"\u0000\u0000\u0000\u0517\u0518\u0001\u0000\u0000\u0000\u0518\u0519\u0001"+
		"\u0000\u0000\u0000\u0519\u051a\u0005V\u0000\u0000\u051a\u00d1\u0001\u0000"+
		"\u0000\u0000\u051b\u0520\u0003\u00d4j\u0000\u051c\u051d\u0005z\u0000\u0000"+
		"\u051d\u051f\u0003\u00d4j\u0000\u051e\u051c\u0001\u0000\u0000\u0000\u051f"+
		"\u0522\u0001\u0000\u0000\u0000\u0520\u051e\u0001\u0000\u0000\u0000\u0520"+
		"\u0521\u0001\u0000\u0000\u0000\u0521\u0524\u0001\u0000\u0000\u0000\u0522"+
		"\u0520\u0001\u0000\u0000\u0000\u0523\u0525\u0005\u0083\u0000\u0000\u0524"+
		"\u0523\u0001\u0000\u0000\u0000\u0524\u0525\u0001\u0000\u0000\u0000\u0525"+
		"\u00d3\u0001\u0000\u0000\u0000\u0526\u0527\u0003\u00d6k\u0000\u0527\u0528"+
		"\u0005\u007f\u0000\u0000\u0528\u052a\u0001\u0000\u0000\u0000\u0529\u0526"+
		"\u0001\u0000\u0000\u0000\u0529\u052a\u0001\u0000\u0000\u0000\u052a\u052b"+
		"\u0001\u0000\u0000\u0000\u052b\u052d\u0005\u0084\u0000\u0000\u052c\u052e"+
		"\u0003\u00d8l\u0000\u052d\u052c\u0001\u0000\u0000\u0000\u052d\u052e\u0001"+
		"\u0000\u0000\u0000\u052e\u00d5\u0001\u0000\u0000\u0000\u052f\u0530\u0005"+
		"\u0084\u0000\u0000\u0530\u00d7\u0001\u0000\u0000\u0000\u0531\u0533\u0005"+
		"U\u0000\u0000\u0532\u0534\u0003\u00dam\u0000\u0533\u0532\u0001\u0000\u0000"+
		"\u0000\u0533\u0534\u0001\u0000\u0000\u0000\u0534\u0535\u0001\u0000\u0000"+
		"\u0000\u0535\u0536\u0005V\u0000\u0000\u0536\u00d9\u0001\u0000\u0000\u0000"+
		"\u0537\u0539\u0003\u00dcn\u0000\u0538\u0537\u0001\u0000\u0000\u0000\u0539"+
		"\u053a\u0001\u0000\u0000\u0000\u053a\u0538\u0001\u0000\u0000\u0000\u053a"+
		"\u053b\u0001\u0000\u0000\u0000\u053b\u00db\u0001\u0000\u0000\u0000\u053c"+
		"\u053d\u0005U\u0000\u0000\u053d\u053e\u0003\u00dam\u0000\u053e\u053f\u0005"+
		"V\u0000\u0000\u053f\u054e\u0001\u0000\u0000\u0000\u0540\u0541\u0005W\u0000"+
		"\u0000\u0541\u0542\u0003\u00dam\u0000\u0542\u0543\u0005X\u0000\u0000\u0543"+
		"\u054e\u0001\u0000\u0000\u0000\u0544\u0545\u0005Y\u0000\u0000\u0545\u0546"+
		"\u0003\u00dam\u0000\u0546\u0547\u0005Z\u0000\u0000\u0547\u054e\u0001\u0000"+
		"\u0000\u0000\u0548\u054a\b\u0010\u0000\u0000\u0549\u0548\u0001\u0000\u0000"+
		"\u0000\u054a\u054b\u0001\u0000\u0000\u0000\u054b\u0549\u0001\u0000\u0000"+
		"\u0000\u054b\u054c\u0001\u0000\u0000\u0000\u054c\u054e\u0001\u0000\u0000"+
		"\u0000\u054d\u053c\u0001\u0000\u0000\u0000\u054d\u0540\u0001\u0000\u0000"+
		"\u0000\u054d\u0544\u0001\u0000\u0000\u0000\u054d\u0549\u0001\u0000\u0000"+
		"\u0000\u054e\u00dd\u0001\u0000\u0000\u0000\u054f\u0554\u0003\u00e0p\u0000"+
		"\u0550\u0551\u0005z\u0000\u0000\u0551\u0553\u0003\u00e0p\u0000\u0552\u0550"+
		"\u0001\u0000\u0000\u0000\u0553\u0556\u0001\u0000\u0000\u0000\u0554\u0552"+
		"\u0001\u0000\u0000\u0000\u0554\u0555\u0001\u0000\u0000\u0000\u0555\u00df"+
		"\u0001\u0000\u0000\u0000\u0556\u0554\u0001\u0000\u0000\u0000\u0557\u0559"+
		"\u0003\u00e2q\u0000\u0558\u055a\u0003\u010c\u0086\u0000\u0559\u0558\u0001"+
		"\u0000\u0000\u0000\u0559\u055a\u0001\u0000\u0000\u0000\u055a\u00e1\u0001"+
		"\u0000\u0000\u0000\u055b\u0561\u0003\u00e4r\u0000\u055c\u055d\u0003\u00e6"+
		"s\u0000\u055d\u055e\u0003\u00e8t\u0000\u055e\u055f\u0003\u00eau\u0000"+
		"\u055f\u0561\u0001\u0000\u0000\u0000\u0560\u055b\u0001\u0000\u0000\u0000"+
		"\u0560\u055c\u0001\u0000\u0000\u0000\u0561\u00e3\u0001\u0000\u0000\u0000"+
		"\u0562\u0564\u0003\u00ecv\u0000\u0563\u0565\u0005\u0016\u0000\u0000\u0564"+
		"\u0563\u0001\u0000\u0000\u0000\u0564\u0565\u0001\u0000\u0000\u0000\u0565"+
		"\u0567\u0001\u0000\u0000\u0000\u0566\u0562\u0001\u0000\u0000\u0000\u0567"+
		"\u056a\u0001\u0000\u0000\u0000\u0568\u0566\u0001\u0000\u0000\u0000\u0568"+
		"\u0569\u0001\u0000\u0000\u0000\u0569\u056b\u0001\u0000\u0000\u0000\u056a"+
		"\u0568\u0001\u0000\u0000\u0000\u056b\u056c\u0003\u00e6s\u0000\u056c\u00e5"+
		"\u0001\u0000\u0000\u0000\u056d\u056e\u0006s\uffff\uffff\u0000\u056e\u0570"+
		"\u0003\u00f4z\u0000\u056f\u0571\u0003\u00ccf\u0000\u0570\u056f\u0001\u0000"+
		"\u0000\u0000\u0570\u0571\u0001\u0000\u0000\u0000\u0571\u0577\u0001\u0000"+
		"\u0000\u0000\u0572\u0573\u0005U\u0000\u0000\u0573\u0574\u0003\u00e4r\u0000"+
		"\u0574\u0575\u0005V\u0000\u0000\u0575\u0577\u0001\u0000\u0000\u0000\u0576"+
		"\u056d\u0001\u0000\u0000\u0000\u0576\u0572\u0001\u0000\u0000\u0000\u0577"+
		"\u0586\u0001\u0000\u0000\u0000\u0578\u0582\n\u0002\u0000\u0000\u0579\u0583"+
		"\u0003\u00e8t\u0000\u057a\u057c\u0005W\u0000\u0000\u057b\u057d\u0003\\"+
		".\u0000\u057c\u057b\u0001\u0000\u0000\u0000\u057c\u057d\u0001\u0000\u0000"+
		"\u0000\u057d\u057e\u0001\u0000\u0000\u0000\u057e\u0580\u0005X\u0000\u0000"+
		"\u057f\u0581\u0003\u00ccf\u0000\u0580\u057f\u0001\u0000\u0000\u0000\u0580"+
		"\u0581\u0001\u0000\u0000\u0000\u0581\u0583\u0001\u0000\u0000\u0000\u0582"+
		"\u0579\u0001\u0000\u0000\u0000\u0582\u057a\u0001\u0000\u0000\u0000\u0583"+
		"\u0585\u0001\u0000\u0000\u0000\u0584\u0578\u0001\u0000\u0000\u0000\u0585"+
		"\u0588\u0001\u0000\u0000\u0000\u0586\u0584\u0001\u0000\u0000\u0000\u0586"+
		"\u0587\u0001\u0000\u0000\u0000\u0587\u00e7\u0001\u0000\u0000\u0000\u0588"+
		"\u0586\u0001\u0000\u0000\u0000\u0589\u058b\u0005U\u0000\u0000\u058a\u058c"+
		"\u0003\u0102\u0081\u0000\u058b\u058a\u0001\u0000\u0000\u0000\u058b\u058c"+
		"\u0001\u0000\u0000\u0000\u058c\u058d\u0001\u0000\u0000\u0000\u058d\u058f"+
		"\u0005V\u0000\u0000\u058e\u0590\u0003\u00eew\u0000\u058f\u058e\u0001\u0000"+
		"\u0000\u0000\u058f\u0590\u0001\u0000\u0000\u0000\u0590\u0592\u0001\u0000"+
		"\u0000\u0000\u0591\u0593\u0003\u00f2y\u0000\u0592\u0591\u0001\u0000\u0000"+
		"\u0000\u0592\u0593\u0001\u0000\u0000\u0000\u0593\u0595\u0001\u0000\u0000"+
		"\u0000\u0594\u0596\u0003\u0172\u00b9\u0000\u0595\u0594\u0001\u0000\u0000"+
		"\u0000\u0595\u0596\u0001\u0000\u0000\u0000\u0596\u0598\u0001\u0000\u0000"+
		"\u0000\u0597\u0599\u0003\u00ccf\u0000\u0598\u0597\u0001\u0000\u0000\u0000"+
		"\u0598\u0599\u0001\u0000\u0000\u0000\u0599\u00e9\u0001\u0000\u0000\u0000"+
		"\u059a\u059b\u0005|\u0000\u0000\u059b\u059d\u0003\u0098L\u0000\u059c\u059e"+
		"\u0003\u00f8|\u0000\u059d\u059c\u0001\u0000\u0000\u0000\u059d\u059e\u0001"+
		"\u0000\u0000\u0000\u059e\u00eb\u0001\u0000\u0000\u0000\u059f\u05a1\u0007"+
		"\u0011\u0000\u0000\u05a0\u05a2\u0003\u00ccf\u0000\u05a1\u05a0\u0001\u0000"+
		"\u0000\u0000\u05a1\u05a2\u0001\u0000\u0000\u0000\u05a2\u05ae\u0001\u0000"+
		"\u0000\u0000\u05a3\u05a5\u0003\n\u0005\u0000\u05a4\u05a3\u0001\u0000\u0000"+
		"\u0000\u05a4\u05a5\u0001\u0000\u0000\u0000\u05a5\u05a6\u0001\u0000\u0000"+
		"\u0000\u05a6\u05a8\u0005]\u0000\u0000\u05a7\u05a9\u0003\u00ccf\u0000\u05a8"+
		"\u05a7\u0001\u0000\u0000\u0000\u05a8\u05a9\u0001\u0000\u0000\u0000\u05a9"+
		"\u05ab\u0001\u0000\u0000\u0000\u05aa\u05ac\u0003\u00eew\u0000\u05ab\u05aa"+
		"\u0001\u0000\u0000\u0000\u05ab\u05ac\u0001\u0000\u0000\u0000\u05ac\u05ae"+
		"\u0001\u0000\u0000\u0000\u05ad\u059f\u0001\u0000\u0000\u0000\u05ad\u05a4"+
		"\u0001\u0000\u0000\u0000\u05ae\u00ed\u0001\u0000\u0000\u0000\u05af\u05b1"+
		"\u0003\u00f0x\u0000\u05b0\u05af\u0001\u0000\u0000\u0000\u05b1\u05b2\u0001"+
		"\u0000\u0000\u0000\u05b2\u05b0\u0001\u0000\u0000\u0000\u05b2\u05b3\u0001"+
		"\u0000\u0000\u0000\u05b3\u00ef\u0001\u0000\u0000\u0000\u05b4\u05b5\u0007"+
		"\u0012\u0000\u0000\u05b5\u00f1\u0001\u0000\u0000\u0000\u05b6\u05b7\u0007"+
		"\u0011\u0000\u0000\u05b7\u00f3\u0001\u0000\u0000\u0000\u05b8\u05ba\u0005"+
		"\u0083\u0000\u0000\u05b9\u05b8\u0001\u0000\u0000\u0000\u05b9\u05ba\u0001"+
		"\u0000\u0000\u0000\u05ba\u05bb\u0001\u0000\u0000\u0000\u05bb\u05bc\u0003"+
		"\u0004\u0002\u0000\u05bc\u00f5\u0001\u0000\u0000\u0000\u05bd\u05bf\u0003"+
		"\u0096K\u0000\u05be\u05c0\u0003\u00f8|\u0000\u05bf\u05be\u0001\u0000\u0000"+
		"\u0000\u05bf\u05c0\u0001\u0000\u0000\u0000\u05c0\u00f7\u0001\u0000\u0000"+
		"\u0000\u05c1\u05ca\u0003\u00fa}\u0000\u05c2\u05c4\u0003\u00fc~\u0000\u05c3"+
		"\u05c2\u0001\u0000\u0000\u0000\u05c3\u05c4\u0001\u0000\u0000\u0000\u05c4"+
		"\u05c5\u0001\u0000\u0000\u0000\u05c5\u05c6\u0003\u00e8t\u0000\u05c6\u05c7"+
		"\u0003\u00eau\u0000\u05c7\u05ca\u0001\u0000\u0000\u0000\u05c8\u05ca\u0003"+
		"\u00fe\u007f\u0000\u05c9\u05c1\u0001\u0000\u0000\u0000\u05c9\u05c3\u0001"+
		"\u0000\u0000\u0000\u05c9\u05c8\u0001\u0000\u0000\u0000\u05ca\u00f9\u0001"+
		"\u0000\u0000\u0000\u05cb\u05cd\u0003\u00ecv\u0000\u05cc\u05cb\u0001\u0000"+
		"\u0000\u0000\u05cd\u05d0\u0001\u0000\u0000\u0000\u05ce\u05cc\u0001\u0000"+
		"\u0000\u0000\u05ce\u05cf\u0001\u0000\u0000\u0000\u05cf\u05d3\u0001\u0000"+
		"\u0000\u0000\u05d0\u05ce\u0001\u0000\u0000\u0000\u05d1\u05d4\u0003\u00fc"+
		"~\u0000\u05d2\u05d4\u0003\u00ecv\u0000\u05d3\u05d1\u0001\u0000\u0000\u0000"+
		"\u05d3\u05d2\u0001\u0000\u0000\u0000\u05d4\u00fb\u0001\u0000\u0000\u0000"+
		"\u05d5\u05db\u0003\u00e8t\u0000\u05d6\u05d7\u0005U\u0000\u0000\u05d7\u05d8"+
		"\u0003\u00fa}\u0000\u05d8\u05d9\u0005V\u0000\u0000\u05d9\u05db\u0001\u0000"+
		"\u0000\u0000\u05da\u05d5\u0001\u0000\u0000\u0000\u05da\u05d6\u0001\u0000"+
		"\u0000\u0000\u05db\u05e7\u0001\u0000\u0000\u0000\u05dc\u05e6\u0003\u00e8"+
		"t\u0000\u05dd\u05df\u0005W\u0000\u0000\u05de\u05e0\u0003\\.\u0000\u05df"+
		"\u05de\u0001\u0000\u0000\u0000\u05df\u05e0\u0001\u0000\u0000\u0000\u05e0"+
		"\u05e1\u0001\u0000\u0000\u0000\u05e1\u05e3\u0005X\u0000\u0000\u05e2\u05e4"+
		"\u0003\u00ccf\u0000\u05e3\u05e2\u0001\u0000\u0000\u0000\u05e3\u05e4\u0001"+
		"\u0000\u0000\u0000\u05e4\u05e6\u0001\u0000\u0000\u0000\u05e5\u05dc\u0001"+
		"\u0000\u0000\u0000\u05e5\u05dd\u0001\u0000\u0000\u0000\u05e6\u05e9\u0001"+
		"\u0000\u0000\u0000\u05e7\u05e5\u0001\u0000\u0000\u0000\u05e7\u05e8\u0001"+
		"\u0000\u0000\u0000\u05e8\u00fd\u0001\u0000\u0000\u0000\u05e9\u05e7\u0001"+
		"\u0000\u0000\u0000\u05ea\u05ec\u0003\u00ecv\u0000\u05eb\u05ea\u0001\u0000"+
		"\u0000\u0000\u05ec\u05ef\u0001\u0000\u0000\u0000\u05ed\u05eb\u0001\u0000"+
		"\u0000\u0000\u05ed\u05ee\u0001\u0000\u0000\u0000\u05ee\u05f0\u0001\u0000"+
		"\u0000\u0000\u05ef\u05ed\u0001\u0000\u0000\u0000\u05f0\u05f1\u0003\u0100"+
		"\u0080\u0000\u05f1\u00ff\u0001\u0000\u0000\u0000\u05f2\u05fe\u0005\u0083"+
		"\u0000\u0000\u05f3\u05fd\u0003\u00e8t\u0000\u05f4\u05f6\u0005W\u0000\u0000"+
		"\u05f5\u05f7\u0003\\.\u0000\u05f6\u05f5\u0001\u0000\u0000\u0000\u05f6"+
		"\u05f7\u0001\u0000\u0000\u0000\u05f7\u05f8\u0001\u0000\u0000\u0000\u05f8"+
		"\u05fa\u0005X\u0000\u0000\u05f9\u05fb\u0003\u00ccf\u0000\u05fa\u05f9\u0001"+
		"\u0000\u0000\u0000\u05fa\u05fb\u0001\u0000\u0000\u0000\u05fb\u05fd\u0001"+
		"\u0000\u0000\u0000\u05fc\u05f3\u0001\u0000\u0000\u0000\u05fc\u05f4\u0001"+
		"\u0000\u0000\u0000\u05fd\u0600\u0001\u0000\u0000\u0000\u05fe\u05fc\u0001"+
		"\u0000\u0000\u0000\u05fe\u05ff\u0001\u0000\u0000\u0000\u05ff\u0101\u0001"+
		"\u0000\u0000\u0000\u0600\u05fe\u0001\u0000\u0000\u0000\u0601\u0606\u0003"+
		"\u0104\u0082\u0000\u0602\u0604\u0005z\u0000\u0000\u0603\u0602\u0001\u0000"+
		"\u0000\u0000\u0603\u0604\u0001\u0000\u0000\u0000\u0604\u0605\u0001\u0000"+
		"\u0000\u0000\u0605\u0607\u0005\u0083\u0000\u0000\u0606\u0603\u0001\u0000"+
		"\u0000\u0000\u0606\u0607\u0001\u0000\u0000\u0000\u0607\u0103\u0001\u0000"+
		"\u0000\u0000\u0608\u060d\u0003\u0106\u0083\u0000\u0609\u060a\u0005z\u0000"+
		"\u0000\u060a\u060c\u0003\u0106\u0083\u0000\u060b\u0609\u0001\u0000\u0000"+
		"\u0000\u060c\u060f\u0001\u0000\u0000\u0000\u060d\u060b\u0001\u0000\u0000"+
		"\u0000\u060d\u060e\u0001\u0000\u0000\u0000\u060e\u0105\u0001\u0000\u0000"+
		"\u0000\u060f\u060d\u0001\u0000\u0000\u0000\u0610\u0612\u0003\u00ccf\u0000"+
		"\u0611\u0610\u0001\u0000\u0000\u0000\u0611\u0612\u0001\u0000\u0000\u0000"+
		"\u0612\u0613\u0001\u0000\u0000\u0000\u0613\u0618\u0003\u008aE\u0000\u0614"+
		"\u0619\u0003\u00e2q\u0000\u0615\u0617\u0003\u00f8|\u0000\u0616\u0615\u0001"+
		"\u0000\u0000\u0000\u0616\u0617\u0001\u0000\u0000\u0000\u0617\u0619\u0001"+
		"\u0000\u0000\u0000\u0618\u0614\u0001\u0000\u0000\u0000\u0618\u0616\u0001"+
		"\u0000\u0000\u0000\u0619\u061c\u0001\u0000\u0000\u0000\u061a\u061b\u0005"+
		"e\u0000\u0000\u061b\u061d\u0003\u0110\u0088\u0000\u061c\u061a\u0001\u0000"+
		"\u0000\u0000\u061c\u061d\u0001\u0000\u0000\u0000\u061d\u0107\u0001\u0000"+
		"\u0000\u0000\u061e\u0620\u0003\u00ccf\u0000\u061f\u061e\u0001\u0000\u0000"+
		"\u0000\u061f\u0620\u0001\u0000\u0000\u0000\u0620\u0622\u0001\u0000\u0000"+
		"\u0000\u0621\u0623\u0003\u008aE\u0000\u0622\u0621\u0001\u0000\u0000\u0000"+
		"\u0622\u0623\u0001\u0000\u0000\u0000\u0623\u0624\u0001\u0000\u0000\u0000"+
		"\u0624\u0626\u0003\u00e2q\u0000\u0625\u0627\u0003\u012a\u0095\u0000\u0626"+
		"\u0625\u0001\u0000\u0000\u0000\u0626\u0627\u0001\u0000\u0000\u0000\u0627"+
		"\u0628\u0001\u0000\u0000\u0000\u0628\u0629\u0003\u010a\u0085\u0000\u0629"+
		"\u0109\u0001\u0000\u0000\u0000\u062a\u062c\u0003\u0142\u00a1\u0000\u062b"+
		"\u062a\u0001\u0000\u0000\u0000\u062b\u062c\u0001\u0000\u0000\u0000\u062c"+
		"\u062d\u0001\u0000\u0000\u0000\u062d\u0633\u0003d2\u0000\u062e\u0633\u0003"+
		"\u0168\u00b4\u0000\u062f\u0630\u0005e\u0000\u0000\u0630\u0631\u0007\u0013"+
		"\u0000\u0000\u0631\u0633\u0005\u0080\u0000\u0000\u0632\u062b\u0001\u0000"+
		"\u0000\u0000\u0632\u062e\u0001\u0000\u0000\u0000\u0632\u062f\u0001\u0000"+
		"\u0000\u0000\u0633\u010b\u0001\u0000\u0000\u0000\u0634\u063a\u0003\u010e"+
		"\u0087\u0000\u0635\u0636\u0005U\u0000\u0000\u0636\u0637\u0003\"\u0011"+
		"\u0000\u0637\u0638\u0005V\u0000\u0000\u0638\u063a\u0001\u0000\u0000\u0000"+
		"\u0639\u0634\u0001\u0000\u0000\u0000\u0639\u0635\u0001\u0000\u0000\u0000"+
		"\u063a\u010d\u0001\u0000\u0000\u0000\u063b\u063c\u0005e\u0000\u0000\u063c"+
		"\u063f\u0003\u0110\u0088\u0000\u063d\u063f\u0003\u0114\u008a\u0000\u063e"+
		"\u063b\u0001\u0000\u0000\u0000\u063e\u063d\u0001\u0000\u0000\u0000\u063f"+
		"\u010f\u0001\u0000\u0000\u0000\u0640\u0643\u0003V+\u0000\u0641\u0643\u0003"+
		"\u0114\u008a\u0000\u0642\u0640\u0001\u0000\u0000\u0000\u0642\u0641\u0001"+
		"\u0000\u0000\u0000\u0643\u0111\u0001\u0000\u0000\u0000\u0644\u0646\u0003"+
		"\u0110\u0088\u0000\u0645\u0647\u0005\u0083\u0000\u0000\u0646\u0645\u0001"+
		"\u0000\u0000\u0000\u0646\u0647\u0001\u0000\u0000\u0000\u0647\u064f\u0001"+
		"\u0000\u0000\u0000\u0648\u0649\u0005z\u0000\u0000\u0649\u064b\u0003\u0110"+
		"\u0088\u0000\u064a\u064c\u0005\u0083\u0000\u0000\u064b\u064a\u0001\u0000"+
		"\u0000\u0000\u064b\u064c\u0001\u0000\u0000\u0000\u064c\u064e\u0001\u0000"+
		"\u0000\u0000\u064d\u0648\u0001\u0000\u0000\u0000\u064e\u0651\u0001\u0000"+
		"\u0000\u0000\u064f\u064d\u0001\u0000\u0000\u0000\u064f\u0650\u0001\u0000"+
		"\u0000\u0000\u0650\u0113\u0001\u0000\u0000\u0000\u0651\u064f\u0001\u0000"+
		"\u0000\u0000\u0652\u0657\u0005Y\u0000\u0000\u0653\u0655\u0003\u0112\u0089"+
		"\u0000\u0654\u0656\u0005z\u0000\u0000\u0655\u0654\u0001\u0000\u0000\u0000"+
		"\u0655\u0656\u0001\u0000\u0000\u0000\u0656\u0658\u0001\u0000\u0000\u0000"+
		"\u0657\u0653\u0001\u0000\u0000\u0000\u0657\u0658\u0001\u0000\u0000\u0000"+
		"\u0658\u0659\u0001\u0000\u0000\u0000\u0659\u065a\u0005Z\u0000\u0000\u065a"+
		"\u0115\u0001\u0000\u0000\u0000\u065b\u065e\u0005\u0084\u0000\u0000\u065c"+
		"\u065e\u0003\u0156\u00ab\u0000\u065d\u065b\u0001\u0000\u0000\u0000\u065d"+
		"\u065c\u0001\u0000\u0000\u0000\u065e\u0117\u0001\u0000\u0000\u0000\u065f"+
		"\u0660\u0003\u011a\u008d\u0000\u0660\u0662\u0005Y\u0000\u0000\u0661\u0663"+
		"\u0003\u0122\u0091\u0000\u0662\u0661\u0001\u0000\u0000\u0000\u0662\u0663"+
		"\u0001\u0000\u0000\u0000\u0663\u0664\u0001\u0000\u0000\u0000\u0664\u0665"+
		"\u0005Z\u0000\u0000\u0665\u0119\u0001\u0000\u0000\u0000\u0666\u0668\u0003"+
		"\u0120\u0090\u0000\u0667\u0669\u0003\u00ccf\u0000\u0668\u0667\u0001\u0000"+
		"\u0000\u0000\u0668\u0669\u0001\u0000\u0000\u0000\u0669\u066e\u0001\u0000"+
		"\u0000\u0000\u066a\u066c\u0003\u011c\u008e\u0000\u066b\u066d\u0003\u011e"+
		"\u008f\u0000\u066c\u066b\u0001\u0000\u0000\u0000\u066c\u066d\u0001\u0000"+
		"\u0000\u0000\u066d\u066f\u0001\u0000\u0000\u0000\u066e\u066a\u0001\u0000"+
		"\u0000\u0000\u066e\u066f\u0001\u0000\u0000\u0000\u066f\u0671\u0001\u0000"+
		"\u0000\u0000\u0670\u0672\u0003\u0130\u0098\u0000\u0671\u0670\u0001\u0000"+
		"\u0000\u0000\u0671\u0672\u0001\u0000\u0000\u0000\u0672\u067e\u0001\u0000"+
		"\u0000\u0000\u0673\u0675\u0005M\u0000\u0000\u0674\u0676\u0003\u00ccf\u0000"+
		"\u0675\u0674\u0001\u0000\u0000\u0000\u0675\u0676\u0001\u0000\u0000\u0000"+
		"\u0676\u067b\u0001\u0000\u0000\u0000\u0677\u0679\u0003\u011c\u008e\u0000"+
		"\u0678\u067a\u0003\u011e\u008f\u0000\u0679\u0678\u0001\u0000\u0000\u0000"+
		"\u0679\u067a\u0001\u0000\u0000\u0000\u067a\u067c\u0001\u0000\u0000\u0000"+
		"\u067b\u0677\u0001\u0000\u0000\u0000\u067b\u067c\u0001\u0000\u0000\u0000"+
		"\u067c\u067e\u0001\u0000\u0000\u0000\u067d\u0666\u0001\u0000\u0000\u0000"+
		"\u067d\u0673\u0001\u0000\u0000\u0000\u067e\u011b\u0001\u0000\u0000\u0000"+
		"\u067f\u0681\u0003\n\u0005\u0000\u0680\u067f\u0001\u0000\u0000\u0000\u0680"+
		"\u0681\u0001\u0000\u0000\u0000\u0681\u0682\u0001\u0000\u0000\u0000\u0682"+
		"\u0683\u0003\u0116\u008b\u0000\u0683\u011d\u0001\u0000\u0000\u0000\u0684"+
		"\u0685\u0005&\u0000\u0000\u0685\u011f\u0001\u0000\u0000\u0000\u0686\u0687"+
		"\u0007\u000f\u0000\u0000\u0687\u0121\u0001\u0000\u0000\u0000\u0688\u068d"+
		"\u0003\u0124\u0092\u0000\u0689\u068a\u0003\u013a\u009d\u0000\u068a\u068b"+
		"\u0005~\u0000\u0000\u068b\u068d\u0001\u0000\u0000\u0000\u068c\u0688\u0001"+
		"\u0000\u0000\u0000\u068c\u0689\u0001\u0000\u0000\u0000\u068d\u068e\u0001"+
		"\u0000\u0000\u0000\u068e\u068c\u0001\u0000\u0000\u0000\u068e\u068f\u0001"+
		"\u0000\u0000\u0000\u068f\u0123\u0001\u0000\u0000\u0000\u0690\u0692\u0003"+
		"\u00ccf\u0000\u0691\u0690\u0001\u0000\u0000\u0000\u0691\u0692\u0001\u0000"+
		"\u0000\u0000\u0692\u0694\u0001\u0000\u0000\u0000\u0693\u0695\u0003\u008a"+
		"E\u0000\u0694\u0693\u0001\u0000\u0000\u0000\u0694\u0695\u0001\u0000\u0000"+
		"\u0000\u0695\u0697\u0001\u0000\u0000\u0000\u0696\u0698\u0003\u0126\u0093"+
		"\u0000\u0697\u0696\u0001\u0000\u0000\u0000\u0697\u0698\u0001\u0000\u0000"+
		"\u0000\u0698\u0699\u0001\u0000\u0000\u0000\u0699\u06a1\u0005\u0080\u0000"+
		"\u0000\u069a\u06a1\u0003\u0108\u0084\u0000\u069b\u06a1\u0003\u00c4b\u0000"+
		"\u069c\u06a1\u0003\u0082A\u0000\u069d\u06a1\u0003\u014e\u00a7\u0000\u069e"+
		"\u06a1\u0003~?\u0000\u069f\u06a1\u0003\u0084B\u0000\u06a0\u0691\u0001"+
		"\u0000\u0000\u0000\u06a0\u069a\u0001\u0000\u0000\u0000\u06a0\u069b\u0001"+
		"\u0000\u0000\u0000\u06a0\u069c\u0001\u0000\u0000\u0000\u06a0\u069d\u0001"+
		"\u0000\u0000\u0000\u06a0\u069e\u0001\u0000\u0000\u0000\u06a0\u069f\u0001"+
		"\u0000\u0000\u0000\u06a1\u0125\u0001\u0000\u0000\u0000\u06a2\u06a7\u0003"+
		"\u0128\u0094\u0000\u06a3\u06a4\u0005z\u0000\u0000\u06a4\u06a6\u0003\u0128"+
		"\u0094\u0000\u06a5\u06a3\u0001\u0000\u0000\u0000\u06a6\u06a9\u0001\u0000"+
		"\u0000\u0000\u06a7\u06a5\u0001\u0000\u0000\u0000\u06a7\u06a8\u0001\u0000"+
		"\u0000\u0000\u06a8\u0127\u0001\u0000\u0000\u0000\u06a9\u06a7\u0001\u0000"+
		"\u0000\u0000\u06aa\u06b3\u0003\u00e2q\u0000\u06ab\u06b4\u0003\u012a\u0095"+
		"\u0000\u06ac\u06ad\u0004\u0094\u0007\u0000\u06ad\u06b4\u0003\u012e\u0097"+
		"\u0000\u06ae\u06af\u0004\u0094\b\u0000\u06af\u06b0\u0003\u012a\u0095\u0000"+
		"\u06b0\u06b1\u0003\u012e\u0097\u0000\u06b1\u06b4\u0001\u0000\u0000\u0000"+
		"\u06b2\u06b4\u0003\u010e\u0087\u0000\u06b3\u06ab\u0001\u0000\u0000\u0000"+
		"\u06b3\u06ac\u0001\u0000\u0000\u0000\u06b3\u06ae\u0001\u0000\u0000\u0000"+
		"\u06b3\u06b2\u0001\u0000\u0000\u0000\u06b4\u06bf\u0001\u0000\u0000\u0000"+
		"\u06b5\u06bf\u0003\u00e2q\u0000\u06b6\u06b8\u0005\u0084\u0000\u0000\u06b7"+
		"\u06b6\u0001\u0000\u0000\u0000\u06b7\u06b8\u0001\u0000\u0000\u0000\u06b8"+
		"\u06ba\u0001\u0000\u0000\u0000\u06b9\u06bb\u0003\u00ccf\u0000\u06ba\u06b9"+
		"\u0001\u0000\u0000\u0000\u06ba\u06bb\u0001\u0000\u0000\u0000\u06bb\u06bc"+
		"\u0001\u0000\u0000\u0000\u06bc\u06bd\u0005~\u0000\u0000\u06bd\u06bf\u0003"+
		"\\.\u0000\u06be\u06aa\u0001\u0000\u0000\u0000\u06be\u06b5\u0001\u0000"+
		"\u0000\u0000\u06be\u06b7\u0001\u0000\u0000\u0000\u06bf\u0129\u0001\u0000"+
		"\u0000\u0000\u06c0\u06c2\u0003\u012c\u0096\u0000\u06c1\u06c0\u0001\u0000"+
		"\u0000\u0000\u06c2\u06c3\u0001\u0000\u0000\u0000\u06c3\u06c1\u0001\u0000"+
		"\u0000\u0000\u06c3\u06c4\u0001\u0000\u0000\u0000\u06c4\u012b\u0001\u0000"+
		"\u0000\u0000\u06c5\u06c6\u0007\u0014\u0000\u0000\u06c6\u012d\u0001\u0000"+
		"\u0000\u0000\u06c7\u06c8\u0005e\u0000\u0000\u06c8\u06c9\u0005\u0001\u0000"+
		"\u0000\u06c9\u012f\u0001\u0000\u0000\u0000\u06ca\u06cb\u0005~\u0000\u0000"+
		"\u06cb\u06cc\u0003\u0132\u0099\u0000\u06cc\u0131\u0001\u0000\u0000\u0000"+
		"\u06cd\u06cf\u0003\u0134\u009a\u0000\u06ce\u06d0\u0005\u0083\u0000\u0000"+
		"\u06cf\u06ce\u0001\u0000\u0000\u0000\u06cf\u06d0\u0001\u0000\u0000\u0000"+
		"\u06d0\u06d8\u0001\u0000\u0000\u0000\u06d1\u06d2\u0005z\u0000\u0000\u06d2"+
		"\u06d4\u0003\u0134\u009a\u0000\u06d3\u06d5\u0005\u0083\u0000\u0000\u06d4"+
		"\u06d3\u0001\u0000\u0000\u0000\u06d4\u06d5\u0001\u0000\u0000\u0000\u06d5"+
		"\u06d7\u0001\u0000\u0000\u0000\u06d6\u06d1\u0001\u0000\u0000\u0000\u06d7"+
		"\u06da\u0001\u0000\u0000\u0000\u06d8\u06d6\u0001\u0000\u0000\u0000\u06d8"+
		"\u06d9\u0001\u0000\u0000\u0000\u06d9\u0133\u0001\u0000\u0000\u0000\u06da"+
		"\u06d8\u0001\u0000\u0000\u0000\u06db\u06dd\u0003\u00ccf\u0000\u06dc\u06db"+
		"\u0001\u0000\u0000\u0000\u06dc\u06dd\u0001\u0000\u0000\u0000\u06dd\u06ea"+
		"\u0001\u0000\u0000\u0000\u06de\u06eb\u0003\u0138\u009c\u0000\u06df\u06e1"+
		"\u0005P\u0000\u0000\u06e0\u06e2\u0003\u013a\u009d\u0000\u06e1\u06e0\u0001"+
		"\u0000\u0000\u0000\u06e1\u06e2\u0001\u0000\u0000\u0000\u06e2\u06e3\u0001"+
		"\u0000\u0000\u0000\u06e3\u06eb\u0003\u0138\u009c\u0000\u06e4\u06e6\u0003"+
		"\u013a\u009d\u0000\u06e5\u06e7\u0005P\u0000\u0000\u06e6\u06e5\u0001\u0000"+
		"\u0000\u0000\u06e6\u06e7\u0001\u0000\u0000\u0000\u06e7\u06e8\u0001\u0000"+
		"\u0000\u0000\u06e8\u06e9\u0003\u0138\u009c\u0000\u06e9\u06eb\u0001\u0000"+
		"\u0000\u0000\u06ea\u06de\u0001\u0000\u0000\u0000\u06ea\u06df\u0001\u0000"+
		"\u0000\u0000\u06ea\u06e4\u0001\u0000\u0000\u0000\u06eb\u0135\u0001\u0000"+
		"\u0000\u0000\u06ec\u06ee\u0003\n\u0005\u0000\u06ed\u06ec\u0001\u0000\u0000"+
		"\u0000\u06ed\u06ee\u0001\u0000\u0000\u0000\u06ee\u06ef\u0001\u0000\u0000"+
		"\u0000\u06ef\u06f2\u0003\u0116\u008b\u0000\u06f0\u06f2\u0003\u00a2Q\u0000"+
		"\u06f1\u06ed\u0001\u0000\u0000\u0000\u06f1\u06f0\u0001\u0000\u0000\u0000"+
		"\u06f2\u0137\u0001\u0000\u0000\u0000\u06f3\u06f4\u0003\u0136\u009b\u0000"+
		"\u06f4\u0139\u0001\u0000\u0000\u0000\u06f5\u06f6\u0007\u0015\u0000\u0000"+
		"\u06f6\u013b\u0001\u0000\u0000\u0000\u06f7\u06f8\u00054\u0000\u0000\u06f8"+
		"\u06f9\u0003\u013e\u009f\u0000\u06f9\u013d\u0001\u0000\u0000\u0000\u06fa"+
		"\u06fc\u0003\u0096K\u0000\u06fb\u06fd\u0003\u0140\u00a0\u0000\u06fc\u06fb"+
		"\u0001\u0000\u0000\u0000\u06fc\u06fd\u0001\u0000\u0000\u0000\u06fd\u013f"+
		"\u0001\u0000\u0000\u0000\u06fe\u0700\u0003\u00ecv\u0000\u06ff\u0701\u0003"+
		"\u0140\u00a0\u0000\u0700\u06ff\u0001\u0000\u0000\u0000\u0700\u0701\u0001"+
		"\u0000\u0000\u0000\u0701\u0141\u0001\u0000\u0000\u0000\u0702\u0703\u0005"+
		"~\u0000\u0000\u0703\u0704\u0003\u0144\u00a2\u0000\u0704\u0143\u0001\u0000"+
		"\u0000\u0000\u0705\u0707\u0003\u0146\u00a3\u0000\u0706\u0708\u0005\u0083"+
		"\u0000\u0000\u0707\u0706\u0001\u0000\u0000\u0000\u0707\u0708\u0001\u0000"+
		"\u0000\u0000\u0708\u0710\u0001\u0000\u0000\u0000\u0709\u070a\u0005z\u0000"+
		"\u0000\u070a\u070c\u0003\u0146\u00a3\u0000\u070b\u070d\u0005\u0083\u0000"+
		"\u0000\u070c\u070b\u0001\u0000\u0000\u0000\u070c\u070d\u0001\u0000\u0000"+
		"\u0000\u070d\u070f\u0001\u0000\u0000\u0000\u070e\u0709\u0001\u0000\u0000"+
		"\u0000\u070f\u0712\u0001\u0000\u0000\u0000\u0710\u070e\u0001\u0000\u0000"+
		"\u0000\u0710\u0711\u0001\u0000\u0000\u0000\u0711\u0145\u0001\u0000\u0000"+
		"\u0000\u0712\u0710\u0001\u0000\u0000\u0000\u0713\u071a\u0003\u0148\u00a4"+
		"\u0000\u0714\u0716\u0005U\u0000\u0000\u0715\u0717\u0003\"\u0011\u0000"+
		"\u0716\u0715\u0001\u0000\u0000\u0000\u0716\u0717\u0001\u0000\u0000\u0000"+
		"\u0717\u0718\u0001\u0000\u0000\u0000\u0718\u071b\u0005V\u0000\u0000\u0719"+
		"\u071b\u0003\u0114\u008a\u0000\u071a\u0714\u0001\u0000\u0000\u0000\u071a"+
		"\u0719\u0001\u0000\u0000\u0000\u071b\u0147\u0001\u0000\u0000\u0000\u071c"+
		"\u071f\u0003\u0136\u009b\u0000\u071d\u071f\u0005\u0084\u0000\u0000\u071e"+
		"\u071c\u0001\u0000\u0000\u0000\u071e\u071d\u0001\u0000\u0000\u0000\u071f"+
		"\u0149\u0001\u0000\u0000\u0000\u0720\u0721\u00054\u0000\u0000\u0721\u0722"+
		"\u0003\u017a\u00bd\u0000\u0722\u014b\u0001\u0000\u0000\u0000\u0723\u0727"+
		"\u00054\u0000\u0000\u0724\u0725\u0005\u0004\u0000\u0000\u0725\u0728\u0005"+
		"\u0084\u0000\u0000\u0726\u0728\u0005\u008c\u0000\u0000\u0727\u0724\u0001"+
		"\u0000\u0000\u0000\u0727\u0726\u0001\u0000\u0000\u0000\u0728\u014d\u0001"+
		"\u0000\u0000\u0000\u0729\u072a\u0005D\u0000\u0000\u072a\u072b\u0005f\u0000"+
		"\u0000\u072b\u072c\u0003\u0150\u00a8\u0000\u072c\u072d\u0005g\u0000\u0000"+
		"\u072d\u072e\u0003z=\u0000\u072e\u014f\u0001\u0000\u0000\u0000\u072f\u0734"+
		"\u0003\u0152\u00a9\u0000\u0730\u0731\u0005z\u0000\u0000\u0731\u0733\u0003"+
		"\u0152\u00a9\u0000\u0732\u0730\u0001\u0000\u0000\u0000\u0733\u0736\u0001"+
		"\u0000\u0000\u0000\u0734\u0732\u0001\u0000\u0000\u0000\u0734\u0735\u0001"+
		"\u0000\u0000\u0000\u0735\u0151\u0001\u0000\u0000\u0000\u0736\u0734\u0001"+
		"\u0000\u0000\u0000\u0737\u073a\u0003\u0154\u00aa\u0000\u0738\u073a\u0003"+
		"\u0106\u0083\u0000\u0739\u0737\u0001\u0000\u0000\u0000\u0739\u0738\u0001"+
		"\u0000\u0000\u0000\u073a\u0153\u0001\u0000\u0000\u0000\u073b\u073c\u0005"+
		"D\u0000\u0000\u073c\u073d\u0005f\u0000\u0000\u073d\u073e\u0003\u0150\u00a8"+
		"\u0000\u073e\u073f\u0005g\u0000\u0000\u073f\u0741\u0001\u0000\u0000\u0000"+
		"\u0740\u073b\u0001\u0000\u0000\u0000\u0740\u0741\u0001\u0000\u0000\u0000"+
		"\u0741\u0742\u0001\u0000\u0000\u0000\u0742\u0745\u0005\u0015\u0000\u0000"+
		"\u0743\u0745\u0005L\u0000\u0000\u0744\u0740\u0001\u0000\u0000\u0000\u0744"+
		"\u0743\u0001\u0000\u0000\u0000\u0745\u0751\u0001\u0000\u0000\u0000\u0746"+
		"\u0748\u0005\u0083\u0000\u0000\u0747\u0746\u0001\u0000\u0000\u0000\u0747"+
		"\u0748\u0001\u0000\u0000\u0000\u0748\u074a\u0001\u0000\u0000\u0000\u0749"+
		"\u074b\u0005\u0084\u0000\u0000\u074a\u0749\u0001\u0000\u0000\u0000\u074a"+
		"\u074b\u0001\u0000\u0000\u0000\u074b\u0752\u0001\u0000\u0000\u0000\u074c"+
		"\u074e\u0005\u0084\u0000\u0000\u074d\u074c\u0001\u0000\u0000\u0000\u074d"+
		"\u074e\u0001\u0000\u0000\u0000\u074e\u074f\u0001\u0000\u0000\u0000\u074f"+
		"\u0750\u0005e\u0000\u0000\u0750\u0752\u0003\u00f6{\u0000\u0751\u0747\u0001"+
		"\u0000\u0000\u0000\u0751\u074d\u0001\u0000\u0000\u0000\u0752\u0155\u0001"+
		"\u0000\u0000\u0000\u0753\u0754\u0003\u015a\u00ad\u0000\u0754\u0756\u0005"+
		"f\u0000\u0000\u0755\u0757\u0003\u015c\u00ae\u0000\u0756\u0755\u0001\u0000"+
		"\u0000\u0000\u0756\u0757\u0001\u0000\u0000\u0000\u0757\u0758\u0001\u0000"+
		"\u0000\u0000\u0758\u0759\u0005g\u0000\u0000\u0759\u0157\u0001\u0000\u0000"+
		"\u0000\u075a\u0766\u0003\u0156\u00ab\u0000\u075b\u075e\u0003\u014a\u00a5"+
		"\u0000\u075c\u075e\u0003\u014c\u00a6\u0000\u075d\u075b\u0001\u0000\u0000"+
		"\u0000\u075d\u075c\u0001\u0000\u0000\u0000\u075e\u075f\u0001\u0000\u0000"+
		"\u0000\u075f\u0761\u0005f\u0000\u0000\u0760\u0762\u0003\u015c\u00ae\u0000"+
		"\u0761\u0760\u0001\u0000\u0000\u0000\u0761\u0762\u0001\u0000\u0000\u0000"+
		"\u0762\u0763\u0001\u0000\u0000\u0000\u0763\u0764\u0005g\u0000\u0000\u0764"+
		"\u0766\u0001\u0000\u0000\u0000\u0765\u075a\u0001\u0000\u0000\u0000\u0765"+
		"\u075d\u0001\u0000\u0000\u0000\u0766\u0159\u0001\u0000\u0000\u0000\u0767"+
		"\u0768\u0005\u0084\u0000\u0000\u0768\u015b\u0001\u0000\u0000\u0000\u0769"+
		"\u076b\u0003\u015e\u00af\u0000\u076a\u076c\u0005\u0083\u0000\u0000\u076b"+
		"\u076a\u0001\u0000\u0000\u0000\u076b\u076c\u0001\u0000\u0000\u0000\u076c"+
		"\u0774\u0001\u0000\u0000\u0000\u076d\u076e\u0005z\u0000\u0000\u076e\u0770"+
		"\u0003\u015e\u00af\u0000\u076f\u0771\u0005\u0083\u0000\u0000\u0770\u076f"+
		"\u0001\u0000\u0000\u0000\u0770\u0771\u0001\u0000\u0000\u0000\u0771\u0773"+
		"\u0001\u0000\u0000\u0000\u0772\u076d\u0001\u0000\u0000\u0000\u0773\u0776"+
		"\u0001\u0000\u0000\u0000\u0774\u0772\u0001\u0000\u0000\u0000\u0774\u0775"+
		"\u0001\u0000\u0000\u0000\u0775\u015d\u0001\u0000\u0000\u0000\u0776\u0774"+
		"\u0001\u0000\u0000\u0000\u0777\u077b\u0003\u00f6{\u0000\u0778\u077b\u0003"+
		"\\.\u0000\u0779\u077b\u0003\u0004\u0002\u0000\u077a\u0777\u0001\u0000"+
		"\u0000\u0000\u077a\u0778\u0001\u0000\u0000\u0000\u077a\u0779\u0001\u0000"+
		"\u0000\u0000\u077b\u015f\u0001\u0000\u0000\u0000\u077c\u077d\u0005L\u0000"+
		"\u0000\u077d\u0783\u0003\n\u0005\u0000\u077e\u0784\u0005\u0084\u0000\u0000"+
		"\u077f\u0781\u0005D\u0000\u0000\u0780\u077f\u0001\u0000\u0000\u0000\u0780"+
		"\u0781\u0001\u0000\u0000\u0000\u0781\u0782\u0001\u0000\u0000\u0000\u0782"+
		"\u0784\u0003\u0156\u00ab\u0000\u0783\u077e\u0001\u0000\u0000\u0000\u0783"+
		"\u0780\u0001\u0000\u0000\u0000\u0784\u0161\u0001\u0000\u0000\u0000\u0785"+
		"\u0787\u0005$\u0000\u0000\u0786\u0785\u0001\u0000\u0000\u0000\u0786\u0787"+
		"\u0001\u0000\u0000\u0000\u0787\u0788\u0001\u0000\u0000\u0000\u0788\u0789"+
		"\u0005D\u0000\u0000\u0789\u078a\u0003z=\u0000\u078a\u0163\u0001\u0000"+
		"\u0000\u0000\u078b\u078c\u0005D\u0000\u0000\u078c\u078d\u0005f\u0000\u0000"+
		"\u078d\u078e\u0005g\u0000\u0000\u078e\u078f\u0003z=\u0000\u078f\u0165"+
		"\u0001\u0000\u0000\u0000\u0790\u0791\u0005I\u0000\u0000\u0791\u0792\u0003"+
		"d2\u0000\u0792\u0793\u0003\u016a\u00b5\u0000\u0793\u0167\u0001\u0000\u0000"+
		"\u0000\u0794\u0796\u0005I\u0000\u0000\u0795\u0797\u0003\u0142\u00a1\u0000"+
		"\u0796\u0795\u0001\u0000\u0000\u0000\u0796\u0797\u0001\u0000\u0000\u0000"+
		"\u0797\u0798\u0001\u0000\u0000\u0000\u0798\u0799\u0003d2\u0000\u0799\u079a"+
		"\u0003\u016a\u00b5\u0000\u079a\u0169\u0001\u0000\u0000\u0000\u079b\u079d"+
		"\u0003\u016c\u00b6\u0000\u079c\u079b\u0001\u0000\u0000\u0000\u079d\u079e"+
		"\u0001\u0000\u0000\u0000\u079e\u079c\u0001\u0000\u0000\u0000\u079e\u079f"+
		"\u0001\u0000\u0000\u0000\u079f\u016b\u0001\u0000\u0000\u0000\u07a0\u07a1"+
		"\u0005\u0011\u0000\u0000\u07a1\u07a2\u0005U\u0000\u0000\u07a2\u07a3\u0003"+
		"\u016e\u00b7\u0000\u07a3\u07a4\u0005V\u0000\u0000\u07a4\u07a5\u0003d2"+
		"\u0000\u07a5\u016d\u0001\u0000\u0000\u0000\u07a6\u07a8\u0003\u00ccf\u0000"+
		"\u07a7\u07a6\u0001\u0000\u0000\u0000\u07a7\u07a8\u0001\u0000\u0000\u0000"+
		"\u07a8\u07a9\u0001\u0000\u0000\u0000\u07a9\u07ac\u0003\u0096K\u0000\u07aa"+
		"\u07ad\u0003\u00e2q\u0000\u07ab\u07ad\u0003\u00f8|\u0000\u07ac\u07aa\u0001"+
		"\u0000\u0000\u0000\u07ac\u07ab\u0001\u0000\u0000\u0000\u07ac\u07ad\u0001"+
		"\u0000\u0000\u0000\u07ad\u07b0\u0001\u0000\u0000\u0000\u07ae\u07b0\u0005"+
		"\u0083\u0000\u0000\u07af\u07a7\u0001\u0000\u0000\u0000\u07af\u07ae\u0001"+
		"\u0000\u0000\u0000\u07b0\u016f\u0001\u0000\u0000\u0000\u07b1\u07b3\u0005"+
		"G\u0000\u0000\u07b2\u07b4\u0003V+\u0000\u07b3\u07b2\u0001\u0000\u0000"+
		"\u0000\u07b3\u07b4\u0001\u0000\u0000\u0000\u07b4\u0171\u0001\u0000\u0000"+
		"\u0000\u07b5\u07b8\u0003\u0174\u00ba\u0000\u07b6\u07b8\u0003\u0178\u00bc"+
		"\u0000\u07b7\u07b5\u0001\u0000\u0000\u0000\u07b7\u07b6\u0001\u0000\u0000"+
		"\u0000\u07b8\u0173\u0001\u0000\u0000\u0000\u07b9\u07ba\u0005G\u0000\u0000"+
		"\u07ba\u07bc\u0005U\u0000\u0000\u07bb\u07bd\u0003\u0176\u00bb\u0000\u07bc"+
		"\u07bb\u0001\u0000\u0000\u0000\u07bc\u07bd\u0001\u0000\u0000\u0000\u07bd"+
		"\u07be\u0001\u0000\u0000\u0000\u07be\u07bf\u0005V\u0000\u0000\u07bf\u0175"+
		"\u0001\u0000\u0000\u0000\u07c0\u07c2\u0003\u00f6{\u0000\u07c1\u07c3\u0005"+
		"\u0083\u0000\u0000\u07c2\u07c1\u0001\u0000\u0000\u0000\u07c2\u07c3\u0001"+
		"\u0000\u0000\u0000\u07c3\u07cb\u0001\u0000\u0000\u0000\u07c4\u07c5\u0005"+
		"z\u0000\u0000\u07c5\u07c7\u0003\u00f6{\u0000\u07c6\u07c8\u0005\u0083\u0000"+
		"\u0000\u07c7\u07c6\u0001\u0000\u0000\u0000\u07c7\u07c8\u0001\u0000\u0000"+
		"\u0000\u07c8\u07ca\u0001\u0000\u0000\u0000\u07c9\u07c4\u0001\u0000\u0000"+
		"\u0000\u07ca\u07cd\u0001\u0000\u0000\u0000\u07cb\u07c9\u0001\u0000\u0000"+
		"\u0000\u07cb\u07cc\u0001\u0000\u0000\u0000\u07cc\u0177\u0001\u0000\u0000"+
		"\u0000\u07cd\u07cb\u0001\u0000\u0000\u0000\u07ce\u07cf\u00052\u0000\u0000"+
		"\u07cf\u07d0\u0005U\u0000\u0000\u07d0\u07d1\u0003\\.\u0000\u07d1\u07d2"+
		"\u0005V\u0000\u0000\u07d2\u07d5\u0001\u0000\u0000\u0000\u07d3\u07d5\u0005"+
		"2\u0000\u0000\u07d4\u07ce\u0001\u0000\u0000\u0000\u07d4\u07d3\u0001\u0000"+
		"\u0000\u0000\u07d5\u0179\u0001\u0000\u0000\u0000\u07d6\u07d9\u00051\u0000"+
		"\u0000\u07d7\u07d8\u0005W\u0000\u0000\u07d8\u07da\u0005X\u0000\u0000\u07d9"+
		"\u07d7\u0001\u0000\u0000\u0000\u07d9\u07da\u0001\u0000\u0000\u0000\u07da"+
		"\u080a\u0001\u0000\u0000\u0000\u07db\u07de\u0005\u001c\u0000\u0000\u07dc"+
		"\u07dd\u0005W\u0000\u0000\u07dd\u07df\u0005X\u0000\u0000\u07de\u07dc\u0001"+
		"\u0000\u0000\u0000\u07de\u07df\u0001\u0000\u0000\u0000\u07df\u080a\u0001"+
		"\u0000\u0000\u0000\u07e0\u080a\u0005[\u0000\u0000\u07e1\u080a\u0005\\"+
		"\u0000\u0000\u07e2\u080a\u0005]\u0000\u0000\u07e3\u080a\u0005^\u0000\u0000"+
		"\u07e4\u080a\u0005_\u0000\u0000\u07e5\u080a\u0005`\u0000\u0000\u07e6\u080a"+
		"\u0005a\u0000\u0000\u07e7\u080a\u0005b\u0000\u0000\u07e8\u080a\u0005c"+
		"\u0000\u0000\u07e9\u080a\u0005d\u0000\u0000\u07ea\u080a\u0005e\u0000\u0000"+
		"\u07eb\u080a\u0005g\u0000\u0000\u07ec\u080a\u0005f\u0000\u0000\u07ed\u080a"+
		"\u0005u\u0000\u0000\u07ee\u080a\u0005h\u0000\u0000\u07ef\u080a\u0005i"+
		"\u0000\u0000\u07f0\u080a\u0005j\u0000\u0000\u07f1\u080a\u0005l\u0000\u0000"+
		"\u07f2\u080a\u0005m\u0000\u0000\u07f3\u080a\u0005n\u0000\u0000\u07f4\u080a"+
		"\u0005o\u0000\u0000\u07f5\u07f6\u0005f\u0000\u0000\u07f6\u080a\u0005f"+
		"\u0000\u0000\u07f7\u07f8\u0005g\u0000\u0000\u07f8\u080a\u0005g\u0000\u0000"+
		"\u07f9\u080a\u0005q\u0000\u0000\u07fa\u080a\u0005p\u0000\u0000\u07fb\u080a"+
		"\u0005r\u0000\u0000\u07fc\u080a\u0005s\u0000\u0000\u07fd\u080a\u0005t"+
		"\u0000\u0000\u07fe\u080a\u0005v\u0000\u0000\u07ff\u080a\u0005w\u0000\u0000"+
		"\u0800\u080a\u0005x\u0000\u0000\u0801\u080a\u0005y\u0000\u0000\u0802\u080a"+
		"\u0005z\u0000\u0000\u0803\u080a\u0005{\u0000\u0000\u0804\u080a\u0005|"+
		"\u0000\u0000\u0805\u0806\u0005U\u0000\u0000\u0806\u080a\u0005V\u0000\u0000"+
		"\u0807\u0808\u0005W\u0000\u0000\u0808\u080a\u0005X\u0000\u0000\u0809\u07d6"+
		"\u0001\u0000\u0000\u0000\u0809\u07db\u0001\u0000\u0000\u0000\u0809\u07e0"+
		"\u0001\u0000\u0000\u0000\u0809\u07e1\u0001\u0000\u0000\u0000\u0809\u07e2"+
		"\u0001\u0000\u0000\u0000\u0809\u07e3\u0001\u0000\u0000\u0000\u0809\u07e4"+
		"\u0001\u0000\u0000\u0000\u0809\u07e5\u0001\u0000\u0000\u0000\u0809\u07e6"+
		"\u0001\u0000\u0000\u0000\u0809\u07e7\u0001\u0000\u0000\u0000\u0809\u07e8"+
		"\u0001\u0000\u0000\u0000\u0809\u07e9\u0001\u0000\u0000\u0000\u0809\u07ea"+
		"\u0001\u0000\u0000\u0000\u0809\u07eb\u0001\u0000\u0000\u0000\u0809\u07ec"+
		"\u0001\u0000\u0000\u0000\u0809\u07ed\u0001\u0000\u0000\u0000\u0809\u07ee"+
		"\u0001\u0000\u0000\u0000\u0809\u07ef\u0001\u0000\u0000\u0000\u0809\u07f0"+
		"\u0001\u0000\u0000\u0000\u0809\u07f1\u0001\u0000\u0000\u0000\u0809\u07f2"+
		"\u0001\u0000\u0000\u0000\u0809\u07f3\u0001\u0000\u0000\u0000\u0809\u07f4"+
		"\u0001\u0000\u0000\u0000\u0809\u07f5\u0001\u0000\u0000\u0000\u0809\u07f7"+
		"\u0001\u0000\u0000\u0000\u0809\u07f9\u0001\u0000\u0000\u0000\u0809\u07fa"+
		"\u0001\u0000\u0000\u0000\u0809\u07fb\u0001\u0000\u0000\u0000\u0809\u07fc"+
		"\u0001\u0000\u0000\u0000\u0809\u07fd\u0001\u0000\u0000\u0000\u0809\u07fe"+
		"\u0001\u0000\u0000\u0000\u0809\u07ff\u0001\u0000\u0000\u0000\u0809\u0800"+
		"\u0001\u0000\u0000\u0000\u0809\u0801\u0001\u0000\u0000\u0000\u0809\u0802"+
		"\u0001\u0000\u0000\u0000\u0809\u0803\u0001\u0000\u0000\u0000\u0809\u0804"+
		"\u0001\u0000\u0000\u0000\u0809\u0805\u0001\u0000\u0000\u0000\u0809\u0807"+
		"\u0001\u0000\u0000\u0000\u080a\u017b\u0001\u0000\u0000\u0000\u080b\u080c"+
		"\u0007\u0016\u0000\u0000\u080c\u017d\u0001\u0000\u0000\u0000\u0123\u017f"+
		"\u0186\u018f\u0193\u019c\u019f\u01a3\u01ab\u01b2\u01b5\u01ba\u01bf\u01c5"+
		"\u01cd\u01cf\u01d8\u01dc\u01e0\u01e3\u01e7\u01ea\u01f1\u01f5\u01f8\u01fb"+
		"\u01fe\u0204\u0208\u020c\u021a\u021e\u0224\u022b\u0231\u0235\u0239\u023b"+
		"\u0243\u0248\u0255\u025c\u0268\u0272\u0277\u027b\u0282\u0285\u028d\u0291"+
		"\u0294\u029b\u02a2\u02a6\u02ab\u02af\u02b2\u02b7\u02c6\u02cd\u02d5\u02dd"+
		"\u02e6\u02ed\u02f4\u02fc\u0304\u030c\u0314\u031c\u0324\u032d\u0335\u033e"+
		"\u0346\u034e\u0350\u0353\u0359\u035f\u0365\u036c\u0375\u037d\u0381\u0388"+
		"\u038a\u039e\u03a2\u03a8\u03ad\u03b1\u03b4\u03bb\u03c2\u03c6\u03cf\u03da"+
		"\u03e4\u03e9\u03f0\u03f3\u03f8\u03fd\u0412\u0417\u041a\u0425\u042b\u0430"+
		"\u0433\u0438\u043b\u0442\u0459\u045f\u0465\u046b\u046e\u0474\u0478\u047c"+
		"\u047f\u0487\u0489\u048f\u0492\u0495\u0498\u049c\u04a0\u04a6\u04b0\u04b6"+
		"\u04bc\u04c1\u04c6\u04ca\u04d7\u04dd\u04e1\u04e7\u04ec\u04fb\u04ff\u0504"+
		"\u0509\u050e\u0514\u0517\u0520\u0524\u0529\u052d\u0533\u053a\u054b\u054d"+
		"\u0554\u0559\u0560\u0564\u0568\u0570\u0576\u057c\u0580\u0582\u0586\u058b"+
		"\u058f\u0592\u0595\u0598\u059d\u05a1\u05a4\u05a8\u05ab\u05ad\u05b2\u05b9"+
		"\u05bf\u05c3\u05c9\u05ce\u05d3\u05da\u05df\u05e3\u05e5\u05e7\u05ed\u05f6"+
		"\u05fa\u05fc\u05fe\u0603\u0606\u060d\u0611\u0616\u0618\u061c\u061f\u0622"+
		"\u0626\u062b\u0632\u0639\u063e\u0642\u0646\u064b\u064f\u0655\u0657\u065d"+
		"\u0662\u0668\u066c\u066e\u0671\u0675\u0679\u067b\u067d\u0680\u068c\u068e"+
		"\u0691\u0694\u0697\u06a0\u06a7\u06b3\u06b7\u06ba\u06be\u06c3\u06cf\u06d4"+
		"\u06d8\u06dc\u06e1\u06e6\u06ea\u06ed\u06f1\u06fc\u0700\u0707\u070c\u0710"+
		"\u0716\u071a\u071e\u0727\u0734\u0739\u0740\u0744\u0747\u074a\u074d\u0751"+
		"\u0756\u075d\u0761\u0765\u076b\u0770\u0774\u077a\u0780\u0783\u0786\u0796"+
		"\u079e\u07a7\u07ac\u07af\u07b3\u07b7\u07bc\u07c2\u07c7\u07cb\u07d4\u07d9"+
		"\u07de\u0809";
	public static final ATN _ATN =
		new ATNDeserializer().deserialize(_serializedATN.toCharArray());
	static {
		_decisionToDFA = new DFA[_ATN.getNumberOfDecisions()];
		for (int i = 0; i < _ATN.getNumberOfDecisions(); i++) {
			_decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i);
		}
	}
}
```

`src/main/java/com/lauriewired/malimite/decompile/antlr/CPP14Parser.tokens`:

```tokens
IntegerLiteral=1
CharacterLiteral=2
FloatingLiteral=3
StringLiteral=4
BooleanLiteral=5
PointerLiteral=6
UserDefinedLiteral=7
MultiLineMacro=8
Directive=9
Alignas=10
Alignof=11
Asm=12
Auto=13
Bool=14
Break=15
Case=16
Catch=17
Char=18
Char16=19
Char32=20
Class=21
Const=22
Constexpr=23
Const_cast=24
Continue=25
Decltype=26
Default=27
Delete=28
Do=29
Double=30
Dynamic_cast=31
Else=32
Enum=33
Explicit=34
Export=35
Extern=36
False_=37
Final=38
Float=39
For=40
Friend=41
Goto=42
If=43
Inline=44
Int=45
Long=46
Mutable=47
Namespace=48
New=49
Noexcept=50
Nullptr=51
Operator=52
Override=53
Private=54
Protected=55
Public=56
Register=57
Reinterpret_cast=58
Return=59
Short=60
Signed=61
Sizeof=62
Static=63
Static_assert=64
Static_cast=65
Struct=66
Switch=67
Template=68
This=69
Thread_local=70
Throw=71
True_=72
Try=73
Typedef=74
Typeid_=75
Typename_=76
Union=77
Unsigned=78
Using=79
Virtual=80
Void=81
Volatile=82
Wchar=83
While=84
LeftParen=85
RightParen=86
LeftBracket=87
RightBracket=88
LeftBrace=89
RightBrace=90
Plus=91
Minus=92
Star=93
Div=94
Mod=95
Caret=96
And=97
Or=98
Tilde=99
Not=100
Assign=101
Less=102
Greater=103
PlusAssign=104
MinusAssign=105
StarAssign=106
DivAssign=107
ModAssign=108
XorAssign=109
AndAssign=110
OrAssign=111
LeftShiftAssign=112
RightShiftAssign=113
Equal=114
NotEqual=115
LessEqual=116
GreaterEqual=117
AndAnd=118
OrOr=119
PlusPlus=120
MinusMinus=121
Comma=122
ArrowStar=123
Arrow=124
Question=125
Colon=126
Doublecolon=127
Semi=128
Dot=129
DotStar=130
Ellipsis=131
Identifier=132
DecimalLiteral=133
OctalLiteral=134
HexadecimalLiteral=135
BinaryLiteral=136
Integersuffix=137
UserDefinedIntegerLiteral=138
UserDefinedFloatingLiteral=139
UserDefinedStringLiteral=140
UserDefinedCharacterLiteral=141
Whitespace=142
Newline=143
BlockComment=144
LineComment=145
'alignas'=10
'alignof'=11
'asm'=12
'auto'=13
'bool'=14
'break'=15
'case'=16
'catch'=17
'char'=18
'char16_t'=19
'char32_t'=20
'class'=21
'const'=22
'constexpr'=23
'const_cast'=24
'continue'=25
'decltype'=26
'default'=27
'delete'=28
'do'=29
'double'=30
'dynamic_cast'=31
'else'=32
'enum'=33
'explicit'=34
'export'=35
'extern'=36
'false'=37
'final'=38
'float'=39
'for'=40
'friend'=41
'goto'=42
'if'=43
'inline'=44
'int'=45
'long'=46
'mutable'=47
'namespace'=48
'new'=49
'noexcept'=50
'nullptr'=51
'operator'=52
'override'=53
'private'=54
'protected'=55
'public'=56
'register'=57
'reinterpret_cast'=58
'return'=59
'short'=60
'signed'=61
'sizeof'=62
'static'=63
'static_assert'=64
'static_cast'=65
'struct'=66
'switch'=67
'template'=68
'this'=69
'thread_local'=70
'throw'=71
'true'=72
'try'=73
'typedef'=74
'typeid'=75
'typename'=76
'union'=77
'unsigned'=78
'using'=79
'virtual'=80
'void'=81
'volatile'=82
'wchar_t'=83
'while'=84
'('=85
')'=86
'['=87
']'=88
'{'=89
'}'=90
'+'=91
'-'=92
'*'=93
'/'=94
'%'=95
'^'=96
'&'=97
'|'=98
'~'=99
'='=101
'<'=102
'>'=103
'+='=104
'-='=105
'*='=106
'/='=107
'%='=108
'^='=109
'&='=110
'|='=111
'<<='=112
'>>='=113
'=='=114
'!='=115
'<='=116
'>='=117
'++'=120
'--'=121
','=122
'->*'=123
'->'=124
'?'=125
':'=126
'::'=127
';'=128
'.'=129
'.*'=130
'...'=131

```

`src/main/java/com/lauriewired/malimite/decompile/antlr/CPP14ParserBase.java`:

```java
package com.lauriewired.malimite.decompile.antlr;

import org.antlr.v4.runtime.Parser;
import org.antlr.v4.runtime.TokenStream;

public abstract class CPP14ParserBase extends Parser {
    public CPP14ParserBase(TokenStream input) {
        super(input);
    }

    // Stub implementation for IsPureSpecifierAllowed
    public boolean IsPureSpecifierAllowed() {
        return true;
    }
}

```

`src/main/java/com/lauriewired/malimite/decompile/antlr/CPP14ParserBaseListener.java`:

```java
// Generated from CPP14Parser.g4 by ANTLR 4.13.1
package com.lauriewired.malimite.decompile.antlr;

import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.tree.ErrorNode;
import org.antlr.v4.runtime.tree.TerminalNode;

/**
 * This class provides an empty implementation of {@link CPP14ParserListener},
 * which can be extended to create a listener which only needs to handle a subset
 * of the available methods.
 */
@SuppressWarnings("CheckReturnValue")
public class CPP14ParserBaseListener implements CPP14ParserListener {
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTranslationUnit(CPP14Parser.TranslationUnitContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTranslationUnit(CPP14Parser.TranslationUnitContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterPrimaryExpression(CPP14Parser.PrimaryExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitPrimaryExpression(CPP14Parser.PrimaryExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterIdExpression(CPP14Parser.IdExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitIdExpression(CPP14Parser.IdExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterUnqualifiedId(CPP14Parser.UnqualifiedIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitUnqualifiedId(CPP14Parser.UnqualifiedIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterQualifiedId(CPP14Parser.QualifiedIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitQualifiedId(CPP14Parser.QualifiedIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterNestedNameSpecifier(CPP14Parser.NestedNameSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitNestedNameSpecifier(CPP14Parser.NestedNameSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterLambdaExpression(CPP14Parser.LambdaExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitLambdaExpression(CPP14Parser.LambdaExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterLambdaIntroducer(CPP14Parser.LambdaIntroducerContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitLambdaIntroducer(CPP14Parser.LambdaIntroducerContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterLambdaCapture(CPP14Parser.LambdaCaptureContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitLambdaCapture(CPP14Parser.LambdaCaptureContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterCaptureDefault(CPP14Parser.CaptureDefaultContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitCaptureDefault(CPP14Parser.CaptureDefaultContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterCaptureList(CPP14Parser.CaptureListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitCaptureList(CPP14Parser.CaptureListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterCapture(CPP14Parser.CaptureContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitCapture(CPP14Parser.CaptureContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterSimpleCapture(CPP14Parser.SimpleCaptureContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitSimpleCapture(CPP14Parser.SimpleCaptureContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterInitcapture(CPP14Parser.InitcaptureContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitInitcapture(CPP14Parser.InitcaptureContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterLambdaDeclarator(CPP14Parser.LambdaDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitLambdaDeclarator(CPP14Parser.LambdaDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterPostfixExpression(CPP14Parser.PostfixExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitPostfixExpression(CPP14Parser.PostfixExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTypeIdOfTheTypeId(CPP14Parser.TypeIdOfTheTypeIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTypeIdOfTheTypeId(CPP14Parser.TypeIdOfTheTypeIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterExpressionList(CPP14Parser.ExpressionListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitExpressionList(CPP14Parser.ExpressionListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterPseudoDestructorName(CPP14Parser.PseudoDestructorNameContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitPseudoDestructorName(CPP14Parser.PseudoDestructorNameContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterUnaryExpression(CPP14Parser.UnaryExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitUnaryExpression(CPP14Parser.UnaryExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterUnaryOperator(CPP14Parser.UnaryOperatorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitUnaryOperator(CPP14Parser.UnaryOperatorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterNewExpression_(CPP14Parser.NewExpression_Context ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitNewExpression_(CPP14Parser.NewExpression_Context ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterNewPlacement(CPP14Parser.NewPlacementContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitNewPlacement(CPP14Parser.NewPlacementContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterNewTypeId(CPP14Parser.NewTypeIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitNewTypeId(CPP14Parser.NewTypeIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterNewDeclarator_(CPP14Parser.NewDeclarator_Context ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitNewDeclarator_(CPP14Parser.NewDeclarator_Context ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterNoPointerNewDeclarator(CPP14Parser.NoPointerNewDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitNoPointerNewDeclarator(CPP14Parser.NoPointerNewDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterNewInitializer_(CPP14Parser.NewInitializer_Context ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitNewInitializer_(CPP14Parser.NewInitializer_Context ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterDeleteExpression(CPP14Parser.DeleteExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitDeleteExpression(CPP14Parser.DeleteExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterNoExceptExpression(CPP14Parser.NoExceptExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitNoExceptExpression(CPP14Parser.NoExceptExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterCastExpression(CPP14Parser.CastExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitCastExpression(CPP14Parser.CastExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterPointerMemberExpression(CPP14Parser.PointerMemberExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitPointerMemberExpression(CPP14Parser.PointerMemberExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterMultiplicativeExpression(CPP14Parser.MultiplicativeExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitMultiplicativeExpression(CPP14Parser.MultiplicativeExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterAdditiveExpression(CPP14Parser.AdditiveExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitAdditiveExpression(CPP14Parser.AdditiveExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterShiftExpression(CPP14Parser.ShiftExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitShiftExpression(CPP14Parser.ShiftExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterShiftOperator(CPP14Parser.ShiftOperatorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitShiftOperator(CPP14Parser.ShiftOperatorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterRelationalExpression(CPP14Parser.RelationalExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitRelationalExpression(CPP14Parser.RelationalExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterEqualityExpression(CPP14Parser.EqualityExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitEqualityExpression(CPP14Parser.EqualityExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterAndExpression(CPP14Parser.AndExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitAndExpression(CPP14Parser.AndExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterExclusiveOrExpression(CPP14Parser.ExclusiveOrExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitExclusiveOrExpression(CPP14Parser.ExclusiveOrExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterInclusiveOrExpression(CPP14Parser.InclusiveOrExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitInclusiveOrExpression(CPP14Parser.InclusiveOrExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterLogicalAndExpression(CPP14Parser.LogicalAndExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitLogicalAndExpression(CPP14Parser.LogicalAndExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterLogicalOrExpression(CPP14Parser.LogicalOrExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitLogicalOrExpression(CPP14Parser.LogicalOrExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterConditionalExpression(CPP14Parser.ConditionalExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitConditionalExpression(CPP14Parser.ConditionalExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterAssignmentExpression(CPP14Parser.AssignmentExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitAssignmentExpression(CPP14Parser.AssignmentExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterAssignmentOperator(CPP14Parser.AssignmentOperatorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitAssignmentOperator(CPP14Parser.AssignmentOperatorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterExpression(CPP14Parser.ExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitExpression(CPP14Parser.ExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterConstantExpression(CPP14Parser.ConstantExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitConstantExpression(CPP14Parser.ConstantExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterStatement(CPP14Parser.StatementContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitStatement(CPP14Parser.StatementContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterLabeledStatement(CPP14Parser.LabeledStatementContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitLabeledStatement(CPP14Parser.LabeledStatementContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterExpressionStatement(CPP14Parser.ExpressionStatementContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitExpressionStatement(CPP14Parser.ExpressionStatementContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterCompoundStatement(CPP14Parser.CompoundStatementContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitCompoundStatement(CPP14Parser.CompoundStatementContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterStatementSeq(CPP14Parser.StatementSeqContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitStatementSeq(CPP14Parser.StatementSeqContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterSelectionStatement(CPP14Parser.SelectionStatementContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitSelectionStatement(CPP14Parser.SelectionStatementContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterCondition(CPP14Parser.ConditionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitCondition(CPP14Parser.ConditionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterIterationStatement(CPP14Parser.IterationStatementContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitIterationStatement(CPP14Parser.IterationStatementContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterForInitStatement(CPP14Parser.ForInitStatementContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitForInitStatement(CPP14Parser.ForInitStatementContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterForRangeDeclaration(CPP14Parser.ForRangeDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitForRangeDeclaration(CPP14Parser.ForRangeDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterForRangeInitializer(CPP14Parser.ForRangeInitializerContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitForRangeInitializer(CPP14Parser.ForRangeInitializerContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterJumpStatement(CPP14Parser.JumpStatementContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitJumpStatement(CPP14Parser.JumpStatementContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterDeclarationStatement(CPP14Parser.DeclarationStatementContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitDeclarationStatement(CPP14Parser.DeclarationStatementContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterDeclarationseq(CPP14Parser.DeclarationseqContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitDeclarationseq(CPP14Parser.DeclarationseqContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterDeclaration(CPP14Parser.DeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitDeclaration(CPP14Parser.DeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterBlockDeclaration(CPP14Parser.BlockDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitBlockDeclaration(CPP14Parser.BlockDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterAliasDeclaration(CPP14Parser.AliasDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitAliasDeclaration(CPP14Parser.AliasDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterSimpleDeclaration(CPP14Parser.SimpleDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitSimpleDeclaration(CPP14Parser.SimpleDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterStaticAssertDeclaration(CPP14Parser.StaticAssertDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitStaticAssertDeclaration(CPP14Parser.StaticAssertDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterEmptyDeclaration_(CPP14Parser.EmptyDeclaration_Context ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitEmptyDeclaration_(CPP14Parser.EmptyDeclaration_Context ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterAttributeDeclaration(CPP14Parser.AttributeDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitAttributeDeclaration(CPP14Parser.AttributeDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterDeclSpecifier(CPP14Parser.DeclSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitDeclSpecifier(CPP14Parser.DeclSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterDeclSpecifierSeq(CPP14Parser.DeclSpecifierSeqContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitDeclSpecifierSeq(CPP14Parser.DeclSpecifierSeqContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterStorageClassSpecifier(CPP14Parser.StorageClassSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitStorageClassSpecifier(CPP14Parser.StorageClassSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterFunctionSpecifier(CPP14Parser.FunctionSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitFunctionSpecifier(CPP14Parser.FunctionSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTypedefName(CPP14Parser.TypedefNameContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTypedefName(CPP14Parser.TypedefNameContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTypeSpecifier(CPP14Parser.TypeSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTypeSpecifier(CPP14Parser.TypeSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTrailingTypeSpecifier(CPP14Parser.TrailingTypeSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTrailingTypeSpecifier(CPP14Parser.TrailingTypeSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTypeSpecifierSeq(CPP14Parser.TypeSpecifierSeqContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTypeSpecifierSeq(CPP14Parser.TypeSpecifierSeqContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTrailingTypeSpecifierSeq(CPP14Parser.TrailingTypeSpecifierSeqContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTrailingTypeSpecifierSeq(CPP14Parser.TrailingTypeSpecifierSeqContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterSimpleTypeLengthModifier(CPP14Parser.SimpleTypeLengthModifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitSimpleTypeLengthModifier(CPP14Parser.SimpleTypeLengthModifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterSimpleTypeSignednessModifier(CPP14Parser.SimpleTypeSignednessModifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitSimpleTypeSignednessModifier(CPP14Parser.SimpleTypeSignednessModifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterSimpleTypeSpecifier(CPP14Parser.SimpleTypeSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitSimpleTypeSpecifier(CPP14Parser.SimpleTypeSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTheTypeName(CPP14Parser.TheTypeNameContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTheTypeName(CPP14Parser.TheTypeNameContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterDecltypeSpecifier(CPP14Parser.DecltypeSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitDecltypeSpecifier(CPP14Parser.DecltypeSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterElaboratedTypeSpecifier(CPP14Parser.ElaboratedTypeSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitElaboratedTypeSpecifier(CPP14Parser.ElaboratedTypeSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterEnumName(CPP14Parser.EnumNameContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitEnumName(CPP14Parser.EnumNameContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterEnumSpecifier(CPP14Parser.EnumSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitEnumSpecifier(CPP14Parser.EnumSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterEnumHead(CPP14Parser.EnumHeadContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitEnumHead(CPP14Parser.EnumHeadContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterOpaqueEnumDeclaration(CPP14Parser.OpaqueEnumDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitOpaqueEnumDeclaration(CPP14Parser.OpaqueEnumDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterEnumkey(CPP14Parser.EnumkeyContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitEnumkey(CPP14Parser.EnumkeyContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterEnumbase(CPP14Parser.EnumbaseContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitEnumbase(CPP14Parser.EnumbaseContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterEnumeratorList(CPP14Parser.EnumeratorListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitEnumeratorList(CPP14Parser.EnumeratorListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterEnumeratorDefinition(CPP14Parser.EnumeratorDefinitionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitEnumeratorDefinition(CPP14Parser.EnumeratorDefinitionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterEnumerator(CPP14Parser.EnumeratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitEnumerator(CPP14Parser.EnumeratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterNamespaceName(CPP14Parser.NamespaceNameContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitNamespaceName(CPP14Parser.NamespaceNameContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterOriginalNamespaceName(CPP14Parser.OriginalNamespaceNameContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitOriginalNamespaceName(CPP14Parser.OriginalNamespaceNameContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterNamespaceDefinition(CPP14Parser.NamespaceDefinitionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitNamespaceDefinition(CPP14Parser.NamespaceDefinitionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterNamespaceAlias(CPP14Parser.NamespaceAliasContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitNamespaceAlias(CPP14Parser.NamespaceAliasContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterNamespaceAliasDefinition(CPP14Parser.NamespaceAliasDefinitionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitNamespaceAliasDefinition(CPP14Parser.NamespaceAliasDefinitionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterQualifiednamespacespecifier(CPP14Parser.QualifiednamespacespecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitQualifiednamespacespecifier(CPP14Parser.QualifiednamespacespecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterUsingDeclaration(CPP14Parser.UsingDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitUsingDeclaration(CPP14Parser.UsingDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterUsingDirective(CPP14Parser.UsingDirectiveContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitUsingDirective(CPP14Parser.UsingDirectiveContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterAsmDefinition(CPP14Parser.AsmDefinitionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitAsmDefinition(CPP14Parser.AsmDefinitionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterLinkageSpecification(CPP14Parser.LinkageSpecificationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitLinkageSpecification(CPP14Parser.LinkageSpecificationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterAttributeSpecifierSeq(CPP14Parser.AttributeSpecifierSeqContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitAttributeSpecifierSeq(CPP14Parser.AttributeSpecifierSeqContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterAttributeSpecifier(CPP14Parser.AttributeSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitAttributeSpecifier(CPP14Parser.AttributeSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterAlignmentspecifier(CPP14Parser.AlignmentspecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitAlignmentspecifier(CPP14Parser.AlignmentspecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterAttributeList(CPP14Parser.AttributeListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitAttributeList(CPP14Parser.AttributeListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterAttribute(CPP14Parser.AttributeContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitAttribute(CPP14Parser.AttributeContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterAttributeNamespace(CPP14Parser.AttributeNamespaceContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitAttributeNamespace(CPP14Parser.AttributeNamespaceContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterAttributeArgumentClause(CPP14Parser.AttributeArgumentClauseContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitAttributeArgumentClause(CPP14Parser.AttributeArgumentClauseContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterBalancedTokenSeq(CPP14Parser.BalancedTokenSeqContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitBalancedTokenSeq(CPP14Parser.BalancedTokenSeqContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterBalancedtoken(CPP14Parser.BalancedtokenContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitBalancedtoken(CPP14Parser.BalancedtokenContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterInitDeclaratorList(CPP14Parser.InitDeclaratorListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitInitDeclaratorList(CPP14Parser.InitDeclaratorListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterInitDeclarator(CPP14Parser.InitDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitInitDeclarator(CPP14Parser.InitDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterDeclarator(CPP14Parser.DeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitDeclarator(CPP14Parser.DeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterPointerDeclarator(CPP14Parser.PointerDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitPointerDeclarator(CPP14Parser.PointerDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterNoPointerDeclarator(CPP14Parser.NoPointerDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitNoPointerDeclarator(CPP14Parser.NoPointerDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterParametersAndQualifiers(CPP14Parser.ParametersAndQualifiersContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitParametersAndQualifiers(CPP14Parser.ParametersAndQualifiersContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTrailingReturnType(CPP14Parser.TrailingReturnTypeContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTrailingReturnType(CPP14Parser.TrailingReturnTypeContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterPointerOperator(CPP14Parser.PointerOperatorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitPointerOperator(CPP14Parser.PointerOperatorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterCvqualifierseq(CPP14Parser.CvqualifierseqContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitCvqualifierseq(CPP14Parser.CvqualifierseqContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterCvQualifier(CPP14Parser.CvQualifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitCvQualifier(CPP14Parser.CvQualifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterRefqualifier(CPP14Parser.RefqualifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitRefqualifier(CPP14Parser.RefqualifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterDeclaratorid(CPP14Parser.DeclaratoridContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitDeclaratorid(CPP14Parser.DeclaratoridContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTheTypeId(CPP14Parser.TheTypeIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTheTypeId(CPP14Parser.TheTypeIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterAbstractDeclarator(CPP14Parser.AbstractDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitAbstractDeclarator(CPP14Parser.AbstractDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterPointerAbstractDeclarator(CPP14Parser.PointerAbstractDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitPointerAbstractDeclarator(CPP14Parser.PointerAbstractDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterNoPointerAbstractDeclarator(CPP14Parser.NoPointerAbstractDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitNoPointerAbstractDeclarator(CPP14Parser.NoPointerAbstractDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterAbstractPackDeclarator(CPP14Parser.AbstractPackDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitAbstractPackDeclarator(CPP14Parser.AbstractPackDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterNoPointerAbstractPackDeclarator(CPP14Parser.NoPointerAbstractPackDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitNoPointerAbstractPackDeclarator(CPP14Parser.NoPointerAbstractPackDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterParameterDeclarationClause(CPP14Parser.ParameterDeclarationClauseContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitParameterDeclarationClause(CPP14Parser.ParameterDeclarationClauseContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterParameterDeclarationList(CPP14Parser.ParameterDeclarationListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitParameterDeclarationList(CPP14Parser.ParameterDeclarationListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterParameterDeclaration(CPP14Parser.ParameterDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitParameterDeclaration(CPP14Parser.ParameterDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterFunctionDefinition(CPP14Parser.FunctionDefinitionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitFunctionDefinition(CPP14Parser.FunctionDefinitionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterFunctionBody(CPP14Parser.FunctionBodyContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitFunctionBody(CPP14Parser.FunctionBodyContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterInitializer(CPP14Parser.InitializerContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitInitializer(CPP14Parser.InitializerContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterBraceOrEqualInitializer(CPP14Parser.BraceOrEqualInitializerContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitBraceOrEqualInitializer(CPP14Parser.BraceOrEqualInitializerContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterInitializerClause(CPP14Parser.InitializerClauseContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitInitializerClause(CPP14Parser.InitializerClauseContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterInitializerList(CPP14Parser.InitializerListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitInitializerList(CPP14Parser.InitializerListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterBracedInitList(CPP14Parser.BracedInitListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitBracedInitList(CPP14Parser.BracedInitListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterClassName(CPP14Parser.ClassNameContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitClassName(CPP14Parser.ClassNameContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterClassSpecifier(CPP14Parser.ClassSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitClassSpecifier(CPP14Parser.ClassSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterClassHead(CPP14Parser.ClassHeadContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitClassHead(CPP14Parser.ClassHeadContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterClassHeadName(CPP14Parser.ClassHeadNameContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitClassHeadName(CPP14Parser.ClassHeadNameContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterClassVirtSpecifier(CPP14Parser.ClassVirtSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitClassVirtSpecifier(CPP14Parser.ClassVirtSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterClassKey(CPP14Parser.ClassKeyContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitClassKey(CPP14Parser.ClassKeyContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterMemberSpecification(CPP14Parser.MemberSpecificationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitMemberSpecification(CPP14Parser.MemberSpecificationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterMemberdeclaration(CPP14Parser.MemberdeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitMemberdeclaration(CPP14Parser.MemberdeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterMemberDeclaratorList(CPP14Parser.MemberDeclaratorListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitMemberDeclaratorList(CPP14Parser.MemberDeclaratorListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterMemberDeclarator(CPP14Parser.MemberDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitMemberDeclarator(CPP14Parser.MemberDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterVirtualSpecifierSeq(CPP14Parser.VirtualSpecifierSeqContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitVirtualSpecifierSeq(CPP14Parser.VirtualSpecifierSeqContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterVirtualSpecifier(CPP14Parser.VirtualSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitVirtualSpecifier(CPP14Parser.VirtualSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterPureSpecifier(CPP14Parser.PureSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitPureSpecifier(CPP14Parser.PureSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterBaseClause(CPP14Parser.BaseClauseContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitBaseClause(CPP14Parser.BaseClauseContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterBaseSpecifierList(CPP14Parser.BaseSpecifierListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitBaseSpecifierList(CPP14Parser.BaseSpecifierListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterBaseSpecifier(CPP14Parser.BaseSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitBaseSpecifier(CPP14Parser.BaseSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterClassOrDeclType(CPP14Parser.ClassOrDeclTypeContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitClassOrDeclType(CPP14Parser.ClassOrDeclTypeContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterBaseTypeSpecifier(CPP14Parser.BaseTypeSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitBaseTypeSpecifier(CPP14Parser.BaseTypeSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterAccessSpecifier(CPP14Parser.AccessSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitAccessSpecifier(CPP14Parser.AccessSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterConversionFunctionId(CPP14Parser.ConversionFunctionIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitConversionFunctionId(CPP14Parser.ConversionFunctionIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterConversionTypeId(CPP14Parser.ConversionTypeIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitConversionTypeId(CPP14Parser.ConversionTypeIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterConversionDeclarator(CPP14Parser.ConversionDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitConversionDeclarator(CPP14Parser.ConversionDeclaratorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterConstructorInitializer(CPP14Parser.ConstructorInitializerContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitConstructorInitializer(CPP14Parser.ConstructorInitializerContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterMemInitializerList(CPP14Parser.MemInitializerListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitMemInitializerList(CPP14Parser.MemInitializerListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterMemInitializer(CPP14Parser.MemInitializerContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitMemInitializer(CPP14Parser.MemInitializerContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterMeminitializerid(CPP14Parser.MeminitializeridContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitMeminitializerid(CPP14Parser.MeminitializeridContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterOperatorFunctionId(CPP14Parser.OperatorFunctionIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitOperatorFunctionId(CPP14Parser.OperatorFunctionIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterLiteralOperatorId(CPP14Parser.LiteralOperatorIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitLiteralOperatorId(CPP14Parser.LiteralOperatorIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTemplateDeclaration(CPP14Parser.TemplateDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTemplateDeclaration(CPP14Parser.TemplateDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTemplateparameterList(CPP14Parser.TemplateparameterListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTemplateparameterList(CPP14Parser.TemplateparameterListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTemplateParameter(CPP14Parser.TemplateParameterContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTemplateParameter(CPP14Parser.TemplateParameterContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTypeParameter(CPP14Parser.TypeParameterContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTypeParameter(CPP14Parser.TypeParameterContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterSimpleTemplateId(CPP14Parser.SimpleTemplateIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitSimpleTemplateId(CPP14Parser.SimpleTemplateIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTemplateId(CPP14Parser.TemplateIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTemplateId(CPP14Parser.TemplateIdContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTemplateName(CPP14Parser.TemplateNameContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTemplateName(CPP14Parser.TemplateNameContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTemplateArgumentList(CPP14Parser.TemplateArgumentListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTemplateArgumentList(CPP14Parser.TemplateArgumentListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTemplateArgument(CPP14Parser.TemplateArgumentContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTemplateArgument(CPP14Parser.TemplateArgumentContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTypeNameSpecifier(CPP14Parser.TypeNameSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTypeNameSpecifier(CPP14Parser.TypeNameSpecifierContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterExplicitInstantiation(CPP14Parser.ExplicitInstantiationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitExplicitInstantiation(CPP14Parser.ExplicitInstantiationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterExplicitSpecialization(CPP14Parser.ExplicitSpecializationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitExplicitSpecialization(CPP14Parser.ExplicitSpecializationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTryBlock(CPP14Parser.TryBlockContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTryBlock(CPP14Parser.TryBlockContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterFunctionTryBlock(CPP14Parser.FunctionTryBlockContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitFunctionTryBlock(CPP14Parser.FunctionTryBlockContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterHandlerSeq(CPP14Parser.HandlerSeqContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitHandlerSeq(CPP14Parser.HandlerSeqContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterHandler(CPP14Parser.HandlerContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitHandler(CPP14Parser.HandlerContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterExceptionDeclaration(CPP14Parser.ExceptionDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitExceptionDeclaration(CPP14Parser.ExceptionDeclarationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterThrowExpression(CPP14Parser.ThrowExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitThrowExpression(CPP14Parser.ThrowExpressionContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterExceptionSpecification(CPP14Parser.ExceptionSpecificationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitExceptionSpecification(CPP14Parser.ExceptionSpecificationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterDynamicExceptionSpecification(CPP14Parser.DynamicExceptionSpecificationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitDynamicExceptionSpecification(CPP14Parser.DynamicExceptionSpecificationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTypeIdList(CPP14Parser.TypeIdListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTypeIdList(CPP14Parser.TypeIdListContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterNoeExceptSpecification(CPP14Parser.NoeExceptSpecificationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitNoeExceptSpecification(CPP14Parser.NoeExceptSpecificationContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterTheOperator(CPP14Parser.TheOperatorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitTheOperator(CPP14Parser.TheOperatorContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterLiteral(CPP14Parser.LiteralContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitLiteral(CPP14Parser.LiteralContext ctx) { }

	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void enterEveryRule(ParserRuleContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void exitEveryRule(ParserRuleContext ctx) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void visitTerminal(TerminalNode node) { }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation does nothing.</p>
	 */
	@Override public void visitErrorNode(ErrorNode node) { }
}
```

`src/main/java/com/lauriewired/malimite/decompile/antlr/CPP14ParserBaseVisitor.java`:

```java
// Generated from CPP14Parser.g4 by ANTLR 4.13.1
package com.lauriewired.malimite.decompile.antlr;
import org.antlr.v4.runtime.tree.AbstractParseTreeVisitor;

/**
 * This class provides an empty implementation of {@link CPP14ParserVisitor},
 * which can be extended to create a visitor which only needs to handle a subset
 * of the available methods.
 *
 * @param <T> The return type of the visit operation. Use {@link Void} for
 * operations with no return type.
 */
@SuppressWarnings("CheckReturnValue")
public class CPP14ParserBaseVisitor<T> extends AbstractParseTreeVisitor<T> implements CPP14ParserVisitor<T> {
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTranslationUnit(CPP14Parser.TranslationUnitContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitPrimaryExpression(CPP14Parser.PrimaryExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitIdExpression(CPP14Parser.IdExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitUnqualifiedId(CPP14Parser.UnqualifiedIdContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitQualifiedId(CPP14Parser.QualifiedIdContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitNestedNameSpecifier(CPP14Parser.NestedNameSpecifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitLambdaExpression(CPP14Parser.LambdaExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitLambdaIntroducer(CPP14Parser.LambdaIntroducerContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitLambdaCapture(CPP14Parser.LambdaCaptureContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitCaptureDefault(CPP14Parser.CaptureDefaultContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitCaptureList(CPP14Parser.CaptureListContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitCapture(CPP14Parser.CaptureContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitSimpleCapture(CPP14Parser.SimpleCaptureContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitInitcapture(CPP14Parser.InitcaptureContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitLambdaDeclarator(CPP14Parser.LambdaDeclaratorContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitPostfixExpression(CPP14Parser.PostfixExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTypeIdOfTheTypeId(CPP14Parser.TypeIdOfTheTypeIdContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitExpressionList(CPP14Parser.ExpressionListContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitPseudoDestructorName(CPP14Parser.PseudoDestructorNameContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitUnaryExpression(CPP14Parser.UnaryExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitUnaryOperator(CPP14Parser.UnaryOperatorContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitNewExpression_(CPP14Parser.NewExpression_Context ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitNewPlacement(CPP14Parser.NewPlacementContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitNewTypeId(CPP14Parser.NewTypeIdContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitNewDeclarator_(CPP14Parser.NewDeclarator_Context ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitNoPointerNewDeclarator(CPP14Parser.NoPointerNewDeclaratorContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitNewInitializer_(CPP14Parser.NewInitializer_Context ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitDeleteExpression(CPP14Parser.DeleteExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitNoExceptExpression(CPP14Parser.NoExceptExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitCastExpression(CPP14Parser.CastExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitPointerMemberExpression(CPP14Parser.PointerMemberExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitMultiplicativeExpression(CPP14Parser.MultiplicativeExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitAdditiveExpression(CPP14Parser.AdditiveExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitShiftExpression(CPP14Parser.ShiftExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitShiftOperator(CPP14Parser.ShiftOperatorContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitRelationalExpression(CPP14Parser.RelationalExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitEqualityExpression(CPP14Parser.EqualityExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitAndExpression(CPP14Parser.AndExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitExclusiveOrExpression(CPP14Parser.ExclusiveOrExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitInclusiveOrExpression(CPP14Parser.InclusiveOrExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitLogicalAndExpression(CPP14Parser.LogicalAndExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitLogicalOrExpression(CPP14Parser.LogicalOrExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitConditionalExpression(CPP14Parser.ConditionalExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitAssignmentExpression(CPP14Parser.AssignmentExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitAssignmentOperator(CPP14Parser.AssignmentOperatorContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitExpression(CPP14Parser.ExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitConstantExpression(CPP14Parser.ConstantExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitStatement(CPP14Parser.StatementContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitLabeledStatement(CPP14Parser.LabeledStatementContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitExpressionStatement(CPP14Parser.ExpressionStatementContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitCompoundStatement(CPP14Parser.CompoundStatementContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitStatementSeq(CPP14Parser.StatementSeqContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitSelectionStatement(CPP14Parser.SelectionStatementContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitCondition(CPP14Parser.ConditionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitIterationStatement(CPP14Parser.IterationStatementContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitForInitStatement(CPP14Parser.ForInitStatementContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitForRangeDeclaration(CPP14Parser.ForRangeDeclarationContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitForRangeInitializer(CPP14Parser.ForRangeInitializerContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitJumpStatement(CPP14Parser.JumpStatementContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitDeclarationStatement(CPP14Parser.DeclarationStatementContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitDeclarationseq(CPP14Parser.DeclarationseqContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitDeclaration(CPP14Parser.DeclarationContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitBlockDeclaration(CPP14Parser.BlockDeclarationContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitAliasDeclaration(CPP14Parser.AliasDeclarationContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitSimpleDeclaration(CPP14Parser.SimpleDeclarationContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitStaticAssertDeclaration(CPP14Parser.StaticAssertDeclarationContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitEmptyDeclaration_(CPP14Parser.EmptyDeclaration_Context ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitAttributeDeclaration(CPP14Parser.AttributeDeclarationContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitDeclSpecifier(CPP14Parser.DeclSpecifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitDeclSpecifierSeq(CPP14Parser.DeclSpecifierSeqContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitStorageClassSpecifier(CPP14Parser.StorageClassSpecifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitFunctionSpecifier(CPP14Parser.FunctionSpecifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTypedefName(CPP14Parser.TypedefNameContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTypeSpecifier(CPP14Parser.TypeSpecifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTrailingTypeSpecifier(CPP14Parser.TrailingTypeSpecifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTypeSpecifierSeq(CPP14Parser.TypeSpecifierSeqContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTrailingTypeSpecifierSeq(CPP14Parser.TrailingTypeSpecifierSeqContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitSimpleTypeLengthModifier(CPP14Parser.SimpleTypeLengthModifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitSimpleTypeSignednessModifier(CPP14Parser.SimpleTypeSignednessModifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitSimpleTypeSpecifier(CPP14Parser.SimpleTypeSpecifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTheTypeName(CPP14Parser.TheTypeNameContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitDecltypeSpecifier(CPP14Parser.DecltypeSpecifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitElaboratedTypeSpecifier(CPP14Parser.ElaboratedTypeSpecifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitEnumName(CPP14Parser.EnumNameContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitEnumSpecifier(CPP14Parser.EnumSpecifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitEnumHead(CPP14Parser.EnumHeadContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitOpaqueEnumDeclaration(CPP14Parser.OpaqueEnumDeclarationContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitEnumkey(CPP14Parser.EnumkeyContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitEnumbase(CPP14Parser.EnumbaseContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitEnumeratorList(CPP14Parser.EnumeratorListContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitEnumeratorDefinition(CPP14Parser.EnumeratorDefinitionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitEnumerator(CPP14Parser.EnumeratorContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitNamespaceName(CPP14Parser.NamespaceNameContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitOriginalNamespaceName(CPP14Parser.OriginalNamespaceNameContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitNamespaceDefinition(CPP14Parser.NamespaceDefinitionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitNamespaceAlias(CPP14Parser.NamespaceAliasContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitNamespaceAliasDefinition(CPP14Parser.NamespaceAliasDefinitionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitQualifiednamespacespecifier(CPP14Parser.QualifiednamespacespecifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitUsingDeclaration(CPP14Parser.UsingDeclarationContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitUsingDirective(CPP14Parser.UsingDirectiveContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitAsmDefinition(CPP14Parser.AsmDefinitionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitLinkageSpecification(CPP14Parser.LinkageSpecificationContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitAttributeSpecifierSeq(CPP14Parser.AttributeSpecifierSeqContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitAttributeSpecifier(CPP14Parser.AttributeSpecifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitAlignmentspecifier(CPP14Parser.AlignmentspecifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitAttributeList(CPP14Parser.AttributeListContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitAttribute(CPP14Parser.AttributeContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitAttributeNamespace(CPP14Parser.AttributeNamespaceContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitAttributeArgumentClause(CPP14Parser.AttributeArgumentClauseContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitBalancedTokenSeq(CPP14Parser.BalancedTokenSeqContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitBalancedtoken(CPP14Parser.BalancedtokenContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitInitDeclaratorList(CPP14Parser.InitDeclaratorListContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitInitDeclarator(CPP14Parser.InitDeclaratorContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitDeclarator(CPP14Parser.DeclaratorContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitPointerDeclarator(CPP14Parser.PointerDeclaratorContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitNoPointerDeclarator(CPP14Parser.NoPointerDeclaratorContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitParametersAndQualifiers(CPP14Parser.ParametersAndQualifiersContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTrailingReturnType(CPP14Parser.TrailingReturnTypeContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitPointerOperator(CPP14Parser.PointerOperatorContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitCvqualifierseq(CPP14Parser.CvqualifierseqContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitCvQualifier(CPP14Parser.CvQualifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitRefqualifier(CPP14Parser.RefqualifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitDeclaratorid(CPP14Parser.DeclaratoridContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTheTypeId(CPP14Parser.TheTypeIdContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitAbstractDeclarator(CPP14Parser.AbstractDeclaratorContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitPointerAbstractDeclarator(CPP14Parser.PointerAbstractDeclaratorContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitNoPointerAbstractDeclarator(CPP14Parser.NoPointerAbstractDeclaratorContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitAbstractPackDeclarator(CPP14Parser.AbstractPackDeclaratorContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitNoPointerAbstractPackDeclarator(CPP14Parser.NoPointerAbstractPackDeclaratorContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitParameterDeclarationClause(CPP14Parser.ParameterDeclarationClauseContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitParameterDeclarationList(CPP14Parser.ParameterDeclarationListContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitParameterDeclaration(CPP14Parser.ParameterDeclarationContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitFunctionDefinition(CPP14Parser.FunctionDefinitionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitFunctionBody(CPP14Parser.FunctionBodyContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitInitializer(CPP14Parser.InitializerContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitBraceOrEqualInitializer(CPP14Parser.BraceOrEqualInitializerContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitInitializerClause(CPP14Parser.InitializerClauseContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitInitializerList(CPP14Parser.InitializerListContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitBracedInitList(CPP14Parser.BracedInitListContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitClassName(CPP14Parser.ClassNameContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitClassSpecifier(CPP14Parser.ClassSpecifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitClassHead(CPP14Parser.ClassHeadContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitClassHeadName(CPP14Parser.ClassHeadNameContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitClassVirtSpecifier(CPP14Parser.ClassVirtSpecifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitClassKey(CPP14Parser.ClassKeyContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitMemberSpecification(CPP14Parser.MemberSpecificationContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitMemberdeclaration(CPP14Parser.MemberdeclarationContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitMemberDeclaratorList(CPP14Parser.MemberDeclaratorListContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitMemberDeclarator(CPP14Parser.MemberDeclaratorContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitVirtualSpecifierSeq(CPP14Parser.VirtualSpecifierSeqContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitVirtualSpecifier(CPP14Parser.VirtualSpecifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitPureSpecifier(CPP14Parser.PureSpecifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitBaseClause(CPP14Parser.BaseClauseContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitBaseSpecifierList(CPP14Parser.BaseSpecifierListContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitBaseSpecifier(CPP14Parser.BaseSpecifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitClassOrDeclType(CPP14Parser.ClassOrDeclTypeContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitBaseTypeSpecifier(CPP14Parser.BaseTypeSpecifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitAccessSpecifier(CPP14Parser.AccessSpecifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitConversionFunctionId(CPP14Parser.ConversionFunctionIdContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitConversionTypeId(CPP14Parser.ConversionTypeIdContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitConversionDeclarator(CPP14Parser.ConversionDeclaratorContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitConstructorInitializer(CPP14Parser.ConstructorInitializerContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitMemInitializerList(CPP14Parser.MemInitializerListContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitMemInitializer(CPP14Parser.MemInitializerContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitMeminitializerid(CPP14Parser.MeminitializeridContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitOperatorFunctionId(CPP14Parser.OperatorFunctionIdContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitLiteralOperatorId(CPP14Parser.LiteralOperatorIdContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTemplateDeclaration(CPP14Parser.TemplateDeclarationContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTemplateparameterList(CPP14Parser.TemplateparameterListContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTemplateParameter(CPP14Parser.TemplateParameterContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTypeParameter(CPP14Parser.TypeParameterContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitSimpleTemplateId(CPP14Parser.SimpleTemplateIdContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTemplateId(CPP14Parser.TemplateIdContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTemplateName(CPP14Parser.TemplateNameContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTemplateArgumentList(CPP14Parser.TemplateArgumentListContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTemplateArgument(CPP14Parser.TemplateArgumentContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTypeNameSpecifier(CPP14Parser.TypeNameSpecifierContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitExplicitInstantiation(CPP14Parser.ExplicitInstantiationContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitExplicitSpecialization(CPP14Parser.ExplicitSpecializationContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTryBlock(CPP14Parser.TryBlockContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitFunctionTryBlock(CPP14Parser.FunctionTryBlockContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitHandlerSeq(CPP14Parser.HandlerSeqContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitHandler(CPP14Parser.HandlerContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitExceptionDeclaration(CPP14Parser.ExceptionDeclarationContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitThrowExpression(CPP14Parser.ThrowExpressionContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitExceptionSpecification(CPP14Parser.ExceptionSpecificationContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitDynamicExceptionSpecification(CPP14Parser.DynamicExceptionSpecificationContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTypeIdList(CPP14Parser.TypeIdListContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitNoeExceptSpecification(CPP14Parser.NoeExceptSpecificationContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitTheOperator(CPP14Parser.TheOperatorContext ctx) { return visitChildren(ctx); }
	/**
	 * {@inheritDoc}
	 *
	 * <p>The default implementation returns the result of calling
	 * {@link #visitChildren} on {@code ctx}.</p>
	 */
	@Override public T visitLiteral(CPP14Parser.LiteralContext ctx) { return visitChildren(ctx); }
}
```

`src/main/java/com/lauriewired/malimite/decompile/antlr/CPP14ParserListener.java`:

```java
// Generated from CPP14Parser.g4 by ANTLR 4.13.1
package com.lauriewired.malimite.decompile.antlr;
import org.antlr.v4.runtime.tree.ParseTreeListener;

/**
 * This interface defines a complete listener for a parse tree produced by
 * {@link CPP14Parser}.
 */
public interface CPP14ParserListener extends ParseTreeListener {
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#translationUnit}.
	 * @param ctx the parse tree
	 */
	void enterTranslationUnit(CPP14Parser.TranslationUnitContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#translationUnit}.
	 * @param ctx the parse tree
	 */
	void exitTranslationUnit(CPP14Parser.TranslationUnitContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#primaryExpression}.
	 * @param ctx the parse tree
	 */
	void enterPrimaryExpression(CPP14Parser.PrimaryExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#primaryExpression}.
	 * @param ctx the parse tree
	 */
	void exitPrimaryExpression(CPP14Parser.PrimaryExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#idExpression}.
	 * @param ctx the parse tree
	 */
	void enterIdExpression(CPP14Parser.IdExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#idExpression}.
	 * @param ctx the parse tree
	 */
	void exitIdExpression(CPP14Parser.IdExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#unqualifiedId}.
	 * @param ctx the parse tree
	 */
	void enterUnqualifiedId(CPP14Parser.UnqualifiedIdContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#unqualifiedId}.
	 * @param ctx the parse tree
	 */
	void exitUnqualifiedId(CPP14Parser.UnqualifiedIdContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#qualifiedId}.
	 * @param ctx the parse tree
	 */
	void enterQualifiedId(CPP14Parser.QualifiedIdContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#qualifiedId}.
	 * @param ctx the parse tree
	 */
	void exitQualifiedId(CPP14Parser.QualifiedIdContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#nestedNameSpecifier}.
	 * @param ctx the parse tree
	 */
	void enterNestedNameSpecifier(CPP14Parser.NestedNameSpecifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#nestedNameSpecifier}.
	 * @param ctx the parse tree
	 */
	void exitNestedNameSpecifier(CPP14Parser.NestedNameSpecifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#lambdaExpression}.
	 * @param ctx the parse tree
	 */
	void enterLambdaExpression(CPP14Parser.LambdaExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#lambdaExpression}.
	 * @param ctx the parse tree
	 */
	void exitLambdaExpression(CPP14Parser.LambdaExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#lambdaIntroducer}.
	 * @param ctx the parse tree
	 */
	void enterLambdaIntroducer(CPP14Parser.LambdaIntroducerContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#lambdaIntroducer}.
	 * @param ctx the parse tree
	 */
	void exitLambdaIntroducer(CPP14Parser.LambdaIntroducerContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#lambdaCapture}.
	 * @param ctx the parse tree
	 */
	void enterLambdaCapture(CPP14Parser.LambdaCaptureContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#lambdaCapture}.
	 * @param ctx the parse tree
	 */
	void exitLambdaCapture(CPP14Parser.LambdaCaptureContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#captureDefault}.
	 * @param ctx the parse tree
	 */
	void enterCaptureDefault(CPP14Parser.CaptureDefaultContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#captureDefault}.
	 * @param ctx the parse tree
	 */
	void exitCaptureDefault(CPP14Parser.CaptureDefaultContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#captureList}.
	 * @param ctx the parse tree
	 */
	void enterCaptureList(CPP14Parser.CaptureListContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#captureList}.
	 * @param ctx the parse tree
	 */
	void exitCaptureList(CPP14Parser.CaptureListContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#capture}.
	 * @param ctx the parse tree
	 */
	void enterCapture(CPP14Parser.CaptureContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#capture}.
	 * @param ctx the parse tree
	 */
	void exitCapture(CPP14Parser.CaptureContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#simpleCapture}.
	 * @param ctx the parse tree
	 */
	void enterSimpleCapture(CPP14Parser.SimpleCaptureContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#simpleCapture}.
	 * @param ctx the parse tree
	 */
	void exitSimpleCapture(CPP14Parser.SimpleCaptureContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#initcapture}.
	 * @param ctx the parse tree
	 */
	void enterInitcapture(CPP14Parser.InitcaptureContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#initcapture}.
	 * @param ctx the parse tree
	 */
	void exitInitcapture(CPP14Parser.InitcaptureContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#lambdaDeclarator}.
	 * @param ctx the parse tree
	 */
	void enterLambdaDeclarator(CPP14Parser.LambdaDeclaratorContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#lambdaDeclarator}.
	 * @param ctx the parse tree
	 */
	void exitLambdaDeclarator(CPP14Parser.LambdaDeclaratorContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#postfixExpression}.
	 * @param ctx the parse tree
	 */
	void enterPostfixExpression(CPP14Parser.PostfixExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#postfixExpression}.
	 * @param ctx the parse tree
	 */
	void exitPostfixExpression(CPP14Parser.PostfixExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#typeIdOfTheTypeId}.
	 * @param ctx the parse tree
	 */
	void enterTypeIdOfTheTypeId(CPP14Parser.TypeIdOfTheTypeIdContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#typeIdOfTheTypeId}.
	 * @param ctx the parse tree
	 */
	void exitTypeIdOfTheTypeId(CPP14Parser.TypeIdOfTheTypeIdContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#expressionList}.
	 * @param ctx the parse tree
	 */
	void enterExpressionList(CPP14Parser.ExpressionListContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#expressionList}.
	 * @param ctx the parse tree
	 */
	void exitExpressionList(CPP14Parser.ExpressionListContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#pseudoDestructorName}.
	 * @param ctx the parse tree
	 */
	void enterPseudoDestructorName(CPP14Parser.PseudoDestructorNameContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#pseudoDestructorName}.
	 * @param ctx the parse tree
	 */
	void exitPseudoDestructorName(CPP14Parser.PseudoDestructorNameContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#unaryExpression}.
	 * @param ctx the parse tree
	 */
	void enterUnaryExpression(CPP14Parser.UnaryExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#unaryExpression}.
	 * @param ctx the parse tree
	 */
	void exitUnaryExpression(CPP14Parser.UnaryExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#unaryOperator}.
	 * @param ctx the parse tree
	 */
	void enterUnaryOperator(CPP14Parser.UnaryOperatorContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#unaryOperator}.
	 * @param ctx the parse tree
	 */
	void exitUnaryOperator(CPP14Parser.UnaryOperatorContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#newExpression_}.
	 * @param ctx the parse tree
	 */
	void enterNewExpression_(CPP14Parser.NewExpression_Context ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#newExpression_}.
	 * @param ctx the parse tree
	 */
	void exitNewExpression_(CPP14Parser.NewExpression_Context ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#newPlacement}.
	 * @param ctx the parse tree
	 */
	void enterNewPlacement(CPP14Parser.NewPlacementContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#newPlacement}.
	 * @param ctx the parse tree
	 */
	void exitNewPlacement(CPP14Parser.NewPlacementContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#newTypeId}.
	 * @param ctx the parse tree
	 */
	void enterNewTypeId(CPP14Parser.NewTypeIdContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#newTypeId}.
	 * @param ctx the parse tree
	 */
	void exitNewTypeId(CPP14Parser.NewTypeIdContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#newDeclarator_}.
	 * @param ctx the parse tree
	 */
	void enterNewDeclarator_(CPP14Parser.NewDeclarator_Context ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#newDeclarator_}.
	 * @param ctx the parse tree
	 */
	void exitNewDeclarator_(CPP14Parser.NewDeclarator_Context ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#noPointerNewDeclarator}.
	 * @param ctx the parse tree
	 */
	void enterNoPointerNewDeclarator(CPP14Parser.NoPointerNewDeclaratorContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#noPointerNewDeclarator}.
	 * @param ctx the parse tree
	 */
	void exitNoPointerNewDeclarator(CPP14Parser.NoPointerNewDeclaratorContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#newInitializer_}.
	 * @param ctx the parse tree
	 */
	void enterNewInitializer_(CPP14Parser.NewInitializer_Context ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#newInitializer_}.
	 * @param ctx the parse tree
	 */
	void exitNewInitializer_(CPP14Parser.NewInitializer_Context ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#deleteExpression}.
	 * @param ctx the parse tree
	 */
	void enterDeleteExpression(CPP14Parser.DeleteExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#deleteExpression}.
	 * @param ctx the parse tree
	 */
	void exitDeleteExpression(CPP14Parser.DeleteExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#noExceptExpression}.
	 * @param ctx the parse tree
	 */
	void enterNoExceptExpression(CPP14Parser.NoExceptExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#noExceptExpression}.
	 * @param ctx the parse tree
	 */
	void exitNoExceptExpression(CPP14Parser.NoExceptExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#castExpression}.
	 * @param ctx the parse tree
	 */
	void enterCastExpression(CPP14Parser.CastExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#castExpression}.
	 * @param ctx the parse tree
	 */
	void exitCastExpression(CPP14Parser.CastExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#pointerMemberExpression}.
	 * @param ctx the parse tree
	 */
	void enterPointerMemberExpression(CPP14Parser.PointerMemberExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#pointerMemberExpression}.
	 * @param ctx the parse tree
	 */
	void exitPointerMemberExpression(CPP14Parser.PointerMemberExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#multiplicativeExpression}.
	 * @param ctx the parse tree
	 */
	void enterMultiplicativeExpression(CPP14Parser.MultiplicativeExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#multiplicativeExpression}.
	 * @param ctx the parse tree
	 */
	void exitMultiplicativeExpression(CPP14Parser.MultiplicativeExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#additiveExpression}.
	 * @param ctx the parse tree
	 */
	void enterAdditiveExpression(CPP14Parser.AdditiveExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#additiveExpression}.
	 * @param ctx the parse tree
	 */
	void exitAdditiveExpression(CPP14Parser.AdditiveExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#shiftExpression}.
	 * @param ctx the parse tree
	 */
	void enterShiftExpression(CPP14Parser.ShiftExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#shiftExpression}.
	 * @param ctx the parse tree
	 */
	void exitShiftExpression(CPP14Parser.ShiftExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#shiftOperator}.
	 * @param ctx the parse tree
	 */
	void enterShiftOperator(CPP14Parser.ShiftOperatorContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#shiftOperator}.
	 * @param ctx the parse tree
	 */
	void exitShiftOperator(CPP14Parser.ShiftOperatorContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#relationalExpression}.
	 * @param ctx the parse tree
	 */
	void enterRelationalExpression(CPP14Parser.RelationalExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#relationalExpression}.
	 * @param ctx the parse tree
	 */
	void exitRelationalExpression(CPP14Parser.RelationalExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#equalityExpression}.
	 * @param ctx the parse tree
	 */
	void enterEqualityExpression(CPP14Parser.EqualityExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#equalityExpression}.
	 * @param ctx the parse tree
	 */
	void exitEqualityExpression(CPP14Parser.EqualityExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#andExpression}.
	 * @param ctx the parse tree
	 */
	void enterAndExpression(CPP14Parser.AndExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#andExpression}.
	 * @param ctx the parse tree
	 */
	void exitAndExpression(CPP14Parser.AndExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#exclusiveOrExpression}.
	 * @param ctx the parse tree
	 */
	void enterExclusiveOrExpression(CPP14Parser.ExclusiveOrExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#exclusiveOrExpression}.
	 * @param ctx the parse tree
	 */
	void exitExclusiveOrExpression(CPP14Parser.ExclusiveOrExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#inclusiveOrExpression}.
	 * @param ctx the parse tree
	 */
	void enterInclusiveOrExpression(CPP14Parser.InclusiveOrExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#inclusiveOrExpression}.
	 * @param ctx the parse tree
	 */
	void exitInclusiveOrExpression(CPP14Parser.InclusiveOrExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#logicalAndExpression}.
	 * @param ctx the parse tree
	 */
	void enterLogicalAndExpression(CPP14Parser.LogicalAndExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#logicalAndExpression}.
	 * @param ctx the parse tree
	 */
	void exitLogicalAndExpression(CPP14Parser.LogicalAndExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#logicalOrExpression}.
	 * @param ctx the parse tree
	 */
	void enterLogicalOrExpression(CPP14Parser.LogicalOrExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#logicalOrExpression}.
	 * @param ctx the parse tree
	 */
	void exitLogicalOrExpression(CPP14Parser.LogicalOrExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#conditionalExpression}.
	 * @param ctx the parse tree
	 */
	void enterConditionalExpression(CPP14Parser.ConditionalExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#conditionalExpression}.
	 * @param ctx the parse tree
	 */
	void exitConditionalExpression(CPP14Parser.ConditionalExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#assignmentExpression}.
	 * @param ctx the parse tree
	 */
	void enterAssignmentExpression(CPP14Parser.AssignmentExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#assignmentExpression}.
	 * @param ctx the parse tree
	 */
	void exitAssignmentExpression(CPP14Parser.AssignmentExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#assignmentOperator}.
	 * @param ctx the parse tree
	 */
	void enterAssignmentOperator(CPP14Parser.AssignmentOperatorContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#assignmentOperator}.
	 * @param ctx the parse tree
	 */
	void exitAssignmentOperator(CPP14Parser.AssignmentOperatorContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#expression}.
	 * @param ctx the parse tree
	 */
	void enterExpression(CPP14Parser.ExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#expression}.
	 * @param ctx the parse tree
	 */
	void exitExpression(CPP14Parser.ExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#constantExpression}.
	 * @param ctx the parse tree
	 */
	void enterConstantExpression(CPP14Parser.ConstantExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#constantExpression}.
	 * @param ctx the parse tree
	 */
	void exitConstantExpression(CPP14Parser.ConstantExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#statement}.
	 * @param ctx the parse tree
	 */
	void enterStatement(CPP14Parser.StatementContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#statement}.
	 * @param ctx the parse tree
	 */
	void exitStatement(CPP14Parser.StatementContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#labeledStatement}.
	 * @param ctx the parse tree
	 */
	void enterLabeledStatement(CPP14Parser.LabeledStatementContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#labeledStatement}.
	 * @param ctx the parse tree
	 */
	void exitLabeledStatement(CPP14Parser.LabeledStatementContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#expressionStatement}.
	 * @param ctx the parse tree
	 */
	void enterExpressionStatement(CPP14Parser.ExpressionStatementContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#expressionStatement}.
	 * @param ctx the parse tree
	 */
	void exitExpressionStatement(CPP14Parser.ExpressionStatementContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#compoundStatement}.
	 * @param ctx the parse tree
	 */
	void enterCompoundStatement(CPP14Parser.CompoundStatementContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#compoundStatement}.
	 * @param ctx the parse tree
	 */
	void exitCompoundStatement(CPP14Parser.CompoundStatementContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#statementSeq}.
	 * @param ctx the parse tree
	 */
	void enterStatementSeq(CPP14Parser.StatementSeqContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#statementSeq}.
	 * @param ctx the parse tree
	 */
	void exitStatementSeq(CPP14Parser.StatementSeqContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#selectionStatement}.
	 * @param ctx the parse tree
	 */
	void enterSelectionStatement(CPP14Parser.SelectionStatementContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#selectionStatement}.
	 * @param ctx the parse tree
	 */
	void exitSelectionStatement(CPP14Parser.SelectionStatementContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#condition}.
	 * @param ctx the parse tree
	 */
	void enterCondition(CPP14Parser.ConditionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#condition}.
	 * @param ctx the parse tree
	 */
	void exitCondition(CPP14Parser.ConditionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#iterationStatement}.
	 * @param ctx the parse tree
	 */
	void enterIterationStatement(CPP14Parser.IterationStatementContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#iterationStatement}.
	 * @param ctx the parse tree
	 */
	void exitIterationStatement(CPP14Parser.IterationStatementContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#forInitStatement}.
	 * @param ctx the parse tree
	 */
	void enterForInitStatement(CPP14Parser.ForInitStatementContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#forInitStatement}.
	 * @param ctx the parse tree
	 */
	void exitForInitStatement(CPP14Parser.ForInitStatementContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#forRangeDeclaration}.
	 * @param ctx the parse tree
	 */
	void enterForRangeDeclaration(CPP14Parser.ForRangeDeclarationContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#forRangeDeclaration}.
	 * @param ctx the parse tree
	 */
	void exitForRangeDeclaration(CPP14Parser.ForRangeDeclarationContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#forRangeInitializer}.
	 * @param ctx the parse tree
	 */
	void enterForRangeInitializer(CPP14Parser.ForRangeInitializerContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#forRangeInitializer}.
	 * @param ctx the parse tree
	 */
	void exitForRangeInitializer(CPP14Parser.ForRangeInitializerContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#jumpStatement}.
	 * @param ctx the parse tree
	 */
	void enterJumpStatement(CPP14Parser.JumpStatementContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#jumpStatement}.
	 * @param ctx the parse tree
	 */
	void exitJumpStatement(CPP14Parser.JumpStatementContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#declarationStatement}.
	 * @param ctx the parse tree
	 */
	void enterDeclarationStatement(CPP14Parser.DeclarationStatementContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#declarationStatement}.
	 * @param ctx the parse tree
	 */
	void exitDeclarationStatement(CPP14Parser.DeclarationStatementContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#declarationseq}.
	 * @param ctx the parse tree
	 */
	void enterDeclarationseq(CPP14Parser.DeclarationseqContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#declarationseq}.
	 * @param ctx the parse tree
	 */
	void exitDeclarationseq(CPP14Parser.DeclarationseqContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#declaration}.
	 * @param ctx the parse tree
	 */
	void enterDeclaration(CPP14Parser.DeclarationContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#declaration}.
	 * @param ctx the parse tree
	 */
	void exitDeclaration(CPP14Parser.DeclarationContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#blockDeclaration}.
	 * @param ctx the parse tree
	 */
	void enterBlockDeclaration(CPP14Parser.BlockDeclarationContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#blockDeclaration}.
	 * @param ctx the parse tree
	 */
	void exitBlockDeclaration(CPP14Parser.BlockDeclarationContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#aliasDeclaration}.
	 * @param ctx the parse tree
	 */
	void enterAliasDeclaration(CPP14Parser.AliasDeclarationContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#aliasDeclaration}.
	 * @param ctx the parse tree
	 */
	void exitAliasDeclaration(CPP14Parser.AliasDeclarationContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#simpleDeclaration}.
	 * @param ctx the parse tree
	 */
	void enterSimpleDeclaration(CPP14Parser.SimpleDeclarationContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#simpleDeclaration}.
	 * @param ctx the parse tree
	 */
	void exitSimpleDeclaration(CPP14Parser.SimpleDeclarationContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#staticAssertDeclaration}.
	 * @param ctx the parse tree
	 */
	void enterStaticAssertDeclaration(CPP14Parser.StaticAssertDeclarationContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#staticAssertDeclaration}.
	 * @param ctx the parse tree
	 */
	void exitStaticAssertDeclaration(CPP14Parser.StaticAssertDeclarationContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#emptyDeclaration_}.
	 * @param ctx the parse tree
	 */
	void enterEmptyDeclaration_(CPP14Parser.EmptyDeclaration_Context ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#emptyDeclaration_}.
	 * @param ctx the parse tree
	 */
	void exitEmptyDeclaration_(CPP14Parser.EmptyDeclaration_Context ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#attributeDeclaration}.
	 * @param ctx the parse tree
	 */
	void enterAttributeDeclaration(CPP14Parser.AttributeDeclarationContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#attributeDeclaration}.
	 * @param ctx the parse tree
	 */
	void exitAttributeDeclaration(CPP14Parser.AttributeDeclarationContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#declSpecifier}.
	 * @param ctx the parse tree
	 */
	void enterDeclSpecifier(CPP14Parser.DeclSpecifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#declSpecifier}.
	 * @param ctx the parse tree
	 */
	void exitDeclSpecifier(CPP14Parser.DeclSpecifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#declSpecifierSeq}.
	 * @param ctx the parse tree
	 */
	void enterDeclSpecifierSeq(CPP14Parser.DeclSpecifierSeqContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#declSpecifierSeq}.
	 * @param ctx the parse tree
	 */
	void exitDeclSpecifierSeq(CPP14Parser.DeclSpecifierSeqContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#storageClassSpecifier}.
	 * @param ctx the parse tree
	 */
	void enterStorageClassSpecifier(CPP14Parser.StorageClassSpecifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#storageClassSpecifier}.
	 * @param ctx the parse tree
	 */
	void exitStorageClassSpecifier(CPP14Parser.StorageClassSpecifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#functionSpecifier}.
	 * @param ctx the parse tree
	 */
	void enterFunctionSpecifier(CPP14Parser.FunctionSpecifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#functionSpecifier}.
	 * @param ctx the parse tree
	 */
	void exitFunctionSpecifier(CPP14Parser.FunctionSpecifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#typedefName}.
	 * @param ctx the parse tree
	 */
	void enterTypedefName(CPP14Parser.TypedefNameContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#typedefName}.
	 * @param ctx the parse tree
	 */
	void exitTypedefName(CPP14Parser.TypedefNameContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#typeSpecifier}.
	 * @param ctx the parse tree
	 */
	void enterTypeSpecifier(CPP14Parser.TypeSpecifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#typeSpecifier}.
	 * @param ctx the parse tree
	 */
	void exitTypeSpecifier(CPP14Parser.TypeSpecifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#trailingTypeSpecifier}.
	 * @param ctx the parse tree
	 */
	void enterTrailingTypeSpecifier(CPP14Parser.TrailingTypeSpecifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#trailingTypeSpecifier}.
	 * @param ctx the parse tree
	 */
	void exitTrailingTypeSpecifier(CPP14Parser.TrailingTypeSpecifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#typeSpecifierSeq}.
	 * @param ctx the parse tree
	 */
	void enterTypeSpecifierSeq(CPP14Parser.TypeSpecifierSeqContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#typeSpecifierSeq}.
	 * @param ctx the parse tree
	 */
	void exitTypeSpecifierSeq(CPP14Parser.TypeSpecifierSeqContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#trailingTypeSpecifierSeq}.
	 * @param ctx the parse tree
	 */
	void enterTrailingTypeSpecifierSeq(CPP14Parser.TrailingTypeSpecifierSeqContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#trailingTypeSpecifierSeq}.
	 * @param ctx the parse tree
	 */
	void exitTrailingTypeSpecifierSeq(CPP14Parser.TrailingTypeSpecifierSeqContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#simpleTypeLengthModifier}.
	 * @param ctx the parse tree
	 */
	void enterSimpleTypeLengthModifier(CPP14Parser.SimpleTypeLengthModifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#simpleTypeLengthModifier}.
	 * @param ctx the parse tree
	 */
	void exitSimpleTypeLengthModifier(CPP14Parser.SimpleTypeLengthModifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#simpleTypeSignednessModifier}.
	 * @param ctx the parse tree
	 */
	void enterSimpleTypeSignednessModifier(CPP14Parser.SimpleTypeSignednessModifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#simpleTypeSignednessModifier}.
	 * @param ctx the parse tree
	 */
	void exitSimpleTypeSignednessModifier(CPP14Parser.SimpleTypeSignednessModifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#simpleTypeSpecifier}.
	 * @param ctx the parse tree
	 */
	void enterSimpleTypeSpecifier(CPP14Parser.SimpleTypeSpecifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#simpleTypeSpecifier}.
	 * @param ctx the parse tree
	 */
	void exitSimpleTypeSpecifier(CPP14Parser.SimpleTypeSpecifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#theTypeName}.
	 * @param ctx the parse tree
	 */
	void enterTheTypeName(CPP14Parser.TheTypeNameContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#theTypeName}.
	 * @param ctx the parse tree
	 */
	void exitTheTypeName(CPP14Parser.TheTypeNameContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#decltypeSpecifier}.
	 * @param ctx the parse tree
	 */
	void enterDecltypeSpecifier(CPP14Parser.DecltypeSpecifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#decltypeSpecifier}.
	 * @param ctx the parse tree
	 */
	void exitDecltypeSpecifier(CPP14Parser.DecltypeSpecifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#elaboratedTypeSpecifier}.
	 * @param ctx the parse tree
	 */
	void enterElaboratedTypeSpecifier(CPP14Parser.ElaboratedTypeSpecifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#elaboratedTypeSpecifier}.
	 * @param ctx the parse tree
	 */
	void exitElaboratedTypeSpecifier(CPP14Parser.ElaboratedTypeSpecifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#enumName}.
	 * @param ctx the parse tree
	 */
	void enterEnumName(CPP14Parser.EnumNameContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#enumName}.
	 * @param ctx the parse tree
	 */
	void exitEnumName(CPP14Parser.EnumNameContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#enumSpecifier}.
	 * @param ctx the parse tree
	 */
	void enterEnumSpecifier(CPP14Parser.EnumSpecifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#enumSpecifier}.
	 * @param ctx the parse tree
	 */
	void exitEnumSpecifier(CPP14Parser.EnumSpecifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#enumHead}.
	 * @param ctx the parse tree
	 */
	void enterEnumHead(CPP14Parser.EnumHeadContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#enumHead}.
	 * @param ctx the parse tree
	 */
	void exitEnumHead(CPP14Parser.EnumHeadContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#opaqueEnumDeclaration}.
	 * @param ctx the parse tree
	 */
	void enterOpaqueEnumDeclaration(CPP14Parser.OpaqueEnumDeclarationContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#opaqueEnumDeclaration}.
	 * @param ctx the parse tree
	 */
	void exitOpaqueEnumDeclaration(CPP14Parser.OpaqueEnumDeclarationContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#enumkey}.
	 * @param ctx the parse tree
	 */
	void enterEnumkey(CPP14Parser.EnumkeyContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#enumkey}.
	 * @param ctx the parse tree
	 */
	void exitEnumkey(CPP14Parser.EnumkeyContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#enumbase}.
	 * @param ctx the parse tree
	 */
	void enterEnumbase(CPP14Parser.EnumbaseContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#enumbase}.
	 * @param ctx the parse tree
	 */
	void exitEnumbase(CPP14Parser.EnumbaseContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#enumeratorList}.
	 * @param ctx the parse tree
	 */
	void enterEnumeratorList(CPP14Parser.EnumeratorListContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#enumeratorList}.
	 * @param ctx the parse tree
	 */
	void exitEnumeratorList(CPP14Parser.EnumeratorListContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#enumeratorDefinition}.
	 * @param ctx the parse tree
	 */
	void enterEnumeratorDefinition(CPP14Parser.EnumeratorDefinitionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#enumeratorDefinition}.
	 * @param ctx the parse tree
	 */
	void exitEnumeratorDefinition(CPP14Parser.EnumeratorDefinitionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#enumerator}.
	 * @param ctx the parse tree
	 */
	void enterEnumerator(CPP14Parser.EnumeratorContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#enumerator}.
	 * @param ctx the parse tree
	 */
	void exitEnumerator(CPP14Parser.EnumeratorContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#namespaceName}.
	 * @param ctx the parse tree
	 */
	void enterNamespaceName(CPP14Parser.NamespaceNameContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#namespaceName}.
	 * @param ctx the parse tree
	 */
	void exitNamespaceName(CPP14Parser.NamespaceNameContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#originalNamespaceName}.
	 * @param ctx the parse tree
	 */
	void enterOriginalNamespaceName(CPP14Parser.OriginalNamespaceNameContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#originalNamespaceName}.
	 * @param ctx the parse tree
	 */
	void exitOriginalNamespaceName(CPP14Parser.OriginalNamespaceNameContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#namespaceDefinition}.
	 * @param ctx the parse tree
	 */
	void enterNamespaceDefinition(CPP14Parser.NamespaceDefinitionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#namespaceDefinition}.
	 * @param ctx the parse tree
	 */
	void exitNamespaceDefinition(CPP14Parser.NamespaceDefinitionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#namespaceAlias}.
	 * @param ctx the parse tree
	 */
	void enterNamespaceAlias(CPP14Parser.NamespaceAliasContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#namespaceAlias}.
	 * @param ctx the parse tree
	 */
	void exitNamespaceAlias(CPP14Parser.NamespaceAliasContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#namespaceAliasDefinition}.
	 * @param ctx the parse tree
	 */
	void enterNamespaceAliasDefinition(CPP14Parser.NamespaceAliasDefinitionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#namespaceAliasDefinition}.
	 * @param ctx the parse tree
	 */
	void exitNamespaceAliasDefinition(CPP14Parser.NamespaceAliasDefinitionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#qualifiednamespacespecifier}.
	 * @param ctx the parse tree
	 */
	void enterQualifiednamespacespecifier(CPP14Parser.QualifiednamespacespecifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#qualifiednamespacespecifier}.
	 * @param ctx the parse tree
	 */
	void exitQualifiednamespacespecifier(CPP14Parser.QualifiednamespacespecifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#usingDeclaration}.
	 * @param ctx the parse tree
	 */
	void enterUsingDeclaration(CPP14Parser.UsingDeclarationContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#usingDeclaration}.
	 * @param ctx the parse tree
	 */
	void exitUsingDeclaration(CPP14Parser.UsingDeclarationContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#usingDirective}.
	 * @param ctx the parse tree
	 */
	void enterUsingDirective(CPP14Parser.UsingDirectiveContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#usingDirective}.
	 * @param ctx the parse tree
	 */
	void exitUsingDirective(CPP14Parser.UsingDirectiveContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#asmDefinition}.
	 * @param ctx the parse tree
	 */
	void enterAsmDefinition(CPP14Parser.AsmDefinitionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#asmDefinition}.
	 * @param ctx the parse tree
	 */
	void exitAsmDefinition(CPP14Parser.AsmDefinitionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#linkageSpecification}.
	 * @param ctx the parse tree
	 */
	void enterLinkageSpecification(CPP14Parser.LinkageSpecificationContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#linkageSpecification}.
	 * @param ctx the parse tree
	 */
	void exitLinkageSpecification(CPP14Parser.LinkageSpecificationContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#attributeSpecifierSeq}.
	 * @param ctx the parse tree
	 */
	void enterAttributeSpecifierSeq(CPP14Parser.AttributeSpecifierSeqContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#attributeSpecifierSeq}.
	 * @param ctx the parse tree
	 */
	void exitAttributeSpecifierSeq(CPP14Parser.AttributeSpecifierSeqContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#attributeSpecifier}.
	 * @param ctx the parse tree
	 */
	void enterAttributeSpecifier(CPP14Parser.AttributeSpecifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#attributeSpecifier}.
	 * @param ctx the parse tree
	 */
	void exitAttributeSpecifier(CPP14Parser.AttributeSpecifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#alignmentspecifier}.
	 * @param ctx the parse tree
	 */
	void enterAlignmentspecifier(CPP14Parser.AlignmentspecifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#alignmentspecifier}.
	 * @param ctx the parse tree
	 */
	void exitAlignmentspecifier(CPP14Parser.AlignmentspecifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#attributeList}.
	 * @param ctx the parse tree
	 */
	void enterAttributeList(CPP14Parser.AttributeListContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#attributeList}.
	 * @param ctx the parse tree
	 */
	void exitAttributeList(CPP14Parser.AttributeListContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#attribute}.
	 * @param ctx the parse tree
	 */
	void enterAttribute(CPP14Parser.AttributeContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#attribute}.
	 * @param ctx the parse tree
	 */
	void exitAttribute(CPP14Parser.AttributeContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#attributeNamespace}.
	 * @param ctx the parse tree
	 */
	void enterAttributeNamespace(CPP14Parser.AttributeNamespaceContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#attributeNamespace}.
	 * @param ctx the parse tree
	 */
	void exitAttributeNamespace(CPP14Parser.AttributeNamespaceContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#attributeArgumentClause}.
	 * @param ctx the parse tree
	 */
	void enterAttributeArgumentClause(CPP14Parser.AttributeArgumentClauseContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#attributeArgumentClause}.
	 * @param ctx the parse tree
	 */
	void exitAttributeArgumentClause(CPP14Parser.AttributeArgumentClauseContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#balancedTokenSeq}.
	 * @param ctx the parse tree
	 */
	void enterBalancedTokenSeq(CPP14Parser.BalancedTokenSeqContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#balancedTokenSeq}.
	 * @param ctx the parse tree
	 */
	void exitBalancedTokenSeq(CPP14Parser.BalancedTokenSeqContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#balancedtoken}.
	 * @param ctx the parse tree
	 */
	void enterBalancedtoken(CPP14Parser.BalancedtokenContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#balancedtoken}.
	 * @param ctx the parse tree
	 */
	void exitBalancedtoken(CPP14Parser.BalancedtokenContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#initDeclaratorList}.
	 * @param ctx the parse tree
	 */
	void enterInitDeclaratorList(CPP14Parser.InitDeclaratorListContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#initDeclaratorList}.
	 * @param ctx the parse tree
	 */
	void exitInitDeclaratorList(CPP14Parser.InitDeclaratorListContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#initDeclarator}.
	 * @param ctx the parse tree
	 */
	void enterInitDeclarator(CPP14Parser.InitDeclaratorContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#initDeclarator}.
	 * @param ctx the parse tree
	 */
	void exitInitDeclarator(CPP14Parser.InitDeclaratorContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#declarator}.
	 * @param ctx the parse tree
	 */
	void enterDeclarator(CPP14Parser.DeclaratorContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#declarator}.
	 * @param ctx the parse tree
	 */
	void exitDeclarator(CPP14Parser.DeclaratorContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#pointerDeclarator}.
	 * @param ctx the parse tree
	 */
	void enterPointerDeclarator(CPP14Parser.PointerDeclaratorContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#pointerDeclarator}.
	 * @param ctx the parse tree
	 */
	void exitPointerDeclarator(CPP14Parser.PointerDeclaratorContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#noPointerDeclarator}.
	 * @param ctx the parse tree
	 */
	void enterNoPointerDeclarator(CPP14Parser.NoPointerDeclaratorContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#noPointerDeclarator}.
	 * @param ctx the parse tree
	 */
	void exitNoPointerDeclarator(CPP14Parser.NoPointerDeclaratorContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#parametersAndQualifiers}.
	 * @param ctx the parse tree
	 */
	void enterParametersAndQualifiers(CPP14Parser.ParametersAndQualifiersContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#parametersAndQualifiers}.
	 * @param ctx the parse tree
	 */
	void exitParametersAndQualifiers(CPP14Parser.ParametersAndQualifiersContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#trailingReturnType}.
	 * @param ctx the parse tree
	 */
	void enterTrailingReturnType(CPP14Parser.TrailingReturnTypeContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#trailingReturnType}.
	 * @param ctx the parse tree
	 */
	void exitTrailingReturnType(CPP14Parser.TrailingReturnTypeContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#pointerOperator}.
	 * @param ctx the parse tree
	 */
	void enterPointerOperator(CPP14Parser.PointerOperatorContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#pointerOperator}.
	 * @param ctx the parse tree
	 */
	void exitPointerOperator(CPP14Parser.PointerOperatorContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#cvqualifierseq}.
	 * @param ctx the parse tree
	 */
	void enterCvqualifierseq(CPP14Parser.CvqualifierseqContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#cvqualifierseq}.
	 * @param ctx the parse tree
	 */
	void exitCvqualifierseq(CPP14Parser.CvqualifierseqContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#cvQualifier}.
	 * @param ctx the parse tree
	 */
	void enterCvQualifier(CPP14Parser.CvQualifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#cvQualifier}.
	 * @param ctx the parse tree
	 */
	void exitCvQualifier(CPP14Parser.CvQualifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#refqualifier}.
	 * @param ctx the parse tree
	 */
	void enterRefqualifier(CPP14Parser.RefqualifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#refqualifier}.
	 * @param ctx the parse tree
	 */
	void exitRefqualifier(CPP14Parser.RefqualifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#declaratorid}.
	 * @param ctx the parse tree
	 */
	void enterDeclaratorid(CPP14Parser.DeclaratoridContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#declaratorid}.
	 * @param ctx the parse tree
	 */
	void exitDeclaratorid(CPP14Parser.DeclaratoridContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#theTypeId}.
	 * @param ctx the parse tree
	 */
	void enterTheTypeId(CPP14Parser.TheTypeIdContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#theTypeId}.
	 * @param ctx the parse tree
	 */
	void exitTheTypeId(CPP14Parser.TheTypeIdContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#abstractDeclarator}.
	 * @param ctx the parse tree
	 */
	void enterAbstractDeclarator(CPP14Parser.AbstractDeclaratorContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#abstractDeclarator}.
	 * @param ctx the parse tree
	 */
	void exitAbstractDeclarator(CPP14Parser.AbstractDeclaratorContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#pointerAbstractDeclarator}.
	 * @param ctx the parse tree
	 */
	void enterPointerAbstractDeclarator(CPP14Parser.PointerAbstractDeclaratorContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#pointerAbstractDeclarator}.
	 * @param ctx the parse tree
	 */
	void exitPointerAbstractDeclarator(CPP14Parser.PointerAbstractDeclaratorContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#noPointerAbstractDeclarator}.
	 * @param ctx the parse tree
	 */
	void enterNoPointerAbstractDeclarator(CPP14Parser.NoPointerAbstractDeclaratorContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#noPointerAbstractDeclarator}.
	 * @param ctx the parse tree
	 */
	void exitNoPointerAbstractDeclarator(CPP14Parser.NoPointerAbstractDeclaratorContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#abstractPackDeclarator}.
	 * @param ctx the parse tree
	 */
	void enterAbstractPackDeclarator(CPP14Parser.AbstractPackDeclaratorContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#abstractPackDeclarator}.
	 * @param ctx the parse tree
	 */
	void exitAbstractPackDeclarator(CPP14Parser.AbstractPackDeclaratorContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#noPointerAbstractPackDeclarator}.
	 * @param ctx the parse tree
	 */
	void enterNoPointerAbstractPackDeclarator(CPP14Parser.NoPointerAbstractPackDeclaratorContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#noPointerAbstractPackDeclarator}.
	 * @param ctx the parse tree
	 */
	void exitNoPointerAbstractPackDeclarator(CPP14Parser.NoPointerAbstractPackDeclaratorContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#parameterDeclarationClause}.
	 * @param ctx the parse tree
	 */
	void enterParameterDeclarationClause(CPP14Parser.ParameterDeclarationClauseContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#parameterDeclarationClause}.
	 * @param ctx the parse tree
	 */
	void exitParameterDeclarationClause(CPP14Parser.ParameterDeclarationClauseContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#parameterDeclarationList}.
	 * @param ctx the parse tree
	 */
	void enterParameterDeclarationList(CPP14Parser.ParameterDeclarationListContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#parameterDeclarationList}.
	 * @param ctx the parse tree
	 */
	void exitParameterDeclarationList(CPP14Parser.ParameterDeclarationListContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#parameterDeclaration}.
	 * @param ctx the parse tree
	 */
	void enterParameterDeclaration(CPP14Parser.ParameterDeclarationContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#parameterDeclaration}.
	 * @param ctx the parse tree
	 */
	void exitParameterDeclaration(CPP14Parser.ParameterDeclarationContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#functionDefinition}.
	 * @param ctx the parse tree
	 */
	void enterFunctionDefinition(CPP14Parser.FunctionDefinitionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#functionDefinition}.
	 * @param ctx the parse tree
	 */
	void exitFunctionDefinition(CPP14Parser.FunctionDefinitionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#functionBody}.
	 * @param ctx the parse tree
	 */
	void enterFunctionBody(CPP14Parser.FunctionBodyContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#functionBody}.
	 * @param ctx the parse tree
	 */
	void exitFunctionBody(CPP14Parser.FunctionBodyContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#initializer}.
	 * @param ctx the parse tree
	 */
	void enterInitializer(CPP14Parser.InitializerContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#initializer}.
	 * @param ctx the parse tree
	 */
	void exitInitializer(CPP14Parser.InitializerContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#braceOrEqualInitializer}.
	 * @param ctx the parse tree
	 */
	void enterBraceOrEqualInitializer(CPP14Parser.BraceOrEqualInitializerContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#braceOrEqualInitializer}.
	 * @param ctx the parse tree
	 */
	void exitBraceOrEqualInitializer(CPP14Parser.BraceOrEqualInitializerContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#initializerClause}.
	 * @param ctx the parse tree
	 */
	void enterInitializerClause(CPP14Parser.InitializerClauseContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#initializerClause}.
	 * @param ctx the parse tree
	 */
	void exitInitializerClause(CPP14Parser.InitializerClauseContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#initializerList}.
	 * @param ctx the parse tree
	 */
	void enterInitializerList(CPP14Parser.InitializerListContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#initializerList}.
	 * @param ctx the parse tree
	 */
	void exitInitializerList(CPP14Parser.InitializerListContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#bracedInitList}.
	 * @param ctx the parse tree
	 */
	void enterBracedInitList(CPP14Parser.BracedInitListContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#bracedInitList}.
	 * @param ctx the parse tree
	 */
	void exitBracedInitList(CPP14Parser.BracedInitListContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#className}.
	 * @param ctx the parse tree
	 */
	void enterClassName(CPP14Parser.ClassNameContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#className}.
	 * @param ctx the parse tree
	 */
	void exitClassName(CPP14Parser.ClassNameContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#classSpecifier}.
	 * @param ctx the parse tree
	 */
	void enterClassSpecifier(CPP14Parser.ClassSpecifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#classSpecifier}.
	 * @param ctx the parse tree
	 */
	void exitClassSpecifier(CPP14Parser.ClassSpecifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#classHead}.
	 * @param ctx the parse tree
	 */
	void enterClassHead(CPP14Parser.ClassHeadContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#classHead}.
	 * @param ctx the parse tree
	 */
	void exitClassHead(CPP14Parser.ClassHeadContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#classHeadName}.
	 * @param ctx the parse tree
	 */
	void enterClassHeadName(CPP14Parser.ClassHeadNameContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#classHeadName}.
	 * @param ctx the parse tree
	 */
	void exitClassHeadName(CPP14Parser.ClassHeadNameContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#classVirtSpecifier}.
	 * @param ctx the parse tree
	 */
	void enterClassVirtSpecifier(CPP14Parser.ClassVirtSpecifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#classVirtSpecifier}.
	 * @param ctx the parse tree
	 */
	void exitClassVirtSpecifier(CPP14Parser.ClassVirtSpecifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#classKey}.
	 * @param ctx the parse tree
	 */
	void enterClassKey(CPP14Parser.ClassKeyContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#classKey}.
	 * @param ctx the parse tree
	 */
	void exitClassKey(CPP14Parser.ClassKeyContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#memberSpecification}.
	 * @param ctx the parse tree
	 */
	void enterMemberSpecification(CPP14Parser.MemberSpecificationContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#memberSpecification}.
	 * @param ctx the parse tree
	 */
	void exitMemberSpecification(CPP14Parser.MemberSpecificationContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#memberdeclaration}.
	 * @param ctx the parse tree
	 */
	void enterMemberdeclaration(CPP14Parser.MemberdeclarationContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#memberdeclaration}.
	 * @param ctx the parse tree
	 */
	void exitMemberdeclaration(CPP14Parser.MemberdeclarationContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#memberDeclaratorList}.
	 * @param ctx the parse tree
	 */
	void enterMemberDeclaratorList(CPP14Parser.MemberDeclaratorListContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#memberDeclaratorList}.
	 * @param ctx the parse tree
	 */
	void exitMemberDeclaratorList(CPP14Parser.MemberDeclaratorListContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#memberDeclarator}.
	 * @param ctx the parse tree
	 */
	void enterMemberDeclarator(CPP14Parser.MemberDeclaratorContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#memberDeclarator}.
	 * @param ctx the parse tree
	 */
	void exitMemberDeclarator(CPP14Parser.MemberDeclaratorContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#virtualSpecifierSeq}.
	 * @param ctx the parse tree
	 */
	void enterVirtualSpecifierSeq(CPP14Parser.VirtualSpecifierSeqContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#virtualSpecifierSeq}.
	 * @param ctx the parse tree
	 */
	void exitVirtualSpecifierSeq(CPP14Parser.VirtualSpecifierSeqContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#virtualSpecifier}.
	 * @param ctx the parse tree
	 */
	void enterVirtualSpecifier(CPP14Parser.VirtualSpecifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#virtualSpecifier}.
	 * @param ctx the parse tree
	 */
	void exitVirtualSpecifier(CPP14Parser.VirtualSpecifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#pureSpecifier}.
	 * @param ctx the parse tree
	 */
	void enterPureSpecifier(CPP14Parser.PureSpecifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#pureSpecifier}.
	 * @param ctx the parse tree
	 */
	void exitPureSpecifier(CPP14Parser.PureSpecifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#baseClause}.
	 * @param ctx the parse tree
	 */
	void enterBaseClause(CPP14Parser.BaseClauseContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#baseClause}.
	 * @param ctx the parse tree
	 */
	void exitBaseClause(CPP14Parser.BaseClauseContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#baseSpecifierList}.
	 * @param ctx the parse tree
	 */
	void enterBaseSpecifierList(CPP14Parser.BaseSpecifierListContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#baseSpecifierList}.
	 * @param ctx the parse tree
	 */
	void exitBaseSpecifierList(CPP14Parser.BaseSpecifierListContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#baseSpecifier}.
	 * @param ctx the parse tree
	 */
	void enterBaseSpecifier(CPP14Parser.BaseSpecifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#baseSpecifier}.
	 * @param ctx the parse tree
	 */
	void exitBaseSpecifier(CPP14Parser.BaseSpecifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#classOrDeclType}.
	 * @param ctx the parse tree
	 */
	void enterClassOrDeclType(CPP14Parser.ClassOrDeclTypeContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#classOrDeclType}.
	 * @param ctx the parse tree
	 */
	void exitClassOrDeclType(CPP14Parser.ClassOrDeclTypeContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#baseTypeSpecifier}.
	 * @param ctx the parse tree
	 */
	void enterBaseTypeSpecifier(CPP14Parser.BaseTypeSpecifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#baseTypeSpecifier}.
	 * @param ctx the parse tree
	 */
	void exitBaseTypeSpecifier(CPP14Parser.BaseTypeSpecifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#accessSpecifier}.
	 * @param ctx the parse tree
	 */
	void enterAccessSpecifier(CPP14Parser.AccessSpecifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#accessSpecifier}.
	 * @param ctx the parse tree
	 */
	void exitAccessSpecifier(CPP14Parser.AccessSpecifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#conversionFunctionId}.
	 * @param ctx the parse tree
	 */
	void enterConversionFunctionId(CPP14Parser.ConversionFunctionIdContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#conversionFunctionId}.
	 * @param ctx the parse tree
	 */
	void exitConversionFunctionId(CPP14Parser.ConversionFunctionIdContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#conversionTypeId}.
	 * @param ctx the parse tree
	 */
	void enterConversionTypeId(CPP14Parser.ConversionTypeIdContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#conversionTypeId}.
	 * @param ctx the parse tree
	 */
	void exitConversionTypeId(CPP14Parser.ConversionTypeIdContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#conversionDeclarator}.
	 * @param ctx the parse tree
	 */
	void enterConversionDeclarator(CPP14Parser.ConversionDeclaratorContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#conversionDeclarator}.
	 * @param ctx the parse tree
	 */
	void exitConversionDeclarator(CPP14Parser.ConversionDeclaratorContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#constructorInitializer}.
	 * @param ctx the parse tree
	 */
	void enterConstructorInitializer(CPP14Parser.ConstructorInitializerContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#constructorInitializer}.
	 * @param ctx the parse tree
	 */
	void exitConstructorInitializer(CPP14Parser.ConstructorInitializerContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#memInitializerList}.
	 * @param ctx the parse tree
	 */
	void enterMemInitializerList(CPP14Parser.MemInitializerListContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#memInitializerList}.
	 * @param ctx the parse tree
	 */
	void exitMemInitializerList(CPP14Parser.MemInitializerListContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#memInitializer}.
	 * @param ctx the parse tree
	 */
	void enterMemInitializer(CPP14Parser.MemInitializerContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#memInitializer}.
	 * @param ctx the parse tree
	 */
	void exitMemInitializer(CPP14Parser.MemInitializerContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#meminitializerid}.
	 * @param ctx the parse tree
	 */
	void enterMeminitializerid(CPP14Parser.MeminitializeridContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#meminitializerid}.
	 * @param ctx the parse tree
	 */
	void exitMeminitializerid(CPP14Parser.MeminitializeridContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#operatorFunctionId}.
	 * @param ctx the parse tree
	 */
	void enterOperatorFunctionId(CPP14Parser.OperatorFunctionIdContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#operatorFunctionId}.
	 * @param ctx the parse tree
	 */
	void exitOperatorFunctionId(CPP14Parser.OperatorFunctionIdContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#literalOperatorId}.
	 * @param ctx the parse tree
	 */
	void enterLiteralOperatorId(CPP14Parser.LiteralOperatorIdContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#literalOperatorId}.
	 * @param ctx the parse tree
	 */
	void exitLiteralOperatorId(CPP14Parser.LiteralOperatorIdContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#templateDeclaration}.
	 * @param ctx the parse tree
	 */
	void enterTemplateDeclaration(CPP14Parser.TemplateDeclarationContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#templateDeclaration}.
	 * @param ctx the parse tree
	 */
	void exitTemplateDeclaration(CPP14Parser.TemplateDeclarationContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#templateparameterList}.
	 * @param ctx the parse tree
	 */
	void enterTemplateparameterList(CPP14Parser.TemplateparameterListContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#templateparameterList}.
	 * @param ctx the parse tree
	 */
	void exitTemplateparameterList(CPP14Parser.TemplateparameterListContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#templateParameter}.
	 * @param ctx the parse tree
	 */
	void enterTemplateParameter(CPP14Parser.TemplateParameterContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#templateParameter}.
	 * @param ctx the parse tree
	 */
	void exitTemplateParameter(CPP14Parser.TemplateParameterContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#typeParameter}.
	 * @param ctx the parse tree
	 */
	void enterTypeParameter(CPP14Parser.TypeParameterContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#typeParameter}.
	 * @param ctx the parse tree
	 */
	void exitTypeParameter(CPP14Parser.TypeParameterContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#simpleTemplateId}.
	 * @param ctx the parse tree
	 */
	void enterSimpleTemplateId(CPP14Parser.SimpleTemplateIdContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#simpleTemplateId}.
	 * @param ctx the parse tree
	 */
	void exitSimpleTemplateId(CPP14Parser.SimpleTemplateIdContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#templateId}.
	 * @param ctx the parse tree
	 */
	void enterTemplateId(CPP14Parser.TemplateIdContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#templateId}.
	 * @param ctx the parse tree
	 */
	void exitTemplateId(CPP14Parser.TemplateIdContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#templateName}.
	 * @param ctx the parse tree
	 */
	void enterTemplateName(CPP14Parser.TemplateNameContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#templateName}.
	 * @param ctx the parse tree
	 */
	void exitTemplateName(CPP14Parser.TemplateNameContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#templateArgumentList}.
	 * @param ctx the parse tree
	 */
	void enterTemplateArgumentList(CPP14Parser.TemplateArgumentListContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#templateArgumentList}.
	 * @param ctx the parse tree
	 */
	void exitTemplateArgumentList(CPP14Parser.TemplateArgumentListContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#templateArgument}.
	 * @param ctx the parse tree
	 */
	void enterTemplateArgument(CPP14Parser.TemplateArgumentContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#templateArgument}.
	 * @param ctx the parse tree
	 */
	void exitTemplateArgument(CPP14Parser.TemplateArgumentContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#typeNameSpecifier}.
	 * @param ctx the parse tree
	 */
	void enterTypeNameSpecifier(CPP14Parser.TypeNameSpecifierContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#typeNameSpecifier}.
	 * @param ctx the parse tree
	 */
	void exitTypeNameSpecifier(CPP14Parser.TypeNameSpecifierContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#explicitInstantiation}.
	 * @param ctx the parse tree
	 */
	void enterExplicitInstantiation(CPP14Parser.ExplicitInstantiationContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#explicitInstantiation}.
	 * @param ctx the parse tree
	 */
	void exitExplicitInstantiation(CPP14Parser.ExplicitInstantiationContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#explicitSpecialization}.
	 * @param ctx the parse tree
	 */
	void enterExplicitSpecialization(CPP14Parser.ExplicitSpecializationContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#explicitSpecialization}.
	 * @param ctx the parse tree
	 */
	void exitExplicitSpecialization(CPP14Parser.ExplicitSpecializationContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#tryBlock}.
	 * @param ctx the parse tree
	 */
	void enterTryBlock(CPP14Parser.TryBlockContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#tryBlock}.
	 * @param ctx the parse tree
	 */
	void exitTryBlock(CPP14Parser.TryBlockContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#functionTryBlock}.
	 * @param ctx the parse tree
	 */
	void enterFunctionTryBlock(CPP14Parser.FunctionTryBlockContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#functionTryBlock}.
	 * @param ctx the parse tree
	 */
	void exitFunctionTryBlock(CPP14Parser.FunctionTryBlockContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#handlerSeq}.
	 * @param ctx the parse tree
	 */
	void enterHandlerSeq(CPP14Parser.HandlerSeqContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#handlerSeq}.
	 * @param ctx the parse tree
	 */
	void exitHandlerSeq(CPP14Parser.HandlerSeqContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#handler}.
	 * @param ctx the parse tree
	 */
	void enterHandler(CPP14Parser.HandlerContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#handler}.
	 * @param ctx the parse tree
	 */
	void exitHandler(CPP14Parser.HandlerContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#exceptionDeclaration}.
	 * @param ctx the parse tree
	 */
	void enterExceptionDeclaration(CPP14Parser.ExceptionDeclarationContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#exceptionDeclaration}.
	 * @param ctx the parse tree
	 */
	void exitExceptionDeclaration(CPP14Parser.ExceptionDeclarationContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#throwExpression}.
	 * @param ctx the parse tree
	 */
	void enterThrowExpression(CPP14Parser.ThrowExpressionContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#throwExpression}.
	 * @param ctx the parse tree
	 */
	void exitThrowExpression(CPP14Parser.ThrowExpressionContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#exceptionSpecification}.
	 * @param ctx the parse tree
	 */
	void enterExceptionSpecification(CPP14Parser.ExceptionSpecificationContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#exceptionSpecification}.
	 * @param ctx the parse tree
	 */
	void exitExceptionSpecification(CPP14Parser.ExceptionSpecificationContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#dynamicExceptionSpecification}.
	 * @param ctx the parse tree
	 */
	void enterDynamicExceptionSpecification(CPP14Parser.DynamicExceptionSpecificationContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#dynamicExceptionSpecification}.
	 * @param ctx the parse tree
	 */
	void exitDynamicExceptionSpecification(CPP14Parser.DynamicExceptionSpecificationContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#typeIdList}.
	 * @param ctx the parse tree
	 */
	void enterTypeIdList(CPP14Parser.TypeIdListContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#typeIdList}.
	 * @param ctx the parse tree
	 */
	void exitTypeIdList(CPP14Parser.TypeIdListContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#noeExceptSpecification}.
	 * @param ctx the parse tree
	 */
	void enterNoeExceptSpecification(CPP14Parser.NoeExceptSpecificationContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#noeExceptSpecification}.
	 * @param ctx the parse tree
	 */
	void exitNoeExceptSpecification(CPP14Parser.NoeExceptSpecificationContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#theOperator}.
	 * @param ctx the parse tree
	 */
	void enterTheOperator(CPP14Parser.TheOperatorContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#theOperator}.
	 * @param ctx the parse tree
	 */
	void exitTheOperator(CPP14Parser.TheOperatorContext ctx);
	/**
	 * Enter a parse tree produced by {@link CPP14Parser#literal}.
	 * @param ctx the parse tree
	 */
	void enterLiteral(CPP14Parser.LiteralContext ctx);
	/**
	 * Exit a parse tree produced by {@link CPP14Parser#literal}.
	 * @param ctx the parse tree
	 */
	void exitLiteral(CPP14Parser.LiteralContext ctx);
}
```

`src/main/java/com/lauriewired/malimite/decompile/antlr/CPP14ParserVisitor.java`:

```java
// Generated from CPP14Parser.g4 by ANTLR 4.13.1
package com.lauriewired.malimite.decompile.antlr;
import org.antlr.v4.runtime.tree.ParseTreeVisitor;

/**
 * This interface defines a complete generic visitor for a parse tree produced
 * by {@link CPP14Parser}.
 *
 * @param <T> The return type of the visit operation. Use {@link Void} for
 * operations with no return type.
 */
public interface CPP14ParserVisitor<T> extends ParseTreeVisitor<T> {
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#translationUnit}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTranslationUnit(CPP14Parser.TranslationUnitContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#primaryExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitPrimaryExpression(CPP14Parser.PrimaryExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#idExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitIdExpression(CPP14Parser.IdExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#unqualifiedId}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitUnqualifiedId(CPP14Parser.UnqualifiedIdContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#qualifiedId}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitQualifiedId(CPP14Parser.QualifiedIdContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#nestedNameSpecifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitNestedNameSpecifier(CPP14Parser.NestedNameSpecifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#lambdaExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitLambdaExpression(CPP14Parser.LambdaExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#lambdaIntroducer}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitLambdaIntroducer(CPP14Parser.LambdaIntroducerContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#lambdaCapture}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitLambdaCapture(CPP14Parser.LambdaCaptureContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#captureDefault}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitCaptureDefault(CPP14Parser.CaptureDefaultContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#captureList}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitCaptureList(CPP14Parser.CaptureListContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#capture}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitCapture(CPP14Parser.CaptureContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#simpleCapture}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitSimpleCapture(CPP14Parser.SimpleCaptureContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#initcapture}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitInitcapture(CPP14Parser.InitcaptureContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#lambdaDeclarator}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitLambdaDeclarator(CPP14Parser.LambdaDeclaratorContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#postfixExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitPostfixExpression(CPP14Parser.PostfixExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#typeIdOfTheTypeId}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTypeIdOfTheTypeId(CPP14Parser.TypeIdOfTheTypeIdContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#expressionList}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitExpressionList(CPP14Parser.ExpressionListContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#pseudoDestructorName}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitPseudoDestructorName(CPP14Parser.PseudoDestructorNameContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#unaryExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitUnaryExpression(CPP14Parser.UnaryExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#unaryOperator}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitUnaryOperator(CPP14Parser.UnaryOperatorContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#newExpression_}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitNewExpression_(CPP14Parser.NewExpression_Context ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#newPlacement}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitNewPlacement(CPP14Parser.NewPlacementContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#newTypeId}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitNewTypeId(CPP14Parser.NewTypeIdContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#newDeclarator_}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitNewDeclarator_(CPP14Parser.NewDeclarator_Context ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#noPointerNewDeclarator}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitNoPointerNewDeclarator(CPP14Parser.NoPointerNewDeclaratorContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#newInitializer_}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitNewInitializer_(CPP14Parser.NewInitializer_Context ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#deleteExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitDeleteExpression(CPP14Parser.DeleteExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#noExceptExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitNoExceptExpression(CPP14Parser.NoExceptExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#castExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitCastExpression(CPP14Parser.CastExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#pointerMemberExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitPointerMemberExpression(CPP14Parser.PointerMemberExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#multiplicativeExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitMultiplicativeExpression(CPP14Parser.MultiplicativeExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#additiveExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitAdditiveExpression(CPP14Parser.AdditiveExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#shiftExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitShiftExpression(CPP14Parser.ShiftExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#shiftOperator}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitShiftOperator(CPP14Parser.ShiftOperatorContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#relationalExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitRelationalExpression(CPP14Parser.RelationalExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#equalityExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitEqualityExpression(CPP14Parser.EqualityExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#andExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitAndExpression(CPP14Parser.AndExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#exclusiveOrExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitExclusiveOrExpression(CPP14Parser.ExclusiveOrExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#inclusiveOrExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitInclusiveOrExpression(CPP14Parser.InclusiveOrExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#logicalAndExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitLogicalAndExpression(CPP14Parser.LogicalAndExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#logicalOrExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitLogicalOrExpression(CPP14Parser.LogicalOrExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#conditionalExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitConditionalExpression(CPP14Parser.ConditionalExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#assignmentExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitAssignmentExpression(CPP14Parser.AssignmentExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#assignmentOperator}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitAssignmentOperator(CPP14Parser.AssignmentOperatorContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#expression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitExpression(CPP14Parser.ExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#constantExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitConstantExpression(CPP14Parser.ConstantExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#statement}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitStatement(CPP14Parser.StatementContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#labeledStatement}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitLabeledStatement(CPP14Parser.LabeledStatementContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#expressionStatement}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitExpressionStatement(CPP14Parser.ExpressionStatementContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#compoundStatement}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitCompoundStatement(CPP14Parser.CompoundStatementContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#statementSeq}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitStatementSeq(CPP14Parser.StatementSeqContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#selectionStatement}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitSelectionStatement(CPP14Parser.SelectionStatementContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#condition}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitCondition(CPP14Parser.ConditionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#iterationStatement}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitIterationStatement(CPP14Parser.IterationStatementContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#forInitStatement}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitForInitStatement(CPP14Parser.ForInitStatementContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#forRangeDeclaration}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitForRangeDeclaration(CPP14Parser.ForRangeDeclarationContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#forRangeInitializer}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitForRangeInitializer(CPP14Parser.ForRangeInitializerContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#jumpStatement}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitJumpStatement(CPP14Parser.JumpStatementContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#declarationStatement}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitDeclarationStatement(CPP14Parser.DeclarationStatementContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#declarationseq}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitDeclarationseq(CPP14Parser.DeclarationseqContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#declaration}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitDeclaration(CPP14Parser.DeclarationContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#blockDeclaration}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitBlockDeclaration(CPP14Parser.BlockDeclarationContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#aliasDeclaration}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitAliasDeclaration(CPP14Parser.AliasDeclarationContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#simpleDeclaration}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitSimpleDeclaration(CPP14Parser.SimpleDeclarationContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#staticAssertDeclaration}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitStaticAssertDeclaration(CPP14Parser.StaticAssertDeclarationContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#emptyDeclaration_}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitEmptyDeclaration_(CPP14Parser.EmptyDeclaration_Context ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#attributeDeclaration}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitAttributeDeclaration(CPP14Parser.AttributeDeclarationContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#declSpecifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitDeclSpecifier(CPP14Parser.DeclSpecifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#declSpecifierSeq}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitDeclSpecifierSeq(CPP14Parser.DeclSpecifierSeqContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#storageClassSpecifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitStorageClassSpecifier(CPP14Parser.StorageClassSpecifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#functionSpecifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitFunctionSpecifier(CPP14Parser.FunctionSpecifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#typedefName}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTypedefName(CPP14Parser.TypedefNameContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#typeSpecifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTypeSpecifier(CPP14Parser.TypeSpecifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#trailingTypeSpecifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTrailingTypeSpecifier(CPP14Parser.TrailingTypeSpecifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#typeSpecifierSeq}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTypeSpecifierSeq(CPP14Parser.TypeSpecifierSeqContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#trailingTypeSpecifierSeq}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTrailingTypeSpecifierSeq(CPP14Parser.TrailingTypeSpecifierSeqContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#simpleTypeLengthModifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitSimpleTypeLengthModifier(CPP14Parser.SimpleTypeLengthModifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#simpleTypeSignednessModifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitSimpleTypeSignednessModifier(CPP14Parser.SimpleTypeSignednessModifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#simpleTypeSpecifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitSimpleTypeSpecifier(CPP14Parser.SimpleTypeSpecifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#theTypeName}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTheTypeName(CPP14Parser.TheTypeNameContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#decltypeSpecifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitDecltypeSpecifier(CPP14Parser.DecltypeSpecifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#elaboratedTypeSpecifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitElaboratedTypeSpecifier(CPP14Parser.ElaboratedTypeSpecifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#enumName}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitEnumName(CPP14Parser.EnumNameContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#enumSpecifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitEnumSpecifier(CPP14Parser.EnumSpecifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#enumHead}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitEnumHead(CPP14Parser.EnumHeadContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#opaqueEnumDeclaration}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitOpaqueEnumDeclaration(CPP14Parser.OpaqueEnumDeclarationContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#enumkey}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitEnumkey(CPP14Parser.EnumkeyContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#enumbase}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitEnumbase(CPP14Parser.EnumbaseContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#enumeratorList}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitEnumeratorList(CPP14Parser.EnumeratorListContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#enumeratorDefinition}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitEnumeratorDefinition(CPP14Parser.EnumeratorDefinitionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#enumerator}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitEnumerator(CPP14Parser.EnumeratorContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#namespaceName}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitNamespaceName(CPP14Parser.NamespaceNameContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#originalNamespaceName}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitOriginalNamespaceName(CPP14Parser.OriginalNamespaceNameContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#namespaceDefinition}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitNamespaceDefinition(CPP14Parser.NamespaceDefinitionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#namespaceAlias}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitNamespaceAlias(CPP14Parser.NamespaceAliasContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#namespaceAliasDefinition}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitNamespaceAliasDefinition(CPP14Parser.NamespaceAliasDefinitionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#qualifiednamespacespecifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitQualifiednamespacespecifier(CPP14Parser.QualifiednamespacespecifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#usingDeclaration}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitUsingDeclaration(CPP14Parser.UsingDeclarationContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#usingDirective}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitUsingDirective(CPP14Parser.UsingDirectiveContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#asmDefinition}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitAsmDefinition(CPP14Parser.AsmDefinitionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#linkageSpecification}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitLinkageSpecification(CPP14Parser.LinkageSpecificationContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#attributeSpecifierSeq}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitAttributeSpecifierSeq(CPP14Parser.AttributeSpecifierSeqContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#attributeSpecifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitAttributeSpecifier(CPP14Parser.AttributeSpecifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#alignmentspecifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitAlignmentspecifier(CPP14Parser.AlignmentspecifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#attributeList}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitAttributeList(CPP14Parser.AttributeListContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#attribute}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitAttribute(CPP14Parser.AttributeContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#attributeNamespace}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitAttributeNamespace(CPP14Parser.AttributeNamespaceContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#attributeArgumentClause}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitAttributeArgumentClause(CPP14Parser.AttributeArgumentClauseContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#balancedTokenSeq}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitBalancedTokenSeq(CPP14Parser.BalancedTokenSeqContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#balancedtoken}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitBalancedtoken(CPP14Parser.BalancedtokenContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#initDeclaratorList}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitInitDeclaratorList(CPP14Parser.InitDeclaratorListContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#initDeclarator}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitInitDeclarator(CPP14Parser.InitDeclaratorContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#declarator}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitDeclarator(CPP14Parser.DeclaratorContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#pointerDeclarator}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitPointerDeclarator(CPP14Parser.PointerDeclaratorContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#noPointerDeclarator}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitNoPointerDeclarator(CPP14Parser.NoPointerDeclaratorContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#parametersAndQualifiers}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitParametersAndQualifiers(CPP14Parser.ParametersAndQualifiersContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#trailingReturnType}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTrailingReturnType(CPP14Parser.TrailingReturnTypeContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#pointerOperator}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitPointerOperator(CPP14Parser.PointerOperatorContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#cvqualifierseq}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitCvqualifierseq(CPP14Parser.CvqualifierseqContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#cvQualifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitCvQualifier(CPP14Parser.CvQualifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#refqualifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitRefqualifier(CPP14Parser.RefqualifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#declaratorid}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitDeclaratorid(CPP14Parser.DeclaratoridContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#theTypeId}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTheTypeId(CPP14Parser.TheTypeIdContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#abstractDeclarator}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitAbstractDeclarator(CPP14Parser.AbstractDeclaratorContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#pointerAbstractDeclarator}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitPointerAbstractDeclarator(CPP14Parser.PointerAbstractDeclaratorContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#noPointerAbstractDeclarator}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitNoPointerAbstractDeclarator(CPP14Parser.NoPointerAbstractDeclaratorContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#abstractPackDeclarator}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitAbstractPackDeclarator(CPP14Parser.AbstractPackDeclaratorContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#noPointerAbstractPackDeclarator}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitNoPointerAbstractPackDeclarator(CPP14Parser.NoPointerAbstractPackDeclaratorContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#parameterDeclarationClause}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitParameterDeclarationClause(CPP14Parser.ParameterDeclarationClauseContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#parameterDeclarationList}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitParameterDeclarationList(CPP14Parser.ParameterDeclarationListContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#parameterDeclaration}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitParameterDeclaration(CPP14Parser.ParameterDeclarationContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#functionDefinition}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitFunctionDefinition(CPP14Parser.FunctionDefinitionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#functionBody}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitFunctionBody(CPP14Parser.FunctionBodyContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#initializer}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitInitializer(CPP14Parser.InitializerContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#braceOrEqualInitializer}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitBraceOrEqualInitializer(CPP14Parser.BraceOrEqualInitializerContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#initializerClause}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitInitializerClause(CPP14Parser.InitializerClauseContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#initializerList}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitInitializerList(CPP14Parser.InitializerListContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#bracedInitList}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitBracedInitList(CPP14Parser.BracedInitListContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#className}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitClassName(CPP14Parser.ClassNameContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#classSpecifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitClassSpecifier(CPP14Parser.ClassSpecifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#classHead}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitClassHead(CPP14Parser.ClassHeadContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#classHeadName}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitClassHeadName(CPP14Parser.ClassHeadNameContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#classVirtSpecifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitClassVirtSpecifier(CPP14Parser.ClassVirtSpecifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#classKey}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitClassKey(CPP14Parser.ClassKeyContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#memberSpecification}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitMemberSpecification(CPP14Parser.MemberSpecificationContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#memberdeclaration}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitMemberdeclaration(CPP14Parser.MemberdeclarationContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#memberDeclaratorList}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitMemberDeclaratorList(CPP14Parser.MemberDeclaratorListContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#memberDeclarator}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitMemberDeclarator(CPP14Parser.MemberDeclaratorContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#virtualSpecifierSeq}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitVirtualSpecifierSeq(CPP14Parser.VirtualSpecifierSeqContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#virtualSpecifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitVirtualSpecifier(CPP14Parser.VirtualSpecifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#pureSpecifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitPureSpecifier(CPP14Parser.PureSpecifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#baseClause}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitBaseClause(CPP14Parser.BaseClauseContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#baseSpecifierList}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitBaseSpecifierList(CPP14Parser.BaseSpecifierListContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#baseSpecifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitBaseSpecifier(CPP14Parser.BaseSpecifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#classOrDeclType}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitClassOrDeclType(CPP14Parser.ClassOrDeclTypeContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#baseTypeSpecifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitBaseTypeSpecifier(CPP14Parser.BaseTypeSpecifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#accessSpecifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitAccessSpecifier(CPP14Parser.AccessSpecifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#conversionFunctionId}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitConversionFunctionId(CPP14Parser.ConversionFunctionIdContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#conversionTypeId}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitConversionTypeId(CPP14Parser.ConversionTypeIdContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#conversionDeclarator}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitConversionDeclarator(CPP14Parser.ConversionDeclaratorContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#constructorInitializer}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitConstructorInitializer(CPP14Parser.ConstructorInitializerContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#memInitializerList}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitMemInitializerList(CPP14Parser.MemInitializerListContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#memInitializer}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitMemInitializer(CPP14Parser.MemInitializerContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#meminitializerid}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitMeminitializerid(CPP14Parser.MeminitializeridContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#operatorFunctionId}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitOperatorFunctionId(CPP14Parser.OperatorFunctionIdContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#literalOperatorId}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitLiteralOperatorId(CPP14Parser.LiteralOperatorIdContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#templateDeclaration}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTemplateDeclaration(CPP14Parser.TemplateDeclarationContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#templateparameterList}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTemplateparameterList(CPP14Parser.TemplateparameterListContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#templateParameter}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTemplateParameter(CPP14Parser.TemplateParameterContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#typeParameter}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTypeParameter(CPP14Parser.TypeParameterContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#simpleTemplateId}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitSimpleTemplateId(CPP14Parser.SimpleTemplateIdContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#templateId}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTemplateId(CPP14Parser.TemplateIdContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#templateName}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTemplateName(CPP14Parser.TemplateNameContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#templateArgumentList}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTemplateArgumentList(CPP14Parser.TemplateArgumentListContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#templateArgument}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTemplateArgument(CPP14Parser.TemplateArgumentContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#typeNameSpecifier}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTypeNameSpecifier(CPP14Parser.TypeNameSpecifierContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#explicitInstantiation}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitExplicitInstantiation(CPP14Parser.ExplicitInstantiationContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#explicitSpecialization}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitExplicitSpecialization(CPP14Parser.ExplicitSpecializationContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#tryBlock}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTryBlock(CPP14Parser.TryBlockContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#functionTryBlock}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitFunctionTryBlock(CPP14Parser.FunctionTryBlockContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#handlerSeq}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitHandlerSeq(CPP14Parser.HandlerSeqContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#handler}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitHandler(CPP14Parser.HandlerContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#exceptionDeclaration}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitExceptionDeclaration(CPP14Parser.ExceptionDeclarationContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#throwExpression}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitThrowExpression(CPP14Parser.ThrowExpressionContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#exceptionSpecification}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitExceptionSpecification(CPP14Parser.ExceptionSpecificationContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#dynamicExceptionSpecification}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitDynamicExceptionSpecification(CPP14Parser.DynamicExceptionSpecificationContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#typeIdList}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTypeIdList(CPP14Parser.TypeIdListContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#noeExceptSpecification}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitNoeExceptSpecification(CPP14Parser.NoeExceptSpecificationContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#theOperator}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitTheOperator(CPP14Parser.TheOperatorContext ctx);
	/**
	 * Visit a parse tree produced by {@link CPP14Parser#literal}.
	 * @param ctx the parse tree
	 * @return the visitor result
	 */
	T visitLiteral(CPP14Parser.LiteralContext ctx);
}
```

`src/main/java/com/lauriewired/malimite/files/InfoPlist.java`:

```java
package com.lauriewired.malimite.files;

import java.util.Map;
import javax.swing.tree.DefaultMutableTreeNode;

import com.lauriewired.malimite.utils.NodeOperations;
import com.lauriewired.malimite.utils.PlistUtils;
import com.lauriewired.malimite.utils.FileProcessing;
import com.dd.plist.NSDictionary;
import com.dd.plist.NSObject;
import com.dd.plist.PropertyListParser;
import java.io.File;
import java.nio.file.Files;

public class InfoPlist {
    private String infoPlistBundleExecutable;
    private String bundleIdentifier;

    public InfoPlist(DefaultMutableTreeNode infoPlistNode, String filePath, Map<String, String> fileEntriesMap) {
        try {
            String infoPlistPath = NodeOperations.buildFullPathFromNode(infoPlistNode);
            byte[] plistData;

            File file = new File(filePath);
            if (FileProcessing.isArchiveFile(file)) {
                // Handle archive files (IPA, ZIP, etc.)
                plistData = FileProcessing.readContentFromZip(filePath, fileEntriesMap.get(infoPlistPath));
            } else {
                // Handle directories and .app bundles
                String directPath = fileEntriesMap.get(infoPlistPath);
                plistData = Files.readAllBytes(new File(directPath).toPath());
            }

            if (PlistUtils.isBinaryPlist(plistData)) {
                // Handle binary plist
                NSObject plist = PropertyListParser.parse(plistData);
                infoPlistBundleExecutable = extractCFBundleExecutable(plist);
                bundleIdentifier = extractCFBundleIdentifier(plist);
            } else {
                // Handle XML plist
                String plistContent = new String(plistData);
                NSObject plist = PropertyListParser.parse(plistContent.getBytes());
                infoPlistBundleExecutable = extractCFBundleExecutable(plist);
                bundleIdentifier = extractCFBundleIdentifier(plist);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public InfoPlist() {
        this.infoPlistBundleExecutable = "unknown";
        this.bundleIdentifier = "unknown";
    }

    public static InfoPlist createEmpty() {
        return new InfoPlist();
    }

    /*
     * Takes in a binary or XML Info.plist and returns the CFBundleExecutable value
     */
    public static String extractCFBundleExecutable(NSObject plist) {
        String infoPlistBundleExecutable = "";

        if (plist instanceof NSDictionary) {
            NSDictionary dict = (NSDictionary) plist;
            String executableName = dict.objectForKey("CFBundleExecutable").toString();
            infoPlistBundleExecutable = executableName;
        }

        return infoPlistBundleExecutable;
    }

    /*
     * Takes in a binary or XML Info.plist and returns the CFBundleIdentifier value
     */
    public static String extractCFBundleIdentifier(NSObject plist) {
        String bundleIdentifier = "";

        if (plist instanceof NSDictionary) {
            NSDictionary dict = (NSDictionary) plist;
            String identifier = dict.objectForKey("CFBundleIdentifier").toString();
            bundleIdentifier = identifier;
        }

        return bundleIdentifier;
    }

    public String getExecutableName() {
        return this.infoPlistBundleExecutable;
    }

    public String getBundleIdentifier() {
        return this.bundleIdentifier;
    }
}
```

`src/main/java/com/lauriewired/malimite/files/Macho.java`:

```java
package com.lauriewired.malimite.files;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;
import java.util.logging.Level;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.charset.StandardCharsets;

public class Macho {
    private static final Logger LOGGER = Logger.getLogger(Macho.class.getName());

    // Mach-O Magic Numbers
    private static final int UNIVERSAL_MAGIC = 0xcafebabe;
    private static final int UNIVERSAL_CIGAM = 0xbebafeca;

    private List<Integer> cpuTypes;
    private List<Integer> cpuSubTypes;
    private List<Long> offsets;
    private List<Long> sizes;
    private boolean isUniversal;
    private String machoExecutablePath;
    private String outputDirectoryPath;
    private String machoExecutableName;
    private boolean isSwift = false;

    public Macho(String machoExecutablePath, String outputDirectoryPath, String machoExecutableName) {
        this.isUniversal = false;
        this.cpuTypes = new ArrayList<>();
        this.cpuSubTypes = new ArrayList<>();
        this.offsets = new ArrayList<>();
        this.sizes = new ArrayList<>();
        this.machoExecutablePath = machoExecutablePath;
        this.outputDirectoryPath = outputDirectoryPath;
        this.machoExecutableName = machoExecutableName;

        processMacho();
    }

    public void processUniversalMacho(String selectedArchitecture) {
        extractMachoArchitecture(selectedArchitecture);

        // We do not care about the original macho anymore
        // This will effectively reset the instance variables for the extracted macho
        processMacho();
    }


    private void extractMachoArchitecture(String selectedArchitecture) {
        for (int i = 0; i < cpuTypes.size(); i++) {
            String arch = getArchitectureName(cpuTypes.get(i));
            String fullArchitecture = generateFullArchitectureString(arch, cpuTypes.get(i), cpuSubTypes.get(i));

            if (fullArchitecture.equals(selectedArchitecture)) {
                String tempFileName = machoExecutableName + "_extracted.macho";
                try {
                    extractSlice(machoExecutablePath, tempFileName, offsets.get(i), sizes.get(i));
                    LOGGER.info("Extracted " + arch + " slice to " + tempFileName);

                    replaceOldMachoWithNew(tempFileName);
                } catch (IOException e) {
                    LOGGER.log(Level.SEVERE, "Error extracting Mach-O slice", e);
                }
                break;
            }
        }
    }

    private void extractSlice(String inputFilePath, String outputFileName, long offset, long size) throws IOException {
        // Construct the full path for the output file
        String outputPath = outputDirectoryPath + File.separator + outputFileName;

        try (RandomAccessFile inputFile = new RandomAccessFile(inputFilePath, "r");
             FileOutputStream outputFile = new FileOutputStream(outputPath)) {

            inputFile.seek(offset);
            byte[] buffer = new byte[8192];
            long remaining = size;

            while (remaining > 0) {
                int bytesRead = inputFile.read(buffer, 0, (int) Math.min(buffer.length, remaining));
                if (bytesRead == -1) break;

                outputFile.write(buffer, 0, bytesRead);
                remaining -= bytesRead;
            }
        }
    }

    private void replaceOldMachoWithNew(String tempFileName) throws IOException {
        File oldMacho = new File(machoExecutablePath);
        File extractedMacho = new File(outputDirectoryPath + File.separator + tempFileName);
        File newMacho = new File(machoExecutablePath);

        if (oldMacho.delete()) {
            if (!extractedMacho.renameTo(newMacho)) {
                throw new IOException("Failed to rename extracted Mach-O file.");
            }
            LOGGER.info("Replaced old Mach-O file with the extracted one.");
        } else {
            throw new IOException("Failed to delete old Mach-O file.");
        }
    }

    /*
     * Reads in a Mach-O file and sets instance variables based on type and architecture
     */
    private void processMacho() {
        File file = new File(this.machoExecutablePath);

        try (RandomAccessFile raf = new RandomAccessFile(file, "r")) {
            int magic = raf.readInt();
            if (magic == UNIVERSAL_MAGIC || magic == UNIVERSAL_CIGAM) {
                this.isUniversal = true;
                LOGGER.info("Detected Universal binary with architectures:");

                boolean reverseByteOrder = (magic == UNIVERSAL_CIGAM);
                int archCount = reverseByteOrder ? Integer.reverseBytes(raf.readInt()) : raf.readInt();
                for (int i = 0; i < archCount; i++) {
                    raf.seek(8L + i * 20L);
                    int cpuType = reverseByteOrder ? Integer.reverseBytes(raf.readInt()) : raf.readInt();
                    int cpuSubType = reverseByteOrder ? Integer.reverseBytes(raf.readInt()) : raf.readInt();
                    long offset = reverseByteOrder ? Integer.reverseBytes(raf.readInt()) : raf.readInt();
                    long size = reverseByteOrder ? Integer.reverseBytes(raf.readInt()) : raf.readInt();

                    cpuTypes.add(cpuType);
                    cpuSubTypes.add(cpuSubType);
                    offsets.add(offset);
                    sizes.add(size);
                }
            } else {
                this.isUniversal = false;
                LOGGER.info("This is not a Universal binary.");
            }

            // After processing the Mach-O headers, check for Swift
            detectSwift(file);
        } catch (IOException e) {
            LOGGER.log(Level.SEVERE, "Error reading file", e);
        }
    }

    private void detectSwift(File file) {
        try {
            // Read the file content as bytes
            byte[] content = Files.readAllBytes(file.toPath());
            String stringContent = new String(content, StandardCharsets.UTF_8);

            // Look for common Swift indicators in the binary
            isSwift = stringContent.contains("Swift Runtime") || 
                      stringContent.contains("SwiftCore") ||
                      stringContent.contains("_swift_") ||
                      stringContent.contains("_$s");  // Swift name mangling prefix

            LOGGER.info("Binary detected as: " + (isSwift ? "Swift" : "Objective-C"));
        } catch (IOException e) {
            LOGGER.log(Level.WARNING, "Error detecting Swift/Objective-C", e);
            isSwift = false; // Default to Objective-C if detection fails
        }
    }

    public static class Architecture {
        private String name;
        private int cpuType;
        private int cpuSubType;
        
        public Architecture(String name, int cpuType, int cpuSubType) {
            this.name = name;
            this.cpuType = cpuType;
            this.cpuSubType = cpuSubType;
        }
        
        @Override
        public String toString() {
            return name + " (CPU Type: " + cpuType + ", SubType: " + cpuSubType + ")";
        }
        
        // Getters
        public String getName() { return name; }
        public int getCpuType() { return cpuType; }
        public int getCpuSubType() { return cpuSubType; }
    }

    private String getArchitectureName(int cpuType) {
        switch (cpuType) {
            case 0x00000007: return "Intel x86";
            case 0x01000007: return "Intel x86_64";
            case 0x0000000C: return "ARM";
            case 0x0100000C: return "ARM64";
            default: return "Unknown";
        }
    }

    public List<Architecture> getArchitectures() {
        List<Architecture> architectures = new ArrayList<>();
        for (int i = 0; i < cpuTypes.size(); i++) {
            architectures.add(new Architecture(
                getArchitectureName(cpuTypes.get(i)),
                cpuTypes.get(i),
                cpuSubTypes.get(i)
            ));
        }
        return architectures;
    }

    public List<String> getArchitectureStrings() {
        List<String> architectureStrings = new ArrayList<>();

        for (int i = 0; i < cpuTypes.size(); i++) {
            int cpuType = cpuTypes.get(i);
            int cpuSubType = cpuSubTypes.get(i);
            String arch = getArchitectureName(cpuType);

            String fullArchitecture = generateFullArchitectureString(arch, cpuType, cpuSubType);
            architectureStrings.add(fullArchitecture);
        }

        return architectureStrings;
    } 

    public void printArchitectures() {
        String arch = "";
        String fullArchitecture = "";

        for (int i = 0; i < cpuTypes.size(); i++) {
            int cpuType = cpuTypes.get(i);
            int cpuSubType = cpuSubTypes.get(i);
            arch = getArchitectureName(cpuType);

            fullArchitecture = generateFullArchitectureString(arch, cpuType, cpuSubType);
            LOGGER.info(fullArchitecture);
        }
    }

    private String generateFullArchitectureString(String arch, int cpuType, int cpuSubType) {
        return arch + " (CPU Type: " + cpuType + ", SubType: " + cpuSubType + ")";
    }

    public List<Integer> getCpuTypes() {
        return cpuTypes;
    }

    public List<Integer> getCpuSubTypes() {
        return cpuSubTypes;
    }

    public boolean isUniversalBinary() {
        return this.isUniversal;
    }

    public String getMachoExecutableName() {
        return this.machoExecutableName;
    }

    public boolean isSwift() {
        return isSwift;
    }

    public long getSize() {
        File machoFile = new File(this.machoExecutablePath);
        return machoFile.length();
    }

    public Macho() {
        this.isUniversal = false;
        this.cpuTypes = new ArrayList<>();
        this.cpuSubTypes = new ArrayList<>();
        this.offsets = new ArrayList<>();
        this.sizes = new ArrayList<>();
        this.machoExecutablePath = "";
        this.outputDirectoryPath = "";
        this.machoExecutableName = "unknown";
        this.isSwift = false;
    }

    public static Macho createEmpty() {
        return new Macho();
    }
}

```

`src/main/java/com/lauriewired/malimite/files/MobileProvision.java`:

```java
package com.lauriewired.malimite.files;

import org.bouncycastle.cms.CMSSignedData;
import org.bouncycastle.cms.CMSProcessableByteArray;
import com.dd.plist.NSObject;
import com.dd.plist.PropertyListParser;
import com.lauriewired.malimite.utils.PlistUtils;
import java.util.logging.Logger;
import java.util.logging.Level;

public class MobileProvision {
    private static final Logger LOGGER = Logger.getLogger(MobileProvision.class.getName());

    public static String extractEmbeddedXML(byte[] provisionData) throws Exception {
        LOGGER.info("Attempting to extract embedded XML from provision data");
        try {
            CMSSignedData signedData = new CMSSignedData(new CMSProcessableByteArray(provisionData), provisionData);
            String fullContent = new String((byte[]) signedData.getSignedContent().getContent());

            // Find the start and end of the XML plist content
            int plistStart = fullContent.indexOf("<?xml");
            int plistEnd = fullContent.indexOf("</plist>") + "</plist>".length();

            if (plistStart == -1 || plistEnd == -1) {
                LOGGER.severe("Failed to locate XML plist content in embedded.mobileprovision");
                throw new Exception("Failed to locate XML plist content in embedded.mobileprovision");
            }

            LOGGER.info("Successfully extracted XML content from provision data");
            return fullContent.substring(plistStart, plistEnd);
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error extracting embedded XML", e);
            throw e;
        }
    }

    public static String parseProvisioningProfile(byte[] provisionData) {
        LOGGER.info("Starting to parse provisioning profile");
        try {
            String xmlContent = extractEmbeddedXML(provisionData);
            byte[] contentBytes = xmlContent.getBytes();

            // Use PlistUtils to handle binary or XML plist parsing
            if (PlistUtils.isBinaryPlist(contentBytes)) {
                LOGGER.info("Detected binary plist format, proceeding with binary parsing");
                return PlistUtils.decodeBinaryPropertyList(contentBytes);
            } else {
                LOGGER.info("Detected XML plist format, proceeding with XML parsing");
                NSObject parsedPlist = PropertyListParser.parse(contentBytes);
                return parsedPlist.toXMLPropertyList();
            }
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error parsing provisioning profile", e);
            return null;
        }
    }
}
```

`src/main/java/com/lauriewired/malimite/security/KeyEncryption.java`:

```java
package com.lauriewired.malimite.security;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.spec.KeySpec;
import java.util.Base64;

public class KeyEncryption {
    private static final String ALGORITHM = "AES";
    private static final String SECRET = "MALIMITE_" + System.getProperty("user.name");
    private static final byte[] SALT = "MALIMITE_SALT_123".getBytes();
    
    private static SecretKey generateKey() throws Exception {
        SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
        KeySpec spec = new PBEKeySpec(SECRET.toCharArray(), SALT, 65536, 256);
        return new SecretKeySpec(factory.generateSecret(spec).getEncoded(), ALGORITHM);
    }
    
    public static String encrypt(String value) {
        try {
            if (value == null || value.isEmpty()) return "";
            
            SecretKey key = generateKey();
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] encryptedBytes = cipher.doFinal(value.getBytes());
            return Base64.getEncoder().encodeToString(encryptedBytes);
        } catch (Exception e) {
            throw new RuntimeException("Error encrypting value", e);
        }
    }
    
    public static String decrypt(String encrypted) {
        try {
            if (encrypted == null || encrypted.isEmpty()) return "";
            
            SecretKey key = generateKey();
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, key);
            byte[] decryptedBytes = cipher.doFinal(Base64.getDecoder().decode(encrypted));
            return new String(decryptedBytes, StandardCharsets.UTF_8);
        } catch (Exception e) {
            throw new RuntimeException("Error decrypting value", e);
        }
    }
} 
```

`src/main/java/com/lauriewired/malimite/tools/AIBackend.java`:

```java
package com.lauriewired.malimite.tools;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.logging.Logger;
import java.util.logging.Level;

import com.lauriewired.malimite.configuration.Config;
import com.lauriewired.malimite.ui.AnalysisWindow;
import com.lauriewired.malimite.configuration.Project;
import com.lauriewired.malimite.security.KeyEncryption;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import javax.swing.*;

public class AIBackend {
    public static class Model {
        private final String displayName;
        private final String provider;
        private final String modelId;

        public Model(String displayName, String provider, String modelId) {
            this.displayName = displayName;
            this.provider = provider;
            this.modelId = modelId;
        }

        public String getDisplayName() { return displayName; }
        public String getProvider() { return provider; }
        public String getModelId() { return modelId; }
    }

    private static final Model[] SUPPORTED_MODELS = {
        new Model("OpenAI GPT-4 Turbo", "openai", "gpt-4-turbo"),
        new Model("OpenAI GPT-4 Mini", "openai", "gpt-4-mini"),
        new Model("Local Model", "local", "local-model")
        
        // TODO: Add support for Claude
        //new Model("Claude", "claude", "claude-v1"),
    };

    public static Model[] getSupportedModels() {
        return SUPPORTED_MODELS;
    }

    public static Model getDefaultModel() {
        return SUPPORTED_MODELS[0]; // Returns GPT-4 Turbo as default
    }

    private static final String OPENAI_API_URL = "https://api.openai.com/v1/chat/completions";
    private static final String CLAUDE_API_URL = "https://api.anthropic.com/v1/complete";

    private static final String DEFAULT_PROMPT = 
        "Translate the following decompiled functions into %s. " +
        "Return only the %s code for these functions, preserving the method names and any global variables. " +
        "You may adjust local variable names for readability, but do not add, remove, or modify any other methods or global definitions. " +
        "Surround each translated function with \"BEGIN_FUNCTION\" at the beginning and \"END_FUNCTION\" at the end. " +
        "Keep functions in the same order as they appear in the original code.";

    private static final String SUMMARIZE_PROMPT =
        "Provide a clear and concise summary of what these functions do. " +
        "Focus on their purpose, key functionality, and any notable patterns. " +
        "If you think this belongs to a known library, mention it. " +
        "Format the response in markdown.\n\n";

    private static final String VULNERABILITY_PROMPT =
        "Analyze these functions for potential security vulnerabilities and coding issues. " +
        "Consider: memory safety, input validation, authentication bypasses, and common coding pitfalls. " +
        "Ignore issues like readability, magic numbers, hardcoded values, and other minor issues since this is decompiled code. " +
        "Don't provide recommendations for fixing these issues, just identify them and say how they could be exploited. " +
        "Format the response in markdown with clear headers for each identified issue.\n\n";

    public static String getPromptForAction(String action, String functionCode) {
        StringBuilder fullPrompt = new StringBuilder();
        
        switch (action) {
            case "Auto Fix":
                Project currentProject = AnalysisWindow.getCurrentProject();
                String targetLanguage = currentProject != null && currentProject.isSwift() ? "Swift" : "Objective-C";
                fullPrompt.append(String.format(DEFAULT_PROMPT, targetLanguage, targetLanguage));
                break;
            case "Summarize":
                fullPrompt.append(SUMMARIZE_PROMPT);
                break;
            case "Find Vulnerabilities":
                fullPrompt.append(VULNERABILITY_PROMPT);
                break;
            default:
                throw new IllegalArgumentException("Unknown action: " + action);
        }

        fullPrompt.append("\nHere are the functions to analyze:\n\n");
        fullPrompt.append(functionCode);
        
        return fullPrompt.toString();
    }

    public static String getDefaultPrompt() {
        Project currentProject = AnalysisWindow.getCurrentProject();
        String targetLanguage = currentProject != null && currentProject.isSwift() ? "Swift" : "Objective-C";
        return String.format(DEFAULT_PROMPT, targetLanguage, targetLanguage);
    }

    public static class ApiKeyMissingException extends Exception {
        public ApiKeyMissingException(String message) {
            super(message);
        }
    }

    private static final Logger LOGGER = Logger.getLogger(AIBackend.class.getName());

    public static String sendToModel(String provider, String modelId, String inputText, Config config) throws IOException, ApiKeyMissingException {
        switch (provider.toLowerCase()) {
            case "openai":
                String openaiKey = KeyEncryption.decrypt(config.getOpenAIApiKey());
                if (openaiKey == null || openaiKey.trim().isEmpty()) {
                    showApiKeyMissingDialog("OpenAI");
                    throw new ApiKeyMissingException("OpenAI API key is missing");
                }
                return sendOpenAIRequest(OPENAI_API_URL, openaiKey, inputText, modelId);

            case "claude":
                String claudeKey = KeyEncryption.decrypt(config.getClaudeApiKey());
                if (claudeKey == null || claudeKey.trim().isEmpty()) {
                    showApiKeyMissingDialog("Claude");
                    throw new ApiKeyMissingException("Claude API key is missing");
                }
                return sendClaudeRequest(CLAUDE_API_URL, claudeKey, inputText, modelId);

            case "local":
                return sendLocalModelRequest(config.getLocalModelUrl(), inputText);

            default:
                throw new IllegalArgumentException("Unsupported provider: " + provider);
        }
    }

    private static void showApiKeyMissingDialog(String provider) {
        SwingUtilities.invokeLater(() -> {
            JOptionPane.showMessageDialog(
                null,
                provider + " API key is not set. Please set it in Preferences.",
                "API Key Missing",
                JOptionPane.WARNING_MESSAGE
            );
        });
    }

    private static String sendOpenAIRequest(String apiUrl, String apiKey, String inputText, String modelId) throws IOException {
        URL url = new URL(apiUrl);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setRequestMethod("POST");
        conn.setRequestProperty("Authorization", "Bearer " + apiKey);
        conn.setRequestProperty("Content-Type", "application/json");
        conn.setDoOutput(true);

        // Properly escape the input text for JSON
        String escapedInput = inputText.replace("\\", "\\\\")
                                     .replace("\"", "\\\"")
                                     .replace("\n", "\\n")
                                     .replace("\r", "\\r")
                                     .replace("\t", "\\t")
                                     .replace("\f", "\\f")
                                     .replace("\b", "\\b");

        // Construct the JSON payload using a more structured approach
        String jsonInputString = String.format(
            "{" +
                "\"model\": \"%s\"," +
                "\"messages\": [" +
                    "{" +
                        "\"role\": \"user\"," +
                        "\"content\": \"%s\"" +
                    "}" +
                "]" +
            "}", modelId, escapedInput);

        String response = executeRequest(conn, jsonInputString);
        return parseOpenAIResponse(response);
    }

    private static String parseOpenAIResponse(String jsonResponse) {
        try {
            JSONObject json = new JSONObject(jsonResponse);
            
            // Check for error response
            if (json.has("error")) {
                JSONObject error = json.getJSONObject("error");
                String errorMessage = error.getString("message");
                LOGGER.log(Level.SEVERE, "OpenAI API Error: " + errorMessage);
                return "Error: " + errorMessage;
            }

            // Parse successful response
            JSONArray choices = json.getJSONArray("choices");
            if (choices.length() > 0) {
                JSONObject firstChoice = choices.getJSONObject(0);
                JSONObject message = firstChoice.getJSONObject("message");
                String content = message.getString("content");
                
                // Extract code between triple backticks
                int startIndex = content.indexOf("```");
                if (startIndex != -1) {
                    startIndex = content.indexOf("\n", startIndex) + 1;
                    int endIndex = content.lastIndexOf("```");
                    if (endIndex != -1) {
                        return content.substring(startIndex, endIndex).trim();
                    }
                }
                return content;
            }
            
            // If we get here, something unexpected happened
            LOGGER.log(Level.WARNING, "Unexpected OpenAI response format: " + jsonResponse);
            return "Error: Unexpected response format";
            
        } catch (JSONException e) {
            LOGGER.log(Level.SEVERE, "Error parsing OpenAI response: " + jsonResponse, e);
            return "Error parsing response: " + e.getMessage();
        }
    }

    private static String sendClaudeRequest(String apiUrl, String apiKey, String inputText, String modelId) throws IOException {
        URL url = new URL(apiUrl);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setRequestMethod("POST");
        conn.setRequestProperty("Authorization", "Bearer " + apiKey);
        conn.setRequestProperty("Content-Type", "application/json");
        conn.setDoOutput(true);
    
        // Adjust payload format for Claude API if needed
        String jsonInputString = String.format(
            "{\"model\": \"%s\", \"prompt\": \"%s\"}",
            modelId, inputText
        );
    
        return executeRequest(conn, jsonInputString);
    }    

    private static boolean isChatCompatible(String apiUrl) {
        // Check if the URL contains common chat model endpoints
        return apiUrl.contains("localhost:1234") || // LM Studio
               apiUrl.contains("localhost:5000") || // Text Generation WebUI
               apiUrl.contains("localhost:8080");   // Ollama
    }

    private static String sendLocalModelRequest(String apiUrl, String inputText) throws IOException {
        boolean chatCompatible = isChatCompatible(apiUrl);

        // Use the base URL provided by the user
        URL url = new URL(apiUrl);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setRequestMethod("POST");
        conn.setRequestProperty("Content-Type", "application/json");
        conn.setDoOutput(true);

        String jsonInputString;
        if (chatCompatible) {
            // Use the chat-compatible format
            jsonInputString = String.format(
                "{" +
                    "\"model\": \"local-model\"," +
                    "\"messages\": [{" +
                        "\"role\": \"user\"," +
                        "\"content\": \"%s\"" +
                    "}]," +
                    "\"max_tokens\": 2000," +
                    "\"temperature\": 0.7" +
                "}",
                escapeJsonString(inputText)
            );
        } else {
            // Use the simple completion format
            jsonInputString = String.format(
                "{" +
                    "\"model\": \"local-model\"," +
                    "\"prompt\": \"%s\"," +
                    "\"max_tokens\": 2000," +
                    "\"temperature\": 0.7" +
                "}",
                escapeJsonString(inputText)
            );
        }

        String response = executeRequest(conn, jsonInputString);
        return parseLocalModelResponse(response);
    }

    private static String parseLocalModelResponse(String jsonResponse) {
        try {
            JSONObject json = new JSONObject(jsonResponse);
            
            // Try chat completion format first
            if (json.has("choices")) {
                JSONArray choices = json.getJSONArray("choices");
                if (choices.length() > 0) {
                    JSONObject choice = choices.getJSONObject(0);
                    if (choice.has("message")) {
                        return choice.getJSONObject("message").getString("content");
                    } else if (choice.has("text")) {
                        return choice.getString("text");
                    }
                }
            }
            
            // Fall back to simple completion format
            if (json.has("generated_text")) {
                return json.getString("generated_text");
            }
            
            // If no recognized format is found, return the raw response
            return jsonResponse;
        } catch (JSONException e) {
            LOGGER.log(Level.SEVERE, "Error parsing Local Model response", e);
            return jsonResponse;
        }
    }

    private static String escapeJsonString(String input) {
        return input.replace("\\", "\\\\")
                   .replace("\"", "\\\"")
                   .replace("\n", "\\n")
                   .replace("\r", "\\r")
                   .replace("\t", "\\t")
                   .replace("\f", "\\f")
                   .replace("\b", "\\b");
    }

    private static String executeRequest(HttpURLConnection conn, String jsonInputString) throws IOException {
        try (OutputStream os = conn.getOutputStream()) {
            byte[] input = jsonInputString.getBytes(StandardCharsets.UTF_8);
            os.write(input, 0, input.length);
        }
    
        int responseCode = conn.getResponseCode();
        InputStream inputStream = (responseCode >= 200 && responseCode < 300) ?
            conn.getInputStream() : conn.getErrorStream();
    
        try (BufferedReader br = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {
            StringBuilder response = new StringBuilder();
            String responseLine;
            while ((responseLine = br.readLine()) != null) {
                response.append(responseLine.trim());
            }
            return response.toString();
        }
    }    
}


```

`src/main/java/com/lauriewired/malimite/tools/RuntimeMethodHandler.java`:

```java
package com.lauriewired.malimite.tools;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class RuntimeMethodHandler {
    private static final Map<String, Set<String>> methodCategories = new HashMap<>();

    static {
        // Object Retain/Release
        addCategory("Object Retain/Release",
            "_swift_retain",
            "_swift_retain_n",
            "_swift_release",
            "_swift_release_n",
            "_swift_bridgeObjectRelease",
            "_swift_unknownObjectRelease",
            "_swift_unownedRetain",
            "_swift_unownedRelease",
            "_swift_retainCount",
            "_swift_bridgeObjectRetain",
            "_swift_unknownObjectRetain"
        );

        // Dynamic Casting and Type Checking
        addCategory("Dynamic Casting",
            "_swift_dynamicCast",
            "_swift_dynamicCastClass",
            "_swift_dynamicCastClassUnconditional",
            "_swift_dynamicCastObjCClass",
            "_swift_dynamicCastObjCClassUnconditional",
            "_swift_dynamicCastMetatype",
            "_swift_dynamicCastMetatypeUnconditional",
            "_swift_isClassOrObjCExistentialType",
            "_swift_getGenericMetadata",
            "_swift_getGenericWitnessTable"
        );

        // Memory Management
        addCategory("Memory Management",
            "_swift_allocObject",
            "_swift_deallocObject",
            "_swift_slowAlloc",
            "_swift_slowDealloc",
            "_swift_slowAllocArray",
            "_swift_bufferAllocate",
            "_swift_bufferDeallocate",
            "_swift_bufferHeaderInit",
            "_swift_bufferInitialize",
            "_swift_bufferDestroy"
        );

        // String and Character
        addCategory("String Operations",
            "_swift_convertStringToNSString",
            "_swift_convertNSStringToString",
            "_swift_convertStringToCString",
            "_swift_convertCStringToString",
            "_swift_bridgeNSStringToString",
            "_swift_isStringEmpty",
            "_swift_strlen",
            "_swift_getStringLength"
        );

        // Existentials
        addCategory("Existentials",
            "_swift_existentialRetain",
            "_swift_existentialRelease",
            "_swift_getExistentialTypeMetadata",
            "_swift_getExistentialMetatype",
            "_swift_getDynamicType"
        );

        // Concurrency
        addCategory("Concurrency",
            "_swift_task_create",
            "_swift_task_suspend",
            "_swift_task_resume",
            "_swift_task_future_wait",
            "_swift_task_future_create",
            "_swift_task_detach",
            "_swift_task_group_create",
            "_swift_task_group_add",
            "_swift_task_group_wait",
            "_swift_task_isCancelled"
        );

        // Bridging and Objective-C
        addCategory("Bridging",
            "_swift_bridgeObjectRetain",
            "_swift_bridgeObjectRelease",
            "_swift_bridgeFromObjectiveC",
            "_swift_bridgeToObjectiveC",
            "_swift_objc_getClass",
            "_swift_objc_getProtocol",
            "_swift_objc_getSelector",
            "_swift_objc_allocateClassPair",
            "_swift_objc_registerClassPair",
            "_swift_objc_autorelease"
        );

        // Type Metadata
        addCategory("Type Metadata",
            "_swift_getClass",
            "_swift_getTypeByMangledName",
            "_swift_getTypeByMangledNameInContext",
            "_swift_getTypeMetadata",
            "_swift_getTypeMetadata2",
            "_swift_getTypeMetadata3",
            "_swift_getSuperclass",
            "_swift_getSuperclassTypeMetadata",
            "_swift_getWitnessTable",
            "_swift_getGenericWitnessTable",
            "_swift_getAssociatedTypeWitness"
        );

        // Reflection
        addCategory("Reflection",
            "_swift_reflectionMirror_create",
            "_swift_reflectionMirror_destroy",
            "_swift_reflectionMetadataForClass",
            "_swift_reflectionMetadataForObject"
        );

        // Error Handling
        addCategory("Error Handling",
            "_swift_getErrorType",
            "_swift_getErrorMetadata",
            "_swift_errorRetain",
            "_swift_errorRelease",
            "_swift_isError",
            "_swift_errorThrow",
            "_swift_errorCatch"
        );

        // Protocol and Witness Tables
        addCategory("Protocol",
            "_swift_getProtocolConformance",
            "_swift_getWitnessTable",
            "_swift_getGenericWitnessTable",
            "_swift_getAssociatedTypeWitness",
            "_swift_protocolRequiresWitnessTable"
        );

        // KeyPaths
        addCategory("KeyPaths",
            "_swift_keyPathRetain",
            "_swift_keyPathRelease",
            "_swift_keyPathAllocate",
            "_swift_keyPathCopy",
            "_swift_keyPathCreate"
        );

        // Atomic Operations
        addCategory("Atomic",
            "_swift_atomicLoad",
            "_swift_atomicStore",
            "_swift_atomicCompareExchange",
            "_swift_atomicFetchAdd",
            "_swift_atomicFetchSub"
        );

        // Miscellaneous
        addCategory("Miscellaneous",
            "_swift_once",
            "_swift_conformsToProtocol",
            "_swift_objectForKey",
            "_swift_setObjectForKey",
            "_swift_getAssociatedObject",
            "_swift_setAssociatedObject",
            "_swift_deallocateAssociatedObject",
            "_swift_getEnclosingContext",
            "_swift_currentContext",
            "_swift_getFieldAt"
        );

        // Objective-C Memory Management
        addCategory("Objective-C Memory",
            "_objc_retain",
            "_objc_release",
            "_objc_retainAutoreleasedReturnValue",
            "_objc_retainAutorelease",
            "_objc_storeStrong",
            "_objc_loadWeak",
            "_objc_storeWeak",
            "_objc_copyWeak",
            "_objc_destroyWeak",
            "_objc_clearDeallocating",
            "_objc_autorelease",
            "_objc_autoreleasePoolPush",
            "_objc_autoreleasePoolPop",
            "_objc_autoreleaseReturnValue"
        );

        // Objective-C Dynamic Messaging
        addCategory("Objective-C Messaging",
            "_objc_msgSend",
            "_objc_msgSendSuper",
            "_objc_msgSendSuper2",
            "_objc_msgSend_stret",
            "_objc_msgSend_fpret",
            "_objc_msgLookup",
            "_objc_msgForward",
            "_objc_msgForward_stret",
            "_objc_msgSendUncached"
        );

        // Objective-C Class and Metaclass
        addCategory("Objective-C Class",
            "_objc_getClass",
            "_objc_getMetaClass",
            "_objc_getRequiredClass",
            "_objc_getClassList",
            "_objc_registerClassPair",
            "_objc_setFutureClass",
            "_objc_allocateClassPair",
            "_objc_disposeClassPair",
            "_objc_duplicateClass",
            "_objc_copyClassNamesForImage",
            "_objc_setHook_getClass",
            "_objc_setHook_getMetaClass"
        );

        // Objective-C Property and KVC
        addCategory("Objective-C Property",
            "_objc_copyPropertyList",
            "_objc_getProperty",
            "_objc_setProperty",
            "_objc_copyPropertyAttributes",
            "_objc_setKey",
            "_objc_getKey",
            "_objc_getKeyPath",
            "_objc_setKeyPath"
        );

        // Objective-C Protocol
        addCategory("Objective-C Protocol",
            "_objc_getProtocol",
            "_objc_registerProtocol",
            "_objc_conformsToProtocol",
            "_objc_allocateProtocol",
            "_objc_addProtocol",
            "_objc_setProtocolMethodTypes",
            "_objc_getSelector",
            "_objc_selector_register"
        );

        // Objective-C Exception Handling
        addCategory("Objective-C Exceptions",
            "_objc_terminate",
            "_objc_begin_catch",
            "_objc_end_catch",
            "_objc_exception_throw",
            "_objc_setExceptionPreprocessor",
            "_objc_setExceptionHandler"
        );

        // Objective-C Associated Objects
        addCategory("Objective-C Associated",
            "_objc_setAssociatedObject",
            "_objc_getAssociatedObject",
            "_objc_removeAssociatedObjects"
        );

        // Objective-C Block Operations
        addCategory("Objective-C Blocks",
            "_objc_block_copy",
            "_objc_block_release",
            "_objc_block_store"
        );

        // Objective-C Synchronization
        addCategory("Objective-C Sync",
            "_objc_sync_enter",
            "_objc_sync_exit",
            "_objc_initialize",
            "_objc_initializeClassPair",
            "_objc_fixupClassPair",
            "_objc_demangleClassName"
        );
    }

    private static void addCategory(String category, String... methods) {
        Set<String> methodSet = new HashSet<>();
        for (String method : methods) {
            methodSet.add(method);
        }
        methodCategories.put(category, methodSet);
    }

    public static Set<String> getMethodsInCategory(String category) {
        return methodCategories.getOrDefault(category, new HashSet<>());
    }

    public static Set<String> getAllMethods() {
        Set<String> allMethods = new HashSet<>();
        methodCategories.values().forEach(allMethods::addAll);
        return allMethods;
    }

    public static String getCategoryForMethod(String method) {
        for (Map.Entry<String, Set<String>> entry : methodCategories.entrySet()) {
            if (entry.getValue().contains(method)) {
                return entry.getKey();
            }
        }
        return "Unknown";
    }

    public static Set<String> getCategories() {
        return methodCategories.keySet();
    }

    public static boolean isSwiftRuntimeMethod(String method) {
        return getAllMethods().contains(method);
    }
} 
```

`src/main/java/com/lauriewired/malimite/ui/AnalysisWindow.java`:

```java
package com.lauriewired.malimite.ui;

import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JDialog;
import javax.swing.JEditorPane;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JProgressBar;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JTable;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.JTextPane;
import javax.swing.JToggleButton;
import javax.swing.JTree;
import javax.swing.ListSelectionModel;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.SwingWorker;
import javax.swing.DefaultListModel;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.table.TableColumnModel;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;
import javax.swing.Timer;
import java.awt.event.ActionListener;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.event.ActionEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
import org.fife.ui.rsyntaxtextarea.SyntaxConstants;
import org.fife.ui.rtextarea.RTextScrollPane;

import com.lauriewired.malimite.configuration.Config;
import com.lauriewired.malimite.decompile.DynamicDecompile;
import com.lauriewired.malimite.configuration.Project;
import com.lauriewired.malimite.database.SQLiteDBHandler;
import com.lauriewired.malimite.decompile.GhidraProject;
import com.lauriewired.malimite.files.InfoPlist;
import com.lauriewired.malimite.files.Macho;
import com.lauriewired.malimite.files.MobileProvision;
import com.lauriewired.malimite.tools.AIBackend;
import com.lauriewired.malimite.tools.AIBackend.Model;
import com.lauriewired.malimite.utils.FileProcessing;
import com.lauriewired.malimite.utils.NodeOperations;
import com.lauriewired.malimite.utils.PlistUtils;
import com.lauriewired.malimite.utils.ResourceParser;

import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.Frame;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Rectangle;

import java.nio.file.Files;
import java.awt.Desktop;

public class AnalysisWindow {
    private static final Logger LOGGER = Logger.getLogger(AnalysisWindow.class.getName());

    private static JFrame analysisFrame;  // Singleton instance
    private static JLabel fileNameLabel;
    private static RSyntaxTextArea fileContentArea;
    private static DefaultTreeModel treeModel;
    private static JTree fileTree;
    private static Map<String, String> fileEntriesMap;
    private static String currentFilePath;

    private static SQLiteDBHandler dbHandler;
    private static GhidraProject ghidraProject;
    private static String projectDirectoryPath;
    private static String executableFilePath;
    private static InfoPlist infoPlist;
    private static Macho projectMacho;
    private static Config config;

    private static JSplitPane mainSplitPane;
    private static JSplitPane rightSplitPane;
    private static JSplitPane rightVerticalSplitPane;
    private static JPanel functionAssistPanel;
    private static JPanel stringsPanel;
    private static boolean functionAssistVisible = false;
    private static JLabel bundleIdValue;
    private static JLabel closeLabel;

    private static JButton saveButton;
    private static boolean isEditing = false;

    private static JProgressBar processingBar;
    private static JLabel processingLabel;
    private static JPanel statusPanel;

    private static JTextPane infoDisplay;

    private static Project currentProject;

    private static JLabel stringsCloseLabel;

    private static JPanel resourceStringsPanel;
    private static JLabel resourceStringsCloseLabel;

    // Add this flag to track whether we're updating from SelectFile
    private static boolean updatingFromSelectFile = false;

    // Add this near the other static variables at the top of the class
    private static String currentClassName;
    private static String currentSelectedText;
    private static int currentCaretPosition;

    // Add this constant at the class level
    private static final int RIGHT_PANEL_WIDTH = 300;
    private static int lastDividerLocation = -1;  // Store the last divider location

    // Add these as class-level variables
    private static JPanel searchPanel;
    private static JTextField searchField;
    private static JButton nextButton;
    private static JButton prevButton;
    private static JLabel matchCountLabel;
    private static int currentSearchIndex = -1;
    private static List<Integer> searchResults = new ArrayList<>();

    // Add this as a class field at the top with other static fields
    private static JComboBox<String> actionSelector;

    // Add a method to properly close the window
    public static void closeWindow() {
        if (analysisFrame != null) {
            analysisFrame.dispose();
            analysisFrame = null;
            
            // Reset all static variables
            fileTree = null;
            treeModel = null;
            fileContentArea = null;
            fileEntriesMap.clear();
            searchResults.clear();
            currentSearchIndex = -1;
            isEditing = false;
            functionAssistVisible = false;
            lastDividerLocation = -1;
            currentProject = null;
            dbHandler = null;
            infoPlist = null;
            projectMacho = null;
            ghidraProject = null;
            config = null;  // Also reset the config
        }
    }

    public static void show(File file, Config configInstance) {
        // Store the config instance
        config = configInstance;
        
        // Close any existing window first
        closeWindow();
        
        // Create new window
        SwingUtilities.invokeLater(() -> {
            analysisFrame = new JFrame("Analysis - " + file.getName());
            analysisFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
            analysisFrame.setSize(800, 600);
            analysisFrame.setExtendedState(JFrame.MAXIMIZED_BOTH);

            currentFilePath = file.getAbsolutePath();
            fileEntriesMap = new HashMap<>();

            SelectFile.clear();

            JPanel contentPanel = setupUIComponents();
            analysisFrame.getContentPane().add(contentPanel, BorderLayout.CENTER);

            DefaultMutableTreeNode hiddenRoot = (DefaultMutableTreeNode) treeModel.getRoot();
            DefaultMutableTreeNode classesRootNode = (DefaultMutableTreeNode) hiddenRoot.getChildAt(0);
            DefaultMutableTreeNode filesRootNode = (DefaultMutableTreeNode) hiddenRoot.getChildAt(1);

            loadAndAnalyzeFile(file, filesRootNode, classesRootNode);
            
            // Select Info.plist node by default
            DefaultMutableTreeNode infoNode = NodeOperations.findInfoPlistNode((DefaultMutableTreeNode) treeModel.getRoot());

            if (infoNode != null) {
                TreePath infoPath = new TreePath(treeModel.getPathToRoot(infoNode));
                fileTree.setSelectionPath(infoPath);
                fileTree.scrollPathToVisible(infoPath);
                SelectFile.addFile(infoPath);
            }
            
            analysisFrame.setVisible(true);

            analysisFrame.addWindowListener(new java.awt.event.WindowAdapter() {
                @Override
                public void windowClosing(java.awt.event.WindowEvent e) {
                    analysisFrame = null;
                }
            });

            ApplicationMenu applicationMenu = new ApplicationMenu(
                analysisFrame, 
                fileTree,
                config
            );
            analysisFrame.setJMenuBar(applicationMenu.createMenuBar());

            toggleRightPanel(); // lol this is really lazy but works. oh well.
            toggleRightPanel();
        });
    }

    private static JPanel setupUIComponents() {
        fileNameLabel = new JLabel("Analyzing " + currentFilePath);
        fileNameLabel.setBorder(BorderFactory.createEmptyBorder(5, 10, 10, 10));
    
        DefaultMutableTreeNode hiddenRootNode = new DefaultMutableTreeNode("Hidden");
        treeModel = new DefaultTreeModel(hiddenRootNode);
        DefaultMutableTreeNode classesRootNode = new DefaultMutableTreeNode("Classes");
        DefaultMutableTreeNode filesRootNode = new DefaultMutableTreeNode("Files");
        hiddenRootNode.add(classesRootNode);
        hiddenRootNode.add(filesRootNode);
    
        fileTree = new JTree(treeModel);
        fileTree.setRootVisible(false);
        fileTree.addMouseListener(new MouseAdapter() {
            private Timer clickTimer;
        
            @Override
            public void mousePressed(MouseEvent e) {
                handlePopupTrigger(e); // Check for right-click or popup trigger on press
            }
        
            @Override
            public void mouseReleased(MouseEvent e) {
                handlePopupTrigger(e); // Check for right-click or popup trigger on release
            }
        
            @Override
            public void mouseClicked(MouseEvent e) {
                if (SwingUtilities.isLeftMouseButton(e)) {
                    TreePath path = fileTree.getPathForLocation(e.getX(), e.getY());
                    if (path == null || path.getLastPathComponent() == null) {
                        return;
                    }
        
                    DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
        
                    // Add this block to update currentClassName when clicking on a class node
                    if (isInClassesOrDecompiledTree(path)) {
                        if (isInClassesTree(path) && path.getPathCount() == 3 || isInDecompiledTree(path) && path.getPathCount() == 4) { // Class node
                            currentClassName = node.getUserObject().toString();
                            LOGGER.info("Selected class: " + currentClassName);
                        } else if (isInClassesTree(path) && path.getPathCount() == 4 || isInDecompiledTree(path) && path.getPathCount() == 5) { // Function node
                            DefaultMutableTreeNode parentNode = (DefaultMutableTreeNode) node.getParent();
                            currentClassName = parentNode.getUserObject().toString();
                            LOGGER.info("Selected class (from function): " + currentClassName);
                        }
                    }
        
                    if (e.getClickCount() == 2) {
                        // Cancel the single-click timer if a double-click is detected
                        if (clickTimer != null && clickTimer.isRunning()) {
                            clickTimer.stop();
                        }
        
                        // Handle double-click
                        if (node.isLeaf()) {
                            SelectFile.addFile(path);
                            displaySelectedFileContent(new TreeSelectionEvent(fileTree, path, false, null, null));
                        }
                    } else if (e.getClickCount() == 1) {
                        // Delay single-click logic to distinguish it from double-click
                        if (clickTimer != null && clickTimer.isRunning()) {
                            clickTimer.stop();
                        }
        
                        clickTimer = new Timer(200, new ActionListener() {
                            @Override
                            public void actionPerformed(ActionEvent evt) {
                                // Handle single-click
                                displaySelectedFileContent(new TreeSelectionEvent(fileTree, path, false, null, null));
        
                                // Check if the file is already open
                                if (SelectFile.isFileOpen(path)) {
                                    SelectFile.handleNodeClick(path);
                                } else if (node.isLeaf() || isInClassesOrDecompiledTree(path)) {
                                    SelectFile.replaceActiveFile(path);
                                }
                                clickTimer.stop();
                            }
                        });
                        clickTimer.setRepeats(false);
                        clickTimer.start();
                    }
                }
            }
        
            private void handlePopupTrigger(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    TreePath path = fileTree.getPathForLocation(e.getX(), e.getY());
                    if (path != null) {
                        // Existing code for function editing
                        if (isInClassesOrDecompiledTree(path) && path.getPathCount() == 4) {
                            JPopupMenu popup = new JPopupMenu();
                            JMenuItem editItem = new JMenuItem("Edit function");
                            editItem.addActionListener(ev -> startEditing(path));
                            popup.add(editItem);
                            popup.show(fileTree, e.getX(), e.getY());
                        }
                        // New code for file decompilation
                        else if (path.getLastPathComponent() != null) {
                            DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
                            if (node.isLeaf()) {
                                JPopupMenu popup = new JPopupMenu();
                                JMenuItem decompileItem = new JMenuItem("Decompile");
                                decompileItem.addActionListener(ev -> {
                                    // Build the path key the same way it was stored
                                    String pathKey = NodeOperations.buildFullPathFromNode(node);
                                    String entryPath = fileEntriesMap.get(pathKey);
                                    if (entryPath != null) {
                                        DynamicDecompile.decompileFile(currentFilePath, projectDirectoryPath, entryPath, config, dbHandler, infoPlist.getExecutableName(), treeModel, fileTree);
                                    }
                                });
                                popup.add(decompileItem);
                                popup.show(fileTree, e.getX(), e.getY());
                            }
                        }
                    }
                }
            }
        });
        
        JScrollPane treeScrollPane = new JScrollPane(fileTree);
    
        // Initialize RSyntaxTextArea with syntax highlighting
        fileContentArea = new RSyntaxTextArea();
        fileContentArea.setTabSize(2);
        fileContentArea.setTabsEmulated(true);  // This makes it use spaces instead of tabs
        fileContentArea.setEditable(false);
        fileContentArea.setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_CPLUSPLUS);
        fileContentArea.setCodeFoldingEnabled(true);
    
        // Add cursor and selection tracking
        fileContentArea.addCaretListener(e -> {
            currentCaretPosition = e.getDot();
            currentSelectedText = fileContentArea.getSelectedText();
        });
    
        // Add these lines to enable bracket matching
        fileContentArea.setPaintMatchedBracketPair(true);
        fileContentArea.setBracketMatchingEnabled(true);
        fileContentArea.setAnimateBracketMatching(true);
        fileContentArea.setPaintTabLines(true);  // This enables the vertical scope lines
    
        SyntaxHighlighter.applyCustomTheme(fileContentArea);
        SyntaxHighlighter.setupWordHighlighting(fileContentArea);
    
        // Add RSyntaxTextArea to RTextScrollPane
        RTextScrollPane contentScrollPane = new RTextScrollPane(fileContentArea);
    
        // Create info display panel
        infoDisplay = new JTextPane();
        infoDisplay.setContentType("text/html");
        infoDisplay.setEditable(false);
        infoDisplay.putClientProperty(JEditorPane.HONOR_DISPLAY_PROPERTIES, Boolean.TRUE);
    
        JScrollPane infoScrollPane = new JScrollPane(infoDisplay);
        infoScrollPane.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
    
        JPanel leftPanel = new JPanel(new BorderLayout());
    
        JPanel treePanel = new JPanel(new BorderLayout());
        treePanel.add(fileNameLabel, BorderLayout.NORTH);
        treePanel.add(treeScrollPane, BorderLayout.CENTER);
    
        JSplitPane leftSplitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, treePanel, infoScrollPane);
        leftSplitPane.setResizeWeight(0.7);
    
        leftPanel.add(leftSplitPane, BorderLayout.CENTER);
    
        // Initialize bundleIdValue as a class-level variable
        bundleIdValue = new JLabel("Loading...", SwingConstants.CENTER);
        bundleIdValue.setFont(bundleIdValue.getFont().deriveFont(Font.BOLD));
    
        JPanel bundleIdPanel = new JPanel(new BorderLayout());
        bundleIdPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 10, 5));
        bundleIdPanel.add(bundleIdValue, BorderLayout.CENTER);

        // Create a panel to hold both the label and tabs
        JPanel labelAndTabsPanel = new JPanel(new BorderLayout());
        labelAndTabsPanel.setBorder(BorderFactory.createMatteBorder(1, 0, 0, 0, javax.swing.UIManager.getColor("Separator.foreground")));
        labelAndTabsPanel.add(SelectFile.getFileTabsPanel(), BorderLayout.CENTER);

        // Create a panel to hold both the label and tabs
        JPanel fileLabelPanel = new JPanel(new BorderLayout());
        fileLabelPanel.add(labelAndTabsPanel, BorderLayout.CENTER);

        // Add this panel to the top of the content area
        JPanel rightPanel = new JPanel(new BorderLayout());
        rightPanel.add(fileLabelPanel, BorderLayout.NORTH);
        rightPanel.add(contentScrollPane, BorderLayout.CENTER);
    
        // Create function assist panel with close label
        functionAssistPanel = new JPanel(new BorderLayout());
        functionAssistPanel.setPreferredSize(new Dimension(300, 0));
        functionAssistPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
        
        // Create header panel to hold both label and close label
        JPanel headerPanel = new JPanel(new BorderLayout());
        JLabel assistLabel = new JLabel("Function Assist", SwingConstants.CENTER);
        assistLabel.setFont(assistLabel.getFont().deriveFont(Font.BOLD));
        assistLabel.setBorder(BorderFactory.createEmptyBorder(0, 0, 10, 0));
        
        // Create close label
        closeLabel = new JLabel("");
        //closeLabel = new JLabel("✕");  // Using "✕" as the close symbol
        closeLabel.setFont(closeLabel.getFont().deriveFont(14.0f));
        closeLabel.setBorder(BorderFactory.createEmptyBorder(0, 5, 10, 5));
        closeLabel.setCursor(new Cursor(Cursor.HAND_CURSOR));
        // closeLabel.addMouseListener(new java.awt.event.MouseAdapter() {
        //     @Override
        //     public void mouseClicked(java.awt.event.MouseEvent evt) {
        //         toggleFunctionAssist();
        //     }
        // });
        
        headerPanel.add(assistLabel, BorderLayout.CENTER);
        headerPanel.add(closeLabel, BorderLayout.EAST);
        functionAssistPanel.add(headerPanel, BorderLayout.NORTH);

        // Add function selection panel
        JPanel selectionPanel = new JPanel(new BorderLayout());
        DefaultListModel<String> functionListModel = new DefaultListModel<>();
        JList<String> functionList = new JList<>(functionListModel);
        functionList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);

        // Add "Select All" checkbox
        JCheckBox selectAllBox = new JCheckBox("Select All");
        selectAllBox.addActionListener(e -> {
            if (selectAllBox.isSelected()) {
                functionList.setSelectionInterval(0, functionListModel.getSize() - 1);
            } else {
                functionList.clearSelection();
            }
        });

        // Add scroll pane for function list
        JScrollPane listScrollPane = new JScrollPane(functionList);
        
        selectionPanel.add(selectAllBox, BorderLayout.NORTH);
        selectionPanel.add(listScrollPane, BorderLayout.CENTER);
        
        // Create model selector
        Model[] models = AIBackend.getSupportedModels();
        String[] modelNames = Arrays.stream(models)
            .map(Model::getDisplayName)
            .toArray(String[]::new);
        JComboBox<String> modelSelector = new JComboBox<>(modelNames);
        
        // Replace the clean button creation with a combo box and button panel
        JPanel actionPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));

        // Create action combo box
        String[] actions = {"Auto Fix", "Summarize", "Find Vulnerabilities"};
        actionSelector = new JComboBox<>(actions);

        // Create action button (renamed from cleanButton)
        JButton actionButton = new JButton("Execute");

        actionPanel.add(actionSelector);
        actionPanel.add(actionButton);

        // Update bottom panel to include both model selector and action panel
        JPanel bottomPanel = new JPanel(new BorderLayout());
        bottomPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        JPanel modelPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        modelPanel.add(new JLabel("Model:"));
        modelPanel.add(modelSelector);

        bottomPanel.add(modelPanel, BorderLayout.WEST);
        bottomPanel.add(actionPanel, BorderLayout.EAST);

        // Update action button listener
        actionButton.addActionListener(e -> {
            String selectedAction = (String) actionSelector.getSelectedItem();
            String selectedDisplayName = modelSelector.getSelectedItem().toString();
            Model selectedModel = Arrays.stream(AIBackend.getSupportedModels())
                .filter(m -> m.getDisplayName().equals(selectedDisplayName))
                .findFirst()
                .orElse(AIBackend.getDefaultModel());

            // Get selected functions from the list
            List<String> selectedFunctions = ((JList<String>) listScrollPane.getViewport().getView()).getSelectedValuesList();

            if (selectedFunctions.isEmpty()) {
                JOptionPane.showMessageDialog(analysisFrame,
                    "Please select at least one function to process.",
                    "No Selection",
                    JOptionPane.WARNING_MESSAGE);
                return;
            }

            // Get the parent class name from the tree selection
            TreePath path = fileTree.getSelectionPath();
            if (path == null) {
                JOptionPane.showMessageDialog(analysisFrame,
                    "Please select a class in the tree view.",
                    "No Class Selected",
                    JOptionPane.WARNING_MESSAGE);
                return;
            }

            // Build the function code string
            String executableName = getExecutableNameForSelectedNode(fileTree.getSelectionPath());
            DefaultMutableTreeNode classNode = (DefaultMutableTreeNode) path.getPathComponent(2);
            String className = classNode.getUserObject().toString();

            StringBuilder functionCode = new StringBuilder();
            for (String functionName : selectedFunctions) {
                String decompilation = dbHandler.getFunctionDecompilation(functionName, className, executableName);
                if (decompilation != null && !decompilation.isEmpty()) {
                    functionCode.append("// Function: ").append(functionName).append("\n");
                    functionCode.append(decompilation).append("\n\n");
                }
            }

            // Get the appropriate prompt from AIBackend
            String prompt = AIBackend.getPromptForAction(selectedAction, functionCode.toString());

            // Create confirmation message
            String confirmMessage = String.format(
                "<html>Sending %d function%s to %s for %s analysis:<br><br>%s</html>",
                selectedFunctions.size(),
                selectedFunctions.size() == 1 ? "" : "s",
                selectedModel.getDisplayName(),
                selectedAction.toLowerCase(),
                String.join(", ", selectedFunctions)
            );

            // Create custom dialog with two buttons
            Object[] options = {"Confirm", "Edit Prompt"};
            int choice = JOptionPane.showOptionDialog(
                analysisFrame,
                confirmMessage,
                "Confirm Analysis",
                JOptionPane.YES_NO_OPTION,
                JOptionPane.QUESTION_MESSAGE,
                null,
                options,
                options[0]
            );

            if (choice == 0) { // Confirm was clicked
                if (selectedAction.equals("Auto Fix")) {
                    sendPromptToAI(selectedModel, prompt);
                } else {
                    // For Summarize and Find Vulnerabilities, show response in a dialog
                    sendPromptForDialog(selectedModel, prompt, selectedAction);
                }
            } else if (choice == 1) { // Edit Prompt was clicked
                showPromptEditor(selectedModel, prompt);
            }
        });

        selectionPanel.add(bottomPanel, BorderLayout.SOUTH);
        
        functionAssistPanel.add(selectionPanel, BorderLayout.CENTER);

        // Add the same click listener to the label for consistency
        // assistLabel.setCursor(new Cursor(Cursor.HAND_CURSOR));
        // assistLabel.addMouseListener(new java.awt.event.MouseAdapter() {
        //     @Override
        //     public void mouseClicked(java.awt.event.MouseEvent evt) {
        //         toggleFunctionAssist();
        //     }
        // });

        functionAssistPanel.setVisible(false); // Start with the panel hidden

        // Create strings panel
        stringsPanel = new JPanel(new BorderLayout());
        stringsPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
        
        // Create header for strings panel
        JPanel stringsHeaderPanel = new JPanel(new BorderLayout());
        JLabel stringsLabel = new JLabel("Mach-O Strings", SwingConstants.CENTER);
        stringsLabel.setFont(stringsLabel.getFont().deriveFont(Font.BOLD));
        stringsLabel.setBorder(BorderFactory.createEmptyBorder(0, 0, 10, 0));
        
        // Add close button for strings panel
        stringsCloseLabel = new JLabel("✕");  // Using "✕" as the close symbol
        stringsCloseLabel.setFont(stringsCloseLabel.getFont().deriveFont(14.0f));
        stringsCloseLabel.setBorder(BorderFactory.createEmptyBorder(0, 5, 10, 5));
        stringsCloseLabel.setCursor(new Cursor(Cursor.HAND_CURSOR));
        stringsCloseLabel.addMouseListener(new java.awt.event.MouseAdapter() {
            @Override
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                toggleRightPanel();  // Reuse the same toggle since panels are linked
            }
        });
        stringsCloseLabel.setVisible(functionAssistVisible);
        
        stringsHeaderPanel.add(stringsLabel, BorderLayout.CENTER);
        stringsHeaderPanel.add(stringsCloseLabel, BorderLayout.EAST);
        
        stringsPanel.add(stringsHeaderPanel, BorderLayout.NORTH);
        
        // Create placeholder content
        JTextArea stringsContent = new JTextArea("String analysis will appear here...");
        stringsContent.setEditable(false);
        stringsContent.setBackground(null);
        stringsContent.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        JScrollPane stringsScrollPane = new JScrollPane(stringsContent);
        stringsPanel.add(stringsScrollPane, BorderLayout.CENTER);

        // Create resource strings panel
        resourceStringsPanel = new JPanel(new BorderLayout());
        resourceStringsPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        // Create header for resource strings panel
        JPanel resourceStringsHeaderPanel = new JPanel(new BorderLayout());
        JLabel resourceStringsLabel = new JLabel("Resource Strings", SwingConstants.CENTER);
        resourceStringsLabel.setFont(resourceStringsLabel.getFont().deriveFont(Font.BOLD));
        resourceStringsLabel.setBorder(BorderFactory.createEmptyBorder(0, 0, 10, 0));

        // Add close button for resource strings panel
        //resourceStringsCloseLabel = new JLabel("✕");
        resourceStringsCloseLabel = new JLabel("");
        resourceStringsCloseLabel.setFont(resourceStringsCloseLabel.getFont().deriveFont(14.0f));
        resourceStringsCloseLabel.setBorder(BorderFactory.createEmptyBorder(0, 5, 10, 5));
        resourceStringsCloseLabel.setCursor(new Cursor(Cursor.HAND_CURSOR));
        // resourceStringsCloseLabel.addMouseListener(new java.awt.event.MouseAdapter() {
        //     @Override
        //     public void mouseClicked(java.awt.event.MouseEvent evt) {
        //         toggleFunctionAssist();  // Reuse the same toggle since panels are linked
        //     }
        // });
        resourceStringsCloseLabel.setVisible(functionAssistVisible);

        resourceStringsHeaderPanel.add(resourceStringsLabel, BorderLayout.CENTER);
        resourceStringsHeaderPanel.add(resourceStringsCloseLabel, BorderLayout.EAST);

        resourceStringsPanel.add(resourceStringsHeaderPanel, BorderLayout.NORTH);

        // Create placeholder content
        JTextArea resourceStringsContent = new JTextArea("Resource string analysis will appear here...");
        resourceStringsContent.setEditable(false);
        resourceStringsContent.setBackground(null);
        resourceStringsContent.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        JScrollPane resourceStringsScrollPane = new JScrollPane(resourceStringsContent);
        resourceStringsPanel.add(resourceStringsScrollPane, BorderLayout.CENTER);

        // Create vertical split pane for all three panels
        rightVerticalSplitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
        rightVerticalSplitPane.setResizeWeight(0.67); // Give top section 67% of space

        // First split: Strings and Resource Strings
        JSplitPane topSplitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, stringsPanel, resourceStringsPanel);
        topSplitPane.setResizeWeight(0.5);  // Equal split between top two panels

        // Add the top split pane and function assist panel to the main vertical split
        rightVerticalSplitPane.setTopComponent(topSplitPane);
        rightVerticalSplitPane.setBottomComponent(functionAssistPanel);

        // Create the main horizontal split between content and right panels
        rightSplitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, rightPanel, rightVerticalSplitPane);
        rightSplitPane.setDividerLocation(1.0);
        rightSplitPane.setResizeWeight(1.0);

        // Set initial sizes for the panels
        stringsPanel.setPreferredSize(new Dimension(300, 200));
        resourceStringsPanel.setPreferredSize(new Dimension(300, 200));
        functionAssistPanel.setPreferredSize(new Dimension(300, 200));

        // Combine left and right panels
        mainSplitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, leftPanel, rightSplitPane);
        mainSplitPane.setDividerLocation(300);
    
        JPanel contentPanel = new JPanel(new BorderLayout());
        contentPanel.add(mainSplitPane, BorderLayout.CENTER);

        toggleRightPanel(); // Change my mind. Want to show it by default and this is the easiest way to do it

        // Add save button (initially invisible)
        saveButton = new JButton("Save Changes");
        saveButton.setVisible(false);
        saveButton.addActionListener(e -> saveCurrentFunction());
        
        // Add save button to the right panel, above the content
        JPanel rightTopPanel = new JPanel(new BorderLayout());
        rightTopPanel.add(bundleIdPanel, BorderLayout.NORTH);
        rightTopPanel.add(fileLabelPanel, BorderLayout.CENTER);
        rightTopPanel.add(saveButton, BorderLayout.EAST);
        rightPanel.add(rightTopPanel, BorderLayout.NORTH);     

        // Add status panel at the bottom
        statusPanel = new JPanel(new BorderLayout());
        processingBar = new JProgressBar();
        processingBar.setIndeterminate(true);
        processingLabel = new JLabel("Processing classes...");
        processingLabel.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 10));
        
        statusPanel.add(processingLabel, BorderLayout.WEST);
        statusPanel.add(processingBar, BorderLayout.CENTER);
        statusPanel.setVisible(false);
        
        contentPanel.add(statusPanel, BorderLayout.SOUTH);

        KeyboardShortcuts.setupShortcuts(fileContentArea, analysisFrame);

        // Add search panel to the right panel (after the existing fileLabelPanel)
        rightTopPanel.add(bundleIdPanel, BorderLayout.NORTH);
        
        // Create a panel to hold both search and file label panels
        JPanel topControlsPanel = new JPanel(new BorderLayout());
        topControlsPanel.add(fileLabelPanel, BorderLayout.CENTER);
        topControlsPanel.add(setupSearchPanel(), BorderLayout.EAST);
        rightTopPanel.add(topControlsPanel, BorderLayout.CENTER);
        
        rightTopPanel.add(saveButton, BorderLayout.EAST);
        rightPanel.add(rightTopPanel, BorderLayout.NORTH);

        return contentPanel;
    }      

    private static void loadAndAnalyzeFile(File file, DefaultMutableTreeNode filesRootNode, DefaultMutableTreeNode classesRootNode) {
        LOGGER.info("Starting analysis on " + file.getName());
        fileNameLabel.setText(file.getName());
        filesRootNode.removeAllChildren();
        treeModel.reload();
        fileEntriesMap.clear();
        fileContentArea.setText("");
    
        LOGGER.info("Beginning file analysis process");
        
        if (FileProcessing.isArchiveFile(file)) {
            // Handle archive files (IPA, ZIP, etc.)
            unzipAndLoadToTree(file, filesRootNode, classesRootNode);
        } else if (file.isDirectory() || file.getName().endsWith(".app")) {
            // Handle directories and .app bundles
            loadDirectoryToTree(file, filesRootNode, classesRootNode);
        } else {
            LOGGER.warning("Unsupported file type: " + file.getName());
            return;
        }
        
        // If no Info.plist was found, create empty objects and expand Files node
        if (infoPlist == null) {
            LOGGER.warning("No Info.plist found, creating empty objects");
            infoPlist = InfoPlist.createEmpty();
            projectMacho = Macho.createEmpty();
            updateBundleIdDisplay("unknown");
            
            // Get Files node (second child of root)
            DefaultMutableTreeNode filesNode = (DefaultMutableTreeNode) ((DefaultMutableTreeNode) treeModel.getRoot()).getChildAt(1);
            TreePath filesPath = new TreePath(treeModel.getPathToRoot(filesNode));
            fileTree.expandPath(filesPath);
            
            // Select first child if available
            if (filesNode.getChildCount() > 0) {
                DefaultMutableTreeNode firstChild = (DefaultMutableTreeNode) filesNode.getFirstChild();
                TreePath childPath = new TreePath(treeModel.getPathToRoot(firstChild));
                fileTree.setSelectionPath(childPath);
                fileTree.scrollPathToVisible(childPath);
                SelectFile.addFile(childPath);
                displaySelectedFileContent(new TreeSelectionEvent(fileTree, childPath, false, null, null));
            }
        }
        
        // Update project info
        Project project = FileProcessing.updateFileInfo(file, projectMacho);
        config.addProjectPath(project.getFilePath());
        currentProject = project;
        infoDisplay.setText(project.generateInfoString());
        
        populateMachoStringsPanel();
        populateResourceStringsPanel();

        // Only try to select Info.plist if it exists
        DefaultMutableTreeNode infoNode = NodeOperations.findInfoPlistNode((DefaultMutableTreeNode) treeModel.getRoot());
        if (infoNode != null) {
            TreePath infoPath = new TreePath(treeModel.getPathToRoot(infoNode));
            fileTree.setSelectionPath(infoPath);
            fileTree.scrollPathToVisible(infoPath);
            SelectFile.addFile(infoPath);
            
            displaySelectedFileContent(new TreeSelectionEvent(fileTree, infoPath, false, null, null));
        }

        // Repopulate the "Decompiled" node if we have a valid database connection
        if (dbHandler != null) {
            DynamicDecompile.repopulateDecompiledNode(treeModel, dbHandler, infoPlist.getExecutableName());
        }
    }

    private static void loadDirectoryToTree(File directory, DefaultMutableTreeNode filesRootNode, DefaultMutableTreeNode classesRootNode) {
        LOGGER.info("Loading directory: " + directory.getAbsolutePath());
        
        // Create app node if this is an .app bundle
        DefaultMutableTreeNode appNode = directory.getName().endsWith(".app") ? 
            new DefaultMutableTreeNode(directory.getName()) : null;
        if (appNode != null) {
            filesRootNode.add(appNode);
        }
        
        // Process all files in the directory
        processDirectory(directory, appNode != null ? appNode : filesRootNode, "");
        
        // Find Info.plist with CFBundleIdentifier
        DefaultMutableTreeNode foundInfoNode = findInfoPlistWithBundleId(directory, appNode != null ? appNode : filesRootNode);
        if (foundInfoNode != null) {
            String nodePath = NodeOperations.buildFullPathFromNode(foundInfoNode);
            infoPlist = new InfoPlist(foundInfoNode, fileEntriesMap.get(nodePath), fileEntriesMap);
            updateBundleIdDisplay(infoPlist.getBundleIdentifier());
            
            // Initialize project if Info.plist was found
            initializeProject();
            populateClassesNode(classesRootNode);
            
            // Process resource strings
            processResourceStrings(directory, appNode);
            
            // Select Info.plist node and display its content
            TreePath infoPath = new TreePath(treeModel.getPathToRoot(foundInfoNode));
            fileTree.setSelectionPath(infoPath);
            fileTree.scrollPathToVisible(infoPath);
            SelectFile.addFile(infoPath);
            displaySelectedFileContent(new TreeSelectionEvent(fileTree, infoPath, false, null, null));
        }
        
        treeModel.reload();
    }

    private static DefaultMutableTreeNode findInfoPlistWithBundleId(File directory, DefaultMutableTreeNode rootNode) {
        File[] files = directory.listFiles();
        if (files == null) return null;

        for (File file : files) {
            if (file.getName().equals("Info.plist")) {
                try {
                    // Read the file as bytes first
                    byte[] contentBytes = Files.readAllBytes(file.toPath());
                    
                    // Check if it's a binary plist and decode appropriately
                    String content;
                    if (PlistUtils.isBinaryPlist(contentBytes)) {
                        content = PlistUtils.decodeBinaryPropertyList(contentBytes);
                    } else {
                        content = new String(contentBytes);
                    }

                    if (content.contains("CFBundleIdentifier")) {
                        // Find the existing Info.plist node in the tree
                        Enumeration<?> e = rootNode.breadthFirstEnumeration();
                        while (e.hasMoreElements()) {
                            DefaultMutableTreeNode node = (DefaultMutableTreeNode) e.nextElement();
                            if (node.getUserObject().toString().equals("Info.plist")) {
                                return node;
                            }
                        }
                    }
                } catch (IOException e) {
                    LOGGER.log(Level.SEVERE, "Error reading Info.plist: " + e.getMessage(), e);
                }
            } else if (file.isDirectory()) {
                DefaultMutableTreeNode result = findInfoPlistWithBundleId(file, rootNode);
                if (result != null) {
                    return result;
                }
            }
        }
        return null;
    }

    private static void processDirectory(File directory, DefaultMutableTreeNode parentNode, String currentPath) {
        File[] files = directory.listFiles();
        if (files == null) return;

        for (File file : files) {
            String newPath = currentPath.isEmpty() ? file.getName() : currentPath + "/" + file.getName();
            
            if (file.isDirectory()) {
                DefaultMutableTreeNode dirNode = new DefaultMutableTreeNode(file.getName());
                parentNode.add(dirNode);
                processDirectory(file, dirNode, newPath);
            } else {
                DefaultMutableTreeNode fileNode = new DefaultMutableTreeNode(file.getName());
                parentNode.add(fileNode);
                fileEntriesMap.put(NodeOperations.buildFullPathFromNode(fileNode), file.getAbsolutePath());
            }
        }
    }

    private static void unzipAndLoadToTree(File fileToUnzip, DefaultMutableTreeNode filesRootNode, DefaultMutableTreeNode classesRootNode) {
        LOGGER.info("Analyzing " + fileToUnzip);
        currentFilePath = fileToUnzip.toString();

        try (ZipInputStream zipIn = new ZipInputStream(new FileInputStream(fileToUnzip))) {
            ZipEntry entry = zipIn.getNextEntry();
            DefaultMutableTreeNode appNode = null;
            
            // First pass: Find and process Info.plist containing CFBundleIdentifier
            while (entry != null) {
                if (entry.getName().endsWith("Info.plist")) {
                    // Read the content of the Info.plist file
                    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
                    byte[] buffer = new byte[4096];
                    int len;
                    while ((len = zipIn.read(buffer)) > 0) {
                        outputStream.write(buffer, 0, len);
                    }
                    byte[] contentBytes = outputStream.toByteArray();

                    // Check if this Info.plist contains CFBundleIdentifier
                    String content;
                    if (PlistUtils.isBinaryPlist(contentBytes)) {
                        content = PlistUtils.decodeBinaryPropertyList(contentBytes);
                    } else {
                        content = new String(contentBytes);
                    }

                    if (content.contains("CFBundleIdentifier")) {
                        DefaultMutableTreeNode infoNode = new DefaultMutableTreeNode("Info.plist");
                        filesRootNode.add(infoNode);
                        String nodePath = NodeOperations.buildFullPathFromNode(infoNode);
                        fileEntriesMap.put(nodePath, entry.getName());
                        infoPlist = new InfoPlist(infoNode, currentFilePath, fileEntriesMap);
                        updateBundleIdDisplay(infoPlist.getBundleIdentifier());
                        
                        // Remove Info.plist from fileEntriesMap so it can be processed separately later
                        fileEntriesMap.remove(nodePath);
                        filesRootNode.remove(infoNode);
                        break;
                    }
                }
                zipIn.closeEntry();
                entry = zipIn.getNextEntry();
            }
            
            // Reset stream for second pass
            zipIn.close();
            try (ZipInputStream zipIn2 = new ZipInputStream(new FileInputStream(fileToUnzip))) {
                entry = zipIn2.getNextEntry();
                
                // Second pass: Process all other files
                while (entry != null) {
                    if (entry.getName().endsWith(".app/")) {
                        appNode = new DefaultMutableTreeNode(entry.getName());
                        filesRootNode.add(appNode);
                    } else if (appNode != null && entry.getName().startsWith(appNode.toString())) {
                        handleEntryWithoutResources(entry, appNode, zipIn2);
                    }
                    zipIn2.closeEntry();
                    entry = zipIn2.getNextEntry();
                }
            }
            
            LOGGER.info("Finished extracting resources");

            // Only initialize project if we have a valid Info.plist
            if (infoPlist != null) {
                initializeProject();
                populateClassesNode(classesRootNode);
                
                // Now process all resources in a separate pass
                processResourceStrings(fileToUnzip, appNode);
            } else {
                LOGGER.severe("Could not find or process Info.plist file");
                throw new IOException("Info.plist file not found or could not be processed");
            }

            treeModel.reload();
            NodeOperations.collapseAllTreeNodes(fileTree);
        } catch (IOException e) {
            LOGGER.log(Level.SEVERE, "Error unzipping and loading to tree", e);
        }
    }
    
    private static void populateClassesNode(DefaultMutableTreeNode classesRootNode) {
        Map<String, List<String>> classesAndFunctions = dbHandler.getMainExecutableClasses(infoPlist.getExecutableName());
        
        // Convert map keys to sorted list
        List<String> sortedClassNames = new ArrayList<>(classesAndFunctions.keySet());
        
        // Remove "Libraries" from the list if it exists
        sortedClassNames.remove("Libraries");
        
        // Sort remaining class names
        Collections.sort(sortedClassNames);
        
        // Add "Libraries" first if it exists in the original map
        if (classesAndFunctions.containsKey("Libraries")) {
            DefaultMutableTreeNode librariesNode = new DefaultMutableTreeNode("Libraries");
            List<String> libraryFunctions = classesAndFunctions.get("Libraries");
            if (libraryFunctions != null) {
                Collections.sort(libraryFunctions);
                for (String function : libraryFunctions) {
                    librariesNode.add(new DefaultMutableTreeNode(function));
                }
            }
            classesRootNode.add(librariesNode);
        }
        
        // Add remaining classes in sorted order
        for (String className : sortedClassNames) {
            DefaultMutableTreeNode classNode = new DefaultMutableTreeNode(className);
            List<String> functions = classesAndFunctions.get(className);
            
            // Sort functions alphabetically if they exist
            if (functions != null) {
                Collections.sort(functions);
                for (String function : functions) {
                    classNode.add(new DefaultMutableTreeNode(function));
                }
            }
            
            classesRootNode.add(classNode);
        }
        
        treeModel.reload(classesRootNode);
    }

    private static void initializeProject() {
        LOGGER.info("Initializing project...");
        
        // Create and show processing dialog
        JDialog processingDialog = new JDialog(analysisFrame, "Processing", true);
        JPanel mainPanel = new JPanel(new BorderLayout(10, 10));
        mainPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        
        // Create top panel for progress bar and status
        JPanel topPanel = new JPanel(new BorderLayout(10, 10));
        JProgressBar progressBar = new JProgressBar();
        progressBar.setIndeterminate(true);
        topPanel.add(progressBar, BorderLayout.CENTER);
        
        JLabel statusLabel = new JLabel("Initializing Ghidra analysis...");
        topPanel.add(statusLabel, BorderLayout.SOUTH);
        
        // Create console output components
        JTextArea consoleOutput = new JTextArea();
        consoleOutput.setEditable(false);
        consoleOutput.setFont(new Font(Font.MONOSPACED, Font.PLAIN, 12));
        JScrollPane consoleScrollPane = new JScrollPane(consoleOutput);
        consoleScrollPane.setPreferredSize(new Dimension(600, 200));
        
        // Create toggle button panel
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        JToggleButton toggleConsoleButton = new JToggleButton("Show Processing Output");
        buttonPanel.add(toggleConsoleButton);
        
        // Add components to main panel
        mainPanel.add(topPanel, BorderLayout.NORTH);
        mainPanel.add(buttonPanel, BorderLayout.CENTER);
        
        // Initially hide console
        consoleScrollPane.setVisible(false);
        
        // Toggle console visibility
        toggleConsoleButton.addActionListener(e -> {
            consoleScrollPane.setVisible(toggleConsoleButton.isSelected());
            processingDialog.pack();
            processingDialog.setLocationRelativeTo(analysisFrame);
        });
        
        mainPanel.add(consoleScrollPane, BorderLayout.SOUTH);
        processingDialog.add(mainPanel);
        processingDialog.pack();
        processingDialog.setLocationRelativeTo(analysisFrame);
        
        // Create a SwingWorker to handle the background processing
        SwingWorker<Void, String> worker = new SwingWorker<Void, String>() {
            @Override
            protected Void doInBackground() throws Exception {
                publish("Extracting Mach-O file...");
                projectDirectoryPath = FileProcessing.extractMachoToProjectDirectory(currentFilePath, 
                    infoPlist.getExecutableName(), config.getConfigDirectory());
                LOGGER.info("Project directory created at: " + projectDirectoryPath);

                publish("Opening project...");
                FileProcessing.openProject(currentFilePath, projectDirectoryPath, 
                    infoPlist.getExecutableName(), config.getConfigDirectory(), false);

                executableFilePath = projectDirectoryPath + File.separator + infoPlist.getExecutableName();
                LOGGER.info("Loading Mach-O file: " + executableFilePath);
                
                publish("Loading Mach-O file...");
                projectMacho = new Macho(executableFilePath, projectDirectoryPath, infoPlist.getExecutableName());

                // Get the input file name without extension
                String inputFileName = new File(currentFilePath).getName();
                int lastDotIndex = inputFileName.lastIndexOf('.');
                if (lastDotIndex > 0) {
                    inputFileName = inputFileName.substring(0, lastDotIndex);
                }
                
                String dbFilePath = projectDirectoryPath + File.separator + inputFileName + "_malimite.db";
                LOGGER.info("Checking for database at: " + dbFilePath);

                File dbFile = new File(dbFilePath);
                if (!dbFile.exists()) {
                    if (projectMacho.isUniversalBinary()) {
                        LOGGER.info("Detected universal binary - preparing to handle architecture selection");
                        final String[] selectedArch = new String[1];
                        
                        // Don't hide the processing dialog, just show arch selection on top
                        SwingUtilities.invokeAndWait(() -> {
                            LOGGER.info("Showing architecture selection dialog");
                            List<String> architectures = projectMacho.getArchitectureStrings();
                            LOGGER.info("Available architectures: " + String.join(", ", architectures));
                            selectedArch[0] = selectArchitecture(architectures);
                            LOGGER.info("Selected architecture: " + selectedArch[0]);
                        });

                        // Process the selected architecture if one was chosen
                        if (selectedArch[0] != null) {
                            LOGGER.info("Beginning processing of " + selectedArch[0] + " architecture");
                            publish("Processing " + selectedArch[0] + " architecture...");
                            try {
                                projectMacho.processUniversalMacho(selectedArch[0]);
                                LOGGER.info("Finished processing " + selectedArch[0] + " architecture");
                            } catch (Exception e) {
                                LOGGER.severe("Error processing universal Mach-O: " + e.getMessage());
                                e.printStackTrace();
                                throw e;
                            }
                        } else {
                            LOGGER.warning("No architecture selected - cannot proceed");
                            throw new IllegalStateException("No architecture selected for universal binary");
                        }
                    }
                    projectMacho.printArchitectures();
                    publish("Processing and decompiling...");

                    publish("Creating new database...");
                    dbHandler = new SQLiteDBHandler(projectDirectoryPath + File.separator, 
                        inputFileName + "_malimite.db");

                    publish("Starting Ghidra analysis...");
                    ghidraProject = new GhidraProject(infoPlist.getExecutableName(), 
                        executableFilePath, config, dbHandler, 
                        // Add console output callback
                        message -> SwingUtilities.invokeLater(() -> {
                            consoleOutput.append(message + "\n");
                            consoleOutput.setCaretPosition(consoleOutput.getDocument().getLength());
                        }));
                
                    ghidraProject.decompileMacho(executableFilePath, projectDirectoryPath, projectMacho, false);
                } else {
                    publish("Loading existing database...");
                    dbHandler = new SQLiteDBHandler(projectDirectoryPath + File.separator, 
                        inputFileName + "_malimite.db");
                }

                // After dbHandler is initialized, set it in ResourceParser
                ResourceParser.setDatabaseHandler(dbHandler);

                return null;
            }
            
            @Override
            protected void process(List<String> chunks) {
                for (String message : chunks) {
                    if (message.equals("HIDE_DIALOG")) {
                        processingDialog.setVisible(false);
                    } else if (message.equals("SHOW_DIALOG")) {
                        processingDialog.setVisible(true);
                    } else {
                        statusLabel.setText(message);
                        consoleOutput.append(message + "\n");
                        consoleOutput.setCaretPosition(consoleOutput.getDocument().getLength());
                    }
                }
            }
            
            @Override
            protected void done() {
                processingDialog.dispose();
                try {
                    get();
                    // Show the analysis window after processing is complete
                    SwingUtilities.invokeLater(() -> {
                        if (analysisFrame != null) {
                            analysisFrame.setVisible(true);
                            analysisFrame.toFront();
                            analysisFrame.requestFocus();
                            if (analysisFrame.getExtendedState() == Frame.ICONIFIED) {
                                analysisFrame.setExtendedState(Frame.NORMAL);
                            }
                            analysisFrame.setAlwaysOnTop(true);
                            analysisFrame.setAlwaysOnTop(false);
                        }
                    });
                } catch (Exception e) {
                    LOGGER.log(Level.SEVERE, "Error during project initialization", e);
                    JOptionPane.showMessageDialog(analysisFrame,
                        "Error during initialization: " + e.getMessage(),
                        "Initialization Error",
                        JOptionPane.ERROR_MESSAGE);
                }
            }
        };
        
        worker.execute();
        processingDialog.setVisible(true);
    }

    private static String selectArchitecture(List<String> architectures) {
        JComboBox<String> architectureComboBox = new JComboBox<>(architectures.toArray(new String[0]));
        int result = JOptionPane.showConfirmDialog(null, architectureComboBox, "Select Architecture", 
                                                    JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE);
        if (result == JOptionPane.OK_OPTION) {
            return (String) architectureComboBox.getSelectedItem();
        }
        return null;
    }
    
    private static void handleEntryWithoutResources(ZipEntry entry, DefaultMutableTreeNode appNode, ZipInputStream zipIn) throws IOException {
        String relativePath = entry.getName().substring(appNode.toString().length());
        DefaultMutableTreeNode currentNode;

        // Read the content once into a byte array
        byte[] contentBytes = null;
        if (!entry.isDirectory()) {
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            byte[] buffer = new byte[4096];
            int len;
            while ((len = zipIn.read(buffer)) > 0) {
                outputStream.write(buffer, 0, len);
            }
            contentBytes = outputStream.toByteArray();
        }

        if (relativePath.equals("Info.plist")) {
            currentNode = new DefaultMutableTreeNode("Info.plist");
            appNode.add(currentNode);
            fileEntriesMap.put(NodeOperations.buildFullPathFromNode(currentNode), entry.getName());

            // Process Info.plist content
            if (contentBytes != null) {
                // Process as Info.plist
                infoPlist = new InfoPlist(currentNode, currentFilePath, fileEntriesMap);
                updateBundleIdDisplay(infoPlist.getBundleIdentifier());
            }
        } else {
            // Create or get the "Resources" node and add other files to it
            currentNode = NodeOperations.addOrGetNode(appNode, "Resources", true);

            // Skip the first part of the path if it's a directory
            String[] pathParts = relativePath.split("/");
            for (int i = (entry.isDirectory() ? 1 : 0); i < pathParts.length; i++) {
                boolean isDirectory = i < pathParts.length - 1 || entry.isDirectory();
                currentNode = NodeOperations.addOrGetNode(currentNode, pathParts[i], isDirectory);

                if (!isDirectory) {
                    fileEntriesMap.put(NodeOperations.buildFullPathFromNode(currentNode), entry.getName());
                }
            }
        }
    }

    private static void processResourceStrings(File inputFile, DefaultMutableTreeNode appNode) {
        if (FileProcessing.isArchiveFile(inputFile)) {
            // Handle archive files (IPA, ZIP, etc.)
            processArchiveResourceStrings(inputFile, appNode);
        } else {
            // Handle directories and .app bundles
            processDirectoryResourceStrings(inputFile, appNode);
        }
    }

    private static void processArchiveResourceStrings(File archiveFile, DefaultMutableTreeNode appNode) {
        try (ZipInputStream zipIn = new ZipInputStream(new FileInputStream(archiveFile))) {
            ZipEntry entry = zipIn.getNextEntry();
            
            while (entry != null) {
                if (!entry.isDirectory() && appNode != null && entry.getName().startsWith(appNode.toString())) {
                    // Check if this is a resource file and process it
                    if (ResourceParser.isResource(entry.getName())) {
                        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
                        byte[] buffer = new byte[4096];
                        int len;
                        while ((len = zipIn.read(buffer)) > 0) {
                            outputStream.write(buffer, 0, len);
                        }
                        try (ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray())) {
                            ResourceParser.parseResourceForStrings(inputStream, entry.getName());
                        }
                    }
                }
                zipIn.closeEntry();
                entry = zipIn.getNextEntry();
            }
        } catch (IOException e) {
            LOGGER.log(Level.SEVERE, "Error processing archive resource strings", e);
        }
    }

    private static void processDirectoryResourceStrings(File directory, DefaultMutableTreeNode appNode) {
        try {
            // Get the app directory if it exists
            File appDirectory = directory;
            if (appNode != null) {
                String appName = appNode.getUserObject().toString();
                if (directory.getName().equals(appName)) {
                    appDirectory = directory;
                } else {
                    File[] files = directory.listFiles();
                    if (files != null) {
                        for (File file : files) {
                            if (file.getName().equals(appName)) {
                                appDirectory = file;
                                break;
                            }
                        }
                    }
                }
            }

            // Process all files in the directory recursively
            processDirectoryContents(appDirectory);
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error processing directory resource strings", e);
        }
    }

    private static void processDirectoryContents(File directory) {
        if (directory == null || !directory.exists()) {
            return;
        }

        File[] files = directory.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    processDirectoryContents(file);
                } else if (ResourceParser.isResource(file.getName())) {
                    try (FileInputStream inputStream = new FileInputStream(file)) {
                        ResourceParser.parseResourceForStrings(inputStream, file.getAbsolutePath());
                    } catch (IOException e) {
                        LOGGER.log(Level.SEVERE, "Error processing resource file: " + file.getName(), e);
                    }
                }
            }
        }
    }

    private static String getExecutableNameForSelectedNode(TreePath path) {
        if (isInClassesTree(path) || isInFilesTree(path)) {
            // If the node is part of the Classes tree, use the executable name from infoPlist
            return infoPlist.getExecutableName();
        } else if (isInDecompiledTree(path)) {
            // If the node is part of the Decompiled tree, use the name of the child node
            DefaultMutableTreeNode decompiledNode = (DefaultMutableTreeNode) path.getPathComponent(2);
            return decompiledNode.getUserObject().toString();
        }
        
        return null; // Return null or handle the case where the executable name is not found
    }

    private static void displaySelectedFileContent(TreeSelectionEvent e) {
        // Don't change content if we're currently editing
        if (isEditing) {
            return;
        }

        TreePath path = e.getPath();
        DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
        
        String executableName = getExecutableNameForSelectedNode(path);
        if (executableName == null) {
            LOGGER.warning("Executable name could not be determined for the selected node.");
            return;
        }
    
        // Check if we're in the Classes root
        if (isInClassesOrDecompiledTree(path)) {
            fileContentArea.setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_CPLUSPLUS);
            
            // If this is a class node (direct child of "Classes" node)
            if ((isInClassesTree(path) && path.getPathCount() == 3) || (isInDecompiledTree(path) && path.getPathCount() == 4)) {
                String className = node.getUserObject().toString();
                displayClassDecompilation(className, executableName);
                return;
            }
            // If this is a function node (grandchild of "Classes" node)
            else if ((isInClassesTree(path) && path.getPathCount() == 4) || (isInDecompiledTree(path) && path.getPathCount() == 5)) {
                DefaultMutableTreeNode parentNode = (DefaultMutableTreeNode) node.getParent();
                String className = parentNode.getUserObject().toString();
                String functionName = node.getUserObject().toString();
                displayFunctionDecompilation(functionName, className, executableName);
                return;
            }
        }

        // Build the full path
        StringBuilder fullPath = new StringBuilder();
        for (int i = 1; i < path.getPathCount(); i++) {
            if (fullPath.length() > 0 && fullPath.charAt(fullPath.length() - 1) != '/') {
                fullPath.append("/");
            }
            fullPath.append(((DefaultMutableTreeNode) path.getPathComponent(i)).getUserObject().toString());
        }

        // Only proceed if this path exists in our fileEntriesMap
        String entryPath = fileEntriesMap.get(fullPath.toString());
        if (entryPath == null) {
            return;
        }

        if (currentFilePath != null) {
            try {
                byte[] contentBytes;
                File file = new File(currentFilePath);
                
                if (FileProcessing.isArchiveFile(file)) {
                    // Handle archive files (IPA, ZIP, etc.)
                    contentBytes = FileProcessing.readContentFromZip(currentFilePath, entryPath);
                } else {
                    // Handle directories and .app bundles - read file directly
                    contentBytes = Files.readAllBytes(new File(entryPath).toPath());
                }

                String contentText;
                setSyntaxStyle(entryPath);

                // Check if this is a mobile provision file
                if (entryPath.endsWith("embedded.mobileprovision")) {
                    contentText = MobileProvision.parseProvisioningProfile(contentBytes);
                } else if (fullPath.toString().endsWith("plist")) {
                    if (PlistUtils.isBinaryPlist(contentBytes)) {
                        contentText = PlistUtils.decodeBinaryPropertyList(contentBytes);
                        fileContentArea.setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_JSON);
                    } else {
                        contentText = new String(contentBytes);
                        fileContentArea.setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_XML);
                    }
                } else {
                    contentText = new String(contentBytes);
                }

                fileContentArea.setText(contentText);
                fileContentArea.setCaretPosition(0);
            } catch (IOException ex) {
                LOGGER.log(Level.SEVERE, "Error reading file content", ex);
                fileContentArea.setText("Error reading file: " + ex.getMessage());
            } catch (Exception ex) {
                LOGGER.log(Level.SEVERE, "Error processing file content", ex);
                fileContentArea.setText("Error processing file: " + ex.getMessage());
            }
        }
    }

    private static void displayFunctionDecompilation(String functionName, String className, String executableName) {
        try {
            // Update the function list in the function assist panel
            FileProcessing.updateFunctionList(functionAssistPanel, dbHandler, className);
            
            String functionDecompilation = dbHandler.getFunctionDecompilation(functionName, className, executableName);
            if (functionDecompilation != null && !functionDecompilation.isEmpty()) {
                // Only add headers if they don't already exist
                String content = functionDecompilation;
                if (!content.trim().startsWith("// Class:") && !content.trim().startsWith("// Function:")) {
                    StringBuilder contentBuilder = new StringBuilder();
                    contentBuilder.append("// Class: ").append(className).append("\n");
                    contentBuilder.append("// Function: ").append(functionName).append("\n\n");
                    contentBuilder.append(functionDecompilation);
                    content = contentBuilder.toString();
                }

                fileContentArea.setText(content);
                fileContentArea.setCaretPosition(0);
            } else {
                fileContentArea.setText("No decompilation available for function " + functionName);
            }
        } catch (Exception ex) {
            LOGGER.log(Level.SEVERE, "Error displaying decompilation for " + functionName, ex);
            fileContentArea.setText("Error loading decompilation for " + functionName);
        }
    }

    private static void displayClassDecompilation(String className, String executableName) {
        try {
            // Update the function list in the function assist panel
            FileProcessing.updateFunctionList(functionAssistPanel, dbHandler, className);
            
            // Get all functions for this class from the map we already have
            Map<String, List<String>> classesAndFunctions = dbHandler.getAllClassesAndFunctions();
            List<String> functions = classesAndFunctions.get(className);
            
            if (functions == null || functions.isEmpty()) {
                fileContentArea.setText("No functions found for " + className);
                return;
            }

            // Build the complete decompilation by combining all function decompilations
            StringBuilder fullDecompilation = new StringBuilder();
            
            // Only add class header if it's not already present
            String firstFunction = dbHandler.getFunctionDecompilation(functions.get(0), className, executableName);
            if (firstFunction == null || !firstFunction.trim().startsWith("// Class:")) {
                fullDecompilation.append("// Class: ").append(className).append("\n\n");
            }

            for (String functionName : functions) {
                String functionDecompilation = dbHandler.getFunctionDecompilation(functionName, className, executableName);
                if (functionDecompilation != null && !functionDecompilation.isEmpty()) {
                    // Only add function header if it's not already present
                    if (!functionDecompilation.trim().startsWith("// Class:") && !functionDecompilation.trim().startsWith("// Function:")) {
                        fullDecompilation.append("// Function: ").append(functionName).append("\n");
                    }
                    fullDecompilation.append(functionDecompilation).append("\n\n");
                }
            }

            if (fullDecompilation.length() > 0) {
                fileContentArea.setText(fullDecompilation.toString());
                fileContentArea.setCaretPosition(0);
            } else {
                fileContentArea.setText("No decompilation available for " + className);
            }
        } catch (Exception ex) {
            LOGGER.log(Level.SEVERE, "Error displaying decompilation for " + className, ex);
            fileContentArea.setText("Error loading decompilation for " + className);
        }
    }

    public static void safeMenuAction(Runnable action) {
        SafeMenuAction.execute(action);
    }

    private static void updateBundleIdDisplay(String bundleId) {
        SwingUtilities.invokeLater(() -> {
            if (bundleIdValue != null) {
                bundleIdValue.setText(bundleId != null ? bundleId : "N/A");
            }
        });
    }    

    public static void toggleRightPanel() {
        if (functionAssistPanel != null && mainSplitPane != null) {
            functionAssistVisible = !functionAssistVisible;
            functionAssistPanel.setVisible(functionAssistVisible);
            stringsPanel.setVisible(functionAssistVisible);
            resourceStringsPanel.setVisible(functionAssistVisible);
            closeLabel.setVisible(functionAssistVisible);
            stringsCloseLabel.setVisible(functionAssistVisible);
            resourceStringsCloseLabel.setVisible(functionAssistVisible);

            if (functionAssistVisible) {
                if (lastDividerLocation == -1) {
                    // First time opening, calculate the position
                    lastDividerLocation = rightSplitPane.getWidth() - RIGHT_PANEL_WIDTH;
                }
                rightSplitPane.setDividerLocation(lastDividerLocation);
                
                // Set equal spacing for all three panels
                JSplitPane topSplitPane = (JSplitPane) rightVerticalSplitPane.getTopComponent();
                topSplitPane.setDividerLocation(0.5);  // Equal split between top two panels
                rightVerticalSplitPane.setDividerLocation(0.66);  // Give bottom panel 1/3 of space
            } else {
                // Store the current location before hiding
                lastDividerLocation = rightSplitPane.getDividerLocation();
                rightSplitPane.setDividerLocation(1.0);
            }

            mainSplitPane.revalidate();
            mainSplitPane.repaint();
        }
    }

    private static void sendPromptToAI(Model selectedModel, String prompt) {
        // Create a loading dialog
        JDialog loadingDialog = new JDialog(analysisFrame, "Processing", true);
        JPanel panel = new JPanel(new BorderLayout(10, 10));
        panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        
        // Add a spinner
        JProgressBar spinner = new JProgressBar();
        spinner.setIndeterminate(true);
        panel.add(spinner, BorderLayout.CENTER);
        
        // Add a status label
        JLabel statusLabel = new JLabel("Sending request to " + selectedModel.getDisplayName() + "...");
        panel.add(statusLabel, BorderLayout.SOUTH);
        
        loadingDialog.add(panel);
        loadingDialog.pack();
        loadingDialog.setLocationRelativeTo(analysisFrame);
        
        // Run the AI request in a background thread
        SwingWorker<String, Void> worker = new SwingWorker<String, Void>() {
            @Override
            protected String doInBackground() throws Exception {
                try {
                    return AIBackend.sendToModel(
                        selectedModel.getProvider(), 
                        selectedModel.getModelId(), 
                        prompt, 
                        config
                    );
                } catch (IOException ex) {
                    throw ex;
                }
            }
            
            @Override
            protected void done() {
                loadingDialog.dispose();
                try {
                    String aiResponse = get();
                    if (aiResponse != null) {
                        showFunctionAcceptanceDialog(aiResponse);
                    }
                } catch (Exception ex) {
                    // Only show error dialog if it's not an ApiKeyMissingException
                    if (!(ex.getCause() instanceof AIBackend.ApiKeyMissingException)) {
                        JOptionPane.showMessageDialog(analysisFrame, 
                            "Error connecting to AI model: " + ex.getMessage(), 
                            "Error", 
                            JOptionPane.ERROR_MESSAGE);
                    }
                }
            }
        };
        
        // Start the background task and show the loading dialog
        worker.execute();
        loadingDialog.setVisible(true);
    }

    private static void showPromptEditor(Model selectedModel, String prompt) {
        // Create an editable text area for the prompt
        JTextArea promptArea = new JTextArea(prompt);
        promptArea.setRows(10);
        promptArea.setColumns(50);
        promptArea.setLineWrap(true);
        promptArea.setWrapStyleWord(true);
        
        // Create a scroll pane for the text area
        JScrollPane scrollPane = new JScrollPane(promptArea);
        
        // Create a panel with a descriptive label
        JPanel promptPanel = new JPanel(new BorderLayout());
        promptPanel.add(new JLabel("Edit prompt before sending:"), BorderLayout.NORTH);
        promptPanel.add(scrollPane, BorderLayout.CENTER);
        
        // Show prompt editor
        int confirm = JOptionPane.showConfirmDialog(analysisFrame,
            promptPanel,
            "Edit and Confirm Prompt",
            JOptionPane.OK_CANCEL_OPTION,
            JOptionPane.PLAIN_MESSAGE);
            
        if (confirm == JOptionPane.OK_OPTION) {
            // Get the current action from our stored reference
            String selectedAction = actionSelector.getSelectedItem().toString();
            
            if (selectedAction.equals("Auto Fix")) {
                sendPromptToAI(selectedModel, promptArea.getText());
            } else {
                sendPromptForDialog(selectedModel, promptArea.getText(), selectedAction);
            }
        }
    }

    private static void showFunctionAcceptanceDialog(String aiResponse) {
        // Split response into functions using the tags
        java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(
            "BEGIN_FUNCTION\\s*(.+?)\\s*END_FUNCTION",
            java.util.regex.Pattern.DOTALL
        );
        java.util.regex.Matcher matcher = pattern.matcher(aiResponse);
        
        JPanel mainPanel = new JPanel(new BorderLayout());
        JPanel functionsPanel = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.weightx = 1.0;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.insets = new Insets(5, 5, 5, 5);

        // Get selected function names from functionList in order
        JList<String> functionList = (JList<String>) ((JScrollPane) ((JPanel) functionAssistPanel.getComponent(1)).getComponent(1)).getViewport().getView();
        List<String> selectedFunctionNames = functionList.getSelectedValuesList();

        TreePath path = fileTree.getSelectionPath();
        if (path == null) {
            JOptionPane.showMessageDialog(analysisFrame, 
                "Please select a class first.", 
                "Error", 
                JOptionPane.ERROR_MESSAGE);
            return;
        }
        String className = getCurrentClassName();

        // Map to track which function names the user has confirmed
        Map<JCheckBox, String> checkboxToCodeMap = new HashMap<>();
        int functionIndex = 0;

        while (matcher.find() && functionIndex < selectedFunctionNames.size()) {
            String function = matcher.group(1).trim();
            if (function.isEmpty()) continue;

            String currentFunctionName = selectedFunctionNames.get(functionIndex);
            
            JPanel functionPanel = new JPanel(new BorderLayout());
            functionPanel.setBorder(BorderFactory.createEtchedBorder());

            // Simplified header with just the checkbox, selected by default
            JCheckBox checkbox = new JCheckBox("Replace function: " + currentFunctionName);
            checkbox.setSelected(true);  // Set checked by default

            JTextArea codeArea = new JTextArea(function);
            codeArea.setRows(8);
            codeArea.setEditable(false);
            JScrollPane scrollPane = new JScrollPane(codeArea);

            functionPanel.add(checkbox, BorderLayout.NORTH);
            functionPanel.add(scrollPane, BorderLayout.CENTER);

            checkboxToCodeMap.put(checkbox, function);

            gbc.gridy++;
            functionsPanel.add(functionPanel, gbc);
            functionIndex++;
        }

        JScrollPane mainScrollPane = new JScrollPane(functionsPanel);
        // Remove fixed height, let it be determined by content
        mainScrollPane.setPreferredSize(new Dimension(800, Math.min(600, functionsPanel.getPreferredSize().height + 50)));
        mainPanel.add(mainScrollPane, BorderLayout.CENTER);

        int result = JOptionPane.showConfirmDialog(analysisFrame,
            mainPanel,
            "Accept or Reject Function Updates",
            JOptionPane.OK_CANCEL_OPTION,
            JOptionPane.PLAIN_MESSAGE);

        if (result == JOptionPane.OK_OPTION) {
            boolean anyUpdates = false;
            functionIndex = 0;
            for (Map.Entry<JCheckBox, String> entry : checkboxToCodeMap.entrySet()) {
                JCheckBox checkbox = entry.getKey();
                if (checkbox.isSelected()) {
                    String newCode = entry.getValue();
                    String functionName = selectedFunctionNames.get(functionIndex);

                    // Ensure comments are present
                    if (!newCode.trim().startsWith("// Class:") && !newCode.trim().startsWith("// Function:")) {
                        StringBuilder contentBuilder = new StringBuilder();
                        contentBuilder.append("// Class: ").append(className).append("\n");
                        contentBuilder.append("// Function: ").append(functionName).append("\n\n");
                        contentBuilder.append(newCode);
                        newCode = contentBuilder.toString();
                    }

                    // Get the executable name for the selected node
                    String executableName = getExecutableNameForSelectedNode(fileTree.getSelectionPath());

                    // Update database and verify
                    dbHandler.updateFunctionDecompilation(functionName, className, newCode, executableName);
                    String verifyUpdate = dbHandler.getFunctionDecompilation(functionName, className, executableName);
                    if (verifyUpdate != null && verifyUpdate.equals(newCode)) {
                        anyUpdates = true;
                    } else {
                        LOGGER.warning("Failed to update function: " + functionName);
                    }
                }
                functionIndex++;
            }

            // Refresh display if any updates were made
            if (anyUpdates) {
                // Get the executable name for the selected node
                String executableName = getExecutableNameForSelectedNode(fileTree.getSelectionPath());
                SwingUtilities.invokeLater(() -> displayClassDecompilation(className, executableName));
            }
        }
    }

    private static boolean isInClassesOrDecompiledTree(TreePath path) {
        return isInClassesTree(path) || isInDecompiledTree(path);
    }


    private static boolean isInClassesTree(TreePath path) {
        return path.getPathCount() > 1 && 
               ((DefaultMutableTreeNode) path.getPathComponent(1)).getUserObject().toString().equals("Classes");
    }

    private static boolean isInFilesTree(TreePath path) {
        return path.getPathCount() > 1 && 
               ((DefaultMutableTreeNode) path.getPathComponent(1)).getUserObject().toString().equals("Files");
    }

    private static boolean isInDecompiledTree(TreePath path) {
        return path.getPathCount() > 1 && 
                ((DefaultMutableTreeNode) path.getPathComponent(1)).getUserObject().toString().equals("Decompiled");
    }

    public static void startEditing(TreePath path) {
        DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
        DefaultMutableTreeNode parentNode = (DefaultMutableTreeNode) node.getParent();
        String functionName = node.getUserObject().toString();
        String className = parentNode.getUserObject().toString();

        // Enable editing and show save button
        fileContentArea.setEditable(true);
        saveButton.setVisible(true);
        isEditing = true;

        // Store current function info for saving later
        fileContentArea.putClientProperty("currentFunction", functionName);
        fileContentArea.putClientProperty("currentClass", className);
    }

    private static void saveCurrentFunction() {
        if (!isEditing) return;

        String functionName = (String) fileContentArea.getClientProperty("currentFunction");
        String className = (String) fileContentArea.getClientProperty("currentClass");
        String newCode = fileContentArea.getText();

        // Update the database
        dbHandler.updateFunctionDecompilation(functionName, className, newCode, projectMacho.getMachoExecutableName());

        // Reset editing state
        fileContentArea.setEditable(false);
        saveButton.setVisible(false);
        isEditing = false;

        // Refresh the display
        String executableName = getExecutableNameForSelectedNode(fileTree.getSelectionPath());
        displayFunctionDecompilation(functionName, className, executableName);
    }

    public static Project getCurrentProject() {
        return currentProject;
    }

    // Add this new method
    public static void populateMachoStringsPanel() {
        if (dbHandler != null && stringsPanel != null) {
            List<Map<String, String>> machoStrings = dbHandler.getMachoStrings();
            
            StringBuilder content = new StringBuilder();
            content.append("<html><body style='font-family: monospace'>");
            
            content.append("<table>");
            content.append("<tr>");
            content.append("<th style='text-align: left; padding-right: 20px'>Value</th>");
            content.append("<th style='text-align: left; padding-right: 20px'>Segment</th>");
            content.append("<th style='text-align: left; padding-right: 20px'>Label</th>");
            content.append("<th style='text-align: left'>File</th>");
            content.append("</tr>");
            
            for (Map<String, String> string : machoStrings) {
                content.append("<tr>");
                content.append("<td style='padding-right: 20px'>").append(string.get("value")).append("</td>");
                content.append("<td style='padding-right: 20px'>").append(string.get("segment")).append("</td>");
                content.append("<td style='padding-right: 20px'>").append(string.get("label")).append("</td>");
                content.append("<td>").append(string.get("ExecutableName")).append("</td>");
                content.append("</tr>");
            }
            
            content.append("</table></body></html>");
            
            // Update panel content
            updatePanelContent(stringsPanel, content.toString());
        }
    }

    // Add this new method to populate the resource strings panel
    private static void populateResourceStringsPanel() {
        if (dbHandler != null && resourceStringsPanel != null) {
            List<Map<String, String>> resourceStrings = dbHandler.getResourceStrings();
            
            // Create table model with column names
            String[] columnNames = {"Value", "File", "Type"};
            Object[][] data = new Object[resourceStrings.size()][3];
            
            // Populate table data
            for (int i = 0; i < resourceStrings.size(); i++) {
                Map<String, String> string = resourceStrings.get(i);
                String value = string.get("value").trim();
                String fullPath = string.get("resourceId");
                String fileName = fullPath.substring(fullPath.lastIndexOf('/') + 1);
                
                // Truncate value if too long
                String truncatedValue = value.length() > 60 ? value.substring(0, 60) + "..." : value;
                
                data[i][0] = truncatedValue;
                data[i][1] = fileName;
                data[i][2] = string.get("type");
            }
            
            // Create table
            JTable table = new JTable(data, columnNames) {
                @Override
                public boolean isCellEditable(int row, int column) {
                    return false;  // Make table read-only
                }
            };
            
            // Add mouse listener for row clicks
            table.addMouseListener(new MouseAdapter() {
                @Override
                public void mouseClicked(MouseEvent e) {
                    if (e.getClickCount() == 2) {  // Only handle double clicks
                        LOGGER.info("Double click detected");
                        
                        int row = table.rowAtPoint(e.getPoint());
                        LOGGER.info("Selected row: " + row);
                        
                        if (row >= 0 && row < resourceStrings.size()) {
                            Map<String, String> selectedString = resourceStrings.get(row);
                            String resourcePath = selectedString.get("resourceId");
                            LOGGER.info("Resource path: " + resourcePath);
                            
                            // Construct the correct path by prepending "Files/" and adding "Resources/"
                            // after the .app/ component if it's not the main Info.plist
                            String fullPath;
                            if (resourcePath.matches("Payload/[^/]+\\.app/Info\\.plist")) {
                                fullPath = "Files/" + resourcePath;
                            } else {
                                // Find the .app/ part and insert Resources/ after it
                                int appIndex = resourcePath.indexOf(".app/");
                                if (appIndex != -1) {
                                    fullPath = "Files/" + resourcePath.substring(0, appIndex + 5) + 
                                             "Resources/" + resourcePath.substring(appIndex + 5);
                                } else {
                                    fullPath = "Files/" + resourcePath;
                                }
                            }
                            LOGGER.info("Constructed full path: " + fullPath);
                            
                            // Find the node and create a TreePath
                            DefaultMutableTreeNode node = findNodeByPath((DefaultMutableTreeNode) treeModel.getRoot(), fullPath);
                            if (node != null) {
                                TreePath path = new TreePath(node.getPath());
                                SelectFile.addFile(path);  // This will handle both opening and activating the file
                                
                                // Find and highlight the string after a short delay
                                String searchValue = selectedString.get("value").trim();
                                LOGGER.info("Searching for value: " + searchValue);
                                
                                SwingUtilities.invokeLater(() -> {
                                    try {
                                        String content = fileContentArea.getText();
                                        LOGGER.info("Content length: " + content.length());
                                        
                                        int index = content.indexOf(searchValue);
                                        LOGGER.info("Found string at index: " + index);
                                        
                                        if (index != -1) {
                                            LOGGER.info("Setting caret and selection");
                                            fileContentArea.setCaretPosition(index);
                                            fileContentArea.setSelectionStart(index);
                                            fileContentArea.setSelectionEnd(index + searchValue.length());
                                            
                                            Rectangle rect = fileContentArea.modelToView(index);
                                            LOGGER.info("View rectangle: " + (rect != null ? rect.toString() : "null"));
                                            
                                            if (rect != null) {
                                                fileContentArea.scrollRectToVisible(rect);
                                                LOGGER.info("Scrolled to make selection visible");
                                            }
                                        } else {
                                            LOGGER.warning("String not found in content");
                                            // Log a small portion of the content for debugging
                                            LOGGER.info("Content preview: " + 
                                                content.substring(0, Math.min(100, content.length())) + "...");
                                        }
                                    } catch (Exception ex) {
                                        LOGGER.log(Level.SEVERE, "Error highlighting text", ex);
                                    }
                                });
                            } else {
                                LOGGER.warning("Could not find node for path: " + fullPath);
                            }
                        } else {
                            LOGGER.warning("Invalid row selected: " + row);
                        }
                    }
                }
            });
            
            // Style the table
            table.setShowGrid(false);
            table.setIntercellSpacing(new Dimension(0, 0));
            table.setRowHeight(25);
            table.getTableHeader().setReorderingAllowed(false);
            
            // Add selection highlighting
            table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
            table.setRowSelectionAllowed(true);
            
            // Set column widths
            TableColumnModel columnModel = table.getColumnModel();
            columnModel.getColumn(0).setPreferredWidth(300);  // Value column
            columnModel.getColumn(1).setPreferredWidth(150);  // File column
            columnModel.getColumn(2).setPreferredWidth(100);  // Type column
            
            // Update the panel's content
            Component[] components = resourceStringsPanel.getComponents();
            for (Component component : components) {
                if (component instanceof JScrollPane) {
                    ((JScrollPane) component).setViewportView(table);
                    break;
                }
            }
        }
    }

    // Helper method to reduce code duplication
    private static void updatePanelContent(JPanel panel, String content) {
        SwingUtilities.invokeLater(() -> {
            Component[] components = panel.getComponents();
            for (Component component : components) {
                if (component instanceof JScrollPane) {
                    JScrollPane scrollPane = (JScrollPane) component;
                    JEditorPane editorPane = new JEditorPane();
                    editorPane.setContentType("text/html");
                    editorPane.setEditable(false);
                    editorPane.setText(content);
                    editorPane.setBackground(null);
                    editorPane.setCaretPosition(0);
                    scrollPane.setViewportView(editorPane);
                    scrollPane.getVerticalScrollBar().setValue(0);
                    
                    // Force the panel to refresh
                    panel.revalidate();
                    panel.repaint();
                    scrollPane.revalidate();
                    scrollPane.repaint();
                }
            }
        });
    }

    public static void setSyntaxStyle(String filePath) {
        if (filePath == null) {
            fileContentArea.setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_NONE);
            return;
        }

        // Classes directory always uses C syntax
        if (filePath.startsWith("Classes/")) {
            fileContentArea.setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_CPLUSPLUS);
            return;
        }

        // Handle different file types
        if (!filePath.endsWith(".plist")) {
            if (filePath.endsWith("embedded.mobileprovision")) {
                fileContentArea.setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_XML);
            } else if (filePath.endsWith(".json")) {
                fileContentArea.setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_JSON);
            } else if (filePath.endsWith(".xml")) {
                fileContentArea.setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_XML);
            } else if (filePath.endsWith(".js")) {
                fileContentArea.setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_JAVASCRIPT);
            } else if (filePath.endsWith(".html") || filePath.endsWith(".htm")) {
                fileContentArea.setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_HTML);
            } else if (filePath.endsWith(".css")) {
                fileContentArea.setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_CSS);
            } else {
                // Default to C syntax for unknown file types
                fileContentArea.setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_CPLUSPLUS);
            }
        }
    }

    public static void showFileContent(String filePath) {
        if (filePath == null) {
            fileContentArea.setText("");
            return;
        }

        SwingUtilities.invokeLater(() -> {
            DefaultMutableTreeNode root = (DefaultMutableTreeNode) treeModel.getRoot();
            DefaultMutableTreeNode targetNode = null;
            
            // Check if this is a class/function path (contains "Classes/")
            if (filePath.startsWith("Classes/")) {
                String[] parts = filePath.split("/");
                if (parts.length >= 2) {
                    String className = parts[1];
                    String functionName = parts.length == 3 ? parts[2] : null;

                    String executableName = getExecutableNameForSelectedNode(fileTree.getSelectionPath());
                    
                    // If it's a function, display just that function
                    if (functionName != null) {
                        displayFunctionDecompilation(functionName, className, executableName);
                    } else {
                        // If it's a class, display the whole class
                        displayClassDecompilation(className, executableName);
                    }
                    
                    // Find the node for tree selection
                    targetNode = findClassOrFunctionNode(root, className, functionName);
                }
            } else {
                // Regular file path handling
                targetNode = findNodeByPath(root, filePath);
                
                if (targetNode != null) {
                    TreePath path = new TreePath(targetNode.getPath());
                    displaySelectedFileContent(new TreeSelectionEvent(fileTree, path, false, null, null));
                }
            }

            // Only update tree selection if not called from SelectFile
            if (targetNode != null && !updatingFromSelectFile) {
                TreePath path = new TreePath(targetNode.getPath());
                fileTree.setSelectionPath(path);
                fileTree.scrollPathToVisible(path);
            }

            setSyntaxStyle(filePath);
            
            // Force focus and repaint
            fileContentArea.requestFocusInWindow();
            fileContentArea.repaint();
        });
    }

    // Add this method to be called from SelectFile
    public static void showFileContentFromSelectFile(String filePath) {
        updatingFromSelectFile = true;
        showFileContent(filePath);
        updatingFromSelectFile = false;
    }

    // Helper method to find a node by path
    private static DefaultMutableTreeNode findNodeByPath(DefaultMutableTreeNode root, String path) {
        path = path.replaceAll("/+", "/");
        
        String[] parts = path.split("/");
        DefaultMutableTreeNode current = root;
        
        for (int i = 0; i < parts.length; i++) {
            boolean found = false;
            
            for (int j = 0; j < current.getChildCount(); j++) {
                DefaultMutableTreeNode child = (DefaultMutableTreeNode) current.getChildAt(j);
                String nodeValue = child.getUserObject().toString().replaceAll("/+", "/");
                
                if (nodeValue.equals(parts[i])) {
                    current = child;
                    j = 0;
                    found = true;
                    break;
                } else if (nodeValue.contains(parts[i]) && i + 1 < parts.length) {
                    String combined = parts[i] + "/" + parts[i + 1] + "/";
                    if (nodeValue.equals(combined)) {
                        current = child;
                        j = 0;
                        i++;
                        found = true;
                        break;
                    }
                }
                    
            }
            
            if (!found) {
                return null; // If any part of the path is not found, return null
            }
        }
        
        return current;
    }

    // Helper method to find class or function node
    private static DefaultMutableTreeNode findClassOrFunctionNode(DefaultMutableTreeNode root, String className, String functionName) {
        // Find Classes root node
        for (int i = 0; i < root.getChildCount(); i++) {
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) root.getChildAt(i);
            if (node.getUserObject().toString().equals("Classes")) {
                // Find class node
                for (int j = 0; j < node.getChildCount(); j++) {
                    DefaultMutableTreeNode classNode = (DefaultMutableTreeNode) node.getChildAt(j);
                    if (classNode.getUserObject().toString().equals(className)) {
                        // If we're looking for a specific function
                        if (functionName != null) {
                            for (int k = 0; k < classNode.getChildCount(); k++) {
                                DefaultMutableTreeNode functionNode = (DefaultMutableTreeNode) classNode.getChildAt(k);
                                if (functionNode.getUserObject().toString().equals(functionName)) {
                                    return functionNode;
                                }
                            }
                        } else {
                            return classNode;
                        }
                    }
                }
            }
        }
        return null;
    }

    public static void zoomIn() {
        if (fileContentArea != null) {
            Font currentFont = fileContentArea.getFont();
            float newSize = currentFont.getSize() + 2.0f;
            if (newSize <= 72.0f) { // Maximum size limit
                fileContentArea.setFont(currentFont.deriveFont(newSize));
            }
        }
    }

    public static void zoomOut() {
        if (fileContentArea != null) {
            Font currentFont = fileContentArea.getFont();
            float newSize = currentFont.getSize() - 2.0f;
            if (newSize >= 8.0f) { // Minimum size limit
                fileContentArea.setFont(currentFont.deriveFont(newSize));
            }
        }
    }

    public static void resetZoom() {
        if (fileContentArea != null) {
            Font currentFont = fileContentArea.getFont();
            fileContentArea.setFont(currentFont.deriveFont(14.0f)); // Reset to default size
        }
    }

    // Add these getter methods
    public static String getCurrentClassName() {
        return currentClassName;
    }

    public static SQLiteDBHandler getDbHandler() {
        return dbHandler;
    }

    public static String getCurrentFunctionName() {
        if (fileContentArea == null) return "";
        
        String content = fileContentArea.getText();
        int caretPosition = fileContentArea.getCaretPosition();
        
        // Split the content into lines for processing
        String[] lines = content.split("\n");
        int currentLine = 0;
        int currentPosition = 0;
        
        // Find which line contains the caret
        while (currentPosition < caretPosition && currentLine < lines.length) {
            currentPosition += lines[currentLine].length() + 1; // +1 for newline
            currentLine++;
        }
        
        // Search backwards from current line to find function declaration
        String currentFunction = "";
        for (int i = currentLine - 1; i >= 0; i--) {
            String line = lines[i].trim();
            
            // Look for function marker comment
            if (line.startsWith("// Function: ")) {
                currentFunction = line.substring("// Function: ".length()).trim();
                break;
            }
            
            // If we hit another function's end or the class declaration, stop searching
            if (line.startsWith("// Function: ") || line.startsWith("// Class: ")) {
                break;
            }
        }
        
        return currentFunction;
    }

    public static String getCurrentSelectedText() {
        return currentSelectedText;
    }

    public static int getCurrentCaretPosition() {
        return currentCaretPosition;
    }

    public static RSyntaxTextArea getFileContentArea() {
        return fileContentArea;
    }

    public static void navigateToLine(int lineNumber) {
        SwingUtilities.invokeLater(() -> {
            try {
                int line = lineNumber - 1; // Convert to 0-based index
                int offset = fileContentArea.getLineStartOffset(line);
                fileContentArea.setCaretPosition(offset);
                
                // Ensure the line is visible
                Rectangle rect = fileContentArea.modelToView(offset);
                if (rect != null) {
                    fileContentArea.scrollRectToVisible(rect);
                }
                
                // Highlight the line
                int lineEnd = fileContentArea.getLineEndOffset(line);
                fileContentArea.setSelectionStart(offset);
                fileContentArea.setSelectionEnd(lineEnd - 1);
                
                fileContentArea.requestFocusInWindow();
                fileContentArea.repaint();
            } catch (Exception e) {
                System.err.println("Error navigating to line: " + e.getMessage());
            }
        });
    }

    // Add this method to setup the search panel
    private static JPanel setupSearchPanel() {
        searchPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        searchPanel.setVisible(false);
        
        // Create search field
        searchField = new JTextField(20);
        searchField.getDocument().addDocumentListener(new javax.swing.event.DocumentListener() {
            public void insertUpdate(javax.swing.event.DocumentEvent e) { performSearch(); }
            public void removeUpdate(javax.swing.event.DocumentEvent e) { performSearch(); }
            public void changedUpdate(javax.swing.event.DocumentEvent e) { performSearch(); }
        });
        
        // Create navigation buttons
        prevButton = new JButton("↑");
        nextButton = new JButton("↓");
        prevButton.setEnabled(false);
        nextButton.setEnabled(false);
        
        // Create match count label
        matchCountLabel = new JLabel("0/0");
        
        // Create close button
        JButton closeButton = new JButton("✕");
        closeButton.setBorder(BorderFactory.createEmptyBorder(2, 4, 2, 4));
        closeButton.addActionListener(e -> toggleSearchPanel());
        
        // Add key bindings for Enter and Shift+Enter
        searchField.addKeyListener(new java.awt.event.KeyAdapter() {
            @Override
            public void keyPressed(java.awt.event.KeyEvent e) {
                if (e.getKeyCode() == java.awt.event.KeyEvent.VK_ENTER) {
                    if (e.isShiftDown()) {
                        findPrevious();
                    } else {
                        findNext();
                    }
                } else if (e.getKeyCode() == java.awt.event.KeyEvent.VK_ESCAPE) {
                    toggleSearchPanel();
                }
            }
        });
        
        // Add button actions
        prevButton.addActionListener(e -> findPrevious());
        nextButton.addActionListener(e -> findNext());
        
        // Add components to panel
        searchPanel.add(searchField);
        searchPanel.add(prevButton);
        searchPanel.add(nextButton);
        searchPanel.add(matchCountLabel);
        searchPanel.add(closeButton);
        
        return searchPanel;
    }

    // Add this method to toggle search panel visibility
    public static void toggleSearchPanel() {
        searchPanel.setVisible(!searchPanel.isVisible());
        if (searchPanel.isVisible()) {
            searchField.requestFocusInWindow();
            searchField.selectAll();
        }
    }

    // Add these methods to handle search functionality
    private static void performSearch() {
        String searchText = searchField.getText();
        searchResults.clear();
        currentSearchIndex = -1;
        
        if (searchText.isEmpty()) {
            updateSearchUI();
            return;
        }
        
        String content = fileContentArea.getText();
        String lowerContent = content.toLowerCase();
        String lowerSearchText = searchText.toLowerCase();
        
        int index = 0;
        while ((index = lowerContent.indexOf(lowerSearchText, index)) != -1) {
            searchResults.add(index);
            index += searchText.length();
        }
        
        if (!searchResults.isEmpty()) {
            currentSearchIndex = 0;
            highlightCurrentMatch();
        }
        
        updateSearchUI();
    }

    private static void findNext() {
        if (searchResults.isEmpty()) return;
        
        currentSearchIndex = (currentSearchIndex + 1) % searchResults.size();
        highlightCurrentMatch();
    }

    private static void findPrevious() {
        if (searchResults.isEmpty()) return;
        
        currentSearchIndex = (currentSearchIndex - 1 + searchResults.size()) % searchResults.size();
        highlightCurrentMatch();
    }

    private static void highlightCurrentMatch() {
        if (currentSearchIndex >= 0 && currentSearchIndex < searchResults.size()) {
            int start = searchResults.get(currentSearchIndex);
            int end = start + searchField.getText().length();
            fileContentArea.setCaretPosition(start);
            fileContentArea.select(start, end);
            
            // Ensure the selection is visible
            try {
                Rectangle rect = fileContentArea.modelToView(start);
                if (rect != null) {
                    fileContentArea.scrollRectToVisible(rect);
                }
            } catch (Exception e) {
                LOGGER.log(Level.WARNING, "Error scrolling to match", e);
            }
        }
    }

    private static void updateSearchUI() {
        boolean hasResults = !searchResults.isEmpty();
        prevButton.setEnabled(hasResults);
        nextButton.setEnabled(hasResults);
        matchCountLabel.setText(hasResults ? 
            (currentSearchIndex + 1) + "/" + searchResults.size() : 
            "0/0");
    }

    private static void setupTreeSelectionListener() {
        fileTree.addTreeSelectionListener((TreeSelectionEvent e) -> {
            DefaultMutableTreeNode selectedNode = (DefaultMutableTreeNode) fileTree.getLastSelectedPathComponent();
            if (selectedNode == null) return;

            // Check if the selected node is a function under "Classes" or "Decompiled"
            if (selectedNode.getLevel() == 3) { // Assuming level 3 is where functions are
                DefaultMutableTreeNode parentNode = (DefaultMutableTreeNode) selectedNode.getParent();
                DefaultMutableTreeNode grandParentNode = (DefaultMutableTreeNode) parentNode.getParent();
                
                String parentName = parentNode.getUserObject().toString();
                String grandParentName = grandParentNode.getUserObject().toString();
                
                if ("Classes".equals(grandParentName) || "Decompiled".equals(grandParentName)) {
                    String functionName = selectedNode.getUserObject().toString();
                    String className = parentName;
                    String executableName = grandParentName.equals("Decompiled") ? grandParentNode.getUserObject().toString() : null;
                    
                    displayFunctionDecompilation(functionName, className, executableName);
                }
            }
        });
    }

    public static String getCurrentExecutableName() {
        TreePath path = fileTree.getSelectionPath();
        if (path != null) {
            return getExecutableNameForSelectedNode(path);
        }
        return null;
    }

    // Add this new method to handle displaying AI responses in a dialog
    private static void sendPromptForDialog(Model selectedModel, String prompt, String action) {
        // Create a loading dialog
        JDialog loadingDialog = new JDialog(analysisFrame, "Processing", true);
        JPanel panel = new JPanel(new BorderLayout(10, 10));
        panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        
        JProgressBar spinner = new JProgressBar();
        spinner.setIndeterminate(true);
        panel.add(spinner, BorderLayout.CENTER);
        
        JLabel statusLabel = new JLabel("Sending request to " + selectedModel.getDisplayName() + "...");
        panel.add(statusLabel, BorderLayout.SOUTH);
        
        loadingDialog.add(panel);
        loadingDialog.pack();
        loadingDialog.setLocationRelativeTo(analysisFrame);
        
        SwingWorker<String, Void> worker = new SwingWorker<String, Void>() {
            @Override
            protected String doInBackground() throws Exception {
                return AIBackend.sendToModel(
                    selectedModel.getProvider(),
                    selectedModel.getModelId(),
                    prompt,
                    config
                );
            }
            
            @Override
            protected void done() {
                loadingDialog.dispose();
                try {
                    String response = get();
                    if (response != null) {
                        // Create and show response dialog
                        JDialog responseDialog = new JDialog(analysisFrame, action + " Results", true);
                        responseDialog.setLayout(new BorderLayout());

                        // Create editor pane with HTML support
                        JEditorPane responsePane = new JEditorPane();
                        responsePane.setEditable(false);
                        responsePane.setContentType("text/html");
                        
                        // Convert markdown to HTML
                        com.vladsch.flexmark.util.data.MutableDataSet options = new com.vladsch.flexmark.util.data.MutableDataSet();
                        com.vladsch.flexmark.parser.Parser parser = com.vladsch.flexmark.parser.Parser.builder(options).build();
                        com.vladsch.flexmark.html.HtmlRenderer renderer = com.vladsch.flexmark.html.HtmlRenderer.builder(options).build();
                        com.vladsch.flexmark.util.ast.Node document = parser.parse(response);
                        String html = "<html><body style='font-family: Arial, sans-serif; padding: 20px;'>" + 
                                    renderer.render(document) + 
                                    "</body></html>";
                        
                        responsePane.setText(html);
                        responsePane.setCaretPosition(0);
                        
                        // Enable hyperlink support
                        responsePane.addHyperlinkListener(e -> {
                            if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
                                try {
                                    Desktop.getDesktop().browse(e.getURL().toURI());
                                } catch (Exception ex) {
                                    LOGGER.log(Level.WARNING, "Error opening URL", ex);
                                }
                            }
                        });
                        
                        JScrollPane scrollPane = new JScrollPane(responsePane);
                        scrollPane.setPreferredSize(new Dimension(800, 600));
                        
                        // Add close button at the bottom
                        JButton closeButton = new JButton("Close");
                        closeButton.addActionListener(e -> responseDialog.dispose());
                        
                        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
                        buttonPanel.add(closeButton);
                        
                        responseDialog.add(scrollPane, BorderLayout.CENTER);
                        responseDialog.add(buttonPanel, BorderLayout.SOUTH);
                        
                        responseDialog.pack();
                        responseDialog.setLocationRelativeTo(analysisFrame);
                        responseDialog.setVisible(true);
                    }
                } catch (Exception ex) {
                    if (!(ex.getCause() instanceof AIBackend.ApiKeyMissingException)) {
                        JOptionPane.showMessageDialog(analysisFrame,
                            "Error connecting to AI model: " + ex.getMessage(),
                            "Error",
                            JOptionPane.ERROR_MESSAGE);
                    }
                }
            }
        };
        
        worker.execute();
        loadingDialog.setVisible(true);
    }
}

```

`src/main/java/com/lauriewired/malimite/ui/ApplicationMenu.java`:

```java
package com.lauriewired.malimite.ui;

import javax.swing.*;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;

import com.lauriewired.malimite.utils.NodeOperations;
import com.lauriewired.malimite.configuration.Config;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;

import com.lauriewired.malimite.database.SQLiteDBHandler;
import com.lauriewired.malimite.ui.AnalysisWindow;
import com.lauriewired.malimite.ui.ReferenceHandler;
import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;

public class ApplicationMenu {
    private final JFrame parentFrame;
    private final JTree fileTree;
    private final Config config;

    public ApplicationMenu(JFrame parentFrame, JTree fileTree, Config config) {
        this.parentFrame = parentFrame;
        this.fileTree = fileTree;
        this.config = config;
    }

    public JMenuBar createMenuBar() {
        JMenuBar menuBar = new JMenuBar();
        menuBar.add(createFileMenu());
        menuBar.add(createViewMenu());
        menuBar.add(createWindowsMenu());
        menuBar.add(createHelpMenu());
        return menuBar;
    }

    private JMenu createFileMenu() {
        JMenu fileMenu = new JMenu("File");
        fileMenu.setMnemonic(KeyEvent.VK_F);

        addMenuItem(fileMenu, "Preferences...", e -> {
            SwingUtilities.invokeLater(() -> PreferencesDialog.show(parentFrame, config));
        }, KeyStroke.getKeyStroke(KeyEvent.VK_COMMA, KeyEvent.CTRL_DOWN_MASK));

        addMenuItem(fileMenu, "Close Window", e -> {
            parentFrame.dispose();
        }, KeyStroke.getKeyStroke(KeyEvent.VK_W, KeyEvent.CTRL_DOWN_MASK));

        fileMenu.addSeparator();

        addMenuItem(fileMenu, "Configure Libraries", e -> {
            SwingUtilities.invokeLater(() -> LibraryConfigDialog.show(parentFrame, config));
        });

        addMenuItem(fileMenu, "Edit Function", e -> {
            TreePath path = fileTree.getSelectionPath();
            if (path != null && path.getPathCount() == 4 && 
                ((DefaultMutableTreeNode)path.getPathComponent(1)).getUserObject().toString().equals("Classes")) {
                AnalysisWindow.startEditing(path);
            } else {
                JOptionPane.showMessageDialog(parentFrame,
                    "Please select a function in the Classes tree to edit.",
                    "No Function Selected",
                    JOptionPane.WARNING_MESSAGE);
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_E, KeyEvent.CTRL_DOWN_MASK));

        return fileMenu;
    }

    private JMenu createViewMenu() {
        JMenu viewMenu = new JMenu("View");
        viewMenu.setMnemonic(KeyEvent.VK_V);

        if (fileTree != null) {
            addMenuItem(viewMenu, "Expand All", e -> 
                NodeOperations.expandAllTreeNodes(fileTree),
                KeyStroke.getKeyStroke(KeyEvent.VK_E, KeyEvent.CTRL_DOWN_MASK)
            );

            viewMenu.addSeparator();

            addMenuItem(viewMenu, "Collapse All", e -> 
                NodeOperations.collapseAllTreeNodes(fileTree),
                KeyStroke.getKeyStroke(KeyEvent.VK_C, KeyEvent.CTRL_DOWN_MASK)
            );

            viewMenu.addSeparator();
        }

        JCheckBoxMenuItem lineWrapItem = new JCheckBoxMenuItem("Line Wrap");
        lineWrapItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_W, KeyEvent.ALT_DOWN_MASK));
        lineWrapItem.addActionListener(e -> {
            RSyntaxTextArea textArea = AnalysisWindow.getFileContentArea();
            if (textArea != null) {
                textArea.setLineWrap(!textArea.getLineWrap());
                textArea.setWrapStyleWord(textArea.getLineWrap());
            }
        });
        viewMenu.add(lineWrapItem);

        viewMenu.addSeparator();

        addMenuItem(viewMenu, "Zoom In", e -> 
            AnalysisWindow.zoomIn(),
            KeyStroke.getKeyStroke(KeyEvent.VK_EQUALS, KeyEvent.CTRL_DOWN_MASK)
        );

        addMenuItem(viewMenu, "Zoom Out", e -> 
            AnalysisWindow.zoomOut(),
            KeyStroke.getKeyStroke(KeyEvent.VK_MINUS, KeyEvent.CTRL_DOWN_MASK)
        );

        addMenuItem(viewMenu, "Reset Zoom", e -> 
            AnalysisWindow.resetZoom(),
            KeyStroke.getKeyStroke(KeyEvent.VK_0, KeyEvent.CTRL_DOWN_MASK)
        );

        return viewMenu;
    }

    private JMenu createWindowsMenu() {
        JMenu windowsMenu = new JMenu("Windows");
        windowsMenu.setMnemonic(KeyEvent.VK_W);

        addMenuItem(windowsMenu, "Search", e -> {
            AnalysisWindow.toggleSearchPanel();
        },
            KeyStroke.getKeyStroke(KeyEvent.VK_F, 
                config.isMac() ? KeyEvent.META_DOWN_MASK : KeyEvent.CTRL_DOWN_MASK)
        );

        addMenuItem(windowsMenu, "Search in Code", e -> {
            String searchTerm = JOptionPane.showInputDialog(parentFrame,
                "Enter search term (variable, method, or class name):",
                "Search in Code",
                JOptionPane.PLAIN_MESSAGE);
            
            if (searchTerm != null && !searchTerm.trim().isEmpty()) {
                SearchResultsDialog.show(parentFrame, AnalysisWindow.getDbHandler(), searchTerm.trim());
            }
        },
            KeyStroke.getKeyStroke(KeyEvent.VK_H, KeyEvent.CTRL_DOWN_MASK)
        );

        addMenuItem(windowsMenu, "Right Panel", e -> {
            AnalysisWindow.toggleRightPanel();
        },
            KeyStroke.getKeyStroke(KeyEvent.VK_L, config.isMac() ? KeyEvent.META_DOWN_MASK : KeyEvent.CTRL_DOWN_MASK)
        );

        windowsMenu.addSeparator();

        addMenuItem(windowsMenu, "Xrefs", e -> {
            String className = AnalysisWindow.getCurrentClassName();
            String functionName = AnalysisWindow.getCurrentFunctionName();
            String executableName = AnalysisWindow.getCurrentExecutableName();
            SQLiteDBHandler dbHandler = AnalysisWindow.getDbHandler();
            RSyntaxTextArea textArea = AnalysisWindow.getFileContentArea();
            
            if (className != null && dbHandler != null && textArea != null) {
                ReferenceHandler.handleReferenceRequest(textArea, parentFrame, className, dbHandler, functionName, executableName);
            }
        },
            KeyStroke.getKeyStroke(KeyEvent.VK_X, KeyEvent.CTRL_DOWN_MASK)
        );

        windowsMenu.addSeparator();

        addMenuItem(windowsMenu, "Entrypoints", e -> {
            EntrypointsDialog.show(parentFrame, AnalysisWindow.getDbHandler());
        });

        return windowsMenu;
    }

    private JMenu createHelpMenu() {
        JMenu helpMenu = new JMenu("Help");
        helpMenu.setMnemonic(KeyEvent.VK_H);

        addMenuItem(helpMenu, "About", e -> 
            JOptionPane.showMessageDialog(parentFrame,
                "Malimite - iOS and macOS Decompiler\nVersion 1.0\n© 2025",
                "About Malimite",
                JOptionPane.INFORMATION_MESSAGE)
        );

        return helpMenu;
    }

    private void addMenuItem(JMenu menu, String text, ActionListener action, KeyStroke accelerator) {
        JMenuItem menuItem = new JMenuItem(text);
        if (accelerator != null) {
            menuItem.setAccelerator(accelerator);
        }
        menuItem.addActionListener(e -> SafeMenuAction.execute(() -> action.actionPerformed(e)));
        menu.add(menuItem);
    }

    private void addMenuItem(JMenu menu, String text, ActionListener action) {
        addMenuItem(menu, text, action, null);
    }
} 
```

`src/main/java/com/lauriewired/malimite/ui/CustomTokenMaker.java`:

```java
package com.lauriewired.malimite.ui;

import javax.swing.text.Segment;
import org.fife.ui.rsyntaxtextarea.*;
import org.fife.ui.rsyntaxtextarea.modes.CPlusPlusTokenMaker;
import com.lauriewired.malimite.tools.RuntimeMethodHandler;

public class CustomTokenMaker extends CPlusPlusTokenMaker {
    // Custom token type for runtime methods
    public static final int RUNTIME_METHOD = Token.IDENTIFIER + 1;

    @Override
    public Token getTokenList(Segment text, int initialTokenType, int startOffset) {
        // Use parent method to generate initial token list
        Token tokenList = super.getTokenList(text, initialTokenType, startOffset);
        Token t = tokenList;

        // Traverse the token list
        while (t != null && t.isPaintable()) {
            if (t.getType() == TokenTypes.IDENTIFIER) {
                String lexeme = t.getLexeme();

                // Check for runtime method prefixes
                if (lexeme.startsWith("_swift_") || lexeme.startsWith("_objc_")) {
                    if (RuntimeMethodHandler.isSwiftRuntimeMethod(lexeme)) {
                        t.setType(RUNTIME_METHOD); // Assign custom token type
                    }
                }
            }
            t = t.getNextToken(); // Move to the next token
        }
        return tokenList;
    }
}

```

`src/main/java/com/lauriewired/malimite/ui/EntrypointsDialog.java`:

```java
package com.lauriewired.malimite.ui;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.*;
import java.util.List;
import com.lauriewired.malimite.database.SQLiteDBHandler;

public class EntrypointsDialog {
    private static final Set<String> ENTRYPOINT_FUNCTIONS = new HashSet<>(Arrays.asList(
        "applicationDidFinishLaunching",
        "application:didFinishLaunchingWithOptions",
        "applicationWillResignActive",
        "applicationDidEnterBackground",
        "applicationWillEnterForeground",
        "applicationDidBecomeActive",
        "applicationWillTerminate",
        "application:configurationForConnectingSceneSession:options",
        "application:didDiscardSceneSessions",
        "application:openURL:options",
        "application:performFetchWithCompletionHandler",
        "application:didReceiveRemoteNotification:fetchCompletionHandler",
        "application:handleEventsForBackgroundURLSession:completionHandler",
        "application:shouldSaveSecureApplicationState",
        "application:shouldRestoreSecureApplicationState",
        "application:didRegisterForRemoteNotificationsWithDeviceToken",
        "application:didFailToRegisterForRemoteNotificationsWithError",
        "application:didReceiveRemoteNotification",
        "application:handleOpenURL",
        "application:continueUserActivity:restorationHandler",
        "application:didUpdateUserActivity",
        "scene:willConnectToSession:options",
        "sceneDidDisconnect",
        "sceneDidBecomeActive",
        "sceneWillResignActive",
        "sceneWillEnterForeground",
        "sceneDidEnterBackground",
        "application:handleWatchKitExtensionRequest:reply",
        "main",
        "loadView",
        "viewDidLoad"
    ));

    public static void show(JFrame parentFrame, SQLiteDBHandler dbHandler) {
        JDialog dialog = new JDialog(parentFrame, "Entrypoints", true);
        dialog.setLayout(new BorderLayout());

        // Create table model with column names
        DefaultTableModel tableModel = new DefaultTableModel(
            new String[]{"Class Name", "Entrypoint Function"}, 
            0
        ) {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false; // Make table read-only
            }
        };

        // Find all entrypoints
        Map<String, List<String>> classesAndFunctions = dbHandler.getAllClassesAndFunctions();
        List<String[]> foundEntrypoints = new ArrayList<>();
        
        for (Map.Entry<String, List<String>> entry : classesAndFunctions.entrySet()) {
            String className = entry.getKey();
            List<String> functions = entry.getValue();
            
            for (String function : functions) {
                if (ENTRYPOINT_FUNCTIONS.contains(function)) {
                    foundEntrypoints.add(new String[]{className, function});
                }
            }
        }

        // Sort entrypoints by class name, then function name
        Collections.sort(foundEntrypoints, (a, b) -> {
            int classCompare = a[0].compareTo(b[0]);
            return classCompare != 0 ? classCompare : a[1].compareTo(b[1]);
        });

        // Add sorted entrypoints to table model
        for (String[] entrypoint : foundEntrypoints) {
            tableModel.addRow(entrypoint);
        }

        // Create and configure the JTable
        JTable entrypointTable = new JTable(tableModel);
        entrypointTable.setFillsViewportHeight(true);
        entrypointTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
        
        // Make columns resize better
        entrypointTable.getColumnModel().getColumn(0).setPreferredWidth(200);
        entrypointTable.getColumnModel().getColumn(1).setPreferredWidth(300);

        // Add double-click listener
        entrypointTable.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (e.getClickCount() == 2) {
                    int row = entrypointTable.rowAtPoint(e.getPoint());
                    if (row >= 0) {
                        String className = (String) tableModel.getValueAt(row, 0);
                        String functionName = (String) tableModel.getValueAt(row, 1);
                        
                        // Close the dialog
                        dialog.dispose();
                        
                        // Navigate to the selected function in the analysis window
                        SwingUtilities.invokeLater(() -> {
                            // Navigate to the function using the path format
                            String path = "Classes/" + className + "/" + functionName;
                            AnalysisWindow.showFileContent(path);
                        });
                    }
                }
            }
        });

        // Add the table to a scroll pane
        JScrollPane scrollPane = new JScrollPane(entrypointTable);
        dialog.add(scrollPane, BorderLayout.CENTER);

        // Add a close button at the bottom
        JButton closeButton = new JButton("Close");
        closeButton.addActionListener(e -> dialog.dispose());
        JPanel buttonPanel = new JPanel();
        buttonPanel.add(closeButton);
        dialog.add(buttonPanel, BorderLayout.SOUTH);

        // Set dialog size and show it
        dialog.setSize(800, 500);
        dialog.setLocationRelativeTo(parentFrame);
        dialog.setVisible(true);
    }
} 
```

`src/main/java/com/lauriewired/malimite/ui/KeyboardShortcuts.java`:

```java
package com.lauriewired.malimite.ui;

import javax.swing.KeyStroke;
import javax.swing.SwingUtilities;
import java.awt.event.KeyEvent;
import java.awt.event.InputEvent;
import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
import java.util.logging.Logger;
import java.util.logging.Level;
import javax.swing.JFrame;

public class KeyboardShortcuts {
    private static final Logger LOGGER = Logger.getLogger(KeyboardShortcuts.class.getName());

    public static void setupShortcuts(RSyntaxTextArea textArea, JFrame parentFrame) {
        // Add 'x' key binding for references
        textArea.getInputMap().put(KeyStroke.getKeyStroke('x'), "showReferences");
        textArea.getActionMap().put("showReferences", new javax.swing.AbstractAction() {
            @Override
            public void actionPerformed(java.awt.event.ActionEvent e) {
                showReferencesForSelectedWord(textArea, parentFrame);
            }
        });
    }

    private static void showReferencesForSelectedWord(RSyntaxTextArea textArea, JFrame parentFrame) {
        String selectedText = textArea.getSelectedText();
        
        // If no text is selected, try to get the word at the cursor
        if (selectedText == null || selectedText.trim().isEmpty()) {
            try {
                int caretPos = textArea.getCaretPosition();
                int start = getWordStart(textArea.getText(), caretPos);
                int end = getWordEnd(textArea.getText(), caretPos);
                if (start != -1 && end != -1) {
                    selectedText = textArea.getText(start, end - start);
                }
            } catch (Exception ex) {
                LOGGER.log(Level.WARNING, "Error getting word at cursor", ex);
                return;
            }
        }

        // Only proceed if we have a word and we're in a class context
        if (selectedText != null && !selectedText.trim().isEmpty()) {
            String currentClassName = AnalysisWindow.getCurrentClassName();
            if (currentClassName != null && !currentClassName.isEmpty()) {
                ReferencesDialog.show(parentFrame, 
                    AnalysisWindow.getDbHandler(), 
                    selectedText.trim(), 
                    AnalysisWindow.getCurrentClassName(),
                    AnalysisWindow.getCurrentFunctionName(),
                    AnalysisWindow.getCurrentExecutableName());
            }
        }
    }

    private static int getWordStart(String text, int pos) {
        if (pos <= 0 || pos >= text.length()) return -1;
        
        while (pos > 0 && isWordChar(text.charAt(pos - 1))) {
            pos--;
        }
        return pos;
    }

    private static int getWordEnd(String text, int pos) {
        if (pos < 0 || pos >= text.length()) return -1;
        
        while (pos < text.length() && isWordChar(text.charAt(pos))) {
            pos++;
        }
        return pos;
    }

    private static boolean isWordChar(char c) {
        return Character.isLetterOrDigit(c) || c == '_';
    }
} 
```

`src/main/java/com/lauriewired/malimite/ui/LibraryConfigDialog.java`:

```java
package com.lauriewired.malimite.ui;

import com.lauriewired.malimite.configuration.LibraryDefinitions;
import com.lauriewired.malimite.configuration.Config;
import javax.swing.*;
import java.awt.*;

public class LibraryConfigDialog {
    public static void show(JFrame parent, Config config) {
        JDialog dialog = new JDialog(parent, "Configure Libraries", true);
        dialog.setLayout(new BorderLayout(10, 10));
        dialog.setSize(450, 500);
        dialog.setLocationRelativeTo(parent);

        // Create info panel
        JPanel infoPanel = new JPanel();
        infoPanel.setLayout(new BorderLayout());
        infoPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        
        JTextArea infoText = new JTextArea(
            "Configure library names to optimize decompilation performance.\n\n" +
            "• Library names are case-sensitive\n" +
            "• Classes starting with these names will be treated as libraries\n" +
            "• Library classes will be skipped during decompilation\n" +
            "• Use this to ignore known frameworks and focus on app-specific code"
        );
        infoText.setEditable(false);
        infoText.setBackground(null);
        infoText.setWrapStyleWord(true);
        infoText.setLineWrap(true);
        infoPanel.add(infoText, BorderLayout.CENTER);
        
        dialog.add(infoPanel, BorderLayout.NORTH);

        // Create list model and populate with active libraries
        DefaultListModel<String> listModel = new DefaultListModel<>();
        LibraryDefinitions.getActiveLibraries(config).forEach(listModel::addElement);

        // Create list with model
        JList<String> libraryList = new JList<>(listModel);
        libraryList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
        
        // Add scroll pane
        JScrollPane scrollPane = new JScrollPane(libraryList);
        dialog.add(scrollPane, BorderLayout.CENTER);

        // Create button panel
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
        
        // Add library button
        JButton addButton = new JButton("Add");
        addButton.addActionListener(e -> {
            String input = JOptionPane.showInputDialog(dialog, 
                "Enter library name:", 
                "Add Library", 
                JOptionPane.PLAIN_MESSAGE);
            
            if (input != null && !input.trim().isEmpty()) {
                String library = input.trim();
                config.addLibrary(library);
                if (!listModel.contains(library)) {
                    listModel.addElement(library);
                }
            }
        });

        // Remove library button
        JButton removeButton = new JButton("Remove");
        removeButton.addActionListener(e -> {
            int[] indices = libraryList.getSelectedIndices();
            for (int i = indices.length - 1; i >= 0; i--) {
                String library = listModel.getElementAt(indices[i]);
                config.removeLibrary(library);
                listModel.remove(indices[i]);
            }
        });

        // Restore defaults button
        JButton restoreButton = new JButton("Restore Defaults");
        restoreButton.addActionListener(e -> {
            int result = JOptionPane.showConfirmDialog(dialog,
                "This will restore all libraries to their default settings.\nContinue?",
                "Restore Defaults",
                JOptionPane.YES_NO_OPTION,
                JOptionPane.WARNING_MESSAGE);
                
            if (result == JOptionPane.YES_OPTION) {
                config.clearLibraryConfigurations();
                listModel.clear();
                LibraryDefinitions.getDefaultLibraries().forEach(listModel::addElement);
            }
        });

        // Close button
        JButton closeButton = new JButton("Close");
        closeButton.addActionListener(e -> dialog.dispose());

        buttonPanel.add(restoreButton);
        buttonPanel.add(addButton);
        buttonPanel.add(removeButton);
        buttonPanel.add(closeButton);
        dialog.add(buttonPanel, BorderLayout.SOUTH);

        dialog.setVisible(true);
    }
} 
```

`src/main/java/com/lauriewired/malimite/ui/PreferencesDialog.java`:

```java
package com.lauriewired.malimite.ui;

import javax.swing.*;
import java.awt.*;
import com.lauriewired.malimite.configuration.Config;
import com.lauriewired.malimite.utils.GhidraSetup;
import com.lauriewired.malimite.Malimite;

public class PreferencesDialog {
    private static JDialog dialog;

    public static void show(JFrame parent, Config config) {
        // Check if dialog is already showing
        if (dialog != null && dialog.isVisible()) {
            dialog.toFront();
            return;
        }

        // Create the dialog
        dialog = new JDialog(parent, "Preferences", true);
        dialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);

        // Create the main panel with some padding
        JPanel mainPanel = new JPanel();
        mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
        mainPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // Theme selection
        JPanel themePanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        themePanel.add(new JLabel("Theme:"));
        JComboBox<String> themeComboBox = new JComboBox<>(new String[]{
            "dark", 
            "light"
        });
        themeComboBox.setSelectedItem(config.getTheme());
        themePanel.add(themeComboBox);
        mainPanel.add(themePanel);

        // Ghidra path setting
        JPanel ghidraPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        ghidraPanel.add(new JLabel("Ghidra Path:"));
        JTextField ghidraPathField = new JTextField(config.getGhidraPath(), 30);
        JButton browseButton = new JButton("Browse");
        
        // Add help icon with tooltip
        JButton helpButton = new JButton("?");
        helpButton.setPreferredSize(new Dimension(20, 20));
        helpButton.setToolTipText("Path to root directory of Ghidra installation");
        helpButton.setFocusPainted(false);
        
        browseButton.addActionListener(e -> {
            JFileChooser fileChooser = new JFileChooser();
            fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
            if (fileChooser.showOpenDialog(dialog) == JFileChooser.APPROVE_OPTION) {
                ghidraPathField.setText(fileChooser.getSelectedFile().getAbsolutePath());
            }
        });
        ghidraPanel.add(ghidraPathField);
        ghidraPanel.add(browseButton);
        ghidraPanel.add(helpButton);  // Add the help button
        mainPanel.add(ghidraPanel);

        // Add some vertical spacing
        mainPanel.add(Box.createVerticalStrut(10));

        // Add OpenAI API Key field
        JPanel openaiPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        openaiPanel.add(new JLabel("OpenAI API Key:"));
        JPasswordField openaiKeyField = new JPasswordField(config.getOpenAIApiKey(), 30);
        openaiPanel.add(openaiKeyField);
        mainPanel.add(openaiPanel);

        /*
        TODO Add back in when claude tested
        // Add Claude API Key field
        JPanel claudePanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        claudePanel.add(new JLabel("Claude API Key:"));
        JPasswordField claudeKeyField = new JPasswordField(config.getClaudeApiKey(), 30);
        claudePanel.add(claudeKeyField);
        mainPanel.add(claudePanel);
        */

        // Add Local Model URL field
        JPanel localModelPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        localModelPanel.add(new JLabel("Local Model URL:"));
        JTextField localModelUrlField = new JTextField(config.getLocalModelUrl(), 30);
        localModelPanel.add(localModelUrlField);
        mainPanel.add(localModelPanel);

        // Add some vertical spacing
        mainPanel.add(Box.createVerticalStrut(10));

        // Buttons panel
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        JButton saveButton = new JButton("Save");
        JButton cancelButton = new JButton("Cancel");

        saveButton.addActionListener(e -> {
            String newTheme = (String) themeComboBox.getSelectedItem();
            String currentTheme = config.getTheme();
            String newGhidraPath = ghidraPathField.getText();
            String currentGhidraPath = config.getGhidraPath();
            
            // Check if Ghidra path has changed
            if (!newGhidraPath.equals(currentGhidraPath)) {
                int response = JOptionPane.showConfirmDialog(dialog,
                    "Ghidra path updated. Downloading JSON dependency to Ghidra directory.\nNote: This will not affect Ghidra",
                    "Setup Required Libraries",
                    JOptionPane.OK_CANCEL_OPTION,
                    JOptionPane.INFORMATION_MESSAGE);
                
                if (response == JOptionPane.OK_OPTION) {
                    GhidraSetup.setupGhidraLibs(newGhidraPath);
                }
            }
            
            // Save all preferences
            config.setTheme(newTheme);
            config.setGhidraPath(newGhidraPath);
            config.setOpenAIApiKey(new String(openaiKeyField.getPassword()));
            //config.setClaudeApiKey(new String(claudeKeyField.getPassword()));
            config.setLocalModelUrl(localModelUrlField.getText());
            config.saveConfig();
            
            // Apply theme change if it was modified
            if (!newTheme.equals(currentTheme)) {
                Malimite.updateTheme(newTheme);
            }
            
            dialog.dispose();
        });        

        cancelButton.addActionListener(e -> dialog.dispose());

        buttonPanel.add(saveButton);
        buttonPanel.add(cancelButton);
        mainPanel.add(buttonPanel);

        // Add the main panel to the dialog
        dialog.add(mainPanel);

        // Size and position the dialog
        dialog.pack();
        dialog.setLocationRelativeTo(parent);
        dialog.setResizable(false);

        // Show the dialog
        dialog.setVisible(true);
    }
} 
```

`src/main/java/com/lauriewired/malimite/ui/ReferenceHandler.java`:

```java
package com.lauriewired.malimite.ui;

import javax.swing.*;
import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
import java.awt.event.KeyEvent;
import java.awt.event.KeyAdapter;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import com.lauriewired.malimite.database.SQLiteDBHandler;

public class ReferenceHandler {
    private static final Pattern IDENTIFIER_PATTERN = Pattern.compile("[a-zA-Z_$][a-zA-Z0-9_$]*");

    public static void attachTo(RSyntaxTextArea textArea, JFrame parent, String className, SQLiteDBHandler dbHandler, String functionName, String executableName) {
        textArea.addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                if (e.getKeyChar() == 'x' || e.getKeyChar() == 'X') {
                    handleReferenceRequest(textArea, parent, className, dbHandler, functionName, executableName);
                }
            }
        });
    }

    public static void handleReferenceRequest(RSyntaxTextArea textArea, JFrame parent, String className, SQLiteDBHandler dbHandler, String functionName, String executableName) {
        String selectedText = textArea.getSelectedText();
        
        if (selectedText == null || selectedText.trim().isEmpty()) {
            // If no text is selected, try to get the word at cursor
            selectedText = getWordAtCursor(textArea);
            if (selectedText == null) return;
        }

        selectedText = selectedText.trim();
        
        // Verify it's a valid identifier
        if (!IDENTIFIER_PATTERN.matcher(selectedText).matches()) {
            return;
        }

        // Show the references dialog
        ReferencesDialog.show(parent, dbHandler, selectedText, className, functionName, executableName);
    }

    public static void handleReferenceRequest(JFrame parent, String className, SQLiteDBHandler dbHandler, String functionName, String executableName) {
        // Show the references dialog without a specific selection
        ReferencesDialog.show(parent, dbHandler, null, className, functionName, executableName);
    }

    private static String getWordAtCursor(RSyntaxTextArea textArea) {
        try {
            int caretPos = textArea.getCaretPosition();
            String text = textArea.getText();
            
            // Find word boundaries
            int start = caretPos;
            int end = caretPos;

            // Look backwards for start of word
            while (start > 0 && isWordChar(text.charAt(start - 1))) {
                start--;
            }

            // Look forwards for end of word
            while (end < text.length() && isWordChar(text.charAt(end))) {
                end++;
            }

            if (start != end) {
                return text.substring(start, end);
            }
        } catch (Exception e) {
            // Handle any potential exceptions gracefully
            return null;
        }
        return null;
    }

    private static boolean isWordChar(char c) {
        return Character.isLetterOrDigit(c) || c == '_' || c == '$';
    }
} 
```

`src/main/java/com/lauriewired/malimite/ui/ReferencesDialog.java`:

```java
package com.lauriewired.malimite.ui;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.util.List;
import java.util.Map;

import com.lauriewired.malimite.database.SQLiteDBHandler;
import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
import java.awt.Rectangle;

public class ReferencesDialog {
    private static JDialog dialog;
    private static JTable referencesTable;
    private static DefaultTableModel tableModel;
    private static SQLiteDBHandler dbHandler;

    public static void show(JFrame parent, SQLiteDBHandler handler, String name, String className, String functionName, String executableName) {
        // Check if dialog is already showing
        if (dialog != null && dialog.isVisible()) {
            dialog.toFront();
            return;
        }

        dbHandler = handler;

        // Determine if this is a local variable or function
        boolean isLocalVariable = isLocalVariable(name, className, functionName, executableName);

        // Create the dialog with appropriate title
        String title = isLocalVariable ? "Variable References" : "Function References";
        dialog = new JDialog(parent, title, false);
        dialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);

        // Create main panel with padding
        JPanel mainPanel = new JPanel(new BorderLayout(10, 10));
        mainPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // Create table model with appropriate columns
        String[] columns;
        if (isLocalVariable) {
            columns = new String[]{"Type", "Variable", "Function", "Line"};
        } else {
            columns = new String[]{"Type", "Source", "Target", "Line"};
        }

        tableModel = new DefaultTableModel(columns, 0) {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };

        // Create and configure the table
        referencesTable = new JTable(tableModel);
        referencesTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        referencesTable.getTableHeader().setReorderingAllowed(false);

        // Add table to scroll pane
        JScrollPane scrollPane = new JScrollPane(referencesTable);
        scrollPane.setPreferredSize(new Dimension(600, 300));
        mainPanel.add(scrollPane, BorderLayout.CENTER);

        // Create info panel at the top
        JPanel infoPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        String infoText = isLocalVariable ? 
            String.format("References for variable '%s' in %s", name, className) :
            String.format("References for function '%s'", name);
        JLabel infoLabel = new JLabel(infoText);
        infoLabel.setFont(infoLabel.getFont().deriveFont(Font.BOLD));
        infoPanel.add(infoLabel);

        // Add type information if it's a local variable
        if (isLocalVariable) {
            String type = getVariableType(name, className, executableName);
            if (type != null) {
                JLabel typeLabel = new JLabel(String.format(" (Type: %s)", type));
                infoPanel.add(typeLabel);
            }
        }

        mainPanel.add(infoPanel, BorderLayout.NORTH);

        // Create button panel at the bottom
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        JButton closeButton = new JButton("Close");
        closeButton.addActionListener(e -> dialog.dispose());
        buttonPanel.add(closeButton);
        mainPanel.add(buttonPanel, BorderLayout.SOUTH);

        // Add the main panel to the dialog
        dialog.add(mainPanel);

        // Load references data
        if (isLocalVariable) {
            System.out.println("Loading local variable references for " + name + " in " + className);
            loadLocalVariableReferences(name, className, functionName, executableName);
        } else {
            System.out.println("Loading function references for " + name + " in " + className);
            loadFunctionReferences(name, className);
        }

        // Add mouse listener for double-click handling
        referencesTable.addMouseListener(new java.awt.event.MouseAdapter() {
            @Override
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                if (evt.getClickCount() == 2) {
                    int row = referencesTable.getSelectedRow();
                    if (row != -1) {
                        handleDoubleClick(row, isLocalVariable);
                    }
                }
            }
        });

        // Size and position the dialog
        dialog.pack();
        dialog.setLocationRelativeTo(parent);

        // Show the dialog
        dialog.setVisible(true);
    }

    private static boolean isLocalVariable(String name, String className, String functionName, String executableName) {
        // First check if it's a known function
        if (dbHandler.isFunctionName(name)) {
            return false; // It's a function
        }


        // Then check if it's a known variable in TypeInformation
        List<Map<String, String>> typeInfo = dbHandler.getTypeInformation(name, className, executableName);
        if (!typeInfo.isEmpty()) {
            return true; // It's a variable with type information
        }

        // Check for local variable references
        List<Map<String, String>> localVarRefs = dbHandler.getLocalVariableReferences(name, className, functionName, executableName);
        if (!localVarRefs.isEmpty()) {
            return true; // It's referenced as a local variable
        }

        // If we can't definitively determine it's a variable, assume it's a function
        return false;
    }

    private static String getVariableType(String variableName, String className, String executableName) {
        List<Map<String, String>> typeInfo = dbHandler.getTypeInformation(variableName, className, executableName);
        if (!typeInfo.isEmpty()) {
            return typeInfo.get(0).get("variableType");
        }
        return null;
    }

    private static void loadLocalVariableReferences(String variableName, String className, String functionName, String executableName) {
        // Clear existing table data
        tableModel.setRowCount(0);

        // Get local variable references
        List<Map<String, String>> references = dbHandler.getLocalVariableReferences(variableName, className, functionName, executableName);

        // Add references to table
        for (Map<String, String> reference : references) {
            String type = "LOCAL_VAR";
            String variable = reference.get("variableName");
            String function = formatReference(reference.get("containingFunction"), 
                                           reference.get("containingClass"));
            String line = reference.get("lineNumber");

            tableModel.addRow(new Object[]{type, variable, function, line});
        }

        // Adjust column widths
        referencesTable.getColumnModel().getColumn(0).setPreferredWidth(100); // Type
        referencesTable.getColumnModel().getColumn(1).setPreferredWidth(150); // Variable
        referencesTable.getColumnModel().getColumn(2).setPreferredWidth(250); // Function
        referencesTable.getColumnModel().getColumn(3).setPreferredWidth(100); // Line
    }

    private static void loadFunctionReferences(String functionName, String className) {
        // Clear existing table data
        tableModel.setRowCount(0);

        // Get function references
        List<Map<String, String>> references = dbHandler.getFunctionCrossReferences(functionName);

        // Add references to table
        for (Map<String, String> reference : references) {
            String type = reference.get("referenceType");
            String source = formatReference(reference.get("sourceFunction"), 
                                         reference.get("sourceClass"));
            String target = formatReference(reference.get("targetFunction"), 
                                         reference.get("targetClass"));
            String line = reference.get("lineNumber");

            tableModel.addRow(new Object[]{type, source, target, line});
        }

        // Adjust column widths
        referencesTable.getColumnModel().getColumn(0).setPreferredWidth(100); // Type
        referencesTable.getColumnModel().getColumn(1).setPreferredWidth(200); // Source
        referencesTable.getColumnModel().getColumn(2).setPreferredWidth(200); // Target
        referencesTable.getColumnModel().getColumn(3).setPreferredWidth(100); // Line
    }

    private static String formatReference(String function, String className) {
        if (function == null || className == null) {
            return "Unknown";
        }
        return String.format("%s::%s", className, function);
    }

    private static void handleDoubleClick(int row, boolean isLocalVariable) {
        String targetClass;
        String targetFunction;
        String lineNumber;

        if (isLocalVariable) {
            // For local variables, the function column contains "class::function"
            String functionRef = (String) tableModel.getValueAt(row, 2);
            String[] parts = functionRef.split("::");
            if (parts.length == 2) {
                targetClass = parts[0];
                targetFunction = parts[1];
            } else {
                return;
            }
            lineNumber = (String) tableModel.getValueAt(row, 3);
        } else {
            // For function references, use the source column instead of target
            String sourceRef = (String) tableModel.getValueAt(row, 1);
            String[] parts = sourceRef.split("::");
            if (parts.length == 2) {
                targetClass = parts[0];
                targetFunction = parts[1];
            } else {
                return;
            }
            lineNumber = (String) tableModel.getValueAt(row, 3);
        }

        // Navigate to the file and line
        SwingUtilities.invokeLater(() -> {
            // Build the path for the file (Classes/className/functionName)
            String filePath = String.format("Classes/%s/%s", targetClass, targetFunction);
            
            // Show the file content
            AnalysisWindow.showFileContent(filePath);
            
            // Navigate to line after content is loaded
            if (lineNumber != null) {
                try {
                    int line = Integer.parseInt(lineNumber);
                    AnalysisWindow.navigateToLine(line);
                } catch (NumberFormatException e) {
                    System.err.println("Invalid line number: " + lineNumber);
                }
            }
        });
    }
} 
```

`src/main/java/com/lauriewired/malimite/ui/SafeMenuAction.java`:

```java
package com.lauriewired.malimite.ui;

import javax.swing.JDialog;
import javax.swing.SwingUtilities;
import java.util.logging.Logger;

public class SafeMenuAction {
    private static final Logger LOGGER = Logger.getLogger(SafeMenuAction.class.getName());
    private static boolean menuActionInProgress = false;
    private static final Object menuLock = new Object();
    private static JDialog preferencesDialog = null;

    public static void execute(Runnable action) {
        synchronized (menuLock) {
            if (menuActionInProgress) {
                return;  // Prevents simultaneous actions
            }
            menuActionInProgress = true;
        }

        SwingUtilities.invokeLater(() -> {
            try {
                action.run();
            } catch (Exception ex) {
                LOGGER.severe("Error in menu action: " + ex.getMessage());
            } finally {
                releaseMenuLock();  // Ensure the lock is always released
            }
        });
    }

    private static void releaseMenuLock() {
        synchronized (menuLock) {
            menuActionInProgress = false;
        }
    }

    public static JDialog getPreferencesDialog() {
        return preferencesDialog;
    }

    public static void setPreferencesDialog(JDialog dialog) {
        cleanupPreferencesDialog();  // Ensure old dialog is disposed
        preferencesDialog = dialog;
    }

    public static void cleanupPreferencesDialog() {
        if (preferencesDialog != null) {
            preferencesDialog.dispose();  // Dispose of existing dialog to avoid conflicts
            preferencesDialog = null;
        }
    }
}
```

`src/main/java/com/lauriewired/malimite/ui/SearchResultsDialog.java`:

```java
package com.lauriewired.malimite.ui;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.util.List;
import java.util.Map;

import com.lauriewired.malimite.database.SQLiteDBHandler;

public class SearchResultsDialog {
    private static JDialog dialog;
    private static JTable resultsTable;
    private static DefaultTableModel tableModel;

    public static void show(JFrame parent, SQLiteDBHandler dbHandler, String searchTerm) {
        // Check if dialog is already showing
        if (dialog != null && dialog.isVisible()) {
            dialog.dispose();
        }

        // Create the dialog
        dialog = new JDialog(parent, "Search Results", false);
        dialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);

        // Create main panel with padding
        JPanel mainPanel = new JPanel(new BorderLayout(10, 10));
        mainPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // Create table model
        String[] columns = {"Type", "Name", "Location", "Line"};
        tableModel = new DefaultTableModel(columns, 0) {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };

        // Create and configure the table
        resultsTable = new JTable(tableModel);
        resultsTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        resultsTable.getTableHeader().setReorderingAllowed(false);

        // Add table to scroll pane
        JScrollPane scrollPane = new JScrollPane(resultsTable);
        scrollPane.setPreferredSize(new Dimension(800, 400));
        mainPanel.add(scrollPane, BorderLayout.CENTER);

        // Create info panel at the top
        JPanel infoPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        JLabel infoLabel = new JLabel("Search results for: " + searchTerm);
        infoLabel.setFont(infoLabel.getFont().deriveFont(Font.BOLD));
        infoPanel.add(infoLabel);
        mainPanel.add(infoPanel, BorderLayout.NORTH);

        // Create button panel at the bottom
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        JButton closeButton = new JButton("Close");
        closeButton.addActionListener(e -> dialog.dispose());
        buttonPanel.add(closeButton);
        mainPanel.add(buttonPanel, BorderLayout.SOUTH);

        // Add the main panel to the dialog
        dialog.add(mainPanel);

        // Load search results
        List<Map<String, String>> results = dbHandler.searchCodebase(searchTerm);
        loadSearchResults(results);

        // Add double-click handler
        resultsTable.addMouseListener(new java.awt.event.MouseAdapter() {
            @Override
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                if (evt.getClickCount() == 2) {
                    int row = resultsTable.getSelectedRow();
                    if (row != -1) {
                        handleDoubleClick(row);
                    }
                }
            }
        });

        // Size and position the dialog
        dialog.pack();
        dialog.setLocationRelativeTo(parent);

        // Show the dialog
        dialog.setVisible(true);
    }

    private static void loadSearchResults(List<Map<String, String>> results) {
        tableModel.setRowCount(0);
        
        for (Map<String, String> result : results) {
            tableModel.addRow(new Object[]{
                result.get("type"),
                result.get("name"),
                result.get("container"),
                result.get("line")
            });
        }

        // Adjust column widths
        resultsTable.getColumnModel().getColumn(0).setPreferredWidth(100);  // Type
        resultsTable.getColumnModel().getColumn(1).setPreferredWidth(200);  // Name
        resultsTable.getColumnModel().getColumn(2).setPreferredWidth(400);  // Location
        resultsTable.getColumnModel().getColumn(3).setPreferredWidth(100);  // Line
    }

    private static void handleDoubleClick(int row) {
        String type = (String) tableModel.getValueAt(row, 0);
        String name = (String) tableModel.getValueAt(row, 1);
        String container = (String) tableModel.getValueAt(row, 2);
        String line = (String) tableModel.getValueAt(row, 3);

        SwingUtilities.invokeLater(() -> {
            String path;
            if ("Class".equals(type)) {
                path = "Classes/" + name;
            } else if ("Function".equals(type)) {
                path = "Classes/" + container + "/" + name;
            } else { // Variable
                String[] parts = container.split(" in ");
                if (parts.length == 2) {
                    path = "Classes/" + parts[1] + "/" + parts[0];
                } else {
                    return;
                }
            }

            // Show the file content
            AnalysisWindow.showFileContent(path);
            
            // Navigate to line if available
            if (line != null && !line.isEmpty()) {
                try {
                    int lineNum = Integer.parseInt(line);
                    AnalysisWindow.navigateToLine(lineNum);
                } catch (NumberFormatException e) {
                    System.err.println("Invalid line number: " + line);
                }
            }
        });
    }
} 
```

`src/main/java/com/lauriewired/malimite/ui/SelectFile.java`:

```java
package com.lauriewired.malimite.ui;

import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.FlowLayout;
import java.awt.Insets;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;
import java.util.logging.Level;

public class SelectFile {
    private static final Map<String, FileTab> openFiles = new HashMap<>();
    private static final List<String> fileOrder = new ArrayList<>();
    private static final JPanel fileTabsContainer = new JPanel(new BorderLayout());
    private static final JPanel fileTabsPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 2, 0));
    private static final JButton leftArrow = new JButton("◀");
    private static final JButton rightArrow = new JButton("▶");
    private static String activeFile = null;
    private static int scrollPosition = 0;
    private static final Logger LOGGER = Logger.getLogger(SelectFile.class.getName());
    
    private static class FileTab extends JPanel {
        private boolean active = false;
        private final String filePath;
        private final JLabel nameLabel;
        private final JLabel closeButton;
        
        public FileTab(String path, Runnable onClose) {
            this.filePath = path;
            setLayout(new FlowLayout(FlowLayout.LEFT, 2, 0));
            setOpaque(false);
            
            // Extract just the file name from the path
            String fileName = path.contains("/") ? 
                path.substring(path.lastIndexOf('/') + 1) : path;
            
            nameLabel = new JLabel(fileName);
            nameLabel.setBorder(BorderFactory.createEmptyBorder(2, 3, 2, 3));
            nameLabel.setCursor(new Cursor(Cursor.HAND_CURSOR));
            
            closeButton = new JLabel("×");
            closeButton.setFont(closeButton.getFont().deriveFont(14f));
            closeButton.setCursor(new Cursor(Cursor.HAND_CURSOR));
            closeButton.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));
            
            add(nameLabel);
            add(closeButton);
            
            this.addMouseListener(new MouseAdapter() {
                @Override
                public void mouseClicked(MouseEvent e) {
                    if (e.getButton() == MouseEvent.BUTTON2) {
                        onClose.run();
                        return;
                    }
                    setActiveFile(filePath);
                }

                @Override
                public void mouseEntered(MouseEvent e) {
                    setHovered(true);
                }

                @Override
                public void mouseExited(MouseEvent e) {
                    setHovered(false);
                }
            });
            
            closeButton.addMouseListener(new MouseAdapter() {
                @Override
                public void mouseClicked(MouseEvent e) {
                    onClose.run();
                }
            });
        }
        
        public void setActive(boolean active) {
            this.active = active;
            setHovered(active);
            if (active) {
                setBorder(BorderFactory.createCompoundBorder(
                    BorderFactory.createMatteBorder(0, 0, 2, 0, Color.GRAY),
                    BorderFactory.createEmptyBorder(2, 2, 0, 2)
                ));
            } else {
                setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));
            }
        }

        public void setHovered(boolean hovered) {
            nameLabel.setForeground(hovered || active ? Color.WHITE : new Color(187, 187, 187));
            closeButton.setForeground(hovered || active ? Color.WHITE : new Color(187, 187, 187));
        }
    }
    
    public static JPanel getFileTabsPanel() {
        // Setup scroll buttons
        leftArrow.setMargin(new Insets(0, 2, 0, 2));
        rightArrow.setMargin(new Insets(0, 2, 0, 2));
        
        leftArrow.addActionListener(e -> scroll(-1));
        rightArrow.addActionListener(e -> scroll(1));
        
        // Add components to container
        fileTabsContainer.add(leftArrow, BorderLayout.WEST);
        fileTabsContainer.add(fileTabsPanel, BorderLayout.CENTER);
        fileTabsContainer.add(rightArrow, BorderLayout.EAST);
        
        return fileTabsContainer;
    }
    
    public static void addFile(TreePath path) {
        //printDebugState("addFile - start");
        DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
        String filePath = buildPathFromNode(node);
        
        // Remove "Empty" tab if it exists
        Component[] components = fileTabsPanel.getComponents();
        for (Component comp : components) {
            if (comp instanceof JLabel && "Empty".equals(((JLabel) comp).getText())) {
                fileTabsPanel.remove(comp);
            }
        }
        
        // Check if file is already open
        if (!openFiles.containsKey(filePath)) {
            FileTab tab = new FileTab(filePath, () -> closeFile(filePath));
            openFiles.put(filePath, tab);
            fileOrder.add(filePath);
            
            // Add the tab to the panel
            fileTabsPanel.add(tab);
        }

        // Force layout update
        fileTabsPanel.revalidate();
        fileTabsContainer.revalidate();
        fileTabsPanel.repaint();
        fileTabsContainer.repaint();
        
        // Set as active file
        setActiveFile(filePath);
        //printDebugState("addFile - end");
    }
    
    private static void closeFile(String filePath) {
        LOGGER.info("Closing file: " + filePath);
        FileTab tab = openFiles.remove(filePath);
        if (tab != null) {
            fileTabsPanel.remove(tab);
            fileOrder.remove(filePath);
            
            if (openFiles.isEmpty()) {
                addEmptyTab();
                setActiveFile(null);
            } else if (filePath.equals(activeFile)) {
                int index = fileOrder.indexOf(filePath);
                if (index > 0) {
                    setActiveFile(fileOrder.get(index - 1));
                } else if (!fileOrder.isEmpty()) {
                    setActiveFile(fileOrder.get(0));
                }
            }
            
            fileTabsPanel.revalidate();
            fileTabsPanel.repaint();
        }
    }
    
    private static void setActiveFile(String filePath) {
        LOGGER.info("Setting active file: " + filePath);
        // Prevent unnecessary updates if the file is already active
        if (filePath != null && filePath.equals(activeFile)) {
            return;
        }

        activeFile = filePath;
        openFiles.forEach((path, tab) -> tab.setActive(path.equals(filePath)));
        
        // Force layout update
        fileTabsPanel.revalidate();
        fileTabsContainer.revalidate();
        fileTabsPanel.repaint();
        fileTabsContainer.repaint();
        
        // Always notify AnalysisWindow to update content, whether filePath is null or not
        AnalysisWindow.showFileContent(filePath);
    }
    
    private static String buildPathFromNode(DefaultMutableTreeNode node) {
        StringBuilder path = new StringBuilder(node.toString());
        DefaultMutableTreeNode parent = (DefaultMutableTreeNode) node.getParent();
        
        while (parent != null && !parent.isRoot()) {
            path.insert(0, parent.toString() + "/");
            parent = (DefaultMutableTreeNode) parent.getParent();
        }
        
        return path.toString();
    }
    
    public static void clear() {
        //printDebugState("clear - start");
        openFiles.clear();
        fileOrder.clear();
        fileTabsPanel.removeAll();
        fileTabsPanel.revalidate();
        fileTabsPanel.repaint();
        activeFile = null;
        scrollPosition = 0;
        //printDebugState("clear - end");
    }

    private static void addEmptyTab() {
        JLabel emptyLabel = new JLabel("Empty");
        emptyLabel.setBorder(BorderFactory.createEmptyBorder(2, 5, 2, 5));
        fileTabsPanel.add(emptyLabel);
    }

    private static void scroll(int direction) {
        //printDebugState("scroll - start");
        if (fileOrder.isEmpty()) return;
        
        int currentIndex = activeFile != null ? fileOrder.indexOf(activeFile) : -1;
        int newIndex = currentIndex + direction;
        
        if (newIndex >= 0 && newIndex < fileOrder.size()) {
            String newFilePath = fileOrder.get(newIndex);
            setActiveFile(newFilePath); // Sets the new active file
    
            // Ensure this tab is visible in the viewport
            ensureTabVisible(newIndex);
    
            // Force content update in AnalysisWindow
            AnalysisWindow.showFileContent(newFilePath);
        }
        //printDebugState("scroll - end");
    }    

    private static void ensureTabVisible(int index) {
        if (index < 0 || index >= fileTabsPanel.getComponentCount()) return;
    
        Component tab = fileTabsPanel.getComponent(index);
        int tabLeft = tab.getX();
        int tabRight = tabLeft + tab.getWidth();
        int visibleWidth = fileTabsPanel.getParent().getWidth() - leftArrow.getWidth() - rightArrow.getWidth();
    
        if (tabLeft < -scrollPosition) {
            // Scroll left to make the tab visible
            scrollPosition = -tabLeft;
        } else if (tabRight > -scrollPosition + visibleWidth) {
            // Scroll right to make the tab visible
            scrollPosition = -(tabRight - visibleWidth);
        }
    
        // Apply the scroll position to each tab component
        for (Component comp : fileTabsPanel.getComponents()) {
            comp.setLocation(comp.getX() - scrollPosition, comp.getY());
        }
    
        fileTabsPanel.revalidate();
        fileTabsPanel.repaint();
    }

    public static void handleNodeClick(TreePath path) {
        DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
        String filePath = buildPathFromNode(node);
        
        // Only update if the file is already open and not currently active
        if (openFiles.containsKey(filePath) && !filePath.equals(activeFile)) {
            setActiveFile(filePath);
        }
    }

    public static void replaceActiveFile(TreePath path) {
        LOGGER.info("Replacing active file: " + path);
        DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
        String filePath = buildPathFromNode(node);
        
        // Remove current active file if it exists
        if (activeFile != null) {
            FileTab oldTab = openFiles.remove(activeFile);
            if (oldTab != null) {
                fileTabsPanel.remove(oldTab);
                fileOrder.remove(activeFile);
            }
        }
        
        // Add new file
        FileTab tab = new FileTab(filePath, () -> closeFile(filePath));
        openFiles.put(filePath, tab);
        fileOrder.add(filePath);
        fileTabsPanel.add(tab);
        
        // Set as active
        setActiveFile(filePath);
        
        fileTabsPanel.revalidate();
        fileTabsPanel.repaint();
    }

    public static boolean isFileOpen(TreePath path) {
        DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
        String filePath = buildPathFromNode(node);
        return openFiles.containsKey(filePath);
    }

    private static void printDebugState(String functionName) {
        LOGGER.fine(() -> "\n=== " + functionName + " ===\n" +
                   "openFiles: " + openFiles.keySet() + "\n" +
                   "fileOrder: " + fileOrder + "\n" +
                   "activeFile: " + activeFile);
    }
}

```

`src/main/java/com/lauriewired/malimite/ui/SyntaxHighlighter.java`:

```java
package com.lauriewired.malimite.ui;

import java.awt.Color;
import java.awt.Container;
import java.awt.Insets;

import javax.swing.BorderFactory;
import javax.swing.UIManager;

import org.fife.ui.rtextarea.RTextScrollPane;
import org.fife.ui.rtextarea.Gutter;
import org.fife.ui.rsyntaxtextarea.AbstractTokenMakerFactory;
import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
import org.fife.ui.rsyntaxtextarea.SyntaxConstants;
import org.fife.ui.rsyntaxtextarea.SyntaxScheme;
import org.fife.ui.rsyntaxtextarea.Token;
import org.fife.ui.rsyntaxtextarea.TokenMakerFactory;
import org.fife.ui.rtextarea.SmartHighlightPainter;
import javax.swing.text.Highlighter;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.HashMap;
import java.util.Map;
import com.lauriewired.malimite.tools.RuntimeMethodHandler;
import org.fife.ui.rsyntaxtextarea.Style;

public class SyntaxHighlighter {

    private static final Logger LOGGER = Logger.getLogger(SyntaxHighlighter.class.getName());
    private static final Color HIGHLIGHT_COLOR = new Color(255, 255, 0, 70);
    private static final List<Object> wordHighlights = new ArrayList<>(); // Track word highlights
    private static final Map<String, Color> customWordColors = new HashMap<>();

    public static void applyCustomTheme(RSyntaxTextArea textArea) {
        // Register the custom TokenMaker for the C++ syntax style
        AbstractTokenMakerFactory factory = (AbstractTokenMakerFactory) TokenMakerFactory.getDefaultInstance();
        factory.putMapping(SyntaxConstants.SYNTAX_STYLE_CPLUSPLUS, "com.lauriewired.malimite.ui.CustomTokenMaker");
        
        textArea.setSyntaxEditingStyle(SyntaxConstants.SYNTAX_STYLE_CPLUSPLUS);

        // Get the current theme's background color from UIManager
        Color themeBackground = UIManager.getColor("Panel.background");
        if (themeBackground == null) {
            // Fallback if UIManager color is not available
            themeBackground = textArea.getBackground();
        }
    
        boolean isDarkTheme = isDarkTheme(themeBackground);
    
        // Reset the syntax scheme to ensure clean state
        textArea.setSyntaxScheme(new SyntaxScheme(true));
        SyntaxScheme scheme = textArea.getSyntaxScheme();
        
        // Ensure the scheme can handle our custom token
        Color runtimeMethodColor = isDarkTheme 
            ? new Color(210, 240, 255)  // Very light blue for dark theme (much lighter than #9CDCFE)
            : new Color(0, 150, 255);   // Brighter blue for light theme (lighter than #001080)
        scheme.setStyle(CustomTokenMaker.RUNTIME_METHOD, new Style(runtimeMethodColor));
    
        // Background colors based on the theme
        Color editorBackground = isDarkTheme ? themeBackground : Color.WHITE;  // Use white for light theme
        Color lineHighlight = isDarkTheme ? 
            adjustBrightness(themeBackground, 1.2f) : 
            new Color(240, 240, 240);  // Light gray for light theme
        Color lineNumberBackground = isDarkTheme ? themeBackground : Color.WHITE;
        //Color lineNumberForeground = isDarkTheme ? Color.decode("#CCCCCC") : Color.decode("#333333");
    
        // Set the syntax colors for the theme
        if (isDarkTheme) {
            Color dataTypeColor = Color.decode("#4EC9B0");
            Color booleanColor = Color.decode("#569CD6");
            scheme.getStyle(Token.RESERVED_WORD).foreground = Color.decode("#569CD6");
            scheme.getStyle(Token.RESERVED_WORD_2).foreground = dataTypeColor;
            scheme.getStyle(Token.DATA_TYPE).foreground = dataTypeColor;
            scheme.getStyle(Token.FUNCTION).foreground = Color.decode("#DCDCAA");
            scheme.getStyle(Token.LITERAL_NUMBER_DECIMAL_INT).foreground = Color.decode("#D7BA7D");
            scheme.getStyle(Token.LITERAL_NUMBER_HEXADECIMAL).foreground = Color.decode("#D7BA7D");
            scheme.getStyle(Token.LITERAL_BOOLEAN).foreground = booleanColor;
            scheme.getStyle(Token.LITERAL_STRING_DOUBLE_QUOTE).foreground = Color.decode("#CE9178");
            scheme.getStyle(Token.COMMENT_MULTILINE).foreground = Color.decode("#57A64A");
            scheme.getStyle(Token.COMMENT_DOCUMENTATION).foreground = Color.decode("#57A64A");
            scheme.getStyle(Token.COMMENT_EOL).foreground = Color.decode("#57A64A");
            scheme.getStyle(Token.OPERATOR).foreground = Color.WHITE;
            scheme.getStyle(Token.SEPARATOR).foreground = Color.WHITE;
            scheme.getStyle(Token.IDENTIFIER).foreground = Color.decode("#9CDCFE");
            // XML-specific colors for dark theme
            scheme.getStyle(Token.MARKUP_TAG_DELIMITER).foreground = Color.decode("#808080");    // Gray for < > /
            scheme.getStyle(Token.MARKUP_TAG_NAME).foreground = Color.decode("#569CD6");         // Blue for tag names
            scheme.getStyle(Token.MARKUP_TAG_ATTRIBUTE).foreground = Color.decode("#9CDCFE");    // Light blue for attributes
            scheme.getStyle(Token.MARKUP_TAG_ATTRIBUTE_VALUE).foreground = Color.decode("#CE9178"); // Orange for values
        } else {
            Color booleanColor = Color.decode("#0451A5");
            Color keyColor = Color.decode("#4A7A4F"); // Soft green for keys
            Color valueColor = Color.decode("#376E9B"); // Soft blue for values
            scheme.getStyle(Token.RESERVED_WORD).foreground = Color.decode("#0000FF");
            scheme.getStyle(Token.DATA_TYPE).foreground = Color.decode("#267F99");
            scheme.getStyle(Token.FUNCTION).foreground = Color.decode("#795E26");
            scheme.getStyle(Token.LITERAL_NUMBER_DECIMAL_INT).foreground = Color.decode("#098658");
            scheme.getStyle(Token.LITERAL_NUMBER_HEXADECIMAL).foreground = Color.decode("#098658");
            scheme.getStyle(Token.LITERAL_BOOLEAN).foreground = booleanColor;
            scheme.getStyle(Token.LITERAL_STRING_DOUBLE_QUOTE).foreground = valueColor; // Soft blue for values
            scheme.getStyle(Token.MARKUP_TAG_NAME).foreground = keyColor; // Soft green for tag names (keys)
            scheme.getStyle(Token.COMMENT_MULTILINE).foreground = Color.decode("#008000");
            scheme.getStyle(Token.COMMENT_DOCUMENTATION).foreground = Color.decode("#008000");
            scheme.getStyle(Token.COMMENT_EOL).foreground = Color.decode("#008000");
            scheme.getStyle(Token.OPERATOR).foreground = Color.decode("#333333");
            scheme.getStyle(Token.SEPARATOR).foreground = Color.decode("#333333");
            scheme.getStyle(Token.IDENTIFIER).foreground = Color.decode("#001080");
            // XML-specific colors for light theme
            scheme.getStyle(Token.MARKUP_TAG_DELIMITER).foreground = Color.decode("#800000");    // Dark red for < > /
            scheme.getStyle(Token.MARKUP_TAG_NAME).foreground = Color.decode("#800000");         // Dark red for tag names
            scheme.getStyle(Token.MARKUP_TAG_ATTRIBUTE).foreground = Color.decode("#FF0000");    // Red for attributes
            scheme.getStyle(Token.MARKUP_TAG_ATTRIBUTE_VALUE).foreground = Color.decode("#0000FF"); // Blue for values
        }
    
        // Apply background colors
        textArea.setBackground(editorBackground);
        textArea.setCurrentLineHighlightColor(lineHighlight);
        textArea.setFadeCurrentLineHighlight(true);
    
        // Reset gutter colors directly to ensure the change applies
        Container parent = textArea.getParent();
        if (parent != null && parent.getParent() instanceof RTextScrollPane) {
            RTextScrollPane scrollPane = (RTextScrollPane) parent.getParent();
            Gutter gutter = scrollPane.getGutter();
            gutter.setBackground(lineNumberBackground);
            //gutter.setLineNumberColor(lineNumberForeground);
            //gutter.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));
        }
    
        // Add these lines after setting the background colors
        Color selectionColor = isDarkTheme ? 
            new Color(51, 153, 255, 90) :  // Semi-transparent blue for dark theme
            new Color(51, 153, 255, 50);   // Lighter blue for light theme
        textArea.setSelectionColor(selectionColor);
    
        textArea.revalidate();
        textArea.repaint();
    }    

    private static boolean isDarkTheme(Color background) {
        double brightness = (background.getRed() * 0.299 + 
                           background.getGreen() * 0.587 + 
                           background.getBlue() * 0.114) / 255;
        return brightness < 0.5;
    }

    private static Color adjustBrightness(Color color, float factor) {
        float[] hsb = Color.RGBtoHSB(color.getRed(), color.getGreen(), color.getBlue(), null);
        hsb[2] = Math.min(1.0f, hsb[2] * factor); // Adjust brightness
        return Color.getHSBColor(hsb[0], hsb[1], hsb[2]);
    }

    public static void setupWordHighlighting(RSyntaxTextArea textArea) {
        // Use a distinct color for word highlights
        Color wordHighlightColor = HIGHLIGHT_COLOR;
        Highlighter.HighlightPainter painter = new SmartHighlightPainter(wordHighlightColor);
    
        // Add a caret listener to dynamically highlight words at the caret
        textArea.addCaretListener(e -> {
            try {
                int caretPos = textArea.getCaretPosition();
                highlightWordAtCaret(textArea, caretPos, painter);
            } catch (Exception ex) {
                LOGGER.log(Level.WARNING, "Error during word highlighting", ex);
            }
        });
    }

    private static void highlightWordAtCaret(RSyntaxTextArea textArea, int caretPos, Highlighter.HighlightPainter painter) {
        try {
            // Remove only word highlights
            Highlighter highlighter = textArea.getHighlighter();
            for (Object highlight : wordHighlights) {
                highlighter.removeHighlight(highlight);
            }
            wordHighlights.clear(); // Clear the tracking list

            // Get the word at the caret or the selected text
            String selectedText = textArea.getSelectedText();
            if (selectedText == null || selectedText.trim().isEmpty()) {
                selectedText = getWordAtCaret(textArea.getText(), caretPos);
            }

            if (selectedText == null || selectedText.trim().isEmpty()) {
                return;
            }

            // Highlight all occurrences of the word
            String text = textArea.getText();
            String wordRegex = "\\b" + Pattern.quote(selectedText.trim()) + "\\b";
            Pattern pattern = Pattern.compile(wordRegex);
            Matcher matcher = pattern.matcher(text);

            while (matcher.find()) {
                Object highlight = highlighter.addHighlight(matcher.start(), matcher.end(), painter);
                wordHighlights.add(highlight); // Track this highlight
            }
        } catch (Exception ex) {
            LOGGER.log(Level.WARNING, "Error highlighting text", ex);
        }
    }

    private static String getWordAtCaret(String text, int caretPos) {
        if (caretPos < 0 || caretPos >= text.length()) return null;
    
        int start = caretPos;
        int end = caretPos;
    
        // Find the start of the word
        while (start > 0 && isWordChar(text.charAt(start - 1))) {
            start--;
        }
    
        // Find the end of the word
        while (end < text.length() && isWordChar(text.charAt(end))) {
            end++;
        }
    
        if (start < end) {
            return text.substring(start, end);
        }
        return null;
    }

    private static boolean isWordChar(char c) {
        return Character.isLetterOrDigit(c) || c == '_';
    }
}
```

`src/main/java/com/lauriewired/malimite/ui/WrapLayout.java`:

```java
package com.lauriewired.malimite.ui;

import java.awt.*;

public class WrapLayout extends FlowLayout {
    public WrapLayout(int align, int hgap, int vgap) {
        super(align, hgap, vgap);
    }

    @Override
    public Dimension preferredLayoutSize(Container target) {
        return layoutSize(target, true);
    }

    @Override
    public Dimension minimumLayoutSize(Container target) {
        return layoutSize(target, false);
    }

    private Dimension layoutSize(Container target, boolean preferred) {
        synchronized (target.getTreeLock()) {
            int width = target.getWidth();
            if (width == 0) width = Integer.MAX_VALUE;
            
            Insets insets = target.getInsets();
            int maxWidth = width - (insets.left + insets.right);
            int x = insets.left;
            int y = insets.top;
            int rowHeight = 0;

            int nmembers = target.getComponentCount();
            for (int i = 0; i < nmembers; i++) {
                Component m = target.getComponent(i);
                if (m.isVisible()) {
                    Dimension d = preferred ? m.getPreferredSize() : m.getMinimumSize();
                    if (x > insets.left && x + d.width > maxWidth) {
                        x = insets.left;
                        y += rowHeight + getVgap();
                        rowHeight = 0;
                    }
                    x += d.width + getHgap();
                    rowHeight = Math.max(rowHeight, d.height);
                }
            }
            return new Dimension(width, y + rowHeight + insets.bottom);
        }
    }
} 
```

`src/main/java/com/lauriewired/malimite/utils/FileProcessing.java`:

```java
package com.lauriewired.malimite.utils;

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import com.google.gson.reflect.TypeToken;
import java.lang.reflect.Type;
import java.util.logging.Level;
import java.util.logging.Logger;
import com.lauriewired.malimite.files.Macho;
import com.lauriewired.malimite.database.SQLiteDBHandler;

import com.lauriewired.malimite.configuration.Project;
import javax.swing.*;
import java.util.Map;
import com.lauriewired.malimite.configuration.Config;

public class FileProcessing {
    private static final Logger LOGGER = Logger.getLogger(FileProcessing.class.getName());
    private static Config config;

    public static void readStream(InputStream stream) {
        new Thread(() -> {
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(stream))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    LOGGER.info(line);
                }
            } catch (IOException e) {
                LOGGER.log(Level.SEVERE, "Error reading stream", e);
            }
        }).start();
    }

    public static void unzipExecutable(String zipFilePath, String executableName, String outputFilePath) throws IOException {
        LOGGER.info("Attempting to unzip executable from: " + zipFilePath);
        LOGGER.info("Looking for executable: " + executableName);
        LOGGER.info("Output path: " + outputFilePath);
        
        try (ZipInputStream zipIn = new ZipInputStream(new FileInputStream(zipFilePath))) {
            ZipEntry entry = zipIn.getNextEntry();
            while (entry != null) {
                LOGGER.info("Examining zip entry: " + entry.getName());
                if (!entry.isDirectory() && entry.getName().endsWith(executableName)) {
                    LOGGER.info("Found matching executable, extracting...");
                    extractFile(zipIn, outputFilePath);
                    LOGGER.info("Successfully extracted executable to: " + outputFilePath);
                    break;
                }
                zipIn.closeEntry();
                entry = zipIn.getNextEntry();
            }
        }
    }

    public static void extractFile(ZipInputStream zipIn, String filePath) throws IOException {
        try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(filePath))) {
            byte[] bytesIn = new byte[4096];
            int read;
            while ((read = zipIn.read(bytesIn)) != -1) {
                bos.write(bytesIn, 0, read);
            }
        }
    }

    public static byte[] readContentFromZip(String zipFilePath, String entryPath) throws IOException {
        try (ZipInputStream zipIn = new ZipInputStream(new FileInputStream(zipFilePath))) {
            ZipEntry entry = zipIn.getNextEntry();
    
            while (entry != null) {
                if (entry.getName().equals(entryPath)) {
                    ByteArrayOutputStream out = new ByteArrayOutputStream();
                    byte[] buffer = new byte[1024];
                    int len;
                    while ((len = zipIn.read(buffer)) > 0) {
                        out.write(buffer, 0, len);
                    }
                    return out.toByteArray();
                }
                zipIn.closeEntry();
                entry = zipIn.getNextEntry();
            }
        }
        return new byte[0]; // Return empty array if the entry is not found
    }

    /*
     * Extracts a macho binary from an IPA file to a new project directory
     * Returns the name of the new project directory
     */
    public static String extractMachoToProjectDirectory(String filePath, String executableName, String projectDirectoryPath) {
        LOGGER.info("filePath: " + filePath + " executableName: " + executableName + " projectDirectoryPath: " + projectDirectoryPath);
        if (filePath == null || filePath.isEmpty()) {
            LOGGER.warning("Invalid file path");
            return "";
        }

        // Extract the base name of the input file
        File inputFile = new File(filePath);
        String baseName = inputFile.getName();
        int lastDotIndex = baseName.lastIndexOf('.');
        if (lastDotIndex > 0) {
            baseName = baseName.substring(0, lastDotIndex);
        }

        // If executableName is empty or null, just use the input file name
        if (executableName == null || executableName.isEmpty()) {
            LOGGER.info("No executable name provided, using input file name: " + baseName);
        } else {
            LOGGER.info("Using executable name: " + executableName);
        }

        // Create project directory name based on input file name
        String projectDirPath = inputFile.getParent() + File.separator + baseName + "_malimite";
        LOGGER.info("Created project directory path: " + projectDirPath);
        
        return projectDirPath;
    }
    
    /*
     * Creates a new malimite project if it doesn't exist
     * Otherwise, reopens an existing project
     */
    public static void openProject(String filePath, String projectDirectoryPath, String executableName, String configDir, boolean avoidReopen) {
        // Create malimite project directory
        File projectDirectory = new File(projectDirectoryPath);
        if (!projectDirectory.exists() || avoidReopen) {
            if (projectDirectory.mkdir() || projectDirectory.exists()) {
                LOGGER.info("Created project directory: " + projectDirectoryPath);
                
                // Create and save initial project configuration
                Project project = new Project();
                project.setFileName(executableName);
                project.setFilePath(filePath);
                project.setSize(new File(filePath).length());
                
                // Save the project configuration to project.json
                saveProjectConfig(projectDirectoryPath, project);
                addProjectToList(filePath);

                File inputFile = new File(filePath);
                if (isArchiveFile(inputFile)) {
                    // Handle archive files (IPA, ZIP, etc.)
                    if (executableName != null && !executableName.isEmpty()) {
                        // Unzip the executable into the new project directory
                        String outputFilePath = projectDirectoryPath + File.separator + executableName;
                        try {
                            unzipExecutable(filePath, executableName, outputFilePath);
                        } catch (IOException e) {
                            LOGGER.log(Level.SEVERE, "Error unzipping executable", e);
                        }
                    } else {
                        LOGGER.warning("No executable name provided for archive file");
                    }
                } else if (inputFile.isDirectory() || inputFile.getName().endsWith(".app")) {
                    // Handle directories and .app bundles
                    // Find the executable in the directory
                    File[] files = inputFile.listFiles();
                    if (files != null) {
                        for (File file : files) {
                            if (file.getName().equals(executableName)) {
                                // Copy the executable to the project directory
                                String outputFilePath = projectDirectoryPath + File.separator + executableName;
                                try {
                                    Files.copy(file.toPath(), new File(outputFilePath).toPath());
                                    LOGGER.info("Copied executable to: " + outputFilePath);
                                } catch (IOException e) {
                                    LOGGER.log(Level.SEVERE, "Error copying executable", e);
                                }
                                break;
                            }
                        }
                    }
                }
            } else {
                LOGGER.warning("Failed to create project directory: " + projectDirectoryPath);
                return;
            }
        } else {
            // Load existing project configuration
            Project project = loadProjectConfig(projectDirectoryPath);
            if (project != null) {
                LOGGER.info("Loaded existing project: " + project.getFileName());
            }
        }
    }

    private static Project loadProjectConfig(String projectDirectoryPath) {
        try {
            String configPath = projectDirectoryPath + File.separator + "project.json";
            String json = Files.readString(Paths.get(configPath));
            Gson gson = new Gson();
            return gson.fromJson(json, Project.class);
        } catch (IOException e) {
            System.err.println("Failed to load project configuration: " + e.getMessage());
            return null;
        }
    }

    public static boolean isArchiveFile(File file) {
        String name = file.getName().toLowerCase();
        return name.endsWith(".ipa") || 
               name.endsWith(".zip") || 
               name.endsWith(".tar") || 
               name.endsWith(".gz") ||
               name.endsWith(".7z");
    }

    private static void addProjectToList(String projectPath) {
        config.addProjectPath(projectPath);
    }

    // Add this method to set the config
    public static void setConfig(Config configuration) {
        config = configuration;
    }

    public static Project updateFileInfo(File file, Macho projectMacho) {
        Project project = new Project();
        project.setFilePath(file.getAbsolutePath());
        project.setFileName(file.getName());
        
        // Get file size based on whether it's an archive or not
        if (isArchiveFile(file)) {
            project.setSize(file.length());
        } else {
            // For non-archives, use the Macho file size
            if (projectMacho != null) {
                project.setSize(projectMacho.getSize());
            } else {
                project.setSize(file.length());
            }
        }
        
        try {
            project.setIsMachO(true);
            project.setMachoInfo(projectMacho);
            project.setIsSwift(projectMacho.isSwift());
            
            if (projectMacho.isUniversalBinary()) {
                project.setFileType("Universal Mach-O Binary");
            } else {
                project.setFileType("Single Architecture Mach-O");
            }
        } catch (Exception ex) {
            project.setFileType("Unknown or unsupported file format");
            project.setIsMachO(false);
            LOGGER.warning("Error reading file format: " + ex.getMessage());
        }

        return project;
    }

    public static void updateFunctionList(JPanel functionAssistPanel, SQLiteDBHandler dbHandler, String className) {
        if (functionAssistPanel != null) {
            JList<?> functionList = (JList<?>) ((JScrollPane) ((JPanel) functionAssistPanel
                .getComponent(1)).getComponent(1)).getViewport().getView();
            DefaultListModel<String> model = (DefaultListModel<String>) functionList.getModel();
            model.clear();
            
            // Get functions for the selected class
            Map<String, List<String>> classesAndFunctions = dbHandler.getAllClassesAndFunctions();
            List<String> functions = classesAndFunctions.get(className);
            
            if (functions != null) {
                for (String function : functions) {
                    model.addElement(function);
                }
            }
            
            // Reset "Select All" checkbox
            JCheckBox selectAllBox = (JCheckBox) ((JPanel) functionAssistPanel
                .getComponent(1)).getComponent(0);
            selectAllBox.setSelected(false);
        }
    }

    private static void saveProjectConfig(String projectDirectoryPath, Project project) {
        try {
            File configFile = new File(projectDirectoryPath + File.separator + "project.json");
            // Create parent directories if they don't exist
            configFile.getParentFile().mkdirs();
            
            Gson gson = new GsonBuilder().setPrettyPrinting().create();
            String json = gson.toJson(project);
            Files.writeString(configFile.toPath(), json);
            LOGGER.info("Successfully saved project config to: " + configFile.getAbsolutePath());
        } catch (IOException e) {
            LOGGER.log(Level.SEVERE, "Failed to save project configuration", e);
        }
    }
}

```

`src/main/java/com/lauriewired/malimite/utils/GhidraSetup.java`:

```java
package com.lauriewired.malimite.utils;

import javax.swing.*;
import java.io.*;
import java.net.URL;
import java.nio.file.*;

public class GhidraSetup {
    private static final String JSON_VERSION = "20210307";
    private static final String JSON_JAR = "json-" + JSON_VERSION + ".jar";
    private static final String DOWNLOAD_URL = "https://repo1.maven.org/maven2/org/json/json/" + JSON_VERSION + "/" + JSON_JAR;

    private static boolean runAsAdmin(String[] command) {
        try {
            ProcessBuilder pb = new ProcessBuilder(command);
            pb.inheritIO();
            Process process = pb.start();
            return process.waitFor() == 0;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    public static void setupGhidraLibs(String ghidraPath) {
        Path patchDir = Paths.get(ghidraPath, "Ghidra", "patch");
        Path jsonJarPath = patchDir.resolve(JSON_JAR);

        // First try normal file operations
        try {
            Files.createDirectories(patchDir);
            URL url = new URL(DOWNLOAD_URL);
            try (InputStream in = url.openStream()) {
                Files.copy(in, jsonJarPath, StandardCopyOption.REPLACE_EXISTING);
            }
            JOptionPane.showMessageDialog(null,
                "Required library has been successfully installed.",
                "Setup Complete",
                JOptionPane.INFORMATION_MESSAGE);
            return;
        } catch (IOException e) {
            // If normal operation fails, try with admin privileges
            int response = JOptionPane.showConfirmDialog(null,
                "Failed to install library with normal permissions. Try with admin privileges?",
                "Permission Error",
                JOptionPane.YES_NO_OPTION,
                JOptionPane.QUESTION_MESSAGE);

            if (response == JOptionPane.YES_OPTION) {
                // Download to temp file first
                Path tempFile = null;
                try {
                    tempFile = Files.createTempFile("ghidra_json_", ".jar");
                    URL url = new URL(DOWNLOAD_URL);
                    try (InputStream in = url.openStream()) {
                        Files.copy(in, tempFile, StandardCopyOption.REPLACE_EXISTING);
                    }

                    // Use sudo commands to create directory and copy file
                    String[] mkdirCommand = {"sudo", "mkdir", "-p", patchDir.toString()};
                    String[] copyCommand = {"sudo", "cp", tempFile.toString(), jsonJarPath.toString()};
                    
                    if (runAsAdmin(mkdirCommand) && runAsAdmin(copyCommand)) {
                        JOptionPane.showMessageDialog(null,
                            "Required library has been successfully installed with admin privileges.",
                            "Setup Complete",
                            JOptionPane.INFORMATION_MESSAGE);
                        return;
                    }
                } catch (IOException ex) {
                    ex.printStackTrace();
                } finally {
                    if (tempFile != null) {
                        try {
                            Files.deleteIfExists(tempFile);
                        } catch (IOException ignored) {}
                    }
                }
            }
            
            // If everything fails, show error message
            JOptionPane.showMessageDialog(null,
                "Failed to install library: " + e.getMessage(),
                "Setup Error",
                JOptionPane.ERROR_MESSAGE);
        }
    }
} 
```

`src/main/java/com/lauriewired/malimite/utils/NodeOperations.java`:

```java
package com.lauriewired.malimite.utils;

import java.util.Enumeration;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;

import javax.swing.JTree;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreeNode;

public class NodeOperations {
    private static final Logger LOGGER = Logger.getLogger(NodeOperations.class.getName());

    public static String buildFullPathFromNode(TreeNode node) {
        StringBuilder fullPath = new StringBuilder();
        String nodeString = "";
        
        while (node != null) {
            nodeString = node.toString();

            // Avoid adding the prepended "Files" node
            if (node.getParent() != null && nodeString != "Hidden") {
                //System.out.println("fullPath: " + fullPath.toString());
                //System.out.println("node: " + nodeString);

                // Insert slash into path only if needed
                if (fullPath.length() > 0 && fullPath.charAt(0) != '/' && nodeString.charAt(nodeString.length() - 1) != '/') {
                    fullPath.insert(0, "/");
                }
                fullPath.insert(0, nodeString);
            }

            node = node.getParent();
        }
        return fullPath.toString();
    }

    public static void collapseAllTreeNodes(JTree fileTree) {
        for (int i = 0; i < fileTree.getRowCount(); i++) {
            fileTree.collapseRow(i);
        }
    }

    public static DefaultMutableTreeNode addOrGetNode(DefaultMutableTreeNode parentNode, String nodeName, boolean isDirectory) {
        Enumeration<TreeNode> children = parentNode.children();
        while (children.hasMoreElements()) {
            DefaultMutableTreeNode childNode = (DefaultMutableTreeNode) children.nextElement();
            if (childNode.getUserObject().equals(nodeName) && childNode.getAllowsChildren() == isDirectory) {
                return childNode;
            }
        }
    
        DefaultMutableTreeNode newNode = new DefaultMutableTreeNode(nodeName, isDirectory);
        parentNode.add(newNode);
        return newNode;
    }

    public static void expandAllTreeNodes(JTree fileTree) {
        for (int i = 0; i < fileTree.getRowCount(); i++) {
            fileTree.expandRow(i);
        }
    }

    public static DefaultMutableTreeNode findInfoPlistNode(DefaultMutableTreeNode root) {
        // Find the Files node first
        for (int i = 0; i < root.getChildCount(); i++) {
            DefaultMutableTreeNode filesNode = (DefaultMutableTreeNode) root.getChildAt(i);
            
            if (filesNode.getUserObject().toString().equals("Files")) {
                // Look for the .app directory directly under Files
                for (int j = 0; j < filesNode.getChildCount(); j++) {
                    DefaultMutableTreeNode appNode = (DefaultMutableTreeNode) filesNode.getChildAt(j);
                    if (appNode.getUserObject().toString().endsWith(".app/")) {
                        // Look for Info.plist directly under the .app directory
                        for (int k = 0; k < appNode.getChildCount(); k++) {
                            DefaultMutableTreeNode child = (DefaultMutableTreeNode) appNode.getChildAt(k);
                            if (child.getUserObject().toString().equals("Info.plist")) {
                                return child;
                            }
                        }
                    }
                }
            }
        }
        return null;
    }

    public static void populateClassesNode(DefaultMutableTreeNode classesRootNode, 
            Map<String, List<String>> classesAndFunctions) {
        LOGGER.info("Populating classes tree...");
        classesRootNode.removeAllChildren();
        LOGGER.info("Retrieved " + classesAndFunctions.size() + " classes from database");

        for (Map.Entry<String, List<String>> entry : classesAndFunctions.entrySet()) {
            String className = entry.getKey();
            List<String> functions = entry.getValue();
            LOGGER.fine("Adding class: " + className + " with " + functions.size() + " functions");
            DefaultMutableTreeNode classNode = new DefaultMutableTreeNode(className);
            for (String function : functions) {
                classNode.add(new DefaultMutableTreeNode(function));
            }
            classesRootNode.add(classNode);
        }
        LOGGER.info("Finished populating classes tree");
    }
}

```

`src/main/java/com/lauriewired/malimite/utils/PlistUtils.java`:

```java
package com.lauriewired.malimite.utils;

import java.util.Arrays;

import com.dd.plist.NSObject;
import com.dd.plist.PropertyListParser;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class PlistUtils {
    /*
     * Returns true if it's a binary plist
     * Returns false if it is an XML plist
     */
    public static boolean isBinaryPlist(byte[] contentBytes) {
        if (contentBytes.length < "bplist".length()) {
            return false;
        }
        String header = new String(Arrays.copyOf(contentBytes, "bplist".length()));

        return header.equals("bplist");
    }

    /*
     * Inputs the binary plist as a byte array
     * Returns the decoded plist in JSON format
     * Do it this way because using the plist library instead of built-in mac libs makes this cross-platform
     */
    public static String decodeBinaryPropertyList(byte[] plistData) {
        try {
            NSObject plist = PropertyListParser.parse(plistData);
            Object javaObj = plist.toJavaObject();
    
            // Use Gson to format it as a JSON string
            Gson gson = new GsonBuilder().setPrettyPrinting().create();
            return gson.toJson(javaObj);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}

```

`src/main/java/com/lauriewired/malimite/utils/ResourceParser.java`:

```java
package com.lauriewired.malimite.utils;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Pattern;
import java.util.logging.Logger;
import com.lauriewired.malimite.files.MobileProvision;
import com.lauriewired.malimite.database.SQLiteDBHandler;
public class ResourceParser {

    private static SQLiteDBHandler dbHandler;
    private static final Logger LOGGER = Logger.getLogger(ResourceParser.class.getName());

    public static void setDatabaseHandler(SQLiteDBHandler handler) {
        dbHandler = handler;
    }

    // Predefined patterns for identifying resource files
    private static final List<Pattern> RESOURCE_PATTERNS = Arrays.asList(
        Pattern.compile(".*\\.plist$"),                 // Property list files
        Pattern.compile(".*\\.strings$"),               // Localization string files
        Pattern.compile(".*\\.json$"),                  // JSON configuration files
        Pattern.compile(".*\\.xml$"),                   // XML files
        Pattern.compile(".*\\.mobileprovision$"),       // Provisioning profiles
        Pattern.compile(".*\\.storyboardc$"),           // Interface builder files
        Pattern.compile(".*\\.xcassets$"),              // Asset catalogs
        Pattern.compile(".*\\.nib$"),                   // Interface builder files
        Pattern.compile(".*\\.xib$")                    // Interface builder files (newly added)
    );

    /**
     * Checks if a file name matches any predefined resource pattern.
     */
    public static boolean isResource(String fileName) {
        LOGGER.fine("Checking if file is a resource: " + fileName);
        for (Pattern pattern : RESOURCE_PATTERNS) {
            if (pattern.matcher(fileName).matches()) {
                LOGGER.fine("File identified as resource: " + fileName);
                return true;
            }
        }
        return false;
    }

    /**
     * Parses a resource file for readable strings from an input stream.
     * This function handles text-based resources and excludes binary data.
     */
    public static void parseResourceForStrings(InputStream inputStream, String fileName) {
        try {
            // Convert input stream to byte array for multiple reads
            ByteArrayOutputStream buffer = new ByteArrayOutputStream();
            int nRead;
            byte[] data = new byte[4096];
            while ((nRead = inputStream.read(data, 0, data.length)) != -1) {
                buffer.write(data, 0, nRead);
            }
            byte[] contentBytes = buffer.toByteArray();

            LOGGER.info("Processing file: " + fileName);

            // Handle different file types
            String content;
            if (fileName.endsWith(".plist")) {
                content = handlePlist(contentBytes);
                LOGGER.fine("Processed as plist file");
            } else if (fileName.endsWith("embedded.mobileprovision")) {
                content = MobileProvision.extractEmbeddedXML(contentBytes);
                LOGGER.fine("Processed as mobileprovision file");
            } else {
                content = new String(contentBytes, StandardCharsets.UTF_8);
                LOGGER.fine("Processed as regular text file");
            }

            // Process the content line by line
            try (BufferedReader reader = new BufferedReader(new StringReader(content))) {
                String line;
                int lineCount = 0;
                while ((line = reader.readLine()) != null) {
                    lineCount++;
                    
                    if (!line.trim().isEmpty()) {
                        String[] segments = line.split("[^\\p{Print}]+");
                        for (String segment : segments) {
                            String trimmedSegment = segment.trim();
                            if (!trimmedSegment.isEmpty() && trimmedSegment.replaceAll("\\s+", "").length() > 4) {
                                if (dbHandler != null) {
                                    // Store the trimmed segment
                                    dbHandler.insertResourceString(fileName, trimmedSegment, getResourceType(fileName));
                                    LOGGER.fine("Inserted resource string: " + trimmedSegment + " for path: " + fileName);
                                }
                            }
                        }
                    }
                }
                LOGGER.info("Completed processing " + lineCount + " lines");
            }
        } catch (IOException e) {
            LOGGER.severe("Error reading file: " + e.getMessage());
        } catch (Exception e) {
            LOGGER.severe("Error processing file: " + e.getMessage());
        }
    }

    private static String handlePlist(byte[] contentBytes) throws Exception {
        if (PlistUtils.isBinaryPlist(contentBytes)) {
            return PlistUtils.decodeBinaryPropertyList(contentBytes);
        }
        return new String(contentBytes, StandardCharsets.UTF_8);
    }

    private static String getResourceType(String fileName) {
        if (fileName.endsWith(".plist")) return "plist";
        if (fileName.endsWith(".strings")) return "strings";
        if (fileName.endsWith(".json")) return "json";
        if (fileName.endsWith(".xml")) return "xml";
        if (fileName.endsWith(".mobileprovision")) return "mobileprovision";
        if (fileName.endsWith(".storyboardc")) return "storyboard";
        if (fileName.endsWith(".xcassets")) return "assets";
        if (fileName.endsWith(".nib")) return "nib";
        return "unknown";
    }
}

```