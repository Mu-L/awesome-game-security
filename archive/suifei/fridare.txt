Project Path: arc_suifei_fridare_50b4w55m

Source Tree:

```txt
arc_suifei_fridare_50b4w55m
â”œâ”€â”€ CHANGELOG
â”œâ”€â”€ LICENSE
â”œâ”€â”€ Makefile
â”œâ”€â”€ NOTICE.md
â”œâ”€â”€ README.md
â”œâ”€â”€ autoinstall.sh
â”œâ”€â”€ docs
â”‚   â”œâ”€â”€ android.md
â”‚   â”œâ”€â”€ install.md
â”‚   â”œâ”€â”€ ios.md
â”‚   â”œâ”€â”€ patch-tools.md
â”‚   â””â”€â”€ samples
â”‚       â”œâ”€â”€ root
â”‚       â”‚   â””â”€â”€ re.frida.server.plist
â”‚       â””â”€â”€ rootless
â”‚           â””â”€â”€ re.frida.server.plist
â”œâ”€â”€ fridare.sh
â”œâ”€â”€ hexreplace
â”‚   â”œâ”€â”€ Makefile
â”‚   â”œâ”€â”€ go.mod
â”‚   â”œâ”€â”€ go.sum
â”‚   â””â”€â”€ main.go
â”œâ”€â”€ logo
â”‚   â”œâ”€â”€ AppIcon.icns
â”‚   â”œâ”€â”€ AppIcon.ico
â”‚   â”œâ”€â”€ Uwp_150.png
â”‚   â””â”€â”€ Uwp_44.png
â”œâ”€â”€ screenshots
â”‚   â”œâ”€â”€ 1.png
â”‚   â”œâ”€â”€ 2.png
â”‚   â”œâ”€â”€ 3.png
â”‚   â”œâ”€â”€ 555354813.jpg
â”‚   â”œâ”€â”€ UI-01.png
â”‚   â”œâ”€â”€ UI-02.png
â”‚   â”œâ”€â”€ UI-03.png
â”‚   â”œâ”€â”€ UI-04.png
â”‚   â”œâ”€â”€ UI-05.png
â”‚   â”œâ”€â”€ UI-07.png
â”‚   â”œâ”€â”€ UI-08.png
â”‚   â””â”€â”€ md5.png
â”œâ”€â”€ test_binary.sh
â”œâ”€â”€ test_program.c
â”œâ”€â”€ test_program.exe
â”œâ”€â”€ toolkit
â”‚   â”œâ”€â”€ generate_frida_modules.py
â”‚   â”œâ”€â”€ manifest.txt
â”‚   â””â”€â”€ merge.py
â”œâ”€â”€ ui
â”‚   â”œâ”€â”€ build.sh
â”‚   â”œâ”€â”€ cmd
â”‚   â”‚   â”œâ”€â”€ create
â”‚   â”‚   â”‚   â””â”€â”€ main.go
â”‚   â”‚   â”œâ”€â”€ gui
â”‚   â”‚   â”‚   â””â”€â”€ main.go
â”‚   â”‚   â””â”€â”€ patch
â”‚   â”‚       â””â”€â”€ main.go
â”‚   â”œâ”€â”€ go.mod
â”‚   â”œâ”€â”€ go.sum
â”‚   â””â”€â”€ internal
â”‚       â”œâ”€â”€ assets
â”‚       â”‚   â”œâ”€â”€ appicon.go
â”‚       â”‚   â””â”€â”€ logo.go
â”‚       â”œâ”€â”€ config
â”‚       â”‚   â””â”€â”€ config.go
â”‚       â”œâ”€â”€ core
â”‚       â”‚   â”œâ”€â”€ arch_desc.go
â”‚       â”‚   â”œâ”€â”€ binary_analyzer.go
â”‚       â”‚   â”œâ”€â”€ debpackager.go
â”‚       â”‚   â”œâ”€â”€ frida.go
â”‚       â”‚   â”œâ”€â”€ hexreplace.go
â”‚       â”‚   â””â”€â”€ patcher.go
â”‚       â”œâ”€â”€ ui
â”‚       â”‚   â”œâ”€â”€ download_tab.go
â”‚       â”‚   â”œâ”€â”€ main_window.go
â”‚       â”‚   â”œâ”€â”€ notice_async.go
â”‚       â”‚   â””â”€â”€ tabs.go
â”‚       â””â”€â”€ utils
â”‚           â””â”€â”€ utils.go
â””â”€â”€ win
    â”œâ”€â”€ README.md
    â”œâ”€â”€ hexreplace_windows_amd64.exe
    â”œâ”€â”€ patch-frida-tools.cmd
    â””â”€â”€ patch-frida.cmd

```

`LICENSE`:

```
MIT License

Copyright (c) 2024 SuiFei

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Makefile`:

```
.PHONY: help clean build deploy

help:
	@echo "make help - Show this help"
	@echo "make clean - Clean the project"
	@echo "make deploy - Deploy the project"
	@echo "make build - Build the project"

clean:
	@rm -rf dist

build:
	@./fridare.sh build -latest -y

deploy:
	./autoinstall.sh
	@echo "Please run 'frida -H <iPhone IP>:8899 -F' to connect to the device"

all: clean build deploy
```

`NOTICE.md`:

```md
- The iOS device should ideally be running iOS 13 or newer. Support for older versions is considered experimental.
- **frida_17.2.15_iphoneos-arm.deb å¯æ­£å¸¸åœ¨ iOS 13ç¯å¢ƒæ­£å¸¸è¿è¡Œ(unc0ver)**ï¼Œè€Œæ›´é«˜ç‰ˆæœ¬æ— æ³•æ­£å¸¸æ‰§è¡Œï¼Œé”™è¯¯ä¸ºï¼š
```
iPhone:~ root# ldid -S/var/root/entitlements.xml /usr/sbin/frida-server
iPhone:~ root# /usr/sbin/frida-server
Segmentation fault: 11
```

```

`README.md`:

```md
# Fridare

[English](#Features) | [ä¸­æ–‡](#ç‰¹æ€§) | [GUIå›¾å½¢ç•Œé¢](#-guiç‰ˆæœ¬æˆªå›¾)

[![GitHub Streak](https://streak-stats.demolab.com?user=suifei&theme=dark&locale=zh_Hans&date_format=%5BY.%5Dn.j)](https://git.io/streak-stats)
<img src="screenshots/555354813.jpg" width="156" alt="QQç¾¤äºŒç»´ç "> 

![Github stars](https://img.shields.io/github/stars/suifei/fridare?style=social)
![Github forks](https://img.shields.io/github/forks/suifei/fridare?style=social)
![Github watchers](https://img.shields.io/github/watchers/suifei/fridare?style=social)
![Github license](https://img.shields.io/github/license/suifei/fridare)
![Github issues](https://img.shields.io/github/issues/suifei/fridare)
![Github pull requests](https://img.shields.io/github/issues-pr/suifei/fridare)
![Github contributors](https://img.shields.io/github/contributors/suifei/fridare)
![Github last commit](https://img.shields.io/github/last-commit/suifei/fridare)
![Github repo size](https://img.shields.io/github/repo-size/suifei/fridare)
![Github code size](https://img.shields.io/github/languages/code-size/suifei/fridare)
![Github language count](https://img.shields.io/github/languages/count/suifei/fridare)
![Github top language](https://img.shields.io/github/languages/top/suifei/fridare)
![Github tag](https://img.shields.io/github/v/tag/suifei/fridare)
[![GitHub followers](https://img.shields.io/github/followers/suifei.svg?style=social&label=Follow&maxAge=2592000)](https://github.com/suifei?tab=followers)
[![Twitter Follow](https://img.shields.io/twitter/follow/csuifei?style=social)](https://twitter.com/csuifei)

Fridare æ˜¯ä¸€ä¸ªç”¨äº iOS frida æ’ä»¶ã€Android,linux,Windows ç­‰å¹³å° frida-server çš„è‡ªåŠ¨åŒ–é­”æ”¹å·¥å…·ã€‚å®ƒå…è®¸ç”¨æˆ·æ›´æ”¹åç§°å’Œç«¯å£ï¼Œä»¥å¢å¼ºå®‰å…¨æ€§å’Œçµæ´»æ€§ã€‚å…é™¤äº†å¾ˆå¤šè¶Šç‹±æ£€æµ‹fridaçš„æƒ…å†µã€‚

ğŸ‰ **v4.0.0 é‡å¤§æ›´æ–°**ï¼šå…¨æ–°å‘å¸ƒåŸºäº Fyne æ¡†æ¶çš„è·¨å¹³å°GUIç‰ˆæœ¬ï¼Œæä¾›ç°ä»£åŒ–çš„å›¾å½¢ç”¨æˆ·ç•Œé¢ï¼Œè®© Frida æœåŠ¡å™¨ä¿®æ”¹å˜å¾—æ›´åŠ ç›´è§‚å’Œä¾¿æ·ï¼

âœ¨ **åŒæ¨¡å¼æ”¯æŒ**ï¼šæ—¢ä¿ç•™äº†å¼ºå¤§çš„å‘½ä»¤è¡Œç•Œé¢ï¼Œåˆæ–°å¢äº†ç”¨æˆ·å‹å¥½çš„å›¾å½¢ç•Œé¢ï¼Œæ»¡è¶³ä¸åŒç”¨æˆ·çš„ä½¿ç”¨ä¹ æƒ¯ã€‚

**[Windows ä¸‹ä½¿ç”¨](win/README.md)|[Android æ–‡æ¡£](docs/android.md)|[iOS æ–‡æ¡£](docs/ios.md)|[frida-tools æ–‡æ¡£](docs/patch-tools.md)|[å®‰è£…æŒ‡åŒ—](docs/install.md)|[CHANGELOG](CHANGELOG)**

æ¬¢è¿å¤§å®¶å…¥QQç¾¤è®¨è®ºï¼š[QQ 555354813](screenshots/555354813.jpg) ï¼Œå¦‚æœ¬é¡¹ç›®å¯¹ä½ æœ‰æ‰€å¸®åŠ©ï¼Œè®°å¾—ç»™ä½œè€…åŠ æ˜Ÿé¼“åŠ±å“¦ï¼

## ç‰¹æ€§

- **ğŸ‰ å…¨æ–°GUIç‰ˆæœ¬**ï¼šåŸºäº Fyne æ¡†æ¶çš„ç°ä»£åŒ–å›¾å½¢ç”¨æˆ·ç•Œé¢
- **ğŸ–¥ï¸ è·¨å¹³å°æ”¯æŒ**ï¼šWindowsã€macOSã€Linux åŸç”ŸGUIåº”ç”¨
- **ğŸ“± ç›´è§‚æ“ä½œ**ï¼šå¯è§†åŒ–çš„ Frida æœåŠ¡å™¨ä¿®æ”¹å’Œé…ç½®ç®¡ç†
- **ğŸ“Š å®æ—¶åé¦ˆ**ï¼šå›¾å½¢åŒ–æ—¥å¿—æ˜¾ç¤ºå’Œè¿›åº¦æ¡å±•ç¤º
- **ğŸ”§ Windows debåŒ…æ”¯æŒ**ï¼šåœ¨Windowså¹³å°ä¸‹ç›´æ¥ä¿®æ”¹å’Œåˆ›å»ºdebåŒ…ï¼Œæ— éœ€Linuxç¯å¢ƒ
- è‡ªåŠ¨ä¸‹è½½å¹¶ä¿®æ”¹æŒ‡å®šç‰ˆæœ¬çš„ frida-server 
- éšæœºç”Ÿæˆæ–°çš„ frida-server åç§°
- è‡ªå®šä¹‰ frida-server ç«¯å£
- æ”¯æŒ arm å’Œ arm64 æ¶æ„
- äºŒè¿›åˆ¶æ›¿æ¢ä¿®æ”¹
   - frida-server
   - frida-agent.dylib
   - frida-tools
- ç”Ÿæˆå¯ç›´æ¥å®‰è£…çš„ä¿®æ”¹ç‰ˆ .deb åŒ…
- ä¸€ä½“åŒ–å‘½ä»¤è¡Œç•Œé¢ï¼Œæä¾›å¤šç§åŠŸèƒ½
- é…ç½®æ–‡ä»¶æ”¯æŒï¼Œå¯ä¿å­˜ç”¨æˆ·è®¾ç½®
- è‡ªåŠ¨æ£€æŸ¥å’Œå®‰è£…ä¾èµ–
- ä¸‹è½½ç‰¹å®š Frida æ¨¡å—
- åˆ—å‡ºå¯ç”¨ Frida ç‰ˆæœ¬å’Œæ¨¡å—
- æ”¯æŒ Conda ç¯å¢ƒ
- æ”¯æŒ macho, elf, pe æ–‡ä»¶æ ¼å¼
- æ”¯æŒ Windows,Linux,MacOS,Android,IOS çš„patch
- æ”¯æŒè‡ªæ›´æ–°

æ¬¢è¿ä½¿ç”¨æ–°çš„ä¸€é”®å®‰è£…åŠŸèƒ½å¿«é€Ÿå¼€å§‹ä½¿ç”¨ Fridareï¼

```shell
 curl -s https://raw.githubusercontent.com/suifei/fridare/main/fridare.sh | bash -s install
```

## ğŸ‰ å…¨æ–°GUIç‰ˆæœ¬ v4.0.0 - 2025-01-02

### é‡å¤§æ›´æ–°ï¼šå›¾å½¢ç”¨æˆ·ç•Œé¢å‘å¸ƒ

Fridare ç°åœ¨æä¾›äº†åŸºäº Fyne æ¡†æ¶çš„ç°ä»£åŒ–å›¾å½¢ç”¨æˆ·ç•Œé¢ï¼Œè®© Frida æœåŠ¡å™¨çš„ä¿®æ”¹å˜å¾—æ›´åŠ ç›´è§‚å’Œä¾¿æ·ï¼

#### ğŸš€ GUIç‰ˆæœ¬äº®ç‚¹

- **ğŸ¨ ç°ä»£åŒ–ç•Œé¢**ï¼šé‡‡ç”¨ Fyne æ¡†æ¶æ„å»ºçš„è·¨å¹³å°åŸç”ŸGUIåº”ç”¨
- **ğŸ–±ï¸ æ‹–æ‹½æ“ä½œ**ï¼šæ”¯æŒæ–‡ä»¶æ‹–æ‹½ï¼Œç®€åŒ–æ–‡ä»¶é€‰æ‹©æµç¨‹
- **ğŸ“Š å®æ—¶ç›‘æ§**ï¼šå¯è§†åŒ–è¿›åº¦æ¡å’Œå®æ—¶æ—¥å¿—æ˜¾ç¤º
- **âš™ï¸ å¯è§†åŒ–é…ç½®**ï¼šå›¾å½¢åŒ–çš„é…ç½®ç®¡ç†ç•Œé¢
- **ğŸ”§ å¤šå·¥å…·é›†æˆ**ï¼šåŒ…å«åˆ›å»ºã€ä¿®è¡¥ã€GUIä¸‰ä¸ªç‹¬ç«‹å·¥å…·

#### ğŸ“¦ æ„å»ºGUIç‰ˆæœ¬

```bash
cd ui
./build.sh
```

æ„å»ºå®Œæˆåå°†ç”Ÿæˆä¸‰ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ï¼š
- `fridare-gui.exe` - ä¸»GUIåº”ç”¨ç¨‹åº
- `fridare-create.exe` - åˆ›å»ºå·¥å…· 
- `fridare-patch.exe` - è¡¥ä¸å·¥å…·

#### ğŸ–¥ï¸ è¿è¡ŒGUIåº”ç”¨

```bash
./build/fridare-gui.exe
```

GUIç‰ˆæœ¬ä¿æŒäº†ä¸å‘½ä»¤è¡Œç‰ˆæœ¬å®Œå…¨ç›¸åŒçš„åŠŸèƒ½ï¼ŒåŒæ—¶æä¾›äº†æ›´åŠ å‹å¥½çš„ç”¨æˆ·ä½“éªŒã€‚æ— è®ºæ‚¨æ˜¯æ–°æ‰‹è¿˜æ˜¯ä¸“å®¶ï¼Œéƒ½å¯ä»¥è½»æ¾ä½¿ç”¨å›¾å½¢ç•Œé¢æ¥ä¿®æ”¹å’Œé…ç½® Frida æœåŠ¡å™¨ã€‚

### ğŸ“¸ GUIç‰ˆæœ¬æˆªå›¾

![](screenshots/UI-01.png)
![](screenshots/UI-02.png)
![](screenshots/UI-03.png)
![](screenshots/UI-04.png)
![](screenshots/UI-05.png)
![](screenshots/UI-06.png)
![](screenshots/UI-07.png)
![](screenshots/UI-08.png)

### ğŸ”§ Windowså¹³å°debåŒ…å®Œå…¨æ”¯æŒ

v4.0.0ç‰ˆæœ¬çš„é‡å¤§çªç ´ä¹‹ä¸€æ˜¯åœ¨Windowså¹³å°ä¸‹å®ç°äº†å¯¹debåŒ…çš„å®Œå…¨æ”¯æŒï¼š

#### æ ¸å¿ƒä¼˜åŠ¿
- **æ— éœ€Linuxç¯å¢ƒ**ï¼šç›´æ¥åœ¨Windowsä¸‹å¤„ç†debåŒ…ï¼Œå‘Šåˆ«WSLå’Œè™šæ‹Ÿæœº
- **åŸç”Ÿdebå¤„ç†**ï¼šå®Œæ•´çš„è§£å‹ã€ä¿®æ”¹ã€é‡æ–°æ‰“åŒ…å·¥å…·é“¾
- **GUIå¯è§†åŒ–æ“ä½œ**ï¼šå›¾å½¢ç•Œé¢ä¸‹çš„æ‹–æ‹½å¼debåŒ…å¤„ç†
- **ä¸€é”®å¼å·¥ä½œæµ**ï¼šä»ä¸‹è½½åˆ°ä¿®æ”¹åˆ°æ‰“åŒ…çš„å®Œæ•´è‡ªåŠ¨åŒ–æµç¨‹

#### æŠ€æœ¯å®ç°
- å®ç°äº†Windowså¹³å°ä¸‹çš„åŸç”ŸdebåŒ…è§£æç®—æ³•
- é›†æˆäº†è·¨å¹³å°çš„tar.gzå’Œarå½’æ¡£å¤„ç†èƒ½åŠ›
- æ”¯æŒDebianæ§åˆ¶æ–‡ä»¶çš„è¯»å–å’Œä¿®æ”¹
- ä¿æŒLinuxå…¼å®¹çš„æ–‡ä»¶æƒé™å’Œç»“æ„

#### ä½¿ç”¨åœºæ™¯
```bash
# ç›´æ¥åœ¨Windowsä¸‹ä¿®æ”¹iOS debåŒ…
./fridare-gui.exe  # æ‹–æ‹½debæ–‡ä»¶è¿›è¡Œå¯è§†åŒ–ä¿®æ”¹

# æˆ–ä½¿ç”¨å‘½ä»¤è¡Œ
./fridare-patch.exe -i frida-server.deb -o modified.deb
```

è¿™é¡¹åŠŸèƒ½è®©Windowsç”¨æˆ·æ— éœ€é¢å¤–ç¯å¢ƒå³å¯å®Œæˆå®Œæ•´çš„FridaæœåŠ¡å™¨å®šåˆ¶å·¥ä½œæµç¨‹ï¼

## [v3.1.5] - 2024-07-29 Windows æ”¯æŒ

### Added
- æ–°å¢ `patch-frida.cmd` è„šæœ¬,ç”¨äºåœ¨ Windows ç¯å¢ƒä¸‹ä¿®æ”¹ frida-server
- æ–°å¢ `patch-frida-tools.cmd` è„šæœ¬,ç”¨äºåœ¨ Windows ç¯å¢ƒä¸‹ä¿®æ”¹ frida-tools
- å¢åŠ å¯¹ Windows å¹³å°çš„å…¨é¢æ”¯æŒ
- æ›´æ–°äº†ä½¿ç”¨è¯´æ˜,å¢åŠ äº† Windows å¹³å°çš„è¯¦ç»†æ•™ç¨‹

## [v3.1.4] - 2024-07-18

### Added
- å¢åŠ  `patch-tools` å‘½ä»¤ï¼Œç”¨äºä¿®è¡¥ frida-tools æ¨¡å—
- æ–°å¢ `render_markdown` å‡½æ•°ï¼Œç”¨äºåœ¨ç»ˆç«¯ä¸­æ¸²æŸ“ç®€å•çš„ Markdown æ ¼å¼
- æ·»åŠ  `generate_random_name` å‡½æ•°ï¼Œç”¨äºç”Ÿæˆéšæœºçš„ Frida é­”æ”¹å
- å®ç° `move_file` å‡½æ•°ï¼Œç”¨äºå¤„ç†æ–‡ä»¶ç§»åŠ¨æ—¶çš„ "are identical" é”™è¯¯

### Improved 
- ä¼˜åŒ– `list_frida_versions` å‡½æ•°ï¼Œç°åœ¨èƒ½å¤Ÿæ¸²æŸ“ Markdown æ ¼å¼çš„ç‰ˆæœ¬è¯´æ˜
- æ”¹è¿› `build_frida` å‡½æ•°ï¼Œæ”¯æŒä½¿ç”¨æœ¬åœ° deb æ–‡ä»¶è¿›è¡Œæ„å»º
- å¢å¼º `patch_frida_tools` å’Œ `restore_frida_tools` å‡½æ•°çš„åŠŸèƒ½å’Œé”™è¯¯å¤„ç†
- ä¼˜åŒ– `modify_frida_tools` å‡½æ•°ï¼Œæé«˜ä¿®æ”¹ frida-tools çš„å¯é æ€§
- æ”¹è¿› `download_frida_module` å‡½æ•°ï¼Œå¢åŠ å¯¹ç‰¹å®šæ“ä½œç³»ç»Ÿå’Œæ¶æ„çš„æ”¯æŒ

### Fixed
- ä¿®å¤äº†åœ¨æŸäº›æƒ…å†µä¸‹æ— æ³•æ­£ç¡®è·å– Frida è·¯å¾„çš„é—®é¢˜
- è§£å†³äº†ç§»åŠ¨æ–‡ä»¶æ—¶å¯èƒ½é‡åˆ°çš„ "are identical" é”™è¯¯

### Changed
- æ›´æ–° `show_main_usage` å’Œå…¶ä»–ä½¿ç”¨è¯´æ˜å‡½æ•°ï¼Œä»¥åæ˜ æ–°å¢çš„åŠŸèƒ½
- è°ƒæ•´ `parse_arguments` å‡½æ•°ï¼Œæ”¯æŒæ–°å¢çš„ `patch-tools` å‘½ä»¤
- ä¿®æ”¹é…ç½®æ–‡ä»¶çš„å¤„ç†æ–¹å¼ï¼Œå¢åŠ äº†å¯¹ `FRIDA_NAME` çš„æ”¯æŒ

### Other Changes
- ä»£ç ç»“æ„ä¼˜åŒ–ï¼Œæé«˜äº†æ•´ä½“å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§
- å¢åŠ äº†æ›´å¤šçš„æ—¥å¿—è¾“å‡ºï¼Œæä¾›æ›´è¯¦ç»†çš„æ‰§è¡Œä¿¡æ¯
- æ›´æ–°äº†ç‰ˆæœ¬å·è‡³ 3.1.4

## v3.1.2 - 2024-07-17

### Added
- å¢åŠ å¯¹å¤šå¹³å°çš„æ”¯æŒï¼šç°åœ¨æ”¯æŒ `macOS`ã€`iOS`ã€`Android`ã€`Linux` å’Œ `Windows`
- æ–°å¢ `upgrade` å‘½ä»¤ï¼šç”¨äºè‡ªåŠ¨æ›´æ–° Fridare è„šæœ¬
- æ–°å¢ä¸€é”®å®‰è£…åŠŸèƒ½

### Changed
- ä¼˜åŒ–ç‰ˆæœ¬æ£€æŸ¥å’Œæ›´æ–°æµç¨‹

### Fixed
- ä¿®å¤äº†åœ¨ Windows ç³»ç»Ÿä¸Šæ— æ³•æ­£ç¡®è¯†åˆ«å’Œå®‰è£… Frida å·¥å…·çš„é—®é¢˜
- ä¿®å¤äº†åœ¨ macOS ç³»ç»Ÿä¸Šæ— æ³•æ­£ç¡®ä¸‹è½½ Frida å·¥å…·çš„é—®é¢˜

### Other Changes
- æ›´æ–°ç‰ˆæœ¬å·è‡³ 3.1.2
- ä»£ç é‡æ„å’Œä¼˜åŒ–ï¼Œæé«˜æ•´ä½“æ€§èƒ½å’Œç¨³å®šæ€§

### v3.1.1
- å¢åŠ äº† `upgrade` å‘½ä»¤ï¼Œç”¨äºè‡ªåŠ¨æ›´æ–° Fridare è„šæœ¬

### v3.1.0
- å¢åŠ äº† `patch` å‘½ä»¤ï¼Œç”¨äºä¿®è¡¥æŒ‡å®šçš„ Frida æ¨¡å—
   - ä¾‹å¦‚ï¼š`å®‰å“ frida-server` `./fridare.sh p -m frida-server -latest -os android -arch arm64 -o ./patched`
- å¢åŠ äº†å¯¹ `patch` å‘½ä»¤çš„å¸®åŠ©ä¿¡æ¯
- å¢åŠ å¯¹ ELF å’Œ PE æ–‡ä»¶æ ¼å¼çš„æ”¯æŒ(æ”¯æŒ Windows,Linux,MacOS,Android,IOS)
- æ›´æ–°äº† `build`ã€`download` ç­‰å‘½ä»¤çš„ç”¨æ³•è¯´æ˜
- ä¿®å¤äº†ä¸€äº›å°çš„ Bug å¹¶æ”¹è¿›äº†è„šæœ¬çš„ç¨³å®šæ€§

![v3.1.0](screenshots/3.png)

### v3.0.1 Fixed
- ä¿®å¤åœ¨ Conda ç¯å¢ƒä¸­æ— æ³•æ­£ç¡®è¯†åˆ«å’Œä¿®æ”¹ Frida å·¥å…·çš„é—®é¢˜
- è§£å†³å¤šä¸ª Python ç¯å¢ƒå…±å­˜æ—¶çš„å…¼å®¹æ€§é—®é¢˜

### æ–°å¢ç‰¹æ€§ v3.0.0
- æ–°å¢ `fridare.sh` è„šæœ¬ï¼Œæ•´åˆæ‰€æœ‰åŠŸèƒ½ï¼Œæä¾›æ›´å®Œæ•´çš„å‘½ä»¤è¡Œç•Œé¢
- æ–°å¢ `build`, `ls`, `download`, `lm`, `setup`, `config`, å’Œ `help` å‘½ä»¤
- æ–°å¢é…ç½®æ–‡ä»¶æ”¯æŒï¼Œå¯ä»¥ä¿å­˜å’ŒåŠ è½½ç”¨æˆ·è®¾ç½®
- æ–°å¢é¢œè‰²è¾“å‡ºï¼Œæå‡ç”¨æˆ·ä½“éªŒ
- æ–°å¢è‡ªåŠ¨æ£€æŸ¥å’Œå®‰è£…ä¾èµ–åŠŸèƒ½
- æ–°å¢ä¸‹è½½ç‰¹å®š Frida æ¨¡å—çš„åŠŸèƒ½
- æ–°å¢åˆ—å‡ºå¯ç”¨ Frida ç‰ˆæœ¬å’Œæ¨¡å—çš„åŠŸèƒ½

### v2.2.0 (ä»…æµ‹è¯• macOS arm æ¶æ„ï¼Œå…¶å®ƒæ¶æ„æœªæµ‹è¯•)
- æ–°å¢åŠ  frida-tools è¡¥ä¸ï¼Œé€‚é… `frida:rpc` ç‰¹å¾é­”æ”¹
   - è§£å†³ Android å†…å­˜æ‰«æè¯¥å­—ç¬¦ä¸²é—®é¢˜
   - è‡ªåŠ¨æ‰«ææœ¬åœ° pip å®‰è£… frida-tools çš„ä½ç½®ï¼Œå¯¹ `core.py` æ–‡ä»¶è¿›è¡Œé­”æ”¹ï¼Œå¯¹ `_frida.abi3.so` æ–‡ä»¶è¿›è¡Œé­”æ”¹
- æ–°å¢åŠ  frida-agent.dylib é­”æ”¹ï¼Œä»æ–‡ä»¶åç§°ï¼ŒåŠ è½½ä½ç½®è¿›è¡Œéšè—
   - è§£å†³ agent åŠ è½½æœªéšè—é—®é¢˜

### v2.1.1

- å¼•å…¥ `autoinstall.sh` è„šæœ¬ï¼Œå®ç° Frida æ’ä»¶çš„è‡ªåŠ¨éƒ¨ç½²ã€‚
- å¼•å…¥ `Makefile`ï¼Œç®€åŒ–é¡¹ç›®çš„æ„å»ºå’Œéƒ¨ç½²æµç¨‹ã€‚
- è¿è¡Œä¹‹å‰è¯·ç¡®ä¿æœ¬æœºå·²ç»å®‰è£…äº† [issh](https://github.com/4ch12dy/issh) å‘½ä»¤ã€‚å¹¶é…ç½®å¥½äº† ssh çš„å…å¯†ç™»å½•ã€‚
   > é…ç½® issh çš„ ssh å…å¯†ç™»é™†
   ```shell
   # ç”Ÿæˆ keygen å¯†é’¥ï¼Œå¦‚æœå·²ç”Ÿæˆå¯ä»¥è·³è¿‡
   ssh-keygen -t rsa -b 4096 -C "<EMAIL>"
   # é…ç½®æ‰‹æœºIPï¼Œå¦‚æœUSBè¿æ¥å¯ä»¥ä¸é…ç½®
   issh ip set <iPhone-IP>     
   # æ‹·è´å…¬é’¥åˆ°æ‰‹æœº /var/root ï¼Œéœ€è¦ root å¯†ç  alpine
   issh scp ~/.ssh/id_rsa.pub  
   # è¿œç¨‹æœåŠ¡å™¨æ·»åŠ å…¬é’¥åˆ° authorized_keys æ–‡ä»¶
   issh run "mkdir -p ~/.ssh && cat /var/root/id_rsa.pub >> ~/.ssh/authorized_keys && chmod 600 ~/.ssh/authorized_keys && chmod 700 ~/.ssh"
   ```

## Frida é­”æ”¹è„šæœ¬çš„ç»“æ„å’ŒåŠŸèƒ½
```shell
fridare.sh - Frida é­”æ”¹è„šæœ¬
â”‚
â”œâ”€â”€ ä¸»è¦åŠŸèƒ½
â”‚   â”œâ”€â”€ æ„å»ºé­”æ”¹ç‰ˆ Frida (build)
â”‚   â”‚   â”œâ”€â”€ æ”¯æŒæŒ‡å®šç‰ˆæœ¬æˆ–æœ€æ–°ç‰ˆæœ¬
â”‚   â”‚   â”œâ”€â”€ è‡ªåŠ¨ç”Ÿæˆéšæœº5å­—ç¬¦åç§°
â”‚   â”‚   â”œâ”€â”€ è‡ªå®šä¹‰ç«¯å£è®¾ç½®
â”‚   â”‚   â””â”€â”€ æ”¯æŒ arm å’Œ arm64 æ¶æ„
â”‚   â”œâ”€â”€ åˆ—å‡ºå¯ç”¨ Frida ç‰ˆæœ¬ (ls, list)
â”‚   â”‚   â””â”€â”€ ä» GitHub API è·å–ç‰ˆæœ¬ä¿¡æ¯
â”‚   â”œâ”€â”€ ä¸‹è½½ç‰¹å®šç‰ˆæœ¬ Frida (download)
â”‚   â”‚   â”œâ”€â”€ æ”¯æŒä¸‹è½½å•ä¸ªæˆ–æ‰€æœ‰æ¨¡å—
â”‚   â”‚   â””â”€â”€ å¯é€‰çš„è‡ªåŠ¨è§£å‹åŠŸèƒ½
â”‚   â”œâ”€â”€ åˆ—å‡ºå¯ç”¨ Frida æ¨¡å— (lm, list-modules)
â”‚   â”œâ”€â”€ æ£€æŸ¥å¹¶å®‰è£…ç³»ç»Ÿä¾èµ– (setup)
â”‚   â”‚   â”œâ”€â”€ è‡ªåŠ¨æ£€æµ‹ç¼ºå¤±ä¾èµ–
â”‚   â”‚   â””â”€â”€ ä½¿ç”¨åŒ…ç®¡ç†å™¨å®‰è£…ä¾èµ–
â”‚   â””â”€â”€ é…ç½®é€‰é¡¹è®¾ç½® (config)
â”‚       â”œâ”€â”€ è®¾ç½® HTTP ä»£ç†
â”‚       â”œâ”€â”€ è®¾ç½® Frida æœåŠ¡å™¨ç«¯å£
â”‚       â””â”€â”€ è®¾ç½® Frida é­”æ”¹åç§°
â”‚
â”œâ”€â”€ è„šæœ¬ç»“æ„
â”‚   â”œâ”€â”€ åˆå§‹åŒ–é…ç½® (initialize_config)
â”‚   â”‚   â””â”€â”€ è¯»å–å’Œåˆ›å»ºé…ç½®æ–‡ä»¶
â”‚   â”œâ”€â”€ å‚æ•°è§£æ (parse_arguments)
â”‚   â”‚   â””â”€â”€ æ”¯æŒå¤šç§å‘½ä»¤è¡Œé€‰é¡¹
â”‚   â”œâ”€â”€ å‘½ä»¤å¤„ç†
â”‚   â”‚   â”œâ”€â”€ build: æ„å»ºé­”æ”¹ç‰ˆ Frida
â”‚   â”‚   â”œâ”€â”€ patch: ä¿®è¡¥æŒ‡å®šçš„ Frida æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ setup: è®¾ç½®ç¯å¢ƒ
â”‚   â”‚   â”œâ”€â”€ config: ç®¡ç†é…ç½®
â”‚   â”‚   â”œâ”€â”€ list: åˆ—å‡ºç‰ˆæœ¬
â”‚   â”‚   â”œâ”€â”€ download: ä¸‹è½½æ¨¡å—
â”‚   â”‚   â””â”€â”€ list-modules: åˆ—å‡ºæ¨¡å—
â”‚   â””â”€â”€ ä¸»å‡½æ•° (main)
â”‚       â””â”€â”€ æ•´åˆæ‰€æœ‰åŠŸèƒ½çš„å…¥å£ç‚¹
â”‚
â”œâ”€â”€ æ„å»ºè¿‡ç¨‹ (build_frida)
â”‚   â”œâ”€â”€ ç‰ˆæœ¬æ£€æŸ¥
â”‚   â”‚   â””â”€â”€ æ”¯æŒæœ€æ–°ç‰ˆæœ¬è‡ªåŠ¨æ£€æµ‹
â”‚   â”œâ”€â”€ ç¯å¢ƒå‡†å¤‡
â”‚   â”‚   â”œâ”€â”€ æ£€æŸ¥ Python ç¯å¢ƒ (åŒ…æ‹¬ Conda)
â”‚   â”‚   â””â”€â”€ æ£€æŸ¥ Golang ç¯å¢ƒ
â”‚   â”œâ”€â”€ ä¸‹è½½ Frida (download_frida)
â”‚   â”œâ”€â”€ è§£åŒ… deb æ–‡ä»¶
â”‚   â”œâ”€â”€ ä¿®æ”¹æ–‡ä»¶
â”‚   â”‚   â”œâ”€â”€ ä¿®æ”¹å¯åŠ¨å®ˆæŠ¤ç¨‹åº (modify_launch_daemon)
â”‚   â”‚   â”‚   â””â”€â”€ æ›´æ–° plist æ–‡ä»¶
â”‚   â”‚   â”œâ”€â”€ ä¿®æ”¹ Debian æ–‡ä»¶ (modify_debian_files)
â”‚   â”‚   â”‚   â”œâ”€â”€ æ›´æ–° control æ–‡ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ æ›´æ–° extrainst_ æ–‡ä»¶
â”‚   â”‚   â”‚   â””â”€â”€ æ›´æ–° prerm æ–‡ä»¶
â”‚   â”‚   â””â”€â”€ ä¿®æ”¹äºŒè¿›åˆ¶æ–‡ä»¶ (modify_binary)
â”‚   â”‚       â”œâ”€â”€ ä¿®æ”¹ frida-server
â”‚   â”‚       â”œâ”€â”€ ä¿®æ”¹ frida-agent.dylib
â”‚   â”‚       â””â”€â”€ ä½¿ç”¨ hexreplace å·¥å…·
â”‚   â”œâ”€â”€ é‡æ–°æ‰“åŒ… deb æ–‡ä»¶ (repackage_deb)
â”‚   â””â”€â”€ ä¿®æ”¹ frida-tools (modify_frida_tools)
â”‚       â”œâ”€â”€ ä¿®æ”¹ Python åº“æ–‡ä»¶
â”‚       â””â”€â”€ æ›´æ–° core.py ä¸­çš„å­—ç¬¦ä¸²
â”‚
â”œâ”€â”€ è¾…åŠ©åŠŸèƒ½
â”‚   â”œâ”€â”€ æ—¥å¿—è¾“å‡º (log_info, log_success, log_warning, log_error)
â”‚   â”‚   â””â”€â”€ æ”¯æŒå½©è‰²è¾“å‡º
â”‚   â”œâ”€â”€ ç”¨æˆ·ç¡®è®¤ (confirm_execution)
â”‚   â”‚   â””â”€â”€ å¯é€‰çš„è‡ªåŠ¨ç¡®è®¤æ¨¡å¼
â”‚   â”œâ”€â”€ ä¾èµ–æ£€æŸ¥ (check_dependencies)
â”‚   â”œâ”€â”€ ä¾èµ–å®‰è£… (install_dependencies)
â”‚   â”œâ”€â”€ é…ç½®ç®¡ç† (set_config, unset_config, list_config)
â”‚   â””â”€â”€ Frida ç‰ˆæœ¬å’Œæ¨¡å—åˆ—è¡¨ (list_frida_versions, list_frida_modules)
â”‚
â”œâ”€â”€ ä¸‹è½½åŠŸèƒ½ (download_frida_module)
â”‚   â”œâ”€â”€ ç‰ˆæœ¬é€‰æ‹© (æœ€æ–°ç‰ˆæˆ–æŒ‡å®šç‰ˆæœ¬)
â”‚   â”œâ”€â”€ æ¨¡å—é€‰æ‹© (å•ä¸ªæ¨¡å—æˆ–å…¨éƒ¨æ¨¡å—)
â”‚   â”œâ”€â”€ ä¸‹è½½è¿‡ç¨‹
â”‚   â”‚   â””â”€â”€ æ”¯æŒ HTTP ä»£ç†
â”‚   â””â”€â”€ è§£å‹å¤„ç†
â”‚       â””â”€â”€ å¯é€‰çš„è‡ªåŠ¨è§£å‹åŠŸèƒ½
â”‚
â””â”€â”€ å®‰å…¨å’Œæƒé™
    â”œâ”€â”€ sudo æƒé™ä¿æŒ (sudo_keep_alive)
    â””â”€â”€ æ¸…ç†è¿‡ç¨‹ (cleanup)
```

## å‰ææ¡ä»¶

- macOS æ“ä½œç³»ç»Ÿï¼ˆç”¨äºè¿è¡Œæ„å»ºè„šæœ¬ï¼‰
- Homebrew
- Python 3
- Go (ç”¨äºç¼–è¯‘ hexreplace å·¥å…·)
- è¶Šç‹±çš„ iOS è®¾å¤‡
- åœ¨ iOS è®¾å¤‡ä¸Šå®‰è£… OpenSSH

## å®‰è£…

### æ–¹å¼ä¸€ï¼šå‘½ä»¤è¡Œç‰ˆæœ¬

1. å…‹éš†æ­¤ä»“åº“ï¼š
```shell
git clone https://github.com/suifei/fridare.git
cd fridare
```

2. è¿è¡Œè®¾ç½®å‘½ä»¤
```shell
./fridare.sh setup
```
æ­¤å‘½ä»¤å°†æ£€æŸ¥å¹¶å®‰è£…æ‰€éœ€çš„ä¾èµ–é¡¹ã€‚

3. æŸ¥çœ‹å¸®åŠ©
```shell
./fridare.sh help
```

### æ–¹å¼äºŒï¼šGUIç‰ˆæœ¬ï¼ˆæ¨èï¼‰

#### æ„å»ºGUIåº”ç”¨

1. ç¡®ä¿å·²å®‰è£…ä¾èµ–ï¼š
```shell
# å®‰è£… Go (å¦‚æœå°šæœªå®‰è£…)
# å®‰è£… Fyne ä¾èµ–
go install fyne.io/fyne/v2/cmd/fyne@latest
```

2. æ„å»ºGUIåº”ç”¨ï¼š
```shell
cd ui
./build.sh
```

3. è¿è¡ŒGUIåº”ç”¨ï¼š
```shell
./build/fridare-gui.exe
```

#### GUIç‰ˆæœ¬ç‰¹è‰²

- ğŸ¨ **ç›´è§‚ç•Œé¢**ï¼šç°ä»£åŒ–çš„å›¾å½¢ç”¨æˆ·ç•Œé¢ï¼Œæ“ä½œç®€å•ç›´è§‚
- ğŸ“ **æ–‡ä»¶æ‹–æ‹½**ï¼šæ”¯æŒæ‹–æ‹½æ–‡ä»¶åˆ°åº”ç”¨ä¸­è¿›è¡Œå¤„ç†
- ğŸ“Š **å®æ—¶åé¦ˆ**ï¼šå¯è§†åŒ–è¿›åº¦æ¡å’Œå½©è‰²æ—¥å¿—è¾“å‡º
- âš™ï¸ **é…ç½®ç®¡ç†**ï¼šå›¾å½¢åŒ–é…ç½®ç•Œé¢ï¼Œè®¾ç½®ä¸€ç›®äº†ç„¶
- ğŸ”§ **å·¥å…·é›†æˆ**ï¼šé›†æˆåˆ›å»ºã€ä¿®è¡¥ã€GUIå¤šä¸ªå·¥å…·äºä¸€ä½“
- ğŸ—‚ï¸ **Windows debåŒ…æ”¯æŒ**ï¼šåœ¨Windowsä¸‹åŸç”Ÿå¤„ç†debåŒ…ï¼Œæ— éœ€Linuxç¯å¢ƒ

## ä½¿ç”¨æ–¹æ³•
Fridare æä¾›äº†å¤šä¸ªå‘½ä»¤æ¥æ»¡è¶³ä¸åŒçš„éœ€æ±‚ï¼š

### å‘½ä»¤æ¸…å•

1. `build`: é‡æ–°æ‰“åŒ… Frida
2. `ls` æˆ– `list`: åˆ—å‡ºå¯ç”¨çš„ Frida ç‰ˆæœ¬
3. `download`: ä¸‹è½½ç‰¹å®šç‰ˆæœ¬çš„ Frida
4. `lm` æˆ– `list-modules`: åˆ—å‡ºå¯ç”¨çš„ Frida æ¨¡å—
5. `setup`: æ£€æŸ¥å¹¶å®‰è£…ç³»ç»Ÿä¾èµ–
6. `config`: è®¾ç½®é…ç½®é€‰é¡¹
7. `help`: æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯

### ä½¿ç”¨èŒƒä¾‹

1. æ„å»ºé­”æ”¹ç‰ˆ Frida
```shell
./fridare.sh build -v 16.0.19 -p 8899 -y
```
è¿™ä¸ªå‘½ä»¤ä¼šæ„å»ºç‰ˆæœ¬ 16.0.19 çš„ Fridaï¼Œè®¾ç½®ç«¯å£ä¸º 8899ï¼Œå¹¶è‡ªåŠ¨ç¡®è®¤æ‰€æœ‰æç¤ºã€‚

2. åˆ—å‡ºå¯ç”¨çš„ Frida ç‰ˆæœ¬
```shell
./fridare.sh ls
```

3. ä¸‹è½½ç‰¹å®šç‰ˆæœ¬çš„ Frida
```shell
./fridare.sh download -v 16.0.19 -m frida-server ./output
```
è¿™ä¸ªå‘½ä»¤ä¼šä¸‹è½½ç‰ˆæœ¬ 16.0.19 çš„ frida-server æ¨¡å—åˆ° ./output ç›®å½•ã€‚

4. ä¸‹è½½æœ€æ–°ç‰ˆæœ¬çš„æ‰€æœ‰ Frida æ¨¡å—
```shell
./fridare.sh download -latest -all ./output
```

5. åˆ—å‡ºå¯ç”¨çš„ Frida æ¨¡å—
```shell
./fridare.sh lm
```

6. è®¾ç½®ç¯å¢ƒ
```shell
./fridare.sh setup
```
è¿™ä¸ªå‘½ä»¤ä¼šæ£€æŸ¥å¹¶å®‰è£…æ‰€éœ€çš„ç³»ç»Ÿä¾èµ–ã€‚

7. é…ç½®è®¾ç½®
```shell
./fridare.sh config set proxy http://127.0.0.1:7890
./fridare.sh config set port 9999
./fridare.sh config set frida-name abcde
```
è¿™äº›å‘½ä»¤åˆ†åˆ«è®¾ç½®ä»£ç†ã€ç«¯å£å’Œ Frida é­”æ”¹åã€‚

8. åˆ—å‡ºå½“å‰é…ç½®
```shell
./fridare.sh config ls
```

9. è·å–ç‰¹å®šå‘½ä»¤çš„å¸®åŠ©ä¿¡æ¯
```shell
./fridare.sh help build
```
è¿™ä¸ªå‘½ä»¤ä¼šæ˜¾ç¤º build å‘½ä»¤çš„è¯¦ç»†ç”¨æ³•ã€‚

10. ä½¿ç”¨æœ€æ–°ç‰ˆæœ¬æ„å»º Frida
```shell
./fridare.sh build -latest -p 9999 -y
```
è¿™ä¸ªå‘½ä»¤ä¼šä½¿ç”¨æœ€æ–°ç‰ˆæœ¬çš„ Frida è¿›è¡Œæ„å»ºï¼Œè®¾ç½®ç«¯å£ä¸º 9999ï¼Œå¹¶è‡ªåŠ¨ç¡®è®¤æ‰€æœ‰æç¤ºã€‚

11. ä¸‹è½½ä½†ä¸è§£å‹ Frida æ¨¡å—
```shell
./fridare.sh download -latest -m frida-gadget --no-extract ./output
```
è¿™ä¸ªå‘½ä»¤ä¼šä¸‹è½½æœ€æ–°ç‰ˆæœ¬çš„ frida-gadget æ¨¡å—åˆ° ./output ç›®å½•ï¼Œä½†ä¸ä¼šè‡ªåŠ¨è§£å‹ã€‚

12. å®‰è£… frida-tools
```shell
./fridare.sh config frida-tools
```
è¿™ä¸ªå‘½ä»¤ä¼šå®‰è£…æˆ–æ›´æ–° frida-toolsã€‚

13. å°†ç”Ÿæˆçš„ .deb åŒ…ä¼ è¾“åˆ°æ‚¨çš„ iOS è®¾å¤‡ï¼š
```shell
scp ./dist/frida_16.3.3_iphoneos-arm_tcp.deb root@<iPhone-IP>:/var/root/
```

14. SSH è¿›å…¥æ‚¨çš„ iOS è®¾å¤‡å¹¶å®‰è£…ä¿®æ”¹åçš„åŒ…ï¼š
```shell
ssh root@<iPhone-IP>
dpkg -i /var/root/frida_16.3.3_iphoneos-arm_tcp.deb
```

è¿™äº›ç¤ºä¾‹æ¶µç›–äº†è„šæœ¬çš„ä¸»è¦åŠŸèƒ½å’Œå¸¸è§ä½¿ç”¨åœºæ™¯ã€‚å¯å¸®åŠ©æ‚¨å¿«é€Ÿä¸Šæ‰‹ä½¿ç”¨ã€‚

## å®‰è£…å…¼å®¹ç‰ˆæœ¬çš„ Frida å·¥å…·

ä¸ºç¡®ä¿å…¼å®¹æ€§ï¼Œè¯·å®‰è£…ä¸ä¿®æ”¹åçš„æœåŠ¡å™¨ç‰ˆæœ¬ç›¸åŒ¹é…çš„ Frida å·¥å…·ï¼š
```shell
pip install frida-tools==12.4.3
```
å¯¹äº Node.js ç”¨æˆ·ï¼š
```shell
npm install frida@16.3.3
```

## è®¿é—® frida-server
å¦‚æœæ‚¨çš„è®¾å¤‡é€šè¿‡ USB è®¿é—®ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤è¿æ¥åˆ°æœ¬åœ° frida-serverï¼š
```shell
frida -U -f <target-process>
```
## ä½¿ç”¨è¿œç¨‹ frida-server
å¦‚æœä¸ä½¿ç”¨usbæ•°æ®çº¿æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤è¿æ¥åˆ°è¿œç¨‹ frida-server ï¼š
```shell
frida -H <iPhone-IP>:8899 -U
frida-trace -H <iPhone-IP>:8899 ...
frida-ps -H <iPhone-IP>:8899
frida-inject -H <iPhone-IP>:8899 ...
```

## åŸç†
Fridare é¡¹ç›®çš„æ ¸å¿ƒåŸç†ï¼š

### 1. frida-server ä¿®æ”¹åŸç†

Fridare çš„æ ¸å¿ƒæ€æƒ³æ˜¯ä¿®æ”¹ frida-server ï¼Œä½¿å…¶æ›´éš¾è¢«æ£€æµ‹ã€‚è¿™ä¸»è¦é€šè¿‡ä»¥ä¸‹å‡ ä¸ªæ–¹é¢å®ç°ï¼š

- é‡å‘½åæœåŠ¡å™¨æ–‡ä»¶ï¼š
   å°† `frida-server` é‡å‘½åä¸ºéšæœºç”Ÿæˆçš„åç§°ï¼ˆå¦‚ `abcde`ï¼‰ï¼Œè¿™æ ·å¯ä»¥é¿å…ç®€å•çš„åç§°æ£€æµ‹ã€‚

- ä¿®æ”¹å¯åŠ¨é…ç½®ï¼š
   æ›´æ–° LaunchDaemons plist æ–‡ä»¶ï¼Œä½¿å…¶ä½¿ç”¨æ–°çš„æœåŠ¡å™¨åç§°å’Œè‡ªå®šä¹‰ç«¯å£ã€‚è¿™æ ·å¯ä»¥æ”¹å˜æœåŠ¡å™¨çš„å¯åŠ¨æ–¹å¼å’Œç›‘å¬ç«¯å£ã€‚

- äºŒè¿›åˆ¶æ–‡ä»¶ä¿®æ”¹ï¼š
   ä½¿ç”¨äºŒè¿›åˆ¶æ›¿æ¢æŠ€æœ¯ï¼Œå°†æœåŠ¡å™¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­çš„ "frida" ç›¸å…³å­—ç¬¦ä¸²æ›¿æ¢ä¸ºè‡ªå®šä¹‰å­—ç¬¦ä¸²ã€‚è¿™å¯ä»¥é¿å…é€šè¿‡æ‰«æäºŒè¿›åˆ¶æ–‡ä»¶æ¥æ£€æµ‹ Fridaã€‚

### 2. deb åŒ…ä¿®æ”¹å’Œé‡æ‰“åŒ…

é¡¹ç›®ä½¿ç”¨ dpkg-deb å·¥å…·è§£åŒ…å’Œé‡æ–°æ‰“åŒ… deb æ–‡ä»¶ã€‚è¿™å…è®¸æˆ‘ä»¬ä¿®æ”¹åŒ…çš„å†…å®¹ï¼ŒåŒ…æ‹¬ï¼š

- æ›´æ–° DEBIAN/control æ–‡ä»¶ä¸­çš„åŒ…å
- ä¿®æ”¹ DEBIAN/extrainst_ å’Œ DEBIAN/prerm è„šæœ¬ä»¥ä½¿ç”¨æ–°çš„æœåŠ¡å™¨åç§°
- æ›¿æ¢å’Œé‡å‘½åå®é™…çš„æœåŠ¡å™¨äºŒè¿›åˆ¶æ–‡ä»¶

### 3. è‡ªåŠ¨åŒ–æµç¨‹

fridare.sh è„šæœ¬è‡ªåŠ¨åŒ–äº†æ•´ä¸ªè¿‡ç¨‹ï¼š

- ä¸‹è½½æŒ‡å®šç‰ˆæœ¬çš„ frida-server 
- ç”Ÿæˆéšæœºåç§°
- ä¿®æ”¹æ‰€æœ‰å¿…è¦çš„æ–‡ä»¶
- é‡æ–°æ‰“åŒ… deb æ–‡ä»¶

### 4. å…¼å®¹æ€§è€ƒè™‘

è„šæœ¬åŒæ—¶å¤„ç† arm å’Œ arm64 æ¶æ„çš„åŒ…ï¼Œç¡®ä¿åœ¨ä¸åŒçš„ iOS è®¾å¤‡ä¸Šçš„å…¼å®¹æ€§ã€‚

### 5. å®‰å…¨æ€§å¢å¼º

é€šè¿‡æ›´æ”¹æœåŠ¡å™¨åç§°ã€ç«¯å£å’Œå†…éƒ¨å­—ç¬¦ä¸²ï¼Œè¿™ä¸ªé¡¹ç›®ä½¿å¾—é€šè¿‡å¸¸è§„æ–¹æ³•æ£€æµ‹ Frida çš„å­˜åœ¨å˜å¾—æ›´åŠ å›°éš¾ã€‚è¿™å¯¹äºåœ¨æŸäº›å¯èƒ½ä¼šä¸»åŠ¨æ£€æµ‹å’Œé˜»æ­¢ Frida çš„åº”ç”¨ä¸­ä½¿ç”¨ Frida éå¸¸æœ‰ç”¨ã€‚

### 6. çµæ´»æ€§

é€šè¿‡å…è®¸ç”¨æˆ·æŒ‡å®š Frida ç‰ˆæœ¬å’Œç«¯å£ï¼Œè¯¥å·¥å…·æä¾›äº†å¾ˆå¤§çš„çµæ´»æ€§ï¼Œå¯ä»¥é€‚åº”ä¸åŒçš„éœ€æ±‚å’Œç¯å¢ƒã€‚

### 7. äºŒè¿›åˆ¶ä¿®æ”¹æŠ€æœ¯

ä½¿ç”¨ [hexreplace](hexreplace/main.go) æ¥æ‰§è¡ŒäºŒè¿›åˆ¶æ›¿æ¢ï¼Œåœ¨ä¸é‡æ–°ç¼–è¯‘ Frida çš„æƒ…å†µä¸‹ä¿®æ”¹äºŒè¿›åˆ¶æ–‡ä»¶ã€‚è¿™ç§æ–¹æ³•è™½ç„¶æœ‰æ•ˆï¼Œä½†ä¹Ÿæœ‰å±€é™æ€§ï¼Œå› ä¸ºå®ƒåªèƒ½æ›¿æ¢å›ºå®šé•¿åº¦çš„å­—ç¬¦ä¸²ã€‚

## æ³¨æ„äº‹é¡¹

- é»˜è®¤çš„ root ç”¨æˆ·å¯†ç ä¸º "alpine"ã€‚å‡ºäºå®‰å…¨è€ƒè™‘ï¼Œå¼ºçƒˆå»ºè®®æ›´æ”¹æ­¤å¯†ç ã€‚
- è¯·ç¡®ä¿æ‚¨çš„ iOS è®¾å¤‡å·²è¶Šç‹±å¹¶å®‰è£…äº† OpenSSHã€‚
- æ­¤å·¥å…·ä»…ç”¨äºæ•™è‚²å’Œç ”ç©¶ç›®çš„ã€‚è¯·éµå®ˆæ‰€æœ‰é€‚ç”¨çš„æ³•å¾‹å’Œæ¡æ¬¾ã€‚

## è´¡çŒ®

æ¬¢è¿æäº¤é—®é¢˜å’Œæ‹‰å–è¯·æ±‚ã€‚å¯¹äºé‡å¤§æ›´æ”¹ï¼Œè¯·å…ˆå¼€issueè®¨è®ºæ‚¨æƒ³è¦æ›´æ”¹çš„å†…å®¹ã€‚

## è®¸å¯è¯

[MIT LICENSE](LICENSE)

---

# Fridare

Fridare is a modification tool designed for customizing Frida-server, specifically for jailbroken iOS devices. It allows users to change names and ports, enhancing security and flexibility. It eliminates many jailbreak detection scenarios for Frida.

ğŸ‰ **v4.0.0 Major Update**: Brand new cross-platform GUI version based on Fyne framework, providing a modern graphical user interface that makes Frida server modification more intuitive and convenient!

âœ¨ **Dual Mode Support**: Retains the powerful command-line interface while introducing a user-friendly graphical interface to meet different user preferences.

[CHANGELOG](CHANGELOG)

## Features

Here's the English version of the changelog:

## [v3.1.4] - 2024-07-18

### Added
- Introduced new `patch-tools` command for modifying the frida-tools module
- Implemented `render_markdown` function to display simple Markdown formatting in the terminal
- Added `generate_random_name` function to create random Frida modification names
- Created `move_file` function to handle "are identical" errors during file moves

### Improved
- Enhanced `list_frida_versions` function to render Markdown-formatted version descriptions
- Upgraded `build_frida` function to support building from local deb files
- Expanded functionality and error handling in `patch_frida_tools` and `restore_frida_tools` functions
- Optimized `modify_frida_tools` function for more reliable frida-tools modifications
- Enhanced `download_frida_module` function with support for specific OS and architecture

### Fixed
- Resolved issues with incorrect Frida path detection in certain scenarios
- Addressed "are identical" errors that could occur during file moves

### Changed
- Updated `show_main_usage` and other usage instruction functions to reflect new features
- Adjusted `parse_arguments` function to accommodate the new `patch-tools` command
- Modified configuration file handling to include support for `FRIDA_NAME`

### Other
- Improved overall code structure for better readability and maintainability
- Added more detailed log outputs for enhanced execution information
- Updated version number to 3.1.4

### New Features v3.0.0
- Added `fridare.sh` script, integrating all functionalities and providing a more complete command-line interface
- Added `build`, `ls`, `download`, `lm`, `setup`, `config`, and `help` commands
- Added configuration file support for saving and loading user settings
- Added color output to enhance user experience
- Added automatic dependency checking and installation
- Added functionality to download specific Frida modules
- Added listing of available Frida versions and modules

### New Features v2.2.0 (Tested only on macOS arm architecture, other architectures not tested)
- Added frida-tools patch, adapting to `frida:rpc` feature modification
   - Resolves the issue of Android memory scanning for this string
   - Automatically scans the local pip installation location of frida-tools, modifies the `core.py` file, and modifies the `_frida.abi3.so` file
- Added frida-agent.dylib modification, hiding from filename and load location
   - Resolves the issue of unhidden agent loading

### New Features v2.1.1

- Introduced `autoinstall.sh` script for automatic deployment of Frida plugins.
- Introduced `Makefile` to simplify the project build and deployment process.
- Before running, please ensure that the [issh](https://github.com/4ch12dy/issh) command is installed on your machine. And configure password-free SSH login.
   > Configure password-free SSH login for issh
   ```shell
   # Generate keygen, skip if already generated
   ssh-keygen -t rsa -b 4096 -C "<EMAIL>"
   # Configure iPhone IP, can be skipped if using USB connection
   issh ip set <iPhone-IP>     
   # Copy public key to /var/root on the phone, requires root password alpine
   issh scp ~/.ssh/id_rsa.pub  
   # Add public key to authorized_keys file on remote server
   issh run "mkdir -p ~/.ssh && cat /var/root/id_rsa.pub >> ~/.ssh/authorized_keys && chmod 600 ~/.ssh/authorized_keys && chmod 700 ~/.ssh"
   ```

## Features

- **ğŸ‰ Brand New GUI Version**: Modern graphical user interface based on Fyne framework
- **ğŸ–¥ï¸ Cross-Platform Support**: Native GUI applications for Windows, macOS, Linux
- **ğŸ“± Intuitive Operation**: Visual Frida server modification and configuration management
- **ğŸ“Š Real-time Feedback**: Graphical log display and progress bar visualization
- **ğŸ”§ Windows deb Package Support**: Native deb package modification and creation on Windows without Linux environment
- Automatically download and modify specified versions of frida-server
- Randomly generate new frida-server names
- Customize frida-server ports
- Support for arm and arm64 architectures
- Binary replacement modification
   - frida-server
   - frida-agent.dylib
   - frida-tools
- Generate modified .deb packages ready for direct installation
- Integrated command-line interface providing multiple functionalities
- Configuration file support for saving user settings
- Automatic dependency checking and installation
- Download specific Frida modules
- List available Frida versions and modules

## Structure and Functionality of the Frida Modification Script
```shell
fridare.sh - Frida Modification Script
â”‚
â”œâ”€â”€ Main Functions
â”‚   â”œâ”€â”€ Build Modified Frida (build)
â”‚   â”‚   â”œâ”€â”€ Support for specified version or latest version
â”‚   â”‚   â”œâ”€â”€ Auto-generate random 5-character name
â”‚   â”‚   â”œâ”€â”€ Custom port setting
â”‚   â”‚   â””â”€â”€ Support for arm and arm64 architectures
â”‚   â”œâ”€â”€ List Available Frida Versions (ls, list)
â”‚   â”‚   â””â”€â”€ Fetch version info from GitHub API
â”‚   â”œâ”€â”€ Download Specific Frida Version (download)
â”‚   â”‚   â”œâ”€â”€ Support for downloading single or all modules
â”‚   â”‚   â””â”€â”€ Optional auto-extraction feature
â”‚   â”œâ”€â”€ List Available Frida Modules (lm, list-modules)
â”‚   â”œâ”€â”€ Check and Install System Dependencies (setup)
â”‚   â”‚   â”œâ”€â”€ Auto-detect missing dependencies
â”‚   â”‚   â””â”€â”€ Install dependencies using package manager
â”‚   â””â”€â”€ Configure Options (config)
â”‚       â”œâ”€â”€ Set HTTP proxy
â”‚       â”œâ”€â”€ Set Frida server port
â”‚       â””â”€â”€ Set Frida modification name
â”‚
â”œâ”€â”€ Script Structure
â”‚   â”œâ”€â”€ Initialize Configuration (initialize_config)
â”‚   â”‚   â””â”€â”€ Read and create configuration file
â”‚   â”œâ”€â”€ Parse Arguments (parse_arguments)
â”‚   â”‚   â””â”€â”€ Support various command-line options
â”‚   â”œâ”€â”€ Command Processing
â”‚   â”‚   â”œâ”€â”€ build: Build modified Frida
â”‚   â”‚   â”œâ”€â”€ setup: Set up environment
â”‚   â”‚   â”œâ”€â”€ config: Manage configuration
â”‚   â”‚   â”œâ”€â”€ list: List versions
â”‚   â”‚   â”œâ”€â”€ download: Download modules
â”‚   â”‚   â””â”€â”€ list-modules: List modules
â”‚   â””â”€â”€ Main Function (main)
â”‚       â””â”€â”€ Entry point integrating all functionalities
â”‚
â”œâ”€â”€ Build Process (build_frida)
â”‚   â”œâ”€â”€ Version Check
â”‚   â”‚   â””â”€â”€ Support for latest version auto-detection
â”‚   â”œâ”€â”€ Environment Preparation
â”‚   â”‚   â”œâ”€â”€ Check Python environment (including Conda)
â”‚   â”‚   â””â”€â”€ Check Golang environment
â”‚   â”œâ”€â”€ Download Frida (download_frida)
â”‚   â”œâ”€â”€ Unpack deb File
â”‚   â”œâ”€â”€ Modify Files
â”‚   â”‚   â”œâ”€â”€ Modify Launch Daemon (modify_launch_daemon)
â”‚   â”‚   â”‚   â””â”€â”€ Update plist file
â”‚   â”‚   â”œâ”€â”€ Modify Debian Files (modify_debian_files)
â”‚   â”‚   â”‚   â”œâ”€â”€ Update control file
â”‚   â”‚   â”‚   â”œâ”€â”€ Update extrainst_ file
â”‚   â”‚   â”‚   â””â”€â”€ Update prerm file
â”‚   â”‚   â””â”€â”€ Modify Binary Files (modify_binary)
â”‚   â”‚       â”œâ”€â”€ Modify frida-server
â”‚   â”‚       â”œâ”€â”€ Modify frida-agent.dylib
â”‚   â”‚       â””â”€â”€ Use hexreplace tool
â”‚   â”œâ”€â”€ Repackage deb File (repackage_deb)
â”‚   â””â”€â”€ Modify frida-tools (modify_frida_tools)
â”‚       â”œâ”€â”€ Modify Python library files
â”‚       â””â”€â”€ Update strings in core.py
â”‚
â”œâ”€â”€ Auxiliary Functions
â”‚   â”œâ”€â”€ Log Output (log_info, log_success, log_warning, log_error)
â”‚   â”‚   â””â”€â”€ Support for colored output
â”‚   â”œâ”€â”€ User Confirmation (confirm_execution)
â”‚   â”‚   â””â”€â”€ Optional auto-confirm mode
â”‚   â”œâ”€â”€ Dependency Check (check_dependencies)
â”‚   â”œâ”€â”€ Dependency Installation (install_dependencies)
â”‚   â”œâ”€â”€ Configuration Management (set_config, unset_config, list_config)
â”‚   â””â”€â”€ Frida Version and Module Lists (list_frida_versions, list_frida_modules)
â”‚
â”œâ”€â”€ Download Functionality (download_frida_module)
â”‚   â”œâ”€â”€ Version Selection (latest or specified version)
â”‚   â”œâ”€â”€ Module Selection (single module or all modules)
â”‚   â”œâ”€â”€ Download Process
â”‚   â”‚   â””â”€â”€ Support for HTTP proxy
â”‚   â””â”€â”€ Extraction Processing
â”‚       â””â”€â”€ Optional auto-extraction feature
â”‚
â””â”€â”€ Security and Permissions
    â”œâ”€â”€ Maintain sudo Privileges (sudo_keep_alive)
    â””â”€â”€ Cleanup Process (cleanup)
```

## Prerequisites

- macOS operating system (for running build scripts)
- Homebrew
- Python 3
- Go (for compiling the hexreplace tool)
- Jailbroken iOS device
- OpenSSH installed on iOS device

## Installation

1. Clone this repository:
```shell
git clone https://github.com/suifei/fridare.git
cd fridare
```

2. Run the setup command:
```shell
./fridare.sh setup
```
This command will check and install the required dependencies.

3. View the help information:
```shell
./fridare.sh help
```

## Usage
Fridare provides multiple commands to meet different needs:

### Command List

1. `build`: Repackage Frida
2. `ls` or `list`: List available Frida versions
3. `download`: Download a specific version of Frida
4. `lm` or `list-modules`: List available Frida modules
5. `setup`: Check and install system dependencies
6. `config`: Set configuration options
7. `help`: Display help information

### Usage Examples

1. Build a modified version of Frida
```shell
./fridare.sh build -v 16.0.19 -p 8899 -y
```
This command will build Frida version 16.0.19, set the port to 8899, and automatically confirm all prompts.

2. List available Frida versions
```shell
./fridare.sh ls
```

3. Download a specific version of Frida
```shell
./fridare.sh download -v 16.0.19 -m frida-server ./output
```
This command will download the frida-server module of version 16.0.19 to the ./output directory.

4. Download all Frida modules of the latest version
```shell
./fridare.sh download -latest -all ./output
```

5. List available Frida modules
```shell
./fridare.sh lm
```

6. Set up the environment
```shell
./fridare.sh setup
```
This command will check and install the required system dependencies.

7. Configure settings
```shell
./fridare.sh config set proxy http://127.0.0.1:7890
./fridare.sh config set port 9999
./fridare.sh config set frida-name abcde
```
These commands set the proxy, port, and Frida modification name respectively.

8. List current configuration
```shell
./fridare.sh config ls
```

9. Get help information for a specific command
```shell
./fridare.sh help build
```
This command will display detailed usage for the build command.

10. Build Frida using the latest version
```shell
./fridare.sh build -latest -p 9999 -y
```
This command will build using the latest version of Frida, set the port to 9999, and automatically confirm all prompts.

11. Download but don't extract Frida module
```shell
./fridare.sh download -latest -m frida-gadget --no-extract ./output
```
This command will download the latest version of the frida-gadget module to the ./output directory but won't automatically extract it.

12. Install frida-tools
```shell
./fridare.sh config frida-tools
```
This command will install or update frida-tools.

13. Transfer the generated .deb package to your iOS device:
```shell
scp ./dist/frida_16.3.3_iphoneos-arm_tcp.deb root@<iPhone-IP>:/var/root/
```

14. SSH into your iOS device and install the modified package:
```shell
ssh root@<iPhone-IP>
dpkg -i /var/root/frida_16.3.3_iphoneos-arm_tcp.deb
```

These examples cover the main functionalities and common usage scenarios of the script. They can help you quickly get started with using it.

## Installing Compatible Frida Tools

To ensure compatibility, please install Frida tools that match the modified server version:
```shell
pip install frida-tools==12.4.3
```
For Node.js users:
```shell
npm install frida@16.3.3
```

## Accessing frida-server
If your device is accessed via USB, you can use the following command to connect to the local frida-server:
```shell
frida -U -f <target-process>
```
## Using Remote frida-server
If not using a USB data cable, you can use the following commands to connect to the remote frida-server:
```shell
frida -H <iPhone-IP>:8899 -U
frida-trace -H <iPhone-IP>:8899 ...
frida-ps -H <iPhone-IP>:8899
frida-inject -H <iPhone-IP>:8899 ...
```

## Principles
Core principles of the Fridare project:

### 1. frida-server Modification Principle

The core idea of Fridare is to modify frida-server to make it harder to detect. This is mainly achieved through the following aspects:

- Renaming the server file:
   Rename `frida-server` to a randomly generated name (e.g., `abcde`), which avoids simple name detection.

- Modifying startup configuration:
   Update the LaunchDaemons plist file to use the new server name and custom port. This changes the way the server starts and the port it listens on.

- Binary file modification:
   Use binary replacement techniques to replace "frida" related strings in the server binary file with custom strings. This can avoid detection of Frida by scanning the binary file.

### 2. deb Package Modification and Repackaging

The project uses the dpkg-deb tool to unpack and repack deb files. This allows us to modify the contents of the package, including:

- Updating the package name in the DEBIAN/control file
- Modifying DEBIAN/extrainst_ and DEBIAN/prerm scripts to use the new server name
- Replacing and renaming the actual server binary file

### 3. Automated Process

The fridare.sh script automates the entire process:

- Downloading the specified version of frida-server
- Generating random names
- Modifying all necessary files
- Repacking the deb file

### 4. Compatibility Considerations

The script handles packages for both arm and arm64 architectures, ensuring compatibility on different iOS devices.

### 5. Enhanced Security

By changing the server name, port, and internal strings, this project makes it more difficult to detect the presence of Frida through conventional methods. This is particularly useful for using Frida in applications that might actively detect and block Frida.

### 6. Flexibility

By allowing users to specify the Frida version and port, the tool provides great flexibility to adapt to different needs and environments.

### 7. Binary Modification Technique

Using [hexreplace](hexreplace/main.go) to perform binary replacements, modifying binary files without recompiling Frida. While effective, this method has limitations as it can only replace fixed-length strings.

## Notes

- The default root user password is "alpine". For security reasons, it is strongly recommended to change this password.
- Please ensure your iOS device is jailbroken and has OpenSSH installed.
- This tool is for educational and research purposes only. Please comply with all applicable laws and terms.

## Contributing

Issues and pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.

## License

[MIT LICENSE](LICENSE)

```

`autoinstall.sh`:

```sh
#!/bin/bash
iSSH_ROOT_DIR=`cat ~/.issh/rootdir`
if [ -z "$iSSH_ROOT_DIR" ]; then
  echo "issh not found in PATH"
  echo "Please install issh from https://github.com/4ch12dy/issh"
  exit 1
fi

DEB_NAME=$(cd dist && ls -lt *-arm_*.deb | head -n 1 | awk '{print $9}' && cd ..)
INSTALL_NAME=$(echo $DEB_NAME | awk -F'_' '{print $4}')
INSTANCE_NAME=$(source $iSSH_ROOT_DIR/issh.sh && issh run "apt install gawk -y --allow-unauthenticated" && issh run "ps -e | grep 0.0.0.0:8899 | grep /usr/sbin/ | grep -v grep | awk '{n=split(\$0,a,\"/\");n2=split(a[n],b,\" \"); print b[n2-2]}'")
INSTANCE_NAME=$(echo $INSTANCE_NAME | awk '{print $NF}')
echo "DEB File: $DEB_NAME"
echo "Frida Instance: $INSTANCE_NAME"
echo "Install Name: $INSTALL_NAME"

source $iSSH_ROOT_DIR/issh.sh && issh scp dist/$DEB_NAME

if [ -n "$INSTANCE_NAME" ]; then
    source $iSSH_ROOT_DIR/issh.sh && issh run "dpkg -r re.$INSTANCE_NAME.server"  
fi
source $iSSH_ROOT_DIR/issh.sh && issh run "dpkg -i /var/root/$DEB_NAME"
source $iSSH_ROOT_DIR/issh.sh && issh run "rm -rf /var/root/$DEB_NAME"
source $iSSH_ROOT_DIR/issh.sh && issh run "ps -e|grep $INSTALL_NAME"
```

`docs/android.md`:

```md
# Android frida-server é­”æ”¹æ•™ç¨‹

## å‰ææ¡ä»¶

- å®‰è£… fridare.sh è„šæœ¬
- ç¡®ä¿ç³»ç»Ÿä¸­å·²å®‰è£… Python 3 å’Œ Golang
- ç¡®ä¿å·²å®‰è£… Frida

## æ­¥éª¤

### 1. æ£€æŸ¥ç¯å¢ƒ

é¦–å…ˆï¼Œè¿è¡Œ `fridare.sh upgrade` å‘½ä»¤æ¥æ£€æŸ¥ç¯å¢ƒå¹¶æ›´æ–° FRIDA_MODULESï¼š

```bash
$ ./fridare.sh upgrade
```

è¿™å°†æ˜¾ç¤ºæ‚¨çš„ç¯å¢ƒä¿¡æ¯ï¼ŒåŒ…æ‹¬ Python ç‰ˆæœ¬ã€Frida ç‰ˆæœ¬ã€Go ç‰ˆæœ¬ç­‰ã€‚

### 2. é…ç½®ä»£ç†ï¼ˆå¯é€‰ï¼‰

å¦‚æœéœ€è¦ä½¿ç”¨ä»£ç†ï¼Œå¯ä»¥é€šè¿‡ä»¥ä¸‹å‘½ä»¤è®¾ç½®ï¼š

```bash
$ ./fridare.sh conf edit
```

é€‰æ‹©é€‰é¡¹ 1 æ¥ç¼–è¾‘ HTTP ä»£ç†ï¼Œè¾“å…¥ä»£ç†åœ°å€ï¼ˆä¾‹å¦‚ï¼šsocks5://localhost:1080ï¼‰ã€‚

### 3. æŸ¥çœ‹å¯ç”¨çš„ Frida æ¨¡å—

è¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æŸ¥çœ‹æ‰€æœ‰å¯ç”¨çš„ Frida æ¨¡å—ï¼š

```bash
$ ./fridare.sh lm
```

è¿™å°†åˆ—å‡ºæ‰€æœ‰å¯ç”¨çš„ Frida æ¨¡å—ï¼ŒåŒ…æ‹¬å®ƒä»¬æ”¯æŒçš„æ“ä½œç³»ç»Ÿå’Œæ¶æ„ã€‚

### 4. é­”æ”¹ frida-server

ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤æ¥ä¿®è¡¥ frida-serverï¼š

```bash
$ ./fridare.sh patch -m frida-server -latest -os android -arch arm64 -o ./patched
```

å‚æ•°è¯´æ˜ï¼š
- `-m frida-server`: æŒ‡å®šè¦ä¿®è¡¥çš„æ¨¡å—
- `-latest`: ä½¿ç”¨æœ€æ–°ç‰ˆæœ¬çš„ Frida
- `-os android`: æŒ‡å®šæ“ä½œç³»ç»Ÿä¸º Android
- `-arch arm64`: æŒ‡å®šæ¶æ„ä¸º arm64
- `-o ./patched`: æŒ‡å®šè¾“å‡ºç›®å½•

### 5. è¾“å…¥é­”æ”¹åç§°

åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œè„šæœ¬ä¼šæç¤ºæ‚¨è¾“å…¥ä¸€ä¸ªé­”æ”¹åç§°ã€‚è¿™ä¸ªåç§°åº”è¯¥æ˜¯ 5 ä¸ªå­—æ¯ï¼ˆa-z æˆ– A-Zï¼‰ã€‚ä¾‹å¦‚ï¼š

```
è¯·è¾“å…¥æœ¬æ¬¡æ‰€é‡‡ç”¨çš„ Frida é­”æ”¹å: axjdf
```

### 6. ç­‰å¾…ä¿®è¡¥å®Œæˆ

è„šæœ¬ä¼šè‡ªåŠ¨ä¸‹è½½æŒ‡å®šçš„ frida-serverï¼Œè§£å‹ï¼Œç„¶åè¿›è¡Œä¿®è¡¥ã€‚æ•´ä¸ªè¿‡ç¨‹åŒ…æ‹¬ï¼š

- ä¸‹è½½ frida-server
- è§£å‹æ–‡ä»¶
- ä¿®è¡¥äºŒè¿›åˆ¶æ–‡ä»¶
- æ›¿æ¢å­—ç¬¦ä¸²

### 7. æŸ¥çœ‹è¾“å‡º

ä¿®è¡¥å®Œæˆåï¼Œæ‚¨ä¼šçœ‹åˆ°ç±»ä¼¼ä»¥ä¸‹çš„è¾“å‡ºï¼š

```
[SUCC] æ¨¡å—ä¿®è¡¥å®Œæˆ: ./patched/frida-server_axjdf
```

è¿™è¡¨ç¤ºé­”æ”¹åçš„ frida-server å·²ç»ç”Ÿæˆï¼Œæ–‡ä»¶åä¸º `frida-server_axjdf`ã€‚

## ä½¿ç”¨é­”æ”¹åçš„ frida-server

1. å°†ä¿®è¡¥åçš„ `frida-server_axjdf` æ–‡ä»¶ä¼ è¾“åˆ° Android è®¾å¤‡ä¸Šã€‚
2. èµ‹äºˆæ–‡ä»¶æ‰§è¡Œæƒé™ï¼š`chmod +x frida-server_axjdf`
3. åœ¨ Android è®¾å¤‡ä¸Šè¿è¡Œé­”æ”¹åçš„ frida-serverï¼š`./frida-server_axjdf`

æ³¨æ„ï¼šä½¿ç”¨é­”æ”¹åçš„ frida-server æ—¶ï¼Œç¡®ä¿å®¢æˆ·ç«¯ä»£ç ä¸­ä½¿ç”¨äº†ç›¸åŒçš„é­”æ”¹åç§°ï¼ˆæœ¬ä¾‹ä¸­ä¸º "axjdf"ï¼‰ã€‚

é€šè¿‡è¿™ä¸ªæ•™ç¨‹ï¼Œæ‚¨å¯ä»¥æˆåŠŸåœ°é­”æ”¹ Android ç‰ˆæœ¬çš„ frida-serverï¼Œä½¿å…¶æ›´éš¾è¢«æ£€æµ‹åˆ°ã€‚è®°å¾—æ¯æ¬¡ä½¿ç”¨æ—¶éƒ½æ›´æ¢é­”æ”¹åç§°ï¼Œä»¥æé«˜éšè”½æ€§ã€‚
```

`docs/install.md`:

```md
# Fridare å®‰è£…è¯´æ˜

Fridare æ˜¯ä¸€ä¸ªç”¨äºé­”æ”¹ Frida çš„å·¥å…·ï¼Œå¯ä»¥å¸®åŠ©ä½ ç»•è¿‡ä¸€äº›åŸºæœ¬çš„æ£€æµ‹æœºåˆ¶ã€‚ä»¥ä¸‹æ˜¯å®‰è£…å’Œé…ç½® Fridare çš„æ­¥éª¤ã€‚

## å¿«é€Ÿå®‰è£…

ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å¯ä»¥å¿«é€Ÿå®‰è£… Fridareï¼š

```bash
curl -s https://raw.githubusercontent.com/suifei/fridare/main/fridare.sh | bash -s install
```

è¿™ä¸ªå‘½ä»¤ä¼šåœ¨å½“å‰ç›®å½•ä¸‹åˆ›å»ºä¸€ä¸ª `fridare` æ–‡ä»¶å¤¹ï¼Œå…¶ä¸­åŒ…å«äº†å®‰è£…å¥½çš„ Fridare å·¥å…·ã€‚

## é…ç½®ç¯å¢ƒå˜é‡

å®‰è£…å®Œæˆåï¼Œä½ éœ€è¦å°† Fridare æ·»åŠ åˆ°ç³»ç»Ÿçš„ç¯å¢ƒå˜é‡ä¸­ï¼Œä»¥ä¾¿å¯ä»¥åœ¨ä»»ä½•ä½ç½®ä½¿ç”¨ `fridare` å‘½ä»¤ã€‚

### å¯¹äº Bash ç”¨æˆ·

1. ç¼–è¾‘ä½ çš„ `.bashrc` æ–‡ä»¶ï¼š

   ```bash
   nano ~/.bashrc
   ```

2. åœ¨æ–‡ä»¶æœ«å°¾æ·»åŠ ä»¥ä¸‹è¡Œï¼š

   ```bash
   export PATH=$PATH:/path/to/fridare
   ```

   è¯·å°† `/path/to/fridare` æ›¿æ¢ä¸ºå®é™…çš„ Fridare å®‰è£…è·¯å¾„ã€‚

3. ä¿å­˜å¹¶å…³é—­æ–‡ä»¶ï¼Œç„¶åè¿è¡Œï¼š

   ```bash
   source ~/.bashrc
   ```

### å¯¹äº Zsh ç”¨æˆ·

1. ç¼–è¾‘ä½ çš„ `.zshrc` æ–‡ä»¶ï¼š

   ```bash
   nano ~/.zshrc
   ```

2. åœ¨æ–‡ä»¶æœ«å°¾æ·»åŠ ä»¥ä¸‹è¡Œï¼š

   ```bash
   export PATH=$PATH:/path/to/fridare
   ```

   è¯·å°† `/path/to/fridare` æ›¿æ¢ä¸ºå®é™…çš„ Fridare å®‰è£…è·¯å¾„ã€‚

3. ä¿å­˜å¹¶å…³é—­æ–‡ä»¶ï¼Œç„¶åè¿è¡Œï¼š

   ```bash
   source ~/.zshrc
   ```

## éªŒè¯å®‰è£…

å®‰è£…å®Œæˆåï¼Œä½ å¯ä»¥é€šè¿‡è¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥éªŒè¯ Fridare æ˜¯å¦å·²æ­£ç¡®å®‰è£…ï¼š

```bash
fridare.sh help
```

å¦‚æœå®‰è£…æˆåŠŸï¼Œä½ åº”è¯¥èƒ½çœ‹åˆ° Fridare çš„ç‰ˆæœ¬ä¿¡æ¯ã€‚

## ä½¿ç”¨ Fridare

ç°åœ¨ä½ å¯ä»¥åœ¨ç»ˆç«¯çš„ä»»ä½•ä½ç½®ä½¿ç”¨ `fridare.sh` å‘½ä»¤æ¥è¿è¡Œ Fridare å·¥å…·ã€‚ä¾‹å¦‚ï¼š

```bash
fridare.sh build -latest
```

è¿™ä¸ªå‘½ä»¤ä¼šä¸‹è½½å¹¶é­”æ”¹æœ€æ–°ç‰ˆæœ¬çš„ Fridaã€‚

## æ³¨æ„äº‹é¡¹

- ç¡®ä¿ä½ æœ‰è¶³å¤Ÿçš„æƒé™æ¥ä¿®æ”¹ç³»ç»Ÿç¯å¢ƒå˜é‡ã€‚
- å¦‚æœä½ ä½¿ç”¨çš„æ˜¯å…¶ä»– shellï¼Œè¯·ç›¸åº”åœ°ä¿®æ”¹ç›¸å…³çš„é…ç½®æ–‡ä»¶ã€‚
- å®šæœŸæ£€æŸ¥ Fridare çš„æ›´æ–°ï¼Œä»¥è·å¾—æœ€æ–°çš„åŠŸèƒ½å’Œå®‰å…¨ä¿®å¤ã€‚

ç°åœ¨ä½ å·²ç»æˆåŠŸå®‰è£…äº† Fridareï¼Œå¯ä»¥å¼€å§‹ä½¿ç”¨å®ƒæ¥é­”æ”¹ Frida äº†ã€‚è¯·ç¡®ä¿åœ¨åˆæ³•å’Œæˆæƒçš„æƒ…å†µä¸‹ä½¿ç”¨æ­¤å·¥å…·ã€‚
```

`docs/ios.md`:

```md
# iOS frida-server é­”æ”¹æ•™ç¨‹

## å‰ææ¡ä»¶

- å®‰è£… fridare.sh è„šæœ¬
- ç¡®ä¿ç³»ç»Ÿä¸­å·²å®‰è£… Python 3 å’Œ Golang
- ç¡®ä¿å·²å®‰è£… Frida å’Œç›¸å…³ä¾èµ–

## æ­¥éª¤

### 1. è¿è¡Œé­”æ”¹è„šæœ¬

ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å¼€å§‹é­”æ”¹è¿‡ç¨‹ï¼š

```bash
$ ./fridare.sh build -latest
```

è¿™ä¸ªå‘½ä»¤ä¼šè‡ªåŠ¨ä¸‹è½½æœ€æ–°ç‰ˆæœ¬çš„ Fridaï¼Œå¹¶å¼€å§‹é­”æ”¹è¿‡ç¨‹ã€‚

### 2. ç¡®è®¤å…è´£å£°æ˜

è„šæœ¬ä¼šæ˜¾ç¤ºä¸€ä¸ªå…è´£å£°æ˜ã€‚ä»”ç»†é˜…è¯»å¹¶ç¡®è®¤æ˜¯å¦åŒæ„ï¼š

```
æ‚¨æ˜¯å¦åŒæ„ä»¥ä¸Šå…è´£å£°æ˜å¹¶å…è®¸ä½¿ç”¨sudoæƒé™ï¼Ÿ(y/N) y
```

è¾“å…¥ `y` å¹¶æŒ‰å›è½¦ä»¥ç»§ç»­ã€‚

### 3. ç­‰å¾…ä¸‹è½½å’Œä¿®æ”¹è¿‡ç¨‹

è„šæœ¬ä¼šè‡ªåŠ¨å®Œæˆä»¥ä¸‹æ­¥éª¤ï¼š

- ä¸‹è½½æœ€æ–°ç‰ˆæœ¬çš„ Frida deb åŒ…ï¼ˆé€‚ç”¨äº arm å’Œ arm64 æ¶æ„ï¼‰
- ä¿®æ”¹ plist æ–‡ä»¶
- ä¿®æ”¹ DEBIAN æ–‡ä»¶å¤¹ä¸­çš„æ–‡ä»¶
- ä¿®æ”¹äºŒè¿›åˆ¶æ–‡ä»¶
- é‡æ–°æ‰“åŒ… deb æ–‡ä»¶

### 4. æŸ¥çœ‹è¾“å‡ºä¿¡æ¯

é­”æ”¹å®Œæˆåï¼Œè„šæœ¬ä¼šæ˜¾ç¤ºé‡è¦ä¿¡æ¯ï¼š

```
[INFO] æ–°ç‰ˆæœ¬åï¼šduquj
[INFO] è¯·ä½¿ç”¨æ–°ç‰ˆæœ¬åï¼šduquj è¿›è¡Œè°ƒè¯•
[INFO] è¯·ä½¿ç”¨ç«¯å£ï¼š8899 è¿›è¡Œè°ƒè¯•
[INFO] æ–°ç‰ˆæœ¬ deb æ–‡ä»¶ï¼š../dist/frida_16.4.4_iphoneos-arm64_duquj_tcp.deb
```

è®°ä¸‹æ–°çš„ç‰ˆæœ¬åï¼ˆæœ¬ä¾‹ä¸­ä¸º "duquj"ï¼‰å’Œç«¯å£å·ï¼Œè¿™äº›åœ¨ä¹‹åçš„ä½¿ç”¨ä¸­ä¼šç”¨åˆ°ã€‚

### 5. å®‰è£…åˆ° iOS è®¾å¤‡

æŒ‰ç…§è„šæœ¬æä¾›çš„è¯´æ˜ï¼Œå°†é­”æ”¹åçš„ deb æ–‡ä»¶å®‰è£…åˆ° iOS è®¾å¤‡ä¸Šï¼š

```
[INFO] iPhone å®‰è£…ï¼š
[INFO] scp dist/frida_16.4.4_iphoneos-arm64_duquj_tcp.deb root@<iPhone-IP>:/var/root
[INFO] ssh root@<iPhone-IP>
[INFO] dpkg -i /var/root/frida_16.4.4_iphoneos-arm64_duquj_tcp.deb
```

æ›¿æ¢ `<iPhone-IP>` ä¸ºä½ çš„ iOS è®¾å¤‡å®é™… IP åœ°å€ã€‚

### 6. è¿æ¥å’Œä½¿ç”¨

ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤è¿æ¥åˆ°é­”æ”¹åçš„ frida-serverï¼š

```
[INFO] PC è¿æ¥ï¼š
[INFO] frida -U -f com.xxx.xxx -l
[INFO] frida -H <iPhone-IP>:8899 -f com.xxx.xxx --no-pause
```

å°† `com.xxx.xxx` æ›¿æ¢ä¸ºç›®æ ‡åº”ç”¨çš„åŒ…åï¼Œ`<iPhone-IP>` æ›¿æ¢ä¸º iOS è®¾å¤‡çš„ IP åœ°å€ã€‚

### 7. ä¿®æ”¹ frida-toolsï¼ˆå¯é€‰ï¼‰

è„šæœ¬ä¼šè¯¢é—®æ˜¯å¦è¦ä¿®æ”¹æœ¬åœ°çš„ frida-tools ä»¥é€‚é…é­”æ”¹ç‰ˆæœ¬ï¼š

```
æœ¬è„šæœ¬å°†è‡ªåŠ¨ä¿®æ”¹æœ¬åœ° frida-toolsï¼Œä»¥é€‚é…é­”æ”¹ç‰ˆæœ¬çš„ Fridaã€‚ï¼ˆè·³è¿‡ frida-tools é­”æ”¹ã€‚æŸäº›åŠŸèƒ½å¯èƒ½æ— æ³•ä½¿ç”¨ï¼Œå»ºè®®ä¿®æ”¹ï¼‰
æ‚¨æ˜¯å¦åŒæ„ï¼Ÿ(y/N)
```

å¦‚æœéœ€è¦å®Œæ•´åŠŸèƒ½ï¼Œå»ºè®®è¾“å…¥ `y` åŒæ„ä¿®æ”¹ã€‚

## æ³¨æ„äº‹é¡¹

1. æ¯æ¬¡è¿è¡Œè„šæœ¬éƒ½ä¼šç”Ÿæˆæ–°çš„é­”æ”¹åç§°ï¼Œç¡®ä¿ä½¿ç”¨æœ€æ–°ç”Ÿæˆçš„åç§°å’Œç«¯å£å·ã€‚
2. é­”æ”¹åçš„ frida-server å¯èƒ½ä¼šç»•è¿‡ä¸€äº›åŸºæœ¬çš„æ£€æµ‹ï¼Œä½†ä¸ä¿è¯èƒ½ç»•è¿‡æ‰€æœ‰æ£€æµ‹æœºåˆ¶ã€‚
3. ä½¿ç”¨é­”æ”¹ç‰ˆæœ¬å¯èƒ½ä¼šå½±å“æŸäº› Frida åŠŸèƒ½ï¼Œç‰¹åˆ«æ˜¯å¦‚æœæ²¡æœ‰ä¿®æ”¹ frida-toolsã€‚
4. ç¡®ä¿åœ¨åˆæ³•å’Œæˆæƒçš„æƒ…å†µä¸‹ä½¿ç”¨æ­¤å·¥å…·ã€‚


```

`docs/patch-tools.md`:

```md
# Frida-tools é­”æ”¹æŒ‡å—

fridare.sh è„šæœ¬æä¾›äº† `patch-tools` å‘½ä»¤ï¼Œå…è®¸æ‚¨ä¿®æ”¹ frida-tools ä»¥é€‚é…é­”æ”¹ç‰ˆæœ¬çš„ Fridaã€‚æœ¬æŒ‡å—å°†å¸®åŠ©æ‚¨ä½¿ç”¨è¿™ä¸ªåŠŸèƒ½ã€‚

## 1. ä¿®æ”¹ frida-tools

### ä½¿ç”¨é…ç½®çš„é­”æ”¹å

å¦‚æœæ‚¨å·²ç»åœ¨é…ç½®ä¸­è®¾ç½®äº† `FRIDA_NAME`ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ï¼š

```bash
./fridare.sh patch-tools name
```

è¿™å°†ä½¿ç”¨é…ç½®ä¸­çš„é­”æ”¹åæ¥ä¿®æ”¹ frida-toolsã€‚

### æŒ‡å®šæ–°çš„é­”æ”¹å

å¦‚æœæ‚¨æƒ³ä½¿ç”¨ä¸€ä¸ªä¸åŒçš„é­”æ”¹åï¼Œå¯ä»¥ç›´æ¥åœ¨å‘½ä»¤ä¸­æŒ‡å®šï¼š

```bash
./fridare.sh patch-tools name abcde
```

è¿™é‡Œçš„ `abcde` å°±æ˜¯æ‚¨æŒ‡å®šçš„æ–°é­”æ”¹åã€‚è¯·ç¡®ä¿ä½¿ç”¨æ°å¥½ 5 ä¸ªå­—æ¯ï¼ˆa-z æˆ– A-Zï¼‰ã€‚

### ä½¿ç”¨éšæœºç”Ÿæˆçš„é­”æ”¹å

å¦‚æœæ‚¨æ—¢æ²¡æœ‰åœ¨é…ç½®ä¸­è®¾ç½® `FRIDA_NAME`ï¼Œä¹Ÿæ²¡æœ‰åœ¨å‘½ä»¤ä¸­æŒ‡å®šï¼Œè„šæœ¬ä¼šéšæœºç”Ÿæˆä¸€ä¸ªé­”æ”¹åï¼š

```bash
./fridare.sh patch-tools name
```

## 2. ç¡®è®¤æ“ä½œ

æ‰§è¡Œå‘½ä»¤åï¼Œè„šæœ¬ä¼šæ˜¾ç¤ºæ‰¾åˆ°çš„ frida-tools è·¯å¾„ï¼Œå¹¶è¯¢é—®æ‚¨æ˜¯å¦ç¡®è®¤ä½¿ç”¨æ­¤è·¯å¾„ã€‚è¾“å…¥ 'y' ç¡®è®¤ï¼Œæˆ– 'n' å–æ¶ˆæ“ä½œã€‚

## 3. æŸ¥çœ‹ç»“æœ

è„šæœ¬ä¼šæ˜¾ç¤ºä¿®æ”¹è¿‡ç¨‹çš„è¯¦ç»†ä¿¡æ¯ï¼ŒåŒ…æ‹¬ï¼š

- åˆ›å»ºå¤‡ä»½æ–‡ä»¶
- ä¿®æ”¹ Python åº“æ–‡ä»¶
- æ›´æ–° core.py æ–‡ä»¶ä¸­çš„ç›¸å…³å­—ç¬¦ä¸²

## 4. æ¢å¤åŸç‰ˆ

å¦‚æœæ‚¨éœ€è¦æ¢å¤ frida-tools åˆ°åŸç‰ˆï¼Œå¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š

```bash
./fridare.sh patch-tools restore
```

è¿™å°†ä½¿ç”¨ä¹‹å‰åˆ›å»ºçš„å¤‡ä»½æ–‡ä»¶æ¥æ¢å¤åŸå§‹çš„ frida-tools æ–‡ä»¶ã€‚

## æ³¨æ„äº‹é¡¹

1. è¯·ç¡®ä¿åœ¨ä¿®æ”¹ frida-tools ä¹‹å‰å·²ç»æˆåŠŸæ„å»ºäº†é­”æ”¹ç‰ˆæœ¬çš„ Fridaã€‚
2. ä¿®æ”¹æ“ä½œä¼šåˆ›å»ºå¤‡ä»½æ–‡ä»¶ï¼Œä»¥ä¾¿äºæ—¥åæ¢å¤ã€‚
3. å¦‚æœé‡åˆ°æƒé™é—®é¢˜ï¼Œå¯èƒ½éœ€è¦ä½¿ç”¨ sudo è¿è¡Œè„šæœ¬ã€‚
4. ä¿®æ”¹åï¼Œå»ºè®®æµ‹è¯• frida-tools çš„åŠŸèƒ½ï¼Œç¡®ä¿ä¸€åˆ‡æ­£å¸¸å·¥ä½œã€‚

é€šè¿‡ä½¿ç”¨ `patch-tools` å‘½ä»¤ï¼Œæ‚¨å¯ä»¥è½»æ¾åœ°å°† frida-tools ä¸æ‚¨çš„é­”æ”¹ç‰ˆ Frida ä¿æŒåŒæ­¥ï¼Œç¡®ä¿æ•´ä¸ªå·¥å…·é“¾çš„å…¼å®¹æ€§ã€‚
```

`docs/samples/root/re.frida.server.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Label</key>
	<string>re.frida.server</string>
	<key>Program</key>
	<string>/usr/sbin/frida-server</string>
	<key>ProgramArguments</key>
	<array>
		<string>/usr/sbin/frida-server</string>
	</array>
	<key>EnvironmentVariables</key>
	<dict>
		<key>_MSSafeMode</key>
		<string>1</string>
	</dict>
	<key>UserName</key>
	<string>root</string>
	<key>POSIXSpawnType</key>
	<string>Interactive</string>
	<key>RunAtLoad</key>
	<true/>
	<key>LimitLoadToSessionType</key>
	<string>System</string>
	<key>KeepAlive</key>
	<true/>
	<key>ThrottleInterval</key>
	<integer>5</integer>
	<key>ExecuteAllowed</key>
	<true/>
</dict>
</plist>

```

`docs/samples/rootless/re.frida.server.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Label</key>
	<string>re.frida.server</string>
	<key>Program</key>
	<string>/var/jb/usr/sbin/frida-server</string>
	<key>ProgramArguments</key>
	<array>
		<string>/var/jb/usr/sbin/frida-server</string>
	</array>
	<key>UserName</key>
	<string>root</string>
	<key>POSIXSpawnType</key>
	<string>Interactive</string>
	<key>RunAtLoad</key>
	<true/>
	<key>KeepAlive</key>
	<true/>
	<key>ThrottleInterval</key>
	<integer>5</integer>
	<key>ExecuteAllowed</key>
	<true/>
</dict>
</plist>

```

`fridare.sh`:

```sh
#!/bin/bash

# Frida é­”æ”¹è„šæœ¬ï¼Œç”¨äºä¿®æ”¹ frida-server çš„åç§°å’Œç«¯å£
# ä½œè€…ï¼šsuifei@gmail.com

set -e # é‡åˆ°é”™è¯¯ç«‹å³é€€å‡º

VERSION="3.1.7"
# é»˜è®¤å€¼è®¾ç½®
DEF_FRIDA_SERVER_PORT=8899
DEF_AUTO_CONFIRM="false"

readonly COLOR_YELLOW='\033[33m'
readonly COLOR_RED='\033[31m'
readonly COLOR_PINK='\033[95m'
readonly COLOR_MAGENTA='\033[95m'
readonly COLOR_ORANGE='\033[33m'
readonly COLOR_PURPLE='\033[35m'
readonly COLOR_GREEN='\033[32m'
readonly COLOR_BLUE='\033[34m'
readonly COLOR_SKYBLUE='\033[36m'
readonly COLOR_WHITE='\033[37m'
readonly COLOR_BLACK='\033[30m'
readonly COLOR_GRAY='\033[90m'
readonly COLOR_CYAN='\033[96m'
readonly COLOR_BOLD='\033[1m'
readonly COLOR_DIM='\033[2m'
readonly COLOR_ITALIC='\033[3m'
readonly COLOR_UNDERLINE='\033[4m'
readonly COLOR_BLINK='\033[5m'
readonly COLOR_REVERSE='\033[7m'
readonly COLOR_STRIKETHROUGH='\033[9m'

readonly COLOR_RESET='\033[0m'
readonly COLOR_BG_WHITE='\033[47m'
readonly COLOR_BG_BLACK='\033[40m'
readonly COLOR_BG_RED='\033[41m'
readonly COLOR_BG_GREEN='\033[42m'
readonly COLOR_BG_YELLOW='\033[43m'
readonly COLOR_BG_BLUE='\033[44m'
readonly COLOR_BG_PURPLE='\033[45m'
readonly COLOR_BG_SKYBLUE='\033[46m'

# åˆå§‹åŒ–å˜é‡
FRIDA_VERSION=""
FRIDA_SERVER_PORT=""
CURL_PROXY=""
AUTO_CONFIRM=""
CONFIG_FILE="${HOME}/.fridare.conf"

# å…è´£å£°æ˜
DISCLAIMER="${COLOR_BG_WHITE}${COLOR_BLACK}${COLOR_BLINK} æœ¬è„šæœ¬ä»…ä¾›${COLOR_BLUE}å­¦ä¹ ä½¿ç”¨ï¼Œ${COLOR_RED}è¯·å‹¿ç”¨äºéæ³•ç”¨é€”ã€‚${COLOR_RESET}
å…è´£å£°æ˜:
1. æœ¬è„šæœ¬ä»…ä¾›å­¦ä¹ å’Œç ”ç©¶ä½¿ç”¨ï¼Œä¸å¾—ç”¨äºå•†ä¸šæˆ–éæ³•ç›®çš„ã€‚
2. ä½¿ç”¨æœ¬è„šæœ¬ä¿®æ”¹Fridaå¯èƒ½è¿åFridaçš„ä½¿ç”¨æ¡æ¬¾æˆ–ç‰ˆæƒè§„å®šã€‚
3. ç”¨æˆ·åº”è‡ªè¡Œæ‰¿æ‹…ä½¿ç”¨æœ¬è„šæœ¬çš„æ‰€æœ‰é£é™©å’Œæ³•å¾‹è´£ä»»ã€‚
4. è„šæœ¬ä½œè€…ä¸å¯¹å› ä½¿ç”¨æœ¬è„šæœ¬è€Œå¯¼è‡´çš„ä»»ä½•æŸå¤±æˆ–æ³•å¾‹é—®é¢˜è´Ÿè´£ã€‚
5. ä½¿ç”¨æœ¬è„šæœ¬å³è¡¨ç¤ºæ‚¨å·²é˜…è¯»å¹¶åŒæ„ä»¥ä¸Šå£°æ˜ã€‚

Disclaimer:
1. This script is for learning and research purposes only and may not be used 
   for commercial or illegal purposes.
2. Using this script to modify Frida may violate Frida's terms of use or 
   copyright regulations.
3. Users should bear all risks and legal responsibilities of using this script.
4. The script author is not responsible for any losses or legal issues caused 
   by the use of this script.
5. Using this script means that you have read and agree to the above statement.
"

# æ—¥å¿—å‡½æ•°
log_info() {
    echo -e "${COLOR_WHITE}[INFO] $1${COLOR_RESET}"
}

log_success() {
    echo -e "${COLOR_GREEN}[SUCC] $1${COLOR_RESET}"
}

log_warning() {
    echo -e "${COLOR_YELLOW}[WARN] $1${COLOR_RESET}"
}

log_error() {
    echo -e "${COLOR_BG_WHITE}${COLOR_RED}[ERRO] $1${COLOR_RESET}"
}

log_cinfo() {
    echo -e "$1[INFO] $2${COLOR_RESET}"
}

log_color() {
    echo -e "$1$2${COLOR_RESET}"
}

log_skyblue() {
    echo -e "${COLOR_SKYBLUE}$1${COLOR_RESET}"
}
download_with_progress() {
    local url="$1"
    local output_file="$2"
    local description="$3"
    local retry_count=3
    local temp_file="${output_file}.tmp"

    local curl_cmd="curl -L --progress-bar --fail --show-error"
    if [ -n "$CURL_PROXY" ]; then
        case "$CURL_PROXY" in
        socks4://*)
            local proxy=${CURL_PROXY#socks4://}
            curl_cmd+=" --socks4 $proxy"
            ;;
        socks4a://*)
            local proxy=${CURL_PROXY#socks4a://}
            curl_cmd+=" --socks4a $proxy"
            ;;
        socks5://*)
            local proxy=${CURL_PROXY#socks5://}
            curl_cmd+=" --socks5 $proxy"
            ;;
        socks5h://*)
            local proxy=${CURL_PROXY#socks5h://}
            curl_cmd+=" --socks5-hostname $proxy"
            ;;
        http://*)
            curl_cmd+=" --proxy $CURL_PROXY"
            ;;
        https://*)
            curl_cmd+=" --proxy $CURL_PROXY"
            ;;
        *)
            log_warning "æœªçŸ¥çš„ä»£ç†åè®®ï¼Œå°†ä½œä¸º HTTP ä»£ç†ä½¿ç”¨: $CURL_PROXY"
            curl_cmd+=" --proxy $CURL_PROXY"
            ;;
        esac
    fi

    while [ $retry_count -gt 0 ]; do
        echo -e "${COLOR_SKYBLUE}æ­£åœ¨ä¸‹è½½ $description...${COLOR_RESET}"

        if $curl_cmd "$url" -o "$temp_file" 2>&1 | tee /dev/stderr |
            sed -u 's/^[# ]*\([0-9]*\.[0-9]%\).*\([ 0-9.]*\(KiB\|MiB\|GiB\)\/s\).*$/\1\né€Ÿåº¦: \2/' |
            while IFS= read -r line; do
                if [[ $line =~ ^[0-9]+\.[0-9]% ]]; then
                    percent=${line%\%*}
                    completed=$(printf "%.0f" $percent)
                    printf "\rè¿›åº¦: [%-50s] %d%%" $(printf "=%.0s" $(seq 1 $((completed / 2)))) "$completed"
                elif [[ $line =~ ^é€Ÿåº¦: ]]; then
                    printf " %s" "$line"
                fi
            done; then
            echo # æ¢è¡Œ
            mv "$temp_file" "$output_file"
            local file_size=$(wc -c <"$output_file")
            echo -e "${COLOR_GREEN}ä¸‹è½½å®Œæˆ: $output_file (å¤§å°: $file_size å­—èŠ‚)${COLOR_RESET}"
            return 0
        else
            echo # æ¢è¡Œ
            local curl_exit_code=$?
            log_error "ä¸‹è½½å¤±è´¥: $output_file (curl exit code: $curl_exit_code)"
            if [ -f "$temp_file" ]; then
                log_error "ä¸´æ—¶æ–‡ä»¶å¤§å°: $(wc -c <"$temp_file") å­—èŠ‚"
                rm -f "$temp_file"
            fi
            retry_count=$((retry_count - 1))
            if [ $retry_count -gt 0 ]; then
                log_warning "æ£€æŸ¥ç½‘ç»œè¿æ¥..."
                if ! ping -c 1 github.com &>/dev/null; then
                    log_error "æ— æ³•è¿æ¥åˆ° github.comï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥"
                    return 1
                fi
                log_warning "ç½‘ç»œè¿æ¥æ­£å¸¸ï¼Œ5ç§’åé‡è¯•..."
                sleep 5
            fi
        fi
    done

    if [ $retry_count -eq 0 ]; then
        log_error "è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œä¸‹è½½å¤±è´¥"
        return 1
    fi
}
show_main_usage() {
    echo -e "${COLOR_SKYBLUE}Frida é‡æ‰“åŒ…å·¥å…· v${VERSION}${COLOR_RESET}"
    # è®¡ç®—å¹¶æ˜¾ç¤ºå½“å‰è„šæœ¬çš„ MD5 å€¼
    local script_path="$0"
    local script_md5=$(md5 -q "$script_path" 2>/dev/null || md5sum "$script_path" | cut -d ' ' -f 1)
    echo -e "${COLOR_GREEN}è„šæœ¬ MD5: ${COLOR_YELLOW}${script_md5}${COLOR_RESET}"
    echo -e "${COLOR_WHITE}ç”¨æ³•: $0 <å‘½ä»¤> [é€‰é¡¹]${COLOR_RESET}"
    echo
    echo -e "${COLOR_YELLOW}å‘½ä»¤:${COLOR_RESET}"
    echo -e "  ${COLOR_GREEN}q,    quickstart${COLOR_RESET}     æ˜¾ç¤ºå¿«é€Ÿå¼€å§‹æŒ‡å—"
    echo -e "  ${COLOR_GREEN}b,    build${COLOR_RESET}          é‡æ–°æ‰“åŒ… Frida"
    echo -e "  ${COLOR_GREEN}p,    patch${COLOR_RESET}          ä¿®è¡¥æŒ‡å®šçš„ Frida æ¨¡å—"
    echo -e "  ${COLOR_GREEN}pt,   patch-tools${COLOR_RESET}    ä¿®è¡¥ frida-tools æ¨¡å—"
    echo -e "  ${COLOR_GREEN}pwt,  patch-wintools${COLOR_RESET} ä¿®è¡¥ Windows frida-tools æ¨¡å—"
    echo -e "  ${COLOR_GREEN}ls,   list${COLOR_RESET}           åˆ—å‡ºå¯ç”¨çš„ Frida ç‰ˆæœ¬"
    echo -e "  ${COLOR_GREEN}dl,   download${COLOR_RESET}       ä¸‹è½½ç‰¹å®šç‰ˆæœ¬çš„ Frida"
    echo -e "  ${COLOR_GREEN}lm,   list-modules${COLOR_RESET}   åˆ—å‡ºå¯ç”¨çš„ Frida æ¨¡å—"
    echo -e "  ${COLOR_GREEN}s,    setup${COLOR_RESET}          æ£€æŸ¥å¹¶å®‰è£…ç³»ç»Ÿä¾èµ–"
    echo -e "  ${COLOR_GREEN}conf, config${COLOR_RESET}         è®¾ç½®é…ç½®é€‰é¡¹"
    echo -e "  ${COLOR_GREEN}u,    upgrade${COLOR_RESET}        æ›´æ–°é…ç½®ï¼Œæ£€æŸ¥æ–°ç‰ˆæœ¬"
    echo -e "  ${COLOR_GREEN}h,    help${COLOR_RESET}           æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯"
    echo
    echo -e "${COLOR_WHITE}è¿è¡Œ '$0 help <å‘½ä»¤>' ä»¥è·å–ç‰¹å®šå‘½ä»¤çš„æ›´å¤šä¿¡æ¯ã€‚${COLOR_RESET}"
    echo -e "${COLOR_WHITE}æ–°ç”¨æˆ·ï¼Ÿ è¿è¡Œ '$0 quickstart' è·å–å¿«é€Ÿå…¥é—¨æŒ‡å—ã€‚${COLOR_RESET}"
    echo -e "${COLOR_GRAY}    suifei@gmail.com${COLOR_RESET}"
    echo -e "${COLOR_GRAY}    https://github.com/suifei/fridare${COLOR_RESET}"
}

show_build_usage() {
    echo -e "${COLOR_SKYBLUE}ç”¨æ³•: $0 b|build [é€‰é¡¹]${COLOR_RESET}"
    echo
    echo -e "${COLOR_YELLOW}é€‰é¡¹:${COLOR_RESET}"
    echo -e "  ${COLOR_GREEN}-c clean${COLOR_RESET}                                     æ¸…ç†æ„å»ºç›®å½•"
    echo -e "  ${COLOR_GREEN}-v VERSION${COLOR_RESET}                                   æŒ‡å®š Frida ç‰ˆæœ¬"
    echo -e "  ${COLOR_GREEN}-latest${COLOR_RESET}                                      ä½¿ç”¨æœ€æ–°çš„ Frida ç‰ˆæœ¬"
    echo -e "  ${COLOR_GREEN}-p, --port PORT${COLOR_RESET}                              æŒ‡å®š Frida æœåŠ¡å™¨ç«¯å£ (é»˜è®¤: $DEF_FRIDA_SERVER_PORT)"
    echo -e "  ${COLOR_GREEN}-y, --yes${COLOR_RESET}                                    è‡ªåŠ¨å›ç­”æ˜¯ä»¥ç¡®è®¤æç¤º"
    echo -e "  ${COLOR_GREEN}-l, --local archs[arm,arm64,arm64e] FILENAME${COLOR_RESET} ä½¿ç”¨æœ¬åœ° deb æ–‡ä»¶ï¼ŒæŒ‡å®šæ„å»ºæ¶æ„"
    echo
    echo -e "${COLOR_BG_WHITE}${COLOR_RED}æ³¨æ„: -v, -latest å’Œ -l ä¸èƒ½åŒæ—¶ä½¿ç”¨${COLOR_RESET}"
    echo -e "${COLOR_BG_WHITE}${COLOR_RED}æ³¨æ„: -l ä½¿ç”¨æœ¬åœ° deb æ–‡ä»¶æ—¶ï¼Œè¯·ä½¿ç”¨å…¨è·¯å¾„ï¼Œæˆ–è€…ä¸è¦æŠŠåŸå§‹åŒ…æ”¾åˆ° build ç›®å½•ï¼Œä¼šå¯¼è‡´è·¯å¾„å†²çªã€‚${COLOR_RESET}"
    echo -e "${COLOR_WHITE}ç¤ºä¾‹:${COLOR_RESET}"
    echo -e "  $0 build -v 16.4.2"
    echo -e "  $0 build -latest"
    echo -e "  $0 build -l arm64 frida-server_16.4.2_amd64.deb"
    echo -e "  $0 build -c -l arm64 frida-server_16.4.2_amd64.deb "
    echo -e "  $0 build -c -l arm64 frida-server_16.4.2_amd64.deb" -p 8000"
    echo -e " $0 build -c -l arm64 frida-server_16.4.2_amd64.deb" -p 8000 -y"
}

show_patch_usage() {
    echo -e "${COLOR_SKYBLUE}ç”¨æ³•: $0 patch [é€‰é¡¹]${COLOR_RESET}"
    echo
    echo -e "${COLOR_YELLOW}é€‰é¡¹:${COLOR_RESET}"
    echo -e "  ${COLOR_GREEN}-m, --module NAME${COLOR_RESET}        æŒ‡å®šè¦ä¿®è¡¥çš„ Frida æ¨¡å—åç§°"
    echo -e "  ${COLOR_GREEN}-v, --version VERSION${COLOR_RESET}    æŒ‡å®š Frida ç‰ˆæœ¬"
    echo -e "  ${COLOR_GREEN}-latest${COLOR_RESET}                  ä½¿ç”¨æœ€æ–°çš„ Frida ç‰ˆæœ¬"
    echo -e "  ${COLOR_GREEN}-os OS${COLOR_RESET}                   æŒ‡å®šæ“ä½œç³»ç»Ÿ (å¯é€‰)"
    echo -e "  ${COLOR_GREEN}-arch ARCH${COLOR_RESET}               æŒ‡å®šå¤„ç†å™¨æ¶æ„ (å¯é€‰)"
    echo -e "  ${COLOR_GREEN}-o, --output DIR${COLOR_RESET}         æŒ‡å®šè¾“å‡ºç›®å½• (é»˜è®¤: ./patched_output)"
    echo -e "  ${COLOR_GREEN}-n, --no-backup${COLOR_RESET}          ä¸ä¿ç•™æºæ–‡ä»¶ (é»˜è®¤ä¿ç•™)"
    echo -e "  ${COLOR_GREEN}-a, --auto-package${COLOR_RESET}       è‡ªåŠ¨æ‰“åŒ…ä¿®è¡¥åçš„æ¨¡å— (é»˜è®¤ä¸æ‰“åŒ…)"
    echo -e "  ${COLOR_GREEN}-f, --force${COLOR_RESET}              è¦†ç›–å·²å­˜åœ¨çš„æ–‡ä»¶ (é»˜è®¤è·³è¿‡)"
    echo
    echo -e "${COLOR_WHITE}ç¤ºä¾‹:${COLOR_RESET}"
    echo -e "  $0 patch -m frida-server -v 14.2.18 -os android -arch arm64 -o ./patched -a"
    echo -e "  $0 patch -m frida-gadget -latest -os ios -arch arm64 -k -a -f"
}
show_patch_tools_usage() {
    echo -e "${COLOR_SKYBLUE}ç”¨æ³•: $0 patch-tools <æ“ä½œ> [é€‰é¡¹]${COLOR_RESET}"
    echo
    echo -e "${COLOR_YELLOW}æ“ä½œ:${COLOR_RESET}"
    echo -e "  ${COLOR_GREEN}name${COLOR_RESET}                     é…ç½® frida-tools é­”æ”¹åï¼Œ5ä¸ªï¼ˆa-zA-Zï¼‰å­—ç¬¦ï¼Œç•™ç©ºåˆ™è¯»å–é…ç½®çš„åç§°\"${COLOR_GREEN}${FRIDA_NAME}${COLOR_RESET}\"ï¼Œå¦åˆ™éšæœºç”Ÿæˆ"
    echo -e "  ${COLOR_GREEN}restore${COLOR_RESET}                  æ¢å¤ frida-tools åˆ°åŸç‰ˆ"
    echo
    echo -e "${COLOR_WHITE}ç¤ºä¾‹:${COLOR_RESET}"
    echo -e "  $0 patch-tools name abcde"
    echo -e "  $0 patch-tools restore"
}
show_patch_wintools_usage(){
    echo -e "${COLOR_SKYBLUE}ç”¨æ³•: $0 éœ€è¦åˆ°windowsç³»ç»Ÿä¸‹ï¼Œä½¿ç”¨winå­ç›®å½•å†…çš„å·¥å…·è¿›è¡Œå¤„ç†${COLOR_RESET}"
}
show_config_usage() {
    echo -e "${COLOR_SKYBLUE}ç”¨æ³•: $0 config <æ“ä½œ> <é€‰é¡¹> [<å€¼>]${COLOR_RESET}"
    echo
    echo -e "${COLOR_YELLOW}æ“ä½œ:${COLOR_RESET}"
    echo -e "  ${COLOR_GREEN}set <é€‰é¡¹> <å€¼>${COLOR_RESET}    è®¾ç½®é…ç½®"
    echo -e "  ${COLOR_GREEN}unset <é€‰é¡¹>${COLOR_RESET}       å–æ¶ˆè®¾ç½®"
    echo -e "  ${COLOR_GREEN}ls, list${COLOR_RESET}          åˆ—å‡ºæ‰€æœ‰é…ç½®"
    echo -e "  ${COLOR_GREEN}edit${COLOR_RESET}              å¯åŠ¨äº¤äº’å¼é…ç½®ç¼–è¾‘å™¨"
    echo -e "  ${COLOR_GREEN}frida-tools${COLOR_RESET}       å®‰è£… frida-tools"
    echo
    echo -e "${COLOR_YELLOW}é€‰é¡¹:${COLOR_RESET}"
    echo -e "  ${COLOR_GREEN}proxy${COLOR_RESET}              HTTP ä»£ç†"
    echo -e "  ${COLOR_GREEN}port${COLOR_RESET}               Frida æœåŠ¡å™¨ç«¯å£"
    echo -e "  ${COLOR_GREEN}frida-name${COLOR_RESET}         Frida é­”æ”¹å"
}

show_download_usage() {
    echo -e "${COLOR_SKYBLUE}ç”¨æ³•: $0 dl|download [é€‰é¡¹] <è¾“å‡ºç›®å½•>${COLOR_RESET}"
    echo
    echo -e "${COLOR_YELLOW}é€‰é¡¹:${COLOR_RESET}"
    echo -e "  ${COLOR_GREEN}-v, --version VERSION${COLOR_RESET}    æŒ‡å®šè¦ä¸‹è½½çš„ Frida ç‰ˆæœ¬"
    echo -e "  ${COLOR_GREEN}-latest${COLOR_RESET}                  ä¸‹è½½æœ€æ–°çš„ Frida ç‰ˆæœ¬"
    echo -e "  ${COLOR_GREEN}-m, --module MODULE${COLOR_RESET}      æŒ‡å®šè¦ä¸‹è½½çš„æ¨¡å—åç§°"
    echo -e "  ${COLOR_GREEN}-all${COLOR_RESET}                     ä¸‹è½½æ‰€æœ‰æ¨¡å—"
    echo -e "  ${COLOR_GREEN}--no-extract${COLOR_RESET}             ä¸è‡ªåŠ¨è§£å‹æ–‡ä»¶"
    echo -e "  ${COLOR_GREEN}-f, --force${COLOR_RESET}              è¦†ç›–å·²å­˜åœ¨çš„æ–‡ä»¶ (é»˜è®¤è·³è¿‡)"
    echo -e "  ${COLOR_GREEN}lm, list-modules${COLOR_RESET}         åˆ—å‡ºæ‰€æœ‰å¯ç”¨çš„æ¨¡å—"
    echo
    echo -e "${COLOR_WHITE}ç¤ºä¾‹:${COLOR_RESET}"
    echo -e "  $0 download -v 16.4.2 -m frida-server ./output"
    echo -e "  $0 download -latest -m frida-gadget ./output"
    echo -e "  $0 download -latest -all ./output -f"
    echo -e "  $0 download -latest -all --no-extract ./output"
}

show_setup_usage() {
    echo -e "${COLOR_SKYBLUE}ç”¨æ³•: $0 s|setup${COLOR_RESET}"
    echo
    echo -e "${COLOR_WHITE}æ£€æŸ¥å¹¶å®‰è£…ç³»ç»Ÿä¾èµ–ã€‚è¿™ä¸ªå‘½ä»¤å°†ï¼š${COLOR_RESET}"
    echo -e "  ${COLOR_GREEN}â€¢${COLOR_RESET} æ£€æŸ¥æ‰€æœ‰å¿…è¦çš„ä¾èµ–æ˜¯å¦å·²å®‰è£…"
    echo -e "  ${COLOR_GREEN}â€¢${COLOR_RESET} å¦‚æœç¼ºå°‘ä»»ä½•ä¾èµ–ï¼Œå°è¯•å®‰è£…å®ƒä»¬"
    echo -e "  ${COLOR_GREEN}â€¢${COLOR_RESET} åˆ›å»ºå¿…è¦çš„ç›®å½•ç»“æ„ï¼ˆå¦‚ build å’Œ dist ç›®å½•ï¼‰"
    echo
    echo -e "${COLOR_YELLOW}æ­¤å‘½ä»¤ä¸éœ€è¦ä»»ä½•é¢å¤–çš„å‚æ•°ã€‚${COLOR_RESET}"
}

show_upgrade_usage() {
    echo -e "${COLOR_SKYBLUE}ç”¨æ³•: $0 u|upgrade${COLOR_RESET}"
    echo
    echo -e "${COLOR_WHITE}æ›´æ–°é…ç½®å¹¶æ£€æŸ¥æ–°ç‰ˆæœ¬ã€‚è¿™ä¸ªå‘½ä»¤å°†ï¼š${COLOR_RESET}"
    echo -e "  ${COLOR_GREEN}â€¢${COLOR_RESET} æ›´æ–° FRIDA_MODULES é…ç½®"
    echo -e "  ${COLOR_GREEN}â€¢${COLOR_RESET} æ£€æŸ¥ fridare.sh è„šæœ¬çš„æ–°ç‰ˆæœ¬"
    echo -e "  ${COLOR_GREEN}â€¢${COLOR_RESET} å¦‚æœæœ‰æ–°ç‰ˆæœ¬å¯ç”¨ï¼Œæç¤ºç”¨æˆ·æ˜¯å¦è¦æ›´æ–°"
    echo
    echo -e "${COLOR_YELLOW}æ­¤å‘½ä»¤ä¸éœ€è¦ä»»ä½•é¢å¤–çš„å‚æ•°ã€‚${COLOR_RESET}"
}

show_list_usage() {
    echo -e "${COLOR_SKYBLUE}ç”¨æ³•: $0 ls|list${COLOR_RESET}"
    echo
    echo -e "${COLOR_WHITE}åˆ—å‡ºå¯ç”¨çš„ Frida ç‰ˆæœ¬ã€‚è¿™ä¸ªå‘½ä»¤å°†ï¼š${COLOR_RESET}"
    echo -e "  ${COLOR_GREEN}â€¢${COLOR_RESET} ä» GitHub è·å–æœ€æ–°çš„ Frida å‘å¸ƒç‰ˆæœ¬ä¿¡æ¯"
    echo -e "  ${COLOR_GREEN}â€¢${COLOR_RESET} æ˜¾ç¤ºæœ€è¿‘çš„ 10 ä¸ªç‰ˆæœ¬ï¼ŒåŒ…æ‹¬ç‰ˆæœ¬å·ã€å‘å¸ƒæ—¥æœŸå’Œä¸‹è½½æ¬¡æ•°"
    echo -e "  ${COLOR_GREEN}â€¢${COLOR_RESET} ä¸ºæ¯ä¸ªç‰ˆæœ¬æ˜¾ç¤ºç®€çŸ­çš„æ›´æ–°è¯´æ˜"
    echo
    echo -e "${COLOR_YELLOW}æ­¤å‘½ä»¤ä¸éœ€è¦ä»»ä½•é¢å¤–çš„å‚æ•°ã€‚${COLOR_RESET}"
}

show_list_modules_usage() {
    echo -e "${COLOR_SKYBLUE}ç”¨æ³•: $0 lm|list-modules${COLOR_RESET}"
    echo
    echo -e "${COLOR_WHITE}åˆ—å‡ºå¯ç”¨çš„ Frida æ¨¡å—ã€‚è¿™ä¸ªå‘½ä»¤å°†ï¼š${COLOR_RESET}"
    echo -e "  ${COLOR_GREEN}â€¢${COLOR_RESET} æ˜¾ç¤ºæ‰€æœ‰å¯ç”¨çš„ Frida æ¨¡å—"
    echo -e "  ${COLOR_GREEN}â€¢${COLOR_RESET} åŒ…æ‹¬æ¨¡å—åç§°ã€æ”¯æŒçš„æ“ä½œç³»ç»Ÿå’Œæ¶æ„"
    echo
    echo -e "${COLOR_YELLOW}æ­¤å‘½ä»¤ä¸éœ€è¦ä»»ä½•é¢å¤–çš„å‚æ•°ã€‚${COLOR_RESET}"
}

quick_start_guide() {
    echo -e "${COLOR_SKYBLUE}å¿«é€Ÿå¼€å§‹æŒ‡å—${COLOR_RESET}"
    echo -e "${COLOR_GREEN}1.${COLOR_RESET} è®¾ç½®ç¯å¢ƒ: $0 setup"
    echo -e "${COLOR_GREEN}2.${COLOR_RESET} æŸ¥çœ‹å¯ç”¨çš„ Frida ç‰ˆæœ¬: $0 list"
    echo -e "${COLOR_GREEN}3.${COLOR_RESET} æ„å»º Frida: $0 build -v <ç‰ˆæœ¬> æˆ– $0 build -latest"
    echo -e "${COLOR_GREEN}4.${COLOR_RESET} ä¸‹è½½ Frida æ¨¡å—: $0 download -latest -m frida-server ./output"
    echo -e "${COLOR_GREEN}5.${COLOR_RESET} ä¿®è¡¥ Frida æ¨¡å—: $0 patch -m frida-server -latest"
    echo -e "${COLOR_GREEN}6.${COLOR_RESET} é…ç½®è®¾ç½®: $0 config edit"
    echo -e "\n${COLOR_YELLOW}è¯¦ç»†ä½¿ç”¨è¯´æ˜è¯·è¿è¡Œ: $0 help <å‘½ä»¤>${COLOR_RESET}"
}
# å‡½æ•°ï¼šè§£æå‘½ä»¤è¡Œå‚æ•°
parse_arguments() {
    if [ $# -eq 0 ]; then
        show_main_usage
        exit 0
    fi

    command="$1"
    shift

    case "$command" in
    b | build)
        parse_build_args "$@"
        ;;
    p | patch)
        parse_patch_args "$@"
        ;;
    s | setup)
        setup_environment
        ;;
    conf | config)
        parse_config_args "$@"
        ;;
    ls | list)
        list_frida_versions
        ;;
    dl | download)
        parse_download_args "$@"
        ;;
    lm | list-modules)
        list_frida_modules
        ;;
    u | upgrade)
        upgrade_version=""
        if [ $# -gt 0 ]; then
            upgrade_version="$1"
        fi
        update_frida_modules "$upgrade_version"
        check_version "false"
        ;;
    q | quickstart)
        quick_start_guide
        ;;
    h | help)
        if [ $# -eq 0 ]; then
            show_main_usage
        else
            case "$1" in
            b | build) show_build_usage ;;
            p | patch) show_patch_usage ;;
            conf | config) show_config_usage ;;
            dl | download) show_download_usage ;;
            s | setup) show_setup_usage ;;
            u | upgrade) show_upgrade_usage ;;
            ls | list) show_list_usage ;;
            lm | list-modules) show_list_modules_usage ;;
            *)
                log_error "æœªçŸ¥å‘½ä»¤: $1"
                show_main_usage
                ;;
            esac
        fi
        ;;
    install)
        update_frida_modules
        is_install="true"
        check_version $is_install
        ;;
    pt | patch-tools)
        parse_patch_tools_args "$@"
        ;;
    pwt | patch-wintools)
        parse_patch_wintools_args "$@"
        ;;
    *)
        log_error "æœªçŸ¥å‘½ä»¤: $command"
        show_main_usage
        exit 1
        ;;
    esac
}
parse_patch_wintools_args(){
    show_patch_wintools_usage
}
parse_patch_tools_args() {
    local action=""
    local new_name=""

    while [[ $# -gt 0 ]]; do
        case $1 in
        name)
            action="name"
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                new_name="$2"
                shift
            fi
            shift
            ;;
        restore)
            action="restore"
            shift
            ;;
        *)
            log_error "æ— æ•ˆçš„å‚æ•°: $1"
            show_patch_tools_usage
            exit 1
            ;;
        esac
    done

    if [ -z "$action" ]; then
        log_error "å¿…é¡»æŒ‡å®š name æˆ– restore æ“ä½œ"
        show_patch_tools_usage
        exit 1
    fi

    local python_cmd=$(get_python_cmd)
    if [ -z "$python_cmd" ]; then
        log_error "æœªæ‰¾åˆ° Python è§£é‡Šå™¨"
        return 1
    fi

    local pylib_path=$($python_cmd -c "import os, frida; print(os.path.dirname(frida.__file__))" 2>/dev/null)
    if [ $? -ne 0 ]; then
        log_error "æ‰§è¡Œ Python å‘½ä»¤å¤±è´¥ï¼Œè¯·ç¡®ä¿ frida å·²æ­£ç¡®å®‰è£…"
        return 1
    fi

    log_success "æ‰¾åˆ° frida-tools è·¯å¾„: $pylib_path"
    log_skyblue "æ˜¯å¦ç¡®è®¤ä½¿ç”¨æ­¤è·¯å¾„ï¼Ÿ"
    read -p "è¯·è¾“å…¥ (y/n)" -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "æ“ä½œå·²å–æ¶ˆ"
        exit 0
    fi

    if [ "$action" = "name" ]; then
        patch_frida_tools "$new_name"
    elif [ "$action" = "restore" ]; then
        restore_frida_tools "$pylib_path"
    fi
}
get_latest_frida_version() {
    local latest_version=$(curl -s "https://api.github.com/repos/frida/frida/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    if [ -z "$latest_version" ]; then
        log_error "æ— æ³•è·å–æœ€æ–°çš„ Frida ç‰ˆæœ¬"
        exit 1
    fi
    echo "$latest_version"
}
parse_build_args() {
    FRIDA_SERVER_PORT="$DEF_FRIDA_SERVER_PORT"
    AUTO_CONFIRM="false"
    USE_LATEST="false"
    FRIDA_VERSION=""
    clean="false"
    LOCAL_DEB=""
    LOCAL_ARCH=""

    while [ "$#" -gt 0 ]; do
        case "$1" in
        -v)
            if [ "$USE_LATEST" = "true" ] || [ -n "$LOCAL_DEB" ]; then
                log_error "é”™è¯¯: -v å’Œ -latest æˆ– -l ä¸èƒ½åŒæ—¶ä½¿ç”¨" >&2
                show_build_usage
                exit 1
            fi
            FRIDA_VERSION="$2"
            shift 2
            ;;
        -latest)
            if [ -n "$FRIDA_VERSION" ] || [ -n "$LOCAL_DEB" ]; then
                log_error "é”™è¯¯: -latest å’Œ -v æˆ– -l ä¸èƒ½åŒæ—¶ä½¿ç”¨" >&2
                show_build_usage
                exit 1
            fi
            USE_LATEST="true"
            shift
            ;;
        -p | --port)
            FRIDA_SERVER_PORT="$2"
            shift 2
            ;;
        -y | --yes)
            AUTO_CONFIRM="true"
            shift
            ;;
        -c | --clean)
            clean="true"
            shift
            ;;
        -l | --local)
            if [ -n "$FRIDA_VERSION" ] || [ "$USE_LATEST" = "true" ]; then
                log_error "é”™è¯¯: -l å’Œ -v æˆ– -latest ä¸èƒ½åŒæ—¶ä½¿ç”¨" >&2
                show_build_usage
                exit 1
            fi
            if [ -z "$2" ] || [ -z "$3" ]; then
                log_error "é”™è¯¯: ä½¿ç”¨æœ¬åœ°æ–‡ä»¶æ—¶å¿…é¡»æŒ‡å®šå¤„ç†å™¨æ¶æ„ arm, arm64 æˆ– arm64e" >&2
                show_build_usage
                exit 1
            fi
            LOCAL_ARCH="$2"
            LOCAL_DEB="$3"
            shift 3
            ;;
        *)
            log_error "æ— æ•ˆé€‰é¡¹: $1" >&2
            show_build_usage
            exit 1
            ;;
        esac
    done

    if [ "$USE_LATEST" = "true" ]; then
        FRIDA_VERSION=$(get_latest_frida_version)
        log_info "ä½¿ç”¨æœ€æ–°çš„ Frida ç‰ˆæœ¬: $FRIDA_VERSION"
    elif [ -z "$FRIDA_VERSION" ] && [ -z "$LOCAL_DEB" ]; then
        log_error "é”™è¯¯: å¿…é¡»æŒ‡å®š Frida ç‰ˆæœ¬ (-v) æˆ–ä½¿ç”¨æœ€æ–°ç‰ˆæœ¬ (-latest) æˆ–ä½¿ç”¨æœ¬åœ°æ–‡ä»¶ (-l)" >&2
        show_build_usage
        exit 1
    else
        log_info "ä½¿ç”¨æŒ‡å®šçš„ Frida ç‰ˆæœ¬: $FRIDA_VERSION"
    fi

    # æ‰§è¡Œæ„å»ºé€»è¾‘
    build_frida "$clean" "$LOCAL_DEB" "$LOCAL_ARCH"
}
parse_config_args() {
    if [ $# -eq 0 ]; then
        show_config_usage
        exit 1
    fi

    action="$1"
    shift

    case "$action" in
    set)
        if [ $# -lt 2 ]; then
            log_error "set å‘½ä»¤éœ€è¦ä¸€ä¸ªé€‰é¡¹å’Œä¸€ä¸ªå€¼"
            show_config_usage
            exit 1
        fi
        option="$1"
        value="$2"
        set_config "$option" "$value"
        list_config
        ;;
    unset)
        if [ $# -lt 1 ]; then
            log_error "unset å‘½ä»¤éœ€è¦ä¸€ä¸ªé€‰é¡¹"
            show_config_usage
            exit 1
        fi
        option="$1"
        unset_config "$option"
        list_config
        ;;
    ls | list)
        list_config
        ;;
    edit)
        interactive_config_editor
        ;;
    frida-tools)
        install_frida_tools
        ;;
    *)
        log_error "æœªçŸ¥çš„é…ç½®æ“ä½œ: $action"
        show_config_usage
        exit 1
        ;;
    esac
}

set_config() {
    local option="$1"
    local value="$2"
    case "$option" in
    proxy)
        CURL_PROXY="$value"
        log_success "ä»£ç†å·²è®¾ç½®ä¸º: $CURL_PROXY"
        ;;
    port)
        FRIDA_SERVER_PORT="$value"
        log_success "Frida æœåŠ¡å™¨ç«¯å£å·²è®¾ç½®ä¸º: $FRIDA_SERVER_PORT"
        ;;
    frida-name)
        FRIDA_NAME="$value"
        log_success "Frida é­”æ”¹åå·²è®¾ç½®ä¸º: $FRIDA_NAME"
        ;;
    *)
        log_error "æœªçŸ¥çš„é…ç½®é€‰é¡¹: $option"
        show_config_usage
        return
        ;;
    esac
    update_config_file
}

unset_config() {
    local option="$1"
    case "$option" in
    proxy)
        CURL_PROXY=""
        log_success "HTTP ä»£ç†è®¾ç½®å·²å–æ¶ˆ"
        ;;
    port)
        FRIDA_SERVER_PORT="$DEF_FRIDA_SERVER_PORT"
        log_success "Frida æœåŠ¡å™¨ç«¯å£å·²é‡ç½®ä¸ºé»˜è®¤å€¼: $FRIDA_SERVER_PORT"
        ;;
    frida-name)
        FRIDA_NAME=""
        log_success "Frida é­”æ”¹åè®¾ç½®å·²å–æ¶ˆ"
        ;;
    *)
        log_error "æœªçŸ¥çš„é…ç½®é€‰é¡¹: $option"
        show_config_usage
        return
        ;;
    esac
    update_config_file
}
list_config() {
    log_info "å½“å‰é…ç½® (å­˜å‚¨åœ¨ $CONFIG_FILE)ï¼š"
    [ -n "$CURL_PROXY" ] && log_info "HTTP ä»£ç†: $CURL_PROXY"
    log_info "Frida æœåŠ¡å™¨ç«¯å£: ${FRIDA_SERVER_PORT:-$DEF_FRIDA_SERVER_PORT}"
    [ -n "$FRIDA_NAME" ] && log_info "Frida é­”æ”¹å: $FRIDA_NAME"
}
update_config_file() {
    echo "#Fridare.sh config" >"$CONFIG_FILE"
    echo "FRIDA_SERVER_PORT=${FRIDA_SERVER_PORT}" >>"$CONFIG_FILE"
    echo "CURL_PROXY=${CURL_PROXY}" >>"$CONFIG_FILE"
    echo "AUTO_CONFIRM=${AUTO_CONFIRM}" >>"$CONFIG_FILE"
    echo "FRIDA_NAME=${FRIDA_NAME}" >>"$CONFIG_FILE"
    echo "FRIDA_MODULES=(" >>"$CONFIG_FILE"
    for module in "${FRIDA_MODULES[@]}"; do
        echo "$module" >>"$CONFIG_FILE"
    done
    echo ")" >>"$CONFIG_FILE"
    log_success "é…ç½®å·²æ›´æ–°: $CONFIG_FILE"
}

interactive_config_editor() {
    while true; do
        echo -e "${COLOR_SKYBLUE}äº¤äº’å¼é…ç½®ç¼–è¾‘å™¨${COLOR_RESET}"
        echo -e "${COLOR_GREEN}1.${COLOR_RESET} ç¼–è¾‘ WEB ä»£ç† ${COLOR_GRAY}(å½“å‰: ${CURL_PROXY:-æœªè®¾ç½®})${COLOR_RESET}"
        echo -e "${COLOR_GREEN}2.${COLOR_RESET} ç¼–è¾‘ Frida æœåŠ¡å™¨ç«¯å£ ${COLOR_GRAY}(å½“å‰: ${FRIDA_SERVER_PORT:-$DEF_FRIDA_SERVER_PORT})${COLOR_RESET}"
        echo -e "${COLOR_GREEN}3.${COLOR_RESET} ç¼–è¾‘ Frida é­”æ”¹å ${COLOR_GRAY}(å½“å‰: ${FRIDA_NAME:-æœªè®¾ç½®})${COLOR_RESET}"
        echo -e "${COLOR_GREEN}4.${COLOR_RESET} é€€å‡º"
        read -p "è¯·é€‰æ‹©è¦ç¼–è¾‘çš„é¡¹ç›® (1-4): " choice
        case $choice in
        1)
            read -p "è¾“å…¥æ–°çš„ HTTP ä»£ç† (å½“å‰: ${CURL_PROXY:-æœªè®¾ç½®}): " new_proxy
            if [ -n "$new_proxy" ]; then
                set_config proxy "$new_proxy"
            else
                echo -e "${COLOR_YELLOW}ä¿æŒåŸå€¼ä¸å˜${COLOR_RESET}"
            fi
            ;;
        2)
            read -p "è¾“å…¥æ–°çš„ Frida æœåŠ¡å™¨ç«¯å£ (å½“å‰: ${FRIDA_SERVER_PORT:-$DEF_FRIDA_SERVER_PORT}): " new_port
            if [ -n "$new_port" ]; then
                set_config port "$new_port"
            else
                echo -e "${COLOR_YELLOW}ä¿æŒåŸå€¼ä¸å˜${COLOR_RESET}"
            fi
            ;;
        3)
            read -p "è¾“å…¥æ–°çš„ Frida é­”æ”¹å (å½“å‰: ${FRIDA_NAME:-æœªè®¾ç½®}): " new_name
            if [ -n "$new_name" ]; then
                # æ£€æŸ¥æ–°åç§°æ˜¯å¦æœ‰æ•ˆ
                if [[ ! "$new_name" =~ ^[a-zA-Z]{5}$ ]]; then
                    log_error "æ— æ•ˆçš„é­”æ”¹å: $new_name"
                    log_info "é­”æ”¹åå¿…é¡»æ˜¯æ°å¥½ 5 ä¸ªå­—æ¯ï¼ˆa-z æˆ– A-Zï¼‰"
                else
                    set_config frida-name "$new_name"
                fi
            else
                echo -e "${COLOR_YELLOW}ä¿æŒåŸå€¼ä¸å˜${COLOR_RESET}"
            fi
            ;;
        4)
            return
            ;;
        *)
            echo -e "${COLOR_BG_WHITE}${COLOR_RED}æ— æ•ˆçš„é€‰æ‹©${COLOR_RESET}"
            ;;
        esac
        echo
    done
}
render_markdown() {
    echo "$1" | sed -E '
        # æ ‡é¢˜
        s/^# (.+)$/\n\\033[1;4;31m\1\\033[0m\n/g;
        s/^## (.+)$/\n\\033[1;4;32m\1\\033[0m\n/g;
        s/^### (.+)$/\n\\033[1;4;33m\1\\033[0m\n/g;
        s/^#### (.+)$/\n\\033[1;4;34m\1\\033[0m\n/g;
        s/^##### (.+)$/\n\\033[1;4;35m\1\\033[0m\n/g;
        s/^###### (.+)$/\n\\033[1;4;36m\1\\033[0m\n/g;

        # ç²—ä½“å’Œæ–œä½“
        s/\*\*\*([^*]+)\*\*\*/\\033[1;3m\1\\033[0m/g;
        s/\*\*([^*]+)\*\*/\\033[1m\1\\033[0m/g;
        s/\*([^*]+)\*/\\033[3m\1\\033[0m/g;
        s/_([^_]+)_/\\033[3m\1\\033[0m/g;

        # åˆ é™¤çº¿
        s/~~([^~]+)~~/\\033[9m\1\\033[0m/g;

        # ä»£ç å—
        s/`([^`]+)`/\\033[7m\1\\033[0m/g;

        # é“¾æ¥
        s/\[([^\]]+)\]\(([^\)]+)\)/\\033[4;34m\1\\033[0m (\\033[34m\2\\033[0m)/g;

        # æ— åºåˆ—è¡¨
        s/^[*+-] (.+)$/  â€¢ \1/g;

        # æœ‰åºåˆ—è¡¨ (ä»…æ”¯æŒå‰9ä¸ªé¡¹ç›®)
        s/^([1-9])\. (.+)$/  \1. \2/g;

        # æ°´å¹³çº¿
        s/^([-*_]{3,})$/\\033[37mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\033[0m/g;

        # å¼•ç”¨
        s/^> (.+)$/  â”ƒ \\033[36m\1\\033[0m/g;
    '
}
list_frida_versions() {
    log_info "è·å– Frida æœ€æ–°ç‰ˆæœ¬åˆ—è¡¨..."

    # ä½¿ç”¨ GitHub API è·å–æœ€æ–°çš„ 10 ä¸ªå‘å¸ƒç‰ˆæœ¬
    releases=$(curl -s "https://api.github.com/repos/frida/frida/releases?per_page=10")

    if [ $? -ne 0 ]; then
        log_error "æ— æ³•ä» GitHub è·å– Frida ç‰ˆæœ¬ä¿¡æ¯"
        exit 1
    fi

    log_success "æœ€æ–°çš„ Frida ç‰ˆæœ¬ï¼š"
    log_color ${COLOR_BG_WHITE}${COLOR_BLUE} "åºå·\tç‰ˆæœ¬\t\tå‘å¸ƒæ—¥æœŸ\t\tä¸‹è½½æ¬¡æ•°"
    echo -e "$(render_markdown "---")"

    echo "$releases" | jq -r '.[] | "\(.tag_name)\t\(.published_at)\t\(.assets | length)"' |
        while IFS=$'\t' read -r version date asset_count; do
            # æ ¼å¼åŒ–æ—¥æœŸ (é€‚ç”¨äº macOS)
            formatted_date=$(date -jf "%Y-%m-%dT%H:%M:%SZ" "$date" "+%Y-%m-%d" 2>/dev/null || echo "$date")
            description=$(echo "$releases" | jq -r ".[] | select(.tag_name == \"$version\") | .body" | sed 's/\r//' | sed 's/\n\n/\n/g' | head -n 10)
            # è¾“å‡ºæ ¼å¼åŒ–çš„ç‰ˆæœ¬ä¿¡æ¯
            rendered_description=$(render_markdown "$description")
            printf "${COLOR_GREEN}%2d${COLOR_RESET}\t${COLOR_YELLOW}%-10s${COLOR_RESET}\t%s\t\t%s\n" "$((++i))" "$version" "$formatted_date" "$asset_count"
            echo -e "${rendered_description}"
            echo -e "$(render_markdown "---")"
        done

    echo -e "\n${COLOR_SKYBLUE}æç¤º: ä½¿ç”¨ 'fridare.sh build -v <ç‰ˆæœ¬å·>' æ¥æ„å»ºç‰¹å®šç‰ˆæœ¬${COLOR_RESET}"
}
FRIDA_MODULES=()

get_proxy_settings() {
    curl_proxy=$(echo $CURL_PROXY)
    if [[ -n $curl_proxy ]]; then
        echo "$curl_proxy"
    else
        echo ""
    fi
}

get_latest_release() {
    echo "è·å–æœ€æ–°çš„ Frida ç‰ˆæœ¬..."
    url="https://api.github.com/repos/frida/frida/releases/tags/$1"
    if [ "$1" = "" ] ; then
        url="https://api.github.com/repos/frida/frida/releases/latest"
    fi
    proxies=$(get_proxy_settings)

    if [[ -n $proxies ]]; then
        response=$(curl -s -H "Accept: application/json" -x "$proxies" "$url")
    else
        response=$(curl -s -H "Accept: application/json" "$url")
    fi

    echo "$response"
}

parse_filename() {
    filename=$1
    if [[ $filename =~ (frida[-_]?[a-zA-Z0-9\-]+)?[-_](v?[0-9]+\.[0-9]+\.[0-9]+)[-_]([a-zA-Z0-9\-]+)[-_]([a-zA-Z0-9_]+) ]]; then
        module_type=${BASH_REMATCH[1]}
        version=${BASH_REMATCH[2]}
        os=${BASH_REMATCH[3]}
        arch=${BASH_REMATCH[4]}

        [[ $filename == *"."* ]] && ext=${filename##*.} || ext="N/A"

        [[ $arch == "64" ]] && arch="x86_64"
        [[ $arch == *"_"* ]] && arch=${arch##*_}

        if [[ $os == "cp"* && $os == *"-"* ]] || [[ $os == *"node-"* ]] || [[ $os == *"electron-"* ]]; then
            IFS='-' read -ra os_info <<<"$os"
            os_count=${#os_info[@]}
            if [ $os_count -gt 0 ]; then
                new_os=${os_info[$os_count - 1]}
                if [ $os_count -gt 2 ]; then
                    if [[ $os == "cp"* ]]; then
                        new_module_type="frida-python-${os_info[0]}-${os_info[1]}"
                    else
                        new_module_type="frida-${os_info[0]}-${os_info[1]}"
                    fi
                    module_type=$new_module_type
                fi
                os=$new_os
            fi
        elif [[ $os == *"-"* ]]; then
            os=${os%%-*}
        fi

        [[ -z $module_type && $filename == *"deb"* ]] && module_type="frida-${os}-deb"
        [[ -z $module_type && $filename == *"gum-graft"* ]] && module_type="gum-graft" && os=${filename##*-} && arch=${filename##*-}.${ext}

        echo "$module_type:$version:$os:$arch:$ext"
    else
        echo "null"
    fi
}

generate_frida_modules() {
    release=$(get_latest_release $1)
    assets=$(echo "$release" | awk -F'"' '/"browser_download_url":/{print $4}')

    frida_modules=()
    for asset in $assets; do
        filename=$(basename "$asset")
        parsed=$(parse_filename "$filename")
        if [[ $parsed != "null" ]]; then
            IFS=':' read -r module_type version os arch ext <<<"$parsed"
            [[ $version == v* ]] && version=${version#v}
            asset_name=${filename//$version/"{VERSION}"}
            frida_modules+=("$module_type:$os:$arch:$asset_name")
        fi
    done

    printf '%s\n' "${frida_modules[@]}"
}

update_frida_modules() {
    log_info "æ­£åœ¨æ›´æ–° FRIDA_MODULES... $1"

    # ç¡®ä¿ CURL_PROXY ç¯å¢ƒå˜é‡å¯ç”¨äº Python è„šæœ¬
    local new_modules=$(generate_frida_modules "$1")

    if [ $? -ne 0 ]; then
        log_error "æ›´æ–° FRIDA_MODULES å¤±è´¥"
        return 1
    fi

    FRIDA_MODULES=()
    FRIDA_MODULES=("$new_modules")
    # æ›´æ–°é…ç½®æ–‡ä»¶ä¸­çš„ FRIDA_MODULES
    update_config_file
    log_success "FRIDA_MODULES æ›´æ–°å®Œæˆ"
    return 0
}
list_frida_modules() {
    # æ£€æŸ¥ FRIDA_MODULES æ˜¯å¦ä¸ºç©º
    if [ ${#FRIDA_MODULES[@]} -eq 0 ]; then
        log_info "FRIDA_MODULES ä¸ºç©ºï¼Œæ­£åœ¨æ›´æ–°..."
        update_frida_modules
        # é‡æ–°åŠ è½½é…ç½®æ–‡ä»¶ä»¥è·å–æ›´æ–°åçš„ FRIDA_MODULES
        source "$CONFIG_FILE"
    fi

    log_info "å¯ç”¨çš„ Frida æ¨¡å—ï¼š"
    # ä½¿ç”¨ä¸´æ—¶æ–‡ä»¶æ¥å­˜å‚¨å’Œæ’åºå”¯ä¸€çš„æ¨¡å—
    temp_file=$(mktemp)

    # æ·»åŠ è¡¨å¤´
    echo -e "æ¨¡å—åç§°\tæ“ä½œç³»ç»Ÿ\tæ¶æ„" >"$temp_file"
    echo -e "-------\t-------\t----" >>"$temp_file"

    for item in "${FRIDA_MODULES[@]}"; do
        IFS=':' read -r mod os arch filename <<<"$item"
        echo -e "$mod\t$os\t$arch" >>"$temp_file"
    done

    # ä½¿ç”¨ column å‘½ä»¤å¯¹é½è¾“å‡ºï¼Œå¹¶åˆ é™¤ä¸´æ—¶æ–‡ä»¶
    column -t -s $'\t' <"$temp_file"
    rm -f "$temp_file"
}

parse_download_args() {
    local version=""
    local module=""
    local output_dir=""
    local use_latest=false
    local download_all=false
    local no_extract=false
    local os=""
    local arch=""
    local force=false

    while [[ $# -gt 0 ]]; do
        case $1 in
        ls | list-modules)
            list_frida_modules
            exit 0
            ;;
        -v | --version)
            version="$2"
            shift 2
            ;;
        -latest)
            use_latest=true
            shift
            ;;
        -m | --module)
            module="$2"
            shift 2
            ;;
        -all)
            download_all=true
            shift
            ;;
        --no-extract)
            no_extract=true
            shift
            ;;
        -os)
            os="$2"
            shift 2
            ;;
        -arch)
            arch="$2"
            shift 2
            ;;
        -f | --force)
            force=true
            shift
            ;;
        *)
            if [[ -z "$output_dir" ]]; then
                output_dir="$1"
                shift
            else
                log_error "æ— æ•ˆçš„å‚æ•°: $1"
                show_download_usage
                exit 1
            fi
            ;;
        esac
    done

    if [[ -z "$output_dir" ]]; then
        log_error "å¿…é¡»æŒ‡å®šè¾“å‡ºç›®å½•"
        show_download_usage
        exit 1
    fi

    if [[ "$use_latest" == true && -n "$version" ]]; then
        log_error "ä¸èƒ½åŒæ—¶æŒ‡å®šç‰ˆæœ¬å’Œä½¿ç”¨æœ€æ–°ç‰ˆæœ¬"
        show_download_usage
        exit 1
    fi

    if [[ "$download_all" == true && -n "$module" ]]; then
        log_error "ä¸èƒ½åŒæ—¶æŒ‡å®šæ¨¡å—å’Œä¸‹è½½æ‰€æœ‰æ¨¡å—"
        show_download_usage
        exit 1
    fi

    # æ‰§è¡Œä¸‹è½½é€»è¾‘
    download_frida_module "$version" "$use_latest" "$module" "$download_all" "$output_dir" "$no_extract" "$os" "$arch" "$force"
}
download_frida_module() {
    local version="$1"
    local use_latest="$2"
    local module="$3"
    local download_all="$4"
    local output_dir="$5"
    local no_extract="$6"
    local os="$7"
    local arch="$8"
    local force="$9"

    # å¦‚æœä½¿ç”¨æœ€æ–°ç‰ˆæœ¬ï¼Œè·å–æœ€æ–°ç‰ˆæœ¬å·
    if [[ "$use_latest" == true ]]; then
        version=$(get_latest_frida_version)
        log_info "ä½¿ç”¨æœ€æ–°ç‰ˆæœ¬: $version"
    fi
    # å¦‚æœæŒ‡å®šäº†æ¨¡å—ï¼Œæ£€æŸ¥æ¨¡å—æ˜¯å¦å­˜åœ¨
    if [[ -n "$module" ]]; then
        local module_found=false
        for item in "${FRIDA_MODULES[@]}"; do
            IFS=':' read -r item_mod item_os item_arch filename <<<"$item"
            if [[ "$item_mod" == "$module" ]]; then
                module_found=true
                break
            fi
        done
        if [[ "$module_found" == false ]]; then
            log_error "æŒ‡å®šçš„æ¨¡å— '$module' ä¸å­˜åœ¨ã€‚ä½¿ç”¨ 'download list-modules' æŸ¥çœ‹å¯ç”¨æ¨¡å—ã€‚"
            exit 1
        fi
    fi
    # æ£€æŸ¥ 7z æ˜¯å¦å®‰è£…
    if ! command -v 7z &>/dev/null; then
        log_warning "7z æœªå®‰è£…ï¼Œå°†ä½¿ç”¨ç³»ç»Ÿé»˜è®¤è§£å‹å·¥å…·"
    fi

    # åˆ›å»ºåŸºç¡€è¾“å‡ºç›®å½•
    mkdir -p "$output_dir"

    local found_match=false
    # éå†æ¨¡å—åˆ—è¡¨
    for item in "${FRIDA_MODULES[@]}"; do
        IFS=':' read -r item_mod item_os item_arch filename <<<"$item"
        # å¦‚æœæŒ‡å®šäº†æ¨¡å—ä¸”ä¸åŒ¹é…ï¼Œåˆ™è·³è¿‡
        if [ "$item_mod" != "$module" ] || [ "$item_arch" != "$arch" ] ; then
            # å¦‚æœä¸æ˜¯ä¸‹è½½å…¨éƒ¨ï¼Œæ‰¾åˆ°åŒ¹é…é¡¹åå°±é€€å‡ºå¾ªç¯
            if [[ "$download_all" != true ]]; then
                continue
            fi
        fi
        found_match=true

        # æ›¿æ¢æ–‡ä»¶åä¸­çš„ç‰ˆæœ¬å ä½ç¬¦
        filename="${filename/\{VERSION\}/$version}"

        # åˆ›å»ºç›®å½•ç»“æ„
        local dir="${output_dir}/${version}/${item_mod}/${item_os}/${item_arch}"
        mkdir -p "$dir"

        local url="https://github.com/frida/frida/releases/download/${version}/${filename}"
        local output_file="${dir}/${filename}"

        if [[ -f "$output_file" && "$force" != true ]]; then
            log_info "æ–‡ä»¶ $filename å·²å­˜åœ¨ï¼Œè·³è¿‡ä¸‹è½½"
        else
            log_info "æ­£åœ¨ä¸‹è½½ $filename åˆ° $dir"
            download_with_progress "$url" "$output_file" "$filename"

            log_success "ä¸‹è½½ $filename å®Œæˆ"
        fi
        # è§£å‹é€»è¾‘
        if [[ "$no_extract" != true ]]; then
            if [[ "$filename" != *.deb && "$filename" != *.whl ]]; then # æ’é™¤ deb å’Œ whl æ–‡ä»¶
                if command -v 7z &>/dev/null; then
                    log_info "ä½¿ç”¨ 7z è§£å‹ $filename..."
                    7z x "$output_file" -o"$dir" -y || {
                        log_error "è§£å‹ $filename å¤±è´¥"
                        continue
                    }
                    rm -rf $output_file
                else
                    case "$filename" in
                    *.tar.xz)
                        log_info "è§£å‹ $filename..."
                        tar -xJf "$output_file" -C "$dir" || {
                            log_error "è§£å‹ $filename å¤±è´¥"
                            continue
                        }
                        rm -rf $output_file
                        ;;
                    *.xz)
                        log_info "è§£å‹ $filename..."
                        xz -d "$output_file" || {
                            log_error "è§£å‹ $filename å¤±è´¥"
                            continue
                        }
                        rm -rf $output_file
                        ;;
                    *.gz)
                        log_info "è§£å‹ $filename..."
                        gzip -d "$output_file" || {
                            log_error "è§£å‹ $filename å¤±è´¥"
                            continue
                        }
                        rm -rf $output_file
                        ;;
                    *)
                        log_warning "æ— æ³•è¯†åˆ«çš„å‹ç¼©æ ¼å¼: $filenameï¼Œè·³è¿‡è§£å‹"
                        ;;
                    esac
                fi
                log_success "è§£å‹ $filename å®Œæˆ"
            else
                log_info "è·³è¿‡è§£å‹ $filename (deb æˆ– whl æ–‡ä»¶)"
            fi
        fi

    done
    if [[ "$found_match" == false ]]; then
        log_error "æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„æ¨¡å—: $module (OS: $item_os, Arch: $item_arch)"
        return 1
    fi
    log_success "æ‰€æœ‰ä¸‹è½½å’Œè§£å‹æ“ä½œå®Œæˆ"
}
parse_patch_args() {
    local module=""
    local version=""
    local use_latest=false
    local os=""
    local arch=""
    local output_dir="${SCRIPT_WORK_DIR}/patched"
    local no_backup=false
    local auto_package=false
    local force=false

    while [[ $# -gt 0 ]]; do
        case $1 in
        -m | --module)
            module="$2"
            shift 2
            ;;
        -v | --version)
            version="$2"
            shift 2
            ;;
        -latest)
            use_latest=true
            shift
            ;;
        -os)
            os="$2"
            shift 2
            ;;
        -arch)
            arch="$2"
            shift 2
            ;;
        -o | --output)
            output_dir="$2"
            shift 2
            ;;
        -n | --no-backup)
            no_backup=true
            shift
            ;;
        -a | --auto-package)
            auto_package=true
            shift
            ;;
        -f | --force)
            force=true
            shift
            ;;
        *)
            log_error "æ— æ•ˆçš„å‚æ•°: $1"
            show_patch_usage
            exit 1
            ;;
        esac
    done

    if [ -z "$module" ]; then
        log_error "å¿…é¡»æŒ‡å®šæ¨¡å—åç§°"
        show_patch_usage
        exit 1
    fi

    if [ "$use_latest" = true ] && [ -n "$version" ]; then
        log_error "ä¸èƒ½åŒæ—¶æŒ‡å®šç‰ˆæœ¬å’Œä½¿ç”¨æœ€æ–°ç‰ˆæœ¬"
        show_patch_usage
        exit 1
    fi

    if [ "$use_latest" = false ] && [ -z "$version" ]; then
        log_error "å¿…é¡»æŒ‡å®šç‰ˆæœ¬æˆ–ä½¿ç”¨ -latest é€‰é¡¹"
        show_patch_usage
        exit 1
    fi

    # å¦‚æœä½¿ç”¨æœ€æ–°ç‰ˆæœ¬,è·å–æœ€æ–°ç‰ˆæœ¬å·
    if [ "$use_latest" = true ]; then
        version=$(get_latest_frida_version)
        log_info "ä½¿ç”¨æœ€æ–°ç‰ˆæœ¬: $version"
    fi

    # æ‰§è¡Œä¿®è¡¥é€»è¾‘
    patch_frida_module "$module" "$version" "$os" "$arch" "$output_dir" "$keep_source" "$auto_package" "$force"
}

patch_frida_module() {
    local module="$1"
    local version="$2"
    local os="$3"
    local arch="$4"
    local output_dir="$5"
    local keep_source="$6"
    local auto_package="$7"
    local force="$8"

    log_info "å‡†å¤‡ä¸‹è½½æ¨¡å—: $module, ç‰ˆæœ¬: $version, OS: $os, æ¶æ„: $arch, è¾“å‡ºç›®å½•: $output_dir, ä¿ç•™æºç : $keep_source, è‡ªåŠ¨æ‰“åŒ…: $auto_package, å¼ºåˆ¶ä¸‹è½½: $force"

    # é¦–å…ˆä¸‹è½½æ¨¡å—
    download_frida_module "$version" false "$module" false "$output_dir" false "$os" "$arch" "$force"

    # è·å–ä¸‹è½½çš„æ–‡ä»¶è·¯å¾„
    local downloaded_file=$(find "$output_dir" -name "${module}*-${os}*-${arch}*" -type f | head -n 1)
    if [ -z "$downloaded_file" ]; then
        log_error "æ— æ³•æ‰¾åˆ°ä¸‹è½½çš„æ¨¡å—æ–‡ä»¶"
        return 1
    fi

    log_info "æ­£åœ¨ä¿®è¡¥æ–‡ä»¶: $downloaded_file"

    # ç¼–è¯‘hexreplaceå·¥å…·
    (cd $SCRIPT_WORK_DIR/hexreplace && go build -o $SCRIPT_WORK_DIR/build/hexreplace && cd ..) || {
        log_error "ç¼–è¯‘ hexreplace å·¥å…·å¤±è´¥"
        return 1
    }
    chmod +x $SCRIPT_WORK_DIR/build/hexreplace

    # ç”Ÿæˆæ–°çš„Fridaåç§°ï¼ˆå¦‚æœæœªæŒ‡å®šåˆ™æç¤ºè¿›è¡Œé…ç½®ï¼š config set frida-name ï¼‰
    if [ -z "$FRIDA_NAME" ]; then
        log_error "æœªæŒ‡å®š Frida é­”æ”¹åï¼Œè¯·ä½¿ç”¨ config set frida-name å‘½ä»¤æŒ‡å®š"
        read -p "è¯·è¾“å…¥æœ¬æ¬¡æ‰€é‡‡ç”¨çš„ Frida é­”æ”¹å: " value
        if [[ "$value" =~ ^[a-zA-Z]{5}$ ]]; then
            FRIDA_NAME="$value"
            log_success "Frida é­”æ”¹åå·²è®¾ç½®ä¸º: $FRIDA_NAME"
        else
            log_error "æ— æ•ˆçš„ Frida é­”æ”¹å: $value"
            log_info "Frida é­”æ”¹åå¿…é¡»æ˜¯æ°å¥½ 5 ä¸ªå­—æ¯ï¼ˆa-z æˆ– A-Zï¼‰"
            return 1
        fi
    else
        log_info "ä½¿ç”¨æŒ‡å®šçš„ Frida é­”æ”¹å: $FRIDA_NAME"
    fi

    # ä¿®è¡¥äºŒè¿›åˆ¶æ–‡ä»¶
    local patched_file="${output_dir}/${module}_${FRIDA_NAME}"
    ($SCRIPT_WORK_DIR/build/hexreplace "$downloaded_file" "$FRIDA_NAME" "$patched_file") || {
        log_error "ä¿®æ”¹ ${module} äºŒè¿›åˆ¶å¤±è´¥"
        return 1
    }

    # è®¾ç½®æƒé™
    sudo chmod +x "$patched_file"
    # sudo chown root:wheel "$patched_file"

    log_success "æ¨¡å—ä¿®è¡¥å®Œæˆ: $patched_file"

    # å¤„ç†æºæ–‡ä»¶
    if [ "$no_backup" = true ]; then
        rm -f "$downloaded_file"
        log_info "å·²åˆ é™¤æºæ–‡ä»¶"
    fi

    # è‡ªåŠ¨æ‰“åŒ…
    if [ "$auto_package" = true ]; then
        log_info "æ­£åœ¨è‡ªåŠ¨æ‰“åŒ…ä¿®è¡¥åçš„æ¨¡å—..."

        # è·å–åŸå§‹æ–‡ä»¶çš„æ‰©å±•å
        local original_extension="${downloaded_file##*.}"
        local packed_file="${patched_file}.${original_extension}"

        # ä½¿ç”¨7zè¿›è¡Œå‹ç¼©
        if command -v 7z &>/dev/null; then
            case "$original_extension" in
            xz | gz | zip | tar | bz2 | 7z)
                7z a -t"$original_extension" "$packed_file" "$patched_file" >/dev/null || {
                    log_error "ä½¿ç”¨ 7z å‹ç¼©å¤±è´¥"
                    return 1
                }
                ;;
            *)
                # å¯¹äºæœªçŸ¥æ ¼å¼,ä½¿ç”¨gzipå‹ç¼©
                gzip -c "$patched_file" >"${patched_file}.gz" || {
                    log_error "ä½¿ç”¨ gzip å‹ç¼©å¤±è´¥"
                    return 1
                }
                packed_file="${patched_file}.gz"
                log_warning "æœªçŸ¥çš„å‹ç¼©æ ¼å¼: ${original_extension}, ä½¿ç”¨ gzip å‹ç¼©"
                ;;
            esac
        else
            # å¦‚æœ7zä¸å¯ç”¨,é€€å›åˆ°ä½¿ç”¨gzip
            gzip -c "$patched_file" >"${patched_file}.gz" || {
                log_error "ä½¿ç”¨ gzip å‹ç¼©å¤±è´¥"
                return 1
            }
            packed_file="${patched_file}.gz"
            log_warning "7z ä¸å¯ç”¨,ä½¿ç”¨ gzip å‹ç¼©"
        fi

        if [ "$packed_file" != "$patched_file" ]; then
            log_success "æ¨¡å—å·²æ‰“åŒ…: $packed_file"
            # å¦‚æœä¸ä¿ç•™æºæ–‡ä»¶ï¼Œåˆ é™¤æœªå‹ç¼©çš„ä¿®è¡¥æ–‡ä»¶
            if [ "$no_backup" = true ]; then
                rm -f "$patched_file"
                log_info "å·²åˆ é™¤æœªå‹ç¼©çš„ä¿®è¡¥æ–‡ä»¶"
            fi
        fi
    fi

    return 0
}
# ç”¨æˆ·ç¡®è®¤å‡½æ•°
confirm_execution() {
    if [ "$AUTO_CONFIRM" = "true" ]; then
        log_warning "è‡ªåŠ¨ç¡®è®¤æ¨¡å¼ï¼šç”¨æˆ·å·²åŒæ„å…è´£å£°æ˜å’Œsudoæƒé™ä½¿ç”¨ã€‚"
        return 0
    fi

    log_color $COLOR_PURPLE "$DISCLAIMER"
    log_warning "æœ¬è„šæœ¬å°†ä¼šè¦æ±‚ä½¿ç”¨sudoæƒé™ä»¥ä¿®æ”¹æ–‡ä»¶æƒé™ã€‚"

    read -p "æ‚¨æ˜¯å¦åŒæ„ä»¥ä¸Šå…è´£å£°æ˜å¹¶å…è®¸ä½¿ç”¨sudoæƒé™ï¼Ÿ(y/N) " response
    case "$response" in
    [yY][eE][sS] | [yY])
        return 0
        ;;
    *)
        log_info "ç”¨æˆ·ä¸åŒæ„ï¼Œæ“ä½œå·²å–æ¶ˆ"
        exit 0
        ;;
    esac
}
confirm_modify_frida_tools() {
    if [ "$AUTO_CONFIRM" = "true" ]; then
        log_warning "è‡ªåŠ¨ç¡®è®¤æ¨¡å¼ï¼šç”¨æˆ·å·²åŒæ„è‡ªåŠ¨ä¿®æ”¹æœ¬åœ° frida-toolsã€‚"
        return 0
    fi
    log_color $COLOR_PURPLE "æœ¬è„šæœ¬å°†è‡ªåŠ¨ä¿®æ”¹æœ¬åœ° frida-toolsï¼Œä»¥é€‚é…é­”æ”¹ç‰ˆæœ¬çš„ Fridaã€‚ï¼ˆè·³è¿‡ frida-tools é­”æ”¹ã€‚æŸäº›åŠŸèƒ½å¯èƒ½æ— æ³•ä½¿ç”¨ï¼Œå»ºè®®ä¿®æ”¹ï¼‰"
    read -p "æ‚¨æ˜¯å¦åŒæ„ï¼Ÿ(y/N) " response
    case "$response" in
    [yY][eE][sS] | [yY])
        return 0
        ;;
    *)
        log_info "ç”¨æˆ·ä¸åŒæ„ï¼Œæ“ä½œå·²å–æ¶ˆ"
        return 1
        ;;
    esac
}
check_dependencies() {
    local missing_tools=()
    local tools=("xcode-select" "brew" "git" "jq" "dpkg-deb" "go" "python3" "7z" "curl" "xz" "gzip")

    for tool in "${tools[@]}"; do
        if ! command -v $tool &>/dev/null; then
            missing_tools+=("$tool")
            log_warning "$COLOR_YELLOW$tool$COLOR_RESET ${COLOR_PURPLE}æœªæ‰¾åˆ°"
        else
            log_success "$COLOR_YELLOW$tool$COLOR_RESET ${COLOR_SKYBLUE}å·²å®‰è£…"
        fi
    done

    # æ£€æŸ¥ Frida å·¥å…·
    if ! check_frida_tool; then
        missing_tools+=("frida-tools")
        log_warning "${COLOR_YELLOW}frida-tools${COLOR_RESET} ${COLOR_PURPLE}æœªæ‰¾åˆ°"
    else
        log_success "${COLOR_YELLOW}frida-tools$COLOR_RESET ${COLOR_SKYBLUE}å·²å®‰è£…"
    fi

    if [ ${#missing_tools[@]} -eq 0 ]; then
        log_success "æ‰€æœ‰ä¾èµ–å·²å®‰è£…"
        return 0
    else
        log_warning "ä»¥ä¸‹å·¥å…·æœªå®‰è£…: ${missing_tools[*]}"
        return 1
    fi

}

install_dependencies() {
    log_warning "æ­£åœ¨å®‰è£…ç¼ºå¤±çš„ä¾èµ–..."
    confirm_execution

    check_and_install_tool "xcode-select" "xcode-select --install"
    check_and_install_tool "brew" "curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh | bash"
    check_and_install_tool "git" "brew install git"
    check_and_install_tool "jq" "brew install jq"
    check_and_install_tool "dpkg-deb" "brew install dpkg"
    check_and_install_tool "go" "brew install go"
    check_and_install_tool "python3" "brew install python3"
    check_and_install_tool "7z" "brew install p7zip"
    check_and_install_tool "curl" "brew install curl"
    check_and_install_tool "xz" "brew install xz"
    check_and_install_tool "gzip" "brew install gzip"

    install_frida_tools

    log_success "ä¾èµ–å®‰è£…å®Œæˆ"
}

setup_environment() {
    log_info "æ£€æŸ¥ç³»ç»Ÿä¾èµ–..."
    if ! check_dependencies; then
        install_dependencies
    fi

    log_success "ç¯å¢ƒè®¾ç½®å®Œæˆ"
}
check_frida_tool() {
    if command -v frida-ps >/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}
install_frida_tools() {
    log_info "æ­£åœ¨å®‰è£… frida-tools..."

    local pip_commands=("pip" "pip3")
    for pip_cmd in "${pip_commands[@]}"; do
        if command -v "$pip_cmd" >/dev/null 2>&1; then
            if $pip_cmd install --user frida-tools --force-reinstall; then
                log_success "frida-tools å®‰è£…æˆåŠŸ"
                return 0
            else
                log_error "ä½¿ç”¨ $pip_cmd å®‰è£… frida-tools å¤±è´¥"
            fi
        fi
    done

    log_error "æ— æ³•å®‰è£… frida-toolsã€‚è¯·ç¡®ä¿ pip å·²æ­£ç¡®å®‰è£…å¹¶ä¸”ç½‘ç»œè¿æ¥æ­£å¸¸ã€‚"
    return 1
}
check_and_install_tool() {
    local tool=$1
    local install_cmd=$2

    if ! command -v $tool &>/dev/null; then
        log_warning "$tool æœªæ‰¾åˆ°ï¼Œæ­£åœ¨å®‰è£…..."
        eval $install_cmd || {
            log_error "å®‰è£… $tool å¤±è´¥"
            exit 1
        }
    else
        log_success "$tool å·²å®‰è£…"
    fi
}
# å‡½æ•°ï¼šä¸‹è½½ Frida
download_frida() {
    local arch=$1
    local fridaver=$2
    local clean=$3
    local filename="frida_${fridaver}_iphoneos-${arch}.deb"
    local output="${SCRIPT_WORK_DIR}/build/$filename"
    # å¦‚æœæœ¬åœ°æ–‡ä»¶å­˜åœ¨
    if [ -f "$output" ]; then
        if [ "$clean" = "true" ]; then
            log_warning "æ¸…ç†æ—§æ–‡ä»¶: $output"
            rm -f $output
        fi
    fi

    if [ ! -f "$output" ]; then
        local url="https://github.com/frida/frida/releases/download/${fridaver}/${filename}"
        echo $url
        download_with_progress "$url" "$output"
    else
        log_warning "æœ¬åœ°å­˜åœ¨ $filename"
    fi

    log_success "ä¸‹è½½ $filename å®Œæˆ"
}
# æ–°å¢å‡½æ•°ï¼šåˆ é™¤ç›®å½•å†…çš„æ‰€æœ‰ .DS_Store æ–‡ä»¶
remove_ds_store() {
    local dir=$1
    log_success "æ­£åœ¨åˆ é™¤ $dir ä¸­çš„ .DS_Store æ–‡ä»¶..."
    find "$dir" -name ".DS_Store" -type f -delete
    log_info ".DS_Store æ–‡ä»¶åˆ é™¤å®Œæˆ"
}

modify_launch_daemon() {
    local build=$1
    local arch=$2
    local plist

    if [ "$arch" = "arm64" ]; then
        plist="${build}/var/jb/Library/LaunchDaemons/re.frida.server.plist"
    else
        plist="${build}/Library/LaunchDaemons/re.frida.server.plist"
    fi

    if [ ! -f "$plist" ]; then
        log_error "é”™è¯¯: plist æ–‡ä»¶ä¸å­˜åœ¨: $plist"
        return 1
    fi

    log_success "æ­£åœ¨ä¿®æ”¹ plist æ–‡ä»¶: $plist"
    log_info "FRIDA_NAME: $FRIDA_NAME"
    log_info "FRIDA_SERVER_PORT: $FRIDA_SERVER_PORT"

    # æ£€æŸ¥å˜é‡æ˜¯å¦ä¸ºç©º
    if [ -z "$FRIDA_NAME" ] || [ -z "$FRIDA_SERVER_PORT" ]; then
        log_error "é”™è¯¯: FRIDA_NAME æˆ– FRIDA_SERVER_PORT ä¸ºç©º"
        return 1
    fi

    # ä½¿ç”¨ -e é€‰é¡¹ä¸ºæ¯ä¸ªæ›¿æ¢æ“ä½œåˆ›å»ºå•ç‹¬çš„ sed å‘½ä»¤
    sed -i '' \
        -e 's/re\.frida\.server/re.'"${FRIDA_NAME}"'.server/g' \
        -e 's/frida-server/'"${FRIDA_NAME}"'/g' \
        -e 's@</array>@\t<string>-l</string>\n\t\t<string>0.0.0.0:'"${FRIDA_SERVER_PORT}"'</string>\n\t</array>@g' \
        "$plist"

    if [ $? -ne 0 ]; then
        log_error "é”™è¯¯: sed å‘½ä»¤æ‰§è¡Œå¤±è´¥"
        return 1
    fi

    log_success "plist æ–‡ä»¶ä¿®æ”¹å®Œæˆ"

    # æ”¶åˆ°ä¸€ä¸ª arm64e çš„ç‰ˆæœ¬ï¼Œå¯¹å®ƒåšäº†é€‚é…ï¼š
    # æ£€æŸ¥ usr/sbin/frida-server-wrapper å’Œ usr/sbin/frida-server.ent
    # å­˜åœ¨åˆ™æ›´å ${FRIDA_NAME}-server-wrapper å’Œ usr/sbin/${FRIDA_NAME}-server.ent
    # æ‰“å¼€ ${FRIDA_NAME}-server-wrapper ï¼Œè¿›è¡Œæ›¿æ¢
    # exec /usr/sbin/frida-server $@ æ›¿æ¢ä¸º exec /usr/sbin/${FRIDA_NAME}-server $@
    # æ‰“å¼€ usr/sbin/${FRIDA_NAME}-server.entï¼Œè¿›è¡Œæ›¿æ¢
    # <string>re.frida.Server</string> æ›¿æ¢ä¸º <string>re.${FRIDA_NAME}.Server</string>
    # ä¿®æ”¹2ä¸ªæ–‡ä»¶æƒé™
    # local frida_server_wrapper_file="${build}/usr/sbin/frida-server-wrapper"
    # local new_frida_server_wrapper_file="${build}/usr/sbin/${FRIDA_NAME}-server-wrapper"
    # local frida_server_ent_file="${build}/usr/sbin/frida-server.ent"
    # local new_frida_server_ent_file="${build}/usr/sbin/${FRIDA_NAME}-server.ent"

    # if [ -f "$frida_server_wrapper_file" ]; then
    #     log_success "æ­£åœ¨ä¿®æ”¹ frida-server-wrapper æ–‡ä»¶: $frida_server_wrapper_file"
    #     sed -i '' 's/exec \/usr\/sbin\/frida-server/exec \/usr\/sbin\/'"${FRIDA_NAME}"'-server/g' "$frida_server_wrapper_file"
    #     if [ $? -ne 0 ]; then
    #         log_error "é”™è¯¯: ä¿®æ”¹ frida-server-wrapper æ–‡ä»¶å¤±è´¥"
    #         return 1
    #     fi
    #     log_success "frida-server-wrapper æ–‡ä»¶ä¿®æ”¹å®Œæˆ"
    #     mv "$frida_server_wrapper_file" "$new_frida_server_wrapper_file"
    #     if [ $? -ne 0 ]; then
    #         log_error "é”™è¯¯: é‡å‘½å frida-server-wrapper æ–‡ä»¶å¤±è´¥"
    #         return 1
    #     fi
    #     log_success "frida-server-wrapper æ–‡ä»¶å·²é‡å‘½åä¸º: $new_frida_server_wrapper_file"
    #     sudo chown root:wheel $new_frida_server_wrapper_file
    #     if [ $? -ne 0 ]; then
    #         log_error "é”™è¯¯: ä¿®æ”¹ frida-server-wrapper æ–‡ä»¶æƒé™å¤±è´¥"
    #         return 1
    #     fi
    #     log_success "frida-server-wrapper æ–‡ä»¶æƒé™ä¿®æ”¹å®Œæˆ"
    # else
    #     log_warning "è­¦å‘Š: frida-server-wrapper æ–‡ä»¶ä¸å­˜åœ¨: $frida_server_wrapper_file"
    # fi

    # if [ -f "$frida_server_ent_file" ]; then
    #     log_success "æ­£åœ¨ä¿®æ”¹ frida-server.ent æ–‡ä»¶: $frida_server_ent_file"
    #     sed -i '' 's/<string>re\.frida\.Server/<string>re.'"${FRIDA_NAME}"'.Server/g' "$frida_server_ent_file"
    #     if [ $? -ne 0 ]; then
    #         log_error "é”™è¯¯: ä¿®æ”¹ frida-server.ent æ–‡ä»¶å¤±è´¥"
    #         return 1
    #     fi
    #     log_success "frida-server.ent æ–‡ä»¶ä¿®æ”¹å®Œæˆ"
    #     mv "$frida_server_ent_file" "$new_frida_server_ent_file"
    #     if [ $? -ne 0 ]; then
    #         log_error "é”™è¯¯: é‡å‘½å frida-server.ent æ–‡ä»¶å¤±è´¥"
    #         return 1
    #     fi
    #     log_success "frida-server.ent æ–‡ä»¶å·²é‡å‘½åä¸º: $new_frida_server_ent_file"
    #     sudo chown root:wheel $new_frida_server_ent_file
    #     if [ $? -ne 0 ]; then
    #         log_error "é”™è¯¯: ä¿®æ”¹ frida-server.ent æ–‡ä»¶æƒé™å¤±è´¥"
    #         return 1
    #     fi
    #     log_success "frida-server.ent æ–‡ä»¶æƒé™ä¿®æ”¹å®Œæˆ"
    # else
    #     log_warning "è­¦å‘Š: frida-server.ent æ–‡ä»¶ä¸å­˜åœ¨: $frida_server_ent_file"
    # fi

    # log_success "frida-server-wrapper å’Œ frida-server.ent æ–‡ä»¶ä¿®æ”¹å®Œæˆ"

    # é‡å‘½å plist æ–‡ä»¶
    local new_plist
    if [ "$arch" = "arm64" ]; then
        new_plist="${build}/var/jb/Library/LaunchDaemons/re.${FRIDA_NAME}.server.plist"
    else
        new_plist="${build}/Library/LaunchDaemons/re.${FRIDA_NAME}.server.plist"
    fi

    mv "$plist" "$new_plist"
    sudo chown root:wheel $new_plist

    if [ $? -ne 0 ]; then
        log_error "é”™è¯¯: é‡å‘½å plist æ–‡ä»¶å¤±è´¥"
        return 1
    fi

    log_success "plist æ–‡ä»¶å·²é‡å‘½åä¸º: $new_plist"
}

modify_debian_files() {
    local build=$1
    local arch=$2
    local debian_dir

    debian_dir="${build}/DEBIAN"

    log_success "æ­£åœ¨ä¿®æ”¹ DEBIAN æ–‡ä»¶å¤¹ä¸­çš„æ–‡ä»¶: $debian_dir"
    log_info "FRIDA_NAME: $FRIDA_NAME"

    # æ£€æŸ¥å˜é‡æ˜¯å¦ä¸ºç©º
    if [ -z "$FRIDA_NAME" ]; then
        log_error "é”™è¯¯: FRIDA_NAME ä¸ºç©º"
        return 1
    fi

    # ä¿®æ”¹ control æ–‡ä»¶
    local control_file="${debian_dir}/control"
    if [ -f "$control_file" ]; then
        log_info "ä¿®æ”¹ control æ–‡ä»¶"
        sed -i '' 's/Package: re\.frida\.server/Package: re.'"${FRIDA_NAME}"'.server/g' "$control_file"
        if [ $? -ne 0 ]; then
            log_error "é”™è¯¯: ä¿®æ”¹ control æ–‡ä»¶å¤±è´¥"
            return 1
        fi
    else
        log_warning "è­¦å‘Š: control æ–‡ä»¶ä¸å­˜åœ¨: $control_file"
    fi
    sudo chown root:wheel $control_file

    # ä¿®æ”¹ extrainst_ æ–‡ä»¶
    local extrainst_file="${debian_dir}/extrainst_"
    if [ -f "$extrainst_file" ]; then
        log_info "ä¿®æ”¹ extrainst_ æ–‡ä»¶"
        if [ "$arch" = "arm64" ]; then
            sed -i '' 's@launchcfg=/var/jb/Library/LaunchDaemons/re\.frida\.server\.plist@launchcfg=/var/jb/Library/LaunchDaemons/re.'"${FRIDA_NAME}"'.server.plist@g' "$extrainst_file"
        else
            sed -i '' 's@launchcfg=/Library/LaunchDaemons/re\.frida\.server\.plist@launchcfg=/Library/LaunchDaemons/re.'"${FRIDA_NAME}"'.server.plist@g' "$extrainst_file"
        fi
        if [ $? -ne 0 ]; then
            log_error "é”™è¯¯: ä¿®æ”¹ extrainst_ æ–‡ä»¶å¤±è´¥"
            return 1
        fi
    else
        log_warning "è­¦å‘Š: extrainst_ æ–‡ä»¶ä¸å­˜åœ¨: $extrainst_file"
    fi
    sudo chown root:wheel $extrainst_file

    # ä¿®æ”¹ prerm æ–‡ä»¶
    local prerm_file="${debian_dir}/prerm"
    if [ -f "$prerm_file" ]; then
        log_info "ä¿®æ”¹ prerm æ–‡ä»¶"
        if [ "$arch" = "arm64" ]; then
            sed -i '' 's@launchctl unload /var/jb/Library/LaunchDaemons/re\.frida\.server\.plist@launchctl unload /var/jb/Library/LaunchDaemons/re.'"${FRIDA_NAME}"'.server.plist@g' "$prerm_file"
        else
            sed -i '' 's@launchctl unload /Library/LaunchDaemons/re\.frida\.server\.plist@launchctl unload /Library/LaunchDaemons/re.'"${FRIDA_NAME}"'.server.plist@g' "$prerm_file"
        fi
        if [ $? -ne 0 ]; then
            log_error "é”™è¯¯: ä¿®æ”¹ prerm æ–‡ä»¶å¤±è´¥"
            return 1
        fi
    else
        log_warning "è­¦å‘Š: prerm æ–‡ä»¶ä¸å­˜åœ¨: $prerm_file"
    fi
    sudo chown root:wheel $prerm_file

    log_success "DEBIAN æ–‡ä»¶å¤¹ä¸­çš„æ–‡ä»¶ä¿®æ”¹å®Œæˆ"
}

modify_binary() {
    local build=$1
    local arch=$2
    local frida_server_path
    local new_path
    local frida_dylib_file
    local new_dylib_file
    local dylib_folder
    local new_dylib_folder

    if [ "$arch" = "arm64" ]; then
        frida_server_path="${build}/var/jb/usr/sbin/frida-server"
        new_path="${build}/var/jb/usr/sbin/${FRIDA_NAME}"
        frida_dylib_file="${build}/var/jb/usr/lib/frida/frida-agent.dylib"
        new_dylib_file="${build}/var/jb/usr/lib/frida/${FRIDA_NAME}-agent.dylib"
        dylib_folder="${build}/var/jb/usr/lib/frida"
        new_dylib_folder="${build}/var/jb/usr/lib/${FRIDA_NAME}"
    else
        frida_server_path="${build}/usr/sbin/frida-server"
        new_path="${build}/usr/sbin/${FRIDA_NAME}"
        frida_dylib_file="${build}/usr/lib/frida/frida-agent.dylib"
        new_dylib_file="${build}/usr/lib/frida/${FRIDA_NAME}-agent.dylib"
        dylib_folder="${build}/usr/lib/frida"
        new_dylib_folder="${build}/usr/lib/${FRIDA_NAME}"
    fi
    log_success "æ­£åœ¨ä¿®æ”¹äºŒè¿›åˆ¶æ–‡ä»¶: $frida_server_path"
    if [ ! -f "$frida_server_path" ]; then
        log_error "é”™è¯¯: frida-server æ–‡ä»¶ä¸å­˜åœ¨äºè·¯å¾„: $frida_server_path"
        return 1
    fi

    (cd $SCRIPT_WORK_DIR/hexreplace && go build -o $SCRIPT_WORK_DIR/build/hexreplace && cd ..) || {
        log_error "ç¼–è¯‘ hexreplace å·¥å…·å¤±è´¥"
        return 1
    }
    chmod +x $SCRIPT_WORK_DIR/build/hexreplace
    ($SCRIPT_WORK_DIR/build/hexreplace "$frida_server_path" "$FRIDA_NAME" "$new_path") || {
        log_error "ä¿®æ”¹ frida-server äºŒè¿›åˆ¶å¤±è´¥"
        return 1
    }
    rm -rf $frida_server_path
    # ç¡®ä¿æ–°æ–‡ä»¶æœ‰æ‰§è¡Œæƒé™
    sudo chmod +x $new_path
    sudo chown root:wheel $new_path

    ($SCRIPT_WORK_DIR/build/hexreplace $frida_dylib_file $FRIDA_NAME $new_dylib_file) || {
        log_error "ä¿®æ”¹ frida-agent.dylib å¤±è´¥"
        return 1
    }
    rm -rf $frida_dylib_file
    # ç¡®ä¿æ–°æ–‡ä»¶æœ‰æ‰§è¡Œæƒé™
    sudo chmod +x $new_dylib_file
    sudo chown root:wheel $new_dylib_file

    # ä¿®æ”¹dylibç›®å½•
    if ! mv "$dylib_folder" "$new_dylib_folder"; then
        log_error "é‡å‘½å dylib ç›®å½•å¤±è´¥"
        return 1
    fi
    log_success "äºŒè¿›åˆ¶æ–‡ä»¶ä¿®æ”¹å®Œæˆ"
    return 0
}

# å‡½æ•°ï¼šé‡æ–°æ‰“åŒ… deb æ–‡ä»¶
repackage_deb() {
    local build=$1
    local output_filename=$2
    # åœ¨æ‰“åŒ…ä¹‹å‰åˆ é™¤ .DS_Store æ–‡ä»¶
    remove_ds_store "$build"
    # æ‰“åŒ…
    dpkg-deb -b "$build" "$output_filename" || {
        log_error "æ‰“åŒ… $output_filename å¤±è´¥"
        exit 1
    }

    rm -rf "$build"

    log_success "é‡æ–°æ‰“åŒ… $output_filename å®Œæˆ"
}

find_frida_path() {
    local pip_commands=("pip3" "pip")
    local frida_path=""

    for pip_cmd in "${pip_commands[@]}"; do
        if command -v "$pip_cmd" >/dev/null 2>&1; then
            frida_path=$("$pip_cmd" show frida 2>/dev/null | grep "Location:" | cut -d " " -f 2-)
            if [ -n "$frida_path" ]; then
                frida_path="${frida_path}/frida"
                if [ -d "$frida_path" ]; then
                    echo "$frida_path"
                    return 0
                fi
            fi
        fi
    done

    # å¦‚æœé€šè¿‡ pip æ— æ³•æ‰¾åˆ°ï¼Œå°è¯•å¸¸è§è·¯å¾„
    local frida_paths=(
        "/usr/local/lib/python*/site-packages/frida"
        "/usr/lib/python*/site-packages/frida"
        "$HOME/.local/lib/python*/site-packages/frida"
        "$HOME/Library/Python/*/lib/python/site-packages/frida"
        "$HOME/anaconda*/lib/python*/site-packages/frida"
        "/opt/homebrew/lib/python*/site-packages/frida"
        "/Library/Frameworks/Python.framework/Versions/*/lib/python*/site-packages/frida"
        "/Applications/Frida.app/Contents/Resources/lib/python*/site-packages/frida"
    )

    for path_pattern in "${frida_paths[@]}"; do
        for path in $path_pattern; do
            if [ -d "$path" ]; then
                echo "$path"
                return 0
            fi
        done
    done

    log_error "æ— æ³•æ‰¾åˆ° frida-tools è·¯å¾„ã€‚è¯·ç¡®ä¿ frida-tools å·²æ­£ç¡®å®‰è£…ã€‚"
    return 1
}
generate_random_name() {
    cat /dev/urandom | env LC_CTYPE=C tr -dc 'a-z' | fold -w 5 | head -n 1
}
patch_frida_tools() {
    local local_frida_name="$1"

    log_info "å¼€å§‹ç»™ frida-tools æ‰“è¡¥ä¸..."

    # å¦‚æœæœªæä¾›åç§°ï¼Œå°è¯•ä½¿ç”¨é…ç½®çš„åç§°æˆ–ç”Ÿæˆéšæœºåç§°
    if [ -z "$local_frida_name" ]; then
        if [ -n "$FRIDA_NAME" ]; then
            local_frida_name="$FRIDA_NAME"
            log_info "ä½¿ç”¨é…ç½®çš„é­”æ”¹å: $local_frida_name"
        else
            local_frida_name=$(generate_random_name)
            log_info "ç”Ÿæˆéšæœºé­”æ”¹å: $local_frida_name"
        fi
    fi

    # æ£€æŸ¥æ–°åç§°æ˜¯å¦æœ‰æ•ˆ
    if [[ ! "$local_frida_name" =~ ^[a-zA-Z]{5}$ ]]; then
        log_error "æ— æ•ˆçš„é­”æ”¹å: $local_frida_name"
        log_info "é­”æ”¹åå¿…é¡»æ˜¯æ°å¥½ 5 ä¸ªå­—æ¯ï¼ˆa-z æˆ– A-Zï¼‰"
        return 1
    fi

    modify_frida_tools "$local_frida_name"
}

restore_frida_tools() {
    log_info "å¼€å§‹æ¢å¤ frida-tools åˆ°åŸç‰ˆ..."
    local python_cmd=$(get_python_cmd)
    if [ -z "$python_cmd" ]; then
        log_error "æœªæ‰¾åˆ° Python è§£é‡Šå™¨"
        return 1
    fi

    local frida_tools_path=$($python_cmd -c "import os, frida; print(os.path.dirname(frida.__file__))" 2>/dev/null)
    if [ $? -ne 0 ]; then
        log_error "æ‰§è¡Œ Python å‘½ä»¤å¤±è´¥ï¼Œè¯·ç¡®ä¿ frida å·²æ­£ç¡®å®‰è£…"
        return 1
    fi
    # æ¢å¤ Python åº“æ–‡ä»¶
    local pylib_backup=$(ls $frida_tools_path/*.so.fridare 2>/dev/null)
    local pylib=$(ls $frida_tools_path/*.so 2>/dev/null)

    if [ -z "$pylib_backup" ]; then
        log_warning "æœªæ‰¾åˆ° Python åº“æ–‡ä»¶çš„å¤‡ä»½"
        return 1
    else
        log_info "æ­£åœ¨æ¢å¤ Python åº“æ–‡ä»¶: $pylib"
        mv "$pylib_backup" "$pylib"
    fi

    # æ¢å¤ core.py æ–‡ä»¶
    local core_py="$frida_tools_path/core.py"
    if [ -f "$core_py.fridare" ]; then
        log_info "æ­£åœ¨æ¢å¤ core.py æ–‡ä»¶: $core_py"
        mv "$core_py.fridare" "$core_py"
    else
        log_warning "æœªæ‰¾åˆ° core.py æ–‡ä»¶çš„å¤‡ä»½"
    fi

    rm -rf "$frida_tools_path/__pycache__"
    log_success "frida-tools å·²æ¢å¤åˆ°åŸç‰ˆ"
}
# å‡½æ•°ï¼šä¿®è®¢frida-tools
modify_core_py() {
    frida_name=$1
    path=$2
    p="${path}/core.py"
    b="${p}.fridare"
    if [ ! -f "$b" ]; then
        echo "Creating backup: $b"
        cp "$p" "$b"
    else
        echo "Backup already exists: $b"
    fi
    replaced=0
    while IFS= read -r line; do
        # echo "Processing line: $line" >&2  # Debug output

        if [[ $line =~ [\'\"](([^\'\"]+):rpc)[\'\"] ]]; then
            old=${BASH_REMATCH[2]}
            new=$(printf "%-5s" "${frida_name:0:5}")
            new_line=${line//$old:rpc/$new:rpc}
            if [ "$new_line" != "$line" ]; then
                echo "Replaced \"$old:rpc\" with \"$new:rpc\"" >&2
                line=$new_line
                ((replaced++))
            fi
        fi

        echo "$line"
    done < "$p" > "${p}.tmp"
    if [ $replaced -gt 0 ]; then
        mv "${p}.tmp" "$p"
        echo "Replacement complete. Made $replaced replacements."
    else
        echo "No matching pattern found, no changes made"
        rm "${p}.tmp"
    fi
}
modify_frida_tools() {
    local local_frida_name="$1"

    local python_cmd=$(get_python_cmd)
    if [ -z "$python_cmd" ]; then
        log_error "æœªæ‰¾åˆ° Python è§£é‡Šå™¨"
        return 1
    fi

    local pylib_path=$($python_cmd -c "import os, frida; print(os.path.dirname(frida.__file__))" 2>/dev/null)
    if [ $? -ne 0 ]; then
        log_error "æ‰§è¡Œ Python å‘½ä»¤å¤±è´¥ï¼Œè¯·ç¡®ä¿ frida å·²æ­£ç¡®å®‰è£…"
        return 1
    fi
    local pylib=$(ls $pylib_path/*.so 2>/dev/null)
    if [ -z "$pylib" ]; then
        log_error "æœªæ‰¾åˆ° frida Python åº“"
        return 1
    fi

    if [ ! -f "$pylib.fridare" ]; then
        cp "$pylib" "$pylib.fridare"
        log_info "åˆ›å»ºå¤‡ä»½: $pylib.fridare"
    else
        log_info "å¤‡ä»½å·²å­˜åœ¨: $pylib.fridare"
    fi

    log_info "Python åº“æ–‡ä»¶: $pylib"
    log_info "Frida åç§°: $local_frida_name"

    $SCRIPT_WORK_DIR/build/hexreplace "$pylib" "$local_frida_name" "test.so" || {
        log_error "ä¿®æ”¹ frida Python åº“å¤±è´¥"
        return 1
    }

    rm -f "$pylib"
    rm -rf "$pylib_path/__pycache__"
    mv test.so "$pylib"
    chmod 755 "$pylib"

    modify_core_py "$local_frida_name" "$pylib_path"

    log_success "frida-tools ä¿®æ”¹å®Œæˆ"
    return 0
}
get_absolute_path() {
    local relative_path="$1"
    local absolute_path=""

    # å¦‚æœæ˜¯ç›¸å¯¹è·¯å¾„ï¼Œæ·»åŠ å½“å‰ç›®å½•
    if [[ "$relative_path" != /* ]]; then
        relative_path="$PWD/$relative_path"
    fi

    # è§„èŒƒåŒ–è·¯å¾„
    local oldIFS="$IFS"
    IFS='/'
    local path_parts=($relative_path)
    local new_path=()

    for part in "${path_parts[@]}"; do
        case "$part" in
        "" | ".") ;;
        "..")
            if [ ${#new_path[@]} -ne 0 ]; then
                unset 'new_path[${#new_path[@]}-1]'
            fi
            ;;
        *)
            new_path+=("$part")
            ;;
        esac
    done

    IFS="$oldIFS"
    absolute_path="/${new_path[*]}"
    absolute_path="${absolute_path// //}"

    echo "$absolute_path"
}
move_file() {
    local source_file="$1"
    local target_dir="$2"
    mv "$OUTPUT_FIsource_fileLENAME" "$target_dir" 2>&1 | grep -v "are identical" || true
}
build_frida() {
    local clean=$1
    local local_deb=$2
    local local_arch=$3
    # æ£€æŸ¥å¹¶è®¾ç½® Frida ç‰ˆæœ¬
    local use_local=false
    if [ -n "$local_deb" ]; then
        # é¦–å…ˆæ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if [ ! -f "$local_deb" ]; then
            log_error "æœ¬åœ°æ–‡ä»¶ä¸å­˜åœ¨: $local_deb"
            exit 1
        fi
        # è·å– local_deb çš„ç»å¯¹è·¯å¾„
        if command -v realpath >/dev/null 2>&1; then
            local_deb=$(realpath "$local_deb")
        else
            # å¦‚æœ realpath ä¸å¯ç”¨ï¼Œä½¿ç”¨è‡ªå®šä¹‰å‡½æ•°
            local_deb=$(get_absolute_path "$local_deb")
        fi
        if [ ! -f "$local_deb" ]; then
            log_error "æœ¬åœ°æ–‡ä»¶ä¸å­˜åœ¨: $local_deb"
            exit 1
        fi
        log_info "ä½¿ç”¨æœ¬åœ°æ–‡ä»¶: $local_deb"
        use_local=true
    else
        if [ -z "$FRIDA_VERSION" ]; then
            log_error "æœªæŒ‡å®š Frida ç‰ˆæœ¬"
            show_build_usage
            exit 1
        fi
    fi

    log_info "ä½¿ç”¨ Frida æœåŠ¡å™¨ç«¯å£: $FRIDA_SERVER_PORT"
    [ -n "$CURL_PROXY" ] && log_info "HTTP ä»£ç†ï¼š${CURL_PROXY}"
    [ "$AUTO_CONFIRM" = "true" ] && log_info "è‡ªåŠ¨ç¡®è®¤ï¼šå·²å¯ç”¨"

    log_warning "æœŸé—´å¯èƒ½ä¼šè¦æ±‚è¾“å…¥ sudo å¯†ç ï¼Œç”¨äºä¿®æ”¹æ–‡ä»¶æƒé™"
    log_color "${COLOR_GREEN}æ„å»ºç›®å½•ï¼š${COLOR_RESET} $SCRIPT_WORK_DIR/build"
    log_color "${COLOR_GREEN}è¾“å‡ºç›®å½•ï¼š${COLOR_RESET} $SCRIPT_WORK_DIR/dist"

    # ç¡®è®¤æ‰§è¡Œ
    if [ "$AUTO_CONFIRM" != "true" ]; then
        confirm_execution
    fi

    log_info "å¼€å§‹æ„å»º Frida..."
    # æ£€æŸ¥å¹¶å®‰è£… dpkg

    if ! check_dependencies; then
        log_error "ä¾èµ–æ£€æŸ¥å¤±è´¥"
        log_success "è¯·ä½¿ç”¨ './$0 setup' å‘½ä»¤å®‰è£…ä¾èµ–"
        exit 1
    fi

    # å¦‚æœ FRIDA_NAME ä¸ºç©ºï¼Œç”Ÿæˆä¸€ä¸ªæ–°çš„
    if [ -z "$FRIDA_NAME" ]; then
        FRIDA_NAME=$(generate_random_name)
        if [[ ! "$FRIDA_NAME" =~ ^[a-z]{5}$ ]]; then
            log_error "æ— æ³•ç”Ÿæˆæœ‰æ•ˆçš„ Frida é­”æ”¹å"
            exit 1
        fi
    fi

    local architectures=("arm" "arm64")
    for arch in "${architectures[@]}"; do
        local input_file
        if [ "$use_local" = "true" ]; then
            input_file="$local_deb"
            OUTPUT_FILENAME="${local_deb}_${FRIDA_NAME}_tcp.deb"
            if [ "$local_arch" = "arm64e" ]; then
                arch="arm"
            fi
            log_info "ä½¿ç”¨æœ¬åœ°æ–‡ä»¶: $input_file"
        else
            input_file="${SCRIPT_WORK_DIR}/build/frida_${FRIDA_VERSION}_iphoneos-${arch}.deb"
            OUTPUT_FILENAME="${SCRIPT_WORK_DIR}/build/frida_${FRIDA_VERSION}_iphoneos-${arch}_${FRIDA_NAME}_tcp.deb"
            download_frida $arch $FRIDA_VERSION $clean
        fi

        BUILD_DIR="${SCRIPT_WORK_DIR}/build/frida_build_${arch}"
        rm -rf "$BUILD_DIR"

        dpkg-deb -R "${input_file}" "${BUILD_DIR}"

        log_cinfo $COLOR_GREEN "æ­£åœ¨ä¿®æ”¹ Frida ${COLOR_PURPLE}${FRIDA_VERSION}${COLOR_RESET} ç‰ˆæœ¬ (${COLOR_SKYBLUE}${arch}${COLOR_RESET})"
        modify_launch_daemon "$BUILD_DIR" "$arch"
        modify_debian_files "$BUILD_DIR" "$arch"
        modify_binary "$BUILD_DIR" "$arch"

        repackage_deb "$BUILD_DIR" "$OUTPUT_FILENAME"

        mkdir -p $SCRIPT_WORK_DIR/dist

        mv "$OUTPUT_FILENAME" $SCRIPT_WORK_DIR/dist/ 2>&1 | grep -v "are identical" || true

        log_success "Frida ${FRIDA_VERSION} ç‰ˆæœ¬ (${arch}) ä¿®æ”¹å®Œæˆ"

        log_info "æ–°ç‰ˆæœ¬åï¼š${FRIDA_NAME}"
        log_info "è¯·ä½¿ç”¨æ–°ç‰ˆæœ¬åï¼š${FRIDA_NAME} è¿›è¡Œè°ƒè¯•"
        log_info "è¯·ä½¿ç”¨ç«¯å£ï¼š${FRIDA_SERVER_PORT} è¿›è¡Œè°ƒè¯•"
        log_info "æ–°ç‰ˆæœ¬ deb æ–‡ä»¶ï¼š$SCRIPT_WORK_DIR/dist/${OUTPUT_FILENAME}"
        log_info "-------------------------------------------------"
        log_info "iPhone å®‰è£…ï¼š"
        log_info "scp dist/${OUTPUT_FILENAME} root@<iPhone-IP>:/var/root"
        log_info "ssh root@<iPhone-IP>"
        log_info "dpkg -i /var/root/${OUTPUT_FILENAME}"
        log_info "PC è¿æ¥ï¼š"
        log_info "frida -U -f com.xxx.xxx -l"
        log_info "frida -H <iPhone-IP>:${FRIDA_SERVER_PORT} -f com.xxx.xxx --no-pause"
        log_info "-------------------------------------------------"

        if [ -n "$local_deb" ]; then
            return 0 # å¦‚æœæ˜¯æœ¬åœ°æ–‡ä»¶ï¼Œåªå¤„ç†ä¸€æ¬¡
        fi
    done

    # ç¡®è®¤æ‰§è¡Œ
    if [ "$AUTO_CONFIRM" != "true" ]; then
        # ä¸åŒæ„è¿”å›0
        if ! confirm_modify_frida_tools; then
            log_success "frida-tools æœªä¿®æ”¹ã€‚"
            exit 0
        fi
    fi
    modify_frida_tools "$FRIDA_NAME"

}
initialize_config() {
    SCRIPT_WORK_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    log_color $COLOR_GREEN "å·¥ä½œç›®å½•ï¼š$SCRIPT_WORK_DIR"
    if [ ! -f "$CONFIG_FILE" ]; then
        echo "# Fridare Configuration File" >"$CONFIG_FILE"
        echo "FRIDA_SERVER_PORT=$DEF_FRIDA_SERVER_PORT" >>"$CONFIG_FILE"
        echo "CURL_PROXY=" >>"$CONFIG_FILE"
        echo "AUTO_CONFIRM=$DEF_AUTO_CONFIRM" >>"$CONFIG_FILE"
        echo "FRIDA_NAME=" >>"$CONFIG_FILE"
        echo "FRIDA_MODULES=(" >>"$CONFIG_FILE"
        echo ")" >>"$CONFIG_FILE"
    fi

    # æ£€æŸ¥å¹¶åˆ›å»º build å’Œ dist ç›®å½•
    if [ ! -d "${SCRIPT_WORK_DIR}/build" ]; then
        mkdir -p ${SCRIPT_WORK_DIR}/build
    fi
    if [ ! -d "${SCRIPT_WORK_DIR}/dist" ]; then
        mkdir -p ${SCRIPT_WORK_DIR}/dist
    fi

}
is_conda_env() {
    # æ£€æŸ¥ CONDA_PREFIX ç¯å¢ƒå˜é‡æ˜¯å¦å­˜åœ¨
    [ -n "$CONDA_PREFIX" ]
}
get_python_cmd() {
    if is_conda_env; then
        echo "$CONDA_PREFIX/bin/python"
    else
        for cmd in python3 python; do
            if command -v $cmd >/dev/null 2>&1; then
                echo $cmd
                return
            fi
        done
    fi
}
#åˆ›å»ºäº†ä¸€ä¸ªåå°è¿›ç¨‹ï¼Œå…¶ç›®çš„æ˜¯ä¿æŒ sudo æƒé™æ´»è·ƒ
sudo_keep_alive() {
    while true; do
        sudo -n true
        sleep 60
        kill -0 "$$" || exit
    done 2>/dev/null &
    SUDO_KEEP_ALIVE_PID=$!
}

# åœ¨è„šæœ¬ç»“æŸæ—¶æ¸…ç†
cleanup() {
    if [ -n "$SUDO_KEEP_ALIVE_PID" ]; then
        kill $SUDO_KEEP_ALIVE_PID
    fi
}
get_golang_info() {
    if command -v go >/dev/null 2>&1; then
        local go_version=$(go version 2>&1)
        local go_path=$(go env GOPATH 2>/dev/null)
        echo "$go_version:$go_path"
    else
        echo "Not installed"
    fi
}
log_environment_info() {
    log_skyblue "ç¯å¢ƒä¿¡æ¯:"

    # Python ç¯å¢ƒä¿¡æ¯
    if is_conda_env; then
        log_skyblue "  Conda ç¯å¢ƒ: $CONDA_PREFIX"
    else
        log_skyblue "  ä½¿ç”¨ç³»ç»Ÿ Python ç¯å¢ƒ"
    fi
    local python_cmd=$(get_python_cmd)
    log_skyblue "  Python è·¯å¾„: $python_cmd"
    log_skyblue "  Python ç‰ˆæœ¬: $($python_cmd --version 2>&1)"

    # Frida ä¿¡æ¯
    local frida_version=$($python_cmd -c 'import frida; print(frida.__version__)' 2>/dev/null)
    if [ -n "$frida_version" ]; then
        log_skyblue "  Frida ç‰ˆæœ¬: $frida_version"
        log_skyblue "  Frida è·¯å¾„: $($python_cmd -c 'import os; import frida; print(os.path.dirname(frida.__file__))' 2>/dev/null)"
    else
        log_warning "  Frida æœªå®‰è£…æˆ–æ— æ³•æ£€æµ‹"
    fi

    # Golang ç¯å¢ƒä¿¡æ¯
    local golang_info=$(get_golang_info)
    if [ "$golang_info" != "Not installed" ]; then
        IFS=':' read -r go_version go_path <<<"$golang_info"
        log_skyblue "  Golang ç‰ˆæœ¬: $go_version"
        log_skyblue "  GOPATH: $go_path"
    else
        log_warning "  Golang æœªå®‰è£…æˆ–æ— æ³•æ£€æµ‹"
    fi

    # æ“ä½œç³»ç»Ÿä¿¡æ¯
    log_skyblue "  æ“ä½œç³»ç»Ÿ: $(uname -s)"
    log_skyblue "  ç³»ç»Ÿç‰ˆæœ¬: $(uname -r)"

    echo # ç©ºè¡Œï¼Œä¸ºäº†æ›´å¥½çš„å¯è¯»æ€§
}

log_config_info() {
    log_skyblue "é…ç½®ä¿¡æ¯:"
    log_skyblue "  FRIDA_SERVER_PORT: $FRIDA_SERVER_PORT"
    log_skyblue "  CURL_PROXY: $CURL_PROXY"
    log_skyblue "  AUTO_CONFIRM: $AUTO_CONFIRM"
    log_skyblue "  FRIDA_NAME: $FRIDA_NAME"
    echo # ç©ºè¡Œï¼Œä¸ºäº†æ›´å¥½çš„å¯è¯»æ€§
}

version_compare() {
    local v1="$1"
    local v2="$2"

    # Remove 'v' if present
    v1="${v1#v}"
    v2="${v2#v}"

    # Split the versions into arrays
    IFS='.' read -r -a ver1 <<<"$v1"
    IFS='.' read -r -a ver2 <<<"$v2"

    # Compare each part of the version
    for ((i = 0; i < ${#ver1[@]} || i < ${#ver2[@]}; i++)); do
        local num1=$((${ver1[i]:-0}))
        local num2=$((${ver2[i]:-0}))
        if ((num1 > num2)); then
            echo ">" # v1 is greater
            return
        elif ((num1 < num2)); then
            echo "<" # v2 is greater
            return
        fi
    done
    echo "=" # versions are equal
}

check_version() {
    local is_install=$1
    local current_version="$VERSION"
    local repo_owner="suifei"
    local repo_name="fridare"
    local next="false"

    log_info "æ£€æŸ¥ç‰ˆæœ¬æ›´æ–°..."
    local releases_info=$(curl -s "https://api.github.com/repos/$repo_owner/$repo_name/releases")

    if [ -z "$releases_info" ]; then
        log_error "æ— æ³•è·å–ç‰ˆæœ¬ä¿¡æ¯"
        return 1
    fi

    # è·å–æ‰€æœ‰éé¢„å‘å¸ƒç‰ˆæœ¬ï¼Œå¹¶æŒ‰ç‰ˆæœ¬å·æ’åº
    local versions=$(echo "$releases_info" | jq -r '.[] | select(.prerelease == false) | .tag_name' | sort -rV)
    local latest_version=$(echo "$versions" | head -n1)

    if [ -z "$latest_version" ]; then
        log_error "æ— æ³•è·å–æœ€æ–°ç‰ˆæœ¬ä¿¡æ¯"
        return 1
    fi

    local download_url=$(echo "$releases_info" | jq -r ".[] | select(.tag_name == \"$latest_version\") | .zipball_url")

    if [ -z "$download_url" ]; then
        log_error "æ— æ³•è·å–ä¸‹è½½é“¾æ¥"
        return 1
    fi

    current_version="${current_version#v}"
    latest_version="${latest_version#v}"

    result=$(version_compare "$current_version" "$latest_version")

    if [ "$result" = "=" ]; then
        log_success "å½“å‰ç‰ˆæœ¬ (${current_version}) å·²æ˜¯æœ€æ–°æ­£å¼ç‰ˆæœ¬"
    elif [ "$result" = ">" ]; then
        log_success "å½“å‰ç‰ˆæœ¬ (${current_version}) æ¯”æœ€æ–°æ­£å¼ç‰ˆæœ¬ (${latest_version}) æ›´æ–°"
    elif [ "$result" = "<" ]; then
        log_warning "å‘ç°æ–°çš„æ­£å¼ç‰ˆæœ¬ï¼š${latest_version}ï¼ˆå½“å‰ç‰ˆæœ¬ï¼š${current_version}ï¼‰"
        echo "æ›´æ–°è¯´æ˜ï¼š"
        echo "$releases_info" | jq -r ".[] | select(.tag_name == \"$latest_version\") | .body" | sed 's/^/  /'

        read -p "æ˜¯å¦æ›´æ–°åˆ°æœ€æ–°æ­£å¼ç‰ˆæœ¬ï¼Ÿ(y/n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log_info "å–æ¶ˆæ›´æ–°"
            return 0
        fi
        next="true"
    else
        log_error "ç‰ˆæœ¬æ¯”è¾ƒå‡ºé”™"
    fi
    if [ "$next" = "true" ] || [ "$is_install" = "true" ]; then

        # ä¸‹è½½å’Œæ›´æ–°è¿‡ç¨‹ä¿æŒä¸å˜
        log_info "å¼€å§‹ä¸‹è½½æœ€æ–°æ­£å¼ç‰ˆæœ¬..."
        local temp_dir=$(mktemp -d)
        local zip_file="$temp_dir/fridare-$latest_version.zip"
        local extract_dir="$temp_dir/extracted_files"

        download_with_progress "$download_url" "$zip_file" "Fridare ç‰ˆæœ¬ ${latest_version}"

        log_info "è§£å‹æ–‡ä»¶..."
        if ! unzip -q "$zip_file" -d "$extract_dir"; then
            log_error "è§£å‹å¤±è´¥"
            rm -rf "$temp_dir"
            return 1
        fi

        log_info "æ›´æ–°æœ¬åœ°æ–‡ä»¶..."
        local script_dir="$(dirname "$0")"
        local install_dir="${script_dir}/fridare"

        if [ "$is_install" = "true" ]; then
            # åˆ›å»ºç›®å½•
            mkdir -p "$install_dir"
            script_dir="$install_dir"
            log_success "æ–‡ä»¶å¤¹ \"${script_dir}\" å·²åˆ›å»ºï¼Œè¯·å°†æ­¤æ–‡ä»¶å¤¹æ·»åŠ åˆ° PATH ç¯å¢ƒå˜é‡ä¸­"
            log_skyblue "  export PATH=\$PATH:\"${script_dir}\""
            # åŠ å…¥ .bashrc æˆ–è€… .zshrc çš„æç¤º
            if [ -f "$HOME/.bashrc" ]; then
                log_skyblue "  echo \"export PATH=\$PATH:\\\"${script_dir}\\\"\" >> ~/.bashrc"
            fi
            if [ -f "$HOME/.zshrc" ]; then
                log_skyblue "  echo \"export PATH=\$PATH:\\\"${script_dir}\\\"\" >> ~/.zshrc"
            fi
        fi

        # æ‰¾åˆ°è§£å‹åçš„ç›®å½•ï¼ˆåº”è¯¥åªæœ‰ä¸€ä¸ªï¼‰
        local update_dir=$(find "$extract_dir" -maxdepth 1 -type d | grep -v "^$extract_dir$" | head -n 1)

        if [ -z "$update_dir" ]; then
            log_error "æ— æ³•æ‰¾åˆ°æ›´æ–°æ–‡ä»¶ç›®å½•"
            rm -rf "$temp_dir"
            return 1
        fi

        log_info "æ­£åœ¨ä» $update_dir å¤åˆ¶æ–‡ä»¶åˆ° $script_dir"

        # å¤åˆ¶æ–°æ–‡ä»¶åˆ°è„šæœ¬ç›®å½•
        if ! cp -R "$update_dir/"* "$script_dir/"; then
            log_error "å¤åˆ¶æ–°æ–‡ä»¶å¤±è´¥"
            rm -rf "$temp_dir"
            return 1
        fi

        # åˆ é™¤æ—§æ–‡ä»¶
        find "$script_dir" -type f | while read file; do
            if [ ! -e "$update_dir/${file#$script_dir/}" ]; then
                rm "$file"
            fi
        done

        # è°ƒæ•´æƒé™
        chmod -R 755 "$script_dir"
        # åˆ é™¤.git
        rm -rf "$script_dir/.git"

        # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        rm -rf "$temp_dir"

        log_success "æ›´æ–°å®Œæˆï¼Œæ–°ç‰ˆæœ¬ï¼š${latest_version}"
        log_info "è¯·é‡æ–°è¿è¡Œè„šæœ¬ä»¥ä½¿ç”¨æ–°ç‰ˆæœ¬"
        exit 0
    fi
}

# ä¸»å‡½æ•°
main() {
    initialize_config
    log_environment_info
    # æ£€æŸ¥æ˜¯å¦æœ‰ -y å‚æ•°
    if [[ "$*" == *"-y"* || "$*" == *"--yes"* ]]; then
        sudo -v || {
            log_error "æ— æ³•è·å– sudo æƒé™"
            exit 1
        }
        sudo_keep_alive
        trap cleanup EXIT
    fi
    # æ£€æŸ¥æ˜¯å¦æ˜¯é¦–æ¬¡è¿è¡Œ
    if [ ! -f "$CONFIG_FILE" ]; then
        echo -e "${COLOR_YELLOW}æ¬¢è¿ä½¿ç”¨ Fridareï¼è¿™ä¼¼ä¹æ˜¯æ‚¨ç¬¬ä¸€æ¬¡è¿è¡Œæœ¬å·¥å…·ã€‚${COLOR_RESET}"
        echo -e "${COLOR_YELLOW}ä»¥ä¸‹æ˜¯å¿«é€Ÿå¼€å§‹æŒ‡å—ï¼š${COLOR_RESET}\n"
        quick_start_guide
        echo -e "\n${COLOR_YELLOW}æŒ‰å›è½¦é”®ç»§ç»­...${COLOR_RESET}"
        read
    fi
    # è¯»å–é…ç½®æ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    if [ -f "$CONFIG_FILE" ]; then
        FRIDA_MODULES=()
        source "$CONFIG_FILE"
    fi

    # å°†é…ç½®æ–‡ä»¶ä¸­çš„å€¼èµ‹ç»™è„šæœ¬å˜é‡
    FRIDA_SERVER_PORT=${FRIDA_SERVER_PORT:-$DEF_FRIDA_SERVER_PORT}
    CURL_PROXY=${CURL_PROXY:-""}
    AUTO_CONFIRM=${AUTO_CONFIRM:-$DEF_AUTO_CONFIRM}
    FRIDA_NAME=${FRIDA_NAME:-""}

    log_config_info

    # è§£æå‚æ•°
    parse_arguments "$@"
}
# æ‰§è¡Œä¸»å‡½æ•°
main "$@"

```

`hexreplace/Makefile`:

```
.PHONY: test build

help:
	@echo "make test - Run the tests"
	@echo "make build - Build the project"

build:
	@go build 

test:
	@go run main.go ../build/test.so abcde _test.so
```

`hexreplace/go.mod`:

```mod
module github.com/suifei/fridare/hexreplace

go 1.22.3

```

`hexreplace/main.go`:

```go
/*
hexreplace is a tool to patch binary file with hex string.
Usage: hexreplace <file path> <frida new name>
Example: hexreplace /Users/xxx/Desktop/frida-ios-dump/FridaGadget.dylib frida
Author: suifei@gmail.com
Github: https://github.com/suifei/fridare/tree/master/hexreplace
Version: 2.2

changelog:
- 2.2:
	- Added support for ELF and PE file formats
	- Added functions for describing architectures: describeMachOArch, describeELFArch, describePEArch
	- Modified buildReplacements function to support different executable formats
	- Unified file detection and opening logic into detectAndOpenFile function
	- Refactored handleSignleArchitecture and handleMultipleArchitectures functions to handle different file formats
	
- 2.1:
	- Refactored the Replacements structure to support multiple sections:
	- Added a new 'SectionName' field to the Replacements struct
	- Changed 'Replacements' to contain an 'Items' slice of Replacement structs
	- Modified the buildReplacements function to return a slice of Replacements, allowing for multiple section definitions
	- Updated handleSignleArchitecture and patchArchitecture functions to process multiple sections:
	- Now iterates through all defined sections in the Replacements slice
	- Applies replacements to each specified section individually
	- Adjusted the replaceInSection function to accept a slice of Replacement structs
	- Improved error handling and logging:
	- Added more detailed error messages for each section processing step
	- Included section names in log messages for better traceability
	- Enhanced code flexibility and extensibility:
	- Made it easier to add new sections for replacement in the future
	- Improved code organization by grouping replacement rules by section

- 2.0: support multiple architectures, add more ARM and ARM64 subtypes, add more replacements, macho.File.Section() returns a pointer to macho.Section, add more error handling
- 1.0: initial version
*/
package main

import (
	"debug/elf"
	"debug/macho"
	"debug/pe"
	"encoding/binary"
	"fmt"
	"io"
	"os"
	"strings"
)

type ExecutableFormat int

const (
	PE ExecutableFormat = iota
	MachO
	ELF
)

type Replacement struct {
	Old []byte
	New []byte
}

type Replacements struct {
	ExecutableFormat ExecutableFormat
	SectionName      string
	Items            []*Replacement
}

func describeArch(file interface{}, format ExecutableFormat) string {
	switch format {
	case MachO:
		switch f := file.(type) {
		case *macho.File:
			return describeMachOArch(f)
		case *macho.FatFile:
			return "MachO Fat Binary (Multiple Architectures)"
		}
	case ELF:
		if f, ok := file.(*elf.File); ok {
			return describeELFArch(f)
		}
	case PE:
		if f, ok := file.(*pe.File); ok {
			return describePEArch(f)
		}
	}
	return "Unknown Architecture"
}

func cpuTypeToString(cpu macho.Cpu) string {
	switch cpu {
	case macho.Cpu386:
		return "x86"
	case macho.CpuAmd64:
		return "x86_64"
	case macho.CpuArm:
		return "ARM"
	case macho.CpuArm64:
		return "ARM64"
	case macho.CpuPpc:
		return "PowerPC"
	case macho.CpuPpc64:
		return "PowerPC 64"
	default:
		return fmt.Sprintf("Unknown CPU type: %d", cpu)
	}
}
func describeMachOArch(f *macho.File) string {
	cpu := cpuTypeToString(f.Cpu)
	byteOrder := "Little Endian"
	if f.ByteOrder == binary.BigEndian {
		byteOrder = "Big Endian"
	}
	return fmt.Sprintf("MachO: CPU: %s, Byte Order: %s, File Type: %s", cpu, byteOrder, f.Type.String())
}

func describeELFArch(f *elf.File) string {
	var details []string
	details = append(details, fmt.Sprintf("Machine: %s", f.Machine.String()))
	details = append(details, fmt.Sprintf("Class: %s", f.Class.String()))
	details = append(details, fmt.Sprintf("Data: %s", f.Data.String()))
	details = append(details, fmt.Sprintf("OSABI: %s", describeOSABI(f.OSABI)))
	details = append(details, fmt.Sprintf("ABI Version: %d", f.ABIVersion))
	details = append(details, fmt.Sprintf("Type: %s", f.Type.String()))
	details = append(details, fmt.Sprintf("Entry: 0x%x", f.Entry))
	if len(f.Progs) > 0 {
		details = append(details, fmt.Sprintf("Program Headers: %d", len(f.Progs)))
		for _, prog := range f.Progs {
			details = append(details, fmt.Sprintf("  Type: %s, Flags: %s, VAddr: 0x%x, Memsz: 0x%x",
				prog.Type.String(), describeProgramFlags(prog.Flags), prog.Vaddr, prog.Memsz))
		}
	}
	if len(f.Sections) > 0 {
		details = append(details, fmt.Sprintf("Section Headers: %d", len(f.Sections)))
		for _, section := range f.Sections {
			details = append(details, fmt.Sprintf("  Name: %s, Type: %s, Flags: %s, Addr: 0x%x, Size: 0x%x",
				section.Name, section.Type.String(), describeSectionFlags(section.Flags), section.Addr, section.Size))
		}
	}
	if syms, err := f.DynamicSymbols(); err == nil {
		details = append(details, fmt.Sprintf("Dynamic Symbols: %d", len(syms)))
	}
	if libs, err := f.ImportedLibraries(); err == nil && len(libs) > 0 {
		details = append(details, fmt.Sprintf("Imported Libraries: %s", strings.Join(libs, ", ")))
	}
	return strings.Join(details, "\n")
}

func describeOSABI(osabi elf.OSABI) string {
	switch osabi {
	case elf.ELFOSABI_NONE:
		return "UNIX System V ABI"
	case elf.ELFOSABI_HPUX:
		return "HP-UX"
	case elf.ELFOSABI_NETBSD:
		return "NetBSD"
	case elf.ELFOSABI_LINUX:
		return "Linux"
	case elf.ELFOSABI_SOLARIS:
		return "Sun Solaris"
	case elf.ELFOSABI_AIX:
		return "IBM AIX"
	case elf.ELFOSABI_IRIX:
		return "SGI Irix"
	case elf.ELFOSABI_FREEBSD:
		return "FreeBSD"
	case elf.ELFOSABI_TRU64:
		return "Compaq TRU64 UNIX"
	case elf.ELFOSABI_MODESTO:
		return "Novell Modesto"
	case elf.ELFOSABI_OPENBSD:
		return "OpenBSD"
	case elf.ELFOSABI_ARM:
		return "ARM"
	case elf.ELFOSABI_STANDALONE:
		return "Standalone (embedded) application"
	default:
		return fmt.Sprintf("Unknown OSABI (%d)", osabi)
	}
}

func describeProgramFlags(flags elf.ProgFlag) string {
	var s []string
	if flags&elf.PF_X != 0 {
		s = append(s, "X")
	}
	if flags&elf.PF_W != 0 {
		s = append(s, "W")
	}
	if flags&elf.PF_R != 0 {
		s = append(s, "R")
	}
	return strings.Join(s, "+")
}

func describeSectionFlags(flags elf.SectionFlag) string {
	var s []string
	if flags&elf.SHF_WRITE != 0 {
		s = append(s, "W")
	}
	if flags&elf.SHF_ALLOC != 0 {
		s = append(s, "A")
	}
	if flags&elf.SHF_EXECINSTR != 0 {
		s = append(s, "X")
	}
	return strings.Join(s, "+")
}
func describePEArch(f *pe.File) string {
	var details []string
	details = append(details, fmt.Sprintf("Machine: %d", f.Machine))
	characteristics := describeCharacteristics(f.Characteristics)
	if len(characteristics) > 0 {
		details = append(details, fmt.Sprintf("Characteristics: %s", strings.Join(characteristics, "\n")))
	}
	if f.OptionalHeader != nil {
		switch oh := f.OptionalHeader.(type) {
		case *pe.OptionalHeader32:
			details = append(details, "Format: PE32")
			details = append(details, fmt.Sprintf("Subsystem: %s", describeSubsystem(oh.Subsystem)))
			details = append(details, fmt.Sprintf("BaseOfCode: 0x%X", oh.BaseOfCode))
			details = append(details, fmt.Sprintf("BaseOfData: 0x%X", oh.BaseOfData))
		case *pe.OptionalHeader64:
			details = append(details, "Format: PE32+")
			details = append(details, fmt.Sprintf("Subsystem: %s", describeSubsystem(oh.Subsystem)))
			details = append(details, fmt.Sprintf("BaseOfCode: 0x%X", oh.BaseOfCode))
		}
	}
	details = append(details, fmt.Sprintf("Number of Sections: %d", len(f.Sections)))

	for i, s := range f.Sections {
		details = append(details, fmt.Sprintf("\tSection %d: %s", i, describePESection(s)))
	}
	details = append(details, fmt.Sprintf("Number of Symbols: %d", len(f.Symbols)))

	return strings.Join(details, "\n")
}

func describePESection(s *pe.Section) string {
	return fmt.Sprintf("Name: %s, Address: 0x%X, Size: 0x%X", s.Name, s.VirtualAddress, s.Size)
}

func describeCharacteristics(characteristics uint16) []string {
	var chars []string
	if characteristics&pe.IMAGE_FILE_EXECUTABLE_IMAGE != 0 {
		chars = append(chars, "Executable")
	}
	if characteristics&pe.IMAGE_FILE_LARGE_ADDRESS_AWARE != 0 {
		chars = append(chars, "Large Address Aware")
	}
	if characteristics&pe.IMAGE_FILE_DLL != 0 {
		chars = append(chars, "DLL")
	}
	if characteristics&pe.IMAGE_FILE_32BIT_MACHINE != 0 {
		chars = append(chars, "32-bit")
	}
	if characteristics&pe.IMAGE_FILE_SYSTEM != 0 {
		chars = append(chars, "System")
	}
	if characteristics&pe.IMAGE_FILE_DEBUG_STRIPPED != 0 {
		chars = append(chars, "Debug Stripped")
	}
	return chars
}

func describeSubsystem(subsystem uint16) string {
	switch subsystem {
	case pe.IMAGE_SUBSYSTEM_WINDOWS_GUI:
		return "Windows GUI"
	case pe.IMAGE_SUBSYSTEM_WINDOWS_CUI:
		return "Windows Console"
	case pe.IMAGE_SUBSYSTEM_EFI_APPLICATION:
		return "EFI Application"
	case pe.IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER:
		return "EFI Boot Service Driver"
	case pe.IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER:
		return "EFI Runtime Driver"
	case pe.IMAGE_SUBSYSTEM_NATIVE:
		return "Native"
	case pe.IMAGE_SUBSYSTEM_POSIX_CUI:
		return "POSIX Console"
	default:
		return fmt.Sprintf("Unknown (%d)", subsystem)
	}
}
func main() {
	if len(os.Args) != 4 {
		fmt.Println("Usage: program <input file path> <frida new name> <output file path>")
		os.Exit(1)
	}

	inputFilePath := os.Args[1]
	fridaNewName := os.Args[2]
	outputFilePath := os.Args[3]

	if len(fridaNewName) != 5 || !isStringAlpha(fridaNewName) {
		fmt.Println("Error: frida new name must be a 5-character alphabetic string")
		os.Exit(1)
	}

	// é¦–å…ˆå¤åˆ¶è¾“å…¥æ–‡ä»¶åˆ°è¾“å‡ºæ–‡ä»¶
	if err := copyFile(inputFilePath, outputFilePath); err != nil {
		fmt.Println("Error copying file:", err)
		os.Exit(1)
	}

	file, format, err := detectAndOpenFile(outputFilePath)
	if err != nil {
		fmt.Println("Error opening file:", err)
		os.Exit(1)
	}

	fmt.Println("Detected file format:", format)
	fmt.Println(describeArch(file, format))

	switch f := file.(type) {
	case *macho.File:
		handleSignleArchitecture(f, outputFilePath, fridaNewName, format)
	case *macho.FatFile:
		handleMultipleArchitectures(f, outputFilePath, fridaNewName, format)
	case *elf.File:
		handleELFFile(f, outputFilePath, fridaNewName, format)
	case *pe.File:
		handlePEFile(f, outputFilePath, fridaNewName, format)
	default:
		fmt.Println("Unsupported file type")
		os.Exit(1)
	}

	fmt.Println("Patch success")
}

func detectAndOpenFile(filePath string) (interface{}, ExecutableFormat, error) {
	if machoFile, err := macho.Open(filePath); err == nil {
		return machoFile, MachO, nil
	}
	if fatFile, err := macho.OpenFat(filePath); err == nil {
		return fatFile, MachO, nil
	}
	if elfFile, err := elf.Open(filePath); err == nil {
		return elfFile, ELF, nil
	}
	if peFile, err := pe.Open(filePath); err == nil {
		return peFile, PE, nil
	}
	return nil, 0, fmt.Errorf("unsupported file format")
}
func copyFile(src, dst string) error {
	sourceFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer sourceFile.Close()

	destFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer destFile.Close()

	_, err = io.Copy(destFile, sourceFile)

	os.Chmod(dst, 0755)
	return err
}

func handlePEFile(file *pe.File, outputFilePath, fridaNewName string, format ExecutableFormat) {
	replacementsList := buildReplacements(fridaNewName, format)
	for _, replacements := range replacementsList {
		section := file.Section(replacements.SectionName)
		if section == nil {
			fmt.Printf("Warning: %s section not found in file\n", replacements.SectionName)
			continue
		}
		data, err := section.Data()
		if err != nil {
			fmt.Printf("Error reading section data for %s: %v\n", replacements.SectionName, err)
			continue
		}
		modifiedData := replaceInSection(data, replacements.Items)
		if err := writeModifiedSection(outputFilePath, int64(section.Offset), modifiedData); err != nil {
			fmt.Printf("Error writing modified data for %s: %v\n", replacements.SectionName, err)
			continue
		}
		fmt.Printf("Successfully patched %s section\n", replacements.SectionName)
	}
}

func handleELFFile(file *elf.File, outputFilePath, fridaNewName string, format ExecutableFormat) {
	replacementsList := buildReplacements(fridaNewName, format)
	for _, replacements := range replacementsList {
		section := file.Section(replacements.SectionName)
		if section == nil {
			fmt.Printf("Warning: %s section not found in file\n", replacements.SectionName)
			continue
		}
		data, err := section.Data()
		if err != nil {
			fmt.Printf("Error reading section data for %s: %v\n", replacements.SectionName, err)
			continue
		}
		modifiedData := replaceInSection(data, replacements.Items)
		if err := writeModifiedSection(outputFilePath, int64(section.Offset), modifiedData); err != nil {
			fmt.Printf("Error writing modified data for %s: %v\n", replacements.SectionName, err)
			continue
		}
		fmt.Printf("Successfully patched %s section\n", replacements.SectionName)
	}
}

func handleSignleArchitecture(file *macho.File, outputFilePath, fridaNewName string, format ExecutableFormat) {
	replacementsList := buildReplacements(fridaNewName, format)
	for _, replacements := range replacementsList {
		section := file.Section(replacements.SectionName)
		if section == nil {
			fmt.Printf("Warning: %s section not found in file\n", replacements.SectionName)
			continue
		}
		data, err := section.Data()
		if err != nil {
			fmt.Printf("Error reading section data for %s: %v\n", replacements.SectionName, err)
			continue
		}
		modifiedData := replaceInSection(data, replacements.Items)
		if err := writeModifiedSection(outputFilePath, int64(section.Offset), modifiedData); err != nil {
			fmt.Printf("Error writing modified data for %s: %v\n", replacements.SectionName, err)
			continue
		}
		fmt.Printf("Successfully patched %s section\n", replacements.SectionName)
	}
}

func handleMultipleArchitectures(fatFile *macho.FatFile, filePath, fridaNewName string, format ExecutableFormat) {
	for _, arch := range fatFile.Arches {
		patchArchitecture(arch, filePath, fridaNewName, format)
	}
}

func patchArchitecture(arch macho.FatArch, filePath, fridaNewName string, format ExecutableFormat) {
	replacementsList := buildReplacements(fridaNewName, format)
	for _, replacements := range replacementsList {
		section := arch.Section(replacements.SectionName)
		if section == nil {
			fmt.Printf("Warning: %s section not found in architecture %s\n", replacements.SectionName, arch.Cpu.String())
			continue
		}
		data, err := section.Data()
		if err != nil {
			fmt.Printf("Error reading section data for %s in architecture %s: %v\n", replacements.SectionName, arch.Cpu.String(), err)
			continue
		}
		modifiedData := replaceInSection(data, replacements.Items)
		if err := writeModifiedSection(filePath, int64(arch.Offset+section.Offset), modifiedData); err != nil {
			fmt.Printf("Error writing modified data for %s in architecture %s: %v\n", replacements.SectionName, arch.Cpu.String(), err)
			continue
		}
		fmt.Printf("Successfully patched %s section\n", replacements.SectionName)
	}
}

func isStringAlpha(s string) bool {
	for _, c := range s {
		if c < 'a' || c > 'z' {
			return false
		}
	}
	return true
}

func buildReplacements(fridaNewName string, format ExecutableFormat) []Replacements {
	switch format {
	case MachO:
		return []Replacements{
			{
				ExecutableFormat: format,
				SectionName:      "__cstring",
				Items: []*Replacement{
					{Old: []byte("frida_server_"), New: []byte(fridaNewName + "_server_")},
					{Old: []byte("frida-server-main-loop"), New: []byte(fridaNewName + "-server-main-loop")},
					{Old: []byte("frida-main-loop"), New: []byte(fridaNewName + "-main-loop")},
					{Old: []byte("frida:rpc"), New: []byte(fridaNewName + ":rpc")},
					{Old: []byte("frida-agent.dylib"), New: []byte(fridaNewName + "-agent.dylib")},
					{Old: []byte("/usr/lib/frida/"), New: []byte("/usr/lib/" + fridaNewName + "/")},
					{Old: []byte("gum-"), New: []byte(fridaNewName[:3] + "-")},
				},
			},
			{
				ExecutableFormat: format,
				SectionName:      "__const",
				Items: []*Replacement{
					{Old: []byte("frida:rpc"), New: []byte(fridaNewName + ":rpc")},
				},
			},
		}
	case ELF:
		return []Replacements{
			{
				ExecutableFormat: format,
				SectionName:      ".rodata",
				Items: []*Replacement{
					{Old: []byte("frida_server_"), New: []byte(fridaNewName + "_server_")},
					{Old: []byte("frida-main-loop"), New: []byte(fridaNewName + "-main-loop")},
					{Old: []byte("frida:rpc"), New: []byte(fridaNewName + ":rpc")},
					{Old: []byte("frida-agent-<arch>.so"), New: []byte(fridaNewName + "-agent-<arch>.so")},
					{Old: []byte("frida-agent-arm.so"), New: []byte(fridaNewName + "-agent-arm.so")},
					{Old: []byte("frida-agent-arm64.so"), New: []byte(fridaNewName + "-agent-arm64.so")},
					{Old: []byte("frida-agent-32.so"), New: []byte(fridaNewName + "-agent-32.so")},
					{Old: []byte("frida-agent-64.so"), New: []byte(fridaNewName + "-agent-64.so")},
					{Old: []byte("gum-"), New: []byte(fridaNewName[:3] + "-")},
				},
			},
			{
				ExecutableFormat: format,
				SectionName:      ".text",
				Items: []*Replacement{
					{Old: []byte("frida:rpc"), New: []byte(fridaNewName + ":rpc")},
					{Old: []byte("gum-"), New: []byte(fridaNewName[:3] + "-")},
				},
			},
		}
	case PE:
		return []Replacements{
			{
				ExecutableFormat: format,
				SectionName:      ".rdata",
				Items: []*Replacement{
					{Old: []byte("frida-"), New: []byte(fridaNewName + "-")},
					{Old: []byte("frida_"), New: []byte(fridaNewName + "_")},
					{Old: []byte("frida_server_"), New: []byte(fridaNewName + "_server_")},
					{Old: []byte("frida-main-loop"), New: []byte(fridaNewName + "-main-loop")},
					{Old: []byte("gum-"), New: []byte(fridaNewName[:3] + "-")},
					{Old: []byte("frida-thread"), New: []byte(fridaNewName + "-thread")},
					{Old: []byte("frida:rpc"), New: []byte(fridaNewName + ":rpc")},
					{Old: []byte("frida-agent"), New: []byte(fridaNewName + "-agent")},
				},
			},
		}
	}
	return nil
}

func replaceInSection(data []byte, replacements []*Replacement) []byte {
	modifiedData := make([]byte, len(data))
	copy(modifiedData, data)

	counter := 0
	for _, replacement := range replacements {
		oldBytes := replacement.Old
		newBytes := replacement.New

		for i := 0; i <= len(modifiedData)-len(oldBytes); i++ {
			if bytesEqual(modifiedData[i:i+len(oldBytes)], oldBytes) {
				replacement := make([]byte, len(oldBytes))
				copy(replacement, newBytes)
				for j := len(newBytes); j < len(oldBytes); j++ {
					replacement[j] = 0
				}
				copy(modifiedData[i:i+len(oldBytes)], replacement)
				counter++
			}
		}
	}

	fmt.Printf("Replaced %d occurrences\n", counter)

	return modifiedData
}

func bytesEqual(a, b []byte) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

func writeModifiedSection(filePath string, offset int64, data []byte) error {
	f, err := os.OpenFile(filePath, os.O_RDWR, 0)
	if err != nil {
		return err
	}
	defer f.Close()

	_, err = f.WriteAt(data, offset)
	return err
}

```

`test_binary.sh`:

```sh
#!/bin/bash
# Simple test binary with strings
echo "frida-server"
echo "Hello World"
echo "Test Binary"

```

`test_program.c`:

```c
#include <stdio.h>

int main() {
    printf("frida-server started\n");
    printf("Hello World from test binary\n");
    printf("This is a test for binary analysis\n");
    return 0;
}

```

`toolkit/generate_frida_modules.py`:

```py
import os
import re
import requests

def get_proxy_settings():
    curl_proxy = os.environ.get('CURL_PROXY', '')
    if curl_proxy:
        return {"http": curl_proxy, "https": curl_proxy}
    return None

def get_latest_release():
    url = "https://api.github.com/repos/frida/frida/releases/latest"
    proxies = get_proxy_settings()
    try:
        response = requests.get(url, proxies=proxies)
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        print(f"Error fetching latest release: {str(e)}")
        return None

def parse_filename(filename):
    pattern = re.compile(r'(?P<module_type>frida[-_]?[a-zA-Z0-9\-]+)?[-_](?P<version>v?\d+\.\d+\.\d+)[-_](?P<os>[a-zA-Z0-9\-]+)[-_](?P<arch>[a-zA-Z0-9_]+)')
    match = pattern.search(filename)
    if match:
        module_type = match.group('module_type') or 'N/A'
        version = match.group('version')
        os = match.group('os')
        arch = match.group('arch')
        if '.' in filename:
            ext = filename.split('.')[-1]
        else:
            ext = 'N/A'
        if '64' == arch:
            arch = 'x86_64'
        elif '_' in arch:
            arch = arch.split('_')[-1]
        if os.startswith('cp') and '-' in os:
            os_info = os.split('-')
            os = os_info[-1]
            module_type = 'frida-python-' + os_info[0] + '-' + os_info[1]
        elif 'node-' in os:
            os_info = os.split('-')
            os = os_info[-1]
            module_type = 'frida-' + os_info[0] + '-' + os_info[1]
        elif 'electron-' in os:
            os_info = os.split('-')
            os = os_info[-1]
            module_type = 'frida-' + os_info[0] + '-' + os_info[1]
        elif '-' in os:
            os = os.split('-')[0]

        if 'N/A' == module_type and 'deb' in filename:
            module_type = 'frida-' + os + '-deb'
        elif 'N/A' == module_type and 'gum-graft' in filename:
            module_type = 'gum-graft'
            os = filename.split('-')[-2]
            arch = filename.split('-')[-1].split('.')[0]
        return (module_type, version, os, arch, ext)
    return None

def generate_frida_modules():
    release = get_latest_release()
    if not release:
        return []

    assets = release['assets']
    frida_modules = []

    for asset in assets:
        parsed = parse_filename(asset['name'])
        if parsed:
            module_type, version, os, arch, ext = parsed
            if 'v' == version[0]:
                version = version[1:]
            asset_name = asset['name'].replace(version, '{VERSION}')
            frida_modules.append(f'"{module_type}:{os}:{arch}:{asset_name}"')

    return frida_modules

def main():
    frida_modules = generate_frida_modules()
    print("FRIDA_MODULES=(")
    for module in frida_modules:
        print(f"    {module}")
    print(")")

if __name__ == "__main__":
    main()
```

`toolkit/manifest.txt`:

```txt
hexreplace/main.go
hexreplace/Makefile
hexreplace/go.mod
autoinstall.sh
CHANGELOG
fridare.sh
README.md
```

`toolkit/merge.py`:

```py
import os
import argparse

def get_language(file_extension):
    language_map = {
        '.py': 'python',
        '.js': 'javascript',
        '.html': 'html',
        '.css': 'css',
        '.java': 'java',
        '.c': 'c',
        '.cpp': 'cpp',
        '.go': 'golang',
        '.rs': 'rust',
        '.sh': 'shell',
        '.md': 'markdown',
        '.json': 'json',
        '.yaml': 'yaml',
        '.xml': 'xml',
        '.sql': 'sql',
        '.ts': 'typescript',
    }
    return language_map.get(file_extension.lower(), '')

def escape_backticks(content):
    return content.replace("```", "\\`\\`\\`")

def merge_files(manifest_file, base_directory, output_file):
    with open(output_file, 'w', encoding='utf-8') as outfile:
        with open(manifest_file, 'r', encoding='utf-8') as manifest:
            for line in manifest:
                file_path = line.strip()
                if not file_path or file_path.startswith('#'):
                    continue  # è·³è¿‡ç©ºè¡Œå’Œæ³¨é‡Š

                full_path = os.path.join(base_directory, file_path)
                if not os.path.exists(full_path):
                    print(f"Warning: File not found - {full_path}")
                    continue

                _, file_extension = os.path.splitext(file_path)
                
                # å†™å…¥æ–‡ä»¶åä½œä¸ºMarkdownæ ‡é¢˜
                outfile.write(f"# {file_path}\n\n")
                
                # è·å–è¯­è¨€ç±»å‹
                language = get_language(file_extension)
                
                # è¯»å–å¹¶è½¬ä¹‰æ–‡ä»¶å†…å®¹
                try:
                    with open(full_path, 'r', encoding='utf-8') as infile:
                        content = infile.read()
                        escaped_content = escape_backticks(content)
                    
                    # å†™å…¥æ–‡ä»¶å†…å®¹ï¼ŒåŒ…æ‹¬è¯­è¨€ç±»å‹
                    outfile.write(f"```{language}\n{escaped_content}\n```\n\n")
                except Exception as e:
                    print(f"Error reading file {full_path}: {e}")

def main():
    parser = argparse.ArgumentParser(description="Merge specified files into a single Markdown file.")
    parser.add_argument("manifest", help="Path to the manifest file listing files to merge")
    parser.add_argument("base_directory", help="Base directory for the files listed in the manifest")
    parser.add_argument("output", help="Output file name")
    
    args = parser.parse_args()
    
    merge_files(args.manifest, args.base_directory, args.output)
    print(f"Files merged successfully into {args.output}")

if __name__ == "__main__":
    main()
```

`ui/build.sh`:

```sh
#!/bin/bash
# Fridare GUI æ„å»ºè„šæœ¬

set -e

echo "=== Fridare GUI æ„å»ºå·¥å…· ==="
echo ""

# è¿›å…¥é¡¹ç›®ç›®å½•
cd "$(dirname "$0")"

# æ¸…ç†æ—§çš„æ„å»ºæ–‡ä»¶
echo "æ¸…ç†æ—§çš„æ„å»ºæ–‡ä»¶..."
rm -f build/fridare-gui.exe
rm -f build/fridare-create.exe
rm -f build/fridare-patch.exe

# ä½¿ç”¨ fyne build æ„å»ºï¼ˆåŒ…å«æ›´å¥½çš„å›¾æ ‡å’Œèµ„æºæ‰“åŒ…ï¼‰
echo "æ„å»ºåº”ç”¨ç¨‹åº..."
fyne build --src cmd/gui -o ../../build/fridare-gui.exe
go build -o build/fridare-create.exe cmd/create/main.go
go build -o build/fridare-patch.exe cmd/patch/main.go

echo ""
echo "âœ… æ„å»ºå®Œæˆï¼"
echo ""
echo "ç”Ÿæˆçš„æ–‡ä»¶ï¼š"
ls -la build/fridare-gui.exe
ls -la build/fridare-create.exe
ls -la build/fridare-patch.exe

echo ""
echo "è¿è¡Œåº”ç”¨ç¨‹åºï¼š"
echo "  ./build/fridare-gui.exe"

./build/fridare-gui.exe
```

`ui/cmd/create/main.go`:

```go
package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"

	"fridare-gui/internal/core"
)

func main() {
	var (
		fridaServerPath  = flag.String("server", "", "frida-serveræ–‡ä»¶è·¯å¾„ (å¿…éœ€)")
		fridaAgentPath   = flag.String("agent", "", "frida-agent.dylibæ–‡ä»¶è·¯å¾„ (å¿…éœ€)")
		outputPath       = flag.String("output", "", "è¾“å‡ºDEBæ–‡ä»¶è·¯å¾„ (å¿…éœ€)")
		magicName        = flag.String("magic", "", "é­”æ”¹åç§° (5ä¸ªå­—ç¬¦, å¿…éœ€)")
		port             = flag.Int("port", 27042, "æœåŠ¡ç«¯å£ (é»˜è®¤: 27042)")
		isRootless       = flag.Bool("rootless", false, "æ˜¯å¦ä¸ºrootlessç»“æ„ (é»˜è®¤: false, å³rootç»“æ„)")
		packageName      = flag.String("name", "", "åŒ…å (å¯é€‰, è‡ªåŠ¨ç”Ÿæˆ)")
		version          = flag.String("version", "17.2.17", "ç‰ˆæœ¬å· (é»˜è®¤: 17.2.17)")
		architecture     = flag.String("arch", "iphoneos-arm64", "æ¶æ„ (é»˜è®¤: iphoneos-arm64)")
		maintainer       = flag.String("maintainer", "Fridare Team <support@fridare.com>", "ç»´æŠ¤è€…")
		description      = flag.String("desc", "", "åŒ…æè¿° (å¯é€‰, è‡ªåŠ¨ç”Ÿæˆ)")
		depends          = flag.String("depends", "firmware (>= 12.0)", "ä¾èµ– (é»˜è®¤: firmware (>= 12.0))")
		section          = flag.String("section", "Development", "åˆ†ç±» (é»˜è®¤: Development)")
		priority         = flag.String("priority", "optional", "ä¼˜å…ˆçº§ (é»˜è®¤: optional)")
		homepage         = flag.String("homepage", "https://frida.re/", "ä¸»é¡µ (é»˜è®¤: https://frida.re/)")
		extractDebPath   = flag.String("extract-deb", "", "ä»ç°æœ‰DEBåŒ…ä¸­æå–frida-agent.dylib (å¯é€‰)")
		extractAgentOnly = flag.Bool("extract-agent-only", false, "ä»…æå–agentæ–‡ä»¶åˆ°å½“å‰ç›®å½•ï¼Œä¸åˆ›å»ºæ–°DEBåŒ…")
		help             = flag.Bool("help", false, "æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯")
	)

	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Fridare DEBåŒ…åˆ›å»ºå·¥å…·\n\n")
		fmt.Fprintf(os.Stderr, "ç”¨æ³•: %s [é€‰é¡¹]\n\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "é€‰é¡¹:\n")
		flag.PrintDefaults()
		fmt.Fprintf(os.Stderr, "\nç¤ºä¾‹:\n")
		fmt.Fprintf(os.Stderr, "  # åˆ›å»ºRootç»“æ„çš„DEBåŒ…\n")
		fmt.Fprintf(os.Stderr, "  %s -server frida-server -agent frida-agent.dylib -magic agent -output agent.deb\n\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "  # åˆ›å»ºRootlessç»“æ„çš„DEBåŒ…\n")
		fmt.Fprintf(os.Stderr, "  %s -server frida-server -agent frida-agent.dylib -magic agent -rootless -port 27043 -output agent-rootless.deb\n\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "  # ä»ç°æœ‰DEBåŒ…ä¸­æå–agentå¹¶åˆ›å»ºæ–°DEBåŒ…\n")
		fmt.Fprintf(os.Stderr, "  %s -server frida-server -extract-deb frida_17.2.17_iphoneos-arm64.deb -magic agent -output agent.deb\n\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "  # ä»…ä»DEBåŒ…ä¸­æå–agentæ–‡ä»¶\n")
		fmt.Fprintf(os.Stderr, "  %s -extract-deb frida_17.2.17_iphoneos-arm64.deb -extract-agent-only\n\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "æ³¨æ„:\n")
		fmt.Fprintf(os.Stderr, "  - magicåç§°å¿…é¡»æ˜¯5ä¸ªå­—ç¬¦ï¼Œä¸”ç¬¦åˆå‘½åè§„åˆ™ (å­—æ¯å¼€å¤´ï¼ŒåŒ…å«å­—æ¯æ•°å­—)\n")
		fmt.Fprintf(os.Stderr, "  - rootlessç»“æ„ç”¨äºç°ä»£è¶Šç‹±ç¯å¢ƒ (å¦‚checkra1n, unc0verç­‰)\n")
		fmt.Fprintf(os.Stderr, "  - rootç»“æ„ç”¨äºä¼ ç»Ÿè¶Šç‹±ç¯å¢ƒ\n")
		fmt.Fprintf(os.Stderr, "  - frida-agent.dylibæ–‡ä»¶æ˜¯å¿…éœ€çš„ï¼Œç¡®ä¿å®Œæ•´åŠŸèƒ½\n")
	}

	flag.Parse()

	if *help {
		flag.Usage()
		return
	}

	// å¤„ç†ä»…æå–agentæ–‡ä»¶çš„æƒ…å†µ
	if *extractAgentOnly {
		if *extractDebPath == "" {
			fmt.Fprintf(os.Stderr, "é”™è¯¯: ä½¿ç”¨ -extract-agent-only æ—¶å¿…é¡»æŒ‡å®š -extract-deb å‚æ•°\n\n")
			flag.Usage()
			os.Exit(1)
		}

		fmt.Printf("INFO: è¯¥åŠŸèƒ½å°†åœ¨åç»­ç‰ˆæœ¬ä¸­å®ç°\n")
		fmt.Printf("INFO: å½“å‰å¯ä»¥æ‰‹åŠ¨è§£å‹DEBåŒ…è·å–agentæ–‡ä»¶:\n")
		fmt.Printf("  ar -x %s\n", *extractDebPath)
		fmt.Printf("  tar -xf data.tar.xz\n")
		fmt.Printf("  find . -name '*agent*.dylib'\n")
		return
	}

	// å¦‚æœæŒ‡å®šäº†extract-debå‚æ•°ï¼Œå°è¯•ä»ä¸­è·å–agentæ–‡ä»¶è·¯å¾„
	if *extractDebPath != "" && *fridaAgentPath == "" {
		fmt.Printf("INFO: ä»DEBåŒ…ä¸­è‡ªåŠ¨æå–agentæ–‡ä»¶åŠŸèƒ½å°†åœ¨åç»­ç‰ˆæœ¬ä¸­å®ç°\n")
		fmt.Printf("INFO: è¯·æ‰‹åŠ¨æå–agentæ–‡ä»¶å¹¶ä½¿ç”¨ -agent å‚æ•°æŒ‡å®š\n")
	}

	// éªŒè¯å¿…éœ€å‚æ•°
	if *fridaServerPath == "" {
		fmt.Fprintf(os.Stderr, "é”™è¯¯: å¿…é¡»æŒ‡å®šfrida-serveræ–‡ä»¶è·¯å¾„ (-server)\n\n")
		flag.Usage()
		os.Exit(1)
	}

	if *fridaAgentPath == "" && *extractDebPath == "" {
		fmt.Fprintf(os.Stderr, "é”™è¯¯: å¿…é¡»æŒ‡å®šfrida-agent.dylibæ–‡ä»¶è·¯å¾„ (-agent) æˆ–ä½¿ç”¨ -extract-deb ä»ç°æœ‰DEBåŒ…æå–\n\n")
		flag.Usage()
		os.Exit(1)
	}

	if *outputPath == "" {
		fmt.Fprintf(os.Stderr, "é”™è¯¯: å¿…é¡»æŒ‡å®šè¾“å‡ºDEBæ–‡ä»¶è·¯å¾„ (-output)\n\n")
		flag.Usage()
		os.Exit(1)
	}

	if *magicName == "" {
		fmt.Fprintf(os.Stderr, "é”™è¯¯: å¿…é¡»æŒ‡å®šé­”æ”¹åç§° (-magic)\n\n")
		flag.Usage()
		os.Exit(1)
	}

	// éªŒè¯magicåç§°
	if len(*magicName) != 5 {
		fmt.Fprintf(os.Stderr, "é”™è¯¯: é­”æ”¹åç§°å¿…é¡»æ˜¯5ä¸ªå­—ç¬¦ï¼Œå½“å‰: %dä¸ªå­—ç¬¦\n", len(*magicName))
		os.Exit(1)
	}

	if !isValidMagicName(*magicName) {
		fmt.Fprintf(os.Stderr, "é”™è¯¯: é­”æ”¹åç§°æ ¼å¼æ— æ•ˆï¼Œå¿…é¡»ä»¥å­—æ¯å¼€å¤´ï¼ŒåŒ…å«å­—æ¯å’Œæ•°å­—\n")
		os.Exit(1)
	}

	// éªŒè¯æ–‡ä»¶å­˜åœ¨
	if _, err := os.Stat(*fridaServerPath); os.IsNotExist(err) {
		fmt.Fprintf(os.Stderr, "é”™è¯¯: frida-serveræ–‡ä»¶ä¸å­˜åœ¨: %s\n", *fridaServerPath)
		os.Exit(1)
	}

	// æ£€æŸ¥frida-serveræ–‡ä»¶å¤§å°
	if stat, err := os.Stat(*fridaServerPath); err == nil {
		if stat.Size() < 1024*1024 { // å°äº1MBå¯èƒ½æœ‰é—®é¢˜
			fmt.Fprintf(os.Stderr, "è­¦å‘Š: frida-serveræ–‡ä»¶å¤§å°å¼‚å¸¸: %.2f MB\n", float64(stat.Size())/(1024*1024))
		} else {
			fmt.Printf("INFO: frida-serveræ–‡ä»¶å¤§å°: %.2f MB\n", float64(stat.Size())/(1024*1024))
		}
	}

	if *fridaAgentPath != "" {
		if _, err := os.Stat(*fridaAgentPath); os.IsNotExist(err) {
			fmt.Fprintf(os.Stderr, "é”™è¯¯: frida-agentæ–‡ä»¶ä¸å­˜åœ¨: %s\n", *fridaAgentPath)
			os.Exit(1)
		}
		// æ£€æŸ¥frida-agentæ–‡ä»¶å¤§å°
		if stat, err := os.Stat(*fridaAgentPath); err == nil {
			fmt.Printf("INFO: frida-agentæ–‡ä»¶å¤§å°: %.2f MB\n", float64(stat.Size())/(1024*1024))
		}
	}

	// éªŒè¯ç«¯å£èŒƒå›´
	if *port < 1 || *port > 65535 {
		fmt.Fprintf(os.Stderr, "é”™è¯¯: ç«¯å£å¿…é¡»åœ¨1-65535èŒƒå›´å†…\n")
		os.Exit(1)
	}

	// è‡ªåŠ¨ç”ŸæˆåŒ…åï¼ˆå¦‚æœæœªæŒ‡å®šï¼‰
	if *packageName == "" {
		// å°†"frida"æ›¿æ¢ä¸ºé­”æ”¹åç§°
		*packageName = fmt.Sprintf("re.%s.server", *magicName)
	}

	// è‡ªåŠ¨ç”Ÿæˆæè¿°ï¼ˆå¦‚æœæœªæŒ‡å®šï¼‰
	if *description == "" {
		*description = fmt.Sprintf("Dynamic instrumentation toolkit for developers, security researchers, and reverse engineers (Modified: %s)", *magicName)
	}

	// æ˜¾ç¤ºé…ç½®ä¿¡æ¯
	fmt.Printf("=== Fridare DEBåŒ…åˆ›å»ºå·¥å…· ===\n")
	fmt.Printf("è¾“å…¥æ–‡ä»¶:\n")
	fmt.Printf("  frida-server: %s\n", *fridaServerPath)
	if *fridaAgentPath != "" {
		fmt.Printf("  frida-agent:  %s\n", *fridaAgentPath)
	} else {
		fmt.Printf("  frida-agent:  (æœªæŒ‡å®š)\n")
	}
	fmt.Printf("è¾“å‡ºæ–‡ä»¶: %s\n", *outputPath)
	fmt.Printf("åŒ…é…ç½®:\n")
	fmt.Printf("  åŒ…å:     %s\n", *packageName)
	fmt.Printf("  ç‰ˆæœ¬:     %s\n", *version)
	fmt.Printf("  æ¶æ„:     %s\n", *architecture)
	fmt.Printf("  é­”æ”¹å:   %s\n", *magicName)
	fmt.Printf("  ç«¯å£:     %d\n", *port)
	fmt.Printf("  ç»“æ„:     %s\n", map[bool]string{true: "Rootless", false: "Root"}[*isRootless])
	fmt.Printf("  ç»´æŠ¤è€…:   %s\n", *maintainer)
	fmt.Printf("  æè¿°:     %s\n", *description)
	fmt.Printf("=============================\n\n")

	// åˆ›å»ºåŒ…ä¿¡æ¯
	packageInfo := &core.PackageInfo{
		Name:         *packageName,
		Version:      *version,
		Architecture: *architecture,
		Maintainer:   *maintainer,
		Description:  *description,
		Depends:      *depends,
		Section:      *section,
		Priority:     *priority,
		Homepage:     *homepage,
		Port:         *port,
		MagicName:    *magicName,
		IsRootless:   *isRootless,
	}

	// åˆ›å»ºDEBæ„å»ºå™¨
	creator := core.NewCreateFridaDeb(*fridaServerPath, *outputPath, packageInfo)
	if *fridaAgentPath != "" {
		creator.FridaAgentPath = *fridaAgentPath
	}

	// æ‰§è¡Œæ„å»º
	err := creator.CreateDebPackage()
	if err != nil {
		fmt.Fprintf(os.Stderr, "é”™è¯¯: DEBåŒ…åˆ›å»ºå¤±è´¥: %v\n", err)
		os.Exit(1)
	}

	// æ˜¾ç¤ºæˆåŠŸä¿¡æ¯
	fmt.Printf("\nâœ… DEBåŒ…åˆ›å»ºæˆåŠŸ!\n")
	fmt.Printf("è¾“å‡ºæ–‡ä»¶: %s\n", *outputPath)

	// æ˜¾ç¤ºæ–‡ä»¶å¤§å°
	if stat, err := os.Stat(*outputPath); err == nil {
		fmt.Printf("æ–‡ä»¶å¤§å°: %.2f MB\n", float64(stat.Size())/(1024*1024))
	}

	fmt.Printf("\nğŸ“¦ å®‰è£…å‘½ä»¤:\n")
	fmt.Printf("  dpkg -i %s\n", filepath.Base(*outputPath))
	fmt.Printf("\nğŸ”§ æœåŠ¡æ§åˆ¶:\n")
	if *isRootless {
		fmt.Printf("  å¯åŠ¨: launchctl load /var/re/Library/LaunchDaemons/re.%s.server.plist\n", *magicName)
		fmt.Printf("  åœæ­¢: launchctl unload /var/re/Library/LaunchDaemons/re.%s.server.plist\n", *magicName)
	} else {
		fmt.Printf("  å¯åŠ¨: launchctl load /Library/LaunchDaemons/re.%s.server.plist\n", *magicName)
		fmt.Printf("  åœæ­¢: launchctl unload /Library/LaunchDaemons/re.%s.server.plist\n", *magicName)
	}
	fmt.Printf("\nğŸŒ è¿æ¥ä¿¡æ¯:\n")
	fmt.Printf("  ç«¯å£: %d\n", *port)
	fmt.Printf("  fridaå‘½ä»¤: frida -H <è®¾å¤‡IP>:%d <è¿›ç¨‹å>\n", *port)
}

// isValidMagicName éªŒè¯é­”æ”¹åç§°æ ¼å¼
func isValidMagicName(s string) bool {
	// å¿…é¡»ä»¥å­—æ¯å¼€å¤´
	if len(s) == 0 {
		return false
	}

	first := s[0]
	if !((first >= 'A' && first <= 'Z') || (first >= 'a' && first <= 'z')) {
		return false
	}

	// æ£€æŸ¥å…¶ä½™å­—ç¬¦å¿…é¡»æ˜¯å­—æ¯æˆ–æ•°å­—
	for _, c := range s {
		if !((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')) {
			return false
		}
	}

	return true
}

```

`ui/cmd/gui/main.go`:

```go
package main

import (
	"fridare-gui/internal/assets"
	"fridare-gui/internal/config"
	"fridare-gui/internal/ui"
	"log"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/app"
)

const (
	AppID   = "com.suifei.fridare"
	AppName = "Fridare GUI"
	Version = "1.0.0"
)

func main() {
	// è®¾ç½®åº”ç”¨å…ƒæ•°æ®
	app.SetMetadata(fyne.AppMetadata{
		ID:      AppID,
		Name:    AppName,
		Version: Version,
	})

	// åˆ›å»ºåº”ç”¨ç¨‹åº
	myApp := app.NewWithID(AppID)

	// è®¾ç½®åº”ç”¨ç¨‹åºå›¾æ ‡
	myApp.SetIcon(assets.AppIcon)

	// åŠ è½½é…ç½®
	cfg, err := config.LoadConfig()
	if err != nil {
		log.Printf("åŠ è½½é…ç½®å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤é…ç½®: %v", err)
		cfg = config.DefaultConfig()
	}

	// åˆ›å»ºä¸»çª—å£
	mainWindow := ui.NewMainWindow(myApp, cfg)

	// æ˜¾ç¤ºçª—å£å¹¶è¿è¡Œ
	mainWindow.ShowAndRun()
}

```

`ui/cmd/patch/main.go`:

```go
package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"

	"fridare-gui/internal/core"
)

func main() {
	if len(os.Args) < 4 {
		fmt.Println("ç”¨æ³•: fridare-patch.exe <è¾“å…¥DEBæ–‡ä»¶> <è¾“å‡ºDEBæ–‡ä»¶> <é­”æ”¹åç§°> [ç«¯å£]")
		fmt.Println("ç¤ºä¾‹: fridare-patch.exe frida_17.2.17_iphoneos-arm64.deb frida_modified.deb test-frida 27042")
		fmt.Println("")
		fmt.Println("è¯´æ˜:")
		fmt.Println("  - è¾“å…¥DEBæ–‡ä»¶: åŸå§‹çš„frida DEBåŒ…æ–‡ä»¶è·¯å¾„")
		fmt.Println("  - è¾“å‡ºDEBæ–‡ä»¶: ä¿®æ”¹åçš„DEBåŒ…è¾“å‡ºè·¯å¾„")
		fmt.Println("  - é­”æ”¹åç§°: ç”¨äºæ›¿æ¢fridaå­—ç¬¦ä¸²çš„5å­—ç¬¦åç§°")
		fmt.Println("  - ç«¯å£: å¯é€‰ï¼ŒæœåŠ¡ç«¯å£å·ï¼Œé»˜è®¤27042")
		os.Exit(1)
	}

	inputPath := os.Args[1]
	outputPath := os.Args[2]
	magicName := os.Args[3]
	port := 27042
	if len(os.Args) > 4 {
		fmt.Sscanf(os.Args[4], "%d", &port)
	}

	// è®¾ç½®æ—¥å¿—æ ¼å¼
	log.SetFlags(log.LstdFlags | log.Lshortfile)

	fmt.Println("=== Fridare DEBåŒ…ä¿®æ”¹å·¥å…· ===")
	fmt.Printf("è¾“å…¥æ–‡ä»¶: %s\n", inputPath)
	fmt.Printf("è¾“å‡ºæ–‡ä»¶: %s\n", outputPath)
	fmt.Printf("é­”æ”¹åç§°: %s\n", magicName)
	fmt.Printf("ç«¯å£: %d\n", port)
	fmt.Println("=============================")
	fmt.Println()

	// æ£€æŸ¥è¾“å…¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
	if _, err := os.Stat(inputPath); os.IsNotExist(err) {
		log.Fatalf("é”™è¯¯: è¾“å…¥æ–‡ä»¶ä¸å­˜åœ¨: %s", inputPath)
	}

	// åˆ›å»ºè¾“å‡ºç›®å½•
	outputDir := filepath.Dir(outputPath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		log.Fatalf("é”™è¯¯: åˆ›å»ºè¾“å‡ºç›®å½•å¤±è´¥: %v", err)
	}

	// åˆ›å»ºDEBä¿®æ”¹å™¨
	modifier := core.NewDebModifier(inputPath, outputPath, magicName, port)

	// è¿›åº¦å›è°ƒå‡½æ•°
	progressCallback := func(progress float64, message string) {
		fmt.Printf("[%.0f%%] %s\n", progress*100, message)
	}

	// æ‰§è¡Œä¿®æ”¹
	err := modifier.ModifyDebPackage(progressCallback)
	if err != nil {
		log.Fatalf("é”™è¯¯: DEBåŒ…ä¿®æ”¹å¤±è´¥: %v", err)
	}

	fmt.Println()
	fmt.Println("âœ… DEBåŒ…ä¿®æ”¹æˆåŠŸå®Œæˆ!")

	// æ˜¾ç¤ºè¾“å‡ºæ–‡ä»¶ä¿¡æ¯
	if stat, err := os.Stat(outputPath); err == nil {
		fmt.Printf("è¾“å‡ºæ–‡ä»¶: %s\n", outputPath)
		fmt.Printf("æ–‡ä»¶å¤§å°: %.2f MB\n", float64(stat.Size())/1024/1024)
	}

	fmt.Println()
	fmt.Println("ğŸ“¦ å®‰è£…å‘½ä»¤:")
	fmt.Printf("  dpkg -i %s\n", filepath.Base(outputPath))
	fmt.Println()
	fmt.Println("ğŸ”§ æœåŠ¡æ§åˆ¶:")
	fmt.Printf("  å¯åŠ¨: launchctl load /Library/LaunchDaemons/re.%s.server.plist\n", magicName)
	fmt.Printf("  åœæ­¢: launchctl unload /Library/LaunchDaemons/re.%s.server.plist\n", magicName)
	fmt.Println()
	fmt.Println("ğŸŒ è¿æ¥ä¿¡æ¯:")
	fmt.Printf("  ç«¯å£: %d\n", port)
	fmt.Printf("  fridaå‘½ä»¤: frida -H <è®¾å¤‡IP>:%d <è¿›ç¨‹å>\n", port)
}

```

`ui/go.mod`:

```mod
module fridare-gui

go 1.21

require (
	fyne.io/fyne/v2 v2.6.2
	github.com/go-resty/resty/v2 v2.16.5
	github.com/ulikunitz/xz v0.5.13
)

require (
	fyne.io/systray v1.11.0 // indirect
	github.com/BurntSushi/toml v1.4.0 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/fredbi/uri v1.1.0 // indirect
	github.com/fsnotify/fsnotify v1.9.0 // indirect
	github.com/fyne-io/gl-js v0.2.0 // indirect
	github.com/fyne-io/glfw-js v0.3.0 // indirect
	github.com/fyne-io/image v0.1.1 // indirect
	github.com/fyne-io/oksvg v0.1.0 // indirect
	github.com/go-gl/gl v0.0.0-20231021071112-07e5d0ea2e71 // indirect
	github.com/go-gl/glfw/v3.3/glfw v0.0.0-20240506104042-037f3cc74f2a // indirect
	github.com/go-text/render v0.2.0 // indirect
	github.com/go-text/typesetting v0.2.1 // indirect
	github.com/godbus/dbus/v5 v5.1.0 // indirect
	github.com/hack-pad/go-indexeddb v0.3.2 // indirect
	github.com/hack-pad/safejs v0.1.0 // indirect
	github.com/jeandeaual/go-locale v0.0.0-20250612000132-0ef82f21eade // indirect
	github.com/jsummers/gobmp v0.0.0-20230614200233-a9de23ed2e25 // indirect
	github.com/kr/text v0.2.0 // indirect
	github.com/nfnt/resize v0.0.0-20180221191011-83c6a9932646 // indirect
	github.com/nicksnyder/go-i18n/v2 v2.5.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/rymdport/portal v0.4.1 // indirect
	github.com/srwiley/oksvg v0.0.0-20221011165216-be6e8873101c // indirect
	github.com/srwiley/rasterx v0.0.0-20220730225603-2ab79fcdd4ef // indirect
	github.com/stretchr/testify v1.10.0 // indirect
	github.com/yuin/goldmark v1.7.8 // indirect
	golang.org/x/image v0.24.0 // indirect
	golang.org/x/net v0.35.0 // indirect
	golang.org/x/sys v0.30.0 // indirect
	golang.org/x/text v0.22.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

```

`ui/go.sum`:

```sum
fyne.io/fyne/v2 v2.6.2 h1:RPgwmXWn+EuP/TKwO7w5p73ILVC26qHD9j3CZUZNwgM=
fyne.io/fyne/v2 v2.6.2/go.mod h1:9IJ8uWgzfcMossFoUkLiOrUIEtaDvF4nML114WiCtXU=
fyne.io/systray v1.11.0 h1:D9HISlxSkx+jHSniMBR6fCFOUjk1x/OOOJLa9lJYAKg=
fyne.io/systray v1.11.0/go.mod h1:RVwqP9nYMo7h5zViCBHri2FgjXF7H2cub7MAq4NSoLs=
github.com/BurntSushi/toml v1.4.0 h1:kuoIxZQy2WRRk1pttg9asf+WVv6tWQuBNVmK8+nqPr0=
github.com/BurntSushi/toml v1.4.0/go.mod h1:ukJfTF/6rtPPRCnwkur4qwRxa8vTRFBF0uk2lLoLwho=
github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/felixge/fgprof v0.9.3 h1:VvyZxILNuCiUCSXtPtYmmtGvb65nqXh2QFWc0Wpf2/g=
github.com/felixge/fgprof v0.9.3/go.mod h1:RdbpDgzqYVh/T9fPELJyV7EYJuHB55UTEULNun8eiPw=
github.com/fredbi/uri v1.1.0 h1:OqLpTXtyRg9ABReqvDGdJPqZUxs8cyBDOMXBbskCaB8=
github.com/fredbi/uri v1.1.0/go.mod h1:aYTUoAXBOq7BLfVJ8GnKmfcuURosB1xyHDIfWeC/iW4=
github.com/fsnotify/fsnotify v1.9.0 h1:2Ml+OJNzbYCTzsxtv8vKSFD9PbJjmhYF14k/jKC7S9k=
github.com/fsnotify/fsnotify v1.9.0/go.mod h1:8jBTzvmWwFyi3Pb8djgCCO5IBqzKJ/Jwo8TRcHyHii0=
github.com/fyne-io/gl-js v0.2.0 h1:+EXMLVEa18EfkXBVKhifYB6OGs3HwKO3lUElA0LlAjs=
github.com/fyne-io/gl-js v0.2.0/go.mod h1:ZcepK8vmOYLu96JoxbCKJy2ybr+g1pTnaBDdl7c3ajI=
github.com/fyne-io/glfw-js v0.3.0 h1:d8k2+Y7l+zy2pc7wlGRyPfTgZoqDf3AI4G+2zOWhWUk=
github.com/fyne-io/glfw-js v0.3.0/go.mod h1:Ri6te7rdZtBgBpxLW19uBpp3Dl6K9K/bRaYdJ22G8Jk=
github.com/fyne-io/image v0.1.1 h1:WH0z4H7qfvNUw5l4p3bC1q70sa5+YWVt6HCj7y4VNyA=
github.com/fyne-io/image v0.1.1/go.mod h1:xrfYBh6yspc+KjkgdZU/ifUC9sPA5Iv7WYUBzQKK7JM=
github.com/fyne-io/oksvg v0.1.0 h1:7EUKk3HV3Y2E+qypp3nWqMXD7mum0hCw2KEGhI1fnBw=
github.com/fyne-io/oksvg v0.1.0/go.mod h1:dJ9oEkPiWhnTFNCmRgEze+YNprJF7YRbpjgpWS4kzoI=
github.com/go-gl/gl v0.0.0-20231021071112-07e5d0ea2e71 h1:5BVwOaUSBTlVZowGO6VZGw2H/zl9nrd3eCZfYV+NfQA=
github.com/go-gl/gl v0.0.0-20231021071112-07e5d0ea2e71/go.mod h1:9YTyiznxEY1fVinfM7RvRcjRHbw2xLBJ3AAGIT0I4Nw=
github.com/go-gl/glfw/v3.3/glfw v0.0.0-20240506104042-037f3cc74f2a h1:vxnBhFDDT+xzxf1jTJKMKZw3H0swfWk9RpWbBbDK5+0=
github.com/go-gl/glfw/v3.3/glfw v0.0.0-20240506104042-037f3cc74f2a/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=
github.com/go-resty/resty/v2 v2.16.5 h1:hBKqmWrr7uRc3euHVqmh1HTHcKn99Smr7o5spptdhTM=
github.com/go-resty/resty/v2 v2.16.5/go.mod h1:hkJtXbA2iKHzJheXYvQ8snQES5ZLGKMwQ07xAwp/fiA=
github.com/go-text/render v0.2.0 h1:LBYoTmp5jYiJ4NPqDc2pz17MLmA3wHw1dZSVGcOdeAc=
github.com/go-text/render v0.2.0/go.mod h1:CkiqfukRGKJA5vZZISkjSYrcdtgKQWRa2HIzvwNN5SU=
github.com/go-text/typesetting v0.2.1 h1:x0jMOGyO3d1qFAPI0j4GSsh7M0Q3Ypjzr4+CEVg82V8=
github.com/go-text/typesetting v0.2.1/go.mod h1:mTOxEwasOFpAMBjEQDhdWRckoLLeI/+qrQeBCTGEt6M=
github.com/go-text/typesetting-utils v0.0.0-20241103174707-87a29e9e6066 h1:qCuYC+94v2xrb1PoS4NIDe7DGYtLnU2wWiQe9a1B1c0=
github.com/go-text/typesetting-utils v0.0.0-20241103174707-87a29e9e6066/go.mod h1:DDxDdQEnB70R8owOx3LVpEFvpMK9eeH1o2r0yZhFI9o=
github.com/godbus/dbus/v5 v5.1.0 h1:4KLkAxT3aOY8Li4FRJe/KvhoNFFxo0m6fNuFUO8QJUk=
github.com/godbus/dbus/v5 v5.1.0/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=
github.com/google/pprof v0.0.0-20211214055906-6f57359322fd h1:1FjCyPC+syAzJ5/2S8fqdZK1R22vvA0J7JZKcuOIQ7Y=
github.com/google/pprof v0.0.0-20211214055906-6f57359322fd/go.mod h1:KgnwoLYCZ8IQu3XUZ8Nc/bM9CCZFOyjUNOSygVozoDg=
github.com/hack-pad/go-indexeddb v0.3.2 h1:DTqeJJYc1usa45Q5r52t01KhvlSN02+Oq+tQbSBI91A=
github.com/hack-pad/go-indexeddb v0.3.2/go.mod h1:QvfTevpDVlkfomY498LhstjwbPW6QC4VC/lxYb0Kom0=
github.com/hack-pad/safejs v0.1.0 h1:qPS6vjreAqh2amUqj4WNG1zIw7qlRQJ9K10eDKMCnE8=
github.com/hack-pad/safejs v0.1.0/go.mod h1:HdS+bKF1NrE72VoXZeWzxFOVQVUSqZJAG0xNCnb+Tio=
github.com/jeandeaual/go-locale v0.0.0-20250612000132-0ef82f21eade h1:FmusiCI1wHw+XQbvL9M+1r/C3SPqKrmBaIOYwVfQoDE=
github.com/jeandeaual/go-locale v0.0.0-20250612000132-0ef82f21eade/go.mod h1:ZDXo8KHryOWSIqnsb/CiDq7hQUYryCgdVnxbj8tDG7o=
github.com/jsummers/gobmp v0.0.0-20230614200233-a9de23ed2e25 h1:YLvr1eE6cdCqjOe972w/cYF+FjW34v27+9Vo5106B4M=
github.com/jsummers/gobmp v0.0.0-20230614200233-a9de23ed2e25/go.mod h1:kLgvv7o6UM+0QSf0QjAse3wReFDsb9qbZJdfexWlrQw=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/nfnt/resize v0.0.0-20180221191011-83c6a9932646 h1:zYyBkD/k9seD2A7fsi6Oo2LfFZAehjjQMERAvZLEDnQ=
github.com/nfnt/resize v0.0.0-20180221191011-83c6a9932646/go.mod h1:jpp1/29i3P1S/RLdc7JQKbRpFeM1dOBd8T9ki5s+AY8=
github.com/nicksnyder/go-i18n/v2 v2.5.1 h1:IxtPxYsR9Gp60cGXjfuR/llTqV8aYMsC472zD0D1vHk=
github.com/nicksnyder/go-i18n/v2 v2.5.1/go.mod h1:DrhgsSDZxoAfvVrBVLXoxZn/pN5TXqaDbq7ju94viiQ=
github.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e h1:fD57ERR4JtEqsWbfPhv4DMiApHyliiK5xCTNVSPiaAs=
github.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e/go.mod h1:zD1mROLANZcx1PVRCS0qkT7pwLkGfwJo4zjcN/Tysno=
github.com/pkg/profile v1.7.0 h1:hnbDkaNWPCLMO9wGLdBFTIZvzDrDfBM2072E1S9gJkA=
github.com/pkg/profile v1.7.0/go.mod h1:8Uer0jas47ZQMJ7VD+OHknK4YDY07LPUC6dEvqDjvNo=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/rymdport/portal v0.4.1 h1:2dnZhjf5uEaeDjeF/yBIeeRo6pNI2QAKm7kq1w/kbnA=
github.com/rymdport/portal v0.4.1/go.mod h1:kFF4jslnJ8pD5uCi17brj/ODlfIidOxlgUDTO5ncnC4=
github.com/srwiley/oksvg v0.0.0-20221011165216-be6e8873101c h1:km8GpoQut05eY3GiYWEedbTT0qnSxrCjsVbb7yKY1KE=
github.com/srwiley/oksvg v0.0.0-20221011165216-be6e8873101c/go.mod h1:cNQ3dwVJtS5Hmnjxy6AgTPd0Inb3pW05ftPSX7NZO7Q=
github.com/srwiley/rasterx v0.0.0-20220730225603-2ab79fcdd4ef h1:Ch6Q+AZUxDBCVqdkI8FSpFyZDtCVBc2VmejdNrm5rRQ=
github.com/srwiley/rasterx v0.0.0-20220730225603-2ab79fcdd4ef/go.mod h1:nXTWP6+gD5+LUJ8krVhhoeHjvHTutPxMYl5SvkcnJNE=
github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/ulikunitz/xz v0.5.13 h1:ar98gWrjf4H1ev05fYP/o29PDZw9DrI3niHtnEqyuXA=
github.com/ulikunitz/xz v0.5.13/go.mod h1:nbz6k7qbPmH4IRqmfOplQw/tblSgqTqBwxkY0oWt/14=
github.com/yuin/goldmark v1.7.8 h1:iERMLn0/QJeHFhxSt3p6PeN9mGnvIKSpG9YYorDMnic=
github.com/yuin/goldmark v1.7.8/go.mod h1:uzxRWxtg69N339t3louHJ7+O03ezfj6PlliRlaOzY1E=
golang.org/x/image v0.24.0 h1:AN7zRgVsbvmTfNyqIbbOraYL8mSwcKncEj8ofjgzcMQ=
golang.org/x/image v0.24.0/go.mod h1:4b/ITuLfqYq1hqZcjofwctIhi7sZh2WaCjvsBNjjya8=
golang.org/x/net v0.35.0 h1:T5GQRQb2y08kTAByq9L4/bz8cipCdA8FbRTXewonqY8=
golang.org/x/net v0.35.0/go.mod h1:EglIi67kWsHKlRzzVMUD93VMSWGFOMSZgxFjparz1Qk=
golang.org/x/sys v0.30.0 h1:QjkSwP/36a20jFYWkSue1YwXzLmsV5Gfq7Eiy72C1uc=
golang.org/x/sys v0.30.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/text v0.22.0 h1:bofq7m3/HAFvbF51jz3Q9wLg3jkvSPuiZu/pD1XwgtM=
golang.org/x/text v0.22.0/go.mod h1:YRoo4H8PVmsu+E3Ou7cqLVH8oXWIHVoX0jqUWALQhfY=
golang.org/x/time v0.6.0 h1:eTDhh4ZXt5Qf0augr54TN6suAUudPcawVZeIAPU7D4U=
golang.org/x/time v0.6.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f h1:BLraFXnmrev5lT+xlilqcH8XK9/i0At2xKjWk4p6zsU=
gopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=

```

`ui/internal/assets/appicon.go`:

```go
// auto-generated
// Code generated by '$ fyne bundle'. DO NOT EDIT.

package assets

import "fyne.io/fyne/v2"

var AppIcon = &fyne.StaticResource{
	StaticName: "AppIcon.ico",
	StaticContent: []byte(
		"\x00\x00\x01\x00\b\x00\x10\x10\x00\x00\x00\x00\x00\x00\f\x01\x00\x00\x86\x00\x00\x00\x14\x14\x00\x00\x00\x00\x00\x00.\x01\x00\x00\x92\x01\x00\x00\x18\x18\x00\x00\x00\x00\x00\x00~\x01\x00\x00\xc0\x02\x00\x00  \x00\x00\x00\x00\x00\x00\xc0\x01\x00\x00>\x04\x00\x00((\x00\x00\x00\x00\x00\x00a\x02\x00\x00\xfe\x05\x00\x0000\x00\x00\x00\x00\x00\x00\xdb\x02\x00\x00_\b\x00\x00@@\x00\x00\x00\x00\x00\x00]\x04\x00\x00:\v\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\f\x11\x00\x00\x97\x0f\x00\x00\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x10\x00\x00\x00\x10\b\x06\x00\x00\x00\x1f\xf3\xffa\x00\x00\x00\x04sBIT\b\b\b\b|\bd\x88\x00\x00\x00\xc3IDAT8\x8dÍ‘\xbf\nAq\x14\xc7?\xe7woW\x11\x97\x92A\xfe\x94\xc5p\a\x19\xac\x16\xcf\xc0\v\xb0{\x03Ym\xd7n\xf4JÊ¢\xa4lt\xdd\x14\xcb\xe5X\f\x14\xc5\x1dä»œN\x9dÏ§s:\x12\fzcT\x87\x88d\xf9&\xaa\aD\xa6\x12\xf4\xbb\xc1\xd7\xf0\x83\xc4Ä†\x01D\xb2&6|\xcf\x1f\vl\xaf\xf1T\xdf\xce=6\xe9Ñ„h\xb9@2.\x97\xed\x06\xa7\xd9B\xcf'\x9cf\x8bh\xbd\xc2*\x96\x11\xc7\xe14\x9f\xbd\xde\xe0\xba\xdfq=\x86\xd8\xd5\x1a&\x99B\xdc\x1c&_\xc0\xae{$\xda\x1d\xb8DX\xa5\xca\xd3\x06\x12\fz\xfaé½¯\xf2\xc7_\xf8\x9d@\xd10.\xachh\x04\xf1\xe3H\x14\r\x05\xf1o\x04\x057V(\x06\u009b\x00\x00\x00\x00IEND\xaeB`\x82\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x14\x00\x00\x00\x14\b\x06\x00\x00\x00\x8d\x89\x1d\r\x00\x00\x00\x04sBIT\b\b\b\b|\bd\x88\x00\x00\x00\xe5IDAT8\x8d\xedÑ±j\x02Q\x10\x85\xe1\x7f.z\xb3k\xa1BR\bi\xb6\xb7\xd0\a\xb0\xb1L\x95\x80`a\x1b[A\x9f\xc0\xbcA\x8a\xb4\xbe\x94\x8d\xa0 h\x88Al,\x12\x94Uw\xc7\xc2X\b\x06${\x9b\x80\xa7\x9aa\xe0\xe3\xc0\xc8\xf2\xb9\xfe\x84h\x17\xa4L\x92(\x13\xa0\x93\x02^A\x82D\x18\x80\x10\x80v\xcdap\x15)\x1bw\xd8!W\xd01x\xf3\xf0H\xa6\xd9\"U,\x01`+Ul\xa5\n\x80_k\\\x04Ê²Y\xd7\xe3\xe2\xd7\x1a\x98\xc2=\xfa\xfd\x85\xb9\xbdC<\x0f\xddn!\x8a\x88\x17s\xf0|L6\x87XK\xbc^cry\xa2\xcf\x0fV\xbd\xb7\xf3\r\x01\xe2\xf9\x8c\xddx\x88\x86\xe1\xe9\xe1\a\xd30D7\x1bv\xa3\x01\x92\xb6D\xb3\xf7\xdf\x1b\xba\xc8?\xfb\xf2\x15\xfc#\xa8:u\xa6)}\x03\xd2F\xe9'\xc7t\n\xbc\xec\x01\xdc\xc7C\xf2\xc8ÓŠ\xd6\x00\x00\x00\x00IEND\xaeB`\x82\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x18\x00\x00\x00\x18\b\x06\x00\x00\x00\xe0w=\xf8\x00\x00\x00\x04sBIT\b\b\b\b|\bd\x88\x00\x00\x015IDATH\x89\xed\xd2?KBQ\x1c\xc6\xf1\xef\xefx\xbd\xe6\x7f\x1aB\x8aj\x88\xa8\xa0\xa0=\x1ctj\x12\x03\xa3!h\xb3)\xa2\b\x82\x86\xa6^\x81\xbd\x89\xb6\xa0K\x83\xf4\x12\"\x82\x1aZ\x1a\x8463\xc8@\xc1?\xd9=\r\xd2\r2\x8cÊ»\x88\xcft8\xfcx>\x87s\x8e\x94\xb3\xab\t\xb4\xdaAX\xa1\x97Ñœ!\xf6\xb1\x01\xb2\x8b\x90\xeei9\xd0>\xb0\x88\x02\xe9}\xf9\xa7\x92V\ue5773\x00\x06\x80\v\x80\x19O\x12\xda;ÄŸYw\xf6\x02\xd9mg\x1d>8\xfa\x15`|\xdd\xf0\xc4Fy{(P;=!\xb8\xb5\x8fn\xd4Ûƒ\xf3\x8b\f-\xa7Pc\x13\x98\xf1$\xc6\xdc\x02x\xbd\x88\xf2`?=\xa2Fb\xb4\n\xf74\xf2Vw\xe0\xa3,4>\x89D\x87\x01\x90@\x10\x15\x89R\xbf8'\xb0\xb1\x89\x84#P\xafaLÏ¢_\x9e\x11\x9f\x0f1M|K\x89\x0e\xe0\xdb7h\xdd\xddÒ¼\xbeDW+\xe8j\x05\x00\xbbTÄŸ\xca ^\x13cj\xc6\xc1u\xb3\x89]*\x02\xf0zs\xd5\xd1%\xe5\xec\x9a\xeev\x87\xffM\x1f~\xd3\x01Ğ—\x80\xb6~\x1e\xfbk\xb4\xa5@\xe7\xdcA\xb4\x05:\xf7\x0e\x92\xc2PZ\x90\xa4.\xf5\x00\x00\x00\x00IEND\xaeB`\x82\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00 \x00\x00\x00 \b\x06\x00\x00\x00szz\xf4\x00\x00\x00\x04sBIT\b\b\b\b|\bd\x88\x00\x00\x01wIDATX\x85\xed\xd3;K\xc3`\x14\xc6\xf1\xffI\xd2\xd4^ÄŠ\xf7E\x1c\x04\a\a\xbf\x80 \x0e\x0e\x82\xd0B\xc0\xa1\x8b\x0e\xae\x82\xba\xb8\x14\aqq\xa9~\n7\xa1\xb89\xb9\xb8\xb9\xf8\t\x84\"hu\xd1\xd8x!%=\x0e^ hE\x90\xa6\x0ey\xb6\x9c\xbc\xc9\xf3Ë›D\xee\x96\v9\xcc\xc4\x1eP@$G\x14Q\xbd\a*\x04\x8du\v\xd3\xdeGX\x8a\xa4\xf8#o\x0f\xba\x8ci\x8b\x01\x9a\x8f\xb4<\x14\xcd\x1b\x91m\xfbw\x11\xc9\x19\x1d+\x7fO\f\x88\x011 \x06\xb4\x04$\xe7\xf3\xa4\x9c\"\xf6\xf4lh\x9er\x8aX\x93S\x9f\xc7\xe9\x95\xd5?\x01\xac\x96\x80\x999\x9a\xb7\xb5/\xf3\xe0\xe6:|\x83\xf1\x89\xf6\x00\x00\x82\xea\x05\xc1\xcd5\xdd[\xbb\x00\xa8W\xff\x9c\xa7\x9c\"\xeaÕ‘t\x06\x80\xecF\t\xa3\xb7\x8f\x97\xe3#\xba\x16\x1c\x9a\xb75\x9a\x0f.f\xff\x00\xd8I\xeaÛ›\xdfv\xfc\xea\x1bP\xaf\x8e$\xec\xd0L\xd2\x19\xbc\xf2\x0e\xfa\xf4\x18z%\xe6\xd0\b\x00^y\ak|\x02\xf5\xfd/\xd7\xfe\x1a\xf0|x\x80\x7fz\x8218L\xe3\xfc,|\xb2\xd1 \xbbQB\xd2\x19\xcc\xd11\x8c\xc1aH$BK\x82\xcb*b\xdb\x04\xb5\xab\x96\x1dr\xb7\xb2\xa8?!Ú\xff\xfb\x1bÆ€\x18\x10\x03b@d\x00E\xddN\x95+\xea\x1a\xa2R\xe9\x14@T*\x16\x81\xbf\x86i\xa3\xa2\x05Az\xa2(V\xd4\x15\x95\n\x81\xbf\xf6\n5\xbei\x9dL\x9d\x15`\x00\x00\x00\x00IEND\xaeB`\x82\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00(\x00\x00\x00(\b\x06\x00\x00\x00\x8c\xfe\xb8m\x00\x00\x00\x04sBIT\b\b\b\b|\bd\x88\x00\x00\x02\x18IDATX\x85\xed\xd4?h\x13a\x18\x80\xf1\xe7\xbb\xfci\x9b\x884K\x8d\rf\x12*\xa4\x98\xaa\xa4`\x145\x938\x88J\xa1C\xc7\xeaÖ‚\xe2Ô¡H\x05\x87N\"\xe8\x187')\xa8\x93\xe0\x94,]\x04\x89R\a\xa9-!T\x11Ô¦Il$\x97Ü½\x0e\a\xa1!\xbd\x94r\xeau\xb8g\xbb\xef\xfd\xb8\xfb\xddqw\n\xa0|s\xf2:Jn#\x8c\xa1\xd4 \xae'9\x90\xfb\x91\xecRNY8^\xb8M\xda=3\xa3\xa1\xe4\x8e\xdb\f\xfbÔ‚\x06\xea\xa2\xdb\fÛ„\xa4æ¶¡gJ\r\x1el \xe0\x01\x9d\xe6\x01\x9d\xe6\x01\x9d\xe6\x01\x9d\xe6\x01\x9dv\xe0\x81\xfe^\xc3\xe0\xf9\f\xc1\xf1s\x00\x98\xd5\n\xf5\xec\xe3\x8eyß•k\x04\x93g\xa8-\xdek\xaf\x1d\xba;\x0f\xc0\xaf\x87\x0f\xfe=\xd0w\xe4(\xbeX\x1c}9\x87Y\xdf\xee\x9a7^\xbfBjÕ¿\x02\xb1\xab'pgR\xab201E0}\xc9:n\xea4\xdf.\x13H\xa51Ë›\x84\xa7g\x90\xa6\x8e\n\x851\x8ak\xd6\xd3M\xa5Q\xa10\xad\x95\x02\xdaP\x14_,\x8e4uZ\x9f?\xe1?>\x02@k\xa5@\xfdY\xd6\xf6\xba{\xbe\x83*\x14\"\x90J\xe3?1\x8a\x16\x8daVÊ´\xd6W;\xf6\x04\xcf^\xc0\xfc\xfe\x8d\xea\xdc,Fq\r\x00\xa3T\xc4\xf8\xba\x81Ô·\xf1\x8f\x8e\x01\xb4\xf7\x04N\x9eF\xb66;fv\xed\xf9\x04\xcd\xca\x16Õ¹Yks\"Ixz\xa6\xfb&\xfa\xfa\xbb\xd6\x06&\xa60\x7f\xfe\xc0X_m#D\xd7\xdbsc\xa3\x84\xfc\xae\xef\xfa\xea\xecl__q\xff\xe5\xab\x18_J\xb4>\xbe\xefXo\xe4Ş \r\x1f\xe3\xf0\xe2\x13\xb4\xa1\xa8\xb5\xa87\xf0E\x87\xf1\x8f$\xba\xce\xd3\xfc\xf0\x8e\xc0\xa9q\xfc\x89$\xbeX\xbc\xe75U\xf9Ö¤\xec\a\xf9\xbf;\xf0\xffA\x0f\xe84\x0f\xe84\x0f\xe84\x0f\xe84\x0f\xe84\x0f\xe8$A*\x1aH\xdem\x88]\n\n\x1a\xa2\x1e\xb9\r\xb1O\x16\xb4\xc8\xd3\xe7/\x11n\x80\xe4\x05\xa9\xb8M\xb2\x92<\x98\x99Hv)\xf7\ag\x86\xae\x80\x97HSg\x00\x00\x00\x00IEND\xaeB`\x82\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x000\x00\x00\x000\b\x06\x00\x00\x00W\x02\xf9\x87\x00\x00\x00\x04sBIT\b\b\b\b|\bd\x88\x00\x00\x02\x92IDATh\x81\xed\x95_HSQ\x1c\x80\xbfs\xdd&\xcd?mD\x11\x04\x05\xbd\x89\xd9*)\x1f\n\xaa\x97\xe8\xad|È‚\nV*\x11-\x12!\xf2Az\b\x1f\xf6$F\xeeimeQ\xe0\"\xb2\xb7\xdeB\x10A,PB\x82\xc0\x90 \x88\xccÜ¦\x9b\xb4\xab\xfb\xf5\xb0\x18\xcc\x19Î«p\x14\xee\xf7x\xee9\x87\xef\xbb\xf7\x1c\xae\xe2\x1f\xb3\xcdM\xe7Qr\a\xe1\x10JyØŒ\x88\xc4Q\x8c!\xea\xa17\x12\x1b\x00P\x00\xb3\xcd\x17\x9e\xa0\x94_\xab\xdcZ\x11yê¼\xba\xa6ro\x9e7\xba},!4\x1a(i\xd3\xeda\x19%m\x06\xa8\x93\xba=,#\xf8\f\xdd\x0e\xebB)\xcf\xd6\x0e\x00\xec\x00\xdd\xd8\x01\xba\xb1\x03tc\a\xe8\xc6\x0eĞ\x1d\xa0\x9b\r\rp\x9d8\xbd\x91Û•\x84\xa3\x94I\xd5\xc1^\x8c\x1d;\x01\xc8\xceL\x93\xec\b\xac8\xcf}\xb9\x19\x80\xcc\xd0\xfb\x82\xb5\xe6\xe80\v\xaf_\xae\xd7uEJ\n\x00\xf8\xf3\xee\xed\xaa\x12\xf1\x9bW\xd6-\xb4VJ\x0eXNe{'e{\xf6\x82\xd3\xc9\xd2\xd4$\xf3\xdd]x\xc2\xfd\xc4[/\xe2n\xb9\x8d\xf3\xe0\x11$\x9dB\xb9+\xf2k\xaa\x83\xbd\x00(\xa7\x8bT4\xc4\xe2\xc48\x9ep?Ù™i\xb2?\x7f\x90M&p\xd6\xd4\x01`~\xfeD\xfa\xf1\xa3U=J\xbe\x03\xe5g\xcf\xe1\t\xf7S\xd9\xde\t\x80\xa3\xa6\x8eT4\xc4\xd2\xd4d\xd1\\W}\x03\v\xb1gEG-\xd9\x11 \xd9\x11@\xd2)\\\x87\x8f\xe6\xc7\xcd\xd1aæ»»p\xd57\x90\x8a\x86HEC\xb8\xea\x1bJ\xf2\xb2|\x84Ì±\x0fT\\\xbf\x95\xff\x02\x85\xbb:\xf3\xf7@Ò©\xdcP\xad\x0f\xf7%?bfP\xdb=\x18\xbbv\xe7\xa7\xe7\xf7u8q_m\x05 \x9b\x88ol\xc0r\x8c\xaa*\x96\xbe\x7f\xfb\xffÆµ>\x80\xfc\x11*?u\x0613\xcc=\xb8\x97?JE,\x9a\xa4\x9f\x87Y\x9c\x18/\xd9\xc3R\x80\xa3\xd6GÙ¾\xfd\xa4_Dp\x1d;^\xf4<32De\xe0.\xd9_\xd3`\x9a9\xb7\xaf_\xd8v\xc0Gu\xb0\xb7\xe0^\x14\xac\xfb8BÅ6$\x9dB\u2fd9\v\xde_\xd5EÍ¶4\x89\x95\x88Í‚\xfd'Ö\x1d\xa0\x1b;@7v\x80n\xec\x00\xdd\xd8\x01\xba\xb1\x03t\xb3\xf5\x03\x04Iè–°\x8a \tC\xc1\x98n\x11\xab(\x183\x10Õ£[\xc42\xa2z\fo$6\x80Ğ§\xdbe\xcd\b}\xdeHl\xc0\x00\xf0Fb~\x84F\x90\xc1\xcd|'rn2\x88\xd0\xe8\x8d\xc4\xfc\x00\x7f\x01E0\xdc(\n=\x8d\xde\x00\x00\x00\x00IEND\xaeB`\x82\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00@\x00\x00\x00@\b\x06\x00\x00\x00\xaaiq\xde\x00\x00\x00\x04sBIT\b\b\b\b|\bd\x88\x00\x00\x04\x14IDATx\x9c\xed\x9b\x7fH\x9cu\x1c\xc7_\xdf\xe7\xb9{NO=o\x8d-\x97\xb8$\x8ds\xacQĞš0\x05\r\xb2\xda(\x16[fH4\xcb\x1b\f\x9a\x8c\xa4\x81\x7f\xd8\xfe\x18\x11\xc6\"\x169\x18\xe8FJ\x18&\x16n\x10F\xc1(\x8cX9RJ\xda\x18\xf5G\xb4e9\xdbfz\x97\xf7\xe3\xf9\xf6\x87\xf3\xf0NNv\xa2~`<\xaf\xbf\xbe\xcf\xf7\xf3|\xbf\xcf\xeb\xde\xcf\xf7\xbe<\xc7\xc3)\x16\xf0Ï«\xb5\x95JÑ¨QÛ•\xe2!\xee\"\xb4\xe6g\x85\x1eÖš\xd3\xf7\x9c\xe9\x1b\x9a\xefW\x00\xd3\r\xb5\x05QS\xb5\x81~\x19\xa5\x94\x9c\xe6\x1a\xa0\xb5F\xa9\x0f\xcdH\xf4\x88\xaf\xfb\xb3I\x17@\xc4\xc5\t\x05u\xb7\U000f8ed9\xbb\xc1\xaf\xc4\xddn\x03hP\xb7\x1a\x9f\x7f\xd1V\xc6\xc7\xd2^\x12\x18\xb6\xbdÛˆ+\xa3AZD\x8a\xb8a\x1c6\x94\xd6e\xd2\"R(\xad\xcb\f\x14\x05\xd2\"b(\n\fP\x1ei\x0f9\x94ÇV\x90\xc6\t@Z@\x1a'\x00i\x01i\x9c\x00\xa4\x05\xa4q\x02\x90\x16\x90\xc6\t@Z@\x1a'\x00i\x01i\x9c\x00\xa4\x05\xa4q\x02\x90\x16\x90\xc6\t@Z@\x9a5\t\xc0\x1bl\"\xb7\xb95m\xdd\xdfÑ»d}5qe:\xc0\xd7Ö\xb1~CR\xdf\xec\xe0\x00\xe1\xfe\x9e\xf4\x17\xb9\xff\x01\x947's\xbb5 \xe3\x00\xe6\x99\x1d\x1cH\xb4\xa3\x97Æ–<w\xea\xcd×—{\x99Ug\xd9\x01\xa4\xdeq\xd7Ö‡\xc9\xdeW\x8fYT\x9c\xe8\x8b\xfd\xf2\x13\xd3ï½…\xaf\xad\x1d\x80\xa9\x96C\x00\xe4\xb5\x1c\xc3,\t@,J\xe4â…¤y\U0008ef83\xb9\xa9\x10\\nt8D\xf4\xfbo\t}\xd4Ins+\xae-Ûˆ\xffz\x19\xb3$\xc0\xec\xe0\x00vh\x06OU\xcdÜŠ\xbc=W\xa8\xf3\x83\x8c>ÇŠ\xed\x01\x9e\xea'1\x8b\x8a\t\x7f\xda\xc3\xcd\x03ui\xcf\xcbmn\xc5,\t\x10\x1d\x19f\xf6\xab\xcfq\x95\x06\x92\xea\xcam\x11>\xdbG\xa8\xeb\x14D\xa3X\x15Õ‹\xe6\xb8y\xa0\x8ep\x7f\x0fY\xbb\x9e\x83h\x94\xe9\x13o\x13\xbbr\t\xab\xbc\x12\xab\xf2\U0004cf17\xbd\x02\xfc\x1d\xbdIBw\x8aY\xb8\x19{\xfc\x1a3'\x8f\x03\x10\xff\xebO\xbc\xfb\x0f&\xea\v\xbf.Ö\n\\[\xb6%\x8d\x0f\x9f\xeb\a\xc0\xfbR\x10\x95\xed%\xfcI7\xb1\xb1Q\xa6\xc7F\xf1w\xf4b\xed\xa8 2t\xfe\x8e}Vd\x0f\x00\x989y\x9c\xbc\x96cd\xef\xad'{o}\xdaqÊ—O\xfc\xea\xef\x89\xe3\xc8\xd0\xf9\xa4\x00\xbc\xc1&\\\xa5\x01\x947\a\x95\xed]4>66\n\x80\xb1q\ue35ew\xff\xc1\xa4\xf1\x99\xb2b{\x00\x80\xb1\xa1\x00{r\x82\xa9\x96CI+d!:\x1c\xc2X\xb7>q\xecÙµ'\xd1\xf6\x06\x9b\xb0\xca+\x89|\xfd%\x91\x1f\x7f \xeb\xa9g\x17\xad\x80y\xec\xa9[\x00\x84\xbaNet\xc7SYv\x00\xa9x\x83M(_>\x91\x94\x95\x91\x8a}\xfdoÌ¢br^;\x82=~\x15kgu\xa2f\xf8\xf2\x13mw\xd9V\xcc\xc2\xcdi\xe7\x89|\xf7\rÖ£\xe5d=\xb3\x0f\xf3\xdeM\x00\xb8\x1e,\xe3ß¶\xa3\x19y\xaf\xd8&\xe8*\r\xa0Ã¡%\x9f\a`n\xe5Ø“\x13\xb8\x1fÙUUC\xec\xb7+\x89\xda\x7f_\x9cÃ\x9c\xc0\xaa\xaa\xc1\xfd\xd8N\xec\x89\xf1\xb4\xf3\xc4\xc6F\t\x9f\xedC\xb9-<O\xef\xc1\xf3\xc4n\xb02\x7fÏ«n\x04_\xd0\x19\x8f\xba\x8bp~\vH\vH\xe3\x04 - \x8d\x13\x80\xb4\x804N\x00\xd2\x02\xd28\x01H\vH\xe3\x04 - \x8d\x13\x80\xb4\x804N\x00\xd2\x02\xd28\x01H\vH\xe3\x04 - \x8d\xa1\xb5\xbe,-!\x85\xd6\xfa\x82\x81bDZD\x0e5b\x18\xb6\xfd\xae\xb4\x86\bZ\xc7\r\xa5;\f\xff\x99\xfea4]\xd2>\x02\xb4\xfb;\xfb.\x1a\x00\xa6i\xbe\x01\\\x17\x16Z34\xfa\x0f\xbf\x87VH\xf9\xb7\xf4\x8d\xc6\xda\xc3(\x1a\x80\xfb@m\x94\x90[-\xb4\xd6\xe3J\xa9khİ½\xeet\xdf\xfb\xf3\xfd\xff\x03\xd8\xf0+\x90DaZ\xb9\x00\x00\x00\x00IEND\xaeB`\x82\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x01\x00\x00\x00\x01\x00\b\x06\x00\x00\x00\\r\xa8f\x00\x00\x00\x04sBIT\b\b\b\b|\bd\x88\x00\x00\x10\xc3IDATx\x9c\xed\xdd\x7fl\xdc\xf5}\xc7\xf1\xd7\xe7{\xe73\xbe$\xfe\x914SH\bD\x01FP\xe8\f\xe3G(\xb1\x80LBM\xa6\x82\x01c\xa0\x19\x1d%8\x1d\x12D\x9a\x90\x18TJQË˜\x06\xcaÖ©\x03\xfe\x01\x03YA\x19Ô¤\x10\xe8 \x88j\x94\rR\nc\xd4K\xa2\x84\x06PB \xa4\r\x8ec;\xb1\xb1\xef\xc7g\x7f\x18\xbbv\xee{\xf6\xddÙ¾\xbb\xf8\xfd|H\xfc\xe1\xaf\xef\xee\xfb\xe1\xe2\xef\xf3\xbe\xbf\xcfi\x12u\xdd\xda|F\xda\xf9F\xaf\xe0\f\xe7\xfd|9w\xb2\x97\x9f\xef\xe4\x16L\xe6|\x00\v\xbc\xfcgN\xee\x80\xe4\x0fx\xb9\xcf]\xda\xef\x89D\xd3/W?\xbay\xf7d\xcd\xc3Ml\x80r=k\x9a/N:\xd7(\xf9\xab\x9dsgM\xd6\xc0\x00\x84\xf3\xf2\xbb%\xbd\x10I\xa5_\xa8~r\xf3;N\xf2\x85\xbeV\xc1\x01\xe8\\\xd3|\x95w\xee\x1f\x9c\xd39\x85\xbe\x06\x80\x89\xf1\xf2\xdb\xe5\xf5\xfdÙ\xb7\xfdG!\xcf\xcf;\x00]-7\\\x9c\x92\xff\x17']\\\xc8\f\x01L>\xef\xf5VT\xba\xbb\xfa\U0005ff55\xcf\xf3r\x0e\x80on\x8e\x1d\xa9q\xff$i]Ş£\x03P\x1c\xde\xff\xa4\xb6[\x7f\xe7\xda\xda\x06ryxN\x018\xfc\xbd\xe6S]Jmr\ue889\x8d\x0e\xc0\x94\xf3\xfe\x1d\x1fQ\xf3\xecG\xdb>\x19\xef\xa1\xc1x\x0f\xe8Zs\xdd*\x97\xd2\xfb,\xfc\xc0\tÂ¹\x8b\\J\xefw\xaem\xbelÜ‡f\xfb\x85on\x8etU\xbb\xbf\xf7\xf2\xf7È¹\t\x1d-\x00P\x02Ş§\xbc\xd3\xfa\xbaÖ¶\a\xb3\x1d)Èº\x06\xd0U\xed\xaf\xf5N\xdfg\xe1\aNP\xceE\x9c\xdc?v\xb54_\x9f\xf5!a\x13;\xd76\x9fë½¶9\xb9\xaa\xa9\x1b\x1d\x80b\xf0\xf2}Î§\x97\xd7=\xbe\xf9\xfd\xe3\x7f\x97\x11\x80\x9e[\x9a\xe7&\x02\xf7\x9esZX\x9c\xe1\x01\x98j\xdek\x7fEÚŸ?\xebÉ¶C#\xa7gl\x02$\"z\x88\x85\x1f\x98^\x9c\xd3\xc2DD\x0feL\x1f\xf9C\xd7-M\xcbÒ‘\xc8\xdb\xc5\x1b\x16\x80b\x8a\xb8\xf4\xf2\xeaÇ\xdb6\xf4\xf3\xa85\x80T\x10\xfc\xa4\xf8C\x02P,I\xef6\x8c\xfcy8\x00]\xb7^w\xa3snY\xf1\x87\x04\xa0X\x9c\xdc%]\xb7^w\xe3\x1f\x7f\x96\xe4\u05ed\xaa\xec\xec\x9b\xf9;'wj\xe9\x86\x06\xa0(\xbc\xf6Ö¦\xe2g\xbb\x8d\x1b\xbf\f$\xa9\xbbw\xe6\n\x16~\xc0\b\xa7Eİ‘c\x97K_m\x02\xa4\xe4\xae.\xe9\x80\x00\x14\xd5\xd02\x1fx\xc9\xc9\xf9\xabJ= \x00Eu\xa5\x97\x9c\xebj\xb9\xe1\xe2\xb4\xfc\xafK=\x1a\x00E\xe6\xfcyA\xca{V\xff\x01\x83\xbc\xd7\xca\xc09\xbf\xa4\xd4\x03\x01P|N\xba8\xf0^\xf3J=\x10\x00\xc5\xe7\xbd\xe6\x05\x92jK=\x10\x00%Q\x1bÈ±\x06\x00Xäœ«\r\x9c\\M\xa9\a\x02\xa0\x14|\xed\xb8\xf7\x04\x040]\xb9J\x02\x00\x18F\x00\x00\xc3\b\x00`\x18\x01\x00\f#\x00\x80a\x04\x000\x8c\x00\x00\x86\x11\x00\xc00\x02\x00\x18F\x00\x00\xc3\b\x00`\x18\x01\x00\f#\x00\x80a\x04\x000\x8c\x00\x00\x86\x11\x00\xc00\x02\x00\x18F\x00\x00\xc3\b\x00`\x18\x01\x00\f#\x00\x80a\x04\x000\x8c\x00\x00\x86\x11\x00\xc00\x02\x00\x18F\x00\x00\xc3\b\x00`\x18\x01\x00\f#\x00\x80a\x04\x000\x8c\x00\x00\x86\x11\x00\xc00\x02\x00\x18F\x00\x00\xc3\b\x00`\x18\x01\x00\f#\x00\x80a\x04\x000\x8c\x00\x00\x86\x11\x00\xc00\x02\x00\x18F\x00\x00\xc3\b\x00`\x18\x01\x00\f#\x00\x80a\x04\x000\x8c\x00\x00\x86\x11\x00\xc00\x02\x00\x18F\x00\x00\xc3\b\x00`\x18\x01\x00\f#\x00\x80a\x04\x000\x8c\x00\x00\x86\x11\x00\xc00\x02\x00\x18F\x00\x00\xc3\b\x00`\x18\x01\x00\f#\x00\x80a\x04\x000\x8c\x00\x00\x86\x11\x00\xc00\x02\x00\x18F\x00\x00\xc3\b\x00`\x18\x01\x00\f#\x00\x80a\x04\x000\x8c\x00\x00\x86\x11\x00\xc00\x02\x00\x18F\x00\x00\xc3\b\x00`\x18\x01\x00\f#\x00\x80a\x04\x000\x8c\x00\x00\x86\x11\x00\xc00\x02\x00\x18\x16-\xf5\x00\x90)\xba\xb4^\xb1o\\\xaa\xa0\xbaF\x89]\xdb\xd5\xffÊ–)\x9fgU\xd3jU\xaelÌ˜\x9eÜµ]G\x7f|\xff\x94\xcf\x1f\xa5A\x00\xcaL\xe5\xaaFU]\xd5,E+$IÑ³\xbf\xae\u0605\x97\xa8ç¾»K<2LG\xd3\"\x00\xd5\x0f<\xac`\xce\xdcIy\xad\xfe\xad[Ô·yÓ¤\xbcV!NZu\xf5\xf0\xc2?$\xb2p\x91\xe2-\xeb\xd4\xdb\xfaP\x89F\x85\xe9\x8a}\x00e\xc6U\xc5C\xa7GO[\\\xe4\x91\xc0\x02\x02p\x82\xf0\x89\x81R\x0f\x01\xd3\x10\x01(3\xa9\x8f>Èœ\x98Lh\xe0\xddm\xc5\x1f\f\xa6=\x02Pfz\x1e\xb8W\xc9]Û¥dB\x92ä»»\xd4\xf7b[Q\x8e\x04\xc0\x9ei\xb1\x130\x9bR\xef\xd0+\x14\x87\xddP,\xac\x01\x00\x86\x11\x00\xc00\x02\x00\x18F\x00\x00Ã¦\xf5N\xc0\xa9\x14\xbf\xa9E\x91SN\x95\xab\x9d\x9d\xf7Y\x88cíœœy\xe7zE\xcf\xfez^\xcf\t3t=A\xf4\xb4\xc5r5\xb5\xa3N0Jw\x1cRj\xff>%\xda\xffG\x03o\xbe\x9e\xd7\xd8\xc7\x12kX\xa1\x8a\xfa\v\x14\xcc\xf9\x9a\\|F\xc6\xfb\xe2\xfbzå»(\xb9\xefc\r\xfc\xfa\xbf\x94\xdcÙ\xf3k\xd7>\xf6lÆ´t\xc7!u\xdfs\xc7\xf0\xcf\xf1\x96u\x8a\x9eq\xd6\xf0|}_\xaf\x12ï¼¥Ş§[\xc7|\xed\xb1\xde+\xdfİ¥tW\xa7R\x1f\xef\x19\xf7uND\x04 OUM\xab\x15\xbbìŠ¬gì•ƒ\x19\xb7ß¥\x8as\xea3N)\x1e\x12Ì™\xab`\xce\\U\x9cS\xaf\x8a\xfa\vt\xec\x91\r\x13\x9a\xdf\xf1\v^6\xae*.W\x15Wl\xde|\xc5\xce_\xa6Ä\xf6\t\xcf[\x1a\\\x80\xe37~W\xc1\xbc\xf9\x19\xf3\v\xfedŞ˜\xcf;\xe9\x9bW*zæ’¬\uf56b\xaeQ\xa4\xbaF\x91\x85\x8bTq\xd1r\r\xbc\xf1\xda\tyd)\x1b6\x01\xf20\xf3\xce\xf5\xaa\\\xd9X\xd6\v\xff\xac{\x1fTÅ¹\x17d\xfd\x83\x1e%Z\xa1\x8as/Ğ¬{\xee\x9b\xd0\xfcb\xcb\x1a\xf2\xbf\x16ch\xde\xf7>X\U0003c1c4-\xfc\xe3\xa9\\Õ¨\x19kn\x1f\\\xdb\xca\xe5\xbd\xd2`P*W6*\u07b2\xae\x90a\x96%\x02\x90\xa3xËº\xd0U\xf3r2\xeb\xde\a\x15Y\xb8(\xef\xe7EN?k\xf0S\xb0\x00.>\xa3\xa0\xe7\r\xcf{\xe1\"\u0378\xfd\xae\x82\x9f\x1foYW\xd0\xc2_uU\xb3\\uMA\xf3\x8c-k\x986\x11`\x13 \aÑ¥\xf5\x8a\x9d\xbf,\xf4w\xbe\xafW\x89\xff\xfb_\xf9Î\x8cU\xc3l\xdb\xf3Sa\xe6\x9d\xeb\xc7\\\xf8}_\xaf\xd2_\xfcA\xfeh\x8f$)\xb2\xe0\xd4Q\v@\xe4\xf4\xb3&e\x1c\xbe\xbbK\xe9C\a\x95\xfa\xf4\x13\xf9\xbe\xde\xe1\xe9\xd13\x97(\x98\xbf0t\xed\xa9\xe2\x9c\xfa\x82\xe7W\xf1g\x7f\x9e\xd7\xe3\xa3K\xebC\xaf\xb8\x94$%\x13J\xechW\xfa\xe0g\x92\x06?\xf1#\x8b\xcf\f}_c\xcb\x1a\x94Ü½cR\xf7\xa1\x94\x02\x01\xc8A\xec\x1b\x97\x86\xfe\xc1\xf8\xee.\x1d{â‘¼vfM\x85XÃŠ\xec\xa1I&\xd4\xffË—C\xb7[c\r+TuÍ·\v\xfe$\x1c)\xddqH\x89w\xb7\x8d\xb9}\x1c]Z\xaf\x19knÏœ_\xb4B\xf1\x9bZ\xf2\xde\xc96j\xb3#\x99\xd0\xc0{\xbf\x19\u07b98\xb4c\xcfU\x9e4\xea9\xf1\x1b\xbf\x1b\x1a\xa1\xb1\xfe-\xb3\xdd,\xa5\xf2/V\x12\x80rV\xb9\xb21\xf4\x1f.\x9bl{\xda#_\vß¾M\xec\xda^\xf2\x85_\x1a\xfcC\f\x95L\xe8\xe8\xc3\x1b\xb2\x8eq\xe0\xcd×•\xee<\x1c\xbeP\xe6*\x91\xd0\xc0\x1b\xaf\xe5\xb4\xf0&w\xb6\xab\xef\xf9\x7fW\xfc\xe6\xdb2~\x179\xe5\xd4\xc2\xe6/I\xc9D\xc6\xf5\x12É\xed\x19\xff\xdfUM\xabC7\x17\xc6\vy\xdf\xe6M\n\xe6-\x18Ü·2r\xcc\v\x17)Ö°â„\x00\xfb\x00r\xe0jg\x87N\xf7\x9d\x1dE\x1eI\xb8\xc8\xc9\vB\xa7\xf7\xff\xf2\xe5q\x03\x95\xdcÙ®cO<2|\xf1Q\xbez\x9fÙ˜\xd7'\xf7\xc0\x9b\xaf+\xddq(cz\xb6\xf78\x17\xb9^,Uq\xee\x85\xe1c\xda\xf6\xabqß§c\x8fl\b}\x8f*\xea/\by\xf4\x89\x83\x00\xe4\"Q\xd8\xc2Q\f\xf1\x9bZB7O\xd2\x1d\x87r>\\\x95\xdcÙ®Ô¾\x8f\v\x9a\x7f!k@\xbe\xf7XA\xf3\n\x93Ú¿7\xa7\x85?\xba\xb4>\xf4\xd3?\x9f\xf7)\xf5\xf9g\x19\xd3\"y\xee\x80,7\xd3z\x13`\xb2\xa4;;B\xffx\xca\xe1p`\xb6\xe3\xdc\xc9\x0fC\xee+0\x86\xe4\x9eİ“\xb6#pH\xe5\xaaF\x05\xf1\x19\x8a\x9c\xb6X.\x16\x93\xab\x9d-\x17\x9f\x11\xfa\xbe\x15z4!\xd7\xfb$\xc4\xce\v\xff\xf4O\xedß—\xf3\xbc\x86v\xa0\x8e\xe4jjs~~9\"\x009H\xec\xda\x1e\xba\x93-zÎ¹%\x18\xcdhY\x03\xb0{GQ\xc71\xb4\xd3-2\xff\x14\x055uy\xefS((\xa6\xc9D\xce\xf7I\xc8\xf6>\r\xed\xf1/T9|\bLÄ´\x0e\xc0d\xdd\x0f\xa0\xff\x95-\xaa\xbcìŠŒ\x93]\x829sU\xfd\xc0\xc3\xea\x7fãµ’İ°\xc3U\xc4B\xa7\x17s\xc7\xd4\xcc;\u05cfy6\xddTIw\x1d\xc9\xf9\xb1n\xe6\xac\xd0\xe9\xf9\xee(\x9en\xa6u\x00&S\xefS\x8fi\xe6\x1dwe\xfc\x91\as\xe6\xaa\xea\xdaÕª\xbavuI\xc65\x19\x87\xf0\n\x95\xf5\xb0\xde\x18\x86\xce\r(\xf6'\xe7DOX\x1aKti}Y\x1c\r*\x04\x01\xc8Qrg\xbb\x8e>\xbcA\xf1ï¬\xb4[\x90\x9f\xe8\xe2\xdfY\x9bu\xe1\x1f\xba\x88\xc6\x1f\xedQj\xdf\xc7J\xf7\x1e\x1b^K*\xe6\tR\xc5P\xb1d)\x01\xb0 \xb9\xb3]\xdd\xf7Ü¡X\xc3\n\xc5.Z^\x92\xd5\xder\x11oY\x17\x1a\xc2t\xc7!}\xf9\x8b\xcd\xe5wl\xbc\x8c\x8f\xe4\x94\x12\x01(\x80\x9bU\xadÈ¢\xd3\xcbb\xe1\xf7\xdd]%\xd9\f\b\xfb\x9e\x82\xe3/\xcf\xcd&\xdb\xf6\xf8T\xcav$\xe7D\xbdo\xe4d\xe1<\x80<\r_Hr\xfc6lr\xf0\x8c\xb8#ko\x18\xfe/\xb9k\xfb\x94\x8f'\xdb\xf7\x05T5\xe5\xb7O\"\x92\xe7\x17\x8f\x84-L\xb9\x1ez\x9c\xca\xed\xf1l|\x7f\x7f\xe8\xf4\x13}/\xfeD\x11\x80<D\x97Ö\xfa\u07be\x91\xfa^l+\xc9\r#\xfc\x91Ã¡Ó£K\xf3\xbb\xc0&\xb2 \xf7Sq+W\x85\xef5\xcf\xf5\xccÈ \x04\xc7Î“\x1f\xff.t\xfa\x84NA\x9e\x06\b@\x1e\xaa\x9aV\x87.\xfc\xc9\"}\x83o\x98Ô§\x9f\x84N\x8f\x9c\xbc@\xb1\x86\x159\xbdF\xfc\xa6\x96\xbc6#\x82\t|\x82\xc7[Ö•dÓ©\xff\x95-\xa3\xaeN\x1c\x129mqŞ±\x9cN\b@\x8eb\r+\xc2/\xb7M&\xf4\xe5\xab/\x15}<Cz\x9fn\r?\x8f?Z\xa1\xaak\xbe=\xee\xf3+W5*\xb6\xfc\xf2\xbc\xe6\x99\xcer*\xefx\xf7\x14\xa8\\\u0558\xf5\xb2\xeabH\xed\xfd(sb\xb4b\xf0\xc6 yF`\xe6\x9d\xeb\xf3\xde\xcc*G\x04 GÙ®\xb8K\xee\xd9]\xf2C@\xc9=\xbbC\xa7\xbb\xea\x1a\xd5\xfc\xf3\xa3Y\xd7\x04\xe27\xb5dİ¤\x19K\xb6\xb5\x9d\xc8\xe9g\r^\x9b\x10\xa2rUc\xf6\xeb\xf0\x8b\xe4\xcbW_\n\x8d\xa5\xab\xaeÑŒ5\xb7\xe7\xb4@\xc7[Ö©\xe6_\x9f\x9c6\x8719\n\x90\x83\xcaU\x8de\xf9\xe9?\xe4\xcbW_\xd2\xcc,\x87$]u\x8d\xe27ß¦\x93\xbeÕ¤\xf4\x1f\x0e\x0eN\x8b\xc52nÎ‘\xee8\x94\xd7\xf9\r\xe9\x83\aBw\x04\xc6.\xbbB\x91\xc5g*u\xe0S\xf9\xce\x0e\xb9\xba9\x8a\xcc?e\xf4\xfb\x97L\x94$\x04É\xedJ\xechÏ¸\xacW\x1a|\x9f*W6*v\xc9\xe5J\x1f:\xa8tO\xcf\xf0i\u0091\xd3\x16\xcbÍœ5x\xd5e\x19\x1c\xf9\x99L\x04 \a\x95\x97]\x11:\xbd\x1c>\xfd\xa5\xc1?ì·~\xa5X\x96qJ\x7f\xbc\x11h\x98\xa1\x9by\xe4sJl\xe2\xb7\xeff}|d\u18acw'J\xed\xdf\x1bz\xc7\xe0b9\xf6È†1o\x9d6|\x13PIÒ‰}\xa9o.\xd8\x04\x18GU\xd3\xea\xac\x7f\xac\xe5\xf0\xe9?\xa4\xf7\xe9V\r\xfc\xe6Í¼\x9fç»»\xd4\xfb\xd4cy?\xafo\xf3\xa6\xf0o2\x1eg^\xe5pÌ½ç¾»\x95Ú¿wÂ¯\x93m_È‰\x84\x00\x8c\xa3\xe2\xc2KB\xa7\xa7\xf6\xef-\x8bO\xff\x91z[\x1fR\xff\xd6\xf0\xbd\xddaR\x1f}0\xa1[\x9a\r\x7f\x93q\x11\xe65\xd9z\xee\xbb[\x03o\xbc\x96\xf3{5Rj\xff^\xf5\xfd|Ó´\xf8\xc6f6\x01\xc60Ö§\x7f\xff\x7fn-\xf2hrÓ·y\x93\xfa6o\x1a\xbc\x8bq\x96/\x05\xf1G\x0e\xab\xff\xcd\xd7'\xe5tİ£?\xbe_\xb1\x86\x15\xaalX\x91\xf1%)C7\b\x1dh\x7f\xaf,\x17\x96Ş§[\xa5\xa7[UÕ´Z\xd13\x97\x84\x7f\xc9K2\xa1t\xd7\x11\xf9#\x87\x95\xfa\xe2P\xde_hR\xee\\g\xcb\xf5\xbeÔƒ\x00P\x1al\x02\x00\x86\x11\x00\xc00\x02\x00\x18F\x00\x00\xc3\b\x00`\x18\x01\x00\f#\x00\x80a\x04\x000\x8c\x00\x00\x86\x11\x00\xc00\x02\x00\x18F\x00\x00\xc3\b\x00`\x18\x01\x00\f#\x00\x80a\x04\x000\x8c\x00\x00\x86\x11\x00\xc00\x02\x00\x18F\x00\x00\xc3\b\x00`\x18\x01\x00\f#\x00\x80a\x04\x000\x8c\x00\x00\x86\x11\x00\xc00\x02\x00\x18F\x00\x00\xc3\b\x00`\x18\x01\x00\f#\x00\x80a\x04\x000\x8c\x00\x00\x86\x11\x00\xc00\x02\x00\x18F\x00\x00\xc3\b\x00`\x18\x01\x00\f#\x00\x80a\x04\x000\x8c\x00\x00\x86\x11\x00\xc00\x02\x00\x18F\x00\x00\xc3\b\x00`\x18\x01\x00\f#\x00\x80a\x04\x000\x8c\x00\x00\x86\x11\x00\xc00\x02\x00\x18F\x00\x00\xc3\b\x00`\x18\x01\x00\f#\x00\x80a\x04\x000\x8c\x00\x00\x86\x11\x00\xc00\x02\x00\x18F\x00\x00\xc3\b\x00`\x18\x01\x00\f#\x00\x80a\x04\x000\x8c\x00\x00\x86\x11\x00\xc00\x02\x00\x18F\x00\x00\xc3\b\x00`\x18\x01\x00\f#\x00\x80a\x04\x000\x8c\x00\x00\x86\x11\x00\xc00\x02\x00\x18F\x00\x00\xc3\b\x00`\x18\x01\x00\f#\x00\x80a\x04\x000\x8c\x00\x00\x86\x11\x00\xc00\x02\x00\x18F\x00\x00\xc3\x02I\xbf/\xf5 \x00\x94\xc4\xef\x03y\x1d,\xf5(\x00\x94\x80\xd7\xc1\xc0;\x02\x00\x98\xe4\xfc\xde\xc0\xb1\x06\x00\x98\xe4\xbd;\x18\xb8@o\x97z \x00\x8a/\b\xf4\xdb\xc0'\x82\xad\xa5\x1e\b\x80\xe2\xf3\x89`kP\xb7\xf1\x99\xbd\xde\xfb\x0fJ=\x18\x00\xc5\xe3\xbd\xff\xa0n\xe33{\x03Ir\x12k\x01\x80)\xee\x05\xe9\xab\x13\x81\x02\x02\x00\x98\xe2\\z\xab\xf4U\x00\xaa\xe3G_\x97|\x7fi\x87\x04\xa0\x18\xbc|Wm\x97\xdb&}\x15\x00\xf7\xd0+\xfdJ\xeb\xb6\xd2\x0e\v@1\xb8\xb4\xfeÖµ\xb5\rH#\xae\x05\xa8\xed\xd1S^~{\xe9\x86\x05`\xaay\xaf\x1d\xb5=zj\xe8\xe7\xe1\x00\xb8\xb6\xb6\x94\xf3\xee\xde\xd2\f\v@18\xe9\a\xae\xad-5\xe2\xe7\xd1\x0e\xdf\xda\xfc\xdfÎ¹\x86\xe2\x0e\v\xc0T\xf3\xf2\xdbf\xb7\xb6-\x1f9-\xe3r\xe0H*\xbd\xc6{u\x17oX\x00\x8a\xe0\x8b\x88\xd7\xcd\xc7O\xcc\b@\xcd\xc6\xcd{\x02ç¯“\x94(Ê°\x00L\xb5D we\xcd\xe3m\x1f\x1e\xff\x8b\xd0\x1b\x82Ô¶\xb6\xbd&\xa5\xfff\xea\xc7\x05`\xcay\xad\xadi}6\xf4\x9a\x9f\xacw\x04\xaak}\xeeII?\x9a\xb2A\x01(\x86\x1f\xd5=\xfe\xb3\x7f\xcb\xf6ËŒ\x9d\x80\xc7\xebl\xb9\xae\xd1\xcbmrr\xf1\xc9\x1d\x17\x80\xa9\xe2\xe5\xfb\xe4\xfc\xf5\xb3\x1f{\xee\x17c=n\xdc\x00HR\xe7\xadM\xe7I\x91\x9f\xcbiÑ¤\x8c\x0e\xc0\xd4\xf1~\x9f|\xd0X\xf7Ä³\xed\xe3=4\xa7\x00HR\xf7__3'\x19\x8b\xbe\xe8\xe4.\x99\xd8\xe8\x00L\x15/\xbd\x1d\x1dH|\xab\xfa\xa7\xcfw\xe4\xf2\xf8\x9c\xef\n\\\xfd\xd3\xe7;\xea\xbat\xa9\x94^#é£‚G\b`\xd2y\xaf]\xde\xfb\xbf\xaa\xeb\xf2\r\xb9.\xfcR\x1ek\x00\xa3f\xd6\xdc\x1c\xe9\xaeq×§\xbc~\xe0\x9c\xce.\xe45\x00L\x9c\xf7\xda%\xf9\xfb\xeb\x16.}\xc6\xfd\xf0\x87\xe9|\x9f_P\x00\x86g.\xb9\xee[\x9a.JE\x82\xab%]\xed\xe4\x96L\xe4\xf5\x00\x8co\xf0\x06>\ue168\xf7[f=\xd1\xf6\xb6\x93|\xa1\xaf5\xa1\x00\x1c\xaf\xfb{MKR\xc9\xe0/\xbds\x7f\xea\xa4\xf9r~\xbe\xf7\xeed\xe74\x7f2\xe7\x03X\xe0\xe5?sr\a\xe4\xfd\xe7\u07b9\x03N\xe9\x0f\x03ï¶„\x9d\xd0S\xa8\xff\a\xf4\xd9\xd1K\xff\x15\xa1\x90\x00\x00\x00\x00IEND\xaeB`\x82"),
}

```

`ui/internal/assets/logo.go`:

```go
// auto-generated
// Code generated by '$ fyne bundle'. DO NOT EDIT.

package assets

import "fyne.io/fyne/v2"

var LogoPNG = &fyne.StaticResource{
	StaticName: "Uwp_150.png",
	StaticContent: []byte(
		"\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x96\x00\x00\x00\x96\b\x06\x00\x00\x00<\x01q\xe2\x00\x00\x00\x04sBIT\b\b\b\b|\bd\x88\x00\x00\t\xb8IDATx\x9c\xed\xdd\x7fl\xd4w\x1d\xc7\xf1\xd7\xe7{\xbf\xdac\xf4Z\x18[\x01\x81\x86faX\t1\xfe\x18\xce&\x1b\x89\x8c\xe1\x94nb\xb7È˜\x9bp\xc4\x19V\xdd&\xfb\x91\xe8\x96H\xd0`L\x88\x11\x8c[h1K\xc6\x12iT\x181\xfc\xd0\f\xfe 3s\xce1\x192c\x964#@\xa5\xd4\xf6\xaeİµ\xd7\xde}\xdf\xfeQ\xfam\xefg\x7f\xf0}\xf7\xbb;^\x8f\x84\xe4~|\xef\xfb}\xc3=\xfb\xfd~\xef{\x10\f&!\xb6\xa5y\x0e \xf7Ø°Öˆ\xc1\xa7\x8d\xc8|1\x98g`\u0093y=\x95&\x81$\x8c\x98+b\xd0i \xe7\x8cmN\x18#\x7f\x89\xb4\xb5\xffo\xa2×š\xa2+\u07bc~v\xafU\xb1\x03\x90'\x00\xe3wod*]\x92\x82\xe0WÕƒ\xc1\x9f\x98\x03\aâ…–\xca\x1b\x96\x00\xa6ws\xf3\xa3\xb0\xcc.\x00\xb7\xaa\xcdH%KD:\r\xf0lu[\xfb\xab\x06\x90\xec\xe7\xad|/\x8aE\x9b\xb7\xc3`?\x18\x15\x15`\x8c\xa9\x05\xf0Jo\xf4\x9b?\xc8\xfb\xfc\xf8;\xd2\xdc\xecë˜\xfd\x00\xbe=\x13\xc3Q\xd9\xf8euL\xb6\x9b\xf6\xf6\xf4\xe8\x03\x19{\xacŞˆ\xb4\x80Q\xd1\xd4=y\xad\x1d\x87\xb3\xc7\xea\x8d6\xaf\x11\x98c(px$\x9a\x80m\x19|5\xb2\xef\xe0q\xe0ZX\xf2\xd8c\x15\xbd\xfeD\axNE\xd7A \x97kb\xa87\xed\xed\x03\x16\x00\xf4\xf8?~\x12\x8c\x8a\xae\x93\x81\x99\xdf\x1b\x91\xef\x02\x80%\x80\x81 \xef\x99=\xd1T\tÌ³\x02\x18\x13\x8b>\xb4Ê†\xfc\xd5ë¨|X0_\xb2\xd2\"\xf7{=\b\x95\x97\xb4\xc8\xfd\x961\xb2\xca\xebA\xa8\xbc\x18#\xab,\x11\xd4z=\b\x95\x17\x11\xd4Z0\f\x8b\\fPk\x19\x98\x88\xd7sPy10\x11^e'\x15\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x85\xdf\xeb\x01f\xd2MO\xff\x18\xd6-\xb5\xb0\xaft\xa2\x7f\xf7\xcei\xafÃ¿|\x85s\xbfw\xebCn\x8dWV<\t\xabz\xdf\xef&\xbd\xac[o\\xS\xd4\t\u009a;\x0f\xe1h\v\x12\xad{\\Y7\xe5\xbaa\x0e\x85&R\x93y?T\xe1\xd1$7\x06\xcf\x0f\x85\x12\x8fA\x86\x87Ô·\x93<u\x02\xbeEK`Í\a\xbb\xbb\v\xc9S'Ô·y#\xf3<\xac\xa17Oa\xe0\xf7\xaf\xa9o'u\xee=ÄŸ\x7fB};4\xe2\x869\x14\xd2\xccbX\xa4\xc2\xf3C\xe1t\x84\xa3-\xf0/Y\n\xeb\xe6y\x80?\x90w\x19\xbb\xbb+\xe3\xd0W\xb9a#B\xf769\xf7\x93\xc7\x0e\x17<\x04\xcf\xda\xf6\f\xfcKo\x83\xa9\x8a\x00\x00d \x81tÇ‡\x18<~dR\xf3\x05\x1bW#Ô¸\x1a\xa6z\x0e\xac\xb9\xf3\x9c\xc7e \x01\xfb\xd2\x05$O\x9f\xc4\xd0\xe9\x939\xaf\xcbw)#\xb4\xae\t\xa1\xbb\u058c\xac'5\x8c\xde\xefm\xcax\x8d\xbfa%Bwß“1/RÃ°\xafva\xf8\xcc\xdb3r\x9a\x91OI\x85\xe5oX\x89\xf0#[3\xde,\xb7\xd7?k\xf3\xb6\xb17\xe8\x1aS\x19\x86\x7f\xf9\n\xccZ\xb8\x18vWg\xd1u\x84\xa3-\b\xdeÑ˜\xf79S\x19\x86\xaf~\x19\xc2K\x96\xc2Ì®B\xf2\xe8\xe1\xa2\xeb\n6\xaeF\xe5\xfa\xe6\xb1\x1f\x9e\xac\x1f\xa2Ğº&T\xac\xbb\x1f\xa62\x9c\xf5\x1b\t\xc0\xaa]\x80Ğ½M\xf0\xdfv;\xfav\xbdXt;\x1aJ*\xac\x8a\xb5_Ïˆ*}\xa1\x03\xd2\xdf\xe7\xdc\xf7\xd5\xd5\xe7\xfe!OAvT2\x90\x80$>\x06\x00\x98\xf0,\x98\xaa\b|\xe1\xe2\xeb\xb7\xc6\xed5Ò—/:\xf3Y\xb7Ô\xcd\xee\x0f t×š\tÃªX\xbb\xbe\xe0\x1e9\xb4\xae)#\xbaÑ½j\xf6\xb6|\xf5\xcb\x10\xde\x14E\xe2\xd5Ö¢\xdbr\x9b\xe7a\x85\xeem\xca8D\x8d\x97:\x7f6\xe3\n\xb9\xaf\xae\u07b9\x9d\xbeĞ\xbe\x1d\xcfe,_\xb5k\xef\xb4\xc3\nG[2\xa2Ê·\xfe\xd9/\xfe\x1c\xbeEu\x13\xae+u\xfe,\x06\x8f\x1fA\xea\xdc{\x99\xaf\x7f~\a|\xf5\xcb\x00\x8c\\\xa4\r6\xae\xce{H\x1ce\xd5.\x80\xddy\t\x83\xc7_\xcfY\xae\xe2+\xf79Q\xe5\x9bu\xfca5\xf0\xc5/\x033\x1cVI\x9d\xbc\x8f\x8ff\xfc\x9e\xca\r\x81q\xe76vwW\xce\x1b\x05\x00};\x9e\x83\f$\x8a\xaeg\xf0\xf8\x11\xf4\xefŞ™\x13\x15\x00$\xb3\xe2\xf0\xdd:\xbf\xe8\xba$\x1eC\xfc\x85\xa7r\xa2\no\x8af\x9cO\xe5;\x8f\xeaß½\x13H\r\x03\x18\xf9s\xabÜ°\xb1\xe8\xb6\xdc\xe6yX\x12\x8f\xc1\xee\xee\xca\xff+\x1e\xcbX\xd6\xee\xeern\x9b`Ğµ\x19\xfc\r+3\xf6V\xa9\xf7\xcf\x14\\v\xf4pSH\xbe\xa0Fe\abj\xe6\x16]\xd7\xf0\xbb\x7f\xcb\xfb\xb8\xefS\x8b\xc7\xe6\xb9|\xb1\xe06\xedX\xef\xd8k\x96,-\xba-\xb7y~(\x9c\xca\x05\xd2\xd4\xfbg\x10\xbck\r\x80\x91s\x87\xd9\xcf\xef@\xea?\x1f8Ï›\xc0\xf4b\v\xdcŞ9Ó»oOk=\xe3\x85\xd65\xc1\xb7p1\xac\xaa\b\xac\x9a\xb9@ \x90\xf3\xa1\xc3\xca\xfa\x90\x90\xad\xd0\x1c\xa6z\x8esÛ·\xa8nJß½\xce\x14\xcfÃš\x8aÄ«\xad@E%\x82\x9f\xbb\x03\xf0\a\xe0\xab_æœ³\xb8\xa9\xd8^g\"\x05?\xa9\xcd\xf0\x1c^+\xa9\xb0\x00 Ñº\a\xe9\x8b\x1fe~\f\xff\x84\b\xadkB\xe57\xc6\xceed \x01\xfb\xea\x15H\x7f\x1f\xecx\f\xd2\xd3]\xf0\x83\xcat\xa5/tL*\xc0\xf4\x7f/\xbb\xbaİ‰\x94\\X\xd9\xd7v\xc6\x7f\"\xaaÚµ×•k\\\x95\x1b6\x16<<\x17;\xb7\v\xddy\xb7s\xdb\uef04\xf8\vO\xe5.\xe3FX\xc3\xc3\x19w\xbd\xba\bZ\x8c\xe7'\xefSU\xf1\xb5\rNT\x85>\xbdMU\xf6\x1b\xe3oX\x99w9\x7f\xc3Ê¢'\xc1\xd6\xcdcQ\xdb=\xdd9\xcf\a\x1bWOs\xc2L\xe9\xceK\xcem\xdf\xfc\x85\x05\xe7\xf5RI\x85U\xb9ac\xc6\x1ei\xf8\xed7][w\xfaB\x87sÛ·\xa8\x0e\xe1hK\xc6\xf3\xa3W\xe5'{\xf8\xb5\xb2>\xf1\xf9\x1bV\xa2\xf2\x81o]\xf7\x9c\xc0\xc8_\x01\x1a\xbd\x94\x00\x7f\x00\xb36o+\x18m8Ú‚YÛqe\xbbSQR\x87\xc2\xc0\x17\xeetn\xcb@\xc2\xd5C@\xf2\x8dc\b?\xbc\xc5\t'xG#\x02\xcbW\xc0\x8e\xf5\xc0\x04\x82\xce\xf7\x92\x12\x8f\xe5|\xe53Ê¾\xda\x05\xabv\x01\x80\x91\x8b\x9bU\xbb\xf6Â¾\xd2\t\x13\fÂ·d)$\xeb\x106]\xa9s\xefaè·\x9c\xaf\x8eLU\x04\xe1G\x1fG\xc5\xda\xf5Î\xd2\xdc4\x1b\xbe\xf9\v\x01\x7f\x00\xa9\xf3g]\xd9\xeeT\x94\xcc\x1e+go\xf5\xcf\x7f\xb8\xba\xfe\xa1\xd3'1\xf4\xce[\x19\x8f\x99\xaa\b|\x8b\xeaFb\xb9\xf6\x06\xa5/~Tp\x1d\xc97O\x8d\xedI0ruİ¿|\x85\xf3\xc9u\xf0\xe8!\xd7\xe6M\xb4\xee\xc9\tÆª]\x00\xff\xf2\x15#\xdb\\T7\xf6uO2\xe9\xdav'\xabd\xc2\xca\xde[i\xfc}\xf5D\xeb\x1e$^yi\xe4\xb08.\x10\xbb\xf3\x12\x92\xc7\x0eO\xf8\x0f0\x92G\x0f#q\xa0-\xf3\xf5\xa9a\xa4/t q\xa0m\xc2\xef\x06\xa7\xaa\x7f\xf7Ng\xde\xeco\x04\xec\xee.\xa4?\xfc7\x06\xfe\xf0\x1a>\xfe\xf5/\\\xdd\xeed\x98\x9e\xe8\x832\xe3[\xa5\xb2W2{,*-\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x05\xc3\"\x15\f\x8bT0,R\xc1\xb0H\x85\x05\xc8\xcc\xff\xbf\xaeT\xd6\x04\x12\xb3 \xe8\xf4z\x10*3\x82NK\xc0\xb0\xc8]Æ \xd3\x02\xcc\x19\xaf\a\xa1\xf2\"b>\xb0|\x90C^\x0fB\xe5\xc5\a9dU\x85\xfbO\n$\xe6\xf50T\x1eD\x10\xaf\x8a\xe3\r\xcb\xec9\x9a\x84\x98\x97\xbc\x1e\x88\xca\xc6oL{\xfb\x90\x05\x005\x83\x81\x9fA\xa4\xcbë‰¨Ä‰t\xd5\xc8\xe0O\x81k\x17HÍ\x03q\xcb2\x8f\x00\xb0=\x1d\x8cJ\x99m\f\x1e6\xfb_\xef\x03\xc6]y\x8f\xec;x\\ ?\xf2n.*m\xf6\x0f\xab[\xdb\xff<z\xcfd?İ³\xe5\xc1}0\x88\xce\xecPT\xcaD\xf0\U0009cd83\x8f\x8f\x7f,\xe7\xbb\u009a\xb6\x83[\x01{;Dd\xe6F\xa3\x92$\"\"Ò’\x1d\x15\x90g\x8f5\xaagk\xf3\x03\"\xd8c`\x16\xeaNG%I\xd0\x01K\x9e\xae\xd9\xd7\xfe\xc7|O\x17\fkT\xcf\xe6\xe6\xc7`\xf0}\x18\xf3Y\xf7\xa7\xa3\x92#\xf2.`\xf6Ö´\x1d\xdc_l\xb1\t\xc3\x1a\xd5\xf7\x9d\xe6y)\x83\xfb`\x99\xcf\x03\xf2\x19\xc04\x00\xb8\xf9\xba\a\xa5O\xb2\xab\x10\xfc\v\x06ga\xcb\xdf\xfd\x82?\xcd\xfem\xfb\xa4.K\xfd\x1f\xf8\xfa\xf3\xb3#|k\xb8\x00\x00\x00\x00IEND\xaeB`\x82"),
}

```

`ui/internal/config/config.go`:

```go
package config

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
)

// Config åº”ç”¨ç¨‹åºé…ç½®ç»“æ„
type Config struct {
	// å…¨å±€é…ç½®
	AppVersion string `json:"app_version"`
	WorkDir    string `json:"work_dir"`

	// ç½‘ç»œé…ç½®
	Proxy   string `json:"proxy"`
	Timeout int    `json:"timeout"` // ç§’
	Retries int    `json:"retries"`

	// Frida é…ç½®
	DefaultPort int    `json:"default_port"`
	MagicName   string `json:"magic_name"`
	AutoConfirm bool   `json:"auto_confirm"`

	// UI é…ç½®
	Theme        string `json:"theme"` // "light", "dark", "auto"
	WindowWidth  int    `json:"window_width"`
	WindowHeight int    `json:"window_height"`
	DebugMode    bool   `json:"debug_mode"`
	NoShowNotice bool   `json:"no_show_notice"` // æ˜¯å¦ä¸å†æ˜¾ç¤ºé€šçŸ¥

	// ä¸‹è½½é…ç½®
	DownloadDir         string `json:"download_dir"`
	ConcurrentDownloads int    `json:"concurrent_downloads"`

	// æœ€è¿‘ä½¿ç”¨
	RecentVersions  []string `json:"recent_versions"`
	RecentPlatforms []string `json:"recent_platforms"`
}

// DefaultConfig è¿”å›é»˜è®¤é…ç½®
func DefaultConfig() *Config {
	homeDir, _ := os.UserHomeDir()

	return &Config{
		AppVersion: "1.0.0",
		WorkDir:    filepath.Join(homeDir, ".fridare"),

		Proxy:   "",
		Timeout: 30,
		Retries: 3,

		DefaultPort: 27042,
		MagicName:   "frida",
		AutoConfirm: false,

		Theme:        "auto",
		WindowWidth:  1200,
		WindowHeight: 800,
		DebugMode:    false,
		NoShowNotice: false,

		DownloadDir:         filepath.Join(homeDir, "Downloads", "fridare"),
		ConcurrentDownloads: 3,

		RecentVersions:  []string{},
		RecentPlatforms: []string{},
	}
}

// ConfigPath è¿”å›é…ç½®æ–‡ä»¶è·¯å¾„
func ConfigPath() (string, error) {
	configDir, err := os.UserConfigDir()
	if err != nil {
		return "", err
	}

	appConfigDir := filepath.Join(configDir, "fridare")
	if err := os.MkdirAll(appConfigDir, 0755); err != nil {
		return "", err
	}

	return filepath.Join(appConfigDir, "config.json"), nil
}

// LoadConfig åŠ è½½é…ç½®æ–‡ä»¶
func LoadConfig() (*Config, error) {
	configPath, err := ConfigPath()
	if err != nil {
		return nil, fmt.Errorf("è·å–é…ç½®è·¯å¾„å¤±è´¥: %w", err)
	}

	// å¦‚æœé…ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¿”å›é»˜è®¤é…ç½®
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		cfg := DefaultConfig()
		// å°è¯•ä¿å­˜é»˜è®¤é…ç½®
		if saveErr := cfg.Save(); saveErr != nil {
			// ä¿å­˜å¤±è´¥ä½†ä¸å½±å“ä½¿ç”¨é»˜è®¤é…ç½®
			fmt.Printf("ä¿å­˜é»˜è®¤é…ç½®å¤±è´¥: %v\n", saveErr)
		}
		return cfg, nil
	}

	data, err := os.ReadFile(configPath)
	if err != nil {
		return nil, fmt.Errorf("è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥: %w", err)
	}

	var cfg Config
	if err := json.Unmarshal(data, &cfg); err != nil {
		return nil, fmt.Errorf("è§£æé…ç½®æ–‡ä»¶å¤±è´¥: %w", err)
	}

	// éªŒè¯å¹¶è¡¥å……é»˜è®¤å€¼
	cfg.validate()

	return &cfg, nil
}

// Save ä¿å­˜é…ç½®åˆ°æ–‡ä»¶
func (c *Config) Save() error {
	configPath, err := ConfigPath()
	if err != nil {
		return fmt.Errorf("è·å–é…ç½®è·¯å¾„å¤±è´¥: %w", err)
	}

	data, err := json.MarshalIndent(c, "", "  ")
	if err != nil {
		return fmt.Errorf("åºåˆ—åŒ–é…ç½®å¤±è´¥: %w", err)
	}

	if err := os.WriteFile(configPath, data, 0644); err != nil {
		return fmt.Errorf("å†™å…¥é…ç½®æ–‡ä»¶å¤±è´¥: %w", err)
	}

	return nil
}

// validate éªŒè¯é…ç½®å¹¶è¡¥å……é»˜è®¤å€¼
func (c *Config) validate() {
	if c.Timeout <= 0 {
		c.Timeout = 30
	}
	if c.Retries <= 0 {
		c.Retries = 3
	}
	if c.DefaultPort <= 0 || c.DefaultPort > 65535 {
		c.DefaultPort = 27042
	}
	if c.WindowWidth <= 0 {
		c.WindowWidth = 1200
	}
	if c.WindowHeight <= 0 {
		c.WindowHeight = 800
	}
	if c.ConcurrentDownloads <= 0 {
		c.ConcurrentDownloads = 3
	}
	if c.Theme == "" {
		c.Theme = "auto"
	}
	if c.WorkDir == "" {
		homeDir, _ := os.UserHomeDir()
		c.WorkDir = filepath.Join(homeDir, ".fridare")
	}
	if c.DownloadDir == "" {
		homeDir, _ := os.UserHomeDir()
		c.DownloadDir = filepath.Join(homeDir, "Downloads", "fridare")
	}
}

// AddRecentVersion æ·»åŠ æœ€è¿‘ä½¿ç”¨çš„ç‰ˆæœ¬
func (c *Config) AddRecentVersion(version string) {
	// ç§»é™¤é‡å¤é¡¹
	for i, v := range c.RecentVersions {
		if v == version {
			c.RecentVersions = append(c.RecentVersions[:i], c.RecentVersions[i+1:]...)
			break
		}
	}

	// æ·»åŠ åˆ°å¼€å¤´
	c.RecentVersions = append([]string{version}, c.RecentVersions...)

	// é™åˆ¶æ•°é‡
	if len(c.RecentVersions) > 10 {
		c.RecentVersions = c.RecentVersions[:10]
	}
}

// AddRecentPlatform æ·»åŠ æœ€è¿‘ä½¿ç”¨çš„å¹³å°
func (c *Config) AddRecentPlatform(platform string) {
	// ç§»é™¤é‡å¤é¡¹
	for i, p := range c.RecentPlatforms {
		if p == platform {
			c.RecentPlatforms = append(c.RecentPlatforms[:i], c.RecentPlatforms[i+1:]...)
			break
		}
	}

	// æ·»åŠ åˆ°å¼€å¤´
	c.RecentPlatforms = append([]string{platform}, c.RecentPlatforms...)

	// é™åˆ¶æ•°é‡
	if len(c.RecentPlatforms) > 10 {
		c.RecentPlatforms = c.RecentPlatforms[:10]
	}
}

// EnsureWorkDir ç¡®ä¿å·¥ä½œç›®å½•å­˜åœ¨
func (c *Config) EnsureWorkDir() error {
	return os.MkdirAll(c.WorkDir, 0755)
}

// EnsureDownloadDir ç¡®ä¿ä¸‹è½½ç›®å½•å­˜åœ¨
func (c *Config) EnsureDownloadDir() error {
	return os.MkdirAll(c.DownloadDir, 0755)
}

```

`ui/internal/core/arch_desc.go`:

```go
package core

import (
	"debug/elf"
	"debug/macho"
	"debug/pe"
	"encoding/binary"
	"fmt"
	"strings"
)

// describeArch returns a detailed description of the file architecture
func describeArch(file interface{}, format ExecutableFormat) string {
	switch format {
	case MachO:
		switch f := file.(type) {
		case *macho.File:
			return describeMachOArch(f)
		case *macho.FatFile:
			return "MachO Fat Binary (Multiple Architectures)"
		}
	case ELF:
		if f, ok := file.(*elf.File); ok {
			return describeELFArch(f)
		}
	case PE:
		if f, ok := file.(*pe.File); ok {
			return describePEArch(f)
		}
	}
	return "Unknown Architecture"
}

// cpuTypeToString converts MachO CPU type to string
func cpuTypeToString(cpu macho.Cpu) string {
	switch cpu {
	case macho.Cpu386:
		return "x86"
	case macho.CpuAmd64:
		return "x86_64"
	case macho.CpuArm:
		return "ARM"
	case macho.CpuArm64:
		return "ARM64"
	case macho.CpuPpc:
		return "PowerPC"
	case macho.CpuPpc64:
		return "PowerPC 64"
	default:
		return fmt.Sprintf("Unknown CPU type: %d", cpu)
	}
}

// describeMachOArch describes MachO file architecture
func describeMachOArch(f *macho.File) string {
	cpu := cpuTypeToString(f.Cpu)
	byteOrder := "Little Endian"
	if f.ByteOrder == binary.BigEndian {
		byteOrder = "Big Endian"
	}
	return fmt.Sprintf("MachO: CPU: %s, Byte Order: %s, File Type: %s", cpu, byteOrder, f.Type.String())
}

// describeELFArch describes ELF file architecture
func describeELFArch(f *elf.File) string {
	var details []string
	details = append(details, fmt.Sprintf("Machine: %s", f.Machine.String()))
	details = append(details, fmt.Sprintf("Class: %s", f.Class.String()))
	details = append(details, fmt.Sprintf("Data: %s", f.Data.String()))
	details = append(details, fmt.Sprintf("OSABI: %s", describeOSABI(f.OSABI)))
	details = append(details, fmt.Sprintf("ABI Version: %d", f.ABIVersion))
	details = append(details, fmt.Sprintf("Type: %s", f.Type.String()))
	details = append(details, fmt.Sprintf("Entry: 0x%x", f.Entry))

	if len(f.Progs) > 0 {
		details = append(details, fmt.Sprintf("Program Headers: %d", len(f.Progs)))
		for _, prog := range f.Progs {
			details = append(details, fmt.Sprintf("  Type: %s, Flags: %s, VAddr: 0x%x, Memsz: 0x%x",
				prog.Type.String(), describeProgramFlags(prog.Flags), prog.Vaddr, prog.Memsz))
		}
	}

	if len(f.Sections) > 0 {
		details = append(details, fmt.Sprintf("Section Headers: %d", len(f.Sections)))
		for _, section := range f.Sections {
			details = append(details, fmt.Sprintf("  Name: %s, Type: %s, Flags: %s, Addr: 0x%x, Size: 0x%x",
				section.Name, section.Type.String(), describeSectionFlags(section.Flags), section.Addr, section.Size))
		}
	}

	if syms, err := f.DynamicSymbols(); err == nil {
		details = append(details, fmt.Sprintf("Dynamic Symbols: %d", len(syms)))
	}

	if libs, err := f.ImportedLibraries(); err == nil && len(libs) > 0 {
		details = append(details, fmt.Sprintf("Imported Libraries: %s", strings.Join(libs, ", ")))
	}

	return strings.Join(details, "\n")
}

// describeOSABI describes ELF OS/ABI
func describeOSABI(osabi elf.OSABI) string {
	switch osabi {
	case elf.ELFOSABI_NONE:
		return "UNIX System V ABI"
	case elf.ELFOSABI_HPUX:
		return "HP-UX"
	case elf.ELFOSABI_NETBSD:
		return "NetBSD"
	case elf.ELFOSABI_LINUX:
		return "Linux"
	case elf.ELFOSABI_SOLARIS:
		return "Sun Solaris"
	case elf.ELFOSABI_AIX:
		return "IBM AIX"
	case elf.ELFOSABI_IRIX:
		return "SGI Irix"
	case elf.ELFOSABI_FREEBSD:
		return "FreeBSD"
	case elf.ELFOSABI_TRU64:
		return "Compaq TRU64 UNIX"
	case elf.ELFOSABI_MODESTO:
		return "Novell Modesto"
	case elf.ELFOSABI_OPENBSD:
		return "OpenBSD"
	case elf.ELFOSABI_ARM:
		return "ARM"
	case elf.ELFOSABI_STANDALONE:
		return "Standalone (embedded) application"
	default:
		return fmt.Sprintf("Unknown OSABI (%d)", osabi)
	}
}

// describeProgramFlags describes ELF program flags
func describeProgramFlags(flags elf.ProgFlag) string {
	var s []string
	if flags&elf.PF_X != 0 {
		s = append(s, "X")
	}
	if flags&elf.PF_W != 0 {
		s = append(s, "W")
	}
	if flags&elf.PF_R != 0 {
		s = append(s, "R")
	}
	return strings.Join(s, "+")
}

// describeSectionFlags describes ELF section flags
func describeSectionFlags(flags elf.SectionFlag) string {
	var s []string
	if flags&elf.SHF_WRITE != 0 {
		s = append(s, "W")
	}
	if flags&elf.SHF_ALLOC != 0 {
		s = append(s, "A")
	}
	if flags&elf.SHF_EXECINSTR != 0 {
		s = append(s, "X")
	}
	return strings.Join(s, "+")
}

// describePEArch describes PE file architecture
func describePEArch(f *pe.File) string {
	var details []string
	details = append(details, fmt.Sprintf("Machine: %d", f.Machine))

	characteristics := describeCharacteristics(f.Characteristics)
	if len(characteristics) > 0 {
		details = append(details, fmt.Sprintf("Characteristics: %s", strings.Join(characteristics, ", ")))
	}

	if f.OptionalHeader != nil {
		switch oh := f.OptionalHeader.(type) {
		case *pe.OptionalHeader32:
			details = append(details, "Format: PE32")
			details = append(details, fmt.Sprintf("Subsystem: %s", describeSubsystem(oh.Subsystem)))
			details = append(details, fmt.Sprintf("BaseOfCode: 0x%X", oh.BaseOfCode))
			details = append(details, fmt.Sprintf("BaseOfData: 0x%X", oh.BaseOfData))
		case *pe.OptionalHeader64:
			details = append(details, "Format: PE32+")
			details = append(details, fmt.Sprintf("Subsystem: %s", describeSubsystem(oh.Subsystem)))
			details = append(details, fmt.Sprintf("BaseOfCode: 0x%X", oh.BaseOfCode))
		}
	}

	details = append(details, fmt.Sprintf("Number of Sections: %d", len(f.Sections)))
	for i, s := range f.Sections {
		details = append(details, fmt.Sprintf("  Section %d: %s", i, describePESection(s)))
	}

	details = append(details, fmt.Sprintf("Number of Symbols: %d", len(f.Symbols)))

	return strings.Join(details, "\n")
}

// describePESection describes a PE section
func describePESection(s *pe.Section) string {
	return fmt.Sprintf("Name: %s, Address: 0x%X, Size: 0x%X", s.Name, s.VirtualAddress, s.Size)
}

// describeCharacteristics describes PE characteristics
func describeCharacteristics(characteristics uint16) []string {
	var chars []string
	if characteristics&pe.IMAGE_FILE_EXECUTABLE_IMAGE != 0 {
		chars = append(chars, "Executable")
	}
	if characteristics&pe.IMAGE_FILE_LARGE_ADDRESS_AWARE != 0 {
		chars = append(chars, "Large Address Aware")
	}
	if characteristics&pe.IMAGE_FILE_DLL != 0 {
		chars = append(chars, "DLL")
	}
	if characteristics&pe.IMAGE_FILE_32BIT_MACHINE != 0 {
		chars = append(chars, "32-bit")
	}
	if characteristics&pe.IMAGE_FILE_SYSTEM != 0 {
		chars = append(chars, "System")
	}
	if characteristics&pe.IMAGE_FILE_DEBUG_STRIPPED != 0 {
		chars = append(chars, "Debug Stripped")
	}
	return chars
}

// describeSubsystem describes PE subsystem
func describeSubsystem(subsystem uint16) string {
	switch subsystem {
	case pe.IMAGE_SUBSYSTEM_WINDOWS_GUI:
		return "Windows GUI"
	case pe.IMAGE_SUBSYSTEM_WINDOWS_CUI:
		return "Windows Console"
	case pe.IMAGE_SUBSYSTEM_EFI_APPLICATION:
		return "EFI Application"
	case pe.IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER:
		return "EFI Boot Service Driver"
	case pe.IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER:
		return "EFI Runtime Driver"
	case pe.IMAGE_SUBSYSTEM_NATIVE:
		return "Native"
	case pe.IMAGE_SUBSYSTEM_POSIX_CUI:
		return "POSIX Console"
	default:
		return fmt.Sprintf("Unknown (%d)", subsystem)
	}
}

```

`ui/internal/core/binary_analyzer.go`:

```go
package core

import (
	"debug/elf"
	"debug/macho"
	"debug/pe"

	"fmt"
	"os"
	"strings"
	"unicode"
)

// BinaryAnalyzer äºŒè¿›åˆ¶æ–‡ä»¶åˆ†æå™¨
type BinaryAnalyzer struct {
	filePath string
	fileType string
	data     []byte
}

// SectionInfo æ®µä¿¡æ¯
type SectionInfo struct {
	Index      int
	Name       string
	Offset     uint64 // Start address
	EndOffset  uint64 // End address
	Size       uint64
	Type       string
	ArchIndex  int    // æ¶æ„ç´¢å¼•ï¼ˆFat Mach-Oä½¿ç”¨ï¼‰
	ArchOffset uint64 // æ¶æ„åœ¨æ–‡ä»¶ä¸­çš„åç§»ï¼ˆFat Mach-Oä½¿ç”¨ï¼‰

	// æ‰©å±•å±æ€§ï¼ˆIDAé£æ ¼ï¼‰
	Readable   bool   // R - å¯è¯»
	Writable   bool   // W - å¯å†™
	Executable bool   // X - å¯æ‰§è¡Œ
	Data       bool   // D - æ•°æ®æ®µ
	Loaded     bool   // L - å·²åŠ è½½
	Align      string // å¯¹é½æ–¹å¼
	Base       string // åŸºå€ç±»å‹
	Class      string // æ®µç±»åˆ« (CODE/DATA/BSSç­‰)
	AddressDep string // AD - åœ°å€ä¾èµ–
	Bitness    string // T - ä½æ•° (32/64)
	DataSize   string // DS - æ•°æ®å¤§å°

	// åŠ¨æ€æ•°æ®ç±»å‹è¯†åˆ«
	DataType      string // æ•°æ®ç±»å‹: "pointer", "string", "code", "data"
	PointerSize   int    // æŒ‡é’ˆå¤§å°ï¼ˆå­—èŠ‚ï¼‰
	ContentFormat string // å†…å®¹æ ¼å¼: "address", "char", "byte"
}

// StringInfo å­—ç¬¦ä¸²ä¿¡æ¯
type StringInfo struct {
	Index  int
	Offset uint64
	Data   string
	Length int
	String string
}

// FileInfo æ–‡ä»¶ä¿¡æ¯
type FileInfo struct {
	FilePath        string
	FileType        string
	FileSize        int64
	Architecture    string
	DetailedInfo    string // è¯¦ç»†çš„æ¶æ„ä¿¡æ¯ï¼Œæ¥è‡ªarch_desc.go
	IsFatMachO      bool   // æ˜¯å¦ä¸º Fat Mach-O æ–‡ä»¶
	Sections        []SectionInfo
	SelectedSection *SectionInfo // å½“å‰é€‰ä¸­çš„æ®µ
	SectionData     []byte       // é€‰ä¸­æ®µçš„æ•°æ®
}

// NewBinaryAnalyzer åˆ›å»ºäºŒè¿›åˆ¶åˆ†æå™¨
func NewBinaryAnalyzer(filePath string) *BinaryAnalyzer {
	return &BinaryAnalyzer{
		filePath: filePath,
	}
}

// AnalyzeFile åˆ†ææ–‡ä»¶
func (ba *BinaryAnalyzer) AnalyzeFile() (*FileInfo, error) {
	// è·å–æ–‡ä»¶ä¿¡æ¯
	file, err := os.Open(ba.filePath)
	if err != nil {
		return nil, fmt.Errorf("æ‰“å¼€æ–‡ä»¶å¤±è´¥: %v", err)
	}
	defer file.Close()

	stat, err := file.Stat()
	if err != nil {
		return nil, fmt.Errorf("è·å–æ–‡ä»¶ä¿¡æ¯å¤±è´¥: %v", err)
	}

	// ä½¿ç”¨hexreplace.goä¸­çš„æ£€æµ‹å’Œæ‰“å¼€é€»è¾‘
	binFile, format, err := detectAndOpenFile(ba.filePath)
	if err != nil {
		return nil, fmt.Errorf("æ£€æµ‹æ–‡ä»¶æ ¼å¼å¤±è´¥: %v", err)
	}

	// åˆ›å»ºæ–‡ä»¶ä¿¡æ¯
	fileInfo := &FileInfo{
		FilePath: ba.filePath,
		FileType: formatToString(format),
		FileSize: stat.Size(),
	}

	// è·å–è¯¦ç»†çš„æ¶æ„ä¿¡æ¯ï¼ˆä½¿ç”¨arch_desc.goï¼‰
	fileInfo.DetailedInfo = describeArch(binFile, format)

	// æ ¹æ®æ–‡ä»¶ç±»å‹è§£ææ®µä¿¡æ¯
	switch f := binFile.(type) {
	case *macho.File:
		fileInfo.Architecture = cpuTypeToString(f.Cpu)
		fileInfo.IsFatMachO = false
		bitness := ba.getMachOBitness(f)
		fileInfo.Sections = ba.parseMachOSections(f, fileInfo.FileType, bitness)
	case *macho.FatFile:
		fileInfo.Architecture = "Universal Binary (Multiple Architectures)"
		fileInfo.IsFatMachO = true
		fileInfo.Sections = ba.parseFatMachOSections(f)
	case *elf.File:
		fileInfo.Architecture = f.Machine.String()
		fileInfo.IsFatMachO = false
		bitness := ba.getELFBitness(f)
		fileInfo.Sections = ba.parseELFSections(f, fileInfo.FileType, bitness)
	case *pe.File:
		fileInfo.Architecture = fmt.Sprintf("Machine: %d", f.Machine)
		fileInfo.IsFatMachO = false
		bitness := ba.getPEBitness(f)
		fileInfo.Sections = ba.parsePESections(f, fileInfo.FileType, bitness)
	default:
		return nil, fmt.Errorf("ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼")
	}

	return fileInfo, nil
}

// parseMachOSections è§£æMach-Oå•æ¶æ„æ–‡ä»¶çš„æ®µä¿¡æ¯
func (ba *BinaryAnalyzer) parseMachOSections(f *macho.File, fileType string, bitness int) []SectionInfo {
	var sections []SectionInfo
	index := 0

	// éå†æ‰€æœ‰æ®µ
	for _, sect := range f.Sections {
		sectInfo := SectionInfo{
			Index:     index,
			Name:      sect.Name,
			Offset:    uint64(sect.Offset),
			EndOffset: uint64(sect.Offset) + sect.Size,
			Size:      sect.Size,
			Type:      fmt.Sprintf("Flags: 0x%X", sect.Flags),
		}

		// è®¾ç½®æ®µå±æ€§ï¼ˆåŸºäºMach-Oæ®µæ ‡å¿—ï¼‰
		ba.setMachOSectionAttributes(&sectInfo, sect)

		// åŠ¨æ€è¯†åˆ«æ•°æ®ç±»å‹
		ba.IdentifySectionDataType(&sectInfo, fileType, bitness)

		sections = append(sections, sectInfo)
		index++
	}

	return sections
}

// setMachOSectionAttributes è®¾ç½®Mach-Oæ®µçš„è¯¦ç»†å±æ€§
func (ba *BinaryAnalyzer) setMachOSectionAttributes(sectInfo *SectionInfo, sect *macho.Section) {
	// è®¾ç½®åŸºæœ¬æƒé™ï¼ˆåŸºäºæ®µæ ‡å¿—ï¼‰
	// flags := sect.Flags // æš‚æ—¶ä¸ä½¿ç”¨ï¼Œä¿ç•™ä¾›å°†æ¥æ‰©å±•

	// åŸºäºæ®µåç§°å’Œç±»å‹è®¾ç½®å±æ€§
	sectInfo.Readable = true // Mach-Oæ®µé»˜è®¤å¯è¯»
	sectInfo.Loaded = true   // é»˜è®¤å·²åŠ è½½
	sectInfo.Bitness = "64"  // å‡è®¾64ä½ï¼Œå®é™…åº”è¯¥ä»æ–‡ä»¶å¤´è·å–
	sectInfo.AddressDep = "00"
	sectInfo.DataSize = "0C"

	// æ ¹æ®æ®µåç§°è®¾ç½®æƒé™å’Œç±»å‹
	switch {
	case strings.HasPrefix(sect.Name, "__text") || strings.HasPrefix(sect.Name, "__stubs") ||
		strings.HasPrefix(sect.Name, "__stub_helper") || strings.HasPrefix(sect.Name, "__objc_stubs"):
		sectInfo.Executable = true
		sectInfo.Writable = false
		sectInfo.Class = "CODE"
		sectInfo.Base = fmt.Sprintf("%02X", sectInfo.Index+1)
		sectInfo.Align = getAlignmentType(sect.Name)

	case strings.HasPrefix(sect.Name, "__const") || strings.HasPrefix(sect.Name, "__cstring") ||
		strings.HasPrefix(sect.Name, "__objc_") || strings.HasPrefix(sect.Name, "__cfstring"):
		sectInfo.Executable = false
		sectInfo.Writable = false
		sectInfo.Class = "DATA"
		sectInfo.Base = fmt.Sprintf("%02X", sectInfo.Index+1)
		sectInfo.Align = getAlignmentType(sect.Name)

	case strings.HasPrefix(sect.Name, "__data") || strings.HasPrefix(sect.Name, "__got") ||
		strings.HasPrefix(sect.Name, "__la_symbol_ptr") || strings.HasPrefix(sect.Name, "__mod_init_func"):
		sectInfo.Executable = false
		sectInfo.Writable = true
		sectInfo.Class = "DATA"
		sectInfo.Base = fmt.Sprintf("%02X", sectInfo.Index+1)
		sectInfo.Align = getAlignmentType(sect.Name)

	case strings.HasPrefix(sect.Name, "__bss") || strings.HasPrefix(sect.Name, "__common"):
		sectInfo.Executable = false
		sectInfo.Writable = true
		sectInfo.Class = "BSS"
		sectInfo.Base = fmt.Sprintf("%02X", sectInfo.Index+1)
		sectInfo.Align = getAlignmentType(sect.Name)

	default:
		sectInfo.Executable = false
		sectInfo.Writable = false
		sectInfo.Class = "DATA"
		sectInfo.Base = fmt.Sprintf("%02X", sectInfo.Index+1)
		sectInfo.Align = "byte"
	}

	sectInfo.Data = sectInfo.Class == "DATA" || sectInfo.Class == "BSS"
}

// getAlignmentType æ ¹æ®æ®µåè·å–å¯¹é½ç±»å‹
func getAlignmentType(sectName string) string {
	switch {
	case strings.Contains(sectName, "__cstring") || strings.Contains(sectName, "__objc_classname"):
		return "byte"
	case strings.Contains(sectName, "__text") || strings.Contains(sectName, "__const"):
		return "para"
	case strings.Contains(sectName, "__stubs") || strings.Contains(sectName, "__stub_helper"):
		return "dword"
	case strings.Contains(sectName, "__objc_stubs"):
		return "align_32"
	case strings.Contains(sectName, "__got") || strings.Contains(sectName, "__la_symbol_ptr") ||
		strings.Contains(sectName, "__data") || strings.Contains(sectName, "__cfstring"):
		return "qword"
	case strings.Contains(sectName, "__ustring") || strings.Contains(sectName, "__objc_methname"):
		return "word"
	case strings.Contains(sectName, "__eh_frame"):
		return "qword"
	default:
		return "byte"
	}
}

// parseFatMachOSections è§£æFat Mach-Oæ–‡ä»¶çš„æ®µä¿¡æ¯
func (ba *BinaryAnalyzer) parseFatMachOSections(f *macho.FatFile) []SectionInfo {
	var sections []SectionInfo
	index := 0

	// éå†æ‰€æœ‰æ¶æ„
	for archIndex, arch := range f.Arches {
		// æ·»åŠ æ¶æ„ä¿¡æ¯ä½œä¸ºä¸€ä¸ªèŠ‚ç‚¹
		sections = append(sections, SectionInfo{
			Index:      index,
			Name:       fmt.Sprintf("Architecture %d: %s", archIndex, arch.Cpu.String()),
			Offset:     uint64(arch.Offset),
			Size:       uint64(arch.Size),
			Type:       "Architecture",
			ArchIndex:  archIndex,
			ArchOffset: uint64(arch.Offset),
		})
		index++

		// æ·»åŠ è¯¥æ¶æ„çš„æ®µä¿¡æ¯
		for _, sect := range arch.Sections {
			sectInfo := SectionInfo{
				Index:      index,
				Name:       sect.Name,
				Offset:     uint64(arch.Offset + sect.Offset),
				EndOffset:  uint64(arch.Offset+sect.Offset) + sect.Size,
				Size:       sect.Size,
				Type:       fmt.Sprintf("Flags: 0x%X", sect.Flags),
				ArchIndex:  archIndex,
				ArchOffset: uint64(arch.Offset),
			}

			// è®¾ç½®æ®µå±æ€§
			ba.setMachOSectionAttributes(&sectInfo, sect)

			sections = append(sections, sectInfo)
			index++
		}
	}

	return sections
}

// parseELFSections è§£æELFæ–‡ä»¶çš„æ®µä¿¡æ¯
func (ba *BinaryAnalyzer) parseELFSections(f *elf.File, fileType string, bitness int) []SectionInfo {
	var sections []SectionInfo

	// éå†æ‰€æœ‰æ®µ
	for i, sect := range f.Sections {
		sectInfo := SectionInfo{
			Index:  i,
			Name:   sect.Name,
			Offset: sect.Offset,
			Size:   sect.Size,
			Type:   sect.Type.String(),
		}

		// è®¾ç½®æ®µæƒé™
		sectInfo.Readable = sect.Flags&elf.SHF_ALLOC != 0
		sectInfo.Writable = sect.Flags&elf.SHF_WRITE != 0
		sectInfo.Executable = sect.Flags&elf.SHF_EXECINSTR != 0

		// åŠ¨æ€è¯†åˆ«æ•°æ®ç±»å‹
		ba.IdentifySectionDataType(&sectInfo, fileType, bitness)

		sections = append(sections, sectInfo)
	}

	return sections
}

// parsePESections è§£æPEæ–‡ä»¶çš„æ®µä¿¡æ¯
func (ba *BinaryAnalyzer) parsePESections(f *pe.File, fileType string, bitness int) []SectionInfo {
	var sections []SectionInfo

	// éå†æ‰€æœ‰æ®µ
	for i, sect := range f.Sections {
		sectInfo := SectionInfo{
			Index:  i,
			Name:   sect.Name,
			Offset: uint64(sect.Offset),
			Size:   uint64(sect.Size),
			Type:   fmt.Sprintf("VAddr: 0x%X", sect.VirtualAddress),
		}

		// è®¾ç½®æ®µæƒé™ï¼ˆåŸºäºPEç‰¹æ€§ï¼‰
		sectInfo.Readable = sect.Characteristics&pe.IMAGE_SCN_MEM_READ != 0
		sectInfo.Writable = sect.Characteristics&pe.IMAGE_SCN_MEM_WRITE != 0
		sectInfo.Executable = sect.Characteristics&pe.IMAGE_SCN_MEM_EXECUTE != 0

		// åŠ¨æ€è¯†åˆ«æ•°æ®ç±»å‹
		ba.IdentifySectionDataType(&sectInfo, fileType, bitness)

		sections = append(sections, sectInfo)
	}

	return sections
}

// GetSectionData è·å–æŒ‡å®šæ®µçš„æ•°æ®
func (ba *BinaryAnalyzer) GetSectionData(filePath string, sectionIndex int, sections []SectionInfo) ([]byte, error) {
	if sectionIndex < 0 || sectionIndex >= len(sections) {
		return nil, fmt.Errorf("æ— æ•ˆçš„æ®µç´¢å¼•")
	}

	// ä½¿ç”¨hexreplace.goä¸­çš„æ£€æµ‹å’Œæ‰“å¼€é€»è¾‘
	binFile, format, err := detectAndOpenFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("æ‰“å¼€æ–‡ä»¶å¤±è´¥: %v", err)
	}

	// æ ¹æ®æ–‡ä»¶ç±»å‹è·å–æ®µæ•°æ®
	switch f := binFile.(type) {
	case *macho.File:
		if sectionIndex < len(f.Sections) {
			return f.Sections[sectionIndex].Data()
		}
	case *macho.FatFile:
		// Fatæ–‡ä»¶éœ€è¦ç‰¹æ®Šå¤„ç†ï¼Œæ ¹æ®æ®µç´¢å¼•æ‰¾åˆ°å¯¹åº”çš„æ¶æ„å’Œæ®µ
		if sectionIndex < len(sections) {
			section := sections[sectionIndex]

			// å¦‚æœæ˜¯æ¶æ„èŠ‚ç‚¹ï¼Œè¿”å›ç©ºæ•°æ®
			if section.Type == "Architecture" {
				return []byte{}, nil
			}

			// æ‰¾åˆ°å¯¹åº”çš„æ¶æ„
			if section.ArchIndex < len(f.Arches) {
				arch := f.Arches[section.ArchIndex]

				// åœ¨è¯¥æ¶æ„ä¸­æ‰¾åˆ°å¯¹åº”çš„æ®µ
				for _, sect := range arch.Sections {
					if sect.Name == section.Name {
						return sect.Data()
					}
				}
			}
		}
		return nil, fmt.Errorf("æœªæ‰¾åˆ° Fat Mach-O æ®µæ•°æ®")
	case *elf.File:
		if sectionIndex < len(f.Sections) {
			return f.Sections[sectionIndex].Data()
		}
	case *pe.File:
		if sectionIndex < len(f.Sections) {
			return f.Sections[sectionIndex].Data()
		}
	default:
		return nil, fmt.Errorf("ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼: %v", format)
	}

	return nil, fmt.Errorf("æœªæ‰¾åˆ°æ®µæ•°æ®")
}

// isPrintable æ£€æŸ¥å­—ç¬¦æ˜¯å¦å¯æ‰“å°
func isPrintable(b byte) bool {
	return unicode.IsPrint(rune(b)) && b < 127
}

// ExtractStringsFromData ä»æ•°æ®ä¸­æå–å­—ç¬¦ä¸²
func (ba *BinaryAnalyzer) ExtractStringsFromData(data []byte, baseOffset uint64) []StringInfo {
	var strings []StringInfo
	var currentString []byte
	var stringStart uint64
	index := 0

	for i, b := range data {
		if isPrintable(b) {
			if len(currentString) == 0 {
				stringStart = baseOffset + uint64(i)
			}
			currentString = append(currentString, b)
		} else {
			if len(currentString) >= 4 { // åªä¿ç•™é•¿åº¦>=4çš„å­—ç¬¦ä¸²
				str := string(currentString)
				hexData := fmt.Sprintf("%X", currentString)

				strings = append(strings, StringInfo{
					Index:  index,
					Offset: stringStart,
					Data:   hexData,
					Length: len(currentString),
					String: str,
				})
				index++
			}
			currentString = nil
		}
	}

	// å¤„ç†æœ«å°¾çš„å­—ç¬¦ä¸²
	if len(currentString) >= 4 {
		str := string(currentString)
		hexData := fmt.Sprintf("%X", currentString)

		strings = append(strings, StringInfo{
			Index:  index,
			Offset: stringStart,
			Data:   hexData,
			Length: len(currentString),
			String: str,
		})
	}

	return strings
}

// getMachOBitness è·å–Mach-Oæ–‡ä»¶çš„ä½æ•°
func (ba *BinaryAnalyzer) getMachOBitness(f *macho.File) int {
	switch f.Cpu {
	case macho.Cpu386, macho.CpuArm:
		return 32
	case macho.CpuAmd64, macho.CpuArm64:
		return 64
	default:
		return 64 // é»˜è®¤64ä½
	}
}

// getELFBitness è·å–ELFæ–‡ä»¶çš„ä½æ•°
func (ba *BinaryAnalyzer) getELFBitness(f *elf.File) int {
	switch f.Class {
	case elf.ELFCLASS32:
		return 32
	case elf.ELFCLASS64:
		return 64
	default:
		return 64 // é»˜è®¤64ä½
	}
}

// getPEBitness è·å–PEæ–‡ä»¶çš„ä½æ•°
func (ba *BinaryAnalyzer) getPEBitness(f *pe.File) int {
	switch f.Machine {
	case pe.IMAGE_FILE_MACHINE_I386:
		return 32
	case pe.IMAGE_FILE_MACHINE_AMD64:
		return 64
	default:
		return 32 // PEé»˜è®¤32ä½
	}
}

// IdentifySectionDataType åŠ¨æ€è¯†åˆ«æ®µçš„æ•°æ®ç±»å‹
func (ba *BinaryAnalyzer) IdentifySectionDataType(section *SectionInfo, fileType string, bitness int) {
	// è®¾ç½®æŒ‡é’ˆå¤§å°
	section.PointerSize = bitness / 8

	// æ ¹æ®æ®µåç§°åŠ¨æ€è¯†åˆ«æ•°æ®ç±»å‹
	sectionName := strings.ToLower(section.Name)

	// è¯†åˆ«æŒ‡é’ˆæ®µ
	if ba.isPointerSection(sectionName, fileType) {
		section.DataType = "pointer"
		section.ContentFormat = "address"
		return
	}

	// è¯†åˆ«å­—ç¬¦ä¸²æ®µ
	if ba.isStringSection(sectionName, fileType) {
		section.DataType = "string"
		section.ContentFormat = "char"
		return
	}

	// è¯†åˆ«ä»£ç æ®µ
	if ba.isCodeSection(sectionName, fileType) || section.Executable {
		section.DataType = "code"
		section.ContentFormat = "byte"
		return
	}

	// é»˜è®¤ä¸ºæ•°æ®æ®µ
	section.DataType = "data"
	section.ContentFormat = "byte"
}

// isPointerSection åˆ¤æ–­æ˜¯å¦ä¸ºæŒ‡é’ˆæ®µï¼ˆæ ¹æ®æ–‡ä»¶ç±»å‹å’Œæ®µåï¼‰
func (ba *BinaryAnalyzer) isPointerSection(sectionName, fileType string) bool {
	switch fileType {
	case "Mach-O":
		pointerSections := []string{
			"__got",            // Global Offset Table
			"__la_symbol_ptr",  // Lazy symbol pointers
			"__nl_symbol_ptr",  // Non-lazy symbol pointers
			"__mod_init_func",  // Module initialization functions
			"__mod_term_func",  // Module termination functions
			"__auth_ptr",       // Authenticated pointers
			"__objc_classlist", // Objective-C class list
			"__objc_protolist", // Objective-C protocol list
			"__objc_imageinfo", // Objective-C image info
			"__objc_const",     // Objective-C constants (often pointers)
		}
		for _, pattern := range pointerSections {
			if strings.Contains(sectionName, pattern) {
				return true
			}
		}

	case "ELF":
		pointerSections := []string{
			".got",        // Global Offset Table
			".got.plt",    // GOT for PLT
			".plt",        // Procedure Linkage Table
			".init_array", // Initialization function pointers
			".fini_array", // Finalization function pointers
			".ctors",      // Constructor pointers
			".dtors",      // Destructor pointers
			".dynamic",    // Dynamic linking information
		}
		for _, pattern := range pointerSections {
			if strings.Contains(sectionName, pattern) {
				return true
			}
		}

	case "PE":
		pointerSections := []string{
			".idata", // Import data
			".edata", // Export data
			".reloc", // Relocation data
			".tls",   // Thread Local Storage
		}
		for _, pattern := range pointerSections {
			if strings.Contains(sectionName, pattern) {
				return true
			}
		}
	}

	return false
}

// isStringSection åˆ¤æ–­æ˜¯å¦ä¸ºå­—ç¬¦ä¸²æ®µï¼ˆæ ¹æ®æ–‡ä»¶ç±»å‹å’Œæ®µåï¼‰
func (ba *BinaryAnalyzer) isStringSection(sectionName, fileType string) bool {
	switch fileType {
	case "Mach-O":
		stringSections := []string{
			"__cstring",        // C strings
			"__cfstring",       // Core Foundation strings
			"__string",         // General strings
			"__const",          // Constants (often strings)
			"__objc_methname",  // Objective-C method names
			"__objc_classname", // Objective-C class names
			"__objc_methtype",  // Objective-C method types
		}
		for _, pattern := range stringSections {
			if strings.Contains(sectionName, pattern) {
				return true
			}
		}

	case "ELF":
		stringSections := []string{
			".rodata",   // Read-only data (often strings)
			".strtab",   // String table
			".shstrtab", // Section header string table
			".dynstr",   // Dynamic string table
			".comment",  // Comments
		}
		for _, pattern := range stringSections {
			if strings.Contains(sectionName, pattern) {
				return true
			}
		}

	case "PE":
		stringSections := []string{
			".rdata", // Read-only data
			".rsrc",  // Resources (may contain strings)
		}
		for _, pattern := range stringSections {
			if strings.Contains(sectionName, pattern) {
				return true
			}
		}
	}

	return false
}

// isCodeSection åˆ¤æ–­æ˜¯å¦ä¸ºä»£ç æ®µï¼ˆæ ¹æ®æ–‡ä»¶ç±»å‹å’Œæ®µåï¼‰
func (ba *BinaryAnalyzer) isCodeSection(sectionName, fileType string) bool {
	switch fileType {
	case "Mach-O":
		codeSections := []string{
			"__text",        // Code section
			"__stubs",       // Symbol stubs
			"__stub_helper", // Stub helper
		}
		for _, pattern := range codeSections {
			if strings.Contains(sectionName, pattern) {
				return true
			}
		}

	case "ELF":
		codeSections := []string{
			".text", // Code section
			".init", // Initialization code
			".fini", // Finalization code
			".plt",  // Procedure linkage table (code)
		}
		for _, pattern := range codeSections {
			if strings.Contains(sectionName, pattern) {
				return true
			}
		}

	case "PE":
		codeSections := []string{
			".text", // Code section
		}
		for _, pattern := range codeSections {
			if strings.Contains(sectionName, pattern) {
				return true
			}
		}
	}

	return false
}

```

`ui/internal/core/debpackager.go`:

```go
package core

import (
	"archive/tar"
	"bufio"
	"bytes"
	"compress/gzip"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/ulikunitz/xz"
)

// DebPackager DEBåŒ…æ„å»ºå™¨
type DebPackager struct {
	TempDir string
}

// PackageInfo åŒ…ä¿¡æ¯
type PackageInfo struct {
	Name         string
	Version      string
	Architecture string
	Maintainer   string
	Description  string
	Depends      string
	Section      string
	Priority     string
	Homepage     string
	Port         int
	MagicName    string
	IsRootless   bool // æ˜¯å¦ä¸ºrootlessç»“æ„
}

// PathMapper è·¯å¾„æ˜ å°„å™¨ï¼Œç”¨äºå¤„ç†ä¸åŒæ¶æ„çš„è·¯å¾„è½¬æ¢
type PathMapper struct {
	isRootless    bool
	originalPaths map[string]string // åŸå§‹è·¯å¾„ -> æ–°è·¯å¾„æ˜ å°„
}

// NewPathMapper åˆ›å»ºè·¯å¾„æ˜ å°„å™¨
func NewPathMapper(extractDir string) *PathMapper {
	pm := &PathMapper{
		originalPaths: make(map[string]string),
	}

	// æ£€æµ‹æ˜¯å¦ä¸ºrootlessç»“æ„
	rootlessPath := filepath.Join(extractDir, "var", "jb")
	if _, err := os.Stat(rootlessPath); err == nil {
		pm.isRootless = true
		log.Printf("DEBUG: æ£€æµ‹åˆ°rootlessè¶Šç‹±ç»“æ„ï¼Œå°†ä½¿ç”¨ /var/re è·¯å¾„")
	} else {
		pm.isRootless = false
		log.Printf("DEBUG: æ£€æµ‹åˆ°ä¼ ç»Ÿè¶Šç‹±ç»“æ„")
	}

	return pm
}

// MapPath æ˜ å°„è·¯å¾„ï¼Œå°†æ•æ„Ÿè·¯å¾„è½¬æ¢ä¸ºå®‰å…¨è·¯å¾„
func (pm *PathMapper) MapPath(originalPath string) string {
	if !pm.isRootless {
		return originalPath
	}

	// å°† /var/jb æ›¿æ¢ä¸º /var/re
	mapped := strings.ReplaceAll(originalPath, "var/jb", "var/re")
	mapped = strings.ReplaceAll(mapped, "/var/jb", "/var/re")

	// è®°å½•æ˜ å°„å…³ç³»
	if mapped != originalPath {
		pm.originalPaths[originalPath] = mapped
		log.Printf("DEBUG: è·¯å¾„æ˜ å°„: %s -> %s", originalPath, mapped)
	}

	return mapped
}

// DebModifier DEBåŒ…ä¿®æ”¹å™¨ç»“æ„
type DebModifier struct {
	InputPath  string
	OutputPath string
	MagicName  string
	Port       int
	TempDir    string
	ExtractDir string
	PathMapper *PathMapper // è·¯å¾„æ˜ å°„å™¨
}

// NewDebPackager åˆ›å»ºæ–°çš„DEBåŒ…æ„å»ºå™¨
func NewDebPackager() *DebPackager {
	return &DebPackager{}
}

// CreateDebPackage åˆ›å»ºDEBåŒ…
func (dp *DebPackager) CreateDebPackage(fridaFile, outputPath string, info *PackageInfo, progressCallback func(float64, string)) error {
	// åˆ›å»ºä¸´æ—¶ç›®å½•
	tempDir, err := os.MkdirTemp("", "fridare_deb_*")
	if err != nil {
		return fmt.Errorf("åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥: %v", err)
	}
	dp.TempDir = tempDir
	defer os.RemoveAll(tempDir)

	progressCallback(0.1, "åˆ›å»ºä¸´æ—¶ç›®å½•...")

	// æ£€æµ‹Fridaæ–‡ä»¶æ¶æ„
	arch, err := dp.detectArchitecture(fridaFile)
	if err != nil {
		return fmt.Errorf("æ£€æµ‹æ–‡ä»¶æ¶æ„å¤±è´¥: %v", err)
	}
	info.Architecture = arch

	progressCallback(0.2, "æ£€æµ‹æ–‡ä»¶æ¶æ„: "+arch)

	// åˆ›å»ºåŒ…ç›®å½•ç»“æ„
	err = dp.createPackageStructure(tempDir, arch, info)
	if err != nil {
		return fmt.Errorf("åˆ›å»ºåŒ…ç»“æ„å¤±è´¥: %v", err)
	}

	progressCallback(0.3, "åˆ›å»ºåŒ…ç›®å½•ç»“æ„...")

	// å¤åˆ¶Fridaæ–‡ä»¶åˆ°æ­£ç¡®ä½ç½®
	err = dp.copyFridaFile(fridaFile, tempDir, arch, info)
	if err != nil {
		return fmt.Errorf("å¤åˆ¶Fridaæ–‡ä»¶å¤±è´¥: %v", err)
	}

	progressCallback(0.5, "å¤åˆ¶Fridaæ–‡ä»¶...")

	// åˆ›å»ºæ§åˆ¶æ–‡ä»¶
	err = dp.createControlFile(tempDir, info)
	if err != nil {
		return fmt.Errorf("åˆ›å»ºæ§åˆ¶æ–‡ä»¶å¤±è´¥: %v", err)
	}

	progressCallback(0.6, "åˆ›å»ºæ§åˆ¶æ–‡ä»¶...")

	// åˆ›å»ºå¯åŠ¨è„šæœ¬
	err = dp.createLaunchDaemon(tempDir, arch, info)
	if err != nil {
		return fmt.Errorf("åˆ›å»ºå¯åŠ¨è„šæœ¬å¤±è´¥: %v", err)
	}

	progressCallback(0.7, "åˆ›å»ºå¯åŠ¨è„šæœ¬...")

	// åˆ›å»ºå®‰è£…åè„šæœ¬
	err = dp.createPostInstScript(tempDir, info)
	if err != nil {
		return fmt.Errorf("åˆ›å»ºå®‰è£…è„šæœ¬å¤±è´¥: %v", err)
	}

	progressCallback(0.8, "åˆ›å»ºå®‰è£…è„šæœ¬...")

	// æ„å»ºDEBåŒ…
	err = dp.buildDebPackage(tempDir, outputPath, info)
	if err != nil {
		return fmt.Errorf("æ„å»ºDEBåŒ…å¤±è´¥: %v", err)
	}

	progressCallback(1.0, "DEBåŒ…æ„å»ºå®Œæˆ")

	return nil
}

// detectArchitecture æ£€æµ‹æ–‡ä»¶æ¶æ„
func (dp *DebPackager) detectArchitecture(filePath string) (string, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return "", err
	}
	defer file.Close()

	// è¯»å–æ–‡ä»¶å¤´éƒ¨ä¿¡æ¯
	header := make([]byte, 16)
	_, err = file.Read(header)
	if err != nil {
		return "", err
	}

	// æ£€æµ‹Mach-Oæ ¼å¼ (iOS)
	if len(header) >= 4 {
		magic := string(header[:4])
		switch magic {
		case "\xca\xfe\xba\xbe": // FAT binary
			return "iphoneos-arm", nil
		case "\xcf\xfa\xed\xfe": // 64-bit little endian
			return "iphoneos-arm64", nil
		case "\xce\xfa\xed\xfe": // 32-bit little endian
			return "iphoneos-arm", nil
		case "\xfe\xed\xfa\xce": // 32-bit big endian
			return "iphoneos-arm", nil
		case "\xfe\xed\xfa\xcf": // 64-bit big endian
			return "iphoneos-arm64", nil
		}
	}

	// é»˜è®¤è¿”å›arm64
	return "iphoneos-arm64", nil
}

// createPackageStructure åˆ›å»ºåŒ…ç›®å½•ç»“æ„
func (dp *DebPackager) createPackageStructure(tempDir, arch string, info *PackageInfo) error {
	dirs := []string{
		"DEBIAN",
		"usr/bin",
		"Library/LaunchDaemons",
	}

	// æ ¹æ®æ¶æ„åˆ›å»ºä¸åŒçš„ç›®å½•ç»“æ„
	if strings.Contains(arch, "arm64") {
		dirs = append(dirs, "var/re/usr/bin", "var/re/Library/LaunchDaemons")
	}

	for _, dir := range dirs {
		fullPath := filepath.Join(tempDir, dir)
		err := os.MkdirAll(fullPath, 0755)
		if err != nil {
			return err
		}
	}

	return nil
}

// copyFridaFile å¤åˆ¶Fridaæ–‡ä»¶åˆ°æ­£ç¡®ä½ç½®
func (dp *DebPackager) copyFridaFile(srcFile, tempDir, arch string, info *PackageInfo) error {
	var destPaths []string

	// æ ¹æ®æ¶æ„ç¡®å®šç›®æ ‡è·¯å¾„
	if strings.Contains(arch, "arm64") {
		destPaths = []string{
			filepath.Join(tempDir, "var/re/usr/bin", info.MagicName),
			filepath.Join(tempDir, "usr/bin", info.MagicName),
		}
	} else {
		destPaths = []string{
			filepath.Join(tempDir, "usr/bin", info.MagicName),
		}
	}

	// å¤åˆ¶æ–‡ä»¶åˆ°æ‰€æœ‰ç›®æ ‡è·¯å¾„
	for _, destPath := range destPaths {
		err := dp.copyFile(srcFile, destPath)
		if err != nil {
			return err
		}

		// è®¾ç½®å¯æ‰§è¡Œæƒé™
		err = os.Chmod(destPath, 0755)
		if err != nil {
			return err
		}
	}

	return nil
}

// copyFile å¤åˆ¶æ–‡ä»¶
func (dp *DebPackager) copyFile(src, dst string) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	// ç¡®ä¿ç›®å½•å­˜åœ¨
	err = os.MkdirAll(filepath.Dir(dst), 0755)
	if err != nil {
		return err
	}

	dstFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer dstFile.Close()

	_, err = io.Copy(dstFile, srcFile)
	return err
}

// createControlFile åˆ›å»ºæ§åˆ¶æ–‡ä»¶
func (dp *DebPackager) createControlFile(tempDir string, info *PackageInfo) error {
	controlPath := filepath.Join(tempDir, "DEBIAN", "control")

	// è®¡ç®—å®‰è£…å¤§å°
	installedSize, err := dp.calculateInstalledSize(tempDir)
	if err != nil {
		installedSize = 100 // é»˜è®¤å€¼
	}

	content := fmt.Sprintf(`Package: %s
Version: %s
Architecture: %s
Maintainer: %s
Installed-Size: %d
Depends: %s
Section: %s
Priority: %s
Homepage: %s
Description: %s
 Magic name: %s
 Default port: %d
`,
		info.Name,
		info.Version,
		info.Architecture,
		info.Maintainer,
		installedSize,
		info.Depends,
		info.Section,
		info.Priority,
		info.Homepage,
		info.Description,
		info.MagicName,
		info.Port,
	)

	return os.WriteFile(controlPath, []byte(content), 0644)
}

// createLaunchDaemon åˆ›å»ºå¯åŠ¨å®ˆæŠ¤ç¨‹åºé…ç½®
func (dp *DebPackager) createLaunchDaemon(tempDir, arch string, info *PackageInfo) error {
	var plistPaths []string

	// æ ¹æ®æ¶æ„ç¡®å®šplistæ–‡ä»¶è·¯å¾„
	if strings.Contains(arch, "arm64") {
		plistPaths = []string{
			filepath.Join(tempDir, "var/re/Library/LaunchDaemons", fmt.Sprintf("re.%s.server.plist", info.MagicName)),
			filepath.Join(tempDir, "Library/LaunchDaemons", fmt.Sprintf("re.%s.server.plist", info.MagicName)),
		}
	} else {
		plistPaths = []string{
			filepath.Join(tempDir, "Library/LaunchDaemons", fmt.Sprintf("re.%s.server.plist", info.MagicName)),
		}
	}

	// plistå†…å®¹
	plistContent := fmt.Sprintf(`<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Label</key>
	<string>re.%s.server</string>
	<key>ProgramArguments</key>
	<array>
		<string>/usr/bin/%s</string>
		<string>-l</string>
		<string>0.0.0.0:%d</string>
	</array>
	<key>UserName</key>
	<string>root</string>
	<key>RunAtLoad</key>
	<true/>
	<key>KeepAlive</key>
	<true/>
</dict>
</plist>
`, info.MagicName, info.MagicName, info.Port)

	// å†™å…¥æ‰€æœ‰plistæ–‡ä»¶
	for _, plistPath := range plistPaths {
		err := os.WriteFile(plistPath, []byte(plistContent), 0644)
		if err != nil {
			return err
		}
	}

	return nil
}

// createPostInstScript åˆ›å»ºå®‰è£…åè„šæœ¬ (ä¿®å¤ç‰ˆæœ¬)
func (dp *DebPackager) createPostInstScript(tempDir string, info *PackageInfo) error {
	postinstPath := filepath.Join(tempDir, "DEBIAN", "postinst")

	var content string
	if info.IsRootless {
		// Rootlessç»“æ„
		content = fmt.Sprintf(`#!/bin/bash
set -e

# è®¾ç½®å¯æ‰§è¡Œæƒé™ (Rootless)
if [ -f /var/re/usr/sbin/%s ]; then
    chmod 755 /var/re/usr/sbin/%s
    chown root:wheel /var/re/usr/sbin/%s
fi

# è®¾ç½®dylibæƒé™
if [ -d /var/re/usr/lib/%s ]; then
    chmod 755 /var/re/usr/lib/%s/*
    chown root:wheel /var/re/usr/lib/%s/*
fi

# åŠ è½½å®ˆæŠ¤ç¨‹åº
if [ -f /var/re/Library/LaunchDaemons/re.%s.server.plist ]; then
    launchctl load /var/re/Library/LaunchDaemons/re.%s.server.plist
fi

echo "Fridare %s å®‰è£…å®Œæˆ (Rootless)"
echo "æœåŠ¡å·²å¯åŠ¨åœ¨ç«¯å£ %d"
`,
			info.MagicName, info.MagicName, info.MagicName,
			info.MagicName, info.MagicName, info.MagicName,
			info.MagicName, info.MagicName,
			info.MagicName, info.Port,
		)
	} else {
		// Rootç»“æ„
		content = fmt.Sprintf(`#!/bin/bash
set -e

# è®¾ç½®å¯æ‰§è¡Œæƒé™ (Root)
if [ -f /usr/sbin/%s ]; then
    chmod 755 /usr/sbin/%s
    chown root:wheel /usr/sbin/%s
fi

# è®¾ç½®dylibæƒé™
if [ -d /usr/lib/%s ]; then
    chmod 755 /usr/lib/%s/*
    chown root:wheel /usr/lib/%s/*
fi

# åŠ è½½å®ˆæŠ¤ç¨‹åº
if [ -f /Library/LaunchDaemons/re.%s.server.plist ]; then
    launchctl load /Library/LaunchDaemons/re.%s.server.plist
fi

echo "Fridare %s å®‰è£…å®Œæˆ (Root)"
echo "æœåŠ¡å·²å¯åŠ¨åœ¨ç«¯å£ %d"
`,
			info.MagicName, info.MagicName, info.MagicName,
			info.MagicName, info.MagicName, info.MagicName,
			info.MagicName, info.MagicName,
			info.MagicName, info.Port,
		)
	}

	err := os.WriteFile(postinstPath, []byte(content), 0755)
	if err != nil {
		return err
	}

	// åˆ›å»ºå¸è½½å‰è„šæœ¬
	prermPath := filepath.Join(tempDir, "DEBIAN", "prerm")
	var prermContent string

	if info.IsRootless {
		prermContent = fmt.Sprintf(`#!/bin/bash
set -e

# åœæ­¢å®ˆæŠ¤ç¨‹åº (Rootless)
if [ -f /var/re/Library/LaunchDaemons/re.%s.server.plist ]; then
    launchctl unload /var/re/Library/LaunchDaemons/re.%s.server.plist 2>/dev/null || true
fi

echo "Fridare %s æœåŠ¡å·²åœæ­¢ (Rootless)"
`,
			info.MagicName, info.MagicName, info.MagicName,
		)
	} else {
		prermContent = fmt.Sprintf(`#!/bin/bash
set -e

# åœæ­¢å®ˆæŠ¤ç¨‹åº (Root)
if [ -f /Library/LaunchDaemons/re.%s.server.plist ]; then
    launchctl unload /Library/LaunchDaemons/re.%s.server.plist 2>/dev/null || true
fi

echo "Fridare %s æœåŠ¡å·²åœæ­¢ (Root)"
`,
			info.MagicName, info.MagicName, info.MagicName,
		)
	}

	return os.WriteFile(prermPath, []byte(prermContent), 0755)
}

// calculateInstalledSize è®¡ç®—å®‰è£…å¤§å°ï¼ˆKBï¼‰
func (dp *DebPackager) calculateInstalledSize(dir string) (int, error) {
	var totalSize int64

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && !strings.Contains(path, "DEBIAN") {
			totalSize += info.Size()
		}
		return nil
	})

	if err != nil {
		return 0, err
	}

	// è½¬æ¢ä¸ºKBå¹¶å‘ä¸Šå–æ•´
	sizeKB := int((totalSize + 1023) / 1024)
	return sizeKB, nil
}

// buildDebPackage æ„å»ºDEBåŒ…
func (dp *DebPackager) buildDebPackage(tempDir, outputPath string, info *PackageInfo) error {
	// æ£€æŸ¥æ˜¯å¦æœ‰dpkg-debå‘½ä»¤
	if _, err := exec.LookPath("dpkg-deb"); err == nil {
		return dp.buildWithDpkgDeb(tempDir, outputPath)
	}

	// å¦‚æœæ²¡æœ‰dpkg-debï¼Œä½¿ç”¨å†…ç½®æ–¹æ³•
	return dp.buildWithTar(tempDir, outputPath, info)
}

// buildWithDpkgDeb ä½¿ç”¨dpkg-debæ„å»º
func (dp *DebPackager) buildWithDpkgDeb(tempDir, outputPath string) error {
	cmd := exec.Command("dpkg-deb", "--build", tempDir, outputPath)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("dpkg-deb æ‰§è¡Œå¤±è´¥: %v, è¾“å‡º: %s", err, string(output))
	}
	return nil
}

// buildWithTar ä½¿ç”¨taræ„å»ºï¼ˆå†…ç½®æ–¹æ³•ï¼‰
func (dp *DebPackager) buildWithTar(tempDir, outputPath string, info *PackageInfo) error {
	// åˆ›å»ºdata.tar.gz
	dataPath := filepath.Join(tempDir, "data.tar.gz")
	err := dp.createDataTar(tempDir, dataPath)
	if err != nil {
		return err
	}

	// åˆ›å»ºcontrol.tar.gz
	controlPath := filepath.Join(tempDir, "control.tar.gz")
	err = dp.createControlTar(tempDir, controlPath)
	if err != nil {
		return err
	}

	// åˆ›å»ºdebian-binaryæ–‡ä»¶
	debianBinaryPath := filepath.Join(tempDir, "debian-binary")
	err = os.WriteFile(debianBinaryPath, []byte("2.0\n"), 0644)
	if err != nil {
		return err
	}

	// åˆ›å»ºæœ€ç»ˆçš„.debæ–‡ä»¶
	return dp.createDebFile(tempDir, outputPath)
}

// createDataTar åˆ›å»ºdata.tar.gz
func (dp *DebPackager) createDataTar(tempDir, outputPath string) error {
	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	gzWriter := gzip.NewWriter(file)
	defer gzWriter.Close()

	tarWriter := tar.NewWriter(gzWriter)
	defer tarWriter.Close()

	// éå†å¹¶æ·»åŠ éDEBIANç›®å½•çš„æ‰€æœ‰æ–‡ä»¶
	return filepath.Walk(tempDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		relPath, err := filepath.Rel(tempDir, path)
		if err != nil {
			return err
		}

		// è·³è¿‡DEBIANç›®å½•å’Œä¸´æ—¶æ–‡ä»¶
		if strings.HasPrefix(relPath, "DEBIAN") || strings.Contains(relPath, ".tar.gz") || relPath == "debian-binary" {
			return nil
		}

		if relPath == "." {
			return nil
		}

		// åˆ›å»ºtarå¤´éƒ¨
		header, err := tar.FileInfoHeader(info, "")
		if err != nil {
			return err
		}

		header.Name = "./" + relPath

		err = tarWriter.WriteHeader(header)
		if err != nil {
			return err
		}

		// å¦‚æœæ˜¯æ–‡ä»¶ï¼Œå†™å…¥å†…å®¹
		if !info.IsDir() {
			file, err := os.Open(path)
			if err != nil {
				return err
			}
			defer file.Close()

			_, err = io.Copy(tarWriter, file)
			if err != nil {
				return err
			}
		}

		return nil
	})
}

// createControlTar åˆ›å»ºcontrol.tar.gz
func (dp *DebPackager) createControlTar(tempDir, outputPath string) error {
	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	gzWriter := gzip.NewWriter(file)
	defer gzWriter.Close()

	tarWriter := tar.NewWriter(gzWriter)
	defer tarWriter.Close()

	debianDir := filepath.Join(tempDir, "DEBIAN")

	// éå†DEBIANç›®å½•
	return filepath.Walk(debianDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		relPath, err := filepath.Rel(debianDir, path)
		if err != nil {
			return err
		}

		if relPath == "." {
			return nil
		}

		// åˆ›å»ºtarå¤´éƒ¨
		header, err := tar.FileInfoHeader(info, "")
		if err != nil {
			return err
		}

		header.Name = "./" + relPath

		err = tarWriter.WriteHeader(header)
		if err != nil {
			return err
		}

		// å¦‚æœæ˜¯æ–‡ä»¶ï¼Œå†™å…¥å†…å®¹
		if !info.IsDir() {
			file, err := os.Open(path)
			if err != nil {
				return err
			}
			defer file.Close()

			_, err = io.Copy(tarWriter, file)
			if err != nil {
				return err
			}
		}

		return nil
	})
}

// createDebFile åˆ›å»ºæœ€ç»ˆçš„.debæ–‡ä»¶
func (dp *DebPackager) createDebFile(tempDir, outputPath string) error {
	debFile, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer debFile.Close()

	// å†™å…¥debian-binary
	debianBinaryPath := filepath.Join(tempDir, "debian-binary")
	err = dp.appendFile(debFile, debianBinaryPath)
	if err != nil {
		return err
	}

	// å†™å…¥control.tar.gz
	controlPath := filepath.Join(tempDir, "control.tar.gz")
	err = dp.appendFile(debFile, controlPath)
	if err != nil {
		return err
	}

	// å†™å…¥data.tar.gz
	dataPath := filepath.Join(tempDir, "data.tar.gz")
	return dp.appendFile(debFile, dataPath)
}

// appendFile å°†æ–‡ä»¶å†…å®¹è¿½åŠ åˆ°å¦ä¸€ä¸ªæ–‡ä»¶
func (dp *DebPackager) appendFile(dst *os.File, srcPath string) error {
	src, err := os.Open(srcPath)
	if err != nil {
		return err
	}
	defer src.Close()

	_, err = io.Copy(dst, src)
	return err
}

// ValidatePackageInfo éªŒè¯åŒ…ä¿¡æ¯
func (dp *DebPackager) ValidatePackageInfo(info *PackageInfo) error {
	if info.Name == "" {
		return fmt.Errorf("åŒ…åä¸èƒ½ä¸ºç©º")
	}
	if info.Version == "" {
		return fmt.Errorf("ç‰ˆæœ¬ä¸èƒ½ä¸ºç©º")
	}
	if info.Maintainer == "" {
		return fmt.Errorf("ç»´æŠ¤è€…ä¸èƒ½ä¸ºç©º")
	}
	if info.MagicName == "" {
		return fmt.Errorf("é­”æ”¹åç§°ä¸èƒ½ä¸ºç©º")
	}
	if len(info.MagicName) != 5 {
		return fmt.Errorf("é­”æ”¹åç§°å¿…é¡»ä¸º5ä¸ªå­—ç¬¦")
	}
	if info.Port <= 0 || info.Port > 65535 {
		return fmt.Errorf("ç«¯å£å·å¿…é¡»åœ¨1-65535ä¹‹é—´")
	}
	return nil
}

// GetDefaultPackageInfo è·å–é»˜è®¤åŒ…ä¿¡æ¯
func (dp *DebPackager) GetDefaultPackageInfo() *PackageInfo {
	return &PackageInfo{
		Name:         "com.fridare.server",
		Version:      "1.0.0",
		Architecture: "iphoneos-arm64",
		Maintainer:   "Fridare Team <suifei@gmail.com>",
		Description:  "Modified Frida Server for iOS",
		Depends:      "",
		Section:      "Development",
		Priority:     "optional",
		Homepage:     "https://github.com/suifei/fridare",
		Port:         27042,
		MagicName:    "frida",
	}
}

// NewDebModifier åˆ›å»ºæ–°çš„DEBåŒ…ä¿®æ”¹å™¨
func NewDebModifier(inputPath, outputPath, magicName string, port int) *DebModifier {
	return &DebModifier{
		InputPath:  inputPath,
		OutputPath: outputPath,
		MagicName:  magicName,
		Port:       port,
	}
}

// ModifyDebPackage ä¿®æ”¹ç°æœ‰DEBåŒ… - ä¸»è¦åŠŸèƒ½å‡½æ•°
func (dm *DebModifier) ModifyDebPackage(progressCallback func(float64, string)) error {
	log.Printf("INFO: å¼€å§‹ä¿®æ”¹DEBåŒ… - è¾“å…¥: %s, è¾“å‡º: %s, é­”æ”¹å: %s, ç«¯å£: %d",
		dm.InputPath, dm.OutputPath, dm.MagicName, dm.Port)

	// è·å–è¾“å…¥æ–‡ä»¶å¤§å°
	if stat, err := os.Stat(dm.InputPath); err == nil {
		log.Printf("INFO: è¾“å…¥DEBæ–‡ä»¶å¤§å°: %d å­—èŠ‚ (%.2f KB)", stat.Size(), float64(stat.Size())/1024)
	}

	// åˆ›å»ºä¸´æ—¶ç›®å½•
	tempDir, err := os.MkdirTemp("", "fridare_modify_*")
	if err != nil {
		log.Printf("ERROR: åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥: %v", err)
		return fmt.Errorf("åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥: %v", err)
	}
	dm.TempDir = tempDir
	log.Printf("DEBUG: åˆ›å»ºä¸´æ—¶ç›®å½•: %s", tempDir)
	defer func() {
		log.Printf("DEBUG: æ¸…ç†ä¸´æ—¶ç›®å½•: %s", tempDir)
		os.RemoveAll(tempDir)
	}()

	dm.ExtractDir = filepath.Join(tempDir, "extracted")
	err = os.MkdirAll(dm.ExtractDir, 0755)
	if err != nil {
		log.Printf("ERROR: åˆ›å»ºè§£å‹ç›®å½•å¤±è´¥: %v", err)
		return fmt.Errorf("åˆ›å»ºè§£å‹ç›®å½•å¤±è´¥: %v", err)
	}
	log.Printf("DEBUG: åˆ›å»ºè§£å‹ç›®å½•: %s", dm.ExtractDir)

	progressCallback(0.1, "è§£å‹DEBåŒ…...")

	// 1. è§£å‹ç°æœ‰DEBåŒ…
	log.Printf("INFO: æ­¥éª¤1 - è§£å‹DEBåŒ…")
	err = dm.extractDebPackage()
	if err != nil {
		log.Printf("ERROR: è§£å‹DEBåŒ…å¤±è´¥: %v", err)
		return fmt.Errorf("è§£å‹DEBåŒ…å¤±è´¥: %v", err)
	}

	// åˆå§‹åŒ–è·¯å¾„æ˜ å°„å™¨
	dm.PathMapper = NewPathMapper(dm.ExtractDir)

	progressCallback(0.3, "è¯»å–åŒ…ä¿¡æ¯...")

	// 2. è¯»å–åŒ…ä¿¡æ¯
	log.Printf("INFO: æ­¥éª¤2 - è¯»å–åŒ…ä¿¡æ¯")
	packageInfo, err := dm.readPackageInfo()
	if err != nil {
		log.Printf("ERROR: è¯»å–åŒ…ä¿¡æ¯å¤±è´¥: %v", err)
		return fmt.Errorf("è¯»å–åŒ…ä¿¡æ¯å¤±è´¥: %v", err)
	}
	log.Printf("DEBUG: åŒ…ä¿¡æ¯ - åç§°: %s, ç‰ˆæœ¬: %s, æ¶æ„: %s", packageInfo.Name, packageInfo.Version, packageInfo.Architecture)

	progressCallback(0.4, "ä¿®æ”¹åŒ…å…ƒæ•°æ®...")

	// 3. ä¿®æ”¹åŒ…å…ƒæ•°æ®
	log.Printf("INFO: æ­¥éª¤3 - ä¿®æ”¹åŒ…å…ƒæ•°æ®")
	err = dm.modifyPackageMetadata(packageInfo)
	if err != nil {
		log.Printf("ERROR: ä¿®æ”¹åŒ…å…ƒæ•°æ®å¤±è´¥: %v", err)
		return fmt.Errorf("ä¿®æ”¹åŒ…å…ƒæ•°æ®å¤±è´¥: %v", err)
	}

	progressCallback(0.5, "ä¿®æ”¹äºŒè¿›åˆ¶æ–‡ä»¶...")

	// 4. ä¿®æ”¹äºŒè¿›åˆ¶æ–‡ä»¶å
	log.Printf("INFO: æ­¥éª¤4 - ä¿®æ”¹äºŒè¿›åˆ¶æ–‡ä»¶")
	err = dm.modifyBinaryFiles()
	if err != nil {
		log.Printf("ERROR: ä¿®æ”¹äºŒè¿›åˆ¶æ–‡ä»¶å¤±è´¥: %v", err)
		return fmt.Errorf("ä¿®æ”¹äºŒè¿›åˆ¶æ–‡ä»¶å¤±è´¥: %v", err)
	}

	progressCallback(0.7, "ä¿®æ”¹å¯åŠ¨å®ˆæŠ¤è¿›ç¨‹...")

	// 5. ä¿®æ”¹å¯åŠ¨å®ˆæŠ¤è¿›ç¨‹é…ç½®
	log.Printf("INFO: æ­¥éª¤5 - ä¿®æ”¹å¯åŠ¨å®ˆæŠ¤è¿›ç¨‹é…ç½®")
	err = dm.modifyLaunchDaemon()
	if err != nil {
		log.Printf("ERROR: ä¿®æ”¹å¯åŠ¨å®ˆæŠ¤è¿›ç¨‹å¤±è´¥: %v", err)
		return fmt.Errorf("ä¿®æ”¹å¯åŠ¨å®ˆæŠ¤è¿›ç¨‹å¤±è´¥: %v", err)
	}

	progressCallback(0.8, "ä¿®æ”¹DEBIANè„šæœ¬...")

	// 6. ä¿®æ”¹DEBIANç›®å½•ä¸­çš„è„šæœ¬
	log.Printf("INFO: æ­¥éª¤6 - ä¿®æ”¹DEBIANè„šæœ¬")
	err = dm.modifyDebianScripts()
	if err != nil {
		log.Printf("ERROR: ä¿®æ”¹DEBIANè„šæœ¬å¤±è´¥: %v", err)
		return fmt.Errorf("ä¿®æ”¹DEBIANè„šæœ¬å¤±è´¥: %v", err)
	}

	progressCallback(0.9, "é‡æ–°æ‰“åŒ…DEB...")

	// 7. é‡æ–°æ‰“åŒ…
	log.Printf("INFO: æ­¥éª¤7 - é‡æ–°æ‰“åŒ…DEBæ–‡ä»¶")
	err = dm.repackageDebFile()
	if err != nil {
		log.Printf("ERROR: é‡æ–°æ‰“åŒ…å¤±è´¥: %v", err)
		return fmt.Errorf("é‡æ–°æ‰“åŒ…å¤±è´¥: %v", err)
	}

	// è·å–è¾“å‡ºæ–‡ä»¶å¤§å°
	if stat, err := os.Stat(dm.OutputPath); err == nil {
		log.Printf("INFO: è¾“å‡ºDEBæ–‡ä»¶å¤§å°: %d å­—èŠ‚ (%.2f KB)", stat.Size(), float64(stat.Size())/1024)
	}

	progressCallback(1.0, "DEBåŒ…ä¿®æ”¹å®Œæˆ!")
	log.Printf("SUCCESS: DEBåŒ…ä¿®æ”¹å®Œæˆ: %s", dm.OutputPath)
	return nil
}

// extractDebPackage è§£å‹DEBåŒ…ï¼ˆçº¯Goå®ç°ï¼‰
func (dm *DebModifier) extractDebPackage() error {
	// DEBåŒ…æ˜¯ARæ ¼å¼çš„æ¡£æ¡ˆï¼ŒåŒ…å«debian-binaryã€control.tar.xzã€data.tar.xz
	return dm.extractDebWithGoAr()
}

// extractDebWithGoAr ä½¿ç”¨çº¯Goæ–¹å¼è§£æARæ ¼å¼è§£å‹DEBæ–‡ä»¶
func (dm *DebModifier) extractDebWithGoAr() error {
	log.Printf("INFO: å¼€å§‹è§£å‹DEBæ–‡ä»¶: %s -> %s", dm.InputPath, dm.ExtractDir)

	file, err := os.Open(dm.InputPath)
	if err != nil {
		log.Printf("ERROR: æ‰“å¼€DEBæ–‡ä»¶å¤±è´¥: %v", err)
		return fmt.Errorf("æ‰“å¼€DEBæ–‡ä»¶å¤±è´¥: %v", err)
	}
	defer file.Close()

	// è·å–æ–‡ä»¶å¤§å°
	stat, err := file.Stat()
	if err != nil {
		log.Printf("WARNING: è·å–DEBæ–‡ä»¶å¤§å°å¤±è´¥: %v", err)
	} else {
		log.Printf("INFO: DEBæ–‡ä»¶å¤§å°: %d å­—èŠ‚", stat.Size())
	}

	// è¯»å–ARæ–‡ä»¶å¤´éƒ¨
	header := make([]byte, 8)
	_, err = file.Read(header)
	if err != nil {
		log.Printf("ERROR: è¯»å–ARå¤´éƒ¨å¤±è´¥: %v", err)
		return fmt.Errorf("è¯»å–ARå¤´éƒ¨å¤±è´¥: %v", err)
	}

	if string(header) != "!<arch>\n" {
		log.Printf("ERROR: ä¸æ˜¯æœ‰æ•ˆçš„ARæ–‡ä»¶ï¼Œå¤´éƒ¨: %q", string(header))
		return fmt.Errorf("ä¸æ˜¯æœ‰æ•ˆçš„ARæ–‡ä»¶")
	}
	log.Printf("DEBUG: ARæ–‡ä»¶å¤´éƒ¨éªŒè¯é€šè¿‡")

	var controlData, dataArchive []byte
	entryCount := 0

	// è§£æARæ–‡ä»¶æ¡ç›®
	for {
		entry, err := dm.readArEntry(file)
		if err == io.EOF {
			log.Printf("DEBUG: ARæ–‡ä»¶è§£æå®Œæˆï¼Œå…±å¤„ç† %d ä¸ªæ¡ç›®", entryCount)
			break
		}
		if err != nil {
			log.Printf("ERROR: è¯»å–ARæ¡ç›®å¤±è´¥: %v", err)
			return fmt.Errorf("è¯»å–ARæ¡ç›®å¤±è´¥: %v", err)
		}

		entryCount++
		log.Printf("DEBUG: å¤„ç†ARæ¡ç›® %d: åç§°=%s, å¤§å°=%d å­—èŠ‚", entryCount, entry.Name, entry.Size)

		// è¯»å–æ–‡ä»¶å†…å®¹
		content := make([]byte, entry.Size)
		_, err = io.ReadFull(file, content)
		if err != nil {
			log.Printf("ERROR: è¯»å–ARæ–‡ä»¶å†…å®¹å¤±è´¥: %s, é”™è¯¯: %v", entry.Name, err)
			return fmt.Errorf("è¯»å–ARæ–‡ä»¶å†…å®¹å¤±è´¥: %v", err)
		}

		switch entry.Name {
		case "control.tar.xz", "control.tar.gz":
			controlData = content
			log.Printf("INFO: ä¿å­˜controlæ¡£æ¡ˆ: %s, å¤§å°: %d å­—èŠ‚", entry.Name, len(content))
		case "data.tar.xz", "data.tar.gz":
			dataArchive = content
			log.Printf("INFO: ä¿å­˜dataæ¡£æ¡ˆ: %s, å¤§å°: %d å­—èŠ‚", entry.Name, len(content))
		case "debian-binary":
			log.Printf("INFO: debian-binaryå†…å®¹: %q", string(content))
			continue
		default:
			log.Printf("INFO: è·³è¿‡æœªçŸ¥æ¡ç›®: %s", entry.Name)
		}

		// ARæ–‡ä»¶è¦æ±‚å¶æ•°å­—èŠ‚å¯¹é½
		if entry.Size%2 == 1 {
			file.Seek(1, 1)
			log.Printf("DEBUG: è·³è¿‡å¯¹é½å¡«å……å­—èŠ‚: %s", entry.Name)
		}
	}

	// è§£å‹control.tar.xzåˆ°DEBIANç›®å½•
	controlDir := filepath.Join(dm.ExtractDir, "DEBIAN")
	err = os.MkdirAll(controlDir, 0755)
	if err != nil {
		log.Printf("ERROR: åˆ›å»ºDEBIANç›®å½•å¤±è´¥: %v", err)
		return err
	}

	if len(controlData) > 0 {
		log.Printf("INFO: å¼€å§‹è§£å‹controlæ¡£æ¡ˆåˆ°: %s", controlDir)
		err = dm.extractTarArchive(controlData, controlDir)
		if err != nil {
			log.Printf("ERROR: è§£å‹control.tarå¤±è´¥: %v", err)
			return fmt.Errorf("è§£å‹control.tarå¤±è´¥: %v", err)
		}
	} else {
		log.Printf("WARNING: æœªæ‰¾åˆ°controlæ¡£æ¡ˆæ•°æ®")
	}

	// è§£å‹data.tar.xzåˆ°æ ¹ç›®å½•
	if len(dataArchive) > 0 {
		log.Printf("INFO: å¼€å§‹è§£å‹dataæ¡£æ¡ˆåˆ°: %s", dm.ExtractDir)
		err = dm.extractTarArchive(dataArchive, dm.ExtractDir)
		if err != nil {
			log.Printf("ERROR: è§£å‹data.tarå¤±è´¥: %v", err)
			return fmt.Errorf("è§£å‹data.tarå¤±è´¥: %v", err)
		}
	} else {
		log.Printf("WARNING: æœªæ‰¾åˆ°dataæ¡£æ¡ˆæ•°æ®")
	}

	log.Printf("SUCCESS: DEBæ–‡ä»¶è§£å‹å®Œæˆ: %s", dm.ExtractDir)
	return nil
}

// arEntry ARæ–‡ä»¶æ¡ç›®
type arEntry struct {
	Name string
	Size int64
}

// readArEntry è¯»å–ARæ–‡ä»¶æ¡ç›®å¤´éƒ¨
func (dm *DebModifier) readArEntry(file *os.File) (*arEntry, error) {
	header := make([]byte, 60)
	n, err := file.Read(header)
	if err != nil {
		return nil, err
	}
	if n != 60 {
		return nil, io.EOF
	}

	// è§£ææ–‡ä»¶åï¼ˆ16å­—èŠ‚ï¼‰
	nameBytes := header[0:16]
	name := strings.TrimSpace(string(nameBytes))

	// è§£ææ–‡ä»¶å¤§å°ï¼ˆ10å­—èŠ‚ï¼Œä½ç½®48-58ï¼‰
	sizeBytes := header[48:58]
	sizeStr := strings.TrimSpace(string(sizeBytes))
	size, err := strconv.ParseInt(sizeStr, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("è§£ææ–‡ä»¶å¤§å°å¤±è´¥: %v", err)
	}

	return &arEntry{
		Name: name,
		Size: size,
	}, nil
}

// extractTarArchive è§£å‹taræ¡£æ¡ˆï¼ˆæ”¯æŒgzipå’Œxzå‹ç¼©ï¼‰
func (dm *DebModifier) extractTarArchive(data []byte, targetDir string) error {
	log.Printf("DEBUG: å¼€å§‹è§£å‹taræ¡£æ¡ˆï¼Œæ•°æ®å¤§å°: %d å­—èŠ‚ï¼Œç›®æ ‡ç›®å½•: %s", len(data), targetDir)

	var reader io.Reader = bytes.NewReader(data)
	var compressionType string = "æœªå‹ç¼©"

	// æ£€æŸ¥å‹ç¼©æ ¼å¼
	if len(data) >= 2 {
		// æ£€æŸ¥æ˜¯å¦æ˜¯gzipæ ¼å¼ (0x1f, 0x8b)
		if data[0] == 0x1f && data[1] == 0x8b {
			compressionType = "gzip"
			log.Printf("DEBUG: æ£€æµ‹åˆ°gzipå‹ç¼©æ ¼å¼")
			gzReader, err := gzip.NewReader(reader)
			if err != nil {
				log.Printf("ERROR: åˆ›å»ºgzipè¯»å–å™¨å¤±è´¥: %v", err)
				return fmt.Errorf("åˆ›å»ºgzipè¯»å–å™¨å¤±è´¥: %v", err)
			}
			defer gzReader.Close()
			reader = gzReader
		} else if len(data) >= 6 {
			// æ£€æŸ¥æ˜¯å¦æ˜¯xzæ ¼å¼ (0xFD, '7', 'z', 'X', 'Z', 0x00)
			xzHeader := []byte{0xFD, '7', 'z', 'X', 'Z', 0x00}
			if bytes.Equal(data[:6], xzHeader) {
				compressionType = "xz"
				log.Printf("DEBUG: æ£€æµ‹åˆ°xzå‹ç¼©æ ¼å¼")
				xzReader, err := xz.NewReader(reader)
				if err != nil {
					log.Printf("ERROR: åˆ›å»ºxzè¯»å–å™¨å¤±è´¥: %v", err)
					return fmt.Errorf("åˆ›å»ºxzè¯»å–å™¨å¤±è´¥: %v", err)
				}
				reader = xzReader
			} else {
				log.Printf("DEBUG: æ£€æµ‹åˆ°æœªçŸ¥å‹ç¼©æ ¼å¼ï¼Œå¤´éƒ¨å­—èŠ‚: %x", data[:6])
			}
		}
	}

	log.Printf("INFO: taræ¡£æ¡ˆå‹ç¼©ç±»å‹: %s", compressionType)

	// è§£å‹taræ¡£æ¡ˆ
	tarReader := tar.NewReader(reader)

	var fileCount, dirCount int
	var totalSize int64

	for {
		header, err := tarReader.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Printf("ERROR: è¯»å–tarå¤´å¤±è´¥: %v", err)
			return fmt.Errorf("è¯»å–tarå¤´å¤±è´¥: %v", err)
		}

		// æ„é€ ç›®æ ‡è·¯å¾„ï¼Œåº”ç”¨è·¯å¾„æ˜ å°„
		originalName := header.Name
		mappedName := originalName

		// å¦‚æœæ˜¯rootlessç»“æ„ï¼Œå°† var/jb æ›¿æ¢ä¸º var/re
		if strings.Contains(originalName, "var/jb") {
			mappedName = strings.ReplaceAll(originalName, "var/jb", "var/re")
			log.Printf("DEBUG: è·¯å¾„æ˜ å°„: %s -> %s", originalName, mappedName)
		}

		targetPath := filepath.Join(targetDir, mappedName)
		log.Printf("DEBUG: å¤„ç†taræ¡ç›®: %s -> %s, ç±»å‹: %d, å¤§å°: %d, æƒé™: %o",
			mappedName, targetPath, header.Typeflag, header.Size, header.Mode)

		// ç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨
		if header.Typeflag == tar.TypeDir {
			dirCount++
			err = os.MkdirAll(targetPath, os.FileMode(header.Mode))
			if err != nil {
				log.Printf("ERROR: åˆ›å»ºç›®å½•å¤±è´¥: %s, é”™è¯¯: %v", targetPath, err)
				return fmt.Errorf("åˆ›å»ºç›®å½•å¤±è´¥: %v", err)
			}
			log.Printf("DEBUG: ç›®å½•åˆ›å»ºæˆåŠŸ: %s", targetPath)
			continue
		}

		// ç¡®ä¿çˆ¶ç›®å½•å­˜åœ¨
		parentDir := filepath.Dir(targetPath)
		err = os.MkdirAll(parentDir, 0755)
		if err != nil {
			log.Printf("ERROR: åˆ›å»ºçˆ¶ç›®å½•å¤±è´¥: %s, é”™è¯¯: %v", parentDir, err)
			return fmt.Errorf("åˆ›å»ºçˆ¶ç›®å½•å¤±è´¥: %v", err)
		}

		// åˆ›å»ºæ–‡ä»¶
		switch header.Typeflag {
		case tar.TypeReg:
			fileCount++
			totalSize += header.Size

			file, err := os.OpenFile(targetPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, os.FileMode(header.Mode))
			if err != nil {
				log.Printf("ERROR: åˆ›å»ºæ–‡ä»¶å¤±è´¥: %s, é”™è¯¯: %v", targetPath, err)
				return fmt.Errorf("åˆ›å»ºæ–‡ä»¶å¤±è´¥: %v", err)
			}

			written, err := io.Copy(file, tarReader)
			file.Close()
			if err != nil {
				log.Printf("ERROR: å†™å…¥æ–‡ä»¶å†…å®¹å¤±è´¥: %s, é”™è¯¯: %v", targetPath, err)
				return fmt.Errorf("å†™å…¥æ–‡ä»¶å†…å®¹å¤±è´¥: %v", err)
			}

			if written != header.Size {
				log.Printf("WARNING: æ–‡ä»¶å¤§å°ä¸åŒ¹é…: %s, æœŸæœ›: %d, å®é™…: %d", targetPath, header.Size, written)
			}

			log.Printf("DEBUG: æ–‡ä»¶åˆ›å»ºæˆåŠŸ: %s, å†™å…¥: %d å­—èŠ‚", targetPath, written)

		case tar.TypeSymlink:
			log.Printf("DEBUG: åˆ›å»ºç¬¦å·é“¾æ¥: %s -> %s", targetPath, header.Linkname)
			err = os.Symlink(header.Linkname, targetPath)
			if err != nil {
				log.Printf("WARNING: åˆ›å»ºç¬¦å·é“¾æ¥å¤±è´¥: %s -> %s, é”™è¯¯: %v", targetPath, header.Linkname, err)
				// Windowsä¸‹å¯èƒ½ä¸æ”¯æŒç¬¦å·é“¾æ¥ï¼Œå¿½ç•¥é”™è¯¯
				continue
			}
		default:
			log.Printf("WARNING: è·³è¿‡ä¸æ”¯æŒçš„taræ¡ç›®ç±»å‹: %s, ç±»å‹: %d", header.Name, header.Typeflag)
		}
	}

	log.Printf("INFO: taræ¡£æ¡ˆè§£å‹å®Œæˆ - ç›®å½•æ•°: %d, æ–‡ä»¶æ•°: %d, æ€»å¤§å°: %d å­—èŠ‚", dirCount, fileCount, totalSize)
	return nil
}

// readPackageInfo è¯»å–åŒ…ä¿¡æ¯
func (dm *DebModifier) readPackageInfo() (*PackageInfo, error) {
	controlFile := filepath.Join(dm.ExtractDir, "DEBIAN", "control")

	file, err := os.Open(controlFile)
	if err != nil {
		return nil, fmt.Errorf("æ‰“å¼€controlæ–‡ä»¶å¤±è´¥: %v", err)
	}
	defer file.Close()

	info := &PackageInfo{}
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		if strings.Contains(line, ":") {
			parts := strings.SplitN(line, ":", 2)
			if len(parts) == 2 {
				key := strings.TrimSpace(parts[0])
				value := strings.TrimSpace(parts[1])

				switch key {
				case "Package":
					info.Name = value
				case "Version":
					info.Version = value
				case "Architecture":
					info.Architecture = value
				case "Maintainer":
					info.Maintainer = value
				case "Description":
					info.Description = value
				case "Depends":
					info.Depends = value
				case "Section":
					info.Section = value
				case "Priority":
					info.Priority = value
				case "Homepage":
					info.Homepage = value
				}
			}
		}
	}

	return info, scanner.Err()
}

// modifyPackageMetadata ä¿®æ”¹åŒ…å…ƒæ•°æ®
func (dm *DebModifier) modifyPackageMetadata(info *PackageInfo) error {
	// ä¿®æ”¹åŒ…åï¼Œæ·»åŠ é­”æ”¹åç§°
	if !strings.Contains(info.Name, dm.MagicName) {
		info.Name = strings.Replace(info.Name, "frida", dm.MagicName, -1)
	}

	// æ›´æ–°controlæ–‡ä»¶
	controlFile := filepath.Join(dm.ExtractDir, "DEBIAN", "control")
	return dm.updateControlFile(controlFile, info)
}

// updateControlFile æ›´æ–°controlæ–‡ä»¶
func (dm *DebModifier) updateControlFile(controlFile string, info *PackageInfo) error {
	file, err := os.Open(controlFile)
	if err != nil {
		return err
	}
	defer file.Close()

	var lines []string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		if strings.Contains(line, ":") {
			parts := strings.SplitN(line, ":", 2)
			if len(parts) == 2 {
				key := strings.TrimSpace(parts[0])

				switch key {
				case "Package":
					line = fmt.Sprintf("Package: %s", info.Name)
				case "Version":
					// ä¿æŒåŸç‰ˆæœ¬æˆ–æ›´æ–°
					line = fmt.Sprintf("Version: %s", info.Version)
				case "Description":
					line = fmt.Sprintf("Description: %s (Modified with %s)", strings.TrimSpace(parts[1]), dm.MagicName)
				}
			}
		}
		lines = append(lines, line)
	}

	if err := scanner.Err(); err != nil {
		return err
	}

	// å†™å›æ–‡ä»¶
	return dm.writeLinesToFile(controlFile, lines)
}

// modifyBinaryFiles ä¿®æ”¹äºŒè¿›åˆ¶æ–‡ä»¶åå’Œå†…å®¹
func (dm *DebModifier) modifyBinaryFiles() error {
	log.Printf("INFO: å¼€å§‹ä¿®æ”¹äºŒè¿›åˆ¶æ–‡ä»¶åå’Œå†…å®¹")

	// éªŒè¯é­”æ”¹åç§° (å¿…é¡»ä¸º5ä¸ªå­—ç¬¦ï¼Œä¸”ç¬¦åˆå‘½åè§„åˆ™)
	if len(dm.MagicName) != 5 {
		return fmt.Errorf("é­”æ”¹åç§°å¿…é¡»æ˜¯5ä¸ªå­—ç¬¦ï¼Œå½“å‰: %s (%då­—ç¬¦)", dm.MagicName, len(dm.MagicName))
	}

	// éªŒè¯å­—ç¬¦è§„åˆ™ï¼šå¿…é¡»ä»¥å­—æ¯å¼€å¤´ï¼ŒåŒ…å«å­—æ¯å’Œæ•°å­—
	if !dm.isValidMagicName(dm.MagicName) {
		return fmt.Errorf("é­”æ”¹åç§°å¿…é¡»ä»¥å­—æ¯å¼€å¤´ï¼Œåªèƒ½åŒ…å«å­—æ¯å’Œæ•°å­—: %s", dm.MagicName)
	}

	// åˆ›å»ºHexReplacerå®ä¾‹
	hexReplacer := NewHexReplacer()

	// æŸ¥æ‰¾frida-serveræ–‡ä»¶
	var fridaServerPaths []string

	// ä¼ ç»Ÿè·¯å¾„
	traditionalPath := filepath.Join(dm.ExtractDir, "usr", "sbin", "frida-server")
	if _, err := os.Stat(traditionalPath); err == nil {
		fridaServerPaths = append(fridaServerPaths, traditionalPath)
		log.Printf("DEBUG: æ‰¾åˆ°ä¼ ç»Ÿfrida-serverè·¯å¾„: %s", traditionalPath)
	}

	// Rootlessè·¯å¾„ (ä½¿ç”¨ /var/re é¿å…æ•æ„Ÿè¯æ±‡)
	rootlessPath := filepath.Join(dm.ExtractDir, "var", "re", "usr", "sbin", "frida-server")
	if _, err := os.Stat(rootlessPath); err == nil {
		fridaServerPaths = append(fridaServerPaths, rootlessPath)
		log.Printf("DEBUG: æ‰¾åˆ°rootless frida-serverè·¯å¾„: %s", rootlessPath)
	}

	// å¯¹æ‰¾åˆ°çš„frida-serveræ–‡ä»¶æ‰§è¡Œhexæ›¿æ¢å’Œé‡å‘½å
	for _, oldPath := range fridaServerPaths {
		// 1. é¦–å…ˆè¿›è¡ŒäºŒè¿›åˆ¶å†…å®¹ä¿®æ”¹
		log.Printf("INFO: å¼€å§‹ä¿®æ”¹äºŒè¿›åˆ¶æ–‡ä»¶å†…å®¹: %s", oldPath)

		// è·å–åŸæ–‡ä»¶æƒé™
		stat, err := os.Stat(oldPath)
		if err != nil {
			return fmt.Errorf("è·å–æ–‡ä»¶æƒé™å¤±è´¥: %v", err)
		}
		originalMode := stat.Mode()

		// åˆ›å»ºæœ€ç»ˆç›®æ ‡æ–‡ä»¶è·¯å¾„
		dir := filepath.Dir(oldPath)
		newPath := filepath.Join(dir, dm.MagicName)

		// è¿›åº¦å›è°ƒå‡½æ•°
		progressCallback := func(progress float64, message string) {
			log.Printf("DEBUG: HEXæ›¿æ¢è¿›åº¦ %.1f%% - %s", progress*100, message)
		}

		// æ‰§è¡Œhexæ›¿æ¢ (ç›´æ¥è¾“å‡ºåˆ°æœ€ç»ˆæ–‡ä»¶å)
		err = hexReplacer.PatchFile(oldPath, dm.MagicName, newPath, progressCallback)
		if err != nil {
			log.Printf("ERROR: äºŒè¿›åˆ¶å†…å®¹ä¿®æ”¹å¤±è´¥: %s, é”™è¯¯: %v", oldPath, err)
			return fmt.Errorf("ä¿®æ”¹äºŒè¿›åˆ¶æ–‡ä»¶å†…å®¹å¤±è´¥ %s: %v", oldPath, err)
		}
		log.Printf("INFO: æˆåŠŸä¿®æ”¹äºŒè¿›åˆ¶æ–‡ä»¶å†…å®¹: %s", oldPath)

		// 2. åˆ é™¤åŸæ–‡ä»¶
		err = os.Remove(oldPath)
		if err != nil {
			log.Printf("WARNING: åˆ é™¤åŸæ–‡ä»¶å¤±è´¥: %s, é”™è¯¯: %v", oldPath, err)
			// ä¸è¦å› ä¸ºåˆ é™¤å¤±è´¥è€Œç»ˆæ­¢ï¼Œç»§ç»­æ‰§è¡Œ
		}

		// 3. è®¾ç½®æ–°æ–‡ä»¶æƒé™
		err = os.Chmod(newPath, originalMode)
		if err != nil {
			log.Printf("WARNING: è®¾ç½®æ–‡ä»¶æƒé™å¤±è´¥: %s, æƒé™: %o, é”™è¯¯: %v", newPath, originalMode, err)
		}

		log.Printf("INFO: æˆåŠŸä¿®æ”¹å’Œé‡å‘½åfrida-server: %s -> %s", oldPath, newPath)
	}

	// æŸ¥æ‰¾å¹¶é‡å‘½åfrida-agent.dylibæ–‡ä»¶
	return dm.renameAgentLibraries()
}

// renameWithPermissions ä¿æŒæƒé™çš„é‡å‘½åå‡½æ•°
func (dm *DebModifier) renameWithPermissions(oldPath, newPath string) error {
	// è·å–åŸæ–‡ä»¶æƒé™
	stat, err := os.Stat(oldPath)
	if err != nil {
		return fmt.Errorf("è·å–æ–‡ä»¶ä¿¡æ¯å¤±è´¥: %v", err)
	}

	originalMode := stat.Mode()
	log.Printf("DEBUG: ä¿æŒæ–‡ä»¶æƒé™é‡å‘½å: %s -> %s, æƒé™: %o", oldPath, newPath, originalMode.Perm())

	// æ‰§è¡Œé‡å‘½å
	err = os.Rename(oldPath, newPath)
	if err != nil {
		return err
	}

	// é‡æ–°è®¾ç½®æƒé™
	err = os.Chmod(newPath, originalMode)
	if err != nil {
		log.Printf("WARNING: è®¾ç½®æ–‡ä»¶æƒé™å¤±è´¥: %s, æƒé™: %o, é”™è¯¯: %v", newPath, originalMode, err)
		// æƒé™è®¾ç½®å¤±è´¥ä¸ç®—è‡´å‘½é”™è¯¯ï¼Œç»§ç»­æ‰§è¡Œ
	}

	return nil
}

// renameAgentLibraries é‡å‘½åagentåº“æ–‡ä»¶
func (dm *DebModifier) renameAgentLibraries() error {
	log.Printf("INFO: å¼€å§‹é‡å‘½åagentåº“æ–‡ä»¶")

	// ä¼ ç»Ÿè·¯å¾„
	traditionalDir := filepath.Join(dm.ExtractDir, "usr", "lib", "frida")
	if _, err := os.Stat(traditionalDir); err == nil {
		log.Printf("DEBUG: æ‰¾åˆ°ä¼ ç»Ÿåº“ç›®å½•: %s", traditionalDir)
		newDir := filepath.Join(dm.ExtractDir, "usr", "lib", dm.MagicName)

		err = dm.renameWithPermissions(traditionalDir, newDir)
		if err != nil {
			log.Printf("ERROR: é‡å‘½ååº“ç›®å½•å¤±è´¥: %s -> %s, é”™è¯¯: %v", traditionalDir, newDir, err)
			return fmt.Errorf("é‡å‘½ååº“ç›®å½•å¤±è´¥: %v", err)
		}
		log.Printf("INFO: æˆåŠŸé‡å‘½ååº“ç›®å½•: %s -> %s", traditionalDir, newDir)

		// é‡å‘½ådylibæ–‡ä»¶
		err = dm.renameLibraryFiles(newDir)
		if err != nil {
			return err
		}
	}

	// Rootlessè·¯å¾„ (ä½¿ç”¨ /var/re é¿å…æ•æ„Ÿè¯æ±‡)
	rootlessDir := filepath.Join(dm.ExtractDir, "var", "re", "usr", "lib", "frida")
	if _, err := os.Stat(rootlessDir); err == nil {
		log.Printf("DEBUG: æ‰¾åˆ°rootlessåº“ç›®å½•: %s", rootlessDir)
		newDir := filepath.Join(dm.ExtractDir, "var", "re", "usr", "lib", dm.MagicName)

		err = dm.renameWithPermissions(rootlessDir, newDir)
		if err != nil {
			log.Printf("ERROR: é‡å‘½årootlessåº“ç›®å½•å¤±è´¥: %s -> %s, é”™è¯¯: %v", rootlessDir, newDir, err)
			return fmt.Errorf("é‡å‘½årootlessåº“ç›®å½•å¤±è´¥: %v", err)
		}
		log.Printf("INFO: æˆåŠŸé‡å‘½årootlessåº“ç›®å½•: %s -> %s", rootlessDir, newDir)

		// é‡å‘½ådylibæ–‡ä»¶
		err = dm.renameLibraryFiles(newDir)
		if err != nil {
			return err
		}
	}

	return nil
}

// renameLibraryFiles é‡å‘½åå¹¶ä¿®æ”¹åº“æ–‡ä»¶å†…å®¹
func (dm *DebModifier) renameLibraryFiles(libDir string) error {
	log.Printf("DEBUG: å¼€å§‹é‡å‘½åå’Œä¿®æ”¹åº“ç›®å½•ä¸­çš„æ–‡ä»¶: %s", libDir)

	// åˆ›å»ºHexReplacerå®ä¾‹
	hexReplacer := NewHexReplacer()

	entries, err := os.ReadDir(libDir)
	if err != nil {
		log.Printf("ERROR: è¯»å–åº“ç›®å½•å¤±è´¥: %s, é”™è¯¯: %v", libDir, err)
		return err
	}

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}

		oldName := entry.Name()
		if strings.Contains(oldName, "frida-agent") {
			newName := strings.Replace(oldName, "frida-agent", dm.MagicName+"-agent", -1)
			oldPath := filepath.Join(libDir, oldName)
			newPath := filepath.Join(libDir, newName)

			// 1. é¦–å…ˆè¿›è¡ŒäºŒè¿›åˆ¶å†…å®¹ä¿®æ”¹
			log.Printf("INFO: å¼€å§‹ä¿®æ”¹agentåº“æ–‡ä»¶å†…å®¹: %s", oldPath)

			// è·å–åŸæ–‡ä»¶æƒé™
			stat, err := os.Stat(oldPath)
			if err != nil {
				return fmt.Errorf("è·å–agentæ–‡ä»¶æƒé™å¤±è´¥: %v", err)
			}
			originalMode := stat.Mode()

			// è¿›åº¦å›è°ƒå‡½æ•°
			progressCallback := func(progress float64, message string) {
				log.Printf("DEBUG: Agent HEXæ›¿æ¢è¿›åº¦ %.1f%% - %s", progress*100, message)
			}

			// æ‰§è¡Œhexæ›¿æ¢ (ç›´æ¥è¾“å‡ºåˆ°æœ€ç»ˆæ–‡ä»¶å)
			err = hexReplacer.PatchFile(oldPath, dm.MagicName, newPath, progressCallback)
			if err != nil {
				log.Printf("ERROR: agentæ–‡ä»¶å†…å®¹ä¿®æ”¹å¤±è´¥: %s, é”™è¯¯: %v", oldPath, err)
				return fmt.Errorf("ä¿®æ”¹agentæ–‡ä»¶å†…å®¹å¤±è´¥ %s: %v", oldPath, err)
			}
			log.Printf("INFO: æˆåŠŸä¿®æ”¹agentæ–‡ä»¶å†…å®¹: %s", oldPath)

			// 2. åˆ é™¤åŸæ–‡ä»¶
			err = os.Remove(oldPath)
			if err != nil {
				log.Printf("WARNING: åˆ é™¤åŸagentæ–‡ä»¶å¤±è´¥: %s, é”™è¯¯: %v", oldPath, err)
				// ä¸è¦å› ä¸ºåˆ é™¤å¤±è´¥è€Œç»ˆæ­¢ï¼Œç»§ç»­æ‰§è¡Œ
			}

			// 3. è®¾ç½®æ–°æ–‡ä»¶æƒé™
			err = os.Chmod(newPath, originalMode)
			if err != nil {
				log.Printf("WARNING: è®¾ç½®agentæ–‡ä»¶æƒé™å¤±è´¥: %s, æƒé™: %o, é”™è¯¯: %v", newPath, originalMode, err)
			}

			log.Printf("INFO: æˆåŠŸä¿®æ”¹å’Œé‡å‘½åagentæ–‡ä»¶: %s -> %s", oldName, newName)
		}
	}

	return nil
}

// modifyLaunchDaemon ä¿®æ”¹å¯åŠ¨å®ˆæŠ¤è¿›ç¨‹é…ç½®
func (dm *DebModifier) modifyLaunchDaemon() error {
	log.Printf("DEBUG: å¼€å§‹ä¿®æ”¹å¯åŠ¨å®ˆæŠ¤è¿›ç¨‹é…ç½®")

	// æŸ¥æ‰¾LaunchDaemonsç›®å½• (ä½¿ç”¨ /var/re é¿å…æ•æ„Ÿè¯æ±‡)
	launchDirs := []string{
		filepath.Join(dm.ExtractDir, "Library", "LaunchDaemons"),
		filepath.Join(dm.ExtractDir, "var", "re", "Library", "LaunchDaemons"),
	}

	for _, launchDir := range launchDirs {
		if _, err := os.Stat(launchDir); err != nil {
			log.Printf("DEBUG: LaunchDaemonsç›®å½•ä¸å­˜åœ¨: %s", launchDir)
			continue
		}

		log.Printf("DEBUG: å¤„ç†LaunchDaemonsç›®å½•: %s", launchDir)
		entries, err := os.ReadDir(launchDir)
		if err != nil {
			log.Printf("WARNING: è¯»å–LaunchDaemonsç›®å½•å¤±è´¥: %s, é”™è¯¯: %v", launchDir, err)
			continue
		}

		for _, entry := range entries {
			if entry.IsDir() {
				continue
			}

			filename := entry.Name()
			if strings.Contains(filename, "frida.server") || strings.Contains(filename, "re.frida.server") {
				oldPath := filepath.Join(launchDir, filename)

				// ç”Ÿæˆæ–°æ–‡ä»¶å
				newFilename := strings.Replace(filename, "frida", dm.MagicName, -1)
				newPath := filepath.Join(launchDir, newFilename)

				log.Printf("DEBUG: ä¿®æ”¹plistæ–‡ä»¶: %s -> %s", filename, newFilename)

				// ä¿®æ”¹plistå†…å®¹
				err = dm.modifyPlistContent(oldPath, newPath)
				if err != nil {
					log.Printf("ERROR: ä¿®æ”¹plistæ–‡ä»¶å¤±è´¥: %s, é”™è¯¯: %v", oldPath, err)
					return fmt.Errorf("ä¿®æ”¹plistæ–‡ä»¶å¤±è´¥: %v", err)
				}
				log.Printf("INFO: æˆåŠŸä¿®æ”¹plistæ–‡ä»¶: %s", newFilename)
			}
		}
	}

	return nil
}

// modifyPlistContent ä¿®æ”¹plistæ–‡ä»¶å†…å®¹
func (dm *DebModifier) modifyPlistContent(oldPath, newPath string) error {
	log.Printf("DEBUG: ä¿®æ”¹plistæ–‡ä»¶å†…å®¹: %s -> %s", oldPath, newPath)

	// è·å–åŸæ–‡ä»¶æƒé™
	oldInfo, err := os.Stat(oldPath)
	if err != nil {
		log.Printf("ERROR: è·å–plistæ–‡ä»¶ä¿¡æ¯å¤±è´¥: %s, é”™è¯¯: %v", oldPath, err)
		return err
	}

	log.Printf("DEBUG: åŸplistæ–‡ä»¶æƒé™: %s (%04o)", oldPath, oldInfo.Mode().Perm())

	// è¯»å–åŸæ–‡ä»¶
	content, err := os.ReadFile(oldPath)
	if err != nil {
		log.Printf("ERROR: è¯»å–plistæ–‡ä»¶å¤±è´¥: %s, é”™è¯¯: %v", oldPath, err)
		return err
	}

	// ä¿®æ”¹å†…å®¹
	modifiedContent := string(content)

	// æ›¿æ¢äºŒè¿›åˆ¶è·¯å¾„ (ä½¿ç”¨ /var/re é¿å…æ•æ„Ÿè¯æ±‡)
	modifiedContent = strings.ReplaceAll(modifiedContent, "/usr/sbin/frida-server", "/usr/sbin/"+dm.MagicName)
	modifiedContent = strings.ReplaceAll(modifiedContent, "/var/jb/usr/sbin/frida-server", "/var/re/usr/sbin/"+dm.MagicName)
	modifiedContent = strings.ReplaceAll(modifiedContent, "<string>/var/jb/", "<string>/var/re/")
	// æ›¿æ¢æ ‡ç­¾
	modifiedContent = strings.ReplaceAll(modifiedContent, "re.frida.server", "re."+dm.MagicName+".server")

	// æ›¿æ¢ç«¯å£ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
	portRegex := regexp.MustCompile(`<string>27042</string>`)
	modifiedContent = portRegex.ReplaceAllString(modifiedContent, fmt.Sprintf("<string>%d</string>", dm.Port))

	// æ·»åŠ ç«¯å£å¯åŠ¨å‚æ•° -l 0.0.0.0:ç«¯å£ åˆ° ProgramArguments
	// åªæœ‰å½“ç«¯å£ä¸æ˜¯é»˜è®¤ç«¯å£27042æ—¶æ‰æ·»åŠ 
	if dm.Port != 27042 {
		log.Printf("DEBUG: æ·»åŠ ç«¯å£å¯åŠ¨å‚æ•°: -l 0.0.0.0:%d", dm.Port)

		// æŸ¥æ‰¾ </array> æ ‡ç­¾ï¼Œåœ¨å…¶å‰é¢æ·»åŠ  -l å’Œç«¯å£å‚æ•°ï¼ˆç¡®ä¿æ— å¤šä½™ç©ºè¡Œï¼‰
		arrayCloseRegex := regexp.MustCompile(`(\s*)</array>`)
		modifiedContent = arrayCloseRegex.ReplaceAllString(modifiedContent,
			fmt.Sprintf("$1\t<string>-l</string>\n$1\t<string>0.0.0.0:%d</string>\n$1</array>", dm.Port))

		log.Printf("DEBUG: ç«¯å£å¯åŠ¨å‚æ•°æ·»åŠ å®Œæˆ")
	} else {
		log.Printf("DEBUG: ä½¿ç”¨é»˜è®¤ç«¯å£27042ï¼Œæ— éœ€æ·»åŠ å¯åŠ¨å‚æ•°")
	}

	// å†™å…¥æ–°æ–‡ä»¶ï¼ˆä¿æŒåŸæƒé™ï¼‰
	err = os.WriteFile(newPath, []byte(modifiedContent), oldInfo.Mode().Perm())
	if err != nil {
		log.Printf("ERROR: å†™å…¥æ–°plistæ–‡ä»¶å¤±è´¥: %s, é”™è¯¯: %v", newPath, err)
		return err
	}

	// éªŒè¯æ–°æ–‡ä»¶æƒé™
	newInfo, err := os.Stat(newPath)
	if err == nil {
		log.Printf("DEBUG: æ–°plistæ–‡ä»¶æƒé™: %s (%04o)", newPath, newInfo.Mode().Perm())
	}

	// åˆ é™¤æ—§æ–‡ä»¶
	if oldPath != newPath {
		err = os.Remove(oldPath)
		if err != nil {
			log.Printf("WARNING: åˆ é™¤æ—§plistæ–‡ä»¶å¤±è´¥: %s, é”™è¯¯: %v", oldPath, err)
		} else {
			log.Printf("DEBUG: åˆ é™¤æ—§plistæ–‡ä»¶: %s", oldPath)
		}
	}

	return nil
}

// modifyDebianScripts ä¿®æ”¹DEBIANç›®å½•ä¸­çš„è„šæœ¬
func (dm *DebModifier) modifyDebianScripts() error {
	debianDir := filepath.Join(dm.ExtractDir, "DEBIAN")

	// ä¿®æ”¹extrainst_æ–‡ä»¶
	extrainstFile := filepath.Join(debianDir, "extrainst_")
	if _, err := os.Stat(extrainstFile); err == nil {
		err = dm.modifyScriptFile(extrainstFile)
		if err != nil {
			return fmt.Errorf("ä¿®æ”¹extrainst_å¤±è´¥: %v", err)
		}
	}

	// ä¿®æ”¹prermæ–‡ä»¶
	prermFile := filepath.Join(debianDir, "prerm")
	if _, err := os.Stat(prermFile); err == nil {
		err = dm.modifyScriptFile(prermFile)
		if err != nil {
			return fmt.Errorf("ä¿®æ”¹prermå¤±è´¥: %v", err)
		}
	}

	return nil
}

// modifyScriptFile ä¿®æ”¹è„šæœ¬æ–‡ä»¶
func (dm *DebModifier) modifyScriptFile(scriptFile string) error {
	content, err := os.ReadFile(scriptFile)
	if err != nil {
		return err
	}

	modifiedContent := string(content)

	// æ›¿æ¢plistè·¯å¾„
	modifiedContent = strings.ReplaceAll(modifiedContent,
		"re.frida.server.plist",
		"re."+dm.MagicName+".server.plist")

	// æ›¿æ¢launchctlå‘½ä»¤ä¸­çš„plistè·¯å¾„ (ä½¿ç”¨ /var/re é¿å…æ•æ„Ÿè¯æ±‡)
	modifiedContent = strings.ReplaceAll(modifiedContent,
		"/Library/LaunchDaemons/re.frida.server.plist",
		"/Library/LaunchDaemons/re."+dm.MagicName+".server.plist")

	modifiedContent = strings.ReplaceAll(modifiedContent,
		"/var/jb/Library/LaunchDaemons/re.frida.server.plist",
		"/var/re/Library/LaunchDaemons/re."+dm.MagicName+".server.plist")

	return os.WriteFile(scriptFile, []byte(modifiedContent), 0755)
}

// repackageDebFile é‡æ–°æ‰“åŒ…DEBæ–‡ä»¶ï¼ˆçº¯Goå®ç°ï¼‰
func (dm *DebModifier) repackageDebFile() error {
	return dm.repackageWithGoAr()
}

// repackageWithGoAr ä½¿ç”¨çº¯Goæ–¹å¼é‡æ–°æ‰“åŒ…DEBæ–‡ä»¶
func (dm *DebModifier) repackageWithGoAr() error {
	log.Printf("INFO: å¼€å§‹é‡æ–°æ‰“åŒ…DEBæ–‡ä»¶: %s -> %s", dm.InputPath, dm.OutputPath)

	// åˆ›å»ºè¾“å‡ºæ–‡ä»¶
	outputFile, err := os.Create(dm.OutputPath)
	if err != nil {
		log.Printf("ERROR: åˆ›å»ºè¾“å‡ºæ–‡ä»¶å¤±è´¥: %v", err)
		return fmt.Errorf("åˆ›å»ºè¾“å‡ºæ–‡ä»¶å¤±è´¥: %v", err)
	}
	defer outputFile.Close()

	// å†™å…¥ARæ–‡ä»¶å¤´éƒ¨ "!<arch>\n"
	arHeaderWritten, err := outputFile.Write([]byte("!<arch>\n"))
	if err != nil {
		log.Printf("ERROR: å†™å…¥ARå¤´éƒ¨å¤±è´¥: %v", err)
		return fmt.Errorf("å†™å…¥ARå¤´éƒ¨å¤±è´¥: %v", err)
	}
	log.Printf("DEBUG: ARæ–‡ä»¶å¤´éƒ¨å†™å…¥å®Œæˆ: %d å­—èŠ‚", arHeaderWritten)

	// åˆ›å»ºARå†™å…¥å™¨
	arWriter := &arWriter{w: outputFile}

	// 1. å†™å…¥debian-binaryæ–‡ä»¶
	debianBinary := []byte("2.0\n")
	log.Printf("DEBUG: å‡†å¤‡å†™å…¥debian-binary: %d å­—èŠ‚", len(debianBinary))
	err = arWriter.writeFile("debian-binary", debianBinary)
	if err != nil {
		log.Printf("ERROR: å†™å…¥debian-binaryå¤±è´¥: %v", err)
		return fmt.Errorf("å†™å…¥debian-binaryå¤±è´¥: %v", err)
	}

	// 2. åˆ›å»ºå¹¶å†™å…¥control.tar.xz
	log.Printf("INFO: å¼€å§‹åˆ›å»ºcontrol.tar.xz")
	controlData, err := dm.createControlTarData()
	if err != nil {
		log.Printf("ERROR: åˆ›å»ºcontrol.taræ•°æ®å¤±è´¥: %v", err)
		return fmt.Errorf("åˆ›å»ºcontrol.taræ•°æ®å¤±è´¥: %v", err)
	}

	compressedControl, err := dm.compressWithXz(controlData)
	if err != nil {
		log.Printf("ERROR: å‹ç¼©control.tarå¤±è´¥: %v", err)
		return fmt.Errorf("å‹ç¼©control.tarå¤±è´¥: %v", err)
	}

	err = arWriter.writeFile("control.tar.xz", compressedControl)
	if err != nil {
		log.Printf("ERROR: å†™å…¥control.tar.xzå¤±è´¥: %v", err)
		return fmt.Errorf("å†™å…¥control.tar.xzå¤±è´¥: %v", err)
	}

	// 3. åˆ›å»ºå¹¶å†™å…¥data.tar.xz
	log.Printf("INFO: å¼€å§‹åˆ›å»ºdata.tar.xz")
	dataArchive, err := dm.createDataTarData()
	if err != nil {
		log.Printf("ERROR: åˆ›å»ºdata.taræ•°æ®å¤±è´¥: %v", err)
		return fmt.Errorf("åˆ›å»ºdata.taræ•°æ®å¤±è´¥: %v", err)
	}

	compressedData, err := dm.compressWithXz(dataArchive)
	if err != nil {
		log.Printf("ERROR: å‹ç¼©data.tarå¤±è´¥: %v", err)
		return fmt.Errorf("å‹ç¼©data.tarå¤±è´¥: %v", err)
	}

	err = arWriter.writeFile("data.tar.xz", compressedData)
	if err != nil {
		log.Printf("ERROR: å†™å…¥data.tar.xzå¤±è´¥: %v", err)
		return fmt.Errorf("å†™å…¥data.tar.xzå¤±è´¥: %v", err)
	}

	// è·å–è¾“å‡ºæ–‡ä»¶å¤§å°
	stat, err := outputFile.Stat()
	if err != nil {
		log.Printf("WARNING: è·å–è¾“å‡ºæ–‡ä»¶å¤§å°å¤±è´¥: %v", err)
	} else {
		log.Printf("INFO: DEBæ–‡ä»¶é‡æ–°æ‰“åŒ…å®Œæˆï¼Œæ€»å¤§å°: %d å­—èŠ‚", stat.Size())
	}

	log.Printf("SUCCESS: DEBæ–‡ä»¶é‡æ–°æ‰“åŒ…æˆåŠŸ: %s", dm.OutputPath)

	// å¯é€‰ï¼šéªŒè¯ç”Ÿæˆçš„DEBæ–‡ä»¶
	err = dm.validateGeneratedDeb()
	if err != nil {
		log.Printf("WARNING: DEBæ–‡ä»¶éªŒè¯å¤±è´¥: %v", err)
	}

	return nil
}

// validateGeneratedDeb éªŒè¯ç”Ÿæˆçš„DEBæ–‡ä»¶
func (dm *DebModifier) validateGeneratedDeb() error {
	log.Printf("INFO: å¼€å§‹éªŒè¯ç”Ÿæˆçš„DEBæ–‡ä»¶: %s", dm.OutputPath)

	// å°è¯•è§£æç”Ÿæˆçš„DEBæ–‡ä»¶
	file, err := os.Open(dm.OutputPath)
	if err != nil {
		return fmt.Errorf("æ‰“å¼€DEBæ–‡ä»¶å¤±è´¥: %v", err)
	}
	defer file.Close()

	// éªŒè¯ARæ–‡ä»¶å¤´éƒ¨
	header := make([]byte, 8)
	_, err = file.Read(header)
	if err != nil {
		return fmt.Errorf("è¯»å–ARå¤´éƒ¨å¤±è´¥: %v", err)
	}

	if string(header) != "!<arch>\n" {
		return fmt.Errorf("ARæ–‡ä»¶å¤´éƒ¨æ— æ•ˆ: %q", string(header))
	}
	log.Printf("DEBUG: ARæ–‡ä»¶å¤´éƒ¨éªŒè¯é€šè¿‡")

	entryCount := 0
	var dataSize int64

	// éªŒè¯ARæ¡ç›®
	for {
		entry, err := dm.readArEntry(file)
		if err == io.EOF {
			break
		}
		if err != nil {
			return fmt.Errorf("è¯»å–ARæ¡ç›®å¤±è´¥: %v", err)
		}

		entryCount++
		log.Printf("DEBUG: éªŒè¯ARæ¡ç›® %d: %s (%d å­—èŠ‚)", entryCount, entry.Name, entry.Size)

		if entry.Name == "data.tar.xz" {
			dataSize = entry.Size
			log.Printf("INFO: æ‰¾åˆ°data.tar.xzï¼Œå¤§å°: %d å­—èŠ‚", dataSize)

			// è¯»å–data.tar.xzå†…å®¹è¿›è¡ŒéªŒè¯
			dataContent := make([]byte, entry.Size)
			_, err = io.ReadFull(file, dataContent)
			if err != nil {
				return fmt.Errorf("è¯»å–data.tar.xzå†…å®¹å¤±è´¥: %v", err)
			}

			// éªŒè¯XZå‹ç¼©æ ¼å¼
			if len(dataContent) >= 6 {
				xzHeader := []byte{0xFD, '7', 'z', 'X', 'Z', 0x00}
				if bytes.Equal(dataContent[:6], xzHeader) {
					log.Printf("DEBUG: data.tar.xz XZæ ¼å¼éªŒè¯é€šè¿‡")
				} else {
					log.Printf("WARNING: data.tar.xz XZå¤´éƒ¨ä¸åŒ¹é…: %x", dataContent[:6])
				}
			}

			// å°è¯•è§£å‹éªŒè¯
			err = dm.validateTarXzContent(dataContent)
			if err != nil {
				return fmt.Errorf("data.tar.xzå†…å®¹éªŒè¯å¤±è´¥: %v", err)
			}
		} else {
			// è·³è¿‡å…¶ä»–æ¡ç›®
			_, err = file.Seek(entry.Size, 1)
			if err != nil {
				return fmt.Errorf("è·³è¿‡æ¡ç›®å¤±è´¥: %v", err)
			}
		}

		// ARå¯¹é½
		if entry.Size%2 == 1 {
			file.Seek(1, 1)
		}
	}

	log.Printf("INFO: DEBæ–‡ä»¶éªŒè¯å®Œæˆ - æ¡ç›®æ•°: %d, data.tar.xzå¤§å°: %d å­—èŠ‚", entryCount, dataSize)
	return nil
}

// validateTarXzContent éªŒè¯tar.xzå†…å®¹
func (dm *DebModifier) validateTarXzContent(data []byte) error {
	log.Printf("DEBUG: å¼€å§‹éªŒè¯tar.xzå†…å®¹ï¼Œå¤§å°: %d å­—èŠ‚", len(data))

	reader := bytes.NewReader(data)

	// è§£å‹XZ
	xzReader, err := xz.NewReader(reader)
	if err != nil {
		return fmt.Errorf("åˆ›å»ºXZè¯»å–å™¨å¤±è´¥: %v", err)
	}

	// è¯»å–TARå†…å®¹
	tarReader := tar.NewReader(xzReader)

	var fileCount, dirCount int
	var totalSize int64

	for {
		header, err := tarReader.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return fmt.Errorf("è¯»å–tarå¤´å¤±è´¥: %v", err)
		}

		if header.Typeflag == tar.TypeDir {
			dirCount++
		} else if header.Typeflag == tar.TypeReg {
			fileCount++
			totalSize += header.Size
		}

		log.Printf("DEBUG: TARæ¡ç›®: %s, ç±»å‹: %d, å¤§å°: %d", header.Name, header.Typeflag, header.Size)
	}

	log.Printf("INFO: TARå†…å®¹éªŒè¯å®Œæˆ - ç›®å½•æ•°: %d, æ–‡ä»¶æ•°: %d, æ€»å¤§å°: %d å­—èŠ‚", dirCount, fileCount, totalSize)
	return nil
} // arWriter ARæ ¼å¼å†™å…¥å™¨
type arWriter struct {
	w io.Writer
}

// writeFile å†™å…¥ARæ–‡ä»¶æ¡ç›®
func (aw *arWriter) writeFile(name string, data []byte) error {
	log.Printf("DEBUG: å†™å…¥ARæ–‡ä»¶æ¡ç›®: %s, å¤§å°: %d å­—èŠ‚", name, len(data))

	// ARæ–‡ä»¶å¤´æ ¼å¼: åç§°(16å­—èŠ‚) + ä¿®æ”¹æ—¶é—´(12å­—èŠ‚) + ç”¨æˆ·ID(6å­—èŠ‚) + ç»„ID(6å­—èŠ‚) + æ–‡ä»¶æ¨¡å¼(8å­—èŠ‚) + æ–‡ä»¶å¤§å°(10å­—èŠ‚) + ç»“æŸæ ‡è®°(2å­—èŠ‚)
	header := make([]byte, 60)

	// æ–‡ä»¶åï¼ˆæœ€å¤š16å­—ç¬¦ï¼Œä¸è¶³çš„ç”¨ç©ºæ ¼å¡«å……ï¼‰
	copy(header[0:16], []byte(fmt.Sprintf("%-16s", name)))

	// ä¿®æ”¹æ—¶é—´ï¼ˆUnixæ—¶é—´æˆ³ï¼‰
	copy(header[16:28], []byte(fmt.Sprintf("%-12d", 0)))

	// ç”¨æˆ·ID
	copy(header[28:34], []byte("0     "))

	// ç»„ID
	copy(header[34:40], []byte("0     "))

	// æ–‡ä»¶æ¨¡å¼
	copy(header[40:48], []byte("100644  "))

	// æ–‡ä»¶å¤§å°
	copy(header[48:58], []byte(fmt.Sprintf("%-10d", len(data))))

	// ç»“æŸæ ‡è®°
	copy(header[58:60], []byte("`\n"))

	// å†™å…¥å¤´éƒ¨
	headerWritten, err := aw.w.Write(header)
	if err != nil {
		log.Printf("ERROR: å†™å…¥ARå¤´éƒ¨å¤±è´¥: %s, é”™è¯¯: %v", name, err)
		return err
	}

	if headerWritten != 60 {
		log.Printf("WARNING: ARå¤´éƒ¨å†™å…¥å­—èŠ‚æ•°ä¸åŒ¹é…: %s, æœŸæœ›: 60, å®é™…: %d", name, headerWritten)
	}

	// å†™å…¥æ•°æ®
	dataWritten, err := aw.w.Write(data)
	if err != nil {
		log.Printf("ERROR: å†™å…¥ARæ•°æ®å¤±è´¥: %s, é”™è¯¯: %v", name, err)
		return err
	}

	if dataWritten != len(data) {
		log.Printf("WARNING: ARæ•°æ®å†™å…¥å­—èŠ‚æ•°ä¸åŒ¹é…: %s, æœŸæœ›: %d, å®é™…: %d", name, len(data), dataWritten)
	}

	// ARæ–‡ä»¶è¦æ±‚æ¯ä¸ªæ¡ç›®éƒ½æ˜¯å¶æ•°å­—èŠ‚å¯¹é½
	if len(data)%2 == 1 {
		padWritten, err := aw.w.Write([]byte{'\n'})
		if err != nil {
			log.Printf("ERROR: å†™å…¥ARå¯¹é½å¡«å……å¤±è´¥: %s, é”™è¯¯: %v", name, err)
			return err
		}
		log.Printf("DEBUG: ARæ–‡ä»¶ %s æ·»åŠ å¯¹é½å¡«å……: %d å­—èŠ‚", name, padWritten)
	}

	log.Printf("INFO: ARæ¡ç›®å†™å…¥å®Œæˆ: %s, å¤´éƒ¨: %d å­—èŠ‚, æ•°æ®: %d å­—èŠ‚", name, headerWritten, dataWritten)
	return nil
}

// createControlTarData åˆ›å»ºcontrol.taræ•°æ®
func (dm *DebModifier) createControlTarData() ([]byte, error) {
	debianDir := filepath.Join(dm.ExtractDir, "DEBIAN")
	log.Printf("DEBUG: å¼€å§‹åˆ›å»ºcontrol.taræ•°æ®ï¼ŒDEBIANç›®å½•: %s", debianDir)

	var buf bytes.Buffer
	tarWriter := tar.NewWriter(&buf)
	defer tarWriter.Close()

	var fileCount, dirCount int
	var totalSize int64

	err := filepath.Walk(debianDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			log.Printf("ERROR: éå†DEBIANç›®å½•å¤±è´¥: %s, é”™è¯¯: %v", path, err)
			return err
		}

		// è·³è¿‡ç›®å½•æœ¬èº«
		if path == debianDir {
			log.Printf("DEBUG: è·³è¿‡DEBIANæ ¹ç›®å½•: %s", path)
			return nil
		}

		// è·å–ç›¸å¯¹è·¯å¾„
		relPath, err := filepath.Rel(debianDir, path)
		if err != nil {
			log.Printf("ERROR: è®¡ç®—DEBIANç›¸å¯¹è·¯å¾„å¤±è´¥: %s, é”™è¯¯: %v", path, err)
			return err
		}

		// ä½¿ç”¨Unixè·¯å¾„åˆ†éš”ç¬¦
		originalRelPath := relPath
		relPath = strings.ReplaceAll(relPath, "\\", "/")
		if originalRelPath != relPath {
			log.Printf("DEBUG: DEBIANè·¯å¾„åˆ†éš”ç¬¦è½¬æ¢: %s -> %s", originalRelPath, relPath)
		}

		if info.IsDir() {
			dirCount++
			log.Printf("DEBUG: æ·»åŠ DEBIANç›®å½•: %s/, æƒé™: %o", relPath, info.Mode().Perm())
			header := &tar.Header{
				Name:     relPath + "/",
				Mode:     int64(info.Mode().Perm()),
				Typeflag: tar.TypeDir,
				ModTime:  info.ModTime(),
				Format:   tar.FormatGNU, // ä½¿ç”¨GNUæ ¼å¼åŒ¹é…åŸå§‹æ–‡ä»¶
			}
			err := tarWriter.WriteHeader(header)
			if err != nil {
				log.Printf("ERROR: å†™å…¥DEBIANç›®å½•å¤´éƒ¨å¤±è´¥: %s, é”™è¯¯: %v", relPath, err)
			}
			return err
		} else {
			fileCount++
			totalSize += info.Size()

			// æ ¹æ®æ–‡ä»¶ç±»å‹è®¾ç½®æ­£ç¡®çš„æƒé™ï¼ˆç¬¦åˆDEBåŒ…è§„èŒƒï¼‰
			var perm os.FileMode
			switch relPath {
			case "control":
				perm = 0644 // controlæ–‡ä»¶æ ‡å‡†æƒé™
			case "postinst", "prerm", "postrm", "preinst":
				perm = 0755 // è„šæœ¬æ–‡ä»¶éœ€è¦å¯æ‰§è¡Œæƒé™
			case "extrainst_":
				perm = 0755 // extrainst_æ–‡ä»¶éœ€è¦å¯æ‰§è¡Œæƒé™
			default:
				perm = 0644 // å…¶ä»–æ–‡ä»¶é»˜è®¤æƒé™
			}

			log.Printf("DEBUG: æ·»åŠ DEBIANæ–‡ä»¶: %s, å¤§å°: %d å­—èŠ‚, æƒé™: %o", relPath, info.Size(), perm)

			file, err := os.Open(path)
			if err != nil {
				log.Printf("ERROR: æ‰“å¼€DEBIANæ–‡ä»¶å¤±è´¥: %s, é”™è¯¯: %v", path, err)
				return err
			}
			defer file.Close()

			header := &tar.Header{
				Name:     relPath,
				Mode:     int64(perm),
				Size:     info.Size(),
				Typeflag: tar.TypeReg,
				ModTime:  info.ModTime(),
				Uid:      0, // root
				Gid:      0, // root
				Uname:    "root",
				Gname:    "root",
				Format:   tar.FormatGNU, // ä½¿ç”¨GNUæ ¼å¼åŒ¹é…åŸå§‹æ–‡ä»¶
			}

			err = tarWriter.WriteHeader(header)
			if err != nil {
				log.Printf("ERROR: å†™å…¥DEBIANæ–‡ä»¶å¤´éƒ¨å¤±è´¥: %s, é”™è¯¯: %v", relPath, err)
				return err
			}

			written, err := io.Copy(tarWriter, file)
			if err != nil {
				log.Printf("ERROR: å¤åˆ¶DEBIANæ–‡ä»¶å†…å®¹å¤±è´¥: %s, é”™è¯¯: %v", relPath, err)
				return err
			}

			if written != info.Size() {
				log.Printf("WARNING: DEBIANæ–‡ä»¶å¤§å°ä¸åŒ¹é…: %s, æœŸæœ›: %d, å®é™…å†™å…¥: %d", relPath, info.Size(), written)
			}

			return nil
		}
	})

	if err != nil {
		log.Printf("ERROR: éå†DEBIANç›®å½•å¤±è´¥: %v", err)
		return nil, err
	}

	err = tarWriter.Close()
	if err != nil {
		log.Printf("ERROR: å…³é—­control.tarå†™å…¥å™¨å¤±è´¥: %v", err)
		return nil, err
	}

	tarData := buf.Bytes()
	log.Printf("INFO: control.taråˆ›å»ºå®Œæˆ - ç›®å½•æ•°: %d, æ–‡ä»¶æ•°: %d, æ€»æ–‡ä»¶å¤§å°: %d å­—èŠ‚, taræ•°æ®å¤§å°: %d å­—èŠ‚",
		dirCount, fileCount, totalSize, len(tarData))

	return tarData, nil
}

// createDataTarData åˆ›å»ºdata.taræ•°æ®
func (dm *DebModifier) createDataTarData() ([]byte, error) {
	log.Printf("DEBUG: å¼€å§‹åˆ›å»ºdata.taræ•°æ®ï¼Œæå–ç›®å½•: %s", dm.ExtractDir)

	var buf bytes.Buffer
	tarWriter := tar.NewWriter(&buf)
	defer tarWriter.Close()

	var fileCount, dirCount int
	var totalSize int64

	// æ£€æµ‹æ˜¯å¦ä¸ºrootlessç»“æ„
	isRootless := false
	if _, err := os.Stat(filepath.Join(dm.ExtractDir, "var", "re")); err == nil {
		isRootless = true
		log.Printf("DEBUG: æ£€æµ‹åˆ°rootlessç»“æ„")
	}

	// æ‰€æœ‰ç»“æ„éƒ½éœ€è¦æ·»åŠ æ ¹ç›®å½• "." æ¡ç›®ï¼Œrootlessä¹Ÿæ˜¯ä»./varå¼€å§‹
	log.Printf("DEBUG: æ·»åŠ TARæ ¹ç›®å½•æ¡ç›® './'")
	rootHeader := &tar.Header{
		Name:     "./",
		Mode:     int64(0755), // drwxr-xr-x
		Typeflag: tar.TypeDir,
		ModTime:  time.Now(),
		Uid:      0, // root
		Gid:      0, // root
		Uname:    "root",
		Gname:    "root",
		Format:   tar.FormatGNU, // ä½¿ç”¨GNUæ ¼å¼åŒ¹é…åŸå§‹æ–‡ä»¶
	}
	err := tarWriter.WriteHeader(rootHeader)
	if err != nil {
		log.Printf("ERROR: å†™å…¥æ ¹ç›®å½•å¤´éƒ¨å¤±è´¥: %v", err)
		return nil, err
	}
	dirCount++

	err = filepath.Walk(dm.ExtractDir, func(path string, info os.FileInfo, walkErr error) error {
		if walkErr != nil {
			log.Printf("ERROR: éå†è·¯å¾„ %s æ—¶å‡ºé”™: %v", path, walkErr)
			return walkErr
		}

		// è·³è¿‡æ ¹ç›®å½•å’ŒDEBIANç›®å½•
		if path == dm.ExtractDir {
			log.Printf("DEBUG: è·³è¿‡æ ¹ç›®å½•: %s", path)
			return nil
		}

		relPath, err := filepath.Rel(dm.ExtractDir, path)
		if err != nil {
			log.Printf("ERROR: è®¡ç®—ç›¸å¯¹è·¯å¾„å¤±è´¥ï¼Œè·¯å¾„: %s, é”™è¯¯: %v", path, err)
			return err
		}

		// è·³è¿‡DEBIANç›®å½•
		if strings.HasPrefix(relPath, "DEBIAN") {
			log.Printf("DEBUG: è·³è¿‡DEBIANç›®å½•: %s", relPath)
			if info.IsDir() {
				return filepath.SkipDir
			}
			return nil
		}

		// ä½¿ç”¨Unixè·¯å¾„åˆ†éš”ç¬¦
		originalRelPath := relPath
		relPath = strings.ReplaceAll(relPath, "\\", "/")
		if originalRelPath != relPath {
			log.Printf("DEBUG: è·¯å¾„åˆ†éš”ç¬¦è½¬æ¢: %s -> %s", originalRelPath, relPath)
		}

		// æ ¹æ®è·¯å¾„ç±»å‹å†³å®šTARè·¯å¾„æ ¼å¼
		var tarPath string
		if isRootless && strings.HasPrefix(relPath, "var") {
			// rootlessç»“æ„ä¸­çš„varè·¯å¾„ä½¿ç”¨"./"å‰ç¼€: ./var/re/...
			tarPath = "./" + relPath
			log.Printf("DEBUG: TARè·¯å¾„å¤„ç†(rootless): %s -> %s", relPath, tarPath)
		} else if !isRootless {
			// ä¼ ç»Ÿç»“æ„æ·»åŠ "./"å‰ç¼€
			tarPath = "./" + relPath
			log.Printf("DEBUG: TARè·¯å¾„å¤„ç†(ä¼ ç»Ÿ): %s -> %s", relPath, tarPath)
		} else {
			// rootlessç»“æ„ä¸­çš„å…¶ä»–è·¯å¾„ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
			tarPath = "./" + relPath
			log.Printf("DEBUG: TARè·¯å¾„å¤„ç†(å…¶ä»–): %s -> %s", relPath, tarPath)
		}

		if info.IsDir() {
			dirCount++
			// ç›®å½•åº”è¯¥ä½¿ç”¨755æƒé™ (drwxr-xr-x)
			dirMode := os.FileMode(0755)
			log.Printf("DEBUG: æ·»åŠ ç›®å½•: %s/, æƒé™: %04o (ä¿®æ­£ä¸º755)", tarPath, dirMode)
			header := &tar.Header{
				Name:     tarPath + "/",
				Mode:     int64(dirMode),
				Typeflag: tar.TypeDir,
				ModTime:  info.ModTime(),
				Uid:      0, // root
				Gid:      0, // root
				Uname:    "root",
				Gname:    "root",
				Format:   tar.FormatGNU, // ä½¿ç”¨GNUæ ¼å¼åŒ¹é…åŸå§‹æ–‡ä»¶
			}
			err := tarWriter.WriteHeader(header)
			if err != nil {
				log.Printf("ERROR: å†™å…¥ç›®å½•å¤´éƒ¨å¤±è´¥: %s, é”™è¯¯: %v", relPath, err)
			}
			return err
		} else {
			fileCount++
			totalSize += info.Size()

			// æ ¹æ®æ–‡ä»¶ç±»å‹è®¾ç½®æ­£ç¡®çš„æƒé™
			var perm os.FileMode
			switch {
			case strings.HasSuffix(tarPath, "/frida-server") || strings.HasSuffix(tarPath, "/"+dm.MagicName):
				// frida-server å’Œé‡å‘½ååçš„æœåŠ¡å™¨éœ€è¦å¯æ‰§è¡Œæƒé™
				perm = 0755
				log.Printf("DEBUG: è®¾ç½®æœåŠ¡å™¨å¯æ‰§è¡Œæƒé™: %s -> 755", tarPath)
			case strings.Contains(tarPath, "frida-agent") || strings.Contains(tarPath, dm.MagicName+"-agent"):
				// agent åº“æ–‡ä»¶éœ€è¦å¯æ‰§è¡Œæƒé™
				perm = 0755
				log.Printf("DEBUG: è®¾ç½®agentå¯æ‰§è¡Œæƒé™: %s -> 755", tarPath)
			case strings.HasSuffix(tarPath, ".plist"):
				// plist æ–‡ä»¶ä½¿ç”¨æ ‡å‡†æƒé™
				perm = 0644
				log.Printf("DEBUG: è®¾ç½®plistæƒé™: %s -> 644", tarPath)
			default:
				// å…¶ä»–æ–‡ä»¶ä¿æŒå½“å‰æƒé™
				perm = info.Mode().Perm()
				log.Printf("DEBUG: ä¿æŒåŸæƒé™: %s -> %04o", tarPath, perm)
			}

			log.Printf("DEBUG: æ·»åŠ æ–‡ä»¶: %s, å¤§å°: %d å­—èŠ‚, æƒé™: %04o", tarPath, info.Size(), perm)

			file, err := os.Open(path)
			if err != nil {
				log.Printf("ERROR: æ‰“å¼€æ–‡ä»¶å¤±è´¥: %s, é”™è¯¯: %v", path, err)
				return err
			}
			defer file.Close()

			header := &tar.Header{
				Name:     tarPath,
				Mode:     int64(perm),
				Size:     info.Size(),
				Typeflag: tar.TypeReg,
				ModTime:  info.ModTime(),
				Uid:      0, // root
				Gid:      0, // root
				Uname:    "root",
				Gname:    "root",
				Format:   tar.FormatGNU, // ä½¿ç”¨GNUæ ¼å¼åŒ¹é…åŸå§‹æ–‡ä»¶
			}

			err = tarWriter.WriteHeader(header)
			if err != nil {
				log.Printf("ERROR: å†™å…¥æ–‡ä»¶å¤´éƒ¨å¤±è´¥: %s, é”™è¯¯: %v", relPath, err)
				return err
			}

			written, err := io.Copy(tarWriter, file)
			if err != nil {
				log.Printf("ERROR: å¤åˆ¶æ–‡ä»¶å†…å®¹å¤±è´¥: %s, é”™è¯¯: %v", relPath, err)
				return err
			}

			if written != info.Size() {
				log.Printf("WARNING: æ–‡ä»¶å¤§å°ä¸åŒ¹é…: %s, æœŸæœ›: %d, å®é™…å†™å…¥: %d", relPath, info.Size(), written)
			}

			return nil
		}
	})

	if err != nil {
		log.Printf("ERROR: éå†ç›®å½•å¤±è´¥: %v", err)
		return nil, err
	}

	err = tarWriter.Close()
	if err != nil {
		log.Printf("ERROR: å…³é—­tarå†™å…¥å™¨å¤±è´¥: %v", err)
		return nil, err
	}

	tarData := buf.Bytes()
	log.Printf("INFO: data.taråˆ›å»ºå®Œæˆ - ç›®å½•æ•°: %d, æ–‡ä»¶æ•°: %d, æ€»æ–‡ä»¶å¤§å°: %d å­—èŠ‚, taræ•°æ®å¤§å°: %d å­—èŠ‚",
		dirCount, fileCount, totalSize, len(tarData))

	return tarData, nil
}

// compressWithXz ä½¿ç”¨XZå‹ç¼©æ•°æ®
func (dm *DebModifier) compressWithXz(data []byte) ([]byte, error) {
	log.Printf("DEBUG: å¼€å§‹XZå‹ç¼©ï¼ŒåŸå§‹æ•°æ®å¤§å°: %d å­—èŠ‚", len(data))

	var buf bytes.Buffer

	// åˆ›å»ºä¸åŸå§‹DEBæ–‡ä»¶åŒ¹é…çš„XZé…ç½®
	// ç®—æ³•: LZMA2:23 CRC64, æ•°æ®æµ1, å­—å—3, ç°‡å¤§å°25165824
	config := xz.WriterConfig{
		DictCap:   16 << 20, // 16MBå­—å…¸ï¼ŒåŒ¹é…LZMA2:23çº§åˆ«
		BlockSize: 25165824, // 25MBå—å¤§å°ï¼ŒåŒ¹é…åŸå§‹ç°‡å¤§å°
		CheckSum:  xz.CRC64, // ä½¿ç”¨CRC64åŒ¹é…åŸå§‹ç®—æ³•
	}

	writer, err := config.NewWriter(&buf)
	if err != nil {
		log.Printf("ERROR: åˆ›å»ºXZå†™å…¥å™¨å¤±è´¥: %v", err)
		return nil, err
	}

	written, err := writer.Write(data)
	if err != nil {
		writer.Close()
		log.Printf("ERROR: XZå‹ç¼©å†™å…¥å¤±è´¥: %v", err)
		return nil, err
	}

	if written != len(data) {
		log.Printf("WARNING: XZå‹ç¼©å†™å…¥å­—èŠ‚æ•°ä¸åŒ¹é…ï¼ŒæœŸæœ›: %d, å®é™…: %d", len(data), written)
	}

	err = writer.Close()
	if err != nil {
		log.Printf("ERROR: å…³é—­XZå†™å…¥å™¨å¤±è´¥: %v", err)
		return nil, err
	}

	compressed := buf.Bytes()
	compressionRatio := float64(len(compressed)) / float64(len(data)) * 100
	log.Printf("INFO: XZå‹ç¼©å®Œæˆ - åŸå§‹: %d å­—èŠ‚, å‹ç¼©å: %d å­—èŠ‚, å‹ç¼©ç‡: %.2f%%",
		len(data), len(compressed), compressionRatio)

	return compressed, nil
} // writeLinesToFile å†™å…¥è¡Œåˆ°æ–‡ä»¶
func (dm *DebModifier) writeLinesToFile(filename string, lines []string) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := bufio.NewWriter(file)
	for _, line := range lines {
		_, err := writer.WriteString(line + "\n")
		if err != nil {
			return err
		}
	}

	return writer.Flush()
}

// isValidMagicName éªŒè¯é­”æ”¹åç§°æ ¼å¼
func (dm *DebModifier) isValidMagicName(s string) bool {
	// å¿…é¡»ä»¥å­—æ¯å¼€å¤´
	if len(s) == 0 {
		return false
	}

	first := s[0]
	if !((first >= 'A' && first <= 'Z') || (first >= 'a' && first <= 'z')) {
		return false
	}

	// æ£€æŸ¥å…¶ä½™å­—ç¬¦å¿…é¡»æ˜¯å­—æ¯æˆ–æ•°å­—
	for _, c := range s {
		if !((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')) {
			return false
		}
	}

	return true
}

// CreateFridaDeb åˆ›å»ºæ–°çš„Frida DEBåŒ…
type CreateFridaDeb struct {
	FridaServerPath string       // frida-server æ–‡ä»¶è·¯å¾„
	FridaAgentPath  string       // frida-agent.dylib æ–‡ä»¶è·¯å¾„ (å¯é€‰)
	OutputPath      string       // è¾“å‡ºDEBæ–‡ä»¶è·¯å¾„
	PackageInfo     *PackageInfo // åŒ…ä¿¡æ¯
	TempDir         string       // ä¸´æ—¶ç›®å½•
}

// NewCreateFridaDeb åˆ›å»ºæ–°çš„Frida DEBæ„å»ºå™¨
func NewCreateFridaDeb(fridaServerPath, outputPath string, info *PackageInfo) *CreateFridaDeb {
	return &CreateFridaDeb{
		FridaServerPath: fridaServerPath,
		OutputPath:      outputPath,
		PackageInfo:     info,
	}
}

// CreateDebPackage åˆ›å»ºæ–°çš„DEBåŒ…
func (cfd *CreateFridaDeb) CreateDebPackage() error {
	log.Printf("INFO: å¼€å§‹åˆ›å»ºæ–°çš„Frida DEBåŒ…")
	log.Printf("INFO: è¾“å…¥æ–‡ä»¶: %s", cfd.FridaServerPath)
	log.Printf("INFO: è¾“å‡ºæ–‡ä»¶: %s", cfd.OutputPath)
	log.Printf("INFO: åŒ…å: %s, ç‰ˆæœ¬: %s, æ¶æ„: %s",
		cfd.PackageInfo.Name, cfd.PackageInfo.Version, cfd.PackageInfo.Architecture)
	log.Printf("INFO: é­”æ”¹åç§°: %s, ç«¯å£: %d",
		cfd.PackageInfo.MagicName, cfd.PackageInfo.Port)
	log.Printf("INFO: ç»“æ„ç±»å‹: %s",
		map[bool]string{true: "Rootless", false: "Root"}[cfd.PackageInfo.IsRootless])

	// 1. åˆ›å»ºä¸´æ—¶ç›®å½•
	tempDir, err := os.MkdirTemp("", "fridare-create-*")
	if err != nil {
		return fmt.Errorf("åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥: %v", err)
	}
	cfd.TempDir = tempDir
	defer os.RemoveAll(tempDir)

	log.Printf("DEBUG: ä¸´æ—¶ç›®å½•: %s", tempDir)

	// 2. åˆ›å»ºåŒ…ç›®å½•ç»“æ„
	err = cfd.createPackageStructure()
	if err != nil {
		return fmt.Errorf("åˆ›å»ºåŒ…ç»“æ„å¤±è´¥: %v", err)
	}

	// 3. å¤åˆ¶å¹¶ä¿®æ”¹frida-serveræ–‡ä»¶
	err = cfd.copyAndPatchFridaServer()
	if err != nil {
		return fmt.Errorf("å¤åˆ¶å’Œä¿®æ”¹frida-serverå¤±è´¥: %v", err)
	}

	// 4. å¤åˆ¶å¹¶ä¿®æ”¹frida-agentæ–‡ä»¶ï¼ˆå¦‚æœæä¾›ï¼‰
	if cfd.FridaAgentPath != "" {
		err = cfd.copyAndPatchFridaAgent()
		if err != nil {
			return fmt.Errorf("å¤åˆ¶å’Œä¿®æ”¹frida-agentå¤±è´¥: %v", err)
		}
	} else {
		// æ£€æŸ¥æ˜¯å¦ä¸ºå®Œæ•´çš„fridaåŒ…åˆ›å»ºï¼Œå¦‚æœæ˜¯åˆ™æç¤ºéœ€è¦agentæ–‡ä»¶
		log.Printf("WARNING: æœªæä¾›frida-agent.dylibæ–‡ä»¶ï¼Œåˆ›å»ºçš„DEBåŒ…å°†åªåŒ…å«frida-server")
		log.Printf("INFO: å¦‚éœ€å®Œæ•´åŠŸèƒ½ï¼Œè¯·ä½¿ç”¨ -agent å‚æ•°æŒ‡å®šfrida-agent.dylibæ–‡ä»¶")
	}

	// 5. åˆ›å»ºLaunchDaemoné…ç½®
	err = cfd.createLaunchDaemonConfig()
	if err != nil {
		return fmt.Errorf("åˆ›å»ºå¯åŠ¨å®ˆæŠ¤ç¨‹åºé…ç½®å¤±è´¥: %v", err)
	}

	// 6. åˆ›å»ºæ§åˆ¶æ–‡ä»¶
	err = cfd.createControlFiles()
	if err != nil {
		return fmt.Errorf("åˆ›å»ºæ§åˆ¶æ–‡ä»¶å¤±è´¥: %v", err)
	}

	// 7. æ„å»ºDEBåŒ…
	err = cfd.buildDebPackage()
	if err != nil {
		return fmt.Errorf("æ„å»ºDEBåŒ…å¤±è´¥: %v", err)
	}

	log.Printf("SUCCESS: Frida DEBåŒ…åˆ›å»ºæˆåŠŸ: %s", cfd.OutputPath)
	return nil
}

// createPackageStructure åˆ›å»ºåŒ…ç›®å½•ç»“æ„
func (cfd *CreateFridaDeb) createPackageStructure() error {
	log.Printf("INFO: åˆ›å»ºåŒ…ç›®å½•ç»“æ„")

	var dirs []string

	if cfd.PackageInfo.IsRootless {
		// Rootlessç»“æ„
		dirs = []string{
			"DEBIAN",
			"var/re/usr/sbin",
			"var/re/usr/lib/" + cfd.PackageInfo.MagicName,
			"var/re/Library/LaunchDaemons",
		}
	} else {
		// Rootç»“æ„
		dirs = []string{
			"DEBIAN",
			"usr/sbin",
			"usr/lib/" + cfd.PackageInfo.MagicName,
			"Library/LaunchDaemons",
		}
	}

	for _, dir := range dirs {
		fullPath := filepath.Join(cfd.TempDir, dir)
		err := os.MkdirAll(fullPath, 0755)
		if err != nil {
			return fmt.Errorf("åˆ›å»ºç›®å½•å¤±è´¥ %s: %v", dir, err)
		}
		log.Printf("DEBUG: åˆ›å»ºç›®å½•: %s", dir)
	}

	return nil
}

// copyAndPatchFridaServer å¤åˆ¶å¹¶ä¿®æ”¹frida-serveræ–‡ä»¶
func (cfd *CreateFridaDeb) copyAndPatchFridaServer() error {
	log.Printf("INFO: å¼€å§‹å¤åˆ¶å’Œä¿®æ”¹frida-serveræ–‡ä»¶")

	// ç›®æ ‡è·¯å¾„
	var targetPath string
	if cfd.PackageInfo.IsRootless {
		targetPath = filepath.Join(cfd.TempDir, "var/re/usr/sbin", cfd.PackageInfo.MagicName)
	} else {
		targetPath = filepath.Join(cfd.TempDir, "usr/sbin", cfd.PackageInfo.MagicName)
	}

	// å¦‚æœéœ€è¦patchï¼Œä½¿ç”¨HexReplacer
	if cfd.PackageInfo.MagicName != "frida-server" {
		log.Printf("INFO: å¼€å§‹å¯¹frida-serverè¿›è¡ŒHEXæ›¿æ¢")

		// åˆ›å»ºHexReplacerå®ä¾‹
		hexReplacer := NewHexReplacer()

		// è¿›åº¦å›è°ƒ
		progressFunc := func(progress float64, message string) {
			log.Printf("INFO: Server HEXæ›¿æ¢è¿›åº¦ %.1f%% - %s", progress, message)
		}

		// æ‰§è¡Œhexæ›¿æ¢
		err := hexReplacer.PatchFile(cfd.FridaServerPath, cfd.PackageInfo.MagicName, targetPath, progressFunc)
		if err != nil {
			return fmt.Errorf("HEXæ›¿æ¢frida-serverå¤±è´¥: %v", err)
		}

		// è®¾ç½®å¯æ‰§è¡Œæƒé™
		err = os.Chmod(targetPath, 0755)
		if err != nil {
			log.Printf("WARNING: è®¾ç½®frida-serveræƒé™å¤±è´¥: %v", err)
		}

		log.Printf("SUCCESS: frida-server HEXæ›¿æ¢å®Œæˆ")
	} else {
		// ç›´æ¥å¤åˆ¶æ–‡ä»¶
		err := cfd.copyFileWithPermissions(cfd.FridaServerPath, targetPath, 0755)
		if err != nil {
			return fmt.Errorf("å¤åˆ¶frida-serverå¤±è´¥: %v", err)
		}
	}

	log.Printf("INFO: frida-serveræ–‡ä»¶å¤„ç†å®Œæˆ: %s", targetPath)
	return nil
}

// copyAndPatchFridaAgent å¤åˆ¶å¹¶ä¿®æ”¹frida-agentæ–‡ä»¶
func (cfd *CreateFridaDeb) copyAndPatchFridaAgent() error {
	log.Printf("INFO: å¼€å§‹å¤åˆ¶å’Œä¿®æ”¹frida-agentæ–‡ä»¶")

	// ç›®æ ‡è·¯å¾„
	var targetDir string
	if cfd.PackageInfo.IsRootless {
		targetDir = filepath.Join(cfd.TempDir, "var/re/usr/lib", cfd.PackageInfo.MagicName)
	} else {
		targetDir = filepath.Join(cfd.TempDir, "usr/lib", cfd.PackageInfo.MagicName)
	}

	// è·å–åŸæ–‡ä»¶å
	originalName := filepath.Base(cfd.FridaAgentPath)
	newName := strings.ReplaceAll(originalName, "frida-agent", cfd.PackageInfo.MagicName+"-agent")
	targetPath := filepath.Join(targetDir, newName)

	// å¦‚æœéœ€è¦patchï¼Œä½¿ç”¨HexReplacer
	if cfd.PackageInfo.MagicName != "frida" {
		log.Printf("INFO: å¼€å§‹å¯¹frida-agentè¿›è¡ŒHEXæ›¿æ¢")

		// åˆ›å»ºHexReplacerå®ä¾‹
		hexReplacer := NewHexReplacer()

		// è¿›åº¦å›è°ƒ
		progressFunc := func(progress float64, message string) {
			log.Printf("INFO: Agent HEXæ›¿æ¢è¿›åº¦ %.1f%% - %s", progress, message)
		}

		// æ‰§è¡Œhexæ›¿æ¢
		err := hexReplacer.PatchFile(cfd.FridaAgentPath, cfd.PackageInfo.MagicName, targetPath, progressFunc)
		if err != nil {
			return fmt.Errorf("HEXæ›¿æ¢frida-agentå¤±è´¥: %v", err)
		}

		// è®¾ç½®å¯æ‰§è¡Œæƒé™
		err = os.Chmod(targetPath, 0755)
		if err != nil {
			log.Printf("WARNING: è®¾ç½®frida-agentæƒé™å¤±è´¥: %v", err)
		}

		log.Printf("SUCCESS: frida-agent HEXæ›¿æ¢å®Œæˆ")
	} else {
		// ç›´æ¥å¤åˆ¶æ–‡ä»¶
		err := cfd.copyFileWithPermissions(cfd.FridaAgentPath, targetPath, 0755)
		if err != nil {
			return fmt.Errorf("å¤åˆ¶frida-agentå¤±è´¥: %v", err)
		}
	}

	log.Printf("INFO: frida-agentæ–‡ä»¶å¤„ç†å®Œæˆ: %s", targetPath)
	return nil
}

// createLaunchDaemonConfig åˆ›å»ºå¯åŠ¨å®ˆæŠ¤ç¨‹åºé…ç½®
func (cfd *CreateFridaDeb) createLaunchDaemonConfig() error {
	log.Printf("INFO: åˆ›å»ºå¯åŠ¨å®ˆæŠ¤ç¨‹åºé…ç½®")

	var plistPath string
	var programPath string

	if cfd.PackageInfo.IsRootless {
		plistPath = filepath.Join(cfd.TempDir, "var/re/Library/LaunchDaemons",
			fmt.Sprintf("re.%s.server.plist", cfd.PackageInfo.MagicName))
		// æ³¨æ„ï¼šrootlessç¯å¢ƒä¸‹å®é™…è¿è¡Œè·¯å¾„æ˜¯/var/jbï¼Œä½†æˆ‘ä»¬å†…éƒ¨ä½¿ç”¨/var/reé¿å…æ£€æµ‹
		programPath = fmt.Sprintf("/var/re/usr/sbin/%s", cfd.PackageInfo.MagicName)
	} else {
		plistPath = filepath.Join(cfd.TempDir, "Library/LaunchDaemons",
			fmt.Sprintf("re.%s.server.plist", cfd.PackageInfo.MagicName))
		programPath = fmt.Sprintf("/usr/sbin/%s", cfd.PackageInfo.MagicName)
	}

	// åˆ›å»ºplistå†…å®¹
	plistContent := fmt.Sprintf(`<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Label</key>
	<string>re.%s.server</string>
	<key>Program</key>
	<string>%s</string>
	<key>ProgramArguments</key>
	<array>
		<string>%s</string>`,
		cfd.PackageInfo.MagicName, programPath, programPath)

	// å¦‚æœç«¯å£ä¸æ˜¯é»˜è®¤ç«¯å£ï¼Œæ·»åŠ ç«¯å£å‚æ•°
	if cfd.PackageInfo.Port != 27042 {
		plistContent += fmt.Sprintf(`
		<string>-l</string>
		<string>0.0.0.0:%d</string>`, cfd.PackageInfo.Port)
	}

	// æ ¹æ®ç»“æ„ç±»å‹æ·»åŠ ä¸åŒçš„é…ç½®
	if cfd.PackageInfo.IsRootless {
		// Rootlessç»“æ„ - ç®€åŒ–é…ç½®
		plistContent += `
	</array>
	<key>UserName</key>
	<string>root</string>
	<key>POSIXSpawnType</key>
	<string>Interactive</string>
	<key>RunAtLoad</key>
	<true/>
	<key>KeepAlive</key>
	<true/>
	<key>ThrottleInterval</key>
	<integer>5</integer>
	<key>ExecuteAllowed</key>
	<true/>
</dict>
</plist>
`
	} else {
		// Rootç»“æ„ - åŒ…å«ç¯å¢ƒå˜é‡å’Œç³»ç»Ÿçº§é™åˆ¶
		plistContent += `
	</array>
	<key>EnvironmentVariables</key>
	<dict>
		<key>_MSSafeMode</key>
		<string>1</string>
	</dict>
	<key>UserName</key>
	<string>root</string>
	<key>POSIXSpawnType</key>
	<string>Interactive</string>
	<key>RunAtLoad</key>
	<true/>
	<key>LimitLoadToSessionType</key>
	<string>System</string>
	<key>KeepAlive</key>
	<true/>
	<key>ThrottleInterval</key>
	<integer>5</integer>
	<key>ExecuteAllowed</key>
	<true/>
</dict>
</plist>
`
	}

	err := os.WriteFile(plistPath, []byte(plistContent), 0644)
	if err != nil {
		return fmt.Errorf("å†™å…¥plistæ–‡ä»¶å¤±è´¥: %v", err)
	}

	log.Printf("INFO: å¯åŠ¨å®ˆæŠ¤ç¨‹åºé…ç½®åˆ›å»ºå®Œæˆ: %s", plistPath)
	return nil
}

// createControlFiles åˆ›å»ºæ§åˆ¶æ–‡ä»¶
func (cfd *CreateFridaDeb) createControlFiles() error {
	log.Printf("INFO: åˆ›å»ºæ§åˆ¶æ–‡ä»¶")

	// åˆ›å»ºcontrolæ–‡ä»¶ - ä¸åŸç‰ˆæ ¼å¼ä¿æŒä¸€è‡´ï¼Œä½†æ›¿æ¢fridaå­—ç¬¦ä¸²
	controlPath := filepath.Join(cfd.TempDir, "DEBIAN", "control")

	// è®¡ç®—å®‰è£…å¤§å°
	installedSize, err := cfd.calculateInstalledSize()
	if err != nil {
		log.Printf("WARNING: è®¡ç®—å®‰è£…å¤§å°å¤±è´¥: %v", err)
		installedSize = 52864 // ä½¿ç”¨åŸç‰ˆé»˜è®¤å€¼
	}

	// è®¡ç®—åŒ…å¤§å°ï¼ˆè¿‘ä¼¼å€¼ï¼‰
	packageSize := installedSize * 3 / 10 // å¤§çº¦30%çš„å‹ç¼©æ¯”

	// ç”Ÿæˆä¸åŸç‰ˆä¸€è‡´çš„controlå†…å®¹ï¼Œä½†æ›¿æ¢fridaç›¸å…³å­—ç¬¦ä¸²
	controlContent := fmt.Sprintf(`Package: re.%s.server
Name: %s
Version: %s
Priority: %s
Size: %d
Installed-Size: %d
Architecture: %s
Description: Observe and reprogram running programs.
Homepage: %s
Maintainer: %s Developers <%s@nowsecure.com>
Author: %s Developers <%s@nowsecure.com>
Section: %s
Conflicts: re.%s.server64
`,
		cfd.PackageInfo.MagicName,                // re.{magic}.server
		strings.Title(cfd.PackageInfo.MagicName), // Name: {Magic}
		cfd.PackageInfo.Version,                  // Version
		cfd.PackageInfo.Priority,                 // Priority
		packageSize,                              // Size
		installedSize,                            // Installed-Size
		cfd.PackageInfo.Architecture,             // Architecture
		cfd.PackageInfo.Homepage,                 // Homepage
		strings.Title(cfd.PackageInfo.MagicName), // Maintainer: {Magic} Developers
		cfd.PackageInfo.MagicName,                // email prefix
		strings.Title(cfd.PackageInfo.MagicName), // Author: {Magic} Developers
		cfd.PackageInfo.MagicName,                // email prefix
		cfd.PackageInfo.Section,                  // Section
		cfd.PackageInfo.MagicName,                // Conflicts: re.{magic}.server64
	)

	err = os.WriteFile(controlPath, []byte(controlContent), 0644)
	if err != nil {
		return fmt.Errorf("å†™å…¥controlæ–‡ä»¶å¤±è´¥: %v", err)
	}

	// åˆ›å»ºextrainst_æ–‡ä»¶ï¼ˆç©ºæ–‡ä»¶ï¼Œä¿æŒä¸åŸç‰ˆä¸€è‡´ï¼‰
	extrainstPath := filepath.Join(cfd.TempDir, "DEBIAN", "extrainst_")
	err = os.WriteFile(extrainstPath, []byte(""), 0755)
	if err != nil {
		return fmt.Errorf("åˆ›å»ºextrainst_æ–‡ä»¶å¤±è´¥: %v", err)
	}

	// åˆ›å»ºpostinstè„šæœ¬
	err = cfd.createPostInstScript()
	if err != nil {
		return fmt.Errorf("åˆ›å»ºpostinstè„šæœ¬å¤±è´¥: %v", err)
	}

	// åˆ›å»ºprermè„šæœ¬
	err = cfd.createPreRmScript()
	if err != nil {
		return fmt.Errorf("åˆ›å»ºprermè„šæœ¬å¤±è´¥: %v", err)
	}

	log.Printf("INFO: æ§åˆ¶æ–‡ä»¶åˆ›å»ºå®Œæˆ")
	return nil
}

// createPostInstScript åˆ›å»ºå®‰è£…åè„šæœ¬
func (cfd *CreateFridaDeb) createPostInstScript() error {
	postinstPath := filepath.Join(cfd.TempDir, "DEBIAN", "postinst")

	var content string
	if cfd.PackageInfo.IsRootless {
		content = fmt.Sprintf(`#!/bin/bash
set -e

# è®¾ç½®å¯æ‰§è¡Œæƒé™ (Rootless)
chmod 755 /var/re/usr/sbin/%s
chown root:wheel /var/re/usr/sbin/%s

# è®¾ç½® agent dylib æƒé™ (Rootless)
if [ -d "/var/re/usr/lib/%s" ]; then
    chmod 755 /var/re/usr/lib/%s/*
    chown root:wheel /var/re/usr/lib/%s/*
fi

# åŠ è½½å®ˆæŠ¤ç¨‹åº
if [ -f /var/re/Library/LaunchDaemons/re.%s.server.plist ]; then
    launchctl load /var/re/Library/LaunchDaemons/re.%s.server.plist
fi

echo "Fridare %s å®‰è£…å®Œæˆ (Rootless)"
echo "æœåŠ¡å·²å¯åŠ¨åœ¨ç«¯å£ %d"
`,
			cfd.PackageInfo.MagicName, cfd.PackageInfo.MagicName,
			cfd.PackageInfo.MagicName, cfd.PackageInfo.MagicName, cfd.PackageInfo.MagicName,
			cfd.PackageInfo.MagicName, cfd.PackageInfo.MagicName,
			cfd.PackageInfo.MagicName, cfd.PackageInfo.Port,
		)
	} else {
		content = fmt.Sprintf(`#!/bin/bash
set -e

# è®¾ç½®å¯æ‰§è¡Œæƒé™ (Root)
chmod 755 /usr/sbin/%s
chown root:wheel /usr/sbin/%s

# è®¾ç½® agent dylib æƒé™ (Root)
if [ -d "/usr/lib/%s" ]; then
    chmod 755 /usr/lib/%s/*
    chown root:wheel /usr/lib/%s/*
fi

# åŠ è½½å®ˆæŠ¤ç¨‹åº
if [ -f /Library/LaunchDaemons/re.%s.server.plist ]; then
    launchctl load /Library/LaunchDaemons/re.%s.server.plist
fi

echo "Fridare %s å®‰è£…å®Œæˆ (Root)"
echo "æœåŠ¡å·²å¯åŠ¨åœ¨ç«¯å£ %d"
`,
			cfd.PackageInfo.MagicName, cfd.PackageInfo.MagicName,
			cfd.PackageInfo.MagicName, cfd.PackageInfo.MagicName, cfd.PackageInfo.MagicName,
			cfd.PackageInfo.MagicName, cfd.PackageInfo.MagicName,
			cfd.PackageInfo.MagicName, cfd.PackageInfo.Port,
		)
	}

	return os.WriteFile(postinstPath, []byte(content), 0755)
}

// createPreRmScript åˆ›å»ºå¸è½½å‰è„šæœ¬
func (cfd *CreateFridaDeb) createPreRmScript() error {
	prermPath := filepath.Join(cfd.TempDir, "DEBIAN", "prerm")

	var content string
	if cfd.PackageInfo.IsRootless {
		content = fmt.Sprintf(`#!/bin/bash
set -e

# åœæ­¢å®ˆæŠ¤ç¨‹åº (Rootless)
if [ -f /var/re/Library/LaunchDaemons/re.%s.server.plist ]; then
    launchctl unload /var/re/Library/LaunchDaemons/re.%s.server.plist
fi

echo "Fridare %s æœåŠ¡å·²åœæ­¢ (Rootless)"
`,
			cfd.PackageInfo.MagicName, cfd.PackageInfo.MagicName,
			cfd.PackageInfo.MagicName,
		)
	} else {
		content = fmt.Sprintf(`#!/bin/bash
set -e

# åœæ­¢å®ˆæŠ¤ç¨‹åº (Root)
if [ -f /Library/LaunchDaemons/re.%s.server.plist ]; then
    launchctl unload /Library/LaunchDaemons/re.%s.server.plist
fi

echo "Fridare %s æœåŠ¡å·²åœæ­¢ (Root)"
`,
			cfd.PackageInfo.MagicName, cfd.PackageInfo.MagicName,
			cfd.PackageInfo.MagicName,
		)
	}

	return os.WriteFile(prermPath, []byte(content), 0755)
}

// calculateInstalledSize è®¡ç®—å®‰è£…å¤§å°ï¼ˆKBï¼‰
func (cfd *CreateFridaDeb) calculateInstalledSize() (int, error) {
	var totalSize int64

	err := filepath.Walk(cfd.TempDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// è·³è¿‡DEBIANç›®å½•
		if strings.Contains(path, "DEBIAN") {
			return nil
		}

		if !info.IsDir() {
			totalSize += info.Size()
		}
		return nil
	})

	if err != nil {
		return 0, err
	}

	// è½¬æ¢ä¸ºKBå¹¶å‘ä¸Šå–æ•´
	sizeKB := int((totalSize + 1023) / 1024)
	return sizeKB, nil
}

// buildDebPackage æ„å»ºDEBåŒ…
func (cfd *CreateFridaDeb) buildDebPackage() error {
	log.Printf("INFO: å¼€å§‹æ„å»ºDEBåŒ…")

	// ä½¿ç”¨å†…ç½®çš„çº¯Goæ–¹å¼æ„å»º
	modifier := &DebModifier{
		OutputPath: cfd.OutputPath,
		ExtractDir: cfd.TempDir,
		MagicName:  cfd.PackageInfo.MagicName, // ä¼ é€’é­”æ”¹åç§°
	}

	return modifier.repackageWithGoAr()
}

// copyFileWithPermissions å¤åˆ¶æ–‡ä»¶å¹¶è®¾ç½®æƒé™
func (cfd *CreateFridaDeb) copyFileWithPermissions(src, dst string, perm os.FileMode) error {
	// ç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨
	dstDir := filepath.Dir(dst)
	err := os.MkdirAll(dstDir, 0755)
	if err != nil {
		return fmt.Errorf("åˆ›å»ºç›®æ ‡ç›®å½•å¤±è´¥: %v", err)
	}

	// å¤åˆ¶æ–‡ä»¶
	srcFile, err := os.Open(src)
	if err != nil {
		return fmt.Errorf("æ‰“å¼€æºæ–‡ä»¶å¤±è´¥: %v", err)
	}
	defer srcFile.Close()

	dstFile, err := os.Create(dst)
	if err != nil {
		return fmt.Errorf("åˆ›å»ºç›®æ ‡æ–‡ä»¶å¤±è´¥: %v", err)
	}
	defer dstFile.Close()

	_, err = io.Copy(dstFile, srcFile)
	if err != nil {
		return fmt.Errorf("å¤åˆ¶æ–‡ä»¶å†…å®¹å¤±è´¥: %v", err)
	}

	// è®¾ç½®æƒé™
	err = os.Chmod(dst, perm)
	if err != nil {
		return fmt.Errorf("è®¾ç½®æ–‡ä»¶æƒé™å¤±è´¥: %v", err)
	}

	return nil
}

// GetDefaultCreatePackageInfo è·å–é»˜è®¤çš„åˆ›å»ºåŒ…ä¿¡æ¯
func GetDefaultCreatePackageInfo(magicName string, port int, isRootless bool) *PackageInfo {
	packageName := fmt.Sprintf("re.frida.server.%s", magicName)
	if isRootless {
		packageName += ".rootless"
	}

	return &PackageInfo{
		Name:         packageName,
		Version:      "17.2.17",
		Architecture: "iphoneos-arm64",
		Maintainer:   "Fridare Team <support@fridare.com>",
		Description:  fmt.Sprintf("Dynamic instrumentation toolkit for developers, security researchers, and reverse engineers (Modified: %s)", magicName),
		Depends:      "firmware (>= 12.0)",
		Section:      "Development",
		Priority:     "optional",
		Homepage:     "https://frida.re/",
		Port:         port,
		MagicName:    magicName,
		IsRootless:   isRootless,
	}
}

```

`ui/internal/core/frida.go`:

```go
package core

import (
	"context"
	"fmt"
	"io"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/go-resty/resty/v2"
)

// FridaVersion Fridaç‰ˆæœ¬ä¿¡æ¯
type FridaVersion struct {
	Version    string    `json:"tag_name"`
	Name       string    `json:"name"`
	Body       string    `json:"body"`
	Published  time.Time `json:"published_at"`
	PreRelease bool      `json:"prerelease"`
	Draft      bool      `json:"draft"`
	Assets     []Asset   `json:"assets"`
}

// Asset å‘å¸ƒèµ„æº
type Asset struct {
	Name        string `json:"name"`
	Size        int64  `json:"size"`
	DownloadURL string `json:"browser_download_url"`
	ContentType string `json:"content_type"`
}

// Platform æ”¯æŒçš„å¹³å°
type Platform struct {
	OS   string
	Arch string
	Name string
}

// SupportedPlatforms æ”¯æŒçš„å¹³å°åˆ—è¡¨
var SupportedPlatforms = []Platform{
	{"android", "arm64", "Android ARM64"},
	{"android", "arm", "Android ARM"},
	{"android", "x86_64", "Android x86_64"},
	{"android", "x86", "Android x86"},
	{"ios", "arm64", "iOS ARM64"},
	{"windows", "x86_64", "Windows x64"},
	{"windows", "x86", "Windows x86"},
	{"linux", "x86_64", "Linux x64"},
	{"linux", "arm64", "Linux ARM64"},
	{"macos", "arm64", "macOS ARM64"},
	{"macos", "x86_64", "macOS x64"},
}

// FileType æ–‡ä»¶ç±»å‹
type FileType string

const (
	FileTypeServer FileType = "server"
	FileTypeGadget FileType = "gadget"
	FileTypeTools  FileType = "tools"
)

// FridaClient Fridaå®¢æˆ·ç«¯
type FridaClient struct {
	client *resty.Client
	proxy  string
}

// NewFridaClient åˆ›å»ºæ–°çš„Fridaå®¢æˆ·ç«¯
func NewFridaClient(proxy string, timeout time.Duration) *FridaClient {
	client := resty.New().
		SetTimeout(timeout).
		SetRetryCount(3).
		SetRetryWaitTime(5 * time.Second).
		SetRetryMaxWaitTime(30 * time.Second)

	if proxy != "" {
		client.SetProxy(proxy)
	}

	// è®¾ç½®ç”¨æˆ·ä»£ç†
	client.SetHeader("User-Agent", "Fridare-GUI/1.0.0")

	return &FridaClient{
		client: client,
		proxy:  proxy,
	}
}

// GetVersions è·å–Fridaç‰ˆæœ¬åˆ—è¡¨
func (fc *FridaClient) GetVersions() ([]FridaVersion, error) {
	var releases []FridaVersion

	// GitHub APIè·å–releases
	resp, err := fc.client.R().
		SetResult(&releases).
		Get("https://api.github.com/repos/frida/frida/releases")

	if err != nil {
		return nil, fmt.Errorf("è·å–ç‰ˆæœ¬åˆ—è¡¨å¤±è´¥: %w", err)
	}

	if resp.StatusCode() != 200 {
		return nil, fmt.Errorf("GitHub APIè¿”å›é”™è¯¯çŠ¶æ€ç : %d", resp.StatusCode())
	}

	// è¿‡æ»¤å¹¶æ’åº
	var validReleases []FridaVersion
	for _, release := range releases {
		if !release.Draft && len(release.Assets) > 0 {
			validReleases = append(validReleases, release)
		}
	}

	// æŒ‰ç‰ˆæœ¬å·æ’åºï¼ˆæœ€æ–°çš„åœ¨å‰é¢ï¼‰
	sort.Slice(validReleases, func(i, j int) bool {
		return compareVersions(validReleases[i].Version, validReleases[j].Version) > 0
	})

	return validReleases, nil
}

// GetLatestVersion è·å–æœ€æ–°ç‰ˆæœ¬
func (fc *FridaClient) GetLatestVersion() (*FridaVersion, error) {
	versions, err := fc.GetVersions()
	if err != nil {
		return nil, err
	}

	if len(versions) == 0 {
		return nil, fmt.Errorf("æ²¡æœ‰æ‰¾åˆ°å¯ç”¨ç‰ˆæœ¬")
	}

	// è¿”å›ç¬¬ä¸€ä¸ªéé¢„å‘å¸ƒç‰ˆæœ¬
	for _, version := range versions {
		if !version.PreRelease {
			return &version, nil
		}
	}

	// å¦‚æœæ²¡æœ‰ç¨³å®šç‰ˆæœ¬ï¼Œè¿”å›æœ€æ–°çš„é¢„å‘å¸ƒç‰ˆæœ¬
	return &versions[0], nil
}

// FindAsset æŸ¥æ‰¾åŒ¹é…çš„èµ„æºæ–‡ä»¶
func (fc *FridaClient) FindAsset(version *FridaVersion, platform Platform, fileType FileType) (*Asset, error) {
	var pattern string

	switch fileType {
	case FileTypeServer:
		pattern = fmt.Sprintf(`frida-server-.*-%s-%s.*`, version.Version, platform.OS)
		if platform.Arch != "" {
			pattern = fmt.Sprintf(`frida-server-.*-%s-%s-%s.*`, version.Version, platform.OS, platform.Arch)
		}
	case FileTypeGadget:
		pattern = fmt.Sprintf(`frida-gadget-.*-%s-%s.*`, version.Version, platform.OS)
		if platform.Arch != "" {
			pattern = fmt.Sprintf(`frida-gadget-.*-%s-%s-%s.*`, version.Version, platform.OS, platform.Arch)
		}
	case FileTypeTools:
		pattern = fmt.Sprintf(`frida-tools-.*-%s.*`, version.Version)
	default:
		return nil, fmt.Errorf("ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: %s", fileType)
	}

	regex, err := regexp.Compile(pattern)
	if err != nil {
		return nil, fmt.Errorf("ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼å¤±è´¥: %w", err)
	}

	for _, asset := range version.Assets {
		if regex.MatchString(asset.Name) {
			return &asset, nil
		}
	}

	return nil, fmt.Errorf("æœªæ‰¾åˆ°åŒ¹é…çš„æ–‡ä»¶: %s", pattern)
}

// DownloadProgress ä¸‹è½½è¿›åº¦å›è°ƒ
type DownloadProgress func(downloaded, total int64, speed float64)

// DownloadFile ä¸‹è½½æ–‡ä»¶
func (fc *FridaClient) DownloadFile(url, filename string, progress DownloadProgress) error {
	resp, err := fc.client.R().
		SetDoNotParseResponse(true).
		Get(url)

	if err != nil {
		return fmt.Errorf("ä¸‹è½½å¤±è´¥: %w", err)
	}
	defer resp.RawBody().Close()

	if resp.StatusCode() != 200 {
		return fmt.Errorf("ä¸‹è½½å¤±è´¥ï¼ŒçŠ¶æ€ç : %d", resp.StatusCode())
	}

	// è·å–æ–‡ä»¶å¤§å°
	contentLength := resp.Header().Get("Content-Length")
	var totalSize int64
	if contentLength != "" {
		totalSize, _ = strconv.ParseInt(contentLength, 10, 64)
	}

	// åˆ›å»ºæ–‡ä»¶
	out, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("åˆ›å»ºæ–‡ä»¶å¤±è´¥: %w", err)
	}
	defer out.Close()

	// ä¸‹è½½å¹¶ç›‘æ§è¿›åº¦
	var downloaded int64
	startTime := time.Now()
	buffer := make([]byte, 32*1024) // 32KBç¼“å†²åŒº

	for {
		n, err := resp.RawBody().Read(buffer)
		if n > 0 {
			_, writeErr := out.Write(buffer[:n])
			if writeErr != nil {
				return fmt.Errorf("å†™å…¥æ–‡ä»¶å¤±è´¥: %w", writeErr)
			}

			downloaded += int64(n)

			// è®¡ç®—é€Ÿåº¦
			elapsed := time.Since(startTime).Seconds()
			speed := float64(downloaded) / elapsed

			// è°ƒç”¨è¿›åº¦å›è°ƒ
			if progress != nil {
				progress(downloaded, totalSize, speed)
			}
		}

		if err != nil {
			if err == io.EOF {
				break
			}
			return fmt.Errorf("è¯»å–å“åº”å¤±è´¥: %w", err)
		}
	}

	return nil
}

// DownloadFileWithContext ä¸‹è½½æ–‡ä»¶ï¼ˆæ”¯æŒä¸Šä¸‹æ–‡å–æ¶ˆï¼‰
func (fc *FridaClient) DownloadFileWithContext(ctx context.Context, url, filename string, progress DownloadProgress) error {
	resp, err := fc.client.R().
		SetContext(ctx).
		SetDoNotParseResponse(true).
		Get(url)

	if err != nil {
		return fmt.Errorf("ä¸‹è½½å¤±è´¥: %w", err)
	}
	defer resp.RawBody().Close()

	if resp.StatusCode() != 200 {
		return fmt.Errorf("ä¸‹è½½å¤±è´¥ï¼ŒçŠ¶æ€ç : %d", resp.StatusCode())
	}

	// è·å–æ–‡ä»¶å¤§å°
	contentLength := resp.Header().Get("Content-Length")
	var totalSize int64
	if contentLength != "" {
		totalSize, _ = strconv.ParseInt(contentLength, 10, 64)
	}

	// åˆ›å»ºæ–‡ä»¶
	out, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("åˆ›å»ºæ–‡ä»¶å¤±è´¥: %w", err)
	}
	defer out.Close()

	// ä¸‹è½½å¹¶ç›‘æ§è¿›åº¦
	var downloaded int64
	startTime := time.Now()
	buffer := make([]byte, 32*1024) // 32KBç¼“å†²åŒº

	for {
		// æ›´é¢‘ç¹åœ°æ£€æŸ¥ä¸Šä¸‹æ–‡æ˜¯å¦è¢«å–æ¶ˆ
		select {
		case <-ctx.Done():
			// ç«‹å³å…³é—­æ–‡ä»¶å¹¶åˆ é™¤éƒ¨åˆ†ä¸‹è½½çš„æ–‡ä»¶
			out.Close()
			os.Remove(filename)
			return ctx.Err()
		default:
		}

		// è®¾ç½®è¯»å–è¶…æ—¶ï¼Œä½¿å¾—å–æ¶ˆæ£€æŸ¥æ›´åŠæ—¶
		n, err := resp.RawBody().Read(buffer)
		if n > 0 {
			// åœ¨å†™å…¥å‰å†æ¬¡æ£€æŸ¥å–æ¶ˆ
			select {
			case <-ctx.Done():
				out.Close()
				os.Remove(filename)
				return ctx.Err()
			default:
			}

			_, writeErr := out.Write(buffer[:n])
			if writeErr != nil {
				return fmt.Errorf("å†™å…¥æ–‡ä»¶å¤±è´¥: %w", writeErr)
			}

			downloaded += int64(n)

			// è®¡ç®—é€Ÿåº¦
			elapsed := time.Since(startTime).Seconds()
			speed := float64(downloaded) / elapsed

			// è°ƒç”¨è¿›åº¦å›è°ƒï¼ˆåœ¨å›è°ƒä¸­ä¹Ÿæ£€æŸ¥å–æ¶ˆï¼‰
			if progress != nil {
				select {
				case <-ctx.Done():
					out.Close()
					os.Remove(filename)
					return ctx.Err()
				default:
					progress(downloaded, totalSize, speed)
				}
			}
		}

		if err != nil {
			if err == io.EOF {
				break
			}
			return fmt.Errorf("è¯»å–å“åº”å¤±è´¥: %w", err)
		}
	}

	return nil
}

// compareVersions æ¯”è¾ƒç‰ˆæœ¬å·
func compareVersions(v1, v2 string) int {
	// ç§»é™¤ 'v' å‰ç¼€
	v1 = strings.TrimPrefix(v1, "v")
	v2 = strings.TrimPrefix(v2, "v")

	parts1 := strings.Split(v1, ".")
	parts2 := strings.Split(v2, ".")

	maxLen := len(parts1)
	if len(parts2) > maxLen {
		maxLen = len(parts2)
	}

	for i := 0; i < maxLen; i++ {
		var p1, p2 int
		if i < len(parts1) {
			p1, _ = strconv.Atoi(parts1[i])
		}
		if i < len(parts2) {
			p2, _ = strconv.Atoi(parts2[i])
		}

		if p1 > p2 {
			return 1
		} else if p1 < p2 {
			return -1
		}
	}

	return 0
}

// GetPlatformByName æ ¹æ®åç§°è·å–å¹³å°
func GetPlatformByName(name string) *Platform {
	for _, platform := range SupportedPlatforms {
		if platform.Name == name {
			return &platform
		}
	}
	return nil
}

// GetFileTypeByName æ ¹æ®åç§°è·å–æ–‡ä»¶ç±»å‹
func GetFileTypeByName(name string) FileType {
	switch name {
	case "frida-server (å¯æ‰§è¡Œæ–‡ä»¶)":
		return FileTypeServer
	case "frida-gadget (åŠ¨æ€åº“)":
		return FileTypeGadget
	case "frida-tools (PythonåŒ…)":
		return FileTypeTools
	default:
		return FileTypeServer
	}
}

// FormatSize æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
func FormatSize(size int64) string {
	const unit = 1024
	if size < unit {
		return fmt.Sprintf("%d B", size)
	}
	div, exp := int64(unit), 0
	for n := size / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(size)/float64(div), "KMGTPE"[exp])
}

// FormatSpeed æ ¼å¼åŒ–ä¸‹è½½é€Ÿåº¦
func FormatSpeed(bytesPerSecond float64) string {
	return FormatSize(int64(bytesPerSecond)) + "/s"
}

```

`ui/internal/core/hexreplace.go`:

```go
package core

import (
	"debug/elf"
	"debug/macho"
	"debug/pe"
	"fmt"
	"fridare-gui/internal/utils"
	"io"
	"os"
)

// ExecutableFormat represents the type of executable file
type ExecutableFormat int

const (
	PE ExecutableFormat = iota
	MachO
	ELF
)

// Replacement represents a hex replacement operation
type Replacement struct {
	Old []byte
	New []byte
}

// Replacements represents a collection of replacements for a specific section
type Replacements struct {
	ExecutableFormat ExecutableFormat
	SectionName      string
	Items            []*Replacement
}

// HexReplacer handles binary file patching operations
type HexReplacer struct{}

// NewHexReplacer creates a new hex replacer instance
func NewHexReplacer() *HexReplacer {
	return &HexReplacer{}
}

// PatchFile patches a binary file with the given frida new name
func (hr *HexReplacer) PatchFile(inputFilePath, fridaNewName, outputFilePath string, progressCallback func(float64, string)) error {
	// Validate frida new name (must be exactly 5 characters, all lowercase)
	if len(fridaNewName) != 5 || !utils.IsFridaNewName(fridaNewName) {
		return fmt.Errorf("frida new name must be exactly 5 lowercase alphabetic characters")
	}

	if progressCallback != nil {
		progressCallback(0.1, "æ­£åœ¨å¤åˆ¶æ–‡ä»¶...")
	}

	// Copy input file to output file
	if err := copyFile(inputFilePath, outputFilePath); err != nil {
		return fmt.Errorf("error copying file: %v", err)
	}

	if progressCallback != nil {
		progressCallback(0.3, "æ­£åœ¨æ£€æµ‹æ–‡ä»¶æ ¼å¼...")
	}

	// Detect and open file
	file, format, err := detectAndOpenFile(outputFilePath)
	if err != nil {
		return fmt.Errorf("error opening file: %v", err)
	}

	if progressCallback != nil {
		progressCallback(0.5, fmt.Sprintf("æ­£åœ¨å¤„ç† %s æ ¼å¼æ–‡ä»¶...", formatToString(format)))
	}

	// Process based on file format
	switch f := file.(type) {
	case *macho.File:
		if progressCallback != nil {
			progressCallback(0.7, "æ­£åœ¨ä¿®æ”¹ MachO å•æ¶æ„æ–‡ä»¶...")
		}
		return hr.handleSingleArchitecture(f, outputFilePath, fridaNewName, format)
	case *macho.FatFile:
		if progressCallback != nil {
			progressCallback(0.7, "æ­£åœ¨ä¿®æ”¹ MachO å¤šæ¶æ„æ–‡ä»¶...")
		}
		return hr.handleMultipleArchitectures(f, outputFilePath, fridaNewName, format)
	case *elf.File:
		if progressCallback != nil {
			progressCallback(0.7, "æ­£åœ¨ä¿®æ”¹ ELF æ–‡ä»¶...")
		}
		return hr.handleELFFile(f, outputFilePath, fridaNewName, format)
	case *pe.File:
		if progressCallback != nil {
			progressCallback(0.7, "æ­£åœ¨ä¿®æ”¹ PE æ–‡ä»¶...")
		}
		return hr.handlePEFile(f, outputFilePath, fridaNewName, format)
	default:
		return fmt.Errorf("unsupported file type")
	}
}

// DescribeFile returns a description of the file format and architecture
func (hr *HexReplacer) DescribeFile(filePath string) (string, error) {
	file, format, err := detectAndOpenFile(filePath)
	if err != nil {
		return "", fmt.Errorf("error opening file: %v", err)
	}

	description := fmt.Sprintf("Detected file format: %s\n", formatToString(format))
	description += describeArch(file, format)

	return description, nil
}

// detectAndOpenFile detects file format and opens it
func detectAndOpenFile(filePath string) (interface{}, ExecutableFormat, error) {
	if machoFile, err := macho.Open(filePath); err == nil {
		return machoFile, MachO, nil
	}
	if fatFile, err := macho.OpenFat(filePath); err == nil {
		return fatFile, MachO, nil
	}
	if elfFile, err := elf.Open(filePath); err == nil {
		return elfFile, ELF, nil
	}
	if peFile, err := pe.Open(filePath); err == nil {
		return peFile, PE, nil
	}
	return nil, 0, fmt.Errorf("unsupported file format")
}

// copyFile copies a file from src to dst
func copyFile(src, dst string) error {
	sourceFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer sourceFile.Close()

	destFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer destFile.Close()

	_, err = io.Copy(destFile, sourceFile)
	if err != nil {
		return err
	}

	// Set executable permissions
	return os.Chmod(dst, 0755)
}

// handlePEFile handles PE format files
func (hr *HexReplacer) handlePEFile(file *pe.File, outputFilePath, fridaNewName string, format ExecutableFormat) error {
	replacementsList := buildReplacements(fridaNewName, format)
	for _, replacements := range replacementsList {
		section := file.Section(replacements.SectionName)
		if section == nil {
			continue // Skip missing sections
		}

		data, err := section.Data()
		if err != nil {
			return fmt.Errorf("error reading section data for %s: %v", replacements.SectionName, err)
		}

		modifiedData := replaceInSection(data, replacements.Items)
		if err := writeModifiedSection(outputFilePath, int64(section.Offset), modifiedData); err != nil {
			return fmt.Errorf("error writing modified data for %s: %v", replacements.SectionName, err)
		}
	}
	return nil
}

// handleELFFile handles ELF format files
func (hr *HexReplacer) handleELFFile(file *elf.File, outputFilePath, fridaNewName string, format ExecutableFormat) error {
	replacementsList := buildReplacements(fridaNewName, format)
	for _, replacements := range replacementsList {
		section := file.Section(replacements.SectionName)
		if section == nil {
			continue // Skip missing sections
		}

		data, err := section.Data()
		if err != nil {
			return fmt.Errorf("error reading section data for %s: %v", replacements.SectionName, err)
		}

		modifiedData := replaceInSection(data, replacements.Items)
		if err := writeModifiedSection(outputFilePath, int64(section.Offset), modifiedData); err != nil {
			return fmt.Errorf("error writing modified data for %s: %v", replacements.SectionName, err)
		}
	}
	return nil
}

// handleSingleArchitecture handles single architecture MachO files
func (hr *HexReplacer) handleSingleArchitecture(file *macho.File, outputFilePath, fridaNewName string, format ExecutableFormat) error {
	replacementsList := buildReplacements(fridaNewName, format)
	for _, replacements := range replacementsList {
		section := file.Section(replacements.SectionName)
		if section == nil {
			continue // Skip missing sections
		}

		data, err := section.Data()
		if err != nil {
			return fmt.Errorf("error reading section data for %s: %v", replacements.SectionName, err)
		}

		modifiedData := replaceInSection(data, replacements.Items)
		if err := writeModifiedSection(outputFilePath, int64(section.Offset), modifiedData); err != nil {
			return fmt.Errorf("error writing modified data for %s: %v", replacements.SectionName, err)
		}
	}
	return nil
}

// handleMultipleArchitectures handles fat MachO files with multiple architectures
func (hr *HexReplacer) handleMultipleArchitectures(fatFile *macho.FatFile, filePath, fridaNewName string, format ExecutableFormat) error {
	for _, arch := range fatFile.Arches {
		if err := hr.patchArchitecture(arch, filePath, fridaNewName, format); err != nil {
			return err
		}
	}
	return nil
}

// patchArchitecture patches a specific architecture in a fat binary
func (hr *HexReplacer) patchArchitecture(arch macho.FatArch, filePath, fridaNewName string, format ExecutableFormat) error {
	replacementsList := buildReplacements(fridaNewName, format)
	for _, replacements := range replacementsList {
		section := arch.Section(replacements.SectionName)
		if section == nil {
			continue // Skip missing sections
		}

		data, err := section.Data()
		if err != nil {
			return fmt.Errorf("error reading section data for %s in architecture %s: %v", replacements.SectionName, arch.Cpu.String(), err)
		}

		modifiedData := replaceInSection(data, replacements.Items)
		if err := writeModifiedSection(filePath, int64(arch.Offset+section.Offset), modifiedData); err != nil {
			return fmt.Errorf("error writing modified data for %s in architecture %s: %v", replacements.SectionName, arch.Cpu.String(), err)
		}
	}
	return nil
}

// buildReplacements builds replacement rules based on file format
func buildReplacements(fridaNewName string, format ExecutableFormat) []Replacements {
	switch format {
	case MachO:
		return []Replacements{
			{
				ExecutableFormat: format,
				SectionName:      "__cstring",
				Items: []*Replacement{
					{Old: []byte("frida_server_"), New: []byte(fridaNewName + "_server_")},
					{Old: []byte("frida-server-main-loop"), New: []byte(fridaNewName + "-server-main-loop")},
					{Old: []byte("frida-main-loop"), New: []byte(fridaNewName + "-main-loop")},
					{Old: []byte("frida:rpc"), New: []byte(fridaNewName + ":rpc")},
					{Old: []byte("frida-agent.dylib"), New: []byte(fridaNewName + "-agent.dylib")},
					{Old: []byte("/usr/lib/frida/"), New: []byte("/usr/lib/" + fridaNewName + "/")},
					{Old: []byte("gum-"), New: []byte(fridaNewName[:3] + "-")},
				},
			},
			{
				ExecutableFormat: format,
				SectionName:      "__const",
				Items: []*Replacement{
					{Old: []byte("frida:rpc"), New: []byte(fridaNewName + ":rpc")},
				},
			},
		}
	case ELF:
		return []Replacements{
			{
				ExecutableFormat: format,
				SectionName:      ".rodata",
				Items: []*Replacement{
					{Old: []byte("frida_server_"), New: []byte(fridaNewName + "_server_")},
					{Old: []byte("frida-main-loop"), New: []byte(fridaNewName + "-main-loop")},
					{Old: []byte("frida:rpc"), New: []byte(fridaNewName + ":rpc")},
					{Old: []byte("frida-agent-<arch>.so"), New: []byte(fridaNewName + "-agent-<arch>.so")},
					{Old: []byte("frida-agent-arm.so"), New: []byte(fridaNewName + "-agent-arm.so")},
					{Old: []byte("frida-agent-arm64.so"), New: []byte(fridaNewName + "-agent-arm64.so")},
					{Old: []byte("frida-agent-32.so"), New: []byte(fridaNewName + "-agent-32.so")},
					{Old: []byte("frida-agent-64.so"), New: []byte(fridaNewName + "-agent-64.so")},
					{Old: []byte("gum-"), New: []byte(fridaNewName[:3] + "-")},
				},
			},
			{
				ExecutableFormat: format,
				SectionName:      ".text",
				Items: []*Replacement{
					{Old: []byte("frida:rpc"), New: []byte(fridaNewName + ":rpc")},
					{Old: []byte("gum-"), New: []byte(fridaNewName[:3] + "-")},
				},
			},
		}
	case PE:
		return []Replacements{
			{
				ExecutableFormat: format,
				SectionName:      ".rdata",
				Items: []*Replacement{
					{Old: []byte("frida-"), New: []byte(fridaNewName + "-")},
					{Old: []byte("frida_"), New: []byte(fridaNewName + "_")},
					{Old: []byte("frida_server_"), New: []byte(fridaNewName + "_server_")},
					{Old: []byte("frida-main-loop"), New: []byte(fridaNewName + "-main-loop")},
					{Old: []byte("gum-"), New: []byte(fridaNewName[:3] + "-")},
					{Old: []byte("frida-thread"), New: []byte(fridaNewName + "-thread")},
					{Old: []byte("frida:rpc"), New: []byte(fridaNewName + ":rpc")},
					{Old: []byte("frida-agent"), New: []byte(fridaNewName + "-agent")},
				},
			},
		}
	}
	return nil
}

// replaceInSection performs replacements in a section's data
func replaceInSection(data []byte, replacements []*Replacement) []byte {
	modifiedData := make([]byte, len(data))
	copy(modifiedData, data)

	for _, replacement := range replacements {
		oldBytes := replacement.Old
		newBytes := replacement.New

		for i := 0; i <= len(modifiedData)-len(oldBytes); i++ {
			if bytesEqual(modifiedData[i:i+len(oldBytes)], oldBytes) {
				replacementBytes := make([]byte, len(oldBytes))
				copy(replacementBytes, newBytes)
				// Pad with zeros if new bytes are shorter
				for j := len(newBytes); j < len(oldBytes); j++ {
					replacementBytes[j] = 0
				}
				copy(modifiedData[i:i+len(oldBytes)], replacementBytes)
			}
		}
	}

	return modifiedData
}

// bytesEqual compares two byte slices for equality
func bytesEqual(a, b []byte) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

// writeModifiedSection writes modified data to a specific offset in the file
func writeModifiedSection(filePath string, offset int64, data []byte) error {
	f, err := os.OpenFile(filePath, os.O_RDWR, 0)
	if err != nil {
		return err
	}
	defer f.Close()

	_, err = f.WriteAt(data, offset)
	return err
}

// formatToString converts ExecutableFormat to string
func formatToString(format ExecutableFormat) string {
	switch format {
	case PE:
		return "PE"
	case MachO:
		return "MachO"
	case ELF:
		return "ELF"
	default:
		return "Unknown"
	}
}

```

`ui/internal/core/patcher.go`:

```go
package core

import (
	"bytes"
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
)

// PatchInfo ä¿®è¡¥ä¿¡æ¯
type PatchInfo struct {
	OriginalHex    string
	ReplacementHex string
	Description    string
}

// BinaryPatcher äºŒè¿›åˆ¶æ–‡ä»¶ä¿®è¡¥å™¨
type BinaryPatcher struct {
	workDir string
}

// NewBinaryPatcher åˆ›å»ºæ–°çš„äºŒè¿›åˆ¶ä¿®è¡¥å™¨
func NewBinaryPatcher(workDir string) *BinaryPatcher {
	return &BinaryPatcher{
		workDir: workDir,
	}
}

// GetPredefinedPatches è·å–é¢„å®šä¹‰çš„ä¿®è¡¥æ¨¡å¼
func (bp *BinaryPatcher) GetPredefinedPatches() map[string][]PatchInfo {
	return map[string][]PatchInfo{
		"frida-server": {
			{
				OriginalHex:    "667269646124736572766572",
				ReplacementHex: "", // å°†åœ¨è¿è¡Œæ—¶è®¾ç½®
				Description:    "ä¿®æ”¹æœåŠ¡å™¨åç§°",
			},
			{
				OriginalHex:    "000000000000FFFF0000FFFF",
				ReplacementHex: "", // å°†åœ¨è¿è¡Œæ—¶è®¾ç½®
				Description:    "ä¿®æ”¹é»˜è®¤ç«¯å£",
			},
		},
		"frida-gadget": {
			{
				OriginalHex:    "667269646124676164676574",
				ReplacementHex: "", // å°†åœ¨è¿è¡Œæ—¶è®¾ç½®
				Description:    "ä¿®æ”¹gadgetæ ‡è¯†",
			},
		},
		"frida.dll": {
			{
				OriginalHex:    "6672696461",
				ReplacementHex: "", // å°†åœ¨è¿è¡Œæ—¶è®¾ç½®
				Description:    "ä¿®æ”¹DLLæ ‡è¯†",
			},
		},
	}
}

// DetectFileType æ£€æµ‹æ–‡ä»¶ç±»å‹
func (bp *BinaryPatcher) DetectFileType(filePath string) (string, error) {
	data, err := os.ReadFile(filePath)
	if err != nil {
		return "", fmt.Errorf("è¯»å–æ–‡ä»¶å¤±è´¥: %w", err)
	}

	// æ£€æŸ¥æ–‡ä»¶å¤´å’Œå†…å®¹ç‰¹å¾
	fileName := strings.ToLower(filepath.Base(filePath))

	if strings.Contains(fileName, "frida-server") {
		return "frida-server", nil
	}
	if strings.Contains(fileName, "frida-gadget") || strings.Contains(fileName, "gadget") {
		return "frida-gadget", nil
	}
	if strings.HasSuffix(fileName, ".dll") && bytes.Contains(data, []byte("frida")) {
		return "frida.dll", nil
	}
	if strings.HasSuffix(fileName, ".so") && bytes.Contains(data, []byte("frida")) {
		return "libfrida.so", nil
	}
	if strings.HasSuffix(fileName, ".pyd") && bytes.Contains(data, []byte("frida")) {
		return "_frida.pyd", nil
	}

	// é€šè¿‡å†…å®¹æ£€æµ‹
	if bytes.Contains(data, []byte("frida$server")) {
		return "frida-server", nil
	}
	if bytes.Contains(data, []byte("frida$gadget")) {
		return "frida-gadget", nil
	}

	return "unknown", nil
}

// PatchFile ä¿®è¡¥æ–‡ä»¶
func (bp *BinaryPatcher) PatchFile(inputPath, outputPath string, patches []PatchInfo) error {
	// è¯»å–åŸæ–‡ä»¶
	data, err := os.ReadFile(inputPath)
	if err != nil {
		return fmt.Errorf("è¯»å–è¾“å…¥æ–‡ä»¶å¤±è´¥: %w", err)
	}

	// åˆ›å»ºå¤‡ä»½
	backupPath := inputPath + ".bak"
	if err := os.WriteFile(backupPath, data, 0644); err != nil {
		return fmt.Errorf("åˆ›å»ºå¤‡ä»½æ–‡ä»¶å¤±è´¥: %w", err)
	}

	// åº”ç”¨ä¿®è¡¥
	patchedData := make([]byte, len(data))
	copy(patchedData, data)

	for _, patch := range patches {
		if patch.OriginalHex == "" || patch.ReplacementHex == "" {
			continue
		}

		originalBytes, err := hex.DecodeString(patch.OriginalHex)
		if err != nil {
			return fmt.Errorf("è§£ç åŸå§‹åå…­è¿›åˆ¶å¤±è´¥: %w", err)
		}

		replacementBytes, err := hex.DecodeString(patch.ReplacementHex)
		if err != nil {
			return fmt.Errorf("è§£ç æ›¿æ¢åå…­è¿›åˆ¶å¤±è´¥: %w", err)
		}

		// æŸ¥æ‰¾å¹¶æ›¿æ¢
		patchedData = bytes.ReplaceAll(patchedData, originalBytes, replacementBytes)
	}

	// ä¿å­˜ä¿®è¡¥åçš„æ–‡ä»¶
	if err := os.WriteFile(outputPath, patchedData, 0755); err != nil {
		return fmt.Errorf("å†™å…¥è¾“å‡ºæ–‡ä»¶å¤±è´¥: %w", err)
	}

	return nil
}

// GenerateNamePatch ç”Ÿæˆåç§°ä¿®è¡¥ä¿¡æ¯
func (bp *BinaryPatcher) GenerateNamePatch(newName string) (string, error) {
	if len(newName) != 5 {
		return "", fmt.Errorf("åç§°å¿…é¡»æ˜¯5ä¸ªå­—ç¬¦")
	}

	// å°†æ–°åç§°è½¬æ¢ä¸ºåå…­è¿›åˆ¶ï¼Œå¹¶æ·»åŠ $serveråç¼€
	nameWithSuffix := newName + "$server"
	return hex.EncodeToString([]byte(nameWithSuffix)), nil
}

// GeneratePortPatch ç”Ÿæˆç«¯å£ä¿®è¡¥ä¿¡æ¯
func (bp *BinaryPatcher) GeneratePortPatch(port int) (string, string, error) {
	if port < 1024 || port > 65535 {
		return "", "", fmt.Errorf("ç«¯å£å·å¿…é¡»åœ¨1024-65535èŒƒå›´å†…")
	}

	// è¿™é‡Œéœ€è¦æ ¹æ®å…·ä½“çš„äºŒè¿›åˆ¶æ ¼å¼æ¥ç”Ÿæˆç«¯å£ä¿®è¡¥
	// è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„å®ç°ï¼Œå®é™…å¯èƒ½éœ€è¦æ›´å¤æ‚çš„é€»è¾‘
	originalPort := 27042 // é»˜è®¤ç«¯å£

	// ç”ŸæˆåŸå§‹ç«¯å£çš„åå…­è¿›åˆ¶è¡¨ç¤º
	originalHex := fmt.Sprintf("%04X", originalPort)
	// ç”Ÿæˆæ–°ç«¯å£çš„åå…­è¿›åˆ¶è¡¨ç¤º
	newHex := fmt.Sprintf("%04X", port)

	return originalHex, newHex, nil
}

// ValidateFile éªŒè¯æ–‡ä»¶
func (bp *BinaryPatcher) ValidateFile(filePath string) error {
	info, err := os.Stat(filePath)
	if err != nil {
		return fmt.Errorf("æ–‡ä»¶ä¸å­˜åœ¨: %w", err)
	}

	if info.IsDir() {
		return fmt.Errorf("è·¯å¾„æ˜¯ç›®å½•ï¼Œä¸æ˜¯æ–‡ä»¶")
	}

	if info.Size() == 0 {
		return fmt.Errorf("æ–‡ä»¶ä¸ºç©º")
	}

	return nil
}

// CalculateFileMD5 è®¡ç®—æ–‡ä»¶MD5
func (bp *BinaryPatcher) CalculateFileMD5(filePath string) (string, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return "", err
	}
	defer file.Close()

	hash := md5.New()
	if _, err := io.Copy(hash, file); err != nil {
		return "", err
	}

	return hex.EncodeToString(hash.Sum(nil)), nil
}

// GetFileInfo è·å–æ–‡ä»¶ä¿¡æ¯
func (bp *BinaryPatcher) GetFileInfo(filePath string) (map[string]interface{}, error) {
	info, err := os.Stat(filePath)
	if err != nil {
		return nil, err
	}

	md5Sum, err := bp.CalculateFileMD5(filePath)
	if err != nil {
		return nil, err
	}

	fileType, err := bp.DetectFileType(filePath)
	if err != nil {
		return nil, err
	}

	return map[string]interface{}{
		"name":     info.Name(),
		"size":     info.Size(),
		"mod_time": info.ModTime(),
		"md5":      md5Sum,
		"type":     fileType,
	}, nil
}

// SearchPattern åœ¨æ–‡ä»¶ä¸­æœç´¢æ¨¡å¼
func (bp *BinaryPatcher) SearchPattern(filePath, hexPattern string) ([]int64, error) {
	data, err := os.ReadFile(filePath)
	if err != nil {
		return nil, err
	}

	pattern, err := hex.DecodeString(hexPattern)
	if err != nil {
		return nil, fmt.Errorf("æ— æ•ˆçš„åå…­è¿›åˆ¶æ¨¡å¼: %w", err)
	}

	var positions []int64
	for i := 0; i <= len(data)-len(pattern); i++ {
		if bytes.Equal(data[i:i+len(pattern)], pattern) {
			positions = append(positions, int64(i))
		}
	}

	return positions, nil
}

```

`ui/internal/ui/download_tab.go`:

```go
package ui

import (
	"context"
	"fmt"
	"fridare-gui/internal/config"
	"fridare-gui/internal/core"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"time"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/widget"
)

// FixedWidthEntry å›ºå®šå®½åº¦çš„Entryç»„ä»¶
type FixedWidthEntry struct {
	widget.Entry
	fixedWidth float32
}

// NewFixedWidthEntry åˆ›å»ºå›ºå®šå®½åº¦çš„Entry
func NewFixedWidthEntry(width float32) *FixedWidthEntry {
	entry := &FixedWidthEntry{
		fixedWidth: width,
	}
	entry.ExtendBaseWidget(entry)
	return entry
}

// MinSize è¿”å›å›ºå®šçš„æœ€å°å°ºå¯¸
func (e *FixedWidthEntry) MinSize() fyne.Size {
	return fyne.NewSize(e.fixedWidth, 35)
}

// FixedWidthSelect å›ºå®šå®½åº¦çš„Selectç»„ä»¶
type FixedWidthSelect struct {
	widget.Select
	fixedWidth float32
}

// NewFixedWidthSelect åˆ›å»ºå›ºå®šå®½åº¦çš„Select
func NewFixedWidthSelect(options []string, width float32) *FixedWidthSelect {
	sel := &FixedWidthSelect{
		fixedWidth: width,
	}
	sel.Select.Options = options
	sel.ExtendBaseWidget(sel)
	return sel
}

// MinSize è¿”å›å›ºå®šçš„æœ€å°å°ºå¯¸
func (s *FixedWidthSelect) MinSize() fyne.Size {
	return fyne.NewSize(s.fixedWidth, 35)
}

// åˆ›å»ºæ ‡å‡†å­—ä½“å¤§å°çš„æ ‡ç­¾
func newStandardLabel(text string) *widget.Label {
	label := widget.NewLabel(text)
	// è®¾ç½®æ ‡å‡†æ–‡æœ¬æ ·å¼
	label.TextStyle = fyne.TextStyle{}
	return label
}

// åˆ›å»ºå°å·å­—ä½“çš„æ ‡ç­¾ï¼ˆç”¨äºè¯¦ç»†ä¿¡æ¯ï¼‰
func newSmallLabel(text string) *widget.Label {
	label := widget.NewLabel(text)
	label.TextStyle = fyne.TextStyle{}
	return label
}

// åˆ›å»ºç²—ä½“æ ‡ç­¾ï¼ˆç”¨äºæ–‡ä»¶åï¼‰
func newBoldLabel(text string) *widget.Label {
	label := widget.NewLabel(text)
	label.TextStyle = fyne.TextStyle{Bold: true}
	return label
}

// AssetInfo èµ„æºä¿¡æ¯
type AssetInfo struct {
	Asset      core.Asset
	Version    string
	Platform   string
	FileType   string
	SHA256     string
	Size       string
	UploadTime string
	Selected   bool
	// ä¸‹è½½çŠ¶æ€ç›¸å…³
	IsDownloading bool
	Progress      float64 // 0.0 - 1.0
	Speed         string
	Downloaded    string
	Status        string // "ç­‰å¾…", "ä¸‹è½½ä¸­", "å®Œæˆ", "å¤±è´¥"
	DownloadPath  string // ä¸‹è½½æ–‡ä»¶çš„å®Œæ•´è·¯å¾„
}

// DownloadTab ä¸‹è½½æ ‡ç­¾é¡µ
type DownloadTab struct {
	app          fyne.App
	config       *config.Config
	updateStatus StatusUpdater

	// UI ç»„ä»¶
	content        *fyne.Container
	versionSelect  *widget.Select
	customVersion  *FixedWidthEntry
	platformSelect *FixedWidthSelect
	assetList      *widget.List
	filterEntry    *FixedWidthEntry

	// å·¥å…·æ æ§ä»¶
	toolbarSelectAll *widget.Button
	toolbarInvertSel *widget.Button
	toolbarDownload  *widget.Button
	toolbarCancelSel *widget.Button
	toolbarStart     *widget.Button
	toolbarStop      *widget.Button

	// ä¸‹è½½æ§åˆ¶
	activeDownloads map[int]*DownloadTask // æ´»è·ƒä¸‹è½½ä»»åŠ¡

	// èµ„æºæ•°æ®
	currentAssets    []AssetInfo
	filteredAssets   []AssetInfo
	selectedAssets   map[int]bool
	currentSelection int // å½“å‰é€‰ä¸­çš„æ–‡ä»¶ç´¢å¼•

	// ä¸šåŠ¡ç»„ä»¶
	fridaClient *core.FridaClient
	versions    []core.FridaVersion
}

// DownloadTask ä¸‹è½½ä»»åŠ¡
type DownloadTask struct {
	AssetIndex int
	Progress   float64
	Speed      string
	Downloaded string
	Status     string
	Context    context.Context
	CancelFunc context.CancelFunc
}

// NewDownloadTab åˆ›å»ºä¸‹è½½æ ‡ç­¾é¡µ
func NewDownloadTab(app fyne.App, cfg *config.Config, statusUpdater StatusUpdater) *DownloadTab {
	dt := &DownloadTab{
		app:              app,
		config:           cfg,
		updateStatus:     statusUpdater,
		activeDownloads:  make(map[int]*DownloadTask),
		currentSelection: -1, // åˆå§‹åŒ–ä¸ºæ— é€‰æ‹©
	}

	// åˆ›å»º Frida å®¢æˆ·ç«¯ - ä¸ºä¸‹è½½è®¾ç½®æ›´é•¿çš„è¶…æ—¶æ—¶é—´
	downloadTimeout := time.Duration(cfg.Timeout*3) * time.Second // ä¸‹è½½è¶…æ—¶è®¾ä¸ºæ™®é€šè¶…æ—¶çš„3å€
	if downloadTimeout < 120*time.Second {
		downloadTimeout = 120 * time.Second // è‡³å°‘2åˆ†é’Ÿ
	}
	dt.fridaClient = core.NewFridaClient(cfg.Proxy, downloadTimeout)

	dt.setupUI()
	dt.loadVersions()

	return dt
}

// setupUI è®¾ç½®UI
func (dt *DownloadTab) setupUI() {
	// åˆå§‹åŒ–é€‰ä¸­çŠ¶æ€
	dt.selectedAssets = make(map[int]bool)

	// åˆ›å»ºé¡¶éƒ¨æ§åˆ¶åŒºåŸŸï¼ˆç‰ˆæœ¬é€‰æ‹© + å·¥å…·æ ï¼‰
	topSection := dt.createTopSection()

	// åˆ›å»ºæ–‡ä»¶åˆ—è¡¨åŒºåŸŸ
	listSection := dt.createFileList()

	// åˆ›å»ºçŠ¶æ€æ 
	statusSection := dt.createStatusBar()

	// ä¸»è¦å¸ƒå±€ï¼šé¡¶éƒ¨æ§åˆ¶ + æ–‡ä»¶åˆ—è¡¨ + çŠ¶æ€æ 
	dt.content = container.NewBorder(
		topSection,    // é¡¶éƒ¨
		statusSection, // åº•éƒ¨
		nil, nil,      // å·¦å³
		listSection, // ä¸­å¿ƒ
	)
}

// createTopSection åˆ›å»ºé¡¶éƒ¨æ§åˆ¶åŒºåŸŸï¼ˆåŒ…å«ç‰ˆæœ¬é€‰æ‹©å’Œå·¥å…·æ ï¼‰
func (dt *DownloadTab) createTopSection() *fyne.Container {
	// ç¬¬ä¸€è¡Œï¼šç‰ˆæœ¬å’Œå¹³å°é€‰æ‹©
	dt.versionSelect = widget.NewSelect([]string{"åŠ è½½ä¸­..."}, nil)
	dt.versionSelect.OnChanged = dt.onVersionChanged

	// ä½¿ç”¨å›ºå®šå®½åº¦çš„è‡ªå®šä¹‰ç‰ˆæœ¬è¾“å…¥æ¡†
	dt.customVersion = NewFixedWidthEntry(150)
	dt.customVersion.SetPlaceHolder("æˆ–æ‰‹åŠ¨è¾“å…¥ç‰ˆæœ¬å·")

	refreshBtn := widget.NewButton("åˆ·æ–°", func() {
		dt.loadVersions()
	})

	// å¹³å°é€‰æ‹© - ä½¿ç”¨å›ºå®šå®½åº¦çš„è‡ªå®šä¹‰Select
	platformOptions := make([]string, len(core.SupportedPlatforms)+1)
	platformOptions[0] = "All" // æ·»åŠ  All é€‰é¡¹ä½œä¸ºç¬¬ä¸€ä¸ªé€‰é¡¹
	for i, platform := range core.SupportedPlatforms {
		platformOptions[i+1] = platform.Name
	}
	dt.platformSelect = NewFixedWidthSelect(platformOptions, 120)
	dt.platformSelect.SetSelected("All") // é»˜è®¤é€‰æ‹© All
	dt.platformSelect.OnChanged = dt.onPlatformChanged

	// è¿‡æ»¤å™¨ - ä½¿ç”¨å›ºå®šå®½åº¦çš„è‡ªå®šä¹‰Entry
	dt.filterEntry = NewFixedWidthEntry(120)
	dt.filterEntry.SetPlaceHolder("è¿‡æ»¤æ–‡ä»¶å...")
	dt.filterEntry.OnChanged = dt.onFilterChanged

	// ç¬¬ä¸€è¡Œï¼šç‰ˆæœ¬å’Œå¹³å°æ§åˆ¶ - ä½¿ç”¨åˆ†ç»„å¸ƒå±€ç¡®ä¿æ¸…æ™°çš„ç»“æ„å’Œé—´è·
	versionSection := container.NewHBox(
		newStandardLabel("ç‰ˆæœ¬:"),
		dt.versionSelect,
		dt.customVersion,
		refreshBtn,
	)

	platformSection := container.NewHBox(
		newStandardLabel("å¹³å°:"),
		dt.platformSelect,
	)

	filterSection := container.NewHBox(
		newStandardLabel("è¿‡æ»¤:"),
		dt.filterEntry,
	)

	// ç¬¬ä¸€è¡Œï¼šç‰ˆæœ¬å’Œå¹³å°æ§åˆ¶ - ä½¿ç”¨åˆ†ç»„å¸ƒå±€ç¡®ä¿æ¸…æ™°çš„ç»“æ„å’Œé—´è·
	firstRow := container.NewHBox(
		versionSection,
		widget.NewSeparator(),
		platformSection,
		widget.NewSeparator(),
		filterSection,
	)

	// ç¬¬äºŒè¡Œï¼šæ–‡ä»¶æ“ä½œå·¥å…·æ 
	dt.toolbarSelectAll = widget.NewButton("å…¨é€‰", dt.selectAll)
	dt.toolbarSelectAll.Resize(fyne.NewSize(60, 35))

	dt.toolbarInvertSel = widget.NewButton("åé€‰", dt.invertSelection)
	dt.toolbarInvertSel.Resize(fyne.NewSize(60, 35))

	dt.toolbarDownload = widget.NewButton("ä¸‹è½½é€‰ä¸­", dt.startBatchDownload)
	dt.toolbarDownload.Importance = widget.HighImportance
	dt.toolbarDownload.Resize(fyne.NewSize(100, 35))
	dt.toolbarDownload.Disable()

	dt.toolbarCancelSel = widget.NewButton("å–æ¶ˆé€‰ä¸­", dt.clearSelection)
	dt.toolbarCancelSel.Resize(fyne.NewSize(80, 35))

	// ä¸‹è½½æ§åˆ¶æŒ‰é’® - ç§»é™¤æš‚åœåŠŸèƒ½ï¼Œåªä¿ç•™å¼€å§‹å’Œå–æ¶ˆ
	dt.toolbarStart = widget.NewButton("å¼€å§‹", dt.startSelectedDownloads)
	dt.toolbarStart.Resize(fyne.NewSize(60, 35))
	dt.toolbarStart.Disable()

	dt.toolbarStop = widget.NewButton("å–æ¶ˆ", dt.stopSelectedDownloads)
	dt.toolbarStop.Resize(fyne.NewSize(60, 35))
	dt.toolbarStop.Disable()

	secondRow := container.NewHBox(
		dt.toolbarSelectAll,
		dt.toolbarInvertSel,
		dt.toolbarDownload,
		dt.toolbarCancelSel,
		widget.NewSeparator(),
		dt.toolbarStart,
		dt.toolbarStop,
	)

	// å‚ç›´ç»„åˆä¸¤è¡Œ
	return container.NewVBox(
		firstRow,
		widget.NewSeparator(),
		secondRow,
	)
}

// createStatusBar åˆ›å»ºçŠ¶æ€æ 
func (dt *DownloadTab) createStatusBar() *fyne.Container {
	return container.NewHBox(
		newStandardLabel("å°±ç»ª"),
	)
}

// createFileList åˆ›å»ºæ–‡ä»¶åˆ—è¡¨
func (dt *DownloadTab) createFileList() *container.Scroll {
	// èµ„æºåˆ—è¡¨
	dt.assetList = widget.NewList(
		func() int {
			return len(dt.filteredAssets)
		},
		func() fyne.CanvasObject {
			check := widget.NewCheck("", nil)
			check.Resize(fyne.NewSize(20, 20))

			nameLabel := newBoldLabel("")
			nameLabel.Wrapping = fyne.TextWrapOff

			infoLabel := newSmallLabel("")

			// ä¸‹è½½è¿›åº¦æ¡ - ç´§å‡‘å‹
			progressBar := widget.NewProgressBar()
			progressBar.SetValue(0)
			progressBar.Hide()
			progressBar.Resize(fyne.NewSize(120, 18)) // é™åˆ¶è¿›åº¦æ¡å®½åº¦

			// æ§åˆ¶æŒ‰é’® - ç´§å‡‘å‹
			stopBtn := widget.NewButton("â¹", nil)
			stopBtn.Resize(fyne.NewSize(22, 18))
			stopBtn.Hide()

			// æ‰“å¼€æ–‡ä»¶ä½ç½®æŒ‰é’® - è¶…é“¾æ¥æ ·å¼
			openLocationBtn := widget.NewButton("ğŸ“ æ‰“å¼€ä½ç½®", nil)
			openLocationBtn.Resize(fyne.NewSize(80, 18))
			openLocationBtn.Hide()

			// çŠ¶æ€æ ‡ç­¾ - ç´§å‡‘å‹
			statusLabel := newSmallLabel("")
			statusLabel.Hide()

			// åˆ›å»ºæ–‡ä»¶åå’Œæ§åˆ¶åŒºåŸŸçš„å®¹å™¨
			fileNameContainer := container.NewHBox(nameLabel)

			controlsContainer := container.NewHBox(
				progressBar,
				statusLabel,
				stopBtn,
				openLocationBtn,
			)
			controlsContainer.Hide()

			// ç¬¬ä¸€è¡Œï¼šæ–‡ä»¶å + æ§åˆ¶åŒºåŸŸ - ä½¿ç”¨HBoxè€Œä¸æ˜¯Border
			firstRow := container.NewHBox(
				fileNameContainer,
				widget.NewSeparator(), // åˆ†éš”ç¬¦
				controlsContainer,
			)

			// æ•´ä¸ªå†…å®¹åŒºåŸŸ
			content := container.NewVBox(
				firstRow,
				infoLabel,
			)

			// æœ€ç»ˆé¡¹ç›®å®¹å™¨
			item := container.NewBorder(
				nil, nil, // top, bottom
				check, nil, // left, right
				content, // center
			)

			return item
		},
		func(id widget.ListItemID, obj fyne.CanvasObject) {
			if id >= len(dt.filteredAssets) {
				return
			}

			borderContainer := obj.(*fyne.Container)
			if len(borderContainer.Objects) < 2 {
				return
			}

			// æ‰¾åˆ°å„ä¸ªæ§ä»¶
			var check *widget.Check
			var content *fyne.Container

			for _, child := range borderContainer.Objects {
				if c, ok := child.(*widget.Check); ok {
					check = c
				} else if cont, ok := child.(*fyne.Container); ok {
					content = cont
				}
			}

			if check == nil || content == nil || len(content.Objects) < 2 {
				return
			}

			// è·å–å¸ƒå±€ç»“æ„
			firstRow := content.Objects[0].(*fyne.Container) // ç¬¬ä¸€è¡Œ
			infoLabel := content.Objects[1].(*widget.Label)  // è¯¦ç»†ä¿¡æ¯

			// ä»ç¬¬ä¸€è¡Œè·å–æ–‡ä»¶åå’Œæ§åˆ¶åŒºåŸŸ (HBox: nameContainer, separator, controlsContainer)
			fileNameContainer := firstRow.Objects[0].(*fyne.Container) // æ–‡ä»¶åå®¹å™¨
			controlsContainer := firstRow.Objects[2].(*fyne.Container) // æ§åˆ¶åŒºåŸŸ (è·³è¿‡åˆ†éš”ç¬¦)

			// è·å–å…·ä½“æ§ä»¶
			nameLabel := fileNameContainer.Objects[0].(*widget.Label)
			progressBar := controlsContainer.Objects[0].(*widget.ProgressBar)
			statusLabel := controlsContainer.Objects[1].(*widget.Label)
			stopBtn := controlsContainer.Objects[2].(*widget.Button)
			openLocationBtn := controlsContainer.Objects[3].(*widget.Button)

			asset := dt.filteredAssets[id]
			check.SetChecked(dt.selectedAssets[id])
			check.OnChanged = func(checked bool) {
				dt.selectedAssets[id] = checked
				dt.updateDownloadButton()
				dt.updateToolbarDownloadButtons() // æ›´æ–°å·¥å…·æ æŒ‰é’®çŠ¶æ€
			}

			// è®¾ç½®æ–‡ä»¶å
			nameLabel.SetText(asset.Asset.Name)

			// è®¾ç½®è¯¦ç»†ä¿¡æ¯
			info := fmt.Sprintf("å¹³å°: %s | ç±»å‹: %s | å¤§å°: %s | æ—¶é—´: %s",
				asset.Platform,
				asset.FileType,
				asset.Size,
				asset.UploadTime)
			infoLabel.SetText(info)

			// æ ¹æ®ä¸‹è½½çŠ¶æ€è®¾ç½®UI
			if asset.IsDownloading || asset.Status == "å®Œæˆ" || asset.Status == "å¤±è´¥" {
				// æ˜¾ç¤ºæ§åˆ¶åŒºåŸŸ
				controlsContainer.Show()
				progressBar.Show()
				progressBar.SetValue(asset.Progress)

				if asset.IsDownloading {
					// ä¸‹è½½ä¸­ï¼šæ˜¾ç¤ºå–æ¶ˆæŒ‰é’®
					stopBtn.Show()
					openLocationBtn.Hide()
					statusLabel.Show()
					statusLabel.SetText(fmt.Sprintf("%.1f%% - %s", asset.Progress*100, asset.Speed))

					stopBtn.SetText("å–æ¶ˆ")
					stopBtn.OnTapped = func() {
						dt.stopAssetDownload(id)
						dt.updateToolbarDownloadButtons() // æ›´æ–°å·¥å…·æ æŒ‰é’®çŠ¶æ€
					}
				} else if asset.Status == "å®Œæˆ" {
					// ä¸‹è½½å®Œæˆï¼šéšè—å¼€å§‹/å–æ¶ˆæŒ‰é’®ï¼Œæ˜¾ç¤ºæ‰“å¼€æ–‡ä»¶ä½ç½®æŒ‰é’®
					stopBtn.Hide()
					openLocationBtn.Show()
					statusLabel.Show()
					statusLabel.SetText("å®Œæˆ")

					openLocationBtn.OnTapped = func() {
						if asset.DownloadPath != "" {
							dt.openFileLocation(filepath.Base(asset.DownloadPath))
						} else {
							// å¤‡ç”¨æ–¹æ¡ˆï¼šä½¿ç”¨æ–‡ä»¶åæ„å»ºè·¯å¾„
							dt.openFileLocation(asset.Asset.Name)
						}
					}
				} else if asset.Status == "å¤±è´¥" {
					stopBtn.Hide()
					openLocationBtn.Hide()
					statusLabel.Show()
					statusLabel.SetText("å¤±è´¥")
				}
			} else {
				// éšè—æ§åˆ¶åŒºåŸŸï¼ŒèŠ‚çº¦ç©ºé—´
				controlsContainer.Hide()
			}
		},
	)

	// æ·»åŠ åˆ—è¡¨é€‰æ‹©å˜åŒ–ç›‘å¬å™¨
	dt.assetList.OnSelected = func(id widget.ListItemID) {
		// å½“é€‰æ‹©åˆ—è¡¨é¡¹æ—¶ï¼Œæ›´æ–°å½“å‰é€‰æ‹©ç´¢å¼•å’Œå·¥å…·æ æŒ‰é’®çŠ¶æ€
		dt.currentSelection = int(id)
		dt.updateToolbarDownloadButtons()
	}

	dt.assetList.OnUnselected = func(id widget.ListItemID) {
		// å½“å–æ¶ˆé€‰æ‹©åˆ—è¡¨é¡¹æ—¶ï¼Œé‡ç½®é€‰æ‹©ç´¢å¼•å¹¶æ›´æ–°å·¥å…·æ æŒ‰é’®çŠ¶æ€
		dt.currentSelection = -1
		dt.updateToolbarDownloadButtons()
	}

	// ç»™åˆ—è¡¨æ·»åŠ æ»šåŠ¨
	return container.NewScroll(dt.assetList)
}

// onVersionChanged ç‰ˆæœ¬é€‰æ‹©æ”¹å˜äº‹ä»¶
func (dt *DownloadTab) onVersionChanged(selected string) {
	dt.loadAssetsForVersion(selected)
}

// onPlatformChanged å¹³å°é€‰æ‹©æ”¹å˜äº‹ä»¶
func (dt *DownloadTab) onPlatformChanged(selected string) {
	dt.filterAssets()
}

// onFilterChanged è¿‡æ»¤å™¨æ”¹å˜äº‹ä»¶
func (dt *DownloadTab) onFilterChanged(text string) {
	dt.filterAssets()
}

// clearSelection æ¸…é™¤é€‰æ‹©
func (dt *DownloadTab) clearSelection() {
	for i := range dt.filteredAssets {
		dt.selectedAssets[i] = false
	}
	fyne.Do(func() {
		dt.assetList.Refresh()
	})
	dt.updateToolbarButtons()
}

// updateToolbarButtons æ›´æ–°å·¥å…·æ æŒ‰é’®çŠ¶æ€
func (dt *DownloadTab) updateToolbarButtons() {
	hasSelected := false
	for _, selected := range dt.selectedAssets {
		if selected {
			hasSelected = true
			break
		}
	}

	if hasSelected {
		dt.toolbarDownload.Enable()
	} else {
		dt.toolbarDownload.Disable()
	}
}

// stopAssetDownload åœæ­¢å•ä¸ªèµ„æºä¸‹è½½
func (dt *DownloadTab) stopAssetDownload(assetIndex int) {
	if task, exists := dt.activeDownloads[assetIndex]; exists {
		// ç«‹å³ä»æ´»è·ƒä»»åŠ¡ä¸­ç§»é™¤ï¼Œé˜²æ­¢goroutineç»§ç»­å¤„ç†
		delete(dt.activeDownloads, assetIndex)

		// å–æ¶ˆä¸Šä¸‹æ–‡
		if task.CancelFunc != nil {
			task.CancelFunc()
		}

		if assetIndex < len(dt.filteredAssets) {
			// è·å–ä¸‹è½½æ–‡ä»¶è·¯å¾„
			asset := dt.filteredAssets[assetIndex]
			downloadPath := filepath.Join(dt.config.DownloadDir, asset.Asset.Name)

			// ç«‹å³æ›´æ–°UIçŠ¶æ€
			dt.filteredAssets[assetIndex].Status = "å·²å–æ¶ˆ"
			dt.filteredAssets[assetIndex].IsDownloading = false
			dt.filteredAssets[assetIndex].Progress = 0
			dt.filteredAssets[assetIndex].Speed = ""
			dt.filteredAssets[assetIndex].Downloaded = ""

			fyne.Do(func() {
				dt.assetList.Refresh()
			})

			// å¼‚æ­¥åˆ é™¤éƒ¨åˆ†ä¸‹è½½çš„æ–‡ä»¶
			go func() {
				// ç­‰å¾…ä¸€å°æ®µæ—¶é—´è®©æ–‡ä»¶å¥æŸ„é‡Šæ”¾
				time.Sleep(100 * time.Millisecond)

				// å°è¯•åˆ é™¤æ–‡ä»¶
				if err := os.Remove(downloadPath); err != nil {
					// å¦‚æœåˆ é™¤å¤±è´¥ï¼Œå°è¯•å¤šæ¬¡
					for i := 0; i < 3; i++ {
						time.Sleep(500 * time.Millisecond)
						if err := os.Remove(downloadPath); err == nil {
							break
						}
					}
				}

				// 1ç§’åé‡ç½®ä¸ºç­‰å¾…çŠ¶æ€
				time.Sleep(1 * time.Second)
				if assetIndex < len(dt.filteredAssets) {
					dt.filteredAssets[assetIndex].Status = "ç­‰å¾…"
					fyne.Do(func() {
						dt.assetList.Refresh()
					})
				}
			}()
		}

		dt.updateStatus("ä¸‹è½½å·²å–æ¶ˆ")
	}
}

// selectAll å…¨é€‰
func (dt *DownloadTab) selectAll() {
	for i := range dt.filteredAssets {
		dt.selectedAssets[i] = true
	}
	fyne.Do(func() {
		dt.assetList.Refresh()
	})
	dt.updateDownloadButton()
}

// invertSelection åé€‰
func (dt *DownloadTab) invertSelection() {
	for i := range dt.filteredAssets {
		dt.selectedAssets[i] = !dt.selectedAssets[i]
	}
	fyne.Do(func() {
		dt.assetList.Refresh()
	})
	dt.updateDownloadButton()
}

// updateDownloadButton æ›´æ–°ä¸‹è½½æŒ‰é’®çŠ¶æ€ï¼ˆä¿æŒå…¼å®¹æ€§ï¼‰
func (dt *DownloadTab) updateDownloadButton() {
	dt.updateToolbarButtons()
}

// loadAssetsForVersion ä¸ºæŒ‡å®šç‰ˆæœ¬åŠ è½½èµ„æº
func (dt *DownloadTab) loadAssetsForVersion(versionName string) {
	var selectedVersion *core.FridaVersion
	for _, version := range dt.versions {
		if version.Version == versionName {
			selectedVersion = &version
			break
		}
	}

	if selectedVersion == nil {
		dt.currentAssets = []AssetInfo{}
		dt.filterAssets()
		return
	}

	// è½¬æ¢èµ„æºä¸ºAssetInfo
	dt.currentAssets = make([]AssetInfo, 0, len(selectedVersion.Assets))
	for _, asset := range selectedVersion.Assets {
		// è§£ææ–‡ä»¶åä»¥ç¡®å®šå¹³å°å’Œæ–‡ä»¶ç±»å‹
		platform, fileType := dt.parseAssetInfo(asset.Name)

		assetInfo := AssetInfo{
			Asset:         asset,
			Version:       selectedVersion.Version,
			Platform:      platform,
			FileType:      fileType,
			SHA256:        "è®¡ç®—ä¸­...", // è¿™é‡Œå¯ä»¥åç»­ä»GitHub APIè·å–
			Size:          core.FormatSize(asset.Size),
			UploadTime:    selectedVersion.Published.Format("2006-01-02"),
			Selected:      false,
			IsDownloading: false,
			Progress:      0.0,
			Speed:         "",
			Downloaded:    "",
			Status:        "ç­‰å¾…",
		}
		dt.currentAssets = append(dt.currentAssets, assetInfo)
	}

	dt.filterAssets()
}

// parseAssetInfo è§£æèµ„æºæ–‡ä»¶åè·å–å¹³å°å’Œæ–‡ä»¶ç±»å‹ä¿¡æ¯
func (dt *DownloadTab) parseAssetInfo(filename string) (platform, fileType string) {
	// ç®€å•çš„æ–‡ä»¶åè§£æé€»è¾‘
	lower := strings.ToLower(filename)

	// ç¡®å®šæ–‡ä»¶ç±»å‹
	if strings.Contains(lower, "server") {
		fileType = "frida-server"
	} else if strings.Contains(lower, "gadget") {
		fileType = "frida-gadget"
	} else if strings.Contains(lower, "tools") || strings.Contains(lower, ".whl") {
		fileType = "frida-tools"
	} else {
		fileType = "å…¶ä»–"
	}

	// ç¡®å®šå¹³å°
	if strings.Contains(lower, "android") {
		if strings.Contains(lower, "arm64") {
			platform = "Android ARM64"
		} else if strings.Contains(lower, "arm") {
			platform = "Android ARM"
		} else if strings.Contains(lower, "x86_64") {
			platform = "Android x86_64"
		} else if strings.Contains(lower, "x86") {
			platform = "Android x86"
		} else {
			platform = "Android"
		}
	} else if strings.Contains(lower, "ios") {
		platform = "iOS ARM64"
	} else if strings.Contains(lower, "windows") {
		if strings.Contains(lower, "x86_64") || strings.Contains(lower, "amd64") {
			platform = "Windows x64"
		} else {
			platform = "Windows x86"
		}
	} else if strings.Contains(lower, "linux") {
		if strings.Contains(lower, "arm64") {
			platform = "Linux ARM64"
		} else {
			platform = "Linux x64"
		}
	} else if strings.Contains(lower, "macos") || strings.Contains(lower, "darwin") {
		if strings.Contains(lower, "arm64") {
			platform = "macOS ARM64"
		} else {
			platform = "macOS x64"
		}
	} else {
		platform = "é€šç”¨"
	}

	return platform, fileType
}

// filterAssets è¿‡æ»¤èµ„æº
func (dt *DownloadTab) filterAssets() {
	if dt.assetList == nil {
		return // å¦‚æœåˆ—è¡¨è¿˜æ²¡åˆå§‹åŒ–ï¼Œç›´æ¥è¿”å›
	}

	platformFilter := dt.platformSelect.Selected
	textFilter := strings.ToLower(dt.filterEntry.Text)

	dt.filteredAssets = []AssetInfo{}
	dt.selectedAssets = make(map[int]bool)
	dt.currentSelection = -1 // é‡ç½®å½“å‰é€‰æ‹©

	filteredIndex := 0
	for _, asset := range dt.currentAssets {
		// å¹³å°è¿‡æ»¤ - å¦‚æœé€‰æ‹© "All" åˆ™ä¸è¿›è¡Œå¹³å°è¿‡æ»¤
		if platformFilter != "" && platformFilter != "All" && asset.Platform != platformFilter && asset.Platform != "é€šç”¨" {
			continue
		}

		// æ–‡æœ¬è¿‡æ»¤
		if textFilter != "" && !strings.Contains(strings.ToLower(asset.Asset.Name), textFilter) {
			continue
		}

		dt.filteredAssets = append(dt.filteredAssets, asset)
		dt.selectedAssets[filteredIndex] = false
		filteredIndex++
	}

	fyne.Do(func() {
		dt.assetList.Refresh()
	})
	dt.updateDownloadButton()
	dt.updateToolbarDownloadButtons()
}

// startBatchDownload å¼€å§‹æ‰¹é‡ä¸‹è½½
func (dt *DownloadTab) startBatchDownload() {
	// æ”¶é›†é€‰ä¸­çš„èµ„æº
	var selectedAssets []int // å­˜å‚¨é€‰ä¸­èµ„æºçš„ç´¢å¼•
	for i, selected := range dt.selectedAssets {
		if selected && i < len(dt.filteredAssets) {
			selectedAssets = append(selectedAssets, i)
		}
	}

	if len(selectedAssets) == 0 {
		dt.updateStatus("è¯·é€‰æ‹©è¦ä¸‹è½½çš„æ–‡ä»¶")
		return
	}

	// ç¦ç”¨ä¸‹è½½æŒ‰é’®
	dt.toolbarDownload.Disable()
	dt.updateStatus(fmt.Sprintf("å¼€å§‹æ‰¹é‡ä¸‹è½½ %d ä¸ªæ–‡ä»¶...", len(selectedAssets)))

	// ä¸ºæ¯ä¸ªé€‰ä¸­çš„æ–‡ä»¶å¼€å§‹ä¸‹è½½
	for _, assetIndex := range selectedAssets {
		dt.startSingleDownload(assetIndex)
	}
}

// startSingleDownload å¼€å§‹å•ä¸ªæ–‡ä»¶ä¸‹è½½
func (dt *DownloadTab) startSingleDownload(assetIndex int) {
	if assetIndex >= len(dt.filteredAssets) {
		return
	}

	// æ›´æ–°èµ„æºçŠ¶æ€
	dt.filteredAssets[assetIndex].Status = "ä¸‹è½½ä¸­"
	dt.filteredAssets[assetIndex].IsDownloading = true
	dt.filteredAssets[assetIndex].Progress = 0.0

	// åˆ·æ–°UI
	fyne.DoAndWait(func() {
		dt.assetList.Refresh()
	})

	// åˆ›å»ºå¸¦å–æ¶ˆåŠŸèƒ½çš„ä¸Šä¸‹æ–‡
	ctx, cancel := context.WithCancel(context.Background())

	// åˆ›å»ºä¸‹è½½ä»»åŠ¡
	task := &DownloadTask{
		AssetIndex: assetIndex,
		Progress:   0.0,
		Status:     "ä¸‹è½½ä¸­",
		Context:    ctx,
		CancelFunc: cancel,
	}
	dt.activeDownloads[assetIndex] = task

	go func() {
		defer cancel() // ç¡®ä¿goroutineç»“æŸæ—¶å–æ¶ˆä¸Šä¸‹æ–‡

		asset := dt.filteredAssets[assetIndex]

		// ç¡®ä¿ä¸‹è½½ç›®å½•å­˜åœ¨
		if err := dt.config.EnsureDownloadDir(); err != nil {
			dt.updateStatus(fmt.Sprintf("åˆ›å»ºä¸‹è½½ç›®å½•å¤±è´¥: %v", err))
			dt.filteredAssets[assetIndex].Status = "å¤±è´¥"
			dt.assetList.Refresh()
			return
		}

		// æ„å»ºä¸‹è½½è·¯å¾„
		downloadPath := filepath.Join(dt.config.DownloadDir, asset.Asset.Name)

		// ä¸‹è½½æ–‡ä»¶ï¼Œå¸¦è¿›åº¦å›è°ƒå’Œå–æ¶ˆæ”¯æŒ
		err := dt.fridaClient.DownloadFileWithContext(ctx, asset.Asset.DownloadURL, downloadPath, func(downloaded, total int64, speed float64) {
			// æ›´æ–°è¿›åº¦
			if total > 0 {
				progress := float64(downloaded) / float64(total)
				dt.filteredAssets[assetIndex].Progress = progress
				dt.filteredAssets[assetIndex].Speed = core.FormatSpeed(speed)
				dt.filteredAssets[assetIndex].Downloaded = core.FormatSize(downloaded)

				// åˆ·æ–°UI
				fyne.Do(func() {
					dt.assetList.Refresh()
				})
			}
		})

		// ä¸‹è½½å®Œæˆå¤„ç†
		if err != nil {
			// æ£€æŸ¥ä»»åŠ¡æ˜¯å¦è¿˜å­˜åœ¨ï¼ˆå¯èƒ½å·²è¢«ç”¨æˆ·å–æ¶ˆï¼‰
			if _, exists := dt.activeDownloads[assetIndex]; !exists {
				// ä»»åŠ¡å·²è¢«å–æ¶ˆï¼Œä¸éœ€è¦æ›´æ–°çŠ¶æ€
				return
			}

			if ctx.Err() == context.Canceled {
				dt.updateStatus(fmt.Sprintf("ä¸‹è½½å·²å–æ¶ˆ: %s", asset.Asset.Name))
				dt.filteredAssets[assetIndex].Status = "å·²å–æ¶ˆ"
			} else {
				dt.updateStatus(fmt.Sprintf("ä¸‹è½½å¤±è´¥ %s: %v", asset.Asset.Name, err))
				dt.filteredAssets[assetIndex].Status = "å¤±è´¥"
			}
		} else {
			// æ£€æŸ¥ä»»åŠ¡æ˜¯å¦è¿˜å­˜åœ¨ï¼ˆå¯èƒ½å·²è¢«ç”¨æˆ·å–æ¶ˆï¼‰
			if _, exists := dt.activeDownloads[assetIndex]; !exists {
				// ä»»åŠ¡å·²è¢«å–æ¶ˆï¼Œåˆ é™¤å·²ä¸‹è½½çš„æ–‡ä»¶
				os.Remove(downloadPath)
				return
			}

			dt.updateStatus(fmt.Sprintf("ä¸‹è½½å®Œæˆ: %s", asset.Asset.Name))
			dt.filteredAssets[assetIndex].Status = "å®Œæˆ"
			dt.filteredAssets[assetIndex].Progress = 1.0
			dt.filteredAssets[assetIndex].DownloadPath = downloadPath // ä¿å­˜ä¸‹è½½è·¯å¾„

			// æ›´æ–°æœ€è¿‘ä½¿ç”¨
			dt.config.AddRecentVersion(asset.Version)
			dt.config.Save()
		}

		// æ¸…ç†ä»»åŠ¡ï¼ˆåªæœ‰ä»»åŠ¡è¿˜å­˜åœ¨æ—¶æ‰æ¸…ç†ï¼‰
		if _, exists := dt.activeDownloads[assetIndex]; exists {
			delete(dt.activeDownloads, assetIndex)
			dt.filteredAssets[assetIndex].IsDownloading = false
			fyne.DoAndWait(func() {
				dt.assetList.Refresh()
			})

			// é‡æ–°å¯ç”¨ä¸‹è½½æŒ‰é’®
			dt.toolbarDownload.Enable()
		}
	}()
}

// loadVersions åŠ è½½ç‰ˆæœ¬åˆ—è¡¨
func (dt *DownloadTab) loadVersions() {
	dt.updateStatus("æ­£åœ¨è·å–ç‰ˆæœ¬åˆ—è¡¨...")
	dt.versionSelect.SetOptions([]string{"åŠ è½½ä¸­..."})
	dt.versionSelect.Disable()

	go func() {
		versions, err := dt.fridaClient.GetVersions()

		// åœ¨ä¸»çº¿ç¨‹ä¸­æ›´æ–°UIï¼Œä½¿ç”¨fyne.Doé¿å…çº¿ç¨‹è­¦å‘Š
		fyne.Do(func() {
			if err != nil {
				dt.versionSelect.SetOptions([]string{"è·å–å¤±è´¥"})
				dt.versionSelect.Enable()
				dt.updateStatus(fmt.Sprintf("è·å–ç‰ˆæœ¬åˆ—è¡¨å¤±è´¥: %v", err))
				return
			}

			dt.versions = versions

			// æå–ç‰ˆæœ¬å­—ç¬¦ä¸²
			versionStrings := make([]string, len(versions))
			for i, version := range versions {
				versionStrings[i] = version.Version
			}

			// æ›´æ–°UIæ§ä»¶é€‰é¡¹
			dt.versionSelect.SetOptions(versionStrings)
			dt.versionSelect.Enable()

			// å¦‚æœæœ‰ç‰ˆæœ¬ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ª
			if len(versionStrings) > 0 {
				dt.versionSelect.SetSelected(versionStrings[0])
				dt.loadAssetsForVersion(versionStrings[0])
			}

			dt.updateStatus(fmt.Sprintf("æˆåŠŸåŠ è½½ %d ä¸ªç‰ˆæœ¬", len(versions)))
		})
	}()
}

// Content è¿”å›æ ‡ç­¾é¡µå†…å®¹
func (dt *DownloadTab) Content() *fyne.Container {
	return dt.content
}

// Refresh åˆ·æ–°æ ‡ç­¾é¡µ
func (dt *DownloadTab) Refresh() {
	dt.loadVersions()
}

// startSelectedDownloads å¼€å§‹å½“å‰é€‰ä¸­çš„ä¸‹è½½ä»»åŠ¡
func (dt *DownloadTab) startSelectedDownloads() {
	// åªå¤„ç†å½“å‰é«˜äº®é€‰ä¸­çš„æ–‡ä»¶
	if dt.currentSelection >= 0 && dt.currentSelection < len(dt.filteredAssets) {
		if !dt.filteredAssets[dt.currentSelection].IsDownloading {
			dt.startAssetDownload(dt.currentSelection)
		}
	}
	dt.updateToolbarDownloadButtons()
}

// startAssetDownload å¼€å§‹æŒ‡å®šèµ„æºçš„ä¸‹è½½
func (dt *DownloadTab) startAssetDownload(assetIndex int) {
	// æ£€æŸ¥ç´¢å¼•æœ‰æ•ˆæ€§
	if assetIndex < 0 || assetIndex >= len(dt.filteredAssets) {
		dt.updateStatus("æ— æ•ˆçš„æ–‡ä»¶ç´¢å¼•")
		return
	}

	// æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨ä¸‹è½½ä¸­
	if dt.filteredAssets[assetIndex].IsDownloading {
		dt.updateStatus("è¯¥æ–‡ä»¶æ­£åœ¨ä¸‹è½½ä¸­")
		return
	}

	// å¦‚æœæ–‡ä»¶å·²å®Œæˆä¸‹è½½ï¼Œè¯¢é—®æ˜¯å¦é‡æ–°ä¸‹è½½
	if dt.filteredAssets[assetIndex].Status == "å®Œæˆ" {
		dt.updateStatus("æ–‡ä»¶å·²ä¸‹è½½å®Œæˆï¼Œæ­£åœ¨é‡æ–°ä¸‹è½½...")
		// é‡ç½®çŠ¶æ€
		dt.filteredAssets[assetIndex].Status = "ç­‰å¾…"
		dt.filteredAssets[assetIndex].Progress = 0.0
	}

	// å¼€å§‹å•ä¸ªæ–‡ä»¶ä¸‹è½½
	dt.startSingleDownload(assetIndex)

	// æ›´æ–°çŠ¶æ€æ¶ˆæ¯
	asset := dt.filteredAssets[assetIndex]
	dt.updateStatus(fmt.Sprintf("å¼€å§‹ä¸‹è½½: %s", asset.Asset.Name))
}

// stopSelectedDownloads åœæ­¢å½“å‰é€‰ä¸­çš„ä¸‹è½½ä»»åŠ¡
func (dt *DownloadTab) stopSelectedDownloads() {
	// åªå¤„ç†å½“å‰é«˜äº®é€‰ä¸­çš„æ–‡ä»¶
	if dt.currentSelection >= 0 && dt.currentSelection < len(dt.filteredAssets) {
		if dt.filteredAssets[dt.currentSelection].IsDownloading {
			dt.stopAssetDownload(dt.currentSelection)
		}
	}
	dt.updateToolbarDownloadButtons()
}

// updateToolbarDownloadButtons æ›´æ–°å·¥å…·æ ä¸‹è½½æ§åˆ¶æŒ‰é’®çŠ¶æ€
func (dt *DownloadTab) updateToolbarDownloadButtons() {
	hasActive := false
	hasSelected := false

	// åªæ£€æŸ¥å½“å‰é«˜äº®é€‰ä¸­çš„æ–‡ä»¶çŠ¶æ€
	if dt.currentSelection >= 0 && dt.currentSelection < len(dt.filteredAssets) {
		hasSelected = true
		asset := dt.filteredAssets[dt.currentSelection]
		if asset.IsDownloading {
			hasActive = true
		}
	}

	// å¼€å§‹æŒ‰é’®ï¼šåªæœ‰åœ¨é€‰ä¸­æ–‡ä»¶ä¸”æ²¡æœ‰ä¸‹è½½ä¸”æœªå®Œæˆæ—¶æ‰å¯ç”¨
	if hasSelected && !hasActive {
		asset := dt.filteredAssets[dt.currentSelection]
		if asset.Status != "å®Œæˆ" {
			dt.toolbarStart.Enable()
			dt.toolbarStart.SetText("å¼€å§‹")
		} else {
			dt.toolbarStart.Disable()
			dt.toolbarStart.SetText("å·²å®Œæˆ")
		}
	} else {
		dt.toolbarStart.Disable()
		dt.toolbarStart.SetText("å¼€å§‹")
	}

	// å–æ¶ˆæŒ‰é’®ï¼šåªæœ‰åœ¨æœ‰æ´»è·ƒä¸‹è½½æ—¶æ‰å¯ç”¨
	if hasActive {
		dt.toolbarStop.Enable()
		dt.toolbarStop.SetText("å–æ¶ˆ")
	} else {
		dt.toolbarStop.Disable()
		dt.toolbarStop.SetText("å–æ¶ˆ")
	}
}

// openFileLocation æ‰“å¼€æ–‡ä»¶åœ¨æ–‡ä»¶ç®¡ç†å™¨ä¸­çš„ä½ç½®
func (dt *DownloadTab) openFileLocation(filename string) {
	if dt.config == nil {
		return
	}

	downloadPath := filepath.Join(dt.config.DownloadDir, filename)

	// æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
	if _, err := os.Stat(downloadPath); os.IsNotExist(err) {
		dt.updateStatus(fmt.Sprintf("æ–‡ä»¶ä¸å­˜åœ¨: %s", filename))
		return
	}

	// æ ¹æ®æ“ä½œç³»ç»Ÿæ‰“å¼€æ–‡ä»¶ç®¡ç†å™¨
	var cmd *exec.Cmd
	switch {
	case strings.Contains(strings.ToLower(runtime.GOOS), "windows"):
		cmd = exec.Command("explorer", "/select,", downloadPath)
	case strings.Contains(strings.ToLower(runtime.GOOS), "darwin"):
		cmd = exec.Command("open", "-R", downloadPath)
	default: // Linux
		cmd = exec.Command("xdg-open", filepath.Dir(downloadPath))
	}

	if err := cmd.Start(); err != nil {
		dt.updateStatus(fmt.Sprintf("æ— æ³•æ‰“å¼€æ–‡ä»¶ä½ç½®: %v", err))
	} else {
		dt.updateStatus(fmt.Sprintf("å·²æ‰“å¼€æ–‡ä»¶ä½ç½®: %s", filename))
	}
}

```

`ui/internal/ui/main_window.go`:

```go
package ui

import (
	"fmt"
	"fridare-gui/internal/assets"
	"fridare-gui/internal/config"
	"fridare-gui/internal/utils"
	"log"
	"strconv"
	"strings"
	"time"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/canvas"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/theme"
	"fyne.io/fyne/v2/widget"
)

const (
	WindowMinWidth  = 1200
	WindowMinHeight = 800
)

// LogEntry è‡ªå®šä¹‰æ—¥å¿—ç»„ä»¶ - æ¨¡æ‹Ÿç»ˆç«¯æ ·å¼
type LogEntry struct {
	*widget.RichText
	logContent string
}

// NewLogEntry åˆ›å»ºæ–°çš„æ—¥å¿—ç»„ä»¶
func NewLogEntry() *LogEntry {
	richText := widget.NewRichText()
	richText.Wrapping = fyne.TextWrapWord
	richText.Scroll = container.ScrollBoth

	log := &LogEntry{
		RichText:   richText,
		logContent: "",
	}

	// è®¾ç½®åˆå§‹æ ·å¼å’ŒèƒŒæ™¯æç¤º
	log.updateContent()

	return log
}

// updateContent æ›´æ–°å†…å®¹å¹¶è®¾ç½®æ ·å¼
func (l *LogEntry) updateContent() {
	if l.logContent == "" {
		l.logContent = "ğŸ“‹ æ—¥å¿—è¾“å‡ºåŒºåŸŸ (æ¨¡æ‹Ÿç»ˆç«¯æ ·å¼)\n"
	}

	// ä½¿ç”¨ä»£ç å—æ ·å¼æ¥æ¨¡æ‹Ÿç»ˆç«¯å¤–è§‚
	l.RichText.ParseMarkdown("```\n" + l.logContent + "\n```")
}

// SetLogText è®¾ç½®æ—¥å¿—æ–‡æœ¬
func (l *LogEntry) SetLogText(text string) {
	l.logContent = text
	l.updateContent()
}

// AppendLogText è¿½åŠ æ—¥å¿—æ–‡æœ¬
func (l *LogEntry) AppendLogText(text string) {
	l.logContent += text
	l.updateContent()
}

// String è·å–å½“å‰æ–‡æœ¬å†…å®¹
func (l *LogEntry) String() string {
	return l.logContent
}

// MainWindow ä¸»çª—å£ç»“æ„
type MainWindow struct {
	app    fyne.App
	window fyne.Window
	config *config.Config

	// UI ç»„ä»¶
	content      *fyne.Container
	tabContainer *container.AppTabs
	statusBar    *widget.Label
	logText      *LogEntry // æ”¹ä¸ºè‡ªå®šä¹‰æ—¥å¿—ç»„ä»¶

	// å·¥å…·æ ä»£ç†é…ç½®æ§ä»¶
	proxyEntry *FixedWidthEntry

	// å…¨å±€é…ç½®æ§ä»¶
	globalMagicNameEntry *FixedWidthEntry
	globalPortEntry      *FixedWidthEntry

	// åŠŸèƒ½æ¨¡å—
	downloadTab *DownloadTab
	modifyTab   *ModifyTab
	packageTab  *PackageTab
	createTab   *CreateTab // æ–°å¢åˆ›å»ºæ ‡ç­¾é¡µ
	toolsTab    *ToolsTab
	settingsTab *SettingsTab
	helpTab     *HelpTab     // æ–°å¢å¸®åŠ©æ ‡ç­¾é¡µ
	analysisTab *AnalysisTab // æ–°å¢åˆ†ææ ‡ç­¾é¡µ
}

// NewMainWindow åˆ›å»ºä¸»çª—å£
func NewMainWindow(app fyne.App, cfg *config.Config) *MainWindow {
	// åˆ›å»ºçª—å£
	window := app.NewWindow("Fridare GUI - Frida é­”æ”¹å·¥å…·")
	window.SetMaster()
	window.SetIcon(assets.AppIcon) // è®¾ç½®çª—å£å›¾æ ‡

	// è®¾ç½®çª—å£å¤§å°
	window.Resize(fyne.NewSize(float32(cfg.WindowWidth), float32(cfg.WindowHeight)))
	window.SetFixedSize(false)

	// è®¾ç½®æœ€å°å°ºå¯¸
	window.SetContent(widget.NewLabel("Loading..."))

	// è®¾ç½®çª—å£æœ€å°å°ºå¯¸
	if cfg.WindowWidth < WindowMinWidth {
		cfg.WindowWidth = WindowMinWidth
	}
	if cfg.WindowHeight < WindowMinHeight {
		cfg.WindowHeight = WindowMinHeight
	}

	mw := &MainWindow{
		app:    app,
		window: window,
		config: cfg,
	}

	// åˆå§‹åŒ–UI
	mw.setupUI()

	// åº”ç”¨ä¸»é¢˜
	mw.applyTheme()

	// æ˜¾ç¤ºé€šçŸ¥
	mw.showNoticeAsync()

	return mw
}

// setupUI è®¾ç½®UI
func (mw *MainWindow) setupUI() {
	// åˆ›å»ºåŠŸèƒ½æ ‡ç­¾é¡µ
	mw.tabContainer = container.NewAppTabs()

	// åˆ›å»ºå„ä¸ªåŠŸèƒ½æ¨¡å—
	mw.downloadTab = NewDownloadTab(mw.app, mw.config, mw.updateStatus)
	mw.modifyTab = NewModifyTab(mw.app, mw.config, mw.updateStatus, mw.addLog)
	mw.packageTab = NewPackageTab(mw.app, mw.config, mw.updateStatus, mw.addLog)
	mw.createTab = NewCreateTab(mw.app, mw.config, mw.updateStatus, mw.addLog) // æ–°å¢åˆ›å»ºæ ‡ç­¾é¡µ
	mw.toolsTab = NewToolsTab(mw.config, mw.updateStatus)
	mw.toolsTab.SetLogFunction(mw.addLog) // è®¾ç½®æ—¥å¿—å‡½æ•°
	mw.settingsTab = NewSettingsTab(mw.config, mw.updateStatus, mw.applyTheme, mw.window)
	mw.helpTab = NewHelpTab()                                                      // æ–°å¢å¸®åŠ©æ ‡ç­¾é¡µ
	mw.analysisTab = NewAnalysisTab(mw.app, mw.config, mw.updateStatus, mw.addLog) // æ–°å¢åˆ†ææ ‡ç­¾é¡µ

	// æ·»åŠ æ ‡ç­¾é¡µï¼ˆä¸åŸå‹ä¿æŒä¸€è‡´ï¼‰ï¼Œä¸ºæ¯ä¸ªtabæ·»åŠ æ»šåŠ¨æ”¯æŒ
	mw.tabContainer.Append(container.NewTabItem("ğŸ“¥ ä¸‹è½½",
		container.NewScroll(mw.downloadTab.Content())))
	mw.tabContainer.Append(container.NewTabItem("ğŸ”§ frida é­”æ”¹",
		container.NewScroll(mw.modifyTab.Content())))
	mw.tabContainer.Append(container.NewTabItem("ğŸ“¦ iOS DEB é­”æ”¹",
		container.NewScroll(mw.packageTab.Content())))
	mw.tabContainer.Append(container.NewTabItem("ğŸ†• iOS DEB æ‰“åŒ…",
		container.NewScroll(mw.createTab.Content()))) // æ–°å¢åˆ›å»ºæ ‡ç­¾é¡µ
	mw.tabContainer.Append(container.NewTabItem("ğŸ› ï¸ frida-tools é­”æ”¹",
		container.NewScroll(mw.toolsTab.Content())))
	mw.tabContainer.Append(container.NewTabItem("ğŸ”¬ æ–‡ä»¶åˆ†æ",
		container.NewScroll(mw.analysisTab.Content()))) // æ–°å¢åˆ†ææ ‡ç­¾é¡µ
	mw.tabContainer.Append(container.NewTabItem("âš™ï¸ è®¾ç½®",
		container.NewScroll(mw.settingsTab.Content()))) // è®¾ç½®æ ‡ç­¾é¡µ
	mw.tabContainer.Append(container.NewTabItem("â“ å¸®åŠ©",
		mw.helpTab.Content())) // å¸®åŠ©æ ‡ç­¾é¡µ - ä¸éœ€è¦æ»šåŠ¨åŒ…è£…å› ä¸ºå†…éƒ¨å·²å¤„ç†
	mw.tabContainer.OnSelected = func(tab *container.TabItem) {
		mw.updateStatus("åˆ‡æ¢åˆ°æ ‡ç­¾: " + tab.Text)
		// å¦‚æœå½“å‰æ ‡ç­¾æ˜¯è®¾ç½®æ ‡ç­¾é¡µï¼Œåˆ™åˆ·æ–°é…ç½®æ˜¾ç¤º
		if tab.Text == "âš™ï¸ è®¾ç½®" {
			mw.settingsTab.RefreshConfigDisplay()
		}
	}

	// åˆ›å»ºåº•éƒ¨çŠ¶æ€åŒºåŸŸï¼ˆåŒ…å«æ—¥å¿—å’ŒæŒ‰é’®ï¼‰
	bottomArea := mw.createBottomArea()

	// åˆ›å»ºé¡¶éƒ¨å·¥å…·æ 
	toolbar := mw.createToolbar()

	// åˆ›å»ºä¸»å¸ƒå±€ - ç®€åŒ–ä¸ºå‚ç›´å¸ƒå±€ï¼Œç§»é™¤å·¦ä¾§è¾¹æ 
	mw.content = container.NewBorder(
		toolbar,         // top
		bottomArea,      // bottom
		nil,             // left
		nil,             // right
		mw.tabContainer, // center
	)

	// è®¾ç½®çª—å£å†…å®¹
	mw.window.SetContent(mw.content)
}

// createToolbar åˆ›å»ºå·¥å…·æ 
func (mw *MainWindow) createToolbar() *fyne.Container {
	// Logoå›¾æ ‡ - ä½¿ç”¨canvas.Imageå¹¶è®¾ç½®å›ºå®šå¤§å°
	logoImage := canvas.NewImageFromResource(assets.AppIcon)
	logoImage.FillMode = canvas.ImageFillOriginal
	logoImage.Resize(fyne.NewSize(64, 64))
	logoImage.SetMinSize(fyne.NewSize(64, 64))

	// åº”ç”¨æ ‡é¢˜
	titleLabel := widget.NewLabel("Fridare GUI - Frida é­”æ”¹å·¥å…·")
	titleLabel.TextStyle = fyne.TextStyle{Bold: true}

	// ä»£ç†é…ç½® - ä½¿ç”¨å›ºå®šå®½åº¦çš„Entryï¼Œå‚è€ƒdownload_tabçš„å®ç°
	mw.proxyEntry = NewFixedWidthEntry(300)
	mw.proxyEntry.SetPlaceHolder("http://proxy:port (å¯é€‰)")
	if mw.config.Proxy != "" {
		mw.proxyEntry.SetText(mw.config.Proxy)
	}

	// ä»£ç†æµ‹è¯•æŒ‰é’®
	proxyTestBtn := widget.NewButtonWithIcon("", theme.SearchIcon(), func() {
		mw.testProxy()
	})
	proxyTestBtn.SetText("æµ‹è¯•")

	// ä¿å­˜ä»£ç†é…ç½®æŒ‰é’®
	proxySaveBtn := widget.NewButtonWithIcon("", theme.DocumentSaveIcon(), func() {
		mw.saveProxyConfig()
	})
	proxySaveBtn.SetText("ä¿å­˜")

	// å…¨å±€é­”æ”¹é…ç½®åŒºåŸŸ
	mw.globalMagicNameEntry = NewFixedWidthEntry(80)
	mw.globalMagicNameEntry.SetPlaceHolder("5å­—ç¬¦")
	if mw.config.MagicName != "" {
		mw.globalMagicNameEntry.SetText(mw.config.MagicName)
	} else {
		mw.globalMagicNameEntry.SetText("frida")
	}

	mw.globalPortEntry = NewFixedWidthEntry(60)
	mw.globalPortEntry.SetPlaceHolder("ç«¯å£")
	if mw.config.DefaultPort > 0 {
		mw.globalPortEntry.SetText(fmt.Sprintf("%d", mw.config.DefaultPort))
	} else {
		mw.globalPortEntry.SetText("27042")
	}

	// å…¨å±€é…ç½®éªŒè¯å’Œä¿å­˜
	mw.globalMagicNameEntry.OnChanged = func(text string) {
		if len(text) == 5 && isValidMagicName(text) {
			mw.updateGlobalMagicName(text)
		}
	}

	mw.globalPortEntry.OnChanged = func(text string) {
		if port, err := strconv.Atoi(text); err == nil && port > 0 && port <= 65535 {
			mw.updateGlobalPort(port)
		}
	}

	// éšæœºé­”æ”¹åç§°æŒ‰é’®
	randomMagicBtn := widget.NewButtonWithIcon("", theme.ViewRefreshIcon(), func() {
		randomName := utils.GenerateRandomName()
		mw.globalMagicNameEntry.SetText(randomName)
		mw.updateGlobalMagicName(randomName)
	})
	randomMagicBtn.SetText("éšæœº")

	// ä»£ç†é…ç½®åŒºåŸŸ - å‚è€ƒdownload_tabçš„å¸ƒå±€æ–¹å¼
	proxyArea := container.NewHBox(
		widget.NewLabel("ä»£ç†:"),
		mw.proxyEntry,
		proxyTestBtn,
		proxySaveBtn,
		widget.NewLabel("å…¨å±€é­”æ”¹:"),
		mw.globalMagicNameEntry,
		randomMagicBtn,
		widget.NewLabel("ç«¯å£:"),
		mw.globalPortEntry,
	)

	// å¸®åŠ©æŒ‰é’®
	helpBtn := widget.NewButtonWithIcon("", theme.InfoIcon(), func() {
		mw.showAbout()
	})
	logoTitle := container.NewHBox(
		logoImage,
		titleLabel) // å·¦ä¾§: Logo + Title
	// å·¥å…·æ å¸ƒå±€ - åˆ†ä¸¤è¡Œæ˜¾ç¤º
	topRow := container.NewBorder(
		nil, nil,
		logoTitle, // å·¦ä¾§: Logo + Title
		helpBtn,   // å³ä¾§: å¸®åŠ©æŒ‰é’®
		proxyArea, // ä¸­é—´: ä»£ç†é…ç½®
	)

	toolbar := container.NewVBox(topRow)

	return toolbar
}

// updateStatus æ›´æ–°çŠ¶æ€æ 
func (mw *MainWindow) updateStatus(message string) {
	if mw.statusBar != nil {
		fyne.Do(func() {
			mw.statusBar.SetText(message)
		})
	}
	// è®°å½•æ—¥å¿—ä½†ä¸ç«‹å³æ›´æ–°UI
	log.Println("STATUS:", message)
}

// saveProxyConfig ä¿å­˜ä»£ç†é…ç½®
func (mw *MainWindow) saveProxyConfig() {
	// æ›´æ–°é…ç½®
	mw.config.Proxy = mw.proxyEntry.Text

	// ä¿å­˜é…ç½®
	if err := mw.config.Save(); err != nil {
		mw.updateStatus("ä¿å­˜ä»£ç†é…ç½®å¤±è´¥: " + err.Error())
		mw.addLog("ERROR: ä¿å­˜ä»£ç†é…ç½®å¤±è´¥: " + err.Error())
	} else {
		mw.updateStatus("ä»£ç†é…ç½®å·²ä¿å­˜")
		mw.addLog("INFO: ä»£ç†é…ç½®å·²ä¿å­˜")
	}
}

// saveConfig ä¿å­˜é…ç½®
func (mw *MainWindow) saveConfig() {
	if err := mw.config.Save(); err != nil {
		mw.updateStatus("ä¿å­˜é…ç½®å¤±è´¥: " + err.Error())
		log.Printf("ä¿å­˜é…ç½®å¤±è´¥: %v", err)
	} else {
		mw.updateStatus("é…ç½®å·²ä¿å­˜")
	}
}

// applyTheme åº”ç”¨ä¸»é¢˜
func (mw *MainWindow) applyTheme() {
	switch mw.config.Theme {
	case "dark":
		mw.app.Settings().SetTheme(theme.DarkTheme())
	case "light":
		mw.app.Settings().SetTheme(theme.LightTheme())
	default:
		// auto - ä½¿ç”¨ç³»ç»Ÿé»˜è®¤
		mw.app.Settings().SetTheme(theme.DefaultTheme())
	}
}

// showAbout æ˜¾ç¤ºå…³äºå¯¹è¯æ¡†
func (mw *MainWindow) showAbout() {
	// åˆ›å»ºç®€å•çš„å¯¹è¯æ¡†å†…å®¹
	content := widget.NewLabel(`Fridare GUI v1.0.0

Frida é‡æ‰“åŒ…å’Œä¿®è¡¥å·¥å…·çš„å›¾å½¢ç•Œé¢ç‰ˆæœ¬

ç‰¹æ€§: ä¸‹è½½å‘è¡Œç‰ˆ, äºŒè¿›åˆ¶ä¿®è¡¥, DEBåŒ…ç”Ÿæˆ, å·¥å…·é›†æˆ

ä½œè€…: suifei@gmail.com
é¡¹ç›®: https://github.com/suifei/fridare`)

	content.Alignment = fyne.TextAlignCenter
	content.Wrapping = fyne.TextWrapWord

	// åˆ›å»ºå¯¹è¯æ¡†
	dialog := dialog.NewCustom("å…³äº Fridare GUI", "ç¡®å®š", content, mw.window)
	dialog.Resize(fyne.NewSize(400, 250))
	dialog.Show()
}

// showNotice æ˜¾ç¤ºé€šçŸ¥å¯¹è¯æ¡†
func (mw *MainWindow) showNotice() {
	// åˆ›å»ºç®€å•çš„å¯¹è¯æ¡†å†…å®¹, æ”¯æŒå¤šè¡Œæ–‡æœ¬å’Œmarkdown
	// é€šçŸ¥å†…å®¹ä» https://raw.githubusercontent.com/suifei/fridare/main/NOTICE.md è·å–
	// ç½‘ç»œè¯·æ±‚å¤±è´¥åˆ™ä¸æ˜¾ç¤º(è‡ªåŠ¨æŒ‚æ¥ä»£ç†)

	// ä»é…ç½®è·å–ä»£ç†ï¼Œå¦‚æœé…ç½®æ²¡æœ‰ï¼Œåˆ™å°è¯•è·å–ç³»ç»Ÿä»£ç†  ï¼Œå¦åˆ™ä¸ºâ€œâ€
	// ç³»ç»Ÿä»£ç†è·å–ï¼š
	// HTTPProxy:  getEnvAny("HTTP_PROXY", "http_proxy"),
	// HTTPSProxy: getEnvAny("HTTPS_PROXY", "https_proxy"),
	// NoProxy:    getEnvAny("NO_PROXY", "no_proxy"),
	// CGI:        os.Getenv("REQUEST_METHOD") != "",
	noticeURL := "https://raw.githubusercontent.com/suifei/fridare/main/NOTICE.md"
	noticeContent, err := utils.FetchRemoteText(
		noticeURL,
		mw.config.Proxy)
	if err != nil || strings.TrimSpace(noticeContent) == "" {
		// è·å–å¤±è´¥æˆ–å†…å®¹ä¸ºç©ºåˆ™ä¸æ˜¾ç¤ºé€šçŸ¥
		return
	} else {
		mw.addLog("INFO: æˆåŠŸè·å–é€šçŸ¥å†…å®¹: " + noticeURL)
		if mw.config.NoShowNotice {
			// å°†é€šçŸ¥æ˜¾ç¤ºåˆ°logä¸­ä¸å¼¹çª—ï¼Œmarkdown æ–‡æœ¬ç”¨äºæ—¥å¿—æ˜¾ç¤º
			mw.addLog("NOTICE: " + strings.ReplaceAll(noticeContent, "\n\n", "\n"))
			mw.addLog("INFO: é…ç½®è®¾ç½®ä¸ºä¸æ˜¾ç¤ºé€šçŸ¥ï¼Œè·³è¿‡æ˜¾ç¤º")
			return
		}
	}

	// åˆ›å»ºå¯¹è¯æ¡†
	contentViewer := widget.NewRichText()
	contentViewer.ParseMarkdown(noticeContent)
	contentViewer.Wrapping = fyne.TextWrapWord
	// æ”¯æŒå¯¹è¯æ¡†å‹¾é€‰ä¸å†æ˜¾ç¤ºå¹¶è®°å½•åˆ°é…ç½®æ–‡ä»¶
	checkbox := widget.NewCheck("ä¸å†æ˜¾ç¤ºæ­¤é€šçŸ¥", func(checked bool) {
		mw.config.NoShowNotice = checked
		// ä¿å­˜é…ç½®
		if err := mw.config.Save(); err != nil {
			mw.updateStatus("ä¿å­˜é…ç½®å¤±è´¥: " + err.Error())
			mw.addLog("ERROR: ä¿å­˜é…ç½®å¤±è´¥: " + err.Error())
		} else {
			mw.updateStatus("é…ç½®å·²ä¿å­˜")
			mw.addLog("INFO: é…ç½®å·²ä¿å­˜")
		}
	})
	checkbox.SetChecked(mw.config.NoShowNotice)

	content := container.NewBorder(nil, checkbox, nil, nil, container.NewVScroll(contentViewer))

	dialog := dialog.NewCustom("Fridare GUI - é€šçŸ¥", "ç¡®å®š", content, mw.window)
	dialog.Resize(fyne.NewSize(400, 400))
	dialog.Show()
}

// ShowAndRun æ˜¾ç¤ºçª—å£å¹¶è¿è¡Œåº”ç”¨
func (mw *MainWindow) ShowAndRun() {
	// è®¾ç½®å…³é—­å›è°ƒ
	mw.window.SetCloseIntercept(func() {
		mw.saveConfig()
		mw.app.Quit()
	})

	// æ˜¾ç¤ºçª—å£
	mw.window.Show()

	// è¿è¡Œåº”ç”¨
	mw.app.Run()
}

// StatusUpdater çŠ¶æ€æ›´æ–°æ¥å£
type StatusUpdater func(message string)

// createBottomArea åˆ›å»ºåº•éƒ¨åŒºåŸŸ
func (mw *MainWindow) createBottomArea() *fyne.Container {
	// åˆ›å»ºçŠ¶æ€æ 
	mw.statusBar = widget.NewLabel("ç­‰å¾…æ“ä½œ...")
	mw.statusBar.TextStyle = fyne.TextStyle{Italic: true}

	// åˆ›å»ºæ—¥å¿—åŒºåŸŸ - ä½¿ç”¨è‡ªå®šä¹‰æ—¥å¿—ç»„ä»¶ï¼Œé»‘è‰²èƒŒæ™¯ç»¿è‰²æ–‡å­—
	mw.logText = NewLogEntry()
	mw.logText.Resize(fyne.NewSize(0, 60)) // è®¾ç½®é«˜åº¦

	// åˆ›å»ºæ—¥å¿—æ§åˆ¶æŒ‰é’®
	clearBtn := widget.NewButton("æ¸…ç©º", func() {
		mw.logText.SetLogText("")
		mw.updateStatus("æ—¥å¿—å·²æ¸…ç©º")
	})

	historyBtn := widget.NewButton("å†å²", func() {
		mw.updateStatus("å†å²åŠŸèƒ½å¾…å®ç°")
	})

	logControls := container.NewHBox(
		mw.statusBar,
		widget.NewSeparator(),
		clearBtn,
		historyBtn,
	)

	// åˆ›å»ºå¸¦æ»šåŠ¨çš„æ—¥å¿—åŒºåŸŸ
	logScroll := container.NewScroll(mw.logText)
	logScroll.SetMinSize(fyne.NewSize(0, 60))

	// ç»„è£…åº•éƒ¨åŒºåŸŸ
	bottomArea := container.NewBorder(
		logControls, // top
		nil,         // bottom
		nil,         // left
		nil,         // right
		logScroll,   // center
	)

	return bottomArea
}

// addLog æ·»åŠ æ—¥å¿—
func (mw *MainWindow) addLog(message string) {
	if mw.logText != nil {
		timestamp := time.Now().Format("15:04:05")
		logEntry := fmt.Sprintf("[%s] %s", timestamp, message)
		fyne.Do(func() {
			mw.logText.AppendLogText(logEntry + "\n")
		})
	}
}

// testProxy æµ‹è¯•ä»£ç†è¿æ¥
func (mw *MainWindow) testProxy() {
	proxyURL := strings.TrimSpace(mw.proxyEntry.Text)

	// å¦‚æœä»£ç†ä¸ºç©ºï¼Œæµ‹è¯•ç›´è¿
	if proxyURL == "" {
		mw.updateStatus("æ­£åœ¨æµ‹è¯•ç›´è¿...")
		mw.addLog("INFO: å¼€å§‹æµ‹è¯•ç›´è¿")
	} else {
		mw.updateStatus("æ­£åœ¨æµ‹è¯•ä»£ç†è¿æ¥...")
		mw.addLog("INFO: å¼€å§‹æµ‹è¯•ä»£ç†è¿æ¥: " + proxyURL)
	}

	// å¼‚æ­¥æ‰§è¡Œæµ‹è¯•
	go func() {
		// æµ‹è¯•å¤šä¸ªURL
		testURLs := []struct {
			name string
			url  string
		}{
			{"GitHub Frida API", "https://api.github.com/repos/frida/frida/releases/latest"},
			{"Google", "https://www.google.com"},
		}

		var results []string
		var successCount int

		for _, test := range testURLs {
			success, message, err := utils.TestProxy(proxyURL, test.url, mw.config.Timeout)

			if success {
				results = append(results, fmt.Sprintf("âœ“ %s: %s", test.name, message))
				successCount++
				mw.addLog(fmt.Sprintf("SUCCESS: %s - %s", test.name, message))
			} else {
				results = append(results, fmt.Sprintf("âœ— %s: %s", test.name, message))
				mw.addLog(fmt.Sprintf("ERROR: %s - %s", test.name, message))
				if err != nil {
					mw.addLog("ERROR: " + err.Error())
				}
			}
		}
		ProxyInfo := "Proxy: Direct"
		if proxyURL != "" {
			ProxyInfo = "Proxy: " + proxyURL
		}
		// æ›´æ–°UI
		if successCount > 0 {
			if successCount == len(testURLs) {
				mw.updateStatus("ä»£ç†æµ‹è¯•å®Œå…¨æˆåŠŸ")
				dialog.ShowInformation("ä»£ç†æµ‹è¯•ç»“æœ",
					fmt.Sprintf("%s, æµ‹è¯•æˆåŠŸï¼(%d/%d)\n\n%s",
						ProxyInfo,
						successCount, len(testURLs), strings.Join(results, "\n")),
					mw.window)
			} else {
				mw.updateStatus(fmt.Sprintf("ä»£ç†æµ‹è¯•éƒ¨åˆ†æˆåŠŸ (%d/%d)", successCount, len(testURLs)))
				dialog.ShowInformation("ä»£ç†æµ‹è¯•ç»“æœ",
					fmt.Sprintf("%s, éƒ¨åˆ†æˆåŠŸ (%d/%d)\n\n%s",
						ProxyInfo,
						successCount, len(testURLs), strings.Join(results, "\n")),
					mw.window)
			}
		} else {
			mw.updateStatus("ä»£ç†æµ‹è¯•å¤±è´¥")
			dialog.ShowError(
				fmt.Errorf("%s, ä»£ç†æµ‹è¯•å¤±è´¥\n\n%s", ProxyInfo, strings.Join(results, "\n")),
				mw.window)
		}
	}()
}

// isValidMagicName éªŒè¯é­”æ”¹åç§°
func isValidMagicName(name string) bool {
	if len(name) != 5 {
		return false
	}
	for _, c := range name {
		if !((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')) {
			return false
		}
	}
	return true
}

// updateGlobalMagicName æ›´æ–°å…¨å±€é­”æ”¹åç§°
func (mw *MainWindow) updateGlobalMagicName(magicName string) {
	mw.config.MagicName = magicName
	mw.saveProxyConfig() // é‡ç”¨ç°æœ‰çš„ä¿å­˜æ–¹æ³•

	// é€šçŸ¥æ‰€æœ‰æ ‡ç­¾é¡µæ›´æ–°
	mw.updateTabsGlobalConfig()
	mw.updateStatus("å…¨å±€é­”æ”¹åç§°å·²æ›´æ–°: " + magicName)
}

// updateGlobalPort æ›´æ–°å…¨å±€ç«¯å£
func (mw *MainWindow) updateGlobalPort(port int) {
	mw.config.DefaultPort = port
	mw.saveProxyConfig() // é‡ç”¨ç°æœ‰çš„ä¿å­˜æ–¹æ³•

	// é€šçŸ¥æ‰€æœ‰æ ‡ç­¾é¡µæ›´æ–°
	mw.updateTabsGlobalConfig()
	mw.updateStatus(fmt.Sprintf("å…¨å±€ç«¯å£å·²æ›´æ–°: %d", port))
}

// updateTabsGlobalConfig æ›´æ–°æ‰€æœ‰æ ‡ç­¾é¡µçš„å…¨å±€é…ç½®
func (mw *MainWindow) updateTabsGlobalConfig() {
	// æ›´æ–°ModifyTab
	if mw.modifyTab != nil {
		mw.modifyTab.UpdateGlobalConfig(mw.config.MagicName, mw.config.DefaultPort)
	}

	// æ›´æ–°PackageTab
	if mw.packageTab != nil {
		mw.packageTab.UpdateGlobalConfig(mw.config.MagicName, mw.config.DefaultPort)
	}

	// æ›´æ–°CreateTab
	if mw.createTab != nil {
		mw.createTab.UpdateGlobalConfig(mw.config.MagicName, mw.config.DefaultPort)
	}

	// æ›´æ–°ToolsTab
	if mw.toolsTab != nil {
		mw.toolsTab.UpdateGlobalConfig(mw.config.MagicName, mw.config.DefaultPort)
	}
}

```

`ui/internal/ui/notice_async.go`:

```go
package ui

import (
	"fridare-gui/internal/utils"
	"strings"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/widget"
)

// NoticeData é€šçŸ¥æ•°æ®ç»“æ„
type NoticeData struct {
	Content string
	Error   error
}

// showNoticeAsync å¼‚æ­¥æ˜¾ç¤ºé€šçŸ¥å¯¹è¯æ¡†ï¼Œä½¿ç”¨åç¨‹å’Œchannel
func (mw *MainWindow) showNoticeAsync() {
	// åˆ›å»ºchannelç”¨äºæ¥æ”¶HTTPè¯·æ±‚ç»“æœ
	noticeChannel := make(chan NoticeData, 1)

	// å¯åŠ¨åç¨‹æ‰§è¡ŒHTTPè¯·æ±‚
	go func() {
		// åˆ›å»ºç®€å•çš„å¯¹è¯æ¡†å†…å®¹, æ”¯æŒå¤šè¡Œæ–‡æœ¬å’Œmarkdown
		// é€šçŸ¥å†…å®¹ä» https://raw.githubusercontent.com/suifei/fridare/main/NOTICE.md è·å–
		// ç½‘ç»œè¯·æ±‚å¤±è´¥åˆ™ä¸æ˜¾ç¤º(è‡ªåŠ¨æŒ‚æ¥ä»£ç†)

		// ä»é…ç½®è·å–ä»£ç†ï¼Œå¦‚æœé…ç½®æ²¡æœ‰ï¼Œåˆ™å°è¯•è·å–ç³»ç»Ÿä»£ç†  ï¼Œå¦åˆ™ä¸º""
		// ç³»ç»Ÿä»£ç†è·å–ï¼š
		// HTTPProxy:  getEnvAny("HTTP_PROXY", "http_proxy"),
		// HTTPSProxy: getEnvAny("HTTPS_PROXY", "https_proxy"),
		// NoProxy:    getEnvAny("NO_PROXY", "no_proxy"),
		// CGI:        os.Getenv("REQUEST_METHOD") != "",
		noticeURL := "https://raw.githubusercontent.com/suifei/fridare/main/NOTICE.md"
		noticeContent, err := utils.FetchRemoteText(
			noticeURL,
			mw.config.Proxy)

		// é€šè¿‡channelå‘é€ç»“æœ
		noticeChannel <- NoticeData{
			Content: noticeContent,
			Error:   err,
		}
	}()

	// å¯åŠ¨å¦ä¸€ä¸ªåç¨‹ç›‘å¬channelå¹¶å¤„ç†UIæ›´æ–°
	go func() {
		data := <-noticeChannel

		if data.Error != nil || strings.TrimSpace(data.Content) == "" {
			// è·å–å¤±è´¥æˆ–å†…å®¹ä¸ºç©ºåˆ™ä¸æ˜¾ç¤ºé€šçŸ¥
			return
		}

		// åœ¨ä¸»UIçº¿ç¨‹ä¸­æ˜¾ç¤ºé€šçŸ¥
		mw.addLog("INFO: æˆåŠŸè·å–é€šçŸ¥å†…å®¹: https://raw.githubusercontent.com/suifei/fridare/main/NOTICE.md")

		if mw.config.NoShowNotice {
			// å°†é€šçŸ¥æ˜¾ç¤ºåˆ°logä¸­ä¸å¼¹çª—ï¼Œmarkdown æ–‡æœ¬ç”¨äºæ—¥å¿—æ˜¾ç¤º
			mw.addLog("NOTICE: " + strings.ReplaceAll(data.Content, "\n\n", "\n"))
			mw.addLog("INFO: é…ç½®è®¾ç½®ä¸ºä¸æ˜¾ç¤ºé€šçŸ¥ï¼Œè·³è¿‡æ˜¾ç¤º")
			return
		}

		// åˆ›å»ºå¯¹è¯æ¡†
		contentViewer := widget.NewRichText()
		contentViewer.ParseMarkdown(data.Content)
		contentViewer.Wrapping = fyne.TextWrapWord

		// æ”¯æŒå¯¹è¯æ¡†å‹¾é€‰ä¸å†æ˜¾ç¤ºå¹¶è®°å½•åˆ°é…ç½®æ–‡ä»¶
		checkbox := widget.NewCheck("ä¸å†æ˜¾ç¤ºæ­¤é€šçŸ¥", func(checked bool) {
			mw.config.NoShowNotice = checked
			// ä¿å­˜é…ç½®
			if err := mw.config.Save(); err != nil {
				mw.updateStatus("ä¿å­˜é…ç½®å¤±è´¥: " + err.Error())
				mw.addLog("ERROR: ä¿å­˜é…ç½®å¤±è´¥: " + err.Error())
			} else {
				mw.updateStatus("é…ç½®å·²ä¿å­˜")
				mw.addLog("INFO: é…ç½®å·²ä¿å­˜")
			}
		})
		checkbox.SetChecked(mw.config.NoShowNotice)

		content := container.NewBorder(nil, checkbox, nil, nil, container.NewVScroll(contentViewer))

		dialog := dialog.NewCustom("Fridare GUI - é€šçŸ¥", "ç¡®å®š", content, mw.window)
		dialog.Resize(fyne.NewSize(400, 400))
		dialog.Show()
	}()
}

```

`ui/internal/ui/tabs.go`:

```go
package ui

import (
	"encoding/json"
	"fmt"
	"fridare-gui/internal/config"
	"fridare-gui/internal/core"
	"fridare-gui/internal/utils"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"
	"syscall"
	"time"
	"unicode"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/storage"
	"fyne.io/fyne/v2/widget"
)

// fixedWidthEntry åˆ›å»ºå›ºå®šå®½åº¦çš„Entry
func fixedWidthEntry(width float32, placeholder string) *FixedWidthEntry {
	entry := NewFixedWidthEntry(width)
	entry.SetPlaceHolder(placeholder)
	entry.Resize(fyne.NewSize(width, entry.MinSize().Height))
	return entry
}

// ModifyTab ä¿®æ”¹æ ‡ç­¾é¡µ
type ModifyTab struct {
	app          fyne.App
	config       *config.Config
	updateStatus StatusUpdater
	addLog       func(string) // æ·»åŠ æ—¥å¿—è®°å½•åŠŸèƒ½
	content      *fyne.Container

	// UI ç»„ä»¶
	filePathEntry  *widget.Entry
	magicNameEntry *widget.Entry
	fileInfoText   *widget.RichText
	progressBar    *widget.ProgressBar
	progressLabel  *widget.Label
	patchBtn       *widget.Button

	// æ ¸å¿ƒåŠŸèƒ½
	hexReplacer *core.HexReplacer
}

// NewModifyTab åˆ›å»ºä¿®æ”¹æ ‡ç­¾é¡µ
func NewModifyTab(app fyne.App, cfg *config.Config, statusUpdater StatusUpdater, logFunc func(string)) *ModifyTab {
	mt := &ModifyTab{
		app:          app,
		config:       cfg,
		updateStatus: statusUpdater,
		addLog:       logFunc,
		hexReplacer:  core.NewHexReplacer(),
	}

	mt.setupUI()
	return mt
}

func (mt *ModifyTab) setupUI() {
	// è¾“å…¥æ–‡ä»¶é€‰æ‹©åŒºåŸŸ
	mt.filePathEntry = widget.NewEntry()
	mt.filePathEntry.SetPlaceHolder("é€‰æ‹©è¦ä¿®æ”¹çš„ Frida äºŒè¿›åˆ¶æ–‡ä»¶...")
	mt.filePathEntry.OnChanged = func(path string) {
		if path != "" {
			mt.analyzeFile(path)
		} else {
			mt.fileInfoText.ParseMarkdown("")
		}
		// ç«‹å³éªŒè¯è¾“å…¥
		mt.validateInput(mt.magicNameEntry.Text, mt.filePathEntry.Text)
	}

	browseInputBtn := widget.NewButton("æµè§ˆ", func() {
		mt.selectInputFile()
	})

	fileSelectArea := container.NewBorder(
		nil, nil, nil, browseInputBtn, mt.filePathEntry,
	)

	// é­”æ”¹é€‰é¡¹
	mt.magicNameEntry = widget.NewEntry()
	mt.magicNameEntry.SetPlaceHolder("è¾“å…¥5ä¸ªå°å†™å­—æ¯")
	if mt.config.MagicName != "" && len(mt.config.MagicName) == 5 {
		mt.magicNameEntry.SetText(mt.config.MagicName)
	} else {
		mt.magicNameEntry.SetText("frida")
	}
	// éªŒè¯è¾“å…¥
	mt.magicNameEntry.OnChanged = func(text string) {
		mt.validateInput(text, mt.filePathEntry.Text)
	}

	// éšæœºç”ŸæˆæŒ‰é’®
	randomBtn := widget.NewButton("éšæœº", func() {
		randomName := mt.generateRandomName()
		mt.magicNameEntry.SetText(randomName)
		mt.validateInput(randomName, mt.filePathEntry.Text)
	})

	magicNameArea := container.NewBorder(
		nil, nil, nil, randomBtn, mt.magicNameEntry,
	)

	optionsForm := container.NewVBox(
		widget.NewLabel("é­”æ”¹åç§° (å¿…é¡»5ä¸ªå°å†™å­—æ¯):"),
		magicNameArea,
	)

	// æ–‡ä»¶ä¿¡æ¯æ˜¾ç¤ºåŒºåŸŸ
	mt.fileInfoText = widget.NewRichText()
	mt.fileInfoText.Resize(fyne.NewSize(0, 200))

	fileInfoScroll := container.NewScroll(mt.fileInfoText)
	fileInfoScroll.SetMinSize(fyne.NewSize(0, 200))

	fileInfoCard := widget.NewCard("æ–‡ä»¶ä¿¡æ¯", "äºŒè¿›åˆ¶æ–‡ä»¶æ ¼å¼å’Œæ¶æ„ä¿¡æ¯", fileInfoScroll)

	// ä¿®æ”¹æŒ‰é’®
	mt.patchBtn = widget.NewButton("å¼€å§‹é­”æ”¹", func() {
		mt.startPatching()
	})
	mt.patchBtn.Importance = widget.HighImportance
	mt.patchBtn.Disable() // åˆå§‹çŠ¶æ€ç¦ç”¨

	// è¿›åº¦æ˜¾ç¤º
	mt.progressBar = widget.NewProgressBar()
	mt.progressBar.Hide()

	mt.progressLabel = widget.NewLabel("")
	mt.progressLabel.Hide()

	// ä¸»å¸ƒå±€
	mainContent := container.NewVBox(
		container.NewVBox(
			widget.NewLabel("è¾“å…¥æ–‡ä»¶:"),
			fileSelectArea,
		),
		widget.NewSeparator(),
		optionsForm,
		widget.NewSeparator(),
		mt.patchBtn,
		mt.progressBar,
		mt.progressLabel,
	)

	// ä½¿ç”¨æ°´å¹³åˆ†å‰²å¸ƒå±€
	splitContainer := container.NewHSplit(
		widget.NewCard("äºŒè¿›åˆ¶é­”æ”¹å™¨", "ä¿®æ”¹ Frida äºŒè¿›åˆ¶æ–‡ä»¶çš„ç‰¹å¾å­—ç¬¦ä¸²", mainContent),
		fileInfoCard,
	)
	splitContainer.Offset = 0.6 // å·¦ä¾§å 60%

	mt.content = container.NewPadded(splitContainer)

	// åˆå§‹éªŒè¯çŠ¶æ€
	mt.validateInput(mt.magicNameEntry.Text, mt.filePathEntry.Text)
}

// selectInputFile é€‰æ‹©è¾“å…¥æ–‡ä»¶
func (mt *ModifyTab) selectInputFile() {
	fileDialog := dialog.NewFileOpen(func(reader fyne.URIReadCloser, err error) {
		if err != nil || reader == nil {
			return
		}
		defer reader.Close()

		path := reader.URI().Path()
		mt.filePathEntry.SetText(path)
		mt.validateInput(mt.magicNameEntry.Text, path)
	}, fyne.CurrentApp().Driver().AllWindows()[0])

	// ç§»é™¤æ–‡ä»¶ç±»å‹è¿‡æ»¤ï¼Œæ”¯æŒæ‰€æœ‰æ–‡ä»¶ç±»å‹
	fileDialog.Show()
}

// analyzeFile åˆ†ææ–‡ä»¶
func (mt *ModifyTab) analyzeFile(filePath string) {
	go func() {
		mt.updateStatus("æ­£åœ¨åˆ†ææ–‡ä»¶...")

		description, err := mt.hexReplacer.DescribeFile(filePath)
		if err != nil {
			mt.fileInfoText.ParseMarkdown(fmt.Sprintf("**é”™è¯¯:** %s", err.Error()))
			mt.updateStatus("æ–‡ä»¶åˆ†æå¤±è´¥: " + err.Error())
			return
		}

		// æ ¼å¼åŒ–æ˜¾ç¤ºä¿¡æ¯
		markdown := fmt.Sprintf("**æ–‡ä»¶è·¯å¾„:** %s\n\n**æ–‡ä»¶ä¿¡æ¯:**\n```\n%s\n```", filePath, description)
		mt.fileInfoText.ParseMarkdown(markdown)
		fyne.Do(func() {
			mt.updateStatus("æ–‡ä»¶åˆ†æå®Œæˆ")
		})
	}()
}

// validateInput éªŒè¯è¾“å…¥
func (mt *ModifyTab) validateInput(name string, filePath string) {
	inputValid := name != ""
	nameValid := len(name) == 5 && utils.IsFridaNewName(name)
	filePathValid := utils.FileExists(filePath)

	if inputValid && nameValid && filePathValid {
		mt.patchBtn.Enable()
	} else {
		mt.patchBtn.Disable()
	}

}

// generateRandomName ç”Ÿæˆéšæœºåç§°
func (mt *ModifyTab) generateRandomName() string {
	return utils.GenerateRandomName()
}

// startPatching å¼€å§‹ä¿®æ”¹
func (mt *ModifyTab) startPatching() {
	inputPath := mt.filePathEntry.Text
	magicName := mt.magicNameEntry.Text

	// è‡ªåŠ¨ç”Ÿæˆè¾“å‡ºè·¯å¾„
	dir := filepath.Dir(inputPath)
	base := filepath.Base(inputPath)
	ext := filepath.Ext(base)
	name := strings.TrimSuffix(base, ext)

	// å°†æ–‡ä»¶åä¸­çš„ frida æ›¿æ¢ä¸ºé­”æ”¹åç§°
	if strings.Contains(name, "frida") {
		name = strings.ReplaceAll(name, "frida", magicName)
	} else {
		name = magicName + "_" + name
	}

	outputPath := filepath.Join(dir, name+ext)

	// æ˜¾ç¤ºè¿›åº¦
	mt.progressBar.Show()
	mt.progressLabel.Show()
	mt.progressBar.SetValue(0)
	mt.progressLabel.SetText("æ­£åœ¨åˆå§‹åŒ–...")
	mt.patchBtn.Disable()

	go func() {
		defer func() {
			mt.progressBar.Hide()
			mt.progressLabel.Hide()
			mt.patchBtn.Enable()
		}()

		mt.updateStatus("å¼€å§‹é­”æ”¹äºŒè¿›åˆ¶æ–‡ä»¶...")
		mt.addLog("INFO: å¼€å§‹é­”æ”¹äºŒè¿›åˆ¶æ–‡ä»¶")
		mt.addLog(fmt.Sprintf("INFO: è¾“å…¥æ–‡ä»¶: %s", inputPath))
		mt.addLog(fmt.Sprintf("INFO: è¾“å‡ºæ–‡ä»¶: %s", outputPath))
		mt.addLog(fmt.Sprintf("INFO: é­”æ”¹åç§°: %s", magicName))

		// è¿›åº¦å›è°ƒå‡½æ•°
		progressCallback := func(progress float64, message string) {
			mt.progressBar.SetValue(progress)
			mt.progressLabel.SetText(message)
			mt.updateStatus(message)
			mt.addLog(fmt.Sprintf("INFO: %s (%.1f%%)", message, progress*100))
		}

		// æ‰§è¡Œä¿®æ”¹
		err := mt.hexReplacer.PatchFile(inputPath, magicName, outputPath, progressCallback)
		if err != nil {
			errorMsg := "é­”æ”¹å¤±è´¥: " + err.Error()
			mt.updateStatus(errorMsg)
			mt.progressLabel.SetText("é­”æ”¹å¤±è´¥!")
			mt.addLog("ERROR: " + errorMsg)

			// åªæ˜¾ç¤ºæœ€ç»ˆé”™è¯¯ç»“æœçš„å¼¹çª—
			dialog.ShowError(fmt.Errorf("é­”æ”¹å¤±è´¥: %v", err), fyne.CurrentApp().Driver().AllWindows()[0])
			return
		}

		mt.progressBar.SetValue(1.0)
		mt.progressLabel.SetText("é­”æ”¹å®Œæˆ!")
		successMsg := fmt.Sprintf("é­”æ”¹å®Œæˆ! è¾“å‡ºæ–‡ä»¶: %s", outputPath)
		mt.updateStatus(successMsg)
		mt.addLog("SUCCESS: " + successMsg)

		// æ›´æ–°é…ç½®
		mt.config.MagicName = magicName
		mt.config.Save()
		mt.addLog("INFO: é…ç½®å·²ä¿å­˜")

		// åªæ˜¾ç¤ºæœ€ç»ˆæˆåŠŸç»“æœçš„å¼¹çª—
		// ç¼©çŸ­è·¯å¾„æ˜¾ç¤ºä»¥é¿å…å®½åº¦é—®é¢˜
		inputBaseName := filepath.Base(inputPath)
		outputBaseName := filepath.Base(outputPath)

		contentText := fmt.Sprintf("é­”æ”¹å®Œæˆ!\n\nè¾“å…¥æ–‡ä»¶: %s\nè¾“å‡ºæ–‡ä»¶: %s\né­”æ”¹åç§°: %s\n\næ–‡ä»¶å·²ä¿å­˜åˆ°ä¸è¾“å…¥æ–‡ä»¶ç›¸åŒçš„ç›®å½•",
			inputBaseName, outputBaseName, magicName)

		// ä½¿ç”¨ç®€å•çš„ä¿¡æ¯å¼¹çª—ï¼Œå†…å®¹ä¼šè‡ªåŠ¨æ¢è¡Œ
		dialog.ShowInformation("é­”æ”¹å®Œæˆ", contentText, fyne.CurrentApp().Driver().AllWindows()[0])
	}()
}

func (mt *ModifyTab) Content() *fyne.Container {
	return mt.content
}

func (mt *ModifyTab) Refresh() {
	// åˆ·æ–°é€»è¾‘
}

// UpdateGlobalConfig æ›´æ–°å…¨å±€é…ç½®
func (mt *ModifyTab) UpdateGlobalConfig(magicName string, port int) {
	if mt.magicNameEntry != nil {
		mt.magicNameEntry.SetText(magicName)
	}
}

// PackageTab æ‰“åŒ…æ ‡ç­¾é¡µ
type PackageTab struct {
	app          fyne.App
	config       *config.Config
	updateStatus StatusUpdater
	addLog       func(string)
	content      *fyne.Container

	// UI ç»„ä»¶
	debFileEntry    *widget.Entry // DEBæ–‡ä»¶é€‰æ‹©
	outputPathEntry *widget.Entry
	portEntry       *widget.Entry
	magicNameEntry  *widget.Entry
	packageBtn      *widget.Button
	progressBar     *widget.ProgressBar
	progressLabel   *widget.Label

	// æ ¸å¿ƒåŠŸèƒ½
	debPackager *core.DebPackager
}

func NewPackageTab(app fyne.App, cfg *config.Config, statusUpdater StatusUpdater, logFunc func(string)) *PackageTab {
	pt := &PackageTab{
		app:          app,
		config:       cfg,
		updateStatus: statusUpdater,
		addLog:       logFunc,
		debPackager:  core.NewDebPackager(),
	}

	pt.setupUI()
	return pt
}

func (pt *PackageTab) setupUI() {
	// ç›´æ¥è®¾ç½®ä¸ºä¿®æ”¹ç°æœ‰DEBåŒ…æ¨¡å¼ï¼Œä¸éœ€è¦æ¨¡å¼é€‰æ‹©
	pt.debFileEntry = widget.NewEntry()
	pt.debFileEntry.SetPlaceHolder("é€‰æ‹©è¦ä¿®æ”¹çš„ DEB åŒ…æ–‡ä»¶...")
	pt.debFileEntry.OnChanged = func(path string) {
		pt.validateInput()
	}

	// è®¾ç½®DEBæ–‡ä»¶é€‰æ‹©åŒºåŸŸ
	browseDebBtn := widget.NewButton("æµè§ˆ", func() {
		pt.selectDebFile()
	})

	debFileArea := container.NewBorder(
		nil, nil, widget.NewLabel("DEBæ–‡ä»¶:"), browseDebBtn, pt.debFileEntry,
	)

	// åŒ…ä¿¡æ¯æ˜¾ç¤ºåŒºåŸŸ
	infoText := widget.NewRichText()
	infoText.ParseMarkdown("**DEBåŒ…ä¿®æ”¹å™¨**\n\n" +
		"â€¢ é€‰æ‹©ç°æœ‰çš„Frida DEBåŒ…æ–‡ä»¶\n" +
		"â€¢ è‡ªåŠ¨è¯»å–åŒ…å…ƒæ•°æ®\n" +
		"â€¢ ä½¿ç”¨æŒ‡å®šçš„é­”æ”¹åç§°å’Œç«¯å£è¿›è¡Œä¿®æ”¹\n" +
		"â€¢ ç”Ÿæˆä¿®æ”¹åçš„DEBåŒ…\n\n" +
		"**æ”¯æŒçš„ä¿®æ”¹ï¼š**\n" +
		"â€¢ ä¿®æ”¹FridaæœåŠ¡åç§°\n" +
		"â€¢ ä¿®æ”¹é»˜è®¤ç›‘å¬ç«¯å£\n" +
		"â€¢ ä¿æŒåŸåŒ…çš„æ‰€æœ‰å…¶ä»–è®¾ç½®")

	packageInfoCard := widget.NewCard("æ“ä½œè¯´æ˜", "", infoText)

	// è¾“å‡ºè·¯å¾„é€‰æ‹©
	pt.outputPathEntry = widget.NewEntry()
	pt.outputPathEntry.SetPlaceHolder("DEB åŒ…è¾“å‡ºè·¯å¾„...")
	pt.outputPathEntry.OnChanged = func(path string) {
		pt.validateInput()
	}

	browseOutputBtn := widget.NewButton("æµè§ˆ", func() {
		pt.selectOutputPath()
	})

	outputArea := container.NewBorder(
		nil, nil, nil, browseOutputBtn, pt.outputPathEntry,
	)

	// é­”æ”¹é…ç½®
	pt.portEntry = widget.NewEntry()
	if pt.config.DefaultPort != 0 {
		pt.portEntry.SetText(fmt.Sprintf("%d", pt.config.DefaultPort))
	} else {
		pt.portEntry.SetText("27042")
	}
	pt.portEntry.SetPlaceHolder("Frida æœåŠ¡å™¨ç«¯å£")

	pt.magicNameEntry = widget.NewEntry()
	if pt.config.MagicName != "" && len(pt.config.MagicName) == 5 {
		pt.magicNameEntry.SetText(pt.config.MagicName)
	} else {
		pt.magicNameEntry.SetText("frida")
	}
	pt.magicNameEntry.SetPlaceHolder("é­”æ”¹åç§° (5ä¸ªå­—ç¬¦)")

	// éªŒè¯è¾“å…¥
	pt.magicNameEntry.OnChanged = func(text string) {
		pt.validateInput()
	}
	pt.portEntry.OnChanged = func(text string) {
		pt.validateInput()
	}

	// éšæœºç”Ÿæˆé­”æ”¹åç§°æŒ‰é’®
	randomMagicBtn := widget.NewButton("éšæœº", func() {
		randomName := utils.GenerateRandomName()
		pt.magicNameEntry.SetText(randomName)
	})

	magicNameArea := container.NewBorder(
		nil, nil, nil, randomMagicBtn, pt.magicNameEntry,
	)

	// è¿›åº¦æ¡å’ŒçŠ¶æ€
	pt.progressBar = widget.NewProgressBar()
	pt.progressBar.Hide()
	pt.progressLabel = widget.NewLabel("")
	pt.progressLabel.Hide()

	// æ“ä½œæŒ‰é’®
	pt.packageBtn = widget.NewButton("ä¿®æ”¹ DEB åŒ…", func() {
		pt.startPackaging()
	})
	pt.packageBtn.Disable()

	progressArea := container.NewVBox(
		pt.progressBar,
		pt.progressLabel,
	)

	actionArea := container.NewBorder(
		nil, nil, nil, pt.packageBtn, progressArea,
	)

	// ä¸»å¸ƒå±€
	pt.content = container.NewVBox(
		debFileArea,
		widget.NewSeparator(),
		container.NewBorder(
			nil, nil, widget.NewLabel("è¾“å‡ºè·¯å¾„:"), nil, outputArea,
		),
		widget.NewSeparator(),
		container.NewBorder(
			nil, nil, widget.NewLabel("é­”æ”¹åç§°:"), nil, magicNameArea,
		),
		container.NewBorder(
			nil, nil, widget.NewLabel("æœåŠ¡ç«¯å£:"), nil, pt.portEntry,
		),
		widget.NewSeparator(),
		packageInfoCard,
		widget.NewSeparator(),
		actionArea,
	)
}

func (pt *PackageTab) Content() *fyne.Container {
	return pt.content
}

func (pt *PackageTab) Refresh() {
	// åˆ·æ–°é€»è¾‘
	pt.validateInput()
}

// UpdateGlobalConfig æ›´æ–°å…¨å±€é…ç½®
func (pt *PackageTab) UpdateGlobalConfig(magicName string, port int) {
	if pt.magicNameEntry != nil {
		pt.magicNameEntry.SetText(magicName)
	}
	if pt.portEntry != nil {
		pt.portEntry.SetText(fmt.Sprintf("%d", port))
	}
}

// selectDebFile é€‰æ‹©DEBæ–‡ä»¶
func (pt *PackageTab) selectDebFile() {
	fileDialog := dialog.NewFileOpen(func(reader fyne.URIReadCloser, err error) {
		if err != nil || reader == nil {
			return
		}
		defer reader.Close()

		path := reader.URI().Path()
		pt.debFileEntry.SetText(path)

		// è‡ªåŠ¨è®¾ç½®è¾“å‡ºè·¯å¾„
		if pt.outputPathEntry.Text == "" {
			dir := filepath.Dir(path)
			base := filepath.Base(path)
			nameWithoutExt := strings.TrimSuffix(base, filepath.Ext(base))

			// ç”Ÿæˆä¿®æ”¹åçš„æ–‡ä»¶å
			magicName := pt.magicNameEntry.Text
			if magicName == "" {
				magicName = "frida"
			}

			outputName := fmt.Sprintf("%s_%s_modified.deb", nameWithoutExt, magicName)
			outputPath := filepath.Join(dir, outputName)
			pt.outputPathEntry.SetText(outputPath)
		}
	}, fyne.CurrentApp().Driver().AllWindows()[0])

	// è®¾ç½®æ–‡ä»¶è¿‡æ»¤å™¨
	fileDialog.SetFilter(storage.NewExtensionFileFilter([]string{".deb"}))
	fileDialog.Show()
}

// selectOutputPath é€‰æ‹©è¾“å‡ºè·¯å¾„
func (pt *PackageTab) selectOutputPath() {
	fileDialog := dialog.NewFileSave(func(writer fyne.URIWriteCloser, err error) {
		if err != nil || writer == nil {
			return
		}
		defer writer.Close()

		filePath := writer.URI().Path()
		if !strings.HasSuffix(strings.ToLower(filePath), ".deb") {
			filePath += ".deb"
		}
		pt.outputPathEntry.SetText(filePath)
	}, fyne.CurrentApp().Driver().AllWindows()[0])

	// è®¾ç½®é»˜è®¤æ–‡ä»¶å
	magicName := pt.magicNameEntry.Text
	if magicName == "" {
		magicName = "frida"
	}

	defaultName := fmt.Sprintf("%s_modified.deb", magicName)
	fileDialog.SetFileName(defaultName)

	fileDialog.Show()
}

// validateInput éªŒè¯è¾“å…¥
func (pt *PackageTab) validateInput() {
	outputPathValid := pt.outputPathEntry.Text != ""
	magicNameValid := len(pt.magicNameEntry.Text) == 5 && utils.IsFridaNewName(pt.magicNameEntry.Text)
	portValid := pt.isValidPort(pt.portEntry.Text)
	fileValid := pt.debFileEntry.Text != ""

	if fileValid && outputPathValid && magicNameValid && portValid {
		pt.packageBtn.Enable()
	} else {
		pt.packageBtn.Disable()
	}
}

// isValidPort æ£€æŸ¥ç«¯å£æ˜¯å¦æœ‰æ•ˆ
func (pt *PackageTab) isValidPort(portStr string) bool {
	if portStr == "" {
		return false
	}
	port, err := strconv.Atoi(portStr)
	return err == nil && port > 0 && port <= 65535
}

// startPackaging å¼€å§‹ä¿®æ”¹DEBåŒ…
func (pt *PackageTab) startPackaging() {
	outputPath := pt.outputPathEntry.Text
	debFile := pt.debFileEntry.Text

	// è§£æç«¯å£
	port, err := strconv.Atoi(pt.portEntry.Text)
	if err != nil {
		pt.updateStatus("ç«¯å£å·æ— æ•ˆ")
		pt.addLog("ERROR: ç«¯å£å·æ— æ•ˆ: " + pt.portEntry.Text)
		return
	}

	magicName := pt.magicNameEntry.Text

	// æ˜¾ç¤ºè¿›åº¦
	pt.progressBar.Show()
	pt.progressLabel.Show()
	pt.progressBar.SetValue(0)
	pt.progressLabel.SetText("æ­£åœ¨åˆå§‹åŒ–...")
	pt.packageBtn.Disable()

	go func() {
		defer func() {
			fyne.Do(pt.progressBar.Hide)
			fyne.Do(pt.progressLabel.Hide)
			fyne.Do(pt.packageBtn.Enable)
		}()

		pt.modifyExistingDebPackage(outputPath, port, magicName, debFile)
	}()
}

// modifyExistingDebPackage ä¿®æ”¹ç°æœ‰DEBåŒ…
func (pt *PackageTab) modifyExistingDebPackage(outputPath string, port int, magicName string, debFile string) {

	pt.updateStatus("å¼€å§‹ä¿®æ”¹DEBåŒ…...")
	pt.addLog("INFO: å¼€å§‹ä¿®æ”¹ç°æœ‰DEBåŒ…")
	pt.addLog(fmt.Sprintf("INFO: è¾“å…¥DEBæ–‡ä»¶: %s", debFile))
	pt.addLog(fmt.Sprintf("INFO: è¾“å‡ºè·¯å¾„: %s", outputPath))
	pt.addLog(fmt.Sprintf("INFO: é­”æ”¹åç§°: %s", magicName))
	pt.addLog(fmt.Sprintf("INFO: ç«¯å£: %d", port))

	// åˆ›å»ºDEBä¿®æ”¹å™¨
	debModifier := core.NewDebModifier(debFile, outputPath, magicName, port)

	// è¿›åº¦å›è°ƒå‡½æ•°
	progressCallback := func(progress float64, message string) {
		fyne.Do(func() {
			pt.progressBar.SetValue(progress)
			pt.progressLabel.SetText(message)
			pt.updateStatus(message)
			pt.addLog(fmt.Sprintf("INFO: %s (%.1f%%)", message, progress*100))
		})
	}

	// æ‰§è¡Œä¿®æ”¹
	err := debModifier.ModifyDebPackage(progressCallback)
	if err != nil {
		errorMsg := "DEBåŒ…ä¿®æ”¹å¤±è´¥: " + err.Error()
		pt.updateStatus(errorMsg)
		pt.progressLabel.SetText("ä¿®æ”¹å¤±è´¥!")
		pt.addLog("ERROR: " + errorMsg)

		// æ˜¾ç¤ºé”™è¯¯å¼¹çª—
		dialog.ShowError(fmt.Errorf("DEBåŒ…ä¿®æ”¹å¤±è´¥: %v", err), fyne.CurrentApp().Driver().AllWindows()[0])
		return
	}

	pt.progressBar.SetValue(1.0)
	pt.progressLabel.SetText("DEBåŒ…ä¿®æ”¹å®Œæˆ!")
	successMsg := fmt.Sprintf("DEBåŒ…ä¿®æ”¹å®Œæˆ! è¾“å‡ºæ–‡ä»¶: %s", outputPath)
	pt.updateStatus(successMsg)
	pt.addLog("SUCCESS: " + successMsg)

	// æ›´æ–°é…ç½®
	pt.config.MagicName = magicName
	pt.config.DefaultPort = port
	pt.config.Save()
	pt.addLog("INFO: é…ç½®å·²ä¿å­˜")

	// æ˜¾ç¤ºæˆåŠŸå¼¹çª—
	outputBaseName := filepath.Base(outputPath)
	inputBaseName := filepath.Base(debFile)
	contentText := fmt.Sprintf("DEBåŒ…ä¿®æ”¹å®Œæˆ!\n\nåŸå§‹æ–‡ä»¶: %s\nè¾“å‡ºæ–‡ä»¶: %s\né­”æ”¹åç§°: %s\nç«¯å£: %d\n\nä¿®æ”¹åçš„æ–‡ä»¶å·²ä¿å­˜åˆ°æŒ‡å®šä½ç½®",
		inputBaseName, outputBaseName, magicName, port)

	dialog.ShowInformation("DEBåŒ…ä¿®æ”¹å®Œæˆ", contentText, fyne.CurrentApp().Driver().AllWindows()[0])
}

// PythonEnv Pythonç¯å¢ƒä¿¡æ¯
type PythonEnv struct {
	Name    string // ç¯å¢ƒåç§° (conda env name æˆ– "System Python")
	Path    string // Pythonå¯æ‰§è¡Œæ–‡ä»¶è·¯å¾„
	Version string // Pythonç‰ˆæœ¬
	Type    string // ç¯å¢ƒç±»å‹ (conda, venv, system)
}

// FridaInfo Fridaå·¥å…·ä¿¡æ¯
type FridaInfo struct {
	Version     string // fridaç‰ˆæœ¬
	InstallPath string // å®‰è£…è·¯å¾„
	PatchStatus string // è¡¥ä¸çŠ¶æ€ (original, patched, unknown)
	BackupPath  string // å¤‡ä»½è·¯å¾„
}

// ToolsTab å·¥å…·æ ‡ç­¾é¡µ
type ToolsTab struct {
	app          fyne.App
	config       *config.Config
	updateStatus StatusUpdater
	addLog       func(string)
	content      *fyne.Container

	// UIç»„ä»¶
	pythonEnvSelect   *widget.Select
	refreshEnvBtn     *widget.Button
	envInfoLabel      *widget.Label
	fridaInfoLabel    *widget.Label
	fridaVersionLabel *widget.Label
	fridaPathLabel    *widget.Label
	patchStatusLabel  *widget.Label

	magicNameEntry *FixedWidthEntry
	portEntry      *FixedWidthEntry

	patchBtn   *widget.Button
	restoreBtn *widget.Button
	backupBtn  *widget.Button

	progressBar   *widget.ProgressBar
	progressLabel *widget.Label

	// æ•°æ®
	pythonEnvs  []PythonEnv
	currentEnv  *PythonEnv
	fridaInfo   *FridaInfo
	hexReplacer *core.HexReplacer
}

func NewToolsTab(cfg *config.Config, statusUpdater StatusUpdater) *ToolsTab {
	tt := &ToolsTab{
		config:       cfg,
		updateStatus: statusUpdater,
		addLog:       func(msg string) {}, // é»˜è®¤ç©ºå®ç°
		pythonEnvs:   []PythonEnv{},
		hexReplacer:  core.NewHexReplacer(),
	}

	tt.setupUI()
	return tt
}

// SetLogFunction è®¾ç½®æ—¥å¿—å‡½æ•°
func (tt *ToolsTab) SetLogFunction(addLog func(string)) {
	tt.addLog = addLog
}

func (tt *ToolsTab) setupUI() {
	// Pythonç¯å¢ƒé€‰æ‹©åŒºåŸŸ
	tt.pythonEnvSelect = widget.NewSelect([]string{"ç‚¹å‡»åˆ·æ–°æ‰«æPythonç¯å¢ƒ..."}, func(selected string) {
		tt.onPythonEnvSelected(selected)
	})
	tt.pythonEnvSelect.Resize(fyne.NewSize(300, 0))

	tt.refreshEnvBtn = widget.NewButton("åˆ·æ–°ç¯å¢ƒ", func() {
		tt.scanPythonEnvironments()
	})

	tt.envInfoLabel = widget.NewLabel("æœªé€‰æ‹©Pythonç¯å¢ƒ")
	tt.envInfoLabel.Wrapping = fyne.TextWrapWord

	environmentArea := widget.NewCard("Pythonç¯å¢ƒ", "", container.NewVBox(
		container.NewHBox(
			widget.NewLabel("é€‰æ‹©Pythonç¯å¢ƒ:"),
			tt.pythonEnvSelect,
			tt.refreshEnvBtn,
		),
		tt.envInfoLabel,
	))

	// frida-toolsä¿¡æ¯åŒºåŸŸ
	tt.fridaInfoLabel = widget.NewLabel("è¯·å…ˆé€‰æ‹©Pythonç¯å¢ƒ")
	tt.fridaVersionLabel = widget.NewLabel("ç‰ˆæœ¬: æœªçŸ¥")
	tt.fridaPathLabel = widget.NewLabel("è·¯å¾„: æœªçŸ¥")
	tt.patchStatusLabel = widget.NewLabel("çŠ¶æ€: æœªæ£€æµ‹")

	detectBtn := widget.NewButton("æ£€æµ‹frida-tools", func() {
		tt.detectFridaTools()
	})

	fridaInfoArea := widget.NewCard("frida-toolsä¿¡æ¯", "", container.NewVBox(
		container.NewHBox(detectBtn, tt.fridaInfoLabel),
		tt.fridaVersionLabel,
		tt.fridaPathLabel,
		tt.patchStatusLabel,
	))

	// é­”æ”¹é…ç½®åŒºåŸŸ
	tt.magicNameEntry = fixedWidthEntry(180, "é­”æ”¹åç§°")
	tt.magicNameEntry.SetText("fridare")

	// é­”æ”¹åç§°éªŒè¯å™¨
	tt.magicNameEntry.Validator = func(text string) error {
		if len(text) == 0 {
			return fmt.Errorf("é­”æ”¹åç§°ä¸èƒ½ä¸ºç©º")
		}
		if len(text) > 10 {
			return fmt.Errorf("é­”æ”¹åç§°ä¸èƒ½è¶…è¿‡10ä¸ªå­—ç¬¦")
		}
		// æ£€æŸ¥å­—ç¬¦åˆæ³•æ€§
		for i, c := range text {
			if !((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '_' || c == '-') {
				return fmt.Errorf("ç¬¬%dä¸ªå­—ç¬¦'%c'æ— æ•ˆï¼Œåªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿å’Œæ¨ªçº¿", i+1, c)
			}
		}
		return nil
	}

	tt.portEntry = fixedWidthEntry(160, "ç«¯å£")
	tt.portEntry.SetText("27042")
	tt.portEntry.Validator = func(text string) error {
		if port, err := strconv.Atoi(text); err != nil || port < 1 || port > 65535 {
			return fmt.Errorf("ç«¯å£å¿…é¡»åœ¨1-65535èŒƒå›´å†…")
		}
		return nil
	}

	// æ“ä½œæŒ‰é’®åŒºåŸŸ
	tt.patchBtn = widget.NewButton("æ‰§è¡Œé­”æ”¹", func() {
		tt.patchFridaTools()
	})
	tt.patchBtn.Importance = widget.HighImportance
	tt.patchBtn.Disable()

	tt.restoreBtn = widget.NewButton("æ¢å¤åŸç‰ˆ", func() {
		tt.restoreFridaTools()
	})
	tt.restoreBtn.Disable()

	tt.backupBtn = widget.NewButton("æ‰‹åŠ¨å¤‡ä»½", func() {
		tt.backupFridaTools()
	})
	tt.backupBtn.Disable()

	configArea := widget.NewCard("é­”æ”¹é…ç½®", "", container.NewVBox(
		container.NewHBox(
			widget.NewLabel("é­”æ”¹åç§°:"), tt.magicNameEntry,
			widget.NewLabel("é»˜è®¤ç«¯å£:"), tt.portEntry,
			tt.patchBtn,
			tt.restoreBtn,
			tt.backupBtn),
	))
	// è¿›åº¦æ˜¾ç¤º
	tt.progressBar = widget.NewProgressBar()
	tt.progressBar.Hide()

	tt.progressLabel = widget.NewLabel("")
	tt.progressLabel.Hide()

	progressArea := container.NewVBox(
		tt.progressBar,
		tt.progressLabel,
	)

	// ä¸»å¸ƒå±€
	tt.content = container.NewVBox(
		container.NewGridWithColumns(2,
			environmentArea,
			fridaInfoArea),
		configArea,
		progressArea,
	)

	// åˆå§‹æ‰«æPythonç¯å¢ƒ
	go tt.scanPythonEnvironments()
}

// scanPythonEnvironments æ‰«æPythonç¯å¢ƒ
func (tt *ToolsTab) scanPythonEnvironments() {
	tt.updateStatus("æ­£åœ¨æ‰«æPythonç¯å¢ƒ...")
	tt.addLog("INFO: å¼€å§‹æ‰«æPythonç¯å¢ƒ")

	var envs []PythonEnv

	// æ‰«æcondaç¯å¢ƒ
	condaEnvs := tt.scanCondaEnvironments()
	envs = append(envs, condaEnvs...)

	// æ‰«æç³»ç»ŸPython
	systemPython := tt.scanSystemPython()
	if systemPython != nil {
		envs = append(envs, *systemPython)
	}

	// æ‰«ævenvç¯å¢ƒ (å¯é€‰ï¼Œå…ˆä¸å®ç°)

	tt.pythonEnvs = envs

	// æ›´æ–°UI
	fyne.Do(func() {
		if len(envs) == 0 {
			tt.pythonEnvSelect.Options = []string{"æœªæ‰¾åˆ°Pythonç¯å¢ƒ"}
			tt.envInfoLabel.SetText("æœªæ‰¾åˆ°å¯ç”¨çš„Pythonç¯å¢ƒ")
			tt.updateStatus("æœªæ‰¾åˆ°Pythonç¯å¢ƒ")
		} else {
			options := make([]string, len(envs))
			for i, env := range envs {
				options[i] = fmt.Sprintf("%s (%s)", env.Name, env.Type)
			}
			tt.pythonEnvSelect.Options = options
			tt.pythonEnvSelect.Refresh()
			tt.updateStatus(fmt.Sprintf("æ‰¾åˆ° %d ä¸ªPythonç¯å¢ƒ", len(envs)))
			tt.addLog(fmt.Sprintf("INFO: æ‰¾åˆ° %d ä¸ªPythonç¯å¢ƒ", len(envs)))
		}
	})
}

// scanCondaEnvironments æ‰«æcondaç¯å¢ƒ
func (tt *ToolsTab) scanCondaEnvironments() []PythonEnv {
	var envs []PythonEnv

	// æ‰§è¡Œconda env listå‘½ä»¤
	cmd := exec.Command("conda", "env", "list", "--json")
	hideConsoleCmd(cmd)
	output, err := cmd.Output()
	if err != nil {
		tt.addLog("INFO: æœªæ‰¾åˆ°condaç¯å¢ƒ")
		return envs
	}

	// è§£æJSONè¾“å‡º
	var condaInfo struct {
		Envs []string `json:"envs"`
	}

	if err := json.Unmarshal(output, &condaInfo); err != nil {
		tt.addLog("ERROR: è§£æcondaç¯å¢ƒä¿¡æ¯å¤±è´¥: " + err.Error())
		return envs
	}

	// è·å–æ¯ä¸ªç¯å¢ƒçš„è¯¦ç»†ä¿¡æ¯
	for _, envPath := range condaInfo.Envs {
		pythonPath := filepath.Join(envPath, "python")
		if runtime.GOOS == "windows" {
			pythonPath = filepath.Join(envPath, "python.exe")
		}

		// æ£€æŸ¥pythonå¯æ‰§è¡Œæ–‡ä»¶æ˜¯å¦å­˜åœ¨
		if _, err := os.Stat(pythonPath); os.IsNotExist(err) {
			continue
		}

		// è·å–ç¯å¢ƒåç§°
		envName := filepath.Base(envPath)
		if envName == "." {
			envName = "base"
		}

		// è·å–Pythonç‰ˆæœ¬
		versionCmd := exec.Command(pythonPath, "--version")
		hideConsoleCmd(versionCmd)
		versionOutput, err := versionCmd.Output()
		version := "æœªçŸ¥"
		if err == nil {
			version = strings.TrimSpace(string(versionOutput))
		}

		env := PythonEnv{
			Name:    envName,
			Path:    pythonPath,
			Version: version,
			Type:    "conda",
		}
		envs = append(envs, env)
		tt.addLog(fmt.Sprintf("INFO: æ‰¾åˆ°condaç¯å¢ƒ: %s (%s)", envName, version))
	}

	return envs
}

// scanSystemPython æ‰«æç³»ç»ŸPython
func (tt *ToolsTab) scanSystemPython() *PythonEnv {
	// å°è¯•æ‰¾åˆ°ç³»ç»ŸPython
	pythonCmds := []string{"python", "python3"}

	for _, cmd := range pythonCmds {
		pythonPath, err := exec.LookPath(cmd)
		if err != nil {
			continue
		}

		// è·å–Pythonç‰ˆæœ¬
		versionCmd := exec.Command(pythonPath, "--version")
		hideConsoleCmd(versionCmd)
		versionOutput, err := versionCmd.Output()
		version := "æœªçŸ¥"
		if err == nil {
			version = strings.TrimSpace(string(versionOutput))
		}

		env := &PythonEnv{
			Name:    "System Python",
			Path:    pythonPath,
			Version: version,
			Type:    "system",
		}

		tt.addLog(fmt.Sprintf("INFO: æ‰¾åˆ°ç³»ç»ŸPython: %s", version))
		return env
	}

	return nil
}

// onPythonEnvSelected Pythonç¯å¢ƒé€‰æ‹©å›è°ƒ
func (tt *ToolsTab) onPythonEnvSelected(selected string) {
	if selected == "" || selected == "æœªæ‰¾åˆ°Pythonç¯å¢ƒ" {
		return
	}

	// ä»é€‰æ‹©çš„å­—ç¬¦ä¸²ä¸­æ‰¾åˆ°å¯¹åº”çš„ç¯å¢ƒ
	for _, env := range tt.pythonEnvs {
		expectedText := fmt.Sprintf("%s (%s)", env.Name, env.Type)
		if expectedText == selected {
			tt.currentEnv = &env

			// æ›´æ–°ç¯å¢ƒä¿¡æ¯æ˜¾ç¤º
			tt.envInfoLabel.SetText(fmt.Sprintf("ç¯å¢ƒ: %s\nç‰ˆæœ¬: %s\nè·¯å¾„: %s",
				env.Name, env.Version, env.Path))

			tt.updateStatus(fmt.Sprintf("å·²é€‰æ‹©Pythonç¯å¢ƒ: %s", env.Name))
			tt.addLog(fmt.Sprintf("INFO: åˆ‡æ¢åˆ°Pythonç¯å¢ƒ: %s", env.Name))

			// å¯ç”¨æ£€æµ‹æŒ‰é’®
			// è‡ªåŠ¨æ£€æµ‹frida-tools
			go tt.detectFridaTools()
			break
		}
	}
}

// detectFridaTools æ£€æµ‹frida-toolsä¿¡æ¯
func (tt *ToolsTab) detectFridaTools() {
	if tt.currentEnv == nil {
		tt.updateStatus("è¯·å…ˆé€‰æ‹©Pythonç¯å¢ƒ")
		return
	}

	fyne.Do(func() {
		tt.fridaInfoLabel.SetText("æœªå®‰è£…frida-tools")
		tt.fridaVersionLabel.SetText("ç‰ˆæœ¬: æœªå®‰è£…")
		tt.fridaPathLabel.SetText("è·¯å¾„: æ— ")
		tt.patchStatusLabel.SetText("çŠ¶æ€: æœªå®‰è£…")
		tt.patchBtn.Disable()
		tt.restoreBtn.Disable()
		tt.backupBtn.Disable()
	})
	tt.updateStatus("æ­£åœ¨æ£€æµ‹frida-tools...")
	tt.addLog("INFO: å¼€å§‹æ£€æµ‹frida-tools")

	// ä½¿ç”¨é€‰å®šçš„Pythonç¯å¢ƒæ‰§è¡Œpip show frida
	var cmd *exec.Cmd
	if tt.currentEnv.Type == "conda" {
		// condaç¯å¢ƒéœ€è¦æ¿€æ´»
		envName := tt.currentEnv.Name
		if envName == "base" {
			cmd = exec.Command("conda", "run", "-n", "base", "pip", "show", "frida")
		} else {
			cmd = exec.Command("conda", "run", "-n", envName, "pip", "show", "frida")
		}
	} else {
		// ç³»ç»ŸPythonç›´æ¥ä½¿ç”¨pip
		cmd = exec.Command(tt.currentEnv.Path, "-m", "pip", "show", "frida")
	}
	hideConsoleCmd(cmd)

	output, err := cmd.Output()
	if err != nil {
		tt.updateStatus("æœªæ£€æµ‹åˆ°frida-tools")
		tt.addLog("ERROR: æœªæ£€æµ‹åˆ°frida-tools: " + err.Error())
		return
	}

	// è§£æpip showè¾“å‡º
	lines := strings.Split(string(output), "\n")
	var version, location string

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "Version:") {
			version = strings.TrimSpace(strings.TrimPrefix(line, "Version:"))
		} else if strings.HasPrefix(line, "Location:") {
			location = strings.TrimSpace(strings.TrimPrefix(line, "Location:"))
		}
	}

	if version == "" || location == "" {
		tt.updateStatus("æ— æ³•è·å–frida-toolsä¿¡æ¯")
		tt.addLog("ERROR: æ— æ³•è§£æfrida-toolsä¿¡æ¯")
		return
	}

	// æ£€æµ‹patchçŠ¶æ€
	fridaPath := filepath.Join(location, "frida")
	patchStatus := tt.checkPatchStatus(fridaPath)
	backupPath := filepath.Join(fridaPath, "_original_backup")

	tt.fridaInfo = &FridaInfo{
		Version:     version,
		InstallPath: fridaPath,
		PatchStatus: patchStatus,
		BackupPath:  backupPath,
	}

	// æ›´æ–°UI
	fyne.Do(func() {
		tt.fridaInfoLabel.SetText("å·²æ£€æµ‹åˆ°frida-tools")
		tt.fridaVersionLabel.SetText("ç‰ˆæœ¬: " + version)
		tt.fridaPathLabel.SetText("è·¯å¾„: " + fridaPath)
		tt.patchStatusLabel.SetText("çŠ¶æ€: " + patchStatus)

		// æ ¹æ®çŠ¶æ€å¯ç”¨/ç¦ç”¨æŒ‰é’®
		if patchStatus == "original" {
			tt.patchBtn.Enable()
			tt.restoreBtn.Disable()
			tt.backupBtn.Enable()
		} else if patchStatus == "patched" {
			tt.patchBtn.Disable()
			tt.restoreBtn.Enable()
			tt.backupBtn.Disable()
		} else {
			tt.patchBtn.Enable()
			tt.restoreBtn.Disable()
			tt.backupBtn.Enable()
		}
	})

	tt.updateStatus("frida-toolsæ£€æµ‹å®Œæˆ")
	tt.addLog(fmt.Sprintf("INFO: frida-tools v%s æ£€æµ‹å®Œæˆï¼ŒçŠ¶æ€: %s", version, patchStatus))
}

// checkPatchStatus æ£€æŸ¥patchçŠ¶æ€
func (tt *ToolsTab) checkPatchStatus(fridaPath string) string {
	// æ£€æŸ¥å¤‡ä»½ç›®å½•æ˜¯å¦å­˜åœ¨
	backupPath := filepath.Join(fridaPath, "_original_backup")
	if _, err := os.Stat(backupPath); err == nil {
		return "patched"
	}

	// æ£€æŸ¥å…³é”®æ–‡ä»¶æ˜¯å¦åŒ…å«fridaå­—ç¬¦ä¸² (ç®€å•æ£€æµ‹)
	coreFile := filepath.Join(fridaPath, "_frida.py")
	if _, err := os.Stat(coreFile); err == nil {
		content, err := os.ReadFile(coreFile)
		if err == nil {
			contentStr := string(content)
			// å¦‚æœåŒ…å«é»˜è®¤çš„fridaå­—ç¬¦ä¸²ï¼Œè®¤ä¸ºæ˜¯åŸç‰ˆ
			if strings.Contains(contentStr, "frida-server") && !strings.Contains(contentStr, "fridare") {
				return "original"
			} else if strings.Contains(contentStr, "fridare") {
				return "patched"
			}
		}
	}

	return "unknown"
}

// patchFridaTools æ‰§è¡Œfrida-toolsé­”æ”¹
func (tt *ToolsTab) patchFridaTools() {
	if tt.currentEnv == nil || tt.fridaInfo == nil {
		tt.updateStatus("è¯·å…ˆé€‰æ‹©Pythonç¯å¢ƒå¹¶æ£€æµ‹frida-tools")
		return
	}

	magicName := strings.TrimSpace(tt.magicNameEntry.Text)
	port := strings.TrimSpace(tt.portEntry.Text)

	// éªŒè¯è¾“å…¥
	if err := tt.magicNameEntry.Validator(magicName); err != nil {
		tt.updateStatus("é­”æ”¹åç§°é”™è¯¯: " + err.Error())
		return
	}
	if err := tt.portEntry.Validator(port); err != nil {
		tt.updateStatus("ç«¯å£é”™è¯¯: " + err.Error())
		return
	}

	tt.updateStatus("å¼€å§‹æ‰§è¡Œfrida-toolsé­”æ”¹...")
	tt.addLog(fmt.Sprintf("INFO: å¼€å§‹é­”æ”¹frida-toolsï¼Œé­”æ”¹åç§°: %s, ç«¯å£: %s", magicName, port))

	// æ˜¾ç¤ºè¿›åº¦
	fyne.Do(func() {
		tt.progressBar.Show()
		tt.progressLabel.Show()
		tt.progressLabel.SetText("æ­£åœ¨åˆ›å»ºå¤‡ä»½...")
		tt.progressBar.SetValue(0.1)
		tt.patchBtn.Disable()
	})

	go func() {
		// 1. åˆ›å»ºå¤‡ä»½
		if err := tt.createBackup(); err != nil {
			fyne.Do(func() {
				tt.progressBar.Hide()
				tt.progressLabel.Hide()
				tt.patchBtn.Enable()
			})
			tt.updateStatus("åˆ›å»ºå¤‡ä»½å¤±è´¥: " + err.Error())
			tt.addLog("ERROR: åˆ›å»ºå¤‡ä»½å¤±è´¥: " + err.Error())
			return
		}

		fyne.Do(func() {
			tt.progressLabel.SetText("æ­£åœ¨æ‰§è¡Œé­”æ”¹...")
			tt.progressBar.SetValue(0.5)
		})

		// 2. æ‰§è¡Œé­”æ”¹
		if err := tt.performPatch(magicName, port); err != nil {
			fyne.Do(func() {
				tt.progressBar.Hide()
				tt.progressLabel.Hide()
				tt.patchBtn.Enable()
			})
			tt.updateStatus("é­”æ”¹å¤±è´¥: " + err.Error())
			tt.addLog("ERROR: é­”æ”¹å¤±è´¥: " + err.Error())
			return
		}

		fyne.Do(func() {
			tt.progressLabel.SetText("é­”æ”¹å®Œæˆ!")
			tt.progressBar.SetValue(1.0)

			// å»¶è¿Ÿéšè—è¿›åº¦æ¡
			time.AfterFunc(2*time.Second, func() {
				fyne.Do(func() {
					tt.progressBar.Hide()
					tt.progressLabel.Hide()
				})
			})

			// æ›´æ–°æŒ‰é’®çŠ¶æ€
			tt.patchBtn.Disable()
			tt.restoreBtn.Enable()
			tt.backupBtn.Disable()

			// æ›´æ–°çŠ¶æ€æ˜¾ç¤º
			tt.patchStatusLabel.SetText("çŠ¶æ€: patched")
		})

		tt.updateStatus("frida-toolsé­”æ”¹å®Œæˆ!")
		tt.addLog("SUCCESS: frida-toolsé­”æ”¹å®Œæˆ")
	}()
}

// createBackup åˆ›å»ºå¤‡ä»½
func (tt *ToolsTab) createBackup() error {
	backupPath := tt.fridaInfo.BackupPath

	// å¦‚æœå¤‡ä»½å·²å­˜åœ¨ï¼Œè·³è¿‡
	if _, err := os.Stat(backupPath); err == nil {
		tt.addLog("INFO: å¤‡ä»½å·²å­˜åœ¨ï¼Œè·³è¿‡åˆ›å»ºå¤‡ä»½")
		return nil
	}

	// åˆ›å»ºå¤‡ä»½ç›®å½•
	if err := os.MkdirAll(backupPath, 0755); err != nil {
		return fmt.Errorf("åˆ›å»ºå¤‡ä»½ç›®å½•å¤±è´¥: %v", err)
	}

	// å¤åˆ¶å…³é”®æ–‡ä»¶
	filesToBackup := []string{
		"_frida.py",
		"core.py",
		"__init__.py",
	}

	for _, file := range filesToBackup {
		srcPath := filepath.Join(tt.fridaInfo.InstallPath, file)
		dstPath := filepath.Join(backupPath, file)

		if _, err := os.Stat(srcPath); err == nil {
			if err := tt.copyFile(srcPath, dstPath); err != nil {
				return fmt.Errorf("å¤‡ä»½æ–‡ä»¶ %s å¤±è´¥: %v", file, err)
			}
			tt.addLog(fmt.Sprintf("INFO: å·²å¤‡ä»½æ–‡ä»¶: %s", file))
		}
	}

	tt.addLog("INFO: å¤‡ä»½åˆ›å»ºå®Œæˆ")
	return nil
}

// copyFile å¤åˆ¶æ–‡ä»¶
func (tt *ToolsTab) copyFile(src, dst string) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	dstFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer dstFile.Close()

	_, err = io.Copy(dstFile, srcFile)
	return err
}

// performPatch æ‰§è¡Œé­”æ”¹
func (tt *ToolsTab) performPatch(magicName, port string) error {
	// 1. Pythonä»£ç å­—ç¬¦ä¸²é­”æ”¹
	if err := tt.patchPythonFiles(magicName, port); err != nil {
		return fmt.Errorf("Pythonæ–‡ä»¶é­”æ”¹å¤±è´¥: %v", err)
	}

	// 2. SOæ–‡ä»¶äºŒè¿›åˆ¶é­”æ”¹
	if err := tt.patchSOFiles(magicName, port); err != nil {
		return fmt.Errorf("SOæ–‡ä»¶é­”æ”¹å¤±è´¥: %v", err)
	}

	return nil
}

// patchPythonFiles é­”æ”¹Pythonæ–‡ä»¶
func (tt *ToolsTab) patchPythonFiles(magicName, port string) error {
	// å®šä¹‰è¦é­”æ”¹çš„æ–‡ä»¶å’Œæ›¿æ¢è§„åˆ™
	patchRules := map[string]map[string]string{
		"_frida.py": {
			"frida-server": magicName + "-server",
			"frida-agent":  magicName + "-agent",
			"27042":        port,
			"frida":        magicName,
		},
		"core.py": {
			"frida-server": magicName + "-server",
			"frida-agent":  magicName + "-agent",
			"frida":        magicName,
			"27042":        port,
		},
		"__init__.py": {
			"frida": magicName,
		},
	}

	for file, rules := range patchRules {
		filePath := filepath.Join(tt.fridaInfo.InstallPath, file)

		// æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
		if _, err := os.Stat(filePath); os.IsNotExist(err) {
			tt.addLog(fmt.Sprintf("WARN: Pythonæ–‡ä»¶ä¸å­˜åœ¨ï¼Œè·³è¿‡: %s", file))
			continue
		}

		// è¯»å–æ–‡ä»¶å†…å®¹
		content, err := os.ReadFile(filePath)
		if err != nil {
			return fmt.Errorf("è¯»å–æ–‡ä»¶ %s å¤±è´¥: %v", file, err)
		}

		contentStr := string(content)
		originalContent := contentStr

		// åº”ç”¨æ›¿æ¢è§„åˆ™
		for oldStr, newStr := range rules {
			if strings.Contains(contentStr, oldStr) {
				contentStr = strings.ReplaceAll(contentStr, oldStr, newStr)
				tt.addLog(fmt.Sprintf("INFO: æ›¿æ¢ '%s' -> '%s' åœ¨æ–‡ä»¶ %s", oldStr, newStr, file))
			}
		}

		// å¦‚æœå†…å®¹æœ‰å˜åŒ–ï¼Œå†™å›æ–‡ä»¶
		if contentStr != originalContent {
			if err := os.WriteFile(filePath, []byte(contentStr), 0644); err != nil {
				return fmt.Errorf("å†™å…¥æ–‡ä»¶ %s å¤±è´¥: %v", file, err)
			}
			tt.addLog(fmt.Sprintf("SUCCESS: å·²é­”æ”¹Pythonæ–‡ä»¶: %s", file))
		} else {
			tt.addLog(fmt.Sprintf("INFO: Pythonæ–‡ä»¶æ— éœ€ä¿®æ”¹: %s", file))
		}
	}

	return nil
}

// patchSOFiles é­”æ”¹SOæ–‡ä»¶
func (tt *ToolsTab) patchSOFiles(magicName, port string) error {
	// æŸ¥æ‰¾SOæ–‡ä»¶
	soFiles, err := tt.findSOFiles()
	if err != nil {
		return fmt.Errorf("æŸ¥æ‰¾SOæ–‡ä»¶å¤±è´¥: %v", err)
	}

	if len(soFiles) == 0 {
		tt.addLog("INFO: æœªæ‰¾åˆ°SOæ–‡ä»¶ï¼Œè·³è¿‡äºŒè¿›åˆ¶é­”æ”¹")
		return nil
	}

	// ä½¿ç”¨hexreplaceå·¥å…·è¿›è¡ŒäºŒè¿›åˆ¶æ›¿æ¢
	for _, soFile := range soFiles {
		if err := tt.patchSingleSOFile(soFile, magicName, port); err != nil {
			tt.addLog(fmt.Sprintf("WARN: SOæ–‡ä»¶é­”æ”¹å¤±è´¥: %s, é”™è¯¯: %v", soFile, err))
			continue
		}
		tt.addLog(fmt.Sprintf("SUCCESS: å·²é­”æ”¹SOæ–‡ä»¶: %s", soFile))
	}

	return nil
}

// findSOFiles æŸ¥æ‰¾SOæ–‡ä»¶
func (tt *ToolsTab) findSOFiles() ([]string, error) {
	var soFiles []string

	// éå†fridaå®‰è£…ç›®å½•
	err := filepath.Walk(tt.fridaInfo.InstallPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return nil // å¿½ç•¥é”™è¯¯ï¼Œç»§ç»­éå†
		}

		// æŸ¥æ‰¾.soã€.dllã€.dylibæ–‡ä»¶
		ext := strings.ToLower(filepath.Ext(path))
		if ext == ".so" || ext == ".dll" || ext == ".dylib" || ext == ".pyd" {
			soFiles = append(soFiles, path)
		}

		return nil
	})

	return soFiles, err
}

// patchSingleSOFile é­”æ”¹å•ä¸ªSOæ–‡ä»¶
func (tt *ToolsTab) patchSingleSOFile(soFile, magicName, port string) error {
	// ä½¿ç”¨HexReplacerè¿›è¡Œä¸“ä¸šçš„äºŒè¿›åˆ¶é­”æ”¹
	// HexReplacerä¼šè‡ªåŠ¨å¤„ç†æ‰€æœ‰fridaç›¸å…³çš„å­—ç¬¦ä¸²æ›¿æ¢
	if err := tt.hexReplace(soFile, "", magicName); err != nil {
		return fmt.Errorf("é­”æ”¹SOæ–‡ä»¶å¤±è´¥: %v", err)
	}

	tt.addLog(fmt.Sprintf("SUCCESS: å·²é­”æ”¹SOæ–‡ä»¶: %s", soFile))
	return nil
}

// hexReplace æ‰§è¡Œåå…­è¿›åˆ¶æ›¿æ¢ - ä½¿ç”¨HexReplacerè¿›è¡Œä¸“ä¸šçš„äºŒè¿›åˆ¶é­”æ”¹
func (tt *ToolsTab) hexReplace(filePath, oldStr, newStr string) error {
	// æ£€æŸ¥æ–°å­—ç¬¦ä¸²é•¿åº¦ï¼ˆé­”æ”¹åç§°å¿…é¡»æ˜¯5ä¸ªå­—ç¬¦ï¼‰
	if len(newStr) != 5 {
		return fmt.Errorf("é­”æ”¹åç§°å¿…é¡»æ˜¯5ä¸ªå­—ç¬¦ï¼Œå½“å‰ä¸º: %s (%då­—ç¬¦)", newStr, len(newStr))
	}

	// åˆ›å»ºä¸´æ—¶è¾“å‡ºæ–‡ä»¶
	tempFile := filePath + ".tmp"

	// ä½¿ç”¨HexReplacerè¿›è¡Œä¸“ä¸šçš„äºŒè¿›åˆ¶é­”æ”¹
	err := tt.hexReplacer.PatchFile(filePath, newStr, tempFile, func(progress float64, status string) {
		// å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ è¿›åº¦å›è°ƒï¼Œä½†å¯¹äºSOæ–‡ä»¶é­”æ”¹æˆ‘ä»¬ç®€åŒ–å¤„ç†
		tt.addLog(fmt.Sprintf("INFO: %s (%.1f%%)", status, progress*100))
	})

	if err != nil {
		// æ¸…ç†ä¸´æ—¶æ–‡ä»¶
		os.Remove(tempFile)
		return fmt.Errorf("HexReplaceré­”æ”¹å¤±è´¥: %v", err)
	}

	// æ›¿æ¢åŸæ–‡ä»¶
	if err := os.Rename(tempFile, filePath); err != nil {
		os.Remove(tempFile)
		return fmt.Errorf("æ›¿æ¢åŸæ–‡ä»¶å¤±è´¥: %v", err)
	}

	return nil
}

// restoreFridaTools æ¢å¤åŸç‰ˆfrida-tools
func (tt *ToolsTab) restoreFridaTools() {
	if tt.fridaInfo == nil {
		tt.updateStatus("è¯·å…ˆæ£€æµ‹frida-tools")
		return
	}

	tt.updateStatus("å¼€å§‹æ¢å¤åŸç‰ˆfrida-tools...")
	tt.addLog("INFO: å¼€å§‹æ¢å¤åŸç‰ˆfrida-tools")

	// æ˜¾ç¤ºè¿›åº¦
	fyne.Do(func() {
		tt.progressBar.Show()
		tt.progressLabel.Show()
		tt.progressLabel.SetText("æ­£åœ¨æ¢å¤åŸç‰ˆ...")
		tt.progressBar.SetValue(0.2)
		tt.restoreBtn.Disable()
	})

	go func() {
		if err := tt.performRestore(); err != nil {
			fyne.Do(func() {
				tt.progressBar.Hide()
				tt.progressLabel.Hide()
				tt.restoreBtn.Enable()
			})
			tt.updateStatus("æ¢å¤å¤±è´¥: " + err.Error())
			tt.addLog("ERROR: æ¢å¤å¤±è´¥: " + err.Error())
			return
		}

		fyne.Do(func() {
			tt.progressLabel.SetText("æ¢å¤å®Œæˆ!")
			tt.progressBar.SetValue(1.0)

			// å»¶è¿Ÿéšè—è¿›åº¦æ¡
			time.AfterFunc(2*time.Second, func() {
				fyne.Do(func() {
					tt.progressBar.Hide()
					tt.progressLabel.Hide()
				})
			})

			// æ›´æ–°æŒ‰é’®çŠ¶æ€
			tt.patchBtn.Enable()
			tt.restoreBtn.Disable()
			tt.backupBtn.Enable()

			// æ›´æ–°çŠ¶æ€æ˜¾ç¤º
			tt.patchStatusLabel.SetText("çŠ¶æ€: original")
		})

		tt.updateStatus("frida-toolsæ¢å¤å®Œæˆ!")
		tt.addLog("SUCCESS: frida-toolsæ¢å¤å®Œæˆ")
	}()
}

// performRestore æ‰§è¡Œæ¢å¤
func (tt *ToolsTab) performRestore() error {
	backupPath := tt.fridaInfo.BackupPath

	// æ£€æŸ¥å¤‡ä»½æ˜¯å¦å­˜åœ¨
	if _, err := os.Stat(backupPath); os.IsNotExist(err) {
		return fmt.Errorf("å¤‡ä»½ä¸å­˜åœ¨: %s", backupPath)
	}

	// æ¢å¤å¤‡ä»½çš„æ–‡ä»¶
	files, err := os.ReadDir(backupPath)
	if err != nil {
		return fmt.Errorf("è¯»å–å¤‡ä»½ç›®å½•å¤±è´¥: %v", err)
	}

	fyne.Do(func() {
		tt.progressBar.SetValue(0.5)
	})

	for _, file := range files {
		if file.IsDir() {
			continue
		}

		srcPath := filepath.Join(backupPath, file.Name())
		dstPath := filepath.Join(tt.fridaInfo.InstallPath, file.Name())

		if err := tt.copyFile(srcPath, dstPath); err != nil {
			return fmt.Errorf("æ¢å¤æ–‡ä»¶ %s å¤±è´¥: %v", file.Name(), err)
		}
		tt.addLog(fmt.Sprintf("INFO: å·²æ¢å¤æ–‡ä»¶: %s", file.Name()))
	}

	// åˆ é™¤å¤‡ä»½ç›®å½•
	if err := os.RemoveAll(backupPath); err != nil {
		tt.addLog(fmt.Sprintf("WARN: åˆ é™¤å¤‡ä»½ç›®å½•å¤±è´¥: %v", err))
	} else {
		tt.addLog("INFO: å·²åˆ é™¤å¤‡ä»½ç›®å½•")
	}

	return nil
}

// backupFridaTools æ‰‹åŠ¨å¤‡ä»½
func (tt *ToolsTab) backupFridaTools() {
	if tt.fridaInfo == nil {
		tt.updateStatus("è¯·å…ˆæ£€æµ‹frida-tools")
		return
	}

	tt.updateStatus("å¼€å§‹æ‰‹åŠ¨å¤‡ä»½...")
	tt.addLog("INFO: å¼€å§‹æ‰‹åŠ¨å¤‡ä»½")

	go func() {
		if err := tt.createBackup(); err != nil {
			tt.updateStatus("æ‰‹åŠ¨å¤‡ä»½å¤±è´¥: " + err.Error())
			tt.addLog("ERROR: æ‰‹åŠ¨å¤‡ä»½å¤±è´¥: " + err.Error())
		} else {
			tt.updateStatus("æ‰‹åŠ¨å¤‡ä»½å®Œæˆ")
			tt.addLog("SUCCESS: æ‰‹åŠ¨å¤‡ä»½å®Œæˆ")
		}
	}()
}

func (tt *ToolsTab) Content() *fyne.Container {
	return tt.content
}

func (tt *ToolsTab) Refresh() {
	// åˆ·æ–°é€»è¾‘
}

// UpdateGlobalConfig æ›´æ–°å…¨å±€é…ç½®
func (tt *ToolsTab) UpdateGlobalConfig(magicName string, port int) {
	if tt.magicNameEntry != nil {
		tt.magicNameEntry.SetText(magicName)
	}
	if tt.portEntry != nil {
		tt.portEntry.SetText(fmt.Sprintf("%d", port))
	}
}

// SettingsTab è®¾ç½®æ ‡ç­¾é¡µ
type SettingsTab struct {
	config       *config.Config
	updateStatus StatusUpdater
	applyTheme   func()
	content      *fyne.Container
	window       fyne.Window // æ·»åŠ çª—å£å¼•ç”¨

	// å…¨å±€é…ç½®ç»„ä»¶
	appVersionEntry *FixedWidthEntry
	workDirEntry    *FixedWidthEntry

	// ç½‘ç»œé…ç½®ç»„ä»¶
	proxyEntry   *FixedWidthEntry
	timeoutEntry *FixedWidthEntry
	retriesEntry *FixedWidthEntry

	// Fridaé…ç½®ç»„ä»¶
	defaultPortEntry *FixedWidthEntry
	magicNameEntry   *FixedWidthEntry
	autoConfirmCheck *widget.Check

	// UIé…ç½®ç»„ä»¶
	themeSelect       *widget.Select
	windowWidthEntry  *FixedWidthEntry
	windowHeightEntry *FixedWidthEntry
	debugModeCheck    *widget.Check
	noShowNoticeCheck *widget.Check

	// ä¸‹è½½é…ç½®ç»„ä»¶
	downloadDirEntry         *FixedWidthEntry
	concurrentDownloadsEntry *FixedWidthEntry

	// æ“ä½œæŒ‰é’®
	saveBtn   *widget.Button
	resetBtn  *widget.Button
	importBtn *widget.Button
	exportBtn *widget.Button
}

func NewSettingsTab(cfg *config.Config, statusUpdater StatusUpdater, themeApplier func(), window fyne.Window) *SettingsTab {
	st := &SettingsTab{
		config:       cfg,
		updateStatus: statusUpdater,
		applyTheme:   themeApplier,
		window:       window,
	}

	st.setupUI()
	return st
}
func (st *SettingsTab) RefreshConfigDisplay() {
	// åˆ·æ–°é…ç½®æ˜¾ç¤º
	if st.appVersionEntry != nil {
		st.appVersionEntry.SetText(st.config.AppVersion)
	}
	if st.workDirEntry != nil {
		st.workDirEntry.SetText(st.config.WorkDir)
	}
	if st.proxyEntry != nil {
		st.proxyEntry.SetText(st.config.Proxy)
	}
	if st.timeoutEntry != nil {
		st.timeoutEntry.SetText(fmt.Sprintf("%d", st.config.Timeout))
	}
	if st.retriesEntry != nil {
		st.retriesEntry.SetText(fmt.Sprintf("%d", st.config.Retries))
	}
	if st.defaultPortEntry != nil {
		st.defaultPortEntry.SetText(fmt.Sprintf("%d", st.config.DefaultPort))
	}
	if st.magicNameEntry != nil {
		st.magicNameEntry.SetText(st.config.MagicName)
	}
	if st.autoConfirmCheck != nil {
		st.autoConfirmCheck.SetChecked(st.config.AutoConfirm)
	}
	if st.themeSelect != nil {
		st.themeSelect.SetSelected(st.config.Theme)
	}
	if st.windowWidthEntry != nil {
		st.windowWidthEntry.SetText(fmt.Sprintf("%d", st.config.WindowWidth))
	}
	if st.windowHeightEntry != nil {
		st.windowHeightEntry.SetText(fmt.Sprintf("%d", st.config.WindowHeight))
	}
	if st.debugModeCheck != nil {
		st.debugModeCheck.SetChecked(st.config.DebugMode)
	}
	if st.noShowNoticeCheck != nil {
		st.noShowNoticeCheck.SetChecked(st.config.NoShowNotice)
	}
}

func (st *SettingsTab) setupUI() {
	// å…¨å±€é…ç½®åŒºåŸŸ
	st.appVersionEntry = fixedWidthEntry(120, "ç‰ˆæœ¬å·")
	st.appVersionEntry.SetText(st.config.AppVersion)
	st.appVersionEntry.Disable() // ç‰ˆæœ¬å·åªè¯»
	st.workDirEntry = fixedWidthEntry(300, "å·¥ä½œç›®å½•è·¯å¾„")
	st.workDirEntry.SetText(st.config.WorkDir)

	workDirBtn := widget.NewButton("é€‰æ‹©", st.selectWorkDir)

	globalConfigSection := widget.NewCard("ğŸ”§ å…¨å±€é…ç½®", "", container.NewVBox(
		container.NewHBox(
			widget.NewLabel("åº”ç”¨ç‰ˆæœ¬:"), st.appVersionEntry,
			widget.NewLabel("   "), // é—´è·
		),
		container.NewHBox(
			widget.NewLabel("å·¥ä½œç›®å½•:"), st.workDirEntry, workDirBtn,
		),
	))

	// ç½‘ç»œé…ç½®åŒºåŸŸ
	st.proxyEntry = fixedWidthEntry(300, "http://proxy:port")
	st.proxyEntry.SetText(st.config.Proxy)

	st.timeoutEntry = fixedWidthEntry(80, "ç§’")
	st.timeoutEntry.SetText(fmt.Sprintf("%d", st.config.Timeout))
	st.timeoutEntry.Validator = func(text string) error {
		if val, err := strconv.Atoi(text); err != nil || val < 5 || val > 300 {
			return fmt.Errorf("è¶…æ—¶æ—¶é—´å¿…é¡»åœ¨5-300ç§’ä¹‹é—´")
		}
		return nil
	}

	st.retriesEntry = fixedWidthEntry(80, "æ¬¡")
	st.retriesEntry.SetText(fmt.Sprintf("%d", st.config.Retries))
	st.retriesEntry.Validator = func(text string) error {
		if val, err := strconv.Atoi(text); err != nil || val < 0 || val > 10 {
			return fmt.Errorf("é‡è¯•æ¬¡æ•°å¿…é¡»åœ¨0-10æ¬¡ä¹‹é—´")
		}
		return nil
	}

	proxyTestBtn := widget.NewButton("æµ‹è¯•", st.testProxy)

	networkConfigSection := widget.NewCard("ğŸŒ ç½‘ç»œé…ç½®", "", container.NewVBox(
		container.NewHBox(
			widget.NewLabel("ä»£ç†æœåŠ¡å™¨:"), st.proxyEntry, proxyTestBtn,
		),
		container.NewHBox(
			widget.NewLabel("è¶…æ—¶æ—¶é—´:"), st.timeoutEntry,
			widget.NewLabel("   é‡è¯•æ¬¡æ•°:"), st.retriesEntry,
		),
		widget.NewLabel("è¯´æ˜: ä»£ç†è®¾ç½®å½±å“fridaä¸‹è½½ï¼Œè¶…æ—¶å’Œé‡è¯•ç”¨äºç½‘ç»œè¯·æ±‚"),
	))

	// Fridaé…ç½®åŒºåŸŸ
	st.defaultPortEntry = fixedWidthEntry(80, "ç«¯å£")
	st.defaultPortEntry.SetText(fmt.Sprintf("%d", st.config.DefaultPort))

	st.magicNameEntry = fixedWidthEntry(100, "5å­—ç¬¦")
	st.magicNameEntry.SetText(st.config.MagicName)

	st.autoConfirmCheck = widget.NewCheck("è‡ªåŠ¨ç¡®è®¤æ“ä½œ", nil)
	st.autoConfirmCheck.SetChecked(st.config.AutoConfirm)

	// æ·»åŠ è¯´æ˜æ ‡ç­¾
	autoConfirmLabel := widget.NewLabel("(å¯ç”¨åå°†è·³è¿‡ç¡®è®¤å¯¹è¯æ¡†ï¼Œç›´æ¥æ‰§è¡Œé­”æ”¹æ“ä½œ)")
	autoConfirmLabel.TextStyle = fyne.TextStyle{Italic: true}

	randomNameBtn := widget.NewButton("éšæœº", st.generateRandomMagicName)

	fridaConfigSection := widget.NewCard("ğŸ¯ Fridaé…ç½®", "", container.NewVBox(
		container.NewHBox(
			widget.NewLabel("é»˜è®¤ç«¯å£:"), st.defaultPortEntry,
			widget.NewLabel("   é­”æ”¹åç§°:"), st.magicNameEntry, randomNameBtn,
		),
		container.NewHBox(
			st.autoConfirmCheck, autoConfirmLabel,
		),
	))

	// UIé…ç½®åŒºåŸŸ
	st.themeSelect = widget.NewSelect([]string{"auto", "light", "dark"}, func(selected string) {
		// å®æ—¶åº”ç”¨ä¸»é¢˜
		st.config.Theme = selected
		if st.applyTheme != nil {
			st.applyTheme()
		}
		st.updateStatus(fmt.Sprintf("ä¸»é¢˜å·²åˆ‡æ¢ä¸º: %s", selected))
	})
	st.themeSelect.SetSelected(st.config.Theme)

	st.windowWidthEntry = fixedWidthEntry(80, "å®½åº¦")
	st.windowWidthEntry.SetText(fmt.Sprintf("%d", st.config.WindowWidth))

	st.windowHeightEntry = fixedWidthEntry(80, "é«˜åº¦")
	st.windowHeightEntry.SetText(fmt.Sprintf("%d", st.config.WindowHeight))

	st.debugModeCheck = widget.NewCheck("è°ƒè¯•æ¨¡å¼", nil)
	st.debugModeCheck.SetChecked(st.config.DebugMode)

	st.noShowNoticeCheck = widget.NewCheck("å¯åŠ¨æ—¶ä¸æ˜¾ç¤ºå…¬å‘Š", nil)
	st.noShowNoticeCheck.SetChecked(st.config.NoShowNotice)

	uiConfigSection := widget.NewCard("ğŸ¨ ç•Œé¢é…ç½®", "", container.NewVBox(
		container.NewHBox(
			widget.NewLabel("ä¸»é¢˜:"), st.themeSelect,
			st.debugModeCheck,
		),
		container.NewHBox(
			widget.NewLabel("çª—å£å¤§å°:"), st.windowWidthEntry,
			widget.NewLabel("x"), st.windowHeightEntry,
			st.noShowNoticeCheck,
		),
	))

	// ä¸‹è½½é…ç½®åŒºåŸŸ
	st.downloadDirEntry = fixedWidthEntry(300, "ä¸‹è½½ç›®å½•è·¯å¾„")
	st.downloadDirEntry.SetText(st.config.DownloadDir)

	st.concurrentDownloadsEntry = fixedWidthEntry(80, "å¹¶å‘æ•°")
	st.concurrentDownloadsEntry.SetText(fmt.Sprintf("%d", st.config.ConcurrentDownloads))
	st.concurrentDownloadsEntry.Validator = func(text string) error {
		if val, err := strconv.Atoi(text); err != nil || val < 1 || val > 10 {
			return fmt.Errorf("å¹¶å‘ä¸‹è½½æ•°å¿…é¡»åœ¨1-10ä¹‹é—´")
		}
		return nil
	}

	downloadDirBtn := widget.NewButton("é€‰æ‹©", st.selectDownloadDir)

	downloadConfigSection := widget.NewCard("ğŸ“¥ ä¸‹è½½é…ç½®", "", container.NewVBox(
		container.NewHBox(
			widget.NewLabel("ä¸‹è½½ç›®å½•:"), st.downloadDirEntry, downloadDirBtn,
		),
		container.NewHBox(
			widget.NewLabel("å¹¶å‘ä¸‹è½½:"), st.concurrentDownloadsEntry,
		),
		widget.NewLabel("è¯´æ˜: å¹¶å‘ä¸‹è½½æ•°å½±å“åŒæ—¶ä¸‹è½½çš„æ–‡ä»¶æ•°é‡ï¼Œè¿‡å¤§å¯èƒ½å¯¼è‡´ç½‘ç»œå µå¡"),
	))

	// æ“ä½œæŒ‰é’®åŒºåŸŸ
	st.saveBtn = widget.NewButton("ğŸ’¾ ä¿å­˜è®¾ç½®", st.saveSettings)
	st.saveBtn.Importance = widget.HighImportance

	st.resetBtn = widget.NewButton("ğŸ”„ é‡ç½®é»˜è®¤", st.resetToDefaults)
	st.importBtn = widget.NewButton("ğŸ“ å¯¼å…¥é…ç½®", st.importSettings)
	st.exportBtn = widget.NewButton("ğŸ’¾ å¯¼å‡ºé…ç½®", st.exportSettings)

	actionSection := widget.NewCard("âš¡ æ“ä½œ", "", container.NewGridWithColumns(2,
		container.NewHBox(st.saveBtn, st.resetBtn),
		container.NewHBox(st.importBtn, st.exportBtn),
	))

	// ä¸»å¸ƒå±€ - ä½¿ç”¨Gridå¸ƒå±€ï¼Œ2åˆ—æ˜¾ç¤º
	leftColumn := container.NewVBox(
		globalConfigSection,
		networkConfigSection,
		fridaConfigSection,
	)

	rightColumn := container.NewVBox(
		uiConfigSection,
		downloadConfigSection,
		actionSection,
	)

	st.content = container.NewGridWithColumns(2, leftColumn, rightColumn)
}

func (st *SettingsTab) Content() *fyne.Container {
	return st.content
}

func (st *SettingsTab) Refresh() {
	// åˆ·æ–°é€»è¾‘
}

// UpdateGlobalConfig æ›´æ–°å…¨å±€é…ç½®
func (st *SettingsTab) UpdateGlobalConfig(magicName string, port int) {
	if st.magicNameEntry != nil {
		st.magicNameEntry.SetText(magicName)
	}
	if st.defaultPortEntry != nil {
		st.defaultPortEntry.SetText(fmt.Sprintf("%d", port))
	}
}

// selectWorkDir é€‰æ‹©å·¥ä½œç›®å½•
func (st *SettingsTab) selectWorkDir() {
	dialog.ShowFolderOpen(func(dir fyne.ListableURI, err error) {
		if err != nil || dir == nil {
			return
		}
		st.workDirEntry.SetText(dir.Path())
	}, st.window)
}

// selectDownloadDir é€‰æ‹©ä¸‹è½½ç›®å½•
func (st *SettingsTab) selectDownloadDir() {
	dialog.ShowFolderOpen(func(dir fyne.ListableURI, err error) {
		if err != nil || dir == nil {
			return
		}
		st.downloadDirEntry.SetText(dir.Path())
	}, st.window)
}

// testProxy æµ‹è¯•ä»£ç†
func (st *SettingsTab) testProxy() {
	proxy := strings.TrimSpace(st.proxyEntry.Text)
	if proxy == "" {
		st.updateStatus("è¯·å…ˆè¾“å…¥ä»£ç†åœ°å€")
		return
	}

	st.updateStatus("æ­£åœ¨æµ‹è¯•ä»£ç†...")
	// è¿™é‡Œå¯ä»¥é‡ç”¨MainWindowçš„ä»£ç†æµ‹è¯•é€»è¾‘
	// ç®€åŒ–å®ç°
	go func() {
		time.Sleep(2 * time.Second) // æ¨¡æ‹Ÿæµ‹è¯•
		st.updateStatus("ä»£ç†æµ‹è¯•å®Œæˆ")
	}()
}

// generateRandomMagicName ç”Ÿæˆéšæœºé­”æ”¹åç§°
func (st *SettingsTab) generateRandomMagicName() {
	randomName := utils.GenerateRandomName()
	st.magicNameEntry.SetText(randomName)
}

// saveSettings ä¿å­˜è®¾ç½®
func (st *SettingsTab) saveSettings() {
	// éªŒè¯å’Œæ›´æ–°é…ç½®
	if err := st.validateAndUpdateConfig(); err != nil {
		st.updateStatus("é…ç½®éªŒè¯å¤±è´¥: " + err.Error())
		return
	}

	// ä¿å­˜é…ç½®
	if err := st.config.Save(); err != nil {
		st.updateStatus("ä¿å­˜é…ç½®å¤±è´¥: " + err.Error())
		return
	}

	// åº”ç”¨ä¸»é¢˜å˜æ›´
	if st.applyTheme != nil {
		st.applyTheme()
	}

	st.updateStatus("è®¾ç½®å·²ä¿å­˜")
}

// validateAndUpdateConfig éªŒè¯å¹¶æ›´æ–°é…ç½®
func (st *SettingsTab) validateAndUpdateConfig() error {
	// æ›´æ–°ç½‘ç»œé…ç½®
	st.config.Proxy = strings.TrimSpace(st.proxyEntry.Text)

	if timeout, err := strconv.Atoi(st.timeoutEntry.Text); err == nil && timeout > 0 {
		st.config.Timeout = timeout
	} else {
		return fmt.Errorf("è¶…æ—¶æ—¶é—´å¿…é¡»æ˜¯æ­£æ•´æ•°")
	}

	if retries, err := strconv.Atoi(st.retriesEntry.Text); err == nil && retries >= 0 {
		st.config.Retries = retries
	} else {
		return fmt.Errorf("é‡è¯•æ¬¡æ•°å¿…é¡»æ˜¯éè´Ÿæ•´æ•°")
	}

	// æ›´æ–°Fridaé…ç½®
	if port, err := strconv.Atoi(st.defaultPortEntry.Text); err == nil && port > 0 && port <= 65535 {
		st.config.DefaultPort = port
	} else {
		return fmt.Errorf("ç«¯å£å¿…é¡»åœ¨1-65535èŒƒå›´å†…")
	}

	magicName := strings.TrimSpace(st.magicNameEntry.Text)
	if len(magicName) == 5 {
		st.config.MagicName = magicName
	} else {
		return fmt.Errorf("é­”æ”¹åç§°å¿…é¡»æ˜¯5ä¸ªå­—ç¬¦")
	}

	st.config.AutoConfirm = st.autoConfirmCheck.Checked

	// æ›´æ–°UIé…ç½®
	st.config.Theme = st.themeSelect.Selected
	st.config.DebugMode = st.debugModeCheck.Checked
	st.config.NoShowNotice = st.noShowNoticeCheck.Checked

	if width, err := strconv.Atoi(st.windowWidthEntry.Text); err == nil && width >= 800 {
		st.config.WindowWidth = width
	} else {
		return fmt.Errorf("çª—å£å®½åº¦å¿…é¡»å¤§äºç­‰äº800")
	}

	if height, err := strconv.Atoi(st.windowHeightEntry.Text); err == nil && height >= 600 {
		st.config.WindowHeight = height
	} else {
		return fmt.Errorf("çª—å£é«˜åº¦å¿…é¡»å¤§äºç­‰äº600")
	}

	// æ›´æ–°ä¸‹è½½é…ç½®
	st.config.DownloadDir = strings.TrimSpace(st.downloadDirEntry.Text)
	st.config.WorkDir = strings.TrimSpace(st.workDirEntry.Text)

	if concurrent, err := strconv.Atoi(st.concurrentDownloadsEntry.Text); err == nil && concurrent > 0 && concurrent <= 10 {
		st.config.ConcurrentDownloads = concurrent
	} else {
		return fmt.Errorf("å¹¶å‘ä¸‹è½½æ•°å¿…é¡»åœ¨1-10èŒƒå›´å†…")
	}

	return nil
}

// resetToDefaults é‡ç½®ä¸ºé»˜è®¤å€¼
func (st *SettingsTab) resetToDefaults() {
	dialog.ShowConfirm("ç¡®è®¤é‡ç½®", "ç¡®å®šè¦é‡ç½®æ‰€æœ‰è®¾ç½®ä¸ºé»˜è®¤å€¼å—ï¼Ÿ", func(confirmed bool) {
		if !confirmed {
			return
		}

		defaultConfig := config.DefaultConfig()
		*st.config = *defaultConfig

		// é‡æ–°åŠ è½½UI
		st.loadConfigToUI()
		st.updateStatus("å·²é‡ç½®ä¸ºé»˜è®¤è®¾ç½®")
	}, st.window)
}

// loadConfigToUI åŠ è½½é…ç½®åˆ°UI
func (st *SettingsTab) loadConfigToUI() {
	st.workDirEntry.SetText(st.config.WorkDir)
	st.proxyEntry.SetText(st.config.Proxy)
	st.timeoutEntry.SetText(fmt.Sprintf("%d", st.config.Timeout))
	st.retriesEntry.SetText(fmt.Sprintf("%d", st.config.Retries))
	st.defaultPortEntry.SetText(fmt.Sprintf("%d", st.config.DefaultPort))
	st.magicNameEntry.SetText(st.config.MagicName)
	st.autoConfirmCheck.SetChecked(st.config.AutoConfirm)
	st.themeSelect.SetSelected(st.config.Theme)
	st.windowWidthEntry.SetText(fmt.Sprintf("%d", st.config.WindowWidth))
	st.windowHeightEntry.SetText(fmt.Sprintf("%d", st.config.WindowHeight))
	st.debugModeCheck.SetChecked(st.config.DebugMode)
	st.noShowNoticeCheck.SetChecked(st.config.NoShowNotice)
	st.downloadDirEntry.SetText(st.config.DownloadDir)
	st.concurrentDownloadsEntry.SetText(fmt.Sprintf("%d", st.config.ConcurrentDownloads))
}

// importSettings å¯¼å…¥é…ç½®
func (st *SettingsTab) importSettings() {
	dialog.ShowFileOpen(func(file fyne.URIReadCloser, err error) {
		if err != nil || file == nil {
			return
		}
		defer file.Close()

		// è¿™é‡Œå¯ä»¥å®ç°é…ç½®æ–‡ä»¶å¯¼å…¥é€»è¾‘
		st.updateStatus("é…ç½®å¯¼å…¥åŠŸèƒ½å¾…å®ç°")
	}, st.window)
}

// exportSettings å¯¼å‡ºé…ç½®
func (st *SettingsTab) exportSettings() {
	dialog.ShowFileSave(func(file fyne.URIWriteCloser, err error) {
		if err != nil || file == nil {
			return
		}
		defer file.Close()

		// è¿™é‡Œå¯ä»¥å®ç°é…ç½®æ–‡ä»¶å¯¼å‡ºé€»è¾‘
		st.updateStatus("é…ç½®å¯¼å‡ºåŠŸèƒ½å¾…å®ç°")
	}, st.window)
}

// CreateTab åˆ›å»ºDEBåŒ…æ ‡ç­¾é¡µ
type CreateTab struct {
	app          fyne.App
	config       *config.Config
	updateStatus StatusUpdater
	addLog       func(string)
	content      *fyne.Container

	// UI ç»„ä»¶ - ä½¿ç”¨widget.Entryæ”¹å–„æ‰€æœ‰è¾“å…¥æ¡†å®½åº¦
	fridaServerEntry   *FixedWidthEntry
	fridaAgentEntry    *FixedWidthEntry
	outputPathEntry    *FixedWidthEntry
	magicNameEntry     *FixedWidthEntry
	portEntry          *FixedWidthEntry
	packageNameEntry   *FixedWidthEntry
	versionEntry       *FixedWidthEntry
	architectureSelect *widget.Select
	maintainerEntry    *FixedWidthEntry
	descriptionEntry   *FixedWidthEntry
	dependsEntry       *FixedWidthEntry
	sectionEntry       *FixedWidthEntry
	prioritySelect     *widget.Select
	homepageEntry      *FixedWidthEntry
	isRootlessCheck    *widget.Check
	progressBar        *widget.ProgressBar
	progressLabel      *widget.Label
	createBtn          *widget.Button

	// æ ¸å¿ƒåŠŸèƒ½ (CreateFridaDeb is instantiated locally when needed)
}

// NewCreateTab åˆ›å»ºæ–°çš„åˆ›å»ºæ ‡ç­¾é¡µ
func NewCreateTab(app fyne.App, cfg *config.Config, statusUpdater StatusUpdater, logFunc func(string)) *CreateTab {
	ct := &CreateTab{
		app:          app,
		config:       cfg,
		updateStatus: statusUpdater,
		addLog:       logFunc,
	}

	ct.setupUI()
	return ct
}

// setupUI è®¾ç½®UIç•Œé¢
func (ct *CreateTab) setupUI() {
	// ä½¿ç”¨å›ºå®šå®½åº¦Entryç»„ä»¶ - å¢åŠ å®½åº¦
	ct.fridaServerEntry = fixedWidthEntry(200, "é€‰æ‹©frida-serveræ–‡ä»¶...")
	ct.fridaAgentEntry = fixedWidthEntry(200, "é€‰æ‹©frida-agent.dylibæ–‡ä»¶ (å¯é€‰)...")
	ct.outputPathEntry = fixedWidthEntry(180, "é€‰æ‹©è¾“å‡ºDEBæ–‡ä»¶è·¯å¾„...")

	ct.magicNameEntry = fixedWidthEntry(100, "5å­—ç¬¦")
	ct.portEntry = fixedWidthEntry(100, "ç«¯å£")
	ct.packageNameEntry = fixedWidthEntry(300, "åŒ…å (è‡ªåŠ¨ç”Ÿæˆ)")
	ct.versionEntry = fixedWidthEntry(200, "ç‰ˆæœ¬")
	ct.maintainerEntry = fixedWidthEntry(300, "ç»´æŠ¤è€…")
	ct.descriptionEntry = fixedWidthEntry(300, "åŒ…æè¿°")
	ct.dependsEntry = fixedWidthEntry(200, "ä¾èµ–")
	ct.sectionEntry = fixedWidthEntry(200, "åˆ†ç±»")
	ct.homepageEntry = fixedWidthEntry(300, "ä¸»é¡µ")

	// è®¾ç½®æŒ‰é’®
	serverSelectBtn := widget.NewButton("é€‰æ‹©", ct.selectFridaServer)
	agentSelectBtn := widget.NewButton("é€‰æ‹©", ct.selectFridaAgent)
	outputSelectBtn := widget.NewButton("é€‰æ‹©", ct.selectOutputPath)

	// åŸºæœ¬é…ç½®éªŒè¯å™¨å’Œäº‹ä»¶
	ct.magicNameEntry.Validator = func(text string) error {
		if len(text) != 5 {
			return fmt.Errorf("é­”æ”¹åç§°å¿…é¡»æ˜¯5ä¸ªå­—ç¬¦")
		}
		if len(text) == 0 {
			return fmt.Errorf("é­”æ”¹åç§°ä¸èƒ½ä¸ºç©º")
		}

		// æ£€æŸ¥é¦–å­—ç¬¦å¿…é¡»æ˜¯å­—æ¯
		first := text[0]
		if !((first >= 'A' && first <= 'Z') || (first >= 'a' && first <= 'z')) {
			return fmt.Errorf("é­”æ”¹åç§°å¿…é¡»ä»¥å­—æ¯å¼€å¤´")
		}

		// æ£€æŸ¥æ‰€æœ‰å­—ç¬¦å¿…é¡»æ˜¯å­—æ¯æˆ–æ•°å­—
		for i, c := range text {
			if !((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')) {
				return fmt.Errorf("ç¬¬%dä¸ªå­—ç¬¦'%c'æ— æ•ˆï¼Œåªèƒ½åŒ…å«å­—æ¯å’Œæ•°å­—", i+1, c)
			}
		}

		// æ£€æŸ¥æ˜¯å¦ä¸ºä¿ç•™åç§°
		lowerText := strings.ToLower(text)
		reservedNames := []string{"frida", "admin", "root", "user", "guest"}
		for _, reserved := range reservedNames {
			if lowerText == reserved {
				return fmt.Errorf("'%s'æ˜¯ä¿ç•™åç§°ï¼Œè¯·ä½¿ç”¨å…¶ä»–åç§°", text)
			}
		}

		return nil
	}

	// æ·»åŠ å®æ—¶éªŒè¯å’Œå­—ç¬¦é•¿åº¦é™åˆ¶
	ct.magicNameEntry.OnChanged = func(text string) {
		// é™åˆ¶è¾“å…¥é•¿åº¦ä¸º5ä¸ªå­—ç¬¦
		if len(text) > 5 {
			ct.magicNameEntry.SetText(text[:5])
			return
		}

		// å®æ—¶æ›´æ–°åŒ…å
		ct.updatePackageName(text)

		// å®æ—¶éªŒè¯æ˜¾ç¤º
		if err := ct.magicNameEntry.Validator(text); err != nil {
			ct.updateStatus(fmt.Sprintf("é­”æ”¹åç§°é”™è¯¯: %v", err))
		} else if len(text) == 5 {
			ct.updateStatus("é­”æ”¹åç§°éªŒè¯é€šè¿‡")
		}
	}

	ct.portEntry.SetText("27042")
	ct.portEntry.Validator = func(text string) error {
		if port, err := strconv.Atoi(text); err != nil || port < 1 || port > 65535 {
			return fmt.Errorf("ç«¯å£å¿…é¡»åœ¨1-65535èŒƒå›´å†…")
		}
		return nil
	}

	ct.isRootlessCheck = widget.NewCheck("Rootlessç»“æ„", nil)

	// åŒ…ä¿¡æ¯é…ç½®
	ct.packageNameEntry.Disable() // è®¾ç½®ä¸ºåªè¯»

	ct.versionEntry.SetText("17.2.17")

	ct.architectureSelect = widget.NewSelect([]string{
		"iphoneos-arm64",
		"iphoneos-arm",
		"all",
	}, nil)
	ct.architectureSelect.SetSelected("iphoneos-arm64")
	ct.architectureSelect.Resize(fyne.NewSize(200, 0))

	ct.maintainerEntry.SetText("Fridare Team <support@fridare.com>")
	ct.descriptionEntry.SetPlaceHolder("åŒ…æè¿° (è‡ªåŠ¨ç”Ÿæˆ)")
	ct.dependsEntry.SetText("firmware (>= 12.0)")
	ct.sectionEntry.SetText("Development")

	ct.prioritySelect = widget.NewSelect([]string{
		"optional",
		"important",
		"required",
		"standard",
	}, nil)
	ct.prioritySelect.SetSelected("optional")
	ct.prioritySelect.Resize(fyne.NewSize(200, 0))

	ct.homepageEntry.SetText("https://frida.re/")

	// è¿›åº¦æ˜¾ç¤º
	ct.progressBar = widget.NewProgressBar()
	ct.progressLabel = widget.NewLabel("å‡†å¤‡å°±ç»ª")

	// åˆ›å»ºæŒ‰é’®
	ct.createBtn = widget.NewButton("åˆ›å»ºDEBåŒ…", ct.createDebPackage)
	ct.createBtn.Importance = widget.HighImportance

	// ç®€åŒ–çš„ç´§å‡‘å¸ƒå±€ - ä½¿ç”¨Borderå¸ƒå±€é¿å…é‡å 
	// æ–‡ä»¶é€‰æ‹©åŒºåŸŸ
	serverRow := container.NewBorder(nil, nil,
		widget.NewLabel("frida-server:"),
		serverSelectBtn,
		ct.fridaServerEntry)

	agentRow := container.NewBorder(nil, nil,
		widget.NewLabel(" frida-agent:"),
		agentSelectBtn,
		ct.fridaAgentEntry)

	outputRow := container.NewBorder(nil, nil,
		widget.NewLabel("     è¾“å‡ºè·¯å¾„:"),
		outputSelectBtn,
		ct.outputPathEntry)

	fileSection := widget.NewCard("æ–‡ä»¶é€‰æ‹©", "", container.NewVBox(
		serverRow,
		agentRow,
		outputRow,
	))

	// åŸºæœ¬é…ç½®åŒºåŸŸ - ä½¿ç”¨HBoxæ¨ªå‘æ’åˆ—
	configSection := widget.NewCard("åŸºæœ¬é…ç½®", "", container.NewHBox(
		widget.NewLabel("é­”æ”¹åç§°:"), ct.magicNameEntry,
		widget.NewLabel("ã€€ã€€ç«¯å£:"), ct.portEntry,
		widget.NewLabel("ã€€ã€€ã€€ã€€"), ct.isRootlessCheck,
	))

	// åŒ…ä¿¡æ¯åŒºåŸŸ - åˆ†ä¸¤è¡Œæ˜¾ç¤º
	packageRow1 := container.NewHBox(
		widget.NewLabel("ã€€ã€€åŒ…å:"), ct.packageNameEntry,
		widget.NewLabel("ã€€ã€€ç‰ˆæœ¬:"), ct.versionEntry,
		widget.NewLabel("ã€€ã€€æ¶æ„:"), ct.architectureSelect,
	)

	packageRow2 := container.NewHBox(
		widget.NewLabel("ã€€ç»´æŠ¤è€…:"), ct.maintainerEntry,
		widget.NewLabel("ã€€ã€€åˆ†ç±»:"), ct.sectionEntry,
		widget.NewLabel("ã€€ä¼˜å…ˆçº§:"), ct.prioritySelect,
	)

	packageSection := widget.NewCard("ã€€åŒ…ä¿¡æ¯", "", container.NewVBox(
		packageRow1,
		packageRow2,
	))

	// è¯¦ç»†ä¿¡æ¯åŒºåŸŸ - ä¸€è¡Œæ˜¾ç¤º
	detailRow := container.NewHBox(
		widget.NewLabel("ã€€ã€€æè¿°:"), ct.descriptionEntry,
		widget.NewLabel("ã€€ã€€ä¾èµ–:"), ct.dependsEntry,
		widget.NewLabel("ã€€ã€€ä¸»é¡µ:"), ct.homepageEntry,
	)

	detailSection := widget.NewCard("è¯¦ç»†ä¿¡æ¯", "", detailRow)

	// æ“ä½œåŒºåŸŸ - ä½¿ç”¨Borderå¸ƒå±€
	actionSection := container.NewBorder(nil, nil,
		container.NewHBox(ct.progressLabel, ct.progressBar),
		ct.createBtn,
		nil,
	)

	// ä¸»å¸ƒå±€
	ct.content = container.NewVBox(
		fileSection,
		configSection,
		packageSection,
		detailSection,
		actionSection,
	)

	// è®¾ç½®ç›‘å¬å™¨ - é­”æ”¹åç§°çš„OnChangedå·²åœ¨Entryå®šä¹‰æ—¶è®¾ç½®
	ct.isRootlessCheck.OnChanged = func(checked bool) {
		ct.updatePackageName(ct.magicNameEntry.Text)
	}
}

// selectFridaServer é€‰æ‹©frida-serveræ–‡ä»¶
func (ct *CreateTab) selectFridaServer() {
	dialog.ShowFileOpen(func(reader fyne.URIReadCloser, err error) {
		if err != nil || reader == nil {
			return
		}
		defer reader.Close()

		filePath := reader.URI().Path()
		ct.fridaServerEntry.SetText(filePath)
		ct.addLog(fmt.Sprintf("é€‰æ‹©frida-serveræ–‡ä»¶: %s", filePath))
	}, ct.app.Driver().AllWindows()[0])
}

// selectFridaAgent é€‰æ‹©frida-agentæ–‡ä»¶
func (ct *CreateTab) selectFridaAgent() {
	dialog.ShowFileOpen(func(reader fyne.URIReadCloser, err error) {
		if err != nil || reader == nil {
			return
		}
		defer reader.Close()

		filePath := reader.URI().Path()
		ct.fridaAgentEntry.SetText(filePath)
		ct.addLog(fmt.Sprintf("é€‰æ‹©frida-agentæ–‡ä»¶: %s", filePath))
	}, ct.app.Driver().AllWindows()[0])
}

// selectOutputPath é€‰æ‹©è¾“å‡ºè·¯å¾„
func (ct *CreateTab) selectOutputPath() {
	dialog.ShowFileSave(func(writer fyne.URIWriteCloser, err error) {
		if err != nil || writer == nil {
			return
		}
		defer writer.Close()

		filePath := writer.URI().Path()
		if !strings.HasSuffix(strings.ToLower(filePath), ".deb") {
			filePath += ".deb"
		}
		ct.outputPathEntry.SetText(filePath)
		ct.addLog(fmt.Sprintf("é€‰æ‹©è¾“å‡ºè·¯å¾„: %s", filePath))
	}, ct.app.Driver().AllWindows()[0])
}

// updatePackageName æ›´æ–°åŒ…å
func (ct *CreateTab) updatePackageName(magicName string) {
	if magicName == "" {
		ct.packageNameEntry.SetText("")
		ct.descriptionEntry.SetText("")
		return
	}

	// ç”Ÿæˆè§„åˆ™ï¼šå°†é­”æ”¹å­—ç¬¦æ›¿æ¢å…¶ä¸­çš„fridaå­—ç¬¦
	basePackageName := "re.frida.server"

	// å°†fridaæ›¿æ¢ä¸ºé­”æ”¹åç§°
	packageName := strings.ReplaceAll(basePackageName, "frida", magicName)

	// æ·»åŠ rootlessåç¼€ï¼ˆå¦‚æœé€‰ä¸­ï¼‰
	if ct.isRootlessCheck.Checked {
		packageName += ".rootless"
	}

	ct.packageNameEntry.SetText(packageName)

	// åŒæ—¶æ›´æ–°æè¿°ï¼Œä¹Ÿæ›¿æ¢å…¶ä¸­çš„frida
	baseDescription := "Dynamic instrumentation toolkit for developers, security researchers, and reverse engineers based on Frida"
	description := strings.ReplaceAll(baseDescription, "Frida", strings.Title(magicName))
	description += fmt.Sprintf(" (Modified: %s)", magicName)
	ct.descriptionEntry.SetText(description)
}

// createDebPackage åˆ›å»ºDEBåŒ…
func (ct *CreateTab) createDebPackage() {
	// éªŒè¯è¾“å…¥
	if ct.fridaServerEntry.Text == "" {
		ct.showError("è¯·é€‰æ‹©frida-serveræ–‡ä»¶")
		return
	}

	if ct.outputPathEntry.Text == "" {
		ct.showError("è¯·é€‰æ‹©è¾“å‡ºè·¯å¾„")
		return
	}

	if ct.magicNameEntry.Text == "" {
		ct.showError("è¯·è¾“å…¥é­”æ”¹åç§°")
		return
	}

	if err := ct.magicNameEntry.Validator(ct.magicNameEntry.Text); err != nil {
		ct.showError(fmt.Sprintf("é­”æ”¹åç§°æ ¼å¼é”™è¯¯: %v", err))
		return
	}

	port, err := strconv.Atoi(ct.portEntry.Text)
	if err != nil {
		ct.showError("ç«¯å£æ ¼å¼é”™è¯¯")
		return
	}

	// ç¦ç”¨æŒ‰é’®
	ct.createBtn.Disable()
	ct.progressBar.SetValue(0)
	ct.progressLabel.SetText("å¼€å§‹åˆ›å»º...")

	// å¼‚æ­¥æ‰§è¡Œ
	go ct.performCreate(port)
}

// performCreate æ‰§è¡Œåˆ›å»ºè¿‡ç¨‹
func (ct *CreateTab) performCreate(port int) {
	defer func() {
		ct.createBtn.Enable()
	}()

	// åˆ›å»ºåŒ…ä¿¡æ¯
	packageInfo := &core.PackageInfo{
		Name:         ct.packageNameEntry.Text,
		Version:      ct.versionEntry.Text,
		Architecture: ct.architectureSelect.Selected,
		Maintainer:   ct.maintainerEntry.Text,
		Description:  ct.descriptionEntry.Text,
		Depends:      ct.dependsEntry.Text,
		Section:      ct.sectionEntry.Text,
		Priority:     ct.prioritySelect.Selected,
		Homepage:     ct.homepageEntry.Text,
		Port:         port,
		MagicName:    ct.magicNameEntry.Text,
		IsRootless:   ct.isRootlessCheck.Checked,
	}

	// åˆ›å»ºDEBæ„å»ºå™¨
	creator := core.NewCreateFridaDeb(ct.fridaServerEntry.Text, ct.outputPathEntry.Text, packageInfo)
	if ct.fridaAgentEntry.Text != "" {
		creator.FridaAgentPath = ct.fridaAgentEntry.Text
	}

	ct.addLog("å¼€å§‹åˆ›å»ºDEBåŒ…...")
	ct.addLog(fmt.Sprintf("é­”æ”¹åç§°: %s, ç«¯å£: %d, ç»“æ„: %s",
		packageInfo.MagicName, packageInfo.Port,
		map[bool]string{true: "Rootless", false: "Root"}[packageInfo.IsRootless]))

	// æ‰§è¡Œåˆ›å»º
	err := creator.CreateDebPackage()
	if err != nil {
		ct.progressLabel.SetText("åˆ›å»ºå¤±è´¥")
		ct.showError(fmt.Sprintf("åˆ›å»ºDEBåŒ…å¤±è´¥: %v", err))
		ct.addLog(fmt.Sprintf("é”™è¯¯: %v", err))
		return
	}

	ct.progressBar.SetValue(1.0)
	ct.progressLabel.SetText("åˆ›å»ºå®Œæˆ")
	ct.addLog("DEBåŒ…åˆ›å»ºæˆåŠŸ!")

	// æ˜¾ç¤ºæˆåŠŸä¿¡æ¯
	ct.showSuccess("DEBåŒ…åˆ›å»ºæˆåŠŸ!", fmt.Sprintf("è¾“å‡ºæ–‡ä»¶: %s", ct.outputPathEntry.Text))

	ct.updateStatus("DEBåŒ…åˆ›å»ºå®Œæˆ")
}

// showError æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
func (ct *CreateTab) showError(message string) {
	dialog.ShowError(fmt.Errorf("%s", message), ct.app.Driver().AllWindows()[0])
}

// showSuccess æ˜¾ç¤ºæˆåŠŸä¿¡æ¯
func (ct *CreateTab) showSuccess(title, message string) {
	dialog.ShowInformation(title, message, ct.app.Driver().AllWindows()[0])
}

// Content è¿”å›æ ‡ç­¾é¡µå†…å®¹
func (ct *CreateTab) Content() *fyne.Container {
	return ct.content
}

// Refresh åˆ·æ–°æ ‡ç­¾é¡µ
func (ct *CreateTab) Refresh() {
	// åˆ·æ–°é€»è¾‘
}

// UpdateGlobalConfig æ›´æ–°å…¨å±€é…ç½®
func (ct *CreateTab) UpdateGlobalConfig(magicName string, port int) {
	if ct.magicNameEntry != nil {
		ct.magicNameEntry.SetText(magicName)
		// è§¦å‘å®æ—¶éªŒè¯å’ŒåŒ…åæ›´æ–°
		if ct.magicNameEntry.OnChanged != nil {
			ct.magicNameEntry.OnChanged(magicName)
		}
	}
	if ct.portEntry != nil {
		ct.portEntry.SetText(fmt.Sprintf("%d", port))
	}
}

func hideConsoleCmd(cmd *exec.Cmd) {
	if runtime.GOOS == "windows" {
		cmd.SysProcAttr = &syscall.SysProcAttr{
			HideWindow:    true,
			CreationFlags: 0x08000000, // CREATE_NO_WINDOW
		}
	}
}

// HelpTab å¸®åŠ©æ ‡ç­¾é¡µ
type HelpTab struct {
	content       *fyne.Container
	indexList     *widget.List
	contentViewer *widget.RichText

	// å¸®åŠ©æ–‡æ¡£æ•°æ®
	helpSections []HelpSection
	currentIndex int
}

// HelpSection å¸®åŠ©ç« èŠ‚
type HelpSection struct {
	Title   string
	Icon    string
	Content string
}

// NewHelpTab åˆ›å»ºæ–°çš„å¸®åŠ©æ ‡ç­¾é¡µ
func NewHelpTab() *HelpTab {
	ht := &HelpTab{
		currentIndex: 0,
	}

	ht.setupHelpData()
	ht.setupUI()

	return ht
}

// setupHelpData è®¾ç½®å¸®åŠ©æ–‡æ¡£æ•°æ®
func (ht *HelpTab) setupHelpData() {
	ht.helpSections = []HelpSection{
		{
			Title: "å¿«é€Ÿå¼€å§‹",
			Icon:  "ğŸš€",
			Content: `# å¿«é€Ÿå¼€å§‹æŒ‡å—

## æ¬¢è¿ä½¿ç”¨ Fridare GUI

Fridare æ˜¯ä¸€ä¸ªå¼ºå¤§çš„ Frida å·¥å…·é›†ï¼Œä¸“ä¸º iOS é€†å‘å·¥ç¨‹å’Œå®‰å…¨ç ”ç©¶è®¾è®¡ã€‚

### ä¸»è¦åŠŸèƒ½
- **Frida ä¸‹è½½ç®¡ç†**ï¼šè‡ªåŠ¨ä¸‹è½½æœ€æ–°ç‰ˆæœ¬çš„ Frida ç»„ä»¶
- **äºŒè¿›åˆ¶æ–‡ä»¶é­”æ”¹**ï¼šä¿®æ”¹ Frida ç‰¹å¾ä»¥ç»•è¿‡æ£€æµ‹
- **DEB åŒ…å¤„ç†**ï¼šåˆ›å»ºå’Œä¿®æ”¹ iOS DEB å®‰è£…åŒ…  
- **Python ç¯å¢ƒé›†æˆ**ï¼šè‡ªåŠ¨æ£€æµ‹å’Œé…ç½® Python ç¯å¢ƒ
- **frida-tools é­”æ”¹**ï¼šä¿®æ”¹ frida-tools é¿å…è¢«æ£€æµ‹

### å¿«é€Ÿä¸Šæ‰‹æ­¥éª¤
1. **é…ç½®ç¯å¢ƒ**ï¼šåœ¨"è®¾ç½®"é¡µé¢é…ç½®å·¥ä½œç›®å½•å’Œç½‘ç»œä»£ç†
2. **ä¸‹è½½ Frida**ï¼šä½¿ç”¨"ä¸‹è½½"åŠŸèƒ½è·å–æ‰€éœ€ç‰ˆæœ¬
3. **æ‰§è¡Œé­”æ”¹**ï¼šä½¿ç”¨ç›¸åº”åŠŸèƒ½é¡µé¢è¿›è¡Œæ–‡ä»¶ä¿®æ”¹
4. **éƒ¨ç½²ä½¿ç”¨**ï¼šå°†å¤„ç†åçš„æ–‡ä»¶éƒ¨ç½²åˆ°ç›®æ ‡è®¾å¤‡

> ğŸ’¡ **æç¤º**ï¼šé¦–æ¬¡ä½¿ç”¨å»ºè®®å…ˆæŸ¥çœ‹"è®¾ç½®"é¡µé¢è¿›è¡ŒåŸºæœ¬é…ç½®ã€‚`,
		},
		{
			Title: "ä¸‹è½½åŠŸèƒ½",
			Icon:  "ğŸ“¥",
			Content: `# ä¸‹è½½åŠŸèƒ½è¯¦è§£

## åŠŸèƒ½æ¦‚è¿°
ä¸‹è½½é¡µé¢æä¾›äº†å®Œæ•´çš„ Frida ç»„ä»¶ä¸‹è½½å’Œç®¡ç†åŠŸèƒ½ã€‚

## ç‰ˆæœ¬é€‰æ‹©
- **è‡ªåŠ¨è·å–**ï¼šç¨‹åºå¯åŠ¨æ—¶è‡ªåŠ¨è·å–æœ€æ–°ç‰ˆæœ¬åˆ—è¡¨
- **ç‰ˆæœ¬è¿‡æ»¤**ï¼šæ”¯æŒæŒ‰ç‰ˆæœ¬å·ç­›é€‰å’Œæœç´¢
- **å¹³å°æ”¯æŒ**ï¼šæ”¯æŒ iOS arm64ã€armv7 ç­‰å¤šç§æ¶æ„

## æ”¯æŒçš„ç»„ä»¶ç±»å‹
### 1. frida-server
- iOS è®¾å¤‡ä¸Šè¿è¡Œçš„æ ¸å¿ƒæœåŠ¡
- æ”¯æŒ arm64ã€armv7 æ¶æ„
- è‡ªåŠ¨é€‰æ‹©å¯¹åº”è®¾å¤‡æ¶æ„

### 2. frida-agent
- åŠ¨æ€æ³¨å…¥çš„ Agent åº“æ–‡ä»¶  
- é€šå¸¸ä¸º .dylib æ ¼å¼
- ç”¨äºé«˜çº§æ³¨å…¥åœºæ™¯

### 3. frida-gadget
- åµŒå…¥å¼ Frida åº“
- ç”¨äºåº”ç”¨å†…éƒ¨é›†æˆ
- æ”¯æŒå¤šç§åŠ è½½æ¨¡å¼

## ä¸‹è½½é…ç½®
- **ä¸‹è½½ç›®å½•**ï¼šå¯åœ¨è®¾ç½®ä¸­è‡ªå®šä¹‰ä¸‹è½½è·¯å¾„
- **å¹¶å‘ä¸‹è½½**ï¼šæ”¯æŒ 1-10 ä¸ªå¹¶å‘ä¸‹è½½ä»»åŠ¡
- **ä»£ç†æ”¯æŒ**ï¼šæ”¯æŒ HTTP/HTTPS ä»£ç†ä¸‹è½½
- **æ–­ç‚¹ç»­ä¼ **ï¼šæ”¯æŒå¤§æ–‡ä»¶æ–­ç‚¹ç»­ä¼ 

## ä½¿ç”¨æŠ€å·§
- å»ºè®®ä¸‹è½½åç«‹å³è¿›è¡Œé­”æ”¹å¤„ç†
- å¯åŒæ—¶ä¸‹è½½å¤šä¸ªç‰ˆæœ¬å¤‡ç”¨
- å®šæœŸæ¸…ç†ä¸éœ€è¦çš„æ—§ç‰ˆæœ¬æ–‡ä»¶`,
		},
		{
			Title: "Frida é­”æ”¹",
			Icon:  "ğŸ”§",
			Content: `# Frida äºŒè¿›åˆ¶é­”æ”¹è¯¦è§£

## åŠŸèƒ½ç›®çš„
é€šè¿‡ä¿®æ”¹ Frida äºŒè¿›åˆ¶æ–‡ä»¶çš„ç‰¹å¾å­—ç¬¦ä¸²ï¼Œç»•è¿‡åº”ç”¨çš„ Frida æ£€æµ‹æœºåˆ¶ã€‚

## é­”æ”¹åŸç†
### ç‰¹å¾å­—ç¬¦ä¸²æ›¿æ¢
- å°†é»˜è®¤çš„ "frida" å­—ç¬¦ä¸²æ›¿æ¢ä¸ºè‡ªå®šä¹‰åç§°
- ä¿®æ”¹ç«¯å£å·é¿å…å›ºå®šç«¯å£æ£€æµ‹
- ä¿æŒäºŒè¿›åˆ¶æ–‡ä»¶ç»“æ„å®Œæ•´æ€§

### æ”¯æŒçš„æ–‡ä»¶æ ¼å¼
- **MachO**ï¼šiOS å¯æ‰§è¡Œæ–‡ä»¶æ ¼å¼
- **ELF**ï¼šLinux å¯æ‰§è¡Œæ–‡ä»¶æ ¼å¼  
- **PE**ï¼šWindows å¯æ‰§è¡Œæ–‡ä»¶æ ¼å¼

## é­”æ”¹æ­¥éª¤
### 1. é€‰æ‹©æ–‡ä»¶
- æ”¯æŒå•æ–‡ä»¶æˆ–æ‰¹é‡é€‰æ‹©
- è‡ªåŠ¨è¯†åˆ«æ–‡ä»¶æ ¼å¼ç±»å‹
- æ˜¾ç¤ºæ–‡ä»¶åŸºæœ¬ä¿¡æ¯

### 2. é…ç½®å‚æ•°
- **é­”æ”¹åç§°**ï¼š5ä¸ªå­—ç¬¦ï¼Œå¿…é¡»ä»¥å­—æ¯å¼€å¤´
- **ç›®æ ‡ç«¯å£**ï¼š1-65535 èŒƒå›´å†…çš„æœ‰æ•ˆç«¯å£
- **è¾“å‡ºè·¯å¾„**ï¼šå¯é€‰æ‹©è¦†ç›–æˆ–å¦å­˜

### 3. æ‰§è¡Œé­”æ”¹
- å®æ—¶æ˜¾ç¤ºå¤„ç†è¿›åº¦
- æ”¯æŒæ‰¹é‡å¤„ç†å¤šä¸ªæ–‡ä»¶
- è‡ªåŠ¨å¤‡ä»½åŸå§‹æ–‡ä»¶

## æ³¨æ„äº‹é¡¹
- é­”æ”¹åç§°å¿…é¡»ä¸¥æ ¼ä¸º 5 ä¸ªå­—ç¬¦
- å»ºè®®ä½¿ç”¨éšæœºåç§°é¿å…è¢«è¯†åˆ«
- å¤„ç†å‰ä¼šè‡ªåŠ¨åˆ›å»ºå¤‡ä»½æ–‡ä»¶
- æ”¯æŒä¸€é”®æ¢å¤åˆ°åŸå§‹çŠ¶æ€

## é«˜çº§åŠŸèƒ½
- **éšæœºåç§°ç”Ÿæˆ**ï¼šè‡ªåŠ¨ç”Ÿæˆå®‰å…¨çš„éšæœºåç§°
- **æ‰¹é‡å¤„ç†**ï¼šåŒæ—¶å¤„ç†å¤šä¸ªæ–‡ä»¶
- **é¢„è§ˆæ¨¡å¼**ï¼šå¤„ç†å‰é¢„è§ˆä¿®æ”¹å†…å®¹`,
		},
		{
			Title: "DEB åŒ…é­”æ”¹",
			Icon:  "ğŸ“¦",
			Content: `# DEB åŒ…é­”æ”¹åŠŸèƒ½

## åŠŸèƒ½æ¦‚è¿°
å¯¹å·²æœ‰çš„ iOS DEB å®‰è£…åŒ…è¿›è¡Œæ·±åº¦é­”æ”¹ï¼Œä¿®æ”¹å…¶ä¸­çš„ Frida ç»„ä»¶ã€‚

## æ”¯æŒçš„åŒ…ç±»å‹
### Frida DEB åŒ…
- re.frida.server
- frida-server ç›¸å…³åŒ…
- ç¬¬ä¸‰æ–¹ Frida è¡ç”ŸåŒ…

### æ£€æµ‹æœºåˆ¶
- **è‡ªåŠ¨è¯†åˆ«**ï¼šæ™ºèƒ½è¯†åˆ«åŒ…å†…çš„ Frida ç»„ä»¶
- **æ–‡ä»¶æ‰«æ**ï¼šé€’å½’æ‰«ææ‰€æœ‰å¯æ‰§è¡Œæ–‡ä»¶
- **æ ¼å¼éªŒè¯**ï¼šéªŒè¯ DEB åŒ…å®Œæ•´æ€§

## é­”æ”¹æµç¨‹
### 1. åŒ…è§£æ
- è§£å‹ DEB åŒ…ç»“æ„
- åˆ†ææ§åˆ¶æ–‡ä»¶ä¿¡æ¯
- è¯†åˆ«å¯æ‰§è¡Œç»„ä»¶

### 2. ç»„ä»¶é­”æ”¹
- å¯¹è¯†åˆ«åˆ°çš„ Frida æ–‡ä»¶æ‰§è¡Œé­”æ”¹
- ä¿æŒæ–‡ä»¶æƒé™å’Œå±æ€§
- æ›´æ–°åŒ…çš„æ ¡éªŒä¿¡æ¯

### 3. é‡æ–°æ‰“åŒ…
- é‡æ–°å‹ç¼©ä¿®æ”¹åçš„æ–‡ä»¶
- æ›´æ–°åŒ…å…ƒæ•°æ®
- ç”Ÿæˆæ–°çš„ DEB æ–‡ä»¶

## é…ç½®é€‰é¡¹
- **é­”æ”¹åç§°**ï¼šç»Ÿä¸€çš„ 5 å­—ç¬¦æ ‡è¯†
- **ç«¯å£é…ç½®**ï¼šä¿®æ”¹é»˜è®¤ç›‘å¬ç«¯å£
- **åŒ…ä¿¡æ¯**ï¼šå¯é€‰æ‹©æ˜¯å¦ä¿®æ”¹åŒ…æ ‡è¯†ç¬¦

## è¾“å‡ºç»“æœ
- ç”Ÿæˆé­”æ”¹åçš„æ–° DEB åŒ…
- ä¿ç•™åŸåŒ…çš„æ‰€æœ‰åŠŸèƒ½
- è‡ªåŠ¨æ·»åŠ é­”æ”¹æ ‡è¯†åç¼€

## ä½¿ç”¨å»ºè®®
- å¤„ç†å‰å¤‡ä»½åŸå§‹ DEB åŒ…
- æµ‹è¯•é­”æ”¹åçš„åŒ…æ˜¯å¦æ­£å¸¸å·¥ä½œ
- å»ºè®®åœ¨æ²™ç›’ç¯å¢ƒä¸­å…ˆè¡Œæµ‹è¯•`,
		},
		{
			Title: "DEB åŒ…åˆ›å»º",
			Icon:  "ğŸ†•",
			Content: `# DEB åŒ…åˆ›å»ºåŠŸèƒ½

## åŠŸèƒ½ä»‹ç»
ä»é›¶å¼€å§‹åˆ›å»ºå…¨æ–°çš„ iOS DEB å®‰è£…åŒ…ï¼Œé›†æˆé­”æ”¹åçš„ Frida ç»„ä»¶ã€‚

## åˆ›å»ºæµç¨‹
### 1. ç»„ä»¶é€‰æ‹©
- **frida-server**ï¼šå¿…é€‰çš„æ ¸å¿ƒæœåŠ¡æ–‡ä»¶
- **frida-agent**ï¼šå¯é€‰çš„ Agent åº“æ–‡ä»¶
- **é…ç½®æ–‡ä»¶**ï¼šLaunchDaemon plist é…ç½®

### 2. åŒ…ä¿¡æ¯é…ç½®
- **åŒ…å**ï¼šè‡ªåŠ¨ç”Ÿæˆæˆ–æ‰‹åŠ¨æŒ‡å®š
- **ç‰ˆæœ¬å·**ï¼šéµå¾ª Debian ç‰ˆæœ¬è§„èŒƒ
- **ç»´æŠ¤è€…ä¿¡æ¯**ï¼šåŒ…çš„ç»´æŠ¤è€…ä¿¡æ¯
- **æè¿°ä¿¡æ¯**ï¼šåŒ…çš„åŠŸèƒ½æè¿°

### 3. é«˜çº§é€‰é¡¹
- **ä¾èµ–å…³ç³»**ï¼šæŒ‡å®šåŒ…çš„ä¾èµ–é¡¹
- **å†²çªå¤„ç†**ï¼šé¿å…ä¸ç°æœ‰åŒ…å†²çª
- **å®‰è£…è„šæœ¬**ï¼šè‡ªå®šä¹‰å®‰è£…/å¸è½½è„šæœ¬

## æ”¯æŒçš„å®‰è£…æ–¹å¼
### Root æ¨¡å¼
- ä¼ ç»Ÿçš„ root æƒé™å®‰è£…
- å®Œæ•´çš„ç³»ç»Ÿè®¿é—®æƒé™
- å…¼å®¹æ€§æœ€å¥½

### Rootless æ¨¡å¼
- é€‚é…æ–°ç‰ˆæœ¬ iOS çš„ rootless ç¯å¢ƒ
- å—é™çš„ç³»ç»Ÿè®¿é—®æƒé™
- æ›´é«˜çš„å®‰å…¨æ€§

## è‡ªåŠ¨åŒ–åŠŸèƒ½
- **æ™ºèƒ½åŒ…å**ï¼šåŸºäºé­”æ”¹åç§°è‡ªåŠ¨ç”Ÿæˆ
- **ç‰ˆæœ¬ç®¡ç†**ï¼šè‡ªåŠ¨é€’å¢ç‰ˆæœ¬å·
- **æƒé™è®¾ç½®**ï¼šè‡ªåŠ¨è®¾ç½®æ­£ç¡®çš„æ–‡ä»¶æƒé™
- **ç­¾åéªŒè¯**ï¼šå¯é€‰çš„åŒ…ç­¾ååŠŸèƒ½

## è¾“å‡ºæ–‡ä»¶
- æ ‡å‡†çš„ .deb å®‰è£…åŒ…
- åŒ…å«æ‰€æœ‰å¿…è¦çš„å…ƒæ•°æ®
- å¯ç›´æ¥ç”¨äº Cydia/Sileo å®‰è£…

## è´¨é‡ä¿è¯
- åŒ…ç»“æ„éªŒè¯
- æ–‡ä»¶å®Œæ•´æ€§æ£€æŸ¥
- å…¼å®¹æ€§æµ‹è¯•å»ºè®®`,
		},
		{
			Title: "frida-tools é­”æ”¹",
			Icon:  "ğŸ› ï¸",
			Content: `# frida-tools é­”æ”¹åŠŸèƒ½

## åŠŸèƒ½ç›®æ ‡
å¯¹PCä¸­å®‰è£…çš„ frida-tools Python åŒ…è¿›è¡Œé­”æ”¹ï¼Œé¿å…æ— æ³•è®¿é—®é­”æ”¹è¿‡çš„ frida-serverã€‚

## æ£€æµ‹æœºåˆ¶
### Python ç¯å¢ƒæ‰«æ
- **Conda ç¯å¢ƒ**ï¼šè‡ªåŠ¨æ£€æµ‹æ‰€æœ‰ conda ç¯å¢ƒ
- **ç³»ç»Ÿ Python**ï¼šæ£€æµ‹ç³»ç»Ÿçº§ Python å®‰è£…
- **è™šæ‹Ÿç¯å¢ƒ**ï¼šè¯†åˆ« venv/virtualenv ç¯å¢ƒ

### frida-tools æ£€æµ‹
- ä½¿ç”¨ pip show frida-tools æ£€æŸ¥å®‰è£…çŠ¶æ€
- è·å–å®‰è£…è·¯å¾„å’Œç‰ˆæœ¬ä¿¡æ¯
- éªŒè¯åŒ…çš„å®Œæ•´æ€§

## é­”æ”¹å†…å®¹
### 1. Python ä»£ç é­”æ”¹
- ä¿®æ”¹ Python æºç ä¸­çš„å­—ç¬¦ä¸²å¸¸é‡
- æ›¿æ¢é»˜è®¤çš„ "frida" æ ‡è¯†ç¬¦
- ä¿æŒä»£ç åŠŸèƒ½å®Œæ•´æ€§

### 2. äºŒè¿›åˆ¶åº“é­”æ”¹
- é­”æ”¹ .so/.pyd åŠ¨æ€åº“æ–‡ä»¶
- ä½¿ç”¨å†…ç½® HexReplacer å¼•æ“
- æ”¯æŒè·¨å¹³å°äºŒè¿›åˆ¶å¤„ç†

### 3. é…ç½®æ–‡ä»¶ä¿®æ”¹
- æ›´æ–°ç›¸å…³é…ç½®æ–‡ä»¶
- ä¿®æ”¹é»˜è®¤ç«¯å£è®¾ç½®
- ä¿æŒå·¥å…·å…¼å®¹æ€§

## å®‰å…¨æœºåˆ¶
### è‡ªåŠ¨å¤‡ä»½
- é­”æ”¹å‰è‡ªåŠ¨å¤‡ä»½åŸå§‹æ–‡ä»¶
- æ”¯æŒä¸€é”®æ¢å¤åˆ°åŸå§‹çŠ¶æ€
- å¤‡ä»½æ–‡ä»¶å®Œæ•´æ€§éªŒè¯

### å†²çªæ£€æµ‹
- æ£€æµ‹æ˜¯å¦æœ‰æ­£åœ¨è¿è¡Œçš„ frida è¿›ç¨‹
- é¿å…åœ¨ä½¿ç”¨ä¸­çš„ç¯å¢ƒè¿›è¡Œé­”æ”¹
- æä¾›å®‰å…¨çš„é­”æ”¹æ—¶æœºå»ºè®®

## ä½¿ç”¨æµç¨‹
1. **ç¯å¢ƒæ‰«æ**ï¼šè‡ªåŠ¨æ£€æµ‹æ‰€æœ‰ Python ç¯å¢ƒ
2. **é€‰æ‹©ç¯å¢ƒ**ï¼šé€‰æ‹©è¦é­”æ”¹çš„ Python ç¯å¢ƒ
3. **é…ç½®å‚æ•°**ï¼šè®¾ç½®é­”æ”¹åç§°å’Œç«¯å£
4. **æ‰§è¡Œé­”æ”¹**ï¼šè‡ªåŠ¨å¤‡ä»½å¹¶æ‰§è¡Œé­”æ”¹
5. **éªŒè¯ç»“æœ**ï¼šæ£€æŸ¥é­”æ”¹æ˜¯å¦æˆåŠŸ

## æ³¨æ„äº‹é¡¹
- é­”æ”¹ä¼šå½±å“è¯¥ç¯å¢ƒä¸­çš„æ‰€æœ‰ frida å·¥å…·
- å»ºè®®åœ¨ä¸“ç”¨ç¯å¢ƒä¸­è¿›è¡Œé­”æ”¹
- é­”æ”¹åçš„å·¥å…·ä¸åŸç‰ˆä¸å…¼å®¹
- å¯ä»¥éšæ—¶æ¢å¤åˆ°åŸå§‹çŠ¶æ€`,
		},
		{
			Title: "è®¾ç½®",
			Icon:  "âš™ï¸",
			Content: `# è®¾ç½®è¯¦è§£

## å…¨å±€é…ç½®
### åº”ç”¨ç‰ˆæœ¬
- æ˜¾ç¤ºå½“å‰ç¨‹åºç‰ˆæœ¬ä¿¡æ¯
- åªè¯»å­—æ®µï¼Œä¸å¯ä¿®æ”¹

### å·¥ä½œç›®å½•
- ç¨‹åºçš„ä¸»è¦å·¥ä½œç›®å½•
- å­˜å‚¨ä¸´æ—¶æ–‡ä»¶å’Œç¼“å­˜
- é»˜è®¤ä½ç½®ï¼š~/.fridare

## ç½‘ç»œé…ç½®
### ä»£ç†è®¾ç½®
- æ”¯æŒ HTTP/HTTPS ä»£ç†
- æ ¼å¼ï¼šhttp://proxy:port
- å½±å“æ‰€æœ‰ç½‘ç»œä¸‹è½½æ“ä½œ

### è¶…æ—¶æ—¶é—´
- ç½‘ç»œè¯·æ±‚è¶…æ—¶æ—¶é—´
- èŒƒå›´ï¼š5-300 ç§’
- å½±å“ä¸‹è½½å’Œç½‘ç»œéªŒè¯

### é‡è¯•æ¬¡æ•°
- ç½‘ç»œå¤±è´¥åçš„é‡è¯•æ¬¡æ•°
- èŒƒå›´ï¼š0-10 æ¬¡
- æé«˜ç½‘ç»œæ“ä½œæˆåŠŸç‡

## Frida é…ç½®
### é»˜è®¤ç«¯å£
- Frida æœåŠ¡çš„é»˜è®¤ç›‘å¬ç«¯å£
- èŒƒå›´ï¼š1-65535
- å½±å“æ‰€æœ‰é­”æ”¹æ“ä½œ

### é­”æ”¹åç§°
- å…¨å±€é»˜è®¤çš„é­”æ”¹æ ‡è¯†ç¬¦
- å¿…é¡»ä¸º 5 ä¸ªå­—ç¬¦
- ä»¥å­—æ¯å¼€å¤´ï¼ŒåŒ…å«å­—æ¯å’Œæ•°å­—

### è‡ªåŠ¨ç¡®è®¤æ“ä½œ
- å¯ç”¨åè·³è¿‡ç¡®è®¤å¯¹è¯æ¡†
- æé«˜æ‰¹é‡æ“ä½œæ•ˆç‡
- å»ºè®®ç†Ÿç»ƒç”¨æˆ·å¯ç”¨

## ç•Œé¢é…ç½®
### ä¸»é¢˜é€‰æ‹©
- **Auto**ï¼šè·Ÿéšç³»ç»Ÿä¸»é¢˜
- **Light**ï¼šæµ…è‰²ä¸»é¢˜
- **Dark**ï¼šæ·±è‰²ä¸»é¢˜
- æ”¯æŒå®æ—¶åˆ‡æ¢

### çª—å£å°ºå¯¸
- è‡ªå®šä¹‰ç¨‹åºçª—å£å¤§å°
- å®½åº¦ï¼šæœ€å° 800 åƒç´ 
- é«˜åº¦ï¼šæœ€å° 600 åƒç´ 

### è°ƒè¯•æ¨¡å¼
- å¯ç”¨è¯¦ç»†çš„è°ƒè¯•ä¿¡æ¯
- æ˜¾ç¤ºæ›´å¤šæŠ€æœ¯ç»†èŠ‚
- ä¾¿äºé—®é¢˜è¯Šæ–­

## ä¸‹è½½é…ç½®
### ä¸‹è½½ç›®å½•
- Frida ç»„ä»¶çš„ä¸‹è½½ç›®å½•
- é»˜è®¤ï¼š~/Downloads/fridare
- å¯è‡ªå®šä¹‰åˆ°ä»»æ„ä½ç½®

### å¹¶å‘ä¸‹è½½æ•°
- åŒæ—¶è¿›è¡Œçš„ä¸‹è½½ä»»åŠ¡æ•°
- èŒƒå›´ï¼š1-10 ä¸ª
- è¿‡å¤§å¯èƒ½å¯¼è‡´ç½‘ç»œæ‹¥å µ

## é…ç½®ç®¡ç†
### ä¿å­˜è®¾ç½®
- å®æ—¶éªŒè¯é…ç½®æœ‰æ•ˆæ€§
- è‡ªåŠ¨ä¿å­˜åˆ°é…ç½®æ–‡ä»¶
- ä¸‹æ¬¡å¯åŠ¨è‡ªåŠ¨åŠ è½½

### é‡ç½®é»˜è®¤
- ä¸€é”®æ¢å¤æ‰€æœ‰é»˜è®¤è®¾ç½®
- ä¼šæ¸…é™¤æ‰€æœ‰è‡ªå®šä¹‰é…ç½®
- æ“ä½œå‰ä¼šå¼¹å‡ºç¡®è®¤å¯¹è¯æ¡†

### å¯¼å…¥/å¯¼å‡º
- æ”¯æŒé…ç½®æ–‡ä»¶çš„å¯¼å…¥å¯¼å‡º
- ä¾¿äºåœ¨å¤šå°è®¾å¤‡é—´åŒæ­¥é…ç½®
- ä½¿ç”¨ JSON æ ¼å¼å­˜å‚¨`,
		},
		{
			Title: "æ•…éšœæ’é™¤",
			Icon:  "ğŸ”",
			Content: `# æ•…éšœæ’é™¤æŒ‡å—

## å¸¸è§é—®é¢˜

### 1. ä¸‹è½½å¤±è´¥
**ç—‡çŠ¶**ï¼šæ— æ³•ä¸‹è½½ Frida ç»„ä»¶ï¼Œè¿æ¥è¶…æ—¶

**è§£å†³æ–¹æ¡ˆ**ï¼š
- æ£€æŸ¥ç½‘ç»œè¿æ¥çŠ¶æ€
- é…ç½®åˆé€‚çš„ä»£ç†æœåŠ¡å™¨
- å¢åŠ è¶…æ—¶æ—¶é—´è®¾ç½®
- å°è¯•æ›´æ¢ä¸‹è½½æº

### 2. é­”æ”¹å¤±è´¥
**ç—‡çŠ¶**ï¼šæ–‡ä»¶é­”æ”¹è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯

**è§£å†³æ–¹æ¡ˆ**ï¼š
- ç¡®ä¿æ–‡ä»¶æœªè¢«å…¶ä»–ç¨‹åºå ç”¨
- æ£€æŸ¥æ–‡ä»¶æƒé™è®¾ç½®
- éªŒè¯é­”æ”¹åç§°æ ¼å¼æ­£ç¡®
- å°è¯•é‡æ–°ä¸‹è½½åŸå§‹æ–‡ä»¶

### 3. Python ç¯å¢ƒæ£€æµ‹å¤±è´¥
**ç—‡çŠ¶**ï¼šæ— æ³•æ£€æµ‹åˆ° Python ç¯å¢ƒæˆ– frida-tools

**è§£å†³æ–¹æ¡ˆ**ï¼š
- ç¡®ä¿ Python æ­£ç¡®å®‰è£…
- æ£€æŸ¥ PATH ç¯å¢ƒå˜é‡
- é‡æ–°å®‰è£… frida-tools
- å°è¯•åœ¨ç®¡ç†å‘˜æƒé™ä¸‹è¿è¡Œ

### 4. DEB åŒ…åˆ›å»ºå¤±è´¥
**ç—‡çŠ¶**ï¼šDEB åŒ…åˆ›å»ºè¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯

**è§£å†³æ–¹æ¡ˆ**ï¼š
- æ£€æŸ¥æ‰€é€‰æ–‡ä»¶çš„å®Œæ•´æ€§
- ç¡®ä¿æœ‰è¶³å¤Ÿçš„ç£ç›˜ç©ºé—´
- éªŒè¯åŒ…ä¿¡æ¯æ ¼å¼æ­£ç¡®
- æ£€æŸ¥ç›®æ ‡ç›®å½•å†™æƒé™

### 5. PCç«¯è¿æ¥iOSå¤±è´¥
**ç—‡çŠ¶**ï¼šfrida-ps -U æ— æ³•è¿æ¥åˆ°è®¾å¤‡

**è§£å†³æ–¹æ¡ˆ**ï¼š
- ç¡®è®¤iOSè®¾å¤‡å·²å®‰è£…é­”æ”¹åçš„frida-server
- æ£€æŸ¥PCç«¯æ˜¯å¦å·²æ‰§è¡Œ"ğŸ› ï¸ frida-tools é­”æ”¹"
- éªŒè¯iOSè®¾å¤‡ç«¯å’ŒPCç«¯é­”æ”¹åç§°æ˜¯å¦å®Œå…¨ä¸€è‡´
- ç¡®è®¤è®¾å¤‡USBè¿æ¥æ­£å¸¸
- é‡æ–°å¯åŠ¨frida-serverè¿›ç¨‹

## è°ƒè¯•æŠ€å·§

### å¯ç”¨è°ƒè¯•æ¨¡å¼
åœ¨è®¾ç½®é¡µé¢å¯ç”¨"è°ƒè¯•æ¨¡å¼"ï¼Œå¯ä»¥è·å¾—æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯ã€‚

### æŸ¥çœ‹æ—¥å¿—ä¿¡æ¯
ç¨‹åºåº•éƒ¨çš„æ—¥å¿—åŒºåŸŸä¼šæ˜¾ç¤ºè¯¦ç»†çš„æ“ä½œä¿¡æ¯ï¼Œæœ‰åŠ©äºè¯Šæ–­é—®é¢˜ã€‚

### æ–‡ä»¶æƒé™æ£€æŸ¥
ç¡®ä¿ç¨‹åºå¯¹å·¥ä½œç›®å½•å…·æœ‰è¯»å†™æƒé™ã€‚

### ç½‘ç»œè¿æ¥æµ‹è¯•
ä½¿ç”¨è®¾ç½®é¡µé¢çš„"æµ‹è¯•ä»£ç†"åŠŸèƒ½éªŒè¯ç½‘ç»œé…ç½®ã€‚

## è·å–æ”¯æŒä¸å¸®åŠ©

### é¡¹ç›®ä¿¡æ¯
- **GitHubé¡¹ç›®åœ°å€**: https://github.com/suifei/fridare
- **é¡¹ç›®æ–‡æ¡£**: https://github.com/suifei/fridare/blob/main/README.md
- **é—®é¢˜åé¦ˆ**: https://github.com/suifei/fridare/issues

### æŠ€æœ¯äº¤æµ
- **QQæŠ€æœ¯äº¤æµç¾¤**: 5353548813
- **è®¨è®ºè¯é¢˜**: Fridaé­”æ”¹æŠ€æœ¯ã€iOSé€†å‘ã€å·¥å…·ä½¿ç”¨ç»éªŒ
- **ç¾¤å†…èµ„æº**: æœ€æ–°ç‰ˆæœ¬å‘å¸ƒã€æŠ€æœ¯æ–‡æ¡£ã€é—®é¢˜è§£ç­”

### é”™è¯¯æŠ¥å‘Š
é‡åˆ°é—®é¢˜æ—¶ï¼Œè¯·æä¾›ï¼š
- é”™è¯¯çš„è¯¦ç»†æè¿°å’Œæˆªå›¾
- æ“ä½œç³»ç»Ÿç‰ˆæœ¬å’Œæ¶æ„
- ç¨‹åºç‰ˆæœ¬ä¿¡æ¯
- ç›¸å…³çš„æ—¥å¿—ä¿¡æ¯
- å¤ç°é—®é¢˜çš„å…·ä½“æ­¥éª¤

### ç¤¾åŒºæ”¯æŒ
- æŸ¥çœ‹é¡¹ç›® Wiki æ–‡æ¡£
- æœç´¢å·²çŸ¥é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ
- åœ¨GitHubæäº¤ Issue æŠ¥å‘Š
- å‚ä¸QQç¾¤è®¨è®º

## é¢„é˜²æªæ–½

### å®šæœŸå¤‡ä»½
- å®šæœŸå¤‡ä»½é‡è¦çš„é…ç½®æ–‡ä»¶
- ä¿ç•™åŸå§‹çš„ Frida ç»„ä»¶
- è®°å½•é­”æ”¹è¿‡çš„ç¯å¢ƒä¿¡æ¯

### ç¯å¢ƒéš”ç¦»
- ä½¿ç”¨ä¸“ç”¨çš„ Python ç¯å¢ƒè¿›è¡Œé­”æ”¹
- é¿å…åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ç›´æ¥æ“ä½œ
- åœ¨è™šæ‹Ÿæœºä¸­æµ‹è¯•æ–°åŠŸèƒ½

### ç‰ˆæœ¬ç®¡ç†
- è®°å½•ä½¿ç”¨çš„ Frida ç‰ˆæœ¬
- ä¿ç•™å¤šä¸ªç‰ˆæœ¬çš„å¤‡ä»½
- æµ‹è¯•å…¼å®¹æ€§åå†å‡çº§

## å¸¸è§é”™è¯¯ä»£ç 

### Error 1001: ç½‘ç»œè¿æ¥å¤±è´¥
- æ£€æŸ¥ç½‘ç»œè¿æ¥
- é…ç½®æ­£ç¡®çš„ä»£ç†è®¾ç½®
- ç¡®è®¤é˜²ç«å¢™è®¾ç½®

### Error 1002: æ–‡ä»¶æƒé™ä¸è¶³
- ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œç¨‹åº
- æ£€æŸ¥ç›®æ ‡ç›®å½•æƒé™
- æš‚æ—¶å…³é—­å®‰å…¨è½¯ä»¶

### Error 1003: Pythonç¯å¢ƒå¼‚å¸¸
- é‡æ–°å®‰è£…Python
- æ›´æ–°pipåˆ°æœ€æ–°ç‰ˆæœ¬
- é‡æ–°å®‰è£…frida-tools

### Error 1004: é­”æ”¹åç§°å†²çª
- ä½¿ç”¨ä¸åŒçš„é­”æ”¹åç§°
- æ£€æŸ¥å·²å­˜åœ¨çš„è¿›ç¨‹
- é‡å¯ç›¸å…³æœåŠ¡

å¦‚éœ€æ›´å¤šå¸®åŠ©ï¼Œè¯·è®¿é—®é¡¹ç›®GitHubé¡µé¢æˆ–åŠ å…¥QQæŠ€æœ¯äº¤æµç¾¤è·å–æ”¯æŒã€‚`,
		},
		{
			Title: "æœ€ä½³å®è·µ",
			Icon:  "ğŸ“‹",
			Content: `# æœ€ä½³å®è·µæŒ‡å—

## ä½¿ç”¨æµç¨‹å»ºè®®

### 1.1 Frida é­”æ”¹ + DEBåŒ…åˆ›å»ºæµç¨‹
- **é€‚ç”¨åœºæ™¯**ï¼šé’ˆå¯¹æ‰€æœ‰å¹³å°çš„ frida-server è¿›ç¨‹è¿›è¡Œé­”æ”¹
- **æ“ä½œæ­¥éª¤**ï¼š
  1. ä½¿ç”¨"ğŸ”§ frida é­”æ”¹"åŠŸèƒ½ä¿®æ”¹ frida-server äºŒè¿›åˆ¶æ–‡ä»¶
  2. ä½¿ç”¨"ğŸ†• iOS DEB æ‰“åŒ…"åŠŸèƒ½åˆ¶ä½œiOSå®‰è£…åŒ…
  3. **é‡è¦**ï¼šä½¿ç”¨"ğŸ› ï¸ frida-tools é­”æ”¹"åŠŸèƒ½ä¿®æ”¹PCç«¯ Frida CLI
- **æ³¨æ„äº‹é¡¹**ï¼šç¡®ä¿é­”æ”¹åç§°åœ¨æ‰€æœ‰æ­¥éª¤ä¸­ä¿æŒä¸€è‡´

### 1.2 DEBåŒ…é­”æ”¹æµç¨‹
- **é€‚ç”¨åœºæ™¯**ï¼šé’ˆå¯¹å®˜æ–¹å‘å¸ƒçš„ DEB åŒ…è¿›è¡Œä¿®æ”¹
- **æ“ä½œæ­¥éª¤**ï¼š
  1. ä½¿ç”¨"ğŸ“¦ iOS DEB é­”æ”¹"åŠŸèƒ½ä¿®æ”¹ç°æœ‰DEBåŒ…
  2. æ”¯æŒ root å’Œ rootless ä¸¤ç§æ¨¡å¼
  3. å°†é­”æ”¹åçš„ DEB åŒ…å®‰è£…åˆ°iOSè®¾å¤‡
  4. **é‡è¦**ï¼šä½¿ç”¨"ğŸ› ï¸ frida-tools é­”æ”¹"åŠŸèƒ½ä¿®æ”¹PCç«¯ Frida CLI
- **ä¼˜åŠ¿**ï¼šåŸºäºå®˜æ–¹åŒ…ï¼Œç¨³å®šæ€§æ›´å¥½

### 1.3 DEBåŒ…åˆ›å»ºæµç¨‹
- **é€‚ç”¨åœºæ™¯**ï¼šå®Œå…¨è‡ªå®šä¹‰åˆ›å»ºiOS DEBå®‰è£…åŒ…
- **æ“ä½œæ­¥éª¤**ï¼š
  1. ä½¿ç”¨"ğŸ†• iOS DEB æ‰“åŒ…"åŠŸèƒ½ä»å¤´åˆ›å»ºDEBåŒ…
  2. è‡ªå®šä¹‰åŒ…åã€ç‰ˆæœ¬ã€é…ç½®ç­‰ä¿¡æ¯
  3. **é‡è¦**ï¼šä½¿ç”¨"ğŸ› ï¸ frida-tools é­”æ”¹"åŠŸèƒ½ä¿®æ”¹PCç«¯ Frida CLI
- **ç‰¹ç‚¹**ï¼šå®Œå…¨å¯æ§ï¼Œé€‚åˆé«˜çº§ç”¨æˆ·

## âš ï¸ é‡è¦æé†’

### PCç«¯é…ç½®è¦æ±‚
**å…³é”®**ï¼šFridaé­”æ”¹åï¼ŒPCä¸Šè¦è®©fridaå‘½ä»¤èƒ½æ­£ç¡®è®¿é—®iOSè®¾å¤‡ï¼Œå¿…é¡»é‡‡ç”¨ä¸€è‡´çš„é­”æ”¹å­—ç¬¦é€šè¿‡"ğŸ› ï¸ frida-tools é­”æ”¹"åŠŸèƒ½ä¿®æ”¹PCç«¯çš„Pythonåº“ã€‚

### é­”æ”¹åç§°ä¸€è‡´æ€§
- iOSè®¾å¤‡ç«¯çš„ frida-server é­”æ”¹åç§°
- PCç«¯çš„ frida-tools é­”æ”¹åç§°
- **å¿…é¡»å®Œå…¨ä¸€è‡´**ï¼Œå¦åˆ™æ— æ³•æ­£å¸¸è¿æ¥

## ç¯å¢ƒå‡†å¤‡
- é¦–æ¬¡ä½¿ç”¨å‰å®ŒæˆåŸºæœ¬è®¾ç½®é…ç½®
- åˆ›å»ºä¸“ç”¨çš„å·¥ä½œç›®å½•
- é…ç½®åˆé€‚çš„ç½‘ç»œä»£ç†ï¼ˆå¦‚éœ€è¦ï¼‰

## ç»„ä»¶è·å–
- ä¼˜å…ˆä¸‹è½½æœ€æ–°ç¨³å®šç‰ˆæœ¬
- åŒæ—¶ä¿ç•™ä¸€ä¸ªå¤‡ç”¨ç‰ˆæœ¬
- éªŒè¯ä¸‹è½½æ–‡ä»¶çš„å®Œæ•´æ€§

## é­”æ”¹ç­–ç•¥
- ä½¿ç”¨éšæœºç”Ÿæˆçš„é­”æ”¹åç§°
- é¿å…ä½¿ç”¨å®¹æ˜“è¢«è¯†åˆ«çš„åç§°
- å®šæœŸæ›´æ¢é­”æ”¹å‚æ•°

## æµ‹è¯•éªŒè¯
- åœ¨æµ‹è¯•ç¯å¢ƒä¸­éªŒè¯é­”æ”¹æ•ˆæœ
- ç¡®è®¤åŠŸèƒ½æ­£å¸¸åå†éƒ¨ç½²
- ä¿ç•™åŸå§‹æ–‡ä»¶ä½œä¸ºå¤‡ä»½

## å®‰å…¨å»ºè®®
- é­”æ”¹åç§°é¿å…ä½¿ç”¨æ•æ„Ÿè¯æ±‡
- ä½¿ç”¨éšæœºå­—ç¬¦ç»„åˆ
- å®šæœŸæ›´æ¢æ ‡è¯†ç¬¦
- ä½¿ç”¨å¯ä¿¡çš„ä»£ç†æœåŠ¡å™¨
- å®šæœŸæ›´æ–°ç¨‹åºç‰ˆæœ¬

## ç»´æŠ¤å»ºè®®
- æ¯æœˆæ£€æŸ¥é…ç½®è®¾ç½®
- æ¸…ç†ä¸éœ€è¦çš„ä¸‹è½½æ–‡ä»¶
- æ›´æ–°åˆ°æœ€æ–°ç¨‹åºç‰ˆæœ¬
- å¤‡ä»½é‡è¦é…ç½®å’Œæ“ä½œæ—¥å¿—`,
		},
	}
}

// setupUI è®¾ç½®UIç•Œé¢
func (ht *HelpTab) setupUI() {
	// åˆ›å»ºç´¢å¼•åˆ—è¡¨
	ht.indexList = widget.NewList(
		func() int {
			return len(ht.helpSections)
		},
		func() fyne.CanvasObject {
			icon := widget.NewLabel("")
			title := widget.NewLabel("")
			title.TextStyle = fyne.TextStyle{Bold: true}
			return container.NewHBox(icon, title)
		},
		func(id widget.ListItemID, obj fyne.CanvasObject) {
			container := obj.(*fyne.Container)
			icon := container.Objects[0].(*widget.Label)
			title := container.Objects[1].(*widget.Label)

			section := ht.helpSections[id]
			icon.SetText(section.Icon)
			title.SetText(section.Title)
		},
	)

	// è®¾ç½®é€‰æ‹©äº‹ä»¶
	ht.currentIndex = -1
	ht.indexList.OnSelected = func(id widget.ListItemID) {
		// é¿å…é‡å¤åŠ è½½ç›¸åŒå†…å®¹
		if ht.currentIndex == id {
			return
		}

		ht.showContent(id)
	}

	// åˆ›å»ºå†…å®¹æ˜¾ç¤ºåŒºåŸŸ
	ht.contentViewer = widget.NewRichText()
	ht.contentViewer.Wrapping = fyne.TextWrapWord
	ht.contentViewer.Scroll = container.ScrollBoth

	// æ˜¾ç¤ºé»˜è®¤å†…å®¹
	ht.showContent(0)
	ht.indexList.Select(0)

	// å¼ºåˆ¶åˆ·æ–°åˆ—è¡¨
	ht.indexList.Refresh()

	// åˆ›å»ºå·¦ä¾§é¢æ¿ - ä½¿ç”¨Borderå¸ƒå±€è®©åˆ—è¡¨è‡ªé€‚åº”é«˜åº¦
	titleLabel := widget.NewLabel("ğŸ“– å¸®åŠ©ç›®å½•")
	titleLabel.TextStyle = fyne.TextStyle{Bold: true}

	leftPanel := container.NewBorder(
		container.NewVBox(titleLabel, widget.NewSeparator()), // top
		nil,          // bottom
		nil,          // left
		nil,          // right
		ht.indexList, // center - åˆ—è¡¨å æ®å‰©ä½™ç©ºé—´
	)

	// åˆ›å»ºå³ä¾§é¢æ¿ - å†…å®¹æ˜¾ç¤ºåŒºåŸŸ
	rightPanel := container.NewBorder(
		nil, nil, nil, nil,
		container.NewScroll(ht.contentViewer),
	)

	// ä½¿ç”¨åˆ†å‰²å®¹å™¨ - è°ƒæ•´åˆ†å‰²æ¯”ä¾‹
	split := container.NewHSplit(leftPanel, rightPanel)
	split.SetOffset(0.3) // å·¦ä¾§å 30%ï¼Œå³ä¾§å 70%

	// å°†åˆ†å‰²å®¹å™¨åŒ…è£…åœ¨æ™®é€šå®¹å™¨ä¸­
	ht.content = container.NewBorder(nil, nil, nil, nil, split)
}

// showContent æ˜¾ç¤ºæŒ‡å®šç« èŠ‚çš„å†…å®¹
func (ht *HelpTab) showContent(index int) {
	if index >= 0 && index < len(ht.helpSections) {
		section := ht.helpSections[index]
		ht.contentViewer.ParseMarkdown(section.Content)
		ht.currentIndex = index
	}
}

// Content è¿”å›æ ‡ç­¾é¡µå†…å®¹
func (ht *HelpTab) Content() *fyne.Container {
	return ht.content
}

// AnalysisTab æ–‡ä»¶åˆ†ææ ‡ç­¾é¡µ
type AnalysisTab struct {
	app          fyne.App
	config       *config.Config
	updateStatus StatusUpdater
	addLog       func(string)
	content      *fyne.Container

	// UI ç»„ä»¶
	filePathEntry *widget.Entry
	browseBtn     *widget.Button
	analyzeBtn    *widget.Button
	// è¿‡æ»¤æœç´¢æ¡†
	searchEntry *widget.Entry

	// å·¦ä¾§æ ‘å½¢ç»“æ„
	tree *widget.Tree

	// å³ä¾§è¡¨æ ¼ï¼ˆåŒè¡¨æ ¼æ¨¡å¼ï¼‰
	sectionListTable *widget.Table // æ®µåˆ—è¡¨è¡¨æ ¼ï¼ˆIDAé£æ ¼ï¼‰
	sectionDataTable *widget.Table // æ®µæ•°æ®è¡¨æ ¼ï¼ˆåå…­è¿›åˆ¶/å­—ç¬¦ä¸²ï¼‰
	currentTable     *widget.Table // å½“å‰æ˜¾ç¤ºçš„è¡¨æ ¼

	// å½“å‰æ–‡ä»¶ä¿¡æ¯
	currentFile     string
	fileInfo        *core.FileInfo
	selectedSection int
	analyzer        *core.BinaryAnalyzer

	// æ•°æ®ç¼“å­˜ - ç”¨äºä¼˜åŒ–æ€§èƒ½
	sectionDataCache    map[int][]byte // æ®µæ•°æ®ç¼“å­˜
	lastSelectedSection int            // ä¸Šæ¬¡é€‰ä¸­çš„æ®µï¼Œç”¨äºæ£€æµ‹å˜åŒ–

	// æœç´¢è¿‡æ»¤åŠŸèƒ½
	currentSearchText string        // å½“å‰æœç´¢æ–‡æœ¬
	filteredStrings   []StringData  // è¿‡æ»¤åçš„å­—ç¬¦ä¸²åˆ—è¡¨
	highlightMatches  map[int][]int // é«˜äº®åŒ¹é…ä½ç½®ï¼šè¡Œå·->åŒ¹é…ä½ç½®æ•°ç»„
}

// NewAnalysisTab åˆ›å»ºåˆ†ææ ‡ç­¾é¡µ
func NewAnalysisTab(app fyne.App, cfg *config.Config, statusUpdater StatusUpdater, logFunc func(string)) *AnalysisTab {
	at := &AnalysisTab{
		app:                 app,
		config:              cfg,
		updateStatus:        statusUpdater,
		addLog:              logFunc,
		selectedSection:     -1,
		sectionDataCache:    make(map[int][]byte),
		lastSelectedSection: -1,
	}

	at.setupUI()
	return at
}

func (at *AnalysisTab) setupUI() {
	// æ–‡ä»¶é€‰æ‹©åŒºåŸŸ
	at.filePathEntry = widget.NewEntry()
	at.filePathEntry.SetPlaceHolder("é€‰æ‹©è¦åˆ†æçš„äºŒè¿›åˆ¶æ–‡ä»¶ (Mach-O, PE, ELF)...")

	at.browseBtn = widget.NewButton("æµè§ˆ", func() {
		at.selectFile()
	})

	at.analyzeBtn = widget.NewButton("åˆ†ææ–‡ä»¶", func() {
		at.analyzeFile()
	})
	at.analyzeBtn.Importance = widget.HighImportance
	at.analyzeBtn.Disable()

	at.searchEntry = widget.NewEntry()
	at.searchEntry.SetPlaceHolder("æœå­—ç¬¦ä¸²...")
	at.searchEntry.OnChanged = func(text string) {
		at.filterSectionData(text)
	}

	// æ–‡ä»¶è·¯å¾„æ›´æ”¹äº‹ä»¶ï¼ˆæ·»åŠ è‡ªåŠ¨åˆ†æåŠŸèƒ½ï¼‰
	var autoAnalyzeTimer *time.Timer
	at.filePathEntry.OnChanged = func(path string) {
		if path != "" && at.fileExists(path) {
			at.analyzeBtn.Enable()

			// é‡ç½®å®šæ—¶å™¨ï¼Œå®ç°é˜²æŠ–æ•ˆæœï¼ˆç”¨æˆ·åœæ­¢è¾“å…¥500msåè‡ªåŠ¨åˆ†æï¼‰
			if autoAnalyzeTimer != nil {
				autoAnalyzeTimer.Stop()
			}
			autoAnalyzeTimer = time.AfterFunc(500*time.Millisecond, func() {
				// å†æ¬¡æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œé¿å…è·¯å¾„å˜åŒ–åçš„å»¶è¿Ÿåˆ†æ
				if at.filePathEntry.Text != "" && at.fileExists(at.filePathEntry.Text) {
					at.analyzeFile()
				}
			})
		} else {
			at.analyzeBtn.Disable()
			// å–æ¶ˆå¾…æ‰§è¡Œçš„è‡ªåŠ¨åˆ†æ
			if autoAnalyzeTimer != nil {
				autoAnalyzeTimer.Stop()
			}
		}
	}

	fileSelectArea :=
		container.NewBorder(nil, nil, nil, nil,
			container.NewGridWithColumns(3,
				at.filePathEntry,
				container.NewHBox(at.browseBtn, at.analyzeBtn),
				at.searchEntry),
		)

	// åˆ›å»ºå·¦ä¾§æ ‘å½¢ç»“æ„
	at.tree = widget.NewTree(
		func(uid widget.TreeNodeID) []widget.TreeNodeID {
			return at.getChildNodes(uid)
		},
		func(uid widget.TreeNodeID) bool {
			return at.isBranch(uid)
		},
		func(branch bool) fyne.CanvasObject {
			return widget.NewLabel("Template")
		},
		func(uid widget.TreeNodeID, branch bool, object fyne.CanvasObject) {
			label := object.(*widget.Label)
			label.SetText(at.getNodeText(uid))
			if branch {
				label.TextStyle = fyne.TextStyle{Bold: true}
			} else {
				label.TextStyle = fyne.TextStyle{}
			}
		},
	)

	at.tree.OnSelected = func(uid widget.TreeNodeID) {
		at.onTreeNodeSelected(uid)
	}

	// åˆ›å»ºåŒè¡¨æ ¼ç³»ç»Ÿ
	at.createTables()

	// è®¾ç½®åˆå§‹è¡¨æ ¼ï¼ˆæ®µåˆ—è¡¨æ¨¡å¼ï¼‰
	at.switchToSectionListMode()

	// åˆ›å»ºåˆ†å‰²å®¹å™¨ - ç›´æ¥ä½¿ç”¨è¡¨æ ¼ï¼Œä¸éœ€è¦å®¹å™¨
	splitContainer := container.NewHSplit(
		container.NewBorder(
			widget.NewLabel("æ–‡ä»¶ç»“æ„"),
			nil, nil, nil,
			container.NewScroll(at.tree),
		),
		container.NewBorder(
			widget.NewLabel("è¯¦ç»†ä¿¡æ¯"),
			nil, nil, nil,
			container.NewStack(
				container.NewScroll(at.sectionListTable),
				container.NewScroll(at.sectionDataTable),
			),
		),
	)
	splitContainer.Offset = 0.3 // å·¦ä¾§å 30%

	// ä¸»å¸ƒå±€

	at.content = container.NewBorder(
		widget.NewCard("æ–‡ä»¶é€‰æ‹©", "", fileSelectArea),
		nil, nil, nil,
		splitContainer,
	)

}

// selectFile é€‰æ‹©æ–‡ä»¶
func (at *AnalysisTab) selectFile() {
	dialog.ShowFileOpen(func(reader fyne.URIReadCloser, err error) {
		if err != nil || reader == nil {
			return
		}
		defer reader.Close()

		path := reader.URI().Path()
		at.filePathEntry.SetText(path)

		// è‡ªåŠ¨åˆ†æé€‰ä¸­çš„æ–‡ä»¶
		if path != "" && at.fileExists(path) {
			// ç¨å¾®å»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿UIæ›´æ–°å®Œæˆ
			time.AfterFunc(100*time.Millisecond, func() {
				at.analyzeFile()
			})
		}
	}, at.app.Driver().AllWindows()[0])
}

// fileExists æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
func (at *AnalysisTab) fileExists(path string) bool {
	if path == "" {
		return false
	}
	_, err := os.Stat(path)
	return err == nil
}

// analyzeFile åˆ†ææ–‡ä»¶
func (at *AnalysisTab) analyzeFile() {
	filePath := at.filePathEntry.Text
	if filePath == "" {
		at.updateStatus("è¯·é€‰æ‹©è¦åˆ†æçš„æ–‡ä»¶")
		return
	}

	at.updateStatus("æ­£åœ¨åˆ†ææ–‡ä»¶...")
	at.addLog(fmt.Sprintf("INFO: å¼€å§‹åˆ†ææ–‡ä»¶: %s", filePath))

	go func() {
		defer func() {
			at.updateStatus("æ–‡ä»¶åˆ†æå®Œæˆ")
		}()

		// æ¸…ç†æ—§çš„ç¼“å­˜æ•°æ®
		at.clearSectionDataCache()
		at.selectedSection = -1
		at.lastSelectedSection = -1

		// åˆ›å»ºåˆ†æå™¨
		at.analyzer = core.NewBinaryAnalyzer(filePath)

		// åˆ†ææ–‡ä»¶
		fileInfo, err := at.analyzer.AnalyzeFile()
		if err != nil {
			at.addLog(fmt.Sprintf("ERROR: æ–‡ä»¶åˆ†æå¤±è´¥: %v", err))
			return
		}

		at.currentFile = filePath
		at.fileInfo = fileInfo
		at.addLog(fmt.Sprintf("INFO: æ£€æµ‹åˆ°æ–‡ä»¶ç±»å‹: %s", fileInfo.FileType))
		at.addLog(fmt.Sprintf("INFO: æ¶æ„: %s", fileInfo.Architecture))
		at.addLog(fmt.Sprintf("INFO: æ®µæ•°é‡: %d", len(fileInfo.Sections)))
		at.addLog(fmt.Sprintf("INFO: æ®µæ•°é‡: %d", len(fileInfo.Sections)))

		// åˆ·æ–°UI
		fyne.Do(func() {
			at.tree.Refresh()
			at.currentTable.Refresh()
			at.currentTable.ScrollToTop()
		})
	}()
}

// æ ‘å½¢ç»“æ„ç›¸å…³æ–¹æ³•
func (at *AnalysisTab) getChildNodes(uid widget.TreeNodeID) []widget.TreeNodeID {
	if uid == "" {
		// æ ¹èŠ‚ç‚¹
		if at.currentFile == "" {
			return []widget.TreeNodeID{}
		}
		return []widget.TreeNodeID{"file_info", "sections"}
	}

	switch uid {
	case "file_info":
		// æ–‡ä»¶ä¿¡æ¯å­èŠ‚ç‚¹
		children := []widget.TreeNodeID{}
		if at.fileInfo != nil {
			// æ–‡ä»¶ç±»å‹èŠ‚ç‚¹
			typeLines := strings.Split(at.fileInfo.FileType, "\n")
			for i, line := range typeLines {
				line = strings.TrimSpace(line)
				if line != "" { // å¿½ç•¥ç©ºè¡Œ
					children = append(children, widget.TreeNodeID(fmt.Sprintf("info_type_%d", i)))
				}
			}

			// æ–‡ä»¶å¤§å°èŠ‚ç‚¹
			sizeText := fmt.Sprintf("%d bytes", at.fileInfo.FileSize)
			sizeLines := strings.Split(sizeText, "\n")
			for i, line := range sizeLines {
				line = strings.TrimSpace(line)
				if line != "" { // å¿½ç•¥ç©ºè¡Œ
					children = append(children, widget.TreeNodeID(fmt.Sprintf("info_size_%d", i)))
				}
			}

			// æ¶æ„ä¿¡æ¯èŠ‚ç‚¹
			archLines := strings.Split(at.fileInfo.Architecture, "\n")
			for i, line := range archLines {
				line = strings.TrimSpace(line)
				if line != "" { // å¿½ç•¥ç©ºè¡Œ
					children = append(children, widget.TreeNodeID(fmt.Sprintf("info_arch_%d", i)))
				}
			}

			// è¯¦ç»†ä¿¡æ¯èŠ‚ç‚¹
			if at.fileInfo.DetailedInfo != "" {
				detailLines := strings.Split(at.fileInfo.DetailedInfo, "\n")
				for i, line := range detailLines {
					line = strings.TrimSpace(line)
					if line != "" { // å¿½ç•¥ç©ºè¡Œ
						children = append(children, widget.TreeNodeID(fmt.Sprintf("info_detailed_%d", i)))
					}
				}
			}
		}
		return children
	case "sections":
		children := []widget.TreeNodeID{}
		if at.fileInfo != nil {
			if at.fileInfo.IsFatMachO {
				// Fat Mach-O: å…ˆæ˜¾ç¤ºæ¶æ„èŠ‚ç‚¹
				archMap := make(map[int]bool)
				for _, section := range at.fileInfo.Sections {
					if section.Type == "Architecture" {
						if !archMap[section.ArchIndex] {
							children = append(children, widget.TreeNodeID(fmt.Sprintf("arch_%d", section.ArchIndex)))
							archMap[section.ArchIndex] = true
						}
					}
				}
			} else {
				// æ™®é€šæ–‡ä»¶: ç›´æ¥æ˜¾ç¤ºæ®µèŠ‚ç‚¹
				for i := range at.fileInfo.Sections {
					children = append(children, widget.TreeNodeID(fmt.Sprintf("section_%d", i)))
				}
			}
		}
		return children
	default:
		// å¤„ç†æ¶æ„èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ï¼ˆFat Mach-Oï¼‰
		if strings.HasPrefix(string(uid), "arch_") {
			children := []widget.TreeNodeID{}
			archIndexStr := strings.TrimPrefix(string(uid), "arch_")
			if archIndex, err := strconv.Atoi(archIndexStr); err == nil && at.fileInfo != nil {
				for i, section := range at.fileInfo.Sections {
					if section.ArchIndex == archIndex && section.Type != "Architecture" {
						children = append(children, widget.TreeNodeID(fmt.Sprintf("section_%d", i)))
					}
				}
			}
			return children
		}
		return []widget.TreeNodeID{}
	}
}

func (at *AnalysisTab) isBranch(uid widget.TreeNodeID) bool {
	// æ ¹èŠ‚ç‚¹ã€æ–‡ä»¶ä¿¡æ¯èŠ‚ç‚¹ã€æ®µèŠ‚ç‚¹ã€æ¶æ„èŠ‚ç‚¹æ˜¯åˆ†æ”¯
	if uid == "" || uid == "file_info" || uid == "sections" {
		return true
	}
	// æ¶æ„èŠ‚ç‚¹ä¹Ÿæ˜¯åˆ†æ”¯
	if strings.HasPrefix(string(uid), "arch_") {
		return true
	}
	return false
}

func (at *AnalysisTab) getNodeText(uid widget.TreeNodeID) string {
	switch uid {
	case "":
		return "Root"
	case "file_info":
		return "æ–‡ä»¶ä¿¡æ¯"
	case "sections":
		if at.fileInfo != nil {
			return fmt.Sprintf("æ®µä¿¡æ¯ (%d)", len(at.fileInfo.Sections))
		}
		return "æ®µä¿¡æ¯ (0)"
	default:
		// æ–‡ä»¶ä¿¡æ¯å¤šè¡ŒèŠ‚ç‚¹
		if strings.HasPrefix(string(uid), "info_type_") {
			indexStr := strings.TrimPrefix(string(uid), "info_type_")
			if index, err := strconv.Atoi(indexStr); err == nil && at.fileInfo != nil {
				typeLines := strings.Split(at.fileInfo.FileType, "\n")
				if index < len(typeLines) {
					line := strings.TrimSpace(typeLines[index])
					if line != "" {
						return fmt.Sprintf("æ–‡ä»¶ç±»å‹: %s", line)
					}
				}
			}
			return "æ–‡ä»¶ç±»å‹: æœªçŸ¥"
		}
		if strings.HasPrefix(string(uid), "info_size_") {
			indexStr := strings.TrimPrefix(string(uid), "info_size_")
			if index, err := strconv.Atoi(indexStr); err == nil && at.fileInfo != nil {
				sizeText := fmt.Sprintf("%d bytes", at.fileInfo.FileSize)
				sizeLines := strings.Split(sizeText, "\n")
				if index < len(sizeLines) {
					line := strings.TrimSpace(sizeLines[index])
					if line != "" {
						return fmt.Sprintf("æ–‡ä»¶å¤§å°: %s", line)
					}
				}
			}
			return "æ–‡ä»¶å¤§å°: æœªçŸ¥"
		}
		if strings.HasPrefix(string(uid), "info_arch_") {
			indexStr := strings.TrimPrefix(string(uid), "info_arch_")
			if index, err := strconv.Atoi(indexStr); err == nil && at.fileInfo != nil {
				archLines := strings.Split(at.fileInfo.Architecture, "\n")
				if index < len(archLines) {
					// line := strings.TrimSpace(archLines[index])
					// if line != "" {
					return "æ¶æ„:"
					// }
				}
			}
			return "æ¶æ„: æœªçŸ¥"
		}
		if strings.HasPrefix(string(uid), "info_detailed_") {
			indexStr := strings.TrimPrefix(string(uid), "info_detailed_")
			if index, err := strconv.Atoi(indexStr); err == nil && at.fileInfo != nil {
				detailLines := strings.Split(at.fileInfo.DetailedInfo, "\n")
				if index < len(detailLines) {
					line := strings.TrimSpace(detailLines[index])
					if line != "" {
						return fmt.Sprintf("  %s", line)
					}
				}
			}
			return "è¯¦ç»†ä¿¡æ¯: æœªçŸ¥"
		}

		// æ¶æ„èŠ‚ç‚¹
		if strings.HasPrefix(string(uid), "arch_") {
			archIndexStr := strings.TrimPrefix(string(uid), "arch_")
			if archIndex, err := strconv.Atoi(archIndexStr); err == nil && at.fileInfo != nil {
				for _, section := range at.fileInfo.Sections {
					if section.ArchIndex == archIndex && section.Type == "Architecture" {
						return section.Name
					}
				}
			}
			return fmt.Sprintf("æ¶æ„ %s", archIndexStr)
		}
		// æ®µèŠ‚ç‚¹
		if strings.HasPrefix(string(uid), "section_") {
			index := strings.TrimPrefix(string(uid), "section_")
			if i, err := strconv.Atoi(index); err == nil && at.fileInfo != nil && i < len(at.fileInfo.Sections) {
				section := at.fileInfo.Sections[i]
				return fmt.Sprintf("%s (0x%X, %d bytes)", section.Name, section.Offset, section.Size)
			}
		}
		return string(uid)
	}
}

// getCachedSectionData è·å–ç¼“å­˜çš„æ®µæ•°æ®
func (at *AnalysisTab) getCachedSectionData(sectionIndex int) ([]byte, error) {
	// æ£€æŸ¥ç¼“å­˜
	if data, exists := at.sectionDataCache[sectionIndex]; exists {
		return data, nil
	}

	// è·å–æ–°æ•°æ®å¹¶ç¼“å­˜
	data, err := at.analyzer.GetSectionData(at.currentFile, sectionIndex, at.fileInfo.Sections)
	if err != nil {
		return nil, err
	}

	// åªç¼“å­˜
	at.sectionDataCache[sectionIndex] = data

	return data, nil
}

// clearSectionDataCache æ¸…ç†æ®µæ•°æ®ç¼“å­˜
func (at *AnalysisTab) clearSectionDataCache() {
	at.sectionDataCache = make(map[int][]byte)
}

// formatSectionInfoIDA IDAé£æ ¼çš„æ®µä¿¡æ¯æ ¼å¼åŒ–ï¼ˆ15åˆ—ï¼‰
func (at *AnalysisTab) formatSectionInfoIDA(section *core.SectionInfo, col int) string {
	switch col {
	case 0: // Name
		if section.Name != "" {
			return section.Name
		}
		return "<unnamed>"
	case 1: // Start
		return fmt.Sprintf("%016X", section.Offset)
	case 2: // End
		return fmt.Sprintf("%016X", section.EndOffset)
	case 3: // R (Readable)
		if section.Readable {
			return "R"
		}
		return "."
	case 4: // W (Writable)
		if section.Writable {
			return "W"
		}
		return "."
	case 5: // X (Executable)
		if section.Executable {
			return "X"
		}
		return "."
	case 6: // D (Data)
		if section.Data {
			return "D"
		}
		return "."
	case 7: // L (Loaded)
		if section.Loaded {
			return "L"
		}
		return "."
	case 8: // Align
		if section.Align != "" {
			return section.Align
		}
		return "byte"
	case 9: // Base
		if section.Base != "" {
			return section.Base
		}
		return "01"
	case 10: // Type
		return "public"
	case 11: // Class
		if section.Class != "" {
			return section.Class
		}
		return "DATA"
	case 12: // AD (Address Dependent) - åº”è¯¥æ˜¾ç¤ºä½æ•°
		if section.Bitness != "" {
			return section.Bitness
		}
		return "64"
	case 13: // T (Type) - åº”è¯¥æ˜¾ç¤º"00"
		return "00"
	case 14: // DS (Data Size) - æ˜¾ç¤ºæ®µç±»å‹ç¼–å·
		if section.Base != "" {
			return section.Base
		}
		return "01"
	}
	return ""
}

// updateTableLayout æ›´æ–°è¡¨æ ¼å¸ƒå±€ï¼ˆæ›¿æ¢ä¸ºåŒè¡¨æ ¼åˆ‡æ¢æ¨¡å¼ï¼‰
func (at *AnalysisTab) updateTableLayout() {
	if at.selectedSection >= 0 {
		// åˆ‡æ¢åˆ°æ®µæ•°æ®æ¨¡å¼
		at.switchToSectionDataMode()
	} else {
		// åˆ‡æ¢åˆ°æ®µåˆ—è¡¨æ¨¡å¼
		at.switchToSectionListMode()
	}
}

// displaySectionData æ˜¾ç¤ºæ®µæ•°æ®ï¼ˆåŠ¨æ€é€‚é…æ¶æ„å’Œæ®µç±»å‹ï¼‰
func (at *AnalysisTab) displaySectionData(id widget.TableCellID, label *widget.Label) {
	// ä¸¥æ ¼çš„è¾¹ç•Œæ£€æŸ¥
	if at.fileInfo == nil ||
		at.selectedSection < 0 ||
		at.selectedSection >= len(at.fileInfo.Sections) ||
		id.Row < 0 ||
		id.Col < 0 ||
		id.Col >= 5 {
		label.SetText("")
		return
	}

	section := at.fileInfo.Sections[at.selectedSection]

	// æ‰€æœ‰æ®µéƒ½ä½¿ç”¨å­—ç¬¦ä¸²æœç´¢æ¨¡å¼æ˜¾ç¤ºï¼ˆç±»ä¼¼IDA stringsçª—å£ï¼‰
	// æœç´¢æ®µä¸­çš„å­—ç¬¦ä¸²å¹¶æ˜¾ç¤ºï¼šåœ°å€ã€é•¿åº¦ã€æ–‡æœ¬å†…å®¹
	at.displayStringsInSection(id, label, section)
}

// displaySectionDataWithRichText ä½¿ç”¨RichTextæ˜¾ç¤ºæ®µæ•°æ®ï¼ˆæ”¯æŒé«˜äº®ï¼‰
func (at *AnalysisTab) displaySectionDataWithRichText(id widget.TableCellID, cont *fyne.Container) {
	if at.fileInfo == nil || len(at.fileInfo.Sections) == 0 {
		return
	}

	section := at.fileInfo.Sections[at.selectedSection]

	// æ‰€æœ‰æ®µéƒ½ä½¿ç”¨å­—ç¬¦ä¸²æœç´¢æ¨¡å¼æ˜¾ç¤ºï¼ˆç±»ä¼¼IDA stringsçª—å£ï¼‰
	// æœç´¢æ®µä¸­çš„å­—ç¬¦ä¸²å¹¶æ˜¾ç¤ºï¼šåœ°å€ã€é•¿åº¦ã€æ–‡æœ¬å†…å®¹
	at.displayStringsInSectionWithRichText(id, cont, section)
}

// displayStringsInSectionWithRichText ä½¿ç”¨RichTextæ˜¾ç¤ºæ®µä¸­çš„å­—ç¬¦ä¸²ï¼ˆæ”¯æŒçœŸæ­£çš„é«˜äº®ï¼‰
func (at *AnalysisTab) displayStringsInSectionWithRichText(id widget.TableCellID, cont *fyne.Container, section core.SectionInfo) {
	// è·å–æ®µæ•°æ®
	data, err := at.getCachedSectionData(at.selectedSection)
	if err != nil {
		label := widget.NewLabel("Error")
		label.Truncation = fyne.TextTruncateEllipsis
		cont.Objects = []fyne.CanvasObject{label}
		return
	}

	if len(data) == 0 {
		label := widget.NewLabel("No Data")
		label.Truncation = fyne.TextTruncateEllipsis
		cont.Objects = []fyne.CanvasObject{label}
		return
	}

	// æ€§èƒ½ä¼˜åŒ–ï¼šé™åˆ¶è§£æçš„æ•°æ®é‡
	const maxStringParseSize = 512 * 1024 // 512KBé™åˆ¶
	parseData := data
	showWarning := false
	if len(data) > maxStringParseSize {
		parseData = data[:maxStringParseSize]
		showWarning = true
	}

	// å†³å®šä½¿ç”¨å“ªä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼šè¿‡æ»¤åçš„è¿˜æ˜¯å…¨éƒ¨çš„
	var displayStringList []StringData

	if at.currentSearchText != "" && at.filteredStrings != nil {
		// ä½¿ç”¨è¿‡æ»¤åçš„å­—ç¬¦ä¸²åˆ—è¡¨
		displayStringList = at.filteredStrings
	} else {
		// æ™ºèƒ½è§£æå­—ç¬¦ä¸²ï¼šæ ¹æ®æ®µç±»å‹é€‰æ‹©è§£ææ–¹æ³•
		if at.isCStringSection(section) {
			// æ˜ç¡®çš„å­—ç¬¦ä¸²æ®µï¼šæŒ‰\0åˆ†å‰²
			displayStringList = at.parseCStrings(parseData)
		} else {
			// å…¶ä»–æ®µï¼šä½¿ç”¨IDAé£æ ¼çš„å­—ç¬¦ä¸²æœç´¢ç®—æ³•
			displayStringList = at.parseStringsIDAStyle(parseData)
		}
	}

	// å¦‚æœæ²¡æœ‰æ‰¾åˆ°å­—ç¬¦ä¸²ï¼Œæ˜¾ç¤ºæç¤º
	if len(displayStringList) == 0 {
		if id.Row == 0 {
			text := ""
			switch id.Col {
			case 0:
				text = "0"
			case 1:
				text = fmt.Sprintf("%08X", section.Offset)
			case 2:
				text = "NO_STRINGS"
			case 3:
				text = "0"
			case 4:
				text = "æœªåœ¨æ­¤æ®µä¸­æ‰¾åˆ°å­—ç¬¦ä¸²"
			}
			label := widget.NewLabel(text)
			label.Truncation = fyne.TextTruncateEllipsis
			cont.Objects = []fyne.CanvasObject{label}
		}
		return
	}

	// å¤„ç†è­¦å‘Šè¡Œï¼ˆå¦‚æœæ®µå¤ªå¤§ï¼‰
	adjustedRow := id.Row
	if showWarning {
		if id.Row == 0 {
			text := ""
			switch id.Col {
			case 0:
				text = "âš ï¸"
			case 1:
				text = fmt.Sprintf("%08X", section.Offset)
			case 2:
				text = "LARGE_SECTION"
			case 3:
				text = fmt.Sprintf("%d", len(data))
			case 4:
				text = fmt.Sprintf("æ®µå¤ªå¤§ï¼Œä»…æœç´¢å‰%.1fKBçš„å­—ç¬¦ä¸²", float64(maxStringParseSize)/1024)
			}
			label := widget.NewLabel(text)
			label.Truncation = fyne.TextTruncateEllipsis
			cont.Objects = []fyne.CanvasObject{label}
			return
		}
		adjustedRow = id.Row - 1 // å‡å»è­¦å‘Šè¡Œ
	}

	// æ£€æŸ¥è¡Œç´¢å¼•æ˜¯å¦æœ‰æ•ˆ
	if adjustedRow < 0 || adjustedRow >= len(displayStringList) {
		return
	}

	str := displayStringList[adjustedRow]

	// æ ¹æ®åˆ—ç±»å‹åˆ›å»ºä¸åŒçš„ç»„ä»¶
	switch id.Col {
	case 0:
		// Index - å­—ç¬¦ä¸²ç´¢å¼•
		label := widget.NewLabel(fmt.Sprintf("%d", adjustedRow))
		label.Truncation = fyne.TextTruncateEllipsis
		cont.Objects = []fyne.CanvasObject{label}
	case 1:
		// Address - å­—ç¬¦ä¸²åœ¨æ–‡ä»¶ä¸­çš„åœ°å€
		address := section.Offset + str.Offset
		var text string
		if section.PointerSize == 4 {
			text = fmt.Sprintf("%08X", address)
		} else {
			text = fmt.Sprintf("%016X", address)
		}
		label := widget.NewLabel(text)
		label.Truncation = fyne.TextTruncateEllipsis
		cont.Objects = []fyne.CanvasObject{label}
	case 2:
		// Type - å­—ç¬¦ä¸²ç±»å‹æ ‡è¯†
		var text string
		if len(str.Data) > 30 {
			text = "LONG_STR"
		} else if at.isASCIIString(str.Data) {
			text = "ASCII"
		} else {
			text = "UTF8"
		}
		label := widget.NewLabel(text)
		label.Truncation = fyne.TextTruncateEllipsis
		cont.Objects = []fyne.CanvasObject{label}
	case 3:
		// Length - å­—ç¬¦ä¸²é•¿åº¦
		label := widget.NewLabel(fmt.Sprintf("%d", len(str.Data)))
		label.Truncation = fyne.TextTruncateEllipsis
		cont.Objects = []fyne.CanvasObject{label}
	case 4:
		// String - å­—ç¬¦ä¸²å†…å®¹ï¼ˆä½¿ç”¨RichTextæ”¯æŒé«˜äº®ï¼‰
		displayStr := str.Data
		// æ¸…ç†ä¸å¯æ˜¾ç¤ºå­—ç¬¦ï¼Œä¿æŒå®Œæ•´å†…å®¹
		displayStr = at.cleanStringForDisplay(displayStr)

		// å¦‚æœæœ‰æœç´¢æ–‡æœ¬ï¼Œä½¿ç”¨RichTexté«˜äº®æ˜¾ç¤º
		if at.currentSearchText != "" && at.highlightMatches != nil {
			if _, exists := at.highlightMatches[adjustedRow]; exists {
				richText := at.createHighlightedRichText(displayStr, at.currentSearchText)
				cont.Objects = []fyne.CanvasObject{richText}
			} else {
				label := widget.NewLabel(displayStr)
				cont.Objects = []fyne.CanvasObject{label}
			}
		} else {
			label := widget.NewLabel(displayStr)
			label.Truncation = fyne.TextTruncateEllipsis
			cont.Objects = []fyne.CanvasObject{label}
		}
	}
}

// displayStringsInSection æ˜¾ç¤ºæ®µä¸­çš„å­—ç¬¦ä¸²ï¼ˆIDA stringsçª—å£é£æ ¼ï¼‰
// æœç´¢æ®µä¸­çš„æ‰€æœ‰å­—ç¬¦ä¸²ï¼Œæ˜¾ç¤ºåœ°å€ã€é•¿åº¦ã€æ–‡æœ¬å†…å®¹
func (at *AnalysisTab) displayStringsInSection(id widget.TableCellID, label *widget.Label, section core.SectionInfo) {
	// è·å–æ®µæ•°æ®
	data, err := at.getCachedSectionData(at.selectedSection)
	if err != nil {
		label.SetText("Error")
		return
	}

	if len(data) == 0 {
		label.SetText("No Data")
		return
	}

	// æ€§èƒ½ä¼˜åŒ–ï¼šé™åˆ¶è§£æçš„æ•°æ®é‡
	const maxStringParseSize = 512 * 1024 // 512KBé™åˆ¶
	parseData := data
	showWarning := false
	if len(data) > maxStringParseSize {
		parseData = data[:maxStringParseSize]
		showWarning = true
	}

	// å†³å®šä½¿ç”¨å“ªä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼šè¿‡æ»¤åçš„è¿˜æ˜¯å…¨éƒ¨çš„
	var displayStringList []StringData

	if at.currentSearchText != "" && at.filteredStrings != nil {
		// ä½¿ç”¨è¿‡æ»¤åçš„å­—ç¬¦ä¸²åˆ—è¡¨
		displayStringList = at.filteredStrings
	} else {
		// æ™ºèƒ½è§£æå­—ç¬¦ä¸²ï¼šæ ¹æ®æ®µç±»å‹é€‰æ‹©è§£ææ–¹æ³•
		if at.isCStringSection(section) {
			// æ˜ç¡®çš„å­—ç¬¦ä¸²æ®µï¼šæŒ‰\0åˆ†å‰²
			displayStringList = at.parseCStrings(parseData)
		} else {
			// å…¶ä»–æ®µï¼šä½¿ç”¨IDAé£æ ¼çš„å­—ç¬¦ä¸²æœç´¢ç®—æ³•
			displayStringList = at.parseStringsIDAStyle(parseData)
		}
	}

	// å¦‚æœæ²¡æœ‰æ‰¾åˆ°å­—ç¬¦ä¸²ï¼Œæ˜¾ç¤ºæç¤º
	if len(displayStringList) == 0 {
		if id.Row == 0 {
			switch id.Col {
			case 0:
				label.SetText("0")
			case 1:
				label.SetText(fmt.Sprintf("%08X", section.Offset))
			case 2:
				label.SetText("NO_STRINGS")
			case 3:
				label.SetText("0")
			case 4:
				label.SetText("æœªåœ¨æ­¤æ®µä¸­æ‰¾åˆ°å­—ç¬¦ä¸²")
			}
		} else {
			label.SetText("")
		}
		return
	}

	// å¤„ç†è­¦å‘Šè¡Œï¼ˆå¦‚æœæ®µå¤ªå¤§ï¼‰
	adjustedRow := id.Row
	if showWarning {
		if id.Row == 0 {
			// æ˜¾ç¤ºè­¦å‘Šè¡Œ
			switch id.Col {
			case 0:
				label.SetText("âš ï¸")
			case 1:
				label.SetText(fmt.Sprintf("%08X", section.Offset))
			case 2:
				label.SetText("LARGE_SECTION")
			case 3:
				label.SetText(fmt.Sprintf("%d", len(data)))
			case 4:
				label.SetText(fmt.Sprintf("æ®µå¤ªå¤§ï¼Œä»…æœç´¢å‰%.1fKBçš„å­—ç¬¦ä¸²", float64(maxStringParseSize)/1024))
			}
			return
		}
		adjustedRow = id.Row - 1 // å‡å»è­¦å‘Šè¡Œ
	}

	// æ£€æŸ¥è¡Œç´¢å¼•æ˜¯å¦æœ‰æ•ˆ
	if adjustedRow < 0 || adjustedRow >= len(displayStringList) {
		label.SetText("")
		return
	}

	str := displayStringList[adjustedRow]

	switch id.Col {
	case 0:
		// Index - å­—ç¬¦ä¸²ç´¢å¼•
		label.SetText(fmt.Sprintf("%d", adjustedRow))
	case 1:
		// Address - å­—ç¬¦ä¸²åœ¨æ–‡ä»¶ä¸­çš„åœ°å€
		address := section.Offset + str.Offset
		if section.PointerSize == 4 {
			label.SetText(fmt.Sprintf("%08X", address))
		} else {
			label.SetText(fmt.Sprintf("%016X", address))
		}
	case 2:
		// Type - å­—ç¬¦ä¸²ç±»å‹æ ‡è¯†
		if len(str.Data) > 30 {
			label.SetText("LONG_STR")
		} else if at.isASCIIString(str.Data) {
			label.SetText("ASCII")
		} else {
			label.SetText("UTF8")
		}
	case 3:
		// Length - å­—ç¬¦ä¸²é•¿åº¦
		label.SetText(fmt.Sprintf("%d", len(str.Data)))
	case 4:
		// String - å­—ç¬¦ä¸²å†…å®¹ï¼ˆæ”¯æŒæœç´¢é«˜äº®ï¼‰
		displayStr := str.Data
		// æ¸…ç†ä¸å¯æ˜¾ç¤ºå­—ç¬¦ï¼Œä¿æŒå®Œæ•´å†…å®¹
		displayStr = at.cleanStringForDisplay(displayStr)

		// å¦‚æœæœ‰æœç´¢æ–‡æœ¬ä¸”å­˜åœ¨é«˜äº®åŒ¹é…ï¼Œæ·»åŠ é«˜äº®æ ‡è®°
		if at.currentSearchText != "" && at.highlightMatches != nil {
			if matches, exists := at.highlightMatches[adjustedRow]; exists && len(matches) > 0 {
				// ä½¿ç”¨æ›´ä¼˜é›…çš„é«˜äº®æ–¹å¼
				displayStr = at.addHighlightMarkers(displayStr, at.currentSearchText)
			}
		}

		label.SetText(displayStr)
	}
}

// StringData å­—ç¬¦ä¸²æ•°æ®ç»“æ„
type StringData struct {
	Index  int
	Offset uint64
	Data   string
}

// isASCIIString åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦ä¸ºçº¯ASCII
func (at *AnalysisTab) isASCIIString(s string) bool {
	for _, b := range []byte(s) {
		if b > 127 {
			return false
		}
	}
	return true
}

// cleanStringForDisplay æ¸…ç†å­—ç¬¦ä¸²ä»¥ä¾¿æ˜¾ç¤º
func (at *AnalysisTab) cleanStringForDisplay(s string) string {
	var result strings.Builder
	result.Grow(len(s))

	for _, r := range s {
		if r >= 32 && r <= 126 {
			// ASCIIå¯æ‰“å°å­—ç¬¦
			result.WriteRune(r)
		} else if r > 127 {
			// UTF-8å­—ç¬¦ï¼Œä¿ç•™
			result.WriteRune(r)
		} else {
			// æ§åˆ¶å­—ç¬¦ï¼Œæ›¿æ¢ä¸ºç‚¹
			result.WriteByte('.')
		}
	}

	return result.String()
}

// filterSectionData è¿‡æ»¤æ®µæ•°æ®ï¼ˆæœç´¢å­—ç¬¦ä¸²ï¼‰
func (at *AnalysisTab) filterSectionData(searchText string) {
	// å¦‚æœå½“å‰æ²¡æœ‰é€‰ä¸­æ®µï¼Œä¸æ‰§è¡Œè¿‡æ»¤
	if at.selectedSection < 0 || at.fileInfo == nil || at.currentTable != at.sectionDataTable {
		return
	}

	// æ¸…ç†å¹¶ä¿å­˜æœç´¢æ–‡æœ¬
	at.currentSearchText = strings.TrimSpace(searchText)

	// å¦‚æœæœç´¢æ–‡æœ¬ä¸ºç©ºï¼Œæ¸…é™¤è¿‡æ»¤æ˜¾ç¤ºæ‰€æœ‰æ•°æ®
	if at.currentSearchText == "" {
		at.filteredStrings = nil
		at.highlightMatches = nil
		at.currentTable.Refresh()
		section := at.fileInfo.Sections[at.selectedSection]
		at.updateStatus(fmt.Sprintf("æ˜¾ç¤ºæ®µ %s çš„æ‰€æœ‰å­—ç¬¦ä¸²", section.Name))
		return
	}

	// è·å–å½“å‰æ®µçš„æ‰€æœ‰å­—ç¬¦ä¸²
	section := at.fileInfo.Sections[at.selectedSection]
	data, err := at.getCachedSectionData(at.selectedSection)
	if err != nil || len(data) == 0 {
		at.updateStatus("æ— æ³•è·å–æ®µæ•°æ®")
		return
	}

	// æ€§èƒ½ä¼˜åŒ–ï¼šé™åˆ¶è§£æçš„æ•°æ®é‡
	const maxStringParseSize = 512 * 1024
	parseData := data
	if len(data) > maxStringParseSize {
		parseData = data[:maxStringParseSize]
	}

	// æ™ºèƒ½è§£æå­—ç¬¦ä¸²
	var allStrings []StringData
	if at.isCStringSection(section) {
		allStrings = at.parseCStrings(parseData)
	} else {
		allStrings = at.parseStringsIDAStyle(parseData)
	}

	// æ‰§è¡Œæ¨¡ç³ŠåŒ¹é…æœç´¢
	at.filteredStrings = nil
	at.highlightMatches = make(map[int][]int)

	searchLower := strings.ToLower(at.currentSearchText)
	matchCount := 0

	for _, str := range allStrings {
		strLower := strings.ToLower(str.Data)

		// æ£€æŸ¥æ˜¯å¦åŒ…å«æœç´¢æ–‡æœ¬
		if strings.Contains(strLower, searchLower) {
			// æ‰¾åˆ°åŒ¹é…çš„å­—ç¬¦ä¸²ï¼Œæ·»åŠ åˆ°è¿‡æ»¤ç»“æœ
			filteredIndex := len(at.filteredStrings)
			at.filteredStrings = append(at.filteredStrings, StringData{
				Index:  filteredIndex,
				Offset: str.Offset,
				Data:   str.Data,
			})

			// è®¡ç®—é«˜äº®ä½ç½®
			matches := at.findAllMatches(strLower, searchLower)
			if len(matches) > 0 {
				at.highlightMatches[filteredIndex] = matches
			}

			matchCount++
		}
	}

	// åˆ·æ–°è¡¨æ ¼æ˜¾ç¤ºè¿‡æ»¤ç»“æœ
	at.currentTable.Refresh()
	at.currentTable.ScrollToTop()

	// æ›´æ–°çŠ¶æ€ä¿¡æ¯
	if matchCount > 0 {
		at.updateStatus(fmt.Sprintf("åœ¨æ®µ %s ä¸­æ‰¾åˆ° %d ä¸ªåŒ¹é… \"%s\" çš„å­—ç¬¦ä¸²",
			section.Name, matchCount, at.currentSearchText))
	} else {
		at.updateStatus(fmt.Sprintf("åœ¨æ®µ %s ä¸­æœªæ‰¾åˆ°åŒ¹é… \"%s\" çš„å­—ç¬¦ä¸²",
			section.Name, at.currentSearchText))
	}
}

// isCStringSection åˆ¤æ–­æ˜¯å¦ä¸ºæ˜ç¡®çš„Cå­—ç¬¦ä¸²æ®µ
func (at *AnalysisTab) isCStringSection(section core.SectionInfo) bool {
	// æ˜ç¡®çš„Cå­—ç¬¦ä¸²æ®µåç§°
	cstringSegments := []string{
		"__cstring",  // Mach-O Cå­—ç¬¦ä¸²æ®µ
		"__cfstring", // Core Foundationå­—ç¬¦ä¸²
		"__string",   // é€šç”¨å­—ç¬¦ä¸²æ®µ
		".rodata",    // ELFåªè¯»æ•°æ®æ®µï¼ˆé€šå¸¸åŒ…å«å­—ç¬¦ä¸²å¸¸é‡ï¼‰
		".rdata",     // PEåªè¯»æ•°æ®æ®µ
	}

	sectionName := strings.ToLower(section.Name)
	for _, cstringName := range cstringSegments {
		if strings.Contains(sectionName, cstringName) {
			return true
		}
	}

	return false
}

// parseCStrings è§£æCå­—ç¬¦ä¸²ï¼ˆæŒ‰\0åˆ†å‰²ï¼‰
func (at *AnalysisTab) parseCStrings(data []byte) []StringData {
	var stringList []StringData
	var start int

	for i, b := range data {
		if b == 0 {
			// æ‰¾åˆ°\0åˆ†éš”ç¬¦
			if i > start {
				str := string(data[start:i])
				// åªä¿ç•™æœ‰æ„ä¹‰çš„å­—ç¬¦ä¸²ï¼ˆé•¿åº¦>=2ï¼‰
				if len(str) >= 2 && at.containsPrintableChars(str) {
					stringList = append(stringList, StringData{
						Index:  len(stringList),
						Offset: uint64(start),
						Data:   str,
					})
				}
			}
			start = i + 1
		}
	}

	// å¤„ç†æœ€åä¸€ä¸ªå­—ç¬¦ä¸²ï¼ˆå¦‚æœæ²¡æœ‰ä»¥\0ç»“å°¾ï¼‰
	if start < len(data) {
		str := string(data[start:])
		if len(str) >= 2 && at.containsPrintableChars(str) {
			stringList = append(stringList, StringData{
				Index:  len(stringList),
				Offset: uint64(start),
				Data:   str,
			})
		}
	}

	return stringList
}

// parseStringsIDAStyle ä½¿ç”¨IDAé£æ ¼çš„å­—ç¬¦ä¸²æœç´¢ç®—æ³•
func (at *AnalysisTab) parseStringsIDAStyle(data []byte) []StringData {
	var stringList []StringData
	var currentString []byte
	var currentOffset uint64

	const minStringLength = 4 // IDAé»˜è®¤æœ€å°å­—ç¬¦ä¸²é•¿åº¦

	for i, b := range data {
		if at.isPrintableChar(b) {
			// å¯æ‰“å°å­—ç¬¦ï¼Œæ·»åŠ åˆ°å½“å‰å­—ç¬¦ä¸²
			if currentString == nil {
				currentOffset = uint64(i)
			}
			currentString = append(currentString, b)
		} else if b >= 128 {
			// å¯èƒ½çš„UTF-8å­—ç¬¦ï¼Œå°è¯•è§£æ
			if at.isValidUTF8Start(data, i) {
				if currentString == nil {
					currentOffset = uint64(i)
				}
				// æ·»åŠ UTF-8å­—èŠ‚åºåˆ—
				utfLen := at.getUTF8Length(b)
				for j := 0; j < utfLen && i+j < len(data); j++ {
					currentString = append(currentString, data[i+j])
				}
				// è·³è¿‡UTF-8çš„å‰©ä½™å­—èŠ‚
				for j := 1; j < utfLen && i+j < len(data); j++ {
					i++
				}
			} else {
				// éæ–‡æœ¬å­—ç¬¦ï¼Œç»“æŸå½“å‰å­—ç¬¦ä¸²
				if len(currentString) >= minStringLength {
					stringList = append(stringList, StringData{
						Index:  len(stringList),
						Offset: currentOffset,
						Data:   string(currentString),
					})
				}
				currentString = nil
			}
		} else {
			// éå¯æ‰“å°å­—ç¬¦ï¼Œç»“æŸå½“å‰å­—ç¬¦ä¸²
			if len(currentString) >= minStringLength {
				stringList = append(stringList, StringData{
					Index:  len(stringList),
					Offset: currentOffset,
					Data:   string(currentString),
				})
			}
			currentString = nil
		}
	}

	// å¤„ç†æœ€åä¸€ä¸ªå­—ç¬¦ä¸²
	if len(currentString) >= minStringLength {
		stringList = append(stringList, StringData{
			Index:  len(stringList),
			Offset: currentOffset,
			Data:   string(currentString),
		})
	}

	return stringList
}

// containsPrintableChars æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦åŒ…å«è¶³å¤Ÿçš„å¯æ‰“å°å­—ç¬¦
func (at *AnalysisTab) containsPrintableChars(s string) bool {
	printableCount := 0
	for _, r := range s {
		if r >= 32 && r <= 126 {
			printableCount++
		}
	}
	// è‡³å°‘80%çš„å­—ç¬¦æ˜¯å¯æ‰“å°çš„
	return float64(printableCount)/float64(len(s)) >= 0.8
}

// findAllMatches æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰åŒ¹é…ä½ç½®
func (at *AnalysisTab) findAllMatches(text, pattern string) []int {
	var matches []int

	if len(pattern) == 0 {
		return matches
	}

	start := 0
	for {
		index := strings.Index(text[start:], pattern)
		if index == -1 {
			break
		}

		actualIndex := start + index
		matches = append(matches, actualIndex)
		start = actualIndex + 1 // å…è®¸é‡å åŒ¹é…
	}

	return matches
}

// addHighlightMarkers ä¸ºå­—ç¬¦ä¸²æ·»åŠ é«˜äº®æ ‡è®°ï¼ˆä½¿ç”¨ä¸“ä¸šçš„è§†è§‰æ ‡è®°ï¼‰
func (at *AnalysisTab) addHighlightMarkers(text, searchPattern string) string {
	if searchPattern == "" {
		return text
	}

	searchLower := strings.ToLower(searchPattern)
	textLower := strings.ToLower(text)

	var result strings.Builder
	lastIndex := 0

	for {
		index := strings.Index(textLower[lastIndex:], searchLower)
		if index == -1 {
			// æ·»åŠ å‰©ä½™æ–‡æœ¬
			result.WriteString(text[lastIndex:])
			break
		}

		actualIndex := lastIndex + index

		// æ·»åŠ åŒ¹é…å‰çš„æ–‡æœ¬
		result.WriteString(text[lastIndex:actualIndex])

		// æ·»åŠ é«˜äº®æ ‡è®°çš„åŒ¹é…æ–‡æœ¬ï¼ˆä½¿ç”¨ä¸“ä¸šçš„æ ‡è®°æ–¹å¼ï¼‰
		matchedText := text[actualIndex : actualIndex+len(searchPattern)]

		// æ–¹æ¡ˆ1: ä½¿ç”¨ä¸‹åˆ’çº¿å’Œç²—ä½“æ•ˆæœï¼ˆå¦‚æœæ”¯æŒï¼‰
		result.WriteString("â•£") // ä½¿ç”¨ç›’ç»˜å­—ç¬¦ä½œä¸ºå¼€å§‹æ ‡è®°
		result.WriteString(matchedText)
		result.WriteString("â• ") // ä½¿ç”¨ç›’ç»˜å­—ç¬¦ä½œä¸ºç»“æŸæ ‡è®°

		lastIndex = actualIndex + len(searchPattern)
	}

	return result.String()
}

// createHighlightedRichText åˆ›å»ºå¸¦é«˜äº®çš„RichTextç»„ä»¶
func (at *AnalysisTab) createHighlightedRichText(text, searchPattern string) *widget.RichText {
	richText := widget.NewRichText()
	richText.Truncation = fyne.TextTruncateEllipsis
	if searchPattern == "" {
		// æ²¡æœ‰æœç´¢æ¨¡å¼ï¼Œæ˜¾ç¤ºæ™®é€šæ–‡æœ¬
		richText.ParseMarkdown(text)
		return richText
	}

	searchLower := strings.ToLower(searchPattern)
	textLower := strings.ToLower(text)

	// æ„å»ºå¯Œæ–‡æœ¬å†…å®¹
	var content strings.Builder
	lastIndex := 0

	for {
		index := strings.Index(textLower[lastIndex:], searchLower)
		if index == -1 {
			// æ·»åŠ å‰©ä½™çš„æ™®é€šæ–‡æœ¬
			if lastIndex < len(text) {
				content.WriteString(text[lastIndex:])
			}
			break
		}

		actualIndex := lastIndex + index

		// æ·»åŠ åŒ¹é…å‰çš„æ™®é€šæ–‡æœ¬
		if actualIndex > lastIndex {
			content.WriteString(text[lastIndex:actualIndex])
		}

		// æ·»åŠ é«˜äº®çš„åŒ¹é…æ–‡æœ¬ï¼ˆä½¿ç”¨Markdownè¯­æ³• - ç²—ä½“+æ–œä½“ï¼‰
		matchedText := text[actualIndex : actualIndex+len(searchPattern)]
		content.WriteString("**") // ç²—ä½“+æ–œä½“
		content.WriteString(matchedText)
		content.WriteString("**")

		lastIndex = actualIndex + len(searchPattern)
	}

	// è§£æMarkdownå†…å®¹
	richText.ParseMarkdown(content.String())

	// è®¾ç½®ä¸€äº›æ ·å¼å±æ€§
	richText.Wrapping = fyne.TextWrapOff // ä¸æ¢è¡Œï¼Œä¿æŒè¡¨æ ¼æ•´æ´

	return richText
}

// addColorHighlight æ·»åŠ é¢œè‰²é«˜äº®æ•ˆæœï¼ˆå¤‡é€‰æ–¹æ¡ˆï¼‰
func (at *AnalysisTab) addColorHighlight(text, searchPattern string) string {
	if searchPattern == "" {
		return text
	}

	// ä½¿ç”¨Unicodeå—å­—ç¬¦åˆ›å»ºèƒŒæ™¯é«˜äº®æ•ˆæœ
	searchLower := strings.ToLower(searchPattern)
	textLower := strings.ToLower(text)

	// åˆ›å»ºé«˜äº®å­—ç¬¦æ˜ å°„
	highlightMap := map[rune]rune{
		'a': 'ğŸ…°', 'b': 'ğŸ…±', 'c': 'ğŸ…²', 'd': 'ğŸ…³', 'e': 'ğŸ…´',
		'f': 'ğŸ…µ', 'g': 'ğŸ…¶', 'h': 'ğŸ…·', 'i': 'ğŸ…¸', 'j': 'ğŸ…¹',
		'k': 'ğŸ…º', 'l': 'ğŸ…»', 'm': 'ğŸ…¼', 'n': 'ğŸ…½', 'o': 'ğŸ…¾',
		'p': 'ğŸ…¿', 'q': 'ğŸ†€', 'r': 'ğŸ†', 's': 'ğŸ†‚', 't': 'ğŸ†ƒ',
		'u': 'ğŸ†„', 'v': 'ğŸ†…', 'w': 'ğŸ††', 'x': 'ğŸ†‡', 'y': 'ğŸ†ˆ', 'z': 'ğŸ†‰',
	}

	var result strings.Builder
	lastIndex := 0

	for {
		index := strings.Index(textLower[lastIndex:], searchLower)
		if index == -1 {
			result.WriteString(text[lastIndex:])
			break
		}

		actualIndex := lastIndex + index
		result.WriteString(text[lastIndex:actualIndex])

		// è½¬æ¢åŒ¹é…çš„æ–‡æœ¬ä¸ºé«˜äº®ç‰ˆæœ¬
		matchedText := text[actualIndex : actualIndex+len(searchPattern)]
		for _, r := range matchedText {
			if highlighted, exists := highlightMap[unicode.ToLower(r)]; exists {
				result.WriteRune(highlighted)
			} else {
				result.WriteRune(r)
			}
		}

		lastIndex = actualIndex + len(searchPattern)
	}

	return result.String()
}

// isPrintableChar åˆ¤æ–­å­—ç¬¦æ˜¯å¦å¯æ‰“å°
func (at *AnalysisTab) isPrintableChar(b byte) bool {
	// ASCIIå¯æ‰“å°å­—ç¬¦èŒƒå›´ï¼š32-126
	return b >= 32 && b <= 126
}

// isValidUTF8Start æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆçš„UTF-8èµ·å§‹å­—èŠ‚
func (at *AnalysisTab) isValidUTF8Start(data []byte, pos int) bool {
	if pos >= len(data) {
		return false
	}

	b := data[pos]

	// UTF-8ç¼–ç è§„åˆ™æ£€æŸ¥
	if b&0x80 == 0 {
		return true // ASCII
	} else if b&0xE0 == 0xC0 {
		// 2å­—èŠ‚UTF-8
		return pos+1 < len(data) && (data[pos+1]&0xC0) == 0x80
	} else if b&0xF0 == 0xE0 {
		// 3å­—èŠ‚UTF-8
		return pos+2 < len(data) &&
			(data[pos+1]&0xC0) == 0x80 &&
			(data[pos+2]&0xC0) == 0x80
	} else if b&0xF8 == 0xF0 {
		// 4å­—èŠ‚UTF-8
		return pos+3 < len(data) &&
			(data[pos+1]&0xC0) == 0x80 &&
			(data[pos+2]&0xC0) == 0x80 &&
			(data[pos+3]&0xC0) == 0x80
	}

	return false
}

// getUTF8Length è·å–UTF-8å­—ç¬¦çš„å­—èŠ‚é•¿åº¦
func (at *AnalysisTab) getUTF8Length(b byte) int {
	if b&0x80 == 0 {
		return 1 // ASCII
	} else if b&0xE0 == 0xC0 {
		return 2 // 2å­—èŠ‚UTF-8
	} else if b&0xF0 == 0xE0 {
		return 3 // 3å­—èŠ‚UTF-8
	} else if b&0xF8 == 0xF0 {
		return 4 // 4å­—èŠ‚UTF-8
	}
	return 1 // é”™è¯¯æƒ…å†µï¼Œè¿”å›1
}

// PointerData æŒ‡é’ˆæ•°æ®ç»“æ„
type PointerData struct {
	Index   int
	Offset  uint64
	Address uint64
	IsValid bool
}

// onTreeNodeSelected å¤„ç†æ ‘èŠ‚ç‚¹é€‰æ‹©äº‹ä»¶
func (at *AnalysisTab) onTreeNodeSelected(uid widget.TreeNodeID) {
	switch uid {
	case "file_info":
		// æ–‡ä»¶ä¿¡æ¯èŠ‚ç‚¹ï¼šåˆ‡æ¢åˆ°æ®µåˆ—è¡¨æ¨¡å¼
		at.selectedSection = -1
		at.switchToSectionListMode()
		at.currentTable.Refresh()
		at.currentTable.ScrollToTop()
		at.updateStatus("æ˜¾ç¤ºæ®µåˆ—è¡¨ä¿¡æ¯ï¼ˆIDAé£æ ¼ï¼‰")

	case "sections":
		// æ˜¾ç¤ºæ‰€æœ‰æ®µä¿¡æ¯
		at.selectedSection = -1
		at.switchToSectionListMode()
		at.currentTable.Refresh()
		at.currentTable.ScrollToTop()
		if at.fileInfo != nil {
			at.updateStatus(fmt.Sprintf("æ˜¾ç¤ºæ‰€æœ‰æ®µä¿¡æ¯ (%dä¸ª)", len(at.fileInfo.Sections)))
		}

	default:
		// æ–‡ä»¶ä¿¡æ¯å¤šè¡ŒèŠ‚ç‚¹
		if strings.HasPrefix(string(uid), "info_type_") ||
			strings.HasPrefix(string(uid), "info_size_") ||
			strings.HasPrefix(string(uid), "info_arch_") ||
			strings.HasPrefix(string(uid), "info_detailed_") {
			// æ–‡ä»¶ä¿¡æ¯å­èŠ‚ç‚¹ï¼šä¸éœ€è¦ç‰¹æ®Šå¤„ç†ï¼Œåªæ˜¾ç¤ºåŸºæœ¬ä¿¡æ¯
			at.selectedSection = -1
			at.switchToSectionListMode()
			at.currentTable.Refresh()
			at.currentTable.ScrollToTop()
			at.updateStatus("æ˜¾ç¤ºæ–‡ä»¶è¯¦ç»†ä¿¡æ¯")
			// æ¶æ„èŠ‚ç‚¹
		} else if strings.HasPrefix(string(uid), "arch_") {
			archIndexStr := strings.TrimPrefix(string(uid), "arch_")
			if archIndex, err := strconv.Atoi(archIndexStr); err == nil && at.fileInfo != nil {
				// æ˜¾ç¤ºè¯¥æ¶æ„çš„ä¿¡æ¯
				at.selectedSection = -1
				for _, section := range at.fileInfo.Sections {
					if section.ArchIndex == archIndex && section.Type == "Architecture" {
						at.updateStatus(fmt.Sprintf("æ¶æ„ä¿¡æ¯: %s", section.Name))
						break
					}
				}
				at.currentTable.Refresh()
				at.currentTable.ScrollToTop()
			}
		} else if strings.HasPrefix(string(uid), "section_") {
			// æ®µèŠ‚ç‚¹
			index := strings.TrimPrefix(string(uid), "section_")
			if i, err := strconv.Atoi(index); err == nil && at.fileInfo != nil && i < len(at.fileInfo.Sections) {
				// æ£€æŸ¥æ˜¯å¦åˆ‡æ¢åˆ°ä¸åŒçš„æ®µï¼Œå¦‚æœæ˜¯åˆ™æ¸…ç†ä¸å¿…è¦çš„ç¼“å­˜
				if at.selectedSection != i {
					// ä¿ç•™å½“å‰æ®µå’Œæ–°æ®µçš„ç¼“å­˜ï¼Œæ¸…ç†å…¶ä»–
					newCache := make(map[int][]byte)
					if data, exists := at.sectionDataCache[at.selectedSection]; exists {
						newCache[at.selectedSection] = data
					}
					if data, exists := at.sectionDataCache[i]; exists {
						newCache[i] = data
					}
					at.sectionDataCache = newCache
				}

				at.lastSelectedSection = at.selectedSection
				at.selectedSection = i
				section := at.fileInfo.Sections[i]
				at.updateTableLayout() // æ›´æ–°è¡¨æ ¼å¸ƒå±€ä¸ºæ®µæ•°æ®æ¨¡å¼
				at.updateStatus(fmt.Sprintf("é€‰æ‹©æ®µ: %s (å¤§å°: %d bytes)", section.Name, section.Size))
				at.currentTable.Refresh()
				at.currentTable.ScrollToTop()
			}
		}
	}
}

// Content è¿”å›æ ‡ç­¾é¡µå†…å®¹
func (at *AnalysisTab) Content() *fyne.Container {
	return at.content
}

// Refresh åˆ·æ–°æ ‡ç­¾é¡µ
func (at *AnalysisTab) Refresh() {
	if at.tree != nil {
		at.tree.Refresh()
	}
	if at.currentTable != nil {
		at.currentTable.Refresh()
		at.currentTable.ScrollToTop()
	}
}

// createTables åˆ›å»ºä¸¤ä¸ªç‹¬ç«‹çš„è¡¨æ ¼å®ä¾‹
func (at *AnalysisTab) createTables() {
	// åˆ›å»ºæ®µåˆ—è¡¨è¡¨æ ¼ï¼ˆIDAé£æ ¼ï¼‰
	at.sectionListTable = widget.NewTableWithHeaders(
		func() (int, int) {
			if at.fileInfo == nil || len(at.fileInfo.Sections) == 0 {
				return 0, 15
			}
			return len(at.fileInfo.Sections), 15
		},
		func() fyne.CanvasObject {
			return widget.NewLabel("Cell Data")
		},
		func(id widget.TableCellID, object fyne.CanvasObject) {
			label := object.(*widget.Label)
			label.SetText("")
			label.Truncation = fyne.TextTruncateEllipsis

			if at.fileInfo == nil || len(at.fileInfo.Sections) == 0 {
				return
			}

			if id.Row >= 0 && id.Row < len(at.fileInfo.Sections) && id.Col >= 0 && id.Col < 15 {
				section := &at.fileInfo.Sections[id.Row]
				text := at.formatSectionInfoIDA(section, id.Col)
				label.SetText(text)
			}
		},
	)

	// è®¾ç½®æ®µåˆ—è¡¨è¡¨æ ¼è¡¨å¤´
	at.sectionListTable.CreateHeader = func() fyne.CanvasObject {
		return widget.NewLabel("Header")
	}
	at.sectionListTable.UpdateHeader = func(id widget.TableCellID, object fyne.CanvasObject) {
		label := object.(*widget.Label)
		label.TextStyle = fyne.TextStyle{Bold: true}

		headers := []string{"Name", "Start", "End", "R", "W", "X", "D", "L", "Align", "Base", "Type", "Class", "AD", "T", "DS"}
		if id.Col >= 0 && id.Col < len(headers) {
			label.SetText(headers[id.Col])
		}
	}

	// è®¾ç½®æ®µåˆ—è¡¨è¡¨æ ¼åˆ—å®½
	at.sectionListTable.SetColumnWidth(0, 140) // Name
	at.sectionListTable.SetColumnWidth(1, 140) // Start
	at.sectionListTable.SetColumnWidth(2, 140) // End
	at.sectionListTable.SetColumnWidth(3, 25)  // R
	at.sectionListTable.SetColumnWidth(4, 25)  // W
	at.sectionListTable.SetColumnWidth(5, 25)  // X
	at.sectionListTable.SetColumnWidth(6, 25)  // D
	at.sectionListTable.SetColumnWidth(7, 25)  // L
	at.sectionListTable.SetColumnWidth(8, 70)  // Align
	at.sectionListTable.SetColumnWidth(9, 40)  // Base
	at.sectionListTable.SetColumnWidth(10, 50) // Type
	at.sectionListTable.SetColumnWidth(11, 50) // Class
	at.sectionListTable.SetColumnWidth(12, 30) // AD
	at.sectionListTable.SetColumnWidth(13, 25) // T
	at.sectionListTable.SetColumnWidth(14, 30) // DS
	at.sectionListTable.SetRowHeight(0, 30)

	// åˆ›å»ºæ®µæ•°æ®è¡¨æ ¼ï¼ˆåå…­è¿›åˆ¶/å­—ç¬¦ä¸²ï¼‰
	at.sectionDataTable = widget.NewTableWithHeaders(
		func() (int, int) {
			if at.fileInfo == nil || len(at.fileInfo.Sections) == 0 || at.selectedSection < 0 {
				return 0, 5
			}

			if at.selectedSection < len(at.fileInfo.Sections) {
				// æ‰€æœ‰æ®µéƒ½ä½¿ç”¨å­—ç¬¦ä¸²æœç´¢æ¨¡å¼
				data, err := at.getCachedSectionData(at.selectedSection)
				if err != nil || len(data) == 0 {
					return 1, 5 // è‡³å°‘æ˜¾ç¤ºä¸€è¡Œï¼ˆé”™è¯¯æˆ–æ— æ•°æ®æç¤ºï¼‰
				}

				// æ€§èƒ½ä¼˜åŒ–ï¼šé™åˆ¶è§£æçš„æ•°æ®é‡
				const maxStringParseSize = 512 * 1024
				parseData := data
				if len(data) > maxStringParseSize {
					parseData = data[:maxStringParseSize]
				}

				// å†³å®šä½¿ç”¨å“ªä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼šè¿‡æ»¤åçš„è¿˜æ˜¯å…¨éƒ¨çš„
				section := at.fileInfo.Sections[at.selectedSection]
				var stringList []StringData

				if at.currentSearchText != "" && at.filteredStrings != nil {
					// ä½¿ç”¨è¿‡æ»¤åçš„å­—ç¬¦ä¸²åˆ—è¡¨
					stringList = at.filteredStrings
				} else {
					// æ™ºèƒ½è§£æå­—ç¬¦ä¸²ï¼šæ ¹æ®æ®µç±»å‹é€‰æ‹©è§£ææ–¹æ³•
					if at.isCStringSection(section) {
						// æ˜ç¡®çš„å­—ç¬¦ä¸²æ®µï¼šæŒ‰\0åˆ†å‰²
						stringList = at.parseCStrings(parseData)
					} else {
						// å…¶ä»–æ®µï¼šä½¿ç”¨IDAé£æ ¼çš„å­—ç¬¦ä¸²æœç´¢ç®—æ³•
						stringList = at.parseStringsIDAStyle(parseData)
					}
				}
				rowCount := len(stringList)

				// å¦‚æœæ®µå¤ªå¤§ï¼Œå¢åŠ ä¸€è¡Œè­¦å‘Š
				if len(data) > maxStringParseSize {
					rowCount++
				}

				// å¦‚æœæ²¡æœ‰æ‰¾åˆ°å­—ç¬¦ä¸²ï¼Œè‡³å°‘æ˜¾ç¤ºä¸€è¡Œæç¤º
				if rowCount == 0 {
					rowCount = 1
				}

				return rowCount, 5
			}
			return 0, 5
		},
		func() fyne.CanvasObject {
			// ä¸ºå­—ç¬¦ä¸²åˆ—åˆ›å»ºRichTextï¼Œå…¶ä»–åˆ—ä½¿ç”¨Label
			return container.NewWithoutLayout() // ä½¿ç”¨å®¹å™¨æ¥æ”¯æŒåŠ¨æ€ç»„ä»¶
		},
		func(id widget.TableCellID, object fyne.CanvasObject) {
			cont := object.(*fyne.Container)
			cont.Objects = nil // æ¸…ç©ºå®¹å™¨

			if at.fileInfo == nil || len(at.fileInfo.Sections) == 0 {
				return
			}

			if at.selectedSection >= 0 && at.selectedSection < len(at.fileInfo.Sections) {
				at.displaySectionDataWithRichText(id, cont)
			}
		},
	)

	// è®¾ç½®æ®µæ•°æ®è¡¨æ ¼è¡¨å¤´
	at.sectionDataTable.CreateHeader = func() fyne.CanvasObject {
		return widget.NewLabel("Header")
	}
	at.sectionDataTable.UpdateHeader = func(id widget.TableCellID, object fyne.CanvasObject) {
		label := object.(*widget.Label)
		label.TextStyle = fyne.TextStyle{Bold: true}

		headers := []string{"Index", "Address", "Type", "Length", "String"}
		if id.Col >= 0 && id.Col < len(headers) {
			label.SetText(headers[id.Col])
		}
	}

	// è®¾ç½®æ®µæ•°æ®è¡¨æ ¼åˆ—å®½
	at.sectionDataTable.SetColumnWidth(0, 60)  // Index
	at.sectionDataTable.SetColumnWidth(1, 120) // Address (æ‰©å¤§ä»¥é€‚åº”16ä½åœ°å€)
	at.sectionDataTable.SetColumnWidth(2, 80)  // Type (å­—ç¬¦ä¸²ç±»å‹)
	at.sectionDataTable.SetColumnWidth(3, 80)  // Length
	at.sectionDataTable.SetColumnWidth(4, 400) // String (æ‰©å¤§ä»¥æ˜¾ç¤ºæ›´å¤šå†…å®¹)
	at.sectionDataTable.SetRowHeight(0, 30)
}

// switchToSectionListMode åˆ‡æ¢åˆ°æ®µåˆ—è¡¨æ¨¡å¼ï¼ˆIDAé£æ ¼ï¼‰
func (at *AnalysisTab) switchToSectionListMode() {
	if at.sectionListTable == nil || at.sectionDataTable == nil {
		return
	}

	at.currentTable = at.sectionListTable
	at.sectionListTable.Show()
	at.sectionDataTable.Hide()
}

// switchToSectionDataMode åˆ‡æ¢åˆ°æ®µæ•°æ®æ¨¡å¼ï¼ˆåå…­è¿›åˆ¶/å­—ç¬¦ä¸²ï¼‰
func (at *AnalysisTab) switchToSectionDataMode() {
	if at.sectionListTable == nil || at.sectionDataTable == nil {
		return
	}

	at.currentTable = at.sectionDataTable
	at.sectionDataTable.Show()
	at.sectionListTable.Hide()
}

```

`ui/internal/utils/utils.go`:

```go
package utils

import (
	"crypto/md5"
	"fmt"
	"io"
	"math/rand"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"time"
)

// GetExecutableDir è·å–å¯æ‰§è¡Œæ–‡ä»¶æ‰€åœ¨ç›®å½•
func GetExecutableDir() (string, error) {
	executable, err := os.Executable()
	if err != nil {
		return "", err
	}
	return filepath.Dir(executable), nil
}

// GetConfigDir è·å–é…ç½®ç›®å½•
func GetConfigDir() (string, error) {
	var configDir string

	switch runtime.GOOS {
	case "windows":
		configDir = os.Getenv("APPDATA")
		if configDir == "" {
			configDir = os.Getenv("USERPROFILE")
		}
	case "darwin":
		configDir = os.Getenv("HOME")
		if configDir != "" {
			configDir = filepath.Join(configDir, "Library", "Application Support")
		}
	default: // linux and others
		configDir = os.Getenv("XDG_CONFIG_HOME")
		if configDir == "" {
			configDir = os.Getenv("HOME")
			if configDir != "" {
				configDir = filepath.Join(configDir, ".config")
			}
		}
	}

	if configDir == "" {
		return "", fmt.Errorf("æ— æ³•ç¡®å®šé…ç½®ç›®å½•")
	}

	return filepath.Join(configDir, "fridare"), nil
}

// EnsureDir ç¡®ä¿ç›®å½•å­˜åœ¨
func EnsureDir(dir string) error {
	return os.MkdirAll(dir, 0755)
}

// FileExists æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
func FileExists(filename string) bool {
	_, err := os.Stat(filename)
	return err == nil
}

// DirExists æ£€æŸ¥ç›®å½•æ˜¯å¦å­˜åœ¨
func DirExists(dirname string) bool {
	info, err := os.Stat(dirname)
	return err == nil && info.IsDir()
}

// CalculateMD5 è®¡ç®—æ–‡ä»¶MD5
func CalculateMD5(filename string) (string, error) {
	file, err := os.Open(filename)
	if err != nil {
		return "", err
	}
	defer file.Close()

	hash := md5.New()
	if _, err := io.Copy(hash, file); err != nil {
		return "", err
	}

	return fmt.Sprintf("%x", hash.Sum(nil)), nil
}

// GetFileSize è·å–æ–‡ä»¶å¤§å°
func GetFileSize(filename string) (int64, error) {
	info, err := os.Stat(filename)
	if err != nil {
		return 0, err
	}
	return info.Size(), nil
}

// FormatBytes æ ¼å¼åŒ–å­—èŠ‚å¤§å°
func FormatBytes(bytes int64) string {
	const unit = 1024
	if bytes < unit {
		return fmt.Sprintf("%d B", bytes)
	}
	div, exp := int64(unit), 0
	for n := bytes / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])
}

// CleanPath æ¸…ç†è·¯å¾„
func CleanPath(path string) string {
	// æ›¿æ¢åæ–œæ ä¸ºæ­£æ–œæ ï¼ˆWindowså…¼å®¹æ€§ï¼‰
	path = strings.ReplaceAll(path, "\\", "/")
	// æ¸…ç†è·¯å¾„
	return filepath.Clean(path)
}

// GetRelativePath è·å–ç›¸å¯¹è·¯å¾„
func GetRelativePath(basepath, targetpath string) (string, error) {
	return filepath.Rel(basepath, targetpath)
}

// SanitizeFilename æ¸…ç†æ–‡ä»¶åï¼ˆç§»é™¤éæ³•å­—ç¬¦ï¼‰
func SanitizeFilename(filename string) string {
	// Windowsç¦ç”¨çš„å­—ç¬¦
	invalidChars := []string{"<", ">", ":", "\"", "|", "?", "*", "/", "\\"}

	for _, char := range invalidChars {
		filename = strings.ReplaceAll(filename, char, "_")
	}

	// ç§»é™¤æ§åˆ¶å­—ç¬¦
	var result strings.Builder
	for _, r := range filename {
		if r >= 32 && r != 127 {
			result.WriteRune(r)
		}
	}

	return strings.TrimSpace(result.String())
}

// CopyFile å¤åˆ¶æ–‡ä»¶
func CopyFile(src, dst string) error {
	sourceFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer sourceFile.Close()

	// ç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨
	if err := EnsureDir(filepath.Dir(dst)); err != nil {
		return err
	}

	destFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer destFile.Close()

	_, err = io.Copy(destFile, sourceFile)
	return err
}

// MoveFile ç§»åŠ¨æ–‡ä»¶
func MoveFile(src, dst string) error {
	// ç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨
	if err := EnsureDir(filepath.Dir(dst)); err != nil {
		return err
	}

	// å…ˆå°è¯•é‡å‘½åï¼ˆå¦‚æœåœ¨åŒä¸€ä¸ªåˆ†åŒºï¼‰
	if err := os.Rename(src, dst); err == nil {
		return nil
	}

	// å¦‚æœé‡å‘½åå¤±è´¥ï¼Œåˆ™å¤åˆ¶ååˆ é™¤
	if err := CopyFile(src, dst); err != nil {
		return err
	}

	return os.Remove(src)
}

// BackupFile å¤‡ä»½æ–‡ä»¶
func BackupFile(filename string) error {
	backupName := filename + ".bak"
	return CopyFile(filename, backupName)
}

// IsValidHex æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆçš„åå…­è¿›åˆ¶å­—ç¬¦ä¸²
func IsValidHex(s string) bool {
	// ç§»é™¤ç©ºæ ¼å’Œå¸¸è§åˆ†éš”ç¬¦
	s = strings.ReplaceAll(s, " ", "")
	s = strings.ReplaceAll(s, "-", "")
	s = strings.ReplaceAll(s, ":", "")

	// æ£€æŸ¥é•¿åº¦æ˜¯å¦ä¸ºå¶æ•°
	if len(s)%2 != 0 {
		return false
	}

	// æ£€æŸ¥æ˜¯å¦åªåŒ…å«åå…­è¿›åˆ¶å­—ç¬¦
	for _, r := range s {
		if !((r >= '0' && r <= '9') || (r >= 'a' && r <= 'f') || (r >= 'A' && r <= 'F')) {
			return false
		}
	}

	return true
}

// CleanHex æ¸…ç†åå…­è¿›åˆ¶å­—ç¬¦ä¸²
func CleanHex(s string) string {
	// ç§»é™¤ç©ºæ ¼å’Œå¸¸è§åˆ†éš”ç¬¦
	s = strings.ReplaceAll(s, " ", "")
	s = strings.ReplaceAll(s, "-", "")
	s = strings.ReplaceAll(s, ":", "")
	s = strings.ReplaceAll(s, "\t", "")
	s = strings.ReplaceAll(s, "\n", "")
	s = strings.ReplaceAll(s, "\r", "")

	return strings.ToUpper(s)
}

// GetSystemInfo è·å–ç³»ç»Ÿä¿¡æ¯
func GetSystemInfo() map[string]string {
	return map[string]string{
		"os":      runtime.GOOS,
		"arch":    runtime.GOARCH,
		"version": runtime.Version(),
		"cpus":    fmt.Sprintf("%d", runtime.NumCPU()),
	}
}

// FindExecutable æŸ¥æ‰¾å¯æ‰§è¡Œæ–‡ä»¶
func FindExecutable(name string) (string, error) {
	// åœ¨ PATH ä¸­æŸ¥æ‰¾
	if path, err := exec.LookPath(name); err == nil {
		return path, nil
	}

	// åœ¨å½“å‰ç›®å½•æŸ¥æ‰¾
	if FileExists(name) {
		return filepath.Abs(name)
	}

	// åœ¨å¯æ‰§è¡Œæ–‡ä»¶ç›®å½•æŸ¥æ‰¾
	execDir, err := GetExecutableDir()
	if err == nil {
		execPath := filepath.Join(execDir, name)
		if FileExists(execPath) {
			return execPath, nil
		}
	}

	return "", fmt.Errorf("æ‰¾ä¸åˆ°å¯æ‰§è¡Œæ–‡ä»¶: %s", name)
}

// FetchRemoteText è·å–è¿œç¨‹æ–‡æœ¬å†…å®¹(æ”¯æŒä»£ç†)
func FetchRemoteText(urlStr string, proxyURL string) (string, error) {
	// åˆ›å»ºHTTPå®¢æˆ·ç«¯
	client := &http.Client{
		Timeout: 10 * time.Second,
	}

	// å¦‚æœproxyURL ä¼ å…¥ä¸ºç©ºï¼Œåˆ™å°è¯•ä½¿ç”¨ç³»ç»Ÿä»£ç†
	if proxyURL == "" {
		if proxyURL, err := http.ProxyFromEnvironment(&http.Request{URL: &url.URL{Host: urlStr}}); err == nil && proxyURL != nil {
			client.Transport = &http.Transport{
				Proxy: http.ProxyURL(proxyURL),
			}
		}
	}
	// å¦‚æœæä¾›äº†ä»£ç†URLï¼Œè®¾ç½®ä»£ç†
	resp, err := client.Get(urlStr)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("è¯·æ±‚å¤±è´¥: %s", resp.Status)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(body), nil
}

// TestProxy æµ‹è¯•ä»£ç†è¿æ¥
func TestProxy(proxyURL string, testURL string, timeout int) (bool, string, error) {
	// å¦‚æœæ²¡æœ‰æŒ‡å®šæµ‹è¯•URLï¼Œä½¿ç”¨é»˜è®¤çš„
	if testURL == "" {
		testURL = "https://api.github.com/repos/frida/frida/releases/latest"
	}

	// åˆ›å»ºHTTPå®¢æˆ·ç«¯
	client := &http.Client{
		Timeout: time.Duration(timeout) * time.Second,
	}

	// å¦‚æœæä¾›äº†ä»£ç†URLï¼Œè®¾ç½®ä»£ç†
	if proxyURL != "" {
		proxyParsed, err := url.Parse(proxyURL)
		if err != nil {
			return false, "ä»£ç†URLæ ¼å¼é”™è¯¯", err
		}

		transport := &http.Transport{
			Proxy: http.ProxyURL(proxyParsed),
		}
		client.Transport = transport
	}

	// å‘é€æµ‹è¯•è¯·æ±‚
	start := time.Now()
	resp, err := client.Get(testURL)
	elapsed := time.Since(start)

	if err != nil {
		return false, fmt.Sprintf("è¿æ¥å¤±è´¥: %v", err), err
	}
	defer resp.Body.Close()

	// æ£€æŸ¥å“åº”çŠ¶æ€
	if resp.StatusCode == http.StatusOK {
		return true, fmt.Sprintf("è¿æ¥æˆåŠŸ (%dms)", elapsed.Milliseconds()), nil
	} else {
		return false, fmt.Sprintf("HTTPçŠ¶æ€ç : %d", resp.StatusCode), nil
	}
}

// GenerateRandomName ç”Ÿæˆéšæœºåç§°ï¼ˆ5ä¸ªå­—ç¬¦ï¼Œç¬¬ä¸€ä½å¿…é¡»æ˜¯å­—æ¯ï¼Œç”¨1-5å­—æ¯å•è¯+æ•°å­—è¡¥å……ï¼‰
func GenerateRandomName() string {
	// åˆ›å»ºéšæœºç”Ÿæˆå™¨
	rng := rand.New(rand.NewSource(time.Now().UnixNano()))

	// 1å­—æ¯å•è¯ï¼ˆå¸¸ç”¨ç¼©å†™ï¼‰
	oneLetterWords := []string{
		"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
		"n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
	}

	// 2å­—æ¯å•è¯
	twoLetterWords := []string{
		"ai", "am", "an", "as", "at", "be", "by", "do", "go", "he", "hi",
		"if", "in", "is", "it", "me", "my", "no", "of", "ok", "on", "or",
		"so", "to", "up", "we", "db", "os", "ui", "io", "js", "py", "qt",
		"ax", "ox", "ex", "rx", "tx", "dx", "fx", "mx", "nx", "px", "zx",
	}

	// 3å­—æ¯å•è¯
	threeLetterWords := []string{
		"add", "and", "any", "app", "art", "bad", "big", "box", "bug", "bus",
		"buy", "can", "car", "cat", "cpu", "cry", "cut", "day", "die", "dig",
		"doc", "dog", "eat", "end", "eye", "far", "fix", "fly", "for", "fun",
		"get", "god", "gun", "guy", "has", "hit", "hot", "how", "ice", "job",
		"key", "led", "let", "log", "lot", "low", "man", "map", "max", "may",
		"net", "new", "now", "old", "one", "our", "out", "own", "pay", "pdf",
		"put", "ram", "raw", "red", "rom", "row", "run", "see", "set", "sex",
		"she", "six", "sql", "sun", "tax", "tea", "ten", "the", "top", "try",
		"two", "use", "via", "war", "way", "web", "who", "why", "win", "yes",
		"you", "zip", "api", "css", "dll", "exe", "gif", "jpg", "png", "xml",
	}

	// 4å­—æ¯å•è¯
	fourLetterWords := []string{
		"able", "back", "base", "best", "blue", "body", "book", "both", "call",
		"came", "case", "chat", "city", "code", "come", "copy", "core", "data",
		"date", "deal", "deep", "desk", "diff", "disk", "done", "door", "down",
		"draw", "drop", "each", "edit", "else", "even", "ever", "exit", "face",
		"fact", "fail", "fast", "file", "find", "fire", "flag", "flow", "form",
		"free", "from", "full", "game", "give", "good", "grab", "hand", "hard",
		"have", "head", "help", "here", "hide", "high", "hold", "home", "hope",
		"host", "hour", "http", "huge", "icon", "idea", "into", "item", "join",
		"jump", "just", "keep", "kind", "know", "last", "late", "left", "like",
		"line", "link", "list", "live", "load", "lock", "long", "look", "loop",
		"love", "made", "mail", "main", "make", "many", "mark", "math", "menu",
		"meta", "mind", "mode", "more", "most", "move", "much", "must", "name",
		"near", "need", "news", "next", "nice", "node", "note", "only", "open",
		"over", "page", "part", "pass", "path", "plan", "play", "plus", "port",
		"post", "pull", "push", "quit", "race", "read", "real", "rich", "room",
		"root", "rule", "same", "save", "scan", "seal", "seek", "seem", "self",
		"sell", "send", "show", "shut", "side", "sign", "size", "some", "sort",
		"spin", "stop", "sure", "swap", "take", "talk", "task", "team", "tell",
		"test", "text", "than", "that", "them", "then", "they", "this", "time",
		"tiny", "tool", "true", "turn", "type", "unit", "upon", "used", "user",
		"very", "view", "wait", "walk", "want", "what", "when", "with", "word",
		"work", "year", "your", "zero", "ajax", "bash", "boot", "bulk", "byte",
		"calc", "cash", "chef", "clip", "club", "cool", "ctrl", "curl", "demo",
		"draw", "dump", "echo", "exec", "font", "grep", "hash", "head", "heap",
		"http", "init", "java", "jpeg", "json", "kill", "lamp", "lens", "lint",
		"loop", "mask", "mega", "mono", "nano", "null", "perl", "ping", "plug",
		"pool", "post", "proc", "quad", "quiz", "rake", "rest", "ruby", "slug",
		"snap", "soap", "tail", "temp", "term", "unix", "uuid", "void", "wiki",
		"yoga", "zoom",
	}

	// 5å­—æ¯å•è¯
	fiveLetterWords := []string{
		"about", "above", "abuse", "actor", "acute", "admit", "adopt", "adult",
		"after", "again", "agent", "agree", "ahead", "alarm", "album", "alert",
		"alien", "align", "alike", "alive", "allow", "alone", "along", "alter",
		"amber", "amend", "among", "anger", "angle", "angry", "apart", "apple",
		"apply", "arena", "argue", "arise", "array", "arrow", "aside", "asset",
		"atlas", "audio", "audit", "avoid", "awake", "award", "aware", "badly",
		"baker", "bases", "basic", "beach", "began", "begin", "being", "below",
		"bench", "billy", "birth", "black", "blame", "blank", "blast", "blind",
		"block", "blood", "bloom", "board", "boost", "booth", "bound", "brain",
		"brand", "brass", "brave", "bread", "break", "breed", "brief", "bring",
		"broad", "broke", "brown", "brush", "build", "built", "buyer", "cable",
		"cache", "candy", "carry", "catch", "cause", "chain", "chair", "chaos",
		"charm", "chart", "chase", "cheap", "check", "chess", "chest", "child",
		"china", "chose", "civil", "claim", "class", "clean", "clear", "click",
		"climb", "clock", "close", "cloud", "coach", "coast", "could", "count",
		"court", "cover", "crack", "craft", "crash", "crazy", "cream", "crime",
		"cross", "crowd", "crown", "crude", "curve", "cycle", "daily", "dance",
		"dated", "dealt", "death", "debut", "delay", "depth", "doing", "doubt",
		"dozen", "draft", "drama", "drank", "dream", "dress", "drill", "drink",
		"drive", "drove", "dying", "eager", "early", "earth", "eight", "elite",
		"empty", "enemy", "enjoy", "enter", "entry", "equal", "error", "event",
		"every", "exact", "exist", "extra", "faith", "false", "fault", "fiber",
		"field", "fifth", "fifty", "fight", "final", "first", "fixed", "flash",
		"fleet", "floor", "fluid", "focus", "force", "forth", "forty", "forum",
		"found", "frame", "frank", "fraud", "fresh", "front", "fruit", "fully",
		"funny", "giant", "given", "glass", "globe", "glory", "grace", "grade",
		"grand", "grant", "grass", "grave", "great", "green", "gross", "group",
		"grown", "guard", "guess", "guest", "guide", "happy", "harry", "heart",
		"heavy", "hence", "henry", "horse", "hotel", "house", "human", "hurry",
		"image", "imply", "index", "inner", "input", "intro", "issue", "japan",
		"jimmy", "joint", "jones", "judge", "known", "label", "large", "laser",
		"later", "laugh", "layer", "learn", "lease", "least", "leave", "legal",
		"level", "lewis", "light", "limit", "links", "lived", "local", "logic",
		"loose", "lower", "lucky", "lunch", "lying", "magic", "major", "maker",
		"march", "maria", "match", "maybe", "mayor", "meant", "media", "metal",
		"might", "minor", "minus", "mixed", "model", "money", "month", "moral",
		"motor", "mount", "mouse", "mouth", "moved", "movie", "music", "needs",
		"never", "newly", "night", "noise", "north", "noted", "novel", "nurse",
		"occur", "ocean", "offer", "often", "order", "organ", "other", "ought",
		"owner", "paint", "panel", "panic", "paper", "party", "peace", "peter",
		"phase", "phone", "photo", "piano", "piece", "pilot", "pitch", "place",
		"plain", "plane", "plant", "plate", "point", "pound", "power", "press",
		"price", "pride", "prime", "print", "prior", "prize", "proof", "proud",
		"prove", "queen", "quick", "quiet", "quite", "radio", "raise", "range",
		"rapid", "ratio", "reach", "react", "ready", "realm", "rebel", "refer",
		"relax", "repay", "reply", "right", "rigid", "rival", "river", "robin",
		"roger", "roman", "rough", "round", "route", "royal", "rugby", "rural",
		"safer", "saint", "salad", "sales", "sarah", "sauce", "scale", "scare",
		"scene", "scope", "score", "sense", "serve", "seven", "shade", "shake",
		"shall", "shame", "shape", "share", "sharp", "sheep", "sheet", "shelf",
		"shell", "shift", "shine", "shirt", "shock", "shoot", "short", "shown",
		"sight", "silly", "simon", "since", "sixth", "sixty", "sized", "skill",
		"sleep", "slide", "small", "smart", "smile", "smith", "smoke", "snake",
		"snow", "solid", "solve", "sorry", "sound", "south", "space", "spare",
		"speak", "speed", "spend", "spent", "split", "spoke", "sport", "staff",
		"stage", "stake", "stand", "start", "state", "steal", "steam", "steel",
		"stick", "still", "stock", "stone", "stood", "store", "storm", "story",
		"strip", "stuck", "study", "stuff", "style", "sugar", "suite", "super",
		"sweet", "swift", "swing", "swiss", "sword", "table", "taken", "taste",
		"taxes", "teach", "terry", "thank", "theft", "their", "theme", "there",
		"these", "thick", "thing", "think", "third", "those", "three", "threw",
		"throw", "thumb", "tiger", "tight", "times", "title", "today", "token",
		"topic", "total", "touch", "tough", "tower", "track", "trade", "train",
		"treat", "trend", "trial", "tribe", "trick", "tried", "tries", "truly",
		"trunk", "trust", "truth", "twice", "twist", "tyler", "ultra", "uncle",
		"under", "undue", "union", "unity", "until", "upper", "upset", "urban",
		"urged", "usage", "users", "using", "usual", "valid", "value", "video",
		"virus", "visit", "vital", "vocal", "voice", "waste", "watch", "water",
		"wheel", "where", "which", "while", "white", "whole", "whose", "woman",
		"women", "world", "worry", "worse", "worst", "worth", "would", "write",
		"wrong", "wrote", "young", "yours", "youth", "admin", "adobe", "agent",
		"alert", "anime", "apple", "ascii", "atlas", "badge", "beach", "bench",
		"black", "blade", "blank", "blast", "blend", "blind", "block", "bloom",
		"board", "boost", "booth", "bound", "brain", "brand", "brave", "bread",
		"break", "brick", "brief", "bring", "broad", "brown", "brush", "build",
		"burst", "buyer", "cable", "cache", "candy", "carry", "catch", "chain",
		"chair", "chaos", "charm", "chart", "chase", "cheap", "check", "chess",
		"chest", "china", "chose", "civic", "claim", "class", "clean", "clear",
		"click", "climb", "clock", "close", "cloud", "clown", "coach", "coast",
		"could", "count", "court", "cover", "crack", "craft", "crash", "crazy",
		"cream", "crime", "crisp", "cross", "crowd", "crown", "crude", "curve",
		"cycle", "daily", "dance", "dated", "dealt", "death", "debug", "delay",
		"depth", "doing", "doubt", "dozen", "draft", "drama", "drank", "dream",
		"dress", "drill", "drink", "drive", "drove", "dying", "eager", "early",
		"earth", "eight", "elite", "empty", "enemy", "enjoy", "enter", "entry",
		"equal", "error", "event", "every", "exact", "exist", "extra", "faith",
		"false", "fault", "fiber", "field", "fifth", "fifty", "fight", "final",
		"first", "fixed", "flash", "fleet", "floor", "fluid", "focus", "force",
		"forth", "forty", "forum", "found", "frame", "frank", "fraud", "fresh",
		"front", "fruit", "fully", "funny", "giant", "given", "glass", "globe",
		"glory", "grace", "grade", "grand", "grant", "grass", "grave", "great",
		"green", "gross", "group", "grown", "guard", "guess", "guest", "guide",
		"happy", "harry", "heart", "heavy", "hence", "henry", "horse", "hotel",
		"house", "human", "hurry", "image", "imply", "index", "inner", "input",
		"intro", "issue", "japan", "jimmy", "joint", "jones", "judge", "known",
		"label", "large", "laser", "later", "laugh", "layer", "learn", "lease",
		"least", "leave", "legal", "level", "lewis", "light", "limit", "links",
		"lived", "local", "logic", "loose", "lower", "lucky", "lunch", "lying",
		"magic", "major", "maker", "march", "maria", "match", "maybe", "mayor",
		"meant", "media", "metal", "might", "minor", "minus", "mixed", "model",
		"money", "month", "moral", "motor", "mount", "mouse", "mouth", "moved",
		"movie", "music", "needs", "never", "newly", "night", "noise", "north",
		"noted", "novel", "nurse", "occur", "ocean", "offer", "often", "order",
		"organ", "other", "ought", "owner", "paint", "panel", "panic", "paper",
		"party", "peace", "peter", "phase", "phone", "photo", "piano", "piece",
		"pilot", "pitch", "place", "plain", "plane", "plant", "plate", "point",
		"pound", "power", "press", "price", "pride", "prime", "print", "prior",
		"prize", "proof", "proud", "prove", "queen", "quick", "quiet", "quite",
		"radio", "raise", "range", "rapid", "ratio", "reach", "react", "ready",
		"realm", "rebel", "refer", "relax", "repay", "reply", "right", "rigid",
		"rival", "river", "robin", "roger", "roman", "rough", "round", "route",
		"royal", "rugby", "rural", "safer", "saint", "salad", "sales", "sarah",
		"sauce", "scale", "scare", "scene", "scope", "score", "sense", "serve",
		"seven", "shade", "shake", "shall", "shame", "shape", "share", "sharp",
		"sheep", "sheet", "shelf", "shell", "shift", "shine", "shirt", "shock",
		"shoot", "short", "shown", "sight", "silly", "simon", "since", "sixth",
		"sixty", "sized", "skill", "sleep", "slide", "small", "smart", "smile",
		"smith", "smoke", "snake", "solid", "solve", "sorry", "sound", "south",
		"space", "spare", "speak", "speed", "spend", "spent", "split", "spoke",
		"sport", "staff", "stage", "stake", "stand", "start", "state", "steal",
		"steam", "steel", "stick", "still", "stock", "stone", "stood", "store",
		"storm", "story", "strip", "stuck", "study", "stuff", "style", "sugar",
		"suite", "super", "sweet", "swift", "swing", "swiss", "sword", "table",
		"taken", "taste", "taxes", "teach", "terry", "thank", "theft", "their",
		"theme", "there", "these", "thick", "thing", "think", "third", "those",
		"three", "threw", "throw", "thumb", "tiger", "tight", "times", "title",
		"today", "token", "topic", "total", "touch", "tough", "tower", "track",
		"trade", "train", "treat", "trend", "trial", "tribe", "trick", "tried",
		"tries", "truly", "trunk", "trust", "truth", "twice", "twist", "tyler",
		"ultra", "uncle", "under", "undue", "union", "unity", "until", "upper",
		"upset", "urban", "urged", "usage", "users", "using", "usual", "valid",
		"value", "video", "virus", "visit", "vital", "vocal", "voice", "waste",
		"watch", "water", "wheel", "where", "which", "while", "white", "whole",
		"whose", "woman", "women", "world", "worry", "worse", "worst", "worth",
		"would", "write", "wrong", "wrote", "young", "yours", "youth",
	}

	// å°†æ‰€æœ‰å•è¯ç»„åˆ
	allWords := [][]string{
		oneLetterWords,
		twoLetterWords,
		threeLetterWords,
		fourLetterWords,
		fiveLetterWords,
	}

	// éšæœºé€‰æ‹©é•¿åº¦ç±»åˆ«
	lengthIndex := rng.Intn(len(allWords))
	selectedWords := allWords[lengthIndex]

	// ä»é€‰ä¸­çš„é•¿åº¦ç±»åˆ«ä¸­éšæœºé€‰æ‹©ä¸€ä¸ªå•è¯
	baseWord := selectedWords[rng.Intn(len(selectedWords))]

	// å¦‚æœå•è¯é•¿åº¦ä¸è¶³5ä¸ªå­—ç¬¦ï¼Œç”¨æ•°å­—è¡¥å……
	if len(baseWord) < 5 {
		needed := 5 - len(baseWord)
		for i := 0; i < needed; i++ {
			baseWord += fmt.Sprintf("%d", rng.Intn(10))
		}
	}

	return baseWord
}
// isFridaNewName æ£€æŸ¥å­—ç¬¦ä¸²å¿…é¡»æ˜¯ A-Za-z0-9
func IsFridaNewName(s string) bool {
	for _, c := range s {
		//å¿…é¡»æ˜¯ A-Za-z0-9
		if !((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')) {
			return false
		}
	}
	//å¦‚æœç¬¬ä¸€ä¸ªå­—ç¬¦ä¸æ˜¯å­—æ¯ä¹Ÿä¸è¡Œ
	if s[0] < 'A' || (s[0] > 'Z' && s[0] < 'a') || s[0] > 'z' {
		return false
	}
	return true
}
```

`win/README.md`:

```md
# Fridare Windows ä½¿ç”¨æŒ‡å—

## æœ€æ–°æ›´æ–°

### v3.1.5 - Windows æ”¯æŒ

- æ–°å¢ `patch-frida.cmd` è„šæœ¬,ç”¨äºåœ¨ Windows ç¯å¢ƒä¸‹ä¿®æ”¹ frida-server
- æ–°å¢ `patch-frida-tools.cmd` è„šæœ¬,ç”¨äºåœ¨ Windows ç¯å¢ƒä¸‹ä¿®æ”¹ frida-tools
- å¢åŠ å¯¹ Windows å¹³å°çš„å…¨é¢æ”¯æŒ
- æ›´æ–°äº†ä½¿ç”¨è¯´æ˜,å¢åŠ äº† Windows å¹³å°çš„è¯¦ç»†æ•™ç¨‹

## Windows ä¸‹çš„ä½¿ç”¨æ•™ç¨‹

### å‡†å¤‡å·¥ä½œ

1. ç¡®ä¿ä½ çš„ç³»ç»Ÿå·²ç»å®‰è£…äº† Python å’Œ pip
2. ä¸‹è½½ Fridare é¡¹ç›®åˆ°æœ¬åœ°

### ä¿®æ”¹ frida-server

1. æ‰“å¼€å‘½ä»¤æç¤ºç¬¦,è¿›å…¥ Fridare é¡¹ç›®ç›®å½•
2. è¿è¡Œä»¥ä¸‹å‘½ä»¤:

```
patch-frida.cmd <frida-serverè·¯å¾„> <5å­—ç¬¦é­”æ”¹å>
```

ä¾‹å¦‚:

```
patch-frida.cmd frida-server-16.4.7-android-arm64 abcde
```

3. è„šæœ¬å°†ä¼šç”Ÿæˆä¸€ä¸ªä¿®æ”¹åçš„ frida-server æ–‡ä»¶,æ–‡ä»¶åä¸º `frida-server-16.4.7-android-arm64_abcde`

### ä¿®æ”¹ frida-tools

1. åœ¨å‘½ä»¤æç¤ºç¬¦ä¸­è¿è¡Œ:

```
patch-frida-tools.cmd
```

2. è„šæœ¬ä¼šè‡ªåŠ¨å®šä½ frida çš„å®‰è£…è·¯å¾„
3. æ ¹æ®æç¤ºè¾“å…¥ 5 ä¸ªå­—ç¬¦çš„é­”æ”¹å(å¿…é¡»æ˜¯å°å†™å­—æ¯ a-z)
4. è„šæœ¬ä¼šè‡ªåŠ¨ä¿®æ”¹ `core.py` å’Œ `_frida.pyd` æ–‡ä»¶

### æ³¨æ„äº‹é¡¹

- åœ¨ä¿®æ”¹ frida-tools ä¹‹å‰,è„šæœ¬ä¼šè‡ªåŠ¨å¤‡ä»½åŸæ–‡ä»¶
- ç¡®ä¿ä½ æœ‰è¶³å¤Ÿçš„æƒé™ä¿®æ”¹ Python å®‰è£…ç›®å½•ä¸‹çš„æ–‡ä»¶
- ä¿®æ”¹å,å»ºè®®é‡æ–°å¯åŠ¨ä½ çš„ Python ç¯å¢ƒä»¥ç¡®ä¿æ›´æ”¹ç”Ÿæ•ˆ

## æ•…éšœæ’é™¤

å¦‚æœé‡åˆ° "Error: hexreplace tool not found" é”™è¯¯,è¯·ç¡®ä¿ `hexreplace_windows_amd64.exe` æ–‡ä»¶ä½äºä¸è„šæœ¬ç›¸åŒçš„ç›®å½•ä¸­ã€‚

å¦‚æœä¿®æ”¹è¿‡ç¨‹ä¸­é‡åˆ°æƒé™é—®é¢˜,å°è¯•ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œå‘½ä»¤æç¤ºç¬¦ã€‚

## æ¢å¤åŸå§‹æ–‡ä»¶

å¦‚æœéœ€è¦æ¢å¤åŸå§‹çš„ frida-tools æ–‡ä»¶:

1. æ‰¾åˆ° frida çš„å®‰è£…ç›®å½• (é€šå¸¸åœ¨è¿è¡Œ `patch-frida-tools.cmd` æ—¶ä¼šæ˜¾ç¤º)
2. å°† `core.py.fridare` é‡å‘½åä¸º `core.py`
3. å°† `_frida.pyd.fridare` é‡å‘½åä¸º `_frida.pyd`

## è´¡çŒ®

æ¬¢è¿æäº¤é—®é¢˜å’Œæ‹‰å–è¯·æ±‚ã€‚å¯¹äºé‡å¤§æ›´æ”¹,è¯·å…ˆå¼€ issue è®¨è®ºæ‚¨æƒ³è¦æ›´æ”¹çš„å†…å®¹ã€‚

## è®¸å¯è¯

[MIT LICENSE](LICENSE)

```

`win/patch-frida-tools.cmd`:

```cmd
@echo off
setlocal enabledelayedexpansion

:: è·å–è„šæœ¬æ‰€åœ¨è·¯å¾„
set "SCRIPT_PATH=%~dp0"
:: è®¾ç½® hexreplace å·¥å…·è·¯å¾„
set "HEXREPLACE_PATH=%SCRIPT_PATH%hexreplace_windows_amd64.exe"

:: æ£€æŸ¥ hexreplace å·¥å…·æ˜¯å¦å­˜åœ¨
if not exist "%HEXREPLACE_PATH%" (
    echo Error: hexreplace tool not found at %HEXREPLACE_PATH%
    goto :eof
)

:: ä½¿ç”¨ pip è·å– Frida å®‰è£…è·¯å¾„
for /f "tokens=2 delims= " %%a in ('pip show frida ^| findstr "Location"') do set FRIDA_PATH=%%a\frida

echo Frida installation path: %FRIDA_PATH%

:: æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
if not exist "%FRIDA_PATH%\core.py" (
    echo Error: core.py not found in %FRIDA_PATH%
    goto :eof
)
if not exist "%FRIDA_PATH%\_frida.pyd" (
    echo Error: _frida.pyd not found in %FRIDA_PATH%
    goto :eof
)

:: å¤‡ä»½æ–‡ä»¶
if not exist "%FRIDA_PATH%\core.py.fridare" (
    copy "%FRIDA_PATH%\core.py" "%FRIDA_PATH%\core.py.fridare"
    echo Backed up core.py
)
if not exist "%FRIDA_PATH%\_frida.pyd.fridare" (
    copy "%FRIDA_PATH%\_frida.pyd" "%FRIDA_PATH%\_frida.pyd.fridare"
    echo Backed up _frida.pyd
)

:: è·å–ç”¨æˆ·è¾“å…¥
set /p "input=Please enter 5 characters (a-z): "
if not "%input:~4,1%" == "" (
    if "%input:~5,1%" == "" (
        echo Input accepted.
    ) else (
        echo Input must be exactly 5 characters.
        goto :eof
    )
) else (
    echo Input must be exactly 5 characters.
    goto :eof
)

:: ä½¿ç”¨ hexreplace ä¿®æ”¹æ–‡ä»¶
"%HEXREPLACE_PATH%" "%FRIDA_PATH%\_frida.pyd" %input% "%FRIDA_PATH%\_frida.pyd.modify"

if %errorlevel% neq 0 (
    echo Error occurred during file modification.
    goto :eof
)

:: æ›¿æ¢åŸæ–‡ä»¶
move /y "%FRIDA_PATH%\_frida.pyd.modify" "%FRIDA_PATH%\_frida.pyd"

echo Modification complete.
```

`win/patch-frida.cmd`:

```cmd
@echo off
setlocal enabledelayedexpansion

:: æ£€æŸ¥å‚æ•°æ•°é‡
if "%~2"=="" (
    echo Usage: %~nx0 ^<frida-server_path^> ^<5_char_magic_name^>
    echo Example: %~nx0 "C:\path\to\frida-server.exe" abcde
    goto :eof
)

:: è·å–è¾“å…¥å‚æ•°
set "FRIDA_SERVER_PATH=%~1"
set "MAGIC_NAME=%~2"

:: éªŒè¯è¾“å…¥æ–‡ä»¶è·¯å¾„
if not exist "%FRIDA_SERVER_PATH%" (
    echo Error: frida-server file not found at %FRIDA_SERVER_PATH%
    goto :eof
)

:: éªŒè¯é­”æ”¹åé•¿åº¦
if not "%MAGIC_NAME:~4,1%" == "" (
    if "%MAGIC_NAME:~5,1%" == "" (
        echo Magic name accepted.
    ) else (
        echo Error: Magic name must be exactly 5 characters.
        goto :eof
    )
) else (
    echo Error: Magic name must be exactly 5 characters.
    goto :eof
)

:: è·å–è„šæœ¬æ‰€åœ¨è·¯å¾„
set "SCRIPT_PATH=%~dp0"
:: è®¾ç½® hexreplace å·¥å…·è·¯å¾„
set "HEXREPLACE_PATH=%SCRIPT_PATH%hexreplace_windows_amd64.exe"

:: æ£€æŸ¥ hexreplace å·¥å…·æ˜¯å¦å­˜åœ¨
if not exist "%HEXREPLACE_PATH%" (
    echo Error: hexreplace tool not found at %HEXREPLACE_PATH%
    goto :eof
)

:: æ„å»ºè¾“å‡ºæ–‡ä»¶å
for %%F in ("%FRIDA_SERVER_PATH%") do (
    set "FILE_NAME=%%~nF"
    set "FILE_EXT=%%~xF"
)
set "OUTPUT_PATH=%~dp1%FILE_NAME%%FILE_EXT%_%MAGIC_NAME%"

:: ä½¿ç”¨ hexreplace ä¿®æ”¹æ–‡ä»¶
"%HEXREPLACE_PATH%" "%FRIDA_SERVER_PATH%" %MAGIC_NAME% "%OUTPUT_PATH%"

if %errorlevel% neq 0 (
    echo Error occurred during file modification.
    goto :eof
)

echo Modification complete.
echo Modified file saved as: %OUTPUT_PATH%
```