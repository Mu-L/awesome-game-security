Project Path: arc_eversinc33_unKover_e5ub6bjr

Source Tree:

```txt
arc_eversinc33_unKover_e5ub6bjr
├── Client
│   ├── App.config
│   ├── App.xaml
│   ├── App.xaml.cs
│   ├── Client.csproj
│   ├── MainWindow.xaml
│   ├── MainWindow.xaml.cs
│   ├── Properties
│   │   ├── AssemblyInfo.cs
│   │   ├── Resources.Designer.cs
│   │   ├── Resources.resx
│   │   ├── Settings.Designer.cs
│   │   └── Settings.settings
│   └── packages.config
├── README.md
├── Unkover.inf
├── Unkover.sln
├── Unkover.vcxproj
├── Unkover.vcxproj.filters
├── Unkover.vcxproj.new
├── img
│   ├── detect.jpg
│   └── gui.png
└── unKover
    ├── Driver.cpp
    ├── Driver.h
    ├── apc.cpp
    ├── apc.h
    ├── deviceobjects.cpp
    ├── deviceobjects.h
    ├── handlers.cpp
    ├── handlers.h
    ├── hiding.cpp
    ├── hiding.h
    ├── meta.cpp
    ├── meta.h
    ├── nmi.cpp
    ├── nmi.h
    ├── sectioncompare.cpp
    ├── sectioncompare.h
    ├── threads.cpp
    ├── threads.h
    ├── tracing.cpp
    ├── utils.cpp
    └── utils.h

```

`Client/App.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2" />
    </startup>
  <runtime>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-6.0.3.0" newVersion="6.0.3.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.1.2" newVersion="4.0.1.2" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-9.0.0.8" newVersion="9.0.0.8" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-9.0.0.8" newVersion="9.0.0.8" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-9.0.0.8" newVersion="9.0.0.8" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-9.0.0.8" newVersion="9.0.0.8" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
      </dependentAssembly>
    </assemblyBinding>
  </runtime>
</configuration>
```

`Client/App.xaml`:

```xaml
<Application x:Class="Client.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:Client"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
         
    </Application.Resources>
</Application>

```

`Client/App.xaml.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;

namespace Client
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application
    {
    }
}

```

`Client/Client.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="..\packages\Microsoft.Diagnostics.Tracing.TraceEvent.3.1.28\build\Microsoft.Diagnostics.Tracing.TraceEvent.props" Condition="Exists('..\packages\Microsoft.Diagnostics.Tracing.TraceEvent.3.1.28\build\Microsoft.Diagnostics.Tracing.TraceEvent.props')" />
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{3ED9B299-9FD8-4215-B269-479EC0221F60}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>Client</RootNamespace>
    <AssemblyName>Client</AssemblyName>
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <ProjectTypeGuids>{60dc8134-eba5-43b8-bcc9-bb4bc16c2548};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
    <WarningLevel>4</WarningLevel>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
    <NuGetPackageImportStamp>
    </NuGetPackageImportStamp>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Dia2Lib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Diagnostics.Tracing.TraceEvent.3.1.28\lib\netstandard2.0\Dia2Lib.dll</HintPath>
      <EmbedInteropTypes>True</EmbedInteropTypes>
    </Reference>
    <Reference Include="Microsoft.Bcl.AsyncInterfaces, Version=9.0.0.8, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Bcl.AsyncInterfaces.9.0.8\lib\net462\Microsoft.Bcl.AsyncInterfaces.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Diagnostics.FastSerialization, Version=3.1.28.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Diagnostics.Tracing.TraceEvent.3.1.28\lib\netstandard2.0\Microsoft.Diagnostics.FastSerialization.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Diagnostics.NETCore.Client, Version=0.2.10.10501, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Diagnostics.NETCore.Client.0.2.510501\lib\netstandard2.0\Microsoft.Diagnostics.NETCore.Client.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Diagnostics.Tracing.TraceEvent, Version=3.1.28.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Diagnostics.Tracing.TraceEvent.3.1.28\lib\netstandard2.0\Microsoft.Diagnostics.Tracing.TraceEvent.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.DependencyInjection, Version=6.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Extensions.DependencyInjection.6.0.0\lib\net461\Microsoft.Extensions.DependencyInjection.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.DependencyInjection.Abstractions, Version=6.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Extensions.DependencyInjection.Abstractions.6.0.0\lib\net461\Microsoft.Extensions.DependencyInjection.Abstractions.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.Logging, Version=6.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Extensions.Logging.6.0.0\lib\net461\Microsoft.Extensions.Logging.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.Logging.Abstractions, Version=6.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Extensions.Logging.Abstractions.6.0.0\lib\net461\Microsoft.Extensions.Logging.Abstractions.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.Options, Version=6.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Extensions.Options.6.0.0\lib\net461\Microsoft.Extensions.Options.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.Primitives, Version=6.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Extensions.Primitives.6.0.0\lib\net461\Microsoft.Extensions.Primitives.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Win32.Registry, Version=5.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Win32.Registry.5.0.0\lib\net461\Microsoft.Win32.Registry.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Buffers, Version=4.0.3.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Buffers.4.5.1\lib\net461\System.Buffers.dll</HintPath>
    </Reference>
    <Reference Include="System.Collections.Immutable, Version=9.0.0.8, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Collections.Immutable.9.0.8\lib\net462\System.Collections.Immutable.dll</HintPath>
    </Reference>
    <Reference Include="System.ComponentModel.DataAnnotations" />
    <Reference Include="System.Data" />
    <Reference Include="System.Diagnostics.DiagnosticSource, Version=6.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Diagnostics.DiagnosticSource.6.0.0\lib\net461\System.Diagnostics.DiagnosticSource.dll</HintPath>
    </Reference>
    <Reference Include="System.IO.Pipelines, Version=9.0.0.8, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>..\packages\System.IO.Pipelines.9.0.8\lib\net462\System.IO.Pipelines.dll</HintPath>
    </Reference>
    <Reference Include="System.Memory, Version=4.0.1.2, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Memory.4.5.5\lib\net461\System.Memory.dll</HintPath>
    </Reference>
    <Reference Include="System.Numerics" />
    <Reference Include="System.Numerics.Vectors, Version=4.1.4.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Numerics.Vectors.4.5.0\lib\net46\System.Numerics.Vectors.dll</HintPath>
    </Reference>
    <Reference Include="System.Reflection.Metadata, Version=9.0.0.8, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Reflection.Metadata.9.0.8\lib\net462\System.Reflection.Metadata.dll</HintPath>
    </Reference>
    <Reference Include="System.Reflection.TypeExtensions, Version=4.1.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Reflection.TypeExtensions.4.7.0\lib\net461\System.Reflection.TypeExtensions.dll</HintPath>
    </Reference>
    <Reference Include="System.Runtime.CompilerServices.Unsafe, Version=6.0.3.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Runtime.CompilerServices.Unsafe.6.1.2\lib\net462\System.Runtime.CompilerServices.Unsafe.dll</HintPath>
    </Reference>
    <Reference Include="System.Security.AccessControl, Version=5.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Security.AccessControl.5.0.0\lib\net461\System.Security.AccessControl.dll</HintPath>
    </Reference>
    <Reference Include="System.Security.Principal.Windows, Version=5.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Security.Principal.Windows.5.0.0\lib\net461\System.Security.Principal.Windows.dll</HintPath>
    </Reference>
    <Reference Include="System.Text.Encodings.Web, Version=9.0.0.8, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Text.Encodings.Web.9.0.8\lib\net462\System.Text.Encodings.Web.dll</HintPath>
    </Reference>
    <Reference Include="System.Text.Json, Version=9.0.0.8, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Text.Json.9.0.8\lib\net462\System.Text.Json.dll</HintPath>
    </Reference>
    <Reference Include="System.Threading.Tasks.Extensions, Version=4.2.0.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>..\packages\System.Threading.Tasks.Extensions.4.5.4\lib\net461\System.Threading.Tasks.Extensions.dll</HintPath>
    </Reference>
    <Reference Include="System.ValueTuple, Version=4.0.3.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>..\packages\System.ValueTuple.4.5.0\lib\net47\System.ValueTuple.dll</HintPath>
    </Reference>
    <Reference Include="System.Xml" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xaml">
      <RequiredTargetFramework>4.0</RequiredTargetFramework>
    </Reference>
    <Reference Include="TraceReloggerLib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>..\packages\Microsoft.Diagnostics.Tracing.TraceEvent.3.1.28\lib\netstandard2.0\TraceReloggerLib.dll</HintPath>
      <EmbedInteropTypes>True</EmbedInteropTypes>
    </Reference>
    <Reference Include="WindowsBase" />
    <Reference Include="PresentationCore" />
    <Reference Include="PresentationFramework" />
  </ItemGroup>
  <ItemGroup>
    <ApplicationDefinition Include="App.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </ApplicationDefinition>
    <Page Include="MainWindow.xaml">
      <Generator>MSBuild:Compile</Generator>
      <SubType>Designer</SubType>
    </Page>
    <Compile Include="App.xaml.cs">
      <DependentUpon>App.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="MainWindow.xaml.cs">
      <DependentUpon>MainWindow.xaml</DependentUpon>
      <SubType>Code</SubType>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Properties\AssemblyInfo.cs">
      <SubType>Code</SubType>
    </Compile>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <None Include="packages.config" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <Import Project="..\packages\Microsoft.Extensions.Logging.Abstractions.6.0.0\build\Microsoft.Extensions.Logging.Abstractions.targets" Condition="Exists('..\packages\Microsoft.Extensions.Logging.Abstractions.6.0.0\build\Microsoft.Extensions.Logging.Abstractions.targets')" />
  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>This project references NuGet package(s) that are missing on this computer. Use NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
    </PropertyGroup>
    <Error Condition="!Exists('..\packages\Microsoft.Extensions.Logging.Abstractions.6.0.0\build\Microsoft.Extensions.Logging.Abstractions.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Microsoft.Extensions.Logging.Abstractions.6.0.0\build\Microsoft.Extensions.Logging.Abstractions.targets'))" />
    <Error Condition="!Exists('..\packages\Microsoft.Diagnostics.Tracing.TraceEvent.3.1.28\build\Microsoft.Diagnostics.Tracing.TraceEvent.props')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Microsoft.Diagnostics.Tracing.TraceEvent.3.1.28\build\Microsoft.Diagnostics.Tracing.TraceEvent.props'))" />
  </Target>
</Project>
```

`Client/MainWindow.xaml`:

```xaml
<Window x:Class="Client.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Unkover Trace Viewer" Height="600" Width="800">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <!-- Controls row: align filter TextBox with second column (Message). -->
        <Grid Grid.Row="0" Margin="8">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="150"/>
                <ColumnDefinition Width="*"/>
            </Grid.ColumnDefinitions>

            <!-- Left: Show Logs checkbox -->
            <StackPanel Orientation="Horizontal" VerticalAlignment="Center" Grid.Column="0">
                <CheckBox x:Name="ShowLogsCheckBox"
                          Content="Show logs"
                          IsChecked="True"
                          Checked="ShowLogsCheckBox_Checked"
                          Unchecked="ShowLogsCheckBox_Unchecked"/>
            </StackPanel>

            <!-- Right: Filter textbox aligned with Message column -->
            <StackPanel Grid.Column="1" Orientation="Horizontal" VerticalAlignment="Center">
                <TextBlock Text="Filter:" Margin="0,0,8,0"/>
                <TextBox x:Name="FilterTextBox"
                         Width="300"
                         ToolTip="Type to filter Type/Message"
                         TextChanged="FilterTextBox_TextChanged"/>
            </StackPanel>
        </Grid>

        <DataGrid x:Name="TraceGrid"
                  Grid.Row="1"
                  AutoGenerateColumns="False"
                  IsReadOnly="True"
                  CanUserAddRows="False">
            <DataGrid.Columns>
                <DataGridTextColumn Header="Type" Binding="{Binding Type}" Width="150"/>
                <DataGridTextColumn Header="Message" Binding="{Binding Message}" Width="*"/>
                <DataGridTextColumn Header="Timestamp" Binding="{Binding Timestamp}" Width="180"/>
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</Window>

```

`Client/MainWindow.xaml.cs`:

```cs
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Data;
using Microsoft.Diagnostics.Tracing;
using Microsoft.Diagnostics.Tracing.Session;

namespace Client
{
    public partial class MainWindow : Window
    {
        private TraceEventSession _session;
        private ETWTraceEventSource _source;
        private readonly ObservableCollection<TraceItem> _items = new ObservableCollection<TraceItem>();
        private ICollectionView _view;

        public MainWindow()
        {
            InitializeComponent();

            TraceGrid.ItemsSource = _items;

            _view = CollectionViewSource.GetDefaultView(_items);
            _view.Filter = ApplyFilter;

            Loaded += MainWindow_Loaded;
            Closing += MainWindow_Closing;
        }

        private void MainWindow_Loaded(object sender, RoutedEventArgs e)
        {
            Task.Run(() => StartListening());
        }

        private void MainWindow_Closing(object sender, CancelEventArgs e)
        {
            try { _session?.Dispose(); } catch { }
            try { _source?.Dispose(); } catch { }
        }

        private bool ApplyFilter(object obj)
        {
            if (obj is TraceItem item)
            {
                // Hide LOG type when checkbox is unchecked
                if (ShowLogsCheckBox != null && ShowLogsCheckBox.IsChecked == false && string.Equals(item.Type, "LOG", StringComparison.OrdinalIgnoreCase))
                    return false;

                var filterText = FilterTextBox?.Text ?? string.Empty;
                if (string.IsNullOrWhiteSpace(filterText))
                    return true;

                var ft = filterText.Trim();
                var type = item.Type ?? string.Empty;
                var message = item.Message ?? string.Empty;

                return type.IndexOf(ft, StringComparison.OrdinalIgnoreCase) >= 0
                    || message.IndexOf(ft, StringComparison.OrdinalIgnoreCase) >= 0;
            }
            return true;
        }

        private void FilterTextBox_TextChanged(object sender, System.Windows.Controls.TextChangedEventArgs e)
        {
            // Refresh the view to re-apply the filter on text change
            _view?.Refresh();
        }

        private void ShowLogsCheckBox_Checked(object sender, RoutedEventArgs e)
        {
            // Show LOG entries when checkbox is checked
            _view?.Refresh();
        }

        private void ShowLogsCheckBox_Unchecked(object sender, RoutedEventArgs e)
        {
            // Hide LOG entries when checkbox is unchecked
            _view?.Refresh();
        }

        private void StartListening()
        {
            try
            {
                using (var session = new TraceEventSession("UnkoverClientSession"))
                {
                    _session = session;
                    _session.StopOnDispose = true;

                    session.EnableProvider(new Guid("95bc72d9-99bc-7317-12bc-dac4e219200c"));

                    using (var source = new ETWTraceEventSource("UnkoverClientSession", TraceEventSourceType.Session))
                    {
                        _source = source;

                        source.Dynamic.All += (TraceEvent data) =>
                        {
                            try
                            {
                                string type = null;
                                string message = null;
                                try { type = data.PayloadByName("Type") as string; } catch { }
                                try { message = data.PayloadByName("Message") as string; } catch { }

                                if (string.IsNullOrEmpty(type)) type = data.ProviderName ?? "unKover";
                                if (message == null) message = data.FormattedMessage ?? string.Empty;

                                var timestamp = data.TimeStamp.ToLocalTime();

                                Dispatcher.Invoke(() =>
                                {
                                    _items.Insert(0, new TraceItem { Type = type, Message = message, Timestamp = timestamp });
                                    //if (_items.Count > 2000) _items.RemoveAt(_items.Count - 1);
                                });
                            }
                            catch (Exception ex)
                            {
                                Dispatcher.Invoke(() => MessageBox.Show(this, ex.Message));
                            }
                        };

                        source.Process();
                    }
                }
            }
            catch (Exception ex)
            {
                Dispatcher.Invoke(() => MessageBox.Show(this, "Failed to start ETW session: " + ex.Message));
            }
        }
    }

    public class TraceItem
    {
        public string Type { get; set; }
        public string Message { get; set; }
        public DateTime Timestamp { get; set; }
    }
}

```

`Client/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Windows;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Client")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Client")]
[assembly: AssemblyCopyright("Copyright ©  2025")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

//In order to begin building localizable applications, set
//<UICulture>CultureYouAreCodingWith</UICulture> in your .csproj file
//inside a <PropertyGroup>.  For example, if you are using US english
//in your source files, set the <UICulture> to en-US.  Then uncomment
//the NeutralResourceLanguage attribute below.  Update the "en-US" in
//the line below to match the UICulture setting in the project file.

//[assembly: NeutralResourcesLanguage("en-US", UltimateResourceFallbackLocation.Satellite)]


[assembly: ThemeInfo(
    ResourceDictionaryLocation.None, //where theme specific resource dictionaries are located
                                     //(used if a resource is not found in the page,
                                     // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly //where the generic resource dictionary is located
                                              //(used if a resource is not found in the page,
                                              // app, or any theme specific resource dictionaries)
)]


// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`Client/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Client.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Client.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}

```

`Client/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`Client/Properties/Settings.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Client.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}

```

`Client/Properties/Settings.settings`:

```settings
<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="uri:settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>
```

`Client/packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Microsoft.Bcl.AsyncInterfaces" version="9.0.8" targetFramework="net472" />
  <package id="Microsoft.Diagnostics.NETCore.Client" version="0.2.510501" targetFramework="net472" />
  <package id="Microsoft.Diagnostics.Tracing.TraceEvent" version="3.1.28" targetFramework="net472" />
  <package id="Microsoft.Extensions.DependencyInjection" version="6.0.0" targetFramework="net472" />
  <package id="Microsoft.Extensions.DependencyInjection.Abstractions" version="6.0.0" targetFramework="net472" />
  <package id="Microsoft.Extensions.Logging" version="6.0.0" targetFramework="net472" />
  <package id="Microsoft.Extensions.Logging.Abstractions" version="6.0.0" targetFramework="net472" />
  <package id="Microsoft.Extensions.Options" version="6.0.0" targetFramework="net472" />
  <package id="Microsoft.Extensions.Primitives" version="6.0.0" targetFramework="net472" />
  <package id="Microsoft.Win32.Registry" version="5.0.0" targetFramework="net472" />
  <package id="System.Buffers" version="4.5.1" targetFramework="net472" />
  <package id="System.Collections.Immutable" version="9.0.8" targetFramework="net472" />
  <package id="System.Diagnostics.DiagnosticSource" version="6.0.0" targetFramework="net472" />
  <package id="System.IO.Pipelines" version="9.0.8" targetFramework="net472" />
  <package id="System.Memory" version="4.5.5" targetFramework="net472" />
  <package id="System.Numerics.Vectors" version="4.5.0" targetFramework="net472" />
  <package id="System.Reflection.Metadata" version="9.0.8" targetFramework="net472" />
  <package id="System.Reflection.TypeExtensions" version="4.7.0" targetFramework="net472" />
  <package id="System.Runtime.CompilerServices.Unsafe" version="6.1.2" targetFramework="net472" />
  <package id="System.Security.AccessControl" version="5.0.0" targetFramework="net472" />
  <package id="System.Security.Principal.Windows" version="5.0.0" targetFramework="net472" />
  <package id="System.Text.Encodings.Web" version="9.0.8" targetFramework="net472" />
  <package id="System.Text.Json" version="9.0.8" targetFramework="net472" />
  <package id="System.Threading.Tasks.Extensions" version="4.5.4" targetFramework="net472" />
  <package id="System.ValueTuple" version="4.5.0" targetFramework="net472" />
</packages>
```

`README.md`:

```md
# unKover

Windows anti-rootkit driver that can detect drivers mapped to kernel memory. Think [Moneta](https://github.com/forrest-orr/moneta), but for the kernel (obviously this is a simplified comparison). Additionally detects hidden threads as of the latest version.

The idea is to have a small & concise anti-rootkit to aid you (the rootkit dev) in honing your rootkits evasion abilities while also showcasing detection vectors with minimal FP rate that can detect many of the openly available driver mapper + rootkit combinations. 

For more information see the following blogposts:
* https://eversinc33.com/posts/anti-anti-rootkit-part-i.html
* https://eversinc33.com/posts/anti-anti-rootkit-part-ii.html

While some open source anti-cheats with capabilities far beyond this tool's exist (such as donnaskiez [ac](https://github.com/donnaskiez/ac)), I wanted something that I can easily tweak according to my needs. Maybe it will be useful for you too.

Techniques implemented:

* NMI Callbacks: Periodically sends Non-Maskable Interrupts (NMIs) to each core and analyzes the currently running thread's call stack for any pointers to unbacked memory.
* APC StackWalks: Same as the NMI check, but with an APC queued to each system thread.
* System thread analysis: Periodically check all system threads for start-addresses pointing to unbacked memory.
* Driver Object analysis: Periodically check all driver objects registered on the system, and check if their DriverEntry points to unbacked memory.
* .text section comparison: Periodically check drivers for .text section thats differ in-mem vs on-disk, to detect driver "stomping"
* Detecting threads removed from the `PspCidTable`
* Detecting hooked Major Function Handlers pointing to unbacked memory

<p align="center">
<img src="./img/gui.png" alt="unKover output"/>
</p>

## Installation

You need to enable testsigning to load the driver. I also recommend to enable debugging for the kernel.

Run the following from an administrative prompt and reboot afterwards:

```cmd
bcdedit /set testsigning on
bcdedit /debug on
```

Then you can load the driver with `sc.exe` or use OSR DriverLoader:

```cmd
sc.exe create Unkover binPath= "C:\path\to\Unkover.sys" type= kernel start= demand
sc.exe start Unkover
```

Afterwards, you can start the Client to view the logs.

### Credits

* DeviceObject scanning code partly taken from https://github.com/not-wlan/driver-hijack


```

`Unkover.inf`:

```inf
;
; Unkover.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=
CatalogFile=Unkover.cat
PnpLockdown=1

;This template is supported for OS version 17763 (Windows 10 version 1809) and after.
;For Windows OS prior to Windows 10 1809 set DefaultDestDir = 12
[DestinationDirs]
DefaultDestDir = 13


[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]


[Manufacturer]

[Strings]
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
DiskName="Unkover Source Disk"

```

`Unkover.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.7.34031.279
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Unkover", "Unkover.vcxproj", "{CA2BD34A-0096-4A66-B78E-8645283F2CF4}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Client", "Client\Client.csproj", "{3ED9B299-9FD8-4215-B269-479EC0221F60}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Release|Any CPU = Release|Any CPU
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{CA2BD34A-0096-4A66-B78E-8645283F2CF4}.Debug|Any CPU.ActiveCfg = Debug|x64
		{CA2BD34A-0096-4A66-B78E-8645283F2CF4}.Debug|Any CPU.Build.0 = Debug|x64
		{CA2BD34A-0096-4A66-B78E-8645283F2CF4}.Debug|Any CPU.Deploy.0 = Debug|x64
		{CA2BD34A-0096-4A66-B78E-8645283F2CF4}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{CA2BD34A-0096-4A66-B78E-8645283F2CF4}.Debug|ARM64.Build.0 = Debug|ARM64
		{CA2BD34A-0096-4A66-B78E-8645283F2CF4}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{CA2BD34A-0096-4A66-B78E-8645283F2CF4}.Debug|x64.ActiveCfg = Debug|x64
		{CA2BD34A-0096-4A66-B78E-8645283F2CF4}.Debug|x64.Build.0 = Debug|x64
		{CA2BD34A-0096-4A66-B78E-8645283F2CF4}.Debug|x64.Deploy.0 = Debug|x64
		{CA2BD34A-0096-4A66-B78E-8645283F2CF4}.Release|Any CPU.ActiveCfg = Release|x64
		{CA2BD34A-0096-4A66-B78E-8645283F2CF4}.Release|Any CPU.Build.0 = Release|x64
		{CA2BD34A-0096-4A66-B78E-8645283F2CF4}.Release|Any CPU.Deploy.0 = Release|x64
		{CA2BD34A-0096-4A66-B78E-8645283F2CF4}.Release|ARM64.ActiveCfg = Release|ARM64
		{CA2BD34A-0096-4A66-B78E-8645283F2CF4}.Release|ARM64.Build.0 = Release|ARM64
		{CA2BD34A-0096-4A66-B78E-8645283F2CF4}.Release|ARM64.Deploy.0 = Release|ARM64
		{CA2BD34A-0096-4A66-B78E-8645283F2CF4}.Release|x64.ActiveCfg = Release|x64
		{CA2BD34A-0096-4A66-B78E-8645283F2CF4}.Release|x64.Build.0 = Release|x64
		{CA2BD34A-0096-4A66-B78E-8645283F2CF4}.Release|x64.Deploy.0 = Release|x64
		{3ED9B299-9FD8-4215-B269-479EC0221F60}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3ED9B299-9FD8-4215-B269-479EC0221F60}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3ED9B299-9FD8-4215-B269-479EC0221F60}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{3ED9B299-9FD8-4215-B269-479EC0221F60}.Debug|ARM64.Build.0 = Debug|Any CPU
		{3ED9B299-9FD8-4215-B269-479EC0221F60}.Debug|x64.ActiveCfg = Debug|Any CPU
		{3ED9B299-9FD8-4215-B269-479EC0221F60}.Debug|x64.Build.0 = Debug|Any CPU
		{3ED9B299-9FD8-4215-B269-479EC0221F60}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3ED9B299-9FD8-4215-B269-479EC0221F60}.Release|Any CPU.Build.0 = Release|Any CPU
		{3ED9B299-9FD8-4215-B269-479EC0221F60}.Release|ARM64.ActiveCfg = Release|Any CPU
		{3ED9B299-9FD8-4215-B269-479EC0221F60}.Release|ARM64.Build.0 = Release|Any CPU
		{3ED9B299-9FD8-4215-B269-479EC0221F60}.Release|x64.ActiveCfg = Release|Any CPU
		{3ED9B299-9FD8-4215-B269-479EC0221F60}.Release|x64.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {7D2F4B82-117C-4D89-8C66-30BD8AB2E52E}
	EndGlobalSection
EndGlobal

```

`Unkover.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{CA2BD34A-0096-4A66-B78E-8645283F2CF4}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>Unkover</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="Unkover.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="unKover\apc.cpp" />
    <ClCompile Include="unKover\deviceobjects.cpp" />
    <ClCompile Include="unKover\Driver.cpp" />
    <ClCompile Include="unKover\handlers.cpp" />
    <ClCompile Include="unKover\hiding.cpp" />
    <ClCompile Include="unKover\meta.cpp" />
    <ClCompile Include="unKover\nmi.cpp" />
    <ClCompile Include="unKover\sectioncompare.cpp" />
    <ClCompile Include="unKover\threads.cpp" />
    <ClCompile Include="unKover\tracing.cpp" />
    <ClCompile Include="unKover\utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="unKover\apc.h" />
    <ClInclude Include="unKover\deviceobjects.h" />
    <ClInclude Include="unKover\Driver.h" />
    <ClInclude Include="unKover\handlers.h" />
    <ClInclude Include="unKover\hiding.h" />
    <ClInclude Include="unKover\meta.h" />
    <ClInclude Include="unKover\nmi.h" />
    <ClInclude Include="unKover\sectioncompare.h" />
    <ClInclude Include="unKover\threads.h" />
    <ClInclude Include="unKover\utils.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="Unkover.vcxproj.new" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Unkover.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="Unkover.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="unKover\Driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="unKover\meta.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="unKover\nmi.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="unKover\threads.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="unKover\apc.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="unKover\deviceobjects.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="unKover\sectioncompare.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="unKover\hiding.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="unKover\utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="unKover\tracing.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="unKover\handlers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="unKover\utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="unKover\meta.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="unKover\nmi.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="unKover\threads.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="unKover\apc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="unKover\deviceobjects.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="unKover\sectioncompare.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="unKover\hiding.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="unKover\Driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="unKover\handlers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
    <None Include="Unkover.vcxproj.new" />
  </ItemGroup>
</Project>
```

`Unkover.vcxproj.new`:

```new
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{CA2BD34A-0096-4A66-B78E-8645283F2CF4}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>Unkover</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="Unkover.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>

  <!-- Sources -->
  <ItemGroup>
    <ClCompile Include="unKover\Driver.cpp" />
    <ClCompile Include="unKover\meta.cpp" />
    <ClCompile Include="unKover\nmi.cpp" />
    <ClCompile Include="unKover\threads.cpp" />
    <ClCompile Include="unKover\apc.cpp" />
    <ClCompile Include="unKover\deviceobjects.cpp" />
    <ClCompile Include="unKover\sectioncompare.cpp" />
    <ClCompile Include="unKover\hiding.cpp" />
  </ItemGroup>

  <!-- Headers -->
  <ItemGroup>
    <ClInclude Include="unKover\Driver.h" />
    <ClInclude Include="unKover\meta.h" />
    <ClInclude Include="unKover\nmi.h" />
    <ClInclude Include="unKover\threads.h" />
    <ClInclude Include="unKover\apc.h" />
    <ClInclude Include="unKover\deviceobjects.h" />
    <ClInclude Include="unKover\sectioncompare.h" />
    <ClInclude Include="unKover\hiding.h" />
    <ClInclude Include="unKover\utils.h" />
  </ItemGroup>

  <ItemGroup>
    <None Include="README.md" />
  </ItemGroup>

  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`unKover/Driver.cpp`:

```cpp
#include "Driver.h"
#include <ntifs.h>
#include <ntddk.h>

#include "meta.h"
#include "nmi.h"
#include "threads.h"
#include "apc.h"
#include "deviceobjects.h"
#include "sectioncompare.h"
#include "hiding.h"
#include "handlers.h"

//
// define handles
//
HANDLE g_hScanSystemThreads = NULL;
HANDLE g_hSendNmis = NULL;
HANDLE g_hCheckDriverObjects = NULL;
HANDLE g_hAPCCheck = NULL;
HANDLE g_hTextSectionCompare = NULL;
HANDLE g_hHidingDetection = NULL;
HANDLE g_hCheckHandlers = NULL;

/**
 * @brief Waits for a worker thread to signal completion and closes its handle.
 *
 * @param[IN] pThreadHandle    Pointer to thread handle to close.
 * @param[IN] pFinishedEvent   Event signaled by the worker thread.
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
static VOID
UkShutdownThread(
    PHANDLE pThreadHandle,
    PKEVENT pFinishedEvent
)
{
    KeWaitForSingleObject(pFinishedEvent, Executive, KernelMode, FALSE, NULL);
    if (pThreadHandle)
    {
        ZwClose(*pThreadHandle);
        *pThreadHandle = NULL;
    }
}

/**
 * @brief Driver unload routine.
 *
 * @param[IN] drvObj Driver object.
 */
_Function_class_(DRIVER_UNLOAD)
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
VOID
DriverUnload(
    PDRIVER_OBJECT drvObj
)
{
	UNREFERENCED_PARAMETER(drvObj);

    //
    // Unload sequence
    //
    LOG_DBG("Unload called\n");
    LOG_DBG("Stopping all threads. This can a few seconds...\n");

    g_doAPCStackWalk = FALSE;
    g_sendNmis = FALSE;
    g_scanSystemThreads = FALSE;
    g_scanDriverObjects = FALSE;
    g_compareTextSections = FALSE;
    g_hidingDetection = FALSE;
	g_checkHandlers = FALSE;

    //
    // Unregister TraceLogging provider on unload
    //
    TraceLoggingUnregister(g_hTraceProvider);

    UkShutdownThread(&g_hAPCCheck, &g_apcFinishedEvent);
    UkShutdownThread(&g_hSendNmis, &g_sendNmisFinishedEvent);
    UkShutdownThread(&g_hScanSystemThreads, &g_scanSystemThreadsFinishedEvent);
    UkShutdownThread(&g_hCheckDriverObjects, &g_scanDriverObjectsFinishedEvent);
    UkShutdownThread(&g_hTextSectionCompare, &g_compareTextSectionsFinishedEvent);
    UkShutdownThread(&g_hHidingDetection, &g_hidingDetectionFinishedEvent);
    UkShutdownThread(&g_hCheckHandlers, &g_checkHandlersFinishedEvent);
    
    //
    // Wait 3 seconds for termination
    //
    UkSleepMs(3000);

    //
    // Unload NMI module
    //
    UkUnloadNMI();
}

/**
 * @brief Driver entry routine.
 *
 * @param[IN] drvObj   Driver object provided by the system.
 * @param[IN] regPath  Registry path.
 *
 * @return NTSTATUS code.
 */
EXTERN_C
_Function_class_(DRIVER_INITIALIZE)
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS 
DriverEntry(
    PDRIVER_OBJECT drvObj,
    PUNICODE_STRING regPath
)
{
    UNREFERENCED_PARAMETER(regPath);

    LOG_DBG("unKover driver entry\n");

    g_drvObj = drvObj;
    drvObj->DriverUnload = DriverUnload;

    NTSTATUS NtStatus = STATUS_SUCCESS;

    if (!UkRegisterNmiCallbacks())
    {
        UkUnloadNMI();
        return STATUS_FAILED_DRIVER_ENTRY;
    }

    //
    // Register TraceLogging provider
    //
    TraceLoggingRegister(g_hTraceProvider);

    //
    // Start monitoring threads
    //
    UkTraceEtw("LOG", "Creating thread to scan system threads");
    NtStatus = PsCreateSystemThread(&g_hScanSystemThreads, THREAD_ALL_ACCESS, NULL, NULL, NULL, UkScanSystemThreads, NULL);
    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    UkTraceEtw("LOG", "Creating thread to send NMIs and analyze call stacks");
    NtStatus = PsCreateSystemThread(&g_hSendNmis, THREAD_ALL_ACCESS, NULL, NULL, NULL, UkSendNMI, NULL);
    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    UkTraceEtw("LOG", "Creating thread to check DriverObjects in object manager");
    NtStatus = PsCreateSystemThread(&g_hCheckDriverObjects, THREAD_ALL_ACCESS, NULL, NULL, NULL, UkCheckDriverObjects, NULL);
    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    UkTraceEtw("LOG", "Creating thread to check call stacks via APC");
    NtStatus = PsCreateSystemThread(&g_hAPCCheck, THREAD_ALL_ACCESS, NULL, NULL, NULL, UkAPCStackWalk, NULL);
    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    UkTraceEtw("LOG", "Creating thread to compare driver .text sections");
    NtStatus = PsCreateSystemThread(&g_hTextSectionCompare, THREAD_ALL_ACCESS, NULL, NULL, NULL, UkCompareTextSections, NULL);
    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    UkTraceEtw("LOG", "Creating thread to detect threads hidden from PspCidTable");
    NtStatus = PsCreateSystemThread(&g_hHidingDetection, THREAD_ALL_ACCESS, NULL, NULL, NULL, UkDetectHiddenThreads, NULL);
    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    UkTraceEtw("LOG", "Creating thread to check driver IOCTL handlers for hooks");
	NtStatus = PsCreateSystemThread(&g_hCheckHandlers, THREAD_ALL_ACCESS, NULL, NULL, NULL, UkCheckHandlers, NULL);
    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

	UkTraceEtw("LOG", "Driver initialized successfully");

    //
    // TODO: check physmem handles, hal pointers, more
    //  

    return NtStatus;
}

```

`unKover/Driver.h`:

```h
#pragma once

#include <ntifs.h>
#include <ntddk.h>

#ifdef __cplusplus
extern "C" {
#endif

/* thread handles started by DriverEntry */
extern HANDLE g_hScanSystemThreads;
extern HANDLE g_hSendNmis;
extern HANDLE g_hCheckDriverObjects;
extern HANDLE g_hAPCCheck;
extern HANDLE g_hTextSectionCompare;
extern HANDLE g_hHidingDetection;

NTSTATUS DriverEntry(PDRIVER_OBJECT drvObj, PUNICODE_STRING regPath);
VOID DriverUnload(PDRIVER_OBJECT drvObj);

#ifdef __cplusplus
}
#endif

```

`unKover/apc.cpp`:

```cpp
#include "apc.h"
#include "meta.h"

/**
 * @brief Normal APC routine; no operation.
 *
 * @param[IN] NormalContext   Optional normal context.
 * @param[IN] SystemArgument1 Optional system argument.
 * @param[IN] SystemArgument2 Optional system argument.
 */
_IRQL_requires_same_
_IRQL_requires_(APC_LEVEL)
VOID
UkNormalAPC(
    _In_opt_ PVOID NormalContext,
    _In_opt_ PVOID SystemArgument1,
    _In_opt_ PVOID SystemArgument2
)
{
    UNREFERENCED_PARAMETER(NormalContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);
}

/**
 * @brief APC rundown routine; releases APC object.
 *
 * @param[IN] Apc APC object to free.
 */
_IRQL_requires_same_
_IRQL_requires_(APC_LEVEL)
VOID
UkRundownAPC(
    _In_ PRKAPC Apc
)
{
    ExFreePoolWithTag(Apc, POOL_TAG);
}

/**
 * @brief Kernel APC routine that captures and analyzes the current thread's stack.
 *
 * @param[IN] Apc             APC object.
 * @param[OUT] NormalRoutine  Receives normal routine pointer.
 * @param[OUT] NormalContext  Receives normal context pointer.
 * @param[OUT] SystemArgument1 Receives system argument pointer.
 * @param[OUT] SystemArgument2 Receives system argument pointer.
 */
_IRQL_requires_same_
_IRQL_requires_(APC_LEVEL)
VOID 
UkCaptureStackAPC(
    IN PKAPC Apc,
    IN OUT PKNORMAL_ROUTINE* NormalRoutine,
    IN OUT PVOID* NormalContext,
    IN OUT PVOID* SystemArgument1,
    IN OUT PVOID* SystemArgument2
)
{
    UNREFERENCED_PARAMETER(Apc);
    UNREFERENCED_PARAMETER(NormalRoutine);
    UNREFERENCED_PARAMETER(NormalContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    PVOID* stackFrames = (PVOID*)ExAllocatePoolWithTag(NonPagedPoolNx, MAX_STACK_DEPTH * sizeof(PVOID), POOL_TAG);
    if (!stackFrames)
    {
        //
        // Signal that APC is done
        //
        ExFreePoolWithTag(Apc, POOL_TAG);
        KeSetEvent(&g_kernelApcSyncEvent, 0, FALSE);
        return;
    }

    RtlSecureZeroMemory(stackFrames, MAX_STACK_DEPTH * sizeof(PVOID));
    HANDLE threadId = PsGetCurrentThreadId();
    USHORT framesCaptured = RtlCaptureStackBackTrace(0, MAX_STACK_DEPTH, stackFrames, NULL);

    //
    // Stack trace analysis
    //
    for (auto i = 0; i < framesCaptured; ++i)
    {
        //
        // Check if address of frame is from unbacked memory
        //
        ULONG_PTR addr = (ULONG_PTR)stackFrames[i];
        if (UkGetDriverForAddress(addr) == NULL)
        {
            UkTraceEtw("APCStackWalk", "Detected stack frame pointing to unbacked region: TID: %lu @ 0x%llx", HandleToUlong(threadId), addr);
            
            //
            // Print stack frame TODO: clean this code
            //
            for (auto j = 0; j < framesCaptured; ++j)
            {
                ULONG_PTR address = (ULONG_PTR)stackFrames[j];
                PKLDR_DATA_TABLE_ENTRY driver = UkGetDriverForAddress(address);
                if (driver == NULL) 
                { 
                    UkTraceEtw("APCStackWalk", "  [%d] Stack frame %lu: 0x%llx // %ws", HandleToUlong(threadId), j, address, L"??? <------ Unbacked!"); 
                }
                else 
                {
                    auto offsetToFunction = (driver == NULL) ? address : (address - (ULONG_PTR)driver->DllBase);
                    PWCHAR driverName = driver->BaseDllName.Buffer;
                    UkTraceEtw("APCStackWalk", "  [%d] Stack frame %lu: 0x%llx+0x%llx // %ws", HandleToUlong(threadId), j, (ULONG_PTR)driver->DllBase, offsetToFunction, driverName);
                }
            }
        }
    }

    if (stackFrames) { ExFreePoolWithTag(stackFrames, POOL_TAG); }

    //
    // Signal that APC is done
    //
    ExFreePoolWithTag(Apc, POOL_TAG);
    KeSetEvent(&g_kernelApcSyncEvent, 0, FALSE);
}

/**
 * @brief Worker function that periodically queues kernel APCs to system threads to analyze stacks.
 *
 * @param[IN] StartContext Optional start context.
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
VOID
UkAPCStackWalk(
    IN PVOID StartContext
)
{
    UNREFERENCED_PARAMETER(StartContext);

    NTSTATUS NtStatus;

    KeInitializeEvent(&g_apcFinishedEvent, SynchronizationEvent, FALSE);
    KeInitializeEvent(&g_kernelApcSyncEvent, NotificationEvent, FALSE);

    do
    {
        LOG_DBG("Scanning running system thread call stacks via APC...\n");

        //
        // Queue APCs to system threads. TIDs are a multiple of 4. TODO: max number?
        //
        for (auto tid = 4; tid < 0xFFFF; tid += 4)
        {
            PETHREAD ThreadObj;
            PKAPC apc;

            //
            // Get ETHREAD object for TID
            //
            if (!NT_SUCCESS(PsLookupThreadByThreadId(UlongToHandle(tid), &ThreadObj)))
            {
                continue;
            }

            //
            // Ignore current thread and non system threads
            //
            if (!PsIsSystemThread(ThreadObj) || ThreadObj == (PETHREAD)KeGetCurrentThread())
            {
                ObDereferenceObject(ThreadObj);
                continue;
            }

            //
            // Initialize APC
            //
            apc = (PKAPC)ExAllocatePoolWithTag(
                NonPagedPool,
                sizeof(KAPC),
                POOL_TAG
            );
            KeInitializeApc(apc,
                (PKTHREAD)ThreadObj,
                OriginalApcEnvironment,
                UkCaptureStackAPC,
                UkRundownAPC,
                UkNormalAPC,
                KernelMode,
                NULL
            );

            //
            // Queue APC
            //
            NtStatus = KeInsertQueueApc(apc, NULL, NULL, IO_NO_INCREMENT);
            if (!NT_SUCCESS(NtStatus))
            {
                LOG_DBG("KeInsertQueueApc failed\n");
                KeSetEvent(&g_kernelApcSyncEvent, 0, FALSE);
                KeSetEvent(&g_rundownApcSyncEvent, 0, FALSE);
            }

            //
            // Wait for event to signal that the apc is done before queueing the next one
            //
            UkSleepMs(50);
            LARGE_INTEGER timeout;
            timeout.QuadPart = 5000;
            NtStatus = KeWaitForSingleObject(&g_kernelApcSyncEvent, Executive, KernelMode, FALSE, &timeout);
            if (NtStatus == STATUS_TIMEOUT)
            {
                LOG_DBG("APC did not return before timeout (tid: %u)\n", tid);
            }
            KeResetEvent(&g_kernelApcSyncEvent);

            //
            // Clean up
            //
            if (ThreadObj) { ObDereferenceObject(ThreadObj); }
        }

        UkSleepMs(5000);

    } while (g_doAPCStackWalk);

    KeSetEvent(&g_apcFinishedEvent, 0, TRUE);
    PsTerminateSystemThread(STATUS_SUCCESS);
}

```

`unKover/apc.h`:

```h
#pragma once

#include <ntifs.h>
#include <ntddk.h>

#include "utils.h"

#ifdef __cplusplus
extern "C" {
#endif

VOID
UkAPCStackWalk(
    IN PVOID StartContext
);

typedef enum _KAPC_ENVIRONMENT {
    OriginalApcEnvironment,
    AttachedApcEnvironment,
    CurrentApcEnvironment,
    InsertApcEnvironment
} KAPC_ENVIRONMENT;

typedef VOID(*PKNORMAL_ROUTINE)(
    _In_ PVOID NormalContext,
    _In_ PVOID SystemArgument1,
    _In_ PVOID SystemArgument2
);

typedef VOID(*PKKERNEL_ROUTINE) (
    IN PKAPC Apc,
    IN OUT PKNORMAL_ROUTINE* NormalRoutine,
    IN OUT PVOID* NormalContext,
    IN OUT PVOID* SystemArgument1,
    IN OUT PVOID* SystemArgument2
);

typedef VOID(*PKRUNDOWN_ROUTINE) (
    IN  PKAPC Apc
);

EXTERN_C VOID
KeInitializeApc(
    IN  PKAPC Apc,
    IN  PKTHREAD Thread,
    IN  KAPC_ENVIRONMENT Environment,
    IN  PKKERNEL_ROUTINE KernelRoutine,
    IN  PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,
    IN  PKNORMAL_ROUTINE NormalRoutine OPTIONAL,
    IN  KPROCESSOR_MODE ApcMode OPTIONAL,
    IN  PVOID NormalContext OPTIONAL
);

EXTERN_C BOOLEAN
KeInsertQueueApc(
    IN  PKAPC Apc,
    IN  PVOID SystemArgument1,
    IN  PVOID SystemArgument2,
    IN  KPRIORITY Increment
);


extern BOOLEAN g_doAPCStackWalk;
extern KEVENT g_kernelApcSyncEvent;
extern KEVENT g_rundownApcSyncEvent;
extern KEVENT g_apcFinishedEvent;

#define MAX_STACK_DEPTH 32

#ifdef __cplusplus
}
#endif

```

`unKover/deviceobjects.cpp`:

```cpp
#include "deviceobjects.h"

BOOLEAN g_scanDriverObjects = TRUE;
KEVENT g_scanDriverObjectsFinishedEvent;
ULONG_PTR g_hashBucketLock = NULL;

/**
 * @brief Scan driver objects in object manager and report suspicious pointers.
 *
 * @param[IN] StartContext Optional start context.
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
VOID 
UkCheckDriverObjects(
    _In_ PVOID StartContext
)
{
    UNREFERENCED_PARAMETER(StartContext);

    KeInitializeEvent(&g_scanDriverObjectsFinishedEvent, SynchronizationEvent, FALSE);

    NTSTATUS status;
    PVOID directory;
    HANDLE handle;
    OBJECT_ATTRIBUTES attributes;
    UNICODE_STRING directoryName = RTL_CONSTANT_STRING(L"\\Driver");

    //
    // Get Handle to \\Driver directory
    //
    InitializeObjectAttributes(&attributes, &directoryName, OBJ_CASE_INSENSITIVE, NULL, NULL);
    status = ZwOpenDirectoryObject(&handle, DIRECTORY_ALL_ACCESS, &attributes);
    if (!NT_SUCCESS(status))
    {
        LOG_DBG("Couldnt get \\Driver directory handle\n");
        return;
    }

    status = ObReferenceObjectByHandle(handle, DIRECTORY_ALL_ACCESS, nullptr, KernelMode, &directory, nullptr);
    if (!NT_SUCCESS(status))
    {
        ZwClose(handle);
        LOG_DBG("Couldnt get \\Driver directory object from handle\n");
        return;
    }

    POBJECT_DIRECTORY directoryObject = (POBJECT_DIRECTORY)directory;
    g_hashBucketLock = directoryObject->Lock;

    do
    {
        UkTraceEtw("DeviceObjectScanner", "Scanning DriverObjects...");

        //
        // Lock for the hashbucket
        //
        KeEnterCriticalRegion(); 
        ExAcquirePushLockExclusiveEx((PEX_PUSH_LOCK)&g_hashBucketLock, 0);

        for (size_t i = 0; i < 37; ++i)
        {
            POBJECT_DIRECTORY_ENTRY entry = directoryObject->HashBuckets[i];
            if (!entry)
            {
                continue;
            }

            while (entry != nullptr && entry->Object)
            {
                PDRIVER_OBJECT driver = (PDRIVER_OBJECT)entry->Object;

                //
                // Check memory of DriverStart
                //
                if (UkGetDriverForAddress((ULONG_PTR)driver->DriverStart) == NULL)
                {
                    UkTraceEtw("DeviceObjectScanner", "Detected DriverObject.DriverStart pointing to unbacked or invalid region %ws @ 0x%llx",
                        driver->DriverName.Buffer,
                        (ULONG_PTR)driver->DriverStart
                    );
                }
                if (UkGetDriverForAddress((ULONG_PTR)driver->DriverInit) == NULL)
                {
                    UkTraceEtw("DeviceObjectScanner", "Detected DriverEntry pointing to unbacked region %ws @ 0x%llx",
                        driver->DriverName.Buffer,
                        (ULONG_PTR)driver->DriverInit
                    );
                }

                entry = entry->ChainLink;
            }
        }

        ExReleasePushLockExclusiveEx((PEX_PUSH_LOCK)&g_hashBucketLock, 0);
        KeLeaveCriticalRegion();

        UkSleepMs(5000);

    } while (g_scanDriverObjects);

    ObDereferenceObject(directory);
    ZwClose(handle);    

    KeSetEvent(&g_scanDriverObjectsFinishedEvent, 0, TRUE);

    PsTerminateSystemThread(STATUS_SUCCESS);
}

```

`unKover/deviceobjects.h`:

```h
#pragma once

#include <ntifs.h>
#include <ntddk.h>
#include "meta.h"
#include "utils.h"

#ifdef __cplusplus
extern "C" {
#endif

EXTERN_C NTSTATUS ZwQueryDirectoryObject(
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG BufferLength,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT PULONG Context,
    OUT PULONG ReturnLength OPTIONAL
);

EXTERN_C NTSTATUS ObReferenceObjectByName(
    IN PUNICODE_STRING ObjectPath,
    IN ULONG Attributes,
    IN PACCESS_STATE PassedAccessState,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_TYPE ObjectType,
    IN KPROCESSOR_MODE AccessMode,
    IN OUT PVOID ParseContext,
    OUT PVOID* ObjectPtr
);

typedef struct _OBJECT_TYPE_INITIALIZER
{
    USHORT Length;
    UCHAR ObjectTypeFlags;
    ULONG CaseInsensitive : 1;
    ULONG UnnamedObjectsOnly : 1;
    ULONG UseDefaultObject : 1;
    ULONG SecurityRequired : 1;
    ULONG MaintainHandleCount : 1;
    ULONG MaintainTypeList : 1;
    ULONG ObjectTypeCode;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    POOL_TYPE PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
    PVOID DumpProcedure;
    LONG* OpenProcedure;
    PVOID CloseProcedure;
    PVOID DeleteProcedure;
    LONG* ParseProcedure;
    LONG* SecurityProcedure;
    LONG* QueryNameProcedure;
    UCHAR* OkayToCloseProcedure;
} OBJECT_TYPE_INITIALIZER, * POBJECT_TYPE_INITIALIZER;

typedef struct _OBJECT_TYPE
{
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER TypeInfo;
    EX_PUSH_LOCK TypeLock;
    ULONG Key;
    LIST_ENTRY CallbackList;
} OBJECT_TYPE, * POBJECT_TYPE;

typedef struct _DEVICE_MAP* PDEVICE_MAP;

typedef struct _OBJECT_DIRECTORY_ENTRY
{
    struct _OBJECT_DIRECTORY_ENTRY* ChainLink;
    PVOID Object;
    ULONG HashValue;
} OBJECT_DIRECTORY_ENTRY, * POBJECT_DIRECTORY_ENTRY;

typedef struct _OBJECT_DIRECTORY
{
    POBJECT_DIRECTORY_ENTRY HashBuckets[37];
    EX_PUSH_LOCK Lock;
    PDEVICE_MAP DeviceMap;
    ULONG SessionId;
    PVOID NamespaceEntry;
    ULONG Flags;
} OBJECT_DIRECTORY, * POBJECT_DIRECTORY;

VOID UkCheckDriverObjects(IN PVOID StartContext);

/* globals */
extern BOOLEAN g_scanDriverObjects;
extern KEVENT g_scanDriverObjectsFinishedEvent;
extern ULONG_PTR g_hashBucketLock;

#ifdef __cplusplus
}
#endif

```

`unKover/handlers.cpp`:

```cpp
#include "handlers.h"
#include "utils.h"
#include "deviceobjects.h"

BOOLEAN g_checkHandlers = TRUE;
KEVENT g_checkHandlersFinishedEvent;

extern POBJECT_TYPE* IoDeviceObjectType;

/**
 * @brief Checks for hooked IOCTL handlers in the driver object of each driver.
 *
 * @param[IN] StartContext Context parameter (unused).
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
VOID
UkCheckHandlers(
    _In_ PVOID StartContext
)
{
    UNREFERENCED_PARAMETER(StartContext);

    KeInitializeEvent(&g_checkHandlersFinishedEvent, SynchronizationEvent, FALSE);

    NTSTATUS status;
    PVOID directory = nullptr;
    HANDLE handle = nullptr;
    OBJECT_ATTRIBUTES attributes;
    UNICODE_STRING directoryName = RTL_CONSTANT_STRING(L"\\Driver");

    //
    // Get Handle to \\Driver directory
    //
    InitializeObjectAttributes(&attributes, &directoryName, OBJ_CASE_INSENSITIVE, NULL, NULL);
    status = ZwOpenDirectoryObject(&handle, DIRECTORY_ALL_ACCESS, &attributes);
    if (!NT_SUCCESS(status))
    {
        LOG_DBG("Couldnt get \\Driver directory handle\n");
        KeSetEvent(&g_checkHandlersFinishedEvent, IO_NO_INCREMENT, FALSE);
        PsTerminateSystemThread(status);
        return;
    }

    status = ObReferenceObjectByHandle(handle, DIRECTORY_ALL_ACCESS, nullptr, KernelMode, &directory, nullptr);
    if (!NT_SUCCESS(status))
    {
        LOG_DBG("Couldnt get \\Driver directory object from handle\n");
        ZwClose(handle);
        KeSetEvent(&g_checkHandlersFinishedEvent, IO_NO_INCREMENT, FALSE);
        PsTerminateSystemThread(status);
        return;
    }

    POBJECT_DIRECTORY directoryObject = (POBJECT_DIRECTORY)directory;

    do
    {
        UkTraceEtw("HandlerChecker", "Scanning DriverObjects...");

        KeEnterCriticalRegion();
        ExAcquirePushLockExclusiveEx((PEX_PUSH_LOCK)&directoryObject->Lock, 0);

        for (size_t i = 0; i < 37; ++i)
        {
            POBJECT_DIRECTORY_ENTRY entry = directoryObject->HashBuckets[i];
            if (!entry)
                continue;

            while (entry != nullptr && entry->Object)
            {
                PDRIVER_OBJECT driver = (PDRIVER_OBJECT)entry->Object;

                if (!driver)
                {
                    entry = entry->ChainLink;
                    continue;
                }

                for (INT j = 0; j < IRP_MJ_MAXIMUM_FUNCTION; ++j)
                {
                    const ULONG_PTR handlerAddress = (ULONG_PTR)driver->MajorFunction[j];
                    if (!handlerAddress)
                        continue;

                    PKLDR_DATA_TABLE_ENTRY handlerEntry = UkGetDriverForAddress(handlerAddress);
                    if (!handlerEntry)
                    {
                        UkTraceEtw("HandlerChecker",
                            "Driver %wZ has hooked MajorFunction[%d] at address 0x%p",
                            driver->DriverName,
                            j,
                            (PVOID)handlerAddress
                        );
                    }
                }

                entry = entry->ChainLink;
            }
        }

        ExReleasePushLockExclusiveEx((PEX_PUSH_LOCK)&directoryObject->Lock, 0);
        KeLeaveCriticalRegion();

        UkSleepMs(5000);

    } while (g_checkHandlers);

    // 
    // Cleanup object references before signaling completion
    //
    ObDereferenceObject(directory);
    ZwClose(handle);

    KeSetEvent(&g_checkHandlersFinishedEvent, IO_NO_INCREMENT, FALSE);
    PsTerminateSystemThread(STATUS_SUCCESS);
}
```

`unKover/handlers.h`:

```h
#pragma once

#include <ntifs.h>
#include <ntddk.h>
#include "utils.h"

#ifdef __cplusplus
extern "C" {
#endif

_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
VOID
UkCheckHandlers(
    _In_ PVOID StartContext
);

/* globals */
extern BOOLEAN g_checkHandlers;
extern KEVENT g_checkHandlersFinishedEvent;

#ifdef __cplusplus
}
#endif

```

`unKover/hiding.cpp`:

```cpp
#include "hiding.h"
#include "meta.h"

BOOLEAN g_hidingDetection = TRUE;
KEVENT g_hidingDetectionFinishedEvent;

/**
 * @brief Returns the offset of ETHREAD::ThreadListEntry for the given Windows build.
 *
 * @param[IN] buildNumber Windows build number from RtlGetVersion.
 *
 * @return Offset in bytes.
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
ULONG 
UkGetThreadListEntryOffset(
	_In_ ULONG buildNumber
)
{
	ULONG threadListEntry = 0UL;

	switch (buildNumber) 
	{
	case WIN_1507:
	case WIN_1511:
		threadListEntry = 0x690;
		break;
	case WIN_1607:
		threadListEntry = 0x698;
		break;
	case WIN_1703:
		threadListEntry = 0x6a0;
		break;
	case WIN_1709:
	case WIN_1803:
	case WIN_1809:
		threadListEntry = 0x6a8;
		break;
	case WIN_1903:
	case WIN_1909:
		threadListEntry = 0x6b8;
		break;
	case WIN_2004:
	case WIN_20H2:
	case WIN_21H1:
	case WIN_21H2:
	case WIN_22H2:
		threadListEntry = 0x4e8;
		break;
	case WIN_11_24H2:
		threadListEntry = 0x578;
		break;
	default:
		threadListEntry = 0x538;
		break;
	}

	return threadListEntry;
}

/**
 * @brief Walks the system process ETHREAD list and reports hidden threads.
 *
 * @return STATUS_SUCCESS.
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS 
UkWalkSystemProcessThreads()
{
	auto currentThread = (PETHREAD)KeGetCurrentThread();
	
	//
	// Get windows build number to get correct offset
	//
	RTL_OSVERSIONINFOW osInfo = { 0 };
	osInfo.dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOW);
	RtlGetVersion(&osInfo);

    auto threadListEntry = (PLIST_ENTRY)((ULONG_PTR)currentThread + UkGetThreadListEntryOffset(osInfo.dwBuildNumber));
    auto listEntry = threadListEntry;

    while ((listEntry = listEntry->Flink) != threadListEntry)
    {
        auto entry = (PETHREAD)((ULONG_PTR)listEntry - UkGetThreadListEntryOffset(osInfo.dwBuildNumber));
        auto threadId = (ULONG)PsGetThreadId((PETHREAD)entry);

        if (threadId != 0)
        {
            PETHREAD pThread = NULL;
            NTSTATUS status = PsLookupThreadByThreadId(ULongToHandle(threadId), &pThread);

            if (!NT_SUCCESS(status))
            {
                UkTraceEtw("PspCidTableScanner", "Found hidden thread: PID: 0x%llx", threadId);
            }
            else
            {
                ObDereferenceObject(pThread);
            }
        }
    }

    return STATUS_SUCCESS;
}

/**
 * @brief Periodically detects threads hidden from PspCidTable.
 *
 * @param[IN] StartContext Optional start context.
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
VOID
UkDetectHiddenThreads(
    _In_ PVOID StartContext
)
{
    UNREFERENCED_PARAMETER(StartContext);

    KeInitializeEvent(&g_hidingDetectionFinishedEvent, SynchronizationEvent, FALSE);

    do
    {
        UkTraceEtw("PspCidTableScanner", "Starting to look for hidden threads");
        UkWalkSystemProcessThreads();
        UkSleepMs(3000);

    } while (g_hidingDetection);

    KeSetEvent(&g_hidingDetectionFinishedEvent, 0, TRUE);
    PsTerminateSystemThread(STATUS_SUCCESS);
}

```

`unKover/hiding.h`:

```h
#pragma once

#include <ntifs.h>
#include <ntddk.h>
#include "utils.h"

#ifdef __cplusplus
extern "C" {
#endif

ULONG
UkGetThreadListEntryOffset(
    ULONG buildNumber
);

NTSTATUS
UkWalkSystemProcessThreads(
    VOID
);

VOID
UkDetectHiddenThreads(
    IN PVOID StartContext
);

/* globals */
extern BOOLEAN g_hidingDetection;
extern KEVENT g_hidingDetectionFinishedEvent;

#ifdef __cplusplus
}
#endif

```

`unKover/meta.cpp`:

```cpp
#include "meta.h"

/**
 * @brief Global driver object pointer defined for cross-module access.
 */
PDRIVER_OBJECT g_drvObj = NULL;

```

`unKover/meta.h`:

```h
#pragma once

#include <ntifs.h>
#include <ntddk.h>
#include <TraceLoggingProvider.h>

//
// Pool tag and logging macros
//
#define POOL_TAG 'rvkU'
#define DRIVER_LOG_PREFIX "[unKover] :: "
#define DRIVER_DBG_PREFIX "          :: "
#define LOG_DBG(x, ...) DbgPrint((DRIVER_DBG_PREFIX x), __VA_ARGS__)

//
// Windows build numbers
//
constexpr ULONG64 WIN_1507 = 10240;
constexpr ULONG64 WIN_1511 = 10586;
constexpr ULONG64 WIN_1607 = 14393;
constexpr ULONG64 WIN_1703 = 15063;
constexpr ULONG64 WIN_1709 = 16299;
constexpr ULONG64 WIN_1803 = 17134;
constexpr ULONG64 WIN_1809 = 17763;
constexpr ULONG64 WIN_1903 = 18362;
constexpr ULONG64 WIN_1909 = 18363;
constexpr ULONG64 WIN_2004 = 19041;
constexpr ULONG64 WIN_20H2 = 19042;
constexpr ULONG64 WIN_21H1 = 19043;
constexpr ULONG64 WIN_21H2 = 19044;
constexpr ULONG64 WIN_22H2 = 19045;
constexpr ULONG64 WIN_11_21H2 = 22000;
constexpr ULONG64 WIN_11_22H2 = 22621;
constexpr ULONG64 WIN_11_23H2 = 22631;
constexpr ULONG64 WIN_11_24H2 = 26100;

//
// Declare TraceLogging provider handle for other translation units
//
TRACELOGGING_DECLARE_PROVIDER(g_hTraceProvider);

#ifdef __cplusplus
extern "C" {
#endif

//
// Global driver object pointer.
//
extern PDRIVER_OBJECT g_drvObj;


void
UkTraceEtw(
    _In_ PCSTR Type,
    _In_ PCSTR Format,
    ...
);

#ifdef __cplusplus
}
#endif

```

`unKover/nmi.cpp`:

```cpp
#include "nmi.h"
#include "utils.h"

EXTERN_C VOID KeInitializeAffinityEx(PKAFFINITY_EX affinity);
EXTERN_C VOID KeAddProcessorAffinityEx(PKAFFINITY_EX affinity, INT num);
EXTERN_C VOID HalSendNMI(PKAFFINITY_EX affinity);

ULONG g_numCores = 0;
PVOID g_NmiCallbackHandle = NULL;
PKAFFINITY_EX g_NmiAffinity = NULL;
PNMI_CONTEXT g_NmiContext = NULL;
HANDLE SendNMIThreadHandle = NULL;

BOOLEAN g_sendNmis = TRUE;
KEVENT g_sendNmisFinishedEvent;

/**
 * @brief NMI callback that captures minimal stack information per processor.
 *
 * @param[IN] context   Per-processor NMI_CONTEXT array.
 * @param[IN] handled   Whether NMI was handled (unused).
 *
 * @return TRUE always.
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
BOOLEAN 
UkNmiCallback(
    _In_ PVOID context,
    _In_ BOOLEAN handled
)
{
    UNREFERENCED_PARAMETER(handled);

    PNMI_CONTEXT nmiContext = (PNMI_CONTEXT)context;
    ULONG procNum = KeGetCurrentProcessorNumber();
    
    nmiContext[procNum].numFired++;
    nmiContext[procNum].threadId = HandleToULong(PsGetCurrentThreadId());
    nmiContext[procNum].framesCaptured = RtlCaptureStackBackTrace(
        0, 
        STACK_CAPTURE_SIZE, 
        (PVOID*)nmiContext[procNum].stackFrames,
        NULL
    );

    return TRUE;
}

/**
 * @brief Analyze captured NMI data and emit ETW reports for suspicious frames.
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
VOID
UkAnalyzeNmiData(
    VOID
)
{
    for (auto core=0u; core<g_numCores; ++core)
    {
        PETHREAD ThreadObj = NULL;
        NMI_CONTEXT nmiContext = g_NmiContext[core];

        LOG_DBG("NMI callback data: TID: %l\n", nmiContext.threadId);

        if (nmiContext.threadId == 0)
        {
            continue;
        }

        if (!NT_SUCCESS(PsLookupThreadByThreadId(ULongToHandle(nmiContext.threadId), &ThreadObj)))
        {
            LOG_DBG("PsLookupThreadByThreadId error\n");
            continue;
        }

        //
        // Check each stack frame for origin
        //
        for (auto i = 0; i < nmiContext.framesCaptured; ++i)
        {
            ULONG_PTR addr = (ULONG_PTR)(nmiContext.stackFrames[i]);
            PKLDR_DATA_TABLE_ENTRY driver = UkGetDriverForAddress(addr);

            if (driver == NULL)
            {
                UkTraceEtw("NmiCallback", "Detected stack frame pointing to unbacked region. TID: %u @ 0x%llx", nmiContext.threadId, addr);
            
                //
                // Print stack frame TODO: clean this code
                //
                for (auto j = 0; j < nmiContext.framesCaptured; ++j)
                {
                    ULONG_PTR address = (ULONG_PTR)nmiContext.stackFrames[j];
                    PKLDR_DATA_TABLE_ENTRY currDriver = UkGetDriverForAddress(address);
                    if (currDriver == NULL)
                    {
                        UkTraceEtw("NmiCallback", "[%d] Stack frame %lu: 0x%llx // %ws\n", nmiContext.threadId, j, address, L"??? <------ Unbacked!");
                    }
                    else
                    {
                        auto offsetToFunction = (currDriver == NULL) ? address : (address - (ULONG_PTR)currDriver->DllBase);
                        PWCHAR driverName = currDriver->BaseDllName.Buffer;
                        UkTraceEtw("NmiCallback", "[%d] Stack frame %lu: 0x%llx+0x%llx // %ws\n", nmiContext.threadId, j, (ULONG_PTR)currDriver->DllBase, offsetToFunction, driverName);
                    }
                }
            }
        }
        
        if (ThreadObj)
        {
            ObDereferenceObject(ThreadObj);
        }
    }
}

/**
 * @brief Allocate and initialize NMI resources and state.
 *
 * @return TRUE on success; FALSE otherwise.
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
BOOLEAN 
UkRegisterNmiCallbacks(
    VOID
)
{
    g_numCores = KeQueryActiveProcessorCountEx(0);
    ULONG nmiContextLength = g_numCores * sizeof(NMI_CONTEXT);

    g_NmiContext = (PNMI_CONTEXT)ExAllocatePoolWithTag(NonPagedPool, nmiContextLength, POOL_TAG);
    g_NmiAffinity = (PKAFFINITY_EX)ExAllocatePoolWithTag(NonPagedPool, sizeof(KAFFINITY_EX), POOL_TAG);

    if (!g_NmiAffinity || !g_NmiContext)
        return FALSE;

    RtlSecureZeroMemory(g_NmiContext, nmiContextLength);

    return TRUE;
}

/**
 * @brief Release NMI-related resources and deregister callback if present.
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
VOID 
UkUnloadNMI(
    VOID
)
{
    if (g_NmiCallbackHandle) KeDeregisterNmiCallback(g_NmiCallbackHandle);
    if (g_NmiAffinity) ExFreePoolWithTag(g_NmiAffinity, POOL_TAG);
    if (g_NmiContext) ExFreePoolWithTag(g_NmiContext, POOL_TAG);
}

/**
 * @brief Send NMI to each processor and process captured data.
 *
 * @param[IN] StartContext unused.
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
VOID
UkSendNMI(
    _In_ PVOID StartContext
)
{
    UNREFERENCED_PARAMETER(StartContext);

    NTSTATUS NtStatus;

    KeInitializeEvent(&g_sendNmisFinishedEvent, SynchronizationEvent, FALSE);

    do
    {
        //
        // Register callback
        //
        g_NmiCallbackHandle = KeRegisterNmiCallback(UkNmiCallback, g_NmiContext);

        //
        // Fire NMI for each core
        //
        for (auto core=0u; core<g_numCores; ++core)
        {
            KeInitializeAffinityEx(g_NmiAffinity);
            KeAddProcessorAffinityEx(g_NmiAffinity, core);

            LOG_DBG("Sending NMI to analyze thread running on core %d...\n", core);
            HalSendNMI(g_NmiAffinity);

            //
            // Sleep for 1 seconds between each NMI to allow completion
            //
            UkSleepMs(1000);
        }

        //
        // Unregister callback
        //
        if (g_NmiCallbackHandle)
        {
            NtStatus = KeDeregisterNmiCallback(g_NmiCallbackHandle);
            if (!NT_SUCCESS(NtStatus))
            {
                LOG_DBG("KeDeregisterNmiCallback error: %d\n", NtStatus);
            }
        }

        //
        // Analyze data
        //
        UkAnalyzeNmiData();

        UkSleepMs(5000);

    } while (g_sendNmis);

    KeSetEvent(&g_sendNmisFinishedEvent, 0, FALSE);
    PsTerminateSystemThread(STATUS_SUCCESS);
}

```

`unKover/nmi.h`:

```h
#pragma once

#include <ntifs.h>
#include <ntddk.h>
#include "meta.h"
#include "utils.h"

#define STACK_CAPTURE_SIZE 32

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _NMI_CONTEXT
{
    ULONG threadId;
    INT numFired;
    USHORT framesCaptured;
    ULONG_PTR stackFrames[STACK_CAPTURE_SIZE];
} NMI_CONTEXT, *PNMI_CONTEXT;

typedef struct _KAFFINITY_EX
{
    USHORT Count;
    USHORT Size;
    ULONG Reserved;
    ULONGLONG Bitmap[20];
} KAFFINITY_EX, *PKAFFINITY_EX;

EXTERN_C VOID KeInitializeAffinityEx(PKAFFINITY_EX affinity);
EXTERN_C VOID KeAddProcessorAffinityEx(PKAFFINITY_EX affinity, INT num);
EXTERN_C VOID HalSendNMI(PKAFFINITY_EX affinity);

BOOLEAN
UkRegisterNmiCallbacks(
    VOID
);

VOID
UkUnloadNMI(
    VOID
);

VOID
UkSendNMI(
    _In_ PVOID StartContext
);

VOID
UkAnalyzeNmiData(
    VOID
);

BOOLEAN
UkNmiCallback(
    _In_ PVOID context,
    _In_ BOOLEAN handled
);

/* globals */
extern ULONG g_numCores;
extern PVOID g_NmiCallbackHandle;
extern PKAFFINITY_EX g_NmiAffinity;
extern PNMI_CONTEXT g_NmiContext;
extern HANDLE SendNMIThreadHandle;
extern BOOLEAN g_sendNmis;
extern KEVENT g_sendNmisFinishedEvent;

#ifdef __cplusplus
}
#endif

```

`unKover/sectioncompare.cpp`:

```cpp
#include <ntifs.h>
#include <ntddk.h>
#include <ntimage.h>
#include <string.h>

#include "sectioncompare.h"
#include "meta.h"
#include "utils.h"

BOOLEAN g_compareTextSections = TRUE;
KEVENT g_compareTextSectionsFinishedEvent;

/**
 * @brief If OriginalString starts with "System32", prepend "\\SystemRoot\\"; otherwise copy as-is.
 *
 * @param[IN]  OriginalString Source string.
 * @param[OUT] ResultString   Destination string.
 *
 * @return NTSTATUS.
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
UkPrependWindowsPathIfStartsWithSystem32(
    _In_ PUNICODE_STRING OriginalString,
    _Out_ PUNICODE_STRING ResultString
)
{
    UNICODE_STRING system32 = RTL_CONSTANT_STRING(L"System32");
    UNICODE_STRING windowsPrefix;
    RtlInitUnicodeString(&windowsPrefix, L"\\SystemRoot\\");

    BOOLEAN startsWithSystem32 = RtlPrefixUnicodeString(&system32, OriginalString, TRUE);

    if (startsWithSystem32)
    {
        USHORT newLength = windowsPrefix.Length + OriginalString->Length;

        ResultString->Buffer = (PWCH)ExAllocatePoolWithTag(NonPagedPool, newLength, POOL_TAG);
        if (ResultString->Buffer == NULL)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        ResultString->Length = newLength;
        ResultString->MaximumLength = newLength;

        RtlCopyMemory(ResultString->Buffer, windowsPrefix.Buffer, windowsPrefix.Length);
        RtlCopyMemory((PCHAR)ResultString->Buffer + windowsPrefix.Length, OriginalString->Buffer, OriginalString->Length);
    }
    else
    {
        ResultString->Buffer = (PWCH)ExAllocatePoolWithTag(NonPagedPool, OriginalString->Length, POOL_TAG);
        if (ResultString->Buffer == NULL)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        ResultString->Length = OriginalString->Length;
        ResultString->MaximumLength = OriginalString->Length;

        RtlCopyMemory(ResultString->Buffer, OriginalString->Buffer, OriginalString->Length);
    }

    return STATUS_SUCCESS;
}

/**
 * @brief Read entire file contents into memory.
 *
 * @param[IN]  FileName   File name.
 * @param[OUT] FileBuffer Allocated buffer with contents.
 * @param[OUT] FileSize   Size in bytes.
 *
 * @return NTSTATUS.
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
UkReadFileToMemory(
    _In_ PUNICODE_STRING FileName,
    _Out_ PVOID* FileBuffer,
    _Out_ ULONG* FileSize
)
{
    NTSTATUS status;
    HANDLE fileHandle = NULL;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    FILE_STANDARD_INFORMATION fileStandardInformation;
    PVOID buffer = NULL;

    InitializeObjectAttributes(&objectAttributes, FileName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = ZwCreateFile(
        &fileHandle,
        GENERIC_READ,
        &objectAttributes,
        &ioStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ,
        FILE_OPEN,
        FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0
    );

    if (!NT_SUCCESS(status))
    {
        goto Cleanup;
    }

    //
    // get file size
    //
    status = ZwQueryInformationFile(fileHandle, &ioStatusBlock, &fileStandardInformation, sizeof(fileStandardInformation), FileStandardInformation);
    if (!NT_SUCCESS(status))
    {
        goto Cleanup;
    }

    //
    // allocate memory
    //
    buffer = ExAllocatePoolWithTag(NonPagedPool, fileStandardInformation.EndOfFile.LowPart, POOL_TAG);
    if (buffer == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    status = ZwReadFile(fileHandle, NULL, NULL, NULL, &ioStatusBlock, buffer, fileStandardInformation.EndOfFile.LowPart, NULL, NULL);
    if (!NT_SUCCESS(status))
    {
        goto Cleanup;
    }

    *FileBuffer = buffer;
    *FileSize = fileStandardInformation.EndOfFile.LowPart;
    if (fileHandle) { ZwClose(fileHandle); }
    //
    // do not free the buffer yet
    //
    return status;

Cleanup:
    if (buffer) { ExFreePool(buffer); }
    if (fileHandle) { ZwClose(fileHandle); }
    return status;
}

/**
 * @brief Retrieve a specific section from a PE image buffer.
 *
 * @param[IN]  sectionName   Section name.
 * @param[IN]  peBuffer      PE image buffer.
 * @param[OUT] sectionBuffer Allocated buffer with section contents.
 * @param[OUT] size          Size of section.
 *
 * @return NTSTATUS.
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
UkGetPeSection(
    IN PCHAR sectionName,
    IN PVOID peBuffer,
    OUT PCHAR sectionBuffer,
    OUT PULONG size
)
{
    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)peBuffer;
    if (!dosHeader)
    {
        UkTraceEtw("TextSectionComparer", "-- [!] Invalid PE header");
        return STATUS_INVALID_PARAMETER;
    }

    PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((CHAR*)peBuffer + dosHeader->e_lfanew);
    if (ntHeaders == NULL)
    {
        UkTraceEtw("TextSectionComparer", "-- [!] Invalid PE header");
        return STATUS_INVALID_PARAMETER;
    }

    PIMAGE_SECTION_HEADER sectionHeader = IMAGE_FIRST_SECTION(ntHeaders);
    for (ULONG i = 0; i < ntHeaders->FileHeader.NumberOfSections; i++)
    {
        if (strncmp((char*)sectionHeader->Name, sectionName, IMAGE_SIZEOF_SHORT_NAME) == 0)
        {
            ULONG sectionOffset = sectionHeader->PointerToRawData;
            ULONG sectionSize = sectionHeader->SizeOfRawData;

            sectionBuffer = (PCHAR)ExAllocatePoolWithTag(NonPagedPool, sectionSize, POOL_TAG);
            if (sectionBuffer == NULL)
            {
                UkTraceEtw("TextSectionComparer", "[!] Failed to allocate memory for section");
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            RtlCopyMemory(sectionBuffer, (PCHAR)((ULONG_PTR)peBuffer + sectionOffset), sectionSize);
            if (size) *size = sectionSize;
            return STATUS_SUCCESS;
        }
        sectionHeader++;
    }

    UkTraceEtw("TextSectionComparer", "[!] Section not found");
    return STATUS_NOT_FOUND;
}

/**
 * @brief Compare .text sections of loaded drivers with their on-disk counterparts.
 *
 * @param[IN] StartContext Optional context parameter.
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
VOID
UkCompareTextSections(
    PVOID startContext
)
{
    UNREFERENCED_PARAMETER(startContext);
    NTSTATUS status;
    PVOID directory;
    HANDLE handle;
    OBJECT_ATTRIBUTES attributes;
    UNICODE_STRING directoryName = RTL_CONSTANT_STRING(L"\\Driver");

    KeInitializeEvent(&g_compareTextSectionsFinishedEvent, SynchronizationEvent, FALSE);

    while (g_compareTextSections)
    {
        // 
        // Get Handle to \Driver directory
        //
        InitializeObjectAttributes(&attributes, &directoryName, OBJ_CASE_INSENSITIVE, NULL, NULL);
        status = ZwOpenDirectoryObject(&handle, DIRECTORY_ALL_ACCESS, &attributes);
        if (!NT_SUCCESS(status))
        {
            LOG_DBG("Couldnt get \\Driver directory handle\n");
            return;
        }

        status = ObReferenceObjectByHandle(handle, DIRECTORY_ALL_ACCESS, nullptr, KernelMode, &directory, nullptr);
        if (!NT_SUCCESS(status))
        {
            ZwClose(handle);
            LOG_DBG("Couldnt get \\Driver directory object from handle\n");
            return;
        }

        POBJECT_DIRECTORY directoryObject = (POBJECT_DIRECTORY)directory;
        ULONG_PTR hashBucketLock = directoryObject->Lock;

        UkTraceEtw("TextSectionComparer", "Scanning DriverObjects...");

        // 
        // Lock for the hashbucket
        //
        KeEnterCriticalRegion();
        ExAcquirePushLockExclusiveEx(&hashBucketLock, 0);

        for (POBJECT_DIRECTORY_ENTRY entry : directoryObject->HashBuckets)
        {
            if (!entry)
            {
                continue;
            }

            while (entry != nullptr && entry->Object)
            {
                PVOID fileBuffer = NULL;
                PCHAR textSectionOnDiskBuffer = NULL;
                PCHAR textSectionInMemBuffer = NULL;
                ULONG sectionSizeOnDisk = 0;
                ULONG sectionSizeInMem = 0;

                PDRIVER_OBJECT driver = (PDRIVER_OBJECT)entry->Object;

                UNICODE_STRING imagePath;
                WCHAR imagePathBuffer[256];
                imagePath.Buffer = imagePathBuffer;
                imagePath.Length = 0;
                imagePath.MaximumLength = sizeof(imagePathBuffer);

                UNICODE_STRING driverServiceName;
                WCHAR serviceNameBuffer[256];
                driverServiceName.Buffer = serviceNameBuffer;
                driverServiceName.Length = 0;
                driverServiceName.MaximumLength = sizeof(serviceNameBuffer);

                // 
                // Get driver service name to lookup path to binary
                //
                UkStripDriverPrefix(&driver->DriverName, &driverServiceName);

                // 
                // get the image path
                //
                NTSTATUS status = UkGetDriverImagePath(&driverServiceName, &imagePath);
                if (NT_SUCCESS(status))
                {
                    // LOG_MSG("[*] Checking driver: %wZ -> %wZ\n", driverServiceName, imagePath);
                }
                else
                {
                    //LOG_MSG("-- [!] Failed to get driver image path for %wZ, Status: 0x%x\n", driverServiceName, status);
                    goto Next;
                }

                UNICODE_STRING imagePathAbsolute;

                status = UkPrependWindowsPathIfStartsWithSystem32(&imagePath, &imagePathAbsolute);
                if (!NT_SUCCESS(status))
                {
                    //LOG_MSG("-- [!] Failed to construct absolute path for %wZ, Status: 0x%x\n", imagePath, status);
                    goto Next;
                }

                // 
                // read the image and compare it to the in memory image
                //
                ULONG fileSize = 0;
                status = UkReadFileToMemory(&imagePathAbsolute, &fileBuffer, &fileSize);
                if (NT_SUCCESS(status))
                {
                    //
                    // compare .text sections
                    //
                    if (!NT_SUCCESS(UkGetPeSection(".text", fileBuffer, textSectionOnDiskBuffer, &sectionSizeOnDisk))
                        || !NT_SUCCESS(UkGetPeSection(".text", driver->DriverStart, textSectionInMemBuffer, &sectionSizeInMem))
                        || !textSectionOnDiskBuffer || !textSectionInMemBuffer)
                    {
                        goto Next;
                    }

                    if (RtlCompareMemory(textSectionOnDiskBuffer, textSectionInMemBuffer, sectionSizeOnDisk) != sectionSizeOnDisk)
                    {
                        UkTraceEtw("TextSectionComparer", " .TEXT section differs %wZ", imagePath);
                    }
                    else
                    {
                        // LOG_MSG("-- [*] .text section matches\n");
                    }
                }
                else
                {
                    LOG_DBG("Failed to read image %wZ, Status: 0x%x", imagePathAbsolute, status);
                    goto Next;
                }

            Next:
                if (fileBuffer)
                {
                    ExFreePool(fileBuffer);
                }
                if (textSectionOnDiskBuffer)
                {
                    ExFreePool(textSectionOnDiskBuffer);
                }
                if (textSectionInMemBuffer)
                {
                    ExFreePool(textSectionInMemBuffer);
                }
                entry = entry->ChainLink;
            }
        }

        ExReleasePushLockExclusiveEx(&hashBucketLock, 0);
        KeLeaveCriticalRegion();

        ObDereferenceObject(directory);
        ZwClose(handle);

        UkSleepMs(5000);

    } while (g_compareTextSections);

    KeSetEvent(&g_compareTextSectionsFinishedEvent, 0, FALSE);
    PsTerminateSystemThread(STATUS_SUCCESS);
}
```

`unKover/sectioncompare.h`:

```h
#pragma once

#include <ntifs.h>
#include <ntddk.h>
#include "deviceobjects.h"
#include "utils.h"

#ifdef __cplusplus
extern "C" {
#endif

VOID
UkCompareTextSections(
    IN PVOID StartContext
);

/* globals */
extern BOOLEAN g_compareTextSections;
extern KEVENT g_compareTextSectionsFinishedEvent;

#ifdef __cplusplus
}
#endif

```

`unKover/threads.cpp`:

```cpp
#include "threads.h"
#include "meta.h"

BOOLEAN g_scanSystemThreads = TRUE;
KEVENT g_scanSystemThreadsFinishedEvent;

/**
 * @brief Scans running system threads to detect unbacked start addresses.
 *
 * @param[IN] StartContext Unused.
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
VOID
UkScanSystemThreads(
    _In_ PVOID StartContext
)
{
    UNREFERENCED_PARAMETER(StartContext);

    KeInitializeEvent(&g_scanSystemThreadsFinishedEvent, SynchronizationEvent, FALSE);

    do
    {
        UkTraceEtw("SystemThreadScanner", "Scanning running system threads...");

        //
        // Scan system threads. TIDs are a multiple of 4 TODO: max number?
        //
        for (auto tid=4; tid<0xFFFF; tid += 4)
        {
            PETHREAD ThreadObj = NULL;

            //
            // Get ETHREAD object for TID
            //
            if (tid == 0 || !NT_SUCCESS(PsLookupThreadByThreadId(ULongToHandle(tid), &ThreadObj)))
            {
                continue;
            }

            //
            // Ignore current thread and non system threads
            //
            if (!PsIsSystemThread(ThreadObj) || ThreadObj == (PETHREAD)KeGetCurrentThread())
            {
                if (ThreadObj) { ObDereferenceObject(ThreadObj); }
                continue;
            }

            //
            // Resolve start address
            //
            ULONG_PTR startAddress = UkGetThreadStartAddress(ThreadObj);
            if (startAddress != 0)
            {
                if (UkGetDriverForAddress(startAddress) == NULL)
                {
                    UkTraceEtw("SystemThreadScanner", "Detected system thread start address pointing to unbacked region: TID: %lu @ 0x%llx", tid, startAddress);
                }
            }

            ObDereferenceObject(ThreadObj);
        }

        UkSleepMs(5000);

    } while(g_scanSystemThreads);
    
    KeSetEvent(&g_scanSystemThreadsFinishedEvent, 0, TRUE);
    PsTerminateSystemThread(STATUS_SUCCESS);
}

```

`unKover/threads.h`:

```h
#pragma once

#include <ntifs.h>
#include <ntddk.h>
#include "utils.h"

#ifdef __cplusplus
extern "C" {
#endif


VOID
UkScanSystemThreads(
    IN PVOID StartContext
);

//
// globals
//
extern BOOLEAN g_scanSystemThreads;
extern KEVENT g_scanSystemThreadsFinishedEvent;

#ifdef __cplusplus
}
#endif

```

`unKover/tracing.cpp`:

```cpp
#include "meta.h"
#include <stdarg.h>
#include <strsafe.h>
#include <TraceLoggingProvider.h>

TRACELOGGING_DEFINE_PROVIDER(
    g_hTraceProvider,
    "unKover",
    (0x95bc72d9, 0x99bc, 0x7317, 0x12, 0xbc, 0xda, 0xc4, 0xe2, 0x19, 0x20, 0x0c)
);

/**
 * @brief Emit an ETW trace event using TraceLogging.
 *
 * @param[IN] Type   ASCII category string.
 * @param[IN] Format printf-style ANSI format string.
 */
_IRQL_requires_same_
_IRQL_requires_max_(APC_LEVEL)
void
UkTraceEtw(
    _In_ PCSTR Type,
    _In_ PCSTR Format,
    ...
)
{
    CHAR buffer[1024];
    va_list args;
    va_start(args, Format);
    StringCbVPrintfA(buffer, sizeof(buffer), Format, args);
    va_end(args);

    TraceLoggingWrite(
        g_hTraceProvider,
        "UnkoverEvent",
        TraceLoggingString(Type, "Type"),
        TraceLoggingString(buffer, "Message")
    );
}

```

`unKover/utils.cpp`:

```cpp
#include <ntifs.h>
#include <ntddk.h>
#include "meta.h"
#include "utils.h"

BOOLEAN g_doAPCStackWalk = TRUE;
KEVENT g_kernelApcSyncEvent;
KEVENT g_rundownApcSyncEvent;
KEVENT g_apcFinishedEvent;

/**
 * @brief Remove common driver path prefixes from the input string.
 *
 * @param[IN]  InputString  Original UNICODE string.
 * @param[OUT] OutputString Result string without prefix.
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
VOID
UkStripDriverPrefix(
    _In_ PUNICODE_STRING InputString,
    _Out_ PUNICODE_STRING OutputString
)
{
    UNICODE_STRING prefix = RTL_CONSTANT_STRING(L"\\Driver");
    if (RtlPrefixUnicodeString(&prefix, InputString, TRUE))
    {
        USHORT newLength = (USHORT)(InputString->Length - prefix.Length);
        OutputString->Buffer = InputString->Buffer + (prefix.Length / sizeof(WCHAR));
        OutputString->Length = newLength;
        OutputString->MaximumLength = newLength;
    }
    else
    {
        RtlCopyUnicodeString(OutputString, InputString);
    }
}

/**
 * @brief Resolve driver image path from a given driver name.
 *
 * @param[IN]  DriverName Driver base name.
 * @param[OUT] ImagePath  Full image path.
 *
 * @return NTSTATUS.
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
UkGetDriverImagePath(
    _In_ PUNICODE_STRING DriverName,
    _Out_ PUNICODE_STRING ImagePath
)
{
    NTSTATUS status;
    UNICODE_STRING registryPath;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE keyHandle = NULL;
    ULONG resultLength;
    PKEY_VALUE_PARTIAL_INFORMATION keyValueInfo = NULL;

    WCHAR registryPathBuffer[256];
    registryPath.Buffer = registryPathBuffer;
    registryPath.Length = 0;
    registryPath.MaximumLength = sizeof(registryPathBuffer);
    RtlAppendUnicodeToString(&registryPath, L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services");
    RtlAppendUnicodeStringToString(&registryPath, DriverName);

    InitializeObjectAttributes(&objectAttributes, &registryPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
    status = ZwOpenKey(&keyHandle, KEY_READ, &objectAttributes);
    if (!NT_SUCCESS(status))
    {
        UkTraceEtw("LOG", "[!] Failed to open registry key: %wZ, Status: 0x%x", &registryPath, status);
        goto Cleanup;
    }

    ULONG keyValueInfoSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 256 * sizeof(WCHAR);
    keyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ExAllocatePoolWithTag(PagedPool, keyValueInfoSize, POOL_TAG);
    if (!keyValueInfo)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    UNICODE_STRING valueName;
    RtlInitUnicodeString(&valueName, L"ImagePath");
    status = ZwQueryValueKey(keyHandle, &valueName, KeyValuePartialInformation, keyValueInfo, keyValueInfoSize, &resultLength);
    if (NT_SUCCESS(status))
    {
        RtlInitUnicodeString(ImagePath, (PCWSTR)keyValueInfo->Data);
    }
    else
    {
        UkTraceEtw("LOG", "Failed to query ImagePath value, Status: 0x%x", status);
        goto Cleanup;
    }

Cleanup:
    if (keyValueInfo) { ExFreePoolWithTag(keyValueInfo, POOL_TAG); }
    if (keyHandle) { ZwClose(keyHandle); }
    return status;
}

/**
 * @brief Case-insensitive wide-character strcmp.
 *
 * @param[IN] s1 First string.
 * @param[IN] s2 Second string.
 *
 * @return Comparison result.
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
INT
_strcmpi_w(
    _In_ const wchar_t* s1,
    _In_ const wchar_t* s2
)
{
    WCHAR c1, c2;

    if (s1 == s2)
        return 0;

    if (s1 == 0)
        return -1;

    if (s2 == 0)
        return 1;

    do {
        c1 = RtlUpcaseUnicodeChar(*s1);
        c2 = RtlUpcaseUnicodeChar(*s2);
        s1++;
        s2++;
    } while ((c1 != 0) && (c1 == c2));

    return (INT)(c1 - c2);
}

/**
 * @brief Get the driver module corresponding to a virtual address.
 *
 * @param[IN] address Target virtual address.
 *
 * @return Pointer to KLDR_DATA_TABLE_ENTRY, or NULL if not found.
 */
_IRQL_requires_same_
_IRQL_requires_max_(APC_LEVEL)
PKLDR_DATA_TABLE_ENTRY
UkGetDriverForAddress(
    _In_ ULONG_PTR address
)
{
    if (!address || g_drvObj == NULL)
    {
        return NULL;
    }

    PKLDR_DATA_TABLE_ENTRY entry = (PKLDR_DATA_TABLE_ENTRY)g_drvObj->DriverSection;

    for (auto i = 0; i < 512 && entry; ++i)
    {
        UINT64 startAddr = (UINT64)entry->DllBase;
        UINT64 endAddr = startAddr + (UINT64)entry->SizeOfImage;
        if (address >= startAddr && address < endAddr)
        {
            return entry;
        }
        entry = (PKLDR_DATA_TABLE_ENTRY)entry->InLoadOrderLinks.Flink;
    }

    return NULL;
}

/**
 * @brief Query a thread's start address.
 *
 * @param[IN] ThreadObj ETHREAD object pointer.
 *
 * @return Start address as ULONG_PTR.
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
ULONG_PTR
UkGetThreadStartAddress(
    _In_ PETHREAD ThreadObj
)
{
    HANDLE hThread;
    ULONG_PTR startAddress = 0;
    ULONG bytesReturned = 0;

    if (!ThreadObj)
        return 0;

    if (ObOpenObjectByPointer(ThreadObj, OBJ_KERNEL_HANDLE, NULL, GENERIC_READ, *PsThreadType, KernelMode, &hThread) != STATUS_SUCCESS)
    {
        return 0;
    }

    if (!NT_SUCCESS(ZwQueryInformationThread(hThread, (THREADINFOCLASS)ThreadQuerySetWin32StartAddress, &startAddress, sizeof(startAddress), &bytesReturned)))
    {
        ZwClose(hThread);
        return 0;
    }

    if (!MmIsAddressValid((PVOID)startAddress))
    {
        ZwClose(hThread);
        return 0;
    }

    ZwClose(hThread);
    return startAddress;
}

/**
 * @brief Sleep the current thread for a given number of milliseconds.
 *
 * @param[IN] milliseconds Delay duration.
 */
_IRQL_requires_same_
_IRQL_requires_(PASSIVE_LEVEL)
VOID
UkSleepMs(
    INT milliseconds
)
{
    LARGE_INTEGER interval;
    interval.QuadPart = -1 * (LONGLONG)(milliseconds * 10000);
    KeDelayExecutionThread(KernelMode, FALSE, &interval);
}
```

`unKover/utils.h`:

```h
#pragma once

#include <ntifs.h>
#include <ntddk.h>
#include <ntimage.h>
#include "meta.h"

typedef struct _OBJECT_DIRECTORY_INFORMATION
{
	UNICODE_STRING Name;
	UNICODE_STRING TypeName;
} OBJECT_DIRECTORY_INFORMATION, * POBJECT_DIRECTORY_INFORMATION;

EXTERN_C NTSTATUS ZwQueryInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);
EXTERN_C NTSTATUS ObReferenceObjectByName(PUNICODE_STRING ObjectName, ULONG Attributes, PACCESS_STATE AccessState, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PVOID ParseContext, PVOID* Object);
EXTERN_C NTSTATUS ZwQueryDirectoryObject(
	_In_      HANDLE  DirectoryHandle,
	_Out_opt_ PVOID   Buffer,
	_In_      ULONG   Length,
	_In_      BOOLEAN ReturnSingleEntry,
	_In_      BOOLEAN RestartScan,
	_Inout_   PULONG  Context,
	_Out_opt_ PULONG  ReturnLength
);

typedef struct _KLDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	PVOID ExceptionTable;
	UINT32 ExceptionTableSize;
	PVOID GpValue;
	NON_PAGED_DEBUG_INFO* NonPagedDebugInfo;
	PVOID DllBase;
	PVOID EntryPoint;
	UINT32 SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	UINT32 Flags;
	UINT16 LoadCount;
	UINT16 SignatureInfo;
	PVOID SectionPointer;
	UINT32 CheckSum;
	UINT32 CoverageSectionSize;
	PVOID CoverageSection;
	PVOID LoadedImports;
	PVOID Spare;
	UINT32 SizeOfImageNotRounded;
	UINT32 TimeDateStamp;
} KLDR_DATA_TABLE_ENTRY, * PKLDR_DATA_TABLE_ENTRY;

VOID
UkStripDriverPrefix(
    _In_ PUNICODE_STRING InputString,
    _Out_ PUNICODE_STRING OutputString
);

NTSTATUS
UkGetDriverImagePath(
    _In_ PUNICODE_STRING DriverName,
    _Out_ PUNICODE_STRING ImagePath
);

INT
_strcmpi_w(
    _In_ const wchar_t* s1,
    _In_ const wchar_t* s2
);

PKLDR_DATA_TABLE_ENTRY
UkGetDriverForAddress(
    _In_ ULONG_PTR address
);

ULONG_PTR
UkGetThreadStartAddress(
    _In_ PETHREAD ThreadObj
);

VOID
UkSleepMs(
    INT milliseconds
);

//
// globals
//
extern BOOLEAN g_doAPCStackWalk;
extern KEVENT g_kernelApcSyncEvent;
extern KEVENT g_rundownApcSyncEvent;
extern KEVENT g_apcFinishedEvent;

```