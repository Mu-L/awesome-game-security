Project Path: arc_K4ryuu_IDA-VTableExplorer_twkj5wrx

Source Tree:

```txt
arc_K4ryuu_IDA-VTableExplorer_twkj5wrx
‚îú‚îÄ‚îÄ CHANGELOG.md
‚îú‚îÄ‚îÄ Makefile
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ docker
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îú‚îÄ‚îÄ Makefile
‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ docs
‚îÇ   ‚îî‚îÄ‚îÄ images
‚îÇ       ‚îú‚îÄ‚îÄ annotated-vtable.jpg
‚îÇ       ‚îú‚îÄ‚îÄ chooser-context-menu.jpg
‚îÇ       ‚îú‚îÄ‚îÄ function-browser.jpg
‚îÇ       ‚îú‚îÄ‚îÄ ida-context-menu.jpg
‚îÇ       ‚îú‚îÄ‚îÄ inheritance-graph.png
‚îÇ       ‚îî‚îÄ‚îÄ vtable-chooser.png
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ inheritance_graph.h
    ‚îú‚îÄ‚îÄ main.cpp
    ‚îú‚îÄ‚îÄ rtti_detector.h
    ‚îú‚îÄ‚îÄ rtti_parser.h
    ‚îú‚îÄ‚îÄ smart_annotator.h
    ‚îú‚îÄ‚îÄ vtable_chooser.h
    ‚îú‚îÄ‚îÄ vtable_comparison.h
    ‚îú‚îÄ‚îÄ vtable_detector.h
    ‚îî‚îÄ‚îÄ vtable_utils.h

```

`CHANGELOG.md`:

```md
# Changelog

Format based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).

---

## [1.2.3] - 2026-02-13

### Added

-  **COL-based VTable Discovery**: Detect vtables that have RTTI Complete Object Locator (`??_R4`) symbols but no `??_7` vtable symbol
   -  Second-pass scan in `find_vtables()` processes all `??_R4` name entries
   -  Extracts class name from COL's TypeDescriptor using existing RTTI parser
   -  Locates vtable via name construction (`??_R4` ‚Üí `??_7` lookup) or data xref walking
   -  Validates vtable entries point to executable code before adding
   -  Supports both x86 (absolute pointers) and x64 (RVA-based) COL formats

### Fixed

-  **Missing VTables in Windows PE Binaries**: Classes like `CSource2Server`, `CEngineServer` that only had `??_R4` COL symbols are now properly discovered and displayed

---

## [1.2.2] - 2025-12-23

### Added

-  **VTable Header Comments**: Vtable annotations now include header comment showing parent class inheritance
   -  Format: `vtable for 'ClassName' : inherits 'ParentClass'`
   -  Root classes show: `vtable for 'ClassName' : (root class)`
-  **Override Status Annotations**: Function entries now display inheritance status
   -  `[Override]` - Function overrides parent implementation
   -  `[Inherited]` - Function inherited unchanged from parent
   -  `[NEW]` - New virtual function not in parent
   -  `[Pure‚ÜíImpl]` - Pure virtual function now implemented
   -  `[Impl‚ÜíPure]` - Implementation changed to pure virtual
   -  `[PURE]` - Pure virtual function (for classes without parent)

### Improved

-  **Fixed-Width Annotation Formatting**: All annotation comments now align perfectly
   -  Status prefixes padded to 13 characters for consistent alignment
   -  Index and offset values left-aligned with trailing spaces
   -  Format: `[Status]     index: N   | offset: M   `

---

## [1.2.1] - 2025-12-21

### Added

-  **RTTI Auto-Detection**: Automatic MSVC vs GCC/Itanium format detection based on file type and symbol mangling
-  **Intermediate Class Support**: Detect and display compiler-inlined classes that exist in RTTI chain but have no vtable symbol
-  **Inheritance Graph Enhancement**: Intermediate classes shown with proper parent-child connections and "uses [ParentVTable]" info
-  **MSVC x64 Pointer Format Detection**: Auto-detect 64-bit absolute pointers vs 32-bit RVA format in Complete Object Locator

### Fixed

-  **Nested Class Name Normalization**: MSVC nested classes now properly display as `Outer::Inner` instead of `Outer@Inner`
-  **Graph Edge Logic**: Fixed intermediate class connections - parent‚Üíintermediate‚Üíchild chain displays correctly
-  **Class Name Validation**: Relaxed validation to support more edge cases

### Improved

-  **Code Cleanup**: Compact comments, renamed functions, removed redundant code
-  **Chooser Simplification**: Removed unused Insert/Delete options from VTable list
-  **Buffer Sizes**: Increased limits for longer class names and RTTI strings

---

## [1.2.0] - 2025-12-19 - Check README.md

### Added

-  Graph-based inheritance visualization with interactive navigation
-  RTTI parser for automatic inheritance detection (GCC/MSVC formats)
-  Comparison view with override detection and filtering
-  Base class and derived count columns
-  Keyboard shortcuts (Cmd/Ctrl+Shift+V/T/C)

### Fixed

-  Compiler-specific warning flags (GCC vs Clang)
-  macOS deployment target (12.0 to match IDA SDK)
-  All platforms build with 0 warnings

---

## [1.1.0] - 2025-12-02

### Added

**Function Browser**

-  New `Del` key action: Browse all functions in a vtable
-  Secondary chooser window showing function index, address, name, and status
-  Jump to any function with `Enter` key
-  Pure virtual functions highlighted in red

**Pure Virtual Detection**

-  Automatic detection of `__cxa_pure_virtual`, `_purecall`, and `purevirt` symbols
-  Abstract classes marked with `[abstract]` suffix and distinct color
-  Function count shows pure virtual breakdown: `26 (3 pv)`

**Annotate All**

-  New `Ins` key action: Annotate all vtables at once
-  Progress indicator with cancel support
-  Summary dialog showing total vtables and functions processed

**UI Improvements**

-  New "Functions" column showing function count per vtable
-  Color coding: abstract classes in light blue, pure virtuals in red
-  Dockable tab instead of modal window
-  Singleton chooser - reopening brings back the same tab with cached data
-  Refresh action to rescan vtables

### Optimized

-  Cached vtable data for instant reopening
-  Binary search for vtable boundary detection
-  Unified scanner template eliminates duplicate code

---

## [1.0.2] - 2025-11-20

### Fixed

-  Buffer overrun protection in `demangle_msvc_name()` for malformed MSVC symbols
-  Exception handling around `find_vtables()` to prevent crashes

### Removed

-  Windows Docker build (MinGW has ABI incompatibility with MSVC for C++ virtual functions)

---

## [1.0.1] - 2025-11-18

### Changed

**Annotation Format**

-  Updated vtable entry comments to `"index: X | offset: Y"` format (includes both virtual function index and byte offset)
-  Removed function-level comments from decompiled code (assembly-only annotation now)

**Function Detection**

-  Enhanced function pointer validation with name-based trust (accepts IDA auto-generated names: `sub_*`, `nullsub_*`, `j_*`, `*_vfunc_*`)
-  Increased invalid entry tolerance from 2 to 5 consecutive entries for better vtable scanning

---

## [1.0.0] - 2025-11-16

### Added

-  Symbol-based vtable detection (`_ZTV*` for Linux/GCC, `??_7*` for Windows/MSVC)
-  Automatic class name extraction from mangled symbols
-  Virtual function index annotation with byte offsets
-  Native IDA chooser with searchable vtable list
-  Smart RTTI offset detection
-  Context menu and hotkey support (‚åò‚áßV / Ctrl+Shift+V)
-  Multi-platform support: IDA Pro 9.x on Linux, Windows, macOS (ARM64 + x64)
-  Docker-based cross-compilation build system

---

**Repository**: [K4ryuu/IDA-VTableExplorer](https://github.com/K4ryuu/IDA-VTableExplorer)

```

`Makefile`:

```
# VTableExplorer Makefile - Docker multi-platform build

# Platform detection
UNAME_S := $(shell uname -s 2>/dev/null || echo Windows)
ifeq ($(UNAME_S),Windows_NT)
    PLATFORM := Windows
else ifeq ($(UNAME_S),Darwin)
    PLATFORM := Darwin
    LLVM_DIR := $(shell brew --prefix llvm 2>/dev/null || echo /opt/homebrew/opt/llvm)
    LLD_LINK := $(shell which lld-link 2>/dev/null || echo /opt/homebrew/bin/lld-link)
    XWIN_DIR := $(HOME)/.xwin
else ifeq ($(UNAME_S),Linux)
    PLATFORM := Linux
    LLVM_DIR := /usr/lib/llvm-15
    LLD_LINK := $(shell which lld-link 2>/dev/null || echo lld-link)
    XWIN_DIR := $(HOME)/.xwin
else
    PLATFORM := Windows
endif

.PHONY: build build-windows build-all build-clean clean check-docker

check-docker:
	@which docker > /dev/null || (printf "\n[!] Docker is not installed or not in PATH\n\n" && \
	printf "    Install Docker:\n" && \
	printf "    ‚ñ™ macOS:   https://docs.docker.com/desktop/install/mac-install/\n" && \
	printf "    ‚ñ™ Linux:   https://docs.docker.com/engine/install/\n" && \
	printf "    ‚ñ™ Windows: https://docs.docker.com/desktop/install/windows-install/\n\n" && \
	exit 1)
	@docker info > /dev/null 2>&1 || ( \
		printf "\n[!] Docker is not running\n\n"; \
		if [ "$$(uname -s)" = "Darwin" ]; then \
			printf "    Starting Docker Desktop...\n"; \
			open -a Docker && sleep 5 && \
			(docker info > /dev/null 2>&1 && printf "    [‚úì] Docker started successfully\n\n" || \
			(printf "    [!] Failed to start Docker Desktop\n" && \
			printf "    Please start it manually from Applications\n\n" && exit 1)); \
		else \
			printf "    Linux: sudo systemctl start docker\n"; \
			printf "    Windows: Start Docker Desktop\n\n"; \
			exit 1; \
		fi \
	)

build: check-docker
	@printf "[*] Building all platforms via Docker multi-stage build...\n"
	@docker build -f docker/Dockerfile --target artifacts -t vtable-all-artifacts .
	@printf "[*] Extracting binaries...\n"
	@docker create --name vtable-all-extract vtable-all-artifacts
	@mkdir -p release
	@docker cp vtable-all-extract:/vtable64-linux-x64.so release/
	@docker cp vtable-all-extract:/vtable64-linux-arm64.so release/
	@docker cp vtable-all-extract:/vtable64-macos-arm64.dylib release/
	@docker cp vtable-all-extract:/vtable64-macos-x64.dylib release/
	@docker rm vtable-all-extract
	@docker rmi vtable-all-artifacts
	@printf "\n[*] ========================================\n"
	@printf "[+] All platforms built successfully!\n"
	@printf "\n"
	@printf "    Linux x64:   release/vtable64-linux-x64.so\n"
	@printf "    Linux ARM64: release/vtable64-linux-arm64.so\n"
	@printf "    macOS ARM64: release/vtable64-macos-arm64.dylib\n"
	@printf "    macOS x64:   release/vtable64-macos-x64.dylib\n"
	@printf "\n"
	@printf "    Note: For Windows, use ida-win-build with Clang MSVC ABI\n"
	@printf "\n"

build-windows:
ifeq ($(PLATFORM),Windows)
	@printf "[*] Building Windows x64 (native build)...\n"
	@printf "[!] Native Windows build not yet implemented\n"
	@printf "    Use MSVC or Clang-cl manually, or build from macOS/Linux\n"
	@exit 1
else
	@printf "[*] Building Windows x64 (cross-compile from $(PLATFORM))...\n"
	@if [ ! -d "$(LLVM_DIR)" ]; then \
		printf "\n[!] LLVM not found at $(LLVM_DIR)\n"; \
		printf "    macOS: brew install llvm\n"; \
		printf "    Linux: apt install clang lld\n\n"; \
		exit 1; \
	fi
	@if [ ! -d "$(XWIN_DIR)" ]; then \
		printf "\n[!] xwin not found at $(XWIN_DIR)\n"; \
		printf "    Install: cargo install xwin\n"; \
		printf "    Setup:   xwin --accept-license splat --output ~/.xwin\n\n"; \
		exit 1; \
	fi
	@mkdir -p obj release
	@printf "    Compiling source files...\n"
	@for src in src/*.cpp; do \
		obj_name="obj/$$(basename $${src%.*}).obj"; \
		printf "      $$src\n"; \
		$(LLVM_DIR)/bin/clang-cl \
			--target=x86_64-pc-windows-msvc \
			/EHsc /O2 /std:c++17 \
			-Isdk/src/include \
			-D__NT__ -D__EA64__ \
			-Wno-microsoft-include \
			-Wno-unused-command-line-argument \
			-Wno-nontrivial-memcall \
			-Wno-nullability-completeness \
			-Wno-varargs \
			"/Fo$$obj_name" \
			-c "$$src" \
			-imsvc "$(XWIN_DIR)/crt/include" \
			-imsvc "$(XWIN_DIR)/sdk/include/ucrt" \
			-imsvc "$(XWIN_DIR)/sdk/include/um" \
			-imsvc "$(XWIN_DIR)/sdk/include/shared" \
			2>&1 | grep -v "^clang-cl: warning:" || true; \
	done
	@printf "    Linking: vtable64-windows-x64.dll\n"
	@$(LLD_LINK) \
		/DLL \
		/NOIMPLIB \
		/OUT:release/vtable64-windows-x64.dll \
		/LIBPATH:sdk/src/lib/x64_win_vc_64 \
		/LIBPATH:$(XWIN_DIR)/crt/lib/x86_64 \
		/LIBPATH:$(XWIN_DIR)/sdk/lib/um/x86_64 \
		/LIBPATH:$(XWIN_DIR)/sdk/lib/ucrt/x86_64 \
		obj/*.obj \
		ida.lib \
		/NOLOGO
	@printf "[+] Windows x64: release/vtable64-windows-x64.dll\n"
endif

build-all: clean build build-windows
	@printf "\n[*] ========================================\n"
	@printf "[+] ALL PLATFORMS BUILT SUCCESSFULLY!\n"
	@printf "\n"
	@printf "    Linux x64:    release/vtable64-linux-x64.so\n"
	@printf "    Linux ARM64:  release/vtable64-linux-arm64.so\n"
	@printf "    macOS ARM64:  release/vtable64-macos-arm64.dylib\n"
	@printf "    macOS x64:    release/vtable64-macos-x64.dylib\n"
	@printf "    Windows x64:  release/vtable64-windows-x64.dll\n"
	@printf "\n"
	@printf "    Total: 5 platforms, ready for release!\n"
	@printf "\n"

clean:
	@printf "[*] Cleaning build artifacts...\n"
	@rm -rf release/* obj/*
	@printf "[+] Cleaned: release/ and obj/\n"

build-clean:
	@printf "[*] Cleaning Docker artifacts...\n"
	@docker rm -f vtable-all-extract 2>/dev/null || true
	@docker rmi vtable-all-artifacts 2>/dev/null || true
	@printf "[*] Docker cleanup complete\n"

```

`README.md`:

```md
# VTable Explorer for IDA Pro

Professional C++ virtual table analysis plugin for IDA Pro 9.x with complete cross-platform support.

Automatic vtable detection, inheritance analysis, and function override tracking for reverse engineering compiled C++ binaries.

---

### Support My Work

I create free, open-source projects for the community. If you'd like to support my work, consider becoming a sponsor!

#### üíñ GitHub Sponsors

Support this project through [GitHub Sponsors](https://github.com/sponsors/K4ryuu) with flexible options:

- **One-time** or **monthly** contributions
- **Custom amount** - choose what works for you
- **Multiple tiers available** - from basic benefits to priority support or private project access

Every contribution helps me dedicate more time to development, support, and creating new features. Thank you! üôè

<p align="center">
  <a href="https://github.com/sponsors/K4ryuu">
    <img src="https://img.shields.io/badge/sponsor-30363D?style=for-the-badge&logo=GitHub-Sponsors&logoColor=#EA4AAA" alt="GitHub Sponsors" />
  </a>
</p>

‚≠ê **Or support me for free by starring this repository!**

---

## Features

**Core Capabilities**

- Automatic vtable detection (GCC/MSVC symbol patterns)
- Class name extraction and demangling
- Virtual function indexing with byte offsets
- Inheritance hierarchy detection via RTTI parsing
- Function override comparison between base and derived classes
- Pure virtual and abstract class identification
- Interactive inheritance graph visualization
- Batch annotation with progress tracking

**Platform Support**

- IDA Pro 9.x (modern SDK)
- Windows x64
- Linux x64/ARM64
- macOS Intel/Apple Silicon

**Integration**

- Native IDA chooser interface
- Context menu integration
- Keyboard shortcuts (Ctrl+Shift+V / Cmd+Shift+V)
- Searchable vtable browser with 2000+ entry support

---

## Installation

**Download** binary for your platform from releases

**Copy** to IDA plugins directory:

```
Windows:  C:\Program Files\IDA Pro 9.x\plugins\vtable64-windows-x64.dll
Linux:    /opt/ida-pro/plugins/vtable64-linux-{x64,arm64}.so
macOS:    /Applications/IDA Pro 9.x.app/Contents/MacOS/plugins/vtable64-macos-{arm64,x64}.dylib
```

**Restart** IDA Pro

---

## Quick Start

**Open Plugin**
- Keyboard: `Ctrl+Shift+V` (Win/Linux) or `Cmd+Shift+V` (macOS)
- Menu: `Edit ‚Üí Plugins ‚Üí VTableExplorer`
- Context menu: Right-click in disassembly

**Basic Workflow**

1. Open plugin to see all detected vtables
2. Search by typing class name
3. Press `Enter` to annotate and jump to vtable
4. Press `Del` to browse virtual functions
5. Press `Edit` to compare with base class (shows overrides only)
6. Press `Ins` to batch annotate all vtables

**Inheritance Analysis**

- Right-click vtable ‚Üí "Show Inheritance Tree" for visual class hierarchy
- Override comparison highlights changes: inherited (gray), overridden (green), new (blue)
- Toggle "Show All" / "Hide Inherited" to filter results

---

## Use Cases

**Runtime Hooking**

```cpp
// VTable Explorer shows: index: 42 | offset: 336
void** vtable = *(void***)pObject;
auto OnTakeDamage = (TakeDamageFn)vtable[42];  // exact index from annotation
```

**Reverse Engineering**

- Locate player/entity vtables by class name search
- Map virtual function hierarchies across inheritance
- Identify which methods derived classes override
- Track pure virtual functions and abstract classes

**Code Analysis**

- Understand polymorphic behavior patterns
- Visualize inheritance relationships
- Compare vtable implementations across class families
- Document virtual function indices for hooking frameworks

---

## Screenshots

<p align="center">
  <img src="docs/images/vtable-chooser.png" alt="VTable Chooser" width="700"/>
  <br/>
  <em>Searchable vtable browser with inheritance and pure virtual detection</em>
</p>

<p align="center">
  <img src="docs/images/function-browser.jpg" alt="Function Browser" width="700"/>
  <br/>
  <em>Virtual function browser with index and override status</em>
</p>

<p align="center">
  <img src="docs/images/annotated-vtable.jpg" alt="Annotated VTable" width="700"/>
  <br/>
  <em>Annotated vtable with function indices and byte offsets</em>
</p>

<p align="center">
  <img src="docs/images/inheritance-graph.png" alt="Inheritance Graph" width="700"/>
  <br/>
  <em>Interactive class hierarchy visualization with override statistics</em>
</p>

<p align="center">
  <img src="docs/images/chooser-context-menu.jpg" alt="Context Menu" width="700"/>
  <br/>
  <em>VTable Explorer context menu with Show Inheritance Tree and Compare with Base</em>
</p>

<p align="center">
  <img src="docs/images/ida-context-menu.jpg" alt="IDA Context Menu" width="700"/>
  <br/>
  <em>IDA disassembly view with VTable Explorer integration</em>
</p>

---

## How It Works

**Symbol Detection**

VTable Explorer scans for platform-specific vtable symbols:

```
Linux/GCC:     _ZTV6Player  ‚Üí vtable for 'Player'
Windows/MSVC:  ??_7Player@@6B@  ‚Üí Player::`vftable'
```

**RTTI Parsing**

Automatic Runtime Type Information parsing extracts:
- Base class relationships
- Multiple inheritance detection
- Virtual inheritance identification
- Class hierarchy structure

**Annotation Example**

```asm
.data:1CDB018 _ZTV6CCSBot:              ; vtable for 'CCSBot'
.data:1CDB020   dq offset _ZTI6CCSBot  ; typeinfo (RTTI metadata)
.data:1CDB028   dq offset sub_A23D00   ; index: 0 | offset: 0
.data:1CDB030   dq offset sub_A237B0   ; index: 1 | offset: 8
.data:1CDB038   dq offset sub_A283C0   ; index: 2 | offset: 16
```

**Smart Offset Detection**

- Linux/GCC: Auto-detects RTTI metadata offset (typically +2 qwords)
- Windows/MSVC: Starts at vtable base (offset 0)
- Boundary detection stops at next vtable or invalid pointers
- Tolerates up to 5 consecutive invalid entries for robust scanning

---

## Building from Source

**Prerequisites**

- IDA SDK extracted to `sdk/` directory
- Docker (for Linux/macOS builds)
- LLVM/Clang (for Windows cross-compile)

**Build Commands**

```bash
# Linux + macOS (via Docker)
make build

# Windows cross-compile (requires llvm + xwin)
make build-windows

# All platforms
make build-all
```

**Output**

Binaries in `release/`:
- `vtable64-linux-x64.so`
- `vtable64-linux-arm64.so`
- `vtable64-macos-arm64.dylib`
- `vtable64-macos-x64.dylib`
- `vtable64-windows-x64.dll`

See [docker/README.md](docker/README.md) for build details.

---

## Technical Details

**Detection Patterns**

- `_ZTV*` - Linux/GCC vtable symbols
- `??_7*@@6B@` - Windows/MSVC vftable symbols
- `*vftable*`, `*vtbl*` - Generic fallback patterns

**Class Name Extraction**

- IDA demangler integration
- Itanium C++ ABI name parser fallback
- Namespace and template support

**Pure Virtual Detection**

- `__cxa_pure_virtual` (GCC)
- `_purecall`, `purevirt` (MSVC)
- Abstract classes marked in chooser

**Annotation Strategy**

- 0-based indexing (C++ standard)
- Index + byte offset comments
- RTTI metadata skipping
- Enhanced function detection (trusts IDA auto-analysis)

**Inheritance Analysis**

- GCC: `__class_type_info` parsing
- MSVC: `_RTTICompleteObjectLocator` parsing
- Multi-level hierarchy traversal
- Virtual inheritance detection

---

## Credits

**Original concept** by [KillStr3aK](https://github.com/KillStr3aK) - Python vtable script

**Build system** adapted from [IDA-Fusion-Enhanced](https://github.com/K4ryuu/IDA-Fusion-Enhanced)

---

## License

MIT License - Free for personal and commercial use

```

`docker/Dockerfile`:

```
# Multi-platform build - all targets in one container
FROM --platform=linux/amd64 ubuntu:24.04 AS base

RUN apt-get update && apt-get install -y \
    build-essential \
    g++ \
    clang \
    cmake \
    git \
    make \
    wget \
    libssl-dev \
    lzma-dev \
    libxml2-dev \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /build
COPY src/ ./src/
COPY sdk/ ./sdk/
COPY docker/Makefile ./Makefile

# ============================================
# Linux x64 build
# ============================================
FROM base AS linux-build
ENV PLATFORM=Linux
RUN make && \
    mkdir -p /output && \
    cp release/*.so /output/vtable64-linux-x64.so

# ============================================
# Linux ARM64 build
# ============================================
FROM --platform=linux/arm64 ubuntu:24.04 AS linux-arm64-build

RUN apt-get update && apt-get install -y \
    build-essential \
    g++ \
    make \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /build
COPY src/ ./src/
COPY sdk/ ./sdk/
COPY docker/Makefile ./Makefile

ENV PLATFORM=Linux
RUN make && \
    mkdir -p /output && \
    cp release/*.so /output/vtable64-linux-arm64.so

# ============================================
# macOS osxcross - use pre-built image
# ============================================
FROM --platform=linux/amd64 crazymax/osxcross:latest-ubuntu AS osxcross

# ============================================
# macOS ARM64 build
# ============================================
FROM base AS macos-arm64-build
ENV PATH="/osxcross/bin:$PATH"
ENV LD_LIBRARY_PATH="/osxcross/lib"
ENV PLATFORM=Darwin
ENV ARCH=arm64
WORKDIR /build
COPY src/ ./src/
COPY sdk/ ./sdk/
COPY docker/Makefile ./Makefile
RUN --mount=type=bind,from=osxcross,source=/osxcross,target=/osxcross \
    make && \
    mkdir -p /output && \
    cp release/*.dylib /output/vtable64-macos-arm64.dylib

# ============================================
# macOS Intel x64 build
# ============================================
FROM base AS macos-x64-build
ENV PATH="/osxcross/bin:$PATH"
ENV LD_LIBRARY_PATH="/osxcross/lib"
ENV PLATFORM=Darwin
ENV ARCH=x86_64
WORKDIR /build
COPY src/ ./src/
COPY sdk/ ./sdk/
COPY docker/Makefile ./Makefile
RUN --mount=type=bind,from=osxcross,source=/osxcross,target=/osxcross \
    make && \
    mkdir -p /output && \
    cp release/*.dylib /output/vtable64-macos-x64.dylib

# ============================================
# Final stage - collect all artifacts
# ============================================
FROM alpine:latest AS artifacts
COPY --from=linux-build /output/vtable64-linux-x64.so /
COPY --from=linux-arm64-build /output/vtable64-linux-arm64.so /
COPY --from=macos-arm64-build /output/vtable64-macos-arm64.dylib /
COPY --from=macos-x64-build /output/vtable64-macos-x64.dylib /
CMD ["/bin/sh"]

```

`docker/Makefile`:

```
# Internal Makefile for Docker builds - no Docker check needed

# Platform detection (via env vars in Docker, uname for native)
PLATFORM ?= $(shell uname -s)

# Default values - IDA SDK requires C++17
USE_COMPILER   := g++
COMPILER_FLAGS := -O2 -std=c++17 -Wreturn-type
LINKER_FLAGS   :=

OBJ_DIR        := obj/
CPP_FILES      := $(wildcard ./src/*.cpp)

# Platform-specific settings
ifeq ($(PLATFORM),Linux)
    # Linux - GCC (official)
    USE_COMPILER   := g++
    COMPILER_FLAGS += -Wno-nontrivial-memcall -Wno-nullability-completeness -Wno-varargs
    COMPILER_FLAGS += -Isdk/src/include
    COMPILER_FLAGS += -fPIC
    COMPILER_FLAGS += -D__LINUX__ -D__EA64__
    LINKER_FLAGS   := -shared
    RELEASE_NAME   := vtable64.so

else ifeq ($(PLATFORM),Darwin)
    # macOS - Clang (official)
    ARCH           ?= arm64
    ifeq ($(ARCH),x86_64)
        USE_COMPILER   := o64-clang++
        COMPILER_FLAGS += -Wno-nullability-completeness -Wno-varargs
        COMPILER_FLAGS += -Isdk/src/include
        COMPILER_FLAGS += -D__MAC__ -D__EA64__
        COMPILER_FLAGS += -mmacosx-version-min=12.0
        COMPILER_FLAGS += -Lsdk/src/lib/x64_mac_clang_64
        RELEASE_NAME   := vtable64-macos-x64.dylib
    else
        USE_COMPILER   := oa64-clang++
        COMPILER_FLAGS += -Wno-nullability-completeness -Wno-varargs
        COMPILER_FLAGS += -Isdk/src/include
        COMPILER_FLAGS += -D__MAC__ -D__EA64__
        COMPILER_FLAGS += -mmacosx-version-min=12.0
        COMPILER_FLAGS += -Lsdk/src/lib/arm64_mac_clang_64
        RELEASE_NAME   := vtable64-macos-arm64.dylib
    endif
    LINKER_FLAGS   := -dynamiclib -undefined dynamic_lookup -lida

else
    # Windows builds not supported via Docker/MinGW due to ABI incompatibility
    # Use Clang with MSVC ABI target (clang-cl + lld-link) instead
    $(error Windows builds require MSVC ABI. Use clang-cl on Windows or cross-compile with xwin)
endif

.PHONY: all clean

all:
	@mkdir -p $(OBJ_DIR)
	@echo "Building for $(PLATFORM) with $(USE_COMPILER)..."
	@count=0; \
	for file in $(CPP_FILES); do \
	  echo "  Compiling: $$file"; \
	  $(USE_COMPILER) $$file -c -o $(OBJ_DIR)$$count.o $(COMPILER_FLAGS); \
	  count=$$((count + 1)); \
	done
	@mkdir -p release
	@echo "  Linking: $(RELEASE_NAME)"
	@$(USE_COMPILER) -o release/$(RELEASE_NAME) $(COMPILER_FLAGS) $(OBJ_DIR)*.o $(LINKER_FLAGS)
	@echo "Done: release/$(RELEASE_NAME)"

clean:
	@rm -rf $(OBJ_DIR) release/

```

`docker/README.md`:

```md
# Docker Multi-Platform Build

Cross-compile IDA-Fusion for **all platforms** from any host OS using a single multi-stage container.

## Prerequisites

- Docker installed and running
- IDA SDK extracted to `sdk/` directory

## Usage

### Build All Platforms

```bash
make build
```

Builds all 4 platforms in one multi-stage Docker container.

### Cleanup

```bash
make build-clean
```

## Output

Binaries are saved to `release/`:

- `fusion64-linux-x64.so` - Linux x64
- `fusion64-windows-x64.dll` - Windows x64
- `fusion64-macos-arm64.dylib` - macOS ARM64
- `fusion64-macos-x64.dylib` - macOS Intel x64

> **Note**: 32-bit builds are not included (IDA Pro 7.5+ is 64-bit only)

## Implementation

**Files:**
- `Dockerfile` - Multi-stage build for all platforms
- `Makefile` - Platform-specific build logic (no Docker check)

**Build stages:**
- **Linux**: Ubuntu 22.04 with g++
- **Windows**: Ubuntu 22.04 with MinGW cross-compiler
- **macOS ARM64**: Ubuntu 22.04 with osxcross (MacOSX13.3 SDK)
- **macOS x64**: Ubuntu 22.04 with osxcross (MacOSX13.3 SDK)

All artifacts are collected in a final `scratch` stage for extraction. Containers are automatically cleaned up after build.

```

`src/inheritance_graph.h`:

```h
#pragma once
#include <ida.hpp>
#include <graph.hpp>
#include <kernwin.hpp>
#include <moves.hpp>
#include <map>
#include <set>
#include <string>
#include "rtti_parser.h"
#include "vtable_comparison.h"
#include "vtable_utils.h"

namespace inheritance_graph {

struct graph_data_t {
    std::map<int, std::string> node_labels;
    std::map<int, ea_t> node_vtables;
    std::map<int, uint32> node_colors;
    std::map<int, std::vector<int>> edges;  // node -> children
    int node_count = 0;
    std::string current_class;
    int current_node = -1;

    int add_node(const std::string& label, ea_t vtable_addr, uint32 bg_color) {
        int node = node_count++;
        node_labels[node] = label;
        node_vtables[node] = vtable_addr;
        node_colors[node] = bg_color;
        edges[node] = std::vector<int>();
        return node;
    }

    void add_edge(int from, int to) {
        edges[from].push_back(to);
    }

    ea_t get_vtable(int node) const {
        auto it = node_vtables.find(node);
        return it != node_vtables.end() ? it->second : BADADDR;
    }
};

inline void collect_ancestors(
    const std::string& cls,
    const std::map<std::string, const VTableInfo*>& vtable_map,
    std::set<std::string>& lineage)
{
    auto it = vtable_map.find(cls);
    if (it == vtable_map.end()) return;

    const VTableInfo* vt = it->second;

    if (vt->is_intermediate && !vt->parent_class.empty()) {
        if (lineage.insert(vt->parent_class).second)
            collect_ancestors(vt->parent_class, vtable_map, lineage);
        return;
    }

    for (const auto& base : vt->base_classes) {
        if (lineage.insert(base).second)
            collect_ancestors(base, vtable_map, lineage);
    }
}

inline void collect_descendants(
    const std::string& cls,
    const std::vector<VTableInfo>* all_vtables,
    std::set<std::string>& lineage)
{
    for (const auto& vt : *all_vtables) {
        for (const auto& base : vt.base_classes) {
            if (base == cls && lineage.insert(vt.class_name).second) {
                collect_descendants(vt.class_name, all_vtables, lineage);
                break;
            }
        }
    }
}


static ssize_t idaapi graph_callback(void *ud, int code, va_list va) {
    graph_data_t *data = (graph_data_t *)ud;

    switch (code) {
        case grcode_user_refresh: return 1;

        case grcode_clicked: {
            va_arg(va, graph_viewer_t *);
            selection_item_t *item = va_arg(va, selection_item_t *);
            if (item && item->is_node) {
                ea_t addr = data->get_vtable(item->node);
                if (addr != BADADDR) jumpto(addr);
            }
            return 0;
        }

        case grcode_dblclicked: {
            graph_viewer_t *gv = va_arg(va, graph_viewer_t *);
            selection_item_t *item = va_arg(va, selection_item_t *);
            if (item && item->is_node) viewer_center_on(gv, item->node);
            return 0;
        }

        case grcode_destroyed:
            delete data;
            return 0;

        default: break;
    }
    return 0;
}


inline void calc_stats(ea_t child, ea_t parent, bool is_win,
                       const std::vector<ea_t>& sorted,
                       int& inherited, int& overridden, int& new_funcs)
{
    inherited = overridden = new_funcs = 0;
    if (child == BADADDR || parent == BADADDR) return;

    auto cmp = vtable_comparison::compare_vtables(child, parent, is_win, sorted);
    inherited = cmp.inherited_count;
    overridden = cmp.overridden_count;
    new_funcs = cmp.new_virtual_count;
}

inline void pad_line(char* out, int sz, const char* lbl, const char* val, int w) {
    int pad = w - 4 - strlen(lbl) - strlen(val);
    if (pad < 1) pad = 1;

    char* p = out;
    p += qsnprintf(p, sz, "  %s", lbl);
    for (int i = 0; i < pad && (p - out) < sz - 3; i++) *p++ = ' ';
    qsnprintf(p, sz - (p - out), "%s  ", val);
}

inline void show_inheritance_graph(
    const std::string& class_name,
    ea_t vtable_addr,
    bool is_windows,
    const std::vector<VTableInfo>* all_vtables)
{
    TWidget* existing = find_widget("Inheritance Lineage");
    if (existing) {
        close_widget(existing, WCLS_DONT_SAVE_SIZE);
    }

    if (!all_vtables || all_vtables->empty()) {
        warning("No vtables available");
        return;
    }

    show_wait_box("Building lineage...");

    std::map<std::string, const VTableInfo*> vtable_map;
    std::vector<ea_t> sorted_vtables;
    sorted_vtables.reserve(all_vtables->size());
    for (const auto& vt : *all_vtables) {
        vtable_map[vt.class_name] = &vt;
        sorted_vtables.push_back(vt.address);
    }
    std::sort(sorted_vtables.begin(), sorted_vtables.end());

    std::set<std::string> lineage;
    lineage.insert(class_name);  // Add selected class

    size_t before_ancestors = lineage.size();
    collect_ancestors(class_name, vtable_map, lineage);  // Add all parents up to root
    size_t ancestors_count = lineage.size() - before_ancestors;

    size_t before_descendants = lineage.size();
    collect_descendants(class_name, all_vtables, lineage);  // Add all children down
    size_t descendants_count = lineage.size() - before_descendants;

    graph_data_t *data = new graph_data_t();
    std::map<std::string, int> class_to_node;

    using namespace vtable_utils;
    const uint32 NORMAL_COLOR = GRAPH_NORMAL;     // Medium-dark tan (good contrast)
    const uint32 SELECTED_COLOR = GRAPH_SELECTED; // Lighter tan for selection highlight
    const uint32 ABSTRACT_COLOR = GRAPH_ABSTRACT; // Medium purple (good contrast)

    for (const std::string& cls : lineage) {
        auto it = vtable_map.find(cls);

        bool found = (it != vtable_map.end());
        const VTableInfo* vt = found ? it->second : nullptr;
        bool is_intermediate = found ? vt->is_intermediate : true;

        char label[1024];
        char lines[10][256];
        int line_count = 0;
        bool is_abstract = (found && !is_intermediate) ? (vt->pure_virtual_count > 0) : false;

        // Intermediate node
        if (!found || is_intermediate) {
            bool is_selected = (cls == class_name);
            if (is_selected) {
                qsnprintf(lines[line_count++], 256, "  %s (SELECTED)  ", cls.c_str());
            } else {
                qsnprintf(lines[line_count++], 256, "  %s  ", cls.c_str());
            }

            int name_len = strlen(lines[0]);
            const int LINE_WIDTH = (name_len > 50) ? name_len : 50;
            if (name_len < LINE_WIDTH) {
                for (int i = name_len; i < LINE_WIDTH && i < 255; i++) {
                    lines[0][i] = ' ';
                }
                lines[0][LINE_WIDTH] = '\0';
            }

            int sep_idx = 0;
            lines[line_count][sep_idx++] = ' ';
            lines[line_count][sep_idx++] = ' ';
            for (int i = 2; i < LINE_WIDTH - 2 && sep_idx < 255; i++) {
                lines[line_count][sep_idx++] = '-';
            }
            lines[line_count][sep_idx++] = ' ';
            lines[line_count][sep_idx++] = ' ';
            lines[line_count][sep_idx] = '\0';
            line_count++;

            if (found && vt->parent_vtable_addr != BADADDR) {
                char parent_ref[64];
                qsnprintf(parent_ref, sizeof(parent_ref), "uses %s", vt->parent_class.c_str());
                pad_line(lines[line_count++], 256, "VTable  :", parent_ref, LINE_WIDTH);
            } else {
                pad_line(lines[line_count++], 256, "VTable  :", "(none)", LINE_WIDTH);
            }
            pad_line(lines[line_count++], 256, "Type    :", "Inlined by compiler", LINE_WIDTH);

            label[0] = '\0';
            for (int i = 0; i < line_count; i++) {
                if (i > 0) qstrncat(label, "\n", sizeof(label) - strlen(label) - 1);
                qstrncat(label, lines[i], sizeof(label) - strlen(label) - 1);
            }

            uint32 color = is_selected ? SELECTED_COLOR : 0x808080;
            ea_t node_addr = (found && vt->parent_vtable_addr != BADADDR) ? vt->parent_vtable_addr : BADADDR;
            int node = data->add_node(label, node_addr, color);
            class_to_node[cls] = node;
            continue;
        }

        bool is_selected = (cls == class_name);
        if (is_selected && is_abstract) {
            qsnprintf(lines[line_count++], 256, "  %s [abstract] (SELECTED)  ", cls.c_str());
        } else if (is_selected) {
            qsnprintf(lines[line_count++], 256, "  %s (SELECTED)  ", cls.c_str());
        } else if (is_abstract) {
            qsnprintf(lines[line_count++], 256, "  %s [abstract]  ", cls.c_str());
        } else {
            qsnprintf(lines[line_count++], 256, "  %s  ", cls.c_str());
        }

        int name_len = strlen(lines[0]);
        const int LINE_WIDTH = (name_len > 50) ? name_len : 50;

        if (name_len < LINE_WIDTH) {
            for (int i = name_len; i < LINE_WIDTH && i < 255; i++) {
                lines[0][i] = ' ';
            }
            lines[0][LINE_WIDTH] = '\0';
        }

        int sep_idx = 0;
        lines[line_count][sep_idx++] = ' ';
        lines[line_count][sep_idx++] = ' ';
        for (int i = 2; i < LINE_WIDTH - 2 && sep_idx < 255; i++) {
            lines[line_count][sep_idx++] = '-';
        }
        lines[line_count][sep_idx++] = ' ';
        lines[line_count][sep_idx++] = ' ';
        lines[line_count][sep_idx] = '\0';
        line_count++;

        char addr_val[32];
        qsnprintf(addr_val, sizeof(addr_val), "0x%llX", (unsigned long long)vt->address);
        pad_line(lines[line_count++], 256, "Addr    :", addr_val, LINE_WIDTH);

        char funcs_val[32];
        if (is_abstract) {
            qsnprintf(funcs_val, sizeof(funcs_val), "%d (%d pure)", vt->func_count, vt->pure_virtual_count);
        } else {
            qsnprintf(funcs_val, sizeof(funcs_val), "%d", vt->func_count);
        }
        pad_line(lines[line_count++], 256, "Funcs   :", funcs_val, LINE_WIDTH);

        char parent_val[128];
        ea_t parent_vtable_addr = BADADDR;
        std::string stats_parent_name;
        if (!vt->base_classes.empty()) {
            const char* parent_name = vt->base_classes[0].c_str();
            if (vt->base_classes.size() > 1) {
                qsnprintf(parent_val, sizeof(parent_val), "%s (+%d)", parent_name, (int)vt->base_classes.size() - 1);
            } else {
                qsnprintf(parent_val, sizeof(parent_val), "%s", parent_name);
            }
            for (const auto& base : vt->base_classes) {
                auto parent_it = vtable_map.find(base);
                if (parent_it != vtable_map.end() && !parent_it->second->is_intermediate) {
                    parent_vtable_addr = parent_it->second->address;
                    stats_parent_name = base;
                    break;
                }
            }
        } else {
            qsnprintf(parent_val, sizeof(parent_val), "(root)");
        }
        pad_line(lines[line_count++], 256, "Parent  :", parent_val, LINE_WIDTH);

        char kids_val[16];
        qsnprintf(kids_val, sizeof(kids_val), "%d", vt->derived_count);
        pad_line(lines[line_count++], 256, "Children:", kids_val, LINE_WIDTH);

        if (parent_vtable_addr != BADADDR) {
            int inherited = 0, overridden = 0, new_funcs = 0;
            calc_stats(vt->address, parent_vtable_addr, vt->is_windows, sorted_vtables, inherited, overridden, new_funcs);

            char inh_val[16], ovr_val[16], new_val[16];
            qsnprintf(inh_val, sizeof(inh_val), "%d", inherited);
            qsnprintf(ovr_val, sizeof(ovr_val), "%d", overridden);
            qsnprintf(new_val, sizeof(new_val), "%d", new_funcs);

            pad_line(lines[line_count++], 256, "Inherit :", inh_val, LINE_WIDTH);
            pad_line(lines[line_count++], 256, "Override:", ovr_val, LINE_WIDTH);
            pad_line(lines[line_count++], 256, "New     :", new_val, LINE_WIDTH);
        }

        label[0] = '\0';
        for (int i = 0; i < line_count; i++) {
            if (i > 0) qstrncat(label, "\n", sizeof(label) - strlen(label) - 1);
            qstrncat(label, lines[i], sizeof(label) - strlen(label) - 1);
        }

        uint32 color = (cls == class_name) ? SELECTED_COLOR : is_abstract ? ABSTRACT_COLOR : NORMAL_COLOR;

        int node = data->add_node(label, vt->address, color);
        class_to_node[cls] = node;
    }

    // Edges
    for (const std::string& cls : lineage) {
        auto it = vtable_map.find(cls);
        int child_node = class_to_node[cls];

        if (it == vtable_map.end()) {
            for (const auto& [other_cls, other_vt] : vtable_map) {
                for (size_t i = 0; i < other_vt->base_classes.size(); ++i) {
                    if (other_vt->base_classes[i] == cls) {
                        if (i + 1 < other_vt->base_classes.size()) {
                            const std::string& parent = other_vt->base_classes[i + 1];
                            auto parent_it = class_to_node.find(parent);
                            if (parent_it != class_to_node.end()) {
                                data->add_edge(parent_it->second, child_node);
                            }
                        }
                        goto next_class;
                    }
                }
            }
            next_class:
            continue;
        }

        // Intermediate: use parent_class field
        if (it->second->is_intermediate && !it->second->parent_class.empty()) {
            auto parent_it = class_to_node.find(it->second->parent_class);
            if (parent_it != class_to_node.end()) {
                data->add_edge(parent_it->second, child_node);
            }
            continue;
        }

        if (!it->second->base_classes.empty()) {
            const std::string& direct_parent = it->second->base_classes[0];
            auto parent_it = class_to_node.find(direct_parent);
            if (parent_it != class_to_node.end()) {
                data->add_edge(parent_it->second, child_node);
            }
        }
    }

    interactive_graph_t* graph = create_interactive_graph(10000 + rand());

    for (int i = 0; i < data->node_count; i++)
        graph->resize(i + 1);

    for (int i = 0; i < data->node_count; i++) {
        node_info_t ni;
        ni.text = data->node_labels[i].c_str();
        ni.ea = data->node_vtables[i];
        ni.bg_color = data->node_colors[i];
        set_node_info(graph->gid, i, ni, NIF_TEXT | NIF_BG_COLOR | NIF_EA);
    }

    for (const auto& [from, tos] : data->edges) {
        for (int to : tos) {
            edge_info_t ei;
            graph->add_edge(from, to, &ei);
        }
    }

    graph_viewer_t* viewer = create_graph_viewer("Inheritance Lineage", graph->gid, graph_callback, data, 0);
    set_viewer_graph(viewer, graph);
    graph->del_custom_layout();
    graph->create_digraph_layout();

    display_widget(viewer, WOPN_DP_TAB | WOPN_PERSIST);
    refresh_viewer(viewer);

    int selected_node = class_to_node[class_name];
    viewer_center_on(viewer, selected_node);

    graph_location_info_t gli;
    gli.zoom = 1.0;
    viewer_set_gli(viewer, &gli, 0);

    refresh_viewer(viewer);

    hide_wait_box();
}

} // namespace inheritance_graph

```

`src/main.cpp`:

```cpp
#include <ida.hpp>
#include <idp.hpp>
#include <loader.hpp>
#include <kernwin.hpp>
#include "vtable_chooser.h"

#define PLUGIN_VERSION "1.2.3"
#define PLUGIN_DESCRIPTION "VTable Explorer v" PLUGIN_VERSION " - Graph-based inheritance view & high quality vtable analysis"

struct vtable_explorer_action_t : public action_handler_t {
    virtual int idaapi activate(action_activation_ctx_t*) override {
        show_vtable_chooser();
        return 1;
    }

    virtual action_state_t idaapi update(action_update_ctx_t*) override {
        return AST_ENABLE_ALWAYS;
    }
};

struct vtable_tree_action_t : public action_handler_t {
    virtual int idaapi activate(action_activation_ctx_t* ctx) override {
        show_inheritance_tree_action(ctx);
        return 1;
    }

    virtual action_state_t idaapi update(action_update_ctx_t*) override {
        return AST_ENABLE_ALWAYS;
    }
};

struct vtable_compare_action_t : public action_handler_t {
    virtual int idaapi activate(action_activation_ctx_t* ctx) override {
        show_compare_base_action(ctx);
        return 1;
    }

    virtual action_state_t idaapi update(action_update_ctx_t*) override {
        return AST_ENABLE_ALWAYS;
    }
};

struct funcbrowser_jump_action_t : public action_handler_t {
    virtual int idaapi activate(action_activation_ctx_t* ctx) override {
        funcbrowser_jump_action(ctx);
        return 1;
    }

    virtual action_state_t idaapi update(action_update_ctx_t*) override {
        return AST_ENABLE_ALWAYS;
    }
};

struct compbrowser_jump_derived_action_t : public action_handler_t {
    virtual int idaapi activate(action_activation_ctx_t* ctx) override {
        compbrowser_jump_derived_action(ctx);
        return 1;
    }

    virtual action_state_t idaapi update(action_update_ctx_t*) override {
        return AST_ENABLE_ALWAYS;
    }
};

struct compbrowser_jump_base_action_t : public action_handler_t {
    virtual int idaapi activate(action_activation_ctx_t* ctx) override {
        compbrowser_jump_base_action(ctx);
        return 1;
    }

    virtual action_state_t idaapi update(action_update_ctx_t*) override {
        return AST_ENABLE_ALWAYS;
    }
};

struct compbrowser_toggle_action_t : public action_handler_t {
    virtual int idaapi activate(action_activation_ctx_t* ctx) override {
        compbrowser_toggle_action(ctx);
        return 1;
    }

    virtual action_state_t idaapi update(action_update_ctx_t*) override {
        return AST_ENABLE_ALWAYS;
    }
};

struct browse_functions_action_t : public action_handler_t {
    virtual int idaapi activate(action_activation_ctx_t* ctx) override {
        browse_functions_action(ctx);
        return 1;
    }

    virtual action_state_t idaapi update(action_update_ctx_t*) override {
        return AST_ENABLE_ALWAYS;
    }
};

struct annotate_all_action_t : public action_handler_t {
    virtual int idaapi activate(action_activation_ctx_t* ctx) override {
        annotate_all_action(ctx);
        return 1;
    }

    virtual action_state_t idaapi update(action_update_ctx_t*) override {
        return AST_ENABLE_ALWAYS;
    }
};

static vtable_explorer_action_t ah_explorer;
static vtable_tree_action_t ah_tree;
static vtable_compare_action_t ah_compare;
static funcbrowser_jump_action_t ah_funcjump;
static compbrowser_jump_derived_action_t ah_compjump_derived;
static compbrowser_jump_base_action_t ah_compjump_base;
static compbrowser_toggle_action_t ah_comptoggle;
static browse_functions_action_t ah_browse_funcs;
static annotate_all_action_t ah_annotate_all;

struct ui_event_listener_t : public event_listener_t {
    virtual ssize_t idaapi on_event(ssize_t code, va_list va) override {
        if (code == ui_finish_populating_widget_popup) {
            TWidget* widget = va_arg(va, TWidget*);
            TPopupMenu* popup = va_arg(va, TPopupMenu*);

            if (get_widget_type(widget) == BWN_DISASM || get_widget_type(widget) == BWN_PSEUDOCODE) {
                attach_action_to_popup(widget, popup, "-", nullptr, SETMENU_APP);
                attach_action_to_popup(widget, popup, "vtable:explorer", nullptr, SETMENU_APP);
            }
            else if (get_widget_type(widget) == BWN_CHOOSER) {
                qstring title;
                get_widget_title(&title, widget);
                if (title == "VTable Explorer") {
                    attach_action_to_popup(widget, popup, "-", nullptr, SETMENU_APP);
                    attach_action_to_popup(widget, popup, "vtable:browse_funcs", nullptr, SETMENU_APP);
                    attach_action_to_popup(widget, popup, "vtable:tree", nullptr, SETMENU_APP);
                    attach_action_to_popup(widget, popup, "vtable:compare", nullptr, SETMENU_APP);
                    attach_action_to_popup(widget, popup, "-", nullptr, SETMENU_APP);
                    attach_action_to_popup(widget, popup, "vtable:annotate_all", nullptr, SETMENU_APP);
                }
                else if (title.find("Functions:") == 0) {
                    attach_action_to_popup(widget, popup, "-", nullptr, SETMENU_APP);
                    attach_action_to_popup(widget, popup, "funcbrowser:jump", nullptr, SETMENU_APP);
                }
                else if (title.find("Compare:") == 0 || title == "VTable Comparison") {
                    attach_action_to_popup(widget, popup, "-", nullptr, SETMENU_APP);
                    attach_action_to_popup(widget, popup, "compbrowser:jump_derived", nullptr, SETMENU_APP);
                    attach_action_to_popup(widget, popup, "compbrowser:jump_base", nullptr, SETMENU_APP);
                    attach_action_to_popup(widget, popup, "compbrowser:toggle", nullptr, SETMENU_APP);
                }
            }
        }
        return 0;
    }
};

static ui_event_listener_t ui_listener;

struct vtable_plugin_ctx_t : public plugmod_t {
    virtual bool idaapi run(size_t) override {
        return true;
    }

    virtual ~vtable_plugin_ctx_t() {
        unregister_action("vtable:explorer");
        unregister_action("vtable:tree");
        unregister_action("vtable:compare");
        unregister_action("vtable:browse_funcs");
        unregister_action("vtable:annotate_all");
        unregister_action("funcbrowser:jump");
        unregister_action("compbrowser:jump_derived");
        unregister_action("compbrowser:jump_base");
        unregister_action("compbrowser:toggle");
        unhook_event_listener(HT_UI, &ui_listener);
    }
};

plugmod_t* idaapi init() {
    action_desc_t desc_explorer = ACTION_DESC_LITERAL(
        "vtable:explorer",
        "VTable Explorer",
        &ah_explorer,
        nullptr,
        "Open VTable Explorer with searchable class list",
        -1
    );

    action_desc_t desc_tree = ACTION_DESC_LITERAL(
        "vtable:tree",
        "Show Inheritance Tree",
        &ah_tree,
        nullptr,
        "Show inheritance graph for selected class",
        -1
    );

    action_desc_t desc_compare = ACTION_DESC_LITERAL(
        "vtable:compare",
        "Compare with Base",
        &ah_compare,
        nullptr,
        "Compare vtable with base class",
        -1
    );

    action_desc_t desc_funcjump = ACTION_DESC_LITERAL(
        "funcbrowser:jump",
        "Jump to Function",
        &ah_funcjump,
        nullptr,
        "Jump to selected virtual function",
        -1
    );

    action_desc_t desc_compjump_derived = ACTION_DESC_LITERAL(
        "compbrowser:jump_derived",
        "Jump to Derived Function",
        &ah_compjump_derived,
        nullptr,
        "Jump to derived class function",
        -1
    );

    action_desc_t desc_compjump_base = ACTION_DESC_LITERAL(
        "compbrowser:jump_base",
        "Jump to Base Function",
        &ah_compjump_base,
        nullptr,
        "Jump to base class function",
        -1
    );

    action_desc_t desc_comptoggle = ACTION_DESC_LITERAL(
        "compbrowser:toggle",
        "Toggle Inherited Functions",
        &ah_comptoggle,
        nullptr,
        "Toggle display of inherited functions",
        -1
    );

    action_desc_t desc_browse_funcs = ACTION_DESC_LITERAL(
        "vtable:browse_funcs",
        "Browse Functions",
        &ah_browse_funcs,
        nullptr,
        "Browse virtual functions in selected vtable",
        -1
    );

    action_desc_t desc_annotate_all = ACTION_DESC_LITERAL(
        "vtable:annotate_all",
        "Annotate All VTables",
        &ah_annotate_all,
        nullptr,
        "Annotate all vtables with function indices",
        -1
    );

    register_action(desc_explorer);
    register_action(desc_tree);
    register_action(desc_compare);
    register_action(desc_browse_funcs);
    register_action(desc_annotate_all);
    register_action(desc_funcjump);
    register_action(desc_compjump_derived);
    register_action(desc_compjump_base);
    register_action(desc_comptoggle);

    hook_event_listener(HT_UI, &ui_listener, nullptr, 0);

    return new vtable_plugin_ctx_t;
}

plugin_t PLUGIN = {
    IDP_INTERFACE_VERSION,
    PLUGIN_MULTI,
    init,
    nullptr,
    nullptr,
    PLUGIN_DESCRIPTION,
    "https://github.com/K4ryuu/IDA-VTableExplorer",
    "VTableExplorer",
    nullptr
};

```

`src/rtti_detector.h`:

```h
#pragma once
#include <ida.hpp>
#include <idp.hpp>
#include <name.hpp>
#include <bytes.hpp>
#include "vtable_utils.h"

namespace rtti_detector {

using vtable_utils::get_ptr_size;
using vtable_utils::read_ptr;

struct RTTIConfig {
    bool is_msvc = false;
    bool use_64bit_ptrs = false;
    int rtti_offset = -8;
    bool detected = false;
};

static RTTIConfig g_config;

// Format detection
inline bool is_pe_file() {
    char ftype[64];
    return get_file_type_name(ftype, sizeof(ftype)) && strstr(ftype, "PE");
}

inline bool is_elf_file() {
    char ftype[64];
    return get_file_type_name(ftype, sizeof(ftype)) && strstr(ftype, "ELF");
}

inline bool has_msvc_mangling(ea_t addr) {
    qstring name;
    return get_name(&name, addr) && name.length() >= 4 && strncmp(name.c_str(), "??_7", 4) == 0;
}

inline bool has_gcc_mangling(ea_t addr) {
    qstring name;
    return get_name(&name, addr) && name.length() >= 4 && strncmp(name.c_str(), "_ZTV", 4) == 0;
}

// MSVC COL validation
inline bool validate_msvc_col(ea_t col_addr) {
    if (!is_mapped(col_addr)) return false;

    uint32 sig = get_dword(col_addr);
    if (sig > 2) return false;

    const int ptr_size = get_ptr_size();
    int32 type_rva = get_dword(col_addr + 12);
    int32 class_rva = get_dword(col_addr + 16);

    ea_t type_addr, class_addr;
    if (ptr_size == 8) {
        ea_t base = get_imagebase();
        if (base == BADADDR) return false;
        type_addr = base + type_rva;
        class_addr = base + class_rva;
    } else {
        type_addr = type_rva;
        class_addr = class_rva;
    }

    if (!is_mapped(type_addr) || !is_mapped(class_addr)) return false;
    if (get_dword(class_addr) != 0) return false;
    if (get_dword(class_addr + 8) > 64) return false;

    return true;
}

// GCC typeinfo validation
inline bool validate_gcc_typeinfo(ea_t ti_addr) {
    if (!is_mapped(ti_addr)) return false;

    ea_t vtbl = read_ptr(ti_addr);
    if (!is_mapped(vtbl)) return false;

    ea_t name = read_ptr(ti_addr + get_ptr_size());
    if (!is_mapped(name)) return false;

    char prefix[5] = {0};
    for (int i = 0; i < 4; i++) {
        prefix[i] = get_byte(name + i);
        if (!isprint(prefix[i]) && prefix[i] != '_') return false;
    }
    return strcmp(prefix, "_ZTS") == 0;
}

// MSVC x64: detect if using 64-bit pointers or 32-bit RVAs
inline bool detect_msvc_64bit_ptr_format(ea_t vtable) {
    ea_t base = get_imagebase();
    if (base == BADADDR) return true;

    ea_t ptr64 = get_qword(vtable - 8);
    if (is_mapped(ptr64) && validate_msvc_col(ptr64)) return true;

    uint32 rva = get_dword(vtable - 8);
    if (is_mapped(base + rva) && validate_msvc_col(base + rva)) return false;

    return true;
}

// Find RTTI offset by probing common locations
inline int detect_rtti_offset(ea_t vtable, bool is_msvc) {
    static const int offsets[] = {-8, -16, 8, 0, 16, -24, 24};
    const int ptr_size = get_ptr_size();

    for (int off : offsets) {
        ea_t probe = vtable + off;
        if (!is_mapped(probe)) continue;

        if (is_msvc) {
            ea_t col = (ptr_size == 8) ? get_qword(probe) : get_dword(probe);
            if (is_mapped(col) && validate_msvc_col(col)) return off;

            if (ptr_size == 8) {
                ea_t base = get_imagebase();
                if (base != BADADDR) {
                    col = base + get_dword(probe);
                    if (is_mapped(col) && validate_msvc_col(col)) return off;
                }
            }
        } else {
            ea_t ti = read_ptr(probe);
            if (is_mapped(ti) && validate_gcc_typeinfo(ti)) return off;
        }
    }
    return -8;
}

// Main detection
inline RTTIConfig auto_detect(ea_t vtable) {
    RTTIConfig cfg;
    cfg.is_msvc = has_msvc_mangling(vtable) || (!has_gcc_mangling(vtable) && is_pe_file());

    if (cfg.is_msvc && get_ptr_size() == 8)
        cfg.use_64bit_ptrs = detect_msvc_64bit_ptr_format(vtable);

    cfg.rtti_offset = detect_rtti_offset(vtable, cfg.is_msvc);
    cfg.detected = true;
    return cfg;
}

inline const RTTIConfig& get_config(ea_t vtable) {
    if (!g_config.detected) g_config = auto_detect(vtable);
    return g_config;
}

inline void reset_config() { g_config = RTTIConfig(); }

} // namespace rtti_detector

```

`src/rtti_parser.h`:

```h
#pragma once
#include <ida.hpp>
#include <idp.hpp>
#include <bytes.hpp>
#include <name.hpp>
#include <demangle.hpp>
#include <segment.hpp>
#include <vector>
#include <string>
#include <map>
#include <algorithm>
#include "vtable_utils.h"
#include "rtti_detector.h"

namespace rtti_parser {

using vtable_utils::get_ptr_size;
using vtable_utils::read_ptr;
using vtable_utils::read_int32;

struct BaseClassInfo {
    std::string class_name;
    ea_t vtable_addr = BADADDR;
    int offset = 0;
    bool is_virtual = false;
};

struct InheritanceInfo {
    std::string class_name;
    std::vector<BaseClassInfo> base_classes;
    bool has_multiple_inheritance = false;
    bool has_virtual_inheritance = false;
};

namespace gcc_rtti {

inline std::string read_string(ea_t addr) {
    if (!is_mapped(addr)) return "";
    std::string r;
    r.reserve(128);
    for (int i = 0; i < vtable_utils::MAX_RTTI_STRING_LENGTH; ++i) {
        char c = get_byte(addr + i);
        if (!c || (!isprint(c) && c != '_')) break;
        r.push_back(c);
    }
    return r;
}

inline std::string extract_class_from_mangled(const std::string& m) {
    if (m.empty()) return "";

    // _ZTS prefix
    if (m.compare(0, 4, "_ZTS") == 0 && m.length() > 4) {
        const char* p = m.c_str() + 4;
        if (isdigit(*p)) {
            int len = atoi(p);
            while (isdigit(*p)) ++p;
            if (len > 0 && len < 256 && strlen(p) >= (size_t)len)
                return std::string(p, len);
        }
    }

    // Nested name (N...E)
    if (m[0] == 'N') {
        std::string r;
        const char* p = m.c_str() + 1;
        while (*p && *p != 'E') {
            if (!isdigit(*p)) break;
            int len = atoi(p);
            while (isdigit(*p)) ++p;
            if (len <= 0 || len >= 256 || strlen(p) < (size_t)len) break;
            if (!r.empty()) r += "::";
            r.append(p, len);
            p += len;
        }
        if (!r.empty()) return r;
    }
    // Simple name
    else if (isdigit(m[0])) {
        const char* p = m.c_str();
        int len = atoi(p);
        while (isdigit(*p)) ++p;
        if (len > 0 && len < 256 && strlen(p) >= (size_t)len)
            return std::string(p, len);
    }

    // Fallback: demangle
    qstring dem;
    if (demangle_name(&dem, m.c_str(), MNG_NODEFINIT) > 0) {
        std::string s = dem.c_str();
        size_t pos = s.find("typeinfo for ");
        return (pos != std::string::npos) ? s.substr(pos + 13) : s;
    }
    return "";
}

inline InheritanceInfo parse_gcc_typeinfo(ea_t ti_addr, const std::string& derived) {
    InheritanceInfo info;
    info.class_name = derived;
    if (!is_mapped(ti_addr)) return info;

    const int ps = get_ptr_size();
    ea_t vt = read_ptr(ti_addr);
    ea_t name = read_ptr(ti_addr + ps);

    if (vt == BADADDR || name == BADADDR) return info;

    qstring vt_name;
    bool got = get_name(&vt_name, vt) && vt_name.find("off_") != 0;

    if (!got) {
        ea_t indirect = read_ptr(vt);
        if (indirect != BADADDR && is_mapped(indirect))
            got = get_name(&vt_name, indirect);

        if (!got) {
            // Try to get base from structure
            ea_t base_ti = read_ptr(ti_addr + 2 * ps);
            if (base_ti != BADADDR && is_mapped(base_ti)) {
                ea_t bn = read_ptr(base_ti + ps);
                if (bn != BADADDR) {
                    std::string bc = extract_class_from_mangled(read_string(bn));
                    if (!bc.empty()) {
                        BaseClassInfo b;
                        b.class_name = bc;
                        info.base_classes.push_back(b);
                    }
                }
            }
            return info;
        }
    }

    const char* n = vt_name.c_str();

    // Single inheritance
    if (strstr(n, "__si_class_type_info")) {
        ea_t base_ti = read_ptr(ti_addr + 2 * ps);
        if (base_ti != BADADDR) {
            ea_t bn = read_ptr(base_ti + ps);
            if (bn != BADADDR) {
                std::string bc = extract_class_from_mangled(read_string(bn));
                if (!bc.empty()) {
                    BaseClassInfo b;
                    b.class_name = bc;
                    info.base_classes.push_back(b);
                }
            }
        }
    }
    // Multiple/virtual inheritance
    else if (strstr(n, "__vmi_class_type_info")) {
        info.has_multiple_inheritance = true;
        int32 flags = read_int32(ti_addr + 2 * ps);
        int32 cnt = read_int32(ti_addr + 3 * ps);
        if (flags & 1) info.has_virtual_inheritance = true;

        if (cnt > 0 && cnt < 32) {
            ea_t arr = ti_addr + 4 * ps;
            for (int32 i = 0; i < cnt; ++i) {
                ea_t entry = arr + (i * 2 * ps);
                ea_t base_ti = read_ptr(entry);
                int32 off_flags = read_int32(entry + ps);
                if (base_ti != BADADDR) {
                    ea_t bn = read_ptr(base_ti + ps);
                    if (bn != BADADDR) {
                        std::string bc = extract_class_from_mangled(read_string(bn));
                        if (!bc.empty()) {
                            BaseClassInfo b;
                            b.class_name = bc;
                            b.offset = off_flags >> 8;
                            b.is_virtual = (off_flags & 1) != 0;
                            info.base_classes.push_back(b);
                        }
                    }
                }
            }
        }
    }
    return info;
}

} // namespace gcc_rtti

namespace msvc_rtti {

using vtable_utils::normalize_msvc_nested_class;
using vtable_utils::clean_msvc_decorated_name;

inline ea_t rva_to_va(ea_t base, int32 rva) {
    return rva ? base + rva : BADADDR;
}

inline std::string read_msvc_type_name(ea_t td) {
    if (!is_mapped(td)) return "";

    const int ps = get_ptr_size();
    ea_t name_addr = td + 2 * ps;

    std::string raw;
    raw.reserve(128);
    for (int i = 0; i < vtable_utils::MAX_RTTI_STRING_LENGTH; ++i) {
        char c = get_byte(name_addr + i);
        if (!c || (!isprint(c) && c != '_')) break;
        raw.push_back(c);
    }

    const char* to_dem = raw.c_str();
    if (!raw.empty() && raw[0] == '.') to_dem++;

    qstring dem;
    if (demangle_name(&dem, to_dem, MNG_NODEFINIT) > 0 && dem.length() > 0) {
        std::string s = dem.c_str();
        if (s.compare(0, 6, "class ") == 0) s = s.substr(6);
        else if (s.compare(0, 7, "struct ") == 0) s = s.substr(7);
        else if (s.compare(0, 6, "union ") == 0) s = s.substr(6);
        return normalize_msvc_nested_class(clean_msvc_decorated_name(s));
    }

    // Manual parse: .?AV or .?AU prefix
    if (raw.length() > 4 && (raw.compare(0, 4, ".?AV") == 0 || raw.compare(0, 4, ".?AU") == 0)) {
        size_t end = raw.find("@@", 4);
        if (end != std::string::npos) {
            std::string n = raw.substr(4, end - 4);
            if (n.length() > 2 && n.compare(0, 2, "?$") == 0) {
                size_t te = n.find('@', 2);
                return (te != std::string::npos) ? n.substr(2, te - 2) : n.substr(2);
            }
            return normalize_msvc_nested_class(n);
        }
    }
    return normalize_msvc_nested_class(raw);
}

inline InheritanceInfo parse_msvc_col(ea_t col, const std::string& derived) {
    InheritanceInfo info;
    info.class_name = derived;
    if (!is_mapped(col)) return info;

    const int ps = get_ptr_size();
    const bool x64 = (ps == 8);

    uint32 sig = get_dword(col);
    if (sig > 2) return info;

    int32 type_rva = get_dword(col + 12);
    int32 class_rva = get_dword(col + 16);

    ea_t base = x64 ? get_imagebase() : 0;
    if (x64 && base == BADADDR) return info;

    ea_t td = x64 ? rva_to_va(base, type_rva) : type_rva;
    ea_t cd = x64 ? rva_to_va(base, class_rva) : class_rva;
    if (td == BADADDR || cd == BADADDR) return info;

    uint32 attrs = get_dword(cd + 4);
    uint32 num = get_dword(cd + 8);
    int32 arr_rva = get_dword(cd + 12);

    info.has_multiple_inheritance = (attrs & 1) != 0;
    info.has_virtual_inheritance = (attrs & 2) != 0;
    if (!num || num > 64) return info;

    ea_t arr = x64 ? rva_to_va(base, arr_rva) : arr_rva;
    if (arr == BADADDR || !is_mapped(arr)) return info;

    for (uint32 i = 0; i < num; ++i) {
        int32 bcd_rva = get_dword(arr + i * 4);
        ea_t bcd = x64 ? rva_to_va(base, bcd_rva) : bcd_rva;
        if (bcd == BADADDR || !is_mapped(bcd)) continue;

        int32 btd_rva = get_dword(bcd);
        int32 mdisp = get_dword(bcd + 8);
        int32 vdisp = get_dword(bcd + 16);

        ea_t btd = x64 ? rva_to_va(base, btd_rva) : btd_rva;
        if (btd == BADADDR || !is_mapped(btd)) continue;

        std::string bc = read_msvc_type_name(btd);
        if (bc.empty() || bc == derived) continue;

        if (i > 0) {
            BaseClassInfo b;
            b.class_name = bc;
            b.offset = mdisp;
            b.is_virtual = (vdisp != -1);
            info.base_classes.push_back(b);
        }
    }
    return info;
}

} // namespace msvc_rtti

inline InheritanceInfo parse_msvc_rtti(ea_t vt, const rtti_detector::RTTIConfig& cfg) {
    InheritanceInfo info;
    const int ps = get_ptr_size();

    ea_t rtti = vt + cfg.rtti_offset;
    if (!is_mapped(rtti)) return info;

    ea_t col;
    if (ps == 8) {
        col = cfg.use_64bit_ptrs ? get_qword(rtti) : msvc_rtti::rva_to_va(get_imagebase(), get_dword(rtti));
    } else {
        col = get_dword(rtti);
    }
    if (col == BADADDR || !is_mapped(col)) return info;

    std::string cls;
    qstring n;
    if (get_name(&n, vt) && strncmp(n.c_str(), "??_7", 4) == 0) {
        const char* end = strstr(n.c_str(), "@@6B@");
        if (end) cls.assign(n.c_str() + 4, end - n.c_str() - 4);
    }
    return msvc_rtti::parse_msvc_col(col, cls);
}

inline InheritanceInfo parse_gcc_rtti(ea_t vt, const rtti_detector::RTTIConfig&) {
    InheritanceInfo info;
    const int ps = get_ptr_size();

    ea_t candidates[] = { read_ptr(vt + ps), read_ptr(vt - ps), read_ptr(vt - 2 * ps) };

    std::string cls;
    qstring n;
    if (get_name(&n, vt)) {
        qstring dem;
        if (demangle_name(&dem, n.c_str(), MNG_NODEFINIT) > 0) {
            const char* d = dem.c_str();
            const char* pos = strstr(d, "vtable for ");
            if (!pos) pos = strstr(d, "vtable for'");
            if (pos) {
                const char* s = pos + 11;
                if (*s == '\'') s++;
                cls = s;
                if (!cls.empty() && cls.back() == '\'') cls.pop_back();
            }
        }
    }

    for (int i = 0; i < 3; ++i) {
        if (candidates[i] == BADADDR || !is_mapped(candidates[i])) continue;
        InheritanceInfo ti = gcc_rtti::parse_gcc_typeinfo(candidates[i], cls);
        if (!ti.base_classes.empty()) return ti;
        if (i == 2) info = ti;
    }
    return info;
}

inline InheritanceInfo parse_vtable_rtti(ea_t vt) {
    const auto& cfg = rtti_detector::get_config(vt);
    return cfg.is_msvc ? parse_msvc_rtti(vt, cfg) : parse_gcc_rtti(vt, cfg);
}

static std::map<ea_t, InheritanceInfo> g_rtti_cache;

inline const InheritanceInfo& get_inheritance_info(ea_t vt) {
    auto it = g_rtti_cache.find(vt);
    if (it != g_rtti_cache.end()) return it->second;
    g_rtti_cache[vt] = parse_vtable_rtti(vt);
    return g_rtti_cache[vt];
}

inline void clear_rtti_cache() { g_rtti_cache.clear(); }

} // namespace rtti_parser

```

`src/smart_annotator.h`:

```h
#pragma once
#include <ida.hpp>
#include <idp.hpp>
#include <bytes.hpp>
#include <funcs.hpp>
#include <segment.hpp>
#include <lines.hpp>
#include <auto.hpp>
#include <vector>
#include <algorithm>
#include "vtable_utils.h"
#include "rtti_detector.h"

namespace smart_annotator {

using vtable_utils::get_ptr_size;
using vtable_utils::read_ptr;
using vtable_utils::OPCODE_PUSH_RBP;
using vtable_utils::OPCODE_REX_W;
using vtable_utils::OPCODE_REX;
using vtable_utils::OPCODE_REX_B;

inline int detect_vfunc_start_offset(ea_t vtable_addr, bool) {
    using namespace vtable_utils;

    const auto& config = rtti_detector::get_config(vtable_addr);
    if (config.is_msvc) return 0;

    const int ptr_size = get_ptr_size();
    for (int i = 0; i < MAX_VFUNC_SEARCH_DEPTH; ++i) {
        ea_t entry = vtable_addr + (i * ptr_size);
        if (!is_mapped(entry)) continue;

        segment_t* seg = getseg(read_ptr(entry));
        if (seg && (seg->perm & SEGPERM_EXEC)) return i;
    }

    // GCC/Itanium: [offset-to-top, typeinfo*, vfuncs...]
    return (config.rtti_offset < 0) ? 2 : DEFAULT_VFUNC_START_OFFSET;
}

inline bool is_pure_virtual(ea_t func) {
    if (!func || func == BADADDR) return false;
    qstring name;
    if (!get_name(&name, func)) return false;
    return name.find("__cxa_pure_virtual") != qstring::npos ||
           name.find("_purecall") != qstring::npos ||
           name.find("purevirt") != qstring::npos;
}

inline bool is_typeinfo(ea_t ptr) {
    qstring name;
    return get_name(&name, ptr) &&
           (name.find("_ZTI") != qstring::npos || name.find("typeinfo") != qstring::npos);
}

inline bool is_valid_func_ptr(ea_t addr) {
    if (!addr || addr == BADADDR || !is_mapped(addr)) return false;

    segment_t* seg = getseg(addr);
    if (!seg || !(seg->perm & SEGPERM_EXEC)) return false;
    if (is_code(get_flags(addr))) return true;

    qstring name;
    if (get_name(&name, addr)) {
        const char* n = name.c_str();
        if (strncmp(n, "sub_", 4) == 0 || strncmp(n, "nullsub_", 8) == 0 ||
            strncmp(n, "j_", 2) == 0 || strstr(n, "_vfunc_"))
            return true;
    }

    uint8 b = get_byte(addr);
    return b == OPCODE_PUSH_RBP || b == OPCODE_REX_W || b == OPCODE_REX || b == OPCODE_REX_B;
}

inline ea_t find_next_vtable(ea_t current, const std::vector<ea_t>& sorted) {
    auto it = std::upper_bound(sorted.begin(), sorted.end(), current);
    return (it != sorted.end()) ? *it : BADADDR;
}

struct VTableEntry {
    ea_t entry_addr;
    ea_t func_ptr;
    int index;
    bool is_pure_virtual;
};

struct VTableStats {
    int func_count = 0;
    int pure_virtual_count = 0;
};

template<bool collect_entries, bool annotate>
inline VTableStats scan_vtable(
    ea_t vtable_addr,
    bool is_windows,
    const std::vector<ea_t>& sorted_vtables,
    std::vector<VTableEntry>* out_entries = nullptr,
    const std::map<int, int>* status_map = nullptr)
{
    using namespace vtable_utils;

    VTableStats stats;
    const int ptr_size = get_ptr_size();
    const int start_offset = detect_vfunc_start_offset(vtable_addr, is_windows);
    const ea_t next_vtable = find_next_vtable(vtable_addr, sorted_vtables);

    int max_check = MAX_VTABLE_ENTRIES;
    if (next_vtable != BADADDR && next_vtable > vtable_addr)
        max_check = std::min(max_check, (int)((next_vtable - vtable_addr) / ptr_size));

    int consecutive_invalid = 0;
    int vfunc_index = 0;
    char cmt_buf[COMMENT_BUFFER_SIZE];

    for (int i = start_offset; i < max_check && consecutive_invalid < CONSECUTIVE_INVALID_THRESHOLD; ++i) {
        ea_t entry_addr = vtable_addr + (i * ptr_size);
        if (!is_mapped(entry_addr)) break;

        if (std::binary_search(sorted_vtables.begin(), sorted_vtables.end(), entry_addr) &&
            entry_addr != vtable_addr) break;

        ea_t func_ptr = read_ptr(entry_addr);
        if (!func_ptr || func_ptr == BADADDR) {
            ++consecutive_invalid;
            continue;
        }

        bool pure_virt = is_pure_virtual(func_ptr);

        if (!pure_virt && !is_valid_func_ptr(func_ptr)) {
            if (is_typeinfo(func_ptr)) {
                ++consecutive_invalid;
                continue;
            }
            ++consecutive_invalid;
            continue;
        }

        consecutive_invalid = 0;
        stats.func_count++;
        if (pure_virt) stats.pure_virtual_count++;

        if constexpr (collect_entries) {
            if (out_entries) {
                out_entries->push_back({entry_addr, func_ptr, vfunc_index, pure_virt});
            }
        }

        if constexpr (annotate) {
            if (!is_code(get_flags(func_ptr)))
                add_func(func_ptr);

            int byte_offset = vfunc_index * ptr_size;
            const char* prefix = "";

            // Determine prefix based on status (fixed width: 13 chars including space)
            if (status_map) {
                auto it = status_map->find(vfunc_index);
                if (it != status_map->end()) {
                    switch (it->second) {
                        case 0: prefix = "[Inherited]  "; break;  // INHERITED (11 + 2 spaces)
                        case 1: prefix = "[Override]   "; break;  // OVERRIDDEN (10 + 3 spaces)
                        case 2: prefix = "[NEW]        "; break;  // NEW_VIRTUAL (5 + 8 spaces)
                        case 3: prefix = "[Pure‚ÜíImpl]  "; break;  // PURE_TO_IMPL (11 + 2 spaces)
                        case 4: prefix = "[Impl‚ÜíPure]  "; break;  // IMPL_TO_PURE (11 + 2 spaces)
                    }
                }
            } else if (pure_virt) {
                prefix = "[PURE]       ";  // 6 + 7 spaces
            }

            qsnprintf(cmt_buf, sizeof(cmt_buf), "%sindex: %-3d | offset: %-4d", prefix, vfunc_index, byte_offset);
            set_cmt(entry_addr, cmt_buf, false);
        }

        ++vfunc_index;
    }

    return stats;
}

inline VTableStats get_vtable_stats(ea_t addr, bool is_win, const std::vector<ea_t>& vtables) {
    return scan_vtable<false, false>(addr, is_win, vtables);
}

inline std::vector<VTableEntry> get_vtable_entries(ea_t addr, bool is_win, const std::vector<ea_t>& vtables) {
    using namespace vtable_utils;

    std::vector<VTableEntry> entries;
    entries.reserve(ENTRY_RESERVE_SIZE);
    scan_vtable<true, false>(addr, is_win, vtables, &entries);
    return entries;
}

inline int annotate_vtable(ea_t addr, bool is_win, const std::vector<ea_t>& vtables, const std::map<int, int>* status_map = nullptr) {
    return scan_vtable<false, true>(addr, is_win, vtables, nullptr, status_map).func_count;
}

} // namespace smart_annotator

```

`src/vtable_chooser.h`:

```h
#pragma once
#include <ida.hpp>
#include <kernwin.hpp>
#include <vector>
#include <string>
#include <map>
#include <set>
#include "vtable_detector.h"
#include "smart_annotator.h"
#include "rtti_parser.h"
#include "vtable_comparison.h"
#include "inheritance_graph.h"
#include "vtable_utils.h"

struct vtable_cache_t {
    std::vector<VTableInfo> vtables;
    std::vector<ea_t> sorted_addrs;
    bool valid = false;

    void refresh() {
        vtables = vtable_detector::find_vtables();
        sorted_addrs.clear();
        sorted_addrs.reserve(vtables.size());
        for (const auto &v : vtables)
            sorted_addrs.push_back(v.address);
        std::sort(sorted_addrs.begin(), sorted_addrs.end());

        std::map<std::string, ea_t> class_to_vtable;
        for (const auto &vt : vtables) {
            class_to_vtable[vt.class_name] = vt.address;
        }

        for (auto &vt : vtables) {
            auto stats = smart_annotator::get_vtable_stats(vt.address, vt.is_windows, sorted_addrs);
            vt.func_count = stats.func_count;
            vt.pure_virtual_count = stats.pure_virtual_count;

            const auto& inherit_info = rtti_parser::get_inheritance_info(vt.address);
            vt.base_classes.clear();
            for (const auto& base : inherit_info.base_classes) {
                vt.base_classes.push_back(base.class_name);
            }
            vt.has_multiple_inheritance = inherit_info.has_multiple_inheritance;
            vt.has_virtual_inheritance = inherit_info.has_virtual_inheritance;

            if (!vt.base_classes.empty()) {
                vt.parent_class = vt.base_classes[0];
            }

            vt.derived_classes.clear();
            vt.derived_count = 0;
        }

        std::map<std::string, std::vector<std::string>> base_to_derived;
        for (const auto &vt : vtables) {
            for (const auto& base : vt.base_classes) {
                base_to_derived[base].push_back(vt.class_name);
            }
        }

        std::vector<VTableInfo> intermediate_classes;
        std::set<std::string> seen_intermediate;

        for (const auto &vt : vtables) {
            for (size_t i = 0; i < vt.base_classes.size(); ++i) {
                const std::string& base = vt.base_classes[i];
                if (class_to_vtable.find(base) == class_to_vtable.end() &&
                    seen_intermediate.find(base) == seen_intermediate.end()) {

                    seen_intermediate.insert(base);

                    ea_t parent_vtable = BADADDR;
                    std::string parent_name;
                    for (size_t j = i + 1; j < vt.base_classes.size(); ++j) {
                        auto it = class_to_vtable.find(vt.base_classes[j]);
                        if (it != class_to_vtable.end()) {
                            parent_vtable = it->second;
                            parent_name = vt.base_classes[j];
                            break;
                        }
                    }

                    VTableInfo intermediate;
                    intermediate.address = BADADDR;
                    intermediate.class_name = base;
                    intermediate.display_name = parent_name.empty() ?
                        base :
                        parent_name + "::" + base;
                    intermediate.is_windows = vt.is_windows;
                    intermediate.func_count = 0;
                    intermediate.pure_virtual_count = 0;
                    intermediate.derived_count = 0;
                    intermediate.has_multiple_inheritance = false;
                    intermediate.has_virtual_inheritance = false;
                    intermediate.is_intermediate = true;
                    intermediate.parent_vtable_addr = parent_vtable;
                    intermediate.parent_class = parent_name;

                    if (parent_vtable != BADADDR) {
                        auto stats = smart_annotator::get_vtable_stats(parent_vtable, vt.is_windows, sorted_addrs);
                        intermediate.func_count = stats.func_count;
                        intermediate.pure_virtual_count = stats.pure_virtual_count;
                    }

                    auto derived_it = base_to_derived.find(base);
                    if (derived_it != base_to_derived.end()) {
                        intermediate.derived_classes = derived_it->second;
                        intermediate.derived_count = static_cast<int>(derived_it->second.size());
                    }

                    intermediate_classes.push_back(std::move(intermediate));
                    class_to_vtable[base] = BADADDR;
                }
            }
        }

        for (auto& inter : intermediate_classes) {
            vtables.push_back(std::move(inter));
        }

        for (auto &vt : vtables) {
            if (!vt.is_intermediate) {
                auto it = base_to_derived.find(vt.class_name);
                if (it != base_to_derived.end()) {
                    vt.derived_classes = it->second;
                    vt.derived_count = static_cast<int>(it->second.size());
                }
            }
        }

        std::sort(vtables.begin(), vtables.end(),
            [](const VTableInfo& a, const VTableInfo& b) { return a.class_name < b.class_name; });

        valid = true;
    }

    void invalidate() { valid = false; }
};

static vtable_cache_t g_vtable_cache;

struct func_browser_t : public chooser_t {
protected:
    static constexpr uint32 flags_ = CH_KEEP;
    std::vector<smart_annotator::VTableEntry> entries;
    ea_t vtable_addr;
    std::map<int, vtable_comparison::OverrideStatus> status_map;

    mutable char idx_cache[vtable_utils::INDEX_CACHE_SIZE];
    mutable char entry_addr_cache[vtable_utils::ADDRESS_CACHE_SIZE];
    mutable char func_addr_cache[vtable_utils::FUNCTION_NAME_CACHE_SIZE];

public:
    static constexpr int widths_[] = { 8, 20, 20, 14 };
    static constexpr const char *const header_[] = {
        "Index", "Entry Address", "Function", "Status"
    };

    qstring title_storage;

    func_browser_t(const std::string& cls_name, ea_t vt_addr,
                   const std::vector<smart_annotator::VTableEntry>& ents,
                   const vtable_comparison::VTableComparison* comp = nullptr)
        : chooser_t(flags_, qnumber(widths_), widths_, header_, "Functions"),
          entries(ents), vtable_addr(vt_addr)
    {
        title_storage.sprnt("Functions: %s", cls_name.c_str());
        title = title_storage.c_str();
        popup_names[POPUP_INS] = "Jump to Function";

        if (comp) {
            for (const auto& entry : comp->entries) {
                status_map[entry.index] = entry.status;
            }
        }
    }

    virtual size_t idaapi get_count() const override {
        return entries.size();
    }

    virtual void idaapi get_row(
        qstrvec_t *cols, int *, chooser_item_attrs_t *attrs, size_t n) const override
    {
        if (cols == nullptr || n >= entries.size()) return;

        const auto &entry = entries[n];

        vtable_utils::format_index(idx_cache, sizeof(idx_cache), entry.index);
        cols->at(0) = idx_cache;

        vtable_utils::format_address(entry_addr_cache, sizeof(entry_addr_cache), entry.entry_addr);
        cols->at(1) = entry_addr_cache;

        vtable_utils::format_function(func_addr_cache, sizeof(func_addr_cache), entry.func_ptr);
        cols->at(2) = func_addr_cache;

        auto status_it = status_map.find(entry.index);
        if (status_it != status_map.end()) {
            cols->at(3) = vtable_comparison::get_status_string(status_it->second);
            if (attrs) attrs->color = vtable_comparison::get_status_color(status_it->second);
        } else if (entry.is_pure_virtual) {
            cols->at(3) = "pure virtual";
            if (attrs) attrs->color = vtable_utils::CLASS_PURE_VIRTUAL;
        } else {
            cols->at(3) = "";
        }
    }

    virtual cbret_t idaapi enter(size_t n) override {
        if (n >= entries.size()) return cbret_t(0);
        jumpto(entries[n].func_ptr);
        return cbret_t(0);
    }

    virtual cbret_t idaapi ins(ssize_t n) override {
        size_t idx = (n < 0) ? 0 : n;
        if (idx >= entries.size()) return cbret_t(0);
        jumpto(entries[idx].func_ptr);
        return cbret_t(0);
    }

    virtual const void *idaapi get_obj_id(size_t *len) const override {
        *len = sizeof(vtable_addr);
        return &vtable_addr;
    }
};

struct comparison_browser_t : public chooser_t {
protected:
    static constexpr uint32 flags_ = CH_KEEP | CH_CAN_REFRESH;
    vtable_comparison::VTableComparison comparison;
    bool show_inherited;

    mutable char idx_cache[vtable_utils::INDEX_CACHE_SIZE];
    mutable char base_addr_cache[vtable_utils::ADDRESS_CACHE_SIZE];
    mutable char base_func_cache[vtable_utils::FUNCTION_NAME_CACHE_SIZE];
    mutable char derived_addr_cache[vtable_utils::ADDRESS_CACHE_SIZE];
    mutable char derived_func_cache[vtable_utils::FUNCTION_NAME_CACHE_SIZE];

    mutable std::vector<size_t> filtered_indices;
    mutable bool cache_valid = false;

public:
    static constexpr int widths_[] = { 6, 18, 22, 18, 22, 14 };
    static constexpr const char *const header_[] = {
        "Index", "Base Function", "Base Address",
        "Derived Function", "Derived Address", "Status"
    };

    qstring title_storage;

    comparison_browser_t(const vtable_comparison::VTableComparison& comp, bool show_all = false)
        : chooser_t(flags_, qnumber(widths_), widths_, header_, "VTable Comparison"),
          comparison(comp), show_inherited(show_all)
    {
        title_storage.sprnt("Compare: %s ‚Üí %s",
                           comp.derived_class.c_str(),
                           comp.base_class.c_str());
        title = title_storage.c_str();
        popup_names[POPUP_INS] = "Jump to Derived Function";
        popup_names[POPUP_DEL] = "Jump to Base Function";
        popup_names[POPUP_REFRESH] = show_inherited ? "Hide Inherited" : "Show All";
        rebuild_filtered_cache();  // Build cache on construction
    }

private:
    void rebuild_filtered_cache() const {
        filtered_indices.clear();
        filtered_indices.reserve(comparison.entries.size());

        for (size_t i = 0; i < comparison.entries.size(); ++i) {
            if (show_inherited || comparison.entries[i].status != vtable_comparison::OverrideStatus::INHERITED) {
                filtered_indices.push_back(i);
            }
        }
        cache_valid = true;
    }

public:
    virtual size_t idaapi get_count() const override {
        if (!cache_valid) rebuild_filtered_cache();
        return filtered_indices.size();
    }

    virtual void idaapi get_row(
        qstrvec_t *cols, int *, chooser_item_attrs_t *attrs, size_t n) const override
    {
        if (cols == nullptr) return;
        if (!cache_valid) rebuild_filtered_cache();
        if (n >= filtered_indices.size()) {
            return;
        }

        size_t entry_idx = filtered_indices[n];
        const auto& entry = comparison.entries[entry_idx];

        vtable_utils::format_index(idx_cache, sizeof(idx_cache), entry.index);
        cols->at(0) = idx_cache;

        if (!entry.base_func_name.empty()) {
            qsnprintf(base_func_cache, sizeof(base_func_cache), "%s", entry.base_func_name.c_str());
            cols->at(1) = base_func_cache;
        } else if (entry.base_func_ptr != BADADDR) {
            vtable_utils::format_sub_address(base_func_cache, sizeof(base_func_cache), entry.base_func_ptr);
            cols->at(1) = base_func_cache;
        } else {
            cols->at(1) = "-";
        }

        if (entry.base_func_ptr != BADADDR) {
            vtable_utils::format_address(base_addr_cache, sizeof(base_addr_cache), entry.base_func_ptr);
            cols->at(2) = base_addr_cache;
        } else {
            cols->at(2) = "-";
        }

        if (!entry.derived_func_name.empty()) {
            qsnprintf(derived_func_cache, sizeof(derived_func_cache), "%s", entry.derived_func_name.c_str());
            cols->at(3) = derived_func_cache;
        } else {
            vtable_utils::format_sub_address(derived_func_cache, sizeof(derived_func_cache), entry.derived_func_ptr);
            cols->at(3) = derived_func_cache;
        }

        vtable_utils::format_address(derived_addr_cache, sizeof(derived_addr_cache), entry.derived_func_ptr);
        cols->at(4) = derived_addr_cache;

        cols->at(5) = vtable_comparison::get_status_string(entry.status);
        if (attrs) attrs->color = vtable_comparison::get_status_color(entry.status);
    }

    virtual cbret_t idaapi enter(size_t n) override {
        if (!cache_valid) rebuild_filtered_cache();
        if (n >= filtered_indices.size()) return cbret_t(0);

        const auto& entry = comparison.entries[filtered_indices[n]];

        if (entry.derived_func_ptr != BADADDR) {
            jumpto(entry.derived_func_ptr);
        }

        return cbret_t(0);
    }

    virtual cbret_t idaapi ins(ssize_t n) override {
        if (n < 0 || !cache_valid) rebuild_filtered_cache();
        size_t idx = (n < 0) ? 0 : n;
        if (idx >= filtered_indices.size()) return cbret_t(0);

        const auto& entry = comparison.entries[filtered_indices[idx]];

        if (entry.derived_func_ptr != BADADDR) {
            jumpto(entry.derived_func_ptr);
        }

        return cbret_t(n);
    }

    virtual cbret_t idaapi del(ssize_t n) {
        if (n < 0 || !cache_valid) rebuild_filtered_cache();
        size_t idx = (n < 0) ? 0 : n;
        if (idx >= filtered_indices.size()) return cbret_t(0);

        const auto& entry = comparison.entries[filtered_indices[idx]];

        if (entry.base_func_ptr != BADADDR) {
            jumpto(entry.base_func_ptr);
        }

        return cbret_t(n);
    }

    virtual cbret_t idaapi refresh(ssize_t) override {
        show_inherited = !show_inherited;
        popup_names[POPUP_REFRESH] = show_inherited ? "Hide Inherited" : "Show All";
        cache_valid = false;  // Invalidate cache on filter change
        return cbret_t(ALL_CHANGED);
    }

    virtual const void *idaapi get_obj_id(size_t *len) const override {
        static const char id[] = "VTableComparison";
        *len = sizeof(id);
        return id;
    }
};

struct vtable_chooser_t : public chooser_t {
protected:
    static constexpr uint32 flags_ = CH_KEEP | CH_CAN_REFRESH;
    mutable size_t last_selection = 0;

public:
    static constexpr int widths_[] = { 30, 25, 18, 10, 12 };
    static constexpr const char *const header_[] = {
        "Class Name", "Base Classes", "Address",
        "Functions", "Status"
    };

    vtable_chooser_t() : chooser_t(flags_, qnumber(widths_), widths_, header_, "VTable Explorer") {
        popup_names[POPUP_REFRESH] = "Refresh VTables";

        if (!g_vtable_cache.valid) {
            try {
                g_vtable_cache.refresh();
            } catch (...) {
                g_vtable_cache.vtables.clear();
            }
        }
    }

    virtual size_t idaapi get_count() const override {
        return g_vtable_cache.vtables.size();
    }

    virtual void idaapi get_row(
        qstrvec_t *cols, int *, chooser_item_attrs_t *attrs, size_t n) const override
    {
        if (cols == nullptr || n >= g_vtable_cache.vtables.size()) return;

        const VTableInfo &vt = g_vtable_cache.vtables[n];

        cols->at(0) = vt.display_name.c_str();

        if (!vt.base_classes.empty()) {
            cols->at(1) = vt.base_classes[0].c_str();
        } else if (!vt.parent_class.empty()) {
            cols->at(1) = vt.parent_class.c_str();
        } else {
            cols->at(1) = "";
        }

        char addr_buf[32];
        if (vt.is_intermediate) {
            if (vt.parent_vtable_addr != BADADDR) {
                qsnprintf(addr_buf, sizeof(addr_buf), "-> 0x%llX", (unsigned long long)vt.parent_vtable_addr);
            } else {
                qsnprintf(addr_buf, sizeof(addr_buf), "(inlined)");
            }
        } else {
            qsnprintf(addr_buf, sizeof(addr_buf), "0x%llX", (unsigned long long)vt.address);
        }
        cols->at(2) = addr_buf;

        char count_buf[16];
        if (vt.is_intermediate) {
            if (vt.func_count > 0) {
                qsnprintf(count_buf, sizeof(count_buf), "~%d", vt.func_count);
            } else {
                qsnprintf(count_buf, sizeof(count_buf), "-");
            }
        } else if (vt.pure_virtual_count > 0) {
            qsnprintf(count_buf, sizeof(count_buf), "%d (%d pv)", vt.func_count, vt.pure_virtual_count);
        } else {
            qsnprintf(count_buf, sizeof(count_buf), "%d", vt.func_count);
        }
        cols->at(3) = count_buf;

        const char* status = "";
        if (vt.is_intermediate) {
            status = "Intermediate";
        } else if (vt.pure_virtual_count > 0) {
            status = "Abstract";
        } else if (!vt.base_classes.empty()) {
            status = "Has Base";
        } else {
            status = "Root";
        }
        cols->at(4) = status;

        if (vt.is_intermediate) {
            if (attrs) attrs->color = 0xA0A0A0;
        } else if (vt.pure_virtual_count > 0) {
            if (attrs) attrs->color = vtable_utils::CLASS_MULTIPLE_INHERIT;
        } else if (vt.base_classes.empty() && !vt.is_intermediate) {
            if (attrs) attrs->color = vtable_utils::CLASS_VIRTUAL_INHERIT;
        }
    }

    virtual cbret_t idaapi enter(size_t n) override {
        if (n >= g_vtable_cache.vtables.size()) return cbret_t(0);

        last_selection = n;
        const VTableInfo &vt = g_vtable_cache.vtables[n];

        if (vt.is_intermediate) {
            if (vt.parent_vtable_addr != BADADDR) {
                jumpto(vt.parent_vtable_addr);
                info("Intermediate Class\n\n"
                     "Class: %s\nNo vtable symbol (inlined by compiler)\n"
                     "Jumped to parent: %s @ 0x%llX",
                     vt.class_name.c_str(), vt.parent_class.c_str(),
                     (unsigned long long)vt.parent_vtable_addr);
            } else {
                info("Intermediate Class\n\n"
                     "Class: %s\nNo vtable symbol (inlined by compiler)\n"
                     "No parent vtable found",
                     vt.class_name.c_str());
            }
            return cbret_t(n);
        }

        // Get base class for comparison (same logic as annotate_all_vtables)
        std::map<int, int> status_map;
        std::string base_for_comp = !vt.base_classes.empty() ? vt.base_classes[0] : "";
        if (!base_for_comp.empty()) {
            ea_t base_vtable = vtable_comparison::find_vtable_by_class_name(base_for_comp, g_vtable_cache.vtables);
            if (base_vtable != BADADDR) {
                auto comp = vtable_comparison::compare_vtables(
                    vt.address, base_vtable, vt.is_windows,
                    g_vtable_cache.sorted_addrs, vt.class_name, base_for_comp);

                for (const auto& entry : comp.entries) {
                    status_map[entry.index] = static_cast<int>(entry.status);
                }
            }
        }

        // Add vtable header comment with parent class info
        char vtable_cmt[256];
        if (!base_for_comp.empty()) {
            qsnprintf(vtable_cmt, sizeof(vtable_cmt), "vtable for '%s' : inherits '%s'",
                     vt.class_name.c_str(), base_for_comp.c_str());
        } else {
            qsnprintf(vtable_cmt, sizeof(vtable_cmt), "vtable for '%s' : (root class)",
                     vt.class_name.c_str());
        }
        set_cmt(vt.address, vtable_cmt, false);

        int count = smart_annotator::annotate_vtable(vt.address, vt.is_windows, g_vtable_cache.sorted_addrs,
                                                     status_map.empty() ? nullptr : &status_map);
        jumpto(vt.address);

        info("VTable Annotation Complete\n\n"
             "Class: %s\nAddress: 0x%llX\nFunctions annotated: %d%s",
             vt.class_name.c_str(), (unsigned long long)vt.address, count,
             vt.pure_virtual_count > 0 ? "\n(Abstract class)" : "");

        return cbret_t(n);
    }

    virtual cbret_t idaapi refresh(ssize_t) override {
        show_wait_box("Scanning vtables...");
        g_vtable_cache.refresh();
        hide_wait_box();
        return cbret_t(ALL_CHANGED);
    }

    virtual const void *idaapi get_obj_id(size_t *len) const override {
        static const char id[] = "VTableExplorer";
        *len = sizeof(id);
        return id;
    }

    size_t get_current_selection() const { return last_selection; }

    void show_tree_for_selection(size_t n) {
        if (n >= g_vtable_cache.vtables.size()) {
            warning("Invalid selection: %zu", n);
            return;
        }
        const VTableInfo& vt = g_vtable_cache.vtables[n];
        inheritance_graph::show_inheritance_graph(
            vt.class_name, vt.address, vt.is_windows, &g_vtable_cache.vtables
        );
    }

    void show_tree_for_current() {
        if (last_selection >= g_vtable_cache.vtables.size()) {
            warning("No vtable selected");
            return;
        }
        const VTableInfo& vt = g_vtable_cache.vtables[last_selection];
        inheritance_graph::show_inheritance_graph(
            vt.class_name, vt.address, vt.is_windows, &g_vtable_cache.vtables
        );
    }

private:
    bool select_base_class(const std::vector<std::string>& base_classes,
                          std::string& selected_base) const {
        if (base_classes.size() == 1) {
            selected_base = base_classes[0];
            return true;
        }

        qstring selection_text = "Select base class:\n\n";
        for (size_t i = 0; i < base_classes.size(); ++i) {
            selection_text.cat_sprnt("%d. %s\n", (int)i, base_classes[i].c_str());
        }
        selection_text.cat_sprnt("\nEnter number (0-%d): ", (int)(base_classes.size() - 1));

        qstring choice_str;
        if (!ask_str(&choice_str, HIST_IDENT, "%s", selection_text.c_str())) {
            return false;
        }

        int base_selection = atoi(choice_str.c_str());

        if (base_selection < 0 || base_selection >= (int)base_classes.size()) {
            warning("Invalid choice: %d. Must be between 0 and %d",
                   base_selection, (int)(base_classes.size() - 1));
            return false;
        }

        selected_base = base_classes[base_selection];
        return true;
    }

    void show_comparison_for_vtable_index(size_t n) {
        if (n >= g_vtable_cache.vtables.size()) {
            warning("Invalid selection");
            return;
        }

        const VTableInfo& vt = g_vtable_cache.vtables[n];

        if (vt.is_intermediate) {
            if (vt.parent_vtable_addr == BADADDR || vt.parent_class.empty()) {
                warning("Intermediate class %s has no parent vtable to compare",
                       vt.class_name.c_str());
                return;
            }

            ea_t parent_parent_vtable = BADADDR;
            std::string parent_parent_name;

            for (const auto& other : g_vtable_cache.vtables) {
                if (other.class_name == vt.parent_class && !other.is_intermediate) {
                    if (!other.base_classes.empty()) {
                        parent_parent_name = other.base_classes[0];
                        parent_parent_vtable = vtable_comparison::find_vtable_by_class_name(
                            parent_parent_name, g_vtable_cache.vtables);
                    }
                    break;
                }
            }

            if (parent_parent_vtable == BADADDR) {
                info("Intermediate Class Comparison\n\n"
                     "Class: %s (uses parent's vtable)\n"
                     "Parent: %s @ 0x%llX\n\n"
                     "No grandparent vtable found for comparison.\n"
                     "Use 'Browse Functions' to see inherited functions.",
                     vt.class_name.c_str(), vt.parent_class.c_str(),
                     (unsigned long long)vt.parent_vtable_addr);
                return;
            }

            auto comp = vtable_comparison::compare_vtables(
                vt.parent_vtable_addr, parent_parent_vtable, vt.is_windows,
                g_vtable_cache.sorted_addrs,
                vt.class_name + " (via " + vt.parent_class + ")", parent_parent_name
            );

            if (comp.entries.empty()) {
                warning("No vtable entries found for comparison");
                return;
            }

            comparison_browser_t *browser = new comparison_browser_t(comp, false);
            browser->choose();
            return;
        }

        if (vt.base_classes.empty()) {
            warning("No base classes found for %s\n\n"
                   "This class either:\n"
                   "- Has no inheritance\n"
                   "- Was compiled without RTTI\n"
                   "- Has stripped RTTI information",
                   vt.class_name.c_str());
            return;
        }

        std::string selected_base;
        if (!select_base_class(vt.base_classes, selected_base)) {
            return;
        }

        ea_t base_vtable = vtable_comparison::find_vtable_by_class_name(
            selected_base, g_vtable_cache.vtables);

        if (base_vtable == BADADDR) {
            warning("Could not find vtable for base class: %s", selected_base.c_str());
            return;
        }

        auto comp = vtable_comparison::compare_vtables(
            vt.address, base_vtable, vt.is_windows,
            g_vtable_cache.sorted_addrs,
            vt.class_name, selected_base
        );

        if (comp.entries.empty()) {
            warning("No vtable entries found for comparison");
            return;
        }

        comparison_browser_t *browser = new comparison_browser_t(comp, false);
        browser->choose();
    }

public:
    void show_compare_for_selection(size_t n) {
        show_comparison_for_vtable_index(n);
    }

    void show_compare_for_current() {
        show_comparison_for_vtable_index(last_selection);
    }

    void browse_functions_for_selection(size_t n) {
        if (n >= g_vtable_cache.vtables.size()) return;

        last_selection = n;
        const VTableInfo &vt = g_vtable_cache.vtables[n];

        ea_t browse_addr = vt.is_intermediate ? vt.parent_vtable_addr : vt.address;
        if (browse_addr == BADADDR) {
            warning("No vtable address available for %s", vt.class_name.c_str());
            return;
        }

        auto entries = smart_annotator::get_vtable_entries(browse_addr, vt.is_windows, g_vtable_cache.sorted_addrs);
        if (entries.empty()) {
            warning("No functions found in vtable");
            return;
        }

        vtable_comparison::VTableComparison* comp_ptr = nullptr;
        vtable_comparison::VTableComparison comp_data;

        std::string base_for_comp = vt.is_intermediate ? vt.parent_class :
                                    (!vt.base_classes.empty() ? vt.base_classes[0] : "");
        if (!base_for_comp.empty()) {
            ea_t base_vtable = vtable_comparison::find_vtable_by_class_name(base_for_comp, g_vtable_cache.vtables);
            if (base_vtable != BADADDR) {
                comp_data = vtable_comparison::compare_vtables(
                    browse_addr, base_vtable, vt.is_windows,
                    g_vtable_cache.sorted_addrs, vt.class_name, base_for_comp);
                comp_ptr = &comp_data;
            }
        }

        func_browser_t *browser = new func_browser_t(vt.class_name, browse_addr, entries, comp_ptr);
        browser->choose();
    }

    void browse_functions_for_current() {
        browse_functions_for_selection(last_selection);
    }

    void annotate_all_vtables() {
        if (g_vtable_cache.vtables.empty()) return;

        show_wait_box("Annotating all vtables...");

        int total_funcs = 0;
        int total_vtables = 0;

        for (const auto &vt : g_vtable_cache.vtables) {
            if (vt.is_intermediate) continue;

            // Get base class for comparison (same logic as function browser)
            std::map<int, int> status_map;
            std::string base_for_comp = !vt.base_classes.empty() ? vt.base_classes[0] : "";
            if (!base_for_comp.empty()) {
                ea_t base_vtable = vtable_comparison::find_vtable_by_class_name(base_for_comp, g_vtable_cache.vtables);
                if (base_vtable != BADADDR) {
                    auto comp = vtable_comparison::compare_vtables(
                        vt.address, base_vtable, vt.is_windows,
                        g_vtable_cache.sorted_addrs, vt.class_name, base_for_comp);

                    // Build status map from comparison entries
                    for (const auto& entry : comp.entries) {
                        status_map[entry.index] = static_cast<int>(entry.status);
                    }
                }
            }

            // Add vtable header comment with parent class info
            char vtable_cmt[256];
            if (!base_for_comp.empty()) {
                qsnprintf(vtable_cmt, sizeof(vtable_cmt), "vtable for '%s' : inherits '%s'",
                         vt.class_name.c_str(), base_for_comp.c_str());
            } else {
                qsnprintf(vtable_cmt, sizeof(vtable_cmt), "vtable for '%s' : (root class)",
                         vt.class_name.c_str());
            }
            set_cmt(vt.address, vtable_cmt, false);

            int count = smart_annotator::annotate_vtable(vt.address, vt.is_windows, g_vtable_cache.sorted_addrs,
                                                         status_map.empty() ? nullptr : &status_map);
            total_funcs += count;
            total_vtables++;

            if (user_cancelled()) {
                hide_wait_box();
                info("Annotation cancelled.\n\nVTables annotated: %d / %d\nFunctions annotated: %d",
                     total_vtables, (int)g_vtable_cache.vtables.size(), total_funcs);
                return;
            }
        }

        hide_wait_box();
        info("All VTables Annotated!\n\nVTables processed: %d\nTotal functions annotated: %d",
             total_vtables, total_funcs);
    }
};

static vtable_chooser_t* g_chooser = nullptr;

inline void show_vtable_chooser() {
    if (!g_chooser) {
        g_chooser = new vtable_chooser_t();
    }
    g_chooser->choose();
}

inline void close_vtable_chooser() {
    if (g_chooser) {
        delete g_chooser;
        g_chooser = nullptr;
    }
    g_vtable_cache.invalidate();
}

inline void show_inheritance_tree_action(action_activation_ctx_t* ctx) {
    if (!g_chooser) {
        warning("VTable Explorer not open.\nPlease open it first from the context menu");
        return;
    }

    if (ctx && !ctx->chooser_selection.empty()) {
        g_chooser->show_tree_for_selection(ctx->chooser_selection[0]);
    } else {
        g_chooser->show_tree_for_current();
    }
}

inline void show_compare_base_action(action_activation_ctx_t* ctx) {
    if (!g_chooser) {
        warning("VTable Explorer not open.\nPlease open it first from the context menu");
        return;
    }

    if (ctx && !ctx->chooser_selection.empty()) {
        g_chooser->show_compare_for_selection(ctx->chooser_selection[0]);
    } else {
        g_chooser->show_compare_for_current();
    }
}

inline void funcbrowser_jump_action(action_activation_ctx_t* ctx) {
    if (!ctx || !ctx->widget) return;

    qstring title;
    get_widget_title(&title, ctx->widget);

    func_browser_t* browser = (func_browser_t*)get_chooser_obj(title.c_str());
    if (browser && !ctx->chooser_selection.empty()) {
        browser->ins(ctx->chooser_selection[0]);
    }
}

inline void compbrowser_jump_derived_action(action_activation_ctx_t* ctx) {
    if (!ctx || !ctx->widget) return;

    qstring title;
    get_widget_title(&title, ctx->widget);

    comparison_browser_t* browser = (comparison_browser_t*)get_chooser_obj(title.c_str());
    if (browser && !ctx->chooser_selection.empty()) {
        browser->ins(ctx->chooser_selection[0]);
    }
}

inline void compbrowser_jump_base_action(action_activation_ctx_t* ctx) {
    if (!ctx || !ctx->widget) return;

    qstring title;
    get_widget_title(&title, ctx->widget);

    comparison_browser_t* browser = (comparison_browser_t*)get_chooser_obj(title.c_str());
    if (browser && !ctx->chooser_selection.empty()) {
        browser->del(ctx->chooser_selection[0]);
    }
}

inline void compbrowser_toggle_action(action_activation_ctx_t* ctx) {
    if (!ctx || !ctx->widget) return;

    qstring title;
    get_widget_title(&title, ctx->widget);

    comparison_browser_t* browser = (comparison_browser_t*)get_chooser_obj(title.c_str());
    if (browser) {
        browser->refresh(0);
    }
}

inline void browse_functions_action(action_activation_ctx_t* ctx) {
    if (!g_chooser) {
        warning("VTable Explorer not open.\nPlease open it first from the context menu");
        return;
    }

    if (ctx && !ctx->chooser_selection.empty()) {
        g_chooser->browse_functions_for_selection(ctx->chooser_selection[0]);
    } else {
        g_chooser->browse_functions_for_current();
    }
}

inline void annotate_all_action(action_activation_ctx_t* ctx) {
    if (!g_chooser) {
        warning("VTable Explorer not open.\nPlease open it first from the context menu");
        return;
    }
    g_chooser->annotate_all_vtables();
}

```

`src/vtable_comparison.h`:

```h
#pragma once
#include <ida.hpp>
#include <vector>
#include <string>
#include <map>
#include "rtti_parser.h"
#include "smart_annotator.h"
#include "vtable_utils.h"

namespace vtable_comparison {

enum class OverrideStatus {
    INHERITED,
    OVERRIDDEN,
    NEW_VIRTUAL,
    PURE_TO_IMPL,
    IMPL_TO_PURE
};

struct ComparisonEntry {
    int index;
    ea_t derived_entry_addr;
    ea_t derived_func_ptr;
    ea_t base_entry_addr;
    ea_t base_func_ptr;
    OverrideStatus status;
    bool is_pure_virtual_base;
    bool is_pure_virtual_derived;
    std::string base_func_name;
    std::string derived_func_name;
};

struct VTableComparison {
    std::string derived_class;
    std::string base_class;
    ea_t derived_vtable;
    ea_t base_vtable;
    std::vector<ComparisonEntry> entries;
    int inherited_count;
    int overridden_count;
    int new_virtual_count;
};

inline std::string get_func_name(ea_t func) {
    if (!func || func == BADADDR) return "";
    qstring name;
    return get_name(&name, func) ? std::string(name.c_str()) : "";
}

inline VTableComparison compare_vtables(
    ea_t derived_vt, ea_t base_vt, bool is_win,
    const std::vector<ea_t>& sorted,
    const std::string& derived_cls = "",
    const std::string& base_cls = "")
{
    VTableComparison r;
    r.derived_class = derived_cls;
    r.base_class = base_cls;
    r.derived_vtable = derived_vt;
    r.base_vtable = base_vt;
    r.inherited_count = r.overridden_count = r.new_virtual_count = 0;

    auto derived_entries = smart_annotator::get_vtable_entries(derived_vt, is_win, sorted);
    auto base_entries = smart_annotator::get_vtable_entries(base_vt, is_win, sorted);

    std::map<int, smart_annotator::VTableEntry> base_map;
    for (const auto& e : base_entries) base_map[e.index] = e;

    for (const auto& d : derived_entries) {
        ComparisonEntry c;
        c.index = d.index;
        c.derived_entry_addr = d.entry_addr;
        c.derived_func_ptr = d.func_ptr;
        c.is_pure_virtual_derived = d.is_pure_virtual;
        c.derived_func_name = get_func_name(d.func_ptr);

        auto it = base_map.find(d.index);
        if (it != base_map.end()) {
            const auto& b = it->second;
            c.base_entry_addr = b.entry_addr;
            c.base_func_ptr = b.func_ptr;
            c.is_pure_virtual_base = b.is_pure_virtual;
            c.base_func_name = get_func_name(b.func_ptr);

            if (c.derived_func_ptr == c.base_func_ptr) {
                c.status = OverrideStatus::INHERITED;
                r.inherited_count++;
            } else {
                if (c.is_pure_virtual_base && !c.is_pure_virtual_derived)
                    c.status = OverrideStatus::PURE_TO_IMPL;
                else if (!c.is_pure_virtual_base && c.is_pure_virtual_derived)
                    c.status = OverrideStatus::IMPL_TO_PURE;
                else
                    c.status = OverrideStatus::OVERRIDDEN;
                r.overridden_count++;
            }
        } else {
            c.base_entry_addr = BADADDR;
            c.base_func_ptr = BADADDR;
            c.is_pure_virtual_base = false;
            c.status = OverrideStatus::NEW_VIRTUAL;
            r.new_virtual_count++;
        }
        r.entries.push_back(c);
    }
    return r;
}

inline ea_t find_vtable_by_class_name(const std::string& name, const std::vector<VTableInfo>& vtables) {
    for (const auto& vt : vtables)
        if (vt.class_name == name) return vt.address;
    return BADADDR;
}

inline const char* get_status_string(OverrideStatus s) {
    switch (s) {
        case OverrideStatus::INHERITED:    return "Inherited";
        case OverrideStatus::OVERRIDDEN:   return "Overridden";
        case OverrideStatus::NEW_VIRTUAL:  return "New Virtual";
        case OverrideStatus::PURE_TO_IMPL: return "Pure‚ÜíImpl";
        case OverrideStatus::IMPL_TO_PURE: return "Impl‚ÜíPure";
        default: return "Unknown";
    }
}

inline uint32 get_status_color(OverrideStatus s) {
    using namespace vtable_utils;
    switch (s) {
        case OverrideStatus::INHERITED:    return STATUS_INHERITED;
        case OverrideStatus::OVERRIDDEN:   return STATUS_OVERRIDDEN;
        case OverrideStatus::NEW_VIRTUAL:  return STATUS_NEW_VIRTUAL;
        case OverrideStatus::PURE_TO_IMPL: return STATUS_PURE_TO_IMPL;
        case OverrideStatus::IMPL_TO_PURE: return STATUS_IMPL_TO_PURE;
        default: return DEFAULT_BG;
    }
}

} // namespace vtable_comparison

```

`src/vtable_detector.h`:

```h
#pragma once
#include <ida.hpp>
#include <idp.hpp>
#include <name.hpp>
#include <nalt.hpp>
#include <demangle.hpp>
#include <segment.hpp>
#include <funcs.hpp>
#include <bytes.hpp>
#include <xref.hpp>
#include <vector>
#include <string>
#include <map>
#include <algorithm>
#include "vtable_utils.h"
#include "rtti_parser.h"

struct VTableInfo {
    ea_t address;
    std::string class_name;
    std::string display_name;
    bool is_windows;
    int func_count;
    int pure_virtual_count;
    std::vector<std::string> base_classes;
    std::vector<std::string> derived_classes;
    int derived_count;
    bool has_multiple_inheritance;
    bool has_virtual_inheritance;
    bool is_intermediate;        // True if class has no vtable but exists in RTTI chain
    ea_t parent_vtable_addr;     // For intermediate: parent's vtable address
    std::string parent_class;    // Direct parent class name
};

namespace vtable_detector {

using vtable_utils::normalize_msvc_nested_class;

inline bool is_valid_class_name(const std::string& name) {
    using namespace vtable_utils;

    const size_t len = name.length();
    if (len < MIN_CLASS_NAME_LENGTH || len > MAX_CLASS_NAME_LENGTH) return false;

    const char first = name[0];
    if (!isupper(first) && first != '_') return false;

    int alnum_count = 0;
    bool all_same = true;

    for (size_t i = 0; i < len; ++i) {
        const char c = name[i];
        if (isalnum(c) || c == '_') ++alnum_count;
        if (i > 0 && c != first) all_same = false;
    }

    return alnum_count > 0 && !all_same;
}

inline std::string extract_class_name(const char* mangled_name, bool& is_windows) {
    using namespace vtable_utils;

    std::string sym_name(mangled_name);
    is_windows = false;

    if (sym_name.length() > 4 && sym_name.compare(sym_name.length() - 4, 4, "_ptr") == 0)
        sym_name.resize(sym_name.length() - 4);

    qstring demangled;
    if (demangle_name(&demangled, sym_name.c_str(), MNG_NODEFINIT) > 0) {
        const char* dem = demangled.c_str();

        const char* vtable_pos = strstr(dem, "vtable for ");
        if (vtable_pos) {
            std::string class_name(vtable_pos + 11);
            class_name = normalize_msvc_nested_class(class_name);
            if (is_valid_class_name(class_name)) return class_name;
        }

        const char* vft_pos = strstr(dem, "::`vftable'");
        if (vft_pos) {
            is_windows = true;
            const char* const_pos = strstr(dem, "const ");
            if (const_pos && const_pos < vft_pos) {
                std::string class_name(const_pos + 6, vft_pos - const_pos - 6);
                class_name = normalize_msvc_nested_class(class_name);  // @ -> ::
                if (is_valid_class_name(class_name)) return class_name;
            }
        }
    }

    if (sym_name.compare(0, 4, "_ZTV") != 0) return "";

    const char* p = sym_name.c_str() + 4;
    const char* end = sym_name.c_str() + sym_name.length();

    if (*p == 'N') {
        std::string last_component;
        for (++p; *p && *p != 'E'; ) {
            if (!isdigit(*p)) { ++p; continue; }

            int len = atoi(p);
            while (isdigit(*p)) ++p;
            if (len <= 0 || len >= (int)MAX_COMPONENT_LENGTH || p + len > end) break;

            last_component.assign(p, len);
            p += len;
        }
        last_component = normalize_msvc_nested_class(last_component);
        if (is_valid_class_name(last_component)) return last_component;
    }
    else if (isdigit(*p)) {
        int len = atoi(p);
        while (isdigit(*p)) ++p;
        if (len <= 0 || len >= (int)MAX_COMPONENT_LENGTH || p + len > end) return "";

        std::string class_name(p, len);
        class_name = normalize_msvc_nested_class(class_name);
        if (is_valid_class_name(class_name)) return class_name;

        size_t first_upper = class_name.find_first_of("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
        if (first_upper != std::string::npos) {
            size_t template_start = std::string::npos;
            for (size_t i = first_upper; i + 1 < class_name.length(); ++i) {
                if (class_name[i] == 'L' && isdigit(class_name[i + 1])) {
                    template_start = i;
                    break;
                }
            }
            size_t end_pos = (template_start != std::string::npos) ? template_start : class_name.length();
            std::string cleaned = class_name.substr(first_upper, end_pos - first_upper);
            cleaned = normalize_msvc_nested_class(cleaned);
            if (is_valid_class_name(cleaned)) return cleaned;
        }
    }

    return "";
}

inline std::vector<VTableInfo> find_vtables() {
    using namespace vtable_utils;

    std::vector<VTableInfo> vtables;
    std::map<std::string, ea_t> seen;

    const size_t name_count = get_nlist_size();
    vtables.reserve(name_count / VTABLE_RESERVE_RATIO);

    auto add_vtable = [&](ea_t ea, const std::string& class_name, bool is_win) {
        if (seen.emplace(class_name, ea).second) {
            VTableInfo vt;
            vt.address = ea;
            vt.class_name = class_name;
            vt.display_name = class_name;
            vt.is_windows = is_win;
            vt.func_count = 0;
            vt.pure_virtual_count = 0;
            vt.derived_count = 0;
            vt.has_multiple_inheritance = false;
            vt.has_virtual_inheritance = false;
            vt.is_intermediate = false;
            vt.parent_vtable_addr = BADADDR;
            vtables.push_back(std::move(vt));
        }
    };

    for (size_t i = 0; i < name_count; ++i) {
        const char* name = get_nlist_name(i);
        if (!name || !*name) continue;

        ea_t ea = get_nlist_ea(i);
        bool is_windows = false;
        std::string class_name;

        if (strncmp(name, "_ZTV", 4) == 0) {
            class_name = extract_class_name(name, is_windows);
            if (is_valid_class_name(class_name))
                add_vtable(ea, class_name, false);
        }
        else if (strncmp(name, "??_7", 4) == 0) {
            class_name = extract_class_name(name, is_windows);
            if (class_name.empty()) {
                const char* marker = strstr(name, "@@6B@");
                if (marker) {
                    class_name.assign(name + 4, marker - name - 4);
                    class_name = normalize_msvc_nested_class(class_name);
                }
            }
            if (is_valid_class_name(class_name))
                add_vtable(ea, class_name, true);
        }
        else if (strstr(name, "vftable") || strstr(name, "vtbl")) {
            class_name = extract_class_name(name, is_windows);
            if (class_name.empty()) {
                class_name = name;
                is_windows = true;
                class_name = normalize_msvc_nested_class(class_name);
            }
            if (is_valid_class_name(class_name))
                add_vtable(ea, class_name, is_windows);
        }
    }

    // Second pass: discover vtables from ??_R4 (RTTI Complete Object Locator)
    // symbols that have no corresponding ??_7 vtable symbol
    for (size_t i = 0; i < name_count; ++i) {
        const char* name = get_nlist_name(i);
        if (!name || strncmp(name, "??_R4", 5) != 0) continue;

        ea_t col_ea = get_nlist_ea(i);
        if (!rtti_detector::validate_msvc_col(col_ea)) continue;

        // Read TypeDescriptor address from COL (+12 = type_descriptor RVA)
        const int ps = get_ptr_size();
        const bool x64 = (ps == 8);
        int32 td_rva = get_dword(col_ea + 12);

        ea_t td;
        if (x64) {
            ea_t base = get_imagebase();
            if (base == BADADDR) continue;
            td = rtti_parser::msvc_rtti::rva_to_va(base, td_rva);
        } else {
            td = (ea_t)(uint32)td_rva;
        }
        if (td == BADADDR || !is_mapped(td)) continue;

        std::string class_name = rtti_parser::msvc_rtti::read_msvc_type_name(td);
        if (!is_valid_class_name(class_name)) continue;
        if (seen.count(class_name)) continue;

        // Locate vtable from COL
        ea_t vtable_addr = BADADDR;

        // Strategy C: construct matching ??_7 name from ??_R4 name
        {
            std::string vt_sym = "??_7" + std::string(name + 5);
            ea_t ea = get_name_ea(BADADDR, vt_sym.c_str());
            if (ea != BADADDR)
                vtable_addr = ea;
        }

        // Strategy A: find data xrefs to the COL address
        if (vtable_addr == BADADDR) {
            xrefblk_t xb;
            for (bool ok = xb.first_to(col_ea, XREF_DATA); ok; ok = xb.next_to()) {
                // COL pointer sits at vtable - ptr_size, so vtable = xref + ptr_size
                ea_t candidate = xb.from + ps;
                ea_t first_entry = read_ptr(candidate);
                if (first_entry == BADADDR || !is_mapped(first_entry)) continue;

                if (get_func(first_entry)) {
                    vtable_addr = candidate;
                    break;
                }
                segment_t* seg = getseg(first_entry);
                if (seg && (seg->perm & SEGPERM_EXEC)) {
                    vtable_addr = candidate;
                    break;
                }
            }
        }

        if (vtable_addr == BADADDR) continue;

        // Validate: first vtable entry must point to executable code
        ea_t first_func = read_ptr(vtable_addr);
        if (first_func == BADADDR || !is_mapped(first_func)) continue;
        if (!get_func(first_func)) {
            segment_t* seg = getseg(first_func);
            if (!seg || !(seg->perm & SEGPERM_EXEC)) continue;
        }

        add_vtable(vtable_addr, class_name, true);
    }

    std::sort(vtables.begin(), vtables.end(),
        [](const VTableInfo& a, const VTableInfo& b) { return a.class_name < b.class_name; });

    return vtables;
}

} // namespace vtable_detector

```

`src/vtable_utils.h`:

```h
#pragma once
#include <ida.hpp>

namespace vtable_utils {

// Limits
constexpr size_t MIN_CLASS_NAME_LENGTH = 1;
constexpr size_t MAX_CLASS_NAME_LENGTH = 512;
constexpr size_t MAX_COMPONENT_LENGTH = 2048;
constexpr int MAX_RTTI_STRING_LENGTH = 1024;

// Detection
constexpr int MAX_VTABLE_ENTRIES = 2048;
constexpr int CONSECUTIVE_INVALID_THRESHOLD = 5;
constexpr int DEFAULT_VFUNC_START_OFFSET = 2;
constexpr int MAX_VFUNC_SEARCH_DEPTH = 4;

// Buffers
constexpr size_t COMMENT_BUFFER_SIZE = 128;
constexpr size_t FUNCTION_NAME_CACHE_SIZE = 512;
constexpr size_t INDEX_CACHE_SIZE = 16;
constexpr size_t ADDRESS_CACHE_SIZE = 32;
constexpr size_t VTABLE_RESERVE_RATIO = 100;
constexpr size_t ENTRY_RESERVE_SIZE = 64;

// Opcodes
constexpr uint8 OPCODE_PUSH_RBP = 0x55;
constexpr uint8 OPCODE_REX_W = 0x48;
constexpr uint8 OPCODE_REX = 0x40;
constexpr uint8 OPCODE_REX_B = 0x41;

// Colors (BGR)
constexpr uint32 GRAPH_NORMAL = 0x706050;
constexpr uint32 GRAPH_SELECTED = 0xA08070;
constexpr uint32 GRAPH_ABSTRACT = 0x806080;

constexpr uint32 STATUS_INHERITED = 0xA0A0A0;
constexpr uint32 STATUS_OVERRIDDEN = 0x80D080;
constexpr uint32 STATUS_NEW_VIRTUAL = 0x8080D0;
constexpr uint32 STATUS_PURE_TO_IMPL = 0x80D0D0;
constexpr uint32 STATUS_IMPL_TO_PURE = 0xD08080;

constexpr uint32 CLASS_PURE_VIRTUAL = 0xD08080;
constexpr uint32 CLASS_MULTIPLE_INHERIT = 0xD0A080;
constexpr uint32 CLASS_VIRTUAL_INHERIT = 0x8080D0;
constexpr uint32 DEFAULT_BG = 0xFFFFFF;

// Formatters
inline void format_address(char* buf, size_t sz, ea_t addr) {
    qsnprintf(buf, sz, "0x%llX", (unsigned long long)addr);
}

inline void format_sub_address(char* buf, size_t sz, ea_t addr) {
    qsnprintf(buf, sz, "sub_%llX", (unsigned long long)addr);
}

inline void format_index(char* buf, size_t sz, int idx) {
    qsnprintf(buf, sz, "%d", idx);
}

inline void format_function(char* buf, size_t sz, ea_t func) {
    qstring name;
    if (get_name(&name, func) && name.length()) qsnprintf(buf, sz, "%s", name.c_str());
    else format_address(buf, sz, func);
}

// Memory
inline int get_ptr_size() {
    static int ps = inf_is_64bit() ? 8 : 4;
    return ps;
}

inline ea_t read_ptr(ea_t addr) {
    if (!is_mapped(addr)) return BADADDR;
    return get_ptr_size() == 8 ? get_qword(addr) : get_dword(addr);
}

inline int32 read_int32(ea_t addr) {
    return is_mapped(addr) ? get_dword(addr) : 0;
}

inline std::string normalize_msvc_nested_class(const std::string& name) {
    if (name.find('@') == std::string::npos) return name;

    std::vector<std::string> components;
    size_t start = 0;
    size_t pos;

    while ((pos = name.find('@', start)) != std::string::npos) {
        components.push_back(name.substr(start, pos - start));
        start = pos + 1;
    }
    components.push_back(name.substr(start));

    std::string result;
    for (auto it = components.rbegin(); it != components.rend(); ++it) {
        if (it->empty()) continue;
        if (!result.empty()) result += "::";
        result += *it;
    }
    return result;
}

inline std::string clean_msvc_decorated_name(const std::string& name) {
    std::string result = name;

    size_t template_marker = result.rfind("?$");
    if (template_marker != std::string::npos) {
        result = result.substr(template_marker + 2);
    }

    size_t scope_hash = result.find("::$");
    while (scope_hash != std::string::npos) {
        size_t scope_end = result.find("::", scope_hash + 2);
        if (scope_end != std::string::npos) {
            result.erase(scope_hash, scope_end - scope_hash + 2);
        } else {
            break;
        }
        scope_hash = result.find("::$");
    }

    if (!result.empty()) {
        if (result[0] == '$' && result.length() > 3) {
            size_t prefix_end = result.find_first_not_of("0123456789ABCDEFabcdef", 1);
            if (prefix_end != std::string::npos && prefix_end > 1) {
                result = result.substr(prefix_end);
            }
        }
        if (result.length() > 1 && (result[0] == 'V' || result[0] == 'U') && isupper(result[1])) {
            result = result.substr(1);
        }
    }

    return result;
}

} // namespace vtable_utils

```