Project Path: arc_topfreegames_pitaya_nddlsfk5

Source Tree:

```txt
arc_topfreegames_pitaya_nddlsfk5
├── LICENSE
├── Makefile
├── README.md
├── benchmark
│   ├── benchmark_test.go
│   └── testdata
│       ├── gen_proto.bat
│       ├── gen_proto.sh
│       ├── test.pb.go
│       └── test.proto
├── cmd
│   ├── repl.go
│   └── root.go
├── deploy
│   └── kubernetes
│       ├── example-backend.yaml
│       └── example-frontend.yaml
├── docs
│   ├── API.md
│   ├── Makefile
│   ├── builder.md
│   ├── cli.md
│   ├── communication.md
│   ├── conf.py
│   ├── configuration.rst
│   ├── examples.md
│   ├── features.md
│   ├── handshake-validators.md
│   ├── index.rst
│   ├── make.bat
│   ├── overview.md
│   ├── requirements.txt
│   └── tracing.md
├── e2e
│   └── e2e_test.go
├── examples
│   ├── demo
│   │   ├── chat
│   │   │   ├── README.md
│   │   │   ├── main.go
│   │   │   └── web
│   │   │       ├── index.html
│   │   │       ├── protocol.js
│   │   │       └── starx-wsclient.js
│   │   ├── cluster
│   │   │   ├── main.go
│   │   │   └── services
│   │   │       ├── connector.go
│   │   │       └── room.go
│   │   ├── cluster_grpc
│   │   │   ├── main.go
│   │   │   └── services
│   │   │       ├── connector.go
│   │   │       └── room.go
│   │   ├── custom_metrics
│   │   │   ├── README.md
│   │   │   ├── config.yaml
│   │   │   ├── main.go
│   │   │   ├── messages
│   │   │   │   ├── args.go
│   │   │   │   └── responses.go
│   │   │   └── services
│   │   │       └── room.go
│   │   ├── pipeline
│   │   │   └── main.go
│   │   ├── protos
│   │   │   ├── cluster.pb.go
│   │   │   └── cluster.proto
│   │   ├── rate_limiting
│   │   │   ├── main.go
│   │   │   └── services
│   │   │       └── room.go
│   │   └── worker
│   │       ├── main.go
│   │       ├── protos
│   │       │   ├── arg.pb.go
│   │       │   ├── arg.proto
│   │       │   ├── response.pb.go
│   │       │   └── response.proto
│   │       └── services
│   │           ├── metagame.go
│   │           ├── room.go
│   │           └── worker.go
│   └── testing
│       ├── docker
│       │   └── Dockerfile
│       ├── docker-compose-jaeger.yml
│       ├── docker-compose.yml
│       ├── main.go
│       └── protos
│           ├── cluster.pb.go
│           └── cluster.proto
├── go.mod
├── go.sum
├── go.work
├── go.work.sum
├── main.go
├── pitaya-protos
├── pkg
│   ├── acceptor
│   │   ├── acceptor.go
│   │   ├── fixtures
│   │   │   ├── server.crt
│   │   │   └── server.key
│   │   ├── proxyprotowrapper.go
│   │   ├── tcp_acceptor.go
│   │   ├── tcp_acceptor_test.go
│   │   ├── ws_acceptor.go
│   │   └── ws_acceptor_test.go
│   ├── acceptorwrapper
│   │   ├── base.go
│   │   ├── base_test.go
│   │   ├── rate_limiter.go
│   │   ├── rate_limiter_test.go
│   │   ├── rate_limiting_wrapper.go
│   │   ├── rate_limiting_wrapper_test.go
│   │   └── wrapper.go
│   ├── agent
│   │   ├── agent.go
│   │   ├── agent_remote.go
│   │   ├── agent_remote_test.go
│   │   ├── agent_test.go
│   │   └── mocks
│   │       └── agent.go
│   ├── app.go
│   ├── app_test.go
│   ├── builder.go
│   ├── builder_test.go
│   ├── client
│   │   ├── client.go
│   │   ├── client_test.go
│   │   ├── pitayaclient.go
│   │   └── protoclient.go
│   ├── cluster
│   │   ├── cluster.go
│   │   ├── etcd_service_discovery.go
│   │   ├── etcd_service_discovery_test.go
│   │   ├── grpc_rpc_client.go
│   │   ├── grpc_rpc_client_test.go
│   │   ├── grpc_rpc_server.go
│   │   ├── grpc_rpc_server_test.go
│   │   ├── info_retriever.go
│   │   ├── info_retriever_test.go
│   │   ├── mocks
│   │   │   ├── cluster.go
│   │   │   └── service_discovery.go
│   │   ├── nats_rpc_client.go
│   │   ├── nats_rpc_client_test.go
│   │   ├── nats_rpc_common.go
│   │   ├── nats_rpc_common_test.go
│   │   ├── nats_rpc_server.go
│   │   ├── nats_rpc_server_test.go
│   │   ├── server.go
│   │   ├── server_test.go
│   │   └── service_discovery.go
│   ├── component
│   │   ├── base.go
│   │   ├── component.go
│   │   ├── method.go
│   │   ├── method_test.go
│   │   ├── options.go
│   │   ├── options_test.go
│   │   ├── service.go
│   │   └── service_test.go
│   ├── component.go
│   ├── component_test.go
│   ├── config
│   │   ├── config.go
│   │   ├── config_test.go
│   │   └── viper_config.go
│   ├── conn
│   │   ├── codec
│   │   │   ├── constants.go
│   │   │   ├── mocks
│   │   │   │   ├── packet_decoder.go
│   │   │   │   └── packet_encoder.go
│   │   │   ├── packet_decoder.go
│   │   │   ├── packet_encoder.go
│   │   │   ├── pomelo_packet_decoder.go
│   │   │   ├── pomelo_packet_decoder_test.go
│   │   │   ├── pomelo_packet_encoder.go
│   │   │   ├── pomelo_packet_encoder_test.go
│   │   │   └── utils.go
│   │   ├── message
│   │   │   ├── fixtures
│   │   │   │   ├── test_invalid_message.golden
│   │   │   │   ├── test_must_gzip.golden
│   │   │   │   ├── test_notify_type.golden
│   │   │   │   ├── test_notify_type_compressed.golden
│   │   │   │   ├── test_push_type.golden
│   │   │   │   ├── test_push_type_compressed.golden
│   │   │   │   ├── test_reponse_type.golden
│   │   │   │   ├── test_reponse_type_with_data.golden
│   │   │   │   ├── test_reponse_type_with_error.golden
│   │   │   │   ├── test_reponse_type_with_id.golden
│   │   │   │   ├── test_request_type.golden
│   │   │   │   ├── test_request_type_compressed.golden
│   │   │   │   └── test_wrong_type.golden
│   │   │   ├── message.go
│   │   │   ├── message_encoder.go
│   │   │   ├── message_test.go
│   │   │   └── mocks
│   │   │       └── message_encoder.go
│   │   └── packet
│   │       ├── constants.go
│   │       ├── packet.go
│   │       └── packet_test.go
│   ├── constants
│   │   ├── const.go
│   │   ├── errors.go
│   │   └── version.go
│   ├── context
│   │   ├── context.go
│   │   ├── context_test.go
│   │   └── fixtures
│   │       ├── one_element.golden
│   │       └── registered_struct.golden
│   ├── defaultpipelines
│   │   ├── default_struct_validator.go
│   │   ├── default_struct_validator_test.go
│   │   └── struct_validator.go
│   ├── docgenerator
│   │   ├── descriptors.go
│   │   ├── descriptors_test.go
│   │   ├── generator.go
│   │   └── generator_test.go
│   ├── errors
│   │   ├── errors.go
│   │   └── errors_test.go
│   ├── group.go
│   ├── group_test.go
│   ├── groups
│   │   ├── etcd_group_service.go
│   │   ├── etcd_group_service_test.go
│   │   ├── group_service.go
│   │   ├── group_service_test.go
│   │   ├── memory_group_service.go
│   │   └── memory_group_service_test.go
│   ├── helpers
│   │   ├── helpers.go
│   │   └── type_support.go
│   ├── interfaces
│   │   ├── interfaces.go
│   │   └── mocks
│   │       └── interfaces.go
│   ├── kick.go
│   ├── kick_test.go
│   ├── logger
│   │   ├── interfaces
│   │   │   └── interfaces.go
│   │   ├── logger.go
│   │   ├── logger_test.go
│   │   ├── logrus
│   │   │   └── logrus.go
│   │   └── test
│   │       └── test.go
│   ├── metrics
│   │   ├── constants.go
│   │   ├── mocks
│   │   │   ├── reporter.go
│   │   │   └── statsd_reporter.go
│   │   ├── models
│   │   │   └── models.go
│   │   ├── prometheus_reporter.go
│   │   ├── report.go
│   │   ├── report_test.go
│   │   ├── reporter_interfaces.go
│   │   ├── statsd_reporter.go
│   │   └── statsd_reporter_test.go
│   ├── mocks
│   │   ├── acceptor.go
│   │   └── app.go
│   ├── module.go
│   ├── module_test.go
│   ├── modules
│   │   ├── api_docs_gen.go
│   │   ├── base.go
│   │   ├── binary.go
│   │   ├── binary_test.go
│   │   ├── binary_windows.go
│   │   ├── binding_storage.go
│   │   └── unique_session.go
│   ├── networkentity
│   │   ├── mocks
│   │   │   └── networkentity.go
│   │   └── networkentity.go
│   ├── pipeline
│   │   ├── pipeline.go
│   │   └── pipeline_test.go
│   ├── protos
│   │   ├── bind.pb.go
│   │   ├── doc.pb.go
│   │   ├── docmsg.pb.go
│   │   ├── error.pb.go
│   │   ├── kick.pb.go
│   │   ├── mocks
│   │   │   └── pitaya.go
│   │   ├── msg.pb.go
│   │   ├── pitaya.pb.go
│   │   ├── protodescriptor.pb.go
│   │   ├── push.pb.go
│   │   ├── request.pb.go
│   │   ├── response.pb.go
│   │   ├── session.pb.go
│   │   └── test
│   │       ├── somestruct.pb.go
│   │       ├── testrequest.pb.go
│   │       └── testresponse.pb.go
│   ├── push.go
│   ├── push_test.go
│   ├── remote
│   │   ├── sys.go
│   │   └── sys_test.go
│   ├── reporters.go
│   ├── route
│   │   ├── route.go
│   │   └── route_test.go
│   ├── router
│   │   ├── router.go
│   │   └── router_test.go
│   ├── rpc.go
│   ├── rpc_test.go
│   ├── serialize
│   │   ├── json
│   │   │   ├── json.go
│   │   │   └── json_test.go
│   │   ├── mocks
│   │   │   └── serializer.go
│   │   ├── protobuf
│   │   │   ├── fixtures
│   │   │   │   └── TestMarshal
│   │   │   │       └── test_ok.golden
│   │   │   ├── protobuf.go
│   │   │   └── protobuf_test.go
│   │   └── serializer.go
│   ├── service
│   │   ├── base_service.go
│   │   ├── fixtures
│   │   │   ├── unmarshal_remote_test_1.golden
│   │   │   ├── unmarshal_remote_test_2.golden
│   │   │   └── unmarshal_remote_test_3.golden
│   │   ├── handler.go
│   │   ├── handler_pool.go
│   │   ├── handler_pool_test.go
│   │   ├── handler_test.go
│   │   ├── remote.go
│   │   ├── remote_test.go
│   │   ├── util.go
│   │   └── util_test.go
│   ├── session
│   │   ├── fixtures
│   │   │   ├── testSessionSetData_1.golden
│   │   │   ├── testSessionSetData_2.golden
│   │   │   ├── testSessionSetData_3.golden
│   │   │   ├── testSessionSetData_4.golden
│   │   │   ├── testSessionSetData_5.golden
│   │   │   ├── testUpdateEncodedData_1.golden
│   │   │   ├── testUpdateEncodedData_2.golden
│   │   │   ├── testUpdateEncodedData_3.golden
│   │   │   ├── testUpdateEncodedData_4.golden
│   │   │   └── testUpdateEncodedData_5.golden
│   │   ├── mocks
│   │   │   └── session.go
│   │   ├── session.go
│   │   ├── session_test.go
│   │   ├── static.go
│   │   └── test
│   │       └── static_test.go
│   ├── static.go
│   ├── static_test.go
│   ├── timer
│   │   ├── timer.go
│   │   └── timer_test.go
│   ├── timer.go
│   ├── timer_test.go
│   ├── tracing
│   │   ├── otel.go
│   │   ├── span.go
│   │   └── span_test.go
│   ├── util
│   │   ├── compression
│   │   │   ├── compression.go
│   │   │   ├── compression_test.go
│   │   │   └── fixtures
│   │   │       ├── compression_deflate_test_1.golden
│   │   │       ├── compression_deflate_test_2.golden
│   │   │       └── compression_deflate_test_3.golden
│   │   ├── fixtures
│   │   │   ├── gob_encode_test_1.golden
│   │   │   ├── gob_encode_test_2.golden
│   │   │   └── gob_encode_test_3.golden
│   │   ├── util.go
│   │   └── util_test.go
│   └── worker
│       ├── constants.go
│       ├── mocks
│       │   └── rpc_job.go
│       ├── models.go
│       ├── report.go
│       ├── report_test.go
│       ├── rpc_job.go
│       ├── worker.go
│       └── worker_test.go
├── repl
│   ├── commands.go
│   ├── file.go
│   ├── helpers.go
│   ├── log.go
│   ├── main.go
│   └── shell.go
└── xk6-pitaya
    ├── Dockerfile
    ├── LICENSE
    ├── README.md
    ├── client.go
    ├── examples
    │   └── scenario1.js
    ├── go.mod
    ├── go.sum
    ├── module.go
    ├── register.go
    └── stats.go

```

`LICENSE`:

```
Copyright (c) 2018 TFG Co and nano Authors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Makefile`:

```
ifeq ($(OS), Windows_NT)
	BIN := pitaya-cli.exe
	XK6_BIN := k6.exe
	MKFOLDER := if not exist "build" mkdir build
	GREP_CMD := findstr /V
else
	BIN := pitaya-cli
	XK6_BIN := k6
	MKFOLDER := mkdir -p build
	GREP_CMD := grep -v
endif

TESTABLE_PACKAGES = `go list ./... | $(GREP_CMD) examples | $(GREP_CMD) constants | $(GREP_CMD) mocks | $(GREP_CMD) helpers | $(GREP_CMD) interfaces | $(GREP_CMD) protos | $(GREP_CMD) e2e | $(GREP_CMD) benchmark`

setup: init-submodules
	@go get ./...

build:
	@$(MKFOLDER)
	@go build -o build/$(BIN) .
	@echo "build pitaya-cli at ./build/$(BIN)"

build-k6-extension:
	@$(MKFOLDER)
	@xk6 build --with github.com/topfreegames/xk6-pitaya=./xk6-pitaya/ --with github.com/topfreegames/pitaya/v3/pkg=./pkg/ --output ./build/$(XK6_BIN)
	@echo "build pitaya k6 extension at ./build/$(XK6_BIN)"

init-submodules:
	@git submodule init

setup-ci:
	@go install github.com/mattn/goveralls@latest
	@go install github.com/wadey/gocovmerge@latest

setup-protobuf-macos:
	@brew install protobuf
	@go install github.com/golang/protobuf/protoc-gen-go@latest

run-jaeger-aio:
	@docker compose -f ./examples/testing/docker-compose-jaeger.yml up -d
	@echo "Access jaeger UI @ http://localhost:16686"

run-chat-example:
	@cd examples/testing && docker compose up -d etcd nats && cd ../demo/chat/ && go run main.go

run-cluster-example-frontend-tracing:
	@PITAYA_METRICS_PROMETHEUS_PORT=9090 OTEL_SDK_DISABLED=false OTEL_SERVICE_NAME=example-frontend OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4317 OTEL_EXPORTER_OTLP_PROTOCOL=grpc OTEL_TRACES_SAMPLER=parentbased_traceidratio OTEL_TRACES_SAMPLER_ARG="1" go run examples/demo/cluster/main.go

run-cluster-example-backend-tracing:
	@PITAYA_METRICS_PROMETHEUS_PORT=9091 OTEL_SDK_DISABLED=false OTEL_SERVICE_NAME=example-backend OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4317 OTEL_EXPORTER_OTLP_PROTOCOL=grpc OTEL_TRACES_SAMPLER=parentbased_traceidratio OTEL_TRACES_SAMPLER_ARG="1" go run examples/demo/cluster/main.go --port 3251 --type room --frontend=false

run-cluster-example-frontend:
	@PITAYA_METRICS_PROMETHEUS_PORT=9090 go run examples/demo/cluster/main.go

run-cluster-protobuf-frontend-example:
	@cd examples/demo/cluster_protobuf && go run main.go

run-cluster-protobuf-backend-example:
	@cd examples/demo/cluster_protobuf && go run main.go --port 3251 --type room --frontend=false

run-cluster-example-backend:
	@PITAYA_METRICS_PROMETHEUS_PORT=9091 go run examples/demo/cluster/main.go --port 3251 --type room --frontend=false

run-cluster-grpc-example-connector:
	@cd examples/demo/cluster_grpc && go run main.go

run-cluster-grpc-example-room:
	@cd examples/demo/cluster_grpc && go run main.go --port 3251 --rpcsvport 3435 --type room --frontend=false

run-cluster-worker-example-room:
	@cd examples/demo/worker && go run main.go --type room --frontend=true

run-cluster-worker-example-metagame:
	@cd examples/demo/worker && go run main.go --type metagame --frontend=false

run-cluster-worker-example-worker:
	@cd examples/demo/worker && go run main.go --type worker --frontend=false

run-custom-metrics-example:
	@cd examples/demo/custom_metrics && go run main.go --port 3250

run-rate-limiting-example:
	@go run examples/demo/rate_limiting/main.go

protos-compile-demo:
	@protoc -I examples/demo/protos examples/demo/protos/*.proto --go_out=.

protos-compile:
	@cd benchmark/testdata && ./gen_proto.sh
	@protoc -I pitaya-protos/ pitaya-protos/*.proto --go_out=plugins=grpc:protos
	@protoc -I pitaya-protos/test pitaya-protos/test/*.proto --go_out=protos/test

rm-test-temp-files:
	@rm -f cluster/127.0.0.1* 127.0.0.1*
	@rm -f cluster/localhost* localhost*

ensure-testing-bin:
	@[ -f ./examples/testing/server ] || go build -o ./examples/testing/server ./examples/testing/main.go

ensure-testing-deps:
	@cd ./examples/testing && docker compose up -d

ensure-e2e-deps-grpc:
	@cd ./examples/testing && docker compose up -d etcd

kill-testing-deps:
	@cd ./examples/testing && docker compose down; true

kill-jaeger:
	@docker compose -f ./examples/testing/docker-compose-jaeger.yml down; true

e2e-test: e2e-test-nats e2e-test-grpc

e2e-test-nats: ensure-testing-deps ensure-testing-bin
	@echo "===============RUNNING E2E NATS TESTS==============="
	@go test ./e2e/e2e_test.go -update

e2e-test-grpc: ensure-testing-deps ensure-testing-bin
	@echo "===============RUNNING E2E GRPC TESTS==============="
	@go test ./e2e/e2e_test.go -update -grpc

bench-nats-sv:
	@PITAYA_METRICS_PROMETHEUS_PORT=9098 ./examples/testing/server -type game -frontend=false > /dev/null 2>&1 & echo $$! > back.PID
	@PITAYA_METRICS_PROMETHEUS_PORT=9099 ./examples/testing/server -type connector -frontend=true > /dev/null 2>&1 & echo $$! > front.PID

bench-grpc-sv:
	@PITAYA_METRICS_PROMETHEUS_PORT=9098 ./examples/testing/server -grpc -grpcport=3435 -type game -frontend=false > /dev/null 2>&1 & echo $$! > back.PID
	@PITAYA_METRICS_PROMETHEUS_PORT=9099 ./examples/testing/server -grpc -grpcport=3436 -type connector -frontend=true > /dev/null 2>&1 & echo $$! > front.PID

benchmark-test-nats: ensure-testing-deps ensure-testing-bin
	@echo "===============RUNNING BENCHMARK TESTS WITH NATS==============="
	@echo "--- starting testing servers"
	@echo "--- sleeping for 5 seconds"
	@make bench-nats-sv
	@sleep 5
	@go test ./benchmark/benchmark_test.go -bench=.
	@echo "--- killing testing servers"
	@kill `cat back.PID` && rm back.PID
	@kill `cat front.PID` && rm front.PID

benchmark-test-grpc: ensure-e2e-deps-grpc ensure-testing-bin
	@echo "===============RUNNING BENCHMARK TESTS WITH GRPC==============="
	@echo "--- starting testing servers"
	@echo "--- sleeping for 5 seconds"
	@make bench-grpc-sv
	@sleep 5
	@go test ./benchmark/benchmark_test.go -bench=.
	@echo "--- killing testing servers"
	@kill `cat back.PID` && rm back.PID
	@kill `cat front.PID` && rm front.PID

unit-test-coverage: kill-testing-deps
	@echo "===============RUNNING UNIT TESTS==============="
	@go test $(TESTABLE_PACKAGES) -coverprofile coverprofile.out

test: kill-testing-deps test-coverage
	@make rm-test-temp-files
	@make ensure-testing-deps
	@sleep 10
	@make e2e-test

test-coverage: unit-test-coverage
	@make rm-test-temp-files

test-coverage-html: test-coverage
	@go tool cover -html=coverprofile.out

merge-profiles:
	@rm -f coverage-all.out
	@gocovmerge *.out > coverage-all.out

test-coverage-func coverage-func: test-coverage merge-profiles
	@echo
	@echo "\033[1;34m=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\033[0m"
	@echo "\033[1;34mFunctions NOT COVERED by Tests\033[0m"
	@echo "\033[1;34m=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\033[0m"
	@go tool cover -func=coverage-all.out | egrep -v "100.0[%]"

mocks: agent-mock session-mock networkentity-mock pitaya-mock serializer-mock metrics-mock acceptor-mock

agent-mock:
	@mockgen github.com/topfreegames/pitaya/v3/pkg/agent Agent,AgentFactory | sed 's/mock_agent/mocks/' > pkg/agent/mocks/agent.go

session-mock:
	@mockgen github.com/topfreegames/pitaya/v3/pkg/session Session,SessionPool | sed 's/mock_session/mocks/' > pkg/session/mocks/session.go

networkentity-mock:
	@mockgen github.com/topfreegames/pitaya/v3/pkg/networkentity NetworkEntity | sed 's/mock_networkentity/mocks/' > pkg/networkentity/mocks/networkentity.go

pitaya-mock:
	@mockgen github.com/topfreegames/pitaya/v3/pkg Pitaya | sed 's/mock_pkg/mocks/' > pkg/mocks/app.go

metrics-mock:
	@mockgen github.com/topfreegames/pitaya/v3/pkg/metrics Reporter | sed 's/mock_metrics/mocks/' > pkg/metrics/mocks/reporter.go
	@mockgen github.com/topfreegames/pitaya/v3/pkg/metrics Client | sed 's/mock_metrics/mocks/' > pkg/metrics/mocks/statsd_reporter.go

serializer-mock:
	@mockgen github.com/topfreegames/pitaya/v3/pkg/serialize Serializer | sed 's/mock_serialize/mocks/' > pkg/serialize/mocks/serializer.go

acceptor-mock:
	@mockgen github.com/topfreegames/pitaya/v3/pkg/acceptor PlayerConn,Acceptor | sed 's/mock_acceptor/mocks/' > pkg/mocks/acceptor.go

worker-mock:
	@mockgen github.com/topfreegames/pitaya/v3/pkg/worker RPCJob | sed 's/mock_worker/mocks/' > pkg/worker/mocks/rpc_job.go

```

`README.md`:

```md
# pitaya [![Build Status][7]][8] [![Coverage Status][9]][10] [![GoDoc][1]][2] [![Docs][11]][12] [![Go Report Card][3]][4] [![MIT licensed][5]][6]

---

[1]: https://godoc.org/github.com/topfreegames/pitaya?status.svg
[2]: https://godoc.org/github.com/topfreegames/pitaya
[3]: https://goreportcard.com/badge/github.com/topfreegames/pitaya
[4]: https://goreportcard.com/report/github.com/topfreegames/pitaya
[5]: https://img.shields.io/badge/license-MIT-blue.svg
[6]: LICENSE
[7]: https://github.com/topfreegames/pitaya/actions/workflows/tests.yaml/badge.svg
[8]: https://github.com/topfreegames/pitaya/actions/workflows/tests.yaml
[9]: https://coveralls.io/repos/github/topfreegames/pitaya/badge.svg?branch=master
[10]: https://coveralls.io/github/topfreegames/pitaya?branch=master
[11]: https://readthedocs.org/projects/pitaya/badge/?version=latest
[12]: https://pitaya.readthedocs.io/en/latest/?badge=latest

Pitaya is an simple, fast and lightweight game server framework with clustering support and client libraries for iOS, Android, Unity and others through the [C SDK](https://github.com/topfreegames/libpitaya).
It provides a basic development framework for distributed multiplayer games and server-side applications.

## Getting Started

### Prerequisites

* [Go](https://golang.org/) >= 1.16
* [etcd](https://github.com/coreos/etcd) (optional, used for service discovery)
* [nats](https://github.com/nats-io/nats.go) (optional, used for sending and receiving rpc)
* [docker](https://www.docker.com) (optional, used for running etcd and nats dependencies on containers)

### Installing
clone the repo
```
git clone https://github.com/topfreegames/pitaya.git
```
setup pitaya dependencies
```
make setup
```

### Hacking pitaya

Here's one example of running Pitaya:

Start etcd (This command requires docker-compose and will run an etcd container locally. An etcd may be run without docker if preferred.)
```
cd ./examples/testing && docker compose up -d etcd
```
run the connector frontend server from cluster_grpc example
```
make run-cluster-grpc-example-connector
```
run the room backend server from the cluster_grpc example
```
make run-cluster-grpc-example-room
```

Now there should be 2 pitaya servers running, a frontend connector and a backend room. To send requests, use a REPL client for pitaya [pitaya-cli](https://github.com/topfreegames/pitaya/tree/main/pitaya-cli).

```
$ pitaya-cli
Pitaya REPL Client
>>> connect localhost:3250
connected!
>>> request room.room.entry
>>> sv-> {"code":0,"result":"ok"}
```

## Running the tests
```
make test
```
This command will run both unit and e2e tests.

## Contributing
#TODO

## Authors
* **TFG Co** - Initial work

## License
[MIT License](./LICENSE)

## Acknowledgements
* [nano](https://github.com/lonnng/nano) authors for building the framework pitaya is based on.
* [pomelo](https://github.com/NetEase/pomelo) authors for the inspiration on the distributed design and protocol

## Security
If you have found a security vulnerability, please email security@tfgco.com

## Resources
- Other pitaya-related projects
  + [libpitaya-cluster](https://github.com/topfreegames/libpitaya-cluster)
  + [libpitaya](https://github.com/topfreegames/libpitaya)
  + [pitaya-admin](https://github.com/topfreegames/pitaya-admin)
  + [pitaya-bot](https://github.com/topfreegames/pitaya-bot)
  + [pitaya-cli](https://github.com/topfreegames/pitaya/tree/main/pitaya-cli)
  + [pitaya-protos](https://github.com/topfreegames/pitaya-protos)

- Documents
  + [API Reference](https://godoc.org/github.com/topfreegames/pitaya)
  + [In-depth documentation](https://pitaya.readthedocs.io/en/latest/)

- Demo
  + [Implement a chat room in ~100 lines with pitaya and WebSocket](./examples/demo/chat) (adapted from [nano](https://github.com/lonnng/nano)'s example)
  + [Pitaya cluster mode example](./examples/demo/cluster)
  + [Pitaya cluster mode with protobuf protocol example](./examples/demo/cluster_protobuf)

```

`benchmark/benchmark_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package benchmark

import (
	"fmt"
	"os"
	"testing"

	"github.com/sirupsen/logrus"
	"github.com/topfreegames/pitaya/v3/pkg/client"
)

var clients []*client.Client

func getClients(n, port int) []*client.Client {
	c := make([]*client.Client, n)
	for i := 0; i < n; i++ {
		c[i] = client.New(logrus.FatalLevel)
		err := c[i].ConnectTo(fmt.Sprintf("%s:%d", "localhost", port))
		if err != nil {
			panic(err)
		}
	}
	return c

}

func TestMain(m *testing.M) {
	exit := m.Run()
	os.Exit(exit)
}

func BenchmarkCreateManyClients(b *testing.B) {

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		g := client.New(logrus.FatalLevel)
		err := g.ConnectTo(fmt.Sprintf("%s:%d", "localhost", 32222))
		defer g.Disconnect()
		if err != nil {
			b.Logf("failed to connect")
			b.FailNow()
		}
	}

}

func BenchmarkFrontHandlerWithSessionAndRawReturnsRaw(b *testing.B) {
	clients := getClients(1, 32222)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := clients[0].SendRequest("connector.testsvc.testrequestreceivereturnsraw", []byte("ola"))
		if err != nil {
			b.Logf("failed to send request to server")
			b.FailNow()
		}
		<-clients[0].IncomingMsgChan
	}
}

func BenchmarkFrontHandlerWithSessionAndPtrReturnsPtr(b *testing.B) {
	clients := getClients(1, 32222)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := clients[0].SendRequest("connector.testsvc.testrequestreturnsptr", []byte(`{"msg":"bench single"}`))
		if err != nil {
			b.Logf("failed to send request to server")
			b.FailNow()
		}
		<-clients[0].IncomingMsgChan
	}
}

func BenchmarkFrontHandlerWithSessionAndPtrReturnsPtrManyClientsParallel(b *testing.B) {
	numClients := 1000
	clients := getClients(numClients, 32222)

	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_, err := clients[b.N%numClients].SendRequest("connector.testsvc.testrequestreturnsptr", []byte(`{"msg":"bench parall"}`))
			if err != nil {
				b.Logf("failed to send request to server")
				b.FailNow()
			}
			<-clients[b.N%numClients].IncomingMsgChan
		}
	})
}

func BenchmarkFrontHandlerWithSessionAndPtrReturnsPtrParallel(b *testing.B) {
	clients := getClients(1, 32222)

	b.ResetTimer()

	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_, err := clients[0].SendRequest("connector.testsvc.testrequestreturnsptr", []byte(`{"msg":"b"}`))
			if err != nil {
				b.Logf("failed to send request to server")
				b.FailNow()
			}
			<-clients[0].IncomingMsgChan
		}
	})
}

func BenchmarkFrontHandlerWithSessionOnlyReturnsPtr(b *testing.B) {
	clients := getClients(1, 32222)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := clients[0].SendRequest("connector.testsvc.testrequestonlysessionreturnsptr", []byte{})
		if err != nil {
			b.Logf("failed to send request to server")
			b.FailNow()
		}
		<-clients[0].IncomingMsgChan
	}
}

func BenchmarkFrontHandlerWithSessionOnlyReturnsPtrParallel(b *testing.B) {
	clients := getClients(1, 32222)

	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_, err := clients[0].SendRequest("connector.testsvc.testrequestonlysessionreturnsptr", []byte{})
			if err != nil {
				b.Logf("failed to send request to server")
				b.FailNow()
			}
			<-clients[0].IncomingMsgChan
		}
	})
}

func BenchmarkBackHandlerWithSessionOnlyReturnsPtr(b *testing.B) {
	clients := getClients(1, 32222)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := clients[0].SendRequest("game.testsvc.testrequestonlysessionreturnsptr", []byte{})
		if err != nil {
			b.Logf("failed to send request to server")
			b.FailNow()
		}

		<-clients[0].IncomingMsgChan
	}
}

func BenchmarkBackHandlerWithSessionOnlyReturnsPtrParallel(b *testing.B) {
	clients := getClients(1, 32222)

	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_, err := clients[0].SendRequest("game.testsvc.testrequestonlysessionreturnsptr", []byte{})
			if err != nil {
				b.Logf("failed to send request to server")
				b.FailNow()
			}
			<-clients[0].IncomingMsgChan
		}
	})
}

func BenchmarkBackHandlerWithSessionOnlyReturnsPtrParallelMultipleClients(b *testing.B) {
	numClients := 100
	clients := getClients(numClients, 32222)

	b.ResetTimer()

	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			_, err := clients[b.N%numClients].SendRequest("game.testsvc.testrequestonlysessionreturnsptr", []byte{})
			if err != nil {
				b.Logf("failed to send request to server")
				b.FailNow()
			}
			<-clients[b.N%numClients].IncomingMsgChan
		}
	})
}

```

`benchmark/testdata/gen_proto.bat`:

```bat
protoc --gogofaster_out=. *.proto

```

`benchmark/testdata/gen_proto.sh`:

```sh
protoc --go_out . *.proto

```

`benchmark/testdata/test.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: test.proto

package testdata

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Ping struct {
	Content              string   `protobuf:"bytes,1,opt,name=Content" json:"Content,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Ping) Reset()         { *m = Ping{} }
func (m *Ping) String() string { return proto.CompactTextString(m) }
func (*Ping) ProtoMessage()    {}
func (*Ping) Descriptor() ([]byte, []int) {
	return fileDescriptor_test_ab5a0806b9eb7ae2, []int{0}
}
func (m *Ping) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Ping.Unmarshal(m, b)
}
func (m *Ping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Ping.Marshal(b, m, deterministic)
}
func (dst *Ping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ping.Merge(dst, src)
}
func (m *Ping) XXX_Size() int {
	return xxx_messageInfo_Ping.Size(m)
}
func (m *Ping) XXX_DiscardUnknown() {
	xxx_messageInfo_Ping.DiscardUnknown(m)
}

var xxx_messageInfo_Ping proto.InternalMessageInfo

func (m *Ping) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

type Pong struct {
	Content              string   `protobuf:"bytes,2,opt,name=Content" json:"Content,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Pong) Reset()         { *m = Pong{} }
func (m *Pong) String() string { return proto.CompactTextString(m) }
func (*Pong) ProtoMessage()    {}
func (*Pong) Descriptor() ([]byte, []int) {
	return fileDescriptor_test_ab5a0806b9eb7ae2, []int{1}
}
func (m *Pong) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Pong.Unmarshal(m, b)
}
func (m *Pong) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Pong.Marshal(b, m, deterministic)
}
func (dst *Pong) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pong.Merge(dst, src)
}
func (m *Pong) XXX_Size() int {
	return xxx_messageInfo_Pong.Size(m)
}
func (m *Pong) XXX_DiscardUnknown() {
	xxx_messageInfo_Pong.DiscardUnknown(m)
}

var xxx_messageInfo_Pong proto.InternalMessageInfo

func (m *Pong) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func init() {
	proto.RegisterType((*Ping)(nil), "testdata.Ping")
	proto.RegisterType((*Pong)(nil), "testdata.Pong")
}

func init() { proto.RegisterFile("test.proto", fileDescriptor_test_ab5a0806b9eb7ae2) }

var fileDescriptor_test_ab5a0806b9eb7ae2 = []byte{
	// 85 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x2a, 0x49, 0x2d, 0x2e,
	0xd1, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x00, 0xb1, 0x53, 0x12, 0x4b, 0x12, 0x95, 0x14,
	0xb8, 0x58, 0x02, 0x32, 0xf3, 0xd2, 0x85, 0x24, 0xb8, 0xd8, 0x9d, 0xf3, 0xf3, 0x4a, 0x52, 0xf3,
	0x4a, 0x24, 0x18, 0x15, 0x18, 0x35, 0x38, 0x83, 0x60, 0x5c, 0xb0, 0x8a, 0x7c, 0x54, 0x15, 0x4c,
	0x28, 0x2a, 0x92, 0xd8, 0xc0, 0x86, 0x1a, 0x03, 0x02, 0x00, 0x00, 0xff, 0xff, 0x01, 0xcd, 0x56,
	0xda, 0x62, 0x00, 0x00, 0x00,
}

```

`benchmark/testdata/test.proto`:

```proto
syntax = "proto3";
package testdata;

message Ping {
    string Content = 1;
}

message Pong {
    string Content = 2;
}
```

`cmd/repl.go`:

```go
/*
Copyright 2024 Wildlife Studios

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package cmd

import (
	"github.com/spf13/cobra"
	"github.com/topfreegames/pitaya/v3/repl"
)

var docsRoute string
var fileName string
var prettyJSON bool

// replCmd opens pitaya REPL tool
var replCmd = &cobra.Command{
	Use:   "repl",
	Short: "starts pitaya repl tool",
	Long:  `starts pitaya repl tool`,
	Run: func(cmd *cobra.Command, args []string) {
		repl.Start(docsRoute, fileName, prettyJSON)
	},
}

func init() {
	replCmd.Flags().StringVarP(&docsRoute, "docs", "d", "", "route containing the documentation")
	replCmd.Flags().StringVarP(&fileName, "filename", "f", "", "file containing the commands to run")
	replCmd.Flags().BoolVarP(&prettyJSON, "pretty", "p", false, "print pretty jsons")
	rootCmd.AddCommand(replCmd)
}

```

`cmd/root.go`:

```go
/*
Copyright 2024 Wildlife Studios

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package cmd

import (
	"github.com/spf13/cobra"
)

var cfgFile string

// rootCmd represents the base command when called without any subcommands
var rootCmd = &cobra.Command{
	Use:   "pitaya",
	Short: "Pitaya command line utilities",
	Long:  `Pitaya command line utilities`,
	// Uncomment the following line if your bare application
	// has an action associated with it:
	// Run: func(cmd *cobra.Command, args []string) { },
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() {
	cobra.CheckErr(rootCmd.Execute())
}

func init() {
}

```

`deploy/kubernetes/example-backend.yaml`:

```yaml
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  labels:
    app: pitaya-example
  name: backend
  namespace: pitaya-example
spec:
  replicas: 3
  selector:
    matchLabels:
      app: pitaya-example
  template:
    metadata:
      labels:
        app: pitaya-example
        server: backend
    spec:
      containers:
      - image: quay.io/felipejfc/pitaya-example-sv:v1
        command:
          - /server
          - -type
          - game
          - -frontend=false
        env:
        - name: PITAYA_CLUSTER_RPC_CLIENT_NATS_CONNECT
          value: nats://nats-cluster-1.nats-io.svc.cluster.local:4222
        - name: PITAYA_CLUSTER_RPC_SERVER_NATS_CONNECT
          value: nats://nats-cluster-1.nats-io.svc.cluster.local:4222
        - name: PITAYA_CLUSTER_SD_ETCD_ENDPOINTS
          value: etcd-cluster-1.etcd.svc.cluster.local:2379
        - name: PITAYA_HEARTBEAT_INTERVAL
          value: 10s
        name: backend
        resources:
          limits:
            cpu: 1000m
            memory: 300Mi
          requests:
            cpu: 100m
            memory: 200Mi

```

`deploy/kubernetes/example-frontend.yaml`:

```yaml
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  labels:
    app: pitaya-example
  name: frontend
  namespace: pitaya-example
spec:
  replicas: 3
  selector:
    matchLabels:
      app: pitaya-example
  template:
    metadata:
      labels:
        app: pitaya-example
        server: frontend
    spec:
      containers:
      - image: quay.io/felipejfc/pitaya-example-sv:v1
        command:
          - /server
          - -type
          - connector
          - -frontend=true
        env:
        - name: PITAYA_CLUSTER_RPC_CLIENT_NATS_CONNECT
          value: nats://nats-cluster-1.nats-io.svc.cluster.local:4222
        - name: PITAYA_CLUSTER_RPC_SERVER_NATS_CONNECT
          value: nats://nats-cluster-1.nats-io.svc.cluster.local:4222
        - name: PITAYA_CLUSTER_SD_ETCD_ENDPOINTS
          value: etcd-cluster-1.etcd.svc.cluster.local:2379
        - name: PITAYA_HEARTBEAT_INTERVAL
          value: 10s
        name: frontend
        resources:
          limits:
            cpu: 1000m
            memory: 300Mi
          requests:
            cpu: 100m
            memory: 200Mi
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: pitaya-example
  name: frontend
  namespace: pitaya-example
spec:
  ports:
  - name: tcp
    port: 32222
    protocol: TCP
    targetPort: 32222
  selector:
    app: pitaya-example
    server: frontend
  type: LoadBalancer


```

`docs/API.md`:

```md
Pitaya API
==========

## Handlers

Handlers are one of the core features of Pitaya, they are the entities responsible for receiving the requests from the clients and handling them, returning the response if the method is a request handler, or nothing, if the method is a notify handler.

### Signature

Handlers must be public methods of the struct and have a signature following:

Arguments
* `context.Context`: the context of the request, which contains the client's session.
* `pointer or []byte`: the payload of the request (_optional_).

Notify handlers return nothing, while request handlers must return:
* `pointer or []byte`: the response payload
* `error`: an error variable


### Registering handlers

Handlers must be explicitly registered by the application by calling a pitaya app's `Register` with a instance of the handler component. The handler's name can be defined by calling `pitaya/component`.WithName(`"handlerName"`) and the methods can be renamed by using `pitaya/component`.WithNameFunc(`func(string) string`).

The clients can call the handler by calling `serverType.handlerName.methodName`.


### Routing messages

Messages are forwarded by pitaya to the appropriate server type, and custom routers can be added to the application by calling a pitaya app's `AddRoute`, it expects two arguments:

* `serverType`: the server type of the target requests to be routed
* `routingFunction`: the routing function with the signature `func(session.Session, *route.Route, []byte, map[string]*cluster.Server) (*cluster.Server, error)`, it receives the user's session, the route being requested, the message and the map of valid servers of the given type, the key being the servers' ids

The server will then use the routing function when routing requests to the given server type.


### Lifecycle Methods

Handlers can optionally implement the following lifecycle methods:

* `Init()` - Called by Pitaya when initializing the application
* `AfterInit()` - Called by Pitaya after initializing the application
* `BeforeShutdown()` - Called by Pitaya when shutting down components, but before calling shutdown
* `Shutdown()` - Called by Pitaya after the start of shutdown


### Handler example

Below is a very barebones example of a handler definition, for a complete working example, check the [cluster demo](https://github.com/topfreegames/pitaya/tree/master/examples/demo/cluster).

```go
import (
  "github.com/topfreegames/pitaya"
  "github.com/topfreegames/pitaya/component"
)

type Handler struct {
  component.Base
}

type UserRequestMessage struct {
  Name    string `json:"name"`
  Content string `json:"content"`
}

type UserResponseMessage {
}

type UserPushMessage{
  Command string `json:"cmd"`
}

// Init runs on service initialization (not required to be defined)
func (h *Handler) Init() {}

// AfterInit runs after initialization (not required to be defined)
func (h *Handler) AfterInit() {}

// TestRequest can be called by the client by calling <servertype>.testhandler.testrequest
func (h *Handler) TestRequest(ctx context.Context, msg *UserRequestMessage) (*UserResponseMessage, error) {
  return &UserResponseMessage{}, nil
}

func (h *Handler) TestPush(ctx context.Context, msg *UserPushMessage) {
}

func main() {
  builder := pitaya.NewDefaultBuilder()
  ...
  app := builder.Build()

  app.Register(
    &Handler{}, // struct to register as handler
    component.WithName("testhandler"), // name of the handler, used by the clients
    component.WithNameFunc(strings.ToLower), // naming conversion scheme to be used by the clients
  )
  ...
  app.Start()
}

```

## Remotes

Remotes are one of the core features of Pitaya, they are the entities responsible for receiving the RPCs from other Pitaya servers.

### Signature

Remotes must be public methods of the struct and have a signature following:

Arguments
* `context.Context`: the context of the request.
* `proto.Message`: the payload of the request (_optional_).

Remote methods must return:
* `proto.Message`: the response payload in protobuf format
* `error`: an error variable


### Registering remotes

Remotes must be explicitly registered by the application by calling a pitaya app's `RegisterRemote` with a instance of the remote component. The remote's name can be defined by calling `pitaya/component`.WithName(`"remoteName"`) and the methods can be renamed by using `pitaya/component`.WithNameFunc(`func(string) string`).

The servers can call the remote by calling `serverType.remoteName.methodName`.


### RPC calls

There are two options when sending RPCs between servers:
* **Specify only server type**: In this case Pitaya will select one of the available servers at random
* **Specify server type and ID**: In this scenario Pitaya will send the RPC to the specified server


### Lifecycle Methods

Remotes can optionally implement the following lifecycle methods:

* `Init()` - Called by Pitaya when initializing the application
* `AfterInit()` - Called by Pitaya after initializing the application
* `BeforeShutdown()` - Called by Pitaya when shutting down components, but before calling shutdown
* `Shutdown()` - Called by Pitaya after the start of shutdown

### Remote example

For a complete working example, check the [cluster demo](https://github.com/topfreegames/pitaya/tree/master/examples/demo/cluster).

```

`docs/Makefile`:

```
# Minimal makefile for Sphinx documentation
#

# You can set these variables from the command line.
SPHINXOPTS    =
SPHINXBUILD   = sphinx-build
SPHINXPROJ    = Pitaya
SOURCEDIR     = .
BUILDDIR      = _build

# Put it first so that "make" without argument is like "make help".
help:
	@$(SPHINXBUILD) -M help "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

.PHONY: help Makefile

# Catch-all target: route all unknown targets to Sphinx using the new
# "make mode" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).
%: Makefile
	@$(SPHINXBUILD) -M $@ "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)


```

`docs/builder.md`:

```md
Builder
===

Pitaya offers a [`Builder`](../builder.go) object which can be utilized to define a sort of pitaya properties.

### PostBuildHooks

Post-build hooks can be used to execute additional actions automatically after the build process. It also allows you to interact with the built pitaya app.

A common use case is where it becomes necessary to perform configuration steps in both the pitaya builder and the pitaya app being built. In such cases, an effective approach is to internalize these configurations, enabling you to handle them collectively in a single operation or process. It simplifies the overall configuration process, reducing the need for separate and potentially repetitive steps.

```go
// main.go
cfg := config.NewDefaultBuilderConfig()
builder := pitaya.NewDefaultBuilder(isFrontEnd, "my-server-type", pitaya.Cluster, map[string]string{}, *cfg)

customModule := NewCustomModule(builder)
customModule.ConfigurePitaya(builder)

app := builder.Build()

// custom_object.go
type CustomObject struct {
	builder *pitaya.Builder
}

func NewCustomObject(builder *pitaya.Builder) *CustomObject {
	return &CustomObject{
		builder: builder,
	}
}

func (object *CustomObject) ConfigurePitaya() {
	object.builder.AddAcceptor(...)
	object.builder.AddPostBuildHook(func (app pitaya.App) {
		app.Register(...)
	})
}
```

In the above example the `ConfigurePitaya` method of the `CustomObject` is adding an `Acceptor` to the pitaya app being built, and also adding a post-build function which will register a handler `Component` that will expose endpoints to receive calls. 

```

`docs/cli.md`:

```md
Pitaya CLI
==========

A REPL cli client made in go for pitaya.

## Installing

```
go install github.com/topfreegames/pitaya/v3
```

## Usage

For cli flags, run `pitaya-cli --help`

```
$ pitaya

Pitaya command line utilities

Usage:
  pitaya [command]

Available Commands:
  completion  Generate the autocompletion script for the specified shell
  help        Help about any command
  repl        starts pitaya repl tool

Flags:
  -h, --help   help for pitaya

Use "pitaya [command] --help" for more information about a command.

$ pitaya repl

Pitaya REPL Client
>>> help

Commands:
  clear             clear the screen
  connect           connects to pitaya
  disconnect        disconnects from pitaya server
  exit              exit the program
  help              display help
  notify            makes a notify to pitaya server
  push              insert information of push return
  request           makes a request to pitaya server
  sethandshake      sets a handshake parameter
```

### Protobuf
For connecting to a server that uses protobuf as serializer the server must implement two routes:
- Docs: responsible for returning all handlers and the protos used on input and
  output;
- Descriptors: The list of protos descriptions, this will be used by the CLI to
  encode/decode the messages.

To implement those routes you can use some functions provided by pitaya, here is
a short example of both routes:
```go
import (
	// ...

	"github.com/topfreegames/pitaya"
	"github.com/topfreegames/pitaya/protos"
)

// Docs handler
func (c *MyHandler) Docs(ctx context.Context) (*protos.Doc, error) {
	d, err := pitaya.Documentation(true)
	if err != nil {
		return nil, fmt.Errorf("failed to generate documentation for pitaya routes: %w", err)
	}

	doc, err := json.Marshal(d)
	if err != nil {
		return nil, fmt.Errorf("failed to encode documentation JSON: %w", err)
	}

	return &protos.Doc{Doc: string(doc)}, nil
}

// Descriptors route
func (c *MyHandler) Descriptors(ctx context.Context, names *protos.ProtoNames) (*protos.ProtoDescriptors, error) {
	descriptors := make([][]byte, len(names.Name))

	for i, protoName := range names.Name {
		desc, err := pitaya.Descriptor(protoName)
		if err != nil {
			return nil, fmt.Errorf("failed to get descriptor for '%s': %w", protoName, err)
		}

		descriptors[i] = desc
	}

	return &protos.ProtoDescriptors{Desc: descriptors}, nil
}
```

When initilizing the CLI, you have to provide the docs route as the following:
```
pitaya-cli -docs connector.docsHandler.docs
```

NOTE: The descriptors handler is automatically discovered by the client.
It must only follow the signature mentioned earlier.

A full example of running pitaya-cli with protobuf:
```
pitaya-cli -docs connector.docsHandler.docs
>>> push connector.playerHandler.matchfound protos.FindMatchPush
>>> connect localhost:30124
>>> request connector.playerHandler.create
>>> request connector.playerHandler.findmatch {"RoomType":"xxxx"}
```

### Set handshake parameters

You can edit handshake parameters before connecting to the server.

You may pass the full handshake json:
```
Pitaya REPL Client
>>> sethandshake {"sys":{"clientVersion":"1.0.6", "clientBuildNumber":"999","platform":"ios"}}
```

Or edit one of three specific parameters:
```
Pitaya REPL Client
>>> sethandshake platform ios
>>> sethandshake buildNumber 999
>>> sethandshake version 1.0.6
```

### Read commands from file

It's possible to add a list of sequential requests into a file and pitaya-cli will execute them in order.

For example: commands.txt

```
connect localhost:3250
request connector.playerHandler.create
request connector.playerHandler.findmatch {"RoomType":"xxxx"}
```

Then run: `pitaya-cli --filename commands.txt`

```

`docs/communication.md`:

```md
Communication
=============

In this section we will describe in detail the communication process between the client and the server. From establishing the connection, sending a request and receiving a response. The example is going to assume the application is running in cluster mode and that the target server is not the same as the one the client is connected to.


## Establishing the connection

The overview of what happens when a client connects and makes a request is:

* Establish low level connection with acceptor
* Pass the connection to the handler service
* Handler service creates a new agent for the connection
* Handler service reads message from the connection
* Message is decoded with configured decoder
* Decoded packet from the message is processed
* First packet must be a handshake request, to which the server returns a handshake response with the serializer, route dictionary and heartbeat timeout
* Client must then reply with a handshake ack, connection is then established
* Data messages are processed by the handler and the target server type is extracted from the message route, the message is deserialized using the specified method
* If the target server type is different from the current server, the server makes a remote call to the right type of server, selecting one server according to the routing function logic. The remote call includes the current representation of the client's session
* The receiving remote server receives the request and handles it as a _Sys_ RPC call, creating a new remote agent to handle the request, this agent receives the session's representation
* The before pipeline functions are called and the handler message is deserialized
* The appropriate handler is then called by the remote server, which returns the response that is then serialized and the after pipeline functions are executed
* If the backend server wants to modify the session it needs to modify and push the modifications to the frontend server explicitly
* Once the frontend server receives the response it forwards the message to the session specifying the request message ID
* The agent receives the requests, encodes it and sends to the low-level connection

### Acceptors

The first thing the client must do is establish a connection with the Pitaya server. And for that to happen, the server must have specified one or more acceptors.

Acceptors are the entities responsible for listening for connections, establishing them, abstracting and forwarding them to the handler service. Pitaya comes with support for TCP and websocket acceptors. Custom acceptors can be implemented and added to Pitaya applications, they just need to implement the proper interface.

### Handler service

After the low level connection is established it is passed to the handler service to handle. The handler service is responsible for handling the lifecycle of the clients' connections. It reads from the low-level connection, decodes the received packets and handles them properly, calling the local server's handler if the target server type is the same as the local one or forwarding the message to the remote service otherwise.

Pitaya has a configuration to define the number of concurrent messages being processed at the same time, both local and remote messages count for the concurrency, so if the server expects to deal with slow routes this configuration might need to be tweaked a bit. The configuration is `pitaya.concurrency.handler.dispatch`.

### Agent

The agent entity is responsible for storing information about the client's connection, it stores the session, encoder, serializer, state, connection, among others. It is used to communicate with the client to send messages and also ensure the connection is kept alive.

### Route compression

The application can define a dictionary of compressed routes before starting, these routes are sent to the clients on the handshake. Compressing the routes might be useful for the routes that are used a lot to reduce the communication overhead.

### Handshake

The first operation that happens when a client connects is the handshake. The handshake is initiated by the client, who sends information about the client, such as platform, version of the client library, and others, and can also send user data in this step. This data is stored in the client's session and can be accessed later. The server replies with heartbeat interval, name of the serializer and the dictionary of compressed routes.

In order to enforce specific requirements, validations can be performed on the data submitted by the client. These validations server as a means to verify that the client is adherent to predefined server rules. By that if the client does not comply with the specified criteria, access to the server capabilities can be restricted.

You can find more about the handshake validation [here](./handshake-validators.md).

### Remote service

The remote service is responsible both for making RPCs and for receiving and handling them. In the case of a forwarded client request the RPC is of type _Sys_.

In the calling side the service is responsible for identifying the proper server to be called, both by server type and by routing logic.

In the receiving side the service identifies it is a _Sys_ RPC and creates a remote agent to handle the request. This remote agent is short-lived, living only while the request is alive, changes to the backend session do not automatically reflect in the associated frontend session, they need to be explicitly committed by pushing them. The message is then forwarded to the appropriate handler to be processed.

### Pipeline

The pipeline in Pitaya is a set of functions that can be defined to be run before or after every handler request. The functions receive the context and the raw message and should return the request object and error, they are allowed to modify the context and return a modified request. If the before function returns an error the request fails and the process is aborted.

### Serializer

The handler must first deserialize the message before processing it. So the function responsible for calling the handler method first deserializes the message, calls the method and then serializes the response returned by the method and returns it back to the remote service.

### Handler

Each Pitaya server can register multiple handler structures, as long as they have different names. Each structure can have multiple methods and Pitaya will choose the right structure and methods based on the called route.

```

`docs/conf.py`:

```py
# -*- coding: utf-8 -*-
#
# Configuration file for the Sphinx documentation builder.
#
# This file does only contain a selection of the most common options. For a
# full list see the documentation:
# http://www.sphinx-doc.org/en/master/config

# -- Path setup --------------------------------------------------------------

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#
# import os
# import sys
# sys.path.insert(0, os.path.abspath('.'))

from recommonmark.parser import CommonMarkParser

source_parsers = {
    '.md': CommonMarkParser,
}

# -- Project information -----------------------------------------------------

project = u'Pitaya'
copyright = u'2018, TFGCo'
author = u'TFGCo'

# The short X.Y version
version = u''
# The full version, including alpha/beta/rc tags
release = u''


# -- General configuration ---------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#
# needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = ['myst_parser']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix(es) of source filenames.
# You can specify multiple suffix as a list of string:
#
source_suffix = ['.rst', '.md']
# source_suffix = '.rst'

# The master toctree document.
master_doc = 'index'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#
# This is also used if you do content translation via gettext catalogs.
# Usually you set "language" from the command line for these cases.
language = None

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This pattern also affects html_static_path and html_extra_path .
exclude_patterns = [u'_build', 'Thumbs.db', '.DS_Store']

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'


# -- Options for HTML output -------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
html_theme = 'sphinx_rtd_theme'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#
# html_theme_options = {}

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# Custom sidebar templates, must be a dictionary that maps document names
# to template names.
#
# The default sidebars (for documents that don't match any pattern) are
# defined by theme itself.  Builtin themes are using these templates by
# default: ``['localtoc.html', 'relations.html', 'sourcelink.html',
# 'searchbox.html']``.
#
# html_sidebars = {}


# -- Options for HTMLHelp output ---------------------------------------------

# Output file base name for HTML help builder.
htmlhelp_basename = 'Pitayadoc'


# -- Options for LaTeX output ------------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    #
    # 'papersize': 'letterpaper',

    # The font size ('10pt', '11pt' or '12pt').
    #
    # 'pointsize': '10pt',

    # Additional stuff for the LaTeX preamble.
    #
    # 'preamble': '',

    # Latex figure (float) alignment
    #
    # 'figure_align': 'htbp',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
    (master_doc, 'Pitaya.tex', u'Pitaya Documentation',
     u'TFGCo', 'manual'),
]


# -- Options for manual page output ------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    (master_doc, 'pitaya', u'Pitaya Documentation',
     [author], 1)
]


# -- Options for Texinfo output ----------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    (master_doc, 'Pitaya', u'Pitaya Documentation',
     author, 'Pitaya', 'One line description of project.',
     'Miscellaneous'),
]

```

`docs/configuration.rst`:

```rst
*************
Configuration
*************

Pitaya uses Viper to control its configuration. Below we describe the configuration variables split by topic. We judge the default values are good for most cases, but might need to be changed for some use cases.

Service Discovery
=================

These configuration values configure service discovery for the default etcd service discovery module.
 They only need to be set if the application runs in cluster mode.

.. list-table::
  :widths: 15 10 10 50
  :header-rows: 1
  :stub-columns: 1

  * - Configuration
    - Default value
    - Type
    - Description
  * - pitaya.cluster.sd.etcd.dialtimeout
    - 5s
    - time.Time
    - Dial timeout value passed to the service discovery etcd client
  * - pitaya.cluster.sd.etcd.endpoints
    - localhost:2379
    - string
    - List of comma separated etcd endpoints
  * - pitaya.cluster.sd.etcd.user
    - 
    - string
    - Username to connect to etcd
  * - pitaya.cluster.sd.etcd.pass
    - 
    - string
    - Password to connect to etcd
  * - pitaya.cluster.sd.etcd.heartbeat.ttl
    - 60s
    - time.Time
    - Hearbeat interval for the etcd lease
  * - pitaya.cluster.sd.etcd.grantlease.timeout
    - 60s
    - time.Duration
    - Timeout for etcd lease
  * - pitaya.cluster.sd.etcd.grantlease.maxretries
    - 15
    - int
    - Maximum number of attempts to etcd grant lease
  * - pitaya.cluster.sd.etcd.grantlease.retryinterval
    - 5s
    - time.Duration
    - Interval between each grant lease attempt
  * - pitaya.cluster.sd.etcd.revoke.timeout
    - 5s
    - time.Duration
    - Timeout for etcd's revoke function
  * - pitaya.cluster.sd.etcd.heartbeat.log
    - false
    - bool
    - Whether etcd heartbeats should be logged in debug mode
  * - pitaya.cluster.sd.etcd.prefix
    - pitaya/
    - string
    - Prefix used to avoid collisions with different pitaya applications, servers must have the same prefix to be able to see each other
  * - pitaya.cluster.sd.etcd.syncservers.interval
    - 120s
    - time.Duration
    - Interval between server syncs performed by the service discovery module
  * - pitaya.cluster.sd.etcd.shutdown.delay
    - 10ms
    - time.Duration
    - Time to wait to shutdown after deregistering from service discovery
  * - pitaya.cluster.sd.etcd.servertypeblacklist
    - nil
    - []string
    - A list of server types that should be ignored by the service discovery
  * - pitaya.cluster.sd.etcd.syncservers.parallelism
    - 10
    - int
    - The number of goroutines that should be used while getting server information on etcd initialization

RPC Service
===========

The configurations only need to be set if the RPC Service is enabled with the given type.

.. list-table::
  :widths: 15 10 10 50
  :header-rows: 1
  :stub-columns: 1

  * - Configuration
    - Default value
    - Type
    - Description
  * - pitaya.cluster.rpc.server.nats.buffer.messages
    - 75
    - int
    - Size of the buffer that for the nats RPC server accepts before starting to drop incoming messages
  * - pitaya.cluster.rpc.server.nats.buffer.push
    - 100
    - int
    - Size of the buffer that the nats RPC server creates for push messages
  * - pitaya.cluster.rpc.client.grpc.dialtimeout
    - 5s
    - time.Time
    - Timeout for the gRPC client to establish the connection
  * - pitaya.cluster.rpc.client.grpc.lazyconnection
    - false
    - bool
    - Whether the gRPC client should use a lazy connection, that is, connect only when a request is made to that server
  * - pitaya.cluster.rpc.client.grpc.requesttimeout
    - 5s
    - time.Time
    - Request timeout for RPC calls with the gRPC client
  * - pitaya.cluster.rpc.client.nats.connect
    - nats://localhost:4222
    - string
    - Nats address for the client
  * - pitaya.cluster.rpc.client.nats.connectiontimeout
    - 5s
    - time.Duration
    - Timeout for the nats client to establish the connection
  * - pitaya.cluster.rpc.client.nats.requesttimeout
    - 5s
    - time.Time
    - Request timeout for RPC calls with the nats client
  * - pitaya.cluster.rpc.client.nats.maxreconnectionretries
    - 15
    - int
    - Maximum number of retries to reconnect to nats for the client
  * - pitaya.cluster.rpc.client.nats.websocketcompression
    - true
    - bool
    - Enables compression in websocket connections to NATS. Needs both client and server to be enabled
  * - pitaya.cluster.rpc.client.nats.reconnectjitter
    - 100ms
    - time.Time
    - ReconnectJitter sets the upper bound for a random delay added to ReconnectWait during a reconnect when no TLS is used
  * - pitaya.cluster.rpc.client.nats.reconnectjittertls
    - 1s
    - time.Time
    - ReconnectJitterTLS sets the upper bound for a random delay added to ReconnectWait during a reconnect when TLS is used
  * - pitaya.cluster.rpc.client.nats.reconnectwait
    - 1s
    - time.Time
    - ReconnectWait sets the time to backoff after attempting to (and failing to) reconnect
  * - pitaya.cluster.rpc.client.nats.pinginterval
    - 2m
    - time.Time
    - PingInterval is the period at which the client will be sending ping commands to the server, disabled if 0 or negative
  * - pitaya.cluster.rpc.client.nats.maxpingsoutstanding
    - 3
    - int
    - MaxPingsOutstanding is the maximum number of pending ping commands that can be awaiting a response before raising an ErrStaleConnection error
  * - pitaya.cluster.rpc.server.nats.connect
    - nats://localhost:4222
    - string
    - Nats address for the server
  * - pitaya.cluster.rpc.server.nats.connectiontimeout
    - 5s
    - time.Duration
    - Timeout for the nats server to establish the connection
  * - pitaya.cluster.rpc.server.nats.maxreconnectionretries
    - 15
    - int
    - Maximum number of retries to reconnect to nats for the server
  * - pitaya.cluster.rpc.server.nats.websocketcompression
    - true
    - bool
    - Enables compression in websocket connections to NATS. Needs both client and server to be enabled
  * - pitaya.cluster.rpc.server.nats.reconnectjitter
    - 100ms
    - time.Time
    - ReconnectJitter sets the upper bound for a random delay added to ReconnectWait during a reconnect when no TLS is used
  * - pitaya.cluster.rpc.server.nats.reconnectjittertls
    - 1s
    - time.Time
    - ReconnectJitterTLS sets the upper bound for a random delay added to ReconnectWait during a reconnect when TLS is used
  * - pitaya.cluster.rpc.server.nats.reconnectwait
    - 1s
    - time.Time
    - ReconnectWait sets the time to backoff after attempting to (and failing to) reconnect
  * - pitaya.cluster.rpc.server.nats.pinginterval
    - 2m
    - time.Time
    - PingInterval is the period at which the client will be sending ping commands to the server, disabled if 0 or negative
  * - pitaya.cluster.rpc.server.nats.maxpingsoutstanding
    - 3
    - int
    - MaxPingsOutstanding is the maximum number of pending ping commands that can be awaiting a response before raising an ErrStaleConnection error
  * - pitaya.cluster.rpc.server.grpc.port
    - 3434
    - int
    - The port that the gRPC server listens to
  * - pitaya.cluster.rpc.server.nats.services
    - 30
    - int
    - Number of goroutines processing messages at the remote service for the nats RPC service
  * - pitaya.worker.redis.url
    - localhost:6379
    - string
    - Redis url pitaya workers use to register jobs
  * - pitaya.worker.redis.pool
    - 10
    - string
    - Number of connections to keep with Redis
  * - pitaya.worker.redis.password
    - ""
    - string
    - Redis password to connect to pitaya workers redis
  * - pitaya.worker.concurrency
    - 1
    - int
    - Number of workers to execute job
  * - pitaya.worker.namespace
    - ""
    - string
    - Worker namespace, can be used to differ stacks in a blue-green deployment
  * - pitaya.worker.retry.enabled
    - true
    - bool
    - If true, retry job if errored for max times
  * - pitaya.worker.retry.max
    - 5
    - int
    - Max number of job retries
  * - pitaya.worker.retry.exponential
    - 2
    - int
    - Retry job after backoff of nRetry**2
  * - pitaya.worker.retry.minDelay
    - 0
    - int
    - Min time to wait on backoff to retry job
  * - pitaya.worker.retry.maxDelay
    - 10
    - int
    - Max time to wait on backoff to retry job
  * - pitaya.worker.retry.maxRandom
    - 10
    - int
    - Random time to wait during backoff

Connection
==========

.. list-table::
  :widths: 15 10 10 50
  :header-rows: 1
  :stub-columns: 1

  * - Configuration
    - Default value
    - Type
    - Description
  * - pitaya.handler.messages.compression
    - true
    - bool
    - Whether messages between client and server should be compressed
  * - pitaya.heartbeat.interval
    - 30s
    - time.Time
    - Keepalive heartbeat interval for the client connection
  * - pitaya.buffer.agent.writetimeout
    - 10s
    - time.Duration
    - Timeout for agent to send packets
  * - pitaya.conn.ratelimiting.interval
    - 1s
    - time.Duration
    - Window of time to count requests
  * - pitaya.conn.ratelimiting.limit
    - 20
    - int
    - Max number of requests allowed in a interval
  * - pitaya.conn.ratelimiting.forcedisable
    - false
    - bool
    - If true, ignores rate limiting even when added with WithWrappers

Metrics Reporting
=================

.. list-table::
  :widths: 15 10 10 50
  :header-rows: 1
  :stub-columns: 1

  * - Configuration
    - Default value
    - Type
    - Description
  * - pitaya.metrics.statsd.enabled
    - false
    - bool
    - Whether statsd reporting should be enabled
  * - pitaya.metrics.statsd.host
    - localhost:9125
    - string
    - Address of the statsd server to send the metrics to
  * - pitaya.metrics.statsd.prefix
    - pitaya.
    - string
    - Prefix of the metrics reported to statsd
  * - pitaya.metrics.statsd.rate
    - 1
    - int
    - Statsd metrics rate
  * - pitaya.metrics.prometheus.enabled
    - false
    - bool
    - Whether prometheus reporting should be enabled
  * - pitaya.metrics.prometheus.port
    - 9090
    - int
    - Port to expose prometheus metrics
  * - pitaya.metrics.constTags
    - map[string]string{}
    - map[string]string
    - Constant tags to be added to reported metrics
  * - pitaya.metrics.prometheus.additionalTags
    - map[string]string{}
    - map[string]string
    - Additional tags to reported metrics, the map is from tag to default value
  * - pitaya.metrics.period
    - 15s
    - string
    - Period that system metrics will be reported
  * - pitaya.metrics.custom.counters
    - []map[string]interface{}
    - []map[string]interface
    - Custom metrics counter
  * - pitaya.metrics.custom.counters[].Subsystem
    - ""
    - string
    - Custom counter subsystem name
  * - pitaya.metrics.custom.counters[].Name
    - ""
    - string
    - Custom counter name, must not be empty
  * - pitaya.metrics.custom.counters[].Help
    - ""
    - string
    - Custom counter help which explain what is the metric, must not be empty
  * - pitaya.metrics.custom.counters[].Labels
    - []string{}
    - []string
    - Custom counter labels the metric will carry
  * - pitaya.metrics.custom.gauges
    - []map[string]interface{}
    - []map[string]interface
    - Custom metrics gauge 
  * - pitaya.metrics.custom.gauges[].Subsystem
    - ""
    - string
    - Custom gauge subsystem name
  * - pitaya.metrics.custom.gauges[].Name
    - ""
    - string
    - Custom gauge name, must not be empty
  * - pitaya.metrics.custom.gauges[].Help
    - ""
    - string
    - Custom gauge help which explain what is the metric, must not be empty
  * - pitaya.metrics.custom.gauges[].Labels
    - []string{}
    - []string
    - Custom gauge labels the metric will carry
  * - pitaya.metrics.custom.summaries
    - []map[string]interface{}
    - []map[string]interface
    - Custom metrics summary 
  * - pitaya.metrics.custom.summaries[].Subsystem
    - ""
    - string
    - Custom summary subsystem name
  * - pitaya.metrics.custom.summaries[].Name
    - ""
    - string
    - Custom summary name, must not be empty
  * - pitaya.metrics.custom.summaries[].Help
    - ""
    - string
    - Custom summary help which explain what is the metric, must not be empty
  * - pitaya.metrics.custom.summaries[].Labels
    - []string{}
    - []string
    - Custom summary labels the metric will carry
  * - pitaya.metrics.custom.summaries[].Objectives
    - map[float64]float64
    - map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001}
    - Custom summary objectives with quantiles 

Concurrency
===========

.. list-table::
  :widths: 15 10 10 50
  :header-rows: 1
  :stub-columns: 1

  * - Configuration
    - Default value
    - Type
    - Description
  * - pitaya.buffer.agent.messages
    - 100
    - int
    - Buffer size for received client messages for each agent
  * - pitaya.buffer.handler.localprocess
    - 20
    - int
    - Buffer size for messages received by the handler and processed locally
  * - pitaya.buffer.handler.remoteprocess
    - 20
    - int
    - Buffer size for messages received by the handler and forwarded to remote servers
  * - pitaya.concurrency.handler.dispatch
    - 25
    - int
    - Number of goroutines processing messages at the handler service

Modules
=======

These configurations are only used if the modules are created. It is recommended to use Binding Storage module with gRPC RPC service to be able to use all RPC service features.

.. list-table::
  :widths: 15 10 10 50
  :header-rows: 1
  :stub-columns: 1

  * - Configuration
    - Default value
    - Type
    - Description
  * - pitaya.session.unique
    - true
    - bool
    - Whether Pitaya should enforce unique sessions for the clients, enabling the unique sessions module
  * - pitaya.modules.bindingstorage.etcd.endpoints
    - localhost:2379
    - string
    - Comma separated list of etcd endpoints to be used by the binding storage module, should be the same as the service discovery etcd
  * - pitaya.modules.bindingstorage.etcd.prefix
    - pitaya/
    - string
    - Prefix used for etcd, should be the same as the service discovery
  * - pitaya.modules.bindingstorage.etcd.dialtimeout
    - 5s
    - time.Time
    - Timeout to establish the etcd connection
  * - pitaya.modules.bindingstorage.etcd.leasettl
    - 1h
    - time.Time
    - Duration of the etcd lease before automatic renewal

Default Pipelines
=================

These configurations control if the default pipelines should be enabled or not

.. list-table::
  :widths: 15 10 10 50
  :header-rows: 1
  :stub-columns: 1

  * - Configuration
    - Default value
    - Type
    - Description
  * - pitaya.defaultpipelines.structvalidation.enabled
    - false
    - bool
    - Whether Pitaya should enable the default struct validator for handler arguments

Groups
=================

These configurations are used for group services implementations.

.. list-table::
  :widths: 15 10 10 50
  :header-rows: 1
  :stub-columns: 1

  * - Configuration
    - Default value
    - Type
    - Description
  * - pitaya.groups.etcd.endpoints
    - localhost:2379
    - string
    - Comma separated list of etcd endpoints to be used by the groups etcd service 
  * - pitaya.groups.etcd.prefix
    - pitaya/
    - string 
    - Prefix used for every group key in etcd
  * - pitaya.groups.etcd.dialtimeout
    - 5s
    - time.Time
    - Timeout to establish the etcd group connection
  * - pitaya.groups.etcd.transactiontimeout
    - 5s
    - time.Duration
    - Timeout to finish group request to Etcd
  * - pitaya.groups.memory.tickduration
    - 30s
    - time.Duration
    - Duration time of tick that will check if should delete group or not

```

`docs/examples.md`:

```md
Examples
========

Example projects can be found [here](https://github.com/topfreegames/pitaya/tree/master/examples/demo)


```

`docs/features.md`:

```md
Features
========

Pitaya has a modular and configurable architecture which helps to hide the complexity of scaling the application and managing clients' sessions and communications.

Some of its core features are described below.

## Frontend and backend servers

In cluster mode servers can either be a frontend or backend server.

Frontend servers must specify listeners for receiving incoming client connections. They are capable of forwarding received messages to the appropriate servers according to the routing logic.

Backend servers don't listen for connections, they only receive RPCs, either forwarded client messages (sys rpc) or RPCs from other servers (user rpc).

## Groups

Groups are structures which store information about target users and allows sending broadcast messages to all users in the group and also multicast messages to a subset of the users according to some criteria.

They are useful for creating game rooms for example, you just put all the players from a game room into the same group and then you'll be able to broadcast the room's state to all of them.

## Listeners

Frontend servers must specify one or more acceptors to handle incoming client connections, Pitaya comes with TCP and Websocket acceptors already implemented, and other acceptors can be added to the application by implementing the acceptor interface.

## Acceptor Wrappers

Wrappers can be used on acceptors, like TCP and Websocket, to read and change incoming data before performing the message forwarding. To create a new wrapper just implement the Wrapper interface (or inherit the struct from BaseWrapper) and add it into your acceptor by using the WithWrappers method. Next there are some examples of acceptor wrappers. 

### Rate limiting
Read the incoming data on each player's connection to limit requests troughput. After the limit is exceeded, requests are dropped until slots are available again. The requests count and management is done on player's connection, therefore it happens even before session bind. The used algorithm is the [Leaky Bucket](https://en.wikipedia.org/wiki/Leaky_bucket#Comparison_with_the_token_bucket_algorithm). This algorithm represents a leaky bucket that has its output flow slower than its input flow. It saves each request timestamp in a `slot` (of a total of `limit` slots) and this slot is freed again after `interval`. For example: if `limit` of 1 request in an `interval` of 1 second, when a request happens at 0.2s the next request will only be handled by pitaya after 1s (at 1.2s).

```
0     request
|--------|
   0.2s
0                 available again
|------------------------|
|- 0.2s -|----- 1s ------|
```

## Message forwarding

When a server instance receives a client message, it checks the target server type by looking at the route. If the target server type is different from the receiving server type, the instance forwards the message to an appropriate server instance of the correct type. The client doesn't need to take any action to forward the message, this process is done automatically by Pitaya.

By default the routing function chooses one instance of the target server type at random. Custom functions can be defined to change this behavior.

## Message push

Messages can be pushed to users without previous information about either session or connection status. These push messages have a route (so that the client can identify the source and treat properly), the message, the target ids and the server type the client is expected to be connected to.

## Modules

Modules are entities that can be registered to the Pitaya application and must implement the defined [interface](https://github.com/topfreegames/pitaya/tree/master/interfaces/interfaces.go#L24). Pitaya is responsible for calling the appropriate lifecycle methods as needed, the registered modules can be retrieved by name.

### SessionModules

SessionModules are an extension of the Module interface. If a module implements the `interfaces.SessionModule` interface, and session draining is enabled in Pitaya, Pitaya will not shut down before all SessionModules report their session count as zero.

When Pitaya receives a SIGTERM signal, it will invoke the `StartSessionDraining` method on all registered SessionModules. After this Pitaya will periodically call the `SessionCount` method on all registered SessionModules to check if they have reached zero.

**Note:** Pitaya will shut down after the session drain timeout has passed, or it receives another signal, even if the session count is not zero.

### Built in modules

Pitaya comes with a few already implemented modules, and more modules can be implemented as needed. The modules Pitaya has currently are:

#### Binary

This module starts a binary as a child process and pipes its stdout and stderr to info and error log messages, respectively.

#### Unique session

This module adds a callback for `OnSessionBind` that checks if the id being bound has already been bound in one of the other frontend servers.

#### Binding storage

This module implements functionality needed by the gRPC RPC implementation to enable the functionality of broadcasting session binds and pushes to users without knowledge of the servers the users are connected to.

## Monitoring

Pitaya has support for metrics reporting, it comes with Prometheus and Statsd support already implemented and has support for custom reporters that implement the `Reporter` interface. Pitaya also comes with support for open tracing compatible frameworks, allowing the easy integration of Jaeger and others.

The list of metrics reported by the `Reporter` is: 

- Response time: the time to process a message, in nanoseconds. It is segmented
  by route, status, server type and response code;
- Process delay time: the delay to start processing a message, in nanoseconds;
  It is segmented by route and server type;
- Exceeded Rate Limit: the number of blocked requests by exceeded rate limiting;
- Connected clients: number of clients connected at the moment;
- Server count: the number of discovered servers by service discovery. It is
  segmented by server type;
- Channel capacity: the available capacity of the channel;
- Dropped messages: the number of rpc server dropped messages, that is, messages that are not handled;
- Goroutines count: the current number Goroutines;
- Heap size: the current heap size;
- Heap objects count: the current number of objects at the heap;
- Worker jobs retry: the current amount of RPC reliability worker job retries; 
- Worker jobs total: the current amount of RPC reliability worker jobs. It is
  segmented by job status;
- Worker queue size: the current size of RPC reliability worker job queues. It
  is segmented by each available queue.

### Custom Metrics

Besides pitaya default monitoring, it is possible to create new metrics. If using only Statsd reporter, no configuration is needed. If using Prometheus, it is necessary do add a configuration specifying the metrics parameters. More details on [doc](configuration.html#metrics-reporting) and this [example](https://github.com/topfreegames/pitaya/tree/master/examples/demo/custom_metrics).

## Pipelines

Pipelines are middlewares which allow methods to be executed before and after handler requests, they receive the request's context and request data and return the request data, which is passed to the next method in the pipeline.

## RPCs

Pitaya has support for RPC calls when in cluster mode, there are two components to enable this, RPC client and RPC server. There are currently two options for using RPCs implemented for Pitaya, NATS and gRPC, the default is NATS.

There are two types of RPCs, _Sys_ and _User_.

### Sys RPCs

These are the RPCs done by the servers when forwarding handler messages to the appropriate server type.

### User RPCs

User RPCs are done when the application actively calls a remote method in another server. The call can specify the ID of the target server or let Pitaya choose one according to the routing logic.

### User Reliable RPCs

These are done when the application calls a remote using workers, that is, Pitaya retries the RPC if any error occurrs.

**Important**: the remote that is being called must be idempotent; also the ReliableRPC will not return the remote's reply since it is asynchronous, it only returns the job id (jid) if success.

### Customize Timeout Per-Request

The only thing you need to do to customize the timeout value of a RPC Request,is that like below:

```
ctx := pcontext.AddToPropagateCtx(context.Background(), constants.RequestTimeout, (60 * time.Second).String())
```

then transfer the ctx to RPC() or RPCTo() function as the context parameter

**Note**: this feature is only supportted while using nats currently.

## Server operation mode

Pitaya has two types of operation: standalone and cluster mode.

### Standalone mode

In standalone mode the servers don't interact with one another, don't use service discovery and don't have support to RPCs. This is a limited version of the framework which can be used when the application doesn't need to have different types of servers or communicate among them.

### Cluster mode

Cluster mode is a more complete mode, using service discovery, RPC client and server and remote communication among servers of the application. This mode is useful for more complex applications, which might benefit from splitting the responsabilities among different specialized types of servers. This mode already comes with default services for RPC calls and service discovery.

## Serializers

Pitaya has support for different types of message serializers for the messages sent to and from the client, the default serializer is the JSON serializer and Pitaya comes with native support for the Protobuf serializer as well. New serializers can be implemented by implementing the `serialize.Serializer` interface.

The desired serializer can be set by the application by calling the `SetSerializer` method from the `pitaya` package.

## Service discovery

Servers operating in cluster mode must have a service discovery client to be able to work. Pitaya comes with a default client using etcd, which is used if no other client is defined. The service discovery client is responsible for registering the server and keeping the list of valid servers updated, as well as providing information about requested servers as needed.

## Sessions

Every connection established by the clients has an associated session instance, which is ephemeral and destroyed when the connection closes. Sessions are part of the core functionality of Pitaya, because they allow asynchronous communication with the clients and storage of data between requests. The main features of sessions are:

* **ID binding** - Sessions can be bound to an user ID, allowing other parts of the application to send messages to the user without needing to know which server or connection the user is connected to
* **Data storage** - Sessions can be used for data storage, storing and retrieving data between requests
* **Message passing** - Messages can be sent to connected users through their sessions, without needing to have knowledge about the underlying connection protocol
* **Accessible on requests** - Sessions are accessible on handler requests in the context instance
* **Kick** - Users can be kicked from the server through the session's `Kick` method

Even though sessions are accessible on handler requests both on frontend and backend servers, their behavior is a bit different if they are a frontend or backend session. This is mostly due to the fact that the session actually lives in the frontend servers, and just a representation of its state is sent to the backend server.

A session is considered a frontend session if it is being accessed from a frontend server, and a backend session is accessed from a backend server. Each kind of session is better described below.

### Frontend sessions

Sessions are associated to a connection in the frontend server, and can be retrieved by session ID or bound user ID in the server the connection was established, but cannot be retrieved from a different server.

Callbacks can be added to some session lifecycle changes, such as closing and binding. The callbacks can be on a per-session basis (with `s.OnClose`) or for every session (with `OnSessionClose`, `OnSessionBind` and `OnAfterSessionBind`).

### Backend sessions

Backend sessions have access to the sessions through the handler's methods, but they have some limitations and special characteristics. Changes to session variables must be pushed to the frontend server by calling `s.PushToFront` (this is not needed for `s.Bind` operations), setting callbacks to session lifecycle operations is also not allowed. One can also not retrieve a session by user ID from a backend server.


```

`docs/handshake-validators.md`:

```md
Handshake Validators
=====

Pitaya allows to defined Handshake Validators.<br />

The primary purpose of these validators is to perform validation checks on the data transmitted by the client. The validators play a crucial role in verifying the integrity and reliability of the client's input before establishing a connection.

In addition to data validation, handshake validators can also execute other custom logic to assess the client's compliance with the server-defined requirements. This additional logic may involve evaluating factors such as authenticating credentials, permissions, or any other criteria necessary to determine the client's eligibility to access the server.

### Adding handshake validators

To ensure the effective utilization of these validators, they should be added to the `SessionPool` component. As a result, each newly created session within the `SessionPool` will automatically incorporate the designated validators.

Once the handshake process is initiated, the validators will be invoked to execute their validation routines.

```go
cfg := config.NewDefaultBuilderConfig()
builder := pitaya.NewDefaultBuilder(isFrontEnd, "my-server-type", pitaya.Cluster, map[string]string{}, *cfg)
builder.SessionPool.AddHandshakeValidator("MyCustomValidator", func (data *session.HandshakeData) error {
	if data.Sys.Version != "1.0.0" {
		return errors.New("Unknown client version")
	}

	return nil
})
```

As a result of the validation process, if an error is encountered, the server will transmit a message to client within the code 400. This code emulates the widely recognized HTTP Bad Request status code, indicating that the client's request could not be fulfilled due to invalid data. Otherwise, if the validation process succeeds, the server will dispatch a message to client containing a code 200, mirroring the HTTP Ok status code.<br />
**Is important to mention that, when there are many validator functions, the validation will stop as soon it encounters the first error.**

```

`docs/index.rst`:

```rst
.. Pitaya documentation master file, created by
   sphinx-quickstart on Mon Jul 16 17:01:02 2018.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Welcome to Pitaya's documentation!
==================================

.. toctree::
   :maxdepth: 2
   :caption: Contents:

   overview
   features
   communication
   configuration
   API
   cli
   examples
   tracing


Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`

```

`docs/make.bat`:

```bat
@ECHO OFF

pushd %~dp0

REM Command file for Sphinx documentation

if "%SPHINXBUILD%" == "" (
	set SPHINXBUILD=sphinx-build
)
set SOURCEDIR=.
set BUILDDIR=_build
set SPHINXPROJ=Pitaya

if "%1" == "" goto help

%SPHINXBUILD% >NUL 2>NUL
if errorlevel 9009 (
	echo.
	echo.The 'sphinx-build' command was not found. Make sure you have Sphinx
	echo.installed, then set the SPHINXBUILD environment variable to point
	echo.to the full path of the 'sphinx-build' executable. Alternatively you
	echo.may add the Sphinx directory to PATH.
	echo.
	echo.If you don't have Sphinx installed, grab it from
	echo.http://sphinx-doc.org/
	exit /b 1
)

%SPHINXBUILD% -M %1 %SOURCEDIR% %BUILDDIR% %SPHINXOPTS%
goto end

:help
%SPHINXBUILD% -M help %SOURCEDIR% %BUILDDIR% %SPHINXOPTS%

:end
popd

```

`docs/overview.md`:

```md
Overview
========

Pitaya is an easy to use, fast and lightweight game server framework inspired by [starx](https://github.com/lonnng/starx) and [pomelo](https://github.com/NetEase/pomelo) and built on top of [nano](https://github.com/lonnng/nano)'s networking library.

The goal of pitaya is to provide a basic, robust development framework for distributed multiplayer games and server-side applications.

## Features

* **User sessions** - Pitaya has support for user sessions, allowing binding sessions to user ids, setting custom data and retrieving it in other places while the session is active
* **Cluster support** - Pitaya comes with support to default service discovery and RPC modules, allowing communication between different types of servers with ease
* **WS and TCP listeners** - Pitaya has support for TCP and Websocket acceptors, which are abstracted from the application receiving the requests
* **Handlers and remotes** - Pitaya allows the application to specify its handlers, which receive and process client messages, and its remotes, which receive and process RPC server messages. They can both specify custom init, afterinit and shutdown methods
* **Message forwarding** - When a server receives a handler message it forwards the message to the server of the correct type
* **Client library SDK** - [libpitaya](https://github.com/topfreegames/libpitaya) is the official client library SDK for Pitaya
* **Monitoring** - Pitaya has support for Prometheus and statsd by default and accepts other custom reporters that implement the Reporter interface
* **Open tracing compatible** - Pitaya is compatible with [OpenTelemetry](https://opentelemetry.io/), so using [Jaeger](https://github.com/jaegertracing/jaeger) or any other compatible tracing framework is simple
* **Custom modules** - Pitaya already has some default modules and supports custom modules as well
* **Custom serializers** - Pitaya natively supports JSON and Protobuf messages and it is possible to add other custom serializers as needed
* **Write compatible servers in other languages** - Using [libpitaya-cluster](https://github.com/topfreegames/libpitaya-cluster) its possible to write pitaya-compatible servers in other languages that are able to register in the cluster and handle RPCs, there's already a csharp library that's compatible with unity and a WIP of a python library in the repo.
* **REPL Client for development/debugging** - [Pitaya-cli](https://github.com/topfreegames/pitaya-cli) is a REPL client that can be used for making development and debugging of pitaya servers easier.
* **Bots for integration/stress tests** - [Pitaya-bot](https://github.com/topfreegames/pitaya-bot) is a server test framework that can easily copy users behaviour to test corner case scenarios, which can validate the responses received, or make massive accesses into pitaya servers. 

## Architecture

Pitaya was developed considering modularity and extendability at its core, while providing solid basic functionalities to abstract client interactions to well defined interfaces. The full API documentation is available in Godoc format at [godoc](https://godoc.org/github.com/topfreegames/pitaya).

## Who's Using it

Well, right now, only us at TFG Co, are using it, but it would be great to get a community around the project. Hope to hear from you guys soon!

## How To Contribute?

Just the usual: Fork, Hack, Pull Request. Rinse and Repeat. Also don't forget to include tests and docs (we are very fond of both).

```

`docs/requirements.txt`:

```txt
sphinx-markdown-tables==0.0.17
recommonmark==0.7.1
sphinx-rtd-theme==2.0.0
myst-parser==3.0.1

```

`docs/tracing.md`:

```md
Tracing
=======

Pitaya supports tracing using [OpenTelemetry](https://opentelemetry.io/).

### Using OpenTelemetry tracing

Pitaya supports tracing using [OpenTelemetry](https://opentelemetry.io/). To enable and configure OpenTelemetry tracing, you can use standard OpenTelemetry environment variables.

First, make sure to call the `InitializeOtel` function in your main application:

```go
func main() {
    // ...
    err := tracing.InitializeOtel()
    if err != nil {
        logger.Log.Errorf("Failed to initialize OpenTelemetry: %v", err)
    }
    // ...
}
```

### Configuration Options

OpenTelemetry can be configured using standard environment variables. Here are some key variables you might want to set:

- `OTEL_SERVICE_NAME`: The name of your service.
- `OTEL_EXPORTER_OTLP_ENDPOINT`: The endpoint of your OpenTelemetry collector.
- `OTEL_EXPORTER_OTLP_PROTOCOL`: The protocol to use (e.g., `grpc` or `http/protobuf`).
- `OTEL_TRACES_SAMPLER`: The sampling strategy to use.
- `OTEL_TRACES_SAMPLER_ARG`: The argument for the sampling strategy.
- `OTEL_SDK_DISABLED`: Set to `true` to disable tracing.

For a complete list of OpenTelemetry environment variables, refer to the [OpenTelemetry specification](https://opentelemetry.io/docs/concepts/sdk-configuration/general-sdk-configuration/).

### Testing Locally

To test OpenTelemetry tracing locally, you can use Jaeger as your tracing backend. First, start Jaeger using Docker:

```bash
make run-jaeger-aio
make run-cluster-example-frontend-tracing
make run-cluster-example-backend-tracing
```

The last two commands will run your Pitaya servers with OpenTelemetry configured with the following envs:

```bash
OTEL_SERVICE_NAME=example-frontend OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4317 OTEL_EXPORTER_OTLP_PROTOCOL=grpc OTEL_TRACES_SAMPLER=parentbased_traceidratio OTEL_TRACES_SAMPLER_ARG="1"

OTEL_SERVICE_NAME=example-backend OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4317 OTEL_EXPORTER_OTLP_PROTOCOL=grpc OTEL_TRACES_SAMPLER=parentbased_traceidratio OTEL_TRACES_SAMPLER_ARG="1"
```

Access the Jaeger UI at http://localhost:16686 to view and analyze your traces.
```

`e2e/e2e_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package e2e

import (
	"flag"
	"fmt"
	"os"
	"os/exec"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/client"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/helpers"
)

var update = flag.Bool("update", false, "update server binary")
var grpc = flag.Bool("grpc", false, "use grpc server and client")

func TestMain(m *testing.M) {
	flag.Parse()
	if *update {
		cmd := exec.Command("go", "build", "-o", "../examples/testing/server", "../examples/testing/main.go")
		err := cmd.Run()
		if err != nil {
			panic(err)
		}
	}
	exit := m.Run()
	os.Exit(exit)
}

func TestHandlerCallToFront(t *testing.T) {
	tables := []struct {
		req  string
		data []byte
		resp []byte
	}{
		{"connector.testsvc.testrequestonlysessionreturnsptr", []byte(``), []byte(`{"code":200,"msg":"hello"}`)},
		{"connector.testsvc.testrequestonlysessionreturnsptrnil", []byte(``), []byte(`{"code":"PIT-000","msg":"reply must not be null"}`)},
		{"connector.testsvc.testrequestonlysessionreturnsrawnil", []byte(``), []byte(`{"code":"PIT-000","msg":"reply must not be null"}`)},
		{"connector.testsvc.testrequestreturnsptr", []byte(`{"msg":"good"}`), []byte(`{"code":200,"msg":"good"}`)},
		{"connector.testsvc.testrequestreturnsraw", []byte(`{"msg":"good"}`), []byte(`good`)},
		{"connector.testsvc.testrequestreceivereturnsraw", []byte(`woow`), []byte(`woow`)},
		{"connector.testsvc.nonexistenthandler", []byte(`woow`), []byte(`{"code":"PIT-404","msg":"pitaya/handler: connector.testsvc.nonexistenthandler not found"}`)},
		{"connector.testsvc.testrequestreturnserror", []byte(`woow`), []byte(`{"code":"PIT-555","msg":"somerror"}`)},
	}
	port := helpers.GetFreePort(t)
	sdPrefix := fmt.Sprintf("%s/", uuid.New().String())

	defer helpers.StartServer(t, true, true, "connector", port, sdPrefix, *grpc, false)()
	c := client.New(logrus.InfoLevel)

	err := c.ConnectTo(fmt.Sprintf("localhost:%d", port))
	assert.NoError(t, err)
	defer c.Disconnect()

	for _, table := range tables {
		t.Run(table.req, func(t *testing.T) {
			_, err = c.SendRequest(table.req, table.data)
			assert.NoError(t, err)

			msg := helpers.ShouldEventuallyReceive(t, c.IncomingMsgChan).(*message.Message)
			assert.Equal(t, message.Response, msg.Type)
			assert.Equal(t, table.resp, msg.Data)
		})
	}
}

func TestGroupFront(t *testing.T) {
	port := helpers.GetFreePort(t)

	sdPrefix := fmt.Sprintf("%s/", uuid.New().String())
	defer helpers.StartServer(t, true, true, "connector", port, sdPrefix, *grpc, false)()
	c1 := client.New(logrus.InfoLevel)
	c2 := client.New(logrus.InfoLevel)

	err := c1.ConnectTo(fmt.Sprintf("localhost:%d", port))
	assert.NoError(t, err)
	defer c1.Disconnect()

	err = c2.ConnectTo(fmt.Sprintf("localhost:%d", port))
	assert.NoError(t, err)
	defer c2.Disconnect()

	_, err = c1.SendRequest("connector.testsvc.testbind", []byte{})
	assert.NoError(t, err)
	_, err = c2.SendRequest("connector.testsvc.testbind", []byte{})
	assert.NoError(t, err)

	msg1 := helpers.ShouldEventuallyReceive(t, c1.IncomingMsgChan).(*message.Message)
	msg2 := helpers.ShouldEventuallyReceive(t, c2.IncomingMsgChan).(*message.Message)

	assert.Equal(t, []byte("ack"), msg1.Data)
	assert.Equal(t, []byte("ack"), msg2.Data)

	tables := []struct {
		route string
		data  []byte
	}{
		{"connector.testsvc.testsendgroupmsg", []byte("testing group")},
		{"connector.testsvc.testsendgroupmsgptr", []byte(`{"msg":"hellow"}`)},
	}

	for _, table := range tables {
		c1.SendNotify(table.route, table.data)
		msg1 = helpers.ShouldEventuallyReceive(t, c1.IncomingMsgChan).(*message.Message)
		msg2 = helpers.ShouldEventuallyReceive(t, c2.IncomingMsgChan).(*message.Message)

		assert.Equal(t, message.Push, msg1.Type)
		assert.Equal(t, message.Push, msg2.Type)

		assert.Equal(t, table.data, msg1.Data)
		assert.Equal(t, table.data, msg2.Data)
	}
}

func TestKick(t *testing.T) {
	port1 := helpers.GetFreePort(t)

	sdPrefix := fmt.Sprintf("%s/", uuid.New().String())
	defer helpers.StartServer(t, true, true, "connector", port1, sdPrefix, *grpc, false)()
	c1 := client.New(logrus.InfoLevel)
	c2 := client.New(logrus.InfoLevel)

	err := c1.ConnectTo(fmt.Sprintf("localhost:%d", port1))
	assert.NoError(t, err)
	defer c1.Disconnect()

	err = c2.ConnectTo(fmt.Sprintf("localhost:%d", port1))
	assert.NoError(t, err)
	defer c2.Disconnect()

	uid1 := uuid.New().String()
	_, err = c1.SendRequest("connector.testsvc.testbindid", []byte(uid1))
	assert.NoError(t, err)

	helpers.ShouldEventuallyReceive(t, c1.IncomingMsgChan)

	_, err = c2.SendRequest("connector.testsvc.testrequestkickuser", []byte(uid1))
	assert.NoError(t, err)

	helpers.ShouldEventuallyReceive(t, c2.IncomingMsgChan)

	helpers.ShouldEventuallyReturn(t, func() bool {
		return c1.Connected
	}, false, 10*time.Millisecond, 1*time.Second)
}

func TestSameUIDUserShouldBeKicked(t *testing.T) {
	port1 := helpers.GetFreePort(t)

	sdPrefix := fmt.Sprintf("%s/", uuid.New().String())
	defer helpers.StartServer(t, true, true, "connector", port1, sdPrefix, *grpc, false)()
	c1 := client.New(logrus.InfoLevel)
	c2 := client.New(logrus.InfoLevel)

	err := c1.ConnectTo(fmt.Sprintf("localhost:%d", port1))
	assert.NoError(t, err)
	defer c1.Disconnect()

	err = c2.ConnectTo(fmt.Sprintf("localhost:%d", port1))
	assert.NoError(t, err)
	defer c2.Disconnect()

	uid1 := uuid.New().String()
	_, err = c1.SendRequest("connector.testsvc.testbindid", []byte(uid1))
	assert.NoError(t, err)
	helpers.ShouldEventuallyReceive(t, c1.IncomingMsgChan)

	_, err = c2.SendRequest("connector.testsvc.testbindid", []byte(uid1))
	assert.NoError(t, err)

	helpers.ShouldEventuallyReceive(t, c2.IncomingMsgChan)

	helpers.ShouldEventuallyReturn(t, func() bool {
		return c1.Connected
	}, false, 10*time.Millisecond, 1*time.Second)
}

func TestSameUIDUserShouldBeKickedInDifferentServersFromSameType(t *testing.T) {
	port1 := helpers.GetFreePort(t)
	port2 := helpers.GetFreePort(t)

	sdPrefix := fmt.Sprintf("%s/", uuid.New().String())
	defer helpers.StartServer(t, true, true, "connector", port1, sdPrefix, *grpc, false)()
	defer helpers.StartServer(t, true, true, "connector", port2, sdPrefix, *grpc, false)()
	c1 := client.New(logrus.InfoLevel)
	c2 := client.New(logrus.InfoLevel)

	err := c1.ConnectTo(fmt.Sprintf("localhost:%d", port1))
	assert.NoError(t, err)
	defer c1.Disconnect()

	err = c2.ConnectTo(fmt.Sprintf("localhost:%d", port2))
	assert.NoError(t, err)
	defer c2.Disconnect()

	uid1 := uuid.New().String()
	go func() {
		time.Sleep(10 * time.Millisecond)
		_, err = c1.SendRequest("connector.testsvc.testbindid", []byte(uid1))
		assert.NoError(t, err)
	}()
	helpers.ShouldEventuallyReceive(t, c1.IncomingMsgChan, 1*time.Second)

	go func() {
		time.Sleep(10 * time.Millisecond)
		_, err = c2.SendRequest("connector.testsvc.testbindid", []byte(uid1))
		assert.NoError(t, err)
	}()
	helpers.ShouldEventuallyReceive(t, c2.IncomingMsgChan, 2*time.Second)

	helpers.ShouldEventuallyReturn(t, func() bool {
		return c1.Connected
	}, false, 10*time.Millisecond, 1*time.Second)
}

func TestSameUIDUserShouldNotBeKickedInDifferentServersFromDiffType(t *testing.T) {
	port1 := helpers.GetFreePort(t)
	port2 := helpers.GetFreePort(t)

	sdPrefix := fmt.Sprintf("%s/", uuid.New().String())
	defer helpers.StartServer(t, true, true, "connector1", port1, sdPrefix, *grpc, false)()
	defer helpers.StartServer(t, true, true, "connector2", port2, sdPrefix, *grpc, false)()
	c1 := client.New(logrus.InfoLevel)
	c2 := client.New(logrus.InfoLevel)

	err := c1.ConnectTo(fmt.Sprintf("localhost:%d", port1))
	assert.NoError(t, err)
	defer c1.Disconnect()

	err = c2.ConnectTo(fmt.Sprintf("localhost:%d", port2))
	assert.NoError(t, err)
	defer c2.Disconnect()

	uid1 := uuid.New().String()
	go func() {
		time.Sleep(10 * time.Millisecond)
		_, err = c1.SendRequest("connector.testsvc.testbindid", []byte(uid1))
		assert.NoError(t, err)
	}()
	helpers.ShouldEventuallyReceive(t, c1.IncomingMsgChan)

	go func() {
		time.Sleep(10 * time.Millisecond)
		_, err = c2.SendRequest("connector.testsvc.testbindid", []byte(uid1))
		assert.NoError(t, err)
	}()

	helpers.ShouldEventuallyReceive(t, c2.IncomingMsgChan)

	helpers.ShouldAlwaysReturn(t, func() bool {
		return c1.Connected
	}, true, 10*time.Millisecond, 1*time.Second)
}

func TestKickOnBack(t *testing.T) {
	port1 := helpers.GetFreePort(t)

	sdPrefix := fmt.Sprintf("%s/", uuid.New().String())
	defer helpers.StartServer(t, true, true, "connector", port1, sdPrefix, *grpc, false)()
	defer helpers.StartServer(t, false, true, "game", 0, sdPrefix, *grpc, false)()
	c1 := client.New(logrus.DebugLevel)

	err := c1.ConnectTo(fmt.Sprintf("localhost:%d", port1))
	assert.NoError(t, err)
	defer c1.Disconnect()
	go func() {
		time.Sleep(10 * time.Millisecond)
		_, err = c1.SendRequest("game.testsvc.testbind", nil)
		assert.NoError(t, err)
	}()
	msg1 := helpers.ShouldEventuallyReceive(t, c1.IncomingMsgChan).(*message.Message)
	assert.Equal(t, []byte("ack"), msg1.Data)
	go func() {
		time.Sleep(10 * time.Millisecond)
		_, err = c1.SendRequest("game.testsvc.testrequestkickme", nil)
		assert.NoError(t, err)
	}()
	helpers.ShouldEventuallyReturn(t, func() bool {
		return c1.Connected
	}, false, 100*time.Millisecond, 1*time.Second)
}

func TestPushToUsers(t *testing.T) {
	port1 := helpers.GetFreePort(t)

	sdPrefix := fmt.Sprintf("%s/", uuid.New().String())
	defer helpers.StartServer(t, false, true, "game", 0, sdPrefix, *grpc, false)()
	defer helpers.StartServer(t, true, true, "connector", port1, sdPrefix, *grpc, false)()
	port2 := helpers.GetFreePort(t)
	defer helpers.StartServer(t, true, true, "connector", port2, sdPrefix, *grpc, false)()
	c1 := client.New(logrus.DebugLevel)
	c2 := client.New(logrus.DebugLevel)

	err := c1.ConnectTo(fmt.Sprintf("localhost:%d", port1))
	assert.NoError(t, err)
	defer c1.Disconnect()

	err = c2.ConnectTo(fmt.Sprintf("localhost:%d", port2))
	assert.NoError(t, err)
	defer c2.Disconnect()

	uid1 := uuid.New().String()
	uid2 := uuid.New().String()
	go func(uid1 string, uid2 string) {
		time.Sleep(10 * time.Millisecond)
		_, err = c1.SendRequest("connector.testsvc.testbindid", []byte(uid1))
		assert.NoError(t, err)
		_, err = c2.SendRequest("connector.testsvc.testbindid", []byte(uid2))
		assert.NoError(t, err)
	}(uid1, uid2)
	msg1 := helpers.ShouldEventuallyReceive(t, c1.IncomingMsgChan, 1*time.Second).(*message.Message)
	msg2 := helpers.ShouldEventuallyReceive(t, c2.IncomingMsgChan, 1*time.Second).(*message.Message)

	assert.Equal(t, []byte("ack"), msg1.Data)
	assert.Equal(t, []byte("ack"), msg2.Data)

	msg := fmt.Sprintf(`{"msg":"testing send to users","uids":["%s","%s"]}`, uid1, uid2)

	tables := []struct {
		name  string
		route string
	}{
		{"test1", "connector.testsvc.testsendtousers"},
		{"test2", "game.testsvc.testsendtousers"},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			go func() {
				time.Sleep(10 * time.Millisecond)
				c1.SendNotify(table.route, []byte(msg))
			}()
			msg1 = helpers.ShouldEventuallyReceive(t, c1.IncomingMsgChan).(*message.Message)
			msg2 = helpers.ShouldEventuallyReceive(t, c2.IncomingMsgChan).(*message.Message)

			assert.Equal(t, message.Push, msg1.Type)
			assert.Equal(t, message.Push, msg2.Type)

			assert.Equal(t, "testing send to users", string(msg1.Data))
			assert.Equal(t, "testing send to users", string(msg2.Data))
		})
	}
}

func TestForwardToBackend(t *testing.T) {
	portFront := helpers.GetFreePort(t)
	sdPrefix := fmt.Sprintf("%s/", uuid.New().String())
	defer helpers.StartServer(t, false, true, "game", 0, sdPrefix, *grpc, false)()
	defer helpers.StartServer(t, true, true, "connector", portFront, sdPrefix, *grpc, true)()

	tables := []struct {
		req  string
		data []byte
		resp []byte
	}{
		{"game.testsvc.testrequestonlysessionreturnsptr", []byte(``), []byte(`{"code":200,"msg":"hello"}`)},
		{"game.testsvc.testrequestreturnsptr", []byte(`{"msg":"good"}`), []byte(`{"code":200,"msg":"good"}`)},
		{"game.testsvc.testrequestreturnsraw", []byte(`{"msg":"good"}`), []byte(`good`)},
		{"game.testsvc.testrequestreceivereturnsraw", []byte(`woow`), []byte(`woow`)},
		{"game.testsvc.nonexistenthandler", []byte(`woow`), []byte(`{"code":"PIT-404","msg":"pitaya/handler: game.testsvc.nonexistenthandler not found"}`)},
		{"game.testsvc.testrequestreturnserror", []byte(`woow`), []byte(`{"code":"PIT-555","msg":"somerror"}`)},
	}

	c := client.New(logrus.InfoLevel)

	err := c.ConnectTo(fmt.Sprintf("localhost:%d", portFront))
	assert.NoError(t, err)
	defer c.Disconnect()

	for _, table := range tables {
		t.Run(table.req, func(t *testing.T) {
			go func() {
				time.Sleep(10 * time.Millisecond)
				_, err = c.SendRequest(table.req, table.data)
				assert.NoError(t, err)
			}()
			msg := helpers.ShouldEventuallyReceive(t, c.IncomingMsgChan).(*message.Message)
			assert.Equal(t, message.Response, msg.Type)
			assert.Equal(t, table.resp, msg.Data)
		})
	}
}

func TestGroupBack(t *testing.T) {
	port1 := helpers.GetFreePort(t)
	port2 := helpers.GetFreePort(t)
	sdPrefix := fmt.Sprintf("%s/", uuid.New().String())

	defer helpers.StartServer(t, false, true, "game", 0, sdPrefix, *grpc, false)()
	defer helpers.StartServer(t, true, true, "connector", port1, sdPrefix, *grpc, false)()
	defer helpers.StartServer(t, true, true, "connector", port2, sdPrefix, *grpc, false)()
	c1 := client.New(logrus.InfoLevel)
	c2 := client.New(logrus.InfoLevel)

	err := c1.ConnectTo(fmt.Sprintf("localhost:%d", port1))
	assert.NoError(t, err)
	defer c1.Disconnect()

	err = c2.ConnectTo(fmt.Sprintf("localhost:%d", port2))
	assert.NoError(t, err)
	defer c2.Disconnect()

	go func() {
		time.Sleep(10 * time.Millisecond)
		_, err = c1.SendRequest("game.testsvc.testbind", []byte{})
		assert.NoError(t, err)
		_, err = c2.SendRequest("game.testsvc.testbind", []byte{})
		assert.NoError(t, err)
	}()

	msg1 := helpers.ShouldEventuallyReceive(t, c1.IncomingMsgChan).(*message.Message)
	msg2 := helpers.ShouldEventuallyReceive(t, c2.IncomingMsgChan).(*message.Message)

	assert.Equal(t, []byte("ack"), msg1.Data)
	assert.Equal(t, []byte("ack"), msg2.Data)

	tables := []struct {
		route string
		data  []byte
	}{
		{"game.testsvc.testsendgroupmsg", []byte("testing group")},
		{"game.testsvc.testsendgroupmsgptr", []byte(`{"msg":"hellow"}`)},
	}

	for _, table := range tables {
		go func() {
			time.Sleep(10 * time.Millisecond)
			c1.SendNotify(table.route, table.data)
		}()
		msg1 = helpers.ShouldEventuallyReceive(t, c1.IncomingMsgChan).(*message.Message)
		msg2 = helpers.ShouldEventuallyReceive(t, c2.IncomingMsgChan).(*message.Message)

		assert.Equal(t, message.Push, msg1.Type)
		assert.Equal(t, message.Push, msg2.Type)

		assert.Equal(t, table.data, msg1.Data)
		assert.Equal(t, table.data, msg2.Data)
	}
}

func TestUserRPC(t *testing.T) {
	port1 := helpers.GetFreePort(t)

	sdPrefix := fmt.Sprintf("%s/", uuid.New().String())
	// set lazy connections
	defer helpers.StartServer(t, false, true, "game", 0, sdPrefix, *grpc, true)()
	defer helpers.StartServer(t, true, true, "connector", port1, sdPrefix, *grpc, false)()
	c1 := client.New(logrus.InfoLevel)

	err := c1.ConnectTo(fmt.Sprintf("localhost:%d", port1))
	assert.NoError(t, err)
	defer c1.Disconnect()

	tables := []struct {
		name  string
		route string
		data  []byte
		res   []byte
	}{
		{"front_to_back", "connector.testsvc.testsendrpc", []byte(`{"route":"game.testremotesvc.rpctestrawptrreturnsptr","data":"thisthis"}`), []byte(`{"code":200,"msg":"got thisthis"}`)},
		{"back_to_front", "game.testsvc.testsendrpc", []byte(`{"route":"connector.testremotesvc.rpctestrawptrreturnsptr","data":"thisthis"}`), []byte(`{"code":200,"msg":"got thisthis"}`)},
		{"front_to_back_error", "connector.testsvc.testsendrpc", []byte(`{"route":"game.testremotesvc.rpctestreturnserror","data":"thisthis"}`), []byte(`{"code":"PIT-433","msg":"test error","metadata":{"some":"meta"}}`)},
		{"back_to_front_error", "game.testsvc.testsendrpc", []byte(`{"route":"connector.testremotesvc.rpctestreturnserror","data":"thisthis"}`), []byte(`{"code":"PIT-433","msg":"test error","metadata":{"some":"meta"}}`)},
		{"same_server", "connector.testsvc.testsendrpc", []byte(`{"route":"connector.testremotesvc.rpctestrawptrreturnsptr","data":"thisthis"}`), []byte(`{"code":"PIT-000","msg":"you are making a rpc that may be processed locally, either specify a different server type or specify a server id"}`)},
		{"front_to_back_ptr", "connector.testsvc.testsendrpc", []byte(`{"route":"game.testremotesvc.rpctestptrreturnsptr","data":"thisthis"}`), []byte(`{"code":200,"msg":"got thisthis"}`)},
		{"no_args", "connector.testsvc.testsendrpcnoargs", []byte(`{"route":"game.testremotesvc.rpctestnoargs"}`), []byte(`{"code":200,"msg":"got nothing"}`)},
		{"not_found", "connector.testsvc.testsendrpc", []byte(`{"route":"game.testremotesvc.rpctestnotfound","data":"thisthis"}`), []byte(`{"code":"PIT-404","msg":"route not found","metadata":{"route":"testremotesvc.rpctestnotfound"}}`)},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			go func() {
				time.Sleep(10 * time.Millisecond)
				_, err := c1.SendRequest(table.route, table.data)
				assert.NoError(t, err)
			}()
			msg := helpers.ShouldEventuallyReceive(t, c1.IncomingMsgChan).(*message.Message)
			assert.Equal(t, table.res, msg.Data)
		})
	}
}

```

`examples/demo/chat/README.md`:

```md
# pitaya-chat-demo
chat room demo base on [pitaya](https://github.com/topfreegames/pitaya) in 100 lines

refs: https://github.com/topfreegames/pitaya

## Required
- golang
- websocket

## Run
```
docker compose -f ../../testing/docker-compose.yml up -d etcd nats
go run main.go
```

open browser => http://localhost:3251/web/

```

`examples/demo/chat/main.go`:

```go
package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"time"

	"strings"

	"github.com/topfreegames/pitaya/v3/pkg"
	"github.com/topfreegames/pitaya/v3/pkg/acceptor"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/groups"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/timer"
)

type (
	// Room represents a component that contains a bundle of room related handler
	// like Join/Message
	Room struct {
		component.Base
		timer *timer.Timer
		app   pitaya.Pitaya
	}

	// UserMessage represents a message that user sent
	UserMessage struct {
		Name    string `json:"name"`
		Content string `json:"content"`
	}

	// NewUser message will be received when new user join room
	NewUser struct {
		Content string `json:"content"`
	}

	// AllMembers contains all members uid
	AllMembers struct {
		Members []string `json:"members"`
	}

	// JoinResponse represents the result of joining room
	JoinResponse struct {
		Code   int    `json:"code"`
		Result string `json:"result"`
	}
)

// NewRoom returns a Handler Base implementation
func NewRoom(app pitaya.Pitaya) *Room {
	return &Room{
		app: app,
	}
}

// AfterInit component lifetime callback
func (r *Room) AfterInit() {
	r.timer = pitaya.NewTimer(time.Minute, func() {
		count, err := r.app.GroupCountMembers(context.Background(), "room")
		logger.Log.Debugf("UserCount: Time=> %s, Count=> %d, Error=> %v", time.Now().String(), count, err)
	})
}

// Join room
func (r *Room) Join(ctx context.Context, msg []byte) (*JoinResponse, error) {
	s := r.app.GetSessionFromCtx(ctx)
	fakeUID := s.ID()                              // just use s.ID as uid !!!
	err := s.Bind(ctx, strconv.Itoa(int(fakeUID))) // binding session uid

	if err != nil {
		return nil, pitaya.Error(err, "RH-000", map[string]string{"failed": "bind"})
	}

	uids, err := r.app.GroupMembers(ctx, "room")
	if err != nil {
		return nil, err
	}
	s.Push("onMembers", &AllMembers{Members: uids})
	// notify others
	r.app.GroupBroadcast(ctx, "chat", "room", "onNewUser", &NewUser{Content: fmt.Sprintf("New user: %s", s.UID())})
	// new user join group
	r.app.GroupAddMember(ctx, "room", s.UID()) // add session to group

	// on session close, remove it from group
	s.OnClose(func() {
		r.app.GroupRemoveMember(ctx, "room", s.UID())
	})

	return &JoinResponse{Result: "success"}, nil
}

// Message sync last message to all members
func (r *Room) Message(ctx context.Context, msg *UserMessage) {
	err := r.app.GroupBroadcast(ctx, "chat", "room", "onMessage", msg)
	if err != nil {
		fmt.Println("error broadcasting message", err)
	}
}

var app pitaya.Pitaya

func main() {
	conf := configApp()
	builder := pitaya.NewDefaultBuilder(true, "chat", pitaya.Cluster, map[string]string{}, *conf)
	builder.AddAcceptor(acceptor.NewWSAcceptor(":3250"))
	builder.Groups = groups.NewMemoryGroupService(builder.Config.Groups.Memory)
	app = builder.Build()

	defer app.Shutdown()

	err := app.GroupCreate(context.Background(), "room")
	if err != nil {
		panic(err)
	}

	// rewrite component and handler name
	room := NewRoom(app)
	app.Register(room,
		component.WithName("room"),
		component.WithNameFunc(strings.ToLower),
	)

	log.SetFlags(log.LstdFlags | log.Llongfile)

	http.Handle("/web/", http.StripPrefix("/web/", http.FileServer(http.Dir("web"))))

	go http.ListenAndServe(":3251", nil)

	app.Start()
}

func configApp() *config.PitayaConfig {
	conf := config.NewDefaultPitayaConfig()
	conf.Buffer.Handler.LocalProcess = 15
	conf.Heartbeat.Interval = time.Duration(15 * time.Second)
	conf.Buffer.Agent.Messages = 32
	conf.Handler.Messages.Compression = false
	return conf
}

```

`examples/demo/chat/web/index.html`:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Chat Demo</title>
</head>
<body>
<div id="container">
    <ul>
        <li v-for="msg in messages">[<span style="color:red;">{{msg.name}}</span>]{{msg.content}}</li>
    </ul>
    <div class="controls">
        <input type="text" v-model="nickname">
        <input type="text" v-model="inputMessage">
        <input type="button" v-on:click="sendMessage" value="Send">
    </div>
</div>
<script src="http://cdnjs.cloudflare.com/ajax/libs/vue/1.0.26/vue.min.js" type="text/javascript"></script>
<!--[starx websocket library](https://github.com/topfreegames/pitaya-client-websocket)-->
<script src="protocol.js" type="text/javascript"></script>
<script src="starx-wsclient.js" type="text/javascript"></script>
<script>
    var v = new Vue({
        el: "#container",
        data: {
            nickname:'guest' + Date.now(),
            inputMessage:'',
            messages: []
        },
        methods: {
            sendMessage: function () {
                console.log(this.inputMessage);
                starx.notify('room.message', {name: this.nickname, content: this.inputMessage});
                this.inputMessage = '';
            }
        }
    });

    var onMessage = function (msg) {
        v.messages.push(msg)
    };

    var join = function (data) {
        console.log(data);
        if(data.code === 0) {
            v.messages.push({name:'system', content:data.result});
            starx.on('onMessage', onMessage)
        }
    };

    var onNewUser = function (data) {
        console.log(data);
        v.messages.push({name:'system', content:data.content});
    };

    var onMembers = function (data) {
        console.log(data);
        v.messages.push({name:'system', content: "members: "+data.members});
    };

    starx.init({host: '127.0.0.1', port: 3250, path: '/'}, function () {
        console.log("initialized");
        starx.on("onNewUser", onNewUser);
        starx.on("onMembers", onMembers);
        starx.request("room.join", {}, join);
    })
</script>
</body>
</html>

```

`examples/demo/chat/web/protocol.js`:

```js
(function (exports, ByteArray, global) {
  var Protocol = exports;

  var PKG_HEAD_BYTES = 4;
  var MSG_FLAG_BYTES = 1;
  var MSG_ROUTE_CODE_BYTES = 2;
  var MSG_ID_MAX_BYTES = 5;
  var MSG_ROUTE_LEN_BYTES = 1;

  var MSG_ROUTE_CODE_MAX = 0xffff;

  var MSG_COMPRESS_ROUTE_MASK = 0x1;
  var MSG_TYPE_MASK = 0x7;

  var Package = Protocol.Package = {};
  var Message = Protocol.Message = {};

  Package.TYPE_HANDSHAKE = 1;
  Package.TYPE_HANDSHAKE_ACK = 2;
  Package.TYPE_HEARTBEAT = 3;
  Package.TYPE_DATA = 4;
  Package.TYPE_KICK = 5;

  Message.TYPE_REQUEST = 0;
  Message.TYPE_NOTIFY = 1;
  Message.TYPE_RESPONSE = 2;
  Message.TYPE_PUSH = 3;

  /**
   * pomele client encode
   * id message id;
   * route message route
   * msg message body
   * socketio current support string
   */
  Protocol.strencode = function(str) {
    var byteArray = new ByteArray(str.length * 3);
    var offset = 0;
    for(var i = 0; i < str.length; i++){
      var charCode = str.charCodeAt(i);
      var codes = null;
      if(charCode <= 0x7f){
        codes = [charCode];
      }else if(charCode <= 0x7ff){
        codes = [0xc0|(charCode>>6), 0x80|(charCode & 0x3f)];
      }else{
        codes = [0xe0|(charCode>>12), 0x80|((charCode & 0xfc0)>>6), 0x80|(charCode & 0x3f)];
      }
      for(var j = 0; j < codes.length; j++){
        byteArray[offset] = codes[j];
        ++offset;
      }
    }
    var _buffer = new ByteArray(offset);
    copyArray(_buffer, 0, byteArray, 0, offset);
    return _buffer;
  };

  /**
   * client decode
   * msg String data
   * return Message Object
   */
  Protocol.strdecode = function(buffer) {
    var bytes = new ByteArray(buffer);
    var array = [];
    var offset = 0;
    var charCode = 0;
    var end = bytes.length;
    while(offset < end){
      if(bytes[offset] < 128){
        charCode = bytes[offset];
        offset += 1;
      }else if(bytes[offset] < 224){
        charCode = ((bytes[offset] & 0x3f)<<6) + (bytes[offset+1] & 0x3f);
        offset += 2;
      }else{
        charCode = ((bytes[offset] & 0x0f)<<12) + ((bytes[offset+1] & 0x3f)<<6) + (bytes[offset+2] & 0x3f);
        offset += 3;
      }
      array.push(charCode);
    }
    return String.fromCharCode.apply(null, array);
  };

  /**
   * Package protocol encode.
   *
   * Pomelo package format:
   * +------+-------------+------------------+
   * | type | body length |       body       |
   * +------+-------------+------------------+
   *
   * Head: 4bytes
   *   0: package type,
   *      1 - handshake,
   *      2 - handshake ack,
   *      3 - heartbeat,
   *      4 - data
   *      5 - kick
   *   1 - 3: big-endian body length
   * Body: body length bytes
   *
   * @param  {Number}    type   package type
   * @param  {ByteArray} body   body content in bytes
   * @return {ByteArray}        new byte array that contains encode result
   */
  Package.encode = function(type, body){
    var length = body ? body.length : 0;
    var buffer = new ByteArray(PKG_HEAD_BYTES + length);
    var index = 0;
    buffer[index++] = type & 0xff;
    buffer[index++] = (length >> 16) & 0xff;
    buffer[index++] = (length >> 8) & 0xff;
    buffer[index++] = length & 0xff;
    if(body) {
      copyArray(buffer, index, body, 0, length);
    }
    return buffer;
  };

  /**
   * Package protocol decode.
   * See encode for package format.
   *
   * @param  {ByteArray} buffer byte array containing package content
   * @return {Object}           {type: package type, buffer: body byte array}
   */
  Package.decode = function(buffer){
    var offset = 0;
    var bytes = new ByteArray(buffer);
    var length = 0;
    var rs = [];
    while(offset < bytes.length) {
      var type = bytes[offset++];
      length = ((bytes[offset++]) << 16 | (bytes[offset++]) << 8 | bytes[offset++]) >>> 0;
      var body = length ? new ByteArray(length) : null;
      copyArray(body, 0, bytes, offset, length);
      offset += length;
      rs.push({'type': type, 'body': body});
    }
    return rs.length === 1 ? rs[0]: rs;
  };

  /**
   * Message protocol encode.
   *
   * @param  {Number} id            message id
   * @param  {Number} type          message type
   * @param  {Number} compressRoute whether compress route
   * @param  {Number|String} route  route code or route string
   * @param  {Buffer} msg           message body bytes
   * @return {Buffer}               encode result
   */
  Message.encode = function(id, type, compressRoute, route, msg){
    // caculate message max length
    var idBytes = msgHasId(type) ? caculateMsgIdBytes(id) : 0;
    var msgLen = MSG_FLAG_BYTES + idBytes;

    if(msgHasRoute(type)) {
      if(compressRoute) {
        if(typeof route !== 'number'){
          throw new Error('error flag for number route!');
        }
        msgLen += MSG_ROUTE_CODE_BYTES;
      } else {
        msgLen += MSG_ROUTE_LEN_BYTES;
        if(route) {
          route = Protocol.strencode(route);
          if(route.length>255) {
            throw new Error('route maxlength is overflow');
          }
          msgLen += route.length;
        }
      }
    }

    if(msg) {
      msgLen += msg.length;
    }

    var buffer = new ByteArray(msgLen);
    var offset = 0;

    // add flag
    offset = encodeMsgFlag(type, compressRoute, buffer, offset);

    // add message id
    if(msgHasId(type)) {
      offset = encodeMsgId(id, buffer, offset);
    }

    // add route
    if(msgHasRoute(type)) {
      offset = encodeMsgRoute(compressRoute, route, buffer, offset);
    }

    // add body
    if(msg) {
      offset = encodeMsgBody(msg, buffer, offset);
    }

    return buffer;
  };

  /**
   * Message protocol decode.
   *
   * @param  {Buffer|Uint8Array} buffer message bytes
   * @return {Object}            message object
   */
  Message.decode = function(buffer) {
    var bytes =  new ByteArray(buffer);
    var bytesLen = bytes.length || bytes.byteLength;
    var offset = 0;
    var id = 0;
    var route = null;

    // parse flag
    var flag = bytes[offset++];
    var compressRoute = flag & MSG_COMPRESS_ROUTE_MASK;
    var type = (flag >> 1) & MSG_TYPE_MASK;

    // parse id
    if(msgHasId(type)) {
      var m = parseInt(bytes[offset]);
      var i = 0;
      do{
        var m = parseInt(bytes[offset]);
        id = id + ((m & 0x7f) * Math.pow(2,(7*i)));
        offset++;
        i++;
      }while(m >= 128);
    }

    // parse route
    if(msgHasRoute(type)) {
      if(compressRoute) {
        route = (bytes[offset++]) << 8 | bytes[offset++];
      } else {
        var routeLen = bytes[offset++];
        if(routeLen) {
          route = new ByteArray(routeLen);
          copyArray(route, 0, bytes, offset, routeLen);
          route = Protocol.strdecode(route);
        } else {
          route = '';
        }
        offset += routeLen;
      }
    }

    // parse body
    var bodyLen = bytesLen - offset;
    var body = new ByteArray(bodyLen);

    copyArray(body, 0, bytes, offset, bodyLen);

    return {'id': id, 'type': type, 'compressRoute': compressRoute,
            'route': route, 'body': body};
  };

  var copyArray = function(dest, doffset, src, soffset, length) {
    if('function' === typeof src.copy) {
      // Buffer
      src.copy(dest, doffset, soffset, soffset + length);
    } else {
      // Uint8Array
      for(var index=0; index<length; index++){
        dest[doffset++] = src[soffset++];
      }
    }
  };

  var msgHasId = function(type) {
    return type === Message.TYPE_REQUEST || type === Message.TYPE_RESPONSE;
  };

  var msgHasRoute = function(type) {
    return type === Message.TYPE_REQUEST || type === Message.TYPE_NOTIFY ||
           type === Message.TYPE_PUSH;
  };

  var caculateMsgIdBytes = function(id) {
    var len = 0;
    do {
      len += 1;
      id >>= 7;
    } while(id > 0);
    return len;
  };

  var encodeMsgFlag = function(type, compressRoute, buffer, offset) {
    if(type !== Message.TYPE_REQUEST && type !== Message.TYPE_NOTIFY &&
       type !== Message.TYPE_RESPONSE && type !== Message.TYPE_PUSH) {
      throw new Error('unkonw message type: ' + type);
    }

    buffer[offset] = (type << 1) | (compressRoute ? 1 : 0);

    return offset + MSG_FLAG_BYTES;
  };

  var encodeMsgId = function(id, buffer, offset) {
    do{
      var tmp = id % 128;
      var next = Math.floor(id/128);

      if(next !== 0){
        tmp = tmp + 128;
      }
      buffer[offset++] = tmp;

      id = next;
    } while(id !== 0);

    return offset;
  };

  var encodeMsgRoute = function(compressRoute, route, buffer, offset) {
    if (compressRoute) {
      if(route > MSG_ROUTE_CODE_MAX){
        throw new Error('route number is overflow');
      }

      buffer[offset++] = (route >> 8) & 0xff;
      buffer[offset++] = route & 0xff;
    } else {
      if(route) {
        buffer[offset++] = route.length & 0xff;
        copyArray(buffer, offset, route, 0, route.length);
        offset += route.length;
      } else {
        buffer[offset++] = 0;
      }
    }

    return offset;
  };

  var encodeMsgBody = function(msg, buffer, offset) {
    copyArray(buffer, offset, msg, 0, msg.length);
    return offset + msg.length;
  };

  if(typeof(window) != "undefined") {
    window.Protocol = Protocol;
  }
})(typeof(window)=="undefined" ? module.exports : (this.Protocol = {}),typeof(window)=="undefined"  ? Buffer : Uint8Array, this);

```

`examples/demo/chat/web/starx-wsclient.js`:

```js
(function() {
  function Emitter(obj) {
    if (obj) return mixin(obj);
  }
    /**
   * Mixin the emitter properties.
   *
   * @param {Object} obj
   * @return {Object}
   * @api private
   */

  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }
    return obj;
  }

  /**
   * Listen on the given `event` with `fn`.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.on =
  Emitter.prototype.addEventListener = function(event, fn){
    this._callbacks = this._callbacks || {};
    (this._callbacks[event] = this._callbacks[event] || [])
      .push(fn);
    return this;
  };

  /**
   * Adds an `event` listener that will be invoked a single
   * time then automatically removed.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.once = function(event, fn){
    var self = this;
    this._callbacks = this._callbacks || {};

    function on() {
      self.off(event, on);
      fn.apply(this, arguments);
    }

    on.fn = fn;
    this.on(event, on);
    return this;
  };

  /**
   * Remove the given callback for `event` or all
   * registered callbacks.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.off =
  Emitter.prototype.removeListener =
  Emitter.prototype.removeAllListeners =
  Emitter.prototype.removeEventListener = function(event, fn){
    this._callbacks = this._callbacks || {};

    // all
    if (0 == arguments.length) {
      this._callbacks = {};
      return this;
    }

    // specific event
    var callbacks = this._callbacks[event];
    if (!callbacks) return this;

    // remove all handlers
    if (1 == arguments.length) {
      delete this._callbacks[event];
      return this;
    }

    // remove specific handler
    var cb;
    for (var i = 0; i < callbacks.length; i++) {
      cb = callbacks[i];
      if (cb === fn || cb.fn === fn) {
        callbacks.splice(i, 1);
        break;
      }
    }
    return this;
  };

  /**
   * Emit `event` with the given args.
   *
   * @param {String} event
   * @param {Mixed} ...
   * @return {Emitter}
   */

  Emitter.prototype.emit = function(event){
    this._callbacks = this._callbacks || {};
    var args = [].slice.call(arguments, 1)
      , callbacks = this._callbacks[event];

    if (callbacks) {
      callbacks = callbacks.slice(0);
      for (var i = 0, len = callbacks.length; i < len; ++i) {
        callbacks[i].apply(this, args);
      }
    }

    return this;
  };

  /**
   * Return array of callbacks for `event`.
   *
   * @param {String} event
   * @return {Array}
   * @api public
   */

  Emitter.prototype.listeners = function(event){
    this._callbacks = this._callbacks || {};
    return this._callbacks[event] || [];
  };

  /**
   * Check if this emitter has `event` handlers.
   *
   * @param {String} event
   * @return {Boolean}
   * @api public
   */

  Emitter.prototype.hasListeners = function(event){
    return !! this.listeners(event).length;
  };
  var JS_WS_CLIENT_TYPE = 'js-websocket';
  var JS_WS_CLIENT_VERSION = '0.0.1';

  var Protocol = window.Protocol;
  var decodeIO_encoder = null;
  var decodeIO_decoder = null;
  var Package = Protocol.Package;
  var Message = Protocol.Message;
  var EventEmitter = Emitter;
  var rsa = window.rsa;

  if(typeof(window) != "undefined" && typeof(sys) != 'undefined' && sys.localStorage) {
    window.localStorage = sys.localStorage;
  }

  var RES_OK = 200;
  var RES_FAIL = 500;
  var RES_OLD_CLIENT = 501;

  if (typeof Object.create !== 'function') {
    Object.create = function (o) {
      function F() {}
      F.prototype = o;
      return new F();
    };
  }

  var root = window;
  var starx = Object.create(EventEmitter.prototype); // object extend from object
  root.starx = starx;
  var socket = null;
  var reqId = 0;
  var callbacks = {};
  var handlers = {};
  //Map from request id to route
  var routeMap = {};
  var dict = {};    // route string to code
  var abbrs = {};   // code to route string

  var heartbeatInterval = 0;
  var heartbeatTimeout = 0;
  var nextHeartbeatTimeout = 0;
  var gapThreshold = 100;   // heartbeat gap threashold
  var heartbeatId = null;
  var heartbeatTimeoutId = null;
  var handshakeCallback = null;

  var decode = null;
  var encode = null;

  var reconnect = false;
  var reconncetTimer = null;
  var reconnectUrl = null;
  var reconnectAttempts = 0;
  var reconnectionDelay = 5000;
  var DEFAULT_MAX_RECONNECT_ATTEMPTS = 10;

  var useCrypto;

  var handshakeBuffer = {
    'sys': {
      type: JS_WS_CLIENT_TYPE,
      version: JS_WS_CLIENT_VERSION,
      rsa: {}
    },
    'user': {
    }
  };

  var initCallback = null;

  starx.init = function(params, cb) {
    initCallback = cb;
    var host = params.host;
    var port = params.port;
    var path = params.path;

    encode = params.encode || defaultEncode;
    decode = params.decode || defaultDecode;

    var url = 'ws://' + host;
    if(port) {
      url +=  ':' + port;
    }

    if(path) {
      url += path;
    }

    handshakeBuffer.user = params.user;
    if(params.encrypt) {
      useCrypto = true;
      rsa.generate(1024, "10001");
      var data = {
        rsa_n: rsa.n.toString(16),
        rsa_e: rsa.e
      };
      handshakeBuffer.sys.rsa = data;
    }
    handshakeCallback = params.handshakeCallback;
    connect(params, url, cb);
  };

  var defaultDecode = starx.decode = function(data) {
    var msg = Message.decode(data);

    if(msg.id > 0){
      msg.route = routeMap[msg.id];
      delete routeMap[msg.id];
      if(!msg.route){
        return;
      }
    }

    msg.body = deCompose(msg);
    return msg;
  };

  var defaultEncode = starx.encode = function(reqId, route, msg) {
    var type = reqId ? Message.TYPE_REQUEST : Message.TYPE_NOTIFY;

    if(decodeIO_encoder && decodeIO_encoder.lookup(route)) {
      var Builder = decodeIO_encoder.build(route);
      msg = new Builder(msg).encodeNB();
    } else {
      msg = Protocol.strencode(JSON.stringify(msg));
    }

    var compressRoute = 0;
    if(dict && dict[route]) {
      route = dict[route];
      compressRoute = 1;
    }

    return Message.encode(reqId, type, compressRoute, route, msg);
  };

  var connect = function(params, url, cb) {
    console.log('connect to ' + url);

    var params = params || {};
    var maxReconnectAttempts = params.maxReconnectAttempts || DEFAULT_MAX_RECONNECT_ATTEMPTS;
    reconnectUrl = url;

    var onopen = function(event) {
      if(!!reconnect) {
        starx.emit('reconnect');
      }
      reset();
      var obj = Package.encode(Package.TYPE_HANDSHAKE, Protocol.strencode(JSON.stringify(handshakeBuffer)));
      send(obj);
    };
    var onmessage = function(event) {
      processPackage(Package.decode(event.data), cb);
      // new package arrived, update the heartbeat timeout
      if(heartbeatTimeout) {
        nextHeartbeatTimeout = Date.now() + heartbeatTimeout;
      }
    };
    var onerror = function(event) {
      starx.emit('io-error', event);
      console.error('socket error: ', event);
    };
    var onclose = function(event) {
      starx.emit('close',event);
      starx.emit('disconnect', event);
      console.log('socket close: ', event);
      if(!!params.reconnect && reconnectAttempts < maxReconnectAttempts) {
        reconnect = true;
        reconnectAttempts++;
        reconncetTimer = setTimeout(function() {
          connect(params, reconnectUrl, cb);
        }, reconnectionDelay);
        reconnectionDelay *= 2;
      }
    };
    socket = new WebSocket(url);
    socket.binaryType = 'arraybuffer';
    socket.onopen = onopen;
    socket.onmessage = onmessage;
    socket.onerror = onerror;
    socket.onclose = onclose;
  };

  starx.disconnect = function() {
    if(socket) {
      if(socket.disconnect) socket.disconnect();
      if(socket.close) socket.close();
      console.log('disconnect');
      socket = null;
    }

    if(heartbeatId) {
      clearTimeout(heartbeatId);
      heartbeatId = null;
    }
    if(heartbeatTimeoutId) {
      clearTimeout(heartbeatTimeoutId);
      heartbeatTimeoutId = null;
    }
  };

  var reset = function() {
    reconnect = false;
    reconnectionDelay = 1000 * 5;
    reconnectAttempts = 0;
    clearTimeout(reconncetTimer);
  };

  starx.request = function(route, msg, cb) {
    if(arguments.length === 2 && typeof msg === 'function') {
      cb = msg;
      msg = {};
    } else {
      msg = msg || {};
    }
    route = route || msg.route;
    if(!route) {
      return;
    }

    reqId++;
    sendMessage(reqId, route, msg);

    callbacks[reqId] = cb;
    routeMap[reqId] = route;
  };

  starx.notify = function(route, msg) {
    msg = msg || {};
    sendMessage(0, route, msg);
  };

  var sendMessage = function(reqId, route, msg) {
    if(useCrypto) {
      msg = JSON.stringify(msg);
      var sig = rsa.signString(msg, "sha256");
      msg = JSON.parse(msg);
      msg['__crypto__'] = sig;
    }

    if(encode) {
      msg = encode(reqId, route, msg);
    }

    var packet = Package.encode(Package.TYPE_DATA, msg);
    send(packet);
  };

  var send = function(packet) {
    socket.send(packet.buffer);
  };

  var handler = {};

  var heartbeat = function(data) {
    if(!heartbeatInterval) {
      // no heartbeat
      return;
    }

    var obj = Package.encode(Package.TYPE_HEARTBEAT);
    if(heartbeatTimeoutId) {
      clearTimeout(heartbeatTimeoutId);
      heartbeatTimeoutId = null;
    }

    if(heartbeatId) {
      // already in a heartbeat interval
      return;
    }
    heartbeatId = setTimeout(function() {
      heartbeatId = null;
      send(obj);

      nextHeartbeatTimeout = Date.now() + heartbeatTimeout;
      heartbeatTimeoutId = setTimeout(heartbeatTimeoutCb, heartbeatTimeout);
    }, heartbeatInterval);
  };

  var heartbeatTimeoutCb = function() {
    var gap = nextHeartbeatTimeout - Date.now();
    if(gap > gapThreshold) {
      heartbeatTimeoutId = setTimeout(heartbeatTimeoutCb, gap);
    } else {
      console.error('server heartbeat timeout');
      starx.emit('heartbeat timeout');
      starx.disconnect();
    }
  };

  var handshake = function(data) {
    data = JSON.parse(Protocol.strdecode(data));
    if(data.code === RES_OLD_CLIENT) {
      starx.emit('error', 'client version not fullfill');
      return;
    }

    if(data.code !== RES_OK) {
      starx.emit('error', 'handshake fail');
      return;
    }

    handshakeInit(data);

    var obj = Package.encode(Package.TYPE_HANDSHAKE_ACK);
    send(obj);
    if(initCallback) {
      initCallback(socket);
    }
  };

  var onData = function(data) {
    var msg = data;
    if(decode) {
      msg = decode(msg);
    }
    processMessage(starx, msg);
  };

  var onKick = function(data) {
    data = JSON.parse(Protocol.strdecode(data));
    starx.emit('onKick', data);
  };

  handlers[Package.TYPE_HANDSHAKE] = handshake;
  handlers[Package.TYPE_HEARTBEAT] = heartbeat;
  handlers[Package.TYPE_DATA] = onData;
  handlers[Package.TYPE_KICK] = onKick;

  var processPackage = function(msgs) {
    if(Array.isArray(msgs)) {
      for(var i=0; i<msgs.length; i++) {
        var msg = msgs[i];
        handlers[msg.type](msg.body);
      }
    } else {
      handlers[msgs.type](msgs.body);
    }
  };

  var processMessage = function(starx, msg) {
    if(!msg.id) {
      // server push message
      starx.emit(msg.route, msg.body);
      return;
    }

    //if have a id then find the callback function with the request
    var cb = callbacks[msg.id];

    delete callbacks[msg.id];
    if(typeof cb !== 'function') {
      return;
    }

    cb(msg.body);

  };

  var processMessageBatch = function(starx, msgs) {
    for(var i=0, l=msgs.length; i<l; i++) {
      processMessage(starx, msgs[i]);
    }
  };

  var deCompose = function(msg) {
    var route = msg.route;

    //Decompose route from dict
    if(msg.compressRoute) {
      if(!abbrs[route]){
        return {};
      }

      route = msg.route = abbrs[route];
    }

    if(decodeIO_decoder && decodeIO_decoder.lookup(route)) {
      return decodeIO_decoder.build(route).decode(msg.body);
    } else {
      return JSON.parse(Protocol.strdecode(msg.body));
    }

    return msg;
  };

  var handshakeInit = function(data) {
    if(data.sys && data.sys.heartbeat) {
      heartbeatInterval = data.sys.heartbeat * 1000;   // heartbeat interval
      heartbeatTimeout = heartbeatInterval * 2;        // max heartbeat timeout
    } else {
      heartbeatInterval = 0;
      heartbeatTimeout = 0;
    }

    initData(data);

    if(typeof handshakeCallback === 'function') {
      handshakeCallback(data.user);
    }
  };

  //Initilize data used in starx client
  var initData = function(data) {
    if(!data || !data.sys) {
      return;
    }
    dict = data.sys.dict;

    //Init compress dict
    if(dict) {
      dict = dict;
      abbrs = {};

      for(var route in dict) {
        abbrs[dict[route]] = route;
      }
    }

    window.starx = starx;
  }})();

```

`examples/demo/cluster/main.go`:

```go
package main

import (
	"context"
	"flag"
	"fmt"

	"strings"

	"github.com/sirupsen/logrus"
	"github.com/topfreegames/pitaya/v3/examples/demo/cluster/services"
	pitaya "github.com/topfreegames/pitaya/v3/pkg"
	"github.com/topfreegames/pitaya/v3/pkg/acceptor"
	"github.com/topfreegames/pitaya/v3/pkg/cluster"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/groups"
	"github.com/topfreegames/pitaya/v3/pkg/route"
	"github.com/topfreegames/pitaya/v3/pkg/tracing"
)

var app pitaya.Pitaya

func configureBackend() {
	room := services.NewRoom(app)
	app.Register(room,
		component.WithName("room"),
		component.WithNameFunc(strings.ToLower),
	)

	app.RegisterRemote(room,
		component.WithName("room"),
		component.WithNameFunc(strings.ToLower),
	)
}

func configureFrontend(port int) {
	app.Register(services.NewConnector(app),
		component.WithName("connector"),
		component.WithNameFunc(strings.ToLower),
	)

	app.RegisterRemote(services.NewConnectorRemote(app),
		component.WithName("connectorremote"),
		component.WithNameFunc(strings.ToLower),
	)

	err := app.AddRoute("room", func(
		ctx context.Context,
		route *route.Route,
		payload []byte,
		servers map[string]*cluster.Server,
	) (*cluster.Server, error) {
		// will return the first server
		for k := range servers {
			return servers[k], nil
		}
		return nil, nil
	})

	if err != nil {
		fmt.Printf("error adding route %s\n", err.Error())
	}

	err = app.SetDictionary(map[string]uint16{
		"connector.getsessiondata": 1,
		"connector.setsessiondata": 2,
		"room.room.getsessiondata": 3,
		"onMessage":                4,
		"onMembers":                5,
	})

	if err != nil {
		fmt.Printf("error setting route dictionary %s\n", err.Error())
	}
}

func configureOpenTelemetry(logger logrus.FieldLogger) {
	err := tracing.InitializeOtel()
	if err != nil {
		logger.Errorf("Failed to initialize OpenTelemetry: %v", err)
	}
}

func main() {
	port := flag.Int("port", 3250, "the port to listen")
	svType := flag.String("type", "connector", "the server type")
	isFrontend := flag.Bool("frontend", true, "if server is frontend")

	flag.Parse()

	configureOpenTelemetry(logrus.New())

	builder := pitaya.NewDefaultBuilder(*isFrontend, *svType, pitaya.Cluster, map[string]string{}, *config.NewDefaultPitayaConfig())
	if *isFrontend {
		tcp := acceptor.NewTCPAcceptor(fmt.Sprintf(":%d", *port))
		builder.AddAcceptor(tcp)
	}
	builder.Groups = groups.NewMemoryGroupService(builder.Config.Groups.Memory)
	app = builder.Build()

	defer app.Shutdown()

	if !*isFrontend {
		configureBackend()
	} else {
		configureFrontend(*port)
	}

	app.Start()
}

```

`examples/demo/cluster/services/connector.go`:

```go
package services

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/topfreegames/pitaya/v3/examples/demo/protos"
	pitaya "github.com/topfreegames/pitaya/v3/pkg"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	pitayaprotos "github.com/topfreegames/pitaya/v3/pkg/protos"
)

// ConnectorRemote is a remote that will receive rpc's
type ConnectorRemote struct {
	component.Base
	app pitaya.Pitaya
}

// Connector struct
type Connector struct {
	component.Base
	app pitaya.Pitaya
}

// SessionData struct
type SessionData struct {
	Data map[string]interface{}
}

// Response struct
type Response struct {
	Code int32
	Msg  string
}

// NewConnector ctor
func NewConnector(app pitaya.Pitaya) *Connector {
	return &Connector{app: app}
}

// NewConnectorRemote ctor
func NewConnectorRemote(app pitaya.Pitaya) *ConnectorRemote {
	return &ConnectorRemote{app: app}
}

func reply(code int32, msg string) (*protos.Response, error) {
	res := &protos.Response{
		Code: code,
		Msg:  msg,
	}
	return res, nil
}

// GetSessionData gets the session data
func (c *Connector) GetSessionData(ctx context.Context) (*SessionData, error) {
	s := c.app.GetSessionFromCtx(ctx)
	res := &SessionData{
		Data: s.GetData(),
	}
	return res, nil
}

// SetSessionData sets the session data
func (c *Connector) SetSessionData(ctx context.Context, data *SessionData) (*protos.Response, error) {
	s := c.app.GetSessionFromCtx(ctx)
	err := s.SetData(data.Data)
	if err != nil {
		return nil, pitaya.Error(err, "CN-000", map[string]string{"failed": "set data"})
	}
	return reply(200, "success")
}

// NotifySessionData sets the session data
func (c *Connector) NotifySessionData(ctx context.Context, data *SessionData) {
	s := c.app.GetSessionFromCtx(ctx)
	err := s.SetData(data.Data)
	if err != nil {
		fmt.Println("got error on notify", err)
	}
}

// RemoteFunc is a function that will be called remotely
func (c *ConnectorRemote) RemoteFunc(ctx context.Context, msg *protos.RPCMsg) (*protos.RPCRes, error) {
	fmt.Printf("received a remote call with this message: %s\n", msg.GetMsg())
	return &protos.RPCRes{
		Msg: msg.GetMsg(),
	}, nil
}

// Docs returns documentation
func (c *ConnectorRemote) Docs(ctx context.Context, ddd *pitayaprotos.Doc) (*pitayaprotos.Doc, error) {
	d, err := c.app.Documentation(true)
	if err != nil {
		return nil, err
	}
	doc, err := json.Marshal(d)

	if err != nil {
		return nil, err
	}

	return &pitayaprotos.Doc{Doc: string(doc)}, nil
}

func (c *ConnectorRemote) Descriptor(ctx context.Context, names *pitayaprotos.ProtoNames) (*pitayaprotos.ProtoDescriptors, error) {
	descriptors := make([][]byte, len(names.Name))

	for i, protoName := range names.Name {
		desc, err := pitaya.Descriptor(protoName)
		if err != nil {
			return nil, fmt.Errorf("failed to get descriptor for '%s': %w", protoName, err)
		}

		descriptors[i] = desc
	}

	return &pitayaprotos.ProtoDescriptors{Desc: descriptors}, nil
}

```

`examples/demo/cluster/services/room.go`:

```go
package services

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/topfreegames/pitaya/v3/examples/demo/protos"
	pitaya "github.com/topfreegames/pitaya/v3/pkg"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/timer"
)

type (
	// Room represents a component that contains a bundle of room related handler
	// like Join/Message
	Room struct {
		component.Base
		timer *timer.Timer
		app   pitaya.Pitaya
		Stats *protos.Stats
	}

	// UserMessage represents a message that user sent
	UserMessage struct {
		Name    string `json:"name"`
		Content string `json:"content"`
	}

	// Stats exports the room status
	Stats struct {
		outboundBytes int
		inboundBytes  int
	}

	// RPCResponse represents a rpc message
	RPCResponse struct {
		Msg string `json:"msg"`
	}

	// SendRPCMsg represents a rpc message
	SendRPCMsg struct {
		ServerID string `json:"serverId"`
		Route    string `json:"route"`
		Msg      string `json:"msg"`
	}

	// NewUser message will be received when new user join room
	NewUser struct {
		Content string `json:"content"`
	}

	// AllMembers contains all members uid
	AllMembers struct {
		Members []string `json:"members"`
	}

	// JoinResponse represents the result of joining room
	JoinResponse struct {
		Code   int    `json:"code"`
		Result string `json:"result"`
	}
)

// NewRoom returns a new room
func NewRoom(app pitaya.Pitaya) *Room {
	return &Room{
		app:   app,
		Stats: &protos.Stats{},
	}
}

// Init runs on service initialization
func (r *Room) Init() {
	r.app.GroupCreate(context.Background(), "room")
}

// AfterInit component lifetime callback
func (r *Room) AfterInit() {
	r.timer = pitaya.NewTimer(time.Minute, func() {
		count, err := r.app.GroupCountMembers(context.Background(), "room")
		println("UserCount: Time=>", time.Now().String(), "Count=>", count, "Error=>", err)
		println("OutboundBytes", r.Stats.OutboundBytes)
		println("InboundBytes", r.Stats.OutboundBytes)
	})
}

// Entry is the entrypoint
func (r *Room) Entry(ctx context.Context, msg []byte) (*protos.JoinResponse, error) {
	logger := pitaya.GetDefaultLoggerFromCtx(ctx) // The default logger contains a requestId, the route being executed and the sessionId
	s := r.app.GetSessionFromCtx(ctx)

	err := s.Bind(ctx, uuid.New().String())
	if err != nil {
		logger.Error("Failed to bind session")
		logger.Error(err)
		return nil, pitaya.Error(err, "RH-000", map[string]string{"failed": "bind"})
	}
	return &protos.JoinResponse{Result: "ok"}, nil
}

// GetSessionData gets the session data
func (r *Room) GetSessionData(ctx context.Context) (*SessionData, error) {
	s := r.app.GetSessionFromCtx(ctx)
	return &SessionData{
		Data: s.GetData(),
	}, nil
}

// SetSessionData sets the session data
func (r *Room) SetSessionData(ctx context.Context, data *SessionData) ([]byte, error) {
	logger := pitaya.GetDefaultLoggerFromCtx(ctx)
	s := r.app.GetSessionFromCtx(ctx)
	err := s.SetData(data.Data)
	if err != nil {
		logger.Error("Failed to set session data")
		logger.Error(err)
		return nil, err
	}
	err = s.PushToFront(ctx)
	if err != nil {
		return nil, err
	}
	return []byte("success"), nil
}

// Notify push is a notify route that triggers a push to a session
func (r *Room) NotifyPush(ctx context.Context) {
	s := r.app.GetSessionFromCtx(ctx)
	r.app.SendPushToUsers("testPush", &protos.RPCMsg{Msg: "test"}, []string{s.UID()}, "connector")
}

// Join room
func (r *Room) Join(ctx context.Context) (*protos.JoinResponse, error) {
	logger := pitaya.GetDefaultLoggerFromCtx(ctx)
	s := r.app.GetSessionFromCtx(ctx)
	err := r.app.GroupAddMember(ctx, "room", s.UID())
	if err != nil {
		logger.Error("Failed to join room")
		logger.Error(err)
		return nil, err
	}
	members, err := r.app.GroupMembers(ctx, "room")
	if err != nil {
		logger.Error("Failed to get members")
		logger.Error(err)
		return nil, err
	}
	s.Push("onMembers", &protos.AllMembers{Members: members})
	err = r.app.GroupBroadcast(ctx, "connector", "room", "onNewUser", &protos.NewUser{Content: fmt.Sprintf("New user: %d", s.ID())})
	if err != nil {
		logger.Error("Failed to broadcast onNewUser")
		logger.Error(err)
		return nil, err
	}
	return &protos.JoinResponse{Result: "success"}, nil
}

// Leave room
func (r *Room) Leave(ctx context.Context) ([]byte, error) {
	logger := pitaya.GetDefaultLoggerFromCtx(ctx)
	s := r.app.GetSessionFromCtx(ctx)
	err := r.app.GroupRemoveMember(ctx, "room", s.UID())
	if err != nil {
		logger.Error(err)
		return []byte("failed"), err
	}
	return []byte("success"), err
}

// Message sync last message to all members
func (r *Room) Message(ctx context.Context, msg *protos.UserMessage) {
	logger := pitaya.GetDefaultLoggerFromCtx(ctx)
	err := r.app.GroupBroadcast(ctx, "connector", "room", "onMessage", msg)
	if err != nil {
		logger.Error("Error broadcasting message")
		logger.Error(err)
	}
}

// SendRPC sends rpc
func (r *Room) SendRPC(ctx context.Context, msg *protos.SendRPCMsg) (*protos.RPCRes, error) {
	logger := pitaya.GetDefaultLoggerFromCtx(ctx)
	ret := &protos.RPCRes{}
	err := r.app.RPCTo(ctx, msg.ServerId, msg.Route, ret, &protos.RPCMsg{Msg: msg.Msg})
	if err != nil {
		logger.Errorf("Failed to execute RPCTo %s - %s", msg.ServerId, msg.Route)
		logger.Error(err)
		return nil, pitaya.Error(err, "RPC-000")
	}
	return ret, nil
}

// MessageRemote just echoes the given message
func (r *Room) MessageRemote(ctx context.Context, msg *protos.UserMessage, b bool, s string) (*protos.UserMessage, error) {
	return msg, nil
}

```

`examples/demo/cluster_grpc/main.go`:

```go
package main

import (
	"context"
	"flag"
	"fmt"
	"strconv"

	"strings"

	"github.com/topfreegames/pitaya/v3/examples/demo/cluster_grpc/services"
	pitaya "github.com/topfreegames/pitaya/v3/pkg"
	"github.com/topfreegames/pitaya/v3/pkg/acceptor"
	"github.com/topfreegames/pitaya/v3/pkg/cluster"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/groups"
	"github.com/topfreegames/pitaya/v3/pkg/modules"
	"github.com/topfreegames/pitaya/v3/pkg/route"
)

var app pitaya.Pitaya

func configureBackend() {
	room := services.NewRoom(app)
	app.Register(room,
		component.WithName("room"),
		component.WithNameFunc(strings.ToLower),
	)

	app.RegisterRemote(room,
		component.WithName("room"),
		component.WithNameFunc(strings.ToLower),
	)
}

func configureFrontend(port int) {
	app.Register(services.NewConnector(app),
		component.WithName("connector"),
		component.WithNameFunc(strings.ToLower),
	)
	app.RegisterRemote(&services.ConnectorRemote{},
		component.WithName("connectorremote"),
		component.WithNameFunc(strings.ToLower),
	)

	err := app.AddRoute("room", func(
		ctx context.Context,
		route *route.Route,
		payload []byte,
		servers map[string]*cluster.Server,
	) (*cluster.Server, error) {
		// will return the first server
		for k := range servers {
			return servers[k], nil
		}
		return nil, nil
	})

	if err != nil {
		fmt.Printf("error adding route %s\n", err.Error())
	}

	err = app.SetDictionary(map[string]uint16{
		"connector.getsessiondata": 1,
		"connector.setsessiondata": 2,
		"room.room.getsessiondata": 3,
		"onMessage":                4,
		"onMembers":                5,
	})

	if err != nil {
		fmt.Printf("error setting route dictionary %s\n", err.Error())
	}
}

func main() {
	port := flag.Int("port", 3250, "the port to listen")
	svType := flag.String("type", "connector", "the server type")
	isFrontend := flag.Bool("frontend", true, "if server is frontend")
	rpcServerPort := flag.Int("rpcsvport", 3434, "the port that grpc server will listen")

	flag.Parse()

	meta := map[string]string{
		constants.GRPCHostKey: "127.0.0.1",
		constants.GRPCPortKey: strconv.Itoa(*rpcServerPort),
	}

	var bs *modules.ETCDBindingStorage
	app, bs = createApp(*port, *isFrontend, *svType, meta, *rpcServerPort)

	defer app.Shutdown()

	app.RegisterModule(bs, "bindingsStorage")
	if !*isFrontend {
		configureBackend()
	} else {
		configureFrontend(*port)
	}
	app.Start()
}

func createApp(port int, isFrontend bool, svType string, meta map[string]string, rpcServerPort int) (pitaya.Pitaya, *modules.ETCDBindingStorage) {
	builder := pitaya.NewDefaultBuilder(isFrontend, svType, pitaya.Cluster, meta, *config.NewDefaultPitayaConfig())

	grpcServerConfig := builder.Config.Cluster.RPC.Server.Grpc
	grpcServerConfig.Port = rpcServerPort
	gs, err := cluster.NewGRPCServer(grpcServerConfig, builder.Server, builder.MetricsReporters)
	if err != nil {
		panic(err)
	}
	builder.RPCServer = gs
	builder.Groups = groups.NewMemoryGroupService(builder.Config.Groups.Memory)

	bs := modules.NewETCDBindingStorage(builder.Server, builder.SessionPool, builder.Config.Modules.BindingStorage.Etcd)

	gc, err := cluster.NewGRPCClient(
		builder.Config.Cluster.RPC.Client.Grpc,
		builder.Server,
		builder.MetricsReporters,
		bs,
		cluster.NewInfoRetriever(builder.Config.Cluster.Info),
	)
	if err != nil {
		panic(err)
	}
	builder.RPCClient = gc

	if isFrontend {
		tcp := acceptor.NewTCPAcceptor(fmt.Sprintf(":%d", port))
		builder.AddAcceptor(tcp)
	}

	return builder.Build(), bs
}

```

`examples/demo/cluster_grpc/services/connector.go`:

```go
package services

import (
	"context"
	"fmt"

	"github.com/topfreegames/pitaya/v3/examples/demo/protos"
	pitaya "github.com/topfreegames/pitaya/v3/pkg"
	"github.com/topfreegames/pitaya/v3/pkg/component"
)

// ConnectorRemote is a remote that will receive rpc's
type ConnectorRemote struct {
	component.Base
}

// Connector struct
type Connector struct {
	component.Base
	app pitaya.Pitaya
}

// SessionData struct
type SessionData struct {
	Data map[string]interface{}
}

// Response struct
type Response struct {
	Code int32
	Msg  string
}

// NewConnector ctor
func NewConnector(app pitaya.Pitaya) *Connector {
	return &Connector{app: app}
}

func reply(code int32, msg string) (*Response, error) {
	res := &Response{
		Code: code,
		Msg:  msg,
	}
	return res, nil
}

// GetSessionData gets the session data
func (c *Connector) GetSessionData(ctx context.Context) (*SessionData, error) {
	s := c.app.GetSessionFromCtx(ctx)
	res := &SessionData{
		Data: s.GetData(),
	}
	return res, nil
}

// SetSessionData sets the session data
func (c *Connector) SetSessionData(ctx context.Context, data *SessionData) (*Response, error) {
	s := c.app.GetSessionFromCtx(ctx)
	err := s.SetData(data.Data)
	if err != nil {
		return nil, pitaya.Error(err, "CN-000", map[string]string{"failed": "set data"})
	}
	return reply(200, "success")
}

// NotifySessionData sets the session data
func (c *Connector) NotifySessionData(ctx context.Context, data *SessionData) {
	s := c.app.GetSessionFromCtx(ctx)
	err := s.SetData(data.Data)
	if err != nil {
		fmt.Println("got error on notify", err)
	}
}

// SendPushToUser sends a push to a user
func (c *Connector) SendPushToUser(ctx context.Context, msg *UserMessage) (*Response, error) {
	_, err := c.app.SendPushToUsers("onMessage", msg, []string{"2"}, "connector")
	if err != nil {
		return nil, err
	}
	return &Response{
		Code: 200,
		Msg:  "boa",
	}, nil
}

// RemoteFunc is a function that will be called remotely
func (c *ConnectorRemote) RemoteFunc(ctx context.Context, msg *protos.RPCMsg) (*protos.RPCRes, error) {
	fmt.Printf("received a remote call with this message: %s\n", msg)
	return &protos.RPCRes{
		Msg: fmt.Sprintf("received msg: %s", msg.GetMsg()),
	}, nil
}

```

`examples/demo/cluster_grpc/services/room.go`:

```go
package services

import (
	"context"
	"encoding/gob"
	"fmt"
	"strconv"
	"time"

	"github.com/topfreegames/pitaya/v3/examples/demo/protos"
	pitaya "github.com/topfreegames/pitaya/v3/pkg"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/timer"
)

type (
	// Room represents a component that contains a bundle of room related handler
	// like Join/Message
	Room struct {
		component.Base
		timer *timer.Timer
		app   pitaya.Pitaya
		Stats *Stats
	}

	// UserMessage represents a message that user sent
	UserMessage struct {
		Name    string `json:"name"`
		Content string `json:"content"`
	}

	// Stats exports the room status
	Stats struct {
		outboundBytes int
		inboundBytes  int
	}

	// SendRPCMsg represents a rpc message
	SendRPCMsg struct {
		ServerID string `json:"serverId"`
		Route    string `json:"route"`
		Msg      string `json:"msg"`
	}

	// NewUser message will be received when new user join room
	NewUser struct {
		Content string `json:"content"`
	}

	// AllMembers contains all members uid
	AllMembers struct {
		Members []string `json:"members"`
	}

	// JoinResponse represents the result of joining room
	JoinResponse struct {
		Code   int    `json:"code"`
		Result string `json:"result"`
	}
)

// Outbound gets the outbound status
func (Stats *Stats) Outbound(ctx context.Context, in []byte) ([]byte, error) {
	Stats.outboundBytes += len(in)
	return in, nil
}

// Inbound gets the inbound status
func (Stats *Stats) Inbound(ctx context.Context, in []byte) ([]byte, error) {
	Stats.inboundBytes += len(in)
	return in, nil
}

// NewRoom returns a new room
func NewRoom(app pitaya.Pitaya) *Room {
	return &Room{
		app:   app,
		Stats: &Stats{},
	}
}

// Init runs on service initialization
func (r *Room) Init() {
	r.app.GroupCreate(context.Background(), "room")
	// It is necessary to register all structs that will be used in RPC calls
	// This must be done both in the caller and callee servers
	gob.Register(&UserMessage{})
}

// AfterInit component lifetime callback
func (r *Room) AfterInit() {
	r.timer = pitaya.NewTimer(time.Minute, func() {
		count, err := r.app.GroupCountMembers(context.Background(), "room")
		println("UserCount: Time=>", time.Now().String(), "Count=>", count, "Error=>", err)
		println("OutboundBytes", r.Stats.outboundBytes)
		println("InboundBytes", r.Stats.outboundBytes)
	})
}

// Entry is the entrypoint
func (r *Room) Entry(ctx context.Context, msg []byte) (*JoinResponse, error) {
	s := r.app.GetSessionFromCtx(ctx)
	err := s.Bind(ctx, strconv.Itoa(int(s.ID())))
	if err != nil {
		return nil, pitaya.Error(err, "RH-000", map[string]string{"failed": "bind"})
	}
	return &JoinResponse{Result: "ok"}, nil
}

// GetSessionData gets the session data
func (r *Room) GetSessionData(ctx context.Context) (*SessionData, error) {
	s := r.app.GetSessionFromCtx(ctx)
	return &SessionData{
		Data: s.GetData(),
	}, nil
}

// SetSessionData sets the session data
func (r *Room) SetSessionData(ctx context.Context, data *SessionData) ([]byte, error) {
	s := r.app.GetSessionFromCtx(ctx)
	err := s.SetData(data.Data)
	if err != nil {
		return nil, err
	}
	err = s.PushToFront(ctx)
	if err != nil {
		return nil, err
	}
	return []byte("success"), nil
}

// Join room
func (r *Room) Join(ctx context.Context) (*JoinResponse, error) {
	s := r.app.GetSessionFromCtx(ctx)
	err := r.app.GroupAddMember(ctx, "room", s.UID())
	if err != nil {
		return nil, err
	}
	members, err := r.app.GroupMembers(ctx, "room")
	if err != nil {
		return nil, err
	}
	s.Push("onMembers", &AllMembers{Members: members})
	r.app.GroupBroadcast(ctx, "connector", "room", "onNewUser", &NewUser{Content: fmt.Sprintf("New user: %d", s.ID())})
	err = s.OnClose(func() {
		r.app.GroupRemoveMember(ctx, "room", s.UID())
	})
	if err != nil {
		return nil, err
	}
	return &JoinResponse{Result: "success"}, nil
}

// Message sync last message to all members
func (r *Room) Message(ctx context.Context, msg *UserMessage) {
	err := r.app.GroupBroadcast(ctx, "connector", "room", "onMessage", msg)
	if err != nil {
		fmt.Println("error broadcasting message", err)
	}
}

// SendRPC sends rpc
func (r *Room) SendRPC(ctx context.Context, msg *protos.RPCMsg) (*protos.RPCRes, error) {
	ret := &protos.RPCRes{}
	err := r.app.RPC(ctx, "connector.connectorremote.remotefunc", ret, msg)
	if err != nil {
		return nil, pitaya.Error(err, "RPC-000")
	}
	return ret, nil
}

// MessageRemote just echoes the given message
func (r *Room) MessageRemote(ctx context.Context, msg *UserMessage, b bool, s string) (*UserMessage, error) {
	return msg, nil
}

```

`examples/demo/custom_metrics/README.md`:

```md
Custom Metrics Example
=======================

# Run
`make run-custom-metrics-example`

# Call routes
By using [pitaya-cli](https://github.com/topfreegames/pitaya-cli), call:
```
connect localhost:3250
request room.room.setcounter {"value": 1.0, "tag1": "value1", "tag2": "value2"}
request room.room.setgauge1 {"value": 1.0, "tag1": "value1"}
request room.room.setgauge2 {"value": 1.0, "tag2": "value2"}
request room.room.setsummary {"value": 1.0, "tag1": "value1"}
```

Check out the results on `curl localhost:9090/metrics | grep 'my_'`

```

`examples/demo/custom_metrics/config.yaml`:

```yaml
pitaya:
  metrics:
    prometheus:
      enabled: true
    custom:
      counters:
      - subsystem: room
        name: my_counter
        help: a counter example
        labels: ['tag1', 'tag2']
      gauges:
      - subsystem: room
        name: my_gauge_1
        help: a gauge example
        labels: ['tag1']
      - subsystem: room
        name: my_gauge_2
        help: a gauge example
        labels: ['tag2']
      summaries:
      - subsystem: room
        name: my_summary
        help: a summary example
        objectives: {0.7: 0.05, 0.9: 0.01, 0.99: 0.001}
        labels: ['tag1']

```

`examples/demo/custom_metrics/main.go`:

```go
package main

import (
	"flag"
	"fmt"
	"strings"

	"github.com/spf13/viper"
	"github.com/topfreegames/pitaya/v3/examples/demo/custom_metrics/services"
	pitaya "github.com/topfreegames/pitaya/v3/pkg"
	"github.com/topfreegames/pitaya/v3/pkg/acceptor"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/config"
)

var app pitaya.Pitaya

func main() {
	port := flag.Int("port", 3250, "the port to listen")
	svType := "room"
	isFrontend := true

	flag.Parse()

	cfg := viper.New()
	cfg.AddConfigPath(".")
	cfg.SetConfigName("config")
	err := cfg.ReadInConfig()
	if err != nil {
		panic(err)
	}

	tcp := acceptor.NewTCPAcceptor(fmt.Sprintf(":%d", *port))

	conf := config.NewConfig(cfg)
	builder := pitaya.NewBuilderWithConfigs(isFrontend, svType, pitaya.Cluster, map[string]string{}, conf)
	builder.AddAcceptor(tcp)
	app = builder.Build()

	defer app.Shutdown()

	app.Register(services.NewRoom(app),
		component.WithName("room"),
		component.WithNameFunc(strings.ToLower),
	)

	app.Start()
}

```

`examples/demo/custom_metrics/messages/args.go`:

```go
package messages

// SetCounterArg is the argument on room.setcounter handler
type SetCounterArg struct {
	Value float64
	Tag1  string
	Tag2  string
}

// SetGaugeArg is the argument on room.setgauge* handler
type SetGaugeArg struct {
	Value float64
	Tag   string
}

// SetSummaryArg is the argument on room.setsummary handler
type SetSummaryArg struct {
	Value float64
	Tag   string
}

```

`examples/demo/custom_metrics/messages/responses.go`:

```go
package messages

// Response is the basic response on handlers
type Response struct {
	Code int
}

// OKResponse returns a response with code 200
func OKResponse() *Response {
	return &Response{Code: 200}
}

```

`examples/demo/custom_metrics/services/room.go`:

```go
package services

import (
	"context"

	"github.com/topfreegames/pitaya/v3/examples/demo/custom_metrics/messages"
	pitaya "github.com/topfreegames/pitaya/v3/pkg"
	"github.com/topfreegames/pitaya/v3/pkg/component"
)

// Room server
type Room struct {
	component.Base
	app pitaya.Pitaya
}

// NewRoom ctor
func NewRoom(app pitaya.Pitaya) *Room {
	return &Room{
		app: app,
	}
}

// SetCounter sets custom my_counter
func (r *Room) SetCounter(
	ctx context.Context,
	arg *messages.SetCounterArg,
) (*messages.Response, error) {
	counterMetricName := "my_counter"

	for _, reporter := range r.app.GetMetricsReporters() {
		reporter.ReportCount(counterMetricName, map[string]string{
			"tag1": arg.Tag1,
			"tag2": arg.Tag2,
		}, arg.Value)
	}

	return messages.OKResponse(), nil
}

// SetGauge1 sets custom my_gauge_1
func (r *Room) SetGauge1(
	ctx context.Context,
	arg *messages.SetGaugeArg,
) (*messages.Response, error) {
	counterMetricName := "my_gauge_1"

	for _, reporter := range r.app.GetMetricsReporters() {
		reporter.ReportGauge(counterMetricName, map[string]string{
			"tag1": arg.Tag,
		}, arg.Value)
	}

	return messages.OKResponse(), nil
}

// SetGauge2 sets custom my_gauge_2
func (r *Room) SetGauge2(
	ctx context.Context,
	arg *messages.SetGaugeArg,
) (*messages.Response, error) {
	counterMetricName := "my_gauge_2"

	for _, reporter := range r.app.GetMetricsReporters() {
		reporter.ReportGauge(counterMetricName, map[string]string{
			"tag2": arg.Tag,
		}, arg.Value)
	}

	return messages.OKResponse(), nil
}

// SetSummary sets custom my_summary
func (r *Room) SetSummary(
	ctx context.Context,
	arg *messages.SetSummaryArg,
) (*messages.Response, error) {
	counterMetricName := "my_summary"

	for _, reporter := range r.app.GetMetricsReporters() {
		reporter.ReportSummary(counterMetricName, map[string]string{
			"tag1": arg.Tag,
		}, arg.Value)
	}

	return messages.OKResponse(), nil
}

```

`examples/demo/pipeline/main.go`:

```go
package main

import (
	"context"
	"flag"
	"fmt"

	"github.com/topfreegames/pitaya/v3/pkg"
	"github.com/topfreegames/pitaya/v3/pkg/acceptor"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/config"
)

// MetagameServer ...
type MetagameServer struct {
	component.Base
}

// NewMetagameMock ...
func NewMetagameMock() *MetagameServer {
	return &MetagameServer{}
}

// CreatePlayerCheatArgs is the struct used as parameter for the CreatePlayerCheat handler
// Using the 'validate' tag it's possible to add validations on all struct fields.
// For reference on the default validator see https://github.com/go-playground/validator.
// Also, to enable this validation pipeline see docs/configuration.rst.
type CreatePlayerCheatArgs struct {
	Name         string `json:"name"`
	Email        string `json:"email" validate:"email"`
	SoftCurrency int    `json:"softCurrency" validate:"gte=0,lte=1000"`
	HardCurrency int    `json:"hardCurrency" validate:"gte=0,lte=200"`
}

// CreatePlayerCheatResponse ...
type CreatePlayerCheatResponse struct {
	Msg string `json:"msg"`
}

// CreatePlayerCheat ...
func (g *MetagameServer) CreatePlayerCheat(ctx context.Context, args *CreatePlayerCheatArgs) (*CreatePlayerCheatResponse, error) {
	logger := pitaya.GetDefaultLoggerFromCtx(ctx) // The default logger contains a requestId, the route being executed and the sessionId
	logger.Info("CreatePlayerChest called")
	// Do nothing. This is just an example of how pipelines can be helpful
	return &CreatePlayerCheatResponse{
		Msg: "ok",
	}, nil
}

// HandlerNoArgResponse ...
type HandlerNoArgResponse struct {
	Msg string `json:"msg"`
}

// HandlerNoArg is a simple handler that do not have any arguments
func (g *MetagameServer) HandlerNoArg(ctx context.Context) (*HandlerNoArgResponse, error) {
	return &HandlerNoArgResponse{
		Msg: "ok",
	}, nil
}

// Simple example of a before pipeline that actually asserts the type of the
// in parameter.
// IMPORTANT: that this kind of pipeline will be hard to exist in real code
// as a pipeline function executes for every handler and each of them
// most probably have different parameter types.
func (g *MetagameServer) simpleBefore(ctx context.Context, in interface{}) (context.Context, interface{}, error) {
	logger := pitaya.GetDefaultLoggerFromCtx(ctx)
	logger.Info("Simple Before exec")

	if in != nil {
		createPlayerArgs := in.(*CreatePlayerCheatArgs)

		logger.Infof("Name: %s", createPlayerArgs.Name)
		logger.Infof("Email: %s", createPlayerArgs.Email)
		logger.Infof("SoftCurrency: %d", createPlayerArgs.SoftCurrency)
		logger.Infof("HardCurrency: %d", createPlayerArgs.HardCurrency)
	}
	return ctx, in, nil
}

// Simple example of an after pipeline. The 2nd argument is the handler response.
func (g *MetagameServer) simpleAfter(ctx context.Context, resp interface{}, err error) (interface{}, error) {
	logger := pitaya.GetDefaultLoggerFromCtx(ctx)
	logger.Infof("Simple After exec - response: %v , error: %v", resp, err)

	return resp, err
}

var app pitaya.Pitaya

func main() {
	svType := flag.String("type", "metagameDemo", "the server type")
	isFrontend := flag.Bool("frontend", true, "if server is frontend")
	flag.Parse()

	port := 3251
	metagameServer := NewMetagameMock()

	config := config.NewDefaultPitayaConfig()
	config.DefaultPipelines.StructValidation.Enabled = true

	builder := pitaya.NewDefaultBuilder(*isFrontend, *svType, pitaya.Cluster, map[string]string{}, *config)
	tcp := acceptor.NewTCPAcceptor(fmt.Sprintf(":%d", port))
	builder.AddAcceptor(tcp)
	builder.HandlerHooks.BeforeHandler.PushBack(metagameServer.simpleBefore)
	builder.HandlerHooks.AfterHandler.PushBack(metagameServer.simpleAfter)
	app = builder.Build()

	defer app.Shutdown()

	app.Register(metagameServer,
		component.WithName("metagameHandler"),
	)

	app.Start()
}

```

`examples/demo/protos/cluster.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.26.0
// 	protoc        v3.12.3
// source: examples/demo/protos/cluster.proto

package protos

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// RPCMsg message to be sent using rpc
type RPCMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Msg string `protobuf:"bytes,1,opt,name=Msg,proto3" json:"Msg,omitempty"`
}

func (x *RPCMsg) Reset() {
	*x = RPCMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_examples_demo_protos_cluster_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RPCMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RPCMsg) ProtoMessage() {}

func (x *RPCMsg) ProtoReflect() protoreflect.Message {
	mi := &file_examples_demo_protos_cluster_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RPCMsg.ProtoReflect.Descriptor instead.
func (*RPCMsg) Descriptor() ([]byte, []int) {
	return file_examples_demo_protos_cluster_proto_rawDescGZIP(), []int{0}
}

func (x *RPCMsg) GetMsg() string {
	if x != nil {
		return x.Msg
	}
	return ""
}

// RPCRes is the rpc response
type RPCRes struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Msg string `protobuf:"bytes,1,opt,name=Msg,proto3" json:"Msg,omitempty"`
}

func (x *RPCRes) Reset() {
	*x = RPCRes{}
	if protoimpl.UnsafeEnabled {
		mi := &file_examples_demo_protos_cluster_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RPCRes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RPCRes) ProtoMessage() {}

func (x *RPCRes) ProtoReflect() protoreflect.Message {
	mi := &file_examples_demo_protos_cluster_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RPCRes.ProtoReflect.Descriptor instead.
func (*RPCRes) Descriptor() ([]byte, []int) {
	return file_examples_demo_protos_cluster_proto_rawDescGZIP(), []int{1}
}

func (x *RPCRes) GetMsg() string {
	if x != nil {
		return x.Msg
	}
	return ""
}

// UserMessage represents a message that user sent
type UserMessage struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Name    string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Content string `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
}

func (x *UserMessage) Reset() {
	*x = UserMessage{}
	if protoimpl.UnsafeEnabled {
		mi := &file_examples_demo_protos_cluster_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UserMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserMessage) ProtoMessage() {}

func (x *UserMessage) ProtoReflect() protoreflect.Message {
	mi := &file_examples_demo_protos_cluster_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserMessage.ProtoReflect.Descriptor instead.
func (*UserMessage) Descriptor() ([]byte, []int) {
	return file_examples_demo_protos_cluster_proto_rawDescGZIP(), []int{2}
}

func (x *UserMessage) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *UserMessage) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

// Stats exports the room status
type Stats struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	OutboundBytes int64 `protobuf:"varint,1,opt,name=outbound_bytes,json=outboundBytes,proto3" json:"outbound_bytes,omitempty"`
	InboundBytes  int64 `protobuf:"varint,2,opt,name=inbound_bytes,json=inboundBytes,proto3" json:"inbound_bytes,omitempty"`
}

func (x *Stats) Reset() {
	*x = Stats{}
	if protoimpl.UnsafeEnabled {
		mi := &file_examples_demo_protos_cluster_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Stats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Stats) ProtoMessage() {}

func (x *Stats) ProtoReflect() protoreflect.Message {
	mi := &file_examples_demo_protos_cluster_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Stats.ProtoReflect.Descriptor instead.
func (*Stats) Descriptor() ([]byte, []int) {
	return file_examples_demo_protos_cluster_proto_rawDescGZIP(), []int{3}
}

func (x *Stats) GetOutboundBytes() int64 {
	if x != nil {
		return x.OutboundBytes
	}
	return 0
}

func (x *Stats) GetInboundBytes() int64 {
	if x != nil {
		return x.InboundBytes
	}
	return 0
}

// SendRPCMsg represents a rpc message
type SendRPCMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ServerId string `protobuf:"bytes,1,opt,name=server_id,json=serverId,proto3" json:"server_id,omitempty"`
	Route    string `protobuf:"bytes,2,opt,name=route,proto3" json:"route,omitempty"`
	Msg      string `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (x *SendRPCMsg) Reset() {
	*x = SendRPCMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_examples_demo_protos_cluster_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SendRPCMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendRPCMsg) ProtoMessage() {}

func (x *SendRPCMsg) ProtoReflect() protoreflect.Message {
	mi := &file_examples_demo_protos_cluster_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SendRPCMsg.ProtoReflect.Descriptor instead.
func (*SendRPCMsg) Descriptor() ([]byte, []int) {
	return file_examples_demo_protos_cluster_proto_rawDescGZIP(), []int{4}
}

func (x *SendRPCMsg) GetServerId() string {
	if x != nil {
		return x.ServerId
	}
	return ""
}

func (x *SendRPCMsg) GetRoute() string {
	if x != nil {
		return x.Route
	}
	return ""
}

func (x *SendRPCMsg) GetMsg() string {
	if x != nil {
		return x.Msg
	}
	return ""
}

// NewUser message will be received when new user join room
type NewUser struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Content string `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
}

func (x *NewUser) Reset() {
	*x = NewUser{}
	if protoimpl.UnsafeEnabled {
		mi := &file_examples_demo_protos_cluster_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NewUser) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NewUser) ProtoMessage() {}

func (x *NewUser) ProtoReflect() protoreflect.Message {
	mi := &file_examples_demo_protos_cluster_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NewUser.ProtoReflect.Descriptor instead.
func (*NewUser) Descriptor() ([]byte, []int) {
	return file_examples_demo_protos_cluster_proto_rawDescGZIP(), []int{5}
}

func (x *NewUser) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

// AllMembers contains all members uid
type AllMembers struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Members []string `protobuf:"bytes,1,rep,name=Members,proto3" json:"Members,omitempty"`
}

func (x *AllMembers) Reset() {
	*x = AllMembers{}
	if protoimpl.UnsafeEnabled {
		mi := &file_examples_demo_protos_cluster_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AllMembers) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AllMembers) ProtoMessage() {}

func (x *AllMembers) ProtoReflect() protoreflect.Message {
	mi := &file_examples_demo_protos_cluster_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AllMembers.ProtoReflect.Descriptor instead.
func (*AllMembers) Descriptor() ([]byte, []int) {
	return file_examples_demo_protos_cluster_proto_rawDescGZIP(), []int{6}
}

func (x *AllMembers) GetMembers() []string {
	if x != nil {
		return x.Members
	}
	return nil
}

// JoinResponse represents the result of joining room
type JoinResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Code   int64  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Result string `protobuf:"bytes,2,opt,name=result,proto3" json:"result,omitempty"`
}

func (x *JoinResponse) Reset() {
	*x = JoinResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_examples_demo_protos_cluster_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *JoinResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JoinResponse) ProtoMessage() {}

func (x *JoinResponse) ProtoReflect() protoreflect.Message {
	mi := &file_examples_demo_protos_cluster_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JoinResponse.ProtoReflect.Descriptor instead.
func (*JoinResponse) Descriptor() ([]byte, []int) {
	return file_examples_demo_protos_cluster_proto_rawDescGZIP(), []int{7}
}

func (x *JoinResponse) GetCode() int64 {
	if x != nil {
		return x.Code
	}
	return 0
}

func (x *JoinResponse) GetResult() string {
	if x != nil {
		return x.Result
	}
	return ""
}

// Response struct
type Response struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Code int32  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg  string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (x *Response) Reset() {
	*x = Response{}
	if protoimpl.UnsafeEnabled {
		mi := &file_examples_demo_protos_cluster_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Response) ProtoMessage() {}

func (x *Response) ProtoReflect() protoreflect.Message {
	mi := &file_examples_demo_protos_cluster_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Response.ProtoReflect.Descriptor instead.
func (*Response) Descriptor() ([]byte, []int) {
	return file_examples_demo_protos_cluster_proto_rawDescGZIP(), []int{8}
}

func (x *Response) GetCode() int32 {
	if x != nil {
		return x.Code
	}
	return 0
}

func (x *Response) GetMsg() string {
	if x != nil {
		return x.Msg
	}
	return ""
}

var File_examples_demo_protos_cluster_proto protoreflect.FileDescriptor

var file_examples_demo_protos_cluster_proto_rawDesc = []byte{
	0x0a, 0x22, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x73, 0x2f, 0x64, 0x65, 0x6d, 0x6f, 0x2f,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0e, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x5f, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x73, 0x22, 0x1a, 0x0a, 0x06, 0x52, 0x50, 0x43, 0x4d, 0x73, 0x67, 0x12, 0x10,
	0x0a, 0x03, 0x4d, 0x73, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x4d, 0x73, 0x67,
	0x22, 0x1a, 0x0a, 0x06, 0x52, 0x50, 0x43, 0x52, 0x65, 0x73, 0x12, 0x10, 0x0a, 0x03, 0x4d, 0x73,
	0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x4d, 0x73, 0x67, 0x22, 0x3b, 0x0a, 0x0b,
	0x55, 0x73, 0x65, 0x72, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x6e,
	0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12,
	0x18, 0x0a, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x22, 0x53, 0x0a, 0x05, 0x53, 0x74, 0x61,
	0x74, 0x73, 0x12, 0x25, 0x0a, 0x0e, 0x6f, 0x75, 0x74, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x5f, 0x62,
	0x79, 0x74, 0x65, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0d, 0x6f, 0x75, 0x74, 0x62,
	0x6f, 0x75, 0x6e, 0x64, 0x42, 0x79, 0x74, 0x65, 0x73, 0x12, 0x23, 0x0a, 0x0d, 0x69, 0x6e, 0x62,
	0x6f, 0x75, 0x6e, 0x64, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03,
	0x52, 0x0c, 0x69, 0x6e, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x42, 0x79, 0x74, 0x65, 0x73, 0x22, 0x51,
	0x0a, 0x0a, 0x53, 0x65, 0x6e, 0x64, 0x52, 0x50, 0x43, 0x4d, 0x73, 0x67, 0x12, 0x1b, 0x0a, 0x09,
	0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x08, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x49, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x72, 0x6f, 0x75,
	0x74, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x12,
	0x10, 0x0a, 0x03, 0x6d, 0x73, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6d, 0x73,
	0x67, 0x22, 0x23, 0x0a, 0x07, 0x4e, 0x65, 0x77, 0x55, 0x73, 0x65, 0x72, 0x12, 0x18, 0x0a, 0x07,
	0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63,
	0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x22, 0x26, 0x0a, 0x0a, 0x41, 0x6c, 0x6c, 0x4d, 0x65, 0x6d,
	0x62, 0x65, 0x72, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x18,
	0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x22, 0x3a,
	0x0a, 0x0c, 0x4a, 0x6f, 0x69, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12,
	0x0a, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x04, 0x63, 0x6f,
	0x64, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x06, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x22, 0x30, 0x0a, 0x08, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x6d, 0x73,
	0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6d, 0x73, 0x67, 0x42, 0x16, 0x5a, 0x14,
	0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x73, 0x2f, 0x64, 0x65, 0x6d, 0x6f, 0x2f, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x73, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_examples_demo_protos_cluster_proto_rawDescOnce sync.Once
	file_examples_demo_protos_cluster_proto_rawDescData = file_examples_demo_protos_cluster_proto_rawDesc
)

func file_examples_demo_protos_cluster_proto_rawDescGZIP() []byte {
	file_examples_demo_protos_cluster_proto_rawDescOnce.Do(func() {
		file_examples_demo_protos_cluster_proto_rawDescData = protoimpl.X.CompressGZIP(file_examples_demo_protos_cluster_proto_rawDescData)
	})
	return file_examples_demo_protos_cluster_proto_rawDescData
}

var file_examples_demo_protos_cluster_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_examples_demo_protos_cluster_proto_goTypes = []interface{}{
	(*RPCMsg)(nil),       // 0: cluster_protos.RPCMsg
	(*RPCRes)(nil),       // 1: cluster_protos.RPCRes
	(*UserMessage)(nil),  // 2: cluster_protos.UserMessage
	(*Stats)(nil),        // 3: cluster_protos.Stats
	(*SendRPCMsg)(nil),   // 4: cluster_protos.SendRPCMsg
	(*NewUser)(nil),      // 5: cluster_protos.NewUser
	(*AllMembers)(nil),   // 6: cluster_protos.AllMembers
	(*JoinResponse)(nil), // 7: cluster_protos.JoinResponse
	(*Response)(nil),     // 8: cluster_protos.Response
}
var file_examples_demo_protos_cluster_proto_depIdxs = []int32{
	0, // [0:0] is the sub-list for method output_type
	0, // [0:0] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_examples_demo_protos_cluster_proto_init() }
func file_examples_demo_protos_cluster_proto_init() {
	if File_examples_demo_protos_cluster_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_examples_demo_protos_cluster_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RPCMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_examples_demo_protos_cluster_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RPCRes); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_examples_demo_protos_cluster_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UserMessage); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_examples_demo_protos_cluster_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Stats); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_examples_demo_protos_cluster_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SendRPCMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_examples_demo_protos_cluster_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NewUser); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_examples_demo_protos_cluster_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AllMembers); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_examples_demo_protos_cluster_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*JoinResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_examples_demo_protos_cluster_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Response); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_examples_demo_protos_cluster_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_examples_demo_protos_cluster_proto_goTypes,
		DependencyIndexes: file_examples_demo_protos_cluster_proto_depIdxs,
		MessageInfos:      file_examples_demo_protos_cluster_proto_msgTypes,
	}.Build()
	File_examples_demo_protos_cluster_proto = out.File
	file_examples_demo_protos_cluster_proto_rawDesc = nil
	file_examples_demo_protos_cluster_proto_goTypes = nil
	file_examples_demo_protos_cluster_proto_depIdxs = nil
}

```

`examples/demo/protos/cluster.proto`:

```proto
syntax = "proto3";

package cluster_protos;
option go_package = "examples/demo/protos";

// RPCMsg message to be sent using rpc
message RPCMsg {
  string Msg = 1;
}

// RPCRes is the rpc response
message RPCRes {
  string Msg = 1;
}

// UserMessage represents a message that user sent
message UserMessage {
  string name = 1;
  string content = 2;
}

// Stats exports the room status
message Stats {
  int64 outbound_bytes = 1;
  int64 inbound_bytes = 2;
}

// SendRPCMsg represents a rpc message
message SendRPCMsg {
  string server_id = 1;
  string route = 2;
  string msg = 3;
}

// NewUser message will be received when new user join room
message NewUser {
  string content = 1;
}

// AllMembers contains all members uid
message AllMembers {
  repeated string Members = 1;
}

// JoinResponse represents the result of joining room
message JoinResponse {
  int64 code = 1;
  string result = 2;
}

// Response struct
message Response {
  int32 code = 1;
  string msg = 2;
}

```

`examples/demo/rate_limiting/main.go`:

```go
package main

import (
	"flag"
	"fmt"
	"strings"
	"time"

	"github.com/spf13/viper"
	"github.com/topfreegames/pitaya/v3/examples/demo/rate_limiting/services"
	pitaya "github.com/topfreegames/pitaya/v3/pkg"
	"github.com/topfreegames/pitaya/v3/pkg/acceptor"
	"github.com/topfreegames/pitaya/v3/pkg/acceptorwrapper"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
)

func createAcceptor(port int, reporters []metrics.Reporter) acceptor.Acceptor {

	// 5 requests in 1 minute. Doesn't make sense, just to test
	// rate limiting
	vConfig := viper.New()
	vConfig.Set("pitaya.conn.ratelimiting.limit", 5)
	vConfig.Set("pitaya.conn.ratelimiting.interval", time.Minute)
	pConfig := config.NewConfig(vConfig)

	rateLimitConfig := config.NewPitayaConfig(pConfig).Conn.RateLimiting

	tcp := acceptor.NewTCPAcceptor(fmt.Sprintf(":%d", port))
	return acceptorwrapper.WithWrappers(
		tcp,
		acceptorwrapper.NewRateLimitingWrapper(reporters, rateLimitConfig))
}

var app pitaya.Pitaya

func main() {
	port := flag.Int("port", 3250, "the port to listen")
	svType := "room"

	flag.Parse()

	config := config.NewDefaultPitayaConfig()
	builder := pitaya.NewDefaultBuilder(true, svType, pitaya.Cluster, map[string]string{}, *config)
	builder.AddAcceptor(createAcceptor(*port, builder.MetricsReporters))

	app = builder.Build()

	defer app.Shutdown()

	room := services.NewRoom()
	app.Register(room,
		component.WithName("room"),
		component.WithNameFunc(strings.ToLower),
	)

	app.Start()
}

```

`examples/demo/rate_limiting/services/room.go`:

```go
package services

import (
	"context"

	"github.com/topfreegames/pitaya/v3/pkg/component"
)

// Room represents a component that contains a bundle of room related handler
type Room struct {
	component.Base
}

// NewRoom returns a new room
func NewRoom() *Room {
	return &Room{}
}

// Ping returns a pong
func (r *Room) Ping(ctx context.Context) ([]byte, error) {
	return []byte("pong"), nil
}

```

`examples/demo/worker/main.go`:

```go
package main

import (
	"flag"
	"fmt"

	"strings"

	"github.com/spf13/viper"
	"github.com/topfreegames/pitaya/v3/examples/demo/worker/services"
	pitaya "github.com/topfreegames/pitaya/v3/pkg"
	"github.com/topfreegames/pitaya/v3/pkg/acceptor"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/config"
)

var app pitaya.Pitaya

func configureWorker() {
	worker := services.Worker{}
	worker.Configure(app)
}

func main() {
	port := flag.Int("port", 3250, "the port to listen")
	svType := flag.String("type", "metagame", "the server type")
	isFrontend := flag.Bool("frontend", true, "if server is frontend")

	flag.Parse()

	conf := viper.New()
	conf.SetDefault("pitaya.worker.redis.url", "localhost:6379")
	conf.SetDefault("pitaya.worker.redis.pool", "3")

	config := config.NewConfig(conf)

	tcp := acceptor.NewTCPAcceptor(fmt.Sprintf(":%d", *port))

	builder := pitaya.NewBuilderWithConfigs(*isFrontend, *svType, pitaya.Cluster, map[string]string{}, config)
	if *isFrontend {
		builder.AddAcceptor(tcp)
	}
	app = builder.Build()

	defer app.Shutdown()

	switch *svType {
	case "metagame":
		app.RegisterRemote(&services.Metagame{},
			component.WithName("metagame"),
			component.WithNameFunc(strings.ToLower),
		)
	case "room":
		app.Register(services.NewRoom(app),
			component.WithName("room"),
			component.WithNameFunc(strings.ToLower),
		)
	case "worker":
		configureWorker()
	}

	app.Start()
}

```

`examples/demo/worker/protos/arg.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: arg.proto

package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Arg struct {
	Msg                  string   `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Arg) Reset()         { *m = Arg{} }
func (m *Arg) String() string { return proto.CompactTextString(m) }
func (*Arg) ProtoMessage()    {}
func (*Arg) Descriptor() ([]byte, []int) {
	return fileDescriptor_arg_e1b1c8888ddf9d6e, []int{0}
}
func (m *Arg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Arg.Unmarshal(m, b)
}
func (m *Arg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Arg.Marshal(b, m, deterministic)
}
func (dst *Arg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Arg.Merge(dst, src)
}
func (m *Arg) XXX_Size() int {
	return xxx_messageInfo_Arg.Size(m)
}
func (m *Arg) XXX_DiscardUnknown() {
	xxx_messageInfo_Arg.DiscardUnknown(m)
}

var xxx_messageInfo_Arg proto.InternalMessageInfo

func (m *Arg) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterType((*Arg)(nil), "protos.Arg")
}

func init() { proto.RegisterFile("arg.proto", fileDescriptor_arg_e1b1c8888ddf9d6e) }

var fileDescriptor_arg_e1b1c8888ddf9d6e = []byte{
	// 66 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x4c, 0x2c, 0x4a, 0xd7,
	0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x03, 0x53, 0xc5, 0x4a, 0xe2, 0x5c, 0xcc, 0x8e, 0x45,
	0xe9, 0x42, 0x02, 0x5c, 0xcc, 0xb9, 0xc5, 0xe9, 0x12, 0x8c, 0x0a, 0x8c, 0x1a, 0x9c, 0x41, 0x20,
	0x66, 0x12, 0x44, 0x81, 0x31, 0x20, 0x00, 0x00, 0xff, 0xff, 0x57, 0x6c, 0xa7, 0xb1, 0x34, 0x00,
	0x00, 0x00,
}

```

`examples/demo/worker/protos/arg.proto`:

```proto
syntax = "proto3";

package protos;

message Arg {
  string msg = 1;
}

```

`examples/demo/worker/protos/response.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: response.proto

package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Response struct {
	Code                 int32    `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_response_7319a4323854ca68, []int{0}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Response.Unmarshal(m, b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Response.Marshal(b, m, deterministic)
}
func (dst *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(dst, src)
}
func (m *Response) XXX_Size() int {
	return xxx_messageInfo_Response.Size(m)
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Response) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterType((*Response)(nil), "protos.Response")
}

func init() { proto.RegisterFile("response.proto", fileDescriptor_response_7319a4323854ca68) }

var fileDescriptor_response_7319a4323854ca68 = []byte{
	// 88 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x2b, 0x4a, 0x2d, 0x2e,
	0xc8, 0xcf, 0x2b, 0x4e, 0xd5, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x03, 0x53, 0xc5, 0x4a,
	0x06, 0x5c, 0x1c, 0x41, 0x50, 0x19, 0x21, 0x21, 0x2e, 0x96, 0xe4, 0xfc, 0x94, 0x54, 0x09, 0x46,
	0x05, 0x46, 0x0d, 0xd6, 0x20, 0x30, 0x5b, 0x48, 0x80, 0x8b, 0x39, 0xb7, 0x38, 0x5d, 0x82, 0x49,
	0x81, 0x51, 0x83, 0x33, 0x08, 0xc4, 0x4c, 0x82, 0xe8, 0x34, 0x06, 0x04, 0x00, 0x00, 0xff, 0xff,
	0x46, 0x18, 0xa3, 0x40, 0x52, 0x00, 0x00, 0x00,
}

```

`examples/demo/worker/protos/response.proto`:

```proto
syntax = "proto3";

package protos;

message Response {
  int32 code = 1;
  string msg = 2;
}

```

`examples/demo/worker/services/metagame.go`:

```go
package services

import (
	"context"

	"github.com/topfreegames/pitaya/v3/examples/demo/worker/protos"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
)

// Metagame server
type Metagame struct {
	component.Base
}

// LogRemote logs argument when called
func (m *Metagame) LogRemote(ctx context.Context, arg *protos.Arg) (*protos.Response, error) {
	logger.Log.Infof("argument %+v\n", arg)
	return &protos.Response{Code: 200, Msg: "ok"}, nil
}

```

`examples/demo/worker/services/room.go`:

```go
package services

import (
	"context"

	"github.com/topfreegames/pitaya/v3/examples/demo/worker/protos"
	pitaya "github.com/topfreegames/pitaya/v3/pkg"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
)

// Room server
type Room struct {
	component.Base
	app pitaya.Pitaya
}

// NewRoom ctor
func NewRoom(app pitaya.Pitaya) *Room {
	return &Room{app: app}
}

// CallLog makes ReliableRPC to metagame LogRemote
func (r *Room) CallLog(ctx context.Context, arg *protos.Arg) (*protos.Response, error) {
	route := "metagame.metagame.logremote"
	reply := &protos.Response{}
	jid, err := r.app.ReliableRPC(route, nil, reply, arg)
	if err != nil {
		logger.Log.Infof("failed to enqueue rpc: %q", err)
		return nil, err
	}

	logger.Log.Infof("enqueue rpc job: %d", jid)
	return &protos.Response{Code: 200, Msg: "ok"}, nil
}

```

`examples/demo/worker/services/worker.go`:

```go
package services

import (
	"context"

	"github.com/golang/protobuf/proto"
	"github.com/topfreegames/pitaya/v3/examples/demo/worker/protos"
	pitaya "github.com/topfreegames/pitaya/v3/pkg"
	"github.com/topfreegames/pitaya/v3/pkg/component"
)

// Worker server
type Worker struct {
	component.Base
}

// Configure starts workers and register rpc job
func (w *Worker) Configure(app pitaya.Pitaya) {
	app.StartWorker()
	app.RegisterRPCJob(&RPCJob{app: app})
}

// RPCJob implements worker.RPCJob
type RPCJob struct {
	app pitaya.Pitaya
}

// ServerDiscovery returns a serverID="", meaning any server
// is ok
func (r *RPCJob) ServerDiscovery(
	route string,
	rpcMetadata map[string]interface{},
) (serverID string, err error) {
	return "", nil
}

// RPC calls pitaya's rpc
func (r *RPCJob) RPC(
	ctx context.Context,
	serverID, routeStr string,
	reply, arg proto.Message,
) error {
	return r.app.RPCTo(ctx, serverID, routeStr, reply, arg)
}

// GetArgReply returns reply and arg of LogRemote,
// since we have no other methods in this example
func (r *RPCJob) GetArgReply(
	route string,
) (arg, reply proto.Message, err error) {
	return &protos.Arg{}, &protos.Response{}, nil
}

```

`examples/testing/docker-compose-jaeger.yml`:

```yml
services:
  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686"
      - "14268:14268"
      - "6831:6831/udp"
      - "6832:6832/udp"
      - "4317:4317"
      - "4318:4318"
    environment:
      - COLLECTOR_OTLP_ENABLED=true
      - COLLECTOR_OTLP_HTTP_HOST_PORT=0.0.0.0:4318
      - COLLECTOR_OTLP_GRPC_HOST_PORT=0.0.0.0:4317
      - LOG_LEVEL=debug

```

`examples/testing/docker-compose.yml`:

```yml
services:
  nats:
    image: nats
    ports:
      - 4222:4222
  etcd:
    image: quay.io/coreos/etcd:v3.5.15
    command:
      - /usr/local/bin/etcd
      - --listen-client-urls=http://0.0.0.0:2379
      - --advertise-client-urls=http://0.0.0.0:2379
    ports:
      - 2379:2379
  redis:
    image: redis
    ports:
      - 6379:6379

```

`examples/testing/docker/Dockerfile`:

```
FROM alpine:3.7

ADD ./server /server

CMD /server

```

`examples/testing/main.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package main

import (
	"context"
	"errors"
	"flag"
	"fmt"
	"strings"

	"github.com/google/uuid"
	"github.com/sirupsen/logrus"
	"github.com/spf13/viper"
	"github.com/topfreegames/pitaya/v3/examples/testing/protos"
	pitaya "github.com/topfreegames/pitaya/v3/pkg"
	"github.com/topfreegames/pitaya/v3/pkg/acceptor"
	"github.com/topfreegames/pitaya/v3/pkg/cluster"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/groups"
	logruswrapper "github.com/topfreegames/pitaya/v3/pkg/logger/logrus"
	"github.com/topfreegames/pitaya/v3/pkg/modules"
	"github.com/topfreegames/pitaya/v3/pkg/protos/test"
	"github.com/topfreegames/pitaya/v3/pkg/serialize/json"
	"github.com/topfreegames/pitaya/v3/pkg/serialize/protobuf"
	"github.com/topfreegames/pitaya/v3/pkg/session"
)

// TestSvc service for e2e tests
type TestSvc struct {
	component.Base
	app         pitaya.Pitaya
	sessionPool session.SessionPool
}

// TestRemoteSvc remote service for e2e tests
type TestRemoteSvc struct {
	component.Base
}

// TestRPCRequest for e2e tests
type TestRPCRequest struct {
	Route string `json:"route"`
	Data  string `json:"data"`
}

// TestSendToUsers for e2e tests
type TestSendToUsers struct {
	UIDs []string `json:"uids"`
	Msg  string   `json:"msg"`
}

// RPCTestRawPtrReturnsPtr remote for e2e tests
func (tr *TestRemoteSvc) RPCTestRawPtrReturnsPtr(ctx context.Context, data *test.TestRequest) (*test.TestResponse, error) {
	return &test.TestResponse{
		Code: 200,
		Msg:  fmt.Sprintf("got %s", data.GetMsg()),
	}, nil
}

// RPCTestPtrReturnsPtr remote for e2e tests
func (tr *TestRemoteSvc) RPCTestPtrReturnsPtr(ctx context.Context, req *test.TestRequest) (*test.TestResponse, error) {
	return &test.TestResponse{
		Code: 200,
		Msg:  fmt.Sprintf("got %s", req.Msg),
	}, nil
}

// RPCTestReturnsError remote for e2e tests
func (tr *TestRemoteSvc) RPCTestReturnsError(ctx context.Context, data *test.TestRequest) (*test.TestResponse, error) {
	return nil, pitaya.Error(errors.New("test error"), "PIT-433", map[string]string{"some": "meta"})
}

// RPCTestNoArgs remote for e2e tests
func (tr *TestRemoteSvc) RPCTestNoArgs(ctx context.Context) (*test.TestResponse, error) {
	return &test.TestResponse{
		Code: 200,
		Msg:  "got nothing",
	}, nil
}

// Init inits testsvc
func (t *TestSvc) Init() {
	err := t.app.GroupCreate(context.Background(), "g1")
	if err != nil {
		panic(err)
	}
}

// TestRequestKickUser handler for e2e tests
func (t *TestSvc) TestRequestKickUser(ctx context.Context, userID []byte) (*test.TestResponse, error) {
	s := t.sessionPool.GetSessionByUID(string(userID))
	if s == nil {
		return nil, pitaya.Error(constants.ErrSessionNotFound, "PIT-404")
	}
	err := s.Kick(ctx)
	if err != nil {
		return nil, err
	}
	return &test.TestResponse{
		Code: 200,
		Msg:  "ok",
	}, nil
}

// TestRequestKickMe handler for e2e tests
func (t *TestSvc) TestRequestKickMe(ctx context.Context) (*test.TestResponse, error) {
	s := t.app.GetSessionFromCtx(ctx)
	if s == nil {
		return nil, pitaya.Error(constants.ErrSessionNotFound, "PIT-404")
	}
	err := s.Kick(ctx)
	if err != nil {
		return nil, err
	}
	return &test.TestResponse{
		Code: 200,
		Msg:  "ok",
	}, nil
}

// TestRequestOnlySessionReturnsPtr handler for e2e tests
func (t *TestSvc) TestRequestOnlySessionReturnsPtr(ctx context.Context) (*test.TestResponse, error) {
	return &test.TestResponse{
		Code: 200,
		Msg:  "hello",
	}, nil
}

// TestRequestOnlySessionReturnsPtrNil handler for e2e tests
func (t *TestSvc) TestRequestOnlySessionReturnsPtrNil(ctx context.Context) (*test.TestResponse, error) {
	return nil, nil
}

// TestRequestReturnsPtr handler for e2e tests
func (t *TestSvc) TestRequestReturnsPtr(ctx context.Context, in *test.TestRequest) (*test.TestResponse, error) {
	return &test.TestResponse{
		Code: 200,
		Msg:  in.Msg,
	}, nil
}

// TestRequestOnlySessionReturnsRawNil handler for e2e tests
func (t *TestSvc) TestRequestOnlySessionReturnsRawNil(ctx context.Context) ([]byte, error) {
	return nil, nil
}

// TestRequestReturnsRaw handler for e2e tests
func (t *TestSvc) TestRequestReturnsRaw(ctx context.Context, in *test.TestRequest) ([]byte, error) {
	return []byte(in.Msg), nil
}

// TestRequestReceiveReturnsRaw handler for e2e tests
func (t *TestSvc) TestRequestReceiveReturnsRaw(ctx context.Context, in []byte) ([]byte, error) {
	return in, nil
}

// TestRequestReturnsError handler for e2e tests
func (t *TestSvc) TestRequestReturnsError(ctx context.Context, in []byte) ([]byte, error) {
	return nil, pitaya.Error(errors.New("somerror"), "PIT-555")
}

// TestBind handler for e2e tests
func (t *TestSvc) TestBind(ctx context.Context) ([]byte, error) {
	uid := uuid.New().String()
	s := t.app.GetSessionFromCtx(ctx)
	err := s.Bind(ctx, uid)
	if err != nil {
		return nil, pitaya.Error(err, "PIT-444")
	}
	err = t.app.GroupAddMember(ctx, "g1", s.UID())
	if err != nil {
		return nil, pitaya.Error(err, "PIT-441")
	}
	return []byte("ack"), nil
}

// TestBindID handler for e2e tests
func (t *TestSvc) TestBindID(ctx context.Context, byteUID []byte) ([]byte, error) {
	s := t.app.GetSessionFromCtx(ctx)
	err := s.Bind(ctx, string(byteUID))
	if err != nil {
		return nil, pitaya.Error(err, "PIT-444")
	}
	err = t.app.GroupAddMember(ctx, "g1", s.UID())
	if err != nil {
		return nil, pitaya.Error(err, "PIT-441")
	}
	return []byte("ack"), nil
}

// TestSendGroupMsg handler for e2e tests
func (t *TestSvc) TestSendGroupMsg(ctx context.Context, msg []byte) {
	t.app.GroupBroadcast(ctx, "connector", "g1", "route.test", msg)
}

// TestSendGroupMsgPtr handler for e2e tests
func (t *TestSvc) TestSendGroupMsgPtr(ctx context.Context, msg *test.TestRequest) {
	t.app.GroupBroadcast(ctx, "connector", "g1", "route.testptr", msg)
}

// TestSendToUsers handler for e2e tests
func (t *TestSvc) TestSendToUsers(ctx context.Context, msg *TestSendToUsers) {
	t.app.SendPushToUsers("route.sendtousers", []byte(msg.Msg), msg.UIDs, "connector")
}

// TestSendRPC tests sending a RPC
func (t *TestSvc) TestSendRPC(ctx context.Context, msg *TestRPCRequest) (*protos.TestResponse, error) {
	rep := &protos.TestResponse{}
	err := t.app.RPC(ctx, msg.Route, rep, &protos.TestRequest{Msg: msg.Data})
	if err != nil {
		return nil, err
	}
	return rep, nil
}

// TestSendRPCNoArgs tests sending a RPC
func (t *TestSvc) TestSendRPCNoArgs(ctx context.Context, msg *TestRPCRequest) (*protos.TestResponse, error) {
	rep := &protos.TestResponse{}
	err := t.app.RPC(ctx, msg.Route, rep, nil)
	if err != nil {
		return nil, err
	}
	return rep, nil
}

// var app pitaya.Pitaya

func main() {
	port := flag.Int("port", 32222, "the port to listen")
	svType := flag.String("type", "connector", "the server type")
	isFrontend := flag.Bool("frontend", true, "if server is frontend")
	serializer := flag.String("serializer", "json", "json or protobuf")
	sdPrefix := flag.String("sdprefix", "pitaya/", "prefix to discover other servers")
	debug := flag.Bool("debug", false, "turn on debug logging")
	grpc := flag.Bool("grpc", false, "turn on grpc")
	grpcPort := flag.Int("grpcport", 3434, "the grpc server port")

	flag.Parse()

	cfg := viper.New()
	cfg.Set("pitaya.cluster.sd.etcd.prefix", *sdPrefix)
	cfg.Set("pitaya.cluster.rpc.server.grpc.port", *grpcPort)

	l := logrus.New()
	l.Formatter = &logrus.TextFormatter{}
	l.SetLevel(logrus.InfoLevel)
	if *debug {
		l.SetLevel(logrus.DebugLevel)
	}

	pitaya.SetLogger(logruswrapper.NewWithFieldLogger(l))

	app, bs, sessionPool := createApp(*serializer, *port, *grpc, *isFrontend, *svType, pitaya.Cluster, map[string]string{
		constants.GRPCHostKey: "127.0.0.1",
		constants.GRPCPortKey: fmt.Sprintf("%d", *grpcPort),
	}, cfg)

	if *grpc {
		app.RegisterModule(bs, "bindingsStorage")
	}

	app.Register(
		&TestSvc{
			app:         app,
			sessionPool: sessionPool,
		},
		component.WithName("testsvc"),
		component.WithNameFunc(strings.ToLower),
	)

	app.RegisterRemote(
		&TestRemoteSvc{},
		component.WithName("testremotesvc"),
		component.WithNameFunc(strings.ToLower),
	)

	app.Start()
}

func createApp(serializer string, port int, grpc bool, isFrontend bool, svType string, serverMode pitaya.ServerMode, metadata map[string]string, cfg ...*viper.Viper) (pitaya.Pitaya, *modules.ETCDBindingStorage, session.SessionPool) {
	conf := config.NewConfig(cfg...)
	builder := pitaya.NewBuilderWithConfigs(isFrontend, svType, serverMode, metadata, conf)

	if isFrontend {
		tcp := acceptor.NewTCPAcceptor(fmt.Sprintf(":%d", port))
		builder.AddAcceptor(tcp)
	}

	builder.Groups = groups.NewMemoryGroupService(builder.Config.Groups.Memory)

	if serializer == "json" {
		builder.Serializer = json.NewSerializer()
	} else if serializer == "protobuf" {
		builder.Serializer = protobuf.NewSerializer()
	} else {
		panic("serializer should be either json or protobuf")
	}

	pitayaConfig := config.NewPitayaConfig(conf)

	var bs *modules.ETCDBindingStorage
	if grpc {
		gs, err := cluster.NewGRPCServer(pitayaConfig.Cluster.RPC.Server.Grpc, builder.Server, builder.MetricsReporters)
		if err != nil {
			panic(err)
		}

		bs = modules.NewETCDBindingStorage(builder.Server, builder.SessionPool, pitayaConfig.Modules.BindingStorage.Etcd)

		gc, err := cluster.NewGRPCClient(
			pitayaConfig.Cluster.RPC.Client.Grpc,
			builder.Server,
			builder.MetricsReporters,
			bs,
			cluster.NewInfoRetriever(pitayaConfig.Cluster.Info),
		)
		if err != nil {
			panic(err)
		}
		builder.RPCServer = gs
		builder.RPCClient = gc
	}

	return builder.Build(), bs, builder.SessionPool
}

```

`examples/testing/protos/cluster.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: cluster.proto

package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// TestRequest message to be sent using rpc
type TestRequest struct {
	Msg                  string   `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestRequest) Reset()         { *m = TestRequest{} }
func (m *TestRequest) String() string { return proto.CompactTextString(m) }
func (*TestRequest) ProtoMessage()    {}
func (*TestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cluster_8103f0c0bad3b7cd, []int{0}
}
func (m *TestRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TestRequest.Unmarshal(m, b)
}
func (m *TestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TestRequest.Marshal(b, m, deterministic)
}
func (dst *TestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestRequest.Merge(dst, src)
}
func (m *TestRequest) XXX_Size() int {
	return xxx_messageInfo_TestRequest.Size(m)
}
func (m *TestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TestRequest proto.InternalMessageInfo

func (m *TestRequest) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// TestResponse is the rpc response
type TestResponse struct {
	Code                 int32    `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestResponse) Reset()         { *m = TestResponse{} }
func (m *TestResponse) String() string { return proto.CompactTextString(m) }
func (*TestResponse) ProtoMessage()    {}
func (*TestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cluster_8103f0c0bad3b7cd, []int{1}
}
func (m *TestResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TestResponse.Unmarshal(m, b)
}
func (m *TestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TestResponse.Marshal(b, m, deterministic)
}
func (dst *TestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestResponse.Merge(dst, src)
}
func (m *TestResponse) XXX_Size() int {
	return xxx_messageInfo_TestResponse.Size(m)
}
func (m *TestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TestResponse proto.InternalMessageInfo

func (m *TestResponse) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *TestResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterType((*TestRequest)(nil), "protos.TestRequest")
	proto.RegisterType((*TestResponse)(nil), "protos.TestResponse")
}

func init() { proto.RegisterFile("cluster.proto", fileDescriptor_cluster_8103f0c0bad3b7cd) }

var fileDescriptor_cluster_8103f0c0bad3b7cd = []byte{
	// 109 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x4d, 0xce, 0x29, 0x2d,
	0x2e, 0x49, 0x2d, 0xd2, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x03, 0x53, 0xc5, 0x4a, 0xf2,
	0x5c, 0xdc, 0x21, 0xa9, 0xc5, 0x25, 0x41, 0xa9, 0x85, 0xa5, 0xa9, 0xc5, 0x25, 0x42, 0x02, 0x5c,
	0xcc, 0xb9, 0xc5, 0xe9, 0x12, 0x8c, 0x0a, 0x8c, 0x1a, 0x9c, 0x41, 0x20, 0xa6, 0x92, 0x09, 0x17,
	0x0f, 0x44, 0x41, 0x71, 0x41, 0x7e, 0x5e, 0x71, 0xaa, 0x90, 0x10, 0x17, 0x4b, 0x72, 0x7e, 0x4a,
	0x2a, 0x58, 0x09, 0x6b, 0x10, 0x98, 0x0d, 0xd3, 0xc5, 0x04, 0xd7, 0x95, 0x04, 0x31, 0xde, 0x18,
	0x10, 0x00, 0x00, 0xff, 0xff, 0xb1, 0x1b, 0x30, 0x27, 0x76, 0x00, 0x00, 0x00,
}

```

`examples/testing/protos/cluster.proto`:

```proto
syntax = "proto3";

package protos;

// TestRequest message to be sent using rpc
message TestRequest {
  string msg = 1;
}

// TestResponse is the rpc response
message  TestResponse {
  int32 code = 1;
  string msg = 2;
}

```

`go.mod`:

```mod
module github.com/topfreegames/pitaya/v3

go 1.25.4

require (
	github.com/DataDog/datadog-go v4.8.3+incompatible
	github.com/abiosoft/ishell/v2 v2.0.2
	github.com/go-playground/validator/v10 v10.13.0
	github.com/golang/mock v1.6.0
	github.com/golang/protobuf v1.5.4
	github.com/google/uuid v1.6.0
	github.com/gorilla/websocket v1.5.1
	github.com/jhump/protoreflect v1.15.6
	github.com/mailgun/proxyproto v1.0.0
	github.com/mitchellh/go-homedir v1.1.0
	github.com/mitchellh/mapstructure v1.5.0
	github.com/nats-io/nats-server/v2 v2.12.2
	github.com/nats-io/nats.go v1.47.0
	github.com/nats-io/nuid v1.0.1
	github.com/prometheus/client_golang v1.16.0
	github.com/sirupsen/logrus v1.9.3
	github.com/spf13/cobra v1.4.0
	github.com/spf13/viper v1.15.0
	github.com/stretchr/testify v1.9.0
	github.com/topfreegames/go-workers v1.2.1
	go.etcd.io/etcd/api/v3 v3.5.11
	go.etcd.io/etcd/client/pkg/v3 v3.5.11
	go.etcd.io/etcd/client/v3 v3.5.11
	go.etcd.io/etcd/tests/v3 v3.5.11
	go.opentelemetry.io/otel v1.28.0
	go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.28.0
	go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.28.0
	go.opentelemetry.io/otel/sdk v1.28.0
	go.opentelemetry.io/otel/trace v1.28.0
	golang.org/x/net v0.47.0
	google.golang.org/grpc v1.64.1
	google.golang.org/protobuf v1.34.2
)

require (
	github.com/BurntSushi/toml v1.3.2 // indirect
	github.com/Microsoft/go-winio v0.6.1 // indirect
	github.com/abiosoft/ishell v2.0.0+incompatible // indirect
	github.com/abiosoft/readline v0.0.0-20180607040430-155bce2042db // indirect
	github.com/antithesishq/antithesis-sdk-go v0.5.0 // indirect
	github.com/benbjohnson/clock v1.1.0 // indirect
	github.com/beorn7/perks v1.0.1 // indirect
	github.com/bitly/go-simplejson v0.5.1 // indirect
	github.com/bufbuild/protocompile v0.8.0 // indirect
	github.com/cenkalti/backoff/v4 v4.3.0 // indirect
	github.com/cespare/xxhash/v2 v2.2.0 // indirect
	github.com/coreos/go-semver v0.3.1 // indirect
	github.com/coreos/go-systemd/v22 v22.5.0 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/dustin/go-humanize v1.0.1 // indirect
	github.com/fatih/color v1.16.0 // indirect
	github.com/flynn-archive/go-shlex v0.0.0-20150515145356-3f9db97f8568 // indirect
	github.com/fsnotify/fsnotify v1.6.0 // indirect
	github.com/go-logr/logr v1.4.2 // indirect
	github.com/go-logr/stdr v1.2.2 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/gogo/protobuf v1.3.2 // indirect
	github.com/golang-jwt/jwt/v4 v4.5.2 // indirect
	github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da // indirect
	github.com/gomodule/redigo v1.9.2 // indirect
	github.com/google/btree v1.0.1 // indirect
	github.com/google/go-tpm v0.9.7 // indirect
	github.com/grpc-ecosystem/go-grpc-middleware v1.4.0 // indirect
	github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0 // indirect
	github.com/grpc-ecosystem/grpc-gateway v1.16.0 // indirect
	github.com/grpc-ecosystem/grpc-gateway/v2 v2.20.0 // indirect
	github.com/hashicorp/hcl v1.0.0 // indirect
	github.com/inconshreveable/mousetrap v1.0.0 // indirect
	github.com/jonboulle/clockwork v0.2.2 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/compress v1.18.1 // indirect
	github.com/leodido/go-urn v1.2.4 // indirect
	github.com/magiconair/properties v1.8.7 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/matttproud/golang_protobuf_extensions v1.0.4 // indirect
	github.com/minio/highwayhash v1.0.4-0.20251030100505-070ab1a87a76 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/nats-io/jwt/v2 v2.8.0 // indirect
	github.com/nats-io/nkeys v0.4.11 // indirect
	github.com/pelletier/go-toml/v2 v2.0.7 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/prometheus/client_model v0.5.0 // indirect
	github.com/prometheus/common v0.43.0 // indirect
	github.com/prometheus/procfs v0.10.1 // indirect
	github.com/soheilhy/cmux v0.1.5 // indirect
	github.com/spf13/afero v1.10.0 // indirect
	github.com/spf13/cast v1.5.1 // indirect
	github.com/spf13/jwalterweatherman v1.1.0 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
	github.com/subosito/gotenv v1.4.2 // indirect
	github.com/tmc/grpc-websocket-proxy v0.0.0-20201229170055-e5319fda7802 // indirect
	github.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2 // indirect
	go.etcd.io/bbolt v1.3.8 // indirect
	go.etcd.io/etcd/client/v2 v2.305.11 // indirect
	go.etcd.io/etcd/pkg/v3 v3.5.11 // indirect
	go.etcd.io/etcd/raft/v3 v3.5.11 // indirect
	go.etcd.io/etcd/server/v3 v3.5.11 // indirect
	go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.49.0 // indirect
	go.opentelemetry.io/otel/metric v1.28.0 // indirect
	go.opentelemetry.io/proto/otlp v1.3.1 // indirect
	go.uber.org/atomic v1.11.0 // indirect
	go.uber.org/multierr v1.11.0 // indirect
	go.uber.org/zap v1.24.0 // indirect
	golang.org/x/crypto v0.45.0 // indirect
	golang.org/x/mod v0.29.0 // indirect
	golang.org/x/sync v0.18.0 // indirect
	golang.org/x/sys v0.38.0 // indirect
	golang.org/x/text v0.31.0 // indirect
	golang.org/x/time v0.14.0 // indirect
	golang.org/x/tools v0.38.0 // indirect
	google.golang.org/genproto v0.0.0-20240227224415-6ceb2ff114de // indirect
	google.golang.org/genproto/googleapis/api v0.0.0-20240701130421-f6361c86f094 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20240701130421-f6361c86f094 // indirect
	gopkg.in/ini.v1 v1.67.0 // indirect
	gopkg.in/natefinch/lumberjack.v2 v2.0.0 // indirect
	gopkg.in/yaml.v2 v2.4.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	sigs.k8s.io/yaml v1.3.0 // indirect
)

```

`go.sum`:

```sum
cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
cloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
cloud.google.com/go v0.38.0/go.mod h1:990N+gfupTy94rShfmMCWGDn0LpTmnzTp2qbd1dvSRU=
cloud.google.com/go v0.44.1/go.mod h1:iSa0KzasP4Uvy3f1mN/7PiObzGgflwredwwASm/v6AU=
cloud.google.com/go v0.44.2/go.mod h1:60680Gw3Yr4ikxnPRS/oxxkBccT6SA1yMk63TGekxKY=
cloud.google.com/go v0.44.3/go.mod h1:60680Gw3Yr4ikxnPRS/oxxkBccT6SA1yMk63TGekxKY=
cloud.google.com/go v0.45.1/go.mod h1:RpBamKRgapWJb87xiFSdk4g1CME7QZg3uwTez+TSTjc=
cloud.google.com/go v0.46.3/go.mod h1:a6bKKbmY7er1mI7TEI4lsAkts/mkhTSZK8w33B4RAg0=
cloud.google.com/go v0.50.0/go.mod h1:r9sluTvynVuxRIOHXQEHMFffphuXHOMZMycpNR5e6To=
cloud.google.com/go v0.52.0/go.mod h1:pXajvRH/6o3+F9jDHZWQ5PbGhn+o8w9qiu/CffaVdO4=
cloud.google.com/go v0.53.0/go.mod h1:fp/UouUEsRkN6ryDKNW/Upv/JBKnv6WDthjR6+vze6M=
cloud.google.com/go v0.54.0/go.mod h1:1rq2OEkV3YMf6n/9ZvGWI3GWw0VoqH/1x2nd8Is/bPc=
cloud.google.com/go v0.56.0/go.mod h1:jr7tqZxxKOVYizybht9+26Z/gUq7tiRzu+ACVAMbKVk=
cloud.google.com/go v0.57.0/go.mod h1:oXiQ6Rzq3RAkkY7N6t3TcE6jE+CIBBbA36lwQ1JyzZs=
cloud.google.com/go v0.62.0/go.mod h1:jmCYTdRCQuc1PHIIJ/maLInMho30T/Y0M4hTdTShOYc=
cloud.google.com/go v0.65.0/go.mod h1:O5N8zS7uWy9vkA9vayVHs65eM1ubvY4h553ofrNHObY=
cloud.google.com/go v0.72.0/go.mod h1:M+5Vjvlc2wnp6tjzE102Dw08nGShTscUx2nZMufOKPI=
cloud.google.com/go v0.74.0/go.mod h1:VV1xSbzvo+9QJOxLDaJfTjx5e+MePCpCWwvftOeQmWk=
cloud.google.com/go v0.75.0/go.mod h1:VGuuCn7PG0dwsd5XPVm2Mm3wlh3EL55/79EKB6hlPTY=
cloud.google.com/go/bigquery v1.0.1/go.mod h1:i/xbL2UlR5RvWAURpBYZTtm/cXjCha9lbfbpx4poX+o=
cloud.google.com/go/bigquery v1.3.0/go.mod h1:PjpwJnslEMmckchkHFfq+HTD2DmtT67aNFKH1/VBDHE=
cloud.google.com/go/bigquery v1.4.0/go.mod h1:S8dzgnTigyfTmLBfrtrhyYhwRxG72rYxvftPBK2Dvzc=
cloud.google.com/go/bigquery v1.5.0/go.mod h1:snEHRnqQbz117VIFhE8bmtwIDY80NLUZUMb4Nv6dBIg=
cloud.google.com/go/bigquery v1.7.0/go.mod h1://okPTzCYNXSlb24MZs83e2Do+h+VXtc4gLoIoXIAPc=
cloud.google.com/go/bigquery v1.8.0/go.mod h1:J5hqkt3O0uAFnINi6JXValWIb1v0goeZM77hZzJN/fQ=
cloud.google.com/go/datastore v1.0.0/go.mod h1:LXYbyblFSglQ5pkeyhO+Qmw7ukd3C+pD7TKLgZqpHYE=
cloud.google.com/go/datastore v1.1.0/go.mod h1:umbIZjpQpHh4hmRpGhH4tLFup+FVzqBi1b3c64qFpCk=
cloud.google.com/go/pubsub v1.0.1/go.mod h1:R0Gpsv3s54REJCy4fxDixWD93lHJMoZTyQ2kNxGRt3I=
cloud.google.com/go/pubsub v1.1.0/go.mod h1:EwwdRX2sKPjnvnqCa270oGRyludottCI76h+R3AArQw=
cloud.google.com/go/pubsub v1.2.0/go.mod h1:jhfEVHT8odbXTkndysNHCcx0awwzvfOlguIAii9o8iA=
cloud.google.com/go/pubsub v1.3.1/go.mod h1:i+ucay31+CNRpDW4Lu78I4xXG+O1r/MAHgjpRVR+TSU=
cloud.google.com/go/storage v1.0.0/go.mod h1:IhtSnM/ZTZV8YYJWCY8RULGVqBDmpoyjwiyrjsg+URw=
cloud.google.com/go/storage v1.5.0/go.mod h1:tpKbwo567HUNpVclU5sGELwQWBDZ8gh0ZeosJ0Rtdos=
cloud.google.com/go/storage v1.6.0/go.mod h1:N7U0C8pVQ/+NIKOBQyamJIeKQKkZ+mxpohlUTyfDhBk=
cloud.google.com/go/storage v1.8.0/go.mod h1:Wv1Oy7z6Yz3DshWRJFhqM/UCfaWIRTdp0RXyy7KQOVs=
cloud.google.com/go/storage v1.10.0/go.mod h1:FLPqc6j+Ki4BU591ie1oL6qBQGu2Bl/tZ9ullr3+Kg0=
cloud.google.com/go/storage v1.14.0/go.mod h1:GrKmX003DSIwi9o29oFT7YDnHYwZoctc3fOKtUw0Xmo=
dmitri.shuralyov.com/gpu/mtl v0.0.0-20190408044501-666a987793e9/go.mod h1:H6x//7gZCb22OMCxBHrMx7a5I7Hp++hsVxbQ4BYO7hU=
github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
github.com/BurntSushi/toml v1.3.2 h1:o7IhLm0Msx3BaB+n3Ag7L8EVlByGnpq14C4YWiu/gL8=
github.com/BurntSushi/toml v1.3.2/go.mod h1:CxXYINrC8qIiEnFrOxCa7Jy5BFHlXnUU2pbicEuybxQ=
github.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802/go.mod h1:IVnqGOEym/WlBOVXweHU+Q+/VP0lqqI8lqeDx9IjBqo=
github.com/DataDog/datadog-go v4.8.3+incompatible h1:fNGaYSuObuQb5nzeTQqowRAd9bpDIRRV4/gUtIBjh8Q=
github.com/DataDog/datadog-go v4.8.3+incompatible/go.mod h1:LButxg5PwREeZtORoXG3tL4fMGNddJ+vMq1mwgfaqoQ=
github.com/Microsoft/go-winio v0.6.1 h1:9/kr64B9VUZrLm5YYwbGtUJnMgqWVOdUAXu6Migciow=
github.com/Microsoft/go-winio v0.6.1/go.mod h1:LRdKpFKfdobln8UmuiYcKPot9D2v6svN5+sAH+4kjUM=
github.com/abiosoft/ishell v2.0.0+incompatible h1:zpwIuEHc37EzrsIYah3cpevrIc8Oma7oZPxr03tlmmw=
github.com/abiosoft/ishell v2.0.0+incompatible/go.mod h1:HQR9AqF2R3P4XXpMpI0NAzgHf/aS6+zVXRj14cVk9qg=
github.com/abiosoft/ishell/v2 v2.0.2 h1:5qVfGiQISaYM8TkbBl7RFO6MddABoXpATrsFbVI+SNo=
github.com/abiosoft/ishell/v2 v2.0.2/go.mod h1:E4oTCXfo6QjoCart0QYa5m9w4S+deXs/P/9jA77A9Bs=
github.com/abiosoft/readline v0.0.0-20180607040430-155bce2042db h1:CjPUSXOiYptLbTdr1RceuZgSFDQ7U15ITERUGrUORx8=
github.com/abiosoft/readline v0.0.0-20180607040430-155bce2042db/go.mod h1:rB3B4rKii8V21ydCbIzH5hZiCQE7f5E9SzUb/ZZx530=
github.com/antihax/optional v1.0.0/go.mod h1:uupD/76wgC+ih3iEmQUL+0Ugr19nfwCT1kdvxnR2qWY=
github.com/antithesishq/antithesis-sdk-go v0.5.0 h1:cudCFF83pDDANcXFzkQPUHHedfnnIbUO3JMr9fqwFJs=
github.com/antithesishq/antithesis-sdk-go v0.5.0/go.mod h1:IUpT2DPAKh6i/YhSbt6Gl3v2yvUZjmKncl7U91fup7E=
github.com/benbjohnson/clock v1.1.0 h1:Q92kusRqC1XV2MjkWETPvjJVqKetz1OzxZB7mHJLju8=
github.com/benbjohnson/clock v1.1.0/go.mod h1:J11/hYXuz8f4ySSvYwY0FKfm+ezbsZBKZxNJlLklBHA=
github.com/beorn7/perks v1.0.1 h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=
github.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=
github.com/bitly/go-simplejson v0.5.1 h1:xgwPbetQScXt1gh9BmoJ6j9JMr3TElvuIyjR8pgdoow=
github.com/bitly/go-simplejson v0.5.1/go.mod h1:YOPVLzCfwK14b4Sff3oP1AmGhI9T9Vsg84etUnlyp+Q=
github.com/bufbuild/protocompile v0.8.0 h1:9Kp1q6OkS9L4nM3FYbr8vlJnEwtbpDPQlQOVXfR+78s=
github.com/bufbuild/protocompile v0.8.0/go.mod h1:+Etjg4guZoAqzVk2czwEQP12yaxLJ8DxuqCJ9qHdH94=
github.com/cenkalti/backoff/v4 v4.3.0 h1:MyRJ/UdXutAwSAT+s3wNd7MfTIcy71VQueUuFK343L8=
github.com/cenkalti/backoff/v4 v4.3.0/go.mod h1:Y3VNntkOUPxTVeUxJ/G5vcM//AlwfmyYozVcomhLiZE=
github.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=
github.com/cespare/xxhash/v2 v2.2.0 h1:DC2CZ1Ep5Y4k3ZQ899DldepgrayRUGE6BBZ/cd9Cj44=
github.com/cespare/xxhash/v2 v2.2.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
github.com/chzyer/logex v1.1.10 h1:Swpa1K6QvQznwJRcfTfQJmTE72DqScAa40E+fbHEXEE=
github.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=
github.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=
github.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1 h1:q763qf9huN11kDQavWsoZXJNW3xEE4JJyHa5Q25/sd8=
github.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=
github.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=
github.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=
github.com/cncf/udpa/go v0.0.0-20200629203442-efcf912fb354/go.mod h1:WmhPx2Nbnhtbo57+VJT5O0JRkEi1Wbu0z5j0R8u5Hbk=
github.com/cncf/udpa/go v0.0.0-20201120205902-5459f2c99403/go.mod h1:WmhPx2Nbnhtbo57+VJT5O0JRkEi1Wbu0z5j0R8u5Hbk=
github.com/cockroachdb/datadriven v1.0.2 h1:H9MtNqVoVhvd9nCBwOyDjUEdZCREqbIdCJD93PBm/jA=
github.com/cockroachdb/datadriven v1.0.2/go.mod h1:a9RdTaap04u637JoCzcUoIcDmvwSUtcUFtT/C3kJlTU=
github.com/coreos/go-semver v0.3.1 h1:yi21YpKnrx1gt5R+la8n5WgS0kCrsPp33dmEyHReZr4=
github.com/coreos/go-semver v0.3.1/go.mod h1:irMmmIw/7yzSRPWryHsK7EYSg09caPQL03VsM8rvUec=
github.com/coreos/go-systemd/v22 v22.5.0 h1:RrqgGjYQKalulkV8NGVIfkXQf6YYmOyiJKk8iXXhfZs=
github.com/coreos/go-systemd/v22 v22.5.0/go.mod h1:Y58oyj3AT4RCenI/lSvhwexgC+NSVTIJ3seZv2GcEnc=
github.com/cpuguy83/go-md2man/v2 v2.0.1/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=
github.com/customerio/gospec v0.0.0-20130710230057-a5cc0e48aa39 h1:O0YTztXI3XeJXlFhSo4wNb0VBVqSgT+hi/CjNWKvMnY=
github.com/customerio/gospec v0.0.0-20130710230057-a5cc0e48aa39/go.mod h1:OzYUFhPuL2JbjwFwrv6CZs23uBawekc6OZs+g19F0mY=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=
github.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=
github.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=
github.com/envoyproxy/go-control-plane v0.9.1-0.20191026205805-5f8ba28d4473/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=
github.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=
github.com/envoyproxy/go-control-plane v0.9.7/go.mod h1:cwu0lG7PUMfa9snN8LXBig5ynNVH9qI8YYLbd1fK2po=
github.com/envoyproxy/go-control-plane v0.9.9-0.20201210154907-fd9021fe5dad/go.mod h1:cXg6YxExXjJnVBQHBLXeUAgxn2UodCpnH306RInaBQk=
github.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=
github.com/fatih/color v1.12.0/go.mod h1:ELkj/draVOlAH/xkhN6mQ50Qd0MPOk5AAr3maGEBuJM=
github.com/fatih/color v1.16.0 h1:zmkK9Ngbjj+K0yRhTVONQh1p/HknKYSlNT+vZCzyokM=
github.com/fatih/color v1.16.0/go.mod h1:fL2Sau1YI5c0pdGEVCbKQbLXB6edEj1ZgiY4NijnWvE=
github.com/fatih/structs v1.1.0/go.mod h1:9NiDSp5zOcgEDl+j00MP/WkGVPOlPRLejGD8Ga6PJ7M=
github.com/flynn-archive/go-shlex v0.0.0-20150515145356-3f9db97f8568 h1:BMXYYRWTLOJKlh+lOBt6nUQgXAfB7oVIQt5cNreqSLI=
github.com/flynn-archive/go-shlex v0.0.0-20150515145356-3f9db97f8568/go.mod h1:rZfgFAXFS/z/lEd6LJmf9HVZ1LkgYiHx5pHhV5DR16M=
github.com/frankban/quicktest v1.14.4 h1:g2rn0vABPOOXmZUj+vbmUp0lPoXEMuhTpIluN0XL9UY=
github.com/frankban/quicktest v1.14.4/go.mod h1:4ptaffx2x8+WTWXmUCuVU6aPUX1/Mz7zb5vbUoiM6w0=
github.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=
github.com/fsnotify/fsnotify v1.4.9/go.mod h1:znqG4EE+3YCdAaPaxE2ZRY/06pZUdp0tY4IgpuI1SZQ=
github.com/fsnotify/fsnotify v1.6.0 h1:n+5WquG0fcWoWp6xPWfHdbskMCQaFnG6PfBrh1Ky4HY=
github.com/fsnotify/fsnotify v1.6.0/go.mod h1:sl3t1tCWJFWoRz9R8WJCbQihKKwmorjAbSClcnxKAGw=
github.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=
github.com/go-gl/glfw v0.0.0-20190409004039-e6da0acd62b1/go.mod h1:vR7hzQXu2zJy9AVAgeJqvqgH9Q5CA+iKCZ2gyEVpxRU=
github.com/go-gl/glfw/v3.3/glfw v0.0.0-20191125211704-12ad95a8df72/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=
github.com/go-gl/glfw/v3.3/glfw v0.0.0-20200222043503-6f7a984d4dc4/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=
github.com/go-ini/ini v1.55.0/go.mod h1:ByCAeIL28uOIIG0E3PJtZPDL8WnHpFKFOtgjp+3Ies8=
github.com/go-kit/log v0.1.0/go.mod h1:zbhenjAZHb184qTLMA9ZjW7ThYL0H2mk7Q6pNt4vbaY=
github.com/go-logfmt/logfmt v0.5.0/go.mod h1:wCYkCAKZfumFQihp8CzCvQ3paCTfi41vtzG1KdI/P7A=
github.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=
github.com/go-logr/logr v1.4.2 h1:6pFjapn8bFcIbiKo3XT4j/BhANplGihG6tvd+8rYgrY=
github.com/go-logr/logr v1.4.2/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=
github.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=
github.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=
github.com/go-playground/assert/v2 v2.2.0 h1:JvknZsQTYeFEAhQwI4qEt9cyV5ONwRHC+lYKSsYSR8s=
github.com/go-playground/assert/v2 v2.2.0/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=
github.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=
github.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=
github.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=
github.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=
github.com/go-playground/validator/v10 v10.13.0 h1:cFRQdfaSMCOSfGCCLB20MHvuoHb/s5G8L5pu2ppK5AQ=
github.com/go-playground/validator/v10 v10.13.0/go.mod h1:dwu7+CG8/CtBiJFZDz4e+5Upb6OLw04gtBYw0mcG/z4=
github.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=
github.com/godbus/dbus/v5 v5.0.4/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=
github.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=
github.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=
github.com/golang-jwt/jwt/v4 v4.5.2 h1:YtQM7lnr8iZ+j5q71MGKkNw9Mn7AjHM68uc9g5fXeUI=
github.com/golang-jwt/jwt/v4 v4.5.2/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=
github.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=
github.com/golang/groupcache v0.0.0-20190702054246-869f871628b6/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/golang/groupcache v0.0.0-20191227052852-215e87163ea7/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/golang/groupcache v0.0.0-20200121045136-8c9f03a8e57e/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da h1:oI5xCqsCo564l8iNU+DwB5epxmsaqB+rhGL0m5jtYqE=
github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
github.com/golang/mock v1.2.0/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
github.com/golang/mock v1.3.1/go.mod h1:sBzyDLLjw3U8JLTeZvSv8jJB+tU5PVekmnlKIyFUx0Y=
github.com/golang/mock v1.4.0/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=
github.com/golang/mock v1.4.1/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=
github.com/golang/mock v1.4.3/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=
github.com/golang/mock v1.4.4/go.mod h1:l3mdAwkq5BuhzHwde/uurv3sEJeZMXNpwsxVWU71h+4=
github.com/golang/mock v1.6.0 h1:ErTB+efbowRARo13NNdxyJji2egdxLGQhRaY+DUumQc=
github.com/golang/mock v1.6.0/go.mod h1:p6yTPP+5HYm5mzsMV8JkE6ZKdX+/wYM6Hr+LicevLPs=
github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=
github.com/golang/protobuf v1.3.4/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=
github.com/golang/protobuf v1.3.5/go.mod h1:6O5/vntMXwX2lRkT1hjjk0nAC1IDOTvTlVgjlRvqsdk=
github.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=
github.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=
github.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=
github.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=
github.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=
github.com/golang/protobuf v1.4.1/go.mod h1:U8fpvMrcmy5pZrNK1lt4xCsGvpyWQ/VVv6QDs8UjoX8=
github.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
github.com/golang/protobuf v1.4.3/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
github.com/golang/protobuf v1.5.4 h1:i7eJL8qZTpSEXOPTxNKhASYpMn+8e5Q6AdndVa1dWek=
github.com/golang/protobuf v1.5.4/go.mod h1:lnTiLA8Wa4RWRcIUkrtSVa5nRhsEGBg48fD6rSs7xps=
github.com/gomodule/redigo v1.9.2 h1:HrutZBLhSIU8abiSfW8pj8mPhOyMYjZT/wcA4/L9L9s=
github.com/gomodule/redigo v1.9.2/go.mod h1:KsU3hiK/Ay8U42qpaJk+kuNa3C+spxapWpM+ywhcgtw=
github.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=
github.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=
github.com/google/btree v1.0.1 h1:gK4Kx5IaGY9CD5sPJ36FHiBJ6ZXl0kilRiiCj+jdYp4=
github.com/google/btree v1.0.1/go.mod h1:xXMiIv4Fb/0kKde4SpL7qlzvu5cMJDRkFDxJfI9uaxA=
github.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=
github.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.4.1/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.1/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.2/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.4/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=
github.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/google/go-tpm v0.9.7 h1:u89J4tUUeDTlH8xxC3CTW7OHZjbjKoHdQ9W7gCUhtxA=
github.com/google/go-tpm v0.9.7/go.mod h1:h9jEsEECg7gtLis0upRBQU+GhYVH6jMjrFxI8u6bVUY=
github.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=
github.com/google/martian v2.1.0+incompatible/go.mod h1:9I4somxYTbIHy5NJKHRl3wXiIaQGbYVAs8BPL6v8lEs=
github.com/google/martian/v3 v3.0.0/go.mod h1:y5Zk1BBys9G+gd6Jrk0W3cC1+ELVxBWuIGO+w/tUAp0=
github.com/google/martian/v3 v3.1.0/go.mod h1:y5Zk1BBys9G+gd6Jrk0W3cC1+ELVxBWuIGO+w/tUAp0=
github.com/google/pprof v0.0.0-20181206194817-3ea8567a2e57/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=
github.com/google/pprof v0.0.0-20190515194954-54271f7e092f/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=
github.com/google/pprof v0.0.0-20191218002539-d4f498aebedc/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
github.com/google/pprof v0.0.0-20200212024743-f11f1df84d12/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
github.com/google/pprof v0.0.0-20200229191704-1ebb73c60ed3/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
github.com/google/pprof v0.0.0-20200430221834-fc25d7d30c6d/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
github.com/google/pprof v0.0.0-20200708004538-1a94d8640e99/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
github.com/google/pprof v0.0.0-20201023163331-3e6fc7fc9c4c/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=
github.com/google/pprof v0.0.0-20201203190320-1bf35d6f28c2/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=
github.com/google/pprof v0.0.0-20201218002935-b9804c9f04c2/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=
github.com/google/renameio v0.1.0/go.mod h1:KWCgfxg9yswjAJkECMjeO8J8rahYeXnNhOm40UhjYkI=
github.com/google/uuid v1.1.2/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/googleapis/gax-go/v2 v2.0.4/go.mod h1:0Wqv26UfaUD9n4G6kQubkQ+KchISgw+vpHVxEJEs9eg=
github.com/googleapis/gax-go/v2 v2.0.5/go.mod h1:DWXyrwAJ9X0FpwwEdw+IPEYBICEFu5mhpdKc/us6bOk=
github.com/googleapis/google-cloud-go-testing v0.0.0-20200911160855-bcd43fbb19e8/go.mod h1:dvDLG8qkwmyD9a/MJJN3XJcT3xFxOKAvTZGvuZmac9g=
github.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=
github.com/gorilla/websocket v1.5.1 h1:gmztn0JnHVt9JZquRuzLw3g4wouNVzKL15iLr/zn/QY=
github.com/gorilla/websocket v1.5.1/go.mod h1:x3kM2JMyaluk02fnUJpQuwD2dCS5NDG2ZHL0uE0tcaY=
github.com/grpc-ecosystem/go-grpc-middleware v1.4.0 h1:UH//fgunKIs4JdUbpDl1VZCDaL56wXCB/5+wF6uHfaI=
github.com/grpc-ecosystem/go-grpc-middleware v1.4.0/go.mod h1:g5qyo/la0ALbONm6Vbp88Yd8NsDy6rZz+RcrMPxvld8=
github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0 h1:Ovs26xHkKqVztRpIrF/92BcuyuQ/YW4NSIpoGtfXNho=
github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0/go.mod h1:8NvIoxWQoOIhqOTXgfV/d3M/q6VIi02HzZEHgUlZvzk=
github.com/grpc-ecosystem/grpc-gateway v1.16.0 h1:gmcG1KaJ57LophUzW0Hy8NmPhnMZb4M0+kPpLofRdBo=
github.com/grpc-ecosystem/grpc-gateway v1.16.0/go.mod h1:BDjrQk3hbvj6Nolgz8mAMFbcEtjT1g+wF4CSlocrBnw=
github.com/grpc-ecosystem/grpc-gateway/v2 v2.20.0 h1:bkypFPDjIYGfCYD5mRBvpqxfYX1YCS1PXdKYWi8FsN0=
github.com/grpc-ecosystem/grpc-gateway/v2 v2.20.0/go.mod h1:P+Lt/0by1T8bfcF3z737NnSbmxQAppXMRziHUxPOC8k=
github.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=
github.com/hashicorp/golang-lru v0.5.1/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=
github.com/hashicorp/hcl v1.0.0 h1:0Anlzjpi4vEasTeNFn2mLJgTSwt0+6sfsiTG8qcWGx4=
github.com/hashicorp/hcl v1.0.0/go.mod h1:E5yfLk+7swimpb2L/Alb/PJmXilQ/rhwaUYs4T20WEQ=
github.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=
github.com/ianlancetaylor/demangle v0.0.0-20181102032728-5e5cf60278f6/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=
github.com/ianlancetaylor/demangle v0.0.0-20200824232613-28f6c0f3b639/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=
github.com/inconshreveable/mousetrap v1.0.0 h1:Z8tu5sraLXCXIcARxBp/8cbvlwVa7Z1NHg9XEKhtSvM=
github.com/inconshreveable/mousetrap v1.0.0/go.mod h1:PxqpIevigyE2G7u3NXJIT2ANytuPF1OarO4DADm73n8=
github.com/jhump/protoreflect v1.15.6 h1:WMYJbw2Wo+KOWwZFvgY0jMoVHM6i4XIvRs2RcBj5VmI=
github.com/jhump/protoreflect v1.15.6/go.mod h1:jCHoyYQIJnaabEYnbGwyo9hUqfyUMTbJw/tAut5t97E=
github.com/jonboulle/clockwork v0.2.2 h1:UOGuzwb1PwsrDAObMuhUnj0p5ULPj8V/xJ7Kx9qUBdQ=
github.com/jonboulle/clockwork v0.2.2/go.mod h1:Pkfl5aHPm1nk2H9h0bjmnJD/BcgbGXUBGnn1kMkgxc8=
github.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=
github.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=
github.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=
github.com/jstemmer/go-junit-report v0.9.1/go.mod h1:Brl9GWCQeLvo8nXZwPNNblvFj/XSXhF0NWZEnDohbsk=
github.com/jtolds/gls v4.20.0+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=
github.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=
github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
github.com/klauspost/compress v1.18.1 h1:bcSGx7UbpBqMChDtsF28Lw6v/G94LPrrbMbdC3JH2co=
github.com/klauspost/compress v1.18.1/go.mod h1:ZQFFVG+MdnR0P+l6wpXgIL4NTtwiKIdBnrBd8Nrxr+0=
github.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=
github.com/kr/fs v0.1.0/go.mod h1:FFnZGqtBN9Gxj7eW1uZ42v5BccTP0vu6NEaFoC2HwRg=
github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=
github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/leodido/go-urn v1.2.4 h1:XlAE/cm/ms7TE/VMVoduSpNBoyc2dOxHs5MZSwAN63Q=
github.com/leodido/go-urn v1.2.4/go.mod h1:7ZrI8mTSeBSHl/UaRyKQW1qZeMgak41ANeCNaVckg+4=
github.com/magiconair/properties v1.8.7 h1:IeQXZAiQcpL9mgcAe1Nu6cX9LLw6ExEHKjN0VQdvPDY=
github.com/magiconair/properties v1.8.7/go.mod h1:Dhd985XPs7jluiymwWYZ0G4Z61jb3vdS329zhj2hYo0=
github.com/mailgun/proxyproto v1.0.0 h1:CZTX/NM0qSq2JSatnowAhXmsHCXVu9JY6CDouOxJIQ4=
github.com/mailgun/proxyproto v1.0.0/go.mod h1:4r+sqMZLJWs8HRnFYcpYH/Cb+P2QGAQt+bV76JJkS4I=
github.com/mattn/go-colorable v0.1.8/go.mod h1:u6P/XSegPjTcexA+o6vUJrdnUu04hMope9wVRipJSqc=
github.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=
github.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=
github.com/mattn/go-isatty v0.0.12/go.mod h1:cbi8OIDigv2wuxKPP5vlRcQ1OAZbq2CE4Kysco4FUpU=
github.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/matttproud/golang_protobuf_extensions v1.0.4 h1:mmDVorXM7PCGKw94cs5zkfA9PSy5pEvNWRP0ET0TIVo=
github.com/matttproud/golang_protobuf_extensions v1.0.4/go.mod h1:BSXmuO+STAnVfrANrmjBb36TMTDstsz7MSK+HVaYKv4=
github.com/minio/highwayhash v1.0.4-0.20251030100505-070ab1a87a76 h1:KGuD/pM2JpL9FAYvBrnBBeENKZNh6eNtjqytV6TYjnk=
github.com/minio/highwayhash v1.0.4-0.20251030100505-070ab1a87a76/go.mod h1:GGYsuwP/fPD6Y9hMiXuapVvlIUEhFhMTh0rxU3ik1LQ=
github.com/mitchellh/go-homedir v1.1.0 h1:lukF9ziXFxDFPkA1vsr5zpc1XuPDn/wFntq5mG+4E0Y=
github.com/mitchellh/go-homedir v1.1.0/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=
github.com/mitchellh/mapstructure v1.5.0 h1:jeMsZIYE/09sWLaz43PL7Gy6RuMjD2eJVyuac5Z2hdY=
github.com/mitchellh/mapstructure v1.5.0/go.mod h1:bFUtVrKA4DC2yAKiSyO/QUcy7e+RRV2QTWOzhPopBRo=
github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=
github.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=
github.com/nats-io/jwt/v2 v2.8.0 h1:K7uzyz50+yGZDO5o772eRE7atlcSEENpL7P+b74JV1g=
github.com/nats-io/jwt/v2 v2.8.0/go.mod h1:me11pOkwObtcBNR8AiMrUbtVOUGkqYjMQZ6jnSdVUIA=
github.com/nats-io/nats-server/v2 v2.12.2 h1:4TEQd0Y4zvcW0IsVxjlXnRso1hBkQl3TS0BI+SxgPhE=
github.com/nats-io/nats-server/v2 v2.12.2/go.mod h1:j1AAttYeu7WnvD8HLJ+WWKNMSyxsqmZ160pNtCQRMyE=
github.com/nats-io/nats.go v1.47.0 h1:YQdADw6J/UfGUd2Oy6tn4Hq6YHxCaJrVKayxxFqYrgM=
github.com/nats-io/nats.go v1.47.0/go.mod h1:iRWIPokVIFbVijxuMQq4y9ttaBTMe0SFdlZfMDd+33g=
github.com/nats-io/nkeys v0.4.11 h1:q44qGV008kYd9W1b1nEBkNzvnWxtRSQ7A8BoqRrcfa0=
github.com/nats-io/nkeys v0.4.11/go.mod h1:szDimtgmfOi9n25JpfIdGw12tZFYXqhGxjhVxsatHVE=
github.com/nats-io/nuid v1.0.1 h1:5iA8DT8V7q8WK2EScv2padNa/rTESc1KdnPw4TC2paw=
github.com/nats-io/nuid v1.0.1/go.mod h1:19wcPz3Ph3q0Jbyiqsd0kePYG7A95tJPxeL+1OSON2c=
github.com/onsi/ginkgo v1.6.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=
github.com/onsi/ginkgo v1.12.0/go.mod h1:oUhWkIvk5aDxtKvDDuw8gItl8pKl42LzjC9KZE0HfGg=
github.com/onsi/gomega v1.7.1/go.mod h1:XdKZgCCFLUoM/7CFJVPcG8C1xQ1AJ0vpAezJrB7JYyY=
github.com/onsi/gomega v1.9.0/go.mod h1:Ho0h+IUsWyvy1OpqCwxlQ/21gkhVunqlU8fDGcoTdcA=
github.com/opentracing/opentracing-go v1.1.0/go.mod h1:UkNAQd3GIcIGf0SeVgPpRdFStlNbqXla1AfSYxPUl2o=
github.com/pelletier/go-toml/v2 v2.0.7 h1:muncTPStnKRos5dpVKULv2FVd4bMOhNePj9CjgDb8Us=
github.com/pelletier/go-toml/v2 v2.0.7/go.mod h1:eumQOmlWiOPt5WriQQqoM5y18pDHwha2N+QD+EUNTek=
github.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pkg/sftp v1.13.1/go.mod h1:3HaPG6Dq1ILlpPZRO0HVMrsydcdLt6HRDccSgb87qRg=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/prometheus/client_golang v1.16.0 h1:yk/hx9hDbrGHovbci4BY+pRMfSuuat626eFsHb7tmT8=
github.com/prometheus/client_golang v1.16.0/go.mod h1:Zsulrv/L9oM40tJ7T815tM89lFEugiJ9HzIqaAx4LKc=
github.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
github.com/prometheus/client_model v0.5.0 h1:VQw1hfvPvk3Uv6Qf29VrPF32JB6rtbgI6cYPYQjL0Qw=
github.com/prometheus/client_model v0.5.0/go.mod h1:dTiFglRmd66nLR9Pv9f0mZi7B7fk5Pm3gvsjB5tr+kI=
github.com/prometheus/common v0.43.0 h1:iq+BVjvYLei5f27wiuNiB1DN6DYQkp1c8Bx0Vykh5us=
github.com/prometheus/common v0.43.0/go.mod h1:NCvr5cQIh3Y/gy73/RdVtC9r8xxrxwJnB+2lB3BxrFc=
github.com/prometheus/procfs v0.10.1 h1:kYK1Va/YMlutzCGazswoHKo//tZVlFpKYh+PymziUAg=
github.com/prometheus/procfs v0.10.1/go.mod h1:nwNm2aOCAYw8uTR/9bWRREkZFxAUcWzPHWJq+XBB/FM=
github.com/rogpeppe/fastuuid v1.2.0/go.mod h1:jVj6XXZzXRy/MSR5jhDC/2q6DgLz+nrA6LYCDYWNEvQ=
github.com/rogpeppe/go-internal v1.3.0/go.mod h1:M8bDsm7K2OlrFYOpmOWEs/qY81heoFRclV5y23lUDJ4=
github.com/rogpeppe/go-internal v1.12.0 h1:exVL4IDcn6na9z1rAb56Vxr+CgyK3nn3O+epU5NdKM8=
github.com/rogpeppe/go-internal v1.12.0/go.mod h1:E+RYuTGaKKdloAfM02xzb0FW3Paa99yedzYV+kq4uf4=
github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
github.com/sirupsen/logrus v1.4.2/go.mod h1:tLMulIdttU9McNUspp0xgXVQah82FyeX6MwdIuYE2rE=
github.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=
github.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=
github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=
github.com/smartystreets/goconvey v1.6.4/go.mod h1:syvi0/a8iFYH4r/RixwvyeAJjdLS9QV7WQ/tjFTllLA=
github.com/soheilhy/cmux v0.1.5 h1:jjzc5WVemNEDTLwv9tlmemhC73tI08BNOIGwBOo10Js=
github.com/soheilhy/cmux v0.1.5/go.mod h1:T7TcVDs9LWfQgPlPsdngu6I6QIoyIFZDDC6sNE1GqG0=
github.com/spf13/afero v1.10.0 h1:EaGW2JJh15aKOejeuJ+wpFSHnbd7GE6Wvp3TsNhb6LY=
github.com/spf13/afero v1.10.0/go.mod h1:UBogFpq8E9Hx+xc5CNTTEpTnuHVmXDwZcZcE1eb/UhQ=
github.com/spf13/cast v1.3.1/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=
github.com/spf13/cast v1.5.1 h1:R+kOtfhWQE6TVQzY+4D7wJLBgkdVasCEFxSUBYBYIlA=
github.com/spf13/cast v1.5.1/go.mod h1:b9PdjNptOpzXr7Rq1q9gJML/2cdGQAo69NKzQ10KN48=
github.com/spf13/cobra v1.4.0 h1:y+wJpx64xcgO1V+RcnwW0LEHxTKRi2ZDPSBjWnrg88Q=
github.com/spf13/cobra v1.4.0/go.mod h1:Wo4iy3BUC+X2Fybo0PDqwJIv3dNRiZLHQymsfxlB84g=
github.com/spf13/jwalterweatherman v1.1.0 h1:ue6voC5bR5F8YxI5S67j9i582FU4Qvo2bmqnqMYADFk=
github.com/spf13/jwalterweatherman v1.1.0/go.mod h1:aNWZUN0dPAAO/Ljvb5BEdw96iTZ0EXowPYD95IqWIGo=
github.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=
github.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
github.com/spf13/viper v1.15.0 h1:js3yy885G8xwJa6iOISGFwd+qlUo5AvyXb7CiihdtiU=
github.com/spf13/viper v1.15.0/go.mod h1:fFcTBJxvhhzSJiZy8n+PeW6t8l+KeT/uTARa0jHOQLA=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
github.com/stretchr/objx v0.5.2 h1:xuMeJ0Sdp5ZMRXx/aWO6RZxdr3beISkG5/G/aIRr3pY=
github.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=
github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
github.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
github.com/stretchr/testify v1.8.2/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
github.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=
github.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/subosito/gotenv v1.4.2 h1:X1TuBLAMDFbaTAChgCBLu3DU3UPyELpnF2jjJ2cz/S8=
github.com/subosito/gotenv v1.4.2/go.mod h1:ayKnFf/c6rvx/2iiLrJUk1e6plDbT3edrFNGqEflhK0=
github.com/thrawn01/args v0.3.0/go.mod h1:TnRiOFjyh7Wa6oC8ACFPc7KIvbzCiluphA3mJUiPIEo=
github.com/tmc/grpc-websocket-proxy v0.0.0-20201229170055-e5319fda7802 h1:uruHq4dN7GR16kFc5fp3d1RIYzJW5onx8Ybykw2YQFA=
github.com/tmc/grpc-websocket-proxy v0.0.0-20201229170055-e5319fda7802/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=
github.com/topfreegames/go-workers v1.2.1 h1:Jkkir3NngId7XHBP8JxcrqFDR22gLmfzaZlJO0IgCzU=
github.com/topfreegames/go-workers v1.2.1/go.mod h1:Ayopyg9jGJyQ0nEXH8W7iBBBV6rLxwwMKFAdwCD1TSs=
github.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2 h1:eY9dn8+vbi4tKz5Qo6v2eYzo7kUS51QINcR5jNpbZS8=
github.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2/go.mod h1:UETIi67q53MR2AWcXfiuqkDkRtnGDLqkBTpCHuJHxtU=
github.com/yuin/goldmark v1.1.25/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
github.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
github.com/yuin/goldmark v1.1.32/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
github.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
github.com/yuin/goldmark v1.3.5/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1Zlc8k=
go.etcd.io/bbolt v1.3.8 h1:xs88BrvEv273UsB79e0hcVrlUWmS0a8upikMFhSyAtA=
go.etcd.io/bbolt v1.3.8/go.mod h1:N9Mkw9X8x5fupy0IKsmuqVtoGDyxsaDlbk4Rd05IAQw=
go.etcd.io/etcd/api/v3 v3.5.11 h1:B54KwXbWDHyD3XYAwprxNzTe7vlhR69LuBgZnMVvS7E=
go.etcd.io/etcd/api/v3 v3.5.11/go.mod h1:Ot+o0SWSyT6uHhA56al1oCED0JImsRiU9Dc26+C2a+4=
go.etcd.io/etcd/client/pkg/v3 v3.5.11 h1:bT2xVspdiCj2910T0V+/KHcVKjkUrCZVtk8J2JF2z1A=
go.etcd.io/etcd/client/pkg/v3 v3.5.11/go.mod h1:seTzl2d9APP8R5Y2hFL3NVlD6qC/dOT+3kvrqPyTas4=
go.etcd.io/etcd/client/v2 v2.305.11 h1:ZqdKLNJnWpE3bUaaj3XZ5xWyCi+7Vspgk9E0hlIBguE=
go.etcd.io/etcd/client/v2 v2.305.11/go.mod h1:vX2j5tMynwOateY6BfVmLol3gYOIkbhqjs/BqRsdIOw=
go.etcd.io/etcd/client/v3 v3.5.11 h1:ajWtgoNSZJ1gmS8k+icvPtqsqEav+iUorF7b0qozgUU=
go.etcd.io/etcd/client/v3 v3.5.11/go.mod h1:a6xQUEqFJ8vztO1agJh/KQKOMfFI8og52ZconzcDJwE=
go.etcd.io/etcd/pkg/v3 v3.5.11 h1:U5+/mZh+jps8VRWv7+xPiK1tC1hRBOBYdn7zCqtWyOY=
go.etcd.io/etcd/pkg/v3 v3.5.11/go.mod h1:bLfwo6YEgpOAMBZJsZg5AiSS+mxNTRJi15Dvp9kKW68=
go.etcd.io/etcd/raft/v3 v3.5.11 h1:eeimaNIT9DjV4bdLSy4FjLQ/KGSAiG1L5T1nTf5VoZg=
go.etcd.io/etcd/raft/v3 v3.5.11/go.mod h1:Tp7kZJVtWJWLiMCPrgkimiOB5ZYi8YM93onQihpG724=
go.etcd.io/etcd/server/v3 v3.5.11 h1:FEa0ImvoXdIPa81/vZUKpnJ74fpQ5ZivseoIKMPzfpg=
go.etcd.io/etcd/server/v3 v3.5.11/go.mod h1:CS0+TwcuRlhg1I5CpA3YlisOcoqJB1h1GMRgje75uDs=
go.etcd.io/etcd/tests/v3 v3.5.11 h1:2DsRhrCNmlkPtk+zYovCLuEQlLi0hYNRq1bHW11/VFs=
go.etcd.io/etcd/tests/v3 v3.5.11/go.mod h1:XZ38aoIXYjFUDbltGqhZtnMQ6PGWn90sozJ1mZzhrCM=
go.opencensus.io v0.21.0/go.mod h1:mSImk1erAIZhrmZN+AvHh14ztQfjbGwt4TtuofqLduU=
go.opencensus.io v0.22.0/go.mod h1:+kGneAE2xo2IficOXnaByMWTGM9T73dGwxeWcUqIpI8=
go.opencensus.io v0.22.2/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=
go.opencensus.io v0.22.3/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=
go.opencensus.io v0.22.4/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=
go.opencensus.io v0.22.5/go.mod h1:5pWMHQbX5EPX2/62yrJeAkowc+lfs/XD7Uxpq3pI6kk=
go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.49.0 h1:4Pp6oUg3+e/6M4C0A/3kJ2VYa++dsWVTtGgLVj5xtHg=
go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.49.0/go.mod h1:Mjt1i1INqiaoZOMGR1RIUJN+i3ChKoFRqzrRQhlkbs0=
go.opentelemetry.io/otel v1.28.0 h1:/SqNcYk+idO0CxKEUOtKQClMK/MimZihKYMruSMViUo=
go.opentelemetry.io/otel v1.28.0/go.mod h1:q68ijF8Fc8CnMHKyzqL6akLO46ePnjkgfIMIjUIX9z4=
go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.28.0 h1:3Q/xZUyC1BBkualc9ROb4G8qkH90LXEIICcs5zv1OYY=
go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.28.0/go.mod h1:s75jGIWA9OfCMzF0xr+ZgfrB5FEbbV7UuYo32ahUiFI=
go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.28.0 h1:R3X6ZXmNPRR8ul6i3WgFURCHzaXjHdm0karRG/+dj3s=
go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.28.0/go.mod h1:QWFXnDavXWwMx2EEcZsf3yxgEKAqsxQ+Syjp+seyInw=
go.opentelemetry.io/otel/metric v1.28.0 h1:f0HGvSl1KRAU1DLgLGFjrwVyismPlnuU6JD6bOeuA5Q=
go.opentelemetry.io/otel/metric v1.28.0/go.mod h1:Fb1eVBFZmLVTMb6PPohq3TO9IIhUisDsbJoL/+uQW4s=
go.opentelemetry.io/otel/sdk v1.28.0 h1:b9d7hIry8yZsgtbmM0DKyPWMMUMlK9NEKuIG4aBqWyE=
go.opentelemetry.io/otel/sdk v1.28.0/go.mod h1:oYj7ClPUA7Iw3m+r7GeEjz0qckQRJK2B8zjcZEfu7Pg=
go.opentelemetry.io/otel/trace v1.28.0 h1:GhQ9cUuQGmNDd5BTCP2dAvv75RdMxEfTmYejp+lkx9g=
go.opentelemetry.io/otel/trace v1.28.0/go.mod h1:jPyXzNPg6da9+38HEwElrQiHlVMTnVfM3/yv2OlIHaI=
go.opentelemetry.io/proto/otlp v1.3.1 h1:TrMUixzpM0yuc/znrFTP9MMRh8trP93mkCiDVeXrui0=
go.opentelemetry.io/proto/otlp v1.3.1/go.mod h1:0X1WI4de4ZsLrrJNLAQbFeLCm3T7yBkR0XqQ7niQU+8=
go.uber.org/atomic v1.7.0/go.mod h1:fEN4uk6kAWBTFdckzkM89CLk9XfWZrxpCo0nPH17wJc=
go.uber.org/atomic v1.11.0 h1:ZvwS0R+56ePWxUNi+Atn9dWONBPp/AUETXlHW0DxSjE=
go.uber.org/atomic v1.11.0/go.mod h1:LUxbIzbOniOlMKjJjyPfpl4v+PKK2cNJn91OQbhoJI0=
go.uber.org/goleak v1.1.10/go.mod h1:8a7PlsEVH3e/a/GLqe5IIrQx6GzcnRmZEufDUTk4A7A=
go.uber.org/goleak v1.3.0 h1:2K3zAYmnTNqV73imy9J1T3WC+gmCePx2hEGkimedGto=
go.uber.org/goleak v1.3.0/go.mod h1:CoHD4mav9JJNrW/WLlf7HGZPjdw8EucARQHekz1X6bE=
go.uber.org/multierr v1.6.0/go.mod h1:cdWPpRnG4AhwMwsgIHip0KRBQjJy5kYEpYjJxpXp9iU=
go.uber.org/multierr v1.11.0 h1:blXXJkSxSSfBVBlC76pxqeO+LN3aDfLQo+309xJstO0=
go.uber.org/multierr v1.11.0/go.mod h1:20+QtiLqy0Nd6FdQB9TLXag12DsQkrbs3htMFfDN80Y=
go.uber.org/zap v1.18.1/go.mod h1:xg/QME4nWcxGxrpdeYfq7UvYrLh66cuVKdrbD1XF/NI=
go.uber.org/zap v1.24.0 h1:FiJd5l1UOLj0wCgbSE0rwwXHzEdAZS6hiiSnxJN/D60=
go.uber.org/zap v1.24.0/go.mod h1:2kMP+WWQ8aoFoedH3T2sq6iJ2yDWpHbP0f6MQbS9Gkg=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20190510104115-cbcb75029529/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20190605123033-f99c8df09eb5/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/crypto v0.0.0-20210421170649-83a5a9bb288b/go.mod h1:T9bdIzuCu7OtxOm1hfPfRQxPLYneinmdGuTeoZ9dtd4=
golang.org/x/crypto v0.0.0-20220722155217-630584e8d5aa/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=
golang.org/x/crypto v0.45.0 h1:jMBrvKuj23MTlT0bQEOBcAE0mjg8mK9RXFhRH6nyF3Q=
golang.org/x/crypto v0.45.0/go.mod h1:XTGrrkGJve7CYK7J8PEww4aY7gM3qMCElcJQ8n8JdX4=
golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
golang.org/x/exp v0.0.0-20190306152737-a1d7652674e8/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
golang.org/x/exp v0.0.0-20190510132918-efd6b22b2522/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=
golang.org/x/exp v0.0.0-20190829153037-c13cbed26979/go.mod h1:86+5VVa7VpoJ4kLfm080zCjGlMRFzhUhsZKEZO7MGek=
golang.org/x/exp v0.0.0-20191030013958-a1ab85dbe136/go.mod h1:JXzH8nQsPlswgeRAPE3MuO9GYsAcnJvJ4vnMwN/5qkY=
golang.org/x/exp v0.0.0-20191129062945-2f5052295587/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=
golang.org/x/exp v0.0.0-20191227195350-da58074b4299/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=
golang.org/x/exp v0.0.0-20200119233911-0405dc783f0a/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=
golang.org/x/exp v0.0.0-20200207192155-f17229e696bd/go.mod h1:J/WKrq2StrnmMY6+EHIKF9dgMWnmCNThgcyBT1FY9mM=
golang.org/x/exp v0.0.0-20200224162631-6cc2880d07d6/go.mod h1:3jZMyOhIsHpP37uCMkUooju7aAi5cS1Q23tOzKc+0MU=
golang.org/x/image v0.0.0-20190227222117-0694c2d4d067/go.mod h1:kZ7UVZpmo3dzQBMxlp+ypCbDeSB+sBbTgSJuh5dn5js=
golang.org/x/image v0.0.0-20190802002840-cff245a6509b/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=
golang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
golang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=
golang.org/x/lint v0.0.0-20190301231843-5614ed5bae6f/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
golang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/lint v0.0.0-20190409202823-959b441ac422/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/lint v0.0.0-20190909230951-414d861bb4ac/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/lint v0.0.0-20190930215403-16217165b5de/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/lint v0.0.0-20191125180803-fdd1cda4f05f/go.mod h1:5qLYkcX4OjUUV8bRuDixDT3tpyyb+LUpUlRWLxfhWrs=
golang.org/x/lint v0.0.0-20200130185559-910be7a94367/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=
golang.org/x/lint v0.0.0-20200302205851-738671d3881b/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=
golang.org/x/lint v0.0.0-20201208152925-83fdc39ff7b5/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=
golang.org/x/mobile v0.0.0-20190312151609-d3739f865fa6/go.mod h1:z+o9i4GpDbdi3rU15maQ/Ox0txvL9dWGYEHz965HBQE=
golang.org/x/mobile v0.0.0-20190719004257-d2bd2a29d028/go.mod h1:E/iHnbuqvinMTCcRqshq8CkpyQDoeVncDDYHnLhea+o=
golang.org/x/mod v0.0.0-20190513183733-4bf6d317e70e/go.mod h1:mXi4GBBbnImb6dmsKGUJ2LatrhH/nqhxcFungHvyanc=
golang.org/x/mod v0.1.0/go.mod h1:0QHyrYULN0/3qlju5TqG8bIK38QM8yzMo5ekMj3DlcY=
golang.org/x/mod v0.1.1-0.20191105210325-c90efee705ee/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=
golang.org/x/mod v0.1.1-0.20191107180719-034126e5016b/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=
golang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.4.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.4.1/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.29.0 h1:HV8lRxZC4l2cr3Zq1LvtOsi/ThTgWnUk/y64QSs8GwA=
golang.org/x/mod v0.29.0/go.mod h1:NyhrlYXJ2H4eJiRy/WDBO6HMqZQ6q9nk4JzS3NuCK+w=
golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190501004415-9ce7a6920f09/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190503192946-f4e77d36d62c/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190603091049-60506f45cf65/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20190628185345-da137c7871d7/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20190724013045-ca1201d0de80/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20191209160850-c0dbc17a3553/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200114155413-6afb5195e5aa/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200202094626-16171245cfb2/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200222125558-5a598a2470a0/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200301022130-244492dfa37a/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200320220750-118fecf932d8/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200324143707-d3edc9973b7e/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
golang.org/x/net v0.0.0-20200501053045-e0ff5e5a1de5/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
golang.org/x/net v0.0.0-20200506145744-7e3656a0809f/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
golang.org/x/net v0.0.0-20200513185701-a91f0712d120/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
golang.org/x/net v0.0.0-20200520182314-0ba52f642ac2/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
golang.org/x/net v0.0.0-20200625001655-4c5254603344/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=
golang.org/x/net v0.0.0-20200707034311-ab3426394381/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=
golang.org/x/net v0.0.0-20200822124328-c89045814202/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=
golang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
golang.org/x/net v0.0.0-20201031054903-ff519b6c9102/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
golang.org/x/net v0.0.0-20201202161906-c7110b5ffcbb/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
golang.org/x/net v0.0.0-20201209123823-ac852fbbde11/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20201224014010-6772e930b67b/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20210405180319-a5a99cb37ef4/go.mod h1:p54w0d4576C0XHj96bSt6lcn1PtDYWL6XObtHCRCNQM=
golang.org/x/net v0.0.0-20211112202133-69e39bad7dc2/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
golang.org/x/net v0.47.0 h1:Mx+4dIFzqraBXUugkia1OOvlD6LemFo1ALMHjrXDOhY=
golang.org/x/net v0.47.0/go.mod h1:/jNxtkgq5yWUGYkaZGqo27cfGZ1c5Nen03aYrrKpVRU=
golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
golang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
golang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
golang.org/x/oauth2 v0.0.0-20191202225959-858c2ad4c8b6/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
golang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
golang.org/x/oauth2 v0.0.0-20200902213428-5d25da1a8d43/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
golang.org/x/oauth2 v0.0.0-20201109201403-9fd604954f58/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
golang.org/x/oauth2 v0.0.0-20201208152858-08078c50e5b5/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
golang.org/x/oauth2 v0.0.0-20210218202405-ba52d332ba99/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=
golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20200317015054-43a5402ce75a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20200625203802-6e8e738ad208/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20201207232520-09787c993a3a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.18.0 h1:kr88TuHDroi+UVf+0hZnirlk8o8T+4MrK6mr60WkH/I=
golang.org/x/sync v0.18.0/go.mod h1:9KTHXmSnoGruLpwFjVSX0lNNA75CykiMECbovNTZqGI=
golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190312061237-fead79001313/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190422165155-953cdadca894/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190502145724-3ef323f4f1fd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190507160741-ecd444e8653b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190606165138-5da285871e9c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190624142023-c5567b49c5d0/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190726091711-fc99dfbffb4e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191001151750-bb3f8db39f24/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191005200804-aed5e4c7ecf9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191120155948-bd437916bb0e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191204072324-ce4227a45e2e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191228213918-04cbcbbfeed8/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200113162924-86b910548bc1/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200116001909-b77594299b42/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200122134326-e047566fdf82/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200202164722-d101bd2416d5/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200212091648-12a6c2dcc1e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200223170610-d5e6a3e2c0ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200302150141-5c8b2ff67527/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200331124033-c3d80250170d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200501052902-10377860bb8e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200511232937-7e40ca221e25/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200515095857-1151b9dac4a9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200523222454-059865788121/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200803210538-64077c9b5642/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200905004654-be1d3432aa8f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201201145000-ef89a241ccb3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210104204734-6f8348627aad/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210119212857-b64e53b001e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210225134936-a50acf3fe073/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210423185535-09eb48e85fd7/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210510120138-977fb7262007/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20211025201205-69cdffdb9359/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220908164124-27713097b956/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.21.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/sys v0.38.0 h1:3yZWxaJjBmCWXqhN1qh02AkOnCQ1poK6oF+a7xWL6Gc=
golang.org/x/sys v0.38.0/go.mod h1:OgkHotnGiDImocRcuBABYBEXf8A9a87e/uXjp9XT3ks=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.4/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/text v0.31.0 h1:aC8ghyu4JhP8VojJ2lEHBnochRno1sgL6nEi9WGFGMM=
golang.org/x/text v0.31.0/go.mod h1:tKRAlv61yKIjGGHX/4tP1LTbc13YSec1pxVEWXzfoeM=
golang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/time v0.0.0-20191024005414-555d28b269f0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/time v0.14.0 h1:MRx4UaLrDotUKUdCIqzPC48t1Y9hANFKIRpNx+Te8PI=
golang.org/x/time v0.14.0/go.mod h1:eL/Oa2bBBK0TkX57Fyni+NgnyQQN4LitPmob2Hjnqw4=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=
golang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190312151545-0bb0c0a6e846/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190312170243-e65039ee4138/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190328211700-ab21143f2384/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190425150028-36563e24a262/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
golang.org/x/tools v0.0.0-20190506145303-2d16b83fe98c/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
golang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
golang.org/x/tools v0.0.0-20190606124116-d0a3d012864b/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
golang.org/x/tools v0.0.0-20190621195816-6e04913cbbac/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
golang.org/x/tools v0.0.0-20190628153133-6cdbf07be9d0/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
golang.org/x/tools v0.0.0-20190816200558-6889da9d5479/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20190911174233-4f2ddba30aff/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191012152004-8de300cfc20a/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191108193012-7d206e10da11/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191113191852-77e3bb0ad9e7/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191115202509-3a792d9c32b2/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191125144606-a911d9008d1f/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191130070609-6e064ea0cf2d/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191216173652-a0e659d51361/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20191227053925-7b8e75db28f4/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200117161641-43d50277825c/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200122220014-bf1340f18c4a/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200130002326-2f3ba24bd6e7/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200204074204-1cc6d1ef6c74/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200207183749-b753a1ba74fa/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200212150539-ea181f53ac56/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200224181240-023911ca70b2/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200227222343-706bc42d1f0d/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200304193943-95d2e580d8eb/go.mod h1:o4KQGtdN14AW+yjsvvwRTJJuXz8XRtIHtEnmAXLyFUw=
golang.org/x/tools v0.0.0-20200312045724-11d5b4c81c7d/go.mod h1:o4KQGtdN14AW+yjsvvwRTJJuXz8XRtIHtEnmAXLyFUw=
golang.org/x/tools v0.0.0-20200331025713-a30bf2db82d4/go.mod h1:Sl4aGygMT6LrqrWclx+PTx3U+LnKx/seiNR+3G19Ar8=
golang.org/x/tools v0.0.0-20200501065659-ab2804fb9c9d/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
golang.org/x/tools v0.0.0-20200512131952-2bc93b1c0c88/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
golang.org/x/tools v0.0.0-20200515010526-7d3b6ebf133d/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
golang.org/x/tools v0.0.0-20200618134242-20370b0cb4b2/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
golang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
golang.org/x/tools v0.0.0-20200729194436-6467de6f59a7/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=
golang.org/x/tools v0.0.0-20200804011535-6c149bb5ef0d/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=
golang.org/x/tools v0.0.0-20200825202427-b303f430e36d/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=
golang.org/x/tools v0.0.0-20200904185747-39188db58858/go.mod h1:Cj7w3i3Rnn0Xh82ur9kSqwfTHTeVxaDqrfMjpcNT6bE=
golang.org/x/tools v0.0.0-20201110124207-079ba7bd75cd/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.0.0-20201201161351-ac6f37ff4c2a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.0.0-20201208233053-a543418bbed2/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.0.0-20210105154028-b0ab187a4818/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.0.0-20210108195828-e2f9c7f1fc8e/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.1.0/go.mod h1:xkSsbof2nBLbhDlRMhhhyNLN/zl3eTqcnHD5viDpcZ0=
golang.org/x/tools v0.1.1/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=
golang.org/x/tools v0.38.0 h1:Hx2Xv8hISq8Lm16jvBZ2VQf+RLmbd7wVUsALibYI/IQ=
golang.org/x/tools v0.38.0/go.mod h1:yEsQ/d/YK8cjh0L6rZlY8tgtlKiBNTL14pGDJPJpYQs=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
google.golang.org/api v0.4.0/go.mod h1:8k5glujaEP+g9n7WNsDg8QP6cUVNI86fCNMcbazEtwE=
google.golang.org/api v0.7.0/go.mod h1:WtwebWUNSVBH/HAw79HIFXZNqEvBhG+Ra+ax0hx3E3M=
google.golang.org/api v0.8.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=
google.golang.org/api v0.9.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=
google.golang.org/api v0.13.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=
google.golang.org/api v0.14.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=
google.golang.org/api v0.15.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=
google.golang.org/api v0.17.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
google.golang.org/api v0.18.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
google.golang.org/api v0.19.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
google.golang.org/api v0.20.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
google.golang.org/api v0.22.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
google.golang.org/api v0.24.0/go.mod h1:lIXQywCXRcnZPGlsd8NbLnOjtAoL6em04bJ9+z0MncE=
google.golang.org/api v0.28.0/go.mod h1:lIXQywCXRcnZPGlsd8NbLnOjtAoL6em04bJ9+z0MncE=
google.golang.org/api v0.29.0/go.mod h1:Lcubydp8VUV7KeIHD9z2Bys/sm/vGKnG1UHuDBSrHWM=
google.golang.org/api v0.30.0/go.mod h1:QGmEvQ87FHZNiUVJkT14jQNYJ4ZJjdRF23ZXz5138Fc=
google.golang.org/api v0.35.0/go.mod h1:/XrVsuzM0rZmrsbjJutiuftIzeuTQcEeaYcSk/mQ1dg=
google.golang.org/api v0.36.0/go.mod h1:+z5ficQTmoYpPn8LCUNVpK5I7hwkpjbcgqA7I34qYtE=
google.golang.org/api v0.40.0/go.mod h1:fYKFpnQN0DsDSKRVRcQSDQNtqWPfM9i+zNPxepjRCQ8=
google.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=
google.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
google.golang.org/appengine v1.5.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
google.golang.org/appengine v1.6.1/go.mod h1:i06prIuMbXzDqacNJfV5OdTW448YApPu5ww/cMBSeb0=
google.golang.org/appengine v1.6.5/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=
google.golang.org/appengine v1.6.6/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=
google.golang.org/appengine v1.6.7/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=
google.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=
google.golang.org/genproto v0.0.0-20190307195333-5fe7a883aa19/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
google.golang.org/genproto v0.0.0-20190418145605-e7d98fc518a7/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
google.golang.org/genproto v0.0.0-20190425155659-357c62f0e4bb/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
google.golang.org/genproto v0.0.0-20190502173448-54afdca5d873/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
google.golang.org/genproto v0.0.0-20190801165951-fa694d86fc64/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=
google.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=
google.golang.org/genproto v0.0.0-20190911173649-1774047e7e51/go.mod h1:IbNlFCBrqXvoKpeg0TB2l7cyZUmoaFKYIwrEpbDKLA8=
google.golang.org/genproto v0.0.0-20191108220845-16a3f7862a1a/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
google.golang.org/genproto v0.0.0-20191115194625-c23dd37a84c9/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
google.golang.org/genproto v0.0.0-20191216164720-4f79533eabd1/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
google.golang.org/genproto v0.0.0-20191230161307-f3c370f40bfb/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
google.golang.org/genproto v0.0.0-20200115191322-ca5a22157cba/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
google.golang.org/genproto v0.0.0-20200122232147-0452cf42e150/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
google.golang.org/genproto v0.0.0-20200204135345-fa8e72b47b90/go.mod h1:GmwEX6Z4W5gMy59cAlVYjN9JhxgbQH6Gn+gFDQe2lzA=
google.golang.org/genproto v0.0.0-20200212174721-66ed5ce911ce/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200224152610-e50cd9704f63/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200228133532-8c2c7df3a383/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200305110556-506484158171/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200312145019-da6875a35672/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200331122359-1ee6d9798940/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200423170343-7949de9c1215/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200430143042-b979b6f78d84/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200511104702-f5ebc3bea380/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200513103714-09dca8ec2884/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200515170657-fc4c6c6a6587/go.mod h1:YsZOwe1myG/8QRHRsmBRE1LrgQY60beZKjly0O1fX9U=
google.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=
google.golang.org/genproto v0.0.0-20200618031413-b414f8b61790/go.mod h1:jDfRM7FcilCzHH/e9qn6dsT145K34l5v+OpcnNgKAAA=
google.golang.org/genproto v0.0.0-20200729003335-053ba62fc06f/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20200804131852-c06518451d9c/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20200825200019-8632dd797987/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20200904004341-0bd0a958aa1d/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20201109203340-2640f1f9cdfb/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20201201144952-b05cb90ed32e/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20201210142538-e3217bee35cc/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20201214200347-8c77b98c765d/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20210108203827-ffc7fda8c3d7/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20210226172003-ab064af71705/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=
google.golang.org/genproto v0.0.0-20240227224415-6ceb2ff114de h1:F6qOa9AZTYJXOUEr4jDysRDLrm4PHePlge4v4TGAlxY=
google.golang.org/genproto v0.0.0-20240227224415-6ceb2ff114de/go.mod h1:VUhTRKeHn9wwcdrk73nvdC9gF178Tzhmt/qyaFcPLSo=
google.golang.org/genproto/googleapis/api v0.0.0-20240701130421-f6361c86f094 h1:0+ozOGcrp+Y8Aq8TLNN2Aliibms5LEzsq99ZZmAGYm0=
google.golang.org/genproto/googleapis/api v0.0.0-20240701130421-f6361c86f094/go.mod h1:fJ/e3If/Q67Mj99hin0hMhiNyCRmt6BQ2aWIJshUSJw=
google.golang.org/genproto/googleapis/rpc v0.0.0-20240701130421-f6361c86f094 h1:BwIjyKYGsK9dMCBOorzRri8MQwmi7mT9rGHsCEinZkA=
google.golang.org/genproto/googleapis/rpc v0.0.0-20240701130421-f6361c86f094/go.mod h1:Ue6ibwXGpU+dqIcODieyLOcgj7z8+IcskoNIgZxtrFY=
google.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=
google.golang.org/grpc v1.20.1/go.mod h1:10oTOabMzJvdu6/UiuZezV6QK5dSlG84ov/aaiqXj38=
google.golang.org/grpc v1.21.1/go.mod h1:oYelfM1adQP15Ek0mdvEgi9Df8B9CZIaU1084ijfRaM=
google.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=
google.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=
google.golang.org/grpc v1.26.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
google.golang.org/grpc v1.27.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
google.golang.org/grpc v1.27.1/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
google.golang.org/grpc v1.28.0/go.mod h1:rpkK4SK4GF4Ach/+MFLZUBavHOvF2JJB5uozKKal+60=
google.golang.org/grpc v1.29.1/go.mod h1:itym6AZVZYACWQqET3MqgPpjcuV5QH3BxFS3IjizoKk=
google.golang.org/grpc v1.30.0/go.mod h1:N36X2cJ7JwdamYAgDz+s+rVMFjt3numwzf/HckM8pak=
google.golang.org/grpc v1.31.0/go.mod h1:N36X2cJ7JwdamYAgDz+s+rVMFjt3numwzf/HckM8pak=
google.golang.org/grpc v1.31.1/go.mod h1:N36X2cJ7JwdamYAgDz+s+rVMFjt3numwzf/HckM8pak=
google.golang.org/grpc v1.33.1/go.mod h1:fr5YgcSWrqhRRxogOsw7RzIpsmvOZ6IcH4kBYTpR3n0=
google.golang.org/grpc v1.33.2/go.mod h1:JMHMWHQWaTccqQQlmk3MJZS+GWXOdAesneDmEnv2fbc=
google.golang.org/grpc v1.34.0/go.mod h1:WotjhfgOW/POjDeRt8vscBtXq+2VjORFy659qA51WJ8=
google.golang.org/grpc v1.35.0/go.mod h1:qjiiYl8FncCW8feJPdyg3v6XW24KsRHe+dy9BAGRRjU=
google.golang.org/grpc v1.64.1 h1:LKtvyfbX3UGVPFcGqJ9ItpVWW6oN/2XqTxfAnwRRXiA=
google.golang.org/grpc v1.64.1/go.mod h1:hiQF4LFZelK2WKaP6W0L92zGHtiQdZxk8CrSdvyjeP0=
google.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=
google.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=
google.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=
google.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=
google.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=
google.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.24.0/go.mod h1:r/3tXBNzIEhYS9I1OUVjXDlt8tc493IdKGjtUeSXeh4=
google.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=
google.golang.org/protobuf v1.34.2 h1:6xV6lTsCfpGD21XK49h7MhtcApnLqkfYgPcdHftf6hg=
google.golang.org/protobuf v1.34.2/go.mod h1:qYOHts0dSfpeUzUFpOMr/WGzszTmLH+DiWniOlNbLDw=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
gopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=
gopkg.in/fsnotify.v1 v1.4.7/go.mod h1:Tz8NjZHkW78fSQdbUxIjBTcgA1z1m8ZHf0WmKUhAMys=
gopkg.in/ini.v1 v1.55.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=
gopkg.in/ini.v1 v1.67.0 h1:Dgnx+6+nfE+IfzjUEISNeydPJh9AXNNsWbGP9KzCsOA=
gopkg.in/ini.v1 v1.67.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=
gopkg.in/natefinch/lumberjack.v2 v2.0.0 h1:1Lc07Kr7qY4U2YPouBjpCLxpiyxIVoxqXgkXLknAOE8=
gopkg.in/natefinch/lumberjack.v2 v2.0.0/go.mod h1:l0ndWWf7gzL7RNwBG7wST/UCcT4T24xpD6X8LsfU/+k=
gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7/go.mod h1:dt/ZhP58zS4L8KSrWDmTeBkI65Dw0HsyUHuEVlX15mw=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.3/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=
gopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
honnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.0.0-20190106161140-3f1c8253044a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.0.0-20190418001031-e561f6794a2a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.0.1-2019.2.3/go.mod h1:a3bituU0lyd329TUQxRnasdCoJDkEUEAqEt0JzvZhAg=
honnef.co/go/tools v0.0.1-2020.1.3/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=
honnef.co/go/tools v0.0.1-2020.1.4/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=
rsc.io/binaryregexp v0.2.0/go.mod h1:qTv7/COck+e2FymRvadv62gMdZztPaShugOCi3I+8D8=
rsc.io/quote/v3 v3.1.0/go.mod h1:yEA65RcK8LyAZtP9Kv3t0HmxON59tX3rD+tICJqUlj0=
rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=
sigs.k8s.io/yaml v1.3.0 h1:a2VclLzOGrwOHDiV8EfBGhvjHvP46CtW5j6POvhYGGo=
sigs.k8s.io/yaml v1.3.0/go.mod h1:GeOyir5tyXNByN85N/dRIT9es5UQNerPYEKK56eTBm8=

```

`go.work`:

```work
go 1.25.4

use (
	.
	./xk6-pitaya
)

```

`go.work.sum`:

```sum
buf.build/gen/go/gogo/protobuf/protocolbuffers/go v1.31.0-20210810001428-4df00b267f94.1 h1:IpfoSUtXcmtXmL672yCeHx96evE7Z4AyWo8R2lVBU3o=
buf.build/gen/go/gogo/protobuf/protocolbuffers/go v1.31.0-20210810001428-4df00b267f94.1/go.mod h1:Az9fvKFYQGtiDa7cPW9T3Nbw8u3hpmD6wG15RsbQlA0=
buf.build/gen/go/gogo/protobuf/protocolbuffers/go v1.36.10-20240617172848-e1dbca2775a7.1/go.mod h1:3ddKE6u98YQFS1jpuYmVEmU1fdAiHqB5Re6S3E16/mI=
buf.build/gen/go/prometheus/prometheus/protocolbuffers/go v1.31.0-20230627135113-9a12bc2590d2.1 h1:aAMGEehZVBrkvsvQYwE4yNrXRYkSX84eZpRaKPiDuxg=
buf.build/gen/go/prometheus/prometheus/protocolbuffers/go v1.31.0-20230627135113-9a12bc2590d2.1/go.mod h1:iqW5nSujn3ZJ9ISZQX3K/uWwjckAp8hz0J4/wNgFBZo=
buf.build/gen/go/prometheus/prometheus/protocolbuffers/go v1.36.10-20251006115534-cbd485bd5afd.1/go.mod h1:BdURQlk1lXab5ov60A7yLZZONSP0Cho+RkOntf+FZF8=
cel.dev/expr v0.24.0/go.mod h1:hLPLo1W4QUmuYdA72RBX06QTs6MXw941piREPl3Yfiw=
cloud.google.com/go v0.112.0 h1:tpFCD7hpHFlQ8yPwT3x+QeXqc2T6+n6T+hmABHfDUSM=
cloud.google.com/go v0.112.0/go.mod h1:3jEEVwZ/MHU4djK5t5RHuKOA/GbLddgTdVubX1qnPD4=
cloud.google.com/go/accessapproval v1.7.5 h1:uzmAMSgYcnlHa9X9YSQZ4Q1wlfl4NNkZyQgho1Z6p04=
cloud.google.com/go/accessapproval v1.7.5/go.mod h1:g88i1ok5dvQ9XJsxpUInWWvUBrIZhyPDPbk4T01OoJ0=
cloud.google.com/go/accesscontextmanager v1.8.5 h1:2GLNaNu9KRJhJBFTIVRoPwk6xE5mUDgD47abBq4Zp/I=
cloud.google.com/go/accesscontextmanager v1.8.5/go.mod h1:TInEhcZ7V9jptGNqN3EzZ5XMhT6ijWxTGjzyETwmL0Q=
cloud.google.com/go/aiplatform v1.60.0 h1:0cSrii1ZeLr16MbBoocyy5KVnrSdiQ3KN/vtrTe7RqE=
cloud.google.com/go/aiplatform v1.60.0/go.mod h1:eTlGuHOahHprZw3Hio5VKmtThIOak5/qy6pzdsqcQnM=
cloud.google.com/go/analytics v0.23.0 h1:Q+y94XH84jM8SK8O7qiY/PJRexb6n7dRbQ6PiUa4YGM=
cloud.google.com/go/analytics v0.23.0/go.mod h1:YPd7Bvik3WS95KBok2gPXDqQPHy08TsCQG6CdUCb+u0=
cloud.google.com/go/apigateway v1.6.5 h1:sPXnpk+6TneKIrjCjcpX5YGsAKy3PTdpIchoj8/74OE=
cloud.google.com/go/apigateway v1.6.5/go.mod h1:6wCwvYRckRQogyDDltpANi3zsCDl6kWi0b4Je+w2UiI=
cloud.google.com/go/apigeeconnect v1.6.5 h1:CrfIKv9Go3fh/QfQgisU3MeP90Ww7l/sVGmr3TpECo8=
cloud.google.com/go/apigeeconnect v1.6.5/go.mod h1:MEKm3AiT7s11PqTfKE3KZluZA9O91FNysvd3E6SJ6Ow=
cloud.google.com/go/apigeeregistry v0.8.3 h1:C+QU2K+DzDjk4g074ouwHQGkoff1h5OMQp6sblCVreQ=
cloud.google.com/go/apigeeregistry v0.8.3/go.mod h1:aInOWnqF4yMQx8kTjDqHNXjZGh/mxeNlAf52YqtASUs=
cloud.google.com/go/appengine v1.8.5 h1:l2SviT44zWQiOv8bPoMBzW0vOcMO22iO0s+nVtVhdts=
cloud.google.com/go/appengine v1.8.5/go.mod h1:uHBgNoGLTS5di7BvU25NFDuKa82v0qQLjyMJLuPQrVo=
cloud.google.com/go/area120 v0.8.5 h1:vTs08KPLN/iMzTbxpu5ciL06KcsrVPMjz4IwcQyZ4uY=
cloud.google.com/go/area120 v0.8.5/go.mod h1:BcoFCbDLZjsfe4EkCnEq1LKvHSK0Ew/zk5UFu6GMyA0=
cloud.google.com/go/artifactregistry v1.14.7 h1:W9sVlyb1VRcUf83w7aM3yMsnp4HS4PoyGqYQNG0O5lI=
cloud.google.com/go/artifactregistry v1.14.7/go.mod h1:0AUKhzWQzfmeTvT4SjfI4zjot72EMfrkvL9g9aRjnnM=
cloud.google.com/go/asset v1.17.2 h1:xgFnBP3luSbUcC9RWJvb3Zkt+y/wW6PKwPHr3ssnIP8=
cloud.google.com/go/asset v1.17.2/go.mod h1:SVbzde67ehddSoKf5uebOD1sYw8Ab/jD/9EIeWg99q4=
cloud.google.com/go/assuredworkloads v1.11.5 h1:gCrN3IyvqY3cP0wh2h43d99CgH3G+WYs9CeuFVKChR8=
cloud.google.com/go/assuredworkloads v1.11.5/go.mod h1:FKJ3g3ZvkL2D7qtqIGnDufFkHxwIpNM9vtmhvt+6wqk=
cloud.google.com/go/automl v1.13.5 h1:ijiJy9sYWh75WrqImXsfWc1e3HR3iO+ef9fvW03Ig/4=
cloud.google.com/go/automl v1.13.5/go.mod h1:MDw3vLem3yh+SvmSgeYUmUKqyls6NzSumDm9OJ3xJ1Y=
cloud.google.com/go/baremetalsolution v1.2.4 h1:LFydisRmS7hQk9P/YhekwuZGqb45TW4QavcrMToWo5A=
cloud.google.com/go/baremetalsolution v1.2.4/go.mod h1:BHCmxgpevw9IEryE99HbYEfxXkAEA3hkMJbYYsHtIuY=
cloud.google.com/go/batch v1.8.0 h1:2HK4JerwVaIcCh/lJiHwh6+uswPthiMMWhiSWLELayk=
cloud.google.com/go/batch v1.8.0/go.mod h1:k8V7f6VE2Suc0zUM4WtoibNrA6D3dqBpB+++e3vSGYc=
cloud.google.com/go/beyondcorp v1.0.4 h1:qs0J0O9Ol2h1yA0AU+r7l3hOCPzs2MjE1d6d/kaHIKo=
cloud.google.com/go/beyondcorp v1.0.4/go.mod h1:Gx8/Rk2MxrvWfn4WIhHIG1NV7IBfg14pTKv1+EArVcc=
cloud.google.com/go/bigquery v1.59.1 h1:CpT+/njKuKT3CEmswm6IbhNu9u35zt5dO4yPDLW+nG4=
cloud.google.com/go/bigquery v1.59.1/go.mod h1:VP1UJYgevyTwsV7desjzNzDND5p6hZB+Z8gZJN1GQUc=
cloud.google.com/go/billing v1.18.2 h1:oWUEQvuC4JvtnqLZ35zgzdbuHt4Itbftvzbe6aEyFdE=
cloud.google.com/go/billing v1.18.2/go.mod h1:PPIwVsOOQ7xzbADCwNe8nvK776QpfrOAUkvKjCUcpSE=
cloud.google.com/go/binaryauthorization v1.8.1 h1:1jcyh2uIUwSZkJ/JmL8kd5SUkL/Krbv8zmYLEbAz6kY=
cloud.google.com/go/binaryauthorization v1.8.1/go.mod h1:1HVRyBerREA/nhI7yLang4Zn7vfNVA3okoAR9qYQJAQ=
cloud.google.com/go/certificatemanager v1.7.5 h1:UMBr/twXvH3jcT5J5/YjRxf2tvwTYIfrpemTebe0txc=
cloud.google.com/go/certificatemanager v1.7.5/go.mod h1:uX+v7kWqy0Y3NG/ZhNvffh0kuqkKZIXdvlZRO7z0VtM=
cloud.google.com/go/channel v1.17.5 h1:/omiBnyFjm4S1ETHoOmJbL7LH7Ljcei4rYG6Sj3hc80=
cloud.google.com/go/channel v1.17.5/go.mod h1:FlpaOSINDAXgEext0KMaBq/vwpLMkkPAw9b2mApQeHc=
cloud.google.com/go/cloudbuild v1.15.1 h1:ZB6oOmJo+MTov9n629fiCrO9YZPOg25FZvQ7gIHu5ng=
cloud.google.com/go/cloudbuild v1.15.1/go.mod h1:gIofXZSu+XD2Uy+qkOrGKEx45zd7s28u/k8f99qKals=
cloud.google.com/go/clouddms v1.7.4 h1:Sr0Zo5EAcPQiCBgHWICg3VGkcdS/LLP1d9SR7qQBM/s=
cloud.google.com/go/clouddms v1.7.4/go.mod h1:RdrVqoFG9RWI5AvZ81SxJ/xvxPdtcRhFotwdE79DieY=
cloud.google.com/go/cloudtasks v1.12.6 h1:EUt1hIZ9bLv8Iz9yWaCrqgMnIU+Tdh0yXM1MMVGhjfE=
cloud.google.com/go/cloudtasks v1.12.6/go.mod h1:b7c7fe4+TJsFZfDyzO51F7cjq7HLUlRi/KZQLQjDsaY=
cloud.google.com/go/compute v1.25.1 h1:ZRpHJedLtTpKgr3RV1Fx23NuaAEN1Zfx9hw1u4aJdjU=
cloud.google.com/go/compute v1.25.1/go.mod h1:oopOIR53ly6viBYxaDhBfJwzUAxf1zE//uf3IB011ls=
cloud.google.com/go/compute/metadata v0.2.3 h1:mg4jlk7mCAj6xXp9UJ4fjI9VUI5rubuGBW5aJ7UnBMY=
cloud.google.com/go/compute/metadata v0.2.3/go.mod h1:VAV5nSsACxMJvgaAuX6Pk2AawlZn8kiOGuCv6gTkwuA=
cloud.google.com/go/compute/metadata v0.3.0/go.mod h1:zFmK7XCadkQkj6TtorcaGlCW1hT1fIilQDwofLpJ20k=
cloud.google.com/go/compute/metadata v0.9.0/go.mod h1:E0bWwX5wTnLPedCKqk3pJmVgCBSM6qQI1yTBdEb3C10=
cloud.google.com/go/contactcenterinsights v1.13.0 h1:6Vs/YnDG5STGjlWMEjN/xtmft7MrOTOnOZYUZtGTx0w=
cloud.google.com/go/contactcenterinsights v1.13.0/go.mod h1:ieq5d5EtHsu8vhe2y3amtZ+BE+AQwX5qAy7cpo0POsI=
cloud.google.com/go/container v1.31.0 h1:MAaNH7VRNPWEhvqOypq2j+7ONJKrKzon4v9nS3nLZe0=
cloud.google.com/go/container v1.31.0/go.mod h1:7yABn5s3Iv3lmw7oMmyGbeV6tQj86njcTijkkGuvdZA=
cloud.google.com/go/containeranalysis v0.11.4 h1:doJ0M1ljS4hS0D2UbHywlHGwB7sQLNrt9vFk9Zyi7vY=
cloud.google.com/go/containeranalysis v0.11.4/go.mod h1:cVZT7rXYBS9NG1rhQbWL9pWbXCKHWJPYraE8/FTSYPE=
cloud.google.com/go/datacatalog v1.19.3 h1:A0vKYCQdxQuV4Pi0LL9p39Vwvg4jH5yYveMv50gU5Tw=
cloud.google.com/go/datacatalog v1.19.3/go.mod h1:ra8V3UAsciBpJKQ+z9Whkxzxv7jmQg1hfODr3N3YPJ4=
cloud.google.com/go/dataflow v0.9.5 h1:RYHtcPhmE664+F0Je46p+NvFbG8z//KCXp+uEqB4jZU=
cloud.google.com/go/dataflow v0.9.5/go.mod h1:udl6oi8pfUHnL0z6UN9Lf9chGqzDMVqcYTcZ1aPnCZQ=
cloud.google.com/go/dataform v0.9.2 h1:5e4eqGrd0iDTCg4Q+VlAao5j2naKAA7xRurNtwmUknU=
cloud.google.com/go/dataform v0.9.2/go.mod h1:S8cQUwPNWXo7m/g3DhWHsLBoufRNn9EgFrMgne2j7cI=
cloud.google.com/go/datafusion v1.7.5 h1:HQ/BUOP8OIGJxuztpYvNvlb+/U+/Bfs9SO8tQbh61fk=
cloud.google.com/go/datafusion v1.7.5/go.mod h1:bYH53Oa5UiqahfbNK9YuYKteeD4RbQSNMx7JF7peGHc=
cloud.google.com/go/datalabeling v0.8.5 h1:GpIFRdm0qIZNsxqURFJwHt0ZBJZ0nF/mUVEigR7PH/8=
cloud.google.com/go/datalabeling v0.8.5/go.mod h1:IABB2lxQnkdUbMnQaOl2prCOfms20mcPxDBm36lps+s=
cloud.google.com/go/dataplex v1.14.2 h1:fxIfdU8fxzR3clhOoNI7XFppvAmndxDu1AMH+qX9WKQ=
cloud.google.com/go/dataplex v1.14.2/go.mod h1:0oGOSFlEKef1cQeAHXy4GZPB/Ife0fz/PxBf+ZymA2U=
cloud.google.com/go/dataproc/v2 v2.4.0 h1:/u81Fd+BvCLp+xjctI1DiWVJn6cn9/s3Akc8xPH02yk=
cloud.google.com/go/dataproc/v2 v2.4.0/go.mod h1:3B1Ht2aRB8VZIteGxQS/iNSJGzt9+CA0WGnDVMEm7Z4=
cloud.google.com/go/dataqna v0.8.5 h1:9ybXs3nr9BzxSGC04SsvtuXaHY0qmJSLIpIAbZo9GqQ=
cloud.google.com/go/dataqna v0.8.5/go.mod h1:vgihg1mz6n7pb5q2YJF7KlXve6tCglInd6XO0JGOlWM=
cloud.google.com/go/datastore v1.15.0 h1:0P9WcsQeTWjuD1H14JIY7XQscIPQ4Laje8ti96IC5vg=
cloud.google.com/go/datastore v1.15.0/go.mod h1:GAeStMBIt9bPS7jMJA85kgkpsMkvseWWXiaHya9Jes8=
cloud.google.com/go/datastream v1.10.4 h1:o1QDKMo/hk0FN7vhoUQURREuA0rgKmnYapB+1M+7Qz4=
cloud.google.com/go/datastream v1.10.4/go.mod h1:7kRxPdxZxhPg3MFeCSulmAJnil8NJGGvSNdn4p1sRZo=
cloud.google.com/go/deploy v1.17.1 h1:m27Ojwj03gvpJqCbodLYiVmE9x4/LrHGGMjzc0LBfM4=
cloud.google.com/go/deploy v1.17.1/go.mod h1:SXQyfsXrk0fBmgBHRzBjQbZhMfKZ3hMQBw5ym7MN/50=
cloud.google.com/go/dialogflow v1.49.0 h1:KqG0oxGE71qo0lRVyAoeBozefCvsMfcDzDjoLYSY0F4=
cloud.google.com/go/dialogflow v1.49.0/go.mod h1:dhVrXKETtdPlpPhE7+2/k4Z8FRNUp6kMV3EW3oz/fe0=
cloud.google.com/go/dlp v1.11.2 h1:lTipOuJaSjlYnnotPMbEhKURLC6GzCMDDzVbJAEbmYM=
cloud.google.com/go/dlp v1.11.2/go.mod h1:9Czi+8Y/FegpWzgSfkRlyz+jwW6Te9Rv26P3UfU/h/w=
cloud.google.com/go/documentai v1.25.0 h1:lI62GMEEPO6vXJI9hj+G9WjOvnR0hEjvjokrnex4cxA=
cloud.google.com/go/documentai v1.25.0/go.mod h1:ftLnzw5VcXkLItp6pw1mFic91tMRyfv6hHEY5br4KzY=
cloud.google.com/go/domains v0.9.5 h1:Mml/R6s3vQQvFPpi/9oX3O5dRirgjyJ8cksK8N19Y7g=
cloud.google.com/go/domains v0.9.5/go.mod h1:dBzlxgepazdFhvG7u23XMhmMKBjrkoUNaw0A8AQB55Y=
cloud.google.com/go/edgecontainer v1.1.5 h1:tBY32km78ScpK2aOP84JoW/+wtpx5WluyPUSEE3270U=
cloud.google.com/go/edgecontainer v1.1.5/go.mod h1:rgcjrba3DEDEQAidT4yuzaKWTbkTI5zAMu3yy6ZWS0M=
cloud.google.com/go/errorreporting v0.3.0 h1:kj1XEWMu8P0qlLhm3FwcaFsUvXChV/OraZwA70trRR0=
cloud.google.com/go/errorreporting v0.3.0/go.mod h1:xsP2yaAp+OAW4OIm60An2bbLpqIhKXdWR/tawvl7QzU=
cloud.google.com/go/essentialcontacts v1.6.6 h1:13eHn5qBnsawxI7mIrv4jRIEmQ1xg0Ztqw5ZGqtUNfA=
cloud.google.com/go/essentialcontacts v1.6.6/go.mod h1:XbqHJGaiH0v2UvtuucfOzFXN+rpL/aU5BCZLn4DYl1Q=
cloud.google.com/go/eventarc v1.13.4 h1:ORkd6/UV5FIdA8KZQDLNZYKS7BBOrj0p01DXPmT4tE4=
cloud.google.com/go/eventarc v1.13.4/go.mod h1:zV5sFVoAa9orc/52Q+OuYUG9xL2IIZTbbuTHC6JSY8s=
cloud.google.com/go/filestore v1.8.1 h1:X5G4y/vrUo1B8Nsz93qSWTMAcM8LXbGUldq33OdcdCw=
cloud.google.com/go/filestore v1.8.1/go.mod h1:MbN9KcaM47DRTIuLfQhJEsjaocVebNtNQhSLhKCF5GM=
cloud.google.com/go/firestore v1.14.0 h1:8aLcKnMPoldYU3YHgu4t2exrKhLQkqaXAGqT0ljrFVw=
cloud.google.com/go/firestore v1.14.0/go.mod h1:96MVaHLsEhbvkBEdZgfN+AS/GIkco1LRpH9Xp9YZfzQ=
cloud.google.com/go/functions v1.16.0 h1:IWVylmK5F6hJ3R5zaRW7jI5PrWhCvtBVU4axQLmXSo4=
cloud.google.com/go/functions v1.16.0/go.mod h1:nbNpfAG7SG7Duw/o1iZ6ohvL7mc6MapWQVpqtM29n8k=
cloud.google.com/go/gkebackup v1.3.5 h1:iuE8KNtTsPOc79qeWoNS8zOWoXPD9SAdOmwgxtlCmh8=
cloud.google.com/go/gkebackup v1.3.5/go.mod h1:KJ77KkNN7Wm1LdMopOelV6OodM01pMuK2/5Zt1t4Tvc=
cloud.google.com/go/gkeconnect v0.8.5 h1:17d+ZSSXKqG/RwZCq3oFMIWLPI8Zw3b8+a9/BEVlwH0=
cloud.google.com/go/gkeconnect v0.8.5/go.mod h1:LC/rS7+CuJ5fgIbXv8tCD/mdfnlAadTaUufgOkmijuk=
cloud.google.com/go/gkehub v0.14.5 h1:RboLNFzf9wEMSo7DrKVBlf+YhK/A/jrLN454L5Tz99Q=
cloud.google.com/go/gkehub v0.14.5/go.mod h1:6bzqxM+a+vEH/h8W8ec4OJl4r36laxTs3A/fMNHJ0wA=
cloud.google.com/go/gkemulticloud v1.1.1 h1:rsSZAGLhyjyE/bE2ToT5fqo1qSW7S+Ubsc9jFOcbhSI=
cloud.google.com/go/gkemulticloud v1.1.1/go.mod h1:C+a4vcHlWeEIf45IB5FFR5XGjTeYhF83+AYIpTy4i2Q=
cloud.google.com/go/gsuiteaddons v1.6.5 h1:CZEbaBwmbYdhFw21Fwbo+C35HMe36fTE0FBSR4KSfWg=
cloud.google.com/go/gsuiteaddons v1.6.5/go.mod h1:Lo4P2IvO8uZ9W+RaC6s1JVxo42vgy+TX5a6hfBZ0ubs=
cloud.google.com/go/iam v1.1.6 h1:bEa06k05IO4f4uJonbB5iAgKTPpABy1ayxaIZV/GHVc=
cloud.google.com/go/iam v1.1.6/go.mod h1:O0zxdPeGBoFdWW3HWmBxJsk0pfvNM/p/qa82rWOGTwI=
cloud.google.com/go/iap v1.9.4 h1:94zirc2r4t6KzhAMW0R6Dme005eTP6yf7g6vN4IhRrA=
cloud.google.com/go/iap v1.9.4/go.mod h1:vO4mSq0xNf/Pu6E5paORLASBwEmphXEjgCFg7aeNu1w=
cloud.google.com/go/ids v1.4.5 h1:xd4U7pgl3GHV+MABnv1BF4/Vy/zBF7CYC8XngkOLzag=
cloud.google.com/go/ids v1.4.5/go.mod h1:p0ZnyzjMWxww6d2DvMGnFwCsSxDJM666Iir1bK1UuBo=
cloud.google.com/go/iot v1.7.5 h1:munTeBlbqI33iuTYgXy7S8lW2TCgi5l1hA4roSIY+EE=
cloud.google.com/go/iot v1.7.5/go.mod h1:nq3/sqTz3HGaWJi1xNiX7F41ThOzpud67vwk0YsSsqs=
cloud.google.com/go/kms v1.15.7 h1:7caV9K3yIxvlQPAcaFffhlT7d1qpxjB1wHBtjWa13SM=
cloud.google.com/go/kms v1.15.7/go.mod h1:ub54lbsa6tDkUwnu4W7Yt1aAIFLnspgh0kPGToDukeI=
cloud.google.com/go/language v1.12.3 h1:iaJZg6K4j/2PvZZVcjeO/btcWWIllVRBhuTFjGO4LXs=
cloud.google.com/go/language v1.12.3/go.mod h1:evFX9wECX6mksEva8RbRnr/4wi/vKGYnAJrTRXU8+f8=
cloud.google.com/go/lifesciences v0.9.5 h1:gXvN70m2p+4zgJFzaz6gMKaxTuF9WJ0USYoMLWAOm8g=
cloud.google.com/go/lifesciences v0.9.5/go.mod h1:OdBm0n7C0Osh5yZB7j9BXyrMnTRGBJIZonUMxo5CzPw=
cloud.google.com/go/logging v1.9.0 h1:iEIOXFO9EmSiTjDmfpbRjOxECO7R8C7b8IXUGOj7xZw=
cloud.google.com/go/logging v1.9.0/go.mod h1:1Io0vnZv4onoUnsVUQY3HZ3Igb1nBchky0A0y7BBBhE=
cloud.google.com/go/longrunning v0.5.5 h1:GOE6pZFdSrTb4KAiKnXsJBtlE6mEyaW44oKyMILWnOg=
cloud.google.com/go/longrunning v0.5.5/go.mod h1:WV2LAxD8/rg5Z1cNW6FJ/ZpX4E4VnDnoTk0yawPBB7s=
cloud.google.com/go/managedidentities v1.6.5 h1:+bpih1piZVLxla/XBqeSUzJBp8gv9plGHIMAI7DLpDM=
cloud.google.com/go/managedidentities v1.6.5/go.mod h1:fkFI2PwwyRQbjLxlm5bQ8SjtObFMW3ChBGNqaMcgZjI=
cloud.google.com/go/maps v1.6.4 h1:EVCZAiDvog9So46460BGbCasPhi613exoaQbpilMVlk=
cloud.google.com/go/maps v1.6.4/go.mod h1:rhjqRy8NWmDJ53saCfsXQ0LKwBHfi6OSh5wkq6BaMhI=
cloud.google.com/go/mediatranslation v0.8.5 h1:c76KdIXljQHSCb/Cy47S8H4s05A4zbK3pAFGzwcczZo=
cloud.google.com/go/mediatranslation v0.8.5/go.mod h1:y7kTHYIPCIfgyLbKncgqouXJtLsU+26hZhHEEy80fSs=
cloud.google.com/go/memcache v1.10.5 h1:yeDv5qxRedFosvpMSEswrqUsJM5OdWvssPHFliNFTc4=
cloud.google.com/go/memcache v1.10.5/go.mod h1:/FcblbNd0FdMsx4natdj+2GWzTq+cjZvMa1I+9QsuMA=
cloud.google.com/go/metastore v1.13.4 h1:dR7vqWXlK6IYR8Wbu9mdFfwlVjodIBhd1JRrpZftTEg=
cloud.google.com/go/metastore v1.13.4/go.mod h1:FMv9bvPInEfX9Ac1cVcRXp8EBBQnBcqH6gz3KvJ9BAE=
cloud.google.com/go/monitoring v1.18.0 h1:NfkDLQDG2UR3WYZVQE8kwSbUIEyIqJUPl+aOQdFH1T4=
cloud.google.com/go/monitoring v1.18.0/go.mod h1:c92vVBCeq/OB4Ioyo+NbN2U7tlg5ZH41PZcdvfc+Lcg=
cloud.google.com/go/networkconnectivity v1.14.4 h1:GBfXFhLyPspnaBE3nI/BRjdhW8vcbpT9QjE/4kDCDdc=
cloud.google.com/go/networkconnectivity v1.14.4/go.mod h1:PU12q++/IMnDJAB+3r+tJtuCXCfwfN+C6Niyj6ji1Po=
cloud.google.com/go/networkmanagement v1.9.4 h1:aLV5GcosBNmd6M8+a0ekB0XlLRexv4fvnJJrYnqeBcg=
cloud.google.com/go/networkmanagement v1.9.4/go.mod h1:daWJAl0KTFytFL7ar33I6R/oNBH8eEOX/rBNHrC/8TA=
cloud.google.com/go/networksecurity v0.9.5 h1:+caSxBTj0E8OYVh/5wElFdjEMO1S/rZtE1152Cepchc=
cloud.google.com/go/networksecurity v0.9.5/go.mod h1:KNkjH/RsylSGyyZ8wXpue8xpCEK+bTtvof8SBfIhMG8=
cloud.google.com/go/notebooks v1.11.3 h1:FH48boYmrWVQ6k0Mx/WrnNafXncT5iSYxA8CNyWTgy0=
cloud.google.com/go/notebooks v1.11.3/go.mod h1:0wQyI2dQC3AZyQqWnRsp+yA+kY4gC7ZIVP4Qg3AQcgo=
cloud.google.com/go/optimization v1.6.3 h1:63NZaWyN+5rZEKHPX4ACpw3BjgyeuY8+rCehiCMaGPY=
cloud.google.com/go/optimization v1.6.3/go.mod h1:8ve3svp3W6NFcAEFr4SfJxrldzhUl4VMUJmhrqVKtYA=
cloud.google.com/go/orchestration v1.8.5 h1:YHgWMlrPttIVGItgGfuvO2KM7x+y9ivN/Yk92pMm1a4=
cloud.google.com/go/orchestration v1.8.5/go.mod h1:C1J7HesE96Ba8/hZ71ISTV2UAat0bwN+pi85ky38Yq8=
cloud.google.com/go/orgpolicy v1.12.1 h1:2JbXigqBJVp8Dx5dONUttFqewu4fP0p3pgOdIZAhpYU=
cloud.google.com/go/orgpolicy v1.12.1/go.mod h1:aibX78RDl5pcK3jA8ysDQCFkVxLj3aOQqrbBaUL2V5I=
cloud.google.com/go/osconfig v1.12.5 h1:Mo5jGAxOMKH/PmDY7fgY19yFcVbvwREb5D5zMPQjFfo=
cloud.google.com/go/osconfig v1.12.5/go.mod h1:D9QFdxzfjgw3h/+ZaAb5NypM8bhOMqBzgmbhzWViiW8=
cloud.google.com/go/oslogin v1.13.1 h1:1K4nOT5VEZNt7XkhaTXupBYos5HjzvJMfhvyD2wWdFs=
cloud.google.com/go/oslogin v1.13.1/go.mod h1:vS8Sr/jR7QvPWpCjNqy6LYZr5Zs1e8ZGW/KPn9gmhws=
cloud.google.com/go/phishingprotection v0.8.5 h1:DH3WFLzEoJdW/6xgsmoDqOwT1xddFi7gKu0QGZQhpGU=
cloud.google.com/go/phishingprotection v0.8.5/go.mod h1:g1smd68F7mF1hgQPuYn3z8HDbNre8L6Z0b7XMYFmX7I=
cloud.google.com/go/policytroubleshooter v1.10.3 h1:c0WOzC6hz964QWNBkyKfna8A2jOIx1zzZa43Gx/P09o=
cloud.google.com/go/policytroubleshooter v1.10.3/go.mod h1:+ZqG3agHT7WPb4EBIRqUv4OyIwRTZvsVDHZ8GlZaoxk=
cloud.google.com/go/privatecatalog v0.9.5 h1:UZ0assTnATXSggoxUIh61RjTQ4P9zCMk/kEMbn0nMYA=
cloud.google.com/go/privatecatalog v0.9.5/go.mod h1:fVWeBOVe7uj2n3kWRGlUQqR/pOd450J9yZoOECcQqJk=
cloud.google.com/go/pubsub v1.36.1 h1:dfEPuGCHGbWUhaMCTHUFjfroILEkx55iUmKBZTP5f+Y=
cloud.google.com/go/pubsub v1.36.1/go.mod h1:iYjCa9EzWOoBiTdd4ps7QoMtMln5NwaZQpK1hbRfBDE=
cloud.google.com/go/pubsublite v1.8.1 h1:pX+idpWMIH30/K7c0epN6V703xpIcMXWRjKJsz0tYGY=
cloud.google.com/go/pubsublite v1.8.1/go.mod h1:fOLdU4f5xldK4RGJrBMm+J7zMWNj/k4PxwEZXy39QS0=
cloud.google.com/go/recaptchaenterprise/v2 v2.9.2 h1:U3Wfq12X9cVMuTpsWDSURnXF0Z9hSPTHj+xsnXDRLsw=
cloud.google.com/go/recaptchaenterprise/v2 v2.9.2/go.mod h1:trwwGkfhCmp05Ll5MSJPXY7yvnO0p4v3orGANAFHAuU=
cloud.google.com/go/recommendationengine v0.8.5 h1:ineqLswaCSBY0csYv5/wuXJMBlxATK6Xc5jJkpiTEdM=
cloud.google.com/go/recommendationengine v0.8.5/go.mod h1:A38rIXHGFvoPvmy6pZLozr0g59NRNREz4cx7F58HAsQ=
cloud.google.com/go/recommender v1.12.1 h1:LVLYS3r3u0MSCxQSDUtLSkporEGi9OAE6hGvayrZNPs=
cloud.google.com/go/recommender v1.12.1/go.mod h1:gf95SInWNND5aPas3yjwl0I572dtudMhMIG4ni8nr+0=
cloud.google.com/go/redis v1.14.2 h1:QF0maEdVv0Fj/2roU8sX3NpiDBzP9ICYTO+5F32gQNo=
cloud.google.com/go/redis v1.14.2/go.mod h1:g0Lu7RRRz46ENdFKQ2EcQZBAJ2PtJHJLuiiRuEXwyQw=
cloud.google.com/go/resourcemanager v1.9.5 h1:AZWr1vWVDKGwfLsVhcN+vcwOz3xqqYxtmMa0aABCMms=
cloud.google.com/go/resourcemanager v1.9.5/go.mod h1:hep6KjelHA+ToEjOfO3garMKi/CLYwTqeAw7YiEI9x8=
cloud.google.com/go/resourcesettings v1.6.5 h1:BTr5MVykJwClASci/7Og4Qfx70aQ4n3epsNLj94ZYgw=
cloud.google.com/go/resourcesettings v1.6.5/go.mod h1:WBOIWZraXZOGAgoR4ukNj0o0HiSMO62H9RpFi9WjP9I=
cloud.google.com/go/retail v1.16.0 h1:Fn1GuAua1c6crCGqfJ1qMxG1Xh10Tg/x5EUODEHMqkw=
cloud.google.com/go/retail v1.16.0/go.mod h1:LW7tllVveZo4ReWt68VnldZFWJRzsh9np+01J9dYWzE=
cloud.google.com/go/run v1.3.4 h1:m9WDA7DzTpczhZggwYlZcBWgCRb+kgSIisWn1sbw2rQ=
cloud.google.com/go/run v1.3.4/go.mod h1:FGieuZvQ3tj1e9GnzXqrMABSuir38AJg5xhiYq+SF3o=
cloud.google.com/go/scheduler v1.10.6 h1:5U8iXLoQ03qOB+ZXlAecU7fiE33+u3QiM9nh4cd0eTE=
cloud.google.com/go/scheduler v1.10.6/go.mod h1:pe2pNCtJ+R01E06XCDOJs1XvAMbv28ZsQEbqknxGOuE=
cloud.google.com/go/secretmanager v1.11.5 h1:82fpF5vBBvu9XW4qj0FU2C6qVMtj1RM/XHwKXUEAfYY=
cloud.google.com/go/secretmanager v1.11.5/go.mod h1:eAGv+DaCHkeVyQi0BeXgAHOU0RdrMeZIASKc+S7VqH4=
cloud.google.com/go/security v1.15.5 h1:wTKJQ10j8EYgvE8Y+KhovxDRVDk2iv/OsxZ6GrLP3kE=
cloud.google.com/go/security v1.15.5/go.mod h1:KS6X2eG3ynWjqcIX976fuToN5juVkF6Ra6c7MPnldtc=
cloud.google.com/go/securitycenter v1.24.4 h1:/5jjkZ+uGe8hZ7pvd7pO30VW/a+pT2MrrdgOqjyucKQ=
cloud.google.com/go/securitycenter v1.24.4/go.mod h1:PSccin+o1EMYKcFQzz9HMMnZ2r9+7jbc+LvPjXhpwcU=
cloud.google.com/go/servicedirectory v1.11.4 h1:da7HFI1229kyzIyuVEzHXip0cw0d+E0s8mjQby0WN+k=
cloud.google.com/go/servicedirectory v1.11.4/go.mod h1:Bz2T9t+/Ehg6x+Y7Ycq5xiShYLD96NfEsWNHyitj1qM=
cloud.google.com/go/shell v1.7.5 h1:3Fq2hzO0ZSyaqBboJrFkwwf/qMufDtqwwA6ep8EZxEI=
cloud.google.com/go/shell v1.7.5/go.mod h1:hL2++7F47/IfpfTO53KYf1EC+F56k3ThfNEXd4zcuiE=
cloud.google.com/go/spanner v1.57.0 h1:fJq+ZfQUDHE+cy1li0bJA8+sy2oiSGhuGqN5nqVaZdU=
cloud.google.com/go/spanner v1.57.0/go.mod h1:aXQ5QDdhPRIqVhYmnkAdwPYvj/DRN0FguclhEWw+jOo=
cloud.google.com/go/speech v1.21.1 h1:nuFc+Kj5B8de75nN4FdPyUbI2SiBoHZG6BLurXL56Q0=
cloud.google.com/go/speech v1.21.1/go.mod h1:E5GHZXYQlkqWQwY5xRSLHw2ci5NMQNG52FfMU1aZrIA=
cloud.google.com/go/storage v1.14.0 h1:6RRlFMv1omScs6iq2hfE3IvgE+l6RfJPampq8UZc5TU=
cloud.google.com/go/storagetransfer v1.10.4 h1:dy4fL3wO0VABvzM05ycMUPFHxTPbJz9Em8ikAJVqSbI=
cloud.google.com/go/storagetransfer v1.10.4/go.mod h1:vef30rZKu5HSEf/x1tK3WfWrL0XVoUQN/EPDRGPzjZs=
cloud.google.com/go/talent v1.6.6 h1:JssV0CE3FNujuSWn7SkosOzg7qrMxVnt6txOfGcMSa4=
cloud.google.com/go/talent v1.6.6/go.mod h1:y/WQDKrhVz12WagoarpAIyKKMeKGKHWPoReZ0g8tseQ=
cloud.google.com/go/texttospeech v1.7.5 h1:dxY2Q5mHCbrGa3oPR2O3PCicdnvKa1JmwGQK36EFLOw=
cloud.google.com/go/texttospeech v1.7.5/go.mod h1:tzpCuNWPwrNJnEa4Pu5taALuZL4QRRLcb+K9pbhXT6M=
cloud.google.com/go/tpu v1.6.5 h1:C8YyYda8WtNdBoCgFwwBzZd+S6+EScHOxM/z1h0NNp8=
cloud.google.com/go/tpu v1.6.5/go.mod h1:P9DFOEBIBhuEcZhXi+wPoVy/cji+0ICFi4TtTkMHSSs=
cloud.google.com/go/trace v1.10.5 h1:0pr4lIKJ5XZFYD9GtxXEWr0KkVeigc3wlGpZco0X1oA=
cloud.google.com/go/trace v1.10.5/go.mod h1:9hjCV1nGBCtXbAE4YK7OqJ8pmPYSxPA0I67JwRd5s3M=
cloud.google.com/go/translate v1.10.1 h1:upovZ0wRMdzZvXnu+RPam41B0mRJ+coRXFP2cYFJ7ew=
cloud.google.com/go/translate v1.10.1/go.mod h1:adGZcQNom/3ogU65N9UXHOnnSvjPwA/jKQUMnsYXOyk=
cloud.google.com/go/video v1.20.4 h1:TXwotxkShP1OqgKsbd+b8N5hrIHavSyLGvYnLGCZ7xc=
cloud.google.com/go/video v1.20.4/go.mod h1:LyUVjyW+Bwj7dh3UJnUGZfyqjEto9DnrvTe1f/+QrW0=
cloud.google.com/go/videointelligence v1.11.5 h1:mYaWH8uhUCXLJCN3gdXswKzRa2+lK0zN6/KsIubm6pE=
cloud.google.com/go/videointelligence v1.11.5/go.mod h1:/PkeQjpRponmOerPeJxNPuxvi12HlW7Em0lJO14FC3I=
cloud.google.com/go/vision/v2 v2.8.0 h1:W52z1b6LdGI66MVhE70g/NFty9zCYYcjdKuycqmlhtg=
cloud.google.com/go/vision/v2 v2.8.0/go.mod h1:ocqDiA2j97pvgogdyhoxiQp2ZkDCyr0HWpicywGGRhU=
cloud.google.com/go/vmmigration v1.7.5 h1:5v9RT2vWyuw3pK2ox0HQpkoftO7Q7/8591dTxxQc79g=
cloud.google.com/go/vmmigration v1.7.5/go.mod h1:pkvO6huVnVWzkFioxSghZxIGcsstDvYiVCxQ9ZH3eYI=
cloud.google.com/go/vmwareengine v1.1.1 h1:EGdDi9QbqThfZq3ILcDK5g+m9jTevc34AY5tACx5v7k=
cloud.google.com/go/vmwareengine v1.1.1/go.mod h1:nMpdsIVkUrSaX8UvmnBhzVzG7PPvNYc5BszcvIVudYs=
cloud.google.com/go/vpcaccess v1.7.5 h1:XyL6hTLtEM/eE4F1GEge8xUN9ZCkiVWn44K/YA7z1rQ=
cloud.google.com/go/vpcaccess v1.7.5/go.mod h1:slc5ZRvvjP78c2dnL7m4l4R9GwL3wDLcpIWz6P/ziig=
cloud.google.com/go/webrisk v1.9.5 h1:251MvGuC8wisNN7+jqu9DDDZAi38KiMXxOpA/EWy4dE=
cloud.google.com/go/webrisk v1.9.5/go.mod h1:aako0Fzep1Q714cPEM5E+mtYX8/jsfegAuS8aivxy3U=
cloud.google.com/go/websecurityscanner v1.6.5 h1:YqWZrZYabG88TZt7364XWRJGhxmxhony2ZUyZEYMF2k=
cloud.google.com/go/websecurityscanner v1.6.5/go.mod h1:QR+DWaxAz2pWooylsBF854/Ijvuoa3FCyS1zBa1rAVQ=
cloud.google.com/go/workflows v1.12.4 h1:uHNmUiatTbPQ4H1pabwfzpfEYD4BBnqDHqMm2IesOh4=
cloud.google.com/go/workflows v1.12.4/go.mod h1:yQ7HUqOkdJK4duVtMeBCAOPiN1ZF1E9pAMX51vpwB/w=
codeberg.org/go-fonts/liberation v0.5.0/go.mod h1:zS/2e1354/mJ4pGzIIaEtm/59VFCFnYC7YV6YdGl5GU=
codeberg.org/go-latex/latex v0.1.0/go.mod h1:LA0q/AyWIYrqVd+A9Upkgsb+IqPcmSTKc9Dny04MHMw=
codeberg.org/go-pdf/fpdf v0.10.0/go.mod h1:Y0DGRAdZ0OmnZPvjbMp/1bYxmIPxm0ws4tfoPOc4LjU=
dario.cat/mergo v1.0.1/go.mod h1:uNxQE+84aUszobStD9th8a29P2fMDhsBdgRYvZOxGmk=
dario.cat/mergo v1.0.2/go.mod h1:E/hbnu0NxMFBjpMIE34DRGLWqDy0g5FuKDhCb31ngxA=
dmitri.shuralyov.com/gpu/mtl v0.0.0-20190408044501-666a987793e9 h1:VpgP7xuJadIUuKccphEpTJnWhS2jkQyMt6Y7pJCD7fY=
git.sr.ht/~sbinet/gg v0.6.0/go.mod h1:uucygbfC9wVPQIfrmwM2et0imr8L7KQWywX0xpFMm94=
github.com/Azure/go-ansiterm v0.0.0-20230124172434-306776ec8161/go.mod h1:xomTg63KZ2rFqZQzSB4Vz2SUXa1BpHTVz9L5PTmPC4E=
github.com/Azure/go-ntlmssp v0.0.0-20221128193559-754e69321358/go.mod h1:chxPXzSsl7ZWRAuOIE23GDNzjWuZquvFlgA8xmpunjU=
github.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802 h1:1BDTz0u9nC3//pOCMdNH+CiXJVYJh5UQNCOBG7jbELc=
github.com/GoogleCloudPlatform/opentelemetry-operations-go/detectors/gcp v1.30.0/go.mod h1:P4WPRUkOhJC13W//jWpyfJNDAIpvRbAUIYLX/4jtlE0=
github.com/Masterminds/semver/v3 v3.4.0/go.mod h1:4V+yj/TJE1HU9XfppCwVMZq3I84lprf4nC11bSS5beM=
github.com/PuerkitoBio/goquery v1.9.1 h1:mTL6XjbJTZdpfL+Gwl5U2h1l9yEkJjhmlTeV9VPW7UI=
github.com/PuerkitoBio/goquery v1.9.1/go.mod h1:cW1n6TmIMDoORQU5IU/P1T3tGFunOeXEpGP2WHRwkbY=
github.com/PuerkitoBio/goquery v1.10.3/go.mod h1:tMUX0zDMHXYlAQk6p35XxQMqMweEKB7iK7iLNd4RH4Y=
github.com/Soontao/goHttpDigestClient v0.0.0-20170320082612-6d28bb1415c5/go.mod h1:5Q4+CyR7+Q3VMG8f78ou+QSX/BNUNUx5W48eFRat8DQ=
github.com/ajstarks/svgo v0.0.0-20211024235047-1546f124cd8b/go.mod h1:1KcenG0jGWcpt8ov532z81sp/kMMUG485J2InIOyADM=
github.com/alecthomas/kingpin/v2 v2.3.2 h1:H0aULhgmSzN8xQ3nX1uxtdlTHYoPLu5AhHxWrKI6ocU=
github.com/alecthomas/kingpin/v2 v2.3.2/go.mod h1:0gyi0zQnjuFk8xrkNKamJoyUo382HRL7ATRpFZCw6tE=
github.com/alecthomas/kingpin/v2 v2.4.0/go.mod h1:0gyi0zQnjuFk8xrkNKamJoyUo382HRL7ATRpFZCw6tE=
github.com/alecthomas/units v0.0.0-20211218093645-b94a6e3cc137 h1:s6gZFSlWYmbqAuRjVTiNNhvNRfY2Wxp9nhfyel4rklc=
github.com/alecthomas/units v0.0.0-20211218093645-b94a6e3cc137/go.mod h1:OMCwj8VM1Kc9e19TLln2VL61YJF0x1XFtfdL4JdbSyE=
github.com/alecthomas/units v0.0.0-20240927000941-0f3dac36c52b/go.mod h1:fvzegU4vN3H1qMT+8wDmzjAcDONcgo2/SZ/TyfdUOFs=
github.com/andybalholm/cascadia v1.3.2 h1:3Xi6Dw5lHF15JtdcmAHD3i1+T8plmv7BQ/nsViSLyss=
github.com/andybalholm/cascadia v1.3.2/go.mod h1:7gtRlve5FxPPgIgX36uWBX58OdBsSS6lUvCFb+h7KvU=
github.com/andybalholm/cascadia v1.3.3/go.mod h1:xNd9bqTn98Ln4DwST8/nG+H0yuB8Hmgu1YHNnWw0GeA=
github.com/antihax/optional v1.0.0 h1:xK2lYat7ZLaVVcIuj82J8kIro4V6kDe0AUDFboUCwcg=
github.com/antithesishq/antithesis-sdk-go v0.4.3-default-no-op/go.mod h1:IUpT2DPAKh6i/YhSbt6Gl3v2yvUZjmKncl7U91fup7E=
github.com/armon/go-metrics v0.4.0 h1:yCQqn7dwca4ITXb+CbubHmedzaQYHhNhrEXLYUeEe8Q=
github.com/armon/go-metrics v0.4.0/go.mod h1:E6amYzXo6aW1tqzoZGT755KkbgrJsSdpwZ+3JqfkOG4=
github.com/aws/aws-sdk-go-v2 v1.38.0/go.mod h1:9Q0OoGQoboYIAJyslFyF1f5K1Ryddop8gqMhWx/n4Wg=
github.com/aws/aws-sdk-go-v2 v1.39.6/go.mod h1:c9pm7VwuW0UPxAEYGyTmyurVcNrbF6Rt/wixFqDhcjE=
github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.6.11/go.mod h1:dd+Lkp6YmMryke+qxW/VnKyhMBDTYP41Q2Bb+6gNZgY=
github.com/aws/aws-sdk-go-v2/aws/protocol/eventstream v1.7.0/go.mod h1:/mXlTIVG9jbxkqDnr5UQNQxW1HRYxeGklkM9vAFeabg=
github.com/aws/aws-sdk-go-v2/config v1.29.17/go.mod h1:9P4wwACpbeXs9Pm9w1QTh6BwWwJjwYvJ1iCt5QbCXh8=
github.com/aws/aws-sdk-go-v2/config v1.31.2/go.mod h1:17ft42Yb2lF6OigqSYiDAiUcX4RIkEMY6XxEMJsrAes=
github.com/aws/aws-sdk-go-v2/credentials v1.17.70/go.mod h1:M+lWhhmomVGgtuPOhO85u4pEa3SmssPTdcYpP/5J/xc=
github.com/aws/aws-sdk-go-v2/credentials v1.18.6/go.mod h1:/jdQkh1iVPa01xndfECInp1v1Wnp70v3K4MvtlLGVEc=
github.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.16.32/go.mod h1:h4Sg6FQdexC1yYG9RDnOvLbW1a/P986++/Y/a+GyEM8=
github.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.18.4/go.mod h1:9xzb8/SV62W6gHQGC/8rrvgNXU6ZoYM3sAIJCIrXJxY=
github.com/aws/aws-sdk-go-v2/internal/configsources v1.3.36/go.mod h1:Q1lnJArKRXkenyog6+Y+zr7WDpk4e6XlR6gs20bbeNo=
github.com/aws/aws-sdk-go-v2/internal/configsources v1.4.4/go.mod h1:l4bdfCD7XyyZA9BolKBo1eLqgaJxl0/x91PL4Yqe0ao=
github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.36/go.mod h1:UdyGa7Q91id/sdyHPwth+043HhmP6yP9MBHgbZM0xo8=
github.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.7.4/go.mod h1:yDmJgqOiH4EA8Hndnv4KwAo8jCGTSnM5ASG1nBI+toA=
github.com/aws/aws-sdk-go-v2/internal/ini v1.8.3/go.mod h1:H5O/EsxDWyU+LP/V8i5sm8cxoZgc2fdNR9bxlOFrQTo=
github.com/aws/aws-sdk-go-v2/internal/v4a v1.3.36/go.mod h1:gDhdAV6wL3PmPqBhiPbnlS447GoWs8HTTOYef9/9Inw=
github.com/aws/aws-sdk-go-v2/internal/v4a v1.4.4/go.mod h1:SPBBhkJxjcrzJBc+qY85e83MQ2q3qdra8fghhkkyrJg=
github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.12.4/go.mod h1:/xFi9KtvBXP97ppCz1TAEvU1Uf66qvid89rbem3wCzQ=
github.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.13.0/go.mod h1:eb3gfbVIxIoGgJsi9pGne19dhCBpK6opTYpQqAmdy44=
github.com/aws/aws-sdk-go-v2/service/internal/checksum v1.7.4/go.mod h1:LT10DsiGjLWh4GbjInf9LQejkYEhBgBCjLG5+lvk4EE=
github.com/aws/aws-sdk-go-v2/service/internal/checksum v1.8.4/go.mod h1:b17At0o8inygF+c6FOD3rNyYZufPw62o9XJbSfQPgbo=
github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.12.17/go.mod h1:ygpklyoaypuyDvOM5ujWGrYWpAK3h7ugnmKCU/76Ys4=
github.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.13.4/go.mod h1:nLEfLnVMmLvyIG58/6gsSA03F1voKGaCfHV7+lR8S7s=
github.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.18.17/go.mod h1:M+jkjBFZ2J6DJrjMv2+vkBbuht6kxJYtJiwoVgX4p4U=
github.com/aws/aws-sdk-go-v2/service/internal/s3shared v1.19.4/go.mod h1:DnbBOv4FlIXHj2/xmrUQYtawRFC9L9ZmQPz+DBc6X5I=
github.com/aws/aws-sdk-go-v2/service/s3 v1.84.0/go.mod h1:kUklwasNoCn5YpyAqC/97r6dzTA1SRKJfKq16SXeoDU=
github.com/aws/aws-sdk-go-v2/service/s3 v1.87.1/go.mod h1:w5PC+6GHLkvMJKasYGVloB3TduOtROEMqm15HSuIbw4=
github.com/aws/aws-sdk-go-v2/service/sso v1.25.5/go.mod h1:b7SiVprpU+iGazDUqvRSLf5XmCdn+JtT1on7uNL6Ipc=
github.com/aws/aws-sdk-go-v2/service/sso v1.28.2/go.mod h1:n9bTZFZcBa9hGGqVz3i/a6+NG0zmZgtkB9qVVFDqPA8=
github.com/aws/aws-sdk-go-v2/service/ssooidc v1.30.3/go.mod h1:vq/GQR1gOFLquZMSrxUK/cpvKCNVYibNyJ1m7JrU88E=
github.com/aws/aws-sdk-go-v2/service/ssooidc v1.33.2/go.mod h1:eknndR9rU8UpE/OmFpqU78V1EcXPKFTTm5l/buZYgvM=
github.com/aws/aws-sdk-go-v2/service/sts v1.34.0/go.mod h1:7ph2tGpfQvwzgistp2+zga9f+bCjlQJPkPUmMgDSD7w=
github.com/aws/aws-sdk-go-v2/service/sts v1.38.0/go.mod h1:bEPcjW7IbolPfK67G1nilqWyoxYMSPrDiIQ3RdIdKgo=
github.com/aws/smithy-go v1.22.5/go.mod h1:t1ufH5HMublsJYulve2RKmHDC15xu1f26kHCp/HgceI=
github.com/aws/smithy-go v1.23.2/go.mod h1:LEj2LM3rBRQJxPZTB4KuzZkaZYnZPnvgIhb4pu07mx0=
github.com/bsm/ginkgo/v2 v2.12.0/go.mod h1:SwYbGRRDovPVboqFv0tPTcG1sN61LM1Z4ARdbAV9g4c=
github.com/bsm/gomega v1.27.10/go.mod h1:JyEr/xRbxbtgWNi8tIEVPUYZ5Dzef52k01W3YH0H+O0=
github.com/campoy/embedmd v1.0.0/go.mod h1:oxyr9RCiSXg0M3VJ3ks0UGfp98BpSSGr0kpiX3MzVl8=
github.com/census-instrumentation/opencensus-proto v0.4.1 h1:iKLQ0xPNFxR/2hzXZMrBo8f1j86j5WHzznCCQxV/b8g=
github.com/census-instrumentation/opencensus-proto v0.4.1/go.mod h1:4T9NM4+4Vw91VeyqjLS6ao50K5bOcLKN6Q42XnYaRYw=
github.com/chromedp/cdproto v0.0.0-20221023212508-67ada9507fb2 h1:xESwMZNYkDnZf9MUk+6lXfMbpDnEJwlEuIxKYKM1vJY=
github.com/chromedp/cdproto v0.0.0-20221023212508-67ada9507fb2/go.mod h1:GKljq0VrfU4D5yc+2qA6OVr8pmO/MBbPEWqWQ/oqGEs=
github.com/chromedp/cdproto v0.0.0-20250803210736-d308e07a266d/go.mod h1:NItd7aLkcfOA/dcMXvl8p1u+lQqioRMq/SqDp71Pb/k=
github.com/chromedp/sysutil v1.0.0 h1:+ZxhTpfpZlmchB58ih/LBHX52ky7w2VhQVKQMucy3Ic=
github.com/chromedp/sysutil v1.0.0/go.mod h1:kgWmDdq8fTzXYcKIBqIYvRRTnYb9aNS9moAV0xufSww=
github.com/chromedp/sysutil v1.1.0/go.mod h1:WiThHUdltqCNKGc4gaU50XgYjwjYIhKWoHGPTUfWTJ8=
github.com/chzyer/readline v1.5.1 h1:upd/6fQk4src78LMRzh5vItIt361/o4uq553V8B5sGI=
github.com/chzyer/readline v1.5.1/go.mod h1:Eh+b79XXUwfKfcPLepksvw2tcLE/Ct21YObkaSkeBlk=
github.com/client9/misspell v0.3.4 h1:ta993UF76GwbvJcIo3Y68y/M3WxlpEHPWIGDkJYwzJI=
github.com/cncf/udpa/go v0.0.0-20201120205902-5459f2c99403 h1:cqQfy1jclcSy/FwLjemeg3SR1yaINm74aQyupQ0Bl8M=
github.com/cncf/udpa/go v0.0.0-20220112060539-c52dc94e7fbe/go.mod h1:6pvJx4me5XPnfI9Z40ddWsdw2W/uZgQLFXToKeRcDiI=
github.com/cncf/xds/go v0.0.0-20240318125728-8a4994d93e50 h1:DBmgJDC9dTfkVyGgipamEh2BpGYxScCH1TOF1LL1cXc=
github.com/cncf/xds/go v0.0.0-20240318125728-8a4994d93e50/go.mod h1:5e1+Vvlzido69INQaVO6d87Qn543Xr6nooe9Kz7oBFM=
github.com/cncf/xds/go v0.0.0-20251022180443-0feb69152e9f/go.mod h1:HlzOvOjVBOfTGSRXRyY0OiCS/3J1akRGQQpRO/7zyF4=
github.com/containerd/errdefs v1.0.0/go.mod h1:+YBYIdtsnF4Iw6nWZhJcqGSg/dwvV7tyJ/kCkyJ2k+M=
github.com/containerd/errdefs/pkg v0.3.0/go.mod h1:NJw6s9HwNuRhnjJhM7pylWwMyAkmCQvQ4GpJHEqRLVk=
github.com/containerd/log v0.1.0/go.mod h1:VRRf09a7mHDIRezVKTRCrOq78v577GXq3bSa3EhrzVo=
github.com/containerd/platforms v0.2.1/go.mod h1:XHCb+2/hzowdiut9rkudds9bE5yJ7npe7dG/wG+uFPw=
github.com/cpuguy83/dockercfg v0.3.2/go.mod h1:sugsbF4//dDlL/i+S+rtpIWp+5h0BHJHfjj5/jFyUJc=
github.com/cpuguy83/go-md2man/v2 v2.0.4 h1:wfIWP927BUkWJb2NmU/kNDYIBTh/ziUX91+lVfRxZq4=
github.com/cpuguy83/go-md2man/v2 v2.0.4/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=
github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
github.com/creack/pty v1.1.11 h1:07n33Z8lZxZ2qwegKbObQohDhXDQxiMMz1NOUGYlesw=
github.com/creack/pty v1.1.11/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc h1:U9qPSI2PIWSS1VwoXQT9A3Wy9MM3WgvqSxFWenqJduM=
github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f/go.mod h1:cuUVRXasLTGF7a8hSLbxyZXjz+1KgoB3wDUb6vlszIc=
github.com/distribution/reference v0.6.0/go.mod h1:BbU0aIcezP1/5jX/8MP0YiH4SdvB5Y4f/wlDRiLyi3E=
github.com/docker/docker v28.2.2+incompatible/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=
github.com/docker/docker v28.3.3+incompatible/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=
github.com/docker/go-connections v0.5.0/go.mod h1:ov60Kzw0kKElRwhNs9UlUHAE/F9Fe6GLaXnqyDdmEXc=
github.com/docker/go-connections v0.6.0/go.mod h1:AahvXYshr6JgfUJGdDCs2b5EZG/vmaMAntpSFH5BFKE=
github.com/docker/go-units v0.5.0/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=
github.com/dop251/goja v0.0.0-20240516125602-ccbae20bcec2/go.mod h1:o31y53rb/qiIAONF7w3FHJZRqqP3fzHUr1HqanthByw=
github.com/dop251/goja_nodejs v0.0.0-20211022123610-8dd9abb0616d h1:W1n4DvpzZGOISgp7wWNtraLcHtnmnTwBlJidqtMIuwQ=
github.com/dop251/goja_nodejs v0.0.0-20211022123610-8dd9abb0616d/go.mod h1:DngW8aVqWbuLRMHItjPUyqdj+HWPvnQe8V8y1nDpIbM=
github.com/ebitengine/purego v0.8.4/go.mod h1:iIjxzd6CiRiOG0UyXP+V1+jWqUXVjPKLAI0mRfJZTmQ=
github.com/envoyproxy/go-control-plane v0.9.9-0.20210217033140-668b12f5399d/go.mod h1:cXg6YxExXjJnVBQHBLXeUAgxn2UodCpnH306RInaBQk=
github.com/envoyproxy/go-control-plane v0.12.0 h1:4X+VP1GHd1Mhj6IB5mMeGbLCleqxjletLK6K0rbxyZI=
github.com/envoyproxy/go-control-plane v0.12.0/go.mod h1:ZBTaoJ23lqITozF0M6G4/IragXCQKCnYbmlmtHvwRG0=
github.com/envoyproxy/go-control-plane v0.13.5-0.20251024222203-75eaa193e329/go.mod h1:Alz8LEClvR7xKsrq3qzoc4N0guvVNSS8KmSChGYr9hs=
github.com/envoyproxy/go-control-plane/envoy v1.35.0/go.mod h1:09qwbGVuSWWAyN5t/b3iyVfz5+z8QWGrzkoqm/8SbEs=
github.com/envoyproxy/go-control-plane/ratelimit v0.1.0/go.mod h1:Wk+tMFAFbCXaJPzVVHnPgRKdUdwW/KdbRt94AzgRee4=
github.com/envoyproxy/protoc-gen-validate v1.0.4 h1:gVPz/FMfvh57HdSJQyvBtF00j8JU4zdyUgIUNhlgg0A=
github.com/envoyproxy/protoc-gen-validate v1.0.4/go.mod h1:qys6tmnRsYrQqIhm2bvKZH4Blx/1gTIZ2UKVY1M+Yew=
github.com/envoyproxy/protoc-gen-validate v1.2.1/go.mod h1:d/C80l/jxXLdfEIhX1W2TmLfsJ31lvEjwamM4DxlWXU=
github.com/etcd-io/gofail v0.0.0-20190801230047-ad7f989257ca h1:Y2I0lxOttdUKz+hNaIdG3FtjuQrTmwXun1opRV65IZc=
github.com/etcd-io/gofail v0.0.0-20190801230047-ad7f989257ca/go.mod h1:49H/RkXP8pKaZy4h0d+NW16rSLhyVBt4o6VLJbmOqDE=
github.com/fatih/structs v1.1.0 h1:Q7juDM0QtcnhCpeyLGQKyg4TOIghuNXrkL32pHAUMxo=
github.com/felixge/httpsnoop v1.0.4/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=
github.com/ghodss/yaml v1.0.0 h1:wQHKEahhL6wmXdzwWG11gIVCkOv05bNOh+Rxn0yngAk=
github.com/go-gl/glfw v0.0.0-20190409004039-e6da0acd62b1 h1:QbL/5oDUmRBzO9/Z7Seo6zf912W/a6Sr4Eu0G/3Jho0=
github.com/go-gl/glfw/v3.3/glfw v0.0.0-20200222043503-6f7a984d4dc4 h1:WtGNWLvXpe6ZudgnXrq0barxBImvnnJoMEhXAzcbM0I=
github.com/go-ini/ini v1.55.0 h1:0wVcG9udk2C3TGgmdIGKK9ScOZHZB5nbG+gwji9fhhc=
github.com/go-jose/go-jose/v4 v4.1.3/go.mod h1:x4oUasVrzR7071A4TnHLGSPpNOm2a21K9Kf04k1rs08=
github.com/go-json-experiment/json v0.0.0-20250211171154-1ae217ad3535/go.mod h1:BWmvoE1Xia34f3l/ibJweyhrT+aROb/FQ6d+37F0e2s=
github.com/go-kit/log v0.2.1 h1:MRVx0/zhvdseW+Gza6N9rVzU/IVzaeE1SFI4raAhmBU=
github.com/go-kit/log v0.2.1/go.mod h1:NwTd00d/i8cPZ3xOwwiv2PO5MOcx78fFErGNcVmBjv0=
github.com/go-logfmt/logfmt v0.5.1 h1:otpy5pqBCBZ1ng9RQ0dPu4PN7ba75Y/aA+UpowDyNVA=
github.com/go-logfmt/logfmt v0.5.1/go.mod h1:WYhtIu8zTZfxdn5+rREduYbwxfcBr/Vr6KEVveWlfTs=
github.com/go-ole/go-ole v1.3.0/go.mod h1:5LS6F96DhAwUc7C+1HLexzMXY1xGRSryjyPPKW6zv78=
github.com/go-stack/stack v1.8.0 h1:5SgMzNM5HxrEjV0ww2lTmX6E2Izsfxas4+YHWRs3Lsk=
github.com/go-task/slim-sprig v0.0.0-20210107165309-348f09dbbbc0 h1:p104kn46Q8WdvHunIJ9dAyjPVtrBPhSr3KT2yUst43I=
github.com/go-task/slim-sprig v0.0.0-20230315185526-52ccab3ef572/go.mod h1:9Pwr4B2jHnOSGXyyzV8ROjYa2ojvAY6HCGYYfMoC3Ls=
github.com/goccmack/gocc v0.0.0-20230228185258-2292f9e40198/go.mod h1:DTh/Y2+NbnOVVoypCCQrovMPDKUGp4yZpSbWg5D0XIM=
github.com/godbus/dbus/v5 v5.0.4 h1:9349emZab16e7zQvpmsbtjc18ykshndd8y2PG3sgJbA=
github.com/golang-jwt/jwt/v5 v5.3.0/go.mod h1:fxCRLWMO43lRc8nhHWY6LGqRcf+1gQWArsqaEUEa5bE=
github.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0/go.mod h1:E/TSTwGwJL78qG/PmXZO1EjYhfJinVAhrmmHX6Z8B9k=
github.com/golang/glog v1.2.0 h1:uCdmnmatrKCgMBlM4rMuJZWOkPDqdbZPnrMXDY4gI68=
github.com/golang/glog v1.2.0/go.mod h1:6AhwSGph0fcJtXVM/PEHPqZlFeoLxhs7/t5UDAwmO+w=
github.com/golang/glog v1.2.5/go.mod h1:6AhwSGph0fcJtXVM/PEHPqZlFeoLxhs7/t5UDAwmO+w=
github.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=
github.com/golang/protobuf v1.5.2/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=
github.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/google/go-tpm v0.9.6/go.mod h1:h9jEsEECg7gtLis0upRBQU+GhYVH6jMjrFxI8u6bVUY=
github.com/google/go-tpm-tools v0.3.13-0.20230620182252-4639ecce2aba/go.mod h1:EFYHy8/1y2KfgTAsx7Luu7NGhoxtuVHnNo8jE7FikKc=
github.com/google/gofuzz v1.0.0 h1:A8PeW59pxE9IoFRqBp37U+mSNaQoZ46F1f0f863XSXw=
github.com/google/martian v2.1.0+incompatible h1:/CP5g8u/VJHijgedC/Legn3BAbAaWPgecwXBIDzw5no=
github.com/google/martian/v3 v3.1.0 h1:wCKgOCHuUEVfsaQLpPSJb7VdYCdTVZQAuOdYm1yc/60=
github.com/google/renameio v0.1.0 h1:GOZbcHa3HfsPKPlmyPyN2KEohoMXOhdMbHrvbpl2QaA=
github.com/googleapis/enterprise-certificate-proxy v0.2.1 h1:RY7tHKZcRlk788d5WSo/e83gOyyy742E8GSs771ySpg=
github.com/googleapis/enterprise-certificate-proxy v0.2.1/go.mod h1:AwSRAtLfXpU5Nm3pW+v7rGDHp09LsPtGY9MduiEsR9k=
github.com/googleapis/gax-go/v2 v2.7.0 h1:IcsPKeInNvYi7eqSaDjiZqDDKu5rsmunY0Y1YupQSSQ=
github.com/googleapis/gax-go/v2 v2.7.0/go.mod h1:TEop28CZZQ2y+c0VxMUmu1lV+fQx57QpBWsYpwqHJx8=
github.com/googleapis/google-cloud-go-testing v0.0.0-20200911160855-bcd43fbb19e8 h1:tlyzajkF3030q6M8SvmJSemC9DTHL/xaMa18b65+JM4=
github.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1 h1:EGx4pi6eqNxGaHF6qqu48+N2wcFQ5qg5FXgOdqsJ5d8=
github.com/grafana/k6build v0.5.15/go.mod h1:Sk7SUiCnx2AgkirG3PrCtmJKYL+a8EeRdTzFfbxP0X8=
github.com/grafana/k6foundry v0.4.7/go.mod h1:eLsr0whhH+5Y1y7YpDxJi3Jv5wHMuf+80vdRyMH10pg=
github.com/grafana/k6provider v0.2.0/go.mod h1:TJ6vzPm4yDQ2ji/Fet0dFOpdjktrKZp4hsnLZhRoZVA=
github.com/grafana/xk6-browser v1.6.0 h1:x8ZfBwiUJRRKNEw+Asr5ae9o2gFvYU1Ll/4dDMNIPZ8=
github.com/grafana/xk6-browser v1.6.0/go.mod h1:xLaGGhTMHIRsMvkVWFYh9RPy87kG2n4L4Or6DeI8U+o=
github.com/grafana/xk6-dashboard v0.7.4 h1:0ZRPTAXW+6A3Xqq/a/OaIZhxUt1SOMwUFff0IPwBHrs=
github.com/grafana/xk6-dashboard v0.7.4/go.mod h1:300QyQ+OQAYz/L/AzB5tKzPeBY5eKh2wl1NsRmCbsx4=
github.com/grafana/xk6-dashboard v0.7.13/go.mod h1:D+k5+Nf836MHpELDqGxUs9eCRAOYE+d5HYM9zDwdILw=
github.com/grafana/xk6-output-prometheus-remote v0.4.0 h1:7k3xjuKaD9BwcX8iuu5v6PtAK1L53kvx1r8BaTUfRH4=
github.com/grafana/xk6-output-prometheus-remote v0.4.0/go.mod h1:esXXthLoVp9JUdGkECRthESVYu0TQTR24wrx2nRM9ak=
github.com/grafana/xk6-redis v0.3.0 h1:eV1YO0miPqGFilN8sL/3OdO6Mm+hZH2nsvJm5dkE0CM=
github.com/grafana/xk6-redis v0.3.0/go.mod h1:3e/U9i1Nm3WEaMy4nZSGMjVf8ZsFau+aXurYJhJ7MfQ=
github.com/grafana/xk6-redis v0.3.4/go.mod h1:2IyZC8uAFXuWmdu5TKPz5w9h2oPxQl5O2wSHv/HQ15I=
github.com/grafana/xk6-webcrypto v0.4.0 h1:CXRGkvVg8snYEyGCq3d5XGzDPxTPJ1m5CS68jPdtZZk=
github.com/grafana/xk6-webcrypto v0.4.0/go.mod h1:+THllImZ8OWlsFc8llWqvzzjottlGdXq/7rIQ16zmFs=
github.com/grafana/xk6-websockets v0.5.1 h1:wymI6UWpwDorv3mEInytrQjC9cmXYxQFygBOCMY1q6k=
github.com/grafana/xk6-websockets v0.5.1/go.mod h1:yPadv8R00MPCnV+GGSlYV/vwVgxKRCiiJoIfWsNGoQg=
github.com/grpc-ecosystem/grpc-gateway/v2 v2.27.2/go.mod h1:pkJQ2tZHJ0aFOVEEot6oZmaVEZcRme73eIFmhiVuRWs=
github.com/hashicorp/consul/api v1.18.0 h1:R7PPNzTCeN6VuQNDwwhZWJvzCtGSrNpJqfb22h3yH9g=
github.com/hashicorp/consul/api v1.18.0/go.mod h1:owRRGJ9M5xReDC5nfT8FTJrNAPbT4NM6p/k+d03q2v4=
github.com/hashicorp/go-cleanhttp v0.5.2 h1:035FKYIWjmULyFRBKPs8TBQoi0x6d9G4xc9neXJWAZQ=
github.com/hashicorp/go-cleanhttp v0.5.2/go.mod h1:kO/YDlP8L1346E6Sodw+PrpBSV4/SoxCXGY6BqNFT48=
github.com/hashicorp/go-hclog v1.2.0 h1:La19f8d7WIlm4ogzNHB0JGqs5AUDAZ2UfCY4sJXcJdM=
github.com/hashicorp/go-hclog v1.2.0/go.mod h1:whpDNt7SSdeAju8AWKIWsul05p54N/39EeqMAyrmvFQ=
github.com/hashicorp/go-immutable-radix v1.3.1 h1:DKHmCUm2hRBK510BaiZlwvpD40f8bJFeZnpfm2KLowc=
github.com/hashicorp/go-immutable-radix v1.3.1/go.mod h1:0y9vanUI8NX6FsYoO3zeMjhV/C5i9g4Q3DwcSNZ4P60=
github.com/hashicorp/go-rootcerts v1.0.2 h1:jzhAVGtqPKbwpyCPELlgNWhE1znq+qwJtW5Oi2viEzc=
github.com/hashicorp/go-rootcerts v1.0.2/go.mod h1:pqUvnprVnM5bf7AOirdbb01K4ccR319Vf4pU3K5EGc8=
github.com/hashicorp/golang-lru v0.5.4 h1:YDjusn29QI/Das2iO9M0BHnIbxPeyuCHsjMW+lJfyTc=
github.com/hashicorp/golang-lru v0.5.4/go.mod h1:iADmTwqILo4mZ8BN3D2Q6+9jd8WM5uGBxy+E8yxSoD4=
github.com/hashicorp/serf v0.10.1 h1:Z1H2J60yRKvfDYAOZLd2MU0ND4AH/WDz7xYHDWQsIPY=
github.com/hashicorp/serf v0.10.1/go.mod h1:yL2t6BqATOLGc5HF7qbFkTfXoPIY0WZdWHfEvMqbG+4=
github.com/hpcloud/tail v1.0.0 h1:nfCOvKYfkgYP8hkirhJocXT2+zOD8yUNjXaWfTlyFKI=
github.com/iancoleman/strcase v0.3.0/go.mod h1:iwCmte+B7n89clKwxIoIXy/HfoL7AsD47ZCWhYzw7ho=
github.com/ianlancetaylor/demangle v0.0.0-20230524184225-eabc099b10ab h1:BA4a7pe6ZTd9F8kXETBoijjFJ/ntaa//1wiH9BZu4zU=
github.com/ianlancetaylor/demangle v0.0.0-20230524184225-eabc099b10ab/go.mod h1:gx7rwoVhcfuVKG5uya9Hs3Sxj7EIvldVofAWIUtGouw=
github.com/ianlancetaylor/demangle v0.0.0-20250417193237-f615e6bd150b/go.mod h1:gx7rwoVhcfuVKG5uya9Hs3Sxj7EIvldVofAWIUtGouw=
github.com/influxdata/influxdb1-client v0.0.0-20190402204710-8ff2fc3824fc/go.mod h1:qj24IKcXYK6Iy9ceXlo3Tc+vtHo9lIhSX5JddghvEPo=
github.com/jhump/gopoet v0.0.0-20190322174617-17282ff210b3/go.mod h1:me9yfT6IJSlOL3FCfrg+L6yzUEZ+5jW6WHt4Sk+UPUI=
github.com/jhump/gopoet v0.1.0 h1:gYjOPnzHd2nzB37xYQZxj4EIQNpBrBskRqQQ3q4ZgSg=
github.com/jhump/gopoet v0.1.0/go.mod h1:me9yfT6IJSlOL3FCfrg+L6yzUEZ+5jW6WHt4Sk+UPUI=
github.com/jhump/goprotoc v0.5.0 h1:Y1UgUX+txUznfqcGdDef8ZOVlyQvnV0pKWZH08RmZuo=
github.com/jhump/goprotoc v0.5.0/go.mod h1:VrbvcYrQOrTi3i0Vf+m+oqQWk9l72mjkJCYo7UvLHRQ=
github.com/jhump/protoreflect v1.11.0/go.mod h1:U7aMIjN0NWq9swDP7xDdoMfRHb35uiuTd3Z9nFXJf5E=
github.com/jpillora/backoff v1.0.0 h1:uvFg412JmmHBHw7iwprIxkPMI+sGQ4kzOWsMeHnm2EA=
github.com/jpillora/backoff v1.0.0/go.mod h1:J/6gKK9jxlEcS3zixgDgUAsiuZ7yrSoa/FX5e0EB2j4=
github.com/jstemmer/go-junit-report v0.9.1 h1:6QPYqodiu3GuPL+7mfx+NwDdp2eTkp9IfEUpgAwUN0o=
github.com/jtolds/gls v4.20.0+incompatible h1:xdiiI2gbIgH/gLH7ADydsJ1uDOEzR8yvV7C0MuV77Wo=
github.com/julienschmidt/httprouter v1.3.0 h1:U0609e9tgbseu3rBINet9P48AI/D3oJs4dN7jwJOQ1U=
github.com/julienschmidt/httprouter v1.3.0/go.mod h1:JR6WtHb+2LUe8TCKY3cZOxFyyO8IZAc4RVcycCCAKdM=
github.com/kisielk/errcheck v1.5.0 h1:e8esj/e4R+SAOwFwN+n3zr0nYeCyeweozKfO23MvHzY=
github.com/kisielk/gotool v1.0.0 h1:AV2c/EiW3KqPNT9ZKl07ehoAGi4C5/01Cfbblndcapg=
github.com/klauspost/compress v1.17.9/go.mod h1:Di0epgTjJY877eYKx5yC51cX2A2Vl2ibi7bDH9ttBbw=
github.com/klauspost/compress v1.18.0/go.mod h1:2Pp+KzxcywXVXMr50+X0Q/Lsb43OQHYWRCY2AiWywWQ=
github.com/konsorten/go-windows-terminal-sequences v1.0.1 h1:mweAR1A6xJ3oS2pRaGiHgQ4OO8tzTaLawm8vnODuwDk=
github.com/kr/fs v0.1.0 h1:Jskdu9ieNAYnjxsi0LbQp1ulIKZV1LAFgK1tWhpZgl8=
github.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=
github.com/kr/pty v1.1.1 h1:VkoXIwSboBpnk99O/KFauAEILuNHv5DVFKZMBN/gUgw=
github.com/ksubedi/gomove v0.0.0-20200106182546-e1fa47256217 h1:CYk3GRunz2nSWbGNXpDxlr5uU/YTkBf1p9zorauMvvc=
github.com/ksubedi/gomove v0.0.0-20200106182546-e1fa47256217/go.mod h1:yq7Mn2Ip7t9irYr+JskEuBYdF3tKnikTKG49Qn5aDuY=
github.com/lufia/plan9stats v0.0.0-20240226150601-1dcf7310316a/go.mod h1:ilwx/Dta8jXAgpFYFvSWEMwxmbWXyiUHkd5FwyKhb5k=
github.com/lyft/protoc-gen-star/v2 v2.0.4-0.20230330145011-496ad1ac90a4/go.mod h1:amey7yeodaJhXSbf/TlLvWiqQfLOSpEk//mLlc+axEk=
github.com/mgutz/ansi v0.0.0-20200706080929-d51e80ef957d h1:5PJl274Y63IEHC+7izoQE9x6ikvDFZS2mDVS3drnohI=
github.com/mgutz/ansi v0.0.0-20200706080929-d51e80ef957d/go.mod h1:01TrycV0kFyexm33Z7vhZRXopbI8J3TDReVlkTgMUxE=
github.com/moby/docker-image-spec v1.3.1/go.mod h1:eKmb5VW8vQEh/BAr2yvVNvuiJuY6UIocYsFu/DxxRpo=
github.com/moby/go-archive v0.1.0/go.mod h1:G9B+YoujNohJmrIYFBpSd54GTUB4lt9S+xVQvsJyFuo=
github.com/moby/patternmatcher v0.6.0/go.mod h1:hDPoyOpDY7OrrMDLaYoY3hf52gNCR/YOUYxkhApJIxc=
github.com/moby/sys/sequential v0.6.0/go.mod h1:uyv8EUTrca5PnDsdMGXhZe6CCe8U/UiTWd+lL+7b/Ko=
github.com/moby/sys/user v0.4.0/go.mod h1:bG+tYYYJgaMtRKgEmuueC0hJEAZWwtIbZTB+85uoHjs=
github.com/moby/sys/userns v0.1.0/go.mod h1:IHUYgu/kao6N8YZlp9Cf444ySSvCmDlmzUcYfDHOl28=
github.com/moby/term v0.5.0/go.mod h1:8FzsFHVUBGZdbDsJw/ot+X+d5HLUbvklYLJ9uGfcI3Y=
github.com/morikuni/aec v1.0.0/go.mod h1:BbKIizmSmc5MMPqRYbxO4ZU0S0+P200+tUnFx7PXmsc=
github.com/mstoykov/k6-taskqueue-lib v0.1.0 h1:M3eww1HSOLEN6rIkbNOJHhOVhlqnqkhYj7GTieiMBz4=
github.com/mstoykov/k6-taskqueue-lib v0.1.0/go.mod h1:PXdINulapvmzF545Auw++SCD69942FeNvUztaa9dVe4=
github.com/mstoykov/k6-taskqueue-lib v0.1.3/go.mod h1:e9R2vtLFHCKT+CMiEjTJVMQiJAi17M1KiXXRs7FYc6w=
github.com/mwitkow/go-conntrack v0.0.0-20190716064945-2f068394615f h1:KUppIJq7/+SVif2QVs3tOP0zanoHgBEVAwHxUSIzRqU=
github.com/mwitkow/go-conntrack v0.0.0-20190716064945-2f068394615f/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=
github.com/nu7hatch/gouuid v0.0.0-20131221200532-179d4d0c4d8d/go.mod h1:YUTz3bUH2ZwIWBy3CJBeOBEugqcmXREj14T+iG/4k4U=
github.com/onsi/ginkgo/v2 v2.1.6 h1:Fx2POJZfKRQcM1pH49qSZiYeu319wji004qX+GDovrU=
github.com/onsi/ginkgo/v2 v2.1.6/go.mod h1:MEH45j8TBi6u9BMogfbp0stKC5cdGjumZj5Y7AG4VIk=
github.com/onsi/ginkgo/v2 v2.17.1/go.mod h1:llBI3WDLL9Z6taip6f33H76YcWtJv+7R3HigUjbIBOs=
github.com/opencontainers/go-digest v1.0.0/go.mod h1:0JzlMkj0TRzQZfJkVvzbP0HBR3IKzErnv2BNG4W4MAM=
github.com/opencontainers/image-spec v1.1.1/go.mod h1:qpqAh3Dmcf36wStyyWU+kCeDgrGnAve2nCC8+7h8Q0M=
github.com/opentracing/opentracing-go v1.1.0 h1:pWlfV3Bxv7k65HYwkikxat0+s3pV4bsqf19k25Ur8rU=
github.com/orfjackal/nanospec.go v0.0.0-20120727230329-de4694c1d701 h1:yOXfzNV7qkZ3nf2NPqy4BMzlCmnQzIEbI1vuqKb2FkQ=
github.com/orfjackal/nanospec.go v0.0.0-20120727230329-de4694c1d701/go.mod h1:VtBIF1XX0c1nKkeAPk8i4aXkYopqQgfDqolHUIHPwNI=
github.com/pkg/browser v0.0.0-20210911075715-681adbf594b8 h1:KoWmjvw+nsYOo29YJK9vDA65RGE3NrOnUtO7a+RF9HU=
github.com/pkg/browser v0.0.0-20210911075715-681adbf594b8/go.mod h1:HKlIX3XHQyzLZPlr7++PzdhaXEj94dEiJgZDTsxEqUI=
github.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c/go.mod h1:7rwL4CYBLnjLxUqIJNnCWiEdr3bn6IUYi15bNlnbCCU=
github.com/pkg/diff v0.0.0-20210226163009-20ebb0f2a09e/go.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=
github.com/pkg/sftp v1.13.1 h1:I2qBYMChEhIjOgazfJmV3/mZM256btk6wkCDRmW7JYs=
github.com/planetscale/vtprotobuf v0.6.1-0.20240319094008-0393e58bdf10/go.mod h1:t/avpk3KcrXxUnYOhZhMXJlSEyie6gQbtLq5NM3loB8=
github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 h1:Jamvg5psRIccs7FGNTlIRMkT8wgtp5eCXdBlqhYGL6U=
github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/power-devops/perfstat v0.0.0-20240221224432-82ca36839d55/go.mod h1:OmDBASR4679mdNQnz2pUhc2G8CO2JrUAVFDRBDP/hJE=
github.com/prashantv/gostub v1.1.0/go.mod h1:A5zLQHz7ieHGG7is6LLXLz7I8+3LZzsrV0P1IAHhP5U=
github.com/prometheus/client_golang v1.20.4/go.mod h1:PIEt8X02hGcP8JWbeHyeZ53Y/jReSnHgO035n//V5WE=
github.com/prometheus/common v0.66.1/go.mod h1:gcaUsgf3KfRSwHY4dIMXLPV0K/Wg1oZ8+SbZk/HH/dA=
github.com/prometheus/procfs v0.15.1/go.mod h1:fB45yRUv8NstnjriLhBQLuOUt+WW4BsoGhij/e3PBqk=
github.com/prometheus/procfs v0.16.1/go.mod h1:teAbpZRB1iIAJYREa1LsoWUXykVXA1KlTmWl8x/U+Is=
github.com/r3labs/sse/v2 v2.10.0/go.mod h1:Igau6Whc+F17QUgML1fYe1VPZzTV6EMCnYktEmkNJ7I=
github.com/redis/go-redis/v9 v9.0.5 h1:CuQcn5HIEeK7BgElubPP8CGtE0KakrnbBSTLjathl5o=
github.com/redis/go-redis/v9 v9.0.5/go.mod h1:WqMKv5vnQbRuZstUwxQI195wHy+t4PuXDOjzMvcuQHk=
github.com/redis/go-redis/v9 v9.6.3/go.mod h1:0C0c6ycQsdpVNQpxb1njEQIqkx5UcsM8FJCQLgE9+RA=
github.com/rogpeppe/fastuuid v1.2.0 h1:Ppwyp6VYCF1nvBTXL3trRso7mXMlRrw9ooo375wvi2s=
github.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=
github.com/rogpeppe/go-internal v1.10.0/go.mod h1:UQnix2H7Ngw/k4C5ijL5+65zddjncjaFoBhdsK/akog=
github.com/russross/blackfriday/v2 v2.1.0 h1:JIOH55/0cWyOuilr9/qlrm0BSXldqnqwMsf35Ld67mk=
github.com/sagikazarmark/crypt v0.9.0 h1:fipzMFW34hFUEc4D7fsLQFtE7yElkpgyS2zruedRdZk=
github.com/sagikazarmark/crypt v0.9.0/go.mod h1:RnH7sEhxfdnPm1z+XMgSLjWTEIjyK4z2dw6+4vHTMuo=
github.com/shirou/gopsutil/v4 v4.25.5/go.mod h1:PfybzyydfZcN+JMMjkF6Zb8Mq1A/VcogFFg7hj50W9c=
github.com/shirou/gopsutil/v4 v4.25.6/go.mod h1:PfybzyydfZcN+JMMjkF6Zb8Mq1A/VcogFFg7hj50W9c=
github.com/shurcooL/sanitized_anchor_name v1.0.0 h1:PdmoCO6wvbs+7yrJyMORt4/BmY5IYyJwS/kOiWx8mHo=
github.com/shurcooL/sanitized_anchor_name v1.0.0/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=
github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d h1:zE9ykElWQ6/NYmHa3jpm/yHnI4xSofP+UP6SpjHcSeM=
github.com/smartystreets/goconvey v1.6.4 h1:fv0U8FUIMPNf1L9lnHLvLhgicrIVChEkdzIKYqbNC9s=
github.com/spiffe/go-spiffe/v2 v2.6.0/go.mod h1:gm2SeUoMZEtpnzPNs2Csc0D/gX33k1xIx7lEzqblHEs=
github.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=
github.com/testcontainers/testcontainers-go v0.38.0/go.mod h1:C52c9MoHpWO+C4aqmgSU+hxlR5jlEayWtgYrb8Pzz1w=
github.com/testcontainers/testcontainers-go v0.39.0/go.mod h1:qmHpkG7H5uPf/EvOORKvS6EuDkBUPE3zpVGaH9NL7f8=
github.com/testcontainers/testcontainers-go/modules/localstack v0.38.0/go.mod h1:BTsbqWC9huPV8Jg8k46Jz4x1oRAA9XGxneuuOOIrtKY=
github.com/testcontainers/testcontainers-go/modules/localstack v0.39.0/go.mod h1:RA935srUbMJu+owHmdRKF12/rl2aifgHqx/hSpPwcJ4=
github.com/thrawn01/args v0.3.0 h1:XbMnfGaw6nFbm8hgSncHu20cGrZMTP8BnxiusA43AeE=
github.com/tidwall/gjson v1.17.1 h1:wlYEnwqAHgzmhNUFfw7Xalt2JzQvsMx2Se4PcoFCT/U=
github.com/tidwall/gjson v1.17.1/go.mod h1:/wbyibRr2FHMks5tjHJ5F8dMZh3AcwJEMf5vlfC0lxk=
github.com/tidwall/gjson v1.18.0/go.mod h1:/wbyibRr2FHMks5tjHJ5F8dMZh3AcwJEMf5vlfC0lxk=
github.com/tidwall/match v1.1.1/go.mod h1:eRSPERbgtNPcGhD8UCthc6PmLEQXEWd3PRB5JTxsfmM=
github.com/tidwall/pretty v1.2.1/go.mod h1:ITEVvHYasfjBbM0u2Pg8T2nJnzm8xPwvNhhsoaGGjNU=
github.com/tklauser/go-sysconf v0.3.13/go.mod h1:zwleP4Q4OehZHGn4CYZDipCgg9usW5IJePewFCGVEa0=
github.com/tklauser/numcpus v0.7.0/go.mod h1:bb6dMVcj8A42tSE7i32fsIUCbQNllK5iDguyOZRUzAY=
github.com/urfave/cli v1.22.15 h1:nuqt+pdC/KqswQKhETJjo7pvn/k4xMUxgW6liI7XpnM=
github.com/urfave/cli v1.22.15/go.mod h1:wSan1hmo5zeyLGBjRJbzRTNk8gwoYa2B9n4q9dmRIc0=
github.com/xhit/go-str2duration/v2 v2.1.0 h1:lxklc02Drh6ynqX+DdPyp5pCKLUQpRT8bp8Ydu2Bstc=
github.com/xhit/go-str2duration/v2 v2.1.0/go.mod h1:ohY8p+0f07DiV6Em5LKB0s2YpLtXVyJfNt1+BlmyAsU=
github.com/xyproto/randomstring v1.0.5/go.mod h1:rgmS5DeNXLivK7YprL0pY+lTuhNQW3iGxZ18UQApw/E=
github.com/yuin/goldmark v1.4.13 h1:fVcFKWvrslecOb/tg+Cc05dkeYx540o0FuFt3nUVDoE=
github.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=
github.com/yusufpapurcu/wmi v1.2.4/go.mod h1:SBZ9tNy3G9/m5Oi98Zks0QjeHVDvuK0qfxQmPyzfmi0=
github.com/zeebo/errs v1.4.0/go.mod h1:sgbWHsvVuTPHcqJJGQ1WhI5KbWlHYz+2+2C/LSEtCw4=
go.etcd.io/etcd/etcdutl/v3 v3.5.11 h1:yzw6yHDYfKU3IW7akusVCmxXJexRgH88a4C21iOSWFc=
go.etcd.io/etcd/etcdutl/v3 v3.5.11/go.mod h1:p7jTKqjyEjl/lyTzhHuQ5kqQt1FhQlRHw8TK90WjHQI=
go.etcd.io/gofail v0.1.0 h1:XItAMIhOojXFQMgrxjnd2EIIHun/d5qL0Pf7FzVTkFg=
go.etcd.io/gofail v0.1.0/go.mod h1:VZBCXYGZhHAinaBiiqYvuDynvahNsAyLFwB3kEHKz1M=
go.opencensus.io v0.24.0 h1:y73uSU6J157QMP2kn2r30vwW1A2W2WFwSCGnAVxeaD0=
go.opencensus.io v0.24.0/go.mod h1:vNK8G9p7aAivkbmorf4v+7Hgx+Zs0yY+0fOtgBfjQKo=
go.opentelemetry.io/auto/sdk v1.1.0/go.mod h1:3wSPjt5PWp2RhlCcmmOial7AvC4DQqZb7a7wCow3W8A=
go.opentelemetry.io/contrib/detectors/gcp v1.38.0/go.mod h1:SU+iU7nu5ud4oCb3LQOhIZ3nRLj6FNVrKgtflbaf2ts=
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0/go.mod h1:p8pYQP+m5XfbZm9fxtSKAbM6oIllS7s2AfxrChvc7iw=
go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc v1.38.0/go.mod h1:GAXRxmLJcVM3u22IjTg74zWBrRCKq8BnOqUVLodpcpw=
go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetrichttp v1.38.0/go.mod h1:ZQM5lAJpOsKnYagGg/zV2krVqTtaVdYdDkhMoX6Oalg=
go.opentelemetry.io/proto/otlp v1.7.1/go.mod h1:b2rVh6rfI/s2pHWNlB7ILJcRALpcNDzKhACevjI+ZnE=
go.uber.org/automaxprocs v1.6.0/go.mod h1:ifeIMSnPZuznNm6jmdzmU3/bfk01Fe2fotchwEFJ8r8=
go.yaml.in/yaml/v2 v2.4.2/go.mod h1:081UH+NErpNdqlCXm3TtEran0rJZGxAYx9hb/ELlsPU=
go.yaml.in/yaml/v3 v3.0.4/go.mod h1:DhzuOOF2ATzADvBadXxruRBLzYTpT36CKvDb3+aBEFg=
golang.org/x/crypto v0.37.0/go.mod h1:vg+k43peMZ0pUMhYmVAWysMK35e6ioLh3wB8ZCAfbVc=
golang.org/x/crypto v0.43.0/go.mod h1:BFbav4mRNlXJL4wNeejLpWxB7wMbc79PdRGhWKncxR0=
golang.org/x/crypto v0.44.0/go.mod h1:013i+Nw79BMiQiMsOPcVCB5ZIJbYkerPrGnOa00tvmc=
golang.org/x/crypto/x509roots/fallback v0.0.0-20240604170348-d4e7c9cb6cb8 h1:+kWDWI3Eb5cPIOr4cP+R2RLDwK3/dXppL+7XmSOh2LA=
golang.org/x/crypto/x509roots/fallback v0.0.0-20240604170348-d4e7c9cb6cb8/go.mod h1:kNa9WdvYnzFwC79zRpLRMJbdEFlhyM5RPFBBZp/wWH8=
golang.org/x/crypto/x509roots/fallback v0.0.0-20251009181029-0b7aa0cfb07b/go.mod h1:MEIPiCnxvQEjA4astfaKItNwEVZA5Ki+3+nyGbJ5N18=
golang.org/x/exp v0.0.0-20200224162631-6cc2880d07d6 h1:QE6XYQK6naiK1EPAe1g/ILLxN5RBoH5xkJk3CqlMI/Y=
golang.org/x/image v0.0.0-20190802002840-cff245a6509b h1:+qEpEAPhDZ1o0x3tHzZTQDArnOixOzGD9HUJfcg0mb4=
golang.org/x/image v0.25.0/go.mod h1:tCAmOEGthTtkalusGp1g3xa2gke8J6c2N565dTyl9Rs=
golang.org/x/lint v0.0.0-20201208152925-83fdc39ff7b5 h1:2M3HP5CCK1Si9FQhwnzYhXdG6DXeebvUHFpre8QvbyI=
golang.org/x/mobile v0.0.0-20190719004257-d2bd2a29d028 h1:4+4C/Iv2U4fMZBiMCc98MG1In4gJY5YRhtpDNeDeHWs=
golang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
golang.org/x/mod v0.14.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=
golang.org/x/mod v0.21.0/go.mod h1:6SkKJ3Xj0I0BrPOZoBy3bdMptDDU9oJrpohJ3eWZ1fY=
golang.org/x/net v0.22.0/go.mod h1:JKghWKKOSdJwpW2GEx0Ja7fmaKnMsbu+MWVZTokSYmg=
golang.org/x/net v0.25.0/go.mod h1:JkAGAh7GEvH74S6FOH42FLoXpXbE/aqXSrIQjXgsiwM=
golang.org/x/net v0.26.0/go.mod h1:5YKkiSynbBIh3p6iOc/vibscux0x38BZDkn8sCUPxHE=
golang.org/x/net v0.38.0/go.mod h1:ivrbrMbzFq5J41QOQh0siUuly180yBYtLp+CKbEaFx8=
golang.org/x/net v0.41.0/go.mod h1:B/K4NNqkfmg07DQYrbwvSluqCJOOXwUjeb/5lOisjbA=
golang.org/x/net v0.43.0/go.mod h1:vhO1fvI4dGsIjh73sWfUVjj3N7CA9WkKJNQm2svM6Jg=
golang.org/x/net v0.46.0/go.mod h1:Q9BGdFy1y4nkUwiLvT5qtyhAnEHgnQ/zd8PfU6nc210=
golang.org/x/net v0.46.1-0.20251013234738-63d1a5100f82/go.mod h1:Q9BGdFy1y4nkUwiLvT5qtyhAnEHgnQ/zd8PfU6nc210=
golang.org/x/oauth2 v0.18.0/go.mod h1:Wf7knwG0MPoWIMMBgFlEaSUDaKskp0dCfrlJRJXbBi8=
golang.org/x/oauth2 v0.20.0 h1:4mQdhULixXKP1rwYBW0vAijoXnkTG0BLCDRzfe1idMo=
golang.org/x/oauth2 v0.20.0/go.mod h1:XYTD2NtWslqkgxebSiOHnXEap4TF09sJSc7H1sXbhtI=
golang.org/x/oauth2 v0.30.0/go.mod h1:B++QgG3ZKulg6sRPGD/mqlHQs5rB3Ml9erfeDY7xKlU=
golang.org/x/oauth2 v0.32.0/go.mod h1:lzm5WQJQwKZ3nwavOZ3IS5Aulzxi68dUSgRHujetwEA=
golang.org/x/sync v0.8.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/sync v0.17.0/go.mod h1:9KTHXmSnoGruLpwFjVSX0lNNA75CykiMECbovNTZqGI=
golang.org/x/sys v0.10.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.18.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/sys v0.25.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/sys v0.26.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/sys v0.31.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
golang.org/x/sys v0.32.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
golang.org/x/sys v0.33.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
golang.org/x/sys v0.35.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
golang.org/x/sys v0.37.0/go.mod h1:OgkHotnGiDImocRcuBABYBEXf8A9a87e/uXjp9XT3ks=
golang.org/x/telemetry v0.0.0-20240521205824-bda55230c457 h1:zf5N6UOrA487eEFacMePxjXAJctxKmyjKUsjA11Uzuk=
golang.org/x/telemetry v0.0.0-20240521205824-bda55230c457/go.mod h1:pRgIJT+bRLFKnoM1ldnzKoxTIn14Yxz928LQRYYgIN0=
golang.org/x/telemetry v0.0.0-20251008203120-078029d740a8/go.mod h1:Pi4ztBfryZoJEkyFTI5/Ocsu2jXyDr6iSdgJiYE/uwE=
golang.org/x/term v0.27.0 h1:WP60Sv1nlK1T6SupCHbXzSaN0b9wUmsPoRS9b61A23Q=
golang.org/x/term v0.37.0/go.mod h1:5pB4lxRNYYVZuTLmy8oR2BH8dflOR+IbTYFD8fi3254=
golang.org/x/text v0.3.8/go.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=
golang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
golang.org/x/text v0.16.0/go.mod h1:GhwF1Be+LQoKShO3cGOHzqOgRrGaYc9AvblQOmPVHnI=
golang.org/x/text v0.23.0/go.mod h1:/BLNzu4aZCJ1+kcD0DNRotWKage4q2rGVAg4o22unh4=
golang.org/x/text v0.28.0/go.mod h1:U8nCwOR8jO/marOQ0QbDiOngZVEBB7MAiitBuMjXiNU=
golang.org/x/text v0.29.0/go.mod h1:7MhJOA9CD2qZyOKYazxdYMF85OwPdEr9jTtBpO7ydH4=
golang.org/x/text v0.30.0/go.mod h1:yDdHFIX9t+tORqspjENWgzaCVXgk0yYnYuSZ8UzzBVM=
golang.org/x/tools v0.11.0/go.mod h1:anzJrxPjNtfgiYQYirP2CPGzGLxrH2u2QBhn6Bf3qY8=
golang.org/x/tools v0.17.0/go.mod h1:xsh6VxdV005rRVaS6SSAf9oiAqljS7UZUacMZ8Bnsps=
golang.org/x/tools v0.26.0/go.mod h1:TPVVj70c7JJ3WCazhD8OdXcZg/og+b9+tH/KxylGwH0=
golang.org/x/tools v0.37.0/go.mod h1:MBN5QPQtLMHVdvsbtarmTNukZDdgwdwlO5qGacAzF0w=
golang.org/x/xerrors v0.0.0-20220907171357-04be3eba64a2 h1:H2TDz8ibqkAF6YGhCdN3jS9O0/s90v0rJh3X/OLHEUk=
golang.org/x/xerrors v0.0.0-20220907171357-04be3eba64a2/go.mod h1:K8+ghG5WaK9qNqU5K3HdILfMLy1f3aNYFI/wnl100a8=
gonum.org/v1/plot v0.15.2/go.mod h1:DX+x+DWso3LTha+AdkJEv5Txvi+Tql3KAGkehP0/Ubg=
google.golang.org/api v0.107.0 h1:I2SlFjD8ZWabaIFOfeEDg3pf0BHJDh6iYQ1ic3Yu/UU=
google.golang.org/api v0.107.0/go.mod h1:2Ts0XTHNVWxypznxWOYUeI4g3WdP9Pk2Qk58+a/O9MY=
google.golang.org/appengine v1.6.8 h1:IhEN5q69dyKagZPYMSdIjS2HqprW324FRQZJcGqPAsM=
google.golang.org/appengine v1.6.8/go.mod h1:1jJ3jBArFh5pcgW8gCtRJnepW8FzD1V44FJffLiz/Ds=
google.golang.org/genproto/googleapis/api v0.0.0-20240318140521-94a12d6c2237/go.mod h1:Z5Iiy3jtmioajWHDGFk7CeugTyHtPvMHA4UTmUkyalE=
google.golang.org/genproto/googleapis/api v0.0.0-20250825161204-c5933d9347a5/go.mod h1:j3QtIyytwqGr1JUDtYXwtMXWPKsEa5LtzIFN1Wn5WvE=
google.golang.org/genproto/googleapis/api v0.0.0-20250929231259-57b25ae835d4/go.mod h1:NnuHhy+bxcg30o7FnVAZbXsPHUDQ9qKWAQKCD7VxFtk=
google.golang.org/genproto/googleapis/api v0.0.0-20251022142026-3a174f9686a8/go.mod h1:fDMmzKV90WSg1NbozdqrE64fkuTv6mlq2zxo9ad+3yo=
google.golang.org/genproto/googleapis/rpc v0.0.0-20231106174013-bbf56f31fb17/go.mod h1:oQ5rr10WTTMvP4A36n8JpR1OrO1BEiV4f78CneXZxkA=
google.golang.org/genproto/googleapis/rpc v0.0.0-20240318140521-94a12d6c2237/go.mod h1:WtryC6hu0hhx87FDGxWCDptyssuo68sk10vYjF+T9fY=
google.golang.org/genproto/googleapis/rpc v0.0.0-20240624140628-dc46fd24d27d/go.mod h1:Ue6ibwXGpU+dqIcODieyLOcgj7z8+IcskoNIgZxtrFY=
google.golang.org/genproto/googleapis/rpc v0.0.0-20250825161204-c5933d9347a5/go.mod h1:M4/wBTSeyLxupu3W3tJtOgB14jILAS/XWPSSa3TAlJc=
google.golang.org/genproto/googleapis/rpc v0.0.0-20250929231259-57b25ae835d4/go.mod h1:HSkG/KdJWusxU1F6CNrwNDjBMgisKxGnc5dAZfT0mjQ=
google.golang.org/genproto/googleapis/rpc v0.0.0-20251022142026-3a174f9686a8/go.mod h1:7i2o+ce6H/6BluujYR+kqX3GKH+dChPTQU19wjRPiGk=
google.golang.org/genproto/googleapis/rpc v0.0.0-20251103181224-f26f9409b101/go.mod h1:7i2o+ce6H/6BluujYR+kqX3GKH+dChPTQU19wjRPiGk=
google.golang.org/grpc v1.38.0/go.mod h1:NREThFqKR1f3iQ6oBuvc5LadQuXVGo9rkm5ZGrQdJfM=
google.golang.org/grpc v1.61.0/go.mod h1:VUbo7IFqmF1QtCAstipjG0GIoq49KvMe9+h1jFLBNJs=
google.golang.org/grpc v1.71.0/go.mod h1:H0GRtasmQOh9LkFoCPDu3ZrwUtD1YGE+b2vYBYd/8Ec=
google.golang.org/grpc v1.75.0/go.mod h1:JtPAzKiq4v1xcAB2hydNlWI2RnF85XXcV0mhKXr2ecQ=
google.golang.org/grpc v1.75.1/go.mod h1:JtPAzKiq4v1xcAB2hydNlWI2RnF85XXcV0mhKXr2ecQ=
google.golang.org/grpc/examples v0.0.0-20250407062114-b368379ef8f6/go.mod h1:6ytKWczdvnpnO+m+JiG9NjEDzR1FJfsnmJdG7B8QVZ8=
google.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=
google.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=
google.golang.org/protobuf v1.33.0/go.mod h1:c6P6GXX6sHbq/GpV6MGZEdwhWPcYBgnhAHhKbcUYpos=
google.golang.org/protobuf v1.36.6/go.mod h1:jduwjTPXsFjZGTmRluh+L6NjiWu7pchiJ2/5YcXBHnY=
google.golang.org/protobuf v1.36.8/go.mod h1:fuxRtAxBytpl4zzqUh6/eyUujkJdNiuEkXntxiD/uRU=
gopkg.in/cenkalti/backoff.v1 v1.1.0/go.mod h1:J6Vskwqd+OMVJl8C33mmtxTBs2gyzfv7UDAkHu8BrjI=
gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/errgo.v2 v2.1.0 h1:0vLT13EuvQ0hNvakwLuFZ/jYrLp5F3kcWHXdRggjCE8=
gopkg.in/fsnotify.v1 v1.4.7 h1:xOHLXZwVvI9hhs+cLKq5+I5onOuwQLhQwiu63xxlHs4=
honnef.co/go/tools v0.0.1-2020.1.4 h1:UoveltGrhghAA7ePc+e+QYDHXrBps2PqFZiHkGR/xK8=
rsc.io/binaryregexp v0.2.0 h1:HfqmD5MEmC0zvwBuF187nq9mdnXjXsSivRiXN7SmRkE=
rsc.io/pdf v0.1.1/go.mod h1:n8OzWcQ6Sp37PL01nO98y4iUCRdTGarVfzxY20ICaU4=
rsc.io/quote/v3 v3.1.0 h1:9JKUTTIUgS6kzR9mK1YuGKv6Nl+DijDNIc0ghT58FaY=
rsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/QiW4=

```

`main.go`:

```go
/*
Copyright 2024 Wildlife Studios

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import "github.com/topfreegames/pitaya/v3/cmd"

func main() {
	cmd.Execute()
}

```

`pkg/acceptor/acceptor.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package acceptor

import "net"

// PlayerConn iface
type PlayerConn interface {
	GetNextMessage() (b []byte, err error)
	RemoteAddr() net.Addr
	net.Conn
}

// Acceptor type interface
type Acceptor interface {
	ListenAndServe()
	Stop()
	GetAddr() string
	GetConnChan() chan PlayerConn
	EnableProxyProtocol()
	IsRunning() bool
	GetConfiguredAddress() string
}

```

`pkg/acceptor/fixtures/server.crt`:

```crt
-----BEGIN CERTIFICATE-----
MIIDdDCCAlwCCQDfEyb9MASNvjANBgkqhkiG9w0BAQsFADB8MQswCQYDVQQGEwJC
UjELMAkGA1UECAwCU1AxCzAJBgNVBAcMAlNQMQ8wDQYDVQQKDAZQaXRheWExEDAO
BgNVBAsMB0JhY2tlbmQxEjAQBgNVBAMMCWxvY2FsaG9zdDEcMBoGCSqGSIb3DQEJ
ARYNcGl0YXlhQHBpdGF5YTAeFw0xODA0MTAyMjEwMTNaFw0yODA0MDcyMjEwMTNa
MHwxCzAJBgNVBAYTAkJSMQswCQYDVQQIDAJTUDELMAkGA1UEBwwCU1AxDzANBgNV
BAoMBlBpdGF5YTEQMA4GA1UECwwHQmFja2VuZDESMBAGA1UEAwwJbG9jYWxob3N0
MRwwGgYJKoZIhvcNAQkBFg1waXRheWFAcGl0YXlhMIIBIjANBgkqhkiG9w0BAQEF
AAOCAQ8AMIIBCgKCAQEArUveZUOOW2Yl92KpvaAYCwjGy3krUbeSEC0m/FbogWz6
3PhFNsobKwp4z8UrgJEGQJZTpA4XU4O1MIw9f+u7qbdJxn4sM9aeYyw5ks7VdgdQ
Wy70EJ2qOElhq2I7n0/Dg6cYmOVYif4BHq5mlVYCujKcpsU+bscPaTqxHu+/4QUH
cBAkcm6nC2ucRZsSdTD/M5uxatSjJK6ustgUN3TLMzFSRC6/kvS2/dwIgWeePnID
nFZaAWxq4tlE3oG2aIH7oRMSDpRj29d9DjvoQUPSdnADbkq6+n3GKPPqLo3ArQxx
gvfKKQFgGyTtTUKZQ95BJCFE+SDIxTc/9YxcTsdxDQIDAQABMA0GCSqGSIb3DQEB
CwUAA4IBAQApWiKBLHDrDuwUMS1OESzr1obWesaA3hGXtgEn31+tr0bNeV1F/ZjZ
KhUBGm4kcLERuc7w+J268PDyU3C8tf4ar5NFgAbUgfE2mD6+LGTsSdS06fJVakjl
v1i4mK6eijC3XkWyP8yIVJRSn+uvR7PGXmRFJoQIv96y918UYLgwvh/do4P/JZYy
VNR99XvznijV7Hq0aP4W742PjWjj5/cPFnRJOMNPKFupZvYaKWVv2c1IO4HKkCQ4
FRyO6PIxgNDGOz8Bkc4Z7CMbOyBRpElvOFAE5hsxIufn8DgRkQahfiBOjqpSHq73
eyuaAd8sURZSDx8ToT2loVh+dlSsqtNI
-----END CERTIFICATE-----

```

`pkg/acceptor/fixtures/server.key`:

```key
-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCtS95lQ45bZiX3
Yqm9oBgLCMbLeStRt5IQLSb8VuiBbPrc+EU2yhsrCnjPxSuAkQZAllOkDhdTg7Uw
jD1/67upt0nGfiwz1p5jLDmSztV2B1BbLvQQnao4SWGrYjufT8ODpxiY5ViJ/gEe
rmaVVgK6MpymxT5uxw9pOrEe77/hBQdwECRybqcLa5xFmxJ1MP8zm7Fq1KMkrq6y
2BQ3dMszMVJELr+S9Lb93AiBZ54+cgOcVloBbGri2UTegbZogfuhExIOlGPb130O
O+hBQ9J2cANuSrr6fcYo8+oujcCtDHGC98opAWAbJO1NQplD3kEkIUT5IMjFNz/1
jFxOx3ENAgMBAAECggEBAIglsvObv5vPBMT2nqR7wmfo3UW+TGpG7loHHzngjYoh
NHWmF7qTzgRilcemACdhyKe1csDQ0UKrlw4tH6QAb89GUI/BULjpREZl2FWeadXw
qRD6MoVbWQAfprwe0Pi4kcI85PY6OPUwuXCBU9a/XCUs3iWnkQU3HsRtd/n2IamG
HooKGz5Ij1+FaB2dKUiwYvxsdA9w2Yg54VuuLce/6VgnR79eYEseGvN44Y68JAsU
nwzsXv9eVmn8T22/uWaaDPOaIwysVNI5YI+WyfcI9HQIaJxVAPggoZh4N6pnD6UM
BjI+EJWD3Aiq1Z6CDG4c2FV4Ku0f/l456ykvZrosbAECgYEA3eMTLC0l7H+Msndz
aUzimKqstPKBWqyJ3Z6sXYGO26/z3mZjcl1+A4gZGWegptMk6PsP27jevWRVPuNi
o/eagGcJ3wpNISkwoJgvkhPDmFSFH+d74yCQQRgPsuJbyaHX+RiDTj4sWgBWoq+T
UR9GQxFmGObklMmBF0o/VeU9XjUCgYEAx/BixVC4gvqBKZdlhLF8e6HWFXhNCIsj
0H6I5vgtSex8I/Zsy320kA0hfzZEuaaGVNrQiYWBAAdAwTKS3W13X8ryBDS6mrCs
BKuM7PDJrS4vKVmiTqMwDpEpL/c9SoOCiPiseZeteoHfKkVsPoQrc2bQzvfttQa6
aHRvyjkTgnkCgYByYbRoeX2rRLVK6rjb9354JMOTI8/65ibL0Bgau8bhCPs2EqIB
OqDTQT1vEzSFyyKj14h9Q/fOugIXwTAARoum1XcJO043YfxnTQx4ySdzR16466O5
mffDFpxBIt8eOggTqMdHdlV2r+X5R3kxwGV//WAcRipfaODbGLM9nEbeYQKBgQCL
JJ8IZLHT7VQARu2OmBpiy/D6RhuOK48EJVtPKj4SaTLHsFJsl5IWghzitDjF3r8z
xIhGfJOXGnUVPwX4dZsTHmCpTqzixLsiEOVla/levXpy039iLK1gJeO9DtonxjgM
7MrTYByJ2mIdv+yh4Ud/63i74M0cI4+M7CN0X55VOQKBgDw0A5cdenE5VIH2nEsx
SWQ8nSz2qli+59sUcRfDnAWT7iJ5DCzxOVV+wQ/A3D/SbufWJQZpJBSJlXnyY1BX
qFiOrseNsU2R0EDmi8agdgVBqxX/NmF9+Np0G3dFyoeYI68BwpiteCa/Aw2HzPl5
2SJrVnL52ZOK5WAumUbuWQqA
-----END PRIVATE KEY-----

```

`pkg/acceptor/proxyprotowrapper.go`:

```go
package acceptor

import (
	"net"
	"sync"

	"github.com/mailgun/proxyproto"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
)

// Listener is used to wrap an underlying listener,
// whose connections may be using the HAProxy Proxy Protocol.
// If the connection is using the protocol, the RemoteAddr() will return
// the correct client address.
type ProxyProtocolListener struct {
	net.Listener
	proxyProtocolEnabled *bool
}

// Accept waits for and returns the next connection to the listener.
func (p *ProxyProtocolListener) Accept() (net.Conn, error) {
	// Get the underlying connection
	conn, err := p.Listener.Accept()
	if err != nil {
		return nil, err
	}
	connP := &Conn{Conn: conn, proxyProtocolEnabled: p.proxyProtocolEnabled}
	if *p.proxyProtocolEnabled {
		err = connP.checkPrefix()
		if err != nil {
			return connP, err
		}
	}
	return connP, nil
}

// Conn is used to wrap and underlying connection which
// may be speaking the Proxy Protocol. If it is, the RemoteAddr() will
// return the address of the client instead of the proxy address.
type Conn struct {
	net.Conn
	dstAddr              *net.Addr
	srcAddr              *net.Addr
	once                 sync.Once
	proxyProtocolEnabled *bool
}

func (p *Conn) LocalAddr() net.Addr {
	if p.dstAddr != nil {
		return *p.dstAddr
	}
	return p.Conn.LocalAddr()
}

// RemoteAddr returns the address of the client if the proxy
// protocol is being used, otherwise just returns the address of
// the socket peer. If there is an error parsing the header, the
// address of the client is not returned, and the socket is closed.
// Once implication of this is that the call could block if the
// client is slow. Using a Deadline is recommended if this is called
// before Read()
func (p *Conn) RemoteAddr() net.Addr {
	if p.srcAddr != nil {
		return *p.srcAddr
	}
	return p.Conn.RemoteAddr()
}

func (p *Conn) checkPrefix() error {

	h, err := proxyproto.ReadHeader(p)
	if err != nil {
		logger.Log.Errorf("Failed to read Proxy Protocol TCP header: %s", err.Error())
		p.Close()
		return err

	} else if h.Source == nil {
		p.Close()
	} else {
		p.srcAddr = &h.Source
		p.dstAddr = &h.Destination
	}

	return nil
}

```

`pkg/acceptor/tcp_acceptor.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package acceptor

import (
	"crypto/tls"
	"fmt"
	"io"
	"net"

	"github.com/topfreegames/pitaya/v3/pkg/conn/codec"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
)

// TCPAcceptor struct
type TCPAcceptor struct {
	addr          string
	connChan      chan PlayerConn
	listener      net.Listener
	running       bool
	certs         []tls.Certificate
	proxyProtocol bool
}

type tcpPlayerConn struct {
	net.Conn
	remoteAddr net.Addr
}

func (t *tcpPlayerConn) RemoteAddr() net.Addr {
	return t.remoteAddr
}

// GetNextMessage reads the next message available in the stream
func (t *tcpPlayerConn) GetNextMessage() (b []byte, err error) {
	header, err := io.ReadAll(io.LimitReader(t.Conn, codec.HeadLength))
	if err != nil {
		return nil, err
	}
	// if the header has no data, we can consider it as a closed connection
	if len(header) == 0 {
		return nil, constants.ErrConnectionClosed
	}
	msgSize, _, err := codec.ParseHeader(header)
	if err != nil {
		return nil, err
	}
	msgData, err := io.ReadAll(io.LimitReader(t.Conn, int64(msgSize)))
	if err != nil {
		return nil, err
	}
	if len(msgData) < msgSize {
		return nil, constants.ErrReceivedMsgSmallerThanExpected
	}
	return append(header, msgData...), nil
}

// NewTCPAcceptor creates a new instance of tcp acceptor
func NewTCPAcceptor(addr string, certs ...string) *TCPAcceptor {
	certificates := []tls.Certificate{}
	if len(certs) != 2 && len(certs) != 0 {
		panic(constants.ErrIncorrectNumberOfCertificates)
	} else if len(certs) == 2 && certs[0] != "" && certs[1] != "" {
		cert, err := tls.LoadX509KeyPair(certs[0], certs[1])
		if err != nil {
			panic(fmt.Errorf("%w: %v", constants.ErrInvalidCertificates, err))
		}
		certificates = append(certificates, cert)
	}

	return NewTLSAcceptor(addr, certificates...)
}

func NewTLSAcceptor(addr string, certs ...tls.Certificate) *TCPAcceptor {
	return &TCPAcceptor{
		addr:          addr,
		connChan:      make(chan PlayerConn),
		running:       false,
		certs:         certs,
		proxyProtocol: false,
	}
}

// GetAddr returns the addr the acceptor will listen on
func (a *TCPAcceptor) GetAddr() string {
	if a.listener != nil {
		return a.listener.Addr().String()
	}
	return ""
}

// GetConnChan gets a connection channel
func (a *TCPAcceptor) GetConnChan() chan PlayerConn {
	return a.connChan
}

// Stop stops the acceptor
func (a *TCPAcceptor) Stop() {
	a.running = false
	a.listener.Close()
}

func (a *TCPAcceptor) hasTLSCertificates() bool {
	return len(a.certs) > 0
}

// ListenAndServe using tcp acceptor
func (a *TCPAcceptor) ListenAndServe() {

	listener := a.createBaseListener()

	if a.hasTLSCertificates() {
		listener = a.listenAndServeTLS(listener)
	}

	a.listener = listener
	a.running = true
	a.serve()
}

// ListenAndServeTLS listens using tls
func (a *TCPAcceptor) ListenAndServeTLS(cert, key string) {
	listener := a.createBaseListener()

	crt, err := tls.LoadX509KeyPair(cert, key)
	if err != nil {
		logger.Log.Fatalf("Failed to listen: %s", err.Error())
	}

	a.certs = append(a.certs, crt)

	a.listener = a.listenAndServeTLS(listener)
	a.running = true
	a.serve()
}

// Create base listener
func (a *TCPAcceptor) createBaseListener() net.Listener {
	// Create raw listener
	baseListener, err := net.Listen("tcp", a.addr)
	if err != nil {
		logger.Log.Fatalf("Failed to listen: %s", err.Error())
	}

	// Wrap listener in ProxyProto
	baseListener = &ProxyProtocolListener{Listener: baseListener, proxyProtocolEnabled: &a.proxyProtocol}

	return baseListener
}

// ListenAndServeTLS listens using tls
func (a *TCPAcceptor) listenAndServeTLS(listener net.Listener) net.Listener {

	tlsCfg := &tls.Config{Certificates: a.certs}
	tlsListener := tls.NewListener(listener, tlsCfg)

	return tlsListener
}

func (a *TCPAcceptor) EnableProxyProtocol() {
	a.proxyProtocol = true
}

func (a *TCPAcceptor) serve() {
	defer a.Stop()
	for a.running {
		conn, err := a.listener.Accept()
		if err != nil {
			logger.Log.Errorf("Failed to accept TCP connection: %s", err.Error())
			continue
		}

		a.connChan <- &tcpPlayerConn{
			Conn:       conn,
			remoteAddr: conn.RemoteAddr(),
		}
	}
}

func (a *TCPAcceptor) IsRunning() bool {
	return a.running
}

func (a *TCPAcceptor) GetConfiguredAddress() string {
	return a.addr
}

```

`pkg/acceptor/tcp_acceptor_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package acceptor

import (
	"net"
	"runtime"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/conn/packet"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/helpers"
)

var tcpAcceptorTables = []struct {
	name     string
	addr     string
	certs    []string
	panicErr string
}{
	{"test_1", "0.0.0.0:0", []string{"./fixtures/server.crt", "./fixtures/server.key"}, ""},
	{"test_2", "0.0.0.0:0", []string{}, ""},
	{"test_3", "127.0.0.1:0", []string{"wqd"}, "certificates must be exactly two"},
	{"test_4", "127.0.0.1:0", []string{"wqd", "wqdqwd"}, "invalid certificates: open wqd: no such file or directory"},
	{"test_5", "127.0.0.1:0", []string{"wqd", "wqdqwd", "wqdqdqwd"}, "certificates must be exactly two"},
}

func TestNewTCPAcceptorGetConnChanAndGetAddr(t *testing.T) {
	t.Parallel()
	for _, table := range tcpAcceptorTables {
		t.Run(table.name, func(t *testing.T) {
			if table.panicErr != "" {
				if table.name == "test_4" && runtime.GOOS == "windows" {
					table.panicErr = "invalid certificates: open wqd: The system cannot find the file specified."
				}
				assert.PanicsWithError(t, table.panicErr, func() {
					NewTCPAcceptor(table.addr, table.certs...)
				})
			} else {
				var a *TCPAcceptor
				assert.NotPanics(t, func() {
					a = NewTCPAcceptor(table.addr, table.certs...)
				})

				if len(table.certs) == 2 {
					assert.Len(t, a.certs, 1)
				} else {
					assert.Len(t, a.certs, 0)
				}
				assert.NotNil(t, a)
			}
		})
	}
}

func TestGetAddr(t *testing.T) {
	t.Parallel()
	for _, table := range tcpAcceptorTables {
		t.Run(table.name, func(t *testing.T) {
			a := NewTCPAcceptor(table.addr)
			// returns nothing because not listening yet
			assert.Equal(t, "", a.GetAddr())
		})
	}
}

func TestGetConnChan(t *testing.T) {
	t.Parallel()
	for _, table := range tcpAcceptorTables {
		t.Run(table.name, func(t *testing.T) {
			a := NewTCPAcceptor(table.addr)
			assert.NotNil(t, a.GetConnChan())
		})
	}
}

func TestListenAndServe(t *testing.T) {
	for _, table := range tcpAcceptorTables {
		t.Run(table.name, func(t *testing.T) {
			a := NewTCPAcceptor(table.addr)
			defer a.Stop()
			c := a.GetConnChan()
			go a.ListenAndServe()
			// should be able to connect within 100 milliseconds
			helpers.ShouldEventuallyReturn(t, func() error {
				_, err := net.Dial("tcp", a.GetAddr())
				return err
			}, nil, 10*time.Millisecond, 100*time.Millisecond)
			conn := helpers.ShouldEventuallyReceive(t, c, 100*time.Millisecond)
			assert.NotNil(t, conn)
		})
	}
}

func TestListenAndServeTLS(t *testing.T) {
	for _, table := range tcpAcceptorTables {
		t.Run(table.name, func(t *testing.T) {
			a := NewTCPAcceptor(table.addr)
			defer a.Stop()
			c := a.GetConnChan()

			go a.ListenAndServeTLS("./fixtures/server.crt", "./fixtures/server.key")
			// should be able to connect within 100 milliseconds
			helpers.ShouldEventuallyReturn(t, func() error {
				_, err := net.Dial("tcp", a.GetAddr())
				return err
			}, nil, 10*time.Millisecond, 100*time.Millisecond)
			conn := helpers.ShouldEventuallyReceive(t, c, 100*time.Millisecond)
			assert.NotNil(t, conn)
		})
	}
}

func TestStop(t *testing.T) {
	for _, table := range tcpAcceptorTables {
		t.Run(table.name, func(t *testing.T) {
			a := NewTCPAcceptor(table.addr)
			go a.ListenAndServe()
			// should be able to connect within 100 milliseconds
			helpers.ShouldEventuallyReturn(t, func() error {
				_, err := net.Dial("tcp", a.GetAddr())
				return err
			}, nil, 10*time.Millisecond, 100*time.Millisecond)
			a.Stop()
			_, err := net.Dial("tcp", table.addr)
			assert.Error(t, err)
		})
	}
}

func TestGetNextMessage(t *testing.T) {
	tables := []struct {
		name string
		data []byte
		err  error
	}{
		{"invalid_header", []byte{0x00, 0x00, 0x00, 0x00}, packet.ErrWrongPomeloPacketType},
		{"valid_message", []byte{0x02, 0x00, 0x00, 0x01, 0x00}, nil},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			a := NewTCPAcceptor("0.0.0.0:0")
			go a.ListenAndServe()
			defer a.Stop()
			c := a.GetConnChan()
			// should be able to connect within 100 milliseconds
			var conn net.Conn
			var err error
			helpers.ShouldEventuallyReturn(t, func() error {
				conn, err = net.Dial("tcp", a.GetAddr())
				return err
			}, nil, 10*time.Millisecond, 100*time.Millisecond)

			defer conn.Close()
			playerConn := helpers.ShouldEventuallyReceive(t, c, 100*time.Millisecond).(PlayerConn)
			_, err = conn.Write(table.data)
			assert.NoError(t, err)

			msg, err := playerConn.GetNextMessage()
			if table.err != nil {
				assert.EqualError(t, err, table.err.Error())
			} else {
				assert.Equal(t, table.data, msg)
				assert.NoError(t, err)
			}
		})
	}
}

func TestGetNextMessageTwoMessagesInBuffer(t *testing.T) {
	a := NewTCPAcceptor("0.0.0.0:0")
	go a.ListenAndServe()
	defer a.Stop()
	c := a.GetConnChan()
	// should be able to connect within 100 milliseconds
	var conn net.Conn
	var err error
	helpers.ShouldEventuallyReturn(t, func() error {
		conn, err = net.Dial("tcp", a.GetAddr())
		return err
	}, nil, 10*time.Millisecond, 100*time.Millisecond)
	defer conn.Close()

	playerConn := helpers.ShouldEventuallyReceive(t, c, 100*time.Millisecond).(PlayerConn)
	msg1 := []byte{0x01, 0x00, 0x00, 0x01, 0x02}
	msg2 := []byte{0x02, 0x00, 0x00, 0x02, 0x01, 0x01}
	buffer := append(msg1, msg2...)
	_, err = conn.Write(buffer)
	assert.NoError(t, err)

	msg, err := playerConn.GetNextMessage()
	assert.NoError(t, err)
	assert.Equal(t, msg1, msg)

	msg, err = playerConn.GetNextMessage()
	assert.NoError(t, err)
	assert.Equal(t, msg2, msg)
}

func TestGetNextMessageEOF(t *testing.T) {
	a := NewTCPAcceptor("0.0.0.0:0")
	go a.ListenAndServe()
	defer a.Stop()
	c := a.GetConnChan()
	// should be able to connect within 100 milliseconds
	var conn net.Conn
	var err error
	helpers.ShouldEventuallyReturn(t, func() error {
		conn, err = net.Dial("tcp", a.GetAddr())
		return err
	}, nil, 10*time.Millisecond, 100*time.Millisecond)

	playerConn := helpers.ShouldEventuallyReceive(t, c, 100*time.Millisecond).(PlayerConn)
	buffer := []byte{0x02, 0x00, 0x00, 0x02, 0x01}
	_, err = conn.Write(buffer)
	assert.NoError(t, err)

	go func() {
		time.Sleep(100 * time.Millisecond)
		conn.Close()
	}()

	_, err = playerConn.GetNextMessage()
	assert.EqualError(t, err, constants.ErrReceivedMsgSmallerThanExpected.Error())
}

func TestGetNextMessageEmptyEOF(t *testing.T) {
	a := NewTCPAcceptor("0.0.0.0:0")
	go a.ListenAndServe()
	defer a.Stop()
	c := a.GetConnChan()
	// should be able to connect within 100 milliseconds
	var conn net.Conn
	var err error
	helpers.ShouldEventuallyReturn(t, func() error {
		conn, err = net.Dial("tcp", a.GetAddr())
		return err
	}, nil, 10*time.Millisecond, 100*time.Millisecond)

	playerConn := helpers.ShouldEventuallyReceive(t, c, 100*time.Millisecond).(PlayerConn)

	go func() {
		time.Sleep(100 * time.Millisecond)
		conn.Close()
	}()

	_, err = playerConn.GetNextMessage()
	assert.EqualError(t, err, constants.ErrConnectionClosed.Error())
}

func TestGetNextMessageInParts(t *testing.T) {
	a := NewTCPAcceptor("0.0.0.0:0")
	go a.ListenAndServe()
	defer a.Stop()
	c := a.GetConnChan()
	// should be able to connect within 100 milliseconds
	var conn net.Conn
	var err error
	helpers.ShouldEventuallyReturn(t, func() error {
		conn, err = net.Dial("tcp", a.GetAddr())
		return err
	}, nil, 10*time.Millisecond, 100*time.Millisecond)

	defer conn.Close()
	playerConn := helpers.ShouldEventuallyReceive(t, c, 100*time.Millisecond).(PlayerConn)
	part1 := []byte{0x02, 0x00, 0x00, 0x03, 0x01}
	part2 := []byte{0x01, 0x02}
	_, err = conn.Write(part1)
	assert.NoError(t, err)

	go func() {
		time.Sleep(200 * time.Millisecond)
		_, err = conn.Write(part2)
	}()

	msg, err := playerConn.GetNextMessage()
	assert.NoError(t, err)
	assert.Equal(t, msg, append(part1, part2...))

}

```

`pkg/acceptor/ws_acceptor.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package acceptor

import (
	"crypto/tls"
	"io"
	"net"
	"net/http"
	"time"

	"github.com/gorilla/websocket"
	"github.com/topfreegames/pitaya/v3/pkg/conn/codec"
	"github.com/topfreegames/pitaya/v3/pkg/conn/packet"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
)

// WSAcceptor struct
type WSAcceptor struct {
	addr     string
	connChan chan PlayerConn
	listener net.Listener
	certFile string
	keyFile  string
	running  bool
}

// NewWSAcceptor returns a new instance of WSAcceptor
func NewWSAcceptor(addr string, certs ...string) *WSAcceptor {
	keyFile := ""
	certFile := ""
	if len(certs) != 2 && len(certs) != 0 {
		panic(constants.ErrInvalidCertificates)
	} else if len(certs) == 2 {
		certFile = certs[0]
		keyFile = certs[1]
	}

	w := &WSAcceptor{
		addr:     addr,
		connChan: make(chan PlayerConn),
		certFile: certFile,
		keyFile:  keyFile,
		running:  false,
	}
	return w
}

func (w *WSAcceptor) IsRunning() bool {
        return w.running
}

func (w *WSAcceptor) GetConfiguredAddress() string {
        return w.addr
}

// GetAddr returns the addr the acceptor will listen on
func (w *WSAcceptor) GetAddr() string {
	if w.listener != nil {
		return w.listener.Addr().String()
	}
	return ""
}

// GetConnChan gets a connection channel
func (w *WSAcceptor) GetConnChan() chan PlayerConn {
	return w.connChan
}

// PROXY protocol support not implemented for WS acceptor
func (w *WSAcceptor) EnableProxyProtocol() {
}

type connHandler struct {
	upgrader *websocket.Upgrader
	connChan chan PlayerConn
}

func (h *connHandler) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	conn, err := h.upgrader.Upgrade(rw, r, nil)
	if err != nil {
		logger.Log.Errorf("Upgrade failure, URI=%s, Error=%s", r.RequestURI, err.Error())
		return
	}

	c, err := NewWSConn(conn)
	if err != nil {
		logger.Log.Errorf("Failed to create new ws connection: %s", err.Error())
		return
	}
	h.connChan <- c
}

func (w *WSAcceptor) hasTLSCertificates() bool {
	return w.certFile != "" && w.keyFile != ""
}

// ListenAndServe listens and serve in the specified addr
func (w *WSAcceptor) ListenAndServe() {
	if w.hasTLSCertificates() {
		w.ListenAndServeTLS(w.certFile, w.keyFile)
		return
	}

	var upgrader = websocket.Upgrader{
		ReadBufferSize:  constants.IOBufferBytesSize,
		WriteBufferSize: constants.IOBufferBytesSize,
		CheckOrigin: func(r *http.Request) bool {
			return true
		},
	}

	listener, err := net.Listen("tcp", w.addr)
	if err != nil {
		logger.Log.Fatalf("Failed to listen: %s", err.Error())
	}
	w.listener = listener
	w.running = true
	w.serve(&upgrader)
}

// ListenAndServeTLS listens and serve in the specified addr using tls
func (w *WSAcceptor) ListenAndServeTLS(cert, key string) {
	var upgrader = websocket.Upgrader{
		ReadBufferSize:  constants.IOBufferBytesSize,
		WriteBufferSize: constants.IOBufferBytesSize,
	}

	crt, err := tls.LoadX509KeyPair(cert, key)
	if err != nil {
		logger.Log.Fatalf("Failed to load x509: %s", err.Error())
	}

	tlsCfg := &tls.Config{Certificates: []tls.Certificate{crt}}
	listener, err := tls.Listen("tcp", w.addr, tlsCfg)
	if err != nil {
		logger.Log.Fatalf("Failed to listen: %s", err.Error())
	}
	w.listener = listener
	w.serve(&upgrader)
}

func (w *WSAcceptor) serve(upgrader *websocket.Upgrader) {
	defer w.Stop()

	http.Serve(w.listener, &connHandler{
		upgrader: upgrader,
		connChan: w.connChan,
	})
}

// Stop stops the acceptor
func (w *WSAcceptor) Stop() {
	w.running = false
	err := w.listener.Close()
	if err != nil {
		logger.Log.Errorf("Failed to stop: %s", err.Error())
	}
}

// WSConn is an adapter to t.Conn, which implements all t.Conn
// interface base on *websocket.Conn
type WSConn struct {
	conn   *websocket.Conn
	typ    int // message type
	reader io.Reader
}

// NewWSConn return an initialized *WSConn
func NewWSConn(conn *websocket.Conn) (*WSConn, error) {
	c := &WSConn{conn: conn}

	return c, nil
}

// GetNextMessage reads the next message available in the stream
func (c *WSConn) GetNextMessage() (b []byte, err error) {
	_, msgBytes, err := c.conn.ReadMessage()
	if err != nil {
		return nil, err
	}
	if len(msgBytes) < codec.HeadLength {
		return nil, packet.ErrInvalidPomeloHeader
	}
	header := msgBytes[:codec.HeadLength]
	msgSize, _, err := codec.ParseHeader(header)
	if err != nil {
		return nil, err
	}
	dataLen := len(msgBytes[codec.HeadLength:])
	if dataLen < msgSize {
		return nil, constants.ErrReceivedMsgSmallerThanExpected
	} else if dataLen > msgSize {
		return nil, constants.ErrReceivedMsgBiggerThanExpected
	}
	return msgBytes, err
}

// Read reads data from the connection.
// Read can be made to time out and return an Error with Timeout() == true
// after a fixed time limit; see SetDeadline and SetReadDeadline.
func (c *WSConn) Read(b []byte) (int, error) {
	if c.reader == nil {
		t, r, err := c.conn.NextReader()
		if err != nil {
			return 0, err
		}
		c.typ = t
		c.reader = r
	}
	n, err := c.reader.Read(b)
	if err != nil && err != io.EOF {
		return n, err
	} else if err == io.EOF {
		_, r, err := c.conn.NextReader()
		if err != nil {
			return 0, err
		}
		c.reader = r
	}

	return n, nil
}

// Write writes data to the connection.
// Write can be made to time out and return an Error with Timeout() == true
// after a fixed time limit; see SetDeadline and SetWriteDeadline.
func (c *WSConn) Write(b []byte) (int, error) {
	err := c.conn.WriteMessage(websocket.BinaryMessage, b)
	if err != nil {
		return 0, err
	}

	return len(b), nil
}

// Close closes the connection.
// Any blocked Read or Write operations will be unblocked and return errors.
func (c *WSConn) Close() error {
	return c.conn.Close()
}

// LocalAddr returns the local network address.
func (c *WSConn) LocalAddr() net.Addr {
	return c.conn.LocalAddr()
}

// RemoteAddr returns the remote network address.
func (c *WSConn) RemoteAddr() net.Addr {
	return c.conn.RemoteAddr()
}

// SetDeadline sets the read and write deadlines associated
// with the connection. It is equivalent to calling both
// SetReadDeadline and SetWriteDeadline.
//
// A deadline is an absolute time after which I/O operations
// fail with a timeout (see type Error) instead of
// blocking. The deadline applies to all future and pending
// I/O, not just the immediately following call to Read or
// Write. After a deadline has been exceeded, the connection
// can be refreshed by setting a deadline in the future.
//
// An idle timeout can be implemented by repeatedly extending
// the deadline after successful Read or Write calls.
//
// A zero value for t means I/O operations will not time out.
func (c *WSConn) SetDeadline(t time.Time) error {
	if err := c.SetReadDeadline(t); err != nil {
		return err
	}

	return c.SetWriteDeadline(t)
}

// SetReadDeadline sets the deadline for future Read calls
// and any currently-blocked Read call.
// A zero value for t means Read will not time out.
func (c *WSConn) SetReadDeadline(t time.Time) error {
	return c.conn.SetReadDeadline(t)
}

// SetWriteDeadline sets the deadline for future Write calls
// and any currently-blocked Write call.
// Even if write times out, it may return n > 0, indicating that
// some of the data was successfully written.
// A zero value for t means Write will not time out.
func (c *WSConn) SetWriteDeadline(t time.Time) error {
	return c.conn.SetWriteDeadline(t)
}

```

`pkg/acceptor/ws_acceptor_test.go`:

```go
package acceptor

import (
	"crypto/tls"
	"fmt"
	"testing"
	"time"

	"github.com/gorilla/websocket"
	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/conn/packet"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/helpers"
)

var wsAcceptorTables = []struct {
	name     string
	addr     string
	write    []byte
	certs    []string
	panicErr error
}{
	// TODO change to allocatable ports
	{"test_1", "0.0.0.0:0", []byte{0x01, 0x02}, []string{"./fixtures/server.crt", "./fixtures/server.key"}, nil},
	{"test_2", "127.0.0.1:0", []byte{0x00}, []string{"./fixtures/server.crt", "./fixtures/server.key"}, nil},
	{"test_3", "0.0.0.0:0", []byte{0x00}, []string{"wqodij"}, constants.ErrInvalidCertificates},
	{"test_4", "0.0.0.0:0", []byte{0x00}, []string{"wqodij", "qwdo", "wod"}, constants.ErrInvalidCertificates},
	{"test_4", "0.0.0.0:0", []byte{0x00}, []string{}, nil},
}

func TestNewWSAcceptor(t *testing.T) {
	t.Parallel()
	for _, table := range wsAcceptorTables {
		t.Run(table.name, func(t *testing.T) {
			if table.panicErr != nil {
				assert.PanicsWithValue(t, table.panicErr, func() {
					NewWSAcceptor(table.addr, table.certs...)
				})
			} else {
				var w *WSAcceptor
				assert.NotPanics(t, func() {
					w = NewWSAcceptor(table.addr, table.certs...)
				})

				if len(table.certs) == 2 {
					assert.Equal(t, table.certs[0], w.certFile)
					assert.Equal(t, table.certs[1], w.keyFile)
				} else {
					assert.Equal(t, "", w.certFile)
					assert.Equal(t, "", w.keyFile)
				}
				assert.NotNil(t, w)
			}
		})
	}
}

func TestWSAcceptorGetAddr(t *testing.T) {
	t.Parallel()
	for _, table := range wsAcceptorTables {
		t.Run(table.name, func(t *testing.T) {
			w := NewWSAcceptor(table.addr)
			// will return empty string because acceptor is not listening
			assert.Equal(t, "", w.GetAddr())
		})
	}
}

func TestWSAcceptorGetConn(t *testing.T) {
	t.Parallel()
	for _, table := range wsAcceptorTables {
		t.Run(table.name, func(t *testing.T) {
			w := NewWSAcceptor(table.addr)
			assert.NotNil(t, w.GetConnChan())
		})
	}
}

func mustConnectToWS(t *testing.T, write []byte, w *WSAcceptor, protocol string) {
	t.Helper()
	helpers.ShouldEventuallyReturn(t, func() error {
		addr := fmt.Sprintf("%s://%s", protocol, w.GetAddr())
		dialer := websocket.DefaultDialer
		conn, _, err := dialer.Dial(addr, nil)
		dialer.TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
		conn.WriteMessage(websocket.BinaryMessage, write)
		return err
	}, nil, 30*time.Millisecond, 100*time.Millisecond)
}

func TestWSAcceptorListenAndServe(t *testing.T) {
	for _, table := range wsAcceptorTables {
		t.Run(table.name, func(t *testing.T) {
			w := NewWSAcceptor(table.addr)
			c := w.GetConnChan()
			defer w.Stop()
			go w.ListenAndServe()
			mustConnectToWS(t, table.write, w, "ws")
			conn := helpers.ShouldEventuallyReceive(t, c, 100*time.Millisecond).(*WSConn)
			assert.NotNil(t, conn)
		})
	}
}

func TestWSAcceptorListenAndServeTLS(t *testing.T) {
	for _, table := range wsAcceptorTables {
		t.Run(table.name, func(t *testing.T) {
			w := NewWSAcceptor(table.addr)
			c := w.GetConnChan()
			defer w.Stop()
			go w.ListenAndServeTLS("./fixtures/server.crt", "./fixtures/server.key")
			mustConnectToWS(t, table.write, w, "wss")
			conn := helpers.ShouldEventuallyReceive(t, c, 100*time.Millisecond).(*WSConn)
			assert.NotNil(t, conn)
		})
	}
}

func TestWSAcceptorStop(t *testing.T) {
	for _, table := range wsAcceptorTables {
		t.Run(table.name, func(t *testing.T) {
			w := NewWSAcceptor(table.addr)
			go w.ListenAndServe()
			mustConnectToWS(t, table.write, w, "ws")
			addr := fmt.Sprintf("ws://%s", w.GetAddr())
			w.Stop()
			_, _, err := websocket.DefaultDialer.Dial(addr, nil)
			assert.Error(t, err)
		})
	}
}

func TestWSConnRead(t *testing.T) {
	for _, table := range wsAcceptorTables {
		t.Run(table.name, func(t *testing.T) {
			w := NewWSAcceptor(table.addr)
			c := w.GetConnChan()
			defer w.Stop()
			go w.ListenAndServe()
			mustConnectToWS(t, table.write, w, "ws")
			conn := helpers.ShouldEventuallyReceive(t, c, 100*time.Millisecond).(*WSConn)
			b := make([]byte, len(table.write))
			n, err := conn.Read(b)
			assert.NoError(t, err)
			assert.Equal(t, len(table.write), n)
			assert.Equal(t, table.write, b)
		})
	}
}

func TestWSConnWrite(t *testing.T) {
	for _, table := range wsAcceptorTables {
		t.Run(table.name, func(t *testing.T) {
			w := NewWSAcceptor(table.addr)
			c := w.GetConnChan()
			defer w.Stop()
			go w.ListenAndServe()
			mustConnectToWS(t, table.write, w, "ws")
			conn := helpers.ShouldEventuallyReceive(t, c, 100*time.Millisecond).(*WSConn)
			b := make([]byte, len(table.write))
			n, err := conn.Write(b)
			assert.NoError(t, err)
			assert.Equal(t, len(table.write), n)
		})
	}
}

func TestWSConnLocalAddr(t *testing.T) {
	for _, table := range wsAcceptorTables {
		t.Run(table.name, func(t *testing.T) {
			w := NewWSAcceptor(table.addr)
			c := w.GetConnChan()
			defer w.Stop()
			go w.ListenAndServe()
			mustConnectToWS(t, table.write, w, "ws")
			conn := helpers.ShouldEventuallyReceive(t, c, 100*time.Millisecond).(*WSConn)
			a := conn.LocalAddr().String()
			assert.NotEmpty(t, a)
		})
	}
}

func TestWSConnRemoteAddr(t *testing.T) {
	for _, table := range wsAcceptorTables {
		t.Run(table.name, func(t *testing.T) {
			w := NewWSAcceptor(table.addr)
			c := w.GetConnChan()
			defer w.Stop()
			go w.ListenAndServe()
			mustConnectToWS(t, table.write, w, "ws")
			conn := helpers.ShouldEventuallyReceive(t, c, 100*time.Millisecond).(*WSConn)
			a := conn.RemoteAddr().String()
			assert.NotEmpty(t, a)
		})
	}
}

func TestWSConnSetDeadline(t *testing.T) {
	for _, table := range wsAcceptorTables {
		t.Run(table.name, func(t *testing.T) {
			w := NewWSAcceptor(table.addr)
			c := w.GetConnChan()
			defer w.Stop()
			go w.ListenAndServe()
			mustConnectToWS(t, table.write, w, "ws")
			conn := helpers.ShouldEventuallyReceive(t, c, 100*time.Millisecond).(*WSConn)
			conn.SetDeadline(time.Now().Add(5 * time.Millisecond))
			time.Sleep(10 * time.Millisecond)
			_, err := conn.Write(table.write)
			assert.Error(t, err)
		})
	}
}

func TestWSGetNextMessage(t *testing.T) {
	tables := []struct {
		name string
		data []byte
		err  error
	}{
		{"invalid_header", []byte{0x00, 0x00, 0x00, 0x00}, packet.ErrWrongPomeloPacketType},
		{"valid_message", []byte{0x02, 0x00, 0x00, 0x01, 0x00}, nil},
		{"invalid_message", []byte{0x02, 0x00, 0x00, 0x02, 0x00}, constants.ErrReceivedMsgSmallerThanExpected},
		{"invalid_header", []byte{0x02, 0x00}, packet.ErrInvalidPomeloHeader},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			w := NewWSAcceptor("0.0.0.0:0")
			c := w.GetConnChan()
			defer w.Stop()
			go w.ListenAndServe()

			var conn *websocket.Conn
			var err error
			helpers.ShouldEventuallyReturn(t, func() error {
				addr := fmt.Sprintf("%s://%s", "ws", w.GetAddr())
				dialer := websocket.DefaultDialer
				conn, _, err = dialer.Dial(addr, nil)
				return err
			}, nil, 10*time.Millisecond, 100*time.Millisecond)

			playerConn := helpers.ShouldEventuallyReceive(t, c, 100*time.Millisecond).(*WSConn)
			defer playerConn.Close()
			err = conn.WriteMessage(websocket.BinaryMessage, table.data)
			assert.NoError(t, err)
			msg, err := playerConn.GetNextMessage()
			if table.err != nil {
				assert.EqualError(t, err, table.err.Error())
			} else {
				assert.NoError(t, err)
				assert.Equal(t, table.data, msg)
			}
		})
	}
}

func TestWSGetNextMessageSequentially(t *testing.T) {
	w := NewWSAcceptor("0.0.0.0:0")
	c := w.GetConnChan()
	defer w.Stop()
	go w.ListenAndServe()

	var conn *websocket.Conn
	var err error
	helpers.ShouldEventuallyReturn(t, func() error {
		addr := fmt.Sprintf("%s://%s", "ws", w.GetAddr())
		dialer := websocket.DefaultDialer
		conn, _, err = dialer.Dial(addr, nil)
		return err
	}, nil, 10*time.Millisecond, 100*time.Millisecond)

	playerConn := helpers.ShouldEventuallyReceive(t, c, 100*time.Millisecond).(*WSConn)
	defer playerConn.Close()
	msg1 := []byte{0x01, 0x00, 0x00, 0x02, 0x01, 0x01}
	msg2 := []byte{0x02, 0x00, 0x00, 0x02, 0x05, 0x04}
	err = conn.WriteMessage(websocket.BinaryMessage, msg1)
	assert.NoError(t, err)
	err = conn.WriteMessage(websocket.BinaryMessage, msg2)
	assert.NoError(t, err)
	msg, err := playerConn.GetNextMessage()
	assert.NoError(t, err)
	assert.Equal(t, msg1, msg)
	msg, err = playerConn.GetNextMessage()
	assert.NoError(t, err)
	assert.Equal(t, msg2, msg)
}

```

`pkg/acceptorwrapper/base.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package acceptorwrapper

import (
	"github.com/topfreegames/pitaya/v3/pkg/acceptor"
)

// BaseWrapper implements Wrapper by saving the acceptor as an attribute.
// Conns from acceptor.GetConnChan are processed by wrapConn and
// forwarded to its own connChan.
// Any new wrapper can inherit from BaseWrapper and just implement wrapConn.
type BaseWrapper struct {
	acceptor.Acceptor
	connChan chan acceptor.PlayerConn
	wrapConn func(acceptor.PlayerConn) acceptor.PlayerConn
}

// NewBaseWrapper returns an instance of BaseWrapper.
func NewBaseWrapper(wrapConn func(acceptor.PlayerConn) acceptor.PlayerConn) BaseWrapper {
	return BaseWrapper{
		connChan: make(chan acceptor.PlayerConn),
		wrapConn: wrapConn,
	}
}

// ListenAndServe starts a goroutine that wraps acceptor's conn
// and calls acceptor's listenAndServe
func (b *BaseWrapper) ListenAndServe() {
	go b.pipe()
	b.Acceptor.ListenAndServe()
}

// GetConnChan returns the wrapper conn chan
func (b *BaseWrapper) GetConnChan() chan acceptor.PlayerConn {
	return b.connChan
}

func (b *BaseWrapper) pipe() {
	for conn := range b.Acceptor.GetConnChan() {
		b.connChan <- b.wrapConn(conn)
	}
}

```

`pkg/acceptorwrapper/base_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package acceptorwrapper

import (
	"testing"

	"github.com/topfreegames/pitaya/v3/pkg/acceptor"

	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/mocks"
)

func TestListenAndServe(t *testing.T) {
	t.Parallel()

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockAcceptor := mocks.NewMockAcceptor(ctrl)
	mockConn := mocks.NewMockPlayerConn(ctrl)

	conns := make(chan acceptor.PlayerConn)
	exit := make(chan struct{})
	reads := 3
	go func() {
		for i := 0; i < reads; i++ {
			mockConn.EXPECT().Read([]byte{})
			conns <- mockConn
		}
	}()

	mockAcceptor.EXPECT().GetConnChan().Return(conns)
	wrapper := &BaseWrapper{
		Acceptor: mockAcceptor,
		connChan: make(chan acceptor.PlayerConn),
		wrapConn: func(c acceptor.PlayerConn) acceptor.PlayerConn {
			_, err := c.Read([]byte{})
			assert.NoError(t, err)
			return c
		},
	}

	go func() {
		i := 0
		for range wrapper.GetConnChan() {
			i++
			if i == reads {
				close(exit)
			}
		}
	}()

	mockAcceptor.EXPECT().ListenAndServe().Do(func() { <-exit })
	wrapper.ListenAndServe()
}

```

`pkg/acceptorwrapper/rate_limiter.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package acceptorwrapper

import (
	"container/list"
	"time"

	"github.com/topfreegames/pitaya/v3/pkg/acceptor"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
)

// RateLimiter wraps net.Conn by applying rate limiting and return empty
// if exceeded. It uses the leaky bucket
// algorithm (https://en.wikipedia.org/wiki/Leaky_bucket).
// Here, "limit" is the number of requests it accepts during an "interval" duration.
// After making a request, a slot is occupied and only freed after "interval"
// duration. If a new request comes when no slots are available, the buffer from
// Read is droped and ignored by pitaya.
// On the client side, this will yield a timeout error and the client must
// be prepared to handle it.
type RateLimiter struct {
	acceptor.PlayerConn
	reporters    []metrics.Reporter
	limit        int
	interval     time.Duration
	times        list.List
	forceDisable bool
}

// NewRateLimiter returns an initialized *RateLimiting
func NewRateLimiter(
	reporters []metrics.Reporter,
	conn acceptor.PlayerConn,
	limit int,
	interval time.Duration,
	forceDisable bool,
) *RateLimiter {
	r := &RateLimiter{
		PlayerConn:   conn,
		reporters:    reporters,
		limit:        limit,
		interval:     interval,
		forceDisable: forceDisable,
	}

	r.times.Init()

	return r
}

// GetNextMessage gets the next message in the connection
func (r *RateLimiter) GetNextMessage() (msg []byte, err error) {
	if r.forceDisable {
		return r.PlayerConn.GetNextMessage()
	}

	for {
		msg, err := r.PlayerConn.GetNextMessage()
		if err != nil {
			return nil, err
		}

		now := time.Now()
		if r.shouldRateLimit(now) {
			logger.Log.Errorf("Data=%s, Error=%s", msg, constants.ErrRateLimitExceeded)
			metrics.ReportExceededRateLimiting(r.reporters)
			continue
		}

		return msg, err
	}
}

// shouldRateLimit saves the now as time taken or returns an error if
// in the limit of rate limiting
func (r *RateLimiter) shouldRateLimit(now time.Time) bool {
	if r.times.Len() < r.limit {
		r.times.PushBack(now)
		return false
	}

	front := r.times.Front()
	if diff := now.Sub(front.Value.(time.Time)); diff < r.interval {
		return true
	}

	front.Value = now
	r.times.MoveToBack(front)
	return false
}

```

`pkg/acceptorwrapper/rate_limiter_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package acceptorwrapper

import (
	"errors"
	"testing"
	"time"

	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
	"github.com/topfreegames/pitaya/v3/pkg/mocks"
)

func TestRateLimiterGetNextMessage(t *testing.T) {
	t.Parallel()

	var (
		limit    = 3
		interval = time.Second
		ret      = []byte{0x01, 0x00, 0x00, 0x01, 0x01}
		errTest  = errors.New("error")

		mockConn *mocks.MockPlayerConn
		r        *RateLimiter
	)

	tables := map[string]struct {
		forceDisable bool
		mock         func()
		expected     []byte
		err          error
	}{
		"test_can_read_on_first_time": {
			forceDisable: false,
			mock: func() {
				mockConn.EXPECT().GetNextMessage().Return(ret, nil)
			},
			expected: ret,
			err:      nil,
		},

		"test_read_return_error": {
			forceDisable: false,
			mock: func() {
				mockConn.EXPECT().GetNextMessage().Return(nil, errTest)
			},
			expected: nil,
			err:      errTest,
		},

		"test_exceed_limit": {
			forceDisable: false,
			mock: func() {
				for i := 0; i < limit; i++ {
					mockConn.EXPECT().GetNextMessage().Return(ret, nil)
					_, err := r.GetNextMessage()
					assert.NoError(t, err)
				}

				// exceed after this call
				mockConn.EXPECT().GetNextMessage().Return(ret, nil)
				// back to for begin, return error to leave for loop
				mockConn.EXPECT().GetNextMessage().Return(ret, errTest)
			},
			expected: nil,
			err:      errTest,
		},

		"test_force_disable": {
			forceDisable: true,
			mock: func() {
				for i := 0; i < limit; i++ {
					mockConn.EXPECT().GetNextMessage().Return(ret, nil)
					_, err := r.GetNextMessage()
					assert.NoError(t, err)
				}

				mockConn.EXPECT().GetNextMessage().Return(ret, nil)
			},
			expected: ret, // exceed but ignored, so return the value of read
			err:      nil,
		},
	}

	for name, table := range tables {
		t.Run(name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			mockConn = mocks.NewMockPlayerConn(ctrl)

			r = NewRateLimiter([]metrics.Reporter{}, mockConn, limit, interval, table.forceDisable)

			table.mock()
			buf, err := r.GetNextMessage()
			assert.Equal(t, table.err, err)
			assert.Equal(t, table.expected, buf)
		})
	}
}

func TestRateLimiterShouldRateLimit(t *testing.T) {
	t.Parallel()

	var (
		limit    = 3
		interval = time.Second
		now      = time.Now()
		r        *RateLimiter
	)

	tables := map[string]struct {
		before func()
		should bool
	}{
		"test_should_not_on_first_time": {
			before: func() {},
			should: false,
		},
		"test_should_not_missing_one_to_limit": {
			before: func() {
				r.shouldRateLimit(now)
				r.shouldRateLimit(now)
			},
			should: false,
		},
		"test_should_not_when_oldest_request_expired": {
			before: func() {
				r.shouldRateLimit(now.Add(-2 * interval))
				r.shouldRateLimit(now)
				r.shouldRateLimit(now)
			},
			should: false,
		},
		"test_should_when_exceeded_limit": {
			before: func() {
				r.shouldRateLimit(now)
				r.shouldRateLimit(now)
				r.shouldRateLimit(now)
			},
			should: true,
		},
	}

	for name, table := range tables {
		t.Run(name, func(t *testing.T) {
			r = NewRateLimiter([]metrics.Reporter{}, nil, limit, interval, false)

			table.before()
			should := r.shouldRateLimit(now)
			assert.Equal(t, table.should, should)
		})
	}
}

```

`pkg/acceptorwrapper/rate_limiting_wrapper.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package acceptorwrapper

import (
	"github.com/topfreegames/pitaya/v3/pkg/acceptor"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
)

// RateLimitingWrapper rate limits for each connection
// received
type RateLimitingWrapper struct {
	BaseWrapper
}

// NewRateLimitingWrapper returns an instance of *RateLimitingWrapper
func NewRateLimitingWrapper(reporters []metrics.Reporter, c config.RateLimitingConfig) *RateLimitingWrapper {
	r := &RateLimitingWrapper{}

	r.BaseWrapper = NewBaseWrapper(func(conn acceptor.PlayerConn) acceptor.PlayerConn {
		return NewRateLimiter(reporters, conn, c.Limit, c.Interval, c.ForceDisable)
	})

	return r
}

// Wrap saves acceptor as an attribute
func (r *RateLimitingWrapper) Wrap(a acceptor.Acceptor) acceptor.Acceptor {
	r.Acceptor = a
	return r
}

```

`pkg/acceptorwrapper/rate_limiting_wrapper_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package acceptorwrapper

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
)

func TestNewRateLimitingWrapper(t *testing.T) {
	t.Parallel()

	reporters := []metrics.Reporter{}

	rateLimitingWrapper := NewRateLimitingWrapper(reporters, config.NewDefaultPitayaConfig().Conn.RateLimiting)
	expected := NewRateLimiter(reporters, nil, 20, time.Second, false)
	assert.Equal(t, expected, rateLimitingWrapper.wrapConn(nil))
}

```

`pkg/acceptorwrapper/wrapper.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package acceptorwrapper

import (
	"github.com/topfreegames/pitaya/v3/pkg/acceptor"
)

// Wrapper has a method that receives an acceptor and the struct
// that implements must encapsulate it. The main goal is to create
// a middleware for packets of net.Conn from acceptor.GetConnChan before
// giving it to serviceHandler.
type Wrapper interface {
	Wrap(acceptor.Acceptor) acceptor.Acceptor
}

// WithWrappers walks through wrappers calling Wrapper
func WithWrappers(
	a acceptor.Acceptor,
	wrappers ...Wrapper,
) acceptor.Acceptor {
	for _, w := range wrappers {
		a = w.Wrap(a)
	}
	return a
}

```

`pkg/agent/agent.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package agent

import (
	"context"
	gojson "encoding/json"
	e "errors"
	"fmt"
	"net"
	"os"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/conn/codec"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/conn/packet"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/errors"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/logger/interfaces"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/serialize"
	"github.com/topfreegames/pitaya/v3/pkg/session"
	"github.com/topfreegames/pitaya/v3/pkg/tracing"
	"github.com/topfreegames/pitaya/v3/pkg/util"
	"github.com/topfreegames/pitaya/v3/pkg/util/compression"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
	"go.opentelemetry.io/otel/trace/noop"
)

var (
	// hbd contains the heartbeat packet data
	hbd []byte
	// hrd contains the handshake response data
	hrd []byte
	// herd contains the handshake error response data
	herd []byte
	once sync.Once
)

const handlerType = "handler"

type (
	agentImpl struct {
		Session            session.Session // session
		sessionPool        session.SessionPool
		appDieChan         chan bool         // app die channel
		chDie              chan struct{}     // wait for close
		chSend             chan pendingWrite // push message queue
		chStopHeartbeat    chan struct{}     // stop heartbeats
		chStopWrite        chan struct{}     // stop writing messages
		closeMutex         sync.Mutex
		conn               net.Conn            // low-level conn fd
		decoder            codec.PacketDecoder // binary decoder
		encoder            codec.PacketEncoder // binary encoder
		heartbeatTimeout   time.Duration
		writeTimeout       time.Duration
		lastAt             int64 // last heartbeat unix time stamp
		messageEncoder     message.Encoder
		messagesBufferSize int // size of the pending messages buffer
		metricsReporters   []metrics.Reporter
		serializer         serialize.Serializer // message serializer
		state              int32                // current agent state
		logger             interfaces.Logger
	}

	pendingMessage struct {
		ctx     context.Context
		typ     message.Type // message type
		route   string       // message route (push)
		mid     uint         // response message id (response)
		payload interface{}  // payload
		err     bool         // if its an error message
	}

	pendingWrite struct {
		ctx  context.Context
		data []byte
		err  error
	}

	// Agent corresponds to a user and is used for storing raw Conn information
	Agent interface {
		GetSession() session.Session
		Push(route string, v interface{}) error
		ResponseMID(ctx context.Context, mid uint, v interface{}, isError ...bool) error
		Close() error
		RemoteAddr() net.Addr
		String() string
		GetStatus() int32
		Kick(ctx context.Context) error
		SetLastAt()
		SetStatus(state int32)
		Handle()
		IPVersion() string
		SendHandshakeResponse() error
		SendHandshakeErrorResponse() error
		SendRequest(ctx context.Context, serverID, route string, v interface{}) (*protos.Response, error)
		AnswerWithError(ctx context.Context, mid uint, err error)
	}

	// AgentFactory factory for creating Agent instances
	AgentFactory interface {
		CreateAgent(conn net.Conn) Agent
	}

	agentFactoryImpl struct {
		sessionPool        session.SessionPool
		appDieChan         chan bool           // app die channel
		decoder            codec.PacketDecoder // binary decoder
		encoder            codec.PacketEncoder // binary encoder
		heartbeatTimeout   time.Duration
		writeTimeout       time.Duration
		messageEncoder     message.Encoder
		messagesBufferSize int // size of the pending messages buffer
		metricsReporters   []metrics.Reporter
		serializer         serialize.Serializer // message serializer
	}
)

// NewAgentFactory ctor
func NewAgentFactory(
	appDieChan chan bool,
	decoder codec.PacketDecoder,
	encoder codec.PacketEncoder,
	serializer serialize.Serializer,
	heartbeatTimeout time.Duration,
	writeTimeout time.Duration,
	messageEncoder message.Encoder,
	messagesBufferSize int,
	sessionPool session.SessionPool,
	metricsReporters []metrics.Reporter,
) AgentFactory {
	return &agentFactoryImpl{
		appDieChan:         appDieChan,
		decoder:            decoder,
		encoder:            encoder,
		heartbeatTimeout:   heartbeatTimeout,
		writeTimeout:       writeTimeout,
		messageEncoder:     messageEncoder,
		messagesBufferSize: messagesBufferSize,
		sessionPool:        sessionPool,
		metricsReporters:   metricsReporters,
		serializer:         serializer,
	}
}

// CreateAgent returns a new agent
func (f *agentFactoryImpl) CreateAgent(conn net.Conn) Agent {
	return newAgent(conn, f.decoder, f.encoder, f.serializer, f.heartbeatTimeout, f.writeTimeout, f.messagesBufferSize, f.appDieChan, f.messageEncoder, f.metricsReporters, f.sessionPool)
}

// NewAgent create new agent instance
func newAgent(
	conn net.Conn,
	packetDecoder codec.PacketDecoder,
	packetEncoder codec.PacketEncoder,
	serializer serialize.Serializer,
	heartbeatTime time.Duration,
	writeTimeout time.Duration,
	messagesBufferSize int,
	dieChan chan bool,
	messageEncoder message.Encoder,
	metricsReporters []metrics.Reporter,
	sessionPool session.SessionPool,
) Agent {
	// initialize heartbeat and handshake data on first user connection
	serializerName := serializer.GetName()

	once.Do(func() {
		hbdEncode(heartbeatTime, packetEncoder, messageEncoder.IsCompressionEnabled(), serializerName)
		herdEncode(heartbeatTime, packetEncoder, messageEncoder.IsCompressionEnabled(), serializerName)
	})

	if writeTimeout <= 0 {
		writeTimeout = config.DefaultWriteTimeout
	}

	a := &agentImpl{
		appDieChan:         dieChan,
		chDie:              make(chan struct{}),
		chSend:             make(chan pendingWrite, messagesBufferSize),
		chStopHeartbeat:    make(chan struct{}),
		chStopWrite:        make(chan struct{}),
		messagesBufferSize: messagesBufferSize,
		conn:               conn,
		decoder:            packetDecoder,
		encoder:            packetEncoder,
		heartbeatTimeout:   heartbeatTime,
		writeTimeout:       writeTimeout,
		lastAt:             time.Now().Unix(),
		serializer:         serializer,
		state:              constants.StatusStart,
		messageEncoder:     messageEncoder,
		metricsReporters:   metricsReporters,
		sessionPool:        sessionPool,
		logger:             logger.Log,
	}
	// binding session
	s := sessionPool.NewSession(a, true)
	a.logger = a.logger.WithField("session_id", s.ID())
	metrics.ReportNumberOfConnectedClients(metricsReporters, sessionPool.GetSessionCount())
	a.Session = s
	return a
}

func (a *agentImpl) getMessageFromPendingMessage(pm pendingMessage) (*message.Message, error) {
	payload, err := util.SerializeOrRaw(a.serializer, pm.payload)
	if err != nil {
		payload, err = util.GetErrorPayload(a.serializer, err)
		if err != nil {
			return nil, err
		}
	}

	// construct message and encode
	m := &message.Message{
		Type:  pm.typ,
		Data:  payload,
		Route: pm.route,
		ID:    pm.mid,
		Err:   pm.err,
	}

	return m, nil
}

func (a *agentImpl) packetEncodeMessage(m *message.Message) ([]byte, error) {
	em, err := a.messageEncoder.Encode(m)
	if err != nil {
		return nil, err
	}

	// packet encode
	p, err := a.encoder.Encode(packet.Data, em)
	if err != nil {
		return nil, err
	}
	return p, nil
}

func (a *agentImpl) send(pendingMsg pendingMessage) (err error) {
	defer func() {
		if panicErr := recover(); panicErr != nil {
			err = errors.NewError(
				fmt.Errorf("%s: %s", constants.ErrBrokenPipe.Error(), panicErr),
				errors.ErrClientClosedRequest,
			)
			logger.Log.Error("agent send panicked: ", err)
		}
	}()
	a.reportChannelSize()

	m, err := a.getMessageFromPendingMessage(pendingMsg)
	if err != nil {
		logger.Log.Errorf(
			"agent send failed when getting pending msg. route: %s, type: %s, err: %s",
			pendingMsg.route, &pendingMsg.typ, err,
		)
		return err
	}

	// packet encode
	p, err := a.packetEncodeMessage(m)
	if err != nil {
		logger.Log.Errorf(
			"agent send failed when encoding the msg. route: %s, type: %s, err: %s",
			pendingMsg.route, &pendingMsg.typ, err,
		)
		return err
	}

	pWrite := pendingWrite{
		ctx:  pendingMsg.ctx,
		data: p,
	}

	if pendingMsg.err {
		pWrite.err = util.GetErrorFromPayload(a.serializer, m.Data)
	}

	// chSend is never closed so we need this to don't block if agent is already closed
	select {
	case a.chSend <- pWrite:
	case <-a.chDie:
	}
	return
}

// GetSession returns the agent session
func (a *agentImpl) GetSession() session.Session {
	return a.Session
}

// Push implementation for NetworkEntity interface
func (a *agentImpl) Push(route string, v interface{}) error {
	if a.GetStatus() == constants.StatusClosed {
		return errors.NewError(constants.ErrBrokenPipe, errors.ErrClientClosedRequest)
	}

	switch d := v.(type) {
	case []byte:
		a.logger.Debugf("Type=Push, ID=%d, UID=%s, Route=%s, Data=%dbytes",
			a.Session.ID(), a.Session.UID(), route, len(d))
	default:
		a.logger.Debugf("Type=Push, ID=%d, UID=%s, Route=%s, Data=%+v",
			a.Session.ID(), a.Session.UID(), route, v)
	}
	return a.send(pendingMessage{typ: message.Push, route: route, payload: v})
}

// ResponseMID implementation for NetworkEntity interface
// Respond message to session
func (a *agentImpl) ResponseMID(ctx context.Context, mid uint, v interface{}, isError ...bool) error {
	err := false
	if len(isError) > 0 {
		err = isError[0]
	}
	if a.GetStatus() == constants.StatusClosed {
		return errors.NewError(constants.ErrBrokenPipe, errors.ErrClientClosedRequest)
	}

	if mid <= 0 {
		return constants.ErrSessionOnNotify
	}

	switch d := v.(type) {
	case []byte:
		a.logger.Debugf("Type=Response, ID=%d, UID=%s, MID=%d, Data=%dbytes",
			a.Session.ID(), a.Session.UID(), mid, len(d))
	default:
		a.logger.Infof("Type=Response, ID=%d, UID=%s, MID=%d, Data=%+v",
			a.Session.ID(), a.Session.UID(), mid, v)
	}

	return a.send(pendingMessage{ctx: ctx, typ: message.Response, mid: mid, payload: v, err: err})
}

// Close closes the agent, cleans inner state and closes low-level connection.
// Any blocked Read or Write operations will be unblocked and return errors.
func (a *agentImpl) Close() error {
	a.closeMutex.Lock()
	defer a.closeMutex.Unlock()
	if a.GetStatus() == constants.StatusClosed {
		return constants.ErrCloseClosedSession
	}
	a.SetStatus(constants.StatusClosed)

	a.logger.Debugf("Session closed, ID=%d, UID=%s, IP=%s",
		a.Session.ID(), a.Session.UID(), a.conn.RemoteAddr())

	// prevent closing closed channel
	select {
	case <-a.chDie:
		// expect
	default:
		close(a.chStopWrite)
		close(a.chStopHeartbeat)
		close(a.chDie)
		a.onSessionClosed(a.Session)
	}

	metrics.ReportNumberOfConnectedClients(a.metricsReporters, a.sessionPool.GetSessionCount())

	return a.conn.Close()
}

// RemoteAddr implementation for NetworkEntity interface
// returns the remote network address.
func (a *agentImpl) RemoteAddr() net.Addr {
	return a.conn.RemoteAddr()
}

// String, implementation for Stringer interface
func (a *agentImpl) String() string {
	return fmt.Sprintf("Remote=%s, LastTime=%d", a.conn.RemoteAddr().String(), atomic.LoadInt64(&a.lastAt))
}

// GetStatus gets the status
func (a *agentImpl) GetStatus() int32 {
	return atomic.LoadInt32(&a.state)
}

// Kick sends a kick packet to a client
func (a *agentImpl) Kick(ctx context.Context) error {
	// packet encode
	p, err := a.encoder.Encode(packet.Kick, nil)
	if err != nil {
		return err
	}
	_, err = a.conn.Write(p)
	return err
}

// SetLastAt sets the last at to now
func (a *agentImpl) SetLastAt() {
	atomic.StoreInt64(&a.lastAt, time.Now().Unix())
}

// SetStatus sets the agent status
func (a *agentImpl) SetStatus(state int32) {
	atomic.StoreInt32(&a.state, state)
}

// Handle handles the messages from and to a client
func (a *agentImpl) Handle() {
	defer func() {
		a.Close()
		a.logger.Debugf("Session handle goroutine exit, SessionID=%d, UID=%s", a.Session.ID(), a.Session.UID())
	}()

	go a.write()
	go a.heartbeat()
	<-a.chDie // agent closed signal
}

// IPVersion returns the remote address ip version.
// net.TCPAddr and net.UDPAddr implementations of String()
// always construct result as <ip>:<port> on both
// ipv4 and ipv6. Also, to see if the ip is ipv6 they both
// check if there is a colon on the string.
// So checking if there are more than one colon here is safe.
func (a *agentImpl) IPVersion() string {
	version := constants.IPv4

	ipPort := a.RemoteAddr().String()
	if strings.Count(ipPort, ":") > 1 {
		version = constants.IPv6
	}

	return version
}

func (a *agentImpl) heartbeat() {
	ticker := time.NewTicker(a.heartbeatTimeout)

	defer func() {
		ticker.Stop()
		a.Close()
	}()

	for {
		select {
		case <-ticker.C:
			deadline := time.Now().Add(-2 * a.heartbeatTimeout).Unix()
			if atomic.LoadInt64(&a.lastAt) < deadline {
				a.logger.Debugf("Session heartbeat timeout, LastTime=%d, Deadline=%d", atomic.LoadInt64(&a.lastAt), deadline)
				return
			}

			// chSend is never closed so we need this to don't block if agent is already closed
			select {
			case a.chSend <- pendingWrite{data: hbd}:
			case <-a.chDie:
				return
			case <-a.chStopHeartbeat:
				return
			}
		case <-a.chDie:
			return
		case <-a.chStopHeartbeat:
			return
		}
	}
}

func (a *agentImpl) onSessionClosed(s session.Session) {
	defer func() {
		if err := recover(); err != nil {
			a.logger.Errorf("pitaya/onSessionClosed: %v", err)
		}
	}()

	for _, fn1 := range s.GetOnCloseCallbacks() {
		fn1()
	}

	for _, fn2 := range a.sessionPool.GetSessionCloseCallbacks() {
		fn2(s)
	}
}

// SendHandshakeResponse sends a handshake response
func (a *agentImpl) SendHandshakeResponse() error {
	_, err := a.conn.Write(hrd)

	return err
}

func (a *agentImpl) SendHandshakeErrorResponse() error {
	_, err := a.conn.Write(herd)

	return err
}

func (a *agentImpl) write() {
	// clean func
	defer func() {
		a.Close()
	}()

	for {
		select {
		case pWrite := <-a.chSend:
			ctx, err, data := pWrite.ctx, pWrite.err, pWrite.data

			writeErr := a.writeToConnection(ctx, data)

			tracing.FinishSpan(ctx, nil)

			if writeErr != nil {
				if e.Is(writeErr, os.ErrDeadlineExceeded) {
					// Log the timeout error but continue processing
					logger.Log.Warnf(
						"Context deadline exceeded for write in conn (%s) | session (%s): %s",
						a.conn.RemoteAddr(), a.Session.UID(), writeErr.Error(),
					)
				} else {
					err = errors.NewError(writeErr, errors.ErrClosedRequest)
					logger.Log.Errorf(
						"Failed to write in conn (%s) | session (%s): %s, agent will close",
						a.conn.RemoteAddr(), a.Session.UID(), writeErr.Error(),
					)
					metrics.ReportTimingFromCtx(ctx, a.metricsReporters, handlerType, err)
					// close agent if low-level conn broke during write
					return
				}
			}

			metrics.ReportTimingFromCtx(ctx, a.metricsReporters, handlerType, err)
		case <-a.chStopWrite:
			return
		}
	}
}

func (a *agentImpl) writeToConnection(ctx context.Context, data []byte) error {
	span := createConnectionSpan(ctx, a.conn, "conn write")

	a.conn.SetWriteDeadline(time.Now().Add(a.writeTimeout))
	_, writeErr := a.conn.Write(data)

	if span != nil {
		defer span.End()

		if writeErr != nil {
			span.RecordError(writeErr)
			span.SetStatus(codes.Error, writeErr.Error())
		}
	}

	return writeErr
}

func createConnectionSpan(ctx context.Context, conn net.Conn, op string) trace.Span {
	if ctx == nil {
		_, span := noop.NewTracerProvider().Tracer("noop").Start(context.TODO(), op)
		return span
	}
	remoteAddress := ""
	if conn.RemoteAddr() != nil {
		remoteAddress = conn.RemoteAddr().String()
	}

	attrs := []attribute.KeyValue{
		attribute.String("span.kind", "connection"),
		attribute.String("addr", remoteAddress),
	}

	_, span := tracing.StartSpan(ctx, op, attrs...)
	return span
}

// SendRequest sends a request to a server
func (a *agentImpl) SendRequest(ctx context.Context, serverID, route string, v interface{}) (*protos.Response, error) {
	return nil, e.New("not implemented")
}

// AnswerWithError answers with an error
func (a *agentImpl) AnswerWithError(ctx context.Context, mid uint, err error) {
	var e error
	defer func() {
		if e != nil {
			tracing.FinishSpan(ctx, e)
			metrics.ReportTimingFromCtx(ctx, a.metricsReporters, handlerType, e)
		}
	}()
	if ctx != nil && err != nil {
		span := trace.SpanFromContext(ctx)
		if span.IsRecording() {
			span.SetStatus(codes.Error, err.Error())
			span.RecordError(err)
		}
	}
	p, e := util.GetErrorPayload(a.serializer, err)
	if e != nil {
		a.logger.Errorf("error answering the user with an error: %s", e.Error())
		return
	}
	e = a.Session.ResponseMID(ctx, mid, p, true)
	if e != nil {
		a.logger.Errorf("error answering the user with an error: %s", e.Error())
	}
}

func hbdEncode(heartbeatTimeout time.Duration, packetEncoder codec.PacketEncoder, dataCompression bool, serializerName string) {
	hData := map[string]interface{}{
		"code": 200,
		"sys": map[string]interface{}{
			"heartbeat":  heartbeatTimeout.Seconds(),
			"dict":       message.GetDictionary(),
			"serializer": serializerName,
		},
	}

	data, err := encodeAndCompress(hData, dataCompression)
	if err != nil {
		panic(err)
	}

	hrd, err = packetEncoder.Encode(packet.Handshake, data)
	if err != nil {
		panic(err)
	}

	hbd, err = packetEncoder.Encode(packet.Heartbeat, nil)
	if err != nil {
		panic(err)
	}
}

func herdEncode(heartbeatTimeout time.Duration, packetEncoder codec.PacketEncoder, dataCompression bool, serializerName string) {
	hErrData := map[string]interface{}{
		"code": 400,
		"sys": map[string]interface{}{
			"heartbeat":  heartbeatTimeout.Seconds(),
			"dict":       message.GetDictionary(),
			"serializer": serializerName,
		},
	}

	errData, err := encodeAndCompress(hErrData, dataCompression)
	if err != nil {
		panic(err)
	}

	herd, err = packetEncoder.Encode(packet.Handshake, errData)
	if err != nil {
		panic(err)
	}
}

func encodeAndCompress(data interface{}, dataCompression bool) ([]byte, error) {
	encData, err := gojson.Marshal(data)
	if err != nil {
		return nil, err
	}

	if dataCompression {
		compressedData, err := compression.DeflateData(encData)
		if err != nil {
			return nil, err
		}

		if len(compressedData) < len(encData) {
			encData = compressedData
		}
	}
	return encData, nil
}

func (a *agentImpl) reportChannelSize() {
	chSendCapacity := a.messagesBufferSize - len(a.chSend)
	if chSendCapacity == 0 {
		a.logger.Warnf("chSend is at maximum capacity")
	}
	for _, mr := range a.metricsReporters {
		if err := mr.ReportHistogram(metrics.ChannelCapacity, map[string]string{"channel": "agent_chsend"}, float64(chSendCapacity)); err != nil {
			logger.Log.Warnf("failed to report histogram chSend channel capacity: %s", err.Error())
		}
	}
}

```

`pkg/agent/agent_remote.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package agent

import (
	"context"
	"net"
	"reflect"

	"github.com/golang/protobuf/proto"
	"github.com/topfreegames/pitaya/v3/pkg/cluster"
	"github.com/topfreegames/pitaya/v3/pkg/conn/codec"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/conn/packet"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/route"
	"github.com/topfreegames/pitaya/v3/pkg/serialize"
	"github.com/topfreegames/pitaya/v3/pkg/session"
	"github.com/topfreegames/pitaya/v3/pkg/util"
)

// Remote corresponding to another server
type Remote struct {
	Session          session.Session // session
	chDie            chan struct{}   // wait for close
	messageEncoder   message.Encoder
	encoder          codec.PacketEncoder      // binary encoder
	frontendID       string                   // the frontend that sent the request
	reply            string                   // nats reply topic
	rpcClient        cluster.RPCClient        // rpc client
	serializer       serialize.Serializer     // message serializer
	serviceDiscovery cluster.ServiceDiscovery // service discovery
}

// NewRemote create new Remote instance
func NewRemote(
	sess *protos.Session,
	reply string,
	rpcClient cluster.RPCClient,
	encoder codec.PacketEncoder,
	serializer serialize.Serializer,
	serviceDiscovery cluster.ServiceDiscovery,
	frontendID string,
	messageEncoder message.Encoder,
	sessionPool session.SessionPool,
) (*Remote, error) {
	a := &Remote{
		chDie:            make(chan struct{}),
		reply:            reply, // TODO this is totally coupled with NATS
		serializer:       serializer,
		encoder:          encoder,
		rpcClient:        rpcClient,
		serviceDiscovery: serviceDiscovery,
		frontendID:       frontendID,
		messageEncoder:   messageEncoder,
	}

	// binding session
	s := sessionPool.NewSession(a, false, sess.GetUid())
	s.SetFrontendData(frontendID, sess.GetId())
	err := s.SetDataEncoded(sess.GetData())
	if err != nil {
		return nil, err
	}
	a.Session = s

	return a, nil
}

// Kick kicks the user
func (a *Remote) Kick(ctx context.Context) error {
	if a.Session.UID() == "" {
		return constants.ErrNoUIDBind
	}
	b, err := proto.Marshal(&protos.KickMsg{
		UserId: a.Session.UID(),
	})
	if err != nil {
		return err
	}
	_, err = a.SendRequest(ctx, a.frontendID, constants.KickRoute, b)
	return err
}

// Push pushes the message to the user
func (a *Remote) Push(route string, v interface{}) error {
	if (reflect.TypeOf(a.rpcClient) == reflect.TypeOf(&cluster.NatsRPCClient{}) &&
		a.Session.UID() == "") {
		return constants.ErrNoUIDBind
	}
	switch d := v.(type) {
	case []byte:
		logger.Log.Debugf("Type=Push, ID=%d, UID=%s, Route=%s, Data=%dbytes",
			a.Session.ID(), a.Session.UID(), route, len(d))
	default:
		logger.Log.Debugf("Type=Push, ID=%d, UID=%s, Route=%s, Data=%+v",
			a.Session.ID(), a.Session.UID(), route, v)
	}

	sv, err := a.serviceDiscovery.GetServer(a.frontendID)
	if err != nil {
		return err
	}
	return a.sendPush(
		pendingMessage{typ: message.Push, route: route, payload: v},
		a.Session.UID(), sv,
	)
}

// ResponseMID reponds the message with mid to the user
func (a *Remote) ResponseMID(ctx context.Context, mid uint, v interface{}, isError ...bool) error {
	err := false
	if len(isError) > 0 {
		err = isError[0]
	}

	if mid <= 0 {
		return constants.ErrSessionOnNotify
	}

	switch d := v.(type) {
	case []byte:
		logger.Log.Debugf("Type=Response, ID=%d, MID=%d, Data=%dbytes",
			a.Session.ID(), mid, len(d))
	default:
		logger.Log.Infof("Type=Response, ID=%d, MID=%d, Data=%+v",
			a.Session.ID(), mid, v)
	}

	return a.send(pendingMessage{ctx: ctx, typ: message.Response, mid: mid, payload: v, err: err}, a.reply)
}

// Close closes the remote
func (a *Remote) Close() error { return nil }

// RemoteAddr returns the remote address of the user
func (a *Remote) RemoteAddr() net.Addr { return nil }

func (a *Remote) serialize(m pendingMessage) ([]byte, error) {
	payload, err := util.SerializeOrRaw(a.serializer, m.payload)
	if err != nil {
		return nil, err
	}

	// construct message and encode
	msg := &message.Message{
		Type:  m.typ,
		Data:  payload,
		Route: m.route,
		ID:    m.mid,
		Err:   m.err,
	}

	em, err := a.messageEncoder.Encode(msg)
	if err != nil {
		return nil, err
	}

	// packet encode
	p, err := a.encoder.Encode(packet.Data, em)
	if err != nil {
		return nil, err
	}

	return p, err
}

func (a *Remote) send(m pendingMessage, to string) (err error) {
	p, err := a.serialize(m)
	if err != nil {
		return err
	}
	res := &protos.Response{
		Data: p,
	}
	bt, err := proto.Marshal(res)
	if err != nil {
		return err
	}
	return a.rpcClient.Send(to, bt)
}

func (a *Remote) sendPush(m pendingMessage, userID string, sv *cluster.Server) (err error) {
	payload, err := util.SerializeOrRaw(a.serializer, m.payload)
	if err != nil {
		return err
	}
	push := &protos.Push{
		Route: m.route,
		Uid:   a.Session.UID(),
		Data:  payload,
	}
	return a.rpcClient.SendPush(userID, sv, push)
}

// SendRequest sends a request to a server
func (a *Remote) SendRequest(ctx context.Context, serverID, reqRoute string, v interface{}) (*protos.Response, error) {
	r, err := route.Decode(reqRoute)
	if err != nil {
		return nil, err
	}
	payload, err := util.SerializeOrRaw(a.serializer, v)
	if err != nil {
		return nil, err
	}
	msg := &message.Message{
		Route: reqRoute,
		Data:  payload,
	}
	server, err := a.serviceDiscovery.GetServer(serverID)
	if err != nil {
		return nil, err
	}
	return a.rpcClient.Call(ctx, protos.RPCType_User, r, nil, msg, server)
}

```

`pkg/agent/agent_remote_test.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package agent

import (
	"context"
	"errors"
	"math/rand"
	"reflect"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/cluster"
	clustermocks "github.com/topfreegames/pitaya/v3/pkg/cluster/mocks"
	codecmocks "github.com/topfreegames/pitaya/v3/pkg/conn/codec/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	messagemocks "github.com/topfreegames/pitaya/v3/pkg/conn/message/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/conn/packet"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/route"
	serializemocks "github.com/topfreegames/pitaya/v3/pkg/serialize/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/session"
)

type someStruct struct {
	A string
}

func TestNewRemote(t *testing.T) {
	uid := uuid.New().String()
	ss := &protos.Session{Uid: uid}
	reply := uuid.New().String()
	frontendID := uuid.New().String()

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockRPCClient := clustermocks.NewMockRPCClient(ctrl)
	mockSD := clustermocks.NewMockServiceDiscovery(ctrl)
	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	mockMessageEncoder := messagemocks.NewMockEncoder(ctrl)

	sessionPool := session.NewSessionPool()
	remote, err := NewRemote(ss, reply, mockRPCClient, mockEncoder, mockSerializer, mockSD, frontendID, mockMessageEncoder, sessionPool)
	assert.NoError(t, err)
	assert.NotNil(t, remote)
	assert.IsType(t, make(chan struct{}), remote.chDie)
	assert.Equal(t, reply, remote.reply)
	assert.Equal(t, mockSerializer, remote.serializer)
	assert.Equal(t, mockEncoder, remote.encoder)
	assert.Equal(t, mockRPCClient, remote.rpcClient)
	assert.Equal(t, mockSD, remote.serviceDiscovery)
	assert.Equal(t, frontendID, remote.frontendID)
	assert.NotNil(t, remote.Session)
	assert.False(t, remote.Session.GetIsFrontend())
}

func TestNewRemoteFailsIfFailedToSetEncodedData(t *testing.T) {
	ss := &protos.Session{Data: []byte("invalid")}

	sessionPool := session.NewSessionPool()
	remote, err := NewRemote(ss, "", nil, nil, nil, nil, "", nil, sessionPool)
	assert.Equal(t, errors.New("invalid character 'i' looking for beginning of value").Error(), err.Error())
	assert.Nil(t, remote)
}

func TestAgentRemoteClose(t *testing.T) {
	sessionPool := session.NewSessionPool()
	remote, err := NewRemote(nil, "", nil, nil, nil, nil, "", nil, sessionPool)
	assert.NoError(t, err)
	assert.NotNil(t, remote)
	err = remote.Close()
	assert.NoError(t, err)
}

func TestAgentRemoteRemoteAddr(t *testing.T) {
	sessionPool := session.NewSessionPool()
	remote, err := NewRemote(nil, "", nil, nil, nil, nil, "", nil, sessionPool)
	assert.NoError(t, err)
	assert.NotNil(t, remote)
	addr := remote.RemoteAddr()
	assert.Nil(t, addr)
}

func TestAgentRemotePush(t *testing.T) {
	route := uuid.New().String()
	tables := []struct {
		name         string
		uid          string
		rpcClient    cluster.RPCClient
		data         interface{}
		errSerialize error
		err          error
	}{
		{"nats_rpc_session_not_bound", "", &cluster.NatsRPCClient{}, nil, nil, constants.ErrNoUIDBind},
		{"success_raw_message", uuid.New().String(), nil, []byte("ok"), nil, nil},
		{"failed_struct_message_serialize", uuid.New().String(), nil, &someStruct{A: "ok"}, errors.New("failed serialize"), errors.New("failed serialize")},
		{"success_struct_message", uuid.New().String(), nil, &someStruct{A: "ok"}, nil, nil},
		{"failed_send", uuid.New().String(), nil, []byte("ok"), nil, errors.New("failed send")},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			if table.rpcClient == nil {
				table.rpcClient = clustermocks.NewMockRPCClient(ctrl)
			}
			fSvID := "123id"
			ss := &protos.Session{Uid: table.uid}
			mockSerializer := serializemocks.NewMockSerializer(ctrl)
			mockSD := clustermocks.NewMockServiceDiscovery(ctrl)
			sessionPool := session.NewSessionPool()
			remote, err := NewRemote(ss, "", table.rpcClient, nil, mockSerializer, mockSD, fSvID, nil, sessionPool)
			assert.NoError(t, err)
			assert.NotNil(t, remote)

			if table.uid != "" {
				expectedData := []byte("done")

				if reflect.TypeOf(table.data) == reflect.TypeOf(([]byte)(nil)) {
					expectedData = table.data.([]byte)
				} else {
					mockSerializer.EXPECT().Marshal(table.data).Return(expectedData, table.errSerialize)
				}

				if table.errSerialize == nil {
					expectedPush := &protos.Push{
						Route: route,
						Uid:   table.uid,
						Data:  expectedData,
					}
					table.rpcClient.(*clustermocks.MockRPCClient).EXPECT().SendPush(table.uid, gomock.Any(), expectedPush).Return(table.err)
				}
			}

			if table.err != constants.ErrNoUIDBind {
				mockSD.EXPECT().GetServer(fSvID).Return(cluster.NewServer(fSvID, "connector", true), nil)
			}
			err = remote.Push(route, table.data)
			assert.Equal(t, table.err, err)
		})
	}
}

func TestKickRemote(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	rpcClient := clustermocks.NewMockRPCClient(ctrl)
	ss := &protos.Session{Uid: uuid.New().String()}
	mockSD := clustermocks.NewMockServiceDiscovery(ctrl)
	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	frontID := uuid.New().String()

	sessionPool := session.NewSessionPool()
	remote, err := NewRemote(ss, "", rpcClient, nil, mockSerializer, mockSD, frontID, nil, sessionPool)
	assert.NoError(t, err)

	mockSD.EXPECT().GetServer(frontID)
	c := context.Background()
	r, _ := route.Decode("sys.kick")
	rpcClient.EXPECT().Call(c, protos.RPCType_User, r, gomock.Nil(), gomock.Any(), gomock.Nil())
	err = remote.Kick(c)

	assert.NoError(t, err)
}

func TestAgentRemoteResponseMID(t *testing.T) {
	tables := []struct {
		name         string
		mid          uint
		data         interface{}
		msgErr       bool
		errEncode    error
		errSerialize error
		err          error
	}{
		{"success_raw_message", uint(rand.Int()), []byte("ok"), false, nil, nil, nil},
		{"success_struct_message", uint(rand.Int()), &someStruct{A: "ok"}, false, nil, nil, nil},
		{"success_struct_message_with_error", uint(rand.Int()), &someStruct{A: "ok"}, true, nil, nil, nil},
		{"failed_struct_message_serialize", uint(rand.Int()), &someStruct{A: "ok"}, false, nil, errors.New("failed serialize"), errors.New("failed serialize")},
		{"failed_encode", uint(rand.Int()), &someStruct{A: "ok"}, false, errors.New("failed encode"), nil, errors.New("failed encode")},
		{"failed_send", uint(rand.Int()), &someStruct{A: "ok"}, false, nil, nil, errors.New("failed send")},
		{"zero_mid", 0, nil, false, nil, nil, constants.ErrSessionOnNotify},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			reply := uuid.New().String()
			uid := uuid.New().String()
			ss := &protos.Session{Uid: uid}
			mockEnconder := codecmocks.NewMockPacketEncoder(ctrl)
			mockSerializer := serializemocks.NewMockSerializer(ctrl)
			mockRPCClient := clustermocks.NewMockRPCClient(ctrl)
			messageEncoder := message.NewMessagesEncoder(false)
			sessionPool := session.NewSessionPool()
			remote, err := NewRemote(ss, reply, mockRPCClient, mockEnconder, mockSerializer, nil, "", messageEncoder, sessionPool)
			assert.NoError(t, err)
			assert.NotNil(t, remote)

			if table.mid != uint(0) {
				serializeRet := []byte("ok")
				if reflect.TypeOf(table.data) == reflect.TypeOf(([]byte)(nil)) {
					serializeRet = table.data.([]byte)
				} else {
					mockSerializer.EXPECT().Marshal(table.data).Return(serializeRet, table.errSerialize)
				}

				if table.errSerialize == nil {
					rawMsg := &message.Message{
						Type: message.Response,
						Data: serializeRet,
						ID:   table.mid,
						Err:  table.msgErr,
					}
					expectedMsg, _ := messageEncoder.Encode(rawMsg)
					mockEnconder.EXPECT().Encode(gomock.Any(), expectedMsg).Return(nil, table.errEncode).Do(
						func(typ packet.Type, d []byte) {
							// cannot compare inside the expect because they are equivalent but not equal
							assert.EqualValues(t, packet.Data, typ)
						})

					if table.errEncode == nil {
						mockRPCClient.EXPECT().Send(reply, gomock.Any()).Return(table.err)
					}
				}

			}
			if table.msgErr {
				err = remote.ResponseMID(nil, table.mid, table.data, table.msgErr)
			} else {
				err = remote.ResponseMID(nil, table.mid, table.data)
			}
			assert.Equal(t, table.err, err)
		})
	}
}

func TestAgentRemoteSendRequest(t *testing.T) {
	tables := []struct {
		name         string
		serverID     string
		reqRoute     string
		data         interface{}
		errSerialize error
		errGetServer error
		err          error
		resp         *protos.Response
	}{
		{"test_failed_bad_route", uuid.New().String(), uuid.New().String(), []byte("ok"), nil, nil, errors.New("invalid route"), nil},
		{"test_success_raw", uuid.New().String(), "", []byte("ok"), nil, nil, nil, &protos.Response{Data: []byte("resp")}},
		{"test_success_struct", uuid.New().String(), "", &someStruct{A: "ok"}, nil, nil, nil, &protos.Response{Data: []byte("resp")}},
		{"test_failed_serialize", uuid.New().String(), "", &someStruct{A: "ok"}, errors.New("ser"), nil, errors.New("ser"), nil},
		{"test_failed_get_server", uuid.New().String(), "", &someStruct{A: "ok"}, nil, errors.New("get sv"), errors.New("get sv"), nil},
		{"test_failed_call", uuid.New().String(), "", &someStruct{A: "ok"}, nil, nil, errors.New("call"), nil},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			mockSD := clustermocks.NewMockServiceDiscovery(ctrl)
			mockSerializer := serializemocks.NewMockSerializer(ctrl)
			mockRPCClient := clustermocks.NewMockRPCClient(ctrl)
			mockMessageEncoder := messagemocks.NewMockEncoder(ctrl)
			sessionPool := session.NewSessionPool()
			remote, err := NewRemote(nil, "", mockRPCClient, nil, mockSerializer, mockSD, "", mockMessageEncoder, sessionPool)
			assert.NoError(t, err)
			assert.NotNil(t, remote)

			if table.reqRoute == "" {
				table.reqRoute = "bla.bla"

				serializeRet := []byte("ok")
				if reflect.TypeOf(table.data) == reflect.TypeOf(([]byte)(nil)) {
					serializeRet = table.data.([]byte)
				} else {
					mockSerializer.EXPECT().Marshal(table.data).Return(serializeRet, table.errSerialize)
				}

				if table.errSerialize == nil {
					expectedServer := &cluster.Server{}
					mockSD.EXPECT().GetServer(table.serverID).Return(expectedServer, table.errGetServer)

					if table.errGetServer == nil {
						r, _ := route.Decode(table.reqRoute)
						expectedMsg := &message.Message{
							Route: table.reqRoute,
							Data:  serializeRet,
						}
						mockRPCClient.EXPECT().Call(nil, protos.RPCType_User, r, nil, expectedMsg, expectedServer).Return(table.resp, table.err)
					}
				}
			}

			resp, err := remote.SendRequest(nil, table.serverID, table.reqRoute, table.data)
			assert.Equal(t, table.err, err)
			assert.Equal(t, table.resp, resp)
		})
	}
}

```

`pkg/agent/agent_test.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package agent

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"math/rand"
	"os"
	"reflect"
	"sync"
	"testing"
	"time"

	"github.com/golang/mock/gomock"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/topfreegames/pitaya/v3/pkg/conn/codec"
	codecmocks "github.com/topfreegames/pitaya/v3/pkg/conn/codec/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	messagemocks "github.com/topfreegames/pitaya/v3/pkg/conn/message/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/conn/packet"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	pcontext "github.com/topfreegames/pitaya/v3/pkg/context"
	e "github.com/topfreegames/pitaya/v3/pkg/errors"
	"github.com/topfreegames/pitaya/v3/pkg/helpers"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
	metricsmocks "github.com/topfreegames/pitaya/v3/pkg/metrics/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/serialize"
	serializemocks "github.com/topfreegames/pitaya/v3/pkg/serialize/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/session"
)

type mockAddr struct{}

func (m *mockAddr) Network() string { return "" }
func (m *mockAddr) String() string  { return "remote-string" }

func heartbeatAndHandshakeMocks(mockEncoder *codecmocks.MockPacketEncoder) {
	// heartbeat and handshake if not set by another test
	mockEncoder.EXPECT().Encode(packet.Type(packet.Handshake), gomock.Not(gomock.Nil())).AnyTimes()
	mockEncoder.EXPECT().Encode(packet.Type(packet.Heartbeat), gomock.Nil()).AnyTimes()
}

func getCtxWithRequestKeys() context.Context {
	ctx := pcontext.AddToPropagateCtx(context.Background(), constants.StartTimeKey, time.Now().UnixNano())
	return pcontext.AddToPropagateCtx(ctx, constants.RouteKey, "route")
}

func TestNewAgent(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockSerializer.EXPECT().GetName().Times(2)

	mockMetricsReporter := metricsmocks.NewMockReporter(ctrl)
	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	mockDecoder := codecmocks.NewMockPacketDecoder(ctrl)
	dieChan := make(chan bool)
	hbTime := time.Second
	writeTimeout := time.Second

	mockConn := mocks.NewMockPlayerConn(ctrl)

	mockEncoder.EXPECT().Encode(gomock.Any(), gomock.Not(gomock.Nil())).Do(
		func(typ packet.Type, d []byte) {
			// cannot compare inside the expect because they are equivalent but not equal
			assert.EqualValues(t, packet.Handshake, typ)
		}).Times(2)
	mockEncoder.EXPECT().Encode(gomock.Any(), gomock.Nil()).Do(
		func(typ packet.Type, d []byte) {
			assert.EqualValues(t, packet.Heartbeat, typ)
		})
	messageEncoder := message.NewMessagesEncoder(false)

	mockMetricsReporters := []metrics.Reporter{mockMetricsReporter}
	sessionPool := session.NewSessionPool()

	mockMetricsReporter.EXPECT().ReportGauge(metrics.ConnectedClients, gomock.Any(), gomock.Any())
	ag := newAgent(mockConn, mockDecoder, mockEncoder, mockSerializer, hbTime, writeTimeout, 10, dieChan, messageEncoder, mockMetricsReporters, sessionPool).(*agentImpl)
	assert.NotNil(t, ag)
	assert.IsType(t, make(chan struct{}), ag.chDie)
	assert.IsType(t, make(chan pendingWrite), ag.chSend)
	assert.IsType(t, make(chan struct{}), ag.chStopHeartbeat)
	assert.IsType(t, make(chan struct{}), ag.chStopWrite)
	assert.Equal(t, dieChan, ag.appDieChan)
	assert.Equal(t, 10, ag.messagesBufferSize)
	assert.Equal(t, mockConn, ag.conn)
	assert.Equal(t, mockDecoder, ag.decoder)
	assert.Equal(t, mockEncoder, ag.encoder)
	assert.Equal(t, hbTime, writeTimeout, ag.heartbeatTimeout)
	assert.InDelta(t, time.Now().Unix(), ag.lastAt, 1)
	assert.Equal(t, mockSerializer, ag.serializer)
	assert.Equal(t, mockMetricsReporters, ag.metricsReporters)
	assert.Equal(t, constants.StatusStart, ag.state)
	assert.NotNil(t, ag.Session)
	assert.True(t, ag.Session.GetIsFrontend())

	// second call should no call hdb encode
	mockMetricsReporter.EXPECT().ReportGauge(metrics.ConnectedClients, gomock.Any(), gomock.Any())
	ag = newAgent(nil, nil, mockEncoder, mockSerializer, hbTime, writeTimeout, 10, dieChan, messageEncoder, mockMetricsReporters, sessionPool).(*agentImpl)
	assert.NotNil(t, ag)
}

func TestKick(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	mockDecoder := codecmocks.NewMockPacketDecoder(ctrl)
	dieChan := make(chan bool)
	hbTime := time.Second
	writeTimeout := time.Second

	mockConn := mocks.NewMockPlayerConn(ctrl)
	mockEncoder.EXPECT().Encode(gomock.Any(), gomock.Nil()).Do(
		func(typ packet.Type, d []byte) {
			assert.EqualValues(t, packet.Kick, typ)
		})
	mockConn.EXPECT().Write(gomock.Any()).Return(0, nil)
	messageEncoder := message.NewMessagesEncoder(false)

	mockSerializer.EXPECT().GetName()

	sessionPool := session.NewSessionPool()
	ag := newAgent(mockConn, mockDecoder, mockEncoder, mockSerializer, hbTime, writeTimeout, 10, dieChan, messageEncoder, nil, sessionPool)
	c := context.Background()
	err := ag.Kick(c)
	assert.NoError(t, err)
}

func TestAgentSend(t *testing.T) {
	tables := []struct {
		name string
		err  error
	}{
		{"success", nil},
		{"failure", e.NewError(
			fmt.Errorf("%s: send on closed channel", constants.ErrBrokenPipe.Error()),
			e.ErrClientClosedRequest,
		)},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			mockSerializer := serializemocks.NewMockSerializer(ctrl)
			mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
			heartbeatAndHandshakeMocks(mockEncoder)
			mockDecoder := codecmocks.NewMockPacketDecoder(ctrl)
			dieChan := make(chan bool)
			hbTime := time.Second
			writeTimeout := time.Second
			messageEncoder := message.NewMessagesEncoder(false)

			mockConn := mocks.NewMockPlayerConn(ctrl)
			mockSerializer.EXPECT().GetName()
			sessionPool := session.NewSessionPool()
			ag := newAgent(mockConn, mockDecoder, mockEncoder, mockSerializer, hbTime, writeTimeout, 10, dieChan, messageEncoder, nil, sessionPool).(*agentImpl)
			assert.NotNil(t, ag)

			if table.err != nil {
				close(ag.chSend)
			}
			pm := pendingMessage{}

			expectedBytes := []byte("ok")

			mockSerializer.EXPECT().Marshal(nil).Return(expectedBytes, nil)
			mockEncoder.EXPECT().Encode(packet.Type(packet.Data), gomock.Any()).Return(expectedBytes, nil)

			err := ag.send(pm)
			assert.Equal(t, table.err, err)

			expectedWrite := pendingWrite{
				ctx:  nil,
				data: expectedBytes,
				err:  nil,
			}

			if table.err == nil {
				recv := helpers.ShouldEventuallyReceive(t, ag.chSend).(pendingWrite)
				assert.Equal(t, expectedWrite, recv)
			}
		})
	}
}

func TestAgentSendSerializeErr(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockConn := mocks.NewMockPlayerConn(ctrl)
	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	messageEncoder := message.NewMessagesEncoder(false)
	mockMetricsReporter := metricsmocks.NewMockReporter(ctrl)
	mockMetricsReporters := []metrics.Reporter{mockMetricsReporter}
	sessionPool := session.NewSessionPool()
	ag := &agentImpl{ // avoid heartbeat and handshake to fully test serialize
		conn:             mockConn,
		chSend:           make(chan pendingWrite, 10),
		chDie:            make(chan struct{}),
		chStopWrite:      make(chan struct{}),
		chStopHeartbeat:  make(chan struct{}),
		encoder:          mockEncoder,
		heartbeatTimeout: time.Second,
		writeTimeout:     time.Second,
		lastAt:           time.Now().Unix(),
		serializer:       mockSerializer,
		messageEncoder:   messageEncoder,
		metricsReporters: mockMetricsReporters,
		Session:          sessionPool.NewSession(nil, true),
		logger:           logger.Log,
		sessionPool:      sessionPool,
	}

	ctx := getCtxWithRequestKeys()
	mockMetricsReporters[0].(*metricsmocks.MockReporter).EXPECT().ReportSummary(metrics.ResponseTime, gomock.Any(), gomock.Any())

	expected := pendingMessage{
		ctx:     ctx,
		typ:     message.Response,
		route:   uuid.New().String(),
		mid:     uint(rand.Int()),
		payload: someStruct{A: "bla"},
	}
	expectedErr := errors.New("noo")
	mockSerializer.EXPECT().Marshal(expected.payload).Return(nil, expectedErr)

	expectedBT := []byte("bla")
	mockSerializer.EXPECT().Marshal(&protos.Error{
		Code: e.ErrUnknownCode,
		Msg:  expectedErr.Error(),
	}).Return(expectedBT, nil)
	m := &message.Message{
		Type:  expected.typ,
		Data:  expectedBT,
		Route: expected.route,
		ID:    expected.mid,
		Err:   false,
	}

	em, err := messageEncoder.Encode(m)
	assert.NoError(t, err)
	expectedPacket := []byte("packet")
	mockEncoder.EXPECT().Encode(gomock.Any(), em).Return(expectedPacket, nil)

	var wg sync.WaitGroup
	wg.Add(1)
	mockConn.EXPECT().RemoteAddr().AnyTimes().Return(&mockAddr{})
	mockConn.EXPECT().SetWriteDeadline(gomock.Any()).Return(nil)
	mockConn.EXPECT().Write(expectedPacket).Do(func(b []byte) {
		wg.Done()
	})
	mockConn.EXPECT().Close().Return(nil)
	go ag.write()
	mockMetricsReporter.EXPECT().ReportHistogram(gomock.Any(), gomock.Any(), gomock.Any())
	mockMetricsReporter.EXPECT().ReportGauge(gomock.Any(), gomock.Any(), gomock.Any())
	ag.send(expected)
	wg.Wait()
	// Close the agent to properly clean up the write goroutine
	ag.Close()

}

func TestAgentPushFailsIfClosedAgent(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockSerializer.EXPECT().GetName()

	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	heartbeatAndHandshakeMocks(mockEncoder)
	messageEncoder := message.NewMessagesEncoder(false)

	sessionPool := session.NewSessionPool()
	ag := newAgent(nil, nil, mockEncoder, mockSerializer, time.Second, time.Second, 10, nil, messageEncoder, nil, sessionPool).(*agentImpl)
	assert.NotNil(t, ag)
	ag.state = constants.StatusClosed
	err := ag.Push("", nil)
	assert.Equal(t, e.NewError(constants.ErrBrokenPipe, e.ErrClientClosedRequest), err)
}

func TestAgentPushStruct(t *testing.T) {
	tables := []struct {
		name string
		data interface{}
		err  error
	}{
		{"success_struct", &someStruct{A: "ok"}, nil},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			mockSerializer := serializemocks.NewMockSerializer(ctrl)
			mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
			heartbeatAndHandshakeMocks(mockEncoder)
			mockDecoder := codecmocks.NewMockPacketDecoder(ctrl)
			dieChan := make(chan bool)
			hbTime := time.Second
			writeTimeout := time.Second
			messageEncoder := message.NewMessagesEncoder(false)
			mockMetricsReporter := metricsmocks.NewMockReporter(ctrl)
			mockConn := mocks.NewMockPlayerConn(ctrl)
			mockMetricsReporters := []metrics.Reporter{mockMetricsReporter}
			mockMetricsReporter.EXPECT().ReportGauge(metrics.ConnectedClients, gomock.Any(), gomock.Any())
			mockSerializer.EXPECT().GetName()
			sessionPool := session.NewSessionPool()
			ag := newAgent(mockConn, mockDecoder, mockEncoder, mockSerializer, hbTime, writeTimeout, 10, dieChan, messageEncoder, mockMetricsReporters, sessionPool).(*agentImpl)
			assert.NotNil(t, ag)

			expectedBytes := []byte("hello")
			msg := &message.Message{
				Type:  message.Push,
				Route: uuid.New().String(),
				Data:  expectedBytes,
			}
			em, err := messageEncoder.Encode(msg)
			assert.NoError(t, err)
			mockSerializer.EXPECT().Marshal(table.data).Return(expectedBytes, nil)
			mockEncoder.EXPECT().Encode(packet.Type(packet.Data), em).Return(expectedBytes, nil)
			expectedWrite := pendingWrite{ctx: nil, data: expectedBytes, err: nil}

			if table.err != nil {
				close(ag.chSend)
			}

			mockMetricsReporter.EXPECT().ReportHistogram(metrics.ChannelCapacity, gomock.Any(), float64(10))
			err = ag.Push(msg.Route, table.data)
			assert.Equal(t, table.err, err)

			if table.err == nil {
				recvData := helpers.ShouldEventuallyReceive(t, ag.chSend).(pendingWrite)
				assert.Equal(t, expectedWrite, recvData)
			}
		})
	}
}

func TestAgentPush(t *testing.T) {
	tables := []struct {
		name string
		data []byte
		err  error
	}{
		{"success_raw", []byte("ok"), nil},
		{"failure", []byte("ok"), e.NewError(
			fmt.Errorf("%s: send on closed channel", constants.ErrBrokenPipe.Error()),
			e.ErrClientClosedRequest,
		)},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			mockSerializer := serializemocks.NewMockSerializer(ctrl)
			mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
			heartbeatAndHandshakeMocks(mockEncoder)
			mockDecoder := codecmocks.NewMockPacketDecoder(ctrl)
			dieChan := make(chan bool)
			hbTime := time.Second
			writeTimeout := time.Second
			messageEncoder := message.NewMessagesEncoder(false)
			mockMetricsReporter := metricsmocks.NewMockReporter(ctrl)
			mockConn := mocks.NewMockPlayerConn(ctrl)
			mockMetricsReporters := []metrics.Reporter{mockMetricsReporter}
			mockMetricsReporter.EXPECT().ReportGauge(metrics.ConnectedClients, gomock.Any(), gomock.Any())
			mockSerializer.EXPECT().GetName()
			sessionPool := session.NewSessionPool()
			ag := newAgent(mockConn, mockDecoder, mockEncoder, mockSerializer, hbTime, writeTimeout, 10, dieChan, messageEncoder, mockMetricsReporters, sessionPool).(*agentImpl)
			assert.NotNil(t, ag)

			expectedBytes := []byte("hello")
			msg := &message.Message{
				Type:  message.Push,
				Route: uuid.New().String(),
				Data:  table.data,
			}
			em, err := messageEncoder.Encode(msg)
			assert.NoError(t, err)
			mockEncoder.EXPECT().Encode(packet.Type(packet.Data), em).Return(expectedBytes, nil)
			expectedWrite := pendingWrite{ctx: nil, data: expectedBytes, err: nil}

			if table.err != nil {
				close(ag.chSend)
			}

			mockMetricsReporter.EXPECT().ReportHistogram(metrics.ChannelCapacity, gomock.Any(), float64(10))
			err = ag.Push(msg.Route, table.data)
			assert.Equal(t, table.err, err)

			if table.err == nil {
				recvData := helpers.ShouldEventuallyReceive(t, ag.chSend).(pendingWrite)
				assert.Equal(t, expectedWrite, recvData)
			}
		})
	}
}

func TestAgentPushFullChannel(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	heartbeatAndHandshakeMocks(mockEncoder)
	mockDecoder := codecmocks.NewMockPacketDecoder(ctrl)
	dieChan := make(chan bool)
	hbTime := time.Second
	writeTimeout := time.Second
	messageEncoder := message.NewMessagesEncoder(false)
	mockMetricsReporter := metricsmocks.NewMockReporter(ctrl)
	mockConn := mocks.NewMockPlayerConn(ctrl)
	mockMetricsReporters := []metrics.Reporter{mockMetricsReporter}
	mockMetricsReporter.EXPECT().ReportGauge(metrics.ConnectedClients, gomock.Any(), gomock.Any())
	mockSerializer.EXPECT().GetName()
	sessionPool := session.NewSessionPool()
	ag := newAgent(mockConn, mockDecoder, mockEncoder, mockSerializer, hbTime, writeTimeout, 0, dieChan, messageEncoder, mockMetricsReporters, sessionPool).(*agentImpl)
	assert.NotNil(t, ag)

	mockMetricsReporter.EXPECT().ReportHistogram(metrics.ChannelCapacity, gomock.Any(), float64(0))

	msg := &message.Message{
		Route: "route",
		Data:  []byte("data"),
		Type:  message.Push,
	}
	em, err := messageEncoder.Encode(msg)
	assert.NoError(t, err)

	mockEncoder.EXPECT().Encode(packet.Type(packet.Data), em)
	go func() {
		err := ag.Push(msg.Route, []byte("data"))
		assert.NoError(t, err)
	}()
	helpers.ShouldEventuallyReceive(t, ag.chSend)
}

func TestAgentResponseMIDFailsIfClosedAgent(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	heartbeatAndHandshakeMocks(mockEncoder)
	mockMessageEncoder := messagemocks.NewMockEncoder(ctrl)
	mockMetricsReporter := metricsmocks.NewMockReporter(ctrl)

	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockSerializer.EXPECT().GetName()

	mockMetricsReporters := []metrics.Reporter{mockMetricsReporter}
	mockMetricsReporter.EXPECT().ReportGauge(metrics.ConnectedClients, gomock.Any(), gomock.Any())
	sessionPool := session.NewSessionPool()
	ag := newAgent(nil, nil, mockEncoder, mockSerializer, time.Second, time.Second, 10, nil, mockMessageEncoder, mockMetricsReporters, sessionPool).(*agentImpl)
	assert.NotNil(t, ag)
	ag.state = constants.StatusClosed

	ctx := getCtxWithRequestKeys()
	err := ag.ResponseMID(ctx, 1, nil)
	assert.Equal(t, e.NewError(constants.ErrBrokenPipe, e.ErrClientClosedRequest), err)
}

func TestAgentResponseMID(t *testing.T) {
	tables := []struct {
		name   string
		mid    uint
		data   interface{}
		msgErr bool
		err    error
	}{
		{"success_raw", uint(rand.Int()), []byte("ok"), false, nil},
		{"success_raw_msg_err", uint(rand.Int()), []byte("ok"), true, nil},
		{"success_struct", uint(rand.Int()), &someStruct{A: "ok"}, false, nil},
		{"failure_empty_mid", 0, []byte("ok"), false, constants.ErrSessionOnNotify},
		{"failure_send", uint(rand.Int()), []byte("ok"), false, e.NewError(
			fmt.Errorf("%s: send on closed channel", constants.ErrBrokenPipe.Error()),
			e.ErrClientClosedRequest,
		)},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			mockMetricsReporter := metricsmocks.NewMockReporter(ctrl)
			mockSerializer := serializemocks.NewMockSerializer(ctrl)
			mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
			heartbeatAndHandshakeMocks(mockEncoder)
			mockDecoder := codecmocks.NewMockPacketDecoder(ctrl)
			dieChan := make(chan bool)
			hbTime := time.Second
			writeTimeout := time.Second
			messageEncoder := message.NewMessagesEncoder(false)

			mockConn := mocks.NewMockPlayerConn(ctrl)
			mockMetricsReporters := []metrics.Reporter{mockMetricsReporter}
			mockMetricsReporter.EXPECT().ReportGauge(metrics.ConnectedClients, gomock.Any(), gomock.Any())
			mockSerializer.EXPECT().GetName()
			sessionPool := session.NewSessionPool()
			ag := newAgent(mockConn, mockDecoder, mockEncoder, mockSerializer, hbTime, writeTimeout, 10, dieChan, messageEncoder, mockMetricsReporters, sessionPool).(*agentImpl)
			assert.NotNil(t, ag)

			ctx := getCtxWithRequestKeys()
			if table.mid != 0 {
				mockEncoder.EXPECT().Encode(gomock.Any(), gomock.Any()).Return([]byte("ok!"), nil)
				mockMetricsReporter.EXPECT().ReportHistogram(metrics.ChannelCapacity, gomock.Any(), float64(10))
			}
			if table.mid != 0 {
				if table.err != nil {
					close(ag.chSend)
				}
			}
			if reflect.TypeOf(table.data) != reflect.TypeOf([]byte{}) {
				mockSerializer.EXPECT().Marshal(table.data).Return([]byte("ok"), nil)
			}
			expected := pendingWrite{ctx: ctx, data: []byte("ok!"), err: nil}
			var err error
			if table.msgErr {
				mockSerializer.EXPECT().Unmarshal(gomock.Any(), gomock.Any()).Return(nil)
				err = ag.ResponseMID(ctx, table.mid, table.data, table.msgErr)
			} else {
				err = ag.ResponseMID(ctx, table.mid, table.data)
			}
			assert.Equal(t, table.err, err)

			if table.err == nil {
				recv := helpers.ShouldEventuallyReceive(t, ag.chSend).(pendingWrite)
				assert.Equal(t, expected.ctx, recv.ctx)
				assert.Equal(t, expected.data, recv.data)
				if table.msgErr {
					assert.NotNil(t, recv.err)
				}
			}
		})
	}
}

func TestAgentResponseMIDFullChannel(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	heartbeatAndHandshakeMocks(mockEncoder)
	mockDecoder := codecmocks.NewMockPacketDecoder(ctrl)
	dieChan := make(chan bool)
	hbTime := time.Second
	writeTimeout := time.Second
	messageEncoder := message.NewMessagesEncoder(false)
	mockMetricsReporter := metricsmocks.NewMockReporter(ctrl)
	mockConn := mocks.NewMockPlayerConn(ctrl)
	mockMetricsReporters := []metrics.Reporter{mockMetricsReporter}
	mockMetricsReporter.EXPECT().ReportGauge(metrics.ConnectedClients, gomock.Any(), gomock.Any())
	mockSerializer.EXPECT().GetName()
	mockEncoder.EXPECT().Encode(packet.Type(packet.Data), gomock.Any())
	sessionPool := session.NewSessionPool()
	ag := newAgent(mockConn, mockDecoder, mockEncoder, mockSerializer, hbTime, writeTimeout, 0, dieChan, messageEncoder, mockMetricsReporters, sessionPool).(*agentImpl)
	assert.NotNil(t, ag)
	mockMetricsReporters[0].(*metricsmocks.MockReporter).EXPECT().ReportHistogram(metrics.ChannelCapacity, gomock.Any(), float64(0))
	go func() {
		err := ag.ResponseMID(nil, 1, []byte("data"))
		assert.NoError(t, err)
	}()
	helpers.ShouldEventuallyReceive(t, ag.chSend)
}

func TestAgentCloseFailsIfAlreadyClosed(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	heartbeatAndHandshakeMocks(mockEncoder)
	mockMessageEncoder := messagemocks.NewMockEncoder(ctrl)
	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockSerializer.EXPECT().GetName()

	sessionPool := session.NewSessionPool()
	ag := newAgent(nil, nil, mockEncoder, mockSerializer, time.Second, time.Second, 10, nil, mockMessageEncoder, nil, sessionPool).(*agentImpl)
	assert.NotNil(t, ag)
	ag.state = constants.StatusClosed
	err := ag.Close()
	assert.Equal(t, constants.ErrCloseClosedSession, err)
}

func TestAgentClose(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockConn := mocks.NewMockPlayerConn(ctrl)
	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	heartbeatAndHandshakeMocks(mockEncoder)
	mockMessageEncoder := messagemocks.NewMockEncoder(ctrl)
	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockSerializer.EXPECT().GetName()

	sessionPool := session.NewSessionPool()
	ag := newAgent(mockConn, nil, mockEncoder, mockSerializer, time.Second, time.Second, 0, nil, mockMessageEncoder, nil, sessionPool).(*agentImpl)
	assert.NotNil(t, ag)

	expected := false
	f := func() { expected = true }
	err := ag.Session.OnClose(f)
	assert.NoError(t, err)

	// validate channels are closed
	stopWrite := false
	stopHeartbeat := false
	die := false
	go func() {
		for {
			select {
			case <-ag.chStopWrite:
				stopWrite = true
			case <-ag.chStopHeartbeat:
				stopHeartbeat = true
			case <-ag.chDie:
				die = true
			}
		}
	}()

	mockConn.EXPECT().RemoteAddr()
	mockConn.EXPECT().Close()
	err = ag.Close()
	assert.NoError(t, err)
	assert.Equal(t, ag.state, constants.StatusClosed)
	assert.True(t, expected)
	helpers.ShouldEventuallyReturn(
		t, func() bool { return stopWrite && stopHeartbeat && die },
		true, 50*time.Millisecond, 500*time.Millisecond)
}

func TestAgentRemoteAddr(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockConn := mocks.NewMockPlayerConn(ctrl)
	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	heartbeatAndHandshakeMocks(mockEncoder)
	mockMessageEncoder := messagemocks.NewMockEncoder(ctrl)
	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockSerializer.EXPECT().GetName()

	sessionPool := session.NewSessionPool()
	ag := newAgent(mockConn, nil, mockEncoder, mockSerializer, time.Second, time.Second, 0, nil, mockMessageEncoder, nil, sessionPool)
	assert.NotNil(t, ag)

	expected := &mockAddr{}
	mockConn.EXPECT().RemoteAddr().Return(expected)
	addr := ag.RemoteAddr()
	assert.Equal(t, expected, addr)
}

func TestAgentString(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockConn := mocks.NewMockPlayerConn(ctrl)
	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	heartbeatAndHandshakeMocks(mockEncoder)
	mockMessageEncoder := messagemocks.NewMockEncoder(ctrl)
	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockSerializer.EXPECT().GetName()

	sessionPool := session.NewSessionPool()
	ag := newAgent(mockConn, nil, mockEncoder, mockSerializer, time.Second, time.Second, 0, nil, mockMessageEncoder, nil, sessionPool).(*agentImpl)
	assert.NotNil(t, ag)

	mockConn.EXPECT().RemoteAddr().Return(&mockAddr{})
	expected := fmt.Sprintf("Remote=remote-string, LastTime=%d", ag.lastAt)
	str := ag.String()
	assert.Equal(t, expected, str)
}

func TestAgentGetStatus(t *testing.T) {
	tables := []struct {
		name   string
		status int32
	}{
		{"start", constants.StatusStart},
		{"closed", constants.StatusClosed},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			mockConn := mocks.NewMockPlayerConn(ctrl)
			mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
			heartbeatAndHandshakeMocks(mockEncoder)
			mockMessageEncoder := messagemocks.NewMockEncoder(ctrl)

			mockSerializer := serializemocks.NewMockSerializer(ctrl)
			mockSerializer.EXPECT().GetName()

			sessionPool := session.NewSessionPool()
			ag := newAgent(mockConn, nil, mockEncoder, mockSerializer, time.Second, time.Second, 0, nil, mockMessageEncoder, nil, sessionPool).(*agentImpl)
			assert.NotNil(t, ag)

			ag.state = table.status

			status := ag.GetStatus()
			assert.Equal(t, table.status, status)
		})
	}
}

func TestAgentSetLastAt(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	heartbeatAndHandshakeMocks(mockEncoder)
	mockMessageEncoder := messagemocks.NewMockEncoder(ctrl)
	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockSerializer.EXPECT().GetName()

	sessionPool := session.NewSessionPool()
	ag := newAgent(nil, nil, mockEncoder, mockSerializer, time.Second, time.Second, 0, nil, mockMessageEncoder, nil, sessionPool).(*agentImpl)
	assert.NotNil(t, ag)

	ag.lastAt = 0
	ag.SetLastAt()
	assert.InDelta(t, time.Now().Unix(), ag.lastAt, 1)
}

func TestAgentSetStatus(t *testing.T) {
	tables := []struct {
		name   string
		status int32
	}{
		{"start", constants.StatusStart},
		{"closed", constants.StatusClosed},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
			heartbeatAndHandshakeMocks(mockEncoder)
			mockMessageEncoder := messagemocks.NewMockEncoder(ctrl)
			mockSerializer := serializemocks.NewMockSerializer(ctrl)
			mockSerializer.EXPECT().GetName()

			sessionPool := session.NewSessionPool()
			ag := newAgent(nil, nil, mockEncoder, mockSerializer, time.Second, time.Second, 0, nil, mockMessageEncoder, nil, sessionPool).(*agentImpl)
			assert.NotNil(t, ag)

			ag.SetStatus(table.status)
			assert.Equal(t, table.status, ag.state)
		})
	}
}

func TestOnSessionClosed(t *testing.T) {
	ctrl := gomock.NewController(t)

	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	heartbeatAndHandshakeMocks(mockEncoder)
	mockMessageEncoder := messagemocks.NewMockEncoder(ctrl)
	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockSerializer.EXPECT().GetName()
	sessionPool := session.NewSessionPool()
	ag := newAgent(nil, nil, mockEncoder, mockSerializer, time.Second, time.Second, 0, nil, mockMessageEncoder, nil, sessionPool).(*agentImpl)

	ss := sessionPool.NewSession(nil, true)

	expected := false
	f := func() { expected = true }
	err := ss.OnClose(f)
	assert.NoError(t, err)

	assert.NotPanics(t, func() { ag.onSessionClosed(ss) })
	assert.True(t, expected)
}

func TestOnSessionClosedRecoversIfPanic(t *testing.T) {
	ctrl := gomock.NewController(t)

	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	heartbeatAndHandshakeMocks(mockEncoder)
	mockMessageEncoder := messagemocks.NewMockEncoder(ctrl)
	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockSerializer.EXPECT().GetName()
	sessionPool := session.NewSessionPool()
	ag := newAgent(nil, nil, mockEncoder, mockSerializer, time.Second, time.Second, 0, nil, mockMessageEncoder, nil, sessionPool).(*agentImpl)

	ss := sessionPool.NewSession(nil, true)

	expected := false
	f := func() {
		expected = true
		panic("oh noes")
	}
	err := ss.OnClose(f)
	assert.NoError(t, err)

	assert.NotPanics(t, func() { ag.onSessionClosed(ss) })
	assert.True(t, expected)
}

func TestAgentSendHandshakeResponse(t *testing.T) {
	tables := []struct {
		name string
		err  error
	}{
		{"success", nil},
		{"failure", errors.New("handshake failed")},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			mockConn := mocks.NewMockPlayerConn(ctrl)
			mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
			heartbeatAndHandshakeMocks(mockEncoder)
			mockMessageEncoder := messagemocks.NewMockEncoder(ctrl)
			mockSerializer := serializemocks.NewMockSerializer(ctrl)
			mockSerializer.EXPECT().GetName()

			sessionPool := session.NewSessionPool()
			ag := newAgent(mockConn, nil, mockEncoder, mockSerializer, time.Second, time.Second, 0, nil, mockMessageEncoder, nil, sessionPool)
			assert.NotNil(t, ag)

			mockConn.EXPECT().Write(hrd).Return(0, table.err)
			err := ag.SendHandshakeResponse()
			assert.Equal(t, table.err, err)
		})
	}
}

func TestAnswerWithError(t *testing.T) {
	unknownError := e.NewError(errors.New(""), e.ErrUnknownCode)
	table := []struct {
		name          string
		answeredErr   error
		encoderErr    error
		getPayloadErr error
		expectedErr   error
	}{
		{
			name:          "should succeed with unknown error",
			answeredErr:   assert.AnError,
			encoderErr:    nil,
			getPayloadErr: nil,
			expectedErr:   unknownError,
		},
		{
			name:          "should not answer if fails to get payload",
			answeredErr:   assert.AnError,
			encoderErr:    nil,
			getPayloadErr: errors.New("serialize err"),
			expectedErr:   nil,
		},
		{
			name:          "should not answer if fails to send",
			answeredErr:   assert.AnError,
			encoderErr:    assert.AnError,
			getPayloadErr: nil,
			expectedErr:   nil,
		},
	}

	for _, row := range table {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			mockSerializer := serializemocks.NewMockSerializer(ctrl)
			mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
			heartbeatAndHandshakeMocks(mockEncoder)
			messageEncoder := message.NewMessagesEncoder(false)
			mockSerializer.EXPECT().GetName()
			sessionPool := session.NewSessionPool()
			ag := newAgent(nil, nil, mockEncoder, mockSerializer, time.Second, time.Second, 1, nil, messageEncoder, nil, sessionPool).(*agentImpl)
			assert.NotNil(t, ag)

			mockSerializer.EXPECT().Marshal(gomock.Any()).Return(nil, row.getPayloadErr).AnyTimes()
			mockSerializer.EXPECT().Unmarshal(gomock.Any(), gomock.Any()).Return(nil).AnyTimes()
			mockEncoder.EXPECT().Encode(packet.Type(packet.Data), gomock.Any()).Return(nil, row.encoderErr).AnyTimes()

			ag.AnswerWithError(nil, uint(rand.Int()), row.answeredErr)
			if row.expectedErr != nil {
				pWrite := helpers.ShouldEventuallyReceive(t, ag.chSend)
				assert.Equal(t, pendingWrite{err: row.expectedErr}, pWrite)
			}
		})
	}
}

type customSerializer struct{}

func (*customSerializer) Marshal(obj interface{}) ([]byte, error) { return json.Marshal(obj) }
func (*customSerializer) Unmarshal(data []byte, obj interface{}) error {
	return json.Unmarshal(data, obj)
}
func (*customSerializer) GetName() string { return "custom" }

func TestAgentAnswerWithError(t *testing.T) {
	jsonSerializer, err := serialize.NewSerializer(serialize.JSON)
	require.NoError(t, err)

	protobufSerializer, err := serialize.NewSerializer(serialize.PROTOBUF)
	require.NoError(t, err)

	customSerializer := &customSerializer{}

	table := []struct {
		name        string
		answeredErr error
		serializer  serialize.Serializer
		expectedErr error
	}{
		{
			name:        "should return unknown code for generic error and JSON serializer",
			answeredErr: assert.AnError,
			serializer:  jsonSerializer,
			expectedErr: e.NewError(assert.AnError, e.ErrUnknownCode),
		},
		{
			name:        "should return custom code for pitaya error and JSON serializer",
			answeredErr: e.NewError(assert.AnError, "CUSTOM-123"),
			serializer:  jsonSerializer,
			expectedErr: e.NewError(assert.AnError, "CUSTOM-123"),
		},
		{
			name:        "should return unknown code for generic error and Protobuf serializer",
			answeredErr: assert.AnError,
			serializer:  protobufSerializer,
			expectedErr: e.NewError(assert.AnError, e.ErrUnknownCode),
		},
		{
			name:        "should return custom code for pitaya error and Protobuf serializer",
			answeredErr: e.NewError(assert.AnError, "CUSTOM-123"),
			serializer:  protobufSerializer,
			expectedErr: e.NewError(assert.AnError, "CUSTOM-123"),
		},
		{
			name:        "should return unknown code for generic error and custom serializer",
			answeredErr: assert.AnError,
			serializer:  customSerializer,
			expectedErr: e.NewError(assert.AnError, e.ErrUnknownCode),
		},
		{
			name:        "should return custom code for pitaya error and custom serializer",
			answeredErr: e.NewError(assert.AnError, "CUSTOM-123"),
			serializer:  customSerializer,
			expectedErr: e.NewError(assert.AnError, "CUSTOM-123"),
		},
	}

	for _, row := range table {
		t.Run(row.name, func(t *testing.T) {
			encoder := codec.NewPomeloPacketEncoder()

			messageEncoder := message.NewMessagesEncoder(false)
			sessionPool := session.NewSessionPool()
			ag := newAgent(nil, nil, encoder, row.serializer, time.Second, time.Second, 1, nil, messageEncoder, nil, sessionPool).(*agentImpl)
			assert.NotNil(t, ag)

			ag.AnswerWithError(nil, uint(rand.Int()), row.answeredErr)

			pWrite := helpers.ShouldEventuallyReceive(t, ag.chSend)
			assert.Equal(t, row.expectedErr, pWrite.(pendingWrite).err)
		})
	}
}

func TestAgentHeartbeat(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	heartbeatAndHandshakeMocks(mockEncoder)
	mockConn := mocks.NewMockPlayerConn(ctrl)
	mockMessageEncoder := messagemocks.NewMockEncoder(ctrl)
	mockSerializer.EXPECT().GetName()
	sessionPool := session.NewSessionPool()
	ag := newAgent(mockConn, nil, mockEncoder, mockSerializer, 1*time.Second, time.Second, 1, nil, mockMessageEncoder, nil, sessionPool).(*agentImpl)
	assert.NotNil(t, ag)

	mockConn.EXPECT().RemoteAddr().MaxTimes(1)
	mockConn.EXPECT().Close().MaxTimes(1)

	die := false
	go func() {
		for {
			select {
			case <-ag.chDie:
				die = true
			}
		}
	}()

	go ag.heartbeat()
	for i := 0; i < 2; i++ {
		pWrite := helpers.ShouldEventuallyReceive(t, ag.chSend, 1100*time.Millisecond).(pendingWrite)
		assert.Equal(t, pendingWrite{data: hbd}, pWrite)
	}
	helpers.ShouldEventuallyReturn(t, func() bool { return die }, true, 500*time.Millisecond, 5*time.Second)
}

func TestAgentHeartbeatExitsIfConnError(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	heartbeatAndHandshakeMocks(mockEncoder)
	mockConn := mocks.NewMockPlayerConn(ctrl)
	mockMessageEncoder := messagemocks.NewMockEncoder(ctrl)
	mockSerializer.EXPECT().GetName()
	sessionPool := session.NewSessionPool()
	ag := newAgent(mockConn, nil, mockEncoder, mockSerializer, 1*time.Second, time.Second, 1, nil, mockMessageEncoder, nil, sessionPool).(*agentImpl)
	assert.NotNil(t, ag)

	mockConn.EXPECT().RemoteAddr().MaxTimes(1)
	mockConn.EXPECT().Close().MaxTimes(1)

	die := false
	go func() {
		for {
			select {
			case <-ag.chDie:
				die = true
			}
		}
	}()

	go ag.heartbeat()
	for i := 0; i < 2; i++ {
		pWrite := helpers.ShouldEventuallyReceive(t, ag.chSend, 1100*time.Millisecond).(pendingWrite)
		assert.Equal(t, pendingWrite{data: hbd}, pWrite)
	}

	helpers.ShouldEventuallyReturn(t, func() bool { return die }, true, 500*time.Millisecond, 2*time.Second)
}

func TestAgentHeartbeatExitsOnStopHeartbeat(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	heartbeatAndHandshakeMocks(mockEncoder)
	mockConn := mocks.NewMockPlayerConn(ctrl)
	messageEncoder := message.NewMessagesEncoder(false)

	mockConn.EXPECT().RemoteAddr().MaxTimes(1)
	mockConn.EXPECT().Close().MaxTimes(1)

	mockSerializer.EXPECT().GetName()
	sessionPool := session.NewSessionPool()
	ag := newAgent(mockConn, nil, mockEncoder, mockSerializer, 1*time.Second, time.Second, 1, nil, messageEncoder, nil, sessionPool).(*agentImpl)
	assert.NotNil(t, ag)

	go func() {
		time.Sleep(500 * time.Millisecond)
		ag.Close()
	}()

	ag.heartbeat()
}

func TestAgentWriteChSend(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	mockConn := mocks.NewMockPlayerConn(ctrl)
	messageEncoder := message.NewMessagesEncoder(false)
	mockMetricsReporter := metricsmocks.NewMockReporter(ctrl)
	mockMetricsReporters := []metrics.Reporter{mockMetricsReporter}
	sessionPool := session.NewSessionPool()
	ag := &agentImpl{ // avoid heartbeat and handshake to fully test serialize
		conn:             mockConn,
		chSend:           make(chan pendingWrite, 10),
		encoder:          mockEncoder,
		heartbeatTimeout: time.Second,
		lastAt:           time.Now().Unix(),
		serializer:       mockSerializer,
		messageEncoder:   messageEncoder,
		metricsReporters: mockMetricsReporters,
		writeTimeout:     time.Second,
		sessionPool:      sessionPool,
	}
	ag.Session = sessionPool.NewSession(ag, true)
	ctx := getCtxWithRequestKeys()
	mockMetricsReporters[0].(*metricsmocks.MockReporter).EXPECT().ReportSummary(metrics.ResponseTime, gomock.Any(), gomock.Any())

	expectedPacket := []byte("final")

	var wg sync.WaitGroup
	wg.Add(1)
	mockConn.EXPECT().RemoteAddr().Times(2).Return(&mockAddr{})
	mockConn.EXPECT().SetWriteDeadline(gomock.Any()).Return(nil)
	mockConn.EXPECT().Write(expectedPacket).Do(func(b []byte) {
		time.Sleep(10 * time.Millisecond)
		wg.Done()
	})
	go ag.write()
	ag.chSend <- pendingWrite{ctx: ctx, data: expectedPacket, err: nil}
	wg.Wait()
}

func TestAgentHandle(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	heartbeatAndHandshakeMocks(mockEncoder)
	mockConn := mocks.NewMockPlayerConn(ctrl)
	messageEncoder := message.NewMessagesEncoder(false)
	mockSerializer.EXPECT().GetName()
	sessionPool := session.NewSessionPool()
	ag := newAgent(mockConn, nil, mockEncoder, mockSerializer, 1*time.Second, time.Second, 1, nil, messageEncoder, nil, sessionPool).(*agentImpl)
	assert.NotNil(t, ag)

	expectedBytes := []byte("bla")

	// Sends two heartbeats and then times out
	mockConn.EXPECT().Write(hbd).Return(0, nil).Times(2)
	var wg sync.WaitGroup
	wg.Add(1)
	closed := false
	go func() {
		for {
			select {
			case <-ag.chDie:
				closed = true
			}
		}
	}()

	mockConn.EXPECT().SetWriteDeadline(gomock.Any()).Return(nil).Times(3)
	mockConn.EXPECT().Write(expectedBytes).Return(0, nil).Do(func(d []byte) {
		wg.Done()
	})

	// ag.Close on method exit
	mockConn.EXPECT().RemoteAddr().MaxTimes(2)
	mockConn.EXPECT().Close().MaxTimes(1)

	ag.chSend <- pendingWrite{ctx: nil, data: expectedBytes, err: nil}

	go ag.Handle()

	wg.Wait()
	helpers.ShouldEventuallyReturn(t, func() bool { return closed }, true, 50*time.Millisecond, 5*time.Second)
}

func TestNatsRPCServerReportMetrics(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	heartbeatAndHandshakeMocks(mockEncoder)
	mockDecoder := codecmocks.NewMockPacketDecoder(ctrl)
	dieChan := make(chan bool)
	hbTime := time.Second
	writeTimeout := time.Second
	messageEncoder := message.NewMessagesEncoder(false)
	mockMetricsReporter := metricsmocks.NewMockReporter(ctrl)
	mockMetricsReporters := []metrics.Reporter{mockMetricsReporter}
	mockConn := mocks.NewMockPlayerConn(ctrl)
	mockMetricsReporter.EXPECT().ReportGauge(metrics.ConnectedClients, gomock.Any(), gomock.Any())
	mockSerializer.EXPECT().GetName()
	sessionPool := session.NewSessionPool()
	ag := newAgent(mockConn, mockDecoder, mockEncoder, mockSerializer, hbTime, writeTimeout, 10, dieChan, messageEncoder, mockMetricsReporters, sessionPool).(*agentImpl)
	assert.NotNil(t, ag)

	ag.messagesBufferSize = 0

	ag.chSend <- pendingWrite{}

	mockMetricsReporter.EXPECT().ReportHistogram(metrics.ChannelCapacity, gomock.Any(), float64(-1))
	ag.reportChannelSize()
}

type customMockAddr struct{ network, str string }

func (m *customMockAddr) Network() string { return m.network }
func (m *customMockAddr) String() string  { return m.str }

func TestIPVersion(t *testing.T) {
	tables := []struct {
		addr      string
		ipVersion string
	}{
		{"127.0.0.1:80", constants.IPv4},
		{"1.2.3.4:3333", constants.IPv4},
		{"::1:3333", constants.IPv6},
		{"2001:db8:0000:1:1:1:1:1:3333", constants.IPv6},
	}

	for _, table := range tables {
		t.Run("test_"+table.addr, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			mockConn := mocks.NewMockPlayerConn(ctrl)
			mockAddr := &customMockAddr{str: table.addr}

			mockConn.EXPECT().RemoteAddr().Return(mockAddr)
			a := &agentImpl{conn: mockConn}

			assert.Equal(t, table.ipVersion, a.IPVersion())
		})
	}
}

func TestAgentWriteChSendWriteError(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockSerializer.EXPECT().GetName()

	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	mockConn := mocks.NewMockPlayerConn(ctrl)
	messageEncoder := message.NewMessagesEncoder(false)
	mockMetricsReporter := metricsmocks.NewMockReporter(ctrl)
	mockMetricsReporter.EXPECT().ReportGauge(metrics.ConnectedClients, gomock.Any(), gomock.Any())

	mockMetricsReporters := []metrics.Reporter{mockMetricsReporter}
	sessionPool := session.NewSessionPool()

	ag := newAgent(mockConn, nil, mockEncoder, mockSerializer, time.Second, time.Second, 0, nil, messageEncoder, mockMetricsReporters, sessionPool).(*agentImpl)

	ctx := getCtxWithRequestKeys()

	expectedPacket := []byte("final")

	writeError := errors.New("write error")

	var wg sync.WaitGroup
	wg.Add(2)

	errorTags := map[string]string{}
	errorTags["route"] = "route"
	errorTags["status"] = "failed"
	errorTags["type"] = "handler"
	errorTags["code"] = e.ErrClosedRequest

	mockMetricsReporter.EXPECT().ReportGauge(metrics.ConnectedClients, gomock.Any(), gomock.Any())
	mockMetricsReporter.EXPECT().ReportSummary(metrics.ResponseTime, errorTags, gomock.Any())

	mockConn.EXPECT().RemoteAddr().Return(&mockAddr{}).Times(4)
	mockConn.EXPECT().Close().Do(func() {
		wg.Done()
	})
	mockConn.EXPECT().SetWriteDeadline(gomock.Any()).Return(nil)
	mockConn.EXPECT().Write(expectedPacket).Do(func(b []byte) {
		wg.Done()
	}).Return(0, writeError)

	go ag.write()
	ag.chSend <- pendingWrite{ctx: ctx, data: expectedPacket, err: nil}
	wg.Wait()
}

func TestAgentWriteChSendWriteTimeout(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockSerializer.EXPECT().GetName()

	mockEncoder := codecmocks.NewMockPacketEncoder(ctrl)
	mockConn := mocks.NewMockPlayerConn(ctrl)
	messageEncoder := message.NewMessagesEncoder(false)
	mockMetricsReporter := metricsmocks.NewMockReporter(ctrl)
	mockMetricsReporter.EXPECT().ReportGauge(metrics.ConnectedClients, gomock.Any(), gomock.Any())

	mockMetricsReporters := []metrics.Reporter{mockMetricsReporter}
	sessionPool := session.NewSessionPool()

	writeTimeout := 10 * time.Millisecond

	ag := newAgent(mockConn, nil, mockEncoder, mockSerializer, time.Second, writeTimeout, 0, nil, messageEncoder, mockMetricsReporters, sessionPool).(*agentImpl)

	ctx := getCtxWithRequestKeys()

	expectedFirstPacket := []byte("first")
	expectedSecondPacket := []byte("final")

	var wg sync.WaitGroup
	wg.Add(2)

	mockMetricsReporter.EXPECT().ReportSummary(metrics.ResponseTime, gomock.Any(), gomock.Any()).Times(2)

	mockConn.EXPECT().RemoteAddr().Return(&mockAddr{}).Times(5)
	mockConn.EXPECT().SetWriteDeadline(gomock.Any()).Return(nil).Times(2)
	mockConn.EXPECT().Write(expectedFirstPacket).Do(func(b []byte) {
		time.Sleep(writeTimeout * 2)
		wg.Done()
	}).Return(0, os.ErrDeadlineExceeded)

	mockConn.EXPECT().Write(expectedSecondPacket).Do(func(b []byte) {
		wg.Done()
	}).Return(0, nil)

	go ag.write()
	ag.chSend <- pendingWrite{ctx: ctx, data: expectedFirstPacket, err: nil}
	ag.chSend <- pendingWrite{ctx: ctx, data: expectedSecondPacket, err: nil}
	wg.Wait()
}

```

`pkg/agent/mocks/agent.go`:

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/topfreegames/pitaya/v3/pkg/agent (interfaces: Agent,AgentFactory)

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	net "net"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	agent "github.com/topfreegames/pitaya/v3/pkg/agent"
	protos "github.com/topfreegames/pitaya/v3/pkg/protos"
	session "github.com/topfreegames/pitaya/v3/pkg/session"
)

// MockAgent is a mock of Agent interface.
type MockAgent struct {
	ctrl     *gomock.Controller
	recorder *MockAgentMockRecorder
}

// MockAgentMockRecorder is the mock recorder for MockAgent.
type MockAgentMockRecorder struct {
	mock *MockAgent
}

// NewMockAgent creates a new mock instance.
func NewMockAgent(ctrl *gomock.Controller) *MockAgent {
	mock := &MockAgent{ctrl: ctrl}
	mock.recorder = &MockAgentMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAgent) EXPECT() *MockAgentMockRecorder {
	return m.recorder
}

// AnswerWithError mocks base method.
func (m *MockAgent) AnswerWithError(arg0 context.Context, arg1 uint, arg2 error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AnswerWithError", arg0, arg1, arg2)
}

// AnswerWithError indicates an expected call of AnswerWithError.
func (mr *MockAgentMockRecorder) AnswerWithError(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AnswerWithError", reflect.TypeOf((*MockAgent)(nil).AnswerWithError), arg0, arg1, arg2)
}

// Close mocks base method.
func (m *MockAgent) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockAgentMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockAgent)(nil).Close))
}

// GetSession mocks base method.
func (m *MockAgent) GetSession() session.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSession")
	ret0, _ := ret[0].(session.Session)
	return ret0
}

// GetSession indicates an expected call of GetSession.
func (mr *MockAgentMockRecorder) GetSession() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSession", reflect.TypeOf((*MockAgent)(nil).GetSession))
}

// GetStatus mocks base method.
func (m *MockAgent) GetStatus() int32 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStatus")
	ret0, _ := ret[0].(int32)
	return ret0
}

// GetStatus indicates an expected call of GetStatus.
func (mr *MockAgentMockRecorder) GetStatus() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStatus", reflect.TypeOf((*MockAgent)(nil).GetStatus))
}

// Handle mocks base method.
func (m *MockAgent) Handle() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Handle")
}

// Handle indicates an expected call of Handle.
func (mr *MockAgentMockRecorder) Handle() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Handle", reflect.TypeOf((*MockAgent)(nil).Handle))
}

// IPVersion mocks base method.
func (m *MockAgent) IPVersion() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IPVersion")
	ret0, _ := ret[0].(string)
	return ret0
}

// IPVersion indicates an expected call of IPVersion.
func (mr *MockAgentMockRecorder) IPVersion() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IPVersion", reflect.TypeOf((*MockAgent)(nil).IPVersion))
}

// Kick mocks base method.
func (m *MockAgent) Kick(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Kick", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Kick indicates an expected call of Kick.
func (mr *MockAgentMockRecorder) Kick(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Kick", reflect.TypeOf((*MockAgent)(nil).Kick), arg0)
}

// Push mocks base method.
func (m *MockAgent) Push(arg0 string, arg1 interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Push", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Push indicates an expected call of Push.
func (mr *MockAgentMockRecorder) Push(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Push", reflect.TypeOf((*MockAgent)(nil).Push), arg0, arg1)
}

// RemoteAddr mocks base method.
func (m *MockAgent) RemoteAddr() net.Addr {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoteAddr")
	ret0, _ := ret[0].(net.Addr)
	return ret0
}

// RemoteAddr indicates an expected call of RemoteAddr.
func (mr *MockAgentMockRecorder) RemoteAddr() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoteAddr", reflect.TypeOf((*MockAgent)(nil).RemoteAddr))
}

// ResponseMID mocks base method.
func (m *MockAgent) ResponseMID(arg0 context.Context, arg1 uint, arg2 interface{}, arg3 ...bool) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ResponseMID", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ResponseMID indicates an expected call of ResponseMID.
func (mr *MockAgentMockRecorder) ResponseMID(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResponseMID", reflect.TypeOf((*MockAgent)(nil).ResponseMID), varargs...)
}

// SendHandshakeErrorResponse mocks base method.
func (m *MockAgent) SendHandshakeErrorResponse() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendHandshakeErrorResponse")
	ret0, _ := ret[0].(error)
	return ret0
}

// SendHandshakeErrorResponse indicates an expected call of SendHandshakeErrorResponse.
func (mr *MockAgentMockRecorder) SendHandshakeErrorResponse() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendHandshakeErrorResponse", reflect.TypeOf((*MockAgent)(nil).SendHandshakeErrorResponse))
}

// SendHandshakeResponse mocks base method.
func (m *MockAgent) SendHandshakeResponse() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendHandshakeResponse")
	ret0, _ := ret[0].(error)
	return ret0
}

// SendHandshakeResponse indicates an expected call of SendHandshakeResponse.
func (mr *MockAgentMockRecorder) SendHandshakeResponse() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendHandshakeResponse", reflect.TypeOf((*MockAgent)(nil).SendHandshakeResponse))
}

// SendRequest mocks base method.
func (m *MockAgent) SendRequest(arg0 context.Context, arg1, arg2 string, arg3 interface{}) (*protos.Response, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendRequest", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(*protos.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SendRequest indicates an expected call of SendRequest.
func (mr *MockAgentMockRecorder) SendRequest(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendRequest", reflect.TypeOf((*MockAgent)(nil).SendRequest), arg0, arg1, arg2, arg3)
}

// SetLastAt mocks base method.
func (m *MockAgent) SetLastAt() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetLastAt")
}

// SetLastAt indicates an expected call of SetLastAt.
func (mr *MockAgentMockRecorder) SetLastAt() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetLastAt", reflect.TypeOf((*MockAgent)(nil).SetLastAt))
}

// SetStatus mocks base method.
func (m *MockAgent) SetStatus(arg0 int32) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetStatus", arg0)
}

// SetStatus indicates an expected call of SetStatus.
func (mr *MockAgentMockRecorder) SetStatus(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetStatus", reflect.TypeOf((*MockAgent)(nil).SetStatus), arg0)
}

// String mocks base method.
func (m *MockAgent) String() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "String")
	ret0, _ := ret[0].(string)
	return ret0
}

// String indicates an expected call of String.
func (mr *MockAgentMockRecorder) String() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "String", reflect.TypeOf((*MockAgent)(nil).String))
}

// MockAgentFactory is a mock of AgentFactory interface.
type MockAgentFactory struct {
	ctrl     *gomock.Controller
	recorder *MockAgentFactoryMockRecorder
}

// MockAgentFactoryMockRecorder is the mock recorder for MockAgentFactory.
type MockAgentFactoryMockRecorder struct {
	mock *MockAgentFactory
}

// NewMockAgentFactory creates a new mock instance.
func NewMockAgentFactory(ctrl *gomock.Controller) *MockAgentFactory {
	mock := &MockAgentFactory{ctrl: ctrl}
	mock.recorder = &MockAgentFactoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAgentFactory) EXPECT() *MockAgentFactoryMockRecorder {
	return m.recorder
}

// CreateAgent mocks base method.
func (m *MockAgentFactory) CreateAgent(arg0 net.Conn) agent.Agent {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateAgent", arg0)
	ret0, _ := ret[0].(agent.Agent)
	return ret0
}

// CreateAgent indicates an expected call of CreateAgent.
func (mr *MockAgentFactoryMockRecorder) CreateAgent(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateAgent", reflect.TypeOf((*MockAgentFactory)(nil).CreateAgent), arg0)
}

```

`pkg/app.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package pitaya

import (
	"context"
	"os"
	"os/signal"
	"reflect"
	"strings"
	"syscall"
	"time"

	"github.com/golang/protobuf/proto"
	"github.com/topfreegames/pitaya/v3/pkg/acceptor"
	"github.com/topfreegames/pitaya/v3/pkg/cluster"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	pcontext "github.com/topfreegames/pitaya/v3/pkg/context"
	"github.com/topfreegames/pitaya/v3/pkg/docgenerator"
	"github.com/topfreegames/pitaya/v3/pkg/errors"
	"github.com/topfreegames/pitaya/v3/pkg/groups"
	"github.com/topfreegames/pitaya/v3/pkg/interfaces"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	logging "github.com/topfreegames/pitaya/v3/pkg/logger/interfaces"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
	mods "github.com/topfreegames/pitaya/v3/pkg/modules"
	"github.com/topfreegames/pitaya/v3/pkg/remote"
	"github.com/topfreegames/pitaya/v3/pkg/router"
	"github.com/topfreegames/pitaya/v3/pkg/serialize"
	"github.com/topfreegames/pitaya/v3/pkg/service"
	"github.com/topfreegames/pitaya/v3/pkg/session"
	"github.com/topfreegames/pitaya/v3/pkg/timer"
	"github.com/topfreegames/pitaya/v3/pkg/tracing"
	"github.com/topfreegames/pitaya/v3/pkg/worker"
	"go.opentelemetry.io/otel/trace"
)

// ServerMode represents a server mode
type ServerMode byte

const (
	_ ServerMode = iota
	// Cluster represents a server running with connection to other servers
	Cluster
	// Standalone represents a server running without connection to other servers
	Standalone
)

// Pitaya App interface
type Pitaya interface {
	GetDieChan() chan bool
	SetDebug(debug bool)
	SetHeartbeatTime(interval time.Duration)
	GetServerID() string
	GetMetricsReporters() []metrics.Reporter
	GetServer() *cluster.Server
	GetServerByID(id string) (*cluster.Server, error)
	GetServersByType(t string) (map[string]*cluster.Server, error)
	GetServers() []*cluster.Server
	GetSessionFromCtx(ctx context.Context) session.Session
	Start()
	SetDictionary(dict map[string]uint16) error
	AddRoute(serverType string, routingFunction router.RoutingFunc) error
	Shutdown()
	StartWorker()
	RegisterRPCJob(rpcJob worker.RPCJob) error
	Documentation(getPtrNames bool) (map[string]interface{}, error)
	IsRunning() bool

	RPC(ctx context.Context, routeStr string, reply proto.Message, arg proto.Message) error
	RPCTo(ctx context.Context, serverID, routeStr string, reply proto.Message, arg proto.Message) error
	ReliableRPC(
		routeStr string,
		metadata map[string]interface{},
		reply, arg proto.Message,
	) (jid string, err error)
	ReliableRPCWithOptions(
		routeStr string,
		metadata map[string]interface{},
		reply, arg proto.Message,
		opts *config.EnqueueOpts,
	) (jid string, err error)

	SendPushToUsers(route string, v interface{}, uids []string, frontendType string) ([]string, error)
	SendKickToUsers(uids []string, frontendType string) ([]string, error)

	GroupCreate(ctx context.Context, groupName string) error
	GroupCreateWithTTL(ctx context.Context, groupName string, ttlTime time.Duration) error
	GroupMembers(ctx context.Context, groupName string) ([]string, error)
	GroupBroadcast(ctx context.Context, frontendType, groupName, route string, v interface{}) error
	GroupContainsMember(ctx context.Context, groupName, uid string) (bool, error)
	GroupAddMember(ctx context.Context, groupName, uid string) error
	GroupRemoveMember(ctx context.Context, groupName, uid string) error
	GroupRemoveAll(ctx context.Context, groupName string) error
	GroupCountMembers(ctx context.Context, groupName string) (int, error)
	GroupRenewTTL(ctx context.Context, groupName string) error
	GroupDelete(ctx context.Context, groupName string) error

	Register(c component.Component, options ...component.Option)
	RegisterRemote(c component.Component, options ...component.Option)

	RegisterModule(module interfaces.Module, name string) error
	RegisterModuleAfter(module interfaces.Module, name string) error
	RegisterModuleBefore(module interfaces.Module, name string) error
	GetModule(name string) (interfaces.Module, error)

	GetNumberOfConnectedClients() int64
	IsReady(ctx context.Context) bool
}

// App is the base app struct
type App struct {
	acceptors         []acceptor.Acceptor
	config            config.PitayaConfig
	debug             bool
	dieChan           chan bool
	heartbeat         time.Duration
	onSessionBind     func(session.Session)
	router            *router.Router
	rpcClient         cluster.RPCClient
	rpcServer         cluster.RPCServer
	metricsReporters  []metrics.Reporter
	running           bool
	serializer        serialize.Serializer
	server            *cluster.Server
	serverMode        ServerMode
	serviceDiscovery  cluster.ServiceDiscovery
	startAt           time.Time
	worker            *worker.Worker
	remoteService     *service.RemoteService
	handlerService    *service.HandlerService
	handlerComp       []regComp
	remoteComp        []regComp
	modulesMap        map[string]interfaces.Module
	modulesArr        []moduleWrapper
	sessionModulesArr []sessionModuleWrapper
	groups            groups.GroupService
	sessionPool       session.SessionPool
}

// NewApp is the base constructor for a pitaya app instance
func NewApp(
	serverMode ServerMode,
	serializer serialize.Serializer,
	acceptors []acceptor.Acceptor,
	dieChan chan bool,
	router *router.Router,
	server *cluster.Server,
	rpcClient cluster.RPCClient,
	rpcServer cluster.RPCServer,
	worker *worker.Worker,
	serviceDiscovery cluster.ServiceDiscovery,
	remoteService *service.RemoteService,
	handlerService *service.HandlerService,
	groups groups.GroupService,
	sessionPool session.SessionPool,
	metricsReporters []metrics.Reporter,
	config config.PitayaConfig,
) *App {
	app := &App{
		server:            server,
		config:            config,
		rpcClient:         rpcClient,
		rpcServer:         rpcServer,
		worker:            worker,
		serviceDiscovery:  serviceDiscovery,
		remoteService:     remoteService,
		handlerService:    handlerService,
		groups:            groups,
		debug:             false,
		startAt:           time.Now(),
		dieChan:           dieChan,
		acceptors:         acceptors,
		metricsReporters:  metricsReporters,
		serverMode:        serverMode,
		running:           false,
		serializer:        serializer,
		router:            router,
		handlerComp:       make([]regComp, 0),
		remoteComp:        make([]regComp, 0),
		modulesMap:        make(map[string]interfaces.Module),
		modulesArr:        []moduleWrapper{},
		sessionModulesArr: []sessionModuleWrapper{},
		sessionPool:       sessionPool,
	}
	if app.heartbeat == time.Duration(0) {
		app.heartbeat = config.Heartbeat.Interval
	}

	app.initSysRemotes()
	return app
}

// GetDieChan gets the channel that the app sinalizes when its going to die
func (app *App) GetDieChan() chan bool {
	return app.dieChan
}

// SetDebug toggles debug on/off
func (app *App) SetDebug(debug bool) {
	app.debug = debug
}

// SetHeartbeatTime sets the heartbeat time
func (app *App) SetHeartbeatTime(interval time.Duration) {
	app.heartbeat = interval
}

// GetServerID returns the generated server id
func (app *App) GetServerID() string {
	return app.server.ID
}

// GetMetricsReporters gets registered metrics reporters
func (app *App) GetMetricsReporters() []metrics.Reporter {
	return app.metricsReporters
}

// GetServer gets the local server instance
func (app *App) GetServer() *cluster.Server {
	return app.server
}

// GetServerByID returns the server with the specified id
func (app *App) GetServerByID(id string) (*cluster.Server, error) {
	return app.serviceDiscovery.GetServer(id)
}

// GetServersByType get all servers of type
func (app *App) GetServersByType(t string) (map[string]*cluster.Server, error) {
	return app.serviceDiscovery.GetServersByType(t)
}

// GetServers get all servers
func (app *App) GetServers() []*cluster.Server {
	return app.serviceDiscovery.GetServers()
}

// IsRunning indicates if the Pitaya app has been initialized. Note: This
// doesn't cover acceptors, only the pitaya internal registration and modules
// initialization.
func (app *App) IsRunning() bool {
	return app.running
}

// SetLogger logger setter
func SetLogger(l logging.Logger) {
	logger.Log = l
}

func (app *App) initSysRemotes() {
	sys := remote.NewSys(app.sessionPool)
	app.RegisterRemote(sys,
		component.WithName("sys"),
		component.WithNameFunc(strings.ToLower),
	)
}

func (app *App) periodicMetrics() {
	period := app.config.Metrics.Period
	go metrics.ReportSysMetrics(app.metricsReporters, period)

	if app.worker.Started() {
		go worker.Report(app.metricsReporters, period)
	}
}

// Start starts the app
func (app *App) Start() {
	if !app.server.Frontend && len(app.acceptors) > 0 {
		logger.Log.Fatal("acceptors are not allowed on backend servers")
	}

	if app.server.Frontend && len(app.acceptors) == 0 {
		logger.Log.Fatal("frontend servers should have at least one configured acceptor")
	}

	if app.serverMode == Cluster {
		if reflect.TypeOf(app.rpcClient) == reflect.TypeOf(&cluster.GRPCClient{}) {
			app.serviceDiscovery.AddListener(app.rpcClient.(*cluster.GRPCClient))
		}

		if err := app.RegisterModuleBefore(app.rpcServer, "rpcServer"); err != nil {
			logger.Log.Fatal("failed to register rpc server module: %s", err.Error())
		}
		if err := app.RegisterModuleBefore(app.rpcClient, "rpcClient"); err != nil {
			logger.Log.Fatal("failed to register rpc client module: %s", err.Error())
		}
		// set the service discovery as the last module to be started to ensure
		// all modules have been properly initialized before the server starts
		// receiving requests from other pitaya servers
		if err := app.RegisterModuleAfter(app.serviceDiscovery, "serviceDiscovery"); err != nil {
			logger.Log.Fatal("failed to register service discovery module: %s", err.Error())
		}
	}

	app.periodicMetrics()

	app.listen()

	defer func() {
		timer.GlobalTicker.Stop()
		app.running = false
	}()

	sg := make(chan os.Signal, 1)
	signal.Notify(sg, syscall.SIGINT, syscall.SIGQUIT, syscall.SIGTERM)

	maxSessionCount := func() int64 {
		count := app.sessionPool.GetSessionCount()
		mc := app.maxModuleSessionCount()
		if mc > count {
			count = mc
		}
		return count
	}

	// stop server
	select {
	case <-app.dieChan:
		logger.Log.Warn("the app will shutdown in a few seconds")
	case s := <-sg:
		logger.Log.Warn("got signal: ", s, ", shutting down...")
		if app.config.Session.Drain.Enabled && s == syscall.SIGTERM {
			logger.Log.Info("Session drain is enabled, draining all sessions before shutting down")
			timeoutTimer := time.NewTimer(app.config.Session.Drain.Timeout)
			app.startModuleSessionDraining()
		loop:
			for {
				if maxSessionCount() == 0 {
					logger.Log.Info("All sessions drained")
					break loop
				}
				select {
				case s := <-sg:
					logger.Log.Warn("got signal: ", s)
					if s == syscall.SIGINT {
						logger.Log.Warnf("Bypassing session draing due to SIGINT. %d sessions will be immediately terminated", maxSessionCount())
					}
					break loop
				case <-timeoutTimer.C:
					logger.Log.Warnf("Session drain has reached maximum timeout. %d sessions will be immediately terminated", maxSessionCount())
					break loop
				case <-time.After(app.config.Session.Drain.Period):
					logger.Log.Infof("Waiting for all sessions to finish: %d sessions remaining...", maxSessionCount())
				}
			}
		}
		close(app.dieChan)
	}

	logger.Log.Warn("server is stopping...")

	app.sessionPool.CloseAll()
	app.shutdownModules()
	app.shutdownComponents()
}

func (app *App) listen() {
	app.startupComponents()
	// create global ticker instance, timer precision could be customized
	// by SetTimerPrecision
	timer.GlobalTicker = time.NewTicker(timer.Precision)

	logger.Log.Infof("starting server %s:%s", app.server.Type, app.server.ID)
	for i := 0; i < app.config.Concurrency.Handler.Dispatch; i++ {
		go app.handlerService.Dispatch(i)
	}
	for _, acc := range app.acceptors {
		a := acc
		go func() {
			for conn := range a.GetConnChan() {
				go app.handlerService.Handle(conn)
			}
		}()
		if app.config.Acceptor.ProxyProtocol {
			logger.Log.Info("Enabling PROXY protocol for inbound connections")
			a.EnableProxyProtocol()
		} else {
			logger.Log.Debug("PROXY protocol is disabled for inbound connections")
		}
		go func() {
			a.ListenAndServe()
		}()
		logger.Log.Infof("Waiting for Acceptor %s to start on addr %s", reflect.TypeOf(a), a.GetConfiguredAddress())

		for !a.IsRunning() {
		}

		logger.Log.Infof("Acceptor %s on addr %s is now accepting connections", reflect.TypeOf(a), a.GetAddr())
	}

	if app.serverMode == Cluster && app.server.Frontend && app.config.Session.Unique {
		unique := mods.NewUniqueSession(app.server, app.rpcServer, app.rpcClient, app.sessionPool)
		app.remoteService.AddRemoteBindingListener(unique)
		app.RegisterModule(unique, "uniqueSession")
	}

	app.startModules()

	logger.Log.Info("all modules started!")

	app.running = true
}

// SetDictionary sets routes map
func (app *App) SetDictionary(dict map[string]uint16) error {
	if app.running {
		return constants.ErrChangeDictionaryWhileRunning
	}
	return message.SetDictionary(dict)
}

// AddRoute adds a routing function to a server type
func (app *App) AddRoute(
	serverType string,
	routingFunction router.RoutingFunc,
) error {
	if app.router != nil {
		if app.running {
			return constants.ErrChangeRouteWhileRunning
		}
		app.router.AddRoute(serverType, routingFunction)
	} else {
		return constants.ErrRouterNotInitialized
	}
	return nil
}

// Shutdown send a signal to let 'pitaya' shutdown itself.
func (app *App) Shutdown() {
	select {
	case <-app.dieChan: // prevent closing closed channel
	default:
		close(app.dieChan)
	}
}

// Error creates a new error with a code, message and metadata
func Error(err error, code string, metadata ...map[string]string) *errors.Error {
	return errors.NewError(err, code, metadata...)
}

// GetSessionFromCtx retrieves a session from a given context
func (app *App) GetSessionFromCtx(ctx context.Context) session.Session {
	sessionVal := ctx.Value(constants.SessionCtxKey)
	if sessionVal == nil {
		logger.Log.Debug("ctx doesn't contain a session, are you calling GetSessionFromCtx from inside a remote?")
		return nil
	}
	return sessionVal.(session.Session)
}

// GetDefaultLoggerFromCtx returns the default logger from the given context
func GetDefaultLoggerFromCtx(ctx context.Context) logging.Logger {
	l := ctx.Value(constants.LoggerCtxKey)
	if l == nil {
		return logger.Log
	}

	return l.(logging.Logger)
}

// AddMetricTagsToPropagateCtx adds a key and metric tags that will
// be propagated through RPC calls. Use the same tags that are at
// 'pitaya.metrics.additionalLabels' config
func AddMetricTagsToPropagateCtx(
	ctx context.Context,
	tags map[string]string,
) context.Context {
	return pcontext.AddToPropagateCtx(ctx, constants.MetricTagsKey, tags)
}

// AddToPropagateCtx adds a key and value that will be propagated through RPC calls
func AddToPropagateCtx(ctx context.Context, key string, val interface{}) context.Context {
	return pcontext.AddToPropagateCtx(ctx, key, val)
}

// GetFromPropagateCtx adds a key and value that came through RPC calls
func GetFromPropagateCtx(ctx context.Context, key string) interface{} {
	return pcontext.GetFromPropagateCtx(ctx, key)
}

// ExtractSpan retrieves an OpenTelemetry span context from the given context
// The span context can be received directly or via an RPC call
func ExtractSpan(ctx context.Context) (trace.SpanContext, error) {
	return tracing.ExtractSpan(ctx)
}

// Documentation returns handler and remotes documentacion
func (app *App) Documentation(getPtrNames bool) (map[string]interface{}, error) {
	handlerDocs, err := app.handlerService.Docs(getPtrNames)
	if err != nil {
		return nil, err
	}
	remoteDocs, err := app.remoteService.Docs(getPtrNames)
	if err != nil {
		return nil, err
	}
	return map[string]interface{}{
		"handlers": handlerDocs,
		"remotes":  remoteDocs,
	}, nil
}

// AddGRPCInfoToMetadata adds host, external host and
// port into metadata
func AddGRPCInfoToMetadata(
	metadata map[string]string,
	region string,
	host, port string,
	externalHost, externalPort string,
) map[string]string {
	metadata[constants.GRPCHostKey] = host
	metadata[constants.GRPCPortKey] = port
	metadata[constants.GRPCExternalHostKey] = externalHost
	metadata[constants.GRPCExternalPortKey] = externalPort
	metadata[constants.RegionKey] = region
	return metadata
}

// Descriptor returns the protobuf message descriptor for a given message name
func Descriptor(protoName string) ([]byte, error) {
	return docgenerator.ProtoDescriptors(protoName)
}

// StartWorker configures, starts and returns pitaya worker
func (app *App) StartWorker() {
	app.worker.Start()
}

// RegisterRPCJob registers rpc job to execute jobs with retries
func (app *App) RegisterRPCJob(rpcJob worker.RPCJob) error {
	err := app.worker.RegisterRPCJob(rpcJob)
	return err
}

// GetNumberOfConnectedClients returns the number of connected clients
func (app *App) GetNumberOfConnectedClients() int64 {
	return app.sessionPool.GetSessionCount()
}

// IsReady checks if pitaya is ready and able to serve requests
func (app *App) IsReady(ctx context.Context) bool {
	if !app.IsRunning() {
		return false
	}

	// Check NATS RPC Client connection
	if app.rpcClient != nil {
		if natsClient, ok := app.rpcClient.(*cluster.NatsRPCClient); ok {
			if !natsClient.IsConnected() {
				logger.Log.Info("pitaya is not ready")
				return false
			}
		}
	}

	// Check NATS RPC Server connection
	if app.rpcServer != nil {
		if natsServer, ok := app.rpcServer.(*cluster.NatsRPCServer); ok {
			if !natsServer.IsConnected() {
				logger.Log.Info("pitaya is not ready")
				return false
			}
		}
	}

	// Check ETCD connection
	if app.serviceDiscovery != nil {
		if !app.serviceDiscovery.IsConnected(ctx) {
			logger.Log.Info("pitaya is not ready")
			return false
		}
	}

	logger.Log.Info("pitaya is ready")
	return true
}

```

`pkg/app_test.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package pitaya

import (
	"context"
	"errors"
	"fmt"
	"net"
	"os"
	"reflect"
	"testing"
	"time"

	"github.com/golang/mock/gomock"
	"github.com/google/uuid"
	"github.com/spf13/viper"
	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/acceptor"
	"github.com/topfreegames/pitaya/v3/pkg/cluster"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	e "github.com/topfreegames/pitaya/v3/pkg/errors"
	"github.com/topfreegames/pitaya/v3/pkg/helpers"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/logger/logrus"
	"github.com/topfreegames/pitaya/v3/pkg/route"
	"github.com/topfreegames/pitaya/v3/pkg/router"
	"github.com/topfreegames/pitaya/v3/pkg/session/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/timer"
	"github.com/topfreegames/pitaya/v3/pkg/tracing"
)

var (
	tables = []struct {
		isFrontend     bool
		serverType     string
		serverMode     ServerMode
		serverMetadata map[string]string
		cfg            *viper.Viper
	}{
		{true, "sv1", Cluster, map[string]string{"name": "bla"}, viper.New()},
		{false, "sv2", Standalone, map[string]string{}, viper.New()},
	}
)

func TestMain(m *testing.M) {
	exit := m.Run()
	os.Exit(exit)
}

func TestNewApp(t *testing.T) {
	for _, table := range tables {
		t.Run(table.serverType, func(t *testing.T) {
			builderConfig := config.NewDefaultPitayaConfig()
			app := NewDefaultApp(table.isFrontend, table.serverType, table.serverMode, table.serverMetadata, *builderConfig).(*App)
			assert.Equal(t, table.isFrontend, app.server.Frontend)
			assert.Equal(t, table.serverType, app.server.Type)
			assert.Equal(t, table.serverMode, app.serverMode)
			assert.Equal(t, table.serverMetadata, app.server.Metadata)
		})
	}
}

func TestAddAcceptor(t *testing.T) {
	acc := acceptor.NewTCPAcceptor("0.0.0.0:0")
	for _, table := range tables {
		t.Run(table.serverType, func(t *testing.T) {
			builderConfig := config.NewDefaultPitayaConfig()
			builder := NewDefaultBuilder(table.isFrontend, table.serverType, table.serverMode, table.serverMetadata, *builderConfig)
			builder.AddAcceptor(acc)
			app := builder.Build().(*App)
			if table.isFrontend {
				assert.Equal(t, acc, app.acceptors[0])
			} else {
				assert.Equal(t, 0, len(app.acceptors))
			}
		})
	}
}

func TestSetDebug(t *testing.T) {
	builderConfig := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *builderConfig).(*App)
	app.SetDebug(true)
	assert.Equal(t, true, app.debug)
	app.SetDebug(false)
	assert.Equal(t, false, app.debug)
}

func TestSetLogger(t *testing.T) {
	l := logrus.New()
	SetLogger(l)
	assert.Equal(t, l, logger.Log)
}

func TestGetDieChan(t *testing.T) {
	builderConfig := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *builderConfig).(*App)
	assert.Equal(t, app.dieChan, app.GetDieChan())
}

func TestGetSever(t *testing.T) {
	builderConfig := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *builderConfig).(*App)
	assert.Equal(t, app.server, app.GetServer())
}

func TestGetMetricsReporters(t *testing.T) {
	builderConfig := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *builderConfig).(*App)
	assert.Equal(t, app.metricsReporters, app.GetMetricsReporters())
}
func TestGetServerByID(t *testing.T) {
	builderConfig := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *builderConfig)
	s, err := app.GetServerByID("id")
	assert.Nil(t, s)
	assert.EqualError(t, constants.ErrNoServerWithID, err.Error())
}

func TestGetServersByType(t *testing.T) {
	builderConfig := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *builderConfig)
	s, err := app.GetServersByType("id")
	assert.Nil(t, s)
	assert.EqualError(t, constants.ErrNoServersAvailableOfType, err.Error())
}

func TestSetHeartbeatInterval(t *testing.T) {
	inter := 35 * time.Millisecond
	builderConfig := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *builderConfig).(*App)
	app.SetHeartbeatTime(inter)
	assert.Equal(t, inter, app.heartbeat)
}

func TestInitSysRemotes(t *testing.T) {
	builderConfig := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *builderConfig).(*App)
	app.initSysRemotes()
	assert.NotNil(t, app.remoteComp[0])
}

func TestSetDictionary(t *testing.T) {
	builderConfig := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *builderConfig).(*App)

	dict := map[string]uint16{"someroute": 12}
	err := app.SetDictionary(dict)
	assert.NoError(t, err)
	assert.Equal(t, dict, message.GetDictionary())

	app.running = true
	err = app.SetDictionary(dict)
	assert.EqualError(t, constants.ErrChangeDictionaryWhileRunning, err.Error())
}

func TestAddRoute(t *testing.T) {
	builderConfig := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *builderConfig).(*App)
	app.router = nil
	err := app.AddRoute("somesv", func(ctx context.Context, route *route.Route, payload []byte, servers map[string]*cluster.Server) (*cluster.Server, error) {
		return nil, nil
	})
	assert.EqualError(t, constants.ErrRouterNotInitialized, err.Error())

	app.router = router.New()
	err = app.AddRoute("somesv", func(ctx context.Context, route *route.Route, payload []byte, servers map[string]*cluster.Server) (*cluster.Server, error) {
		return nil, nil
	})
	assert.NoError(t, err)

	app.running = true
	err = app.AddRoute("somesv", func(ctx context.Context, route *route.Route, payload []byte, servers map[string]*cluster.Server) (*cluster.Server, error) {
		return nil, nil
	})
	assert.EqualError(t, constants.ErrChangeRouteWhileRunning, err.Error())
}

func TestShutdown(t *testing.T) {
	builderConfig := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *builderConfig).(*App)
	go func() {
		app.Shutdown()
	}()
	<-app.dieChan
}

func TestConfigureDefaultMetricsReporter(t *testing.T) {
	tables := []struct {
		enabled bool
	}{
		{true},
		{false},
	}

	for _, table := range tables {
		t.Run(fmt.Sprintf("%t", table.enabled), func(t *testing.T) {
			builderConfig := config.NewDefaultPitayaConfig()
			builderConfig.Metrics.Prometheus.Enabled = table.enabled
			builderConfig.Metrics.Statsd.Enabled = table.enabled
			app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *builderConfig).(*App)
			// if statsd is enabled there are 2 metricsReporters, prometheus and statsd
			assert.Equal(t, table.enabled, len(app.metricsReporters) == 2)
		})
	}
}

func TestDefaultSD(t *testing.T) {
	builderConfig := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *builderConfig).(*App)
	assert.NotNil(t, app.serviceDiscovery)

	etcdSD, err := cluster.NewEtcdServiceDiscovery(config.NewDefaultPitayaConfig().Cluster.SD.Etcd, app.server, app.dieChan)
	assert.NoError(t, err)
	typeOfetcdSD := reflect.TypeOf(etcdSD)

	assert.Equal(t, typeOfetcdSD, reflect.TypeOf(app.serviceDiscovery))
}

func TestDefaultRPCServer(t *testing.T) {
	ctrl := gomock.NewController(t)

	builderConfig := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *builderConfig).(*App)
	assert.NotNil(t, app.rpcServer)

	sessionPool := mocks.NewMockSessionPool(ctrl)

	natsRPCServer, err := cluster.NewNatsRPCServer(config.NewDefaultPitayaConfig().Cluster.RPC.Server.Nats, app.server, nil, app.dieChan, sessionPool)
	assert.NoError(t, err)
	typeOfNatsRPCServer := reflect.TypeOf(natsRPCServer)

	assert.Equal(t, typeOfNatsRPCServer, reflect.TypeOf(app.rpcServer))
}

func TestDefaultRPCClient(t *testing.T) {
	builderConfig := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *builderConfig).(*App)
	assert.NotNil(t, app.rpcClient)

	natsRPCClient, err := cluster.NewNatsRPCClient(config.NewDefaultPitayaConfig().Cluster.RPC.Client.Nats, app.server, nil, app.dieChan)
	assert.NoError(t, err)
	typeOfNatsRPCClient := reflect.TypeOf(natsRPCClient)

	assert.Equal(t, typeOfNatsRPCClient, reflect.TypeOf(app.rpcClient))
}

func TestStartAndListenStandalone(t *testing.T) {
	builderConfig := config.NewDefaultPitayaConfig()

	acc := acceptor.NewTCPAcceptor("0.0.0.0:0")
	builder := NewDefaultBuilder(true, "testtype", Standalone, map[string]string{}, *builderConfig)
	builder.AddAcceptor(acc)
	app := builder.Build().(*App)

	go func() {
		app.Start()
	}()
	helpers.ShouldEventuallyReturn(t, func() bool {
		return app.running
	}, true)

	assert.NotNil(t, app.handlerService)
	assert.NotNil(t, timer.GlobalTicker)
	// should be listening
	assert.NotEmpty(t, acc.GetAddr())
	helpers.ShouldEventuallyReturn(t, func() error {
		n, err := net.Dial("tcp", acc.GetAddr())
		defer n.Close()
		return err
	}, nil, 10*time.Millisecond, 100*time.Millisecond)
}

func TestStartAndListenCluster(t *testing.T) {
	es, cli := helpers.GetTestEtcd(t)
	defer es.Terminate(t)

	ns := helpers.GetTestNatsServer(t)
	nsAddr := ns.Addr().String()

	builder := NewDefaultBuilder(true, "testtype", Cluster, map[string]string{}, *config.NewDefaultPitayaConfig())

	var err error
	natsClientConfig := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Nats
	natsClientConfig.Connect = fmt.Sprintf("nats://%s", nsAddr)
	builder.RPCClient, err = cluster.NewNatsRPCClient(natsClientConfig, builder.Server, builder.MetricsReporters, builder.DieChan)
	if err != nil {
		panic(err.Error())
	}

	natsServerConfig := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Nats
	natsServerConfig.Connect = fmt.Sprintf("nats://%s", nsAddr)
	builder.RPCServer, err = cluster.NewNatsRPCServer(natsServerConfig, builder.Server, builder.MetricsReporters, builder.DieChan, builder.SessionPool)
	if err != nil {
		panic(err.Error())
	}

	etcdSD, err := cluster.NewEtcdServiceDiscovery(config.NewDefaultPitayaConfig().Cluster.SD.Etcd, builder.Server, builder.DieChan, cli)
	builder.ServiceDiscovery = etcdSD
	assert.NoError(t, err)
	acc := acceptor.NewTCPAcceptor("0.0.0.0:0")
	builder.AddAcceptor(acc)
	app := builder.Build().(*App)

	go func() {
		app.Start()
	}()
	helpers.ShouldEventuallyReturn(t, func() bool {
		return app.running
	}, true)

	assert.NotNil(t, app.handlerService)
	assert.NotNil(t, timer.GlobalTicker)
	// should be listening
	assert.NotEmpty(t, acc.GetAddr())
	helpers.ShouldEventuallyReturn(t, func() error {
		n, err := net.Dial("tcp", acc.GetAddr())
		defer n.Close()
		return err
	}, nil, 10*time.Millisecond, 100*time.Millisecond)
}

func TestError(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name     string
		err      error
		code     string
		metadata map[string]string
	}{
		{"nil_metadata", errors.New(uuid.New().String()), uuid.New().String(), nil},
		{"empty_metadata", errors.New(uuid.New().String()), uuid.New().String(), map[string]string{}},
		{"non_empty_metadata", errors.New(uuid.New().String()), uuid.New().String(), map[string]string{"key": uuid.New().String()}},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			var err *e.Error
			if table.metadata != nil {
				err = Error(table.err, table.code, table.metadata)
			} else {
				err = Error(table.err, table.code)
			}
			assert.NotNil(t, err)
			assert.Equal(t, table.code, err.Code)
			assert.Equal(t, table.err.Error(), err.Message)
			assert.Equal(t, table.metadata, err.Metadata)
		})
	}
}

func TestGetSessionFromCtx(t *testing.T) {
	ctrl := gomock.NewController(t)
	ss := mocks.NewMockSession(ctrl)

	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *config.NewDefaultPitayaConfig())
	ctx := context.WithValue(context.Background(), constants.SessionCtxKey, ss)
	s := app.GetSessionFromCtx(ctx)
	assert.Equal(t, ss, s)
}

func TestAddMetricTagsToPropagateCtx(t *testing.T) {
	ctx := AddMetricTagsToPropagateCtx(context.Background(), map[string]string{
		"key": "value",
	})
	val := ctx.Value(constants.PropagateCtxKey)
	assert.Equal(t, map[string]interface{}{
		constants.MetricTagsKey: map[string]string{
			"key": "value",
		},
	}, val)
}

func TestAddToPropagateCtx(t *testing.T) {
	ctx := AddToPropagateCtx(context.Background(), "key", "val")
	val := ctx.Value(constants.PropagateCtxKey)
	assert.Equal(t, map[string]interface{}{"key": "val"}, val)
}

func TestGetFromPropagateCtx(t *testing.T) {
	ctx := AddToPropagateCtx(context.Background(), "key", "val")
	val := GetFromPropagateCtx(ctx, "key")
	assert.Equal(t, "val", val)
}

func TestExtractSpan(t *testing.T) {
	ctx, span := tracing.StartSpan(context.TODO(), "op")
	spanCtx, err := ExtractSpan(ctx)
	assert.NoError(t, err)
	assert.Equal(t, span.SpanContext(), spanCtx)
}

func TestDescriptor(t *testing.T) {
	bts, err := Descriptor("kick.proto")
	assert.NoError(t, err)
	assert.NotNil(t, bts)

	bts, err = Descriptor("not_exists.proto")
	assert.Nil(t, bts)
	assert.EqualError(t, constants.ErrProtodescriptor, err.Error())
}

func TestDocumentation(t *testing.T) {
	builderConfig := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *builderConfig).(*App)
	app.startupComponents()
	doc, err := app.Documentation(false)
	assert.NoError(t, err)
	assert.Equal(t, map[string]interface{}{
		"handlers": map[string]interface{}{},
		"remotes": map[string]interface{}{
			"testtype.sys.bindsession": map[string]interface{}{
				"input": map[string]interface{}{
					"uid":  "string",
					"data": "[]byte",
					"id":   "int64",
				},
				"output": []interface{}{
					map[string]interface{}{
						"error": map[string]interface{}{
							"msg":      "string",
							"code":     "string",
							"metadata": "map[string]string",
						},
						"data": "[]byte",
					},
					"error",
				},
			},
			"testtype.sys.kick": map[string]interface{}{
				"input": map[string]interface{}{
					"userId": "string",
				},
				"output": []interface{}{
					map[string]interface{}{
						"kicked": "bool",
					},
					"error",
				},
			},
			"testtype.sys.pushsession": map[string]interface{}{
				"input": map[string]interface{}{
					"data": "[]byte",
					"id":   "int64",
					"uid":  "string",
				},
				"output": []interface{}{
					map[string]interface{}{
						"error": map[string]interface{}{
							"code":     "string",
							"metadata": "map[string]string",
							"msg":      "string",
						},
						"data": "[]byte",
					},
					"error",
				},
			},
		},
	}, doc)
}

func TestDocumentationTrue(t *testing.T) {
	builderConfig := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *builderConfig).(*App)
	app.startupComponents()
	doc, err := app.Documentation(true)
	assert.NoError(t, err)
	assert.Equal(t, map[string]interface{}{
		"remotes": map[string]interface{}{
			"testtype.sys.bindsession": map[string]interface{}{
				"input": map[string]interface{}{
					"*protos.Session": map[string]interface{}{
						"data": "[]byte",
						"id":   "int64",
						"uid":  "string",
					},
				},
				"output": []interface{}{map[string]interface{}{
					"*protos.Response": map[string]interface{}{
						"data": "[]byte",
						"error": map[string]interface{}{
							"*protos.Error": map[string]interface{}{
								"code":     "string",
								"metadata": "map[string]string",
								"msg":      "string",
							},
						},
					},
				},
					"error",
				},
			},
			"testtype.sys.kick": map[string]interface{}{
				"input": map[string]interface{}{
					"*protos.KickMsg": map[string]interface{}{
						"userId": "string",
					},
				},
				"output": []interface{}{map[string]interface{}{
					"*protos.KickAnswer": map[string]interface{}{
						"kicked": "bool",
					},
				},
					"error",
				},
			},
			"testtype.sys.pushsession": map[string]interface{}{
				"input": map[string]interface{}{
					"*protos.Session": map[string]interface{}{
						"data": "[]byte",
						"id":   "int64",
						"uid":  "string",
					},
				},
				"output": []interface{}{map[string]interface{}{
					"*protos.Response": map[string]interface{}{
						"data": "[]byte",
						"error": map[string]interface{}{
							"*protos.Error": map[string]interface{}{
								"code":     "string",
								"metadata": "map[string]string",
								"msg":      "string",
							},
						},
					},
				},
					"error",
				},
			},
		},
		"handlers": map[string]interface{}{},
	}, doc)
}

func TestAddGRPCInfoToMetadata(t *testing.T) {
	t.Parallel()

	metadata := map[string]string{
		"key1": "value1",
		"key2": "value2",
		"key3": "value3",
	}

	metadata = AddGRPCInfoToMetadata(metadata, "region", "host", "port", "external-host", "external-port")

	assert.Equal(t, map[string]string{
		"key1":                        "value1",
		"key2":                        "value2",
		"key3":                        "value3",
		constants.GRPCHostKey:         "host",
		constants.GRPCPortKey:         "port",
		constants.GRPCExternalHostKey: "external-host",
		constants.GRPCExternalPortKey: "external-port",
		constants.RegionKey:           "region",
	}, metadata)
}

func TestStartWorker(t *testing.T) {
	builderConfig := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *builderConfig).(*App)

	app.StartWorker()
	assert.True(t, app.worker.Started())
}

func TestRegisterRPCJob(t *testing.T) {
	t.Run("register_once", func(t *testing.T) {
		builderConfig := config.NewDefaultPitayaConfig()
		app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *builderConfig)
		app.StartWorker()

		err := app.RegisterRPCJob(nil)
		assert.NoError(t, err)
	})

	t.Run("register_twice", func(t *testing.T) {
		builderConfig := config.NewDefaultPitayaConfig()
		app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *builderConfig)
		app.StartWorker()

		err := app.RegisterRPCJob(nil)
		assert.NoError(t, err)

		err = app.RegisterRPCJob(nil)
		assert.Equal(t, constants.ErrRPCJobAlreadyRegistered, err)
	})
}

```

`pkg/builder.go`:

```go
package pitaya

import (
	"github.com/google/uuid"
	"github.com/topfreegames/pitaya/v3/pkg/acceptor"
	"github.com/topfreegames/pitaya/v3/pkg/agent"
	"github.com/topfreegames/pitaya/v3/pkg/cluster"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/conn/codec"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/defaultpipelines"
	"github.com/topfreegames/pitaya/v3/pkg/groups"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
	"github.com/topfreegames/pitaya/v3/pkg/metrics/models"
	"github.com/topfreegames/pitaya/v3/pkg/pipeline"
	"github.com/topfreegames/pitaya/v3/pkg/router"
	"github.com/topfreegames/pitaya/v3/pkg/serialize"
	"github.com/topfreegames/pitaya/v3/pkg/service"
	"github.com/topfreegames/pitaya/v3/pkg/session"
	"github.com/topfreegames/pitaya/v3/pkg/worker"
)

// Builder holds dependency instances for a pitaya App
type Builder struct {
	acceptors        []acceptor.Acceptor
	postBuildHooks   []func(app Pitaya)
	Config           config.PitayaConfig
	DieChan          chan bool
	PacketDecoder    codec.PacketDecoder
	PacketEncoder    codec.PacketEncoder
	MessageEncoder   *message.MessagesEncoder
	Serializer       serialize.Serializer
	Router           *router.Router
	RPCClient        cluster.RPCClient
	RPCServer        cluster.RPCServer
	MetricsReporters []metrics.Reporter
	Server           *cluster.Server
	ServerMode       ServerMode
	ServiceDiscovery cluster.ServiceDiscovery
	Groups           groups.GroupService
	SessionPool      session.SessionPool
	Worker           *worker.Worker
	RemoteHooks      *pipeline.RemoteHooks
	HandlerHooks     *pipeline.HandlerHooks
}

// PitayaBuilder Builder interface
type PitayaBuilder interface {
	// AddPostBuildHook adds a post-build hook to the builder, a function receiving a Pitaya instance as parameter.
	AddPostBuildHook(hook func(app Pitaya))
	Build() Pitaya
}

// NewBuilderWithConfigs return a builder instance with default dependency instances for a pitaya App
// with configs defined by a config file (config.Config) and default paths (see documentation).
func NewBuilderWithConfigs(
	isFrontend bool,
	serverType string,
	serverMode ServerMode,
	serverMetadata map[string]string,
	conf *config.Config,
) *Builder {
	pitayaConfig := config.NewPitayaConfig(conf)
	return NewBuilder(
		isFrontend,
		serverType,
		serverMode,
		serverMetadata,
		*pitayaConfig,
	)
}

// NewDefaultBuilder return a builder instance with default dependency instances for a pitaya App,
// with default configs
func NewDefaultBuilder(isFrontend bool, serverType string, serverMode ServerMode, serverMetadata map[string]string, pitayaConfig config.PitayaConfig) *Builder {
	return NewBuilder(
		isFrontend,
		serverType,
		serverMode,
		serverMetadata,
		pitayaConfig,
	)
}

// NewBuilder return a builder instance with default dependency instances for a pitaya App,
// with configs explicitly defined
func NewBuilder(isFrontend bool,
	serverType string,
	serverMode ServerMode,
	serverMetadata map[string]string,
	config config.PitayaConfig,
) *Builder {
	server := cluster.NewServer(uuid.New().String(), serverType, isFrontend, serverMetadata)
	dieChan := make(chan bool)

	metricsReporters := []metrics.Reporter{}
	if config.Metrics.Prometheus.Enabled {
		metricsReporters = addDefaultPrometheus(config.Metrics, config.Metrics.Custom, metricsReporters, serverType)
	}

	if config.Metrics.Statsd.Enabled {
		metricsReporters = addDefaultStatsd(config.Metrics, metricsReporters, serverType)
	}

	handlerHooks := pipeline.NewHandlerHooks()
	if config.DefaultPipelines.StructValidation.Enabled {
		configureDefaultPipelines(handlerHooks)
	}

	sessionPool := session.NewSessionPool()

	var serviceDiscovery cluster.ServiceDiscovery
	var rpcServer cluster.RPCServer
	var rpcClient cluster.RPCClient
	if serverMode == Cluster {
		var err error
		serviceDiscovery, err = cluster.NewEtcdServiceDiscovery(config.Cluster.SD.Etcd, server, dieChan)
		if err != nil {
			logger.Log.Fatalf("error creating default cluster service discovery component: %s", err.Error())
		}

		rpcServer, err = cluster.NewNatsRPCServer(config.Cluster.RPC.Server.Nats, server, metricsReporters, dieChan, sessionPool)
		if err != nil {
			logger.Log.Fatalf("error setting default cluster rpc server component: %s", err.Error())
		}

		rpcClient, err = cluster.NewNatsRPCClient(config.Cluster.RPC.Client.Nats, server, metricsReporters, dieChan)
		if err != nil {
			logger.Log.Fatalf("error setting default cluster rpc client component: %s", err.Error())
		}
	}

	worker, err := worker.NewWorker(config.Worker, config.Worker.Retry)
	if err != nil {
		logger.Log.Fatalf("error creating default worker: %s", err.Error())
	}

	gsi := groups.NewMemoryGroupService(config.Groups.Memory)
	if err != nil {
		panic(err)
	}

	serializer, err := serialize.NewSerializer(serialize.Type(config.SerializerType))
	if err != nil {
		logger.Log.Fatalf("error creating serializer: %s", err.Error())
	}

	return &Builder{
		acceptors:        []acceptor.Acceptor{},
		postBuildHooks:   make([]func(app Pitaya), 0),
		Config:           config,
		DieChan:          dieChan,
		PacketDecoder:    codec.NewPomeloPacketDecoder(),
		PacketEncoder:    codec.NewPomeloPacketEncoder(),
		MessageEncoder:   message.NewMessagesEncoder(config.Handler.Messages.Compression),
		Serializer:       serializer,
		Router:           router.New(),
		RPCClient:        rpcClient,
		RPCServer:        rpcServer,
		MetricsReporters: metricsReporters,
		Server:           server,
		ServerMode:       serverMode,
		Groups:           gsi,
		RemoteHooks:      pipeline.NewRemoteHooks(),
		HandlerHooks:     handlerHooks,
		ServiceDiscovery: serviceDiscovery,
		SessionPool:      sessionPool,
		Worker:           worker,
	}
}

// AddAcceptor adds a new acceptor to app
func (builder *Builder) AddAcceptor(ac acceptor.Acceptor) {
	if !builder.Server.Frontend {
		logger.Log.Error("tried to add an acceptor to a backend server, skipping")
		return
	}
	builder.acceptors = append(builder.acceptors, ac)
}

// AddPostBuildHook adds a post-build hook to the builder, a function receiving a Pitaya instance as parameter.
func (builder *Builder) AddPostBuildHook(hook func(app Pitaya)) {
	builder.postBuildHooks = append(builder.postBuildHooks, hook)
}

// Build returns a valid App instance
func (builder *Builder) Build() Pitaya {
	handlerPool := service.NewHandlerPool()
	var remoteService *service.RemoteService
	if builder.ServerMode == Standalone {
		if builder.ServiceDiscovery != nil || builder.RPCClient != nil || builder.RPCServer != nil {
			panic("Standalone mode can't have RPC or service discovery instances")
		}
	} else {
		if !(builder.ServiceDiscovery != nil && builder.RPCClient != nil && builder.RPCServer != nil) {
			panic("Cluster mode must have RPC and service discovery instances")
		}

		builder.Router.SetServiceDiscovery(builder.ServiceDiscovery)

		remoteService = service.NewRemoteService(
			builder.RPCClient,
			builder.RPCServer,
			builder.ServiceDiscovery,
			builder.PacketEncoder,
			builder.Serializer,
			builder.Router,
			builder.MessageEncoder,
			builder.Server,
			builder.SessionPool,
			builder.RemoteHooks,
			builder.HandlerHooks,
			handlerPool,
		)

		builder.RPCServer.SetPitayaServer(remoteService)
	}

	agentFactory := agent.NewAgentFactory(builder.DieChan,
		builder.PacketDecoder,
		builder.PacketEncoder,
		builder.Serializer,
		builder.Config.Heartbeat.Interval,
		builder.Config.Buffer.Agent.WriteTimeout,
		builder.MessageEncoder,
		builder.Config.Buffer.Agent.Messages,
		builder.SessionPool,
		builder.MetricsReporters,
	)

	handlerService := service.NewHandlerService(
		builder.PacketDecoder,
		builder.Serializer,
		builder.Config.Buffer.Handler.LocalProcess,
		builder.Config.Buffer.Handler.RemoteProcess,
		builder.Server,
		remoteService,
		agentFactory,
		builder.MetricsReporters,
		builder.HandlerHooks,
		handlerPool,
	)

	app := NewApp(
		builder.ServerMode,
		builder.Serializer,
		builder.acceptors,
		builder.DieChan,
		builder.Router,
		builder.Server,
		builder.RPCClient,
		builder.RPCServer,
		builder.Worker,
		builder.ServiceDiscovery,
		remoteService,
		handlerService,
		builder.Groups,
		builder.SessionPool,
		builder.MetricsReporters,
		builder.Config,
	)

	for _, postBuildHook := range builder.postBuildHooks {
		postBuildHook(app)
	}

	return app
}

// NewDefaultApp returns a default pitaya app instance
func NewDefaultApp(isFrontend bool, serverType string, serverMode ServerMode, serverMetadata map[string]string, config config.PitayaConfig) Pitaya {
	builder := NewDefaultBuilder(isFrontend, serverType, serverMode, serverMetadata, config)
	return builder.Build()
}

func configureDefaultPipelines(handlerHooks *pipeline.HandlerHooks) {
	handlerHooks.BeforeHandler.PushBack(defaultpipelines.StructValidatorInstance.Validate)
}

func addDefaultPrometheus(config config.MetricsConfig, customMetrics models.CustomMetricsSpec, reporters []metrics.Reporter, serverType string) []metrics.Reporter {
	prometheus, err := CreatePrometheusReporter(serverType, config, customMetrics)
	if err != nil {
		logger.Log.Errorf("failed to start prometheus metrics reporter, skipping %v", err)
	} else {
		reporters = append(reporters, prometheus)
	}
	return reporters
}

func addDefaultStatsd(config config.MetricsConfig, reporters []metrics.Reporter, serverType string) []metrics.Reporter {
	statsd, err := CreateStatsdReporter(serverType, config)
	if err != nil {
		logger.Log.Errorf("failed to start statsd metrics reporter, skipping %v", err)
	} else {
		reporters = append(reporters, statsd)
	}
	return reporters
}

```

`pkg/builder_test.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package pitaya

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/acceptor"
	"github.com/topfreegames/pitaya/v3/pkg/config"
)

func TestPostBuildHooks(t *testing.T) {
	acc := acceptor.NewTCPAcceptor("0.0.0.0:0")
	for _, table := range tables {
		builderConfig := config.NewDefaultPitayaConfig()

		t.Run("with_post_build_hooks", func(t *testing.T) {
			called := false
			builder := NewDefaultBuilder(table.isFrontend, table.serverType, table.serverMode, table.serverMetadata, *builderConfig)
			builder.AddAcceptor(acc)
			builder.AddPostBuildHook(func(app Pitaya) {
				called = true
			})
			app := builder.Build()

			assert.True(t, called)
			assert.NotNil(t, app)
		})

		t.Run("without_post_build_hooks", func(t *testing.T) {
			called := false
			builder := NewDefaultBuilder(table.isFrontend, table.serverType, table.serverMode, table.serverMetadata, *builderConfig)
			builder.AddAcceptor(acc)
			app := builder.Build()

			assert.False(t, called)
			assert.NotNil(t, app)
		})
	}
}

```

`pkg/client/client.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package client

import (
	"bytes"
	"crypto/tls"
	"encoding/json"
	"errors"
	"fmt"
	"net"
	"net/url"
	"sync"
	"sync/atomic"
	"time"

	"github.com/topfreegames/pitaya/v3/pkg/acceptor"

	"github.com/gorilla/websocket"
	"github.com/sirupsen/logrus"
	"github.com/topfreegames/pitaya/v3/pkg"
	"github.com/topfreegames/pitaya/v3/pkg/conn/codec"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/conn/packet"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	logruswrapper "github.com/topfreegames/pitaya/v3/pkg/logger/logrus"
	"github.com/topfreegames/pitaya/v3/pkg/session"
	"github.com/topfreegames/pitaya/v3/pkg/util/compression"
)

// HandshakeSys struct
type HandshakeSys struct {
	Dict       map[string]uint16 `json:"dict"`
	Heartbeat  int               `json:"heartbeat"`
	Serializer string            `json:"serializer"`
}

// HandshakeData struct
type HandshakeData struct {
	Code int          `json:"code"`
	Sys  HandshakeSys `json:"sys"`
}

type pendingRequest struct {
	msg    *message.Message
	sentAt time.Time
}

// Client struct
type Client struct {
	conn                net.Conn
	Connected           bool
	packetEncoder       codec.PacketEncoder
	packetDecoder       codec.PacketDecoder
	packetChan          chan *packet.Packet
	IncomingMsgChan     chan *message.Message
	pendingChan         chan bool
	pendingRequests     map[uint]*pendingRequest
	pendingReqMutex     sync.Mutex
	requestTimeout      time.Duration
	closeChan           chan struct{}
	nextID              uint32
	messageEncoder      message.Encoder
	clientHandshakeData *session.HandshakeData
}

// MsgChannel return the incoming message channel
func (c *Client) MsgChannel() chan *message.Message {
	return c.IncomingMsgChan
}

// ConnectedStatus return the connection status
func (c *Client) ConnectedStatus() bool {
	return c.Connected
}

// New returns a new client
func New(logLevel logrus.Level, requestTimeout ...time.Duration) *Client {
	l := logrus.New()
	l.Formatter = &logrus.TextFormatter{}
	l.SetLevel(logLevel)

	logger.Log = logruswrapper.NewWithFieldLogger(l)

	reqTimeout := 5 * time.Second
	if len(requestTimeout) > 0 {
		reqTimeout = requestTimeout[0]
	}

	return &Client{
		Connected:       false,
		packetEncoder:   codec.NewPomeloPacketEncoder(),
		packetDecoder:   codec.NewPomeloPacketDecoder(),
		packetChan:      make(chan *packet.Packet, 10),
		pendingRequests: make(map[uint]*pendingRequest),
		requestTimeout:  reqTimeout,
		// 30 here is the limit of inflight messages
		// TODO this should probably be configurable
		pendingChan:    make(chan bool, 30),
		messageEncoder: message.NewMessagesEncoder(false),
		clientHandshakeData: &session.HandshakeData{
			Sys: session.HandshakeClientData{
				Platform:    "mac",
				LibVersion:  "0.3.5-release",
				BuildNumber: "20",
				Version:     "2.1",
			},
			User: map[string]interface{}{
				"age": 30,
			},
		},
	}
}

// SetClientHandshakeData sets the data to send inside handshake
func (c *Client) SetClientHandshakeData(data *session.HandshakeData) {
	c.clientHandshakeData = data
}

func (c *Client) sendHandshakeRequest() error {
	enc, err := json.Marshal(c.clientHandshakeData)
	if err != nil {
		return err
	}

	p, err := c.packetEncoder.Encode(packet.Handshake, enc)
	if err != nil {
		return err
	}

	_, err = c.conn.Write(p)
	return err
}

func (c *Client) handleHandshakeResponse() error {
	buf := bytes.NewBuffer(nil)
	packets, err := c.readPackets(buf)
	if err != nil {
		return err
	}

	handshakePacket := packets[0]
	if handshakePacket.Type != packet.Handshake {
		return fmt.Errorf("got first packet from server that is not a handshake, aborting")
	}

	handshake := &HandshakeData{}
	if compression.IsCompressed(handshakePacket.Data) {
		handshakePacket.Data, err = compression.InflateData(handshakePacket.Data)
		if err != nil {
			return err
		}
	}

	err = json.Unmarshal(handshakePacket.Data, handshake)
	if err != nil {
		return err
	}

	logger.Log.Debug("got handshake from sv, data: %v", handshake)

	if handshake.Sys.Dict != nil {
		message.SetDictionary(handshake.Sys.Dict)
	}
	p, err := c.packetEncoder.Encode(packet.HandshakeAck, []byte{})
	if err != nil {
		return err
	}
	_, err = c.conn.Write(p)
	if err != nil {
		return err
	}

	c.Connected = true

	go c.sendHeartbeats(handshake.Sys.Heartbeat)
	go c.handleServerMessages()
	go c.handlePackets()
	go c.pendingRequestsReaper()

	return nil
}

// pendingRequestsReaper delete timedout requests
func (c *Client) pendingRequestsReaper() {
	ticker := time.NewTicker(1 * time.Second)
	defer ticker.Stop()
	for {
		select {
		case <-ticker.C:
			toDelete := make([]*pendingRequest, 0)
			c.pendingReqMutex.Lock()
			for _, v := range c.pendingRequests {
				if time.Now().Sub(v.sentAt) > c.requestTimeout {
					toDelete = append(toDelete, v)
				}
			}
			for _, pendingReq := range toDelete {
				err := pitaya.Error(errors.New("request timeout"), "PIT-504")
				errMarshalled, _ := json.Marshal(err)
				// send a timeout to incoming msg chan
				m := &message.Message{
					Type:  message.Response,
					ID:    pendingReq.msg.ID,
					Route: pendingReq.msg.Route,
					Data:  errMarshalled,
					Err:   true,
				}
				delete(c.pendingRequests, pendingReq.msg.ID)
				<-c.pendingChan
				c.IncomingMsgChan <- m
			}
			c.pendingReqMutex.Unlock()
		case <-c.closeChan:
			return
		}
	}
}

func (c *Client) handlePackets() {
	for {
		select {
		case p := <-c.packetChan:
			switch p.Type {
			case packet.Data:
				//handle data
				logger.Log.Debug("got data: %s", string(p.Data))
				m, err := message.Decode(p.Data)
				if err != nil {
					logger.Log.Errorf("error decoding msg from sv: %s", string(m.Data))
				}
				if m.Type == message.Response {
					c.pendingReqMutex.Lock()
					if _, ok := c.pendingRequests[m.ID]; ok {
						delete(c.pendingRequests, m.ID)
						<-c.pendingChan
					} else {
						c.pendingReqMutex.Unlock()
						continue // do not process msg for already timedout request
					}
					c.pendingReqMutex.Unlock()
				}
				c.IncomingMsgChan <- m
			case packet.Kick:
				logger.Log.Warn("got kick packet from the server! disconnecting...")
				c.Disconnect()
			}
		case <-c.closeChan:
			return
		}
	}
}

func (c *Client) readPackets(buf *bytes.Buffer) ([]*packet.Packet, error) {
	// listen for sv messages
	data := make([]byte, 1024)
	n := len(data)
	var err error

	for n == len(data) {
		n, err = c.conn.Read(data)
		if err != nil {
			return nil, err
		}
		buf.Write(data[:n])
	}
	packets, err := c.packetDecoder.Decode(buf.Bytes())
	if err != nil {
		logger.Log.Errorf("error decoding packet from server: %s", err.Error())
	}
	totalProcessed := 0
	for _, p := range packets {
		totalProcessed += codec.HeadLength + p.Length
	}
	buf.Next(totalProcessed)

	return packets, nil
}

func (c *Client) handleServerMessages() {
	buf := bytes.NewBuffer(nil)
	defer c.Disconnect()
	for c.Connected {
		packets, err := c.readPackets(buf)
		if err != nil && c.Connected {
			logger.Log.Error(err)
			break
		}

		for _, p := range packets {
			c.packetChan <- p
		}
	}
}

func (c *Client) sendHeartbeats(interval int) {
	t := time.NewTicker(time.Duration(interval) * time.Second)
	defer func() {
		t.Stop()
		c.Disconnect()
	}()
	for {
		select {
		case <-t.C:
			p, _ := c.packetEncoder.Encode(packet.Heartbeat, []byte{})
			_, err := c.conn.Write(p)
			if err != nil {
				logger.Log.Errorf("error sending heartbeat to server: %s", err.Error())
				return
			}
		case <-c.closeChan:
			return
		}
	}
}

// Disconnect disconnects the client
func (c *Client) Disconnect() {
	if c.Connected {
		c.Connected = false
		close(c.closeChan)
		c.conn.Close()
	}
}

// ConnectTo connects to the server at addr, for now the only supported protocol is tcp
// if tlsConfig is sent, it connects using TLS
func (c *Client) ConnectTo(addr string, tlsConfig ...*tls.Config) error {
	var conn net.Conn
	var err error
	if len(tlsConfig) > 0 {
		conn, err = tls.Dial("tcp", addr, tlsConfig[0])
	} else {
		conn, err = net.Dial("tcp", addr)
	}
	if err != nil {
		return err
	}
	c.conn = conn
	c.IncomingMsgChan = make(chan *message.Message, 10)

	if err = c.handleHandshake(); err != nil {
		return err
	}

	c.closeChan = make(chan struct{})

	return nil
}

// ConnectToWS connects using webshocket protocol
func (c *Client) ConnectToWS(addr string, path string, tlsConfig ...*tls.Config) error {
	u := url.URL{Scheme: "ws", Host: addr, Path: path}
	dialer := websocket.DefaultDialer

	if len(tlsConfig) > 0 {
		dialer.TLSClientConfig = tlsConfig[0]
		u.Scheme = "wss"
	}

	conn, _, err := dialer.Dial(u.String(), nil)
	if err != nil {
		return err
	}

	c.conn, err = acceptor.NewWSConn(conn)
	if err != nil {
		return err
	}

	c.IncomingMsgChan = make(chan *message.Message, 10)

	if err = c.handleHandshake(); err != nil {
		return err
	}

	c.closeChan = make(chan struct{})

	return nil
}

func (c *Client) handleHandshake() error {
	if err := c.sendHandshakeRequest(); err != nil {
		return err
	}

	if err := c.handleHandshakeResponse(); err != nil {
		return err
	}
	return nil
}

// SendRequest sends a request to the server
func (c *Client) SendRequest(route string, data []byte) (uint, error) {
	return c.sendMsg(message.Request, route, data)
}

// SendNotify sends a notify to the server
func (c *Client) SendNotify(route string, data []byte) error {
	_, err := c.sendMsg(message.Notify, route, data)
	return err
}

func (c *Client) buildPacket(msg message.Message) ([]byte, error) {
	encMsg, err := c.messageEncoder.Encode(&msg)
	if err != nil {
		return nil, err
	}
	p, err := c.packetEncoder.Encode(packet.Data, encMsg)
	if err != nil {
		return nil, err
	}

	return p, nil
}

// sendMsg sends the request to the server
func (c *Client) sendMsg(msgType message.Type, route string, data []byte) (uint, error) {
	// TODO mount msg and encode
	m := message.Message{
		Type:  msgType,
		ID:    uint(atomic.AddUint32(&c.nextID, 1)),
		Route: route,
		Data:  data,
		Err:   false,
	}
	p, err := c.buildPacket(m)
	if msgType == message.Request {
		c.pendingChan <- true
		c.pendingReqMutex.Lock()
		if _, ok := c.pendingRequests[m.ID]; !ok {
			c.pendingRequests[m.ID] = &pendingRequest{
				msg:    &m,
				sentAt: time.Now(),
			}
		}
		c.pendingReqMutex.Unlock()
	}

	if err != nil {
		return m.ID, err
	}
	_, err = c.conn.Write(p)
	return m.ID, err
}

```

`pkg/client/client_test.go`:

```go
package client

import (
	"testing"
	"time"

	"github.com/golang/mock/gomock"
	"github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/helpers"
	"github.com/topfreegames/pitaya/v3/pkg/mocks"
)

func TestSendRequestShouldTimeout(t *testing.T) {
	c := New(logrus.InfoLevel, 100*time.Millisecond)
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockConn := mocks.NewMockPlayerConn(ctrl)
	c.conn = mockConn
	go c.pendingRequestsReaper()

	route := "com.sometest.route"
	data := []byte{0x02, 0x03, 0x04}

	m := message.Message{
		Type:  message.Request,
		ID:    1,
		Route: route,
		Data:  data,
		Err:   false,
	}

	pkt, err := c.buildPacket(m)
	assert.NoError(t, err)

	mockConn.EXPECT().Write(pkt)

	c.IncomingMsgChan = make(chan *message.Message, 10)

	c.nextID = 0
	c.SendRequest(route, data)

	msg := helpers.ShouldEventuallyReceive(t, c.IncomingMsgChan, 2*time.Second).(*message.Message)

	assert.Equal(t, true, msg.Err)
}

```

`pkg/client/pitayaclient.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package client

import (
	"crypto/tls"

	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/session"
)

// PitayaClient iface
type PitayaClient interface {
	ConnectTo(addr string, tlsConfig ...*tls.Config) error
	ConnectToWS(addr string, path string, tlsConfig ...*tls.Config) error
	ConnectedStatus() bool
	Disconnect()
	MsgChannel() chan *message.Message
	SendNotify(route string, data []byte) error
	SendRequest(route string, data []byte) (uint, error)
	SetClientHandshakeData(data *session.HandshakeData)
}

```

`pkg/client/protoclient.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package client

import (
	"bytes"
	"compress/gzip"
	"crypto/tls"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"
	"time"

	"github.com/golang/protobuf/proto"
	protobuf "github.com/golang/protobuf/protoc-gen-go/descriptor"
	"github.com/jhump/protoreflect/desc"
	"github.com/jhump/protoreflect/dynamic"
	"github.com/sirupsen/logrus"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
)

// Command struct. Save the input and output type and proto descriptor for each
// one.
type Command struct {
	input               string // input command name
	output              string // output command name
	inputMsgDescriptor  *desc.MessageDescriptor
	outputMsgDescriptor *desc.MessageDescriptor
}

// ProtoBufferInfo save all commands from a server.
type ProtoBufferInfo struct {
	Commands map[string]*Command
}

// ProtoClient struct
type ProtoClient struct {
	Client
	descriptorsNames        map[string]bool
	info                    ProtoBufferInfo
	docsRoute               string
	descriptorsRoute        string
	IncomingMsgChan         chan *message.Message
	expectedInputDescriptor *desc.MessageDescriptor
	ready                   bool
	closeChan               chan bool
}

// MsgChannel return the incoming message channel
func (pc *ProtoClient) MsgChannel() chan *message.Message {
	return pc.IncomingMsgChan
}

// Receive a compressed byte slice and unpack it to a FileDescriptorProto
func unpackDescriptor(compressedDescriptor []byte) (*protobuf.FileDescriptorProto, error) {
	r, err := gzip.NewReader(bytes.NewReader(compressedDescriptor))
	if err != nil {
		return nil, err
	}
	defer r.Close()

	b, err := io.ReadAll(r)
	if err != nil {
		return nil, err
	}

	var fileDescriptorProto protobuf.FileDescriptorProto

	if err = proto.Unmarshal(b, &fileDescriptorProto); err != nil {
		return nil, err
	}

	return &fileDescriptorProto, nil
}

// Receive an array of descriptors in binary format. The function creates the
// protobuffer from this data and associates it to the message.
func (pc *ProtoClient) buildProtosFromDescriptor(descriptorArray []*protobuf.FileDescriptorProto) error {

	descriptorsMap := make(map[string]*desc.MessageDescriptor)

	descriptors, err := desc.CreateFileDescriptors(descriptorArray)
	if err != nil {
		return err
	}

	for name := range pc.descriptorsNames {
		for _, v := range descriptors {
			message := v.FindMessage(name)
			if message != nil {
				descriptorsMap[name] = message
			}
		}
	}

	for name, cmd := range pc.info.Commands {
		if msg, ok := descriptorsMap[cmd.input]; ok {
			pc.info.Commands[name].inputMsgDescriptor = msg
		}
		if msg, ok := descriptorsMap[cmd.output]; ok {
			pc.info.Commands[name].outputMsgDescriptor = msg
		}
	}

	return nil
}

// Receives each entry from the Unmarshal json from the Docs and read the inputs and
// outputs associated with it. Return the output type, the input and the error.
func getOutputInputNames(command map[string]interface{}) (string, string, error) {
	outputName := ""
	inputName := ""

	in := command["input"]
	inputDocs, ok := in.(map[string]interface{})
	if ok {
		for k := range inputDocs {
			if strings.Contains(k, "proto") {
				inputName = strings.Replace(k, "*", "", 1)
			}
		}
	}

	out := command["output"]
	outputDocsArr := out.([]interface{})
	// we can have handlers that have no return specified.
	if len(outputDocsArr) == 0 {
		return inputName, "", nil
	}

	outputDocs, ok := outputDocsArr[0].(map[string]interface{})
	if ok {
		for k := range outputDocs {
			if strings.Contains(k, "proto") {
				outputName = strings.Replace(k, "*", "", 1)
			}
		}
	}

	return inputName, outputName, nil
}

// Get recursively all protos needed in a Unmarshal json.
func getKeys(info map[string]interface{}, keysSet map[string]bool) {
	for k, v := range info {
		if strings.Contains(k, "*") {
			kew := strings.Replace(k, "*", "", 1)
			keysSet[kew] = true
		}

		listofouts, ok := v.([]interface{})
		if ok {
			for i := range listofouts {
				aux, ok := listofouts[i].(map[string]interface{})
				if !ok {
					continue
				}
				getKeys(aux, keysSet)
			}
		}

		if aux, ok := v.(map[string]interface{}); ok {
			getKeys(aux, keysSet)
		}
	}
}

// Receives one json string from the auto documentation, decode it and request
// to the server the protobuf descriptors. If the the  descriptors route are
// not set, this function identify the route responsible for providing the
// protobuf descriptors.
func (pc *ProtoClient) getDescriptors(data string) error {
	d := []byte(data)
	var jsonmap interface{}
	if err := json.Unmarshal(d, &jsonmap); err != nil {
		return err
	}
	m := jsonmap.(map[string]interface{})
	keysSet := make(map[string]bool)
	getKeys(m, keysSet)

	// load predefined protos
	for _, commands := range pc.info.Commands {
		if commands.input != "" {
			keysSet[commands.input] = true
		}
		if commands.output != "" {
			keysSet[commands.output] = true
		}
	}

	// build commands reference
	handlers := m["handlers"].(map[string]interface{})
	for k, v := range handlers {
		cmdInfo := v.(map[string]interface{})
		in, out, err := getOutputInputNames(cmdInfo)
		if err != nil {
			return fmt.Errorf("failed to get output and input names for '%s' handler: %w", k, err)
		}

		var command Command
		command.input = in
		command.output = out

		pc.info.Commands[k] = &command
		if pc.descriptorsRoute == "" && in == "protos.ProtoNames" && out == "protos.ProtoDescriptors" {
			pc.descriptorsRoute = k
		}
	}

	remotes := m["remotes"].(map[string]interface{})
	for k, v := range remotes {
		cmdInfo := v.(map[string]interface{})
		in, out, err := getOutputInputNames(cmdInfo)
		if err != nil {
			return err
		}

		var command Command
		command.input = in
		command.output = out

		pc.info.Commands[k] = &command
	}

	names := make([]string, 0, len(keysSet))
	for key := range keysSet {
		names = append(names, key)
	}

	protname := &protos.ProtoNames{
		Name: names,
	}

	encodedNames, err := proto.Marshal(protname)
	if err != nil {
		return fmt.Errorf("failed to encode proto names: %w", err)
	}
	_, err = pc.SendRequest(pc.descriptorsRoute, encodedNames)
	if err != nil {
		return fmt.Errorf("failed to send proto descriptors request: %w", err)
	}

	response := <-pc.Client.IncomingMsgChan
	descriptors := &protos.ProtoDescriptors{}
	if err := proto.Unmarshal(response.Data, descriptors); err != nil {
		return fmt.Errorf("failed to unmarshal proto descriptors response: %w", err)
	}

	// get all proto types
	descriptorArray := make([]*protobuf.FileDescriptorProto, 0)
	for i := range descriptors.Desc {
		fileDescriptorProto, err := unpackDescriptor(descriptors.Desc[i])
		if err != nil {
			return fmt.Errorf("failed to unpack descriptor: %w", err)
		}

		descriptorArray = append(descriptorArray, fileDescriptorProto)
		pc.descriptorsNames[names[i]] = true
	}

	if err = pc.buildProtosFromDescriptor(descriptorArray); err != nil {
		return fmt.Errorf("failed to build proto from descriptor: %w", err)
	}

	return nil
}

// Return the basic structure for the ProtoClient struct.
func newProto(docslogLevel logrus.Level, requestTimeout ...time.Duration) *ProtoClient {
	return &ProtoClient{
		Client:           *New(docslogLevel, requestTimeout...),
		descriptorsNames: make(map[string]bool),
		info: ProtoBufferInfo{
			Commands: make(map[string]*Command),
		},
		docsRoute:        "",
		descriptorsRoute: "",
		IncomingMsgChan:  make(chan *message.Message, 10),
		closeChan:        make(chan bool),
	}
}

// NewProto returns a new protoclient with the auto documentation route.
func NewProto(docsRoute string, docslogLevel logrus.Level, requestTimeout ...time.Duration) *ProtoClient {
	newclient := newProto(docslogLevel, requestTimeout...)
	newclient.docsRoute = docsRoute
	return newclient
}

// NewWithDescriptor returns a new protoclient with the descriptors route and
// auto documentation route.
func NewWithDescriptor(descriptorsRoute string, docsRoute string, docslogLevel logrus.Level, requestTimeout ...time.Duration) *ProtoClient {
	newclient := newProto(docslogLevel, requestTimeout...)
	newclient.docsRoute = docsRoute
	newclient.descriptorsRoute = descriptorsRoute
	return newclient
}

// LoadServerInfo load commands information from the server. Addr is the
// server address.
func (pc *ProtoClient) LoadServerInfo(addr string) error {
	pc.ready = false

	if err := pc.Client.ConnectToWS(addr, "", &tls.Config{
		InsecureSkipVerify: true,
	}); err != nil {
		if err := pc.Client.ConnectToWS(addr, ""); err != nil {
			if err := pc.Client.ConnectTo(addr, &tls.Config{
				InsecureSkipVerify: true,
			}); err != nil {
				if err := pc.Client.ConnectTo(addr); err != nil {
					return err
				}
			}
		}
	}

	// request doc info
	_, err := pc.SendRequest(pc.docsRoute, make([]byte, 0))
	if err != nil {
		return err
	}
	response := <-pc.Client.IncomingMsgChan

	docs := &protos.Doc{}
	if err := proto.Unmarshal(response.Data, docs); err != nil {
		return fmt.Errorf("failed to unmarshal docs route response: %w", err)
	}

	if err := pc.getDescriptors(docs.Doc); err != nil {
		return fmt.Errorf("failed to read proto descriptors: %w", err)
	}

	pc.Disconnect()
	pc.ready = true

	return nil
}

// Disconnect the client
func (pc *ProtoClient) Disconnect() {
	pc.Client.Disconnect()
	if pc.ready {
		pc.closeChan <- true
	}
}

// Wait for new messages from the server or the connection end. If the menssage
// has a response.Route, it decodes based on it. If not, it will try to decode
// the menssage using the last expected response.
func (pc *ProtoClient) waitForData() {
	for {
		select {
		case response := <-pc.Client.IncomingMsgChan:
			inputMsg := dynamic.NewMessage(pc.expectedInputDescriptor)

			msg, ok := pc.info.Commands[response.Route]
			if ok {
				inputMsg = dynamic.NewMessage(msg.outputMsgDescriptor)
			} else {
				pc.expectedInputDescriptor = nil
			}

			if response.Err {
				errMsg := &protos.Error{}
				err := proto.Unmarshal(response.Data, errMsg)
				if err != nil {
					logger.Log.Errorf("Erro decode error data: %s", string(response.Data))
					continue
				}
				response.Data, err = json.Marshal(errMsg)
				if err != nil {
					logger.Log.Errorf("error encode error to json: %s", string(response.Data))
					continue
				}
				pc.IncomingMsgChan <- response
				continue
			}

			if inputMsg == nil {
				logger.Log.Errorf("not expected data: %s", string(response.Data))
				continue
			}

			err := inputMsg.Unmarshal(response.Data)
			if err != nil {
				logger.Log.Errorf("error decode data: %s", string(response.Data))
				continue
			}

			data, err2 := inputMsg.MarshalJSON()
			if err2 != nil {
				logger.Log.Errorf("error encode data to json: %s", string(response.Data))
				continue
			}

			response.Data = data
			pc.IncomingMsgChan <- response
		case <-pc.closeChan:
			return
		}
	}
}

// ConnectTo connects to the server at addr, for now the only supported protocol is tcp
// this methods blocks as it also handles the messages from the server
func (pc *ProtoClient) ConnectTo(addr string, tlsConfig ...*tls.Config) error {
	err := pc.Client.ConnectTo(addr, tlsConfig...)
	if err != nil {
		return err
	}

	if !pc.ready {
		err = pc.LoadServerInfo(addr)
		if err != nil {
			return err
		}
	}

	if pc.ready {
		go pc.waitForData()
	}
	return nil
}

// ExportInformation export supported server commands information
func (pc *ProtoClient) ExportInformation() *ProtoBufferInfo {
	if !pc.ready {
		return nil
	}
	return &pc.info
}

// LoadInfo load commands information form ProtoBufferInfo
func (pc *ProtoClient) LoadInfo(info *ProtoBufferInfo) error {
	if info == nil {
		return errors.New("protobuffer information invalid")
	}
	pc.info = *info
	pc.ready = true
	return nil
}

// AddPushResponse add a push response. Must be ladded before LoadInfo.
func (pc *ProtoClient) AddPushResponse(route string, protoName string) {
	if route != "" && protoName != "" {
		var command Command
		command.input = ""
		command.output = protoName

		pc.info.Commands[route] = &command
	}
}

// SendRequest sends a request to the server
func (pc *ProtoClient) SendRequest(route string, data []byte) (uint, error) {

	if !pc.ready {
		return pc.Client.SendRequest(route, data)
	}

	if cmd, ok := pc.info.Commands[route]; ok {
		if len(data) < 0 || string(data) == "{}" || cmd.inputMsgDescriptor == nil {
			pc.expectedInputDescriptor = cmd.outputMsgDescriptor
			data = data[:0]
			return pc.Client.SendRequest(route, data)
		}
		inputMsg := dynamic.NewMessage(cmd.inputMsgDescriptor)
		if err := inputMsg.UnmarshalJSON(data); err != nil {
			return 0, err
		}
		realdata, err := inputMsg.Marshal()
		if err != nil {
			return 0, err
		}
		pc.expectedInputDescriptor = cmd.outputMsgDescriptor
		return pc.Client.SendRequest(route, realdata)
	}

	return 0, errors.New("Invalid Route: " + route)
}

// SendNotify sends a notify to the server
func (pc *ProtoClient) SendNotify(route string, data []byte) error {

	if cmd, ok := pc.info.Commands[route]; ok {
		inputMsg := dynamic.NewMessage(cmd.inputMsgDescriptor)
		err := inputMsg.UnmarshalJSON(data)
		if err != nil {
			return err
		}
		realdata, err := inputMsg.Marshal()
		if err != nil {
			return err
		}
		return pc.Client.SendNotify(route, realdata)
	}

	return errors.New("invalid route")
}

```

`pkg/cluster/cluster.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package cluster

import (
	"context"

	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	pcontext "github.com/topfreegames/pitaya/v3/pkg/context"
	"github.com/topfreegames/pitaya/v3/pkg/interfaces"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/route"
	"github.com/topfreegames/pitaya/v3/pkg/session"
	"github.com/topfreegames/pitaya/v3/pkg/tracing"
)

// RPCServer interface
type RPCServer interface {
	SetPitayaServer(protos.PitayaServer)
	interfaces.Module
}

// RPCClient interface
type RPCClient interface {
	Send(route string, data []byte) error
	SendPush(userID string, frontendSv *Server, push *protos.Push) error
	SendKick(userID string, serverType string, kick *protos.KickMsg) error
	BroadcastSessionBind(uid string) error
	Call(ctx context.Context, rpcType protos.RPCType, route *route.Route, session session.Session, msg *message.Message, server *Server) (*protos.Response, error)
	interfaces.Module
}

// SDListener interface
type SDListener interface {
	AddServer(*Server)
	RemoveServer(*Server)
}

// RemoteBindingListener listens to session bindings in remote servers
type RemoteBindingListener interface {
	OnUserBind(uid, fid string)
}

// InfoRetriever gets cluster info
// It can be implemented, for exemple, by reading
// env var, config or by accessing the cluster API
type InfoRetriever interface {
	Region() string
}

// Action type for enum
type Action int

// Action values
const (
	ADD Action = iota
	DEL
)

func buildRequest(
	ctx context.Context,
	rpcType protos.RPCType,
	route *route.Route,
	session session.Session,
	msg *message.Message,
	thisServer *Server,
) (protos.Request, error) {
	req := protos.Request{
		Type: rpcType,
		Msg: &protos.Msg{
			Route: route.String(),
			Data:  msg.Data,
		},
	}
	ctx, err := tracing.InjectSpan(ctx)
	if err != nil {
		logger.Log.Errorf("failed to inject span: %s", err)
	}
	ctx = pcontext.AddToPropagateCtx(ctx, constants.PeerIDKey, thisServer.ID)
	ctx = pcontext.AddToPropagateCtx(ctx, constants.PeerServiceKey, thisServer.Type)
	req.Metadata, err = pcontext.Encode(ctx)
	if err != nil {
		return req, err
	}
	if thisServer.Frontend {
		req.FrontendID = thisServer.ID
	}

	switch msg.Type {
	case message.Request:
		req.Msg.Type = protos.MsgType_MsgRequest
	case message.Notify:
		req.Msg.Type = protos.MsgType_MsgNotify
	}

	if rpcType == protos.RPCType_Sys {
		mid := uint(0)
		if msg.Type == message.Request {
			mid = msg.ID
		}
		req.Msg.Id = uint64(mid)
		req.Session = &protos.Session{
			Id:   session.ID(),
			Uid:  session.UID(),
			Data: session.GetDataEncoded(),
		}
	}

	return req, nil
}

```

`pkg/cluster/etcd_service_discovery.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package cluster

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/util"
	logutil "go.etcd.io/etcd/client/pkg/v3/logutil"
	clientv3 "go.etcd.io/etcd/client/v3"
	"go.etcd.io/etcd/client/v3/namespace"
	"google.golang.org/grpc"
)

type etcdServiceDiscovery struct {
	cli                    *clientv3.Client
	syncServersInterval    time.Duration
	heartbeatTTL           time.Duration
	logHeartbeat           bool
	lastHeartbeatTime      time.Time
	leaseID                clientv3.LeaseID
	mapByTypeLock          sync.RWMutex
	serverMapByType        map[string]map[string]*Server
	serverMapByID          sync.Map
	etcdEndpoints          []string
	etcdUser               string
	etcdPass               string
	etcdPrefix             string
	etcdDialTimeout        time.Duration
	running                bool
	server                 *Server
	stopChan               chan bool
	stopLeaseChan          chan bool
	lastSyncTime           time.Time
	listeners              []SDListener
	revokeTimeout          time.Duration
	grantLeaseTimeout      time.Duration
	grantLeaseMaxRetries   int
	grantLeaseInterval     time.Duration
	shutdownDelay          time.Duration
	appDieChan             chan bool
	serverTypesBlacklist   []string
	syncServersParallelism int
	syncServersRunning     chan bool
}

// NewEtcdServiceDiscovery ctor
func NewEtcdServiceDiscovery(
	config config.EtcdServiceDiscoveryConfig,
	server *Server,
	appDieChan chan bool,
	cli ...*clientv3.Client,
) (ServiceDiscovery, error) {
	var client *clientv3.Client
	if len(cli) > 0 {
		client = cli[0]
	}
	sd := &etcdServiceDiscovery{
		running:            false,
		server:             server,
		serverMapByType:    make(map[string]map[string]*Server),
		listeners:          make([]SDListener, 0),
		stopChan:           make(chan bool),
		stopLeaseChan:      make(chan bool),
		appDieChan:         appDieChan,
		cli:                client,
		syncServersRunning: make(chan bool),
	}

	sd.configure(config)

	return sd, nil
}

func (sd *etcdServiceDiscovery) configure(config config.EtcdServiceDiscoveryConfig) {
	sd.etcdEndpoints = config.Endpoints
	sd.etcdUser = config.User
	sd.etcdPass = config.Pass
	sd.etcdDialTimeout = config.DialTimeout
	sd.etcdPrefix = config.Prefix
	sd.heartbeatTTL = config.Heartbeat.TTL
	sd.logHeartbeat = config.Heartbeat.Log
	sd.syncServersInterval = config.SyncServers.Interval
	sd.revokeTimeout = config.Revoke.Timeout
	sd.grantLeaseTimeout = config.GrantLease.Timeout
	sd.grantLeaseMaxRetries = config.GrantLease.MaxRetries
	sd.grantLeaseInterval = config.GrantLease.RetryInterval
	sd.shutdownDelay = config.Shutdown.Delay
	sd.serverTypesBlacklist = config.ServerTypesBlacklist
	sd.syncServersParallelism = config.SyncServers.Parallelism
}

func (sd *etcdServiceDiscovery) watchLeaseChan(c <-chan *clientv3.LeaseKeepAliveResponse) {
	failedGrantLeaseAttempts := 0
	for {
		select {
		case <-sd.stopChan:
			return
		case <-sd.stopLeaseChan:
			return
		case leaseKeepAliveResponse, ok := <-c:
			if !ok {
				logger.Log.Error("ETCD lease KeepAlive died, retrying in 10 seconds")
				time.Sleep(10000 * time.Millisecond)
			}
			if leaseKeepAliveResponse != nil {
				if sd.logHeartbeat {
					logger.Log.Debugf("sd: etcd lease %x renewed", leaseKeepAliveResponse.ID)
				}
				failedGrantLeaseAttempts = 0
				continue
			}
			logger.Log.Warn("sd: error renewing etcd lease, reconfiguring")
			for {
				err := sd.renewLease()
				if err != nil {
					failedGrantLeaseAttempts = failedGrantLeaseAttempts + 1
					if err == constants.ErrEtcdGrantLeaseTimeout {
						logger.Log.Warn("sd: timed out trying to grant etcd lease")
						if sd.appDieChan != nil {
							sd.appDieChan <- true
						}
						return
					}
					if failedGrantLeaseAttempts >= sd.grantLeaseMaxRetries {
						logger.Log.Warn("sd: exceeded max attempts to renew etcd lease")
						if sd.appDieChan != nil {
							sd.appDieChan <- true
						}
						return
					}
					logger.Log.Warnf("sd: error granting etcd lease, will retry in %d seconds", uint64(sd.grantLeaseInterval.Seconds()))
					time.Sleep(sd.grantLeaseInterval)
					continue
				}
				return
			}
		}
	}
}

// renewLease reestablishes connection with etcd
func (sd *etcdServiceDiscovery) renewLease() error {
	c := make(chan error, 1)
	go func() {
		defer close(c)
		logger.Log.Infof("waiting for etcd lease")
		err := sd.grantLease()
		if err != nil {
			c <- err
			return
		}
		err = sd.bootstrapServer(sd.server)
		c <- err
	}()
	select {
	case err := <-c:
		return err
	case <-time.After(sd.grantLeaseTimeout):
		return constants.ErrEtcdGrantLeaseTimeout
	}
}

func (sd *etcdServiceDiscovery) grantLease() error {
	// grab lease
	ctx, cancel := context.WithTimeout(context.Background(), sd.etcdDialTimeout)
	defer cancel()
	l, err := sd.cli.Grant(ctx, int64(sd.heartbeatTTL.Seconds()))
	if err != nil {
		return err
	}
	sd.leaseID = l.ID
	logger.Log.Debugf("sd: got leaseID: %x", l.ID)
	// this will keep alive forever, when channel c is closed
	// it means we probably have to rebootstrap the lease
	c, err := sd.cli.KeepAlive(context.TODO(), sd.leaseID)
	if err != nil {
		return err
	}
	// need to receive here as per etcd docs
	<-c
	go sd.watchLeaseChan(c)
	return nil
}

func (sd *etcdServiceDiscovery) addServerIntoEtcd(server *Server) error {
	_, err := sd.cli.Put(
		context.TODO(),
		getKey(server.ID, server.Type),
		server.AsJSONString(),
		clientv3.WithLease(sd.leaseID),
	)
	return err
}

func (sd *etcdServiceDiscovery) bootstrapServer(server *Server) error {
	if err := sd.addServerIntoEtcd(server); err != nil {
		return err
	}

	sd.SyncServers(true)
	return nil
}

// AddListener adds a listener to etcd service discovery
func (sd *etcdServiceDiscovery) AddListener(listener SDListener) {
	sd.listeners = append(sd.listeners, listener)
}

// AfterInit executes after Init
func (sd *etcdServiceDiscovery) AfterInit() {
}

func (sd *etcdServiceDiscovery) notifyListeners(act Action, sv *Server) {
	for _, l := range sd.listeners {
		if act == DEL {
			l.RemoveServer(sv)
		} else if act == ADD {
			l.AddServer(sv)
		}
	}
}

func (sd *etcdServiceDiscovery) writeLockScope(f func()) {
	sd.mapByTypeLock.Lock()
	defer sd.mapByTypeLock.Unlock()
	f()
}

func (sd *etcdServiceDiscovery) deleteServer(serverID string) {
	if actual, ok := sd.serverMapByID.Load(serverID); ok {
		sv := actual.(*Server)
		sd.serverMapByID.Delete(sv.ID)
		sd.writeLockScope(func() {
			if svMap, ok := sd.serverMapByType[sv.Type]; ok {
				delete(svMap, sv.ID)
			}
		})
		sd.notifyListeners(DEL, sv)
	}
}

func (sd *etcdServiceDiscovery) deleteLocalInvalidServers(actualServers []string) {
	sd.serverMapByID.Range(func(key interface{}, value interface{}) bool {
		k := key.(string)
		if !util.SliceContainsString(actualServers, k) {
			logger.Log.Warnf("deleting invalid local server %s", k)
			sd.deleteServer(k)
		}
		return true
	})
}

func getKey(serverID, serverType string) string {
	return fmt.Sprintf("servers/%s/%s", serverType, serverID)
}

func getServerFromEtcd(cli *clientv3.Client, serverType, serverID string) (*Server, error) {
	svKey := getKey(serverID, serverType)
	svEInfo, err := cli.Get(context.TODO(), svKey)
	if err != nil {
		return nil, fmt.Errorf("error getting server: %s from etcd, error: %s", svKey, err.Error())
	}
	if len(svEInfo.Kvs) == 0 {
		return nil, fmt.Errorf("didn't found server: %s in etcd", svKey)
	}
	return parseServer(svEInfo.Kvs[0].Value)
}

// GetServersByType returns a slice with all the servers of a certain type
func (sd *etcdServiceDiscovery) GetServersByType(serverType string) (map[string]*Server, error) {
	sd.mapByTypeLock.RLock()
	defer sd.mapByTypeLock.RUnlock()
	if m, ok := sd.serverMapByType[serverType]; ok && len(m) > 0 {
		// Create a new map to avoid concurrent read and write access to the
		// map, this also prevents accidental changes to the list of servers
		// kept by the service discovery.
		ret := make(map[string]*Server, len(sd.serverMapByType[serverType]))
		for k, v := range sd.serverMapByType[serverType] {
			ret[k] = v
		}
		return ret, nil
	}
	return nil, constants.ErrNoServersAvailableOfType
}

// GetServers returns a slice with all the servers
func (sd *etcdServiceDiscovery) GetServers() []*Server {
	ret := make([]*Server, 0)
	sd.serverMapByID.Range(func(k, v interface{}) bool {
		ret = append(ret, v.(*Server))
		return true
	})
	return ret
}

func (sd *etcdServiceDiscovery) bootstrap() error {
	if err := sd.grantLease(); err != nil {
		return err
	}

	if err := sd.bootstrapServer(sd.server); err != nil {
		return err
	}

	return nil
}

// GetServer returns a server given it's id
func (sd *etcdServiceDiscovery) GetServer(id string) (*Server, error) {
	if sv, ok := sd.serverMapByID.Load(id); ok {
		return sv.(*Server), nil
	}
	return nil, constants.ErrNoServerWithID
}

func (sd *etcdServiceDiscovery) InitETCDClient() error {
	logger.Log.Infof("Initializing ETCD client")
	var cli *clientv3.Client
	var err error
	etcdClientLogger, _ := logutil.CreateDefaultZapLogger(logutil.ConvertToZapLevel("error"))
	config := clientv3.Config{
		Endpoints:   sd.etcdEndpoints,
		DialTimeout: sd.etcdDialTimeout,
		Logger:      etcdClientLogger,
		DialOptions: []grpc.DialOption{grpc.WithBlock()},
	}
	if sd.etcdUser != "" && sd.etcdPass != "" {
		config.Username = sd.etcdUser
		config.Password = sd.etcdPass
	}
	cli, err = clientv3.New(config)
	if err != nil {
		logger.Log.Errorf("error initializing etcd client: %s", err.Error())
		return err
	}
	sd.cli = cli

	// namespaced etcd :)
	sd.cli.KV = namespace.NewKV(sd.cli.KV, sd.etcdPrefix)
	sd.cli.Watcher = namespace.NewWatcher(sd.cli.Watcher, sd.etcdPrefix)
	sd.cli.Lease = namespace.NewLease(sd.cli.Lease, sd.etcdPrefix)
	return nil
}

// Init starts the service discovery client
func (sd *etcdServiceDiscovery) Init() error {
	sd.running = true
	var err error

	if sd.cli == nil {
		err = sd.InitETCDClient()
		if err != nil {
			return err
		}
	} else {
		sd.cli.KV = namespace.NewKV(sd.cli.KV, sd.etcdPrefix)
		sd.cli.Watcher = namespace.NewWatcher(sd.cli.Watcher, sd.etcdPrefix)
		sd.cli.Lease = namespace.NewLease(sd.cli.Lease, sd.etcdPrefix)
	}
	go sd.watchEtcdChanges()

	if err = sd.bootstrap(); err != nil {
		return err
	}

	// update servers
	syncServersTicker := time.NewTicker(sd.syncServersInterval)
	go func() {
		for sd.running {
			select {
			case <-syncServersTicker.C:
				err := sd.SyncServers(false)
				if err != nil {
					logger.Log.Errorf("error resyncing servers: %s", err.Error())
				}
			case <-sd.stopChan:
				return
			}
		}
	}()

	return nil
}

func parseEtcdKey(key string) (string, string, error) {
	splittedServer := strings.Split(key, "/")
	if len(splittedServer) != 3 {
		return "", "", fmt.Errorf("error parsing etcd key %s (server name can't contain /)", key)
	}
	svType := splittedServer[1]
	svID := splittedServer[2]
	return svType, svID, nil
}

func parseServer(value []byte) (*Server, error) {
	var sv *Server
	err := json.Unmarshal(value, &sv)
	if err != nil {
		logger.Log.Warnf("failed to load server %s, error: %s", sv, err.Error())
		return nil, err
	}
	return sv, nil
}

func (sd *etcdServiceDiscovery) printServers() {
	sd.mapByTypeLock.RLock()
	defer sd.mapByTypeLock.RUnlock()
	for k, v := range sd.serverMapByType {
		logger.Log.Debugf("type: %s, servers: %+v", k, v)
	}
}

// Struct that encapsulates a parallel/concurrent etcd get
// it spawns goroutines and receives work requests through a channel
type parallelGetterWork struct {
	serverType string
	serverID   string
	payload    []byte
}

type parallelGetter struct {
	cli         *clientv3.Client
	numWorkers  int
	wg          *sync.WaitGroup
	resultMutex sync.Mutex
	result      *[]*Server
	workChan    chan parallelGetterWork
}

func newParallelGetter(cli *clientv3.Client, numWorkers int) parallelGetter {
	if numWorkers <= 0 {
		numWorkers = 10
	}
	p := parallelGetter{
		cli:        cli,
		numWorkers: numWorkers,
		workChan:   make(chan parallelGetterWork),
		wg:         new(sync.WaitGroup),
		result:     new([]*Server),
	}
	p.start()
	return p
}

func (p *parallelGetter) start() {
	for i := 0; i < p.numWorkers; i++ {
		go func() {
			for work := range p.workChan {
				logger.Log.Debugf("loading info from missing server: %s/%s", work.serverType, work.serverID)
				var sv *Server
				var err error
				if work.payload == nil {
					sv, err = getServerFromEtcd(p.cli, work.serverType, work.serverID)
				} else {
					sv, err = parseServer(work.payload)
				}
				if err != nil {
					logger.Log.Errorf("Error parsing server from etcd: %s, error: %s", work.serverID, err.Error())
					p.wg.Done()
					continue
				}

				p.resultMutex.Lock()
				*p.result = append(*p.result, sv)
				p.resultMutex.Unlock()

				p.wg.Done()
			}
		}()
	}
}

func (p *parallelGetter) waitAndGetResult() []*Server {
	p.wg.Wait()
	close(p.workChan)
	return *p.result
}

func (p *parallelGetter) addWorkWithPayload(serverType, serverID string, payload []byte) {
	p.wg.Add(1)
	p.workChan <- parallelGetterWork{
		serverType: serverType,
		serverID:   serverID,
		payload:    payload,
	}
}

func (p *parallelGetter) addWork(serverType, serverID string) {
	p.wg.Add(1)
	p.workChan <- parallelGetterWork{
		serverType: serverType,
		serverID:   serverID,
	}
}

// SyncServers gets all servers from etcd
func (sd *etcdServiceDiscovery) SyncServers(firstSync bool) error {
	sd.syncServersRunning <- true
	defer func() {
		sd.syncServersRunning <- false
	}()
	start := time.Now()
	var kvs *clientv3.GetResponse
	var err error
	if firstSync {
		kvs, err = sd.cli.Get(
			context.TODO(),
			"servers/",
			clientv3.WithPrefix(),
		)
	} else {
		kvs, err = sd.cli.Get(
			context.TODO(),
			"servers/",
			clientv3.WithPrefix(),
			clientv3.WithKeysOnly(),
		)
	}
	if err != nil {
		logger.Log.Errorf("Error querying etcd server: %s", err.Error())
		return err
	}

	// delete invalid servers (local ones that are not in etcd)
	allIds := make([]string, 0)

	// Spawn worker goroutines that will work in parallel
	parallelGetter := newParallelGetter(sd.cli, sd.syncServersParallelism)

	for _, kv := range kvs.Kvs {
		svType, svID, err := parseEtcdKey(string(kv.Key))
		if err != nil {
			logger.Log.Warnf("failed to parse etcd key %s, error: %s", kv.Key, err.Error())
			continue
		}

		// Check whether the server type is blacklisted or not
		if sd.isServerTypeBlacklisted(svType) && svID != sd.server.ID {
			logger.Log.Debug("ignoring blacklisted server type '%s'", svType)
			continue
		}

		allIds = append(allIds, svID)

		if _, ok := sd.serverMapByID.Load(svID); !ok {
			// Add new work to the channel
			if firstSync {
				parallelGetter.addWorkWithPayload(svType, svID, kv.Value)
			} else {
				parallelGetter.addWork(svType, svID)
			}
		}
	}

	// Wait until all goroutines are finished
	servers := parallelGetter.waitAndGetResult()

	for _, server := range servers {
		logger.Log.Debugf("adding server %v", server)
		sd.addServer(server)
	}

	sd.deleteLocalInvalidServers(allIds)

	sd.printServers()
	sd.lastSyncTime = time.Now()
	elapsed := time.Since(start)
	logger.Log.Infof("SyncServers took : %s to run", elapsed)
	return nil
}

// BeforeShutdown executes before shutting down and will remove the server from the list
func (sd *etcdServiceDiscovery) BeforeShutdown() {
	sd.revoke()
	time.Sleep(sd.shutdownDelay) // Sleep for a short while to ensure shutdown has propagated
}

// Shutdown executes on shutdown and will clean etcd
func (sd *etcdServiceDiscovery) Shutdown() error {
	sd.running = false
	close(sd.stopChan)
	return nil
}

// revoke prevents Pitaya from crashing when etcd is not available
func (sd *etcdServiceDiscovery) revoke() error {
	close(sd.stopLeaseChan)
	c := make(chan error, 1)
	go func() {
		defer close(c)
		logger.Log.Debug("waiting for etcd revoke")

		if sd.cli != nil {
			ctx, cancel := context.WithTimeout(context.Background(), sd.revokeTimeout)
			_, err := sd.cli.Revoke(ctx, sd.leaseID)
			cancel()
			c <- err
		} else {
			c <- nil
		}
		logger.Log.Debug("finished waiting for etcd revoke")
	}()
	err := <-c
	return err
}

func (sd *etcdServiceDiscovery) addServer(sv *Server) {
	if _, loaded := sd.serverMapByID.LoadOrStore(sv.ID, sv); !loaded {
		sd.writeLockScope(func() {
			mapSvByType, ok := sd.serverMapByType[sv.Type]
			if !ok {
				mapSvByType = make(map[string]*Server)
				sd.serverMapByType[sv.Type] = mapSvByType
			}
			mapSvByType[sv.ID] = sv
		})
		if sv.ID != sd.server.ID {
			sd.notifyListeners(ADD, sv)
		}
	}
}

func (sd *etcdServiceDiscovery) watchEtcdChanges() {
	w := sd.cli.Watch(context.Background(), "servers/", clientv3.WithPrefix())
	failedWatchAttempts := 0
	go func(chn clientv3.WatchChan) {
		for sd.running {
			select {
			// Block here if SyncServers() is running and consume the watcher channel after it's finished, to avoid conflicts
			case syncServersState := <-sd.syncServersRunning:
				for syncServersState {
					syncServersState = <-sd.syncServersRunning
				}
			case wResp, ok := <-chn:
				if wResp.Err() != nil {
					logger.Log.Warnf("etcd watcher response error: %s", wResp.Err())
					time.Sleep(100 * time.Millisecond)
				}
				if !ok {
					logger.Log.Error("etcd watcher died, retrying to watch in 1 second")
					failedWatchAttempts++
					time.Sleep(1000 * time.Millisecond)
					if failedWatchAttempts > 10 {
						if err := sd.InitETCDClient(); err != nil {
							failedWatchAttempts = 0
							continue
						}
						chn = sd.cli.Watch(context.Background(), "servers/", clientv3.WithPrefix())
						failedWatchAttempts = 0
					}
					continue
				}
				failedWatchAttempts = 0
				for _, ev := range wResp.Events {
					svType, svID, err := parseEtcdKey(string(ev.Kv.Key))
					if err != nil {
						logger.Log.Warnf("failed to parse key from etcd: %s", ev.Kv.Key)
						continue
					}

					if sd.isServerTypeBlacklisted(svType) && sd.server.ID != svID {
						continue
					}

					switch ev.Type {
					case clientv3.EventTypePut:
						var sv *Server
						var err error
						if sv, err = parseServer(ev.Kv.Value); err != nil {
							logger.Log.Errorf("Failed to parse server from etcd: %v", err)
							continue
						}

						sd.addServer(sv)
						logger.Log.Debugf("server %s added by watcher", ev.Kv.Key)
						sd.printServers()
					case clientv3.EventTypeDelete:
						sd.deleteServer(svID)
						logger.Log.Debugf("server %s deleted by watcher", svID)
						sd.printServers()
					}
				}
			case <-sd.stopChan:
				return
			}
		}
	}(w)
}

func (sd *etcdServiceDiscovery) isServerTypeBlacklisted(svType string) bool {
	for _, blacklistedSv := range sd.serverTypesBlacklist {
		if blacklistedSv == svType {
			return true
		}
	}
	return false
}

func (sd *etcdServiceDiscovery) IsConnected(ctx context.Context) bool {
	if sd.cli == nil {
		return false
	}

	checkCtx, cancel := context.WithTimeout(ctx, sd.revokeTimeout)
	defer cancel()

	_, err := sd.cli.Get(checkCtx, "health-check", clientv3.WithLimit(1))
	return err == nil
}

```

`pkg/cluster/etcd_service_discovery_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package cluster

import (
	"context"
	"math"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/helpers"
	clientv3 "go.etcd.io/etcd/client/v3"
)

var etcdSDTables = []struct {
	server *Server
}{
	{NewServer("frontend-1", "type1", true, map[string]string{"k1": "v1"})},
	{NewServer("backend-1", "type2", false, map[string]string{"k2": "v2"})},
	{NewServer("backend-2", "type3", false, nil)},
}

var etcdSDTablesMultipleServers = []struct {
	servers []*Server
}{
	{[]*Server{}},
	{[]*Server{
		NewServer("frontend-1", "type1", true, map[string]string{"k1": "v1"}),
		NewServer("backend-1", "type2", false, map[string]string{"k2": "v2"}),
		NewServer("backend-2", "type3", false, nil),
	}},
	{[]*Server{
		NewServer("frontend-1", "type2", true, map[string]string{"k1": "v1"}),
		NewServer("frontend-2", "type2", true, map[string]string{"k2": "v2"}),
		NewServer("frontend-3", "type2", true, map[string]string{"k1": "v1"}),
	}},
}

var etcdSDBlacklistTables = []struct {
	name                string
	server              *Server
	serversToAdd        []*Server
	serverTypeBlacklist []string
}{
	{
		name:   "test1",
		server: NewServer("frontend-1", "type1", true, nil),
		serversToAdd: []*Server{
			NewServer("frontend-1", "type1", true, nil),
		},
		serverTypeBlacklist: nil,
	},
	{
		name:   "test2",
		server: NewServer("frontend-1", "type1", true, nil),
		serversToAdd: []*Server{
			NewServer("backend-1", "type1", false, nil),
			NewServer("backend-2", "type2", false, nil),
			NewServer("backend-3", "type3", false, nil),
		},
		serverTypeBlacklist: []string{"type2"},
	},
	{
		name:   "test3",
		server: NewServer("frontend-1", "type1", true, nil),
		serversToAdd: []*Server{
			NewServer("backend-1", "type1", false, nil),
			NewServer("backend-2", "type2", false, nil),
			NewServer("backend-3", "type3", false, nil),
			NewServer("backend-4", "type4", false, nil),
		},
		serverTypeBlacklist: []string{"type1", "type4"},
	},
}

func getEtcdSD(t *testing.T, config config.EtcdServiceDiscoveryConfig, server *Server, cli *clientv3.Client) *etcdServiceDiscovery {
	t.Helper()
	appDieChan := make(chan bool)
	e, err := NewEtcdServiceDiscovery(config, server, appDieChan, cli)
	assert.NoError(t, err)
	return e.(*etcdServiceDiscovery)
}

func TestNewEtcdServiceDiscovery(t *testing.T) {
	t.Parallel()
	for _, table := range etcdSDTables {
		t.Run(table.server.ID, func(t *testing.T) {
			config := config.NewDefaultPitayaConfig().Cluster.SD.Etcd
			c, cli := helpers.GetTestEtcd(t)
			defer c.Terminate(t)
			e := getEtcdSD(t, config, table.server, cli)
			assert.NotNil(t, e)
		})
	}
}

func TestEtcdSDBootstrapLease(t *testing.T) {
	t.Parallel()
	for _, table := range etcdSDTables {
		t.Run(table.server.ID, func(t *testing.T) {
			config := config.NewDefaultPitayaConfig().Cluster.SD.Etcd
			c, cli := helpers.GetTestEtcd(t)
			defer c.Terminate(t)
			e := getEtcdSD(t, config, table.server, cli)
			err := e.grantLease()
			assert.NoError(t, err)
			assert.NotEmpty(t, e.leaseID)
		})
	}
}

func TestEtcdSDBootstrapLeaseError(t *testing.T) {
	t.Parallel()
	for _, table := range etcdSDTables {
		t.Run(table.server.ID, func(t *testing.T) {
			config := config.NewDefaultPitayaConfig().Cluster.SD.Etcd
			c, cli := helpers.GetTestEtcd(t)
			defer c.Terminate(t)
			e := getEtcdSD(t, config, table.server, cli)
			err := e.grantLease()
			assert.Error(t, err)
		})
	}
}

func TestEtcdSDBootstrapServer(t *testing.T) {
	t.Parallel()
	for _, table := range etcdSDTables {
		t.Run(table.server.ID, func(t *testing.T) {
			config := config.NewDefaultPitayaConfig().Cluster.SD.Etcd
			c, cli := helpers.GetTestEtcd(t)
			defer c.Terminate(t)
			e := getEtcdSD(t, config, table.server, cli)
			e.Init()
			err := e.bootstrapServer(table.server)
			assert.NoError(t, err)
			v, err := cli.Get(context.TODO(), getKey(table.server.ID, table.server.Type))
			assert.NoError(t, err)
			assert.NotNil(t, v)
			assert.Equal(t, 1, len(v.Kvs))
			generatedSv, ok := e.serverMapByID.Load(table.server.ID)
			assert.True(t, ok)
			assert.Equal(t, table.server, generatedSv)
			val := v.Kvs[0]
			assert.Equal(t, getKey(table.server.ID, table.server.Type), string(val.Key))
			assert.Equal(t, table.server.AsJSONString(), string(val.Value))
		})
	}
}

func TestEtcdSDDeleteServer(t *testing.T) {
	t.Parallel()
	for _, table := range etcdSDTables {
		t.Run(table.server.ID, func(t *testing.T) {
			config := config.NewDefaultPitayaConfig().Cluster.SD.Etcd
			c, cli := helpers.GetTestEtcd(t)
			defer c.Terminate(t)
			e := getEtcdSD(t, config, table.server, cli)
			e.Init()
			err := e.bootstrapServer(table.server)
			assert.NoError(t, err)
			e.deleteServer(table.server.ID)
			e.serverMapByID.Delete(table.server.ID)
			generatedSv, ok := e.serverMapByID.Load(table.server.ID)
			assert.False(t, ok)
			assert.Nil(t, generatedSv)
			_, err = e.GetServersByType(table.server.Type)
			assert.EqualError(t, constants.ErrNoServersAvailableOfType, err.Error())
		})
	}
}

func TestEtcdSDGetKey(t *testing.T) {
	t.Parallel()
	tables := []struct {
		serverType string
		serverID   string
		ret        string
	}{
		{"type1", "id1", "servers/type1/id1"},
		{"t", "1", "servers/t/1"},
	}

	for _, table := range tables {
		t.Run(table.ret, func(t *testing.T) {
			assert.Equal(t, table.ret, getKey(table.serverID, table.serverType))
		})
	}
}

func TestEtcdSDDeleteLocalInvalidServers(t *testing.T) {
	t.Parallel()
	for _, table := range etcdSDTables {
		t.Run(table.server.ID, func(t *testing.T) {
			config := config.NewDefaultPitayaConfig().Cluster.SD.Etcd
			c, cli := helpers.GetTestEtcd(t)
			defer c.Terminate(t)
			e := getEtcdSD(t, config, table.server, cli)
			invalidServer := &Server{
				ID:   "invalid",
				Type: "bla",
			}
			e.addServer(invalidServer)
			e.deleteLocalInvalidServers([]string{table.server.ID})
			inv, err := e.GetServer(invalidServer.ID)
			assert.EqualError(t, constants.ErrNoServerWithID, err.Error())
			assert.Nil(t, inv)
		})
	}
}

func TestEtcdSDGetServer(t *testing.T) {
	t.Parallel()
	for _, table := range etcdSDTables {
		t.Run(table.server.ID, func(t *testing.T) {
			config := config.NewDefaultPitayaConfig().Cluster.SD.Etcd
			c, cli := helpers.GetTestEtcd(t)
			defer c.Terminate(t)
			e := getEtcdSD(t, config, table.server, cli)
			e.Init()
			e.bootstrapServer(table.server)
			sv, err := e.GetServer(table.server.ID)
			assert.NoError(t, err)
			assert.Equal(t, table.server, sv)
		})
	}
}

func TestEtcdSDGetServers(t *testing.T) {
	t.Parallel()
	for _, table := range etcdSDTablesMultipleServers {
		config := config.NewDefaultPitayaConfig().Cluster.SD.Etcd
		c, cli := helpers.GetTestEtcd(t)
		defer c.Terminate(t)
		e := getEtcdSD(t, config, &Server{}, cli)
		e.Init()
		for _, server := range table.servers {
			e.bootstrapServer(server)
		}
		serverList := e.GetServers()
		var checkList []*Server
		checkList = append(table.servers, &Server{})
		assert.ElementsMatch(t, checkList, serverList)
	}
}

func TestEtcdSDInit(t *testing.T) {
	t.Parallel()
	for _, table := range etcdSDTables {
		t.Run(table.server.ID, func(t *testing.T) {
			config := config.NewDefaultPitayaConfig().Cluster.SD.Etcd
			config.SyncServers.Interval = time.Duration(300 * time.Millisecond)
			c, cli := helpers.GetTestEtcd(t)
			defer c.Terminate(t)
			e := getEtcdSD(t, config, table.server, cli)
			e.Init()
			// should set running
			assert.True(t, e.running)
			// should have a leaseid
			assert.NotEmpty(t, e.leaseID)
			// should register the server
			sv, err := e.GetServer(table.server.ID)
			assert.NoError(t, err)
			assert.Equal(t, table.server, sv)
			// should heartbeat and sync
			time.Sleep(50 * time.Millisecond)
			// TODO may be flaky
			helpers.ShouldEventuallyReturn(t, func() bool {
				return math.Abs(float64(time.Now().Unix()-e.lastSyncTime.Unix())) < 5
			}, true, 50*time.Millisecond, 2*time.Second)
		})
	}
}

func TestEtcdBeforeShutdown(t *testing.T) {
	t.Parallel()
	for _, table := range etcdSDTables {
		t.Run(table.server.ID, func(t *testing.T) {
			config := config.NewDefaultPitayaConfig().Cluster.SD.Etcd
			c, cli := helpers.GetTestEtcd(t)
			defer c.Terminate(t)
			e := getEtcdSD(t, config, table.server, cli)
			e.Init()
			assert.True(t, e.running)
			e.BeforeShutdown()
			assert.True(t, e.running)
			_, err := cli.Revoke(context.TODO(), e.leaseID)
			assert.Error(t, err)
		})
	}
}

func TestEtcdShutdown(t *testing.T) {
	t.Parallel()
	for _, table := range etcdSDTables {
		t.Run(table.server.ID, func(t *testing.T) {
			config := config.NewDefaultPitayaConfig().Cluster.SD.Etcd
			c, cli := helpers.GetTestEtcd(t)
			defer c.Terminate(t)
			e := getEtcdSD(t, config, table.server, cli)
			e.Init()
			assert.True(t, e.running)
			e.Shutdown()
			assert.False(t, e.running)
		})
	}
}

func TestEtcdWatchChangesAddNewServers(t *testing.T) {
	t.Parallel()
	for _, table := range etcdSDTables {
		t.Run(table.server.ID, func(t *testing.T) {
			config := config.NewDefaultPitayaConfig().Cluster.SD.Etcd
			config.SyncServers.Interval = time.Duration(100 * time.Millisecond)
			c, cli := helpers.GetTestEtcd(t)
			defer c.Terminate(t)
			e := getEtcdSD(t, config, table.server, cli)
			e.Init()
			e.running = true
			serversBefore, err := e.GetServersByType(table.server.Type)
			assert.NoError(t, err)
			assert.Equal(t, 1, len(serversBefore))
			newServer := &Server{
				ID:       "newID",
				Type:     table.server.Type,
				Frontend: false,
			}
			err = e.addServerIntoEtcd(newServer)
			assert.NoError(t, err)
			ss, err := getServerFromEtcd(e.cli, newServer.Type, newServer.ID)
			assert.NoError(t, err)
			assert.Equal(t, newServer, ss)
			helpers.ShouldEventuallyReturn(t, func() int {
				serversNow, _ := e.GetServersByType(table.server.Type)
				return len(serversNow)
			}, 2)
		})
	}
}

func TestEtcdWatchChangesDeleteServers(t *testing.T) {
	t.Parallel()
	for _, table := range etcdSDTables {
		t.Run(table.server.ID, func(t *testing.T) {
			config := config.NewDefaultPitayaConfig().Cluster.SD.Etcd
			config.SyncServers.Interval = 100 * time.Millisecond
			c, cli := helpers.GetTestEtcd(t)
			defer c.Terminate(t)
			e := getEtcdSD(t, config, table.server, cli)
			e.Init()
			e.running = true
			serversBefore, err := e.GetServersByType(table.server.Type)
			assert.NoError(t, err)
			assert.Equal(t, 1, len(serversBefore))
			newServer := &Server{
				ID:       "newID",
				Type:     table.server.Type,
				Frontend: false,
			}
			err = e.addServerIntoEtcd(newServer)
			assert.NoError(t, err)
			ss, err := getServerFromEtcd(e.cli, newServer.Type, newServer.ID)
			assert.NoError(t, err)
			assert.Equal(t, newServer, ss)
			helpers.ShouldEventuallyReturn(t, func() int {
				serversNow, _ := e.GetServersByType(table.server.Type)
				return len(serversNow)
			}, 2)
			_, err = cli.Delete(context.TODO(), getKey(newServer.ID, newServer.Type))
			assert.NoError(t, err)
			helpers.ShouldEventuallyReturn(t, func() int {
				serversNow, _ := e.GetServersByType(table.server.Type)
				return len(serversNow)
			}, 1)
		})
	}
}

func TestEtcdWatchChangesWithBlacklist(t *testing.T) {
	t.Parallel()
	for _, table := range etcdSDBlacklistTables {
		t.Run(table.name, func(t *testing.T) {
			config := config.NewDefaultPitayaConfig().Cluster.SD.Etcd
			config.SyncServers.Interval = 100 * time.Millisecond
			config.ServerTypesBlacklist = table.serverTypeBlacklist
			c, cli := helpers.GetTestEtcd(t)
			defer c.Terminate(t)
			e := getEtcdSD(t, config, table.server, cli)
			e.Init()
			e.running = true

			serversBefore, err := e.GetServersByType(table.server.Type)
			assert.NoError(t, err)
			assert.Equal(t, 1, len(serversBefore))

			// Add all servers to ETCD
			for _, serverToAdd := range table.serversToAdd {
				_, err := cli.Put(
					context.TODO(),
					getKey(serverToAdd.ID, serverToAdd.Type),
					serverToAdd.AsJSONString(),
				)
				assert.NoError(t, err)
			}

			numRequiredServersInSd := func() int {
				num := 0
				for _, serverToAdd := range table.serversToAdd {
					if !e.isServerTypeBlacklisted(serverToAdd.Type) {
						num++
					}
				}
				return num + 1 // The server itself is always added to the cache, that's why we add one here
			}

			numServersInSd := func() int {
				num := 0

				_, err := e.GetServer(table.server.ID)
				if err == nil {
					num++
				}
				for _, serverToAdd := range table.serversToAdd {
					_, err := e.GetServer(serverToAdd.ID)
					if err == nil {
						num++
					}
				}
				return num
			}

			helpers.ShouldEventuallyReturn(t, numServersInSd, numRequiredServersInSd())
		})
	}
}

func TestParallelGetter(t *testing.T) {
	c, cli := helpers.GetTestEtcd(t)
	defer c.Terminate(t)

	serversToAdd := []*Server{
		NewServer("frontend-1", "type1", true, nil),
		NewServer("frontend-2", "type2", true, nil),
		NewServer("frontend-3", "type3", true, nil),
		NewServer("frontend-4", "type4", true, nil),
		NewServer("frontend-5", "type5", true, nil),
		NewServer("frontend-6", "type6", true, nil),
		NewServer("frontend-7", "type7", true, nil),
		NewServer("frontend-8", "type8", true, nil),
		NewServer("frontend-9", "type9", true, nil),
	}

	// Add server
	for _, serverToAdd := range serversToAdd {
		_, err := cli.Put(
			context.TODO(),
			getKey(serverToAdd.ID, serverToAdd.Type),
			serverToAdd.AsJSONString(),
		)
		assert.NoError(t, err)
	}

	parallelGetter := newParallelGetter(cli, 5)
	for _, serverToAdd := range serversToAdd {
		payload := []byte("{\"id\":\"" + serverToAdd.ID + "\",\"type\":\"" + serverToAdd.Type + "\",\"frontend\":true,\"hostname\":\"" + serverToAdd.ID + "\",\"metadata\":{\"region\":\"us\"}}")
		parallelGetter.addWorkWithPayload(serverToAdd.Type, serverToAdd.ID, payload)
	}

	servers := parallelGetter.waitAndGetResult()
	assert.Equal(t, len(serversToAdd), len(servers))

	// We add the returned servers to a map first, since the results may be out the order they were added.
	serversMap := map[string]*Server{}
	for _, sv := range servers {
		_, ok := serversMap[sv.ID]
		assert.False(t, ok)
		serversMap[sv.ID] = sv
	}

	for _, serverToAdd := range serversToAdd {
		sv, ok := serversMap[serverToAdd.ID]
		assert.True(t, ok)
		assert.Equal(t, serverToAdd.Type, sv.Type)
		assert.Equal(t, serverToAdd.ID, sv.ID)
		assert.Equal(t, serverToAdd.Frontend, sv.Frontend)
	}
}

```

`pkg/cluster/grpc_rpc_client.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package cluster

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	pcontext "github.com/topfreegames/pitaya/v3/pkg/context"
	pitErrors "github.com/topfreegames/pitaya/v3/pkg/errors"
	"github.com/topfreegames/pitaya/v3/pkg/interfaces"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/route"
	"github.com/topfreegames/pitaya/v3/pkg/session"
	"github.com/topfreegames/pitaya/v3/pkg/tracing"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/trace"
	"google.golang.org/grpc"
)

// GRPCClient rpc client struct
type GRPCClient struct {
	bindingStorage   interfaces.BindingStorage
	clientMap        sync.Map
	dialTimeout      time.Duration
	infoRetriever    InfoRetriever
	lazy             bool
	metricsReporters []metrics.Reporter
	reqTimeout       time.Duration
	server           *Server
}

// NewGRPCClient returns a new instance of GRPCClient
func NewGRPCClient(
	config config.GRPCClientConfig,
	server *Server,
	metricsReporters []metrics.Reporter,
	bindingStorage interfaces.BindingStorage,
	infoRetriever InfoRetriever,
) (*GRPCClient, error) {
	gs := &GRPCClient{
		bindingStorage:   bindingStorage,
		infoRetriever:    infoRetriever,
		metricsReporters: metricsReporters,
		server:           server,
	}

	gs.dialTimeout = config.DialTimeout
	gs.lazy = config.LazyConnection
	gs.reqTimeout = config.RequestTimeout

	return gs, nil
}

type grpcClient struct {
	address   string
	cli       protos.PitayaClient
	conn      *grpc.ClientConn
	connected bool
	lock      sync.Mutex
}

// Init inits grpc rpc client
func (gs *GRPCClient) Init() error {
	return nil
}

// Call makes a RPC Call
func (gs *GRPCClient) Call(
	ctx context.Context,
	rpcType protos.RPCType,
	route *route.Route,
	session session.Session,
	msg *message.Message,
	server *Server,
) (*protos.Response, error) {
	c, ok := gs.clientMap.Load(server.ID)
	if !ok {
		return nil, constants.ErrNoConnectionToServer
	}

	parent, err := tracing.ExtractSpan(ctx)
	if err != nil {
		logger.Log.Warnf("[grpc client] failed to retrieve parent span: %s", err.Error())
	}
	ctx = trace.ContextWithRemoteSpanContext(ctx, parent)

	attributes := []attribute.KeyValue{
		attribute.String("span.kind", "client"),
		attribute.String("local.id", gs.server.ID),
		attribute.String("peer.serverType", server.Type),
		attribute.String("peer.id", server.ID),
	}
	ctx, _ = tracing.StartSpan(ctx, "GRPC RPC Call", attributes...)
	defer tracing.FinishSpan(ctx, err)

	if session != nil {
		requestID := uuid.New().String()
		requestInfo := ""
		if route != nil {
			requestInfo = route.Method
		}
		session.SetRequestInFlight(requestID, requestInfo, true)
		defer session.SetRequestInFlight(requestID, "", false)
	}

	ctx = pcontext.AddToPropagateCtx(ctx, constants.RequestTimeout, gs.reqTimeout.String())
	req, err := buildRequest(ctx, rpcType, route, session, msg, gs.server)
	if err != nil {
		return nil, err
	}

	ctxT, done := context.WithTimeout(ctx, gs.reqTimeout)
	defer done()

	if gs.metricsReporters != nil {
		startTime := time.Now()
		ctxT = pcontext.AddToPropagateCtx(ctxT, constants.StartTimeKey, startTime.UnixNano())
		ctxT = pcontext.AddToPropagateCtx(ctxT, constants.RouteKey, route.String())
		defer metrics.ReportTimingFromCtx(ctxT, gs.metricsReporters, "rpc", err)
	}

	res, err := c.(*grpcClient).call(ctxT, &req)
	if err != nil {
		return nil, err
	}
	if res.Error != nil {
		if res.Error.Code == "" {
			res.Error.Code = pitErrors.ErrUnknownCode
		}
		err = &pitErrors.Error{
			Code:     res.Error.Code,
			Message:  res.Error.Msg,
			Metadata: res.Error.Metadata,
		}
		return nil, err
	}
	return res, nil
}

// Send not implemented in grpc client
func (gs *GRPCClient) Send(uid string, d []byte) error {
	return constants.ErrNotImplemented
}

// BroadcastSessionBind sends the binding information to other servers that may be interested in this info
func (gs *GRPCClient) BroadcastSessionBind(uid string) error {
	if gs.bindingStorage == nil {
		return constants.ErrNoBindingStorageModule
	}
	fid, _ := gs.bindingStorage.GetUserFrontendID(uid, gs.server.Type)
	if fid != "" {
		if c, ok := gs.clientMap.Load(fid); ok {
			msg := &protos.BindMsg{
				Uid: uid,
				Fid: gs.server.ID,
			}
			ctxT, done := context.WithTimeout(context.Background(), gs.reqTimeout)
			defer done()
			err := c.(*grpcClient).sessionBindRemote(ctxT, msg)
			return err
		}
	}
	return nil
}

// SendKick sends a kick to an user
func (gs *GRPCClient) SendKick(userID string, serverType string, kick *protos.KickMsg) error {
	var svID string
	var err error

	if gs.bindingStorage == nil {
		return constants.ErrNoBindingStorageModule
	}

	svID, err = gs.bindingStorage.GetUserFrontendID(userID, serverType)
	if err != nil {
		return err
	}

	if c, ok := gs.clientMap.Load(svID); ok {
		ctxT, done := context.WithTimeout(context.Background(), gs.reqTimeout)
		defer done()
		err := c.(*grpcClient).sendKick(ctxT, kick)
		return err
	}
	return constants.ErrNoConnectionToServer
}

// SendPush sends a message to an user, if you dont know the serverID that the user is connected to, you need to set a BindingStorage when creating the client
// TODO: Jaeger?
func (gs *GRPCClient) SendPush(userID string, frontendSv *Server, push *protos.Push) error {
	var svID string
	var err error
	if frontendSv.ID != "" {
		svID = frontendSv.ID
	} else {
		if gs.bindingStorage == nil {
			return constants.ErrNoBindingStorageModule
		}
		svID, err = gs.bindingStorage.GetUserFrontendID(userID, frontendSv.Type)
		if err != nil {
			return err
		}
	}
	if c, ok := gs.clientMap.Load(svID); ok {
		ctxT, done := context.WithTimeout(context.Background(), gs.reqTimeout)
		defer done()
		err := c.(*grpcClient).pushToUser(ctxT, push)
		return err
	}
	return constants.ErrNoConnectionToServer
}

// AddServer is called when a new server is discovered
func (gs *GRPCClient) AddServer(sv *Server) {
	var host, port, portKey string
	var ok bool

	host, portKey = gs.getServerHost(sv)
	if host == "" {
		logger.Log.Errorf("[grpc client] server %s has no grpcHost specified in metadata", sv.ID)
		return
	}

	if port, ok = sv.Metadata[portKey]; !ok {
		logger.Log.Errorf("[grpc client] server %s has no %s specified in metadata", sv.ID, portKey)
		return
	}

	address := fmt.Sprintf("%s:%s", host, port)
	client := &grpcClient{address: address}
	if !gs.lazy {
		if err := client.connect(); err != nil {
			logger.Log.Errorf("[grpc client] unable to connect to server %s at %s: %v", sv.ID, address, err)
		}
	}
	gs.clientMap.Store(sv.ID, client)
	logger.Log.Debugf("[grpc client] added server %s at %s", sv.ID, address)
}

// RemoveServer is called when a server is removed
func (gs *GRPCClient) RemoveServer(sv *Server) {
	if c, ok := gs.clientMap.Load(sv.ID); ok {
		c.(*grpcClient).disconnect()
		gs.clientMap.Delete(sv.ID)
		logger.Log.Debugf("[grpc client] removed server %s", sv.ID)
	}
}

// AfterInit runs after initialization
func (gs *GRPCClient) AfterInit() {}

// BeforeShutdown runs before shutdown
func (gs *GRPCClient) BeforeShutdown() {}

// Shutdown stops grpc rpc server
func (gs *GRPCClient) Shutdown() error {
	return nil
}

func (gs *GRPCClient) getServerHost(sv *Server) (host, portKey string) {
	var (
		serverRegion, hasRegion   = sv.Metadata[constants.RegionKey]
		externalHost, hasExternal = sv.Metadata[constants.GRPCExternalHostKey]
		internalHost, _           = sv.Metadata[constants.GRPCHostKey]
	)

	hasRegion = hasRegion && serverRegion != ""
	hasExternal = hasExternal && externalHost != ""

	if !hasRegion {
		if hasExternal {
			logger.Log.Warnf("[grpc client] server %s has no region specified in metadata, using external host", sv.ID)
			return externalHost, constants.GRPCExternalPortKey
		}

		logger.Log.Warnf("[grpc client] server %s has no region nor external host specified in metadata, using internal host", sv.ID)
		return internalHost, constants.GRPCPortKey
	}

	if gs.infoRetriever.Region() == serverRegion || !hasExternal {
		logger.Log.Infof("[grpc client] server %s is in same region or external host not provided, using internal host", sv.ID)
		return internalHost, constants.GRPCPortKey
	}

	logger.Log.Infof("[grpc client] server %s is in other region, using external host", sv.ID)
	return externalHost, constants.GRPCExternalPortKey
}

func (gc *grpcClient) connect() error {
	gc.lock.Lock()
	defer gc.lock.Unlock()
	if gc.connected {
		return nil
	}

	conn, err := grpc.Dial(
		gc.address,
		grpc.WithInsecure(),
	)
	if err != nil {
		return err
	}
	c := protos.NewPitayaClient(conn)
	gc.cli = c
	gc.conn = conn
	gc.connected = true
	return nil
}

func (gc *grpcClient) disconnect() {
	gc.lock.Lock()
	if gc.connected {
		gc.conn.Close()
		gc.connected = false
	}
	gc.lock.Unlock()
}

func (gc *grpcClient) pushToUser(ctx context.Context, push *protos.Push) error {
	if !gc.connected {
		if err := gc.connect(); err != nil {
			return err
		}
	}
	_, err := gc.cli.PushToUser(ctx, push)
	return err
}

func (gc *grpcClient) call(ctx context.Context, req *protos.Request) (*protos.Response, error) {
	if !gc.connected {
		if err := gc.connect(); err != nil {
			return nil, err
		}
	}
	return gc.cli.Call(ctx, req)
}

func (gc *grpcClient) sessionBindRemote(ctx context.Context, req *protos.BindMsg) error {
	if !gc.connected {
		if err := gc.connect(); err != nil {
			return err
		}
	}
	_, err := gc.cli.SessionBindRemote(ctx, req)
	return err
}

func (gc *grpcClient) sendKick(ctx context.Context, req *protos.KickMsg) error {
	if !gc.connected {
		if err := gc.connect(); err != nil {
			return err
		}
	}
	_, err := gc.cli.KickUser(ctx, req)
	return err
}

```

`pkg/cluster/grpc_rpc_client_test.go`:

```go
package cluster

import (
	"context"
	"fmt"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/helpers"
	"github.com/topfreegames/pitaya/v3/pkg/interfaces"
	"github.com/topfreegames/pitaya/v3/pkg/interfaces/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	protosmocks "github.com/topfreegames/pitaya/v3/pkg/protos/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/route"
	sessionmocks "github.com/topfreegames/pitaya/v3/pkg/session/mocks"
	"google.golang.org/grpc"
)

func getRPCClient(c config.GRPCClientConfig) (*GRPCClient, error) {
	sv := getServer()
	return NewGRPCClient(c, sv, []metrics.Reporter{}, nil, nil)
}

func TestNewGRPCClient(t *testing.T) {
	c := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Grpc
	g, err := getRPCClient(c)
	assert.NoError(t, err)
	assert.NotNil(t, g)
}

func TestCall(t *testing.T) {
	c := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Grpc
	g, err := getRPCClient(c)
	assert.NoError(t, err)
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockPitayaClient := protosmocks.NewMockPitayaClient(ctrl)
	g.clientMap.Store(g.server.ID, &grpcClient{
		cli:       mockPitayaClient,
		connected: true,
	})

	uid := "someuid"
	msg := &message.Message{
		Type:  0,
		ID:    0,
		Route: "sv.svc.meth",
		Data:  []byte{0x01},
		Err:   false,
	}

	ctx := context.Background()
	rpcType := protos.RPCType_Sys
	r := route.NewRoute("sv", "svc", "meth")

	sess := sessionmocks.NewMockSession(ctrl)
	sess.EXPECT().ID().Return(int64(1)).Times(2)
	sess.EXPECT().UID().Return(uid).Times(2)
	sess.EXPECT().GetDataEncoded().Return(nil).Times(2)
	sess.EXPECT().SetRequestInFlight(gomock.Any(), gomock.Any(), gomock.Any()).Times(2)

	expected, err := buildRequest(ctx, rpcType, r, sess, msg, g.server)
	assert.NoError(t, err)

	mockPitayaClient.EXPECT().Call(gomock.Any(), gomock.Any()).DoAndReturn(func(ctx context.Context, in *protos.Request, opts ...grpc.CallOption) (*protos.Response, error) {
		assert.Equal(t, expected.FrontendID, in.FrontendID)
		assert.Equal(t, expected.Type, in.Type)
		assert.Equal(t, expected.Msg, in.Msg)
		return &protos.Response{
			Data:  []byte{0x01},
			Error: nil,
		}, nil
	})

	res, err := g.Call(ctx, rpcType, r, sess, msg, g.server)

	assert.NoError(t, err)
	assert.NotNil(t, res)
}

func TestBroadcastSessionBind(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockBindingStorage := mocks.NewMockBindingStorage(ctrl)
	mockPitayaClient := protosmocks.NewMockPitayaClient(ctrl)
	tables := []struct {
		name           string
		bindingStorage interfaces.BindingStorage
		err            error
	}{{"shouldrun", mockBindingStorage, nil}, {"shoulderror", nil, constants.ErrNoBindingStorageModule}}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			c := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Grpc
			g, err := getRPCClient(c)
			assert.NoError(t, err)
			uid := "someuid"
			//mockPitayaClient := protosmocks.NewMockPitayaClient(ctrl)

			if table.bindingStorage != nil {
				g.clientMap.Store(g.server.ID, &grpcClient{connected: true, cli: mockPitayaClient})

				g.bindingStorage = mockBindingStorage
				mockBindingStorage.EXPECT().GetUserFrontendID(uid, gomock.Any()).DoAndReturn(func(u, svType string) (string, error) {
					assert.Equal(t, uid, u)
					assert.Equal(t, g.server.Type, svType)

					return g.server.ID, nil
				})

				mockPitayaClient.EXPECT().SessionBindRemote(gomock.Any(), gomock.Any()).Do(func(ctx context.Context, msg *protos.BindMsg, opts ...grpc.CallOption) {
					assert.Equal(t, uid, msg.Uid, g.server.ID, msg.Fid)
				})
			}

			err = g.BroadcastSessionBind(uid)
			if table.err != nil {
				assert.EqualError(t, err, table.err.Error())
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestSendKick(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockBindingStorage := mocks.NewMockBindingStorage(ctrl)
	mockPitayaClient := protosmocks.NewMockPitayaClient(ctrl)
	tables := []struct {
		name           string
		userID         string
		bindingStorage interfaces.BindingStorage
		sv             *Server
		err            error
	}{
		{"bindingstorage", "uid", mockBindingStorage, &Server{
			Type:     "tp",
			Frontend: true}, nil,
		},
		{"nobindingstorage", "uid", nil, &Server{
			Type:     "tp",
			Frontend: true,
		}, constants.ErrNoBindingStorageModule},
		{"nobindingstorage", "", mockBindingStorage, &Server{
			Type:     "tp",
			Frontend: true,
		}, nil},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			c := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Grpc
			g, err := getRPCClient(c)
			assert.NoError(t, err)

			if table.bindingStorage != nil {
				g.clientMap.Store(table.sv.ID, &grpcClient{connected: true, cli: mockPitayaClient})
				g.bindingStorage = table.bindingStorage
				mockBindingStorage.EXPECT().GetUserFrontendID(table.userID, gomock.Any()).DoAndReturn(func(u, svType string) (string, error) {
					assert.Equal(t, table.userID, u)
					assert.Equal(t, table.sv.Type, svType)
					return table.sv.ID, nil
				})

				mockPitayaClient.EXPECT().KickUser(gomock.Any(), gomock.Any()).Do(func(ctx context.Context, msg *protos.KickMsg, opts ...grpc.CallOption) {
					assert.Equal(t, table.userID, msg.UserId)
				})
			}

			kick := &protos.KickMsg{
				UserId: table.userID,
			}

			err = g.SendKick(table.userID, table.sv.Type, kick)
			if table.err != nil {
				assert.Equal(t, err, table.err)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestSendPush(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockBindingStorage := mocks.NewMockBindingStorage(ctrl)
	mockPitayaClient := protosmocks.NewMockPitayaClient(ctrl)
	tables := []struct {
		name           string
		bindingStorage interfaces.BindingStorage
		sv             *Server
		err            error
	}{
		{"bindingstorage-no-fid", mockBindingStorage, &Server{
			Type:     "tp",
			Frontend: true,
		}, nil},
		{"nobindingstorage-no-fid", nil, &Server{
			Type:     "tp",
			Frontend: true,
		}, constants.ErrNoBindingStorageModule},
		{"nobindingstorage-fid", nil, &Server{
			ID:       "someID",
			Type:     "tp",
			Frontend: true,
		}, nil},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			g, err := getRPCClient(config.NewDefaultPitayaConfig().Cluster.RPC.Client.Grpc)
			assert.NoError(t, err)
			uid := "someuid"

			if table.bindingStorage != nil && table.sv.ID == "" {
				g.clientMap.Store(table.sv.ID, &grpcClient{connected: true, cli: mockPitayaClient})
				g.bindingStorage = table.bindingStorage
				mockBindingStorage.EXPECT().GetUserFrontendID(uid, gomock.Any()).DoAndReturn(func(u, svType string) (string, error) {
					assert.Equal(t, uid, u)
					assert.Equal(t, table.sv.Type, svType)
					return table.sv.ID, nil
				})

				mockPitayaClient.EXPECT().PushToUser(gomock.Any(), gomock.Any()).Do(func(ctx context.Context, msg *protos.Push, opts ...grpc.CallOption) {
					assert.Equal(t, uid, msg.Uid)
					assert.Equal(t, msg.Route, "sv.svc.mth")
					assert.Equal(t, msg.Data, []byte{0x01})
				})
			} else if table.bindingStorage == nil && table.sv.ID != "" {
				g.clientMap.Store(table.sv.ID, &grpcClient{connected: true, cli: mockPitayaClient})
				mockPitayaClient.EXPECT().PushToUser(gomock.Any(), gomock.Any()).Do(func(ctx context.Context, msg *protos.Push, opts ...grpc.CallOption) {
					assert.Equal(t, uid, msg.Uid)
					assert.Equal(t, msg.Route, "sv.svc.mth")
					assert.Equal(t, msg.Data, []byte{0x01})
				})
			}

			push := &protos.Push{
				Route: "sv.svc.mth",
				Uid:   uid,
				Data:  []byte{0x01},
			}

			err = g.SendPush(uid, table.sv, push)

			if table.err != nil {
				assert.EqualError(t, err, table.err.Error())
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestAddServer(t *testing.T) {
	t.Run("try-connect", func(t *testing.T) {
		// listen
		clientConfig := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Grpc

		serverConfig := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Grpc
		serverConfig.Port = helpers.GetFreePort(t)
		ctrl := gomock.NewController(t)
		defer ctrl.Finish()

		server := &Server{
			ID:   "someid",
			Type: "sometype",
			Metadata: map[string]string{
				constants.GRPCHostKey: "localhost",
				constants.GRPCPortKey: fmt.Sprintf("%d", serverConfig.Port),
			},
			Frontend: false,
		}
		gs, err := NewGRPCServer(serverConfig, server, []metrics.Reporter{})
		assert.NoError(t, err)

		mockPitayaServer := protosmocks.NewMockPitayaServer(ctrl)
		gs.SetPitayaServer(mockPitayaServer)

		err = gs.Init()
		assert.NoError(t, err)
		// --- should connect to the server and add it to the client map
		g, err := getRPCClient(clientConfig)
		assert.NoError(t, err)
		g.AddServer(server)

		sv, ok := g.clientMap.Load(server.ID)
		assert.NotNil(t, sv)
		assert.True(t, ok)
		cli := sv.(*grpcClient)
		assert.True(t, cli.connected)
		assert.NotNil(t, cli.cli)
	})

	t.Run("lazy", func(t *testing.T) {
		// listen
		clientConfig := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Grpc
		clientConfig.LazyConnection = true

		serverConfig := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Grpc
		serverConfig.Port = helpers.GetFreePort(t)

		ctrl := gomock.NewController(t)
		defer ctrl.Finish()

		server := &Server{
			ID:   "someid",
			Type: "sometype",
			Metadata: map[string]string{
				constants.GRPCHostKey: "localhost",
				constants.GRPCPortKey: fmt.Sprintf("%d", serverConfig.Port),
			},
			Frontend: false,
		}
		gs, err := NewGRPCServer(serverConfig, server, []metrics.Reporter{})
		assert.NoError(t, err)

		mockPitayaServer := protosmocks.NewMockPitayaServer(ctrl)
		gs.SetPitayaServer(mockPitayaServer)

		err = gs.Init()
		assert.NoError(t, err)
		g, err := getRPCClient(clientConfig)
		assert.NoError(t, err)
		// --- should not connect to the server and add it to the client map
		g.AddServer(server)

		sv, ok := g.clientMap.Load(server.ID)
		assert.NotNil(t, sv)
		assert.True(t, ok)
		cli := sv.(*grpcClient)
		assert.False(t, cli.connected)
		assert.Nil(t, cli.cli)
	})
}

func TestGetServerHost(t *testing.T) {
	t.Parallel()

	var (
		host         = "host"
		externalHost = "externalHost"
		region       = "region"
	)

	tables := map[string]struct {
		metadata        map[string]string
		clientRegion    string
		expectedHost    string
		expectedPortKey string
	}{
		"test_has_no_region_and_no_external_host": {
			metadata: map[string]string{
				constants.GRPCHostKey: host,
			},
			expectedHost:    host,
			expectedPortKey: constants.GRPCPortKey,
		},
		"test_has_no_region_and_external_host": {
			metadata: map[string]string{
				constants.GRPCExternalHostKey: externalHost,
			},
			expectedHost:    externalHost,
			expectedPortKey: constants.GRPCExternalPortKey,
		},
		"test_has_region_and_same_region": {
			metadata: map[string]string{
				constants.GRPCHostKey: host,
				constants.RegionKey:   region,
			},
			clientRegion:    region,
			expectedHost:    host,
			expectedPortKey: constants.GRPCPortKey,
		},
		"test_has_region_and_other_region": {
			metadata: map[string]string{
				constants.GRPCExternalHostKey: externalHost,
				constants.RegionKey:           region,
			},
			clientRegion:    "other-region",
			expectedHost:    externalHost,
			expectedPortKey: constants.GRPCExternalPortKey,
		},
	}

	for name, table := range tables {
		t.Run(name, func(t *testing.T) {
			config := config.NewDefaultPitayaConfig().Cluster.Info
			config.Region = table.clientRegion
			infoRetriever := NewInfoRetriever(config)
			gs := &GRPCClient{infoRetriever: infoRetriever}

			host, portKey := gs.getServerHost(&Server{
				Metadata: table.metadata,
			})

			assert.Equal(t, table.expectedHost, host)
			assert.Equal(t, table.expectedPortKey, portKey)
		})
	}
}

func TestRemoveServer(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	clientConfig := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Grpc

	serverConfig := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Grpc
	serverConfig.Port = helpers.GetFreePort(t)

	server := &Server{
		ID:   "someid",
		Type: "sometype",
		Metadata: map[string]string{
			constants.GRPCHostKey: "localhost",
			constants.GRPCPortKey: fmt.Sprintf("%d", serverConfig.Port),
		},
		Frontend: false,
	}
	gs, err := NewGRPCServer(serverConfig, server, []metrics.Reporter{})
	assert.NoError(t, err)
	mockPitayaServer := protosmocks.NewMockPitayaServer(ctrl)
	gs.SetPitayaServer(mockPitayaServer)
	err = gs.Init()
	assert.NoError(t, err)

	gc, err := NewGRPCClient(clientConfig, server, []metrics.Reporter{}, nil, nil)
	assert.NoError(t, err)
	gc.AddServer(server)

	sv, ok := gc.clientMap.Load(server.ID)
	assert.NotNil(t, sv)
	assert.True(t, ok)

	gc.RemoveServer(server)

	sv, ok = gc.clientMap.Load(server.ID)
	assert.Nil(t, sv)
	assert.False(t, ok)
}

```

`pkg/cluster/grpc_rpc_server.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package cluster

import (
	"fmt"
	"net"

	"google.golang.org/grpc"

	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
)

// GRPCServer rpc server struct
type GRPCServer struct {
	server           *Server
	port             int
	metricsReporters []metrics.Reporter
	grpcSv           *grpc.Server
	pitayaServer     protos.PitayaServer
}

// NewGRPCServer constructor
func NewGRPCServer(config config.GRPCServerConfig, server *Server, metricsReporters []metrics.Reporter) (*GRPCServer, error) {
	gs := &GRPCServer{
		port:             config.Port,
		server:           server,
		metricsReporters: metricsReporters,
	}
	return gs, nil
}

// Init inits grpc rpc server
func (gs *GRPCServer) Init() error {
	port := gs.port
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
	if err != nil {
		return err
	}
	gs.grpcSv = grpc.NewServer()
	protos.RegisterPitayaServer(gs.grpcSv, gs.pitayaServer)
	go gs.grpcSv.Serve(lis)
	return nil
}

// SetPitayaServer sets the pitaya server
func (gs *GRPCServer) SetPitayaServer(ps protos.PitayaServer) {
	gs.pitayaServer = ps
}

// AfterInit runs after initialization
func (gs *GRPCServer) AfterInit() {}

// BeforeShutdown runs before shutdown
func (gs *GRPCServer) BeforeShutdown() {}

// Shutdown stops grpc rpc server
func (gs *GRPCServer) Shutdown() error {
	// graceful: stops the server from accepting new connections and RPCs and
	// blocks until all the pending RPCs are finished.
	// source: https://godoc.org/google.golang.org/grpc#Server.GracefulStop
	gs.grpcSv.GracefulStop()
	return nil
}

```

`pkg/cluster/grpc_rpc_server_test.go`:

```go
package cluster

import (
	"fmt"
	"net"
	"testing"

	"github.com/golang/mock/gomock"

	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/helpers"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
	protosmocks "github.com/topfreegames/pitaya/v3/pkg/protos/mocks"
)

func TestNewGRPCServer(t *testing.T) {
	t.Parallel()
	sv := getServer()
	gs, err := NewGRPCServer(config.NewDefaultPitayaConfig().Cluster.RPC.Server.Grpc, sv, []metrics.Reporter{})
	assert.NoError(t, err)
	assert.NotNil(t, gs)
}

func TestGRPCServerInit(t *testing.T) {
	t.Parallel()
	c := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Grpc
	c.Port = helpers.GetFreePort(t)
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockPitayaServer := protosmocks.NewMockPitayaServer(ctrl)

	sv := getServer()
	gs, err := NewGRPCServer(c, sv, []metrics.Reporter{})
	assert.NoError(t, err)
	gs.SetPitayaServer(mockPitayaServer)
	err = gs.Init()
	assert.NoError(t, err)
	assert.NotNil(t, gs)

	conn, err := net.Dial("tcp", fmt.Sprintf("127.0.0.1:%d", c.Port))
	assert.NoError(t, err)
	assert.NotNil(t, conn)
	assert.NotNil(t, gs.grpcSv)
}

```

`pkg/cluster/info_retriever.go`:

```go
package cluster

import "github.com/topfreegames/pitaya/v3/pkg/config"

// infoRetriever gets cluster info from config
// Implements InfoRetriever interface
type infoRetriever struct {
	region string
}

// NewInfoRetriever returns a *infoRetriever
func NewInfoRetriever(config config.InfoRetrieverConfig) InfoRetriever {
	return &infoRetriever{
		region: config.Region,
	}
}

// Region gets server's region from config
func (c *infoRetriever) Region() string {
	return c.region
}

```

`pkg/cluster/info_retriever_test.go`:

```go
package cluster

import (
	"testing"

	"github.com/spf13/viper"
	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/config"
)

func TestInfoRetrieverRegion(t *testing.T) {
	t.Parallel()

	c := viper.New()
	c.Set("pitaya.cluster.info.region", "us")
	conf := config.NewConfig(c)

	infoRetriever := NewInfoRetriever(*&config.NewPitayaConfig(conf).Cluster.Info)

	assert.Equal(t, "us", infoRetriever.Region())
}

```

`pkg/cluster/mocks/cluster.go`:

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: cluster/cluster.go

// Package mock_cluster is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	cluster "github.com/topfreegames/pitaya/v3/pkg/cluster"
	message "github.com/topfreegames/pitaya/v3/pkg/conn/message"
	protos "github.com/topfreegames/pitaya/v3/pkg/protos"
	route "github.com/topfreegames/pitaya/v3/pkg/route"
	session "github.com/topfreegames/pitaya/v3/pkg/session"
)

// MockRPCServer is a mock of RPCServer interface.
type MockRPCServer struct {
	ctrl     *gomock.Controller
	recorder *MockRPCServerMockRecorder
}

// MockRPCServerMockRecorder is the mock recorder for MockRPCServer.
type MockRPCServerMockRecorder struct {
	mock *MockRPCServer
}

// NewMockRPCServer creates a new mock instance.
func NewMockRPCServer(ctrl *gomock.Controller) *MockRPCServer {
	mock := &MockRPCServer{ctrl: ctrl}
	mock.recorder = &MockRPCServerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRPCServer) EXPECT() *MockRPCServerMockRecorder {
	return m.recorder
}

// AfterInit mocks base method.
func (m *MockRPCServer) AfterInit() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AfterInit")
}

// AfterInit indicates an expected call of AfterInit.
func (mr *MockRPCServerMockRecorder) AfterInit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AfterInit", reflect.TypeOf((*MockRPCServer)(nil).AfterInit))
}

// BeforeShutdown mocks base method.
func (m *MockRPCServer) BeforeShutdown() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "BeforeShutdown")
}

// BeforeShutdown indicates an expected call of BeforeShutdown.
func (mr *MockRPCServerMockRecorder) BeforeShutdown() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeforeShutdown", reflect.TypeOf((*MockRPCServer)(nil).BeforeShutdown))
}

// Init mocks base method.
func (m *MockRPCServer) Init() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Init")
	ret0, _ := ret[0].(error)
	return ret0
}

// Init indicates an expected call of Init.
func (mr *MockRPCServerMockRecorder) Init() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*MockRPCServer)(nil).Init))
}

// SetPitayaServer mocks base method.
func (m *MockRPCServer) SetPitayaServer(arg0 protos.PitayaServer) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetPitayaServer", arg0)
}

// SetPitayaServer indicates an expected call of SetPitayaServer.
func (mr *MockRPCServerMockRecorder) SetPitayaServer(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetPitayaServer", reflect.TypeOf((*MockRPCServer)(nil).SetPitayaServer), arg0)
}

// Shutdown mocks base method.
func (m *MockRPCServer) Shutdown() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Shutdown")
	ret0, _ := ret[0].(error)
	return ret0
}

// Shutdown indicates an expected call of Shutdown.
func (mr *MockRPCServerMockRecorder) Shutdown() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Shutdown", reflect.TypeOf((*MockRPCServer)(nil).Shutdown))
}

// MockRPCClient is a mock of RPCClient interface.
type MockRPCClient struct {
	ctrl     *gomock.Controller
	recorder *MockRPCClientMockRecorder
}

// MockRPCClientMockRecorder is the mock recorder for MockRPCClient.
type MockRPCClientMockRecorder struct {
	mock *MockRPCClient
}

// NewMockRPCClient creates a new mock instance.
func NewMockRPCClient(ctrl *gomock.Controller) *MockRPCClient {
	mock := &MockRPCClient{ctrl: ctrl}
	mock.recorder = &MockRPCClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRPCClient) EXPECT() *MockRPCClientMockRecorder {
	return m.recorder
}

// AfterInit mocks base method.
func (m *MockRPCClient) AfterInit() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AfterInit")
}

// AfterInit indicates an expected call of AfterInit.
func (mr *MockRPCClientMockRecorder) AfterInit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AfterInit", reflect.TypeOf((*MockRPCClient)(nil).AfterInit))
}

// BeforeShutdown mocks base method.
func (m *MockRPCClient) BeforeShutdown() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "BeforeShutdown")
}

// BeforeShutdown indicates an expected call of BeforeShutdown.
func (mr *MockRPCClientMockRecorder) BeforeShutdown() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeforeShutdown", reflect.TypeOf((*MockRPCClient)(nil).BeforeShutdown))
}

// BroadcastSessionBind mocks base method.
func (m *MockRPCClient) BroadcastSessionBind(uid string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BroadcastSessionBind", uid)
	ret0, _ := ret[0].(error)
	return ret0
}

// BroadcastSessionBind indicates an expected call of BroadcastSessionBind.
func (mr *MockRPCClientMockRecorder) BroadcastSessionBind(uid interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BroadcastSessionBind", reflect.TypeOf((*MockRPCClient)(nil).BroadcastSessionBind), uid)
}

// Call mocks base method.
func (m *MockRPCClient) Call(ctx context.Context, rpcType protos.RPCType, route *route.Route, session session.Session, msg *message.Message, server *cluster.Server) (*protos.Response, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Call", ctx, rpcType, route, session, msg, server)
	ret0, _ := ret[0].(*protos.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Call indicates an expected call of Call.
func (mr *MockRPCClientMockRecorder) Call(ctx, rpcType, route, session, msg, server interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Call", reflect.TypeOf((*MockRPCClient)(nil).Call), ctx, rpcType, route, session, msg, server)
}

// Init mocks base method.
func (m *MockRPCClient) Init() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Init")
	ret0, _ := ret[0].(error)
	return ret0
}

// Init indicates an expected call of Init.
func (mr *MockRPCClientMockRecorder) Init() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*MockRPCClient)(nil).Init))
}

// Send mocks base method.
func (m *MockRPCClient) Send(route string, data []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Send", route, data)
	ret0, _ := ret[0].(error)
	return ret0
}

// Send indicates an expected call of Send.
func (mr *MockRPCClientMockRecorder) Send(route, data interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Send", reflect.TypeOf((*MockRPCClient)(nil).Send), route, data)
}

// SendKick mocks base method.
func (m *MockRPCClient) SendKick(userID, serverType string, kick *protos.KickMsg) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendKick", userID, serverType, kick)
	ret0, _ := ret[0].(error)
	return ret0
}

// SendKick indicates an expected call of SendKick.
func (mr *MockRPCClientMockRecorder) SendKick(userID, serverType, kick interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendKick", reflect.TypeOf((*MockRPCClient)(nil).SendKick), userID, serverType, kick)
}

// SendPush mocks base method.
func (m *MockRPCClient) SendPush(userID string, frontendSv *cluster.Server, push *protos.Push) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendPush", userID, frontendSv, push)
	ret0, _ := ret[0].(error)
	return ret0
}

// SendPush indicates an expected call of SendPush.
func (mr *MockRPCClientMockRecorder) SendPush(userID, frontendSv, push interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendPush", reflect.TypeOf((*MockRPCClient)(nil).SendPush), userID, frontendSv, push)
}

// Shutdown mocks base method.
func (m *MockRPCClient) Shutdown() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Shutdown")
	ret0, _ := ret[0].(error)
	return ret0
}

// Shutdown indicates an expected call of Shutdown.
func (mr *MockRPCClientMockRecorder) Shutdown() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Shutdown", reflect.TypeOf((*MockRPCClient)(nil).Shutdown))
}

// MockSDListener is a mock of SDListener interface.
type MockSDListener struct {
	ctrl     *gomock.Controller
	recorder *MockSDListenerMockRecorder
}

// MockSDListenerMockRecorder is the mock recorder for MockSDListener.
type MockSDListenerMockRecorder struct {
	mock *MockSDListener
}

// NewMockSDListener creates a new mock instance.
func NewMockSDListener(ctrl *gomock.Controller) *MockSDListener {
	mock := &MockSDListener{ctrl: ctrl}
	mock.recorder = &MockSDListenerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSDListener) EXPECT() *MockSDListenerMockRecorder {
	return m.recorder
}

// AddServer mocks base method.
func (m *MockSDListener) AddServer(arg0 *cluster.Server) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddServer", arg0)
}

// AddServer indicates an expected call of AddServer.
func (mr *MockSDListenerMockRecorder) AddServer(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddServer", reflect.TypeOf((*MockSDListener)(nil).AddServer), arg0)
}

// RemoveServer mocks base method.
func (m *MockSDListener) RemoveServer(arg0 *cluster.Server) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RemoveServer", arg0)
}

// RemoveServer indicates an expected call of RemoveServer.
func (mr *MockSDListenerMockRecorder) RemoveServer(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveServer", reflect.TypeOf((*MockSDListener)(nil).RemoveServer), arg0)
}

// MockRemoteBindingListener is a mock of RemoteBindingListener interface.
type MockRemoteBindingListener struct {
	ctrl     *gomock.Controller
	recorder *MockRemoteBindingListenerMockRecorder
}

// MockRemoteBindingListenerMockRecorder is the mock recorder for MockRemoteBindingListener.
type MockRemoteBindingListenerMockRecorder struct {
	mock *MockRemoteBindingListener
}

// NewMockRemoteBindingListener creates a new mock instance.
func NewMockRemoteBindingListener(ctrl *gomock.Controller) *MockRemoteBindingListener {
	mock := &MockRemoteBindingListener{ctrl: ctrl}
	mock.recorder = &MockRemoteBindingListenerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRemoteBindingListener) EXPECT() *MockRemoteBindingListenerMockRecorder {
	return m.recorder
}

// OnUserBind mocks base method.
func (m *MockRemoteBindingListener) OnUserBind(uid, fid string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "OnUserBind", uid, fid)
}

// OnUserBind indicates an expected call of OnUserBind.
func (mr *MockRemoteBindingListenerMockRecorder) OnUserBind(uid, fid interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnUserBind", reflect.TypeOf((*MockRemoteBindingListener)(nil).OnUserBind), uid, fid)
}

// MockInfoRetriever is a mock of InfoRetriever interface.
type MockInfoRetriever struct {
	ctrl     *gomock.Controller
	recorder *MockInfoRetrieverMockRecorder
}

// MockInfoRetrieverMockRecorder is the mock recorder for MockInfoRetriever.
type MockInfoRetrieverMockRecorder struct {
	mock *MockInfoRetriever
}

// NewMockInfoRetriever creates a new mock instance.
func NewMockInfoRetriever(ctrl *gomock.Controller) *MockInfoRetriever {
	mock := &MockInfoRetriever{ctrl: ctrl}
	mock.recorder = &MockInfoRetrieverMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInfoRetriever) EXPECT() *MockInfoRetrieverMockRecorder {
	return m.recorder
}

// Region mocks base method.
func (m *MockInfoRetriever) Region() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Region")
	ret0, _ := ret[0].(string)
	return ret0
}

// Region indicates an expected call of Region.
func (mr *MockInfoRetrieverMockRecorder) Region() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Region", reflect.TypeOf((*MockInfoRetriever)(nil).Region))
}

```

`pkg/cluster/mocks/service_discovery.go`:

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: cluster/service_discovery.go

// Package mock_cluster is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	cluster "github.com/topfreegames/pitaya/v3/pkg/cluster"
)

// MockServiceDiscovery is a mock of ServiceDiscovery interface.
type MockServiceDiscovery struct {
	ctrl     *gomock.Controller
	recorder *MockServiceDiscoveryMockRecorder
}

// MockServiceDiscoveryMockRecorder is the mock recorder for MockServiceDiscovery.
type MockServiceDiscoveryMockRecorder struct {
	mock *MockServiceDiscovery
}

// NewMockServiceDiscovery creates a new mock instance.
func NewMockServiceDiscovery(ctrl *gomock.Controller) *MockServiceDiscovery {
	mock := &MockServiceDiscovery{ctrl: ctrl}
	mock.recorder = &MockServiceDiscoveryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockServiceDiscovery) EXPECT() *MockServiceDiscoveryMockRecorder {
	return m.recorder
}

// AddListener mocks base method.
func (m *MockServiceDiscovery) AddListener(listener cluster.SDListener) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddListener", listener)
}

// AddListener indicates an expected call of AddListener.
func (mr *MockServiceDiscoveryMockRecorder) AddListener(listener interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddListener", reflect.TypeOf((*MockServiceDiscovery)(nil).AddListener), listener)
}

// AfterInit mocks base method.
func (m *MockServiceDiscovery) AfterInit() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AfterInit")
}

// AfterInit indicates an expected call of AfterInit.
func (mr *MockServiceDiscoveryMockRecorder) AfterInit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AfterInit", reflect.TypeOf((*MockServiceDiscovery)(nil).AfterInit))
}

// BeforeShutdown mocks base method.
func (m *MockServiceDiscovery) BeforeShutdown() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "BeforeShutdown")
}

// BeforeShutdown indicates an expected call of BeforeShutdown.
func (mr *MockServiceDiscoveryMockRecorder) BeforeShutdown() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeforeShutdown", reflect.TypeOf((*MockServiceDiscovery)(nil).BeforeShutdown))
}

// GetServer mocks base method.
func (m *MockServiceDiscovery) GetServer(id string) (*cluster.Server, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetServer", id)
	ret0, _ := ret[0].(*cluster.Server)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetServer indicates an expected call of GetServer.
func (mr *MockServiceDiscoveryMockRecorder) GetServer(id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetServer", reflect.TypeOf((*MockServiceDiscovery)(nil).GetServer), id)
}

// GetServers mocks base method.
func (m *MockServiceDiscovery) GetServers() []*cluster.Server {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetServers")
	ret0, _ := ret[0].([]*cluster.Server)
	return ret0
}

// GetServers indicates an expected call of GetServers.
func (mr *MockServiceDiscoveryMockRecorder) GetServers() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetServers", reflect.TypeOf((*MockServiceDiscovery)(nil).GetServers))
}

// GetServersByType mocks base method.
func (m *MockServiceDiscovery) GetServersByType(serverType string) (map[string]*cluster.Server, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetServersByType", serverType)
	ret0, _ := ret[0].(map[string]*cluster.Server)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetServersByType indicates an expected call of GetServersByType.
func (mr *MockServiceDiscoveryMockRecorder) GetServersByType(serverType interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetServersByType", reflect.TypeOf((*MockServiceDiscovery)(nil).GetServersByType), serverType)
}

// Init mocks base method.
func (m *MockServiceDiscovery) Init() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Init")
	ret0, _ := ret[0].(error)
	return ret0
}

// Init indicates an expected call of Init.
func (mr *MockServiceDiscoveryMockRecorder) Init() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*MockServiceDiscovery)(nil).Init))
}

// IsConnected mocks base method.
func (m *MockServiceDiscovery) IsConnected(arg0 context.Context) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsConnected", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsConnected indicates an expected call of IsConnected.
func (mr *MockServiceDiscoveryMockRecorder) IsConnected(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsConnected", reflect.TypeOf((*MockServiceDiscovery)(nil).IsConnected), arg0)
}

// Shutdown mocks base method.
func (m *MockServiceDiscovery) Shutdown() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Shutdown")
	ret0, _ := ret[0].(error)
	return ret0
}

// Shutdown indicates an expected call of Shutdown.
func (mr *MockServiceDiscoveryMockRecorder) Shutdown() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Shutdown", reflect.TypeOf((*MockServiceDiscovery)(nil).Shutdown))
}

// SyncServers mocks base method.
func (m *MockServiceDiscovery) SyncServers(firstSync bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SyncServers", firstSync)
	ret0, _ := ret[0].(error)
	return ret0
}

// SyncServers indicates an expected call of SyncServers.
func (mr *MockServiceDiscoveryMockRecorder) SyncServers(firstSync interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SyncServers", reflect.TypeOf((*MockServiceDiscovery)(nil).SyncServers), firstSync)
}

```

`pkg/cluster/nats_rpc_client.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package cluster

import (
	"context"
	"fmt"
	"time"

	"github.com/golang/protobuf/proto"
	"github.com/google/uuid"
	nats "github.com/nats-io/nats.go"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	pcontext "github.com/topfreegames/pitaya/v3/pkg/context"
	"github.com/topfreegames/pitaya/v3/pkg/errors"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/route"
	"github.com/topfreegames/pitaya/v3/pkg/session"
	"github.com/topfreegames/pitaya/v3/pkg/tracing"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/trace"
)

// NatsRPCClient struct
type NatsRPCClient struct {
	conn                   *nats.Conn
	connString             string
	connectionTimeout      time.Duration
	maxReconnectionRetries int
	reqTimeout             time.Duration
	running                bool
	server                 *Server
	metricsReporters       []metrics.Reporter
	appDieChan             chan bool
	websocketCompression   bool
	reconnectJitter        time.Duration
	reconnectJitterTLS     time.Duration
	reconnectWait          time.Duration
	pingInterval           time.Duration
	maxPingsOutstanding    int
}

// NewNatsRPCClient ctor
func NewNatsRPCClient(
	config config.NatsRPCClientConfig,
	server *Server,
	metricsReporters []metrics.Reporter,
	appDieChan chan bool,
) (*NatsRPCClient, error) {
	ns := &NatsRPCClient{
		server:            server,
		running:           false,
		metricsReporters:  metricsReporters,
		appDieChan:        appDieChan,
		connectionTimeout: nats.DefaultTimeout,
	}
	if err := ns.configure(config); err != nil {
		return nil, err
	}
	return ns, nil
}

func (ns *NatsRPCClient) configure(config config.NatsRPCClientConfig) error {
	ns.connString = config.Connect
	if ns.connString == "" {
		return constants.ErrNoNatsConnectionString
	}
	ns.connectionTimeout = config.ConnectionTimeout
	ns.maxReconnectionRetries = config.MaxReconnectionRetries
	ns.reqTimeout = config.RequestTimeout
	if ns.reqTimeout == 0 {
		return constants.ErrNatsNoRequestTimeout
	}
	ns.websocketCompression = config.WebsocketCompression
	ns.reconnectJitter = config.ReconnectJitter
	ns.reconnectJitterTLS = config.ReconnectJitterTLS
	ns.reconnectWait = config.ReconnectWait
	ns.pingInterval = config.PingInterval
	ns.maxPingsOutstanding = config.MaxPingsOutstanding
	return nil
}

// BroadcastSessionBind sends the binding information to other servers that may be interested in this info
func (ns *NatsRPCClient) BroadcastSessionBind(uid string) error {
	msg := &protos.BindMsg{
		Uid: uid,
		Fid: ns.server.ID,
	}
	msgData, err := proto.Marshal(msg)
	if err != nil {
		return err
	}
	return ns.Send(GetBindBroadcastTopic(ns.server.Type), msgData)
}

// Send publishes a message in a given topic
func (ns *NatsRPCClient) Send(topic string, data []byte) error {
	if !ns.running {
		return constants.ErrRPCClientNotInitialized
	}
	return ns.conn.Publish(topic, data)
}

// SendPush sends a message to a user
func (ns *NatsRPCClient) SendPush(userID string, frontendSv *Server, push *protos.Push) error {
	topic := GetUserMessagesTopic(userID, frontendSv.Type)
	msg, err := proto.Marshal(push)
	if err != nil {
		return err
	}
	return ns.Send(topic, msg)
}

// SendKick kicks an user
func (ns *NatsRPCClient) SendKick(userID string, serverType string, kick *protos.KickMsg) error {
	topic := GetUserKickTopic(userID, serverType)
	msg, err := proto.Marshal(kick)
	if err != nil {
		return err
	}
	return ns.Send(topic, msg)
}

// Call calls a method remotely
func (ns *NatsRPCClient) Call(
	ctx context.Context,
	rpcType protos.RPCType,
	route *route.Route,
	session session.Session,
	msg *message.Message,
	server *Server,
) (*protos.Response, error) {
	parent, err := tracing.ExtractSpan(ctx)
	if err != nil {
		logger.Log.Warnf("failed to retrieve parent span: %s", err.Error())
	}
	ctx = trace.ContextWithRemoteSpanContext(ctx, parent)
	attributes := []attribute.KeyValue{
		attribute.String("span.kind", "client"),
		attribute.String("local.id", ns.server.ID),
		attribute.String("peer.serverType", server.Type),
		attribute.String("peer.id", server.ID),
	}
	ctx, _ = tracing.StartSpan(ctx, "NATS RPC Call", attributes...)
	defer tracing.FinishSpan(ctx, err)

	if !ns.running {
		err = constants.ErrRPCClientNotInitialized
		return nil, err
	}

	if session != nil {
		requestID := uuid.New().String()
		requestInfo := ""
		if route != nil {
			requestInfo = route.Method
		}

		session.SetRequestInFlight(requestID, requestInfo, true)
		defer session.SetRequestInFlight(requestID, "", false)
	}

	reqTimeout := pcontext.GetFromPropagateCtx(ctx, constants.RequestTimeout)
	if reqTimeout == nil {
		reqTimeout = ns.reqTimeout.String()
		ctx = pcontext.AddToPropagateCtx(ctx, constants.RequestTimeout, reqTimeout)
	}
	logger.Log.Debugf("[rpc_client] sending remote nats request for route %s with timeout of %s", route, reqTimeout)

	req, err := buildRequest(ctx, rpcType, route, session, msg, ns.server)
	if err != nil {
		return nil, err
	}
	marshalledData, err := proto.Marshal(&req)
	if err != nil {
		return nil, err
	}

	var m *nats.Msg

	if ns.metricsReporters != nil {
		startTime := time.Now()
		ctx = pcontext.AddToPropagateCtx(ctx, constants.StartTimeKey, startTime.UnixNano())
		ctx = pcontext.AddToPropagateCtx(ctx, constants.RouteKey, route.String())
		defer func() {
			typ := "rpc"
			metrics.ReportTimingFromCtx(ctx, ns.metricsReporters, typ, err)
		}()
	}

	var timeout time.Duration
	timeout, _ = time.ParseDuration(reqTimeout.(string))
	m, err = ns.conn.Request(getChannel(server.Type, server.ID), marshalledData, timeout)
	if err != nil {
		if err == nats.ErrTimeout {
			err = errors.NewError(constants.ErrRPCRequestTimeout, "PIT-408", map[string]string{
				"timeout": timeout.String(),
				"route":   route.String(),
				"server":  ns.server.ID,
				"peer.id": server.ID,
			})
		}
		return nil, err
	}

	res := &protos.Response{}
	err = proto.Unmarshal(m.Data, res)
	if err != nil {
		return nil, err
	}

	if res.Error != nil {
		if res.Error.Code == "" {
			res.Error.Code = errors.ErrUnknownCode
		}
		err = &errors.Error{
			Code:     res.Error.Code,
			Message:  res.Error.Msg,
			Metadata: res.Error.Metadata,
		}
		return nil, err
	}
	return res, nil
}

// replaceConnection replaces the NATS connection, draining the old one
func (ns *NatsRPCClient) replaceConnection() error {
	return replaceNatsConnection(
		ns.conn,
		nil, // client doesn't have subscriptions
		func() error { return ns.initConnection(true) },
		"client",
	)
}

// Init inits nats rpc client
func (ns *NatsRPCClient) Init() error {
	return ns.initConnection(false)
}

// initConnection initializes or replaces the NATS connection
func (ns *NatsRPCClient) initConnection(isReplacement bool) error {
	if !isReplacement {
		ns.running = true
		logger.Log.Debugf("connecting to nats (client) with timeout of %s", ns.connectionTimeout)
	} else {
		logger.Log.Debugf("re-initializing nats client connection")
	}

	conn, err := setupNatsConn(
		ns.connString,
		ns.appDieChan,
		ns.replaceConnection,
		nats.RetryOnFailedConnect(true),
		nats.MaxReconnects(ns.maxReconnectionRetries),
		nats.Timeout(ns.connectionTimeout),
		nats.Compression(ns.websocketCompression),
		nats.ReconnectJitter(ns.reconnectJitter, ns.reconnectJitterTLS),
		nats.ReconnectWait(ns.reconnectWait),
		nats.PingInterval(ns.pingInterval),
		nats.MaxPingsOutstanding(ns.maxPingsOutstanding),
	)
	if err != nil {
		return err
	}
	ns.conn = conn

	if isReplacement {
		logger.Log.Infof("successfully replaced nats client connection")
	}
	return nil
}

// AfterInit runs after initialization
func (ns *NatsRPCClient) AfterInit() {}

// BeforeShutdown runs before shutdown
func (ns *NatsRPCClient) BeforeShutdown() {}

// Shutdown stops nats rpc server
func (ns *NatsRPCClient) Shutdown() error {
	return nil
}

func (ns *NatsRPCClient) stop() {
	ns.running = false
}

func (ns *NatsRPCClient) getSubscribeChannel() string {
	return fmt.Sprintf("pitaya/servers/%s/%s", ns.server.Type, ns.server.ID)
}

func (ns *NatsRPCClient) IsConnected() bool {
	return ns.conn != nil && ns.conn.IsConnected()
}

```

`pkg/cluster/nats_rpc_client_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package cluster

import (
	"context"
	"errors"
	"fmt"
	"testing"
	"time"

	"github.com/golang/mock/gomock"
	"github.com/golang/protobuf/proto"
	"github.com/google/uuid"
	nats "github.com/nats-io/nats.go"
	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	e "github.com/topfreegames/pitaya/v3/pkg/errors"
	"github.com/topfreegames/pitaya/v3/pkg/helpers"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
	metricsmocks "github.com/topfreegames/pitaya/v3/pkg/metrics/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/route"
	sessionmocks "github.com/topfreegames/pitaya/v3/pkg/session/mocks"
)

func TestNewNatsRPCClient(t *testing.T) {
	t.Parallel()
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockMetricsReporter := metricsmocks.NewMockReporter(ctrl)
	mockMetricsReporters := []metrics.Reporter{mockMetricsReporter}

	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Nats
	sv := getServer()
	n, err := NewNatsRPCClient(cfg, sv, mockMetricsReporters, nil)
	assert.NoError(t, err)
	assert.NotNil(t, n)
	assert.Equal(t, sv, n.server)
	assert.Equal(t, mockMetricsReporters, n.metricsReporters)
	assert.False(t, n.running)
}

func TestNatsRPCClientConfigure(t *testing.T) {
	t.Parallel()
	tables := []struct {
		natsConnect string
		reqTimeout  time.Duration
		err         error
	}{
		{"nats://localhost:2333", time.Duration(10 * time.Second), nil},
		{"nats://localhost:2333", time.Duration(0), constants.ErrNatsNoRequestTimeout},
		{"", time.Duration(10 * time.Second), constants.ErrNoNatsConnectionString},
	}

	for _, table := range tables {
		t.Run(fmt.Sprintf("%s-%s", table.natsConnect, table.reqTimeout), func(t *testing.T) {
			cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Nats
			cfg.Connect = table.natsConnect
			cfg.RequestTimeout = table.reqTimeout
			_, err := NewNatsRPCClient(cfg, getServer(), nil, nil)
			assert.Equal(t, table.err, err)
		})
	}
}

func TestNatsRPCClientGetSubscribeChannel(t *testing.T) {
	t.Parallel()
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Nats
	sv := getServer()
	n, _ := NewNatsRPCClient(cfg, sv, nil, nil)
	assert.Equal(t, fmt.Sprintf("pitaya/servers/%s/%s", n.server.Type, n.server.ID), n.getSubscribeChannel())
}

func TestNatsRPCClientStop(t *testing.T) {
	t.Parallel()
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Nats
	sv := getServer()
	n, _ := NewNatsRPCClient(cfg, sv, nil, nil)
	// change it to true to ensure it goes to false
	n.running = true
	n.stop()
	assert.False(t, n.running)
}

func TestNatsRPCClientInitShouldFailIfConnFails(t *testing.T) {
	t.Parallel()
	sv := getServer()
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Nats
	cfg.Connect = "nats://localhost:1"
	rpcClient, _ := NewNatsRPCClient(cfg, sv, nil, nil)
	err := rpcClient.Init()
	assert.Error(t, err)
}

func TestNatsRPCClientInit(t *testing.T) {
	s := helpers.GetTestNatsServer(t)
	defer s.Shutdown()
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Nats
	cfg.Connect = fmt.Sprintf("nats://%s", s.Addr())
	sv := getServer()

	rpcClient, _ := NewNatsRPCClient(cfg, sv, nil, nil)
	err := rpcClient.Init()
	assert.NoError(t, err)
	assert.True(t, rpcClient.running)

	// should setup conn
	assert.NotNil(t, rpcClient.conn)
	assert.True(t, rpcClient.conn.IsConnected())
}

func TestNatsRPCClientBroadcastSessionBind(t *testing.T) {
	uid := "testuid123"
	s := helpers.GetTestNatsServer(t)
	defer s.Shutdown()
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Nats
	cfg.Connect = fmt.Sprintf("nats://%s", s.Addr())
	sv := getServer()

	rpcClient, _ := NewNatsRPCClient(cfg, sv, nil, nil)
	rpcClient.Init()

	subChan := make(chan *nats.Msg)
	subs, err := rpcClient.conn.ChanSubscribe(GetBindBroadcastTopic(sv.Type), subChan)
	assert.NoError(t, err)
	// TODO this is ugly, can lead to flaky tests and we could probably do it better
	time.Sleep(50 * time.Millisecond)

	err = rpcClient.BroadcastSessionBind(uid)
	assert.NoError(t, err)

	m := helpers.ShouldEventuallyReceive(t, subChan).(*nats.Msg)

	bMsg := &protos.BindMsg{}
	err = proto.Unmarshal(m.Data, bMsg)
	assert.NoError(t, err)

	assert.Equal(t, uid, bMsg.Uid)
	assert.Equal(t, sv.ID, bMsg.Fid)

	subs.Unsubscribe()
}

func TestNatsRPCClientSendKick(t *testing.T) {
	uid := "testuid"
	s := helpers.GetTestNatsServer(t)
	defer s.Shutdown()
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Nats
	cfg.Connect = fmt.Sprintf("nats://%s", s.Addr())
	sv := getServer()

	rpcClient, _ := NewNatsRPCClient(cfg, sv, nil, nil)
	err := rpcClient.Init()
	assert.NoError(t, err)

	kickChan := make(chan *nats.Msg)
	subs, err := rpcClient.conn.ChanSubscribe(GetUserKickTopic(uid, sv.Type), kickChan)
	assert.NoError(t, err)
	time.Sleep(50 * time.Millisecond)

	kick := &protos.KickMsg{
		UserId: uid,
	}

	err = rpcClient.SendKick(uid, sv.Type, kick)
	assert.NoError(t, err)

	m := helpers.ShouldEventuallyReceive(t, kickChan).(*nats.Msg)

	actual := &protos.KickMsg{}
	err = proto.Unmarshal(m.Data, actual)
	assert.NoError(t, err)

	assert.Equal(t, kick.UserId, actual.UserId)
	err = subs.Unsubscribe()
	assert.NoError(t, err)
}

func TestNatsRPCClientSendPush(t *testing.T) {
	uid := "testuid123"
	s := helpers.GetTestNatsServer(t)
	defer s.Shutdown()
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Nats
	cfg.Connect = fmt.Sprintf("nats://%s", s.Addr())
	sv := getServer()

	rpcClient, _ := NewNatsRPCClient(cfg, sv, nil, nil)
	rpcClient.Init()

	subChan := make(chan *nats.Msg)
	subs, err := rpcClient.conn.ChanSubscribe(GetUserMessagesTopic(uid, sv.Type), subChan)
	assert.NoError(t, err)
	// TODO this is ugly, can lead to flaky tests and we could probably do it better
	time.Sleep(50 * time.Millisecond)

	push := &protos.Push{
		Route: "hellow",
		Uid:   uid,
		Data:  []byte{0x01},
	}

	err = rpcClient.SendPush(uid, sv, push)
	assert.NoError(t, err)

	m := helpers.ShouldEventuallyReceive(t, subChan).(*nats.Msg)

	actual := &protos.Push{}
	err = proto.Unmarshal(m.Data, actual)
	assert.NoError(t, err)

	assert.Equal(t, push.Route, actual.Route)
	assert.Equal(t, push.Uid, actual.Uid)
	assert.Equal(t, push.Data, actual.Data)

	subs.Unsubscribe()

}

func TestNatsRPCClientSendShouldFailIfNotRunning(t *testing.T) {
	config := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Nats
	sv := getServer()
	rpcClient, _ := NewNatsRPCClient(config, sv, nil, nil)
	err := rpcClient.Send("topic", []byte("data"))
	assert.Equal(t, constants.ErrRPCClientNotInitialized, err)
}

func TestNatsRPCClientSend(t *testing.T) {
	s := helpers.GetTestNatsServer(t)
	defer s.Shutdown()
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Nats
	cfg.Connect = fmt.Sprintf("nats://%s", s.Addr())
	sv := getServer()

	rpcClient, _ := NewNatsRPCClient(cfg, sv, nil, nil)
	rpcClient.Init()

	tables := []struct {
		name  string
		topic string
		data  []byte
	}{
		{"test1", getChannel(sv.Type, sv.ID), []byte("test1")},
		{"test2", getChannel(sv.Type, sv.ID), []byte("test2")},
	}
	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			subChan := make(chan *nats.Msg)
			subs, err := rpcClient.conn.ChanSubscribe(table.topic, subChan)
			assert.NoError(t, err)
			// TODO this is ugly, can lead to flaky tests and we could probably do it better
			time.Sleep(50 * time.Millisecond)

			err = rpcClient.Send(table.topic, table.data)
			assert.NoError(t, err)

			r := helpers.ShouldEventuallyReceive(t, subChan).(*nats.Msg)
			assert.Equal(t, table.data, r.Data)
			subs.Unsubscribe()
		})
	}
}

func TestNatsRPCClientBuildRequest(t *testing.T) {
	config := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Nats
	sv := getServer()
	rpcClient, _ := NewNatsRPCClient(config, sv, nil, nil)

	rt := route.NewRoute("sv", "svc", "method")

	data := []byte("data")
	messageID := uint(123)
	sessionID := int64(1)
	uid := "uid"
	data2 := []byte("data2")
	tables := []struct {
		name           string
		frontendServer bool
		rpcType        protos.RPCType
		route          *route.Route
		msg            *message.Message
		expected       protos.Request
	}{
		{
			"test-frontend-request", true, protos.RPCType_Sys, rt,
			&message.Message{Type: message.Request, ID: messageID, Data: data},
			protos.Request{
				Type: protos.RPCType_Sys,
				Msg: &protos.Msg{
					Route: rt.String(),
					Data:  data,
					Type:  protos.MsgType_MsgRequest,
					Id:    uint64(messageID),
				},
				FrontendID: sv.ID,
				Session: &protos.Session{
					Id:   sessionID,
					Uid:  uid,
					Data: data2,
				},
			},
		},
		{
			"test-rpc-sys-request", false, protos.RPCType_Sys, rt,
			&message.Message{Type: message.Request, ID: messageID, Data: data},
			protos.Request{
				Type: protos.RPCType_Sys,
				Msg: &protos.Msg{
					Route: rt.String(),
					Data:  data,
					Type:  protos.MsgType_MsgRequest,
					Id:    uint64(messageID),
				},
				FrontendID: "",
				Session: &protos.Session{
					Id:   sessionID,
					Uid:  uid,
					Data: data2,
				},
			},
		},
		{
			"test-rpc-user-request", false, protos.RPCType_User, rt,
			&message.Message{Type: message.Request, ID: messageID, Data: data},
			protos.Request{
				Type: protos.RPCType_User,
				Msg: &protos.Msg{
					Route: rt.String(),
					Data:  data,
					Type:  protos.MsgType_MsgRequest,
				},
				FrontendID: "",
			},
		},
		{
			"test-notify", false, protos.RPCType_Sys, rt,
			&message.Message{Type: message.Notify, ID: messageID, Data: data},
			protos.Request{
				Type: protos.RPCType_Sys,
				Msg: &protos.Msg{
					Route: rt.String(),
					Data:  data,
					Type:  protos.MsgType_MsgNotify,
					Id:    0,
				},
				FrontendID: "",
				Session: &protos.Session{
					Id:   sessionID,
					Uid:  uid,
					Data: data2,
				},
			},
		},
	}
	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			ss := sessionmocks.NewMockSession(ctrl)
			if table.rpcType == protos.RPCType_Sys {
				ss.EXPECT().ID().Return(sessionID).Times(1)
				ss.EXPECT().UID().Return(uid).Times(1)
				ss.EXPECT().GetDataEncoded().Return(data2).Times(1)
			}

			rpcClient.server.Frontend = table.frontendServer
			req, err := buildRequest(context.Background(), table.rpcType, table.route, ss, table.msg, rpcClient.server)
			assert.NoError(t, err)
			assert.NotNil(t, req.Metadata)
			req.Metadata = nil
			assert.Equal(t, table.expected, req)
		})
	}
}

func TestNatsRPCClientCallShouldFailIfNotRunning(t *testing.T) {
	config := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Nats
	sv := getServer()
	rpcClient, _ := NewNatsRPCClient(config, sv, nil, nil)
	res, err := rpcClient.Call(context.Background(), protos.RPCType_Sys, nil, nil, nil, sv)
	assert.Equal(t, constants.ErrRPCClientNotInitialized, err)
	assert.Nil(t, res)
}

func TestNatsRPCClientCall(t *testing.T) {
	s := helpers.GetTestNatsServer(t)
	sv := getServer()
	defer s.Shutdown()
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Client.Nats
	cfg.Connect = fmt.Sprintf("nats://%s", s.Addr())
	cfg.RequestTimeout = time.Duration(300 * time.Millisecond)
	rpcClient, _ := NewNatsRPCClient(cfg, sv, nil, nil)
	rpcClient.Init()

	rt := route.NewRoute("sv", "svc", "method")

	sessionID := int64(1)
	uid := "uid"
	data2 := []byte("data2")

	msg := &message.Message{
		Type: message.Request,
		ID:   uint(123),
		Data: []byte("data"),
	}

	tables := []struct {
		name     string
		response interface{}
		expected *protos.Response
		err      error
	}{
		{"test_error", &protos.Response{Data: []byte("nok"), Error: &protos.Error{Msg: "nok"}}, nil, e.NewError(errors.New("nok"), e.ErrUnknownCode)},
		{"test_ok", &protos.Response{Data: []byte("ok")}, &protos.Response{Data: []byte("ok")}, nil},
		{"test_bad_response", []byte("invalid"), nil, errors.New("cannot parse invalid wire-format data")},
		{"test_bad_proto", &protos.Session{Id: 1, Uid: "snap"}, nil, errors.New("cannot parse invalid wire-format data")},
		{"test_no_response", nil, nil, constants.ErrRPCRequestTimeout},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			conn, err := setupNatsConn(fmt.Sprintf("nats://%s", s.Addr()), nil, nil)
			assert.NoError(t, err)

			sv2 := getServer()
			sv2.Type = uuid.New().String()
			sv2.ID = uuid.New().String()
			subs, err := conn.Subscribe(getChannel(sv2.Type, sv2.ID), func(m *nats.Msg) {
				if table.response != nil {
					if val, ok := table.response.(*protos.Response); ok {
						b, _ := proto.Marshal(val)
						conn.Publish(m.Reply, b)
					} else if val, ok := table.response.(*protos.Session); ok {
						b, _ := proto.Marshal(val)
						conn.Publish(m.Reply, b)
					} else {
						conn.Publish(m.Reply, table.response.([]byte))
					}
				}
			})
			assert.NoError(t, err)
			// TODO this is ugly, can lead to flaky tests and we could probably do it better
			time.Sleep(50 * time.Millisecond)

			ss := sessionmocks.NewMockSession(ctrl)
			ss.EXPECT().ID().Return(sessionID).Times(1)
			ss.EXPECT().UID().Return(uid).Times(1)
			ss.EXPECT().GetDataEncoded().Return(data2).Times(1)
			ss.EXPECT().SetRequestInFlight(gomock.Any(), gomock.Any(), gomock.Any()).Times(2)

			res, err := rpcClient.Call(context.Background(), protos.RPCType_Sys, rt, ss, msg, sv2)
			assert.Equal(t, table.expected, res)
			if table.err != nil {
				assert.Error(t, err)
				assert.Contains(t, err.Error(), table.err.Error())
			}
			err = subs.Unsubscribe()
			assert.NoError(t, err)
			conn.Close()
		})
	}
}

```

`pkg/cluster/nats_rpc_common.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package cluster

import (
	"fmt"
	"os"
	"time"

	nats "github.com/nats-io/nats.go"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
)

func getChannel(serverType, serverID string) string {
	return fmt.Sprintf("pitaya/servers/%s/%s", serverType, serverID)
}

func drainAndClose(nc *nats.Conn) error {
	if nc == nil {
		return nil
	}
	// If connection is already closed, just return
	if nc.IsClosed() {
		return nil
	}
	// Drain connection (this will flush any pending messages and prevent new ones)
	err := nc.Drain()
	if err != nil {
		logger.Log.Warnf("error draining nats connection: %v", err)
		// Even if drain fails, try to close (but only if not already closed)
		if !nc.IsClosed() {
			nc.Close()
		}
		return err
	}

	// Wait for drain to complete with timeout
	timeout := time.After(5 * time.Second)
	ticker := time.NewTicker(100 * time.Millisecond)
	defer ticker.Stop()

	for nc.IsDraining() {
		select {
		case <-ticker.C:
			continue
		case <-timeout:
			logger.Log.Warn("drain timeout exceeded, forcing close")
			if !nc.IsClosed() {
				nc.Close()
			}
			return fmt.Errorf("drain timeout exceeded")
		}
	}

	// Close will happen automatically after drain completes
	return nil
}

// replaceNatsConnection handles the common logic for replacing NATS connections
// It stores old connection/subscription references, calls initFunc to set up the new connection,
// and then drains the old resources after the new connection is ready.
func replaceNatsConnection(
	oldConn *nats.Conn,
	oldSub *nats.Subscription,
	initFunc func() error,
	componentName string,
) error {
	logger.Log.Infof("replacing nats %s connection due to lame duck mode", componentName)

	// Re-initialize connection (pass true to indicate this is a replacement)
	if err := initFunc(); err != nil {
		return err
	}

	// Drain and close old connection and subscription after new one is set up
	if oldSub != nil {
		go func() {
			if err := oldSub.Drain(); err != nil {
				logger.Log.Warnf("error draining old %s subscription: %v", componentName, err)
			}
		}()
	}

	if oldConn != nil {
		go func() {
			if err := drainAndClose(oldConn); err != nil {
				logger.Log.Warnf("error draining old nats %s connection: %v", componentName, err)
			}
		}()
	}

	return nil
}

func setupNatsConn(connectString string, appDieChan chan bool, lameDuckReplacement func() error, options ...nats.Option) (*nats.Conn, error) {
	connectedCh := make(chan bool)
	initialConnectErrorCh := make(chan error)
	natsOptions := append(
		options,
		nats.DisconnectErrHandler(func(nc *nats.Conn, err error) {
			logger.Log.Warnf("disconnected from nats (%s)! Reason: %v", nc.ConnectedAddr(), err)
		}),
		nats.ReconnectHandler(func(nc *nats.Conn) {
			logger.Log.Warnf("reconnected to nats server %s with address %s in cluster %s!", nc.ConnectedServerName(), nc.ConnectedAddr(), nc.ConnectedClusterName())
		}),
		nats.ClosedHandler(func(nc *nats.Conn) {
			// Recover from potential panics when sending on channels that may be closed
			// This can happen if the callback is invoked after setupNatsConn has returned
			defer func() {
				if r := recover(); r != nil {
					// Channel might be closed or in invalid state, just log and continue
					// This is safe because setupNatsConn has already handled the error
					logger.Log.Debugf("recovered from panic in ClosedHandler (channel may be closed): %v", r)
				}
			}()

			err := nc.LastError()
			if err == nil {
				logger.Log.Warn("nats connection closed with no error.")
				return
			}

			logger.Log.Errorf("nats connection closed. reason: %q", nc.LastError())

			// If connection was never successfully established, prioritize initialConnectErrorCh
			// to allow setupNatsConn to return quickly with an error
			wasConnected := nc.ConnectedAddr() != ""

			if !wasConnected {
				// During initial connection, send error to initialConnectErrorCh first
				select {
				case initialConnectErrorCh <- nc.LastError():
					return
				default:
					// If channel is not ready, fall through to appDieChan handling
				}
			}

			if appDieChan != nil {
				select {
				case appDieChan <- true:
					return
				case initialConnectErrorCh <- nc.LastError():
					logger.Log.Warnf("appDieChan not ready, sending error in initialConnectCh")
					return
				default:
					logger.Log.Warnf("no termination channel available, sending termination signal to app")

					p, err := os.FindProcess(os.Getpid())
					if err != nil {
						logger.Log.Errorf("could not find current process: %v", err)
						os.Exit(1)
					}

					// On Windows, Signal() with Interrupt works
					// On Unix-like systems, this is equivalent to SIGINT
					err = p.Signal(os.Interrupt)
					if err != nil {
						logger.Log.Errorf("could not send interrupt signal to the application: %v", err)
						os.Exit(1)
					}
				}
			} else if !wasConnected {
				// If no appDieChan and connection was never established, try initialConnectErrorCh again
				select {
				case initialConnectErrorCh <- nc.LastError():
					return
				default:
					// Channel not ready, but we've already logged the error
				}
			}
		}),
		nats.ErrorHandler(func(nc *nats.Conn, sub *nats.Subscription, err error) {
			if err == nats.ErrSlowConsumer {
				dropped, _ := sub.Dropped()
				logger.Log.Warn("nats slow consumer on subject %q: dropped %d messages\n",
					sub.Subject, dropped)
			} else {
				logger.Log.Errorf(err.Error())
			}
		}),
		nats.ConnectHandler(func(nc *nats.Conn) {
			logger.Log.Infof("connected to nats on %s", nc.ConnectedAddr())
			connectedCh <- true
		}),
		nats.LameDuckModeHandler(func(nc *nats.Conn) {
			logger.Log.Warnf("nats connection entered lame duck mode")
			if lameDuckReplacement != nil {
				go func() {
					if err := lameDuckReplacement(); err != nil {
						logger.Log.Errorf("failed to replace connection: %v", err)
						// The old connection will eventually close (it's in lame duck mode),
						// which will trigger ClosedHandler and appDieChan
					}
				}()
			}
		}),
	)

	nc, err := nats.Connect(connectString, natsOptions...)
	if err != nil {
		return nil, err
	}
	maxConnTimeout := nc.Opts.Timeout
	if nc.Opts.RetryOnFailedConnect {
		// This is non-deterministic becase jitter TLS is different and we need to simplify
		// the calculations. What we want to do is simply not block forever the call while
		// we don't set a timeout so low that hinders our own reconnect config:
		// 		maxReconnectTimeout = reconnectWait + reconnectJitter + reconnectTimeout
		// 		connectionTimeout + (maxReconnectionAttemps * maxReconnectTimeout)
		// Thus, the time.After considers 2 times this value
		maxReconnectionTimeout := nc.Opts.ReconnectWait + nc.Opts.ReconnectJitter + nc.Opts.Timeout
		maxConnTimeout += time.Duration(nc.Opts.MaxReconnect) * maxReconnectionTimeout
	}

	logger.Log.Debugf("attempting nats connection for a max of %v", maxConnTimeout)
	select {
	case <-connectedCh:
		return nc, nil
	case err := <-initialConnectErrorCh:
		drainErr := drainAndClose(nc)
		if drainErr != nil {
			logger.Log.Warnf("failed to drain and close: %s", drainErr)
		}
		return nil, err
	case <-time.After(maxConnTimeout * 2):
		drainErr := drainAndClose(nc)
		if drainErr != nil {
			logger.Log.Warnf("failed to drain and close: %s", drainErr)
		}
		return nil, fmt.Errorf("timeout setting up nats connection")
	}
}

```

`pkg/cluster/nats_rpc_common_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package cluster

import (
	"fmt"
	"testing"
	"time"

	"github.com/nats-io/nats-server/v2/test"
	nats "github.com/nats-io/nats.go"
	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/helpers"
)

func getServer() *Server {
	return &Server{
		ID:       "id1",
		Type:     "type1",
		Frontend: true,
	}
}

func TestNatsRPCCommonGetChannel(t *testing.T) {
	t.Parallel()
	assert.Equal(t, "pitaya/servers/type1/sv1", getChannel("type1", "sv1"))
	assert.Equal(t, "pitaya/servers/2type1/2sv1", getChannel("2type1", "2sv1"))
}

func TestNatsRPCCommonSetupNatsConn(t *testing.T) {
	t.Parallel()
	s := helpers.GetTestNatsServer(t)
	defer s.Shutdown()
	conn, err := setupNatsConn(fmt.Sprintf("nats://%s", s.Addr()), nil, nil)
	assert.NoError(t, err)
	assert.NotNil(t, conn)
}

func TestNatsRPCCommonSetupNatsConnShouldError(t *testing.T) {
	t.Parallel()
	conn, err := setupNatsConn("nats://localhost:1234", nil, nil)
	assert.Error(t, err)
	assert.Nil(t, conn)
}

func TestNatsRPCCommonCloseHandler(t *testing.T) {
	t.Parallel()
	s := helpers.GetTestNatsServer(t)

	dieChan := make(chan bool)

	conn, err := setupNatsConn(fmt.Sprintf("nats://%s", s.Addr()), dieChan, nil, nats.MaxReconnects(1),
		nats.ReconnectWait(1*time.Millisecond))
	assert.NoError(t, err)
	assert.NotNil(t, conn)

	s.Shutdown()

	value, ok := <-dieChan
	assert.True(t, ok)
	assert.True(t, value)
}

func TestSetupNatsConnReconnection(t *testing.T) {
	t.Run("waits for reconnection on initial failure", func(t *testing.T) {
		// Use an invalid address first to force initial connection failure
		invalidAddr := "nats://invalid:4222"
		validAddr := "nats://localhost:4222"

		urls := fmt.Sprintf("%s,%s", invalidAddr, validAddr)

		go func() {
			time.Sleep(50 * time.Millisecond)
			ts := test.RunDefaultServer()
			defer ts.Shutdown()
			<-time.After(200 * time.Millisecond)
		}()

		// Setup connection with retry enabled
		appDieCh := make(chan bool)
		conn, err := setupNatsConn(
			urls,
			appDieCh,
			nil,
			nats.ReconnectWait(10*time.Millisecond),
			nats.MaxReconnects(5),
			nats.RetryOnFailedConnect(true),
		)

		assert.NoError(t, err)
		assert.NotNil(t, conn)
		assert.True(t, conn.IsConnected())

		conn.Close()
	})

	t.Run("does not block indefinitely if all connect attempts fail", func(t *testing.T) {
		invalidAddr := "nats://invalid:4222"

		appDieCh := make(chan bool)
		done := make(chan any)

		go func() {
			conn, err := setupNatsConn(
				invalidAddr,
				appDieCh,
				nil,
				nats.ReconnectWait(10*time.Millisecond),
				nats.MaxReconnects(2),
				nats.RetryOnFailedConnect(true),
			)
			assert.Error(t, err)
			assert.Nil(t, conn)
			close(done)
			close(appDieCh)
		}()

		select {
		case <-appDieCh:
		case <-done:
		case <-time.After(250 * time.Millisecond):
			t.Fail()
		}
	})

	t.Run("if it fails to connect, exit with error even if appDieChan is not ready to listen", func(t *testing.T) {
		invalidAddr := "nats://invalid:4222"

		appDieCh := make(chan bool)
		done := make(chan any)

		go func() {
			conn, err := setupNatsConn(invalidAddr, appDieCh, nil)
			assert.Error(t, err)
			assert.Nil(t, conn)
			close(done)
			close(appDieCh)
		}()

		select {
		case <-done:
		case <-time.After(50 * time.Millisecond):
			t.Fail()
		}
	})

	t.Run("if connection takes too long, exit with error after waiting maxReconnTimeout", func(t *testing.T) {
		invalidAddr := "nats://invalid:4222"

		appDieCh := make(chan bool)
		done := make(chan any)

		initialConnectionTimeout := time.Nanosecond
		maxReconnectionAtetmpts := 1
		reconnectWait := time.Nanosecond
		reconnectJitter := time.Nanosecond
		maxReconnectionTimeout := reconnectWait + reconnectJitter + initialConnectionTimeout
		maxReconnTimeout := initialConnectionTimeout + (time.Duration(maxReconnectionAtetmpts) * maxReconnectionTimeout)

		maxTestTimeout := 100 * time.Millisecond

		// Assert that if it fails because of connection timeout the test will capture
		assert.Greater(t, maxTestTimeout, maxReconnTimeout)

		go func() {
			conn, err := setupNatsConn(
				invalidAddr,
				appDieCh,
				nil,
				nats.Timeout(initialConnectionTimeout),
				nats.ReconnectWait(reconnectWait),
				nats.MaxReconnects(maxReconnectionAtetmpts),
				nats.ReconnectJitter(reconnectJitter, reconnectJitter),
				nats.RetryOnFailedConnect(true),
			)
			assert.Error(t, err)
			assert.ErrorContains(t, err, "timeout setting up nats connection")
			assert.Nil(t, conn)
			close(done)
			close(appDieCh)
		}()

		select {
		case <-done:
		case <-time.After(maxTestTimeout):
			t.Fail()
		}
	})
}

```

`pkg/cluster/nats_rpc_server.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package cluster

import (
	"context"
	"errors"
	"fmt"
	"math"
	"time"

	"github.com/golang/protobuf/proto"
	nats "github.com/nats-io/nats.go"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	e "github.com/topfreegames/pitaya/v3/pkg/errors"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/session"
	"github.com/topfreegames/pitaya/v3/pkg/util"
)

// NatsRPCServer struct
type NatsRPCServer struct {
	service                int
	connString             string
	connectionTimeout      time.Duration
	maxReconnectionRetries int
	server                 *Server
	conn                   *nats.Conn
	pushBufferSize         int
	messagesBufferSize     int
	stopChan               chan bool
	subChan                chan *nats.Msg // subChan is the channel used by the server to receive network messages addressed to itself
	bindingsChan           chan *nats.Msg // bindingsChan receives notify from other servers on every user bind to session
	unhandledReqCh         chan *protos.Request
	responses              []*protos.Response
	requests               []*protos.Request
	userPushCh             chan *protos.Push
	userKickCh             chan *protos.KickMsg
	sub                    *nats.Subscription
	dropped                int
	pitayaServer           protos.PitayaServer
	metricsReporters       []metrics.Reporter
	sessionPool            session.SessionPool
	appDieChan             chan bool
	websocketCompression   bool
	reconnectJitter        time.Duration
	reconnectJitterTLS     time.Duration
	reconnectWait          time.Duration
	pingInterval           time.Duration
	maxPingsOutstanding    int
}

// NewNatsRPCServer ctor
func NewNatsRPCServer(
	config config.NatsRPCServerConfig,
	server *Server,
	metricsReporters []metrics.Reporter,
	appDieChan chan bool,
	sessionPool session.SessionPool,
) (*NatsRPCServer, error) {
	ns := &NatsRPCServer{
		server:            server,
		stopChan:          make(chan bool),
		unhandledReqCh:    make(chan *protos.Request),
		dropped:           0,
		metricsReporters:  metricsReporters,
		appDieChan:        appDieChan,
		connectionTimeout: nats.DefaultTimeout,
		sessionPool:       sessionPool,
	}
	if err := ns.configure(config); err != nil {
		return nil, err
	}

	return ns, nil
}

func (ns *NatsRPCServer) configure(config config.NatsRPCServerConfig) error {
	ns.service = config.Services
	ns.connString = config.Connect
	if ns.connString == "" {
		return constants.ErrNoNatsConnectionString
	}
	ns.connectionTimeout = config.ConnectionTimeout
	ns.maxReconnectionRetries = config.MaxReconnectionRetries
	ns.messagesBufferSize = config.Buffer.Messages
	if ns.messagesBufferSize == 0 {
		return constants.ErrNatsMessagesBufferSizeZero
	}
	ns.pushBufferSize = config.Buffer.Push
	if ns.pushBufferSize == 0 {
		return constants.ErrNatsPushBufferSizeZero
	}
	ns.subChan = make(chan *nats.Msg, ns.messagesBufferSize)
	ns.bindingsChan = make(chan *nats.Msg, ns.messagesBufferSize)
	// the reason this channel is buffered is that we can achieve more performance by not
	// blocking producers on a massive push
	ns.userPushCh = make(chan *protos.Push, ns.pushBufferSize)
	ns.userKickCh = make(chan *protos.KickMsg, ns.messagesBufferSize)
	ns.responses = make([]*protos.Response, ns.service)
	ns.requests = make([]*protos.Request, ns.service)
	ns.websocketCompression = config.WebsocketCompression
	ns.reconnectJitter = config.ReconnectJitter
	ns.reconnectJitterTLS = config.ReconnectJitterTLS
	ns.reconnectWait = config.ReconnectWait
	ns.pingInterval = config.PingInterval
	ns.maxPingsOutstanding = config.MaxPingsOutstanding
	return nil
}

// GetBindingsChannel gets the channel that will receive all bindings
func (ns *NatsRPCServer) GetBindingsChannel() chan *nats.Msg {
	return ns.bindingsChan
}

// GetUserMessagesTopic get the topic for user
func GetUserMessagesTopic(uid string, svType string) string {
	return fmt.Sprintf("pitaya/%s/user/%s/push", svType, uid)
}

// GetUserKickTopic get the topic for kicking an user
func GetUserKickTopic(uid string, svType string) string {
	return fmt.Sprintf("pitaya/%s/user/%s/kick", svType, uid)
}

// GetBindBroadcastTopic gets the topic on which bind events will be broadcasted
func GetBindBroadcastTopic(svType string) string {
	return fmt.Sprintf("pitaya/%s/bindings", svType)
}

// onSessionBind should be called on each session bind
func (ns *NatsRPCServer) onSessionBind(ctx context.Context, s session.Session) error {
	if ns.server.Frontend {
		subu, err := ns.subscribeToUserMessages(s.UID(), ns.server.Type)
		if err != nil {
			return err
		}
		subk, err := ns.subscribeToUserKickChannel(s.UID(), ns.server.Type)
		if err != nil {
			return err
		}
		s.SetSubscriptions([]*nats.Subscription{subu, subk})
	}
	return nil
}

// SetPitayaServer sets the pitaya server
func (ns *NatsRPCServer) SetPitayaServer(ps protos.PitayaServer) {
	ns.pitayaServer = ps
}

func (ns *NatsRPCServer) subscribeToBindingsChannel() error {
	_, err := ns.conn.ChanSubscribe(GetBindBroadcastTopic(ns.server.Type), ns.bindingsChan)
	return err
}

func (ns *NatsRPCServer) subscribeToUserKickChannel(uid string, svType string) (*nats.Subscription, error) {
	sub, err := ns.conn.Subscribe(GetUserKickTopic(uid, svType), func(msg *nats.Msg) {
		kick := &protos.KickMsg{}
		err := proto.Unmarshal(msg.Data, kick)
		if err != nil {
			logger.Log.Error("error unrmarshalling push: ", err.Error())
		}
		ns.userKickCh <- kick
	})
	return sub, err
}

func (ns *NatsRPCServer) subscribeToUserMessages(uid string, svType string) (*nats.Subscription, error) {
	sub, err := ns.conn.Subscribe(GetUserMessagesTopic(uid, svType), func(msg *nats.Msg) {
		push := &protos.Push{}
		err := proto.Unmarshal(msg.Data, push)
		if err != nil {
			logger.Log.Error("error unmarshalling push:", err.Error())
		}
		ns.userPushCh <- push
	})
	if err != nil {
		return nil, err
	}
	return sub, nil
}

func (ns *NatsRPCServer) handleMessages() {
	defer (func() {
		ns.conn.Drain()
		close(ns.unhandledReqCh)
		close(ns.subChan)
		close(ns.bindingsChan)
	})()
	maxPending := float64(0)
	for {
		select {
		case msg := <-ns.subChan:
			ns.reportMetrics()
			// Check if subscription is still valid before accessing it
			// This can happen during connection replacement when the old subscription becomes invalid
			var dropped int
			if ns.sub != nil && ns.sub.IsValid() {
				var err error
				dropped, err = ns.sub.Dropped()
				if err != nil {
					logger.Log.Errorf("error getting number of dropped messages: %s", err.Error())
				}
				if dropped > ns.dropped {
					logger.Log.Warnf("[rpc server] some messages were dropped! numDropped: %d", dropped)
					ns.dropped = dropped
				}
			}
			subsChanLen := float64(len(ns.subChan))
			maxPending = math.Max(float64(maxPending), subsChanLen)
			logger.Log.Debugf("subs channel size: %v, max: %v, dropped: %v", subsChanLen, maxPending, dropped)
			req := &protos.Request{}
			// TODO: Add tracing here to report delay to start processing message in spans
			err := proto.Unmarshal(msg.Data, req)
			if err != nil {
				// should answer rpc with an error
				logger.Log.Error("error unmarshalling rpc message:", err.Error())
				continue
			}
			req.Msg.Reply = msg.Reply
			ns.unhandledReqCh <- req
		case <-ns.stopChan:
			return
		}
	}
}

// GetUnhandledRequestsChannel gets the unhandled requests channel from nats rpc server
func (ns *NatsRPCServer) GetUnhandledRequestsChannel() chan *protos.Request {
	return ns.unhandledReqCh
}

func (ns *NatsRPCServer) getUserPushChannel() chan *protos.Push {
	return ns.userPushCh
}

func (ns *NatsRPCServer) getUserKickChannel() chan *protos.KickMsg {
	return ns.userKickCh
}

func (ns *NatsRPCServer) marshalResponse(res *protos.Response) ([]byte, error) {
	p, err := proto.Marshal(res)
	if err != nil {
		logger.Log.Errorf("error marshaling response: %s", err.Error())

		res := &protos.Response{
			Error: &protos.Error{
				Code: e.ErrUnknownCode,
				Msg:  err.Error(),
			},
		}
		p, _ = proto.Marshal(res)
	}

	if err == nil && res.Error != nil {
		err = errors.New(res.Error.Msg)
	}
	return p, err
}

func (ns *NatsRPCServer) processMessages(threadID int) {
	for ns.requests[threadID] = range ns.GetUnhandledRequestsChannel() {
		logger.Log.Debugf("(%d) processing message %v", threadID, ns.requests[threadID].GetMsg().GetId())
		ctx, err := util.GetContextFromRequest(ns.requests[threadID], ns.server.ID)
		if err != nil {
			ns.responses[threadID] = &protos.Response{
				Error: &protos.Error{
					Code: e.ErrInternalCode,
					Msg:  err.Error(),
				},
			}

			logger.Log.Errorf("error getting context from request: %s", err)
		} else {
			ns.responses[threadID], err = ns.pitayaServer.Call(ctx, ns.requests[threadID])
			if err != nil {
				logger.Log.Errorf("error processing route %s: %s", ns.requests[threadID].GetMsg().GetRoute(), err)
			}
		}
		p, err := ns.marshalResponse(ns.responses[threadID])
		err = ns.conn.Publish(ns.requests[threadID].GetMsg().GetReply(), p)
		if err != nil {
			logger.Log.Errorf("error sending message response: %s", err.Error())
		}
	}
}

func (ns *NatsRPCServer) processSessionBindings() {
	for bind := range ns.bindingsChan {
		b := &protos.BindMsg{}
		err := proto.Unmarshal(bind.Data, b)
		if err != nil {
			logger.Log.Errorf("error processing binding msg: %v", err)
			continue
		}
		ns.pitayaServer.SessionBindRemote(context.Background(), b)
	}
}

func (ns *NatsRPCServer) processPushes() {
	for push := range ns.getUserPushChannel() {
		logger.Log.Debugf("sending push to user %s: %v", push.GetUid(), string(push.Data))
		_, err := ns.pitayaServer.PushToUser(context.Background(), push)
		if err != nil {
			logger.Log.Errorf("error sending push to user: %v", err)
		}
	}
}

func (ns *NatsRPCServer) processKick() {
	for kick := range ns.getUserKickChannel() {
		logger.Log.Debugf("Sending kick to user %s: %v", kick.GetUserId())
		_, err := ns.pitayaServer.KickUser(context.Background(), kick)
		if err != nil {
			logger.Log.Errorf("error sending kick to user: %v", err)
		}
	}
}

// replaceConnection replaces the NATS connection, draining the old one and re-subscribing
func (ns *NatsRPCServer) replaceConnection() error {
	return replaceNatsConnection(
		ns.conn,
		ns.sub,
		func() error { return ns.initConnection(true) },
		"server",
	)
}

// Init inits nats rpc server
func (ns *NatsRPCServer) Init() error {
	return ns.initConnection(false)
}

// initConnection initializes or replaces the NATS connection
func (ns *NatsRPCServer) initConnection(isReplacement bool) error {
	if !isReplacement {
		// TODO should we have concurrency here? it feels like we should
		go ns.handleMessages()
		logger.Log.Debugf("connecting to nats (server) with timeout of %s", ns.connectionTimeout)
	} else {
		logger.Log.Debugf("re-initializing nats server connection")
	}

	conn, err := setupNatsConn(
		ns.connString,
		ns.appDieChan,
		ns.replaceConnection,
		nats.RetryOnFailedConnect(true),
		nats.MaxReconnects(ns.maxReconnectionRetries),
		nats.Timeout(ns.connectionTimeout),
		nats.Compression(ns.websocketCompression),
		nats.ReconnectJitter(ns.reconnectJitter, ns.reconnectJitterTLS),
		nats.ReconnectWait(ns.reconnectWait),
		nats.PingInterval(ns.pingInterval),
		nats.MaxPingsOutstanding(ns.maxPingsOutstanding),
	)
	if err != nil {
		return err
	}
	ns.conn = conn
	if ns.sub, err = ns.subscribe(getChannel(ns.server.Type, ns.server.ID)); err != nil {
		return err
	}

	err = ns.subscribeToBindingsChannel()
	if err != nil {
		return err
	}

	// Re-subscribe to all session subscriptions if this is a replacement
	// The onSessionBind callback is already set up, we just need to trigger it for existing sessions
	if isReplacement && ns.server.Frontend && ns.sessionPool != nil {
		ns.sessionPool.ForEachSession(func(s session.Session) {
			if s.GetIsFrontend() && s.UID() != "" {
				// Re-use the same subscription logic as onSessionBind
				if err := ns.onSessionBind(context.Background(), s); err != nil {
					logger.Log.Errorf("failed to re-subscribe session for user %s: %v", s.UID(), err)
				}
			}
		})
	}

	if !isReplacement {
		// this handles remote messages
		for i := 0; i < ns.service; i++ {
			go ns.processMessages(i)
		}

		ns.sessionPool.OnSessionBind(ns.onSessionBind)

		// this should be so fast that we shoudn't need concurrency
		go ns.processPushes()
		go ns.processSessionBindings()
		go ns.processKick()
	}

	if isReplacement {
		logger.Log.Infof("successfully replaced nats server connection")
	}

	return nil
}

// AfterInit runs after initialization
func (ns *NatsRPCServer) AfterInit() {}

// BeforeShutdown runs before shutdown
func (ns *NatsRPCServer) BeforeShutdown() {}

// Shutdown stops nats rpc server
func (ns *NatsRPCServer) Shutdown() error {
	close(ns.stopChan)
	return nil
}

func (ns *NatsRPCServer) subscribe(topic string) (*nats.Subscription, error) {
	return ns.conn.ChanSubscribe(topic, ns.subChan)
}

func (ns *NatsRPCServer) stop() {
}

func (ns *NatsRPCServer) reportMetrics() {
	if ns.metricsReporters != nil {
		for _, mr := range ns.metricsReporters {
			if err := mr.ReportGauge(metrics.DroppedMessages, map[string]string{}, float64(ns.dropped)); err != nil {
				logger.Log.Warnf("failed to report dropped message: %s", err.Error())
			}

			// subchan
			subChanCapacity := ns.messagesBufferSize - len(ns.subChan)
			if subChanCapacity == 0 {
				logger.Log.Warn("subChan is at maximum capacity")
			}
			if err := mr.ReportHistogram(metrics.ChannelCapacity, map[string]string{"channel": "rpc_server_subchan"}, float64(subChanCapacity)); err != nil {
				logger.Log.Warnf("failed to report subChan queue capacity: %s", err.Error())
			}
			// bindingschan
			bindingsChanCapacity := ns.messagesBufferSize - len(ns.bindingsChan)
			if bindingsChanCapacity == 0 {
				logger.Log.Warn("bindingsChan is at maximum capacity")
			}
			if err := mr.ReportHistogram(metrics.ChannelCapacity, map[string]string{"channel": "rpc_server_bindingschan"}, float64(bindingsChanCapacity)); err != nil {
				logger.Log.Warnf("failed to report bindingsChan capacity: %s", err.Error())
			}

			// userpushch
			userPushChanCapacity := ns.pushBufferSize - len(ns.userPushCh)
			if userPushChanCapacity == 0 {
				logger.Log.Warn("userPushChan is at maximum capacity")
			}
			if err := mr.ReportHistogram(metrics.ChannelCapacity, map[string]string{"channel": "rpc_server_userpushchan"}, float64(userPushChanCapacity)); err != nil {
				logger.Log.Warnf("failed to report userPushCh capacity: %s", err.Error())
			}
		}
	}
}

// IsConnected returns true if NATS connection is established
func (ns *NatsRPCServer) IsConnected() bool {
	return ns.conn != nil && ns.conn.IsConnected()
}

```

`pkg/cluster/nats_rpc_server_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package cluster

import (
	"context"
	"fmt"
	"reflect"
	"testing"
	"time"

	"github.com/golang/mock/gomock"
	"github.com/golang/protobuf/proto"
	nats "github.com/nats-io/nats.go"
	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/helpers"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
	metricsmocks "github.com/topfreegames/pitaya/v3/pkg/metrics/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	protosmocks "github.com/topfreegames/pitaya/v3/pkg/protos/mocks"
	sessionmocks "github.com/topfreegames/pitaya/v3/pkg/session/mocks"
)

type funcPtrMatcher struct {
	ptr uintptr
}

func newFuncPtrMatcher(x interface{}) *funcPtrMatcher {
	if reflect.ValueOf(x).Kind() != reflect.Func {
		panic("funcPtrMatcher only accepts functions as arguments")
	}
	return &funcPtrMatcher{
		ptr: reflect.ValueOf(x).Pointer(),
	}
}

func (m funcPtrMatcher) Matches(x interface{}) bool {
	v := reflect.ValueOf(x)
	switch v.Kind() {
	case reflect.Func:
		ptr := reflect.ValueOf(x).Pointer()
		return ptr == m.ptr
	default:
		return false
	}
}

func (m funcPtrMatcher) String() string {
	return fmt.Sprintf("has address %d", m.ptr)
}

func TestNewNatsRPCServer(t *testing.T) {
	t.Parallel()
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockMetricsReporter := metricsmocks.NewMockReporter(ctrl)
	mockMetricsReporters := []metrics.Reporter{mockMetricsReporter}
	mockSessionPool := sessionmocks.NewMockSessionPool(ctrl)

	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Nats
	sv := getServer()
	n, err := NewNatsRPCServer(cfg, sv, mockMetricsReporters, nil, mockSessionPool)
	assert.NoError(t, err)
	assert.NotNil(t, n)
	assert.Equal(t, sv, n.server)
	assert.Equal(t, mockMetricsReporters, n.metricsReporters)
}

func TestNatsRPCServerConfigure(t *testing.T) {
	t.Parallel()
	tables := []struct {
		natsConnect        string
		messagesBufferSize int
		pushBufferSize     int
		err                error
	}{
		{"nats://localhost:2333", 10, 10, nil},
		{"nats://localhost:2333", 10, 0, constants.ErrNatsPushBufferSizeZero},
		{"nats://localhost:2333", 0, 10, constants.ErrNatsMessagesBufferSizeZero},
		{"", 10, 10, constants.ErrNoNatsConnectionString},
	}

	for _, table := range tables {
		t.Run(fmt.Sprintf("%s-%d-%d", table.natsConnect, table.messagesBufferSize, table.pushBufferSize), func(t *testing.T) {
			cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Nats
			cfg.Connect = table.natsConnect
			cfg.Buffer.Messages = table.messagesBufferSize
			cfg.Buffer.Push = table.pushBufferSize
			_, err := NewNatsRPCServer(cfg, getServer(), nil, nil, nil)
			assert.Equal(t, table.err, err)
		})
	}
}

func TestNatsRPCServerGetUserMessagesTopic(t *testing.T) {
	t.Parallel()
	assert.Equal(t, "pitaya/connector/user/bla/push", GetUserMessagesTopic("bla", "connector"))
	assert.Equal(t, "pitaya/game/user/123bla/push", GetUserMessagesTopic("123bla", "game"))
	assert.Equal(t, "pitaya/connector/user/1/push", GetUserMessagesTopic("1", "connector"))
}

func TestNatsRPCServerGetUserKickTopic(t *testing.T) {
	t.Parallel()
	assert.Equal(t, "pitaya/connector/user/0/kick", GetUserKickTopic("0", "connector"))
	assert.Equal(t, "pitaya/game/user/1/kick", GetUserKickTopic("1", "game"))
	assert.Equal(t, "pitaya/connector/user/10/kick", GetUserKickTopic("10", "connector"))
	assert.Equal(t, "pitaya/game/user/11/kick", GetUserKickTopic("11", "game"))
}

func TestNatsRPCServerGetUnhandledRequestsChannel(t *testing.T) {
	t.Parallel()
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Nats
	sv := getServer()
	n, _ := NewNatsRPCServer(cfg, sv, nil, nil, nil)
	assert.NotNil(t, n.GetUnhandledRequestsChannel())
	assert.IsType(t, make(chan *protos.Request), n.GetUnhandledRequestsChannel())
}

func TestNatsRPCServerGetBindingsChannel(t *testing.T) {
	t.Parallel()
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Nats
	sv := getServer()
	n, _ := NewNatsRPCServer(cfg, sv, nil, nil, nil)
	assert.Equal(t, n.bindingsChan, n.GetBindingsChannel())
}

func TestNatsRPCServerOnSessionBind(t *testing.T) {
	t.Parallel()
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Nats
	sv := getServer()

	ctrl := gomock.NewController(t)
	mockSession := sessionmocks.NewMockSession(ctrl)
	mockSession.EXPECT().UID().Return("uid").Times(2)
	mockSession.EXPECT().SetSubscriptions(gomock.Len(2)).Times(1)

	rpcServer, _ := NewNatsRPCServer(cfg, sv, nil, nil, nil)
	s := helpers.GetTestNatsServer(t)
	defer s.Shutdown()
	conn, err := setupNatsConn(fmt.Sprintf("nats://%s", s.Addr()), nil, nil)
	assert.NoError(t, err)
	rpcServer.conn = conn
	err = rpcServer.onSessionBind(context.Background(), mockSession)
	assert.NoError(t, err)
	assert.NotNil(t, rpcServer.userKickCh)
}

func TestNatsRPCServerSubscribeToBindingsChannel(t *testing.T) {
	t.Parallel()
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Nats
	sv := getServer()
	rpcServer, _ := NewNatsRPCServer(cfg, sv, nil, nil, nil)
	s := helpers.GetTestNatsServer(t)
	defer s.Shutdown()
	conn, err := setupNatsConn(fmt.Sprintf("nats://%s", s.Addr()), nil, nil)
	assert.NoError(t, err)
	rpcServer.conn = conn
	err = rpcServer.subscribeToBindingsChannel()
	assert.NoError(t, err)
	dt := []byte("somedata")
	conn.Publish(GetBindBroadcastTopic(sv.Type), dt)
	msg := helpers.ShouldEventuallyReceive(t, rpcServer.GetBindingsChannel()).(*nats.Msg)
	assert.Equal(t, msg.Data, dt)
}

func TestNatsRPCServerSubscribeUserKickChannel(t *testing.T) {
	t.Parallel()
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Nats
	sv := getServer()
	rpcServer, _ := NewNatsRPCServer(cfg, sv, nil, nil, nil)
	s := helpers.GetTestNatsServer(t)
	defer s.Shutdown()
	conn, err := setupNatsConn(fmt.Sprintf("nats://%s", s.Addr()), nil, nil)
	assert.NoError(t, err)
	rpcServer.conn = conn
	sub, err := rpcServer.subscribeToUserKickChannel("someuid", sv.Type)
	assert.NoError(t, err)
	assert.NotNil(t, sub)
	kick := &protos.KickMsg{UserId: "randomid"}
	dt, err := proto.Marshal(kick)
	assert.NoError(t, err)
	err = conn.Publish(GetUserKickTopic("someuid", sv.Type), dt)
	assert.NoError(t, err)
	msg := helpers.ShouldEventuallyReceive(t, rpcServer.getUserKickChannel()).(*protos.KickMsg)
	assert.Equal(t, msg.UserId, kick.UserId)
}

func TestNatsRPCServerGetUserPushChannel(t *testing.T) {
	t.Parallel()
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Nats
	sv := getServer()
	n, _ := NewNatsRPCServer(cfg, sv, nil, nil, nil)
	assert.NotNil(t, n.getUserPushChannel())
	assert.IsType(t, make(chan *protos.Push), n.getUserPushChannel())
}

func TestNatsRPCServerGetUserKickChannel(t *testing.T) {
	t.Parallel()
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Nats
	sv := getServer()
	n, _ := NewNatsRPCServer(cfg, sv, nil, nil, nil)
	assert.NotNil(t, n.getUserKickChannel())
	assert.IsType(t, make(chan *protos.KickMsg), n.getUserKickChannel())
}

func TestNatsRPCServerSubscribeToUserMessages(t *testing.T) {
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Nats
	sv := getServer()
	rpcServer, _ := NewNatsRPCServer(cfg, sv, nil, nil, nil)
	s := helpers.GetTestNatsServer(t)
	defer s.Shutdown()
	conn, err := setupNatsConn(fmt.Sprintf("nats://%s", s.Addr()), nil, nil)
	assert.NoError(t, err)
	rpcServer.conn = conn
	tables := []struct {
		uid    string
		svType string
		msg    []byte
	}{
		{"user1", "conn", []byte("msg1")},
		{"user2", "game", []byte("")},
		{"u", "conn", []byte("000")},
	}

	for _, table := range tables {
		t.Run(table.uid, func(t *testing.T) {
			subs, err := rpcServer.subscribeToUserMessages(table.uid, table.svType)
			assert.NoError(t, err)
			assert.Equal(t, true, subs.IsValid())
			conn.Publish(GetUserMessagesTopic(table.uid, table.svType), table.msg)
			helpers.ShouldEventuallyReceive(t, rpcServer.userPushCh)
		})
	}
}

func TestNatsRPCServerSubscribe(t *testing.T) {
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Nats
	sv := getServer()
	rpcServer, _ := NewNatsRPCServer(cfg, sv, nil, nil, nil)
	s := helpers.GetTestNatsServer(t)
	defer s.Shutdown()
	conn, err := setupNatsConn(fmt.Sprintf("nats://%s", s.Addr()), nil, nil)
	assert.NoError(t, err)
	rpcServer.conn = conn
	tables := []struct {
		topic string
		msg   []byte
	}{
		{"user1/messages", []byte("msg1")},
		{"user2/messages", []byte("")},
		{"u/messages", []byte("000")},
	}

	for _, table := range tables {
		t.Run(table.topic, func(t *testing.T) {
			subs, err := rpcServer.subscribe(table.topic)
			assert.NoError(t, err)
			assert.Equal(t, true, subs.IsValid())
			conn.Publish(table.topic, table.msg)
			r := helpers.ShouldEventuallyReceive(t, rpcServer.subChan).(*nats.Msg)
			assert.Equal(t, table.msg, r.Data)
		})
	}
}

func TestNatsRPCServerHandleMessages(t *testing.T) {
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Nats
	sv := getServer()
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockMetricsReporter := metricsmocks.NewMockReporter(ctrl)
	mockMetricsReporters := []metrics.Reporter{mockMetricsReporter}

	rpcServer, _ := NewNatsRPCServer(cfg, sv, mockMetricsReporters, nil, nil)
	s := helpers.GetTestNatsServer(t)
	defer s.Shutdown()
	conn, err := setupNatsConn(fmt.Sprintf("nats://%s", s.Addr()), nil, nil)
	assert.NoError(t, err)
	rpcServer.conn = conn
	tables := []struct {
		topic string
		req   *protos.Request
	}{
		{"user1/messages", &protos.Request{Type: protos.RPCType_Sys, FrontendID: "bla", Msg: &protos.Msg{Id: 1, Reply: "ae"}}},
		{"user2/messages", &protos.Request{Type: protos.RPCType_User, FrontendID: "bla2", Msg: &protos.Msg{Id: 1}}},
	}

	go rpcServer.handleMessages()

	for _, table := range tables {
		t.Run(table.topic, func(t *testing.T) {
			subs, err := rpcServer.subscribe(table.topic)
			assert.NoError(t, err)
			assert.Equal(t, true, subs.IsValid())
			b, err := proto.Marshal(table.req)
			assert.NoError(t, err)

			mockMetricsReporter.EXPECT().ReportGauge(metrics.DroppedMessages, gomock.Any(), float64(0))
			mockMetricsReporter.EXPECT().ReportHistogram(metrics.ChannelCapacity, gomock.Any(), gomock.Any()).Times(3)

			conn.Publish(table.topic, b)
			r := helpers.ShouldEventuallyReceive(t, rpcServer.unhandledReqCh).(*protos.Request)
			assert.Equal(t, table.req.FrontendID, r.FrontendID)
			assert.Equal(t, table.req.Msg.Id, r.Msg.Id)
		})
	}
}

func TestNatsRPCServerInitShouldFailIfConnFails(t *testing.T) {
	t.Parallel()
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Nats
	cfg.Connect = "nats://localhost:1"
	sv := getServer()

	ctrl := gomock.NewController(t)
	mockSessionPool := sessionmocks.NewMockSessionPool(ctrl)
	rpcServer, _ := NewNatsRPCServer(cfg, sv, nil, nil, mockSessionPool)
	//mockSessionPool.EXPECT().OnSessionBind(rpcServer.onSessionBind)
	err := rpcServer.Init()
	assert.Error(t, err)
}

func TestNatsRPCServerInit(t *testing.T) {
	s := helpers.GetTestNatsServer(t)
	ctrl := gomock.NewController(t)
	defer s.Shutdown()
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Nats
	cfg.Connect = fmt.Sprintf("nats://%s", s.Addr())
	sv := getServer()

	mockSessionPool := sessionmocks.NewMockSessionPool(ctrl)
	rpcServer, _ := NewNatsRPCServer(cfg, sv, nil, nil, mockSessionPool)
	mockSessionPool.EXPECT().OnSessionBind(newFuncPtrMatcher(rpcServer.onSessionBind))
	err := rpcServer.Init()
	assert.NoError(t, err)
	// should setup conn
	assert.NotNil(t, rpcServer.conn)
	assert.True(t, rpcServer.conn.IsConnected())
	// should subscribe
	assert.True(t, rpcServer.sub.IsValid())
	//should handle messages
	tables := []struct {
		name  string
		topic string
		req   *protos.Request
	}{
		{"test1", getChannel(sv.Type, sv.ID), &protos.Request{Type: protos.RPCType_Sys, FrontendID: "bla", Msg: &protos.Msg{Id: 1, Reply: "ae"}}},
		{"test2", getChannel(sv.Type, sv.ID), &protos.Request{Type: protos.RPCType_User, FrontendID: "bla2", Msg: &protos.Msg{Id: 1, Reply: "boa"}}},
	}
	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			c := make(chan *nats.Msg)
			rpcServer.conn.ChanSubscribe(table.req.Msg.Reply, c)
			rpcServer.unhandledReqCh <- table.req
			r := helpers.ShouldEventuallyReceive(t, c).(*nats.Msg)
			assert.NotNil(t, r.Data)
		})
	}
}

func TestNatsRPCServerProcessBindings(t *testing.T) {
	ctrl := gomock.NewController(t)
	s := helpers.GetTestNatsServer(t)
	defer s.Shutdown()
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Nats
	cfg.Connect = fmt.Sprintf("nats://%s", s.Addr())
	sv := getServer()
	mockSessionPool := sessionmocks.NewMockSessionPool(ctrl)
	rpcServer, _ := NewNatsRPCServer(cfg, sv, nil, nil, mockSessionPool)
	mockSessionPool.EXPECT().OnSessionBind(newFuncPtrMatcher(rpcServer.onSessionBind))
	err := rpcServer.Init()

	assert.NoError(t, err)

	pitayaSvMock := protosmocks.NewMockPitayaServer(ctrl)
	defer ctrl.Finish()

	rpcServer.SetPitayaServer(pitayaSvMock)

	bindMsg := &protos.BindMsg{
		Uid: "testuid",
		Fid: "testfid",
	}

	bindData, err := proto.Marshal(bindMsg)
	assert.NoError(t, err)

	msg := &nats.Msg{
		Data: bindData,
	}

	unmarshalledMsg := &protos.BindMsg{}
	_ = proto.Unmarshal(bindData, unmarshalledMsg)

	pitayaSvMock.EXPECT().SessionBindRemote(context.Background(), unmarshalledMsg).Do(func(ctx context.Context, b *protos.BindMsg) {
		assert.Equal(t, bindMsg.Uid, b.Uid)
		assert.Equal(t, bindMsg.Fid, b.Fid)
	})

	rpcServer.bindingsChan <- msg
	time.Sleep(30 * time.Millisecond)
}

func TestNatsRPCServerProcessPushes(t *testing.T) {
	s := helpers.GetTestNatsServer(t)
	ctrl := gomock.NewController(t)
	defer s.Shutdown()
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Nats
	cfg.Connect = fmt.Sprintf("nats://%s", s.Addr())
	sv := getServer()
	mockSessionPool := sessionmocks.NewMockSessionPool(ctrl)
	rpcServer, _ := NewNatsRPCServer(cfg, sv, nil, nil, mockSessionPool)
	mockSessionPool.EXPECT().OnSessionBind(newFuncPtrMatcher(rpcServer.onSessionBind))
	err := rpcServer.Init()

	assert.NoError(t, err)

	pitayaSvMock := protosmocks.NewMockPitayaServer(ctrl)
	defer ctrl.Finish()

	rpcServer.SetPitayaServer(pitayaSvMock)

	push := &protos.Push{
		Route: "someroute",
		Uid:   "someuid",
		Data:  []byte{0x01},
	}

	pitayaSvMock.EXPECT().PushToUser(context.Background(), push).Do(func(ctx context.Context, p *protos.Push) {
		assert.Equal(t, push.Route, p.Route)
		assert.Equal(t, push.Uid, p.Uid)
		assert.Equal(t, push.Data, p.Data)
	})

	rpcServer.userPushCh <- push
	time.Sleep(30 * time.Millisecond)
}

func TestNatsRPCServerProcessKick(t *testing.T) {
	s := helpers.GetTestNatsServer(t)
	ctrl := gomock.NewController(t)
	defer s.Shutdown()
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Nats
	cfg.Connect = fmt.Sprintf("nats://%s", s.Addr())
	sv := getServer()
	mockSessionPool := sessionmocks.NewMockSessionPool(ctrl)
	rpcServer, _ := NewNatsRPCServer(cfg, sv, nil, nil, mockSessionPool)
	mockSessionPool.EXPECT().OnSessionBind(newFuncPtrMatcher(rpcServer.onSessionBind))
	err := rpcServer.Init()

	assert.NoError(t, err)

	pitayaSvMock := protosmocks.NewMockPitayaServer(ctrl)
	defer ctrl.Finish()

	rpcServer.SetPitayaServer(pitayaSvMock)

	kick := &protos.KickMsg{
		UserId: "someuid",
	}

	pitayaSvMock.EXPECT().KickUser(gomock.Any(), kick).Do(func(ctx context.Context, p *protos.KickMsg) {
		assert.Equal(t, kick.UserId, p.UserId)
	})

	rpcServer.userKickCh <- kick
	time.Sleep(30 * time.Millisecond)
}

func TestNatsRPCServerReportMetrics(t *testing.T) {
	cfg := config.NewDefaultPitayaConfig().Cluster.RPC.Server.Nats
	sv := getServer()
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockMetricsReporter := metricsmocks.NewMockReporter(ctrl)
	mockMetricsReporters := []metrics.Reporter{mockMetricsReporter}

	rpcServer, _ := NewNatsRPCServer(cfg, sv, mockMetricsReporters, nil, nil)
	rpcServer.dropped = 100
	rpcServer.messagesBufferSize = 100
	rpcServer.pushBufferSize = 100

	rpcServer.subChan <- &nats.Msg{}
	rpcServer.bindingsChan <- &nats.Msg{}
	rpcServer.userPushCh <- &protos.Push{}

	mockMetricsReporter.EXPECT().ReportGauge(metrics.DroppedMessages, gomock.Any(), float64(rpcServer.dropped))
	mockMetricsReporter.EXPECT().ReportHistogram(metrics.ChannelCapacity, gomock.Any(), float64(99)).Times(3)
	rpcServer.reportMetrics()
}

```

`pkg/cluster/server.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package cluster

import (
	"encoding/json"
	"os"

	"github.com/topfreegames/pitaya/v3/pkg/logger"
)

// Server struct
type Server struct {
	ID       string            `json:"id"`
	Type     string            `json:"type"`
	Metadata map[string]string `json:"metadata"`
	Frontend bool              `json:"frontend"`
	Hostname string            `json:"hostname"`
}

// NewServer ctor
func NewServer(id, serverType string, frontend bool, metadata ...map[string]string) *Server {
	d := make(map[string]string)
	h, err := os.Hostname()
	if err != nil {
		logger.Log.Errorf("failed to get hostname: %s", err.Error())
	}
	if len(metadata) > 0 {
		d = metadata[0]
	}
	return &Server{
		ID:       id,
		Type:     serverType,
		Metadata: d,
		Frontend: frontend,
		Hostname: h,
	}
}

// AsJSONString returns the server as a json string
func (s *Server) AsJSONString() string {
	str, err := json.Marshal(s)
	if err != nil {
		logger.Log.Errorf("error getting server as json: %s", err.Error())
		return ""
	}
	return string(str)
}

```

`pkg/cluster/server_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package cluster

import (
	"encoding/json"
	"testing"

	"github.com/stretchr/testify/assert"
)

var svTestTables = []struct {
	id       string
	svType   string
	metadata map[string]string
	frontend bool
}{
	{"someid-1", "somesvtype", map[string]string{"bla": "ola"}, true},
	{"someid-2", "somesvtype", nil, true},
	{"someid-3", "somesvtype", map[string]string{"sv": "game"}, false},
	{"someid-4", "somesvtype", map[string]string{}, false},
}

func TestNewServer(t *testing.T) {
	t.Parallel()
	for _, table := range svTestTables {
		t.Run(table.id, func(t *testing.T) {
			s := NewServer(table.id, table.svType, table.frontend, table.metadata)
			assert.Equal(t, table.id, s.ID)
			assert.Equal(t, table.metadata, s.Metadata)
			assert.Equal(t, table.frontend, s.Frontend)
			assert.NotNil(t, s.Hostname)
		})
	}
}

func TestAsJSONString(t *testing.T) {
	t.Parallel()
	for _, table := range svTestTables {
		t.Run(table.id, func(t *testing.T) {
			s := NewServer(table.id, table.svType, table.frontend, table.metadata)
			b, err := json.Marshal(s)
			assert.NoError(t, err)
			assert.Equal(t, string(b), s.AsJSONString())
		})
	}
}

```

`pkg/cluster/service_discovery.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package cluster

import (
	"context"

	"github.com/topfreegames/pitaya/v3/pkg/interfaces"
)

// ServiceDiscovery is the interface for a service discovery client
type ServiceDiscovery interface {
	GetServersByType(serverType string) (map[string]*Server, error)
	GetServer(id string) (*Server, error)
	GetServers() []*Server
	SyncServers(firstSync bool) error
	AddListener(listener SDListener)
	IsConnected(ctx context.Context) bool
	interfaces.Module
}

```

`pkg/component.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package pitaya

import (
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
)

type regComp struct {
	comp component.Component
	opts []component.Option
}

// Register register a component with options
func (app *App) Register(c component.Component, options ...component.Option) {
	app.handlerComp = append(app.handlerComp, regComp{c, options})
}

// RegisterRemote register a remote component with options
func (app *App) RegisterRemote(c component.Component, options ...component.Option) {
	app.remoteComp = append(app.remoteComp, regComp{c, options})
}

func (app *App) startupComponents() {
	// handler component initialize hooks
	for _, c := range app.handlerComp {
		c.comp.Init()
	}

	// handler component after initialize hooks
	for _, c := range app.handlerComp {
		c.comp.AfterInit()
	}

	// remote component initialize hooks
	for _, c := range app.remoteComp {
		c.comp.Init()
	}

	// remote component after initialize hooks
	for _, c := range app.remoteComp {
		c.comp.AfterInit()
	}

	// register all components
	for _, c := range app.handlerComp {
		if err := app.handlerService.Register(c.comp, c.opts); err != nil {
			logger.Log.Errorf("Failed to register handler: %s", err.Error())
		}
	}

	// register all remote components
	for _, c := range app.remoteComp {
		if app.remoteService == nil {
			logger.Log.Warn("registered a remote component but remoteService is not running! skipping...")
		} else {
			if err := app.remoteService.Register(c.comp, c.opts); err != nil {
				logger.Log.Errorf("Failed to register remote: %s", err.Error())
			}
		}
	}

	app.handlerService.DumpServices()
	if app.remoteService != nil {
		app.remoteService.DumpServices()
	}
}

func (app *App) shutdownComponents() {
	// reverse call `BeforeShutdown` hooks
	length := len(app.handlerComp)
	for i := length - 1; i >= 0; i-- {
		app.handlerComp[i].comp.BeforeShutdown()
	}

	// reverse call `Shutdown` hooks
	for i := length - 1; i >= 0; i-- {
		app.handlerComp[i].comp.Shutdown()
	}

	length = len(app.remoteComp)
	for i := length - 1; i >= 0; i-- {
		app.remoteComp[i].comp.BeforeShutdown()
	}

	// reverse call `Shutdown` hooks
	for i := length - 1; i >= 0; i-- {
		app.remoteComp[i].comp.Shutdown()
	}
}

```

`pkg/component/base.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package component

// Base implements a default component for Component.
type Base struct{}

// Init was called to initialize the component.
func (c *Base) Init() {}

// AfterInit was called after the component is initialized.
func (c *Base) AfterInit() {}

// BeforeShutdown was called before the component to shutdown.
func (c *Base) BeforeShutdown() {}

// Shutdown was called to shutdown the component.
func (c *Base) Shutdown() {}

```

`pkg/component/component.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package component

// Component is the interface that represent a component.
type Component interface {
	Init()
	AfterInit()
	BeforeShutdown()
	Shutdown()
}

```

`pkg/component/method.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package component

import (
	"context"
	"reflect"
	"unicode"
	"unicode/utf8"

	"github.com/golang/protobuf/proto"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
)

var (
	typeOfError    = reflect.TypeOf((*error)(nil)).Elem()
	typeOfBytes    = reflect.TypeOf(([]byte)(nil))
	typeOfContext  = reflect.TypeOf(new(context.Context)).Elem()
	typeOfProtoMsg = reflect.TypeOf(new(proto.Message)).Elem()
)

func isExported(name string) bool {
	w, _ := utf8.DecodeRuneInString(name)
	return unicode.IsUpper(w)
}

// isRemoteMethod decide a method is suitable remote method
func isRemoteMethod(method reflect.Method) bool {
	mt := method.Type
	// Method must be exported.
	if method.PkgPath != "" {
		return false
	}

	// Method needs at least two ins: receiver and context.Context
	if mt.NumIn() != 2 && mt.NumIn() != 3 {
		return false
	}

	if t1 := mt.In(1); !t1.Implements(typeOfContext) {
		return false
	}

	if mt.NumIn() == 3 {
		if t2 := mt.In(2); !t2.Implements(typeOfProtoMsg) {
			return false
		}
	}

	// Method needs two outs: interface{}(that implements proto.Message), error
	if mt.NumOut() != 2 {
		return false
	}

	if (mt.Out(0).Kind() != reflect.Ptr) || mt.Out(1) != typeOfError {
		return false
	}

	if o0 := mt.Out(0); !o0.Implements(typeOfProtoMsg) {
		return false
	}

	return true
}

// isHandlerMethod decide a method is suitable handler method
func isHandlerMethod(method reflect.Method) bool {
	mt := method.Type
	// Method must be exported.
	if method.PkgPath != "" {
		return false
	}

	// Method needs two or three ins: receiver, context.Context and optional []byte or pointer.
	if mt.NumIn() != 2 && mt.NumIn() != 3 {
		return false
	}

	if t1 := mt.In(1); !t1.Implements(typeOfContext) {
		return false
	}

	if mt.NumIn() == 3 && mt.In(2).Kind() != reflect.Ptr && mt.In(2) != typeOfBytes {
		return false
	}

	// Method needs either no out or two outs: interface{}(or []byte), error
	if mt.NumOut() != 0 && mt.NumOut() != 2 {
		return false
	}

	if mt.NumOut() == 2 && (mt.Out(1) != typeOfError || mt.Out(0) != typeOfBytes && mt.Out(0).Kind() != reflect.Ptr) {
		return false
	}

	return true
}

func suitableRemoteMethods(typ reflect.Type, nameFunc func(string) string) map[string]*Remote {
	methods := make(map[string]*Remote)
	for m := 0; m < typ.NumMethod(); m++ {
		method := typ.Method(m)
		mt := method.Type
		mn := method.Name
		if isRemoteMethod(method) {
			// rewrite remote name
			if nameFunc != nil {
				mn = nameFunc(mn)
			}
			methods[mn] = &Remote{
				Method:  method,
				HasArgs: method.Type.NumIn() == 3,
			}
			if mt.NumIn() == 3 {
				methods[mn].Type = mt.In(2)
			}
		}
	}
	return methods
}

func suitableHandlerMethods(typ reflect.Type, nameFunc func(string) string) map[string]*Handler {
	methods := make(map[string]*Handler)
	for m := 0; m < typ.NumMethod(); m++ {
		method := typ.Method(m)
		mt := method.Type
		mn := method.Name
		if isHandlerMethod(method) {
			raw := false
			if mt.NumIn() == 3 && mt.In(2) == typeOfBytes {
				raw = true
			}
			// rewrite handler name
			if nameFunc != nil {
				mn = nameFunc(mn)
			}
			var msgType message.Type
			if mt.NumOut() == 0 {
				msgType = message.Notify
			} else {
				msgType = message.Request
			}
			handler := &Handler{
				Method:      method,
				IsRawArg:    raw,
				MessageType: msgType,
			}
			if mt.NumIn() == 3 {
				handler.Type = mt.In(2)
			}
			methods[mn] = handler
		}
	}
	return methods
}

```

`pkg/component/method_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package component

import (
	"context"
	"reflect"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/protos/test"
)

type TestType struct {
	Base
}

func (t *TestType) ExportedNoHandlerNorRemote()                                                {}
func (t *TestType) ExportedHandlerWithOnlySession(ctx context.Context)                         {}
func (t *TestType) ExportedHandlerWithSessionAndRawWithNoOuts(ctx context.Context, msg []byte) {}
func (t *TestType) ExportedHandlerWithSessionAndPointerWithRawOut(ctx context.Context, tt *TestType) ([]byte, error) {
	return nil, nil
}
func (t *TestType) ExportedHandlerWithSessionAndPointerWithPointerOut(ctx context.Context, tt *TestType) (*TestType, error) {
	return nil, nil
}
func (t *TestType) ExportedRemoteRawOut(ctx context.Context) (*test.SomeStruct, error) {
	return nil, nil
}
func (t *TestType) ExportedRemotePointerOut(ctx context.Context) (*test.SomeStruct, error) {
	return nil, nil
}

func TestIsExported(t *testing.T) {
	t.Parallel()
	tables := []struct {
		method string
		res    bool
	}{
		{"notExported", false},
		{"Exported", true},
	}

	for _, table := range tables {
		t.Run(table.method, func(t *testing.T) {
			assert.Equal(t, table.res, isExported(table.method))
		})
	}
}

func TestIsRemoteMethod(t *testing.T) {
	t.Parallel()
	tables := []struct {
		methodName string
		isRemote   bool
	}{
		{"ExportedNoHandlerNorRemote", false},
		{"ExportedHandlerWithOnlySession", false},
		{"ExportedHandlerWithSessionAndRawWithNoOuts", false},
		{"ExportedRemoteRawOut", true},
		{"ExportedRemotePointerOut", true},
	}

	for _, table := range tables {
		t.Run(table.methodName, func(t *testing.T) {
			tObj := &TestType{}
			m, ok := reflect.TypeOf(tObj).MethodByName(table.methodName)
			assert.True(t, ok)
			assert.NotNil(t, m)
			assert.Equal(t, table.isRemote, isRemoteMethod(m))
		})
	}
}

func TestIsHandleMethod(t *testing.T) {
	t.Parallel()
	tables := []struct {
		methodName string
		isRemote   bool
	}{
		{"ExportedNoHandlerNorRemote", false},
		{"ExportedHandlerWithOnlySession", true},
		{"ExportedHandlerWithSessionAndRawWithNoOuts", true},
		{"ExportedHandlerWithSessionAndPointerWithRawOut", true},
		{"ExportedHandlerWithSessionAndPointerWithPointerOut", true},
	}
	for _, table := range tables {
		t.Run(table.methodName, func(t *testing.T) {
			tObj := &TestType{}
			m, ok := reflect.TypeOf(tObj).MethodByName(table.methodName)
			assert.True(t, ok)
			assert.NotNil(t, m)
			assert.Equal(t, table.isRemote, isHandlerMethod(m))
		})
	}
}

func TestSuitableRemoteMethods(t *testing.T) {
	t.Parallel()
	tables := []struct {
		name     string
		nameFunc func(string) string
		outKeys  []string
	}{
		{"noNameFunc", nil, []string{"ExportedRemotePointerOut", "ExportedRemoteRawOut"}},
		{"withNameFunc", strings.ToLower, []string{"exportedremotepointerout", "exportedremoterawout"}},
	}
	tObj := &TestType{}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			out := suitableRemoteMethods(reflect.TypeOf(tObj), table.nameFunc)
			for _, r := range table.outKeys {
				val, ok := out[r]
				assert.True(t, ok)
				assert.NotNil(t, val)
			}
		})
	}
}

func TestSuitableHandlerMethods(t *testing.T) {
	t.Parallel()
	tables := []struct {
		name     string
		nameFunc func(string) string
		outKeys  []string
	}{
		{"noNameFunc", nil, []string{"ExportedHandlerWithOnlySession", "ExportedHandlerWithSessionAndRawWithNoOuts", "ExportedHandlerWithSessionAndPointerWithRawOut", "ExportedHandlerWithSessionAndPointerWithPointerOut"}},
		{"withNameFunc", strings.ToLower, []string{"exportedhandlerwithonlysession", "exportedhandlerwithsessionandrawwithnoouts", "exportedhandlerwithsessionandpointerwithrawout", "exportedhandlerwithsessionandpointerwithpointerout"}},
	}
	tObj := &TestType{}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			out := suitableHandlerMethods(reflect.TypeOf(tObj), table.nameFunc)
			for _, r := range table.outKeys {
				val, ok := out[r]
				assert.True(t, ok)
				assert.NotNil(t, val)

			}
		})
	}

}

```

`pkg/component/options.go`:

```go
// Copyright (c) nano Authors and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package component

type (
	options struct {
		name     string              // component name
		nameFunc func(string) string // rename handler name
	}

	// Option used to customize handler
	Option func(options *options)
)

// WithName used to rename component name
func WithName(name string) Option {
	return func(opt *options) {
		opt.name = name
	}
}

// WithNameFunc override handler name by specific function
// such as: strings.ToUpper/strings.ToLower
func WithNameFunc(fn func(string) string) Option {
	return func(opt *options) {
		opt.nameFunc = fn
	}
}

```

`pkg/component/options_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package component

import (
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestWithName(t *testing.T) {
	name := "someName"
	opt := &options{}
	WithName(name)(opt)
	assert.Equal(t, name, opt.name)
}

func TestWithNameFunc(t *testing.T) {
	name := "somename"
	opt := &options{}
	nameFunc := func(s string) string {
		return strings.ToUpper(s)
	}
	WithNameFunc(nameFunc)(opt)
	assert.Equal(t, opt.nameFunc(name), strings.ToUpper(name))
}

```

`pkg/component/service.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package component

import (
	"errors"
	"reflect"

	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
)

type (
	//Handler represents a message.Message's handler's meta information.
	Handler struct {
		Receiver    reflect.Value  // receiver of method
		Method      reflect.Method // method stub
		Type        reflect.Type   // low-level type of method
		IsRawArg    bool           // whether the data need to serialize
		MessageType message.Type   // handler allowed message type (either request or notify)
	}

	//Remote represents remote's meta information.
	Remote struct {
		Receiver reflect.Value  // receiver of method
		Method   reflect.Method // method stub
		HasArgs  bool           // if remote has no args we won't try to serialize received data into arguments
		Type     reflect.Type   // low-level type of method
	}

	// Service implements a specific service, some of it's methods will be
	// called when the correspond events is occurred.
	Service struct {
		Name     string              // name of service
		Type     reflect.Type        // type of the receiver
		Receiver reflect.Value       // receiver of methods for the service
		Handlers map[string]*Handler // registered methods
		Remotes  map[string]*Remote  // registered remote methods
		Options  options             // options
	}
)

// NewService creates a new service
func NewService(comp Component, opts []Option) *Service {
	s := &Service{
		Type:     reflect.TypeOf(comp),
		Receiver: reflect.ValueOf(comp),
	}

	// apply options
	for i := range opts {
		opt := opts[i]
		opt(&s.Options)
	}
	if name := s.Options.name; name != "" {
		s.Name = name
	} else {
		s.Name = reflect.Indirect(s.Receiver).Type().Name()
	}

	return s
}

// ExtractHandler extract the set of methods from the
// receiver value which satisfy the following conditions:
// - exported method of exported type
// - one or two arguments
// - the first argument is context.Context
// - the second argument (if it exists) is []byte or a pointer
// - zero or two outputs
// - the first output is [] or a pointer
// - the second output is an error
func (s *Service) ExtractHandler() error {
	typeName := reflect.Indirect(s.Receiver).Type().Name()
	if typeName == "" {
		return errors.New("no service name for type " + s.Type.String())
	}
	if !isExported(typeName) {
		return errors.New("type " + typeName + " is not exported")
	}

	// Install the methods
	s.Handlers = suitableHandlerMethods(s.Type, s.Options.nameFunc)

	if len(s.Handlers) == 0 {
		str := ""
		// To help the user, see if a pointer receiver would work.
		method := suitableHandlerMethods(reflect.PtrTo(s.Type), s.Options.nameFunc)
		if len(method) != 0 {
			str = "type " + s.Name + " has no exported methods of handler type (hint: pass a pointer to value of that type)"
		} else {
			str = "type " + s.Name + " has no exported methods of handler type"
		}
		return errors.New(str)
	}

	for i := range s.Handlers {
		s.Handlers[i].Receiver = s.Receiver
	}

	return nil
}

// ExtractRemote extract the set of methods from the
// receiver value which satisfy the following conditions:
// - exported method of exported type
// - two return values
// - the first return implements protobuf interface
// - the second return is an error
func (s *Service) ExtractRemote() error {
	typeName := reflect.Indirect(s.Receiver).Type().Name()
	if typeName == "" {
		return errors.New("no service name for type " + s.Type.String())
	}
	if !isExported(typeName) {
		return errors.New("type " + typeName + " is not exported")
	}

	// Install the methods
	s.Remotes = suitableRemoteMethods(s.Type, s.Options.nameFunc)

	if len(s.Remotes) == 0 {
		str := ""
		// To help the user, see if a pointer receiver would work.
		method := suitableRemoteMethods(reflect.PtrTo(s.Type), s.Options.nameFunc)
		if len(method) != 0 {
			str = "type " + s.Name + " has no exported methods of remote type (hint: pass a pointer to value of that type)"
		} else {
			str = "type " + s.Name + " has no exported methods of remote type"
		}
		return errors.New(str)
	}

	for i := range s.Remotes {
		s.Remotes[i].Receiver = s.Receiver
	}
	return nil
}

// ValidateMessageType validates a given message type against the handler's one
// and returns an error if it is a mismatch and a boolean indicating if the caller should
// exit in the presence of this error or not.
func (h *Handler) ValidateMessageType(msgType message.Type) (exitOnError bool, err error) {
	if h.MessageType != msgType {
		switch msgType {
		case message.Request:
			err = constants.ErrRequestOnNotify
			exitOnError = true

		case message.Notify:
			err = constants.ErrNotifyOnRequest
		}
	}
	return
}

```

`pkg/component/service_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package component

import (
	"errors"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
)

type unexportedTestType struct {
	Base
}

type ExportedTypeWithNoHandlerAndNoRemote struct {
	Base
}

var tables = []struct {
	name     string
	comp     Component
	err      error
	handlers []string
	remotes  []string
}{
	{
		"valid",
		&TestType{},
		nil,
		[]string{"ExportedHandlerWithOnlySession", "ExportedHandlerWithSessionAndPointerWithPointerOut", "ExportedHandlerWithSessionAndPointerWithRawOut", "ExportedHandlerWithSessionAndRawWithNoOuts"},
		[]string{"ExportedRemotePointerOut", "ExportedRemoteRawOut"},
	},
	{"invalid", &unexportedTestType{}, errors.New("type unexportedTestType is not exported"), nil, nil},
	{"invalid", &ExportedTypeWithNoHandlerAndNoRemote{}, errors.New("type ExportedTypeWithNoHandlerAndNoRemote has no exported methods of handler type"), nil, nil},
}

func TestNewService(t *testing.T) {
	tables := []struct {
		name string
		opts []Option
	}{
		{"with-options", []Option{WithName("bla")}},
		{"without-options", []Option{}},
	}
	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			s := NewService(&Base{}, table.opts)
			assert.NotNil(t, s)
		})
	}
}

func TestExtractHandler(t *testing.T) {
	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			svc := NewService(table.comp, []Option{})
			err := svc.ExtractHandler()
			if table.err != nil {
				assert.EqualError(t, table.err, err.Error())
			} else {
				assert.NoError(t, err)
				for _, h := range table.handlers {
					val, ok := svc.Handlers[h]
					assert.True(t, ok)
					assert.NotNil(t, val)

				}
			}
		})
	}
}

func TestExtractRemote(t *testing.T) {
	tables[2].err = errors.New("type ExportedTypeWithNoHandlerAndNoRemote has no exported methods of remote type")
	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			svc := NewService(table.comp, []Option{})
			err := svc.ExtractRemote()
			if table.err != nil {
				assert.EqualError(t, table.err, err.Error())
			} else {
				assert.NoError(t, err)
				for _, r := range table.remotes {
					val, ok := svc.Remotes[r]
					assert.True(t, ok)
					assert.NotNil(t, val)

				}
			}
		})
	}
}

func TestValidateMessageType(t *testing.T) {
	mtTables := []struct {
		name       string
		methodName string
		tp         message.Type
		msgType    message.Type
		err        error
		exit       bool
	}{
		{"notify-msg-to-notify", "ExportedHandlerWithOnlySession", message.Notify, message.Notify, nil, false},
		{"request-msg-to-request", "ExportedHandlerWithSessionAndPointerWithRawOut", message.Request, message.Request, nil, false},
		{"request-msg-to-notify", "ExportedHandlerWithOnlySession", message.Notify, message.Request, constants.ErrRequestOnNotify, true},
		{"request-msg-to-request", "ExportedHandlerWithSessionAndPointerWithRawOut", message.Request, message.Notify, constants.ErrNotifyOnRequest, false},
	}
	tObj := &TestType{}
	svc := NewService(tObj, []Option{})
	svc.ExtractHandler()
	svc.ExtractRemote()
	for _, table := range mtTables {
		t.Run(table.methodName, func(t *testing.T) {
			assert.Equal(t, table.tp, svc.Handlers[table.methodName].MessageType)
			exit, err := svc.Handlers[table.methodName].ValidateMessageType(table.msgType)
			if table.err != nil {
				assert.EqualError(t, table.err, err.Error())
			}
			assert.Equal(t, table.exit, exit)
		})
	}
}

```

`pkg/component_test.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package pitaya

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/config"
)

type MyComp struct {
	component.Base
	running bool
}

func (m *MyComp) Init() {
	m.running = true
}

func (m *MyComp) Shutdown() {
	m.running = false
}

func TestRegister(t *testing.T) {
	config := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *config).(*App)
	b := &component.Base{}
	app.Register(b)
	assert.Equal(t, 1, len(app.handlerComp))
	assert.Equal(t, regComp{b, nil}, app.handlerComp[0])
}

func TestRegisterRemote(t *testing.T) {
	config := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *config).(*App)
	before := app.remoteComp
	b := &component.Base{}
	app.RegisterRemote(b)
	assert.Equal(t, len(before)+1, len(app.remoteComp))
	assert.Equal(t, regComp{b, nil}, app.remoteComp[len(before)])
}

func TestStartupComponents(t *testing.T) {
	app := NewDefaultApp(true, "testtype", Standalone, map[string]string{}, *config.NewDefaultPitayaConfig()).(*App)

	app.Register(&MyComp{})
	app.RegisterRemote(&MyComp{})
	app.startupComponents()
	assert.Equal(t, true, app.handlerComp[0].comp.(*MyComp).running)
}

func TestShutdownComponents(t *testing.T) {
	app := NewDefaultApp(true, "testtype", Standalone, map[string]string{}, *config.NewDefaultPitayaConfig()).(*App)

	app.Register(&MyComp{})
	app.RegisterRemote(&MyComp{})
	app.startupComponents()

	app.shutdownComponents()
	assert.Equal(t, false, app.handlerComp[0].comp.(*MyComp).running)
}

```

`pkg/config/config.go`:

```go
package config

import (
	"time"

	"github.com/topfreegames/pitaya/v3/pkg/metrics/models"
)

const DefaultWriteTimeout = 10 * time.Second

// PitayaConfig provides all the configuration for a pitaya app
type PitayaConfig struct {
	SerializerType   uint16 `mapstructure:"serializertype"`
	DefaultPipelines struct {
		StructValidation struct {
			Enabled bool `mapstructure:"enabled"`
		} `mapstructure:"structvalidation"`
	} `mapstructure:"defaultpipelines"`
	Modules   ModulesConfig
	Heartbeat struct {
		Interval time.Duration `mapstructure:"interval"`
	} `mapstructure:"heartbeat"`
	Handler struct {
		Messages struct {
			Compression bool `mapstructure:"compression"`
		} `mapstructure:"messages"`
	} `mapstructure:"handler"`
	Buffer struct {
		Agent struct {
			Messages     int           `mapstructure:"messages"`
			WriteTimeout time.Duration `mapstructure:"conntimeout"`
		} `mapstructure:"agent"`
		Handler struct {
			LocalProcess  int `mapstructure:"localprocess"`
			RemoteProcess int `mapstructure:"remoteprocess"`
		} `mapstructure:"handler"`
	} `mapstructure:"buffer"`
	Concurrency struct {
		Handler struct {
			Dispatch int `mapstructure:"dispatch"`
		} `mapstructure:"handler"`
	} `mapstructure:"concurrency"`
	Session struct {
		Unique bool `mapstructure:"unique"`
		Drain  struct {
			Enabled bool          `mapstructure:"enabled"`
			Timeout time.Duration `mapstructure:"timeout"`
			Period  time.Duration `mapstructure:"period"`
		} `mapstructure:"drain"`
	} `mapstructure:"session"`

	Acceptor struct {
		ProxyProtocol bool `mapstructure:"proxyprotocol"`
	} `mapstructure:"acceptor"`
	Conn struct {
		RateLimiting RateLimitingConfig `mapstructure:"rateLimiting"`
	} `mapstructure:"conn"`
	Metrics MetricsConfig `mapstructure:"metrics"`
	Cluster ClusterConfig `mapstructure:"cluster"`
	Groups  GroupsConfig  `mapstructure:"groups"`
	Worker  WorkerConfig  `mapstructure:"worker"`
}

// NewDefaultPitayaConfig provides default configuration for Pitaya App
func NewDefaultPitayaConfig() *PitayaConfig {
	return &PitayaConfig{
		SerializerType: 1,
		DefaultPipelines: struct {
			StructValidation struct {
				Enabled bool `mapstructure:"enabled"`
			} `mapstructure:"structvalidation"`
		}{
			StructValidation: struct {
				Enabled bool `mapstructure:"enabled"`
			}{
				Enabled: false,
			},
		},
		Heartbeat: struct {
			Interval time.Duration `mapstructure:"interval"`
		}{
			Interval: time.Duration(30 * time.Second),
		},
		Handler: struct {
			Messages struct {
				Compression bool `mapstructure:"compression"`
			} `mapstructure:"messages"`
		}{
			Messages: struct {
				Compression bool `mapstructure:"compression"`
			}{
				Compression: true,
			},
		},
		Buffer: struct {
			Agent struct {
				Messages     int           `mapstructure:"messages"`
				WriteTimeout time.Duration `mapstructure:"conntimeout"`
			} `mapstructure:"agent"`
			Handler struct {
				LocalProcess  int `mapstructure:"localprocess"`
				RemoteProcess int `mapstructure:"remoteprocess"`
			} `mapstructure:"handler"`
		}{
			Agent: struct {
				Messages     int           `mapstructure:"messages"`
				WriteTimeout time.Duration `mapstructure:"conntimeout"`
			}{
				Messages:     100,
				WriteTimeout: DefaultWriteTimeout,
			},
			Handler: struct {
				LocalProcess  int `mapstructure:"localprocess"`
				RemoteProcess int `mapstructure:"remoteprocess"`
			}{
				LocalProcess:  20,
				RemoteProcess: 20,
			},
		},
		Concurrency: struct {
			Handler struct {
				Dispatch int `mapstructure:"dispatch"`
			} `mapstructure:"handler"`
		}{
			Handler: struct {
				Dispatch int `mapstructure:"dispatch"`
			}{
				Dispatch: 25,
			},
		},
		Session: struct {
			Unique bool `mapstructure:"unique"`
			Drain  struct {
				Enabled bool          `mapstructure:"enabled"`
				Timeout time.Duration `mapstructure:"timeout"`
				Period  time.Duration `mapstructure:"period"`
			} `mapstructure:"drain"`
		}{
			Unique: true,
			Drain: struct {
				Enabled bool          `mapstructure:"enabled"`
				Timeout time.Duration `mapstructure:"timeout"`
				Period  time.Duration `mapstructure:"period"`
			}{
				Enabled: false,
				Timeout: time.Duration(6 * time.Hour),
				Period:  time.Duration(5 * time.Second),
			},
		},
		Metrics: *newDefaultMetricsConfig(),
		Cluster: *newDefaultClusterConfig(),
		Groups:  *newDefaultGroupsConfig(),
		Worker:  *newDefaultWorkerConfig(),
		Modules: *newDefaultModulesConfig(),
		Acceptor: struct {
			ProxyProtocol bool `mapstructure:"proxyprotocol"`
		}{
			ProxyProtocol: false,
		},
		Conn: struct {
			RateLimiting RateLimitingConfig `mapstructure:"rateLimiting"`
		}{
			RateLimiting: *newDefaultRateLimitingConfig(),
		},
	}
}

// NewPitayaConfig returns a config instance with values extracted from default config paths
func NewPitayaConfig(config *Config) *PitayaConfig {
	conf := NewDefaultPitayaConfig()
	if err := config.UnmarshalKey("pitaya", &conf); err != nil {
		panic(err)
	}
	return conf
}

// GRPCClientConfig rpc client config struct
type GRPCClientConfig struct {
	DialTimeout    time.Duration `mapstructure:"dialtimeout"`
	LazyConnection bool          `mapstructure:"lazyconnection"`
	RequestTimeout time.Duration `mapstructure:"requesttimeout"`
}

// newDefaultGRPCClientConfig rpc client default config struct
func newDefaultGRPCClientConfig() *GRPCClientConfig {
	return &GRPCClientConfig{
		DialTimeout:    time.Duration(5 * time.Second),
		LazyConnection: false,
		RequestTimeout: time.Duration(5 * time.Second),
	}
}

// GRPCServerConfig provides configuration for GRPCServer
type GRPCServerConfig struct {
	Port int `mapstructure:"port"`
}

// newDefaultGRPCServerConfig returns a default GRPCServerConfig
func newDefaultGRPCServerConfig() *GRPCServerConfig {
	return &GRPCServerConfig{
		Port: 3434,
	}
}

// NatsRPCClientConfig provides nats client configuration
type NatsRPCClientConfig struct {
	Connect                string        `mapstructure:"connect"`
	MaxReconnectionRetries int           `mapstructure:"maxreconnectionretries"`
	RequestTimeout         time.Duration `mapstructure:"requesttimeout"`
	ConnectionTimeout      time.Duration `mapstructure:"connectiontimeout"`
	WebsocketCompression   bool          `mapstructure:"websocketcompression"`
	ReconnectJitter        time.Duration `mapstructure:"reconnectjitter"`
	ReconnectJitterTLS     time.Duration `mapstructure:"reconnectjittertls"`
	ReconnectWait          time.Duration `mapstructure:"reconnectwait"`
	PingInterval           time.Duration `mapstructure:"pinginterval"`
	MaxPingsOutstanding    int           `mapstructure:"maxpingsoutstanding"`
}

// newDefaultNatsRPCClientConfig provides default nats client configuration
func newDefaultNatsRPCClientConfig() *NatsRPCClientConfig {
	return &NatsRPCClientConfig{
		Connect:                "nats://localhost:4222",
		MaxReconnectionRetries: 15,
		RequestTimeout:         time.Duration(5 * time.Second),
		ConnectionTimeout:      time.Duration(2 * time.Second),
		WebsocketCompression:   true,
		ReconnectJitter:        time.Duration(100 * time.Millisecond),
		ReconnectJitterTLS:     time.Duration(1 * time.Second),
		ReconnectWait:          time.Duration(time.Second),
		PingInterval:           time.Duration(2 * time.Minute),
		MaxPingsOutstanding:    3,
	}
}

// NatsRPCServerConfig provides nats server configuration
type NatsRPCServerConfig struct {
	Connect                string `mapstructure:"connect"`
	MaxReconnectionRetries int    `mapstructure:"maxreconnectionretries"`
	Buffer                 struct {
		Messages int `mapstructure:"messages"`
		Push     int `mapstructure:"push"`
	} `mapstructure:"buffer"`
	Services             int           `mapstructure:"services"`
	ConnectionTimeout    time.Duration `mapstructure:"connectiontimeout"`
	WebsocketCompression bool          `mapstructure:"websocketcompression"`
	ReconnectJitter      time.Duration `mapstructure:"reconnectjitter"`
	ReconnectJitterTLS   time.Duration `mapstructure:"reconnectjittertls"`
	ReconnectWait        time.Duration `mapstructure:"reconnectwait"`
	PingInterval         time.Duration `mapstructure:"pinginterval"`
	MaxPingsOutstanding  int           `mapstructure:"maxpingsoutstanding"`
}

// newDefaultNatsRPCServerConfig provides default nats server configuration
func newDefaultNatsRPCServerConfig() *NatsRPCServerConfig {
	return &NatsRPCServerConfig{
		Connect:                "nats://localhost:4222",
		MaxReconnectionRetries: 15,
		Buffer: struct {
			Messages int `mapstructure:"messages"`
			Push     int `mapstructure:"push"`
		}{
			Messages: 75,
			Push:     100,
		},
		Services:             30,
		ConnectionTimeout:    time.Duration(2 * time.Second),
		WebsocketCompression: true,
		ReconnectJitter:      time.Duration(100 * time.Millisecond),
		ReconnectJitterTLS:   time.Duration(1 * time.Second),
		ReconnectWait:        time.Duration(time.Second),
		PingInterval:         time.Duration(2 * time.Minute),
		MaxPingsOutstanding:  3,
	}
}

// InfoRetrieverConfig provides InfoRetriever configuration
type InfoRetrieverConfig struct {
	Region string `mapstructure:"region"`
}

// newDefaultInfoRetrieverConfig provides default configuration for InfoRetriever
func newDefaultInfoRetrieverConfig() *InfoRetrieverConfig {
	return &InfoRetrieverConfig{
		Region: "",
	}
}

// EtcdServiceDiscoveryConfig Etcd service discovery config
type EtcdServiceDiscoveryConfig struct {
	Endpoints   []string      `mapstructure:"endpoints"`
	User        string        `mapstructure:"user"`
	Pass        string        `mapstructure:"pass"`
	DialTimeout time.Duration `mapstructure:"dialtimeout"`
	Prefix      string        `mapstructure:"prefix"`
	Heartbeat   struct {
		TTL time.Duration `mapstructure:"ttl"`
		Log bool          `mapstructure:"log"`
	} `mapstructure:"heartbeat"`
	SyncServers struct {
		Interval    time.Duration `mapstructure:"interval"`
		Parallelism int           `mapstructure:"parallelism"`
	} `mapstructure:"syncservers"`
	Revoke struct {
		Timeout time.Duration `mapstructure:"timeout"`
	} `mapstructure:"revoke"`
	GrantLease struct {
		Timeout       time.Duration `mapstructure:"timeout"`
		MaxRetries    int           `mapstructure:"maxretries"`
		RetryInterval time.Duration `mapstructure:"retryinterval"`
	} `mapstructure:"grantlease"`
	Shutdown struct {
		Delay time.Duration `mapstructure:"delay"`
	} `mapstructure:"shutdown"`
	ServerTypesBlacklist []string `mapstructure:"servertypesblacklist"`
}

// newDefaultEtcdServiceDiscoveryConfig Etcd service discovery default config
func newDefaultEtcdServiceDiscoveryConfig() *EtcdServiceDiscoveryConfig {
	return &EtcdServiceDiscoveryConfig{
		Endpoints:   []string{"localhost:2379"},
		User:        "",
		Pass:        "",
		DialTimeout: time.Duration(5 * time.Second),
		Prefix:      "pitaya/",
		Heartbeat: struct {
			TTL time.Duration `mapstructure:"ttl"`
			Log bool          `mapstructure:"log"`
		}{
			TTL: time.Duration(60 * time.Second),
			Log: false,
		},
		SyncServers: struct {
			Interval    time.Duration `mapstructure:"interval"`
			Parallelism int           `mapstructure:"parallelism"`
		}{
			Interval:    time.Duration(120 * time.Second),
			Parallelism: 10,
		},
		Revoke: struct {
			Timeout time.Duration `mapstructure:"timeout"`
		}{
			Timeout: time.Duration(5 * time.Second),
		},
		GrantLease: struct {
			Timeout       time.Duration `mapstructure:"timeout"`
			MaxRetries    int           `mapstructure:"maxretries"`
			RetryInterval time.Duration `mapstructure:"retryinterval"`
		}{
			Timeout:       time.Duration(60 * time.Second),
			MaxRetries:    15,
			RetryInterval: time.Duration(5 * time.Second),
		},
		Shutdown: struct {
			Delay time.Duration `mapstructure:"delay"`
		}{
			Delay: time.Duration(300 * time.Millisecond),
		},
		ServerTypesBlacklist: nil,
	}
}

// NewDefaultCustomMetricsSpec returns an empty *CustomMetricsSpec
func NewDefaultCustomMetricsSpec() *models.CustomMetricsSpec {
	return &models.CustomMetricsSpec{
		Summaries: []*models.Summary{},
		Gauges:    []*models.Gauge{},
		Counters:  []*models.Counter{},
	}
}

// NewCustomMetricsSpec returns a *CustomMetricsSpec by reading config key (DEPRECATED)
func NewCustomMetricsSpec(config *Config) *models.CustomMetricsSpec {
	spec := &models.CustomMetricsSpec{}

	if err := config.UnmarshalKey("pitaya.metrics.custom", &spec); err != nil {
		return NewDefaultCustomMetricsSpec()
	}

	return spec
}

// Metrics provides configuration for all metrics related configurations
type MetricsConfig struct {
	Period           time.Duration            `mapstructure:"period"`
	Game             string                   `mapstructure:"game"`
	AdditionalLabels map[string]string        `mapstructure:"additionallabels"`
	ConstLabels      map[string]string        `mapstructure:"constlabels"`
	Custom           models.CustomMetricsSpec `mapstructure:"custom"`
	Prometheus       *PrometheusConfig        `mapstructure:"prometheus"`
	Statsd           *StatsdConfig            `mapstructure:"statsd"`
}

// newDefaultPrometheusConfig provides default configuration for PrometheusReporter
func newDefaultMetricsConfig() *MetricsConfig {
	return &MetricsConfig{
		Period:           time.Duration(15 * time.Second),
		ConstLabels:      map[string]string{},
		AdditionalLabels: map[string]string{},
		Custom:           *NewDefaultCustomMetricsSpec(),
		Prometheus:       newDefaultPrometheusConfig(),
		Statsd:           newDefaultStatsdConfig(),
	}
}

// PrometheusConfig provides configuration for PrometheusReporter
type PrometheusConfig struct {
	Port    int  `mapstructure:"port"`
	Enabled bool `mapstructure:"enabled"`
}

// newDefaultPrometheusConfig provides default configuration for PrometheusReporter
func newDefaultPrometheusConfig() *PrometheusConfig {
	return &PrometheusConfig{
		Port:    9090,
		Enabled: false,
	}
}

// StatsdConfig provides configuration for statsd
type StatsdConfig struct {
	Enabled bool    `mapstructure:"enabled"`
	Host    string  `mapstructure:"host"`
	Prefix  string  `mapstructure:"prefix"`
	Rate    float64 `mapstructure:"rate"`
}

// newDefaultStatsdConfig provides default configuration for statsd
func newDefaultStatsdConfig() *StatsdConfig {
	return &StatsdConfig{
		Enabled: false,
		Host:    "localhost:9125",
		Prefix:  "pitaya.",
		Rate:    1,
	}
}

// newDefaultStatsdConfig provides default configuration for statsd
func newDefaultClusterConfig() *ClusterConfig {
	return &ClusterConfig{
		Info: *newDefaultInfoRetrieverConfig(),
		RPC:  *newDefaultClusterRPCConfig(),
		SD:   *newDefaultClusterSDConfig(),
	}
}

type ClusterConfig struct {
	Info InfoRetrieverConfig `mapstructure:"info"`
	RPC  ClusterRPCConfig    `mapstructure:"rpc"`
	SD   ClusterSDConfig     `mapstructure:"sd"`
}

type ClusterRPCConfig struct {
	Client struct {
		Grpc GRPCClientConfig    `mapstructure:"grpc"`
		Nats NatsRPCClientConfig `mapstructure:"nats"`
	} `mapstructure:"client"`
	Server struct {
		Grpc GRPCServerConfig    `mapstructure:"grpc"`
		Nats NatsRPCServerConfig `mapstructure:"nats"`
	} `mapstructure:"server"`
}

func newDefaultClusterRPCConfig() *ClusterRPCConfig {
	return &ClusterRPCConfig{
		Client: struct {
			Grpc GRPCClientConfig    `mapstructure:"grpc"`
			Nats NatsRPCClientConfig `mapstructure:"nats"`
		}{
			Grpc: *newDefaultGRPCClientConfig(),
			Nats: *newDefaultNatsRPCClientConfig(),
		},
		Server: struct {
			Grpc GRPCServerConfig    `mapstructure:"grpc"`
			Nats NatsRPCServerConfig `mapstructure:"nats"`
		}{
			Grpc: *newDefaultGRPCServerConfig(),
			Nats: *newDefaultNatsRPCServerConfig(),
		},
	}

}

type ClusterSDConfig struct {
	Etcd EtcdServiceDiscoveryConfig `mapstructure:"etcd"`
}

func newDefaultClusterSDConfig() *ClusterSDConfig {
	return &ClusterSDConfig{Etcd: *newDefaultEtcdServiceDiscoveryConfig()}
}

// WorkerConfig provides worker configuration
type WorkerConfig struct {
	Redis struct {
		ServerURL string `mapstructure:"serverurl"`
		Pool      string `mapstructure:"pool"`
		Password  string `mapstructure:"password"`
	} `mapstructure:"redis"`
	Namespace   string      `mapstructure:"namespace"`
	Concurrency int         `mapstructure:"concurrency"`
	Retry       EnqueueOpts `mapstructure:"retry"`
}

// newDefaultWorkerConfig provides worker default configuration
func newDefaultWorkerConfig() *WorkerConfig {
	return &WorkerConfig{
		Redis: struct {
			ServerURL string `mapstructure:"serverurl"`
			Pool      string `mapstructure:"pool"`
			Password  string `mapstructure:"password"`
		}{
			ServerURL: "localhost:6379",
			Pool:      "10",
		},
		Concurrency: 1,
		Retry:       *newDefaultEnqueueOpts(),
	}
}

// EnqueueOpts has retry options for worker
type EnqueueOpts struct {
	Enabled     bool `mapstructure:"enabled"`
	Max         int  `mapstructure:"max"`
	Exponential int  `mapstructure:"exponential"`
	MinDelay    int  `mapstructure:"mindelay"`
	MaxDelay    int  `mapstructure:"maxdelay"`
	MaxRandom   int  `mapstructure:"maxrandom"`
}

// newDefaultEnqueueOpts provides default EnqueueOpts
func newDefaultEnqueueOpts() *EnqueueOpts {
	return &EnqueueOpts{
		Enabled:     true,
		Max:         2,
		Exponential: 5,
		MinDelay:    10,
		MaxDelay:    10,
		MaxRandom:   0,
	}
}

// MemoryGroupConfig provides configuration for MemoryGroup
type MemoryGroupConfig struct {
	TickDuration time.Duration `mapstructure:"tickduration"`
}

// newDefaultMemoryGroupConfig returns a new, default group instance
func newDefaultMemoryGroupConfig() *MemoryGroupConfig {
	return &MemoryGroupConfig{TickDuration: time.Duration(30 * time.Second)}
}

// EtcdGroupServiceConfig provides ETCD configuration
type EtcdGroupServiceConfig struct {
	DialTimeout        time.Duration `mapstructure:"dialtimeout"`
	Endpoints          []string      `mapstructure:"endpoints"`
	Prefix             string        `mapstructure:"prefix"`
	TransactionTimeout time.Duration `mapstructure:"transactiontimeout"`
}

// newDefaultEtcdGroupServiceConfig provides default ETCD configuration
func newDefaultEtcdGroupServiceConfig() *EtcdGroupServiceConfig {
	return &EtcdGroupServiceConfig{
		DialTimeout:        time.Duration(5 * time.Second),
		Endpoints:          []string{"localhost:2379"},
		Prefix:             "pitaya/",
		TransactionTimeout: time.Duration(5 * time.Second),
	}
}

// NewEtcdGroupServiceConfig reads from config to build ETCD configuration
func newEtcdGroupServiceConfig(config *Config) *EtcdGroupServiceConfig {
	conf := newDefaultEtcdGroupServiceConfig()
	if err := config.UnmarshalKey("pitaya.groups.etcd", &conf); err != nil {
		panic(err)
	}
	return conf
}

type GroupsConfig struct {
	Etcd   EtcdGroupServiceConfig `mapstructure:"etcd"`
	Memory MemoryGroupConfig      `mapstructure:"memory"`
}

// NewDefaultGroupConfig provides default ETCD configuration
func newDefaultGroupsConfig() *GroupsConfig {
	return &GroupsConfig{
		Etcd:   *newDefaultEtcdGroupServiceConfig(),
		Memory: *newDefaultMemoryGroupConfig(),
	}
}

// ETCDBindingConfig provides configuration for ETCDBindingStorage
type ETCDBindingConfig struct {
	DialTimeout time.Duration `mapstructure:"dialtimeout"`
	Endpoints   []string      `mapstructure:"endpoints"`
	Prefix      string        `mapstructure:"prefix"`
	LeaseTTL    time.Duration `mapstructure:"leasettl"`
}

// NewDefaultETCDBindingConfig provides default configuration for ETCDBindingStorage
func newDefaultETCDBindingConfig() *ETCDBindingConfig {
	return &ETCDBindingConfig{
		DialTimeout: time.Duration(5 * time.Second),
		Endpoints:   []string{"localhost:2379"},
		Prefix:      "pitaya/",
		LeaseTTL:    time.Duration(5 * time.Hour),
	}
}

// ModulesConfig provides configuration for Pitaya Modules
type ModulesConfig struct {
	BindingStorage struct {
		Etcd ETCDBindingConfig `mapstructure:"etcd"`
	} `mapstructure:"bindingstorage"`
}

// NewDefaultModulesConfig provides default configuration for Pitaya Modules
func newDefaultModulesConfig() *ModulesConfig {
	return &ModulesConfig{
		BindingStorage: struct {
			Etcd ETCDBindingConfig `mapstructure:"etcd"`
		}{
			Etcd: *newDefaultETCDBindingConfig(),
		},
	}
}

// RateLimitingConfig rate limits config
type RateLimitingConfig struct {
	Limit        int           `mapstructure:"limit"`
	Interval     time.Duration `mapstructure:"interval"`
	ForceDisable bool          `mapstructure:"forcedisable"`
}

// newDefaultRateLimitingConfig rate limits default config
func newDefaultRateLimitingConfig() *RateLimitingConfig {
	return &RateLimitingConfig{
		Limit:        20,
		Interval:     time.Duration(time.Second),
		ForceDisable: false,
	}
}

```

`pkg/config/config_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package config

import (
	"fmt"
	"os"
	"testing"
	"time"

	"github.com/spf13/viper"
	"github.com/stretchr/testify/assert"
)

func TestMain(m *testing.M) {
	setup()
	code := m.Run()
	shutdown()
	os.Exit(code)
}

func setup() {
	os.Setenv("PITAYA_HEARTBEAT_INTERVAL", "123s")
	os.Setenv("PITAYA_CONCURRENCY_TEST", "42")
	os.Setenv("PITAYA_BUFFER_TEST", "14")
}

func shutdown() {
	os.Unsetenv("PITAYA_HEARTBEAT_INTERVAL")
	os.Unsetenv("PITAYA_CONCURRENCY_TEST")
	os.Unsetenv("PITAYA_BUFFER_TEST")
}

func TestNewConfig(t *testing.T) {
	t.Parallel()

	cfg := viper.New()
	cfg.SetDefault("pitaya.buffer.agent.messages", 20)
	cfg.Set("pitaya.concurrency.handler.dispatch", 23)
	cfg.SetDefault("pitaya.no.default", "custom")

	tables := []struct {
		in  []*viper.Viper
		key string
		val interface{}
	}{
		{[]*viper.Viper{}, "pitaya.buffer.agent.messages", 100},
		{[]*viper.Viper{cfg}, "pitaya.buffer.agent.messages", 20},
		{[]*viper.Viper{}, "pitaya.no.default", nil},
		{[]*viper.Viper{cfg}, "pitaya.no.default", "custom"},
		{[]*viper.Viper{}, "pitaya.concurrency.handler.dispatch", 25},
		{[]*viper.Viper{cfg}, "pitaya.concurrency.handler.dispatch", 23},
		{[]*viper.Viper{}, "pitaya.heartbeat.interval", "123s"},
		{[]*viper.Viper{cfg}, "pitaya.heartbeat.interval", "123s"},
		{[]*viper.Viper{}, "pitaya.concurrency.test", "42"},
		{[]*viper.Viper{cfg}, "pitaya.concurrency.test", "42"},
		{[]*viper.Viper{}, "pitaya.buffer.test", "14"},
		{[]*viper.Viper{cfg}, "pitaya.buffer.test", "14"},
	}

	for _, table := range tables {
		t.Run(fmt.Sprintf("arguments:%d", len(table.in)), func(t *testing.T) {
			c := NewConfig(table.in...)
			assert.Equal(t, table.val, c.Get(table.key))
		})
	}
}

func TestGetDuration(t *testing.T) {
	t.Parallel()

	c := NewConfig()
	tables := []struct {
		key string
		val time.Duration
	}{
		{"pitaya.heartbeat.interval", 123 * time.Second},
		{"pitaya.cluster.sd.etcd.dialtimeout", 5 * time.Second},
		{"unexistent", time.Duration(0)},
	}

	for _, table := range tables {
		t.Run(fmt.Sprintf("key:%s val:%d", table.key, table.val), func(t *testing.T) {
			assert.Equal(t, table.val, c.GetDuration(table.key))
		})
	}
}

func TestGetString(t *testing.T) {
	t.Parallel()

	c := NewConfig()
	tables := []struct {
		key string
		val []string
	}{
		{"pitaya.cluster.sd.etcd.endpoints", []string{"localhost:2379"}},
		{"unexistent", nil},
	}

	for _, table := range tables {
		t.Run(fmt.Sprintf("key:%s val:%s", table.key, table.val), func(t *testing.T) {
			assert.Equal(t, table.val, c.GetStringSlice(table.key))
		})
	}
}

func TestGetInt(t *testing.T) {
	t.Parallel()

	c := NewConfig()
	tables := []struct {
		key string
		val int
	}{
		{"pitaya.buffer.agent.messages", 100},
		{"unexistent", 0},
	}

	for _, table := range tables {
		t.Run(fmt.Sprintf("key:%s val:%d", table.key, table.val), func(t *testing.T) {
			assert.Equal(t, table.val, c.GetInt(table.key))
		})
	}
}

func TestGetStringSlice(t *testing.T) {
	t.Parallel()

	c := NewConfig()
	tables := []struct {
		key string
		val []string
	}{
		{"pitaya.cluster.sd.etcd.endpoints", []string{"localhost:2379"}},
		{"unexistent", nil},
	}

	for _, table := range tables {
		t.Run(fmt.Sprintf("key:%s val:%s", table.key, table.val), func(t *testing.T) {
			assert.Equal(t, table.val, c.GetStringSlice(table.key))
		})
	}
}

func TestGet(t *testing.T) {
	t.Parallel()

	c := NewConfig()
	tables := []struct {
		key string
		val interface{}
	}{
		{"pitaya.buffer.agent.messages", 100},
		{"unexistent", nil},
	}

	for _, table := range tables {
		t.Run(fmt.Sprintf("key:%s val:%v", table.key, table.val), func(t *testing.T) {
			assert.Equal(t, table.val, c.Get(table.key))
		})
	}
}

```

`pkg/config/viper_config.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package config

import (
	"reflect"
	"strings"

	"github.com/mitchellh/mapstructure"

	"github.com/spf13/viper"
)

// Config is a wrapper around a viper config
type Config struct {
	viper.Viper
}

// NewConfig creates a new config with a given viper config if given
func NewConfig(cfgs ...*viper.Viper) *Config {
	var cfg *viper.Viper
	if len(cfgs) > 0 {
		cfg = cfgs[0]
	} else {
		cfg = viper.New()
	}

	cfg.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
	cfg.AutomaticEnv()
	c := &Config{*cfg}
	c.fillDefaultValues()
	return c
}

func (c *Config) fillDefaultValues() {
	pitayaConfig := NewDefaultPitayaConfig()

	defaultsMap := map[string]interface{}{
		"pitaya.serializertype":        pitayaConfig.SerializerType,
		"pitaya.buffer.agent.messages": pitayaConfig.Buffer.Agent.Messages,
		// the max buffer size that nats will accept, if this buffer overflows, messages will begin to be dropped
		"pitaya.buffer.handler.localprocess":                    pitayaConfig.Buffer.Handler.LocalProcess,
		"pitaya.buffer.handler.remoteprocess":                   pitayaConfig.Buffer.Handler.RemoteProcess,
		"pitaya.cluster.info.region":                            pitayaConfig.Cluster.Info.Region,
		"pitaya.cluster.rpc.client.grpc.dialtimeout":            pitayaConfig.Cluster.RPC.Client.Grpc.DialTimeout,
		"pitaya.cluster.rpc.client.grpc.requesttimeout":         pitayaConfig.Cluster.RPC.Client.Grpc.RequestTimeout,
		"pitaya.cluster.rpc.client.grpc.lazyconnection":         pitayaConfig.Cluster.RPC.Client.Grpc.LazyConnection,
		"pitaya.cluster.rpc.client.nats.connect":                pitayaConfig.Cluster.RPC.Client.Nats.Connect,
		"pitaya.cluster.rpc.client.nats.connectiontimeout":      pitayaConfig.Cluster.RPC.Client.Nats.ConnectionTimeout,
		"pitaya.cluster.rpc.client.nats.maxreconnectionretries": pitayaConfig.Cluster.RPC.Client.Nats.MaxReconnectionRetries,
		"pitaya.cluster.rpc.client.nats.websocketcompression":   pitayaConfig.Cluster.RPC.Client.Nats.WebsocketCompression,
		"pitaya.cluster.rpc.client.nats.reconnectjitter":        pitayaConfig.Cluster.RPC.Client.Nats.ReconnectJitter,
		"pitaya.cluster.rpc.client.nats.reconnectjittertls":     pitayaConfig.Cluster.RPC.Client.Nats.ReconnectJitterTLS,
		"pitaya.cluster.rpc.client.nats.reconnectwait":          pitayaConfig.Cluster.RPC.Client.Nats.ReconnectWait,
		"pitaya.cluster.rpc.client.nats.pinginterval":           pitayaConfig.Cluster.RPC.Client.Nats.PingInterval,
		"pitaya.cluster.rpc.client.nats.maxpingsoutstanding":    pitayaConfig.Cluster.RPC.Client.Nats.MaxPingsOutstanding,
		"pitaya.cluster.rpc.client.nats.requesttimeout":         pitayaConfig.Cluster.RPC.Client.Nats.RequestTimeout,
		"pitaya.cluster.rpc.server.grpc.port":                   pitayaConfig.Cluster.RPC.Server.Grpc.Port,
		"pitaya.cluster.rpc.server.nats.connect":                pitayaConfig.Cluster.RPC.Server.Nats.Connect,
		"pitaya.cluster.rpc.server.nats.connectiontimeout":      pitayaConfig.Cluster.RPC.Server.Nats.ConnectionTimeout,
		"pitaya.cluster.rpc.server.nats.maxreconnectionretries": pitayaConfig.Cluster.RPC.Server.Nats.MaxReconnectionRetries,
		"pitaya.cluster.rpc.server.nats.websocketcompression":   pitayaConfig.Cluster.RPC.Server.Nats.WebsocketCompression,
		"pitaya.cluster.rpc.server.nats.reconnectjitter":        pitayaConfig.Cluster.RPC.Server.Nats.ReconnectJitter,
		"pitaya.cluster.rpc.server.nats.reconnectjittertls":     pitayaConfig.Cluster.RPC.Server.Nats.ReconnectJitterTLS,
		"pitaya.cluster.rpc.server.nats.reconnectwait":          pitayaConfig.Cluster.RPC.Server.Nats.ReconnectWait,
		"pitaya.cluster.rpc.server.nats.pinginterval":           pitayaConfig.Cluster.RPC.Server.Nats.PingInterval,
		"pitaya.cluster.rpc.server.nats.maxpingsoutstanding":    pitayaConfig.Cluster.RPC.Server.Nats.MaxPingsOutstanding,
		"pitaya.cluster.rpc.server.nats.services":               pitayaConfig.Cluster.RPC.Server.Nats.Services,
		"pitaya.cluster.rpc.server.nats.buffer.messages":        pitayaConfig.Cluster.RPC.Server.Nats.Buffer.Messages,
		"pitaya.cluster.rpc.server.nats.buffer.push":            pitayaConfig.Cluster.RPC.Server.Nats.Buffer.Push,
		"pitaya.cluster.sd.etcd.dialtimeout":                    pitayaConfig.Cluster.SD.Etcd.DialTimeout,
		"pitaya.cluster.sd.etcd.endpoints":                      pitayaConfig.Cluster.SD.Etcd.Endpoints,
		"pitaya.cluster.sd.etcd.user":                           pitayaConfig.Cluster.SD.Etcd.User,
		"pitaya.cluster.sd.etcd.pass":                           pitayaConfig.Cluster.SD.Etcd.Pass,
		"pitaya.cluster.sd.etcd.prefix":                         pitayaConfig.Cluster.SD.Etcd.Prefix,
		"pitaya.cluster.sd.etcd.grantlease.maxretries":          pitayaConfig.Cluster.SD.Etcd.GrantLease.MaxRetries,
		"pitaya.cluster.sd.etcd.grantlease.retryinterval":       pitayaConfig.Cluster.SD.Etcd.GrantLease.RetryInterval,
		"pitaya.cluster.sd.etcd.grantlease.timeout":             pitayaConfig.Cluster.SD.Etcd.GrantLease.Timeout,
		"pitaya.cluster.sd.etcd.heartbeat.log":                  pitayaConfig.Cluster.SD.Etcd.Heartbeat.Log,
		"pitaya.cluster.sd.etcd.heartbeat.ttl":                  pitayaConfig.Cluster.SD.Etcd.Heartbeat.TTL,
		"pitaya.cluster.sd.etcd.revoke.timeout":                 pitayaConfig.Cluster.SD.Etcd.Revoke.Timeout,
		"pitaya.cluster.sd.etcd.syncservers.interval":           pitayaConfig.Cluster.SD.Etcd.SyncServers.Interval,
		"pitaya.cluster.sd.etcd.syncservers.parallelism":        pitayaConfig.Cluster.SD.Etcd.SyncServers.Parallelism,
		"pitaya.cluster.sd.etcd.shutdown.delay":                 pitayaConfig.Cluster.SD.Etcd.Shutdown.Delay,
		"pitaya.cluster.sd.etcd.servertypeblacklist":            pitayaConfig.Cluster.SD.Etcd.ServerTypesBlacklist,
		// the sum of this config among all the frontend servers should always be less than
		// the sum of pitaya.buffer.cluster.rpc.server.nats.messages, for covering the worst case scenario
		// a single backend server should have the config pitaya.buffer.cluster.rpc.server.nats.messages bigger
		// than the sum of the config pitaya.concurrency.handler.dispatch among all frontend servers
		"pitaya.acceptor.proxyprotocol":                    pitayaConfig.Acceptor.ProxyProtocol,
		"pitaya.concurrency.handler.dispatch":              pitayaConfig.Concurrency.Handler.Dispatch,
		"pitaya.defaultpipelines.structvalidation.enabled": pitayaConfig.DefaultPipelines.StructValidation.Enabled,
		"pitaya.groups.etcd.dialtimeout":                   pitayaConfig.Groups.Etcd.DialTimeout,
		"pitaya.groups.etcd.endpoints":                     pitayaConfig.Groups.Etcd.Endpoints,
		"pitaya.groups.etcd.prefix":                        pitayaConfig.Groups.Etcd.Prefix,
		"pitaya.groups.etcd.transactiontimeout":            pitayaConfig.Groups.Etcd.TransactionTimeout,
		"pitaya.groups.memory.tickduration":                pitayaConfig.Groups.Memory.TickDuration,
		"pitaya.handler.messages.compression":              pitayaConfig.Handler.Messages.Compression,
		"pitaya.heartbeat.interval":                        pitayaConfig.Heartbeat.Interval,
		"pitaya.metrics.additionalLabels":                  pitayaConfig.Metrics.AdditionalLabels,
		"pitaya.metrics.constLabels":                       pitayaConfig.Metrics.ConstLabels,
		"pitaya.metrics.custom":                            pitayaConfig.Metrics.Custom,
		"pitaya.metrics.period":                            pitayaConfig.Metrics.Period,
		"pitaya.metrics.prometheus.enabled":                pitayaConfig.Metrics.Prometheus.Enabled,
		"pitaya.metrics.prometheus.port":                   pitayaConfig.Metrics.Prometheus.Port,
		"pitaya.metrics.statsd.enabled":                    pitayaConfig.Metrics.Statsd.Enabled,
		"pitaya.metrics.statsd.host":                       pitayaConfig.Metrics.Statsd.Host,
		"pitaya.metrics.statsd.prefix":                     pitayaConfig.Metrics.Statsd.Prefix,
		"pitaya.metrics.statsd.rate":                       pitayaConfig.Metrics.Statsd.Rate,
		"pitaya.modules.bindingstorage.etcd.dialtimeout":   pitayaConfig.Modules.BindingStorage.Etcd.DialTimeout,
		"pitaya.modules.bindingstorage.etcd.endpoints":     pitayaConfig.Modules.BindingStorage.Etcd.Endpoints,
		"pitaya.modules.bindingstorage.etcd.leasettl":      pitayaConfig.Modules.BindingStorage.Etcd.LeaseTTL,
		"pitaya.modules.bindingstorage.etcd.prefix":        pitayaConfig.Modules.BindingStorage.Etcd.Prefix,
		"pitaya.conn.ratelimiting.limit":                   pitayaConfig.Conn.RateLimiting.Limit,
		"pitaya.conn.ratelimiting.interval":                pitayaConfig.Conn.RateLimiting.Interval,
		"pitaya.conn.ratelimiting.forcedisable":            pitayaConfig.Conn.RateLimiting.ForceDisable,
		"pitaya.session.unique":                            pitayaConfig.Session.Unique,
		"pitaya.session.drain.enabled":                     pitayaConfig.Session.Drain.Enabled,
		"pitaya.session.drain.timeout":                     pitayaConfig.Session.Drain.Timeout,
		"pitaya.session.drain.period":                      pitayaConfig.Session.Drain.Period,
		"pitaya.worker.concurrency":                        pitayaConfig.Worker.Concurrency,
		"pitaya.worker.redis.pool":                         pitayaConfig.Worker.Redis.Pool,
		"pitaya.worker.redis.url":                          pitayaConfig.Worker.Redis.ServerURL,
		"pitaya.worker.retry.enabled":                      pitayaConfig.Worker.Retry.Enabled,
		"pitaya.worker.retry.exponential":                  pitayaConfig.Worker.Retry.Exponential,
		"pitaya.worker.retry.max":                          pitayaConfig.Worker.Retry.Max,
		"pitaya.worker.retry.maxDelay":                     pitayaConfig.Worker.Retry.MaxDelay,
		"pitaya.worker.retry.maxRandom":                    pitayaConfig.Worker.Retry.MaxRandom,
		"pitaya.worker.retry.minDelay":                     pitayaConfig.Worker.Retry.MinDelay,
	}

	for param := range defaultsMap {
		val := c.Get(param)
		if val == nil {
			c.SetDefault(param, defaultsMap[param])
		} else {
			c.SetDefault(param, val)
			c.Set(param, val)
		}

	}
}

// UnmarshalKey unmarshals key into v
func (c *Config) UnmarshalKey(key string, rawVal interface{}) error {
	key = strings.ToLower(key)
	delimiter := "."
	prefix := key + delimiter

	i := c.Get(key)
	if i == nil {
		return nil
	}
	if isStringMapInterface(i) {
		val := i.(map[string]interface{})
		keys := c.AllKeys()
		for _, k := range keys {
			if !strings.HasPrefix(k, prefix) {
				continue
			}
			mk := strings.TrimPrefix(k, prefix)
			mk = strings.Split(mk, delimiter)[0]
			if _, exists := val[mk]; exists {
				continue
			}
			mv := c.Get(key + delimiter + mk)
			if mv == nil {
				continue
			}
			val[mk] = mv
		}
		i = val
	}
	return decode(i, defaultDecoderConfig(rawVal))
}

func isStringMapInterface(val interface{}) bool {
	vt := reflect.TypeOf(val)
	return vt.Kind() == reflect.Map &&
		vt.Key().Kind() == reflect.String &&
		vt.Elem().Kind() == reflect.Interface
}

// A wrapper around mapstructure.Decode that mimics the WeakDecode functionality
func decode(input interface{}, config *mapstructure.DecoderConfig) error {
	decoder, err := mapstructure.NewDecoder(config)
	if err != nil {
		return err
	}
	return decoder.Decode(input)
}

// defaultDecoderConfig returns default mapstructure.DecoderConfig with support
// of time.Duration values & string slices
func defaultDecoderConfig(output interface{}, opts ...viper.DecoderConfigOption) *mapstructure.DecoderConfig {
	c := &mapstructure.DecoderConfig{
		Metadata:         nil,
		Result:           output,
		WeaklyTypedInput: true,
		DecodeHook: mapstructure.ComposeDecodeHookFunc(
			mapstructure.StringToTimeDurationHookFunc(),
			mapstructure.StringToSliceHookFunc(","),
		),
	}
	for _, opt := range opts {
		opt(c)
	}
	return c

}

```

`pkg/conn/codec/constants.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package codec

import "errors"

// Codec constants.
const (
	HeadLength    = 4
	MaxPacketSize = 1 << 24 //16MB
)

// ErrPacketSizeExcced is the error used for encode/decode.
var ErrPacketSizeExcced = errors.New("codec: packet size exceed")

```

`pkg/conn/codec/mocks/packet_decoder.go`:

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: conn/codec/packet_decoder.go

// Package mocks is a generated GoMock package.
package mocks

import (
	gomock "github.com/golang/mock/gomock"
	packet "github.com/topfreegames/pitaya/v3/pkg/conn/packet"
	reflect "reflect"
)

// MockPacketDecoder is a mock of PacketDecoder interface
type MockPacketDecoder struct {
	ctrl     *gomock.Controller
	recorder *MockPacketDecoderMockRecorder
}

// MockPacketDecoderMockRecorder is the mock recorder for MockPacketDecoder
type MockPacketDecoderMockRecorder struct {
	mock *MockPacketDecoder
}

// NewMockPacketDecoder creates a new mock instance
func NewMockPacketDecoder(ctrl *gomock.Controller) *MockPacketDecoder {
	mock := &MockPacketDecoder{ctrl: ctrl}
	mock.recorder = &MockPacketDecoderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockPacketDecoder) EXPECT() *MockPacketDecoderMockRecorder {
	return m.recorder
}

// Decode mocks base method
func (m *MockPacketDecoder) Decode(data []byte) ([]*packet.Packet, error) {
	ret := m.ctrl.Call(m, "Decode", data)
	ret0, _ := ret[0].([]*packet.Packet)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Decode indicates an expected call of Decode
func (mr *MockPacketDecoderMockRecorder) Decode(data interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Decode", reflect.TypeOf((*MockPacketDecoder)(nil).Decode), data)
}

```

`pkg/conn/codec/mocks/packet_encoder.go`:

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: conn/codec/packet_encoder.go

// Package mocks is a generated GoMock package.
package mocks

import (
	gomock "github.com/golang/mock/gomock"
	packet "github.com/topfreegames/pitaya/v3/pkg/conn/packet"
	reflect "reflect"
)

// MockPacketEncoder is a mock of PacketEncoder interface
type MockPacketEncoder struct {
	ctrl     *gomock.Controller
	recorder *MockPacketEncoderMockRecorder
}

// MockPacketEncoderMockRecorder is the mock recorder for MockPacketEncoder
type MockPacketEncoderMockRecorder struct {
	mock *MockPacketEncoder
}

// NewMockPacketEncoder creates a new mock instance
func NewMockPacketEncoder(ctrl *gomock.Controller) *MockPacketEncoder {
	mock := &MockPacketEncoder{ctrl: ctrl}
	mock.recorder = &MockPacketEncoderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockPacketEncoder) EXPECT() *MockPacketEncoderMockRecorder {
	return m.recorder
}

// Encode mocks base method
func (m *MockPacketEncoder) Encode(typ packet.Type, data []byte) ([]byte, error) {
	ret := m.ctrl.Call(m, "Encode", typ, data)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Encode indicates an expected call of Encode
func (mr *MockPacketEncoderMockRecorder) Encode(typ, data interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Encode", reflect.TypeOf((*MockPacketEncoder)(nil).Encode), typ, data)
}

```

`pkg/conn/codec/packet_decoder.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package codec

import "github.com/topfreegames/pitaya/v3/pkg/conn/packet"

// PacketDecoder interface
type PacketDecoder interface {
	Decode(data []byte) ([]*packet.Packet, error)
}

```

`pkg/conn/codec/packet_encoder.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package codec

import "github.com/topfreegames/pitaya/v3/pkg/conn/packet"

// PacketEncoder interface
type PacketEncoder interface {
	Encode(typ packet.Type, data []byte) ([]byte, error)
}

```

`pkg/conn/codec/pomelo_packet_decoder.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package codec

import (
	"bytes"

	"github.com/topfreegames/pitaya/v3/pkg/conn/packet"
)

// PomeloPacketDecoder reads and decodes network data slice following pomelo's protocol
type PomeloPacketDecoder struct{}

// NewPomeloPacketDecoder returns a new decoder that used for decode network bytes slice.
func NewPomeloPacketDecoder() *PomeloPacketDecoder {
	return &PomeloPacketDecoder{}
}

func (c *PomeloPacketDecoder) forward(buf *bytes.Buffer) (int, packet.Type, error) {
	header := buf.Next(HeadLength)
	return ParseHeader(header)
}

// Decode decode the network bytes slice to packet.Packet(s)
func (c *PomeloPacketDecoder) Decode(data []byte) ([]*packet.Packet, error) {
	buf := bytes.NewBuffer(nil)
	buf.Write(data)

	var (
		packets []*packet.Packet
		err     error
	)
	// check length
	if buf.Len() < HeadLength {
		return nil, nil
	}

	// first time
	size, typ, err := c.forward(buf)
	if err != nil {
		return nil, err
	}

	for size <= buf.Len() {
		p := &packet.Packet{Type: typ, Length: size, Data: buf.Next(size)}
		packets = append(packets, p)

		// if no more packets, break
		if buf.Len() < HeadLength {
			break
		}

		size, typ, err = c.forward(buf)
		if err != nil {
			return nil, err
		}
	}

	return packets, nil
}

```

`pkg/conn/codec/pomelo_packet_decoder_test.go`:

```go
package codec

import (
	"bytes"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/conn/packet"
)

var forwardTables = map[string]struct {
	buf []byte
	err error
}{
	"test_handshake_type":     {[]byte{packet.Handshake, 0x00, 0x00, 0x00}, nil},
	"test_handshake_ack_type": {[]byte{packet.HandshakeAck, 0x00, 0x00, 0x00}, nil},
	"test_heartbeat_type":     {[]byte{packet.Heartbeat, 0x00, 0x00, 0x00}, nil},
	"test_data_type":          {[]byte{packet.Data, 0x00, 0x00, 0x00}, nil},
	"test_kick_type":          {[]byte{packet.Kick, 0x00, 0x00, 0x00}, nil},

	"test_wrong_packet_type": {[]byte{0x06, 0x00, 0x00, 0x00}, packet.ErrWrongPomeloPacketType},
}

var (
	handshakeHeaderPacket = []byte{packet.Handshake, 0x00, 0x00, 0x01, 0x01}
	invalidHeader         = []byte{0xff, 0x00, 0x00, 0x01}
)

var decodeTables = map[string]struct {
	data   []byte
	packet []*packet.Packet
	err    error
}{
	"test_not_enough_bytes": {[]byte{0x01}, nil, nil},
	"test_error_on_forward": {invalidHeader, nil, packet.ErrWrongPomeloPacketType},
	"test_forward":          {handshakeHeaderPacket, []*packet.Packet{{packet.Handshake, 1, []byte{0x01}}}, nil},
	"test_forward_many":     {append(handshakeHeaderPacket, handshakeHeaderPacket...), []*packet.Packet{{packet.Handshake, 1, []byte{0x01}}, {packet.Handshake, 1, []byte{0x01}}}, nil},
}

func TestNewPomeloPacketDecoder(t *testing.T) {
	t.Parallel()

	ppd := NewPomeloPacketDecoder()

	assert.NotNil(t, ppd)
}

func TestForward(t *testing.T) {
	t.Parallel()

	for name, table := range forwardTables {
		t.Run(name, func(t *testing.T) {
			ppd := NewPomeloPacketDecoder()

			sz, typ, err := ppd.forward(bytes.NewBuffer(table.buf))
			if table.err == nil {
				assert.Equal(t, packet.Type(table.buf[0]), typ)
				assert.Equal(t, 0, sz)
			}

			assert.Equal(t, table.err, err)
		})
	}
}

func TestDecode(t *testing.T) {
	t.Parallel()

	for name, table := range decodeTables {
		t.Run(name, func(t *testing.T) {
			ppd := NewPomeloPacketDecoder()

			packet, err := ppd.Decode(table.data)

			assert.Equal(t, table.err, err)
			assert.ElementsMatch(t, table.packet, packet)
		})
	}
}

```

`pkg/conn/codec/pomelo_packet_encoder.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package codec

import (
	"github.com/topfreegames/pitaya/v3/pkg/conn/packet"
)

// PomeloPacketEncoder struct
type PomeloPacketEncoder struct {
}

// NewPomeloPacketEncoder ctor
func NewPomeloPacketEncoder() *PomeloPacketEncoder {
	return &PomeloPacketEncoder{}
}

// Encode create a packet.Packet from  the raw bytes slice and then encode to network bytes slice
// Protocol refs: https://github.com/NetEase/pomelo/wiki/Communication-Protocol
//
// -<type>-|--------<length>--------|-<data>-
// --------|------------------------|--------
// 1 byte packet type, 3 bytes packet data length(big end), and data segment
func (e *PomeloPacketEncoder) Encode(typ packet.Type, data []byte) ([]byte, error) {
	if typ < packet.Handshake || typ > packet.Kick {
		return nil, packet.ErrWrongPomeloPacketType
	}

	if len(data) > MaxPacketSize {
		return nil, ErrPacketSizeExcced
	}

	p := &packet.Packet{Type: typ, Length: len(data)}
	buf := make([]byte, p.Length+HeadLength)
	buf[0] = byte(p.Type)

	copy(buf[1:HeadLength], IntToBytes(p.Length))
	copy(buf[HeadLength:], data)

	return buf, nil
}

```

`pkg/conn/codec/pomelo_packet_encoder_test.go`:

```go
package codec

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/conn/packet"
)

func helperConcatBytes(packetType packet.Type, length, data []byte) []byte {
	if data == nil {
		return nil
	}

	bytes := []byte{}
	bytes = append(bytes, byte(packetType))
	bytes = append(bytes, length...)
	bytes = append(bytes, data...)
	return bytes
}

var tooBigData = make([]byte, 1<<25)

var encodeTables = map[string]struct {
	packetType packet.Type
	length     []byte
	data       []byte
	err        error
}{
	"test_encode_handshake":    {packet.Handshake, []byte{0x00, 0x00, 0x02}, []byte{0x01, 0x00}, nil},
	"test_invalid_packet_type": {0xff, nil, nil, packet.ErrWrongPomeloPacketType},
	"test_too_big_packet":      {packet.Data, nil, tooBigData, ErrPacketSizeExcced},
}

func TestEncode(t *testing.T) {
	t.Parallel()

	for name, table := range encodeTables {
		t.Run(name, func(t *testing.T) {
			ppe := NewPomeloPacketEncoder()

			encoded, err := ppe.Encode(table.packetType, table.data)
			if table.err != nil {
				assert.Equal(t, table.err, err)
			} else {
				expectedEncoded := helperConcatBytes(table.packetType, table.length, table.data)
				assert.Equal(t, expectedEncoded, encoded)
			}
		})
	}
}

```

`pkg/conn/codec/utils.go`:

```go
package codec

import "github.com/topfreegames/pitaya/v3/pkg/conn/packet"

// ParseHeader parses a packet header and returns its dataLen and packetType or an error
func ParseHeader(header []byte) (int, packet.Type, error) {
	if len(header) != HeadLength {
		return 0, 0x00, packet.ErrInvalidPomeloHeader
	}
	typ := header[0]
	if typ < packet.Handshake || typ > packet.Kick {
		return 0, 0x00, packet.ErrWrongPomeloPacketType
	}

	size := BytesToInt(header[1:])

	if size > MaxPacketSize {
		return 0, 0x00, ErrPacketSizeExcced
	}

	return size, packet.Type(typ), nil
}

// BytesToInt decode packet data length byte to int(Big end)
func BytesToInt(b []byte) int {
	result := 0
	for _, v := range b {
		result = result<<8 + int(v)
	}
	return result
}

// IntToBytes encode packet data length to bytes(Big end)
func IntToBytes(n int) []byte {
	buf := make([]byte, 3)
	buf[0] = byte((n >> 16) & 0xFF)
	buf[1] = byte((n >> 8) & 0xFF)
	buf[2] = byte(n & 0xFF)
	return buf
}

```

`pkg/conn/message/fixtures/test_notify_type.golden`:

```golden
a
```

`pkg/conn/message/fixtures/test_push_type.golden`:

```golden
a
```

`pkg/conn/message/fixtures/test_reponse_type_with_id.golden`:

```golden

```

`pkg/conn/message/message.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package message

import (
	"errors"
	"fmt"
	"strings"
	"sync"
)

// Type represents the type of message, which could be Request/Notify/Response/Push
type Type byte

// Message types
const (
	Request  Type = 0x00
	Notify   Type = 0x01
	Response Type = 0x02
	Push     Type = 0x03
)

const (
	errorMask            = 0x20
	gzipMask             = 0x10
	msgRouteCompressMask = 0x01
	msgTypeMask          = 0x07
	msgRouteLengthMask   = 0xFF
	msgHeadLength        = 0x02
)

var types = map[Type]string{
	Request:  "Request",
	Notify:   "Notify",
	Response: "Response",
	Push:     "Push",
}

var (
	routesCodesMutex = sync.RWMutex{}
	routes           = make(map[string]uint16) // route map to code
	codes            = make(map[uint16]string) // code map to route
)

// Errors that could be occurred in message codec
var (
	ErrWrongMessageType  = errors.New("wrong message type")
	ErrInvalidMessage    = errors.New("invalid message")
	ErrRouteInfoNotFound = errors.New("route info not found in dictionary")
)

// Message represents a unmarshaled message or a message which to be marshaled
type Message struct {
	Type       Type   // message type
	ID         uint   // unique id, zero while notify mode
	Route      string // route for locating service
	Data       []byte // payload
	compressed bool   // is message compressed
	Err        bool   // is an error message
}

// New returns a new message instance
func New(err ...bool) *Message {
	m := &Message{}
	if len(err) > 0 {
		m.Err = err[0]
	}
	return m
}

// String, implementation of fmt.Stringer interface
func (m *Message) String() string {
	return fmt.Sprintf("Type: %s, ID: %d, Route: %s, Compressed: %t, Error: %t, Data: %v, BodyLength: %d",
		types[m.Type],
		m.ID,
		m.Route,
		m.compressed,
		m.Err,
		m.Data,
		len(m.Data))
}

func routable(t Type) bool {
	return t == Request || t == Notify || t == Push
}

func invalidType(t Type) bool {
	return t < Request || t > Push

}

// SetDictionary set routes map which be used to compress route.
func SetDictionary(dict map[string]uint16) error {
	if dict == nil {
		return nil
	}
	routesCodesMutex.Lock()
	defer routesCodesMutex.Unlock()

	for route, code := range dict {
		r := strings.TrimSpace(route)

		// duplication check
		if _, ok := routes[r]; ok {
			return fmt.Errorf("duplicated route(route: %s, code: %d)", r, code)
		}

		if _, ok := codes[code]; ok {
			return fmt.Errorf("duplicated route(route: %s, code: %d)", r, code)
		}

		// update map, using last value when key duplicated
		routes[r] = code
		codes[code] = r
	}

	return nil
}

// GetDictionary gets the routes map which is used to compress route.
func GetDictionary() map[string]uint16 {
	routesCodesMutex.RLock()
	defer routesCodesMutex.RUnlock()
	dict := make(map[string]uint16)
	for k, v := range routes {
		dict[k] = v
	}
	return dict
}

func (t *Type) String() string {
	return types[*t]
}

```

`pkg/conn/message/message_encoder.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package message

import (
	"encoding/binary"

	"github.com/topfreegames/pitaya/v3/pkg/util/compression"
)

// Encoder interface
type Encoder interface {
	IsCompressionEnabled() bool
	Encode(message *Message) ([]byte, error)
}

// MessagesEncoder implements MessageEncoder interface
type MessagesEncoder struct {
	DataCompression bool
}

// NewMessagesEncoder returns a new message encoder
func NewMessagesEncoder(dataCompression bool) *MessagesEncoder {
	me := &MessagesEncoder{dataCompression}
	return me
}

// IsCompressionEnabled returns wether the compression is enabled or not
func (me *MessagesEncoder) IsCompressionEnabled() bool {
	return me.DataCompression
}

// Encode marshals message to binary format. Different message types is corresponding to
// different message header, message types is identified by 2-4 bit of flag field. The
// relationship between message types and message header is presented as follows:
// ------------------------------------------
// |   type   |  flag  |       other        |
// |----------|--------|--------------------|
// | request  |----000-|<message id>|<route>|
// | notify   |----001-|<route>             |
// | response |----010-|<message id>        |
// | push     |----011-|<route>             |
// ------------------------------------------
// The figure above indicates that the bit does not affect the type of message.
// See ref: https://github.com/topfreegames/pitaya/v3/blob/master/docs/communication_protocol.md
func (me *MessagesEncoder) Encode(message *Message) ([]byte, error) {
	if invalidType(message.Type) {
		return nil, ErrWrongMessageType
	}

	buf := make([]byte, 0)
	flag := byte(message.Type) << 1

	routesCodesMutex.RLock()
	code, compressed := routes[message.Route]
	routesCodesMutex.RUnlock()
	if compressed {
		flag |= msgRouteCompressMask
	}

	if message.Err {
		flag |= errorMask
	}

	buf = append(buf, flag)

	if message.Type == Request || message.Type == Response {
		n := message.ID
		// variant length encode
		for {
			b := byte(n % 128)
			n >>= 7
			if n != 0 {
				buf = append(buf, b+128)
			} else {
				buf = append(buf, b)
				break
			}
		}
	}

	if routable(message.Type) {
		if compressed {
			buf = append(buf, byte((code>>8)&0xFF))
			buf = append(buf, byte(code&0xFF))
		} else {
			buf = append(buf, byte(len(message.Route)))
			buf = append(buf, []byte(message.Route)...)
		}
	}

	if me.DataCompression {
		d, err := compression.DeflateData(message.Data)
		if err != nil {
			return nil, err
		}

		if len(d) < len(message.Data) {
			message.Data = d
			buf[0] |= gzipMask
		}
	}

	buf = append(buf, message.Data...)
	return buf, nil
}

// Decode decodes the message
func (me *MessagesEncoder) Decode(data []byte) (*Message, error) {
	return Decode(data)
}

// Decode unmarshal the bytes slice to a message
// See ref: https://github.com/topfreegames/pitaya/v3/blob/master/docs/communication_protocol.md
func Decode(data []byte) (*Message, error) {
	if len(data) < msgHeadLength {
		return nil, ErrInvalidMessage
	}
	m := New()
	flag := data[0]
	offset := 1
	m.Type = Type((flag >> 1) & msgTypeMask)

	if invalidType(m.Type) {
		return nil, ErrWrongMessageType
	}

	if m.Type == Request || m.Type == Response {
		id := uint(0)
		// little end byte order
		// WARNING: must can be stored in 64 bits integer
		// variant length encode
		for i := offset; i < len(data); i++ {
			b := data[i]
			id += uint(b&0x7F) << uint(7*(i-offset))
			if b < 128 {
				offset = i + 1
				break
			}
		}
		m.ID = id
	}

	m.Err = flag&errorMask == errorMask

	size := len(data)
	if routable(m.Type) {
		if flag&msgRouteCompressMask == 1 {
			if offset > size || (offset+2) > size {
				return nil, ErrInvalidMessage
			}

			m.compressed = true
			code := binary.BigEndian.Uint16(data[offset:(offset + 2)])
			routesCodesMutex.RLock()
			route, ok := codes[code]
			routesCodesMutex.RUnlock()
			if !ok {
				return nil, ErrRouteInfoNotFound
			}
			m.Route = route
			offset += 2
		} else {
			m.compressed = false
			rl := data[offset]
			offset++

			if offset > size || (offset+int(rl)) > size {
				return nil, ErrInvalidMessage
			}
			m.Route = string(data[offset:(offset + int(rl))])
			offset += int(rl)
		}
	}

	if offset > size {
		return nil, ErrInvalidMessage
	}

	m.Data = data[offset:]
	var err error
	if flag&gzipMask == gzipMask {
		m.Data, err = compression.InflateData(m.Data)
		if err != nil {
			return nil, err
		}
	}
	return m, nil
}

```

`pkg/conn/message/message_test.go`:

```go
package message

import (
	"errors"
	"flag"
	"fmt"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/helpers"
)

var update = flag.Bool("update", false, "update .golden files")

func resetDicts(t *testing.T) {
	t.Helper()
	routesCodesMutex.Lock()
	defer routesCodesMutex.Unlock()
	routes = make(map[string]uint16)
	codes = make(map[uint16]string)
}

func TestNew(t *testing.T) {
	t.Parallel()

	message := New()

	assert.NotNil(t, message)
}

var encodeTables = map[string]struct {
	message *Message
	routes  map[string]uint16
	msgErr  bool
	gzip    uint8
	err     error
}{
	"test_wrong_type": {&Message{Type: 0xff, Data: []byte{}}, nil, false, 0x0, ErrWrongMessageType},

	"test_request_type": {&Message{Type: Request, Route: "a", Data: []uint8{}}, nil, false, 0x0, nil},
	"test_request_type_compressed": {&Message{Type: Request, Route: "a", Data: []byte{}, compressed: true},
		map[string]uint16{"a": 1}, false, 0x0, nil},

	"test_notify_type": {&Message{Type: Notify, Route: "a", Data: []byte{}}, nil, false, 0x0, nil},
	"test_notify_type_compressed": {&Message{Type: Notify, Route: "a", Data: []byte{}, compressed: true},
		map[string]uint16{"a": 1}, false, 0x0, nil},

	"test_push_type": {&Message{Type: Push, Route: "a", Data: []byte{}}, nil, false, 0x0, nil},
	"test_push_type_compressed": {&Message{Type: Push, Route: "a", Data: []byte{}, compressed: true},
		map[string]uint16{"a": 1}, false, 0x0, nil},

	"test_reponse_type":           {&Message{Type: Response, Data: []byte{}}, nil, false, 0x0, nil},
	"test_reponse_type_with_data": {&Message{Type: Response, Data: []byte{0x01}}, nil, false, 0x0, nil},
	"test_reponse_type_with_id":   {&Message{Type: Response, ID: 129, Data: []byte{}}, nil, false, 0x0, nil},

	"test_reponse_type_with_error": {&Message{Type: Response, Data: []byte{0x01}, Err: true}, nil, true, 0x0, nil},
	"test_must_gzip": {&Message{Type: Response,
		Data: []byte("blablablablablablablablablablablablabla"), Err: true}, nil, true, 0x10, nil},
}

func TestEncode(t *testing.T) {
	for name, table := range encodeTables {
		t.Run(name, func(t *testing.T) {
			message := table.message
			SetDictionary(table.routes)

			messageEncoder := NewMessagesEncoder(table.gzip == 0x10)
			result, err := messageEncoder.Encode(message)
			gp := filepath.Join("fixtures", name+".golden")

			if *update {
				t.Log("updating golden file")
				helpers.WriteFile(t, gp, result)
			}

			expected := helpers.ReadFile(t, gp)

			if err == nil {
				assert.Equal(t, table.gzip, expected[0]&gzipMask)
				assert.Equal(t, expected, result)
			} else {
				assert.Nil(t, result)
			}

			assert.Equal(t, table.err, err)

			resetDicts(t)
		})
	}
}

var decodeTables = map[string]struct {
	message *Message
	routes  map[string]uint16
	msgErr  bool
	gzip    uint8
	err     error
}{
	"test_wrong_type": {&Message{Type: 0xff, Data: []byte{}}, nil, false, 0x0, ErrWrongMessageType},

	"test_request_type": {&Message{Type: Request, Route: "a", Data: []uint8{}}, nil, false, 0x0, nil},
	"test_request_type_compressed": {&Message{Type: Request, Route: "a", Data: []byte{}, compressed: true},
		map[string]uint16{"a": 1}, false, 0x0, nil},

	"test_notify_type": {&Message{Type: Notify, Route: "a", Data: []byte{}}, nil, false, 0x0, nil},
	"test_notify_type_compressed": {&Message{Type: Notify, Route: "a", Data: []byte{}, compressed: true},
		map[string]uint16{"a": 1}, false, 0x0, nil},

	"test_push_type": {&Message{Type: Push, Route: "a", Data: []byte{}}, nil, false, 0x0, nil},
	"test_push_type_compressed": {&Message{Type: Push, Route: "a", Data: []byte{}, compressed: true},
		map[string]uint16{"a": 1}, false, 0x0, nil},

	"test_reponse_type":           {&Message{Type: Response, Data: []byte{}}, nil, false, 0x0, nil},
	"test_reponse_type_with_data": {&Message{Type: Response, Data: []byte{0x01}}, nil, false, 0x0, nil},
	"test_reponse_type_with_id":   {&Message{Type: Response, ID: 129, Data: []byte{}}, nil, false, 0x0, nil},

	"test_reponse_type_with_error": {&Message{Type: Response, Data: []byte{0x01}, Err: true}, nil, true, 0x0, nil},
	"test_must_gzip": {&Message{Type: Response,
		Data: []byte("blablablablablablablablablablablablabla"), Err: true}, nil, true, 0x10, nil},
}

func TestDecode(t *testing.T) {
	for name, table := range decodeTables {
		t.Run(name, func(t *testing.T) {
			SetDictionary(table.routes)

			gp := filepath.Join("fixtures", name+".golden")
			encoded := helpers.ReadFile(t, gp)

			message, err := Decode(encoded)

			if err == nil {
				assert.Equal(t, table.message, message)
			}
			if name == "test_wrong_type" {
				assert.EqualError(t, ErrInvalidMessage, err.Error())
			} else {
				assert.Equal(t, table.err, err)
			}
			resetDicts(t)
		})
	}
}

var dictTables = map[string]struct {
	dicts  []map[string]uint16
	routes map[string]uint16
	codes  map[uint16]string
	err    error
}{
	"test_add_new_route": {[]map[string]uint16{{"a": 1}}, map[string]uint16{"a": 1},
		map[uint16]string{1: "a"}, nil},
	"test_add_new_routes": {[]map[string]uint16{{"a": 1}, {"b": 2}}, map[string]uint16{"a": 1, "b": 2},
		map[uint16]string{1: "a", 2: "b"}, nil},
	"test_override_route": {[]map[string]uint16{{"a": 1}, {"a": 2}}, map[string]uint16{"a": 1},
		map[uint16]string{1: "a"}, errors.New("duplicated route(route: a, code: 1)")},
	"test_override_code": {[]map[string]uint16{{"a": 1}, {"b": 1}}, map[string]uint16{"a": 1},
		map[uint16]string{1: "a"}, errors.New("duplicated route(route: b, code: 1)")},
}

func TestSetDictionary(t *testing.T) {
	for name, table := range dictTables {
		t.Run(name, func(t *testing.T) {
			for _, dict := range table.dicts {
				SetDictionary(dict)
			}

			assert.Equal(t, table.routes, routes)
			assert.Equal(t, table.codes, codes)

			resetDicts(t)
		})
	}
}

func TestSetDictionaryRace(t *testing.T) {
	defer resetDicts(t)

	done := make(chan bool, 2)

	setDictRace := func(dict map[string]uint16) {
		assert.Nil(t, SetDictionary(dict))
		done <- true
	}

	go setDictRace(map[string]uint16{"a": 1})
	go setDictRace(map[string]uint16{"b": 2})

	// wait for both setDictRace to finish
	<-done
	<-done

	expected_codes := map[uint16]string{1: "a", 2: "b"}
	assert.EqualValues(t, expected_codes, codes)

	expected_routes := map[string]uint16{"a": 1, "b": 2}
	assert.EqualValues(t, expected_routes, routes)
}

func TestGetDictionary(t *testing.T) {
	defer resetDicts(t)
	expected := map[string]uint16{"a": 1, "b": 2}
	assert.Nil(t, SetDictionary(expected))

	dict := GetDictionary()
	assert.Equal(t, expected, dict)

	// make sure we're copying the routes maps
	assert.NotEqual(t, fmt.Sprintf("%p", routes), fmt.Sprintf("%p", dict))
}

```

`pkg/conn/message/mocks/message_encoder.go`:

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: ./message_encoder.go

// Package mocks is a generated GoMock package.
package mocks

import (
	gomock "github.com/golang/mock/gomock"
	message "github.com/topfreegames/pitaya/v3/pkg/conn/message"
	reflect "reflect"
)

// MockEncoder is a mock of Encoder interface
type MockEncoder struct {
	ctrl     *gomock.Controller
	recorder *MockEncoderMockRecorder
}

// MockEncoderMockRecorder is the mock recorder for MockEncoder
type MockEncoderMockRecorder struct {
	mock *MockEncoder
}

// NewMockEncoder creates a new mock instance
func NewMockEncoder(ctrl *gomock.Controller) *MockEncoder {
	mock := &MockEncoder{ctrl: ctrl}
	mock.recorder = &MockEncoderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockEncoder) EXPECT() *MockEncoderMockRecorder {
	return m.recorder
}

// IsCompressionEnabled mocks base method
func (m *MockEncoder) IsCompressionEnabled() bool {
	ret := m.ctrl.Call(m, "IsCompressionEnabled")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsCompressionEnabled indicates an expected call of IsCompressionEnabled
func (mr *MockEncoderMockRecorder) IsCompressionEnabled() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsCompressionEnabled", reflect.TypeOf((*MockEncoder)(nil).IsCompressionEnabled))
}

// Encode mocks base method
func (m *MockEncoder) Encode(message *message.Message) ([]byte, error) {
	ret := m.ctrl.Call(m, "Encode", message)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Encode indicates an expected call of Encode
func (mr *MockEncoderMockRecorder) Encode(message interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Encode", reflect.TypeOf((*MockEncoder)(nil).Encode), message)
}

```

`pkg/conn/packet/constants.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package packet

import "errors"

// Type represents the network packet's type such as: handshake and so on.
type Type byte

const (
	_ Type = iota
	// Handshake represents a handshake: request(client) <====> handshake response(server)
	Handshake = 0x01

	// HandshakeAck represents a handshake ack from client to server
	HandshakeAck = 0x02

	// Heartbeat represents a heartbeat
	Heartbeat = 0x03

	// Data represents a common data packet
	Data = 0x04

	// Kick represents a kick off packet
	Kick = 0x05 // disconnect message from server
)

// ErrWrongPomeloPacketType represents a wrong packet type.
var ErrWrongPomeloPacketType = errors.New("wrong packet type")

// ErrInvalidPomeloHeader represents an invalid header
var ErrInvalidPomeloHeader = errors.New("invalid header")

```

`pkg/conn/packet/packet.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package packet

import (
	"fmt"
)

// Packet represents a network packet.
type Packet struct {
	Type   Type
	Length int
	Data   []byte
}

//New create a Packet instance.
func New() *Packet {
	return &Packet{}
}

//String represents the Packet's in text mode.
func (p *Packet) String() string {
	return fmt.Sprintf("Type: %d, Length: %d, Data: %s", p.Type, p.Length, string(p.Data))
}

```

`pkg/conn/packet/packet_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package packet

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestNewPacket(t *testing.T) {
	p := New()
	assert.NotNil(t, p)
}

func TestString(t *testing.T) {
	tables := []struct {
		tp     Type
		data   []byte
		strOut string
	}{
		{Handshake, []byte{0x01}, fmt.Sprintf("Type: %d, Length: %d, Data: %s", Handshake, 1, string([]byte{0x01}))},
		{Data, []byte{0x01, 0x02, 0x03}, fmt.Sprintf("Type: %d, Length: %d, Data: %s", Data, 3, string([]byte{0x01, 0x02, 0x03}))},
		{Kick, []byte{0x05, 0x02, 0x03, 0x04}, fmt.Sprintf("Type: %d, Length: %d, Data: %s", Kick, 4, string([]byte{0x05, 0x02, 0x03, 0x04}))},
	}

	for _, table := range tables {
		t.Run(string(table.data), func(t *testing.T) {
			p := &Packet{}
			p.Data = table.data
			p.Type = table.tp
			p.Length = len(table.data)
			assert.Equal(t, table.strOut, p.String())
		})
	}
}

```

`pkg/constants/const.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package constants

const (
	_ int32 = iota
	// StatusStart status
	StatusStart
	// StatusHandshake status
	StatusHandshake
	// StatusWorking status
	StatusWorking
	// StatusClosed status
	StatusClosed
)

const (
	// SessionPushRoute is the route used for updating session
	SessionPushRoute = "sys.pushsession"

	// SessionBindRoute is the route used for binding session
	SessionBindRoute = "sys.bindsession"

	// KickRoute is the route used for kicking an user
	KickRoute = "sys.kick"
)

// SessionCtxKey is the context key where the session will be set
var SessionCtxKey = "session"

// LoggerCtxKey is the context key where the default logger will be set
var LoggerCtxKey = "default-logger"

type propagateKey struct{}

// PropagateCtxKey is the context key where the content that will be
// propagated through rpc calls is set
var PropagateCtxKey = propagateKey{}

// SpanPropagateCtxKey is the key holding the otel spans inside
// the propagate key
var SpanPropagateCtxKey = "otel-span"

// PeerIDKey is the key holding the peer id to be sent over the context
var PeerIDKey = "peer.id"

// PeerServiceKey is the key holding the peer service to be sent over the context
var PeerServiceKey = "peer.service"

// StartTimeKey is the key holding the request start time (in ns) to be sent over the context
var StartTimeKey = "req-start-time"

// RequestIDKey is the key holding the request id to be sent over the context
var RequestIDKey = "request.id"

// RouteKey is the key holding the request route to be sent over the context
var RouteKey = "req-route"

// MetricTagsKey is the key holding request tags to be sent over the context
// to be reported
var MetricTagsKey = "metric-tags"

// GRPCHostKey is the key for grpc host on server metadata
var GRPCHostKey = "grpcHost"

// GRPCExternalHostKey is the key for grpc external host on server metadata
var GRPCExternalHostKey = "grpc-external-host"

// GRPCPortKey is the key for grpc port on server metadata
var GRPCPortKey = "grpcPort"

// GRPCExternalPortKey is the key for grpc external port on server metadata
var GRPCExternalPortKey = "grpc-external-port"

// RegionKey is the key to save the region server is on
var RegionKey = "region"

// IP constants
const (
	IPVersionKey = "ipversion"
	IPv4         = "ipv4"
	IPv6         = "ipv6"
)

// IOBufferBytesSize will be used when reading messages from clients
var IOBufferBytesSize = 4096

// RequestTimeout is the time it will take for a caller to timeout a request
var RequestTimeout = "reqTimeout"

```

`pkg/constants/errors.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package constants

import "errors"

// Errors that can occur during message handling.
var (
	ErrBindingNotFound                = errors.New("binding for this user was not found in etcd")
	ErrBrokenPipe                     = errors.New("broken low-level pipe")
	ErrBufferExceed                   = errors.New("session send buffer exceed")
	ErrChangeDictionaryWhileRunning   = errors.New("you shouldn't change the dictionary while the app is already running")
	ErrChangeRouteWhileRunning        = errors.New("you shouldn't change routes while app is already running")
	ErrCloseClosedGroup               = errors.New("close closed group")
	ErrCloseClosedSession             = errors.New("close closed session")
	ErrClosedGroup                    = errors.New("group closed")
	ErrEmptyUID                       = errors.New("empty uid")
	ErrEtcdGrantLeaseTimeout          = errors.New("timed out waiting for etcd lease grant")
	ErrEtcdLeaseNotFound              = errors.New("etcd lease not found in group")
	ErrFrontSessionCantPushToFront    = errors.New("frontend session can't push to front")
	ErrFrontendTypeNotSpecified       = errors.New("for using SendPushToUsers from a backend server you have to specify a valid frontendType")
	ErrGroupAlreadyExists             = errors.New("group already exists")
	ErrGroupNotFound                  = errors.New("group not found")
	ErrIllegalUID                     = errors.New("illegal uid")
	ErrIncorrectNumberOfCertificates  = errors.New("certificates must be exactly two")
	ErrInvalidCertificates            = errors.New("invalid certificates")
	ErrInvalidSpanCarrier             = errors.New("tracing: invalid span carrier")
	ErrKickingUsers                   = errors.New("failed to kick users, check array with failed uids")
	ErrMemberAlreadyExists            = errors.New("member already exists in group")
	ErrMemberNotFound                 = errors.New("member not found in the group")
	ErrMemoryTTLNotFound              = errors.New("memory group TTL not found")
	ErrMetricNotKnown                 = errors.New("the provided metric does not exist")
	ErrNatsMessagesBufferSizeZero     = errors.New("pitaya.buffer.cluster.rpc.server.nats.messages cant be zero")
	ErrNatsNoRequestTimeout           = errors.New("pitaya.cluster.rpc.client.nats.requesttimeout cant be empty")
	ErrNatsPushBufferSizeZero         = errors.New("pitaya.buffer.cluster.rpc.server.nats.push cant be zero")
	ErrNilCondition                   = errors.New("pitaya/timer: nil condition")
	ErrNoBindingStorageModule         = errors.New("for sending remote pushes or using unique session module while using grpc you need to pass it a BindingStorage")
	ErrNoConnectionToServer           = errors.New("rpc client has no connection to the chosen server")
	ErrNoContextFound                 = errors.New("no context found")
	ErrNoNatsConnectionString         = errors.New("you have to provide a nats url")
	ErrNoServerTypeChosenForRPC       = errors.New("no server type chosen for sending RPC, send a full route in the format server.service.component")
	ErrNoServerWithID                 = errors.New("can't find any server with the provided ID")
	ErrNoServersAvailableOfType       = errors.New("no servers available of this type")
	ErrNoUIDBind                      = errors.New("you have to bind an UID to the session to do that")
	ErrNonsenseRPC                    = errors.New("you are making a rpc that may be processed locally, either specify a different server type or specify a server id")
	ErrNotImplemented                 = errors.New("method not implemented")
	ErrNotifyOnRequest                = errors.New("tried to notify a request route")
	ErrOnCloseBackend                 = errors.New("onclose callbacks are not allowed on backend servers")
	ErrProtodescriptor                = errors.New("failed to get protobuf message descriptor")
	ErrPushingToUsers                 = errors.New("failed to push message to users, check array with failed uids")
	ErrRPCRequestTimeout              = errors.New("rpc client: request timeout")
	ErrRPCClientNotInitialized        = errors.New("RPC client is not running")
	ErrRPCJobAlreadyRegistered        = errors.New("rpc job was already registered")
	ErrRPCLocal                       = errors.New("RPC must be to a different server type")
	ErrRPCServerNotInitialized        = errors.New("RPC server is not running")
	ErrReplyShouldBeNotNull           = errors.New("reply must not be null")
	ErrReplyShouldBePtr               = errors.New("reply must be a pointer")
	ErrRequestOnNotify                = errors.New("tried to request a notify route")
	ErrRouterNotInitialized           = errors.New("router is not initialized")
	ErrServerNotFound                 = errors.New("server not found")
	ErrServiceDiscoveryNotInitialized = errors.New("service discovery client is not initialized")
	ErrSessionAlreadyBound            = errors.New("session is already bound to an uid")
	ErrSessionDuplication             = errors.New("session exists in the current group")
	ErrSessionNotFound                = errors.New("session not found")
	ErrSessionOnNotify                = errors.New("current session working on notify mode")
	ErrTimeoutTerminatingBinaryModule = errors.New("timeout waiting to binary module to die")
	ErrWrongValueType                 = errors.New("protobuf: convert on wrong type value")
	ErrRateLimitExceeded              = errors.New("rate limit exceeded")
	ErrReceivedMsgSmallerThanExpected = errors.New("received less data than expected, EOF?")
	ErrReceivedMsgBiggerThanExpected  = errors.New("received more data than expected")
	ErrConnectionClosed               = errors.New("client connection closed")
)

```

`pkg/constants/version.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package constants

// VERSION returns current pitaya version
var VERSION = "0.1.0"

```

`pkg/context/context.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package context

import (
	"context"
	"encoding/json"

	"github.com/topfreegames/pitaya/v3/pkg/constants"
)

// AddToPropagateCtx adds a key and value that will be propagated through RPC calls
func AddToPropagateCtx(ctx context.Context, key string, val interface{}) context.Context {
	propagate := ToMap(ctx)
	propagate[key] = val
	return context.WithValue(ctx, constants.PropagateCtxKey, propagate)
}

// GetFromPropagateCtx get a value from the propagate
func GetFromPropagateCtx(ctx context.Context, key string) interface{} {
	propagate := ToMap(ctx)
	if val, ok := propagate[key]; ok {
		return val
	}
	return nil
}

// ToMap returns the values that will be propagated through RPC calls in map[string]interface{} format
func ToMap(ctx context.Context) map[string]interface{} {
	if ctx == nil {
		return map[string]interface{}{}
	}
	p := ctx.Value(constants.PropagateCtxKey)
	if p != nil {
		return p.(map[string]interface{})
	}
	return map[string]interface{}{}
}

// FromMap creates a new context from a map with propagated values
func FromMap(val map[string]interface{}) context.Context {
	return context.WithValue(context.Background(), constants.PropagateCtxKey, val)
}

// Encode returns the given propagatable context encoded in binary format
func Encode(ctx context.Context) ([]byte, error) {
	m := ToMap(ctx)
	if len(m) > 0 {
		return json.Marshal(m)
	}
	return nil, nil
}

// Decode returns a context given a binary encoded message
func Decode(m []byte) (context.Context, error) {
	if len(m) == 0 {
		// TODO maybe return an error
		return nil, nil
	}
	mp := make(map[string]interface{}, 0)
	err := json.Unmarshal(m, &mp)
	if err != nil {
		return nil, err
	}
	return FromMap(mp), nil
}

```

`pkg/context/context_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package context

import (
	"context"
	"encoding/json"
	"errors"
	"flag"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/helpers"
)

var update = flag.Bool("update", false, "update .golden files")

type unregisteredStruct struct{}
type registeredStruct struct{}

func TestAddToPropagateCtx(t *testing.T) {
	tables := []struct {
		name  string
		items map[string]interface{}
	}{
		{"one_element", map[string]interface{}{"key1": "val1"}},
		{"two_elements", map[string]interface{}{"key1": "val1", "key2": "val2"}},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctx := context.Background()
			for k, v := range table.items {
				ctx = AddToPropagateCtx(ctx, k, v)
			}
			val := ctx.Value(constants.PropagateCtxKey)
			assert.IsType(t, map[string]interface{}{}, val)
			assert.Equal(t, table.items, val.(map[string]interface{}))
		})
	}
}

func TestGetFromPropagateCtx(t *testing.T) {
	tables := []struct {
		name  string
		items map[string]interface{}
	}{
		{"one_element", map[string]interface{}{"key1": "val1"}},
		{"two_elements", map[string]interface{}{"key1": "val1", "key2": "val2"}},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctx := context.Background()
			for k, v := range table.items {
				ctx = AddToPropagateCtx(ctx, k, v)
			}

			for k, v := range table.items {
				val := GetFromPropagateCtx(ctx, k)
				assert.Equal(t, v, val)
			}
		})
	}
}

func TestGetFromPropagateCtxReturnsNilIfNotFound(t *testing.T) {
	ctx := context.Background()
	val := GetFromPropagateCtx(ctx, "key")
	assert.Nil(t, val)
}

func TestToMap(t *testing.T) {
	tables := []struct {
		name  string
		items map[string]interface{}
	}{
		{"no_elements", map[string]interface{}{}},
		{"one_element", map[string]interface{}{"key1": "val1"}},
		{"two_elements", map[string]interface{}{"key1": "val1", "key2": "val2"}},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctx := context.Background()
			for k, v := range table.items {
				ctx = AddToPropagateCtx(ctx, k, v)
			}

			val := ToMap(ctx)
			assert.Equal(t, table.items, val)
		})
	}
}

func TestToMapReturnsEmptyIfNothingInPropagateKey(t *testing.T) {
	ctx := context.Background()
	ctx = context.WithValue(ctx, "key", "val")
	val := ToMap(ctx)
	assert.Equal(t, map[string]interface{}{}, val)
}

func TestFromMap(t *testing.T) {
	tables := []struct {
		name  string
		items map[string]interface{}
	}{
		{"one_element", map[string]interface{}{"key1": "val1"}},
		{"two_elements", map[string]interface{}{"key1": "val1", "key2": "val2"}},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctx := FromMap(table.items)
			for k, v := range table.items {
				val := GetFromPropagateCtx(ctx, k)
				assert.Equal(t, v, val)
			}

		})
	}
}

func TestEncode(t *testing.T) {
	tables := []struct {
		name  string
		items map[string]interface{}
		err   error
	}{
		{"no_elements", map[string]interface{}{}, nil},
		{"one_element", map[string]interface{}{"key1": "val1"}, nil},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctx := FromMap(table.items)

			if len(table.items) > 0 && table.err == nil {
				gp := filepath.Join("fixtures", table.name+".golden")
				if *update {
					b, err := json.Marshal(table.items)
					require.NoError(t, err)
					t.Log("updating golden file")
					helpers.WriteFile(t, gp, b)
				}
				expectedEncoded := helpers.ReadFile(t, gp)

				encoded, err := Encode(ctx)
				assert.Equal(t, table.err, err)
				assert.Equal(t, expectedEncoded, encoded)
			} else {
				encoded, err := Encode(ctx)
				assert.Nil(t, encoded)
				assert.Equal(t, table.err, err)
			}
		})
	}
}

func TestDecode(t *testing.T) {
	tables := []struct {
		name  string
		items map[string]interface{}
	}{
		{"one_element", map[string]interface{}{"key1": "val1"}},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctx := FromMap(table.items)

			gp := filepath.Join("fixtures", table.name+".golden")
			encoded := helpers.ReadFile(t, gp)

			decoded, err := Decode(encoded)
			assert.NoError(t, err)
			assert.Equal(t, decoded, ctx)
		})
	}
}

func TestDecodeFailsIfBadEncodedData(t *testing.T) {
	decoded, err := Decode([]byte("oh noes"))
	assert.Equal(t, errors.New("invalid character 'o' looking for beginning of value").Error(), err.Error())
	assert.Nil(t, decoded)
}

func TestDecodeWithEmptyData(t *testing.T) {
	decoded, err := Decode([]byte(""))
	assert.Nil(t, err)
	assert.Nil(t, decoded)
}

```

`pkg/context/fixtures/one_element.golden`:

```golden
{"key1":"val1"}
```

`pkg/context/fixtures/registered_struct.golden`:

```golden
{"key1":{}}
```

`pkg/defaultpipelines/default_struct_validator.go`:

```go
package defaultpipelines

import (
	"context"
	"sync"

	validator "github.com/go-playground/validator/v10"
)

// DefaultValidator is the default arguments validator for handlers
// in pitaya
type DefaultValidator struct {
	once     sync.Once
	validate *validator.Validate
}

// Validate is the the function responsible for validating the 'in' parameter
// based on the struct tags the parameter has.
// This function has the pipeline.Handler signature so
// it is possible to use it as a pipeline function
func (v *DefaultValidator) Validate(ctx context.Context, in interface{}) (context.Context, interface{}, error) {
	if in == nil {
		return ctx, in, nil
	}

	v.lazyinit()
	if err := v.validate.Struct(in); err != nil {
		return ctx, nil, err
	}

	return ctx, in, nil
}

func (v *DefaultValidator) lazyinit() {
	v.once.Do(func() {
		v.validate = validator.New()
	})
}

```

`pkg/defaultpipelines/default_struct_validator_test.go`:

```go
package defaultpipelines

import (
	"context"
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
)

type TestingStruct struct {
	Name         string `json:"name"`
	Email        string `json:"email" validate:"email"`
	SoftCurrency int    `json:"softCurrency" validate:"gte=0,lte=1000"`
	HardCurrency int    `json:"hardCurrency" validate:"gte=0,lte=200"`
}

func TestDefaultValidator(t *testing.T) {
	validator := &DefaultValidator{}

	var tableTest = map[string]struct {
		s          *TestingStruct
		shouldFail bool
	}{
		"validation_error": {
			s: &TestingStruct{
				Email: "notvalid",
			},
			shouldFail: true,
		},
		"validation_success": {
			s: &TestingStruct{
				Name:         "foo",
				Email:        "foo@tfgco.com",
				SoftCurrency: 100,
				HardCurrency: 10,
			},
		},
		"validate_nil_object": {
			s:          nil,
			shouldFail: false,
		},
	}

	for tname, tbl := range tableTest {
		t.Run(tname, func(t *testing.T) {
			var err error
			if tbl.s == nil {
				_, _, err = validator.Validate(context.Background(), nil)
			} else {
				_, _, err = validator.Validate(context.Background(), tbl.s)
			}

			if tbl.shouldFail {
				assert.Error(t, err)
			} else {
				fmt.Println(err)
				assert.NoError(t, err)
			}
		})
	}
}

```

`pkg/defaultpipelines/struct_validator.go`:

```go
package defaultpipelines

import (
	"context"
)

// StructValidator is the interface that must be implemented
// by a struct validator for the request arguments on pitaya.
//
// The default struct validator used by pitaya is https://github.com/go-playground/validator.
type StructValidator interface {
	Validate(context.Context, interface{}) (context.Context, interface{}, error)
}

// StructValidatorInstance holds the default validator
// on start but can be overridden if needed.
var StructValidatorInstance StructValidator = &DefaultValidator{}

```

`pkg/docgenerator/descriptors.go`:

```go
package docgenerator

import (
	"reflect"
	"strings"

	"github.com/golang/protobuf/proto"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
)

// ProtoDescriptors returns the descriptor for a given message name or .proto file
func ProtoDescriptors(protoName string) ([]byte, error) {
	if strings.HasSuffix(protoName, ".proto") {
		descriptor := proto.FileDescriptor(protoName)
		if descriptor == nil {
			return nil, constants.ErrProtodescriptor
		}
		return descriptor, nil
	}

	if strings.HasPrefix(protoName, "types.") {
		protoName = strings.Replace(protoName, "types.", "google.protobuf.", 1)
	}
	protoReflectTypePointer := proto.MessageType(protoName)
	if protoReflectTypePointer == nil {
		return nil, constants.ErrProtodescriptor
	}

	protoReflectType := protoReflectTypePointer.Elem()
	protoValue := reflect.New(protoReflectType)
	descriptorMethod, ok := protoReflectTypePointer.MethodByName("Descriptor")
	if !ok {
		return nil, constants.ErrProtodescriptor
	}

	descriptorValue := descriptorMethod.Func.Call([]reflect.Value{protoValue})
	protoDescriptor := descriptorValue[0].Bytes()

	return protoDescriptor, nil
}

```

`pkg/docgenerator/descriptors_test.go`:

```go
package docgenerator

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	_ "github.com/topfreegames/pitaya/v3/pkg/protos"
)

func TestProtoDescriptors(t *testing.T) {
	t.Parallel()
	tables := []struct {
		name        string
		messageName string
		err         error
	}{
		{"fail filename", "not_exists.proto", constants.ErrProtodescriptor},
		{"success filename", "kick.proto", nil},
		{"success message", "protos.Push", nil},
		{"fail message", "protos.DoNotExist", constants.ErrProtodescriptor},
	}
	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			bts, err := ProtoDescriptors(table.messageName)
			if table.err != nil {
				assert.EqualError(t, table.err, err.Error())
				assert.Nil(t, bts)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, bts)
			}
		})
	}
}

```

`pkg/docgenerator/generator.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package docgenerator

import (
	"encoding/json"
	"reflect"
	"strings"
	"unicode"

	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/route"
)

type docs struct {
	Handlers docMap `json:"handlers"`
	Remotes  docMap `json:"remotes"`
}

type docMap map[string]*doc

type doc struct {
	Input  interface{}   `json:"input"`
	Output []interface{} `json:"output"`
}

// HandlersDocs returns a map from route to input and output
func HandlersDocs(serverType string, services map[string]*component.Service, getPtrNames bool) (map[string]interface{}, error) {
	docs := &docs{
		Handlers: map[string]*doc{},
	}

	for serviceName, service := range services {
		for name, handler := range service.Handlers {
			routeName := route.NewRoute(serverType, serviceName, name)
			docs.Handlers[routeName.String()] = docForMethod(handler.Method, getPtrNames)
		}
	}

	return docs.Handlers.toMap()
}

// RemotesDocs returns a map from route to input and output
func RemotesDocs(serverType string, services map[string]*component.Service, getPtrNames bool) (map[string]interface{}, error) {
	docs := &docs{
		Remotes: map[string]*doc{},
	}

	for serviceName, service := range services {
		for name, remote := range service.Remotes {
			routeName := route.NewRoute(serverType, serviceName, name)
			docs.Remotes[routeName.String()] = docForMethod(remote.Method, getPtrNames)
		}
	}

	return docs.Remotes.toMap()
}

func (d docMap) toMap() (map[string]interface{}, error) {
	var m map[string]interface{}
	bts, err := json.Marshal(d)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(bts, &m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

func docForMethod(method reflect.Method, getPtrNames bool) *doc {
	doc := &doc{
		Output: []interface{}{},
	}

	if method.Type.NumIn() > 2 {
		isOutput := false
		doc.Input = docForType(method.Type.In(2), isOutput, getPtrNames)
	}

	for i := 0; i < method.Type.NumOut(); i++ {
		isOutput := true
		doc.Output = append(doc.Output, docForType(method.Type.Out(i), isOutput, getPtrNames))
	}

	return doc
}

func parseStruct(typ reflect.Type) reflect.Type {
	switch typ.String() {
	case "time.Time":
		return nil
	default:
		return typ
	}
}

func docForType(typ reflect.Type, isOutput bool, getPtrNames bool) interface{} {
	if typ.Kind() == reflect.Ptr {
		fields := map[string]interface{}{}
		elm := typ.Elem()
		for i := 0; i < elm.NumField(); i++ {
			if name, valid := getName(elm.Field(i), isOutput); valid {
				fields[name] = parseType(elm.Field(i).Type, isOutput, getPtrNames)
			}
		}
		if getPtrNames {
			composite := map[string]interface{}{}
			composite[typ.String()] = fields
			return composite
		}
		return fields
	}

	return parseType(typ, isOutput, getPtrNames)
}

func validName(field reflect.StructField) bool {
	isProtoField := func(name string) bool {
		return strings.HasPrefix(name, "XXX_")
	}

	isPrivateField := func(name string) bool {
		for _, r := range name {
			return unicode.IsLower(r)
		}

		return true
	}

	isIgnored := func(field reflect.StructField) bool {
		return field.Tag.Get("json") == "-"
	}

	return !isProtoField(field.Name) && !isPrivateField(field.Name) && !isIgnored(field)
}

func firstLetterToLower(name string, isOutput bool) string {
	if isOutput {
		return name
	}

	return string(append([]byte{strings.ToLower(name)[0]}, name[1:]...))
}

func getName(field reflect.StructField, isOutput bool) (name string, valid bool) {
	if !validName(field) {
		return "", false
	}

	name, ok := field.Tag.Lookup("json")
	if !ok {
		return firstLetterToLower(field.Name, isOutput), true
	}

	return strings.Split(name, ",")[0], true
}

func parseType(typ reflect.Type, isOutput bool, getPtrNames bool) interface{} {
	var elm reflect.Type

	switch typ.Kind() {
	case reflect.Ptr:
		elm = typ.Elem()
	case reflect.Struct:
		elm = parseStruct(typ)
		if elm == nil {
			return typ.String()
		}
	case reflect.Slice:
		parsed := parseType(typ.Elem(), isOutput, getPtrNames)
		if parsed == "uint8" {
			return "[]byte"
		}
		return []interface{}{parsed}
	default:
		return typ.String()
	}

	fields := map[string]interface{}{}
	for i := 0; i < elm.NumField(); i++ {
		if name, valid := getName(elm.Field(i), isOutput); valid {
			fields[name] = parseType(elm.Field(i).Type, isOutput, getPtrNames)
		}
	}
	if getPtrNames {
		composite := map[string]interface{}{}
		composite[typ.String()] = fields
		return composite
	}
	return fields
}

```

`pkg/docgenerator/generator_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package docgenerator

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/protos/test"
)

type MyComp struct {
	component.Base
}

type MyStruct struct {
	Str             string
	privateInt      int
	Int             int       `json:"int"`
	Time            time.Time `json:"time"`
	NotOnJSONString string    `json:"-"`
	Bytes           []byte    `json:"bytes"`
	Struct          *struct {
		Int        int `json:"int"`
		NotPointer struct {
			Str string `json:"str"`
			Int int
		} `json:"notPointer"`
	} `json:"struct"`
	Slice []*struct {
		Int int `json:"int"`
		Str string
	} `json:"slice"`
	NotPointer struct {
		Str string `json:"str"`
		Int int
	} `json:"notPointer"`
}

func (m *MyComp) Init() {}

func (m *MyComp) Shutdown() {}

func (m *MyComp) HandlerEmpty(ctx context.Context) {}

func (m *MyComp) HandlerRaw(ctx context.Context, b []byte) ([]byte, error) {
	return nil, nil
}

func (m *MyComp) HandlerOrRemoteStruct(ctx context.Context, s *MyStruct) (*MyStruct, error) {
	s.privateInt = 0
	return nil, nil
}

func (m *MyComp) RemoteStruct(ctx context.Context, ss *test.SomeStruct) (*test.SomeStruct, error) {
	return nil, nil
}

func TestHandlersDoc(t *testing.T) {
	t.Parallel()

	handlerServices := map[string]*component.Service{}
	s := component.NewService(&MyComp{}, []component.Option{})
	err := s.ExtractHandler()
	assert.NoError(t, err)
	handlerServices[s.Name] = s

	doc, err := HandlersDocs("metagame", handlerServices, false)
	assert.NoError(t, err)
	assert.Equal(t, map[string]interface{}{
		"metagame.MyComp.HandlerEmpty": map[string]interface{}{
			"output": []interface{}{},
			"input":  interface{}(nil),
		},
		"metagame.MyComp.HandlerRaw": map[string]interface{}{
			"input":  "[]byte",
			"output": []interface{}{"[]byte", "error"},
		},
		"metagame.MyComp.HandlerOrRemoteStruct": map[string]interface{}{
			"input": map[string]interface{}{
				"bytes": "[]byte",
				"int":   "int",
				"notPointer": map[string]interface{}{
					"int": "int",
					"str": "string",
				},
				"str": "string",
				"struct": map[string]interface{}{
					"int": "int",
					"notPointer": map[string]interface{}{
						"int": "int",
						"str": "string",
					},
				},
				"slice": []interface{}{
					map[string]interface{}{
						"int": "int",
						"str": "string",
					},
				},
				"time": "time.Time",
			},
			"output": []interface{}{
				map[string]interface{}{
					"int": "int",
					"notPointer": map[string]interface{}{
						"Int": "int",
						"str": "string",
					},
					"Str": "string",
					"struct": map[string]interface{}{
						"int": "int",
						"notPointer": map[string]interface{}{
							"Int": "int",
							"str": "string",
						},
					},
					"slice": []interface{}{
						map[string]interface{}{
							"int": "int",
							"Str": "string",
						},
					},
					"time":  "time.Time",
					"bytes": "[]byte",
				},
				"error",
			},
		},
		"metagame.MyComp.RemoteStruct": map[string]interface{}{
			"input": map[string]interface{}{
				"A": "int32",
				"B": "string",
			},
			"output": []interface{}{
				map[string]interface{}{
					"A": "int32",
					"B": "string",
				},
				"error",
			},
		},
	}, doc)
}

func TestHandlersDocTrue(t *testing.T) {
	t.Parallel()

	handlerServices := map[string]*component.Service{}
	s := component.NewService(&MyComp{}, []component.Option{})
	err := s.ExtractHandler()
	assert.NoError(t, err)
	handlerServices[s.Name] = s

	doc, err := HandlersDocs("metagame", handlerServices, false)
	assert.NoError(t, err)
	assert.Equal(t, map[string]interface{}{
		"metagame.MyComp.HandlerOrRemoteStruct": map[string]interface{}{
			"input": map[string]interface{}{
				"time":  "time.Time",
				"bytes": "[]byte",
				"int":   "int",
				"notPointer": map[string]interface{}{
					"int": "int",
					"str": "string",
				},
				"slice": []interface{}{map[string]interface{}{
					"int": "int",
					"str": "string",
				},
				},
				"str": "string",
				"struct": map[string]interface{}{
					"int": "int",
					"notPointer": map[string]interface{}{
						"int": "int",
						"str": "string",
					},
				},
			},
			"output": []interface{}{map[string]interface{}{
				"Str":   "string",
				"bytes": "[]byte",
				"int":   "int",
				"notPointer": map[string]interface{}{
					"Int": "int",
					"str": "string",
				},
				"slice": []interface{}{map[string]interface{}{
					"Str": "string",
					"int": "int",
				},
				},
				"struct": map[string]interface{}{
					"int": "int",
					"notPointer": map[string]interface{}{
						"Int": "int",
						"str": "string",
					},
				},
				"time": "time.Time",
			},
				"error",
			},
		},
		"metagame.MyComp.HandlerRaw": map[string]interface{}{
			"input": "[]byte",
			"output": []interface{}{
				"[]byte",
				"error",
			},
		},
		"metagame.MyComp.RemoteStruct": map[string]interface{}{
			"input": map[string]interface{}{
				"A": "int32",
				"B": "string",
			},
			"output": []interface{}{map[string]interface{}{
				"A": "int32",
				"B": "string",
			},
				"error",
			},
		},
		"metagame.MyComp.HandlerEmpty": map[string]interface{}{
			"output": []interface{}{},
			"input":  interface{}(nil),
		},
	}, doc)
}

func TestRemotesDoc(t *testing.T) {
	t.Parallel()

	remoteServices := map[string]*component.Service{}
	s := component.NewService(&MyComp{}, []component.Option{})
	err := s.ExtractRemote()
	assert.NoError(t, err)
	remoteServices[s.Name] = s

	doc, err := RemotesDocs("metagame", remoteServices, false)
	assert.NoError(t, err)
	assert.Equal(t, map[string]interface{}{
		"metagame.MyComp.RemoteStruct": map[string]interface{}{
			"input": map[string]interface{}{
				"A": "int32",
				"B": "string",
			},
			"output": []interface{}{
				map[string]interface{}{
					"A": "int32",
					"B": "string",
				},
				"error",
			},
		},
	}, doc)
}

func TestRemotesDocTrue(t *testing.T) {
	t.Parallel()
	remoteServices := map[string]*component.Service{}
	s := component.NewService(&MyComp{}, []component.Option{})
	err := s.ExtractRemote()
	assert.NoError(t, err)
	remoteServices[s.Name] = s
	doc, err := RemotesDocs("metagame", remoteServices, true)
	assert.NoError(t, err)
	assert.Equal(t, map[string]interface{}{
		"metagame.MyComp.RemoteStruct": map[string]interface{}{
			"input": map[string]interface{}{
				"*test.SomeStruct": map[string]interface{}{

					"A": "int32",
					"B": "string",
				},
			},
			"output": []interface{}{
				map[string]interface{}{
					"*test.SomeStruct": map[string]interface{}{
						"A": "int32",
						"B": "string",
					}},
				"error",
			},
		},
	}, doc)
}

```

`pkg/errors/errors.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package errors

import "errors"

// ErrUnknownCode is a string code representing an unknown error
// This will be used when no error code is sent by the handler
const ErrUnknownCode = "PIT-000"

// ErrInternalCode is a string code representing an internal Pitaya error
const ErrInternalCode = "PIT-500"

// ErrNotFoundCode is a string code representing a not found related error
const ErrNotFoundCode = "PIT-404"

// ErrBadRequestCode is a string code representing a bad request related error
const ErrBadRequestCode = "PIT-400"

// ErrClientClosedRequest is a string code representing the client closed request error
const ErrClientClosedRequest = "PIT-499"

// ErrClosedRequest is a string code representing the closed request error
const ErrClosedRequest = "PIT-498"

// Error is an error with a code, message and metadata
type Error struct {
	Code     string
	Message  string
	Metadata map[string]string
}

// NewError ctor
func NewError(err error, code string, metadata ...map[string]string) *Error {
	var pitayaErr *Error
	if ok := errors.As(err, &pitayaErr); ok {
		if len(metadata) > 0 {
			mergeMetadatas(pitayaErr, metadata[0])
		}
		return pitayaErr
	}

	e := &Error{
		Code:    code,
		Message: err.Error(),
	}
	if len(metadata) > 0 {
		e.Metadata = metadata[0]
	}
	return e

}

func (e *Error) Error() string {
	return e.Message
}

func mergeMetadatas(pitayaErr *Error, metadata map[string]string) {
	if pitayaErr.Metadata == nil {
		pitayaErr.Metadata = metadata
		return
	}

	for key, value := range metadata {
		pitayaErr.Metadata[key] = value
	}
}

// CodeFromError returns the code of error.
// If error is nil, return empty string.
// If error is not a pitaya error, returns unkown code
func CodeFromError(err error) string {
	if err == nil {
		return ""
	}

	pitayaErr, ok := err.(*Error)
	if !ok {
		return ErrUnknownCode
	}

	if pitayaErr == nil {
		return ""
	}

	return pitayaErr.Code
}

```

`pkg/errors/errors_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package errors

import (
	"errors"
	"testing"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
)

func TestNewError(t *testing.T) {
	t.Parallel()

	const code = "code"

	type (
		input struct {
			err      error
			code     string
			metadata map[string]string
		}

		expected struct {
			code     string
			metadata map[string]string
		}
	)

	tables := []struct {
		name     string
		input    input
		expected expected
	}{
		{"nil_metadata",
			input{err: errors.New(uuid.New().String()), code: code, metadata: nil},
			expected{code: code, metadata: nil},
		},
		{"empty_metadata",
			input{err: errors.New(uuid.New().String()), code: code, metadata: map[string]string{}},
			expected{code: code, metadata: map[string]string{}},
		},
		{"non_empty_metadata",
			input{err: errors.New(uuid.New().String()), code: code, metadata: map[string]string{"key": "value"}},
			expected{code: code, metadata: map[string]string{"key": "value"}},
		},
		{"pitaya_error",
			input{
				err:      NewError(errors.New(uuid.New().String()), code, map[string]string{"key1": "value1", "key2": "value2"}),
				code:     "another-code",
				metadata: map[string]string{"key1": "new-value1", "key3": "value3"},
			},
			expected{code: code, metadata: map[string]string{"key1": "new-value1", "key2": "value2", "key3": "value3"}},
		},
		{"pitaya_error_nil_metadata",
			input{
				err:      NewError(errors.New(uuid.New().String()), code),
				code:     "another-code",
				metadata: map[string]string{"key1": "value1", "key2": "value2"},
			},
			expected{code: code, metadata: map[string]string{"key1": "value1", "key2": "value2"}},
		},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			var err *Error
			if table.input.metadata != nil {
				err = NewError(table.input.err, table.input.code, table.input.metadata)
			} else {
				err = NewError(table.input.err, table.input.code)
			}
			assert.NotNil(t, err)
			assert.Equal(t, table.input.err.Error(), err.Message)
			assert.Equal(t, table.expected.code, err.Code)
			assert.Equal(t, table.expected.metadata, err.Metadata)
		})
	}
}

func TestErrorError(t *testing.T) {
	t.Parallel()

	sourceErr := errors.New(uuid.New().String())
	err := NewError(sourceErr, uuid.New().String())

	errStr := err.Error()
	assert.Equal(t, sourceErr.Error(), errStr)
}

func TestCodeFromError(t *testing.T) {
	t.Parallel()

	errTest := errors.New("error")
	codeNotFound := "GAME-404"

	tables := map[string]struct {
		err  error
		code string
	}{
		"test_not_error": {
			err:  nil,
			code: "",
		},

		"test_not_pitaya_error": {
			err:  errTest,
			code: ErrUnknownCode,
		},

		"test_nil_pitaya_error": {
			err:  func() *Error { var err *Error; return err }(),
			code: "",
		},

		"test_pitaya_error": {
			err:  NewError(errTest, codeNotFound),
			code: codeNotFound,
		},
	}

	for name, table := range tables {
		t.Run(name, func(t *testing.T) {
			code := CodeFromError(table.err)
			assert.Equal(t, table.code, code)
		})
	}
}

```

`pkg/group.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package pitaya

import (
	"context"
	"time"

	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
)

// Group represents an agglomeration of UIDs which is used to manage
// users. Data sent to the group will be sent to all users in it.

// GroupCreate creates a group
func (app *App) GroupCreate(ctx context.Context, groupName string) error {
	return app.groups.GroupCreate(ctx, groupName)
}

// GroupCreateWithTTL creates a group with given TTL
func (app *App) GroupCreateWithTTL(ctx context.Context, groupName string, ttlTime time.Duration) error {
	return app.groups.GroupCreateWithTTL(ctx, groupName, ttlTime)
}

// GroupMembers returns all member's UIDs
func (app *App) GroupMembers(ctx context.Context, groupName string) ([]string, error) {
	return app.groups.GroupMembers(ctx, groupName)
}

// GroupBroadcast pushes the message to all members inside group
func (app *App) GroupBroadcast(ctx context.Context, frontendType, groupName, route string, v interface{}) error {
	logger.Log.Debugf("Type=Broadcast Route=%s, Data=%+v", route, v)

	members, err := app.GroupMembers(ctx, groupName)
	if err != nil {
		return err
	}
	return app.sendDataToMembers(members, frontendType, route, v)
}

func (app *App) sendDataToMembers(uids []string, frontendType, route string, v interface{}) error {
	errUids, err := app.SendPushToUsers(route, v, uids, frontendType)
	if err != nil {
		logger.Log.Errorf("Group push message error, UID=%v, Error=%s", errUids, err.Error())
		return err
	}
	return nil
}

// GroupContainsMember checks whether an UID is contained in group or not
func (app *App) GroupContainsMember(ctx context.Context, groupName, uid string) (bool, error) {
	if uid == "" {
		return false, constants.ErrEmptyUID
	}
	return app.groups.GroupContainsMember(ctx, groupName, uid)
}

// GroupAddMember adds UID to group
func (app *App) GroupAddMember(ctx context.Context, groupName, uid string) error {
	if uid == "" {
		return constants.ErrEmptyUID
	}
	logger.Log.Debugf("Add user to group %s, UID=%s", groupName, uid)
	return app.groups.GroupAddMember(ctx, groupName, uid)
}

// GroupRemoveMember removes specified UID from group
func (app *App) GroupRemoveMember(ctx context.Context, groupName, uid string) error {
	logger.Log.Debugf("Remove user from group %s, UID=%s", groupName, uid)
	return app.groups.GroupRemoveMember(ctx, groupName, uid)
}

// GroupRemoveAll clears all UIDs
func (app *App) GroupRemoveAll(ctx context.Context, groupName string) error {
	return app.groups.GroupRemoveAll(ctx, groupName)
}

// GroupCountMembers get current member amount in group
func (app *App) GroupCountMembers(ctx context.Context, groupName string) (int, error) {
	return app.groups.GroupCountMembers(ctx, groupName)
}

// GroupRenewTTL renews group with the initial TTL
func (app *App) GroupRenewTTL(ctx context.Context, groupName string) error {
	return app.groups.GroupRenewTTL(ctx, groupName)
}

// GroupDelete deletes whole group, including UIDs and base group
func (app *App) GroupDelete(ctx context.Context, groupName string) error {
	return app.groups.GroupDelete(ctx, groupName)
}

```

`pkg/group_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package pitaya

import (
	"context"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/session/mocks"
)

func createGroupTestApp() Pitaya {
	config := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *config)
	return app
}

func TestCreateDuplicatedGroup(t *testing.T) {
	ctx := context.Background()
	t.Parallel()
	app := createGroupTestApp()
	err := app.GroupCreate(ctx, "testCreateDuplicatedGroup")
	assert.NoError(t, err)
	err = app.GroupCreate(ctx, "testCreateDuplicatedGroup")
	assert.Error(t, err)
	assert.Equal(t, constants.ErrGroupAlreadyExists, err)
}

func TestCreateGroup(t *testing.T) {
	ctx := context.Background()
	t.Parallel()
	app := createGroupTestApp()
	err := app.GroupCreate(ctx, "testCreateGroup")
	assert.NoError(t, err)
	count, err := app.GroupCountMembers(ctx, "testCreateGroup")
	assert.NoError(t, err)
	assert.Equal(t, 0, count)
	err = app.GroupRenewTTL(ctx, "testCreateGroup")
	assert.Error(t, err)
}

func TestCreateGroupWithTTL(t *testing.T) {
	ctx := context.Background()
	t.Parallel()
	app := createGroupTestApp()
	err := app.GroupCreateWithTTL(ctx, "testCreateGroupWithTTL", 10)
	assert.NoError(t, err)
	count, err := app.GroupCountMembers(ctx, "testCreateGroupWithTTL")
	assert.NoError(t, err)
	assert.Equal(t, 0, count)
	err = app.GroupRenewTTL(ctx, "testCreateGroupWithTTL")
	assert.NoError(t, err)
}

func TestGroupAddMember(t *testing.T) {
	ctx := context.Background()
	t.Parallel()
	tables := []struct {
		name     string
		frontend bool
		UID      string
		err      error
	}{
		{"frontend_uid", true, "someuid1", nil},
		{"frontend_nouid", true, "", constants.ErrEmptyUID},
		{"backend_nouid", false, "", constants.ErrEmptyUID},
		{"backend_uid", false, "ola1", nil},
	}

	app := createGroupTestApp()
	err := app.GroupCreate(ctx, "testGroupAddMember")
	assert.NoError(t, err)

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			s := mocks.NewMockSession(ctrl)
			s.EXPECT().GetIsFrontend().Return(table.frontend).AnyTimes()
			s.EXPECT().UID().Return(table.UID).AnyTimes()
			err = app.GroupAddMember(ctx, "testGroupAddMember", s.UID())
			assert.Equal(t, table.err, err)
			if err == nil {
				_, err := app.GroupContainsMember(ctx, "testGroupAddMember", table.UID)
				if table.err == nil {
					assert.NoError(t, err)
				} else {
					assert.Error(t, err)
				}
			}
		})
	}
}

func TestGroupAddDuplicatedMember(t *testing.T) {
	ctx := context.Background()
	t.Parallel()
	app := createGroupTestApp()
	err := app.GroupCreate(ctx, "testGroupAddDuplicatedMember")
	assert.NoError(t, err)
	err = app.GroupAddMember(ctx, "testGroupAddDuplicatedMember", "duplicatedUid")
	assert.NoError(t, err)
	err = app.GroupAddMember(ctx, "testGroupAddDuplicatedMember", "duplicatedUid")
	assert.Error(t, err)
	assert.Equal(t, constants.ErrMemberAlreadyExists, err)
}

func TestGroupContainsMember(t *testing.T) {
	ctx := context.Background()
	t.Parallel()
	tables := []struct {
		name     string
		frontend bool
		UID      string
		err      error
	}{
		{"frontend_uid", true, "someuid2", nil},
		{"backend_uid", false, "ola2", nil},
		{"backend_nouid", false, "", constants.ErrEmptyUID},
	}

	app := createGroupTestApp()
	err := app.GroupCreate(ctx, "testGroupContainsMember")
	assert.NoError(t, err)

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			s := mocks.NewMockSession(ctrl)
			s.EXPECT().GetIsFrontend().Return(table.frontend).AnyTimes()
			s.EXPECT().UID().Return(table.UID).AnyTimes()
			err = app.GroupAddMember(ctx, "testGroupContainsMember", s.UID())
			if table.err == nil {
				assert.NoError(t, err)
			} else {
				assert.Error(t, err)
			}
			b, err := app.GroupContainsMember(ctx, "testGroupContainsMember", table.UID)
			if table.err == nil {
				assert.True(t, b)
				assert.NoError(t, err)
			} else {
				assert.False(t, b)
				assert.Error(t, err)
			}
		})
	}
}

func TestRemove(t *testing.T) {
	ctx := context.Background()
	t.Parallel()
	tables := []struct {
		name     string
		frontend bool
		UID      string
		err      error
	}{
		{"frontend_uid", true, "someuid2", nil},
		{"backend_uid", false, "ola2", nil},
	}

	app := createGroupTestApp()
	err := app.GroupCreate(ctx, "testRemove")
	assert.NoError(t, err)

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			s := mocks.NewMockSession(ctrl)
			s.EXPECT().GetIsFrontend().Return(table.frontend).AnyTimes()
			s.EXPECT().UID().Return(table.UID).AnyTimes()
			err = app.GroupAddMember(ctx, "testRemove", s.UID())
			assert.NoError(t, err)
			err = app.GroupRemoveMember(ctx, "testRemove", s.UID())
			assert.NoError(t, err)
			res, err := app.GroupContainsMember(ctx, "testRemove", table.UID)
			assert.NoError(t, err)
			assert.False(t, res)
		})
	}
}

func TestDelete(t *testing.T) {
	ctx := context.Background()
	t.Parallel()
	tables := []struct {
		name     string
		frontend bool
		UID      string
		err      error
	}{
		{"frontend_uid", true, "leaveSomeuid2", nil},
		{"backend_uid", false, "leaveOla2", nil},
	}

	app := createGroupTestApp()
	err := app.GroupCreate(ctx, "testDeleteSufix")
	assert.NoError(t, err)

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			err = app.GroupCreate(ctx, "testDelete")
			assert.NoError(t, err)
			s := mocks.NewMockSession(ctrl)
			s.EXPECT().GetIsFrontend().Return(table.frontend).AnyTimes()
			s.EXPECT().UID().Return(table.UID).AnyTimes()
			err = app.GroupAddMember(ctx, "testDeleteSufix", s.UID())
			assert.NoError(t, err)
			err = app.GroupAddMember(ctx, "testDelete", s.UID())
			assert.NoError(t, err)
			err = app.GroupDelete(ctx, "testDelete")
			assert.NoError(t, err)

			res, err := app.GroupContainsMember(ctx, "testDeleteSufix", table.UID)
			assert.NoError(t, err)
			assert.True(t, res)
			_, err = app.GroupContainsMember(ctx, "testDelete", table.UID)
			assert.Error(t, err)
			assert.Equal(t, constants.ErrGroupNotFound, err)
		})
	}
}

func TestRemoveAll(t *testing.T) {
	ctx := context.Background()
	t.Parallel()
	tables := []struct {
		name     string
		frontend bool
		UID      string
		err      error
	}{
		{"frontend_uid", true, "removeSomeuid2", nil},
		{"backend_uid", false, "removeOla2", nil},
	}

	app := createGroupTestApp()
	err := app.GroupCreate(ctx, "testRemoveAllSufix")
	assert.NoError(t, err)
	err = app.GroupCreate(ctx, "testRemoveAll")
	assert.NoError(t, err)

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			s := mocks.NewMockSession(ctrl)
			s.EXPECT().GetIsFrontend().Return(table.frontend).AnyTimes()
			s.EXPECT().UID().Return(table.UID).AnyTimes()
			err = app.GroupAddMember(ctx, "testRemoveAllSufix", s.UID())
			assert.NoError(t, err)
			err = app.GroupAddMember(ctx, "testRemoveAll", s.UID())
			assert.NoError(t, err)
			err = app.GroupRemoveAll(ctx, "testRemoveAll")
			assert.NoError(t, err)

			res, err := app.GroupContainsMember(ctx, "testRemoveAllSufix", table.UID)
			assert.NoError(t, err)
			assert.True(t, res)
			res, err = app.GroupContainsMember(ctx, "testRemoveAll", table.UID)
			assert.NoError(t, err)
			assert.False(t, res)
		})
	}
}

func TestCount(t *testing.T) {
	ctx := context.Background()
	t.Parallel()
	tables := []struct {
		name     string
		frontend bool
		UID      string
		err      error
	}{
		{"frontend_uid", true, "someuid2", nil},
		{"backend_uid", false, "ola2", nil},
	}

	app := createGroupTestApp()
	err := app.GroupCreate(ctx, "testCount")
	assert.NoError(t, err)

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			s := mocks.NewMockSession(ctrl)
			s.EXPECT().GetIsFrontend().Return(table.frontend).AnyTimes()
			s.EXPECT().UID().Return(table.UID).AnyTimes()
			err = app.GroupAddMember(ctx, "testCount", s.UID())
			assert.NoError(t, err)
			res, err := app.GroupCountMembers(ctx, "testCount")
			assert.NoError(t, err)
			assert.Equal(t, 1, res)

			err = app.GroupRemoveAll(ctx, "testCount")
			assert.NoError(t, err)
		})
	}
}

func TestMembers(t *testing.T) {
	ctx := context.Background()
	t.Parallel()
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	app := createGroupTestApp()
	err := app.GroupCreate(ctx, "testGroupMembers")
	assert.NoError(t, err)
	s1 := mocks.NewMockSession(ctrl)
	s1.EXPECT().GetIsFrontend().Return(true).AnyTimes()
	s1.EXPECT().UID().Return("someid1").AnyTimes()

	s2 := mocks.NewMockSession(ctrl)
	s2.EXPECT().GetIsFrontend().Return(true).AnyTimes()
	s2.EXPECT().UID().Return("someid2").AnyTimes()

	err = app.GroupAddMember(ctx, "testGroupMembers", s1.UID())
	assert.NoError(t, err)
	err = app.GroupAddMember(ctx, "testGroupMembers", s2.UID())
	assert.NoError(t, err)

	res, err := app.GroupMembers(ctx, "testGroupMembers")
	assert.NoError(t, err)
	assert.ElementsMatch(t, []string{"someid1", "someid2"}, res)
}

func TestBroadcast(t *testing.T) {
	ctx := context.Background()
	t.Parallel()
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	id1 := int64(1)
	id2 := int64(2)
	uid1 := "uid1"
	uid2 := "uid2"

	s1 := mocks.NewMockSession(ctrl)
	s1.EXPECT().GetIsFrontend().Return(true).AnyTimes()
	s1.EXPECT().UID().Return("someid1").AnyTimes()
	s1.EXPECT().ID().Return(id1).AnyTimes()

	s2 := mocks.NewMockSession(ctrl)
	s2.EXPECT().GetIsFrontend().Return(true).AnyTimes()
	s2.EXPECT().ID().Return(id2).AnyTimes()

	mockSessionPool := mocks.NewMockSessionPool(ctrl)
	mockSessionPool.EXPECT().GetSessionByUID(uid1).Return(s1).Times(1)
	mockSessionPool.EXPECT().GetSessionByUID(uid2).Return(s2).Times(1)

	config := config.NewDefaultPitayaConfig()
	builder := NewDefaultBuilder(true, "testtype", Cluster, map[string]string{}, *config)
	builder.SessionPool = mockSessionPool
	app := builder.Build()

	err := app.GroupCreate(ctx, "testBroadcast")
	assert.NoError(t, err)

	err = app.GroupAddMember(ctx, "testBroadcast", uid1)
	assert.NoError(t, err)
	err = app.GroupAddMember(ctx, "testBroadcast", uid2)
	assert.NoError(t, err)
	route := "some.route.bla"
	data := []byte("hellow")
	s1.EXPECT().Push(route, data).Times(1)
	s2.EXPECT().Push(route, data).Times(1)
	err = app.GroupBroadcast(ctx, "testtype", "testBroadcast", route, data)
	assert.NoError(t, err)
}

```

`pkg/groups/etcd_group_service.go`:

```go
package groups

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"go.etcd.io/etcd/api/v3/mvccpb"
	clientv3 "go.etcd.io/etcd/client/v3"
	"go.etcd.io/etcd/client/v3/namespace"
)

var (
	clientInstance     *clientv3.Client
	transactionTimeout time.Duration
	etcdOnce           sync.Once
)

// EtcdGroupService base ETCD struct solution
type EtcdGroupService struct {
	cancelFunc context.CancelFunc
}

// NewEtcdGroupService returns a new group instance
func NewEtcdGroupService(conf config.EtcdGroupServiceConfig, clientOrNil *clientv3.Client) (*EtcdGroupService, error) {
	err := initClientInstance(conf, clientOrNil)
	if err != nil {
		return nil, err
	}
	return &EtcdGroupService{}, err
}

func initClientInstance(config config.EtcdGroupServiceConfig, clientOrNil *clientv3.Client) error {
	var err error
	etcdOnce.Do(func() {
		if clientOrNil != nil {
			clientInstance = clientOrNil
		} else {
			clientInstance, err = createBaseClient(config)
		}
		if err != nil {
			logger.Log.Fatalf("error initializing singleton etcd client in groups: %s", err.Error())
			return
		}
		transactionTimeout = config.TransactionTimeout
	})
	return err
}

func createBaseClient(config config.EtcdGroupServiceConfig) (*clientv3.Client, error) {
	cli, err := clientv3.New(clientv3.Config{
		Endpoints:   config.Endpoints,
		DialTimeout: config.DialTimeout,
	})
	if err != nil {
		return nil, err
	}
	cli.KV = namespace.NewKV(cli.KV, config.Prefix)
	return cli, nil
}

func groupKey(groupName string) string {
	return fmt.Sprintf("groups/%s", groupName)
}

func memberKey(groupName, uid string) string {
	return fmt.Sprintf("%s/uids/%s", groupKey(groupName), uid)
}

func getGroupKV(ctx context.Context, groupName string) (*mvccpb.KeyValue, error) {
	ctxT, cancel := context.WithTimeout(ctx, transactionTimeout)
	defer cancel()
	etcdRes, err := clientInstance.Get(ctxT, groupKey(groupName))
	if err != nil {
		return nil, err
	}
	if etcdRes.Count == 0 {
		return nil, constants.ErrGroupNotFound
	}
	return etcdRes.Kvs[0], nil
}

func (c *EtcdGroupService) createGroup(ctx context.Context, groupName string, leaseID clientv3.LeaseID) error {
	var etcdRes *clientv3.TxnResponse
	var err error

	ctxT, cancel := context.WithTimeout(ctx, transactionTimeout)
	defer cancel()
	if leaseID != 0 {
		etcdRes, err = clientInstance.Txn(ctxT).
			If(clientv3.Compare(clientv3.CreateRevision(groupKey(groupName)), "=", 0)).
			Then(clientv3.OpPut(groupKey(groupName), "", clientv3.WithLease(leaseID))).
			Commit()
	} else {
		etcdRes, err = clientInstance.Txn(ctxT).
			If(clientv3.Compare(clientv3.CreateRevision(groupKey(groupName)), "=", 0)).
			Then(clientv3.OpPut(groupKey(groupName), "")).
			Commit()
	}

	if err != nil {
		return err
	}
	if !etcdRes.Succeeded {
		return constants.ErrGroupAlreadyExists
	}
	return nil
}

// GroupCreate creates a group struct inside ETCD, without TTL
func (c *EtcdGroupService) GroupCreate(ctx context.Context, groupName string) error {
	return c.createGroup(ctx, groupName, 0)
}

// GroupCreateWithTTL creates a group struct inside ETCD, with TTL, using leaseID
func (c *EtcdGroupService) GroupCreateWithTTL(ctx context.Context, groupName string, ttlTime time.Duration) error {
	ctxT, cancel := context.WithTimeout(ctx, transactionTimeout)
	defer cancel()
	lease, err := clientInstance.Grant(ctxT, int64(ttlTime.Seconds()))
	if err != nil {
		return err
	}
	return c.createGroup(ctx, groupName, lease.ID)
}

// GroupMembers returns all member's UIDs
func (c *EtcdGroupService) GroupMembers(ctx context.Context, groupName string) ([]string, error) {
	prefix := memberKey(groupName, "")
	ctxT, cancel := context.WithTimeout(ctx, transactionTimeout)
	defer cancel()
	etcdRes, err := clientInstance.Txn(ctxT).
		If(clientv3.Compare(clientv3.CreateRevision(groupKey(groupName)), ">", 0)).
		Then(clientv3.OpGet(prefix, clientv3.WithPrefix(), clientv3.WithKeysOnly())).
		Commit()

	if err != nil {
		return nil, err
	}
	if !etcdRes.Succeeded {
		return nil, constants.ErrGroupNotFound
	}

	getRes := etcdRes.Responses[0].GetResponseRange()
	members := make([]string, getRes.GetCount())
	for i, kv := range getRes.GetKvs() {
		members[i] = string(kv.Key)[len(prefix):]
	}
	return members, nil
}

// GroupContainsMember checks whether a UID is contained in current group or not
func (c *EtcdGroupService) GroupContainsMember(ctx context.Context, groupName, uid string) (bool, error) {
	ctxT, cancel := context.WithTimeout(ctx, transactionTimeout)
	defer cancel()
	etcdRes, err := clientInstance.Txn(ctxT).
		If(clientv3.Compare(clientv3.CreateRevision(groupKey(groupName)), ">", 0)).
		Then(clientv3.OpGet(memberKey(groupName, uid), clientv3.WithCountOnly())).
		Commit()

	if err != nil {
		return false, err
	}
	if !etcdRes.Succeeded {
		return false, constants.ErrGroupNotFound
	}
	return etcdRes.Responses[0].GetResponseRange().GetCount() > 0, nil
}

// GroupAddMember adds UID to group
func (c *EtcdGroupService) GroupAddMember(ctx context.Context, groupName, uid string) error {
	var etcdRes *clientv3.TxnResponse
	kv, err := getGroupKV(ctx, groupName)
	if err != nil {
		return err
	}

	ctxT, cancel := context.WithTimeout(ctx, transactionTimeout)
	defer cancel()
	if kv.Lease != 0 {
		etcdRes, err = clientInstance.Txn(ctxT).
			If(clientv3.Compare(clientv3.CreateRevision(groupKey(groupName)), ">", 0),
				clientv3.Compare(clientv3.CreateRevision(memberKey(groupName, uid)), "=", 0)).
			Then(clientv3.OpPut(memberKey(groupName, uid), "", clientv3.WithLease(clientv3.LeaseID(kv.Lease)))).
			Commit()
	} else {
		etcdRes, err = clientInstance.Txn(ctxT).
			If(clientv3.Compare(clientv3.CreateRevision(groupKey(groupName)), ">", 0),
				clientv3.Compare(clientv3.CreateRevision(memberKey(groupName, uid)), "=", 0)).
			Then(clientv3.OpPut(memberKey(groupName, uid), "")).
			Commit()
	}

	if err != nil {
		return err
	}
	if !etcdRes.Succeeded {
		return constants.ErrMemberAlreadyExists
	}
	return nil
}

// GroupRemoveMember removes specified UID from group
func (c *EtcdGroupService) GroupRemoveMember(ctx context.Context, groupName, uid string) error {
	ctxT, cancel := context.WithTimeout(ctx, transactionTimeout)
	defer cancel()
	etcdRes, err := clientInstance.Txn(ctxT).
		If(clientv3.Compare(clientv3.CreateRevision(memberKey(groupName, uid)), ">", 0)).
		Then(clientv3.OpDelete(memberKey(groupName, uid))).
		Commit()

	if err != nil {
		return err
	}
	if !etcdRes.Succeeded {
		return constants.ErrMemberNotFound
	}
	return nil
}

// GroupRemoveAll clears all UIDs in the group
func (c *EtcdGroupService) GroupRemoveAll(ctx context.Context, groupName string) error {
	ctxT, cancel := context.WithTimeout(ctx, transactionTimeout)
	defer cancel()
	etcdRes, err := clientInstance.Txn(ctxT).
		If(clientv3.Compare(clientv3.CreateRevision(groupKey(groupName)), ">", 0)).
		Then(clientv3.OpDelete(memberKey(groupName, ""), clientv3.WithPrefix())).
		Commit()

	if err != nil {
		return err
	}
	if !etcdRes.Succeeded {
		return constants.ErrGroupNotFound
	}
	return nil
}

// GroupDelete deletes the whole group, including members and base group
func (c *EtcdGroupService) GroupDelete(ctx context.Context, groupName string) error {
	ctxT, cancel := context.WithTimeout(ctx, transactionTimeout)
	defer cancel()
	etcdRes, err := clientInstance.Txn(ctxT).
		If(clientv3.Compare(clientv3.CreateRevision(groupKey(groupName)), ">", 0)).
		Then(clientv3.OpDelete(memberKey(groupName, ""), clientv3.WithPrefix()),
			clientv3.OpDelete(groupKey(groupName))).
		Commit()

	if err != nil {
		return err
	}
	if !etcdRes.Succeeded {
		return constants.ErrGroupNotFound
	}
	return nil
}

// GroupCountMembers get current member amount in group
func (c *EtcdGroupService) GroupCountMembers(ctx context.Context, groupName string) (int, error) {
	ctxT, cancel := context.WithTimeout(ctx, transactionTimeout)
	defer cancel()
	etcdRes, err := clientInstance.Get(ctxT, memberKey(groupName, ""), clientv3.WithPrefix(), clientv3.WithCountOnly())
	if err != nil {
		return 0, err
	}
	return int(etcdRes.Count), nil
}

// GroupRenewTTL will renew ETCD lease TTL
func (c *EtcdGroupService) GroupRenewTTL(ctx context.Context, groupName string) error {
	kv, err := getGroupKV(ctx, groupName)
	if err != nil {
		return err
	}
	if kv.Lease != 0 {
		ctxT, cancel := context.WithTimeout(ctx, transactionTimeout)
		defer cancel()
		_, err = clientInstance.KeepAliveOnce(ctxT, clientv3.LeaseID(kv.Lease))
		return err
	}
	return constants.ErrEtcdLeaseNotFound
}

func (c *EtcdGroupService) Close() {
	if c.cancelFunc != nil {
		c.cancelFunc()
	}
}

```

`pkg/groups/etcd_group_service_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package groups

import (
	"testing"

	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/helpers"
	"go.etcd.io/etcd/tests/v3/integration"
)

func setup(t *testing.T) (*integration.ClusterV3, GroupService) {
	cluster, cli := helpers.GetTestEtcd(t)
	etcdGroupService, err := NewEtcdGroupService(*&config.NewDefaultPitayaConfig().Groups.Etcd, cli)
	if err != nil {
		panic(err)
	}

	return cluster, etcdGroupService
}

func TestEtcdCreateDuplicatedGroup(t *testing.T) {
	cluster, etcdGroupService := setup(t)
	defer cluster.Terminate(t)
	defer etcdGroupService.Close()
	testCreateDuplicatedGroup(etcdGroupService, t)
}

func TestEtcdCreateGroup(t *testing.T) {
	cluster, etcdGroupService := setup(t)
	defer cluster.Terminate(t)
	defer etcdGroupService.Close()
	testCreateGroup(etcdGroupService, t)
}

func TestEtcdCreateGroupWithTTL(t *testing.T) {
	cluster, etcdGroupService := setup(t)
	defer cluster.Terminate(t)
	defer etcdGroupService.Close()
	testCreateGroupWithTTL(etcdGroupService, t)
}

func TestEtcdGroupAddMember(t *testing.T) {
	cluster, etcdGroupService := setup(t)
	defer cluster.Terminate(t)
	defer etcdGroupService.Close()
	testGroupAddMember(etcdGroupService, t)
}

func TestEtcdGroupAddDuplicatedMember(t *testing.T) {
	cluster, etcdGroupService := setup(t)
	defer cluster.Terminate(t)
	defer etcdGroupService.Close()
	testGroupAddDuplicatedMember(etcdGroupService, t)
}

func TestEtcdGroupContainsMember(t *testing.T) {
	cluster, etcdGroupService := setup(t)
	defer cluster.Terminate(t)
	defer etcdGroupService.Close()
	testGroupContainsMember(etcdGroupService, t)
}

func TestEtcdRemove(t *testing.T) {
	cluster, etcdGroupService := setup(t)
	defer cluster.Terminate(t)
	defer etcdGroupService.Close()
	testRemove(etcdGroupService, t)
}

func TestEtcdDelete(t *testing.T) {
	cluster, etcdGroupService := setup(t)
	defer cluster.Terminate(t)
	defer etcdGroupService.Close()
	testDelete(etcdGroupService, t)
}

func TestEtcdRemoveAll(t *testing.T) {
	cluster, etcdGroupService := setup(t)
	defer cluster.Terminate(t)
	defer etcdGroupService.Close()
	testRemoveAll(etcdGroupService, t)
}

func TestEtcdCount(t *testing.T) {
	cluster, etcdGroupService := setup(t)
	defer cluster.Terminate(t)
	defer etcdGroupService.Close()
	testCount(etcdGroupService, t)
}

func TestEtcdMembers(t *testing.T) {
	cluster, etcdGroupService := setup(t)
	defer cluster.Terminate(t)
	defer etcdGroupService.Close()
	testMembers(etcdGroupService, t)
}

```

`pkg/groups/group_service.go`:

```go
package groups

import (
	"context"
	"time"
)

type (
	// GroupService has ranking methods
	GroupService interface {
		GroupAddMember(ctx context.Context, groupName, uid string) error
		GroupContainsMember(ctx context.Context, groupName, uid string) (bool, error)
		GroupCountMembers(ctx context.Context, groupName string) (int, error)
		GroupCreate(ctx context.Context, groupName string) error
		GroupCreateWithTTL(ctx context.Context, groupName string, ttlTime time.Duration) error
		GroupDelete(ctx context.Context, groupName string) error
		GroupMembers(ctx context.Context, groupName string) ([]string, error)
		GroupRemoveAll(ctx context.Context, groupName string) error
		GroupRemoveMember(ctx context.Context, groupName, uid string) error
		GroupRenewTTL(ctx context.Context, groupName string) error
		Close()
	}
)

func elementIndex(slice []string, element string) (int, bool) {
	for i, sliceElement := range slice {
		if element == sliceElement {
			return i, true
		}
	}
	return 0, false
}

```

`pkg/groups/group_service_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package groups

import (
	"context"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/assert"

	"github.com/topfreegames/pitaya/v3/pkg/constants"
)

func testCreateDuplicatedGroup(gs GroupService, t *testing.T) {
	ctx := context.Background()
	//t.Parallel()
	err := gs.GroupCreate(ctx, "testCreateDuplicatedGroup")
	assert.NoError(t, err)
	err = gs.GroupCreate(ctx, "testCreateDuplicatedGroup")
	assert.Error(t, err)
	assert.Equal(t, constants.ErrGroupAlreadyExists, err)
}

func testCreateGroup(gs GroupService, t *testing.T) {
	ctx := context.Background()
	err := gs.GroupCreate(ctx, "testCreateGroup")
	assert.NoError(t, err)
	count, err := gs.GroupCountMembers(ctx, "testCreateGroup")
	assert.NoError(t, err)
	assert.Equal(t, 0, count)
	err = gs.GroupRenewTTL(ctx, "testCreateGroup")
	assert.Error(t, err)
}

func testCreateGroupWithTTL(gs GroupService, t *testing.T) {
	ctx := context.Background()
	err := gs.GroupCreateWithTTL(ctx, "testCreateGroupWithTTL", 10)
	assert.NoError(t, err)
	count, err := gs.GroupCountMembers(ctx, "testCreateGroupWithTTL")
	assert.NoError(t, err)
	assert.Equal(t, 0, count)
	err = gs.GroupRenewTTL(ctx, "testCreateGroupWithTTL")
	assert.NoError(t, err)
}

func testGroupAddMember(gs GroupService, t *testing.T) {
	ctx := context.Background()
	tables := []struct {
		name     string
		frontend bool
		UID      string
	}{
		{"frontend_uid", true, "someuid1"},
		{"backend_uid", false, "ola1"},
	}

	err := gs.GroupCreate(ctx, "testGroupAddMember")
	assert.NoError(t, err)

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			err = gs.GroupAddMember(ctx, "testGroupAddMember", table.UID)
			assert.NoError(t, err)
			_, err := gs.GroupContainsMember(ctx, "testGroupAddMember", table.UID)
			assert.NoError(t, err)
		})
	}
}

func testGroupAddDuplicatedMember(gs GroupService, t *testing.T) {
	ctx := context.Background()
	err := gs.GroupCreate(ctx, "testGroupAddDuplicatedMember")
	assert.NoError(t, err)
	err = gs.GroupAddMember(ctx, "testGroupAddDuplicatedMember", "duplicatedUid")
	assert.NoError(t, err)
	err = gs.GroupAddMember(ctx, "testGroupAddDuplicatedMember", "duplicatedUid")
	assert.Error(t, err)
	assert.Equal(t, constants.ErrMemberAlreadyExists, err)
}

func testGroupContainsMember(gs GroupService, t *testing.T) {
	ctx := context.Background()
	tables := []struct {
		name     string
		frontend bool
		UID      string
	}{
		{"frontend_uid", true, "someuid2"},
		{"backend_uid", false, "ola2"},
	}

	err := gs.GroupCreate(ctx, "testGroupContainsMember")
	assert.NoError(t, err)

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			err = gs.GroupAddMember(ctx, "testGroupContainsMember", table.UID)
			assert.NoError(t, err)
			b, err := gs.GroupContainsMember(ctx, "testGroupContainsMember", table.UID)
			assert.True(t, b)
			assert.NoError(t, err)
		})
	}
}

func testRemove(gs GroupService, t *testing.T) {
	ctx := context.Background()
	tables := []struct {
		name     string
		frontend bool
		UID      string
		err      error
	}{
		{"frontend_uid", true, "someuid2", nil},
		{"backend_uid", false, "ola2", nil},
	}

	err := gs.GroupCreate(ctx, "testRemove")
	assert.NoError(t, err)

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			err = gs.GroupAddMember(ctx, "testRemove", table.UID)
			assert.NoError(t, err)
			err = gs.GroupRemoveMember(ctx, "testRemove", table.UID)
			assert.NoError(t, err)
			res, err := gs.GroupContainsMember(ctx, "testRemove", table.UID)
			assert.NoError(t, err)
			assert.False(t, res)
		})
	}
}

func testDelete(gs GroupService, t *testing.T) {
	ctx := context.Background()
	tables := []struct {
		name     string
		frontend bool
		UID      string
		err      error
	}{
		{"frontend_uid", true, "leaveSomeuid2", nil},
		{"backend_uid", false, "leaveOla2", nil},
	}

	err := gs.GroupCreate(ctx, "testDeleteSufix")
	assert.NoError(t, err)

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			err = gs.GroupCreate(ctx, "testDelete")
			assert.NoError(t, err)
			err = gs.GroupAddMember(ctx, "testDeleteSufix", table.UID)
			assert.NoError(t, err)
			err = gs.GroupAddMember(ctx, "testDelete", table.UID)
			assert.NoError(t, err)
			err = gs.GroupDelete(ctx, "testDelete")
			assert.NoError(t, err)

			res, err := gs.GroupContainsMember(ctx, "testDeleteSufix", table.UID)
			assert.NoError(t, err)
			assert.True(t, res)
			_, err = gs.GroupContainsMember(ctx, "testDelete", table.UID)
			assert.Error(t, err)
			assert.Equal(t, constants.ErrGroupNotFound, err)
		})
	}
}

func testRemoveAll(gs GroupService, t *testing.T) {
	ctx := context.Background()
	tables := []struct {
		name     string
		frontend bool
		UID      string
		err      error
	}{
		{"frontend_uid", true, "removeSomeuid2", nil},
		{"backend_uid", false, "removeOla2", nil},
	}

	err := gs.GroupCreate(ctx, "testRemoveAllSufix")
	assert.NoError(t, err)
	err = gs.GroupCreate(ctx, "testRemoveAll")
	assert.NoError(t, err)

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			err = gs.GroupAddMember(ctx, "testRemoveAllSufix", table.UID)
			assert.NoError(t, err)
			err = gs.GroupAddMember(ctx, "testRemoveAll", table.UID)
			assert.NoError(t, err)
			err = gs.GroupRemoveAll(ctx, "testRemoveAll")
			assert.NoError(t, err)

			res, err := gs.GroupContainsMember(ctx, "testRemoveAllSufix", table.UID)
			assert.NoError(t, err)
			assert.True(t, res)
			res, err = gs.GroupContainsMember(ctx, "testRemoveAll", table.UID)
			assert.NoError(t, err)
			assert.False(t, res)
		})
	}
}

func testCount(gs GroupService, t *testing.T) {
	ctx := context.Background()
	tables := []struct {
		name     string
		frontend bool
		UID      string
		err      error
	}{
		{"frontend_uid", true, "someuid2", nil},
		{"backend_uid", false, "ola2", nil},
	}

	err := gs.GroupCreate(ctx, "testCount")
	assert.NoError(t, err)

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			err = gs.GroupAddMember(ctx, "testCount", table.UID)
			assert.NoError(t, err)
			res, err := gs.GroupCountMembers(ctx, "testCount")
			assert.NoError(t, err)
			assert.Equal(t, 1, res)

			err = gs.GroupRemoveAll(ctx, "testCount")
			assert.NoError(t, err)
		})
	}
}

func testMembers(gs GroupService, t *testing.T) {
	ctx := context.Background()
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	err := gs.GroupCreate(ctx, "testGroupMembers")
	assert.NoError(t, err)
	uid1 := "someid1"
	uid2 := "someid2"
	err = gs.GroupAddMember(ctx, "testGroupMembers", uid1)
	assert.NoError(t, err)
	err = gs.GroupAddMember(ctx, "testGroupMembers", uid2)
	assert.NoError(t, err)

	res, err := gs.GroupMembers(ctx, "testGroupMembers")
	assert.NoError(t, err)
	assert.ElementsMatch(t, []string{"someid1", "someid2"}, res)
}

```

`pkg/groups/memory_group_service.go`:

```go
package groups

import (
	"context"
	"sync"
	"time"

	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
)

var (
	memoryGroupsMu sync.RWMutex
	memoryGroups   map[string]*MemoryGroup
	memoryOnce     sync.Once
	globalCtx      context.Context
	globalCancel   context.CancelFunc
	cleanupWG      sync.WaitGroup
	cleanupOnce    sync.Once
)

// MemoryGroupService base in server memory solution
type MemoryGroupService struct {
	cancelFunc context.CancelFunc
}

// MemoryGroup is the struct stored in each group key(which is the name of the group)
type MemoryGroup struct {
	Uids        []string
	LastRefresh int64
	TTL         int64
}

// NewMemoryGroupService returns a new group instance
func NewMemoryGroupService(config config.MemoryGroupConfig) *MemoryGroupService {
	service := &MemoryGroupService{}
	memoryOnce.Do(func() {
		memoryGroups = make(map[string]*MemoryGroup)
		globalCtx, globalCancel = context.WithCancel(context.Background())
		cleanupWG.Add(1)
		go groupTTLCleanup(globalCtx, config.TickDuration)
	})
	// All services share the same cancel function
	service.cancelFunc = globalCancel
	return service
}

func groupTTLCleanup(ctx context.Context, interval time.Duration) {
	defer cleanupWG.Done()
	ticker := time.NewTicker(interval)
	defer ticker.Stop()

	for {
		select {
		case now := <-ticker.C:
			// Check if context is cancelled before processing
			if ctx.Err() != nil {
				memoryGroupsMu.Lock()
				for groupName := range memoryGroups {
					delete(memoryGroups, groupName)
				}
				memoryGroupsMu.Unlock()
				return
			}
			memoryGroupsMu.Lock()
			for groupName, mg := range memoryGroups {
				if mg.TTL != 0 && now.UnixNano()-mg.LastRefresh > mg.TTL {
					delete(memoryGroups, groupName)
				}
			}
			memoryGroupsMu.Unlock()
		case <-ctx.Done():
			memoryGroupsMu.Lock()
			for groupName := range memoryGroups {
				delete(memoryGroups, groupName)
			}
			memoryGroupsMu.Unlock()
			return
		}
	}
}

// GroupCreate creates a group without TTL
func (c *MemoryGroupService) GroupCreate(ctx context.Context, groupName string) error {
	memoryGroupsMu.Lock()
	defer memoryGroupsMu.Unlock()

	if _, ok := memoryGroups[groupName]; ok {
		return constants.ErrGroupAlreadyExists
	}

	memoryGroups[groupName] = &MemoryGroup{}
	return nil
}

// GroupCreateWithTTL creates a group with TTL, which the go routine will clean later
func (c *MemoryGroupService) GroupCreateWithTTL(ctx context.Context, groupName string, ttlTime time.Duration) error {
	memoryGroupsMu.Lock()
	defer memoryGroupsMu.Unlock()

	if _, ok := memoryGroups[groupName]; ok {
		return constants.ErrGroupAlreadyExists
	}

	memoryGroups[groupName] = &MemoryGroup{LastRefresh: time.Now().UnixNano(), TTL: ttlTime.Nanoseconds()}
	return nil
}

// GroupMembers returns all member's UID in given group
func (c *MemoryGroupService) GroupMembers(ctx context.Context, groupName string) ([]string, error) {
	memoryGroupsMu.Lock()
	defer memoryGroupsMu.Unlock()

	mg, ok := memoryGroups[groupName]
	if !ok {
		return nil, constants.ErrGroupNotFound
	}

	uids := make([]string, len(mg.Uids))
	copy(uids, mg.Uids)

	return uids, nil
}

// GroupContainsMember check whether an UID is contained in given group or not
func (c *MemoryGroupService) GroupContainsMember(ctx context.Context, groupName, uid string) (bool, error) {
	memoryGroupsMu.Lock()
	defer memoryGroupsMu.Unlock()

	mg, ok := memoryGroups[groupName]
	if !ok {
		return false, constants.ErrGroupNotFound
	}

	_, contains := elementIndex(mg.Uids, uid)
	return contains, nil
}

// GroupAddMember adds UID to group
func (c *MemoryGroupService) GroupAddMember(ctx context.Context, groupName, uid string) error {
	memoryGroupsMu.Lock()
	defer memoryGroupsMu.Unlock()

	mg, ok := memoryGroups[groupName]
	if !ok {
		return constants.ErrGroupNotFound
	}

	_, contains := elementIndex(mg.Uids, uid)
	if contains {
		return constants.ErrMemberAlreadyExists
	}

	mg.Uids = append(mg.Uids, uid)
	memoryGroups[groupName] = mg
	return nil
}

// GroupRemoveMember removes specific UID from group
func (c *MemoryGroupService) GroupRemoveMember(ctx context.Context, groupName, uid string) error {
	memoryGroupsMu.Lock()
	defer memoryGroupsMu.Unlock()

	mg, ok := memoryGroups[groupName]
	if !ok {
		return constants.ErrGroupNotFound
	}
	index, contains := elementIndex(mg.Uids, uid)
	if contains {
		mg.Uids[index] = mg.Uids[len(mg.Uids)-1]
		mg.Uids = mg.Uids[:len(mg.Uids)-1]
		memoryGroups[groupName] = mg
		return nil
	}

	return constants.ErrMemberNotFound
}

// GroupRemoveAll clears all UIDs from group
func (c *MemoryGroupService) GroupRemoveAll(ctx context.Context, groupName string) error {
	memoryGroupsMu.Lock()
	defer memoryGroupsMu.Unlock()

	mg, ok := memoryGroups[groupName]
	if !ok {
		return constants.ErrGroupNotFound
	}

	mg.Uids = []string{}
	return nil
}

// GroupDelete deletes the whole group, including members and base group
func (c *MemoryGroupService) GroupDelete(ctx context.Context, groupName string) error {
	memoryGroupsMu.Lock()
	defer memoryGroupsMu.Unlock()

	_, ok := memoryGroups[groupName]
	if !ok {
		return constants.ErrGroupNotFound
	}

	delete(memoryGroups, groupName)
	return nil
}

// GroupCountMembers get current member amount in group
func (c *MemoryGroupService) GroupCountMembers(ctx context.Context, groupName string) (int, error) {
	memoryGroupsMu.Lock()
	defer memoryGroupsMu.Unlock()

	mg, ok := memoryGroups[groupName]
	if !ok {
		return 0, constants.ErrGroupNotFound
	}

	return len(mg.Uids), nil
}

// GroupRenewTTL will renew lease TTL
func (c *MemoryGroupService) GroupRenewTTL(ctx context.Context, groupName string) error {
	memoryGroupsMu.Lock()
	defer memoryGroupsMu.Unlock()

	mg, ok := memoryGroups[groupName]
	if !ok {
		return constants.ErrGroupNotFound
	}

	if mg.TTL != 0 {
		mg.LastRefresh = time.Now().UnixNano()
		return nil
	}
	return constants.ErrMemoryTTLNotFound
}

func (c *MemoryGroupService) Close() {
	// Only cancel once, even if Close() is called multiple times
	cleanupOnce.Do(func() {
		if globalCancel != nil {
			globalCancel()
			// Wait for the goroutine to exit
			// Use a channel with timeout to prevent indefinite blocking
			done := make(chan struct{})
			go func() {
				cleanupWG.Wait()
				close(done)
			}()
			select {
			case <-done:
				// Goroutine exited successfully
			case <-time.After(1 * time.Second):
				// Timeout - this should not happen in normal operation,
				// but we continue to prevent tests from hanging
			}
		}
	})
}

```

`pkg/groups/memory_group_service_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package groups

import (
	"os"
	"testing"
	"time"

	"github.com/topfreegames/pitaya/v3/pkg/config"
)

var memoryGroupService *MemoryGroupService

func TestMain(m *testing.M) {
	mconfig := *&config.NewDefaultPitayaConfig().Groups.Memory
	mconfig.TickDuration = 10 * time.Millisecond
	memoryGroupService = NewMemoryGroupService(mconfig)
	exit := m.Run()
	memoryGroupService.Close()
	os.Exit(exit)
}

func TestMemoryCreateDuplicatedGroup(t *testing.T) {
	testCreateDuplicatedGroup(memoryGroupService, t)
}

func TestMemoryCreateGroup(t *testing.T) {
	testCreateGroup(memoryGroupService, t)
}

func TestMemoryCreateGroupWithTTL(t *testing.T) {
	testCreateGroupWithTTL(memoryGroupService, t)
}

func TestMemoryGroupAddMember(t *testing.T) {
	testGroupAddMember(memoryGroupService, t)
}

func TestMemoryGroupAddDuplicatedMember(t *testing.T) {
	testGroupAddDuplicatedMember(memoryGroupService, t)
}

func TestMemoryGroupContainsMember(t *testing.T) {
	testGroupContainsMember(memoryGroupService, t)
}

func TestMemoryRemove(t *testing.T) {
	testRemove(memoryGroupService, t)
}

func TestMemoryDelete(t *testing.T) {
	testDelete(memoryGroupService, t)
}

func TestMemoryRemoveAll(t *testing.T) {
	testRemoveAll(memoryGroupService, t)
}

func TestMemoryCount(t *testing.T) {
	testCount(memoryGroupService, t)
}

func TestMemoryMembers(t *testing.T) {
	testMembers(memoryGroupService, t)
}

```

`pkg/helpers/helpers.go`:

```go
package helpers

import (
	"bufio"
	"errors"
	"fmt"
	"net"
	"os"
	"os/exec"
	"path/filepath"
	"reflect"
	"strconv"
	"strings"
	"testing"
	"time"

	"github.com/nats-io/nats-server/v2/server"
	gnatsd "github.com/nats-io/nats-server/v2/test"
	clientv3 "go.etcd.io/etcd/client/v3"
	"go.etcd.io/etcd/tests/v3/integration"
)

// GetFreePort returns a free port
func GetFreePort(t testing.TB) int {
	t.Helper()
	addr, err := net.ResolveTCPAddr("tcp", "localhost:0")
	if err != nil {
		t.Fatal(err)
	}

	l, err := net.ListenTCP("tcp", addr)
	if err != nil {
		t.Fatal(err)
	}
	defer l.Close()
	return l.Addr().(*net.TCPAddr).Port
}

// GetMapKeys returns a string slice with the map keys
func GetMapKeys(t *testing.T, m interface{}) []string {
	if reflect.ValueOf(m).Kind() != reflect.Map {
		t.Fatal(errors.New("GetMapKeys should receive a map"))
	}
	if reflect.TypeOf(m).Key() != reflect.TypeOf("bla") {
		t.Fatal(errors.New("GetMapKeys should receive a map with string keys"))
	}
	t.Helper()
	res := make([]string, 0)
	for _, k := range reflect.ValueOf(m).MapKeys() {
		res = append(res, k.String())
	}
	return res
}

// GetTestNatsServer gets a test nats server
func GetTestNatsServer(t *testing.T) *server.Server {
	opts := gnatsd.DefaultTestOptions
	port := GetFreePort(t)
	opts.Port = port
	s := gnatsd.RunServer(&opts)
	return s
}

// GetTestEtcd gets a test in memory etcd server
func GetTestEtcd(t *testing.T) (*integration.ClusterV3, *clientv3.Client) {
	t.Helper()
	integration.BeforeTest(t)
	c := integration.NewClusterV3(t, &integration.ClusterConfig{Size: 1})
	cli := c.RandClient()
	return c, cli
}

// WriteFile test helper
func WriteFile(t *testing.T, filepath string, bytes []byte) {
	t.Helper()
	if err := os.WriteFile(filepath, bytes, 0644); err != nil {
		t.Fatalf("failed writing file: %s", err)
	}
}

// ReadFile test helper
func ReadFile(t *testing.T, filepath string) []byte {
	t.Helper()
	b, err := os.ReadFile(filepath)
	if err != nil {
		t.Fatalf("failed reading file: %s", err)
	}
	return b
}

// StartProcess starts a process
func StartProcess(t testing.TB, program string, args ...string) *exec.Cmd {
	t.Helper()
	return exec.Command(program, args...)
}

func waitForServerToBeReady(t testing.TB, out *bufio.Reader) {
	t.Helper()
	ShouldEventuallyReturn(t, func() bool {
		line, _, err := out.ReadLine()
		if err != nil {
			t.Fatal(err)
		}
		return strings.Contains(string(line), "all modules started!")
	}, true, 100*time.Millisecond, 30*time.Second)
}

// StartServer starts a server
func StartServer(
	t testing.TB,
	frontend, debug bool,
	svType string,
	port int,
	sdPrefix string,
	grpc, lazyConnection bool,
) func() {
	grpcPort := GetFreePort(t)
	promPort := GetFreePort(t)
	var useGRPC string
	if grpc {
		useGRPC = "true"
	} else {
		useGRPC = "false"
	}
	t.Helper()
	args := []string{
		"-type",
		svType,
		"-port",
		strconv.Itoa(port),
		fmt.Sprintf("-frontend=%s", strconv.FormatBool(frontend)),
		"-sdprefix", sdPrefix,
		"-grpcport", fmt.Sprintf("%d", grpcPort),
		fmt.Sprintf("-grpc=%s", useGRPC),
	}
	if debug {
		args = append(args, "-debug")
	}
	cmd := StartProcess(
		t,
		"../examples/testing/server",
		args...,
	)

	// always use a random port for prometheus, to avoid e2e conflicts
	cmd.Env = []string{
		fmt.Sprintf("PITAYA_METRICS_PROMETHEUS_PORT=%d", promPort),
		fmt.Sprintf("PITAYA_CLUSTER_RPC_CLIENT_GRPC_LAZYCONNECTION=%v", lazyConnection),
	}

	outPipe, err := cmd.StderrPipe()
	if err != nil {
		t.Fatal(err)
	}

	err = cmd.Start()
	if err != nil {
		t.Fatal(err)
	}

	waitForServerToBeReady(t, bufio.NewReader(outPipe))
	return func() {
		err := cmd.Process.Kill()
		if err != nil {
			t.Fatal(err)
		}
	}
}

// FixtureGoldenFileName returns the golden file name on fixtures path
func FixtureGoldenFileName(t *testing.T, name string) string {
	t.Helper()
	return filepath.Join("fixtures", name+".golden")
}

func vetExtras(extras []interface{}) (bool, string) {
	for i, extra := range extras {
		if extra != nil {
			zeroValue := reflect.Zero(reflect.TypeOf(extra)).Interface()
			if !reflect.DeepEqual(zeroValue, extra) {
				message := fmt.Sprintf("unexpected non-nil/non-zero extra argument at index %d:\n\t<%T>: %#v", i+1, extra, extra)
				return false, message
			}
		}
	}
	return true, ""
}

func pollFuncReturn(f interface{}) (interface{}, error) {
	values := reflect.ValueOf(f).Call([]reflect.Value{})

	extras := []interface{}{}
	for _, value := range values[1:] {
		extras = append(extras, value.Interface())
	}

	success, message := vetExtras(extras)

	if !success {
		return nil, errors.New(message)
	}

	return values[0].Interface(), nil
}

// ShouldEventuallyReceive should asserts that eventually channel c receives a value
func ShouldEventuallyReceive(t testing.TB, c interface{}, timeouts ...time.Duration) interface{} {
	t.Helper()
	if !isChan(c) {
		t.Fatal("ShouldEventuallyReceive c argument should be a channel")
	}
	v := reflect.ValueOf(c)

	timeout := time.After(500 * time.Millisecond)

	if len(timeouts) > 0 {
		timeout = time.After(timeouts[0])
	}

	recvChan := make(chan reflect.Value)

	go func() {
		v, ok := v.Recv()
		if ok {
			recvChan <- v
		}
	}()

	select {
	case <-timeout:
		t.Fatal(errors.New("timed out waiting for channel to receive"))
	case a := <-recvChan:
		return a.Interface()
	}

	return nil
}

// ShouldAlwaysReturn asserts that the return of f should always be v, timeouts: 0 - evaluation interval, 1 - timeout
func ShouldAlwaysReturn(t testing.TB, f interface{}, v interface{}, timeouts ...time.Duration) {
	t.Helper()
	interval := 10 * time.Millisecond
	timeout := time.After(50 * time.Millisecond)
	switch len(timeouts) {
	case 1:
		interval = timeouts[0]
		break
	case 2:
		interval = timeouts[0]
		timeout = time.After(timeouts[1])
	}
	ticker := time.NewTicker(interval)
	defer ticker.Stop()

	if isFunction(f) {
		for {
			select {
			case <-timeout:
				return
			case <-ticker.C:
				val, err := pollFuncReturn(f)
				if err != nil {
					t.Fatal(err)
				}
				if v != val {
					t.Fatalf("function f returned wrong value %s", val)
				}
			}
		}
	} else {
		t.Fatal("ShouldAlwaysReturn should receive a function with no args and more than 0 outs")
		return
	}
}

// ShouldEventuallyReturn asserts that eventually the return of f should be v, timeouts: 0 - evaluation interval, 1 - timeout
func ShouldEventuallyReturn(t testing.TB, f interface{}, v interface{}, timeouts ...time.Duration) {
	t.Helper()
	interval := 10 * time.Millisecond
	timeout := time.After(500 * time.Millisecond)
	switch len(timeouts) {
	case 1:
		interval = timeouts[0]
		break
	case 2:
		interval = timeouts[0]
		timeout = time.After(timeouts[1])
	}
	ticker := time.NewTicker(interval)
	defer ticker.Stop()

	if isFunction(f) {
		for {
			select {
			case <-timeout:
				t.Fatalf("function f never returned value %s", v)
			case <-ticker.C:
				val, err := pollFuncReturn(f)
				if err != nil {
					t.Fatal(err)
				}
				if v == val {
					return
				}
			}
		}
	} else {
		t.Fatal("ShouldEventuallyEqual should receive a function with no args and more than 0 outs")
		return
	}
}

```

`pkg/helpers/type_support.go`:

```go
package helpers

import "reflect"

func isFunction(f interface{}) bool {
	actual := reflect.TypeOf(f)
	return actual.Kind() == reflect.Func && actual.NumIn() == 0 && actual.NumOut() > 0
}

func isChan(a interface{}) bool {
	if isNil(a) {
		return false
	}
	return reflect.TypeOf(a).Kind() == reflect.Chan
}

func isNil(a interface{}) bool {
	if a == nil {
		return true
	}

	switch reflect.TypeOf(a).Kind() {
	case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:
		return reflect.ValueOf(a).IsNil()
	}

	return false
}

```

`pkg/interfaces/interfaces.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package interfaces

// Module is the interface that represent a module.
type Module interface {
	Init() error
	AfterInit()
	BeforeShutdown()
	Shutdown() error
}

type SessionModule interface {
	Module
	StartSessionDraining()
	SessionCount() int64
}

// BindingStorage interface
type BindingStorage interface {
	GetUserFrontendID(uid, frontendType string) (string, error)
	PutBinding(uid string) error
}

```

`pkg/interfaces/mocks/interfaces.go`:

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: ./interfaces.go

// Package mocks is a generated GoMock package.
package mocks

import (
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockModule is a mock of Module interface
type MockModule struct {
	ctrl     *gomock.Controller
	recorder *MockModuleMockRecorder
}

// MockModuleMockRecorder is the mock recorder for MockModule
type MockModuleMockRecorder struct {
	mock *MockModule
}

// NewMockModule creates a new mock instance
func NewMockModule(ctrl *gomock.Controller) *MockModule {
	mock := &MockModule{ctrl: ctrl}
	mock.recorder = &MockModuleMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockModule) EXPECT() *MockModuleMockRecorder {
	return m.recorder
}

// Init mocks base method
func (m *MockModule) Init() error {
	ret := m.ctrl.Call(m, "Init")
	ret0, _ := ret[0].(error)
	return ret0
}

// Init indicates an expected call of Init
func (mr *MockModuleMockRecorder) Init() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*MockModule)(nil).Init))
}

// AfterInit mocks base method
func (m *MockModule) AfterInit() {
	m.ctrl.Call(m, "AfterInit")
}

// AfterInit indicates an expected call of AfterInit
func (mr *MockModuleMockRecorder) AfterInit() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AfterInit", reflect.TypeOf((*MockModule)(nil).AfterInit))
}

// BeforeShutdown mocks base method
func (m *MockModule) BeforeShutdown() {
	m.ctrl.Call(m, "BeforeShutdown")
}

// BeforeShutdown indicates an expected call of BeforeShutdown
func (mr *MockModuleMockRecorder) BeforeShutdown() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeforeShutdown", reflect.TypeOf((*MockModule)(nil).BeforeShutdown))
}

// Shutdown mocks base method
func (m *MockModule) Shutdown() error {
	ret := m.ctrl.Call(m, "Shutdown")
	ret0, _ := ret[0].(error)
	return ret0
}

// Shutdown indicates an expected call of Shutdown
func (mr *MockModuleMockRecorder) Shutdown() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Shutdown", reflect.TypeOf((*MockModule)(nil).Shutdown))
}

// MockBindingStorage is a mock of BindingStorage interface
type MockBindingStorage struct {
	ctrl     *gomock.Controller
	recorder *MockBindingStorageMockRecorder
}

// MockBindingStorageMockRecorder is the mock recorder for MockBindingStorage
type MockBindingStorageMockRecorder struct {
	mock *MockBindingStorage
}

// NewMockBindingStorage creates a new mock instance
func NewMockBindingStorage(ctrl *gomock.Controller) *MockBindingStorage {
	mock := &MockBindingStorage{ctrl: ctrl}
	mock.recorder = &MockBindingStorageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockBindingStorage) EXPECT() *MockBindingStorageMockRecorder {
	return m.recorder
}

// GetUserFrontendID mocks base method
func (m *MockBindingStorage) GetUserFrontendID(uid, frontendType string) (string, error) {
	ret := m.ctrl.Call(m, "GetUserFrontendID", uid, frontendType)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUserFrontendID indicates an expected call of GetUserFrontendID
func (mr *MockBindingStorageMockRecorder) GetUserFrontendID(uid, frontendType interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserFrontendID", reflect.TypeOf((*MockBindingStorage)(nil).GetUserFrontendID), uid, frontendType)
}

// PutBinding mocks base method
func (m *MockBindingStorage) PutBinding(uid string) error {
	ret := m.ctrl.Call(m, "PutBinding", uid)
	ret0, _ := ret[0].(error)
	return ret0
}

// PutBinding indicates an expected call of PutBinding
func (mr *MockBindingStorageMockRecorder) PutBinding(uid interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PutBinding", reflect.TypeOf((*MockBindingStorage)(nil).PutBinding), uid)
}

```

`pkg/kick.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package pitaya

import (
	"context"

	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
)

// SendKickToUsers sends kick to an user array
func (app *App) SendKickToUsers(uids []string, frontendType string) ([]string, error) {
	if !app.server.Frontend && frontendType == "" {
		return uids, constants.ErrFrontendTypeNotSpecified
	}

	var notKickedUids []string

	for _, uid := range uids {
		if s := app.sessionPool.GetSessionByUID(uid); s != nil {
			if err := s.Kick(context.Background()); err != nil {
				notKickedUids = append(notKickedUids, uid)
				logger.Log.Errorf("Session kick error, ID=%d, UID=%s, ERROR=%s", s.ID(), s.UID(), err.Error())
			}
		} else if app.rpcClient != nil {
			kick := &protos.KickMsg{UserId: uid}
			if err := app.rpcClient.SendKick(uid, frontendType, kick); err != nil {
				notKickedUids = append(notKickedUids, uid)
				logger.Log.Errorf("RPCClient send kick error, UID=%s, SvType=%s, Error=%s", uid, frontendType, err.Error())
			}
		} else {
			notKickedUids = append(notKickedUids, uid)
		}

	}

	if len(notKickedUids) != 0 {
		return notKickedUids, constants.ErrKickingUsers
	}

	return nil, nil
}

```

`pkg/kick_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package pitaya

import (
	"context"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	clustermocks "github.com/topfreegames/pitaya/v3/pkg/cluster/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	sessionmocks "github.com/topfreegames/pitaya/v3/pkg/session/mocks"
)

func TestSendKickToUsersLocalSession(t *testing.T) {
	table := struct {
		uid1         string
		uid2         string
		frontendType string
		err          error
	}{
		uuid.New().String(), uuid.New().String(), "connector", nil,
	}

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	s1 := sessionmocks.NewMockSession(ctrl)
	s2 := sessionmocks.NewMockSession(ctrl)
	s1.EXPECT().Kick(context.Background()).Times(1).Return(table.err)
	s2.EXPECT().Kick(context.Background()).Times(1).Return(table.err)

	mockSessionPool := sessionmocks.NewMockSessionPool(ctrl)
	mockSessionPool.EXPECT().GetSessionByUID(table.uid1).Return(s1).Times(1)
	mockSessionPool.EXPECT().GetSessionByUID(table.uid2).Return(s2).Times(1)

	config := config.NewDefaultPitayaConfig()
	builder := NewDefaultBuilder(true, "testtype", Cluster, map[string]string{}, *config)
	builder.SessionPool = mockSessionPool
	app := builder.Build()

	failedUids, err := app.SendKickToUsers([]string{table.uid1, table.uid2}, table.frontendType)
	assert.Nil(t, failedUids)
	assert.NoError(t, err)
}

func TestSendKickToUsersFail(t *testing.T) {
	table := struct {
		uid1         string
		uid2         string
		frontendType string
		err          error
	}{
		uuid.New().String(), uuid.New().String(), "connector", constants.ErrKickingUsers,
	}

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	s1 := sessionmocks.NewMockSession(ctrl)
	s1.EXPECT().Kick(context.Background()).Times(1).Return(nil)

	mockSessionPool := sessionmocks.NewMockSessionPool(ctrl)
	mockSessionPool.EXPECT().GetSessionByUID(table.uid1).Return(s1).Times(1)
	mockSessionPool.EXPECT().GetSessionByUID(table.uid2).Return(nil).Times(1)

	mockRPCClient := clustermocks.NewMockRPCClient(ctrl)
	mockRPCClient.EXPECT().SendKick(table.uid2, table.frontendType, &protos.KickMsg{UserId: table.uid2}).Return(table.err).Times(1)

	config := config.NewDefaultPitayaConfig()
	builder := NewDefaultBuilder(true, "testtype", Cluster, map[string]string{}, *config)
	builder.SessionPool = mockSessionPool
	builder.RPCClient = mockRPCClient
	app := builder.Build()

	failedUids, err := app.SendKickToUsers([]string{table.uid1, table.uid2}, table.frontendType)
	assert.Len(t, failedUids, 1)
	assert.Equal(t, failedUids[0], table.uid2)
	assert.Equal(t, err, table.err)
}

func TestSendKickToUsersRemoteSession(t *testing.T) {
	tables := []struct {
		name         string
		uids         []string
		frontendType string
		err          error
	}{
		{"success", []string{uuid.New().String(), uuid.New().String()}, "connector", nil},
		{"fail", []string{uuid.New().String(), uuid.New().String()}, "connector", constants.ErrKickingUsers},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			mockRPCClient := clustermocks.NewMockRPCClient(ctrl)

			config := config.NewDefaultPitayaConfig()
			app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *config).(*App)
			app.rpcClient = mockRPCClient

			for _, uid := range table.uids {
				expectedKick := &protos.KickMsg{UserId: uid}
				mockRPCClient.EXPECT().SendKick(uid, gomock.Any(), expectedKick).Return(table.err)
			}

			failedUids, err := app.SendKickToUsers(table.uids, table.frontendType)
			assert.Equal(t, err, table.err)
			if table.err != nil {
				assert.NotNil(t, failedUids)
				assert.Equal(t, failedUids, table.uids)
			} else {
				assert.Nil(t, failedUids)
			}
		})
	}
}

```

`pkg/logger/interfaces/interfaces.go`:

```go
package interfaces

// Logger interface for pitaya loggers
type Logger interface {
	Fatal(format ...interface{})
	Fatalf(format string, args ...interface{})
	Fatalln(args ...interface{})

	Debug(args ...interface{})
	Debugf(format string, args ...interface{})
	Debugln(args ...interface{})

	Error(args ...interface{})
	Errorf(format string, args ...interface{})
	Errorln(args ...interface{})

	Info(args ...interface{})
	Infof(format string, args ...interface{})
	Infoln(args ...interface{})

	Warn(args ...interface{})
	Warnf(format string, args ...interface{})
	Warnln(args ...interface{})

	Panic(args ...interface{})
	Panicf(format string, args ...interface{})
	Panicln(args ...interface{})

	WithFields(fields map[string]interface{}) Logger
	WithField(key string, value interface{}) Logger
	WithError(err error) Logger

	GetInternalLogger() any
}

```

`pkg/logger/logger.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package logger

import (
	"github.com/sirupsen/logrus"
	"github.com/topfreegames/pitaya/v3/pkg/logger/interfaces"
	logruswrapper "github.com/topfreegames/pitaya/v3/pkg/logger/logrus"
)

// Log is the default logger
var Log = initLogger()

func initLogger() interfaces.Logger {
	plog := logrus.New()
	plog.Formatter = new(logrus.TextFormatter)
	plog.Level = logrus.DebugLevel

	log := plog.WithFields(logrus.Fields{
		"source": "pitaya",
	})
	return logruswrapper.NewWithFieldLogger(log)
}

// SetLogger rewrites the default logger
func SetLogger(l interfaces.Logger) {
	if l != nil {
		Log = l
	}
}

```

`pkg/logger/logger_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package logger

import (
	"testing"

	"github.com/stretchr/testify/assert"
	logruswrapper "github.com/topfreegames/pitaya/v3/pkg/logger/logrus"
)

func TestInitLogger(t *testing.T) {
	initLogger()
	assert.NotNil(t, Log)
}

func TestSetLogger(t *testing.T) {
	l := logruswrapper.New()
	SetLogger(l)
	assert.Equal(t, l, Log)
}

```

`pkg/logger/logrus/logrus.go`:

```go
package logrus

import (
	"github.com/sirupsen/logrus"
	"github.com/topfreegames/pitaya/v3/pkg/logger/interfaces"
)

type logrusImpl struct {
	logrus.FieldLogger
}

// New returns a new interfaces.Logger implementation based on logrus
func New() interfaces.Logger {
	log := logrus.New()
	return NewWithLogger(log)
}

// NewWithEntry returns a new interfaces.Logger implementation based on a provided logrus entry instance
// Deprecated: NewWithEntry is deprecated.
func NewWithEntry(logger *logrus.Entry) interfaces.Logger {
	return &logrusImpl{FieldLogger: logger}
}

// NewWithLogger returns a new interfaces.Logger implementation based on a provided logrus instance
// Deprecated: NewWithLogger is deprecated.
func NewWithLogger(logger *logrus.Logger) interfaces.Logger {
	return &logrusImpl{FieldLogger: logrus.NewEntry(logger)}
}

// NewWithFieldLogger returns a new interfaces.Logger implementation based on a provided logrus instance
func NewWithFieldLogger(logger logrus.FieldLogger) interfaces.Logger {
	return &logrusImpl{FieldLogger: logger}
}

func (l *logrusImpl) WithFields(fields map[string]interface{}) interfaces.Logger {
	return &logrusImpl{FieldLogger: l.FieldLogger.WithFields(fields)}
}

func (l *logrusImpl) WithField(key string, value interface{}) interfaces.Logger {
	return &logrusImpl{FieldLogger: l.FieldLogger.WithField(key, value)}
}

func (l *logrusImpl) WithError(err error) interfaces.Logger {
	return &logrusImpl{FieldLogger: l.FieldLogger.WithError(err)}
}

func (l *logrusImpl) GetInternalLogger() any {
	return l.FieldLogger
}

```

`pkg/logger/test/test.go`:

```go
package test

import (
	tests "github.com/sirupsen/logrus/hooks/test"
	"github.com/topfreegames/pitaya/v3/pkg/logger/interfaces"
	lwrapper "github.com/topfreegames/pitaya/v3/pkg/logger/logrus"
	"io"
)

// NewNullLogger creates a discarding logger and installs the test hook.
func NewNullLogger() (interfaces.Logger, *tests.Hook) {
	logger, hook := tests.NewNullLogger()
	logger.Out = io.Discard
	return lwrapper.NewWithFieldLogger(logger), hook
}

```

`pkg/metrics/constants.go`:

```go
package metrics

var (
	// ResponseTime reports the response time of handlers and rpc
	ResponseTime = "response_time_ns"
	// ConnectedClients represents the number of current connected clients in frontend servers
	ConnectedClients = "connected_clients"
	// CountServers counts the number of servers of different types
	CountServers = "count_servers"
	// ChannelCapacity represents the capacity of a channel as a histogram (distribution of available slots)
	ChannelCapacity = "channel_capacity"
	// DroppedMessages reports the number of dropped messages in rpc server (messages that will not be handled)
	DroppedMessages = "dropped_messages"
	// ProcessDelay reports the message processing delay to handle the messages at the handler service
	ProcessDelay = "handler_delay_ns"
	// Goroutines reports the number of goroutines
	Goroutines = "goroutines"
	// HeapSize reports the size of heap
	HeapSize = "heapsize"
	// HeapObjects reports the number of allocated heap objects
	HeapObjects = "heapobjects"
	// WorkerJobsTotal reports the number of executed jobs
	WorkerJobsTotal = "worker_jobs_total"
	// WorkerJobsRetry reports the number of retried jobs
	WorkerJobsRetry = "worker_jobs_retry_total"
	// WorkerQueueSize reports the queue size on worker
	WorkerQueueSize = "worker_queue_size"
	// ExceededRateLimiting reports the number of requests made in a connection
	// after the rate limit was exceeded
	ExceededRateLimiting = "exceeded_rate_limiting"
)

```

`pkg/metrics/mocks/reporter.go`:

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/topfreegames/pitaya/v3/pkg/metrics (interfaces: Reporter)

// Package mocks is a generated GoMock package.
package mocks

import (
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
)

// MockReporter is a mock of Reporter interface.
type MockReporter struct {
	ctrl     *gomock.Controller
	recorder *MockReporterMockRecorder
}

// MockReporterMockRecorder is the mock recorder for MockReporter.
type MockReporterMockRecorder struct {
	mock *MockReporter
}

// NewMockReporter creates a new mock instance.
func NewMockReporter(ctrl *gomock.Controller) *MockReporter {
	mock := &MockReporter{ctrl: ctrl}
	mock.recorder = &MockReporterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockReporter) EXPECT() *MockReporterMockRecorder {
	return m.recorder
}

// ReportCount mocks base method.
func (m *MockReporter) ReportCount(arg0 string, arg1 map[string]string, arg2 float64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReportCount", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReportCount indicates an expected call of ReportCount.
func (mr *MockReporterMockRecorder) ReportCount(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReportCount", reflect.TypeOf((*MockReporter)(nil).ReportCount), arg0, arg1, arg2)
}

// ReportGauge mocks base method.
func (m *MockReporter) ReportGauge(arg0 string, arg1 map[string]string, arg2 float64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReportGauge", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReportGauge indicates an expected call of ReportGauge.
func (mr *MockReporterMockRecorder) ReportGauge(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReportGauge", reflect.TypeOf((*MockReporter)(nil).ReportGauge), arg0, arg1, arg2)
}

// ReportHistogram mocks base method.
func (m *MockReporter) ReportHistogram(arg0 string, arg1 map[string]string, arg2 float64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReportHistogram", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReportHistogram indicates an expected call of ReportHistogram.
func (mr *MockReporterMockRecorder) ReportHistogram(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReportHistogram", reflect.TypeOf((*MockReporter)(nil).ReportHistogram), arg0, arg1, arg2)
}

// ReportSummary mocks base method.
func (m *MockReporter) ReportSummary(arg0 string, arg1 map[string]string, arg2 float64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReportSummary", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReportSummary indicates an expected call of ReportSummary.
func (mr *MockReporterMockRecorder) ReportSummary(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReportSummary", reflect.TypeOf((*MockReporter)(nil).ReportSummary), arg0, arg1, arg2)
}

```

`pkg/metrics/mocks/statsd_reporter.go`:

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/topfreegames/pitaya/v3/pkg/metrics (interfaces: Client)

// Package mocks is a generated GoMock package.
package mocks

import (
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
)

// MockClient is a mock of Client interface.
type MockClient struct {
	ctrl     *gomock.Controller
	recorder *MockClientMockRecorder
}

// MockClientMockRecorder is the mock recorder for MockClient.
type MockClientMockRecorder struct {
	mock *MockClient
}

// NewMockClient creates a new mock instance.
func NewMockClient(ctrl *gomock.Controller) *MockClient {
	mock := &MockClient{ctrl: ctrl}
	mock.recorder = &MockClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockClient) EXPECT() *MockClientMockRecorder {
	return m.recorder
}

// Count mocks base method.
func (m *MockClient) Count(arg0 string, arg1 int64, arg2 []string, arg3 float64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Count", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// Count indicates an expected call of Count.
func (mr *MockClientMockRecorder) Count(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockClient)(nil).Count), arg0, arg1, arg2, arg3)
}

// Gauge mocks base method.
func (m *MockClient) Gauge(arg0 string, arg1 float64, arg2 []string, arg3 float64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Gauge", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// Gauge indicates an expected call of Gauge.
func (mr *MockClientMockRecorder) Gauge(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Gauge", reflect.TypeOf((*MockClient)(nil).Gauge), arg0, arg1, arg2, arg3)
}

// TimeInMilliseconds mocks base method.
func (m *MockClient) TimeInMilliseconds(arg0 string, arg1 float64, arg2 []string, arg3 float64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TimeInMilliseconds", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// TimeInMilliseconds indicates an expected call of TimeInMilliseconds.
func (mr *MockClientMockRecorder) TimeInMilliseconds(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TimeInMilliseconds", reflect.TypeOf((*MockClient)(nil).TimeInMilliseconds), arg0, arg1, arg2, arg3)
}

```

`pkg/metrics/models/models.go`:

```go
package models

// Summary defines a summary metric
type Summary struct {
	Subsystem  string
	Name       string
	Help       string
	Objectives map[float64]float64
	Labels     []string
}

// Histogram defines a histogram metric
type Histogram struct {
	Subsystem  string
	Name       string
	Help       string
	Buckets    []float64
	Labels     []string
}

// Gauge defines a gauge metric
type Gauge struct {
	Subsystem string
	Name      string
	Help      string
	Labels    []string
}

// Counter defines a counter metric
type Counter struct {
	Subsystem string
	Name      string
	Help      string
	Labels    []string
}

// CustomMetricsSpec has all metrics specs
type CustomMetricsSpec struct {
	Summaries  []*Summary
	Histograms []*Histogram
	Gauges     []*Gauge
	Counters   []*Counter
}

```

`pkg/metrics/prometheus_reporter.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package metrics

import (
	"fmt"

	"github.com/topfreegames/pitaya/v3/pkg/logger"

	"net/http"
	"sync"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/metrics/models"
)

var (
	prometheusReporter *PrometheusReporter
	once               sync.Once
)

// PrometheusReporter reports metrics to prometheus
type PrometheusReporter struct {
	serverType            string
	game                  string
	countReportersMap     map[string]*prometheus.CounterVec
	summaryReportersMap   map[string]*prometheus.SummaryVec
	histogramReportersMap map[string]*prometheus.HistogramVec
	gaugeReportersMap     map[string]*prometheus.GaugeVec
	additionalLabels      map[string]string
}

func (p *PrometheusReporter) registerCustomMetrics(
	constLabels map[string]string,
	additionalLabelsKeys []string,
	spec *models.CustomMetricsSpec,
) {
	for _, summary := range spec.Summaries {
		p.summaryReportersMap[summary.Name] = prometheus.NewSummaryVec(
			prometheus.SummaryOpts{
				Namespace:   "pitaya",
				Subsystem:   summary.Subsystem,
				Name:        summary.Name,
				Help:        summary.Help,
				Objectives:  summary.Objectives,
				ConstLabels: constLabels,
			},
			append(additionalLabelsKeys, summary.Labels...),
		)
	}

	for _, histogram := range spec.Histograms {
		p.histogramReportersMap[histogram.Name] = prometheus.NewHistogramVec(
			prometheus.HistogramOpts{
				Namespace:   "pitaya",
				Subsystem:   histogram.Subsystem,
				Name:        histogram.Name,
				Help:        histogram.Help,
				Buckets:     histogram.Buckets,
				ConstLabels: constLabels,
			},
			append(additionalLabelsKeys, histogram.Labels...),
		)
	}

	for _, gauge := range spec.Gauges {
		p.gaugeReportersMap[gauge.Name] = prometheus.NewGaugeVec(
			prometheus.GaugeOpts{
				Namespace:   "pitaya",
				Subsystem:   gauge.Subsystem,
				Name:        gauge.Name,
				Help:        gauge.Help,
				ConstLabels: constLabels,
			},
			append(additionalLabelsKeys, gauge.Labels...),
		)
	}

	for _, counter := range spec.Counters {
		p.countReportersMap[counter.Name] = prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Namespace:   "pitaya",
				Subsystem:   counter.Subsystem,
				Name:        counter.Name,
				Help:        counter.Help,
				ConstLabels: constLabels,
			},
			append(additionalLabelsKeys, counter.Labels...),
		)
	}
}

func (p *PrometheusReporter) registerMetrics(
	constLabels, additionalLabels map[string]string,
	spec *models.CustomMetricsSpec,
) {

	constLabels["game"] = p.game
	constLabels["serverType"] = p.serverType

	p.additionalLabels = additionalLabels
	additionalLabelsKeys := make([]string, 0, len(additionalLabels))
	for key := range additionalLabels {
		additionalLabelsKeys = append(additionalLabelsKeys, key)
	}

	p.registerCustomMetrics(constLabels, additionalLabelsKeys, spec)

	// HandlerResponseTimeMs summary
	p.summaryReportersMap[ResponseTime] = prometheus.NewSummaryVec(
		prometheus.SummaryOpts{
			Namespace:   "pitaya",
			Subsystem:   "handler",
			Name:        ResponseTime,
			Help:        "the time to process a msg in nanoseconds",
			Objectives:  map[float64]float64{0.7: 0.02, 0.95: 0.005, 0.99: 0.001},
			ConstLabels: constLabels,
		},
		append([]string{"route", "status", "type", "code"}, additionalLabelsKeys...),
	)

	p.histogramReportersMap[ResponseTime] = prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Namespace:   "pitaya",
			Subsystem:   "handler",
			Name:        ResponseTime,
			Help:        "the time to process a msg in nanoseconds",
			Buckets:     []float64{1, 5, 10, 50, 100, 300, 500, 1000, 5000, 10000},
			ConstLabels: constLabels,
		},
		append([]string{"route", "status", "type", "code"}, additionalLabelsKeys...),
	)

	// ProcessDelay summary
	p.summaryReportersMap[ProcessDelay] = prometheus.NewSummaryVec(
		prometheus.SummaryOpts{
			Namespace:   "pitaya",
			Subsystem:   "handler",
			Name:        ProcessDelay,
			Help:        "the delay to start processing a msg in nanoseconds",
			Objectives:  map[float64]float64{0.7: 0.02, 0.95: 0.005, 0.99: 0.001},
			ConstLabels: constLabels,
		},
		append([]string{"route", "type"}, additionalLabelsKeys...),
	)

	// ConnectedClients gauge
	p.gaugeReportersMap[ConnectedClients] = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Namespace:   "pitaya",
			Subsystem:   "acceptor",
			Name:        ConnectedClients,
			Help:        "the number of clients connected right now",
			ConstLabels: constLabels,
		},
		additionalLabelsKeys,
	)

	p.gaugeReportersMap[CountServers] = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Namespace:   "pitaya",
			Subsystem:   "service_discovery",
			Name:        CountServers,
			Help:        "the number of discovered servers by service discovery",
			ConstLabels: constLabels,
		},
		append([]string{"type"}, additionalLabelsKeys...),
	)

	p.histogramReportersMap[ChannelCapacity] = prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Namespace:   "pitaya",
			Subsystem:   "channel",
			Name:        ChannelCapacity,
			Help:        "the available capacity of the channel",
			Buckets:     []float64{0, 1, 10, 50, 100, 250, 500, 750, 1000, 1500, 2000, 3000, 4000, 5000},
			ConstLabels: constLabels,
		},
		append([]string{"channel"}, additionalLabelsKeys...),
	)

	p.gaugeReportersMap[DroppedMessages] = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Namespace:   "pitaya",
			Subsystem:   "rpc_server",
			Name:        DroppedMessages,
			Help:        "the number of rpc server dropped messages (messages that are not handled)",
			ConstLabels: constLabels,
		},
		additionalLabelsKeys,
	)

	p.gaugeReportersMap[Goroutines] = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Namespace:   "pitaya",
			Subsystem:   "sys",
			Name:        Goroutines,
			Help:        "the current number of goroutines",
			ConstLabels: constLabels,
		},
		additionalLabelsKeys,
	)

	p.gaugeReportersMap[HeapSize] = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Namespace:   "pitaya",
			Subsystem:   "sys",
			Name:        HeapSize,
			Help:        "the current heap size",
			ConstLabels: constLabels,
		},
		additionalLabelsKeys,
	)

	p.gaugeReportersMap[HeapObjects] = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Namespace:   "pitaya",
			Subsystem:   "sys",
			Name:        HeapObjects,
			Help:        "the current number of allocated heap objects",
			ConstLabels: constLabels,
		},
		additionalLabelsKeys,
	)

	p.gaugeReportersMap[WorkerJobsRetry] = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Namespace:   "pitaya",
			Subsystem:   "worker",
			Name:        WorkerJobsRetry,
			Help:        "the current number of job retries",
			ConstLabels: constLabels,
		},
		additionalLabelsKeys,
	)

	p.gaugeReportersMap[WorkerQueueSize] = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Namespace:   "pitaya",
			Subsystem:   "worker",
			Name:        WorkerQueueSize,
			Help:        "the current queue size",
			ConstLabels: constLabels,
		},
		append([]string{"queue"}, additionalLabelsKeys...),
	)

	p.gaugeReportersMap[WorkerJobsTotal] = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Namespace:   "pitaya",
			Subsystem:   "worker",
			Name:        WorkerJobsTotal,
			Help:        "the total executed jobs",
			ConstLabels: constLabels,
		},
		append([]string{"status"}, additionalLabelsKeys...),
	)

	p.countReportersMap[ExceededRateLimiting] = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Namespace:   "pitaya",
			Subsystem:   "acceptor",
			Name:        ExceededRateLimiting,
			Help:        "the number of blocked requests by exceeded rate limiting",
			ConstLabels: constLabels,
		},
		additionalLabelsKeys,
	)

	toRegister := make([]prometheus.Collector, 0)
	for _, c := range p.countReportersMap {
		toRegister = append(toRegister, c)
	}

	for _, c := range p.gaugeReportersMap {
		toRegister = append(toRegister, c)
	}

	for _, c := range p.summaryReportersMap {
		toRegister = append(toRegister, c)
	}

	prometheus.MustRegister(toRegister...)
}

// GetPrometheusReporter gets the prometheus reporter singleton
func GetPrometheusReporter(
	serverType string,
	config config.MetricsConfig,
	metricsSpecs models.CustomMetricsSpec,
) (*PrometheusReporter, error) {
	return getPrometheusReporter(serverType, config, &metricsSpecs)
}

func getPrometheusReporter(
	serverType string,
	config config.MetricsConfig,
	metricsSpecs *models.CustomMetricsSpec,
) (*PrometheusReporter, error) {
	once.Do(func() {
		prometheusReporter = &PrometheusReporter{
			serverType:            serverType,
			game:                  config.Game,
			countReportersMap:     make(map[string]*prometheus.CounterVec),
			histogramReportersMap: make(map[string]*prometheus.HistogramVec),
			summaryReportersMap:   make(map[string]*prometheus.SummaryVec),
			gaugeReportersMap:     make(map[string]*prometheus.GaugeVec),
		}
		prometheusReporter.registerMetrics(config.ConstLabels, config.AdditionalLabels, metricsSpecs)
		http.Handle("/metrics", promhttp.Handler())
		go (func() {
			err := http.ListenAndServe(fmt.Sprintf(":%d", config.Prometheus.Port), nil)
			if err != nil {
				logger.Log.Error("prometheus reporter serve start failed, err: ", err)
			}
		})()
	})

	return prometheusReporter, nil
}

// ReportSummary reports a summary metric
func (p *PrometheusReporter) ReportSummary(metric string, labels map[string]string, value float64) error {
	sum := p.summaryReportersMap[metric]
	if sum != nil {
		labels = p.ensureLabels(labels)
		sum.With(labels).Observe(value)
		return nil
	}
	return constants.ErrMetricNotKnown
}

// ReportHistogram reports a histogram metric
func (p *PrometheusReporter) ReportHistogram(metric string, labels map[string]string, value float64) error {
	hist := p.histogramReportersMap[metric]
	if hist != nil {
		labels = p.ensureLabels(labels)
		hist.With(labels).Observe(value)
		return nil
	}
	return constants.ErrMetricNotKnown
}

// ReportCount reports a summary metric
func (p *PrometheusReporter) ReportCount(metric string, labels map[string]string, count float64) error {
	cnt := p.countReportersMap[metric]
	if cnt != nil {
		labels = p.ensureLabels(labels)
		cnt.With(labels).Add(count)
		return nil
	}
	return constants.ErrMetricNotKnown
}

// ReportGauge reports a gauge metric
func (p *PrometheusReporter) ReportGauge(metric string, labels map[string]string, value float64) error {
	g := p.gaugeReportersMap[metric]
	if g != nil {
		labels = p.ensureLabels(labels)
		g.With(labels).Set(value)
		return nil
	}
	return constants.ErrMetricNotKnown
}

// ensureLabels checks if labels contains the additionalLabels values,
// otherwise adds them with the default values
func (p *PrometheusReporter) ensureLabels(labels map[string]string) map[string]string {
	for key, defaultVal := range p.additionalLabels {
		if _, ok := labels[key]; !ok {
			labels[key] = defaultVal
		}
	}

	return labels
}

```

`pkg/metrics/report.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package metrics

import (
	"context"
	"runtime"
	"time"

	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/errors"

	pcontext "github.com/topfreegames/pitaya/v3/pkg/context"
)

// ReportTimingFromCtx reports the latency from the context
func ReportTimingFromCtx(ctx context.Context, reporters []Reporter, typ string, err error) {
	if ctx == nil {
		return
	}
	code := errors.CodeFromError(err)
	status := "ok"
	if err != nil {
		status = "failed"
	}
	if len(reporters) > 0 {
		startTime := pcontext.GetFromPropagateCtx(ctx, constants.StartTimeKey)
		route := pcontext.GetFromPropagateCtx(ctx, constants.RouteKey)
		elapsed := time.Since(time.Unix(0, startTime.(int64)))
		tags := getTags(ctx, map[string]string{
			"route":  route.(string),
			"status": status,
			"type":   typ,
			"code":   code,
		})
		for _, r := range reporters {
			r.ReportSummary(ResponseTime, tags, float64(elapsed.Nanoseconds()))
		}
	}
}

// ReportMessageProcessDelayFromCtx reports the delay to process the messages
func ReportMessageProcessDelayFromCtx(ctx context.Context, reporters []Reporter, typ string) {
	if len(reporters) > 0 {
		startTime := pcontext.GetFromPropagateCtx(ctx, constants.StartTimeKey)
		elapsed := time.Since(time.Unix(0, startTime.(int64)))
		route := pcontext.GetFromPropagateCtx(ctx, constants.RouteKey)
		tags := getTags(ctx, map[string]string{
			"route": route.(string),
			"type":  typ,
		})
		for _, r := range reporters {
			r.ReportSummary(ProcessDelay, tags, float64(elapsed.Nanoseconds()))
		}
	}
}

// ReportNumberOfConnectedClients reports the number of connected clients
func ReportNumberOfConnectedClients(reporters []Reporter, number int64) {
	for _, r := range reporters {
		r.ReportGauge(ConnectedClients, map[string]string{}, float64(number))
	}
}

// ReportSysMetrics reports sys metrics
func ReportSysMetrics(reporters []Reporter, period time.Duration) {
	for {
		for _, r := range reporters {
			num := runtime.NumGoroutine()
			m := &runtime.MemStats{}
			runtime.ReadMemStats(m)

			r.ReportGauge(Goroutines, map[string]string{}, float64(num))
			r.ReportGauge(HeapSize, map[string]string{}, float64(m.Alloc))
			r.ReportGauge(HeapObjects, map[string]string{}, float64(m.HeapObjects))
		}

		time.Sleep(period)
	}
}

// ReportExceededRateLimiting reports the number of requests made
// after exceeded rate limiting in a connection
func ReportExceededRateLimiting(reporters []Reporter) {
	for _, r := range reporters {
		r.ReportCount(ExceededRateLimiting, map[string]string{}, 1)
	}
}

func tagsFromContext(ctx context.Context) map[string]string {
	val := pcontext.GetFromPropagateCtx(ctx, constants.MetricTagsKey)
	if val == nil {
		return map[string]string{}
	}

	tags, ok := val.(map[string]string)
	if !ok {
		return map[string]string{}
	}

	return tags
}

func getTags(ctx context.Context, tags map[string]string) map[string]string {
	for k, v := range tagsFromContext(ctx) {
		tags[k] = v
	}

	return tags
}

```

`pkg/metrics/report_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package metrics

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/golang/mock/gomock"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	pcontext "github.com/topfreegames/pitaya/v3/pkg/context"
	e "github.com/topfreegames/pitaya/v3/pkg/errors"
	"github.com/topfreegames/pitaya/v3/pkg/metrics/mocks"
)

func TestReportTimingFromCtx(t *testing.T) {
	t.Run("test-duration", func(t *testing.T) {
		ctrl := gomock.NewController(t)
		defer ctrl.Finish()
		mockMetricsReporter := mocks.NewMockReporter(ctrl)

		originalTs := time.Now().UnixNano()
		expectedRoute := uuid.New().String()
		expectedType := uuid.New().String()
		expectedErr := errors.New(uuid.New().String())
		ctx := pcontext.AddToPropagateCtx(context.Background(), constants.StartTimeKey, originalTs)
		ctx = pcontext.AddToPropagateCtx(ctx, constants.RouteKey, expectedRoute)

		time.Sleep(200 * time.Millisecond) // to test duration report
		mockMetricsReporter.EXPECT().ReportSummary(ResponseTime, gomock.Any(), gomock.Any()).Do(
			func(metric string, tags map[string]string, duration float64) {
				assert.InDelta(t, duration, time.Now().UnixNano()-originalTs, 10e6)
			},
		)

		ReportTimingFromCtx(ctx, []Reporter{mockMetricsReporter}, expectedType, expectedErr)
	})

	t.Run("test-tags", func(t *testing.T) {
		ctrl := gomock.NewController(t)
		defer ctrl.Finish()
		mockMetricsReporter := mocks.NewMockReporter(ctrl)

		originalTs := time.Now().UnixNano()
		expectedRoute := uuid.New().String()
		expectedType := uuid.New().String()
		var expectedErr error
		ctx := pcontext.AddToPropagateCtx(context.Background(), constants.StartTimeKey, originalTs)
		ctx = pcontext.AddToPropagateCtx(ctx, constants.RouteKey, expectedRoute)
		ctx = pcontext.AddToPropagateCtx(ctx, constants.MetricTagsKey, map[string]string{
			"key": "value",
		})

		expectedTags := map[string]string{
			"route":  expectedRoute,
			"status": "ok",
			"type":   expectedType,
			"key":    "value",
			"code":   "",
		}

		mockMetricsReporter.EXPECT().ReportSummary(ResponseTime, expectedTags, gomock.Any())

		ReportTimingFromCtx(ctx, []Reporter{mockMetricsReporter}, expectedType, expectedErr)
	})

	t.Run("test-tags-not-correct-type", func(t *testing.T) {
		ctrl := gomock.NewController(t)
		defer ctrl.Finish()
		mockMetricsReporter := mocks.NewMockReporter(ctrl)

		originalTs := time.Now().UnixNano()
		expectedRoute := uuid.New().String()
		expectedType := uuid.New().String()
		var expectedErr error
		ctx := pcontext.AddToPropagateCtx(context.Background(), constants.StartTimeKey, originalTs)
		ctx = pcontext.AddToPropagateCtx(ctx, constants.RouteKey, expectedRoute)
		ctx = pcontext.AddToPropagateCtx(ctx, constants.MetricTagsKey, "not-map")

		expectedTags := map[string]string{
			"route":  expectedRoute,
			"status": "ok",
			"type":   expectedType,
			"code":   "",
		}

		mockMetricsReporter.EXPECT().ReportSummary(ResponseTime, expectedTags, gomock.Any())

		ReportTimingFromCtx(ctx, []Reporter{mockMetricsReporter}, expectedType, expectedErr)
	})

	t.Run("test-failed-route-with-pitaya-error", func(t *testing.T) {
		ctrl := gomock.NewController(t)
		defer ctrl.Finish()
		mockMetricsReporter := mocks.NewMockReporter(ctrl)

		originalTs := time.Now().UnixNano()
		expectedRoute := uuid.New().String()
		expectedType := uuid.New().String()
		code := "GAME-404"
		expectedErr := e.NewError(errors.New("error"), code)
		ctx := pcontext.AddToPropagateCtx(context.Background(), constants.StartTimeKey, originalTs)
		ctx = pcontext.AddToPropagateCtx(ctx, constants.RouteKey, expectedRoute)

		mockMetricsReporter.EXPECT().ReportSummary(ResponseTime, map[string]string{
			"route":  expectedRoute,
			"status": "failed",
			"type":   expectedType,
			"code":   code,
		}, gomock.Any())

		ReportTimingFromCtx(ctx, []Reporter{mockMetricsReporter}, expectedType, expectedErr)
	})

	t.Run("test-failed-route", func(t *testing.T) {
		ctrl := gomock.NewController(t)
		defer ctrl.Finish()
		mockMetricsReporter := mocks.NewMockReporter(ctrl)

		originalTs := time.Now().UnixNano()
		expectedRoute := uuid.New().String()
		expectedType := uuid.New().String()
		expectedErr := errors.New("error")
		ctx := pcontext.AddToPropagateCtx(context.Background(), constants.StartTimeKey, originalTs)
		ctx = pcontext.AddToPropagateCtx(ctx, constants.RouteKey, expectedRoute)

		mockMetricsReporter.EXPECT().ReportSummary(ResponseTime, map[string]string{
			"route":  expectedRoute,
			"status": "failed",
			"type":   expectedType,
			"code":   e.ErrUnknownCode,
		}, gomock.Any())

		ReportTimingFromCtx(ctx, []Reporter{mockMetricsReporter}, expectedType, expectedErr)
	})
}

func TestReportMessageProcessDelayFromCtx(t *testing.T) {
	t.Run("test-tags", func(t *testing.T) {
		ctrl := gomock.NewController(t)
		defer ctrl.Finish()
		mockMetricsReporter := mocks.NewMockReporter(ctrl)

		originalTs := time.Now().UnixNano()
		expectedRoute := uuid.New().String()
		expectedType := uuid.New().String()
		ctx := pcontext.AddToPropagateCtx(context.Background(), constants.StartTimeKey, originalTs)
		ctx = pcontext.AddToPropagateCtx(ctx, constants.RouteKey, expectedRoute)
		ctx = pcontext.AddToPropagateCtx(ctx, constants.MetricTagsKey, map[string]string{
			"key": "value",
		})

		expectedTags := map[string]string{
			"route": expectedRoute,
			"type":  expectedType,
			"key":   "value",
		}

		mockMetricsReporter.EXPECT().ReportSummary(ProcessDelay, expectedTags, gomock.Any())

		ReportMessageProcessDelayFromCtx(ctx, []Reporter{mockMetricsReporter}, expectedType)
	})
}

```

`pkg/metrics/reporter_interfaces.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package metrics

// Reporter interface
type Reporter interface {
	ReportCount(metric string, tags map[string]string, count float64) error
	ReportSummary(metric string, tags map[string]string, value float64) error
	ReportHistogram(metric string, tags map[string]string, value float64) error
	ReportGauge(metric string, tags map[string]string, value float64) error
}

```

`pkg/metrics/statsd_reporter.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package metrics

import (
	"fmt"

	"github.com/topfreegames/pitaya/v3/pkg/constants"

	"github.com/DataDog/datadog-go/statsd"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
)

// Client is the interface to required dogstatsd functions
type Client interface {
	Count(name string, value int64, tags []string, rate float64) error
	Gauge(name string, value float64, tags []string, rate float64) error
	TimeInMilliseconds(name string, value float64, tags []string, rate float64) error
}

// StatsdReporter sends application metrics to statsd
type StatsdReporter struct {
	client      Client
	rate        float64
	serverType  string
	defaultTags []string
}

// NewStatsdReporter returns an instance of statsd reportar and an
// error if something fails
func NewStatsdReporter(
	config config.MetricsConfig,
	serverType string,
	clientOrNil ...Client,
) (*StatsdReporter, error) {
	return newStatsdReporter(config, serverType, clientOrNil...)
}

func newStatsdReporter(
	config config.MetricsConfig,
	serverType string,
	clientOrNil ...Client) (*StatsdReporter, error) {
	sr := &StatsdReporter{
		rate:       config.Statsd.Rate,
		serverType: serverType,
	}

	sr.buildDefaultTags(config.ConstLabels)

	if len(clientOrNil) > 0 {
		sr.client = clientOrNil[0]
	} else {
		c, err := statsd.New(config.Statsd.Host)
		if err != nil {
			return nil, err
		}
		c.Namespace = config.Statsd.Prefix
		sr.client = c
	}
	return sr, nil
}

func (s *StatsdReporter) buildDefaultTags(tagsMap map[string]string) {
	defaultTags := make([]string, len(tagsMap)+1)

	defaultTags[0] = fmt.Sprintf("serverType:%s", s.serverType)

	idx := 1
	for k, v := range tagsMap {
		defaultTags[idx] = fmt.Sprintf("%s:%s", k, v)
		idx++
	}

	s.defaultTags = defaultTags
}

// ReportCount sends count reports to statsd
func (s *StatsdReporter) ReportCount(metric string, tagsMap map[string]string, count float64) error {
	fullTags := s.defaultTags

	for k, v := range tagsMap {
		fullTags = append(fullTags, fmt.Sprintf("%s:%s", k, v))
	}

	err := s.client.Count(metric, int64(count), fullTags, s.rate)
	if err != nil {
		logger.Log.Errorf("failed to report count: %q", err)
	}

	return err
}

// ReportGauge sents the gauge value and reports to statsd
func (s *StatsdReporter) ReportGauge(metric string, tagsMap map[string]string, value float64) error {
	fullTags := s.defaultTags

	for k, v := range tagsMap {
		fullTags = append(fullTags, fmt.Sprintf("%s:%s", k, v))
	}

	err := s.client.Gauge(metric, value, fullTags, s.rate)
	if err != nil {
		logger.Log.Errorf("failed to report gauge: %q", err)
	}

	return err
}

// ReportSummary observes the summary value and reports to statsd
func (s *StatsdReporter) ReportSummary(metric string, tagsMap map[string]string, value float64) error {
	fullTags := s.defaultTags

	for k, v := range tagsMap {
		fullTags = append(fullTags, fmt.Sprintf("%s:%s", k, v))
	}

	err := s.client.TimeInMilliseconds(metric, float64(value), fullTags, s.rate)
	if err != nil {
		logger.Log.Errorf("failed to report summary: %q", err)
	}

	return err
}

// ReportHistogram observes the histogram value and reports to statsd
func (s *StatsdReporter) ReportHistogram(metric string, tagsMap map[string]string, value float64) error {
	return constants.ErrNotImplemented
}

```

`pkg/metrics/statsd_reporter_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package metrics

import (
	"errors"
	"fmt"
	"testing"
	"time"

	"github.com/golang/mock/gomock"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	metricsmocks "github.com/topfreegames/pitaya/v3/pkg/metrics/mocks"
)

func TestNewStatsdReporter(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockClient := metricsmocks.NewMockClient(ctrl)

	cfg := config.NewDefaultPitayaConfig().Metrics
	sr, err := NewStatsdReporter(cfg, "svType", mockClient)
	assert.NoError(t, err)
	assert.Equal(t, mockClient, sr.client)
	assert.Equal(t, float64(cfg.Statsd.Rate), sr.rate)
	assert.Equal(t, "svType", sr.serverType)
}

func TestReportLatency(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockClient := metricsmocks.NewMockClient(ctrl)

	cfg := config.NewDefaultPitayaConfig().Metrics
	cfg.ConstLabels = map[string]string{
		"defaultTag": "value",
	}
	sr, err := NewStatsdReporter(cfg, "svType", mockClient)
	assert.NoError(t, err)

	expectedDuration, err := time.ParseDuration("200ms")
	assert.NoError(t, err)
	expectedRoute := uuid.New().String()
	expectedType := uuid.New().String()
	expectedErrored := "failed"

	mockClient.EXPECT().TimeInMilliseconds("response_time_ns", float64(expectedDuration.Nanoseconds()), gomock.Any(), sr.rate).Do(func(n string, d float64, tags []string, r float64) {
		assert.Contains(t, tags, fmt.Sprintf("route:%s", expectedRoute))
		assert.Contains(t, tags, fmt.Sprintf("type:%s", expectedType))
		assert.Contains(t, tags, fmt.Sprintf("status:%s", expectedErrored))
		assert.Contains(t, tags, fmt.Sprintf("serverType:%s", sr.serverType))
		assert.Contains(t, tags, "defaultTag:value")
	})

	err = sr.ReportSummary(ResponseTime, map[string]string{
		"route":      expectedRoute,
		"type":       expectedType,
		"status":     expectedErrored,
		"serverType": sr.serverType,
	}, float64(expectedDuration.Nanoseconds()))
	assert.NoError(t, err)
}

func TestReportLatencyError(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockClient := metricsmocks.NewMockClient(ctrl)

	cfg := config.NewDefaultPitayaConfig().Metrics
	sr, err := NewStatsdReporter(cfg, "svType", mockClient)
	assert.NoError(t, err)

	expectedError := errors.New("some error")
	mockClient.EXPECT().TimeInMilliseconds("response_time_ns", gomock.Any(), gomock.Any(), sr.rate).Return(expectedError)

	err = sr.ReportSummary(ResponseTime, map[string]string{}, float64(123))
	assert.Equal(t, expectedError, err)
}

func TestReportCount(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockClient := metricsmocks.NewMockClient(ctrl)

	cfg := config.NewDefaultPitayaConfig().Metrics
	cfg.ConstLabels = map[string]string{
		"defaultTag": "value",
	}
	sr, err := NewStatsdReporter(cfg, "svType", mockClient)
	assert.NoError(t, err)

	expectedCount := 123
	expectedMetric := uuid.New().String()
	customTags := map[string]string{
		"tag1:": uuid.New().String(),
		"tag2:": uuid.New().String(),
	}
	mockClient.EXPECT().Count(expectedMetric, int64(expectedCount), gomock.Any(), sr.rate).Do(func(n string, v int64, tags []string, r float64) {
		for k, v := range customTags {
			assert.Contains(t, tags, fmt.Sprintf("%s:%s", k, v))
		}
		assert.Contains(t, tags, fmt.Sprintf("serverType:%s", sr.serverType))
		assert.Contains(t, tags, "defaultTag:value")
	})

	err = sr.ReportCount(expectedMetric, customTags, float64(expectedCount))
	assert.NoError(t, err)
}

func TestReportCountError(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockClient := metricsmocks.NewMockClient(ctrl)

	cfg := config.NewDefaultPitayaConfig().Metrics
	sr, err := NewStatsdReporter(cfg, "svType", mockClient)
	assert.NoError(t, err)

	expectedError := errors.New("some error")
	mockClient.EXPECT().Count(gomock.Any(), gomock.Any(), gomock.Any(), sr.rate).Return(expectedError)

	err = sr.ReportCount("123", map[string]string{}, float64(123))
	assert.Equal(t, expectedError, err)
}

func TestReportGauge(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockClient := metricsmocks.NewMockClient(ctrl)

	cfg := config.NewDefaultPitayaConfig().Metrics
	cfg.ConstLabels = map[string]string{
		"defaultTag": "value",
	}
	sr, err := NewStatsdReporter(cfg, "svType", mockClient)
	assert.NoError(t, err)

	expectedValue := 123.1
	expectedMetric := uuid.New().String()
	customTags := map[string]string{
		"tag1:": uuid.New().String(),
		"tag2:": uuid.New().String(),
	}
	mockClient.EXPECT().Gauge(expectedMetric, expectedValue, gomock.Any(), sr.rate).Do(func(n string, v float64, tags []string, r float64) {
		for k, v := range customTags {
			assert.Contains(t, tags, fmt.Sprintf("%s:%s", k, v))
		}
		assert.Contains(t, tags, fmt.Sprintf("serverType:%s", sr.serverType))
		assert.Contains(t, tags, "defaultTag:value")
	})

	err = sr.ReportGauge(expectedMetric, customTags, float64(expectedValue))
	assert.NoError(t, err)
}

func TestReportGaugeError(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockClient := metricsmocks.NewMockClient(ctrl)

	cfg := config.NewDefaultPitayaConfig().Metrics
	cfg.ConstLabels = map[string]string{
		"defaultTag": "value",
	}
	sr, err := NewStatsdReporter(cfg, "svType", mockClient)
	assert.NoError(t, err)

	expectedError := errors.New("some error")
	mockClient.EXPECT().Gauge(gomock.Any(), gomock.Any(), gomock.Any(), sr.rate).Return(expectedError)

	err = sr.ReportGauge("123", map[string]string{}, float64(123.1))
	assert.Equal(t, expectedError, err)
}

```

`pkg/mocks/acceptor.go`:

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/topfreegames/pitaya/v3/pkg/acceptor (interfaces: PlayerConn,Acceptor)

// Package mocks is a generated GoMock package.
package mocks

import (
	net "net"
	reflect "reflect"
	time "time"

	gomock "github.com/golang/mock/gomock"
	acceptor "github.com/topfreegames/pitaya/v3/pkg/acceptor"
)

// MockPlayerConn is a mock of PlayerConn interface.
type MockPlayerConn struct {
	ctrl     *gomock.Controller
	recorder *MockPlayerConnMockRecorder
}

// MockPlayerConnMockRecorder is the mock recorder for MockPlayerConn.
type MockPlayerConnMockRecorder struct {
	mock *MockPlayerConn
}

// NewMockPlayerConn creates a new mock instance.
func NewMockPlayerConn(ctrl *gomock.Controller) *MockPlayerConn {
	mock := &MockPlayerConn{ctrl: ctrl}
	mock.recorder = &MockPlayerConnMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPlayerConn) EXPECT() *MockPlayerConnMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockPlayerConn) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockPlayerConnMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockPlayerConn)(nil).Close))
}

// GetNextMessage mocks base method.
func (m *MockPlayerConn) GetNextMessage() ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetNextMessage")
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetNextMessage indicates an expected call of GetNextMessage.
func (mr *MockPlayerConnMockRecorder) GetNextMessage() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNextMessage", reflect.TypeOf((*MockPlayerConn)(nil).GetNextMessage))
}

// LocalAddr mocks base method.
func (m *MockPlayerConn) LocalAddr() net.Addr {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LocalAddr")
	ret0, _ := ret[0].(net.Addr)
	return ret0
}

// LocalAddr indicates an expected call of LocalAddr.
func (mr *MockPlayerConnMockRecorder) LocalAddr() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LocalAddr", reflect.TypeOf((*MockPlayerConn)(nil).LocalAddr))
}

// Read mocks base method.
func (m *MockPlayerConn) Read(arg0 []byte) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Read", arg0)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Read indicates an expected call of Read.
func (mr *MockPlayerConnMockRecorder) Read(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockPlayerConn)(nil).Read), arg0)
}

// RemoteAddr mocks base method.
func (m *MockPlayerConn) RemoteAddr() net.Addr {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoteAddr")
	ret0, _ := ret[0].(net.Addr)
	return ret0
}

// RemoteAddr indicates an expected call of RemoteAddr.
func (mr *MockPlayerConnMockRecorder) RemoteAddr() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoteAddr", reflect.TypeOf((*MockPlayerConn)(nil).RemoteAddr))
}

// SetDeadline mocks base method.
func (m *MockPlayerConn) SetDeadline(arg0 time.Time) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetDeadline", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetDeadline indicates an expected call of SetDeadline.
func (mr *MockPlayerConnMockRecorder) SetDeadline(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetDeadline", reflect.TypeOf((*MockPlayerConn)(nil).SetDeadline), arg0)
}

// SetReadDeadline mocks base method.
func (m *MockPlayerConn) SetReadDeadline(arg0 time.Time) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetReadDeadline", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetReadDeadline indicates an expected call of SetReadDeadline.
func (mr *MockPlayerConnMockRecorder) SetReadDeadline(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetReadDeadline", reflect.TypeOf((*MockPlayerConn)(nil).SetReadDeadline), arg0)
}

// SetWriteDeadline mocks base method.
func (m *MockPlayerConn) SetWriteDeadline(arg0 time.Time) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetWriteDeadline", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetWriteDeadline indicates an expected call of SetWriteDeadline.
func (mr *MockPlayerConnMockRecorder) SetWriteDeadline(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetWriteDeadline", reflect.TypeOf((*MockPlayerConn)(nil).SetWriteDeadline), arg0)
}

// Write mocks base method.
func (m *MockPlayerConn) Write(arg0 []byte) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Write", arg0)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Write indicates an expected call of Write.
func (mr *MockPlayerConnMockRecorder) Write(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockPlayerConn)(nil).Write), arg0)
}

// MockAcceptor is a mock of Acceptor interface.
type MockAcceptor struct {
	ctrl     *gomock.Controller
	recorder *MockAcceptorMockRecorder
}

// MockAcceptorMockRecorder is the mock recorder for MockAcceptor.
type MockAcceptorMockRecorder struct {
	mock *MockAcceptor
}

// NewMockAcceptor creates a new mock instance.
func NewMockAcceptor(ctrl *gomock.Controller) *MockAcceptor {
	mock := &MockAcceptor{ctrl: ctrl}
	mock.recorder = &MockAcceptorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAcceptor) EXPECT() *MockAcceptorMockRecorder {
	return m.recorder
}

// EnableProxyProtocol mocks base method.
func (m *MockAcceptor) EnableProxyProtocol() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "EnableProxyProtocol")
}

// EnableProxyProtocol indicates an expected call of EnableProxyProtocol.
func (mr *MockAcceptorMockRecorder) EnableProxyProtocol() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnableProxyProtocol", reflect.TypeOf((*MockAcceptor)(nil).EnableProxyProtocol))
}

// GetAddr mocks base method.
func (m *MockAcceptor) GetAddr() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAddr")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetAddr indicates an expected call of GetAddr.
func (mr *MockAcceptorMockRecorder) GetAddr() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAddr", reflect.TypeOf((*MockAcceptor)(nil).GetAddr))
}

// GetConfiguredAddress mocks base method.
func (m *MockAcceptor) GetConfiguredAddress() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetConfiguredAddress")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetConfiguredAddress indicates an expected call of GetConfiguredAddress.
func (mr *MockAcceptorMockRecorder) GetConfiguredAddress() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetConfiguredAddress", reflect.TypeOf((*MockAcceptor)(nil).GetConfiguredAddress))
}

// GetConnChan mocks base method.
func (m *MockAcceptor) GetConnChan() chan acceptor.PlayerConn {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetConnChan")
	ret0, _ := ret[0].(chan acceptor.PlayerConn)
	return ret0
}

// GetConnChan indicates an expected call of GetConnChan.
func (mr *MockAcceptorMockRecorder) GetConnChan() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetConnChan", reflect.TypeOf((*MockAcceptor)(nil).GetConnChan))
}

// IsRunning mocks base method.
func (m *MockAcceptor) IsRunning() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsRunning")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsRunning indicates an expected call of IsRunning.
func (mr *MockAcceptorMockRecorder) IsRunning() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsRunning", reflect.TypeOf((*MockAcceptor)(nil).IsRunning))
}

// ListenAndServe mocks base method.
func (m *MockAcceptor) ListenAndServe() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ListenAndServe")
}

// ListenAndServe indicates an expected call of ListenAndServe.
func (mr *MockAcceptorMockRecorder) ListenAndServe() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListenAndServe", reflect.TypeOf((*MockAcceptor)(nil).ListenAndServe))
}

// Stop mocks base method.
func (m *MockAcceptor) Stop() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Stop")
}

// Stop indicates an expected call of Stop.
func (mr *MockAcceptorMockRecorder) Stop() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockAcceptor)(nil).Stop))
}

```

`pkg/mocks/app.go`:

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/topfreegames/pitaya/v3/pkg (interfaces: Pitaya)

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"
	time "time"

	gomock "github.com/golang/mock/gomock"
	cluster "github.com/topfreegames/pitaya/v3/pkg/cluster"
	component "github.com/topfreegames/pitaya/v3/pkg/component"
	config "github.com/topfreegames/pitaya/v3/pkg/config"
	interfaces "github.com/topfreegames/pitaya/v3/pkg/interfaces"
	metrics "github.com/topfreegames/pitaya/v3/pkg/metrics"
	router "github.com/topfreegames/pitaya/v3/pkg/router"
	session "github.com/topfreegames/pitaya/v3/pkg/session"
	worker "github.com/topfreegames/pitaya/v3/pkg/worker"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
)

// MockPitaya is a mock of Pitaya interface.
type MockPitaya struct {
	ctrl     *gomock.Controller
	recorder *MockPitayaMockRecorder
}

// MockPitayaMockRecorder is the mock recorder for MockPitaya.
type MockPitayaMockRecorder struct {
	mock *MockPitaya
}

// NewMockPitaya creates a new mock instance.
func NewMockPitaya(ctrl *gomock.Controller) *MockPitaya {
	mock := &MockPitaya{ctrl: ctrl}
	mock.recorder = &MockPitayaMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPitaya) EXPECT() *MockPitayaMockRecorder {
	return m.recorder
}

// AddRoute mocks base method.
func (m *MockPitaya) AddRoute(arg0 string, arg1 router.RoutingFunc) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddRoute", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddRoute indicates an expected call of AddRoute.
func (mr *MockPitayaMockRecorder) AddRoute(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddRoute", reflect.TypeOf((*MockPitaya)(nil).AddRoute), arg0, arg1)
}

// Documentation mocks base method.
func (m *MockPitaya) Documentation(arg0 bool) (map[string]interface{}, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Documentation", arg0)
	ret0, _ := ret[0].(map[string]interface{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Documentation indicates an expected call of Documentation.
func (mr *MockPitayaMockRecorder) Documentation(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Documentation", reflect.TypeOf((*MockPitaya)(nil).Documentation), arg0)
}

// GetDieChan mocks base method.
func (m *MockPitaya) GetDieChan() chan bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetDieChan")
	ret0, _ := ret[0].(chan bool)
	return ret0
}

// GetDieChan indicates an expected call of GetDieChan.
func (mr *MockPitayaMockRecorder) GetDieChan() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDieChan", reflect.TypeOf((*MockPitaya)(nil).GetDieChan))
}

// GetMetricsReporters mocks base method.
func (m *MockPitaya) GetMetricsReporters() []metrics.Reporter {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMetricsReporters")
	ret0, _ := ret[0].([]metrics.Reporter)
	return ret0
}

// GetMetricsReporters indicates an expected call of GetMetricsReporters.
func (mr *MockPitayaMockRecorder) GetMetricsReporters() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMetricsReporters", reflect.TypeOf((*MockPitaya)(nil).GetMetricsReporters))
}

// GetModule mocks base method.
func (m *MockPitaya) GetModule(arg0 string) (interfaces.Module, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetModule", arg0)
	ret0, _ := ret[0].(interfaces.Module)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetModule indicates an expected call of GetModule.
func (mr *MockPitayaMockRecorder) GetModule(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetModule", reflect.TypeOf((*MockPitaya)(nil).GetModule), arg0)
}

// GetNumberOfConnectedClients mocks base method.
func (m *MockPitaya) GetNumberOfConnectedClients() int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetNumberOfConnectedClients")
	ret0, _ := ret[0].(int64)
	return ret0
}

// GetNumberOfConnectedClients indicates an expected call of GetNumberOfConnectedClients.
func (mr *MockPitayaMockRecorder) GetNumberOfConnectedClients() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNumberOfConnectedClients", reflect.TypeOf((*MockPitaya)(nil).GetNumberOfConnectedClients))
}

// GetServer mocks base method.
func (m *MockPitaya) GetServer() *cluster.Server {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetServer")
	ret0, _ := ret[0].(*cluster.Server)
	return ret0
}

// GetServer indicates an expected call of GetServer.
func (mr *MockPitayaMockRecorder) GetServer() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetServer", reflect.TypeOf((*MockPitaya)(nil).GetServer))
}

// GetServerByID mocks base method.
func (m *MockPitaya) GetServerByID(arg0 string) (*cluster.Server, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetServerByID", arg0)
	ret0, _ := ret[0].(*cluster.Server)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetServerByID indicates an expected call of GetServerByID.
func (mr *MockPitayaMockRecorder) GetServerByID(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetServerByID", reflect.TypeOf((*MockPitaya)(nil).GetServerByID), arg0)
}

// GetServerID mocks base method.
func (m *MockPitaya) GetServerID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetServerID")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetServerID indicates an expected call of GetServerID.
func (mr *MockPitayaMockRecorder) GetServerID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetServerID", reflect.TypeOf((*MockPitaya)(nil).GetServerID))
}

// GetServers mocks base method.
func (m *MockPitaya) GetServers() []*cluster.Server {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetServers")
	ret0, _ := ret[0].([]*cluster.Server)
	return ret0
}

// GetServers indicates an expected call of GetServers.
func (mr *MockPitayaMockRecorder) GetServers() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetServers", reflect.TypeOf((*MockPitaya)(nil).GetServers))
}

// GetServersByType mocks base method.
func (m *MockPitaya) GetServersByType(arg0 string) (map[string]*cluster.Server, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetServersByType", arg0)
	ret0, _ := ret[0].(map[string]*cluster.Server)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetServersByType indicates an expected call of GetServersByType.
func (mr *MockPitayaMockRecorder) GetServersByType(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetServersByType", reflect.TypeOf((*MockPitaya)(nil).GetServersByType), arg0)
}

// GetSessionFromCtx mocks base method.
func (m *MockPitaya) GetSessionFromCtx(arg0 context.Context) session.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSessionFromCtx", arg0)
	ret0, _ := ret[0].(session.Session)
	return ret0
}

// GetSessionFromCtx indicates an expected call of GetSessionFromCtx.
func (mr *MockPitayaMockRecorder) GetSessionFromCtx(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSessionFromCtx", reflect.TypeOf((*MockPitaya)(nil).GetSessionFromCtx), arg0)
}

// GroupAddMember mocks base method.
func (m *MockPitaya) GroupAddMember(arg0 context.Context, arg1, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GroupAddMember", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// GroupAddMember indicates an expected call of GroupAddMember.
func (mr *MockPitayaMockRecorder) GroupAddMember(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GroupAddMember", reflect.TypeOf((*MockPitaya)(nil).GroupAddMember), arg0, arg1, arg2)
}

// GroupBroadcast mocks base method.
func (m *MockPitaya) GroupBroadcast(arg0 context.Context, arg1, arg2, arg3 string, arg4 interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GroupBroadcast", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].(error)
	return ret0
}

// GroupBroadcast indicates an expected call of GroupBroadcast.
func (mr *MockPitayaMockRecorder) GroupBroadcast(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GroupBroadcast", reflect.TypeOf((*MockPitaya)(nil).GroupBroadcast), arg0, arg1, arg2, arg3, arg4)
}

// GroupContainsMember mocks base method.
func (m *MockPitaya) GroupContainsMember(arg0 context.Context, arg1, arg2 string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GroupContainsMember", arg0, arg1, arg2)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GroupContainsMember indicates an expected call of GroupContainsMember.
func (mr *MockPitayaMockRecorder) GroupContainsMember(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GroupContainsMember", reflect.TypeOf((*MockPitaya)(nil).GroupContainsMember), arg0, arg1, arg2)
}

// GroupCountMembers mocks base method.
func (m *MockPitaya) GroupCountMembers(arg0 context.Context, arg1 string) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GroupCountMembers", arg0, arg1)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GroupCountMembers indicates an expected call of GroupCountMembers.
func (mr *MockPitayaMockRecorder) GroupCountMembers(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GroupCountMembers", reflect.TypeOf((*MockPitaya)(nil).GroupCountMembers), arg0, arg1)
}

// GroupCreate mocks base method.
func (m *MockPitaya) GroupCreate(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GroupCreate", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// GroupCreate indicates an expected call of GroupCreate.
func (mr *MockPitayaMockRecorder) GroupCreate(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GroupCreate", reflect.TypeOf((*MockPitaya)(nil).GroupCreate), arg0, arg1)
}

// GroupCreateWithTTL mocks base method.
func (m *MockPitaya) GroupCreateWithTTL(arg0 context.Context, arg1 string, arg2 time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GroupCreateWithTTL", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// GroupCreateWithTTL indicates an expected call of GroupCreateWithTTL.
func (mr *MockPitayaMockRecorder) GroupCreateWithTTL(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GroupCreateWithTTL", reflect.TypeOf((*MockPitaya)(nil).GroupCreateWithTTL), arg0, arg1, arg2)
}

// GroupDelete mocks base method.
func (m *MockPitaya) GroupDelete(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GroupDelete", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// GroupDelete indicates an expected call of GroupDelete.
func (mr *MockPitayaMockRecorder) GroupDelete(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GroupDelete", reflect.TypeOf((*MockPitaya)(nil).GroupDelete), arg0, arg1)
}

// GroupMembers mocks base method.
func (m *MockPitaya) GroupMembers(arg0 context.Context, arg1 string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GroupMembers", arg0, arg1)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GroupMembers indicates an expected call of GroupMembers.
func (mr *MockPitayaMockRecorder) GroupMembers(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GroupMembers", reflect.TypeOf((*MockPitaya)(nil).GroupMembers), arg0, arg1)
}

// GroupRemoveAll mocks base method.
func (m *MockPitaya) GroupRemoveAll(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GroupRemoveAll", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// GroupRemoveAll indicates an expected call of GroupRemoveAll.
func (mr *MockPitayaMockRecorder) GroupRemoveAll(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GroupRemoveAll", reflect.TypeOf((*MockPitaya)(nil).GroupRemoveAll), arg0, arg1)
}

// GroupRemoveMember mocks base method.
func (m *MockPitaya) GroupRemoveMember(arg0 context.Context, arg1, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GroupRemoveMember", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// GroupRemoveMember indicates an expected call of GroupRemoveMember.
func (mr *MockPitayaMockRecorder) GroupRemoveMember(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GroupRemoveMember", reflect.TypeOf((*MockPitaya)(nil).GroupRemoveMember), arg0, arg1, arg2)
}

// GroupRenewTTL mocks base method.
func (m *MockPitaya) GroupRenewTTL(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GroupRenewTTL", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// GroupRenewTTL indicates an expected call of GroupRenewTTL.
func (mr *MockPitayaMockRecorder) GroupRenewTTL(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GroupRenewTTL", reflect.TypeOf((*MockPitaya)(nil).GroupRenewTTL), arg0, arg1)
}

// IsReady mocks base method.
func (m *MockPitaya) IsReady(arg0 context.Context) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsReady", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsReady indicates an expected call of IsReady.
func (mr *MockPitayaMockRecorder) IsReady(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsReady", reflect.TypeOf((*MockPitaya)(nil).IsReady), arg0)
}

// IsRunning mocks base method.
func (m *MockPitaya) IsRunning() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsRunning")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsRunning indicates an expected call of IsRunning.
func (mr *MockPitayaMockRecorder) IsRunning() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsRunning", reflect.TypeOf((*MockPitaya)(nil).IsRunning))
}

// RPC mocks base method.
func (m *MockPitaya) RPC(arg0 context.Context, arg1 string, arg2, arg3 protoiface.MessageV1) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RPC", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// RPC indicates an expected call of RPC.
func (mr *MockPitayaMockRecorder) RPC(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RPC", reflect.TypeOf((*MockPitaya)(nil).RPC), arg0, arg1, arg2, arg3)
}

// RPCTo mocks base method.
func (m *MockPitaya) RPCTo(arg0 context.Context, arg1, arg2 string, arg3, arg4 protoiface.MessageV1) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RPCTo", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].(error)
	return ret0
}

// RPCTo indicates an expected call of RPCTo.
func (mr *MockPitayaMockRecorder) RPCTo(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RPCTo", reflect.TypeOf((*MockPitaya)(nil).RPCTo), arg0, arg1, arg2, arg3, arg4)
}

// Register mocks base method.
func (m *MockPitaya) Register(arg0 component.Component, arg1 ...component.Option) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Register", varargs...)
}

// Register indicates an expected call of Register.
func (mr *MockPitayaMockRecorder) Register(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Register", reflect.TypeOf((*MockPitaya)(nil).Register), varargs...)
}

// RegisterModule mocks base method.
func (m *MockPitaya) RegisterModule(arg0 interfaces.Module, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RegisterModule", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// RegisterModule indicates an expected call of RegisterModule.
func (mr *MockPitayaMockRecorder) RegisterModule(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterModule", reflect.TypeOf((*MockPitaya)(nil).RegisterModule), arg0, arg1)
}

// RegisterModuleAfter mocks base method.
func (m *MockPitaya) RegisterModuleAfter(arg0 interfaces.Module, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RegisterModuleAfter", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// RegisterModuleAfter indicates an expected call of RegisterModuleAfter.
func (mr *MockPitayaMockRecorder) RegisterModuleAfter(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterModuleAfter", reflect.TypeOf((*MockPitaya)(nil).RegisterModuleAfter), arg0, arg1)
}

// RegisterModuleBefore mocks base method.
func (m *MockPitaya) RegisterModuleBefore(arg0 interfaces.Module, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RegisterModuleBefore", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// RegisterModuleBefore indicates an expected call of RegisterModuleBefore.
func (mr *MockPitayaMockRecorder) RegisterModuleBefore(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterModuleBefore", reflect.TypeOf((*MockPitaya)(nil).RegisterModuleBefore), arg0, arg1)
}

// RegisterRPCJob mocks base method.
func (m *MockPitaya) RegisterRPCJob(arg0 worker.RPCJob) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RegisterRPCJob", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// RegisterRPCJob indicates an expected call of RegisterRPCJob.
func (mr *MockPitayaMockRecorder) RegisterRPCJob(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterRPCJob", reflect.TypeOf((*MockPitaya)(nil).RegisterRPCJob), arg0)
}

// RegisterRemote mocks base method.
func (m *MockPitaya) RegisterRemote(arg0 component.Component, arg1 ...component.Option) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "RegisterRemote", varargs...)
}

// RegisterRemote indicates an expected call of RegisterRemote.
func (mr *MockPitayaMockRecorder) RegisterRemote(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterRemote", reflect.TypeOf((*MockPitaya)(nil).RegisterRemote), varargs...)
}

// ReliableRPC mocks base method.
func (m *MockPitaya) ReliableRPC(arg0 string, arg1 map[string]interface{}, arg2, arg3 protoiface.MessageV1) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReliableRPC", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReliableRPC indicates an expected call of ReliableRPC.
func (mr *MockPitayaMockRecorder) ReliableRPC(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReliableRPC", reflect.TypeOf((*MockPitaya)(nil).ReliableRPC), arg0, arg1, arg2, arg3)
}

// ReliableRPCWithOptions mocks base method.
func (m *MockPitaya) ReliableRPCWithOptions(arg0 string, arg1 map[string]interface{}, arg2, arg3 protoiface.MessageV1, arg4 *config.EnqueueOpts) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReliableRPCWithOptions", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReliableRPCWithOptions indicates an expected call of ReliableRPCWithOptions.
func (mr *MockPitayaMockRecorder) ReliableRPCWithOptions(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReliableRPCWithOptions", reflect.TypeOf((*MockPitaya)(nil).ReliableRPCWithOptions), arg0, arg1, arg2, arg3, arg4)
}

// SendKickToUsers mocks base method.
func (m *MockPitaya) SendKickToUsers(arg0 []string, arg1 string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendKickToUsers", arg0, arg1)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SendKickToUsers indicates an expected call of SendKickToUsers.
func (mr *MockPitayaMockRecorder) SendKickToUsers(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendKickToUsers", reflect.TypeOf((*MockPitaya)(nil).SendKickToUsers), arg0, arg1)
}

// SendPushToUsers mocks base method.
func (m *MockPitaya) SendPushToUsers(arg0 string, arg1 interface{}, arg2 []string, arg3 string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendPushToUsers", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SendPushToUsers indicates an expected call of SendPushToUsers.
func (mr *MockPitayaMockRecorder) SendPushToUsers(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendPushToUsers", reflect.TypeOf((*MockPitaya)(nil).SendPushToUsers), arg0, arg1, arg2, arg3)
}

// SetDebug mocks base method.
func (m *MockPitaya) SetDebug(arg0 bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetDebug", arg0)
}

// SetDebug indicates an expected call of SetDebug.
func (mr *MockPitayaMockRecorder) SetDebug(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetDebug", reflect.TypeOf((*MockPitaya)(nil).SetDebug), arg0)
}

// SetDictionary mocks base method.
func (m *MockPitaya) SetDictionary(arg0 map[string]uint16) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetDictionary", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetDictionary indicates an expected call of SetDictionary.
func (mr *MockPitayaMockRecorder) SetDictionary(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetDictionary", reflect.TypeOf((*MockPitaya)(nil).SetDictionary), arg0)
}

// SetHeartbeatTime mocks base method.
func (m *MockPitaya) SetHeartbeatTime(arg0 time.Duration) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetHeartbeatTime", arg0)
}

// SetHeartbeatTime indicates an expected call of SetHeartbeatTime.
func (mr *MockPitayaMockRecorder) SetHeartbeatTime(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetHeartbeatTime", reflect.TypeOf((*MockPitaya)(nil).SetHeartbeatTime), arg0)
}

// Shutdown mocks base method.
func (m *MockPitaya) Shutdown() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Shutdown")
}

// Shutdown indicates an expected call of Shutdown.
func (mr *MockPitayaMockRecorder) Shutdown() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Shutdown", reflect.TypeOf((*MockPitaya)(nil).Shutdown))
}

// Start mocks base method.
func (m *MockPitaya) Start() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Start")
}

// Start indicates an expected call of Start.
func (mr *MockPitayaMockRecorder) Start() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockPitaya)(nil).Start))
}

// StartWorker mocks base method.
func (m *MockPitaya) StartWorker() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "StartWorker")
}

// StartWorker indicates an expected call of StartWorker.
func (mr *MockPitayaMockRecorder) StartWorker() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartWorker", reflect.TypeOf((*MockPitaya)(nil).StartWorker))
}

```

`pkg/module.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package pitaya

import (
	"fmt"

	"github.com/topfreegames/pitaya/v3/pkg/interfaces"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
)

type moduleWrapper struct {
	module interfaces.Module
	name   string
}

type sessionModuleWrapper struct {
	module interfaces.SessionModule
	name   string
}

// RegisterModule registers a module, by default it register after registered modules
func (app *App) RegisterModule(module interfaces.Module, name string) error {
	return app.RegisterModuleAfter(module, name)
}

// RegisterModuleAfter registers a module after all registered modules
func (app *App) RegisterModuleAfter(module interfaces.Module, name string) error {
	if err := app.alreadyRegistered(name); err != nil {
		return err
	}

	app.modulesMap[name] = module
	app.modulesArr = append(app.modulesArr, moduleWrapper{
		module: module,
		name:   name,
	})

	if sm, ok := module.(interfaces.SessionModule); ok {
		app.sessionModulesArr = append(app.sessionModulesArr, sessionModuleWrapper{
			module: sm,
			name:   name,
		})
	}

	return nil
}

// RegisterModuleBefore registers a module before all registered modules
func (app *App) RegisterModuleBefore(module interfaces.Module, name string) error {
	if err := app.alreadyRegistered(name); err != nil {
		return err
	}

	app.modulesMap[name] = module
	app.modulesArr = append([]moduleWrapper{
		{
			module: module,
			name:   name,
		},
	}, app.modulesArr...)

	if sm, ok := module.(interfaces.SessionModule); ok {
		app.sessionModulesArr = append([]sessionModuleWrapper{
			{
				module: sm,
				name:   name,
			},
		}, app.sessionModulesArr...)
	}

	return nil
}

// GetModule gets a module with a name
func (app *App) GetModule(name string) (interfaces.Module, error) {
	if m, ok := app.modulesMap[name]; ok {
		return m, nil
	}
	return nil, fmt.Errorf("module with name %s not found", name)
}

func (app *App) alreadyRegistered(name string) error {
	if _, ok := app.modulesMap[name]; ok {
		return fmt.Errorf("module with name %s already exists", name)
	}

	return nil
}

// startModules starts all modules in order
func (app *App) startModules() {
	logger.Log.Debug("initializing all modules")
	for _, modWrapper := range app.modulesArr {
		logger.Log.Debugf("initializing module: %s", modWrapper.name)
		if err := modWrapper.module.Init(); err != nil {
			logger.Log.Fatalf("error starting module %s, error: %s", modWrapper.name, err.Error())
		}
	}

	for _, modWrapper := range app.modulesArr {
		modWrapper.module.AfterInit()
		logger.Log.Infof("module: %s successfully loaded", modWrapper.name)
	}
}

func (app *App) startModuleSessionDraining() {
	for i := len(app.sessionModulesArr) - 1; i >= 0; i-- {
		name := app.sessionModulesArr[i].name
		mod := app.sessionModulesArr[i].module

		logger.Log.Debugf("start session draining on module: %s", name)
		mod.StartSessionDraining()
	}
}

func (app *App) maxModuleSessionCount() int64 {
	count := int64(0)
	for _, mod := range app.sessionModulesArr {
		c := mod.module.SessionCount()
		if c > count {
			count = c
		}
	}
	return count
}

// shutdownModules starts all modules in reverse order
func (app *App) shutdownModules() {
	for i := len(app.modulesArr) - 1; i >= 0; i-- {
		app.modulesArr[i].module.BeforeShutdown()
	}

	for i := len(app.modulesArr) - 1; i >= 0; i-- {
		name := app.modulesArr[i].name
		mod := app.modulesArr[i].module

		logger.Log.Debugf("stopping module: %s", name)
		if err := mod.Shutdown(); err != nil {
			logger.Log.Warnf("error stopping module: %s", name)
		}
		logger.Log.Infof("module: %s stopped!", name)
	}
}

```

`pkg/module_test.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package pitaya

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/config"
)

type MyMod struct {
	component.Base
	running bool
	name    string
}

var modulesOrder []string

func (m *MyMod) Init() error {
	m.running = true
	modulesOrder = append(modulesOrder, m.name)
	return nil
}

func (m *MyMod) Shutdown() error {
	m.running = false
	modulesOrder = append(modulesOrder, m.name)
	return nil
}

func TestRegisterModule(t *testing.T) {
	b := &MyMod{}

	config := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *config).(*App)

	err := app.RegisterModule(b, "mod")
	assert.NoError(t, err)
	assert.Equal(t, 1, len(app.modulesMap))
	assert.Equal(t, b, app.modulesMap["mod"])
	assert.Equal(t, 1, len(app.modulesArr))
	assert.Equal(t, "mod", app.modulesArr[0].name)
	assert.Equal(t, b, app.modulesArr[0].module)
	err = app.RegisterModule(b, "mod")
	assert.Error(t, err)
}

func TestGetModule(t *testing.T) {
	b := &MyMod{}

	config := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *config)

	app.RegisterModule(b, "mod")
	m, err := app.GetModule("mod")
	assert.NoError(t, err)
	assert.Equal(t, b, m)

	m, err = app.GetModule("mmm")
	assert.Error(t, err)
}

func TestStartupModules(t *testing.T) {
	modulesOrder = []string{}
	app := NewDefaultApp(true, "testtype", Standalone, map[string]string{}, *config.NewDefaultPitayaConfig()).(*App)

	err := app.RegisterModule(&MyMod{name: "mod1"}, "mod1")
	assert.NoError(t, err)
	err = app.RegisterModuleBefore(&MyMod{name: "mod2"}, "mod2")
	assert.NoError(t, err)
	err = app.RegisterModuleBefore(&MyMod{name: "mod3"}, "mod3")
	assert.NoError(t, err)
	err = app.RegisterModuleAfter(&MyMod{name: "mod4"}, "mod4")
	assert.NoError(t, err)

	app.startModules()
	assert.Equal(t, true, app.modulesMap["mod1"].(*MyMod).running)
	assert.Equal(t, true, app.modulesMap["mod2"].(*MyMod).running)
	assert.Equal(t, true, app.modulesMap["mod3"].(*MyMod).running)
	assert.Equal(t, true, app.modulesMap["mod4"].(*MyMod).running)
	assert.Equal(t, []string{"mod3", "mod2", "mod1", "mod4"}, modulesOrder)
}

func TestShutdownModules(t *testing.T) {
	modulesOrder = []string{}
	app := NewDefaultApp(true, "testtype", Standalone, map[string]string{}, *config.NewDefaultPitayaConfig()).(*App)

	err := app.RegisterModule(&MyMod{name: "mod1"}, "mod1")
	assert.NoError(t, err)
	err = app.RegisterModuleBefore(&MyMod{name: "mod2"}, "mod2")
	assert.NoError(t, err)
	err = app.RegisterModuleBefore(&MyMod{name: "mod3"}, "mod3")
	assert.NoError(t, err)
	err = app.RegisterModuleAfter(&MyMod{name: "mod4"}, "mod4")
	assert.NoError(t, err)

	app.startModules()

	modulesOrder = []string{}
	app.shutdownModules()
	assert.Equal(t, false, app.modulesMap["mod1"].(*MyMod).running)
	assert.Equal(t, false, app.modulesMap["mod2"].(*MyMod).running)
	assert.Equal(t, false, app.modulesMap["mod3"].(*MyMod).running)
	assert.Equal(t, false, app.modulesMap["mod4"].(*MyMod).running)
	assert.Equal(t, []string{"mod4", "mod1", "mod2", "mod3"}, modulesOrder)
}

```

`pkg/modules/api_docs_gen.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package modules

import (
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
)

// APIDocsGen is a pitaya module that generates api docs for pitaya servers
type APIDocsGen struct {
	Base
	basePath string
	services []*component.Service
}

// NewAPIDocsGen creates a new APIDocsGen
func NewAPIDocsGen(basePath string, services []*component.Service) *APIDocsGen {
	return &APIDocsGen{
		basePath: basePath,
		services: services,
	}
}

// Init is called on init method
func (a *APIDocsGen) Init() error {
	for _, s := range a.services {
		logger.Log.Infof("loaded svc: %s", s.Name)
	}
	return nil
}

```

`pkg/modules/base.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package modules

// Base implements a default component for Component.
type Base struct{}

// Init was called to initialize the component.
func (c *Base) Init() error {
	return nil
}

// AfterInit was called after the component is initialized.
func (c *Base) AfterInit() {}

// BeforeShutdown was called before the component to shutdown.
func (c *Base) BeforeShutdown() {}

// Shutdown was called to shutdown the component.
func (c *Base) Shutdown() error {
	return nil
}

```

`pkg/modules/binary.go`:

```go
//go:build linux || darwin
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package modules

import (
	"bufio"
	"os/exec"
	"syscall"
	"time"

	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
)

// Binary is a pitaya module that starts a binary as a child process and
// pipes its stdout
type Binary struct {
	Base
	binPath                  string
	args                     []string
	gracefulShutdownInterval time.Duration
	cmd                      *exec.Cmd
	exitCh                   chan struct{}
}

// NewBinary creates a new binary module with the given path
func NewBinary(binPath string, args []string, gracefulShutdownInterval ...time.Duration) *Binary {
	gracefulTime := 15 * time.Second
	if len(gracefulShutdownInterval) > 0 {
		gracefulTime = gracefulShutdownInterval[0]
	}
	return &Binary{
		binPath:                  binPath,
		args:                     args,
		gracefulShutdownInterval: gracefulTime,
		exitCh:                   make(chan struct{}),
	}
}

// GetExitChannel gets a channel that is closed when the binary dies
func (b *Binary) GetExitChannel() chan struct{} {
	return b.exitCh
}

// Init initializes the binary
func (b *Binary) Init() error {
	b.cmd = exec.Command(b.binPath, b.args...)
	stdout, _ := b.cmd.StdoutPipe()
	stdOutScanner := bufio.NewScanner(stdout)
	stderr, _ := b.cmd.StderrPipe()
	stdErrScanner := bufio.NewScanner(stderr)
	go func() {
		for stdOutScanner.Scan() {
			logger.Log.Info(stdOutScanner.Text())
		}
	}()
	go func() {
		for stdErrScanner.Scan() {
			logger.Log.Error(stdErrScanner.Text())
		}
	}()
	err := b.cmd.Start()
	go func() {
		b.cmd.Wait()
		close(b.exitCh)
	}()
	return err
}

// Shutdown shutdowns the binary module
func (b *Binary) Shutdown() error {
	err := b.cmd.Process.Signal(syscall.SIGTERM)
	if err != nil {
		return err
	}
	timeout := time.After(b.gracefulShutdownInterval)
	select {
	case <-b.exitCh:
		return nil
	case <-timeout:
		b.cmd.Process.Kill()
		return constants.ErrTimeoutTerminatingBinaryModule
	}
}

```

`pkg/modules/binary_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
package modules

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

func TestNewBinary(t *testing.T) {
	tables := []struct {
		name                     string
		binPath                  string
		args                     []string
		gracefulShutdownInterval time.Duration
	}{
		{"cmd1", "go", []string{"some", "arg"}, 2 * time.Second},
		{"cmd2", "go", []string{}, 2 * time.Second},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			b := NewBinary(table.binPath, table.args, table.gracefulShutdownInterval)
			assert.NotNil(t, b)
			assert.Equal(t, table.binPath, b.binPath)
			assert.Equal(t, table.args, b.args)
			assert.Equal(t, table.gracefulShutdownInterval, b.gracefulShutdownInterval)
		})
	}
}

func TestInit(t *testing.T) {
	tables := []struct {
		name                     string
		binPath                  string
		args                     []string
		gracefulShutdownInterval time.Duration
	}{
		{"cmd1", "go", []string{"version"}, 2 * time.Second},
		{"cmd2", "go", []string{}, 2 * time.Second},
	}
	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			b := NewBinary(table.binPath, table.args, table.gracefulShutdownInterval)
			err := b.Init()
			assert.NoError(t, err)
		})
	}
}

func TestShutdown(t *testing.T) {
	tables := []struct {
		name                     string
		binPath                  string
		args                     []string
		gracefulShutdownInterval time.Duration
		err                      error
	}{
		{"cmd1", "tail", []string{"-f", "/dev/null"}, 2 * time.Second, nil},
	}
	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			b := NewBinary(table.binPath, table.args, table.gracefulShutdownInterval)
			err := b.Init()
			assert.NoError(t, err)
			err = b.Shutdown()
			assert.NoError(t, err)
		})
	}
}

```

`pkg/modules/binary_windows.go`:

```go
//go:build windows
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package modules

import (
	"bufio"
	"os/exec"
	"runtime"
	"syscall"
	"time"

	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
)

// Binary is a pitaya module that starts a binary as a child process and
// pipes its stdout
type Binary struct {
	Base
	binPath                  string
	args                     []string
	gracefulShutdownInterval time.Duration
	cmd                      *exec.Cmd
	exitCh                   chan struct{}
}

// NewBinary creates a new binary module with the given path
func NewBinary(binPath string, args []string, gracefulShutdownInterval ...time.Duration) *Binary {
	gracefulTime := 15 * time.Second
	if len(gracefulShutdownInterval) > 0 {
		gracefulTime = gracefulShutdownInterval[0]
	}
	return &Binary{
		binPath:                  binPath,
		args:                     args,
		gracefulShutdownInterval: gracefulTime,
		exitCh:                   make(chan struct{}),
	}
}

// GetExitChannel gets a channel that is closed when the binary dies
func (b *Binary) GetExitChannel() chan struct{} {
	return b.exitCh
}

// Init initializes the binary
func (b *Binary) Init() error {
	b.cmd = exec.Command(b.binPath, b.args...)
	stdout, _ := b.cmd.StdoutPipe()
	stdOutScanner := bufio.NewScanner(stdout)
	stderr, _ := b.cmd.StderrPipe()
	stdErrScanner := bufio.NewScanner(stderr)
	go func() {
		for stdOutScanner.Scan() {
			logger.Log.Info(stdOutScanner.Text())
		}
	}()
	go func() {
		for stdErrScanner.Scan() {
			logger.Log.Error(stdErrScanner.Text())
		}
	}()
	err := b.cmd.Start()
	go func() {
		b.cmd.Wait()
		close(b.exitCh)
	}()
	return err
}

// sendCtrlBreak sends a ctrl break signal to the process, this is a replacement for syscall.SIGTERM in windows
func sendCtrlBreak(pid int) error {
	d, e := syscall.LoadDLL("kernel32.dll")
	if e != nil {
		return e
	}
	p, e := d.FindProc("GenerateConsoleCtrlEvent")
	if e != nil {
		return e
	}
	r, _, e := p.Call(uintptr(syscall.CTRL_BREAK_EVENT), uintptr(pid))
	if r == 0 {
		return e // syscall.GetLastError()
	}
	return nil
}

// Shutdown shutdowns the binary module
func (b *Binary) Shutdown() error {
	if runtime.GOOS == "windows" { // windows does not support SIGTERM
		if err := sendCtrlBreak(b.cmd.Process.Pid); err != nil {
			return err
		}
	} else {
		err := b.cmd.Process.Signal(syscall.SIGTERM)
		if err != nil {
			return err
		}
	}
	timeout := time.After(b.gracefulShutdownInterval)
	select {
	case <-b.exitCh:
		return nil
	case <-timeout:
		b.cmd.Process.Kill()
		return constants.ErrTimeoutTerminatingBinaryModule
	}
}

```

`pkg/modules/binding_storage.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package modules

import (
	"context"
	"fmt"
	"time"

	clientv3 "go.etcd.io/etcd/client/v3"
	"go.etcd.io/etcd/client/v3/namespace"
	"github.com/topfreegames/pitaya/v3/pkg/cluster"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/session"
)

// ETCDBindingStorage module that uses etcd to keep in which frontend server each user is bound
type ETCDBindingStorage struct {
	Base
	cli             *clientv3.Client
	etcdEndpoints   []string
	etcdPrefix      string
	etcdDialTimeout time.Duration
	leaseTTL        time.Duration
	leaseID         clientv3.LeaseID
	thisServer      *cluster.Server
	sessionPool     session.SessionPool
	stopChan        chan struct{}
}

// NewETCDBindingStorage returns a new instance of BindingStorage
func NewETCDBindingStorage(server *cluster.Server, sessionPool session.SessionPool, conf config.ETCDBindingConfig) *ETCDBindingStorage {
	b := &ETCDBindingStorage{
		thisServer:  server,
		sessionPool: sessionPool,
		stopChan:    make(chan struct{}),
	}
	b.etcdDialTimeout = conf.DialTimeout
	b.etcdEndpoints = conf.Endpoints
	b.etcdPrefix = conf.Prefix
	b.leaseTTL = conf.LeaseTTL
	return b
}

func getUserBindingKey(uid, frontendType string) string {
	return fmt.Sprintf("bindings/%s/%s", frontendType, uid)
}

// PutBinding puts the binding info into etcd
func (b *ETCDBindingStorage) PutBinding(uid string) error {
	_, err := b.cli.Put(context.Background(), getUserBindingKey(uid, b.thisServer.Type), b.thisServer.ID, clientv3.WithLease(b.leaseID))
	return err
}

func (b *ETCDBindingStorage) removeBinding(uid string) error {
	_, err := b.cli.Delete(context.Background(), getUserBindingKey(uid, b.thisServer.Type))
	return err
}

// GetUserFrontendID gets the id of the frontend server a user is connected to
// TODO: should we set context here?
// TODO: this could be way more optimized, using watcher and local caching
func (b *ETCDBindingStorage) GetUserFrontendID(uid, frontendType string) (string, error) {
	etcdRes, err := b.cli.Get(context.Background(), getUserBindingKey(uid, frontendType))
	if err != nil {
		return "", err
	}
	if len(etcdRes.Kvs) == 0 {
		return "", constants.ErrBindingNotFound
	}
	return string(etcdRes.Kvs[0].Value), nil
}

func (b *ETCDBindingStorage) setupOnSessionCloseCB() {
	b.sessionPool.OnSessionClose(func(s session.Session) {
		if s.UID() != "" {
			err := b.removeBinding(s.UID())
			if err != nil {
				logger.Log.Errorf("error removing binding info from storage: %v", err)
			}
		}
	})
}

func (b *ETCDBindingStorage) setupOnAfterSessionBindCB() {
	b.sessionPool.OnAfterSessionBind(func(ctx context.Context, s session.Session) error {
		return b.PutBinding(s.UID())
	})
}

func (b *ETCDBindingStorage) watchLeaseChan(c <-chan *clientv3.LeaseKeepAliveResponse) {
	for {
		select {
		case <-b.stopChan:
			return
		case kaRes := <-c:
			if kaRes == nil {
				logger.Log.Warn("[binding storage] sd: error renewing etcd lease, rebootstrapping")
				for {
					err := b.bootstrapLease()
					if err != nil {
						logger.Log.Warn("[binding storage] sd: error rebootstrapping lease, will retry in 5 seconds")
						time.Sleep(5 * time.Second)
						continue
					} else {
						return
					}
				}
			}
		}
	}
}

func (b *ETCDBindingStorage) bootstrapLease() error {
	// grab lease
	l, err := b.cli.Grant(context.TODO(), int64(b.leaseTTL.Seconds()))
	if err != nil {
		return err
	}
	b.leaseID = l.ID
	logger.Log.Debugf("[binding storage] sd: got leaseID: %x", l.ID)
	// this will keep alive forever, when channel c is closed
	// it means we probably have to rebootstrap the lease
	c, err := b.cli.KeepAlive(context.TODO(), b.leaseID)
	if err != nil {
		return err
	}
	// need to receive here as per etcd docs
	<-c
	go b.watchLeaseChan(c)
	return nil
}

// Init starts the binding storage module
func (b *ETCDBindingStorage) Init() error {
	var cli *clientv3.Client
	var err error
	if b.cli == nil {
		cli, err = clientv3.New(clientv3.Config{
			Endpoints:   b.etcdEndpoints,
			DialTimeout: b.etcdDialTimeout,
		})
		if err != nil {
			return err
		}
		b.cli = cli
	}
	// namespaced etcd :)
	b.cli.KV = namespace.NewKV(b.cli.KV, b.etcdPrefix)
	err = b.bootstrapLease()
	if err != nil {
		return err
	}

	if b.thisServer.Frontend {
		b.setupOnSessionCloseCB()
		b.setupOnAfterSessionBindCB()
	}

	return nil
}

// Shutdown executes on shutdown and will clean etcd
func (b *ETCDBindingStorage) Shutdown() error {
	close(b.stopChan)
	return b.cli.Close()
}

```

`pkg/modules/unique_session.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package modules

import (
	"context"

	"github.com/topfreegames/pitaya/v3/pkg/cluster"
	"github.com/topfreegames/pitaya/v3/pkg/session"
)

// UniqueSession module watches for sessions using the same UID and kicks them
type UniqueSession struct {
	Base
	server      *cluster.Server
	rpcClient   cluster.RPCClient
	sessionPool session.SessionPool
}

// NewUniqueSession creates a new unique session module
func NewUniqueSession(server *cluster.Server, rpcServer cluster.RPCServer, rpcClient cluster.RPCClient, sessionPool session.SessionPool) *UniqueSession {
	return &UniqueSession{
		server:      server,
		rpcClient:   rpcClient,
		sessionPool: sessionPool,
	}
}

// OnUserBind method should be called when a user binds a session in remote servers
func (u *UniqueSession) OnUserBind(uid, fid string) {
	if u.server.ID == fid {
		return
	}
	oldSession := u.sessionPool.GetSessionByUID(uid)
	if oldSession != nil {
		// TODO: it would be nice to set this correctly
		oldSession.Kick(context.Background())
	}
}

// Init initializes the module
func (u *UniqueSession) Init() error {
	u.sessionPool.OnSessionBind(func(ctx context.Context, s session.Session) error {
		oldSession := u.sessionPool.GetSessionByUID(s.UID())
		if oldSession != nil {
			return oldSession.Kick(ctx)
		}
		err := u.rpcClient.BroadcastSessionBind(s.UID())
		return err
	})
	return nil
}

```

`pkg/networkentity/mocks/networkentity.go`:

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/topfreegames/pitaya/v3/pkg/networkentity (interfaces: NetworkEntity)

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	net "net"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	protos "github.com/topfreegames/pitaya/v3/pkg/protos"
)

// MockNetworkEntity is a mock of NetworkEntity interface.
type MockNetworkEntity struct {
	ctrl     *gomock.Controller
	recorder *MockNetworkEntityMockRecorder
}

// MockNetworkEntityMockRecorder is the mock recorder for MockNetworkEntity.
type MockNetworkEntityMockRecorder struct {
	mock *MockNetworkEntity
}

// NewMockNetworkEntity creates a new mock instance.
func NewMockNetworkEntity(ctrl *gomock.Controller) *MockNetworkEntity {
	mock := &MockNetworkEntity{ctrl: ctrl}
	mock.recorder = &MockNetworkEntityMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNetworkEntity) EXPECT() *MockNetworkEntityMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockNetworkEntity) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockNetworkEntityMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockNetworkEntity)(nil).Close))
}

// Kick mocks base method.
func (m *MockNetworkEntity) Kick(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Kick", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Kick indicates an expected call of Kick.
func (mr *MockNetworkEntityMockRecorder) Kick(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Kick", reflect.TypeOf((*MockNetworkEntity)(nil).Kick), arg0)
}

// Push mocks base method.
func (m *MockNetworkEntity) Push(arg0 string, arg1 interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Push", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Push indicates an expected call of Push.
func (mr *MockNetworkEntityMockRecorder) Push(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Push", reflect.TypeOf((*MockNetworkEntity)(nil).Push), arg0, arg1)
}

// RemoteAddr mocks base method.
func (m *MockNetworkEntity) RemoteAddr() net.Addr {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoteAddr")
	ret0, _ := ret[0].(net.Addr)
	return ret0
}

// RemoteAddr indicates an expected call of RemoteAddr.
func (mr *MockNetworkEntityMockRecorder) RemoteAddr() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoteAddr", reflect.TypeOf((*MockNetworkEntity)(nil).RemoteAddr))
}

// ResponseMID mocks base method.
func (m *MockNetworkEntity) ResponseMID(arg0 context.Context, arg1 uint, arg2 interface{}, arg3 ...bool) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ResponseMID", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ResponseMID indicates an expected call of ResponseMID.
func (mr *MockNetworkEntityMockRecorder) ResponseMID(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResponseMID", reflect.TypeOf((*MockNetworkEntity)(nil).ResponseMID), varargs...)
}

// SendRequest mocks base method.
func (m *MockNetworkEntity) SendRequest(arg0 context.Context, arg1, arg2 string, arg3 interface{}) (*protos.Response, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendRequest", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(*protos.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SendRequest indicates an expected call of SendRequest.
func (mr *MockNetworkEntityMockRecorder) SendRequest(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendRequest", reflect.TypeOf((*MockNetworkEntity)(nil).SendRequest), arg0, arg1, arg2, arg3)
}

```

`pkg/networkentity/networkentity.go`:

```go
package networkentity

import (
	"context"
	"net"

	"github.com/topfreegames/pitaya/v3/pkg/protos"
)

// NetworkEntity represent low-level network instance
type NetworkEntity interface {
	Push(route string, v interface{}) error
	ResponseMID(ctx context.Context, mid uint, v interface{}, isError ...bool) error
	Close() error
	Kick(ctx context.Context) error
	RemoteAddr() net.Addr
	SendRequest(ctx context.Context, serverID, route string, v interface{}) (*protos.Response, error)
}

```

`pkg/pipeline/pipeline.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package pipeline

import (
	"context"

	"github.com/topfreegames/pitaya/v3/pkg/logger"
)

type (
	// HandlerTempl is a function that has the same signature as a handler and will
	// be called before or after handler methods
	HandlerTempl func(ctx context.Context, in interface{}) (c context.Context, out interface{}, err error)

	// AfterHandlerTempl is a function for the after handler, receives both the handler response
	// and the error returned
	AfterHandlerTempl func(ctx context.Context, out interface{}, err error) (interface{}, error)

	// Channel contains the functions to be called before the handler method is executed
	Channel struct {
		Handlers []HandlerTempl
	}

	// AfterChannel contains the functions to be called after the handler method is executed
	AfterChannel struct {
		Handlers []AfterHandlerTempl
	}

	// Hooks contains before and after channels
	Hooks struct {
		BeforeHandler *Channel
		AfterHandler  *AfterChannel
	}

	HandlerHooks struct {
		Hooks
	}

	RemoteHooks struct {
		Hooks
	}
)

// NewHandlerHooks ctor
func NewHandlerHooks() *HandlerHooks {
	return &HandlerHooks{
		Hooks: Hooks{
			BeforeHandler: NewChannel(),
			AfterHandler:  NewAfterChannel(),
		},
	}
}

// NewRemoteHooks ctor
func NewRemoteHooks() *RemoteHooks {
	return &RemoteHooks{
		Hooks: Hooks{
			BeforeHandler: NewChannel(),
			AfterHandler:  NewAfterChannel(),
		},
	}
}

// NewChannel ctor
func NewChannel() *Channel {
	return &Channel{Handlers: []HandlerTempl{}}
}

// NewAfterChannel ctor
func NewAfterChannel() *AfterChannel {
	return &AfterChannel{Handlers: []AfterHandlerTempl{}}
}

// ExecuteBeforePipeline calls registered handlers
func (p *Channel) ExecuteBeforePipeline(ctx context.Context, data interface{}) (context.Context, interface{}, error) {
	var err error
	res := data
	if len(p.Handlers) > 0 {
		for _, h := range p.Handlers {
			ctx, res, err = h(ctx, res)
			if err != nil {
				logger.Log.Debugf("pitaya/handler: broken pipeline: %s", err.Error())
				return ctx, res, err
			}
		}
	}
	return ctx, res, nil
}

// ExecuteAfterPipeline calls registered handlers
func (p *AfterChannel) ExecuteAfterPipeline(ctx context.Context, res interface{}, err error) (interface{}, error) {
	ret := res
	if len(p.Handlers) > 0 {
		for _, h := range p.Handlers {
			ret, err = h(ctx, ret, err)
		}
	}
	return ret, err
}

// PushFront should not be used after pitaya is running
func (p *Channel) PushFront(h HandlerTempl) {
	Handlers := make([]HandlerTempl, len(p.Handlers)+1)
	Handlers[0] = h
	copy(Handlers[1:], p.Handlers)
	p.Handlers = Handlers
}

// PushBack should not be used after pitaya is running
func (p *Channel) PushBack(h HandlerTempl) {
	p.Handlers = append(p.Handlers, h)
}

// Clear should not be used after pitaya is running
func (p *Channel) Clear() {
	p.Handlers = make([]HandlerTempl, 0)
}

// PushFront should not be used after pitaya is running
func (p *AfterChannel) PushFront(h AfterHandlerTempl) {
	Handlers := make([]AfterHandlerTempl, len(p.Handlers)+1)
	Handlers[0] = h
	copy(Handlers[1:], p.Handlers)
	p.Handlers = Handlers
}

// PushBack should not be used after pitaya is running
func (p *AfterChannel) PushBack(h AfterHandlerTempl) {
	p.Handlers = append(p.Handlers, h)
}

// Clear should not be used after pitaya is running
func (p *AfterChannel) Clear() {
	p.Handlers = make([]AfterHandlerTempl, 0)
}

```

`pkg/pipeline/pipeline_test.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package pipeline

import (
	"context"
	"errors"
	"testing"

	"github.com/stretchr/testify/assert"
)

var (
	handler1 = func(ctx context.Context, in interface{}) (context.Context, interface{}, error) {
		return ctx, in, errors.New("ohno")
	}
	handler2 = func(ctx context.Context, in interface{}) (context.Context, interface{}, error) {
		return ctx, nil, nil
	}
	p = &Channel{}
)

func TestPushFront(t *testing.T) {
	p.PushFront(handler1)
	p.PushFront(handler2)
	defer p.Clear()

	_, _, err := p.Handlers[0](nil, nil)
	assert.Nil(t, nil, err)
}

func TestPushBack(t *testing.T) {
	p.PushFront(handler1)
	p.PushBack(handler2)
	defer p.Clear()

	_, _, err := p.Handlers[0](nil, nil)
	assert.EqualError(t, errors.New("ohno"), err.Error())
}

func TestClear(t *testing.T) {
	p.PushFront(handler1)
	p.PushBack(handler2)
	assert.Len(t, p.Handlers, 2)
	p.Clear()
	assert.Len(t, p.Handlers, 0)
}

```

`pkg/protos/bind.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: bind.proto

package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type BindMsg struct {
	Uid                  string   `protobuf:"bytes,1,opt,name=uid" json:"uid,omitempty"`
	Fid                  string   `protobuf:"bytes,2,opt,name=fid" json:"fid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BindMsg) Reset()         { *m = BindMsg{} }
func (m *BindMsg) String() string { return proto.CompactTextString(m) }
func (*BindMsg) ProtoMessage()    {}
func (*BindMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_bind_9cf772af172ead7d, []int{0}
}
func (m *BindMsg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BindMsg.Unmarshal(m, b)
}
func (m *BindMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BindMsg.Marshal(b, m, deterministic)
}
func (dst *BindMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BindMsg.Merge(dst, src)
}
func (m *BindMsg) XXX_Size() int {
	return xxx_messageInfo_BindMsg.Size(m)
}
func (m *BindMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_BindMsg.DiscardUnknown(m)
}

var xxx_messageInfo_BindMsg proto.InternalMessageInfo

func (m *BindMsg) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *BindMsg) GetFid() string {
	if m != nil {
		return m.Fid
	}
	return ""
}

func init() {
	proto.RegisterType((*BindMsg)(nil), "protos.BindMsg")
}

func init() { proto.RegisterFile("bind.proto", fileDescriptor_bind_9cf772af172ead7d) }

var fileDescriptor_bind_9cf772af172ead7d = []byte{
	// 83 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x4a, 0xca, 0xcc, 0x4b,
	0xd1, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x03, 0x53, 0xc5, 0x4a, 0xba, 0x5c, 0xec, 0x4e,
	0x99, 0x79, 0x29, 0xbe, 0xc5, 0xe9, 0x42, 0x02, 0x5c, 0xcc, 0xa5, 0x99, 0x29, 0x12, 0x8c, 0x0a,
	0x8c, 0x1a, 0x9c, 0x41, 0x20, 0x26, 0x48, 0x24, 0x2d, 0x33, 0x45, 0x82, 0x09, 0x22, 0x92, 0x96,
	0x99, 0x92, 0x04, 0xd1, 0x66, 0x0c, 0x08, 0x00, 0x00, 0xff, 0xff, 0xce, 0x99, 0xf6, 0x32, 0x4b,
	0x00, 0x00, 0x00,
}

```

`pkg/protos/doc.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: doc.proto

package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Doc struct {
	Doc                  string   `protobuf:"bytes,1,opt,name=doc" json:"doc,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Doc) Reset()         { *m = Doc{} }
func (m *Doc) String() string { return proto.CompactTextString(m) }
func (*Doc) ProtoMessage()    {}
func (*Doc) Descriptor() ([]byte, []int) {
	return fileDescriptor_doc_ddb39afaa46ee6d6, []int{0}
}
func (m *Doc) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Doc.Unmarshal(m, b)
}
func (m *Doc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Doc.Marshal(b, m, deterministic)
}
func (dst *Doc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Doc.Merge(dst, src)
}
func (m *Doc) XXX_Size() int {
	return xxx_messageInfo_Doc.Size(m)
}
func (m *Doc) XXX_DiscardUnknown() {
	xxx_messageInfo_Doc.DiscardUnknown(m)
}

var xxx_messageInfo_Doc proto.InternalMessageInfo

func (m *Doc) GetDoc() string {
	if m != nil {
		return m.Doc
	}
	return ""
}

func init() {
	proto.RegisterType((*Doc)(nil), "protos.Doc")
}

func init() { proto.RegisterFile("doc.proto", fileDescriptor_doc_ddb39afaa46ee6d6) }

var fileDescriptor_doc_ddb39afaa46ee6d6 = []byte{
	// 66 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x4c, 0xc9, 0x4f, 0xd6,
	0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x03, 0x53, 0xc5, 0x4a, 0xe2, 0x5c, 0xcc, 0x2e, 0xf9,
	0xc9, 0x42, 0x02, 0x5c, 0xcc, 0x29, 0xf9, 0xc9, 0x12, 0x8c, 0x0a, 0x8c, 0x1a, 0x9c, 0x41, 0x20,
	0x66, 0x12, 0x44, 0x81, 0x31, 0x20, 0x00, 0x00, 0xff, 0xff, 0x98, 0xdb, 0x15, 0x9b, 0x34, 0x00,
	0x00, 0x00,
}

```

`pkg/protos/docmsg.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: docmsg.proto

package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type DocMsg struct {
	GetProtos            bool     `protobuf:"varint,1,opt,name=getProtos" json:"getProtos,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DocMsg) Reset()         { *m = DocMsg{} }
func (m *DocMsg) String() string { return proto.CompactTextString(m) }
func (*DocMsg) ProtoMessage()    {}
func (*DocMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_docmsg_6d699a2b0ab5525e, []int{0}
}
func (m *DocMsg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DocMsg.Unmarshal(m, b)
}
func (m *DocMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DocMsg.Marshal(b, m, deterministic)
}
func (dst *DocMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocMsg.Merge(dst, src)
}
func (m *DocMsg) XXX_Size() int {
	return xxx_messageInfo_DocMsg.Size(m)
}
func (m *DocMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_DocMsg.DiscardUnknown(m)
}

var xxx_messageInfo_DocMsg proto.InternalMessageInfo

func (m *DocMsg) GetGetProtos() bool {
	if m != nil {
		return m.GetProtos
	}
	return false
}

func init() {
	proto.RegisterType((*DocMsg)(nil), "protos.DocMsg")
}

func init() { proto.RegisterFile("docmsg.proto", fileDescriptor_docmsg_6d699a2b0ab5525e) }

var fileDescriptor_docmsg_6d699a2b0ab5525e = []byte{
	// 75 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x49, 0xc9, 0x4f, 0xce,
	0x2d, 0x4e, 0xd7, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x03, 0x53, 0xc5, 0x4a, 0x6a, 0x5c,
	0x6c, 0x2e, 0xf9, 0xc9, 0xbe, 0xc5, 0xe9, 0x42, 0x32, 0x5c, 0x9c, 0xe9, 0xa9, 0x25, 0x01, 0x60,
	0x61, 0x09, 0x46, 0x05, 0x46, 0x0d, 0x8e, 0x20, 0x84, 0x40, 0x12, 0x44, 0xbd, 0x31, 0x20, 0x00,
	0x00, 0xff, 0xff, 0x77, 0x5a, 0xd8, 0xbe, 0x46, 0x00, 0x00, 0x00,
}

```

`pkg/protos/error.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: error.proto

package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Error struct {
	Code                 string            `protobuf:"bytes,1,opt,name=code" json:"code,omitempty"`
	Msg                  string            `protobuf:"bytes,2,opt,name=msg" json:"msg,omitempty"`
	Metadata             map[string]string `protobuf:"bytes,3,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_error_ea2c1b3dd908475b, []int{0}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Error.Unmarshal(m, b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Error.Marshal(b, m, deterministic)
}
func (dst *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(dst, src)
}
func (m *Error) XXX_Size() int {
	return xxx_messageInfo_Error.Size(m)
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *Error) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *Error) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func init() {
	proto.RegisterType((*Error)(nil), "protos.Error")
	proto.RegisterMapType((map[string]string)(nil), "protos.Error.MetadataEntry")
}

func init() { proto.RegisterFile("error.proto", fileDescriptor_error_ea2c1b3dd908475b) }

var fileDescriptor_error_ea2c1b3dd908475b = []byte{
	// 153 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x4e, 0x2d, 0x2a, 0xca,
	0x2f, 0xd2, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x03, 0x53, 0xc5, 0x4a, 0x8b, 0x19, 0xb9,
	0x58, 0x5d, 0x41, 0xe2, 0x42, 0x42, 0x5c, 0x2c, 0xc9, 0xf9, 0x29, 0xa9, 0x12, 0x8c, 0x0a, 0x8c,
	0x1a, 0x9c, 0x41, 0x60, 0xb6, 0x90, 0x00, 0x17, 0x73, 0x6e, 0x71, 0xba, 0x04, 0x13, 0x58, 0x08,
	0xc4, 0x14, 0x32, 0xe7, 0xe2, 0xc8, 0x4d, 0x2d, 0x49, 0x4c, 0x49, 0x2c, 0x49, 0x94, 0x60, 0x56,
	0x60, 0xd6, 0xe0, 0x36, 0x92, 0x86, 0x98, 0x58, 0xac, 0x07, 0x36, 0x46, 0xcf, 0x17, 0x2a, 0xeb,
	0x9a, 0x57, 0x52, 0x54, 0x19, 0x04, 0x57, 0x2c, 0x65, 0xcd, 0xc5, 0x8b, 0x22, 0x05, 0x32, 0x3b,
	0x3b, 0xb5, 0x12, 0x6a, 0x1d, 0x88, 0x29, 0x24, 0xc2, 0xc5, 0x5a, 0x96, 0x98, 0x53, 0x9a, 0x0a,
	0xb5, 0x0f, 0xc2, 0xb1, 0x62, 0xb2, 0x60, 0x4c, 0x82, 0xb8, 0xd6, 0x18, 0x10, 0x00, 0x00, 0xff,
	0xff, 0xb9, 0xd5, 0x83, 0x89, 0xc3, 0x00, 0x00, 0x00,
}

```

`pkg/protos/kick.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: kick.proto

package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type KickMsg struct {
	UserId               string   `protobuf:"bytes,1,opt,name=userId" json:"userId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KickMsg) Reset()         { *m = KickMsg{} }
func (m *KickMsg) String() string { return proto.CompactTextString(m) }
func (*KickMsg) ProtoMessage()    {}
func (*KickMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_kick_71de7c6289e550fd, []int{0}
}
func (m *KickMsg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KickMsg.Unmarshal(m, b)
}
func (m *KickMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KickMsg.Marshal(b, m, deterministic)
}
func (dst *KickMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KickMsg.Merge(dst, src)
}
func (m *KickMsg) XXX_Size() int {
	return xxx_messageInfo_KickMsg.Size(m)
}
func (m *KickMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_KickMsg.DiscardUnknown(m)
}

var xxx_messageInfo_KickMsg proto.InternalMessageInfo

func (m *KickMsg) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

type KickAnswer struct {
	Kicked               bool     `protobuf:"varint,1,opt,name=kicked" json:"kicked,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KickAnswer) Reset()         { *m = KickAnswer{} }
func (m *KickAnswer) String() string { return proto.CompactTextString(m) }
func (*KickAnswer) ProtoMessage()    {}
func (*KickAnswer) Descriptor() ([]byte, []int) {
	return fileDescriptor_kick_71de7c6289e550fd, []int{1}
}
func (m *KickAnswer) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KickAnswer.Unmarshal(m, b)
}
func (m *KickAnswer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KickAnswer.Marshal(b, m, deterministic)
}
func (dst *KickAnswer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KickAnswer.Merge(dst, src)
}
func (m *KickAnswer) XXX_Size() int {
	return xxx_messageInfo_KickAnswer.Size(m)
}
func (m *KickAnswer) XXX_DiscardUnknown() {
	xxx_messageInfo_KickAnswer.DiscardUnknown(m)
}

var xxx_messageInfo_KickAnswer proto.InternalMessageInfo

func (m *KickAnswer) GetKicked() bool {
	if m != nil {
		return m.Kicked
	}
	return false
}

func init() {
	proto.RegisterType((*KickMsg)(nil), "protos.KickMsg")
	proto.RegisterType((*KickAnswer)(nil), "protos.KickAnswer")
}

func init() { proto.RegisterFile("kick.proto", fileDescriptor_kick_71de7c6289e550fd) }

var fileDescriptor_kick_71de7c6289e550fd = []byte{
	// 97 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0xca, 0xce, 0x4c, 0xce,
	0xd6, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x03, 0x53, 0xc5, 0x4a, 0x8a, 0x5c, 0xec, 0xde,
	0x99, 0xc9, 0xd9, 0xbe, 0xc5, 0xe9, 0x42, 0x62, 0x5c, 0x6c, 0xa5, 0xc5, 0xa9, 0x45, 0x9e, 0x29,
	0x12, 0x8c, 0x0a, 0x8c, 0x1a, 0x9c, 0x41, 0x50, 0x9e, 0x92, 0x0a, 0x17, 0x17, 0x48, 0x89, 0x63,
	0x5e, 0x71, 0x79, 0x6a, 0x11, 0x48, 0x15, 0xc8, 0x98, 0x54, 0x88, 0x2a, 0x8e, 0x20, 0x28, 0x2f,
	0x09, 0x62, 0xa0, 0x31, 0x20, 0x00, 0x00, 0xff, 0xff, 0x57, 0xec, 0x62, 0xe2, 0x65, 0x00, 0x00,
	0x00,
}

```

`pkg/protos/mocks/pitaya.go`:

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: protos/pitaya.pb.go

// Package mock_protos is a generated GoMock package.
package mocks

import (
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	protos "github.com/topfreegames/pitaya/v3/pkg/protos"
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// MockPitayaClient is a mock of PitayaClient interface.
type MockPitayaClient struct {
	ctrl     *gomock.Controller
	recorder *MockPitayaClientMockRecorder
}

// MockPitayaClientMockRecorder is the mock recorder for MockPitayaClient.
type MockPitayaClientMockRecorder struct {
	mock *MockPitayaClient
}

// NewMockPitayaClient creates a new mock instance.
func NewMockPitayaClient(ctrl *gomock.Controller) *MockPitayaClient {
	mock := &MockPitayaClient{ctrl: ctrl}
	mock.recorder = &MockPitayaClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPitayaClient) EXPECT() *MockPitayaClientMockRecorder {
	return m.recorder
}

// Call mocks base method.
func (m *MockPitayaClient) Call(ctx context.Context, in *protos.Request, opts ...grpc.CallOption) (*protos.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Call", varargs...)
	ret0, _ := ret[0].(*protos.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Call indicates an expected call of Call.
func (mr *MockPitayaClientMockRecorder) Call(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Call", reflect.TypeOf((*MockPitayaClient)(nil).Call), varargs...)
}

// KickUser mocks base method.
func (m *MockPitayaClient) KickUser(ctx context.Context, in *protos.KickMsg, opts ...grpc.CallOption) (*protos.KickAnswer, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "KickUser", varargs...)
	ret0, _ := ret[0].(*protos.KickAnswer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// KickUser indicates an expected call of KickUser.
func (mr *MockPitayaClientMockRecorder) KickUser(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "KickUser", reflect.TypeOf((*MockPitayaClient)(nil).KickUser), varargs...)
}

// PushToUser mocks base method.
func (m *MockPitayaClient) PushToUser(ctx context.Context, in *protos.Push, opts ...grpc.CallOption) (*protos.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PushToUser", varargs...)
	ret0, _ := ret[0].(*protos.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PushToUser indicates an expected call of PushToUser.
func (mr *MockPitayaClientMockRecorder) PushToUser(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PushToUser", reflect.TypeOf((*MockPitayaClient)(nil).PushToUser), varargs...)
}

// SessionBindRemote mocks base method.
func (m *MockPitayaClient) SessionBindRemote(ctx context.Context, in *protos.BindMsg, opts ...grpc.CallOption) (*protos.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SessionBindRemote", varargs...)
	ret0, _ := ret[0].(*protos.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SessionBindRemote indicates an expected call of SessionBindRemote.
func (mr *MockPitayaClientMockRecorder) SessionBindRemote(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SessionBindRemote", reflect.TypeOf((*MockPitayaClient)(nil).SessionBindRemote), varargs...)
}

// MockPitayaServer is a mock of PitayaServer interface.
type MockPitayaServer struct {
	ctrl     *gomock.Controller
	recorder *MockPitayaServerMockRecorder
}

// MockPitayaServerMockRecorder is the mock recorder for MockPitayaServer.
type MockPitayaServerMockRecorder struct {
	mock *MockPitayaServer
}

// NewMockPitayaServer creates a new mock instance.
func NewMockPitayaServer(ctrl *gomock.Controller) *MockPitayaServer {
	mock := &MockPitayaServer{ctrl: ctrl}
	mock.recorder = &MockPitayaServerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPitayaServer) EXPECT() *MockPitayaServerMockRecorder {
	return m.recorder
}

// Call mocks base method.
func (m *MockPitayaServer) Call(arg0 context.Context, arg1 *protos.Request) (*protos.Response, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Call", arg0, arg1)
	ret0, _ := ret[0].(*protos.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Call indicates an expected call of Call.
func (mr *MockPitayaServerMockRecorder) Call(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Call", reflect.TypeOf((*MockPitayaServer)(nil).Call), arg0, arg1)
}

// KickUser mocks base method.
func (m *MockPitayaServer) KickUser(arg0 context.Context, arg1 *protos.KickMsg) (*protos.KickAnswer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "KickUser", arg0, arg1)
	ret0, _ := ret[0].(*protos.KickAnswer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// KickUser indicates an expected call of KickUser.
func (mr *MockPitayaServerMockRecorder) KickUser(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "KickUser", reflect.TypeOf((*MockPitayaServer)(nil).KickUser), arg0, arg1)
}

// PushToUser mocks base method.
func (m *MockPitayaServer) PushToUser(arg0 context.Context, arg1 *protos.Push) (*protos.Response, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PushToUser", arg0, arg1)
	ret0, _ := ret[0].(*protos.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PushToUser indicates an expected call of PushToUser.
func (mr *MockPitayaServerMockRecorder) PushToUser(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PushToUser", reflect.TypeOf((*MockPitayaServer)(nil).PushToUser), arg0, arg1)
}

// SessionBindRemote mocks base method.
func (m *MockPitayaServer) SessionBindRemote(arg0 context.Context, arg1 *protos.BindMsg) (*protos.Response, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SessionBindRemote", arg0, arg1)
	ret0, _ := ret[0].(*protos.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SessionBindRemote indicates an expected call of SessionBindRemote.
func (mr *MockPitayaServerMockRecorder) SessionBindRemote(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SessionBindRemote", reflect.TypeOf((*MockPitayaServer)(nil).SessionBindRemote), arg0, arg1)
}

```

`pkg/protos/msg.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: msg.proto

package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type MsgType int32

const (
	MsgType_MsgRequest  MsgType = 0
	MsgType_MsgNotify   MsgType = 1
	MsgType_MsgResponse MsgType = 2
	MsgType_MsgPush     MsgType = 3
)

var MsgType_name = map[int32]string{
	0: "MsgRequest",
	1: "MsgNotify",
	2: "MsgResponse",
	3: "MsgPush",
}
var MsgType_value = map[string]int32{
	"MsgRequest":  0,
	"MsgNotify":   1,
	"MsgResponse": 2,
	"MsgPush":     3,
}

func (x MsgType) String() string {
	return proto.EnumName(MsgType_name, int32(x))
}
func (MsgType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_msg_40ab112f05d06c13, []int{0}
}

type Msg struct {
	Id                   uint64   `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	Route                string   `protobuf:"bytes,2,opt,name=route" json:"route,omitempty"`
	Data                 []byte   `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	Reply                string   `protobuf:"bytes,4,opt,name=reply" json:"reply,omitempty"`
	Type                 MsgType  `protobuf:"varint,5,opt,name=type,enum=protos.MsgType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Msg) Reset()         { *m = Msg{} }
func (m *Msg) String() string { return proto.CompactTextString(m) }
func (*Msg) ProtoMessage()    {}
func (*Msg) Descriptor() ([]byte, []int) {
	return fileDescriptor_msg_40ab112f05d06c13, []int{0}
}
func (m *Msg) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Msg.Unmarshal(m, b)
}
func (m *Msg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Msg.Marshal(b, m, deterministic)
}
func (dst *Msg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Msg.Merge(dst, src)
}
func (m *Msg) XXX_Size() int {
	return xxx_messageInfo_Msg.Size(m)
}
func (m *Msg) XXX_DiscardUnknown() {
	xxx_messageInfo_Msg.DiscardUnknown(m)
}

var xxx_messageInfo_Msg proto.InternalMessageInfo

func (m *Msg) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Msg) GetRoute() string {
	if m != nil {
		return m.Route
	}
	return ""
}

func (m *Msg) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Msg) GetReply() string {
	if m != nil {
		return m.Reply
	}
	return ""
}

func (m *Msg) GetType() MsgType {
	if m != nil {
		return m.Type
	}
	return MsgType_MsgRequest
}

func init() {
	proto.RegisterType((*Msg)(nil), "protos.Msg")
	proto.RegisterEnum("protos.MsgType", MsgType_name, MsgType_value)
}

func init() { proto.RegisterFile("msg.proto", fileDescriptor_msg_40ab112f05d06c13) }

var fileDescriptor_msg_40ab112f05d06c13 = []byte{
	// 196 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x2c, 0x8f, 0xc1, 0x4e, 0xc6, 0x20,
	0x0c, 0xc7, 0x85, 0xf1, 0x69, 0xd6, 0xe9, 0x46, 0x1a, 0x0f, 0x1c, 0x89, 0x5e, 0x88, 0x87, 0x1d,
	0xf4, 0x1d, 0xbc, 0x61, 0x0c, 0xf1, 0x05, 0x66, 0x86, 0xb8, 0x44, 0x05, 0x57, 0x76, 0xc0, 0xa7,
	0x37, 0x1f, 0xdb, 0xa9, 0xfd, 0xf7, 0xf7, 0x6b, 0x9a, 0x42, 0xfb, 0x4d, 0x61, 0x4c, 0x6b, 0xcc,
	0x11, 0x2f, 0x6b, 0xa1, 0xbb, 0x3f, 0x68, 0x2c, 0x05, 0xec, 0x81, 0x2f, 0xb3, 0x62, 0x9a, 0x19,
	0xe1, 0xf8, 0x32, 0xe3, 0x2d, 0x9c, 0xd6, 0xb8, 0x65, 0xaf, 0xb8, 0x66, 0xa6, 0x75, 0x7b, 0x40,
	0x04, 0x31, 0x4f, 0x79, 0x52, 0x8d, 0x66, 0xe6, 0xda, 0xd5, 0xbe, 0x9a, 0x3e, 0x7d, 0x15, 0x25,
	0x0e, 0xf3, 0x1c, 0xf0, 0x1e, 0x44, 0x2e, 0xc9, 0xab, 0x93, 0x66, 0xa6, 0x7f, 0x1c, 0xf6, 0xa3,
	0x34, 0x5a, 0x0a, 0x6f, 0x25, 0x79, 0x57, 0xe1, 0xc3, 0x33, 0x5c, 0x1d, 0x03, 0xec, 0x01, 0x2c,
	0x05, 0xe7, 0x7f, 0x37, 0x4f, 0x59, 0x5e, 0xe0, 0x0d, 0xb4, 0x96, 0xc2, 0x4b, 0xcc, 0xcb, 0x47,
	0x91, 0x0c, 0x07, 0xe8, 0x2a, 0xa6, 0x14, 0x7f, 0xc8, 0x4b, 0x8e, 0x5d, 0x5d, 0x7d, 0xdd, 0xe8,
	0x53, 0x36, 0xef, 0xfb, 0x2f, 0x4f, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0x8b, 0x95, 0xef, 0x13,
	0xdf, 0x00, 0x00, 0x00,
}

```

`pkg/protos/pitaya.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pitaya.proto

package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PitayaClient is the client API for Pitaya service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PitayaClient interface {
	Call(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	PushToUser(ctx context.Context, in *Push, opts ...grpc.CallOption) (*Response, error)
	SessionBindRemote(ctx context.Context, in *BindMsg, opts ...grpc.CallOption) (*Response, error)
	KickUser(ctx context.Context, in *KickMsg, opts ...grpc.CallOption) (*KickAnswer, error)
}

type pitayaClient struct {
	cc *grpc.ClientConn
}

func NewPitayaClient(cc *grpc.ClientConn) PitayaClient {
	return &pitayaClient{cc}
}

func (c *pitayaClient) Call(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/protos.Pitaya/Call", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pitayaClient) PushToUser(ctx context.Context, in *Push, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/protos.Pitaya/PushToUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pitayaClient) SessionBindRemote(ctx context.Context, in *BindMsg, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/protos.Pitaya/SessionBindRemote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pitayaClient) KickUser(ctx context.Context, in *KickMsg, opts ...grpc.CallOption) (*KickAnswer, error) {
	out := new(KickAnswer)
	err := c.cc.Invoke(ctx, "/protos.Pitaya/KickUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PitayaServer is the server API for Pitaya service.
type PitayaServer interface {
	Call(context.Context, *Request) (*Response, error)
	PushToUser(context.Context, *Push) (*Response, error)
	SessionBindRemote(context.Context, *BindMsg) (*Response, error)
	KickUser(context.Context, *KickMsg) (*KickAnswer, error)
}

func RegisterPitayaServer(s *grpc.Server, srv PitayaServer) {
	s.RegisterService(&_Pitaya_serviceDesc, srv)
}

func _Pitaya_Call_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PitayaServer).Call(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Pitaya/Call",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PitayaServer).Call(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pitaya_PushToUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Push)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PitayaServer).PushToUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Pitaya/PushToUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PitayaServer).PushToUser(ctx, req.(*Push))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pitaya_SessionBindRemote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BindMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PitayaServer).SessionBindRemote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Pitaya/SessionBindRemote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PitayaServer).SessionBindRemote(ctx, req.(*BindMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Pitaya_KickUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KickMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PitayaServer).KickUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Pitaya/KickUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PitayaServer).KickUser(ctx, req.(*KickMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Pitaya_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.Pitaya",
	HandlerType: (*PitayaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Call",
			Handler:    _Pitaya_Call_Handler,
		},
		{
			MethodName: "PushToUser",
			Handler:    _Pitaya_PushToUser_Handler,
		},
		{
			MethodName: "SessionBindRemote",
			Handler:    _Pitaya_SessionBindRemote_Handler,
		},
		{
			MethodName: "KickUser",
			Handler:    _Pitaya_KickUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pitaya.proto",
}

func init() { proto.RegisterFile("pitaya.proto", fileDescriptor_pitaya_c66f1da1c2593b20) }

var fileDescriptor_pitaya_c66f1da1c2593b20 = []byte{
	// 199 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x29, 0xc8, 0x2c, 0x49,
	0xac, 0x4c, 0xd4, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x03, 0x53, 0xc5, 0x52, 0xbc, 0x45,
	0xa9, 0x85, 0xa5, 0xa9, 0xc5, 0x25, 0x10, 0x61, 0x29, 0xbe, 0xa2, 0xd4, 0xe2, 0x82, 0xfc, 0xbc,
	0xe2, 0x54, 0x28, 0x9f, 0xab, 0xa0, 0xb4, 0x38, 0x03, 0xc6, 0x4e, 0xca, 0xcc, 0x4b, 0x81, 0xb1,
	0xb3, 0x33, 0x93, 0xb3, 0x21, 0x6c, 0xa3, 0x4b, 0x8c, 0x5c, 0x6c, 0x01, 0x60, 0xb3, 0x85, 0xb4,
	0xb9, 0x58, 0x9c, 0x13, 0x73, 0x72, 0x84, 0xf8, 0x21, 0x52, 0xc5, 0x7a, 0x41, 0x10, 0xd3, 0xa5,
	0x04, 0x10, 0x02, 0x10, 0xf3, 0x95, 0x18, 0x84, 0xf4, 0xb8, 0xb8, 0x02, 0x4a, 0x8b, 0x33, 0x42,
	0xf2, 0x43, 0x8b, 0x53, 0x8b, 0x84, 0x78, 0x60, 0x2a, 0x40, 0x62, 0x58, 0xd5, 0x5b, 0x70, 0x09,
	0x06, 0xa7, 0x16, 0x17, 0x67, 0xe6, 0xe7, 0x39, 0x65, 0xe6, 0xa5, 0x04, 0xa5, 0xe6, 0xe6, 0x97,
	0xa4, 0x22, 0x6c, 0x02, 0x89, 0xf9, 0x16, 0xa7, 0x63, 0xd5, 0x69, 0xc8, 0xc5, 0xe1, 0x9d, 0x99,
	0x9c, 0x0d, 0xb6, 0x07, 0xae, 0x01, 0x24, 0x02, 0xd2, 0x20, 0x84, 0x2c, 0xe0, 0x98, 0x57, 0x5c,
	0x9e, 0x5a, 0xa4, 0xc4, 0x90, 0x04, 0x09, 0x1f, 0x63, 0x40, 0x00, 0x00, 0x00, 0xff, 0xff, 0x70,
	0x0c, 0x65, 0x3c, 0x36, 0x01, 0x00, 0x00,
}

```

`pkg/protos/protodescriptor.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: protodescriptor.proto

package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Descriptor proto used to retrieve zipped proto descriptors remotely
type ProtoDescriptor struct {
	Desc                 []byte   `protobuf:"bytes,1,opt,name=desc,proto3" json:"desc,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProtoDescriptor) Reset()         { *m = ProtoDescriptor{} }
func (m *ProtoDescriptor) String() string { return proto.CompactTextString(m) }
func (*ProtoDescriptor) ProtoMessage()    {}
func (*ProtoDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_protodescriptor_d1dc0afa30ee5672, []int{0}
}
func (m *ProtoDescriptor) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProtoDescriptor.Unmarshal(m, b)
}
func (m *ProtoDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProtoDescriptor.Marshal(b, m, deterministic)
}
func (dst *ProtoDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoDescriptor.Merge(dst, src)
}
func (m *ProtoDescriptor) XXX_Size() int {
	return xxx_messageInfo_ProtoDescriptor.Size(m)
}
func (m *ProtoDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoDescriptor proto.InternalMessageInfo

func (m *ProtoDescriptor) GetDesc() []byte {
	if m != nil {
		return m.Desc
	}
	return nil
}

type ProtoName struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProtoName) Reset()         { *m = ProtoName{} }
func (m *ProtoName) String() string { return proto.CompactTextString(m) }
func (*ProtoName) ProtoMessage()    {}
func (*ProtoName) Descriptor() ([]byte, []int) {
	return fileDescriptor_protodescriptor_d1dc0afa30ee5672, []int{1}
}
func (m *ProtoName) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProtoName.Unmarshal(m, b)
}
func (m *ProtoName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProtoName.Marshal(b, m, deterministic)
}
func (dst *ProtoName) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoName.Merge(dst, src)
}
func (m *ProtoName) XXX_Size() int {
	return xxx_messageInfo_ProtoName.Size(m)
}
func (m *ProtoName) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoName.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoName proto.InternalMessageInfo

func (m *ProtoName) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ProtoDescriptors struct {
	Desc                 [][]byte `protobuf:"bytes,1,rep,name=desc,proto3" json:"desc,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProtoDescriptors) Reset()         { *m = ProtoDescriptors{} }
func (m *ProtoDescriptors) String() string { return proto.CompactTextString(m) }
func (*ProtoDescriptors) ProtoMessage()    {}
func (*ProtoDescriptors) Descriptor() ([]byte, []int) {
	return fileDescriptor_protodescriptor_d1dc0afa30ee5672, []int{2}
}
func (m *ProtoDescriptors) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProtoDescriptors.Unmarshal(m, b)
}
func (m *ProtoDescriptors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProtoDescriptors.Marshal(b, m, deterministic)
}
func (dst *ProtoDescriptors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoDescriptors.Merge(dst, src)
}
func (m *ProtoDescriptors) XXX_Size() int {
	return xxx_messageInfo_ProtoDescriptors.Size(m)
}
func (m *ProtoDescriptors) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoDescriptors.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoDescriptors proto.InternalMessageInfo

func (m *ProtoDescriptors) GetDesc() [][]byte {
	if m != nil {
		return m.Desc
	}
	return nil
}

type ProtoNames struct {
	Name                 []string `protobuf:"bytes,1,rep,name=name" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProtoNames) Reset()         { *m = ProtoNames{} }
func (m *ProtoNames) String() string { return proto.CompactTextString(m) }
func (*ProtoNames) ProtoMessage()    {}
func (*ProtoNames) Descriptor() ([]byte, []int) {
	return fileDescriptor_protodescriptor_d1dc0afa30ee5672, []int{3}
}
func (m *ProtoNames) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProtoNames.Unmarshal(m, b)
}
func (m *ProtoNames) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProtoNames.Marshal(b, m, deterministic)
}
func (dst *ProtoNames) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtoNames.Merge(dst, src)
}
func (m *ProtoNames) XXX_Size() int {
	return xxx_messageInfo_ProtoNames.Size(m)
}
func (m *ProtoNames) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtoNames.DiscardUnknown(m)
}

var xxx_messageInfo_ProtoNames proto.InternalMessageInfo

func (m *ProtoNames) GetName() []string {
	if m != nil {
		return m.Name
	}
	return nil
}

func init() {
	proto.RegisterType((*ProtoDescriptor)(nil), "protos.ProtoDescriptor")
	proto.RegisterType((*ProtoName)(nil), "protos.ProtoName")
	proto.RegisterType((*ProtoDescriptors)(nil), "protos.ProtoDescriptors")
	proto.RegisterType((*ProtoNames)(nil), "protos.ProtoNames")
}

func init() {
	proto.RegisterFile("protodescriptor.proto", fileDescriptor_protodescriptor_d1dc0afa30ee5672)
}

var fileDescriptor_protodescriptor_d1dc0afa30ee5672 = []byte{
	// 123 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x2d, 0x28, 0xca, 0x2f,
	0xc9, 0x4f, 0x49, 0x2d, 0x4e, 0x2e, 0xca, 0x2c, 0x28, 0xc9, 0x2f, 0xd2, 0x03, 0xf3, 0x85, 0xd8,
	0xc0, 0x54, 0xb1, 0x92, 0x2a, 0x17, 0x7f, 0x00, 0x88, 0xe5, 0x02, 0x57, 0x20, 0x24, 0xc4, 0xc5,
	0x02, 0x52, 0x2e, 0xc1, 0xa8, 0xc0, 0xa8, 0xc1, 0x13, 0x04, 0x66, 0x2b, 0xc9, 0x73, 0x71, 0x82,
	0x95, 0xf9, 0x25, 0xe6, 0xa6, 0x82, 0x14, 0xe4, 0x25, 0xe6, 0xa6, 0x82, 0x15, 0x70, 0x06, 0x81,
	0xd9, 0x4a, 0x6a, 0x5c, 0x02, 0x68, 0xe6, 0x14, 0x23, 0x19, 0xc4, 0x0c, 0x37, 0x48, 0x81, 0x8b,
	0x0b, 0x6e, 0x50, 0x31, 0x92, 0x49, 0xcc, 0x30, 0x93, 0x92, 0x20, 0x2e, 0x33, 0x06, 0x04, 0x00,
	0x00, 0xff, 0xff, 0x91, 0xb4, 0x22, 0x97, 0xb9, 0x00, 0x00, 0x00,
}

```

`pkg/protos/push.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: push.proto

package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Push struct {
	Route                string   `protobuf:"bytes,1,opt,name=route" json:"route,omitempty"`
	Uid                  string   `protobuf:"bytes,2,opt,name=uid" json:"uid,omitempty"`
	Data                 []byte   `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Push) Reset()         { *m = Push{} }
func (m *Push) String() string { return proto.CompactTextString(m) }
func (*Push) ProtoMessage()    {}
func (*Push) Descriptor() ([]byte, []int) {
	return fileDescriptor_push_77d28476f32095f7, []int{0}
}
func (m *Push) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Push.Unmarshal(m, b)
}
func (m *Push) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Push.Marshal(b, m, deterministic)
}
func (dst *Push) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Push.Merge(dst, src)
}
func (m *Push) XXX_Size() int {
	return xxx_messageInfo_Push.Size(m)
}
func (m *Push) XXX_DiscardUnknown() {
	xxx_messageInfo_Push.DiscardUnknown(m)
}

var xxx_messageInfo_Push proto.InternalMessageInfo

func (m *Push) GetRoute() string {
	if m != nil {
		return m.Route
	}
	return ""
}

func (m *Push) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *Push) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterType((*Push)(nil), "protos.Push")
}

func init() { proto.RegisterFile("push.proto", fileDescriptor_push_77d28476f32095f7) }

var fileDescriptor_push_77d28476f32095f7 = []byte{
	// 100 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x2a, 0x28, 0x2d, 0xce,
	0xd0, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x03, 0x53, 0xc5, 0x4a, 0x4e, 0x5c, 0x2c, 0x01,
	0xa5, 0xc5, 0x19, 0x42, 0x22, 0x5c, 0xac, 0x45, 0xf9, 0xa5, 0x25, 0xa9, 0x12, 0x8c, 0x0a, 0x8c,
	0x1a, 0x9c, 0x41, 0x10, 0x8e, 0x90, 0x00, 0x17, 0x73, 0x69, 0x66, 0x8a, 0x04, 0x13, 0x58, 0x0c,
	0xc4, 0x14, 0x12, 0xe2, 0x62, 0x49, 0x49, 0x2c, 0x49, 0x94, 0x60, 0x56, 0x60, 0xd4, 0xe0, 0x09,
	0x02, 0xb3, 0x93, 0x20, 0x66, 0x19, 0x03, 0x02, 0x00, 0x00, 0xff, 0xff, 0x41, 0x79, 0x42, 0xe3,
	0x60, 0x00, 0x00, 0x00,
}

```

`pkg/protos/request.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: request.proto

package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type RPCType int32

const (
	RPCType_Sys  RPCType = 0
	RPCType_User RPCType = 1
)

var RPCType_name = map[int32]string{
	0: "Sys",
	1: "User",
}
var RPCType_value = map[string]int32{
	"Sys":  0,
	"User": 1,
}

func (x RPCType) String() string {
	return proto.EnumName(RPCType_name, int32(x))
}
func (RPCType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_request_af3dbb976ee13f3b, []int{0}
}

type Request struct {
	Type                 RPCType  `protobuf:"varint,1,opt,name=type,enum=protos.RPCType" json:"type,omitempty"`
	Session              *Session `protobuf:"bytes,2,opt,name=session" json:"session,omitempty"`
	Msg                  *Msg     `protobuf:"bytes,3,opt,name=msg" json:"msg,omitempty"`
	FrontendID           string   `protobuf:"bytes,4,opt,name=frontendID" json:"frontendID,omitempty"`
	Metadata             []byte   `protobuf:"bytes,5,opt,name=metadata,proto3" json:"metadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_request_af3dbb976ee13f3b, []int{0}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Request.Unmarshal(m, b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Request.Marshal(b, m, deterministic)
}
func (dst *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(dst, src)
}
func (m *Request) XXX_Size() int {
	return xxx_messageInfo_Request.Size(m)
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetType() RPCType {
	if m != nil {
		return m.Type
	}
	return RPCType_Sys
}

func (m *Request) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *Request) GetMsg() *Msg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *Request) GetFrontendID() string {
	if m != nil {
		return m.FrontendID
	}
	return ""
}

func (m *Request) GetMetadata() []byte {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func init() {
	proto.RegisterType((*Request)(nil), "protos.Request")
	proto.RegisterEnum("protos.RPCType", RPCType_name, RPCType_value)
}

func init() { proto.RegisterFile("request.proto", fileDescriptor_request_af3dbb976ee13f3b) }

var fileDescriptor_request_af3dbb976ee13f3b = []byte{
	// 210 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x4c, 0x8f, 0xb1, 0x4e, 0x87, 0x30,
	0x10, 0x87, 0xad, 0xa0, 0xfd, 0x73, 0x88, 0x92, 0x9b, 0x1a, 0xa2, 0xa6, 0xd1, 0xa5, 0x3a, 0x30,
	0xe8, 0x23, 0xe8, 0xe2, 0x60, 0x62, 0x8a, 0x3e, 0x00, 0x86, 0x93, 0x38, 0x40, 0xb1, 0x57, 0x07,
	0xde, 0xcb, 0x07, 0x34, 0x52, 0x50, 0xa7, 0xf6, 0xbe, 0xdf, 0x77, 0x97, 0x3b, 0x28, 0x3c, 0x7d,
	0x7c, 0x12, 0x87, 0x7a, 0xf2, 0x2e, 0x38, 0x3c, 0x5c, 0x1e, 0xae, 0x0a, 0x26, 0xe6, 0x77, 0x37,
	0x46, 0x5c, 0x65, 0x03, 0xf7, 0xf1, 0x7b, 0xf1, 0x25, 0x40, 0xda, 0xd8, 0x83, 0x97, 0x90, 0x86,
	0x79, 0x22, 0x25, 0xb4, 0x30, 0xc7, 0x37, 0x27, 0xd1, 0xe0, 0xda, 0x3e, 0xdd, 0x3d, 0xcf, 0x13,
	0xd9, 0x25, 0xc4, 0x2b, 0x90, 0xeb, 0x30, 0xb5, 0xaf, 0x85, 0xc9, 0xff, 0xbc, 0x26, 0x62, 0xbb,
	0xe5, 0x78, 0x06, 0xc9, 0xc0, 0xbd, 0x4a, 0x16, 0x2d, 0xdf, 0xb4, 0x47, 0xee, 0xed, 0x0f, 0xc7,
	0x73, 0x80, 0x37, 0xef, 0xc6, 0x40, 0x63, 0xf7, 0x70, 0xaf, 0x52, 0x2d, 0x4c, 0x66, 0xff, 0x11,
	0xac, 0x60, 0x37, 0x50, 0x68, 0xbb, 0x36, 0xb4, 0xea, 0x40, 0x0b, 0x73, 0x64, 0x7f, 0xeb, 0xeb,
	0x53, 0x90, 0xeb, 0x5a, 0x28, 0x21, 0x69, 0x66, 0x2e, 0xf7, 0x70, 0x07, 0xe9, 0x0b, 0x93, 0x2f,
	0xc5, 0x6b, 0x3c, 0xfb, 0xf6, 0x3b, 0x00, 0x00, 0xff, 0xff, 0x1a, 0x3f, 0x60, 0xec, 0x0e, 0x01,
	0x00, 0x00,
}

```

`pkg/protos/response.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: response.proto

package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Response struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Error                *Error   `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_response_eb66de3736cab2fc, []int{0}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Response.Unmarshal(m, b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Response.Marshal(b, m, deterministic)
}
func (dst *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(dst, src)
}
func (m *Response) XXX_Size() int {
	return xxx_messageInfo_Response.Size(m)
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Response) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func init() {
	proto.RegisterType((*Response)(nil), "protos.Response")
}

func init() { proto.RegisterFile("response.proto", fileDescriptor_response_eb66de3736cab2fc) }

var fileDescriptor_response_eb66de3736cab2fc = []byte{
	// 105 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x2b, 0x4a, 0x2d, 0x2e,
	0xc8, 0xcf, 0x2b, 0x4e, 0xd5, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x03, 0x53, 0xc5, 0x52,
	0xdc, 0xa9, 0x45, 0x45, 0xf9, 0x45, 0x10, 0x41, 0x25, 0x67, 0x2e, 0x8e, 0x20, 0xa8, 0x32, 0x21,
	0x21, 0x2e, 0x96, 0x94, 0xc4, 0x92, 0x44, 0x09, 0x46, 0x05, 0x46, 0x0d, 0x9e, 0x20, 0x30, 0x5b,
	0x48, 0x99, 0x8b, 0x15, 0xac, 0x5c, 0x82, 0x49, 0x81, 0x51, 0x83, 0xdb, 0x88, 0x17, 0xa2, 0xad,
	0x58, 0xcf, 0x15, 0x24, 0x18, 0x04, 0x91, 0x4b, 0x82, 0x98, 0x6c, 0x0c, 0x08, 0x00, 0x00, 0xff,
	0xff, 0xfc, 0x95, 0xc0, 0x6b, 0x72, 0x00, 0x00, 0x00,
}

```

`pkg/protos/session.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: session.proto

package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Session struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	Uid                  string   `protobuf:"bytes,2,opt,name=uid" json:"uid,omitempty"`
	Data                 []byte   `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Session) Reset()         { *m = Session{} }
func (m *Session) String() string { return proto.CompactTextString(m) }
func (*Session) ProtoMessage()    {}
func (*Session) Descriptor() ([]byte, []int) {
	return fileDescriptor_session_4ab38c3ef8b6fd7a, []int{0}
}
func (m *Session) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Session.Unmarshal(m, b)
}
func (m *Session) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Session.Marshal(b, m, deterministic)
}
func (dst *Session) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Session.Merge(dst, src)
}
func (m *Session) XXX_Size() int {
	return xxx_messageInfo_Session.Size(m)
}
func (m *Session) XXX_DiscardUnknown() {
	xxx_messageInfo_Session.DiscardUnknown(m)
}

var xxx_messageInfo_Session proto.InternalMessageInfo

func (m *Session) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Session) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *Session) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterType((*Session)(nil), "protos.Session")
}

func init() { proto.RegisterFile("session.proto", fileDescriptor_session_4ab38c3ef8b6fd7a) }

var fileDescriptor_session_4ab38c3ef8b6fd7a = []byte{
	// 103 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x2d, 0x4e, 0x2d, 0x2e,
	0xce, 0xcc, 0xcf, 0xd3, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x03, 0x53, 0xc5, 0x4a, 0xf6,
	0x5c, 0xec, 0xc1, 0x10, 0x09, 0x21, 0x3e, 0x2e, 0xa6, 0xcc, 0x14, 0x09, 0x46, 0x05, 0x46, 0x0d,
	0xe6, 0x20, 0xa6, 0xcc, 0x14, 0x21, 0x01, 0x2e, 0xe6, 0xd2, 0xcc, 0x14, 0x09, 0x26, 0x05, 0x46,
	0x0d, 0xce, 0x20, 0x10, 0x53, 0x48, 0x88, 0x8b, 0x25, 0x25, 0xb1, 0x24, 0x51, 0x82, 0x59, 0x81,
	0x51, 0x83, 0x27, 0x08, 0xcc, 0x4e, 0x82, 0x18, 0x64, 0x0c, 0x08, 0x00, 0x00, 0xff, 0xff, 0x90,
	0x07, 0x5b, 0x46, 0x60, 0x00, 0x00, 0x00,
}

```

`pkg/protos/test/somestruct.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: somestruct.proto

package test

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type SomeStruct struct {
	A                    int32    `protobuf:"varint,1,opt,name=A" json:"A,omitempty"`
	B                    string   `protobuf:"bytes,2,opt,name=B" json:"B,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SomeStruct) Reset()         { *m = SomeStruct{} }
func (m *SomeStruct) String() string { return proto.CompactTextString(m) }
func (*SomeStruct) ProtoMessage()    {}
func (*SomeStruct) Descriptor() ([]byte, []int) {
	return fileDescriptor_somestruct_0b613b601297f11c, []int{0}
}
func (m *SomeStruct) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SomeStruct.Unmarshal(m, b)
}
func (m *SomeStruct) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SomeStruct.Marshal(b, m, deterministic)
}
func (dst *SomeStruct) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SomeStruct.Merge(dst, src)
}
func (m *SomeStruct) XXX_Size() int {
	return xxx_messageInfo_SomeStruct.Size(m)
}
func (m *SomeStruct) XXX_DiscardUnknown() {
	xxx_messageInfo_SomeStruct.DiscardUnknown(m)
}

var xxx_messageInfo_SomeStruct proto.InternalMessageInfo

func (m *SomeStruct) GetA() int32 {
	if m != nil {
		return m.A
	}
	return 0
}

func (m *SomeStruct) GetB() string {
	if m != nil {
		return m.B
	}
	return ""
}

func init() {
	proto.RegisterType((*SomeStruct)(nil), "test.SomeStruct")
}

func init() { proto.RegisterFile("somestruct.proto", fileDescriptor_somestruct_0b613b601297f11c) }

var fileDescriptor_somestruct_0b613b601297f11c = []byte{
	// 90 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x28, 0xce, 0xcf, 0x4d,
	0x2d, 0x2e, 0x29, 0x2a, 0x4d, 0x2e, 0xd1, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x29, 0x49,
	0x2d, 0x2e, 0x51, 0xd2, 0xe0, 0xe2, 0x0a, 0xce, 0xcf, 0x4d, 0x0d, 0x06, 0xcb, 0x08, 0xf1, 0x70,
	0x31, 0x3a, 0x4a, 0x30, 0x2a, 0x30, 0x6a, 0xb0, 0x06, 0x31, 0x3a, 0x82, 0x78, 0x4e, 0x12, 0x4c,
	0x0a, 0x8c, 0x1a, 0x9c, 0x41, 0x8c, 0x4e, 0x49, 0x6c, 0x60, 0x6d, 0xc6, 0x80, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x3d, 0x9b, 0x98, 0xe0, 0x4a, 0x00, 0x00, 0x00,
}

```

`pkg/protos/test/testrequest.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: testrequest.proto

package test

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type TestRequest struct {
	Msg                  string   `protobuf:"bytes,1,opt,name=msg" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestRequest) Reset()         { *m = TestRequest{} }
func (m *TestRequest) String() string { return proto.CompactTextString(m) }
func (*TestRequest) ProtoMessage()    {}
func (*TestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_testrequest_64ede5bd0b1b0648, []int{0}
}
func (m *TestRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TestRequest.Unmarshal(m, b)
}
func (m *TestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TestRequest.Marshal(b, m, deterministic)
}
func (dst *TestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestRequest.Merge(dst, src)
}
func (m *TestRequest) XXX_Size() int {
	return xxx_messageInfo_TestRequest.Size(m)
}
func (m *TestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TestRequest proto.InternalMessageInfo

func (m *TestRequest) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterType((*TestRequest)(nil), "test.TestRequest")
}

func init() { proto.RegisterFile("testrequest.proto", fileDescriptor_testrequest_64ede5bd0b1b0648) }

var fileDescriptor_testrequest_64ede5bd0b1b0648 = []byte{
	// 79 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x2c, 0x49, 0x2d, 0x2e,
	0x29, 0x4a, 0x2d, 0x2c, 0x4d, 0x2d, 0x2e, 0xd1, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x01,
	0x09, 0x29, 0xc9, 0x73, 0x71, 0x87, 0xa4, 0x16, 0x97, 0x04, 0x41, 0xa4, 0x84, 0x04, 0xb8, 0x98,
	0x73, 0x8b, 0xd3, 0x25, 0x18, 0x15, 0x18, 0x35, 0x38, 0x83, 0x40, 0xcc, 0x24, 0x36, 0xb0, 0x6a,
	0x63, 0x40, 0x00, 0x00, 0x00, 0xff, 0xff, 0x8e, 0xca, 0x49, 0xd7, 0x42, 0x00, 0x00, 0x00,
}

```

`pkg/protos/test/testresponse.pb.go`:

```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: testresponse.proto

package test

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type TestResponse struct {
	Code                 int32    `protobuf:"varint,1,opt,name=code" json:"code,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestResponse) Reset()         { *m = TestResponse{} }
func (m *TestResponse) String() string { return proto.CompactTextString(m) }
func (*TestResponse) ProtoMessage()    {}
func (*TestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_testresponse_54303195d9d8e908, []int{0}
}
func (m *TestResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TestResponse.Unmarshal(m, b)
}
func (m *TestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TestResponse.Marshal(b, m, deterministic)
}
func (dst *TestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestResponse.Merge(dst, src)
}
func (m *TestResponse) XXX_Size() int {
	return xxx_messageInfo_TestResponse.Size(m)
}
func (m *TestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TestResponse proto.InternalMessageInfo

func (m *TestResponse) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *TestResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterType((*TestResponse)(nil), "test.TestResponse")
}

func init() { proto.RegisterFile("testresponse.proto", fileDescriptor_testresponse_54303195d9d8e908) }

var fileDescriptor_testresponse_54303195d9d8e908 = []byte{
	// 96 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x2a, 0x49, 0x2d, 0x2e,
	0x29, 0x4a, 0x2d, 0x2e, 0xc8, 0xcf, 0x2b, 0x4e, 0xd5, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62,
	0x01, 0x89, 0x29, 0x99, 0x70, 0xf1, 0x84, 0xa4, 0x16, 0x97, 0x04, 0x41, 0xe5, 0x84, 0x84, 0xb8,
	0x58, 0x92, 0xf3, 0x53, 0x52, 0x25, 0x18, 0x15, 0x18, 0x35, 0x58, 0x83, 0xc0, 0x6c, 0x21, 0x01,
	0x2e, 0xe6, 0xdc, 0xe2, 0x74, 0x09, 0x26, 0x05, 0x46, 0x0d, 0xce, 0x20, 0x10, 0x33, 0x89, 0x0d,
	0x6c, 0x84, 0x31, 0x20, 0x00, 0x00, 0xff, 0xff, 0x6a, 0x18, 0xc0, 0x42, 0x58, 0x00, 0x00, 0x00,
}

```

`pkg/push.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package pitaya

import (
	"github.com/topfreegames/pitaya/v3/pkg/cluster"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/util"
)

// SendPushToUsers sends a message to the given list of users
func (app *App) SendPushToUsers(route string, v interface{}, uids []string, frontendType string) ([]string, error) {
	data, err := util.SerializeOrRaw(app.serializer, v)
	if err != nil {
		return uids, err
	}

	if !app.server.Frontend && frontendType == "" {
		return uids, constants.ErrFrontendTypeNotSpecified
	}

	var notPushedUids []string

	logger.Log.Debugf("Type=PushToUsers Route=%s, Data=%+v, SvType=%s, #Users=%d", route, v, frontendType, len(uids))

	for _, uid := range uids {
		if s := app.sessionPool.GetSessionByUID(uid); s != nil && app.server.Type == frontendType {
			if err := s.Push(route, data); err != nil {
				notPushedUids = append(notPushedUids, uid)
				logger.Log.Errorf("Session push message error, ID=%d, UID=%s, Error=%s",
					s.ID(), s.UID(), err.Error())
			}
		} else if app.rpcClient != nil {
			push := &protos.Push{
				Route: route,
				Uid:   uid,
				Data:  data,
			}
			if err = app.rpcClient.SendPush(uid, &cluster.Server{Type: frontendType}, push); err != nil {
				notPushedUids = append(notPushedUids, uid)
				logger.Log.Errorf("RPCClient send message error, UID=%s, SvType=%s, Error=%s", uid, frontendType, err.Error())
			}
		} else {
			notPushedUids = append(notPushedUids, uid)
		}
	}

	if len(notPushedUids) != 0 {
		return notPushedUids, constants.ErrPushingToUsers
	}

	return nil, nil
}

```

`pkg/push_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package pitaya

import (
	"errors"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	clustermocks "github.com/topfreegames/pitaya/v3/pkg/cluster/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	serializemocks "github.com/topfreegames/pitaya/v3/pkg/serialize/mocks"
	sessionmocks "github.com/topfreegames/pitaya/v3/pkg/session/mocks"
)

type someStruct struct {
	A int
}

func TestSendPushToUsersFailsIfErrSerializing(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockSerializer := serializemocks.NewMockSerializer(ctrl)

	config := config.NewDefaultPitayaConfig()
	builder := NewDefaultBuilder(true, "testtype", Cluster, map[string]string{}, *config)
	builder.Serializer = mockSerializer
	app := builder.Build()

	route := "some.route.bla"
	data := &someStruct{A: 10}
	uid := uuid.New().String()
	expectedErr := errors.New("serialize error")
	mockSerializer.EXPECT().Marshal(data).Return(nil, expectedErr)

	errArr, err := app.SendPushToUsers(route, data, []string{uid}, "test")
	assert.Equal(t, expectedErr, err)
	assert.Len(t, errArr, 1)
	assert.Equal(t, errArr[0], uid)
}

func TestSendToUsersLocalSession(t *testing.T) {
	tables := []struct {
		name string
		err  error
	}{
		{"successful_request", nil},
		{"failed_request", constants.ErrPushingToUsers},
	}
	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			route := "some.route.bla"
			data := []byte("hello")
			uid1 := uuid.New().String()
			uid2 := uuid.New().String()

			s1 := sessionmocks.NewMockSession(ctrl)
			s2 := sessionmocks.NewMockSession(ctrl)
			if table.err != nil {
				s1.EXPECT().ID().Times(1).Return(int64(1))
				s2.EXPECT().ID().Times(1).Return(int64(2))
				s1.EXPECT().UID().Times(1).Return(uid1)
				s2.EXPECT().UID().Times(1).Return(uid2)
			}
			s1.EXPECT().Push(route, data).Times(1).Return(table.err)
			s2.EXPECT().Push(route, data).Times(1).Return(table.err)

			mockSessionPool := sessionmocks.NewMockSessionPool(ctrl)
			mockSessionPool.EXPECT().GetSessionByUID(uid1).Return(s1).Times(1)
			mockSessionPool.EXPECT().GetSessionByUID(uid2).Return(s2).Times(1)

			config := config.NewDefaultPitayaConfig()
			builder := NewDefaultBuilder(true, "testtype", Standalone, map[string]string{}, *config)
			builder.SessionPool = mockSessionPool
			app := builder.Build().(*App)
			errArr, err := app.SendPushToUsers(route, data, []string{uid1, uid2}, app.server.Type)

			if table.err != nil {
				assert.Equal(t, err, table.err)
				assert.Len(t, errArr, 2)
			} else {
				assert.NoError(t, err)
				assert.Len(t, errArr, 0)
			}

		})
	}
}

func TestSendToUsersRemoteSession(t *testing.T) {
	tables := []struct {
		name string
		err  error
	}{
		{"successful_request", nil},
		{"failed_request", constants.ErrPushingToUsers},
	}
	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			route := "some.route.bla"
			data := []byte("hello")
			svType := "connector"
			uid1 := uuid.New().String()
			uid2 := uuid.New().String()

			expectedMsg1 := &protos.Push{
				Route: route,
				Uid:   uid1,
				Data:  data,
			}
			expectedMsg2 := &protos.Push{
				Route: route,
				Uid:   uid2,
				Data:  data,
			}
			mockRPCClient := clustermocks.NewMockRPCClient(ctrl)
			mockRPCClient.EXPECT().SendPush(uid1, gomock.Any(), expectedMsg1).Return(table.err)
			mockRPCClient.EXPECT().SendPush(uid2, gomock.Any(), expectedMsg2).Return(table.err)

			mockSessionPool := sessionmocks.NewMockSessionPool(ctrl)
			mockSessionPool.EXPECT().GetSessionByUID(uid1).Return(nil).Times(1)
			mockSessionPool.EXPECT().GetSessionByUID(uid2).Return(nil).Times(1)

			config := config.NewDefaultPitayaConfig()
			builder := NewDefaultBuilder(true, "testtype", Cluster, map[string]string{}, *config)
			builder.SessionPool = mockSessionPool
			builder.RPCClient = mockRPCClient
			app := builder.Build()

			errArr, err := app.SendPushToUsers(route, data, []string{uid1, uid2}, svType)
			if table.err != nil {
				assert.EqualError(t, err, table.err.Error())
				assert.Len(t, errArr, 2)
			} else {
				assert.NoError(t, err)
				assert.Nil(t, errArr)
			}
		})
	}
}

```

`pkg/remote/sys.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package remote

import (
	"context"

	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/session"
)

// Sys contains logic for handling sys remotes
type Sys struct {
	component.Base
	sessionPool session.SessionPool
}

// NewSys returns a new Sys instance
func NewSys(sessionPool session.SessionPool) *Sys {
	return &Sys{sessionPool: sessionPool}
}

// BindSession binds the local session
func (s *Sys) BindSession(ctx context.Context, sessionData *protos.Session) (*protos.Response, error) {
	sess := s.sessionPool.GetSessionByID(sessionData.Id)
	if sess == nil {
		return nil, constants.ErrSessionNotFound
	}
	if err := sess.Bind(ctx, sessionData.Uid); err != nil {
		return nil, err
	}
	return &protos.Response{Data: []byte("ack")}, nil
}

// PushSession updates the local session
func (s *Sys) PushSession(ctx context.Context, sessionData *protos.Session) (*protos.Response, error) {
	sess := s.sessionPool.GetSessionByID(sessionData.Id)
	if sess == nil {
		return nil, constants.ErrSessionNotFound
	}
	if err := sess.SetDataEncoded(sessionData.Data); err != nil {
		return nil, err
	}
	return &protos.Response{Data: []byte("ack")}, nil
}

// Kick kicks a local user
func (s *Sys) Kick(ctx context.Context, msg *protos.KickMsg) (*protos.KickAnswer, error) {
	res := &protos.KickAnswer{
		Kicked: false,
	}
	sess := s.sessionPool.GetSessionByUID(msg.GetUserId())
	if sess == nil {
		return res, constants.ErrSessionNotFound
	}
	err := sess.Kick(ctx)
	if err != nil {
		return res, err
	}
	res.Kicked = true
	return res, nil
}

```

`pkg/remote/sys_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package remote

import (
	"encoding/json"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/session/mocks"
)

func TestBindSession(t *testing.T) {
	t.Parallel()
	ctrl := gomock.NewController(t)
	id := int64(1)
	uid := uuid.New().String()
	d, err := json.Marshal(map[string]interface{}{
		"hello": "test",
	})
	assert.NoError(t, err)

	ss := mocks.NewMockSession(ctrl)

	sessionPool := mocks.NewMockSessionPool(ctrl)
	sessionPool.EXPECT().GetSessionByID(id).Return(ss).Times(1)

	s := NewSys(sessionPool)
	data := &protos.Session{
		Id:   id,
		Uid:  uid,
		Data: d,
	}

	ss.EXPECT().Bind(nil, uid).Times(1)

	res, err := s.BindSession(nil, data)
	assert.NoError(t, err)
	assert.Equal(t, []byte("ack"), res.Data)
}

func TestBindSessionShouldErrorIfNotExists(t *testing.T) {
	t.Parallel()
	ctrl := gomock.NewController(t)

	uid := uuid.New().String()
	d, err := json.Marshal(map[string]interface{}{
		"hello": "test",
	})
	assert.NoError(t, err)

	sessionPool := mocks.NewMockSessionPool(ctrl)
	sessionPool.EXPECT().GetSessionByID(gomock.Any()).Return(nil)

	s := NewSys(sessionPool)
	data := &protos.Session{
		Id:   133,
		Uid:  uid,
		Data: d,
	}
	_, err = s.BindSession(nil, data)
	assert.EqualError(t, constants.ErrSessionNotFound, err.Error())
}

func TestBindSessionShouldErrorIfAlreadyBound(t *testing.T) {
	t.Parallel()
	ctrl := gomock.NewController(t)

	id := int64(1)
	uid := uuid.New().String()
	d, err := json.Marshal(map[string]interface{}{
		"hello": "test",
	})
	assert.NoError(t, err)
	data := &protos.Session{
		Id:   id,
		Uid:  uid,
		Data: d,
	}

	ss := mocks.NewMockSession(ctrl)
	ss.EXPECT().ID().Return(id).Times(1)
	ss.EXPECT().Bind(nil, uid).Return(nil).Times(1)
	ss.EXPECT().Bind(nil, uid).Return(constants.ErrSessionAlreadyBound)

	sessionPool := mocks.NewMockSessionPool(ctrl)
	sessionPool.EXPECT().GetSessionByID(ss.ID()).Return(ss).Times(2)

	s := NewSys(sessionPool)
	res, err := s.BindSession(nil, data)
	assert.NoError(t, err)
	assert.Equal(t, []byte("ack"), res.Data)

	_, err = s.BindSession(nil, data)
	assert.EqualError(t, constants.ErrSessionAlreadyBound, err.Error())
}

func TestPushSession(t *testing.T) {
	t.Parallel()
	ctrl := gomock.NewController(t)

	id := int64(1)
	uid := uuid.New().String()
	d, err := json.Marshal(map[string]interface{}{
		"hello":   "test",
		"hello22": 2,
	})
	data := &protos.Session{
		Id:   id,
		Uid:  uid,
		Data: d,
	}
	assert.NoError(t, err)

	ss := mocks.NewMockSession(ctrl)
	ss.EXPECT().SetDataEncoded(d).Times(1)

	sessionPool := mocks.NewMockSessionPool(ctrl)
	sessionPool.EXPECT().GetSessionByID(id).Return(ss).Times(1)

	s := NewSys(sessionPool)
	res, err := s.PushSession(nil, data)
	assert.NoError(t, err)
	assert.Equal(t, []byte("ack"), res.Data)
}

func TestPushSessionShouldFailIfSessionDoesntExists(t *testing.T) {
	t.Parallel()
	ctrl := gomock.NewController(t)

	uid := uuid.New().String()
	d, err := json.Marshal(map[string]interface{}{
		"hello":   "test",
		"hello22": 2,
	})
	assert.NoError(t, err)
	data := &protos.Session{
		Id:   343,
		Uid:  uid,
		Data: d,
	}

	sessionPool := mocks.NewMockSessionPool(ctrl)
	sessionPool.EXPECT().GetSessionByID(data.Id).Return(nil).Times(1)

	s := NewSys(sessionPool)
	_, err = s.PushSession(nil, data)
	assert.EqualError(t, constants.ErrSessionNotFound, err.Error())
}

func TestKick(t *testing.T) {
	t.Parallel()
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	uid := uuid.New().String()

	ss := mocks.NewMockSession(ctrl)
	ss.EXPECT().Kick(nil).Return(nil)

	sessionPool := mocks.NewMockSessionPool(ctrl)
	sessionPool.EXPECT().GetSessionByUID(uid).Return(ss).Times(1)

	s := NewSys(sessionPool)

	res, err := s.Kick(nil, &protos.KickMsg{UserId: uid})
	assert.NoError(t, err)
	assert.True(t, res.Kicked)
}

func TestKickSessionShouldFailIfSessionDoesntExists(t *testing.T) {
	t.Parallel()
	ctrl := gomock.NewController(t)

	uid := uuid.New().String()
	sessionPool := mocks.NewMockSessionPool(ctrl)
	sessionPool.EXPECT().GetSessionByUID(uid).Return(nil).Times(1)

	s := NewSys(sessionPool)
	_, err := s.Kick(nil, &protos.KickMsg{UserId: uid})
	assert.EqualError(t, constants.ErrSessionNotFound, err.Error())
}

```

`pkg/reporters.go`:

```go
package pitaya

import (
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
	"github.com/topfreegames/pitaya/v3/pkg/metrics/models"
)

// CreatePrometheusReporter create a Prometheus reporter instance
func CreatePrometheusReporter(serverType string, config config.MetricsConfig, customSpecs models.CustomMetricsSpec) (*metrics.PrometheusReporter, error) {
	logger.Log.Infof("prometheus is enabled, configuring reporter on port %d", config.Prometheus.Port)
	prometheus, err := metrics.GetPrometheusReporter(serverType, config, customSpecs)
	if err != nil {
		logger.Log.Errorf("failed to start prometheus metrics reporter, skipping %v", err)
	}
	return prometheus, err
}

// CreateStatsdReporter create a Statsd reporter instance
func CreateStatsdReporter(serverType string, config config.MetricsConfig) (*metrics.StatsdReporter, error) {
	logger.Log.Infof(
		"statsd is enabled, configuring the metrics reporter with host: %s",
		config.Statsd.Host,
	)
	metricsReporter, err := metrics.NewStatsdReporter(
		config,
		serverType,
	)
	if err != nil {
		logger.Log.Errorf("failed to start statds metrics reporter, skipping %v", err)
	}
	return metricsReporter, err
}

```

`pkg/route/route.go`:

```go
// Copyright (c) TFG Co and nano Authors. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package route

import (
	"errors"
	"fmt"
	"strings"

	"github.com/topfreegames/pitaya/v3/pkg/logger"
)

var (
	// ErrRouteFieldCantEmpty error
	ErrRouteFieldCantEmpty = errors.New("route field can not be empty")
	// ErrInvalidRoute error
	ErrInvalidRoute = errors.New("invalid route")
)

// Route struct
type Route struct {
	SvType  string
	Service string
	Method  string
}

// NewRoute creates a new route
func NewRoute(server, service, method string) *Route {
	return &Route{server, service, method}
}

// String transforms the route into a string
func (r *Route) String() string {
	if r.SvType != "" {
		return fmt.Sprintf("%s.%s.%s", r.SvType, r.Service, r.Method)
	}
	return r.Short()
}

// Short transforms the route into a string without the server type
func (r *Route) Short() string {
	return fmt.Sprintf("%s.%s", r.Service, r.Method)
}

// Decode decodes the route
func Decode(route string) (*Route, error) {
	r := strings.Split(route, ".")
	for _, s := range r {
		if strings.TrimSpace(s) == "" {
			return nil, ErrRouteFieldCantEmpty
		}
	}
	switch len(r) {
	case 3:
		return NewRoute(r[0], r[1], r[2]), nil
	case 2:
		return NewRoute("", r[0], r[1]), nil
	default:
		logger.Log.Errorf("invalid route: " + route)
		return nil, ErrInvalidRoute
	}
}

```

`pkg/route/route_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package route

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

var tables = []struct {
	server   string
	service  string
	method   string
	outStr   string
	shortStr string
}{
	{"someserver", "someservice", "somemethod", "someserver.someservice.somemethod", "someservice.somemethod"},
	{"", "someservice", "somemethod", "someservice.somemethod", "someservice.somemethod"},
}

func TestNewRoute(t *testing.T) {
	t.Parallel()
	for _, table := range tables {
		t.Run(table.outStr, func(t *testing.T) {
			r := NewRoute(table.server, table.service, table.method)
			assert.NotNil(t, r)
			assert.Equal(t, table.server, r.SvType)
			assert.Equal(t, table.service, r.Service)
			assert.Equal(t, table.method, r.Method)
		})
	}
}

func TestString(t *testing.T) {
	t.Parallel()
	for _, table := range tables {
		t.Run(table.outStr, func(t *testing.T) {
			r := NewRoute(table.server, table.service, table.method)
			assert.Equal(t, table.outStr, r.String())
		})
	}
}

func TestShort(t *testing.T) {
	t.Parallel()
	for _, table := range tables {
		t.Run(table.outStr, func(t *testing.T) {
			r := NewRoute(table.server, table.service, table.method)
			assert.Equal(t, table.shortStr, r.Short())
		})
	}
}

func TestDecode(t *testing.T) {
	t.Parallel()
	dTables := []struct {
		route   string
		server  string
		service string
		method  string
		invalid error
	}{
		{"sv.some.method", "sv", "some", "method", nil},
		{"some.method", "", "some", "method", nil},
		{"invalid", "", "some", "method", ErrInvalidRoute},
		{"invalidstr..invalidmethod", "", "some", "method", ErrRouteFieldCantEmpty},
	}

	for _, table := range dTables {
		t.Run(table.route, func(t *testing.T) {
			r, err := Decode(table.route)
			if table.invalid == nil {
				assert.Equal(t, table.server, r.SvType)
				assert.Equal(t, table.service, r.Service)
				assert.Equal(t, table.method, r.Method)
			} else {
				assert.EqualError(t, err, table.invalid.Error())
			}
		})
	}
}

```

`pkg/router/router.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package router

import (
	"context"
	"math/rand"
	"time"

	"github.com/topfreegames/pitaya/v3/pkg/cluster"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/route"
)

// Router struct
type Router struct {
	serviceDiscovery cluster.ServiceDiscovery
	routesMap        map[string]RoutingFunc
}

// RoutingFunc defines a routing function
type RoutingFunc func(
	ctx context.Context,
	route *route.Route,
	payload []byte,
	servers map[string]*cluster.Server,
) (*cluster.Server, error)

// New returns the router
func New() *Router {
	return &Router{
		routesMap: make(map[string]RoutingFunc),
	}
}

// SetServiceDiscovery sets the sd client
func (r *Router) SetServiceDiscovery(sd cluster.ServiceDiscovery) {
	r.serviceDiscovery = sd
}

func (r *Router) defaultRoute(
	servers map[string]*cluster.Server,
) *cluster.Server {
	srvList := make([]*cluster.Server, 0)
	s := rand.NewSource(time.Now().Unix())
	rnd := rand.New(s)
	for _, v := range servers {
		srvList = append(srvList, v)
	}
	server := srvList[rnd.Intn(len(srvList))]
	return server
}

// Route gets the right server to use in the call
func (r *Router) Route(
	ctx context.Context,
	rpcType protos.RPCType,
	svType string,
	route *route.Route,
	msg *message.Message,
) (*cluster.Server, error) {
	if r.serviceDiscovery == nil {
		return nil, constants.ErrServiceDiscoveryNotInitialized
	}
	serversOfType, err := r.serviceDiscovery.GetServersByType(svType)
	if err != nil {
		return nil, err
	}
	if rpcType == protos.RPCType_User {
		server := r.defaultRoute(serversOfType)
		return server, nil
	}
	routeFunc, ok := r.routesMap[svType]
	if !ok {
		logger.Log.Debugf("no specific route for svType: %s, using default route", svType)
		server := r.defaultRoute(serversOfType)
		return server, nil
	}
	return routeFunc(ctx, route, msg.Data, serversOfType)
}

// AddRoute adds a routing function to a server type
func (r *Router) AddRoute(
	serverType string,
	routingFunction RoutingFunc,
) {
	if _, ok := r.routesMap[serverType]; ok {
		logger.Log.Warnf("overriding the route to svType %s", serverType)
	}
	r.routesMap[serverType] = routingFunction
}

```

`pkg/router/router_test.go`:

```go
package router

import (
	"context"
	"errors"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/cluster"
	"github.com/topfreegames/pitaya/v3/pkg/cluster/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/route"
)

var (
	serverID   = "id"
	serverType = "serverType"
	frontend   = true
	server     = cluster.NewServer(serverID, serverType, frontend)
	servers    = map[string]*cluster.Server{
		serverID: server,
	}

	routingFunction = func(
		ctx context.Context,
		route *route.Route,
		payload []byte,
		servers map[string]*cluster.Server,
	) (*cluster.Server, error) {
		return server, nil
	}
)

var routerTables = map[string]struct {
	server     *cluster.Server
	serverType string
	rpcType    protos.RPCType
	err        error
}{
	"test_server_has_route_func":   {server, serverType, protos.RPCType_Sys, nil},
	"test_server_use_default_func": {server, "notRegisteredType", protos.RPCType_Sys, nil},
	"test_user_use_default_func":   {server, serverType, protos.RPCType_User, nil},
	"test_error_on_service_disc":   {nil, serverType, protos.RPCType_Sys, errors.New("sd error")},
}

var addRouteRouterTables = map[string]struct {
	serverType string
}{
	"test_overrige_server_type": {serverType},
	"test_new_server_type":      {"notRegisteredType"},
}

func TestNew(t *testing.T) {
	t.Parallel()
	router := New()
	assert.NotNil(t, router)
}

func TestDefaultRoute(t *testing.T) {
	t.Parallel()

	router := New()

	retServer := router.defaultRoute(servers)
	assert.Equal(t, server, retServer)
}

func TestRoute(t *testing.T) {
	t.Parallel()

	ctx := context.Background()
	route := route.NewRoute(serverType, "service", "method")

	for name, table := range routerTables {
		t.Run(name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			mockServiceDiscovery := mocks.NewMockServiceDiscovery(ctrl)
			mockServiceDiscovery.EXPECT().
				GetServersByType(table.serverType).
				Return(servers, table.err)

			router := New()
			router.AddRoute(serverType, routingFunction)
			router.SetServiceDiscovery(mockServiceDiscovery)

			retServer, err := router.Route(ctx, table.rpcType, table.serverType, route, &message.Message{
				Data: []byte{0x01},
			})
			assert.Equal(t, table.server, retServer)
			assert.Equal(t, table.err, err)
		})
	}
}

func TestAddRoute(t *testing.T) {
	t.Parallel()

	for name, table := range addRouteRouterTables {
		t.Run(name, func(t *testing.T) {
			router := New()
			router.AddRoute(table.serverType, routingFunction)

			assert.NotNil(t, router.routesMap[table.serverType])
			assert.Nil(t, router.routesMap["anotherServerType"])
		})
	}
}

func TestRouteFailIfNullServiceDiscovery(t *testing.T) {
	t.Parallel()

	router := New()
	_, err := router.Route(context.Background(), protos.RPCType_Sys, serverType, route.NewRoute(serverType, "service", "method"), &message.Message{
		Data: []byte{0x01},
	})
	assert.Equal(t, constants.ErrServiceDiscoveryNotInitialized, err)
}

```

`pkg/rpc.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package pitaya

import (
	"context"
	"reflect"

	"github.com/golang/protobuf/proto"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/route"
)

// RPC calls a method in a different server
func (app *App) RPC(ctx context.Context, routeStr string, reply proto.Message, arg proto.Message) error {
	return app.doSendRPC(ctx, "", routeStr, reply, arg)
}

// RPCTo send a rpc to a specific server
func (app *App) RPCTo(ctx context.Context, serverID, routeStr string, reply proto.Message, arg proto.Message) error {
	return app.doSendRPC(ctx, serverID, routeStr, reply, arg)
}

// ReliableRPC enqueues RPC to worker so it's executed asynchronously
// Default enqueue options are used
func (app *App) ReliableRPC(
	routeStr string,
	metadata map[string]interface{},
	reply, arg proto.Message,
) (jid string, err error) {
	return app.worker.EnqueueRPC(routeStr, metadata, reply, arg)
}

// ReliableRPCWithOptions enqueues RPC to worker
// Receive worker options for this specific RPC
func (app *App) ReliableRPCWithOptions(
	routeStr string,
	metadata map[string]interface{},
	reply, arg proto.Message,
	opts *config.EnqueueOpts,
) (jid string, err error) {
	return app.worker.EnqueueRPCWithOptions(routeStr, metadata, reply, arg, opts)
}

func (app *App) doSendRPC(ctx context.Context, serverID, routeStr string, reply proto.Message, arg proto.Message) error {
	if app.rpcServer == nil {
		return constants.ErrRPCServerNotInitialized
	}

	if reflect.TypeOf(reply).Kind() != reflect.Ptr {
		return constants.ErrReplyShouldBePtr
	}

	r, err := route.Decode(routeStr)
	if err != nil {
		return err
	}

	if r.SvType == "" {
		return constants.ErrNoServerTypeChosenForRPC
	}

	if (r.SvType == app.server.Type && serverID == "") || serverID == app.server.ID {
		return constants.ErrNonsenseRPC
	}

	return app.remoteService.RPC(ctx, serverID, r, reply, arg)
}

```

`pkg/rpc_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package pitaya

import (
	"context"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/golang/protobuf/proto"
	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/cluster"
	clustermocks "github.com/topfreegames/pitaya/v3/pkg/cluster/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/conn/codec"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/pipeline"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/protos/test"
	"github.com/topfreegames/pitaya/v3/pkg/route"
	"github.com/topfreegames/pitaya/v3/pkg/router"
	serializemocks "github.com/topfreegames/pitaya/v3/pkg/serialize/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/service"
	sessionmocks "github.com/topfreegames/pitaya/v3/pkg/session/mocks"
)

func TestDoSendRPCNotInitialized(t *testing.T) {
	config := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Standalone, map[string]string{}, *config).(*App)
	err := app.doSendRPC(nil, "", "", nil, nil)
	assert.Equal(t, constants.ErrRPCServerNotInitialized, err)
}

func TestDoSendRPC(t *testing.T) {
	config := config.NewDefaultPitayaConfig()
	app := NewDefaultApp(true, "testtype", Cluster, map[string]string{}, *config).(*App)
	app.server.ID = "myserver"
	app.rpcServer = &cluster.NatsRPCServer{}
	tables := []struct {
		name     string
		routeStr string
		reply    proto.Message
		arg      proto.Message
		err      error
	}{
		{"bad_route", "badroute", &test.SomeStruct{}, nil, route.ErrInvalidRoute},
		{"no_server_type", "bla.bla", &test.SomeStruct{}, nil, constants.ErrNoServerTypeChosenForRPC},
		{"nonsense_rpc", "mytype.bla.bla", &test.SomeStruct{}, nil, constants.ErrNonsenseRPC},
		{"success", "bla.bla.bla", &test.SomeStruct{}, &test.SomeStruct{A: 1}, nil},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctx := context.Background()
			if table.err == nil {
				packetEncoder := codec.NewPomeloPacketEncoder()
				ctrl := gomock.NewController(t)
				defer ctrl.Finish()
				mockSerializer := serializemocks.NewMockSerializer(ctrl)
				mockSD := clustermocks.NewMockServiceDiscovery(ctrl)
				mockRPCClient := clustermocks.NewMockRPCClient(ctrl)
				mockRPCServer := clustermocks.NewMockRPCServer(ctrl)
				messageEncoder := message.NewMessagesEncoder(false)
				sessionPool := sessionmocks.NewMockSessionPool(ctrl)
				router := router.New()
				handlerPool := service.NewHandlerPool()
				svc := service.NewRemoteService(mockRPCClient, mockRPCServer, mockSD, packetEncoder, mockSerializer, router, messageEncoder, &cluster.Server{}, sessionPool, pipeline.NewRemoteHooks(), pipeline.NewHandlerHooks(), handlerPool)
				assert.NotNil(t, svc)
				app.remoteService = svc
				app.server.ID = "notmyserver"
				b, err := proto.Marshal(&test.SomeStruct{A: 1})
				assert.NoError(t, err)
				mockSD.EXPECT().GetServer("myserver").Return(&cluster.Server{}, nil)
				mockRPCClient.EXPECT().Call(ctx, protos.RPCType_User, gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(&protos.Response{Data: b}, nil)
			}
			err := app.RPCTo(ctx, "myserver", table.routeStr, table.reply, table.arg)
			assert.Equal(t, table.err, err)
		})
	}
}

```

`pkg/serialize/json/json.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package json

import (
	"encoding/json"
)

// Serializer implements the serialize.Serializer interface
type Serializer struct{}

// NewSerializer returns a new Serializer.
func NewSerializer() *Serializer {
	return &Serializer{}
}

// Marshal returns the JSON encoding of v.
func (s *Serializer) Marshal(v interface{}) ([]byte, error) {
	return json.Marshal(v)
}

// Unmarshal parses the JSON-encoded data and stores the result
// in the value pointed to by v.
func (s *Serializer) Unmarshal(data []byte, v interface{}) error {
	return json.Unmarshal(data, v)
}

// GetName returns the name of the serializer.
func (s *Serializer) GetName() string {
	return "json"
}

```

`pkg/serialize/json/json_test.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package json

import (
	"encoding/json"
	"math"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestNewSerializer(t *testing.T) {
	t.Parallel()

	serializer := NewSerializer()

	assert.NotNil(t, serializer)
}

func TestMarshal(t *testing.T) {
	t.Parallel()

	type MyStruct struct {
		Str    string
		Number float64
	}
	var marshalTables = map[string]struct {
		raw       interface{}
		marshaled []byte
		errType   interface{}
	}{
		"test_ok": {
			&MyStruct{Str: "hello", Number: 42},
			[]byte(`{"Str":"hello","Number":42}`),
			nil,
		},
		"test_nok": {
			&MyStruct{Number: math.Inf(1)},
			nil,
			&json.UnsupportedValueError{},
		},
	}
	serializer := NewSerializer()

	for name, table := range marshalTables {
		t.Run(name, func(t *testing.T) {
			result, err := serializer.Marshal(table.raw)

			assert.Equal(t, table.marshaled, result)
			if table.errType == nil {
				assert.NoError(t, err)
			} else {
				assert.IsType(t, table.errType, err)
			}
		})
	}
}

func TestUnmarshal(t *testing.T) {
	t.Parallel()

	type MyStruct struct {
		Str    string
		Number int
	}
	var unmarshalTables = map[string]struct {
		data        []byte
		unmarshaled *MyStruct
		errType     interface{}
	}{
		"test_ok": {
			[]byte(`{"Str":"hello","Number":42}`),
			&MyStruct{Str: "hello", Number: 42},
			nil,
		},
		"test_nok": {
			[]byte(`invalid`),
			nil,
			&json.SyntaxError{},
		},
	}
	serializer := NewSerializer()

	for name, table := range unmarshalTables {
		t.Run(name, func(t *testing.T) {
			var result MyStruct
			err := serializer.Unmarshal(table.data, &result)
			if table.errType == nil {
				assert.NoError(t, err)
				assert.Equal(t, table.unmarshaled, &result)
			} else {
				assert.Empty(t, &result)
				assert.IsType(t, table.errType, err)
			}
		})
	}
}

```

`pkg/serialize/mocks/serializer.go`:

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/topfreegames/pitaya/v3/pkg/serialize (interfaces: Serializer)

// Package mocks is a generated GoMock package.
package mocks

import (
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
)

// MockSerializer is a mock of Serializer interface.
type MockSerializer struct {
	ctrl     *gomock.Controller
	recorder *MockSerializerMockRecorder
}

// MockSerializerMockRecorder is the mock recorder for MockSerializer.
type MockSerializerMockRecorder struct {
	mock *MockSerializer
}

// NewMockSerializer creates a new mock instance.
func NewMockSerializer(ctrl *gomock.Controller) *MockSerializer {
	mock := &MockSerializer{ctrl: ctrl}
	mock.recorder = &MockSerializerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSerializer) EXPECT() *MockSerializerMockRecorder {
	return m.recorder
}

// GetName mocks base method.
func (m *MockSerializer) GetName() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetName")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetName indicates an expected call of GetName.
func (mr *MockSerializerMockRecorder) GetName() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetName", reflect.TypeOf((*MockSerializer)(nil).GetName))
}

// Marshal mocks base method.
func (m *MockSerializer) Marshal(arg0 interface{}) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Marshal", arg0)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Marshal indicates an expected call of Marshal.
func (mr *MockSerializerMockRecorder) Marshal(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Marshal", reflect.TypeOf((*MockSerializer)(nil).Marshal), arg0)
}

// Unmarshal mocks base method.
func (m *MockSerializer) Unmarshal(arg0 []byte, arg1 interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unmarshal", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Unmarshal indicates an expected call of Unmarshal.
func (mr *MockSerializerMockRecorder) Unmarshal(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unmarshal", reflect.TypeOf((*MockSerializer)(nil).Unmarshal), arg0, arg1)
}

```

`pkg/serialize/protobuf/fixtures/TestMarshal/test_ok.golden`:

```golden

dataerror
```

`pkg/serialize/protobuf/protobuf.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package protobuf

import (
	"github.com/golang/protobuf/proto"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
)

// Serializer implements the serialize.Serializer interface
type Serializer struct{}

// NewSerializer returns a new Serializer.
func NewSerializer() *Serializer {
	return &Serializer{}
}

// Marshal returns the protobuf encoding of v.
func (s *Serializer) Marshal(v interface{}) ([]byte, error) {
	pb, ok := v.(proto.Message)
	if !ok {
		return nil, constants.ErrWrongValueType
	}
	return proto.Marshal(pb)
}

// Unmarshal parses the protobuf-encoded data and stores the result
// in the value pointed to by v.
func (s *Serializer) Unmarshal(data []byte, v interface{}) error {
	pb, ok := v.(proto.Message)
	if !ok {
		return constants.ErrWrongValueType
	}
	return proto.Unmarshal(data, pb)
}

// GetName returns the name of the serializer.
func (s *Serializer) GetName() string {
	return "protobuf"
}

```

`pkg/serialize/protobuf/protobuf_test.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package protobuf

import (
	"flag"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/helpers"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
)

var update = flag.Bool("update", false, "update .golden files")

func TestNewSerializer(t *testing.T) {
	t.Parallel()
	serializer := NewSerializer()
	assert.NotNil(t, serializer)
}

func TestMarshal(t *testing.T) {
	var marshalTables = map[string]struct {
		raw interface{}
		err error
	}{
		"test_ok":            {&protos.Response{Data: []byte("data"), Error: &protos.Error{Msg: "error"}}, nil},
		"test_not_a_message": {"invalid", constants.ErrWrongValueType},
	}
	serializer := NewSerializer()

	for name, table := range marshalTables {
		t.Run(name, func(t *testing.T) {
			result, err := serializer.Marshal(table.raw)
			gp := helpers.FixtureGoldenFileName(t, t.Name())

			if table.err == nil {
				assert.NoError(t, err)
				if *update {
					t.Log("updating golden file")
					helpers.WriteFile(t, gp, result)
				}

				expected := helpers.ReadFile(t, gp)
				assert.Equal(t, expected, result)
			} else {
				assert.Equal(t, table.err, err)
			}
		})
	}
}

func TestUnmarshal(t *testing.T) {
	gp := helpers.FixtureGoldenFileName(t, "TestMarshal/test_ok")
	data := helpers.ReadFile(t, gp)

	var dest protos.Response
	var unmarshalTables = map[string]struct {
		expected interface{}
		data     []byte
		dest     interface{}
		err      error
	}{
		"test_ok":           {&protos.Response{Data: []byte("data"), Error: &protos.Error{Msg: "error"}}, data, &dest, nil},
		"test_invalid_dest": {&protos.Response{Data: []byte(nil)}, data, "invalid", constants.ErrWrongValueType},
	}
	serializer := NewSerializer()

	for name, table := range unmarshalTables {
		t.Run(name, func(t *testing.T) {
			result := table.dest
			err := serializer.Unmarshal(table.data, result)
			assert.Equal(t, table.err, err)
			if table.err == nil {
				assert.Equal(t, table.expected, result)
			}
		})
	}
}

```

`pkg/serialize/serializer.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package serialize

import (
	"errors"

	"github.com/topfreegames/pitaya/v3/pkg/serialize/json"
	"github.com/topfreegames/pitaya/v3/pkg/serialize/protobuf"
)

const (
	JSON     Type = 1
	PROTOBUF Type = 2
)

type (
	// Type is the Serializer type.
	Type uint16

	// Marshaler represents a marshal interface
	Marshaler interface {
		Marshal(interface{}) ([]byte, error)
	}

	// Unmarshaler represents a Unmarshal interface
	Unmarshaler interface {
		Unmarshal([]byte, interface{}) error
	}

	// Serializer is the interface that groups the basic Marshal and Unmarshal methods.
	Serializer interface {
		Marshaler
		Unmarshaler
		GetName() string
	}
)

// All recognized and expected serializer type values.

// NewSerializer returns a new serializer of the respective type (JSON or PROTOBUF) according to serializerType Type.
// If serializerType is a JSON, then a JSON serializer is returned.
// If serializerType is a PROTOBUF, then  a PROTOBUF serializer is returned.
// Otherwise, if serializerType is not a valid serializer type, then it returns nil.
func NewSerializer(serializerType Type) (Serializer, error) { //nolint:ireturn
	switch serializerType {
	case JSON:
		return json.NewSerializer(), nil
	case PROTOBUF:
		return protobuf.NewSerializer(), nil
	default:
		return nil, errors.New("serializer type unknown")
	}
}

```

`pkg/service/base_service.go`:

```go
package service

import "github.com/topfreegames/pitaya/v3/pkg/pipeline"

type baseService struct {
	handlerHooks *pipeline.HandlerHooks
}

func (h *baseService) SetHandlerHooks(handlerHooks *pipeline.HandlerHooks) {
	h.handlerHooks = handlerHooks
}

```

`pkg/service/fixtures/unmarshal_remote_test_1.golden`:

```golden
blah
```

`pkg/service/fixtures/unmarshal_remote_test_2.golden`:

```golden
aaa
```

`pkg/service/fixtures/unmarshal_remote_test_3.golden`:

```golden
aab
```

`pkg/service/handler.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package service

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net"
	"strings"
	"time"

	"github.com/nats-io/nuid"
	"go.opentelemetry.io/otel/attribute"

	"github.com/topfreegames/pitaya/v3/pkg/acceptor"
	"github.com/topfreegames/pitaya/v3/pkg/pipeline"

	"github.com/topfreegames/pitaya/v3/pkg/agent"
	"github.com/topfreegames/pitaya/v3/pkg/cluster"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/conn/codec"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/conn/packet"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	pcontext "github.com/topfreegames/pitaya/v3/pkg/context"
	"github.com/topfreegames/pitaya/v3/pkg/docgenerator"
	e "github.com/topfreegames/pitaya/v3/pkg/errors"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
	"github.com/topfreegames/pitaya/v3/pkg/route"
	"github.com/topfreegames/pitaya/v3/pkg/serialize"
	"github.com/topfreegames/pitaya/v3/pkg/session"
	"github.com/topfreegames/pitaya/v3/pkg/timer"
	"github.com/topfreegames/pitaya/v3/pkg/tracing"
)

var (
	handlerType = "handler"
)

type (
	// HandlerService service
	HandlerService struct {
		baseService
		chLocalProcess   chan unhandledMessage // channel of messages that will be processed locally
		chRemoteProcess  chan unhandledMessage // channel of messages that will be processed remotely
		decoder          codec.PacketDecoder   // binary decoder
		remoteService    *RemoteService
		serializer       serialize.Serializer          // message serializer
		server           *cluster.Server               // server obj
		services         map[string]*component.Service // all registered service
		metricsReporters []metrics.Reporter
		agentFactory     agent.AgentFactory
		handlerPool      *HandlerPool
		handlers         map[string]*component.Handler // all handler method
	}

	unhandledMessage struct {
		ctx   context.Context
		agent agent.Agent
		route *route.Route
		msg   *message.Message
	}
)

// NewHandlerService creates and returns a new handler service
func NewHandlerService(
	packetDecoder codec.PacketDecoder,
	serializer serialize.Serializer,
	localProcessBufferSize int,
	remoteProcessBufferSize int,
	server *cluster.Server,
	remoteService *RemoteService,
	agentFactory agent.AgentFactory,
	metricsReporters []metrics.Reporter,
	handlerHooks *pipeline.HandlerHooks,
	handlerPool *HandlerPool,
) *HandlerService {
	h := &HandlerService{
		services:         make(map[string]*component.Service),
		chLocalProcess:   make(chan unhandledMessage, localProcessBufferSize),
		chRemoteProcess:  make(chan unhandledMessage, remoteProcessBufferSize),
		decoder:          packetDecoder,
		serializer:       serializer,
		server:           server,
		remoteService:    remoteService,
		agentFactory:     agentFactory,
		metricsReporters: metricsReporters,
		handlerPool:      handlerPool,
		handlers:         make(map[string]*component.Handler),
	}

	h.handlerHooks = handlerHooks

	return h
}

// Dispatch message to corresponding logic handler
func (h *HandlerService) Dispatch(thread int) {
	// TODO: This timer is being stopped multiple times, it probably doesn't need to be stopped here
	defer timer.GlobalTicker.Stop()

	for {
		// Calls to remote servers block calls to local server
		select {
		case lm := <-h.chLocalProcess:
			metrics.ReportMessageProcessDelayFromCtx(lm.ctx, h.metricsReporters, "local")
			h.localProcess(lm.ctx, lm.agent, lm.route, lm.msg)

		case rm := <-h.chRemoteProcess:
			metrics.ReportMessageProcessDelayFromCtx(rm.ctx, h.metricsReporters, "remote")
			h.remoteService.remoteProcess(rm.ctx, nil, rm.agent, rm.route, rm.msg)

		case <-timer.GlobalTicker.C: // execute cron task
			timer.Cron()

		case t := <-timer.Manager.ChCreatedTimer: // new Timers
			timer.AddTimer(t)

		case id := <-timer.Manager.ChClosingTimer: // closing Timers
			timer.RemoveTimer(id)
		}
	}
}

// Register registers components
func (h *HandlerService) Register(comp component.Component, opts []component.Option) error {
	s := component.NewService(comp, opts)

	if _, ok := h.services[s.Name]; ok {
		return fmt.Errorf("handler: service already defined: %s", s.Name)
	}

	if err := s.ExtractHandler(); err != nil {
		return err
	}

	// register all handlers
	h.services[s.Name] = s
	for name, handler := range s.Handlers {
		h.handlerPool.Register(s.Name, name, handler)
	}
	return nil
}

// Handle handles messages from a conn
func (h *HandlerService) Handle(conn acceptor.PlayerConn) {
	// create a client agent and startup write goroutine
	a := h.agentFactory.CreateAgent(conn)

	// startup agent goroutine
	go a.Handle()

	logger.Log.Debugf("New session established: %s", a.String())

	// guarantee agent related resource is destroyed
	defer func() {
		a.GetSession().Close()
		logger.Log.Debugf("Session read goroutine exit, SessionID=%d, UID=%s", a.GetSession().ID(), a.GetSession().UID())
	}()

	for {
		msg, err := conn.GetNextMessage()

		if err != nil {
			// Check if this is an expected error due to connection being closed
			if errors.Is(err, net.ErrClosed) {
				logger.Log.Debugf("Connection no longer available while reading next available message: %s", err.Error())
			} else if err == constants.ErrConnectionClosed {
				logger.Log.Debugf("Connection no longer available while reading next available message: %s", err.Error())
			} else {
				// Differentiate errors for valid sessions, to avoid noise from load balancer healthchecks and other internet noise
				if a.GetStatus() != constants.StatusStart {
					logger.Log.Errorf("Error reading next available message for UID: %s, Build: %s, error: %s", a.GetSession().UID(), "a.GetSession().GetHandshakeData().Sys.BuildNumber", err.Error())
				} else {
					logger.Log.Debugf("Error reading next available message on initial connection: %s", err.Error())
				}
			}

			return
		}

		packets, err := h.decoder.Decode(msg)
		if err != nil {
			logger.Log.Errorf("Failed to decode message: %s", err.Error())
			return
		}

		if len(packets) < 1 {
			logger.Log.Warnf("Read no packets, data: %v", msg)
			continue
		}

		// process all packet
		for i := range packets {
			if err := h.processPacket(a, packets[i]); err != nil {
				logger.Log.Errorf("Failed to process packet: %s", err.Error())
				return
			}
		}
	}
}

func (h *HandlerService) processPacket(a agent.Agent, p *packet.Packet) error {
	switch p.Type {
	case packet.Handshake:
		logger.Log.Debug("Received handshake packet")

		// Parse the json sent with the handshake by the client
		handshakeData := &session.HandshakeData{}
		if err := json.Unmarshal(p.Data, handshakeData); err != nil {
			defer a.Close()
			logger.Log.Errorf("Failed to unmarshal handshake data: %s", err.Error())
			if serr := a.SendHandshakeErrorResponse(); serr != nil {
				logger.Log.Errorf("Error sending handshake error response: %s", err.Error())
				return err
			}

			return fmt.Errorf("invalid handshake data. Id=%d", a.GetSession().ID())
		}

		if err := a.GetSession().ValidateHandshake(handshakeData); err != nil {
			defer a.Close()
			logger.Log.Errorf("Handshake validation failed: %s", err.Error())
			if serr := a.SendHandshakeErrorResponse(); serr != nil {
				logger.Log.Errorf("Error sending handshake error response: %s", err.Error())
				return err
			}

			return fmt.Errorf("handshake validation failed: %w. SessionId=%d", err, a.GetSession().ID())
		}

		if err := a.SendHandshakeResponse(); err != nil {
			logger.Log.Errorf("Error sending handshake response: %s", err.Error())
			return err
		}
		logger.Log.Debugf("Session handshake Id=%d, Remote=%s", a.GetSession().ID(), a.RemoteAddr())

		a.GetSession().SetHandshakeData(handshakeData)
		a.SetStatus(constants.StatusHandshake)
		err := a.GetSession().Set(constants.IPVersionKey, a.IPVersion())
		if err != nil {
			logger.Log.Warnf("failed to save ip version on session: %q\n", err)
		}

		logger.Log.Debug("Successfully saved handshake data")

	case packet.HandshakeAck:
		a.SetStatus(constants.StatusWorking)
		logger.Log.Debugf("Receive handshake ACK Id=%d, Remote=%s", a.GetSession().ID(), a.RemoteAddr())

	case packet.Data:
		if a.GetStatus() < constants.StatusWorking {
			return fmt.Errorf("receive data on socket which is not yet ACK, session will be closed immediately, remote=%s",
				a.RemoteAddr().String())
		}

		msg, err := message.Decode(p.Data)
		if err != nil {
			return err
		}
		h.processMessage(a, msg)

	case packet.Heartbeat:
		// expected
	}

	a.SetLastAt()
	return nil
}

func (h *HandlerService) processMessage(a agent.Agent, msg *message.Message) {
	requestID := nuid.New().Next()
	ctx := pcontext.AddToPropagateCtx(context.Background(), constants.StartTimeKey, time.Now().UnixNano())
	ctx = pcontext.AddToPropagateCtx(ctx, constants.RouteKey, msg.Route)
	ctx = pcontext.AddToPropagateCtx(ctx, constants.RequestIDKey, requestID)

	attributes := []attribute.KeyValue{
		attribute.String("local.id", h.server.ID),
		attribute.String("span.kind", "server"),
		attribute.String("msg.type", strings.ToLower(msg.Type.String())),
		attribute.String("user.id", a.GetSession().UID()),
		attribute.String("request.id", requestID),
	}
	ctx, _ = tracing.StartSpan(ctx, msg.Route, attributes...)
	ctx = context.WithValue(ctx, constants.SessionCtxKey, a.GetSession())

	r, err := route.Decode(msg.Route)
	if err != nil {
		logger.Log.Errorf("Failed to decode route: %s", err.Error())
		a.AnswerWithError(ctx, msg.ID, e.NewError(err, e.ErrBadRequestCode))
		return
	}

	if r.SvType == "" {
		r.SvType = h.server.Type
	}

	message := unhandledMessage{
		ctx:   ctx,
		agent: a,
		route: r,
		msg:   msg,
	}
	if r.SvType == h.server.Type {
		h.chLocalProcess <- message
	} else {
		if h.remoteService != nil {
			h.chRemoteProcess <- message
		} else {
			logger.Log.Warnf("request made to another server type but no remoteService running")
		}
	}
}

func (h *HandlerService) localProcess(ctx context.Context, a agent.Agent, route *route.Route, msg *message.Message) {
	var mid uint
	switch msg.Type {
	case message.Request:
		mid = msg.ID
	case message.Notify:
		mid = 0
	}

	ret, err := h.handlerPool.ProcessHandlerMessage(ctx, route, h.serializer, h.handlerHooks, a.GetSession(), msg.Data, msg.Type, false)
	if msg.Type != message.Notify {
		if err != nil {
			logger.Log.Errorf("Failed to process handler message: %s", err.Error())
			a.AnswerWithError(ctx, mid, err)
		} else {
			err := a.GetSession().ResponseMID(ctx, mid, ret)
			if err != nil {
				logger.Log.Errorf("Failed to process handler message: %s", err.Error())
				tracing.FinishSpan(ctx, err)
				metrics.ReportTimingFromCtx(ctx, h.metricsReporters, handlerType, err)
			}
		}
	} else {
		metrics.ReportTimingFromCtx(ctx, h.metricsReporters, handlerType, err)
		tracing.FinishSpan(ctx, err)
		if err != nil {
			logger.Log.Errorf("Failed to process notify message: %s", err.Error())
		}
	}
}

// DumpServices outputs all registered services
func (h *HandlerService) DumpServices() {
	handlers := h.handlerPool.GetHandlers()
	for name := range handlers {
		logger.Log.Infof("registered handler %s, isRawArg: %v", name, handlers[name].IsRawArg)
	}
}

// Docs returns documentation for handlers
func (h *HandlerService) Docs(getPtrNames bool) (map[string]interface{}, error) {
	if h == nil {
		return map[string]interface{}{}, nil
	}
	return docgenerator.HandlersDocs(h.server.Type, h.services, getPtrNames)
}

```

`pkg/service/handler_pool.go`:

```go
package service

import (
	"context"
	"fmt"
	"reflect"

	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	e "github.com/topfreegames/pitaya/v3/pkg/errors"
	"github.com/topfreegames/pitaya/v3/pkg/logger/interfaces"
	"github.com/topfreegames/pitaya/v3/pkg/pipeline"
	"github.com/topfreegames/pitaya/v3/pkg/route"
	"github.com/topfreegames/pitaya/v3/pkg/serialize"
	"github.com/topfreegames/pitaya/v3/pkg/session"
	"github.com/topfreegames/pitaya/v3/pkg/util"
)

// HandlerPool ...
type HandlerPool struct {
	handlers map[string]*component.Handler // all handler method
}

// NewHandlerPool ...
func NewHandlerPool() *HandlerPool {
	return &HandlerPool{
		handlers: make(map[string]*component.Handler),
	}
}

// Register ...
func (h *HandlerPool) Register(serviceName string, name string, handler *component.Handler) {
	h.handlers[fmt.Sprintf("%s.%s", serviceName, name)] = handler
}

// GetHandlers ...
func (h *HandlerPool) GetHandlers() map[string]*component.Handler {
	return h.handlers
}

// ProcessHandlerMessage ...
func (h *HandlerPool) ProcessHandlerMessage(
	ctx context.Context,
	rt *route.Route,
	serializer serialize.Serializer,
	handlerHooks *pipeline.HandlerHooks,
	session session.Session,
	data []byte,
	msgTypeIface interface{},
	remote bool,
) ([]byte, error) {
	if ctx == nil {
		ctx = context.Background()
	}
	ctx = context.WithValue(ctx, constants.SessionCtxKey, session)
	ctx = util.CtxWithDefaultLogger(ctx, rt.String(), session.UID())

	handler, err := h.getHandler(rt)
	if err != nil {
		return nil, e.NewError(err, e.ErrNotFoundCode)
	}

	msgType, err := getMsgType(msgTypeIface)
	if err != nil {
		return nil, e.NewError(err, e.ErrInternalCode)
	}

	logger := ctx.Value(constants.LoggerCtxKey).(interfaces.Logger)
	exit, err := handler.ValidateMessageType(msgType)
	if err != nil && exit {
		return nil, e.NewError(err, e.ErrBadRequestCode)
	} else if err != nil {
		logger.Warnf("invalid message type, error: %s", err.Error())
	}

	// First unmarshal the handler arg that will be passed to
	// both handler and pipeline functions
	arg, err := unmarshalHandlerArg(handler, serializer, data)
	if err != nil {
		return nil, e.NewError(err, e.ErrBadRequestCode)
	}

	ctx, arg, err = handlerHooks.BeforeHandler.ExecuteBeforePipeline(ctx, arg)
	if err != nil {
		return nil, err
	}

	logger.Debugf("SID=%d, Data=%s", session.ID(), data)
	args := []reflect.Value{handler.Receiver, reflect.ValueOf(ctx)}
	if arg != nil {
		args = append(args, reflect.ValueOf(arg))
	}

	resp, err := util.Pcall(handler.Method, args)
	if remote && msgType == message.Notify {
		// This is a special case and should only happen with nats rpc client
		// because we used nats request we have to answer to it or else a timeout
		// will happen in the caller server and will be returned to the client
		// the reason why we don't just Publish is to keep track of failed rpc requests
		// with timeouts, maybe we can improve this flow
		resp = []byte("ack")
	}

	resp, err = handlerHooks.AfterHandler.ExecuteAfterPipeline(ctx, resp, err)
	if err != nil {
		return nil, err
	}

	ret, err := serializeReturn(serializer, resp)
	if err != nil {
		return nil, err
	}

	return ret, nil
}

func (h *HandlerPool) getHandler(rt *route.Route) (*component.Handler, error) {
	handler, ok := h.handlers[rt.Short()]
	if !ok {
		e := fmt.Errorf("pitaya/handler: %s not found", rt.String())
		return nil, e
	}
	return handler, nil

}

```

`pkg/service/handler_pool_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package service

import (
	"context"
	"errors"
	"fmt"
	"reflect"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	e "github.com/topfreegames/pitaya/v3/pkg/errors"
	"github.com/topfreegames/pitaya/v3/pkg/pipeline"
	"github.com/topfreegames/pitaya/v3/pkg/protos/test"
	"github.com/topfreegames/pitaya/v3/pkg/route"
	"github.com/topfreegames/pitaya/v3/pkg/serialize/mocks"
	session_mocks "github.com/topfreegames/pitaya/v3/pkg/session/mocks"
)

func TestGetHandlerExists(t *testing.T) {
	rt := route.NewRoute("", uuid.New().String(), uuid.New().String())
	expected := &component.Handler{}
	handlerPool := NewHandlerPool()
	handlerPool.handlers[rt.Short()] = expected
	defer func() { delete(handlerPool.handlers, rt.Short()) }()

	h, err := handlerPool.getHandler(rt)
	assert.NoError(t, err)
	assert.Equal(t, expected, h)
}

func TestGetHandlerDoesntExist(t *testing.T) {
	rt := route.NewRoute("", uuid.New().String(), uuid.New().String())
	handlerPool := NewHandlerPool()
	h, err := handlerPool.getHandler(rt)
	assert.Nil(t, h)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), fmt.Sprintf("%s not found", rt.String()))
}

func TestProcessHandlerMessage(t *testing.T) {
	tObj := &TestType{}

	handlerPool := NewHandlerPool()

	m, ok := reflect.TypeOf(tObj).MethodByName("HandlerPointerRaw")
	assert.True(t, ok)
	assert.NotNil(t, m)
	rt := route.NewRoute("", uuid.New().String(), uuid.New().String())
	handlerPool.handlers[rt.Short()] = &component.Handler{Receiver: reflect.ValueOf(tObj), Method: m, Type: m.Type.In(2)}

	m, ok = reflect.TypeOf(tObj).MethodByName("HandlerPointerErr")
	assert.True(t, ok)
	assert.NotNil(t, m)
	rtErr := route.NewRoute("", uuid.New().String(), uuid.New().String())
	handlerPool.handlers[rtErr.Short()] = &component.Handler{Receiver: reflect.ValueOf(tObj), Method: m, Type: m.Type.In(2)}

	m, ok = reflect.TypeOf(tObj).MethodByName("HandlerPointerStruct")
	assert.True(t, ok)
	assert.NotNil(t, m)
	rtSt := route.NewRoute("", uuid.New().String(), uuid.New().String())
	handlerPool.handlers[rtSt.Short()] = &component.Handler{Receiver: reflect.ValueOf(tObj), Method: m, Type: m.Type.In(2)}

	tables := []struct {
		name         string
		route        *route.Route
		errSerReturn error
		errSerialize error
		outSerialize interface{}
		handlerType  message.Type
		msgType      interface{}
		remote       bool
		out          []byte
		err          error
	}{
		{"invalid_route", route.NewRoute("", "no", "no"), nil, nil, nil, message.Request, nil, false, nil, e.NewError(errors.New("pitaya/handler: no.no not found"), e.ErrNotFoundCode)},
		{"invalid_msg_type", rt, nil, nil, nil, message.Request, nil, false, nil, e.NewError(errInvalidMsg, e.ErrInternalCode)},
		{"request_on_notify", rt, nil, nil, nil, message.Notify, message.Request, false, nil, e.NewError(constants.ErrRequestOnNotify, e.ErrBadRequestCode)},
		{"failed_handle_args_unmarshal", rt, nil, errors.New("some error"), &test.SomeStruct{}, message.Request, message.Request, false, nil, e.NewError(errors.New("some error"), e.ErrBadRequestCode)},
		{"failed_pcall", rtErr, nil, nil, &test.SomeStruct{A: 1, B: "ok"}, message.Request, message.Request, false, nil, errors.New("HandlerPointerErr")},
		{"failed_serialize_return", rtSt, errors.New("ser ret error"), nil, &test.SomeStruct{A: 1, B: "ok"}, message.Request, message.Request, false, []byte("failed"), nil},
		{"ok", rt, nil, nil, &test.SomeStruct{}, message.Request, message.Request, false, []byte("ok"), nil},
		{"notify_on_request", rt, nil, nil, &test.SomeStruct{}, message.Request, message.Notify, false, []byte("ok"), nil},
		{"remote_notify", rt, nil, nil, &test.SomeStruct{}, message.Notify, message.Notify, true, []byte("ack"), nil},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			handlerPool.handlers[rt.Short()].MessageType = table.handlerType
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			ss := session_mocks.NewMockSession(ctrl)
			ss.EXPECT().UID().Return("uid").AnyTimes()
			ss.EXPECT().ID().Return(int64(1)).AnyTimes()
			mockSerializer := mocks.NewMockSerializer(ctrl)
			if table.outSerialize != nil {
				mockSerializer.EXPECT().Unmarshal(gomock.Any(), gomock.Any()).Return(table.errSerialize).Do(
					func(p []byte, arg interface{}) {
						arg = table.outSerialize
					})

				if table.errSerReturn != nil {
					mockSerializer.EXPECT().Marshal(gomock.Any()).Return(table.out, table.errSerReturn)
					mockSerializer.EXPECT().Marshal(gomock.Any()).Return(table.out, nil)
				}
			}
			handlerHooks := pipeline.NewHandlerHooks()
			out, err := handlerPool.ProcessHandlerMessage(nil, table.route, mockSerializer, handlerHooks, ss, nil, table.msgType, table.remote)
			assert.Equal(t, table.out, out)
			assert.Equal(t, table.err, err)
		})
	}
}

func TestProcessHandlerMessageBrokenBeforePipeline(t *testing.T) {
	ctrl := gomock.NewController(t)
	rt := route.NewRoute("", uuid.New().String(), uuid.New().String())
	handlerPool := NewHandlerPool()
	handlerPool.handlers[rt.Short()] = &component.Handler{}
	expected := errors.New("oh noes")
	before := func(ctx context.Context, in interface{}) (context.Context, interface{}, error) {
		return ctx, nil, expected
	}
	beforeHandler := pipeline.NewChannel()
	beforeHandler.PushFront(before)

	handlerHooks := pipeline.NewHandlerHooks()
	handlerHooks.BeforeHandler = beforeHandler
	ss := session_mocks.NewMockSession(ctrl)
	ss.EXPECT().UID().Return("uid").AnyTimes()
	ss.EXPECT().ID().Return(int64(1)).AnyTimes()
	out, err := handlerPool.ProcessHandlerMessage(nil, rt, nil, handlerHooks, ss, nil, message.Request, false)
	assert.Nil(t, out)
	assert.Equal(t, expected, err)
}

func TestProcessHandlerMessageBrokenAfterPipeline(t *testing.T) {
	tObj := &TestType{}
	m, ok := reflect.TypeOf(tObj).MethodByName("HandlerPointerRaw")
	assert.True(t, ok)
	assert.NotNil(t, m)
	rt := route.NewRoute("", uuid.New().String(), uuid.New().String())
	handlerPool := NewHandlerPool()
	handlerPool.handlers[rt.Short()] = &component.Handler{Receiver: reflect.ValueOf(tObj), Method: m, Type: m.Type.In(2)}

	after := func(ctx context.Context, out interface{}, err error) (interface{}, error) {
		return nil, errors.New("oh noes")
	}
	afterHandler := pipeline.NewAfterChannel()
	afterHandler.PushFront(after)

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	ss := session_mocks.NewMockSession(ctrl)
	ss.EXPECT().UID().Return("uid").AnyTimes()
	ss.EXPECT().ID().Return(int64(1)).AnyTimes()

	mockSerializer := mocks.NewMockSerializer(ctrl)
	mockSerializer.EXPECT().Unmarshal(gomock.Any(), gomock.Any()).Return(nil).Do(
		func(p []byte, arg interface{}) {
			arg = &test.SomeStruct{}
		})

	handlerHooks := pipeline.NewHandlerHooks()
	handlerHooks.AfterHandler = afterHandler
	out, err := handlerPool.ProcessHandlerMessage(nil, rt, mockSerializer, handlerHooks, ss, nil, message.Request, false)
	assert.Nil(t, out)
	assert.Equal(t, errors.New("oh noes"), err)
}

```

`pkg/service/handler_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package service

import (
	"context"
	encjson "encoding/json"
	"errors"
	"reflect"
	"sync"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	agentmocks "github.com/topfreegames/pitaya/v3/pkg/agent/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/cluster"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/conn/codec"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/conn/packet"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	pcontext "github.com/topfreegames/pitaya/v3/pkg/context"
	"github.com/topfreegames/pitaya/v3/pkg/helpers"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
	metricsmocks "github.com/topfreegames/pitaya/v3/pkg/metrics/mocks"
	connmock "github.com/topfreegames/pitaya/v3/pkg/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/pipeline"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/route"
	"github.com/topfreegames/pitaya/v3/pkg/serialize/json"
	serializemocks "github.com/topfreegames/pitaya/v3/pkg/serialize/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/session"
	"github.com/topfreegames/pitaya/v3/pkg/session/mocks"
)

var (
	once sync.Once
)

type mockAddr struct{}

func (m *mockAddr) Network() string { return "" }
func (m *mockAddr) String() string  { return "remote-string" }

type MyComp struct {
	component.Base
}

func (m *MyComp) Init()                        {}
func (m *MyComp) Shutdown()                    {}
func (m *MyComp) Handler1(ctx context.Context) {}
func (m *MyComp) Handler2(ctx context.Context, b []byte) ([]byte, error) {
	return nil, nil
}
func (m *MyComp) HandlerRawRaw(ctx context.Context, b []byte) ([]byte, error) {
	return b, nil
}

type NoHandlerRemoteComp struct {
	component.Base
}

func (m *NoHandlerRemoteComp) Init()     {}
func (m *NoHandlerRemoteComp) Shutdown() {}

func TestNewHandlerService(t *testing.T) {
	packetDecoder := codec.NewPomeloPacketDecoder()
	serializer := json.NewSerializer()
	sv := &cluster.Server{}
	remoteSvc := &RemoteService{}
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockMetricsReporter := metricsmocks.NewMockReporter(ctrl)
	mockMetricsReporters := []metrics.Reporter{mockMetricsReporter}
	mockAgentFactory := agentmocks.NewMockAgentFactory(ctrl)
	handlerHooks := pipeline.NewHandlerHooks()
	handlerPool := NewHandlerPool()
	svc := NewHandlerService(
		packetDecoder,
		serializer,
		9, 8,
		sv,
		remoteSvc,
		mockAgentFactory,
		mockMetricsReporters,
		handlerHooks,
		handlerPool,
	)

	assert.NotNil(t, svc)
	assert.Equal(t, packetDecoder, svc.decoder)
	assert.Equal(t, serializer, svc.serializer)
	assert.Equal(t, mockMetricsReporters, svc.metricsReporters)
	assert.Equal(t, sv, svc.server)
	assert.Equal(t, remoteSvc, svc.remoteService)
	assert.Equal(t, mockAgentFactory, svc.agentFactory)
	assert.NotNil(t, svc.chLocalProcess)
	assert.NotNil(t, svc.chRemoteProcess)
	assert.Equal(t, handlerHooks, svc.handlerHooks)
	assert.Equal(t, handlerPool, svc.handlerPool)
}

func TestHandlerServiceRegister(t *testing.T) {
	handlerPool := NewHandlerPool()
	svc := NewHandlerService(nil, nil, 0, 0, nil, nil, nil, nil, nil, handlerPool)
	err := svc.Register(&MyComp{}, []component.Option{})
	assert.NoError(t, err)
	assert.Len(t, svc.services, 1)
	val, ok := svc.services["MyComp"]
	assert.True(t, ok)
	assert.NotNil(t, val)
	val2, ok := handlerPool.GetHandlers()["MyComp.Handler1"]
	assert.True(t, ok)
	assert.NotNil(t, val2)
	val2, ok = handlerPool.GetHandlers()["MyComp.Handler2"]
	assert.True(t, ok)
	assert.NotNil(t, val2)
	val2, ok = handlerPool.GetHandlers()["MyComp.HandlerRawRaw"]
	assert.True(t, ok)
	assert.NotNil(t, val2)
}

func TestHandlerServiceRegisterFailsIfRegisterTwice(t *testing.T) {
	handlerPool := NewHandlerPool()
	svc := NewHandlerService(nil, nil, 0, 0, nil, nil, nil, nil, nil, handlerPool)
	err := svc.Register(&MyComp{}, []component.Option{})
	assert.NoError(t, err)
	err = svc.Register(&MyComp{}, []component.Option{})
	assert.Contains(t, err.Error(), "handler: service already defined")
}

func TestHandlerServiceRegisterFailsIfNoHandlerMethods(t *testing.T) {
	handlerPool := NewHandlerPool()
	svc := NewHandlerService(nil, nil, 0, 0, nil, nil, nil, nil, nil, handlerPool)
	err := svc.Register(&NoHandlerRemoteComp{}, []component.Option{})
	assert.Equal(t, errors.New("type NoHandlerRemoteComp has no exported methods of handler type"), err)
}

func TestHandlerServiceProcessMessage(t *testing.T) {
	tables := []struct {
		name  string
		msg   *message.Message
		err   interface{}
		local bool
	}{
		{"failed_decode", &message.Message{ID: 1, Route: "k.k.k.k"}, &protos.Error{Msg: "invalid route", Code: "PIT-400"}, false},
		{"local_process", &message.Message{ID: 1, Route: "k.k"}, nil, true},
		{"remote_process", &message.Message{ID: 1, Route: "k.k.k"}, nil, false},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			sv := &cluster.Server{}
			handlerPool := NewHandlerPool()
			svc := NewHandlerService(nil, nil, 1, 1, sv, &RemoteService{}, nil, nil, nil, handlerPool)

			mockSession := mocks.NewMockSession(ctrl)
			mockSession.EXPECT().UID().Return("uid").Times(1)
			mockAgent := agentmocks.NewMockAgent(ctrl)
			mockAgent.EXPECT().GetSession().Return(mockSession).Times(2)

			if table.err != nil {
				mockAgent.EXPECT().AnswerWithError(gomock.Any(), table.msg.ID, gomock.Any()).Times(1)
			}

			svc.processMessage(mockAgent, table.msg)

			if table.err == nil {
				var recvMsg unhandledMessage
				if table.err == nil && table.local {
					recvMsg = helpers.ShouldEventuallyReceive(t, svc.chLocalProcess).(unhandledMessage)
				} else if table.err == nil {
					recvMsg = helpers.ShouldEventuallyReceive(t, svc.chRemoteProcess).(unhandledMessage)
				}
				assert.Equal(t, table.msg, recvMsg.msg)
				assert.NotNil(t, pcontext.GetFromPropagateCtx(recvMsg.ctx, constants.StartTimeKey))
				assert.Equal(t, table.msg.Route, pcontext.GetFromPropagateCtx(recvMsg.ctx, constants.RouteKey))
			}
		})
	}
}

func TestHandlerServiceLocalProcess(t *testing.T) {
	tObj := &MyComp{}
	m, ok := reflect.TypeOf(tObj).MethodByName("HandlerRawRaw")
	assert.True(t, ok)
	assert.NotNil(t, m)
	rt := route.NewRoute("", uuid.New().String(), uuid.New().String())
	handlerPool := NewHandlerPool()
	handlerPool.handlers[rt.Short()] = &component.Handler{Receiver: reflect.ValueOf(tObj), Method: m, Type: m.Type.In(2), IsRawArg: true}

	tables := []struct {
		name string
		msg  *message.Message
		rt   *route.Route
		err  interface{}
	}{
		{"process_handler_msg_err", &message.Message{}, route.NewRoute("bla", "bla", "bla"), &protos.Error{Msg: "pitaya/handler: bla.bla.bla not found", Code: "PIT-404"}},
		{"success", &message.Message{ID: 1, Data: []byte(`["ok"]`)}, rt, nil},
	}
	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			mockSession := mocks.NewMockSession(ctrl)
			mockSession.EXPECT().UID().Return("uid").Times(1)

			mockAgent := agentmocks.NewMockAgent(ctrl)
			mockAgent.EXPECT().GetSession().Return(mockSession).AnyTimes()

			svc := NewHandlerService(nil, nil, 1, 1, nil, nil, nil, nil, pipeline.NewHandlerHooks(), handlerPool)

			ctx := context.Background()

			if table.err != nil {
				mockAgent.EXPECT().AnswerWithError(gomock.Any(), table.msg.ID, gomock.Any())
			} else {
				mockSession.EXPECT().ResponseMID(ctx, table.msg.ID, table.msg.Data, gomock.Any()).Return(nil).Times(1)
				mockSession.EXPECT().ID().Return(int64(1)).Times(1)
			}

			svc.localProcess(ctx, mockAgent, table.rt, table.msg)
		})
	}
}

func TestHandlerServiceProcessPacketHandshake(t *testing.T) {
	tables := []struct {
		name         string
		packet       *packet.Packet
		socketStatus int32
		validator    func(data *session.HandshakeData) error
		errStr       string
	}{
		{"invalid_handshake_data", &packet.Packet{Type: packet.Handshake, Data: []byte("asiodjasd")}, constants.StatusClosed, nil, "invalid handshake data"},
		{"validator_error", &packet.Packet{Type: packet.Handshake, Data: []byte(`{"sys":{"platform":"mac"}}`)}, constants.StatusClosed, func(data *session.HandshakeData) error { return errors.New("validation failed") }, "handshake validation failed"},
		{"valid_handshake_data", &packet.Packet{Type: packet.Handshake, Data: []byte(`{"sys":{"platform":"mac"}}`)}, constants.StatusHandshake, func(data *session.HandshakeData) error { return nil }, ""},
	}
	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			mockSession := mocks.NewMockSession(ctrl)
			mockSession.EXPECT().ID().Return(int64(1)).Times(1)

			mockAgent := agentmocks.NewMockAgent(ctrl)
			mockAgent.EXPECT().GetSession().Return(mockSession).Times(1)

			if table.validator != nil {
				mockAgent.EXPECT().GetSession().Return(mockSession).Times(1)
				mockSession.EXPECT().ValidateHandshake(gomock.Any()).DoAndReturn(func(data *session.HandshakeData) error {
					return table.validator(data)
				}).Times(1)
			}

			if table.errStr == "" {
				handshakeData := &session.HandshakeData{}
				_ = encjson.Unmarshal(table.packet.Data, handshakeData)
				mockAgent.EXPECT().GetSession().Return(mockSession).Times(2)
				mockAgent.EXPECT().IPVersion().Return(constants.IPv4).Times(1)
				mockAgent.EXPECT().RemoteAddr().Return(&mockAddr{})
				mockAgent.EXPECT().SetStatus(table.socketStatus).Times(1)
				mockAgent.EXPECT().SendHandshakeResponse().Return(nil).Times(1)
				mockAgent.EXPECT().SetLastAt().Times(1)

				mockSession.EXPECT().SetHandshakeData(handshakeData).Times(1)
				mockSession.EXPECT().Set(constants.IPVersionKey, constants.IPv4).Times(1)
			} else {
				mockAgent.EXPECT().SendHandshakeErrorResponse().Times(1)
				mockAgent.EXPECT().Close().Times(1)
			}

			handlerPool := NewHandlerPool()
			svc := NewHandlerService(nil, nil, 1, 1, nil, nil, nil, nil, pipeline.NewHandlerHooks(), handlerPool)
			err := svc.processPacket(mockAgent, table.packet)
			if table.errStr == "" {
				assert.Nil(t, err)
			} else {
				assert.NotNil(t, err)
				assert.Contains(t, err.Error(), table.errStr)
			}
		})
	}
}

func TestHandlerServiceProcessPacketHandshakeAck(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockSession := mocks.NewMockSession(ctrl)
	mockSession.EXPECT().ID().Return(int64(1)).Times(1)

	handlerPool := NewHandlerPool()
	svc := NewHandlerService(nil, nil, 1, 1, nil, nil, nil, nil, nil, handlerPool)

	mockAgent := agentmocks.NewMockAgent(ctrl)
	mockAgent.EXPECT().GetSession().Return(mockSession).Times(1)
	mockAgent.EXPECT().SetStatus(constants.StatusWorking).Times(1)
	mockAgent.EXPECT().RemoteAddr().Return(&mockAddr{})
	mockAgent.EXPECT().SetLastAt()

	err := svc.processPacket(mockAgent, &packet.Packet{Type: packet.HandshakeAck})
	assert.NoError(t, err)
}

func TestHandlerServiceProcessPacketHeartbeat(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockAgent := agentmocks.NewMockAgent(ctrl)
	mockAgent.EXPECT().SetLastAt()

	handlerPool := NewHandlerPool()
	svc := NewHandlerService(nil, nil, 1, 1, nil, nil, nil, nil, nil, handlerPool)

	err := svc.processPacket(mockAgent, &packet.Packet{Type: packet.Heartbeat})
	assert.NoError(t, err)
}

func TestHandlerServiceProcessPacketData(t *testing.T) {
	msgID := uint(1)
	msg := &message.Message{Type: message.Request, ID: msgID, Data: []byte("ok")}
	messageEncoder := message.NewMessagesEncoder(false)
	encodedMsg, err := messageEncoder.Encode(msg)
	assert.NoError(t, err)
	tables := []struct {
		name         string
		packet       *packet.Packet
		socketStatus int32
		errStr       string
	}{
		{"not_acked_socket", &packet.Packet{Type: packet.Data, Data: []byte("ok")}, constants.StatusStart, "not yet ACK"},
		{"failed_decode", &packet.Packet{Type: packet.Data, Data: []byte("ok")}, constants.StatusWorking, "wrong message type"},
		{"success", &packet.Packet{Type: packet.Data, Data: encodedMsg}, constants.StatusWorking, ""},
	}
	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			mockSession := mocks.NewMockSession(ctrl)

			mockAgent := agentmocks.NewMockAgent(ctrl)

			mockAgent.EXPECT().GetStatus().Return(table.socketStatus)
			if table.socketStatus < constants.StatusWorking {
				mockAgent.EXPECT().RemoteAddr().Return(&mockAddr{})
			} else {
				if table.errStr == "" {
					mockAgent.EXPECT().GetSession().Return(mockSession).Times(2)
					mockSession.EXPECT().UID().Return("uid").Times(1)

					mockAgent.EXPECT().AnswerWithError(gomock.Any(), msgID, gomock.Any()).Times(1)
					mockAgent.EXPECT().SetLastAt().Times(1)
				}
			}

			handlerPool := NewHandlerPool()
			svc := NewHandlerService(nil, nil, 1, 1, &cluster.Server{}, nil, nil, nil, nil, handlerPool)
			err := svc.processPacket(mockAgent, table.packet)
			if table.errStr != "" {
				assert.Contains(t, err.Error(), table.errStr)
			}
		})
	}
}

func TestHandlerServiceHandle(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	packetEncoder := codec.NewPomeloPacketEncoder()
	packetDecoder := codec.NewPomeloPacketDecoder()
	handshakeBuffer := `{"sys":{"platform":"mac","libVersion":"0.3.5-release","clientBuildNumber":"20","clientVersion":"2.1"},"user":{"age":30}}`
	bbb, err := packetEncoder.Encode(packet.Handshake, []byte(handshakeBuffer))
	assert.NoError(t, err)

	mockSerializer := serializemocks.NewMockSerializer(ctrl)

	mockConn := connmock.NewMockPlayerConn(ctrl)

	mockAgent := agentmocks.NewMockAgent(ctrl)
	mockAgentFactory := agentmocks.NewMockAgentFactory(ctrl)
	mockAgentFactory.EXPECT().CreateAgent(mockConn).Return(mockAgent).Times(1)

	var wg sync.WaitGroup
	wg.Add(4)
	defer wg.Wait()

	mockAgent.EXPECT().Handle().Do(func() {
		wg.Done()
	})

	mockAgent.EXPECT().SendHandshakeResponse().Return(nil)

	mockSession := mocks.NewMockSession(ctrl)
	mockSession.EXPECT().GetHandshakeData().Return(&session.HandshakeData{Sys: session.HandshakeClientData{BuildNumber: "10"}}).AnyTimes()
	mockSession.EXPECT().SetHandshakeData(gomock.Any()).Times(1)
	mockSession.EXPECT().ValidateHandshake(gomock.Any()).Times(1)
	mockSession.EXPECT().UID().Return("uid").AnyTimes()
	mockSession.EXPECT().ID().Return(int64(1)).Times(2)
	mockSession.EXPECT().Set(constants.IPVersionKey, constants.IPv4)
	mockSession.EXPECT().Close()

	mockAgent.EXPECT().String().Return("")
	mockAgent.EXPECT().GetStatus().AnyTimes()
	mockAgent.EXPECT().SetStatus(constants.StatusHandshake)
	mockAgent.EXPECT().GetSession().Return(mockSession).AnyTimes()
	mockAgent.EXPECT().IPVersion().Return(constants.IPv4)
	mockAgent.EXPECT().RemoteAddr().Return(&mockAddr{}).AnyTimes()
	mockAgent.EXPECT().SetLastAt().Do(func() {
		wg.Done()
	})

	firstCall := mockConn.EXPECT().GetNextMessage().Return(bbb, nil).Do(func() {
		wg.Done()
	})

	mockConn.EXPECT().GetNextMessage().Return(nil, errors.New("die")).Do(func() {
		wg.Done()
	}).After(firstCall)

	mockConn.EXPECT().Close().MaxTimes(1)

	handlerPool := NewHandlerPool()
	svc := NewHandlerService(packetDecoder, mockSerializer, 1, 1, nil, nil, mockAgentFactory, nil, pipeline.NewHandlerHooks(), handlerPool)
	svc.Handle(mockConn)
}

```

`pkg/service/remote.go`:

```go
//
// Copyright (c) TFG Co. All Rights Reserved.
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package service

import (
	"context"
	"errors"
	"fmt"
	"reflect"
	"time"

	"github.com/golang/protobuf/proto"

	"github.com/topfreegames/pitaya/v3/pkg/agent"
	"github.com/topfreegames/pitaya/v3/pkg/cluster"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/conn/codec"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	pcontext "github.com/topfreegames/pitaya/v3/pkg/context"
	"github.com/topfreegames/pitaya/v3/pkg/docgenerator"
	e "github.com/topfreegames/pitaya/v3/pkg/errors"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/pipeline"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/route"
	"github.com/topfreegames/pitaya/v3/pkg/router"
	"github.com/topfreegames/pitaya/v3/pkg/serialize"
	"github.com/topfreegames/pitaya/v3/pkg/session"
	"github.com/topfreegames/pitaya/v3/pkg/tracing"
	"github.com/topfreegames/pitaya/v3/pkg/util"
)

// RemoteService struct
type RemoteService struct {
	baseService
	rpcServer              cluster.RPCServer
	serviceDiscovery       cluster.ServiceDiscovery
	serializer             serialize.Serializer
	encoder                codec.PacketEncoder
	rpcClient              cluster.RPCClient
	services               map[string]*component.Service // all registered service
	router                 *router.Router
	messageEncoder         message.Encoder
	server                 *cluster.Server // server obj
	remoteBindingListeners []cluster.RemoteBindingListener
	remoteHooks            *pipeline.RemoteHooks
	sessionPool            session.SessionPool
	handlerPool            *HandlerPool
	remotes                map[string]*component.Remote // all remote method
}

// NewRemoteService creates and return a new RemoteService
func NewRemoteService(
	rpcClient cluster.RPCClient,
	rpcServer cluster.RPCServer,
	sd cluster.ServiceDiscovery,
	encoder codec.PacketEncoder,
	serializer serialize.Serializer,
	router *router.Router,
	messageEncoder message.Encoder,
	server *cluster.Server,
	sessionPool session.SessionPool,
	remoteHooks *pipeline.RemoteHooks,
	handlerHooks *pipeline.HandlerHooks,
	handlerPool *HandlerPool,
) *RemoteService {
	remote := &RemoteService{
		services:               make(map[string]*component.Service),
		rpcClient:              rpcClient,
		rpcServer:              rpcServer,
		encoder:                encoder,
		serviceDiscovery:       sd,
		serializer:             serializer,
		router:                 router,
		messageEncoder:         messageEncoder,
		server:                 server,
		remoteBindingListeners: make([]cluster.RemoteBindingListener, 0),
		sessionPool:            sessionPool,
		handlerPool:            handlerPool,
		remotes:                make(map[string]*component.Remote),
	}

	remote.remoteHooks = remoteHooks
	remote.handlerHooks = handlerHooks

	return remote
}

func (r *RemoteService) remoteProcess(
	ctx context.Context,
	server *cluster.Server,
	a agent.Agent,
	route *route.Route,
	msg *message.Message,
) {
	log := logger.Log.WithFields(map[string]interface{}{
                        "route": route.String(),
                        "uid": a.GetSession().UID(),
                })
	res, err := r.remoteCall(ctx, server, protos.RPCType_Sys, route, a.GetSession(), msg)
	switch msg.Type {
	case message.Request:
		if err != nil {
			log.Errorf("Failed to process remote server: %s", err.Error())
			a.AnswerWithError(ctx, msg.ID, err)
			return
		}
		err := a.GetSession().ResponseMID(ctx, msg.ID, res.Data)
		if err != nil {
			log.Errorf("Failed to respond to remote server: %s", err.Error())
			a.AnswerWithError(ctx, msg.ID, err)
		}
	case message.Notify:
		defer tracing.FinishSpan(ctx, err)
		if err == nil && res.Error != nil {
			err = errors.New(res.Error.GetMsg())
		}
		if err != nil {
			log.Errorf("error while sending a notify to server: %s", err.Error())
		}
	}
}

// AddRemoteBindingListener adds a listener
func (r *RemoteService) AddRemoteBindingListener(bindingListener cluster.RemoteBindingListener) {
	r.remoteBindingListeners = append(r.remoteBindingListeners, bindingListener)
}

// Call processes a remote call
func (r *RemoteService) Call(ctx context.Context, req *protos.Request) (*protos.Response, error) {
	c, err := util.GetContextFromRequest(req, r.server.ID)
	c = util.StartSpanFromRequest(c, r.server.ID, req.GetMsg().GetRoute())
	defer tracing.FinishSpan(c, err)
	var res *protos.Response

	if err == nil {
		result := make(chan *protos.Response, 1)
		go func() {
			result <- processRemoteMessage(c, req, r)
		}()

		reqTimeout := pcontext.GetFromPropagateCtx(ctx, constants.RequestTimeout)
		if reqTimeout != nil {
			var timeout time.Duration
			timeout, err = time.ParseDuration(reqTimeout.(string))
			if err == nil {
				select {
				case <-time.After(timeout):
					err = constants.ErrRPCRequestTimeout
				case res := <-result:
					return res, nil
				}
			}
		} else {
			res := <-result
			return res, nil
		}
	}

	if err != nil {
		res = &protos.Response{
			Error: &protos.Error{
				Code: e.ErrInternalCode,
				Msg:  err.Error(),
			},
		}
	}

	if res.Error != nil {
		err = errors.New(res.Error.Msg)
	}

	return res, err
}

// SessionBindRemote is called when a remote server binds a user session and want us to acknowledge it
func (r *RemoteService) SessionBindRemote(ctx context.Context, msg *protos.BindMsg) (*protos.Response, error) {
	for _, r := range r.remoteBindingListeners {
		r.OnUserBind(msg.Uid, msg.Fid)
	}
	return &protos.Response{
		Data: []byte("ack"),
	}, nil
}

// PushToUser sends a push to user
func (r *RemoteService) PushToUser(ctx context.Context, push *protos.Push) (*protos.Response, error) {
	logger.Log.Debugf("sending push to user %s: %v", push.GetUid(), string(push.Data))
	s := r.sessionPool.GetSessionByUID(push.GetUid())
	if s != nil {
		err := s.Push(push.Route, push.Data)
		if err != nil {
			return nil, err
		}
		return &protos.Response{
			Data: []byte("ack"),
		}, nil
	}
	return nil, constants.ErrSessionNotFound
}

// KickUser sends a kick to user
func (r *RemoteService) KickUser(ctx context.Context, kick *protos.KickMsg) (*protos.KickAnswer, error) {
	logger.Log.Debugf("sending kick to user %s", kick.GetUserId())
	s := r.sessionPool.GetSessionByUID(kick.GetUserId())
	if s != nil {
		err := s.Kick(ctx)
		if err != nil {
			return nil, err
		}
		return &protos.KickAnswer{
			Kicked: true,
		}, nil
	}
	return nil, constants.ErrSessionNotFound
}

// DoRPC do rpc and get answer
func (r *RemoteService) DoRPC(ctx context.Context, serverID string, route *route.Route, protoData []byte) (*protos.Response, error) {
	msg := &message.Message{
		Type:  message.Request,
		Route: route.Short(),
		Data:  protoData,
	}

	if serverID == "" {
		return r.remoteCall(ctx, nil, protos.RPCType_User, route, nil, msg)
	}

	target, _ := r.serviceDiscovery.GetServer(serverID)
	if target == nil {
		return nil, constants.ErrServerNotFound
	}

	return r.remoteCall(ctx, target, protos.RPCType_User, route, nil, msg)
}

// RPC makes rpcs
func (r *RemoteService) RPC(ctx context.Context, serverID string, route *route.Route, reply proto.Message, arg proto.Message) error {
	var data []byte
	var err error
	if arg != nil {
		data, err = proto.Marshal(arg)
		if err != nil {
			return err
		}
	}
	res, err := r.DoRPC(ctx, serverID, route, data)
	if err != nil {
		return err
	}

	if res.Error != nil {
		return &e.Error{
			Code:     res.Error.Code,
			Message:  res.Error.Msg,
			Metadata: res.Error.Metadata,
		}
	}

	if reply != nil {
		err = proto.Unmarshal(res.GetData(), reply)
		if err != nil {
			return err
		}
	}
	return nil
}

// Register registers components
func (r *RemoteService) Register(comp component.Component, opts []component.Option) error {
	s := component.NewService(comp, opts)

	if _, ok := r.services[s.Name]; ok {
		return fmt.Errorf("remote: service already defined: %s", s.Name)
	}

	if err := s.ExtractRemote(); err != nil {
		return err
	}

	r.services[s.Name] = s
	// register all remotes
	for name, remote := range s.Remotes {
		r.remotes[fmt.Sprintf("%s.%s", s.Name, name)] = remote
	}

	return nil
}

func processRemoteMessage(ctx context.Context, req *protos.Request, r *RemoteService) *protos.Response {
	rt, err := route.Decode(req.GetMsg().GetRoute())
	if err != nil {
		response := &protos.Response{
			Error: &protos.Error{
				Code: e.ErrBadRequestCode,
				Msg:  "cannot decode route",
				Metadata: map[string]string{
					"route": req.GetMsg().GetRoute(),
				},
			},
		}
		return response
	}

	switch {
	case req.Type == protos.RPCType_Sys:
		return r.handleRPCSys(ctx, req, rt)
	case req.Type == protos.RPCType_User:
		return r.handleRPCUser(ctx, req, rt)
	default:
		return &protos.Response{
			Error: &protos.Error{
				Code: e.ErrBadRequestCode,
				Msg:  "invalid rpc type",
				Metadata: map[string]string{
					"route": req.GetMsg().GetRoute(),
				},
			},
		}
	}
}

func (r *RemoteService) handleRPCUser(ctx context.Context, req *protos.Request, rt *route.Route) *protos.Response {
	remote, ok := r.remotes[rt.Short()]
	if !ok {
		logger.Log.Warnf("pitaya/remote: %s not found", rt.Short())
		response := &protos.Response{
			Error: &protos.Error{
				Code: e.ErrNotFoundCode,
				Msg:  "route not found",
				Metadata: map[string]string{
					"route": rt.Short(),
				},
			},
		}
		return response
	}

	var ret interface{}
	var arg interface{}
	var err error

	if remote.HasArgs {
		arg, err = unmarshalRemoteArg(remote, req.GetMsg().GetData())
		if err != nil {
			response := &protos.Response{
				Error: &protos.Error{
					Code: e.ErrBadRequestCode,
					Msg:  err.Error(),
				},
			}
			return response
		}
	}

	ctx, arg, err = r.remoteHooks.BeforeHandler.ExecuteBeforePipeline(ctx, arg)
	if err != nil {
		response := &protos.Response{
			Error: &protos.Error{
				Code: e.ErrInternalCode,
				Msg:  err.Error(),
			},
		}
		return response
	}

	params := []reflect.Value{remote.Receiver, reflect.ValueOf(ctx)}
	if remote.HasArgs {
		params = append(params, reflect.ValueOf(arg))
	}
	ret, err = util.Pcall(remote.Method, params)

	ret, err = r.remoteHooks.AfterHandler.ExecuteAfterPipeline(ctx, ret, err)
	if err != nil {
		response := &protos.Response{
			Error: &protos.Error{
				Code: e.ErrUnknownCode,
				Msg:  err.Error(),
			},
		}
		if val, ok := err.(*e.Error); ok {
			response.Error.Code = val.Code
			if val.Metadata != nil {
				response.Error.Metadata = val.Metadata
			}
		}
		return response
	}

	var b []byte
	if ret != nil {
		pb, ok := ret.(proto.Message)
		if !ok {
			response := &protos.Response{
				Error: &protos.Error{
					Code: e.ErrUnknownCode,
					Msg:  constants.ErrWrongValueType.Error(),
				},
			}
			return response
		}
		if b, err = proto.Marshal(pb); err != nil {
			response := &protos.Response{
				Error: &protos.Error{
					Code: e.ErrUnknownCode,
					Msg:  err.Error(),
				},
			}
			return response
		}
	}

	response := &protos.Response{}
	response.Data = b
	return response
}

func (r *RemoteService) handleRPCSys(ctx context.Context, req *protos.Request, rt *route.Route) *protos.Response {
	reply := req.GetMsg().GetReply()
	response := &protos.Response{}
	// (warning) a new agent is created for every new request
	a, err := agent.NewRemote(
		req.GetSession(),
		reply,
		r.rpcClient,
		r.encoder,
		r.serializer,
		r.serviceDiscovery,
		req.FrontendID,
		r.messageEncoder,
		r.sessionPool,
	)
	if err != nil {
		logger.Log.Warn("pitaya/handler: cannot instantiate remote agent")
		response := &protos.Response{
			Error: &protos.Error{
				Code: e.ErrInternalCode,
				Msg:  err.Error(),
			},
		}
		return response
	}

	ret, err := r.handlerPool.ProcessHandlerMessage(ctx, rt, r.serializer, r.handlerHooks, a.Session, req.GetMsg().GetData(), req.GetMsg().GetType(), true)
	if err != nil {
		logger.Log.Warnf(err.Error())
		response = &protos.Response{
			Error: &protos.Error{
				Code: e.ErrUnknownCode,
				Msg:  err.Error(),
			},
		}
		if val, ok := err.(*e.Error); ok {
			response.Error.Code = val.Code
			if val.Metadata != nil {
				response.Error.Metadata = val.Metadata
			}
		}
	} else {
		response = &protos.Response{Data: ret}
	}
	return response
}

func (r *RemoteService) remoteCall(
	ctx context.Context,
	server *cluster.Server,
	rpcType protos.RPCType,
	route *route.Route,
	session session.Session,
	msg *message.Message,
) (*protos.Response, error) {
	svType := route.SvType

	var err error
	target := server

	if target == nil {
		target, err = r.router.Route(ctx, rpcType, svType, route, msg)
		if err != nil {
			logger.Log.Errorf("error making call for route %s: %w", route.String(), err)
			return nil, e.NewError(err, e.ErrInternalCode)
		}
	}

	res, err := r.rpcClient.Call(ctx, rpcType, route, session, msg, target)
	if err != nil {
		logger.Log.Errorf("error making call to target with id %s, route %s and host %s: %w", target.ID, route.String(), target.Hostname, err)
		return nil, err
	}
	return res, err
}

// DumpServices outputs all registered services
func (r *RemoteService) DumpServices() {
	for name := range r.remotes {
		logger.Log.Infof("registered remote %s", name)
	}
}

// Docs returns documentation for remotes
func (r *RemoteService) Docs(getPtrNames bool) (map[string]interface{}, error) {
	if r == nil {
		return map[string]interface{}{}, nil
	}
	return docgenerator.RemotesDocs(r.server.Type, r.services, getPtrNames)
}

```

`pkg/service/remote_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package service

import (
	"context"
	"errors"
	"fmt"
	"math/rand"
	"reflect"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/golang/protobuf/proto"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	agentmocks "github.com/topfreegames/pitaya/v3/pkg/agent/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/cluster"
	clustermocks "github.com/topfreegames/pitaya/v3/pkg/cluster/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/conn/codec"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	messagemocks "github.com/topfreegames/pitaya/v3/pkg/conn/message/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	e "github.com/topfreegames/pitaya/v3/pkg/errors"
	"github.com/topfreegames/pitaya/v3/pkg/pipeline"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/protos/test"
	"github.com/topfreegames/pitaya/v3/pkg/route"
	"github.com/topfreegames/pitaya/v3/pkg/router"
	serializemocks "github.com/topfreegames/pitaya/v3/pkg/serialize/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/session"
	sessionmocks "github.com/topfreegames/pitaya/v3/pkg/session/mocks"
)

const ctxModifiedResponse = "response"

func (m *MyComp) Remote1(ctx context.Context, ss *test.SomeStruct) (*test.SomeStruct, error) {
	return &test.SomeStruct{B: "ack"}, nil
}

func (m *MyComp) Remote2(ctx context.Context) (*test.SomeStruct, error) {
	return nil, nil
}

func (m *MyComp) RemoteRes(ctx context.Context, b *test.SomeStruct) (*test.SomeStruct, error) {
	ctxRes := ctx.Value(ctxModifiedResponse) // used in hook tests
	if ctxRes != nil {
		return ctxRes.(*test.SomeStruct), nil
	}
	return b, nil
}

func (m *MyComp) RemoteErr(ctx context.Context) (*test.SomeStruct, error) {
	return nil, e.NewError(errors.New("remote err"), e.ErrUnknownCode)
}

type unregisteredStruct struct{}

func TestNewRemoteService(t *testing.T) {
	packetEncoder := codec.NewPomeloPacketEncoder()
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockSerializer := serializemocks.NewMockSerializer(ctrl)
	mockSD := clustermocks.NewMockServiceDiscovery(ctrl)
	mockRPCClient := clustermocks.NewMockRPCClient(ctrl)
	mockRPCServer := clustermocks.NewMockRPCServer(ctrl)
	mockMessageEncoder := messagemocks.NewMockEncoder(ctrl)
	router := router.New()
	sv := &cluster.Server{}
	sessionPool := session.NewSessionPool()
	remoteHooks := pipeline.NewRemoteHooks()
	handlerHooks := pipeline.NewHandlerHooks()
	handlerPool := NewHandlerPool()
	svc := NewRemoteService(mockRPCClient, mockRPCServer, mockSD, packetEncoder, mockSerializer, router, mockMessageEncoder, sv, sessionPool, remoteHooks, handlerHooks, handlerPool)

	assert.NotNil(t, svc)
	assert.Empty(t, svc.services)
	assert.Equal(t, mockRPCClient, svc.rpcClient)
	assert.Equal(t, mockRPCServer, svc.rpcServer)
	assert.Equal(t, packetEncoder, svc.encoder)
	assert.Equal(t, mockSD, svc.serviceDiscovery)
	assert.Equal(t, mockSerializer, svc.serializer)
	assert.Equal(t, router, svc.router)
	assert.Equal(t, sv, svc.server)
	assert.Equal(t, sessionPool, svc.sessionPool)
	assert.Equal(t, remoteHooks, svc.remoteHooks)
	assert.Equal(t, handlerHooks, svc.handlerHooks)
	assert.Equal(t, handlerPool, svc.handlerPool)
}

func TestRemoteServiceRegister(t *testing.T) {
	svc := NewRemoteService(nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil)
	err := svc.Register(&MyComp{}, []component.Option{})
	assert.NoError(t, err)
	defer func() { svc.remotes = make(map[string]*component.Remote, 0) }()
	assert.Len(t, svc.services, 1)
	val, ok := svc.services["MyComp"]
	assert.True(t, ok)
	assert.NotNil(t, val)
	val2, ok := svc.remotes["MyComp.Remote1"]
	assert.True(t, ok)
	assert.NotNil(t, val2)
	val2, ok = svc.remotes["MyComp.Remote2"]
	assert.True(t, ok)
	assert.NotNil(t, val2)
	val2, ok = svc.remotes["MyComp.RemoteErr"]
	assert.True(t, ok)
	assert.NotNil(t, val)
	val2, ok = svc.remotes["MyComp.RemoteRes"]
	assert.True(t, ok)
	assert.NotNil(t, val)
}

func TestRemoteServiceAddRemoteBindingListener(t *testing.T) {
	svc := NewRemoteService(nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil)
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockBindingListener := clustermocks.NewMockRemoteBindingListener(ctrl)

	svc.AddRemoteBindingListener(mockBindingListener)
	assert.Equal(t, mockBindingListener, svc.remoteBindingListeners[0])
}

func TestRemoteServiceSessionBindRemote(t *testing.T) {
	svc := NewRemoteService(nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil)
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockBindingListener := clustermocks.NewMockRemoteBindingListener(ctrl)

	svc.AddRemoteBindingListener(mockBindingListener)
	assert.Equal(t, mockBindingListener, svc.remoteBindingListeners[0])

	msg := &protos.BindMsg{
		Uid: "uid",
		Fid: "fid",
	}

	mockBindingListener.EXPECT().OnUserBind(msg.Uid, msg.Fid)

	_, err := svc.SessionBindRemote(context.Background(), msg)

	assert.NoError(t, err)
}

func TestRemoteServicePushToUser(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	existingUID := "uid1"
	nonexistingUID := "uid2"

	mockSession := sessionmocks.NewMockSession(ctrl)

	mockSessionPool := sessionmocks.NewMockSessionPool(ctrl)
	mockSessionPool.EXPECT().GetSessionByUID(existingUID).Return(mockSession).Times(1)
	mockSessionPool.EXPECT().GetSessionByUID(nonexistingUID).Return(nil).Times(1)

	tables := []struct {
		name string
		uid  string
		sess session.Session
		p    *protos.Push
		err  error
	}{
		{"success", "uid1", mockSession, &protos.Push{
			Route: "sv.svc.mth",
			Uid:   existingUID,
			Data:  []byte{0x01},
		}, nil},
		{"no_sess_found", "uid2", nil, &protos.Push{
			Route: "sv.svc.mth",
			Uid:   nonexistingUID,
			Data:  []byte{0x01},
		}, constants.ErrSessionNotFound},
	}

	mockSession.EXPECT().Push(tables[0].p.Route, tables[0].p.Data).Times(1)
	svc := NewRemoteService(nil, nil, nil, nil, nil, nil, nil, nil, mockSessionPool, nil, nil, nil)

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			_, err := svc.PushToUser(context.Background(), table.p)
			if table.err != nil {
				assert.EqualError(t, err, table.err.Error())
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestRemoteServiceKickUser(t *testing.T) {
	ctrl := gomock.NewController(t)
	mockSessionPool := sessionmocks.NewMockSessionPool(ctrl)
	svc := NewRemoteService(nil, nil, nil, nil, nil, nil, nil, nil, mockSessionPool, nil, nil, nil)

	existingUID := "uid1"
	nonexistingUID := "uid2"

	mockSession := sessionmocks.NewMockSession(ctrl)
	mockSession.EXPECT().Kick(context.Background()).Times(1)

	mockSessionPool.EXPECT().GetSessionByUID(existingUID).Return(mockSession).Times(1)
	mockSessionPool.EXPECT().GetSessionByUID(nonexistingUID).Return(nil).Times(1)

	defer ctrl.Finish()

	tables := []struct {
		name string
		uid  string
		sess session.Session
		p    *protos.KickMsg
		err  error
	}{
		{"success", existingUID, mockSession, &protos.KickMsg{
			UserId: existingUID,
		}, nil},
		{"sessionNotFound", nonexistingUID, nil, &protos.KickMsg{
			UserId: nonexistingUID,
		}, constants.ErrSessionNotFound},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			_, err := svc.KickUser(context.Background(), table.p)
			if table.err != nil {
				assert.EqualError(t, err, table.err.Error())
			} else {
				assert.NoError(t, err)
			}
		})
	}

}

func TestRemoteServiceRegisterFailsIfRegisterTwice(t *testing.T) {
	svc := NewRemoteService(nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil)
	err := svc.Register(&MyComp{}, []component.Option{})
	assert.NoError(t, err)
	err = svc.Register(&MyComp{}, []component.Option{})
	assert.Contains(t, err.Error(), "remote: service already defined")
}

func TestRemoteServiceRegisterFailsIfNoRemoteMethods(t *testing.T) {
	svc := NewRemoteService(nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil)
	err := svc.Register(&NoHandlerRemoteComp{}, []component.Option{})
	assert.Equal(t, errors.New("type NoHandlerRemoteComp has no exported methods of remote type"), err)
}

func TestRemoteServiceRemoteCallWithDifferentServerArguments(t *testing.T) {
	route := route.NewRoute("sv", "svc", "method")
	table := []struct {
		name           string
		serverArg      *cluster.Server
		routeServer    *cluster.Server
		expectedServer *cluster.Server
	}{
		{
			name:           "should use server argument if provided",
			serverArg:      &cluster.Server{Type: "sv"},
			routeServer:    &cluster.Server{Type: "sv2"},
			expectedServer: &cluster.Server{Type: "sv"},
		},
		{
			name:           "should use route's returned server if server argument is nil",
			serverArg:      nil,
			routeServer:    &cluster.Server{Type: "sv"},
			expectedServer: &cluster.Server{Type: "sv"},
		},
	}

	for _, row := range table {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			mockSession := sessionmocks.NewMockSession(ctrl)
			mockRPCClient := clustermocks.NewMockRPCClient(ctrl)
			sessionPool := sessionmocks.NewMockSessionPool(ctrl)
			mockServiceDiscovery := clustermocks.NewMockServiceDiscovery(ctrl)
			router := router.New()
			router.SetServiceDiscovery(mockServiceDiscovery)
			mockServiceDiscovery.EXPECT().GetServersByType(gomock.Any()).Return(map[string]*cluster.Server{row.routeServer.Type: row.routeServer}, nil).AnyTimes()

			msg := &message.Message{}
			ctx := context.Background()
			mockRPCClient.EXPECT().Call(ctx, protos.RPCType_Sys, gomock.Any(), mockSession, msg, row.expectedServer).Return(nil, nil).AnyTimes()

			svc := NewRemoteService(mockRPCClient, nil, nil, nil, nil, router, nil, nil, sessionPool, nil, pipeline.NewHandlerHooks(), nil)
			assert.NotNil(t, svc)

			_, err := svc.remoteCall(ctx, row.serverArg, protos.RPCType_Sys, route, mockSession, msg)
			assert.NoError(t, err)
		})
	}
}

func TestRemoteServiceRemoteCall(t *testing.T) {
	tables := []struct {
		name        string
		route       route.Route
		serverArg   *cluster.Server
		routeErr    error
		callRes     *protos.Response
		callErr     error
		expectedRes *protos.Response
		expectedErr error
	}{
		{
			name:        "should return internal error for routing generic error",
			route:       *route.NewRoute("sv", "svc", "method"),
			serverArg:   nil,
			routeErr:    assert.AnError,
			callRes:     nil,
			callErr:     nil,
			expectedRes: nil,
			expectedErr: e.NewError(assert.AnError, e.ErrInternalCode),
		},
		{
			name:        "should propagate error for routing pitaya error",
			route:       *route.NewRoute("sv", "svc", "method"),
			serverArg:   nil,
			routeErr:    e.NewError(assert.AnError, "CUSTOM-123"),
			callRes:     nil,
			callErr:     nil,
			expectedRes: nil,
			expectedErr: e.NewError(assert.AnError, "CUSTOM-123"),
		},
		{
			name:        "should propagate error for routing wrapped pitaya error",
			route:       *route.NewRoute("sv", "svc", "method"),
			serverArg:   nil,
			routeErr:    fmt.Errorf("wrapper error: %w", e.NewError(assert.AnError, "CUSTOM-123")),
			callRes:     nil,
			callErr:     nil,
			expectedRes: nil,
			expectedErr: e.NewError(assert.AnError, "CUSTOM-123"),
		},
		{
			name:        "should return error for rpc call error",
			route:       *route.NewRoute("sv", "svc", "method"),
			serverArg:   &cluster.Server{Type: "sv"},
			routeErr:    nil,
			callRes:     nil,
			callErr:     assert.AnError,
			expectedRes: nil,
			expectedErr: assert.AnError,
		},
		{
			name:        "should succeed",
			route:       *route.NewRoute("sv", "svc", "method"),
			serverArg:   &cluster.Server{Type: "sv"},
			routeErr:    nil,
			callRes:     &protos.Response{Data: []byte("ok")},
			callErr:     nil,
			expectedRes: &protos.Response{Data: []byte("ok")},
			expectedErr: nil,
		},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			mockSession := sessionmocks.NewMockSession(ctrl)
			mockRPCClient := clustermocks.NewMockRPCClient(ctrl)
			sessionPool := sessionmocks.NewMockSessionPool(ctrl)
			mockServiceDiscovery := clustermocks.NewMockServiceDiscovery(ctrl)
			router := router.New()
			router.SetServiceDiscovery(mockServiceDiscovery)
			mockServiceDiscovery.EXPECT().GetServersByType(table.route.SvType).Return(map[string]*cluster.Server{"sv": {Type: "sv"}}, nil).AnyTimes()

			router.AddRoute(table.route.SvType, func(ctx context.Context, route *route.Route, payload []byte, servers map[string]*cluster.Server) (*cluster.Server, error) {
				return &cluster.Server{}, table.routeErr
			})
			svc := NewRemoteService(mockRPCClient, nil, nil, nil, nil, router, nil, nil, sessionPool, nil, pipeline.NewHandlerHooks(), nil)
			assert.NotNil(t, svc)

			mockRPCClient.EXPECT().Call(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(table.callRes, table.callErr).AnyTimes()

			ctx := context.Background()
			msg := &message.Message{}
			res, err := svc.remoteCall(ctx, table.serverArg, protos.RPCType_Sys, &table.route, mockSession, msg)
			assert.Equal(t, table.expectedErr, err)
			assert.Equal(t, table.expectedRes, res)
		})
	}
}

func TestRemoteServiceHandleRPCUser(t *testing.T) {
	handlerPool := NewHandlerPool()

	tObj := &MyComp{}
	m, ok := reflect.TypeOf(tObj).MethodByName("Remote1")
	assert.True(t, ok)
	assert.NotNil(t, m)
	rt := route.NewRoute("", uuid.New().String(), uuid.New().String())
	comp := &component.Remote{Receiver: reflect.ValueOf(tObj), Method: m, HasArgs: m.Type.NumIn() > 2}

	m, ok = reflect.TypeOf(tObj).MethodByName("RemoteErr")
	assert.True(t, ok)
	assert.NotNil(t, m)
	rtErr := route.NewRoute("", uuid.New().String(), uuid.New().String())
	compErr := &component.Remote{Receiver: reflect.ValueOf(tObj), Method: m, HasArgs: m.Type.NumIn() > 2}

	m, ok = reflect.TypeOf(tObj).MethodByName("Remote2")
	assert.True(t, ok)
	assert.NotNil(t, m)
	rtStr := route.NewRoute("", uuid.New().String(), uuid.New().String())
	compStr := &component.Remote{Receiver: reflect.ValueOf(tObj), Method: m, HasArgs: m.Type.NumIn() > 2}

	m, ok = reflect.TypeOf(tObj).MethodByName("RemoteRes")
	assert.True(t, ok)
	assert.NotNil(t, m)
	rtRes := route.NewRoute("", uuid.New().String(), uuid.New().String())
	compRes := &component.Remote{Receiver: reflect.ValueOf(tObj), Method: m, HasArgs: m.Type.NumIn() > 2, Type: reflect.TypeOf(&test.SomeStruct{B: "aa"})}

	b, err := proto.Marshal(&test.SomeStruct{B: "aa"})
	assert.NoError(t, err)
	tables := []struct {
		name         string
		req          *protos.Request
		rt           *route.Route
		errSubstring string
	}{
		{"remote_not_found", &protos.Request{Msg: &protos.Msg{}}, route.NewRoute("bla", "bla", "bla"), "route not found"},
		{"failed_unmarshal", &protos.Request{Msg: &protos.Msg{Data: []byte("dd")}}, rt, "reflect: Call using zero Value argument"},
		{"failed_pcall", &protos.Request{Msg: &protos.Msg{}}, rtErr, "remote err"},
		{"success_nil_response", &protos.Request{Msg: &protos.Msg{}}, rtStr, ""},
		{"success_response", &protos.Request{Msg: &protos.Msg{Data: b}}, rtRes, ""},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			packetEncoder := codec.NewPomeloPacketEncoder()
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			mockSerializer := serializemocks.NewMockSerializer(ctrl)
			mockSD := clustermocks.NewMockServiceDiscovery(ctrl)
			mockRPCClient := clustermocks.NewMockRPCClient(ctrl)
			mockRPCServer := clustermocks.NewMockRPCServer(ctrl)
			messageEncoder := message.NewMessagesEncoder(false)
			router := router.New()
			sessionPool := session.NewSessionPool()
			svc := NewRemoteService(mockRPCClient, mockRPCServer, mockSD, packetEncoder, mockSerializer, router, messageEncoder, &cluster.Server{}, sessionPool, pipeline.NewRemoteHooks(), pipeline.NewHandlerHooks(), handlerPool)

			svc.remotes[rt.Short()] = comp
			svc.remotes[rtErr.Short()] = compErr
			svc.remotes[rtStr.Short()] = compStr
			svc.remotes[rtRes.Short()] = compRes

			assert.NotNil(t, svc)
			res := svc.handleRPCUser(context.Background(), table.req, table.rt)
			assert.NoError(t, err)
			if table.errSubstring != "" {
				assert.Contains(t, res.Error.Msg, table.errSubstring)
			} else if table.req.Msg.Data != nil {
				assert.NotNil(t, res.Data)
			}
		})
	}
}

func TestRemoteServiceHandleRPCUserWithHooks(t *testing.T) {
	handlerPool := NewHandlerPool()

	tObj := &MyComp{}
	m, ok := reflect.TypeOf(tObj).MethodByName("Remote1")
	assert.True(t, ok)
	assert.NotNil(t, m)
	rt := route.NewRoute("", uuid.New().String(), uuid.New().String())
	comp := &component.Remote{Receiver: reflect.ValueOf(tObj), Method: m, HasArgs: m.Type.NumIn() > 2}

	m, ok = reflect.TypeOf(tObj).MethodByName("RemoteErr")
	assert.True(t, ok)
	assert.NotNil(t, m)
	rtErr := route.NewRoute("", uuid.New().String(), uuid.New().String())
	compErr := &component.Remote{Receiver: reflect.ValueOf(tObj), Method: m, HasArgs: m.Type.NumIn() > 2}

	m, ok = reflect.TypeOf(tObj).MethodByName("Remote2")
	assert.True(t, ok)
	assert.NotNil(t, m)
	rtStr := route.NewRoute("", uuid.New().String(), uuid.New().String())
	compStr := &component.Remote{Receiver: reflect.ValueOf(tObj), Method: m, HasArgs: m.Type.NumIn() > 2}

	m, ok = reflect.TypeOf(tObj).MethodByName("RemoteRes")
	assert.True(t, ok)
	assert.NotNil(t, m)
	rtRes := route.NewRoute("", uuid.New().String(), uuid.New().String())
	compRes := &component.Remote{Receiver: reflect.ValueOf(tObj), Method: m, HasArgs: m.Type.NumIn() > 2, Type: reflect.TypeOf(&test.SomeStruct{B: "aa"})}

	b, err := proto.Marshal(&test.SomeStruct{B: "aa"})
	assert.NoError(t, err)

	modifiedInput := &test.SomeStruct{B: "cc"}

	modifiedResponse, err := proto.Marshal(modifiedInput)
	assert.NoError(t, err)

	modifiedCtx := context.WithValue(context.Background(), ctxModifiedResponse, modifiedInput)
	tables := []struct {
		name                string
		req                 *protos.Request
		rt                  *route.Route
		expectedOutput      []byte
		errSubstring        string
		shouldRunBeforeHook bool
		shouldRunAfterHook  bool
		modifiedInput       interface{}
		modifiedCtx         context.Context
		modifiedInputError  error
		modifiedOutput      interface{}
		modifiedOutputError error
	}{
		{"remote_not_found", &protos.Request{Msg: &protos.Msg{}}, route.NewRoute("bla", "bla", "bla"), nil, "route not found", false, false, nil, nil, nil, nil, nil},
		{"failed_unmarshal", &protos.Request{Msg: &protos.Msg{Data: []byte("dd")}}, rt, nil, "reflect: Call using zero Value argument", true, true, nil, nil, nil, nil, nil},
		{"failed_pcall", &protos.Request{Msg: &protos.Msg{}}, rtErr, nil, "remote err", true, true, nil, nil, nil, nil, nil},
		{"failed_before_hook", &protos.Request{Msg: &protos.Msg{}}, rtErr, nil, "before hook err", true, false, nil, nil, fmt.Errorf("before hook err"), nil, nil},
		{"failed_pcall_modified_err", &protos.Request{Msg: &protos.Msg{}}, rtErr, nil, "remote err modified output", true, true, nil, nil, nil, nil, fmt.Errorf("remote err modified output")},
		{"success_nil_response", &protos.Request{Msg: &protos.Msg{}}, rtStr, nil, "", true, true, nil, nil, nil, nil, nil},
		{"success_response", &protos.Request{Msg: &protos.Msg{Data: b}}, rtRes, b, "", true, true, nil, nil, nil, nil, nil},
		{"success_response_modified_ctx", &protos.Request{Msg: &protos.Msg{Data: b}}, rtRes, modifiedResponse, "", true, true, nil, modifiedCtx, nil, nil, nil},
		{"success_response_modified_input", &protos.Request{Msg: &protos.Msg{Data: b}}, rtRes, modifiedResponse, "", true, true, modifiedInput, nil, nil, nil, nil},
		{"success_response_modified_input_ctx", &protos.Request{Msg: &protos.Msg{Data: b}}, rtRes, modifiedResponse, "", true, true, modifiedInput, modifiedCtx, nil, nil, nil},
		{"success_response_modified_output", &protos.Request{Msg: &protos.Msg{Data: b}}, rtRes, modifiedResponse, "", true, true, nil, nil, nil, modifiedInput, nil},
		{"failed_after_hook", &protos.Request{Msg: &protos.Msg{Data: b}}, rtRes, nil, "after hook err", true, true, nil, nil, nil, nil, fmt.Errorf("after hook err")},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			packetEncoder := codec.NewPomeloPacketEncoder()
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			mockSerializer := serializemocks.NewMockSerializer(ctrl)
			mockSD := clustermocks.NewMockServiceDiscovery(ctrl)
			mockRPCClient := clustermocks.NewMockRPCClient(ctrl)
			mockRPCServer := clustermocks.NewMockRPCServer(ctrl)
			messageEncoder := message.NewMessagesEncoder(false)
			router := router.New()
			sessionPool := session.NewSessionPool()

			beforeHookInvoked := false
			afterHookInvoked := false

			remoteHooks := pipeline.NewRemoteHooks()
			remoteHooks.BeforeHandler.PushFront(func(ctx context.Context, in interface{}) (context.Context, interface{}, error) {
				if beforeHookInvoked {
					assert.FailNow(t, "BeforeHandler hook invoked twice")
				}
				if afterHookInvoked {
					assert.FailNow(t, "BeforeHandler and AfterHandler hooks running out of order")
				}

				var err error
				if table.modifiedInput != nil {
					in = table.modifiedInput
				}
				if table.modifiedCtx != nil {
					ctx = table.modifiedCtx
				}
				if table.modifiedInputError != nil {
					err = table.modifiedInputError
				}

				beforeHookInvoked = true
				return ctx, in, err
			})
			remoteHooks.AfterHandler.PushFront(func(ctx context.Context, out interface{}, err error) (interface{}, error) {
				if afterHookInvoked {
					assert.FailNow(t, "AfterHandler hook invoked twice")
				}
				if !beforeHookInvoked {
					assert.FailNow(t, "BeforeHandler and AfterHandler hooks running out of order")
				}

				if table.modifiedOutput != nil {
					out = table.modifiedOutput
				}
				if table.modifiedOutputError != nil {
					err = table.modifiedOutputError
				}

				afterHookInvoked = true
				return out, err
			})

			svc := NewRemoteService(mockRPCClient, mockRPCServer, mockSD, packetEncoder, mockSerializer, router, messageEncoder, &cluster.Server{}, sessionPool, remoteHooks, pipeline.NewHandlerHooks(), handlerPool)

			svc.remotes[rt.Short()] = comp
			svc.remotes[rtErr.Short()] = compErr
			svc.remotes[rtStr.Short()] = compStr
			svc.remotes[rtRes.Short()] = compRes

			assert.NotNil(t, svc)

			assert.False(t, beforeHookInvoked, "Before hook invoked before RPC")
			assert.False(t, afterHookInvoked, "After hook invoked before RPC")

			res := svc.handleRPCUser(context.Background(), table.req, table.rt)

			if table.shouldRunBeforeHook {
				assert.True(t, beforeHookInvoked, "After hook was never invoked")
			} else {
				assert.False(t, beforeHookInvoked, "After hook should not have run")
			}
			if table.shouldRunAfterHook {
				assert.True(t, afterHookInvoked, "After hook was never invoked")
			} else {
				assert.False(t, afterHookInvoked, "After hook should not have run")
			}

			assert.NoError(t, err)
			if table.errSubstring != "" {
				assert.Contains(t, res.Error.Msg, table.errSubstring)
			} else if table.req.Msg.Data != nil {
				assert.NotNil(t, res.Data)
			}

			assert.Equal(t, res.Data, table.expectedOutput)
		})
	}
}

func TestRemoteServiceHandleRPCSys(t *testing.T) {
	tObj := &TestType{}
	m, ok := reflect.TypeOf(tObj).MethodByName("HandlerPointerRaw")
	assert.True(t, ok)
	assert.NotNil(t, m)
	rt := route.NewRoute("", uuid.New().String(), uuid.New().String())

	tables := []struct {
		name         string
		req          *protos.Request
		rt           *route.Route
		errSubstring string
	}{
		{"new_remote_err", &protos.Request{
			Msg:     &protos.Msg{Reply: uuid.New().String()},
			Session: &protos.Session{Data: []byte("{no")},
		}, nil, "invalid character 'n' looking for beginning of object key string"},
		{"process_handler_msg_err", &protos.Request{Msg: &protos.Msg{Reply: uuid.New().String()}}, route.NewRoute("bla", "bla", "bla"), "bla.bla.bla not found"},
		{"success", &protos.Request{Msg: &protos.Msg{Data: []byte("ok")}}, rt, ""},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			packetEncoder := codec.NewPomeloPacketEncoder()
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			mockSerializer := serializemocks.NewMockSerializer(ctrl)
			mockSD := clustermocks.NewMockServiceDiscovery(ctrl)
			mockRPCClient := clustermocks.NewMockRPCClient(ctrl)
			mockRPCServer := clustermocks.NewMockRPCServer(ctrl)
			messageEncoder := message.NewMessagesEncoder(false)
			router := router.New()
			sessionPool := session.NewSessionPool()
			handlerPool := NewHandlerPool()
			handlerPool.handlers[rt.Short()] = &component.Handler{Receiver: reflect.ValueOf(tObj), Method: m, Type: m.Type.In(2)}
			svc := NewRemoteService(mockRPCClient, mockRPCServer, mockSD, packetEncoder, mockSerializer, router, messageEncoder, &cluster.Server{}, sessionPool, nil, pipeline.NewHandlerHooks(), handlerPool)
			assert.NotNil(t, svc)

			if table.errSubstring == "" {
				mockSerializer.EXPECT().Unmarshal(gomock.Any(), gomock.Any()).Return(nil)
			}
			res := svc.handleRPCSys(nil, table.req, table.rt)

			if table.errSubstring != "" {
				assert.Contains(t, res.Error.Msg, table.errSubstring)
			} else {
				assert.Equal(t, table.req.Msg.Data, res.Data)
			}

		})
	}
}

func TestRemoteServiceRemoteProcess(t *testing.T) {
	sv := &cluster.Server{}
	rt := route.NewRoute("sv", "svc", "method")

	tables := []struct {
		name           string
		msgType        message.Type
		remoteCallErr  error
		responseMIDErr error
	}{
		{"failed_remote_call", message.Request, errors.New("rpc failed"), nil},
		{"failed_response_mid", message.Request, nil, errors.New("err")},
		{"success_request", message.Request, nil, nil},
		{"success_notify", message.Notify, nil, nil},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			expectedMsg := &message.Message{
				ID:    uint(rand.Int()),
				Type:  table.msgType,
				Route: rt.Short(),
				Data:  []byte("ok"),
			}
			ctx := context.Background()

			packetEncoder := codec.NewPomeloPacketEncoder()
			mockSerializer := serializemocks.NewMockSerializer(ctrl)
			mockSD := clustermocks.NewMockServiceDiscovery(ctrl)
			mockRPCClient := clustermocks.NewMockRPCClient(ctrl)
			mockRPCServer := clustermocks.NewMockRPCServer(ctrl)
			messageEncoder := message.NewMessagesEncoder(false)
			router := router.New()
			sessionPool := session.NewSessionPool()
			mockSession := sessionmocks.NewMockSession(ctrl)

			mockAgent := agentmocks.NewMockAgent(ctrl)
			mockAgent.EXPECT().GetSession().Return(mockSession).AnyTimes()

			mockRPCClient.EXPECT().Call(ctx, protos.RPCType_Sys, rt, gomock.Any(), expectedMsg, gomock.Any()).Return(&protos.Response{Data: []byte("ok")}, table.remoteCallErr)

			if table.remoteCallErr != nil {
				mockAgent.EXPECT().AnswerWithError(ctx, expectedMsg.ID, gomock.Any())
			} else if expectedMsg.Type != message.Notify {
				mockSession.EXPECT().ResponseMID(ctx, expectedMsg.ID, gomock.Any()).Return(table.responseMIDErr)
			}
			mockSession.EXPECT().UID()

			if table.responseMIDErr != nil {
				mockAgent.EXPECT().AnswerWithError(ctx, expectedMsg.ID, table.responseMIDErr)
			}

			svc := NewRemoteService(mockRPCClient, mockRPCServer, mockSD, packetEncoder, mockSerializer, router, messageEncoder, &cluster.Server{}, sessionPool, nil, pipeline.NewHandlerHooks(), nil)
			svc.remoteProcess(ctx, sv, mockAgent, rt, expectedMsg)
		})
	}
}

func TestRemoteServiceRPC(t *testing.T) {
	rt := route.NewRoute("sv", "svc", "method")
	tables := []struct {
		name        string
		serverID    string
		reply       proto.Message
		arg         proto.Message
		foundServer bool
		err         error
	}{
		{"server_id_and_no_target", "serverId", nil, &test.SomeStruct{}, false, constants.ErrServerNotFound},
		{"failed_remote_call", "serverId", nil, &test.SomeStruct{}, true, errors.New("rpc failed")},
		{"success", "serverId", &test.SomeStruct{}, &test.SomeStruct{}, true, nil},
		{"success_nil_reply", "serverId", nil, &test.SomeStruct{}, true, nil},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			packetEncoder := codec.NewPomeloPacketEncoder()
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			mockSerializer := serializemocks.NewMockSerializer(ctrl)
			mockSD := clustermocks.NewMockServiceDiscovery(ctrl)
			mockRPCClient := clustermocks.NewMockRPCClient(ctrl)
			mockRPCServer := clustermocks.NewMockRPCServer(ctrl)
			messageEncoder := message.NewMessagesEncoder(false)
			router := router.New()
			sessionPool := session.NewSessionPool()
			svc := NewRemoteService(mockRPCClient, mockRPCServer, mockSD, packetEncoder, mockSerializer, router, messageEncoder, &cluster.Server{}, sessionPool, nil, pipeline.NewHandlerHooks(), nil)
			assert.NotNil(t, svc)

			if table.serverID != "" {
				var sdRet *cluster.Server
				if table.foundServer {
					sdRet = &cluster.Server{}
				}
				mockSD.EXPECT().GetServer(table.serverID).Return(sdRet, nil)
			}

			var expected *test.SomeStruct
			ctx := context.Background()
			if table.foundServer {
				expectedData, _ := proto.Marshal(table.arg)
				expectedMsg := &message.Message{
					Type:  message.Request,
					Route: rt.Short(),
					Data:  expectedData,
				}

				expected = &test.SomeStruct{}
				b, err := proto.Marshal(expected)

				assert.NoError(t, err)
				mockRPCClient.EXPECT().Call(ctx, protos.RPCType_User, rt, gomock.Any(), expectedMsg, gomock.Any()).Return(&protos.Response{Data: b}, table.err)
			}

			err := svc.RPC(ctx, table.serverID, rt, table.reply, table.arg)
			assert.Equal(t, table.err, err)
			if table.reply != nil {
				// We should consider dropping XXX_NoUnkeyedLiteral, XXX_unrecognized and XXX_sizecache from generated protobufs as this is unuseful overhead
				expected.XXX_sizecache = 0
				assert.Equal(t, table.reply, expected)
			}
		})
	}
}

```

`pkg/service/util.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package service

import (
	"context"
	"errors"
	"reflect"

	"github.com/golang/protobuf/proto"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	e "github.com/topfreegames/pitaya/v3/pkg/errors"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/logger/interfaces"
	"github.com/topfreegames/pitaya/v3/pkg/pipeline"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/route"
	"github.com/topfreegames/pitaya/v3/pkg/serialize"
	"github.com/topfreegames/pitaya/v3/pkg/session"
	"github.com/topfreegames/pitaya/v3/pkg/util"
)

var errInvalidMsg = errors.New("invalid message type provided")

func unmarshalHandlerArg(handler *component.Handler, serializer serialize.Serializer, payload []byte) (interface{}, error) {
	if handler.IsRawArg {
		return payload, nil
	}

	var arg interface{}
	if handler.Type != nil {
		arg = reflect.New(handler.Type.Elem()).Interface()
		err := serializer.Unmarshal(payload, arg)
		if err != nil {
			return nil, err
		}
	}
	return arg, nil
}

func unmarshalRemoteArg(remote *component.Remote, payload []byte) (interface{}, error) {
	var arg interface{}
	if remote.Type != nil {
		arg = reflect.New(remote.Type.Elem()).Interface()
		pb, ok := arg.(proto.Message)
		if !ok {
			return nil, constants.ErrWrongValueType
		}
		err := proto.Unmarshal(payload, pb)
		if err != nil {
			return nil, err
		}
	}
	return arg, nil
}

func getMsgType(msgTypeIface interface{}) (message.Type, error) {
	var msgType message.Type
	if val, ok := msgTypeIface.(message.Type); ok {
		msgType = val
	} else if val, ok := msgTypeIface.(protos.MsgType); ok {
		msgType = util.ConvertProtoToMessageType(val)
	} else {
		return msgType, errInvalidMsg
	}
	return msgType, nil
}

func serializeReturn(ser serialize.Serializer, ret interface{}) ([]byte, error) {
	res, err := util.SerializeOrRaw(ser, ret)
	if err != nil {
		logger.Log.Errorf("Failed to serialize return: %s", err.Error())
		res, err = util.GetErrorPayload(ser, err)
		if err != nil {
			logger.Log.Error("cannot serialize message and respond to the client ", err.Error())
			return nil, err
		}
	}
	return res, nil
}

func processHandlerMessage(
	ctx context.Context,
	rt *route.Route,
	handler *component.Handler,
	serializer serialize.Serializer,
	handlerHooks *pipeline.HandlerHooks,
	session session.Session,
	data []byte,
	msgTypeIface interface{},
	remote bool,
) ([]byte, error) {
	if ctx == nil {
		ctx = context.Background()
	}
	ctx = context.WithValue(ctx, constants.SessionCtxKey, session)
	ctx = util.CtxWithDefaultLogger(ctx, rt.String(), session.UID())

	msgType, err := getMsgType(msgTypeIface)
	if err != nil {
		return nil, e.NewError(err, e.ErrInternalCode)
	}

	logger := ctx.Value(constants.LoggerCtxKey).(interfaces.Logger)
	exit, err := handler.ValidateMessageType(msgType)
	if err != nil && exit {
		return nil, e.NewError(err, e.ErrBadRequestCode)
	} else if err != nil {
		logger.Warnf("invalid message type, error: %s", err.Error())
	}

	// First unmarshal the handler arg that will be passed to
	// both handler and pipeline functions
	arg, err := unmarshalHandlerArg(handler, serializer, data)
	if err != nil {
		return nil, e.NewError(err, e.ErrBadRequestCode)
	}

	ctx, arg, err = handlerHooks.BeforeHandler.ExecuteBeforePipeline(ctx, arg)
	if err != nil {
		return nil, err
	}

	logger.Debugf("SID=%d, Data=%s", session.ID(), data)
	args := []reflect.Value{handler.Receiver, reflect.ValueOf(ctx)}
	if arg != nil {
		args = append(args, reflect.ValueOf(arg))
	}

	resp, err := util.Pcall(handler.Method, args)
	if remote && msgType == message.Notify {
		// This is a special case and should only happen with nats rpc client
		// because we used nats request we have to answer to it or else a timeout
		// will happen in the caller server and will be returned to the client
		// the reason why we don't just Publish is to keep track of failed rpc requests
		// with timeouts, maybe we can improve this flow
		resp = []byte("ack")
	}

	resp, err = handlerHooks.AfterHandler.ExecuteAfterPipeline(ctx, resp, err)
	if err != nil {
		return nil, err
	}

	ret, err := serializeReturn(serializer, resp)
	if err != nil {
		return nil, err
	}

	return ret, nil
}

```

`pkg/service/util_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package service

import (
	"context"
	"errors"
	"flag"
	"path/filepath"
	"reflect"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/golang/protobuf/proto"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/helpers"
	"github.com/topfreegames/pitaya/v3/pkg/pipeline"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/protos/test"
	"github.com/topfreegames/pitaya/v3/pkg/serialize/mocks"
)

var update = flag.Bool("update", false, "update .golden files")

type TestType struct {
	component.Base
}

func (t *TestType) HandlerNil(context.Context)                              {}
func (t *TestType) HandlerRaw(ctx context.Context, msg []byte)              {}
func (t *TestType) HandlerPointer(ctx context.Context, ss *test.SomeStruct) {}
func (t *TestType) HandlerPointerRaw(ctx context.Context, ss *test.SomeStruct) ([]byte, error) {
	return []byte("ok"), nil
}
func (t *TestType) HandlerPointerStruct(ctx context.Context, ss *test.SomeStruct) (*test.SomeStruct, error) {
	return &test.SomeStruct{A: 1, B: "ok"}, nil
}
func (t *TestType) HandlerPointerErr(ctx context.Context, ss *test.SomeStruct) ([]byte, error) {
	return nil, errors.New("HandlerPointerErr")
}

func TestUnmarshalHandlerArg(t *testing.T) {
	t.Parallel()
	tables := []struct {
		name        string
		handlerName string
		isRawArg    bool
		payload     []byte
		out         interface{}
		err         error
	}{
		{"raw_arg", "HandlerRaw", true, []byte("hello"), []byte("hello"), nil},
		{"nil_handler", "HandlerNil", false, []byte("hello"), nil, nil},
		{"struct_handler", "HandlerPointer", false, []byte("hello"), &test.SomeStruct{}, nil},
		{"struct_handler_err", "HandlerPointer", false, []byte("hello"), nil, errors.New("some error")},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			mockSerializer := mocks.NewMockSerializer(ctrl)

			tObj := &TestType{}
			m, ok := reflect.TypeOf(tObj).MethodByName(table.handlerName)
			assert.True(t, ok)
			assert.NotNil(t, m)
			handler := &component.Handler{
				Method:   m,
				IsRawArg: table.isRawArg,
			}
			mt := m.Type
			if mt.NumIn() == 3 {
				handler.Type = mt.In(2)
			}

			if !table.isRawArg && handler.Type != nil {
				mockSerializer.EXPECT().Unmarshal(
					table.payload,
					reflect.New(handler.Type.Elem()).Interface(),
				).Do(func(p []byte, arg interface{}) {
					arg = table.out
				}).Return(table.err)
			}

			arg, err := unmarshalHandlerArg(handler, mockSerializer, table.payload)
			assert.Equal(t, table.err, err)
			assert.Equal(t, table.out, arg)
		})
	}
}

func TestUnmarshalRemoteArg(t *testing.T) {
	t.Parallel()
	tables := []struct {
		name string
		arg  proto.Message
	}{
		{"unmarshal_remote_test_1", &test.SomeStruct{A: 1, B: "blah"}},
		{"unmarshal_remote_test_2", &test.SomeStruct{A: 1, B: "aaa"}},
		{"unmarshal_remote_test_3", &test.SomeStruct{B: "aab"}},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			gp := filepath.Join("fixtures", table.name+".golden")
			if *update {
				b, err := proto.Marshal(table.arg)
				require.NoError(t, err)
				t.Log("updating golden file")
				helpers.WriteFile(t, gp, b)
			}
			payload := helpers.ReadFile(t, gp)

			remote := &component.Remote{
				Type: reflect.TypeOf(&test.SomeStruct{}),
			}

			arg, err := unmarshalRemoteArg(remote, payload)
			assert.NoError(t, err)
			assert.Equal(t, table.arg, arg)
		})
	}
}

func TestUnmarshalRemoteArgErr(t *testing.T) {
	t.Parallel()
	remote := &component.Remote{
		Type: reflect.TypeOf(&test.SomeStruct{}),
	}
	args, err := unmarshalRemoteArg(remote, []byte("arg"))
	assert.Empty(t, args)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "cannot parse invalid wire-format data")
}

func TestGetMsgType(t *testing.T) {
	t.Parallel()
	tables := []struct {
		name    string
		in      interface{}
		msgType message.Type
		err     error
	}{
		{"request", message.Request, message.Request, nil},
		{"notify", message.Notify, message.Notify, nil},
		{"response", message.Response, message.Response, nil},
		{"push", message.Push, message.Push, nil},
		{"protos_request", protos.MsgType_MsgRequest, message.Request, nil},
		{"protos_notify", protos.MsgType_MsgNotify, message.Notify, nil},
		{"invalid", "oops", message.Request, errInvalidMsg},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			msgType, err := getMsgType(table.in)
			assert.Equal(t, table.err, err)
			assert.Equal(t, table.msgType, msgType)
		})
	}
}

func TestExecuteBeforePipelineEmpty(t *testing.T) {
	expected := []byte("ok")
	beforeHandler := pipeline.NewChannel()
	_, res, err := beforeHandler.ExecuteBeforePipeline(nil, expected)
	assert.NoError(t, err)
	assert.Equal(t, expected, res)
}

func TestExecuteBeforePipelineSuccess(t *testing.T) {
	c := context.Background()
	data := []byte("ok")
	expected1 := []byte("oh noes 1")
	expected2 := []byte("oh noes 2")
	before1 := func(ctx context.Context, in interface{}) (context.Context, interface{}, error) {
		assert.Equal(t, c, ctx)
		assert.Equal(t, data, in)
		return ctx, expected1, nil
	}
	before2 := func(ctx context.Context, in interface{}) (context.Context, interface{}, error) {
		assert.Equal(t, c, ctx)
		assert.Equal(t, expected1, in)
		return ctx, expected2, nil
	}

	beforeHandler := pipeline.NewChannel()
	beforeHandler.PushBack(before1)
	beforeHandler.PushBack(before2)
	defer beforeHandler.Clear()

	_, res, err := beforeHandler.ExecuteBeforePipeline(c, data)
	assert.NoError(t, err)
	assert.Equal(t, expected2, res)
}

func TestExecuteBeforePipelineError(t *testing.T) {
	c := context.Background()
	expected := errors.New("oh noes")
	before := func(ctx context.Context, in interface{}) (context.Context, interface{}, error) {
		assert.Equal(t, c, ctx)
		return ctx, nil, expected
	}
	beforeHandler := pipeline.NewChannel()
	beforeHandler.PushFront(before)
	defer beforeHandler.Clear()

	_, _, err := beforeHandler.ExecuteBeforePipeline(c, []byte("ok"))
	assert.Equal(t, expected, err)
}

func TestExecuteAfterPipelineEmpty(t *testing.T) {
	expected := []byte("whatever")
	afterHandler := pipeline.NewAfterChannel()
	res, err := afterHandler.ExecuteAfterPipeline(nil, expected, nil)
	assert.Equal(t, expected, res)
	assert.Nil(t, err)
}

func TestExecuteAfterPipelineSuccess(t *testing.T) {
	c := context.Background()
	data := []byte("ok")
	expected1 := []byte("oh noes 1")
	expected2 := []byte("oh noes 2")
	err0 := errors.New("start with this")
	err1 := errors.New("send this error")
	after1 := func(ctx context.Context, out interface{}, err error) (interface{}, error) {
		assert.Equal(t, c, ctx)
		assert.Equal(t, data, out)
		assert.Equal(t, err0, err)
		return expected1, err1
	}
	after2 := func(ctx context.Context, out interface{}, err error) (interface{}, error) {
		assert.Equal(t, c, ctx)
		assert.Equal(t, expected1, out)
		assert.Equal(t, err1, err)
		return expected2, nil
	}
	afterHandler := pipeline.NewAfterChannel()
	afterHandler.PushBack(after1)
	afterHandler.PushBack(after2)
	defer afterHandler.Clear()

	res, err := afterHandler.ExecuteAfterPipeline(c, []byte("ok"), err0)
	assert.Equal(t, expected2, res)
	assert.Nil(t, err)
}

func TestExecuteAfterPipelineError(t *testing.T) {
	c := context.Background()
	after := func(ctx context.Context, out interface{}, err error) (interface{}, error) {
		assert.Equal(t, c, ctx)
		return nil, errors.New("oh noes")
	}
	afterHandler := pipeline.NewAfterChannel()
	afterHandler.PushFront(after)
	defer afterHandler.Clear()

	res, err := afterHandler.ExecuteAfterPipeline(c, []byte("ok"), nil)
	assert.Nil(t, res)
	assert.Equal(t, errors.New("oh noes"), err)
}

func TestSerializeReturn(t *testing.T) {
	tables := []struct {
		name               string
		isRawArg           bool
		in                 interface{}
		out                []byte
		errSerialize       error
		errGetErrorPayload error
	}{
		{"raw_arg", true, []byte("hello"), []byte("hello"), nil, nil},
		{"success", false, test.SomeStruct{A: 1, B: "hello"}, []byte("hello"), nil, nil},
		{"serialize_fail", false, test.SomeStruct{A: 1, B: "hello"}, nil, errors.New("some error"), nil},
		{"serialize_fail_err_payload", false, test.SomeStruct{A: 1, B: "hello"}, nil, errors.New("some error"), errors.New("some other error")},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			mockSerializer := mocks.NewMockSerializer(ctrl)
			if !table.isRawArg {
				mockSerializer.EXPECT().Marshal(gomock.Any()).Return(table.out, table.errSerialize)
				if table.errSerialize != nil {
					mockSerializer.EXPECT().Marshal(gomock.Any()).Return(table.out, table.errGetErrorPayload)
				}
			}
			out, err := serializeReturn(mockSerializer, table.in)
			assert.Equal(t, table.out, out)
			assert.Equal(t, table.errGetErrorPayload, err)
		})
	}
}

```

`pkg/session/fixtures/testSessionSetData_1.golden`:

```golden
{"byte":"AQ=="}
```

`pkg/session/fixtures/testSessionSetData_2.golden`:

```golden
{"int":1}
```

`pkg/session/fixtures/testSessionSetData_3.golden`:

```golden
{"struct":{"A":1,"B":"aaa"}}
```

`pkg/session/fixtures/testSessionSetData_4.golden`:

```golden
{"string":"aaa"}
```

`pkg/session/fixtures/testSessionSetData_5.golden`:

```golden
{}
```

`pkg/session/fixtures/testUpdateEncodedData_1.golden`:

```golden
{"byte":"AQ=="}
```

`pkg/session/fixtures/testUpdateEncodedData_2.golden`:

```golden
{"int":1}
```

`pkg/session/fixtures/testUpdateEncodedData_3.golden`:

```golden
{"struct":{"A":1,"B":"aaa"}}
```

`pkg/session/fixtures/testUpdateEncodedData_4.golden`:

```golden
{"string":"aaa"}
```

`pkg/session/fixtures/testUpdateEncodedData_5.golden`:

```golden
{}
```

`pkg/session/mocks/session.go`:

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/topfreegames/pitaya/v3/pkg/session (interfaces: Session,SessionPool)

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	net "net"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	nats "github.com/nats-io/nats.go"
	networkentity "github.com/topfreegames/pitaya/v3/pkg/networkentity"
	session "github.com/topfreegames/pitaya/v3/pkg/session"
)

// MockSession is a mock of Session interface.
type MockSession struct {
	ctrl     *gomock.Controller
	recorder *MockSessionMockRecorder
}

// MockSessionMockRecorder is the mock recorder for MockSession.
type MockSessionMockRecorder struct {
	mock *MockSession
}

// NewMockSession creates a new mock instance.
func NewMockSession(ctrl *gomock.Controller) *MockSession {
	mock := &MockSession{ctrl: ctrl}
	mock.recorder = &MockSessionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSession) EXPECT() *MockSessionMockRecorder {
	return m.recorder
}

// Bind mocks base method.
func (m *MockSession) Bind(arg0 context.Context, arg1 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Bind", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Bind indicates an expected call of Bind.
func (mr *MockSessionMockRecorder) Bind(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Bind", reflect.TypeOf((*MockSession)(nil).Bind), arg0, arg1)
}

// Clear mocks base method.
func (m *MockSession) Clear() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Clear")
}

// Clear indicates an expected call of Clear.
func (mr *MockSessionMockRecorder) Clear() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Clear", reflect.TypeOf((*MockSession)(nil).Clear))
}

// Close mocks base method.
func (m *MockSession) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockSessionMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockSession)(nil).Close))
}

// Float32 mocks base method.
func (m *MockSession) Float32(arg0 string) float32 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Float32", arg0)
	ret0, _ := ret[0].(float32)
	return ret0
}

// Float32 indicates an expected call of Float32.
func (mr *MockSessionMockRecorder) Float32(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Float32", reflect.TypeOf((*MockSession)(nil).Float32), arg0)
}

// Float64 mocks base method.
func (m *MockSession) Float64(arg0 string) float64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Float64", arg0)
	ret0, _ := ret[0].(float64)
	return ret0
}

// Float64 indicates an expected call of Float64.
func (mr *MockSessionMockRecorder) Float64(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Float64", reflect.TypeOf((*MockSession)(nil).Float64), arg0)
}

// Get mocks base method.
func (m *MockSession) Get(arg0 string) interface{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", arg0)
	ret0, _ := ret[0].(interface{})
	return ret0
}

// Get indicates an expected call of Get.
func (mr *MockSessionMockRecorder) Get(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockSession)(nil).Get), arg0)
}

// GetData mocks base method.
func (m *MockSession) GetData() map[string]interface{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetData")
	ret0, _ := ret[0].(map[string]interface{})
	return ret0
}

// GetData indicates an expected call of GetData.
func (mr *MockSessionMockRecorder) GetData() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetData", reflect.TypeOf((*MockSession)(nil).GetData))
}

// GetDataEncoded mocks base method.
func (m *MockSession) GetDataEncoded() []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetDataEncoded")
	ret0, _ := ret[0].([]byte)
	return ret0
}

// GetDataEncoded indicates an expected call of GetDataEncoded.
func (mr *MockSessionMockRecorder) GetDataEncoded() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDataEncoded", reflect.TypeOf((*MockSession)(nil).GetDataEncoded))
}

// GetHandshakeData mocks base method.
func (m *MockSession) GetHandshakeData() *session.HandshakeData {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetHandshakeData")
	ret0, _ := ret[0].(*session.HandshakeData)
	return ret0
}

// GetHandshakeData indicates an expected call of GetHandshakeData.
func (mr *MockSessionMockRecorder) GetHandshakeData() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetHandshakeData", reflect.TypeOf((*MockSession)(nil).GetHandshakeData))
}

// GetHandshakeValidators mocks base method.
func (m *MockSession) GetHandshakeValidators() map[string]func(*session.HandshakeData) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetHandshakeValidators")
	ret0, _ := ret[0].(map[string]func(*session.HandshakeData) error)
	return ret0
}

// GetHandshakeValidators indicates an expected call of GetHandshakeValidators.
func (mr *MockSessionMockRecorder) GetHandshakeValidators() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetHandshakeValidators", reflect.TypeOf((*MockSession)(nil).GetHandshakeValidators))
}

// GetIsFrontend mocks base method.
func (m *MockSession) GetIsFrontend() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetIsFrontend")
	ret0, _ := ret[0].(bool)
	return ret0
}

// GetIsFrontend indicates an expected call of GetIsFrontend.
func (mr *MockSessionMockRecorder) GetIsFrontend() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetIsFrontend", reflect.TypeOf((*MockSession)(nil).GetIsFrontend))
}

// GetOnCloseCallbacks mocks base method.
func (m *MockSession) GetOnCloseCallbacks() []func() {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetOnCloseCallbacks")
	ret0, _ := ret[0].([]func())
	return ret0
}

// GetOnCloseCallbacks indicates an expected call of GetOnCloseCallbacks.
func (mr *MockSessionMockRecorder) GetOnCloseCallbacks() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOnCloseCallbacks", reflect.TypeOf((*MockSession)(nil).GetOnCloseCallbacks))
}

// GetRequestsInFlight mocks base method.
func (m *MockSession) GetRequestsInFlight() session.ReqInFlight {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRequestsInFlight")
	ret0, _ := ret[0].(session.ReqInFlight)
	return ret0
}

// GetRequestsInFlight indicates an expected call of GetRequestsInFlight.
func (mr *MockSessionMockRecorder) GetRequestsInFlight() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRequestsInFlight", reflect.TypeOf((*MockSession)(nil).GetRequestsInFlight))
}

// GetSubscriptions mocks base method.
func (m *MockSession) GetSubscriptions() []*nats.Subscription {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSubscriptions")
	ret0, _ := ret[0].([]*nats.Subscription)
	return ret0
}

// GetSubscriptions indicates an expected call of GetSubscriptions.
func (mr *MockSessionMockRecorder) GetSubscriptions() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSubscriptions", reflect.TypeOf((*MockSession)(nil).GetSubscriptions))
}

// HasKey mocks base method.
func (m *MockSession) HasKey(arg0 string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasKey", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasKey indicates an expected call of HasKey.
func (mr *MockSessionMockRecorder) HasKey(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasKey", reflect.TypeOf((*MockSession)(nil).HasKey), arg0)
}

// HasRequestsInFlight mocks base method.
func (m *MockSession) HasRequestsInFlight() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasRequestsInFlight")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasRequestsInFlight indicates an expected call of HasRequestsInFlight.
func (mr *MockSessionMockRecorder) HasRequestsInFlight() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasRequestsInFlight", reflect.TypeOf((*MockSession)(nil).HasRequestsInFlight))
}

// ID mocks base method.
func (m *MockSession) ID() int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(int64)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockSessionMockRecorder) ID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockSession)(nil).ID))
}

// Int mocks base method.
func (m *MockSession) Int(arg0 string) int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Int", arg0)
	ret0, _ := ret[0].(int)
	return ret0
}

// Int indicates an expected call of Int.
func (mr *MockSessionMockRecorder) Int(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Int", reflect.TypeOf((*MockSession)(nil).Int), arg0)
}

// Int16 mocks base method.
func (m *MockSession) Int16(arg0 string) int16 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Int16", arg0)
	ret0, _ := ret[0].(int16)
	return ret0
}

// Int16 indicates an expected call of Int16.
func (mr *MockSessionMockRecorder) Int16(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Int16", reflect.TypeOf((*MockSession)(nil).Int16), arg0)
}

// Int32 mocks base method.
func (m *MockSession) Int32(arg0 string) int32 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Int32", arg0)
	ret0, _ := ret[0].(int32)
	return ret0
}

// Int32 indicates an expected call of Int32.
func (mr *MockSessionMockRecorder) Int32(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Int32", reflect.TypeOf((*MockSession)(nil).Int32), arg0)
}

// Int64 mocks base method.
func (m *MockSession) Int64(arg0 string) int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Int64", arg0)
	ret0, _ := ret[0].(int64)
	return ret0
}

// Int64 indicates an expected call of Int64.
func (mr *MockSessionMockRecorder) Int64(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Int64", reflect.TypeOf((*MockSession)(nil).Int64), arg0)
}

// Int8 mocks base method.
func (m *MockSession) Int8(arg0 string) int8 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Int8", arg0)
	ret0, _ := ret[0].(int8)
	return ret0
}

// Int8 indicates an expected call of Int8.
func (mr *MockSessionMockRecorder) Int8(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Int8", reflect.TypeOf((*MockSession)(nil).Int8), arg0)
}

// Kick mocks base method.
func (m *MockSession) Kick(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Kick", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Kick indicates an expected call of Kick.
func (mr *MockSessionMockRecorder) Kick(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Kick", reflect.TypeOf((*MockSession)(nil).Kick), arg0)
}

// OnClose mocks base method.
func (m *MockSession) OnClose(arg0 func()) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OnClose", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// OnClose indicates an expected call of OnClose.
func (mr *MockSessionMockRecorder) OnClose(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnClose", reflect.TypeOf((*MockSession)(nil).OnClose), arg0)
}

// Push mocks base method.
func (m *MockSession) Push(arg0 string, arg1 interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Push", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Push indicates an expected call of Push.
func (mr *MockSessionMockRecorder) Push(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Push", reflect.TypeOf((*MockSession)(nil).Push), arg0, arg1)
}

// PushToFront mocks base method.
func (m *MockSession) PushToFront(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PushToFront", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// PushToFront indicates an expected call of PushToFront.
func (mr *MockSessionMockRecorder) PushToFront(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PushToFront", reflect.TypeOf((*MockSession)(nil).PushToFront), arg0)
}

// RemoteAddr mocks base method.
func (m *MockSession) RemoteAddr() net.Addr {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoteAddr")
	ret0, _ := ret[0].(net.Addr)
	return ret0
}

// RemoteAddr indicates an expected call of RemoteAddr.
func (mr *MockSessionMockRecorder) RemoteAddr() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoteAddr", reflect.TypeOf((*MockSession)(nil).RemoteAddr))
}

// Remove mocks base method.
func (m *MockSession) Remove(arg0 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Remove", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Remove indicates an expected call of Remove.
func (mr *MockSessionMockRecorder) Remove(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Remove", reflect.TypeOf((*MockSession)(nil).Remove), arg0)
}

// ResponseMID mocks base method.
func (m *MockSession) ResponseMID(arg0 context.Context, arg1 uint, arg2 interface{}, arg3 ...bool) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ResponseMID", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ResponseMID indicates an expected call of ResponseMID.
func (mr *MockSessionMockRecorder) ResponseMID(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResponseMID", reflect.TypeOf((*MockSession)(nil).ResponseMID), varargs...)
}

// Set mocks base method.
func (m *MockSession) Set(arg0 string, arg1 interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Set", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Set indicates an expected call of Set.
func (mr *MockSessionMockRecorder) Set(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockSession)(nil).Set), arg0, arg1)
}

// SetData mocks base method.
func (m *MockSession) SetData(arg0 map[string]interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetData", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetData indicates an expected call of SetData.
func (mr *MockSessionMockRecorder) SetData(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetData", reflect.TypeOf((*MockSession)(nil).SetData), arg0)
}

// SetDataEncoded mocks base method.
func (m *MockSession) SetDataEncoded(arg0 []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetDataEncoded", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetDataEncoded indicates an expected call of SetDataEncoded.
func (mr *MockSessionMockRecorder) SetDataEncoded(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetDataEncoded", reflect.TypeOf((*MockSession)(nil).SetDataEncoded), arg0)
}

// SetFrontendData mocks base method.
func (m *MockSession) SetFrontendData(arg0 string, arg1 int64) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetFrontendData", arg0, arg1)
}

// SetFrontendData indicates an expected call of SetFrontendData.
func (mr *MockSessionMockRecorder) SetFrontendData(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetFrontendData", reflect.TypeOf((*MockSession)(nil).SetFrontendData), arg0, arg1)
}

// SetHandshakeData mocks base method.
func (m *MockSession) SetHandshakeData(arg0 *session.HandshakeData) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetHandshakeData", arg0)
}

// SetHandshakeData indicates an expected call of SetHandshakeData.
func (mr *MockSessionMockRecorder) SetHandshakeData(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetHandshakeData", reflect.TypeOf((*MockSession)(nil).SetHandshakeData), arg0)
}

// SetIsFrontend mocks base method.
func (m *MockSession) SetIsFrontend(arg0 bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetIsFrontend", arg0)
}

// SetIsFrontend indicates an expected call of SetIsFrontend.
func (mr *MockSessionMockRecorder) SetIsFrontend(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetIsFrontend", reflect.TypeOf((*MockSession)(nil).SetIsFrontend), arg0)
}

// SetOnCloseCallbacks mocks base method.
func (m *MockSession) SetOnCloseCallbacks(arg0 []func()) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetOnCloseCallbacks", arg0)
}

// SetOnCloseCallbacks indicates an expected call of SetOnCloseCallbacks.
func (mr *MockSessionMockRecorder) SetOnCloseCallbacks(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetOnCloseCallbacks", reflect.TypeOf((*MockSession)(nil).SetOnCloseCallbacks), arg0)
}

// SetRequestInFlight mocks base method.
func (m *MockSession) SetRequestInFlight(arg0, arg1 string, arg2 bool) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetRequestInFlight", arg0, arg1, arg2)
}

// SetRequestInFlight indicates an expected call of SetRequestInFlight.
func (mr *MockSessionMockRecorder) SetRequestInFlight(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetRequestInFlight", reflect.TypeOf((*MockSession)(nil).SetRequestInFlight), arg0, arg1, arg2)
}

// SetSubscriptions mocks base method.
func (m *MockSession) SetSubscriptions(arg0 []*nats.Subscription) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetSubscriptions", arg0)
}

// SetSubscriptions indicates an expected call of SetSubscriptions.
func (mr *MockSessionMockRecorder) SetSubscriptions(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetSubscriptions", reflect.TypeOf((*MockSession)(nil).SetSubscriptions), arg0)
}

// String mocks base method.
func (m *MockSession) String(arg0 string) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "String", arg0)
	ret0, _ := ret[0].(string)
	return ret0
}

// String indicates an expected call of String.
func (mr *MockSessionMockRecorder) String(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "String", reflect.TypeOf((*MockSession)(nil).String), arg0)
}

// UID mocks base method.
func (m *MockSession) UID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UID")
	ret0, _ := ret[0].(string)
	return ret0
}

// UID indicates an expected call of UID.
func (mr *MockSessionMockRecorder) UID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UID", reflect.TypeOf((*MockSession)(nil).UID))
}

// Uint mocks base method.
func (m *MockSession) Uint(arg0 string) uint {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Uint", arg0)
	ret0, _ := ret[0].(uint)
	return ret0
}

// Uint indicates an expected call of Uint.
func (mr *MockSessionMockRecorder) Uint(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Uint", reflect.TypeOf((*MockSession)(nil).Uint), arg0)
}

// Uint16 mocks base method.
func (m *MockSession) Uint16(arg0 string) uint16 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Uint16", arg0)
	ret0, _ := ret[0].(uint16)
	return ret0
}

// Uint16 indicates an expected call of Uint16.
func (mr *MockSessionMockRecorder) Uint16(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Uint16", reflect.TypeOf((*MockSession)(nil).Uint16), arg0)
}

// Uint32 mocks base method.
func (m *MockSession) Uint32(arg0 string) uint32 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Uint32", arg0)
	ret0, _ := ret[0].(uint32)
	return ret0
}

// Uint32 indicates an expected call of Uint32.
func (mr *MockSessionMockRecorder) Uint32(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Uint32", reflect.TypeOf((*MockSession)(nil).Uint32), arg0)
}

// Uint64 mocks base method.
func (m *MockSession) Uint64(arg0 string) uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Uint64", arg0)
	ret0, _ := ret[0].(uint64)
	return ret0
}

// Uint64 indicates an expected call of Uint64.
func (mr *MockSessionMockRecorder) Uint64(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Uint64", reflect.TypeOf((*MockSession)(nil).Uint64), arg0)
}

// Uint8 mocks base method.
func (m *MockSession) Uint8(arg0 string) byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Uint8", arg0)
	ret0, _ := ret[0].(byte)
	return ret0
}

// Uint8 indicates an expected call of Uint8.
func (mr *MockSessionMockRecorder) Uint8(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Uint8", reflect.TypeOf((*MockSession)(nil).Uint8), arg0)
}

// ValidateHandshake mocks base method.
func (m *MockSession) ValidateHandshake(arg0 *session.HandshakeData) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateHandshake", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// ValidateHandshake indicates an expected call of ValidateHandshake.
func (mr *MockSessionMockRecorder) ValidateHandshake(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateHandshake", reflect.TypeOf((*MockSession)(nil).ValidateHandshake), arg0)
}

// Value mocks base method.
func (m *MockSession) Value(arg0 string) interface{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Value", arg0)
	ret0, _ := ret[0].(interface{})
	return ret0
}

// Value indicates an expected call of Value.
func (mr *MockSessionMockRecorder) Value(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Value", reflect.TypeOf((*MockSession)(nil).Value), arg0)
}

// MockSessionPool is a mock of SessionPool interface.
type MockSessionPool struct {
	ctrl     *gomock.Controller
	recorder *MockSessionPoolMockRecorder
}

// MockSessionPoolMockRecorder is the mock recorder for MockSessionPool.
type MockSessionPoolMockRecorder struct {
	mock *MockSessionPool
}

// NewMockSessionPool creates a new mock instance.
func NewMockSessionPool(ctrl *gomock.Controller) *MockSessionPool {
	mock := &MockSessionPool{ctrl: ctrl}
	mock.recorder = &MockSessionPoolMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSessionPool) EXPECT() *MockSessionPoolMockRecorder {
	return m.recorder
}

// AddHandshakeValidator mocks base method.
func (m *MockSessionPool) AddHandshakeValidator(arg0 string, arg1 func(*session.HandshakeData) error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddHandshakeValidator", arg0, arg1)
}

// AddHandshakeValidator indicates an expected call of AddHandshakeValidator.
func (mr *MockSessionPoolMockRecorder) AddHandshakeValidator(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddHandshakeValidator", reflect.TypeOf((*MockSessionPool)(nil).AddHandshakeValidator), arg0, arg1)
}

// CloseAll mocks base method.
func (m *MockSessionPool) CloseAll() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "CloseAll")
}

// CloseAll indicates an expected call of CloseAll.
func (mr *MockSessionPoolMockRecorder) CloseAll() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloseAll", reflect.TypeOf((*MockSessionPool)(nil).CloseAll))
}

// GetNumberOfConnectedClients mocks base method.
func (m *MockSessionPool) GetNumberOfConnectedClients() int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetNumberOfConnectedClients")
	ret0, _ := ret[0].(int64)
	return ret0
}

// GetNumberOfConnectedClients indicates an expected call of GetNumberOfConnectedClients.
func (mr *MockSessionPoolMockRecorder) GetNumberOfConnectedClients() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNumberOfConnectedClients", reflect.TypeOf((*MockSessionPool)(nil).GetNumberOfConnectedClients))
}

// ForEachSession mocks base method.
func (m *MockSessionPool) ForEachSession(arg0 func(session.Session)) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ForEachSession", arg0)
}

// ForEachSession indicates an expected call of ForEachSession.
func (mr *MockSessionPoolMockRecorder) ForEachSession(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ForEachSession", reflect.TypeOf((*MockSessionPool)(nil).ForEachSession), arg0)
}

// GetSessionByID mocks base method.
func (m *MockSessionPool) GetSessionByID(arg0 int64) session.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSessionByID", arg0)
	ret0, _ := ret[0].(session.Session)
	return ret0
}

// GetSessionByID indicates an expected call of GetSessionByID.
func (mr *MockSessionPoolMockRecorder) GetSessionByID(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSessionByID", reflect.TypeOf((*MockSessionPool)(nil).GetSessionByID), arg0)
}

// GetSessionByUID mocks base method.
func (m *MockSessionPool) GetSessionByUID(arg0 string) session.Session {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSessionByUID", arg0)
	ret0, _ := ret[0].(session.Session)
	return ret0
}

// GetSessionByUID indicates an expected call of GetSessionByUID.
func (mr *MockSessionPoolMockRecorder) GetSessionByUID(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSessionByUID", reflect.TypeOf((*MockSessionPool)(nil).GetSessionByUID), arg0)
}

// GetSessionCloseCallbacks mocks base method.
func (m *MockSessionPool) GetSessionCloseCallbacks() []func(session.Session) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSessionCloseCallbacks")
	ret0, _ := ret[0].([]func(session.Session))
	return ret0
}

// GetSessionCloseCallbacks indicates an expected call of GetSessionCloseCallbacks.
func (mr *MockSessionPoolMockRecorder) GetSessionCloseCallbacks() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSessionCloseCallbacks", reflect.TypeOf((*MockSessionPool)(nil).GetSessionCloseCallbacks))
}

// GetSessionCount mocks base method.
func (m *MockSessionPool) GetSessionCount() int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSessionCount")
	ret0, _ := ret[0].(int64)
	return ret0
}

// GetSessionCount indicates an expected call of GetSessionCount.
func (mr *MockSessionPoolMockRecorder) GetSessionCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSessionCount", reflect.TypeOf((*MockSessionPool)(nil).GetSessionCount))
}

// NewSession mocks base method.
func (m *MockSessionPool) NewSession(arg0 networkentity.NetworkEntity, arg1 bool, arg2 ...string) session.Session {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "NewSession", varargs...)
	ret0, _ := ret[0].(session.Session)
	return ret0
}

// NewSession indicates an expected call of NewSession.
func (mr *MockSessionPoolMockRecorder) NewSession(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewSession", reflect.TypeOf((*MockSessionPool)(nil).NewSession), varargs...)
}

// OnAfterSessionBind mocks base method.
func (m *MockSessionPool) OnAfterSessionBind(arg0 func(context.Context, session.Session) error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "OnAfterSessionBind", arg0)
}

// OnAfterSessionBind indicates an expected call of OnAfterSessionBind.
func (mr *MockSessionPoolMockRecorder) OnAfterSessionBind(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnAfterSessionBind", reflect.TypeOf((*MockSessionPool)(nil).OnAfterSessionBind), arg0)
}

// OnSessionBind mocks base method.
func (m *MockSessionPool) OnSessionBind(arg0 func(context.Context, session.Session) error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "OnSessionBind", arg0)
}

// OnSessionBind indicates an expected call of OnSessionBind.
func (mr *MockSessionPoolMockRecorder) OnSessionBind(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnSessionBind", reflect.TypeOf((*MockSessionPool)(nil).OnSessionBind), arg0)
}

// OnSessionClose mocks base method.
func (m *MockSessionPool) OnSessionClose(arg0 func(session.Session)) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "OnSessionClose", arg0)
}

// OnSessionClose indicates an expected call of OnSessionClose.
func (mr *MockSessionPoolMockRecorder) OnSessionClose(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnSessionClose", reflect.TypeOf((*MockSessionPool)(nil).OnSessionClose), arg0)
}

```

`pkg/session/session.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package session

import (
	"context"
	"encoding/json"
	"fmt"
	"net"
	"reflect"
	"sync"
	"sync/atomic"
	"time"

	"github.com/golang/protobuf/proto"
	nats "github.com/nats-io/nats.go"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/logger/interfaces"
	"github.com/topfreegames/pitaya/v3/pkg/networkentity"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
)

type sessionPoolImpl struct {
	sessionBindCallbacks []func(ctx context.Context, s Session) error
	afterBindCallbacks   []func(ctx context.Context, s Session) error
	handshakeValidators  map[string]func(data *HandshakeData) error

	// SessionCloseCallbacks contains global session close callbacks
	SessionCloseCallbacks []func(s Session)
	sessionsByUID         sync.Map
	sessionsByID          sync.Map
	sessionIDSvc          *sessionIDService
	// SessionCount keeps the current number of sessions
	SessionCount int64
}

// SessionPool centralizes all sessions within a Pitaya app
type SessionPool interface {
	NewSession(entity networkentity.NetworkEntity, frontend bool, UID ...string) Session
	GetSessionCount() int64
	GetSessionCloseCallbacks() []func(s Session)
	GetSessionByUID(uid string) Session
	GetSessionByID(id int64) Session
	OnSessionBind(f func(ctx context.Context, s Session) error)
	OnAfterSessionBind(f func(ctx context.Context, s Session) error)
	OnSessionClose(f func(s Session))
	CloseAll()
	AddHandshakeValidator(name string, f func(data *HandshakeData) error)
	GetNumberOfConnectedClients() int64
	ForEachSession(f func(s Session))
}

// HandshakeClientData represents information about the client sent on the handshake.
type HandshakeClientData struct {
	Platform    string `json:"platform"`
	LibVersion  string `json:"libVersion"`
	BuildNumber string `json:"clientBuildNumber"`
	Version     string `json:"clientVersion"`
}

// HandshakeData represents information about the handshake sent by the client.
// `sys` corresponds to information independent from the app and `user` information
// that depends on the app and is customized by the user.
type HandshakeData struct {
	Sys  HandshakeClientData    `json:"sys"`
	User map[string]interface{} `json:"user,omitempty"`
}

type sessionImpl struct {
	sync.RWMutex                                              // protect data
	id                  int64                                 // session global unique id
	uid                 string                                // binding user id
	lastTime            int64                                 // last heartbeat time
	entity              networkentity.NetworkEntity           // low-level network entity
	data                map[string]interface{}                // session data store
	handshakeData       *HandshakeData                        // handshake data received by the client
	handshakeValidators map[string]func(*HandshakeData) error // validations to run on handshake
	encodedData         []byte                                // session data encoded as a byte array
	OnCloseCallbacks    []func()                              //onClose callbacks
	IsFrontend          bool                                  // if session is a frontend session
	frontendID          string                                // the id of the frontend that owns the session
	frontendSessionID   int64                                 // the id of the session on the frontend server
	Subscriptions       []*nats.Subscription                  // subscription created on bind when using nats rpc server
	requestsInFlight    ReqInFlight                           // whether the session is waiting from a response from a remote
	pool                *sessionPoolImpl
	logger              interfaces.Logger                     // logger instance for this session
}

type ReqInFlight struct {
	m  map[string]string
	mu sync.RWMutex
}

// Session represents a client session, which can store data during the connection.
// All data is released when the low-level connection is broken.
// Session instance related to the client will be passed to Handler method in the
// context parameter.
type Session interface {
	GetOnCloseCallbacks() []func()
	GetIsFrontend() bool
	GetSubscriptions() []*nats.Subscription
	SetOnCloseCallbacks(callbacks []func())
	SetIsFrontend(isFrontend bool)
	SetSubscriptions(subscriptions []*nats.Subscription)
	HasRequestsInFlight() bool
	GetRequestsInFlight() ReqInFlight
	SetRequestInFlight(reqID string, reqData string, inFlight bool)

	Push(route string, v interface{}) error
	ResponseMID(ctx context.Context, mid uint, v interface{}, err ...bool) error
	ID() int64
	UID() string
	GetData() map[string]interface{}
	SetData(data map[string]interface{}) error
	GetDataEncoded() []byte
	SetDataEncoded(encodedData []byte) error
	SetFrontendData(frontendID string, frontendSessionID int64)
	Bind(ctx context.Context, uid string) error
	Kick(ctx context.Context) error
	OnClose(c func()) error
	Close()
	RemoteAddr() net.Addr
	Remove(key string) error
	Set(key string, value interface{}) error
	HasKey(key string) bool
	Get(key string) interface{}
	Int(key string) int
	Int8(key string) int8
	Int16(key string) int16
	Int32(key string) int32
	Int64(key string) int64
	Uint(key string) uint
	Uint8(key string) uint8
	Uint16(key string) uint16
	Uint32(key string) uint32
	Uint64(key string) uint64
	Float32(key string) float32
	Float64(key string) float64
	String(key string) string
	Value(key string) interface{}
	PushToFront(ctx context.Context) error
	Clear()
	SetHandshakeData(data *HandshakeData)
	GetHandshakeData() *HandshakeData
	ValidateHandshake(data *HandshakeData) error
	GetHandshakeValidators() map[string]func(data *HandshakeData) error
}

type sessionIDService struct {
	sid int64
}

func newSessionIDService() *sessionIDService {
	return &sessionIDService{
		sid: 0,
	}
}

// SessionID returns the session id
func (c *sessionIDService) sessionID() int64 {
	return atomic.AddInt64(&c.sid, 1)
}

// NewSession returns a new session instance
// a networkentity.NetworkEntity is a low-level network instance
func (pool *sessionPoolImpl) NewSession(entity networkentity.NetworkEntity, frontend bool, UID ...string) Session {
	s := &sessionImpl{
		id:                  pool.sessionIDSvc.sessionID(),
		entity:              entity,
		data:                make(map[string]interface{}),
		handshakeData:       nil,
		handshakeValidators: pool.handshakeValidators,
		lastTime:            time.Now().Unix(),
		OnCloseCallbacks:    []func(){},
		IsFrontend:          frontend,
		pool:                pool,
		requestsInFlight:    ReqInFlight{m: make(map[string]string)},
		logger:              logger.Log,
	}
	if frontend {
		pool.sessionsByID.Store(s.id, s)
		atomic.AddInt64(&pool.SessionCount, 1)
	}
	s.logger = s.logger.WithField("session_id",s.id)
	if len(UID) > 0 {
		s.uid = UID[0]
		s.logger = s.logger.WithField("uid",s.uid)
	}
	return s
}

// NewSessionPool returns a new session pool instance
func NewSessionPool() SessionPool {
	return &sessionPoolImpl{
		sessionBindCallbacks:  make([]func(ctx context.Context, s Session) error, 0),
		afterBindCallbacks:    make([]func(ctx context.Context, s Session) error, 0),
		handshakeValidators:   make(map[string]func(data *HandshakeData) error, 0),
		SessionCloseCallbacks: make([]func(s Session), 0),
		sessionIDSvc:          newSessionIDService(),
	}
}

func (pool *sessionPoolImpl) GetSessionCount() int64 {
	return pool.SessionCount
}

func (pool *sessionPoolImpl) GetSessionCloseCallbacks() []func(s Session) {
	return pool.SessionCloseCallbacks
}

// GetSessionByUID return a session bound to an user id
func (pool *sessionPoolImpl) GetSessionByUID(uid string) Session {
	// TODO: Block this operation in backend servers
	if val, ok := pool.sessionsByUID.Load(uid); ok {
		return val.(Session)
	}
	return nil
}

// GetSessionByID return a session bound to a frontend server id
func (pool *sessionPoolImpl) GetSessionByID(id int64) Session {
	// TODO: Block this operation in backend servers
	if val, ok := pool.sessionsByID.Load(id); ok {
		return val.(Session)
	}
	return nil
}

// OnSessionBind adds a method to be called when a session is bound
// same function cannot be added twice!
func (pool *sessionPoolImpl) OnSessionBind(f func(ctx context.Context, s Session) error) {
	// Prevents the same function to be added twice in onSessionBind
	sf1 := reflect.ValueOf(f)
	for _, fun := range pool.sessionBindCallbacks {
		sf2 := reflect.ValueOf(fun)
		if sf1.Pointer() == sf2.Pointer() {
			return
		}
	}
	pool.sessionBindCallbacks = append(pool.sessionBindCallbacks, f)
}

// OnAfterSessionBind adds a method to be called when session is bound and after all sessionBind callbacks
func (pool *sessionPoolImpl) OnAfterSessionBind(f func(ctx context.Context, s Session) error) {
	// Prevents the same function to be added twice in onSessionBind
	sf1 := reflect.ValueOf(f)
	for _, fun := range pool.afterBindCallbacks {
		sf2 := reflect.ValueOf(fun)
		if sf1.Pointer() == sf2.Pointer() {
			return
		}
	}
	pool.afterBindCallbacks = append(pool.afterBindCallbacks, f)
}

// OnSessionClose adds a method that will be called when every session closes
func (pool *sessionPoolImpl) OnSessionClose(f func(s Session)) {
	sf1 := reflect.ValueOf(f)
	for _, fun := range pool.SessionCloseCallbacks {
		sf2 := reflect.ValueOf(fun)
		if sf1.Pointer() == sf2.Pointer() {
			return
		}
	}
	pool.SessionCloseCallbacks = append(pool.SessionCloseCallbacks, f)
}

// CloseAll calls Close on all sessions
func (pool *sessionPoolImpl) CloseAll() {
	logger.Log.Infof("closing all sessions, %d sessions", pool.SessionCount)
	for pool.SessionCount > 0 {
		pool.sessionsByID.Range(func(_, value interface{}) bool {
			s := value.(Session)
			if s.HasRequestsInFlight() {
				reqsInFlight := s.GetRequestsInFlight()
				reqsInFlight.mu.RLock()
				for _, route := range reqsInFlight.m {
					logger.Log.Debugf("Session for user %s is waiting on a response for route %s from a remote server. Delaying session close.", s.UID(), route)
				}
				reqsInFlight.mu.RUnlock()
				return false
			} else {
				s.Close()
				return true
			}
		})
		logger.Log.Debugf("%d sessions remaining", pool.SessionCount)
		if pool.SessionCount > 0 {
			time.Sleep(100 * time.Millisecond)
		}
	}
	logger.Log.Info("finished closing sessions")
}

// AddHandshakeValidator allows adds validation functions that will run when
// handshake packets are processed. Errors will be raised with the given name.
func (pool *sessionPoolImpl) AddHandshakeValidator(name string, f func(data *HandshakeData) error) {
	pool.handshakeValidators[name] = f
}

// GetNumberOfConnectedClients returns the number of connected clients
func (pool *sessionPoolImpl) GetNumberOfConnectedClients() int64 {
	return pool.GetSessionCount()
}

// ForEachSession iterates through all sessions in the pool and calls f for each one
func (pool *sessionPoolImpl) ForEachSession(f func(s Session)) {
	pool.sessionsByID.Range(func(_, value interface{}) bool {
		s := value.(Session)
		f(s)
		return true
	})
}

func (s *sessionImpl) updateEncodedData() error {
	var b []byte
	b, err := json.Marshal(s.data)
	if err != nil {
		return err
	}
	s.encodedData = b
	return nil
}

// GetOnCloseCallbacks ...
func (s *sessionImpl) GetOnCloseCallbacks() []func() {
	return s.OnCloseCallbacks
}

// GetIsFrontend ...
func (s *sessionImpl) GetIsFrontend() bool {
	return s.IsFrontend
}

// GetSubscriptions ...
func (s *sessionImpl) GetSubscriptions() []*nats.Subscription {
	return s.Subscriptions
}

// SetOnCloseCallbacks ...
func (s *sessionImpl) SetOnCloseCallbacks(callbacks []func()) {
	s.OnCloseCallbacks = callbacks
}

// SetIsFrontend ...
func (s *sessionImpl) SetIsFrontend(isFrontend bool) {
	s.IsFrontend = isFrontend
}

// SetSubscriptions ...
func (s *sessionImpl) SetSubscriptions(subscriptions []*nats.Subscription) {
	s.Subscriptions = subscriptions
}

// Push message to client
func (s *sessionImpl) Push(route string, v interface{}) error {
	return s.entity.Push(route, v)
}

// ResponseMID responses message to client, mid is
// request message ID
func (s *sessionImpl) ResponseMID(ctx context.Context, mid uint, v interface{}, err ...bool) error {
	return s.entity.ResponseMID(ctx, mid, v, err...)
}

// ID returns the session id
func (s *sessionImpl) ID() int64 {
	return s.id
}

// UID returns uid that bind to current session
func (s *sessionImpl) UID() string {
	return s.uid
}

// GetData gets the data
func (s *sessionImpl) GetData() map[string]interface{} {
	s.RLock()
	defer s.RUnlock()

	return s.data
}

// SetData sets the whole session data
func (s *sessionImpl) SetData(data map[string]interface{}) error {
	s.Lock()
	defer s.Unlock()

	s.data = data
	return s.updateEncodedData()
}

// GetDataEncoded returns the session data as an encoded value
func (s *sessionImpl) GetDataEncoded() []byte {
	return s.encodedData
}

// SetDataEncoded sets the whole session data from an encoded value
func (s *sessionImpl) SetDataEncoded(encodedData []byte) error {
	if len(encodedData) == 0 {
		return nil
	}
	var data map[string]interface{}
	err := json.Unmarshal(encodedData, &data)
	if err != nil {
		return err
	}
	return s.SetData(data)
}

// SetFrontendData sets frontend id and session id
func (s *sessionImpl) SetFrontendData(frontendID string, frontendSessionID int64) {
	s.frontendID = frontendID
	s.frontendSessionID = frontendSessionID
}

// Bind bind UID to current session
func (s *sessionImpl) Bind(ctx context.Context, uid string) error {
	if uid == "" {
		return constants.ErrIllegalUID
	}

	if s.UID() != "" {
		s.logger.Debugf("Error trying to bind UID %s. A UID is already bound in this session", uid)
		return constants.ErrSessionAlreadyBound
	}

	s.uid = uid
	for _, cb := range s.pool.sessionBindCallbacks {
		err := cb(ctx, s)
		if err != nil {
			s.logger.Error("Error running session bind callback. Removing uid from session")
			s.uid = ""
			return err
		}
	}

	// if code running on frontend server
	if s.IsFrontend {
		// If a session with the same UID already exists in this frontend server, close it
		if val, ok := s.pool.sessionsByUID.Load(uid); ok {
			s.logger.Warn("A session for this UID %s already existed in this frontend, on session ID %v closing it", val.(Session).ID())
			val.(Session).Close()
		}
		s.pool.sessionsByUID.Store(uid, s)
	} else {
		// If frontentID is set this means it is a remote call and the current server
		// is not the frontend server that received the user request
		err := s.bindInFront(ctx)
		if err != nil {
			s.logger.Error("error while trying to push session to front: ", err)
			s.uid = ""
			return err
		}
	}

	// invoke after callbacks on session bound
	for _, cb := range s.pool.afterBindCallbacks {
		err := cb(ctx, s)
		if err != nil {
			s.uid = ""
			return err
		}
	}

	return nil
}

// Kick kicks the user
func (s *sessionImpl) Kick(ctx context.Context) error {
	err := s.entity.Kick(ctx)
	if err != nil {
		return err
	}
	return s.entity.Close()
}

// OnClose adds the function it receives to the callbacks that will be called
// when the session is closed
func (s *sessionImpl) OnClose(c func()) error {
	if !s.IsFrontend {
		return constants.ErrOnCloseBackend
	}
	s.OnCloseCallbacks = append(s.OnCloseCallbacks, c)
	return nil
}

// Close terminates current session, session related data will not be released,
// all related data should be cleared explicitly in Session closed callback
func (s *sessionImpl) Close() {
	atomic.AddInt64(&s.pool.SessionCount, -1)
	s.pool.sessionsByID.Delete(s.ID())
	s.logger.Debug("Closing session")
	// Only remove session by UID if the session ID matches the one being closed. This avoids problems with removing a valid session after the user has already reconnected before this session's heartbeat times out
	if val, ok := s.pool.sessionsByUID.Load(s.UID()); ok {
		if (val.(Session)).ID() == s.ID() {
			s.pool.sessionsByUID.Delete(s.UID())
		}
	}
	// TODO: this logic should be moved to nats rpc server
	if s.IsFrontend && s.Subscriptions != nil && len(s.Subscriptions) > 0 {
		// if the user is bound to an userid and nats rpc server is being used we need to unsubscribe
		for _, sub := range s.Subscriptions {
			err := sub.Drain()
			if err != nil {
				s.logger.Errorf("error unsubscribing to user's messages channel: %s, this can cause performance and leak issues", err.Error())
			} else {
				s.logger.Debug("successfully unsubscribed to user's messages channel")
			}
		}
	}
	s.entity.Close()
}

// RemoteAddr returns the remote network address.
func (s *sessionImpl) RemoteAddr() net.Addr {
	return s.entity.RemoteAddr()
}

// Remove delete data associated with the key from session storage
func (s *sessionImpl) Remove(key string) error {
	s.Lock()
	defer s.Unlock()

	delete(s.data, key)
	return s.updateEncodedData()
}

// Set associates value with the key in session storage
func (s *sessionImpl) Set(key string, value interface{}) error {
	s.Lock()
	defer s.Unlock()

	s.data[key] = value
	return s.updateEncodedData()
}

// HasKey decides whether a key has associated value
func (s *sessionImpl) HasKey(key string) bool {
	s.RLock()
	defer s.RUnlock()

	_, has := s.data[key]
	return has
}

// Get returns a key value
func (s *sessionImpl) Get(key string) interface{} {
	s.RLock()
	defer s.RUnlock()

	v, ok := s.data[key]
	if !ok {
		return nil
	}
	return v
}

// Int returns the value associated with the key as a int.
func (s *sessionImpl) Int(key string) int {
	s.RLock()
	defer s.RUnlock()

	v, ok := s.data[key]
	if !ok {
		return 0
	}

	value, ok := v.(int)
	if !ok {
		return 0
	}
	return value
}

// Int8 returns the value associated with the key as a int8.
func (s *sessionImpl) Int8(key string) int8 {
	s.RLock()
	defer s.RUnlock()

	v, ok := s.data[key]
	if !ok {
		return 0
	}

	value, ok := v.(int8)
	if !ok {
		return 0
	}
	return value
}

// Int16 returns the value associated with the key as a int16.
func (s *sessionImpl) Int16(key string) int16 {
	s.RLock()
	defer s.RUnlock()

	v, ok := s.data[key]
	if !ok {
		return 0
	}

	value, ok := v.(int16)
	if !ok {
		return 0
	}
	return value
}

// Int32 returns the value associated with the key as a int32.
func (s *sessionImpl) Int32(key string) int32 {
	s.RLock()
	defer s.RUnlock()

	v, ok := s.data[key]
	if !ok {
		return 0
	}

	value, ok := v.(int32)
	if !ok {
		return 0
	}
	return value
}

// Int64 returns the value associated with the key as a int64.
func (s *sessionImpl) Int64(key string) int64 {
	s.RLock()
	defer s.RUnlock()

	v, ok := s.data[key]
	if !ok {
		return 0
	}

	value, ok := v.(int64)
	if !ok {
		return 0
	}
	return value
}

// Uint returns the value associated with the key as a uint.
func (s *sessionImpl) Uint(key string) uint {
	s.RLock()
	defer s.RUnlock()

	v, ok := s.data[key]
	if !ok {
		return 0
	}

	value, ok := v.(uint)
	if !ok {
		return 0
	}
	return value
}

// Uint8 returns the value associated with the key as a uint8.
func (s *sessionImpl) Uint8(key string) uint8 {
	s.RLock()
	defer s.RUnlock()

	v, ok := s.data[key]
	if !ok {
		return 0
	}

	value, ok := v.(uint8)
	if !ok {
		return 0
	}
	return value
}

// Uint16 returns the value associated with the key as a uint16.
func (s *sessionImpl) Uint16(key string) uint16 {
	s.RLock()
	defer s.RUnlock()

	v, ok := s.data[key]
	if !ok {
		return 0
	}

	value, ok := v.(uint16)
	if !ok {
		return 0
	}
	return value
}

// Uint32 returns the value associated with the key as a uint32.
func (s *sessionImpl) Uint32(key string) uint32 {
	s.RLock()
	defer s.RUnlock()

	v, ok := s.data[key]
	if !ok {
		return 0
	}

	value, ok := v.(uint32)
	if !ok {
		return 0
	}
	return value
}

// Uint64 returns the value associated with the key as a uint64.
func (s *sessionImpl) Uint64(key string) uint64 {
	s.RLock()
	defer s.RUnlock()

	v, ok := s.data[key]
	if !ok {
		return 0
	}

	value, ok := v.(uint64)
	if !ok {
		return 0
	}
	return value
}

// Float32 returns the value associated with the key as a float32.
func (s *sessionImpl) Float32(key string) float32 {
	s.RLock()
	defer s.RUnlock()

	v, ok := s.data[key]
	if !ok {
		return 0
	}

	value, ok := v.(float32)
	if !ok {
		return 0
	}
	return value
}

// Float64 returns the value associated with the key as a float64.
func (s *sessionImpl) Float64(key string) float64 {
	s.RLock()
	defer s.RUnlock()

	v, ok := s.data[key]
	if !ok {
		return 0
	}

	value, ok := v.(float64)
	if !ok {
		return 0
	}
	return value
}

// String returns the value associated with the key as a string.
func (s *sessionImpl) String(key string) string {
	s.RLock()
	defer s.RUnlock()

	v, ok := s.data[key]
	if !ok {
		return ""
	}

	value, ok := v.(string)
	if !ok {
		return ""
	}
	return value
}

// Value returns the value associated with the key as a interface{}.
func (s *sessionImpl) Value(key string) interface{} {
	s.RLock()
	defer s.RUnlock()

	return s.data[key]
}

func (s *sessionImpl) bindInFront(ctx context.Context) error {
	return s.sendRequestToFront(ctx, constants.SessionBindRoute, false)
}

// PushToFront updates the session in the frontend
func (s *sessionImpl) PushToFront(ctx context.Context) error {
	if s.IsFrontend {
		return constants.ErrFrontSessionCantPushToFront
	}
	return s.sendRequestToFront(ctx, constants.SessionPushRoute, true)
}

// Clear releases all data related to current session
func (s *sessionImpl) Clear() {
	s.Lock()
	defer s.Unlock()

	s.uid = ""
	s.data = map[string]interface{}{}
	s.updateEncodedData()
}

// SetHandshakeData sets the handshake data received by the client.
func (s *sessionImpl) SetHandshakeData(data *HandshakeData) {
	s.Lock()
	defer s.Unlock()

	s.handshakeData = data
}

// GetHandshakeData gets the handshake data received by the client.
func (s *sessionImpl) GetHandshakeData() *HandshakeData {
	return s.handshakeData
}

// GetHandshakeValidators return the handshake validators associated with the session.
func (s *sessionImpl) GetHandshakeValidators() map[string]func(data *HandshakeData) error {
	return s.handshakeValidators
}

func (s *sessionImpl) ValidateHandshake(data *HandshakeData) error {
	for name, fun := range s.handshakeValidators {
		if err := fun(data); err != nil {
			return fmt.Errorf("failed to run '%s' validator: %w. SessionId=%d", name, err, s.ID())
		}
	}

	return nil
}

func (s *sessionImpl) sendRequestToFront(ctx context.Context, route string, includeData bool) error {
	log := s.logger.WithField("route", route)
	sessionData := &protos.Session{
		Id:  s.frontendSessionID,
		Uid: s.uid,
	}
	if includeData {
		sessionData.Data = s.encodedData
	}
	b, err := proto.Marshal(sessionData)
	if err != nil {
		return err
	}
	res, err := s.entity.SendRequest(ctx, s.frontendID, route, b)
	if err != nil {
		return err
	}
	log.Debugf("Got response: %+v", res)
	return nil
}

func (s *sessionImpl) HasRequestsInFlight() bool {
	return len(s.requestsInFlight.m) != 0
}

func (s *sessionImpl) GetRequestsInFlight() ReqInFlight {
	return s.requestsInFlight
}

func (s *sessionImpl) SetRequestInFlight(reqID string, reqData string, inFlight bool) {
	s.requestsInFlight.mu.Lock()
	if inFlight {
		s.requestsInFlight.m[reqID] = reqData
	} else {
		if _, ok := s.requestsInFlight.m[reqID]; ok {
			delete(s.requestsInFlight.m, reqID)
		}
	}
	s.requestsInFlight.mu.Unlock()
}

```

`pkg/session/session_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package session

import (
	"context"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"math/rand"
	"path/filepath"
	"testing"
	"time"

	"github.com/golang/mock/gomock"
	"github.com/golang/protobuf/proto"
	"github.com/google/uuid"
	nats "github.com/nats-io/nats.go"
	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/helpers"
	"github.com/topfreegames/pitaya/v3/pkg/networkentity/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
)

var update = flag.Bool("update", false, "update .golden files")

type someStruct struct {
	A int
	B string
}

type unregisteredStruct struct{}

type mockAddr struct{}

func (ma *mockAddr) Network() string { return "tcp" }
func (ma *mockAddr) String() string  { return "192.0.2.1:25" }

func getEncodedEmptyMap() []byte {
	b, _ := json.Marshal(map[string]interface{}{})
	return b
}

func TestNewSessionIDService(t *testing.T) {
	t.Parallel()

	sessionIDService := newSessionIDService()
	assert.NotNil(t, sessionIDService)
	assert.EqualValues(t, 0, sessionIDService.sid)
}

func TestSessionIDServiceSessionID(t *testing.T) {
	t.Parallel()

	sessionIDService := newSessionIDService()
	sessionID := sessionIDService.sessionID()
	assert.EqualValues(t, 1, sessionID)
}

func TestCloseAll(t *testing.T) {
	var (
		entity      *mocks.MockNetworkEntity
		sessionPool = NewSessionPool().(*sessionPoolImpl)
	)

	tables := map[string]struct {
		sessions func() []Session
		mock     func()
	}{
		"test_close_many_sessions": {
			sessions: func() []Session {
				return []Session{
					sessionPool.NewSession(entity, true, uuid.New().String()),
					sessionPool.NewSession(entity, true, uuid.New().String()),
					sessionPool.NewSession(entity, true, uuid.New().String()),
				}
			},
			mock: func() {
				entity.EXPECT().Close().Times(3)
			},
		},

		"test_close_no_sessions": {
			sessions: func() []Session { return []Session{} },
			mock:     func() {},
		},
	}

	for name, table := range tables {
		t.Run(name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			entity = mocks.NewMockNetworkEntity(ctrl)
			for _, s := range table.sessions() {
				sessionPool.sessionsByID.Store(s.ID(), s)
				sessionPool.sessionsByUID.Store(s.UID(), s)
			}

			table.mock()

			sessionPool.CloseAll()
		})
	}
}

func TestNew(t *testing.T) {
	tables := []struct {
		name     string
		frontend bool
		uid      string
	}{
		{"test_frontend", true, ""},
		{"test_backend", false, ""},
		{"test_frontend_with_uid", true, uuid.New().String()},
		{"test_backend_with_uid", false, uuid.New().String()},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			entity := mocks.NewMockNetworkEntity(ctrl)
			sessionPool := NewSessionPool().(*sessionPoolImpl)
			var ss *sessionImpl
			if table.uid != "" {
				ss = sessionPool.NewSession(entity, table.frontend, table.uid).(*sessionImpl)
			} else {
				ss = sessionPool.NewSession(entity, table.frontend).(*sessionImpl)
			}
			assert.NotZero(t, ss.id)
			assert.Equal(t, entity, ss.entity)
			assert.Empty(t, ss.data)
			assert.InDelta(t, time.Now().Unix(), ss.lastTime, 1)
			assert.Empty(t, ss.OnCloseCallbacks)
			assert.Equal(t, table.frontend, ss.IsFrontend)

			if len(table.uid) > 0 {
				assert.Equal(t, table.uid[0], ss.uid[0])
			}

			if table.frontend {
				val, ok := sessionPool.sessionsByID.Load(ss.id)
				assert.True(t, ok)
				assert.Equal(t, val, ss)
			}
		})
	}
}

func TestGetSessionByIDExists(t *testing.T) {
	t.Parallel()

	sessionPool := NewSessionPool()
	expectedSS := sessionPool.NewSession(nil, true)
	ss := sessionPool.GetSessionByID(expectedSS.ID())
	assert.Equal(t, expectedSS, ss)
}

func TestGetSessionByIDDoenstExist(t *testing.T) {
	t.Parallel()
	sessionPool := NewSessionPool()
	ss := sessionPool.GetSessionByID(123456) // huge number to make sure no session with this id
	assert.Nil(t, ss)
}

func TestGetSessionByUIDExists(t *testing.T) {
	uid := uuid.New().String()

	sessionPool := NewSessionPool().(*sessionPoolImpl)
	expectedSS := sessionPool.NewSession(nil, true, uid)
	sessionPool.sessionsByUID.Store(uid, expectedSS)

	ss := sessionPool.GetSessionByUID(uid)
	assert.Equal(t, expectedSS, ss)
}

func TestGetSessionByUIDDoenstExist(t *testing.T) {
	t.Parallel()

	sessionPool := NewSessionPool()
	ss := sessionPool.GetSessionByUID(uuid.New().String())
	assert.Nil(t, ss)
}

func TestKick(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	entity := mocks.NewMockNetworkEntity(ctrl)
	sessionPool := NewSessionPool()
	ss := sessionPool.NewSession(entity, true)
	c := context.Background()
	entity.EXPECT().Kick(c)
	entity.EXPECT().Close()
	err := ss.Kick(c)
	assert.NoError(t, err)
}

func TestSessionUpdateEncodedData(t *testing.T) {
	tables := []struct {
		name string
		data map[string]interface{}
	}{
		{"testUpdateEncodedData_1", map[string]interface{}{"byte": []byte{1}}},
		{"testUpdateEncodedData_2", map[string]interface{}{"int": 1}},
		{"testUpdateEncodedData_3", map[string]interface{}{"struct": someStruct{A: 1, B: "aaa"}}},
		{"testUpdateEncodedData_4", map[string]interface{}{"string": "aaa"}},
		{"testUpdateEncodedData_5", map[string]interface{}{}},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool().(*sessionPoolImpl)
			ss := sessionPool.NewSession(nil, false).(*sessionImpl)
			assert.NotNil(t, ss)

			ss.data = table.data
			err := ss.updateEncodedData()
			assert.NoError(t, err)

			gp := filepath.Join("fixtures", table.name+".golden")
			if *update {
				t.Log("updating golden file")
				helpers.WriteFile(t, gp, ss.encodedData)
			}
			data := helpers.ReadFile(t, gp)

			assert.Equal(t, data, ss.encodedData)
		})
	}
}

func TestSessionPush(t *testing.T) {
	t.Parallel()

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockEntity := mocks.NewMockNetworkEntity(ctrl)
	sessionPool := NewSessionPool()
	ss := sessionPool.NewSession(mockEntity, false)
	route := uuid.New().String()
	v := someStruct{A: 1, B: "aaa"}

	mockEntity.EXPECT().Push(route, v)
	err := ss.Push(route, v)
	assert.NoError(t, err)
}

func TestSessionResponseMID(t *testing.T) {
	t.Parallel()

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()
	mockEntity := mocks.NewMockNetworkEntity(ctrl)
	sessionPool := NewSessionPool()
	ss := sessionPool.NewSession(mockEntity, false)
	mid := uint(rand.Int())
	v := someStruct{A: 1, B: "aaa"}
	ctx := context.Background()

	mockEntity.EXPECT().ResponseMID(ctx, mid, v)
	err := ss.ResponseMID(ctx, mid, v)
	assert.NoError(t, err)
}

func TestSessionID(t *testing.T) {
	t.Parallel()

	sessionPool := NewSessionPool().(*sessionPoolImpl)
	ss := sessionPool.NewSession(nil, false).(*sessionImpl)
	ss.id = int64(rand.Uint64())

	id := ss.ID()
	assert.Equal(t, ss.id, id)
}

func TestSessionUID(t *testing.T) {
	t.Parallel()

	sessionPool := NewSessionPool().(*sessionPoolImpl)
	ss := sessionPool.NewSession(nil, false).(*sessionImpl)
	ss.uid = uuid.New().String()

	uid := ss.UID()
	assert.Equal(t, ss.uid, uid)
}

func TestSessionGetData(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name string
		data map[string]interface{}
	}{
		{"test_1", map[string]interface{}{"byte": []byte{1}, "string": "test", "int": 1}},
		{"test_2", map[string]interface{}{"byte": []byte{1}, "struct": someStruct{A: 1, B: "aaa"}, "int": 34}},
		{"test_3", map[string]interface{}{"string": "aaa"}},
		{"test_4", map[string]interface{}{}},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool().(*sessionPoolImpl)
			ss := sessionPool.NewSession(nil, false).(*sessionImpl)
			ss.data = table.data

			data := ss.GetData()
			assert.Equal(t, ss.data, data)
		})
	}
}

func TestSessionSetData(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name string
		data map[string]interface{}
	}{
		{"testSessionSetData_1", map[string]interface{}{"byte": []byte{1}}},
		{"testSessionSetData_2", map[string]interface{}{"int": 1}},
		{"testSessionSetData_3", map[string]interface{}{"struct": someStruct{A: 1, B: "aaa"}}},
		{"testSessionSetData_4", map[string]interface{}{"string": "aaa"}},
		{"testSessionSetData_5", map[string]interface{}{}},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool().(*sessionPoolImpl)
			ss := sessionPool.NewSession(nil, false).(*sessionImpl)
			err := ss.SetData(table.data)
			assert.NoError(t, err)
			assert.Equal(t, table.data, ss.data)

			gp := filepath.Join("fixtures", table.name+".golden")
			if *update {
				t.Log("updating golden file")
				helpers.WriteFile(t, gp, ss.encodedData)
			}
			encodedData := helpers.ReadFile(t, gp)
			assert.Equal(t, encodedData, ss.encodedData)
		})
	}
}

func TestSessionGetEncodedData(t *testing.T) {
	t.Parallel()
	tables := []struct {
		name string
	}{
		{"testUpdateEncodedData_1"},
		{"testUpdateEncodedData_2"},
		{"testUpdateEncodedData_3"},
		{"testUpdateEncodedData_4"},
		{"testUpdateEncodedData_5"},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool().(*sessionPoolImpl)
			ss := sessionPool.NewSession(nil, false).(*sessionImpl)
			assert.NotNil(t, ss)

			gp := filepath.Join("fixtures", table.name+".golden")
			encodedData := helpers.ReadFile(t, gp)

			ss.encodedData = encodedData
			data := ss.GetDataEncoded()
			assert.Equal(t, ss.encodedData, data)
		})
	}
}

func TestSessionSetEncodedData(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name string
		data map[string]interface{}
	}{
		{"testUpdateEncodedData_2", map[string]interface{}{"int": float64(1)}},
		{"testUpdateEncodedData_3", map[string]interface{}{"struct": map[string]interface{}{"A": float64(1), "B": "aaa"}}},
		{"testUpdateEncodedData_4", map[string]interface{}{"string": "aaa"}},
		{"testUpdateEncodedData_5", map[string]interface{}{}},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool().(*sessionPoolImpl)
			ss := sessionPool.NewSession(nil, false).(*sessionImpl)
			assert.NotNil(t, ss)

			gp := filepath.Join("fixtures", table.name+".golden")
			encodedData := helpers.ReadFile(t, gp)

			err := ss.SetDataEncoded(encodedData)
			assert.NoError(t, err)
			assert.Equal(t, encodedData, ss.encodedData)
			assert.Equal(t, table.data, ss.data)
		})
	}
}

func TestSessionSetFrontendData(t *testing.T) {
	t.Parallel()

	frontendID := uuid.New().String()
	frontendSessionID := int64(rand.Uint64())

	sessionPool := NewSessionPool().(*sessionPoolImpl)
	ss := sessionPool.NewSession(nil, false).(*sessionImpl)
	assert.NotNil(t, ss)
	ss.SetFrontendData(frontendID, frontendSessionID)

	assert.Equal(t, frontendID, ss.frontendID)
	assert.Equal(t, frontendSessionID, ss.frontendSessionID)
}

func TestSessionBindFailsWithoutUID(t *testing.T) {
	t.Parallel()

	sessionPool := NewSessionPool()
	ss := sessionPool.NewSession(nil, false)
	assert.NotNil(t, ss)

	err := ss.Bind(nil, "")
	assert.Equal(t, constants.ErrIllegalUID, err)
}

func TestSessionBindFailsIfAlreadyBound(t *testing.T) {
	t.Parallel()

	sessionPool := NewSessionPool().(*sessionPoolImpl)
	ss := sessionPool.NewSession(nil, false).(*sessionImpl)
	ss.uid = uuid.New().String()
	assert.NotNil(t, ss)

	err := ss.Bind(nil, uuid.New().String())
	assert.Equal(t, constants.ErrSessionAlreadyBound, err)
}

func TestSessionBindRunsOnSessionBind(t *testing.T) {
	affectedVar := ""
	err := errors.New("some error occured")
	tables := []struct {
		name          string
		onSessionBind func(ctx context.Context, s Session) error
		err           error
	}{
		{"successful_on_session_bind", func(ctx context.Context, s Session) error {
			affectedVar = s.UID()
			return nil
		}, nil},
		{"failed_on_session_bind", func(ctx context.Context, s Session) error { return err }, err},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			affectedVar = ""
			sessionPool := NewSessionPool().(*sessionPoolImpl)
			ss := sessionPool.NewSession(nil, true)
			assert.NotNil(t, ss)

			sessionPool.OnSessionBind(table.onSessionBind)
			defer func() { sessionPool.sessionBindCallbacks = make([]func(ctx context.Context, s Session) error, 0) }()

			uid := uuid.New().String()
			err := ss.Bind(nil, uid)

			if table.err != nil {
				assert.Equal(t, table.err, err)
				assert.Empty(t, affectedVar)
				assert.Empty(t, ss.UID())
			} else {
				assert.NoError(t, err)
				assert.Equal(t, uid, affectedVar)
				assert.Equal(t, uid, ss.UID())
			}
		})
	}
}

func TestSessionBindFrontend(t *testing.T) {
	sessionPool := NewSessionPool().(*sessionPoolImpl)
	ss := sessionPool.NewSession(nil, true)
	assert.NotNil(t, ss)

	uid := uuid.New().String()
	err := ss.Bind(nil, uid)
	assert.NoError(t, err)
	assert.Equal(t, uid, ss.UID())

	val, ok := sessionPool.sessionsByUID.Load(uid)
	assert.True(t, ok)
	assert.Equal(t, val, ss)
}

func TestSessionBindBackend(t *testing.T) {
	tables := []struct {
		name string
		err  error
	}{
		{"successful_bind_in_front", nil},
		{"failed_bind_in_front", errors.New("failed bind in front")},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			mockEntity := mocks.NewMockNetworkEntity(ctrl)
			sessionPool := NewSessionPool().(*sessionPoolImpl)
			ss := sessionPool.NewSession(mockEntity, false).(*sessionImpl)
			assert.NotNil(t, ss)

			uid := uuid.New().String()
			expectedSessionData := &protos.Session{
				Id:  ss.frontendSessionID,
				Uid: uid,
			}
			ctx := context.Background()
			expectedRequestData, err := proto.Marshal(expectedSessionData)
			assert.NoError(t, err)

			mockEntity.EXPECT().SendRequest(ctx, ss.frontendID, constants.SessionBindRoute, expectedRequestData).Return(&protos.Response{}, table.err)

			err = ss.Bind(ctx, uid)
			assert.Equal(t, table.err, err)

			if table.err == nil {
				assert.Equal(t, uid, ss.uid)
			} else {
				assert.Empty(t, ss.uid)
			}

			_, ok := sessionPool.sessionsByUID.Load(uid)
			assert.False(t, ok)
		})
	}
}

func TestSessionOnCloseFailsIfBackend(t *testing.T) {
	t.Parallel()

	sessionPool := NewSessionPool()
	ss := sessionPool.NewSession(nil, false)
	assert.NotNil(t, ss)

	err := ss.OnClose(nil)
	assert.Equal(t, constants.ErrOnCloseBackend, err)
}

func TestSessionOnClose(t *testing.T) {
	t.Parallel()

	sessionPool := NewSessionPool()
	ss := sessionPool.NewSession(nil, true)
	assert.NotNil(t, ss)

	expected := false
	f := func() { expected = true }
	err := ss.OnClose(f)
	assert.NoError(t, err)
	assert.Len(t, ss.GetOnCloseCallbacks(), 1)

	ss.GetOnCloseCallbacks()[0]()
	assert.True(t, expected)
}

func TestSessionClose(t *testing.T) {
	tables := []struct {
		name string
		uid  string
	}{
		{"close", ""},
		{"close_bound", uuid.New().String()},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			mockEntity := mocks.NewMockNetworkEntity(ctrl)
			sessionPool := NewSessionPool().(*sessionPoolImpl)
			ss := sessionPool.NewSession(mockEntity, true).(*sessionImpl)
			assert.NotNil(t, ss)

			if table.uid != "" {
				sessionPool.sessionsByUID.Store(table.uid, ss)
				ss.uid = table.uid
			}

			mockEntity.EXPECT().Close()
			ss.Close()

			_, ok := sessionPool.sessionsByID.Load(ss.id)
			assert.False(t, ok)

			if table.uid != "" {
				_, ok = sessionPool.sessionsByUID.Load(table.uid)
				assert.False(t, ok)
			}
		})
	}
}

func TestSessionCloseFrontendWithSubscription(t *testing.T) {
	s := helpers.GetTestNatsServer(t)
	defer s.Shutdown()
	initialSubs := s.NumSubscriptions()

	conn, err := nats.Connect(fmt.Sprintf("nats://%s", s.Addr()))
	assert.NoError(t, err)
	defer conn.Close()

	subs, err := conn.Subscribe(uuid.New().String(), func(msg *nats.Msg) {})
	assert.NoError(t, err)

	helpers.ShouldEventuallyReturn(t, s.NumSubscriptions, initialSubs+1)
	helpers.ShouldEventuallyReturn(t, conn.NumSubscriptions, 1)

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockEntity := mocks.NewMockNetworkEntity(ctrl)
	sessionPool := NewSessionPool()
	ss := sessionPool.NewSession(mockEntity, true)
	assert.NotNil(t, ss)
	ss.SetSubscriptions([]*nats.Subscription{subs})

	mockEntity.EXPECT().Close()
	ss.Close()

	helpers.ShouldEventuallyReturn(t, s.NumSubscriptions, initialSubs)
	helpers.ShouldEventuallyReturn(t, conn.NumSubscriptions, 0)
}

func TestSessionRemoteAddr(t *testing.T) {
	t.Parallel()

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockEntity := mocks.NewMockNetworkEntity(ctrl)
	sessionPool := NewSessionPool()
	ss := sessionPool.NewSession(mockEntity, true)
	assert.NotNil(t, ss)

	expectedAddr := &mockAddr{}
	mockEntity.EXPECT().RemoteAddr().Return(expectedAddr)
	addr := ss.RemoteAddr()
	assert.Equal(t, expectedAddr, addr)
}

func TestSessionSet(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name   string
		val    interface{}
		errStr string
	}{
		{"ok", "val", ""},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			ss := sessionPool.NewSession(nil, true).(*sessionImpl)
			assert.NotNil(t, ss)
			err := ss.Set("key", table.val)
			if table.errStr == "" {
				assert.NoError(t, err)
				val, ok := ss.data["key"]
				assert.True(t, ok)
				assert.Equal(t, table.val, val)
				assert.NotEmpty(t, ss.encodedData)
			}
		})
	}
}

func TestSessionRemove(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name string
		val  interface{}
	}{
		{"existent", "val"},
		{"unexistent", nil},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			ss := sessionPool.NewSession(nil, true).(*sessionImpl)
			assert.NotNil(t, ss)

			if table.val != nil {
				err := ss.Set("key", table.val)
				assert.NoError(t, err)
				assert.NotEmpty(t, ss.data)
				assert.NotEmpty(t, ss.encodedData)
			}

			err := ss.Remove("key")
			assert.NoError(t, err)
			assert.Empty(t, ss.data)

			expectedEncoded := getEncodedEmptyMap()
			assert.Equal(t, expectedEncoded, ss.encodedData)
		})
	}
}

func TestOnSessionBind(t *testing.T) {
	expected := false
	f := func(context.Context, Session) error {
		expected = true
		return nil
	}
	sessionPool := NewSessionPool().(*sessionPoolImpl)
	sessionPool.OnSessionBind(f)
	defer func() { sessionPool.sessionBindCallbacks = make([]func(ctx context.Context, s Session) error, 0) }()
	assert.NotNil(t, sessionPool.OnSessionBind)

	sessionPool.sessionBindCallbacks[0](context.Background(), nil)
	assert.True(t, expected)
}

func TestSessionHasKey(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name string
		val  interface{}
	}{
		{"existent", "val"},
		{"unexistent", nil},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			ss := sessionPool.NewSession(nil, true).(*sessionImpl)
			assert.NotNil(t, ss)

			if table.val != nil {
				err := ss.Set("key", table.val)
				assert.NoError(t, err)
				assert.NotEmpty(t, ss.data)
			}

			exists := ss.HasKey("key")
			assert.Equal(t, table.val != nil, exists)
		})
	}
}

func TestSessionGet(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name string
		val  interface{}
	}{
		{"existent", "val"},
		{"unexistent", nil},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			ss := sessionPool.NewSession(nil, true).(*sessionImpl)
			assert.NotNil(t, ss)

			if table.val != nil {
				err := ss.Set("key", table.val)
				assert.NoError(t, err)
				assert.NotEmpty(t, ss.data)
			}

			val := ss.Get("key")
			assert.Equal(t, table.val, val)
		})
	}
}

func TestSessionInt(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name         string
		val          interface{}
		shouldReturn bool
	}{
		{"existent", 1, true},
		{"existent_wrong_type", "val", false},
		{"unexistent", nil, false},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			ss := sessionPool.NewSession(nil, true).(*sessionImpl)
			assert.NotNil(t, ss)

			if table.val != nil {
				err := ss.Set("key", table.val)
				assert.NoError(t, err)
				assert.NotEmpty(t, ss.data)
			}

			val := ss.Int("key")
			if table.shouldReturn {
				assert.Equal(t, table.val, val)
			} else {
				assert.Equal(t, 0, val)
			}
		})
	}
}

func TestSessionInt8(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name         string
		val          interface{}
		shouldReturn bool
	}{
		{"existent", int8(1), true},
		{"existent_wrong_type", "val", false},
		{"unexistent", nil, false},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			ss := sessionPool.NewSession(nil, true).(*sessionImpl)
			assert.NotNil(t, ss)

			if table.val != nil {
				err := ss.Set("key", table.val)
				assert.NoError(t, err)
				assert.NotEmpty(t, ss.data)
			}

			val := ss.Int8("key")
			if table.shouldReturn {
				assert.Equal(t, table.val, val)
			} else {
				assert.Equal(t, int8(0), val)
			}
		})
	}
}

func TestSessionInt16(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name         string
		val          interface{}
		shouldReturn bool
	}{
		{"existent", int16(1), true},
		{"existent_wrong_type", "val", false},
		{"unexistent", nil, false},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			ss := sessionPool.NewSession(nil, true).(*sessionImpl)
			assert.NotNil(t, ss)

			if table.val != nil {
				err := ss.Set("key", table.val)
				assert.NoError(t, err)
				assert.NotEmpty(t, ss.data)
			}

			val := ss.Int16("key")
			if table.shouldReturn {
				assert.Equal(t, table.val, val)
			} else {
				assert.Equal(t, int16(0), val)
			}
		})
	}
}

func TestSessionInt32(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name         string
		val          interface{}
		shouldReturn bool
	}{
		{"existent", int32(1), true},
		{"existent_wrong_type", "val", false},
		{"unexistent", nil, false},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			ss := sessionPool.NewSession(nil, true).(*sessionImpl)
			assert.NotNil(t, ss)

			if table.val != nil {
				err := ss.Set("key", table.val)
				assert.NoError(t, err)
				assert.NotEmpty(t, ss.data)
			}

			val := ss.Int32("key")
			if table.shouldReturn {
				assert.Equal(t, table.val, val)
			} else {
				assert.Equal(t, int32(0), val)
			}
		})
	}
}

func TestSessionInt64(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name         string
		val          interface{}
		shouldReturn bool
	}{
		{"existent", int64(1), true},
		{"existent_wrong_type", "val", false},
		{"unexistent", nil, false},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			ss := sessionPool.NewSession(nil, true).(*sessionImpl)
			assert.NotNil(t, ss)

			if table.val != nil {
				err := ss.Set("key", table.val)
				assert.NoError(t, err)
				assert.NotEmpty(t, ss.data)
			}

			val := ss.Int64("key")
			if table.shouldReturn {
				assert.Equal(t, table.val, val)
			} else {
				assert.Equal(t, int64(0), val)
			}
		})
	}
}

func TestSessionUint(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name         string
		val          interface{}
		shouldReturn bool
	}{
		{"existent", uint(1), true},
		{"existent_wrong_type", "val", false},
		{"unexistent", nil, false},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			ss := sessionPool.NewSession(nil, true).(*sessionImpl)
			assert.NotNil(t, ss)

			if table.val != nil {
				err := ss.Set("key", table.val)
				assert.NoError(t, err)
				assert.NotEmpty(t, ss.data)
			}

			val := ss.Uint("key")
			if table.shouldReturn {
				assert.Equal(t, table.val, val)
			} else {
				assert.Equal(t, uint(0), val)
			}
		})
	}
}

func TestSessionUint8(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name         string
		val          interface{}
		shouldReturn bool
	}{
		{"existent", uint8(1), true},
		{"existent_wrong_type", "val", false},
		{"unexistent", nil, false},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			ss := sessionPool.NewSession(nil, true).(*sessionImpl)
			assert.NotNil(t, ss)

			if table.val != nil {
				err := ss.Set("key", table.val)
				assert.NoError(t, err)
				assert.NotEmpty(t, ss.data)
			}

			val := ss.Uint8("key")
			if table.shouldReturn {
				assert.Equal(t, table.val, val)
			} else {
				assert.Equal(t, uint8(0), val)
			}
		})
	}
}

func TestSessionUint16(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name         string
		val          interface{}
		shouldReturn bool
	}{
		{"existent", uint16(1), true},
		{"existent_wrong_type", "val", false},
		{"unexistent", nil, false},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			ss := sessionPool.NewSession(nil, true).(*sessionImpl)
			assert.NotNil(t, ss)

			if table.val != nil {
				err := ss.Set("key", table.val)
				assert.NoError(t, err)
				assert.NotEmpty(t, ss.data)
			}

			val := ss.Uint16("key")
			if table.shouldReturn {
				assert.Equal(t, table.val, val)
			} else {
				assert.Equal(t, uint16(0), val)
			}
		})
	}
}

func TestSessionUint32(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name         string
		val          interface{}
		shouldReturn bool
	}{
		{"existent", uint32(1), true},
		{"existent_wrong_type", "val", false},
		{"unexistent", nil, false},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			ss := sessionPool.NewSession(nil, true).(*sessionImpl)
			assert.NotNil(t, ss)

			if table.val != nil {
				err := ss.Set("key", table.val)
				assert.NoError(t, err)
				assert.NotEmpty(t, ss.data)
			}

			val := ss.Uint32("key")
			if table.shouldReturn {
				assert.Equal(t, table.val, val)
			} else {
				assert.Equal(t, uint32(0), val)
			}
		})
	}
}

func TestSessionUint64(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name         string
		val          interface{}
		shouldReturn bool
	}{
		{"existent", uint64(1), true},
		{"existent_wrong_type", "val", false},
		{"unexistent", nil, false},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			ss := sessionPool.NewSession(nil, true).(*sessionImpl)
			assert.NotNil(t, ss)

			if table.val != nil {
				err := ss.Set("key", table.val)
				assert.NoError(t, err)
				assert.NotEmpty(t, ss.data)
			}

			val := ss.Uint64("key")
			if table.shouldReturn {
				assert.Equal(t, table.val, val)
			} else {
				assert.Equal(t, uint64(0), val)
			}
		})
	}
}

func TestSessionFloat32(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name         string
		val          interface{}
		shouldReturn bool
	}{
		{"existent", float32(1), true},
		{"existent_wrong_type", "val", false},
		{"unexistent", nil, false},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			ss := sessionPool.NewSession(nil, true).(*sessionImpl)
			assert.NotNil(t, ss)

			if table.val != nil {
				err := ss.Set("key", table.val)
				assert.NoError(t, err)
				assert.NotEmpty(t, ss.data)
			}

			val := ss.Float32("key")
			if table.shouldReturn {
				assert.Equal(t, table.val, val)
			} else {
				assert.Equal(t, float32(0), val)
			}
		})
	}
}

func TestSessionFloat64(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name         string
		val          interface{}
		shouldReturn bool
	}{
		{"existent", float64(1), true},
		{"existent_wrong_type", "val", false},
		{"unexistent", nil, false},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			ss := sessionPool.NewSession(nil, true).(*sessionImpl)
			assert.NotNil(t, ss)

			if table.val != nil {
				err := ss.Set("key", table.val)
				assert.NoError(t, err)
				assert.NotEmpty(t, ss.data)
			}

			val := ss.Float64("key")
			if table.shouldReturn {
				assert.Equal(t, table.val, val)
			} else {
				assert.Equal(t, float64(0), val)
			}
		})
	}
}

func TestSessionString(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name         string
		val          interface{}
		shouldReturn bool
	}{
		{"existent", "val", true},
		{"existent_wrong_type", 1, false},
		{"unexistent", nil, false},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			ss := sessionPool.NewSession(nil, true).(*sessionImpl)
			assert.NotNil(t, ss)

			if table.val != nil {
				err := ss.Set("key", table.val)
				assert.NoError(t, err)
				assert.NotEmpty(t, ss.data)
			}

			val := ss.String("key")
			if table.shouldReturn {
				assert.Equal(t, table.val, val)
			} else {
				assert.Equal(t, "", val)
			}
		})
	}
}

func TestSessionValue(t *testing.T) {
	t.Parallel()

	tables := []struct {
		name string
		val  interface{}
	}{
		{"existent", "val"},
		{"unexistent", nil},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			ss := sessionPool.NewSession(nil, true).(*sessionImpl)
			assert.NotNil(t, ss)

			if table.val != nil {
				err := ss.Set("key", table.val)
				assert.NoError(t, err)
				assert.NotEmpty(t, ss.data)
			}

			val := ss.Value("key")
			assert.Equal(t, table.val, val)
		})
	}
}

func TestSessionPushToFrontFailsIfFrontend(t *testing.T) {
	t.Parallel()

	sessionPool := NewSessionPool()
	ss := sessionPool.NewSession(nil, true)
	assert.NotNil(t, ss)

	err := ss.PushToFront(nil)
	assert.Equal(t, constants.ErrFrontSessionCantPushToFront, err)
}

func TestSessionPushToFront(t *testing.T) {
	t.Parallel()
	tables := []struct {
		name string
		err  error
	}{
		{"successful_request", nil},
		{"failed_request", errors.New("failed bind in front")},
	}

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			mockEntity := mocks.NewMockNetworkEntity(ctrl)
			sessionPool := NewSessionPool()
			ss := sessionPool.NewSession(mockEntity, false).(*sessionImpl)
			assert.NotNil(t, ss)
			ss.Set("key", "val")
			uid := uuid.New().String()
			ss.uid = uid

			expectedSessionData := &protos.Session{
				Id:   ss.frontendSessionID,
				Uid:  uid,
				Data: ss.encodedData,
			}
			expectedRequestData, err := proto.Marshal(expectedSessionData)
			assert.NoError(t, err)
			ctx := context.Background()
			mockEntity.EXPECT().SendRequest(ctx, ss.frontendID, constants.SessionPushRoute, expectedRequestData).Return(nil, table.err)

			err = ss.PushToFront(ctx)
			assert.Equal(t, table.err, err)
		})
	}
}

func TestSessionClear(t *testing.T) {
	t.Parallel()

	sessionPool := NewSessionPool()
	ss := sessionPool.NewSession(nil, true).(*sessionImpl)
	assert.NotNil(t, ss)

	ss.uid = uuid.New().String()
	err := ss.Set("key", "val")
	assert.NoError(t, err)
	assert.NotEmpty(t, ss.data)
	assert.NotEmpty(t, ss.encodedData)

	ss.Clear()
	assert.Empty(t, ss.data)

	expectedEncoded := getEncodedEmptyMap()
	assert.Equal(t, expectedEncoded, ss.encodedData)
}

func TestSessionGetHandshakeData(t *testing.T) {
	t.Parallel()

	data1 := &HandshakeData{
		Sys: HandshakeClientData{
			Platform:    "macos",
			LibVersion:  "2.3.2",
			BuildNumber: "20",
			Version:     "14.0.2",
		},
		User: make(map[string]interface{}),
	}
	data2 := &HandshakeData{
		Sys: HandshakeClientData{
			Platform:    "windows",
			LibVersion:  "2.3.10",
			BuildNumber: "",
			Version:     "ahaha",
		},
		User: map[string]interface{}{
			"ababa": make(map[string]interface{}),
			"pepe":  1,
		},
	}
	tables := []struct {
		name string
		data *HandshakeData
	}{
		{"test_1", data1},
		{"test_2", data2},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			ss := sessionPool.NewSession(nil, false).(*sessionImpl)

			assert.Nil(t, ss.GetHandshakeData())

			ss.handshakeData = table.data

			assert.Equal(t, ss.GetHandshakeData(), table.data)
		})
	}
}

func TestSessionSetHandshakeData(t *testing.T) {
	t.Parallel()

	data1 := &HandshakeData{
		Sys: HandshakeClientData{
			Platform:    "macos",
			LibVersion:  "2.3.2",
			BuildNumber: "20",
			Version:     "14.0.2",
		},
		User: make(map[string]interface{}),
	}
	data2 := &HandshakeData{
		Sys: HandshakeClientData{
			Platform:    "windows",
			LibVersion:  "2.3.10",
			BuildNumber: "",
			Version:     "ahaha",
		},
		User: map[string]interface{}{
			"ababa": make(map[string]interface{}),
			"pepe":  1,
		},
	}
	tables := []struct {
		name string
		data *HandshakeData
	}{
		{"testSessionSetData_1", data1},
		{"testSessionSetData_2", data2},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			ss := sessionPool.NewSession(nil, false).(*sessionImpl)
			ss.SetHandshakeData(table.data)
			assert.Equal(t, table.data, ss.handshakeData)
		})
	}
}

func TestSessionPoolAddHandshakeValidator(t *testing.T) {
	fa := func(data *HandshakeData) error { return nil }
	fb := func(data *HandshakeData) error { return errors.New("error") }

	tables := []struct {
		name       string
		validators map[string]func(data *HandshakeData) error
		result     int
	}{
		{"add validator", map[string]func(data *HandshakeData) error{"fa": fa}, 1},
		{"add many validators", map[string]func(data *HandshakeData) error{"fa": fa, "fb": fb}, 2},
	}
	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			for name, fun := range table.validators {
				sessionPool.AddHandshakeValidator(name, fun)
			}
			session := sessionPool.NewSession(nil, false).(*sessionImpl)
			validators := session.GetHandshakeValidators()
			assert.Equal(t, len(validators), table.result)
		})
	}
}

func TestSessionValidateHandshake(t *testing.T) {
	fa := func(data *HandshakeData) error { return nil }
	fb := func(data *HandshakeData) error { return errors.New("error") }

	tables := []struct {
		name       string
		validators map[string]func(data *HandshakeData) error
		errStr     string
	}{
		{"one passing validator", map[string]func(data *HandshakeData) error{"fa": fa}, ""},
		{"one failing validator", map[string]func(data *HandshakeData) error{"fb": fb}, "failed to run 'fb'"},
		{"many validators all passing", map[string]func(data *HandshakeData) error{"fa": fa, "fb": fa}, ""},
		{"many validators one failing", map[string]func(data *HandshakeData) error{"fa": fa, "fb": fb}, "failed to run 'fb'"},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			sessionPool := NewSessionPool()
			for name, fun := range table.validators {
				sessionPool.AddHandshakeValidator(name, fun)
			}
			session := sessionPool.NewSession(nil, false).(*sessionImpl)
			err := session.ValidateHandshake(nil)

			if table.errStr != "" {
				assert.Error(t, err)
				assert.Contains(t, err.Error(), table.errStr)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestGetNumberOfConnectedClients(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	entity := mocks.NewMockNetworkEntity(ctrl)
	sessionPool := NewSessionPool()
	connections := sessionPool.GetNumberOfConnectedClients()
	assert.Equal(t, int64(0), connections)

	ss := sessionPool.NewSession(entity, true)
	assert.NotNil(t, ss)
	connections = sessionPool.GetNumberOfConnectedClients()
	assert.Equal(t, int64(1), connections)
}

```

`pkg/session/static.go`:

```go
package session

import (
	"context"
)

var DefaultSessionPool SessionPool

// GetSessionByUID return a session bound to an user id
func GetSessionByUID(uid string) Session {
	return DefaultSessionPool.GetSessionByUID(uid)
}

// GetSessionByID return a session bound to a frontend server id
func GetSessionByID(id int64) Session {
	return DefaultSessionPool.GetSessionByID(id)
}

// OnSessionBind adds a method to be called when a session is bound
// same function cannot be added twice!
func OnSessionBind(f func(ctx context.Context, s Session) error) {
	DefaultSessionPool.OnSessionBind(f)
}

// OnAfterSessionBind adds a method to be called when session is bound and after all sessionBind callbacks
func OnAfterSessionBind(f func(ctx context.Context, s Session) error) {
	DefaultSessionPool.OnAfterSessionBind(f)
}

// OnSessionClose adds a method that will be called when every session closes
func OnSessionClose(f func(s Session)) {
	DefaultSessionPool.OnSessionClose(f)
}

// CloseAll calls Close on all sessions
func CloseAll() {
	DefaultSessionPool.CloseAll()
}

// GetNumberOfConnectedClients returns the number of connected clients
func GetNumberOfConnectedClients() int64 {
	return DefaultSessionPool.GetNumberOfConnectedClients()
}

```

`pkg/session/test/static_test.go`:

```go
package test

import (
	"math"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/google/uuid"
	"github.com/stretchr/testify/require"
	"github.com/topfreegames/pitaya/v3/pkg/session"
	"github.com/topfreegames/pitaya/v3/pkg/session/mocks"
)

func TestStaticGetSessionByUID(t *testing.T) {
	createSessionMock := func(ctrl *gomock.Controller) session.Session {
		return mocks.NewMockSession(ctrl)
	}
	createNilSession := func(ctrl *gomock.Controller) session.Session {
		return mocks.NewMockSession(ctrl)
	}

	tables := []struct {
		name    string
		uid     string
		factory func(ctrl *gomock.Controller) session.Session
	}{
		{"Success", uuid.New().String(), createSessionMock},
		{"Error", uuid.New().String(), createNilSession},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			expectedSession := row.factory(ctrl)

			sessionPool := mocks.NewMockSessionPool(ctrl)
			sessionPool.EXPECT().GetSessionByUID(row.uid).Return(expectedSession)

			session.DefaultSessionPool = sessionPool
			session := session.GetSessionByUID(row.uid)
			require.Equal(t, expectedSession, session)
		})
	}
}

func TestStaticGetSessionByID(t *testing.T) {
	createSessionMock := func(ctrl *gomock.Controller) session.Session {
		return mocks.NewMockSession(ctrl)
	}
	createNilSession := func(ctrl *gomock.Controller) session.Session {
		return mocks.NewMockSession(ctrl)
	}

	tables := []struct {
		name    string
		id      int64
		factory func(ctrl *gomock.Controller) session.Session
	}{
		{"Success", 3, createSessionMock},
		{"Error", 3, createNilSession},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			expectedSession := row.factory(ctrl)

			sessionPool := mocks.NewMockSessionPool(ctrl)
			sessionPool.EXPECT().GetSessionByID(row.id).Return(expectedSession)

			session.DefaultSessionPool = sessionPool
			session := session.GetSessionByID(row.id)
			require.Equal(t, expectedSession, session)
		})
	}
}

func TestStaticOnSessionBind(t *testing.T) {
	ctrl := gomock.NewController(t)

	sessionPool := mocks.NewMockSessionPool(ctrl)
	sessionPool.EXPECT().OnSessionBind(nil)

	session.DefaultSessionPool = sessionPool
	session.OnSessionBind(nil)
}

func TestStaticOnAfterSessionBind(t *testing.T) {
	ctrl := gomock.NewController(t)

	sessionPool := mocks.NewMockSessionPool(ctrl)
	sessionPool.EXPECT().OnAfterSessionBind(nil)

	session.DefaultSessionPool = sessionPool
	session.OnAfterSessionBind(nil)
}

func TestStaticOnSessionClose(t *testing.T) {
	ctrl := gomock.NewController(t)

	sessionPool := mocks.NewMockSessionPool(ctrl)
	sessionPool.EXPECT().OnSessionClose(nil)

	session.DefaultSessionPool = sessionPool
	session.OnSessionClose(nil)
}

func TestStaticCloseAll(t *testing.T) {
	ctrl := gomock.NewController(t)

	sessionPool := mocks.NewMockSessionPool(ctrl)
	sessionPool.EXPECT().CloseAll()

	session.DefaultSessionPool = sessionPool
	session.CloseAll()
}

func TestGetNumberOfConnectedClients(t *testing.T) {
	ctrl := gomock.NewController(t)

	expected := int64(math.MaxInt64)
	sessionPool := mocks.NewMockSessionPool(ctrl)
	sessionPool.EXPECT().GetNumberOfConnectedClients().Return(expected)

	session.DefaultSessionPool = sessionPool
	numberOfConnections := session.GetNumberOfConnectedClients()
	require.Equal(t, expected, numberOfConnections)
}

```

`pkg/static.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package pitaya

import (
	"context"
	"time"

	"github.com/golang/protobuf/proto"
	"github.com/spf13/viper"
	"github.com/topfreegames/pitaya/v3/pkg/cluster"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/interfaces"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
	"github.com/topfreegames/pitaya/v3/pkg/router"
	"github.com/topfreegames/pitaya/v3/pkg/session"
	"github.com/topfreegames/pitaya/v3/pkg/worker"
)

var DefaultApp Pitaya

// Configure configures the app
func Configure(
	isFrontend bool,
	serverType string,
	serverMode ServerMode,
	serverMetadata map[string]string,
	cfgs ...*viper.Viper,
) {
	builder := NewBuilderWithConfigs(
		isFrontend,
		serverType,
		serverMode,
		serverMetadata,
		config.NewConfig(cfgs...),
	)
	DefaultApp = builder.Build()
	session.DefaultSessionPool = builder.SessionPool
}

func GetDieChan() chan bool {
	return DefaultApp.GetDieChan()
}

func SetDebug(debug bool) {
	DefaultApp.SetDebug(debug)
}

func SetHeartbeatTime(interval time.Duration) {
	DefaultApp.SetHeartbeatTime(interval)
}

func GetServerID() string {
	return DefaultApp.GetServerID()
}

func GetMetricsReporters() []metrics.Reporter {
	return DefaultApp.GetMetricsReporters()
}

func GetServer() *cluster.Server {
	return DefaultApp.GetServer()
}

func GetServerByID(id string) (*cluster.Server, error) {
	return DefaultApp.GetServerByID(id)
}

func GetServersByType(t string) (map[string]*cluster.Server, error) {
	return DefaultApp.GetServersByType(t)
}

func GetServers() []*cluster.Server {
	return DefaultApp.GetServers()
}

func GetSessionFromCtx(ctx context.Context) session.Session {
	sessionVal := ctx.Value(constants.SessionCtxKey)
	if sessionVal == nil {
		return nil
	}
	return sessionVal.(session.Session)
}

func Start() {
	DefaultApp.Start()
}

func SetDictionary(dict map[string]uint16) error {
	return DefaultApp.SetDictionary(dict)
}

func AddRoute(serverType string, routingFunction router.RoutingFunc) error {
	return DefaultApp.AddRoute(serverType, routingFunction)
}

func Shutdown() {
	DefaultApp.Shutdown()
}

func StartWorker() {
	DefaultApp.StartWorker()
}

func RegisterRPCJob(rpcJob worker.RPCJob) error {
	return DefaultApp.RegisterRPCJob(rpcJob)
}

func Documentation(getPtrNames bool) (map[string]interface{}, error) {
	return DefaultApp.Documentation(getPtrNames)
}

func IsRunning() bool {
	return DefaultApp.IsRunning()
}

func RPC(ctx context.Context, routeStr string, reply proto.Message, arg proto.Message) error {
	return DefaultApp.RPC(ctx, routeStr, reply, arg)
}

func RPCTo(ctx context.Context, serverID, routeStr string, reply proto.Message, arg proto.Message) error {
	return DefaultApp.RPCTo(ctx, serverID, routeStr, reply, arg)
}

func ReliableRPC(routeStr string, metadata map[string]interface{}, reply, arg proto.Message) (jid string, err error) {
	return DefaultApp.ReliableRPC(routeStr, metadata, reply, arg)
}

func ReliableRPCWithOptions(routeStr string, metadata map[string]interface{}, reply, arg proto.Message, opts *config.EnqueueOpts) (jid string, err error) {
	return DefaultApp.ReliableRPCWithOptions(routeStr, metadata, reply, arg, opts)
}

func SendPushToUsers(route string, v interface{}, uids []string, frontendType string) ([]string, error) {
	return DefaultApp.SendPushToUsers(route, v, uids, frontendType)
}

func SendKickToUsers(uids []string, frontendType string) ([]string, error) {
	return DefaultApp.SendKickToUsers(uids, frontendType)
}

func GroupCreate(ctx context.Context, groupName string) error {
	return DefaultApp.GroupCreate(ctx, groupName)
}

func GroupCreateWithTTL(ctx context.Context, groupName string, ttlTime time.Duration) error {
	return DefaultApp.GroupCreateWithTTL(ctx, groupName, ttlTime)
}

func GroupMembers(ctx context.Context, groupName string) ([]string, error) {
	return DefaultApp.GroupMembers(ctx, groupName)
}

func GroupBroadcast(ctx context.Context, frontendType, groupName, route string, v interface{}) error {
	return DefaultApp.GroupBroadcast(ctx, frontendType, groupName, route, v)
}

func GroupContainsMember(ctx context.Context, groupName, uid string) (bool, error) {
	return DefaultApp.GroupContainsMember(ctx, groupName, uid)
}

func GroupAddMember(ctx context.Context, groupName, uid string) error {
	return DefaultApp.GroupAddMember(ctx, groupName, uid)
}

func GroupRemoveMember(ctx context.Context, groupName, uid string) error {
	return DefaultApp.GroupRemoveMember(ctx, groupName, uid)
}

func GroupRemoveAll(ctx context.Context, groupName string) error {
	return DefaultApp.GroupRemoveAll(ctx, groupName)
}

func GroupCountMembers(ctx context.Context, groupName string) (int, error) {
	return DefaultApp.GroupCountMembers(ctx, groupName)
}

func GroupRenewTTL(ctx context.Context, groupName string) error {
	return DefaultApp.GroupRenewTTL(ctx, groupName)
}

func GroupDelete(ctx context.Context, groupName string) error {
	return DefaultApp.GroupDelete(ctx, groupName)
}

func Register(c component.Component, options ...component.Option) {
	DefaultApp.Register(c, options...)
}

func RegisterRemote(c component.Component, options ...component.Option) {
	DefaultApp.RegisterRemote(c, options...)
}

func RegisterModule(module interfaces.Module, name string) error {
	return DefaultApp.RegisterModule(module, name)
}

func RegisterModuleAfter(module interfaces.Module, name string) error {
	return DefaultApp.RegisterModuleAfter(module, name)
}

func RegisterModuleBefore(module interfaces.Module, name string) error {
	return DefaultApp.RegisterModuleBefore(module, name)
}

func GetModule(name string) (interfaces.Module, error) {
	return DefaultApp.GetModule(name)
}

func GetNumberOfConnectedClients() int64 {
	return DefaultApp.GetNumberOfConnectedClients()
}

func IsReady(ctx context.Context) bool {
	return DefaultApp.IsReady(ctx)
}

```

`pkg/static_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package pitaya

import (
	"context"
	"errors"
	"math"
	"testing"
	"time"

	"github.com/topfreegames/pitaya/v3/pkg/constants"

	"github.com/golang/mock/gomock"
	"github.com/golang/protobuf/proto"
	"github.com/google/uuid"
	"github.com/spf13/viper"
	"github.com/stretchr/testify/require"
	"github.com/topfreegames/pitaya/v3/pkg/cluster"
	"github.com/topfreegames/pitaya/v3/pkg/component"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/interfaces"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
	"github.com/topfreegames/pitaya/v3/pkg/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/session"
	sessionmocks "github.com/topfreegames/pitaya/v3/pkg/session/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/worker"
	workermocks "github.com/topfreegames/pitaya/v3/pkg/worker/mocks"
	"google.golang.org/protobuf/runtime/protoiface"
)

func TestStaticConfigure(t *testing.T) {
	Configure(true, "frontendType", Cluster, map[string]string{}, []*viper.Viper{}...)

	require.NotNil(t, DefaultApp)
	require.NotNil(t, session.DefaultSessionPool)
}

func TestStaticGetDieChan(t *testing.T) {
	ctrl := gomock.NewController(t)

	expected := make(chan bool)

	app := mocks.NewMockPitaya(ctrl)
	app.EXPECT().GetDieChan().Return(expected)

	DefaultApp = app
	require.Equal(t, expected, GetDieChan())
}

func TestStaticSetDebug(t *testing.T) {
	ctrl := gomock.NewController(t)

	expected := true

	app := mocks.NewMockPitaya(ctrl)
	app.EXPECT().SetDebug(expected)

	DefaultApp = app
	SetDebug(expected)
}

func TestStaticSetHeartbeatTime(t *testing.T) {
	ctrl := gomock.NewController(t)

	expected := 2 * time.Second

	app := mocks.NewMockPitaya(ctrl)
	app.EXPECT().SetHeartbeatTime(expected)

	DefaultApp = app
	SetHeartbeatTime(expected)
}

func TestStaticGetServerID(t *testing.T) {
	ctrl := gomock.NewController(t)

	expected := uuid.New().String()

	app := mocks.NewMockPitaya(ctrl)
	app.EXPECT().GetServerID().Return(expected)

	DefaultApp = app
	require.Equal(t, expected, GetServerID())
}

func TestStaticGetMetricsReporters(t *testing.T) {
	ctrl := gomock.NewController(t)

	expected := []metrics.Reporter{}

	app := mocks.NewMockPitaya(ctrl)
	app.EXPECT().GetMetricsReporters().Return(expected)

	DefaultApp = app
	require.Equal(t, expected, GetMetricsReporters())
}

func TestStaticGetServer(t *testing.T) {
	ctrl := gomock.NewController(t)

	expected := &cluster.Server{}

	app := mocks.NewMockPitaya(ctrl)
	app.EXPECT().GetServer().Return(expected)

	DefaultApp = app
	require.Equal(t, expected, GetServer())
}

func TestStaticGetServerByID(t *testing.T) {
	tables := []struct {
		name   string
		id     string
		err    error
		server *cluster.Server
	}{
		{"Success", uuid.New().String(), nil, &cluster.Server{}},
		{"Error", uuid.New().String(), errors.New("error"), nil},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().GetServerByID(row.id).Return(row.server, row.err)

			DefaultApp = app
			server, err := GetServerByID(row.id)
			require.Equal(t, row.err, err)
			require.Equal(t, row.server, server)
		})
	}
}

func TestStaticGetServersByType(t *testing.T) {
	tables := []struct {
		name   string
		typ    string
		err    error
		server map[string]*cluster.Server
	}{
		{"Success", "type", nil, map[string]*cluster.Server{"type": {}}},
		{"Error", "type", errors.New("error"), nil},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().GetServersByType(row.typ).Return(row.server, row.err)

			DefaultApp = app
			server, err := GetServersByType(row.typ)
			require.Equal(t, row.err, err)
			require.Equal(t, row.server, server)
		})
	}
}

func TestStaticGetServers(t *testing.T) {
	ctrl := gomock.NewController(t)

	expected := []*cluster.Server{{}}

	app := mocks.NewMockPitaya(ctrl)
	app.EXPECT().GetServers().Return(expected)

	DefaultApp = app
	require.Equal(t, expected, GetServers())
}

func TestStaticGetSessionFromCtx(t *testing.T) {
	ctrl := gomock.NewController(t)
	ss := sessionmocks.NewMockSession(ctrl)

	ctx := context.WithValue(context.Background(), constants.SessionCtxKey, ss)
	s := GetSessionFromCtx(ctx)
	require.Equal(t, ss, s)
}

func TestStaticStart(t *testing.T) {
	ctrl := gomock.NewController(t)

	app := mocks.NewMockPitaya(ctrl)
	app.EXPECT().Start()

	DefaultApp = app
	Start()
}

func TestStaticSetDictionary(t *testing.T) {
	ctrl := gomock.NewController(t)

	expected := map[string]uint16{"test": 1}

	app := mocks.NewMockPitaya(ctrl)
	app.EXPECT().SetDictionary(expected).Return(nil)

	DefaultApp = app
	SetDictionary(expected)
}

func TestStaticAddRoute(t *testing.T) {
	tables := []struct {
		name       string
		serverType string
		err        error
	}{
		{"Success", "type", nil},
		{"Error", "type", errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().AddRoute(row.serverType, nil).Return(row.err) // Note that functions can't be tested for equality

			DefaultApp = app
			err := AddRoute(row.serverType, nil)
			require.Equal(t, row.err, err)
		})
	}
}

func TestStaticShutdown(t *testing.T) {
	ctrl := gomock.NewController(t)

	app := mocks.NewMockPitaya(ctrl)
	app.EXPECT().Shutdown()

	DefaultApp = app
	Shutdown()
}

func TestStaticStartWorker(t *testing.T) {
	ctrl := gomock.NewController(t)

	app := mocks.NewMockPitaya(ctrl)
	app.EXPECT().StartWorker()

	DefaultApp = app
	StartWorker()
}

func TestStaticRegisterRPCJob(t *testing.T) {
	create := func(ctrl *gomock.Controller) worker.RPCJob {
		return workermocks.NewMockRPCJob(ctrl)
	}

	tables := []struct {
		name   string
		create func(ctrl *gomock.Controller) worker.RPCJob
		err    error
	}{
		{"Success", create, nil},
		{"Error", create, errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			job := create(ctrl)
			app.EXPECT().RegisterRPCJob(job).Return(row.err)

			DefaultApp = app
			err := RegisterRPCJob(job)
			require.Equal(t, row.err, err)
		})
	}
}

func TestStaticDocumentation(t *testing.T) {
	tables := []struct {
		name         string
		expectedBool bool
		returned     map[string]interface{}
		err          error
	}{
		{"Success", true, map[string]interface{}{}, nil},
		{"Error", true, nil, errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().Documentation(row.expectedBool).Return(row.returned, row.err)

			DefaultApp = app
			ret, err := Documentation(row.expectedBool)
			require.Equal(t, row.returned, ret)
			require.Equal(t, row.err, err)
		})
	}
}

func TestStaticIsRunning(t *testing.T) {
	tables := []struct {
		name     string
		returned bool
	}{
		{"Success", true},
		{"Error", false},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().IsRunning().Return(row.returned)

			DefaultApp = app
			require.Equal(t, row.returned, IsRunning())
		})
	}
}

func TestStaticRPC(t *testing.T) {
	ctx := context.Background()
	routeStr := "route"
	var reply protoiface.MessageV1
	var arg protoiface.MessageV1

	tables := []struct {
		name     string
		returned error
	}{
		{"Success", nil},
		{"Error", errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().RPC(ctx, routeStr, reply, arg).Return(row.returned)

			DefaultApp = app
			require.Equal(t, row.returned, RPC(ctx, routeStr, reply, arg))
		})
	}
}

func TestStaticRPCTo(t *testing.T) {
	ctx := context.Background()
	routeStr := "route"
	serverId := uuid.New().String()
	var reply protoiface.MessageV1
	var arg protoiface.MessageV1

	tables := []struct {
		name     string
		returned error
	}{
		{"Success", nil},
		{"Error", errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().RPCTo(ctx, serverId, routeStr, reply, arg).Return(row.returned)

			DefaultApp = app
			require.Equal(t, row.returned, RPCTo(ctx, serverId, routeStr, reply, arg))
		})
	}
}

func TestStaticReliableRPC(t *testing.T) {
	tables := []struct {
		name     string
		route    string
		metadata map[string]interface{}
		reply    proto.Message
		arg      proto.Message
		jid      string
		err      error
	}{
		{"Success", "route", map[string]interface{}{}, nil, nil, "jid", nil},
		{"Error", "route", map[string]interface{}{}, nil, nil, "", errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().ReliableRPC(row.route, row.metadata, row.reply, row.arg).Return(row.jid, row.err)

			DefaultApp = app
			jid, err := ReliableRPC(row.route, row.metadata, row.reply, row.arg)
			require.Equal(t, row.err, err)
			require.Equal(t, row.jid, jid)
		})
	}
}

func TestStaticReliableRPCWithOptions(t *testing.T) {
	tables := []struct {
		name     string
		route    string
		metadata map[string]interface{}
		reply    proto.Message
		arg      proto.Message
		opts     *config.EnqueueOpts
		jid      string
		err      error
	}{
		{"Success", "route", map[string]interface{}{}, nil, nil, nil, "jid", nil},
		{"Error", "route", map[string]interface{}{}, nil, nil, nil, "", errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().ReliableRPCWithOptions(row.route, row.metadata, row.reply, row.arg, row.opts).Return(row.jid, row.err)

			DefaultApp = app
			jid, err := ReliableRPCWithOptions(row.route, row.metadata, row.reply, row.arg, row.opts)
			require.Equal(t, row.err, err)
			require.Equal(t, row.jid, jid)
		})
	}
}

func TestStaticSendPushToUsers(t *testing.T) {
	tables := []struct {
		name         string
		route        string
		v            interface{}
		uids         []string
		frontendType string
		returned     []string
		err          error
	}{
		{"Success", "route", nil, []string{"member"}, "frontendType", []string{"returned"}, nil},
		{"Error", "route", nil, nil, "frontendType", nil, errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().SendPushToUsers(row.route, row.v, row.uids, row.frontendType).Return(row.returned, row.err)

			DefaultApp = app
			returned, err := SendPushToUsers(row.route, row.v, row.uids, row.frontendType)
			require.Equal(t, row.err, err)
			require.Equal(t, row.returned, returned)
		})
	}
}

func TestStaticSendKickToUsers(t *testing.T) {
	tables := []struct {
		name         string
		uids         []string
		frontendType string
		returned     []string
		err          error
	}{
		{"Success", []string{"member"}, "frontendType", []string{"returned"}, nil},
		{"Error", nil, "frontendType", nil, errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().SendKickToUsers(row.uids, row.frontendType).Return(row.returned, row.err)

			DefaultApp = app
			returned, err := SendKickToUsers(row.uids, row.frontendType)
			require.Equal(t, row.err, err)
			require.Equal(t, row.returned, returned)
		})
	}
}

func TestStaticGroupCreate(t *testing.T) {
	ctx := context.Background()
	groupName := "group"

	tables := []struct {
		name     string
		returned error
	}{
		{"Success", nil},
		{"Error", errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().GroupCreate(ctx, groupName).Return(row.returned)

			DefaultApp = app
			require.Equal(t, row.returned, GroupCreate(ctx, groupName))
		})
	}
}

func TestStaticGroupCreateWithTTL(t *testing.T) {
	ctx := context.Background()
	groupName := "group"
	ttl := 2 * time.Second

	tables := []struct {
		name     string
		returned error
	}{
		{"Success", nil},
		{"Error", errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().GroupCreateWithTTL(ctx, groupName, ttl).Return(row.returned)

			DefaultApp = app
			require.Equal(t, row.returned, GroupCreateWithTTL(ctx, groupName, ttl))
		})
	}
}

func TestStaticGroupMembers(t *testing.T) {
	ctx := context.Background()
	tables := []struct {
		name      string
		groupName string
		members   []string
		err       error
	}{
		{"Success", "name", []string{"member"}, nil},
		{"Error", "name", nil, errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().GroupMembers(ctx, row.groupName).Return(row.members, row.err)

			DefaultApp = app
			members, err := GroupMembers(ctx, row.groupName)
			require.Equal(t, row.err, err)
			require.Equal(t, row.members, members)
		})
	}
}

func TestStaticGroupBroadcast(t *testing.T) {
	ctx := context.Background()
	groupName := "group"
	frontendType := "type"
	route := "route"

	tables := []struct {
		name     string
		returned error
	}{
		{"Success", nil},
		{"Error", errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().GroupBroadcast(ctx, frontendType, groupName, route, nil).Return(row.returned)

			DefaultApp = app
			require.Equal(t, row.returned, GroupBroadcast(ctx, frontendType, groupName, route, nil))
		})
	}
}

func TestStaticGroupContainsMember(t *testing.T) {
	ctx := context.Background()
	tables := []struct {
		name      string
		groupName string
		uid       string
		contains  bool
		err       error
	}{
		{"Success", "groupName", uuid.New().String(), true, nil},
		{"Success/False", "groupName", uuid.New().String(), false, nil},
		{"Error", "groupName", uuid.New().String(), true, errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().GroupContainsMember(ctx, row.groupName, row.uid).Return(row.contains, row.err)

			DefaultApp = app
			contains, err := GroupContainsMember(ctx, row.groupName, row.uid)
			require.Equal(t, row.err, err)
			require.Equal(t, row.contains, contains)
		})
	}
}

func TestStaticGroupAddMember(t *testing.T) {
	ctx := context.Background()
	groupName := "group"
	uid := uuid.New().String()

	tables := []struct {
		name     string
		returned error
	}{
		{"Success", nil},
		{"Error", errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().GroupAddMember(ctx, groupName, uid).Return(row.returned)

			DefaultApp = app
			require.Equal(t, row.returned, GroupAddMember(ctx, groupName, uid))
		})
	}
}

func TestStaticGroupRemoveMember(t *testing.T) {
	ctx := context.Background()
	groupName := "group"
	uid := uuid.New().String()

	tables := []struct {
		name     string
		returned error
	}{
		{"Success", nil},
		{"Error", errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().GroupRemoveMember(ctx, groupName, uid).Return(row.returned)

			DefaultApp = app
			require.Equal(t, row.returned, GroupRemoveMember(ctx, groupName, uid))
		})
	}
}

func TestStaticGroupRemoveAll(t *testing.T) {
	ctx := context.Background()
	groupName := "group"

	tables := []struct {
		name     string
		returned error
	}{
		{"Success", nil},
		{"Error", errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().GroupRemoveAll(ctx, groupName).Return(row.returned)

			DefaultApp = app
			require.Equal(t, row.returned, GroupRemoveAll(ctx, groupName))
		})
	}
}

func TestStaticGroupCountMembers(t *testing.T) {
	ctx := context.Background()
	tables := []struct {
		name      string
		groupName string
		count     int
		err       error
	}{
		{"Success", "name", 3, nil},
		{"Error", "name", 0, errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().GroupCountMembers(ctx, row.groupName).Return(row.count, row.err)

			DefaultApp = app
			count, err := GroupCountMembers(ctx, row.groupName)
			require.Equal(t, row.err, err)
			require.Equal(t, row.count, count)
		})
	}
}

func TestStaticGroupRenewTTL(t *testing.T) {
	ctx := context.Background()
	groupName := "group"

	tables := []struct {
		name     string
		returned error
	}{
		{"Success", nil},
		{"Error", errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().GroupRenewTTL(ctx, groupName).Return(row.returned)

			DefaultApp = app
			require.Equal(t, row.returned, GroupRenewTTL(ctx, groupName))
		})
	}
}

func TestStaticGroupDelete(t *testing.T) {
	ctx := context.Background()
	groupName := "group"

	tables := []struct {
		name     string
		returned error
	}{
		{"Success", nil},
		{"Error", errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().GroupDelete(ctx, groupName).Return(row.returned)

			DefaultApp = app
			require.Equal(t, row.returned, GroupDelete(ctx, groupName))
		})
	}
}

func TestStaticRegister(t *testing.T) {
	var c component.Component
	options := []component.Option{}
	ctrl := gomock.NewController(t)

	app := mocks.NewMockPitaya(ctrl)
	app.EXPECT().Register(c, options)

	DefaultApp = app
	Register(c, options...)
}

func TestStaticRegisterRemote(t *testing.T) {
	var c component.Component
	options := []component.Option{}
	ctrl := gomock.NewController(t)

	app := mocks.NewMockPitaya(ctrl)
	app.EXPECT().RegisterRemote(c, options)

	DefaultApp = app
	RegisterRemote(c, options...)
}

func TestStaticRegisterModule(t *testing.T) {
	var module interfaces.Module
	name := "name"

	tables := []struct {
		name     string
		returned error
	}{
		{"Success", nil},
		{"Error", errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().RegisterModule(module, name).Return(row.returned)

			DefaultApp = app
			require.Equal(t, row.returned, RegisterModule(module, name))
		})
	}
}

func TestStaticRegisterModuleAfter(t *testing.T) {
	var module interfaces.Module
	name := "name"

	tables := []struct {
		name     string
		returned error
	}{
		{"Success", nil},
		{"Error", errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().RegisterModuleAfter(module, name).Return(row.returned)

			DefaultApp = app
			require.Equal(t, row.returned, RegisterModuleAfter(module, name))
		})
	}
}

func TestStaticRegisterModuleBefore(t *testing.T) {
	var module interfaces.Module
	name := "name"

	tables := []struct {
		name     string
		returned error
	}{
		{"Success", nil},
		{"Error", errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().RegisterModuleBefore(module, name).Return(row.returned)

			DefaultApp = app
			require.Equal(t, row.returned, RegisterModuleBefore(module, name))
		})
	}
}

func TestStaticGetModule(t *testing.T) {
	tables := []struct {
		name       string
		moduleName string
		module     interfaces.Module
		err        error
	}{
		{"Success", "name", nil, nil},
		{"Error", "name", nil, errors.New("error")},
	}

	for _, row := range tables {
		t.Run(row.name, func(t *testing.T) {
			ctrl := gomock.NewController(t)

			app := mocks.NewMockPitaya(ctrl)
			app.EXPECT().GetModule(row.moduleName).Return(row.module, row.err)

			DefaultApp = app
			module, err := GetModule(row.moduleName)
			require.Equal(t, row.err, err)
			require.Equal(t, row.module, module)
		})
	}
}

func TestGetNumberOfConnectedClients(t *testing.T) {
	ctrl := gomock.NewController(t)

	expected := int64(math.MaxInt64)

	app := mocks.NewMockPitaya(ctrl)
	app.EXPECT().GetNumberOfConnectedClients().Return(expected)

	DefaultApp = app
	require.Equal(t, expected, GetNumberOfConnectedClients())
}

```

`pkg/timer.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package pitaya

import (
	"math"
	"time"

	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/timer"
)

// NewTimer returns a new Timer containing a function that will be called
// with a period specified by the duration argument. It adjusts the intervals
// for slow receivers.
// The duration d must be greater than zero; if not, NewTimer will panic.
// Stop the timer to release associated resources.
func NewTimer(interval time.Duration, fn timer.Func) *timer.Timer {
	return NewCountTimer(interval, timer.LoopForever, fn)
}

// NewCountTimer returns a new Timer containing a function that will be called
// with a period specified by the duration argument. After count times, timer
// will be stopped automatically, It adjusts the intervals for slow receivers.
// The duration d must be greater than zero; if not, NewCountTimer will panic.
// Stop the timer to release associated resources.
func NewCountTimer(interval time.Duration, count int, fn timer.Func) *timer.Timer {
	if fn == nil {
		panic("pitaya/timer: nil timer function")
	}
	if interval <= 0 {
		panic("non-positive interval for NewTimer")
	}

	t := timer.NewTimer(fn, interval, count)
	// add to manager
	timer.Manager.ChCreatedTimer <- t
	return t
}

// NewAfterTimer returns a new Timer containing a function that will be called
// after duration that specified by the duration argument.
// The duration d must be greater than zero; if not, NewAfterTimer will panic.
// Stop the timer to release associated resources.
func NewAfterTimer(duration time.Duration, fn timer.Func) *timer.Timer {
	return NewCountTimer(duration, 1, fn)
}

// NewCondTimer returns a new Timer containing a function that will be called
// when condition satisfied that specified by the condition argument.
// The duration d must be greater than zero; if not, NewCondTimer will panic.
// Stop the timer to release associated resources.
func NewCondTimer(condition timer.Condition, fn timer.Func) (*timer.Timer, error) {
	if condition == nil {
		return nil, constants.ErrNilCondition
	}

	t := NewCountTimer(time.Duration(math.MaxInt64), timer.LoopForever, fn)
	t.SetCondition(condition)
	return t, nil
}

// SetTimerPrecision set the ticker precision, and time precision can not less
// than a Millisecond, and can not change after application running. The default
// precision is time.Second
func SetTimerPrecision(precision time.Duration) {
	if precision < time.Millisecond {
		panic("time precision can not less than a Millisecond")
	}
	timer.Precision = precision
}

// SetTimerBacklog set the timer created/closing channel backlog, A small backlog
// may cause the logic to be blocked when call NewTimer/NewCountTimer/timer.Stop
// in main logic gorontine.
func SetTimerBacklog(c int) {
	timer.SetTimerBacklog(c)
}

```

`pkg/timer/timer.go`:

```go
// Copyright (c) nano Author and TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package timer

import (
	"sync"
	"sync/atomic"
	"time"

	"github.com/topfreegames/pitaya/v3/pkg/logger"
)

var timerBacklog int

const (
	// LoopForever is a constant indicating that timer should loop forever
	LoopForever = -1
)

var (
	// Manager manager for all Timers
	Manager = &struct {
		incrementID    int64      // auto increment id
		timers         sync.Map   // all Timers
		ChClosingTimer chan int64 // timer for closing
		ChCreatedTimer chan *Timer
	}{}

	// Precision indicates the precision of timer, default is time.Second
	Precision = time.Second

	// GlobalTicker represents global ticker that all cron job will be executed
	// in globalTicker.
	GlobalTicker *time.Ticker
)

type (
	// Func represents a function which will be called periodically in main
	// logic gorontine.
	Func func()

	// Condition represents a checker that returns true when cron job needs
	// to execute
	Condition interface {
		Check(now time.Time) bool
	}

	// Timer represents a cron job
	Timer struct {
		ID        int64         // timer id
		fn        Func          // function that execute
		createAt  int64         // timer create time
		interval  time.Duration // execution interval
		condition Condition     // condition to cron job execution
		elapse    int64         // total elapse time
		closed    int32         // is timer closed
		counter   int           // counter
	}
)

func init() {
	// since this runs on init it is better to leave the value hardcoded here
	timerBacklog = 1 << 8
	Manager.ChClosingTimer = make(chan int64, timerBacklog)
	Manager.ChCreatedTimer = make(chan *Timer, timerBacklog)
}

// AddTimer adds a timer to the manager
func AddTimer(t *Timer) {
	Manager.timers.Store(t.ID, t)
}

// RemoveTimer removes a timer to the manager
func RemoveTimer(id int64) {
	Manager.timers.Delete(id)
}

// NewTimer creates a cron job
func NewTimer(fn Func, interval time.Duration, counter int) *Timer {
	id := atomic.AddInt64(&Manager.incrementID, 1)
	t := &Timer{
		ID:       id,
		fn:       fn,
		createAt: time.Now().UnixNano(),
		interval: interval,
		elapse:   int64(interval), // first execution will be after interval
		counter:  counter,
	}

	// add to manager
	Manager.ChCreatedTimer <- t
	return t
}

// SetCondition sets the condition used for verifying when the cron job should run
func (t *Timer) SetCondition(condition Condition) {
	t.condition = condition
}

// Stop turns off a timer. After Stop, fn will not be called forever
func (t *Timer) Stop() {
	if atomic.LoadInt32(&t.closed) > 0 {
		return
	}

	// guarantee that logic is not blocked
	if len(Manager.ChClosingTimer) < timerBacklog {
		Manager.ChClosingTimer <- t.ID
		atomic.StoreInt32(&t.closed, 1)
	} else {
		t.counter = 0 // automatically closed in next Cron
	}
}

// execute job function with protection
func pexec(id int64, fn Func) {
	defer func() {
		if err := recover(); err != nil {
			logger.Log.Errorf("Call timer function error, TimerID=%d, Error=%v", id, err)
		}
	}()

	fn()
}

// Cron executes scheduled tasks
// TODO: if closing Timers'count in single cron call more than timerBacklog will case problem.
func Cron() {
	now := time.Now()
	unn := now.UnixNano()
	Manager.timers.Range(func(idInterface, tInterface interface{}) bool {
		t := tInterface.(*Timer)
		id := idInterface.(int64)
		// prevent ChClosingTimer exceed
		if t.counter == 0 {
			if len(Manager.ChClosingTimer) < timerBacklog {
				t.Stop()
			}
			return true
		}

		// condition timer
		if t.condition != nil {
			if t.condition.Check(now) {
				pexec(id, t.fn)
			}
			return true
		}

		// execute job
		if t.createAt+t.elapse <= unn {
			pexec(id, t.fn)
			t.elapse += int64(t.interval)

			// update timer counter
			if t.counter != LoopForever && t.counter > 0 {
				t.counter--
			}
		}
		return true
	})
}

// SetTimerBacklog set the timer created/closing channel backlog, A small backlog
// may cause the logic to be blocked when call NewTimer/NewCountTimer/timer.Stop
// in main logic gorontine.
func SetTimerBacklog(c int) {
	if c < 16 {
		c = 16
	}
	timerBacklog = c
}

```

`pkg/timer/timer_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package timer

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/helpers"
)

type alwaysRunCondition struct{}

func (a *alwaysRunCondition) Check(now time.Time) bool {
	return true
}

type neverRunCondition struct{}

func (a *neverRunCondition) Check(now time.Time) bool {
	return false
}

var tables = []struct {
	name      string
	f         func()
	interval  time.Duration
	counter   int
	condition Condition
}{
	{"1sec1rep", func() {}, 1 * time.Second, 1, &neverRunCondition{}},
	{"10sec10rep", func() {}, 10 * time.Second, 10, &neverRunCondition{}},
	{"50milli1rep", func() {}, 50 * time.Millisecond, 1, &neverRunCondition{}},
	{"50milli2rep", func() {}, 50 * time.Millisecond, 2, &alwaysRunCondition{}},
}

func TestInit(t *testing.T) {
	t.Parallel()
	assert.NotNil(t, Manager.ChClosingTimer)
	assert.NotNil(t, Manager.ChCreatedTimer)
}

func TestNewTimer(t *testing.T) {
	t.Parallel()
	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			tm := NewTimer(table.f, table.interval, table.counter)
			assert.NotNil(t, tm)
			assert.Equal(t, table.counter, tm.counter)
			assert.Equal(t, table.interval, tm.interval)
		})
	}
}

func TestAddTimer(t *testing.T) {
	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			tm := NewTimer(table.f, table.interval, table.counter)
			AddTimer(tm)
			tt, ok := Manager.timers.Load(tm.ID)
			assert.True(t, ok)
			assert.Equal(t, tm, tt)
		})
	}
}

func TestRemoveTimer(t *testing.T) {
	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			tm := NewTimer(table.f, table.interval, table.counter)
			AddTimer(tm)
			tt, ok := Manager.timers.Load(tm.ID)
			assert.True(t, ok)
			assert.Equal(t, tm, tt)
			RemoveTimer(tm.ID)
			_, ok = Manager.timers.Load(tm.ID)
			assert.False(t, ok)
		})
	}
}

func TestSetCondition(t *testing.T) {
	t.Parallel()
	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			tm := NewTimer(table.f, table.interval, table.counter)
			tm.SetCondition(table.condition)
			assert.Equal(t, table.condition, tm.condition)
		})
	}
}

func TestStop(t *testing.T) {
	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			tm := NewTimer(table.f, table.interval, table.counter)
			tm.Stop()
			closedID := helpers.ShouldEventuallyReceive(t, Manager.ChClosingTimer).(int64)
			assert.Equal(t, tm.ID, closedID)
			assert.Equal(t, int32(1), tm.closed)
		})
	}
}

func TestSetTimerBacklog(t *testing.T) {
	t.Parallel()
	assert.Equal(t, 1<<8, timerBacklog)
	SetTimerBacklog(10)
	// if c is < 16, we force 16
	assert.Equal(t, 1<<4, timerBacklog)
	SetTimerBacklog(32)
	assert.Equal(t, 1<<5, timerBacklog)
}

func TestPexec(t *testing.T) {
	t.Parallel()
	i := 0
	dFunc := func() {
		i++
	}
	pexec(10, dFunc)
	assert.Equal(t, 1, i)

	panicFunc := func() {
		panic("bla")
	}

	// should not panic because the execution is protected
	assert.NotPanics(t, func() {
		pexec(20, panicFunc)
	})
}

func TestCron(t *testing.T) {
	i := 0
	j := 0
	k := 0

	fi := func() {
		i++
	}

	fj := func() {
		j++
	}

	fk := func() {
		k++
	}

	tmi := NewTimer(fi, 20*time.Millisecond, 1)
	tmi.SetCondition(&alwaysRunCondition{})

	tmj := NewTimer(fj, 20*time.Millisecond, 2)

	tmk := NewTimer(fk, 20*time.Millisecond, 2)
	tmk.SetCondition(&neverRunCondition{})

	AddTimer(tmi)
	AddTimer(tmj)
	AddTimer(tmk)

	time.Sleep(10 * time.Millisecond)
	Cron()
	// after 10ms only tmi should run because it has always run condition
	assert.Equal(t, i, i)
	assert.Equal(t, 0, j)
	assert.Equal(t, 0, k)

	time.Sleep(15 * time.Millisecond)
	Cron()
	// after 25ms cron run, i should be 2, j should be 1, and k should be 0 because it has neverRunCondition
	assert.Equal(t, 2, i)
	assert.Equal(t, 1, j)
	assert.Equal(t, 0, k)

	time.Sleep(25 * time.Millisecond)
	Cron()

	// after more 25ms j should be 2
	assert.Equal(t, 2, j)

	time.Sleep(25 * time.Millisecond)
	Cron()
	// after more 25ms j should be still 2 because of the counter
	assert.Equal(t, 2, j)
}

```

`pkg/timer_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package pitaya

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/timer"
)

type MyCond struct{}

func (m *MyCond) Check(now time.Time) bool {
	return false
}

func TestNewTimer(t *testing.T) {
	t.Parallel()
	tt := NewTimer(100*time.Millisecond, func() {})
	assert.NotNil(t, tt)
}

func TestNewCountTimer(t *testing.T) {
	t.Parallel()
	tt := NewCountTimer(100*time.Millisecond, 10, func() {})
	assert.NotNil(t, tt)
}

func TestNewAfterTimer(t *testing.T) {
	t.Parallel()
	tt := NewAfterTimer(100*time.Millisecond, func() {})
	assert.NotNil(t, tt)
}

func TestNewCondTimer(t *testing.T) {
	t.Parallel()
	_, err := NewCondTimer(nil, func() {})
	assert.EqualError(t, constants.ErrNilCondition, err.Error())

	tt, err := NewCondTimer(&MyCond{}, func() {})
	assert.NoError(t, err)
	assert.NotNil(t, tt)
}

func TestSetTimerPrecision(t *testing.T) {
	t.Parallel()
	dur := 33 * time.Millisecond
	SetTimerPrecision(dur)
	assert.Equal(t, dur, timer.Precision)
}

func TestSetTimerBacklog(t *testing.T) {
	backlog := 1 << 4
	SetTimerBacklog(backlog)
}

```

`pkg/tracing/otel.go`:

```go
package tracing

import (
	"context"
	"fmt"
	"os"
	"strings"

	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/sdk/resource"
	sdktrace "go.opentelemetry.io/otel/sdk/trace"
)

func InitializeOtel() error {
	// Print OpenTelemetry configuration
	printOtelConfig()

	ctx := context.Background()

	res, err := resource.New(ctx,
		resource.WithFromEnv(),
		resource.WithOS(),
		resource.WithHost(),
	)
	if err != nil {
		return err
	}

	client := otlptracegrpc.NewClient()

	exporter, err := otlptrace.New(ctx, client)
	if err != nil {
		return err
	}

	tp := sdktrace.NewTracerProvider(
		sdktrace.WithBatcher(exporter),
		sdktrace.WithResource(res),
	)

	otel.SetTracerProvider(tp)
	otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(propagation.TraceContext{}, propagation.Baggage{}))

	logger.Log.Info("OpenTelemetry initialized using environment variables")
	return nil
}

func printOtelConfig() {
	vars := []string{
		"OTEL_SERVICE_NAME",
		"OTEL_EXPORTER_OTLP_ENDPOINT",
		"OTEL_EXPORTER_OTLP_PROTOCOL",
		"OTEL_TRACES_SAMPLER",
		"OTEL_TRACES_SAMPLER_ARG",
		"OTEL_RESOURCE_ATTRIBUTES",
		"OTEL_SDK_DISABLED",
	}

	config := make([]string, 0, len(vars))
	for _, v := range vars {
		value := os.Getenv(v)
		if value == "" {
			value = "<not set>"
		}
		config = append(config, fmt.Sprintf("%s=%s", v, value))
	}

	logger.Log.Info(fmt.Sprintf("OpenTelemetry Configuration: %s", strings.Join(config, ", ")))
}

```

`pkg/tracing/span.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package tracing

import (
	"context"

	"github.com/topfreegames/pitaya/v3/pkg/constants"
	pcontext "github.com/topfreegames/pitaya/v3/pkg/context"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/trace"
	otelTrace "go.opentelemetry.io/otel/trace"
)

func castValueToCarrier(val interface{}) (propagation.MapCarrier, error) {
	if v, ok := val.(propagation.MapCarrier); ok {
		return v, nil
	}
	if m, ok := val.(map[string]interface{}); ok {
		carrier := make(propagation.MapCarrier)
		for k, v := range m {
			if s, ok := v.(string); ok {
				carrier[k] = s
			} else {
				logger.Log.Warnf("value from span carrier cannot be cast to string: %+v", v)
			}
		}
		return carrier, nil
	}
	return nil, constants.ErrInvalidSpanCarrier
}

// ExtractSpan retrieves an OpenTelemetry span context from the given context.Context
// The span context can be received directly (inside the context) or via an RPC call
// (encoded in a carrier)
func ExtractSpan(ctx context.Context) (otelTrace.SpanContext, error) {
	span := otelTrace.SpanFromContext(ctx)
	if span.SpanContext().IsValid() {
		return span.SpanContext(), nil
	}

	if s := pcontext.GetFromPropagateCtx(ctx, constants.SpanPropagateCtxKey); s != nil {
		carrier, err := castValueToCarrier(s)
		if err != nil {
			return otelTrace.SpanContext{}, err
		}

		propagator := otel.GetTextMapPropagator()
		extractedCtx := propagator.Extract(ctx, propagation.MapCarrier(carrier))
		extractedSpan := otelTrace.SpanFromContext(extractedCtx)
		return extractedSpan.SpanContext(), nil
	}

	return otelTrace.SpanContext{}, nil
}

// InjectSpan retrieves an OpenTelemetry span from the current context and creates a new context
// with it encoded in text map format inside the propagatable context content
func InjectSpan(ctx context.Context) (context.Context, error) {
	span := otelTrace.SpanFromContext(ctx)
	if !span.SpanContext().IsValid() {
		return ctx, nil
	}

	carrier := make(map[string]string)
	otel.GetTextMapPropagator().Inject(ctx, propagation.MapCarrier(carrier))

	return pcontext.AddToPropagateCtx(ctx, constants.SpanPropagateCtxKey, carrier), nil
}

// StartSpan starts a new span with a given parent context, operation name, and attributes.
// It returns a context with the created span.
func StartSpan(
	parentCtx context.Context,
	opName string,
	attributes ...attribute.KeyValue,
) (context.Context, trace.Span) {
	tracer := otel.Tracer("pitaya")
	ctx, span := tracer.Start(parentCtx, opName,
		trace.WithAttributes(attributes...),
	)

	return ctx, span
}

// FinishSpan finishes a span retrieved from the given context and logs the error if it exists
func FinishSpan(ctx context.Context, err error) {
	if ctx == nil {
		return
	}
	span := otelTrace.SpanFromContext(ctx)
	if span == nil {
		return
	}
	defer span.End()
	if err != nil {
		span.RecordError(err)
		span.SetStatus(codes.Error, err.Error())
	}
}

```

`pkg/tracing/span_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package tracing

import (
	"context"
	"errors"
	"os"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	pcontext "github.com/topfreegames/pitaya/v3/pkg/context"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/propagation"
	sdktrace "go.opentelemetry.io/otel/sdk/trace"
	"go.opentelemetry.io/otel/trace"
)

var tracerProvider *sdktrace.TracerProvider

func TestMain(m *testing.M) {
	setup()
	code := m.Run()
	shutdown()
	os.Exit(code)
}

func setup() {
	tracerProvider = sdktrace.NewTracerProvider()
	otel.SetTracerProvider(tracerProvider)
	otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(propagation.TraceContext{}, propagation.Baggage{}))
}

func shutdown() {
	_ = tracerProvider.Shutdown(context.Background())
}

func TestExtractSpan(t *testing.T) {
	ctx, span := otel.Tracer("test").Start(context.Background(), "op")
	defer span.End()

	spanCtx, err := ExtractSpan(ctx)
	assert.NoError(t, err)
	assert.Equal(t, span.SpanContext(), spanCtx)
	assert.True(t, spanCtx.IsValid())
}

func TestExtractSpanInjectedSpan(t *testing.T) {
	ctx, span := otel.Tracer("test").Start(context.Background(), "someOp")
	defer span.End()

	carrier := propagation.MapCarrier{}
	otel.GetTextMapPropagator().Inject(ctx, carrier)
	ctx = pcontext.AddToPropagateCtx(context.Background(), constants.SpanPropagateCtxKey, carrier)

	spanCtx, err := ExtractSpan(ctx)
	assert.NoError(t, err)
	assert.Equal(t, span.SpanContext().TraceID(), spanCtx.TraceID())
	assert.Equal(t, span.SpanContext().SpanID(), spanCtx.SpanID())
	assert.True(t, spanCtx.IsValid())
}

func TestExtractSpanNoSpan(t *testing.T) {
	spanCtx, err := ExtractSpan(context.Background())
	assert.NoError(t, err)
	assert.Equal(t, trace.SpanContext{}, spanCtx)
}

func TestExtractSpanBadInjected(t *testing.T) {
	ctx := pcontext.AddToPropagateCtx(context.Background(), constants.SpanPropagateCtxKey, []byte("nope"))
	spanCtx, err := ExtractSpan(ctx)
	assert.Equal(t, constants.ErrInvalidSpanCarrier, err)
	assert.Equal(t, trace.SpanContext{}, spanCtx)
}

func TestInjectSpanContextWithoutSpan(t *testing.T) {
	origCtx := context.Background()
	ctx, err := InjectSpan(origCtx)
	assert.NoError(t, err)
	assert.Equal(t, origCtx, ctx)
}

func TestInjectSpan(t *testing.T) {
	ctx, span := otel.Tracer("test").Start(context.Background(), "op")
	defer span.End()

	injectedCtx, err := InjectSpan(ctx)
	assert.NoError(t, err)
	assert.NotEqual(t, ctx, injectedCtx)
	encodedCtx := pcontext.GetFromPropagateCtx(injectedCtx, constants.SpanPropagateCtxKey)
	assert.NotNil(t, encodedCtx)
}

func TestStartSpan(t *testing.T) {
	parentCtx := context.Background()
	opName := "test-operation"
	attributes := []attribute.KeyValue{
		attribute.String("key1", "value1"),
		attribute.Int("key2", 42),
	}

	ctx, span := StartSpan(parentCtx, opName, attributes...)
	defer span.End()

	assert.NotNil(t, span)
	assert.NotEqual(t, parentCtx, ctx)

	spanCtx := span.SpanContext()
	assert.True(t, spanCtx.IsValid())
	assert.NotEmpty(t, spanCtx.TraceID())
	assert.NotEmpty(t, spanCtx.SpanID())

	// Check if attributes are set
	spanAttrs := span.(interface{ Attributes() []attribute.KeyValue }).Attributes()
	assert.Len(t, spanAttrs, len(attributes))
	for i, attr := range attributes {
		assert.Equal(t, attr, spanAttrs[i])
	}
}

func TestFinishSpan(t *testing.T) {
	t.Run("with error", func(t *testing.T) {
		ctx, span := StartSpan(context.Background(), "test-operation")
		testErr := errors.New("test error")

		FinishSpan(ctx, testErr)

		spanStatus := span.(sdktrace.ReadOnlySpan).Status().Code
		assert.Equal(t, codes.Error, spanStatus)

		spanEvents := span.(interface{ Events() []sdktrace.Event }).Events()
		assert.Len(t, spanEvents, 1)
		assert.Equal(t, "exception", spanEvents[0].Name)
		spanError := span.(sdktrace.ReadOnlySpan).Status().Description
		assert.Equal(t, testErr.Error(), spanError)
	})

	t.Run("without error", func(t *testing.T) {
		ctx, span := StartSpan(context.Background(), "test-operation")

		FinishSpan(ctx, nil)

		spanStatus := span.(sdktrace.ReadOnlySpan).Status().Code
		assert.Equal(t, codes.Unset, spanStatus)

		spanEvents := span.(interface{ Events() []sdktrace.Event }).Events()
		assert.Len(t, spanEvents, 0)
	})

	t.Run("nil context", func(t *testing.T) {
		assert.NotPanics(t, func() {
			FinishSpan(nil, nil)
		})
	})
}
func TestFinishSpanNilCtx(t *testing.T) {
	assert.NotPanics(t, func() { FinishSpan(nil, nil) })
}

func TestFinishSpanCtxWithoutSpan(t *testing.T) {
	assert.NotPanics(t, func() { FinishSpan(context.Background(), nil) })
}

func TestFinishSpanWithErr(t *testing.T) {
	ctx, span := StartSpan(context.Background(), "my-op", attribute.String("hi", "hello"))
	assert.NotPanics(t, func() { FinishSpan(ctx, errors.New("hello")) })

	spanStatus := span.(sdktrace.ReadOnlySpan).Status().Code
	assert.Equal(t, codes.Error, spanStatus)

	spanEvents := span.(interface{ Events() []sdktrace.Event }).Events()
	assert.Len(t, spanEvents, 1)
	assert.Equal(t, "exception", spanEvents[0].Name)
	spanError := span.(sdktrace.ReadOnlySpan).Status().Description
	assert.Equal(t, "hello", spanError)
}

func TestFinishSpanWithoutErr(t *testing.T) {
	ctx, span := StartSpan(context.Background(), "my-op", attribute.String("hi", "hello"))
	assert.NotPanics(t, func() { FinishSpan(ctx, nil) })

	spanStatus := span.(sdktrace.ReadOnlySpan).Status().Code
	assert.Equal(t, codes.Unset, spanStatus)

	spanEvents := span.(interface{ Events() []sdktrace.Event }).Events()
	assert.Len(t, spanEvents, 0)
}

```

`pkg/util/compression/compression.go`:

```go
package compression

import (
	"bytes"
	"compress/zlib"
	"io"
)

func DeflateData(data []byte) ([]byte, error) {
	var bb bytes.Buffer
	z := zlib.NewWriter(&bb)
	_, err := z.Write(data)
	if err != nil {
		return nil, err
	}
	z.Close()
	return bb.Bytes(), nil
}

func InflateData(data []byte) ([]byte, error) {
	zr, err := zlib.NewReader(bytes.NewBuffer(data))
	if err != nil {
		return nil, err
	}
	defer zr.Close()

	return io.ReadAll(zr)
}

func IsCompressed(data []byte) bool {
	return len(data) > 2 &&
	(
		// zlib
		(data[0] == 0x78 &&
		(data[1] == 0x9C ||
		data[1] == 0x01 ||
		data[1] == 0xDA ||
		data[1] == 0x5E)) ||
		// gzip
		(data[0] == 0x1F && data[1] == 0x8B))
}

```

`pkg/util/compression/compression_test.go`:

```go
package compression

import (
	"flag"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/topfreegames/pitaya/v3/pkg/helpers"
)

var update = flag.Bool("update", false, "update .golden files")

var ins = []struct {
	name string
	data string
}{
	{"compression_deflate_test_1", "test"},
	{"compression_deflate_test_2", "{a:1,b:2}"},
	{"compression_deflate_test_3", "Neque porro quisquam est qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit"},
}

func TestCompressionDeflate(t *testing.T) {
	for _, in := range ins {
		t.Run(in.name, func(t *testing.T) {
			b, err := DeflateData([]byte(in.data))
			require.NoError(t, err)
			gp := filepath.Join("fixtures", in.name+".golden")
			if *update {
				t.Log("updating golden file")
				helpers.WriteFile(t, gp, b)
			}
			expected := helpers.ReadFile(t, gp)

			assert.Equal(t, expected, b)
		})
	}
}

func TestCompressionInflate(t *testing.T) {
	for _, in := range ins {
		t.Run(in.name, func(t *testing.T) {
			inputFile := filepath.Join("fixtures", in.name+".golden")
			input := helpers.ReadFile(t, inputFile)

			result, err := InflateData(input)
			require.NoError(t, err)

			assert.Equal(t, string(result), in.data)
		})
	}
}

func TestCompressionInflateIncorrectData(t *testing.T) {
	t.Run("compression_deflate_incorrect_data", func(t *testing.T) {
		input := "arbitrary data"

		result, err := InflateData([]byte(input))
		require.Error(t, err)
		assert.Nil(t, result)
	})
}

```

`pkg/util/util.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package util

import (
	"context"
	"errors"
	"fmt"
	"os"
	"reflect"
	"runtime/debug"
	"strconv"

	"github.com/nats-io/nuid"

	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	pcontext "github.com/topfreegames/pitaya/v3/pkg/context"
	e "github.com/topfreegames/pitaya/v3/pkg/errors"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/logger/interfaces"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/serialize"
	"github.com/topfreegames/pitaya/v3/pkg/tracing"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/trace"
)

func getLoggerFromArgs(args []reflect.Value) interfaces.Logger {
	for _, a := range args {
		if !a.IsValid() {
			continue
		}
		if ctx, ok := a.Interface().(context.Context); ok {
			logVal := ctx.Value(constants.LoggerCtxKey)
			if logVal != nil {
				log := logVal.(interfaces.Logger)
				return log
			}
		}
	}
	return logger.Log
}

// Pcall calls a method that returns an interface and an error and recovers in case of panic
func Pcall(method reflect.Method, args []reflect.Value) (rets interface{}, err error) {
	defer func() {
		if rec := recover(); rec != nil {
			// Try to use logger from context here to help trace error cause
			stackTrace := debug.Stack()
			stackTraceAsRawStringLiteral := strconv.Quote(string(stackTrace))
			log := getLoggerFromArgs(args)
			log.Errorf("panic - pitaya/dispatch: methodName=%s panicData=%v stackTrace=%s", method.Name, rec, stackTraceAsRawStringLiteral)

			if s, ok := rec.(string); ok {
				err = errors.New(s)
			} else {
				err = fmt.Errorf("rpc call internal error - %s: %v", method.Name, rec)
			}
		}
	}()

	r := method.Func.Call(args)
	// r can have 0 length in case of notify handlers
	// otherwise it will have 2 outputs: an interface and an error
	if len(r) == 2 {
		if v := r[1].Interface(); v != nil {
			err = v.(error)
		} else if !r[0].IsNil() {
			rets = r[0].Interface()
		} else {
			err = constants.ErrReplyShouldBeNotNull
		}
	}
	return
}

// SliceContainsString returns true if a slice contains the string
func SliceContainsString(slice []string, str string) bool {
	for _, value := range slice {
		if value == str {
			return true
		}
	}
	return false
}

// SerializeOrRaw serializes the interface if its not an array of bytes already
func SerializeOrRaw(serializer serialize.Serializer, v interface{}) ([]byte, error) {
	if data, ok := v.([]byte); ok {
		return data, nil
	}
	data, err := serializer.Marshal(v)
	if err != nil {
		return nil, err
	}
	return data, nil
}

// FileExists tells if a file exists
func FileExists(filename string) bool {
	_, err := os.Stat(filename)
	return err == nil || os.IsExist(err)
}

// GetErrorFromPayload gets the error from payload
func GetErrorFromPayload(serializer serialize.Serializer, payload []byte) error {
	pErr := &protos.Error{Code: e.ErrUnknownCode}
	_ = serializer.Unmarshal(payload, pErr)
	return &e.Error{Code: pErr.Code, Message: pErr.Msg, Metadata: pErr.Metadata}
}

// GetErrorPayload creates and serializes an error payload
func GetErrorPayload(serializer serialize.Serializer, err error) ([]byte, error) {
	code := e.ErrUnknownCode
	msg := err.Error()
	metadata := map[string]string{}
	if val, ok := err.(*e.Error); ok {
		code = val.Code
		metadata = val.Metadata
	}
	errPayload := &protos.Error{
		Code: code,
		Msg:  msg,
	}
	if len(metadata) > 0 {
		errPayload.Metadata = metadata
	}
	return SerializeOrRaw(serializer, errPayload)
}

// ConvertProtoToMessageType converts a protos.MsgType to a message.Type
func ConvertProtoToMessageType(protoMsgType protos.MsgType) message.Type {
	var msgType message.Type
	switch protoMsgType {
	case protos.MsgType_MsgRequest:
		msgType = message.Request
	case protos.MsgType_MsgNotify:
		msgType = message.Notify
	}
	return msgType
}

// CtxWithDefaultLogger inserts a default logger on ctx to be used on handlers and remotes.
// If using logrus, userId, route and requestId will be added as fields.
// Otherwise the pitaya logger will be used as it is.
func CtxWithDefaultLogger(ctx context.Context, route, userID string) context.Context {
	requestID := pcontext.GetFromPropagateCtx(ctx, constants.RequestIDKey)
	if rID, ok := requestID.(string); ok {
		if rID == "" {
			requestID = nuid.New().Next()
		}
	} else {
		requestID = nuid.New().Next()
	}
	defaultLogger := logger.Log.WithFields(
		map[string]interface{}{
			"route":     route,
			"requestId": requestID,
			"userId":    userID,
		},
	)

	return context.WithValue(ctx, constants.LoggerCtxKey, defaultLogger)
}

// StartSpanFromRequest starts a tracing span from the request
func StartSpanFromRequest(
	ctx context.Context,
	serverID, route string,
) context.Context {
	if ctx == nil {
		return nil
	}

	parent, err := tracing.ExtractSpan(ctx)
	if err != nil {
		return nil
	}

	ctx = trace.ContextWithRemoteSpanContext(ctx, parent)

	// Create a new context and span
	attributes := []attribute.KeyValue{
		attribute.String("local.id", serverID),
		attribute.String("span.kind", "server"),
	}
	peerId, ok := pcontext.GetFromPropagateCtx(ctx, constants.PeerIDKey).(string)
	if ok {
		attributes = append(attributes, attribute.String("peer.id", peerId))
	}
	peerService, ok := pcontext.GetFromPropagateCtx(ctx, constants.PeerServiceKey).(string)
	if ok {
		attributes = append(attributes, attribute.String("peer.service", peerService))
	}
	requestId, ok := pcontext.GetFromPropagateCtx(ctx, constants.RequestIDKey).(string)
	if ok {
		attributes = append(attributes, attribute.String("request.id", requestId))
	}

	ctx, _ = tracing.StartSpan(ctx, route, attributes...)

	return ctx
}

// GetContextFromRequest gets the context from a request
func GetContextFromRequest(req *protos.Request, serverID string) (context.Context, error) {
	ctx, err := pcontext.Decode(req.GetMetadata())
	if err != nil {
		return nil, err
	}
	if ctx == nil {
		return nil, constants.ErrNoContextFound
	}

	requestID := pcontext.GetFromPropagateCtx(ctx, constants.RequestIDKey)
	if rID, ok := requestID.(string); !ok || (ok && rID == "") {
		requestID = nuid.New().Next()
		ctx = pcontext.AddToPropagateCtx(ctx, constants.RequestIDKey, requestID)
	}

	route := req.GetMsg().GetRoute()
	ctx = pcontext.AddToPropagateCtx(ctx, constants.RouteKey, route)
	ctx = CtxWithDefaultLogger(ctx, route, "")
	return ctx, nil
}

```

`pkg/util/util_test.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package util

import (
	"context"
	"errors"
	"flag"
	"fmt"
	"path/filepath"
	"reflect"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/assert"
	"github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	pcontext "github.com/topfreegames/pitaya/v3/pkg/context"
	"github.com/topfreegames/pitaya/v3/pkg/protos"
	"github.com/topfreegames/pitaya/v3/pkg/serialize/mocks"
	"github.com/topfreegames/pitaya/v3/pkg/tracing"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/sdk/trace"
	"go.opentelemetry.io/otel/sdk/trace/tracetest"
)

var update = flag.Bool("update", false, "update .golden files")

type someStruct struct {
	A int
	B string
}

func (s *someStruct) TestFunc(arg1 int, arg2 string) (*someStruct, error) {
	return &someStruct{
		A: arg1,
		B: arg2,
	}, nil
}

func (s *someStruct) TestFuncErr(arg string) (*someStruct, error) {
	return nil, errors.New(arg)
}

func (s *someStruct) TestFuncThrow() (*someStruct, error) {
	panic("ohnoes")
}

func (s *someStruct) TestFuncNil(arg string) (*someStruct, error) {
	return nil, nil
}

func TestPcall(t *testing.T) {
	t.Parallel()
	s := &someStruct{}
	tables := []struct {
		name       string
		obj        interface{}
		methodName string
		args       []reflect.Value
		out        interface{}
		err        error
	}{
		{"test_pcall_1", s, "TestFunc", []reflect.Value{reflect.ValueOf(s), reflect.ValueOf(10), reflect.ValueOf("bla")}, &someStruct{A: 10, B: "bla"}, nil},
		{"test_pcall_2", s, "TestFunc", []reflect.Value{reflect.ValueOf(s), reflect.ValueOf(20), reflect.ValueOf("ble")}, &someStruct{A: 20, B: "ble"}, nil},
		{"test_pcall_3", s, "TestFunc", []reflect.Value{reflect.ValueOf(s), reflect.ValueOf(11), reflect.ValueOf("blb")}, &someStruct{A: 11, B: "blb"}, nil},
		{"test_pcall_4", s, "TestFuncErr", []reflect.Value{reflect.ValueOf(s), reflect.ValueOf("blberror")}, nil, errors.New("blberror")},
		{"test_pcall_5", s, "TestFuncThrow", []reflect.Value{reflect.ValueOf(s)}, nil, errors.New("ohnoes")},
		{"test_pcall_6", s, "TestFuncNil", []reflect.Value{reflect.ValueOf(s), reflect.ValueOf("kkk")}, nil, constants.ErrReplyShouldBeNotNull},
	}

	for _, table := range tables {
		t.Run(table.name, func(t *testing.T) {
			m, ok := reflect.TypeOf(table.obj).MethodByName(table.methodName)
			assert.True(t, ok)
			r, err := Pcall(m, table.args)
			if table.methodName == "TestFunc" || table.methodName == "TestFunc2RetNoErr" {
				assert.NoError(t, err)
			} else {
				assert.Equal(t, table.err, err)
			}
			assert.IsType(t, table.out, r)
			assert.Equal(t, table.out, r)
		})
	}
}

func TestSliceContainsString(t *testing.T) {
	t.Parallel()
	tables := []struct {
		slice []string
		str   string
		ret   bool
	}{
		{[]string{"bla", "ble", "bli"}, "bla", true},
		{[]string{"bl", "ble", "bli"}, "bla", false},
		{[]string{"b", "a", "c"}, "c", true},
		{[]string{"c"}, "c", true},
		{[]string{"c"}, "d", false},
		{[]string{}, "d", false},
		{nil, "d", false},
	}

	for _, table := range tables {
		t.Run(fmt.Sprintf("slice:%s str:%s", table.slice, table.str), func(t *testing.T) {
			res := SliceContainsString(table.slice, table.str)
			assert.Equal(t, table.ret, res)
		})
	}
}

func TestSerializeOrRaw(t *testing.T) {
	t.Parallel()
	tables := []struct {
		in  interface{}
		out interface{}
	}{
		{[]byte{1, 2, 3}, []byte{1, 2, 3}},
		{[]byte{3, 2, 3}, []byte{3, 2, 3}},
		{"bla", []byte{1}},
		{"ble", []byte{1}},
	}

	for i, table := range tables {
		t.Run(fmt.Sprintf("%d", i), func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			mockSerializer := mocks.NewMockSerializer(ctrl)

			if reflect.TypeOf(table.in) != reflect.TypeOf(([]byte)(nil)) {
				mockSerializer.EXPECT().Marshal(table.in).Return(table.out, nil)
			}
			res, err := SerializeOrRaw(mockSerializer, table.in)
			assert.NoError(t, err)
			assert.Equal(t, table.out, res)
		})
	}
}

func TestFileExists(t *testing.T) {
	t.Parallel()
	ins := []struct {
		name string
		out  bool
	}{
		{"gob_encode_test_1", true},
		{"gob_encode_test_2", true},
		{"gob_encode_test_3", true},
		{"gob_encode_test_4", false},
	}

	for _, in := range ins {
		t.Run(in.name, func(t *testing.T) {
			gp := filepath.Join("fixtures", in.name+".golden")
			out := FileExists(gp)
			assert.Equal(t, in.out, out)
		})
	}

}

func TestGetErrorPayload(t *testing.T) {
	t.Parallel()
	tables := []struct {
		in  error
		out []byte
	}{
		{errors.New("some custom error1"), []byte{0x01}},
		{errors.New("error3"), []byte{0x02}},
		{errors.New("bla"), []byte{0x03}},
		{errors.New(""), []byte{0x04}},
	}
	for i, table := range tables {
		t.Run(fmt.Sprintf("%d", i), func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()
			mockSerializer := mocks.NewMockSerializer(ctrl)
			mockSerializer.EXPECT().Marshal(gomock.Any()).Return(table.out, nil)

			b, err := GetErrorPayload(mockSerializer, table.in)
			assert.NoError(t, err)
			assert.Equal(t, table.out, b)
		})
	}
}

func TestConvertProtoToMessageType(t *testing.T) {
	t.Parallel()
	tables := []struct {
		in  protos.MsgType
		out message.Type
	}{
		{protos.MsgType_MsgRequest, message.Request},
		{protos.MsgType_MsgNotify, message.Notify},
	}

	for i, table := range tables {
		t.Run(fmt.Sprintf("%d", i), func(t *testing.T) {
			out := ConvertProtoToMessageType(table.in)
			assert.Equal(t, table.out, out)
		})
	}
}

func TestStartSpanFromRequest(t *testing.T) {
	t.Run("nil context", func(t *testing.T) {
		ctx := StartSpanFromRequest(nil, "server1", "route1")
		assert.Nil(t, ctx)
	})

	t.Run("valid context", func(t *testing.T) {
		// Setup
		exporter := tracetest.NewInMemoryExporter()
		tp := trace.NewTracerProvider(trace.WithSyncer(exporter))
		otel.SetTracerProvider(tp)

		serverID := "server1"
		route := "route1"
		peerID := "peer1"
		peerService := "peerService1"
		requestID := "request1"

		ctx := context.Background()
		ctx = pcontext.AddToPropagateCtx(ctx, constants.PeerIDKey, peerID)
		ctx = pcontext.AddToPropagateCtx(ctx, constants.PeerServiceKey, peerService)
		ctx = pcontext.AddToPropagateCtx(ctx, constants.RequestIDKey, requestID)

		// Execute
		newCtx := StartSpanFromRequest(ctx, serverID, route)

		// Assert
		assert.NotNil(t, newCtx)

		tracing.FinishSpan(newCtx, nil)

		spans := exporter.GetSpans()
		assert.Len(t, spans, 1)

		span := spans[0]
		assert.Equal(t, route, span.Name)

		expectedAttrs := []attribute.KeyValue{
			attribute.String("local.id", serverID),
			attribute.String("span.kind", "server"),
			attribute.String("peer.id", peerID),
			attribute.String("peer.service", peerService),
			attribute.String("request.id", requestID),
		}

		for _, attr := range expectedAttrs {
			assert.Contains(t, span.Attributes, attr)
		}
	})

	t.Run("context without propagated values", func(t *testing.T) {
		// Setup
		exporter := tracetest.NewInMemoryExporter()
		tp := trace.NewTracerProvider(trace.WithSyncer(exporter))
		otel.SetTracerProvider(tp)

		serverID := "server1"
		route := "route1"

		ctx := context.Background()

		// Execute
		newCtx := StartSpanFromRequest(ctx, serverID, route)

		// Assert
		assert.NotNil(t, newCtx)

		tracing.FinishSpan(newCtx, nil)

		spans := exporter.GetSpans()
		assert.Len(t, spans, 1)

		span := spans[0]
		assert.Equal(t, route, span.Name)

		expectedAttrs := []attribute.KeyValue{
			attribute.String("local.id", serverID),
			attribute.String("span.kind", "server"),
		}

		for _, attr := range expectedAttrs {
			assert.Contains(t, span.Attributes, attr)
		}
	})
}

```

`pkg/worker/constants.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package worker

const (
	rpcQueue = "rpc"
	class    = ""
)

```

`pkg/worker/mocks/rpc_job.go`:

```go
// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/topfreegames/pitaya/v3/pkg/worker (interfaces: RPCJob)

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
)

// MockRPCJob is a mock of RPCJob interface.
type MockRPCJob struct {
	ctrl     *gomock.Controller
	recorder *MockRPCJobMockRecorder
}

// MockRPCJobMockRecorder is the mock recorder for MockRPCJob.
type MockRPCJobMockRecorder struct {
	mock *MockRPCJob
}

// NewMockRPCJob creates a new mock instance.
func NewMockRPCJob(ctrl *gomock.Controller) *MockRPCJob {
	mock := &MockRPCJob{ctrl: ctrl}
	mock.recorder = &MockRPCJobMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRPCJob) EXPECT() *MockRPCJobMockRecorder {
	return m.recorder
}

// GetArgReply mocks base method.
func (m *MockRPCJob) GetArgReply(arg0 string) (protoiface.MessageV1, protoiface.MessageV1, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetArgReply", arg0)
	ret0, _ := ret[0].(protoiface.MessageV1)
	ret1, _ := ret[1].(protoiface.MessageV1)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetArgReply indicates an expected call of GetArgReply.
func (mr *MockRPCJobMockRecorder) GetArgReply(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetArgReply", reflect.TypeOf((*MockRPCJob)(nil).GetArgReply), arg0)
}

// RPC mocks base method.
func (m *MockRPCJob) RPC(arg0 context.Context, arg1, arg2 string, arg3, arg4 protoiface.MessageV1) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RPC", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].(error)
	return ret0
}

// RPC indicates an expected call of RPC.
func (mr *MockRPCJobMockRecorder) RPC(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RPC", reflect.TypeOf((*MockRPCJob)(nil).RPC), arg0, arg1, arg2, arg3, arg4)
}

// ServerDiscovery mocks base method.
func (m *MockRPCJob) ServerDiscovery(arg0 string, arg1 map[string]interface{}) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ServerDiscovery", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ServerDiscovery indicates an expected call of ServerDiscovery.
func (mr *MockRPCJobMockRecorder) ServerDiscovery(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ServerDiscovery", reflect.TypeOf((*MockRPCJob)(nil).ServerDiscovery), arg0, arg1)
}

```

`pkg/worker/models.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package worker

import "github.com/golang/protobuf/proto"

type rpcInfo struct {
	Route    string
	Metadata map[string]interface{}
	Arg      proto.Message
	Reply    proto.Message
}

type rpcRoute struct {
	Route string
}

```

`pkg/worker/report.go`:

```go
package worker

import (
	"strconv"
	"time"

	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"

	workers "github.com/topfreegames/go-workers"
)

// Report sends periodic of worker reports
func Report(reporters []metrics.Reporter, period time.Duration) {
	for {
		time.Sleep(period)

		workerStats := workers.GetStats()
		for _, r := range reporters {
			reportJobsRetry(r, workerStats.Retries)
			reportQueueSizes(r, workerStats.Enqueued)
			reportJobsTotal(r, workerStats.Failed, workerStats.Processed)
		}
	}
}

func reportJobsRetry(r metrics.Reporter, retries int64) {
	err := r.ReportGauge(metrics.WorkerJobsRetry, map[string]string{}, float64(retries))
	checkReportErr(metrics.WorkerJobsRetry, err)
}

func reportQueueSizes(r metrics.Reporter, queues map[string]string) {
	for queue, size := range queues {
		tags := map[string]string{"queue": queue}
		sizeFlt, err := strconv.ParseFloat(size, 64)
		if err != nil {
			logger.Log.Errorf("queue size is not int: queue=%s size=%s", queue, size)
			continue
		}

		err = r.ReportGauge(metrics.WorkerQueueSize, tags, sizeFlt)
		checkReportErr(metrics.WorkerQueueSize, err)
	}
}

func reportJobsTotal(r metrics.Reporter, failed, processed int) {
	// "failed" and "processed" always grow up,
	// so they work as count but must be reported as gauge
	err := r.ReportGauge(metrics.WorkerJobsTotal, map[string]string{
		"status": "failed",
	}, float64(failed))
	checkReportErr(metrics.WorkerJobsTotal, err)

	err = r.ReportGauge(metrics.WorkerJobsTotal, map[string]string{
		"status": "ok",
	}, float64(processed))
	checkReportErr(metrics.WorkerJobsTotal, err)
}

func checkReportErr(metric string, err error) {
	if err != nil {
		logger.Log.Errorf("failed to report to %s: %q\n", metric, err)
	}
}

```

`pkg/worker/report_test.go`:

```go
package worker

import (
	"errors"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/topfreegames/pitaya/v3/pkg/metrics"
	"github.com/topfreegames/pitaya/v3/pkg/metrics/mocks"
)

func TestReportJobsRetry(t *testing.T) {
	t.Parallel()

	t.Run("success", func(t *testing.T) {
		ctrl := gomock.NewController(t)
		defer ctrl.Finish()

		mockReporter := mocks.NewMockReporter(ctrl)
		mockReporter.EXPECT().ReportGauge(
			metrics.WorkerJobsRetry,
			map[string]string{},
			float64(10))

		reportJobsRetry(mockReporter, 10)
	})

	t.Run("error", func(t *testing.T) {
		ctrl := gomock.NewController(t)
		defer ctrl.Finish()

		mockReporter := mocks.NewMockReporter(ctrl)
		mockReporter.EXPECT().ReportGauge(
			metrics.WorkerJobsRetry,
			map[string]string{},
			float64(10)).Return(errors.New("err"))

		reportJobsRetry(mockReporter, 10)
	})
}

func TestReportQueueSizes(t *testing.T) {
	t.Parallel()

	var (
		queue1 = "queuename1"
		queue2 = "queuename2"
	)

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockReporter := mocks.NewMockReporter(ctrl)
	mockReporter.EXPECT().ReportGauge(
		metrics.WorkerQueueSize,
		map[string]string{"queue": queue1},
		float64(10))
	mockReporter.EXPECT().ReportGauge(
		metrics.WorkerQueueSize,
		map[string]string{"queue": queue2},
		float64(20))

	reportQueueSizes(mockReporter, map[string]string{
		queue1: "10",
		queue2: "20",
	})
}

func TestReportJobsTotal(t *testing.T) {
	t.Parallel()

	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockReporter := mocks.NewMockReporter(ctrl)
	mockReporter.EXPECT().ReportGauge(
		metrics.WorkerJobsTotal,
		map[string]string{"status": "failed"},
		float64(10))

	mockReporter.EXPECT().ReportGauge(
		metrics.WorkerJobsTotal,
		map[string]string{"status": "ok"},
		float64(20))

	reportJobsTotal(mockReporter, 10, 20)
}

```

`pkg/worker/rpc_job.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package worker

import (
	"context"

	"github.com/golang/protobuf/proto"
)

// RPCJob has infos to execute a rpc on worker
type RPCJob interface {
	// ServerDiscovery returns a serverID based on the route
	// and any metadata that is necessary to decide
	ServerDiscovery(
		route string,
		rpcMetadata map[string]interface{},
	) (serverID string, err error)

	// RPC executes the RPC
	// It is expected that if serverID is "" the RPC
	// happens to any destiny server
	RPC(
		ctx context.Context,
		serverID, routeStr string,
		reply, arg proto.Message,
	) error

	// GetArgReply returns the arg and reply of the
	// method
	GetArgReply(route string) (arg, reply proto.Message, err error)
}

```

`pkg/worker/worker.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package worker

import (
	"context"
	"encoding/json"
	"os"
	"strconv"

	"github.com/golang/protobuf/proto"
	workers "github.com/topfreegames/go-workers"
	"github.com/topfreegames/pitaya/v3/pkg/config"
	"github.com/topfreegames/pitaya/v3/pkg/constants"
	"github.com/topfreegames/pitaya/v3/pkg/logger"
	"github.com/topfreegames/pitaya/v3/pkg/logger/interfaces"
)

// Worker executes RPCs with retry and backoff time
type Worker struct {
	concurrency int
	registered  bool
	opts        *config.EnqueueOpts
	started     bool
}

// NewWorker configures and returns a *Worker
func NewWorker(config config.WorkerConfig, opts config.EnqueueOpts) (*Worker, error) {
	hostname, err := os.Hostname()
	if err != nil {
		return nil, err
	}

	poolSize, err := strconv.Atoi(config.Redis.Pool)
	if err != nil {
		return nil, err
	}

	workers.Configure(workers.Options{
		Address:   config.Redis.ServerURL,
		Password:  config.Redis.Password,
		Namespace: config.Namespace,
		ProcessID: hostname,
		PoolSize:  poolSize,
	})

	return &Worker{
		concurrency: config.Concurrency,
		opts:        &opts,
	}, nil
}

// SetLogger overwrites worker logger
func (w *Worker) SetLogger(logger interfaces.Logger) {
	workers.Logger = logger
}

// Start starts worker in another gorotine
func (w *Worker) Start() {
	go workers.Start()
	w.started = true
}

// Started returns true if worker was started
func (w *Worker) Started() bool {
	return w != nil && w.started
}

// EnqueueRPC enqueues rpc job to worker
func (w *Worker) EnqueueRPC(
	routeStr string,
	metadata map[string]interface{},
	reply, arg proto.Message,
) (jid string, err error) {
	opts := w.enqueueOptions(w.opts)
	return workers.EnqueueWithOptions(rpcQueue, class, &rpcInfo{
		Route:    routeStr,
		Metadata: metadata,
		Arg:      arg,
		Reply:    reply,
	}, opts)
}

// EnqueueRPCWithOptions enqueues rpc job to worker
func (w *Worker) EnqueueRPCWithOptions(
	routeStr string,
	metadata map[string]interface{},
	reply, arg proto.Message,
	opts *config.EnqueueOpts,
) (jid string, err error) {
	return workers.EnqueueWithOptions(rpcQueue, class, &rpcInfo{
		Route:    routeStr,
		Metadata: metadata,
		Arg:      arg,
		Reply:    reply,
	}, w.enqueueOptions(opts))
}

// RegisterRPCJob registers a RPC job
func (w *Worker) RegisterRPCJob(rpcJob RPCJob) error {
	if w.registered {
		return constants.ErrRPCJobAlreadyRegistered
	}

	job := w.parsedRPCJob(rpcJob)
	workers.Process(rpcQueue, job, w.concurrency)
	w.registered = true
	return nil
}

func (w *Worker) parsedRPCJob(rpcJob RPCJob) func(*workers.Msg) {
	return func(jobArg *workers.Msg) {
		logger.Log.Debug("executing rpc job")
		bts, rpcRoute, err := w.unmarshalRouteMetadata(jobArg)
		if err != nil {
			logger.Log.Errorf("failed to get job arg: %q", err)
			panic(err)
		}

		logger.Log.Debug("getting route arg and reply")
		arg, reply, err := rpcJob.GetArgReply(rpcRoute.Route)
		if err != nil {
			logger.Log.Errorf("failed to get methods arg and reply: %q", err)
			panic(err)
		}
		rpcInfo := &rpcInfo{
			Arg:   arg,
			Reply: reply,
		}

		logger.Log.Debug("unmarshalling rpc info")
		err = json.Unmarshal(bts, rpcInfo)
		if err != nil {
			logger.Log.Errorf("failed to unmarshal rpc info: %q", err)
			panic(err)
		}

		logger.Log.Debug("choosing server to make rpc")
		serverID, err := rpcJob.ServerDiscovery(rpcInfo.Route, rpcInfo.Metadata)
		if err != nil {
			logger.Log.Errorf("failed get server: %q", err)
			panic(err)
		}

		ctx := context.Background()

		logger.Log.Debugf("executing rpc func to %s", rpcInfo.Route)
		err = rpcJob.RPC(ctx, serverID, rpcInfo.Route, reply, arg)
		if err != nil {
			logger.Log.Errorf("failed make rpc: %q", err)
			panic(err)
		}

		logger.Log.Debug("finished executing rpc job")
	}
}

func (w *Worker) enqueueOptions(
	opts *config.EnqueueOpts,
) workers.EnqueueOptions {
	return workers.EnqueueOptions{
		Retry:    opts.Enabled,
		RetryMax: opts.Max,
		RetryOptions: workers.RetryOptions{
			Exp:      opts.Exponential,
			MinDelay: opts.MinDelay,
			MaxDelay: opts.MaxDelay,
			MaxRand:  opts.MaxRandom,
		},
	}
}

func (w *Worker) unmarshalRouteMetadata(
	jobArg *workers.Msg,
) ([]byte, *rpcRoute, error) {
	bts, err := jobArg.Args().MarshalJSON()
	if err != nil {
		return nil, nil, err
	}

	rpcRoute := new(rpcRoute)
	err = json.Unmarshal(bts, rpcRoute)
	if err != nil {
		return nil, nil, err
	}

	return bts, rpcRoute, nil
}

```

`pkg/worker/worker_test.go`:

```go
package worker

import (
	"context"
	"errors"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/assert"
	workers "github.com/topfreegames/go-workers"
	"github.com/topfreegames/pitaya/v3/pkg/worker/mocks"
)

type fakeProtoMessage struct {
	Field string
}

func (f *fakeProtoMessage) Reset() {}

func (f *fakeProtoMessage) String() string { return "" }

func (f *fakeProtoMessage) ProtoMessage() {}

func TestParsedRPCJob(t *testing.T) {
	t.Parallel()

	var (
		mockRPCJob *mocks.MockRPCJob
		testErr    = errors.New("error")
		route      = "server.svc.method"
		serverID   = "serverid"
		ctx        = context.Background()
	)

	tables := map[string]struct {
		arg    *workers.Msg
		mocks  func()
		assert func(func(*workers.Msg), *workers.Msg)
	}{
		"test_error_when_route_not_string": {
			arg: func() *workers.Msg {
				msg, err := workers.NewMsg(`{"args": {"route": 10}}`)
				assert.NoError(t, err)
				return msg
			}(),
			mocks: func() {},
			assert: func(f func(*workers.Msg), m *workers.Msg) {
				assert.Panics(t, func() { f(m) })
			},
		},
		"test_error_on_get_arg_reply": {
			arg: func() *workers.Msg {
				msg, err := workers.NewMsg(`{
					"args": { "route": "server.svc.method" }
				}`)
				assert.NoError(t, err)
				return msg
			}(),
			mocks: func() {
				mockRPCJob.EXPECT().
					GetArgReply(route).
					Return(nil, nil, testErr)
			},
			assert: func(f func(*workers.Msg), m *workers.Msg) {
				assert.Panics(t, func() { f(m) })
			},
		},
		"test_error_on_unmarshal_rpc_info": {
			arg: func() *workers.Msg {
				msg, err := workers.NewMsg(`{
					"args": { 
						"route": "server.svc.method",
						"arg": { "field": 10 }
					}
				}`)
				assert.NoError(t, err)
				return msg
			}(),
			mocks: func() {
				mockRPCJob.EXPECT().
					GetArgReply(route).
					Return(&fakeProtoMessage{}, &fakeProtoMessage{}, nil)
			},
			assert: func(f func(*workers.Msg), m *workers.Msg) {
				assert.Panics(t, func() { f(m) })
			},
		},
		"test_error_on_server_discovery": {
			arg: func() *workers.Msg {
				msg, err := workers.NewMsg(`{
					"args": { 
						"route": "server.svc.method",
						"arg": { "field": "string" },
						"metadata": { "stack": "a" }
					}
				}`)
				assert.NoError(t, err)
				return msg
			}(),
			mocks: func() {
				mockRPCJob.EXPECT().
					GetArgReply(route).
					Return(&fakeProtoMessage{}, &fakeProtoMessage{}, nil)
				mockRPCJob.EXPECT().
					ServerDiscovery(route, map[string]interface{}{"stack": "a"}).
					Return("", testErr)
			},
			assert: func(f func(*workers.Msg), m *workers.Msg) {
				assert.Panics(t, func() { f(m) })
			},
		},
		"test_error_on_rpc": {
			arg: func() *workers.Msg {
				msg, err := workers.NewMsg(`{
					"args": { 
						"route": "server.svc.method",
						"arg": { "field": "string" },
						"metadata": { "stack": "a" }
					}
				}`)
				assert.NoError(t, err)
				return msg
			}(),
			mocks: func() {
				mockRPCJob.EXPECT().
					GetArgReply(route).
					Return(&fakeProtoMessage{}, &fakeProtoMessage{}, nil)
				mockRPCJob.EXPECT().
					ServerDiscovery(route, map[string]interface{}{"stack": "a"}).
					Return(serverID, nil)
				mockRPCJob.EXPECT().
					RPC(ctx, serverID, route, &fakeProtoMessage{}, &fakeProtoMessage{Field: "string"}).
					Return(testErr)
			},
			assert: func(f func(*workers.Msg), m *workers.Msg) {
				assert.Panics(t, func() { f(m) })
			},
		},
		"test_execute_rpc": {
			arg: func() *workers.Msg {
				msg, err := workers.NewMsg(`{
					"args": { 
						"route": "server.svc.method",
						"arg": { "field": "string" },
						"metadata": { "stack": "a" }
					}
				}`)
				assert.NoError(t, err)
				return msg
			}(),
			mocks: func() {
				mockRPCJob.EXPECT().
					GetArgReply(route).
					Return(&fakeProtoMessage{}, &fakeProtoMessage{}, nil)
				mockRPCJob.EXPECT().
					ServerDiscovery(route, map[string]interface{}{"stack": "a"}).
					Return(serverID, nil)
				mockRPCJob.EXPECT().
					RPC(ctx, serverID, route, &fakeProtoMessage{}, &fakeProtoMessage{Field: "string"})
			},
			assert: func(f func(*workers.Msg), m *workers.Msg) {
				assert.NotPanics(t, func() { f(m) })
			},
		},
	}

	for name, table := range tables {
		t.Run(name, func(t *testing.T) {
			ctrl := gomock.NewController(t)
			defer ctrl.Finish()

			mockRPCJob = mocks.NewMockRPCJob(ctrl)
			table.mocks()

			worker := &Worker{}
			table.assert(worker.parsedRPCJob(mockRPCJob), table.arg)
		})
	}
}

```

`repl/commands.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package repl

import (
	"encoding/json"
	"errors"
	"strings"

	"github.com/sirupsen/logrus"
	"github.com/topfreegames/pitaya/v3/pkg/client"
)

func connect(logger Log, addr string, onMessageCallback func([]byte)) (err error) {
	if pClient != nil && pClient.ConnectedStatus() {
		return errors.New("already connected")
	}

	switch {
	case docsString != "":
		err = protoClient(logger, addr)
	default:
		logger.Println("Using json client")
		pClient = client.New(logrus.InfoLevel)
	}
	pClient.SetClientHandshakeData(handshake)

	if err != nil {
		return err
	}

	if err = tryConnect(addr); err != nil {
		logger.Println("Failed to connect!")
		return err
	}

	logger.Println("connected!")
	disconnectedCh = make(chan bool, 1)
	go readServerMessages(onMessageCallback)

	return nil
}

func setHandshake(logger Log, args []string) error {

	// Try first unserializing arguments as a json.
	err := json.Unmarshal([]byte(strings.Join(args[:], "")), &handshake)
	if err == nil {
		return nil
	}

	if len(args) == 2 {
		if args[0] != "version" && args[0] != "platform" && args[0] != "buildNumber" {
			return errors.New("invalid argument to sethandshake, expected version, platform or buildNumber")
		}
		switch arg := args[0]; arg {
		case "version":
			handshake.Sys.Version = args[1]
		case "platform":
			handshake.Sys.Platform = args[1]
		case "buildNumber":
			handshake.Sys.BuildNumber = args[1]
		}
		return nil
	}

	return errors.New("invalid number of arguments, expected 1 argument <json> or 2 arguments <variable> <value>")
}

func push(logger Log, args []string) error {
	if pClient != nil {
		return errors.New("use this command before connect")
	}

	if len(args) != 2 {
		return errors.New(`push should be in the format: push {route} {type}`)
	}

	route := args[0]
	pushType := args[1]

	if docsString == "" {
		logger.Println("Only for probuffer servers")
		return nil
	}

	pushInfo[route] = pushType

	return nil
}

func request(logger Log, args []string) error {
	if pClient == nil {
		return errors.New("not connected")
	}

	if !pClient.ConnectedStatus() {
		return errors.New("not connected")
	}

	if len(args) < 1 {
		return errors.New(`request should be in the format: request {route} [data]`)
	}

	route := args[0]

	var data []byte
	if len(args) > 1 {
		data = []byte(strings.Join(args[1:], ""))
	}

	_, err := pClient.SendRequest(route, data)
	if err != nil {
		return err
	}

	return nil
}

func notify(logger Log, args []string) error {
	if pClient == nil {
		return errors.New("not connected")
	}

	if !pClient.ConnectedStatus() {
		return errors.New("not connected")
	}

	if len(args) < 1 {
		return errors.New(`notify should be in the format: notify {route} [data]`)
	}

	route := args[0]
	var data []byte
	if len(args) > 1 {
		data = []byte(strings.Join(args[1:], ""))
	}

	if err := pClient.SendNotify(route, data); err != nil {
		return err
	}

	return nil
}

func disconnect() {
	if pClient.ConnectedStatus() {
		disconnectedCh <- true
		pClient.Disconnect()
	}
}

func routes(logger Log) error {
	if pClient == nil {
		return errors.New("client is not initialized")
	}

	if !pClient.ConnectedStatus() {
		return errors.New("not connected")
	}

	if protoClient, ok := pClient.(*client.ProtoClient); ok {
		info := protoClient.ExportInformation()
		if info != nil {
			for k, _ := range info.Commands {
				logger.Println(k)
			}
		}

	} else {
		return errors.New("only ProtoClient implements the command `routes`")
	}

	return nil
}

```

`repl/file.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package repl

import (
	"bufio"
	"errors"
	"log"
	"os"
	"strings"
)

func executeFromFile(fileName string) {
	logger := log.New(os.Stdout, "", log.LstdFlags)

	var err error
	defer func() {
		if err != nil {
			logger.Printf("error: %s", err.Error())
		}
	}()

	var file *os.File
	file, err = os.Open(fileName)
	if err != nil {
		return
	}

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		command := scanner.Text()
		err = executeCommand(logger, command)
		if err != nil {
			return
		}
	}

	err = scanner.Err()
	if err != nil {
		return
	}
}

func executeCommand(logger Log, command string) error {
	parts := strings.Split(command, " ")

	switch parts[0] {
	case "connect":
		return connect(logger, parts[1], func(data []byte) {
			log.Printf("sv-> %s\n", string(data))
			wait.Done()
		})

	case "sethandshake":
		return setHandshake(logger, parts[1:])

	case "request":
		wait.Add(1)
		if err := request(logger, parts[1:]); err != nil {
			return err
		}
		wait.Wait()
		return nil

	case "notify":
		return notify(logger, parts[1:])

	case "push":
		return push(logger, parts[1:])
	case "routes":
		return routes(logger)
	case "disconnect":
		disconnect()
		return nil

	default:
		return errors.New("command not found")
	}
}

```

`repl/helpers.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package repl

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"os"

	"github.com/abiosoft/ishell/v2"
	"github.com/mitchellh/go-homedir"
	"github.com/sirupsen/logrus"
	"github.com/topfreegames/pitaya/v3/pkg/client"
)

func protoClient(log Log, addr string) error {
	log.Println("Using protobuf client")
	protoclient := client.NewProto(docsString, logrus.InfoLevel)
	pClient = protoclient

	for k, v := range pushInfo {
		protoclient.AddPushResponse(k, v)
	}

	if err := protoclient.LoadServerInfo(addr); err != nil {
		log.Println("Failed to load server info")
		return err
	}

	return nil
}

func tryConnect(addr string) error {
	if err := pClient.ConnectToWS(addr, "", &tls.Config{
		InsecureSkipVerify: true,
	}); err != nil {
		if err := pClient.ConnectToWS(addr, ""); err != nil {
			if err := pClient.ConnectTo(addr, &tls.Config{
				InsecureSkipVerify: true,
			}); err != nil {
				if err := pClient.ConnectTo(addr); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func readServerMessages(callback func(data []byte)) {
	channel := pClient.MsgChannel()
	for {
		select {
		case <-disconnectedCh:
			close(disconnectedCh)
			return
		case m := <-channel:
			callback(parseData(m.Data))
		}
	}
}

func configure(c *ishell.Shell) {
	historyPath := os.Getenv("PITAYACLI_HISTORY_PATH")
	if historyPath == "" {
		home, _ := homedir.Dir()
		historyPath = fmt.Sprintf("%s/.pitayacli_history", home)
	}

	c.SetHistoryPath(historyPath)
}

func parseData(data []byte) []byte {
	if prettyJSON {
		var m interface{}
		_ = json.Unmarshal(data, &m)
		data, _ = json.MarshalIndent(m, "", "\t")
	}

	return data
}

```

`repl/log.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package repl

// Log has log methods
type Log interface {
	Print(...interface{})
	Println(...interface{})
	Printf(string, ...interface{})
}

```

`repl/main.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package repl

import (
	"sync"

	"github.com/topfreegames/pitaya/v3/pkg/client"
	"github.com/topfreegames/pitaya/v3/pkg/session"
)

var (
	pClient        client.PitayaClient
	disconnectedCh chan bool
	docsString     string
	fileName       string
	pushInfo       map[string]string
	wait           sync.WaitGroup
	prettyJSON     bool
	handshake      *session.HandshakeData
)

func Start(docs, filename string, prettyJSON bool) {
	docsString = docs
	fileName = filename
	prettyJSON = prettyJSON
	handshake = &session.HandshakeData{
		Sys: session.HandshakeClientData{
			Platform:    "repl",
			LibVersion:  "0.3.5-release",
			BuildNumber: "20",
			Version:     "1.0.0",
		},
		User: map[string]interface{}{
			"client": "repl",
		},
	}

	switch {
	case fileName != "":
		executeFromFile(fileName)
	default:
		repl()
	}
}

```

`repl/shell.go`:

```go
// Copyright (c) TFG Co. All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package repl

import (
	"github.com/abiosoft/ishell/v2"
)

func repl() {
	shell := ishell.New()
	configure(shell)

	shell.Println("Pitaya REPL Client")

	registerConnect(shell)
	registerDisconnect(shell)
	registerRequest(shell)
	registerNotify(shell)
	registerPush(shell)
	registerSetHandshake(shell)

	pushInfo = make(map[string]string)

	shell.Run()
}

func registerConnect(shell *ishell.Shell) {
	shell.AddCmd(&ishell.Cmd{
		Name: "connect",
		Help: "connects to pitaya",
		Func: func(c *ishell.Context) {
			var addr string
			if len(c.Args) == 0 {
				c.Print("address: ")
				addr = c.ReadLine()
			} else {
				addr = c.Args[0]
			}

			if err := connect(c, addr, func(data []byte) {
				c.Printf("sv->%s\n", string(data))
			}); err != nil {
				c.Err(err)
			}
		},
	})
}

func registerPush(shell *ishell.Shell) {
	shell.AddCmd(&ishell.Cmd{
		Name: "push",
		Help: "insert information of push return",
		Func: func(c *ishell.Context) {
			err := push(c, c.RawArgs[1:])
			if err != nil {
				c.Err(err)
			}
		},
	})
}

func registerRequest(shell *ishell.Shell) {
	shell.AddCmd(&ishell.Cmd{
		Name: "request",
		Help: "makes a request to pitaya server",
		Func: func(c *ishell.Context) {
			err := request(c, c.RawArgs[1:])
			if err != nil {
				c.Err(err)
			}
		},
	})
}

func registerNotify(shell *ishell.Shell) {
	shell.AddCmd(&ishell.Cmd{
		Name: "notify",
		Help: "makes a notify to pitaya server",
		Func: func(c *ishell.Context) {
			err := notify(c, c.RawArgs[1:])
			if err != nil {
				c.Err(err)
			}
		},
	})
}

func registerDisconnect(shell *ishell.Shell) {
	shell.AddCmd(&ishell.Cmd{
		Name: "disconnect",
		Help: "disconnects from pitaya server",
		Func: func(c *ishell.Context) {
			disconnect()
		},
	})
}

func registerSetHandshake(shell *ishell.Shell) {
	shell.AddCmd(&ishell.Cmd{
		Name: "sethandshake",
		Help: "sets a handshake parameter",
		Func: func(c *ishell.Context) {
			err := setHandshake(c, c.RawArgs[1:])
			if err != nil {
				c.Err(err)
			}
		},
	})
}

```

`xk6-pitaya/Dockerfile`:

```
# Build the k6 binary with the extension
FROM golang:1.23 as builder

ARG pitaya_revision

RUN go install go.k6.io/xk6/cmd/xk6@latest
# For our example, we'll add support for output of test metrics to InfluxDB v2.
# Feel free to add other extensions using the '--with ...'.
RUN xk6 build \
    --with github.com/topfreegames/pitaya/xk6-pitaya@$pitaya_revision  \
    --replace github.com/topfreegames/pitaya/v3=github.com/topfreegames/pitaya/v3@$pitaya_revision \
    --output /k6

# Use the operator's base image and override the k6 binary
FROM grafana/k6:latest
COPY --from=builder /k6 /usr/bin/k6

```

`xk6-pitaya/LICENSE`:

```
Copyright (c) 2023 Wildlife Studios

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`xk6-pitaya/README.md`:

```md
# xk6-pitaya

`xk6-pitaya` is a [k6](https://go.k6.io/k6) extension that provides a [Pitaya](https://github.com/topfreegames/pitaya) client implementation.

# Usage

## Building the k6 binary

```shell
xk6 build --with github.com/topfreegames/pitaya/xk6-pitaya=./ --replace github.com/topfreegames/pitaya/v3=../
```

## Building the k6 docker image

```shell
docker build --build-arg pitaya_revision=ac6eb29bdb -t xk6-pitaya
# change the pitaya_revision to the revision you want to use
```

## Example usage

```javascript
import pitaya from 'k6/x/pitaya';
import { check } from 'k6';

export const options = {
  vus: 10,
  duration: '10s',
}

const opts = {
  handshakeData: {
    sys: {
      clientVersion: "1.0.1",
      clientBuildNumber: "1",
      platform: "android"
    },
    user: {
      fiu: "c0a78b27-dd34-4e0d-bff7-36168fce0df5",
      bundleId: "com.game.test",
      deviceType: "ios",
      language: "en",
      osVersion: "12.0",
      region: "US",
      stack: "green-stack"
    }
  },
  requestTimeoutMs: 1000,
  logLevel: "info",
  serializer: "json",
}

const pitayaClient = new pitaya.Client(opts)

export default async () => {
  if (!pitayaClient.isConnected()) {
    pitayaClient.connect("localhost:3250")
  }

  check(pitayaClient.isConnected(), { 'pitaya client is connected': (r) => r === true })

  var res = await pitayaClient.request("room.room.entry")
  check(res.result, { 'contains an result field': (r) => r !== undefined })
  check(res.result, { 'result is ok': (r) => r === "ok" })

  var res = await pitayaClient.request("room.room.setsessiondata", { data: {"testKey": "testVal"} })
  check(res, { 'res is success': (r) => String.fromCharCode.apply(null,r) === "success"} )
  var res = await pitayaClient.request("room.room.getsessiondata")
  check(res.Data, { 'res contains set data': (r) => r.testKey === "testVal"} )
  res = await pitayaClient.request("room.room.join")
  check(res.result, { 'result from join is successful': (r) => r === "success"} )
  res = await pitayaClient.consumePush("onMembers", 500)
  check(res.Members, { 'res contains a member group': (m) => m !== undefined } )
  res = await pitayaClient.request("room.room.leave")
  check(res, { 'result from leave is successful': (r) => String.fromCharCode.apply(null,r) === "success"})

 pitayaClient.disconnect()
}

export function teardown() {
}
```

## Running the scenario 1 example

```shell

# spin up pitaya dependencies
make ensure-testing-deps

# run pitaya server, backend and frontend
make run-cluster-example-backend
make run-cluster-example-frontend

# run k6 scenario
./k6 run ./examples/scenario1.js
```

# Metrics

This extension will add the following metrics to the k6 output:

- `pitaya_client_request_duration_ms`: Histogram of request durations in milliseconds
    - `success`: If the request was successful or not
    - `route`: The route of the request
- `pitaya_client_request_timeout_count`: Counter of timedout requests
    - `route`: The route of the request

# Protobuf client support

This extension does not support pitaya running with protobuf serialization. For loadtesting your server with this, use the json serializer.

```go
builder.Serializer = json.NewSerializer()
```

Or just don't set it, since json is the default serializer.

# Additional Documentation

All k6 documentation also applies to this extension. See https://k6.io/docs/ for more information.

# Running distributed tests

It is possible to run distributed tests using k6 and this extension. To do so you can refer to the [k6 documentation](https://k6.io/docs/testing-guides/running-distributed-tests/) and use the binary generated from this repo as the k6 binary. There's a prebuilt docker image available at [tfgco/xk6-pitaya](https://hub.docker.com/r/tfgco/xk6-pitaya) that you can use as well.

```

`xk6-pitaya/client.go`:

```go
package pitaya

import (
	"crypto/tls"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"reflect"
	"sync"
	"time"

	"github.com/grafana/sobek"
	pitayaclient "github.com/topfreegames/pitaya/v3/pkg/client"
	pitayamessage "github.com/topfreegames/pitaya/v3/pkg/conn/message"
	"github.com/topfreegames/pitaya/v3/pkg/session"
	"go.k6.io/k6/js/modules"
	"go.k6.io/k6/metrics"
)

// Response is the type of the response returned by the server
type Response interface{}

// Client is the pitaya client
// It is used to connect to a pitaya server and send requests and notifies
// It is also used to consume pushes
type Client struct {
	vu             modules.VU
	client         pitayaclient.PitayaClient
	handshake      *session.HandshakeData
	responsesMutex sync.Mutex
	responses      map[uint]chan []byte
	pushesMutex    sync.Mutex
	pushes         map[string]chan []byte
	timeout        time.Duration
	metrics        *pitayaMetrics
	useTLS         bool
}

// Connect connects to the server
// addr is the address of the server to connect to
func (c *Client) Connect(addr string) error {
	vuState := c.vu.State()

	if vuState == nil {
		return errors.New("connecting to a pitaya server in the init context is not supported")
	}

	var err error
	if c.useTLS {
		tlsConfig := &tls.Config{GetConfigForClient: func(*tls.ClientHelloInfo) (*tls.Config, error) { return nil, nil }, InsecureSkipVerify: true}
		err = c.client.ConnectTo(addr, tlsConfig)
	} else {
		err = c.client.ConnectTo(addr)
	}

	if err != nil {
		return err
	}
	go c.listen()

	return err
}

// IsConnected returns true if the client is connected to the server
func (c *Client) IsConnected() bool {
	res := reflect.ValueOf(c.client).Elem().FieldByName("Connected")
	return res.Bool()
}

// ConsumePush will return a promise that will be resolved when a push is received on the given route.
// The promise will be rejected if the timeout is reached before a push is received.
// The promise will be resolved with the push data.
func (c *Client) ConsumePush(route string, timeoutMs int) *sobek.Promise {
	promise, resolve, reject := c.makeHandledPromise()
	ch := c.getPushChannelForRoute(route)
	go func() {
		select {
		case data := <-ch:
			var ret Response
			if err := json.Unmarshal(data, &ret); err != nil {
				err = fmt.Errorf("Error unmarshaling response: %s", err)
				reject(err)
				return
			}
			resolve(ret)
			return
		case <-time.After(time.Duration(timeoutMs) * time.Millisecond):
			reject(fmt.Errorf("Timeout waiting for push on route %s", route))
			return
		}
	}()
	return promise
}

// Notify sends a notify to the server
// route is the route to send the notify to
// msg is the message to send
// returns an error if the notify could not be sent
func (c *Client) Notify(route string, msg interface{}) error {
	m := msg
	if m == nil {
		m = map[string]interface{}{}
	}
	data, err := json.Marshal(m)
	if err != nil {
		return err
	}

	return c.client.SendNotify(route, data)
}

// RequestB64 sends a request to the server using a base64 string
// route is the route to send the request to
// str is the string passed in request
// returns a promise that will be resolved when the response is received
// the promise will be rejected if the timeout is reached before a response is received
func (c *Client) RequestB64(route string, b64msg string) *sobek.Promise { // TODO: add custom timeout
	promise, resolve, reject := c.makeHandledPromise()
	data, err := base64.StdEncoding.DecodeString(b64msg)
	if err != nil {
		reject(err)
		return promise
	}

	timeNow := time.Now()
	mid, err := c.client.SendRequest(route, data)
	if err != nil {
		c.pushRequestMetrics(route, time.Since(timeNow), false, false)
		reject(err)
		return promise
	}
	responseChan := c.getResponseChannelForID(mid)
	go func() {
		select {
		case responseData := <-responseChan:
			c.pushRequestMetrics(route, time.Since(timeNow), true, false)
			var ret Response
			if err := json.Unmarshal(responseData, &ret); err != nil {
				resolve(responseData)
				return
			}
			resolve(ret)
			return
		case <-time.After(c.timeout):
			c.pushRequestMetrics(route, time.Since(timeNow), false, true)
			reject(fmt.Errorf("Timeout waiting for response on route %s", route))
		}
	}()
	return promise
}

// Request sends a request to the server
// route is the route to send the request to
// msg is the message to send
// returns a promise that will be resolved when the response is received
// the promise will be rejected if the timeout is reached before a response is received
func (c *Client) Request(route string, msg interface{}) *sobek.Promise { // TODO: add custom timeout
	m := msg
	if m == nil {
		m = map[string]interface{}{}
	}
	promise, resolve, reject := c.makeHandledPromise()
	data, err := json.Marshal(m)
	if err != nil {
		reject(err)
		return promise
	}

	timeNow := time.Now()
	mid, err := c.client.SendRequest(route, data)
	if err != nil {
		c.pushRequestMetrics(route, time.Since(timeNow), false, false)
		reject(err)
		return promise
	}
	responseChan := c.getResponseChannelForID(mid)
	go func() {
		select {
		case responseData := <-responseChan:
			c.pushRequestMetrics(route, time.Since(timeNow), true, false)
			var ret Response
			if err := json.Unmarshal(responseData, &ret); err != nil {
				resolve(responseData)
				return
			}
			resolve(ret)
			return
		case <-time.After(c.timeout):
			c.pushRequestMetrics(route, time.Since(timeNow), false, true)
			reject(fmt.Errorf("Timeout waiting for response on route %s", route))
		}
	}()
	return promise
}

func (c *Client) pushRequestMetrics(route string, responseTime time.Duration, success bool, timeout bool) error {
	state := c.vu.State()
	if state == nil {
		return errors.New("invalid state")
	}

	ctx := c.vu.Context()
	if ctx == nil {
		return errors.New("invalid context")
	}

	metrics.PushIfNotDone(ctx, state.Samples, metrics.Sample{
		TimeSeries: metrics.TimeSeries{
			Metric: c.metrics.RequestResponseTime,
			Tags: c.metrics.TagsAndMeta.Tags.WithTagsFromMap(state.Options.RunTags).WithTagsFromMap(
				map[string]string{
					"route":   route,
					"success": fmt.Sprintf("%t", success),
				}),
		},
		Value: metrics.D(responseTime),
		Time:  time.Now(),
	})

	value := 0
	if timeout {
		value = 1
	}

	metrics.PushIfNotDone(ctx, state.Samples, metrics.Sample{
		TimeSeries: metrics.TimeSeries{
			Metric: c.metrics.TimeoutRequests,
			Tags: c.metrics.TagsAndMeta.Tags.WithTagsFromMap(state.Options.RunTags).WithTagsFromMap(
				map[string]string{
					"route": route,
				}),
		},
		Value: float64(value),
		Time:  time.Now(),
	})

	return nil
}

// Disconnect disconnects from the server
func (c *Client) Disconnect() {
	c.client.Disconnect()
}

func (c *Client) listen() {
	channel := c.client.MsgChannel()
	go func() {
		for m := range channel {
			switch m.Type {
			case pitayamessage.Response:
				ch := c.getResponseChannelForID(m.ID)
				ch <- m.Data
				c.removeResponseChannelForID(m.ID)
			case pitayamessage.Push:
				ch := c.getPushChannelForRoute(m.Route)
				// only keep one message in the channel, discard the rest
				if len(ch) == 0 {
					ch <- m.Data
				}
			default:
				panic("Unknown message type")
			}
		}
	}()
}

func (c *Client) getResponseChannelForID(id uint) chan []byte {
	c.responsesMutex.Lock()
	defer c.responsesMutex.Unlock()
	if _, ok := c.responses[id]; !ok {
		c.responses[id] = make(chan []byte, 1)
	}

	return c.responses[id]
}

func (c *Client) removeResponseChannelForID(id uint) {
	c.responsesMutex.Lock()
	defer c.responsesMutex.Unlock()

	delete(c.responses, id)
}

func (c *Client) getPushChannelForRoute(route string) chan []byte {
	c.pushesMutex.Lock()
	defer c.pushesMutex.Unlock()
	if _, ok := c.pushes[route]; !ok {
		c.pushes[route] = make(chan []byte, 1)
	}

	return c.pushes[route]
}

// makeHandledPromise will create a promise and return its resolve and reject methods,
// wrapped in such a way that it will block the eventloop from exiting before they are
// called even if the promise isn't resolved by the time the current script ends executing.
func (c *Client) makeHandledPromise() (*sobek.Promise, func(interface{}), func(interface{})) {
	runtime := c.vu.Runtime()
	callback := c.vu.RegisterCallback()
	p, resolve, reject := runtime.NewPromise()

	return p, func(i interface{}) {
			// more stuff
			callback(func() error {
				resolve(i)
				return nil
			})
		}, func(i interface{}) {
			// more stuff
			callback(func() error {
				reject(i)
				return nil
			})
		}
}

```

`xk6-pitaya/examples/scenario1.js`:

```js
import pitaya from 'k6/x/pitaya';
import { check } from 'k6';

export const options = {
  vus: 10,
  duration: '10s',
}

const opts = {
  handshakeData: {
    sys: {
      clientVersion: "1.0.1",
      clientBuildNumber: "1",
      platform: "android"
    },
    user: {
      fiu: "c0a78b27-dd34-4e0d-bff7-36168fce0df5",
      bundleId: "com.game.test",
      deviceType: "ios",
      language: "en",
      osVersion: "12.0",
      region: "US",
      stack: "green-stack"
    }
  },
  requestTimeoutMs: 1000,
  useTLS: false,
}

const pitayaClient = new pitaya.Client(opts)

export default async () => {
  if (!pitayaClient.isConnected()) {
    pitayaClient.connect("localhost:3250")
  }

  check(pitayaClient.isConnected(), { 'pitaya client is connected': (r) => r === true })

  var res = await pitayaClient.request("room.room.entry")
  check(res.result, { 'contains an result field': (r) => r !== undefined })
  check(res.result, { 'result is ok': (r) => r === "ok" })
  var res = await pitayaClient.request("room.room.setsessiondata", { data: {"testKey": "testVal"} })
  check(res, { 'res is success': (r) => String.fromCharCode.apply(null,r) === "success"} )
  var res = await pitayaClient.request("room.room.getsessiondata")
  check(res.Data, { 'res contains set data': (r) => r.testKey === "testVal"} )

  pitayaClient.notify("room.room.notifypush")
  res = await pitayaClient.consumePush("testPush", 100)
  check(res.Msg, { 'push contains msg': (m) => m === "test"} )

  res = await pitayaClient.request("room.room.join")
  check(res.result, { 'result from join is successful': (r) => r === "success"} )
  res = await pitayaClient.consumePush("onMembers", 1000)
  check(res.Members, { 'res contains a member group': (m) => m !== undefined } )
  res = await pitayaClient.request("room.room.leave")
  check(res, { 'result from leave is successful': (r) => String.fromCharCode.apply(null,r) === "success"})

 pitayaClient.disconnect()
}

export function teardown() {
}

```

`xk6-pitaya/go.mod`:

```mod
module github.com/topfreegames/pitaya/xk6-pitaya

go 1.25

require (
	github.com/grafana/sobek v0.0.0-20251121143121-9f4828fa8148
	github.com/sirupsen/logrus v1.9.3
	github.com/topfreegames/pitaya/v3 v3.0.0-beta.6.0.20251121170220-34c2f2055044
	go.k6.io/k6 v1.4.1
)

require (
	github.com/DataDog/datadog-go v4.8.3+incompatible // indirect
	github.com/Microsoft/go-winio v0.6.2 // indirect
	github.com/beorn7/perks v1.0.1 // indirect
	github.com/bitly/go-simplejson v0.5.1 // indirect
	github.com/bufbuild/protocompile v0.14.1 // indirect
	github.com/cenkalti/backoff/v5 v5.0.3 // indirect
	github.com/cespare/xxhash/v2 v2.3.0 // indirect
	github.com/coreos/go-semver v0.3.1 // indirect
	github.com/coreos/go-systemd/v22 v22.5.0 // indirect
	github.com/dlclark/regexp2 v1.11.5 // indirect
	github.com/evanw/esbuild v0.27.0 // indirect
	github.com/fatih/color v1.18.0 // indirect
	github.com/fsnotify/fsnotify v1.6.0 // indirect
	github.com/go-logr/logr v1.4.3 // indirect
	github.com/go-logr/stdr v1.2.2 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.13.0 // indirect
	github.com/go-sourcemap/sourcemap v2.1.4+incompatible // indirect
	github.com/gogo/protobuf v1.3.2 // indirect
	github.com/golang/protobuf v1.5.4 // indirect
	github.com/gomodule/redigo v1.9.2 // indirect
	github.com/google/pprof v0.0.0-20251114195745-4902fdda35c8 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/gorilla/websocket v1.5.3 // indirect
	github.com/grpc-ecosystem/grpc-gateway/v2 v2.27.3 // indirect
	github.com/hashicorp/hcl v1.0.0 // indirect
	github.com/jhump/protoreflect v1.17.0 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/klauspost/compress v1.18.1 // indirect
	github.com/leodido/go-urn v1.2.4 // indirect
	github.com/magiconair/properties v1.8.10 // indirect
	github.com/mailgun/proxyproto v1.0.0 // indirect
	github.com/mailru/easyjson v0.9.1 // indirect
	github.com/mattn/go-colorable v0.1.14 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/mstoykov/atlas v0.0.0-20220811071828-388f114305dd // indirect
	github.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 // indirect
	github.com/nats-io/nats.go v1.47.0 // indirect
	github.com/nats-io/nkeys v0.4.11 // indirect
	github.com/nats-io/nuid v1.0.1 // indirect
	github.com/onsi/ginkgo v1.16.5 // indirect
	github.com/onsi/gomega v1.33.0 // indirect
	github.com/pelletier/go-toml/v2 v2.0.7 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/prometheus/client_golang v1.23.2 // indirect
	github.com/prometheus/client_model v0.6.2 // indirect
	github.com/prometheus/common v0.67.4 // indirect
	github.com/prometheus/procfs v0.19.2 // indirect
	github.com/serenize/snaker v0.0.0-20201027110005-a7ad2135616e // indirect
	github.com/spf13/afero v1.15.0 // indirect
	github.com/spf13/cast v1.5.1 // indirect
	github.com/spf13/jwalterweatherman v1.1.0 // indirect
	github.com/spf13/pflag v1.0.10 // indirect
	github.com/spf13/viper v1.15.0 // indirect
	github.com/stretchr/objx v0.5.2 // indirect
	github.com/subosito/gotenv v1.4.2 // indirect
	github.com/topfreegames/go-workers v1.2.1 // indirect
	go.etcd.io/etcd/api/v3 v3.5.11 // indirect
	go.etcd.io/etcd/client/pkg/v3 v3.5.11 // indirect
	go.etcd.io/etcd/client/v3 v3.5.11 // indirect
	go.opentelemetry.io/auto/sdk v1.2.1 // indirect
	go.opentelemetry.io/otel v1.38.0 // indirect
	go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.38.0 // indirect
	go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.38.0 // indirect
	go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp v1.38.0 // indirect
	go.opentelemetry.io/otel/metric v1.38.0 // indirect
	go.opentelemetry.io/otel/sdk v1.38.0 // indirect
	go.opentelemetry.io/otel/trace v1.38.0 // indirect
	go.opentelemetry.io/proto/otlp v1.9.0 // indirect
	go.uber.org/atomic v1.11.0 // indirect
	go.uber.org/multierr v1.11.0 // indirect
	go.uber.org/zap v1.24.0 // indirect
	go.yaml.in/yaml/v2 v2.4.3 // indirect
	golang.org/x/crypto v0.45.0 // indirect
	golang.org/x/net v0.47.0 // indirect
	golang.org/x/sys v0.38.0 // indirect
	golang.org/x/text v0.31.0 // indirect
	golang.org/x/time v0.14.0 // indirect
	google.golang.org/genproto/googleapis/api v0.0.0-20251111163417-95abcf5c77ba // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20251111163417-95abcf5c77ba // indirect
	google.golang.org/grpc v1.77.0 // indirect
	google.golang.org/protobuf v1.36.10 // indirect
	gopkg.in/guregu/null.v3 v3.5.0 // indirect
	gopkg.in/ini.v1 v1.67.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

```

`xk6-pitaya/go.sum`:

```sum
github.com/DataDog/datadog-go v4.8.3+incompatible h1:fNGaYSuObuQb5nzeTQqowRAd9bpDIRRV4/gUtIBjh8Q=
github.com/DataDog/datadog-go v4.8.3+incompatible/go.mod h1:LButxg5PwREeZtORoXG3tL4fMGNddJ+vMq1mwgfaqoQ=
github.com/Microsoft/go-winio v0.6.2 h1:F2VQgta7ecxGYO8k3ZZz3RS8fVIXVxONVUPlNERoyfY=
github.com/Microsoft/go-winio v0.6.2/go.mod h1:yd8OoFMLzJbo9gZq8j5qaps8bJ9aShtEA8Ipt1oGCvU=
github.com/andybalholm/brotli v1.2.0 h1:ukwgCxwYrmACq68yiUqwIWnGY0cTPox/M94sVwToPjQ=
github.com/andybalholm/brotli v1.2.0/go.mod h1:rzTDkvFWvIrjDXZHkuS16NPggd91W3kUSvPlQ1pLaKY=
github.com/antithesishq/antithesis-sdk-go v0.5.0 h1:cudCFF83pDDANcXFzkQPUHHedfnnIbUO3JMr9fqwFJs=
github.com/antithesishq/antithesis-sdk-go v0.5.0/go.mod h1:IUpT2DPAKh6i/YhSbt6Gl3v2yvUZjmKncl7U91fup7E=
github.com/benbjohnson/clock v1.1.0 h1:Q92kusRqC1XV2MjkWETPvjJVqKetz1OzxZB7mHJLju8=
github.com/benbjohnson/clock v1.1.0/go.mod h1:J11/hYXuz8f4ySSvYwY0FKfm+ezbsZBKZxNJlLklBHA=
github.com/beorn7/perks v1.0.1 h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=
github.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=
github.com/bitly/go-simplejson v0.5.1 h1:xgwPbetQScXt1gh9BmoJ6j9JMr3TElvuIyjR8pgdoow=
github.com/bitly/go-simplejson v0.5.1/go.mod h1:YOPVLzCfwK14b4Sff3oP1AmGhI9T9Vsg84etUnlyp+Q=
github.com/bufbuild/protocompile v0.14.1 h1:iA73zAf/fyljNjQKwYzUHD6AD4R8KMasmwa/FBatYVw=
github.com/bufbuild/protocompile v0.14.1/go.mod h1:ppVdAIhbr2H8asPk6k4pY7t9zB1OU5DoEw9xY/FUi1c=
github.com/cenkalti/backoff/v5 v5.0.3 h1:ZN+IMa753KfX5hd8vVaMixjnqRZ3y8CuJKRKj1xcsSM=
github.com/cenkalti/backoff/v5 v5.0.3/go.mod h1:rkhZdG3JZukswDf7f0cwqPNk4K0sa+F97BxZthm/crw=
github.com/cespare/xxhash/v2 v2.3.0 h1:UL815xU9SqsFlibzuggzjXhog7bL6oX9BbNZnL2UFvs=
github.com/cespare/xxhash/v2 v2.3.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
github.com/coreos/go-semver v0.3.1 h1:yi21YpKnrx1gt5R+la8n5WgS0kCrsPp33dmEyHReZr4=
github.com/coreos/go-semver v0.3.1/go.mod h1:irMmmIw/7yzSRPWryHsK7EYSg09caPQL03VsM8rvUec=
github.com/coreos/go-systemd/v22 v22.5.0 h1:RrqgGjYQKalulkV8NGVIfkXQf6YYmOyiJKk8iXXhfZs=
github.com/coreos/go-systemd/v22 v22.5.0/go.mod h1:Y58oyj3AT4RCenI/lSvhwexgC+NSVTIJ3seZv2GcEnc=
github.com/customerio/gospec v0.0.0-20130710230057-a5cc0e48aa39 h1:O0YTztXI3XeJXlFhSo4wNb0VBVqSgT+hi/CjNWKvMnY=
github.com/customerio/gospec v0.0.0-20130710230057-a5cc0e48aa39/go.mod h1:OzYUFhPuL2JbjwFwrv6CZs23uBawekc6OZs+g19F0mY=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dlclark/regexp2 v1.11.5 h1:Q/sSnsKerHeCkc/jSTNq1oCm7KiVgUMZRDUoRu0JQZQ=
github.com/dlclark/regexp2 v1.11.5/go.mod h1:DHkYz0B9wPfa6wondMfaivmHpzrQ3v9q8cnmRbL6yW8=
github.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=
github.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=
github.com/evanw/esbuild v0.27.0 h1:1fbrgepqU1rZeu4VPcQRZJpvIfQpbrYqRr1wJdeMkfM=
github.com/evanw/esbuild v0.27.0/go.mod h1:D2vIQZqV/vIf/VRHtViaUtViZmG7o+kKmlBfVQuRi48=
github.com/fatih/color v1.18.0 h1:S8gINlzdQ840/4pfAwic/ZE0djQEH3wM94VfqLTZcOM=
github.com/fatih/color v1.18.0/go.mod h1:4FelSpRwEGDpQ12mAdzqdOukCy4u8WUtOY6lkT/6HfU=
github.com/fatih/structs v1.1.0/go.mod h1:9NiDSp5zOcgEDl+j00MP/WkGVPOlPRLejGD8Ga6PJ7M=
github.com/frankban/quicktest v1.14.4 h1:g2rn0vABPOOXmZUj+vbmUp0lPoXEMuhTpIluN0XL9UY=
github.com/frankban/quicktest v1.14.4/go.mod h1:4ptaffx2x8+WTWXmUCuVU6aPUX1/Mz7zb5vbUoiM6w0=
github.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=
github.com/fsnotify/fsnotify v1.4.9/go.mod h1:znqG4EE+3YCdAaPaxE2ZRY/06pZUdp0tY4IgpuI1SZQ=
github.com/fsnotify/fsnotify v1.6.0 h1:n+5WquG0fcWoWp6xPWfHdbskMCQaFnG6PfBrh1Ky4HY=
github.com/fsnotify/fsnotify v1.6.0/go.mod h1:sl3t1tCWJFWoRz9R8WJCbQihKKwmorjAbSClcnxKAGw=
github.com/go-ini/ini v1.55.0/go.mod h1:ByCAeIL28uOIIG0E3PJtZPDL8WnHpFKFOtgjp+3Ies8=
github.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=
github.com/go-logr/logr v1.4.3 h1:CjnDlHq8ikf6E492q6eKboGOC0T8CDaOvkHCIg8idEI=
github.com/go-logr/logr v1.4.3/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=
github.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=
github.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=
github.com/go-playground/assert/v2 v2.2.0 h1:JvknZsQTYeFEAhQwI4qEt9cyV5ONwRHC+lYKSsYSR8s=
github.com/go-playground/assert/v2 v2.2.0/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=
github.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=
github.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=
github.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=
github.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=
github.com/go-playground/validator/v10 v10.13.0 h1:cFRQdfaSMCOSfGCCLB20MHvuoHb/s5G8L5pu2ppK5AQ=
github.com/go-playground/validator/v10 v10.13.0/go.mod h1:dwu7+CG8/CtBiJFZDz4e+5Upb6OLw04gtBYw0mcG/z4=
github.com/go-sourcemap/sourcemap v2.1.4+incompatible h1:a+iTbH5auLKxaNwQFg0B+TCYl6lbukKPc7b5x0n1s6Q=
github.com/go-sourcemap/sourcemap v2.1.4+incompatible/go.mod h1:F8jJfvm2KbVjc5NqelyYJmf/v5J0dwNLS2mL4sNA1Jg=
github.com/go-task/slim-sprig v0.0.0-20210107165309-348f09dbbbc0/go.mod h1:fyg7847qk6SyHyPtNmDHnmrv/HOrqktSC+C9fM+CJOE=
github.com/godbus/dbus/v5 v5.0.4/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=
github.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=
github.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=
github.com/golang-jwt/jwt/v4 v4.5.2 h1:YtQM7lnr8iZ+j5q71MGKkNw9Mn7AjHM68uc9g5fXeUI=
github.com/golang-jwt/jwt/v4 v4.5.2/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=
github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da h1:oI5xCqsCo564l8iNU+DwB5epxmsaqB+rhGL0m5jtYqE=
github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/golang/mock v1.6.0 h1:ErTB+efbowRARo13NNdxyJji2egdxLGQhRaY+DUumQc=
github.com/golang/mock v1.6.0/go.mod h1:p6yTPP+5HYm5mzsMV8JkE6ZKdX+/wYM6Hr+LicevLPs=
github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=
github.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=
github.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=
github.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=
github.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=
github.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
github.com/golang/protobuf v1.5.4 h1:i7eJL8qZTpSEXOPTxNKhASYpMn+8e5Q6AdndVa1dWek=
github.com/golang/protobuf v1.5.4/go.mod h1:lnTiLA8Wa4RWRcIUkrtSVa5nRhsEGBg48fD6rSs7xps=
github.com/gomodule/redigo v1.9.2 h1:HrutZBLhSIU8abiSfW8pj8mPhOyMYjZT/wcA4/L9L9s=
github.com/gomodule/redigo v1.9.2/go.mod h1:KsU3hiK/Ay8U42qpaJk+kuNa3C+spxapWpM+ywhcgtw=
github.com/google/btree v1.0.1 h1:gK4Kx5IaGY9CD5sPJ36FHiBJ6ZXl0kilRiiCj+jdYp4=
github.com/google/btree v1.0.1/go.mod h1:xXMiIv4Fb/0kKde4SpL7qlzvu5cMJDRkFDxJfI9uaxA=
github.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.7.0 h1:wk8382ETsv4JYUZwIsn6YpYiWiBsYLSJiTsyBybVuN8=
github.com/google/go-cmp v0.7.0/go.mod h1:pXiqmnSA92OHEEa9HXL2W4E7lf9JzCmGVUdgjX3N/iU=
github.com/google/go-tpm v0.9.7 h1:u89J4tUUeDTlH8xxC3CTW7OHZjbjKoHdQ9W7gCUhtxA=
github.com/google/go-tpm v0.9.7/go.mod h1:h9jEsEECg7gtLis0upRBQU+GhYVH6jMjrFxI8u6bVUY=
github.com/google/pprof v0.0.0-20251114195745-4902fdda35c8 h1:3DsUAV+VNEQa2CUVLxCY3f87278uWfIDhJnbdvDjvmE=
github.com/google/pprof v0.0.0-20251114195745-4902fdda35c8/go.mod h1:I6V7YzU0XDpsHqbsyrghnFZLO1gwK6NPTNvmetQIk9U=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=
github.com/gorilla/websocket v1.5.3 h1:saDtZ6Pbx/0u+bgYQ3q96pZgCzfhKXGPqt7kZ72aNNg=
github.com/gorilla/websocket v1.5.3/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=
github.com/grafana/sobek v0.0.0-20251121143121-9f4828fa8148 h1:olrivWIwYv1zG3HXU0iW3YyXtEtKr8ODD1K2wQheDCU=
github.com/grafana/sobek v0.0.0-20251121143121-9f4828fa8148/go.mod h1:YtuqiJX1W3XvRSilL/kUZzduJG3phPJWyzM9DiIEfBo=
github.com/grpc-ecosystem/go-grpc-middleware v1.4.0 h1:UH//fgunKIs4JdUbpDl1VZCDaL56wXCB/5+wF6uHfaI=
github.com/grpc-ecosystem/go-grpc-middleware v1.4.0/go.mod h1:g5qyo/la0ALbONm6Vbp88Yd8NsDy6rZz+RcrMPxvld8=
github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0 h1:Ovs26xHkKqVztRpIrF/92BcuyuQ/YW4NSIpoGtfXNho=
github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0/go.mod h1:8NvIoxWQoOIhqOTXgfV/d3M/q6VIi02HzZEHgUlZvzk=
github.com/grpc-ecosystem/grpc-gateway v1.16.0 h1:gmcG1KaJ57LophUzW0Hy8NmPhnMZb4M0+kPpLofRdBo=
github.com/grpc-ecosystem/grpc-gateway v1.16.0/go.mod h1:BDjrQk3hbvj6Nolgz8mAMFbcEtjT1g+wF4CSlocrBnw=
github.com/grpc-ecosystem/grpc-gateway/v2 v2.27.3 h1:NmZ1PKzSTQbuGHw9DGPFomqkkLWMC+vZCkfs+FHv1Vg=
github.com/grpc-ecosystem/grpc-gateway/v2 v2.27.3/go.mod h1:zQrxl1YP88HQlA6i9c63DSVPFklWpGX4OWAc9bFuaH4=
github.com/hashicorp/hcl v1.0.0 h1:0Anlzjpi4vEasTeNFn2mLJgTSwt0+6sfsiTG8qcWGx4=
github.com/hashicorp/hcl v1.0.0/go.mod h1:E5yfLk+7swimpb2L/Alb/PJmXilQ/rhwaUYs4T20WEQ=
github.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=
github.com/jhump/protoreflect v1.17.0 h1:qOEr613fac2lOuTgWN4tPAtLL7fUSbuJL5X5XumQh94=
github.com/jhump/protoreflect v1.17.0/go.mod h1:h9+vUUL38jiBzck8ck+6G/aeMX8Z4QUY/NiJPwPNi+8=
github.com/jonboulle/clockwork v0.2.2 h1:UOGuzwb1PwsrDAObMuhUnj0p5ULPj8V/xJ7Kx9qUBdQ=
github.com/jonboulle/clockwork v0.2.2/go.mod h1:Pkfl5aHPm1nk2H9h0bjmnJD/BcgbGXUBGnn1kMkgxc8=
github.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=
github.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=
github.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=
github.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=
github.com/jtolds/gls v4.20.0+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=
github.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=
github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
github.com/klauspost/compress v1.18.1 h1:bcSGx7UbpBqMChDtsF28Lw6v/G94LPrrbMbdC3JH2co=
github.com/klauspost/compress v1.18.1/go.mod h1:ZQFFVG+MdnR0P+l6wpXgIL4NTtwiKIdBnrBd8Nrxr+0=
github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=
github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/kylelemons/godebug v1.1.0 h1:RPNrshWIDI6G2gRW9EHilWtl7Z6Sb1BR0xunSBf0SNc=
github.com/kylelemons/godebug v1.1.0/go.mod h1:9/0rRGxNHcop5bhtWyNeEfOS8JIWk580+fNqagV/RAw=
github.com/leodido/go-urn v1.2.4 h1:XlAE/cm/ms7TE/VMVoduSpNBoyc2dOxHs5MZSwAN63Q=
github.com/leodido/go-urn v1.2.4/go.mod h1:7ZrI8mTSeBSHl/UaRyKQW1qZeMgak41ANeCNaVckg+4=
github.com/magiconair/properties v1.8.10 h1:s31yESBquKXCV9a/ScB3ESkOjUYYv+X0rg8SYxI99mE=
github.com/magiconair/properties v1.8.10/go.mod h1:Dhd985XPs7jluiymwWYZ0G4Z61jb3vdS329zhj2hYo0=
github.com/mailgun/proxyproto v1.0.0 h1:CZTX/NM0qSq2JSatnowAhXmsHCXVu9JY6CDouOxJIQ4=
github.com/mailgun/proxyproto v1.0.0/go.mod h1:4r+sqMZLJWs8HRnFYcpYH/Cb+P2QGAQt+bV76JJkS4I=
github.com/mailru/easyjson v0.9.1 h1:LbtsOm5WAswyWbvTEOqhypdPeZzHavpZx96/n553mR8=
github.com/mailru/easyjson v0.9.1/go.mod h1:1+xMtQp2MRNVL/V1bOzuP3aP8VNwRW55fQUto+XFtTU=
github.com/mattn/go-colorable v0.1.14 h1:9A9LHSqF/7dyVVX6g0U9cwm9pG3kP9gSzcuIPHPsaIE=
github.com/mattn/go-colorable v0.1.14/go.mod h1:6LmQG8QLFO4G5z1gPvYEzlUgJ2wF+stgPZH1UqBm1s8=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/mccutchen/go-httpbin/v2 v2.18.3 h1:DyckIScjHLJtmlSju+rgjqqI1nL8AdMZHsLSljlbnMU=
github.com/mccutchen/go-httpbin/v2 v2.18.3/go.mod h1:GBy5I7XwZ4ZLhT3hcq39I4ikwN9x4QUt6EAxNiR8Jus=
github.com/minio/highwayhash v1.0.4-0.20251030100505-070ab1a87a76 h1:KGuD/pM2JpL9FAYvBrnBBeENKZNh6eNtjqytV6TYjnk=
github.com/minio/highwayhash v1.0.4-0.20251030100505-070ab1a87a76/go.mod h1:GGYsuwP/fPD6Y9hMiXuapVvlIUEhFhMTh0rxU3ik1LQ=
github.com/mitchellh/mapstructure v1.5.0 h1:jeMsZIYE/09sWLaz43PL7Gy6RuMjD2eJVyuac5Z2hdY=
github.com/mitchellh/mapstructure v1.5.0/go.mod h1:bFUtVrKA4DC2yAKiSyO/QUcy7e+RRV2QTWOzhPopBRo=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=
github.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=
github.com/mstoykov/atlas v0.0.0-20220811071828-388f114305dd h1:AC3N94irbx2kWGA8f/2Ks7EQl2LxKIRQYuT9IJDwgiI=
github.com/mstoykov/atlas v0.0.0-20220811071828-388f114305dd/go.mod h1:9vRHVuLCjoFfE3GT06X0spdOAO+Zzo4AMjdIwUHBvAk=
github.com/mstoykov/envconfig v1.5.0 h1:E2FgWf73BQt0ddgn7aoITkQHmgwAcHup1s//MsS5/f8=
github.com/mstoykov/envconfig v1.5.0/go.mod h1:vk/d9jpexY2Z9Bb0uB4Ndesss1Sr0Z9ZiGUrg5o9VGk=
github.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 h1:C3w9PqII01/Oq1c1nUAm88MOHcQC9l5mIlSMApZMrHA=
github.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822/go.mod h1:+n7T8mK8HuQTcFwEeznm/DIxMOiR9yIdICNftLE1DvQ=
github.com/nats-io/jwt/v2 v2.8.0 h1:K7uzyz50+yGZDO5o772eRE7atlcSEENpL7P+b74JV1g=
github.com/nats-io/jwt/v2 v2.8.0/go.mod h1:me11pOkwObtcBNR8AiMrUbtVOUGkqYjMQZ6jnSdVUIA=
github.com/nats-io/nats-server/v2 v2.12.2 h1:4TEQd0Y4zvcW0IsVxjlXnRso1hBkQl3TS0BI+SxgPhE=
github.com/nats-io/nats-server/v2 v2.12.2/go.mod h1:j1AAttYeu7WnvD8HLJ+WWKNMSyxsqmZ160pNtCQRMyE=
github.com/nats-io/nats.go v1.47.0 h1:YQdADw6J/UfGUd2Oy6tn4Hq6YHxCaJrVKayxxFqYrgM=
github.com/nats-io/nats.go v1.47.0/go.mod h1:iRWIPokVIFbVijxuMQq4y9ttaBTMe0SFdlZfMDd+33g=
github.com/nats-io/nkeys v0.4.11 h1:q44qGV008kYd9W1b1nEBkNzvnWxtRSQ7A8BoqRrcfa0=
github.com/nats-io/nkeys v0.4.11/go.mod h1:szDimtgmfOi9n25JpfIdGw12tZFYXqhGxjhVxsatHVE=
github.com/nats-io/nuid v1.0.1 h1:5iA8DT8V7q8WK2EScv2padNa/rTESc1KdnPw4TC2paw=
github.com/nats-io/nuid v1.0.1/go.mod h1:19wcPz3Ph3q0Jbyiqsd0kePYG7A95tJPxeL+1OSON2c=
github.com/nxadm/tail v1.4.4/go.mod h1:kenIhsEOeOJmVchQTgglprH7qJGnHDVpk1VPCcaMI8A=
github.com/nxadm/tail v1.4.8/go.mod h1:+ncqLTQzXmGhMZNUePPaPqPvBxHAIsmXswZKocGu+AU=
github.com/nxadm/tail v1.4.11 h1:8feyoE3OzPrcshW5/MJ4sGESc5cqmGkGCWlco4l0bqY=
github.com/nxadm/tail v1.4.11/go.mod h1:OTaG3NK980DZzxbRq6lEuzgU+mug70nY11sMd4JXXHc=
github.com/onsi/ginkgo v1.6.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=
github.com/onsi/ginkgo v1.12.0/go.mod h1:oUhWkIvk5aDxtKvDDuw8gItl8pKl42LzjC9KZE0HfGg=
github.com/onsi/ginkgo v1.12.1/go.mod h1:zj2OWP4+oCPe1qIXoGWkgMRwljMUYCdkwsT2108oapk=
github.com/onsi/ginkgo v1.16.5 h1:8xi0RTUf59SOSfEtZMvwTvXYMzG4gV23XVHOZiXNtnE=
github.com/onsi/ginkgo v1.16.5/go.mod h1:+E8gABHa3K6zRBolWtd+ROzc/U5bkGt0FwiG042wbpU=
github.com/onsi/gomega v1.7.1/go.mod h1:XdKZgCCFLUoM/7CFJVPcG8C1xQ1AJ0vpAezJrB7JYyY=
github.com/onsi/gomega v1.9.0/go.mod h1:Ho0h+IUsWyvy1OpqCwxlQ/21gkhVunqlU8fDGcoTdcA=
github.com/onsi/gomega v1.10.1/go.mod h1:iN09h71vgCQne3DLsj+A5owkum+a2tYe+TOCB1ybHNo=
github.com/onsi/gomega v1.33.0 h1:snPCflnZrpMsy94p4lXVEkHo12lmPnc3vY5XBbreexE=
github.com/onsi/gomega v1.33.0/go.mod h1:+925n5YtiFsLzzafLUHzVMBpvvRAzrydIBiSIxjX3wY=
github.com/pelletier/go-toml/v2 v2.0.7 h1:muncTPStnKRos5dpVKULv2FVd4bMOhNePj9CjgDb8Us=
github.com/pelletier/go-toml/v2 v2.0.7/go.mod h1:eumQOmlWiOPt5WriQQqoM5y18pDHwha2N+QD+EUNTek=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/prometheus/client_golang v1.23.2 h1:Je96obch5RDVy3FDMndoUsjAhG5Edi49h0RJWRi/o0o=
github.com/prometheus/client_golang v1.23.2/go.mod h1:Tb1a6LWHB3/SPIzCoaDXI4I8UHKeFTEQ1YCr+0Gyqmg=
github.com/prometheus/client_model v0.6.2 h1:oBsgwpGs7iVziMvrGhE53c/GrLUsZdHnqNwqPLxwZyk=
github.com/prometheus/client_model v0.6.2/go.mod h1:y3m2F6Gdpfy6Ut/GBsUqTWZqCUvMVzSfMLjcu6wAwpE=
github.com/prometheus/common v0.67.4 h1:yR3NqWO1/UyO1w2PhUvXlGQs/PtFmoveVO0KZ4+Lvsc=
github.com/prometheus/common v0.67.4/go.mod h1:gP0fq6YjjNCLssJCQp0yk4M8W6ikLURwkdd/YKtTbyI=
github.com/prometheus/procfs v0.19.2 h1:zUMhqEW66Ex7OXIiDkll3tl9a1ZdilUOd/F6ZXw4Vws=
github.com/prometheus/procfs v0.19.2/go.mod h1:M0aotyiemPhBCM0z5w87kL22CxfcH05ZpYlu+b4J7mw=
github.com/rogpeppe/go-internal v1.14.1 h1:UQB4HGPB6osV0SQTLymcB4TgvyWu6ZyliaW0tI/otEQ=
github.com/rogpeppe/go-internal v1.14.1/go.mod h1:MaRKkUm5W0goXpeCfT7UZI6fk/L7L7so1lCWt35ZSgc=
github.com/serenize/snaker v0.0.0-20201027110005-a7ad2135616e h1:zWKUYT07mGmVBH+9UgnHXd/ekCK99C8EbDSAt5qsjXE=
github.com/serenize/snaker v0.0.0-20201027110005-a7ad2135616e/go.mod h1:Yow6lPLSAXx2ifx470yD/nUe22Dv5vBvxK/UK9UUTVs=
github.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=
github.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=
github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=
github.com/smartystreets/goconvey v1.6.4/go.mod h1:syvi0/a8iFYH4r/RixwvyeAJjdLS9QV7WQ/tjFTllLA=
github.com/soheilhy/cmux v0.1.5 h1:jjzc5WVemNEDTLwv9tlmemhC73tI08BNOIGwBOo10Js=
github.com/soheilhy/cmux v0.1.5/go.mod h1:T7TcVDs9LWfQgPlPsdngu6I6QIoyIFZDDC6sNE1GqG0=
github.com/spf13/afero v1.15.0 h1:b/YBCLWAJdFWJTN9cLhiXXcD7mzKn9Dm86dNnfyQw1I=
github.com/spf13/afero v1.15.0/go.mod h1:NC2ByUVxtQs4b3sIUphxK0NioZnmxgyCrfzeuq8lxMg=
github.com/spf13/cast v1.3.1/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=
github.com/spf13/cast v1.5.1 h1:R+kOtfhWQE6TVQzY+4D7wJLBgkdVasCEFxSUBYBYIlA=
github.com/spf13/cast v1.5.1/go.mod h1:b9PdjNptOpzXr7Rq1q9gJML/2cdGQAo69NKzQ10KN48=
github.com/spf13/jwalterweatherman v1.1.0 h1:ue6voC5bR5F8YxI5S67j9i582FU4Qvo2bmqnqMYADFk=
github.com/spf13/jwalterweatherman v1.1.0/go.mod h1:aNWZUN0dPAAO/Ljvb5BEdw96iTZ0EXowPYD95IqWIGo=
github.com/spf13/pflag v1.0.10 h1:4EBh2KAYBwaONj6b2Ye1GiHfwjqyROoF4RwYO+vPwFk=
github.com/spf13/pflag v1.0.10/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
github.com/spf13/viper v1.15.0 h1:js3yy885G8xwJa6iOISGFwd+qlUo5AvyXb7CiihdtiU=
github.com/spf13/viper v1.15.0/go.mod h1:fFcTBJxvhhzSJiZy8n+PeW6t8l+KeT/uTARa0jHOQLA=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
github.com/stretchr/objx v0.5.2 h1:xuMeJ0Sdp5ZMRXx/aWO6RZxdr3beISkG5/G/aIRr3pY=
github.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=
github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
github.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
github.com/stretchr/testify v1.8.2/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
github.com/stretchr/testify v1.11.1 h1:7s2iGBzp5EwR7/aIZr8ao5+dra3wiQyKjjFuvgVKu7U=
github.com/stretchr/testify v1.11.1/go.mod h1:wZwfW3scLgRK+23gO65QZefKpKQRnfz6sD981Nm4B6U=
github.com/subosito/gotenv v1.4.2 h1:X1TuBLAMDFbaTAChgCBLu3DU3UPyELpnF2jjJ2cz/S8=
github.com/subosito/gotenv v1.4.2/go.mod h1:ayKnFf/c6rvx/2iiLrJUk1e6plDbT3edrFNGqEflhK0=
github.com/thrawn01/args v0.3.0/go.mod h1:TnRiOFjyh7Wa6oC8ACFPc7KIvbzCiluphA3mJUiPIEo=
github.com/tmc/grpc-websocket-proxy v0.0.0-20201229170055-e5319fda7802 h1:uruHq4dN7GR16kFc5fp3d1RIYzJW5onx8Ybykw2YQFA=
github.com/tmc/grpc-websocket-proxy v0.0.0-20201229170055-e5319fda7802/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=
github.com/topfreegames/go-workers v1.2.1 h1:Jkkir3NngId7XHBP8JxcrqFDR22gLmfzaZlJO0IgCzU=
github.com/topfreegames/go-workers v1.2.1/go.mod h1:Ayopyg9jGJyQ0nEXH8W7iBBBV6rLxwwMKFAdwCD1TSs=
github.com/topfreegames/pitaya/v3 v3.0.0-beta.6.0.20251121170220-34c2f2055044 h1:8BlF9qgaaL0Qm39s8A8ObgC1MpV8fLSLHvj+CRfVfDo=
github.com/topfreegames/pitaya/v3 v3.0.0-beta.6.0.20251121170220-34c2f2055044/go.mod h1:XED/OTau1o6nfl/0Ql5rg00KotgfLc4TeEuyGIBkBMA=
github.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2 h1:eY9dn8+vbi4tKz5Qo6v2eYzo7kUS51QINcR5jNpbZS8=
github.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2/go.mod h1:UETIi67q53MR2AWcXfiuqkDkRtnGDLqkBTpCHuJHxtU=
github.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
github.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
go.etcd.io/bbolt v1.3.8 h1:xs88BrvEv273UsB79e0hcVrlUWmS0a8upikMFhSyAtA=
go.etcd.io/bbolt v1.3.8/go.mod h1:N9Mkw9X8x5fupy0IKsmuqVtoGDyxsaDlbk4Rd05IAQw=
go.etcd.io/etcd/api/v3 v3.5.11 h1:B54KwXbWDHyD3XYAwprxNzTe7vlhR69LuBgZnMVvS7E=
go.etcd.io/etcd/api/v3 v3.5.11/go.mod h1:Ot+o0SWSyT6uHhA56al1oCED0JImsRiU9Dc26+C2a+4=
go.etcd.io/etcd/client/pkg/v3 v3.5.11 h1:bT2xVspdiCj2910T0V+/KHcVKjkUrCZVtk8J2JF2z1A=
go.etcd.io/etcd/client/pkg/v3 v3.5.11/go.mod h1:seTzl2d9APP8R5Y2hFL3NVlD6qC/dOT+3kvrqPyTas4=
go.etcd.io/etcd/client/v2 v2.305.11 h1:ZqdKLNJnWpE3bUaaj3XZ5xWyCi+7Vspgk9E0hlIBguE=
go.etcd.io/etcd/client/v2 v2.305.11/go.mod h1:vX2j5tMynwOateY6BfVmLol3gYOIkbhqjs/BqRsdIOw=
go.etcd.io/etcd/client/v3 v3.5.11 h1:ajWtgoNSZJ1gmS8k+icvPtqsqEav+iUorF7b0qozgUU=
go.etcd.io/etcd/client/v3 v3.5.11/go.mod h1:a6xQUEqFJ8vztO1agJh/KQKOMfFI8og52ZconzcDJwE=
go.etcd.io/etcd/pkg/v3 v3.5.11 h1:U5+/mZh+jps8VRWv7+xPiK1tC1hRBOBYdn7zCqtWyOY=
go.etcd.io/etcd/pkg/v3 v3.5.11/go.mod h1:bLfwo6YEgpOAMBZJsZg5AiSS+mxNTRJi15Dvp9kKW68=
go.etcd.io/etcd/raft/v3 v3.5.11 h1:eeimaNIT9DjV4bdLSy4FjLQ/KGSAiG1L5T1nTf5VoZg=
go.etcd.io/etcd/raft/v3 v3.5.11/go.mod h1:Tp7kZJVtWJWLiMCPrgkimiOB5ZYi8YM93onQihpG724=
go.etcd.io/etcd/server/v3 v3.5.11 h1:FEa0ImvoXdIPa81/vZUKpnJ74fpQ5ZivseoIKMPzfpg=
go.etcd.io/etcd/server/v3 v3.5.11/go.mod h1:CS0+TwcuRlhg1I5CpA3YlisOcoqJB1h1GMRgje75uDs=
go.etcd.io/etcd/tests/v3 v3.5.11 h1:2DsRhrCNmlkPtk+zYovCLuEQlLi0hYNRq1bHW11/VFs=
go.etcd.io/etcd/tests/v3 v3.5.11/go.mod h1:XZ38aoIXYjFUDbltGqhZtnMQ6PGWn90sozJ1mZzhrCM=
go.k6.io/k6 v1.4.1 h1:YhxpZDVLRspsMhmi+dy2YRrfBq48KJgB6lDhsv1/Qks=
go.k6.io/k6 v1.4.1/go.mod h1:+aWtcQ7QR7jkzKCa1MSu9DFXcHGfDN7J8e9+y47AHd0=
go.opentelemetry.io/auto/sdk v1.2.1 h1:jXsnJ4Lmnqd11kwkBV2LgLoFMZKizbCi5fNZ/ipaZ64=
go.opentelemetry.io/auto/sdk v1.2.1/go.mod h1:KRTj+aOaElaLi+wW1kO/DZRXwkF4C5xPbEe3ZiIhN7Y=
go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.49.0 h1:4Pp6oUg3+e/6M4C0A/3kJ2VYa++dsWVTtGgLVj5xtHg=
go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.49.0/go.mod h1:Mjt1i1INqiaoZOMGR1RIUJN+i3ChKoFRqzrRQhlkbs0=
go.opentelemetry.io/otel v1.38.0 h1:RkfdswUDRimDg0m2Az18RKOsnI8UDzppJAtj01/Ymk8=
go.opentelemetry.io/otel v1.38.0/go.mod h1:zcmtmQ1+YmQM9wrNsTGV/q/uyusom3P8RxwExxkZhjM=
go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.38.0 h1:GqRJVj7UmLjCVyVJ3ZFLdPRmhDUp2zFmQe3RHIOsw24=
go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.38.0/go.mod h1:ri3aaHSmCTVYu2AWv44YMauwAQc0aqI9gHKIcSbI1pU=
go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.38.0 h1:lwI4Dc5leUqENgGuQImwLo4WnuXFPetmPpkLi2IrX54=
go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.38.0/go.mod h1:Kz/oCE7z5wuyhPxsXDuaPteSWqjSBD5YaSdbxZYGbGk=
go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp v1.38.0 h1:aTL7F04bJHUlztTsNGJ2l+6he8c+y/b//eR0jjjemT4=
go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp v1.38.0/go.mod h1:kldtb7jDTeol0l3ewcmd8SDvx3EmIE7lyvqbasU3QC4=
go.opentelemetry.io/otel/metric v1.38.0 h1:Kl6lzIYGAh5M159u9NgiRkmoMKjvbsKtYRwgfrA6WpA=
go.opentelemetry.io/otel/metric v1.38.0/go.mod h1:kB5n/QoRM8YwmUahxvI3bO34eVtQf2i4utNVLr9gEmI=
go.opentelemetry.io/otel/sdk v1.38.0 h1:l48sr5YbNf2hpCUj/FoGhW9yDkl+Ma+LrVl8qaM5b+E=
go.opentelemetry.io/otel/sdk v1.38.0/go.mod h1:ghmNdGlVemJI3+ZB5iDEuk4bWA3GkTpW+DOoZMYBVVg=
go.opentelemetry.io/otel/sdk/metric v1.38.0 h1:aSH66iL0aZqo//xXzQLYozmWrXxyFkBJ6qT5wthqPoM=
go.opentelemetry.io/otel/sdk/metric v1.38.0/go.mod h1:dg9PBnW9XdQ1Hd6ZnRz689CbtrUp0wMMs9iPcgT9EZA=
go.opentelemetry.io/otel/trace v1.38.0 h1:Fxk5bKrDZJUH+AMyyIXGcFAPah0oRcT+LuNtJrmcNLE=
go.opentelemetry.io/otel/trace v1.38.0/go.mod h1:j1P9ivuFsTceSWe1oY+EeW3sc+Pp42sO++GHkg4wwhs=
go.opentelemetry.io/proto/otlp v1.9.0 h1:l706jCMITVouPOqEnii2fIAuO3IVGBRPV5ICjceRb/A=
go.opentelemetry.io/proto/otlp v1.9.0/go.mod h1:xE+Cx5E/eEHw+ISFkwPLwCZefwVjY+pqKg1qcK03+/4=
go.uber.org/atomic v1.11.0 h1:ZvwS0R+56ePWxUNi+Atn9dWONBPp/AUETXlHW0DxSjE=
go.uber.org/atomic v1.11.0/go.mod h1:LUxbIzbOniOlMKjJjyPfpl4v+PKK2cNJn91OQbhoJI0=
go.uber.org/goleak v1.3.0 h1:2K3zAYmnTNqV73imy9J1T3WC+gmCePx2hEGkimedGto=
go.uber.org/goleak v1.3.0/go.mod h1:CoHD4mav9JJNrW/WLlf7HGZPjdw8EucARQHekz1X6bE=
go.uber.org/multierr v1.11.0 h1:blXXJkSxSSfBVBlC76pxqeO+LN3aDfLQo+309xJstO0=
go.uber.org/multierr v1.11.0/go.mod h1:20+QtiLqy0Nd6FdQB9TLXag12DsQkrbs3htMFfDN80Y=
go.uber.org/zap v1.24.0 h1:FiJd5l1UOLj0wCgbSE0rwwXHzEdAZS6hiiSnxJN/D60=
go.uber.org/zap v1.24.0/go.mod h1:2kMP+WWQ8aoFoedH3T2sq6iJ2yDWpHbP0f6MQbS9Gkg=
go.yaml.in/yaml/v2 v2.4.3 h1:6gvOSjQoTB3vt1l+CU+tSyi/HOjfOjRLJ4YwYZGwRO0=
go.yaml.in/yaml/v2 v2.4.3/go.mod h1:zSxWcmIDjOzPXpjlTTbAsKokqkDNAVtZO0WOMiT90s8=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/crypto v0.45.0 h1:jMBrvKuj23MTlT0bQEOBcAE0mjg8mK9RXFhRH6nyF3Q=
golang.org/x/crypto v0.45.0/go.mod h1:XTGrrkGJve7CYK7J8PEww4aY7gM3qMCElcJQ8n8JdX4=
golang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200320220750-118fecf932d8/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200520004742-59133d7f0dd7/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
golang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
golang.org/x/net v0.47.0 h1:Mx+4dIFzqraBXUugkia1OOvlD6LemFo1ALMHjrXDOhY=
golang.org/x/net v0.47.0/go.mod h1:/jNxtkgq5yWUGYkaZGqo27cfGZ1c5Nen03aYrrKpVRU=
golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.18.0 h1:kr88TuHDroi+UVf+0hZnirlk8o8T+4MrK6mr60WkH/I=
golang.org/x/sync v0.18.0/go.mod h1:9KTHXmSnoGruLpwFjVSX0lNNA75CykiMECbovNTZqGI=
golang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190904154756-749cb33beabd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191005200804-aed5e4c7ecf9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191120155948-bd437916bb0e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210112080510-489259a85091/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220908164124-27713097b956/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.38.0 h1:3yZWxaJjBmCWXqhN1qh02AkOnCQ1poK6oF+a7xWL6Gc=
golang.org/x/sys v0.38.0/go.mod h1:OgkHotnGiDImocRcuBABYBEXf8A9a87e/uXjp9XT3ks=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.31.0 h1:aC8ghyu4JhP8VojJ2lEHBnochRno1sgL6nEi9WGFGMM=
golang.org/x/text v0.31.0/go.mod h1:tKRAlv61yKIjGGHX/4tP1LTbc13YSec1pxVEWXzfoeM=
golang.org/x/time v0.14.0 h1:MRx4UaLrDotUKUdCIqzPC48t1Y9hANFKIRpNx+Te8PI=
golang.org/x/time v0.14.0/go.mod h1:eL/Oa2bBBK0TkX57Fyni+NgnyQQN4LitPmob2Hjnqw4=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190328211700-ab21143f2384/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
golang.org/x/tools v0.0.0-20201224043029-2b0845dc783e/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
gonum.org/v1/gonum v0.16.0 h1:5+ul4Swaf3ESvrOnidPp4GZbzf0mxVQpDCYUQE7OJfk=
gonum.org/v1/gonum v0.16.0/go.mod h1:fef3am4MQ93R2HHpKnLk4/Tbh/s0+wqD5nfa6Pnwy4E=
google.golang.org/genproto v0.0.0-20240227224415-6ceb2ff114de h1:F6qOa9AZTYJXOUEr4jDysRDLrm4PHePlge4v4TGAlxY=
google.golang.org/genproto v0.0.0-20240227224415-6ceb2ff114de/go.mod h1:VUhTRKeHn9wwcdrk73nvdC9gF178Tzhmt/qyaFcPLSo=
google.golang.org/genproto/googleapis/api v0.0.0-20251111163417-95abcf5c77ba h1:B14OtaXuMaCQsl2deSvNkyPKIzq3BjfxQp8d00QyWx4=
google.golang.org/genproto/googleapis/api v0.0.0-20251111163417-95abcf5c77ba/go.mod h1:G5IanEx8/PgI9w6CFcYQf7jMtHQhZruvfM1i3qOqk5U=
google.golang.org/genproto/googleapis/rpc v0.0.0-20251111163417-95abcf5c77ba h1:UKgtfRM7Yh93Sya0Fo8ZzhDP4qBckrrxEr2oF5UIVb8=
google.golang.org/genproto/googleapis/rpc v0.0.0-20251111163417-95abcf5c77ba/go.mod h1:7i2o+ce6H/6BluujYR+kqX3GKH+dChPTQU19wjRPiGk=
google.golang.org/grpc v1.77.0 h1:wVVY6/8cGA6vvffn+wWK5ToddbgdU3d8MNENr4evgXM=
google.golang.org/grpc v1.77.0/go.mod h1:z0BY1iVj0q8E1uSQCjL9cppRj+gnZjzDnzV0dHhrNig=
google.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=
google.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=
google.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=
google.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=
google.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=
google.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.36.10 h1:AYd7cD/uASjIL6Q9LiTjz8JLcrh/88q5UObnmY3aOOE=
google.golang.org/protobuf v1.36.10/go.mod h1:HTf+CrKn2C3g5S8VImy6tdcUvCska2kB7j23XfzDpco=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
gopkg.in/fsnotify.v1 v1.4.7/go.mod h1:Tz8NjZHkW78fSQdbUxIjBTcgA1z1m8ZHf0WmKUhAMys=
gopkg.in/guregu/null.v3 v3.5.0 h1:xTcasT8ETfMcUHn0zTvIYtQud/9Mx5dJqD554SZct0o=
gopkg.in/guregu/null.v3 v3.5.0/go.mod h1:E4tX2Qe3h7QdL+uZ3a0vqvYwKQsRSQKM5V4YltdgH9Y=
gopkg.in/ini.v1 v1.55.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=
gopkg.in/ini.v1 v1.67.0 h1:Dgnx+6+nfE+IfzjUEISNeydPJh9AXNNsWbGP9KzCsOA=
gopkg.in/ini.v1 v1.67.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=
gopkg.in/natefinch/lumberjack.v2 v2.0.0 h1:1Lc07Kr7qY4U2YPouBjpCLxpiyxIVoxqXgkXLknAOE8=
gopkg.in/natefinch/lumberjack.v2 v2.0.0/go.mod h1:l0ndWWf7gzL7RNwBG7wST/UCcT4T24xpD6X8LsfU/+k=
gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 h1:uRGJdciOHaEIrze2W8Q3AKkepLTh2hOroT7a+7czfdQ=
gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7/go.mod h1:dt/ZhP58zS4L8KSrWDmTeBkI65Dw0HsyUHuEVlX15mw=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=
gopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
sigs.k8s.io/yaml v1.3.0 h1:a2VclLzOGrwOHDiV8EfBGhvjHvP46CtW5j6POvhYGGo=
sigs.k8s.io/yaml v1.3.0/go.mod h1:GeOyir5tyXNByN85N/dRIT9es5UQNerPYEKK56eTBm8=

```

`xk6-pitaya/module.go`:

```go
package pitaya

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/grafana/sobek"
	"github.com/sirupsen/logrus"
	pitayaclient "github.com/topfreegames/pitaya/v3/pkg/client"
	"github.com/topfreegames/pitaya/v3/pkg/session"
	"go.k6.io/k6/js/common"
	"go.k6.io/k6/js/modules"
)

type (
	// RootModule is the global module instance that will create Client
	// instances for each VU.
	RootModule struct{}

	// ModuleInstance represents an instance of the JS module.
	ModuleInstance struct {
		vu modules.VU
		*Client
		metrics *pitayaMetrics
	}
)

// Ensure the interfaces are implemented correctly
var (
	_ modules.Instance = &ModuleInstance{}
	_ modules.Module   = &RootModule{}
)

// New returns a pointer to a new RootModule instance
func New() *RootModule {
	return &RootModule{}
}

// NewModuleInstance implements the modules.Module interface and returns
// a new instance for each VU.
func (*RootModule) NewModuleInstance(vu modules.VU) modules.Instance {
	m, err := registerMetrics(vu)
	if err != nil {
		common.Throw(vu.Runtime(), err)
	}
	return &ModuleInstance{vu: vu, Client: &Client{vu: vu}, metrics: &m}
}

// Exports implements the modules.Instance interface and returns
// the exports of the JS module.
func (mi *ModuleInstance) Exports() modules.Exports {
	return modules.Exports{Named: map[string]interface{}{
		"Client": mi.NewClient,
	}}
}

// NewClient is the JS constructor function for the Client type.
// It returns a new Client instance for each VU.
// The first argument is an options object with the following fields:
// - handshakeData: the handshake data to send to the server
// - requestTimeoutMs: the timeout for requests in milliseconds
// - logLevel: the log level to use
func (mi *ModuleInstance) NewClient(call sobek.ConstructorCall) *sobek.Object {
	rt := mi.vu.Runtime()

	var optionsArg map[string]interface{}
	err := rt.ExportTo(call.Arguments[0], &optionsArg)
	if err != nil {
		common.Throw(rt, errors.New("unable to parse options object"))
	}

	opts, err := newOptionsFrom(optionsArg)
	if err != nil {
		common.Throw(rt, fmt.Errorf("invalid options; reason: %w", err))
	}

	client := &Client{
		vu:        mi.vu,
		client:    nil,
		handshake: opts.HandshakeData,
		responses: make(map[uint]chan []byte, 100),
		pushes:    make(map[string]chan []byte, 100),
		timeout:   time.Duration(opts.RequestTimeoutMs) * time.Millisecond,
		metrics:   mi.metrics,
		useTLS:    opts.UseTLS,
	}

	client.client = pitayaclient.New(logrus.InfoLevel)
	client.client.SetClientHandshakeData(opts.HandshakeData)

	return rt.ToValue(client).ToObject(rt)
}

type options struct {
	HandshakeData    *session.HandshakeData `json:"handshakeData"`
	RequestTimeoutMs int                    `json:"requestTimeoutMs"`
	UseTLS           bool                   `json:"useTLS"`
}

// newOptionsFrom validates and instantiates an options struct from its map representation
// as obtained by calling a Goja's Runtime.ExportTo.
func newOptionsFrom(argument map[string]interface{}) (*options, error) {
	jsonStr, err := json.Marshal(argument)
	if err != nil {
		return nil, fmt.Errorf("unable to serialize options to JSON %w", err)
	}

	// Instantiate a JSON decoder which will error on unknown
	// fields. As a result, if the input map contains an unknown
	// option, this function will produce an error.
	decoder := json.NewDecoder(bytes.NewReader(jsonStr))
	decoder.DisallowUnknownFields()

	var opts options
	err = decoder.Decode(&opts)
	if err != nil {
		return nil, fmt.Errorf("unable to decode options %w", err)
	}

	return &opts, nil
}

```

`xk6-pitaya/register.go`:

```go
// Package pitays only exists to register the pitaya extension
package pitaya

import (
	"go.k6.io/k6/js/modules"
)

// Register the extension on module initialization, available to
// import from JS as "k6/x/pitaya".
func init() {
	modules.Register("k6/x/pitaya", new(RootModule))
}

```

`xk6-pitaya/stats.go`:

```go
package pitaya

import (
	"errors"

	"go.k6.io/k6/js/modules"
	"go.k6.io/k6/metrics"
)

type pitayaMetrics struct {
	RequestResponseTime *metrics.Metric
	TimeoutRequests     *metrics.Metric
	TagsAndMeta         *metrics.TagsAndMeta
}

// registerMetrics registers the metrics for the mqtt module in the metrics registry
func registerMetrics(vu modules.VU) (pitayaMetrics, error) {
	p := pitayaMetrics{}
	env := vu.InitEnv()
	if env == nil {
		return p, errors.New("missing env")
	}
	registry := env.Registry
	if registry == nil {
		return p, errors.New("missing registry")
	}

	var err error
	p.RequestResponseTime, err = registry.NewMetric("pitaya_client_request_duration_ms", metrics.Trend)
	if err != nil {
		return p, err
	}

	p.TimeoutRequests, err = registry.NewMetric("pitaya_client_request_timeout_count", metrics.Counter)
	if err != nil {
		return p, err
	}

	p.TagsAndMeta = &metrics.TagsAndMeta{
		Tags: registry.RootTagSet(),
	}
	return p, nil
}

```