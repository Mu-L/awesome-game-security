Project Path: arc_tandasat_Sushi_fnwk3t5j

Source Tree:

```txt
arc_tandasat_Sushi_fnwk3t5j
├── LICENSE
├── README.md
├── Sushi
│   ├── ChangeMSR
│   │   ├── ChangeMSR.cpp
│   │   ├── ChangeMSR.vcxproj
│   │   ├── ChangeMSR.vcxproj.filters
│   │   ├── ChangeMSR.vcxproj.user
│   │   └── stdafx.h
│   ├── Sushi
│   │   ├── Arch
│   │   │   └── amd64
│   │   │       ├── asm64.asm
│   │   │       └── common.inc
│   │   ├── Sushi.vcxproj
│   │   ├── Sushi.vcxproj.filters
│   │   ├── Sushi.vcxproj.user
│   │   ├── asm.h
│   │   ├── ia32_type.h
│   │   ├── log.cpp
│   │   ├── log.h
│   │   ├── misc.cpp
│   │   ├── misc.h
│   │   ├── stdafx.cpp
│   │   ├── stdafx.h
│   │   ├── sushi.cpp
│   │   ├── util.cpp
│   │   ├── util.h
│   │   ├── vminit.cpp
│   │   ├── vminit.h
│   │   ├── vmx.cpp
│   │   ├── vmx.h
│   │   └── vmx_type.h
│   ├── Sushi.sln
│   ├── SushiTest
│   │   ├── SushiTest.cpp
│   │   ├── SushiTest.vcxproj
│   │   ├── SushiTest.vcxproj.filters
│   │   ├── stdafx.cpp
│   │   ├── stdafx.h
│   │   └── targetver.h
│   └── clean.bat
└── img
    ├── basic_output.png
    └── detected.png

```

`LICENSE`:

```
The MIT License (MIT)

Copyright (c) 2015 Satoshi Tanda

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


```

`README.md`:

```md
Sushi
======

Sushi is a tiny, simple hypervisor based monitoring tool detecting and stopping
some of PatchGuard activities from Ring-1.

A related blog entry can be found here:
    http://standa-note.blogspot.ca/2015/08/writing-hypervisor-for-kernel-mode-code.html


Installation and Uninstallation
--------------------------------

Get an archive file for compiled files form this link:

   https://github.com/tandasat/Sushi/releases/latest

On the x64 platform, you have to enable test signing to install the driver.
To do that, open the command prompt with the administrator privilege and type 
the following command, and then restart the system to activate the change:

    bcdedit /set {current} testsigning on

To install the driver, extract the archive file and use the 'sc' command. For 
installation:

    >sc create Sushi type= kernel binPath= C:\Users\user\Desktop\Sushi.sys
    >sc start Sushi

For uninstallation:

    >sc stop Sushi
    >sc delete Sushi

Note that the system must support the Intel VT-x technology to successfully
install the driver. See the blog entry for configuration of the virtual machine
if you are going to test with VMware.

Once you have installed the Sushi.sys, it logs interesting activities on 
C:\Windows\Sushi.log and DebugView when it occurred, or you can run 
SushiTest.exe and see its output is being changed.
![Basic Output](/img/basic_output.png)

Also, you can install ChangeMSR.sys in the same way as above to trigger more 
interesting activities (although you may get bug check 0x109 if you are unlucky
as this driver does not handle all possible patterns).
![Detected](/img/detected.png)


Supported Platform(s)
----------------------
- Windows 8.1 and 10 (x64)


License
--------
This software is released under the MIT License, see LICENSE.

```

`Sushi/ChangeMSR/ChangeMSR.cpp`:

```cpp
// Copyright (c) 2015, tandasat. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

//
// This module implements a demo of MSR moditication to triggar PatchGuard crash
//
#include "stdafx.h"
#include "../Sushi/ia32_type.h"
#include "../Sushi/log.h"
#include "../Sushi/util.h"

////////////////////////////////////////////////////////////////////////////////
//
// macro utilities
//

////////////////////////////////////////////////////////////////////////////////
//
// constants and macros
//

static const ULONG POOL_TAG_NAME = ' RSM';

#if DBG
static const auto LOG_LEVEL =
    LOG_PUT_LEVEL_DEBUG | LOG_OPT_DISABLE_FUNCTION_NAME;
#else
static const auto LOG_LEVEL =
    LOG_PUT_LEVEL_INFO | LOG_OPT_DISABLE_FUNCTION_NAME;
#endif

////////////////////////////////////////////////////////////////////////////////
//
// types
//

#include <pshpack1.h>
struct JMP_CODE {
  UCHAR jmp[6];
  ULONG_PTR address;
};
static_assert(sizeof(JMP_CODE) == 14, "Size check");
#include <poppack.h>

////////////////////////////////////////////////////////////////////////////////
//
// prototypes
//

EXTERN_C DRIVER_INITIALIZE DriverEntry;

EXTERN_C static DRIVER_UNLOAD DriverUnload;

EXTERN_C static NTSTATUS MsrHookCallback(_In_opt_ void* Context);

////////////////////////////////////////////////////////////////////////////////
//
// variables
//

static UCHAR* g_Trampoline = nullptr;
static ULONG_PTR g_MSRs[64] = {};

////////////////////////////////////////////////////////////////////////////////
//
// implementations
//

// Entry point
ALLOC_TEXT(INIT, DriverEntry)
_Use_decl_annotations_ EXTERN_C NTSTATUS
DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) {
  UNREFERENCED_PARAMETER(RegistryPath);
  PAGED_CODE();

  auto status = STATUS_UNSUCCESSFUL;
  DriverObject->DriverUnload = DriverUnload;

  DBG_BREAK();

  status = LogInitialization(LOG_LEVEL, nullptr);
  if (!NT_SUCCESS(status)) {
    return status;
  }

  // Build the following code as a SYSENTER handler on NonPagedPool
  //
  // FF 25 00 00 00 00                       jmp     cs:jmp_address
  // FF FF FF FF FF FF FF FF jmp_address     dq 0FFFFFFFFFFFFFFFFh
  const JMP_CODE jmpCode = {{0xff, 0x25}, __readmsr(IA32_LSTAR)};

  g_Trampoline = reinterpret_cast<UCHAR*>(ExAllocatePoolWithTag(
      NonPagedPoolExecute, sizeof(jmpCode), POOL_TAG_NAME));
  if (!g_Trampoline) {
    LogTermination();
    return STATUS_MEMORY_NOT_ALLOCATED;
  }
  RtlCopyMemory(g_Trampoline, &jmpCode, sizeof(jmpCode));

  // Modify MSR
  UtilForEachProcessor(MsrHookCallback, nullptr);
  return status;
}

ALLOC_TEXT(PAGED, DriverUnload)
_Use_decl_annotations_ EXTERN_C static void DriverUnload(
    PDRIVER_OBJECT DriverObject) {
  UNREFERENCED_PARAMETER(DriverObject);
  PAGED_CODE();

  DBG_BREAK();

  // Restore MSR
  UtilForEachProcessor(MsrHookCallback, nullptr);
  ExFreePoolWithTag(g_Trampoline, POOL_TAG_NAME);
  LogTermination();
}

// Modify or restore MSR
_Use_decl_annotations_ EXTERN_C static NTSTATUS MsrHookCallback(void* Context) {
  UNREFERENCED_PARAMETER(Context);

  auto oldmsr = &g_MSRs[KeGetCurrentProcessorNumber()];
  if (*oldmsr == 0) {
    // Modify
    *oldmsr = __readmsr(IA32_LSTAR);
    __writemsr(IA32_LSTAR, reinterpret_cast<ULONG_PTR>(g_Trampoline));
    LOG_INFO("MSR(%08x) %p => %p", IA32_LSTAR, *oldmsr, g_Trampoline);
  } else {
    // Restore
    __writemsr(IA32_LSTAR, *oldmsr);
    LOG_INFO("MSR(%08x) %p => %p", IA32_LSTAR, g_Trampoline, *oldmsr);
  }
  return STATUS_SUCCESS;
}

```

`Sushi/ChangeMSR/ChangeMSR.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Win8.1 Debug|Win32">
      <Configuration>Win8.1 Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8.1 Release|Win32">
      <Configuration>Win8.1 Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 Debug|Win32">
      <Configuration>Win8 Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 Release|Win32">
      <Configuration>Win8 Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Debug|Win32">
      <Configuration>Win7 Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Release|Win32">
      <Configuration>Win7 Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8.1 Debug|x64">
      <Configuration>Win8.1 Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8.1 Release|x64">
      <Configuration>Win8.1 Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 Debug|x64">
      <Configuration>Win8 Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 Release|x64">
      <Configuration>Win8 Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Debug|x64">
      <Configuration>Win7 Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Release|x64">
      <Configuration>Win7 Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{EDF29BD1-A646-472B-9A17-801D6C4E261C}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>11.0</MinimumVisualStudioVersion>
    <Configuration>Win8.1 Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>ChangeMSR</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8.1 Debug|Win32'" Label="Configuration">
    <TargetVersion>WindowsV6.3</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver8.1</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8.1 Release|Win32'" Label="Configuration">
    <TargetVersion>WindowsV6.3</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver8.1</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows8</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver8.1</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|Win32'" Label="Configuration">
    <TargetVersion>Windows8</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver8.1</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver8.1</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|Win32'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver8.1</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8.1 Debug|x64'" Label="Configuration">
    <TargetVersion>WindowsV6.3</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver8.1</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8.1 Release|x64'" Label="Configuration">
    <TargetVersion>WindowsV6.3</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver8.1</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|x64'" Label="Configuration">
    <TargetVersion>Windows8</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver8.1</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|x64'" Label="Configuration">
    <TargetVersion>Windows8</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver8.1</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver8.1</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver8.1</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8.1 Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8.1 Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8.1 Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8.1 Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8.1 Debug|Win32'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8.1 Release|Win32'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|Win32'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|Win32'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|Win32'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|Win32'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8.1 Debug|x64'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8.1 Release|x64'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|x64'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|x64'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|x64'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|x64'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
    <FilesToPackage Include="@(Inf->'%(CopyOutput)')" Condition="'@(Inf)'!=''" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\Sushi\log.cpp" />
    <ClCompile Include="..\Sushi\util.cpp" />
    <ClCompile Include="ChangeMSR.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Sushi/ChangeMSR/ChangeMSR.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Source Files\../Sushi">
      <UniqueIdentifier>{8a637759-d380-4fbd-b508-63e6183c97e5}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ChangeMSR.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\Sushi\log.cpp">
      <Filter>Source Files\../Sushi</Filter>
    </ClCompile>
    <ClCompile Include="..\Sushi\util.cpp">
      <Filter>Source Files\../Sushi</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Sushi/ChangeMSR/ChangeMSR.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|x64'">
    <SignMode>TestSign</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|x64'">
    <SignMode>TestSign</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8.1 Release|x64'">
    <SignMode>TestSign</SignMode>
  </PropertyGroup>
</Project>
```

`Sushi/ChangeMSR/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

extern "C" {
#pragma warning(push, 0)
#include <fltKernel.h>
#include <Wdmsec.h>
#include <windef.h>
#include <ntimage.h>
#include <stdarg.h>
#define NTSTRSAFE_NO_CB_FUNCTIONS
#include <ntstrsafe.h>
#include <ntddstor.h>
#include <mountdev.h>
#include <ntddvol.h>
#include <intrin.h>
#include <Aux_klib.h>
#pragma warning(pop)
}

////////////////////////////////////////////////////////////////////////////////
//
// macro utilities
//

// Specifies where the code should be located
#ifdef ALLOC_PRAGMA
#define ALLOC_TEXT(Section, Name) __pragma(alloc_text(Section, Name))
#else
#define ALLOC_TEXT(Section, Name)
#endif

// Break point that works only when a debugger is enabled
#ifndef DBG_BREAK
#define DBG_BREAK()              \
  if (KD_DEBUGGER_NOT_PRESENT) { \
  } else {                       \
    __debugbreak();              \
  }                              \
  reinterpret_cast<void*>(0)
#endif

////////////////////////////////////////////////////////////////////////////////
//
// constants and macros
//

////////////////////////////////////////////////////////////////////////////////
//
// types
//

////////////////////////////////////////////////////////////////////////////////
//
// prototypes
//

////////////////////////////////////////////////////////////////////////////////
//
// variables
//

////////////////////////////////////////////////////////////////////////////////
//
// implementations
//

```

`Sushi/Sushi.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
VisualStudioVersion = 12.0.40629.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Sushi", "Sushi\Sushi.vcxproj", "{5CC550F2-7825-4589-B6EA-6C7908663F2D}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ChangeMSR", "ChangeMSR\ChangeMSR.vcxproj", "{EDF29BD1-A646-472B-9A17-801D6C4E261C}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{1603954C-B93E-4388-891E-2F8BCF72CFD2}"
	ProjectSection(SolutionItems) = preProject
		..\.gitattributes = ..\.gitattributes
		..\.gitignore = ..\.gitignore
		..\LICENSE = ..\LICENSE
		..\README.md = ..\README.md
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SushiTest", "SushiTest\SushiTest.vcxproj", "{FEDC1796-520E-4DC0-A081-66D03E462AA0}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Sushi", "Sushi", "{7719D6DF-4028-4299-93EB-2ECFCA2CEF9B}"
	ProjectSection(SolutionItems) = preProject
		.clang-format = .clang-format
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Win7 Debug|x64 = Win7 Debug|x64
		Win7 Release|x64 = Win7 Release|x64
		Win8 Debug|x64 = Win8 Debug|x64
		Win8 Release|x64 = Win8 Release|x64
		Win8.1 Debug|x64 = Win8.1 Debug|x64
		Win8.1 Release|x64 = Win8.1 Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{5CC550F2-7825-4589-B6EA-6C7908663F2D}.Win7 Debug|x64.ActiveCfg = Win7 Debug|x64
		{5CC550F2-7825-4589-B6EA-6C7908663F2D}.Win7 Debug|x64.Build.0 = Win7 Debug|x64
		{5CC550F2-7825-4589-B6EA-6C7908663F2D}.Win7 Debug|x64.Deploy.0 = Win7 Debug|x64
		{5CC550F2-7825-4589-B6EA-6C7908663F2D}.Win7 Release|x64.ActiveCfg = Win7 Release|x64
		{5CC550F2-7825-4589-B6EA-6C7908663F2D}.Win7 Release|x64.Build.0 = Win7 Release|x64
		{5CC550F2-7825-4589-B6EA-6C7908663F2D}.Win7 Release|x64.Deploy.0 = Win7 Release|x64
		{5CC550F2-7825-4589-B6EA-6C7908663F2D}.Win8 Debug|x64.ActiveCfg = Win8 Debug|x64
		{5CC550F2-7825-4589-B6EA-6C7908663F2D}.Win8 Debug|x64.Build.0 = Win8 Debug|x64
		{5CC550F2-7825-4589-B6EA-6C7908663F2D}.Win8 Debug|x64.Deploy.0 = Win8 Debug|x64
		{5CC550F2-7825-4589-B6EA-6C7908663F2D}.Win8 Release|x64.ActiveCfg = Win8 Release|x64
		{5CC550F2-7825-4589-B6EA-6C7908663F2D}.Win8 Release|x64.Build.0 = Win8 Release|x64
		{5CC550F2-7825-4589-B6EA-6C7908663F2D}.Win8 Release|x64.Deploy.0 = Win8 Release|x64
		{5CC550F2-7825-4589-B6EA-6C7908663F2D}.Win8.1 Debug|x64.ActiveCfg = Win8.1 Debug|x64
		{5CC550F2-7825-4589-B6EA-6C7908663F2D}.Win8.1 Debug|x64.Build.0 = Win8.1 Debug|x64
		{5CC550F2-7825-4589-B6EA-6C7908663F2D}.Win8.1 Debug|x64.Deploy.0 = Win8.1 Debug|x64
		{5CC550F2-7825-4589-B6EA-6C7908663F2D}.Win8.1 Release|x64.ActiveCfg = Win8.1 Release|x64
		{5CC550F2-7825-4589-B6EA-6C7908663F2D}.Win8.1 Release|x64.Build.0 = Win8.1 Release|x64
		{5CC550F2-7825-4589-B6EA-6C7908663F2D}.Win8.1 Release|x64.Deploy.0 = Win8.1 Release|x64
		{EDF29BD1-A646-472B-9A17-801D6C4E261C}.Win7 Debug|x64.ActiveCfg = Win7 Debug|x64
		{EDF29BD1-A646-472B-9A17-801D6C4E261C}.Win7 Debug|x64.Build.0 = Win7 Debug|x64
		{EDF29BD1-A646-472B-9A17-801D6C4E261C}.Win7 Debug|x64.Deploy.0 = Win7 Debug|x64
		{EDF29BD1-A646-472B-9A17-801D6C4E261C}.Win7 Release|x64.ActiveCfg = Win7 Release|x64
		{EDF29BD1-A646-472B-9A17-801D6C4E261C}.Win7 Release|x64.Build.0 = Win7 Release|x64
		{EDF29BD1-A646-472B-9A17-801D6C4E261C}.Win7 Release|x64.Deploy.0 = Win7 Release|x64
		{EDF29BD1-A646-472B-9A17-801D6C4E261C}.Win8 Debug|x64.ActiveCfg = Win8 Debug|x64
		{EDF29BD1-A646-472B-9A17-801D6C4E261C}.Win8 Debug|x64.Build.0 = Win8 Debug|x64
		{EDF29BD1-A646-472B-9A17-801D6C4E261C}.Win8 Debug|x64.Deploy.0 = Win8 Debug|x64
		{EDF29BD1-A646-472B-9A17-801D6C4E261C}.Win8 Release|x64.ActiveCfg = Win8 Release|x64
		{EDF29BD1-A646-472B-9A17-801D6C4E261C}.Win8 Release|x64.Build.0 = Win8 Release|x64
		{EDF29BD1-A646-472B-9A17-801D6C4E261C}.Win8 Release|x64.Deploy.0 = Win8 Release|x64
		{EDF29BD1-A646-472B-9A17-801D6C4E261C}.Win8.1 Debug|x64.ActiveCfg = Win8.1 Debug|x64
		{EDF29BD1-A646-472B-9A17-801D6C4E261C}.Win8.1 Debug|x64.Build.0 = Win8.1 Debug|x64
		{EDF29BD1-A646-472B-9A17-801D6C4E261C}.Win8.1 Debug|x64.Deploy.0 = Win8.1 Debug|x64
		{EDF29BD1-A646-472B-9A17-801D6C4E261C}.Win8.1 Release|x64.ActiveCfg = Win8.1 Release|x64
		{EDF29BD1-A646-472B-9A17-801D6C4E261C}.Win8.1 Release|x64.Build.0 = Win8.1 Release|x64
		{EDF29BD1-A646-472B-9A17-801D6C4E261C}.Win8.1 Release|x64.Deploy.0 = Win8.1 Release|x64
		{FEDC1796-520E-4DC0-A081-66D03E462AA0}.Win7 Debug|x64.ActiveCfg = Debug|x64
		{FEDC1796-520E-4DC0-A081-66D03E462AA0}.Win7 Debug|x64.Build.0 = Debug|x64
		{FEDC1796-520E-4DC0-A081-66D03E462AA0}.Win7 Debug|x64.Deploy.0 = Debug|x64
		{FEDC1796-520E-4DC0-A081-66D03E462AA0}.Win7 Release|x64.ActiveCfg = Release|x64
		{FEDC1796-520E-4DC0-A081-66D03E462AA0}.Win7 Release|x64.Build.0 = Release|x64
		{FEDC1796-520E-4DC0-A081-66D03E462AA0}.Win7 Release|x64.Deploy.0 = Release|x64
		{FEDC1796-520E-4DC0-A081-66D03E462AA0}.Win8 Debug|x64.ActiveCfg = Debug|x64
		{FEDC1796-520E-4DC0-A081-66D03E462AA0}.Win8 Debug|x64.Build.0 = Debug|x64
		{FEDC1796-520E-4DC0-A081-66D03E462AA0}.Win8 Debug|x64.Deploy.0 = Debug|x64
		{FEDC1796-520E-4DC0-A081-66D03E462AA0}.Win8 Release|x64.ActiveCfg = Release|x64
		{FEDC1796-520E-4DC0-A081-66D03E462AA0}.Win8 Release|x64.Build.0 = Release|x64
		{FEDC1796-520E-4DC0-A081-66D03E462AA0}.Win8 Release|x64.Deploy.0 = Release|x64
		{FEDC1796-520E-4DC0-A081-66D03E462AA0}.Win8.1 Debug|x64.ActiveCfg = Debug|x64
		{FEDC1796-520E-4DC0-A081-66D03E462AA0}.Win8.1 Debug|x64.Build.0 = Debug|x64
		{FEDC1796-520E-4DC0-A081-66D03E462AA0}.Win8.1 Debug|x64.Deploy.0 = Debug|x64
		{FEDC1796-520E-4DC0-A081-66D03E462AA0}.Win8.1 Release|x64.ActiveCfg = Release|x64
		{FEDC1796-520E-4DC0-A081-66D03E462AA0}.Win8.1 Release|x64.Build.0 = Release|x64
		{FEDC1796-520E-4DC0-A081-66D03E462AA0}.Win8.1 Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{7719D6DF-4028-4299-93EB-2ECFCA2CEF9B} = {1603954C-B93E-4388-891E-2F8BCF72CFD2}
	EndGlobalSection
EndGlobal

```

`Sushi/Sushi/Arch/amd64/asm64.asm`:

```asm
;
; This module implements all assembler code
;
include common.inc

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; References to C functions
;
EXTERN VmxVmExitHandler : PROC
EXTERN MiscDumpGpRegisters : PROC
EXTERN MiscWaitForever : PROC

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; constants
;
.CONST

VM_INSTRUCTION_ERROR        EQU     00004400h
VMX_OK                      EQU     0
VMX_ERROR_WITH_STATUS       EQU     1
VMX_ERROR_WITHOUT_STATUS    EQU     2

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; macros
;

; Dumps all general purpose registers and a flag register.
ASM_DUMP_REGISTERS MACRO
    pushfq
    PUSHAQ
    mov rcx, rsp
    mov rdx, rsp
    add rdx, 8*17
    
    sub rsp, 28h
    call MiscDumpGpRegisters ; MiscDumpGpRegisters(GuestContext, rsp);
    add rsp, 28h
    
    POPAQ
    popfq
ENDM


; Implements jump to an arbitrary location without modifying registers.
; 0ffffffffffffffffh is used as a mark to be replaced with a correct address.
ASM_JMP_TEMPLATE MACRO 
    nop     ; This is space for implanting int 3 for debugging
    jmp     qword ptr [jmp_address]
jmp_address:
    dq      0ffffffffffffffffh
ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; implementations
;
.CODE INIT

; EXTERN_C bool AsmInitialieVM(_In_ void(* VmInitializationRoutine)(
;     ULONG_PTR GuestStackPointer, ULONG_PTR GuestInstructionPointer));
; 
; A wrapper for VmInitializationRoutine.
AsmInitialieVM PROC
    pushfq
    PUSHAQ

    mov rax, rcx
    mov rdx, asmResumeVM
    mov rcx, rsp

    sub rsp, 28h
    call rax                ; VmInitializationRoutine(rsp, asmResumeVM)
    add rsp, 28h

    POPAQ
    popfq
    xor rax, rax            ; return false
    ret

    ; This is where the vitalized guest start to execute after successful 
    ; vmlaunch. 
asmResumeVM:
    POPAQ
    popfq

    ASM_DUMP_REGISTERS
    or rax, 1               ; return true
    ret
AsmInitialieVM ENDP


.CODE


; An entry point of VMM where gets called whenever VM-exit occurred.
AsmVmmEntryPoint PROC
    ; No need to save the flag registers since it is restored from the VMCS at
    ; the time of vmresume.
    PUSHAQ                  ; -8 * 16
    mov rcx, rsp
    
    sub rsp, 28h
    call VmxVmExitHandler   ; bool vmContinue = VmxVmExitHandler(GuestContext);
    add rsp, 28h

    test rax, rax
    jz exitVM               ; if (!vmContinue) jmp exitVM

    POPAQ
    vmresume
    int 3
    jz errorWithCode        ; if (ZF) jmp
    jmp errorWithoutCode 

    ; Executes vmxoff and ends virtualization
exitVM:
    ;   r8  = Guest's rflags
    ;   rdx = Guest's rsp
    ;   rcx = Guest's rip for the next instruction
    POPAQ
    vmxoff
    jz errorWithCode        ; if (ZF) jmp
    jc errorWithoutCode     ; if (CF) jmp
    push r8
    popfq                   ; rflags <= GurstFlags 
    mov rsp, rdx            ; rsp <= GuestRsp
    push rcx
    ret                     ; jmp AddressToReturn

errorWithCode:
    mov rcx, VM_INSTRUCTION_ERROR 
    vmread rcx, rcx

errorWithoutCode:
    jmp errorWithoutCode
AsmVmmEntryPoint ENDP


; EXTERN_C VMX_STATUS AsmVmxCall(_In_ ULONG_PTR HyperCallNumber,
;                                _In_opt_ void *Context);
;
; Executes vmcall with the given hypercall number and a context parameter.
AsmVmxCall PROC
    vmcall                  ; vmcall(HyperCallNumber, Context)
    jz errorWithCode        ; if (ZF) jmp
    jc errorWithoutCode     ; if (CF) jmp
    xor rax, rax            ; return VMX_OK
    ret

errorWithoutCode:
    mov rax, VMX_ERROR_WITHOUT_STATUS
    ret

errorWithCode:
    mov rax, VMX_ERROR_WITH_STATUS
    ret
AsmVmxCall ENDP


; GDT
AsmWriteGDT PROC
    lgdt fword ptr [rcx]
    ret
AsmWriteGDT ENDP

AsmReadGDT PROC
    sgdt [rcx]
    ret
AsmReadGDT ENDP


; LDTR
AsmWriteLDTR PROC
    lldt cx
    ret
AsmWriteLDTR ENDP

AsmReadLDTR PROC
    sldt ax
    ret
AsmReadLDTR ENDP


; TR
AsmWriteTR PROC
    ltr cx
    ret
AsmWriteTR ENDP

AsmReadTR PROC
    str ax
    ret
AsmReadTR ENDP


; ES
AsmWriteES PROC
    mov es, cx
    ret
AsmWriteES ENDP

AsmReadES PROC
    mov ax, es
    ret
AsmReadES ENDP


; CS
AsmWriteCS PROC
    mov cs, cx
    ret
AsmWriteCS ENDP

AsmReadCS PROC
    mov ax, cs
    ret
AsmReadCS ENDP


; SS
AsmWriteSS PROC
    mov ss, cx
    ret
AsmWriteSS ENDP

AsmReadSS PROC
    mov ax, ss
    ret
AsmReadSS ENDP


; DS
AsmWriteDS PROC
    mov ds, cx
    ret
AsmWriteDS ENDP

AsmReadDS PROC
    mov ax, ds
    ret
AsmReadDS ENDP


; FS
AsmWriteFS PROC
    mov fs, cx
    ret
AsmWriteFS ENDP

AsmReadFS PROC
    mov ax, fs
    ret
AsmReadFS ENDP


; GS
AsmWriteGS PROC
    mov gs, cx
    ret
AsmWriteGS ENDP

AsmReadGS PROC
    mov ax, gs
    ret
AsmReadGS ENDP


; MISC

AsmLoadAccessRightsByte PROC
    lar rax, rcx
    ret
AsmLoadAccessRightsByte ENDP


AsmInvalidateInternalCaches PROC
    invd
    ret
AsmInvalidateInternalCaches ENDP


AsmWriteCR2 PROC
    mov cr2, rcx
    ret
AsmWriteCR2 ENDP


AsmUndefinedInstruction PROC
    ud2
    ret
AsmUndefinedInstruction ENDP


AsmXsetbv PROC
    mov rax, r8
    xsetbv      ; XCR[ECX] <= EDX:EAX;
    ret
AsmXsetbv ENDP


; Calls MiscWaitForever() which puts this thread sleep forever. 
AsmWaitForever PROC
    pushfq
    PUSHAQ
    mov rcx, rsp
    mov rdx, rsp
    add rdx, 8*17
    
    sub rsp, 28h
    call MiscWaitForever    ; Using jmp instead will cause bug check in a 
                            ; subsequent sleep function.
    add rsp, 28h
    
    POPAQ
    popfq
    int 3
    ret
AsmWaitForever ENDP


END

```

`Sushi/Sushi/Arch/amd64/common.inc`:

```inc
;
; This module implements common macros
;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; constants
;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; macros
;

; Saves all general purpose registers to the stack
PUSHAQ MACRO
    push    rax
    push    rcx
    push    rdx
    push    rbx
    push    -1      ; dummy for rsp
    push    rbp
    push    rsi
    push    rdi
    push    r8
    push    r9
    push    r10
    push    r11
    push    r12
    push    r13
    push    r14
    push    r15
ENDM


; Loads all general purpose registers from the stack
POPAQ MACRO
    pop     r15
    pop     r14
    pop     r13
    pop     r12
    pop     r11
    pop     r10
    pop     r9
    pop     r8
    pop     rdi
    pop     rsi
    pop     rbp
    add     rsp, 8    ; dummy for rsp
    pop     rbx
    pop     rdx
    pop     rcx
    pop     rax
ENDM


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; implementations
;


```

`Sushi/Sushi/Sushi.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Win8.1 Debug|x64">
      <Configuration>Win8.1 Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8.1 Release|x64">
      <Configuration>Win8.1 Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 Debug|x64">
      <Configuration>Win8 Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win8 Release|x64">
      <Configuration>Win8 Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Debug|x64">
      <Configuration>Win7 Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win7 Release|x64">
      <Configuration>Win7 Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{5CC550F2-7825-4589-B6EA-6C7908663F2D}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>11.0</MinimumVisualStudioVersion>
    <Configuration>Win8.1 Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>Sushi</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8.1 Debug|x64'" Label="Configuration">
    <TargetVersion>WindowsV6.3</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver8.1</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8.1 Release|x64'" Label="Configuration">
    <TargetVersion>WindowsV6.3</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver8.1</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|x64'" Label="Configuration">
    <TargetVersion>Windows8</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver8.1</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|x64'" Label="Configuration">
    <TargetVersion>Windows8</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver8.1</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver8.1</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver8.1</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8.1 Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8.1 Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8.1 Debug|x64'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Aux_klib.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8.1 Release|x64'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Aux_klib.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Debug|x64'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Aux_klib.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|x64'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Aux_klib.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Debug|x64'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Aux_klib.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|x64'">
    <ClCompile>
      <WppScanConfigurationData Condition="'%(ClCompile. ScanConfigurationData)'  == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Aux_klib.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
    <FilesToPackage Include="@(Inf->'%(CopyOutput)')" Condition="'@(Inf)'!=''" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="asm.h" />
    <ClInclude Include="ia32_type.h" />
    <ClInclude Include="log.h" />
    <ClInclude Include="misc.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="util.h" />
    <ClInclude Include="vminit.h" />
    <ClInclude Include="vmx.h" />
    <ClInclude Include="vmx_type.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="log.cpp" />
    <ClCompile Include="misc.cpp" />
    <ClCompile Include="stdafx.cpp" />
    <ClCompile Include="sushi.cpp" />
    <ClCompile Include="util.cpp" />
    <ClCompile Include="vminit.cpp" />
    <ClCompile Include="vmx.cpp" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="Arch\amd64\asm64.asm">
      <FileType>Document</FileType>
    </MASM>
    <None Include="Arch\amd64\common.inc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Sushi/Sushi/Sushi.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Source Files\Arch">
      <UniqueIdentifier>{bed542d2-aa43-4cb8-961c-b6669be1df6e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Arch\amd64">
      <UniqueIdentifier>{57001ab8-48db-4332-91ba-9bd5b8b1b55e}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="asm.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="log.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="misc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="vminit.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="vmx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="vmx_type.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ia32_type.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="log.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="misc.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="sushi.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="util.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="vminit.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="vmx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Arch\amd64\common.inc">
      <Filter>Source Files\Arch\amd64</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="Arch\amd64\asm64.asm">
      <Filter>Source Files\Arch\amd64</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`Sushi/Sushi/Sushi.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win7 Release|x64'">
    <SignMode>TestSign</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8 Release|x64'">
    <SignMode>TestSign</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win8.1 Release|x64'">
    <SignMode>TestSign</SignMode>
  </PropertyGroup>
</Project>
```

`Sushi/Sushi/asm.h`:

```h
// Copyright (c) 2015, tandasat. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

//
// This module declares interfaces to logging functions.
//
#pragma once
#include "ia32_type.h"
#include "vmx_type.h"

////////////////////////////////////////////////////////////////////////////////
//
// macro utilities
//

////////////////////////////////////////////////////////////////////////////////
//
// constants and macros
//

////////////////////////////////////////////////////////////////////////////////
//
// types
//

////////////////////////////////////////////////////////////////////////////////
//
// prototypes
//

EXTERN_C bool AsmInitialieVM(_In_ void (*VmInitializationRoutine)(
    ULONG_PTR GuestStackPointer, ULONG_PTR GuestInstructionPointer));

EXTERN_C void AsmVmmEntryPoint();

EXTERN_C VMX_STATUS AsmVmxCall(_In_ ULONG_PTR HyperCallNumber,
                               _In_opt_ void *Context);

EXTERN_C void AsmWriteGDT(_In_ const GDTR *Gdtr);

EXTERN_C void AsmReadGDT(_Out_ GDTR *Gdtr);

EXTERN_C void AsmWriteLDTR(_In_ USHORT LocalSegmengSelector);

EXTERN_C USHORT AsmReadLDTR();

EXTERN_C void AsmWriteTR(_In_ USHORT TaskRegister);

EXTERN_C USHORT AsmReadTR();

EXTERN_C void AsmWriteES(_In_ USHORT SegmentSelector);

EXTERN_C USHORT AsmReadES();

EXTERN_C void AsmWriteCS(_In_ USHORT SegmentSelector);

EXTERN_C USHORT AsmReadCS();

EXTERN_C void AsmWriteSS(_In_ USHORT SegmentSelector);

EXTERN_C USHORT AsmReadSS();

EXTERN_C void AsmWriteDS(_In_ USHORT SegmentSelector);

EXTERN_C USHORT AsmReadDS();

EXTERN_C void AsmWriteFS(_In_ USHORT SegmentSelector);

EXTERN_C USHORT AsmReadFS();

EXTERN_C void AsmWriteGS(_In_ USHORT SegmentSelector);

EXTERN_C USHORT AsmReadGS();

EXTERN_C ULONG_PTR AsmLoadAccessRightsByte(_In_ ULONG_PTR SegmentSelector);

EXTERN_C void AsmInvalidateInternalCaches();

EXTERN_C void AsmWriteCR2(_In_ ULONG_PTR Cr2);

EXTERN_C void AsmUndefinedInstruction();

EXTERN_C void AsmXsetbv(_In_ ULONG32 Index, _In_ ULONG32 HighValue,
                        _In_ ULONG32 LowValue);

EXTERN_C void AsmWaitForever();

EXTERN_C void AsmTrampoline();

////////////////////////////////////////////////////////////////////////////////
//
// variables
//

////////////////////////////////////////////////////////////////////////////////
//
// implementations
//

EXTERN_C inline void __sgdt(_Out_ void *Gdtr) {
  AsmReadGDT(static_cast<GDTR *>(Gdtr));
}

EXTERN_C inline void __lgdt(_In_ void *Gdtr) {
  AsmWriteGDT(static_cast<GDTR *>(Gdtr));
}

```

`Sushi/Sushi/ia32_type.h`:

```h
// Copyright (c) 2015, tandasat. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

//
// This module defines constants and structures defined by the x86-64
// archtecture
//
#pragma once

////////////////////////////////////////////////////////////////////////////////
//
// macro utilities
//

////////////////////////////////////////////////////////////////////////////////
//
// constants and macros
//

////////////////////////////////////////////////////////////////////////////////
//
// types
//

////////////////////////////////////////////////////////////////////////////////
//
// prototypes
//

//
// EFLAGS
//  2.3 SYSTEM FLAGS AND FIELDS IN THE EFLAGS REGISTER
//
union EFLAGS {
  ULONG_PTR All;
  struct {
    unsigned CF : 1;          // [0] Carry flag
    unsigned Reserved1 : 1;   // [1]  Always 1
    unsigned PF : 1;          // [2] Parity flag
    unsigned Reserved2 : 1;   // [3] Always 0
    unsigned AF : 1;          // [4] Borrow flag
    unsigned Reserved3 : 1;   // [5] Always 0
    unsigned ZF : 1;          // [6] Zero flag
    unsigned SF : 1;          // [7] Sign flag
    unsigned TF : 1;          // [8] Trap flag
    unsigned IF : 1;          // [9] Interrupt flag
    unsigned DF : 1;          // [10]
    unsigned OF : 1;          // [11]
    unsigned IOPL : 2;        // [12-13] I/O privilege level
    unsigned NT : 1;          // [14] Nested task flag
    unsigned Reserved4 : 1;   // [15] Always 0
    unsigned RF : 1;          // [16] Resume flag
    unsigned VM : 1;          // [17] Virtual 8086 mode
    unsigned AC : 1;          // [18] Alignment check
    unsigned VIF : 1;         // [19] Virtual interrupt flag
    unsigned VIP : 1;         // [20] Virtual interrupt pending
    unsigned ID : 1;          // [21] Identification flag
    unsigned Reserved5 : 10;  // [22-31] Always 0
  } Fields;
};
static_assert(sizeof(EFLAGS) == sizeof(void*), "Size check");

//
// For PUSHAQ
//
struct GP_REGISTERS {
  ULONG_PTR r15;
  ULONG_PTR r14;
  ULONG_PTR r13;
  ULONG_PTR r12;
  ULONG_PTR r11;
  ULONG_PTR r10;
  ULONG_PTR r9;
  ULONG_PTR r8;
  ULONG_PTR rdi;
  ULONG_PTR rsi;
  ULONG_PTR rbp;
  ULONG_PTR rsp;
  ULONG_PTR rbx;
  ULONG_PTR rdx;
  ULONG_PTR rcx;
  ULONG_PTR rax;
};

//
// For the sequence of pushfq, PUSHAQ
//
struct ALL_REGISTERS {
  ULONG_PTR r15;
  ULONG_PTR r14;
  ULONG_PTR r13;
  ULONG_PTR r12;
  ULONG_PTR r11;
  ULONG_PTR r10;
  ULONG_PTR r9;
  ULONG_PTR r8;
  ULONG_PTR rdi;
  ULONG_PTR rsi;
  ULONG_PTR rbp;
  ULONG_PTR rsp;
  ULONG_PTR rbx;
  ULONG_PTR rdx;
  ULONG_PTR rcx;
  ULONG_PTR rax;
  EFLAGS rflags;
};

//
// CONTROL REGISTERS
// CR0
//
union CR0_REG {
  ULONG_PTR All;
  struct {
    unsigned PE : 1;          // [0] Protected Mode Enabled
    unsigned MP : 1;          // [1] Monitor Coprocessor FLAG
    unsigned EM : 1;          // [2] Emulate FLAG
    unsigned TS : 1;          // [3] Task Switched FLAG
    unsigned ET : 1;          // [4] Extension Type FLAG
    unsigned NE : 1;          // [5] Numeric Error
    unsigned Reserved1 : 10;  // [6-15]
    unsigned WP : 1;          // [16] Write Protect
    unsigned Reserved2 : 1;   // [17]
    unsigned AM : 1;          // [18] Alignment Mask
    unsigned Reserved3 : 10;  // [19-28]
    unsigned NW : 1;          // [29] Not Write-Through
    unsigned CD : 1;          // [30] Cache Disable
    unsigned PG : 1;          // [31] Paging Enabled
  } Fields;
};
static_assert(sizeof(CR0_REG) == sizeof(void*), "Size check");

//
// CR4
//
union CR4_REG {
  ULONG_PTR All;
  struct {
    unsigned VME : 1;         // [0] Virtual Mode Extensions
    unsigned PVI : 1;         // [1] Protected-Mode Virtual Interrupts
    unsigned TSD : 1;         // [2] Time Stamp Disable
    unsigned DE : 1;          // [3] Debugging Extensions
    unsigned PSE : 1;         // [4] Page Size Extensions
    unsigned PAE : 1;         // [5] Physical Address Extension
    unsigned MCE : 1;         // [6] Machine-Check Enable
    unsigned PGE : 1;         // [7] Page Global Enable
    unsigned PCE : 1;         // [8] Performance-Monitoring Counter Enable
    unsigned OSFXSR : 1;      // [9] OS Support for FXSAVE/FXRSTOR
    unsigned OSXMMEXCPT : 1;  // [10] OS Support for Unmasked SIMD Exceptions
    unsigned Reserved1 : 2;   // [11-12]
    unsigned VMXE : 1;        // [13] Virtual Machine Extensions Enabled
    unsigned SMXE : 1;        // [14] SMX-Enable Bit
    unsigned Reserved2 : 2;   // [15-16]
    unsigned PCIDE : 1;       // [17] PCID Enable
    unsigned OSXSAVE : 1;     // [18] XSAVE and Processor Extended States-Enable
    unsigned Reserved3 : 1;   // [19]
    unsigned SMEP : 1;  // [20] Supervisor Mode Execution Protection Enable
    unsigned SMAP : 1;  // [21] Supervisor Mode Access Protection Enable
  } Fields;
};
static_assert(sizeof(CR4_REG) == sizeof(void*), "Size check");

//
// IDTR/GDTR
// MEMORY-MANAGEMENT REGISTERS
//
#include <pshpack1.h>
struct IDTR {
  unsigned short Limit;
  ULONG_PTR Address;
};
typedef IDTR GDTR;
static_assert(sizeof(IDTR) == 10, "Size check");
static_assert(sizeof(GDTR) == 10, "Size check");
#include <poppack.h>

//
// Segment Selectors
//
#include <pshpack1.h>
union SEG_SELECTOR {
  unsigned short All;
  struct {
    unsigned short RPL : 2;  // Requested Privilege Level
    unsigned short TI : 1;   // Table Indicator
    unsigned short Index : 13;
  } Fields;
};
static_assert(sizeof(SEG_SELECTOR) == 2, "Size check");
#include <poppack.h>

//
// Segment Desctiptor
//
union SEG_DESCRIPTOR {
  unsigned __int64 All;
  struct {
    unsigned LimitLow : 16;
    unsigned BaseLow : 16;
    unsigned BaseMid : 8;
    unsigned Type : 4;
    unsigned System : 1;
    unsigned DPL : 2;
    unsigned Present : 1;
    unsigned LimitHi : 4;
    unsigned AVL : 1;
    unsigned L : 1;  // 64-bit code segment (IA-32e mode only)
    unsigned DB : 1;
    unsigned Gran : 1;
    unsigned BaseHi : 8;
  } Fields;
};
static_assert(sizeof(SEG_DESCRIPTOR) == 8, "Size check");

struct SEG_DESCRIPTOR64 {
  SEG_DESCRIPTOR Descriptor;
  unsigned __int32 BaseUpper32;
  unsigned __int32 Reserved;
};
static_assert(sizeof(SEG_DESCRIPTOR64) == 16, "Size check");

//
// CPU_FEATURES_ECX
//  CPUID - CPU Identification
//  Figure 3-7.  Feature Information Returned in the ECX Register
//
union CPU_FEATURES_ECX {
  ULONG_PTR All;
  struct {
    unsigned SSE3 : 1;       // SSE3 Extensions
    unsigned PCLMULQDQ : 1;  // Carryless Multiplication
    unsigned DTES64 : 1;     // 64-bit DS Area
    unsigned MONITOR : 1;    // MONITOR/WAIT
    unsigned DS_CPL : 1;     // CPL qualified Debug Store
    unsigned VMX : 1;        // Virtual Machine Technology
    unsigned SMX : 1;        // Safer Mode Extensions
    unsigned EST : 1;        // Enhanced Intel Speedstep Technology
    unsigned TM2 : 1;        // Thermal monitor 2
    unsigned SSSE3 : 1;      // SSSE3 extensions
    unsigned CID : 1;        // L1 context ID
    unsigned Reserved1 : 1;  //
    unsigned FMA : 1;        // Fused Multiply Add
    unsigned CX16 : 1;       // CMPXCHG16B
    unsigned xTPR : 1;       // Update control
    unsigned PDCM : 1;       // Performance/Debug capability MSR
    unsigned Reserved2 : 2;  //
    unsigned DCA : 1;        //
    unsigned SSE4_1 : 1;     //
    unsigned SSE4_2 : 1;     //
    unsigned x2APIC : 1;     //
    unsigned MOVBE : 1;      //
    unsigned POPCNT : 1;     //
    unsigned Reserved3 : 1;  //
    unsigned AES : 1;        //
    unsigned XSAVE : 1;      //
    unsigned OSXSAVE : 1;    //
    unsigned Reserved4 : 2;  //
    unsigned Reserved5 : 1;  //  Always 0
  } Fields;
};
static_assert(sizeof(CPU_FEATURES_ECX) == sizeof(void*), "Size check");

struct HARDWARE_PTE {
  ULONG64 Valid : 1;
  ULONG64 Write : 1;
  ULONG64 Owner : 1;
  ULONG64 WriteThrough : 1;
  ULONG64 CacheDisable : 1;
  ULONG64 Accessed : 1;
  ULONG64 Dirty : 1;
  ULONG64 LargePage : 1;
  ULONG64 Global : 1;
  ULONG64 CopyOnWrite : 1;
  ULONG64 Prototype : 1;
  ULONG64 reserved0 : 1;
  ULONG64 PageFrameNumber : 28;
  ULONG64 reserved1 : 12;
  ULONG64 SoftwareWsIndex : 11;
  ULONG64 NoExecute : 1;
};
static_assert(sizeof(HARDWARE_PTE) == sizeof(void*), "Size check");

// MODEL-SPECIFIC REGISTERS (MSRS)
enum MSR_CODE : unsigned int {
  IA32_FEATURE_CONTROL = 0x03A,
  IA32_SYSENTER_CS = 0x174,
  IA32_SYSENTER_ESP = 0x175,
  IA32_SYSENTER_EIP = 0x176,
  IA32_DEBUGCTL = 0x1D9,
  IA32_VMX_BASIC = 0x480,
  IA32_VMX_PINBASED_CTLS = 0x481,
  IA32_VMX_PROCBASED_CTLS = 0x482,
  IA32_VMX_EXIT_CTLS = 0x483,
  IA32_VMX_ENTRY_CTLS = 0x484,
  IA32_VMX_MISC = 0x485,
  IA32_VMX_CR0_FIXED0 = 0x486,
  IA32_VMX_CR0_FIXED1 = 0x487,
  IA32_VMX_CR4_FIXED0 = 0x488,
  IA32_VMX_CR4_FIXED1 = 0x489,
  IA32_VMX_VMCS_ENUM = 0x48A,
  IA32_VMX_PROCBASED_CTLS2 = 0x48B,
  IA32_VMX_EPT_VPID_CAP = 0x48C,

  IA32_EFER = 0xC0000080,
  IA32_STAR = 0xC0000081,
  IA32_LSTAR = 0xC0000082,
  IA32_FMASK = 0xC0000084,
  IA32_FS_BASE = 0xC0000100,
  IA32_GS_BASE = 0xC0000101,
  IA32_KERNEL_GS_BASE = 0xC0000102,
  IA32_TSC_AUX = 0xC0000103,
};

```

`Sushi/Sushi/log.cpp`:

```cpp
// Copyright (c) 2015, tandasat. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

//
// This module implements logging functions.
//
#include "stdafx.h"
#include "log.h"

////////////////////////////////////////////////////////////////////////////////
//
// macro utilities
//

////////////////////////////////////////////////////////////////////////////////
//
// constant and macro
//

// A size for log buffer in NonPagedPool. Two buffers are allocated with this
// size. Exceeded logs are ignored silently. Make it bigger if a buffered log
// size often reach this size.
static const auto LOGP_BUFFER_SIZE_IN_PAGES = 10ul;

// An actual log buffer size in bytes.
static const auto LOGP_BUFFER_SIZE = PAGE_SIZE * LOGP_BUFFER_SIZE_IN_PAGES;

// A size that is usable for logging. Minus one because the last byte is kept
// for \0.
static const auto LOGP_BUFFER_USABLE_SIZE = LOGP_BUFFER_SIZE - 1;

// An interval to flush buffered log entries into a log file.
static const auto LOGP_AUTO_FLUSH_INTERVAL_MSEC = 50;

static const ULONG LOGP_POOL_TAG_NAME = ' gol';

////////////////////////////////////////////////////////////////////////////////
//
// types
//

struct LogBufferInfo {
  volatile char *LogBufferHead;  // A pointer to a buffer currently used.
                                 // It is either LogBuffer1 or LogBuffer2.
  volatile char *LogBufferTail;  // A pointer to where the next log should
                                 // be written.
  char *LogBuffer1;
  char *LogBuffer2;
  SIZE_T LogMaximumUsage;  // Holds the biggest buffer usage to
                           // determine a necessary buffer size.
  HANDLE LogFileHandle;
  KSPIN_LOCK SpinLock;
  ERESOURCE Resource;
  bool ResourceInitialized;
  volatile bool BufferFlushThreadShouldBeAlive;
  HANDLE BufferFlushThreadHandle;
  wchar_t LogFilePath[MAX_PATH];
};

////////////////////////////////////////////////////////////////////////////////
//
// prototypes
//

EXTERN_C NTKERNELAPI UCHAR *NTAPI
PsGetProcessImageFileName(_In_ PEPROCESS Process);

EXTERN_C static NTSTATUS LogpInitializeBufferInfo(
    _In_ const wchar_t *LogFilePath, _Inout_ LogBufferInfo *Info);

EXTERN_C static NTSTATUS LogpInitializeLogFile(_Inout_ LogBufferInfo *Info);

EXTERN_C static DRIVER_REINITIALIZE LogpReinitializationRoutine;

EXTERN_C static void LogpFinalizeBufferInfo(_In_ LogBufferInfo *Info);

#ifdef _X86_
_Requires_lock_not_held_(*SpinLock) _Acquires_lock_(*SpinLock)
    _IRQL_requires_max_(DISPATCH_LEVEL) _IRQL_saves_
    _IRQL_raises_(DISPATCH_LEVEL) inline KIRQL
    KeAcquireSpinLockRaiseToDpc(_Inout_ PKSPIN_LOCK SpinLock);
#endif

EXTERN_C static NTSTATUS LogpMakePrefix(_In_ ULONG Level,
                                        _In_ const char *FunctionName,
                                        _In_ const char *LogMessage,
                                        _Out_ char *LogBuffer,
                                        _In_ size_t LogBufferLength);

EXTERN_C static const char *LogpFindBaseFunctionName(
    _In_ const char *FunctionName);

EXTERN_C static NTSTATUS LogpPut(_In_ char *Message, _In_ ULONG Attribute);

EXTERN_C static NTSTATUS LogpWriteLogBufferToFile(_Inout_ LogBufferInfo *Info,
                                                  _In_ bool PrintOut);

EXTERN_C static NTSTATUS LogpWriteMessageToFile(_In_ const char *Message,
                                                _In_ const LogBufferInfo &Info);

EXTERN_C static NTSTATUS LogpBufferMessage(_In_ const char *Message,
                                           _Inout_ LogBufferInfo *Info);

EXTERN_C static bool LogpIsLogFileEnabled(_In_ const LogBufferInfo &Info);

EXTERN_C static bool LogpIsLogFileActivated(_In_ const LogBufferInfo &Info);

EXTERN_C static bool LogpIsLogNeeded(_In_ ULONG Level);

EXTERN_C static KSTART_ROUTINE LogpBufferFlushThreadRoutine;

EXTERN_C static NTSTATUS LogpSleep(_In_ LONG Millisecond);

////////////////////////////////////////////////////////////////////////////////
//
// variables
//

static auto g_LogpDebugFlag = LOG_PUT_LEVEL_DISABLE;
static LogBufferInfo g_LogpLogBufferInfo = {};

////////////////////////////////////////////////////////////////////////////////
//
// implementations
//

ALLOC_TEXT(INIT, LogInitialization)
_Use_decl_annotations_ EXTERN_C NTSTATUS
LogInitialization(ULONG Flag, const wchar_t *LogFilePath) {
  PAGED_CODE();

  auto status = STATUS_SUCCESS;

  g_LogpDebugFlag = Flag;

  // Initialize a log file if a log file path is specified.
  bool needReinitialization = false;
  if (LogFilePath) {
    status = LogpInitializeBufferInfo(LogFilePath, &g_LogpLogBufferInfo);
    if (status == STATUS_REINITIALIZATION_NEEDED) {
      needReinitialization = true;
    } else if (!NT_SUCCESS(status)) {
      return status;
    }
  }

  // Test the log.
  status = LOG_INFO("Log has been %sinitialized (Buffer= %p %p, File= %S).",
                    (needReinitialization ? "partially " : ""),
                    g_LogpLogBufferInfo.LogBuffer1,
                    g_LogpLogBufferInfo.LogBuffer2, LogFilePath);
  if (!NT_SUCCESS(status)) {
    goto Fail;
  }
  return (needReinitialization ? STATUS_REINITIALIZATION_NEEDED
                               : STATUS_SUCCESS);

Fail:;
  if (LogFilePath) {
    LogpFinalizeBufferInfo(&g_LogpLogBufferInfo);
  }
  return status;
}

// Initialize a log file related code such as a flushing thread.
ALLOC_TEXT(INIT, LogpInitializeBufferInfo)
_Use_decl_annotations_ EXTERN_C static NTSTATUS LogpInitializeBufferInfo(
    const wchar_t *LogFilePath, LogBufferInfo *Info) {
  NT_ASSERT(LogFilePath);
  NT_ASSERT(Info);

  KeInitializeSpinLock(&Info->SpinLock);

  auto status = RtlStringCchCopyW(
      Info->LogFilePath, RTL_NUMBER_OF_FIELD(LogBufferInfo, LogFilePath),
      LogFilePath);
  if (!NT_SUCCESS(status)) {
    return status;
  }

  status = ExInitializeResourceLite(&Info->Resource);
  if (!NT_SUCCESS(status)) {
    return status;
  }
  Info->ResourceInitialized = true;

  // Allocate two log buffers on NonPagedPool.
  Info->LogBuffer1 = reinterpret_cast<char *>(ExAllocatePoolWithTag(
      NonPagedPoolNx, LOGP_BUFFER_SIZE, LOGP_POOL_TAG_NAME));
  if (!Info->LogBuffer1) {
    LogpFinalizeBufferInfo(Info);
    return STATUS_INSUFFICIENT_RESOURCES;
  }

  Info->LogBuffer2 = reinterpret_cast<char *>(ExAllocatePoolWithTag(
      NonPagedPoolNx, LOGP_BUFFER_SIZE, LOGP_POOL_TAG_NAME));
  if (!Info->LogBuffer2) {
    LogpFinalizeBufferInfo(Info);
    return STATUS_INSUFFICIENT_RESOURCES;
  }

  // Initialize these buffers
  RtlFillMemory(Info->LogBuffer1, LOGP_BUFFER_SIZE, 0xff);  // for debug
  Info->LogBuffer1[0] = '\0';
  Info->LogBuffer1[LOGP_BUFFER_SIZE - 1] = '\0';  // at the end

  RtlFillMemory(Info->LogBuffer2, LOGP_BUFFER_SIZE, 0xff);  // for debug
  Info->LogBuffer2[0] = '\0';
  Info->LogBuffer2[LOGP_BUFFER_SIZE - 1] = '\0';  // at the end

  // Buffer should be used is LogBuffer1, and location should be written logs
  // is the head of the buffer.
  Info->LogBufferHead = Info->LogBuffer1;
  Info->LogBufferTail = Info->LogBuffer1;

  status = LogpInitializeLogFile(Info);
  if (status == STATUS_OBJECT_PATH_NOT_FOUND) {
    LOG_DEBUG("The log file needs to be activated later.");
    status = STATUS_REINITIALIZATION_NEEDED;
  } else if (!NT_SUCCESS(status)) {
    LogpFinalizeBufferInfo(Info);
  }
  return status;
}

ALLOC_TEXT(PAGED, LogpInitializeLogFile)
_Use_decl_annotations_ EXTERN_C static NTSTATUS LogpInitializeLogFile(
    LogBufferInfo *Info) {
  PAGED_CODE();

  if (Info->LogFileHandle) {
    return STATUS_SUCCESS;
  }

  // Initialize a log file
  UNICODE_STRING logFilePathU = {};
  RtlInitUnicodeString(&logFilePathU, Info->LogFilePath);

  OBJECT_ATTRIBUTES oa = {};
  InitializeObjectAttributes(&oa, &logFilePathU,
                             OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, nullptr,
                             nullptr);

  IO_STATUS_BLOCK ioStatus = {};
  auto status = ZwCreateFile(
      &Info->LogFileHandle, FILE_APPEND_DATA | SYNCHRONIZE, &oa, &ioStatus,
      nullptr, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN_IF,
      FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE, nullptr, 0);
  if (!NT_SUCCESS(status)) {
    return status;
  }

  // Initialize a log buffer flush thread.
  Info->BufferFlushThreadShouldBeAlive = true;
  status = PsCreateSystemThread(&Info->BufferFlushThreadHandle, GENERIC_ALL,
                                nullptr, nullptr, nullptr,
                                LogpBufferFlushThreadRoutine, Info);
  if (!NT_SUCCESS(status)) {
    ZwClose(Info->LogFileHandle);
    Info->LogFileHandle = nullptr;
    Info->BufferFlushThreadShouldBeAlive = false;
  }
  return status;
}

ALLOC_TEXT(INIT, LogRegisterReinitialization)
_Use_decl_annotations_ EXTERN_C void LogRegisterReinitialization(
    PDRIVER_OBJECT DriverObject) {
  IoRegisterBootDriverReinitialization(
      DriverObject, LogpReinitializationRoutine, &g_LogpLogBufferInfo);
  LOG_INFO("The log file will be activated later.");
}

ALLOC_TEXT(PAGED, LogpReinitializationRoutine)
_Use_decl_annotations_ EXTERN_C VOID static LogpReinitializationRoutine(
    _DRIVER_OBJECT *DriverObject, PVOID Context, ULONG Count) {
  PAGED_CODE();
  UNREFERENCED_PARAMETER(DriverObject);
  UNREFERENCED_PARAMETER(Count);
  NT_ASSERT(Context);

  DBG_BREAK();

  auto info = reinterpret_cast<LogBufferInfo *>(Context);
  auto status = LogpInitializeLogFile(info);
  NT_ASSERT(NT_SUCCESS(status));
  if (NT_SUCCESS(status)) {
    LOG_INFO("The log file has been activated.");
  }
}

// Terminates the log functions without releasing resources.
ALLOC_TEXT(PAGED, LogIrpShutdownHandler)
_Use_decl_annotations_ EXTERN_C void LogIrpShutdownHandler() {
  PAGED_CODE();

  LOG_DEBUG("Flushing... (Max log usage = %08x bytes)",
            g_LogpLogBufferInfo.LogMaximumUsage);
  LOG_INFO("Bye!");
  g_LogpDebugFlag = LOG_PUT_LEVEL_DISABLE;

  // Wait until the log buffer is emptied.
  auto &info = g_LogpLogBufferInfo;
  while (info.LogBufferHead[0]) {
    LogpSleep(LOGP_AUTO_FLUSH_INTERVAL_MSEC);
  }
}

// Terminates the log functions.
ALLOC_TEXT(PAGED, LogTermination)
_Use_decl_annotations_ EXTERN_C void LogTermination() {
  PAGED_CODE();

  LOG_DEBUG("Finalizing... (Max log usage = %08x bytes)",
            g_LogpLogBufferInfo.LogMaximumUsage);
  LOG_INFO("Bye!");
  g_LogpDebugFlag = LOG_PUT_LEVEL_DISABLE;
  LogpFinalizeBufferInfo(&g_LogpLogBufferInfo);
}

// Terminates a log file related code.
ALLOC_TEXT(PAGED, LogpFinalizeBufferInfo)
_Use_decl_annotations_ EXTERN_C static void LogpFinalizeBufferInfo(
    LogBufferInfo *Info) {
  PAGED_CODE();
  NT_ASSERT(Info);

  // Closing the log buffer flush thread.
  if (Info->BufferFlushThreadHandle) {
    Info->BufferFlushThreadShouldBeAlive = false;
    auto status =
        ZwWaitForSingleObject(Info->BufferFlushThreadHandle, FALSE, nullptr);
    if (!NT_SUCCESS(status)) {
      DBG_BREAK();
    }
    ZwClose(Info->BufferFlushThreadHandle);
    Info->BufferFlushThreadHandle = nullptr;
  }

  // Cleaning up other things.
  if (Info->LogFileHandle) {
    ZwClose(Info->LogFileHandle);
    Info->LogFileHandle = nullptr;
  }
  if (Info->LogBuffer2) {
    ExFreePoolWithTag(Info->LogBuffer2, LOGP_POOL_TAG_NAME);
    Info->LogBuffer2 = nullptr;
  }
  if (Info->LogBuffer1) {
    ExFreePoolWithTag(Info->LogBuffer1, LOGP_POOL_TAG_NAME);
    Info->LogBuffer1 = nullptr;
  }

  if (Info->ResourceInitialized) {
    ExDeleteResourceLite(&Info->Resource);
    Info->ResourceInitialized = false;
  }
}

#ifdef _X86_
_Use_decl_annotations_ KIRQL KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock) {
  KIRQL irql = {};
  KeAcquireSpinLock(SpinLock, &irql);
  return irql;
}
#endif

// Actual implementation of logging API.
_Use_decl_annotations_ EXTERN_C NTSTATUS LogpPrint(ULONG Level,
                                                   const char *FunctionName,
                                                   const char *Format, ...) {
  auto status = STATUS_SUCCESS;

  if (!LogpIsLogNeeded(Level)) {
    return status;
  }

  va_list args;
  va_start(args, Format);
  char logMessage[412];
  status =
      RtlStringCchVPrintfA(logMessage, RTL_NUMBER_OF(logMessage), Format, args);
  va_end(args);
  if (!NT_SUCCESS(status)) {
    return status;
  }
  if (logMessage[0] == '\0') {
    return STATUS_INVALID_PARAMETER;
  }

  const auto pureLevel = Level & 0xf0;
  const auto attribute = Level & 0x0f;

  // A single entry of log should not exceed 512 bytes. See
  // Reading and Filtering Debugging Messages in MSDN for details.
  char message[512];
  static_assert(RTL_NUMBER_OF(message) <= 512,
                "One log message should not exceed 512 bytes.");
  status = LogpMakePrefix(pureLevel, FunctionName, logMessage, message,
                          RTL_NUMBER_OF(message));
  if (!NT_SUCCESS(status)) {
    return status;
  }

  return LogpPut(message, attribute);
}

// Concatenates meta information such as the current time and a process ID to
// user given log message.
_Use_decl_annotations_ EXTERN_C static NTSTATUS LogpMakePrefix(
    ULONG Level, const char *FunctionName, const char *LogMessage,
    char *LogBuffer, size_t LogBufferLength) {
  char const *levelString = nullptr;
  switch (Level) {
    case LOGP_LEVEL_DEBUG:
      levelString = "DBG\t";
      break;
    case LOGP_LEVEL_INFO:
      levelString = "INF\t";
      break;
    case LOGP_LEVEL_WARN:
      levelString = "WRN\t";
      break;
    case LOGP_LEVEL_ERROR:
      levelString = "ERR\t";
      break;
    default:
      return STATUS_INVALID_PARAMETER;
  }

  auto status = STATUS_SUCCESS;

  char timeBuffer[20] = {};
  if ((g_LogpDebugFlag & LOG_OPT_DISABLE_TIME) == 0) {
    // Want the current time.
    TIME_FIELDS timeFields;
    LARGE_INTEGER systemTime, localTime;
    KeQuerySystemTime(&systemTime);
    ExSystemTimeToLocalTime(&systemTime, &localTime);
    RtlTimeToTimeFields(&localTime, &timeFields);

    status = RtlStringCchPrintfA(timeBuffer, RTL_NUMBER_OF(timeBuffer),
                                 "%02u:%02u:%02u.%03u\t", timeFields.Hour,
                                 timeFields.Minute, timeFields.Second,
                                 timeFields.Milliseconds);
    if (!NT_SUCCESS(status)) {
      return status;
    }
  }

  // Want the function name
  char functionNameBuffer[50] = {};
  if ((g_LogpDebugFlag & LOG_OPT_DISABLE_FUNCTION_NAME) == 0) {
    const auto baseFunctionName = LogpFindBaseFunctionName(FunctionName);
    status = RtlStringCchPrintfA(functionNameBuffer,
                                 RTL_NUMBER_OF(functionNameBuffer), "%-40s\t",
                                 baseFunctionName);
    if (!NT_SUCCESS(status)) {
      return status;
    }
  }

  // Want the processor number
  char processroNumber[10] = {};
  if ((g_LogpDebugFlag & LOG_OPT_DISABLE_PROCESSOR_NUMBER) == 0) {
    status =
        RtlStringCchPrintfA(processroNumber, RTL_NUMBER_OF(processroNumber),
                            "#%lu\t", KeGetCurrentProcessorNumber());
    if (!NT_SUCCESS(status)) {
      return status;
    }
  }

  //
  // It uses PsGetProcessId(PsGetCurrentProcess()) instead of
  // PsGetCurrentThreadProcessId() because the later sometimes returns
  // unwanted value, for example:
  //  PID == 4 but its image name != ntoskrnl.exe
  // The author is guessing that it is related to attaching processes but
  // not quite sure. The former way works as expected.
  //
  status = RtlStringCchPrintfA(
      LogBuffer, LogBufferLength, "%s%s%s%5Iu\t%5Iu\t%-15s\t%s%s\r\n",
      timeBuffer, levelString, processroNumber,
      reinterpret_cast<ULONG_PTR>(PsGetProcessId(PsGetCurrentProcess())),
      reinterpret_cast<ULONG_PTR>(PsGetCurrentThreadId()),
      PsGetProcessImageFileName(PsGetCurrentProcess()), functionNameBuffer,
      LogMessage);
  return status;
}

// Returns the function's base name, for example,
// NamespaceName::ClassName::MethodName will be returned as MethodName.
_Use_decl_annotations_ EXTERN_C static const char *LogpFindBaseFunctionName(
    const char *FunctionName) {
  if (!FunctionName) {
    return nullptr;
  }

  auto ptr = FunctionName;
  auto name = FunctionName;
  while (*(ptr++)) {
    if (*ptr == ':') {
      name = ptr + 1;
    }
  }
  return name;
}

// Logs the entry according to Attribute and the thread condition.
_Use_decl_annotations_ EXTERN_C static NTSTATUS LogpPut(char *Message,
                                                        ULONG Attribute) {
  auto status = STATUS_SUCCESS;

  // Log the entry to a file or buffer.
  auto &info = g_LogpLogBufferInfo;
  if (LogpIsLogFileEnabled(info)) {
    // Can it log it to a file now?
    if (((Attribute & LOGP_LEVEL_OPT_SAFE) == 0) &&
        KeGetCurrentIrql() == PASSIVE_LEVEL && !KeAreAllApcsDisabled() &&
        LogpIsLogFileActivated(info)) {
      // Yes, it can. Do it.
      LogpWriteLogBufferToFile(&info, false);
      status = LogpWriteMessageToFile(Message, info);
    } else {
      // No, it cannot. Buffer it.
      status = LogpBufferMessage(Message, &info);
    }
  }

  // Can it safely be printed?
  if ((Attribute & LOGP_LEVEL_OPT_SAFE) == 0 &&
      KeGetCurrentIrql() < CLOCK_LEVEL) {
    const auto locationOfCR = strlen(Message) - 2;
    Message[locationOfCR] = '\n';
    Message[locationOfCR + 1] = '\0';
    DbgPrintEx(DPFLTR_DEFAULT_ID, DPFLTR_ERROR_LEVEL, "%s", Message);
  }
  return status;
}

// Switch the current log buffer and save the contents of old buffer to the log
// file. This function does not flush the log file, so code should call
// LogpWriteMessageToFile() or ZwFlushBuffersFile() later.
_Use_decl_annotations_ EXTERN_C static NTSTATUS LogpWriteLogBufferToFile(
    LogBufferInfo *Info, bool PrintOut) {
  NT_ASSERT(Info);
  NT_ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

  auto status = STATUS_SUCCESS;

  // Enter a critical section and acquire a reader lock for Info in order to
  // write a log file safely.
  ExEnterCriticalRegionAndAcquireResourceExclusive(&Info->Resource);

  // Acquire a spin lock for Info.LogBuffer(s) in order to switch its head
  // safely.
  const auto irql = KeAcquireSpinLockRaiseToDpc(&Info->SpinLock);
  auto oldLogBuffer = const_cast<char *>(Info->LogBufferHead);
  if (oldLogBuffer[0]) {
    Info->LogBufferHead = (oldLogBuffer == Info->LogBuffer1) ? Info->LogBuffer2
                                                             : Info->LogBuffer1;
    Info->LogBufferHead[0] = '\0';
    Info->LogBufferTail = Info->LogBufferHead;
  }
  KeReleaseSpinLock(&Info->SpinLock, irql);

  // Write all log entries in old log buffer.
  IO_STATUS_BLOCK ioStatus = {};
  for (auto currentLogEntry = oldLogBuffer; currentLogEntry[0]; /**/) {
    const auto currentLogEntryLength = strlen(currentLogEntry);
    status =
        ZwWriteFile(Info->LogFileHandle, nullptr, nullptr, nullptr, &ioStatus,
                    currentLogEntry, static_cast<ULONG>(currentLogEntryLength),
                    nullptr, nullptr);
    if (!NT_SUCCESS(status)) {
      // It could happen when you did not register IRP_SHUTDOWN and call
      // LogIrpShutdownHandler() and the system tried to log to a file after
      // a file system was unmounted.
      DBG_BREAK();
    }

    if (PrintOut) {
      const auto locationOfCR = currentLogEntryLength - 2;
      currentLogEntry[locationOfCR] = '\n';
      currentLogEntry[locationOfCR + 1] = '\0';
      DbgPrintEx(DPFLTR_DEFAULT_ID, DPFLTR_ERROR_LEVEL, "%s", currentLogEntry);
    }

    currentLogEntry += currentLogEntryLength + 1;
  }
  oldLogBuffer[0] = '\0';

  ExReleaseResourceAndLeaveCriticalRegion(&Info->Resource);
  return status;
}

// Logs the current log entry to and flush the log file.
_Use_decl_annotations_ EXTERN_C static NTSTATUS LogpWriteMessageToFile(
    const char *Message, const LogBufferInfo &Info) {
  NT_ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

  IO_STATUS_BLOCK ioStatus = {};
  auto status =
      ZwWriteFile(Info.LogFileHandle, nullptr, nullptr, nullptr, &ioStatus,
                  const_cast<char *>(Message),
                  static_cast<ULONG>(strlen(Message)), nullptr, nullptr);
  if (!NT_SUCCESS(status)) {
    // It could happen when you did not register IRP_SHUTDOWN and call
    // LogIrpShutdownHandler() and the system tried to log to a file after
    // a file system was unmounted.
    DBG_BREAK();
  }
  status = ZwFlushBuffersFile(Info.LogFileHandle, &ioStatus);
  return status;
}

// Buffer the log entry to the log buffer.
_Use_decl_annotations_ EXTERN_C static NTSTATUS LogpBufferMessage(
    const char *Message, LogBufferInfo *Info) {
  NT_ASSERT(Info);

  // Acquire a spin lock to add the log safely.
  const auto oldIrql = KeGetCurrentIrql();
  if (oldIrql < DISPATCH_LEVEL) {
    KeAcquireSpinLockRaiseToDpc(&Info->SpinLock);
  } else {
    KeAcquireSpinLockAtDpcLevel(&Info->SpinLock);
  }
  NT_ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

  // Copy the current log to the buffer.
  size_t usedBufferSize = Info->LogBufferTail - Info->LogBufferHead;
  auto status =
      RtlStringCchCopyA(const_cast<char *>(Info->LogBufferTail),
                        LOGP_BUFFER_USABLE_SIZE - usedBufferSize, Message);

  // Update Info.LogMaximumUsage if necessary.
  if (NT_SUCCESS(status)) {
    const auto messageLength = strlen(Message) + 1;
    Info->LogBufferTail += messageLength;
    usedBufferSize += messageLength;
    if (usedBufferSize > Info->LogMaximumUsage) {
      Info->LogMaximumUsage = usedBufferSize;  // Update
    }
  } else {
    Info->LogMaximumUsage = LOGP_BUFFER_SIZE;  // Indicates overflow
  }
  *Info->LogBufferTail = '\0';

  if (oldIrql < DISPATCH_LEVEL) {
    KeReleaseSpinLock(&Info->SpinLock, oldIrql);
  } else {
    KeReleaseSpinLockFromDpcLevel(&Info->SpinLock);
  }
  return status;
}

// Returns true when a log file is enabled.
_Use_decl_annotations_ EXTERN_C static bool LogpIsLogFileEnabled(
    const LogBufferInfo &Info) {
  if (Info.LogBuffer1) {
    NT_ASSERT(Info.LogBuffer2);
    NT_ASSERT(Info.LogBufferHead);
    NT_ASSERT(Info.LogBufferTail);
    return true;
  }
  NT_ASSERT(!Info.LogBuffer2);
  NT_ASSERT(!Info.LogBufferHead);
  NT_ASSERT(!Info.LogBufferTail);
  return false;
}

// Returns true when a log file is opened.
_Use_decl_annotations_ EXTERN_C static bool LogpIsLogFileActivated(
    const LogBufferInfo &Info) {
  if (Info.BufferFlushThreadShouldBeAlive) {
    NT_ASSERT(Info.BufferFlushThreadHandle);
    NT_ASSERT(Info.LogFileHandle);
    return true;
  }
  NT_ASSERT(!Info.BufferFlushThreadHandle);
  NT_ASSERT(!Info.LogFileHandle);
  return false;
}

// Returns true when logging is necessary according to the log's severity and
// a set log level.
_Use_decl_annotations_ EXTERN_C static bool LogpIsLogNeeded(ULONG Level) {
  return !!(g_LogpDebugFlag & Level);
}

// A thread runs as long as info.BufferFlushThreadShouldBeAlive is true and
// flushes a log buffer to a log file every LOGP_AUTO_FLUSH_INTERVAL_MSEC msec.
ALLOC_TEXT(PAGED, LogpBufferFlushThreadRoutine)
_Use_decl_annotations_ EXTERN_C static VOID LogpBufferFlushThreadRoutine(
    void *StartContext) {
  PAGED_CODE();
  auto status = STATUS_SUCCESS;
  auto info = reinterpret_cast<LogBufferInfo *>(StartContext);
  LOG_DEBUG("Log thread started.");

  while (info->BufferFlushThreadShouldBeAlive) {
    NT_ASSERT(LogpIsLogFileActivated(*info));
    LogpSleep(LOGP_AUTO_FLUSH_INTERVAL_MSEC);
    if (info->LogBufferHead[0]) {
      NT_ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
      NT_ASSERT(!KeAreAllApcsDisabled());
      status = LogpWriteLogBufferToFile(info, true);
      // Do not flush the file for overall performance. Even a case of
      // bug check, we should be able to recover logs by looking at both
      // log buffers.
    }
  }
  PsTerminateSystemThread(status);
}

// Sleep the current thread's execution for Millisecond milliseconds.
ALLOC_TEXT(PAGED, LogpSleep)
_Use_decl_annotations_ EXTERN_C static NTSTATUS LogpSleep(LONG Millisecond) {
  PAGED_CODE();

  LARGE_INTEGER interval = {};
  interval.QuadPart = -(10000 * Millisecond);  // msec
  return KeDelayExecutionThread(KernelMode, FALSE, &interval);
}

```

`Sushi/Sushi/log.h`:

```h
// Copyright (c) 2015, tandasat. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

//
// This module declares interfaces to logging functions.
//
#pragma once

////////////////////////////////////////////////////////////////////////////////
//
// macro utilities
//

//
// Does log with respective severities. Here are some ideas to decide which
// level is appropriate:
//  DEBUG: For developers.
//  INFO: For all.
//  WARN: For all. It may require some attention but does not prevent the
//        program working properly.
//  ERROR: For all. It stops the program working properly.
//
#define LOG_DEBUG(format, ...) \
  LogpPrint(LOGP_LEVEL_DEBUG, __FUNCTION__, (format), __VA_ARGS__)
#define LOG_INFO(format, ...) \
  LogpPrint(LOGP_LEVEL_INFO, __FUNCTION__, (format), __VA_ARGS__)
#define LOG_WARN(format, ...) \
  LogpPrint(LOGP_LEVEL_WARN, __FUNCTION__, (format), __VA_ARGS__)
#define LOG_ERROR(format, ...) \
  LogpPrint(LOGP_LEVEL_ERROR, __FUNCTION__, (format), __VA_ARGS__)

// Buffers the log to buffer. It is recommended to use it when a status of
// callee is no predictable in order to avoid bug checks.
#define LOG_DEBUG_SAFE(format, ...)                                         \
  LogpPrint(LOGP_LEVEL_DEBUG | LOGP_LEVEL_OPT_SAFE, __FUNCTION__, (format), \
            __VA_ARGS__)
#define LOG_INFO_SAFE(format, ...)                                         \
  LogpPrint(LOGP_LEVEL_INFO | LOGP_LEVEL_OPT_SAFE, __FUNCTION__, (format), \
            __VA_ARGS__)
#define LOG_WARN_SAFE(format, ...)                                         \
  LogpPrint(LOGP_LEVEL_WARN | LOGP_LEVEL_OPT_SAFE, __FUNCTION__, (format), \
            __VA_ARGS__)
#define LOG_ERROR_SAFE(format, ...)                                         \
  LogpPrint(LOGP_LEVEL_ERROR | LOGP_LEVEL_OPT_SAFE, __FUNCTION__, (format), \
            __VA_ARGS__)

////////////////////////////////////////////////////////////////////////////////
//
// constants and macros
//

// (internal) Save this log to buffer and not try to write to a log file.
static const auto LOGP_LEVEL_OPT_SAFE = 0x1ul;

// (internal) Log levels.
static const auto LOGP_LEVEL_DEBUG = 0x10ul;
static const auto LOGP_LEVEL_INFO = 0x20ul;
static const auto LOGP_LEVEL_WARN = 0x40ul;
static const auto LOGP_LEVEL_ERROR = 0x80ul;

// For LogInitialization(). Specifies what level of verbosity is needed.
static const auto LOG_PUT_LEVEL_DEBUG =
    LOGP_LEVEL_ERROR | LOGP_LEVEL_WARN | LOGP_LEVEL_INFO | LOGP_LEVEL_DEBUG;
static const auto LOG_PUT_LEVEL_INFO =
    LOGP_LEVEL_ERROR | LOGP_LEVEL_WARN | LOGP_LEVEL_INFO;
static const auto LOG_PUT_LEVEL_WARN = LOGP_LEVEL_ERROR | LOGP_LEVEL_WARN;
static const auto LOG_PUT_LEVEL_ERROR = LOGP_LEVEL_ERROR;
static const auto LOG_PUT_LEVEL_DISABLE = 0x00ul;

// For LogInitialization(). Does not log a current time.
static const auto LOG_OPT_DISABLE_TIME = 0x100ul;

// For LogInitialization(). Does not log a current function name.
static const auto LOG_OPT_DISABLE_FUNCTION_NAME = 0x200ul;

// For LogInitialization(). Does not log a current processor number.
static const auto LOG_OPT_DISABLE_PROCESSOR_NUMBER = 0x400ul;

////////////////////////////////////////////////////////////////////////////////
//
// types
//

////////////////////////////////////////////////////////////////////////////////
//
// prototypes
//

// Initialize the log system.
// Returns STATUS_SUCCESS when it succeeded, or returns
// STATUS_REINITIALIZATION_NEEDED when re-initialization with
// LogRegisterReinitialization() is required.
EXTERN_C NTSTATUS LogInitialization(_In_ ULONG Flag,
                                    _In_opt_ const wchar_t *FilePath);

// Register re-initialization. DriverEntry() must return STATUS_SUCCESS when
// this function is called.
EXTERN_C void LogRegisterReinitialization(_In_ PDRIVER_OBJECT DriverObject);

// Terminates the log system quickly. It should be called from an
// IRP_MJ_SHUTDOWN handler.
EXTERN_C void LogIrpShutdownHandler();

// Terminates the log system. It should be called from a DriverUnload routine.
EXTERN_C void LogTermination();

// (internal) Use LOG_*() macros instead.
EXTERN_C NTSTATUS LogpPrint(_In_ ULONG Level, _In_ const char *FunctionName,
                            _In_ const char *Format, ...);

////////////////////////////////////////////////////////////////////////////////
//
// variables
//

////////////////////////////////////////////////////////////////////////////////
//
// implementations
//

```

`Sushi/Sushi/misc.cpp`:

```cpp
// Copyright (c) 2015, tandasat. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

//
// This module defines misc functions.
//
#include "stdafx.h"
#include "misc.h"
#include "log.h"
#include "asm.h"
#include "util.h"

////////////////////////////////////////////////////////////////////////////////
//
// macro utilities
//

////////////////////////////////////////////////////////////////////////////////
//
// constants and macros
//

////////////////////////////////////////////////////////////////////////////////
//
// types
//

struct PgContext {
  UCHAR Reserved1[0xc8];
  ULONG_PTR ExAcquireResourceSharedLite_8;  // + 0xc8
  ULONG_PTR Reserved2;
  ULONG_PTR ExAcquireResourceSharedLite_10;  // + 0xd8 for Windows 10
};

////////////////////////////////////////////////////////////////////////////////
//
// prototypes
//

EXTERN_C PVOID NTAPI RtlPcToFileHeader(_In_ PVOID PcValue,
                                       _Out_ PVOID *BaseOfImage);

EXTERN_C static PER_PROCESSOR_DATA *MiscpVmCallUnload();

DECLSPEC_NORETURN EXTERN_C void MiscWaitForever(_In_ const ALL_REGISTERS *Regs,
                                                _In_ ULONG_PTR Rsp);

EXTERN_C void MiscDumpGpRegisters(_In_ const ALL_REGISTERS *Regs,
                                  _In_ ULONG_PTR Rsp);

EXTERN_C static bool MiscpIsPgContext(_In_ ULONG_PTR Address);

////////////////////////////////////////////////////////////////////////////////
//
// variables
//

// An address of ExAcquireResourceSharedLite. Used to verify the if the address
// is a PatchGuard context.
static ULONG_PTR g_MiscpExAcquireResourceSharedLite = 0;

// Ranges of modules which very frequently causes VM-exit. Used as a quick
// filter to avoid calling RtlPcToFileHeader() too often.
static ULONG_PTR g_MiscpNtosBase = 0;
static ULONG_PTR g_MiscpNtosEnd = 0;
static ULONG_PTR g_MiscpHalBase = 0;
static ULONG_PTR g_MiscpHalEnd = 0;

////////////////////////////////////////////////////////////////////////////////
//
// implementations
//

// Initialize misc functions
ALLOC_TEXT(INIT, MiscInitializeRuntimeInfo)
_Use_decl_annotations_ EXTERN_C NTSTATUS MiscInitializeRuntimeInfo() {
  // Solve an address of ExAcquireResourceSharedLite. Note that it is not going
  // to be a real address when DriverVerifier is active in the system.
  UNICODE_STRING procName = RTL_CONSTANT_STRING(L"ExAcquireResourceSharedLite");
  g_MiscpExAcquireResourceSharedLite =
      reinterpret_cast<ULONG_PTR>(MmGetSystemRoutineAddress(&procName));

  // Get a list of system modules currently loaded
  auto status = AuxKlibInitialize();
  if (!NT_SUCCESS(status)) {
    return status;
  }

  ULONG bufferSize = 0;
  status = AuxKlibQueryModuleInformation(
      &bufferSize, sizeof(AUX_MODULE_EXTENDED_INFO), nullptr);
  if (!NT_SUCCESS(status) || !bufferSize) {
    return status;
  }

  bufferSize += (sizeof(AUX_MODULE_EXTENDED_INFO) * 2);
  auto modules = reinterpret_cast<AUX_MODULE_EXTENDED_INFO *>(
      ExAllocatePoolWithTag(PagedPool, bufferSize, SUSHI_POOL_TAG_NAME));
  if (!modules) {
    return STATUS_MEMORY_NOT_ALLOCATED;
  }

  status = AuxKlibQueryModuleInformation(
      &bufferSize, sizeof(AUX_MODULE_EXTENDED_INFO), modules);
  if (!NT_SUCCESS(status)) {
    goto End;
  }

  // Enumerate the list and get ranges of some modules
  status = STATUS_UNSUCCESSFUL;
  const auto numberOfModules = bufferSize / sizeof(AUX_MODULE_EXTENDED_INFO);
  for (auto i = 0; i < numberOfModules; ++i) {
    const auto currentModule = &modules[i];
    const auto imageName = reinterpret_cast<const char *>(
        currentModule->FullPathName + currentModule->FileNameOffset);
    const auto imageBase =
        reinterpret_cast<ULONG_PTR>(currentModule->BasicInfo.ImageBase);
    LOG_DEBUG("%p - %p : %s", imageBase, imageBase + currentModule->ImageSize,
              imageName);
    if (_stricmp(imageName, "ntoskrnl.exe") == 0) {
      g_MiscpNtosBase = imageBase;
      g_MiscpNtosEnd = imageBase + currentModule->ImageSize;
    } else if (_stricmp(imageName, "hal.dll") == 0) {
      g_MiscpHalBase = imageBase;
      g_MiscpHalEnd = imageBase + currentModule->ImageSize;
    }
    if (g_MiscpNtosBase && g_MiscpHalBase) {
      status = STATUS_SUCCESS;
      break;
    }
  }

End:;
  ExFreePoolWithTag(modules, SUSHI_POOL_TAG_NAME);
  return status;
}

// Allocates continuous physical memory
_Use_decl_annotations_ EXTERN_C void *MiscAllocateContiguousMemory(
    SIZE_T NumberOfBytes) {
  PHYSICAL_ADDRESS highestAcceptableAddress = {};
  highestAcceptableAddress.QuadPart = -1;
  return MmAllocateContiguousMemory(NumberOfBytes, highestAcceptableAddress);
}

// Frees an address allocated by MiscAllocateContiguousMemory()
_Use_decl_annotations_ EXTERN_C void MiscFreeContiguousMemory(
    void *BaseAddress) {
  MmFreeContiguousMemory(BaseAddress);
}

// Stops virtualization through a hypercall and frees all related memory
_Use_decl_annotations_ EXTERN_C NTSTATUS MiscStopVM(void *Context) {
  UNREFERENCED_PARAMETER(Context);

  LOG_INFO("Terminating VMX for the processor %d",
           KeGetCurrentProcessorNumber());

  // Stop virtualization and get an address of the management structure
  auto ProcessorData = MiscpVmCallUnload();
  if (!ProcessorData) {
    return STATUS_UNSUCCESSFUL;
  }

  // Frees all related memory
  if (ProcessorData->MsrBitmap) {
    MiscFreeContiguousMemory(ProcessorData->MsrBitmap);
  }
  if (ProcessorData->VmmStackTop) {
    MiscFreeContiguousMemory(ProcessorData->VmmStackTop);
  }
  if (ProcessorData->VmcsRegion) {
    MiscFreeContiguousMemory(ProcessorData->VmcsRegion);
  }
  if (ProcessorData->VmxonRegion) {
    MiscFreeContiguousMemory(ProcessorData->VmxonRegion);
  }
  if (ProcessorData) {
    ExFreePoolWithTag(ProcessorData, SUSHI_POOL_TAG_NAME);
  }

  return STATUS_SUCCESS;
}

// Stops virtualization through a hypercall and returns an address of the
// management structure
_Use_decl_annotations_ EXTERN_C static PER_PROCESSOR_DATA *MiscpVmCallUnload() {
  PER_PROCESSOR_DATA *context = nullptr;
  auto status = MiscVmCall(SUSHI_BACKDOOR_CODE, &context);
  if (!NT_SUCCESS(status)) {
    return nullptr;
  }
  return context;
}

// Executes VMCALL
_Use_decl_annotations_ EXTERN_C NTSTATUS MiscVmCall(ULONG_PTR HyperCallNumber,
                                                    void *Context) {
  __try {
    const auto vmxStatus = AsmVmxCall(HyperCallNumber, Context);
    return (vmxStatus == VMX_OK) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
  } __except (EXCEPTION_EXECUTE_HANDLER) {
    const auto status = GetExceptionCode();
    DBG_BREAK();
    return status;
  }
}

// Checks if the Address is out of any kernel modules. Beware that this is not
// comprehensive check to detect all possible patterns of the interesting things
//
_Use_decl_annotations_ EXTERN_C bool MiscIsInterestingAddress(
    ULONG_PTR Address) {
  if (Address >= reinterpret_cast<ULONG_PTR>(MmSystemRangeStart) &&
      !UtilIsInBounds(Address, g_MiscpNtosBase, g_MiscpNtosEnd) &&
      !UtilIsInBounds(Address, g_MiscpHalBase, g_MiscpHalEnd)) {
    void *base = nullptr;
    if (!RtlPcToFileHeader(reinterpret_cast<void *>(Address), &base)) {
      return true;
    }
  }
  return false;
}

// Wait forever in order to disable this PatchGuard context.
// Note that this function should not be executed from the first validation
// routine that runs as DPC. Since DPC routine cannot lower IRQL, execution of
// this routine results in bug check.
_Use_decl_annotations_ EXTERN_C void MiscWaitForever(const ALL_REGISTERS *Regs,
                                                     ULONG_PTR Rsp) {
  UNREFERENCED_PARAMETER(Regs);
  UNREFERENCED_PARAMETER(Rsp);

  LOG_INFO_SAFE(
      "I got tired of protecting your system and want to sleep. Bye.");
  DBG_BREAK();

#pragma warning(push)
#pragma warning(disable : 28138)
  // The constant argument should instead be variable	The constant argument
  // '0' should instead be variable.
  KeLowerIrql(PASSIVE_LEVEL);
#pragma warning(push)

  // Wait until this thread ends == never returns
  auto status = KeWaitForSingleObject(PsGetCurrentThread(), Executive,
                                      KernelMode, FALSE, nullptr);

  LOG_ERROR_SAFE("Oops!! %p", status);
  DBG_BREAK();
}

_Use_decl_annotations_ EXTERN_C void MiscDumpGpRegisters(
    const ALL_REGISTERS *Regs, ULONG_PTR Rsp) {
  auto currentIrql = KeGetCurrentIrql();
  if (currentIrql < DISPATCH_LEVEL) {
    KeRaiseIrqlToDpcLevel();
  }

  LOG_DEBUG_SAFE(
      "%p "
      "rax= %p rbx= %p rcx= %p "
      "rdx= %p rsi= %p rdi= %p "
      "rsp= %p rbp= %p "
      " r8= %p  r9= %p r10= %p "
      "r11= %p r12= %p r13= %p "
      "r14= %p r15= %p efl= %08x",
      _ReturnAddress(), Regs->rax, Regs->rbx, Regs->rcx, Regs->rdx, Regs->rsi,
      Regs->rdi, Rsp, Regs->rbp, Regs->r8, Regs->r9, Regs->r10, Regs->r11,
      Regs->r12, Regs->r13, Regs->r14, Regs->r15, Regs->rflags.All);

  if (currentIrql < DISPATCH_LEVEL) {
    KeLowerIrql(currentIrql);
  }
}

// Checks if the context have a reference to the PatchGuard context.
_Use_decl_annotations_ EXTERN_C bool MiscIsInterestingContext(
    const GP_REGISTERS *Regs) {
  if (MiscpIsPgContext(Regs->rax) || MiscpIsPgContext(Regs->rbx) ||
      MiscpIsPgContext(Regs->rcx) || MiscpIsPgContext(Regs->rdx) ||
      MiscpIsPgContext(Regs->r9) || MiscpIsPgContext(Regs->r10) ||
      MiscpIsPgContext(Regs->r11) || MiscpIsPgContext(Regs->r12) ||
      MiscpIsPgContext(Regs->r13) || MiscpIsPgContext(Regs->r14) ||
      MiscpIsPgContext(Regs->r15) || MiscpIsPgContext(Regs->rbp) ||
      MiscpIsPgContext(Regs->rdi) || MiscpIsPgContext(Regs->rsi)) {
    return true;
  }
  return false;
}

// Checks if the Address is the PatchGuard context
_Use_decl_annotations_ EXTERN_C static bool MiscpIsPgContext(
    ULONG_PTR Address) {
  const auto pExAcquireResourceSharedLite = g_MiscpExAcquireResourceSharedLite;
  const auto pgContext = reinterpret_cast<PgContext *>(Address);
  if ((UtilIsAccessibleAddress(&pgContext->ExAcquireResourceSharedLite_8) &&
       pgContext->ExAcquireResourceSharedLite_8 ==
           pExAcquireResourceSharedLite) ||
      (UtilIsAccessibleAddress(&pgContext->ExAcquireResourceSharedLite_10) &&
       pgContext->ExAcquireResourceSharedLite_10 ==
           pExAcquireResourceSharedLite)) {
    LOG_INFO_SAFE("PatchGuard Context = %p", Address);
    return true;
  }

  return false;
}

```

`Sushi/Sushi/misc.h`:

```h
// Copyright (c) 2015, tandasat. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

//
// This module declares interfaces to misc functions.
//
#pragma once

////////////////////////////////////////////////////////////////////////////////
//
// macro utilities
//

////////////////////////////////////////////////////////////////////////////////
//
// constants and macros
//

////////////////////////////////////////////////////////////////////////////////
//
// types
//

////////////////////////////////////////////////////////////////////////////////
//
// prototypes
//

EXTERN_C NTSTATUS MiscInitializeRuntimeInfo();

EXTERN_C void *MiscAllocateContiguousMemory(_In_ SIZE_T NumberOfBytes);

EXTERN_C void MiscFreeContiguousMemory(_In_ void *BaseAddress);

EXTERN_C NTSTATUS MiscVmCall(_In_ ULONG_PTR HyperCallNumber,
                             _In_opt_ void *Context);

EXTERN_C NTSTATUS MiscStopVM(_In_opt_ void *Context);

EXTERN_C bool MiscIsInterestingAddress(_In_ ULONG_PTR Address);

EXTERN_C bool MiscIsInterestingContext(_In_ const struct GP_REGISTERS *Regs);

////////////////////////////////////////////////////////////////////////////////
//
// variables
//

////////////////////////////////////////////////////////////////////////////////
//
// implementations
//

```

`Sushi/Sushi/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// sushi.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`Sushi/Sushi/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

extern "C" {
#pragma warning(push, 0)
#include <fltKernel.h>
#include <Wdmsec.h>
#include <windef.h>
#include <ntimage.h>
#include <stdarg.h>
#define NTSTRSAFE_NO_CB_FUNCTIONS
#include <ntstrsafe.h>
#include <ntddstor.h>
#include <mountdev.h>
#include <ntddvol.h>
#include <intrin.h>
#include <Aux_klib.h>
#pragma warning(pop)
}

////////////////////////////////////////////////////////////////////////////////
//
// macro utilities
//

// Specifies where the code should be located
#ifdef ALLOC_PRAGMA
#define ALLOC_TEXT(Section, Name) __pragma(alloc_text(Section, Name))
#else
#define ALLOC_TEXT(Section, Name)
#endif

// Break point that works only when a debugger is enabled
#ifndef DBG_BREAK
#define DBG_BREAK()              \
  if (KD_DEBUGGER_NOT_PRESENT) { \
  } else {                       \
    __debugbreak();              \
  }                              \
  reinterpret_cast<void*>(0)
#endif

////////////////////////////////////////////////////////////////////////////////
//
// constants and macros
//

static const ULONG SUSHI_POOL_TAG_NAME = 'hsus';
static const auto SUSHI_BACKDOOR_CODE = 0x11519;

////////////////////////////////////////////////////////////////////////////////
//
// types
//

struct VMCS;

struct PER_PROCESSOR_DATA {
  void* VmmStackTop;
  VMCS* VmxonRegion;
  VMCS* VmcsRegion;
  void* MsrBitmap;
};

////////////////////////////////////////////////////////////////////////////////
//
// prototypes
//

////////////////////////////////////////////////////////////////////////////////
//
// variables
//

////////////////////////////////////////////////////////////////////////////////
//
// implementations
//

```

`Sushi/Sushi/sushi.cpp`:

```cpp
// Copyright (c) 2015, tandasat. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

//
// This module implements an entry point of the driver.
//
#include "stdafx.h"
#include "log.h"
#include "vminit.h"
#include "misc.h"
#include "util.h"

////////////////////////////////////////////////////////////////////////////////
//
// macro utilities
//

////////////////////////////////////////////////////////////////////////////////
//
// constants and macros
//

static const wchar_t SUSHIP_LOG_FILE_PATH[] = L"\\SystemRoot\\Sushi.log";

#if DBG
static const auto SUSHIP_LOG_LEVEL =
    LOG_PUT_LEVEL_DEBUG | LOG_OPT_DISABLE_FUNCTION_NAME;
#else
static const auto SUSHIP_LOG_LEVEL =
    LOG_PUT_LEVEL_INFO | LOG_OPT_DISABLE_FUNCTION_NAME;
#endif

////////////////////////////////////////////////////////////////////////////////
//
// types
//

////////////////////////////////////////////////////////////////////////////////
//
// prototypes
//

EXTERN_C DRIVER_INITIALIZE DriverEntry;

EXTERN_C static DRIVER_UNLOAD SushipDriverUnload;

EXTERN_C static KSTART_ROUTINE SushipVmxOffThreadRoutine;

////////////////////////////////////////////////////////////////////////////////
//
// variables
//

////////////////////////////////////////////////////////////////////////////////
//
// implementations
//

// Entry point
ALLOC_TEXT(INIT, DriverEntry)
_Use_decl_annotations_ EXTERN_C NTSTATUS
DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) {
  UNREFERENCED_PARAMETER(RegistryPath);
  PAGED_CODE();

  auto status = STATUS_UNSUCCESSFUL;
  DriverObject->DriverUnload = SushipDriverUnload;

  DBG_BREAK();

  // Initialize log functions
  bool needReinitialization = false;
  status = LogInitialization(SUSHIP_LOG_LEVEL, SUSHIP_LOG_FILE_PATH);
  if (status == STATUS_REINITIALIZATION_NEEDED) {
    needReinitialization = true;
  } else if (!NT_SUCCESS(status)) {
    return status;
  }

  // Initialize misc functions
  status = MiscInitializeRuntimeInfo();
  if (!NT_SUCCESS(status)) {
    LogTermination();
    return status;
  }

  // Virtualize all processors
  status = UtilForEachProcessor(VminitStartVM, nullptr);
  if (!NT_SUCCESS(status)) {
    UtilForEachProcessor(MiscStopVM, nullptr);
    LogTermination();
    return status;
  }

  // Register re-initialization for the log functions if needed
  if (needReinitialization) {
    LogRegisterReinitialization(DriverObject);
  }

  LOG_INFO("The VMM has been installed.");
  return status;
}

// Unload handler
ALLOC_TEXT(PAGED, SushipDriverUnload)
_Use_decl_annotations_ EXTERN_C static void SushipDriverUnload(
    PDRIVER_OBJECT DriverObject) {
  UNREFERENCED_PARAMETER(DriverObject);
  PAGED_CODE();

  DBG_BREAK();

  // Create a thread dedicated to de-virtualizing processors. For some reasons,
  // de-virtualizing processors from this thread makes the system stop
  // processing all timer related events and functioning properly.
  HANDLE threadHandle = nullptr;
  auto status =
      PsCreateSystemThread(&threadHandle, GENERIC_ALL, nullptr, nullptr,
                           nullptr, SushipVmxOffThreadRoutine, nullptr);
  if (NT_SUCCESS(status)) {
    // Wait until the thread ends its work.
    status = ZwWaitForSingleObject(threadHandle, FALSE, nullptr);
    status = ZwClose(threadHandle);
  } else {
    DBG_BREAK();
  }

  // Terminates the log functions
  LogTermination();
}

// De-virtualizing all processors
ALLOC_TEXT(PAGED, SushipVmxOffThreadRoutine)
_Use_decl_annotations_ EXTERN_C static VOID SushipVmxOffThreadRoutine(
    void* StartContext) {
  UNREFERENCED_PARAMETER(StartContext);
  PAGED_CODE();

  LOG_INFO("Uninstalling VMM.");
  auto status = UtilForEachProcessor(MiscStopVM, nullptr);
  LOG_INFO("The VMM has been uninstalled.");

  PsTerminateSystemThread(status);
}

```

`Sushi/Sushi/util.cpp`:

```cpp
// Copyright (c) 2015, tandasat. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

//
// This module defines utility functions.
//
#include "stdafx.h"
#include "util.h"

////////////////////////////////////////////////////////////////////////////////
//
// macro utilities
//

////////////////////////////////////////////////////////////////////////////////
//
// constants and macros
//

// Masks to select bits used for getting PTEs.
#ifdef _AMD64_
static const auto UTILP_PXI_MASK = 0x1ff;
static const auto UTILP_PPI_MASK = 0x3ffff;
static const auto UTILP_PDI_MASK = 0x7ffffff;
static const auto UTILP_PTI_MASK = 0xfffffffff;
#else
static const auto UTILP_PDI_MASK = 0xffffffff;
static const auto UTILP_PTI_MASK = 0xffffffff;
#endif

#if defined(_AMD64_) && !defined(PXE_BASE)
#define PXE_BASE 0xFFFFF6FB7DBED000UI64
#define PXE_SELFMAP 0xFFFFF6FB7DBEDF68UI64
#define PPE_BASE 0xFFFFF6FB7DA00000UI64
#define PDE_BASE 0xFFFFF6FB40000000UI64
#define PTE_BASE 0xFFFFF68000000000UI64

#define PXE_TOP 0xFFFFF6FB7DBEDFFFUI64
#define PPE_TOP 0xFFFFF6FB7DBFFFFFUI64
#define PDE_TOP 0xFFFFF6FB7FFFFFFFUI64
#define PTE_TOP 0xFFFFF6FFFFFFFFFFUI64

#define PDE_KTBASE_AMD64 PPE_BASE

#define PTI_SHIFT 12
#define PDI_SHIFT 21
#define PPI_SHIFT 30
#define PXI_SHIFT 39
#endif

////////////////////////////////////////////////////////////////////////////////
//
// types
//

struct WINDOWS_RT_PTE {
  ULONG NoExecute : 1;
  ULONG Present : 1;
  ULONG Unknown1 : 5;
  ULONG Writable : 1;
  ULONG Unknown2 : 4;
  ULONG PageFrameNumber : 20;
};
static_assert(sizeof(WINDOWS_RT_PTE) == 4, "Size check");

struct WINDOWS_AMD64_PTE {
  ULONG64 Present : 1;
  ULONG64 Write : 1;
  ULONG64 Owner : 1;
  ULONG64 WriteThrough : 1;
  ULONG64 CacheDisable : 1;
  ULONG64 Accessed : 1;
  ULONG64 Dirty : 1;
  ULONG64 LargePage : 1;
  ULONG64 Global : 1;
  ULONG64 CopyOnWrite : 1;
  ULONG64 Prototype : 1;
  ULONG64 reserved0 : 1;
  ULONG64 PageFrameNumber : 28;
  ULONG64 reserved1 : 12;
  ULONG64 SoftwareWsIndex : 11;
  ULONG64 NoExecute : 1;
};
static_assert(sizeof(WINDOWS_AMD64_PTE) == 8, "Size check");

#ifdef _AMD64_
using HARDWARE_PTE = WINDOWS_AMD64_PTE;
#else
using HARDWARE_PTE = WINDOWS_RT_PTE;
#endif

////////////////////////////////////////////////////////////////////////////////
//
// prototypes
//

EXTERN_C void NTAPI KeSweepIcacheRange(_In_ BOOLEAN AllProcessors,
                                       _In_ PVOID BaseAddress,
                                       _In_ ULONG Length);

#ifdef _AMD64_
EXTERN_C static HARDWARE_PTE *UtilpAddressToPxe(_In_ const void *Address);

EXTERN_C static HARDWARE_PTE *UtilpAddressToPpe(_In_ const void *Address);
#endif

EXTERN_C static HARDWARE_PTE *UtilpAddressToPde(_In_ const void *Address);

EXTERN_C static HARDWARE_PTE *UtilpAddressToPte(_In_ const void *Address);

////////////////////////////////////////////////////////////////////////////////
//
// variables
//

////////////////////////////////////////////////////////////////////////////////
//
// implementations
//

// Execute a given callback routine on all processors in DPC_LEVEL. Returns
// STATUS_SUCCESS when all callback returned STATUS_SUCCESS as well. When
// one of callbacks returns anything but STATUS_SUCCESS, this function stops
// to call remaining callbacks and returns the value.
_Use_decl_annotations_ EXTERN_C NTSTATUS
UtilForEachProcessor(NTSTATUS (*CallbackRoutine)(void *), void *Context) {
  const auto numberOfProcessors = KeQueryActiveProcessorCount(nullptr);
  for (ULONG processorNumber = 0; processorNumber < numberOfProcessors;
       processorNumber++) {
    // Switch the current processor
    const auto oldAffinity = KeSetSystemAffinityThreadEx(
        static_cast<KAFFINITY>(1ull << processorNumber));
    const auto oldIrql = KeRaiseIrqlToDpcLevel();

    // Execute callback
    const auto status = CallbackRoutine(Context);

    KeLowerIrql(oldIrql);
    KeRevertToUserAffinityThreadEx(oldAffinity);
    if (!NT_SUCCESS(status)) {
      return status;
    }
  }
  return STATUS_SUCCESS;
}

// Sleep the current thread's execution for Millisecond milli-seconds.
ALLOC_TEXT(PAGED, UtilSleep)
_Use_decl_annotations_ EXTERN_C NTSTATUS UtilSleep(LONG Millisecond) {
  PAGED_CODE();

  LARGE_INTEGER interval = {};
  interval.QuadPart = -(10000 * Millisecond);  // msec
  return KeDelayExecutionThread(KernelMode, FALSE, &interval);
}

// memmem().
_Use_decl_annotations_ EXTERN_C void *UtilMemMem(const void *SearchBase,
                                                 SIZE_T SearchSize,
                                                 const void *Pattern,
                                                 SIZE_T PatternSize) {
  if (PatternSize > SearchSize) {
    return nullptr;
  }
  auto searchBase = static_cast<const char *>(SearchBase);
  for (size_t i = 0; i <= SearchSize - PatternSize; i++) {
    if (!memcmp(Pattern, &searchBase[i], PatternSize)) {
      return const_cast<char *>(&searchBase[i]);
    }
  }
  return nullptr;
}

// Invalidates an instruction cache for the specified region.
_Use_decl_annotations_ EXTERN_C void UtilInvalidateInstructionCache(
    void *BaseAddress, SIZE_T Length) {
#ifdef _AMD64_
  UNREFERENCED_PARAMETER(BaseAddress);
  UNREFERENCED_PARAMETER(Length);
  __faststorefence();
#else
  KeSweepIcacheRange(TRUE, BaseAddress, Length);
#endif
}

// Does memcpy safely even if Destination is a read only region.
_Use_decl_annotations_ EXTERN_C NTSTATUS UtilForceMemCpy(void *Destination,
                                                         const void *Source,
                                                         SIZE_T Length) {
  auto mdl = IoAllocateMdl(Destination, static_cast<ULONG>(Length), FALSE,
                           FALSE, nullptr);
  if (!mdl) {
    return STATUS_INSUFFICIENT_RESOURCES;
  }
  MmBuildMdlForNonPagedPool(mdl);

#pragma warning(push)
#pragma warning(disable : 28145)
  //
  // Following MmMapLockedPagesSpecifyCache() call causes bug check in case
  // you are using Driver Verifier. The reason is explained as follows:
  //
  // A driver must not try to create more than one system-address-space
  // mapping for an MDL. Additionally, because an MDL that is built by the
  // MmBuildMdlForNonPagedPool routine is already mapped to the system
  // address space, a driver must not try to map this MDL into the system
  // address space again by using the MmMapLockedPagesSpecifyCache routine.
  // -- MSDN
  //
  // This flag modification hacks Driver Verifier's check and prevent leading
  // bug check.
  //
  mdl->MdlFlags &= ~MDL_SOURCE_IS_NONPAGED_POOL;
  mdl->MdlFlags |= MDL_PAGES_LOCKED;
#pragma warning(pop)

  auto writableDest = MmMapLockedPagesSpecifyCache(
      mdl, KernelMode, MmCached, nullptr, FALSE, NormalPagePriority);
  if (!writableDest) {
    IoFreeMdl(mdl);
    return STATUS_INSUFFICIENT_RESOURCES;
  }
  memcpy(writableDest, Source, Length);
  MmUnmapLockedPages(writableDest, mdl);
  IoFreeMdl(mdl);
  return STATUS_SUCCESS;
}

// Return true if the given address is accessible. It does not prevent a race
// condition.
_Use_decl_annotations_ EXTERN_C bool UtilIsAccessibleAddress(
    const void *Address) {
#ifdef _AMD64_
  const auto pxe = UtilpAddressToPxe(Address);
  const auto ppe = UtilpAddressToPpe(Address);
  const auto pde = UtilpAddressToPde(Address);
  const auto pte = UtilpAddressToPte(Address);
  if ((!pxe->Present) || (!ppe->Present) || (!pde->Present) ||
      (!pde->LargePage && (!pte || !pte->Present))) {
    return false;
  }
#else
  const auto pde = UtilpAddressToPde(Address);
  const auto pte = UtilpAddressToPte(Address);
  if (!pde->Present || !pde->PageFrameNumber || !pte->Present ||
      !pte->PageFrameNumber) {
    return false;
  }
#endif
  return true;
}

/*
Virtual Address Interpretation For Handling PTEs

-- On x64
Sign extension                     16 bits
Page map level 4 selector           9 bits
Page directory pointer selector     9 bits
Page directory selector             9 bits
Page table selector                 9 bits
Byte within page                   12 bits
11111111 11111111 11111000 10000000 00000011 01010011 00001010 00011000
^^^^^^^^ ^^^^^^^^ ~~~~~~~~ ~^^^^^^^ ^^~~~~~~ ~~~^^^^^ ^^^^~~~~ ~~~~~~~~
Sign extension    PML4      PDPT      PD        PT        Offset

-- On ARM
Page directory selector            10 bits
Page table selector                10 bits
Byte within page                   12 bits
10000011 01100000 11010010 01110101
~~~~~~~~ ~~^^^^^^ ^^^^~~~~ ~~~~~~~~
PD         PT         Offset

*/

#ifdef _AMD64_

// Return an address of PXE
_Use_decl_annotations_ EXTERN_C static HARDWARE_PTE *UtilpAddressToPxe(
    const void *Address) {
  const auto addr = reinterpret_cast<ULONG_PTR>(Address);
  const auto index = (addr >> PXI_SHIFT) & UTILP_PXI_MASK;
  const auto offset = index * sizeof(HARDWARE_PTE);
  return reinterpret_cast<HARDWARE_PTE *>(PXE_BASE + offset);
}

// Return an address of PPE
_Use_decl_annotations_ EXTERN_C static HARDWARE_PTE *UtilpAddressToPpe(
    const void *Address) {
  const auto addr = reinterpret_cast<ULONG_PTR>(Address);
  const auto index = (addr >> PPI_SHIFT) & UTILP_PPI_MASK;
  const auto offset = index * sizeof(HARDWARE_PTE);
  return reinterpret_cast<HARDWARE_PTE *>(PPE_BASE + offset);
}

#endif

// Return an address of PDE
_Use_decl_annotations_ EXTERN_C static HARDWARE_PTE *UtilpAddressToPde(
    const void *Address) {
  const auto addr = reinterpret_cast<ULONG_PTR>(Address);
  const auto index = (addr >> PDI_SHIFT) & UTILP_PDI_MASK;
  const auto offset = index * sizeof(HARDWARE_PTE);
  return reinterpret_cast<HARDWARE_PTE *>(PDE_BASE + offset);
}

// Return an address of PTE
_Use_decl_annotations_ EXTERN_C static HARDWARE_PTE *UtilpAddressToPte(
    const void *Address) {
  const auto addr = reinterpret_cast<ULONG_PTR>(Address);
  const auto index = (addr >> PTI_SHIFT) & UTILP_PTI_MASK;
  const auto offset = index * sizeof(HARDWARE_PTE);
  return reinterpret_cast<HARDWARE_PTE *>(PTE_BASE + offset);
}
```

`Sushi/Sushi/util.h`:

```h
// Copyright (c) 2015, tandasat. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

//
// This module declares interfaces to utility functions.
//
#pragma once

////////////////////////////////////////////////////////////////////////////////
//
// macro utilities
//

////////////////////////////////////////////////////////////////////////////////
//
// constants and macros
//

////////////////////////////////////////////////////////////////////////////////
//
// types
//

////////////////////////////////////////////////////////////////////////////////
//
// prototypes
//

EXTERN_C NTSTATUS UtilForEachProcessor(_In_ NTSTATUS (*CallbackRoutine)(void *),
                                       _In_opt_ void *Context);

EXTERN_C NTSTATUS UtilSleep(_In_ LONG Millisecond);

EXTERN_C void *UtilMemMem(_In_ const void *SearchBase, _In_ SIZE_T SearchSize,
                          _In_ const void *Pattern, _In_ SIZE_T PatternSize);

EXTERN_C void UtilInvalidateInstructionCache(_In_ void *BaseAddress,
                                             _In_ SIZE_T Length);

EXTERN_C NTSTATUS UtilForceMemCpy(_In_ void *Destination,
                                  _In_ const void *Source, _In_ SIZE_T Length);

EXTERN_C bool UtilIsAccessibleAddress(_In_ const void *Address);

////////////////////////////////////////////////////////////////////////////////
//
// variables
//

////////////////////////////////////////////////////////////////////////////////
//
// implementations
//

template <typename T>
inline bool UtilIsInBounds(_In_ const T &Value, _In_ const T &Min,
                           _In_ const T &Max) {
  return (Min <= Value) && (Value <= Max);
}

```

`Sushi/Sushi/vminit.cpp`:

```cpp
// Copyright (c) 2015, tandasat. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

//
// This module defines VMM initialization functions.
//
#include "stdafx.h"
#include "vminit.h"
#include "log.h"
#include "misc.h"
#include "asm.h"
#include "ia32_type.h"
#include "vmx_type.h"

////////////////////////////////////////////////////////////////////////////////
//
// macro utilities
//

////////////////////////////////////////////////////////////////////////////////
//
// constants and macros
//

////////////////////////////////////////////////////////////////////////////////
//
// types
//

////////////////////////////////////////////////////////////////////////////////
//
// prototypes
//

EXTERN_C static bool VminitpIsVmxAvailable();

EXTERN_C static void VminitpInitializeVM(
    _In_ ULONG_PTR GuestStackPointer, _In_ ULONG_PTR GuestInstructionPointer);

EXTERN_C static bool VminitpEnterVmxMode(
    _Inout_ PER_PROCESSOR_DATA *ProcessorData);

EXTERN_C static bool VminitpInitializeVMCS(
    _Inout_ PER_PROCESSOR_DATA *ProcessorData);

EXTERN_C static bool VminitpSetupVMCS(
    _In_ const PER_PROCESSOR_DATA *ProcessorData,
    _In_ ULONG_PTR GuestStackPointer, _In_ ULONG_PTR GuestInstructionPointer,
    _In_ ULONG_PTR VmmStackPointer);

EXTERN_C static void VminitpLaunchVM();

EXTERN_C static ULONG VminitpGetSegmentAccessRight(_In_ USHORT SegmentSelector);

EXTERN_C static SEG_DESCRIPTOR *VminitpGetSegmentDescriptor(
    _In_ ULONG_PTR DescriptorTableBase, _In_ USHORT SegmentSelector);

EXTERN_C static ULONG_PTR VminitpGetSegmentBaseByDescriptor(
    _In_ const SEG_DESCRIPTOR *SegmentDescriptor);

EXTERN_C static ULONG_PTR VminitpGetSegmentBase(_In_ ULONG_PTR GdtBase,
                                                _In_ USHORT SegmentSelector);

EXTERN_C static ULONG VminitpAdjustControlValue(_In_ ULONG MsrNumber,
                                                _In_ ULONG RequestedValue);

////////////////////////////////////////////////////////////////////////////////
//
// variables
//

////////////////////////////////////////////////////////////////////////////////
//
// implementations
//

// Virtualize the current processor
ALLOC_TEXT(INIT, VminitStartVM)
_Use_decl_annotations_ EXTERN_C NTSTATUS VminitStartVM(void *Context) {
  UNREFERENCED_PARAMETER(Context);

  LOG_INFO("Initializing VMX for the processor %d.",
           KeGetCurrentProcessorNumber());

  if (!VminitpIsVmxAvailable()) {
    return STATUS_UNSUCCESSFUL;
  }

  if (!AsmInitialieVM(VminitpInitializeVM)) {
    return STATUS_UNSUCCESSFUL;
  }
  LOG_INFO("Initialized successfully.");
  return STATUS_SUCCESS;
}

// Checks if the system supports virtualization
ALLOC_TEXT(INIT, VminitpIsVmxAvailable)
_Use_decl_annotations_ EXTERN_C static bool VminitpIsVmxAvailable() {
  // DISCOVERING SUPPORT FOR VMX
  // If CPUID.1:ECX.VMX[bit 5]=1, then VMX operation is supported.
  int cpuInfo[4] = {};
  __cpuid(cpuInfo, 1);
  CPU_FEATURES_ECX cpuFeatures = {static_cast<ULONG_PTR>(cpuInfo[2])};
  if (!cpuFeatures.Fields.VMX) {
    LOG_ERROR("VMX features are not supported.");
    return false;
  }

  // BASIC VMX INFORMATION
  // The first processors to support VMX operation use the write-back type.
  IA32_VMX_BASIC_MSR vmxBasicMsr = {__readmsr(IA32_VMX_BASIC)};
  if (vmxBasicMsr.Fields.MemoryType != 6) {  // Write Back (WB)
    LOG_ERROR("Write-back cache type is not supported.");
    return false;
  }

  // ENABLING AND ENTERING VMX OPERATION
  IA32_FEATURE_CONTROL_MSR vmxFeatureControl = {
      __readmsr(IA32_FEATURE_CONTROL)};
  if (!vmxFeatureControl.Fields.Lock || !vmxFeatureControl.Fields.EnableVmxon) {
    LOG_ERROR("VMX features are not enabled.");
    return false;
  }

  return true;
}

// Allocates structures for virtualization, initializes VMCS and virtualizes
// the current processor
ALLOC_TEXT(INIT, VminitpInitializeVM)
_Use_decl_annotations_ EXTERN_C static void VminitpInitializeVM(
    ULONG_PTR GuestStackPointer, ULONG_PTR GuestInstructionPointer) {
  // Allocate related structures
  auto ProcessorData =
      reinterpret_cast<PER_PROCESSOR_DATA *>(ExAllocatePoolWithTag(
          NonPagedPoolNx, sizeof(PER_PROCESSOR_DATA), SUSHI_POOL_TAG_NAME));
  auto VmmStackTop = MiscAllocateContiguousMemory(KERNEL_STACK_SIZE);
  auto VmcsRegion =
      reinterpret_cast<VMCS *>(MiscAllocateContiguousMemory(MAXIMUM_VMCS_SIZE));
  auto VmxonRegion =
      reinterpret_cast<VMCS *>(MiscAllocateContiguousMemory(MAXIMUM_VMCS_SIZE));
  auto msrBitmap = MiscAllocateContiguousMemory(PAGE_SIZE);
  if (!ProcessorData || !VmmStackTop || !VmcsRegion || !VmxonRegion ||
      !msrBitmap) {
    goto ReturnFalse;
  }
  RtlZeroMemory(ProcessorData, sizeof(PER_PROCESSOR_DATA));
  RtlZeroMemory(VmmStackTop, KERNEL_STACK_SIZE);
  RtlZeroMemory(VmcsRegion, MAXIMUM_VMCS_SIZE);
  RtlZeroMemory(VmxonRegion, MAXIMUM_VMCS_SIZE);
  RtlZeroMemory(msrBitmap, PAGE_SIZE);

  // Initialize stack memory for VMM like this:
  /*
  (High)
  +------------------+
  | ProcessorData    |  <- VmmStackData
  +------------------+
  | ffffffffffffffff |  <- VmmStackBase
  +------------------+    v
  |                  |    v
  |   VmmStack       |    v (grow)
  |                  |    v
  +------------------+  <- VmmStackTop
  (Low)
  */
  const auto VmmStackBottom =
      reinterpret_cast<ULONG_PTR>(VmmStackTop) + KERNEL_STACK_SIZE;
  const auto VmmStackData = VmmStackBottom - sizeof(void *);
  const auto VmmStackBase = VmmStackData - sizeof(void *);
  LOG_DEBUG("VmmStackTop=       %p", VmmStackTop);
  LOG_DEBUG("VmmStackBottom=    %p", VmmStackBottom);
  LOG_DEBUG("VmmStackData=      %p", VmmStackData);
  LOG_DEBUG("ProcessorData=     %p stored at %p", ProcessorData, VmmStackData);
  LOG_DEBUG("VmmStackBase=      %p", VmmStackBase);
  LOG_DEBUG("GuestStackPointer= %p", GuestStackPointer);
  *reinterpret_cast<ULONG_PTR *>(VmmStackBase) = 0xffffffffffffffff;
  *reinterpret_cast<PER_PROCESSOR_DATA **>(VmmStackData) = ProcessorData;

  // Initialize the management structure
  ProcessorData->VmmStackTop = VmmStackTop;
  ProcessorData->VmcsRegion = VmcsRegion;
  ProcessorData->VmxonRegion = VmxonRegion;
  ProcessorData->MsrBitmap = msrBitmap;

  // Set up VMCS
  if (!VminitpEnterVmxMode(ProcessorData)) {
    goto ReturnFalse;
  }
  if (!VminitpInitializeVMCS(ProcessorData)) {
    goto ReturnFalseWithVmxOff;
  }
  if (!VminitpSetupVMCS(ProcessorData, GuestStackPointer,
                        GuestInstructionPointer, VmmStackBase)) {
    goto ReturnFalseWithVmxOff;
  }

  // Do virtualize the processor
  VminitpLaunchVM();

// Here is not be executed with successful vmlaunch. Instead, the context
// jumps to an address specified by GuestInstructionPointer.

ReturnFalseWithVmxOff:;
  __vmx_off();

ReturnFalse:;
  if (ProcessorData) {
    ExFreePoolWithTag(ProcessorData, SUSHI_POOL_TAG_NAME);
  }
  if (VmmStackTop) {
    MiscFreeContiguousMemory(VmmStackTop);
  }
  if (VmcsRegion) {
    MiscFreeContiguousMemory(VmcsRegion);
  }
  if (VmxonRegion) {
    MiscFreeContiguousMemory(VmxonRegion);
  }
  if (msrBitmap) {
    MiscFreeContiguousMemory(msrBitmap);
  }
}

// VMM SETUP & TEAR DOWN
ALLOC_TEXT(INIT, VminitpEnterVmxMode)
_Use_decl_annotations_ EXTERN_C static bool VminitpEnterVmxMode(
    PER_PROCESSOR_DATA *ProcessorData) {
  // Apply FIXED bits
  const CR0_REG cr0Fixed0 = {__readmsr(IA32_VMX_CR0_FIXED0)};
  const CR0_REG cr0Fixed1 = {__readmsr(IA32_VMX_CR0_FIXED1)};
  CR0_REG cr0 = {__readcr0()};
  cr0.All &= cr0Fixed1.All;
  cr0.All |= cr0Fixed0.All;
  __writecr0(cr0.All);

  const CR4_REG cr4Fixed0 = {__readmsr(IA32_VMX_CR4_FIXED0)};
  const CR4_REG cr4Fixed1 = {__readmsr(IA32_VMX_CR4_FIXED1)};
  CR4_REG cr4 = {__readcr4()};
  cr4.All &= cr4Fixed1.All;
  cr4.All |= cr4Fixed0.All;
  __writecr4(cr4.All);

  // Write a VMCS revision identifier
  IA32_VMX_BASIC_MSR vmxBasicMsr = {__readmsr(IA32_VMX_BASIC)};
  ProcessorData->VmxonRegion->RevisionIdentifier =
      vmxBasicMsr.Fields.RevisionIdentifier;

  auto vmxonRegionPA = MmGetPhysicalAddress(ProcessorData->VmxonRegion);
  if (__vmx_on(
          reinterpret_cast<unsigned long long *>(&vmxonRegionPA.QuadPart))) {
    return false;
  }
  return true;
}

// VMM SETUP & TEAR DOWN
ALLOC_TEXT(INIT, VminitpInitializeVMCS)
_Use_decl_annotations_ EXTERN_C static bool VminitpInitializeVMCS(
    PER_PROCESSOR_DATA *ProcessorData) {
  // Write a VMCS revision identifier
  IA32_VMX_BASIC_MSR vmxBasicMsr = {__readmsr(IA32_VMX_BASIC)};
  ProcessorData->VmcsRegion->RevisionIdentifier =
      vmxBasicMsr.Fields.RevisionIdentifier;

  auto vmcsRegionPA = MmGetPhysicalAddress(ProcessorData->VmcsRegion);

  // It stores the value FFFFFFFF_FFFFFFFFH if there is no current VMCS
  if (__vmx_vmclear(
          reinterpret_cast<unsigned long long *>(&vmcsRegionPA.QuadPart))) {
    return false;
  }

  // Software makes a VMCS current by executing VMPTRLD with the address
  // of the VMCS; that address is loaded into the current-VMCS pointer.
  if (__vmx_vmptrld(
          reinterpret_cast<unsigned long long *>(&vmcsRegionPA.QuadPart))) {
    return false;
  }

  // The launch state of current VMCS is "clear"
  return true;
}

// PREPARATION AND LAUNCHING A VIRTUAL MACHINE
ALLOC_TEXT(INIT, VminitpSetupVMCS)
_Use_decl_annotations_ EXTERN_C static bool VminitpSetupVMCS(
    const PER_PROCESSOR_DATA *ProcessorData, ULONG_PTR GuestStackPointer,
    ULONG_PTR GuestInstructionPointer, ULONG_PTR VmmStackPointer) {
  unsigned char error = 0;

  GDTR gdtr = {};
  __sgdt(&gdtr);

  IDTR idtr = {};
  __sidt(&idtr);

  VMX_VM_ENTER_CONTROLS vmEnterCtlRequested = {};
  vmEnterCtlRequested.Fields.IA32eModeGuest = true;
  VMX_VM_ENTER_CONTROLS vmEnterCtl = {
      VminitpAdjustControlValue(IA32_VMX_ENTRY_CTLS, vmEnterCtlRequested.All)};

  VMX_VM_EXIT_CONTROLS vmExitCtlRequested = {};
  vmExitCtlRequested.Fields.AcknowledgeInterruptOnExit = true;
  vmExitCtlRequested.Fields.HostAddressSpaceSize = true;
  VMX_VM_EXIT_CONTROLS vmExitCtl = {
      VminitpAdjustControlValue(IA32_VMX_EXIT_CTLS, vmExitCtlRequested.All)};

  VMX_PIN_BASED_CONTROLS vmPinCtlRequested = {};
  VMX_PIN_BASED_CONTROLS vmPinCtl = {
      VminitpAdjustControlValue(IA32_VMX_PINBASED_CTLS, vmPinCtlRequested.All)};

  VMX_CPU_BASED_CONTROLS vmCpuCtlRequested = {};
  vmCpuCtlRequested.Fields.RDTSCExiting = true;
  vmCpuCtlRequested.Fields.CR3LoadExiting = true;  // MOV to CR3
  vmCpuCtlRequested.Fields.CR8LoadExiting = true;  // MOV to CR8
  vmCpuCtlRequested.Fields.MovDRExiting = true;
  vmCpuCtlRequested.Fields.UseMSRBitmaps = true;
  vmCpuCtlRequested.Fields.ActivateSecondaryControl = true;
  VMX_CPU_BASED_CONTROLS vmCpuCtl = {VminitpAdjustControlValue(
      IA32_VMX_PROCBASED_CTLS, vmCpuCtlRequested.All)};

  VMX_SECONDARY_CPU_BASED_CONTROLS vmCpuCtl2Requested = {};
  vmCpuCtl2Requested.Fields.EnableRDTSCP = true;
  vmCpuCtl2Requested.Fields.DescriptorTableExiting = true;
  VMX_CPU_BASED_CONTROLS vmCpuCtl2 = {VminitpAdjustControlValue(
      IA32_VMX_PROCBASED_CTLS2, vmCpuCtl2Requested.All)};

  // Set up the MSR bitmap

  // Activate VM-exit for RDMSR against all MSRs
  const auto bitMapReadLow =
      reinterpret_cast<UCHAR *>(ProcessorData->MsrBitmap);
  const auto bitMapReadHigh = bitMapReadLow + 1024;
  RtlFillMemory(bitMapReadLow, 1024, 0xff);   // read        0 -     1fff
  RtlFillMemory(bitMapReadHigh, 1024, 0xff);  // read c0000000 - c0001fff

  // But ignore IA32_MPERF (000000e7) and IA32_APERF (000000e8)
  RTL_BITMAP bitMapReadLowHeader = {};
  RtlInitializeBitMap(&bitMapReadLowHeader,
                      reinterpret_cast<PULONG>(bitMapReadLow), 1024 * 8);
  RtlClearBits(&bitMapReadLowHeader, 0xe7, 2);

  // But ignore IA32_GS_BASE (c0000101) and IA32_KERNEL_GS_BASE (c0000102)
  RTL_BITMAP bitMapReadHighHeader = {};
  RtlInitializeBitMap(&bitMapReadHighHeader,
                      reinterpret_cast<PULONG>(bitMapReadHigh), 1024 * 8);
  RtlClearBits(&bitMapReadHighHeader, 0x101, 2);

  const auto msrBitmapPA = MmGetPhysicalAddress(ProcessorData->MsrBitmap);

  // Set up CR0 and CR4 bitmaps

  // Where a bit is     masked, the shadow bit appears
  // Where a bit is not masked, the actual bit appears
  CR0_REG cr0mask = {};
  cr0mask.Fields.WP = true;
  CR4_REG cr4mask = {};
  cr4mask.Fields.PGE = true;

  // clang-format off
  /* 16-Bit Control Field */

  /* 16-Bit Guest-State Fields */
  error |= __vmx_vmwrite(GUEST_ES_SELECTOR, AsmReadES());
  error |= __vmx_vmwrite(GUEST_CS_SELECTOR, AsmReadCS());
  error |= __vmx_vmwrite(GUEST_SS_SELECTOR, AsmReadSS());
  error |= __vmx_vmwrite(GUEST_DS_SELECTOR, AsmReadDS());
  error |= __vmx_vmwrite(GUEST_FS_SELECTOR, AsmReadFS());
  error |= __vmx_vmwrite(GUEST_GS_SELECTOR, AsmReadGS());
  error |= __vmx_vmwrite(GUEST_LDTR_SELECTOR, AsmReadLDTR());
  error |= __vmx_vmwrite(GUEST_TR_SELECTOR, AsmReadTR());

  /* 16-Bit Host-State Fields */
  error |= __vmx_vmwrite(HOST_ES_SELECTOR, AsmReadES() & 0xf8); // RPL and TI 
  error |= __vmx_vmwrite(HOST_CS_SELECTOR, AsmReadCS() & 0xf8); // have to be 0
  error |= __vmx_vmwrite(HOST_SS_SELECTOR, AsmReadSS() & 0xf8);
  error |= __vmx_vmwrite(HOST_DS_SELECTOR, AsmReadDS() & 0xf8);
  error |= __vmx_vmwrite(HOST_FS_SELECTOR, AsmReadFS() & 0xf8);
  error |= __vmx_vmwrite(HOST_GS_SELECTOR, AsmReadGS() & 0xf8);
  error |= __vmx_vmwrite(HOST_TR_SELECTOR, AsmReadTR() & 0xf8);

  /* 64-Bit Control Fields */
  error |= __vmx_vmwrite(IO_BITMAP_A, 0);
  error |= __vmx_vmwrite(IO_BITMAP_B, 0);
  error |= __vmx_vmwrite(MSR_BITMAP, msrBitmapPA.QuadPart);
  error |= __vmx_vmwrite(TSC_OFFSET, 0);

  /* 64-Bit Guest-State Fields */
  error |= __vmx_vmwrite(VMCS_LINK_POINTER, 0xffffffffffffffff);
  error |= __vmx_vmwrite(GUEST_IA32_DEBUGCTL, __readmsr(IA32_DEBUGCTL));

  /* 32-Bit Control Fields */
  error |= __vmx_vmwrite(PIN_BASED_VM_EXEC_CONTROL, vmPinCtl.All);
  error |= __vmx_vmwrite(CPU_BASED_VM_EXEC_CONTROL, vmCpuCtl.All);
  error |= __vmx_vmwrite(SECONDARY_VM_EXEC_CONTROL, vmCpuCtl2.All);
  error |= __vmx_vmwrite(EXCEPTION_BITMAP, 0);
  error |= __vmx_vmwrite(PAGE_FAULT_ERROR_CODE_MASK, 0);
  error |= __vmx_vmwrite(PAGE_FAULT_ERROR_CODE_MATCH, 0);
  error |= __vmx_vmwrite(CR3_TARGET_COUNT, 0);
  error |= __vmx_vmwrite(VM_EXIT_CONTROLS, vmExitCtl.All);
  error |= __vmx_vmwrite(VM_EXIT_MSR_STORE_COUNT, 0);
  error |= __vmx_vmwrite(VM_EXIT_MSR_LOAD_COUNT, 0);
  error |= __vmx_vmwrite(VM_ENTRY_CONTROLS, vmEnterCtl.All);
  error |= __vmx_vmwrite(VM_ENTRY_MSR_LOAD_COUNT, 0);
  error |= __vmx_vmwrite(VM_ENTRY_INTR_INFO_FIELD, 0);

  /* 32-Bit Guest-State Fields */
  error |= __vmx_vmwrite(GUEST_ES_LIMIT, GetSegmentLimit(AsmReadES()));
  error |= __vmx_vmwrite(GUEST_CS_LIMIT, GetSegmentLimit(AsmReadCS()));
  error |= __vmx_vmwrite(GUEST_SS_LIMIT, GetSegmentLimit(AsmReadSS()));
  error |= __vmx_vmwrite(GUEST_DS_LIMIT, GetSegmentLimit(AsmReadDS()));
  error |= __vmx_vmwrite(GUEST_FS_LIMIT, GetSegmentLimit(AsmReadFS()));
  error |= __vmx_vmwrite(GUEST_GS_LIMIT, GetSegmentLimit(AsmReadGS()));
  error |= __vmx_vmwrite(GUEST_LDTR_LIMIT, GetSegmentLimit(AsmReadLDTR()));
  error |= __vmx_vmwrite(GUEST_TR_LIMIT, GetSegmentLimit(AsmReadTR()));
  error |= __vmx_vmwrite(GUEST_GDTR_LIMIT, gdtr.Limit);
  error |= __vmx_vmwrite(GUEST_IDTR_LIMIT, idtr.Limit);
  error |= __vmx_vmwrite(GUEST_ES_AR_BYTES, VminitpGetSegmentAccessRight(AsmReadES()));
  error |= __vmx_vmwrite(GUEST_CS_AR_BYTES, VminitpGetSegmentAccessRight(AsmReadCS()));
  error |= __vmx_vmwrite(GUEST_SS_AR_BYTES, VminitpGetSegmentAccessRight(AsmReadSS()));
  error |= __vmx_vmwrite(GUEST_DS_AR_BYTES, VminitpGetSegmentAccessRight(AsmReadDS()));
  error |= __vmx_vmwrite(GUEST_FS_AR_BYTES, VminitpGetSegmentAccessRight(AsmReadFS()));
  error |= __vmx_vmwrite(GUEST_GS_AR_BYTES, VminitpGetSegmentAccessRight(AsmReadGS()));
  error |= __vmx_vmwrite(GUEST_LDTR_AR_BYTES, VminitpGetSegmentAccessRight(AsmReadLDTR()));
  error |= __vmx_vmwrite(GUEST_TR_AR_BYTES, VminitpGetSegmentAccessRight(AsmReadTR()));
  error |= __vmx_vmwrite(GUEST_INTERRUPTIBILITY_INFO, 0);
  error |= __vmx_vmwrite(GUEST_ACTIVITY_STATE, 0);
  error |= __vmx_vmwrite(GUEST_SYSENTER_CS, __readmsr(IA32_SYSENTER_CS));

  /* 32-Bit Host-State Field */
  error |= __vmx_vmwrite(HOST_IA32_SYSENTER_CS, __readmsr(IA32_SYSENTER_CS));

  /* Natural-Width Control Fields */
  error |= __vmx_vmwrite(CR0_GUEST_HOST_MASK, cr0mask.All);
  error |= __vmx_vmwrite(CR4_GUEST_HOST_MASK, cr4mask.All);
  error |= __vmx_vmwrite(CR0_READ_SHADOW, __readcr0());
  error |= __vmx_vmwrite(CR4_READ_SHADOW, __readcr4());
  error |= __vmx_vmwrite(CR3_TARGET_VALUE0, 0);
  error |= __vmx_vmwrite(CR3_TARGET_VALUE1, 0);
  error |= __vmx_vmwrite(CR3_TARGET_VALUE2, 0);
  error |= __vmx_vmwrite(CR3_TARGET_VALUE3, 0);

  /* Natural-Width Guest-State Fields */
  error |= __vmx_vmwrite(GUEST_CR0, __readcr0());
  error |= __vmx_vmwrite(GUEST_CR3, __readcr3());
  error |= __vmx_vmwrite(GUEST_CR4, __readcr4());
  error |= __vmx_vmwrite(GUEST_ES_BASE, 0);
  error |= __vmx_vmwrite(GUEST_CS_BASE, 0);
  error |= __vmx_vmwrite(GUEST_SS_BASE, 0);
  error |= __vmx_vmwrite(GUEST_DS_BASE, 0);
  error |= __vmx_vmwrite(GUEST_FS_BASE, __readmsr(IA32_FS_BASE));
  error |= __vmx_vmwrite(GUEST_GS_BASE, __readmsr(IA32_GS_BASE));
  error |= __vmx_vmwrite(GUEST_LDTR_BASE, VminitpGetSegmentBase(gdtr.Address, AsmReadLDTR()));
  error |= __vmx_vmwrite(GUEST_TR_BASE, VminitpGetSegmentBase(gdtr.Address, AsmReadTR()));
  error |= __vmx_vmwrite(GUEST_GDTR_BASE, gdtr.Address);
  error |= __vmx_vmwrite(GUEST_IDTR_BASE, idtr.Address);
  error |= __vmx_vmwrite(GUEST_DR7, __readdr(7));
  error |= __vmx_vmwrite(GUEST_RSP, GuestStackPointer);
  error |= __vmx_vmwrite(GUEST_RIP, GuestInstructionPointer);
  error |= __vmx_vmwrite(GUEST_RFLAGS, __readeflags());
  error |= __vmx_vmwrite(GUEST_SYSENTER_ESP, __readmsr(IA32_SYSENTER_ESP));
  error |= __vmx_vmwrite(GUEST_SYSENTER_EIP, __readmsr(IA32_SYSENTER_EIP));

  /* Natural-Width Host-State Fields */
  error |= __vmx_vmwrite(HOST_CR0, __readcr0());
  error |= __vmx_vmwrite(HOST_CR3, __readcr3());
  error |= __vmx_vmwrite(HOST_CR4, __readcr4());
  error |= __vmx_vmwrite(HOST_FS_BASE, __readmsr(IA32_FS_BASE));
  error |= __vmx_vmwrite(HOST_GS_BASE, __readmsr(IA32_GS_BASE));
  error |= __vmx_vmwrite(HOST_TR_BASE, VminitpGetSegmentBase(gdtr.Address, AsmReadTR()));
  error |= __vmx_vmwrite(HOST_GDTR_BASE, gdtr.Address);
  error |= __vmx_vmwrite(HOST_IDTR_BASE, idtr.Address);
  error |= __vmx_vmwrite(HOST_IA32_SYSENTER_ESP, __readmsr(IA32_SYSENTER_ESP));
  error |= __vmx_vmwrite(HOST_IA32_SYSENTER_EIP, __readmsr(IA32_SYSENTER_EIP));
  error |= __vmx_vmwrite(HOST_RSP, VmmStackPointer);
  error |= __vmx_vmwrite(HOST_RIP, reinterpret_cast<size_t>(AsmVmmEntryPoint));
  // clang-format on

  const auto vmxStatus = static_cast<VMX_STATUS>(error);
  return vmxStatus == VMX_OK;
}

// Executes vmlaunch
ALLOC_TEXT(INIT, VminitpLaunchVM)
_Use_decl_annotations_ EXTERN_C static void VminitpLaunchVM() {
  size_t errorCode = 0;
  auto vmxStatus =
      static_cast<VMX_STATUS>(__vmx_vmread(VM_INSTRUCTION_ERROR, &errorCode));
  if (vmxStatus != VMX_OK) {
    LOG_WARN("VM_INSTRUCTION_ERROR = %p %d", errorCode, vmxStatus);
  }
  DBG_BREAK();
  vmxStatus = static_cast<VMX_STATUS>(__vmx_vmlaunch());

  // Here is not be executed with successful vmlaunch. Instead, the context
  // jumps to an address specified by GUEST_RIP.
  if (vmxStatus == VMX_ERROR_WITH_STATUS) {
    vmxStatus =
        static_cast<VMX_STATUS>(__vmx_vmread(VM_INSTRUCTION_ERROR, &errorCode));
    LOG_ERROR("VM_INSTRUCTION_ERROR = %p %d", errorCode, vmxStatus);
  }
  DBG_BREAK();
}

// Returns access right of the segment specified by the SegmentSelector for VMX
ALLOC_TEXT(INIT, VminitpGetSegmentAccessRight)
_Use_decl_annotations_ EXTERN_C static ULONG VminitpGetSegmentAccessRight(
    USHORT SegmentSelector) {
  VMX_SEG_DESCRIPTOR_ACCESS_RIGHT accessRight = {};
  SEG_SELECTOR ss = {SegmentSelector};
  if (SegmentSelector) {
    auto nativeAccessRight = AsmLoadAccessRightsByte(ss.All);
    nativeAccessRight >>= 8;
    accessRight.All = static_cast<ULONG>(nativeAccessRight);
    accessRight.Fields.Reserved1 = 0;
    accessRight.Fields.Reserved2 = 0;
    accessRight.Fields.Unusable = false;
  } else {
    accessRight.Fields.Unusable = true;
  }
  return accessRight.All;
}

// Returns a base address of the segment specified by SegmentSelector
ALLOC_TEXT(INIT, VminitpGetSegmentBase)
_Use_decl_annotations_ EXTERN_C static ULONG_PTR VminitpGetSegmentBase(
    ULONG_PTR GdtBase, USHORT SegmentSelector) {
  const SEG_SELECTOR ss = {SegmentSelector};
  if (!ss.All) {
    return 0;
  }

  if (ss.Fields.TI) {
    const auto localSegmentDescriptor =
        VminitpGetSegmentDescriptor(GdtBase, AsmReadLDTR());
    const auto LdtBase =
        VminitpGetSegmentBaseByDescriptor(localSegmentDescriptor);
    const auto SegmentDescriptor =
        VminitpGetSegmentDescriptor(LdtBase, SegmentSelector);
    return VminitpGetSegmentBaseByDescriptor(SegmentDescriptor);
  } else {
    const auto segmentDescriptor =
        VminitpGetSegmentDescriptor(GdtBase, SegmentSelector);
    return VminitpGetSegmentBaseByDescriptor(segmentDescriptor);
  }
}

// Returns the segment descriptor corresponds to the SegmentSelector
ALLOC_TEXT(INIT, VminitpGetSegmentDescriptor)
_Use_decl_annotations_ EXTERN_C static SEG_DESCRIPTOR *
VminitpGetSegmentDescriptor(ULONG_PTR DescriptorTableBase,
                            USHORT SegmentSelector) {
  SEG_SELECTOR ss = {SegmentSelector};
  return reinterpret_cast<SEG_DESCRIPTOR *>(
      DescriptorTableBase + ss.Fields.Index * sizeof(SEG_DESCRIPTOR));
}

// Returns a base address of SegmentDescriptor
ALLOC_TEXT(INIT, VminitpGetSegmentBaseByDescriptor)
_Use_decl_annotations_ EXTERN_C static ULONG_PTR
VminitpGetSegmentBaseByDescriptor(const SEG_DESCRIPTOR *SegmentDescriptor) {
  ULONG_PTR baseHi = SegmentDescriptor->Fields.BaseHi;
  baseHi = baseHi << (6 * 4);
  ULONG_PTR baseMid = SegmentDescriptor->Fields.BaseMid;
  baseMid = baseMid << (4 * 4);
  ULONG_PTR baseLow = SegmentDescriptor->Fields.BaseLow;
  ULONG_PTR base = (baseHi | baseMid | baseLow) & 0xffffffff;
  if (!SegmentDescriptor->Fields.System) {
    auto desc64 = reinterpret_cast<const SEG_DESCRIPTOR64 *>(SegmentDescriptor);
    ULONG_PTR baseUpper32 = desc64->BaseUpper32;
    base |= (baseUpper32 << 32);
  }
  return base;
}

// Adjust the requested control value with consulting a value of related MSR
ALLOC_TEXT(INIT, VminitpAdjustControlValue)
_Use_decl_annotations_ EXTERN_C static ULONG VminitpAdjustControlValue(
    ULONG MsrNumber, ULONG RequestedValue) {
  LARGE_INTEGER msrValue = {};
  msrValue.QuadPart = __readmsr(MsrNumber);
  auto adjustedValue = RequestedValue;
  adjustedValue &= msrValue.HighPart;  // bit == 0 in high word ==> must be zero
  adjustedValue |= msrValue.LowPart;   // bit == 1 in low word  ==> must be one
  return adjustedValue;
}

```

`Sushi/Sushi/vminit.h`:

```h
// Copyright (c) 2015, tandasat. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

//
// This module declares interfaces to VMM initialization functions
//
#pragma once

////////////////////////////////////////////////////////////////////////////////
//
// macro utilities
//

////////////////////////////////////////////////////////////////////////////////
//
// constants and macros
//

////////////////////////////////////////////////////////////////////////////////
//
// types
//

////////////////////////////////////////////////////////////////////////////////
//
// prototypes
//

EXTERN_C NTSTATUS VminitStartVM(_In_opt_ void* Context);

////////////////////////////////////////////////////////////////////////////////
//
// variables
//

////////////////////////////////////////////////////////////////////////////////
//
// implementations
//

```

`Sushi/Sushi/vmx.cpp`:

```cpp
// Copyright (c) 2015, tandasat. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

//
// This module declares interfaces to VMM functions.
//
#include "stdafx.h"
#include "vmx.h"
#include "log.h"
#include "asm.h"
#include "misc.h"
#include "ia32_type.h"
#include "vmx_type.h"

////////////////////////////////////////////////////////////////////////////////
//
// macro utilities
//

////////////////////////////////////////////////////////////////////////////////
//
// constants and macros
//

////////////////////////////////////////////////////////////////////////////////
//
// types
//

// Represents raw structure of stack of VMM when VmxVmExitHandler() is called
struct VMM_STACK {
  ULONG_PTR r15;
  ULONG_PTR r14;
  ULONG_PTR r13;
  ULONG_PTR r12;
  ULONG_PTR r11;
  ULONG_PTR r10;
  ULONG_PTR r9;
  ULONG_PTR r8;
  ULONG_PTR rdi;
  ULONG_PTR rsi;
  ULONG_PTR rbp;
  ULONG_PTR rsp;
  ULONG_PTR rbx;
  ULONG_PTR rdx;
  ULONG_PTR rcx;
  ULONG_PTR rax;
  ULONG_PTR Reserved;
  PER_PROCESSOR_DATA *ProcessorData;
};

// Things need to be read and written by each VM-exit handler
struct GUEST_CONTEXT {
  union {
    VMM_STACK *Stack;
    GP_REGISTERS *GpRegs;
  };
  EFLAGS Rflags;
  ULONG_PTR Rip;
  ULONG_PTR Cr8;
  KIRQL Irql;
  bool VmContinue;
};
static_assert(sizeof(GUEST_CONTEXT) == 40, "Size check");

////////////////////////////////////////////////////////////////////////////////
//
// prototypes
//

EXTERN_C bool VmxVmExitHandler(_Inout_ VMM_STACK *Stack);

EXTERN_C static void VmxpHandleCpuid(_Inout_ GUEST_CONTEXT *GuestContext);

EXTERN_C static void VmxpHandleRdtsc(_Inout_ GUEST_CONTEXT *GuestContext);

EXTERN_C static void VmxpHandleRdtscp(_Inout_ GUEST_CONTEXT *GuestContext);

EXTERN_C static void VmxpHandleXsetbv(_Inout_ GUEST_CONTEXT *GuestContext);

EXTERN_C static void VmxpHandleMsrReadAccess(
    _Inout_ GUEST_CONTEXT *GuestContext);

EXTERN_C static void VmxpHandleMsrWriteAccess(
    _Inout_ GUEST_CONTEXT *GuestContext);

EXTERN_C static void VmxpHandleMsrAccess(_Inout_ GUEST_CONTEXT *GuestContext,
                                         _In_ bool ReadAccess);

EXTERN_C static void VmxpHandleGdtrOrIdtrAccess(
    _Inout_ GUEST_CONTEXT *GuestContext);

EXTERN_C static void VmxpHandleLdtrOrTrAccess(
    _Inout_ GUEST_CONTEXT *GuestContext);

EXTERN_C static void VmxpHandleDrAccess(_Inout_ GUEST_CONTEXT *GuestContext);

EXTERN_C static void VmxpHandleCrAccess(_Inout_ GUEST_CONTEXT *GuestContext);

EXTERN_C static void VmxpHandleVmx(_Inout_ GUEST_CONTEXT *GuestContext);

EXTERN_C static void VmxpHandleVmCall(_Inout_ GUEST_CONTEXT *GuestContext);

EXTERN_C static void VmxpHandleInvalidateInternalCaches(
    _Inout_ GUEST_CONTEXT *GuestContext);

EXTERN_C static ULONG_PTR *VmxpSelectRegister(_In_ ULONG Index,
                                              _In_ GUEST_CONTEXT *GuestContext);

EXTERN_C static void VmxpDumpGuestSelectors();

EXTERN_C static SIZE_T VmxpVmRead(_In_ SIZE_T Field);

EXTERN_C static VMX_STATUS VmxpVmWrite(_In_ SIZE_T Field,
                                       _In_ SIZE_T FieldValue);

EXTERN_C static void VmxpAdjustGuestInstructionPointer(_In_ ULONG_PTR GuestRip);

////////////////////////////////////////////////////////////////////////////////
//
// variables
//

////////////////////////////////////////////////////////////////////////////////
//
// implementations
//

// A high level VMX handler called from AsmVmExitHandler().
// Return true for vmresume, or return false for vmxoff.
_Use_decl_annotations_ EXTERN_C bool VmxVmExitHandler(VMM_STACK *Stack) {
  // Raise IRQL as quick as possible
  const auto guestIrql = KeGetCurrentIrql();
  const auto guestCr8 = __readcr8();
  if (guestIrql < DISPATCH_LEVEL) {
    KeRaiseIrqlToDpcLevel();
  }
  NT_ASSERT(Stack->Reserved == 0xffffffffffffffff);

  // Capture the current guest state
  GUEST_CONTEXT guestContext = {Stack,
                                VmxpVmRead(GUEST_RFLAGS),
                                VmxpVmRead(GUEST_RIP),
                                guestCr8,
                                guestIrql,
                                true};
  guestContext.GpRegs->rsp = VmxpVmRead(GUEST_RSP);

  // Dispatch the current VM-exit event
  const VM_EXIT_INFORMATION exitReason = {
      static_cast<ULONG32>(VmxpVmRead(VM_EXIT_REASON))};

  switch (exitReason.Fields.Reason) {
    case EXIT_REASON_CPUID:
      VmxpHandleCpuid(&guestContext);
      break;
    case EXIT_REASON_INVD:
      VmxpHandleInvalidateInternalCaches(&guestContext);
      break;
    case EXIT_REASON_RDTSC:
      VmxpHandleRdtsc(&guestContext);
      break;
    case EXIT_REASON_CR_ACCESS:
      VmxpHandleCrAccess(&guestContext);
      break;
    case EXIT_REASON_DR_ACCESS:
      VmxpHandleDrAccess(&guestContext);
      break;
    case EXIT_REASON_MSR_READ:
      VmxpHandleMsrReadAccess(&guestContext);
      break;
    case EXIT_REASON_MSR_WRITE:
      VmxpHandleMsrWriteAccess(&guestContext);
      break;
    case EXIT_REASON_GDTR_OR_IDTR_ACCESS:
      VmxpHandleGdtrOrIdtrAccess(&guestContext);
      break;
    case EXIT_REASON_LDTR_OR_TR_ACCESS:
      VmxpHandleLdtrOrTrAccess(&guestContext);
      break;
    case EXIT_REASON_VMCALL:
      VmxpHandleVmCall(&guestContext);
      break;
    case EXIT_REASON_VMCLEAR:
    case EXIT_REASON_VMLAUNCH:
    case EXIT_REASON_VMPTRLD:
    case EXIT_REASON_VMPTRST:
    case EXIT_REASON_VMREAD:
    case EXIT_REASON_VMRESUME:
    case EXIT_REASON_VMWRITE:
    case EXIT_REASON_VMOFF:
    case EXIT_REASON_VMON:
      VmxpHandleVmx(&guestContext);
      break;
    case EXIT_REASON_RDTSCP:
      VmxpHandleRdtscp(&guestContext);
      break;
    case EXIT_REASON_XSETBV:
      VmxpHandleXsetbv(&guestContext);
      break;
    default:
      DBG_BREAK();
      VmxpDumpGuestSelectors();
      break;
  }

  if (guestContext.Irql < DISPATCH_LEVEL) {
    KeLowerIrql(guestContext.Irql);
  }

  // Apply (possibly) updated CR8 by the handler
  __writecr8(guestContext.Cr8);
  return guestContext.VmContinue;
}

// CPUID
_Use_decl_annotations_ EXTERN_C static void VmxpHandleCpuid(
    GUEST_CONTEXT *GuestContext) {
  unsigned int cpuInfo[4] = {};
  const auto functionId = static_cast<int>(GuestContext->GpRegs->rax);
  const auto subFunctionId = static_cast<int>(GuestContext->GpRegs->rcx);

  if (functionId == 0 && subFunctionId == SUSHI_BACKDOOR_CODE) {
    // Say "I love sushi" when the back-door code was given
    GuestContext->GpRegs->rbx = 'ol I';
    GuestContext->GpRegs->rdx = 's ev';
    GuestContext->GpRegs->rcx = 'ihsu';
  } else {
    __cpuidex(reinterpret_cast<int *>(cpuInfo), functionId, subFunctionId);
    GuestContext->GpRegs->rax = cpuInfo[0];
    GuestContext->GpRegs->rbx = cpuInfo[1];
    GuestContext->GpRegs->rcx = cpuInfo[2];
    GuestContext->GpRegs->rdx = cpuInfo[3];
  }

  VmxpAdjustGuestInstructionPointer(GuestContext->Rip);
}

// RDTSC
_Use_decl_annotations_ EXTERN_C static void VmxpHandleRdtsc(
    GUEST_CONTEXT *GuestContext) {
  ULARGE_INTEGER tsc = {};
  tsc.QuadPart = __rdtsc();
  GuestContext->GpRegs->rdx = tsc.HighPart;
  GuestContext->GpRegs->rax =
      tsc.LowPart & 0xffffff00;  // Drop lowest 8 bits for demo

  // Log when the guest is in an interesting address
  if (MiscIsInterestingAddress(GuestContext->Rip)) {
    LOG_DEBUG_SAFE("GuestRip= %p, Rdtsc  => %p", GuestContext->Rip,
                   tsc.QuadPart);
  }
  VmxpAdjustGuestInstructionPointer(GuestContext->Rip);
}

// RDTSCP
_Use_decl_annotations_ EXTERN_C static void VmxpHandleRdtscp(
    GUEST_CONTEXT *GuestContext) {
  unsigned int tscAux = 0;
  ULARGE_INTEGER tsc = {};
  tsc.QuadPart = __rdtscp(&tscAux);
  GuestContext->GpRegs->rdx = tsc.HighPart;
  GuestContext->GpRegs->rax =
      tsc.LowPart & 0xffffff00;  // Drop lowest 8 bits for demo
  GuestContext->GpRegs->rcx = tscAux;

  VmxpAdjustGuestInstructionPointer(GuestContext->Rip);
}

// XSETBV. It is executed at the time of system resuming
_Use_decl_annotations_ EXTERN_C static void VmxpHandleXsetbv(
    GUEST_CONTEXT *GuestContext) {
  AsmXsetbv(static_cast<ULONG>(GuestContext->GpRegs->rcx),
            static_cast<ULONG>(GuestContext->GpRegs->rdx),
            static_cast<ULONG>(GuestContext->GpRegs->rax));

  VmxpAdjustGuestInstructionPointer(GuestContext->Rip);
}

// RDMSR
_Use_decl_annotations_ EXTERN_C static void VmxpHandleMsrReadAccess(
    GUEST_CONTEXT *GuestContext) {
  VmxpHandleMsrAccess(GuestContext, true);
}

// WRMSR
_Use_decl_annotations_ EXTERN_C static void VmxpHandleMsrWriteAccess(
    GUEST_CONTEXT *GuestContext) {
  VmxpHandleMsrAccess(GuestContext, false);
}

// RDMSR and WRMSR
_Use_decl_annotations_ EXTERN_C static void VmxpHandleMsrAccess(
    GUEST_CONTEXT *GuestContext, bool ReadAccess) {
  size_t vmcsField = 0;
  switch (GuestContext->GpRegs->rcx) {
    case IA32_SYSENTER_CS:
      vmcsField = GUEST_SYSENTER_CS;
      break;
    case IA32_SYSENTER_ESP:
      vmcsField = GUEST_SYSENTER_ESP;
      break;
    case IA32_SYSENTER_EIP:
      vmcsField = GUEST_SYSENTER_EIP;
      break;
    case IA32_GS_BASE:
      vmcsField = GUEST_GS_BASE;
      break;
    case IA32_FS_BASE:
      vmcsField = GUEST_FS_BASE;
      break;
    default:
      break;
  }

  // This unconditional __readmsr and __writemsr can cause #GP resulting in bug
  // check. A proper way to solve this is check supported MSR values beforehand
  // and inject an exception when unsupported MSR values are given.
  LARGE_INTEGER msrValue = {};
  if (ReadAccess) {
    if (vmcsField) {
      msrValue.QuadPart = VmxpVmRead(vmcsField);
    } else {
      msrValue.QuadPart =
          __readmsr(static_cast<ULONG>(GuestContext->GpRegs->rcx));
    }
    GuestContext->GpRegs->rax = msrValue.LowPart;
    GuestContext->GpRegs->rdx = msrValue.HighPart;

    // Log when the guest is in an interesting address
    if (MiscIsInterestingAddress(GuestContext->Rip)) {
      LOG_INFO_SAFE("GuestRip= %p, RDMSR(%p)", GuestContext->Rip,
                    GuestContext->GpRegs->rcx);
    }
  } else {
    msrValue.LowPart = static_cast<ULONG>(GuestContext->GpRegs->rax);
    msrValue.HighPart = static_cast<ULONG>(GuestContext->GpRegs->rdx);
    if (vmcsField) {
      VmxpVmWrite(vmcsField, msrValue.QuadPart);
    } else {
      __writemsr(static_cast<ULONG>(GuestContext->GpRegs->rcx),
                 msrValue.QuadPart);
    }
  }

  VmxpAdjustGuestInstructionPointer(GuestContext->Rip);
}

// LIDT, SIDT, LGDT and SGDT
_Use_decl_annotations_ EXTERN_C static void VmxpHandleGdtrOrIdtrAccess(
    GUEST_CONTEXT *GuestContext) {
  const GDTR_OR_IDTR_ACCESS_QUALIFICATION exitQualification = {
      static_cast<ULONG32>(VmxpVmRead(VMX_INSTRUCTION_INFO))};

  NT_ASSERT(exitQualification.Fields.AddressSize != BIT_16);
  NT_ASSERT(exitQualification.Fields.OperandSize == BIT_32);

  // Calculate an address to be used for the instruction
  const auto displacement = VmxpVmRead(EXIT_QUALIFICATION);

  // Base
  ULONG_PTR baseValue = 0;
  if (!exitQualification.Fields.BaseRegisterInvalid) {
    const auto registerUsed =
        VmxpSelectRegister(exitQualification.Fields.BaseRegister, GuestContext);
    baseValue = *registerUsed;
  }

  // Index
  ULONG_PTR indexValue = 0;
  if (!exitQualification.Fields.IndexRegisterInvalid) {
    const auto registerUsed = VmxpSelectRegister(
        exitQualification.Fields.IndexRegister, GuestContext);
    indexValue = *registerUsed;
    switch (exitQualification.Fields.Scalling) {
      // clang-format off
    case NO_SCALING: indexValue = indexValue; break;
    case SCALE_BY_2: indexValue = indexValue * 2; break;
    case SCALE_BY_4: indexValue = indexValue * 4; break;
    case SCALE_BY_8: indexValue = indexValue * 8; break;
    default: break;
        // clang-format on
    }
  }

  auto operationAddress = baseValue + indexValue + displacement;
  if (exitQualification.Fields.AddressSize == BIT_32) {
    operationAddress &= 0xffffffff;
  }

  // Emulate the instruction
  auto descriptorTableReg = reinterpret_cast<IDTR *>(operationAddress);
  switch (exitQualification.Fields.InstructionIdentity) {
    case SGDT:
      descriptorTableReg->Address = VmxpVmRead(GUEST_GDTR_BASE);
      descriptorTableReg->Limit =
          static_cast<unsigned short>(VmxpVmRead(GUEST_GDTR_LIMIT));
      break;
    case SIDT:
      descriptorTableReg->Address = VmxpVmRead(GUEST_IDTR_BASE);
      descriptorTableReg->Limit =
          static_cast<unsigned short>(VmxpVmRead(GUEST_IDTR_LIMIT));
      break;
    case LGDT:
      VmxpVmWrite(GUEST_GDTR_BASE, descriptorTableReg->Address);
      VmxpVmWrite(GUEST_GDTR_LIMIT, descriptorTableReg->Limit);
      break;
    case LIDT:
      VmxpVmWrite(GUEST_IDTR_BASE, descriptorTableReg->Address);
      VmxpVmWrite(GUEST_IDTR_LIMIT, descriptorTableReg->Limit);
      break;
  }

  // Log when the guest is in an interesting address
  if (MiscIsInterestingAddress(GuestContext->Rip)) {
    LOG_INFO_SAFE(
        "GuestRip= %p, %s%sDT(Base=%p, Limit=%04X, at %p)", GuestContext->Rip,
        ((exitQualification.Fields.InstructionIdentity & 2) ? "L" : "S"),
        ((exitQualification.Fields.InstructionIdentity & 1) ? "I" : "G"),
        descriptorTableReg->Address, descriptorTableReg->Limit,
        operationAddress);
  }

  VmxpAdjustGuestInstructionPointer(GuestContext->Rip);
}

// LLDT, LTR, SLDT, and STR
_Use_decl_annotations_ EXTERN_C static void VmxpHandleLdtrOrTrAccess(
    GUEST_CONTEXT *GuestContext) {
  const LDTR_OR_TR_ACCESS_QUALIFICATION exitQualification = {
      static_cast<ULONG32>(VmxpVmRead(VMX_INSTRUCTION_INFO))};

  // Calculate an address or a register to be used for the instruction
  const auto displacement = VmxpVmRead(EXIT_QUALIFICATION);

  ULONG_PTR operationAddress = 0;
  if (exitQualification.Fields.RegisterAccess) {
    // Register
    const auto registerUsed =
        VmxpSelectRegister(exitQualification.Fields.Register1, GuestContext);
    operationAddress = reinterpret_cast<ULONG_PTR>(registerUsed);
  } else {
    // Base
    ULONG_PTR baseValue = 0;
    if (!exitQualification.Fields.BaseRegisterInvalid) {
      const auto registerUsed = VmxpSelectRegister(
          exitQualification.Fields.BaseRegister, GuestContext);
      baseValue = *registerUsed;
    }

    // Index
    ULONG_PTR indexValue = 0;
    if (!exitQualification.Fields.IndexRegisterInvalid) {
      const auto registerUsed = VmxpSelectRegister(
          exitQualification.Fields.IndexRegister, GuestContext);
      indexValue = *registerUsed;
      switch (exitQualification.Fields.Scalling) {
        // clang-format off
      case NO_SCALING: indexValue = indexValue; break;
      case SCALE_BY_2: indexValue = indexValue * 2; break;
      case SCALE_BY_4: indexValue = indexValue * 4; break;
      case SCALE_BY_8: indexValue = indexValue * 8; break;
      default: break;
          // clang-format on
      }
    }

    operationAddress = baseValue + indexValue + displacement;
    if (exitQualification.Fields.AddressSize == BIT_32) {
      operationAddress &= 0xffffffff;
    }
  }

  // Emulate the instruction
  auto selector = reinterpret_cast<USHORT *>(operationAddress);
  switch (exitQualification.Fields.InstructionIdentity) {
    case SLDT:
      *selector = static_cast<USHORT>(VmxpVmRead(GUEST_LDTR_SELECTOR));
      break;
    case STR:
      *selector = static_cast<USHORT>(VmxpVmRead(GUEST_TR_SELECTOR));
      break;
    case LLDT:
      VmxpVmWrite(GUEST_LDTR_SELECTOR, *selector);
      break;
    case LTR:
      VmxpVmWrite(GUEST_TR_SELECTOR, *selector);
      break;
  }

  VmxpAdjustGuestInstructionPointer(GuestContext->Rip);
}

// MOV to / from DRx
_Use_decl_annotations_ EXTERN_C static void VmxpHandleDrAccess(
    GUEST_CONTEXT *GuestContext) {
  const MOV_DR_QUALIFICATION exitQualification = {
      VmxpVmRead(EXIT_QUALIFICATION)};
  const auto registerUsed =
      VmxpSelectRegister(exitQualification.Fields.Register, GuestContext);

  // Log when the guest is in an interesting address
  if (MiscIsInterestingAddress(GuestContext->Rip)) {
    LOG_INFO_SAFE(
        "GuestRip= %p, DR=%d, %s, Register=%2d (%p)", GuestContext->Rip,
        exitQualification.Fields.DebuglRegister,
        ((exitQualification.Fields.Direction == MOVE_TO_DR) ? "Write"
                                                            : "Read "),
        exitQualification.Fields.Register, *registerUsed);
  }

  // Emulate the instruction
  switch (exitQualification.Fields.Direction) {
    case MOVE_TO_DR:
      switch (exitQualification.Fields.DebuglRegister) {
        // clang-format off
        case 0: __writedr(0, *registerUsed); break;
        case 1: __writedr(1, *registerUsed); break;
        case 2: __writedr(2, *registerUsed); break;
        case 3: __writedr(3, *registerUsed); break;
        case 4: __writedr(4, *registerUsed); break;
        case 5: __writedr(5, *registerUsed); break;
        case 6: __writedr(6, *registerUsed); break;
        case 7: __writedr(7, *registerUsed); break;
        default: break;
          // clang-format on
      }
      break;
    case MOVE_FROM_DR:
      switch (exitQualification.Fields.DebuglRegister) {
        // clang-format off
        case 0: *registerUsed = __readdr(0); break;
        case 1: *registerUsed = __readdr(1); break;
        case 2: *registerUsed = __readdr(2); break;
        case 3: *registerUsed = __readdr(3); break;
        case 4: *registerUsed = __readdr(4); break;
        case 5: *registerUsed = __readdr(5); break;
        case 6: *registerUsed = __readdr(6); break;
        case 7: *registerUsed = __readdr(7); break;
        default: break;
          // clang-format on
      }
      break;
    default:
      /* UNREACHABLE */
      DBG_BREAK();
      break;
  }

  VmxpAdjustGuestInstructionPointer(GuestContext->Rip);
}

// MOV to / from CRx
_Use_decl_annotations_ EXTERN_C static void VmxpHandleCrAccess(
    GUEST_CONTEXT *GuestContext) {
  const MOV_CR_QUALIFICATION exitQualification = {
      VmxpVmRead(EXIT_QUALIFICATION)};

  const auto registerUsed =
      VmxpSelectRegister(exitQualification.Fields.Register, GuestContext);

  bool wantToContinue = true;
  switch (exitQualification.Fields.AccessType) {
    case MOVE_TO_CR: {
      switch (exitQualification.Fields.ControlRegister) {
        // CR0 <- Reg
        case 0:
          // Log when the guest is in an interesting address
          if (MiscIsInterestingAddress(GuestContext->Rip)) {
            const CR0_REG cr0current = {VmxpVmRead(GUEST_CR0)};
            const CR0_REG cr0requested = {*registerUsed};
            // And WP is being changed
            if (cr0current.Fields.WP != cr0requested.Fields.WP) {
              LOG_INFO_SAFE("GuestRip= %p, CR0WP Modification %p(%d) -> %p(%d)",
                            GuestContext->Rip, cr0current.All,
                            cr0current.Fields.WP, cr0requested.All,
                            cr0requested.Fields.WP);
              // Stop execution when WP is being enabled and the current context
              // seems to be interesting as well.
              if (!cr0current.Fields.WP && cr0requested.Fields.WP &&
                  MiscIsInterestingContext(GuestContext->GpRegs)) {
                DBG_BREAK();
                wantToContinue = false;
              }
            }
          }
          VmxpVmWrite(GUEST_CR0, *registerUsed);
          VmxpVmWrite(CR0_READ_SHADOW, *registerUsed);
          break;

        // CR3 <- Reg
        case 3:
          // Log when the guest is in an interesting address
          if (MiscIsInterestingAddress(GuestContext->Rip)) {
            // And values of current and requested CR3 are the same
            if (VmxpVmRead(GUEST_CR3) == *registerUsed) {
              LOG_INFO_SAFE("GuestRip= %p, TLB Flush with CR3 %p",
                            GuestContext->Rip, *registerUsed);
            }
          }
          VmxpVmWrite(GUEST_CR3, *registerUsed);
          break;

        // CR4 <- Reg
        case 4:
          // Log when the guest is in an interesting address
          if (MiscIsInterestingAddress(GuestContext->Rip)) {
            const CR4_REG cr4current = {VmxpVmRead(GUEST_CR4)};
            const CR4_REG cr4requested = {*registerUsed};
            // And PGE is being changed
            if (cr4current.Fields.PGE != cr4requested.Fields.PGE) {
              LOG_INFO_SAFE("GuestRip= %p, TLB Flush with CR4 %p(%d) -> %p(%d)",
                            GuestContext->Rip, cr4current.All,
                            cr4current.Fields.PGE, cr4requested.All,
                            cr4requested.Fields.PGE);
            }
          }
          VmxpVmWrite(GUEST_CR4, *registerUsed);
          VmxpVmWrite(CR4_READ_SHADOW, *registerUsed);
          break;

        // CR8 <- Reg
        case 8:
          // Log when the guest is in an interesting address
          if (MiscIsInterestingAddress(GuestContext->Rip)) {
            // And CR8 is being raised to any of certain values
            if (*registerUsed > GuestContext->Cr8 &&
                (*registerUsed == DISPATCH_LEVEL ||
                 *registerUsed == HIGH_LEVEL)) {
              LOG_INFO_SAFE("GuestRip= %p, CR8 %d -> %d", GuestContext->Rip,
                            GuestContext->Cr8, *registerUsed);
            }
          }
          GuestContext->Cr8 = *registerUsed;
          break;

        default:
          /* UNREACHABLE */
          DBG_BREAK();
          break;
      }
    } break;

    // Note that MOV from CRx should never cause VM-exit with the current
    // settings. This is just for case when you enable it.
    case MOVE_FROM_CR: {
      switch (exitQualification.Fields.ControlRegister) {
        // Reg <- CR3
        case 3:
          *registerUsed = VmxpVmRead(GUEST_CR3);
          break;

        // Reg <- CR8
        case 8:
          *registerUsed = GuestContext->Cr8;
          break;

        default:
          /* UNREACHABLE */
          DBG_BREAK();
          break;
      }
    } break;

    // Unimplemented
    case CLTS:
    case LMSW:
    default:
      DBG_BREAK();
      break;
  }

  if (wantToContinue) {
    // Just continue as usual
    VmxpAdjustGuestInstructionPointer(GuestContext->Rip);
  } else {
    //
    // Detected a PatchGuard context and want to stop its execution.
    //
    // Here we assume that the detected PatchGuard context is running on the 2nd
    // validation routine and not the 1st, DPC routine. Since AsmWaitForever()
    // lower IRQL forcibly, calling it from the DPC routine results in bug
    // check.
    //
    // In this PoC project, it does not support termination from the DPC
    // routine,
    // but it is still safe because the DPC routine checks only very critical
    // aspects for PatchGuard itself (such as ExQueueWorkItem() and
    // ExpWorkerThread()), and the demo does not modify any of them, thus, the
    // DPC routine will never detect corruption and modify CR0.
    //
    // If you want to kill the context at the DPC routine, you could disassemble
    // the return address and modify code to let the context return without
    // doing anything devastating.
    //
    VmxpVmWrite(GUEST_RIP, reinterpret_cast<ULONG_PTR>(AsmWaitForever));
  }
}

// VMX instructions except for VMCALL
_Use_decl_annotations_ EXTERN_C static void VmxpHandleVmx(
    GUEST_CONTEXT *GuestContext) {
  // CONVENTIONS
  GuestContext->Rflags.Fields.CF = true;  // Error without status
  GuestContext->Rflags.Fields.PF = false;
  GuestContext->Rflags.Fields.AF = false;
  GuestContext->Rflags.Fields.ZF = false;  // Error without status
  GuestContext->Rflags.Fields.SF = false;
  GuestContext->Rflags.Fields.OF = false;
  VmxpVmWrite(GUEST_RFLAGS, GuestContext->Rflags.All);
  VmxpAdjustGuestInstructionPointer(GuestContext->Rip);
}

// VMCALL
_Use_decl_annotations_ EXTERN_C static void VmxpHandleVmCall(
    GUEST_CONTEXT *GuestContext) {
  // VMCALL for Sushi expects that rcx holds a command number, and rdx holds an
  // address of a context parameter optionally
  const auto hypercallNumber = GuestContext->GpRegs->rcx;
  const auto context = reinterpret_cast<void *>(GuestContext->GpRegs->rdx);

  if (hypercallNumber == SUSHI_BACKDOOR_CODE) {
    // Unloading requested
    DBG_BREAK();

    // The processor sets ffff to limits of IDT and GDT when VM-exit occurred.
    // It is not correct value but fine to ignore since vmresume loads correct
    // values from VMCS. But here, we are going to skip vmresume and simply
    // return to where VMCALL is executed. It results in keeping those broken
    // values and ends up with bug check 109, so we should fix them manually.
    const auto gdtLimit = VmxpVmRead(GUEST_GDTR_LIMIT);
    const auto gdtBase = VmxpVmRead(GUEST_GDTR_BASE);
    const auto idtLimit = VmxpVmRead(GUEST_IDTR_LIMIT);
    const auto idtBase = VmxpVmRead(GUEST_IDTR_BASE);
    GDTR gdtr = {static_cast<USHORT>(gdtLimit), gdtBase};
    IDTR idtr = {static_cast<USHORT>(idtLimit), idtBase};
    __lgdt(&gdtr);
    __lidt(&idtr);

    // Store an address of the management structure to the context parameter
    const auto resultPtr = reinterpret_cast<PER_PROCESSOR_DATA **>(context);
    *resultPtr = GuestContext->Stack->ProcessorData;
    LOG_DEBUG_SAFE("context at %p %p", context,
                   GuestContext->Stack->ProcessorData);

    // Set rip to the next instruction of VMCALL
    const auto exitInstructionLength = VmxpVmRead(VM_EXIT_INSTRUCTION_LEN);
    const auto addressToReturn = GuestContext->Rip + exitInstructionLength;

    // Since rflags is overwritten after VMXOFF, we should manually indicates
    // that VMCALL was successful by clearing those flags.
    GuestContext->Rflags.Fields.CF = false;
    GuestContext->Rflags.Fields.ZF = false;

    // Set registers used after VMXOFF to recover the context
    GuestContext->GpRegs->rcx = addressToReturn;
    GuestContext->GpRegs->rdx = GuestContext->GpRegs->rsp;
    GuestContext->GpRegs->r8 = GuestContext->Rflags.All;
    GuestContext->VmContinue = false;

  } else {
    // Unsupported hypercall. Handle like other VMX instructions
    VmxpHandleVmx(GuestContext);
  }
}

// INVD
_Use_decl_annotations_ EXTERN_C static void VmxpHandleInvalidateInternalCaches(
    GUEST_CONTEXT *GuestContext) {
  AsmInvalidateInternalCaches();
  VmxpAdjustGuestInstructionPointer(GuestContext->Rip);
}

// Selects a register to be used based on the Index
_Use_decl_annotations_ EXTERN_C static ULONG_PTR *VmxpSelectRegister(
    ULONG Index, GUEST_CONTEXT *GuestContext) {
  ULONG_PTR *registerUsed = nullptr;
  switch (Index) {
    // clang-format off
  case 0: registerUsed = &GuestContext->GpRegs->rax; break;
  case 1: registerUsed = &GuestContext->GpRegs->rcx; break;
  case 2: registerUsed = &GuestContext->GpRegs->rdx; break;
  case 3: registerUsed = &GuestContext->GpRegs->rbx; break;
  case 4: registerUsed = &GuestContext->GpRegs->rsp; break;
  case 5: registerUsed = &GuestContext->GpRegs->rbp; break;
  case 6: registerUsed = &GuestContext->GpRegs->rsi; break;
  case 7: registerUsed = &GuestContext->GpRegs->rdi; break;
  case 8: registerUsed = &GuestContext->GpRegs->r8; break;
  case 9: registerUsed = &GuestContext->GpRegs->r9; break;
  case 10: registerUsed = &GuestContext->GpRegs->r10; break;
  case 11: registerUsed = &GuestContext->GpRegs->r11; break;
  case 12: registerUsed = &GuestContext->GpRegs->r12; break;
  case 13: registerUsed = &GuestContext->GpRegs->r13; break;
  case 14: registerUsed = &GuestContext->GpRegs->r14; break;
  case 15: registerUsed = &GuestContext->GpRegs->r15; break;
  default: DBG_BREAK(); break;
      // clang-format on
  }
  return registerUsed;
}

// Dumps guest's selectors
_Use_decl_annotations_ EXTERN_C static void VmxpDumpGuestSelectors() {
  LOG_DEBUG_SAFE("es %04x %p %08x %08x", VmxpVmRead(GUEST_ES_SELECTOR),
                 VmxpVmRead(GUEST_ES_BASE), VmxpVmRead(GUEST_ES_LIMIT),
                 VmxpVmRead(GUEST_ES_AR_BYTES));
  LOG_DEBUG_SAFE("cs %04x %p %08x %08x", VmxpVmRead(GUEST_CS_SELECTOR),
                 VmxpVmRead(GUEST_CS_BASE), VmxpVmRead(GUEST_CS_LIMIT),
                 VmxpVmRead(GUEST_CS_AR_BYTES));
  LOG_DEBUG_SAFE("ss %04x %p %08x %08x", VmxpVmRead(GUEST_SS_SELECTOR),
                 VmxpVmRead(GUEST_SS_BASE), VmxpVmRead(GUEST_SS_LIMIT),
                 VmxpVmRead(GUEST_SS_AR_BYTES));
  LOG_DEBUG_SAFE("ds %04x %p %08x %08x", VmxpVmRead(GUEST_DS_SELECTOR),
                 VmxpVmRead(GUEST_DS_BASE), VmxpVmRead(GUEST_DS_LIMIT),
                 VmxpVmRead(GUEST_DS_AR_BYTES));
  LOG_DEBUG_SAFE("fs %04x %p %08x %08x", VmxpVmRead(GUEST_FS_SELECTOR),
                 VmxpVmRead(GUEST_FS_BASE), VmxpVmRead(GUEST_FS_LIMIT),
                 VmxpVmRead(GUEST_FS_AR_BYTES));
  LOG_DEBUG_SAFE("gs %04x %p %08x %08x", VmxpVmRead(GUEST_GS_SELECTOR),
                 VmxpVmRead(GUEST_GS_BASE), VmxpVmRead(GUEST_GS_LIMIT),
                 VmxpVmRead(GUEST_GS_AR_BYTES));
  LOG_DEBUG_SAFE("ld %04x %p %08x %08x", VmxpVmRead(GUEST_LDTR_SELECTOR),
                 VmxpVmRead(GUEST_LDTR_BASE), VmxpVmRead(GUEST_LDTR_LIMIT),
                 VmxpVmRead(GUEST_LDTR_AR_BYTES));
  LOG_DEBUG_SAFE("tr %04x %p %08x %08x", VmxpVmRead(GUEST_TR_SELECTOR),
                 VmxpVmRead(GUEST_TR_BASE), VmxpVmRead(GUEST_TR_LIMIT),
                 VmxpVmRead(GUEST_TR_AR_BYTES));
}

// A wrapper for vmx_vmread
_Use_decl_annotations_ EXTERN_C static SIZE_T VmxpVmRead(SIZE_T Field) {
  size_t fieldValue = 0;
  const auto vmxStatus =
      static_cast<VMX_STATUS>(__vmx_vmread(Field, &fieldValue));
  if (vmxStatus != VMX_OK) {
    LOG_ERROR_SAFE("__vmx_vmread(0x%08x) failed with an error %d", Field,
                   vmxStatus);
    DBG_BREAK();
  }
  return fieldValue;
}

// A wrapper for vmx_vmwrite
_Use_decl_annotations_ EXTERN_C static VMX_STATUS VmxpVmWrite(
    SIZE_T Field, SIZE_T FieldValue) {
  const auto vmxStatus =
      static_cast<VMX_STATUS>(__vmx_vmwrite(Field, FieldValue));
  if (vmxStatus != VMX_OK) {
    LOG_ERROR_SAFE("__vmx_vmwrite(0x%08x) failed with an error %d", Field,
                   vmxStatus);
    DBG_BREAK();
  }
  return vmxStatus;
}

// Sets rip to the next instruction
_Use_decl_annotations_ EXTERN_C static void VmxpAdjustGuestInstructionPointer(
    ULONG_PTR GuestRip) {
  const auto exitInstructionLength = VmxpVmRead(VM_EXIT_INSTRUCTION_LEN);
  VmxpVmWrite(GUEST_RIP, GuestRip + exitInstructionLength);
}

```

`Sushi/Sushi/vmx.h`:

```h
// Copyright (c) 2015, tandasat. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

//
// This module declares interfaces to VMM functions.
//
#pragma once

////////////////////////////////////////////////////////////////////////////////
//
// macro utilities
//

////////////////////////////////////////////////////////////////////////////////
//
// constants and macros
//

////////////////////////////////////////////////////////////////////////////////
//
// types
//

////////////////////////////////////////////////////////////////////////////////
//
// prototypes
//

////////////////////////////////////////////////////////////////////////////////
//
// variables
//

////////////////////////////////////////////////////////////////////////////////
//
// implementations
//

```

`Sushi/Sushi/vmx_type.h`:

```h
// Copyright (c) 2015, tandasat. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

//
// This module defines constants and structures related to VMX features
//
#pragma once

////////////////////////////////////////////////////////////////////////////////
//
// macro utilities
//

////////////////////////////////////////////////////////////////////////////////
//
// constants and macros
//

// OVERVIEW
static const SIZE_T MAXIMUM_VMCS_SIZE = 4096;

enum VMX_STATUS : unsigned char {
  VMX_OK = 0,
  VMX_ERROR_WITH_STATUS = 1,
  VMX_ERROR_WITHOUT_STATUS = 2,
};

// FIELD ENCODING IN VMCS
enum VMCS_ENCODE {
  VIRTUAL_PROCESSOR_ID = 0x00000000,  // 16-Bit Control Field
  POSTED_INTERRUPT_NOTIFICATION = 0x00000002,
  EPTP_INDEX = 0x00000004,
  GUEST_ES_SELECTOR = 0x00000800,  // 16-Bit Guest-State Fields
  GUEST_CS_SELECTOR = 0x00000802,
  GUEST_SS_SELECTOR = 0x00000804,
  GUEST_DS_SELECTOR = 0x00000806,
  GUEST_FS_SELECTOR = 0x00000808,
  GUEST_GS_SELECTOR = 0x0000080a,
  GUEST_LDTR_SELECTOR = 0x0000080c,
  GUEST_TR_SELECTOR = 0x0000080e,
  GUEST_INTERRUPT_STATUS = 0x00000810,
  HOST_ES_SELECTOR = 0x00000c00,  // 16-Bit Host-State Fields
  HOST_CS_SELECTOR = 0x00000c02,
  HOST_SS_SELECTOR = 0x00000c04,
  HOST_DS_SELECTOR = 0x00000c06,
  HOST_FS_SELECTOR = 0x00000c08,
  HOST_GS_SELECTOR = 0x00000c0a,
  HOST_TR_SELECTOR = 0x00000c0c,
  IO_BITMAP_A = 0x00002000,  // 64-Bit Control Fields
  IO_BITMAP_A_HIGH = 0x00002001,
  IO_BITMAP_B = 0x00002002,
  IO_BITMAP_B_HIGH = 0x00002003,
  MSR_BITMAP = 0x00002004,
  MSR_BITMAP_HIGH = 0x00002005,
  VM_EXIT_MSR_STORE_ADDR = 0x00002006,
  VM_EXIT_MSR_STORE_ADDR_HIGH = 0x00002007,
  VM_EXIT_MSR_LOAD_ADDR = 0x00002008,
  VM_EXIT_MSR_LOAD_ADDR_HIGH = 0x00002009,
  VM_ENTRY_MSR_LOAD_ADDR = 0x0000200a,
  VM_ENTRY_MSR_LOAD_ADDR_HIGH = 0x0000200b,
  EXECUTIVE_VMCS_POINTER = 0x0000200c,
  EXECUTIVE_VMCS_POINTER_HIGH = 0x0000200d,
  TSC_OFFSET = 0x00002010,
  TSC_OFFSET_HIGH = 0x00002011,
  VIRTUAL_APIC_PAGE_ADDR = 0x00002012,
  VIRTUAL_APIC_PAGE_ADDR_HIGH = 0x00002013,
  APIC_ACCESS_ADDR = 0x00002014,
  APIC_ACCESS_ADDR_HIGH = 0x00002015,
  EPT_POINTER = 0x0000201a,
  EPT_POINTER_HIGH = 0x0000201b,
  EOI_EXIT_BITMAP_0 = 0x0000201c,
  EOI_EXIT_BITMAP_0_HIGH = 0x0000201d,
  EOI_EXIT_BITMAP_1 = 0x0000201e,
  EOI_EXIT_BITMAP_1_HIGH = 0x0000201f,
  EOI_EXIT_BITMAP_2 = 0x00002020,
  EOI_EXIT_BITMAP_2_HIGH = 0x00002021,
  EOI_EXIT_BITMAP_3 = 0x00002022,
  EOI_EXIT_BITMAP_3_HIGH = 0x00002023,
  EPTP_LIST_ADDRESS = 0x00002024,
  EPTP_LIST_ADDRESS_HIGH = 0x00002025,
  VMREAD_BITMAP_ADDRESS = 0x00002026,
  VMREAD_BITMAP_ADDRESS_HIGH = 0x00002027,
  VMWRITE_BITMAP_ADDRESS = 0x00002028,
  VMWRITE_BITMAP_ADDRESS_HIGH = 0x00002029,
  VIRTUALIZATION_EXCEPTION_INFO_ADDDRESS = 0x0000202a,
  VIRTUALIZATION_EXCEPTION_INFO_ADDDRESS_HIGH = 0x0000202b,
  XSS_EXITING_BITMAP = 0x0000202c,
  XSS_EXITING_BITMAP_HIGH = 0x0000202d,
  GUEST_PHYSICAL_ADDRESS = 0x00002400,  // 64-Bit Read-Only Data Field
  GUEST_PHYSICAL_ADDRESS_HIGH = 0x00002401,
  VMCS_LINK_POINTER = 0x00002800,  // 64-Bit Guest-State Fields
  VMCS_LINK_POINTER_HIGH = 0x00002801,
  GUEST_IA32_DEBUGCTL = 0x00002802,
  GUEST_IA32_DEBUGCTL_HIGH = 0x00002803,
  GUEST_IA32_PAT = 0x00002804,
  GUEST_IA32_PAT_HIGH = 0x00002805,
  GUEST_IA32_EFER = 0x00002806,
  GUEST_IA32_EFER_HIGH = 0x00002807,
  GUEST_IA32_PERF_GLOBAL_CTRL = 0x00002808,
  GUEST_IA32_PERF_GLOBAL_CTRL_HIGH = 0x00002809,
  GUEST_PDPTR0 = 0x0000280a,
  GUEST_PDPTR0_HIGH = 0x0000280b,
  GUEST_PDPTR1 = 0x0000280c,
  GUEST_PDPTR1_HIGH = 0x0000280d,
  GUEST_PDPTR2 = 0x0000280e,
  GUEST_PDPTR2_HIGH = 0x0000280f,
  GUEST_PDPTR3 = 0x00002810,
  GUEST_PDPTR3_HIGH = 0x00002811,
  HOST_IA32_PAT = 0x00002c00,  // 64-Bit Host-State Fields
  HOST_IA32_PAT_HIGH = 0x00002c01,
  HOST_IA32_EFER = 0x00002c02,
  HOST_IA32_EFER_HIGH = 0x00002c03,
  HOST_IA32_PERF_GLOBAL_CTRL = 0x00002c04,
  HOST_IA32_PERF_GLOBAL_CTRL_HIGH = 0x00002c05,
  PIN_BASED_VM_EXEC_CONTROL = 0x00004000,  // 32-Bit Control Fields
  CPU_BASED_VM_EXEC_CONTROL = 0x00004002,
  EXCEPTION_BITMAP = 0x00004004,
  PAGE_FAULT_ERROR_CODE_MASK = 0x00004006,
  PAGE_FAULT_ERROR_CODE_MATCH = 0x00004008,
  CR3_TARGET_COUNT = 0x0000400a,
  VM_EXIT_CONTROLS = 0x0000400c,
  VM_EXIT_MSR_STORE_COUNT = 0x0000400e,
  VM_EXIT_MSR_LOAD_COUNT = 0x00004010,
  VM_ENTRY_CONTROLS = 0x00004012,
  VM_ENTRY_MSR_LOAD_COUNT = 0x00004014,
  VM_ENTRY_INTR_INFO_FIELD = 0x00004016,
  VM_ENTRY_EXCEPTION_ERROR_CODE = 0x00004018,
  VM_ENTRY_INSTRUCTION_LEN = 0x0000401a,
  TPR_THRESHOLD = 0x0000401c,
  SECONDARY_VM_EXEC_CONTROL = 0x0000401e,
  PLE_GAP = 0x00004020,
  PLE_WINDOW = 0x00004022,
  VM_INSTRUCTION_ERROR = 0x00004400,  // 32-Bit Read-Only Data Fields
  VM_EXIT_REASON = 0x00004402,
  VM_EXIT_INTR_INFO = 0x00004404,
  VM_EXIT_INTR_ERROR_CODE = 0x00004406,
  IDT_VECTORING_INFO_FIELD = 0x00004408,
  IDT_VECTORING_ERROR_CODE = 0x0000440a,
  VM_EXIT_INSTRUCTION_LEN = 0x0000440c,
  VMX_INSTRUCTION_INFO = 0x0000440e,
  GUEST_ES_LIMIT = 0x00004800,  // 32-Bit Guest-State Fields
  GUEST_CS_LIMIT = 0x00004802,
  GUEST_SS_LIMIT = 0x00004804,
  GUEST_DS_LIMIT = 0x00004806,
  GUEST_FS_LIMIT = 0x00004808,
  GUEST_GS_LIMIT = 0x0000480a,
  GUEST_LDTR_LIMIT = 0x0000480c,
  GUEST_TR_LIMIT = 0x0000480e,
  GUEST_GDTR_LIMIT = 0x00004810,
  GUEST_IDTR_LIMIT = 0x00004812,
  GUEST_ES_AR_BYTES = 0x00004814,
  GUEST_CS_AR_BYTES = 0x00004816,
  GUEST_SS_AR_BYTES = 0x00004818,
  GUEST_DS_AR_BYTES = 0x0000481a,
  GUEST_FS_AR_BYTES = 0x0000481c,
  GUEST_GS_AR_BYTES = 0x0000481e,
  GUEST_LDTR_AR_BYTES = 0x00004820,
  GUEST_TR_AR_BYTES = 0x00004822,
  GUEST_INTERRUPTIBILITY_INFO = 0x00004824,
  GUEST_ACTIVITY_STATE = 0x00004826,
  GUEST_SMBASE = 0x00004828,
  GUEST_SYSENTER_CS = 0x0000482a,
  VMX_PREEMPTION_TIMER_VALUE = 0x0000482e,
  HOST_IA32_SYSENTER_CS = 0x00004c00,  // 32-Bit Host-State Field
  CR0_GUEST_HOST_MASK = 0x00006000,    // Natural-Width Control Fields
  CR4_GUEST_HOST_MASK = 0x00006002,
  CR0_READ_SHADOW = 0x00006004,
  CR4_READ_SHADOW = 0x00006006,
  CR3_TARGET_VALUE0 = 0x00006008,
  CR3_TARGET_VALUE1 = 0x0000600a,
  CR3_TARGET_VALUE2 = 0x0000600c,
  CR3_TARGET_VALUE3 = 0x0000600e,
  EXIT_QUALIFICATION = 0x00006400,  // Natural-Width Read-Only Data Fields
  IO_RCX = 0x00006402,
  IO_RSI = 0x00006404,
  IO_RDI = 0x00006406,
  IO_RIP = 0x00006408,
  GUEST_LINEAR_ADDRESS = 0x0000640a,
  GUEST_CR0 = 0x00006800,  // Natural-Width Guest-State Fields
  GUEST_CR3 = 0x00006802,
  GUEST_CR4 = 0x00006804,
  GUEST_ES_BASE = 0x00006806,
  GUEST_CS_BASE = 0x00006808,
  GUEST_SS_BASE = 0x0000680a,
  GUEST_DS_BASE = 0x0000680c,
  GUEST_FS_BASE = 0x0000680e,
  GUEST_GS_BASE = 0x00006810,
  GUEST_LDTR_BASE = 0x00006812,
  GUEST_TR_BASE = 0x00006814,
  GUEST_GDTR_BASE = 0x00006816,
  GUEST_IDTR_BASE = 0x00006818,
  GUEST_DR7 = 0x0000681a,
  GUEST_RSP = 0x0000681c,
  GUEST_RIP = 0x0000681e,
  GUEST_RFLAGS = 0x00006820,
  GUEST_PENDING_DBG_EXCEPTIONS = 0x00006822,
  GUEST_SYSENTER_ESP = 0x00006824,
  GUEST_SYSENTER_EIP = 0x00006826,
  HOST_CR0 = 0x00006c00,  // Natural-Width Host-State Fields
  HOST_CR3 = 0x00006c02,
  HOST_CR4 = 0x00006c04,
  HOST_FS_BASE = 0x00006c06,
  HOST_GS_BASE = 0x00006c08,
  HOST_TR_BASE = 0x00006c0a,
  HOST_GDTR_BASE = 0x00006c0c,
  HOST_IDTR_BASE = 0x00006c0e,
  HOST_IA32_SYSENTER_ESP = 0x00006c10,
  HOST_IA32_SYSENTER_EIP = 0x00006c12,
  HOST_RSP = 0x00006c14,
  HOST_RIP = 0x00006c16
};

// VMX BASIC EXIT REASONS
enum VMX_EXIT_REASON : UINT16 {
  EXIT_REASON_EXCEPTION_NMI = 0,
  EXIT_REASON_EXTERNAL_INTERRUPT = 1,
  EXIT_REASON_TRIPLE_FAULT = 2,
  EXIT_REASON_INIT = 3,
  EXIT_REASON_SIPI = 4,
  EXIT_REASON_IO_SMI = 5,
  EXIT_REASON_OTHER_SMI = 6,
  EXIT_REASON_PENDING_INTERRUPT = 7,
  EXIT_REASON_NMI_WINDOW = 8,
  EXIT_REASON_TASK_SWITCH = 9,
  EXIT_REASON_CPUID = 10,
  EXIT_REASON_GETSEC = 11,
  EXIT_REASON_HLT = 12,
  EXIT_REASON_INVD = 13,
  EXIT_REASON_INVLPG = 14,
  EXIT_REASON_RDPMC = 15,
  EXIT_REASON_RDTSC = 16,
  EXIT_REASON_RSM = 17,
  EXIT_REASON_VMCALL = 18,
  EXIT_REASON_VMCLEAR = 19,
  EXIT_REASON_VMLAUNCH = 20,
  EXIT_REASON_VMPTRLD = 21,
  EXIT_REASON_VMPTRST = 22,
  EXIT_REASON_VMREAD = 23,
  EXIT_REASON_VMRESUME = 24,
  EXIT_REASON_VMWRITE = 25,
  EXIT_REASON_VMOFF = 26,
  EXIT_REASON_VMON = 27,
  EXIT_REASON_CR_ACCESS = 28,
  EXIT_REASON_DR_ACCESS = 29,
  EXIT_REASON_IO_INSTRUCTION = 30,
  EXIT_REASON_MSR_READ = 31,
  EXIT_REASON_MSR_WRITE = 32,
  EXIT_REASON_INVALID_GUEST_STATE = 33,
  EXIT_REASON_MSR_LOADING = 34,
  EXIT_REASON_UNDEFINED_35 = 35,
  EXIT_REASON_MWAIT_INSTRUCTION = 36,
  EXIT_REASON_MONITOR_TRAP_FLAG = 37,
  EXIT_REASON_UNDEFINED_38 = 38,
  EXIT_REASON_MONITOR_INSTRUCTION = 39,
  EXIT_REASON_PAUSE_INSTRUCTION = 40,
  EXIT_REASON_MACHINE_CHECK = 41,
  EXIT_REASON_UNDEFINED_42 = 42,
  EXIT_REASON_TPR_BELOW_THRESHOLD = 43,
  EXIT_REASON_APIC_ACCESS = 44,
  EXIT_REASON_VIRTUALIZED_EOI = 45,
  EXIT_REASON_GDTR_OR_IDTR_ACCESS = 46,
  EXIT_REASON_LDTR_OR_TR_ACCESS = 47,
  EXIT_REASON_EPT_VIOLATION = 48,
  EXIT_REASON_EPT_MISCONFIG = 49,
  EXIT_REASON_INVEPT = 50,
  EXIT_REASON_RDTSCP = 51,
  EXIT_REASON_VMX_PREEMPTION_TIME = 52,
  EXIT_REASON_INVVPID = 53,
  EXIT_REASON_WBINVD = 54,
  EXIT_REASON_XSETBV = 55,
  EXIT_REASON_APIC_WRITE = 56,
  EXIT_REASON_RDRAND = 57,
  EXIT_REASON_INVPCID = 58,
  EXIT_REASON_VMFUNC = 59,
  EXIT_REASON_UNDEFINED_60 = 60,
  EXIT_REASON_RDSEED = 61,
  EXIT_REASON_UNDEFINED_62 = 62,
  EXIT_REASON_XSAVES = 63,
  EXIT_REASON_XRSTORS = 64,
};
static_assert(sizeof(VMX_EXIT_REASON) == 2, "Size check");

// VM-instruction error numbers
enum VMX_ERROR_NUMBERS {
  VMXERR_VMCALL_IN_VMX_ROOT_OPERATION = 1,
  VMXERR_VMCLEAR_INVALID_ADDRESS = 2,
  VMXERR_VMCLEAR_VMXON_POINTER = 3,
  VMXERR_VMLAUNCH_NONCLEAR_VMCS = 4,
  VMXERR_VMRESUME_NONLAUNCHED_VMCS = 5,
  VMXERR_VMRESUME_AFTER_VMXOFF = 6,
  VMXERR_ENTRY_INVALID_CONTROL_FIELD = 7,
  VMXERR_ENTRY_INVALID_HOST_STATE_FIELD = 8,
  VMXERR_VMPTRLD_INVALID_ADDRESS = 9,
  VMXERR_VMPTRLD_VMXON_POINTER = 10,
  VMXERR_VMPTRLD_INCORRECT_VMCS_REVISION_ID = 11,
  VMXERR_UNSUPPORTED_VMCS_COMPONENT = 12,
  VMXERR_VMWRITE_READ_ONLY_VMCS_COMPONENT = 13,
  VMXERR_VMXON_IN_VMX_ROOT_OPERATION = 15,
  VMXERR_ENTRY_INVALID_EXECUTIVE_VMCS_POINTER = 16,
  VMXERR_ENTRY_NONLAUNCHED_EXECUTIVE_VMCS = 17,
  VMXERR_ENTRY_EXECUTIVE_VMCS_POINTER_NOT_VMXON_POINTER = 18,
  VMXERR_VMCALL_NONCLEAR_VMCS = 19,
  VMXERR_VMCALL_INVALID_VM_EXIT_CONTROL_FIELDS = 20,
  VMXERR_VMCALL_INCORRECT_MSEG_REVISION_ID = 22,
  VMXERR_VMXOFF_UNDER_DUAL_MONITOR_TREATMENT_OF_SMIS_AND_SMM = 23,
  VMXERR_VMCALL_INVALID_SMM_MONITOR_FEATURES = 24,
  VMXERR_ENTRY_INVALID_VM_EXECUTION_CONTROL_FIELDS_IN_EXECUTIVE_VMCS = 25,
  VMXERR_ENTRY_EVENTS_BLOCKED_BY_MOV_SS = 26,
  VMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID = 28,
};

////////////////////////////////////////////////////////////////////////////////
//
// types
//

//
// Virtual-Machine Control Structures
// FORMAT OF THE VMCS REGION
//
struct VMCS {
  ULONG RevisionIdentifier;
  ULONG VmxAbortIndicator;
  ULONG Data[1];  // implementation-specific format.
};

//
// Pin-Based VM-Execution Controls
//
union VMX_PIN_BASED_CONTROLS {
  unsigned int All;
  struct {
    unsigned ExternalInterruptExiting : 1;    // [0]
    unsigned Reserved1 : 2;                   // [1-2]
    unsigned NMIExiting : 1;                  // [3]
    unsigned Reserved2 : 1;                   // [4]
    unsigned VirtualNMIs : 1;                 // [5]
    unsigned ActivateVMXPreemptionTimer : 1;  // [6]
    unsigned ProcessPostedInterrupts : 1;     // [7]
  } Fields;
};
static_assert(sizeof(VMX_PIN_BASED_CONTROLS) == 4, "Size check");

union VMX_CPU_BASED_CONTROLS {
  unsigned int All;
  struct {
    unsigned Reserved1 : 2;                 // [0-1]
    unsigned InterruptWindowExiting : 1;    // [2]
    unsigned UseTSCOffseting : 1;           // [3]
    unsigned Reserved2 : 3;                 // [4-6]
    unsigned HLTExiting : 1;                // [7]
    unsigned Reserved3 : 1;                 // [8]
    unsigned INVLPGExiting : 1;             // [9]
    unsigned MWAITExiting : 1;              // [10]
    unsigned RDPMCExiting : 1;              // [11]
    unsigned RDTSCExiting : 1;              // [12]
    unsigned Reserved4 : 2;                 // [13-14]
    unsigned CR3LoadExiting : 1;            // [15]
    unsigned CR3StoreExiting : 1;           // [16]
    unsigned Reserved5 : 2;                 // [17-18]
    unsigned CR8LoadExiting : 1;            // [19]
    unsigned CR8StoreExiting : 1;           // [20]
    unsigned UseTPRShadowExiting : 1;       // [21]
    unsigned NMIWindowExiting : 1;          // [22]
    unsigned MovDRExiting : 1;              // [23]
    unsigned UnconditionalIOExiting : 1;    // [24]
    unsigned UseIOBitmaps : 1;              // [25]
    unsigned Reserved6 : 1;                 // [26]
    unsigned MonitorTrapFlag : 1;           // [27]
    unsigned UseMSRBitmaps : 1;             // [28]
    unsigned MONITORExiting : 1;            // [29]
    unsigned PAUSEExiting : 1;              // [30]
    unsigned ActivateSecondaryControl : 1;  // [31]
  } Fields;
};
static_assert(sizeof(VMX_CPU_BASED_CONTROLS) == 4, "Size check");

union VMX_SECONDARY_CPU_BASED_CONTROLS {
  unsigned int All;
  struct {
    unsigned VirtualizeAPICAccesses : 1;      // [0]
    unsigned EnableEPT : 1;                   // [1]
    unsigned DescriptorTableExiting : 1;      // [2]
    unsigned EnableRDTSCP : 1;                // [3]
    unsigned VirtualizeX2APICMode : 1;        // [4]
    unsigned EnableVPID : 1;                  // [5]
    unsigned WBINVDExiting : 1;               // [6]
    unsigned UnrestrictedGuest : 1;           // [7]
    unsigned APICRegisterVirtualization : 1;  // [8]
    unsigned VirtualInterruptDelivery : 1;    // [9]
    unsigned PAUSELoopExiting : 1;            // [10]
    unsigned RDRANDExiting : 1;               // [11]
    unsigned EnableINVPCID : 1;               // [12]
    unsigned EnableVMFunctions : 1;           // [13]
    unsigned VMCSShadowing : 1;               // [14]
    unsigned Reserved1 : 1;                   // [15]
    unsigned RDSEEDExiting : 1;               // [16]
    unsigned Reserved2 : 1;                   // [17]
    unsigned EPTViolation : 1;                // [18]
    unsigned Reserved3 : 1;                   // [19]
    unsigned EnableXSAVESXSTORS : 1;          // [20]
  } Fields;
};
static_assert(sizeof(VMX_SECONDARY_CPU_BASED_CONTROLS) == 4, "Size check");

union VMX_VM_EXIT_CONTROLS {
  unsigned int All;
  struct {
    unsigned Reserved1 : 2;                    // [0-1]
    unsigned SaveDebugControls : 1;            // [2]
    unsigned Reserved2 : 6;                    // [3-8]
    unsigned HostAddressSpaceSize : 1;         // [9]
    unsigned Reserved3 : 2;                    // [10-11]
    unsigned LoadIA32_PERF_GLOBAL_CTRL : 1;    // [12]
    unsigned Reserved4 : 2;                    // [13-14]
    unsigned AcknowledgeInterruptOnExit : 1;   // [15]
    unsigned Reserved5 : 2;                    // [16-17]
    unsigned SaveIA32_PAT : 1;                 // [18]
    unsigned LoadIA32_PAT : 1;                 // [19]
    unsigned SaveIA32_EFER : 1;                // [20]
    unsigned LoadIA32_EFER : 1;                // [21]
    unsigned SaveVMXPreemptionTimerValue : 1;  // [22]
  } Fields;
};
static_assert(sizeof(VMX_VM_EXIT_CONTROLS) == 4, "Size check");

union VMX_VM_ENTER_CONTROLS {
  unsigned int All;
  struct {
    unsigned Reserved1 : 2;                       // [0-1]
    unsigned LoadDebugControls : 1;               // [2]
    unsigned Reserved2 : 6;                       // [3-8]
    unsigned IA32eModeGuest : 1;                  // [9]
    unsigned EntryToSMM : 1;                      // [10]
    unsigned DeactivateDualMonitorTreatment : 1;  // [11]
    unsigned Reserved3 : 1;                       // [12]
    unsigned LoadIA32_PERF_GLOBAL_CTRL : 1;       // [13]
    unsigned LoadIA32_PAT : 1;                    // [14]
    unsigned LoadIA32_EFER : 1;                   // [15]
  } Fields;
};
static_assert(sizeof(VMX_VM_EXIT_CONTROLS) == 4, "Size check");

//
// Guest Register State
//
union VMX_SEG_DESCRIPTOR_ACCESS_RIGHT {
  unsigned int All;
  struct {
    unsigned Type : 4;
    unsigned System : 1;
    unsigned DPL : 2;
    unsigned Present : 1;
    unsigned Reserved1 : 4;
    unsigned AVL : 1;
    unsigned L : 1;  // Reserved (except for CS) 64-bit mode active (for CS)
    unsigned DB : 1;
    unsigned Gran : 1;
    unsigned Unusable : 1;  // Segment unusable (0 = usable; 1 = unusable)
    unsigned Reserved2 : 15;
  } Fields;
};
static_assert(sizeof(VMX_SEG_DESCRIPTOR_ACCESS_RIGHT) == 4, "Size check");

//
// IA32_FEATURE_CONTROL_MSR
// ARCHITECTURAL MSRS
//
union IA32_FEATURE_CONTROL_MSR {
  unsigned __int64 All;
  struct {
    unsigned Lock : 1;                // [0]
    unsigned EnableSMX : 1;           // [1]
    unsigned EnableVmxon : 1;         // [2]
    unsigned Reserved2 : 5;           // [3-7]
    unsigned EnableLocalSENTER : 7;   // [8-14]
    unsigned EnableGlobalSENTER : 1;  // [15]
    unsigned Reserved3a : 16;         //
    unsigned Reserved3b : 32;         // [16-63]
  } Fields;
};
static_assert(sizeof(IA32_FEATURE_CONTROL_MSR) == 8, "Size check");

//
// IA32_VMX_BASIC_MSR
// BASIC VMX INFORMATION
//
union IA32_VMX_BASIC_MSR {
  unsigned __int64 All;
  struct {
    unsigned RevisionIdentifier : 31;   // [0-30]
    unsigned Reserved1 : 1;             // [31]
    unsigned RegionSize : 12;           // [32-43]
    unsigned RegionClear : 1;           // [44]
    unsigned Reserved2 : 3;             // [45-47]
    unsigned SupportedIA64 : 1;         // [48]
    unsigned SupportedDualMoniter : 1;  // [49]
    unsigned MemoryType : 4;            // [50-53]
    unsigned VmExitReport : 1;          // [54]
    unsigned VmxCapabilityHint : 1;     // [55]
    unsigned Reserved3 : 8;             // [56-63]
  } Fields;
};
static_assert(sizeof(IA32_VMX_BASIC_MSR) == 8, "Size check");

//
// IA32_VMX_MISC_MSR
// MISCELLANEOUS DATA
//
union IA32_VMX_MISC_MSR {
  unsigned __int64 All;
  struct {
    unsigned TimeStamp : 5;                            // [0-4]
    unsigned Reserved1 : 1;                            // [5]
    unsigned SupportedActivityStateHLT : 1;            // [6]
    unsigned SupportedActivityStateShutdown : 1;       // [7]
    unsigned SupportedActivityStateWaitForSIPI : 1;    // [8]
    unsigned Reserved2 : 6;                            // [9-14]
    unsigned SupportedReadIA32_SMBASE_MSR : 1;         // [15]
    unsigned SupportedCR3TargetValueNumber : 8;        // [16-23]
    unsigned SupportedCR3TargetValueNumberClear : 1;   // [24]
    unsigned MaximumMSRsNumber : 3;                    // [25-27]
    unsigned SuppoetedChangeIA32_SMM_MONITOR_CTL : 1;  // [28]
    unsigned SuppoetedVmWriteVmExitInformation : 1;    // [29]
    unsigned Reserved3 : 2;                            // [30-31]
    unsigned RevisionIdentifier : 32;                  // [32-63]
  } Fields;
};
static_assert(sizeof(IA32_VMX_MISC_MSR) == 8, "Size check");

//
// IA32_VMX_VMCS_ENUM_MSR
// VMCS ENUMERATION
//
union IA32_VMX_VMCS_ENUM_MSR {
  unsigned __int64 All;
  struct {
    unsigned Reserved1 : 1;                     // [0]
    unsigned SupportedHighestVMCSEncoding : 9;  // [1-9]
    unsigned Reserved2a : 22;                   //
    unsigned Reserved2b : 32;                   // [10-63]
  } Fields;
};
static_assert(sizeof(IA32_VMX_VMCS_ENUM_MSR) == 8, "Size check");

//
// IA32_VMX_EPT_VPID_CAP_MSR
// VPID AND EPT CAPABILITIES
//
union IA32_VMX_EPT_VPID_CAP_MSR {
  unsigned __int64 All;
  struct {
    unsigned SupportedEPT : 1;                                   // [0]
    unsigned Reserved1 : 5;                                      // [1-5]
    unsigned SupportedPageWalkLength4 : 1;                       // [6]
    unsigned Reserved2 : 1;                                      // [7]
    unsigned SupportedUncachebleMemoryType : 1;                  // [8]
    unsigned Reserved3 : 5;                                      // [9-13]
    unsigned SupportedWriteBackMemoryType : 1;                   // [14]
    unsigned Reserved4 : 1;                                      // [15]
    unsigned SupportedPDE2MBPage : 1;                            // [16]
    unsigned Reserved5 : 3;                                      // [17-19]
    unsigned SupportedINVEPT : 1;                                // [20]
    unsigned Reserved6 : 4;                                      // [21-24]
    unsigned SupportedSingleContextINVEPT : 1;                   // [25]
    unsigned SupportedAllContextINVEPT : 1;                      // [26]
    unsigned Reserved7 : 5;                                      // [27-31]
    unsigned SupportedINVVPID : 1;                               // [32]
    unsigned Reserved8 : 7;                                      // [33-39]
    unsigned SupportedIndividualAddressINVVPID : 1;              // [40]
    unsigned SupportedSingleContextINVVPID : 1;                  // [41]
    unsigned SupportedAllContextINVVPID : 1;                     // [42]
    unsigned SupportedSingleContextRetainingGlobalsINVVPID : 1;  // [43]
    unsigned Reserved9 : 20;                                     // [44-63]
  } Fields;
};
static_assert(sizeof(IA32_VMX_EPT_VPID_CAP_MSR) == 8, "Size check");

// VM-ENTRY FAILURES DURING OR AFTER LOADING GUEST STATE
union VM_EXIT_INFORMATION {
  ULONG32 All;
  struct {
    VMX_EXIT_REASON Reason;             // [0:15]
    unsigned short Reserved : 15;       // [16:30]
    unsigned short VMEntryFailure : 1;  // [31]
  } Fields;
};
static_assert(sizeof(VM_EXIT_INFORMATION) == 4, "Size check");

// Format of the VM-Exit Instruction-Information Field as Used for
// LIDT, LGDT, SIDT, or SGDT
enum GDTR_OR_IDTR_SCALING {
  NO_SCALING = 0,
  SCALE_BY_2,
  SCALE_BY_4,
  SCALE_BY_8,
};

enum GDTR_OR_IDTR_ADDRESS_SIZE {
  BIT_16 = 0,
  BIT_32,
  BIT_64,
};

enum GDTR_OR_IDTR_SEGMENT_REGISTERS {
  ES = 0,
  CS,
  SS,
  DS,
  FS,
  GS,
};

enum GDTR_OR_IDTR_INSTRUCTION_IDENTITY {
  SGDT = 0,
  SIDT,
  LGDT,
  LIDT,
};

union GDTR_OR_IDTR_ACCESS_QUALIFICATION {
  ULONG32 All;
  struct {
    unsigned Scalling : 2;
    unsigned Reserved1 : 5;
    unsigned AddressSize : 3;
    unsigned Reserved2 : 1;
    unsigned OperandSize : 1;
    unsigned Reserved3 : 3;
    unsigned SegmentRegister : 3;
    unsigned IndexRegister : 4;
    unsigned IndexRegisterInvalid : 1;
    unsigned BaseRegister : 4;
    unsigned BaseRegisterInvalid : 1;
    unsigned InstructionIdentity : 2;
    unsigned Reserved4 : 2;
  } Fields;
};
static_assert(sizeof(GDTR_OR_IDTR_ACCESS_QUALIFICATION) == 4, "Size check");

// Format of the VM-Exit Instruction-Information Field as Used for
// LLDT, LTR, SLDT, and STR
enum LDTR_OR_TR_INSTRUCTION_IDENTITY {
  SLDT = 0,
  STR,
  LLDT,
  LTR,
};

union LDTR_OR_TR_ACCESS_QUALIFICATION {
  ULONG32 All;
  struct {
    unsigned Scalling : 2;
    unsigned Reserved1 : 1;
    unsigned Register1 : 4;
    unsigned AddressSize : 3;
    unsigned RegisterAccess : 1;
    unsigned Reserved2 : 4;
    unsigned SegmentRegister : 3;
    unsigned IndexRegister : 4;
    unsigned IndexRegisterInvalid : 1;
    unsigned BaseRegister : 4;
    unsigned BaseRegisterInvalid : 1;
    unsigned InstructionIdentity : 2;
    unsigned Reserved4 : 2;
  } Fields;
};
static_assert(sizeof(LDTR_OR_TR_ACCESS_QUALIFICATION) == 4, "Size check");

// Exit Qualification for MOV DR
enum MOV_DR_DIRECTION {
  MOVE_TO_DR = 0,
  MOVE_FROM_DR,
};

union MOV_DR_QUALIFICATION {
  ULONG_PTR All;
  struct {
    unsigned DebuglRegister : 3;
    unsigned Reserved1 : 1;
    unsigned Direction : 1;
    unsigned Reserved2 : 3;
    unsigned Register : 4;
    unsigned Reserved3 : 20;
    // unsigned Reserved4 : 32;
  } Fields;
};
static_assert(sizeof(MOV_DR_QUALIFICATION) == 8, "Size check");

// Exit Qualification for Control-Register Accesses
enum MOV_CR_ACCESS_TYPE {
  MOVE_TO_CR = 0,
  MOVE_FROM_CR,
  CLTS,
  LMSW,
};

union MOV_CR_QUALIFICATION {
  ULONG_PTR All;
  struct {
    unsigned ControlRegister : 4;
    unsigned AccessType : 2;
    unsigned LMSWOperandType : 1;
    unsigned Reserved1 : 1;
    unsigned Register : 4;
    unsigned Reserved2 : 4;
    unsigned LMSWSourceData : 16;
    // unsigned Reserved3 : 32;
  } Fields;
};
static_assert(sizeof(MOV_CR_QUALIFICATION) == 8, "Size check");

////////////////////////////////////////////////////////////////////////////////
//
// prototypes
//

////////////////////////////////////////////////////////////////////////////////
//
// variables
//

////////////////////////////////////////////////////////////////////////////////
//
// implementations
//

```

`Sushi/SushiTest/SushiTest.cpp`:

```cpp
// Copyright (c) 2015, tandasat. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

//
// This module declares interfaces to logging functions.
//
#include "stdafx.h"


////////////////////////////////////////////////////////////////////////////////
//
// macro utilities
//

////////////////////////////////////////////////////////////////////////////////
//
// constants and macros
//

static const auto SUSHI_BACKDOOR_CODE = 0x11519;

////////////////////////////////////////////////////////////////////////////////
//
// types
//

////////////////////////////////////////////////////////////////////////////////
//
// prototypes
//


////////////////////////////////////////////////////////////////////////////////
//
// variables
//

////////////////////////////////////////////////////////////////////////////////
//
// implementations
//

int _tmain(int argc, TCHAR *argv[]) {
  if (argc == 2) {
    const auto affinity = (1 << std::stoul(argv[1]));
    if (!::SetThreadAffinityMask(::GetCurrentThread(), affinity)) {
      std::cout << "SetThreadAffinityMask() failed." << std::endl;
      return EXIT_FAILURE;
    }
  }

  for (; /*ever*/;) {
    int cpuInfo[4] = {};
    __cpuidex(cpuInfo, 0, SUSHI_BACKDOOR_CODE);
    char vendorID[13] = {};
    memcpy(&vendorID[0], &cpuInfo[1], 4);  // ebx
    memcpy(&vendorID[4], &cpuInfo[3], 4);  // edx
    memcpy(&vendorID[8], &cpuInfo[2], 4);  // ecx
    printf("Vendor ID: %s\n", vendorID);

    unsigned int tscAux = 0;
    const auto tsc1 = __rdtscp(&tscAux);
    printf("Rdtscp   : %016Ix, %08x\n", tsc1, tscAux);

    const auto tsc2 = __rdtsc();
    printf("Rdtsc    : %016Ix\n", tsc2);

    ::Sleep(1000);
  }
}

```

`Sushi/SushiTest/SushiTest.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{FEDC1796-520E-4DC0-A081-66D03E462AA0}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>SushiTest</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="SushiTest.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Sushi/SushiTest/SushiTest.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SushiTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Sushi/SushiTest/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// SushiTest.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`Sushi/SushiTest/stdafx.h`:

```h
// Copyright (c) 2015, tandasat. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

//
// This module declares interfaces to logging functions.
//
#pragma once

#include "targetver.h"
#include <iostream>
#include <memory>
#include <string>

#include <intrin.h>
#include <tchar.h>
#include <Windows.h>

////////////////////////////////////////////////////////////////////////////////
//
// macro utilities
//

////////////////////////////////////////////////////////////////////////////////
//
// constants and macros
//

////////////////////////////////////////////////////////////////////////////////
//
// types
//

////////////////////////////////////////////////////////////////////////////////
//
// prototypes
//

////////////////////////////////////////////////////////////////////////////////
//
// variables
//

////////////////////////////////////////////////////////////////////////////////
//
// implementations
//

```

`Sushi/SushiTest/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform,
// include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before
// including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`Sushi/clean.bat`:

```bat
@echo off
del *.sdf
del /a:h *.suo
rmdir /s /q .vs
rmdir /s /q ipch
rmdir /s /q x64
rmdir /s /q SushiTest\x64  
rmdir /s /q Sushi\x64  
rmdir /s /q ChangeMSR\x64  
del /s *.aps
pause

```