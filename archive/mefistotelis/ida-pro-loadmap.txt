Project Path: arc_mefistotelis_ida-pro-loadmap_dmi0n0k6

Source Tree:

```txt
arc_mefistotelis_ida-pro-loadmap_dmi0n0k6
├── Makefile
├── README.md
├── loadmap.sln
├── loadmap.vcproj
├── loadmap.vcxproj
├── loadmap.vcxproj.filters
├── loadmap.vcxproj.user
└── src
    ├── LoadMap.cpp
    ├── MAPReader.cpp
    ├── MAPReader.h
    ├── stdafx.cpp
    └── stdafx.h

```

`Makefile`:

```
PROC=loadmap
O1=MAPReader
O2=stdafx

# required for GetAsyncKeyState()
STDLIBS += User32.lib

include ../plugin.mak

# MAKEDEP dependency list ------------------
$(F)loadmap$(O)   : $(I)bitrange.hpp $(I)bytes.hpp $(I)config.hpp $(I)fpro.h  \
	          $(I)funcs.hpp $(I)ida.hpp $(I)idp.hpp $(I)kernwin.hpp     \
	          $(I)lines.hpp $(I)llong.hpp $(I)loader.hpp $(I)nalt.hpp   \
	          $(I)netnode.hpp $(I)pro.h $(I)range.hpp $(I)segment.hpp   \
	          $(I)ua.hpp $(I)xref.hpp \
	          src/loadmap.cpp
$(F)MAPReader$(O)  : src/MAPReader.cpp src/MAPReader.h
$(F)stdafx$(O)  : src/stdafx.cpp src/stdafx.h

$(PROC): NO_OBSOLETE_FUNCS =

$(F)loadmap$(O): NO_OBSOLETE_FUNCS =

# Copy of the standard idasdk rule, but this one allows src directory
$(F)%$(O): src/%.cpp
	$(strip $(QCXX)$(CXX) $(CXXFLAGS) $(NORTTI) $(CONLY) $(OBJSW)$@ $<)

```

`README.md`:

```md
# IDA Pro plugin for loading .MAP symbol files

Loads a VC/Borland/Dede/GCC/IDA `.map` file into IDA Database.

## What is the MAP file

The `.map` file may be generated during compilation, and contain some of debug info (function names, global variables,
in some cases locals as well).

In the past, it was generated automatically by many compilers. For some programs, it was included in a pre-release
version, or even in final release.

Todays compiles still have ability to enable `.map` file generation, ie:

* Watcom linker has `OPTION MAP[=map_file]` command line switch
* GCC linker has `-Xlinker -Map=output.map` command line switch
* Microsoft VC linker has `/MAP[:filename]` command line switch

## More information

See src/LoadMap.cpp for credits, license and changelog.

## Installation

* Copy loadmap.dll to IDA plugins folder
* Open any PE/LE file project
* Click Load MAP with Shift to see options

## Building

The building requires IDA Pro SDK.

To rebuilt the project on Windows using GUI, copy it to IDA SDK `plugins/loadmap` folder, then open SLN file and build it with Visual Studio.

To rebuilt the project from command line, check how the Github Actions do that. You will need some GNU tools including make, and VC compiler from Visual Studio.

## Troubleshooting

If the plugin does not show in "Edit" -> "Plugins", then:
* Make sure you have a code project opened
* Check IDA "Output" console, there should be a message either confirming the load or with error
* If the "Output" console shows "Cannot load certain module", you probably lack Visual C++ Redistributable Package
* Check the "Issues" tab of this project on Github for more info

## Known issues

Currently it doesn't understand MAP files with 64-bit offsets - new versions of GCC produce files with such long offsets.
WA for this is to just remove excessive zeros from offsets in MAP file before loading it.

Currently the tool uses Windows API, so will not work with Linux or Mac OS version of IDA Pro. To fix that:
* reading keys would have to be switched to one from Qt
* memory mapped file usage would have to be implemented (or switched to C++ standard method, when it finally arrives)

```

`loadmap.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2012
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "loadmap", "loadmap.vcxproj", "{2B1B911C-4238-4F00-97B3-5B90FAD04414}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Debug64|Win32 = Debug64|Win32
		Debug64|x64 = Debug64|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
		Release64|Win32 = Release64|Win32
		Release64|x64 = Release64|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{2B1B911C-4238-4F00-97B3-5B90FAD04414}.Debug|Win32.ActiveCfg = Debug|Win32
		{2B1B911C-4238-4F00-97B3-5B90FAD04414}.Debug|Win32.Build.0 = Debug|Win32
		{2B1B911C-4238-4F00-97B3-5B90FAD04414}.Debug|x64.ActiveCfg = Debug|x64
		{2B1B911C-4238-4F00-97B3-5B90FAD04414}.Debug|x64.Build.0 = Debug|x64
		{2B1B911C-4238-4F00-97B3-5B90FAD04414}.Debug64|Win32.ActiveCfg = Debug64|Win32
		{2B1B911C-4238-4F00-97B3-5B90FAD04414}.Debug64|Win32.Build.0 = Debug64|Win32
		{2B1B911C-4238-4F00-97B3-5B90FAD04414}.Debug64|x64.ActiveCfg = Debug64|x64
		{2B1B911C-4238-4F00-97B3-5B90FAD04414}.Debug64|x64.Build.0 = Debug64|x64
		{2B1B911C-4238-4F00-97B3-5B90FAD04414}.Release|Win32.ActiveCfg = Release|Win32
		{2B1B911C-4238-4F00-97B3-5B90FAD04414}.Release|Win32.Build.0 = Release|Win32
		{2B1B911C-4238-4F00-97B3-5B90FAD04414}.Release|x64.ActiveCfg = Release|x64
		{2B1B911C-4238-4F00-97B3-5B90FAD04414}.Release|x64.Build.0 = Release|x64
		{2B1B911C-4238-4F00-97B3-5B90FAD04414}.Release64|Win32.ActiveCfg = Release64|Win32
		{2B1B911C-4238-4F00-97B3-5B90FAD04414}.Release64|Win32.Build.0 = Release64|Win32
		{2B1B911C-4238-4F00-97B3-5B90FAD04414}.Release64|x64.ActiveCfg = Release64|x64
		{2B1B911C-4238-4F00-97B3-5B90FAD04414}.Release64|x64.Build.0 = Release64|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`loadmap.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9.00"
	Name="loadmap"
	ProjectGUID="{2B1B911C-4238-4F00-97B3-5B90FAD04414}"
	TargetFrameworkVersion="0"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Release|Win32"
			OutputDirectory=".\Release"
			IntermediateDirectory=".\Release"
			ConfigurationType="2"
			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
			UseOfMFC="0"
			ATLMinimizesCRunTimeLibraryUsage="false"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				PreprocessorDefinitions="NDEBUG"
				MkTypLibCompatible="true"
				SuppressStartupBanner="true"
				TargetEnvironment="1"
				TypeLibraryName=".\Release/loadmap.tlb"
				HeaderFileName=""
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="2"
				InlineFunctionExpansion="1"
				AdditionalIncludeDirectories="..\..\include"
				PreprocessorDefinitions="NDEBUG;WIN32;_WINDOWS;_USRDLL;__NT__;__IDP__;MAXSTR=1024"
				StringPooling="true"
				RuntimeLibrary="0"
				EnableFunctionLevelLinking="true"
				PrecompiledHeaderFile=".\Release/loadmap.pch"
				AssemblerListingLocation=".\Release/"
				ObjectFile=".\Release/"
				ProgramDataBaseFileName=".\Release/"
				WarningLevel="3"
				SuppressStartupBanner="true"
				CallingConvention="2"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="NDEBUG"
				Culture="1049"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalOptions="/export:PLUGIN"
				AdditionalDependencies="ida.lib"
				OutputFile="../../bin/x86_win_vc/plugins/loadmap.dll"
				LinkIncremental="1"
				SuppressStartupBanner="true"
				AdditionalLibraryDirectories="..\..\lib\x86_win_vc_32"
				ProgramDatabaseFile=".\Release/loadmap.pdb"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="0"
				ImportLibrary=".\Release/loadmap.lib"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
				SuppressStartupBanner="true"
				OutputFile=".\Release/loadmap.bsc"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Debug|Win32"
			OutputDirectory=".\Debug"
			IntermediateDirectory=".\Debug"
			ConfigurationType="2"
			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
			UseOfMFC="0"
			ATLMinimizesCRunTimeLibraryUsage="false"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				PreprocessorDefinitions="_DEBUG"
				MkTypLibCompatible="true"
				SuppressStartupBanner="true"
				TargetEnvironment="1"
				TypeLibraryName=".\Debug/loadmap.tlb"
				HeaderFileName=""
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include"
				PreprocessorDefinitions="_DEBUG;__NT__;__IDP__;MAXSTR=1024;WIN32;_WINDOWS;_USRDLL"
				MinimalRebuild="true"
				BasicRuntimeChecks="3"
				RuntimeLibrary="1"
				PrecompiledHeaderFile=".\Debug/loadmap.pch"
				AssemblerListingLocation=".\Debug/"
				ObjectFile=".\Debug/"
				ProgramDataBaseFileName=".\Debug/"
				WarningLevel="3"
				SuppressStartupBanner="true"
				DebugInformationFormat="4"
				CallingConvention="2"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="_DEBUG"
				Culture="1033"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalOptions="/export:PLUGIN"
				AdditionalDependencies="ida.lib"
				OutputFile="../../bin/x86_win_vc/plugins/loadmap.dll"
				LinkIncremental="2"
				SuppressStartupBanner="true"
				AdditionalLibraryDirectories="..\..\lib\x86_win_vc_32"
				GenerateDebugInformation="true"
				ProgramDatabaseFile=".\Debug/loadmap.pdb"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="0"
				ImportLibrary=".\Debug/loadmap.lib"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
				SuppressStartupBanner="true"
				OutputFile=".\Debug/loadmap.bsc"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Debug64|Win32"
			OutputDirectory="$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="2"
			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
			UseOfMFC="0"
			ATLMinimizesCRunTimeLibraryUsage="false"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				PreprocessorDefinitions="_DEBUG"
				MkTypLibCompatible="true"
				SuppressStartupBanner="true"
				TargetEnvironment="1"
				TypeLibraryName=".\Debug64/loadmap.tlb"
				HeaderFileName=""
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories="..\..\include"
				PreprocessorDefinitions="_DEBUG;__NT__;__IDP__;__EA64__;MAXSTR=1024;WIN32;_WINDOWS;_USRDLL"
				MinimalRebuild="true"
				BasicRuntimeChecks="3"
				RuntimeLibrary="1"
				AssemblerListingLocation=".\Debug64/"
				ObjectFile=".\Debug64/"
				ProgramDataBaseFileName=".\Debug64/"
				WarningLevel="3"
				SuppressStartupBanner="true"
				DebugInformationFormat="4"
				CallingConvention="2"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="_DEBUG"
				Culture="1033"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalOptions="/export:PLUGIN"
				AdditionalDependencies="ida.lib"
				OutputFile="../../bin/x86_win_vc/plugins/loadmap.p64"
				LinkIncremental="2"
				SuppressStartupBanner="true"
				AdditionalLibraryDirectories="..\..\lib\x86_win_vc_64"
				GenerateDebugInformation="true"
				ProgramDatabaseFile=".\Debug64/loadmap.pdb"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="0"
				ImportLibrary=".\Debug64/loadmap.lib"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
				SuppressStartupBanner="true"
				OutputFile=".\Debug64/loadmap.bsc"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release64|Win32"
			OutputDirectory="$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="2"
			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
			UseOfMFC="0"
			ATLMinimizesCRunTimeLibraryUsage="false"
			CharacterSet="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				PreprocessorDefinitions="NDEBUG"
				MkTypLibCompatible="true"
				SuppressStartupBanner="true"
				TargetEnvironment="1"
				TypeLibraryName=".\Release64/loadmap.tlb"
				HeaderFileName=""
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="2"
				InlineFunctionExpansion="1"
				AdditionalIncludeDirectories="..\..\include"
				PreprocessorDefinitions="NDEBUG;WIN32;_WINDOWS;_USRDLL;__NT__;__IDP__;__EA64__;MAXSTR=1024"
				StringPooling="true"
				RuntimeLibrary="0"
				EnableFunctionLevelLinking="true"
				PrecompiledHeaderFile=".\Release64/loadmap.pch"
				AssemblerListingLocation=".\Release64/"
				ObjectFile=".\Release64/"
				ProgramDataBaseFileName=".\Release64/"
				WarningLevel="3"
				SuppressStartupBanner="true"
				CallingConvention="2"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
				PreprocessorDefinitions="NDEBUG"
				Culture="1049"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalOptions="/export:PLUGIN"
				AdditionalDependencies="ida.lib"
				OutputFile="../../bin/x86_win_vc/plugins/loadmap.p64"
				LinkIncremental="1"
				SuppressStartupBanner="true"
				AdditionalLibraryDirectories="..\..\lib\x86_win_vc_64"
				ProgramDatabaseFile=".\Release64/loadmap.pdb"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="0"
				ImportLibrary=".\Release64/loadmap.lib"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
				SuppressStartupBanner="true"
				OutputFile=".\Release64/loadmap.bsc"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
			>
			<File
				RelativePath="src/loadmap.cpp"
				>
			</File>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`loadmap.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug64|Win32">
      <Configuration>Debug64</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug64|x64">
      <Configuration>Debug64</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release64|Win32">
      <Configuration>Release64</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release64|x64">
      <Configuration>Release64</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{2B1B911C-4238-4F00-97B3-5B90FAD04414}</ProjectGuid>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release64|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v110</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release64|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v110</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug64|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v110</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug64|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v110</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v110</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v110</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v110</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v110</PlatformToolset>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release64|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release64|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug64|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug64|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>11.0.50727.1</_ProjectFileVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>.\Release\</OutDir>
    <IntDir>.\Release\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>.\Debug\</OutDir>
    <IntDir>.\Debug\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug64|Win32'">
    <OutDir>$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug64|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release64|Win32'">
    <OutDir>$(Configuration)\</OutDir>
    <IntDir>$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release64|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Midl>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MkTypLibCompatible>true</MkTypLibCompatible>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <TargetEnvironment>Win32</TargetEnvironment>
      <TypeLibraryName>.\Release/loadmap.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <AdditionalIncludeDirectories>..\..\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;WIN32;_WINDOWS;_USRDLL;__NT__;__IDP__;MAXSTR=1024;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeaderOutputFile>.\Release/loadmap.pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>.\Release/</AssemblerListingLocation>
      <ObjectFileName>.\Release/</ObjectFileName>
      <ProgramDataBaseFileName>.\Release/</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <CallingConvention>StdCall</CallingConvention>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0419</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalOptions>/export:PLUGIN %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>ida.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>../../bin/x86_win_vc/plugins/loadmap.dll</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AdditionalLibraryDirectories>..\..\lib\x86_win_vc_32;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <ProgramDatabaseFile>.\Release/loadmap.pdb</ProgramDatabaseFile>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <ImportLibrary>.\Release/loadmap.lib</ImportLibrary>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>.\Release/loadmap.bsc</OutputFile>
    </Bscmake>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MkTypLibCompatible>true</MkTypLibCompatible>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <TypeLibraryName>.\Release/loadmap.tlb</TypeLibraryName>
      <HeaderFileName>
      </HeaderFileName>
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <AdditionalIncludeDirectories>..\..\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;WIN32;_WINDOWS;_USRDLL;__NT__;__IDP__;MAXSTR=1024;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeaderOutputFile>.\Release/loadmap.pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>.\Release/</AssemblerListingLocation>
      <ObjectFileName>.\Release/</ObjectFileName>
      <ProgramDataBaseFileName>.\Release/</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <CallingConvention>StdCall</CallingConvention>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0419</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalOptions>/export:PLUGIN %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>ida.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>../../bin/x86_win_vc/plugins/loadmap.dll</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AdditionalLibraryDirectories>..\..\lib\x86_win_vc_32;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <ProgramDatabaseFile>.\Release/loadmap.pdb</ProgramDatabaseFile>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <ImportLibrary>.\Release/loadmap.lib</ImportLibrary>
    </Link>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>.\Release/loadmap.bsc</OutputFile>
    </Bscmake>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Midl>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MkTypLibCompatible>true</MkTypLibCompatible>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <TargetEnvironment>Win32</TargetEnvironment>
      <TypeLibraryName>.\Debug/loadmap.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\..\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;__NT__;__IDP__;MAXSTR=1024;WIN32;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>true</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeaderOutputFile>.\Debug/loadmap.pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>.\Debug/</AssemblerListingLocation>
      <ObjectFileName>.\Debug/</ObjectFileName>
      <ProgramDataBaseFileName>.\Debug/</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
      <CallingConvention>StdCall</CallingConvention>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalOptions>/export:PLUGIN %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>ida.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>../../bin/x86_win_vc/plugins/loadmap.dll</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AdditionalLibraryDirectories>..\..\lib\x86_win_vc_32;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>.\Debug/loadmap.pdb</ProgramDatabaseFile>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <ImportLibrary>.\Debug/loadmap.lib</ImportLibrary>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>.\Debug/loadmap.bsc</OutputFile>
    </Bscmake>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MkTypLibCompatible>true</MkTypLibCompatible>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <TypeLibraryName>.\Debug/loadmap.tlb</TypeLibraryName>
      <HeaderFileName>
      </HeaderFileName>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\..\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;__NT__;__IDP__;MAXSTR=1024;WIN32;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeaderOutputFile>.\Debug/loadmap.pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>.\Debug/</AssemblerListingLocation>
      <ObjectFileName>.\Debug/</ObjectFileName>
      <ProgramDataBaseFileName>.\Debug/</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <CallingConvention>StdCall</CallingConvention>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalOptions>/export:PLUGIN %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>ida.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>../../bin/x86_win_vc/plugins/loadmap.dll</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AdditionalLibraryDirectories>..\..\lib\x86_win_vc_32;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>.\Debug/loadmap.pdb</ProgramDatabaseFile>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <ImportLibrary>.\Debug/loadmap.lib</ImportLibrary>
    </Link>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>.\Debug/loadmap.bsc</OutputFile>
    </Bscmake>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug64|Win32'">
    <Midl>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MkTypLibCompatible>true</MkTypLibCompatible>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <TargetEnvironment>Win32</TargetEnvironment>
      <TypeLibraryName>.\Debug64/loadmap.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\..\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;__NT__;__IDP__;__EA64__;MAXSTR=1024;WIN32;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>true</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <AssemblerListingLocation>.\Debug64/</AssemblerListingLocation>
      <ObjectFileName>.\Debug64/</ObjectFileName>
      <ProgramDataBaseFileName>.\Debug64/</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
      <CallingConvention>StdCall</CallingConvention>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalOptions>/export:PLUGIN %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>ida.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>../../bin/x86_win_vc/plugins/loadmap.p64</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AdditionalLibraryDirectories>..\..\lib\x86_win_vc_64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>.\Debug64/loadmap.pdb</ProgramDatabaseFile>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <ImportLibrary>.\Debug64/loadmap.lib</ImportLibrary>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>.\Debug64/loadmap.bsc</OutputFile>
    </Bscmake>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug64|x64'">
    <Midl>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MkTypLibCompatible>true</MkTypLibCompatible>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <TypeLibraryName>.\Debug64/loadmap.tlb</TypeLibraryName>
      <HeaderFileName>
      </HeaderFileName>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>..\..\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>__NT__;__IDP__;__X64__;</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <AssemblerListingLocation>.\Debug64/</AssemblerListingLocation>
      <ObjectFileName>.\Debug64/</ObjectFileName>
      <ProgramDataBaseFileName>.\Debug64/</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <CallingConvention>StdCall</CallingConvention>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0409</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalOptions>/export:PLUGIN %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>ida.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)\$(ProjectName).dll</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AdditionalLibraryDirectories>..\..\lib\x64_win_vc_32;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>.\Debug64/loadmap.pdb</ProgramDatabaseFile>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <ImportLibrary>.\Debug64/loadmap.lib</ImportLibrary>
    </Link>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>.\Debug64/loadmap.bsc</OutputFile>
    </Bscmake>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release64|Win32'">
    <Midl>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MkTypLibCompatible>true</MkTypLibCompatible>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <TargetEnvironment>Win32</TargetEnvironment>
      <TypeLibraryName>.\Release64/loadmap.tlb</TypeLibraryName>
      <HeaderFileName />
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <AdditionalIncludeDirectories>..\..\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;WIN32;_WINDOWS;_USRDLL;__NT__;__IDP__;__EA64__;MAXSTR=1024;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeaderOutputFile>.\Release64/loadmap.pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>.\Release64/</AssemblerListingLocation>
      <ObjectFileName>.\Release64/</ObjectFileName>
      <ProgramDataBaseFileName>.\Release64/</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <CallingConvention>StdCall</CallingConvention>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0419</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalOptions>/export:PLUGIN %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>ida.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>../../bin/x86_win_vc/plugins/loadmap.p64</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AdditionalLibraryDirectories>..\..\lib\x86_win_vc_64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <ProgramDatabaseFile>.\Release64/loadmap.pdb</ProgramDatabaseFile>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention />
      <ImportLibrary>.\Release64/loadmap.lib</ImportLibrary>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>.\Release64/loadmap.bsc</OutputFile>
    </Bscmake>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release64|x64'">
    <Midl>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MkTypLibCompatible>true</MkTypLibCompatible>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <TypeLibraryName>.\Release64/loadmap.tlb</TypeLibraryName>
      <HeaderFileName>
      </HeaderFileName>
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <AdditionalIncludeDirectories>..\..\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;WIN32;_WINDOWS;_USRDLL;__NT__;__IDP__;__EA64__;MAXSTR=1024;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeaderOutputFile>.\Release64/loadmap.pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>.\Release64/</AssemblerListingLocation>
      <ObjectFileName>.\Release64/</ObjectFileName>
      <ProgramDataBaseFileName>.\Release64/</ProgramDataBaseFileName>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <CallingConvention>StdCall</CallingConvention>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0419</Culture>
    </ResourceCompile>
    <Link>
      <AdditionalOptions>/export:PLUGIN %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>ida.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>../../bin/x86_win_vc/plugins/loadmap.p64</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <AdditionalLibraryDirectories>..\..\lib\x86_win_vc_64;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <ProgramDatabaseFile>.\Release64/loadmap.pdb</ProgramDatabaseFile>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <ImportLibrary>.\Release64/loadmap.lib</ImportLibrary>
    </Link>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>.\Release64/loadmap.bsc</OutputFile>
    </Bscmake>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="src/loadmap.cpp" />
    <ClCompile Include="src\MAPReader.cpp" />
    <ClCompile Include="src\stdafx.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\MAPReader.h" />
    <ClInclude Include="src\stdafx.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`loadmap.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{cba80485-cd95-48ec-b2dd-be381a2e304d}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src/loadmap.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\MAPReader.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\MAPReader.h">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="src\stdafx.h">
      <Filter>Source Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`loadmap.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`src/LoadMap.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
/// @file LoadMap.cpp
///     Implementation of an IDA plugin, which loads a VC++/BCC map file.
/// @par Purpose:
///     An IDA plugin, which loads a VC/Borland/Dede map file into IDA Database.
///     Based on the idea of loadmap plugin by Toshiyuki Tega.
/// @author TQN <truong_quoc_ngan@yahoo.com>
/// @author TL <mefistotelis@gmail.com>
/// @date 2004.09.11 - 2018.11.08
/// @version 1.3 - 2018.11.08 - Compiling in VS2010, SDK from IDA 7.0
/// @version 1.2 - 2012.07.18 - Loading GCC MAP files, compiling in IDA 6.2
/// @version 1.1 - 2011.09.13 - Loading Watcom MAP files, compiling in IDA 6.1
/// @version 1.0 - 2004.09.11 - Initial release
/// @par  Copying and copyrights:
///     This program is free software; you can redistribute it and/or modify
///     it under the terms of the GNU General Public License as published by
///     the Free Software Foundation; either version 2 of the License, or
///     (at your option) any later version.
///     IDA Pro SDK by Hex-rays is required to use this software; that
///     SDK has more complex licensing situation, and is not under GPL.
////////////////////////////////////////////////////////////////////////////////
#define PLUG_VERSION "1.4"
//  standard library headers.
#include <cstdio>
// Makes gcc stdlib to not define non-underscored versions of non-ANSI functions (ie memicmp, strlwr)
#define _NO_OLDNAMES
#include <cstring>
#undef _NO_OLDNAMES

//  other headers.
#include  "MAPReader.h"
#include "stdafx.h"

//#define USE_STANDARD_FILE_FUNCTIONS
//#define USE_DANGEROUS_FUNCTIONS

// IDA SDK Header Files
#include <ida.hpp>
#include <idp.hpp>
#include <loader.hpp>
#include <kernwin.hpp>
#include <diskio.hpp>
#include <bytes.hpp>
#include <name.hpp>
#include <entry.hpp>
#include <fpro.h>
#include <err.h> // for qerrstr()
#include <prodir.h> // just for MAXPATH

#if IDA_SDK_VERSION >= 800 && defined(HAS_IDA_QT_DEV_LIB)
// Hex-rays modified Qt is not a part of IDA SDK, needs to be dowloaded separately
#include <QGuiApplication>
#endif

typedef struct _tagPLUGIN_OPTIONS {
    int bNameApply;    //< true - apply to name, false - apply to comment
    int bReplace;      //< replace the existing name or comment
    int bVerbose;      //< show detail messages
} PLUGIN_OPTIONS;

const size_t g_minLineLen = 14; // For a "xxxx:xxxxxxxx " line

/// @brief Global variable for options of plugin
static PLUGIN_OPTIONS g_options = { 0 };

static const cfgopt_t g_optsinfo[] =
{
    cfgopt_t("NAME_APPLY", &g_options.bNameApply, 0, 1),
    cfgopt_t("REPLACE_EXISTING", &g_options.bReplace, 0, 1),
    cfgopt_t("VERBOSE_MESSAGES", &g_options.bVerbose, 0, 1),
};

////////////////////////////////////////////////////////////////////////////////
/// @name Ini Section and Key names
/// @{
static char g_szLoadMapSection[] = "LoadMap";
static char g_szOptionsKey[] = "Options";
/// @}

#ifdef __EA64__
void linearAddressToSymbolAddr(MapFile::MAPSymbol &sym, unsigned long long linear_addr)
#else
void linearAddressToSymbolAddr(MapFile::MAPSymbol &sym, unsigned long linear_addr)
#endif
{
    sym.seg = get_segm_num(linear_addr);
    segment_t * sseg = getnseg((int) sym.seg);
    if (sseg != NULL)
        sym.addr = linear_addr - sseg->start_ea;
    else
        sym.addr = -1;
}


////////////////////////////////////////////////////////////////////////////////
/// @brief Output a formatted string to messages window [analog of printf()]
///     only when the verbose flag of plugin's options is true
/// @param  format const char * printf() style message string.
/// @return void
/// @author TQN
/// @date 2004.09.11
 ////////////////////////////////////////////////////////////////////////////////
void showMsg(const char *format, ...)
{
    if (g_options.bVerbose)
    {
        va_list va;
        va_start(va, format);
        (void) vmsg(format, va);
        va_end(va);
    }
}

////////////////////////////////////////////////////////////////////////////////
/// @brief Show options dialog for getting user desired options
/// @return void
/// @author TQN
/// @date 2004.09.11
////////////////////////////////////////////////////////////////////////////////
static void showOptionsDlg(void)
{
    // Build the format string constant used to create the dialog
    const char format[] =
        "STARTITEM 0\n"                             // TabStop
        "LoadMap Options\n"                         // Title
        "<Apply Map Symbols for Name:R>\n"          // Radio Button 0
        "<Apply Map Symbols for Comment:R>>\n"    // Radio Button 1
        "<Replace Existing Names/Comments:C>>\n"  // Checkbox Button
        "<Show verbose messages:C>>\n\n";           // Checkbox Button

    // Create the option dialog.
    short name = (g_options.bNameApply ? 0 : 1);
    short replace = (g_options.bReplace ? 1 : 0);
    short verbose = (g_options.bVerbose ? 1 : 0);
    if (ask_form(format, &name, &replace, &verbose))
    {
        g_options.bNameApply = (0 == name);
        g_options.bReplace = (1 == replace);
        g_options.bVerbose = (1 == verbose);
    }
}

////////////////////////////////////////////////////////////////////////////////
/// @brief Write-side equivalent of read_config_file() from IDA API
/// @return True if saved
/// @author TL
/// @date 2023.11.22
 ////////////////////////////////////////////////////////////////////////////////
bool write_config_file(
        const char *filename,
        const cfgopt_t opts[],
        size_t nopts)
{
    char szLine[120];
    char szIniPath[MAXPATH] = { 0 };
    int fh, i;

    // Get the full path to user config dir
    qstrncpy(szIniPath, get_user_idadir(), sizeof(szIniPath));
    qstrncat(szIniPath, "/", sizeof(szIniPath));
    qstrncat(szIniPath, filename, sizeof(szIniPath));
    qstrncat(szIniPath, ".cfg", sizeof(szIniPath));
    szIniPath[sizeof(szIniPath) - 1] = '\0';

    fh = qcreate(szIniPath, 0644);
    if (fh == -1)
        return false;

    qsnprintf(szLine, sizeof(szLine), "//\n// LoadMap Plugin auto-saved configuration file\n//\n");
    qwrite(fh, szLine, qstrlen(szLine));

    // Write config in normal IDA format (like the files in IDA/cfg folder).
    // IDA Pro does not provide an API for that - only for reading.

    for (i = 0; i < nopts; i++)
    {
        const cfgopt_t *opt = &opts[i];

        qsnprintf(szLine, sizeof(szLine), "%s = %d\n", opt->name, *(int *)(opt->ptr));
        qwrite(fh, szLine, qstrlen(szLine));
    }
    qclose(fh);

    return true;
}

////////////////////////////////////////////////////////////////////////////////
/// @brief Plugin initialize function
/// @return PLUGIN_KEEP always
/// @author TQN
/// @date 2004.09.11
 ////////////////////////////////////////////////////////////////////////////////
static plugmod_t *idaapi init()
{
    msg("\nLoadMap: Plugin v%s init.\n\n", PLUG_VERSION);

    // Get options saved in cfg file; IDA Pro will find the file, it does
    // not need the full path nor extension, only base name.
    if (!read_config_file("loadmap", g_optsinfo, qnumber(g_optsinfo), NULL))
    {
        msg("LoadMap: Plugin config file '%s.cfg' read failed: %s.\n", "loadmap", qerrstr());
    }

#if IDA_SDK_VERSION >= 800
    switch (inf_get_filetype())
#else
    switch (inf.filetype)
#endif
    {
    case f_ZIP:
        return PLUGIN_SKIP;
    }
    return PLUGIN_KEEP;
}

////////////////////////////////////////////////////////////////////////////////
/// @brief Plugin run function, which does the actual job
/// @param   int    Not used
/// @return void
/// @author TQN
/// @date 2004.09.11
////////////////////////////////////////////////////////////////////////////////
bool idaapi run(size_t)
{
    static char mapFileName[_MAX_PATH] = { 0 };

    { // If user press shift key, show options dialog
#if 0
        // IDA API method - does not work in IDA 8/9, so disabling
        input_event_t input_event;
        if (get_user_input_event(&input_event) && (input_event.modifiers & VES_SHIFT))
#elif IDA_SDK_VERSION >= 800 && defined(HAS_IDA_QT_DEV_LIB)
        // Qt method - requires a special version of Qt which was used for building IDA
        Qt::KeyboardModifiers key = QApplication::queryKeyboardModifiers();
        if (key == Qt::ShiftModifier)
#else
        // Windows-only method
        if (GetAsyncKeyState(VK_SHIFT) & 0x8000)
#endif
        {
            showOptionsDlg();
        }
    }

    unsigned long numOfSegs = get_segm_qty();
    if (0 == numOfSegs)
    {
        warning("Not found any segments");
        return false;
    }

    if ('\0' == mapFileName[0])
    {
        // First run (after all, mapFileName is static)
        get_input_file_path(mapFileName, sizeof(mapFileName));
        pathExtensionSwitch(mapFileName, ".map", sizeof(mapFileName));
    }

    // Show open map file dialog
    char *fname = ask_file(0, mapFileName, "Open MAP file");
    if (NULL == fname)
    {
        msg("LoadMap: User cancel\n");
        return false;
    }

    // Open the map file
    char * pMapStart = NULL;
    size_t mapSize = INVALID_MAPFILE_SIZE;
    MapFile::MAPResult eRet = MapFile::openMAP(fname, pMapStart, mapSize);
    switch (eRet)
    {
        case MapFile::WIN32_ERROR:
            warning("Could not open file '%s'.\nWin32 Error Code = 0x%08X",
                    fname, GetLastError());
            return false;

        case MapFile::FILE_EMPTY_ERROR:
            warning("File '%s' is empty, zero size", fname);
            return false;

        case MapFile::FILE_BINARY_ERROR:
            warning("File '%s' seem to be a binary or Unicode file", fname);
            return false;

        case MapFile::OPEN_NO_ERROR:
        default:
            break;
    }

    MapFile::SectionType sectnHdr = MapFile::NO_SECTION;
    unsigned long sectnNumber = 0;
    unsigned long validSyms = 0;
    unsigned long invalidSyms = 0;

    // The mark pointer to the end of memory map file
    // all below code must not read or write at and over it
    const char * pMapEnd = pMapStart + mapSize;

    show_wait_box("Parsing and applying symbols from the Map file '%s'", fname);

    try
    {
        const char * pLine = pMapStart;
        const char * pEOL = pMapStart;
        MapFile::MAPSymbol sym;
        MapFile::MAPSymbol prvsym;
        sym.seg = SREG_NUM;
        sym.addr = BADADDR;
        sym.name[0] = '\0';
        while (pLine < pMapEnd)
        {
            // Skip the spaces, '\r', '\n' characters, blank lines, seek to the
            // non space character at the beginning of a non blank line
            pLine = MapFile::skipSpaces(pEOL, pMapEnd);

            // Find the EOL '\r' or '\n' characters
            pEOL = MapFile::findEOL(pLine, pMapEnd);

            size_t lineLen = (size_t) (pEOL - pLine);
            if (lineLen < g_minLineLen)
            {
                continue;
            }
            char fmt[80];
            fmt[0] = '\0';

            // Check if we're on section header or section end
            if (sectnHdr == MapFile::NO_SECTION)
            {
                sectnHdr = MapFile::recognizeSectionStart(pLine, lineLen);
                if (sectnHdr != MapFile::NO_SECTION)
                {
                    sectnNumber++;
                    qsnprintf(fmt, sizeof(fmt), "Section start line: '%%.%ds'.\n", lineLen);
                    showMsg(fmt, pLine);
                    continue;
                }
            } else
            {
                sectnHdr = MapFile::recognizeSectionEnd(sectnHdr, pLine, lineLen);
                if (sectnHdr == MapFile::NO_SECTION)
                {
                    qsnprintf(fmt, sizeof(fmt), "Section end line: '%%.%ds'.\n", lineLen);
                    showMsg(fmt, pLine);
                    continue;
                }
            }
            MapFile::ParseResult parsed;
            prvsym.seg = sym.seg;
            prvsym.addr = sym.addr;
            qstrncpy(prvsym.name,sym.name,sizeof(sym.name));
            sym.seg = SREG_NUM;
            sym.addr = BADADDR;
            sym.name[0] = '\0';
            parsed = MapFile::INVALID_LINE;

            switch (sectnHdr)
            {
            case MapFile::NO_SECTION:
                parsed = MapFile::SKIP_LINE;
                break;
            case MapFile::MSVC_MAP:
            case MapFile::BCCL_NAM_MAP:
            case MapFile::BCCL_VAL_MAP:
                parsed = parseMsSymbolLine(sym,pLine,lineLen,g_minLineLen,numOfSegs);
                break;
            case MapFile::WATCOM_MAP:
                parsed = parseWatcomSymbolLine(sym,pLine,lineLen,g_minLineLen,numOfSegs);
                break;
            case MapFile::GCC_MAP:
                parsed = parseGccSymbolLine(sym,pLine,lineLen,g_minLineLen,numOfSegs);
                break;
            }

            if (parsed == MapFile::SKIP_LINE)
            {
                qsnprintf(fmt, sizeof(fmt), "Skipping line: '%%.%ds'.\n", lineLen);
                showMsg(fmt, pLine);
                continue;
            }
            if (parsed == MapFile::FINISHING_LINE)
            {
                sectnHdr = MapFile::NO_SECTION;
                // we have parsed to end of value/name symbols table or reached EOF
                qsnprintf(fmt, sizeof(fmt), "Parsing finished at line: '%%.%ds'.\n", lineLen);
                showMsg(fmt, pLine);
                continue;
            }
            if (parsed == MapFile::INVALID_LINE)
            {
                invalidSyms++;
                qsnprintf(fmt, sizeof(fmt), "Invalid map line: %%.%ds.\n", lineLen);
                showMsg(fmt, pLine);
                continue;
            }
            // If shouldn't apply names
            bool bNameApply = (g_options.bNameApply != 0);
            if (parsed == MapFile::COMMENT_LINE)
            {
                qsnprintf(fmt, sizeof(fmt), "Comment line: %%.%ds.\n", lineLen);
                showMsg(fmt, pLine);
                if (BADADDR == sym.addr)
                    continue;
            }
            // Determine the DeDe map file
            char *pname = sym.name;
            if (('<' == pname[0]) && ('-' == pname[1]))
            {
                // Functions indicator symbol of DeDe map
                pname += 2;
                bNameApply = true;
            }
            else if ('*' == pname[0])
            {
                // VCL controls indicator symbol of DeDe map
                pname++;
                bNameApply = false;
            }
            else if (('-' == pname[0]) && ('>' == pname[1]))
            {
                // VCL methods indicator symbol of DeDe map
                pname += 2;
                bNameApply = false;
            }

            ea_t la = sym.addr + getnseg((int) sym.seg)->start_ea;
            flags_t f = get_full_flags(la);

            bool didOk;
            if (bNameApply) // Apply symbols for name
            {
                //  Add name if there's no meaningful name assigned.
                if (g_options.bReplace ||
                    (!has_name(f) || has_dummy_name(f) || has_auto_name(f)))
                {
                    didOk = set_name(la, pname, SN_NOCHECK | SN_NOWARN);
#ifdef __EA64__
                    showMsg("%04lX:%08llX - Change name to '%s' %s\n",
                        sym.seg, la, pname, didOk ? "succeeded" : "failed");
#else
                    showMsg("%04lX:%08lX - Change name to '%s' %s\n",
                        sym.seg, la, pname, didOk ? "succeeded" : "failed");
#endif
                }
            }
            else if (g_options.bReplace || !has_cmt(f))
            {
                // Apply symbols for comment
                didOk = set_cmt(la, pname, false);
#ifdef __EA64__
                showMsg("%04lX:%08llX - Change comment to '%s' %s\n",
                    sym.seg, la, pname, didOk ? "succeeded" : "failed");
#else
                showMsg("%04lX:%08lX - Change comment to '%s' %s\n",
                    sym.seg, la, pname, didOk ? "succeeded" : "failed");
#endif
            }
            if (didOk)
                validSyms++;
            else
                invalidSyms++;
        }

    }
    catch (...)
    {
        warning("Exception while parsing MAP file '%s'");
        invalidSyms++;
    }
    MapFile::closeMAP(pMapStart);
    hide_wait_box();

    if (sectnNumber == 0)
    {
        warning("File '%s' is not a valid Map file; publics section header wasn't found", fname);
    }
    else
    {
        // Save file name for next askfile_c dialog
        qstrncpy(mapFileName, fname, sizeof(mapFileName));

        // Show the result
        msg("Result of loading and parsing the Map file '%s'\n"
            "   Number of Symbols applied: %d\n"
            "   Number of Invalid Symbols: %d\n\n",
            fname, validSyms, invalidSyms);
    }
    return true;
}

////////////////////////////////////////////////////////////////////////////////
/// @brief Plugin terminate callback function
/// @return void
/// @author TQN
/// @date 2004.09.11
////////////////////////////////////////////////////////////////////////////////
void idaapi term(void)
{
    msg("LoadMap: Plugin v%s terminate.\n", PLUG_VERSION);

    // Write the plugin's options to cfg file
    if (!write_config_file("loadmap", g_optsinfo, qnumber(g_optsinfo)))
    {
        msg("LoadMap: Plugin config file '%s.cfg' save failed: %s.\n", "loadmap", qerrstr());
    }
}

////////////////////////////////////////////////////////////////////////////////
/// @name Plugin information
/// @{
char wanted_name[]   = "Load Symbols From MAP File";
char wanted_hotkey[] = "Ctrl-M";
char comment[]       = "LoadMap loads symbols from a VC/BC/Watcom/Dede map file.";
char help[]          = "LoadMap " PLUG_VERSION ", Visual C/Borland C/Watcom C/Dede map file import plugin."
                              "This module reads selected map file, and loads symbols\n"
                              "into IDA database. Click it while holding Shift to see options.";
/// @}

////////////////////////////////////////////////////////////////////////////////
/// @brief Plugin description block
extern "C" {
plugin_t PLUGIN =
{
    IDP_INTERFACE_VERSION,
    0,                    // Plugin flags
    init,                 // Initialize
    term,                 // Terminate
    run,                  // Main function
    comment,              // Comment about the plugin
    help,
    wanted_name,          // preferred short name of the plugin
    wanted_hotkey         // preferred hotkey to run the plugin
};
};
////////////////////////////////////////////////////////////////////////////////

```

`src/MAPReader.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////
/// @file MAPReader.h
///     MAP file analysis and loading routines.
/// @par Purpose:
///     Library for loading MAP file entries.
/// @author TQN <truong_quoc_ngan@yahoo.com>
/// @author TL <mefistotelis@gmail.com>
/// @date 2004.09.11 - 2018.11.08
/// @par  Copying and copyrights:
///     This program is free software; you can redistribute it and/or modify
///     it under the terms of the GNU General Public License as published by
///     the Free Software Foundation; either version 2 of the License, or
///     (at your option) any later version.
////////////////////////////////////////////////////////////////////////////////

#include  "MAPReader.h"

#include  <cstring>
#include  <cctype>
#include  <cassert>
#include  <cstdlib>

#include "stdafx.h"

using namespace std;

namespace MapFile {

/// @name Strings used to identify start of symbol table in various MAP files.
/// @{
const char MSVC_HDR_START[]        = "Address         Publics by Value              Rva+Base     Lib:Object";
const char MSVC_HDR_START2[]       = "Address         Publics by Value              Rva+Base       Lib:Object";
const char BCCL_HDR_NAME_START[]   = "Address         Publics by Name";
const char BCCL_HDR_VALUE_START[]  = "Address         Publics by Value";
const char WATCOM_MEMMAP_START[]   = "Address        Symbol";
const char WATCOM_MEMMAP_SKIP[]   = "=======        ======";
const char WATCOM_MEMMAP_COMMENT[] = "Module: ";
const char WATCOM_END_TABLE_HDR[]  = "+----------------------+";
const char MSVC_LINE_NUMBER[]      = "Line numbers for ";
const char MSVC_FIXUP[]            = "FIXUPS: ";
const char MSVC_EXPORTS[]          = " Exports";
const char GCC_MEMMAP_START[]      = "Linker script and memory map";
const char GCC_MEMMAP_SKIP1[]       = ".";
const char GCC_MEMMAP_SKIP2[]       = " .";
const char GCC_MEMMAP_SKIP3[]       = "*";
const char GCC_MEMMAP_SKIP4[]       = " *";
const char GCC_MEMMAP_END[]        = "OUTPUT(";
const char GCC_MEMMAP_LOAD[]       = "LOAD ";

/// @}

};

////////////////////////////////////////////////////////////////////////////////
/// @brief Open a map file and map the file content to virtual memory
/// @param lpszFileName  Path name of file to open.
/// @param dwSize Out variable to receive size of file.
/// @param lpMapAddr The pointer to memory address of mapped file
/// @return enum value of OPEN_FILE_ERROR
/// @author TQN
/// @date 2004.09.12
////////////////////////////////////////////////////////////////////////////////
MapFile::MAPResult MapFile::openMAP(const char * fileName, char * &mapAddr, size_t &dwSize)
{
    // Set default values for output parameters
    mapAddr = NULL;
    dwSize = INVALID_MAPFILE_SIZE;

    // Validate all input pointer parameters
    assert(NULL != fileName);
    if (NULL == fileName)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return WIN32_ERROR;
    }

    // Open the file
    HANDLE hFile = CreateFile(fileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                              OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        return WIN32_ERROR;
    }

    dwSize = GetFileSize(hFile, NULL);
    if ((INVALID_MAPFILE_SIZE == dwSize) || (0 == dwSize))
    {
        // File too large or empty
        WIN32CHECK(CloseHandle(hFile));
        return ((0 == dwSize) ? FILE_EMPTY_ERROR : WIN32_ERROR);
    }

    HANDLE hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (NULL == hMap)
    {
        WIN32CHECK(CloseHandle(hFile));
        return WIN32_ERROR;
    }

    // Mapping creation successful, do not need file handle anymore
    WIN32CHECK(CloseHandle(hFile));

    mapAddr = (LPSTR) MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, dwSize);
    if (NULL == mapAddr)
    {
        WIN32CHECK(CloseHandle(hMap));
        return WIN32_ERROR;
    }

    // Map View successful, do not need the map handle anymore
    WIN32CHECK(CloseHandle(hMap));

    if (NULL != memchr(mapAddr, 0, dwSize))
    {
        // File is binary or Unicode file
        WIN32CHECK(UnmapViewOfFile(mapAddr));
        mapAddr = NULL;
        return FILE_BINARY_ERROR;
    }

    return OPEN_NO_ERROR;
}

////////////////////////////////////////////////////////////////////////////////
/// @brief Close memory map file which opened by MemMapFileOpen function.
/// @param lpAddr: Pointer to memory return by MemMapFileOpen.
/// @author TQN
/// @date 2004.09.12
////////////////////////////////////////////////////////////////////////////////
void MapFile::closeMAP(const void * lpAddr)
{
    WIN32CHECK(UnmapViewOfFile(lpAddr));
}

////////////////////////////////////////////////////////////////////////////////
/// @brief Seek to non space character at the beginning of a memory buffer.
/// @param  lpStart Pointer to start of buffer
/// @param  lpEnd Pointer to end of buffer
/// @return Pointer to first non space character at the beginning of buffer
/// @author TQN
/// @date 2004.09.12
////////////////////////////////////////////////////////////////////////////////
const char * MapFile::skipSpaces(const char * pStart, const char * pEnd)
{
    assert(pStart != NULL);
    assert(pEnd != NULL);
    assert(pStart <= pEnd);

    const char * p = pStart;
    while ((p < pEnd) && isspace(*p))
    {
        p++;
    }

    return p;
}

////////////////////////////////////////////////////////////////////////////////
/// @brief Find the EOL character '\r' or '\n' in a memory buffer
/// @param  lpStart LPSTR Pointer to start of buffer
/// @param  lpEnd LPSTR Pointer to end of buffer
/// @return LPSTR Pointer to first EOL character in the buffer
/// @author TQN
/// @date 2004.09.12
////////////////////////////////////////////////////////////////////////////////
const char * MapFile::findEOL(const char * pStart, const char * pEnd)
{
    assert(pStart != NULL);
    assert(pEnd != NULL);
    assert(pStart <= pEnd);

    const char * p = pStart;
    while ((p < pEnd) && ('\r' != *p) && ('\n' != *p))
    {
        p++;
    }

    return p;
}

////////////////////////////////////////////////////////////////////////////////
/// @brief Checks if a line is the starting line of a section to be analyzed.
/// @param  pLine Pointer to start of buffer
/// @param  lineLen Length of the current line
/// @return Type of the new section, or NO_SECTION
/// @author TL
/// @date 2011.09.10
////////////////////////////////////////////////////////////////////////////////
MapFile::SectionType MapFile::recognizeSectionStart(const char *pLine, size_t lineLen)
{
    if (strncasecmp(pLine, MSVC_HDR_START, lineLen) == 0 || strncasecmp(pLine, MSVC_HDR_START2, lineLen) == 0)
        return MapFile::MSVC_MAP;
    if (strncasecmp(pLine, BCCL_HDR_NAME_START, lineLen) == 0)
        return MapFile::BCCL_NAM_MAP;
    if (strncasecmp(pLine, BCCL_HDR_VALUE_START, lineLen) == 0)
        return MapFile::BCCL_VAL_MAP;
    if (strncasecmp(pLine, WATCOM_MEMMAP_START, lineLen) == 0)
        return MapFile::WATCOM_MAP;
    if (strncasecmp(pLine, GCC_MEMMAP_START, lineLen) == 0)
        return MapFile::GCC_MAP;
    return MapFile::NO_SECTION;
}

////////////////////////////////////////////////////////////////////////////////
/// @brief Checks if a line is the ending line of a section we analyzed.
/// @param secType Type of the opened section.
/// @param  pLine Pointer to start of buffer
/// @param  lineLen Length of the current line
/// @return Type of the new section, or value of secType if no change
/// @author TL
/// @date 2011.09.10
////////////////////////////////////////////////////////////////////////////////
MapFile::SectionType MapFile::recognizeSectionEnd(MapFile::SectionType secType, const char *pLine, size_t lineLen)
{
    switch (secType)
    {
    case MapFile::MSVC_MAP:
        if (strncmp(pLine, MSVC_LINE_NUMBER, std::strlen(MSVC_LINE_NUMBER)) == 0)
            return MapFile::NO_SECTION;
        if (strncmp(pLine, MSVC_FIXUP, std::strlen(MSVC_FIXUP)) == 0)
            return MapFile::NO_SECTION;
        if (strncmp(pLine, MSVC_EXPORTS, std::strlen(MSVC_EXPORTS)) == 0)
            return MapFile::NO_SECTION;
        break;
    case MapFile::BCCL_NAM_MAP:
    case MapFile::BCCL_VAL_MAP:
        break;
    case MapFile::WATCOM_MAP:
        if (strncmp(pLine, WATCOM_END_TABLE_HDR, std::strlen(WATCOM_END_TABLE_HDR)) == 0)
            return MapFile::NO_SECTION;
        break;
    case MapFile::GCC_MAP:
        if (strncmp(pLine, GCC_MEMMAP_END, std::strlen(GCC_MEMMAP_END)) == 0)
            return MapFile::NO_SECTION;
        break;
    }
    return secType;
}

////////////////////////////////////////////////////////////////////////////////
/// @brief Reads one entry of Ms-like MAP file.
/// @param sym Target  buffer for symbol data.
/// @param  pLine Pointer to start of buffer
/// @param  lineLen Length of the current line
/// @param  minLineLen Minimal accepted length of line
/// @param numOfSegs Number of segments in IDA, used to verify segment number range
/// @return Result of the parsing
/// @author TL
/// @date 2011.09.10
////////////////////////////////////////////////////////////////////////////////
MapFile::ParseResult MapFile::parseMsSymbolLine(MapFile::MAPSymbol &sym, const char *pLine, size_t lineLen, size_t minLineLen, size_t numOfSegs)
{
    // Get segment number, address, name, by pass spaces at beginning,
    // between ':' character, between address and name
    long lineCut = lineLen;
    if (lineCut > MAXNAMELEN + minLineLen)
        lineCut = MAXNAMELEN + minLineLen;
    char * dupLine = (char *)std::malloc(lineCut+1);
    strncpy(dupLine,pLine,lineCut);
    dupLine[lineCut] = '\0';
    if (strncasecmp(dupLine, ";", 1) == 0)
    {
        strncpy(sym.name,dupLine+1,MAXNAMELEN-1);
        sym.name[MAXNAMELEN] = '\0';
        std::free(dupLine);
        return MapFile::COMMENT_LINE;
    }
    sym.addr = -1;
    int ret;
#ifdef __EA64__
    ret = sscanf(dupLine, " %04lX : %016llX %[^\t\n ;]", &sym.seg, &sym.addr, sym.name);
#else
    ret = sscanf(dupLine, " %04lX : %08lX %[^\t\n ;]", &sym.seg, &sym.addr, sym.name);
#endif
    std::free(dupLine);
    if (3 != ret)
    {
        // we have parsed to end of value/name symbols table or reached EOF
        return MapFile::FINISHING_LINE;
    }
    else if ((0 == sym.seg) || (--sym.seg >= numOfSegs) ||
            (-1 == sym.addr) || (std::strlen(sym.name) == 0) )
    {
        return MapFile::INVALID_LINE;
    }
    // Ensure name is NULL terminated
    sym.name[MAXNAMELEN] = '\0';
    return MapFile::SYMBOL_LINE;
}

////////////////////////////////////////////////////////////////////////////////
/// @brief Reads one entry of Watcom-like MAP file.
/// @param sym Target  buffer for symbol data.
/// @param  pLine Pointer to start of buffer
/// @param  lineLen Length of the current line
/// @param  minLineLen Minimal accepted length of line
/// @param numOfSegs Number of segments in IDA, used to verify segment number range
/// @return Result of the parsing
/// @author TL
/// @date 2011.09.10
////////////////////////////////////////////////////////////////////////////////
MapFile::ParseResult MapFile::parseWatcomSymbolLine(MapFile::MAPSymbol &sym, const char *pLine, size_t lineLen, size_t minLineLen, size_t numOfSegs)
{
    // Get segment number, address, name, by pass spaces at beginning,
    // between ':' character, between address and name
    long lineCut = lineLen;
    if (lineCut > MAXNAMELEN + minLineLen)
        lineCut = MAXNAMELEN + minLineLen;
    char * dupLine = (char *)std::malloc(lineCut+1);
    strncpy(dupLine,pLine,lineCut);
    dupLine[lineCut] = '\0';
    if (strncasecmp(dupLine, ";", 1) == 0)
    {
        strncpy(sym.name,dupLine+1,MAXNAMELEN-1);
        sym.name[MAXNAMELEN] = '\0';
        std::free(dupLine);
        return MapFile::COMMENT_LINE;
    }
    if (strncasecmp(dupLine, WATCOM_MEMMAP_SKIP, std::strlen(WATCOM_MEMMAP_SKIP)) == 0)
    {
        std::free(dupLine);
        return MapFile::SKIP_LINE;
    }
    if (strncasecmp(dupLine, WATCOM_MEMMAP_COMMENT, std::strlen(WATCOM_MEMMAP_COMMENT)) == 0)
    {
        strncpy(sym.name,dupLine+std::strlen(WATCOM_MEMMAP_COMMENT),MAXNAMELEN-1);
        sym.name[MAXNAMELEN] = '\0';
        std::free(dupLine);
        return MapFile::COMMENT_LINE;
    }
    int ret;
#ifdef __EA64__
    ret = sscanf(dupLine, " %04lX : %016llX%*c %[^\t\n;]", &sym.seg, &sym.addr, sym.name);
#else
    ret = sscanf(dupLine, " %04lX : %08lX%*c %[^\t\n;]", &sym.seg, &sym.addr, sym.name);
#endif
    std::free(dupLine);
    if (3 != ret)
    {
        // we have parsed to end of value/name symbols table or reached EOF
        return MapFile::FINISHING_LINE;
    }
    else if ((0 == sym.seg) || (--sym.seg >= numOfSegs) ||
            (-1 == sym.addr) || (std::strlen(sym.name) == 0) )
    {
        return MapFile::INVALID_LINE;
    }
    // Ensure name is NULL terminated
    sym.name[MAXNAMELEN] = '\0';
    return MapFile::SYMBOL_LINE;
}

////////////////////////////////////////////////////////////////////////////////
/// @brief Reads one entry of GCC-like MAP file.
/// @param sym Target  buffer for symbol data.
/// @param  pLine Pointer to start of buffer
/// @param  lineLen Length of the current line
/// @param  minLineLen Minimal accepted length of line
/// @param numOfSegs Number of segments in IDA, used to verify segment number range
/// @return Result of the parsing
/// @author TL
/// @date 2012.07.18
////////////////////////////////////////////////////////////////////////////////
MapFile::ParseResult MapFile::parseGccSymbolLine(MapFile::MAPSymbol &sym, const char *pLine, size_t lineLen, size_t minLineLen, size_t numOfSegs)
{
    // Get segment number, address, name, by pass spaces at beginning,
    // between ':' character, between address and name
    long lineCut = lineLen;
    if (lineCut > MAXNAMELEN + minLineLen)
        lineCut = MAXNAMELEN + minLineLen;
    char * dupLine = (char *)std::malloc(lineCut+1);
    strncpy(dupLine,pLine,lineCut);
    dupLine[lineCut] = '\0';
    if (strncasecmp(dupLine, ";", 1) == 0)
    {
        strncpy(sym.name,dupLine+1,MAXNAMELEN-1);
        sym.name[MAXNAMELEN] = '\0';
        std::free(dupLine);
        return MapFile::COMMENT_LINE;
    }
    if ( (strncasecmp(dupLine, GCC_MEMMAP_SKIP1, std::strlen(GCC_MEMMAP_SKIP1)) == 0) ||
         (strncasecmp(dupLine, GCC_MEMMAP_SKIP2, std::strlen(GCC_MEMMAP_SKIP2)) == 0) )
    {
        std::free(dupLine);
        return MapFile::SKIP_LINE;
    }
    if ( (strncasecmp(dupLine, GCC_MEMMAP_SKIP3, std::strlen(GCC_MEMMAP_SKIP3)) == 0) ||
         (strncasecmp(dupLine, GCC_MEMMAP_SKIP4, std::strlen(GCC_MEMMAP_SKIP4)) == 0) )
    {
        std::free(dupLine);
        return MapFile::SKIP_LINE;
    }
    if (strncasecmp(dupLine, GCC_MEMMAP_LOAD, std::strlen(GCC_MEMMAP_LOAD)) == 0)
    {
        strncpy(sym.name,dupLine,MAXNAMELEN-1);
        sym.name[MAXNAMELEN] = '\0';
        std::free(dupLine);
        return MapFile::COMMENT_LINE;
    }
    int ret;
#ifdef __EA64__
    unsigned long long linear_addr;
    ret = sscanf(dupLine, " 0x%016llX%*c %[^\t\n;]", &linear_addr, sym.name);
#else
    unsigned long linear_addr;
    ret = sscanf(dupLine, " 0x%08lX%*c %[^\t\n;]", &linear_addr, sym.name);
#endif
    std::free(dupLine);
    if (2 != ret)
    {
        // we have parsed to end of value/name symbols table or reached EOF
        return MapFile::FINISHING_LINE;
    }
    linearAddressToSymbolAddr(sym, linear_addr);
    if ((sym.seg >= numOfSegs) || (-1 == sym.addr) || (std::strlen(sym.name) == 0) )
    {
        return MapFile::INVALID_LINE;
    }
    // Ensure name is NULL terminated
    sym.name[MAXNAMELEN] = '\0';
    return MapFile::SYMBOL_LINE;
}

////////////////////////////////////////////////////////////////////////////////

```

`src/MAPReader.h`:

```h
////////////////////////////////////////////////////////////////////////////////
/// @file MAPReader.h
///     MAP file analysis and loading routines header.
/// @par Purpose:
///     Library for loading MAP file entries.
/// @author TQN <truong_quoc_ngan@yahoo.com>
/// @author TL <mefistotelis@gmail.com>
/// @date 2004.09.11 - 2018.11.08
/// @par  Copying and copyrights:
///     This program is free software; you can redistribute it and/or modify
///     it under the terms of the GNU General Public License as published by
///     the Free Software Foundation; either version 2 of the License, or
///     (at your option) any later version.
////////////////////////////////////////////////////////////////////////////////

#ifndef MAPREADER_H_
#define MAPREADER_H_

#include  <cstdio>

#define MAXNAMELEN      512
#define INVALID_MAPFILE_SIZE	(0xffffffff)

namespace MapFile {

typedef enum {
    NO_SECTION = 0,
    MSVC_MAP,
    BCCL_NAM_MAP,
    BCCL_VAL_MAP,
    WATCOM_MAP,
    GCC_MAP
} SectionType;

typedef enum {
    OPEN_NO_ERROR = 0,
    WIN32_ERROR,
    FILE_EMPTY_ERROR,
    FILE_BINARY_ERROR
} MAPResult;

typedef enum {
    SKIP_LINE = 0,
    INVALID_LINE,
    FINISHING_LINE,
    COMMENT_LINE,
    SYMBOL_LINE,
} ParseResult;

typedef struct {
    unsigned long seg;
#ifdef __EA64__
    unsigned long long addr;
#else
    unsigned long addr;
#endif
    char name[MAXNAMELEN + 1];
} MAPSymbol;

void closeMAP(const void * lpAddr);
MAPResult openMAP(const char * lpszFileName, char * &lpMapAddr, size_t &dwSize);
const char * skipSpaces(const char * pStart, const char * pEnd);
const char * findEOL(const char * pStart, const char * pEnd);
MapFile::SectionType recognizeSectionStart(const char *pLine, size_t lineLen);
MapFile::SectionType recognizeSectionEnd(MapFile::SectionType secType, const char *pLine, size_t lineLen);
MapFile::ParseResult parseMsSymbolLine(MapFile::MAPSymbol &sym, const char *pLine, size_t lineLen, size_t minLineLen, size_t numOfSegs);
MapFile::ParseResult parseWatcomSymbolLine(MapFile::MAPSymbol &sym, const char *pLine, size_t lineLen, size_t minLineLen, size_t numOfSegs);
MapFile::ParseResult parseGccSymbolLine(MapFile::MAPSymbol &sym, const char *pLine, size_t lineLen, size_t minLineLen, size_t numOfSegs);

};

// Converts address in linear form into seg:offs, using target executable sections list
#ifdef __EA64__
void linearAddressToSymbolAddr(MapFile::MAPSymbol &sym, unsigned long long linear_addr);
#else
void linearAddressToSymbolAddr(MapFile::MAPSymbol &sym, unsigned long linear_addr);
#endif

#endif

```

`src/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// LoadMap.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include <cstring>

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////
/// @brief Changes extension in given file name buffer
/// @return void
/// @author TL
/// @date 2011.08.07
 ////////////////////////////////////////////////////////////////////////////////
void pathExtensionSwitch(char * fname, const char * newext, size_t fnbuf_len)
{
    size_t len,extlen;
    char * target;
    char * mintarget;
    len = std::strlen(fname);
    target = std::strrchr(fname,'.');
    mintarget = std::strpbrk(fname,":\\/");
    if ( (target == NULL) || (target <= mintarget) )
        target = fname+len;
    extlen = std::strlen(newext);
    // If end of the buffer
    if (target+extlen+1 >= fname+fnbuf_len)
        return;
    strncpy(target, newext, extlen+1);
}


```

`src/stdafx.h`:

```h
////////////////////////////////////////////////////////////////////////////////
/// @file stdafx.h
///     Include file for standard system include files.
/// @par Purpose:
///     Includes standard system headers, or project specific include files
///     that are used frequently, but are changed infrequently.
/// @author TQN <truong_quoc_ngan@yahoo.com>
/// @author TL <mefistotelis@gmail.com>
/// @date 2004.09.11 - 2011.09.13
/// @par  Copying and copyrights:
///     This program is free software; you can redistribute it and/or modify
///     it under the terms of the GNU General Public License as published by
///     the Free Software Foundation; either version 2 of the License, or
///     (at your option) any later version.
////////////////////////////////////////////////////////////////////////////////
#ifndef STDAFX_H_
#define STDAFX_H_

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#define _OBJC_NO_COM
//#define WINSHLWAPI
#define NOGDI
//#define _X86_
#define _AMD64_
#include <windef.h>
#include <basetyps.h>
#include <cstdarg>
#include <winbase.h>
#include <winuser.h>
//#include <windows.h>

// C RTL Debug Support Header Files
//#include <crtdbg.h>

// Shell Lightweight API
#include <winreg.h>
#include <shlwapi.h>
#pragma comment(lib, "shlwapi.lib")

#define strncasecmp strnicmp

void pathExtensionSwitch(char * fname, const char * newext, size_t fnbuf_len);

    #define _VERIFY(x)  (x)
    #define WIN32CHECK(x)   (x)

#endif //!STDAFX_H_
////////////////////////////////////////////////////////////////////////////////

```