Project Path: arc_enenH_pwatch-c_2qf_en2k

Source Tree:

```txt
arc_enenH_pwatch-c_2qf_en2k
├── CMakeLists.txt
├── PerfMap.cpp
├── PerfMap.h
├── README.md
├── m.bat
└── main.cpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.28)

if (NOT DEFINED CMAKE_ANDROID_NDK)
    set(CMAKE_ANDROID_NDK D:/Android/SDK/ndk/27.0.11718014)
    set(CMAKE_TOOLCHAIN_FILE ${CMAKE_ANDROID_NDK}/build/cmake/android.toolchain.cmake)
    set(CMAKE_SYSTEM_NAME Android)
    set(CMAKE_SYSTEM_VERSION 24)
    set(CMAKE_ANDROID_ARCH_ABI arm64-v8a)
    set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
    set(ANDROID_ABI arm64-v8a)
    set(ANDROID_PLATFORM android-26)
    set(ANDROID_NDK ${CMAKE_ANDROID_NDK})
else ()
    SET(ANDROID_STUDIO_BUILD true)
endif ()


project(pwatch_c)

set(CMAKE_CXX_STANDARD 23)

add_executable(pwatch_c
        main.cpp
        PerfMap.cpp)

target_link_libraries(pwatch_c)
```

`PerfMap.cpp`:

```cpp
#include "PerfMap.h"

#include <cstdio>
#include <iostream>
#include <poll.h>
#include <asm-generic/unistd.h>
#include <bits/ioctl.h>
#include <linux/perf_event.h>
#include <sys/mman.h>
#include <unistd.h>

static int perf_event_open(struct perf_event_attr* evt_attr, pid_t pid,
                           int cpu, int group_fd, unsigned long flags) {
    int ret;
    ret = syscall(__NR_perf_event_open, evt_attr, pid, cpu, group_fd, flags);
    return ret;
}

int PerfMap::create(const std::vector<int>& pids, uintptr_t bp_addr, int bp_type, size_t bp_len, int buf_size) {
    perf_event_attr attr{};
    attr.size = sizeof(attr);
    attr.type = PERF_TYPE_BREAKPOINT;
    attr.config = PERF_COUNT_SW_CPU_CLOCK;
    attr.watermark = 0;
    attr.sample_type = PERF_SAMPLE_TID | PERF_SAMPLE_REGS_USER;
    attr.sample_period = 1;
    attr.wakeup_events = 1;
    attr.precise_ip = 2; //同步

    attr.disabled = 1;
    attr.exclude_kernel = 1;
    attr.exclude_hv = 1;

    attr.bp_type = bp_type;
    attr.bp_addr = bp_addr;
    attr.bp_len = bp_len;

    attr.sample_regs_user = ((1ULL << PERF_REG_ARM64_MAX) - 1);
    attr.mmap = 1;
    attr.comm = 1;
    attr.mmap_data = 1;
    attr.mmap2 = 1;

    for (int pid : pids) {
        PerfInfo info{};
        int fd = perf_event_open(&attr, pid, -1, -1, PERF_FLAG_FD_CLOEXEC);
        if (fd < 0) {
            printf("%d perf_event_open error %s\n", pid, strerror(errno));
            continue;
        }
        ioctl(fd, PERF_EVENT_IOC_RESET, 0);
        ioctl(fd, PERF_EVENT_IOC_ENABLE, 0);

        info.fd = fd;
        info.mmap_size = (1 + (1 << buf_size)) * PAGE_SIZE;
        info.mmap_addr = mmap(nullptr, info.mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
        if (info.mmap_addr == MAP_FAILED) {
            printf("%d mmap error %s\n", pid, strerror(errno));
            close(fd);
            continue;
        }
        _perf_infos.push_back(info);
    }
    return 0;
}

void PerfMap::process(const std::function<void(const SampleData&)>& handle, const bool* loop) {
    if (_perf_infos.empty()) {
        printf("No perf event to process\n");
        return;
    }
    pollfd perf_poll[_perf_infos.size()];

    for (int i = 0; i < _perf_infos.size(); i++) {
        auto& info = _perf_infos[i];
        info.mmap_page_metadata = (perf_event_mmap_page*)info.mmap_addr;
        info.data_addr = (uintptr_t)info.mmap_addr + info.mmap_page_metadata->data_offset;
        info.read_data_size = 0;
        info.data_size = info.mmap_page_metadata->data_size;
        perf_poll[i].fd = info.fd;
        perf_poll[i].events = POLLIN;
    }

    while (loop == nullptr || *loop) {
        //每两秒退出一下 防止卡死
        int ret = poll(perf_poll, _perf_infos.size(), 2000);
        if (ret <= 0) {
            continue;
        }
        for (int i = 0; i < _perf_infos.size(); i++) {
            auto& info = _perf_infos[i];
            if (perf_poll[i].revents & POLLIN) {
                while (info.mmap_page_metadata->data_head != info.read_data_size) {
                    auto get_addr = [&](size_t offset) {
                        return info.data_addr + ((info.read_data_size + offset) % info.data_size);
                    };
                    auto data_header = (perf_event_header*)get_addr(0);
                    auto offset = sizeof(perf_event_header);
                    if (data_header->type == PERF_RECORD_SAMPLE) {
                        auto pid = *(uint32_t*)get_addr(offset);
                        offset += 4;
                        auto tid = *(uint32_t*)get_addr(offset);
                        offset += 4;
                        auto abi = *(uint64_t*)get_addr(offset);
                        offset += 8;

                        SampleData data{};
                        for (unsigned long& reg : data.regs) {
                            reg = *(uint64_t*)get_addr(offset);
                            offset += 8;
                        }
                        data.pid = pid;
                        data.tid = tid;
                        data.abi = abi;
                        handle(data);
                        if (loop != nullptr && *loop == false) {
                            return;
                        }
                    }
#ifndef NDEBUG
                    else if (data_header->type == PERF_RECORD_LOST) {
                        auto lost = *(uint64_t*)get_addr(offset);
                        std::cout << "-------" << std::endl;
                        std::cout << "Lost " << lost << " events" << std::endl;
                    } else {
                        std::cout << "-------" << std::endl;
                        std::cout << "Unknown type" << std::endl;
                    }
#endif
                    info.read_data_size += data_header->size;
                    info.mmap_page_metadata->data_tail = info.read_data_size;
                }
            }
        }
    }
}

void PerfMap::enable() {
    for (auto& info : _perf_infos) {
        ioctl(info.fd, PERF_EVENT_IOC_ENABLE, 0);
    }
}

void PerfMap::disable() {
    for (auto& info : _perf_infos) {
        ioctl(info.fd, PERF_EVENT_IOC_RESET, 0);
        ioctl(info.fd, PERF_EVENT_IOC_DISABLE, 0);
    }
}

void PerfMap::destroy() {
    for (auto& info : _perf_infos) {
        if (info.fd) {
            ioctl(info.fd, PERF_EVENT_IOC_DISABLE, 0);
            close(info.fd);
        }
        if (info.mmap_addr) {
            munmap(info.mmap_addr, info.mmap_size);
        }
    }
    _perf_infos.clear();
}

```

`PerfMap.h`:

```h
#pragma once
#include <cstdint>
#include <functional>
#include <asm/perf_regs.h>
#include <linux/perf_event.h>
#include <linux/hw_breakpoint.h>
struct SampleData {
    uint32_t pid;
    uint32_t tid;
    uint64_t abi;
    uint64_t regs[PERF_REG_ARM64_MAX];
};

class PerfMap {
    struct PerfInfo {
        int pid = 0;
        int fd = 0;
        void* mmap_addr = nullptr;

        size_t mmap_size = 0;
        perf_event_mmap_page* mmap_page_metadata = nullptr;
        uintptr_t data_addr = 0;
        uintptr_t data_size = 0;
        int read_data_size = 0;
    };

    std::vector<PerfInfo> _perf_infos;

public:
    int create(const std::vector<int>& pids, uintptr_t bp_addr, int bp_type, size_t bp_len, int buf_size = 0);

    void process(const std::function<void(const SampleData&)>& handle, const bool* loop = nullptr);

    void enable();

    void disable();

    void destroy();
};

```

`README.md`:

```md
# pwatch-c
android上使用c++用perf来硬件断点尝试

警告，用户层已经有对应方法来检测，并不是无痕

参考：
[pwatch](https://github.com/ri-char/pwatch)



```

`m.bat`:

```bat
REM  m.bat | $CMakeCurrentTargetName$ | $ProjectFileDir$
REM adb connect ip:port
adb push cmake-build-debug\%1 /data/local/tmp
adb shell su -c chmod +x /data/local/tmp/%1
adb shell su -c /data/local/tmp/%1

```

`main.cpp`:

```cpp
#include <iostream>
#include <vector>
#include <sys/ioctl.h>
#include <unistd.h>
#include <cstdio>
#include <dirent.h>
#include <pthread.h>
#include <sstream>

#include "PerfMap.h"

static std::vector<int> GetProcessTask(int pid) {
    std::vector<int> vOutput;
    DIR* dir = nullptr;
    struct dirent* ptr = nullptr;
    char szTaskPath[256] = {0};
    sprintf(szTaskPath, "/proc/%d/task", pid);

    dir = opendir(szTaskPath);
    if (nullptr != dir) {
        while ((ptr = readdir(dir)) != nullptr) // 循环读取路径下的每一个文件/文件夹
        {
            // 如果读取到的是"."或者".."则跳过，读取到的不是文件夹名字也跳过
            if ((strcmp(ptr->d_name, ".") == 0) || (strcmp(ptr->d_name, "..") == 0)) {
                continue;
            } else if (ptr->d_type != DT_DIR) {
                continue;
            } else if (strspn(ptr->d_name, "1234567890") != strlen(ptr->d_name)) {
                continue;
            }

            int task = atoi(ptr->d_name);
            char buff[1024];
            sprintf(buff, "/proc/%d/task/%d/comm", pid, task);
            FILE* fp = fopen(buff, "r");
            if (fp) {
                char name[1024]{0};
                fgets(name, sizeof(name), fp);
                fclose(fp);
                std::string_view sv(name);
                const char* blacklist[] = {
                    "RenderThread",
                    "FinalizerDaemon",
                    "RxCachedThreadS",
                    "mali-cmar-backe",
                    "mali-utility-wo",
                    "mali-mem-purge",
                    "mali-hist-dump",
                    "mali-event-hand",
                    "hwuiTask0",
                    "hwuiTask1",
                    "NDK MediaCodec_",
                };
                for (auto& i : blacklist) {
                    if (sv.find(i) != std::string_view::npos) {
                        continue;
                    }
                }
                if (sv.starts_with("binder:") || sv.starts_with("twitter")) {
                    continue;
                }
                /*   LOGD("task %d %s", task, name);*/
                vOutput.push_back(task);
            }
        }
        closedir(dir);
    }
    return vOutput;
}

static const std::string regNames[] = {
    "x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7",
    "x8", "x9", "x10", "x11", "x12", "x13", "x14", "x15",
    "x16", "x17", "x18", "x19", "x20", "x21", "x22", "x23",
    "x24", "x25", "x26", "x27", "x28", "x29", "lr", "sp",
    "pc", "max"
};

int main() {
    pthread_t t;
    pthread_create(&t, nullptr, [](void*) -> void* {
        const auto tasks = GetProcessTask(28944);
        for (auto& task : tasks) {
            std::cout << "task: " << task << std::endl;
        }
        PerfMap perfMap;
        perfMap.create(tasks, 0x73EF915AD4, HW_BREAKPOINT_X, HW_BREAKPOINT_LEN_4, 4);
        perfMap.process([&](const SampleData& data) {
            std::cout << "pid: " << data.pid << " tid: " << data.tid << " abi: " << data.abi << std::endl;
            std::string message;
            for (int i = 0; i < PERF_REG_ARM64_MAX; i++) {
                std::stringstream ss;
                ss << std::hex << data.regs[i];
                message += regNames[i] + ": 0x" + ss.str() + "|";
            }
            std::cout << message << std::endl;
            std::cout << "---------------------------" << std::endl;
        });
        perfMap.destroy();
        return nullptr;
    }, nullptr);

    sleep(5);
    return 0;
}

```