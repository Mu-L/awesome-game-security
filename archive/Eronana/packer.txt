Project Path: arc_Eronana_packer_36rr73_n

Source Tree:

```txt
arc_Eronana_packer_36rr73_n
├── LICENSE
├── README.md
├── compressor
├── packer
│   ├── PE.cpp
│   ├── PE.h
│   ├── main.cpp
│   ├── packer.cpp
│   ├── packer.h
│   ├── packer.vcxproj
│   ├── packer.vcxproj.filters
│   ├── shell.cpp
│   ├── shell.h
│   ├── shell_data.h
│   └── shellcode.bin
└── packer.sln

```

`LICENSE`:

```
MIT License

Copyright (c) 2017 Erona

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# packer
This is a packer for exe under win32.

You can use it to pack any 32-bit exe file.

## Build
**Please use `Microsoft Visual Studio Community 2015` to build this project.**
1. Open `packer.sln` by VS
2. Build

## Compressor
This project use [compressor](https://github.com/Eronana/compressor) to compress data to reduce exe file iexe

## Extension
Another branch [selfvalid](https://github.com/Eronana/packer/tree/selfvalid) with self-validation function that showns how to extend this very basic packer.

## Usage
Just run `packer a.exe`.

`a.exe` is the file you want to pack.

This is detail usage from `packer.exe`:
```
Usage: packer a.exe [options]
Options:
  -level: compression level. 0 for store, 9 for highest
          compression ratio. default is 3.
  -lazy : set max lazy match, default is 8.
  -chain: set max length of find in hash chain, default is 32.

Notice: lazy and chain will be ignored if you setted level.
```

```

`packer.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.24720.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "packer", "packer\packer.vcxproj", "{47D655EA-750C-4555-900F-4C815C0EDADB}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{47D655EA-750C-4555-900F-4C815C0EDADB}.Debug|x64.ActiveCfg = Debug|x64
		{47D655EA-750C-4555-900F-4C815C0EDADB}.Debug|x64.Build.0 = Debug|x64
		{47D655EA-750C-4555-900F-4C815C0EDADB}.Debug|x86.ActiveCfg = Debug|Win32
		{47D655EA-750C-4555-900F-4C815C0EDADB}.Debug|x86.Build.0 = Debug|Win32
		{47D655EA-750C-4555-900F-4C815C0EDADB}.Release|x64.ActiveCfg = Release|x64
		{47D655EA-750C-4555-900F-4C815C0EDADB}.Release|x64.Build.0 = Release|x64
		{47D655EA-750C-4555-900F-4C815C0EDADB}.Release|x86.ActiveCfg = Release|Win32
		{47D655EA-750C-4555-900F-4C815C0EDADB}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`packer/PE.cpp`:

```cpp
#include "PE.h"
#include <string>

PE::PE()
{
	init();
}

PE::PE(const char *filename) :PE()
{
	load(filename);
}

PE::~PE()
{
	clear();
}
void PE::init()
{
	overlay_size = 0;
}
bool read(void *buffer, size_t size, FILE *fp, long offset = -1)
{
	if (~offset&&fseek(fp, offset, SEEK_SET))return false;
	return fread(buffer, size, 1, fp) == 1;
}

bool write(void *buffer, size_t size, FILE *fp, long offset = -1)
{
	if (~offset&&fseek(fp, offset, SEEK_SET))return false;
	return fwrite(buffer, size, 1, fp) == 1;
}

DWORD align(DWORD n, DWORD m)
{
	return (n + m - 1) / m*m;
}

void PE::load(const char *filename)
{
	FILE *fp = fopen(filename, "rb");
	if (!fp)THROW_S("cannot open file ", filename);
	try
	{
		// read dos header
		if (!read(&dos_header, sizeof(dos_header), fp))THROW("cannot read DOS header");
		// check "MZ"
		if (dos_header.e_magic != IMAGE_DOS_SIGNATURE)THROW("incorrect DOS signature");
		// calculate dos stub size
		int dos_stub_size = dos_header.e_lfanew - sizeof(dos_header);
		if (dos_stub_size > 0)
		{
			// new a space to store dos stub
			dos_stub = AUTO_BYTE(new BYTE[dos_stub_size]);
			// read dos stub
			if (!read(dos_stub.get(), dos_stub_size, fp))THROW("cannot read DOS stub");
		}
		// read nt header
		if (!read(&nt_header, sizeof(nt_header), fp))THROW("cannot NT header");
		// check "PE"
		if (nt_header.Signature != IMAGE_NT_SIGNATURE)THROW("incorrect NT signature");
		// check whether it's 32-bit
		if (nt_header.OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC)THROW_S(filename, " is not a valid 32-bit PE file");
		// check whether it's a dll file
		if (nt_header.FileHeader.Characteristics&IMAGE_FILE_DLL)THROW_S(filename, " is not a valid exe file");

		// read section headers
		int NumberOfSections = nt_header.FileHeader.NumberOfSections;
		sections.resize(NumberOfSections);
		for (auto &section : sections)
			if (!read(&section.header, sizeof(section.header), fp))
				THROW("cannot section headers");

		// read section datas
		for (auto &section : sections)if(section.header.SizeOfRawData)
		{
			section.data = AUTO_BYTE(new BYTE[section.header.SizeOfRawData]);
			if (!read(section.data.get(), section.header.SizeOfRawData, fp, section.header.PointerToRawData))
				THROW("cannot section datas");
		}

		// read overlay data
		fseek(fp, 0, SEEK_END);
		size_t file_size = ftell(fp);
		DWORD pe_size = getPESize();
		if (pe_size < file_size)
		{
			overlay_size = file_size - pe_size;
			overlay = AUTO_BYTE(new BYTE[overlay_size]);
			if (!read(overlay.get(), overlay_size, fp, pe_size))THROW("cannot read overlay data");
		}
	}
	catch (...)
	{
		fclose(fp);
		clear();
		throw;
	}
	fclose(fp);
}

void PE::save(const char *filename)
{
	FILE *fp = fopen(filename, "wb");
	if (!fp)THROW_S("cannot open file ", filename);
	try
	{
		// write dos header
		if (!write(&dos_header, sizeof(dos_header), fp))THROW("cannot write DOS header");

		// read dos stub
		int dos_stub_size = dos_header.e_lfanew - sizeof(dos_header);
		if (dos_stub_size > 0 && !write(dos_stub.get(), dos_stub_size, fp))THROW("cannot write DOS stub");

		// read nt header
		if (!write(&nt_header, sizeof(nt_header), fp))THROW("cannot write NT header");

		// write section headers
		for (auto &section : sections)
			if (!write(&section.header, sizeof(section.header), fp))
				THROW("cannot write section headers");

		// write section datas
		for (auto &section : sections)
			if (section.header.SizeOfRawData&&!write(section.data.get(), section.header.SizeOfRawData, fp, section.header.PointerToRawData))
				THROW("cannot write section datas");

		// write overlay data
		if (overlay_size&&!write(overlay.get(), overlay_size, fp))THROW("cannot write overlay data");
	}
	catch (...)
	{
		fclose(fp);
		throw;
	}
	fclose(fp);
}

bool PE::wipeReloc()
{
	auto &BaseReloc = nt_header.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
	if (BaseReloc.VirtualAddress)
	{
		// try to remove .reloc
		if (!removeSection(BaseReloc.VirtualAddress))return false;
		BaseReloc.VirtualAddress = 0;
		BaseReloc.Size = 0;
	}
	// clear reloc info
	nt_header.FileHeader.Characteristics |= IMAGE_FILE_RELOCS_STRIPPED;
	for (auto &sec : sections)sec.header.NumberOfRelocations = 0;
	return true;
}

void PE::wipeBoundImport()
{
	auto &boundImport = nt_header.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT];
	boundImport.VirtualAddress = boundImport.Size = 0;
}

void PE::setSizeOfImage()
{
	nt_header.OptionalHeader.SizeOfImage = getNextSectionRva();
}

void PE::addSection(BYTE Name[], DWORD VirtualSize, DWORD SizeOfRawData, DWORD Characteristics)
{
	// calculate aligned SizeOfRawData
	SizeOfRawData = align(SizeOfRawData, nt_header.OptionalHeader.FileAlignment);
	// calculate new SizeOfHeaders
	DWORD newSizeOfHeaders = align(dos_header.e_lfanew + sizeof(IMAGE_NT_HEADERS) + sizeof(IMAGE_SECTION_HEADER)*(sections.size() + 1), nt_header.OptionalHeader.FileAlignment);
	
	// if necessary, relocate PointerToRawData of sections and increment SizeOfHeaders
	int soh_detal = newSizeOfHeaders - nt_header.OptionalHeader.SizeOfHeaders;
	if (soh_detal > 0)
	{
		for (auto &sec : sections)
			if (sec.header.PointerToRawData >= nt_header.OptionalHeader.SizeOfHeaders)
				sec.header.PointerToRawData += soh_detal;
		nt_header.OptionalHeader.SizeOfHeaders += soh_detal;
	}
	
	PE_SECTION section = {
		{
			{ }, // Name
			{ VirtualSize }, // Misc
			getNextSectionRva(), // VirtualAddress
			SizeOfRawData, // SizeOfRawData
			getPESize(), // PointerToRawData
			0, 0, 0, 0, // PointerToRelocations, PointerToLinenumbers, NumberOfRelocations, NumberOfLinenumbers
			Characteristics
		},
		AUTO_BYTE(new BYTE[SizeOfRawData]())
	};
	// copy Name
	for (int i = 0; i < 8 && Name[i]; i++)section.header.Name[i] = Name[i];
	// add section to sections 
	sections.push_back(std::move(section));
	// increment NumberOfSections
	nt_header.FileHeader.NumberOfSections++;
	// set SizeOfImage
	setSizeOfImage();
}

bool PE::removeSection(DWORD VirtualAddress)
{
	PE_SECTION d_section;
	int i;
	for (i = 0; i < sections.size(); i++)
	{
		// find section by VirutalAddress
		if (sections[i].header.VirtualAddress == VirtualAddress)
		{
			d_section = std::move(sections[i]);
			// reset VirtualSize
			if (i&&i != sections.size() - 1)
				sections[i - 1].header.Misc.VirtualSize += align(sections[i].header.Misc.VirtualSize, nt_header.OptionalHeader.SectionAlignment);
			// move subsequent sections
			for (int j = i + 1; j < sections.size(); j++)sections[j - 1] = std::move(sections[j]);
			break;
		}
	}
	// cannot found the matching section
	if (i == sections.size())return false;

	// decrement size of sections 
	sections.resize(sections.size() - 1);

	DWORD d_PointerToRawData = d_section.header.PointerToRawData;
	DWORD d_SizeOfRawData = d_section.header.SizeOfRawData;
	// Compact raw data
	compactRawData(d_PointerToRawData, d_SizeOfRawData);

	// decrement NumberOfSections
	nt_header.FileHeader.NumberOfSections--;
	// set SizeOfImage
	setSizeOfImage();
	return true;
}

void PE::compactRawData(DWORD PointerToRawData, DWORD SizeOfRawData)
{
	SizeOfRawData = align(SizeOfRawData, 0x200);
	for (auto &sec : sections)
		if (sec.header.PointerToRawData > PointerToRawData)
			sec.header.PointerToRawData -= SizeOfRawData;
}

DWORD PE::getPESize()
{
	DWORD pe_size = 0;
	for (auto &section : sections)
		if (section.header.SizeOfRawData)
			pe_size = max(pe_size, section.header.PointerToRawData + section.header.SizeOfRawData);
	pe_size = align(pe_size, nt_header.OptionalHeader.FileAlignment);
	return pe_size;
}

DWORD PE::getNextSectionRva()
{
	auto &header = sections.rbegin()->header;
	return header.VirtualAddress + align(header.Misc.VirtualSize, nt_header.OptionalHeader.SectionAlignment);
}

int PE::getSectionByRva(DWORD rva)
{
	for (int i = 0; i < sections.size();i++)
	{
		auto &section = sections[i];
		if (rva >= section.header.VirtualAddress&&rva < section.header.VirtualAddress + section.header.Misc.VirtualSize)return i;
	}
	return -1;
}

void *PE::getDataByRva(DWORD rva)
{
	int idx = getSectionByRva(rva);
	if (idx == -1)return NULL;
	return sections[idx].data.get() + (rva - sections[idx].header.VirtualAddress);
}

void *PE::getDataByRaw(DWORD raw)
{
	for (auto &section : sections)
	{
		if (section.header.PointerToRawData >= raw&&raw < section.header.PointerToRawData + section.header.SizeOfRawData)
		{
			return section.data.get() + (raw - section.header.PointerToRawData);
		}
	}
	return NULL;
}

IMAGE_DOS_HEADER &PE::getDosHeader()
{
	return dos_header;
}

IMAGE_NT_HEADERS &PE::getNtHeader()
{
	return nt_header;
}

BYTE *PE::getDosStub()
{
	return dos_stub.get();
}

std::vector<PE_SECTION> &PE::getSections()
{
	return sections;
}

BYTE *PE::getOverlay()
{
	return overlay.get();
}
void PE::clear()
{
	// free dos stub
	dos_stub.reset();
	// free section 
	sections.clear();
	// free overlay data
	overlay.reset();
	// init
	init();
}

```

`packer/PE.h`:

```h
#pragma once

#include "windows.h"
#include <cstdio>
#include <vector>
#include <memory>


typedef std::unique_ptr<BYTE[]> AUTO_BYTE;
#define THROW(S) throw std::string(S)
#define THROW_S(S,A) throw std::string(S)+A

struct PE_SECTION
{
	IMAGE_SECTION_HEADER header;
	AUTO_BYTE data;
};

class PE
{
private:
	IMAGE_DOS_HEADER dos_header;
	IMAGE_NT_HEADERS nt_header;
	AUTO_BYTE dos_stub;
	std::vector<PE_SECTION> sections;
	DWORD overlay_size;
	AUTO_BYTE overlay;
	void init();
	void setSizeOfImage();
public:
	PE();
	PE(const char *filename);
	~PE();
	void load(const char *filename);
	void save(const char *filename);
	bool wipeReloc();
	void wipeBoundImport();
	void clear();
	void addSection(BYTE name[], DWORD VirtualSize, DWORD SizeOfRawData,DWORD Characteristics);
	bool removeSection(DWORD VirtualSize);
	DWORD getPESize();
	DWORD getNextSectionRva();
	int getSectionByRva(DWORD rva);
	void *getDataByRva(DWORD rva);
	void *getDataByRaw(DWORD raw);
	void compactRawData(DWORD PointerToRawData, DWORD SizeOfRawData);
	IMAGE_DOS_HEADER &getDosHeader();
	IMAGE_NT_HEADERS &getNtHeader();
	BYTE *getDosStub();
	std::vector<PE_SECTION> &getSections();
	BYTE *getOverlay();
};
```

`packer/main.cpp`:

```cpp
#include <cstdio>
#include <cstring>
#include "packer.h"
#include "windows.h"
#include "../compressor/utils.h"

void getOutFile(const char *in, char *out)
{
	size_t slen = strlen(in);
	if (!strcmp(in + slen - 4, ".exe"))
	{
		sprintf(out, "%s.exe", in);
		strcpy(out + slen - 3, "packed.exe");
	}
	else sprintf(out, "%s.packed.exe", in);
}

size_t getFileSize(const char *file)
{
	FILE *fp = fopen(file, "rb");
	fseek(fp, 0, SEEK_END);
	size_t size = ftell(fp);
	fclose(fp);
	return size;
}

int usage(char *s)
{
	printf("Usage: %s a.exe [options]\n", s);
	puts("Options:");
	printf("  -level: compression level. 0 for store, %lu for highest\n", config_count - 1);
	printf("          compression ratio. default is %d.\n", DEFAULT_LEVEL);
	printf("  -lazy : set max lazy match, default is %d.\n", config[DEFAULT_LEVEL].lazy_match);
	printf("  -chain: set max length of find in hash chain, default is %d.\n\n", config[DEFAULT_LEVEL].max_chain);
	puts("Notice: lazy and chain will be ignored if you setted level.");
	return 1;
}
void header()
{
	puts("[ Packer ]");
	puts("A win32 exe packer");
	puts("Homepage: https://github.com/Eronana/packer");
	puts("-------------------------------------------");
}
int main(int argc, char **argv)
{
	header();
	if (argc < 2)return usage(argv[0]);
	char *in = argv[1];
	char out[256];
	getOutFile(in, out);
	try
	{
		printf("IN : %s\n", in);
		printf("OUT: %s\n", out);
		puts("Packing...");
		double t = GetTickCount();
		auto result = pack(in, out, argc, argv);
		printf("Finished in %.2fs.\n", (GetTickCount() - t) / 1000);
		size_t in_size = getFileSize(in);
		size_t out_size = getFileSize(out);
		printf("Unpacked Sections: %zu\n", result.unpacked_sections);
		printf("Compress ratio: %.2f%%\n", out_size*100.0 / in_size);
		printf("Original file size: %zu\n", in_size);
		printf("Packed File Size: %zu\n", out_size);
		printf("Original Entry Point: %p\n", result.oep);
		printf("New Entry Point: %p\n", result.new_ep);
	}
	catch (std::string &s)
	{
		printf("err: %s\n", s.c_str());
		return 1;
	}
	return 0;
}

```

`packer/packer.cpp`:

```cpp
#include "packer.h"
#include "../compressor/utils.h"
#include "../compressor/compressor.h"

// new IAT
struct IAT_TYPE
{
	// only one IID
	IMAGE_IMPORT_DESCRIPTOR IID = {};

	// the table end by a empty IID
	IMAGE_IMPORT_DESCRIPTOR __DUMMY_IID__ = {};

	// dll name
	DEFINE_STRING(DllName, "kernel32.dll");

	// INT(IAT) end by NULL
	DWORD IAT[API_SIZE() + 1] = { API_OFFSET() };

	// two necessary functions
	IAT_FIELD()
}IAT;

BYTE shell_loader[] = {
	0x60,              // PUSHAD
	0x68, 0,0,0,0,     // PUSH &peInfo
	0xE8, 0,0,0,0,     // CALL shell_main
	0x89,0x45, 0xFC,   // MOV [DWORD SS:EBP-4], EAX
	0x61,              // POPAD
	0xFF,0x65, 0xFC    // JMP NEAR[DWORD SS : EBP - 4]
};

PackResult pack(char *in, char *out, int argc = 0, char **argv = NULL)
{
	// get shell code
	BYTE *s_begin = (BYTE*)shell_main;
	BYTE *s_end = (BYTE*)shell_end;
	// skip INT3
	while (*s_begin == 0xCC)s_begin++;
	// skip INT3
	while (*(s_end - 1) == 0xCC)s_end--;
	// calculate shell_size
	size_t shell_size = s_end - s_begin;

	/*
	// write shell_main to file
	FILE *f_shell = fopen("shellcode.bin", "wb");
	fwrite(s_begin, shell_size, 1, f_shell);
	fclose(f_shell);
	*/

	// load file
	PE pe;
	pe.load(in);

	// try to wipe reloc and bound import
	pe.wipeReloc();
	pe.wipeBoundImport();

	auto &nt_header = pe.getNtHeader();
	auto &sections = pe.getSections();
	DWORD NumberOfSections = nt_header.FileHeader.NumberOfSections;
	DWORD ImageBase = nt_header.OptionalHeader.ImageBase;

	DWORD packNumberOfSections = NumberOfSections;
	std::vector<bool> skipSection(NumberOfSections);
	DWORD skipDirectory[] = { IMAGE_DIRECTORY_ENTRY_RESOURCE ,IMAGE_DIRECTORY_ENTRY_TLS };

	// fill skipSection and calculate packNumberOfSections
	for (int i = 0; i < SIZEOF(skipDirectory); i++)
	{
		DWORD rva = nt_header.OptionalHeader.DataDirectory[skipDirectory[i]].VirtualAddress;
		if (rva)
		{
			packNumberOfSections--;
			skipSection[pe.getSectionByRva(rva)] = true;
		}
	}

	// skip non-data section
	for (int i = 0; i < NumberOfSections; i++)
	{
		if (!sections[i].header.SizeOfRawData && !skipSection[i])
		{
			packNumberOfSections--;
			skipSection[i] = true;
		}
	}

	// calculate section_data_size
	size_t section_data_size = 0;
	for (int i = 0; i < sections.size(); i++)
		if (!skipSection[i])
			section_data_size += sections[i].header.SizeOfRawData;

	BYTE *section_data = new BYTE[section_data_size];
	// handle sections
	for (int i = 0; i < sections.size(); i++) if (!skipSection[i])
	{
		// copy section data to newSectionData
		auto size = sections[i].header.SizeOfRawData;
		memcpy(section_data, sections[i].data.get(), size);
		section_data += size;
	}
	// restore original address
	section_data -= section_data_size;
	// get compress config
	Config c_config = get_config(argc, argv);
	// compression buffer
	BYTE *c_buffer = new BYTE[getBufferSize(section_data_size)];
	// compress data
	auto c_result = compress(c_buffer, section_data, section_data_size, c_config.lazy_match, c_config.max_chain);

	/*
	// write data to file
	FILE *f_shell = fopen("unpac.bin", "wb");
	fwrite(section_data, section_data_size, 1, f_shell);
	fclose(f_shell);
	f_shell = fopen("pac.bin", "wb");
	fwrite(c_buffer, c_result.compressed_size, 1, f_shell);
	fclose(f_shell);
	BYTE *x_buffer = new BYTE[section_data_size];
	uncompress(x_buffer, c_buffer);
	f_shell = fopen("depac.bin", "wb");
	fwrite(x_buffer, section_data_size, 1, f_shell);
	fclose(f_shell);
	delete[] x_buffer;
	*/

	DWORD &load_config_va = nt_header.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress;
	DWORD load_config_size = nt_header.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].Size;

	BYTE *load_config_data = NULL;
	if (load_config_size&&load_config_va)
	{
		load_config_data = new BYTE[load_config_size];
		BYTE *original = (BYTE*)pe.getDataByRva(load_config_va);
		memcpy(load_config_data, original, load_config_size);
		ZeroMemory(original, load_config_size);
	}

	// release section_data
	delete[] section_data;

	// fill NULL in tail for aligned
	*(DWORD*)(c_buffer + c_result.compressed_size) = 0;
	DWORD aligned_c_size = (c_result.compressed_size + 3) / 4 * 4;

	// calculate new_section_size
	size_t new_section_size = sizeof(PEInfo)
		+ sizeof(SectionInfo)*packNumberOfSections
		+ aligned_c_size
		+ load_config_size
		+ sizeof(IAT)
		+ shell_size
		+ sizeof(shell_loader);

	// add packer section
	pe.addSection((BYTE*)PACKER_SECTION_NAME,
		new_section_size,
		new_section_size,
		IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE);

	// calculate the address of each part
	PEInfo *peInfo = new(pe.getSections().rbegin()->data.get()) PEInfo;
	SectionInfo *sectionInfo = (SectionInfo*)(peInfo + 1);
	BYTE *newSectionData = (BYTE*)(sectionInfo + packNumberOfSections);

	// copy compressed data
	memcpy(newSectionData, c_buffer, aligned_c_size);
	newSectionData += aligned_c_size;

	// release c_buffer
	delete[] c_buffer;

	// fill peInfo
	peInfo->ImageBase = ImageBase;
	peInfo->AddressOfEntryPoint = nt_header.OptionalHeader.AddressOfEntryPoint;
	peInfo->IIDVirtualAddress = nt_header.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
	peInfo->NumberOfSections = packNumberOfSections;
	peInfo->NodeTotal = c_result.node_total;
	peInfo->UncompressSize = section_data_size;



	// handle sections
	for (int i = 0, j = 0; i < sections.size() - 1; i++)if (!skipSection[i])
	{
		// fill sectionInfo
		sectionInfo[j].VirtualAddress = sections[i].header.VirtualAddress;
		sectionInfo[j].SizeOfRawData = sections[i].header.SizeOfRawData;
		j++;

		// set the section be writable
		sections[i].header.Characteristics |= IMAGE_SCN_MEM_WRITE;

		// remove section raw data
		sections[i].header.Misc.VirtualSize = max(sections[i].header.Misc.VirtualSize, sections[i].header.SizeOfRawData);
		pe.compactRawData(sections[i].header.PointerToRawData, sections[i].header.SizeOfRawData);
		sections[i].header.SizeOfRawData = 0;
		sections[i].header.PointerToRawData = 0;
		sections[i].data.reset();
	}


	DWORD new_section_rva = sections.rbegin()->header.VirtualAddress;

	// handle the load directory,
	// to avoid MSVC compiled program crash when an exception occurs
	if (load_config_data)
	{
		memcpy(newSectionData, load_config_data, load_config_size);
		load_config_va = new_section_rva + newSectionData - (BYTE*)peInfo;
		newSectionData += load_config_size;
		delete[] load_config_data;
	}


	DWORD iat_va = new_section_rva + newSectionData - (BYTE*)peInfo;
	// fill IAT and the necessary function addresses
	IAT.IID.Name = (BYTE*)&IAT.DllName - (BYTE*)&IAT + iat_va;
	IAT.IID.FirstThunk = (BYTE*)&IAT.IAT - (BYTE*)&IAT + iat_va;

	// fix address and fill API address
	for (int i = 0; i < SIZEOF(IAT.IAT) - 1; i++)
	{
		IAT.IAT[i] += iat_va;
		(&peInfo->LoadLibraryA)[i] = ImageBase + IAT.IID.FirstThunk + sizeof(DWORD)*i;
	}

	// copy IAT
	memcpy(newSectionData, &IAT, sizeof(IAT));
	newSectionData += sizeof(IAT);
	// set IAT
	nt_header.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = iat_va;
	nt_header.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size = sizeof(IAT.IID) * 2; //IID and DUMMY_IID



	// copy shell_main
	memcpy(newSectionData, s_begin, shell_size);
	newSectionData += shell_size;

	// fill peInfo address
	DWORD *shell_push_call_offset = (DWORD*)(shell_loader + 2); // 2 is PUSHAD and PUSH
	*shell_push_call_offset = ImageBase + new_section_rva;
	// fill shell_main address
	shell_push_call_offset = (DWORD*)((BYTE*)shell_push_call_offset + 5); // 6 is PUSH xxx
	*shell_push_call_offset = 0xffffffff - shell_size - 10; // 10 is PUSHAD, PUSH xxx and CALL xxx

	// copy shell_loader
	memcpy(newSectionData, shell_loader, sizeof(shell_loader));

	// calculate new ep
	DWORD new_ep = new_section_size - sizeof(shell_loader) + new_section_rva;

	PackResult result = {
		result.unpacked_sections = NumberOfSections - packNumberOfSections,
		nt_header.OptionalHeader.AddressOfEntryPoint + ImageBase,
		new_ep + ImageBase
	};

	// set new ep
	nt_header.OptionalHeader.AddressOfEntryPoint = new_ep;

	// save
	pe.save(out);
	return result;
}

```

`packer/packer.h`:

```h
#pragma once

#include "windows.h"
#include "PE.h"
#include "shell.h"
#include <string>
#include <vector>

#define SIZEOF(A) (sizeof(A)/sizeof(A[0]))
#define PACKER_SECTION_NAME ".packer"
#define DEFINE_API(S) struct{WORD Hint=NULL;DEFINE_STRING(name, #S);}S
#define IAT_FIELD_FUNC(NAME) DEFINE_API(NAME);
#define IAT_FIELD() API_LIST(IAT_FIELD_FUNC)
#define API_OFFSET_FUNC(NAME) offsetof(IAT_TYPE,NAME),
#define API_OFFSET() API_LIST(API_OFFSET_FUNC)
#define API_SIZE_FUNC(NAME) 1+
#define API_SIZE() (API_LIST(API_SIZE_FUNC)0)

struct PackResult
{
	size_t unpacked_sections;
	DWORD oep;
	DWORD new_ep;
};
PackResult pack(char *in, char *out, int argc, char **argv);

```

`packer/packer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{47D655EA-750C-4555-900F-4C815C0EDADB}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>packer</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\compressor\bitstream.h" />
    <ClInclude Include="..\compressor\compressor.h" />
    <ClInclude Include="..\compressor\huffman.h" />
    <ClInclude Include="..\compressor\lz77.h" />
    <ClInclude Include="..\compressor\lzhash.h" />
    <ClInclude Include="..\compressor\uncompressor.h" />
    <ClInclude Include="..\compressor\utils.h" />
    <ClInclude Include="packer.h" />
    <ClInclude Include="PE.h" />
    <ClInclude Include="shell.h" />
    <ClInclude Include="shell_data.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\compressor\bitstream.cpp" />
    <ClCompile Include="..\compressor\compressor.cpp" />
    <ClCompile Include="..\compressor\config.cpp" />
    <ClCompile Include="..\compressor\huffman.cpp" />
    <ClCompile Include="..\compressor\lz77.cpp" />
    <ClCompile Include="..\compressor\lzhash.cpp" />
    <ClCompile Include="..\compressor\uncompressor.cpp" />
    <ClCompile Include="..\compressor\utils.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="packer.cpp" />
    <ClCompile Include="PE.cpp" />
    <ClCompile Include="shell.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`packer/packer.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="packer.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="PE.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="shell.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="..\compressor\bitstream.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="..\compressor\compressor.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="..\compressor\config.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="..\compressor\huffman.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="..\compressor\lz77.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="..\compressor\lzhash.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="..\compressor\utils.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="..\compressor\uncompressor.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="PE.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="shell.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="shell_data.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="packer.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="..\compressor\bitstream.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="..\compressor\compressor.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="..\compressor\huffman.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="..\compressor\lz77.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="..\compressor\lzhash.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="..\compressor\utils.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="..\compressor\uncompressor.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`packer/shell.cpp`:

```cpp
#include "shell.h"
#include "../compressor/uncompressor.h"
#include "../compressor/compressor.h"


/*
 * VS won't optimize naked function,
 * so use normal function to get optimized code
 * and use a shell code loader(in packer.cpp) to call it
 *
 * Notice: don't use any abosolute address resources like "string"
 */
DWORD __stdcall shell_main(DWORD pPeInfo)
{
	// set peInfo address
	PEInfo &peInfo = *(PEInfo*)pPeInfo;
	// set sectionInfo address
	SectionInfo *sections = (SectionInfo*)(&peInfo + 1);
	// set section data address
	BYTE *section_data = (BYTE*)(sections + peInfo.NumberOfSections);
	// set shell data
	decltype(peInfo.data) &data = peInfo.data;

	// define API
	DEFINE_SHELL_API();
	/*
	// show a message box
	HMODULE hModule = LoadLibraryA(data.user32);
	decltype(&MessageBoxA) MyMessageBoxA;
	MyMessageBoxA = (decltype(MyMessageBoxA))GetProcAddress(hModule, data.MessageBoxA);
	MyMessageBoxA(NULL, data.content, data.title, NULL);
	*/
	// uncompress
#define VALLOC(SIZE) VirtualAlloc(NULL, SIZE, MEM_COMMIT, PAGE_READWRITE)
#define VFREE(ADDR) VirtualFree(ADDR, 0, MEM_RELEASE)
#define newHNode() (hNodes[node_cnt].value=-1,hNodes[node_cnt].child[0]=hNodes[node_cnt].child[1]=NULL,hNodes+node_cnt++)
	HNode *hNodes = (HNode*)VALLOC(peInfo.NodeTotal*sizeof(HNode));
	int node_cnt = 0;
	BYTE *src = section_data;

	WORD tree_size = *(WORD*)src;
	src += 2;
	WORD len_size_size = *(WORD*)src;
	src += 2;
	DWORD d_buf_size = *(DWORD*)src;
	src += 4;
	DWORD l_buf_size = *(DWORD*)src;
	src += 4;
	WORD *tree = (WORD*)src;
	src += tree_size*sizeof(tree[0]);
	LenSizeType *len_size = (LenSizeType*)src;
	src += len_size_size*sizeof(len_size[0]);
	BYTE *bit_stream = src;

	HNode *huffman = newHNode();
	int code = 0, last_len = 0;
	for (int i = 0, a = 0; i<len_size_size; i++)
	{
		int len = len_size[i].len;
		int size = len_size[i].size;
		code <<= (len - last_len);
		last_len = len;
		// rebuild buffman tree
		while(size--)
		{
			HNode *node = huffman;
			for (int j = len - 1; ~j; j--)
			{
				int v = !!(code&(1 << j));
				if (!node->child[v])node->child[v] = newHNode();
				node = node->child[v];
			}
			node->value = tree[a++];
			code++;
		}
	}

	WORD *d_buf = (WORD*)VALLOC(sizeof(WORD)*d_buf_size);
	BYTE *l_buf = (BYTE*)VALLOC(l_buf_size);

	int byte_count = 0;
	for (int i = 0; i<d_buf_size; i++)
	{
		HNode *node = huffman;
		for (; node->value == -1; byte_count++)node = node->child[!!(bit_stream[byte_count / 8] & (1 << (7 - byte_count % 8)))];
		d_buf[i] = node->value;
	}
	for (int i = 0; i<l_buf_size; i++)
	{
		HNode *node = huffman;
		for (; node->value == -1; byte_count++)node = node->child[!!(bit_stream[byte_count / 8] & (1 << (7 - byte_count % 8)))];
		l_buf[i] = node->value;
	}
	VFREE(hNodes);
	
	section_data = (BYTE*)VALLOC(peInfo.UncompressSize);
	// unlz77
	int x = 0;
	int next = 0;
	for (int i = 0; i<d_buf_size; i++)
	{
		int dis = d_buf[i] - 256;
		if (dis<0) section_data[next++] = d_buf[i];
		else
		{
			BYTE *buf = section_data + next - dis;
			for (int j = 0; j<l_buf[x] + MIN_REPEAT_LENGTH; j++)section_data[next++] = buf[j];
			x++;
		}
	}

	VFREE(l_buf);
	VFREE(d_buf);
	
	// restore sections
	for (int i = 0; i < peInfo.NumberOfSections; i++)
	{
		BYTE *data = (BYTE*)(peInfo.ImageBase + sections[i].VirtualAddress);
		for (int j = 0; j < sections[i].SizeOfRawData; j++)data[j] = *section_data++;
	}

	VFREE(section_data);

	// resotre original IAT
	for(IMAGE_IMPORT_DESCRIPTOR *IID = (IMAGE_IMPORT_DESCRIPTOR*)(peInfo.IIDVirtualAddress + peInfo.ImageBase);;IID++)
	{
		DWORD RealFirstThunk = IID->OriginalFirstThunk;
		if(!RealFirstThunk)RealFirstThunk= IID->FirstThunk;
		if (!RealFirstThunk)break;

		char *DllName = (char*)(peInfo.ImageBase + IID->Name);
		HMODULE hModule = LoadLibraryA(DllName);
		if (!hModule)continue;

		DWORD *OriginalFirstThunk = (DWORD*)(peInfo.ImageBase + RealFirstThunk);
		DWORD *FirstThunk = (DWORD*)(peInfo.ImageBase + IID->FirstThunk);
		for (int i = 0; OriginalFirstThunk[i]; i++)
		{
			DWORD ProcName;
			if (OriginalFirstThunk[i] & IMAGE_ORDINAL_FLAG)ProcName = IMAGE_ORDINAL(OriginalFirstThunk[i]);
			else ProcName = peInfo.ImageBase + OriginalFirstThunk[i] + 2;
			FirstThunk[i] = (DWORD)GetProcAddress(hModule, (LPCSTR)ProcName);
		}
	}
	
	// return oep
	return peInfo.ImageBase + peInfo.AddressOfEntryPoint;
}

// a empty function to calculate the size of shell_main
// this function will be located behind shell_main in VS Community 2015
__declspec(naked) void shell_end()
{
	__asm int 3
}

```

`packer/shell.h`:

```h
#pragma once

#include "windows.h"
#define DEFINE_STRING(NAME,STR) char NAME[sizeof(STR)]=STR
#define PEINFO_FIELD(NAME) DWORD NAME;
#define DEFINE_SHELL_API_FUNC(NAME) decltype(&NAME) NAME = *(decltype(NAME)*)peInfo.NAME;
#define DEFINE_SHELL_API() API_LIST(DEFINE_SHELL_API_FUNC)

#define API_LIST_BEGIN
#define API_LIST_END 
#define API_LIST(T) \
API_LIST_BEGIN \
T(LoadLibraryA)\
T(GetProcAddress)\
T(VirtualAlloc)\
T(VirtualFree)\
API_LIST_END

struct SectionInfo
{
	DWORD VirtualAddress;
	DWORD SizeOfRawData;
};

struct PEInfo
{
	DWORD ImageBase;
	DWORD AddressOfEntryPoint;
	DWORD NumberOfSections;
	DWORD IIDVirtualAddress;
	DWORD NodeTotal;
	DWORD UncompressSize;

	// IMPORT API
	API_LIST(PEINFO_FIELD)
	struct
	{
#include "shell_data.h"
	}data;
};

DWORD __stdcall shell_main(DWORD pPeInfo);
void shell_end();


```

`packer/shell_data.h`:

```h
#pragma once
/*
DEFINE_STRING(user32, "user32.dll");
DEFINE_STRING(MessageBoxA, "MessageBoxA");
DEFINE_STRING(title, "Hello");
DEFINE_STRING(content, "This program has been packed!");
*/
```