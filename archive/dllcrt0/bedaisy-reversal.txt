Project Path: arc_dllcrt0_bedaisy-reversal_d8rhfiv1

Source Tree:

```txt
arc_dllcrt0_bedaisy-reversal_d8rhfiv1
├── check_csrss_integrity.cpp
├── check_flt_filters.cpp
├── check_graphic_components.cpp
├── check_hal_tables.cpp
├── check_img_notify_still_loaded.cpp
├── check_kernel_integrity.cpp
├── check_lookup_thread_by_id.cpp
├── check_objects.cpp
├── check_physical_memory.cpp
├── check_self_dispatch.cpp
├── create_thread_notify.cpp
├── get_callbacklisthead.cpp
├── get_pe_section.cpp
├── handle_request.cpp
├── load_image_notify.cpp
├── report.cpp
├── report_custom_list.cpp
├── report_hook.cpp
├── report_internal.cpp
├── report_manual_mapped_driver.cpp
├── resolve.cpp
├── stackwalk.cpp
├── system_thread.cpp
└── validate_function_integrity.cpp

```

`check_csrss_integrity.cpp`:

```cpp
__int64 __fastcall be::check_csrss_integrity(__int64 a1, unsigned __int64 a2, unsigned int a3, unsigned __int64 a4, unsigned int a5)
{
  __int64 v6; // r12
  __int64 result; // rax
  __int64 v10; // rdi
  __int64 v11; // rdx
  unsigned int v12; // er8
  __int64 v13; // rax
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // rax
  __int64 v16; // rbx
  int v17; // edx
  unsigned __int64 v18; // rsi
  __int128 *v19; // rcx
  char v20; // [rsp+20h] [rbp-91h] BYREF
  int v21; // [rsp+21h] [rbp-90h]
  __int64 v22; // [rsp+25h] [rbp-8Ch]
  __int128 v23; // [rsp+2Dh] [rbp-84h]
  __int128 v24; // [rsp+3Dh] [rbp-74h]
  __int128 v25; // [rsp+4Dh] [rbp-64h]
  __int128 v26; // [rsp+5Dh] [rbp-54h]
  char v27[48]; // [rsp+70h] [rbp-41h] BYREF
  char v28[16]; // [rsp+A0h] [rbp-11h] BYREF
  __m128i v29; // [rsp+B0h] [rbp-1h] BYREF
  int v30; // [rsp+C0h] [rbp+Fh]
  int v31; // [rsp+C4h] [rbp+13h]
  int v32; // [rsp+C8h] [rbp+17h]

  v6 = a3;
  strcpy(v28, "csrss.exe");
  result = sub_1403440C2(v28, 0i64);
  v10 = result;
  if ( result )
  {
    KeStackAttachProcess(result, v27);
    v11 = (__int64)&v29;
    v29 = _mm_load_si128(&unk_1400140E0);
    v30 = 0x8DAB8D90;
    v12 = 0;
    v32 = 0xFF928D90;
    v31 = 0x998C919E;
    do
    {
      *(_BYTE *)v11 = ~*(_BYTE *)v11;
      ++v12;
      ++v11;
    }
    while ( v12 < 28 );
    v13 = resolve(a1, (__int64)&v29);
    v14 = v13;
    if ( v13 )
    {
      v15 = v13 + 16;
      while ( v14 < v15 )
      {
        if ( *(_WORD *)v14 == 0x8B48
          && *(_BYTE *)(v14 + 2) == 5
          && *(_DWORD *)(v14 + 7) == 0x74C08548
          && *(_WORD *)(v14 + 12) == 0x15FF )
        {
          v16 = 0i64;
          v17 = 0;
          v18 = *(unsigned int *)(v14 + 3) + v14;
          while ( 1 )
          {
            v19 = *(__int128 **)(v18 + 8 * v16 + 7);
            if ( v19 )
            {
              if ( a2 <= (unsigned __int64)v19 && (unsigned __int64)v19 < v6 + a2
                || a4 <= (unsigned __int64)v19 && (unsigned __int64)v19 < a5 + a4 )
              {
                v17 = 0;
              }
              else
              {
                v22 = *(_QWORD *)(v18 + 8 * v16 + 7);
                v20 = 0x21;
                v21 = v16;
                v23 = *v19;
                v24 = v19[1];
                v25 = v19[2];
                v26 = v19[3];
                be::report((__int64)&v20, 77i64);
                v17 = 0;
              }
            }
            else if ( ++v17 == 3 )
            {
              goto LABEL_22;
            }
            v16 = (unsigned int)(v16 + 1);
          }
        }
        ++v14;
      }
    }
LABEL_22:
    KeUnstackDetachProcess(v27);
    PsReleaseProcessExitSynchronization(v10);
    result = ObfDereferenceObject(v10);
  }
  return result;
}
```

`check_flt_filters.cpp`:

```cpp
unsigned __int64 __fastcall be::check_flt_filters(__int64 a1)
{
  unsigned __int64 result; // rax
  __int64 v3; // r8
  __int64 v4; // rcx
  unsigned int v5; // edx
  __int64 v6; // rbx
  __int64 v7; // rbx
  int v8; // esi
  char v9; // r15
  __int64 v10; // rdi
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  __int64 v13; // rdi
  __int64 v14; // rcx
  char v15[8]; // [rsp+30h] [rbp-D0h] BYREF
  int v16; // [rsp+38h] [rbp-C8h] BYREF
  int *v17; // [rsp+40h] [rbp-C0h]
  int v18[18]; // [rsp+48h] [rbp-B8h] BYREF
  char v19[128]; // [rsp+90h] [rbp-70h] BYREF

  result = IoGetTopLevelIrp();
  if ( !result )
  {
    result = ObQueryNameString(a1, v19, 128i64, v15);
    if ( (result & 0x80000000) == 0i64 )
    {
      v18[0] = 0xFFB9FFA3;
      v4 = (__int64)v18;
      v18[1] = 0xFF93FF96;
      v5 = 0;
      v18[2] = 0xFFACFF9A;
      v18[3] = 0xFF8CFF86;
      v18[4] = 0xFF9AFF8B;
      v18[5] = 0xFFA3FF92;
      v18[6] = 0xFF96FFB9;
      v18[7] = 0xFF8BFF93;
      v18[8] = 0xFF8DFF9A;
      v18[9] = 0xFFA3FF8C;
      v18[10] = 0xFF93FFB9;
      v18[11] = 0xFFB2FF8B;
      v18[12] = 0xFF8DFF98;
      v18[13] = 0xFF8CFFB2;
      v18[14] = 0xFFFFFF98;
      do
      {
        ++v5;
        *(_WORD *)v4 = ~*(_WORD *)v4;
        v4 += 2i64;
      }
      while ( v5 < 30 );
      v16 = 0x3C003A;
      LOBYTE(v3) = 1;
      v17 = v18;
      result = RtlCompareUnicodeString(v19, &v16, v3);// \FileSystem\Filters\FltMgrMsg
      if ( !(_DWORD)result )
      {
        if ( *(_QWORD *)(a1 + 32) )
        {
          _mm_lfence();
          result = *(_QWORD *)(a1 + 32);
          v6 = *(_QWORD *)(result + 8);
          if ( v6 )
          {
            result = MmIsAddressValid(*(_QWORD *)(result + 8));
            if ( (_BYTE)result )
            {
              v7 = *(_QWORD *)(v6 + 16);
              if ( v7 )
              {
                result = MmIsAddressValid(v7);
                if ( (_BYTE)result )
                {
                  v8 = 0;
                  while ( 1 )
                  {
                    if ( !*(_QWORD *)(v7 + 8i64 * v8 + 16) )
                      goto LABEL_25;
                    v9 = 0;
                    KeWaitForSingleObject(0x1400161D8i64, 0i64, 0i64, 0i64, 0i64);
                    v10 = qword_140016828;
                    if ( qword_140016828 )
                    {
                      v11 = *(_QWORD *)(v7 + 8i64 * v8 + 16);
                      while ( 1 )
                      {
                        v12 = *(_QWORD *)(v10 + 1288);
                        if ( v11 >= v12 && v11 < *(unsigned int *)(v10 + 1296) + v12 )
                          break;
                        v10 = *(_QWORD *)(v10 + 1320);
                        if ( !v10 )
                          goto LABEL_18;
                      }
                      v9 = 1;
                    }
LABEL_18:
                    result = KeReleaseMutex(0x1400161D8i64, 0i64);
                    if ( v10 || (result = ExAllocatePool(512i64, 74i64), (v13 = result) == 0) )
                    {
                      if ( !v9 )
                        goto LABEL_25;
LABEL_23:
                      result = be::report_hook(*(_QWORD *)(v7 + 8i64 * v8 + 16), 32, v8);
                      if ( (unsigned int)++v8 >= 3 )
                        return result;
                    }
                    else
                    {
                      *(_BYTE *)result = 31;
                      v14 = *(_QWORD *)(v7 + 8i64 * v8 + 16);
                      *(_BYTE *)(result + 1) = v8;
                      *(_QWORD *)(result + 2) = v14;
                      if ( (int)sub_14034D2BA(*(_QWORD *)(v7 + 8i64 * v8 + 16), result + 10, 64i64) < 0 )
                        memset((void *)(v13 + 10), 0, 0x40ui64);
                      else
                        v9 = 1;
                      be::report(v13, 0x4Ai64);
                      result = ExFreePoolWithTag(v13, 0i64);
                      if ( v9 )
                        goto LABEL_23;
LABEL_25:
                      if ( (unsigned int)++v8 >= 3 )
                        return result;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
```

`check_graphic_components.cpp`:

```cpp
_DWORD *__fastcall be::check_graphic_components(unsigned __int64 a1, unsigned int a2)
{
  __m128i *v2; // r8
  __int64 v3; // r15
  unsigned int i; // er9
  _DWORD *result; // rax
  unsigned int v7; // edi
  unsigned int v8; // esi
  __int128 **v9; // rbx
  __int128 *v10; // rcx
  __int128 *v11; // rax
  __int128 *v12; // rcx
  char v13; // [rsp+20h] [rbp-29h] BYREF
  unsigned int v14; // [rsp+21h] [rbp-28h]
  __int128 *v15; // [rsp+25h] [rbp-24h]
  __int128 Dst[4]; // [rsp+2Dh] [rbp-1Ch] BYREF
  __m128i _DxgCoreInterface; // [rsp+70h] [rbp+27h] BYREF
  char v18; // [rsp+80h] [rbp+37h]

  v2 = &_DxgCoreInterface;
  _DxgCoreInterface = _mm_load_si128(&DxgCoreInterface);
  v3 = a2;
  v18 = -1;
  for ( i = 0; i < 17; ++i )
  {
    v2->m128i_i8[0] = ~v2->m128i_i8[0];
    v2 = (__m128i *)((char *)v2 + 1);
  }
  result = (_DWORD *)resolve(a1, (__int64)&_DxgCoreInterface);
  if ( result )
  {
    v7 = 1;
    v8 = *result >> 3;
    if ( v8 > 1 )
    {
      v9 = (__int128 **)(result + 2);
      while ( 1 )
      {
        v10 = *v9;
        if ( a1 <= (unsigned __int64)*v9 && (result = (_DWORD *)(v3 + a1), (unsigned __int64)v10 < v3 + a1) )
        {
          v12 = *v9;
          if ( !*v9 )
            goto LABEL_13;
LABEL_11:
          result = (_DWORD *)be::report_hook((unsigned __int64)v12, 13, v7++);
          ++v9;
          if ( v7 >= v8 )
            return result;
        }
        else
        {
          v13 = 12;
          v15 = v10;
          v14 = v7;
          if ( (unsigned __int8)MmIsAddressValid(v10) )
          {
            v11 = *v9;
            Dst[0] = **v9;
            Dst[1] = v11[1];
            Dst[2] = v11[2];
            Dst[3] = v11[3];
          }
          else
          {
            memset(Dst, 0, sizeof(Dst));
          }
          result = (_DWORD *)be::report((__int64)&v13, 77i64);
          v12 = *v9;
          if ( *v9 )
            goto LABEL_11;
LABEL_13:
          ++v7;
          ++v9;
          if ( v7 >= v8 )
            return result;
        }
      }
    }
  }
  return result;
}
```

`check_hal_tables.cpp`:

```cpp
_DWORD *__fastcall be::check_hal_tables(unsigned __int64 a1, unsigned int a2, unsigned __int64 a3, unsigned int a4, unsigned __int64 a5, unsigned int a6, unsigned __int64 a7, unsigned int a8)
{
  __int64 v9; // r13
  __m128i *v11; // r9
  unsigned int v12; // er10
  __int64 v13; // rax
  unsigned __int64 *v14; // rdi
  unsigned int v15; // ebx
  unsigned int v16; // esi
  bool v17; // r15
  unsigned __int64 v18; // rcx
  __int64 v19; // rcx
  unsigned int v20; // edx
  _DWORD *result; // rax
  unsigned int v22; // ecx
  unsigned int v23; // esi
  unsigned int v24; // edi
  unsigned __int64 *v25; // rbx
  char v26; // al
  unsigned __int64 v27; // rcx
  bool v28; // r15
  char v30; // [rsp+30h] [rbp-79h] BYREF
  unsigned int v31; // [rsp+31h] [rbp-78h]
  unsigned __int64 v32; // [rsp+35h] [rbp-74h]
  __m128 Dst; // [rsp+3Dh] [rbp-6Ch] BYREF
  __int128 v34; // [rsp+4Dh] [rbp-5Ch]
  __int128 v35; // [rsp+5Dh] [rbp-4Ch]
  __int128 v36; // [rsp+6Dh] [rbp-3Ch]
  __m128i v37; // [rsp+80h] [rbp-29h] BYREF
  int v38; // [rsp+90h] [rbp-19h]
  int v39; // [rsp+94h] [rbp-15h]
  __m128i _HalDispatchTable; // [rsp+98h] [rbp-11h] BYREF
  char v41; // [rsp+A8h] [rbp-1h]

  v9 = a4;
  _HalDispatchTable = _mm_load_si128(&HalDispatchTable);
  v11 = &_HalDispatchTable;
  v12 = 0;
  v41 = -1;
  do
  {
    v11->m128i_i8[0] = ~v11->m128i_i8[0];
    ++v12;
    v11 = (__m128i *)((char *)v11 + 1);
  }
  while ( v12 < 17 );
  v13 = resolve(a1, (__int64)&_HalDispatchTable);
  if ( v13 )
  {
    v14 = (unsigned __int64 *)(v13 + 8);
    v15 = 1;
    v16 = (*(_DWORD *)v13 > 3u) + 22;
    while ( 1 )
    {
      if ( !*v14 )
        goto LABEL_57;
      v17 = (unsigned __int8)MmIsAddressValid(*v14) != 0;
      v18 = *v14;
      if ( a1 <= *v14 && v18 < a2 + a1 || a3 <= v18 && v18 < v9 + a3 )
      {
        if ( !v17 )
          goto LABEL_57;
LABEL_13:
        be::report_hook(*v14++, 28, v15++);
        if ( v15 >= v16 )
          break;
      }
      else
      {
        v30 = 27;
        v32 = v18;
        v31 = v15;
        if ( v17 )
        {
          Dst = *(__m128 *)v18;
          v34 = *(_OWORD *)(v18 + 16);
          v35 = *(_OWORD *)(v18 + 32);
          v36 = *(_OWORD *)(v18 + 48);
        }
        else
        {
          ((void (__fastcall *)(__m128 *, unsigned __int8, unsigned __int64))memset)(&Dst, 0, 0x40ui64);
        }
        be::report((__int64)&v30, 77i64);
        if ( v17 )
          goto LABEL_13;
LABEL_57:
        ++v15;
        ++v14;
        if ( v15 >= v16 )
          break;
      }
    }
  }
  v19 = (__int64)&v37;
  v37 = _mm_load_si128(&unk_1400140D0);
  v20 = 0;
  v38 = 0x9EAB979C;
  v39 = 0xFF9A939D;
  do
  {
    *(_BYTE *)v19 = ~*(_BYTE *)v19;
    ++v20;
    ++v19;
  }
  while ( v20 < 24 );
  result = (_DWORD *)resolve(a1, (__int64)&v37);
  if ( result )
  {
    v22 = *result;
    v23 = 148;
    if ( *result <= 0x2Eu )
      v23 = 139;
    if ( v22 <= 0x2B )
      v23 = 136;
    if ( v22 <= 0x28 )
      v23 = 126;
    if ( v22 <= 0x24 )
      v23 = 122;
    if ( v22 <= 0x20 )
      v23 = 119;
    if ( v22 <= 0x17 )
      v23 = 106;
    if ( v22 <= 0x15 )
      v23 = 91;
    if ( v22 <= 0xD )
      v23 = 46;
    v24 = 1;
    if ( v22 == 7 )
      v23 = 36;
    if ( v22 <= 6 )
      v23 = 34;
    v25 = (unsigned __int64 *)(result + 2);
    while ( 1 )
    {
      if ( !*v25 )
        goto LABEL_52;
      v26 = MmIsAddressValid(*v25);
      v27 = *v25;
      v28 = v26 != 0;
      if ( a1 <= *v25 && (result = (_DWORD *)(a2 + a1), v27 < (unsigned __int64)result)
        || a3 <= v27 && (result = (_DWORD *)(v9 + a3), v27 < v9 + a3)
        || a5 <= v27 && (result = (_DWORD *)(a5 + a6), v27 < (unsigned __int64)result)
        || a7 <= v27 && (result = (_DWORD *)(a7 + a8), v27 < (unsigned __int64)result) )
      {
        if ( !v28 )
          goto LABEL_52;
LABEL_50:
        result = (_DWORD *)be::report_hook(*v25++, 30, v24++);
        if ( v24 >= v23 )
          return result;
      }
      else
      {
        v30 = 29;
        v31 = v24;
        v32 = v27;
        if ( v28 )
        {
          Dst = *(__m128 *)v27;
          v34 = *(_OWORD *)(v27 + 16);
          v35 = *(_OWORD *)(v27 + 32);
          v36 = *(_OWORD *)(v27 + 48);
        }
        else
        {
          ((void (__fastcall *)(__m128 *, unsigned __int8, unsigned __int64))memset)(&Dst, 0, 0x40ui64);
        }
        result = (_DWORD *)be::report((__int64)&v30, 77i64);
        if ( v28 )
          goto LABEL_50;
LABEL_52:
        ++v24;
        ++v25;
        if ( v24 >= v23 )
          return result;
      }
    }
  }
  return result;
}
```

`check_img_notify_still_loaded.cpp`:

```cpp
__int64 be::check_img_notify_still_loaded()
{
  int v1; // [rsp+28h] [rbp-20h]
  char v2; // [rsp+50h] [rbp+8h] BYREF
  bool v3; // [rsp+51h] [rbp+9h]
  __int64 v4; // [rsp+58h] [rbp+10h] BYREF

  KeWaitForSingleObject(0x1400161D8i64, 0i64, 0i64, 0i64, 0i64);
  if ( qword_140016210 )
  {
    byte_140016171 = 0;
    LOBYTE(v1) = 0;
    if ( (int)ObOpenObjectByPointer(qword_140016210, 512i64, 0i64, 0i64, *PsProcessType, v1, &v4) >= 0 )
    {
      if ( byte_140016171 )
      {
        if ( !byte_140016172 )
          goto LABEL_5;
      }
      else if ( byte_140016172 != byte_140016171 )
      {
LABEL_5:
        ZwClose(v4);
        return KeReleaseMutex(0x1400161D8i64, 0i64);
      }
      v2 = 2;
      byte_140016172 = byte_140016171 == 0;
      v3 = byte_140016171 == 0;
      be::report((__int64)&v2, 2i64);
      ZwClose(v4);
      return KeReleaseMutex(0x1400161D8i64, 0i64);
    }
  }
  return KeReleaseMutex(0x1400161D8i64, 0i64);
}
```

`check_kernel_integrity.cpp`:

```cpp
__int64 be::check_kernel_integrity()
{
  __int64 result; // rax
  char *kernel; // rbx
  char *v2; // rax
  char *v3; // rax
  _QWORD *v4; // r15
  __int64 v5; // r12
  unsigned __int64 *v6; // rbx
  unsigned __int64 v7; // rsi
  unsigned __int64 i; // rbx
  unsigned __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // rax
  __int64 v12; // rdi
  __int64 v13; // r10
  __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // r10
  _DWORD *OptionalHeader; // rdx
  int v18; // er9
  unsigned int v19; // er8
  unsigned int v20; // ecx
  _BYTE *v21; // rdi
  unsigned __int64 *v22; // r14
  unsigned __int64 v23; // rdx
  __int64 j; // rbx
  __int64 v25; // [rsp+20h] [rbp-89h]
  __int64 v26; // [rsp+28h] [rbp-81h]
  unsigned int AddressOfEntryPoint; // [rsp+50h] [rbp-59h] BYREF
  __int64 v28; // [rsp+58h] [rbp-51h] BYREF
  char v29[16]; // [rsp+60h] [rbp-49h] BYREF
  char v30[16]; // [rsp+70h] [rbp-39h] BYREF
  char v31[16]; // [rsp+80h] [rbp-29h] BYREF
  int v32; // [rsp+90h] [rbp-19h] BYREF
  __int64 v33; // [rsp+98h] [rbp-11h]
  char *v34; // [rsp+A0h] [rbp-9h]
  int v35; // [rsp+A8h] [rbp-1h]
  __int128 v36; // [rsp+B0h] [rbp+7h]
  int v37; // [rsp+C0h] [rbp+17h] BYREF
  char v38; // [rsp+C4h] [rbp+1Bh]
  char v39[8]; // [rsp+C8h] [rbp+1Fh] BYREF
  char v40[8]; // [rsp+D0h] [rbp+27h] BYREF
  char v41[8]; // [rsp+D8h] [rbp+2Fh] BYREF

  result = 11362i64;
  if ( (unsigned __int16)(*(_WORD *)NtBuildNumber_0 - 7600) <= 0x2C62u )
  {
    if ( (int)sub_140344C24(1) >= 0
      || (result = sub_140344C24(0), (int)result >= 0) && (result = sub_140344C24(1), (int)result >= 0) )
    {
      kernel = 0i64;
      KeWaitForSingleObject(0x1400161D8i64, 0i64, 0i64, 0i64, 0i64);
      if ( qword_140016830 )
        kernel = *(char **)(qword_140016830 + 0x508);
      result = KeReleaseMutex(0x1400161D8i64, 0i64);
      if ( kernel )
      {
        strcpy(v39, ".data");
        v2 = get_pe_section(kernel, (__int64)v39, &AddressOfEntryPoint);
        v37 = 0x3804082C;
        v38 = 0xC;
        if ( v2 )
        {
          result = (__int64)sub_14034B2FF((__int64)v2, AddressOfEntryPoint, (__int64)&v37, 5ui64);
          if ( result )
            goto LABEL_57;
        }
        if ( (strcpy(v41, ".rdata"), (v3 = get_pe_section(kernel, (__int64)v41, &AddressOfEntryPoint)) != 0i64)
          && (result = (__int64)sub_14034B2FF((__int64)v3, AddressOfEntryPoint, (__int64)&v37, 5ui64)) != 0
          || (strcpy(v40, ".text"), (result = (__int64)get_pe_section(kernel, (__int64)v40, &AddressOfEntryPoint)) != 0)
          && (result = (__int64)sub_14034B2FF(result, AddressOfEntryPoint, (__int64)&v37, 5ui64)) != 0 )
        {
LABEL_57:
          v4 = *(_QWORD **)(result + 14);
          result = MmIsAddressValid(v4);
          if ( (_BYTE)result )
          {
            v5 = 3i64;
            do
            {
              if ( *v4 >= 0xFFFF000000000000ui64 )
              {
                v6 = (unsigned __int64 *)(*v4
                                        + (-(__int64)(*(_WORD *)NtBuildNumber_0 > 0x23F0u) & 0xFFFFFFFFFFFFFFF0ui64)
                                        + 0x28);
                result = MmIsAddressValid(v6);
                if ( (_BYTE)result )
                {
                  v7 = *v6;
                  KeWaitForSingleObject(0x1400161D8i64, 0i64, 0i64, 0i64, 0i64);
                  for ( i = qword_140016828; ; i = *(_QWORD *)(i + 1320) )
                  {
                    if ( !i )
                      goto LABEL_54;
                    v9 = *(_QWORD *)(i + 1288);
                    if ( v7 >= v9 && v7 < *(unsigned int *)(i + 1296) + v9 )
                      break;
                  }
                  RtlInitAnsiString(v30, i + 2);
                  LOBYTE(v10) = 1;
                  if ( (int)RtlAnsiStringToUnicodeString(v29, v30, v10) < 0 )
                  {
LABEL_54:
                    result = KeReleaseMutex(0x1400161D8i64, 0i64);
                    goto LABEL_35;
                  }
                  v33 = 0i64;
                  LODWORD(v26) = 32;
                  LODWORD(v25) = 7;
                  v35 = 576;
                  v32 = 48;
                  v34 = v29;
                  v36 = 0i64;
                  if ( (int)ZwOpenFile(&v28, 0x80000000i64, &v32, v31, v25, v26) >= 0 )
                  {
                    v11 = ExAllocatePool(1i64, 0x1000i64);
                    v12 = v11;
                    if ( v11 )
                    {
                      if ( (int)ZwReadFile(v28, 0i64, 0i64, 0i64, v31, v11, 4096, 0i64, 0i64) >= 0
                        && *(_DWORD *)(v12 + 0x3C) <= 0xFF8u )
                      {
                        _mm_lfence();
                        v13 = *(unsigned int *)(v12 + 0x3C);
                        v14 = *(unsigned __int16 *)(v13 + v12 + 20);
                        v15 = v13 + 24;
                        v16 = *(unsigned __int16 *)(v13 + v12 + 6);
                        OptionalHeader = (_DWORD *)(v14 + v12 + v15);
                        if ( (unsigned __int64)OptionalHeader + 40 * v16 - v12 <= 0x1000 )
                        {
                          v18 = 0;
                          v19 = v7 - *(_DWORD *)(i + 0x508);
                          if ( (_DWORD)v16 )
                          {
                            while ( 1 )
                            {
                              v20 = OptionalHeader[3];
                              if ( v19 >= v20 && v19 < OptionalHeader[2] + v20 )
                                break;
                              OptionalHeader += 10;
                              if ( ++v18 >= (unsigned int)v16 )
                                goto LABEL_33;
                            }
                            if ( (OptionalHeader[9] & 0x22000000) != 0x20000000 )
                              i = 1i64;
                          }
                        }
                      }
LABEL_33:
                      ExFreePoolWithTag(v12, 0i64);
                      ZwClose(v28);
                    }
                    else
                    {
                      ZwClose(v28);
                    }
                  }

                  RtlFreeUnicodeString(v29);
                  result = KeReleaseMutex(0x1400161D8i64, 0i64);
LABEL_35:
                  if ( i <= 1 && v7 >= 0xFFFF000000000000ui64 )
                  {
                    result = ExAllocatePool(512i64, 73i64);
                    v21 = (_BYTE *)result;
                    if ( result )
                    {
                      v22 = (unsigned __int64 *)(result + 1);
                      v23 = v7;
                      if ( i )
                        v23 = v7;
                      *v22 = v23;
                      if ( (int)sub_14034D2BA(v7, result + 9, 64i64) < 0 )
                        memset(v21 + 9, 0, 0x40ui64);
                      for ( j = qword_140016868; ; j = *(_QWORD *)(j + 16) )
                      {
                        if ( !j )
                        {
                          *v21 = 23;
                          be::report((__int64)v21, 0x49i64);
                          be::report_custom_list((unsigned __int64)v22, 72i64, &qword_140016868, 0x140016870i64);
                          result = ExFreePoolWithTag(v21, 0i64);
                          goto LABEL_45;
                        }
                        if ( !(unsigned int)sub_140013A60(*(unsigned __int64 **)j, (__int64)v22, 0x48ui64) )
                          break;
                      }
                      result = ExFreePoolWithTag(v21, 0i64);
                    }
                  }
                }
              }
LABEL_45:
              ++v4;
              --v5;
            }
            while ( v5 );
          }
        }
      }
    }
  }
  return result;
}
```

`check_lookup_thread_by_id.cpp`:

```cpp
void be::check_lookup_thread_by_id()
{
  __int64 v0; // rdx
  __int64 v1; // rax
  __int64 *v2; // rax
  __int64 i; // rax
  char v4; // [rsp+30h] [rbp-68h] BYREF
  __int64 (__fastcall *v5)(_QWORD, _QWORD); // [rsp+31h] [rbp-67h]
  unsigned int v6; // [rsp+39h] [rbp-5Fh]
  __int64 v7; // [rsp+3Dh] [rbp-5Bh]
  char v8; // [rsp+45h] [rbp-53h]
  __int64 v9; // [rsp+46h] [rbp-52h] BYREF
  char v10; // [rsp+4Eh] [rbp-4Ah] BYREF

  if ( !byte_140016175 && *(_WORD *)PsLookupThreadByThreadId == 0x25FF )
  {
    KeWaitForSingleObject(0x1400161D8i64, 6i64, 0i64, 0i64, 0i64);
    v4 = 4;
    v5 = PsLookupThreadByThreadId;
    v6 = *(_DWORD *)((char *)PsLookupThreadByThreadId + 2);
    v0 = *(_QWORD *)((char *)PsLookupThreadByThreadId + v6 + 6);
    v7 = v0;
    if ( *(_WORD *)v0 == 0x25FF )
    {
      v1 = *(unsigned int *)(v0 + 2);
      v8 = 1;
      v0 = *(_QWORD *)(v1 + v0 + 6);
      v2 = (__int64 *)&v10;
      v9 = v0;
    }
    else
    {
      v8 = 0;
      v2 = &v9;
    }
    *(_OWORD *)v2 = *(_OWORD *)v0;
    for ( i = 1i64; i < 0x2E; ++i )
      *(&v4 + i) ^= 0x7Fu;
    be::report((__int64)&v4, 0x41i64);
    KeReleaseMutex(0x1400161D8i64, 0i64);
    byte_140016175 = 1;
  }
}
```

`check_objects.cpp`:

```cpp
__int64 be::check_objects()
{
  __int64 v0; // rcx
  __int64 *v1; // r8
  __int64 result; // rax
  __int64 v3; // rdi
  __int64 v4; // rbx
  int v5; // eax
  unsigned __int8 v6; // dl
  __int64 v7; // rcx
  int v8; // eax
  unsigned int v9; // ecx
  __int64 v10; // rbx
  __int64 v11; // rbx
  __int64 v12; // [rsp+20h] [rbp-E0h] BYREF
  __int64 v13; // [rsp+28h] [rbp-D8h] BYREF
  char *v14; // [rsp+30h] [rbp-D0h]
  char v15[16]; // [rsp+38h] [rbp-C8h] BYREF
  char v16[16]; // [rsp+48h] [rbp-B8h] BYREF
  int v17[4]; // [rsp+58h] [rbp-A8h] BYREF
  int v18[4]; // [rsp+68h] [rbp-98h] BYREF
  int v19[6]; // [rsp+78h] [rbp-88h] BYREF
  char v20; // [rsp+90h] [rbp-70h] BYREF
  unsigned __int8 v21; // [rsp+91h] [rbp-6Fh]
  char v22[142]; // [rsp+92h] [rbp-6Eh] BYREF

  v17[0] = 0x44005C;
  v12 = 0i64;
  v17[1] = 6881394;
  v17[2] = 0x650076;
  v17[3] = 0x72;
  RtlInitUnicodeString(v15, (char *)v17 + 2);
  v0 = (__int64)sub_1403443CA((__int64)v17, (__int64)v15, (__m128i **)&v12);// \Driver
  v19[0] = 0x46005C;
  v19[1] = 0x6C0069;
  v1 = &v12;
  v19[2] = 0x530065;
  v19[3] = 0x730079;
  if ( v0 )
    v1 = (__int64 *)(v0 + 520);
  v19[4] = 0x650074;
  v19[5] = 0x6D;
  result = (__int64)sub_1403443CA((__int64)v19, (__int64)v15, (__m128i **)v1);// \FileSystem
  if ( v12 )
  {
    v18[0] = 0x44005C;
    v18[1] = 0x760065;
    v18[2] = 0x630069;
    v18[3] = 0x65;
    RtlInitUnicodeString(v15, (char *)v18 + 2);
    if ( (__int64)sub_1403443CA((__int64)v18, (__int64)v15, (__m128i **)&v13) )// \Device
    {
      v3 = v13;
      if ( v13 )
      {
        do
        {
          v4 = *(_QWORD *)(*(_QWORD *)(v3 + 0x200) + 8i64);
          if ( !(unsigned __int8)MmIsAddressValid(v4) || sub_14034E128(v12, v4) )
          {
            v10 = *(_QWORD *)(v3 + 520);
            ExFreePoolWithTag(v3, 0i64);
          }
          else
          {
            v20 = 15;
            RtlInitUnicodeString(v16, v3);
            LODWORD(v13) = 0x400000;
            v14 = v22;
            v5 = RtlUnicodeStringToAnsiString(&v13, v16, 0i64);
            v6 = 0;
            if ( v5 >= 0 )
              v6 = v13;
            v21 = v6;
            v7 = *(_QWORD *)(v4 + 64);
            v14 = &v22[v6];
            if ( !(unsigned __int8)MmIsAddressValid(v7)
              || (v8 = RtlUnicodeStringToAnsiString(&v13, v4 + 56, 0i64), v9 = (unsigned __int16)v13, v8 < 0) )
            {
              v9 = 0;
            }
            be::report((__int64)&v20, v9 + (unsigned __int64)((unsigned int)v21 + 2));
            v10 = *(_QWORD *)(v3 + 520);
            ExFreePoolWithTag(v3, 0i64);
          }
          v3 = v10;
        }
        while ( v10 );
      }
    }
    result = v12;
    if ( v12 )
    {
      do
      {
        v11 = *(_QWORD *)(result + 520);
        ExFreePoolWithTag(result, 0i64);
        v12 = v11;
        result = v11;
      }
      while ( v11 );
    }
  }
  return result;
}
```

`check_physical_memory.cpp`:

```cpp
__int64 __fastcall be::check_physical_memory(__int64 physical_memory)
{
  __int64 result; // rax
  __int64 v2; // rcx
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int128 v5; // xmm0
  __int128 v6; // xmm1
  __int64 v7; // [rsp+20h] [rbp-40h] BYREF
  __int64 v8; // [rsp+28h] [rbp-38h] BYREF
  char v9; // [rsp+30h] [rbp-30h] BYREF
  __int128 v10; // [rsp+31h] [rbp-2Fh]
  __int128 v11; // [rsp+41h] [rbp-1Fh]

  v8 = 0i64;
  v7 = 0i64;
  result = sub_1403453AF(&v8, (__int64)&v7, physical_memory);
  if ( (int)result >= 0 )
  {
    if ( *(_WORD *)NtBuildNumber_0 > 0x2580u )
    {
      v3 = v7;
      v4 = *(_QWORD *)(v7 + 0x28);
    }
    else
    {
      v2 = 0i64;
      v3 = v7;
      if ( *(_WORD *)NtBuildNumber_0 == 0x23F0 )
        v2 = 8i64;
      v4 = **(_QWORD **)(v7 - v2 + 0x28);
    }
    if ( *(_QWORD *)(v4 + 48) )
    {
      v5 = *(_OWORD *)(v4 + 0x18);
      v9 = 8;
      v6 = *(_OWORD *)(v4 + 0x28);
      v10 = v5;
      v11 = v6;
      be::report((__int64)&v9, 0x21i64);
      v3 = v7;
    }
    ObfDereferenceObject(v3);
    result = ZwClose(v8);
  }
  return result;
}

__int64 __fastcall sub_1403453AF(_QWORD *a1, __int64 a2, __int64 a3)
{
  int v5; // ebx
  char v7[16]; // [rsp+30h] [rbp-48h] BYREF
  int v8; // [rsp+40h] [rbp-38h] BYREF
  __int64 v9; // [rsp+48h] [rbp-30h]
  char *v10; // [rsp+50h] [rbp-28h]
  int v11; // [rsp+58h] [rbp-20h]
  __int128 v12; // [rsp+60h] [rbp-18h]

  RtlInitUnicodeString(v7, a3);
  v9 = 0i64;
  v10 = v7;
  v8 = 48;
  v11 = 576;
  v12 = 0i64;
  v5 = ZwOpenSection(a1, 0x80000000i64, &v8);
  if ( v5 < 0 )
    return (unsigned int)v5;
  _mm_lfence();
  v5 = ObReferenceObjectByHandle(*a1, 0i64, 0i64, 0i64, a2, 0i64);
  if ( v5 >= 0 )
    return (unsigned int)v5;
  ZwClose(*a1);
  return (unsigned int)v5;
}

```

`check_self_dispatch.cpp`:

```cpp
void **be::check_bedaisy_dispatch()
{
  void **result; // rax
  unsigned int v1; // ebx
  int v2; // eax
  __int64 v3; // rsi
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // rdi
  __int64 v7; // rbx
  _OWORD *v8; // rcx
  int v9; // [rsp+20h] [rbp-B8h] BYREF
  char *v10; // [rsp+28h] [rbp-B0h]
  char v11; // [rsp+30h] [rbp-A8h] BYREF
  char v12[143]; // [rsp+31h] [rbp-A7h] BYREF
  void *retaddr; // [rsp+D8h] [rbp+0h] BYREF

  result = &retaddr;
  if ( !byte_1400168C0 )
  {
    v1 = 0;
    if ( *(_QWORD *)(g_driver_object + 0x70) != 0x1400020CCi64
      || (v1 = 2, *(_QWORD *)(g_driver_object + 0x80) != 0x140002028i64)
      || (v1 = 3, *(_QWORD *)(g_driver_object + 0x88) != 0x14000348Ci64)
      || (result = (void **)sub_14000551C, v1 = 4, *(_QWORD *)(g_driver_object + 144) != 0x14000551Ci64) )
    {
      v11 = 0;
      v10 = v12;
      v9 = 0x400000;
      v2 = RtlUnicodeStringToAnsiString(&v9, g_driver_object + 0x38, 0i64);
      v3 = v1;
      v4 = 0i64;
      if ( v2 >= 0 )
        v4 = (unsigned __int16)v9;
      v5 = g_driver_object;
      v6 = (unsigned int)v4;
      v12[v4] = v1;
      *(_QWORD *)&v12[v4 + 1] = *(_QWORD *)(v5 + 8i64 * v1 + 112);
      v7 = (__int64)&v12[(unsigned int)v4 + 9];
      if ( (unsigned __int8)MmIsAddressValid(*(_QWORD *)(v5 + 8 * v3 + 112)) )
      {
        v8 = *(_OWORD **)(g_driver_object + 8 * v3 + 112);
        *(_OWORD *)v7 = *v8;
        *(_OWORD *)(v7 + 16) = v8[1];
        *(_OWORD *)(v7 + 32) = v8[2];
        *(_OWORD *)(v7 + 48) = v8[3];
      }
      else
      {
        memset((void *)v7, 0, 0x40ui64);
      }
      result = (void **)be::report((__int64)&v11, v6 + 74);
      byte_1400168C0 = 1;
    }
  }
  return result;
}
```

`create_thread_notify.cpp`:

```cpp
void __fastcall be::create_thread_notify(__int64 a1, __int64 a2, char a3)
{
  __int64 v4; // rcx
  __int64 v5; // rcx
  int v6; // [rsp+28h] [rbp-50h]
  __int64 v7; // [rsp+40h] [rbp-38h] BYREF
  __int64 v8; // [rsp+48h] [rbp-30h] BYREF
  unsigned __int64 v9; // [rsp+50h] [rbp-28h] BYREF
  char v10; // [rsp+58h] [rbp-20h] BYREF
  __int64 v11; // [rsp+59h] [rbp-1Fh]

  if ( a1 == qword_140016138 && qword_140016210 && a3 )
  {
    if ( PsGetThreadProcessId(KeGetCurrentThread()) != qword_140016138 )
    {
      if ( qword_140016218 && byte_140016174 )
        byte_140016174 = 0;
      if ( (int)PsLookupThreadByThreadId(a2, &v8) >= 0 )
      {
        LOBYTE(v6) = 0;
        if ( (int)ObOpenObjectByPointer(v8, 512i64, 0i64, 0i64, *PsThreadType, v6, &v7) >= 0 )
        {
          if ( (int)ZwQueryInformationThread(v7, 9i64, &v9) >= 0 )
          {
            KeWaitForSingleObject(&qword_1400161D8, 0i64, 0i64, 0i64, 0i64);
            v5 = qword_1400161B0;
            if ( !qword_1400161B0 )
              goto LABEL_17;
            do
            {
              if ( *(_QWORD *)v5 <= v9 && *(_QWORD *)v5 + (unsigned __int64)*(unsigned int *)(v5 + 8) > v9 )
                break;
              v5 = *(_QWORD *)(v5 + 0x220);
            }
            while ( v5 );
            if ( !v5 )
            {
LABEL_17:
              if ( byte_140016174 || !qword_140016218 )
                qword_140016218 = v9;
            }
            KeReleaseMutex(&qword_1400161D8, 0i64);
          }
          ZwClose(v7);
        }
        ObfDereferenceObject(v8);
      }
      if ( qword_140016218 )
      {
        if ( !byte_140016174 )
        {
          v10 = 3;
          v11 = qword_140016218;
          j_j_be::report_internal_2(&v10, 9);
        }
      }
    }
    j_j_be::check_lookup_thread_by_id(v4);
  }
}
```

`get_callbacklisthead.cpp`:

```cpp
unsigned __int64 be::get_CallbackListHead()
{
  unsigned __int64 v0; // rbx
  unsigned __int64 v1; // rdi
  int v2; // eax
  unsigned __int64 v3; // rcx

  CmUnRegisterCallback(0i64);
  v0 = *(_QWORD *)CmUnRegisterCallback;
  if ( *(_QWORD *)CmUnRegisterCallback )
  {
    v1 = *(_QWORD *)CmUnRegisterCallback + 4096i64;
    while ( v0 < v1 )
    {
      if ( (unsigned __int8)MmIsAddressValid(v0)
        && (unsigned __int8)MmIsAddressValid(v0 + 1)
        && (unsigned __int8)MmIsAddressValid(v0 + 2)
        && *(_BYTE *)v0 == 0x48
        && *(_BYTE *)(v0 + 1) == 0x8D
        && *(_BYTE *)(v0 + 2) == 0xD
        && *(_BYTE *)(v0 - 5) == 0x48
        && *(_BYTE *)(v0 - 4) == 0x8D
        && *(_BYTE *)(v0 - 3) == 0x54 )
      {
        v2 = *(_DWORD *)(v0 + 3);
        if ( v2 <= 0 )
          v3 = (unsigned int)v2 | 0xFFFFFFFF00000000ui64;
        else
          v3 = *(unsigned int *)(v0 + 3);
        return v0 + 7 + v3;
      }
      ++v0;
    }
  }
  return 0i64;
}
```

`get_pe_section.cpp`:

```cpp
char *__fastcall be::get_pe_section(char *a1, __int64 a2, _DWORD *AddressOfEntryPoint)
{
  PIMAGE_NT_HEADERS v6; // rax
  PIMAGE_NT_HEADERS v7; // rdi
  __int64 v8; // rbx
  USHORT v9; // si

  v6 = RtlImageNtHeader(a1);
  v7 = v6;
  if ( !v6 )
    return 0i64;
  v8 = (__int64)&v6->OptionalHeader + v6->FileHeader.SizeOfOptionalHeader;
  v9 = 0;
  if ( !v6->FileHeader.NumberOfSections )
    return 0i64;
  while ( (unsigned int)qword_140016268(v8, a2, 8i64) )
  {
    ++v9;
    v8 += 40i64;
    if ( v9 >= v7->FileHeader.NumberOfSections )
      return 0i64;
  }
  if ( AddressOfEntryPoint )
    *AddressOfEntryPoint = *(_DWORD *)(v8 + 16);
  return &a1[*(unsigned int *)(v8 + 12)];
}
```

`handle_request.cpp`:

```cpp
size_t __fastcall be::handle_request(IRP *a1, unsigned int a2)
{
  __int64 v2; // rbx
  __int64 v4; // r14
  int index; // edi
  int v6; // ecx
  _BYTE *v7; // rax
  unsigned __int64 size; // rsi
  size_t result; // rax
  unsigned int key; // ebx
  _BYTE *buffer; // r14
  int v12; // ecx
  _BYTE *v13; // rsi
  _WORD *v14; // rdx
  __int64 v15; // rsi
  size_t v16; // rsi
  int v17; // eax
  _WORD *v18; // rdx
  __int64 v19; // rsi
  const void **v20; // rbx
  int v21; // eax
  _WORD *v22; // rdx
  __int64 v23; // rsi
  size_t v24; // rsi
  __int64 v25; // rax
  __int64 v26; // rax
  int v27; // ecx
  int v28; // eax
  __int64 _RAX; // rax
  __int64 _RAX; // rax
  __int64 _RDX; // rdx
  __int64 _RCX; // rcx
  __int64 _RBX; // rbx
  int v34; // esi
  unsigned __int64 v35; // rax
  int v36; // ebx
  char v37; // r14
  unsigned __int64 v38; // rdx
  __int64 v39; // rcx
  __int64 v40; // rax
  unsigned __int64 v41; // rdx
  __int64 v42; // rcx
  __int64 v43; // rax
  unsigned __int64 v44; // rdx
  __int64 v45; // rcx
  __int64 v46; // rax
  __int64 v47; // rax
  __int64 v48; // rax
  __int64 v49; // rax
  __int64 _RAX; // rax
  __int64 _RAX; // rax
  __int64 _RDX; // rdx
  __int64 _RCX; // rcx
  __int64 _RBX; // rbx
  __int64 _RAX; // rax
  __int64 _RAX; // rax
  __int64 _RDX; // rdx
  __int64 _RCX; // rcx
  __int64 _RBX; // rbx
  __int64 _RAX; // rax
  __int64 _RAX; // rax
  __int64 _RDX; // rdx
  __int64 _RCX; // rcx
  __int64 _RBX; // rbx
  __int64 _RAX; // rax
  __int64 _RAX; // rax
  __int64 _RDX; // rdx
  __int64 _RCX; // rcx
  __int64 _RBX; // rbx
  _STORAGE_DEVICE_DESCRIPTOR *v70; // rax
  _STORAGE_DEVICE_DESCRIPTOR *v71; // rbx
  __int64 v72; // rsi
  unsigned __int8 v73; // al
  __int64 v74; // rbx
  ST_IDSECTOR *v75; // rax
  ST_IDSECTOR *v76; // rsi
  int v77; // er8
  __int64 v78; // rdx
  unsigned __int64 v79; // rbx
  int i; // ecx
  unsigned __int64 v81; // rbx
  char v82; // dl
  int v83; // ebx
  int j; // er8
  char v85; // dl
  _BYTE *v86; // rsi
  _QWORD *k; // r14
  __int64 v88; // [rsp+20h] [rbp-EE8h]
  __int64 v89; // [rsp+28h] [rbp-EE0h]
  char enc_keys[32]; // [rsp+50h] [rbp-EB8h] BYREF
  __int64 v91; // [rsp+70h] [rbp-E98h] BYREF
  __int64 v92; // [rsp+78h] [rbp-E90h] BYREF
  int v93; // [rsp+80h] [rbp-E88h]
  int v94; // [rsp+84h] [rbp-E84h]
  int v95; // [rsp+88h] [rbp-E80h]
  int v96; // [rsp+8Ch] [rbp-E7Ch]
  _QWORD v97[2]; // [rsp+90h] [rbp-E78h] BYREF
  size_t MaxCount[2]; // [rsp+A0h] [rbp-E68h] BYREF
  int v99; // [rsp+B0h] [rbp-E58h]
  unsigned __int64 v100; // [rsp+B4h] [rbp-E54h]
  int v101; // [rsp+BCh] [rbp-E4Ch]
  __int64 v102; // [rsp+C0h] [rbp-E48h] BYREF
  __int64 v103; // [rsp+C8h] [rbp-E40h]
  const void **v104; // [rsp+D0h] [rbp-E38h] BYREF
  __int64 v105; // [rsp+D8h] [rbp-E30h] BYREF
  __int64 v106; // [rsp+E0h] [rbp-E28h] BYREF
  char v107[4]; // [rsp+E8h] [rbp-E20h] BYREF
  _DWORD v108[3]; // [rsp+ECh] [rbp-E1Ch] BYREF
  _BYTE *v109; // [rsp+F8h] [rbp-E10h]
  struct _UNICODE_STRING v110; // [rsp+100h] [rbp-E08h] BYREF
  __int64 v111; // [rsp+110h] [rbp-DF8h] BYREF
  size_t v112; // [rsp+118h] [rbp-DF0h]
  char v113[8]; // [rsp+120h] [rbp-DE8h] BYREF
  int v114; // [rsp+128h] [rbp-DE0h] BYREF
  int *v115; // [rsp+130h] [rbp-DD8h]
  _QWORD v116[2]; // [rsp+138h] [rbp-DD0h] BYREF
  _QWORD v117[3]; // [rsp+148h] [rbp-DC0h] BYREF
  int v118; // [rsp+160h] [rbp-DA8h]
  __int128 v119; // [rsp+168h] [rbp-DA0h]
  _QWORD v120[3]; // [rsp+178h] [rbp-D90h] BYREF
  int v121; // [rsp+190h] [rbp-D78h]
  __int128 v122; // [rsp+198h] [rbp-D70h]
  _QWORD v123[3]; // [rsp+1A8h] [rbp-D60h] BYREF
  int v124; // [rsp+1C0h] [rbp-D48h]
  __int128 v125; // [rsp+1C8h] [rbp-D40h]
  _QWORD v126[2]; // [rsp+1D8h] [rbp-D30h] BYREF
  char v127[8]; // [rsp+1E8h] [rbp-D20h] BYREF
  int v128; // [rsp+1F0h] [rbp-D18h]
  char v129[8]; // [rsp+200h] [rbp-D08h] BYREF
  int v130; // [rsp+208h] [rbp-D00h]
  __int64 v131; // [rsp+218h] [rbp-CF0h] BYREF
  char v132; // [rsp+222h] [rbp-CE6h]
  int v133[12]; // [rsp+240h] [rbp-CC8h] BYREF
  int v134[12]; // [rsp+270h] [rbp-C98h] BYREF
  int v135[12]; // [rsp+2A0h] [rbp-C68h] BYREF
  _BYTE Dst[2048]; // [rsp+2D0h] [rbp-C38h] BYREF
  _QWORD v137[128]; // [rsp+AD0h] [rbp-438h] BYREF

  v2 = a2;
  ProbeForWrite(a1->UserBuffer, a2, 1i64);
  be::check_img_notify_still_loaded();
  be::check_bedaisy_dispatch();
  v4 = qword_1400161A8;
  index = 0;
  while ( 1 )
  {
    if ( !v4 )
      goto LABEL_32;
    v6 = *(_DWORD *)(v4 + 1048);
    if ( !v6 && !dword_1400168DC )
      break;
    if ( v6 == 1 )
      break;
    v4 = *(_QWORD *)(v4 + 1064);
  }
  if ( *(_DWORD *)(v4 + 0x418) == 1 )
  {
    v111 = 0i64;
    LODWORD(v92) = 0;
    if ( (unsigned int)v2 <= dword_1400168DC )
    {
      _mm_lfence();
      v7 = (unsigned int)v2 <= 0x400 ? Dst : a1->UserBuffer;
      if ( (int)FltReadFile(
                  *(_QWORD *)(v4 + 1032),
                  *(_QWORD *)(v4 + 1040),
                  &v111,
                  (unsigned int)v2,
                  v7,
                  4,
                  &v92,
                  0i64,
                  0i64) >= 0 )
        a1->IoStatus.Information = v2;
    }
LABEL_13:
    dword_1400168DC = 0;
    goto LABEL_14;
  }
LABEL_32:
  if ( qword_1400161B0 && *(_DWORD *)(qword_1400161B0 + 0x218i64) == 2 )
  {
    if ( (unsigned int)v2 <= dword_1400168DC
      && !IoGetTopLevelIrp()
      && (int)ObQueryNameString(*(_QWORD *)(qword_1400161B0 + 0x210i64), &Dst[1024], 1024i64, &enc_keys[16]) >= 0 )
    {
      LODWORD(v117[0]) = 48;
      v117[1] = 0i64;
      v118 = 576;
      v117[2] = &Dst[1024];
      v119 = 0i64;
      LODWORD(v89) = 32;
      LODWORD(v88) = 7;
      if ( (int)ZwOpenFile(&v105, 0x80000000i64, v117, MaxCount, v88, v89) >= 0 )
      {
        if ( (unsigned int)v2 <= 0x400 )
        {
          v13 = Dst;
        }
        else
        {
          _mm_lfence();
          v13 = (_BYTE *)ExAllocatePoolWithTag(1i64, v2, 17730i64);
        }
        if ( !v13 )
          goto LABEL_48;
        _mm_lfence();
        if ( (int)ZwReadFile(v105, 0i64, 0i64, 0i64, MaxCount, v13, v2, 0i64, 0i64) >= 0 )
        {
          if ( v13 != Dst )
          {
            _mm_lfence();
            memcpy(a1->UserBuffer, v13, MaxCount[1]);
          }
          a1->IoStatus.Information = MaxCount[1];
        }
        if ( v13 == Dst )
        {
LABEL_48:
          ZwClose(v105);
        }
        else
        {
          _mm_lfence();
          ExFreePoolWithTag(v13, 0i64);
          ZwClose(v105);
        }
      }
    }
    ObfDereferenceObject(*(_QWORD *)(qword_1400161B0 + 528i64));
    *(_DWORD *)(qword_1400161B0 + 536i64) = 0;
    goto LABEL_13;
  }
  switch ( (_DWORD)v2 )
  {
    case 4:
      *(_DWORD *)Dst = qword_140016138;
      a1->IoStatus.Information = 4i64;
      break;
    case 0x212:
      if ( v4 )
      {
        v14 = (_WORD *)(v4 + 514);
        Dst[0] = 1;
        v15 = -1i64;
        do
          ++v15;
        while ( v14[v15] );
        v16 = 2 * v15;
        memcpy(&Dst[1], v14, v16);
        if ( IoGetTopLevelIrp()
          || (int)qword_1400167A0(*(_QWORD *)(v4 + 1032), *(_QWORD *)(v4 + 1040), v127, 24i64, 5, 0i64) < 0 )
        {
          v17 = 0;
        }
        else
        {
          v17 = v128;
          dword_1400168DC = v128;
        }
        *(_DWORD *)&Dst[v16 + 1] = v17;
        *(_DWORD *)(v4 + 1048) = 1;
        goto LABEL_62;
      }
      if ( qword_1400161B0 && *(_DWORD *)(qword_1400161B0 + 536i64) == 1 )
      {
        Dst[0] = 0;
        v18 = (_WORD *)(qword_1400161B0 + 12i64);
        v19 = -1i64;
        do
          ++v19;
        while ( v18[v19] );
        v16 = 2 * v19;
        v112 = v16;
        memcpy(&Dst[1], v18, v16);
        *(_DWORD *)&Dst[v16 + 1] = 0;
        if ( IoGetTopLevelIrp()
          || (int)ObQueryNameString(*(_QWORD *)(qword_1400161B0 + 528i64), v137, 1024i64, v113) < 0
          || (LODWORD(v120[0]) = 48,
              v120[1] = 0i64,
              v121 = 576,
              v120[2] = v137,
              v122 = 0i64,
              LODWORD(v89) = 32,
              LODWORD(v88) = 7,
              (int)ZwOpenFile(v97, 0x80000000i64, v120, v116, v88, v89) < 0) )
        {
          if ( dword_1400168DC )
            goto LABEL_62;
        }
        else
        {
          if ( (int)ObReferenceObjectByHandle(v97[0], 1179785i64, *IoFileObjectType, 0i64, &v106, 0i64) < 0 )
          {
            v21 = ZwQueryInformationFile(v97[0], v116, v129, 24i64, 5);
          }
          else
          {
            KeGetCurrentIrql();
            if ( (int)IoQueryFileDosDeviceName(v106, &v104) >= 0 )
            {
              v20 = v104;
              v16 = *(unsigned __int16 *)v104;
              v112 = v16;
              memcpy(&Dst[1], v104[1], (unsigned int)v16);
              *(_DWORD *)&Dst[v16 + 1] = 0;
              ExFreePoolWithTag(v20, 0i64);
            }
            ObfDereferenceObject(v106);
            v21 = ZwQueryInformationFile(v97[0], v116, v129, 24i64, 5);
          }
          if ( v21 >= 0 )
          {
            dword_1400168DC = v130;
            *(_DWORD *)&Dst[v16 + 1] = v130;
            *(_DWORD *)(qword_1400161B0 + 536i64) = 2;
          }
          ZwClose(v97[0]);
          if ( dword_1400168DC )
            goto LABEL_62;
        }
        ObfDereferenceObject(*(_QWORD *)(qword_1400161B0 + 528i64));
        *(_DWORD *)(qword_1400161B0 + 536i64) = 0;
LABEL_62:
        a1->IoStatus.Information = v16 + 5;
        break;
      }
      if ( qword_140016820 )
      {
        Dst[0] = 2;
        v22 = (_WORD *)(qword_140016820 + 258);
        v23 = -1i64;
        do
          ++v23;
        while ( v22[v23] );
        v24 = 2 * v23;
        memcpy(&Dst[1], v22, v24);
        v25 = qword_140016820;
        *(_DWORD *)&Dst[v24 + 1] = *(_DWORD *)(qword_140016820 + 1296);
        *(_DWORD *)&Dst[v24 + 5] = *(_DWORD *)(v25 + 1300);
        *(_DWORD *)&Dst[v24 + 9] = *(_DWORD *)(v25 + 1304);
        *(_DWORD *)&Dst[v24 + 13] = *(_DWORD *)(v25 + 1308);
        Dst[v24 + 17] = *(_BYTE *)(v25 + 1312);
        v26 = qword_140016820;
        a1->IoStatus.Information = v24 + 18;
        qword_140016820 = *(_QWORD *)(v26 + 1320);
      }
      break;
    case 0x45:
      Dst[0] = byte_140016172;
      v27 = qword_140016218;
      if ( !qword_140016218 || byte_140016174 )
        v27 = 0;
      *(_DWORD *)&Dst[1] = v27;
      *(_OWORD *)&Dst[5] = xmmword_140016220;
      *(_OWORD *)&Dst[21] = xmmword_140016230;
      *(_OWORD *)&Dst[37] = xmmword_140016240;
      *(_OWORD *)&Dst[53] = xmmword_140016250;
      a1->IoStatus.Information = 0x45i64;
      break;
    case 0x3FC:
      *(_DWORD *)&Dst[1] = 1;
      *(_DWORD *)&Dst[5] = qword_140016138;
      dword_140016480 = 284;
      if ( (int)RtlGetVersion(0x140016480i64) < 0 )
      {
        v28 = 0;
        *(_QWORD *)&Dst[9] = 0i64;
      }
      else
      {
        *(_QWORD *)&Dst[9] = qword_140016484;
        v28 = dword_14001648C;
      }
      *(_DWORD *)&Dst[17] = v28;
      _RAX = 1i64;
      __asm { cpuid }
      v34 = _RCX;
      v99 = _RAX;
      LODWORD(v100) = _RBX;
      v101 = _RDX;
      v35 = __readcr4();
      *(_QWORD *)&Dst[237] = v35;
      v36 = _RCX & 0x4000000;
      if ( (_RCX & 0x4000000) == 0 || (v35 & 0x40000) != 0 )
      {
        v37 = 0;
      }
      else
      {
        v37 = 1;
        __writecr4(v35 | 0x40000);
      }
      *(_QWORD *)&enc_keys[24] = 0xFFFFFFFFFFFE7960ui64;
      *(_QWORD *)&Dst[21] = sub_140005CC0();
      if ( v36 )
        v40 = sub_140005E3C(v39, v38);
      else
        v40 = 0i64;
      *(_QWORD *)&Dst[29] = v40;
      *(_QWORD *)&Dst[37] = sub_140005D84();
      KeDelayExecutionThread(0i64, 0i64, &enc_keys[24]);
      *(_QWORD *)&Dst[45] = sub_140005CC0();
      if ( v36 )
        v43 = sub_140005E3C(v42, v41);
      else
        v43 = 0i64;
      *(_QWORD *)&Dst[53] = v43;
      *(_QWORD *)&Dst[61] = sub_140005D84();
      KeDelayExecutionThread(0i64, 0i64, &enc_keys[24]);
      *(_QWORD *)&Dst[69] = sub_140005CC0();
      if ( v36 )
        v46 = sub_140005E3C(v45, v44);
      else
        v46 = 0i64;
      *(_QWORD *)&Dst[0x4D] = v46;
      *(_QWORD *)&Dst[0x55] = sub_140005D84();
      *(_QWORD *)&Dst[0x5D] = sub_14034DE51(&Dst[165], &Dst[173]);
      if ( v36 )
        v47 = sub_14034DF51(&Dst[181], &Dst[189]);
      else
        v47 = 0i64;
      *(_QWORD *)&Dst[0x65] = v47;
      *(_QWORD *)&Dst[0x6D] = sub_14034DED6((unsigned __int64 *)&Dst[197], &Dst[205]);
      KeDelayExecutionThread(0i64, 0i64, &enc_keys[24]);
      *(_QWORD *)&Dst[0x75] = sub_14034DE51(&Dst[165], &Dst[173]);
      if ( v36 )
        v48 = sub_14034DF51(&Dst[181], &Dst[189]);
      else
        v48 = 0i64;
      *(_QWORD *)&Dst[0x7D] = v48;
      *(_QWORD *)&Dst[0x85] = sub_14034DED6((unsigned __int64 *)&Dst[197], &Dst[205]);
      KeDelayExecutionThread(0i64, 0i64, &enc_keys[24]);
      *(_QWORD *)&Dst[0x8D] = sub_14034DE51(&Dst[165], &Dst[173]);
      if ( v36 )
        v49 = sub_14034DF51(&Dst[181], &Dst[189]);
      else
        v49 = 0i64;
      *(_QWORD *)&Dst[0x95] = v49;
      *(_QWORD *)&Dst[0x9D] = sub_14034DED6((unsigned __int64 *)&Dst[197], &Dst[205]);
      if ( v37 )
        __writecr4(*(unsigned __int64 *)&Dst[237]);
      *(_DWORD *)&Dst[0xD5] = v34;
      if ( (v34 & 0x20) != 0 )
        *(_QWORD *)&Dst[0xD9] = __readmsr(0x3Au);// IA32_FEATURE_CONTROL
      if ( v34 < 0 )
      {
        _RAX = 0x40000000i64;
        __asm { cpuid }
        v99 = _RAX;
        v100 = __PAIR64__(_RCX, _RBX);
        *(_QWORD *)&Dst[0xE1] = __PAIR64__(_RCX, _RBX);
        *(_DWORD *)&Dst[0xE9] = _RDX;
      }
      _RAX = 2147483650i64;
      __asm { cpuid }
      *(_DWORD *)&Dst[0xF5] = _RAX;             // cpu name
      *(_DWORD *)&Dst[0xF9] = _RBX;             // cpu name
      *(_DWORD *)&Dst[0xFD] = _RCX;             // cpu name
      *(_DWORD *)&Dst[0x101] = _RDX;            // cpu name
      _RAX = 2147483651i64;
      __asm { cpuid }
      *(_DWORD *)&Dst[0x105] = _RAX;            // cpu name
      *(_DWORD *)&Dst[0x109] = _RBX;            // cpu name
      *(_DWORD *)&Dst[0x10D] = _RCX;            // cpu name
      _RAX = 2147483652i64;
      *(_DWORD *)&Dst[0x111] = _RDX;            // cpu name
      __asm { cpuid }
      *(_DWORD *)&Dst[0x115] = _RAX;            // cpu name
      *(_DWORD *)&Dst[0x119] = _RBX;            // cpu name
      *(_DWORD *)&Dst[0x11D] = _RCX;            // cpu name
      *(_DWORD *)&Dst[0x121] = _RDX;            // cpu name
      *(_QWORD *)&enc_keys[0x10] = 0x125i64;
      Dst[293] = 0;
      v133[0] = 0x44005C;
      v133[1] = 0x760065;
      v133[2] = 0x630069;
      v133[3] = 0x5C0065;
      v133[4] = 0x610048;
      v133[5] = 0x640072;
      v133[6] = 0x690064;
      v133[7] = 0x6B0073;
      v133[8] = 0x5C0030;
      v133[9] = 0x520044;
      v133[10] = 0x30;
      v114 = 0x2C002A;
      v115 = v133;
      LODWORD(v123[0]) = 0x30;
      v123[1] = 0i64;
      v124 = 576;
      v123[2] = &v114;
      v125 = 0i64;
      LODWORD(v89) = 32;
      LODWORD(v88) = 7;
      if ( (int)ZwOpenFile(&v91, 0xC0000000i64, v123, &v102, v88, v89) < 0 )// \Device\Harddisk0\DR0
      {
        v74 = 294i64;
        *(_QWORD *)&enc_keys[16] = 294i64;
        Dst[294] = 0;
      }
      else
      {
        if ( !byte_1400168E0 )
        {
          v134[0] = 0x77005A;
          v134[1] = 0x650044;
          v134[2] = 0x690076;
          v134[3] = 0x650063;
          v134[4] = 0x6F0049;
          v134[5] = 0x6F0043;
          v134[6] = 0x74006E;
          v134[7] = 0x6F0072;
          v134[8] = 0x46006C;
          v134[9] = 0x6C0069;
          v134[10] = 0x65;
          *(_DWORD *)&v110.Length = 2883626;
          v110.Buffer = (PWSTR)v134;
          if ( be::validate_function_integrity(5, &v110, (__int128 *)ZwDeviceIoControlFile) )
            byte_1400168E0 = 1;
          v135[0] = 0x74004E;
          v135[1] = 0x650044;
          v135[2] = 0x690076;
          v135[3] = 0x650063;
          v135[4] = 0x6F0049;
          v135[5] = 0x6F0043;
          v135[6] = 0x74006E;
          v135[7] = 0x6F0072;
          v135[8] = 0x46006C;
          v135[9] = 0x6C0069;
          v135[10] = 0x65;
          LODWORD(MaxCount[0]) = 0x2C002A;
          MaxCount[1] = (size_t)v135;
          v110 = *(struct _UNICODE_STRING *)MaxCount;
          if ( be::validate_function_integrity(6, &v110, 0i64) )
            byte_1400168E0 = 1;
        }
        v126[0] = 0i64;
        if ( (int)ZwDeviceIoControlFile(v91, 0i64, 0i64, 0i64, &v102, IOCTL_STORAGE_QUERY_PROPERTY, v126, 12, v107, 8) >= 0 )
        {
          if ( v103 )
          {
            v70 = (_STORAGE_DEVICE_DESCRIPTOR *)ExAllocatePoolWithTag(1i64, v108[0], 'EB');
            v71 = v70;
            if ( v70 )
            {
              if ( (int)ZwDeviceIoControlFile(
                          v91,
                          0i64,
                          0i64,
                          0i64,
                          &v102,
                          IOCTL_STORAGE_QUERY_PROPERTY,
                          v126,
                          12,
                          v70,
                          v108[0]) >= 0
                && v103
                && v71->SerialNumberOffset
                && (_mm_lfence(), (unsigned __int8)MmIsAddressValid((char *)v71 + v71->SerialNumberOffset)) )
              {
                _mm_lfence();
                v72 = -1i64;
                do
                  ++v72;
                while ( *((_BYTE *)&v71->Version + v71->SerialNumberOffset + v72) );
                v73 = v72;
                Dst[0x125] = v72;
                if ( (unsigned __int8)v72 > 0x28u )
                  v73 = 0x28;
                Dst[0x125] = v73;
                memcpy(&Dst[0x126], (char *)v71 + v71->SerialNumberOffset, v73);
                ExFreePoolWithTag(v71, 0i64);
              }
              else
              {
                ExFreePoolWithTag(v71, 0i64);
              }
            }
          }
        }
        v74 = Dst[0x125] + 0x126i64;
        *(_QWORD *)&enc_keys[16] = v74;
        Dst[v74] = 0;
        v132 = 0xEC;
        v75 = (ST_IDSECTOR *)ExAllocatePoolWithTag(1i64, 529i64, 17730i64);
        v76 = v75;
        if ( v75 )
        {
          if ( (int)ZwDeviceIoControlFile(v91, 0i64, 0i64, 0i64, &v102, SMART_RCV_DRIVE_DATA, &v131, 33, v75, 529) >= 0
            && v103 )
          {
            Dst[v74] = 0x14;
            v77 = 0;
            HIDWORD(v92) = 0;
            while ( v77 < 19 )
            {
              v78 = v77 + v74;
              Dst[v78 + 1] = v76->sSerialNumber[v77 + 0x11];
              Dst[v78 + 2] = v76->sSerialNumber[v77 + 16];
              v77 += 2;
              HIDWORD(v92) = v77;
            }
          }
          ExFreePoolWithTag(v76, 0i64);
          ZwClose(v91);
        }
        else
        {
          ZwClose(v91);
        }
      }
      v79 = (unsigned __int8)Dst[v74] + 1i64 + v74;
      *(_QWORD *)&enc_keys[16] = v79;
      *(_QWORD *)&v108[1] = MEMORY[0xFFFFF78000000320];
      Dst[0] = RtlRandomEx(&v108[1]);
      if ( v79 >= 0x400 )
        sub_1400138C4();
      Dst[v79] = 0;
      for ( i = 0; ; ++i )
      {
        v93 = i;
        if ( i >= v79 )
          break;
        Dst[v79] += Dst[i];
      }
      v81 = v79 + 1;
      *(_QWORD *)&enc_keys[16] = v81;
      while ( 1 )
      {
        v94 = v81;
        if ( (int)v81 >= 0x16C )
          break;
        *(_DWORD *)&Dst[(int)v81] = RtlRandomEx(&v108[1]);
        LODWORD(v81) = v81 + 4;
      }
      v82 = Dst[0];
      v83 = 0;
      for ( j = 0; ; ++j )
      {
        v95 = v83;
        if ( j >= 0x16B )
          break;
        v85 = v83 ^ Dst[j + 1] ^ v82 ^ 0xA5;
        Dst[j + 1] = v85;
        v82 = ~v85;
        v83 = j + 1;
      }
      a1->IoStatus.Information = 0x16Ci64;
      break;
    case 0x208:
      v86 = Dst;
      v109 = Dst;
      for ( k = (_QWORD *)g_report_head;
            k && (__int64)&v86[*((unsigned int *)k + 2) - (_QWORD)Dst + 2] <= v2;
            g_report_head = k )
      {
        *(_WORD *)v86 = *((_WORD *)k + 4);      // k + 8 = size
        v109 = v86 + 2;
        memcpy(v86 + 2, (const void *)*k, *((unsigned int *)k + 2));
        v86 += *((unsigned int *)k + 2) + 2;
        v109 = v86;
        ExFreePoolWithTag(*k, 0i64);
        k = *(_QWORD **)(g_report_head + 16i64);
        ExFreePoolWithTag(g_report_head, 0i64);
      }
      memset(v86, 0, (size_t)&Dst[v2 - (_QWORD)v86]);
      a1->IoStatus.Information = v2;
      break;
  }
LABEL_14:
  size = a1->IoStatus.Information;
  result = size - 1;
  if ( size - 1 <= 1023 )
  {
    result = (size_t)a1->UserBuffer;
    v104 = (const void **)a1->IoStatus.Information;
    key = *(_DWORD *)result;
    *(_DWORD *)enc_keys = *(_DWORD *)result;
    buffer = Dst;
    if ( result )
      buffer = (_BYTE *)result;
    if ( size <= 4 )
    {
      while ( 1 )
      {
        v96 = index;
        if ( index >= (int)size )
          break;
        buffer[index] = ~(_BYTE)index ^ Dst[index] ^ enc_keys[index];
        result = key >> (index % 32);
        if ( (result & 1) != 0 )
        {
          key = ~(key + 1);
          *(_DWORD *)enc_keys = key;
        }
        ++index;
      }
    }
    else
    {
      if ( buffer == Dst )
        goto LABEL_25;
      memcpy(buffer, Dst, size);
      *(_DWORD *)&enc_keys[8] = 0;
      result = size - 3;
      if ( (int)size - 3 > 0 )
      {
        do
        {
          *(_DWORD *)&buffer[index] ^= key ^ ~index;
          if ( ((key >> (index % 32)) & 1) != 0 )
          {
            key = ~(key + 1);
            *(_DWORD *)enc_keys = key;
          }
          v12 = enc_keys[index % 32] & 3;
          if ( index < (int)size - v12 - 4 )
          {
            index += v12;
            *(_DWORD *)&enc_keys[8] = index;
          }
          ++index;
LABEL_25:
          *(_DWORD *)&enc_keys[8] = index;
          result = size - 3;
        }
        while ( index < (int)size - 3 );
      }
    }
  }
  return result;
}
```

`load_image_notify.cpp`:

```cpp
void **__fastcall be::load_image_notify(const wchar_t **a1, __int64 a2, __int64 a3)
{
  void **result; // rax
  __int64 v6; // rbx
  const wchar_t *v7; // rcx
  unsigned __int64 v8; // r8
  __int64 v9; // rax
  void *v10; // rax
  size_t v11; // r8
  unsigned __int64 v12; // r8
  unsigned __int64 v13; // rdi
  unsigned __int64 v14; // rcx
  void *v15; // rcx
  unsigned __int64 v16; // rdx
  __int64 v17; // rcx
  void *v18; // rax
  size_t v19; // r8
  __int64 v20; // rbx
  unsigned __int64 v21; // rdi
  unsigned __int64 v22; // r8
  unsigned __int64 v23; // rcx
  __int64 v24; // rcx
  void *retaddr; // [rsp+48h] [rbp+0h] BYREF
  unsigned __int16 *v26; // [rsp+58h] [rbp+10h] BYREF

  result = &retaddr;
  if ( a2 )
  {
    if ( a2 == qword_140016138 && qword_140016210 )
    {
      KeWaitForSingleObject(&qword_1400161D8, 0i64, 0i64, 0i64, 0i64);
      v6 = qword_1400161B0;
      if ( !qword_1400161B0 )
        goto LABEL_12;
      do
      {
        v7 = (const wchar_t *)(v6 + 12);
        v8 = (unsigned __int64)*(unsigned __int16 *)a1 >> 1;
        v9 = -1i64;
        do
          ++v9;
        while ( v7[v9] );
        if ( v9 == v8 && !wcsncmp(v7, a1[1], v8) && !(unsigned __int8)sub_140002A9C(v6) )
          break;
        v6 = *(_QWORD *)(v6 + 0x220);
      }
      while ( v6 );
      if ( !v6 )
      {
LABEL_12:
        v10 = (void *)ExAllocatePoolWithTag(1i64, 552i64, 17730i64);
        v6 = (__int64)v10;
        if ( !v10 )
        {
LABEL_27:
          KeReleaseMutex(&qword_1400161D8, 0i64);
          PsGetCurrentProcessId();
          PsGetCurrentThreadId(v17);
          return (void **)KeGetCurrentIrql();
        }
        memset(v10, 0, v11);
        if ( qword_1400161B0 )
          *(_QWORD *)(qword_1400161B8 + 544) = v6;
        else
          qword_1400161B0 = v6;
        qword_1400161B8 = v6;
        v12 = *(unsigned __int16 *)a1;
        v13 = 256i64;
        if ( (unsigned __int16)v12 <= 0x200u )
        {
          v14 = 0i64;
        }
        else
        {
          v12 = (v12 >> 1) - 256;
          v14 = v12;
        }
        ((void (__fastcall *)(__m128i *, unsigned __int64, unsigned __int64))memcpy)(
          (__m128i *)(v6 + 12),
          (unsigned __int64)&a1[1][v14],
          v12);
        if ( *(_WORD *)a1 <= 0x200u )
          v13 = (unsigned __int64)*(unsigned __int16 *)a1 >> 1;
        *(_WORD *)(v6 + 2 * v13 + 12) = 0;
      }
      *(_QWORD *)v6 = *(_QWORD *)(a3 + 8);
      *(_DWORD *)(v6 + 8) = *(_DWORD *)(a3 + 24);
      if ( !*(_DWORD *)(v6 + 536) && v6 == qword_1400161B0 )
      {
        *(_DWORD *)(v6 + 536) = 1;
        v15 = *(void **)(a3 + 40);
        *(_QWORD *)(v6 + 528) = v15;
        ObfReferenceObject(v15);
      }
      if ( byte_140016174 )
      {
        v16 = *(_QWORD *)(a3 + 8);
        if ( qword_140016218 >= v16 && qword_140016218 < *(_QWORD *)(a3 + 24) + v16 )
        {
          byte_140016174 = 0;
          qword_140016218 = 0i64;
        }
      }
      goto LABEL_27;
    }
  }
  else
  {
    if ( (int)IoQueryFileDosDeviceName(*(_QWORD *)(a3 + 40), &v26) >= 0 )
    {
      v18 = (void *)ExAllocatePoolWithTag(1i64, 1328i64, 17730i64);
      v20 = (__int64)v18;
      if ( v18 )
      {
        memset(v18, 0, v19);
        v21 = 256i64;
        v22 = *v26;
        if ( (unsigned __int16)v22 <= 0x200u )
        {
          v23 = 0i64;
        }
        else
        {
          v22 = (v22 >> 1) - 256;
          v23 = v22;
        }
        ((void (__fastcall *)(__m128i *, unsigned __int64, unsigned __int64))memcpy)(
          (__m128i *)(v20 + 258),
          *((_QWORD *)v26 + 1) + 2 * v23,
          v22);
        if ( *v26 <= 0x200u )
          v21 = (unsigned __int64)*v26 >> 1;
        *(_WORD *)(v20 + 2 * v21 + 258) = 0;
        *(_DWORD *)(v20 + 1296) = *(_DWORD *)(a3 + 24);
        v24 = *(_QWORD *)(a3 + 8);
        *(_QWORD *)(v20 + 1288) = v24;
        if ( (unsigned __int8)MmIsAddressValid(v24) )
        {
          *(_DWORD *)(v20 + 1300) = *(_DWORD *)(*(int *)(*(_QWORD *)(a3 + 8) + 0x3Ci64) + *(_QWORD *)(a3 + 8) + 40i64);
          *(_DWORD *)(v20 + 1304) = *(_DWORD *)(*(int *)(*(_QWORD *)(a3 + 8) + 0x3Ci64) + *(_QWORD *)(a3 + 8) + 8i64);
          *(_DWORD *)(v20 + 1308) = *(_DWORD *)(*(int *)(*(_QWORD *)(a3 + 8) + 0x3Ci64) + *(_QWORD *)(a3 + 8) + 172i64);
        }
        KeWaitForSingleObject(&qword_1400161D8, 0i64, 0i64, 0i64, 0i64);
        if ( qword_140016820 )
          *(_QWORD *)(qword_1400161C0 + 1320) = v20;
        else
          qword_140016820 = v20;
        qword_1400161C0 = v20;
        if ( qword_140016828 )
          *(_QWORD *)(qword_1400161C8 + 1320) = v20;
        else
          qword_140016828 = v20;
        qword_1400161C8 = v20;
        KeReleaseMutex(&qword_1400161D8, 0i64);
      }
      ExFreePoolWithTag(v26, 0i64);
    }
    result = (void **)sub_140100619((__int64)a1, a3);
  }
  return result;
}
```

`report.cpp`:

```cpp
// attributes: thunk
__int64 __fastcall be::report(__int64 a1, __int64 a2)
{
  return be::report_internal((_BYTE *)a1, a2);
}
```

`report_custom_list.cpp`:

```cpp
__int64 __fastcall be::report_custom_list(unsigned __int64 a1, __int64 a2, __int64 *a3, __int64 a4)
{
  __int64 result; // rax
  __int64 v9; // rbx
  void *v10; // rax

  result = ExAllocatePool(1i64, 24i64);
  v9 = result;
  if ( result )
  {
    v10 = (void *)ExAllocatePool(1i64, a2);
    *(_QWORD *)v9 = v10;
    if ( v10 )
    {
      *(_DWORD *)(v9 + 8) = a2;
      memcpy(v10, (const void *)a1, (unsigned int)a2);
      *(_QWORD *)(v9 + 16) = 0i64;
      *(_BYTE *)(v9 + 12) = 0;
      KeWaitForSingleObject(0x1400161D8i64, 0i64, 0i64, 0i64, 0i64);
      if ( *a3 )
        *(_QWORD *)(*(_QWORD *)a4 + 16i64) = v9;
      else
        *a3 = v9;
      *(_QWORD *)a4 = v9;
      result = KeReleaseMutex(0x1400161D8i64, 0i64);
    }
    else
    {
      result = ExFreePoolWithTag(v9, 0i64);
    }
  }
  return result;
}
```

`report_hook.cpp`:

```cpp
unsigned __int64 __fastcall be::report_hook(unsigned __int64 a1, char a2, char a3)
{
  unsigned __int64 v3; // r9
  unsigned __int64 result; // rax
  __int128 *v6; // rcx
  __int128 v7; // xmm0
  size_t v8; // rdi
  __int64 i; // rbx
  unsigned __int64 v10; // rcx
  _BYTE *v11; // rdx
  int v12; // [rsp+30h] [rbp-D0h] BYREF
  __m128i *v13; // [rsp+38h] [rbp-C8h]
  char v14[16]; // [rsp+40h] [rbp-C0h] BYREF
  char v15[3]; // [rsp+50h] [rbp-B0h] BYREF
  unsigned __int64 v16; // [rsp+53h] [rbp-ADh]
  __int128 v17; // [rsp+5Bh] [rbp-A5h]
  __int128 *v18; // [rsp+6Bh] [rbp-95h]
  __int128 Dst[4]; // [rsp+73h] [rbp-8Dh] BYREF
  __m128i v20[16]; // [rsp+B3h] [rbp-4Dh] BYREF

  v3 = a1;
  result = a1 + 64;
  if ( a1 < a1 + 64 )
  {
    while ( *(_DWORD *)v3 != 0x25FF || *(_WORD *)(v3 + 4) )
    {
      if ( *(_WORD *)v3 == 0xB848 && *(_WORD *)(v3 + 10) == 0xE0FF )
      {
        v6 = *(__int128 **)(v3 + 2);
        goto LABEL_9;
      }
      if ( ++v3 >= result )
        return result;
    }
    v6 = *(__int128 **)(v3 + 6);
LABEL_9:
    v7 = *(_OWORD *)v3;
    v18 = v6;
    v15[0] = a2;
    v15[2] = v3 - a1;
    v17 = v7;
    v15[1] = a3;
    v16 = v3;
    if ( (unsigned __int8)MmIsAddressValid(v6) )
    {
      Dst[0] = *v18;
      Dst[1] = v18[1];
      Dst[2] = v18[2];
      Dst[3] = v18[3];
      v8 = 0i64;
      KeWaitForSingleObject(0x1400161D8i64, 0i64, 0i64, 0i64, 0i64);
    }
    else
    {
      memset(Dst, 0, sizeof(Dst));
      v8 = 0i64;
      KeWaitForSingleObject(0x1400161D8i64, 0i64, 0i64, 0i64, 0i64);
    }
    for ( i = qword_140016820; ; i = *(_QWORD *)(i + 1320) )
    {
      if ( !i )
        goto LABEL_23;
      v10 = *(_QWORD *)(i + 1288);
      if ( a1 >= v10 && a1 < *(unsigned int *)(i + 1296) + v10 )
        break;
    }
    if ( *(_WORD *)(i + 772) )
    {
      RtlInitUnicodeString(v14, i + 772);
      v12 = 0x1040000;
      v13 = v20;
      if ( (int)RtlUnicodeStringToAnsiString(&v12, v14, 0i64) >= 0 )
      {
        v8 = (unsigned __int16)v12;
        if ( (_WORD)v12 )
        {
LABEL_23:
          KeReleaseMutex(0x1400161D8i64, 0i64);
          goto LABEL_22;
        }
      }
    }
    v8 = -1i64;
    v11 = (_BYTE *)(i + 2 + *(unsigned __int16 *)i);
    do
      ++v8;
    while ( v11[v8] );
    memcpy(v20, v11, v8);
    KeReleaseMutex(0x1400161D8i64, 0i64);
LABEL_22:
    result = be::report((__int64)v15, v8 + 0x63);
  }
  return result;
}
```

`report_internal.cpp`:

```cpp
__int64 __fastcall be::report_internal(_BYTE *a1, int a2)
{
  __int64 result; // rax
  __int64 v5; // rbx
  __int64 v6; // rax
  int v7; // eax
  char v8; // r8
  __int64 v9; // rcx
  int v10; // edx
  _BYTE *v11; // rdi
  char v12; // al
  __int64 seed; // [rsp+50h] [rbp+18h] BYREF

  result = ExAllocatePoolWithTag(1i64, 24i64, 'EB');
  v5 = result;
  if ( result )
  {
    *(_DWORD *)(result + 8) = a2 + 4;
    v6 = ExAllocatePoolWithTag(1i64, (unsigned int)(a2 + 4), 'EB');
    *(_QWORD *)v5 = v6;
    if ( v6 )
    {
      seed = MEMORY[0xFFFFF78000000320];
      v7 = RtlRandomEx(&seed);
      v8 = v7;
      **(_DWORD **)v5 = v7;
      v9 = *(_QWORD *)v5 + 4i64;
      if ( *(_QWORD *)v5 == -4i64 )
        v9 = (__int64)a1;
      v10 = 0;
      if ( a2 > 0 )
      {
        v11 = &a1[-v9];
        do
        {
          v12 = v10++ ^ v8 ^ v11[v9];
          v12 ^= 0xA5u;                         // poggers driver -> client encryption
          *(_BYTE *)v9++ = v12;
          v8 = ~v12;
        }
        while ( v10 < a2 );
      }
      *(_QWORD *)(v5 + 16) = 0i64;
      KeWaitForSingleObject(0x1400161D8i64, 0i64, 0i64, 0i64, 0i64);
      if ( g_report_head )
        *(_QWORD *)(g_report_linked_list + 16) = v5;
      else
        g_report_head = v5;
      g_report_linked_list = v5;
      result = KeReleaseMutex(0x1400161D8i64, 0i64);
    }
    else
    {
      result = ExFreePoolWithTag(v5, 0i64);
    }
  }
  return result;
}
```

`report_manual_mapped_driver.cpp`:

```cpp
unsigned __int64 __fastcall be::report_manual_mapped_driver(unsigned __int64 a1, char a2)
{
  unsigned __int64 v4; // rcx
  unsigned __int64 result; // rax
  __int64 i; // rdi
  __m128 v7; // xmm1
  __m128 v8; // xmm0
  __m128 v9; // xmm1
  unsigned __int64 v10; // rdx
  char v11[2]; // [rsp+30h] [rbp-68h] BYREF
  unsigned __int64 v12; // [rsp+32h] [rbp-66h]
  __m128 v13[4]; // [rsp+3Ah] [rbp-5Eh] BYREF

  v4 = *(_QWORD *)(g_driver_object + 24);
  if ( a1 < v4 || (result = *(unsigned int *)(g_driver_object + 32) + v4, a1 >= result) )
  {
    KeWaitForSingleObject(0x1400161D8i64, 0i64, 0i64, 0i64, 0i64);
    for ( i = qword_140016820; i; i = *(_QWORD *)(i + 0x528) )
    {
      v10 = *(_QWORD *)(i + 0x508);
      if ( a1 >= v10 && a1 < *(unsigned int *)(i + 0x510) + v10 )
        break;
    }
    result = KeReleaseMutex(0x1400161D8i64, 0i64);
    if ( !i )
    {
      v11[0] = 7;
      v11[1] = a2;
      v12 = a1;
      if ( (unsigned __int8)MmIsAddressValid(a1) )
      {
        v7 = *(__m128 *)(a1 + 16);
        v13[0] = *(__m128 *)a1;
        v8 = *(__m128 *)(a1 + 32);
        v13[1] = v7;
        v9 = *(__m128 *)(a1 + 48);
        v13[2] = v8;
        v13[3] = v9;
      }
      else
      {
        ((void (__fastcall *)(__m128 *, unsigned __int8, unsigned __int64))memset)(v13, 0, 0x40ui64);
      }
      result = be::report((__int64)v11, 0x4Ai64);
    }
  }
  return result;
}
```

`resolve.cpp`:

```cpp
__int64 __fastcall be::resolve(__int64 a1, __int64 a2)
{
  __int64 v2; // r9
  __int64 v4; // r8
  __int64 v5; // rdx

  v2 = 0i64;
  if ( a1 )
  {
    v4 = *(unsigned int *)(a1 + 0x3C) + a1 + 24;
    if ( v4 )
    {
      v5 = a1 + *(unsigned int *)(v4 + 112);
      if ( v5 )
        v2 = sub_14034BE74((unsigned int)a1, (_DWORD *)(_DWORD)v5, *(_DWORD *)(v4 + 116), 1, (char *)a2, 0);
    }
  }
  return v2;
}

unsigned __int64 __fastcall sub_14034BE74(__int64 a1, _DWORD *a2, unsigned int a3, int a4, char *a5, unsigned int a6)
{
  int v6; // ebx
  __int64 v8; // rbp
  __int64 v11; // rsi
  __int64 v12; // r9
  unsigned __int64 result; // rax
  int v14; // eax
  int v15; // edx
  int v16; // eax
  char *v17; // rcx
  __int64 v18; // rdi
  char v19; // r8
  int v20; // ecx

  v8 = a3;
  if ( !a2 || !a3 )
    return 0i64;
  v11 = (unsigned int)a2[8] + a1;
  v12 = (unsigned int)a2[9] + a1;
  if ( !a4 )
    return *(unsigned int *)(a1 + (unsigned int)a2[7] + 4i64 * a6);
  v14 = a2[6];
  v15 = 0;
  v16 = v14 - 1;
  if ( v16 < 0 )
    return 0i64;
  while ( 1 )
  {
    v17 = a5;
    v18 = *(unsigned int *)(v11 + 4i64 * v6) + a1 - (_QWORD)a5;
    while ( 1 )
    {
      v19 = *v17;
      if ( v17[v18] != *v17 )
        break;
      ++v17;
      if ( !v19 )
      {
        v20 = 0;
        goto LABEL_11;
      }
    }
    v20 = (unsigned __int8)v17[v18] < (unsigned __int8)*v17 ? -1 : 1;
LABEL_11:
    if ( v20 >= 0 )
      break;
    v16 = v6 - 1;
LABEL_13:
    if ( v16 < v15 )
      goto LABEL_14;
  }
  if ( v20 > 0 )
  {
    v15 = v6 + 1;
    goto LABEL_13;
  }
LABEL_14:
  if ( v16 < v15 )
    return 0i64;
  _mm_lfence();
  if ( (unsigned int)*(unsigned __int16 *)(v12 + 2i64 * v6) >= a2[5] )
    return 0i64;
  _mm_lfence();
  result = *(unsigned int *)((unsigned int)a2[7] + a1 + 4i64 * *(unsigned __int16 *)(v12 + 2i64 * v6)) + a1;
  if ( result > (unsigned __int64)a2 && result < (unsigned __int64)a2 + v8 )
    result = 0i64;
  return result;
}
```

`stackwalk.cpp`:

```cpp
__int64 __fastcall be::stackwalk(__int64 a1, int a2, __int64 a3, char a4)
{
  char v4; // r13
  __int64 v5; // rdi
  __int64 v6; // r15
  __int64 v7; // r12
  __int64 v8; // rbx
  __int64 result; // rax
  unsigned int v10; // esi
  __int64 v11; // rax
  __int64 v12; // r14
  __int64 v13; // rbx
  int v14; // eax
  unsigned int v15; // er10
  int v16; // er11
  unsigned __int64 v17; // rcx
  __int64 v18; // rbx
  unsigned __int64 v19; // rdx
  __int64 v20; // rcx
  unsigned __int64 v21; // r8
  __int64 *v22; // rax
  __int64 v23; // rdi
  __int64 v24; // rcx
  __int64 v25; // rax
  __int64 v26; // r13
  unsigned int v27; // ebx
  __int64 v28; // rax
  __int64 v29; // rbx
  unsigned __int64 v30; // r8
  _BYTE *v31; // rcx
  unsigned int v32; // esi
  int v33; // ebx
  int *v34; // rdi
  unsigned int v35; // er8
  __int64 v36; // rdx
  _QWORD *v37; // rcx
  int v38; // er9
  __int128 v39; // xmm0
  __int128 v40; // xmm1
  __int128 v41; // xmm0
  int v42; // eax
  __int64 v43; // rdi
  __int128 v44; // xmm1
  __int64 v45; // rcx
  _WORD *v46; // rdx
  __int64 v47; // r8
  __int64 v48; // rcx
  int v49; // eax
  __int64 v50; // rcx
  unsigned __int64 v51; // r8
  __int64 v52; // rcx
  __int64 v53; // rax
  __int64 v54; // rcx
  __int64 v55; // rbx
  __int64 v56; // rdx
  char v57; // si
  __int64 v58; // rdx
  __int64 v59; // rbx
  unsigned int v60; // er14
  __int64 v61; // rbx
  unsigned int v62; // edx
  __int64 v63; // rax
  bool v64; // zf
  char v66; // [rsp+44h] [rbp-BCh]
  unsigned int v67; // [rsp+48h] [rbp-B8h]
  unsigned int v68; // [rsp+4Ch] [rbp-B4h]
  char v69; // [rsp+50h] [rbp-B0h]
  __int64 v72; // [rsp+60h] [rbp-A0h]
  __int64 v73; // [rsp+68h] [rbp-98h] BYREF
  __int64 v74; // [rsp+70h] [rbp-90h] BYREF
  int v75; // [rsp+78h] [rbp-88h] BYREF
  int *v76; // [rsp+80h] [rbp-80h]
  int v77; // [rsp+88h] [rbp-78h] BYREF
  int *v78; // [rsp+90h] [rbp-70h]
  __int64 v79; // [rsp+98h] [rbp-68h]
  __int64 v80; // [rsp+A0h] [rbp-60h]
  char v81[24]; // [rsp+A8h] [rbp-58h] BYREF
  __int64 v82[10]; // [rsp+C0h] [rbp-40h] BYREF
  char v83[2]; // [rsp+110h] [rbp+10h] BYREF
  __int64 v84; // [rsp+112h] [rbp+12h]
  __int128 v85; // [rsp+11Ah] [rbp+1Ah]
  __int128 v86; // [rsp+12Ah] [rbp+2Ah]
  __int128 v87; // [rsp+13Ah] [rbp+3Ah]
  __int128 v88; // [rsp+14Ah] [rbp+4Ah]
  int v89; // [rsp+15Ah] [rbp+5Ah]
  char v90; // [rsp+15Eh] [rbp+5Eh]
  int v91[48]; // [rsp+15Fh] [rbp+5Fh] BYREF

  v4 = a4;
  v5 = a3;
  v6 = a1;
  v80 = a1;
  v7 = 10i64 * (unsigned int)a2;
  v8 = *(_QWORD *)(a1 + 80i64 * (unsigned int)a2 + 304);
  result = PsGetCurrentThreadId(a1);
  if ( v8 != result )
  {
    result = PsLookupThreadByThreadId(v8, &v74);
    v10 = 0;
    if ( (int)result >= 0 )
    {
      v11 = ExAllocatePool(512i64, 2168i64);
      v79 = v11;
      v12 = v11;
      if ( v11 )
      {
        v13 = v11 + 88;
        KeInitializeEvent(v11 + 88, 0i64, 0i64);
        KeInitializeApc(v12, v74, 0i64, sub_14000BFA8, 0i64, 0i64, 0, 0i64);
        if ( (unsigned __int8)KeInsertQueueApc(v12, v12, 0i64, 2i64) )
        {
          v73 = -1000000i64;
          v14 = KeWaitForSingleObject(v13, 0i64, 0i64, 0i64, &v73);
          if ( v14 )
          {
            if ( v14 != 258
              || !(unsigned __int8)sub_14034D46C(v12)
              && (unsigned int)KeWaitForSingleObject(v13, 0i64, 0i64, 0i64, &v73) )
            {
              return ObfDereferenceObject(v74);
            }
          }
          else
          {
            KeWaitForSingleObject(&qword_1400161D8, 0i64, 0i64, 0i64, 0i64);
            v15 = *(_DWORD *)(v12 + 2160);
            v69 = 1;
            v16 = 1;
            if ( v15 > 1 )
            {
              while ( 1 )
              {
                if ( v5 || *(_QWORD *)(v12 + 8i64 * v16 + 112) >= 0x8000000000000000ui64 )
                {
                  v17 = *(_QWORD *)(g_driver_object + 24);
                  v18 = v16;
                  v72 = v16;
                  v19 = *(_QWORD *)(v12 + 8i64 * v16 + 112);
                  if ( v19 < v17 || v19 >= v17 + *(unsigned int *)(g_driver_object + 32) )
                  {
                    v20 = qword_140016828;
                    if ( !qword_140016828 )
                      break;
                    do
                    {
                      v21 = *(_QWORD *)(v20 + 1288);
                      if ( v19 >= v21 && v19 < v21 + *(unsigned int *)(v20 + 1296) )
                        break;
                      v20 = *(_QWORD *)(v20 + 1320);
                    }
                    while ( v20 );
                    if ( !v20 )
                      break;
                  }
                }
                v69 = ++v16;
                if ( v16 >= v15 )
                  goto LABEL_17;
              }
              v22 = qword_140016DA8;
              v23 = 0i64;
              do
              {
                v24 = *(v22 - 1);
                if ( !v24 || *(_QWORD *)(v6 + 8 * v7 + 304) == v24 && v19 == *v22 )
                  break;
                ++v10;
                v22 += 2;
              }
              while ( v10 < 0xA );
              if ( (v67 = v10, v10 < 0xA) && !qword_140016DA0[2 * (int)v10] || v4 )
              {
                v25 = ExAllocatePool(512i64, 64i64);
                v26 = v25;
                if ( v25 )
                {
                  if ( (int)((__int64 (__fastcall *)(_QWORD, __int64))sub_14034D4AA)(
                              *(_QWORD *)(v12 + 8 * v18 + 112),
                              v25) >= 0 )
                  {
                    _mm_lfence();
                    v66 = 0;
                    v27 = 0;
                    v68 = 0;
                    v28 = 0i64;
                    while ( *(_BYTE *)(v28 + v26) != 0xE9 )
                    {
                      ++v27;
                      if ( ++v28 >= 60 )
                        goto LABEL_34;
                    }
                    v23 = ExAllocatePool(512i64, 64i64);
                    if ( v23 )
                    {
                      v57 = 0;
                      v58 = v27 + (__int64)*(int *)(v27 + v26 + 1);
                      v59 = *(_QWORD *)(v12 + 8 * v72 + 112);
                      v60 = 0;
                      v61 = v58 + v59 + 5;
                      do
                      {
                        if ( !(unsigned __int8)MmIsAddressValid(v61) || (int)sub_14002D722(v61, v23) < 0 )
                          break;
                        if ( v60 < 0xA )
                          v82[v60] = v61;
                        ++v60;
                        v62 = 0;
                        v63 = 0i64;
                        if ( v60 == 5 )
                          v57 = 1;
                        while ( *(_BYTE *)(v63 + v23) != 0xE9 )
                        {
                          ++v62;
                          if ( ++v63 >= 60 )
                            goto LABEL_96;
                        }
                        v61 += v62 + *(int *)(v63 + v23 + 1) + 5i64;
LABEL_96:
                        ;
                      }
                      while ( v62 != 60 && v60 < 0x64 );
                      v68 = v60;
                      v66 = v57;
                      ExFreePoolWithTag(v23, 0i64);
                      v12 = v79;
                      v23 = 0i64;
                      v6 = v80;
                      v64 = v57 == 0;
                      v10 = v67;
                      if ( !v64 )
                        goto LABEL_53;
                    }
LABEL_34:
                    v29 = a3;
                    if ( a3 != qword_140016830
                      || (unsigned __int8)MmIsAddressValid(*(_QWORD *)(v6 + 8 * v7 + 288))
                      && ((v31 = *(_BYTE **)(v6 + 8 * v7 + 288), *v31 == 0xCC)
                       || *v31 == 0x90
                       || ((*(_WORD *)v31 + 7681) & 0xBFFF) == 0) )
                    {
                      v66 = 1;
                      goto LABEL_54;
                    }
                    v32 = dword_140016D80;
                    v33 = v23;
                    if ( dword_140016D80 )
                    {
                      v34 = dword_140016920;
                      while ( (unsigned int)sub_140013A60(
                                              (unsigned __int64 *)v26,
                                              (__int64)&dword_140016900[9 * v33],
                                              v30) )
                      {
                        v34 += 9;
                        if ( ++v33 >= v32 )
                        {
                          v23 = 0i64;
                          goto LABEL_44;
                        }
                      }
                      v10 = v67;
                      v66 = 1;
                      goto LABEL_53;
                    }
LABEL_44:
                    v35 = v23;
                    if ( a2 >= 50 )
                    {
                      v36 = v23;
                      v37 = (_QWORD *)(v6 + 288);
                      v38 = a2;
                      while ( v36 < 20 && v35 < *(_DWORD *)(v6 + 4) )
                      {
                        if ( *(v37 - 2) == *(_QWORD *)(v6 + 8 * v7 + 272) && *v37 == *(_QWORD *)(v6 + 8 * v7 + 288) )
                        {
                          v66 = 1;
                          goto LABEL_52;
                        }
                        ++v35;
                        --v38;
                        ++v36;
                        v37 += 10;
                        if ( v38 < 50 )
                          break;
                      }
                    }
                    if ( a4 != (_BYTE)v23 )
                    {
LABEL_52:
                      v10 = v67;
LABEL_53:
                      v29 = a3;
LABEL_54:
                      v39 = *(_OWORD *)v26;
                      v83[1] = v69;
                      v40 = *(_OWORD *)(v26 + 16);
                      v85 = v39;
                      v83[0] = 0xE;
                      v41 = *(_OWORD *)(v26 + 32);
                      v84 = *(_QWORD *)(v12 + 8 * v72 + 112);
                      v42 = *(_DWORD *)(v6 + 8 * v7 + 304);
                      v86 = v40;
                      v89 = v42;
                      v43 = 0i64;
                      v44 = *(_OWORD *)(v26 + 48);
                      v87 = v41;
                      v88 = v44;
                      if ( v29 )
                      {
                        v45 = -1i64;
                        do
                          ++v45;
                        while ( *(_WORD *)(v29 + 2 * v45 + 258) );
                        if ( (int)v45 >= 0 )
                        {
                          v46 = (_WORD *)(v29 + 2 * ((int)v45 + 129i64));
                          while ( 1 )
                          {
                            v47 = (unsigned int)v45;
                            --v46;
                            LODWORD(v45) = v45 - 1;
                            if ( (_DWORD)v45 == -1 || *v46 == 92 || *v46 == 47 )
                              break;
                            if ( (int)v45 < 0 )
                              goto LABEL_63;
                          }
                          _mm_lfence();
                          RtlInitUnicodeString(v81, v29 + 2 * (v47 + 129));
                          v75 = 0x400000;
                          v76 = v91;
                          if ( (int)RtlUnicodeStringToAnsiString(&v75, v81, 0i64) >= 0 )
                            v43 = (unsigned __int16)v75;
                        }
                      }
                      else
                      {
                        v77 = 0x400000;
                        v78 = v91;
                        if ( (int)RtlUnicodeStringToAnsiString(&v77, v6 + 56, 0i64) >= 0 )
                          v43 = (unsigned __int16)v77;
                      }
LABEL_63:
                      v90 = v43;
                      if ( v29 )
                        v48 = *(_QWORD *)(v29 + 1288);
                      else
                        LODWORD(v48) = 0;
                      v49 = *(_DWORD *)(v6 + 8 * v7 + 288) - v48;
                      v50 = *(_QWORD *)(v6 + 8 * v7 + 288);
                      *(int *)((char *)v91 + v43) = v49;
                      if ( (unsigned __int8)MmIsAddressValid(v50) )
                        *(_OWORD *)((char *)&v91[1] + v43) = *(_OWORD *)*(_QWORD *)(v6 + 8 * v7 + 288);
                      else
                        *(_OWORD *)((char *)&v91[1] + v43) = 0i64;
                      v52 = *(_QWORD *)(v6 + 8 * v7 + 272);
                      v53 = MEMORY[0xFFFFF78000000014] - v52;
                      v54 = v52 - *(_QWORD *)(v6 + 32);
                      *(_QWORD *)((char *)&v91[5] + v43) = v53;
                      LOWORD(v53) = *(_WORD *)(v6 + 4) - a2 - 1;
                      *(_QWORD *)((char *)&v91[7] + v43 + 2) = v54;
                      *(_WORD *)((char *)&v91[7] + v43) = v53;
                      *((_BYTE *)&v91[9] + v43 + 2) = v68;
                      v55 = 8i64 * v68;
                      if ( v68 > 0xA )
                        v55 = 80i64;
                      ((void (__fastcall *)(__m128i *, unsigned __int64, unsigned __int64))memcpy)(
                        (__m128i *)((char *)&v91[9] + v43 + 3),
                        (unsigned __int64)v82,
                        v51);
                      v56 = v43 + v55 + 0x76;
                      if ( !v66 || v10 >= 0xA || qword_140016DA0[2 * (int)v10] )
                      {
                        ((void (__fastcall *)(char *, __int64))j_be::report_custom_list)(v83, v56);
                      }
                      else
                      {
                        j_j_be::report_internal_0((__int64)v83, v56);
                        qword_140016DA0[2 * (int)v10] = *(_QWORD *)(v6 + 8 * v7 + 304);
                        qword_140016DA8[2 * (int)v10] = *(_QWORD *)(v12 + 8 * v72 + 112);
                      }
                      goto LABEL_73;
                    }
                  }
LABEL_73:
                  ExFreePoolWithTag(v26, 0i64);
                }
              }
            }
LABEL_17:
            KeReleaseMutex(&qword_1400161D8, 0i64);
          }
        }
        ExFreePoolWithTag(v12, 0i64);
      }
      return ObfDereferenceObject(v74);
    }
  }
  return result;
}
```

`system_thread.cpp`:

```cpp
__int64 be::system_thread()
{
  unsigned int v0; // eax
  __int128 *v1; // rax
  unsigned __int16 *v2; // rbx
  char v3; // al
  char v4; // si
  __int64 v5; // rdx
  int v6; // ebx
  __int64 v7; // rax
  __int64 v8; // rdi
  int j; // ebx
  __int64 v10; // rcx
  __int64 v11; // rcx
  __int64 v12; // rax
  char v13; // al
  char v14; // cl
  char v15; // al
  char v16; // cl
  char v17; // al
  char v18; // cl
  char v19; // al
  char v20; // cl
  char v21; // al
  char v22; // cl
  char v23; // al
  char v24; // cl
  int v26; // eax
  bool v27; // si
  unsigned int i; // edi
  __int64 v29; // rdi
  __int64 v30; // rax
  __int64 v31; // r8
  __int64 v32; // rcx
  _DWORD v33[4]; // [rsp+30h] [rbp-D0h] BYREF
  struct _UNICODE_STRING v34; // [rsp+40h] [rbp-C0h] BYREF
  _QWORD v35[2]; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v36; // [rsp+60h] [rbp-A0h] BYREF
  _QWORD v37[2]; // [rsp+68h] [rbp-98h] BYREF
  char v38[48]; // [rsp+78h] [rbp-88h] BYREF
  __int64 v39; // [rsp+A8h] [rbp-58h] BYREF
  char v40[16]; // [rsp+B0h] [rbp-50h] BYREF
  char v41[11]; // [rsp+C0h] [rbp-40h] BYREF
  int v42; // [rsp+CBh] [rbp-35h]
  _WORD v43[8]; // [rsp+CFh] [rbp-31h] BYREF
  int v44; // [rsp+E4h] [rbp-1Ch]
  char v45[8]; // [rsp+E8h] [rbp-18h] BYREF
  int v46; // [rsp+F2h] [rbp-Eh]
  __int64 v47; // [rsp+F6h] [rbp-Ah]
  int v48; // [rsp+FEh] [rbp-2h]
  char v49[8]; // [rsp+102h] [rbp+2h] BYREF
  int v50; // [rsp+10Ch] [rbp+Ch]
  char v51[8]; // [rsp+110h] [rbp+10h] BYREF
  char v52[17]; // [rsp+11Bh] [rbp+1Bh] BYREF
  int v53[8]; // [rsp+140h] [rbp+40h] BYREF
  __int16 v54; // [rsp+160h] [rbp+60h]
  int v55[12]; // [rsp+168h] [rbp+68h] BYREF
  __int16 v56; // [rsp+198h] [rbp+98h]
  int v57[12]; // [rsp+1A0h] [rbp+A0h] BYREF
  __int16 v58; // [rsp+1D0h] [rbp+D0h]
  __m128i v59; // [rsp+1D8h] [rbp+D8h] BYREF
  int v60; // [rsp+1E8h] [rbp+E8h]

  be::validate_function_integrity(0, 0i64, (__int128 *)MmGetSystemRoutineAddress);
  v53[0] = 7143501;
  v53[1] = 7536713;
  v53[2] = 6553665;
  v53[3] = 7471204;
  v53[4] = 7536741;
  v53[5] = 5636211;
  v53[6] = 7077985;
  v53[7] = 6553705;
  v54 = 0;
  *(_DWORD *)&v34.Length = 2228256;
  v34.Buffer = (PWSTR)v53;
  be::validate_function_integrity(1, &v34, (__int128 *)MmIsAddressValid);
  v34.Buffer = (PWSTR)v55;
  *(_DWORD *)&v34.Length = 3276848;
  v55[0] = 7798874;
  v56 = 0;
  v55[11] = 7209071;
  v55[10] = 6881396;
  v55[9] = 6357101;
  v55[8] = 7471215;
  v55[7] = 6684782;
  v55[6] = 4784237;
  v55[5] = 6619252;
  v55[4] = 7536761;
  v55[3] = 5439609;
  v55[2] = 7471205;
  v55[1] = 7667793;
  be::validate_function_integrity(2, &v34, (__int128 *)ZwQuerySystemInformation);
  *(_DWORD *)&v34.Length = 3276848;
  v34.Buffer = (PWSTR)v57;
  v57[0] = 0x74004E;
  v58 = 0;
  v57[11] = 0x6E006F;
  v57[10] = 0x690074;
  v57[9] = 0x61006D;
  v57[7] = 0x66006E;
  v57[5] = 0x650074;
  v57[4] = 0x730079;
  v57[2] = 0x720065;
  v57[1] = 0x750051;
  v57[3] = 0x530079;
  v57[6] = 0x49006D;
  v57[8] = 0x72006F;
  be::validate_function_integrity(3, &v34, 0i64);
  v59 = _mm_load_si128((const __m128i *)&xmmword_140014090);
  v60 = 7959151;
  v0 = sub_140346948((__int64)&v59);
  v1 = (__int128 *)j_GetKeServiceDescriptorTable(v0);
  if ( v1 )
    be::validate_function_integrity(4, 0i64, v1);
  be::check_kernel_integrity();
  v2 = (unsigned __int16 *)qword_140016828;
  strcpy((char *)&v39, "win32k");
  strcpy(v41, "hal.dll");
  v42 = 1818427392;
  strcpy((char *)v43, "ipsp.sys");
  *(_DWORD *)&v43[5] = 776553216;
  strcpy((char *)&v43[7], "dll");
  v44 = 1946157056;
  strcpy(v45, "pm.sys");
  v46 = 1936392192;
  v47 = 1937339182i64;
  v48 = 1660944384;
  strcpy(v49, "dd.dll");
  v50 = 1398013952;
  strcpy(v51, "DDD.dll");
  strcpy(v52, "spsys.sys");
  strcpy(&v52[13], "atikmpag.sys");
  strcpy(v40, "csrss.exe");
  while ( v2 )
  {
    v26 = qword_140016268((char *)v2 + *v2 + 2, &v39, 6i64);
    v27 = v26 == 0;
    if ( !v26 )
      goto LABEL_62;
    for ( i = 0; i < 9; ++i )
    {
      if ( !(unsigned int)strcmp((char *)v2 + *v2 + 2, &v41[13 * i]) )
        break;
    }
    if ( i != 9 )
    {
LABEL_62:
      if ( !v27 )
        goto LABEL_73;
    }
    v29 = 0i64;
    if ( v27 )
    {
      v30 = sub_1403440C2(v40, 0i64);
      v29 = v30;
      if ( !v30 )
        goto LABEL_73;
      KeStackAttachProcess(v30, v38);
      if ( v2 != (unsigned __int16 *)qword_140016830 )
        goto LABEL_66;
LABEL_76:
      v32 = *((_QWORD *)v2 + 161);
      if ( !v32 )
        goto LABEL_74;
LABEL_71:
      sub_14034AA45(v32, (__int64)v2 + *v2 + 2);
      if ( v27 )
        goto LABEL_72;
LABEL_73:
      v2 = (unsigned __int16 *)*((_QWORD *)v2 + 165);
    }
    else
    {
      if ( v2 == (unsigned __int16 *)qword_140016830 )
        goto LABEL_76;
LABEL_66:
      if ( v27 && *(_WORD *)NtBuildNumber_0 > 0x2800u )
        goto LABEL_76;
      if ( !*((_BYTE *)v2 + 2) )
        goto LABEL_76;
      RtlInitAnsiString(v37, v2 + 1);
      LOBYTE(v31) = 1;
      if ( (int)RtlAnsiStringToUnicodeString(v35, v37, v31) < 0 )
        goto LABEL_76;
      sub_140349713(*((_QWORD *)v2 + 161), *((unsigned int *)v2 + 324), (__int64)v35, (unsigned __int64)v2 + *v2 + 2);
      RtlFreeUnicodeString(v35);
      v32 = *((_QWORD *)v2 + 161);
      if ( v32 )
        goto LABEL_71;
LABEL_74:
      if ( !v27 )
        goto LABEL_73;
LABEL_72:
      KeUnstackDetachProcess(v38);
      PsReleaseProcessExitSynchronization(v29);
      ObfDereferenceObject(v29);
      v2 = (unsigned __int16 *)*((_QWORD *)v2 + 165);
    }
  }
  v3 = sub_140349115();
  dword_140016920[0] = 9;
  v4 = v3;
  dword_140016D80 = 1;
  dword_140016900[0] = -2134605496;
  dword_140016904 = 1593835521;
  byte_140016908 = -61;
  sub_14034F069();
  v36 = -1000000i64;
  do
  {
    be::check_img_notify_still_loaded();
    be::check_bedaisy_dispatch();
    if ( !byte_140016176 )
      goto LABEL_35;
    if ( byte_140016004 )
    {
      if ( !qword_140016788 )
        LODWORD(dword_140016714) = 0;
      v5 = 0x140016714i64;
      if ( qword_140016788 )
        v5 = qword_140016788;
      v6 = ZwQuerySystemInformation(5i64, v5, (unsigned int)dword_140016714, v33);
      if ( v6 == -1073741820 )
      {
        if ( qword_140016788 )
          ExFreePoolWithTag(qword_140016788, 0i64);
        LODWORD(dword_140016714) = v33[0] + 1024;
        v7 = ExAllocatePoolWithTag(1i64, (unsigned int)(v33[0] + 1024), 17730i64);
        qword_140016788 = v7;
        if ( !v7 )
          goto LABEL_35;
        do
        {
          v6 = ZwQuerySystemInformation(5i64, v7, (unsigned int)dword_140016714, v33);
          if ( v6 != -1073741820 )
            break;
          ExFreePoolWithTag(qword_140016788, 0i64);
          LODWORD(dword_140016714) = v33[0] + 1024;
          v7 = ExAllocatePoolWithTag(1i64, (unsigned int)(v33[0] + 1024), 17730i64);
          qword_140016788 = v7;
        }
        while ( v7 );
      }
      if ( v6 < 0 )
        goto LABEL_35;
      byte_140016004 = 0;
      qword_140016790 = qword_140016788;
    }
    v8 = PsGetProcessId(*(_QWORD *)PsInitialSystemProcess);
    for ( j = 0; j < 10; ++j )
    {
      if ( !qword_140016210
        || (v10 = *(_QWORD *)(qword_140016790 + 80), v10 == qword_140016138)
        || v10 == (_QWORD)xmmword_140016150
        || v10 == v8
        || v10 == qword_140016160
        || v10 == qword_140016168
        || byte_140016170 && v10 == qword_140016178
        || *(_QWORD *)(qword_140016790 + 88) == (_QWORD)xmmword_140016150
        || (int)PsLookupProcessByProcessId(v10, v35) < 0 )
      {
        v11 = qword_140016790;
        v12 = *(unsigned int *)qword_140016790;
        if ( !(_DWORD)v12 )
        {
LABEL_34:
          byte_140016004 = 1;
          break;
        }
      }
      else
      {
        sub_14033B383(v35[0], 0i64);
        ObfDereferenceObject(v35[0]);
        v11 = qword_140016790;
        v12 = *(unsigned int *)qword_140016790;
        if ( !(_DWORD)v12 )
          goto LABEL_34;
      }
      qword_140016790 = v11 + v12;
    }
LABEL_35:
    if ( !byte_1400168C8 )
    {
      v13 = be::validate_function_integrity(7, 0i64, (__int128 *)KeInitializeEvent);
      v14 = byte_1400168C8;
      if ( v13 )
        v14 = 1;
      byte_1400168C8 = v14;
      v15 = be::validate_function_integrity(8, 0i64, (__int128 *)KeInitializeApc);
      v16 = byte_1400168C8;
      if ( v15 )
        v16 = 1;
      byte_1400168C8 = v16;
      v17 = be::validate_function_integrity(9, 0i64, (__int128 *)KeInsertQueueApc);
      v18 = byte_1400168C8;
      if ( v17 )
        v18 = 1;
      byte_1400168C8 = v18;
      v19 = be::validate_function_integrity(10, 0i64, (__int128 *)RtlWalkFrameChain);
      v20 = byte_1400168C8;
      if ( v19 )
        v20 = 1;
      byte_1400168C8 = v20;
      v21 = be::validate_function_integrity(11, 0i64, (__int128 *)KeSetEvent);
      v22 = byte_1400168C8;
      if ( v21 )
        v22 = 1;
      byte_1400168C8 = v22;
      v23 = be::validate_function_integrity(12, 0i64, (__int128 *)KeWaitForSingleObject);
      v24 = byte_1400168C8;
      if ( v23 )
        v24 = 1;
      byte_1400168C8 = v24;
    }
    sub_1403471F1(v4);
  }
  while ( (unsigned int)KeWaitForSingleObject(0x1400167B8i64, 0i64, 0i64, 0i64, &v36) );
  if ( qword_140016788 )
    ExFreePoolWithTag(qword_140016788, 0i64);
  return PsTerminateSystemThread(0i64);
}
```

`validate_function_integrity.cpp`:

```cpp
char __fastcall be::validate_function_integrity(char a1, struct _UNICODE_STRING *a2, __int128 *a3)
{
  __int128 *v6; // rax
  char v7; // al
  __int128 v8; // xmm1
  __int128 v9; // xmm0
  __int128 v10; // xmm1
  char result; // al
  _QWORD *v12; // rbx
  unsigned int v13; // edi
  unsigned __int64 v14; // rcx
  __int128 *i; // rcx
  unsigned __int64 v16; // rdx
  char v17; // [rsp+20h] [rbp-60h] BYREF
  char v18; // [rsp+21h] [rbp-5Fh]
  char v19; // [rsp+22h] [rbp-5Eh] BYREF
  __int128 *v20; // [rsp+23h] [rbp-5Dh]
  __int128 Dst[4]; // [rsp+2Bh] [rbp-55h] BYREF

  if ( a2 )
    v6 = (__int128 *)MmGetSystemRoutineAddress(a2);
  else
    v6 = 0i64;
  if ( !a3 )
    a3 = v6;
  if ( !a2 || v6 && v6 == a3 )
  {
    if ( qword_140016830
      && ((v14 = *(_QWORD *)(qword_140016830 + 1288), (unsigned __int64)a3 < v14)
       || (unsigned __int64)a3 >= *(unsigned int *)(qword_140016830 + 1296) + v14) )
    {
      v7 = 1;                                   // eat hooked
    }
    else
    {
      for ( i = a3; ; i = *(__int128 **)((char *)i + *(unsigned int *)((char *)i + 2) + 6) )
      {
        while ( *(_BYTE *)i == 0xE9 )
          i = (__int128 *)((char *)i + *(_DWORD *)((char *)i + 1) + 5);
        if ( *(_WORD *)i != 0x25FF )
          break;
      }
      if ( i == a3
        || !qword_140016830
        || (v16 = *(_QWORD *)(qword_140016830 + 1288), (unsigned __int64)i >= v16)
        && (unsigned __int64)i < *(unsigned int *)(qword_140016830 + 1296) + v16 )
      {
        v7 = -1;                                // OK
        if ( *(_BYTE *)i == 0xCC )
          v7 = 3;                               // veh hooked
      }
      else
      {
        v7 = 2;
        a3 = i;
      }
    }
  }
  else
  {
    v7 = 0;
  }
  v19 = v7;
  v20 = a3;
  v18 = a1;
  v17 = 9;
  if ( a3 )
  {
    v8 = a3[1];
    Dst[0] = *a3;
    v9 = a3[2];
    Dst[1] = v8;
    v10 = a3[3];
    Dst[2] = v9;
    Dst[3] = v10;
  }
  else
  {
    memset(Dst, 0, sizeof(Dst));
    v7 = v19;
    a1 = v18;
  }
  if ( v7 == -1 )
  {
    v12 = (_QWORD *)qword_140016368;
    v13 = 0;
    if ( !qword_140016368 )
      goto LABEL_20;
    do
    {
      if ( *(_BYTE *)(*v12 + 1i64) == a1 )
      {
        if ( !(unsigned int)sub_140013A60((unsigned __int64 *)(*v12 + 2i64), (__int64)&v19, 0x49ui64) )
          break;
        ++v13;
      }
      v12 = (_QWORD *)v12[2];
    }
    while ( v12 );
    if ( v12 || v13 >= 3 )
    {
      result = 0;
    }
    else
    {
LABEL_20:
      be::report_custom_list((unsigned __int64)&v17, 0x4Bi64, &qword_140016368, 0x140016378i64);
      result = 0;
    }
  }
  else
  {
    be::report((__int64)&v17, 75i64);
    result = 1;
  }
  return result;
}
```