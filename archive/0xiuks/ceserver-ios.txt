Project Path: arc_0xiuks_ceserver-ios_8h969rxg

Source Tree:

```txt
arc_0xiuks_ceserver-ios_8h969rxg
├── LICENSE
├── LICENSES
│   └── LLVM.TXT
├── README.md
├── ceserver-ios
│   ├── jailbreak
│   │   ├── Makefile
│   │   ├── api.c
│   │   ├── api.h
│   │   ├── ceserver.c
│   │   ├── ceserver.h
│   │   ├── context.h
│   │   ├── control
│   │   ├── debugger.c
│   │   ├── debugger.h
│   │   ├── entitlements.plist
│   │   ├── porthelp.c
│   │   ├── porthelp.h
│   │   ├── symbols.c
│   │   └── symbols.h
│   └── jailed
│       ├── Makefile
│       ├── api.c
│       ├── api.h
│       ├── ceserver.c
│       ├── ceserver.h
│       ├── context.h
│       ├── control
│       ├── debugger.c
│       ├── debugger.h
│       ├── entitlements.plist
│       ├── porthelp.c
│       ├── porthelp.h
│       ├── symbols.c
│       └── symbols.h
├── images
│   ├── RTTI_viewer.png
│   ├── Stacktrace.png
│   └── Structure_dissect.png
└── plugin
    ├── ios_rtti
    │   ├── Makefile
    │   ├── ce_sdk
    │   │   ├── cepluginsdk.h
    │   │   ├── lauxlib.h
    │   │   ├── lua.h
    │   │   ├── luaconf.h
    │   │   └── lualib.h
    │   ├── ios_rtti_plugin.cpp
    │   ├── itanium_abi_rtti.h
    │   └── llvm
    │       ├── include
    │       │   └── llvm
    │       │       ├── Config
    │       │       │   └── llvm-config.h
    │       │       └── Demangle
    │       │           ├── Demangle.h
    │       │           ├── DemangleConfig.h
    │       │           ├── ItaniumDemangle.h
    │       │           ├── ItaniumNodes.def
    │       │           ├── StringViewExtras.h
    │       │           └── Utility.h
    │       └── lib
    │           └── Demangle
    │               └── ItaniumDemangle.cpp
    └── ios_stacktrace
        ├── Makefile
        ├── ce_sdk
        │   ├── cepluginsdk.h
        │   ├── lauxlib.h
        │   ├── lua.h
        │   ├── luaconf.h
        │   └── lualib.h
        └── ios_stacktrace_plugin.cpp

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 0xiuks

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`LICENSES/LLVM.TXT`:

```TXT
==============================================================================
The LLVM Project is under the Apache License v2.0 with LLVM Exceptions:
==============================================================================

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

    1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

    2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

    3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

    4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

    5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

    6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

    7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

    8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

    9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

    END OF TERMS AND CONDITIONS

    APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

    Copyright [yyyy] [name of copyright owner]

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.


---- LLVM Exceptions to the Apache 2.0 License ----

As an exception, if, as a result of your compiling your source code, portions
of this Software are embedded into an Object form of such source code, you
may redistribute such embedded portions in such Object form without complying
with the conditions of Sections 4(a), 4(b) and 4(d) of the License.

In addition, if you combine or link compiled forms of this Software with
software that is licensed under the GPLv2 ("Combined Software") and if a
court of competent jurisdiction determines that the patent provision (Section
3), the indemnity provision (Section 9) or other Section of the License
conflicts with the conditions of the GPLv2, you may retroactively and
prospectively choose to deem waived or otherwise exclude such Section(s) of
the License, but only in their entirety and only with respect to the Combined
Software.

==============================================================================
Software from third parties included in the LLVM Project:
==============================================================================
The LLVM Project contains third party software which is under different license
terms. All such code will be identified clearly using at least one of two
mechanisms:
1) It will be in a separate directory tree with its own `LICENSE.txt` or
   `LICENSE` file at the top containing the specific license and restrictions
   which apply to that software, or
2) It will contain specific license and restriction terms at the top of every
   file.

==============================================================================
Legacy LLVM License (https://llvm.org/docs/DeveloperPolicy.html#legacy):
==============================================================================
University of Illinois/NCSA
Open Source License

Copyright (c) 2003-2019 University of Illinois at Urbana-Champaign.
All rights reserved.

Developed by:

    LLVM Team

    University of Illinois at Urbana-Champaign

    http://llvm.org

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal with
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimers.

    * Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimers in the
      documentation and/or other materials provided with the distribution.

    * Neither the names of the LLVM Team, University of Illinois at
      Urbana-Champaign, nor the names of its contributors may be used to
      endorse or promote products derived from this Software without specific
      prior written permission.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
SOFTWARE.


```

`README.md`:

```md
# ceserver-ios

An iOS port of Cheat Engine's ceserver for jailed and jailbroken devices.  
Windows plugins add support for iOS stack traces and RTTI.  
It may contain bugs or be unoptimized. Feedback is welcome.

## Features
Memory search/read/write, breakpoint/watchpoint, pointer scan, instruction patching, register patching, symbols, etc.  
*Executable memory patching requires a jailbroken device.*


## Usage
#### Jailed
1. Inject the dylib into your target app IPA.
2. Sideload the IPA.
3. Launch the app (the server starts automatically).

#### Jailbreak
1. Copy `ceserver` to the device (e.g. `/var/jb/usr/bin`).
```bash
cd /var/jb/usr/bin
chmod 755 ceserver
./ceserver
```



### PC Connection
#### Wired connection (`recommended`)

```bash
iproxy 52736 52736
# In Cheat Engine, use Network and connect to:
127.0.0.1:52736
```

#### Wireless connection
```bash
# In Cheat Engine, use Network and connect to:
[device IP]:52736
```


## Plugins
Cheat Engine doesn't support iOS stack traces/RTTI natively, so these plugins are required for those features.  


Stacktrace (Main menu → Plugins → iOS-Stacktrace)  
When a breakpoint hits, click Refresh to update the list.
![Stacktrace](images/Stacktrace.png)

Structure Dissect (Memory viewer → Tools → Dissect data/structures, built-in)  
![Structure dissect](images/Structure_dissect.png)

RTTI Viewer (Main menu → Plugins → iOS-RTTI-Viewer)  
![RTTI viewer](images/RTTI_viewer.png)

## Components
- `ceserver-ios/jailbreak/`
  Standalone server binary for jailbreak devices.
- `ceserver-ios/jailed/`
  Dylib build for jailed/sideloaded apps.
- `plugin/ios_stacktrace/`
  Windows CE plugin for iOS stack traces.
- `plugin/ios_rtti/`
  Windows CE plugin for RTTI inspection (includes a small LLVM demangler subset).

## Credits
[Cheat Engine](https://github.com/cheat-engine/cheat-engine) : The original ceserver implementation.
## Licenses
[MIT License](./LICENSE)  
[LLVM](https://github.com/llvm/llvm-project) `LICENSES/LLVM.TXT`

```

`ceserver-ios/jailbreak/Makefile`:

```
TARGET := iphone:clang:latest:12.0
ARCHS := arm64
include $(THEOS)/makefiles/common.mk
TOOL_NAME = ceserver

ceserver_FILES = ceserver.c api.c debugger.c porthelp.c symbols.c
ceserver_CFLAGS += -fblocks
ceserver_CODESIGN_FLAGS = -Sentitlements.plist
ceserver_LIBRARIES = z

include $(THEOS_MAKE_PATH)/tool.mk

```

`ceserver-ios/jailbreak/api.c`:

```c
#include "api.h"

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dlfcn.h>
#include <limits.h>
#include <mach-o/loader.h>
#include <mach/mach_host.h>
#include <mach/vm_region.h>
#include <mach/mach_vm.h>
#include <pthread.h>
#include <sys/param.h>
#include <sys/sysctl.h>
#include <uuid/uuid.h>

#include "debugger.h"

extern kern_return_t mach_vm_read_overwrite(vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size,
                                            mach_vm_address_t data, mach_vm_size_t *outsize);
extern kern_return_t mach_vm_write(vm_map_t target_task, mach_vm_address_t address, vm_offset_t data, mach_msg_type_number_t dataCnt);

int debug_log(const char *format, ...)
{
  (void)format;
  return 0;
}

int getArchitecture(HANDLE hProcess)
{
  if (GetHandleType(hProcess) == htProcesHandle)
  {

    return 3;
  }

  return -1;
}

static int SearchHandleListProcessCallback(PProcessData data, int *pid)
{
  return (data->pid == *pid);
}

static int read_target(task_t task, mach_vm_address_t address, void *buf, size_t size)
{
  if (address == 0 || buf == NULL || size == 0)
    return 0;
  if (size > (size_t)INT_MAX)
    return 0;

  mach_vm_size_t outsize = 0;
  kern_return_t kr = mach_vm_read_overwrite(task, address, (mach_vm_size_t)size, (mach_vm_address_t)buf, &outsize);
  if (kr != KERN_SUCCESS)
    return 0;

  if (outsize > (mach_vm_size_t)INT_MAX)
    return 0;

  return (int)outsize;
}

static int read_target_exact(task_t task, mach_vm_address_t address, void *buf, size_t size)
{
  return read_target(task, address, buf, size) == (int)size;
}

static int is_macho64_magic(uint32_t magic)
{
  return (magic == MH_MAGIC_64) || (magic == MH_CIGAM_64);
}

static uint32_t bswap32_if_needed(uint32_t x, int swapped)
{
  return swapped ? __builtin_bswap32(x) : x;
}

static uint64_t bswap64_if_needed(uint64_t x, int swapped)
{
  return swapped ? __builtin_bswap64(x) : x;
}

typedef void *dyld_process_info;
typedef void *(*dyld_process_info_create_fn)(task_t task, uint64_t timestamp, kern_return_t *kernelError);
typedef void (^dyld_process_info_image_callback)(uint64_t machHeaderAddress, const uuid_t uuid, const char *path);
typedef void (*dyld_process_info_for_each_image_fn)(dyld_process_info info, dyld_process_info_image_callback callback);
typedef void (*dyld_process_info_release_fn)(dyld_process_info info);

typedef struct
{
  dyld_process_info_create_fn create;
  dyld_process_info_for_each_image_fn for_each_image;
  dyld_process_info_release_fn release;
} DyldSPI;

static DyldSPI dyld_spi = {0};
static pthread_once_t dyld_spi_once = PTHREAD_ONCE_INIT;

typedef struct
{
  uint64_t load_address;
  char *path;
} DyldImageInfo;

typedef struct
{
  DyldImageInfo *items;
  size_t count;
  size_t cap;
} DyldImageList;

typedef struct
{
  uint64_t *items;
  size_t count;
  size_t cap;
} AddressSet;

static void init_dyld_spi(void)
{
  dyld_spi.create = (dyld_process_info_create_fn)dlsym(RTLD_DEFAULT, "_dyld_process_info_create");
  dyld_spi.for_each_image = (dyld_process_info_for_each_image_fn)dlsym(RTLD_DEFAULT, "_dyld_process_info_for_each_image");
  dyld_spi.release = (dyld_process_info_release_fn)dlsym(RTLD_DEFAULT, "_dyld_process_info_release");
}

static void dyld_image_list_free(DyldImageList *list)
{
  if (!list || !list->items)
    return;

  for (size_t i = 0; i < list->count; i++)
    free(list->items[i].path);
  free(list->items);
  list->items = NULL;
  list->count = 0;
  list->cap = 0;
}

static int dyld_image_list_append(DyldImageList *list, uint64_t load_address, const char *path)
{
  if (!list)
    return 0;

  if (list->count >= list->cap)
  {
    size_t newcap = (list->cap == 0) ? 64 : list->cap * 2;
    void *newp = realloc(list->items, newcap * sizeof(DyldImageInfo));
    if (!newp)
      return 0;
    list->items = (DyldImageInfo *)newp;
    list->cap = newcap;
  }

  DyldImageInfo *entry = &list->items[list->count++];
  entry->load_address = load_address;
  entry->path = strdup(path);
  if (!entry->path)
    return 0;
  return 1;
}

static void address_set_free(AddressSet *set)
{
  if (!set)
    return;
  free(set->items);
  set->items = NULL;
  set->count = 0;
  set->cap = 0;
}

static int address_set_add(AddressSet *set, uint64_t addr)
{
  if (!set)
    return -1;

  for (size_t i = 0; i < set->count; i++)
  {
    if (set->items[i] == addr)
      return 0;
  }

  if (set->count >= set->cap)
  {
    size_t newcap = (set->cap == 0) ? 64 : set->cap * 2;
    void *newp = realloc(set->items, newcap * sizeof(uint64_t));
    if (!newp)
      return -1;
    set->items = (uint64_t *)newp;
    set->cap = newcap;
  }

  set->items[set->count++] = addr;
  return 1;
}

static int collect_dyld_spi_images(task_t task, DyldImageList *list)
{
  if (!list)
    return 0;

  pthread_once(&dyld_spi_once, init_dyld_spi);
  if (!dyld_spi.create || !dyld_spi.for_each_image || !dyld_spi.release)
    return 0;

  kern_return_t kr = KERN_FAILURE;
  dyld_process_info info = dyld_spi.create(task, 0, &kr);
  if (!info)
    return 0;

  __block int ok = 1;
  __block AddressSet seen = {0};
  __block DyldImageList *out = list;

  dyld_spi.for_each_image(info, ^(uint64_t machHeaderAddress, const uuid_t uuid, const char *path) {
    (void)uuid;
    if (!ok)
      return;
    uint64_t addr = machHeaderAddress;
    int add = address_set_add(&seen, addr);
    if (add <= 0)
    {
      if (add < 0)
        ok = 0;
      return;
    }
    if (!dyld_image_list_append(out, addr, path))
      ok = 0;
  });

  dyld_spi.release(info);
  address_set_free(&seen);

  if (!ok)
  {
    dyld_image_list_free(list);
    return 0;
  }

  return list->count > 0;
}

static uint64_t get_macho_image_size_64(task_t task, mach_vm_address_t base)
{
  struct mach_header_64 hdr;
  if (!read_target_exact(task, base, &hdr, sizeof(hdr)))
    return 0;

  if (!is_macho64_magic(hdr.magic))
    return 0;

  int swapped = (hdr.magic == MH_CIGAM_64);
  uint32_t ncmds = bswap32_if_needed(hdr.ncmds, swapped);
  uint32_t sizeofcmds = bswap32_if_needed(hdr.sizeofcmds, swapped);

  mach_vm_address_t cursor = base + sizeof(struct mach_header_64);
  mach_vm_address_t end = cursor + (mach_vm_address_t)sizeofcmds;
  if (end < cursor)
    return 0;

  uint64_t min_vmaddr = UINT64_MAX;
  uint64_t max_end = 0;


  if (ncmds > 4096)
    return 0;
  if (sizeofcmds > (16U * 1024U * 1024U))
    return 0;

  for (uint32_t i = 0; i < ncmds; i++)
  {
    struct load_command lc;
    if (cursor + sizeof(struct load_command) > end)
      return 0;

    if (!read_target_exact(task, cursor, &lc, sizeof(lc)))
      return 0;

    uint32_t cmd = bswap32_if_needed(lc.cmd, swapped);
    uint32_t cmdsize = bswap32_if_needed(lc.cmdsize, swapped);
    if (cmdsize < sizeof(struct load_command))
      return 0;
    if (cursor + cmdsize > end)
      return 0;

    if (cmd == LC_SEGMENT_64)
    {
      struct segment_command_64 seg;
      if (cmdsize < sizeof(struct segment_command_64))
        return 0;

      if (!read_target_exact(task, cursor, &seg, sizeof(seg)))
        return 0;


      if (strncmp(seg.segname, "__PAGEZERO", 16) != 0)
      {
        uint64_t vmaddr = bswap64_if_needed(seg.vmaddr, swapped);
        uint64_t vmsize = bswap64_if_needed(seg.vmsize, swapped);

        if (vmaddr < min_vmaddr)
          min_vmaddr = vmaddr;


        if (UINT64_MAX - vmaddr < vmsize)
          return 0;

        uint64_t endaddr = vmaddr + vmsize;
        if (endaddr > max_end)
          max_end = endaddr;
      }
    }

    cursor += cmdsize;
  }

  if (min_vmaddr == UINT64_MAX || max_end <= min_vmaddr)
    return 0;

  return max_end - min_vmaddr;
}

static int get_exec_path_sysctl(int pid, char *out, size_t outcap)
{
  if (outcap == 0)
    return 0;

  out[0] = 0;

  int mib[3] = {CTL_KERN, KERN_PROCARGS2, pid};
  size_t size = 0;
  if (sysctl(mib, 3, NULL, &size, NULL, 0) != 0 || size < sizeof(int))
    return 0;

  char *buf = (char *)malloc(size);
  if (!buf)
    return 0;

  if (sysctl(mib, 3, buf, &size, NULL, 0) != 0 || size < sizeof(int))
  {
    free(buf);
    return 0;
  }


  size_t pos = sizeof(int);
  while (pos < size && buf[pos] == '\0')
    pos++;

  size_t i = 0;
  while (pos < size && buf[pos] != '\0' && i + 1 < outcap)
    out[i++] = buf[pos++];
  out[i] = 0;

  free(buf);
  return i > 0;
}

static uint32_t vm_prot_to_page(uint32_t protectioninfo)
{
  
  int r = (protectioninfo & VM_PROT_READ) ? 1 : 0;
  int w = (protectioninfo & VM_PROT_WRITE) ? 1 : 0;
  int x = (protectioninfo & VM_PROT_EXECUTE) ? 1 : 0;

  if (r && w && x)
    return PAGE_EXECUTE_READWRITE;
  if (r && x)
    return PAGE_EXECUTE_READ;
  if (x)
    return PAGE_EXECUTE;
  if (r && w)
    return PAGE_READWRITE;
  if (w)
    return PAGE_READWRITE;
  if (r)
    return PAGE_READONLY;
  return PAGE_NOACCESS;
}

static uint32_t vm_info_to_type(const vm_region_submap_info_data_64_t *info)
{
#if defined(SM_PRIVATE) && defined(SM_COW) && defined(SM_SHARED)
  switch (info->share_mode)
  {
    case SM_PRIVATE:
    case SM_COW:
      return MEM_PRIVATE;
    case SM_SHARED:
    case SM_TRUESHARED:
#ifdef SM_SHARED_ALIASED
    case SM_SHARED_ALIASED:
#endif
      return MEM_MAPPED;
    default:

      return MEM_PRIVATE;
  }
#else
  (void)info;
  return MEM_PRIVATE;
#endif
}

static uint32_t windows_protection_to_vmprot(uint32_t windowsprotection)
{
  
  switch (windowsprotection)
  {
    case PAGE_NOACCESS:
      return VM_PROT_NONE;
    case PAGE_EXECUTE_READWRITE:
      return VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE;
    case PAGE_EXECUTE_READ:
      return VM_PROT_READ | VM_PROT_EXECUTE;
    case PAGE_EXECUTE:
      return VM_PROT_EXECUTE;
    case PAGE_READWRITE:
      return VM_PROT_READ | VM_PROT_WRITE;
    case PAGE_READONLY:
      return VM_PROT_READ;
    default:
      return 0;
  }
}

static pthread_once_t pagesize_once = PTHREAD_ONCE_INIT;
static uint64_t pagesize_cached = 0;

static void init_pagesize(void)
{
  long p = sysconf(_SC_PAGESIZE);
  if (p > 0)
  {
    uint64_t ps = (uint64_t)p;
    if ((ps & (ps - 1)) == 0)
    {
      pagesize_cached = ps;
      return;
    }
  }

  vm_size_t hostps = 0;
  mach_port_t host = mach_host_self();
  if (host_page_size(host, &hostps) == KERN_SUCCESS && hostps > 0)
  {
    uint64_t ps = (uint64_t)hostps;
    if ((ps & (ps - 1)) == 0)
    {
      pagesize_cached = ps;
      mach_port_deallocate(mach_task_self(), host);
      return;
    }
  }
  mach_port_deallocate(mach_task_self(), host);


  pagesize_cached = 4096;
}

static uint64_t get_page_size(void)
{
  pthread_once(&pagesize_once, init_pagesize);
  return pagesize_cached;
}


static void pageprot_to_perms(uint32_t pageprot, int shared, char perms[5])
{
  perms[0] = perms[1] = perms[2] = '-';
  perms[3] = shared ? 's' : 'p';

  switch (pageprot)
  {
    case PAGE_EXECUTE_READWRITE:
      perms[0] = 'r'; perms[1] = 'w'; perms[2] = 'x'; break;
    case PAGE_EXECUTE_READ:
      perms[0] = 'r'; perms[1] = '-'; perms[2] = 'x'; break;
    case PAGE_EXECUTE:
      perms[0] = '-'; perms[1] = '-'; perms[2] = 'x'; break;
    case PAGE_READWRITE:
      perms[0] = 'r'; perms[1] = 'w'; perms[2] = '-'; break;
    case PAGE_READONLY:
      perms[0] = 'r'; perms[1] = '-'; perms[2] = '-'; break;
    default:
      break;
  }
  perms[4] = 0;
}


static int query_leaf_region(task_t task,
                             mach_vm_address_t probe,
                             mach_vm_address_t *out_base,
                             mach_vm_size_t *out_size,
                             vm_region_submap_info_data_64_t *out_info)
{
  mach_vm_address_t want = probe;
  mach_vm_address_t addr = probe;
  natural_t depth = 0;

  while (1)
  {
    mach_vm_address_t q = addr;
    mach_vm_size_t vmsize = 0;
    vm_region_submap_info_data_64_t info;
    mach_msg_type_number_t info_count = VM_REGION_SUBMAP_INFO_COUNT_64;

    kern_return_t kr = mach_vm_region_recurse(task, &q, &vmsize, &depth, (vm_region_recurse_info_t)&info, &info_count);
    if (kr != KERN_SUCCESS)
      return 0;

    if (!info.is_submap)
    {
      *out_base = q;
      *out_size = vmsize;
      *out_info = info;
      return 1;
    }

    if (++depth > 64)
      return 0;


    if (vmsize != 0 && want >= q && want - q < vmsize)
      addr = want;
    else
      addr = q;
  }
}

int VirtualQueryEx(HANDLE hProcess, void *lpAddress, PRegionInfo rinfo, char *mapsline)
{
  if (mapsline)
    mapsline[0] = 0;

  if (GetHandleType(hProcess) != htProcesHandle)
    return 0;


  if (rinfo == NULL)
    return 0;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);

  uint64_t start = (uint64_t)(uintptr_t)lpAddress;
  uint64_t pagesize = get_page_size();
  if (pagesize == 0 || (pagesize & (pagesize - 1)) != 0)
    return 0;
  uint64_t pagemask = ~(pagesize - 1);
  uint64_t pagebase = start & pagemask;
  mach_vm_address_t probe = (mach_vm_address_t)pagebase;

  mach_vm_address_t region_base = 0;
  mach_vm_size_t vmsize = 0;
  vm_region_submap_info_data_64_t info;

  if (!query_leaf_region(p->task, probe, &region_base, &vmsize, &info))
    return 0;


  if ((uint64_t)region_base > pagebase)
  {
    rinfo->baseaddress = pagebase;
    rinfo->size = (uint64_t)region_base - pagebase;
    rinfo->protection = PAGE_NOACCESS;
    rinfo->type = 0;
    if (mapsline)
    {
      uint64_t region_start = (uint64_t)region_base;
      uint64_t region_size = (uint64_t)vmsize;
      if (UINT64_MAX - region_start < region_size)
        region_size = 0;
      uint64_t region_end = region_start + region_size;
      uint32_t p = vm_prot_to_page(info.protection);
      char perms[5];
      int shared = 0;
#if defined(SM_SHARED) && defined(SM_TRUESHARED)
      if (info.share_mode == SM_SHARED || info.share_mode == SM_TRUESHARED
#ifdef SM_SHARED_ALIASED
          || info.share_mode == SM_SHARED_ALIASED
#endif
      )
        shared = 1;
#endif
      pageprot_to_perms(p, shared, perms);

      snprintf(mapsline, 200, "%016llx-%016llx %s %016llx 00:00 0", (unsigned long long)region_start,
               (unsigned long long)region_end, perms, (unsigned long long)info.offset);
      mapsline[199] = 0;
    }
    return 1;
  }


  uint64_t region_start = (uint64_t)region_base;
  uint64_t region_size = (uint64_t)vmsize;
  if (UINT64_MAX - region_start < region_size)
    return 0;
  uint64_t region_end = region_start + region_size;
  if (region_end <= pagebase)
    return 0;

  rinfo->baseaddress = pagebase;
  rinfo->size = region_end - pagebase;
  rinfo->protection = vm_prot_to_page(info.protection);
  rinfo->type = vm_info_to_type(&info);

  if (mapsline)
  {
    uint32_t p = rinfo->protection;
    char perms[5];
    int shared = 0;
#if defined(SM_SHARED) && defined(SM_TRUESHARED)
    if (info.share_mode == SM_SHARED || info.share_mode == SM_TRUESHARED
#ifdef SM_SHARED_ALIASED
        || info.share_mode == SM_SHARED_ALIASED
#endif
    )
      shared = 1;
#endif
    pageprot_to_perms(p, shared, perms);

    snprintf(mapsline, 200, "%016llx-%016llx %s %016llx 00:00 0", (unsigned long long)region_start,
             (unsigned long long)region_end, perms, (unsigned long long)info.offset);
    mapsline[199] = 0;
  }

  return 1;
}


#define VQE_PAGEDONLY 1
#define VQE_DIRTYONLY 2
#define VQE_NOSHARED 4

int VirtualQueryExFull(HANDLE hProcess, uint32_t flags, RegionInfo **rinfo, uint32_t *count)
{
  if (!rinfo || !count)
    return 0;

  *rinfo = NULL;
  *count = 0;

  if (GetHandleType(hProcess) != htProcesHandle)
    return 0;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);

  uint64_t pagesize = get_page_size();
  if (pagesize == 0 || (pagesize & (pagesize - 1)) != 0)
    return 0;

  int max = 128;
  RegionInfo *list = (RegionInfo *)malloc(sizeof(RegionInfo) * (size_t)max);
  if (!list)
    return 0;

  uint32_t pos = 0;
  mach_vm_address_t probe = 0;

  while (1)
  {
    mach_vm_address_t query = probe;
    mach_vm_size_t vmsize = 0;
    vm_region_submap_info_data_64_t info;
    if (!query_leaf_region(p->task, query, &query, &vmsize, &info))
      goto vqfull_done;

    uint64_t region_start = (uint64_t)query;
    uint64_t region_size = (uint64_t)vmsize;
    if (UINT64_MAX - region_start < region_size)
      goto vqfull_done;


    if ((flags & VQE_PAGEDONLY) && info.pages_resident == 0)
    {
      if (vmsize == 0 || UINT64_MAX - (uint64_t)query < (uint64_t)vmsize)
        goto vqfull_done;
      probe = query + vmsize;
      continue;
    }
    if ((flags & VQE_DIRTYONLY) && info.pages_dirtied == 0)
    {
      if (vmsize == 0 || UINT64_MAX - (uint64_t)query < (uint64_t)vmsize)
        goto vqfull_done;
      probe = query + vmsize;
      continue;
    }


    if ((flags & VQE_NOSHARED) && vm_info_to_type(&info) == MEM_MAPPED)
    {

      if (vmsize == 0 || UINT64_MAX - (uint64_t)query < (uint64_t)vmsize)
        goto vqfull_done;
      probe = query + vmsize;
      continue;
    }


    if (vmsize == 0)
      goto vqfull_done;

    if (pos >= (uint32_t)max)
    {
      max *= 2;
      RegionInfo *newlist = (RegionInfo *)realloc(list, sizeof(RegionInfo) * (size_t)max);
      if (!newlist)
        goto vqfull_done;
      list = newlist;
    }

    list[pos].baseaddress = region_start;
    list[pos].size = region_size;
    list[pos].protection = vm_prot_to_page(info.protection);
    list[pos].type = vm_info_to_type(&info);
    pos++;


    if (UINT64_MAX - (uint64_t)query < (uint64_t)vmsize)
      goto vqfull_done;
    probe = query + vmsize;

    if (probe == 0)
      break;
  }

vqfull_done:
  if (pos == 0)
  {
    free(list);
    return 0;
  }

  *rinfo = list;
  *count = pos;
  return 1;
}

int ChangeMemoryProtection(HANDLE hProcess, uint64_t address, uint32_t size, uint32_t windowsprotection, uint32_t *oldprotection)
{
  if (oldprotection)
    *oldprotection = 0;

  if (GetHandleType(hProcess) != htProcesHandle)
    return 0;
  if (size == 0)
    return 0;









  // On iOS, setting RWX can drop execute due to W^X. Treat as success.
  if (windowsprotection == PAGE_EXECUTE_READWRITE)
    return 1;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);
  uint32_t vmprot = windows_protection_to_vmprot(windowsprotection);

  if (windowsprotection != PAGE_NOACCESS && vmprot == 0)
    return 0;

  if (oldprotection)
  {
    RegionInfo ri;
    if (VirtualQueryEx(hProcess, (void *)(uintptr_t)address, &ri, NULL))
      *oldprotection = ri.protection;
  }

  uint64_t ps = get_page_size();
  if (ps == 0 || (ps & (ps - 1)) != 0)
    return 0;


 
  if (vmprot & VM_PROT_WRITE)
    vmprot |= VM_PROT_COPY;


  
  uint64_t start = address & ~(ps - 1);
  if (UINT64_MAX - address < size)
    return 0;
  uint64_t end = address + size;
  uint64_t len64 = end - start;
  uint64_t rem = len64 & (ps - 1);
  if (rem)
  {
    if (UINT64_MAX - len64 < (ps - rem))
      return 0;
    len64 += (ps - rem);
  }

  mach_vm_size_t len = (mach_vm_size_t)len64;
  kern_return_t kr = mach_vm_protect(p->task, (mach_vm_address_t)start, len, FALSE, vmprot);
  return (kr == KERN_SUCCESS) ? 1 : 0;
}

int ReadProcessMemory(HANDLE hProcess, void *lpAddress, void *buffer, int size)
{
  if (GetHandleType(hProcess) != htProcesHandle)
    return 0;

  if (lpAddress == NULL || size <= 0 || buffer == NULL)
    return 0;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);

  return read_target(p->task, (mach_vm_address_t)lpAddress, buffer, (size_t)size);
}

int WriteProcessMemory(HANDLE hProcess, void *lpAddress, void *buffer, int size)
{
  if (GetHandleType(hProcess) != htProcesHandle)
    return 0;

  if (lpAddress == NULL || size <= 0 || buffer == NULL)
    return 0;
  if ((unsigned long)size > UINT32_MAX)
    return 0;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);
  mach_port_t task = p->task;


  kern_return_t kr = mach_vm_write(task, (mach_vm_address_t)lpAddress, (vm_offset_t)(uintptr_t)buffer,
                                   (mach_msg_type_number_t)(uint32_t)size);
  if (kr == KERN_SUCCESS)
    return size;


  uint64_t ps = get_page_size();
  if (ps == 0 || (ps & (ps - 1)) != 0)
    return 0;

  uint64_t start = (uint64_t)(uintptr_t)lpAddress;
  uint64_t end;
  if (UINT64_MAX - start < (uint64_t)size)
    return 0;
  end = start + (uint64_t)size;

  uint64_t page_start = start & ~(ps - 1);
  uint64_t page_end = (end + (ps - 1)) & ~(ps - 1);
  uint64_t page_count = (page_end - page_start) / ps;

  if (page_count == 0 || page_count > SIZE_MAX / sizeof(uint32_t))
    return 0;

  uint32_t *orig_prot = (uint32_t *)malloc((size_t)page_count * sizeof(uint32_t));
  if (!orig_prot)
    return 0;

  mach_vm_address_t cursor = (mach_vm_address_t)page_start;
  uint64_t idx = 0;
  int ok = 1;

  while (cursor < (mach_vm_address_t)page_end)
  {
    mach_vm_address_t rbase = 0;
    mach_vm_size_t rsize = 0;
    vm_region_submap_info_data_64_t info;

    if (!query_leaf_region(task, cursor, &rbase, &rsize, &info))
    {
      ok = 0;
      break;
    }

    orig_prot[idx] = info.protection;

    uint32_t newprot = info.protection | VM_PROT_READ | VM_PROT_WRITE | VM_PROT_COPY;
    mach_vm_address_t ap_base = cursor;
    mach_vm_size_t ap_len = (mach_vm_size_t)ps;

    if (mach_vm_protect(task, ap_base, ap_len, FALSE, newprot) != KERN_SUCCESS)
    {
      ok = 0;
      break;
    }

    if (UINT64_MAX - (uint64_t)cursor < ps)
    {
      ok = 0;
      break;
    }
    cursor += ps;
    idx++;
  }


  if (ok)
    kr = mach_vm_write(task, (mach_vm_address_t)lpAddress, (vm_offset_t)(uintptr_t)buffer,
                       (mach_msg_type_number_t)(uint32_t)size);


  if (idx > 0)
  {
    cursor = (mach_vm_address_t)page_start;
    for (uint64_t i = 0; i < idx; i++)
    {
      mach_vm_protect(task, cursor, (mach_vm_size_t)ps, FALSE, orig_prot[i]);
      if (UINT64_MAX - (uint64_t)cursor < ps)
        break;
      cursor += ps;
    }
  }

  free(orig_prot);

  if (!ok || kr != KERN_SUCCESS)
    return 0;


  if (idx > 0)
  {
    int state = MATTR_VAL_ICACHE_FLUSH;
    vm_address_t cache_base = (vm_address_t)page_start;
    vm_size_t cache_len = (vm_size_t)(page_end - page_start);
    vm_machine_attribute(task, cache_base, cache_len, MATTR_CACHE, &state);
  }
  return size;
}

HANDLE OpenProcess(DWORD pid)
{
  int handle = SearchHandleList(htProcesHandle, (HANDLESEARCHCALLBACK)SearchHandleListProcessCallback, &pid);
  if (handle)
  {
    PProcessData p = (PProcessData)GetPointerFromHandle(handle);
    p->ReferenceCount++;
    return handle;
  }

  mach_port_t task = MACH_PORT_NULL;
  kern_return_t err = task_for_pid(mach_task_self(), pid, &task);
  if (err != KERN_SUCCESS)
  {
    debug_log("task_for_pid(%d) failed: %d\n", pid, err);
    return 0;
  }

  PProcessData p = (PProcessData)malloc(sizeof(ProcessData));
  if (!p)
  {
    debug_log("OpenProcess: malloc failed for ProcessData\n");
    mach_port_deallocate(mach_task_self(), task);
    return 0;
  }

  memset(p, 0, sizeof(ProcessData));
  p->ReferenceCount = 1;
  p->pid = (int)pid;
  p->is64bit = 1;
  p->task = task;

  HANDLE h = CreateHandleFromPointer(p, htProcesHandle);
  if (!h)
  {
    mach_port_deallocate(mach_task_self(), task);
    free(p);
    return 0;
  }

  return h;
}

HANDLE CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID)
{
  if (dwFlags & TH32CS_SNAPPROCESS)
  {
    PProcessList pl = NULL;
    struct kinfo_proc *result = NULL;
    int max = 2048;
    int ok = 0;

    size_t length = 0;
    static const int name[] = {CTL_KERN, KERN_PROC, KERN_PROC_ALL, 0};

    pl = (PProcessList)malloc(sizeof(ProcessList));
    if (!pl)
      goto cleanup;

    memset(pl, 0, sizeof(ProcessList));
    pl->ReferenceCount = 1;
    pl->processCount = 0;
    pl->processList = (PProcessListEntry)malloc(sizeof(ProcessListEntry) * max);
    if (!pl->processList)
      goto cleanup;


    int gotList = 0;
    for (int attempt = 0; attempt < 3; attempt++)
    {
      free(result);
      result = NULL;
      length = 0;

      if (sysctl((int *)name, (sizeof(name) / sizeof(*name)) - 1, NULL, &length, NULL, 0) == -1)
      {
        debug_log("sysctl(KERN_PROC_ALL) size failed: %d\n", errno);
        goto cleanup;
      }

      result = (struct kinfo_proc *)malloc(length);
      if (result == NULL)
        goto cleanup;

      if (sysctl((int *)name, (sizeof(name) / sizeof(*name)) - 1, result, &length, NULL, 0) == 0)
      {
        gotList = 1;
        break;
      }


      if (errno != ENOMEM)
      {
        debug_log("sysctl(KERN_PROC_ALL) read failed: %d\n", errno);
        goto cleanup;
      }
    }

    if (!gotList || !result)
      goto cleanup;

    size_t procCount = length / sizeof(struct kinfo_proc);
    for (size_t i = 0; i < procCount; i++)
    {
      int pid = result[i].kp_proc.p_pid;
      char pathbuf[PATH_MAX];
      memset(pathbuf, 0, sizeof(pathbuf));
      const char *procname = get_exec_path_sysctl(pid, pathbuf, sizeof(pathbuf)) ? pathbuf : result[i].kp_proc.p_comm;

      pl->processList[pl->processCount].PID = pid;
      pl->processList[pl->processCount].ProcessName = strdup(procname);
      if (!pl->processList[pl->processCount].ProcessName)
        continue;

      pl->processCount++;

      if (pl->processCount >= max)
      {
        max *= 2;
        void *newp = realloc(pl->processList, (size_t)max * sizeof(ProcessListEntry));
        if (!newp)
          break;
        pl->processList = (PProcessListEntry)newp;
      }
    }

    ok = 1;

  cleanup:
    if (result)
      free(result);

    if (!ok)
    {
      if (pl)
      {
        if (pl->processList)
        {
          for (int i = 0; i < pl->processCount; i++)
            free(pl->processList[i].ProcessName);
          free(pl->processList);
        }
        free(pl);
      }

      return 0;
    }

    HANDLE hs = CreateHandleFromPointer(pl, htTHSProcess);
    if (!hs)
    {
      for (int i = 0; i < pl->processCount; i++)
        free(pl->processList[i].ProcessName);
      free(pl->processList);
      free(pl);
      return 0;
    }

    return hs;
  }

  if ((dwFlags & TH32CS_SNAPMODULE) || (dwFlags & TH32CS_SNAPFIRSTMODULE))
  {
    int max = 64;
    PModuleList ml = (PModuleList)malloc(sizeof(ModuleList));
    if (!ml)
      return 0;
    memset(ml, 0, sizeof(ModuleList));

    ml->ReferenceCount = 1;
    ml->moduleCount = 0;
    ml->moduleList = (PModuleListEntry)malloc(sizeof(ModuleListEntry) * max);
    if (!ml->moduleList)
    {
      free(ml);
      return 0;
    }

    HANDLE pHandle = OpenProcess(th32ProcessID);
    if (!pHandle)
    {
      free(ml->moduleList);
      free(ml);
      return 0;
    }
    PProcessData p = (PProcessData)GetPointerFromHandle(pHandle);

    char mainpath[PATH_MAX];
    memset(mainpath, 0, sizeof(mainpath));
    get_exec_path_sysctl(th32ProcessID, mainpath, sizeof(mainpath));

    DyldImageList images;
    memset(&images, 0, sizeof(images));
    if (!collect_dyld_spi_images(p->task, &images))
    {
      dyld_image_list_free(&images);
      CloseHandle(pHandle);
      free(ml->moduleList);
      free(ml);
      return 0;
    }

    size_t imageCount = images.count;
    if (imageCount == 0)
    {
      dyld_image_list_free(&images);
      CloseHandle(pHandle);
      free(ml->moduleList);
      free(ml);
      return 0;
    }

    size_t firstIndex = 0;
    if ((dwFlags & TH32CS_SNAPFIRSTMODULE) && mainpath[0])
    {
      for (size_t i = 0; i < imageCount; i++)
      {
        if (strcmp(images.items[i].path, mainpath) == 0)
        {
          firstIndex = i;
          break;
        }
      }
    }

    for (size_t ii = 0; ii < imageCount; ii++)
    {
      size_t i = (firstIndex + ii) % imageCount;

      uint64_t base = images.items[i].load_address;
      const char *pathbuf = images.items[i].path;

      if (ml->moduleCount >= max)
      {
        int newmax = max * 2;
        void *newp = realloc(ml->moduleList, sizeof(ModuleListEntry) * (size_t)newmax);
        if (!newp)
          break;
        ml->moduleList = (PModuleListEntry)newp;
        max = newmax;
      }

      int part = 0;
      for (int j = ml->moduleCount - 1; j >= 0; j--)
      {
        if (strcmp(ml->moduleList[j].moduleName, pathbuf) == 0)
        {
          part = ml->moduleList[j].part + 1;
          break;
        }
      }

      PModuleListEntry mle = &ml->moduleList[ml->moduleCount];
      memset(mle, 0, sizeof(*mle));
      mle->moduleName = strdup(pathbuf);
      if (!mle->moduleName)
        continue;
      mle->baseAddress = (unsigned long long)base;
      mle->fileOffset = 0;
      {
        uint64_t s64 = get_macho_image_size_64(p->task, (mach_vm_address_t)base);


      mle->moduleSize = (s64 > (uint64_t)INT_MAX) ? INT_MAX : (int)s64;
      }
      mle->part = part;
      mle->is64bit = 1;

      ml->moduleCount++;

      if (dwFlags & TH32CS_SNAPFIRSTMODULE)
        break;
    }

    dyld_image_list_free(&images);
    CloseHandle(pHandle);

    HANDLE hm = CreateHandleFromPointer(ml, htTHSModule);
    if (!hm)
    {
      for (int i = 0; i < ml->moduleCount; i++)
        free(ml->moduleList[i].moduleName);
      free(ml->moduleList);
      free(ml);
      return 0;
    }

    return hm;
  }

  debug_log("Unhandled toolhelp32snapshot flags: %x\n", dwFlags);
  return 0;
}

BOOL Process32Next(HANDLE hSnapshot, PProcessListEntry processentry)
{
  if (GetHandleType(hSnapshot) == htTHSProcess)
  {
    PProcessList pl = (PProcessList)GetPointerFromHandle(hSnapshot);

    if (pl->processListIterator < pl->processCount)
    {
      processentry->PID = pl->processList[pl->processListIterator].PID;
      processentry->ProcessName = pl->processList[pl->processListIterator].ProcessName;
      pl->processListIterator++;
      return TRUE;
    }

    return FALSE;
  }

  return FALSE;
}

BOOL Process32First(HANDLE hSnapshot, PProcessListEntry processentry)
{
  if (GetHandleType(hSnapshot) == htTHSProcess)
  {
    PProcessList pl = (PProcessList)GetPointerFromHandle(hSnapshot);
    pl->processListIterator = 0;
    return Process32Next(hSnapshot, processentry);
  }

  return FALSE;
}

BOOL Module32Next(HANDLE hSnapshot, PModuleListEntry moduleentry)
{
  if (GetHandleType(hSnapshot) == htTHSModule)
  {
    PModuleList ml = (PModuleList)GetPointerFromHandle(hSnapshot);
    if (ml->moduleListIterator < ml->moduleCount)
    {
      *moduleentry = ml->moduleList[ml->moduleListIterator];
      ml->moduleListIterator++;
      return TRUE;
    }
    return FALSE;
  }
  return FALSE;
}

BOOL Module32First(HANDLE hSnapshot, PModuleListEntry moduleentry)
{
  if (GetHandleType(hSnapshot) == htTHSModule)
  {
    PModuleList ml = (PModuleList)GetPointerFromHandle(hSnapshot);
    ml->moduleListIterator = 0;
    return Module32Next(hSnapshot, moduleentry);
  }
  return FALSE;
}

void CloseHandle(HANDLE h)
{
  handleType ht = GetHandleType(h);

  if (ht == htTHSProcess)
  {
    PProcessList pl = (PProcessList)GetPointerFromHandle(h);
    pl->ReferenceCount--;
    if (pl->ReferenceCount <= 0)
    {
      for (int i = 0; i < pl->processCount; i++)
        free(pl->processList[i].ProcessName);
      free(pl->processList);
      free(pl);
      RemoveHandle(h);
    }
  }
  else if (ht == htTHSModule)
  {
    PModuleList ml = (PModuleList)GetPointerFromHandle(h);
    ml->ReferenceCount--;
    if (ml->ReferenceCount <= 0)
    {
      for (int i = 0; i < ml->moduleCount; i++)
        free(ml->moduleList[i].moduleName);
      free(ml->moduleList);
      free(ml);
      RemoveHandle(h);
    }
  }
  else if (ht == htProcesHandle)
  {
    PProcessData pd = (PProcessData)GetPointerFromHandle(h);
    pd->ReferenceCount--;
    if (pd->ReferenceCount <= 0)
    {
      if (pd->debuggerData)
        StopDebug(h);
      if (pd->task != MACH_PORT_NULL)
        mach_port_deallocate(mach_task_self(), pd->task);
      free(pd);
      RemoveHandle(h);
    }
  }
  else
  {
    RemoveHandle(h);
  }
}

void initAPI(void)
{

}

```

`ceserver-ios/jailbreak/api.h`:

```h

#ifndef API_H_
#define API_H_

#include <stdint.h>

#include <mach/mach.h>
#include <mach-o/dyld_images.h>
#include <stddef.h>

#include "porthelp.h"

typedef struct
{
  unsigned long long baseAddress;
  uint32_t fileOffset;
  int part;
  int is64bit;
  int moduleSize;
  char *moduleName;
} ModuleListEntry, *PModuleListEntry;

typedef struct
{
  int ReferenceCount;
  int moduleListIterator;
  int moduleCount;
  PModuleListEntry moduleList;
} ModuleList, *PModuleList;

typedef struct
{
  int PID;
  char *ProcessName;
} ProcessListEntry, *PProcessListEntry;

typedef struct
{
  int ReferenceCount;
  int processListIterator;
  int processCount;
  PProcessListEntry processList;
} ProcessList, *PProcessList;

typedef struct
{
  int ReferenceCount;
  int pid;
  int is64bit;
  mach_port_t task;
  void *debuggerData;
} ProcessData, *PProcessData;

typedef struct
{
  uint64_t baseaddress;
  uint64_t size;
  uint32_t protection;
  uint32_t type;
} RegionInfo, *PRegionInfo;

int debug_log(const char *format, ...);

void initAPI(void);

HANDLE CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
BOOL Process32First(HANDLE hSnapshot, PProcessListEntry processentry);
BOOL Process32Next(HANDLE hSnapshot, PProcessListEntry processentry);
BOOL Module32First(HANDLE hSnapshot, PModuleListEntry moduleentry);
BOOL Module32Next(HANDLE hSnapshot, PModuleListEntry moduleentry);
void CloseHandle(HANDLE h);

HANDLE OpenProcess(DWORD pid);
int getArchitecture(HANDLE hProcess);

int ReadProcessMemory(HANDLE hProcess, void *lpAddress, void *buffer, int size);
int WriteProcessMemory(HANDLE hProcess, void *lpAddress, void *buffer, int size);

int VirtualQueryEx(HANDLE hProcess, void *lpAddress, PRegionInfo rinfo, char *mapsline);
int VirtualQueryExFull(HANDLE hProcess, uint32_t flags, RegionInfo **rinfo, uint32_t *count);
int ChangeMemoryProtection(HANDLE hProcess, uint64_t address, uint32_t size, uint32_t windowsprotection, uint32_t *oldprotection);

#endif

```

`ceserver-ios/jailbreak/ceserver.c`:

```c
#include <errno.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <pthread.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <signal.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <sys/types.h>
#include <unistd.h>

#include <zlib.h>

#include "api.h"
#include "ceserver.h"
#include "debugger.h"
#include "porthelp.h"
#include "symbols.h"

#define CESERVERVERSION 6
#ifndef MSG_MORE
#define MSG_MORE 0
#endif

static char versionstring[] = "CHEATENGINE Network 2.3";
static char ceserverpath[] = ".";

__thread char *threadname;
__thread int isDebuggerThread;
__thread int debugfd;

static int can_alloc_size(size_t a, size_t b)
{
  return a <= SIZE_MAX - b;
}

ssize_t recvall(int s, void *buf, size_t size, int flags)
{
  ssize_t totalreceived = 0;
  ssize_t sizeleft = (ssize_t)size;
  unsigned char *buffer = (unsigned char *)buf;

  flags |= MSG_WAITALL;

  while (sizeleft > 0)
  {
    ssize_t i = recv(s, &buffer[totalreceived], (size_t)sizeleft, flags);

    if (i == 0)
      return 0;

    if (i == -1)
    {
      if (errno == EINTR)
        continue;
      return -1;
    }

    totalreceived += i;
    sizeleft -= i;
  }

  return totalreceived;
}

ssize_t sendall(int s, void *buf, size_t size, int flags)
{
  ssize_t totalsent = 0;
  ssize_t sizeleft = (ssize_t)size;
  const unsigned char *buffer = (const unsigned char *)buf;

  while (sizeleft > 0)
  {
    ssize_t i = send(s, &buffer[totalsent], (size_t)sizeleft, flags);
    if (i == 0)
      return 0;
    if (i == -1)
    {
      if (errno == EINTR)
        continue;
      return -1;
    }
    totalsent += i;
    sizeleft -= i;
  }

  return totalsent;
}

ssize_t sendstring16(int s, char *str, int flags)
{
  uint16_t l;
  if (str)
    l = (uint16_t)strlen(str);
  else
    l = 0;

  sendall(s, &l, sizeof(l), l ? MSG_MORE : flags);
  if (l)
    sendall(s, str, l, flags);

  return l;
}

char *receivestring16(int s)
{
  uint16_t l = 0;
  if (recvall(s, &l, sizeof(l), 0) <= 0)
    return NULL;

  if (l == 0)
    return NULL;

  char *str = (char *)malloc((size_t)l + 1);
  if (!str)
    return NULL;

  if (recvall(s, str, l, 0) <= 0)
  {
    free(str);
    return NULL;
  }

  str[l] = 0;
  return str;
}

int DispatchCommand(int currentsocket, unsigned char command)
{
  switch (command)
  {
    case CMD_GETVERSION:
    {
      int versionsize = (int)strlen(versionstring);
      PCeVersion v = (PCeVersion)malloc(sizeof(CeVersion) + versionsize);
      v->stringsize = (unsigned char)versionsize;
      v->version = CESERVERVERSION;
      memcpy((char *)v + sizeof(CeVersion), versionstring, (size_t)versionsize);
      sendall(currentsocket, v, sizeof(CeVersion) + (size_t)versionsize, 0);
      free(v);
      break;
    }

    case CMD_SET_CONNECTION_NAME:
    {
      uint32_t namelength;
      if (recvall(currentsocket, &namelength, sizeof(namelength), 0) > 0)
      {
        char *name = (char *)malloc((size_t)namelength + 1);
        if (recvall(currentsocket, name, namelength, 0) <= 0)
        {
          free(name);
          break;
        }
        name[namelength] = 0;
        free(threadname);
        threadname = name;
      }
      break;
    }

    case CMD_GETABI:
    {
      unsigned char abi = 1;
      sendall(currentsocket, &abi, sizeof(abi), 0);
      break;
    }

    case CMD_GETARCHITECTURE:
    {
      unsigned char arch = 3;
      HANDLE h;
      if (recvall(currentsocket, &h, sizeof(h), 0) > 0)
      {
        int a = getArchitecture(h);
        if (a >= 0)
          arch = (unsigned char)a;
      }
      sendall(currentsocket, &arch, sizeof(arch), 0);
      break;
    }

    case CMD_GETOPTIONS:
    {

      uint16_t count = 0;
      sendall(currentsocket, &count, sizeof(count), 0);
      break;
    }

    case CMD_GETCESERVERPATH:
    {
      sendstring16(currentsocket, ceserverpath, 0);
      break;
    }

    case CMD_ISANDROID:
    {
      unsigned char r = 0;
      sendall(currentsocket, &r, sizeof(r), 0);
      break;
    }

    case CMD_OPENPROCESS:
    {
      int pid = 0;
      if (recvall(currentsocket, &pid, sizeof(pid), 0) > 0)
      {
        int processhandle = (int)OpenProcess((DWORD)pid);
        sendall(currentsocket, &processhandle, sizeof(processhandle), 0);
      }
      break;
    }

    case CMD_STARTDEBUG:
    {
      HANDLE h;
      if (recvall(currentsocket, &h, sizeof(h), MSG_WAITALL) > 0)
      {
        int r;
        debug_log("Calling StartDebug(%d)\n", h);
        r = StartDebug(h);
        sendall(currentsocket, &r, sizeof(r), 0);

        if (r)
        {
          isDebuggerThread = h;
          debugfd = GetDebugPort(h);
        }
      }
      break;
    }

    case CMD_WAITFORDEBUGEVENT:
    {
      struct
      {
        HANDLE pHandle;
        int timeout;
      } wfd;

      if (recvall(currentsocket, &wfd, sizeof(wfd), MSG_WAITALL) > 0)
      {
        int r;
        DebugEvent event;
        memset(&event, 0, sizeof(event));

        r = WaitForDebugEvent(wfd.pHandle, &event, wfd.timeout);
        sendall(currentsocket, &r, sizeof(r), r ? MSG_MORE : 0);

        if (r)
        {
          if (event.debugevent == SIGTRAP)
          {
            debug_log("!!!SIGTRAP!!!\n");
            debug_log("event.address=%llx\n", event.address);
          }

          sendall(currentsocket, &event, sizeof(event), 0);
        }
      }
      break;
    }

    case CMD_CONTINUEFROMDEBUGEVENT:
    {
      struct
      {
        HANDLE pHandle;
        int tid;
        int ignore;
      } cfd;

      if (recvall(currentsocket, &cfd, sizeof(cfd), MSG_WAITALL) > 0)
      {
        int r;
        r = ContinueFromDebugEvent(cfd.pHandle, cfd.tid, cfd.ignore);
        sendall(currentsocket, &r, sizeof(r), 0);
      }
      break;
    }

    case CMD_SETBREAKPOINT:
    {
      CeSetBreapointInput sb;

      debug_log("CMD_SETBREAKPOINT. sizeof(sb)=%d\n", (int)sizeof(sb));

      if (recvall(currentsocket, &sb, sizeof(sb), MSG_WAITALL) > 0)
      {
        int r;

        debug_log("Calling SetBreakpoint\n");
        r = SetBreakpoint(sb.hProcess, sb.tid, sb.debugreg, (void *)sb.Address, sb.bptype, sb.bpsize);
        debug_log("SetBreakpoint returned %d\n", r);
        sendall(currentsocket, &r, sizeof(r), 0);
      }
      break;
    }

    case CMD_REMOVEBREAKPOINT:
    {
      CeRemoveBreapointInput rb;

      if (recvall(currentsocket, &rb, sizeof(rb), MSG_WAITALL) > 0)
      {
        int r;

        debug_log("%s: Calling RemoveBreakpoint\n", threadname ? threadname : "thread");
        r = RemoveBreakpoint(rb.hProcess, rb.tid, rb.debugreg, rb.wasWatchpoint);
        debug_log("RemoveBreakpoint returned: %d\n", r);
        sendall(currentsocket, &r, sizeof(r), 0);
      }
      break;
    }

    case CMD_GETTHREADCONTEXT:
    {
#pragma pack(1)
      struct
      {
        HANDLE hProcess;
        uint32_t tid;
      } gtc;
#pragma pack()

      CONTEXT Context;
      uint32_t result;

      debug_log("CMD_GETTHREADCONTEXT:\n");

      recvall(currentsocket, &gtc, sizeof(gtc), MSG_WAITALL);

      debug_log("Going to call GetThreadContext(%d, %d, %p)\n", gtc.hProcess, gtc.tid, &Context);
      memset(&Context, 0, sizeof(Context));

      result = GetThreadContext(gtc.hProcess, gtc.tid, &Context);

      debug_log("result=%d\n", result);

      if (result)
      {
        debug_log("Context.structsize=%d\n", Context.structsize);
        uint32_t structsize = Context.structsize;
        sendall(currentsocket, &result, sizeof(result), MSG_MORE);
        sendall(currentsocket, &structsize, sizeof(structsize), MSG_MORE);
        sendall(currentsocket, &Context, structsize, 0);
      }
      else
      {
        sendall(currentsocket, &result, sizeof(result), 0);
      }

      break;
    }

    case CMD_SETTHREADCONTEXT:
    {
#pragma pack(1)
      struct
      {
        HANDLE hProcess;
        uint32_t tid;
        uint32_t structsize;
      } stc;
#pragma pack()

      uint32_t result;
      PCONTEXT c;

      debug_log("CMD_SETTHREADCONTEXT:\n");

      recvall(currentsocket, &stc, sizeof(stc), MSG_WAITALL);
      debug_log("hProcess=%d tid=%d structsize=%d\n", stc.hProcess, stc.tid, stc.structsize);

      c = (PCONTEXT)malloc(stc.structsize);
      recvall(currentsocket, c, stc.structsize, MSG_WAITALL);

      debug_log("received a context with data: structsize=%d type=%d\n", c->structsize, c->type);
      debug_log("Going to call SetThreadContext(%d, %d, %p)\n", stc.hProcess, stc.tid, c);

      result = SetThreadContext(stc.hProcess, stc.tid, c);
      free(c);

      debug_log("result=%d\n", result);
      sendall(currentsocket, &result, sizeof(result), 0);

      break;
    }

    case CMD_SUSPENDTHREAD:
    {
      CeSuspendThreadInput st;

      if (recvall(currentsocket, &st, sizeof(st), MSG_WAITALL) > 0)
      {
        int r;
        r = SuspendThread(st.hProcess, st.tid);
        sendall(currentsocket, &r, sizeof(r), 0);
      }
      break;
    }

    case CMD_RESUMETHREAD:
    {
      CeResumeThreadInput rt;

      if (recvall(currentsocket, &rt, sizeof(rt), MSG_WAITALL) > 0)
      {
        int r;
        r = ResumeThread(rt.hProcess, rt.tid);
        sendall(currentsocket, &r, sizeof(r), 0);
      }
      break;
    }

    case CMD_GETREGIONINFO:
    case CMD_VIRTUALQUERYEX:
    {
      CeVirtualQueryExInput c;
      if (recvall(currentsocket, &c, sizeof(c), 0) > 0)
      {
        RegionInfo rinfo;
        CeVirtualQueryExOutput o;
        memset(&rinfo, 0, sizeof(rinfo));
        memset(&o, 0, sizeof(o));

        char mapsline[200];
        mapsline[0] = 0;

        if (command == CMD_VIRTUALQUERYEX)
          o.result = (uint8_t)VirtualQueryEx((HANDLE)c.handle, (void *)(uintptr_t)c.baseaddress, &rinfo, NULL);
        else
          o.result = (uint8_t)VirtualQueryEx((HANDLE)c.handle, (void *)(uintptr_t)c.baseaddress, &rinfo, mapsline);

        o.protection = rinfo.protection;
        o.type = rinfo.type;
        o.baseaddress = rinfo.baseaddress;
        o.size = rinfo.size;

        sendall(currentsocket, &o, sizeof(o), 0);

        if (command == CMD_GETREGIONINFO)
        {
          uint8_t size = (uint8_t)strlen(mapsline);
          sendall(currentsocket, &size, sizeof(size), 0);
          if (size)
            sendall(currentsocket, mapsline, size, 0);
        }
      }
      break;
    }

    case CMD_CREATETOOLHELP32SNAPSHOT:
    {
      CeCreateToolhelp32Snapshot params;
      if (recvall(currentsocket, &params, sizeof(params), 0) > 0)
      {
        HANDLE result = CreateToolhelp32Snapshot(params.dwFlags, params.th32ProcessID);
        sendall(currentsocket, &result, sizeof(result), 0);
      }
      break;
    }

    case CMD_CREATETOOLHELP32SNAPSHOTEX:
    {
      CeCreateToolhelp32Snapshot params;
      if (recvall(currentsocket, &params, sizeof(params), 0) > 0)
      {
        HANDLE r = CreateToolhelp32Snapshot(params.dwFlags, params.th32ProcessID);

        if ((params.dwFlags & TH32CS_SNAPTHREAD) == TH32CS_SNAPTHREAD)
        {


          int n = 0;
          sendall(currentsocket, &n, sizeof(n), 0);

          if (r)
            CloseHandle(r);
        }
        else if ((params.dwFlags & TH32CS_SNAPMODULE) == TH32CS_SNAPMODULE)
        {
          ModuleListEntry me;
          char *outputstream = (char *)malloc(65536);
          int pos = 0;
          if (outputstream)
            memset(outputstream, 0, 65536);

          if (outputstream && r && Module32First(r, &me))
          {
            do
            {
              int namelen = (int)strlen(me.moduleName);
              if ((pos + (int)sizeof(CeModuleEntry) + namelen) > 65536)
              {
                sendall(currentsocket, outputstream, (size_t)pos, 0);
                pos = 0;
              }

              PCeModuleEntry m = (PCeModuleEntry)&outputstream[pos];
              m->modulebase = (int64_t)me.baseAddress;
              m->modulesize = me.moduleSize;
              m->modulefileoffset = me.fileOffset;
              m->modulenamesize = namelen;
              m->modulepart = me.part;
              m->result = 1;

              memcpy((char *)m + sizeof(CeModuleEntry), me.moduleName, (size_t)namelen);
              pos += (int)sizeof(CeModuleEntry) + namelen;
            } while (Module32Next(r, &me));
          }

          if (pos)
            sendall(currentsocket, outputstream, (size_t)pos, 0);

          CeModuleEntry eol;
          memset(&eol, 0, sizeof(eol));
          eol.result = 0;
          eol.modulenamesize = 0;
          sendall(currentsocket, &eol, sizeof(eol), 0);

          if (outputstream)
            free(outputstream);
          if (r)
            CloseHandle(r);
        }
        else
        {
          sendall(currentsocket, &r, sizeof(r), 0);
        }
      }
      break;
    }

    case CMD_PROCESS32FIRST:
    case CMD_PROCESS32NEXT:
    {
      HANDLE toolhelpsnapshot;
      if (recvall(currentsocket, &toolhelpsnapshot, sizeof(toolhelpsnapshot), 0) > 0)
      {
        ProcessListEntry pe;
        BOOL result = (command == CMD_PROCESS32FIRST) ? Process32First(toolhelpsnapshot, &pe) : Process32Next(toolhelpsnapshot, &pe);

        CeProcessEntry *r;
        int size;
        if (result)
        {
          int namelen = (int)strlen(pe.ProcessName);
          size = (int)sizeof(CeProcessEntry) + namelen;
          r = (PCeProcessEntry)malloc((size_t)size);
          r->processnamesize = namelen;
          r->pid = pe.PID;
          memcpy((char *)r + sizeof(CeProcessEntry), pe.ProcessName, (size_t)namelen);
        }
        else
        {
          size = (int)sizeof(CeProcessEntry);
          r = (PCeProcessEntry)malloc((size_t)size);
          r->processnamesize = 0;
          r->pid = 0;
        }

        r->result = result;
        sendall(currentsocket, r, (size_t)size, 0);
        free(r);
      }
      break;
    }

    case CMD_MODULE32FIRST:
    case CMD_MODULE32NEXT:
    {
      HANDLE toolhelpsnapshot;
      if (recvall(currentsocket, &toolhelpsnapshot, sizeof(toolhelpsnapshot), 0) > 0)
      {
        ModuleListEntry me;
        BOOL result = (command == CMD_MODULE32FIRST) ? Module32First(toolhelpsnapshot, &me) : Module32Next(toolhelpsnapshot, &me);

        CeModuleEntry *r;
        int size;
        if (result)
        {
          int namelen = (int)strlen(me.moduleName);
          size = (int)sizeof(CeModuleEntry) + namelen;
          r = (PCeModuleEntry)malloc((size_t)size);
          r->modulebase = (int64_t)me.baseAddress;
          r->modulepart = me.part;
          r->modulesize = me.moduleSize;
          r->modulefileoffset = me.fileOffset;
          r->modulenamesize = namelen;
          memcpy((char *)r + sizeof(CeModuleEntry), me.moduleName, (size_t)namelen);
        }
        else
        {
          size = (int)sizeof(CeModuleEntry);
          r = (PCeModuleEntry)malloc((size_t)size);
          memset(r, 0, (size_t)size);
        }

        r->result = result;
        sendall(currentsocket, r, (size_t)size, 0);
        free(r);
      }
      break;
    }

    case CMD_GETSYMBOLLISTFROMFILE:
    {
      struct
      {
        uint32_t fileoffset;
        uint32_t symbolpathsize;
      } input;

      if (recvall(currentsocket, &input, sizeof(input), 0) > 0)
      {
        char *symbolpath = (char *)malloc((size_t)input.symbolpathsize + 1);
        if (!symbolpath)
          break;

        symbolpath[input.symbolpathsize] = 0;
        if (input.symbolpathsize && recvall(currentsocket, symbolpath, input.symbolpathsize, 0) <= 0)
        {
          free(symbolpath);
          break;
        }

        unsigned char *output = NULL;
        if (memcmp("/dev/", symbolpath, 5) != 0)
          GetSymbolListFromFile(symbolpath, input.fileoffset, &output);

        if (output)
        {
          sendall(currentsocket, output, *(uint32_t *)&output[4], 0);
          free(output);
        }
        else
        {
          uint64_t fail = 0;
          sendall(currentsocket, &fail, sizeof(fail), 0);
        }

        free(symbolpath);
      }
      break;
    }

    case CMD_READPROCESSMEMORY:
    {
      CeReadProcessMemoryInput c;
      if (recvall(currentsocket, &c, sizeof(c), 0) > 0)
      {

        if (c.size > (uint32_t)INT_MAX || !can_alloc_size(sizeof(CeReadProcessMemoryOutput), (size_t)c.size))
        {
          PCeReadProcessMemoryOutput o = (PCeReadProcessMemoryOutput)malloc(sizeof(CeReadProcessMemoryOutput));
          if (o)
          {
            o->read = 0;
            sendall(currentsocket, o, sizeof(CeReadProcessMemoryOutput), 0);
            free(o);
          }
          break;
        }

        PCeReadProcessMemoryOutput o = (PCeReadProcessMemoryOutput)malloc(sizeof(CeReadProcessMemoryOutput) + (size_t)c.size);
        if (!o)
        {

          PCeReadProcessMemoryOutput o2 = (PCeReadProcessMemoryOutput)malloc(sizeof(CeReadProcessMemoryOutput));
          if (o2)
          {
            o2->read = 0;
            sendall(currentsocket, o2, sizeof(CeReadProcessMemoryOutput), 0);
            free(o2);
          }
          break;
        }

        o->read = ReadProcessMemory((HANDLE)c.handle, (void *)(uintptr_t)c.address, &o[1], (int)c.size);

        if (c.compress)
        {
#define COMPRESS_BLOCKSIZE (64 * 1024)
          unsigned char *uncompressed = (unsigned char *)&o[1];
          uint32_t uncompressedSize = (uint32_t)o->read;
          uint32_t compressedSize = 0;

          unsigned char **compressedBlocks = NULL;
          int maxBlocks = 0;
          int currentBlock = 0;
          int blocksAllocated = 0;

          z_stream strm;
          memset(&strm, 0, sizeof(strm));
          int zinit = Z_ERRNO;
          int ok = 1;

          if (uncompressedSize == 0)
          {
            sendall(currentsocket, &uncompressedSize, sizeof(uncompressedSize), MSG_MORE);
            sendall(currentsocket, &compressedSize, sizeof(compressedSize), 0);
            free(o);
            break;
          }

          maxBlocks = 1 + ((int)uncompressedSize / COMPRESS_BLOCKSIZE);
          compressedBlocks = (unsigned char **)malloc((size_t)maxBlocks * sizeof(unsigned char *));
          if (!compressedBlocks)
            ok = 0;

          if (ok)
          {
            zinit = deflateInit(&strm, c.compress);
            if (zinit != Z_OK)
              ok = 0;
          }

          if (ok)
          {
            compressedBlocks[0] = (unsigned char *)malloc(COMPRESS_BLOCKSIZE);
            if (!compressedBlocks[0])
              ok = 0;
            else
            {
              blocksAllocated = 1;
              strm.avail_out = COMPRESS_BLOCKSIZE;
              strm.next_out = compressedBlocks[0];
              strm.next_in = uncompressed;
              strm.avail_in = uncompressedSize;
            }
          }

          while (ok && strm.avail_in)
          {
            int zr = deflate(&strm, Z_NO_FLUSH);
            if (zr != Z_OK && zr != Z_STREAM_END)
            {
              ok = 0;
              break;
            }

            if (strm.avail_out == 0)
            {
              currentBlock++;
              if (currentBlock >= maxBlocks)
              {
                maxBlocks *= 2;
                void *newp = realloc(compressedBlocks, (size_t)maxBlocks * sizeof(unsigned char *));
                if (!newp)
                {
                  ok = 0;
                  break;
                }
                compressedBlocks = (unsigned char **)newp;
              }

              compressedBlocks[currentBlock] = (unsigned char *)malloc(COMPRESS_BLOCKSIZE);
              if (!compressedBlocks[currentBlock])
              {
                ok = 0;
                break;
              }

              blocksAllocated = currentBlock + 1;
              strm.avail_out = COMPRESS_BLOCKSIZE;
              strm.next_out = compressedBlocks[currentBlock];
            }
          }

          while (ok)
          {
            int zr = deflate(&strm, Z_FINISH);
            if (zr == Z_STREAM_END)
              break;
            if (zr != Z_OK)
            {
              ok = 0;
              break;
            }

            if (strm.avail_out == 0)
            {
              currentBlock++;
              if (currentBlock >= maxBlocks)
              {
                maxBlocks *= 2;
                void *newp = realloc(compressedBlocks, (size_t)maxBlocks * sizeof(unsigned char *));
                if (!newp)
                {
                  ok = 0;
                  break;
                }
                compressedBlocks = (unsigned char **)newp;
              }

              compressedBlocks[currentBlock] = (unsigned char *)malloc(COMPRESS_BLOCKSIZE);
              if (!compressedBlocks[currentBlock])
              {
                ok = 0;
                break;
              }

              blocksAllocated = currentBlock + 1;
              strm.avail_out = COMPRESS_BLOCKSIZE;
              strm.next_out = compressedBlocks[currentBlock];
            }
          }

          if (zinit == Z_OK)
            deflateEnd(&strm);

          if (!ok)
          {

            compressedSize = 0;
            sendall(currentsocket, &uncompressedSize, sizeof(uncompressedSize), MSG_MORE);
            sendall(currentsocket, &compressedSize, sizeof(compressedSize), 0);

            for (int i = 0; i < blocksAllocated; i++)
              free(compressedBlocks[i]);
            free(compressedBlocks);
            free(o);
            break;
          }

          compressedSize = (uint32_t)strm.total_out;
          sendall(currentsocket, &uncompressedSize, sizeof(uncompressedSize), MSG_MORE);
          sendall(currentsocket, &compressedSize, sizeof(compressedSize), MSG_MORE);

          for (int i = 0; i < blocksAllocated; i++)
          {
            if (i != currentBlock)
              sendall(currentsocket, compressedBlocks[i], COMPRESS_BLOCKSIZE, MSG_MORE);
            else
              sendall(currentsocket, compressedBlocks[i], COMPRESS_BLOCKSIZE - strm.avail_out, 0);
            free(compressedBlocks[i]);
          }
          free(compressedBlocks);
        }
        else
        {
          sendall(currentsocket, o, sizeof(CeReadProcessMemoryOutput) + (size_t)o->read, 0);
        }

        free(o);
      }
      break;
    }

    case CMD_WRITEPROCESSMEMORY:
    {
      CeWriteProcessMemoryInput c;
      if (recvall(currentsocket, &c, sizeof(c), 0) > 0)
      {
        CeWriteProcessMemoryOutput o;
        unsigned char *buf = NULL;
        if (c.size > 0)
        {

          size_t want = (size_t)c.size;
          buf = (unsigned char *)malloc(want);
          if (buf)
          {
            if (recvall(currentsocket, buf, want, 0) > 0)
              o.written = WriteProcessMemory((HANDLE)c.handle, (void *)(uintptr_t)c.address, buf, (int)c.size);
            else
              o.written = 0;
            free(buf);
          }
          else
          {

            char discard[64 * 1024];
            size_t left = want;
            while (left)
            {
              size_t n = left > sizeof(discard) ? sizeof(discard) : left;
              if (recvall(currentsocket, discard, n, 0) <= 0)
                break;
              left -= n;
            }
            o.written = 0;
          }
        }
        else
        {
          o.written = 0;
        }

        sendall(currentsocket, &o, sizeof(o), 0);
      }
      break;
    }

    case CMD_VIRTUALQUERYEXFULL:
    {
      CeVirtualQueryExFullInput c;
      if (recvall(currentsocket, &c, sizeof(c), MSG_WAITALL) > 0)
      {
        RegionInfo *rinfo = NULL;
        uint32_t count = 0;
        if (VirtualQueryExFull((HANDLE)c.handle, c.flags, &rinfo, &count))
        {
          sendall(currentsocket, &count, sizeof(count), 0);
          for (uint32_t i = 0; i < count; i++)
            sendall(currentsocket, &rinfo[i], sizeof(RegionInfo), 0);
        }
        else
        {

          sendall(currentsocket, &count, sizeof(count), 0);
        }
        free(rinfo);
      }
      break;
    }

    case CMD_CHANGEMEMORYPROTECTION:
    {
      CeChangeMemoryProtection c;
      if (recvall(currentsocket, &c, sizeof(c), 0) > 0)
      {






        uint32_t oldprot = 0;
        uint32_t result = ChangeMemoryProtection(c.hProcess, c.address, c.size, c.windowsprotection, &oldprot);
        sendall(currentsocket, &result, sizeof(result), MSG_MORE);
        sendall(currentsocket, &oldprot, sizeof(oldprot), 0);
      }
      break;
    }

    case CMD_CLOSEHANDLE:
    {
      HANDLE h;
      if (recvall(currentsocket, &h, sizeof(h), 0) > 0)
      {
        CloseHandle(h);
        int ok = 1;
        sendall(currentsocket, &ok, sizeof(ok), 0);
      }
      break;
    }

    case CMD_CLOSECONNECTION:
      close(currentsocket);
      return 0;

    default:
      debug_log("Unknown command received: %u\n", command);

      close(currentsocket);
      return 0;
  }

  return 1;
}

static void *newconnection(void *arg)
{
  int s = (int)(intptr_t)arg;
  int currentsocket = s;
  threadname = NULL;
  isDebuggerThread = 0;
  debugfd = -1;

  while (1)
  {
    if (isDebuggerThread && (debugfd != -1))
    {
      fd_set readfds;
      int maxfd = s;
      int sret;

      FD_ZERO(&readfds);
      FD_SET(s, &readfds);
      FD_SET(debugfd, &readfds);

      if (debugfd > maxfd)
        maxfd = debugfd;

      sret = select(maxfd + 1, &readfds, NULL, NULL, NULL);
      if (sret == -1)
      {
        if (errno == EINTR)
          continue;
        debug_log("select failed: %d\n", errno);
        break;
      }

      if (FD_ISSET(debugfd, &readfds) && FD_ISSET(s, &readfds))
      {
        if (currentsocket == debugfd)
          currentsocket = s;
        else
          currentsocket = debugfd;
      }
      else if (FD_ISSET(debugfd, &readfds))
      {
        currentsocket = debugfd;
      }
      else if (FD_ISSET(s, &readfds))
      {
        currentsocket = s;
      }
      else
      {
        continue;
      }
    }
    else
    {
      currentsocket = s;
    }

    unsigned char command;
    ssize_t r = recvall(currentsocket, &command, 1, MSG_WAITALL);
    if (r == 1)
    {
      if (!DispatchCommand(currentsocket, command))
        break;
    }
    else
    {
      if (r == -1)
        debug_log("read error on socket %d (%d)\n", s, errno);
      else if (threadname)
        debug_log("%s has disconnected\n", threadname);

      if (isDebuggerThread)
      {
        debug_log("This was a debugger thread\n");
        StopDebug(isDebuggerThread);
      }
      break;
    }
  }

  free(threadname);
  threadname = NULL;
  close(s);
  return NULL;
}

int main(int argc, char *argv[])
{
  (void)argc;
  (void)argv;

  initAPI();

  int sock0 = socket(AF_INET, SOCK_STREAM, 0);
  if (sock0 < 0)
  {
    perror("socket");
    return 1;
  }

  int yes = 1;
  setsockopt(sock0, SOL_SOCKET, SO_REUSEADDR, (const char *)&yes, sizeof(yes));

  struct sockaddr_in addr;
  memset(&addr, 0, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_port = htons(52736);
  addr.sin_addr.s_addr = INADDR_ANY;

  if (bind(sock0, (struct sockaddr *)&addr, sizeof(addr)) != 0)
  {
    perror("bind");
    close(sock0);
    return 1;
  }

  if (listen(sock0, 32) != 0)
  {
    perror("listen");
    close(sock0);
    return 1;
  }

  printf("CEServer. Waiting for client connection\n");
  fflush(stdout);

  while (1)
  {
    int sock = accept(sock0, NULL, NULL);
    if (sock < 0)
      continue;

    setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (const char *)&yes, sizeof(yes));

    pthread_t th;
    if (pthread_create(&th, NULL, newconnection, (void *)(intptr_t)sock) == 0)
      pthread_detach(th);
    else
      close(sock);
  }
}

```

`ceserver-ios/jailbreak/ceserver.h`:

```h
/*
 * ceserver.h
 *
 *  Created on: Jul 18, 2011
 *      Author: erich
 */

#ifndef CESERVER_H_
#define CESERVER_H_

#include <stdint.h>
#include <sys/types.h>
#include "porthelp.h"

#define CMD_GETVERSION 0
#define CMD_CLOSECONNECTION 1
#define CMD_TERMINATESERVER 2
#define CMD_OPENPROCESS 3
#define CMD_CREATETOOLHELP32SNAPSHOT 4
#define CMD_PROCESS32FIRST 5
#define CMD_PROCESS32NEXT 6
#define CMD_CLOSEHANDLE 7
#define CMD_VIRTUALQUERYEX 8
#define CMD_READPROCESSMEMORY 9
#define CMD_WRITEPROCESSMEMORY 10
#define CMD_STARTDEBUG 11
#define CMD_STOPDEBUG 12
#define CMD_WAITFORDEBUGEVENT 13
#define CMD_CONTINUEFROMDEBUGEVENT 14
#define CMD_SETBREAKPOINT 15
#define CMD_REMOVEBREAKPOINT 16
#define CMD_SUSPENDTHREAD 17
#define CMD_RESUMETHREAD 18
#define CMD_GETTHREADCONTEXT 19
#define CMD_SETTHREADCONTEXT 20
#define CMD_GETARCHITECTURE 21
#define CMD_MODULE32FIRST 22
#define CMD_MODULE32NEXT 23

#define CMD_GETSYMBOLLISTFROMFILE 24
#define CMD_LOADEXTENSION         25

#define CMD_ALLOC                   26
#define CMD_FREE                    27
#define CMD_CREATETHREAD            28
#define CMD_LOADMODULE              29
#define CMD_SPEEDHACK_SETSPEED      30

#define CMD_VIRTUALQUERYEXFULL      31
#define CMD_GETREGIONINFO           32
#define CMD_GETABI                  33

#define CMD_SET_CONNECTION_NAME     34

#define CMD_CREATETOOLHELP32SNAPSHOTEX 35

#define CMD_CHANGEMEMORYPROTECTION  36

#define CMD_GETOPTIONS              37
#define CMD_GETOPTIONVALUE          38
#define CMD_SETOPTIONVALUE          39


#define CMD_PTRACE_MMAP             40


#define CMD_OPENNAMEDPIPE           41
#define CMD_PIPEREAD                42
#define CMD_PIPEWRITE               43

#define CMD_GETCESERVERPATH         44
#define CMD_ISANDROID               45

#define CMD_LOADMODULEEX            46

#define CMD_SETCURRENTPATH          47
#define CMD_GETCURRENTPATH          48
#define CMD_ENUMFILES               49
#define CMD_GETFILEPERMISSIONS      50
#define CMD_SETFILEPERMISSIONS      51
#define CMD_GETFILE                 52
#define CMD_PUTFILE                 53
#define CMD_CREATEDIR               54
#define CMD_DELETEFILE              55

#define CMD_AOBSCAN					200


#define CMD_COMMANDLIST2            255




#pragma pack(1)
typedef struct {
	int version;
	unsigned char stringsize;

} CeVersion, *PCeVersion;

typedef struct {
    DWORD dwFlags;
    DWORD th32ProcessID;
} CeCreateToolhelp32Snapshot, *PCeCreateToolhelp32Snapshot;

typedef struct {
    int result;
    int pid;
    int processnamesize;

} CeProcessEntry, *PCeProcessEntry;

typedef struct {
    int32_t result;
    int64_t modulebase;
    int32_t modulepart;
    int32_t modulesize;
    uint32_t modulefileoffset;
    int32_t modulenamesize;
} CeModuleEntry, *PCeModuleEntry;

typedef struct {
  int handle;
  uint64_t baseaddress;
} CeVirtualQueryExInput, *PCeVirtualQueryExInput;

typedef struct {
  uint8_t result;
  uint32_t protection;
  uint32_t type;
  uint64_t baseaddress;
  uint64_t size;
} CeVirtualQueryExOutput, *PCeVirtualQueryExOutput;

typedef struct {
  int handle;
  uint8_t flags;
} CeVirtualQueryExFullInput, *PCeVirtualQueryExFullInput;

typedef struct {
  uint32_t protection;
  uint32_t type;
  uint64_t baseaddress;
  uint64_t size;
} CeVirtualQueryExFullOutput, *PCeVirtualQueryExFullOutput;

typedef struct {
  uint32_t handle;
  uint64_t address;
  uint32_t size;
  uint8_t  compress;
} CeReadProcessMemoryInput, *PCeReadProcessMemoryInput;

typedef struct {
  int read;
} CeReadProcessMemoryOutput, *PCeReadProcessMemoryOutput;

typedef struct {
  int32_t handle;
  int64_t address;
  int32_t size;
} CeWriteProcessMemoryInput, *PCeWriteProcessMemoryInput;


typedef struct {
  int32_t written;
} CeWriteProcessMemoryOutput, *PCeWriteProcessMemoryOutput;


typedef struct {
  HANDLE hProcess;
  int tid;
  int debugreg;
  uint64_t Address;
  int bptype;
  int bpsize;
} CeSetBreapointInput, *PCeSetBreakpointInput;


typedef struct {
  int result;
} CeSetBreapointOutput, *PCeSetBreakpointOutput;

typedef struct {
  HANDLE hProcess;
  uint32_t tid;
  uint32_t debugreg;
  uint32_t wasWatchpoint;
} CeRemoveBreapointInput, *PCeRemoveBreakpointInput;


typedef struct {
  int result;
} CeRemoveBreapointOutput, *PCeRemoveBreakpointOutput;

typedef struct {
  HANDLE hProcess;
  int tid;
} CeSuspendThreadInput, *PCeSuspendThreadInput;


typedef struct {
  int result;
} CeSuspendThreadOutput, *PCeSuspendThreadOutput;

typedef struct {
  HANDLE hProcess;
  int tid;
} CeResumeThreadInput, *PCeResumeThreadInput;


typedef struct {
  int result;
} CeResumeThreadOutput, *PCeResumeThreadOutput;

typedef struct {
  HANDLE hProcess;
  uint64_t preferedBase;
  uint32_t size;
  uint32_t windowsprotection;
} CeAllocInput, *PCeAllocInput;


typedef struct {
  uint64_t address;
} CeAllocOutput, *PCeAllocOutput;

typedef struct {
  HANDLE hProcess;
  uint64_t address;
  uint32_t size;
} CeFreeInput, *PCeFreeInput;


typedef struct {
  uint32_t result;
} CeFreeOutput, *PCeFreeOutput;

typedef struct {
  HANDLE hProcess;
  uint64_t startaddress;
  uint64_t parameter;
} CeCreateThreadInput, *PCeCreateThreadInput;


typedef struct {
  HANDLE threadhandle;
} CeCreateThreadOutput, *PCeCreateThreadOutput;

typedef struct {
  HANDLE hProcess;
  uint32_t modulepathlength;

} CeLoadModuleInput, *PCeLoadModuleInput;

typedef struct {
  HANDLE hProcess;
  uint64_t dlopenaddress;
  uint32_t modulepathlength;

} CeLoadModuleInputEx, *PCeLoadModuleInputEx;


typedef struct {
  uint32_t result;
} CeLoadModuleOutput, *PCeLoadModuleOutput;


typedef struct {
  HANDLE hProcess;
  float speed;
} CeSpeedhackSetSpeedInput, *PCeSpeedhackSetSpeedInput;


typedef struct {
  uint32_t result;
} CeSpeedhackSetSpeedOutput, *PCeSpeedhackSetSpeedOutput;

typedef struct {
  HANDLE hProcess;
  uint64_t address;
  uint32_t size;
  uint32_t windowsprotection;
} CeChangeMemoryProtection, *PCeChangeMemoryProtection;

typedef struct {
  HANDLE hPipe;
  uint32_t size;
  uint32_t timeout;
} CeReadPipe, *PCeReadPipe;

typedef struct {
  HANDLE hPipe;
  uint32_t size;
  uint32_t timeout;

} CeWritePipe, *PCeWritePipe;


typedef struct {
	HANDLE hProcess;
	uint64_t start;
	uint64_t end;
	int inc;
	int protection;
	int scansize;
} CeAobScanInput, * PCeAobScanInput;



#pragma pack()

ssize_t sendall (int s, void *buf, size_t size, int flags);
ssize_t recvall (int s, void *buf, size_t size, int flags);

ssize_t sendstring16(int s, char *str, int flags);
char* receivestring16(int s);

int sendinteger(int s, int val, int flags);

int DispatchCommand(int currentsocket, unsigned char command);
int CheckForAndDispatchCommand(int currentsocket);

int getCEServerPath(char *path, int maxlen);

extern char *CESERVERPATH;
extern int ALLOC_WITHOUT_EXTENSION;
extern int PORT;
extern __thread char* threadname;


#if BUILD_OPTION == 1
  #define SHARED_LIBRARY
#endif

#endif /* CESERVER_H_ */

```

`ceserver-ios/jailbreak/context.h`:

```h
#ifndef CONTEXT_H_
#define CONTEXT_H_

#include <stdint.h>

typedef struct
{
  uint64_t regs[31];
  uint64_t sp;
  uint64_t pc;
  uint64_t pstate;
} CONTEXT_REGS;

typedef struct
{
  __uint128_t vregs[32];
  uint32_t fpsr;
  uint32_t fpcr;
  uint32_t __reserved[2];
} CONTEXT_FP;

#pragma pack(push, 1)
typedef struct
{
  uint32_t structsize;
  uint32_t type;
  CONTEXT_REGS regs;
  CONTEXT_FP fp;
} CONTEXT, *PCONTEXT;
#pragma pack(pop)

#endif

```

`ceserver-ios/jailbreak/control`:

```
Package: com.0xiuks.ceserver
Name: ceserver
Version: 1.0.0
Architecture: iphoneos-arm64
Description: ceserver-ios
Maintainer: 0xiuks
Author: xiu
Section: System


```

`ceserver-ios/jailbreak/debugger.c`:

```c
#include "debugger.h"

#include <errno.h>
#include <pthread.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <sys/sysctl.h>
#include <time.h>

#include <mach/exception_types.h>
#include <mach/exc.h>
#include <mach/mach.h>
#include <mach/mach_vm.h>
#include <mach/ndr.h>
#include <mach/thread_act.h>
#include <mach/thread_status.h>

#include "api.h"


#define S_USER ((uint32_t)(2u << 1))
#define WCR_ENABLE ((uint32_t)(1u))
#define WCR_LOAD ((uint32_t)(1u << 3))
#define WCR_STORE ((uint32_t)(1u << 4))

#ifndef EXC_ARM_DA_DEBUG
#define EXC_ARM_DA_DEBUG 0x102
#endif

typedef struct DebugEventQueueElement
{
  DebugEvent de;
  struct DebugEventQueueElement *next;
} DebugEventQueueElement;

typedef struct WatchpointSpec
{
  uint64_t aligned_start;
  uint64_t aligned_size;
  uint64_t requested_start;
  uint64_t requested_size;
} WatchpointSpec;

typedef struct DebuggerBreakpoint
{
  uint64_t address;
  int debugreg;
  int size;
  int bptype;
  thread_t tid;
  int hw_count;
  int hw_index[2];
  WatchpointSpec wp[2];
  struct DebuggerBreakpoint *next;
} DebuggerBreakpoint;

typedef struct PendingException
{
  thread_t thread;
  mach_port_t reply_port;
  mach_msg_id_t msg_id;
  struct PendingException *next;
} PendingException;

typedef struct DebuggerData
{
  mach_port_t exception_port;
  exception_mask_t exception_mask;
  exception_mask_t saved_masks[EXC_TYPES_COUNT];
  mach_port_t saved_ports[EXC_TYPES_COUNT];
  exception_behavior_t saved_behaviors[EXC_TYPES_COUNT];
  thread_state_flavor_t saved_flavors[EXC_TYPES_COUNT];
  mach_msg_type_number_t saved_count;
  task_t task;

  pthread_t exception_thread;
  int exception_thread_running;
  int exception_thread_started;
  thread_t exception_thread_port;

  pthread_mutex_t queue_mutex;
  pthread_cond_t queue_cond;
  DebugEventQueueElement *queue_head;
  DebugEventQueueElement *queue_tail;

  pthread_mutex_t breakpoint_mutex;
  DebuggerBreakpoint *breakpoints;

  thread_t *threads;
  mach_msg_type_number_t thread_count;

  thread_t single_step_thread;

  PendingException *pending_head;
  PendingException *pending_tail;
} DebuggerData;

static pthread_mutex_t g_debugger_lock = PTHREAD_MUTEX_INITIALIZER;
static PProcessData g_debugger_process = NULL;

static uint64_t get_thread_pc(thread_t thread);
static int set_single_step(thread_t thread, int enable);
static int is_thread_invalid_error(kern_return_t err);
static int get_debug_state(thread_t thread, arm_debug_state64_t *dbgstate, kern_return_t *out_err);
static int set_debug_state(thread_t thread, const arm_debug_state64_t *dbgstate, kern_return_t *out_err);
static int set_task_debug_state(task_t task, const arm_debug_state64_t *dbgstate, kern_return_t *out_err);
static int apply_breakpoint_state(thread_t thread, int debugreg, uint64_t address, int size, int enable, kern_return_t *out_err);
static int update_breakpoint_state_in_dbg(arm_debug_state64_t *dbgstate, int debugreg, uint64_t address, int size, int enable);
static int update_watchpoint_state_in_dbg(arm_debug_state64_t *dbgstate, int debugreg, const WatchpointSpec *spec, int bptype, int enable);
static int build_watchpoint_regs(const WatchpointSpec *spec, int bptype, uint64_t *out_wvr, uint64_t *out_wcr);
static int apply_breakpoint_state_transaction(DebuggerData *dbg, thread_t *threads, mach_msg_type_number_t thread_count,
                                              int debugreg, uint64_t address, int size, int enable);
static int apply_watchpoint_state_transaction(DebuggerData *dbg, thread_t *threads, mach_msg_type_number_t thread_count,
                                              const WatchpointSpec *specs, const int *hw_index, int hw_count, int bptype, int enable);
static int apply_breakpoint_state_best_effort(DebuggerData *dbg, int debugreg, uint64_t address, int size, int enable);
static int apply_watchpoint_state_best_effort(DebuggerData *dbg, const WatchpointSpec *specs, const int *hw_index,
                                              int hw_count, int bptype, int enable);
static void apply_breakpoints_to_thread(DebuggerData *dbg, thread_t thread);
static void announce_new_thread(DebuggerData *dbg, thread_t thread);
static void refresh_thread_list(DebuggerData *dbg, task_t task);
static int enqueue_pending_exception(DebuggerData *dbg, thread_t thread, mach_port_t reply_port, mach_msg_id_t msg_id);
static int reply_pending_exception(DebuggerData *dbg, thread_t thread, kern_return_t retcode);
static int reply_all_pending_for_thread(DebuggerData *dbg, thread_t thread, kern_return_t retcode);
static int thread_has_pending_exception(DebuggerData *dbg, thread_t thread);
static int suspend_thread_for_debug(DebuggerData *dbg, thread_t thread, int *out_suspended, kern_return_t *out_err);
static void resume_thread_for_debug(DebuggerData *dbg, thread_t thread, int was_suspended);
static void prune_thread_if_invalid(DebuggerData *dbg, thread_t thread, kern_return_t err);
static uint8_t get_watchpoint_count(void);
static int find_breakpoint_base(DebuggerData *dbg, uint64_t addr, uint64_t *base);
static int get_exception_esr_far(thread_t thread, uint64_t *esr, uint64_t *far);
static int is_watchpoint_exception_esr(uint64_t esr);
static int get_watchpoint_hw_index_from_esr(uint64_t esr, uint32_t *out_index);
static int get_watchpoint_hw_index_from_state(thread_t thread, uint64_t *addr, int *out_index);
static int align_requested_watchpoint(uint64_t requested_addr, uint64_t requested_size, WatchpointSpec *out, int out_cap);
static int enable_watchpoint_on_thread(DebuggerData *dbg, thread_t thread, const DebuggerBreakpoint *bp, kern_return_t *out_err);
static int disable_watchpoint_on_thread(thread_t thread, const DebuggerBreakpoint *bp, kern_return_t *out_err);
static DebuggerBreakpoint *find_watchpoint_by_addr(DebuggerData *dbg, thread_t thread, uint64_t addr);
static DebuggerBreakpoint *find_watchpoint_by_hw_index(DebuggerData *dbg, thread_t thread, int hw_index, int *out_slot);

static uint64_t bit_ceil_u64(uint64_t input)
{
  uint64_t value = 1;
  while (value < input)
  {
    uint64_t next = value << 1;
    if (next <= value)
      return 0;
    value = next;
  }
  return value;
}

static uint64_t bits_u64(uint64_t value, uint32_t msbit, uint32_t lsbit)
{
  uint64_t shift_left = (sizeof(value) * 8u) - 1u - msbit;
  value <<= shift_left;
  value >>= shift_left + lsbit;
  return value;
}

static uint64_t bit_u64(uint64_t value, uint32_t bit)
{
  return bits_u64(value, bit, bit);
}

static int lowest_bit_set_u32(uint32_t value)
{
  for (int i = 0; i < 8; i++)
  {
    if (value & (1u << i))
      return i;
  }
  return -1;
}

static int align_requested_watchpoint(uint64_t requested_addr, uint64_t requested_size, WatchpointSpec *out, int out_cap)
{
  if (requested_size == 0 || out_cap <= 0)
    return 0;

  const uint64_t min_watchpoint_alignment = 8;
  uint64_t aligned_size = requested_size < min_watchpoint_alignment ? min_watchpoint_alignment : requested_size;
  aligned_size = bit_ceil_u64(aligned_size);
  if (aligned_size == 0)
    return 0;

  uint64_t aligned_start = requested_addr & ~(aligned_size - 1);
  if (aligned_start + aligned_size >= requested_addr + requested_size)
  {
    out[0].aligned_start = aligned_start;
    out[0].aligned_size = aligned_size;
    out[0].requested_start = requested_addr;
    out[0].requested_size = requested_size;
    return 1;
  }

  if (out_cap < 2)
    return 0;

  uint64_t split_addr = aligned_start + aligned_size;
  uint64_t first_requested_addr = requested_addr;
  uint64_t first_requested_size = split_addr - requested_addr;
  uint64_t second_requested_addr = split_addr;
  uint64_t second_requested_size = requested_size - first_requested_size;

  WatchpointSpec first;
  WatchpointSpec second;
  if (align_requested_watchpoint(first_requested_addr, first_requested_size, &first, 1) != 1)
    return 0;
  if (align_requested_watchpoint(second_requested_addr, second_requested_size, &second, 1) != 1)
    return 0;

  out[0] = first;
  out[1] = second;
  return 2;
}

static int is_watchpoint_hw_index_used_locked(DebuggerData *dbg, int hw_index)
{
  for (DebuggerBreakpoint *bp = dbg->breakpoints; bp; bp = bp->next)
  {
    if (bp->bptype == 0 || bp->hw_count <= 0)
      continue;
    for (int i = 0; i < bp->hw_count; i++)
    {
      if (bp->hw_index[i] == hw_index)
        return 1;
    }
  }
  return 0;
}

static int allocate_watchpoint_hw_indices_locked(DebuggerData *dbg, int count, int *out_indices)
{
  uint8_t max_watchpoints = get_watchpoint_count();
  int found = 0;

  for (uint8_t i = 0; i < max_watchpoints && found < count; i++)
  {
    if (!is_watchpoint_hw_index_used_locked(dbg, i))
    {
      out_indices[found] = i;
      found++;
    }
  }

  return found == count;
}

static void queue_event(DebuggerData *dbg, const DebugEvent *ev)
{
  DebugEventQueueElement *elem = (DebugEventQueueElement *)malloc(sizeof(DebugEventQueueElement));
  if (!elem)
    return;
  elem->de = *ev;
  elem->next = NULL;

  pthread_mutex_lock(&dbg->queue_mutex);
  if (dbg->queue_tail)
    dbg->queue_tail->next = elem;
  else
    dbg->queue_head = elem;
  dbg->queue_tail = elem;
  pthread_cond_signal(&dbg->queue_cond);
  pthread_mutex_unlock(&dbg->queue_mutex);
}

static int wait_for_event(DebuggerData *dbg, DebugEvent *ev, int timeout_ms)
{
  int has_event = 0;
  pthread_mutex_lock(&dbg->queue_mutex);
  while (!dbg->queue_head && !has_event)
  {
    if (timeout_ms < 0)
    {
      pthread_cond_wait(&dbg->queue_cond, &dbg->queue_mutex);
    }
    else if (timeout_ms == 0)
    {
      break;
    }
    else
    {
      struct timespec ts;
      clock_gettime(CLOCK_REALTIME, &ts);
      ts.tv_sec += timeout_ms / 1000;
      ts.tv_nsec += (timeout_ms % 1000) * 1000000L;
      if (ts.tv_nsec >= 1000000000L)
      {
        ts.tv_sec += 1;
        ts.tv_nsec -= 1000000000L;
      }
      if (pthread_cond_timedwait(&dbg->queue_cond, &dbg->queue_mutex, &ts) == ETIMEDOUT)
        break;
    }
  }

  if (dbg->queue_head)
  {
    DebugEventQueueElement *elem = dbg->queue_head;
    dbg->queue_head = elem->next;
    if (!dbg->queue_head)
      dbg->queue_tail = NULL;
    *ev = elem->de;
    free(elem);
    has_event = 1;
  }
  pthread_mutex_unlock(&dbg->queue_mutex);
  return has_event;
}

static uint8_t get_breakpoint_count(void)
{
  uint32_t n = 0;
  size_t len = sizeof(n);
  if (sysctlbyname("hw.optional.breakpoint", &n, &len, NULL, 0) == 0)
    return (uint8_t)n;
  return 0;
}

static uint8_t get_watchpoint_count(void)
{
  uint32_t n = 0;
  size_t len = sizeof(n);
  if (sysctlbyname("hw.optional.watchpoint", &n, &len, NULL, 0) == 0)
    return (uint8_t)n;
  return 0;
}

static PProcessData get_process_for_exception(mach_port_t task)
{
  (void)task;
  PProcessData p = NULL;
  pthread_mutex_lock(&g_debugger_lock);
  p = g_debugger_process;
  pthread_mutex_unlock(&g_debugger_lock);
  return p;
}

static int register_thread(DebuggerData *dbg, thread_t thread)
{
  for (mach_msg_type_number_t i = 0; i < dbg->thread_count; i++)
  {
    if (dbg->threads[i] == thread)
    {
      mach_port_deallocate(mach_task_self(), thread);
      return 0;
    }
  }

  thread_t *newlist = (thread_t *)realloc(dbg->threads, sizeof(thread_t) * (dbg->thread_count + 1));
  if (!newlist)
  {
    mach_port_deallocate(mach_task_self(), thread);
    return 0;
  }
  dbg->threads = newlist;
  dbg->threads[dbg->thread_count] = thread;
  dbg->thread_count++;

  announce_new_thread(dbg, thread);
  return 1;
}

static kern_return_t handle_exception_raise(DebuggerData *dbg, __Request__exception_raise_t *req)
{
  PProcessData p = get_process_for_exception(req->task.name);
  if (!p || !p->debuggerData)
    return KERN_FAILURE;

  uint64_t exc_code = 0;
  uint64_t exc_subcode = 0;
  if (req->codeCnt > 0)
    exc_code = (uint64_t)req->code[0];
  if (req->codeCnt > 1)
    exc_subcode = (uint64_t)req->code[1];

  register_thread(dbg, req->thread.name);
  mach_port_deallocate(mach_task_self(), req->task.name);

  if (!enqueue_pending_exception(dbg, req->thread.name, req->Head.msgh_remote_port, req->Head.msgh_id))
    debug_log("Failed to queue pending exception for thread %u\n", req->thread.name);

  int signo = SIGTRAP;
  switch (req->exception)
  {
    case EXC_BAD_ACCESS:
      signo = SIGBUS;
      break;
    case EXC_BAD_INSTRUCTION:
      signo = SIGILL;
      break;
    case EXC_ARITHMETIC:
      signo = SIGFPE;
      break;
    case EXC_BREAKPOINT:
    default:
      signo = SIGTRAP;
      break;
  }

  if (dbg->single_step_thread == req->thread.name)
  {
    set_single_step(req->thread.name, 0);
    dbg->single_step_thread = MACH_PORT_NULL;
  }

  DebugEvent ev;
  memset(&ev, 0, sizeof(ev));
  ev.debugevent = signo;
  ev.threadid = (int64_t)req->thread.name;
  ev.address = get_thread_pc(req->thread.name);

  if (req->exception == EXC_BREAKPOINT)
  {
    uint64_t pc = ev.address;
    uint64_t esr = 0;
    uint64_t far = 0;
    int have_esr_far = get_exception_esr_far(req->thread.name, &esr, &far);
    DebuggerBreakpoint *wp = NULL;
    uint64_t candidate = far ? far : exc_subcode;

    if (have_esr_far && is_watchpoint_exception_esr(esr))
    {
      uint32_t hw_index = 0;
      int slot = -1;
      if (get_watchpoint_hw_index_from_esr(esr, &hw_index))
        wp = find_watchpoint_by_hw_index(dbg, req->thread.name, (int)hw_index, &slot);
      if (!wp && candidate)
      {
        int hw_index_state = -1;
        uint64_t candidate_state = candidate;
        if (get_watchpoint_hw_index_from_state(req->thread.name, &candidate_state, &hw_index_state))
        {
          wp = find_watchpoint_by_hw_index(dbg, req->thread.name, hw_index_state, NULL);
          if (candidate_state)
            candidate = candidate_state;
        }
      }
      if (!wp && candidate)
        wp = find_watchpoint_by_addr(dbg, req->thread.name, candidate);
    }
    else if (exc_code == EXC_ARM_DA_DEBUG)
    {
      if (candidate)
      {
        int hw_index_state = -1;
        uint64_t candidate_state = candidate;
        if (get_watchpoint_hw_index_from_state(req->thread.name, &candidate_state, &hw_index_state))
        {
          wp = find_watchpoint_by_hw_index(dbg, req->thread.name, hw_index_state, NULL);
          if (candidate_state)
            candidate = candidate_state;
        }
        if (!wp)
          wp = find_watchpoint_by_addr(dbg, req->thread.name, candidate);
      }
    }

    if (wp)
    {
      ev.address = wp->address;
    }
    else if (exc_code == 1 && exc_subcode)
    {
      DebuggerBreakpoint *addr_wp = find_watchpoint_by_addr(dbg, req->thread.name, exc_subcode);
      if (addr_wp)
      {
        ev.address = addr_wp->address;
      }
      else
      {
        uint64_t base = 0;
        if (find_breakpoint_base(dbg, exc_subcode, &base))
          ev.address = base;
        else if (find_breakpoint_base(dbg, pc, &base))
          ev.address = base;
        else
          ev.address = exc_subcode;
      }
    }
    else if (exc_code == 2 && exc_subcode)
    {
      uint64_t base = 0;
      if (find_breakpoint_base(dbg, exc_subcode, &base))
      {
        ev.address = base;
      }
      else if (find_breakpoint_base(dbg, pc, &base))
      {
        ev.address = base;
      }
      else
      {
        ev.address = exc_subcode;
      }
    }
    else
    {
      uint64_t base = 0;
      if (find_breakpoint_base(dbg, pc, &base))
        ev.address = base;
      else
        ev.address = pc;
    }
  }
  else if (req->exception == EXC_BAD_ACCESS)
  {
    ev.address = exc_subcode ? exc_subcode : ev.address;
  }
  queue_event(dbg, &ev);

  return KERN_SUCCESS;
}

static void *exception_thread_main(void *arg)
{
  PProcessData p = (PProcessData)arg;
  DebuggerData *dbg = (DebuggerData *)p->debuggerData;
  if (dbg && dbg->exception_thread_port == MACH_PORT_NULL)
    dbg->exception_thread_port = mach_thread_self();

  union __RequestUnion__exc_subsystem request;

  while (dbg->exception_thread_running)
  {
    kern_return_t kr = mach_msg(&request.Request_exception_raise.Head, MACH_RCV_MSG, 0,
                                sizeof(request), dbg->exception_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    if (kr == MACH_RCV_INTERRUPTED)
      continue;
    if (kr != KERN_SUCCESS)
      break;

    mach_msg_header_t *in = &request.Request_exception_raise.Head;

    if (in->msgh_id == 2401)
    {
      handle_exception_raise(dbg, &request.Request_exception_raise);
    }
    else if (in->msgh_id == 2402 || in->msgh_id == 2403)
    {
      debug_log("Unhandled exception message id=%d\n", in->msgh_id);
    }
  }

  return NULL;
}

static uint64_t get_thread_pc(thread_t thread)
{
  arm_thread_state64_t state;
  mach_msg_type_number_t count = ARM_THREAD_STATE64_COUNT;
  if (thread_get_state(thread, ARM_THREAD_STATE64, (thread_state_t)&state, &count) != KERN_SUCCESS)
    return 0;
  return (uint64_t)state.__pc;
}

static int set_single_step(thread_t thread, int enable)
{
  arm_debug_state64_t dbgstate;
  mach_msg_type_number_t count = ARM_DEBUG_STATE64_COUNT;
  if (thread_get_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&dbgstate, &count) != KERN_SUCCESS)
    return 0;

  if (enable)
    dbgstate.__mdscr_el1 |= 1u;
  else
    dbgstate.__mdscr_el1 &= ~1u;

  return thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&dbgstate, ARM_DEBUG_STATE64_COUNT) == KERN_SUCCESS;
}

static int is_thread_invalid_error(kern_return_t err)
{
  return err == KERN_INVALID_ARGUMENT || err == KERN_INVALID_CAPABILITY || err == KERN_TERMINATED;
}

static int get_debug_state(thread_t thread, arm_debug_state64_t *dbgstate, kern_return_t *out_err)
{
  mach_msg_type_number_t count = ARM_DEBUG_STATE64_COUNT;
  kern_return_t kr = thread_get_state(thread, ARM_DEBUG_STATE64, (thread_state_t)dbgstate, &count);
  if (out_err)
    *out_err = kr;
  return kr == KERN_SUCCESS;
}

static int set_debug_state(thread_t thread, const arm_debug_state64_t *dbgstate, kern_return_t *out_err)
{
  kern_return_t kr = thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)dbgstate, ARM_DEBUG_STATE64_COUNT);
  if (out_err)
    *out_err = kr;
  return kr == KERN_SUCCESS;
}

static int set_task_debug_state(task_t task, const arm_debug_state64_t *dbgstate, kern_return_t *out_err)
{
  if (task == MACH_PORT_NULL)
  {
    if (out_err)
      *out_err = KERN_INVALID_ARGUMENT;
    return 0;
  }
  kern_return_t kr = task_set_state(task, ARM_DEBUG_STATE64, (thread_state_t)dbgstate, ARM_DEBUG_STATE64_COUNT);
  if (out_err)
    *out_err = kr;
  return kr == KERN_SUCCESS;
}

static int update_breakpoint_state_in_dbg(arm_debug_state64_t *dbgstate, int debugreg, uint64_t address, int size, int enable)
{
  if (debugreg < 0 || debugreg >= (int)(sizeof(dbgstate->__bcr) / sizeof(dbgstate->__bcr[0])))
    return 0;

  if (enable)
  {
    uint64_t aligned = address;
    uint32_t control_value = 0;
    if (size <= 1)
    {
      control_value = (0x1u << 5) | 7u;
    }
    else if (size == 2)
    {
      control_value = (0x3u << 5) | 7u;
      aligned &= ~1ull;
    }
    else
    {
      control_value = (0xfu << 5) | 7u;
      aligned &= ~3ull;
    }
    dbgstate->__bvr[debugreg] = aligned;
    dbgstate->__bcr[debugreg] = control_value;
  }
  else
  {
    dbgstate->__bvr[debugreg] = 0;
    dbgstate->__bcr[debugreg] = 0;
  }
  return 1;
}

static int build_watchpoint_regs(const WatchpointSpec *spec, int bptype, uint64_t *out_wvr, uint64_t *out_wcr)
{
  if (!spec || !out_wvr || !out_wcr)
    return 0;
  if (bptype < 1 || bptype > 3)
    return 0;
  if (spec->requested_size == 0)
    return 0;

  const int watch_read = (bptype == 2 || bptype == 3);
  const int watch_write = (bptype == 1 || bptype == 3);

  uint64_t aligned_dword = spec->aligned_start;
  uint64_t offset = spec->requested_start - spec->aligned_start;
  uint64_t watch_size = spec->requested_size;

  if (spec->aligned_size <= 8 && watch_size <= 8 && (offset + watch_size) <= 8)
  {
    uint64_t bas = ((1ull << watch_size) - 1ull) << offset;
    uint64_t wcr = (bas << 5) | S_USER |
                   (watch_read ? WCR_LOAD : 0) |
                   (watch_write ? WCR_STORE : 0) |
                   WCR_ENABLE;
    *out_wvr = aligned_dword;
    *out_wcr = wcr;
  }
  else
  {
    uint64_t mask = (uint64_t)__builtin_popcountll(spec->aligned_size - 1) << 24;
    uint64_t not_bas_wp = (uint64_t)0xff << 5;
    uint64_t wcr = mask | not_bas_wp | S_USER |
                   (watch_read ? WCR_LOAD : 0) |
                   (watch_write ? WCR_STORE : 0) |
                   WCR_ENABLE;
    *out_wvr = spec->aligned_start;
    *out_wcr = wcr;
  }

  return 1;
}

static int update_watchpoint_state_in_dbg(arm_debug_state64_t *dbgstate, int debugreg, const WatchpointSpec *spec, int bptype,
                                          int enable)
{
  if (debugreg < 0 || debugreg >= (int)(sizeof(dbgstate->__wcr) / sizeof(dbgstate->__wcr[0])))
    return 0;

  if (enable)
  {
    uint64_t wvr = 0;
    uint64_t wcr = 0;
    if (!build_watchpoint_regs(spec, bptype, &wvr, &wcr))
      return 0;
    dbgstate->__wvr[debugreg] = wvr;
    dbgstate->__wcr[debugreg] = wcr;
  }
  else
  {
    dbgstate->__wvr[debugreg] = 0;
    dbgstate->__wcr[debugreg] = 0;
  }
  return 1;
}

typedef struct ThreadDebugStateSnapshot
{
  thread_t thread;
  arm_debug_state64_t state;
  int suspended;
  int applied;
} ThreadDebugStateSnapshot;

static int apply_breakpoint_state_transaction(DebuggerData *dbg, thread_t *threads, mach_msg_type_number_t thread_count,
                                              int debugreg, uint64_t address, int size, int enable)
{
  if (!threads || thread_count == 0)
    return 0;

  ThreadDebugStateSnapshot *snapshots = (ThreadDebugStateSnapshot *)calloc(thread_count, sizeof(ThreadDebugStateSnapshot));
  if (!snapshots)
    return 0;

  thread_t self_thread = mach_thread_self();
  thread_t exception_thread = dbg ? dbg->exception_thread_port : MACH_PORT_NULL;
  int ok = 1;
  int applied = 0;
  int task_state_pending = 0;
  arm_debug_state64_t task_state_new;
  for (mach_msg_type_number_t i = 0; i < thread_count; i++)
  {
    thread_t thread = threads[i];
    kern_return_t err = KERN_SUCCESS;
    int suspended = 0;

    if (thread != self_thread && thread != exception_thread && !suspend_thread_for_debug(dbg, thread, &suspended, &err))
    {
      if (is_thread_invalid_error(err))
      {
        prune_thread_if_invalid(dbg, thread, err);
        continue;
      }
      ok = 0;
      break;
    }

    snapshots[i].thread = thread;
    snapshots[i].suspended = suspended;

    if (!get_debug_state(thread, &snapshots[i].state, &err))
    {
      if (is_thread_invalid_error(err))
      {
        prune_thread_if_invalid(dbg, thread, err);
        resume_thread_for_debug(dbg, thread, suspended);
        continue;
      }
      ok = 0;
      break;
    }

    arm_debug_state64_t new_state = snapshots[i].state;
    if (!update_breakpoint_state_in_dbg(&new_state, debugreg, address, size, enable))
    {
      ok = 0;
      break;
    }

    if (!set_debug_state(thread, &new_state, &err))
    {
      if (is_thread_invalid_error(err))
      {
        prune_thread_if_invalid(dbg, thread, err);
        resume_thread_for_debug(dbg, thread, suspended);
        continue;
      }
      ok = 0;
      break;
    }

    snapshots[i].applied = 1;
    applied++;
    if (!task_state_pending && dbg && dbg->task != MACH_PORT_NULL)
    {
      task_state_new = new_state;
      task_state_pending = 1;
    }
  }

  if (!ok)
  {
    for (mach_msg_type_number_t i = 0; i < thread_count; i++)
    {
      if (snapshots[i].applied)
        set_debug_state(snapshots[i].thread, &snapshots[i].state, NULL);
    }
  }
  else if (applied > 0 && task_state_pending && dbg && dbg->task != MACH_PORT_NULL)
  {
    set_task_debug_state(dbg->task, &task_state_new, NULL);
  }

  for (mach_msg_type_number_t i = 0; i < thread_count; i++)
  {
    if (snapshots[i].suspended)
      resume_thread_for_debug(dbg, snapshots[i].thread, snapshots[i].suspended);
  }

  if (self_thread != MACH_PORT_NULL)
    mach_port_deallocate(mach_task_self(), self_thread);
  free(snapshots);
  return ok && applied > 0;
}

static int apply_breakpoint_state_best_effort(DebuggerData *dbg, int debugreg, uint64_t address, int size, int enable)
{
  if (!dbg || !dbg->threads || dbg->thread_count == 0)
    return 0;

  thread_t self_thread = mach_thread_self();
  thread_t exception_thread = dbg ? dbg->exception_thread_port : MACH_PORT_NULL;
  int ok = 0;
  int task_state_pending = 0;
  arm_debug_state64_t task_state_new;
  for (mach_msg_type_number_t i = 0; i < dbg->thread_count; i++)
  {
    thread_t thread = dbg->threads[i];
    kern_return_t err = KERN_SUCCESS;
    int suspended = 0;
    if (thread != self_thread && thread != exception_thread && !suspend_thread_for_debug(dbg, thread, &suspended, &err))
    {
      prune_thread_if_invalid(dbg, thread, err);
      continue;
    }
    if (apply_breakpoint_state(thread, debugreg, address, size, enable, &err))
    {
      ok = 1;
      if (!task_state_pending && dbg->task != MACH_PORT_NULL)
      {
        if (get_debug_state(thread, &task_state_new, NULL))
          task_state_pending = 1;
      }
    }
    else
      prune_thread_if_invalid(dbg, thread, err);
    resume_thread_for_debug(dbg, thread, suspended);
  }

  if (self_thread != MACH_PORT_NULL)
    mach_port_deallocate(mach_task_self(), self_thread);
  if (ok && task_state_pending && dbg->task != MACH_PORT_NULL)
    set_task_debug_state(dbg->task, &task_state_new, NULL);

  return ok;
}

static int apply_watchpoint_state_best_effort(DebuggerData *dbg, const WatchpointSpec *specs, const int *hw_index,
                                              int hw_count, int bptype, int enable)
{
  if (!dbg || !dbg->threads || dbg->thread_count == 0)
    return 0;
  if (hw_count <= 0 || !hw_index)
    return 0;
  if (enable && !specs)
    return 0;

  DebuggerBreakpoint temp_wp;
  memset(&temp_wp, 0, sizeof(temp_wp));
  temp_wp.bptype = bptype;
  temp_wp.hw_count = hw_count;
  temp_wp.hw_index[0] = hw_index[0];
  temp_wp.hw_index[1] = hw_count > 1 ? hw_index[1] : hw_index[0];
  if (enable)
  {
    temp_wp.wp[0] = specs[0];
    temp_wp.wp[1] = hw_count > 1 ? specs[1] : specs[0];
  }

  thread_t self_thread = mach_thread_self();
  thread_t exception_thread = dbg ? dbg->exception_thread_port : MACH_PORT_NULL;
  int ok = 0;
  int task_state_pending = 0;
  arm_debug_state64_t task_state_new;
  for (mach_msg_type_number_t i = 0; i < dbg->thread_count; i++)
  {
    thread_t thread = dbg->threads[i];
    kern_return_t err = KERN_SUCCESS;
    int suspended = 0;
    if (thread != self_thread && thread != exception_thread && !suspend_thread_for_debug(dbg, thread, &suspended, &err))
    {
      prune_thread_if_invalid(dbg, thread, err);
      continue;
    }
    if (enable ? enable_watchpoint_on_thread(dbg, thread, &temp_wp, &err)
               : disable_watchpoint_on_thread(thread, &temp_wp, &err))
    {
      ok = 1;
      if (!task_state_pending && dbg->task != MACH_PORT_NULL)
      {
        if (get_debug_state(thread, &task_state_new, NULL))
          task_state_pending = 1;
      }
    }
    else
    {
      prune_thread_if_invalid(dbg, thread, err);
    }
    resume_thread_for_debug(dbg, thread, suspended);
  }

  if (self_thread != MACH_PORT_NULL)
    mach_port_deallocate(mach_task_self(), self_thread);
  if (ok && task_state_pending && dbg->task != MACH_PORT_NULL)
    set_task_debug_state(dbg->task, &task_state_new, NULL);

  return ok;
}

static int apply_watchpoint_state_transaction(DebuggerData *dbg, thread_t *threads, mach_msg_type_number_t thread_count,
                                              const WatchpointSpec *specs, const int *hw_index, int hw_count, int bptype, int enable)
{
  if (!threads || thread_count == 0)
    return 0;
  if (hw_count <= 0 || !hw_index)
    return 0;
  if (enable && !specs)
    return 0;

  ThreadDebugStateSnapshot *snapshots = (ThreadDebugStateSnapshot *)calloc(thread_count, sizeof(ThreadDebugStateSnapshot));
  if (!snapshots)
    return 0;

  thread_t self_thread = mach_thread_self();
  thread_t exception_thread = dbg ? dbg->exception_thread_port : MACH_PORT_NULL;
  int ok = 1;
  int applied = 0;
  int task_state_pending = 0;
  arm_debug_state64_t task_state_new;
  for (mach_msg_type_number_t i = 0; i < thread_count; i++)
  {
    thread_t thread = threads[i];
    kern_return_t err = KERN_SUCCESS;
    int suspended = 0;

    if (thread != self_thread && thread != exception_thread && !suspend_thread_for_debug(dbg, thread, &suspended, &err))
    {
      if (is_thread_invalid_error(err))
      {
        prune_thread_if_invalid(dbg, thread, err);
        continue;
      }
      ok = 0;
      break;
    }

    snapshots[i].thread = thread;
    snapshots[i].suspended = suspended;

    if (!get_debug_state(thread, &snapshots[i].state, &err))
    {
      if (is_thread_invalid_error(err))
      {
        prune_thread_if_invalid(dbg, thread, err);
        resume_thread_for_debug(dbg, thread, suspended);
        continue;
      }
      ok = 0;
      break;
    }

    arm_debug_state64_t new_state = snapshots[i].state;
    for (int j = 0; j < hw_count; j++)
    {
      const WatchpointSpec *spec = enable ? &specs[j] : NULL;
      if (!update_watchpoint_state_in_dbg(&new_state, hw_index[j], spec, bptype, enable))
      {
        ok = 0;
        break;
      }
    }
    if (!ok)
      break;

    if (!set_debug_state(thread, &new_state, &err))
    {
      if (is_thread_invalid_error(err))
      {
        prune_thread_if_invalid(dbg, thread, err);
        resume_thread_for_debug(dbg, thread, suspended);
        continue;
      }
      ok = 0;
      break;
    }

    snapshots[i].applied = 1;
    applied++;
    if (!task_state_pending && dbg && dbg->task != MACH_PORT_NULL)
    {
      task_state_new = new_state;
      task_state_pending = 1;
    }
  }

  if (!ok)
  {
    for (mach_msg_type_number_t i = 0; i < thread_count; i++)
    {
      if (snapshots[i].applied)
        set_debug_state(snapshots[i].thread, &snapshots[i].state, NULL);
    }
  }
  else if (applied > 0 && task_state_pending && dbg && dbg->task != MACH_PORT_NULL)
  {
    set_task_debug_state(dbg->task, &task_state_new, NULL);
  }

  for (mach_msg_type_number_t i = 0; i < thread_count; i++)
  {
    if (snapshots[i].suspended)
      resume_thread_for_debug(dbg, snapshots[i].thread, snapshots[i].suspended);
  }

  if (self_thread != MACH_PORT_NULL)
    mach_port_deallocate(mach_task_self(), self_thread);
  free(snapshots);
  return ok && applied > 0;
}
static void fill_context_from_thread(thread_t thread, PCONTEXT Context)
{
  arm_thread_state64_t gpr;
  mach_msg_type_number_t gpr_count = ARM_THREAD_STATE64_COUNT;
  memset(Context, 0, sizeof(*Context));

  if (thread_get_state(thread, ARM_THREAD_STATE64, (thread_state_t)&gpr, &gpr_count) == KERN_SUCCESS)
  {
    for (int i = 0; i < 29; i++)
      Context->regs.regs[i] = gpr.__x[i];
    Context->regs.regs[29] = gpr.__fp;
    Context->regs.regs[30] = gpr.__lr;
    Context->regs.sp = gpr.__sp;
    Context->regs.pc = gpr.__pc;
    Context->regs.pstate = gpr.__cpsr;
  }

  arm_neon_state64_t neon;
  mach_msg_type_number_t neon_count = ARM_NEON_STATE64_COUNT;
  if (thread_get_state(thread, ARM_NEON_STATE64, (thread_state_t)&neon, &neon_count) == KERN_SUCCESS)
  {
    memcpy(Context->fp.vregs, neon.__v, sizeof(neon.__v));
    Context->fp.fpsr = neon.__fpsr;
    Context->fp.fpcr = neon.__fpcr;
  }

  Context->structsize = sizeof(CONTEXT);
  Context->type = 3;
}

static int apply_breakpoint_state(thread_t thread, int debugreg, uint64_t address, int size, int enable, kern_return_t *out_err)
{
  arm_debug_state64_t dbgstate;
  mach_msg_type_number_t count = ARM_DEBUG_STATE64_COUNT;
  kern_return_t kr = thread_get_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&dbgstate, &count);
  if (kr != KERN_SUCCESS)
  {
    if (out_err)
      *out_err = kr;
    return 0;
  }

  if (debugreg < 0 || debugreg >= (int)(sizeof(dbgstate.__bcr) / sizeof(dbgstate.__bcr[0])))
    return 0;

  if (enable)
  {
    uint64_t aligned = address;
    uint32_t control_value = 0;
    if (size <= 1)
    {
      control_value = (0x1u << 5) | 7u;
    }
    else if (size == 2)
    {
      control_value = (0x3u << 5) | 7u;
      aligned &= ~1ull;
    }
    else
    {
      control_value = (0xfu << 5) | 7u;
      aligned &= ~3ull;
    }
    dbgstate.__bvr[debugreg] = aligned;
    dbgstate.__bcr[debugreg] = control_value;
  }
  else
  {
    dbgstate.__bvr[debugreg] = 0;
    dbgstate.__bcr[debugreg] = 0;
  }

  kr = thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&dbgstate, ARM_DEBUG_STATE64_COUNT);
  if (kr != KERN_SUCCESS)
  {
    if (out_err)
      *out_err = kr;
    return 0;
  }
  if (out_err)
    *out_err = KERN_SUCCESS;
  return 1;
}

static int enable_watchpoint_on_thread(DebuggerData *dbg, thread_t thread, const DebuggerBreakpoint *bp,
                                       kern_return_t *out_err)
{
  (void)dbg;
  if (!bp || bp->bptype == 0 || bp->hw_count <= 0)
    return 0;

  arm_debug_state64_t dbgstate;
  kern_return_t err = KERN_SUCCESS;
  if (!get_debug_state(thread, &dbgstate, &err))
  {
    if (out_err)
      *out_err = err;
    return 0;
  }

  arm_debug_state64_t new_state = dbgstate;
  for (int i = 0; i < bp->hw_count; i++)
  {
    if (!update_watchpoint_state_in_dbg(&new_state, bp->hw_index[i], &bp->wp[i], bp->bptype, 1))
      return 0;
  }

  if (!set_debug_state(thread, &new_state, &err))
  {
    if (out_err)
      *out_err = err;
    return 0;
  }

  if (out_err)
    *out_err = KERN_SUCCESS;
  return 1;
}

static int disable_watchpoint_on_thread(thread_t thread, const DebuggerBreakpoint *bp, kern_return_t *out_err)
{
  if (!bp || bp->bptype == 0 || bp->hw_count <= 0)
    return 0;

  arm_debug_state64_t dbgstate;
  kern_return_t err = KERN_SUCCESS;
  if (!get_debug_state(thread, &dbgstate, &err))
  {
    if (out_err)
      *out_err = err;
    return 0;
  }

  arm_debug_state64_t new_state = dbgstate;
  for (int i = 0; i < bp->hw_count; i++)
  {
    if (!update_watchpoint_state_in_dbg(&new_state, bp->hw_index[i], NULL, bp->bptype, 0))
      return 0;
  }

  if (!set_debug_state(thread, &new_state, &err))
  {
    if (out_err)
      *out_err = err;
    return 0;
  }

  if (out_err)
    *out_err = KERN_SUCCESS;
  return 1;
}

static int enqueue_pending_exception(DebuggerData *dbg, thread_t thread, mach_port_t reply_port, mach_msg_id_t msg_id)
{
  PendingException *pe = (PendingException *)malloc(sizeof(PendingException));
  if (!pe)
    return 0;
  pe->thread = thread;
  pe->reply_port = reply_port;
  pe->msg_id = msg_id;
  pe->next = NULL;

  pthread_mutex_lock(&dbg->queue_mutex);
  if (dbg->pending_tail)
    dbg->pending_tail->next = pe;
  else
    dbg->pending_head = pe;
  dbg->pending_tail = pe;
  pthread_mutex_unlock(&dbg->queue_mutex);
  return 1;
}

static int reply_pending_exception(DebuggerData *dbg, thread_t thread, kern_return_t retcode)
{
  PendingException *prev = NULL;
  PendingException *cur = NULL;

  pthread_mutex_lock(&dbg->queue_mutex);
  cur = dbg->pending_head;
  while (cur)
  {
    if (cur->thread == thread)
      break;
    prev = cur;
    cur = cur->next;
  }

  if (!cur)
  {
    pthread_mutex_unlock(&dbg->queue_mutex);
    return 0;
  }

  if (prev)
    prev->next = cur->next;
  else
    dbg->pending_head = cur->next;
  if (dbg->pending_tail == cur)
    dbg->pending_tail = prev;
  pthread_mutex_unlock(&dbg->queue_mutex);

  if (cur->msg_id == 2401)
  {
    __Reply__exception_raise_t r;
    memset(&r, 0, sizeof(r));
    r.Head.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MOVE_SEND_ONCE, 0);
    r.Head.msgh_size = sizeof(r);
    r.Head.msgh_remote_port = cur->reply_port;
    r.Head.msgh_local_port = MACH_PORT_NULL;
    r.Head.msgh_id = cur->msg_id + 100;
    r.NDR = NDR_record;
    r.RetCode = retcode;
    mach_msg(&r.Head, MACH_SEND_MSG, r.Head.msgh_size, 0, MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
  }

  free(cur);
  return 1;
}

static int reply_all_pending_for_thread(DebuggerData *dbg, thread_t thread, kern_return_t retcode)
{
  int count = 0;
  while (reply_pending_exception(dbg, thread, retcode))
    count++;
  return count;
}

static int thread_has_pending_exception(DebuggerData *dbg, thread_t thread)
{
  int found = 0;
  pthread_mutex_lock(&dbg->queue_mutex);
  PendingException *cur = dbg->pending_head;
  while (cur)
  {
    if (cur->thread == thread)
    {
      found = 1;
      break;
    }
    cur = cur->next;
  }
  pthread_mutex_unlock(&dbg->queue_mutex);
  return found;
}

static int suspend_thread_for_debug(DebuggerData *dbg, thread_t thread, int *out_suspended, kern_return_t *out_err)
{
  if (out_suspended)
    *out_suspended = 0;

  if (thread_has_pending_exception(dbg, thread))
  {
    if (out_err)
      *out_err = KERN_SUCCESS;
    // Thread is already stopped in the exception handler; do not suspend.
    return 1;
  }

  kern_return_t kr = thread_suspend(thread);
  if (kr != KERN_SUCCESS)
  {
    if (out_err)
      *out_err = kr;
    return 0;
  }

  if (out_suspended)
    *out_suspended = 1;
  return 1;
}

static void resume_thread_for_debug(DebuggerData *dbg, thread_t thread, int was_suspended)
{
  if (!was_suspended)
    return;
  kern_return_t kr = thread_resume(thread);
  if (kr != KERN_SUCCESS)
    prune_thread_if_invalid(dbg, thread, kr);
}

static void prune_thread_if_invalid(DebuggerData *dbg, thread_t thread, kern_return_t err)
{
  if (err != KERN_INVALID_ARGUMENT && err != KERN_INVALID_CAPABILITY && err != KERN_TERMINATED)
    return;

  for (mach_msg_type_number_t i = 0; i < dbg->thread_count; i++)
  {
    if (dbg->threads[i] == thread)
    {
      mach_port_deallocate(mach_task_self(), dbg->threads[i]);
      for (mach_msg_type_number_t j = i + 1; j < dbg->thread_count; j++)
        dbg->threads[j - 1] = dbg->threads[j];
      dbg->thread_count--;
      break;
    }
  }
}

static DebuggerBreakpoint *find_watchpoint_by_addr(DebuggerData *dbg, thread_t thread, uint64_t addr)
{
  DebuggerBreakpoint *found = NULL;

  pthread_mutex_lock(&dbg->breakpoint_mutex);
  for (DebuggerBreakpoint *bp = dbg->breakpoints; bp; bp = bp->next)
  {
    if (bp->bptype == 0 || bp->size <= 0)
      continue;
    if (bp->tid != -1 && bp->tid != thread)
      continue;

    int slot_count = bp->hw_count > 0 ? bp->hw_count : 0;
    if (slot_count == 0)
    {
      uint64_t start = bp->address;
      uint64_t end = start + (uint64_t)bp->size;
      if (addr >= start && addr < end)
      {
        found = bp;
        break;
      }
      continue;
    }

    for (int i = 0; i < slot_count; i++)
    {
      const WatchpointSpec *spec = &bp->wp[i];
      uint64_t start = spec->aligned_size ? spec->aligned_start : bp->address;
      uint64_t size = spec->aligned_size ? spec->aligned_size : (uint64_t)bp->size;
      uint64_t end = start + size;
      if (addr >= start && addr < end)
      {
        found = bp;
        break;
      }
    }
    if (found)
      break;
  }

  pthread_mutex_unlock(&dbg->breakpoint_mutex);
  return found;
}

static DebuggerBreakpoint *find_watchpoint_by_hw_index_locked(DebuggerData *dbg, thread_t thread, int hw_index, int *out_slot)
{
  DebuggerBreakpoint *found = NULL;
  for (DebuggerBreakpoint *bp = dbg->breakpoints; bp; bp = bp->next)
  {
    if (bp->bptype == 0 || bp->hw_count <= 0)
      continue;
    if (bp->tid != -1 && bp->tid != thread)
      continue;
    for (int i = 0; i < bp->hw_count; i++)
    {
      if (bp->hw_index[i] == hw_index)
      {
        found = bp;
        if (out_slot)
          *out_slot = i;
        break;
      }
    }
    if (found)
      break;
  }
  return found;
}

static DebuggerBreakpoint *find_watchpoint_by_hw_index(DebuggerData *dbg, thread_t thread, int hw_index, int *out_slot)
{
  DebuggerBreakpoint *found = NULL;
  pthread_mutex_lock(&dbg->breakpoint_mutex);
  found = find_watchpoint_by_hw_index_locked(dbg, thread, hw_index, out_slot);
  pthread_mutex_unlock(&dbg->breakpoint_mutex);
  return found;
}

static int find_breakpoint_base(DebuggerData *dbg, uint64_t addr, uint64_t *base)
{
  int found = 0;
  pthread_mutex_lock(&dbg->breakpoint_mutex);
  for (DebuggerBreakpoint *bp = dbg->breakpoints; bp; bp = bp->next)
  {
    if (bp->bptype != 0 || bp->size <= 0)
      continue;
    if (addr >= bp->address && (addr - bp->address) < (uint64_t)bp->size)
    {
      if (base)
        *base = bp->address;
      found = 1;
      break;
    }
  }
  pthread_mutex_unlock(&dbg->breakpoint_mutex);
  return found;
}

static int get_exception_esr_far(thread_t thread, uint64_t *esr, uint64_t *far)
{
#ifdef ARM_EXCEPTION_STATE64
  arm_exception_state64_t exc;
  mach_msg_type_number_t count = ARM_EXCEPTION_STATE64_COUNT;
  if (thread_get_state(thread, ARM_EXCEPTION_STATE64, (thread_state_t)&exc, &count) != KERN_SUCCESS)
    return 0;
  if (esr)
    *esr = (uint64_t)exc.__esr;
  if (far)
    *far = (uint64_t)exc.__far;
  return 1;
#else
  (void)thread;
  (void)esr;
  (void)far;
  return 0;
#endif
}

static int is_watchpoint_exception_esr(uint64_t esr)
{
  return ((esr >> 26) & 0x3fu) == 0x34u;
}

static int get_watchpoint_hw_index_from_esr(uint64_t esr, uint32_t *out_index)
{
  if (!is_watchpoint_exception_esr(esr))
    return 0;
  uint64_t iss = bits_u64(esr, 23, 0);
  uint32_t wpt = (uint32_t)bits_u64(iss, 23, 18);
  uint32_t wptv = (uint32_t)bit_u64(iss, 17);
  if (!wptv)
    return 0;
  if (out_index)
    *out_index = wpt;
  return 1;
}

static int get_watchpoint_hw_index_from_state(thread_t thread, uint64_t *addr, int *out_index)
{
  if (!addr)
    return 0;

  arm_debug_state64_t dbgstate;
  if (!get_debug_state(thread, &dbgstate, NULL))
    return 0;

  int count = (int)(sizeof(dbgstate.__wcr) / sizeof(dbgstate.__wcr[0]));
  for (int i = 0; i < count; i++)
  {
    uint64_t wcr = dbgstate.__wcr[i];
    if ((wcr & WCR_ENABLE) == 0)
      continue;

    uint64_t wvr = dbgstate.__wvr[i];
    uint32_t mask = (uint32_t)bits_u64(wcr, 28, 24);
    if (mask == 0)
    {
      if (bits_u64(wvr, 48, 3) != bits_u64(*addr, 48, 3))
        continue;

      uint32_t bas = (uint32_t)bits_u64(wcr, 12, 5);
      int lsb = lowest_bit_set_u32(bas);
      if (lsb < 0)
        continue;

      uint32_t byte = (uint32_t)bits_u64(*addr, 2, 0);
      if (bas & (1u << byte))
      {
        *addr = wvr + (uint64_t)lsb;
        if (out_index)
          *out_index = i;
        return 1;
      }
    }
    else
    {
      if (bits_u64(wvr, 48, mask) == bits_u64(*addr, 48, mask))
      {
        if (out_index)
          *out_index = i;
        return 1;
      }
    }
  }

  return 0;
}

static void apply_breakpoints_to_thread(DebuggerData *dbg, thread_t thread)
{
  typedef struct BreakpointApplyItem
  {
    uint64_t address;
    int debugreg;
    int size;
    int bptype;
    int hw_count;
    int hw_index[2];
    WatchpointSpec wp[2];
  } BreakpointApplyItem;

  BreakpointApplyItem *items = NULL;
  size_t count = 0;

  pthread_mutex_lock(&dbg->breakpoint_mutex);
  for (DebuggerBreakpoint *bp = dbg->breakpoints; bp; bp = bp->next)
  {
    if (bp->tid != -1 && bp->tid != thread)
      continue;
    count++;
  }

  if (count > 0)
  {
    items = (BreakpointApplyItem *)calloc(count, sizeof(BreakpointApplyItem));
    if (!items)
    {
      pthread_mutex_unlock(&dbg->breakpoint_mutex);
      return;
    }

    size_t idx = 0;
    for (DebuggerBreakpoint *bp = dbg->breakpoints; bp; bp = bp->next)
    {
      if (bp->tid != -1 && bp->tid != thread)
        continue;
      items[idx].address = bp->address;
      items[idx].debugreg = bp->debugreg;
      items[idx].size = bp->size;
      items[idx].bptype = bp->bptype;
      items[idx].hw_count = bp->hw_count;
      items[idx].hw_index[0] = bp->hw_index[0];
      items[idx].hw_index[1] = bp->hw_index[1];
      items[idx].wp[0] = bp->wp[0];
      items[idx].wp[1] = bp->wp[1];
      idx++;
    }
  }
  pthread_mutex_unlock(&dbg->breakpoint_mutex);

  if (!items)
    return;

  kern_return_t err = KERN_SUCCESS;
  int suspended = 0;
  if (!suspend_thread_for_debug(dbg, thread, &suspended, &err))
  {
    prune_thread_if_invalid(dbg, thread, err);
    free(items);
    return;
  }

  for (size_t i = 0; i < count; i++)
  {
    if (items[i].bptype == 0)
    {
      if (!apply_breakpoint_state(thread, items[i].debugreg, items[i].address, items[i].size, 1, &err))
      {
        prune_thread_if_invalid(dbg, thread, err);
        break;
      }
    }
    else
    {
      DebuggerBreakpoint temp_wp;
      memset(&temp_wp, 0, sizeof(temp_wp));
      temp_wp.bptype = items[i].bptype;
      temp_wp.hw_count = items[i].hw_count;
      temp_wp.hw_index[0] = items[i].hw_index[0];
      temp_wp.hw_index[1] = items[i].hw_index[1];
      temp_wp.wp[0] = items[i].wp[0];
      temp_wp.wp[1] = items[i].wp[1];
      if (!enable_watchpoint_on_thread(dbg, thread, &temp_wp, &err))
      {
        prune_thread_if_invalid(dbg, thread, err);
        break;
      }
    }
  }

  resume_thread_for_debug(dbg, thread, suspended);
  free(items);
}

static void announce_new_thread(DebuggerData *dbg, thread_t thread)
{
  apply_breakpoints_to_thread(dbg, thread);
  DebugEvent create_thread;
  memset(&create_thread, 0, sizeof(create_thread));
  create_thread.debugevent = -1;
  create_thread.threadid = (int64_t)thread;
  queue_event(dbg, &create_thread);
}

static void refresh_thread_list(DebuggerData *dbg, task_t task)
{
  thread_act_array_t threads = NULL;
  mach_msg_type_number_t thread_count = 0;
  if (task_threads(task, &threads, &thread_count) != KERN_SUCCESS)
    return;

  if (!threads || thread_count == 0)
  {
    if (threads)
      mach_vm_deallocate(mach_task_self(), (mach_vm_address_t)threads, thread_count * sizeof(thread_t));
    if (dbg->threads)
    {
      for (mach_msg_type_number_t i = 0; i < dbg->thread_count; i++)
        mach_port_deallocate(mach_task_self(), dbg->threads[i]);
      free(dbg->threads);
      dbg->threads = NULL;
      dbg->thread_count = 0;
    }
    return;
  }

  thread_t *newlist = (thread_t *)malloc(sizeof(thread_t) * thread_count);
  if (!newlist)
  {
    for (mach_msg_type_number_t i = 0; i < thread_count; i++)
      mach_port_deallocate(mach_task_self(), threads[i]);
    mach_vm_deallocate(mach_task_self(), (mach_vm_address_t)threads, thread_count * sizeof(thread_t));
    return;
  }

  mach_msg_type_number_t newcount = 0;
  for (mach_msg_type_number_t i = 0; i < thread_count; i++)
  {
    thread_t thread = threads[i];
    int exists = 0;
    for (mach_msg_type_number_t j = 0; j < dbg->thread_count; j++)
    {
      if (dbg->threads && dbg->threads[j] == thread)
      {
        exists = 1;
        break;
      }
    }

    newlist[newcount++] = thread;
    if (exists)
    {
      mach_port_deallocate(mach_task_self(), thread);
    }
    else
    {
      announce_new_thread(dbg, thread);
    }
  }

  if (dbg->threads)
  {
    for (mach_msg_type_number_t i = 0; i < dbg->thread_count; i++)
    {
      thread_t old = dbg->threads[i];
      int still_present = 0;
      for (mach_msg_type_number_t j = 0; j < newcount; j++)
      {
        if (newlist[j] == old)
        {
          still_present = 1;
          break;
        }
      }
      if (!still_present)
        mach_port_deallocate(mach_task_self(), old);
    }
    free(dbg->threads);
  }

  dbg->threads = newlist;
  dbg->thread_count = newcount;

  if (threads)
    mach_vm_deallocate(mach_task_self(), (mach_vm_address_t)threads, thread_count * sizeof(thread_t));
}

int StartDebug(HANDLE hProcess)
{
  if (GetHandleType(hProcess) != htProcesHandle)
    return FALSE;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);
  if (!p)
    return FALSE;

  pthread_mutex_lock(&g_debugger_lock);
  if (g_debugger_process && g_debugger_process != p)
  {
    pthread_mutex_unlock(&g_debugger_lock);
    debug_log("StartDebug: only one debugged process supported\n");
    return FALSE;
  }
  pthread_mutex_unlock(&g_debugger_lock);

  DebuggerData *dbg = (DebuggerData *)calloc(1, sizeof(DebuggerData));
  if (!dbg)
    return FALSE;

  pthread_mutex_init(&dbg->queue_mutex, NULL);
  pthread_cond_init(&dbg->queue_cond, NULL);
  pthread_mutex_init(&dbg->breakpoint_mutex, NULL);
  dbg->exception_mask = EXC_MASK_BREAKPOINT | EXC_MASK_BAD_ACCESS | EXC_MASK_BAD_INSTRUCTION | EXC_MASK_ARITHMETIC;
  dbg->task = p->task;

  dbg->saved_count = EXC_TYPES_COUNT;
  kern_return_t kr = task_get_exception_ports(p->task, dbg->exception_mask, dbg->saved_masks, &dbg->saved_count,
                                              dbg->saved_ports, dbg->saved_behaviors, dbg->saved_flavors);
  if (kr != KERN_SUCCESS)
    debug_log("task_get_exception_ports failed: %d\n", kr);

  kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &dbg->exception_port);
  if (kr != KERN_SUCCESS)
  {
    debug_log("mach_port_allocate failed: %d\n", kr);
    free(dbg);
    return FALSE;
  }

  kr = mach_port_insert_right(mach_task_self(), dbg->exception_port, dbg->exception_port, MACH_MSG_TYPE_MAKE_SEND);
  if (kr != KERN_SUCCESS)
  {
    debug_log("mach_port_insert_right failed: %d\n", kr);
    mach_port_deallocate(mach_task_self(), dbg->exception_port);
    free(dbg);
    return FALSE;
  }

  kr = task_set_exception_ports(p->task, dbg->exception_mask, dbg->exception_port,
                                EXCEPTION_DEFAULT, THREAD_STATE_NONE);
  if (kr != KERN_SUCCESS)
  {
    debug_log("task_set_exception_ports failed: %d\n", kr);
    mach_port_deallocate(mach_task_self(), dbg->exception_port);
    free(dbg);
    return FALSE;
  }

  dbg->exception_thread_running = 1;
  p->debuggerData = dbg;

  pthread_mutex_lock(&g_debugger_lock);
  g_debugger_process = p;
  pthread_mutex_unlock(&g_debugger_lock);

  if (pthread_create(&dbg->exception_thread, NULL, exception_thread_main, p) != 0)
  {
    debug_log("Failed to create exception thread\n");
    StopDebug(hProcess);
    return FALSE;
  }
  dbg->exception_thread_started = 1;

  DebugEvent create_process;
  memset(&create_process, 0, sizeof(create_process));
  create_process.debugevent = -2;
  create_process.threadid = p->pid;
  create_process.maxBreakpointCount = get_breakpoint_count();
  create_process.maxWatchpointCount = get_watchpoint_count();
  create_process.maxSharedBreakpoints = 0;
  queue_event(dbg, &create_process);

  mach_msg_type_number_t thread_count = 0;
  thread_act_array_t threads = NULL;
  kr = task_threads(p->task, &threads, &thread_count);
  if (kr == KERN_SUCCESS && thread_count > 0)
  {
    dbg->threads = (thread_t *)malloc(sizeof(thread_t) * thread_count);
    if (dbg->threads)
    {
      dbg->thread_count = thread_count;
      for (mach_msg_type_number_t i = 0; i < thread_count; i++)
      {
        dbg->threads[i] = threads[i];
        DebugEvent create_thread;
        memset(&create_thread, 0, sizeof(create_thread));
        create_thread.debugevent = -1;
        create_thread.threadid = (int64_t)threads[i];
        queue_event(dbg, &create_thread);
      }
    }
    else
    {
      for (mach_msg_type_number_t i = 0; i < thread_count; i++)
        mach_port_deallocate(mach_task_self(), threads[i]);
    }
    mach_vm_deallocate(mach_task_self(), (mach_vm_address_t)threads, thread_count * sizeof(thread_t));
  }

  debug_log("StartDebug(%d) ok\n", hProcess);
  return TRUE;
}

int StopDebug(HANDLE hProcess)
{
  if (GetHandleType(hProcess) != htProcesHandle)
    return FALSE;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);
  if (!p || !p->debuggerData)
    return FALSE;

  DebuggerData *dbg = (DebuggerData *)p->debuggerData;
  dbg->exception_thread_running = 0;

  if (dbg->exception_port != MACH_PORT_NULL)
    mach_port_destroy(mach_task_self(), dbg->exception_port);

  if (dbg->exception_thread_started)
    pthread_join(dbg->exception_thread, NULL);

  if (dbg->exception_thread_port != MACH_PORT_NULL)
  {
    mach_port_deallocate(mach_task_self(), dbg->exception_thread_port);
    dbg->exception_thread_port = MACH_PORT_NULL;
  }

  if (dbg->saved_count > 0)
  {
    for (mach_msg_type_number_t i = 0; i < dbg->saved_count; i++)
    {
      task_set_exception_ports(p->task, dbg->saved_masks[i], dbg->saved_ports[i],
                               dbg->saved_behaviors[i], dbg->saved_flavors[i]);
    }
  }

  pthread_mutex_lock(&g_debugger_lock);
  if (g_debugger_process == p)
    g_debugger_process = NULL;
  pthread_mutex_unlock(&g_debugger_lock);

  if (dbg->threads)
  {
    for (mach_msg_type_number_t i = 0; i < dbg->thread_count; i++)
      mach_port_deallocate(mach_task_self(), dbg->threads[i]);
    free(dbg->threads);
  }

  while (dbg->pending_head)
  {
    reply_pending_exception(dbg, dbg->pending_head->thread, KERN_SUCCESS);
  }

  DebugEventQueueElement *elem = dbg->queue_head;
  while (elem)
  {
    DebugEventQueueElement *next = elem->next;
    free(elem);
    elem = next;
  }

  DebuggerBreakpoint *bp = dbg->breakpoints;
  while (bp)
  {
    DebuggerBreakpoint *next = bp->next;
    free(bp);
    bp = next;
  }

  pthread_mutex_destroy(&dbg->queue_mutex);
  pthread_cond_destroy(&dbg->queue_cond);
  pthread_mutex_destroy(&dbg->breakpoint_mutex);
  free(dbg);
  p->debuggerData = NULL;

  debug_log("StopDebug(%d) ok\n", hProcess);
  return TRUE;
}

int WaitForDebugEvent(HANDLE hProcess, PDebugEvent devent, int timeout)
{
  if (GetHandleType(hProcess) != htProcesHandle)
    return FALSE;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);
  if (!p || !p->debuggerData)
    return FALSE;

  DebuggerData *dbg = (DebuggerData *)p->debuggerData;
  if (!devent)
    return FALSE;

  refresh_thread_list(dbg, p->task);
  int ok = wait_for_event(dbg, devent, timeout);
  return ok;
}

int ContinueFromDebugEvent(HANDLE hProcess, int tid, int ignoresignal)
{
  if (GetHandleType(hProcess) != htProcesHandle)
    return FALSE;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);
  if (!p || !p->debuggerData)
    return FALSE;

  thread_t thread = (thread_t)tid;
  if (thread == MACH_PORT_NULL)
    return FALSE;

  DebuggerData *dbg = (DebuggerData *)p->debuggerData;
  if (ignoresignal == 2)
  {
    if (set_single_step(thread, 1))
      dbg->single_step_thread = thread;
  }

  {
    reply_all_pending_for_thread(dbg, thread, KERN_SUCCESS);
  }

  return TRUE;
}

int GetDebugPort(HANDLE hProcess)
{
  (void)hProcess;
  return -1;
}

int SetBreakpoint(HANDLE hProcess, int tid, int debugreg, void *address, int bptype, int bpsize)
{
  if (GetHandleType(hProcess) != htProcesHandle)
    return FALSE;

  if (bptype < 0 || bptype > 3)
    return FALSE;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);
  if (!p || !p->debuggerData)
    return FALSE;

  DebuggerData *dbg = (DebuggerData *)p->debuggerData;
  uint64_t addr = (uint64_t)(uintptr_t)address;
  int size = 4;
  if (bptype == 0)
  {
    if (bpsize == 1)
      size = 1;
    else if (bpsize == 2)
      size = 2;
  }
  else
  {
    size = bpsize > 0 ? bpsize : 1;
  }

  WatchpointSpec wp_specs[2];
  int wp_spec_count = 0;
  int wp_hw_index[2] = {-1, -1};
  if (bptype != 0)
  {
    wp_spec_count = align_requested_watchpoint(addr, (uint64_t)size, wp_specs, 2);
    if (wp_spec_count == 0)
      return FALSE;
  }

  pthread_mutex_lock(&dbg->breakpoint_mutex);
  DebuggerBreakpoint *bp = dbg->breakpoints;
  while (bp)
  {
    if (bp->address == addr && bp->debugreg == debugreg && bp->tid == (thread_t)tid &&
        bp->bptype == bptype && bp->size == size)
    {
      DebuggerBreakpoint existing;
      int have_existing = 0;
      if (bptype != 0)
      {
        existing = *bp;
        have_existing = 1;
      }
      pthread_mutex_unlock(&dbg->breakpoint_mutex);
      if (!have_existing)
        return TRUE;

      {
        int re_ok = 0;
        if (tid != -1)
        {
          kern_return_t err = KERN_SUCCESS;
          int suspended = 0;
          if (!suspend_thread_for_debug(dbg, (thread_t)tid, &suspended, &err))
          {
            prune_thread_if_invalid(dbg, (thread_t)tid, err);
            return FALSE;
          }
          if (enable_watchpoint_on_thread(dbg, (thread_t)tid, &existing, &err))
            re_ok = 1;
          else
            prune_thread_if_invalid(dbg, (thread_t)tid, err);
          resume_thread_for_debug(dbg, (thread_t)tid, suspended);
        }
        else if (dbg->threads && dbg->thread_count > 0)
        {
          re_ok = apply_watchpoint_state_transaction(dbg, dbg->threads, dbg->thread_count,
                                                     existing.wp, existing.hw_index, existing.hw_count, existing.bptype, 1);
          if (!re_ok)
            re_ok = apply_watchpoint_state_best_effort(dbg, existing.wp, existing.hw_index, existing.hw_count, existing.bptype, 1);
        }
        return re_ok ? TRUE : FALSE;
      }
    }
    bp = bp->next;
  }

  if (bptype != 0)
  {
    if (!allocate_watchpoint_hw_indices_locked(dbg, wp_spec_count, wp_hw_index))
    {
      pthread_mutex_unlock(&dbg->breakpoint_mutex);
      return FALSE;
    }
  }

  pthread_mutex_unlock(&dbg->breakpoint_mutex);

  DebuggerBreakpoint temp_wp;
  if (bptype != 0)
  {
    memset(&temp_wp, 0, sizeof(temp_wp));
    temp_wp.bptype = bptype;
    temp_wp.hw_count = wp_spec_count;
    temp_wp.hw_index[0] = wp_hw_index[0];
    temp_wp.hw_index[1] = wp_hw_index[1];
    if (wp_spec_count > 0)
    {
      temp_wp.wp[0] = wp_specs[0];
      temp_wp.wp[1] = wp_spec_count > 1 ? wp_specs[1] : wp_specs[0];
    }
  }

  int ok = 0;
  if (tid != -1)
  {
    kern_return_t err = KERN_SUCCESS;
    int suspended = 0;
    if (!suspend_thread_for_debug(dbg, (thread_t)tid, &suspended, &err))
    {
      prune_thread_if_invalid(dbg, (thread_t)tid, err);
      return FALSE;
    }
    if ((bptype == 0)
          ? apply_breakpoint_state((thread_t)tid, debugreg, addr, size, 1, &err)
          : enable_watchpoint_on_thread(dbg, (thread_t)tid, &temp_wp, &err))
    {
      ok = 1;
    }
    else
    {
      prune_thread_if_invalid(dbg, (thread_t)tid, err);
    }
    resume_thread_for_debug(dbg, (thread_t)tid, suspended);
  }
  else if (dbg->threads && dbg->thread_count > 0)
  {
    if (bptype == 0)
    {
      ok = apply_breakpoint_state_transaction(dbg, dbg->threads, dbg->thread_count, debugreg, addr, size, 1);
      if (!ok)
        ok = apply_breakpoint_state_best_effort(dbg, debugreg, addr, size, 1);
    }
    else
    {
      ok = apply_watchpoint_state_transaction(dbg, dbg->threads, dbg->thread_count,
                                              temp_wp.wp, temp_wp.hw_index, temp_wp.hw_count, bptype, 1);
      if (!ok)
        ok = apply_watchpoint_state_best_effort(dbg, temp_wp.wp, temp_wp.hw_index, temp_wp.hw_count, bptype, 1);
    }
  }
  if (!ok)
    return FALSE;

  DebuggerBreakpoint *nb = (DebuggerBreakpoint *)malloc(sizeof(DebuggerBreakpoint));
  if (!nb)
    return FALSE;
  nb->address = addr;
  nb->debugreg = debugreg;
  nb->size = size;
  nb->bptype = bptype;
  nb->tid = (thread_t)tid;
  nb->hw_count = wp_spec_count;
  nb->hw_index[0] = wp_hw_index[0];
  nb->hw_index[1] = wp_hw_index[1];
  if (wp_spec_count > 0)
  {
    nb->wp[0] = wp_specs[0];
    nb->wp[1] = wp_spec_count > 1 ? wp_specs[1] : wp_specs[0];
  }
  pthread_mutex_lock(&dbg->breakpoint_mutex);
  nb->next = dbg->breakpoints;
  dbg->breakpoints = nb;
  pthread_mutex_unlock(&dbg->breakpoint_mutex);

  return TRUE;
}

int RemoveBreakpoint(HANDLE hProcess, int tid, int debugreg, int wasWatchpoint)
{
  if (GetHandleType(hProcess) != htProcesHandle)
    return FALSE;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);
  if (!p || !p->debuggerData)
    return FALSE;

  DebuggerData *dbg = (DebuggerData *)p->debuggerData;

  int ok = 0;

  if (!wasWatchpoint)
  {
    if (tid != -1)
    {
      kern_return_t err = KERN_SUCCESS;
      int suspended = 0;
      if (!suspend_thread_for_debug(dbg, (thread_t)tid, &suspended, &err))
      {
        prune_thread_if_invalid(dbg, (thread_t)tid, err);
        return FALSE;
      }
      if (apply_breakpoint_state((thread_t)tid, debugreg, 0, 0, 0, &err))
      {
        ok = 1;
      }
      else
      {
        prune_thread_if_invalid(dbg, (thread_t)tid, err);
      }
      resume_thread_for_debug(dbg, (thread_t)tid, suspended);
    }
    else if (dbg->threads && dbg->thread_count > 0)
    {
      ok = apply_breakpoint_state_transaction(dbg, dbg->threads, dbg->thread_count, debugreg, 0, 0, 0);
      if (!ok)
        ok = apply_breakpoint_state_best_effort(dbg, debugreg, 0, 0, 0);
    }

    pthread_mutex_lock(&dbg->breakpoint_mutex);
    DebuggerBreakpoint **cur = &dbg->breakpoints;
    while (*cur)
    {
      if ((*cur)->debugreg == debugreg &&
          ((*cur)->tid == (thread_t)tid || tid == -1) &&
          (*cur)->bptype == 0)
      {
        DebuggerBreakpoint *dead = *cur;
        *cur = dead->next;
        free(dead);
        if (tid != -1)
          break;
        continue;
      }
      cur = &(*cur)->next;
    }
    pthread_mutex_unlock(&dbg->breakpoint_mutex);
    return ok ? TRUE : FALSE;
  }

  typedef struct WatchpointRemoveItem
  {
    DebuggerBreakpoint bp;
    int disable_ok;
    struct WatchpointRemoveItem *next;
  } WatchpointRemoveItem;

  WatchpointRemoveItem *targets = NULL;
  WatchpointRemoveItem *tmp = NULL;

  pthread_mutex_lock(&dbg->breakpoint_mutex);
  DebuggerBreakpoint *entry = dbg->breakpoints;
  while (entry)
  {
    if (entry->debugreg == debugreg &&
        (tid == -1 || entry->tid == (thread_t)tid || entry->tid == (thread_t)-1) &&
        entry->bptype != 0)
    {
      WatchpointRemoveItem *copy = (WatchpointRemoveItem *)calloc(1, sizeof(WatchpointRemoveItem));
      if (copy)
      {
        copy->bp = *entry;
        copy->disable_ok = 0;
        copy->next = targets;
        targets = copy;
      }
      if (tid != -1)
        break;
    }
    entry = entry->next;
  }
  pthread_mutex_unlock(&dbg->breakpoint_mutex);

  if (tid != -1)
  {
    tmp = targets;
    while (tmp)
    {
      kern_return_t err = KERN_SUCCESS;
      int suspended = 0;
      if (!suspend_thread_for_debug(dbg, (thread_t)tid, &suspended, &err))
      {
        prune_thread_if_invalid(dbg, (thread_t)tid, err);
      }
      else
      {
        if (disable_watchpoint_on_thread((thread_t)tid, &tmp->bp, &err))
          ok = 1;
        else
          prune_thread_if_invalid(dbg, (thread_t)tid, err);
        resume_thread_for_debug(dbg, (thread_t)tid, suspended);
      }
      tmp = tmp->next;
    }

    while (targets)
    {
      tmp = targets;
      targets = targets->next;
      free(tmp);
    }
    return ok ? TRUE : FALSE;
  }

  tmp = targets;
  while (tmp)
  {
    if (dbg->threads && dbg->thread_count > 0)
    {
      if (apply_watchpoint_state_transaction(dbg, dbg->threads, dbg->thread_count,
                                             tmp->bp.wp, tmp->bp.hw_index, tmp->bp.hw_count, tmp->bp.bptype, 0))
      {
        ok = 1;
        tmp->disable_ok = 1;
      }
      else if (apply_watchpoint_state_best_effort(dbg, tmp->bp.wp, tmp->bp.hw_index, tmp->bp.hw_count, tmp->bp.bptype, 0))
      {
        ok = 1;
        tmp->disable_ok = 1;
      }
    }
    tmp = tmp->next;
  }

  pthread_mutex_lock(&dbg->breakpoint_mutex);
  while (targets)
  {
    WatchpointRemoveItem *copy = targets;
    targets = targets->next;

    if (copy->disable_ok)
    {
      DebuggerBreakpoint **cur = &dbg->breakpoints;
      while (*cur)
      {
        DebuggerBreakpoint *bp = *cur;
        if (bp->debugreg == copy->bp.debugreg &&
            bp->address == copy->bp.address &&
            bp->size == copy->bp.size &&
            ((bp->tid == (thread_t)tid) || tid == -1) &&
            bp->bptype != 0)
        {
          *cur = bp->next;
          free(bp);
          if (tid != -1)
            break;
          continue;
        }
        cur = &(*cur)->next;
      }
    }

    free(copy);
  }
  pthread_mutex_unlock(&dbg->breakpoint_mutex);

  return ok ? TRUE : FALSE;
}

int SuspendThread(HANDLE hProcess, int tid)
{
  (void)hProcess;
  thread_t thread = (thread_t)tid;
  if (thread == MACH_PORT_NULL)
    return FALSE;
  return thread_suspend(thread) == KERN_SUCCESS;
}

int ResumeThread(HANDLE hProcess, int tid)
{
  (void)hProcess;
  thread_t thread = (thread_t)tid;
  if (thread == MACH_PORT_NULL)
    return FALSE;
  return thread_resume(thread) == KERN_SUCCESS;
}

BOOL GetThreadContext(HANDLE hProcess, int tid, PCONTEXT Context)
{
  if (GetHandleType(hProcess) != htProcesHandle || !Context)
    return FALSE;

  thread_t thread = (thread_t)tid;
  if (thread == MACH_PORT_NULL)
    return FALSE;

  fill_context_from_thread(thread, Context);
  return TRUE;
}

BOOL SetThreadContext(HANDLE hProcess, int tid, PCONTEXT Context)
{
  if (GetHandleType(hProcess) != htProcesHandle || !Context)
    return FALSE;

  thread_t thread = (thread_t)tid;
  if (thread == MACH_PORT_NULL)
    return FALSE;

  arm_thread_state64_t gpr;
  mach_msg_type_number_t gpr_count = ARM_THREAD_STATE64_COUNT;
  if (thread_get_state(thread, ARM_THREAD_STATE64, (thread_state_t)&gpr, &gpr_count) != KERN_SUCCESS)
    return FALSE;

  for (int i = 0; i < 29; i++)
    gpr.__x[i] = Context->regs.regs[i];
  gpr.__fp = Context->regs.regs[29];
  gpr.__lr = Context->regs.regs[30];
  gpr.__sp = Context->regs.sp;
  gpr.__pc = Context->regs.pc;
  gpr.__cpsr = (uint32_t)Context->regs.pstate;

  if (thread_set_state(thread, ARM_THREAD_STATE64, (thread_state_t)&gpr, ARM_THREAD_STATE64_COUNT) != KERN_SUCCESS)
    return FALSE;

  arm_neon_state64_t neon;
  mach_msg_type_number_t neon_count = ARM_NEON_STATE64_COUNT;
  if (thread_get_state(thread, ARM_NEON_STATE64, (thread_state_t)&neon, &neon_count) != KERN_SUCCESS)
    return FALSE;

  memcpy(neon.__v, Context->fp.vregs, sizeof(neon.__v));
  neon.__fpsr = Context->fp.fpsr;
  neon.__fpcr = Context->fp.fpcr;

  if (thread_set_state(thread, ARM_NEON_STATE64, (thread_state_t)&neon, ARM_NEON_STATE64_COUNT) != KERN_SUCCESS)
    return FALSE;

  return TRUE;
}

int WakeDebuggerThread(void)
{
  return 0;
}

```

`ceserver-ios/jailbreak/debugger.h`:

```h

#ifndef DEBUGGER_H_
#define DEBUGGER_H_

#include <stdint.h>

#include "context.h"
#include "porthelp.h"

#pragma pack(push, 1)
typedef struct
{
  int debugevent;
  int64_t threadid;
  union
  {
    uint64_t address;
    struct
    {
      uint8_t maxBreakpointCount;
      uint8_t maxWatchpointCount;
      uint8_t maxSharedBreakpoints;
    };
  };
} DebugEvent, *PDebugEvent;
#pragma pack(pop)

int StartDebug(HANDLE hProcess);
int StopDebug(HANDLE hProcess);
int WaitForDebugEvent(HANDLE hProcess, PDebugEvent devent, int timeout);
int ContinueFromDebugEvent(HANDLE hProcess, int tid, int ignoresignal);
int GetDebugPort(HANDLE hProcess);

int SetBreakpoint(HANDLE hProcess, int tid, int debugreg, void *address, int bptype, int bpsize);
int RemoveBreakpoint(HANDLE hProcess, int tid, int debugreg, int wasWatchpoint);

int SuspendThread(HANDLE hProcess, int tid);
int ResumeThread(HANDLE hProcess, int tid);

BOOL GetThreadContext(HANDLE hProcess, int tid, PCONTEXT Context);
BOOL SetThreadContext(HANDLE hProcess, int tid, PCONTEXT Context);

int WakeDebuggerThread(void);

#endif 
```

`ceserver-ios/jailbreak/entitlements.plist`:

```plist
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>platform-application</key>
    <true/>
    <key>com.apple.private.security.container-required</key>
    <false/>
    <key>task_for_pid-allow</key>
    <true/>
    <key>com.apple.system-task-ports</key>
    <true/>
</dict>
</plist>

```

`ceserver-ios/jailbreak/porthelp.c`:

```c
/*
 * porthelp.c
 *
 *  Created on: Jul 21, 2011
 *      Author: erich
 * Description: Implements some tools that might come in handy when writing a port
 */

#include <stddef.h>
#include <string.h>
#include <stdlib.h>
#include "porthelp.h"
#include "api.h"

typedef struct
{
  handleType type;
  void *pointer;
  int Handle;

} HandleListEntry, *PHandleListEntry;

volatile HandleListEntry *HandleList;
int HandleList_max;

int CreateHandleFromPointer(void *p, handleType type)
{
  if (HandleList==NULL)
  {

    HandleList_max=256;
    HandleList=(PHandleListEntry)malloc(256*sizeof(HandleListEntry));

    memset((void *)HandleList, 0, sizeof(HandleListEntry)*256);
  }


  int i;
  for (i=1; i<HandleList_max; i++)
  {
    if (HandleList[i].type==htEmpty)
    {
      HandleList[i].pointer=p;
      HandleList[i].type=type;
      return i;
    }
  }



  debug_log("Reached max amount of handles (%d). Leaking some memory to make a larger list (hope for the best, and fix this handle leak that is going on)\n",HandleList_max);
  HandleListEntry *NewHandleList=malloc(HandleList_max * 2 * sizeof(HandleListEntry));
  memset((void *)NewHandleList, 0, HandleList_max * 2 * sizeof(HandleListEntry));
  memcpy(NewHandleList, (const void *)HandleList, HandleList_max * sizeof(HandleListEntry));

  HandleList=NewHandleList;
  i=HandleList_max;
  HandleList_max=HandleList_max * 2;

  HandleList[i].pointer=p;
  HandleList[i].type=type;
  return i;
}


void *GetPointerFromHandle(int handle)
{
  if ((handle>0) && (handle<HandleList_max) && (HandleList[handle].type != htEmpty))
    return HandleList[handle].pointer;
  else
    return NULL;
}

handleType GetHandleType(int handle)
{
  if ((handle>0) && (handle<HandleList_max))
    return HandleList[handle].type;
  else
    return htEmpty;
}

void RemoveHandle(int handle)
{
  if ((handle>0) && (handle<HandleList_max) && (HandleList[handle].type != htEmpty))
    HandleList[handle].type=htEmpty;
}

int SearchHandleList(int type, HANDLESEARCHCALLBACK cb, void *searchdata)
/*
 * go through the handle list and call cb(data, searchdata) for each handle of the specified type
 * if cb(data,searchdata) returns true then return that handle, else return 0
 */
{
  int i;

  for (i=1; i<HandleList_max; i++)
  {
    if (HandleList[i].type==type)
    {
      if (cb(HandleList[i].pointer, searchdata))
        return i;
    }
  }

  return 0;
}

```

`ceserver-ios/jailbreak/porthelp.h`:

```h
/*
 * porthelp.h
 *
 *  Created on: Jul 21, 2011
 *      Author: erich
 */

#ifndef PORTHELP_H_
#define PORTHELP_H_

#include <stdint.h>

typedef uint32_t HANDLE;
typedef uint32_t DWORD;

#define TH32CS_SNAPPROCESS  0x2
#define TH32CS_SNAPTHREAD   0x4
#define TH32CS_SNAPMODULE   0x8
#define TH32CS_SNAPFIRSTMODULE 0x40000000

#define PAGE_NOACCESS 1
#define PAGE_READONLY 2
#define PAGE_READWRITE 4
#define PAGE_WRITECOPY 8
#define PAGE_EXECUTE 16
#define PAGE_EXECUTE_READ 32
#define PAGE_EXECUTE_READWRITE 64

#define MEM_MAPPED 262144
#define MEM_PRIVATE 131072

typedef enum {htEmpty=0, htProcesHandle, htThreadHandle, htPipeHandle, htTHSProcess, htTHSModule, htTHSThread, htNativeThreadHandle} handleType;
typedef int BOOL;

typedef int (*HANDLESEARCHCALLBACK) (void *data, void *searchdata);

#define TRUE 1
#define FALSE 0


int CreateHandleFromPointer(void *p, handleType type);
void *GetPointerFromHandle(int handle);
handleType GetHandleType(int handle);
void RemoveHandle(int handle);
int SearchHandleList(int type, HANDLESEARCHCALLBACK cb, void *searchdata);

#endif /* PORTHELP_H_ */

```

`ceserver-ios/jailbreak/symbols.c`:

```c

#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <mach-o/fat.h>
#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <zlib.h>

#include "api.h"
#include "symbols.h"

#ifndef n_strx
#define n_strx n_un.n_strx
#endif

#pragma pack(1)
typedef struct
{
  uint64_t address;
  int size;
  int type;
  unsigned char namelength;
  char name[0];
} symbolinfo, *psymbolinfo;
#pragma pack()

#ifndef EXPORT_SYMBOL_FLAGS_REEXPORT
#define EXPORT_SYMBOL_FLAGS_REEXPORT 0x08u
#endif
#ifndef EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER
#define EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER 0x10u
#endif
#ifndef INDIRECT_SYMBOL_ABS
#define INDIRECT_SYMBOL_ABS 0x40000000u
#endif
#ifndef INDIRECT_SYMBOL_LOCAL
#define INDIRECT_SYMBOL_LOCAL 0x80000000u
#endif
#ifndef CPU_TYPE_ARM64_32
#define CPU_TYPE_ARM64_32 ((cpu_type_t)0x0200000c)
#endif

#ifndef DW_EH_PE_omit
#define DW_EH_PE_omit 0xff
#endif
#ifndef DW_EH_PE_absptr
#define DW_EH_PE_absptr 0x00
#endif
#ifndef DW_EH_PE_uleb128
#define DW_EH_PE_uleb128 0x01
#endif
#ifndef DW_EH_PE_udata2
#define DW_EH_PE_udata2 0x02
#endif
#ifndef DW_EH_PE_udata4
#define DW_EH_PE_udata4 0x03
#endif
#ifndef DW_EH_PE_udata8
#define DW_EH_PE_udata8 0x04
#endif
#ifndef DW_EH_PE_sleb128
#define DW_EH_PE_sleb128 0x09
#endif
#ifndef DW_EH_PE_sdata2
#define DW_EH_PE_sdata2 0x0a
#endif
#ifndef DW_EH_PE_sdata4
#define DW_EH_PE_sdata4 0x0b
#endif
#ifndef DW_EH_PE_sdata8
#define DW_EH_PE_sdata8 0x0c
#endif
#ifndef DW_EH_PE_pcrel
#define DW_EH_PE_pcrel 0x10
#endif
#ifndef DW_EH_PE_textrel
#define DW_EH_PE_textrel 0x20
#endif
#ifndef DW_EH_PE_datarel
#define DW_EH_PE_datarel 0x30
#endif
#ifndef DW_EH_PE_funcrel
#define DW_EH_PE_funcrel 0x40
#endif
#ifndef DW_EH_PE_aligned
#define DW_EH_PE_aligned 0x50
#endif
#ifndef DW_EH_PE_indirect
#define DW_EH_PE_indirect 0x80
#endif

#define TEMPBUFSIZE (64 * 1024)

typedef struct
{
  uint64_t addr;
  uint64_t size;
  uint32_t flags;
  uint32_t reserved1;
  uint32_t reserved2;
  uint32_t fileoff;
  char segname[17];
  char sectname[17];
} MachSection;

typedef struct
{
  MachSection *items;
  size_t count;
  size_t cap;
} MachSectionList;

typedef struct
{
  uint64_t addr;
  uint32_t size;
  uint32_t type;
  char *name;
} SymbolEntry;

typedef struct
{
  SymbolEntry *items;
  size_t count;
  size_t cap;
} SymbolList;

typedef struct
{
  uint64_t *slots;
  size_t cap;
  size_t count;
} AddrSet;

typedef struct
{
  uint32_t ncmds;
  uint32_t sizeofcmds;
  uint32_t filetype;
  uint32_t flags;
  int is64;
  int swap;
  uint64_t base_vmaddr;
  uint64_t text_vmaddr;
  struct symtab_command symtab;
  struct dysymtab_command dysymtab;
  struct dyld_info_command dyld_info;
  struct linkedit_data_command exports_trie;
  struct linkedit_data_command function_starts;
  MachSectionList sections;
} MachOInfo;

static uint32_t swap32_if(uint32_t v, int swap)
{
  return swap ? __builtin_bswap32(v) : v;
}

static uint16_t swap16_if(uint16_t v, int swap)
{
  return swap ? __builtin_bswap16(v) : v;
}

static uint64_t swap64_if(uint64_t v, int swap)
{
  return swap ? __builtin_bswap64(v) : v;
}

static int read_at(int fd, uint64_t offset, void *buf, size_t size)
{
  ssize_t r = pread(fd, buf, size, (off_t)offset);
  return (r == (ssize_t)size);
}

static int section_list_append(MachSectionList *list, const MachSection *sec)
{
  if (!list || !sec)
    return 0;

  if (list->count >= list->cap)
  {
    size_t newcap = list->cap ? list->cap * 2 : 64;
    void *p = realloc(list->items, newcap * sizeof(MachSection));
    if (!p)
      return 0;
    list->items = (MachSection *)p;
    list->cap = newcap;
  }

  list->items[list->count++] = *sec;
  return 1;
}

static void section_list_free(MachSectionList *list)
{
  if (!list)
    return;
  free(list->items);
  list->items = NULL;
  list->count = 0;
  list->cap = 0;
}

static int symbol_list_append(SymbolList *list, uint64_t addr, uint32_t size, uint32_t type, const char *name)
{
  if (!list || !name || !name[0])
    return 0;

  if (list->count >= list->cap)
  {
    size_t newcap = list->cap ? list->cap * 2 : 1024;
    void *p = realloc(list->items, newcap * sizeof(SymbolEntry));
    if (!p)
      return 0;
    list->items = (SymbolEntry *)p;
    list->cap = newcap;
  }

  SymbolEntry *e = &list->items[list->count++];
  e->addr = addr;
  e->size = size;
  e->type = type;
  e->name = strdup(name);
  if (!e->name)
  {
    list->count--;
    return 0;
  }

  return 1;
}

static void symbol_list_free(SymbolList *list)
{
  if (!list)
    return;
  for (size_t i = 0; i < list->count; i++)
    free(list->items[i].name);
  free(list->items);
  list->items = NULL;
  list->count = 0;
  list->cap = 0;
}

static int addrset_init(AddrSet *set, size_t cap)
{
  if (!set)
    return 0;
  if (cap < 16)
    cap = 16;
  size_t p = 1;
  while (p < cap)
    p <<= 1;
  cap = p;
  set->slots = (uint64_t *)calloc(cap, sizeof(uint64_t));
  if (!set->slots)
    return 0;
  set->cap = cap;
  set->count = 0;
  return 1;
}

static void addrset_free(AddrSet *set)
{
  if (!set)
    return;
  free(set->slots);
  set->slots = NULL;
  set->cap = 0;
  set->count = 0;
}

static int addrset_grow(AddrSet *set)
{
  size_t newcap = set->cap ? set->cap * 2 : 64;
  uint64_t *newslots = (uint64_t *)calloc(newcap, sizeof(uint64_t));
  if (!newslots)
    return 0;

  for (size_t i = 0; i < set->cap; i++)
  {
    uint64_t v = set->slots[i];
    if (v == 0)
      continue;
    size_t mask = newcap - 1;
    size_t idx = (size_t)(v ^ (v >> 32)) & mask;
    while (newslots[idx] != 0)
      idx = (idx + 1) & mask;
    newslots[idx] = v;
  }

  free(set->slots);
  set->slots = newslots;
  set->cap = newcap;
  return 1;
}

static int addrset_contains(const AddrSet *set, uint64_t v)
{
  if (!set || !set->slots || v == 0)
    return 0;
  size_t mask = set->cap - 1;
  size_t idx = (size_t)(v ^ (v >> 32)) & mask;
  while (set->slots[idx] != 0)
  {
    if (set->slots[idx] == v)
      return 1;
    idx = (idx + 1) & mask;
  }
  return 0;
}

static int addrset_insert(AddrSet *set, uint64_t v)
{
  if (!set || !set->slots || v == 0)
    return 0;
  if ((set->count + 1) * 4 >= set->cap * 3)
  {
    if (!addrset_grow(set))
      return 0;
  }

  size_t mask = set->cap - 1;
  size_t idx = (size_t)(v ^ (v >> 32)) & mask;
  while (set->slots[idx] != 0)
  {
    if (set->slots[idx] == v)
      return 1;
    idx = (idx + 1) & mask;
  }
  set->slots[idx] = v;
  set->count++;
  return 1;
}

static int read_uleb(const unsigned char *data, size_t size, size_t *offset, uint64_t *value)
{
  uint64_t result = 0;
  uint32_t shift = 0;
  while (*offset < size)
  {
    uint8_t byte = data[(*offset)++];
    result |= ((uint64_t)(byte & 0x7f)) << shift;
    if ((byte & 0x80) == 0)
    {
      *value = result;
      return 1;
    }
    shift += 7;
    if (shift > 63)
      return 0;
  }
  return 0;
}

static int read_sleb(const unsigned char *data, size_t size, size_t *offset, int64_t *value)
{
  int64_t result = 0;
  uint32_t shift = 0;
  uint8_t byte = 0;
  while (*offset < size)
  {
    byte = data[(*offset)++];
    result |= ((int64_t)(byte & 0x7f)) << shift;
    shift += 7;
    if ((byte & 0x80) == 0)
      break;
    if (shift > 63)
      return 0;
  }

  if (shift < 64 && (byte & 0x40))
    result |= -((int64_t)1 << shift);

  *value = result;
  return 1;
}

static const char *read_cstr(const unsigned char *data, size_t size, size_t *offset)
{
  size_t start = *offset;
  while (*offset < size)
  {
    if (data[*offset] == 0)
    {
      const char *s = (const char *)&data[start];
      (*offset)++;
      return s;
    }
    (*offset)++;
  }
  return NULL;
}

static int read_encoded_value(const unsigned char *data, size_t size, size_t *offset, uint8_t encoding,
                              uint64_t pc, int swap, int is64, int apply_rel, uint64_t *out)
{
  if (encoding == DW_EH_PE_omit)
    return 0;

  uint8_t fmt = encoding & 0x0f;
  uint8_t rel = encoding & 0x70;
  uint8_t ind = encoding & 0x80;

  uint64_t uval = 0;
  int64_t sval = 0;

  switch (fmt)
  {
    case DW_EH_PE_absptr:
      if (is64)
      {
        if (*offset + 8 > size)
          return 0;
        uint64_t v = 0;
        memcpy(&v, data + *offset, 8);
        uval = swap64_if(v, swap);
        *offset += 8;
      }
      else
      {
        if (*offset + 4 > size)
          return 0;
        uint32_t v = 0;
        memcpy(&v, data + *offset, 4);
        uval = swap32_if(v, swap);
        *offset += 4;
      }
      break;
    case DW_EH_PE_uleb128:
      if (!read_uleb(data, size, offset, &uval))
        return 0;
      break;
    case DW_EH_PE_udata2:
      if (*offset + 2 > size)
        return 0;
      {
        uint16_t v = 0;
        memcpy(&v, data + *offset, 2);
        uval = swap16_if(v, swap);
        *offset += 2;
      }
      break;
    case DW_EH_PE_udata4:
      if (*offset + 4 > size)
        return 0;
      {
        uint32_t v = 0;
        memcpy(&v, data + *offset, 4);
        uval = swap32_if(v, swap);
        *offset += 4;
      }
      break;
    case DW_EH_PE_udata8:
      if (*offset + 8 > size)
        return 0;
      {
        uint64_t v = 0;
        memcpy(&v, data + *offset, 8);
        uval = swap64_if(v, swap);
        *offset += 8;
      }
      break;
    case DW_EH_PE_sleb128:
      if (!read_sleb(data, size, offset, &sval))
        return 0;
      uval = (uint64_t)sval;
      break;
    case DW_EH_PE_sdata2:
      if (*offset + 2 > size)
        return 0;
      {
        int16_t v = 0;
        memcpy(&v, data + *offset, 2);
        v = (int16_t)swap16_if((uint16_t)v, swap);
        sval = v;
        uval = (uint64_t)sval;
        *offset += 2;
      }
      break;
    case DW_EH_PE_sdata4:
      if (*offset + 4 > size)
        return 0;
      {
        int32_t v = 0;
        memcpy(&v, data + *offset, 4);
        v = (int32_t)swap32_if((uint32_t)v, swap);
        sval = v;
        uval = (uint64_t)sval;
        *offset += 4;
      }
      break;
    case DW_EH_PE_sdata8:
      if (*offset + 8 > size)
        return 0;
      {
        int64_t v = 0;
        memcpy(&v, data + *offset, 8);
        v = (int64_t)swap64_if((uint64_t)v, swap);
        sval = v;
        uval = (uint64_t)sval;
        *offset += 8;
      }
      break;
    default:
      return 0;
  }

  if (apply_rel)
  {
    if (rel == DW_EH_PE_pcrel)
      uval += pc;
    else if (rel != 0)
      return 0;
  }

  if (ind)
    return 0;

  *out = uval;
  return 1;
}

static uint64_t adjust_address(uint64_t addr, uint64_t base_vmaddr, int isexe)
{
  if (!isexe && base_vmaddr && addr >= base_vmaddr)
    return addr - base_vmaddr;
  return addr;
}

typedef struct
{
  uint64_t offset;
  uint8_t encoding;
} CieInfo;

static int cie_list_add(CieInfo **list, size_t *count, size_t *cap, uint64_t offset, uint8_t encoding)
{
  if (!list || !count || !cap)
    return 0;
  if (*count >= *cap)
  {
    size_t newcap = *cap ? (*cap * 2) : 32;
    void *p = realloc(*list, newcap * sizeof(CieInfo));
    if (!p)
      return 0;
    *list = (CieInfo *)p;
    *cap = newcap;
  }
  (*list)[*count].offset = offset;
  (*list)[*count].encoding = encoding;
  (*count)++;
  return 1;
}

static int cie_list_find(CieInfo *list, size_t count, uint64_t offset, uint8_t *encoding)
{
  if (!list || !encoding)
    return 0;
  for (size_t i = 0; i < count; i++)
  {
    if (list[i].offset == offset)
    {
      *encoding = list[i].encoding;
      return 1;
    }
  }
  return 0;
}

static int find_section_by_name(const MachOInfo *info, const char *sectname, MachSection *out)
{
  if (!info || !sectname || !out)
    return 0;

  int found = 0;
  MachSection best;
  memset(&best, 0, sizeof(best));

  for (size_t i = 0; i < info->sections.count; i++)
  {
    const MachSection *sec = &info->sections.items[i];
    if (strncmp(sec->sectname, sectname, 16) == 0)
    {
      if (strncmp(sec->segname, "__TEXT", 16) == 0)
      {
        *out = *sec;
        return 1;
      }
      if (!found)
      {
        best = *sec;
        found = 1;
      }
    }
  }

  if (found)
  {
    *out = best;
    return 1;
  }

  return 0;
}

static void apply_eh_frame_sizes(const unsigned char *data, size_t size, const MachSection *sec,
                                 const MachOInfo *info, SymbolList *list)
{
  if (!data || !sec || !info || !list || size == 0)
    return;

  CieInfo *cies = NULL;
  size_t cie_count = 0;
  size_t cie_cap = 0;

  size_t off = 0;
  while (off + 4 <= size)
  {
    size_t record_start = off;
    uint32_t len32 = 0;
    memcpy(&len32, data + off, sizeof(len32));
    len32 = swap32_if(len32, info->swap);
    off += 4;

    if (len32 == 0)
      break;

    uint64_t length = len32;
    int len64 = 0;
    if (len32 == 0xffffffff)
    {
      if (off + 8 > size)
        break;
      uint64_t len = 0;
      memcpy(&len, data + off, sizeof(len));
      length = swap64_if(len, info->swap);
      off += 8;
      len64 = 1;
    }

    size_t content_start = off;
    size_t record_end = content_start + (size_t)length;
    if (record_end > size)
      break;

    size_t id_size = len64 ? 8 : 4;
    if (content_start + id_size > record_end)
    {
      off = record_end;
      continue;
    }

    uint64_t cie_id = 0;
    if (len64)
    {
      uint64_t v = 0;
      memcpy(&v, data + content_start, 8);
      cie_id = swap64_if(v, info->swap);
    }
    else
    {
      uint32_t v = 0;
      memcpy(&v, data + content_start, 4);
      cie_id = swap32_if(v, info->swap);
    }

    size_t cur = content_start + id_size;
    if (cie_id == 0)
    {
      if (cur >= record_end)
      {
        off = record_end;
        continue;
      }
      uint8_t version = data[cur++];
      (void)version;

      size_t aug_start = cur;
      while (cur < record_end && data[cur] != 0)
        cur++;
      if (cur >= record_end)
      {
        off = record_end;
        continue;
      }
      const char *aug = (const char *)&data[aug_start];
      cur++;

      uint64_t dummy_u = 0;
      int64_t dummy_s = 0;
      read_uleb(data, record_end, &cur, &dummy_u);
      read_sleb(data, record_end, &cur, &dummy_s);
      read_uleb(data, record_end, &cur, &dummy_u);

      if (version >= 4 && cur + 2 <= record_end)
        cur += 2;

      uint8_t encoding = DW_EH_PE_absptr;
      if (strchr(aug, 'z') != NULL)
      {
        uint64_t aug_len = 0;
        if (read_uleb(data, record_end, &cur, &aug_len))
        {
          size_t aug_end = cur + (size_t)aug_len;
          size_t sub = cur;
          const char *p = aug;
          if (*p == 'z')
            p++;
          while (*p && sub < aug_end)
          {
            if (*p == 'R')
            {
              encoding = data[sub++];
            }
            else if (*p == 'L')
            {
              sub++;
            }
            else if (*p == 'P')
            {
              uint8_t enc = 0;
              if (sub < aug_end)
                enc = data[sub++];
              uint64_t tmp = 0;
              size_t tmp_off = sub;
              if (read_encoded_value(data, aug_end, &tmp_off, enc,
                                     sec->addr + sub, info->swap, info->is64, 1, &tmp))
                sub = tmp_off;
              else
                sub = aug_end;
            }
            else if (*p == 'S')
            {

            }
            p++;
          }
          cur = aug_end;
        }
      }

      cie_list_add(&cies, &cie_count, &cie_cap, record_start, encoding);
    }
    else
    {
      uint64_t cie_offset = content_start - cie_id;
      uint8_t encoding = DW_EH_PE_absptr;
      if (!cie_list_find(cies, cie_count, cie_offset, &encoding))
      {
        off = record_end;
        continue;
      }

      if (encoding != DW_EH_PE_omit)
      {
        uint64_t start = 0;
        uint64_t range = 0;
        size_t start_off = cur;
        if (read_encoded_value(data, record_end, &cur, encoding,
                               sec->addr + start_off, info->swap, info->is64, 1, &start))
        {
          uint8_t range_enc = (encoding & 0x0f);
          if (range_enc == DW_EH_PE_omit)
          {

          }
          else if (read_encoded_value(data, record_end, &cur, range_enc,
                                      0, info->swap, info->is64, 0, &range))
          {
            if (range > 0)
            {
              uint64_t adj = adjust_address(start, info->base_vmaddr, (info->filetype == MH_EXECUTE && (info->flags & MH_PIE) == 0));
              for (size_t i = 0; i < list->count; i++)
              {
                if (list->items[i].addr == adj && list->items[i].size == 0)
                  list->items[i].size = (uint32_t)range;
              }
            }
          }
        }
      }
    }

    off = record_end;
  }

  free(cies);
}

static int parse_fat_slice(int fd, uint32_t fileoffset, uint32_t *out_offset, uint32_t *out_size)
{
  uint32_t magic = 0;
  if (!read_at(fd, fileoffset, &magic, sizeof(magic)))
    return 0;

  if (magic != FAT_MAGIC && magic != FAT_CIGAM && magic != FAT_MAGIC_64 && magic != FAT_CIGAM_64)
  {
    *out_offset = fileoffset;
    if (out_size)
      *out_size = 0;
    return 1;
  }

  int swap = (magic == FAT_CIGAM || magic == FAT_CIGAM_64);
  int is64 = (magic == FAT_MAGIC_64 || magic == FAT_CIGAM_64);

  struct fat_header fh;
  if (!read_at(fd, fileoffset, &fh, sizeof(fh)))
    return 0;
  uint32_t nfat = swap32_if(fh.nfat_arch, swap);

  uint32_t best_off = 0;
  uint32_t best_size = 0;
  int found = 0;

  for (uint32_t i = 0; i < nfat; i++)
  {
    if (is64)
    {
      struct fat_arch_64 fa;
      uint64_t off = fileoffset + sizeof(fh) + (uint64_t)i * sizeof(fa);
      if (!read_at(fd, off, &fa, sizeof(fa)))
        break;

      cpu_type_t cputype = (cpu_type_t)swap32_if(fa.cputype, swap);
      if (cputype == CPU_TYPE_ARM64 || cputype == CPU_TYPE_ARM64_32)
      {
        best_off = swap32_if((uint32_t)fa.offset, swap);
        best_size = swap32_if((uint32_t)fa.size, swap);
        found = 1;
        break;
      }

      if (!found)
      {
        best_off = swap32_if((uint32_t)fa.offset, swap);
        best_size = swap32_if((uint32_t)fa.size, swap);
      }
    }
    else
    {
      struct fat_arch fa;
      uint64_t off = fileoffset + sizeof(fh) + (uint64_t)i * sizeof(fa);
      if (!read_at(fd, off, &fa, sizeof(fa)))
        break;

      cpu_type_t cputype = (cpu_type_t)swap32_if(fa.cputype, swap);
      if (cputype == CPU_TYPE_ARM64 || cputype == CPU_TYPE_ARM64_32)
      {
        best_off = swap32_if(fa.offset, swap);
        best_size = swap32_if(fa.size, swap);
        found = 1;
        break;
      }

      if (!found)
      {
        best_off = swap32_if(fa.offset, swap);
        best_size = swap32_if(fa.size, swap);
      }
    }
  }

  if (!best_off)
    return 0;

  *out_offset = fileoffset + best_off;
  if (out_size)
    *out_size = best_size;
  return 1;
}

static int parse_macho_header(int fd, uint32_t fileoffset, MachOInfo *info)
{
  uint32_t magic = 0;
  if (!read_at(fd, fileoffset, &magic, sizeof(magic)))
    return 0;

  memset(info, 0, sizeof(*info));

  if (magic == MH_MAGIC_64 || magic == MH_CIGAM_64)
  {
    struct mach_header_64 mh;
    if (!read_at(fd, fileoffset, &mh, sizeof(mh)))
      return 0;
    info->swap = (magic == MH_CIGAM_64);
    info->is64 = 1;
    info->ncmds = swap32_if(mh.ncmds, info->swap);
    info->sizeofcmds = swap32_if(mh.sizeofcmds, info->swap);
    info->filetype = swap32_if(mh.filetype, info->swap);
    info->flags = swap32_if(mh.flags, info->swap);
  }
  else if (magic == MH_MAGIC || magic == MH_CIGAM)
  {
    struct mach_header mh;
    if (!read_at(fd, fileoffset, &mh, sizeof(mh)))
      return 0;
    info->swap = (magic == MH_CIGAM);
    info->is64 = 0;
    info->ncmds = swap32_if(mh.ncmds, info->swap);
    info->sizeofcmds = swap32_if(mh.sizeofcmds, info->swap);
    info->filetype = swap32_if(mh.filetype, info->swap);
    info->flags = swap32_if(mh.flags, info->swap);
  }
  else
    return 0;

  if (info->sizeofcmds == 0 || info->ncmds == 0)
    return 0;

  uint64_t cmds_offset = fileoffset + (info->is64 ? sizeof(struct mach_header_64) : sizeof(struct mach_header));
  unsigned char *cmds = (unsigned char *)malloc(info->sizeofcmds);
  if (!cmds)
    return 0;

  if (!read_at(fd, cmds_offset, cmds, info->sizeofcmds))
  {
    free(cmds);
    return 0;
  }

  uint64_t cursor = 0;
  for (uint32_t i = 0; i < info->ncmds; i++)
  {
    if (cursor + sizeof(struct load_command) > info->sizeofcmds)
      break;

    struct load_command *lc = (struct load_command *)&cmds[cursor];
    uint32_t cmd = swap32_if(lc->cmd, info->swap);
    uint32_t cmdsize = swap32_if(lc->cmdsize, info->swap);
    if (cmdsize < sizeof(struct load_command) || cursor + cmdsize > info->sizeofcmds)
      break;

    if (cmd == LC_SEGMENT_64 && info->is64)
    {
      struct segment_command_64 seg;
      memcpy(&seg, lc, sizeof(seg));
      seg.vmaddr = swap64_if(seg.vmaddr, info->swap);
      seg.vmsize = swap64_if(seg.vmsize, info->swap);
      seg.fileoff = swap64_if(seg.fileoff, info->swap);
      seg.filesize = swap64_if(seg.filesize, info->swap);
      seg.nsects = swap32_if(seg.nsects, info->swap);
      seg.flags = swap32_if(seg.flags, info->swap);

      if (seg.fileoff == 0 && info->base_vmaddr == 0)
        info->base_vmaddr = seg.vmaddr;

      if (strncmp(seg.segname, "__TEXT", 16) == 0 && info->text_vmaddr == 0)
        info->text_vmaddr = seg.vmaddr;

      size_t sect_offset = cursor + sizeof(struct segment_command_64);
      for (uint32_t s = 0; s < seg.nsects; s++)
      {
        if (sect_offset + sizeof(struct section_64) > cursor + cmdsize)
          break;
        struct section_64 sec;
        memcpy(&sec, &cmds[sect_offset], sizeof(sec));
        MachSection ms;
        memset(&ms, 0, sizeof(ms));
        memcpy(ms.segname, sec.segname, 16);
        memcpy(ms.sectname, sec.sectname, 16);
        ms.segname[16] = 0;
        ms.sectname[16] = 0;
        ms.addr = swap64_if(sec.addr, info->swap);
        ms.size = swap64_if(sec.size, info->swap);
        ms.flags = swap32_if(sec.flags, info->swap);
        ms.reserved1 = swap32_if(sec.reserved1, info->swap);
        ms.reserved2 = swap32_if(sec.reserved2, info->swap);
        ms.fileoff = swap32_if(sec.offset, info->swap);
        section_list_append(&info->sections, &ms);
        sect_offset += sizeof(struct section_64);
      }
    }
    else if (cmd == LC_SEGMENT && !info->is64)
    {
      struct segment_command seg;
      memcpy(&seg, lc, sizeof(seg));
      seg.vmaddr = swap32_if(seg.vmaddr, info->swap);
      seg.vmsize = swap32_if(seg.vmsize, info->swap);
      seg.fileoff = swap32_if(seg.fileoff, info->swap);
      seg.filesize = swap32_if(seg.filesize, info->swap);
      seg.nsects = swap32_if(seg.nsects, info->swap);
      seg.flags = swap32_if(seg.flags, info->swap);

      if (seg.fileoff == 0 && info->base_vmaddr == 0)
        info->base_vmaddr = seg.vmaddr;

      if (strncmp(seg.segname, "__TEXT", 16) == 0 && info->text_vmaddr == 0)
        info->text_vmaddr = seg.vmaddr;

      size_t sect_offset = cursor + sizeof(struct segment_command);
      for (uint32_t s = 0; s < seg.nsects; s++)
      {
        if (sect_offset + sizeof(struct section) > cursor + cmdsize)
          break;
        struct section sec;
        memcpy(&sec, &cmds[sect_offset], sizeof(sec));
        MachSection ms;
        memset(&ms, 0, sizeof(ms));
        memcpy(ms.segname, sec.segname, 16);
        memcpy(ms.sectname, sec.sectname, 16);
        ms.segname[16] = 0;
        ms.sectname[16] = 0;
        ms.addr = swap32_if(sec.addr, info->swap);
        ms.size = swap32_if(sec.size, info->swap);
        ms.flags = swap32_if(sec.flags, info->swap);
        ms.reserved1 = swap32_if(sec.reserved1, info->swap);
        ms.reserved2 = swap32_if(sec.reserved2, info->swap);
        ms.fileoff = swap32_if(sec.offset, info->swap);
        section_list_append(&info->sections, &ms);
        sect_offset += sizeof(struct section);
      }
    }
    else if (cmd == LC_SYMTAB)
    {
      struct symtab_command st;
      memcpy(&st, lc, sizeof(st));
      st.cmd = cmd;
      st.cmdsize = cmdsize;
      st.symoff = swap32_if(st.symoff, info->swap);
      st.nsyms = swap32_if(st.nsyms, info->swap);
      st.stroff = swap32_if(st.stroff, info->swap);
      st.strsize = swap32_if(st.strsize, info->swap);
      info->symtab = st;
    }
    else if (cmd == LC_DYSYMTAB)
    {
      struct dysymtab_command dt;
      memcpy(&dt, lc, sizeof(dt));
      dt.cmd = cmd;
      dt.cmdsize = cmdsize;
      dt.ilocalsym = swap32_if(dt.ilocalsym, info->swap);
      dt.nlocalsym = swap32_if(dt.nlocalsym, info->swap);
      dt.iextdefsym = swap32_if(dt.iextdefsym, info->swap);
      dt.nextdefsym = swap32_if(dt.nextdefsym, info->swap);
      dt.iundefsym = swap32_if(dt.iundefsym, info->swap);
      dt.nundefsym = swap32_if(dt.nundefsym, info->swap);
      dt.tocoff = swap32_if(dt.tocoff, info->swap);
      dt.ntoc = swap32_if(dt.ntoc, info->swap);
      dt.modtaboff = swap32_if(dt.modtaboff, info->swap);
      dt.nmodtab = swap32_if(dt.nmodtab, info->swap);
      dt.extrefsymoff = swap32_if(dt.extrefsymoff, info->swap);
      dt.nextrefsyms = swap32_if(dt.nextrefsyms, info->swap);
      dt.indirectsymoff = swap32_if(dt.indirectsymoff, info->swap);
      dt.nindirectsyms = swap32_if(dt.nindirectsyms, info->swap);
      dt.extreloff = swap32_if(dt.extreloff, info->swap);
      dt.nextrel = swap32_if(dt.nextrel, info->swap);
      dt.locreloff = swap32_if(dt.locreloff, info->swap);
      dt.nlocrel = swap32_if(dt.nlocrel, info->swap);
      info->dysymtab = dt;
    }
    else if (cmd == LC_DYLD_INFO || cmd == LC_DYLD_INFO_ONLY)
    {
      struct dyld_info_command di;
      memcpy(&di, lc, sizeof(di));
      di.cmd = cmd;
      di.cmdsize = cmdsize;
      di.export_off = swap32_if(di.export_off, info->swap);
      di.export_size = swap32_if(di.export_size, info->swap);
      info->dyld_info = di;
    }
    else if (cmd == LC_DYLD_EXPORTS_TRIE)
    {
      struct linkedit_data_command le;
      memcpy(&le, lc, sizeof(le));
      le.cmd = cmd;
      le.cmdsize = cmdsize;
      le.dataoff = swap32_if(le.dataoff, info->swap);
      le.datasize = swap32_if(le.datasize, info->swap);
      info->exports_trie = le;
    }
    else if (cmd == LC_FUNCTION_STARTS)
    {
      struct linkedit_data_command le;
      memcpy(&le, lc, sizeof(le));
      le.cmd = cmd;
      le.cmdsize = cmdsize;
      le.dataoff = swap32_if(le.dataoff, info->swap);
      le.datasize = swap32_if(le.datasize, info->swap);
      info->function_starts = le;
    }

    cursor += cmdsize;
  }

  free(cmds);
  return info->symtab.cmd == LC_SYMTAB;
}

static int read_symtab_data(int fd, uint32_t fileoffset, const MachOInfo *info,
                            unsigned char **symtab, size_t *symtab_size,
                            unsigned char **strtab, size_t *strtab_size)
{
  if (!info->symtab.symoff || !info->symtab.nsyms || !info->symtab.stroff || !info->symtab.strsize)
    return 0;

  size_t nlist_size = info->is64 ? sizeof(struct nlist_64) : sizeof(struct nlist);
  size_t symtab_bytes = info->symtab.nsyms * nlist_size;
  size_t strtab_bytes = info->symtab.strsize;

  *symtab = (unsigned char *)malloc(symtab_bytes);
  *strtab = (unsigned char *)malloc(strtab_bytes);
  if (!*symtab || !*strtab)
  {
    free(*symtab);
    free(*strtab);
    *symtab = NULL;
    *strtab = NULL;
    return 0;
  }

  if (!read_at(fd, (uint64_t)fileoffset + info->symtab.symoff, *symtab, symtab_bytes))
  {
    free(*symtab);
    free(*strtab);
    *symtab = NULL;
    *strtab = NULL;
    return 0;
  }
  if (!read_at(fd, (uint64_t)fileoffset + info->symtab.stroff, *strtab, strtab_bytes))
  {
    free(*symtab);
    free(*strtab);
    *symtab = NULL;
    *strtab = NULL;
    return 0;
  }

  *symtab_size = symtab_bytes;
  *strtab_size = strtab_bytes;
  return 1;
}

static int get_nlist_entry(const unsigned char *symtab, size_t nsyms, size_t index,
                           int is64, int swap, struct nlist_64 *out)
{
  if (index >= nsyms)
    return 0;

  if (is64)
  {
    struct nlist_64 n;
    memcpy(&n, symtab + index * sizeof(struct nlist_64), sizeof(n));
    n.n_strx = swap32_if(n.n_strx, swap);
    n.n_desc = swap16_if(n.n_desc, swap);
    n.n_value = swap64_if(n.n_value, swap);
    *out = n;
    return 1;
  }
  else
  {
    struct nlist n32;
    memcpy(&n32, symtab + index * sizeof(struct nlist), sizeof(n32));
    struct nlist_64 n;
    memset(&n, 0, sizeof(n));
    n.n_strx = swap32_if(n32.n_strx, swap);
    n.n_type = n32.n_type;
    n.n_sect = n32.n_sect;
    n.n_desc = swap16_if(n32.n_desc, swap);
    n.n_value = swap32_if(n32.n_value, swap);
    *out = n;
    return 1;
  }
}

static const char *get_symbol_name(const unsigned char *strtab, size_t strtab_size, uint32_t strx)
{
  if (!strtab || strx >= strtab_size)
    return NULL;
  return (const char *)&strtab[strx];
}

static int parse_exports_trie(const unsigned char *data, size_t size, size_t node_offset,
                              char **namebuf, size_t *name_cap, size_t name_len,
                              uint64_t text_base, int is_arm,
                              SymbolList *symbols, AddrSet *addrset,
                              uint64_t base_vmaddr, int isexe)
{
  if (node_offset >= size)
    return 1;

  char *name = *namebuf;
  size_t cap = *name_cap;

  size_t offset = node_offset;
  uint64_t terminal_size = 0;
  if (!read_uleb(data, size, &offset, &terminal_size))
    return 0;

  size_t children_offset = offset + (size_t)terminal_size;
  if (children_offset > size)
    return 0;

  if (terminal_size)
  {
    uint64_t flags = 0;
    if (!read_uleb(data, size, &offset, &flags))
      return 0;

    const char *import_name = NULL;
    uint64_t address = 0;
    if (flags & EXPORT_SYMBOL_FLAGS_REEXPORT)
    {
      uint64_t ordinal = 0;
      if (!read_uleb(data, size, &offset, &ordinal))
        return 0;
      import_name = read_cstr(data, size, &offset);
      (void)ordinal;
    }
    else
    {
      if (!read_uleb(data, size, &offset, &address))
        return 0;
      address += text_base;
      if (flags & EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER)
      {
        uint64_t resolver = 0;
        if (!read_uleb(data, size, &offset, &resolver))
          return 0;
        (void)resolver;
      }
      if (is_arm && (address & 1))
        address &= 0xfffffffffffffffeULL;
    }

    if (name_len > 1 && (flags == 0 || (flags & EXPORT_SYMBOL_FLAGS_REEXPORT)))
    {
      const char *final_name = name;
      if (final_name[0] == '_')
        final_name++;

      if (!(flags & EXPORT_SYMBOL_FLAGS_REEXPORT))
      {
        uint64_t adj = adjust_address(address, base_vmaddr, isexe);
        if (!addrset_contains(addrset, adj))
        {
          if (symbol_list_append(symbols, adj, 0, (uint32_t)flags, final_name))
            addrset_insert(addrset, adj);
        }
      }
      (void)import_name;
    }
  }

  if (children_offset >= size)
    return 1;

  uint8_t child_count = data[children_offset++];
  for (uint8_t i = 0; i < child_count; i++)
  {
    const char *edge = read_cstr(data, size, &children_offset);
    if (!edge)
      return 0;

    size_t edge_len = strlen(edge);
    if (name_len + edge_len + 1 > cap)
    {
      size_t newcap = cap * 2;
      while (name_len + edge_len + 1 > newcap)
        newcap *= 2;
      char *newbuf = (char *)realloc(name, newcap);
      if (!newbuf)
        return 0;
      name = newbuf;
      cap = newcap;
      *namebuf = newbuf;
      *name_cap = newcap;
    }

    memcpy(name + name_len, edge, edge_len + 1);
    size_t next_len = name_len + edge_len;

    uint64_t child_node = 0;
    if (!read_uleb(data, size, &children_offset, &child_node))
      return 0;

    if (child_node)
    {
      if (!parse_exports_trie(data, size, (size_t)child_node, namebuf, name_cap, next_len,
                              text_base, is_arm, symbols, addrset, base_vmaddr, isexe))
        return 0;
    }

    name = *namebuf;
    name[name_len] = 0;
  }

  return 1;
}

static int build_uncompressed_buffer(const SymbolList *list, unsigned char **out, size_t *out_size)
{
  size_t total = 0;
  for (size_t i = 0; i < list->count; i++)
  {
    size_t name_len = strlen(list->items[i].name);
    if (name_len > 255)
      name_len = 255;
    total += sizeof(symbolinfo) + name_len;
  }

  if (total == 0)
    return 0;

  unsigned char *buf = (unsigned char *)malloc(total);
  if (!buf)
    return 0;

  size_t pos = 0;
  for (size_t i = 0; i < list->count; i++)
  {
    size_t name_len = strlen(list->items[i].name);
    if (name_len > 255)
      name_len = 255;

    symbolinfo si;
    si.address = list->items[i].addr;
    si.size = (int)list->items[i].size;
    si.type = (int)list->items[i].type;
    si.namelength = (unsigned char)name_len;

    memcpy(&buf[pos], &si, sizeof(si));
    pos += sizeof(si);
    memcpy(&buf[pos], list->items[i].name, name_len);
    pos += name_len;
  }

  *out = buf;
  *out_size = total;
  return 1;
}

static int cmp_u64(const void *a, const void *b)
{
  uint64_t va = *(const uint64_t *)a;
  uint64_t vb = *(const uint64_t *)b;
  if (va < vb)
    return -1;
  if (va > vb)
    return 1;
  return 0;
}

static int compress_symbol_list(const SymbolList *list, int isexe, unsigned char **output)
{
  unsigned char *uncompressed = NULL;
  size_t uncompressed_size = 0;
  if (!build_uncompressed_buffer(list, &uncompressed, &uncompressed_size))
    return -1;

  uLongf bound = compressBound((uLong)uncompressed_size);
  if (bound + (3 * sizeof(uint32_t)) > UINT32_MAX)
  {
    free(uncompressed);
    return -1;
  }

  unsigned char *out = (unsigned char *)malloc(bound + (3 * sizeof(uint32_t)));
  if (!out)
  {
    free(uncompressed);
    return -1;
  }

  uLongf comp_size = bound;
  int z = compress2(out + (3 * sizeof(uint32_t)), &comp_size, uncompressed, (uLong)uncompressed_size, 9);
  free(uncompressed);
  if (z != Z_OK)
  {
    free(out);
    return -1;
  }

  *(uint32_t *)&out[0] = (uint32_t)isexe;
  *(uint32_t *)&out[4] = (uint32_t)(comp_size + (3 * sizeof(uint32_t)));
  *(uint32_t *)&out[8] = (uint32_t)uncompressed_size;

  *output = out;
  return 0;
}

int GetSymbolListFromFile(char *filename, uint32_t fileoffset, unsigned char **output)
{
  int fd;
  MachOInfo info;
  unsigned char *symtab = NULL;
  unsigned char *strtab = NULL;
  size_t symtab_size = 0;
  size_t strtab_size = 0;

  *output = NULL;

  fd = open(filename, O_RDONLY);
  if (fd == -1)
    return -1;

  uint32_t slice_offset = 0;
  uint32_t slice_size = 0;
  if (!parse_fat_slice(fd, fileoffset, &slice_offset, &slice_size))
  {
    close(fd);
    return -1;
  }

  if (!parse_macho_header(fd, slice_offset, &info))
  {
    section_list_free(&info.sections);
    close(fd);
    return -1;
  }

  if (info.text_vmaddr == 0)
    info.text_vmaddr = info.base_vmaddr;
  if (info.base_vmaddr == 0)
    info.base_vmaddr = info.text_vmaddr;

  if (!read_symtab_data(fd, slice_offset, &info, &symtab, &symtab_size, &strtab, &strtab_size))
  {
    section_list_free(&info.sections);
    close(fd);
    free(symtab);
    free(strtab);
    return -1;
  }

  int isexe = (info.filetype == MH_EXECUTE && (info.flags & MH_PIE) == 0);

  SymbolList list;
  memset(&list, 0, sizeof(list));

  AddrSet addrset;
  memset(&addrset, 0, sizeof(addrset));
  addrset_init(&addrset, 16384);

  size_t nsyms = info.symtab.nsyms;
  for (size_t i = 0; i < nsyms; i++)
  {
    struct nlist_64 n;
    if (!get_nlist_entry(symtab, nsyms, i, info.is64, info.swap, &n))
      continue;

    if (n.n_value == 0)
      continue;

    const char *name = get_symbol_name(strtab, strtab_size, n.n_strx);
    if (!name || !name[0])
      continue;

    uint64_t addr = adjust_address(n.n_value, info.base_vmaddr, isexe);
    symbol_list_append(&list, addr, 0, n.n_type, name);
    addrset_insert(&addrset, addr);
  }


  uint32_t trie_off = 0;
  uint32_t trie_size = 0;
  if (info.exports_trie.dataoff && info.exports_trie.datasize)
  {
    trie_off = info.exports_trie.dataoff;
    trie_size = info.exports_trie.datasize;
  }
  else if (info.dyld_info.export_off && info.dyld_info.export_size)
  {
    trie_off = info.dyld_info.export_off;
    trie_size = info.dyld_info.export_size;
  }

  if (trie_off && trie_size)
  {
    unsigned char *trie_data = (unsigned char *)malloc(trie_size);
    if (trie_data && read_at(fd, (uint64_t)slice_offset + trie_off, trie_data, trie_size))
    {
      size_t name_cap = 256;
      char *namebuf = (char *)malloc(name_cap);
      if (namebuf)
      {
        namebuf[0] = 0;
        parse_exports_trie(trie_data, trie_size, 0, &namebuf, &name_cap, 0, info.text_vmaddr,
                           0, &list, &addrset, info.base_vmaddr, isexe);
        free(namebuf);
      }
    }
    free(trie_data);
  }


  if (info.function_starts.dataoff && info.function_starts.datasize && info.text_vmaddr)
  {
    unsigned char *fs_data = (unsigned char *)malloc(info.function_starts.datasize);
    if (fs_data && read_at(fd, (uint64_t)slice_offset + info.function_starts.dataoff, fs_data,
                           info.function_starts.datasize))
    {
      size_t fs_count = 0;
      size_t fs_cap = 256;
      uint64_t *fs_addrs = (uint64_t *)malloc(fs_cap * sizeof(uint64_t));
      if (fs_addrs)
      {
        size_t off = 0;
        uint64_t addr = info.text_vmaddr;
        while (off < info.function_starts.datasize)
        {
          uint64_t delta = 0;
          if (!read_uleb(fs_data, info.function_starts.datasize, &off, &delta))
            break;
          if (delta == 0)
            break;
          addr += delta;
          uint64_t rel = adjust_address(addr, info.base_vmaddr, isexe);
          if (fs_count >= fs_cap)
          {
            size_t newcap = fs_cap * 2;
            uint64_t *newp = (uint64_t *)realloc(fs_addrs, newcap * sizeof(uint64_t));
            if (!newp)
              break;
            fs_addrs = newp;
            fs_cap = newcap;
          }
          fs_addrs[fs_count++] = rel;
        }

        if (fs_count > 1)
        {
          qsort(fs_addrs, fs_count, sizeof(uint64_t), cmp_u64);

          for (size_t i = 0; i + 1 < fs_count; i++)
          {
            uint64_t start = fs_addrs[i];
            uint64_t end = fs_addrs[i + 1];
            uint64_t size = (end > start) ? (end - start) : 0;
            if (size == 0)
              continue;
            for (size_t s = 0; s < list.count; s++)
            {
              if (list.items[s].addr == start && list.items[s].size == 0)
                list.items[s].size = (uint32_t)size;
            }
          }
        }

        free(fs_addrs);
      }
    }
    free(fs_data);
  }


  {
    MachSection eh_sec;
    if (find_section_by_name(&info, "__eh_frame", &eh_sec) && eh_sec.size > 0)
    {
      unsigned char *eh_data = (unsigned char *)malloc((size_t)eh_sec.size);
      if (eh_data && read_at(fd, (uint64_t)slice_offset + eh_sec.fileoff, eh_data, (size_t)eh_sec.size))
        apply_eh_frame_sizes(eh_data, (size_t)eh_sec.size, &eh_sec, &info, &list);
      free(eh_data);
    }
  }


  if (info.dysymtab.nindirectsyms && info.dysymtab.indirectsymoff && info.sections.count)
  {
    size_t indirect_count = info.dysymtab.nindirectsyms;
    size_t indirect_bytes = indirect_count * sizeof(uint32_t);
    uint32_t *indirect = (uint32_t *)malloc(indirect_bytes);
    if (indirect && read_at(fd, (uint64_t)slice_offset + info.dysymtab.indirectsymoff, indirect, indirect_bytes))
    {
      for (size_t i = 0; i < indirect_count; i++)
        indirect[i] = swap32_if(indirect[i], info.swap);

      for (size_t s = 0; s < info.sections.count; s++)
      {
        MachSection *sec = &info.sections.items[s];
        if ((sec->flags & SECTION_TYPE) != S_SYMBOL_STUBS)
          continue;
        if (sec->reserved2 == 0)
          continue;

        uint32_t stub_size = sec->reserved2;
        uint32_t num_stubs = (uint32_t)(sec->size / stub_size);
        uint32_t index_offset = sec->reserved1;

        for (uint32_t j = 0; j < num_stubs; j++)
        {
          uint32_t idx = index_offset + j;
          if (idx >= indirect_count)
            break;

          uint32_t sym_index = indirect[idx];
          if (sym_index & (INDIRECT_SYMBOL_ABS | INDIRECT_SYMBOL_LOCAL))
            continue;

          struct nlist_64 n;
          if (!get_nlist_entry(symtab, nsyms, sym_index, info.is64, info.swap, &n))
            continue;

          const char *name = get_symbol_name(strtab, strtab_size, n.n_strx);
          if (!name || !name[0])
            continue;

          uint64_t stub_addr = sec->addr + (uint64_t)j * stub_size;
          uint64_t addr = adjust_address(stub_addr, info.base_vmaddr, isexe);
          if (addrset_contains(&addrset, addr))
            continue;

          if (symbol_list_append(&list, addr, stub_size, N_SECT, name))
            addrset_insert(&addrset, addr);
        }
      }
    }
    free(indirect);
  }

  int r = compress_symbol_list(&list, isexe, output);

  addrset_free(&addrset);
  symbol_list_free(&list);
  section_list_free(&info.sections);
  free(symtab);
  free(strtab);
  close(fd);

  return r;
}

typedef struct _fsc
{
  uintptr_t modulebase;
  symcallback originalCallback;
  void *originalContext;
} FindSymbolContext, *PFindSymbolContext;

void FindSymbol_internal(uintptr_t address, char *symbolname, PFindSymbolContext context)
{
  context->originalCallback(context->modulebase + address, symbolname, context->originalContext);
}

int FindSymbol(HANDLE hProcess, char *symbolname, symcallback cb, void *context)
{
  HANDLE ths;
  ModuleListEntry mle;

  if (GetHandleType(hProcess) == htProcesHandle)
  {
    FindSymbolContext c;
    c.originalCallback = cb;
    c.originalContext = context;
    PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);
    if (p == NULL)
      return FALSE;

    ths = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, p->pid);

    if (Module32First(ths, &mle))
      do
      {
        if (mle.part == 0)
        {
          int fd;
          uint32_t fileoffset = mle.fileOffset;

          c.modulebase = (uintptr_t)mle.baseAddress;

          fd = open(mle.moduleName, O_RDONLY);
          if (fd == -1)
            continue;

          unsigned char *symtab = NULL;
          unsigned char *strtab = NULL;
          size_t symtab_size = 0;
          size_t strtab_size = 0;
          MachOInfo info;
          uint32_t slice_offset = 0;
          uint32_t slice_size = 0;

          if (!parse_fat_slice(fd, fileoffset, &slice_offset, &slice_size))
          {
            close(fd);
            continue;
          }

          if (!parse_macho_header(fd, slice_offset, &info))
          {
            close(fd);
            continue;
          }

          if (read_symtab_data(fd, slice_offset, &info, &symtab, &symtab_size, &strtab, &strtab_size))
          {
            size_t nsyms = info.symtab.nsyms;
            for (size_t i = 0; i < nsyms; i++)
            {
              struct nlist_64 n;
              if (!get_nlist_entry(symtab, nsyms, i, info.is64, info.swap, &n))
                continue;
              if (n.n_value == 0)
                continue;
              const char *name = get_symbol_name(strtab, strtab_size, n.n_strx);
              if (!name)
                continue;
              if (strcmp(name, symbolname) == 0)
              {
                uint64_t addr = adjust_address(n.n_value, info.base_vmaddr, 0);
                FindSymbol_internal((uintptr_t)addr, (char *)name, &c);
                break;
              }
            }
          }

          free(symtab);
          free(strtab);
          section_list_free(&info.sections);
          close(fd);
        }
      } while (Module32Next(ths, &mle));

    CloseHandle(ths);
  }

  return 0;
}

```

`ceserver-ios/jailbreak/symbols.h`:

```h
#ifndef SYMBOLS_H_
#define SYMBOLS_H_

#include "api.h"

typedef void (*symcallback)(uintptr_t address, char *symbolname, void *context);

int GetSymbolListFromFile(char *filename, uint32_t fileoffset, unsigned char **output);
int FindSymbol(HANDLE hProcess, char *symbolname, symcallback cb, void *context);

#endif

```

`ceserver-ios/jailed/Makefile`:

```
TARGET := iphone:clang:latest:12.0
ARCHS := arm64
include $(THEOS)/makefiles/common.mk

LIBRARY_NAME = ceserver

ceserver_FILES = ceserver.c api.c debugger.c porthelp.c symbols.c
ceserver_CFLAGS += -fblocks
ceserver_CODESIGN_FLAGS = -Sentitlements.plist
ceserver_LIBRARIES = z

include $(THEOS_MAKE_PATH)/library.mk

```

`ceserver-ios/jailed/api.c`:

```c
#include "api.h"

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dlfcn.h>
#include <limits.h>
#include <mach-o/loader.h>
#include <mach/mach_host.h>
#include <mach/vm_region.h>
#include <mach/mach_vm.h>
#include <pthread.h>
#include <sys/param.h>
#include <sys/sysctl.h>
#include <uuid/uuid.h>

#include "debugger.h"

extern kern_return_t mach_vm_read_overwrite(vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size,
                                            mach_vm_address_t data, mach_vm_size_t *outsize);
extern kern_return_t mach_vm_write(vm_map_t target_task, mach_vm_address_t address, vm_offset_t data, mach_msg_type_number_t dataCnt);

int debug_log(const char *format, ...)
{
  (void)format;
  return 0;
}

int getArchitecture(HANDLE hProcess)
{
  if (GetHandleType(hProcess) == htProcesHandle)
  {

    return 3;
  }

  return -1;
}

static int SearchHandleListProcessCallback(PProcessData data, int *pid)
{
  return (data->pid == *pid);
}

static int read_target(task_t task, mach_vm_address_t address, void *buf, size_t size)
{
  if (address == 0 || buf == NULL || size == 0)
    return 0;
  if (size > (size_t)INT_MAX)
    return 0;

  mach_vm_size_t outsize = 0;
  kern_return_t kr = mach_vm_read_overwrite(task, address, (mach_vm_size_t)size, (mach_vm_address_t)buf, &outsize);
  if (kr != KERN_SUCCESS)
    return 0;

  if (outsize > (mach_vm_size_t)INT_MAX)
    return 0;

  return (int)outsize;
}

static int read_target_exact(task_t task, mach_vm_address_t address, void *buf, size_t size)
{
  return read_target(task, address, buf, size) == (int)size;
}

static int is_macho64_magic(uint32_t magic)
{
  return (magic == MH_MAGIC_64) || (magic == MH_CIGAM_64);
}

static uint32_t bswap32_if_needed(uint32_t x, int swapped)
{
  return swapped ? __builtin_bswap32(x) : x;
}

static uint64_t bswap64_if_needed(uint64_t x, int swapped)
{
  return swapped ? __builtin_bswap64(x) : x;
}

typedef void *dyld_process_info;
typedef void *(*dyld_process_info_create_fn)(task_t task, uint64_t timestamp, kern_return_t *kernelError);
typedef void (^dyld_process_info_image_callback)(uint64_t machHeaderAddress, const uuid_t uuid, const char *path);
typedef void (*dyld_process_info_for_each_image_fn)(dyld_process_info info, dyld_process_info_image_callback callback);
typedef void (*dyld_process_info_release_fn)(dyld_process_info info);

typedef struct
{
  dyld_process_info_create_fn create;
  dyld_process_info_for_each_image_fn for_each_image;
  dyld_process_info_release_fn release;
} DyldSPI;

static DyldSPI dyld_spi = {0};
static pthread_once_t dyld_spi_once = PTHREAD_ONCE_INIT;

typedef struct
{
  uint64_t load_address;
  char *path;
} DyldImageInfo;

typedef struct
{
  DyldImageInfo *items;
  size_t count;
  size_t cap;
} DyldImageList;

typedef struct
{
  uint64_t *items;
  size_t count;
  size_t cap;
} AddressSet;

static void init_dyld_spi(void)
{
  dyld_spi.create = (dyld_process_info_create_fn)dlsym(RTLD_DEFAULT, "_dyld_process_info_create");
  dyld_spi.for_each_image = (dyld_process_info_for_each_image_fn)dlsym(RTLD_DEFAULT, "_dyld_process_info_for_each_image");
  dyld_spi.release = (dyld_process_info_release_fn)dlsym(RTLD_DEFAULT, "_dyld_process_info_release");
}

static void dyld_image_list_free(DyldImageList *list)
{
  if (!list || !list->items)
    return;

  for (size_t i = 0; i < list->count; i++)
    free(list->items[i].path);
  free(list->items);
  list->items = NULL;
  list->count = 0;
  list->cap = 0;
}

static int dyld_image_list_append(DyldImageList *list, uint64_t load_address, const char *path)
{
  if (!list)
    return 0;

  if (list->count >= list->cap)
  {
    size_t newcap = (list->cap == 0) ? 64 : list->cap * 2;
    void *newp = realloc(list->items, newcap * sizeof(DyldImageInfo));
    if (!newp)
      return 0;
    list->items = (DyldImageInfo *)newp;
    list->cap = newcap;
  }

  DyldImageInfo *entry = &list->items[list->count++];
  entry->load_address = load_address;
  entry->path = strdup(path);
  if (!entry->path)
    return 0;
  return 1;
}

static void address_set_free(AddressSet *set)
{
  if (!set)
    return;
  free(set->items);
  set->items = NULL;
  set->count = 0;
  set->cap = 0;
}

static int address_set_add(AddressSet *set, uint64_t addr)
{
  if (!set)
    return -1;

  for (size_t i = 0; i < set->count; i++)
  {
    if (set->items[i] == addr)
      return 0;
  }

  if (set->count >= set->cap)
  {
    size_t newcap = (set->cap == 0) ? 64 : set->cap * 2;
    void *newp = realloc(set->items, newcap * sizeof(uint64_t));
    if (!newp)
      return -1;
    set->items = (uint64_t *)newp;
    set->cap = newcap;
  }

  set->items[set->count++] = addr;
  return 1;
}

static int collect_dyld_spi_images(task_t task, DyldImageList *list)
{
  if (!list)
    return 0;

  pthread_once(&dyld_spi_once, init_dyld_spi);
  if (!dyld_spi.create || !dyld_spi.for_each_image || !dyld_spi.release)
    return 0;

  kern_return_t kr = KERN_FAILURE;
  dyld_process_info info = dyld_spi.create(task, 0, &kr);
  if (!info)
    return 0;

  __block int ok = 1;
  __block AddressSet seen = {0};
  __block DyldImageList *out = list;

  dyld_spi.for_each_image(info, ^(uint64_t machHeaderAddress, const uuid_t uuid, const char *path) {
    (void)uuid;
    if (!ok)
      return;
    uint64_t addr = machHeaderAddress;
    int add = address_set_add(&seen, addr);
    if (add <= 0)
    {
      if (add < 0)
        ok = 0;
      return;
    }
    if (!dyld_image_list_append(out, addr, path))
      ok = 0;
  });

  dyld_spi.release(info);
  address_set_free(&seen);

  if (!ok)
  {
    dyld_image_list_free(list);
    return 0;
  }

  return list->count > 0;
}

static uint64_t get_macho_image_size_64(task_t task, mach_vm_address_t base)
{
  struct mach_header_64 hdr;
  if (!read_target_exact(task, base, &hdr, sizeof(hdr)))
    return 0;

  if (!is_macho64_magic(hdr.magic))
    return 0;

  int swapped = (hdr.magic == MH_CIGAM_64);
  uint32_t ncmds = bswap32_if_needed(hdr.ncmds, swapped);
  uint32_t sizeofcmds = bswap32_if_needed(hdr.sizeofcmds, swapped);

  mach_vm_address_t cursor = base + sizeof(struct mach_header_64);
  mach_vm_address_t end = cursor + (mach_vm_address_t)sizeofcmds;
  if (end < cursor)
    return 0;

  uint64_t min_vmaddr = UINT64_MAX;
  uint64_t max_end = 0;


  if (ncmds > 4096)
    return 0;
  if (sizeofcmds > (16U * 1024U * 1024U))
    return 0;

  for (uint32_t i = 0; i < ncmds; i++)
  {
    struct load_command lc;
    if (cursor + sizeof(struct load_command) > end)
      return 0;

    if (!read_target_exact(task, cursor, &lc, sizeof(lc)))
      return 0;

    uint32_t cmd = bswap32_if_needed(lc.cmd, swapped);
    uint32_t cmdsize = bswap32_if_needed(lc.cmdsize, swapped);
    if (cmdsize < sizeof(struct load_command))
      return 0;
    if (cursor + cmdsize > end)
      return 0;

    if (cmd == LC_SEGMENT_64)
    {
      struct segment_command_64 seg;
      if (cmdsize < sizeof(struct segment_command_64))
        return 0;

      if (!read_target_exact(task, cursor, &seg, sizeof(seg)))
        return 0;


      if (strncmp(seg.segname, "__PAGEZERO", 16) != 0)
      {
        uint64_t vmaddr = bswap64_if_needed(seg.vmaddr, swapped);
        uint64_t vmsize = bswap64_if_needed(seg.vmsize, swapped);

        if (vmaddr < min_vmaddr)
          min_vmaddr = vmaddr;


        if (UINT64_MAX - vmaddr < vmsize)
          return 0;

        uint64_t endaddr = vmaddr + vmsize;
        if (endaddr > max_end)
          max_end = endaddr;
      }
    }

    cursor += cmdsize;
  }

  if (min_vmaddr == UINT64_MAX || max_end <= min_vmaddr)
    return 0;

  return max_end - min_vmaddr;
}

static int get_exec_path_sysctl(int pid, char *out, size_t outcap)
{
  if (outcap == 0)
    return 0;

  out[0] = 0;

  int mib[3] = {CTL_KERN, KERN_PROCARGS2, pid};
  size_t size = 0;
  if (sysctl(mib, 3, NULL, &size, NULL, 0) != 0 || size < sizeof(int))
    return 0;

  char *buf = (char *)malloc(size);
  if (!buf)
    return 0;

  if (sysctl(mib, 3, buf, &size, NULL, 0) != 0 || size < sizeof(int))
  {
    free(buf);
    return 0;
  }


  size_t pos = sizeof(int);
  while (pos < size && buf[pos] == '\0')
    pos++;

  size_t i = 0;
  while (pos < size && buf[pos] != '\0' && i + 1 < outcap)
    out[i++] = buf[pos++];
  out[i] = 0;

  free(buf);
  return i > 0;
}

static uint32_t vm_prot_to_page(uint32_t protectioninfo)
{
  
  int r = (protectioninfo & VM_PROT_READ) ? 1 : 0;
  int w = (protectioninfo & VM_PROT_WRITE) ? 1 : 0;
  int x = (protectioninfo & VM_PROT_EXECUTE) ? 1 : 0;

  if (r && w && x)
    return PAGE_EXECUTE_READWRITE;
  if (r && x)
    return PAGE_EXECUTE_READ;
  if (x)
    return PAGE_EXECUTE;
  if (r && w)
    return PAGE_READWRITE;
  if (w)
    return PAGE_READWRITE;
  if (r)
    return PAGE_READONLY;
  return PAGE_NOACCESS;
}

static uint32_t vm_info_to_type(const vm_region_submap_info_data_64_t *info)
{
#if defined(SM_PRIVATE) && defined(SM_COW) && defined(SM_SHARED)
  switch (info->share_mode)
  {
    case SM_PRIVATE:
    case SM_COW:
      return MEM_PRIVATE;
    case SM_SHARED:
    case SM_TRUESHARED:
#ifdef SM_SHARED_ALIASED
    case SM_SHARED_ALIASED:
#endif
      return MEM_MAPPED;
    default:

      return MEM_PRIVATE;
  }
#else
  (void)info;
  return MEM_PRIVATE;
#endif
}

static uint32_t windows_protection_to_vmprot(uint32_t windowsprotection)
{
  
  switch (windowsprotection)
  {
    case PAGE_NOACCESS:
      return VM_PROT_NONE;
    case PAGE_EXECUTE_READWRITE:
      return VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE;
    case PAGE_EXECUTE_READ:
      return VM_PROT_READ | VM_PROT_EXECUTE;
    case PAGE_EXECUTE:
      return VM_PROT_EXECUTE;
    case PAGE_READWRITE:
      return VM_PROT_READ | VM_PROT_WRITE;
    case PAGE_READONLY:
      return VM_PROT_READ;
    default:
      return 0;
  }
}

static pthread_once_t pagesize_once = PTHREAD_ONCE_INIT;
static uint64_t pagesize_cached = 0;

static void init_pagesize(void)
{
  long p = sysconf(_SC_PAGESIZE);
  if (p > 0)
  {
    uint64_t ps = (uint64_t)p;
    if ((ps & (ps - 1)) == 0)
    {
      pagesize_cached = ps;
      return;
    }
  }

  vm_size_t hostps = 0;
  mach_port_t host = mach_host_self();
  if (host_page_size(host, &hostps) == KERN_SUCCESS && hostps > 0)
  {
    uint64_t ps = (uint64_t)hostps;
    if ((ps & (ps - 1)) == 0)
    {
      pagesize_cached = ps;
      mach_port_deallocate(mach_task_self(), host);
      return;
    }
  }
  mach_port_deallocate(mach_task_self(), host);


  pagesize_cached = 4096;
}

static uint64_t get_page_size(void)
{
  pthread_once(&pagesize_once, init_pagesize);
  return pagesize_cached;
}


static void pageprot_to_perms(uint32_t pageprot, int shared, char perms[5])
{
  perms[0] = perms[1] = perms[2] = '-';
  perms[3] = shared ? 's' : 'p';

  switch (pageprot)
  {
    case PAGE_EXECUTE_READWRITE:
      perms[0] = 'r'; perms[1] = 'w'; perms[2] = 'x'; break;
    case PAGE_EXECUTE_READ:
      perms[0] = 'r'; perms[1] = '-'; perms[2] = 'x'; break;
    case PAGE_EXECUTE:
      perms[0] = '-'; perms[1] = '-'; perms[2] = 'x'; break;
    case PAGE_READWRITE:
      perms[0] = 'r'; perms[1] = 'w'; perms[2] = '-'; break;
    case PAGE_READONLY:
      perms[0] = 'r'; perms[1] = '-'; perms[2] = '-'; break;
    default:
      break;
  }
  perms[4] = 0;
}


static int query_leaf_region(task_t task,
                             mach_vm_address_t probe,
                             mach_vm_address_t *out_base,
                             mach_vm_size_t *out_size,
                             vm_region_submap_info_data_64_t *out_info)
{
  mach_vm_address_t want = probe;
  mach_vm_address_t addr = probe;
  natural_t depth = 0;

  while (1)
  {
    mach_vm_address_t q = addr;
    mach_vm_size_t vmsize = 0;
    vm_region_submap_info_data_64_t info;
    mach_msg_type_number_t info_count = VM_REGION_SUBMAP_INFO_COUNT_64;

    kern_return_t kr = mach_vm_region_recurse(task, &q, &vmsize, &depth, (vm_region_recurse_info_t)&info, &info_count);
    if (kr != KERN_SUCCESS)
      return 0;

    if (!info.is_submap)
    {
      *out_base = q;
      *out_size = vmsize;
      *out_info = info;
      return 1;
    }

    if (++depth > 64)
      return 0;


    if (vmsize != 0 && want >= q && want - q < vmsize)
      addr = want;
    else
      addr = q;
  }
}

int VirtualQueryEx(HANDLE hProcess, void *lpAddress, PRegionInfo rinfo, char *mapsline)
{
  if (mapsline)
    mapsline[0] = 0;

  if (GetHandleType(hProcess) != htProcesHandle)
    return 0;


  if (rinfo == NULL)
    return 0;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);

  uint64_t start = (uint64_t)(uintptr_t)lpAddress;
  uint64_t pagesize = get_page_size();
  if (pagesize == 0 || (pagesize & (pagesize - 1)) != 0)
    return 0;
  uint64_t pagemask = ~(pagesize - 1);
  uint64_t pagebase = start & pagemask;
  mach_vm_address_t probe = (mach_vm_address_t)pagebase;

  mach_vm_address_t region_base = 0;
  mach_vm_size_t vmsize = 0;
  vm_region_submap_info_data_64_t info;

  if (!query_leaf_region(p->task, probe, &region_base, &vmsize, &info))
    return 0;


  if ((uint64_t)region_base > pagebase)
  {
    rinfo->baseaddress = pagebase;
    rinfo->size = (uint64_t)region_base - pagebase;
    rinfo->protection = PAGE_NOACCESS;
    rinfo->type = 0;
    if (mapsline)
    {
      uint64_t region_start = (uint64_t)region_base;
      uint64_t region_size = (uint64_t)vmsize;
      if (UINT64_MAX - region_start < region_size)
        region_size = 0;
      uint64_t region_end = region_start + region_size;
      uint32_t p = vm_prot_to_page(info.protection);
      char perms[5];
      int shared = 0;
#if defined(SM_SHARED) && defined(SM_TRUESHARED)
      if (info.share_mode == SM_SHARED || info.share_mode == SM_TRUESHARED
#ifdef SM_SHARED_ALIASED
          || info.share_mode == SM_SHARED_ALIASED
#endif
      )
        shared = 1;
#endif
      pageprot_to_perms(p, shared, perms);

      snprintf(mapsline, 200, "%016llx-%016llx %s %016llx 00:00 0", (unsigned long long)region_start,
               (unsigned long long)region_end, perms, (unsigned long long)info.offset);
      mapsline[199] = 0;
    }
    return 1;
  }


  uint64_t region_start = (uint64_t)region_base;
  uint64_t region_size = (uint64_t)vmsize;
  if (UINT64_MAX - region_start < region_size)
    return 0;
  uint64_t region_end = region_start + region_size;
  if (region_end <= pagebase)
    return 0;

  rinfo->baseaddress = pagebase;
  rinfo->size = region_end - pagebase;
  rinfo->protection = vm_prot_to_page(info.protection);
  rinfo->type = vm_info_to_type(&info);

  if (mapsline)
  {
    uint32_t p = rinfo->protection;
    char perms[5];
    int shared = 0;
#if defined(SM_SHARED) && defined(SM_TRUESHARED)
    if (info.share_mode == SM_SHARED || info.share_mode == SM_TRUESHARED
#ifdef SM_SHARED_ALIASED
        || info.share_mode == SM_SHARED_ALIASED
#endif
    )
      shared = 1;
#endif
    pageprot_to_perms(p, shared, perms);

    snprintf(mapsline, 200, "%016llx-%016llx %s %016llx 00:00 0", (unsigned long long)region_start,
             (unsigned long long)region_end, perms, (unsigned long long)info.offset);
    mapsline[199] = 0;
  }

  return 1;
}


#define VQE_PAGEDONLY 1
#define VQE_DIRTYONLY 2
#define VQE_NOSHARED 4

int VirtualQueryExFull(HANDLE hProcess, uint32_t flags, RegionInfo **rinfo, uint32_t *count)
{
  if (!rinfo || !count)
    return 0;

  *rinfo = NULL;
  *count = 0;

  if (GetHandleType(hProcess) != htProcesHandle)
    return 0;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);

  uint64_t pagesize = get_page_size();
  if (pagesize == 0 || (pagesize & (pagesize - 1)) != 0)
    return 0;

  int max = 128;
  RegionInfo *list = (RegionInfo *)malloc(sizeof(RegionInfo) * (size_t)max);
  if (!list)
    return 0;

  uint32_t pos = 0;
  mach_vm_address_t probe = 0;

  while (1)
  {
    mach_vm_address_t query = probe;
    mach_vm_size_t vmsize = 0;
    vm_region_submap_info_data_64_t info;
    if (!query_leaf_region(p->task, query, &query, &vmsize, &info))
      goto vqfull_done;

    uint64_t region_start = (uint64_t)query;
    uint64_t region_size = (uint64_t)vmsize;
    if (UINT64_MAX - region_start < region_size)
      goto vqfull_done;


    if ((flags & VQE_PAGEDONLY) && info.pages_resident == 0)
    {
      if (vmsize == 0 || UINT64_MAX - (uint64_t)query < (uint64_t)vmsize)
        goto vqfull_done;
      probe = query + vmsize;
      continue;
    }
    if ((flags & VQE_DIRTYONLY) && info.pages_dirtied == 0)
    {
      if (vmsize == 0 || UINT64_MAX - (uint64_t)query < (uint64_t)vmsize)
        goto vqfull_done;
      probe = query + vmsize;
      continue;
    }


    if ((flags & VQE_NOSHARED) && vm_info_to_type(&info) == MEM_MAPPED)
    {

      if (vmsize == 0 || UINT64_MAX - (uint64_t)query < (uint64_t)vmsize)
        goto vqfull_done;
      probe = query + vmsize;
      continue;
    }


    if (vmsize == 0)
      goto vqfull_done;

    if (pos >= (uint32_t)max)
    {
      max *= 2;
      RegionInfo *newlist = (RegionInfo *)realloc(list, sizeof(RegionInfo) * (size_t)max);
      if (!newlist)
        goto vqfull_done;
      list = newlist;
    }

    list[pos].baseaddress = region_start;
    list[pos].size = region_size;
    list[pos].protection = vm_prot_to_page(info.protection);
    list[pos].type = vm_info_to_type(&info);
    pos++;


    if (UINT64_MAX - (uint64_t)query < (uint64_t)vmsize)
      goto vqfull_done;
    probe = query + vmsize;

    if (probe == 0)
      break;
  }

vqfull_done:
  if (pos == 0)
  {
    free(list);
    return 0;
  }

  *rinfo = list;
  *count = pos;
  return 1;
}

int ChangeMemoryProtection(HANDLE hProcess, uint64_t address, uint32_t size, uint32_t windowsprotection, uint32_t *oldprotection)
{
  if (oldprotection)
    *oldprotection = 0;

  if (GetHandleType(hProcess) != htProcesHandle)
    return 0;
  if (size == 0)
    return 0;









  // On iOS, setting RWX can drop execute due to W^X. Treat as success.
  if (windowsprotection == PAGE_EXECUTE_READWRITE)
    return 1;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);
  uint32_t vmprot = windows_protection_to_vmprot(windowsprotection);

  if (windowsprotection != PAGE_NOACCESS && vmprot == 0)
    return 0;

  if (oldprotection)
  {
    RegionInfo ri;
    if (VirtualQueryEx(hProcess, (void *)(uintptr_t)address, &ri, NULL))
      *oldprotection = ri.protection;
  }

  uint64_t ps = get_page_size();
  if (ps == 0 || (ps & (ps - 1)) != 0)
    return 0;


 
  if (vmprot & VM_PROT_WRITE)
    vmprot |= VM_PROT_COPY;


  
  uint64_t start = address & ~(ps - 1);
  if (UINT64_MAX - address < size)
    return 0;
  uint64_t end = address + size;
  uint64_t len64 = end - start;
  uint64_t rem = len64 & (ps - 1);
  if (rem)
  {
    if (UINT64_MAX - len64 < (ps - rem))
      return 0;
    len64 += (ps - rem);
  }

  mach_vm_size_t len = (mach_vm_size_t)len64;
  kern_return_t kr = mach_vm_protect(p->task, (mach_vm_address_t)start, len, FALSE, vmprot);
  return (kr == KERN_SUCCESS) ? 1 : 0;
}

int ReadProcessMemory(HANDLE hProcess, void *lpAddress, void *buffer, int size)
{
  if (GetHandleType(hProcess) != htProcesHandle)
    return 0;

  if (lpAddress == NULL || size <= 0 || buffer == NULL)
    return 0;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);

  return read_target(p->task, (mach_vm_address_t)lpAddress, buffer, (size_t)size);
}

int WriteProcessMemory(HANDLE hProcess, void *lpAddress, void *buffer, int size)
{
  if (GetHandleType(hProcess) != htProcesHandle)
    return 0;

  if (lpAddress == NULL || size <= 0 || buffer == NULL)
    return 0;
  if ((unsigned long)size > UINT32_MAX)
    return 0;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);
  mach_port_t task = p->task;


  kern_return_t kr = mach_vm_write(task, (mach_vm_address_t)lpAddress, (vm_offset_t)(uintptr_t)buffer,
                                   (mach_msg_type_number_t)(uint32_t)size);
  if (kr == KERN_SUCCESS)
    return size;


  uint64_t ps = get_page_size();
  if (ps == 0 || (ps & (ps - 1)) != 0)
    return 0;

  uint64_t start = (uint64_t)(uintptr_t)lpAddress;
  uint64_t end;
  if (UINT64_MAX - start < (uint64_t)size)
    return 0;
  end = start + (uint64_t)size;

  uint64_t page_start = start & ~(ps - 1);
  uint64_t page_end = (end + (ps - 1)) & ~(ps - 1);
  uint64_t page_count = (page_end - page_start) / ps;

  if (page_count == 0 || page_count > SIZE_MAX / sizeof(uint32_t))
    return 0;

  uint32_t *orig_prot = (uint32_t *)malloc((size_t)page_count * sizeof(uint32_t));
  if (!orig_prot)
    return 0;

  mach_vm_address_t cursor = (mach_vm_address_t)page_start;
  uint64_t idx = 0;
  int ok = 1;

  while (cursor < (mach_vm_address_t)page_end)
  {
    mach_vm_address_t rbase = 0;
    mach_vm_size_t rsize = 0;
    vm_region_submap_info_data_64_t info;

    if (!query_leaf_region(task, cursor, &rbase, &rsize, &info))
    {
      ok = 0;
      break;
    }

    orig_prot[idx] = info.protection;

    uint32_t newprot = info.protection | VM_PROT_READ | VM_PROT_WRITE | VM_PROT_COPY;
    mach_vm_address_t ap_base = cursor;
    mach_vm_size_t ap_len = (mach_vm_size_t)ps;

    if (mach_vm_protect(task, ap_base, ap_len, FALSE, newprot) != KERN_SUCCESS)
    {
      ok = 0;
      break;
    }

    if (UINT64_MAX - (uint64_t)cursor < ps)
    {
      ok = 0;
      break;
    }
    cursor += ps;
    idx++;
  }


  if (ok)
    kr = mach_vm_write(task, (mach_vm_address_t)lpAddress, (vm_offset_t)(uintptr_t)buffer,
                       (mach_msg_type_number_t)(uint32_t)size);


  if (idx > 0)
  {
    cursor = (mach_vm_address_t)page_start;
    for (uint64_t i = 0; i < idx; i++)
    {
      mach_vm_protect(task, cursor, (mach_vm_size_t)ps, FALSE, orig_prot[i]);
      if (UINT64_MAX - (uint64_t)cursor < ps)
        break;
      cursor += ps;
    }
  }

  free(orig_prot);

  if (!ok || kr != KERN_SUCCESS)
    return 0;


  if (idx > 0)
  {
    int state = MATTR_VAL_ICACHE_FLUSH;
    vm_address_t cache_base = (vm_address_t)page_start;
    vm_size_t cache_len = (vm_size_t)(page_end - page_start);
    vm_machine_attribute(task, cache_base, cache_len, MATTR_CACHE, &state);
  }
  return size;
}

HANDLE OpenProcess(DWORD pid)
{
  int handle = SearchHandleList(htProcesHandle, (HANDLESEARCHCALLBACK)SearchHandleListProcessCallback, &pid);
  if (handle)
  {
    PProcessData p = (PProcessData)GetPointerFromHandle(handle);
    p->ReferenceCount++;
    return handle;
  }

  int is_self = ((DWORD)getpid() == pid);
  if (!is_self)
    return 0;

  mach_port_t task = mach_task_self();

  PProcessData p = (PProcessData)malloc(sizeof(ProcessData));
  if (!p)
  {
    debug_log("OpenProcess: malloc failed for ProcessData\n");
    return 0;
  }

  memset(p, 0, sizeof(ProcessData));
  p->ReferenceCount = 1;
  p->pid = (int)pid;
  p->is64bit = 1;
  p->task = task;

  HANDLE h = CreateHandleFromPointer(p, htProcesHandle);
  if (!h)
  {
    free(p);
    return 0;
  }

  return h;
}

HANDLE CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID)
{
  if (dwFlags & TH32CS_SNAPPROCESS)
  {
    PProcessList pl = (PProcessList)malloc(sizeof(ProcessList));
    if (!pl)
      return 0;

    memset(pl, 0, sizeof(ProcessList));
    pl->ReferenceCount = 1;
    pl->processCount = 1;
    pl->processList = (PProcessListEntry)malloc(sizeof(ProcessListEntry));
    if (!pl->processList)
    {
      free(pl);
      return 0;
    }

    int pid = getpid();
    char pathbuf[PATH_MAX];
    memset(pathbuf, 0, sizeof(pathbuf));
    const char *procname = get_exec_path_sysctl(pid, pathbuf, sizeof(pathbuf)) ? pathbuf : "self";

    pl->processList[0].PID = pid;
    pl->processList[0].ProcessName = strdup(procname);
    if (!pl->processList[0].ProcessName)
    {
      free(pl->processList);
      free(pl);
      return 0;
    }

    HANDLE hs = CreateHandleFromPointer(pl, htTHSProcess);
    if (!hs)
    {
      free(pl->processList[0].ProcessName);
      free(pl->processList);
      free(pl);
      return 0;
    }

    return hs;
  }

  if ((dwFlags & TH32CS_SNAPMODULE) || (dwFlags & TH32CS_SNAPFIRSTMODULE))
  {
    int max = 64;
    PModuleList ml = (PModuleList)malloc(sizeof(ModuleList));
    if (!ml)
      return 0;
    memset(ml, 0, sizeof(ModuleList));

    ml->ReferenceCount = 1;
    ml->moduleCount = 0;
    ml->moduleList = (PModuleListEntry)malloc(sizeof(ModuleListEntry) * max);
    if (!ml->moduleList)
    {
      free(ml);
      return 0;
    }

    HANDLE pHandle = OpenProcess(th32ProcessID);
    if (!pHandle)
    {
      free(ml->moduleList);
      free(ml);
      return 0;
    }
    PProcessData p = (PProcessData)GetPointerFromHandle(pHandle);

    char mainpath[PATH_MAX];
    memset(mainpath, 0, sizeof(mainpath));
    get_exec_path_sysctl(th32ProcessID, mainpath, sizeof(mainpath));

    DyldImageList images;
    memset(&images, 0, sizeof(images));
    if (!collect_dyld_spi_images(p->task, &images))
    {
      dyld_image_list_free(&images);
      CloseHandle(pHandle);
      free(ml->moduleList);
      free(ml);
      return 0;
    }

    size_t imageCount = images.count;
    if (imageCount == 0)
    {
      dyld_image_list_free(&images);
      CloseHandle(pHandle);
      free(ml->moduleList);
      free(ml);
      return 0;
    }

    size_t firstIndex = 0;
    if ((dwFlags & TH32CS_SNAPFIRSTMODULE) && mainpath[0])
    {
      for (size_t i = 0; i < imageCount; i++)
      {
        if (strcmp(images.items[i].path, mainpath) == 0)
        {
          firstIndex = i;
          break;
        }
      }
    }

    for (size_t ii = 0; ii < imageCount; ii++)
    {
      size_t i = (firstIndex + ii) % imageCount;

      uint64_t base = images.items[i].load_address;
      const char *pathbuf = images.items[i].path;

      if (ml->moduleCount >= max)
      {
        int newmax = max * 2;
        void *newp = realloc(ml->moduleList, sizeof(ModuleListEntry) * (size_t)newmax);
        if (!newp)
          break;
        ml->moduleList = (PModuleListEntry)newp;
        max = newmax;
      }

      int part = 0;
      for (int j = ml->moduleCount - 1; j >= 0; j--)
      {
        if (strcmp(ml->moduleList[j].moduleName, pathbuf) == 0)
        {
          part = ml->moduleList[j].part + 1;
          break;
        }
      }

      PModuleListEntry mle = &ml->moduleList[ml->moduleCount];
      memset(mle, 0, sizeof(*mle));
      mle->moduleName = strdup(pathbuf);
      if (!mle->moduleName)
        continue;
      mle->baseAddress = (unsigned long long)base;
      mle->fileOffset = 0;
      {
        uint64_t s64 = get_macho_image_size_64(p->task, (mach_vm_address_t)base);


      mle->moduleSize = (s64 > (uint64_t)INT_MAX) ? INT_MAX : (int)s64;
      }
      mle->part = part;
      mle->is64bit = 1;

      ml->moduleCount++;

      if (dwFlags & TH32CS_SNAPFIRSTMODULE)
        break;
    }

    dyld_image_list_free(&images);
    CloseHandle(pHandle);

    HANDLE hm = CreateHandleFromPointer(ml, htTHSModule);
    if (!hm)
    {
      for (int i = 0; i < ml->moduleCount; i++)
        free(ml->moduleList[i].moduleName);
      free(ml->moduleList);
      free(ml);
      return 0;
    }

    return hm;
  }

  debug_log("Unhandled toolhelp32snapshot flags: %x\n", dwFlags);
  return 0;
}

BOOL Process32Next(HANDLE hSnapshot, PProcessListEntry processentry)
{
  if (GetHandleType(hSnapshot) == htTHSProcess)
  {
    PProcessList pl = (PProcessList)GetPointerFromHandle(hSnapshot);

    if (pl->processListIterator < pl->processCount)
    {
      processentry->PID = pl->processList[pl->processListIterator].PID;
      processentry->ProcessName = pl->processList[pl->processListIterator].ProcessName;
      pl->processListIterator++;
      return TRUE;
    }

    return FALSE;
  }

  return FALSE;
}

BOOL Process32First(HANDLE hSnapshot, PProcessListEntry processentry)
{
  if (GetHandleType(hSnapshot) == htTHSProcess)
  {
    PProcessList pl = (PProcessList)GetPointerFromHandle(hSnapshot);
    pl->processListIterator = 0;
    return Process32Next(hSnapshot, processentry);
  }

  return FALSE;
}

BOOL Module32Next(HANDLE hSnapshot, PModuleListEntry moduleentry)
{
  if (GetHandleType(hSnapshot) == htTHSModule)
  {
    PModuleList ml = (PModuleList)GetPointerFromHandle(hSnapshot);
    if (ml->moduleListIterator < ml->moduleCount)
    {
      *moduleentry = ml->moduleList[ml->moduleListIterator];
      ml->moduleListIterator++;
      return TRUE;
    }
    return FALSE;
  }
  return FALSE;
}

BOOL Module32First(HANDLE hSnapshot, PModuleListEntry moduleentry)
{
  if (GetHandleType(hSnapshot) == htTHSModule)
  {
    PModuleList ml = (PModuleList)GetPointerFromHandle(hSnapshot);
    ml->moduleListIterator = 0;
    return Module32Next(hSnapshot, moduleentry);
  }
  return FALSE;
}

void CloseHandle(HANDLE h)
{
  handleType ht = GetHandleType(h);

  if (ht == htTHSProcess)
  {
    PProcessList pl = (PProcessList)GetPointerFromHandle(h);
    pl->ReferenceCount--;
    if (pl->ReferenceCount <= 0)
    {
      for (int i = 0; i < pl->processCount; i++)
        free(pl->processList[i].ProcessName);
      free(pl->processList);
      free(pl);
      RemoveHandle(h);
    }
  }
  else if (ht == htTHSModule)
  {
    PModuleList ml = (PModuleList)GetPointerFromHandle(h);
    ml->ReferenceCount--;
    if (ml->ReferenceCount <= 0)
    {
      for (int i = 0; i < ml->moduleCount; i++)
        free(ml->moduleList[i].moduleName);
      free(ml->moduleList);
      free(ml);
      RemoveHandle(h);
    }
  }
  else if (ht == htProcesHandle)
  {
    PProcessData pd = (PProcessData)GetPointerFromHandle(h);
    pd->ReferenceCount--;
    if (pd->ReferenceCount <= 0)
    {
      if (pd->debuggerData)
        StopDebug(h);
      if (pd->task != MACH_PORT_NULL && pd->task != mach_task_self())
        mach_port_deallocate(mach_task_self(), pd->task);
      free(pd);
      RemoveHandle(h);
    }
  }
  else
  {
    RemoveHandle(h);
  }
}

void initAPI(void)
{

}

```

`ceserver-ios/jailed/api.h`:

```h

#ifndef API_H_
#define API_H_

#include <stdint.h>

#include <mach/mach.h>
#include <mach-o/dyld_images.h>
#include <stddef.h>

#include "porthelp.h"

typedef struct
{
  unsigned long long baseAddress;
  uint32_t fileOffset;
  int part;
  int is64bit;
  int moduleSize;
  char *moduleName;
} ModuleListEntry, *PModuleListEntry;

typedef struct
{
  int ReferenceCount;
  int moduleListIterator;
  int moduleCount;
  PModuleListEntry moduleList;
} ModuleList, *PModuleList;

typedef struct
{
  int PID;
  char *ProcessName;
} ProcessListEntry, *PProcessListEntry;

typedef struct
{
  int ReferenceCount;
  int processListIterator;
  int processCount;
  PProcessListEntry processList;
} ProcessList, *PProcessList;

typedef struct
{
  int ReferenceCount;
  int pid;
  int is64bit;
  mach_port_t task;
  void *debuggerData;
} ProcessData, *PProcessData;

typedef struct
{
  uint64_t baseaddress;
  uint64_t size;
  uint32_t protection;
  uint32_t type;
} RegionInfo, *PRegionInfo;

int debug_log(const char *format, ...);

void initAPI(void);

HANDLE CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
BOOL Process32First(HANDLE hSnapshot, PProcessListEntry processentry);
BOOL Process32Next(HANDLE hSnapshot, PProcessListEntry processentry);
BOOL Module32First(HANDLE hSnapshot, PModuleListEntry moduleentry);
BOOL Module32Next(HANDLE hSnapshot, PModuleListEntry moduleentry);
void CloseHandle(HANDLE h);

HANDLE OpenProcess(DWORD pid);
int getArchitecture(HANDLE hProcess);

int ReadProcessMemory(HANDLE hProcess, void *lpAddress, void *buffer, int size);
int WriteProcessMemory(HANDLE hProcess, void *lpAddress, void *buffer, int size);

int VirtualQueryEx(HANDLE hProcess, void *lpAddress, PRegionInfo rinfo, char *mapsline);
int VirtualQueryExFull(HANDLE hProcess, uint32_t flags, RegionInfo **rinfo, uint32_t *count);
int ChangeMemoryProtection(HANDLE hProcess, uint64_t address, uint32_t size, uint32_t windowsprotection, uint32_t *oldprotection);

#endif

```

`ceserver-ios/jailed/ceserver.c`:

```c
#include <errno.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <pthread.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <signal.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <sys/types.h>
#include <unistd.h>

#include <zlib.h>

#include "api.h"
#include "ceserver.h"
#include "debugger.h"
#include "porthelp.h"
#include "symbols.h"

#define CESERVERVERSION 6
#ifndef MSG_MORE
#define MSG_MORE 0
#endif

static char versionstring[] = "CHEATENGINE Network 2.3";
static char ceserverpath[] = ".";

__thread char *threadname;
__thread int isDebuggerThread;
__thread int debugfd;

static int can_alloc_size(size_t a, size_t b)
{
  return a <= SIZE_MAX - b;
}

ssize_t recvall(int s, void *buf, size_t size, int flags)
{
  ssize_t totalreceived = 0;
  ssize_t sizeleft = (ssize_t)size;
  unsigned char *buffer = (unsigned char *)buf;

  flags |= MSG_WAITALL;

  while (sizeleft > 0)
  {
    ssize_t i = recv(s, &buffer[totalreceived], (size_t)sizeleft, flags);

    if (i == 0)
      return 0;

    if (i == -1)
    {
      if (errno == EINTR)
        continue;
      return -1;
    }

    totalreceived += i;
    sizeleft -= i;
  }

  return totalreceived;
}

ssize_t sendall(int s, void *buf, size_t size, int flags)
{
  ssize_t totalsent = 0;
  ssize_t sizeleft = (ssize_t)size;
  const unsigned char *buffer = (const unsigned char *)buf;

  while (sizeleft > 0)
  {
    ssize_t i = send(s, &buffer[totalsent], (size_t)sizeleft, flags);
    if (i == 0)
      return 0;
    if (i == -1)
    {
      if (errno == EINTR)
        continue;
      return -1;
    }
    totalsent += i;
    sizeleft -= i;
  }

  return totalsent;
}

ssize_t sendstring16(int s, char *str, int flags)
{
  uint16_t l;
  if (str)
    l = (uint16_t)strlen(str);
  else
    l = 0;

  sendall(s, &l, sizeof(l), l ? MSG_MORE : flags);
  if (l)
    sendall(s, str, l, flags);

  return l;
}

char *receivestring16(int s)
{
  uint16_t l = 0;
  if (recvall(s, &l, sizeof(l), 0) <= 0)
    return NULL;

  if (l == 0)
    return NULL;

  char *str = (char *)malloc((size_t)l + 1);
  if (!str)
    return NULL;

  if (recvall(s, str, l, 0) <= 0)
  {
    free(str);
    return NULL;
  }

  str[l] = 0;
  return str;
}

int DispatchCommand(int currentsocket, unsigned char command)
{
  switch (command)
  {
    case CMD_GETVERSION:
    {
      int versionsize = (int)strlen(versionstring);
      PCeVersion v = (PCeVersion)malloc(sizeof(CeVersion) + versionsize);
      v->stringsize = (unsigned char)versionsize;
      v->version = CESERVERVERSION;
      memcpy((char *)v + sizeof(CeVersion), versionstring, (size_t)versionsize);
      sendall(currentsocket, v, sizeof(CeVersion) + (size_t)versionsize, 0);
      free(v);
      break;
    }

    case CMD_SET_CONNECTION_NAME:
    {
      uint32_t namelength;
      if (recvall(currentsocket, &namelength, sizeof(namelength), 0) > 0)
      {
        char *name = (char *)malloc((size_t)namelength + 1);
        if (recvall(currentsocket, name, namelength, 0) <= 0)
        {
          free(name);
          break;
        }
        name[namelength] = 0;
        free(threadname);
        threadname = name;
      }
      break;
    }

    case CMD_GETABI:
    {
      unsigned char abi = 1;
      sendall(currentsocket, &abi, sizeof(abi), 0);
      break;
    }

    case CMD_GETARCHITECTURE:
    {
      unsigned char arch = 3;
      HANDLE h;
      if (recvall(currentsocket, &h, sizeof(h), 0) > 0)
      {
        int a = getArchitecture(h);
        if (a >= 0)
          arch = (unsigned char)a;
      }
      sendall(currentsocket, &arch, sizeof(arch), 0);
      break;
    }

    case CMD_GETOPTIONS:
    {

      uint16_t count = 0;
      sendall(currentsocket, &count, sizeof(count), 0);
      break;
    }

    case CMD_GETCESERVERPATH:
    {
      sendstring16(currentsocket, ceserverpath, 0);
      break;
    }

    case CMD_ISANDROID:
    {
      unsigned char r = 0;
      sendall(currentsocket, &r, sizeof(r), 0);
      break;
    }

    case CMD_OPENPROCESS:
    {
      int pid = 0;
      if (recvall(currentsocket, &pid, sizeof(pid), 0) > 0)
      {
        int processhandle = (int)OpenProcess((DWORD)pid);
        sendall(currentsocket, &processhandle, sizeof(processhandle), 0);
      }
      break;
    }

    case CMD_STARTDEBUG:
    {
      HANDLE h;
      if (recvall(currentsocket, &h, sizeof(h), MSG_WAITALL) > 0)
      {
        int r;
        debug_log("Calling StartDebug(%d)\n", h);
        r = StartDebug(h);
        sendall(currentsocket, &r, sizeof(r), 0);

        if (r)
        {
          isDebuggerThread = h;
          debugfd = GetDebugPort(h);
        }
      }
      break;
    }

    case CMD_WAITFORDEBUGEVENT:
    {
      struct
      {
        HANDLE pHandle;
        int timeout;
      } wfd;

      if (recvall(currentsocket, &wfd, sizeof(wfd), MSG_WAITALL) > 0)
      {
        int r;
        DebugEvent event;
        memset(&event, 0, sizeof(event));

        r = WaitForDebugEvent(wfd.pHandle, &event, wfd.timeout);
        sendall(currentsocket, &r, sizeof(r), r ? MSG_MORE : 0);

        if (r)
        {
          if (event.debugevent == SIGTRAP)
          {
            debug_log("!!!SIGTRAP!!!\n");
            debug_log("event.address=%llx\n", event.address);
          }

          sendall(currentsocket, &event, sizeof(event), 0);
        }
      }
      break;
    }

    case CMD_CONTINUEFROMDEBUGEVENT:
    {
      struct
      {
        HANDLE pHandle;
        int tid;
        int ignore;
      } cfd;

      if (recvall(currentsocket, &cfd, sizeof(cfd), MSG_WAITALL) > 0)
      {
        int r;
        r = ContinueFromDebugEvent(cfd.pHandle, cfd.tid, cfd.ignore);
        sendall(currentsocket, &r, sizeof(r), 0);
      }
      break;
    }

    case CMD_SETBREAKPOINT:
    {
      CeSetBreapointInput sb;

      debug_log("CMD_SETBREAKPOINT. sizeof(sb)=%d\n", (int)sizeof(sb));

      if (recvall(currentsocket, &sb, sizeof(sb), MSG_WAITALL) > 0)
      {
        int r;

        debug_log("Calling SetBreakpoint\n");
        r = SetBreakpoint(sb.hProcess, sb.tid, sb.debugreg, (void *)sb.Address, sb.bptype, sb.bpsize);
        debug_log("SetBreakpoint returned %d\n", r);
        sendall(currentsocket, &r, sizeof(r), 0);
      }
      break;
    }

    case CMD_REMOVEBREAKPOINT:
    {
      CeRemoveBreapointInput rb;

      if (recvall(currentsocket, &rb, sizeof(rb), MSG_WAITALL) > 0)
      {
        int r;

        debug_log("%s: Calling RemoveBreakpoint\n", threadname ? threadname : "thread");
        r = RemoveBreakpoint(rb.hProcess, rb.tid, rb.debugreg, rb.wasWatchpoint);
        debug_log("RemoveBreakpoint returned: %d\n", r);
        sendall(currentsocket, &r, sizeof(r), 0);
      }
      break;
    }

    case CMD_GETTHREADCONTEXT:
    {
#pragma pack(1)
      struct
      {
        HANDLE hProcess;
        uint32_t tid;
      } gtc;
#pragma pack()

      CONTEXT Context;
      uint32_t result;

      debug_log("CMD_GETTHREADCONTEXT:\n");

      recvall(currentsocket, &gtc, sizeof(gtc), MSG_WAITALL);

      debug_log("Going to call GetThreadContext(%d, %d, %p)\n", gtc.hProcess, gtc.tid, &Context);
      memset(&Context, 0, sizeof(Context));

      result = GetThreadContext(gtc.hProcess, gtc.tid, &Context);

      debug_log("result=%d\n", result);

      if (result)
      {
        debug_log("Context.structsize=%d\n", Context.structsize);
        uint32_t structsize = Context.structsize;
        sendall(currentsocket, &result, sizeof(result), MSG_MORE);
        sendall(currentsocket, &structsize, sizeof(structsize), MSG_MORE);
        sendall(currentsocket, &Context, structsize, 0);
      }
      else
      {
        sendall(currentsocket, &result, sizeof(result), 0);
      }

      break;
    }

    case CMD_SETTHREADCONTEXT:
    {
#pragma pack(1)
      struct
      {
        HANDLE hProcess;
        uint32_t tid;
        uint32_t structsize;
      } stc;
#pragma pack()

      uint32_t result;
      PCONTEXT c;

      debug_log("CMD_SETTHREADCONTEXT:\n");

      recvall(currentsocket, &stc, sizeof(stc), MSG_WAITALL);
      debug_log("hProcess=%d tid=%d structsize=%d\n", stc.hProcess, stc.tid, stc.structsize);

      c = (PCONTEXT)malloc(stc.structsize);
      recvall(currentsocket, c, stc.structsize, MSG_WAITALL);

      debug_log("received a context with data: structsize=%d type=%d\n", c->structsize, c->type);
      debug_log("Going to call SetThreadContext(%d, %d, %p)\n", stc.hProcess, stc.tid, c);

      result = SetThreadContext(stc.hProcess, stc.tid, c);
      free(c);

      debug_log("result=%d\n", result);
      sendall(currentsocket, &result, sizeof(result), 0);

      break;
    }

    case CMD_SUSPENDTHREAD:
    {
      CeSuspendThreadInput st;

      if (recvall(currentsocket, &st, sizeof(st), MSG_WAITALL) > 0)
      {
        int r;
        r = SuspendThread(st.hProcess, st.tid);
        sendall(currentsocket, &r, sizeof(r), 0);
      }
      break;
    }

    case CMD_RESUMETHREAD:
    {
      CeResumeThreadInput rt;

      if (recvall(currentsocket, &rt, sizeof(rt), MSG_WAITALL) > 0)
      {
        int r;
        r = ResumeThread(rt.hProcess, rt.tid);
        sendall(currentsocket, &r, sizeof(r), 0);
      }
      break;
    }

    case CMD_GETREGIONINFO:
    case CMD_VIRTUALQUERYEX:
    {
      CeVirtualQueryExInput c;
      if (recvall(currentsocket, &c, sizeof(c), 0) > 0)
      {
        RegionInfo rinfo;
        CeVirtualQueryExOutput o;
        memset(&rinfo, 0, sizeof(rinfo));
        memset(&o, 0, sizeof(o));

        char mapsline[200];
        mapsline[0] = 0;

        if (command == CMD_VIRTUALQUERYEX)
          o.result = (uint8_t)VirtualQueryEx((HANDLE)c.handle, (void *)(uintptr_t)c.baseaddress, &rinfo, NULL);
        else
          o.result = (uint8_t)VirtualQueryEx((HANDLE)c.handle, (void *)(uintptr_t)c.baseaddress, &rinfo, mapsline);

        o.protection = rinfo.protection;
        o.type = rinfo.type;
        o.baseaddress = rinfo.baseaddress;
        o.size = rinfo.size;

        sendall(currentsocket, &o, sizeof(o), 0);

        if (command == CMD_GETREGIONINFO)
        {
          uint8_t size = (uint8_t)strlen(mapsline);
          sendall(currentsocket, &size, sizeof(size), 0);
          if (size)
            sendall(currentsocket, mapsline, size, 0);
        }
      }
      break;
    }

    case CMD_CREATETOOLHELP32SNAPSHOT:
    {
      CeCreateToolhelp32Snapshot params;
      if (recvall(currentsocket, &params, sizeof(params), 0) > 0)
      {
        HANDLE result = CreateToolhelp32Snapshot(params.dwFlags, params.th32ProcessID);
        sendall(currentsocket, &result, sizeof(result), 0);
      }
      break;
    }

    case CMD_CREATETOOLHELP32SNAPSHOTEX:
    {
      CeCreateToolhelp32Snapshot params;
      if (recvall(currentsocket, &params, sizeof(params), 0) > 0)
      {
        HANDLE r = CreateToolhelp32Snapshot(params.dwFlags, params.th32ProcessID);

        if ((params.dwFlags & TH32CS_SNAPTHREAD) == TH32CS_SNAPTHREAD)
        {


          int n = 0;
          sendall(currentsocket, &n, sizeof(n), 0);

          if (r)
            CloseHandle(r);
        }
        else if ((params.dwFlags & TH32CS_SNAPMODULE) == TH32CS_SNAPMODULE)
        {
          ModuleListEntry me;
          char *outputstream = (char *)malloc(65536);
          int pos = 0;
          if (outputstream)
            memset(outputstream, 0, 65536);

          if (outputstream && r && Module32First(r, &me))
          {
            do
            {
              int namelen = (int)strlen(me.moduleName);
              if ((pos + (int)sizeof(CeModuleEntry) + namelen) > 65536)
              {
                sendall(currentsocket, outputstream, (size_t)pos, 0);
                pos = 0;
              }

              PCeModuleEntry m = (PCeModuleEntry)&outputstream[pos];
              m->modulebase = (int64_t)me.baseAddress;
              m->modulesize = me.moduleSize;
              m->modulefileoffset = me.fileOffset;
              m->modulenamesize = namelen;
              m->modulepart = me.part;
              m->result = 1;

              memcpy((char *)m + sizeof(CeModuleEntry), me.moduleName, (size_t)namelen);
              pos += (int)sizeof(CeModuleEntry) + namelen;
            } while (Module32Next(r, &me));
          }

          if (pos)
            sendall(currentsocket, outputstream, (size_t)pos, 0);

          CeModuleEntry eol;
          memset(&eol, 0, sizeof(eol));
          eol.result = 0;
          eol.modulenamesize = 0;
          sendall(currentsocket, &eol, sizeof(eol), 0);

          if (outputstream)
            free(outputstream);
          if (r)
            CloseHandle(r);
        }
        else
        {
          sendall(currentsocket, &r, sizeof(r), 0);
        }
      }
      break;
    }

    case CMD_PROCESS32FIRST:
    case CMD_PROCESS32NEXT:
    {
      HANDLE toolhelpsnapshot;
      if (recvall(currentsocket, &toolhelpsnapshot, sizeof(toolhelpsnapshot), 0) > 0)
      {
        ProcessListEntry pe;
        BOOL result = (command == CMD_PROCESS32FIRST) ? Process32First(toolhelpsnapshot, &pe) : Process32Next(toolhelpsnapshot, &pe);

        CeProcessEntry *r;
        int size;
        if (result)
        {
          int namelen = (int)strlen(pe.ProcessName);
          size = (int)sizeof(CeProcessEntry) + namelen;
          r = (PCeProcessEntry)malloc((size_t)size);
          r->processnamesize = namelen;
          r->pid = pe.PID;
          memcpy((char *)r + sizeof(CeProcessEntry), pe.ProcessName, (size_t)namelen);
        }
        else
        {
          size = (int)sizeof(CeProcessEntry);
          r = (PCeProcessEntry)malloc((size_t)size);
          r->processnamesize = 0;
          r->pid = 0;
        }

        r->result = result;
        sendall(currentsocket, r, (size_t)size, 0);
        free(r);
      }
      break;
    }

    case CMD_MODULE32FIRST:
    case CMD_MODULE32NEXT:
    {
      HANDLE toolhelpsnapshot;
      if (recvall(currentsocket, &toolhelpsnapshot, sizeof(toolhelpsnapshot), 0) > 0)
      {
        ModuleListEntry me;
        BOOL result = (command == CMD_MODULE32FIRST) ? Module32First(toolhelpsnapshot, &me) : Module32Next(toolhelpsnapshot, &me);

        CeModuleEntry *r;
        int size;
        if (result)
        {
          int namelen = (int)strlen(me.moduleName);
          size = (int)sizeof(CeModuleEntry) + namelen;
          r = (PCeModuleEntry)malloc((size_t)size);
          r->modulebase = (int64_t)me.baseAddress;
          r->modulepart = me.part;
          r->modulesize = me.moduleSize;
          r->modulefileoffset = me.fileOffset;
          r->modulenamesize = namelen;
          memcpy((char *)r + sizeof(CeModuleEntry), me.moduleName, (size_t)namelen);
        }
        else
        {
          size = (int)sizeof(CeModuleEntry);
          r = (PCeModuleEntry)malloc((size_t)size);
          memset(r, 0, (size_t)size);
        }

        r->result = result;
        sendall(currentsocket, r, (size_t)size, 0);
        free(r);
      }
      break;
    }

    case CMD_GETSYMBOLLISTFROMFILE:
    {
      struct
      {
        uint32_t fileoffset;
        uint32_t symbolpathsize;
      } input;

      if (recvall(currentsocket, &input, sizeof(input), 0) > 0)
      {
        char *symbolpath = (char *)malloc((size_t)input.symbolpathsize + 1);
        if (!symbolpath)
          break;

        symbolpath[input.symbolpathsize] = 0;
        if (input.symbolpathsize && recvall(currentsocket, symbolpath, input.symbolpathsize, 0) <= 0)
        {
          free(symbolpath);
          break;
        }

        unsigned char *output = NULL;
        if (memcmp("/dev/", symbolpath, 5) != 0)
          GetSymbolListFromFile(symbolpath, input.fileoffset, &output);

        if (output)
        {
          sendall(currentsocket, output, *(uint32_t *)&output[4], 0);
          free(output);
        }
        else
        {
          uint64_t fail = 0;
          sendall(currentsocket, &fail, sizeof(fail), 0);
        }

        free(symbolpath);
      }
      break;
    }

    case CMD_READPROCESSMEMORY:
    {
      CeReadProcessMemoryInput c;
      if (recvall(currentsocket, &c, sizeof(c), 0) > 0)
      {

        if (c.size > (uint32_t)INT_MAX || !can_alloc_size(sizeof(CeReadProcessMemoryOutput), (size_t)c.size))
        {
          PCeReadProcessMemoryOutput o = (PCeReadProcessMemoryOutput)malloc(sizeof(CeReadProcessMemoryOutput));
          if (o)
          {
            o->read = 0;
            sendall(currentsocket, o, sizeof(CeReadProcessMemoryOutput), 0);
            free(o);
          }
          break;
        }

        PCeReadProcessMemoryOutput o = (PCeReadProcessMemoryOutput)malloc(sizeof(CeReadProcessMemoryOutput) + (size_t)c.size);
        if (!o)
        {

          PCeReadProcessMemoryOutput o2 = (PCeReadProcessMemoryOutput)malloc(sizeof(CeReadProcessMemoryOutput));
          if (o2)
          {
            o2->read = 0;
            sendall(currentsocket, o2, sizeof(CeReadProcessMemoryOutput), 0);
            free(o2);
          }
          break;
        }

        o->read = ReadProcessMemory((HANDLE)c.handle, (void *)(uintptr_t)c.address, &o[1], (int)c.size);

        if (c.compress)
        {
#define COMPRESS_BLOCKSIZE (64 * 1024)
          unsigned char *uncompressed = (unsigned char *)&o[1];
          uint32_t uncompressedSize = (uint32_t)o->read;
          uint32_t compressedSize = 0;

          unsigned char **compressedBlocks = NULL;
          int maxBlocks = 0;
          int currentBlock = 0;
          int blocksAllocated = 0;

          z_stream strm;
          memset(&strm, 0, sizeof(strm));
          int zinit = Z_ERRNO;
          int ok = 1;

          if (uncompressedSize == 0)
          {
            sendall(currentsocket, &uncompressedSize, sizeof(uncompressedSize), MSG_MORE);
            sendall(currentsocket, &compressedSize, sizeof(compressedSize), 0);
            free(o);
            break;
          }

          maxBlocks = 1 + ((int)uncompressedSize / COMPRESS_BLOCKSIZE);
          compressedBlocks = (unsigned char **)malloc((size_t)maxBlocks * sizeof(unsigned char *));
          if (!compressedBlocks)
            ok = 0;

          if (ok)
          {
            zinit = deflateInit(&strm, c.compress);
            if (zinit != Z_OK)
              ok = 0;
          }

          if (ok)
          {
            compressedBlocks[0] = (unsigned char *)malloc(COMPRESS_BLOCKSIZE);
            if (!compressedBlocks[0])
              ok = 0;
            else
            {
              blocksAllocated = 1;
              strm.avail_out = COMPRESS_BLOCKSIZE;
              strm.next_out = compressedBlocks[0];
              strm.next_in = uncompressed;
              strm.avail_in = uncompressedSize;
            }
          }

          while (ok && strm.avail_in)
          {
            int zr = deflate(&strm, Z_NO_FLUSH);
            if (zr != Z_OK && zr != Z_STREAM_END)
            {
              ok = 0;
              break;
            }

            if (strm.avail_out == 0)
            {
              currentBlock++;
              if (currentBlock >= maxBlocks)
              {
                maxBlocks *= 2;
                void *newp = realloc(compressedBlocks, (size_t)maxBlocks * sizeof(unsigned char *));
                if (!newp)
                {
                  ok = 0;
                  break;
                }
                compressedBlocks = (unsigned char **)newp;
              }

              compressedBlocks[currentBlock] = (unsigned char *)malloc(COMPRESS_BLOCKSIZE);
              if (!compressedBlocks[currentBlock])
              {
                ok = 0;
                break;
              }

              blocksAllocated = currentBlock + 1;
              strm.avail_out = COMPRESS_BLOCKSIZE;
              strm.next_out = compressedBlocks[currentBlock];
            }
          }

          while (ok)
          {
            int zr = deflate(&strm, Z_FINISH);
            if (zr == Z_STREAM_END)
              break;
            if (zr != Z_OK)
            {
              ok = 0;
              break;
            }

            if (strm.avail_out == 0)
            {
              currentBlock++;
              if (currentBlock >= maxBlocks)
              {
                maxBlocks *= 2;
                void *newp = realloc(compressedBlocks, (size_t)maxBlocks * sizeof(unsigned char *));
                if (!newp)
                {
                  ok = 0;
                  break;
                }
                compressedBlocks = (unsigned char **)newp;
              }

              compressedBlocks[currentBlock] = (unsigned char *)malloc(COMPRESS_BLOCKSIZE);
              if (!compressedBlocks[currentBlock])
              {
                ok = 0;
                break;
              }

              blocksAllocated = currentBlock + 1;
              strm.avail_out = COMPRESS_BLOCKSIZE;
              strm.next_out = compressedBlocks[currentBlock];
            }
          }

          if (zinit == Z_OK)
            deflateEnd(&strm);

          if (!ok)
          {

            compressedSize = 0;
            sendall(currentsocket, &uncompressedSize, sizeof(uncompressedSize), MSG_MORE);
            sendall(currentsocket, &compressedSize, sizeof(compressedSize), 0);

            for (int i = 0; i < blocksAllocated; i++)
              free(compressedBlocks[i]);
            free(compressedBlocks);
            free(o);
            break;
          }

          compressedSize = (uint32_t)strm.total_out;
          sendall(currentsocket, &uncompressedSize, sizeof(uncompressedSize), MSG_MORE);
          sendall(currentsocket, &compressedSize, sizeof(compressedSize), MSG_MORE);

          for (int i = 0; i < blocksAllocated; i++)
          {
            if (i != currentBlock)
              sendall(currentsocket, compressedBlocks[i], COMPRESS_BLOCKSIZE, MSG_MORE);
            else
              sendall(currentsocket, compressedBlocks[i], COMPRESS_BLOCKSIZE - strm.avail_out, 0);
            free(compressedBlocks[i]);
          }
          free(compressedBlocks);
        }
        else
        {
          sendall(currentsocket, o, sizeof(CeReadProcessMemoryOutput) + (size_t)o->read, 0);
        }

        free(o);
      }
      break;
    }

    case CMD_WRITEPROCESSMEMORY:
    {
      CeWriteProcessMemoryInput c;
      if (recvall(currentsocket, &c, sizeof(c), 0) > 0)
      {
        CeWriteProcessMemoryOutput o;
        unsigned char *buf = NULL;
        if (c.size > 0)
        {

          size_t want = (size_t)c.size;
          buf = (unsigned char *)malloc(want);
          if (buf)
          {
            if (recvall(currentsocket, buf, want, 0) > 0)
              o.written = WriteProcessMemory((HANDLE)c.handle, (void *)(uintptr_t)c.address, buf, (int)c.size);
            else
              o.written = 0;
            free(buf);
          }
          else
          {

            char discard[64 * 1024];
            size_t left = want;
            while (left)
            {
              size_t n = left > sizeof(discard) ? sizeof(discard) : left;
              if (recvall(currentsocket, discard, n, 0) <= 0)
                break;
              left -= n;
            }
            o.written = 0;
          }
        }
        else
        {
          o.written = 0;
        }

        sendall(currentsocket, &o, sizeof(o), 0);
      }
      break;
    }

    case CMD_VIRTUALQUERYEXFULL:
    {
      CeVirtualQueryExFullInput c;
      if (recvall(currentsocket, &c, sizeof(c), MSG_WAITALL) > 0)
      {
        RegionInfo *rinfo = NULL;
        uint32_t count = 0;
        if (VirtualQueryExFull((HANDLE)c.handle, c.flags, &rinfo, &count))
        {
          sendall(currentsocket, &count, sizeof(count), 0);
          for (uint32_t i = 0; i < count; i++)
            sendall(currentsocket, &rinfo[i], sizeof(RegionInfo), 0);
        }
        else
        {

          sendall(currentsocket, &count, sizeof(count), 0);
        }
        free(rinfo);
      }
      break;
    }

    case CMD_CHANGEMEMORYPROTECTION:
    {
      CeChangeMemoryProtection c;
      if (recvall(currentsocket, &c, sizeof(c), 0) > 0)
      {






        uint32_t oldprot = 0;
        uint32_t result = ChangeMemoryProtection(c.hProcess, c.address, c.size, c.windowsprotection, &oldprot);
        sendall(currentsocket, &result, sizeof(result), MSG_MORE);
        sendall(currentsocket, &oldprot, sizeof(oldprot), 0);
      }
      break;
    }

    case CMD_CLOSEHANDLE:
    {
      HANDLE h;
      if (recvall(currentsocket, &h, sizeof(h), 0) > 0)
      {
        CloseHandle(h);
        int ok = 1;
        sendall(currentsocket, &ok, sizeof(ok), 0);
      }
      break;
    }

    case CMD_CLOSECONNECTION:
      close(currentsocket);
      return 0;

    default:
      debug_log("Unknown command received: %u\n", command);

      close(currentsocket);
      return 0;
  }

  return 1;
}

static void *newconnection(void *arg)
{
  int s = (int)(intptr_t)arg;
  int currentsocket = s;
  threadname = NULL;
  isDebuggerThread = 0;
  debugfd = -1;

  while (1)
  {
    if (isDebuggerThread && (debugfd != -1))
    {
      fd_set readfds;
      int maxfd = s;
      int sret;

      FD_ZERO(&readfds);
      FD_SET(s, &readfds);
      FD_SET(debugfd, &readfds);

      if (debugfd > maxfd)
        maxfd = debugfd;

      sret = select(maxfd + 1, &readfds, NULL, NULL, NULL);
      if (sret == -1)
      {
        if (errno == EINTR)
          continue;
        debug_log("select failed: %d\n", errno);
        break;
      }

      if (FD_ISSET(debugfd, &readfds) && FD_ISSET(s, &readfds))
      {
        if (currentsocket == debugfd)
          currentsocket = s;
        else
          currentsocket = debugfd;
      }
      else if (FD_ISSET(debugfd, &readfds))
      {
        currentsocket = debugfd;
      }
      else if (FD_ISSET(s, &readfds))
      {
        currentsocket = s;
      }
      else
      {
        continue;
      }
    }
    else
    {
      currentsocket = s;
    }

    unsigned char command;
    ssize_t r = recvall(currentsocket, &command, 1, MSG_WAITALL);
    if (r == 1)
    {
      if (!DispatchCommand(currentsocket, command))
        break;
    }
    else
    {
      if (r == -1)
        debug_log("read error on socket %d (%d)\n", s, errno);
      else if (threadname)
        debug_log("%s has disconnected\n", threadname);

      if (isDebuggerThread)
      {
        debug_log("This was a debugger thread\n");
        StopDebug(isDebuggerThread);
      }
      break;
    }
  }

  free(threadname);
  threadname = NULL;
  close(s);
  return NULL;
}

static void *ceserver_thread_main(void *arg)
{
  (void)arg;

  initAPI();

  int sock0 = socket(AF_INET, SOCK_STREAM, 0);
  if (sock0 < 0)
  {
    perror("socket");
    return NULL;
  }

  int yes = 1;
  setsockopt(sock0, SOL_SOCKET, SO_REUSEADDR, (const char *)&yes, sizeof(yes));

  struct sockaddr_in addr;
  memset(&addr, 0, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_port = htons(52736);
  addr.sin_addr.s_addr = INADDR_ANY;

  if (bind(sock0, (struct sockaddr *)&addr, sizeof(addr)) != 0)
  {
    perror("bind");
    close(sock0);
    return NULL;
  }

  if (listen(sock0, 32) != 0)
  {
    perror("listen");
    close(sock0);
    return NULL;
  }

  printf("CEServer. Waiting for client connection\n");
  fflush(stdout);

  while (1)
  {
    int sock = accept(sock0, NULL, NULL);
    if (sock < 0)
      continue;

    setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (const char *)&yes, sizeof(yes));

    pthread_t th;
    if (pthread_create(&th, NULL, newconnection, (void *)(intptr_t)sock) == 0)
      pthread_detach(th);
    else
      close(sock);
  }

  return NULL;
}

static int g_server_started = 0;

__attribute__((constructor))
static void ceserver_autostart(void)
{
  if (!__sync_bool_compare_and_swap(&g_server_started, 0, 1))
    return;

  pthread_t th;
  if (pthread_create(&th, NULL, ceserver_thread_main, NULL) == 0)
    pthread_detach(th);
}

```

`ceserver-ios/jailed/ceserver.h`:

```h
/*
 * ceserver.h
 *
 *  Created on: Jul 18, 2011
 *      Author: erich
 */

#ifndef CESERVER_H_
#define CESERVER_H_

#include <stdint.h>
#include <sys/types.h>
#include "porthelp.h"

#define CMD_GETVERSION 0
#define CMD_CLOSECONNECTION 1
#define CMD_TERMINATESERVER 2
#define CMD_OPENPROCESS 3
#define CMD_CREATETOOLHELP32SNAPSHOT 4
#define CMD_PROCESS32FIRST 5
#define CMD_PROCESS32NEXT 6
#define CMD_CLOSEHANDLE 7
#define CMD_VIRTUALQUERYEX 8
#define CMD_READPROCESSMEMORY 9
#define CMD_WRITEPROCESSMEMORY 10
#define CMD_STARTDEBUG 11
#define CMD_STOPDEBUG 12
#define CMD_WAITFORDEBUGEVENT 13
#define CMD_CONTINUEFROMDEBUGEVENT 14
#define CMD_SETBREAKPOINT 15
#define CMD_REMOVEBREAKPOINT 16
#define CMD_SUSPENDTHREAD 17
#define CMD_RESUMETHREAD 18
#define CMD_GETTHREADCONTEXT 19
#define CMD_SETTHREADCONTEXT 20
#define CMD_GETARCHITECTURE 21
#define CMD_MODULE32FIRST 22
#define CMD_MODULE32NEXT 23

#define CMD_GETSYMBOLLISTFROMFILE 24
#define CMD_LOADEXTENSION         25

#define CMD_ALLOC                   26
#define CMD_FREE                    27
#define CMD_CREATETHREAD            28
#define CMD_LOADMODULE              29
#define CMD_SPEEDHACK_SETSPEED      30

#define CMD_VIRTUALQUERYEXFULL      31
#define CMD_GETREGIONINFO           32
#define CMD_GETABI                  33

#define CMD_SET_CONNECTION_NAME     34

#define CMD_CREATETOOLHELP32SNAPSHOTEX 35

#define CMD_CHANGEMEMORYPROTECTION  36

#define CMD_GETOPTIONS              37
#define CMD_GETOPTIONVALUE          38
#define CMD_SETOPTIONVALUE          39


#define CMD_PTRACE_MMAP             40


#define CMD_OPENNAMEDPIPE           41
#define CMD_PIPEREAD                42
#define CMD_PIPEWRITE               43

#define CMD_GETCESERVERPATH         44
#define CMD_ISANDROID               45

#define CMD_LOADMODULEEX            46

#define CMD_SETCURRENTPATH          47
#define CMD_GETCURRENTPATH          48
#define CMD_ENUMFILES               49
#define CMD_GETFILEPERMISSIONS      50
#define CMD_SETFILEPERMISSIONS      51
#define CMD_GETFILE                 52
#define CMD_PUTFILE                 53
#define CMD_CREATEDIR               54
#define CMD_DELETEFILE              55

#define CMD_AOBSCAN					200


#define CMD_COMMANDLIST2            255




#pragma pack(1)
typedef struct {
	int version;
	unsigned char stringsize;

} CeVersion, *PCeVersion;

typedef struct {
    DWORD dwFlags;
    DWORD th32ProcessID;
} CeCreateToolhelp32Snapshot, *PCeCreateToolhelp32Snapshot;

typedef struct {
    int result;
    int pid;
    int processnamesize;

} CeProcessEntry, *PCeProcessEntry;

typedef struct {
    int32_t result;
    int64_t modulebase;
    int32_t modulepart;
    int32_t modulesize;
    uint32_t modulefileoffset;
    int32_t modulenamesize;
} CeModuleEntry, *PCeModuleEntry;

typedef struct {
  int handle;
  uint64_t baseaddress;
} CeVirtualQueryExInput, *PCeVirtualQueryExInput;

typedef struct {
  uint8_t result;
  uint32_t protection;
  uint32_t type;
  uint64_t baseaddress;
  uint64_t size;
} CeVirtualQueryExOutput, *PCeVirtualQueryExOutput;

typedef struct {
  int handle;
  uint8_t flags;
} CeVirtualQueryExFullInput, *PCeVirtualQueryExFullInput;

typedef struct {
  uint32_t protection;
  uint32_t type;
  uint64_t baseaddress;
  uint64_t size;
} CeVirtualQueryExFullOutput, *PCeVirtualQueryExFullOutput;

typedef struct {
  uint32_t handle;
  uint64_t address;
  uint32_t size;
  uint8_t  compress;
} CeReadProcessMemoryInput, *PCeReadProcessMemoryInput;

typedef struct {
  int read;
} CeReadProcessMemoryOutput, *PCeReadProcessMemoryOutput;

typedef struct {
  int32_t handle;
  int64_t address;
  int32_t size;
} CeWriteProcessMemoryInput, *PCeWriteProcessMemoryInput;


typedef struct {
  int32_t written;
} CeWriteProcessMemoryOutput, *PCeWriteProcessMemoryOutput;


typedef struct {
  HANDLE hProcess;
  int tid;
  int debugreg;
  uint64_t Address;
  int bptype;
  int bpsize;
} CeSetBreapointInput, *PCeSetBreakpointInput;


typedef struct {
  int result;
} CeSetBreapointOutput, *PCeSetBreakpointOutput;

typedef struct {
  HANDLE hProcess;
  uint32_t tid;
  uint32_t debugreg;
  uint32_t wasWatchpoint;
} CeRemoveBreapointInput, *PCeRemoveBreakpointInput;


typedef struct {
  int result;
} CeRemoveBreapointOutput, *PCeRemoveBreakpointOutput;

typedef struct {
  HANDLE hProcess;
  int tid;
} CeSuspendThreadInput, *PCeSuspendThreadInput;


typedef struct {
  int result;
} CeSuspendThreadOutput, *PCeSuspendThreadOutput;

typedef struct {
  HANDLE hProcess;
  int tid;
} CeResumeThreadInput, *PCeResumeThreadInput;


typedef struct {
  int result;
} CeResumeThreadOutput, *PCeResumeThreadOutput;

typedef struct {
  HANDLE hProcess;
  uint64_t preferedBase;
  uint32_t size;
  uint32_t windowsprotection;
} CeAllocInput, *PCeAllocInput;


typedef struct {
  uint64_t address;
} CeAllocOutput, *PCeAllocOutput;

typedef struct {
  HANDLE hProcess;
  uint64_t address;
  uint32_t size;
} CeFreeInput, *PCeFreeInput;


typedef struct {
  uint32_t result;
} CeFreeOutput, *PCeFreeOutput;

typedef struct {
  HANDLE hProcess;
  uint64_t startaddress;
  uint64_t parameter;
} CeCreateThreadInput, *PCeCreateThreadInput;


typedef struct {
  HANDLE threadhandle;
} CeCreateThreadOutput, *PCeCreateThreadOutput;

typedef struct {
  HANDLE hProcess;
  uint32_t modulepathlength;

} CeLoadModuleInput, *PCeLoadModuleInput;

typedef struct {
  HANDLE hProcess;
  uint64_t dlopenaddress;
  uint32_t modulepathlength;

} CeLoadModuleInputEx, *PCeLoadModuleInputEx;


typedef struct {
  uint32_t result;
} CeLoadModuleOutput, *PCeLoadModuleOutput;


typedef struct {
  HANDLE hProcess;
  float speed;
} CeSpeedhackSetSpeedInput, *PCeSpeedhackSetSpeedInput;


typedef struct {
  uint32_t result;
} CeSpeedhackSetSpeedOutput, *PCeSpeedhackSetSpeedOutput;

typedef struct {
  HANDLE hProcess;
  uint64_t address;
  uint32_t size;
  uint32_t windowsprotection;
} CeChangeMemoryProtection, *PCeChangeMemoryProtection;

typedef struct {
  HANDLE hPipe;
  uint32_t size;
  uint32_t timeout;
} CeReadPipe, *PCeReadPipe;

typedef struct {
  HANDLE hPipe;
  uint32_t size;
  uint32_t timeout;

} CeWritePipe, *PCeWritePipe;


typedef struct {
	HANDLE hProcess;
	uint64_t start;
	uint64_t end;
	int inc;
	int protection;
	int scansize;
} CeAobScanInput, * PCeAobScanInput;



#pragma pack()

ssize_t sendall (int s, void *buf, size_t size, int flags);
ssize_t recvall (int s, void *buf, size_t size, int flags);

ssize_t sendstring16(int s, char *str, int flags);
char* receivestring16(int s);

int sendinteger(int s, int val, int flags);

int DispatchCommand(int currentsocket, unsigned char command);
int CheckForAndDispatchCommand(int currentsocket);

int getCEServerPath(char *path, int maxlen);

extern char *CESERVERPATH;
extern int ALLOC_WITHOUT_EXTENSION;
extern int PORT;
extern __thread char* threadname;


#if BUILD_OPTION == 1
  #define SHARED_LIBRARY
#endif

#endif /* CESERVER_H_ */

```

`ceserver-ios/jailed/context.h`:

```h
#ifndef CONTEXT_H_
#define CONTEXT_H_

#include <stdint.h>

typedef struct
{
  uint64_t regs[31];
  uint64_t sp;
  uint64_t pc;
  uint64_t pstate;
} CONTEXT_REGS;

typedef struct
{
  __uint128_t vregs[32];
  uint32_t fpsr;
  uint32_t fpcr;
  uint32_t __reserved[2];
} CONTEXT_FP;

#pragma pack(push, 1)
typedef struct
{
  uint32_t structsize;
  uint32_t type;
  CONTEXT_REGS regs;
  CONTEXT_FP fp;
} CONTEXT, *PCONTEXT;
#pragma pack(pop)

#endif

```

`ceserver-ios/jailed/control`:

```
Package: com.0xiuks.ceserver
Name: ceserver
Version: 1.0.0
Architecture: iphoneos-arm64
Description: ceserver-ios
Maintainer: 0xiuks
Author: xiu
Section: System


```

`ceserver-ios/jailed/debugger.c`:

```c
#include "debugger.h"

#include <errno.h>
#include <pthread.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <sys/sysctl.h>
#include <time.h>

#include <mach/exception_types.h>
#include <mach/exc.h>
#include <mach/mach.h>
#include <mach/mach_vm.h>
#include <mach/ndr.h>
#include <mach/thread_act.h>
#include <mach/thread_status.h>

#include "api.h"


#define S_USER ((uint32_t)(2u << 1))
#define WCR_ENABLE ((uint32_t)(1u))
#define WCR_LOAD ((uint32_t)(1u << 3))
#define WCR_STORE ((uint32_t)(1u << 4))

#ifndef EXC_ARM_DA_DEBUG
#define EXC_ARM_DA_DEBUG 0x102
#endif

typedef struct DebugEventQueueElement
{
  DebugEvent de;
  struct DebugEventQueueElement *next;
} DebugEventQueueElement;

typedef struct WatchpointSpec
{
  uint64_t aligned_start;
  uint64_t aligned_size;
  uint64_t requested_start;
  uint64_t requested_size;
} WatchpointSpec;

typedef struct DebuggerBreakpoint
{
  uint64_t address;
  int debugreg;
  int size;
  int bptype;
  thread_t tid;
  int hw_count;
  int hw_index[2];
  WatchpointSpec wp[2];
  struct DebuggerBreakpoint *next;
} DebuggerBreakpoint;

typedef struct PendingException
{
  thread_t thread;
  mach_port_t reply_port;
  mach_msg_id_t msg_id;
  struct PendingException *next;
} PendingException;

typedef struct DebuggerData
{
  mach_port_t exception_port;
  exception_mask_t exception_mask;
  exception_mask_t saved_masks[EXC_TYPES_COUNT];
  mach_port_t saved_ports[EXC_TYPES_COUNT];
  exception_behavior_t saved_behaviors[EXC_TYPES_COUNT];
  thread_state_flavor_t saved_flavors[EXC_TYPES_COUNT];
  mach_msg_type_number_t saved_count;
  task_t task;

  pthread_t exception_thread;
  int exception_thread_running;
  int exception_thread_started;
  thread_t exception_thread_port;

  pthread_mutex_t queue_mutex;
  pthread_cond_t queue_cond;
  DebugEventQueueElement *queue_head;
  DebugEventQueueElement *queue_tail;

  pthread_mutex_t breakpoint_mutex;
  DebuggerBreakpoint *breakpoints;

  thread_t *threads;
  mach_msg_type_number_t thread_count;

  thread_t single_step_thread;

  PendingException *pending_head;
  PendingException *pending_tail;
} DebuggerData;

static pthread_mutex_t g_debugger_lock = PTHREAD_MUTEX_INITIALIZER;
static PProcessData g_debugger_process = NULL;

static uint64_t get_thread_pc(thread_t thread);
static int set_single_step(thread_t thread, int enable);
static int is_thread_invalid_error(kern_return_t err);
static int get_debug_state(thread_t thread, arm_debug_state64_t *dbgstate, kern_return_t *out_err);
static int set_debug_state(thread_t thread, const arm_debug_state64_t *dbgstate, kern_return_t *out_err);
static int set_task_debug_state(task_t task, const arm_debug_state64_t *dbgstate, kern_return_t *out_err);
static int apply_breakpoint_state(thread_t thread, int debugreg, uint64_t address, int size, int enable, kern_return_t *out_err);
static int update_breakpoint_state_in_dbg(arm_debug_state64_t *dbgstate, int debugreg, uint64_t address, int size, int enable);
static int update_watchpoint_state_in_dbg(arm_debug_state64_t *dbgstate, int debugreg, const WatchpointSpec *spec, int bptype, int enable);
static int build_watchpoint_regs(const WatchpointSpec *spec, int bptype, uint64_t *out_wvr, uint64_t *out_wcr);
static int apply_breakpoint_state_transaction(DebuggerData *dbg, thread_t *threads, mach_msg_type_number_t thread_count,
                                              int debugreg, uint64_t address, int size, int enable);
static int apply_watchpoint_state_transaction(DebuggerData *dbg, thread_t *threads, mach_msg_type_number_t thread_count,
                                              const WatchpointSpec *specs, const int *hw_index, int hw_count, int bptype, int enable);
static int apply_breakpoint_state_best_effort(DebuggerData *dbg, int debugreg, uint64_t address, int size, int enable);
static int apply_watchpoint_state_best_effort(DebuggerData *dbg, const WatchpointSpec *specs, const int *hw_index,
                                              int hw_count, int bptype, int enable);
static void apply_breakpoints_to_thread(DebuggerData *dbg, thread_t thread);
static void announce_new_thread(DebuggerData *dbg, thread_t thread);
static void refresh_thread_list(DebuggerData *dbg, task_t task);
static int enqueue_pending_exception(DebuggerData *dbg, thread_t thread, mach_port_t reply_port, mach_msg_id_t msg_id);
static int reply_pending_exception(DebuggerData *dbg, thread_t thread, kern_return_t retcode);
static int reply_all_pending_for_thread(DebuggerData *dbg, thread_t thread, kern_return_t retcode);
static int thread_has_pending_exception(DebuggerData *dbg, thread_t thread);
static int suspend_thread_for_debug(DebuggerData *dbg, thread_t thread, int *out_suspended, kern_return_t *out_err);
static void resume_thread_for_debug(DebuggerData *dbg, thread_t thread, int was_suspended);
static void prune_thread_if_invalid(DebuggerData *dbg, thread_t thread, kern_return_t err);
static uint8_t get_watchpoint_count(void);
static int find_breakpoint_base(DebuggerData *dbg, uint64_t addr, uint64_t *base);
static int get_exception_esr_far(thread_t thread, uint64_t *esr, uint64_t *far);
static int is_watchpoint_exception_esr(uint64_t esr);
static int get_watchpoint_hw_index_from_esr(uint64_t esr, uint32_t *out_index);
static int get_watchpoint_hw_index_from_state(thread_t thread, uint64_t *addr, int *out_index);
static int align_requested_watchpoint(uint64_t requested_addr, uint64_t requested_size, WatchpointSpec *out, int out_cap);
static int enable_watchpoint_on_thread(DebuggerData *dbg, thread_t thread, const DebuggerBreakpoint *bp, kern_return_t *out_err);
static int disable_watchpoint_on_thread(thread_t thread, const DebuggerBreakpoint *bp, kern_return_t *out_err);
static DebuggerBreakpoint *find_watchpoint_by_addr(DebuggerData *dbg, thread_t thread, uint64_t addr);
static DebuggerBreakpoint *find_watchpoint_by_hw_index(DebuggerData *dbg, thread_t thread, int hw_index, int *out_slot);

static uint64_t bit_ceil_u64(uint64_t input)
{
  uint64_t value = 1;
  while (value < input)
  {
    uint64_t next = value << 1;
    if (next <= value)
      return 0;
    value = next;
  }
  return value;
}

static uint64_t bits_u64(uint64_t value, uint32_t msbit, uint32_t lsbit)
{
  uint64_t shift_left = (sizeof(value) * 8u) - 1u - msbit;
  value <<= shift_left;
  value >>= shift_left + lsbit;
  return value;
}

static uint64_t bit_u64(uint64_t value, uint32_t bit)
{
  return bits_u64(value, bit, bit);
}

static int lowest_bit_set_u32(uint32_t value)
{
  for (int i = 0; i < 8; i++)
  {
    if (value & (1u << i))
      return i;
  }
  return -1;
}

static int align_requested_watchpoint(uint64_t requested_addr, uint64_t requested_size, WatchpointSpec *out, int out_cap)
{
  if (requested_size == 0 || out_cap <= 0)
    return 0;

  const uint64_t min_watchpoint_alignment = 8;
  uint64_t aligned_size = requested_size < min_watchpoint_alignment ? min_watchpoint_alignment : requested_size;
  aligned_size = bit_ceil_u64(aligned_size);
  if (aligned_size == 0)
    return 0;

  uint64_t aligned_start = requested_addr & ~(aligned_size - 1);
  if (aligned_start + aligned_size >= requested_addr + requested_size)
  {
    out[0].aligned_start = aligned_start;
    out[0].aligned_size = aligned_size;
    out[0].requested_start = requested_addr;
    out[0].requested_size = requested_size;
    return 1;
  }

  if (out_cap < 2)
    return 0;

  uint64_t split_addr = aligned_start + aligned_size;
  uint64_t first_requested_addr = requested_addr;
  uint64_t first_requested_size = split_addr - requested_addr;
  uint64_t second_requested_addr = split_addr;
  uint64_t second_requested_size = requested_size - first_requested_size;

  WatchpointSpec first;
  WatchpointSpec second;
  if (align_requested_watchpoint(first_requested_addr, first_requested_size, &first, 1) != 1)
    return 0;
  if (align_requested_watchpoint(second_requested_addr, second_requested_size, &second, 1) != 1)
    return 0;

  out[0] = first;
  out[1] = second;
  return 2;
}

static int is_watchpoint_hw_index_used_locked(DebuggerData *dbg, int hw_index)
{
  for (DebuggerBreakpoint *bp = dbg->breakpoints; bp; bp = bp->next)
  {
    if (bp->bptype == 0 || bp->hw_count <= 0)
      continue;
    for (int i = 0; i < bp->hw_count; i++)
    {
      if (bp->hw_index[i] == hw_index)
        return 1;
    }
  }
  return 0;
}

static int allocate_watchpoint_hw_indices_locked(DebuggerData *dbg, int count, int *out_indices)
{
  uint8_t max_watchpoints = get_watchpoint_count();
  int found = 0;

  for (uint8_t i = 0; i < max_watchpoints && found < count; i++)
  {
    if (!is_watchpoint_hw_index_used_locked(dbg, i))
    {
      out_indices[found] = i;
      found++;
    }
  }

  return found == count;
}

static void queue_event(DebuggerData *dbg, const DebugEvent *ev)
{
  DebugEventQueueElement *elem = (DebugEventQueueElement *)malloc(sizeof(DebugEventQueueElement));
  if (!elem)
    return;
  elem->de = *ev;
  elem->next = NULL;

  pthread_mutex_lock(&dbg->queue_mutex);
  if (dbg->queue_tail)
    dbg->queue_tail->next = elem;
  else
    dbg->queue_head = elem;
  dbg->queue_tail = elem;
  pthread_cond_signal(&dbg->queue_cond);
  pthread_mutex_unlock(&dbg->queue_mutex);
}

static int wait_for_event(DebuggerData *dbg, DebugEvent *ev, int timeout_ms)
{
  int has_event = 0;
  pthread_mutex_lock(&dbg->queue_mutex);
  while (!dbg->queue_head && !has_event)
  {
    if (timeout_ms < 0)
    {
      pthread_cond_wait(&dbg->queue_cond, &dbg->queue_mutex);
    }
    else if (timeout_ms == 0)
    {
      break;
    }
    else
    {
      struct timespec ts;
      clock_gettime(CLOCK_REALTIME, &ts);
      ts.tv_sec += timeout_ms / 1000;
      ts.tv_nsec += (timeout_ms % 1000) * 1000000L;
      if (ts.tv_nsec >= 1000000000L)
      {
        ts.tv_sec += 1;
        ts.tv_nsec -= 1000000000L;
      }
      if (pthread_cond_timedwait(&dbg->queue_cond, &dbg->queue_mutex, &ts) == ETIMEDOUT)
        break;
    }
  }

  if (dbg->queue_head)
  {
    DebugEventQueueElement *elem = dbg->queue_head;
    dbg->queue_head = elem->next;
    if (!dbg->queue_head)
      dbg->queue_tail = NULL;
    *ev = elem->de;
    free(elem);
    has_event = 1;
  }
  pthread_mutex_unlock(&dbg->queue_mutex);
  return has_event;
}

static uint8_t get_breakpoint_count(void)
{
  uint32_t n = 0;
  size_t len = sizeof(n);
  if (sysctlbyname("hw.optional.breakpoint", &n, &len, NULL, 0) == 0)
    return (uint8_t)n;
  return 0;
}

static uint8_t get_watchpoint_count(void)
{
  uint32_t n = 0;
  size_t len = sizeof(n);
  if (sysctlbyname("hw.optional.watchpoint", &n, &len, NULL, 0) == 0)
    return (uint8_t)n;
  return 0;
}

static PProcessData get_process_for_exception(mach_port_t task)
{
  (void)task;
  PProcessData p = NULL;
  pthread_mutex_lock(&g_debugger_lock);
  p = g_debugger_process;
  pthread_mutex_unlock(&g_debugger_lock);
  return p;
}

static int register_thread(DebuggerData *dbg, thread_t thread)
{
  for (mach_msg_type_number_t i = 0; i < dbg->thread_count; i++)
  {
    if (dbg->threads[i] == thread)
    {
      mach_port_deallocate(mach_task_self(), thread);
      return 0;
    }
  }

  thread_t *newlist = (thread_t *)realloc(dbg->threads, sizeof(thread_t) * (dbg->thread_count + 1));
  if (!newlist)
  {
    mach_port_deallocate(mach_task_self(), thread);
    return 0;
  }
  dbg->threads = newlist;
  dbg->threads[dbg->thread_count] = thread;
  dbg->thread_count++;

  announce_new_thread(dbg, thread);
  return 1;
}

static kern_return_t handle_exception_raise(DebuggerData *dbg, __Request__exception_raise_t *req)
{
  PProcessData p = get_process_for_exception(req->task.name);
  if (!p || !p->debuggerData)
    return KERN_FAILURE;

  uint64_t exc_code = 0;
  uint64_t exc_subcode = 0;
  if (req->codeCnt > 0)
    exc_code = (uint64_t)req->code[0];
  if (req->codeCnt > 1)
    exc_subcode = (uint64_t)req->code[1];

  register_thread(dbg, req->thread.name);
  mach_port_deallocate(mach_task_self(), req->task.name);

  if (!enqueue_pending_exception(dbg, req->thread.name, req->Head.msgh_remote_port, req->Head.msgh_id))
    debug_log("Failed to queue pending exception for thread %u\n", req->thread.name);

  int signo = SIGTRAP;
  switch (req->exception)
  {
    case EXC_BAD_ACCESS:
      signo = SIGBUS;
      break;
    case EXC_BAD_INSTRUCTION:
      signo = SIGILL;
      break;
    case EXC_ARITHMETIC:
      signo = SIGFPE;
      break;
    case EXC_BREAKPOINT:
    default:
      signo = SIGTRAP;
      break;
  }

  if (dbg->single_step_thread == req->thread.name)
  {
    set_single_step(req->thread.name, 0);
    dbg->single_step_thread = MACH_PORT_NULL;
  }

  DebugEvent ev;
  memset(&ev, 0, sizeof(ev));
  ev.debugevent = signo;
  ev.threadid = (int64_t)req->thread.name;
  ev.address = get_thread_pc(req->thread.name);

  if (req->exception == EXC_BREAKPOINT)
  {
    uint64_t pc = ev.address;
    uint64_t esr = 0;
    uint64_t far = 0;
    int have_esr_far = get_exception_esr_far(req->thread.name, &esr, &far);
    DebuggerBreakpoint *wp = NULL;
    uint64_t candidate = far ? far : exc_subcode;

    if (have_esr_far && is_watchpoint_exception_esr(esr))
    {
      uint32_t hw_index = 0;
      int slot = -1;
      if (get_watchpoint_hw_index_from_esr(esr, &hw_index))
        wp = find_watchpoint_by_hw_index(dbg, req->thread.name, (int)hw_index, &slot);
      if (!wp && candidate)
      {
        int hw_index_state = -1;
        uint64_t candidate_state = candidate;
        if (get_watchpoint_hw_index_from_state(req->thread.name, &candidate_state, &hw_index_state))
        {
          wp = find_watchpoint_by_hw_index(dbg, req->thread.name, hw_index_state, NULL);
          if (candidate_state)
            candidate = candidate_state;
        }
      }
      if (!wp && candidate)
        wp = find_watchpoint_by_addr(dbg, req->thread.name, candidate);
    }
    else if (exc_code == EXC_ARM_DA_DEBUG)
    {
      if (candidate)
      {
        int hw_index_state = -1;
        uint64_t candidate_state = candidate;
        if (get_watchpoint_hw_index_from_state(req->thread.name, &candidate_state, &hw_index_state))
        {
          wp = find_watchpoint_by_hw_index(dbg, req->thread.name, hw_index_state, NULL);
          if (candidate_state)
            candidate = candidate_state;
        }
        if (!wp)
          wp = find_watchpoint_by_addr(dbg, req->thread.name, candidate);
      }
    }

    if (wp)
    {
      ev.address = wp->address;
    }
    else if (exc_code == 1 && exc_subcode)
    {
      DebuggerBreakpoint *addr_wp = find_watchpoint_by_addr(dbg, req->thread.name, exc_subcode);
      if (addr_wp)
      {
        ev.address = addr_wp->address;
      }
      else
      {
        uint64_t base = 0;
        if (find_breakpoint_base(dbg, exc_subcode, &base))
          ev.address = base;
        else if (find_breakpoint_base(dbg, pc, &base))
          ev.address = base;
        else
          ev.address = exc_subcode;
      }
    }
    else if (exc_code == 2 && exc_subcode)
    {
      uint64_t base = 0;
      if (find_breakpoint_base(dbg, exc_subcode, &base))
      {
        ev.address = base;
      }
      else if (find_breakpoint_base(dbg, pc, &base))
      {
        ev.address = base;
      }
      else
      {
        ev.address = exc_subcode;
      }
    }
    else
    {
      uint64_t base = 0;
      if (find_breakpoint_base(dbg, pc, &base))
        ev.address = base;
      else
        ev.address = pc;
    }
  }
  else if (req->exception == EXC_BAD_ACCESS)
  {
    ev.address = exc_subcode ? exc_subcode : ev.address;
  }
  queue_event(dbg, &ev);

  return KERN_SUCCESS;
}

static void *exception_thread_main(void *arg)
{
  PProcessData p = (PProcessData)arg;
  DebuggerData *dbg = (DebuggerData *)p->debuggerData;
  if (dbg && dbg->exception_thread_port == MACH_PORT_NULL)
    dbg->exception_thread_port = mach_thread_self();

  union __RequestUnion__exc_subsystem request;

  while (dbg->exception_thread_running)
  {
    kern_return_t kr = mach_msg(&request.Request_exception_raise.Head, MACH_RCV_MSG, 0,
                                sizeof(request), dbg->exception_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    if (kr == MACH_RCV_INTERRUPTED)
      continue;
    if (kr != KERN_SUCCESS)
      break;

    mach_msg_header_t *in = &request.Request_exception_raise.Head;

    if (in->msgh_id == 2401)
    {
      handle_exception_raise(dbg, &request.Request_exception_raise);
    }
    else if (in->msgh_id == 2402 || in->msgh_id == 2403)
    {
      debug_log("Unhandled exception message id=%d\n", in->msgh_id);
    }
  }

  return NULL;
}

static uint64_t get_thread_pc(thread_t thread)
{
  arm_thread_state64_t state;
  mach_msg_type_number_t count = ARM_THREAD_STATE64_COUNT;
  if (thread_get_state(thread, ARM_THREAD_STATE64, (thread_state_t)&state, &count) != KERN_SUCCESS)
    return 0;
  return (uint64_t)state.__pc;
}

static int set_single_step(thread_t thread, int enable)
{
  arm_debug_state64_t dbgstate;
  mach_msg_type_number_t count = ARM_DEBUG_STATE64_COUNT;
  if (thread_get_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&dbgstate, &count) != KERN_SUCCESS)
    return 0;

  if (enable)
    dbgstate.__mdscr_el1 |= 1u;
  else
    dbgstate.__mdscr_el1 &= ~1u;

  return thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&dbgstate, ARM_DEBUG_STATE64_COUNT) == KERN_SUCCESS;
}

static int is_thread_invalid_error(kern_return_t err)
{
  return err == KERN_INVALID_ARGUMENT || err == KERN_INVALID_CAPABILITY || err == KERN_TERMINATED;
}

static int get_debug_state(thread_t thread, arm_debug_state64_t *dbgstate, kern_return_t *out_err)
{
  mach_msg_type_number_t count = ARM_DEBUG_STATE64_COUNT;
  kern_return_t kr = thread_get_state(thread, ARM_DEBUG_STATE64, (thread_state_t)dbgstate, &count);
  if (out_err)
    *out_err = kr;
  return kr == KERN_SUCCESS;
}

static int set_debug_state(thread_t thread, const arm_debug_state64_t *dbgstate, kern_return_t *out_err)
{
  kern_return_t kr = thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)dbgstate, ARM_DEBUG_STATE64_COUNT);
  if (out_err)
    *out_err = kr;
  return kr == KERN_SUCCESS;
}

static int set_task_debug_state(task_t task, const arm_debug_state64_t *dbgstate, kern_return_t *out_err)
{
  if (task == MACH_PORT_NULL)
  {
    if (out_err)
      *out_err = KERN_INVALID_ARGUMENT;
    return 0;
  }
  kern_return_t kr = task_set_state(task, ARM_DEBUG_STATE64, (thread_state_t)dbgstate, ARM_DEBUG_STATE64_COUNT);
  if (out_err)
    *out_err = kr;
  return kr == KERN_SUCCESS;
}

static int update_breakpoint_state_in_dbg(arm_debug_state64_t *dbgstate, int debugreg, uint64_t address, int size, int enable)
{
  if (debugreg < 0 || debugreg >= (int)(sizeof(dbgstate->__bcr) / sizeof(dbgstate->__bcr[0])))
    return 0;

  if (enable)
  {
    uint64_t aligned = address;
    uint32_t control_value = 0;
    if (size <= 1)
    {
      control_value = (0x1u << 5) | 7u;
    }
    else if (size == 2)
    {
      control_value = (0x3u << 5) | 7u;
      aligned &= ~1ull;
    }
    else
    {
      control_value = (0xfu << 5) | 7u;
      aligned &= ~3ull;
    }
    dbgstate->__bvr[debugreg] = aligned;
    dbgstate->__bcr[debugreg] = control_value;
  }
  else
  {
    dbgstate->__bvr[debugreg] = 0;
    dbgstate->__bcr[debugreg] = 0;
  }
  return 1;
}

static int build_watchpoint_regs(const WatchpointSpec *spec, int bptype, uint64_t *out_wvr, uint64_t *out_wcr)
{
  if (!spec || !out_wvr || !out_wcr)
    return 0;
  if (bptype < 1 || bptype > 3)
    return 0;
  if (spec->requested_size == 0)
    return 0;

  const int watch_read = (bptype == 2 || bptype == 3);
  const int watch_write = (bptype == 1 || bptype == 3);

  uint64_t aligned_dword = spec->aligned_start;
  uint64_t offset = spec->requested_start - spec->aligned_start;
  uint64_t watch_size = spec->requested_size;

  if (spec->aligned_size <= 8 && watch_size <= 8 && (offset + watch_size) <= 8)
  {
    uint64_t bas = ((1ull << watch_size) - 1ull) << offset;
    uint64_t wcr = (bas << 5) | S_USER |
                   (watch_read ? WCR_LOAD : 0) |
                   (watch_write ? WCR_STORE : 0) |
                   WCR_ENABLE;
    *out_wvr = aligned_dword;
    *out_wcr = wcr;
  }
  else
  {
    uint64_t mask = (uint64_t)__builtin_popcountll(spec->aligned_size - 1) << 24;
    uint64_t not_bas_wp = (uint64_t)0xff << 5;
    uint64_t wcr = mask | not_bas_wp | S_USER |
                   (watch_read ? WCR_LOAD : 0) |
                   (watch_write ? WCR_STORE : 0) |
                   WCR_ENABLE;
    *out_wvr = spec->aligned_start;
    *out_wcr = wcr;
  }

  return 1;
}

static int update_watchpoint_state_in_dbg(arm_debug_state64_t *dbgstate, int debugreg, const WatchpointSpec *spec, int bptype,
                                          int enable)
{
  if (debugreg < 0 || debugreg >= (int)(sizeof(dbgstate->__wcr) / sizeof(dbgstate->__wcr[0])))
    return 0;

  if (enable)
  {
    uint64_t wvr = 0;
    uint64_t wcr = 0;
    if (!build_watchpoint_regs(spec, bptype, &wvr, &wcr))
      return 0;
    dbgstate->__wvr[debugreg] = wvr;
    dbgstate->__wcr[debugreg] = wcr;
  }
  else
  {
    dbgstate->__wvr[debugreg] = 0;
    dbgstate->__wcr[debugreg] = 0;
  }
  return 1;
}

typedef struct ThreadDebugStateSnapshot
{
  thread_t thread;
  arm_debug_state64_t state;
  int suspended;
  int applied;
} ThreadDebugStateSnapshot;

static int apply_breakpoint_state_transaction(DebuggerData *dbg, thread_t *threads, mach_msg_type_number_t thread_count,
                                              int debugreg, uint64_t address, int size, int enable)
{
  if (!threads || thread_count == 0)
    return 0;

  ThreadDebugStateSnapshot *snapshots = (ThreadDebugStateSnapshot *)calloc(thread_count, sizeof(ThreadDebugStateSnapshot));
  if (!snapshots)
    return 0;

  thread_t self_thread = mach_thread_self();
  thread_t exception_thread = dbg ? dbg->exception_thread_port : MACH_PORT_NULL;
  int ok = 1;
  int applied = 0;
  int task_state_pending = 0;
  arm_debug_state64_t task_state_new;
  for (mach_msg_type_number_t i = 0; i < thread_count; i++)
  {
    thread_t thread = threads[i];
    kern_return_t err = KERN_SUCCESS;
    int suspended = 0;

    if (thread != self_thread && thread != exception_thread && !suspend_thread_for_debug(dbg, thread, &suspended, &err))
    {
      if (is_thread_invalid_error(err))
      {
        prune_thread_if_invalid(dbg, thread, err);
        continue;
      }
      ok = 0;
      break;
    }

    snapshots[i].thread = thread;
    snapshots[i].suspended = suspended;

    if (!get_debug_state(thread, &snapshots[i].state, &err))
    {
      if (is_thread_invalid_error(err))
      {
        prune_thread_if_invalid(dbg, thread, err);
        resume_thread_for_debug(dbg, thread, suspended);
        continue;
      }
      ok = 0;
      break;
    }

    arm_debug_state64_t new_state = snapshots[i].state;
    if (!update_breakpoint_state_in_dbg(&new_state, debugreg, address, size, enable))
    {
      ok = 0;
      break;
    }

    if (!set_debug_state(thread, &new_state, &err))
    {
      if (is_thread_invalid_error(err))
      {
        prune_thread_if_invalid(dbg, thread, err);
        resume_thread_for_debug(dbg, thread, suspended);
        continue;
      }
      ok = 0;
      break;
    }

    snapshots[i].applied = 1;
    applied++;
    if (!task_state_pending && dbg && dbg->task != MACH_PORT_NULL)
    {
      task_state_new = new_state;
      task_state_pending = 1;
    }
  }

  if (!ok)
  {
    for (mach_msg_type_number_t i = 0; i < thread_count; i++)
    {
      if (snapshots[i].applied)
        set_debug_state(snapshots[i].thread, &snapshots[i].state, NULL);
    }
  }
  else if (applied > 0 && task_state_pending && dbg && dbg->task != MACH_PORT_NULL)
  {
    set_task_debug_state(dbg->task, &task_state_new, NULL);
  }

  for (mach_msg_type_number_t i = 0; i < thread_count; i++)
  {
    if (snapshots[i].suspended)
      resume_thread_for_debug(dbg, snapshots[i].thread, snapshots[i].suspended);
  }

  if (self_thread != MACH_PORT_NULL)
    mach_port_deallocate(mach_task_self(), self_thread);
  free(snapshots);
  return ok && applied > 0;
}

static int apply_breakpoint_state_best_effort(DebuggerData *dbg, int debugreg, uint64_t address, int size, int enable)
{
  if (!dbg || !dbg->threads || dbg->thread_count == 0)
    return 0;

  thread_t self_thread = mach_thread_self();
  thread_t exception_thread = dbg ? dbg->exception_thread_port : MACH_PORT_NULL;
  int ok = 0;
  int task_state_pending = 0;
  arm_debug_state64_t task_state_new;
  for (mach_msg_type_number_t i = 0; i < dbg->thread_count; i++)
  {
    thread_t thread = dbg->threads[i];
    kern_return_t err = KERN_SUCCESS;
    int suspended = 0;
    if (thread != self_thread && thread != exception_thread && !suspend_thread_for_debug(dbg, thread, &suspended, &err))
    {
      prune_thread_if_invalid(dbg, thread, err);
      continue;
    }
    if (apply_breakpoint_state(thread, debugreg, address, size, enable, &err))
    {
      ok = 1;
      if (!task_state_pending && dbg->task != MACH_PORT_NULL)
      {
        if (get_debug_state(thread, &task_state_new, NULL))
          task_state_pending = 1;
      }
    }
    else
      prune_thread_if_invalid(dbg, thread, err);
    resume_thread_for_debug(dbg, thread, suspended);
  }

  if (self_thread != MACH_PORT_NULL)
    mach_port_deallocate(mach_task_self(), self_thread);
  if (ok && task_state_pending && dbg->task != MACH_PORT_NULL)
    set_task_debug_state(dbg->task, &task_state_new, NULL);

  return ok;
}

static int apply_watchpoint_state_best_effort(DebuggerData *dbg, const WatchpointSpec *specs, const int *hw_index,
                                              int hw_count, int bptype, int enable)
{
  if (!dbg || !dbg->threads || dbg->thread_count == 0)
    return 0;
  if (hw_count <= 0 || !hw_index)
    return 0;
  if (enable && !specs)
    return 0;

  DebuggerBreakpoint temp_wp;
  memset(&temp_wp, 0, sizeof(temp_wp));
  temp_wp.bptype = bptype;
  temp_wp.hw_count = hw_count;
  temp_wp.hw_index[0] = hw_index[0];
  temp_wp.hw_index[1] = hw_count > 1 ? hw_index[1] : hw_index[0];
  if (enable)
  {
    temp_wp.wp[0] = specs[0];
    temp_wp.wp[1] = hw_count > 1 ? specs[1] : specs[0];
  }

  thread_t self_thread = mach_thread_self();
  thread_t exception_thread = dbg ? dbg->exception_thread_port : MACH_PORT_NULL;
  int ok = 0;
  int task_state_pending = 0;
  arm_debug_state64_t task_state_new;
  for (mach_msg_type_number_t i = 0; i < dbg->thread_count; i++)
  {
    thread_t thread = dbg->threads[i];
    kern_return_t err = KERN_SUCCESS;
    int suspended = 0;
    if (thread != self_thread && thread != exception_thread && !suspend_thread_for_debug(dbg, thread, &suspended, &err))
    {
      prune_thread_if_invalid(dbg, thread, err);
      continue;
    }
    if (enable ? enable_watchpoint_on_thread(dbg, thread, &temp_wp, &err)
               : disable_watchpoint_on_thread(thread, &temp_wp, &err))
    {
      ok = 1;
      if (!task_state_pending && dbg->task != MACH_PORT_NULL)
      {
        if (get_debug_state(thread, &task_state_new, NULL))
          task_state_pending = 1;
      }
    }
    else
    {
      prune_thread_if_invalid(dbg, thread, err);
    }
    resume_thread_for_debug(dbg, thread, suspended);
  }

  if (self_thread != MACH_PORT_NULL)
    mach_port_deallocate(mach_task_self(), self_thread);
  if (ok && task_state_pending && dbg->task != MACH_PORT_NULL)
    set_task_debug_state(dbg->task, &task_state_new, NULL);

  return ok;
}

static int apply_watchpoint_state_transaction(DebuggerData *dbg, thread_t *threads, mach_msg_type_number_t thread_count,
                                              const WatchpointSpec *specs, const int *hw_index, int hw_count, int bptype, int enable)
{
  if (!threads || thread_count == 0)
    return 0;
  if (hw_count <= 0 || !hw_index)
    return 0;
  if (enable && !specs)
    return 0;

  ThreadDebugStateSnapshot *snapshots = (ThreadDebugStateSnapshot *)calloc(thread_count, sizeof(ThreadDebugStateSnapshot));
  if (!snapshots)
    return 0;

  thread_t self_thread = mach_thread_self();
  thread_t exception_thread = dbg ? dbg->exception_thread_port : MACH_PORT_NULL;
  int ok = 1;
  int applied = 0;
  int task_state_pending = 0;
  arm_debug_state64_t task_state_new;
  for (mach_msg_type_number_t i = 0; i < thread_count; i++)
  {
    thread_t thread = threads[i];
    kern_return_t err = KERN_SUCCESS;
    int suspended = 0;

    if (thread != self_thread && thread != exception_thread && !suspend_thread_for_debug(dbg, thread, &suspended, &err))
    {
      if (is_thread_invalid_error(err))
      {
        prune_thread_if_invalid(dbg, thread, err);
        continue;
      }
      ok = 0;
      break;
    }

    snapshots[i].thread = thread;
    snapshots[i].suspended = suspended;

    if (!get_debug_state(thread, &snapshots[i].state, &err))
    {
      if (is_thread_invalid_error(err))
      {
        prune_thread_if_invalid(dbg, thread, err);
        resume_thread_for_debug(dbg, thread, suspended);
        continue;
      }
      ok = 0;
      break;
    }

    arm_debug_state64_t new_state = snapshots[i].state;
    for (int j = 0; j < hw_count; j++)
    {
      const WatchpointSpec *spec = enable ? &specs[j] : NULL;
      if (!update_watchpoint_state_in_dbg(&new_state, hw_index[j], spec, bptype, enable))
      {
        ok = 0;
        break;
      }
    }
    if (!ok)
      break;

    if (!set_debug_state(thread, &new_state, &err))
    {
      if (is_thread_invalid_error(err))
      {
        prune_thread_if_invalid(dbg, thread, err);
        resume_thread_for_debug(dbg, thread, suspended);
        continue;
      }
      ok = 0;
      break;
    }

    snapshots[i].applied = 1;
    applied++;
    if (!task_state_pending && dbg && dbg->task != MACH_PORT_NULL)
    {
      task_state_new = new_state;
      task_state_pending = 1;
    }
  }

  if (!ok)
  {
    for (mach_msg_type_number_t i = 0; i < thread_count; i++)
    {
      if (snapshots[i].applied)
        set_debug_state(snapshots[i].thread, &snapshots[i].state, NULL);
    }
  }
  else if (applied > 0 && task_state_pending && dbg && dbg->task != MACH_PORT_NULL)
  {
    set_task_debug_state(dbg->task, &task_state_new, NULL);
  }

  for (mach_msg_type_number_t i = 0; i < thread_count; i++)
  {
    if (snapshots[i].suspended)
      resume_thread_for_debug(dbg, snapshots[i].thread, snapshots[i].suspended);
  }

  if (self_thread != MACH_PORT_NULL)
    mach_port_deallocate(mach_task_self(), self_thread);
  free(snapshots);
  return ok && applied > 0;
}
static void fill_context_from_thread(thread_t thread, PCONTEXT Context)
{
  arm_thread_state64_t gpr;
  mach_msg_type_number_t gpr_count = ARM_THREAD_STATE64_COUNT;
  memset(Context, 0, sizeof(*Context));

  if (thread_get_state(thread, ARM_THREAD_STATE64, (thread_state_t)&gpr, &gpr_count) == KERN_SUCCESS)
  {
    for (int i = 0; i < 29; i++)
      Context->regs.regs[i] = gpr.__x[i];
    Context->regs.regs[29] = gpr.__fp;
    Context->regs.regs[30] = gpr.__lr;
    Context->regs.sp = gpr.__sp;
    Context->regs.pc = gpr.__pc;
    Context->regs.pstate = gpr.__cpsr;
  }

  arm_neon_state64_t neon;
  mach_msg_type_number_t neon_count = ARM_NEON_STATE64_COUNT;
  if (thread_get_state(thread, ARM_NEON_STATE64, (thread_state_t)&neon, &neon_count) == KERN_SUCCESS)
  {
    memcpy(Context->fp.vregs, neon.__v, sizeof(neon.__v));
    Context->fp.fpsr = neon.__fpsr;
    Context->fp.fpcr = neon.__fpcr;
  }

  Context->structsize = sizeof(CONTEXT);
  Context->type = 3;
}

static int apply_breakpoint_state(thread_t thread, int debugreg, uint64_t address, int size, int enable, kern_return_t *out_err)
{
  arm_debug_state64_t dbgstate;
  mach_msg_type_number_t count = ARM_DEBUG_STATE64_COUNT;
  kern_return_t kr = thread_get_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&dbgstate, &count);
  if (kr != KERN_SUCCESS)
  {
    if (out_err)
      *out_err = kr;
    return 0;
  }

  if (debugreg < 0 || debugreg >= (int)(sizeof(dbgstate.__bcr) / sizeof(dbgstate.__bcr[0])))
    return 0;

  if (enable)
  {
    uint64_t aligned = address;
    uint32_t control_value = 0;
    if (size <= 1)
    {
      control_value = (0x1u << 5) | 7u;
    }
    else if (size == 2)
    {
      control_value = (0x3u << 5) | 7u;
      aligned &= ~1ull;
    }
    else
    {
      control_value = (0xfu << 5) | 7u;
      aligned &= ~3ull;
    }
    dbgstate.__bvr[debugreg] = aligned;
    dbgstate.__bcr[debugreg] = control_value;
  }
  else
  {
    dbgstate.__bvr[debugreg] = 0;
    dbgstate.__bcr[debugreg] = 0;
  }

  kr = thread_set_state(thread, ARM_DEBUG_STATE64, (thread_state_t)&dbgstate, ARM_DEBUG_STATE64_COUNT);
  if (kr != KERN_SUCCESS)
  {
    if (out_err)
      *out_err = kr;
    return 0;
  }
  if (out_err)
    *out_err = KERN_SUCCESS;
  return 1;
}

static int enable_watchpoint_on_thread(DebuggerData *dbg, thread_t thread, const DebuggerBreakpoint *bp,
                                       kern_return_t *out_err)
{
  (void)dbg;
  if (!bp || bp->bptype == 0 || bp->hw_count <= 0)
    return 0;

  arm_debug_state64_t dbgstate;
  kern_return_t err = KERN_SUCCESS;
  if (!get_debug_state(thread, &dbgstate, &err))
  {
    if (out_err)
      *out_err = err;
    return 0;
  }

  arm_debug_state64_t new_state = dbgstate;
  for (int i = 0; i < bp->hw_count; i++)
  {
    if (!update_watchpoint_state_in_dbg(&new_state, bp->hw_index[i], &bp->wp[i], bp->bptype, 1))
      return 0;
  }

  if (!set_debug_state(thread, &new_state, &err))
  {
    if (out_err)
      *out_err = err;
    return 0;
  }

  if (out_err)
    *out_err = KERN_SUCCESS;
  return 1;
}

static int disable_watchpoint_on_thread(thread_t thread, const DebuggerBreakpoint *bp, kern_return_t *out_err)
{
  if (!bp || bp->bptype == 0 || bp->hw_count <= 0)
    return 0;

  arm_debug_state64_t dbgstate;
  kern_return_t err = KERN_SUCCESS;
  if (!get_debug_state(thread, &dbgstate, &err))
  {
    if (out_err)
      *out_err = err;
    return 0;
  }

  arm_debug_state64_t new_state = dbgstate;
  for (int i = 0; i < bp->hw_count; i++)
  {
    if (!update_watchpoint_state_in_dbg(&new_state, bp->hw_index[i], NULL, bp->bptype, 0))
      return 0;
  }

  if (!set_debug_state(thread, &new_state, &err))
  {
    if (out_err)
      *out_err = err;
    return 0;
  }

  if (out_err)
    *out_err = KERN_SUCCESS;
  return 1;
}

static int enqueue_pending_exception(DebuggerData *dbg, thread_t thread, mach_port_t reply_port, mach_msg_id_t msg_id)
{
  PendingException *pe = (PendingException *)malloc(sizeof(PendingException));
  if (!pe)
    return 0;
  pe->thread = thread;
  pe->reply_port = reply_port;
  pe->msg_id = msg_id;
  pe->next = NULL;

  pthread_mutex_lock(&dbg->queue_mutex);
  if (dbg->pending_tail)
    dbg->pending_tail->next = pe;
  else
    dbg->pending_head = pe;
  dbg->pending_tail = pe;
  pthread_mutex_unlock(&dbg->queue_mutex);
  return 1;
}

static int reply_pending_exception(DebuggerData *dbg, thread_t thread, kern_return_t retcode)
{
  PendingException *prev = NULL;
  PendingException *cur = NULL;

  pthread_mutex_lock(&dbg->queue_mutex);
  cur = dbg->pending_head;
  while (cur)
  {
    if (cur->thread == thread)
      break;
    prev = cur;
    cur = cur->next;
  }

  if (!cur)
  {
    pthread_mutex_unlock(&dbg->queue_mutex);
    return 0;
  }

  if (prev)
    prev->next = cur->next;
  else
    dbg->pending_head = cur->next;
  if (dbg->pending_tail == cur)
    dbg->pending_tail = prev;
  pthread_mutex_unlock(&dbg->queue_mutex);

  if (cur->msg_id == 2401)
  {
    __Reply__exception_raise_t r;
    memset(&r, 0, sizeof(r));
    r.Head.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MOVE_SEND_ONCE, 0);
    r.Head.msgh_size = sizeof(r);
    r.Head.msgh_remote_port = cur->reply_port;
    r.Head.msgh_local_port = MACH_PORT_NULL;
    r.Head.msgh_id = cur->msg_id + 100;
    r.NDR = NDR_record;
    r.RetCode = retcode;
    mach_msg(&r.Head, MACH_SEND_MSG, r.Head.msgh_size, 0, MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
  }

  free(cur);
  return 1;
}

static int reply_all_pending_for_thread(DebuggerData *dbg, thread_t thread, kern_return_t retcode)
{
  int count = 0;
  while (reply_pending_exception(dbg, thread, retcode))
    count++;
  return count;
}

static int thread_has_pending_exception(DebuggerData *dbg, thread_t thread)
{
  int found = 0;
  pthread_mutex_lock(&dbg->queue_mutex);
  PendingException *cur = dbg->pending_head;
  while (cur)
  {
    if (cur->thread == thread)
    {
      found = 1;
      break;
    }
    cur = cur->next;
  }
  pthread_mutex_unlock(&dbg->queue_mutex);
  return found;
}

static int suspend_thread_for_debug(DebuggerData *dbg, thread_t thread, int *out_suspended, kern_return_t *out_err)
{
  if (out_suspended)
    *out_suspended = 0;

  if (thread_has_pending_exception(dbg, thread))
  {
    if (out_err)
      *out_err = KERN_SUCCESS;
    // Thread is already stopped in the exception handler; do not suspend.
    return 1;
  }

  kern_return_t kr = thread_suspend(thread);
  if (kr != KERN_SUCCESS)
  {
    if (out_err)
      *out_err = kr;
    return 0;
  }

  if (out_suspended)
    *out_suspended = 1;
  return 1;
}

static void resume_thread_for_debug(DebuggerData *dbg, thread_t thread, int was_suspended)
{
  if (!was_suspended)
    return;
  kern_return_t kr = thread_resume(thread);
  if (kr != KERN_SUCCESS)
    prune_thread_if_invalid(dbg, thread, kr);
}

static void prune_thread_if_invalid(DebuggerData *dbg, thread_t thread, kern_return_t err)
{
  if (err != KERN_INVALID_ARGUMENT && err != KERN_INVALID_CAPABILITY && err != KERN_TERMINATED)
    return;

  for (mach_msg_type_number_t i = 0; i < dbg->thread_count; i++)
  {
    if (dbg->threads[i] == thread)
    {
      mach_port_deallocate(mach_task_self(), dbg->threads[i]);
      for (mach_msg_type_number_t j = i + 1; j < dbg->thread_count; j++)
        dbg->threads[j - 1] = dbg->threads[j];
      dbg->thread_count--;
      break;
    }
  }
}

static DebuggerBreakpoint *find_watchpoint_by_addr(DebuggerData *dbg, thread_t thread, uint64_t addr)
{
  DebuggerBreakpoint *found = NULL;

  pthread_mutex_lock(&dbg->breakpoint_mutex);
  for (DebuggerBreakpoint *bp = dbg->breakpoints; bp; bp = bp->next)
  {
    if (bp->bptype == 0 || bp->size <= 0)
      continue;
    if (bp->tid != -1 && bp->tid != thread)
      continue;

    int slot_count = bp->hw_count > 0 ? bp->hw_count : 0;
    if (slot_count == 0)
    {
      uint64_t start = bp->address;
      uint64_t end = start + (uint64_t)bp->size;
      if (addr >= start && addr < end)
      {
        found = bp;
        break;
      }
      continue;
    }

    for (int i = 0; i < slot_count; i++)
    {
      const WatchpointSpec *spec = &bp->wp[i];
      uint64_t start = spec->aligned_size ? spec->aligned_start : bp->address;
      uint64_t size = spec->aligned_size ? spec->aligned_size : (uint64_t)bp->size;
      uint64_t end = start + size;
      if (addr >= start && addr < end)
      {
        found = bp;
        break;
      }
    }
    if (found)
      break;
  }

  pthread_mutex_unlock(&dbg->breakpoint_mutex);
  return found;
}

static DebuggerBreakpoint *find_watchpoint_by_hw_index_locked(DebuggerData *dbg, thread_t thread, int hw_index, int *out_slot)
{
  DebuggerBreakpoint *found = NULL;
  for (DebuggerBreakpoint *bp = dbg->breakpoints; bp; bp = bp->next)
  {
    if (bp->bptype == 0 || bp->hw_count <= 0)
      continue;
    if (bp->tid != -1 && bp->tid != thread)
      continue;
    for (int i = 0; i < bp->hw_count; i++)
    {
      if (bp->hw_index[i] == hw_index)
      {
        found = bp;
        if (out_slot)
          *out_slot = i;
        break;
      }
    }
    if (found)
      break;
  }
  return found;
}

static DebuggerBreakpoint *find_watchpoint_by_hw_index(DebuggerData *dbg, thread_t thread, int hw_index, int *out_slot)
{
  DebuggerBreakpoint *found = NULL;
  pthread_mutex_lock(&dbg->breakpoint_mutex);
  found = find_watchpoint_by_hw_index_locked(dbg, thread, hw_index, out_slot);
  pthread_mutex_unlock(&dbg->breakpoint_mutex);
  return found;
}

static int find_breakpoint_base(DebuggerData *dbg, uint64_t addr, uint64_t *base)
{
  int found = 0;
  pthread_mutex_lock(&dbg->breakpoint_mutex);
  for (DebuggerBreakpoint *bp = dbg->breakpoints; bp; bp = bp->next)
  {
    if (bp->bptype != 0 || bp->size <= 0)
      continue;
    if (addr >= bp->address && (addr - bp->address) < (uint64_t)bp->size)
    {
      if (base)
        *base = bp->address;
      found = 1;
      break;
    }
  }
  pthread_mutex_unlock(&dbg->breakpoint_mutex);
  return found;
}

static int get_exception_esr_far(thread_t thread, uint64_t *esr, uint64_t *far)
{
#ifdef ARM_EXCEPTION_STATE64
  arm_exception_state64_t exc;
  mach_msg_type_number_t count = ARM_EXCEPTION_STATE64_COUNT;
  if (thread_get_state(thread, ARM_EXCEPTION_STATE64, (thread_state_t)&exc, &count) != KERN_SUCCESS)
    return 0;
  if (esr)
    *esr = (uint64_t)exc.__esr;
  if (far)
    *far = (uint64_t)exc.__far;
  return 1;
#else
  (void)thread;
  (void)esr;
  (void)far;
  return 0;
#endif
}

static int is_watchpoint_exception_esr(uint64_t esr)
{
  return ((esr >> 26) & 0x3fu) == 0x34u;
}

static int get_watchpoint_hw_index_from_esr(uint64_t esr, uint32_t *out_index)
{
  if (!is_watchpoint_exception_esr(esr))
    return 0;
  uint64_t iss = bits_u64(esr, 23, 0);
  uint32_t wpt = (uint32_t)bits_u64(iss, 23, 18);
  uint32_t wptv = (uint32_t)bit_u64(iss, 17);
  if (!wptv)
    return 0;
  if (out_index)
    *out_index = wpt;
  return 1;
}

static int get_watchpoint_hw_index_from_state(thread_t thread, uint64_t *addr, int *out_index)
{
  if (!addr)
    return 0;

  arm_debug_state64_t dbgstate;
  if (!get_debug_state(thread, &dbgstate, NULL))
    return 0;

  int count = (int)(sizeof(dbgstate.__wcr) / sizeof(dbgstate.__wcr[0]));
  for (int i = 0; i < count; i++)
  {
    uint64_t wcr = dbgstate.__wcr[i];
    if ((wcr & WCR_ENABLE) == 0)
      continue;

    uint64_t wvr = dbgstate.__wvr[i];
    uint32_t mask = (uint32_t)bits_u64(wcr, 28, 24);
    if (mask == 0)
    {
      if (bits_u64(wvr, 48, 3) != bits_u64(*addr, 48, 3))
        continue;

      uint32_t bas = (uint32_t)bits_u64(wcr, 12, 5);
      int lsb = lowest_bit_set_u32(bas);
      if (lsb < 0)
        continue;

      uint32_t byte = (uint32_t)bits_u64(*addr, 2, 0);
      if (bas & (1u << byte))
      {
        *addr = wvr + (uint64_t)lsb;
        if (out_index)
          *out_index = i;
        return 1;
      }
    }
    else
    {
      if (bits_u64(wvr, 48, mask) == bits_u64(*addr, 48, mask))
      {
        if (out_index)
          *out_index = i;
        return 1;
      }
    }
  }

  return 0;
}

static void apply_breakpoints_to_thread(DebuggerData *dbg, thread_t thread)
{
  typedef struct BreakpointApplyItem
  {
    uint64_t address;
    int debugreg;
    int size;
    int bptype;
    int hw_count;
    int hw_index[2];
    WatchpointSpec wp[2];
  } BreakpointApplyItem;

  BreakpointApplyItem *items = NULL;
  size_t count = 0;

  pthread_mutex_lock(&dbg->breakpoint_mutex);
  for (DebuggerBreakpoint *bp = dbg->breakpoints; bp; bp = bp->next)
  {
    if (bp->tid != -1 && bp->tid != thread)
      continue;
    count++;
  }

  if (count > 0)
  {
    items = (BreakpointApplyItem *)calloc(count, sizeof(BreakpointApplyItem));
    if (!items)
    {
      pthread_mutex_unlock(&dbg->breakpoint_mutex);
      return;
    }

    size_t idx = 0;
    for (DebuggerBreakpoint *bp = dbg->breakpoints; bp; bp = bp->next)
    {
      if (bp->tid != -1 && bp->tid != thread)
        continue;
      items[idx].address = bp->address;
      items[idx].debugreg = bp->debugreg;
      items[idx].size = bp->size;
      items[idx].bptype = bp->bptype;
      items[idx].hw_count = bp->hw_count;
      items[idx].hw_index[0] = bp->hw_index[0];
      items[idx].hw_index[1] = bp->hw_index[1];
      items[idx].wp[0] = bp->wp[0];
      items[idx].wp[1] = bp->wp[1];
      idx++;
    }
  }
  pthread_mutex_unlock(&dbg->breakpoint_mutex);

  if (!items)
    return;

  kern_return_t err = KERN_SUCCESS;
  int suspended = 0;
  if (!suspend_thread_for_debug(dbg, thread, &suspended, &err))
  {
    prune_thread_if_invalid(dbg, thread, err);
    free(items);
    return;
  }

  for (size_t i = 0; i < count; i++)
  {
    if (items[i].bptype == 0)
    {
      if (!apply_breakpoint_state(thread, items[i].debugreg, items[i].address, items[i].size, 1, &err))
      {
        prune_thread_if_invalid(dbg, thread, err);
        break;
      }
    }
    else
    {
      DebuggerBreakpoint temp_wp;
      memset(&temp_wp, 0, sizeof(temp_wp));
      temp_wp.bptype = items[i].bptype;
      temp_wp.hw_count = items[i].hw_count;
      temp_wp.hw_index[0] = items[i].hw_index[0];
      temp_wp.hw_index[1] = items[i].hw_index[1];
      temp_wp.wp[0] = items[i].wp[0];
      temp_wp.wp[1] = items[i].wp[1];
      if (!enable_watchpoint_on_thread(dbg, thread, &temp_wp, &err))
      {
        prune_thread_if_invalid(dbg, thread, err);
        break;
      }
    }
  }

  resume_thread_for_debug(dbg, thread, suspended);
  free(items);
}

static void announce_new_thread(DebuggerData *dbg, thread_t thread)
{
  apply_breakpoints_to_thread(dbg, thread);
  DebugEvent create_thread;
  memset(&create_thread, 0, sizeof(create_thread));
  create_thread.debugevent = -1;
  create_thread.threadid = (int64_t)thread;
  queue_event(dbg, &create_thread);
}

static void refresh_thread_list(DebuggerData *dbg, task_t task)
{
  thread_act_array_t threads = NULL;
  mach_msg_type_number_t thread_count = 0;
  if (task_threads(task, &threads, &thread_count) != KERN_SUCCESS)
    return;

  if (!threads || thread_count == 0)
  {
    if (threads)
      mach_vm_deallocate(mach_task_self(), (mach_vm_address_t)threads, thread_count * sizeof(thread_t));
    if (dbg->threads)
    {
      for (mach_msg_type_number_t i = 0; i < dbg->thread_count; i++)
        mach_port_deallocate(mach_task_self(), dbg->threads[i]);
      free(dbg->threads);
      dbg->threads = NULL;
      dbg->thread_count = 0;
    }
    return;
  }

  thread_t *newlist = (thread_t *)malloc(sizeof(thread_t) * thread_count);
  if (!newlist)
  {
    for (mach_msg_type_number_t i = 0; i < thread_count; i++)
      mach_port_deallocate(mach_task_self(), threads[i]);
    mach_vm_deallocate(mach_task_self(), (mach_vm_address_t)threads, thread_count * sizeof(thread_t));
    return;
  }

  mach_msg_type_number_t newcount = 0;
  for (mach_msg_type_number_t i = 0; i < thread_count; i++)
  {
    thread_t thread = threads[i];
    int exists = 0;
    for (mach_msg_type_number_t j = 0; j < dbg->thread_count; j++)
    {
      if (dbg->threads && dbg->threads[j] == thread)
      {
        exists = 1;
        break;
      }
    }

    newlist[newcount++] = thread;
    if (exists)
    {
      mach_port_deallocate(mach_task_self(), thread);
    }
    else
    {
      announce_new_thread(dbg, thread);
    }
  }

  if (dbg->threads)
  {
    for (mach_msg_type_number_t i = 0; i < dbg->thread_count; i++)
    {
      thread_t old = dbg->threads[i];
      int still_present = 0;
      for (mach_msg_type_number_t j = 0; j < newcount; j++)
      {
        if (newlist[j] == old)
        {
          still_present = 1;
          break;
        }
      }
      if (!still_present)
        mach_port_deallocate(mach_task_self(), old);
    }
    free(dbg->threads);
  }

  dbg->threads = newlist;
  dbg->thread_count = newcount;

  if (threads)
    mach_vm_deallocate(mach_task_self(), (mach_vm_address_t)threads, thread_count * sizeof(thread_t));
}

int StartDebug(HANDLE hProcess)
{
  if (GetHandleType(hProcess) != htProcesHandle)
    return FALSE;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);
  if (!p)
    return FALSE;

  pthread_mutex_lock(&g_debugger_lock);
  if (g_debugger_process && g_debugger_process != p)
  {
    pthread_mutex_unlock(&g_debugger_lock);
    debug_log("StartDebug: only one debugged process supported\n");
    return FALSE;
  }
  pthread_mutex_unlock(&g_debugger_lock);

  DebuggerData *dbg = (DebuggerData *)calloc(1, sizeof(DebuggerData));
  if (!dbg)
    return FALSE;

  pthread_mutex_init(&dbg->queue_mutex, NULL);
  pthread_cond_init(&dbg->queue_cond, NULL);
  pthread_mutex_init(&dbg->breakpoint_mutex, NULL);
  dbg->exception_mask = EXC_MASK_BREAKPOINT | EXC_MASK_BAD_ACCESS | EXC_MASK_BAD_INSTRUCTION | EXC_MASK_ARITHMETIC;
  dbg->task = p->task;

  dbg->saved_count = EXC_TYPES_COUNT;
  kern_return_t kr = task_get_exception_ports(p->task, dbg->exception_mask, dbg->saved_masks, &dbg->saved_count,
                                              dbg->saved_ports, dbg->saved_behaviors, dbg->saved_flavors);
  if (kr != KERN_SUCCESS)
    debug_log("task_get_exception_ports failed: %d\n", kr);

  kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &dbg->exception_port);
  if (kr != KERN_SUCCESS)
  {
    debug_log("mach_port_allocate failed: %d\n", kr);
    free(dbg);
    return FALSE;
  }

  kr = mach_port_insert_right(mach_task_self(), dbg->exception_port, dbg->exception_port, MACH_MSG_TYPE_MAKE_SEND);
  if (kr != KERN_SUCCESS)
  {
    debug_log("mach_port_insert_right failed: %d\n", kr);
    mach_port_deallocate(mach_task_self(), dbg->exception_port);
    free(dbg);
    return FALSE;
  }

  kr = task_set_exception_ports(p->task, dbg->exception_mask, dbg->exception_port,
                                EXCEPTION_DEFAULT, THREAD_STATE_NONE);
  if (kr != KERN_SUCCESS)
  {
    debug_log("task_set_exception_ports failed: %d\n", kr);
    mach_port_deallocate(mach_task_self(), dbg->exception_port);
    free(dbg);
    return FALSE;
  }

  dbg->exception_thread_running = 1;
  p->debuggerData = dbg;

  pthread_mutex_lock(&g_debugger_lock);
  g_debugger_process = p;
  pthread_mutex_unlock(&g_debugger_lock);

  if (pthread_create(&dbg->exception_thread, NULL, exception_thread_main, p) != 0)
  {
    debug_log("Failed to create exception thread\n");
    StopDebug(hProcess);
    return FALSE;
  }
  dbg->exception_thread_started = 1;

  DebugEvent create_process;
  memset(&create_process, 0, sizeof(create_process));
  create_process.debugevent = -2;
  create_process.threadid = p->pid;
  create_process.maxBreakpointCount = get_breakpoint_count();
  create_process.maxWatchpointCount = get_watchpoint_count();
  create_process.maxSharedBreakpoints = 0;
  queue_event(dbg, &create_process);

  mach_msg_type_number_t thread_count = 0;
  thread_act_array_t threads = NULL;
  kr = task_threads(p->task, &threads, &thread_count);
  if (kr == KERN_SUCCESS && thread_count > 0)
  {
    dbg->threads = (thread_t *)malloc(sizeof(thread_t) * thread_count);
    if (dbg->threads)
    {
      dbg->thread_count = thread_count;
      for (mach_msg_type_number_t i = 0; i < thread_count; i++)
      {
        dbg->threads[i] = threads[i];
        DebugEvent create_thread;
        memset(&create_thread, 0, sizeof(create_thread));
        create_thread.debugevent = -1;
        create_thread.threadid = (int64_t)threads[i];
        queue_event(dbg, &create_thread);
      }
    }
    else
    {
      for (mach_msg_type_number_t i = 0; i < thread_count; i++)
        mach_port_deallocate(mach_task_self(), threads[i]);
    }
    mach_vm_deallocate(mach_task_self(), (mach_vm_address_t)threads, thread_count * sizeof(thread_t));
  }

  debug_log("StartDebug(%d) ok\n", hProcess);
  return TRUE;
}

int StopDebug(HANDLE hProcess)
{
  if (GetHandleType(hProcess) != htProcesHandle)
    return FALSE;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);
  if (!p || !p->debuggerData)
    return FALSE;

  DebuggerData *dbg = (DebuggerData *)p->debuggerData;
  dbg->exception_thread_running = 0;

  if (dbg->exception_port != MACH_PORT_NULL)
    mach_port_destroy(mach_task_self(), dbg->exception_port);

  if (dbg->exception_thread_started)
    pthread_join(dbg->exception_thread, NULL);

  if (dbg->exception_thread_port != MACH_PORT_NULL)
  {
    mach_port_deallocate(mach_task_self(), dbg->exception_thread_port);
    dbg->exception_thread_port = MACH_PORT_NULL;
  }

  if (dbg->saved_count > 0)
  {
    for (mach_msg_type_number_t i = 0; i < dbg->saved_count; i++)
    {
      task_set_exception_ports(p->task, dbg->saved_masks[i], dbg->saved_ports[i],
                               dbg->saved_behaviors[i], dbg->saved_flavors[i]);
    }
  }

  pthread_mutex_lock(&g_debugger_lock);
  if (g_debugger_process == p)
    g_debugger_process = NULL;
  pthread_mutex_unlock(&g_debugger_lock);

  if (dbg->threads)
  {
    for (mach_msg_type_number_t i = 0; i < dbg->thread_count; i++)
      mach_port_deallocate(mach_task_self(), dbg->threads[i]);
    free(dbg->threads);
  }

  while (dbg->pending_head)
  {
    reply_pending_exception(dbg, dbg->pending_head->thread, KERN_SUCCESS);
  }

  DebugEventQueueElement *elem = dbg->queue_head;
  while (elem)
  {
    DebugEventQueueElement *next = elem->next;
    free(elem);
    elem = next;
  }

  DebuggerBreakpoint *bp = dbg->breakpoints;
  while (bp)
  {
    DebuggerBreakpoint *next = bp->next;
    free(bp);
    bp = next;
  }

  pthread_mutex_destroy(&dbg->queue_mutex);
  pthread_cond_destroy(&dbg->queue_cond);
  pthread_mutex_destroy(&dbg->breakpoint_mutex);
  free(dbg);
  p->debuggerData = NULL;

  debug_log("StopDebug(%d) ok\n", hProcess);
  return TRUE;
}

int WaitForDebugEvent(HANDLE hProcess, PDebugEvent devent, int timeout)
{
  if (GetHandleType(hProcess) != htProcesHandle)
    return FALSE;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);
  if (!p || !p->debuggerData)
    return FALSE;

  DebuggerData *dbg = (DebuggerData *)p->debuggerData;
  if (!devent)
    return FALSE;

  refresh_thread_list(dbg, p->task);
  int ok = wait_for_event(dbg, devent, timeout);
  return ok;
}

int ContinueFromDebugEvent(HANDLE hProcess, int tid, int ignoresignal)
{
  if (GetHandleType(hProcess) != htProcesHandle)
    return FALSE;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);
  if (!p || !p->debuggerData)
    return FALSE;

  thread_t thread = (thread_t)tid;
  if (thread == MACH_PORT_NULL)
    return FALSE;

  DebuggerData *dbg = (DebuggerData *)p->debuggerData;
  if (ignoresignal == 2)
  {
    if (set_single_step(thread, 1))
      dbg->single_step_thread = thread;
  }

  {
    reply_all_pending_for_thread(dbg, thread, KERN_SUCCESS);
  }

  return TRUE;
}

int GetDebugPort(HANDLE hProcess)
{
  (void)hProcess;
  return -1;
}

int SetBreakpoint(HANDLE hProcess, int tid, int debugreg, void *address, int bptype, int bpsize)
{
  if (GetHandleType(hProcess) != htProcesHandle)
    return FALSE;

  if (bptype < 0 || bptype > 3)
    return FALSE;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);
  if (!p || !p->debuggerData)
    return FALSE;

  DebuggerData *dbg = (DebuggerData *)p->debuggerData;
  uint64_t addr = (uint64_t)(uintptr_t)address;
  int size = 4;
  if (bptype == 0)
  {
    if (bpsize == 1)
      size = 1;
    else if (bpsize == 2)
      size = 2;
  }
  else
  {
    size = bpsize > 0 ? bpsize : 1;
  }

  WatchpointSpec wp_specs[2];
  int wp_spec_count = 0;
  int wp_hw_index[2] = {-1, -1};
  if (bptype != 0)
  {
    wp_spec_count = align_requested_watchpoint(addr, (uint64_t)size, wp_specs, 2);
    if (wp_spec_count == 0)
      return FALSE;
  }

  pthread_mutex_lock(&dbg->breakpoint_mutex);
  DebuggerBreakpoint *bp = dbg->breakpoints;
  while (bp)
  {
    if (bp->address == addr && bp->debugreg == debugreg && bp->tid == (thread_t)tid &&
        bp->bptype == bptype && bp->size == size)
    {
      DebuggerBreakpoint existing;
      int have_existing = 0;
      if (bptype != 0)
      {
        existing = *bp;
        have_existing = 1;
      }
      pthread_mutex_unlock(&dbg->breakpoint_mutex);
      if (!have_existing)
        return TRUE;

      {
        int re_ok = 0;
        if (tid != -1)
        {
          kern_return_t err = KERN_SUCCESS;
          int suspended = 0;
          if (!suspend_thread_for_debug(dbg, (thread_t)tid, &suspended, &err))
          {
            prune_thread_if_invalid(dbg, (thread_t)tid, err);
            return FALSE;
          }
          if (enable_watchpoint_on_thread(dbg, (thread_t)tid, &existing, &err))
            re_ok = 1;
          else
            prune_thread_if_invalid(dbg, (thread_t)tid, err);
          resume_thread_for_debug(dbg, (thread_t)tid, suspended);
        }
        else if (dbg->threads && dbg->thread_count > 0)
        {
          re_ok = apply_watchpoint_state_transaction(dbg, dbg->threads, dbg->thread_count,
                                                     existing.wp, existing.hw_index, existing.hw_count, existing.bptype, 1);
          if (!re_ok)
            re_ok = apply_watchpoint_state_best_effort(dbg, existing.wp, existing.hw_index, existing.hw_count, existing.bptype, 1);
        }
        return re_ok ? TRUE : FALSE;
      }
    }
    bp = bp->next;
  }

  if (bptype != 0)
  {
    if (!allocate_watchpoint_hw_indices_locked(dbg, wp_spec_count, wp_hw_index))
    {
      pthread_mutex_unlock(&dbg->breakpoint_mutex);
      return FALSE;
    }
  }

  pthread_mutex_unlock(&dbg->breakpoint_mutex);

  DebuggerBreakpoint temp_wp;
  if (bptype != 0)
  {
    memset(&temp_wp, 0, sizeof(temp_wp));
    temp_wp.bptype = bptype;
    temp_wp.hw_count = wp_spec_count;
    temp_wp.hw_index[0] = wp_hw_index[0];
    temp_wp.hw_index[1] = wp_hw_index[1];
    if (wp_spec_count > 0)
    {
      temp_wp.wp[0] = wp_specs[0];
      temp_wp.wp[1] = wp_spec_count > 1 ? wp_specs[1] : wp_specs[0];
    }
  }

  int ok = 0;
  if (tid != -1)
  {
    kern_return_t err = KERN_SUCCESS;
    int suspended = 0;
    if (!suspend_thread_for_debug(dbg, (thread_t)tid, &suspended, &err))
    {
      prune_thread_if_invalid(dbg, (thread_t)tid, err);
      return FALSE;
    }
    if ((bptype == 0)
          ? apply_breakpoint_state((thread_t)tid, debugreg, addr, size, 1, &err)
          : enable_watchpoint_on_thread(dbg, (thread_t)tid, &temp_wp, &err))
    {
      ok = 1;
    }
    else
    {
      prune_thread_if_invalid(dbg, (thread_t)tid, err);
    }
    resume_thread_for_debug(dbg, (thread_t)tid, suspended);
  }
  else if (dbg->threads && dbg->thread_count > 0)
  {
    if (bptype == 0)
    {
      ok = apply_breakpoint_state_transaction(dbg, dbg->threads, dbg->thread_count, debugreg, addr, size, 1);
      if (!ok)
        ok = apply_breakpoint_state_best_effort(dbg, debugreg, addr, size, 1);
    }
    else
    {
      ok = apply_watchpoint_state_transaction(dbg, dbg->threads, dbg->thread_count,
                                              temp_wp.wp, temp_wp.hw_index, temp_wp.hw_count, bptype, 1);
      if (!ok)
        ok = apply_watchpoint_state_best_effort(dbg, temp_wp.wp, temp_wp.hw_index, temp_wp.hw_count, bptype, 1);
    }
  }
  if (!ok)
    return FALSE;

  DebuggerBreakpoint *nb = (DebuggerBreakpoint *)malloc(sizeof(DebuggerBreakpoint));
  if (!nb)
    return FALSE;
  nb->address = addr;
  nb->debugreg = debugreg;
  nb->size = size;
  nb->bptype = bptype;
  nb->tid = (thread_t)tid;
  nb->hw_count = wp_spec_count;
  nb->hw_index[0] = wp_hw_index[0];
  nb->hw_index[1] = wp_hw_index[1];
  if (wp_spec_count > 0)
  {
    nb->wp[0] = wp_specs[0];
    nb->wp[1] = wp_spec_count > 1 ? wp_specs[1] : wp_specs[0];
  }
  pthread_mutex_lock(&dbg->breakpoint_mutex);
  nb->next = dbg->breakpoints;
  dbg->breakpoints = nb;
  pthread_mutex_unlock(&dbg->breakpoint_mutex);

  return TRUE;
}

int RemoveBreakpoint(HANDLE hProcess, int tid, int debugreg, int wasWatchpoint)
{
  if (GetHandleType(hProcess) != htProcesHandle)
    return FALSE;

  PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);
  if (!p || !p->debuggerData)
    return FALSE;

  DebuggerData *dbg = (DebuggerData *)p->debuggerData;

  int ok = 0;

  if (!wasWatchpoint)
  {
    if (tid != -1)
    {
      kern_return_t err = KERN_SUCCESS;
      int suspended = 0;
      if (!suspend_thread_for_debug(dbg, (thread_t)tid, &suspended, &err))
      {
        prune_thread_if_invalid(dbg, (thread_t)tid, err);
        return FALSE;
      }
      if (apply_breakpoint_state((thread_t)tid, debugreg, 0, 0, 0, &err))
      {
        ok = 1;
      }
      else
      {
        prune_thread_if_invalid(dbg, (thread_t)tid, err);
      }
      resume_thread_for_debug(dbg, (thread_t)tid, suspended);
    }
    else if (dbg->threads && dbg->thread_count > 0)
    {
      ok = apply_breakpoint_state_transaction(dbg, dbg->threads, dbg->thread_count, debugreg, 0, 0, 0);
      if (!ok)
        ok = apply_breakpoint_state_best_effort(dbg, debugreg, 0, 0, 0);
    }

    pthread_mutex_lock(&dbg->breakpoint_mutex);
    DebuggerBreakpoint **cur = &dbg->breakpoints;
    while (*cur)
    {
      if ((*cur)->debugreg == debugreg &&
          ((*cur)->tid == (thread_t)tid || tid == -1) &&
          (*cur)->bptype == 0)
      {
        DebuggerBreakpoint *dead = *cur;
        *cur = dead->next;
        free(dead);
        if (tid != -1)
          break;
        continue;
      }
      cur = &(*cur)->next;
    }
    pthread_mutex_unlock(&dbg->breakpoint_mutex);
    return ok ? TRUE : FALSE;
  }

  typedef struct WatchpointRemoveItem
  {
    DebuggerBreakpoint bp;
    int disable_ok;
    struct WatchpointRemoveItem *next;
  } WatchpointRemoveItem;

  WatchpointRemoveItem *targets = NULL;
  WatchpointRemoveItem *tmp = NULL;

  pthread_mutex_lock(&dbg->breakpoint_mutex);
  DebuggerBreakpoint *entry = dbg->breakpoints;
  while (entry)
  {
    if (entry->debugreg == debugreg &&
        (tid == -1 || entry->tid == (thread_t)tid || entry->tid == (thread_t)-1) &&
        entry->bptype != 0)
    {
      WatchpointRemoveItem *copy = (WatchpointRemoveItem *)calloc(1, sizeof(WatchpointRemoveItem));
      if (copy)
      {
        copy->bp = *entry;
        copy->disable_ok = 0;
        copy->next = targets;
        targets = copy;
      }
      if (tid != -1)
        break;
    }
    entry = entry->next;
  }
  pthread_mutex_unlock(&dbg->breakpoint_mutex);

  if (tid != -1)
  {
    tmp = targets;
    while (tmp)
    {
      kern_return_t err = KERN_SUCCESS;
      int suspended = 0;
      if (!suspend_thread_for_debug(dbg, (thread_t)tid, &suspended, &err))
      {
        prune_thread_if_invalid(dbg, (thread_t)tid, err);
      }
      else
      {
        if (disable_watchpoint_on_thread((thread_t)tid, &tmp->bp, &err))
          ok = 1;
        else
          prune_thread_if_invalid(dbg, (thread_t)tid, err);
        resume_thread_for_debug(dbg, (thread_t)tid, suspended);
      }
      tmp = tmp->next;
    }

    while (targets)
    {
      tmp = targets;
      targets = targets->next;
      free(tmp);
    }
    return ok ? TRUE : FALSE;
  }

  tmp = targets;
  while (tmp)
  {
    if (dbg->threads && dbg->thread_count > 0)
    {
      if (apply_watchpoint_state_transaction(dbg, dbg->threads, dbg->thread_count,
                                             tmp->bp.wp, tmp->bp.hw_index, tmp->bp.hw_count, tmp->bp.bptype, 0))
      {
        ok = 1;
        tmp->disable_ok = 1;
      }
      else if (apply_watchpoint_state_best_effort(dbg, tmp->bp.wp, tmp->bp.hw_index, tmp->bp.hw_count, tmp->bp.bptype, 0))
      {
        ok = 1;
        tmp->disable_ok = 1;
      }
    }
    tmp = tmp->next;
  }

  pthread_mutex_lock(&dbg->breakpoint_mutex);
  while (targets)
  {
    WatchpointRemoveItem *copy = targets;
    targets = targets->next;

    if (copy->disable_ok)
    {
      DebuggerBreakpoint **cur = &dbg->breakpoints;
      while (*cur)
      {
        DebuggerBreakpoint *bp = *cur;
        if (bp->debugreg == copy->bp.debugreg &&
            bp->address == copy->bp.address &&
            bp->size == copy->bp.size &&
            ((bp->tid == (thread_t)tid) || tid == -1) &&
            bp->bptype != 0)
        {
          *cur = bp->next;
          free(bp);
          if (tid != -1)
            break;
          continue;
        }
        cur = &(*cur)->next;
      }
    }

    free(copy);
  }
  pthread_mutex_unlock(&dbg->breakpoint_mutex);

  return ok ? TRUE : FALSE;
}

int SuspendThread(HANDLE hProcess, int tid)
{
  (void)hProcess;
  thread_t thread = (thread_t)tid;
  if (thread == MACH_PORT_NULL)
    return FALSE;
  return thread_suspend(thread) == KERN_SUCCESS;
}

int ResumeThread(HANDLE hProcess, int tid)
{
  (void)hProcess;
  thread_t thread = (thread_t)tid;
  if (thread == MACH_PORT_NULL)
    return FALSE;
  return thread_resume(thread) == KERN_SUCCESS;
}

BOOL GetThreadContext(HANDLE hProcess, int tid, PCONTEXT Context)
{
  if (GetHandleType(hProcess) != htProcesHandle || !Context)
    return FALSE;

  thread_t thread = (thread_t)tid;
  if (thread == MACH_PORT_NULL)
    return FALSE;

  fill_context_from_thread(thread, Context);
  return TRUE;
}

BOOL SetThreadContext(HANDLE hProcess, int tid, PCONTEXT Context)
{
  if (GetHandleType(hProcess) != htProcesHandle || !Context)
    return FALSE;

  thread_t thread = (thread_t)tid;
  if (thread == MACH_PORT_NULL)
    return FALSE;

  arm_thread_state64_t gpr;
  mach_msg_type_number_t gpr_count = ARM_THREAD_STATE64_COUNT;
  if (thread_get_state(thread, ARM_THREAD_STATE64, (thread_state_t)&gpr, &gpr_count) != KERN_SUCCESS)
    return FALSE;

  for (int i = 0; i < 29; i++)
    gpr.__x[i] = Context->regs.regs[i];
  gpr.__fp = Context->regs.regs[29];
  gpr.__lr = Context->regs.regs[30];
  gpr.__sp = Context->regs.sp;
  gpr.__pc = Context->regs.pc;
  gpr.__cpsr = (uint32_t)Context->regs.pstate;

  if (thread_set_state(thread, ARM_THREAD_STATE64, (thread_state_t)&gpr, ARM_THREAD_STATE64_COUNT) != KERN_SUCCESS)
    return FALSE;

  arm_neon_state64_t neon;
  mach_msg_type_number_t neon_count = ARM_NEON_STATE64_COUNT;
  if (thread_get_state(thread, ARM_NEON_STATE64, (thread_state_t)&neon, &neon_count) != KERN_SUCCESS)
    return FALSE;

  memcpy(neon.__v, Context->fp.vregs, sizeof(neon.__v));
  neon.__fpsr = Context->fp.fpsr;
  neon.__fpcr = Context->fp.fpcr;

  if (thread_set_state(thread, ARM_NEON_STATE64, (thread_state_t)&neon, ARM_NEON_STATE64_COUNT) != KERN_SUCCESS)
    return FALSE;

  return TRUE;
}

int WakeDebuggerThread(void)
{
  return 0;
}

```

`ceserver-ios/jailed/debugger.h`:

```h
#ifndef DEBUGGER_H_
#define DEBUGGER_H_

#include <stdint.h>

#include "context.h"
#include "porthelp.h"

#pragma pack(push, 1)
typedef struct
{
  int debugevent;
  int64_t threadid;
  union
  {
    uint64_t address;
    struct
    {
      uint8_t maxBreakpointCount;
      uint8_t maxWatchpointCount;
      uint8_t maxSharedBreakpoints;
    };
  };
} DebugEvent, *PDebugEvent;
#pragma pack(pop)

int StartDebug(HANDLE hProcess);
int StopDebug(HANDLE hProcess);
int WaitForDebugEvent(HANDLE hProcess, PDebugEvent devent, int timeout);
int ContinueFromDebugEvent(HANDLE hProcess, int tid, int ignoresignal);
int GetDebugPort(HANDLE hProcess);

int SetBreakpoint(HANDLE hProcess, int tid, int debugreg, void *address, int bptype, int bpsize);
int RemoveBreakpoint(HANDLE hProcess, int tid, int debugreg, int wasWatchpoint);

int SuspendThread(HANDLE hProcess, int tid);
int ResumeThread(HANDLE hProcess, int tid);

BOOL GetThreadContext(HANDLE hProcess, int tid, PCONTEXT Context);
BOOL SetThreadContext(HANDLE hProcess, int tid, PCONTEXT Context);

int WakeDebuggerThread(void);

#endif
```

`ceserver-ios/jailed/entitlements.plist`:

```plist
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>platform-application</key>
    <true/>
    <key>com.apple.private.security.container-required</key>
    <false/>
    <key>task_for_pid-allow</key>
    <true/>
    <key>com.apple.system-task-ports</key>
    <true/>
</dict>
</plist>

```

`ceserver-ios/jailed/porthelp.c`:

```c
/*
 * porthelp.c
 *
 *  Created on: Jul 21, 2011
 *      Author: erich
 * Description: Implements some tools that might come in handy when writing a port
 */

#include <stddef.h>
#include <string.h>
#include <stdlib.h>
#include "porthelp.h"
#include "api.h"

typedef struct
{
  handleType type;
  void *pointer;
  int Handle;

} HandleListEntry, *PHandleListEntry;

volatile HandleListEntry *HandleList;
int HandleList_max;

int CreateHandleFromPointer(void *p, handleType type)
{
  if (HandleList==NULL)
  {

    HandleList_max=256;
    HandleList=(PHandleListEntry)malloc(256*sizeof(HandleListEntry));

    memset((void *)HandleList, 0, sizeof(HandleListEntry)*256);
  }


  int i;
  for (i=1; i<HandleList_max; i++)
  {
    if (HandleList[i].type==htEmpty)
    {
      HandleList[i].pointer=p;
      HandleList[i].type=type;
      return i;
    }
  }



  debug_log("Reached max amount of handles (%d). Leaking some memory to make a larger list (hope for the best, and fix this handle leak that is going on)\n",HandleList_max);
  HandleListEntry *NewHandleList=malloc(HandleList_max * 2 * sizeof(HandleListEntry));
  memset((void *)NewHandleList, 0, HandleList_max * 2 * sizeof(HandleListEntry));
  memcpy(NewHandleList, (const void *)HandleList, HandleList_max * sizeof(HandleListEntry));

  HandleList=NewHandleList;
  i=HandleList_max;
  HandleList_max=HandleList_max * 2;

  HandleList[i].pointer=p;
  HandleList[i].type=type;
  return i;
}


void *GetPointerFromHandle(int handle)
{
  if ((handle>0) && (handle<HandleList_max) && (HandleList[handle].type != htEmpty))
    return HandleList[handle].pointer;
  else
    return NULL;
}

handleType GetHandleType(int handle)
{
  if ((handle>0) && (handle<HandleList_max))
    return HandleList[handle].type;
  else
    return htEmpty;
}

void RemoveHandle(int handle)
{
  if ((handle>0) && (handle<HandleList_max) && (HandleList[handle].type != htEmpty))
    HandleList[handle].type=htEmpty;
}

int SearchHandleList(int type, HANDLESEARCHCALLBACK cb, void *searchdata)
/*
 * go through the handle list and call cb(data, searchdata) for each handle of the specified type
 * if cb(data,searchdata) returns true then return that handle, else return 0
 */
{
  int i;

  for (i=1; i<HandleList_max; i++)
  {
    if (HandleList[i].type==type)
    {
      if (cb(HandleList[i].pointer, searchdata))
        return i;
    }
  }

  return 0;
}

```

`ceserver-ios/jailed/porthelp.h`:

```h
/*
 * porthelp.h
 *
 *  Created on: Jul 21, 2011
 *      Author: erich
 */

#ifndef PORTHELP_H_
#define PORTHELP_H_

#include <stdint.h>

typedef uint32_t HANDLE;
typedef uint32_t DWORD;

#define TH32CS_SNAPPROCESS  0x2
#define TH32CS_SNAPTHREAD   0x4
#define TH32CS_SNAPMODULE   0x8
#define TH32CS_SNAPFIRSTMODULE 0x40000000

#define PAGE_NOACCESS 1
#define PAGE_READONLY 2
#define PAGE_READWRITE 4
#define PAGE_WRITECOPY 8
#define PAGE_EXECUTE 16
#define PAGE_EXECUTE_READ 32
#define PAGE_EXECUTE_READWRITE 64

#define MEM_MAPPED 262144
#define MEM_PRIVATE 131072

typedef enum {htEmpty=0, htProcesHandle, htThreadHandle, htPipeHandle, htTHSProcess, htTHSModule, htTHSThread, htNativeThreadHandle} handleType;
typedef int BOOL;

typedef int (*HANDLESEARCHCALLBACK) (void *data, void *searchdata);

#define TRUE 1
#define FALSE 0


int CreateHandleFromPointer(void *p, handleType type);
void *GetPointerFromHandle(int handle);
handleType GetHandleType(int handle);
void RemoveHandle(int handle);
int SearchHandleList(int type, HANDLESEARCHCALLBACK cb, void *searchdata);

#endif /* PORTHELP_H_ */

```

`ceserver-ios/jailed/symbols.c`:

```c

#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <mach-o/fat.h>
#include <mach-o/loader.h>
#include <mach-o/nlist.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <zlib.h>

#include "api.h"
#include "symbols.h"

#ifndef n_strx
#define n_strx n_un.n_strx
#endif

#pragma pack(1)
typedef struct
{
  uint64_t address;
  int size;
  int type;
  unsigned char namelength;
  char name[0];
} symbolinfo, *psymbolinfo;
#pragma pack()

#ifndef EXPORT_SYMBOL_FLAGS_REEXPORT
#define EXPORT_SYMBOL_FLAGS_REEXPORT 0x08u
#endif
#ifndef EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER
#define EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER 0x10u
#endif
#ifndef INDIRECT_SYMBOL_ABS
#define INDIRECT_SYMBOL_ABS 0x40000000u
#endif
#ifndef INDIRECT_SYMBOL_LOCAL
#define INDIRECT_SYMBOL_LOCAL 0x80000000u
#endif
#ifndef CPU_TYPE_ARM64_32
#define CPU_TYPE_ARM64_32 ((cpu_type_t)0x0200000c)
#endif

#ifndef DW_EH_PE_omit
#define DW_EH_PE_omit 0xff
#endif
#ifndef DW_EH_PE_absptr
#define DW_EH_PE_absptr 0x00
#endif
#ifndef DW_EH_PE_uleb128
#define DW_EH_PE_uleb128 0x01
#endif
#ifndef DW_EH_PE_udata2
#define DW_EH_PE_udata2 0x02
#endif
#ifndef DW_EH_PE_udata4
#define DW_EH_PE_udata4 0x03
#endif
#ifndef DW_EH_PE_udata8
#define DW_EH_PE_udata8 0x04
#endif
#ifndef DW_EH_PE_sleb128
#define DW_EH_PE_sleb128 0x09
#endif
#ifndef DW_EH_PE_sdata2
#define DW_EH_PE_sdata2 0x0a
#endif
#ifndef DW_EH_PE_sdata4
#define DW_EH_PE_sdata4 0x0b
#endif
#ifndef DW_EH_PE_sdata8
#define DW_EH_PE_sdata8 0x0c
#endif
#ifndef DW_EH_PE_pcrel
#define DW_EH_PE_pcrel 0x10
#endif
#ifndef DW_EH_PE_textrel
#define DW_EH_PE_textrel 0x20
#endif
#ifndef DW_EH_PE_datarel
#define DW_EH_PE_datarel 0x30
#endif
#ifndef DW_EH_PE_funcrel
#define DW_EH_PE_funcrel 0x40
#endif
#ifndef DW_EH_PE_aligned
#define DW_EH_PE_aligned 0x50
#endif
#ifndef DW_EH_PE_indirect
#define DW_EH_PE_indirect 0x80
#endif

#define TEMPBUFSIZE (64 * 1024)

typedef struct
{
  uint64_t addr;
  uint64_t size;
  uint32_t flags;
  uint32_t reserved1;
  uint32_t reserved2;
  uint32_t fileoff;
  char segname[17];
  char sectname[17];
} MachSection;

typedef struct
{
  MachSection *items;
  size_t count;
  size_t cap;
} MachSectionList;

typedef struct
{
  uint64_t addr;
  uint32_t size;
  uint32_t type;
  char *name;
} SymbolEntry;

typedef struct
{
  SymbolEntry *items;
  size_t count;
  size_t cap;
} SymbolList;

typedef struct
{
  uint64_t *slots;
  size_t cap;
  size_t count;
} AddrSet;

typedef struct
{
  uint32_t ncmds;
  uint32_t sizeofcmds;
  uint32_t filetype;
  uint32_t flags;
  int is64;
  int swap;
  uint64_t base_vmaddr;
  uint64_t text_vmaddr;
  struct symtab_command symtab;
  struct dysymtab_command dysymtab;
  struct dyld_info_command dyld_info;
  struct linkedit_data_command exports_trie;
  struct linkedit_data_command function_starts;
  MachSectionList sections;
} MachOInfo;

static uint32_t swap32_if(uint32_t v, int swap)
{
  return swap ? __builtin_bswap32(v) : v;
}

static uint16_t swap16_if(uint16_t v, int swap)
{
  return swap ? __builtin_bswap16(v) : v;
}

static uint64_t swap64_if(uint64_t v, int swap)
{
  return swap ? __builtin_bswap64(v) : v;
}

static int read_at(int fd, uint64_t offset, void *buf, size_t size)
{
  ssize_t r = pread(fd, buf, size, (off_t)offset);
  return (r == (ssize_t)size);
}

static int section_list_append(MachSectionList *list, const MachSection *sec)
{
  if (!list || !sec)
    return 0;

  if (list->count >= list->cap)
  {
    size_t newcap = list->cap ? list->cap * 2 : 64;
    void *p = realloc(list->items, newcap * sizeof(MachSection));
    if (!p)
      return 0;
    list->items = (MachSection *)p;
    list->cap = newcap;
  }

  list->items[list->count++] = *sec;
  return 1;
}

static void section_list_free(MachSectionList *list)
{
  if (!list)
    return;
  free(list->items);
  list->items = NULL;
  list->count = 0;
  list->cap = 0;
}

static int symbol_list_append(SymbolList *list, uint64_t addr, uint32_t size, uint32_t type, const char *name)
{
  if (!list || !name || !name[0])
    return 0;

  if (list->count >= list->cap)
  {
    size_t newcap = list->cap ? list->cap * 2 : 1024;
    void *p = realloc(list->items, newcap * sizeof(SymbolEntry));
    if (!p)
      return 0;
    list->items = (SymbolEntry *)p;
    list->cap = newcap;
  }

  SymbolEntry *e = &list->items[list->count++];
  e->addr = addr;
  e->size = size;
  e->type = type;
  e->name = strdup(name);
  if (!e->name)
  {
    list->count--;
    return 0;
  }

  return 1;
}

static void symbol_list_free(SymbolList *list)
{
  if (!list)
    return;
  for (size_t i = 0; i < list->count; i++)
    free(list->items[i].name);
  free(list->items);
  list->items = NULL;
  list->count = 0;
  list->cap = 0;
}

static int addrset_init(AddrSet *set, size_t cap)
{
  if (!set)
    return 0;
  if (cap < 16)
    cap = 16;
  size_t p = 1;
  while (p < cap)
    p <<= 1;
  cap = p;
  set->slots = (uint64_t *)calloc(cap, sizeof(uint64_t));
  if (!set->slots)
    return 0;
  set->cap = cap;
  set->count = 0;
  return 1;
}

static void addrset_free(AddrSet *set)
{
  if (!set)
    return;
  free(set->slots);
  set->slots = NULL;
  set->cap = 0;
  set->count = 0;
}

static int addrset_grow(AddrSet *set)
{
  size_t newcap = set->cap ? set->cap * 2 : 64;
  uint64_t *newslots = (uint64_t *)calloc(newcap, sizeof(uint64_t));
  if (!newslots)
    return 0;

  for (size_t i = 0; i < set->cap; i++)
  {
    uint64_t v = set->slots[i];
    if (v == 0)
      continue;
    size_t mask = newcap - 1;
    size_t idx = (size_t)(v ^ (v >> 32)) & mask;
    while (newslots[idx] != 0)
      idx = (idx + 1) & mask;
    newslots[idx] = v;
  }

  free(set->slots);
  set->slots = newslots;
  set->cap = newcap;
  return 1;
}

static int addrset_contains(const AddrSet *set, uint64_t v)
{
  if (!set || !set->slots || v == 0)
    return 0;
  size_t mask = set->cap - 1;
  size_t idx = (size_t)(v ^ (v >> 32)) & mask;
  while (set->slots[idx] != 0)
  {
    if (set->slots[idx] == v)
      return 1;
    idx = (idx + 1) & mask;
  }
  return 0;
}

static int addrset_insert(AddrSet *set, uint64_t v)
{
  if (!set || !set->slots || v == 0)
    return 0;
  if ((set->count + 1) * 4 >= set->cap * 3)
  {
    if (!addrset_grow(set))
      return 0;
  }

  size_t mask = set->cap - 1;
  size_t idx = (size_t)(v ^ (v >> 32)) & mask;
  while (set->slots[idx] != 0)
  {
    if (set->slots[idx] == v)
      return 1;
    idx = (idx + 1) & mask;
  }
  set->slots[idx] = v;
  set->count++;
  return 1;
}

static int read_uleb(const unsigned char *data, size_t size, size_t *offset, uint64_t *value)
{
  uint64_t result = 0;
  uint32_t shift = 0;
  while (*offset < size)
  {
    uint8_t byte = data[(*offset)++];
    result |= ((uint64_t)(byte & 0x7f)) << shift;
    if ((byte & 0x80) == 0)
    {
      *value = result;
      return 1;
    }
    shift += 7;
    if (shift > 63)
      return 0;
  }
  return 0;
}

static int read_sleb(const unsigned char *data, size_t size, size_t *offset, int64_t *value)
{
  int64_t result = 0;
  uint32_t shift = 0;
  uint8_t byte = 0;
  while (*offset < size)
  {
    byte = data[(*offset)++];
    result |= ((int64_t)(byte & 0x7f)) << shift;
    shift += 7;
    if ((byte & 0x80) == 0)
      break;
    if (shift > 63)
      return 0;
  }

  if (shift < 64 && (byte & 0x40))
    result |= -((int64_t)1 << shift);

  *value = result;
  return 1;
}

static const char *read_cstr(const unsigned char *data, size_t size, size_t *offset)
{
  size_t start = *offset;
  while (*offset < size)
  {
    if (data[*offset] == 0)
    {
      const char *s = (const char *)&data[start];
      (*offset)++;
      return s;
    }
    (*offset)++;
  }
  return NULL;
}

static int read_encoded_value(const unsigned char *data, size_t size, size_t *offset, uint8_t encoding,
                              uint64_t pc, int swap, int is64, int apply_rel, uint64_t *out)
{
  if (encoding == DW_EH_PE_omit)
    return 0;

  uint8_t fmt = encoding & 0x0f;
  uint8_t rel = encoding & 0x70;
  uint8_t ind = encoding & 0x80;

  uint64_t uval = 0;
  int64_t sval = 0;

  switch (fmt)
  {
    case DW_EH_PE_absptr:
      if (is64)
      {
        if (*offset + 8 > size)
          return 0;
        uint64_t v = 0;
        memcpy(&v, data + *offset, 8);
        uval = swap64_if(v, swap);
        *offset += 8;
      }
      else
      {
        if (*offset + 4 > size)
          return 0;
        uint32_t v = 0;
        memcpy(&v, data + *offset, 4);
        uval = swap32_if(v, swap);
        *offset += 4;
      }
      break;
    case DW_EH_PE_uleb128:
      if (!read_uleb(data, size, offset, &uval))
        return 0;
      break;
    case DW_EH_PE_udata2:
      if (*offset + 2 > size)
        return 0;
      {
        uint16_t v = 0;
        memcpy(&v, data + *offset, 2);
        uval = swap16_if(v, swap);
        *offset += 2;
      }
      break;
    case DW_EH_PE_udata4:
      if (*offset + 4 > size)
        return 0;
      {
        uint32_t v = 0;
        memcpy(&v, data + *offset, 4);
        uval = swap32_if(v, swap);
        *offset += 4;
      }
      break;
    case DW_EH_PE_udata8:
      if (*offset + 8 > size)
        return 0;
      {
        uint64_t v = 0;
        memcpy(&v, data + *offset, 8);
        uval = swap64_if(v, swap);
        *offset += 8;
      }
      break;
    case DW_EH_PE_sleb128:
      if (!read_sleb(data, size, offset, &sval))
        return 0;
      uval = (uint64_t)sval;
      break;
    case DW_EH_PE_sdata2:
      if (*offset + 2 > size)
        return 0;
      {
        int16_t v = 0;
        memcpy(&v, data + *offset, 2);
        v = (int16_t)swap16_if((uint16_t)v, swap);
        sval = v;
        uval = (uint64_t)sval;
        *offset += 2;
      }
      break;
    case DW_EH_PE_sdata4:
      if (*offset + 4 > size)
        return 0;
      {
        int32_t v = 0;
        memcpy(&v, data + *offset, 4);
        v = (int32_t)swap32_if((uint32_t)v, swap);
        sval = v;
        uval = (uint64_t)sval;
        *offset += 4;
      }
      break;
    case DW_EH_PE_sdata8:
      if (*offset + 8 > size)
        return 0;
      {
        int64_t v = 0;
        memcpy(&v, data + *offset, 8);
        v = (int64_t)swap64_if((uint64_t)v, swap);
        sval = v;
        uval = (uint64_t)sval;
        *offset += 8;
      }
      break;
    default:
      return 0;
  }

  if (apply_rel)
  {
    if (rel == DW_EH_PE_pcrel)
      uval += pc;
    else if (rel != 0)
      return 0;
  }

  if (ind)
    return 0;

  *out = uval;
  return 1;
}

static uint64_t adjust_address(uint64_t addr, uint64_t base_vmaddr, int isexe)
{
  if (!isexe && base_vmaddr && addr >= base_vmaddr)
    return addr - base_vmaddr;
  return addr;
}

typedef struct
{
  uint64_t offset;
  uint8_t encoding;
} CieInfo;

static int cie_list_add(CieInfo **list, size_t *count, size_t *cap, uint64_t offset, uint8_t encoding)
{
  if (!list || !count || !cap)
    return 0;
  if (*count >= *cap)
  {
    size_t newcap = *cap ? (*cap * 2) : 32;
    void *p = realloc(*list, newcap * sizeof(CieInfo));
    if (!p)
      return 0;
    *list = (CieInfo *)p;
    *cap = newcap;
  }
  (*list)[*count].offset = offset;
  (*list)[*count].encoding = encoding;
  (*count)++;
  return 1;
}

static int cie_list_find(CieInfo *list, size_t count, uint64_t offset, uint8_t *encoding)
{
  if (!list || !encoding)
    return 0;
  for (size_t i = 0; i < count; i++)
  {
    if (list[i].offset == offset)
    {
      *encoding = list[i].encoding;
      return 1;
    }
  }
  return 0;
}

static int find_section_by_name(const MachOInfo *info, const char *sectname, MachSection *out)
{
  if (!info || !sectname || !out)
    return 0;

  int found = 0;
  MachSection best;
  memset(&best, 0, sizeof(best));

  for (size_t i = 0; i < info->sections.count; i++)
  {
    const MachSection *sec = &info->sections.items[i];
    if (strncmp(sec->sectname, sectname, 16) == 0)
    {
      if (strncmp(sec->segname, "__TEXT", 16) == 0)
      {
        *out = *sec;
        return 1;
      }
      if (!found)
      {
        best = *sec;
        found = 1;
      }
    }
  }

  if (found)
  {
    *out = best;
    return 1;
  }

  return 0;
}

static void apply_eh_frame_sizes(const unsigned char *data, size_t size, const MachSection *sec,
                                 const MachOInfo *info, SymbolList *list)
{
  if (!data || !sec || !info || !list || size == 0)
    return;

  CieInfo *cies = NULL;
  size_t cie_count = 0;
  size_t cie_cap = 0;

  size_t off = 0;
  while (off + 4 <= size)
  {
    size_t record_start = off;
    uint32_t len32 = 0;
    memcpy(&len32, data + off, sizeof(len32));
    len32 = swap32_if(len32, info->swap);
    off += 4;

    if (len32 == 0)
      break;

    uint64_t length = len32;
    int len64 = 0;
    if (len32 == 0xffffffff)
    {
      if (off + 8 > size)
        break;
      uint64_t len = 0;
      memcpy(&len, data + off, sizeof(len));
      length = swap64_if(len, info->swap);
      off += 8;
      len64 = 1;
    }

    size_t content_start = off;
    size_t record_end = content_start + (size_t)length;
    if (record_end > size)
      break;

    size_t id_size = len64 ? 8 : 4;
    if (content_start + id_size > record_end)
    {
      off = record_end;
      continue;
    }

    uint64_t cie_id = 0;
    if (len64)
    {
      uint64_t v = 0;
      memcpy(&v, data + content_start, 8);
      cie_id = swap64_if(v, info->swap);
    }
    else
    {
      uint32_t v = 0;
      memcpy(&v, data + content_start, 4);
      cie_id = swap32_if(v, info->swap);
    }

    size_t cur = content_start + id_size;
    if (cie_id == 0)
    {
      if (cur >= record_end)
      {
        off = record_end;
        continue;
      }
      uint8_t version = data[cur++];
      (void)version;

      size_t aug_start = cur;
      while (cur < record_end && data[cur] != 0)
        cur++;
      if (cur >= record_end)
      {
        off = record_end;
        continue;
      }
      const char *aug = (const char *)&data[aug_start];
      cur++;

      uint64_t dummy_u = 0;
      int64_t dummy_s = 0;
      read_uleb(data, record_end, &cur, &dummy_u);
      read_sleb(data, record_end, &cur, &dummy_s);
      read_uleb(data, record_end, &cur, &dummy_u);

      if (version >= 4 && cur + 2 <= record_end)
        cur += 2;

      uint8_t encoding = DW_EH_PE_absptr;
      if (strchr(aug, 'z') != NULL)
      {
        uint64_t aug_len = 0;
        if (read_uleb(data, record_end, &cur, &aug_len))
        {
          size_t aug_end = cur + (size_t)aug_len;
          size_t sub = cur;
          const char *p = aug;
          if (*p == 'z')
            p++;
          while (*p && sub < aug_end)
          {
            if (*p == 'R')
            {
              encoding = data[sub++];
            }
            else if (*p == 'L')
            {
              sub++;
            }
            else if (*p == 'P')
            {
              uint8_t enc = 0;
              if (sub < aug_end)
                enc = data[sub++];
              uint64_t tmp = 0;
              size_t tmp_off = sub;
              if (read_encoded_value(data, aug_end, &tmp_off, enc,
                                     sec->addr + sub, info->swap, info->is64, 1, &tmp))
                sub = tmp_off;
              else
                sub = aug_end;
            }
            else if (*p == 'S')
            {

            }
            p++;
          }
          cur = aug_end;
        }
      }

      cie_list_add(&cies, &cie_count, &cie_cap, record_start, encoding);
    }
    else
    {
      uint64_t cie_offset = content_start - cie_id;
      uint8_t encoding = DW_EH_PE_absptr;
      if (!cie_list_find(cies, cie_count, cie_offset, &encoding))
      {
        off = record_end;
        continue;
      }

      if (encoding != DW_EH_PE_omit)
      {
        uint64_t start = 0;
        uint64_t range = 0;
        size_t start_off = cur;
        if (read_encoded_value(data, record_end, &cur, encoding,
                               sec->addr + start_off, info->swap, info->is64, 1, &start))
        {
          uint8_t range_enc = (encoding & 0x0f);
          if (range_enc == DW_EH_PE_omit)
          {

          }
          else if (read_encoded_value(data, record_end, &cur, range_enc,
                                      0, info->swap, info->is64, 0, &range))
          {
            if (range > 0)
            {
              uint64_t adj = adjust_address(start, info->base_vmaddr, (info->filetype == MH_EXECUTE && (info->flags & MH_PIE) == 0));
              for (size_t i = 0; i < list->count; i++)
              {
                if (list->items[i].addr == adj && list->items[i].size == 0)
                  list->items[i].size = (uint32_t)range;
              }
            }
          }
        }
      }
    }

    off = record_end;
  }

  free(cies);
}

static int parse_fat_slice(int fd, uint32_t fileoffset, uint32_t *out_offset, uint32_t *out_size)
{
  uint32_t magic = 0;
  if (!read_at(fd, fileoffset, &magic, sizeof(magic)))
    return 0;

  if (magic != FAT_MAGIC && magic != FAT_CIGAM && magic != FAT_MAGIC_64 && magic != FAT_CIGAM_64)
  {
    *out_offset = fileoffset;
    if (out_size)
      *out_size = 0;
    return 1;
  }

  int swap = (magic == FAT_CIGAM || magic == FAT_CIGAM_64);
  int is64 = (magic == FAT_MAGIC_64 || magic == FAT_CIGAM_64);

  struct fat_header fh;
  if (!read_at(fd, fileoffset, &fh, sizeof(fh)))
    return 0;
  uint32_t nfat = swap32_if(fh.nfat_arch, swap);

  uint32_t best_off = 0;
  uint32_t best_size = 0;
  int found = 0;

  for (uint32_t i = 0; i < nfat; i++)
  {
    if (is64)
    {
      struct fat_arch_64 fa;
      uint64_t off = fileoffset + sizeof(fh) + (uint64_t)i * sizeof(fa);
      if (!read_at(fd, off, &fa, sizeof(fa)))
        break;

      cpu_type_t cputype = (cpu_type_t)swap32_if(fa.cputype, swap);
      if (cputype == CPU_TYPE_ARM64 || cputype == CPU_TYPE_ARM64_32)
      {
        best_off = swap32_if((uint32_t)fa.offset, swap);
        best_size = swap32_if((uint32_t)fa.size, swap);
        found = 1;
        break;
      }

      if (!found)
      {
        best_off = swap32_if((uint32_t)fa.offset, swap);
        best_size = swap32_if((uint32_t)fa.size, swap);
      }
    }
    else
    {
      struct fat_arch fa;
      uint64_t off = fileoffset + sizeof(fh) + (uint64_t)i * sizeof(fa);
      if (!read_at(fd, off, &fa, sizeof(fa)))
        break;

      cpu_type_t cputype = (cpu_type_t)swap32_if(fa.cputype, swap);
      if (cputype == CPU_TYPE_ARM64 || cputype == CPU_TYPE_ARM64_32)
      {
        best_off = swap32_if(fa.offset, swap);
        best_size = swap32_if(fa.size, swap);
        found = 1;
        break;
      }

      if (!found)
      {
        best_off = swap32_if(fa.offset, swap);
        best_size = swap32_if(fa.size, swap);
      }
    }
  }

  if (!best_off)
    return 0;

  *out_offset = fileoffset + best_off;
  if (out_size)
    *out_size = best_size;
  return 1;
}

static int parse_macho_header(int fd, uint32_t fileoffset, MachOInfo *info)
{
  uint32_t magic = 0;
  if (!read_at(fd, fileoffset, &magic, sizeof(magic)))
    return 0;

  memset(info, 0, sizeof(*info));

  if (magic == MH_MAGIC_64 || magic == MH_CIGAM_64)
  {
    struct mach_header_64 mh;
    if (!read_at(fd, fileoffset, &mh, sizeof(mh)))
      return 0;
    info->swap = (magic == MH_CIGAM_64);
    info->is64 = 1;
    info->ncmds = swap32_if(mh.ncmds, info->swap);
    info->sizeofcmds = swap32_if(mh.sizeofcmds, info->swap);
    info->filetype = swap32_if(mh.filetype, info->swap);
    info->flags = swap32_if(mh.flags, info->swap);
  }
  else if (magic == MH_MAGIC || magic == MH_CIGAM)
  {
    struct mach_header mh;
    if (!read_at(fd, fileoffset, &mh, sizeof(mh)))
      return 0;
    info->swap = (magic == MH_CIGAM);
    info->is64 = 0;
    info->ncmds = swap32_if(mh.ncmds, info->swap);
    info->sizeofcmds = swap32_if(mh.sizeofcmds, info->swap);
    info->filetype = swap32_if(mh.filetype, info->swap);
    info->flags = swap32_if(mh.flags, info->swap);
  }
  else
    return 0;

  if (info->sizeofcmds == 0 || info->ncmds == 0)
    return 0;

  uint64_t cmds_offset = fileoffset + (info->is64 ? sizeof(struct mach_header_64) : sizeof(struct mach_header));
  unsigned char *cmds = (unsigned char *)malloc(info->sizeofcmds);
  if (!cmds)
    return 0;

  if (!read_at(fd, cmds_offset, cmds, info->sizeofcmds))
  {
    free(cmds);
    return 0;
  }

  uint64_t cursor = 0;
  for (uint32_t i = 0; i < info->ncmds; i++)
  {
    if (cursor + sizeof(struct load_command) > info->sizeofcmds)
      break;

    struct load_command *lc = (struct load_command *)&cmds[cursor];
    uint32_t cmd = swap32_if(lc->cmd, info->swap);
    uint32_t cmdsize = swap32_if(lc->cmdsize, info->swap);
    if (cmdsize < sizeof(struct load_command) || cursor + cmdsize > info->sizeofcmds)
      break;

    if (cmd == LC_SEGMENT_64 && info->is64)
    {
      struct segment_command_64 seg;
      memcpy(&seg, lc, sizeof(seg));
      seg.vmaddr = swap64_if(seg.vmaddr, info->swap);
      seg.vmsize = swap64_if(seg.vmsize, info->swap);
      seg.fileoff = swap64_if(seg.fileoff, info->swap);
      seg.filesize = swap64_if(seg.filesize, info->swap);
      seg.nsects = swap32_if(seg.nsects, info->swap);
      seg.flags = swap32_if(seg.flags, info->swap);

      if (seg.fileoff == 0 && info->base_vmaddr == 0)
        info->base_vmaddr = seg.vmaddr;

      if (strncmp(seg.segname, "__TEXT", 16) == 0 && info->text_vmaddr == 0)
        info->text_vmaddr = seg.vmaddr;

      size_t sect_offset = cursor + sizeof(struct segment_command_64);
      for (uint32_t s = 0; s < seg.nsects; s++)
      {
        if (sect_offset + sizeof(struct section_64) > cursor + cmdsize)
          break;
        struct section_64 sec;
        memcpy(&sec, &cmds[sect_offset], sizeof(sec));
        MachSection ms;
        memset(&ms, 0, sizeof(ms));
        memcpy(ms.segname, sec.segname, 16);
        memcpy(ms.sectname, sec.sectname, 16);
        ms.segname[16] = 0;
        ms.sectname[16] = 0;
        ms.addr = swap64_if(sec.addr, info->swap);
        ms.size = swap64_if(sec.size, info->swap);
        ms.flags = swap32_if(sec.flags, info->swap);
        ms.reserved1 = swap32_if(sec.reserved1, info->swap);
        ms.reserved2 = swap32_if(sec.reserved2, info->swap);
        ms.fileoff = swap32_if(sec.offset, info->swap);
        section_list_append(&info->sections, &ms);
        sect_offset += sizeof(struct section_64);
      }
    }
    else if (cmd == LC_SEGMENT && !info->is64)
    {
      struct segment_command seg;
      memcpy(&seg, lc, sizeof(seg));
      seg.vmaddr = swap32_if(seg.vmaddr, info->swap);
      seg.vmsize = swap32_if(seg.vmsize, info->swap);
      seg.fileoff = swap32_if(seg.fileoff, info->swap);
      seg.filesize = swap32_if(seg.filesize, info->swap);
      seg.nsects = swap32_if(seg.nsects, info->swap);
      seg.flags = swap32_if(seg.flags, info->swap);

      if (seg.fileoff == 0 && info->base_vmaddr == 0)
        info->base_vmaddr = seg.vmaddr;

      if (strncmp(seg.segname, "__TEXT", 16) == 0 && info->text_vmaddr == 0)
        info->text_vmaddr = seg.vmaddr;

      size_t sect_offset = cursor + sizeof(struct segment_command);
      for (uint32_t s = 0; s < seg.nsects; s++)
      {
        if (sect_offset + sizeof(struct section) > cursor + cmdsize)
          break;
        struct section sec;
        memcpy(&sec, &cmds[sect_offset], sizeof(sec));
        MachSection ms;
        memset(&ms, 0, sizeof(ms));
        memcpy(ms.segname, sec.segname, 16);
        memcpy(ms.sectname, sec.sectname, 16);
        ms.segname[16] = 0;
        ms.sectname[16] = 0;
        ms.addr = swap32_if(sec.addr, info->swap);
        ms.size = swap32_if(sec.size, info->swap);
        ms.flags = swap32_if(sec.flags, info->swap);
        ms.reserved1 = swap32_if(sec.reserved1, info->swap);
        ms.reserved2 = swap32_if(sec.reserved2, info->swap);
        ms.fileoff = swap32_if(sec.offset, info->swap);
        section_list_append(&info->sections, &ms);
        sect_offset += sizeof(struct section);
      }
    }
    else if (cmd == LC_SYMTAB)
    {
      struct symtab_command st;
      memcpy(&st, lc, sizeof(st));
      st.cmd = cmd;
      st.cmdsize = cmdsize;
      st.symoff = swap32_if(st.symoff, info->swap);
      st.nsyms = swap32_if(st.nsyms, info->swap);
      st.stroff = swap32_if(st.stroff, info->swap);
      st.strsize = swap32_if(st.strsize, info->swap);
      info->symtab = st;
    }
    else if (cmd == LC_DYSYMTAB)
    {
      struct dysymtab_command dt;
      memcpy(&dt, lc, sizeof(dt));
      dt.cmd = cmd;
      dt.cmdsize = cmdsize;
      dt.ilocalsym = swap32_if(dt.ilocalsym, info->swap);
      dt.nlocalsym = swap32_if(dt.nlocalsym, info->swap);
      dt.iextdefsym = swap32_if(dt.iextdefsym, info->swap);
      dt.nextdefsym = swap32_if(dt.nextdefsym, info->swap);
      dt.iundefsym = swap32_if(dt.iundefsym, info->swap);
      dt.nundefsym = swap32_if(dt.nundefsym, info->swap);
      dt.tocoff = swap32_if(dt.tocoff, info->swap);
      dt.ntoc = swap32_if(dt.ntoc, info->swap);
      dt.modtaboff = swap32_if(dt.modtaboff, info->swap);
      dt.nmodtab = swap32_if(dt.nmodtab, info->swap);
      dt.extrefsymoff = swap32_if(dt.extrefsymoff, info->swap);
      dt.nextrefsyms = swap32_if(dt.nextrefsyms, info->swap);
      dt.indirectsymoff = swap32_if(dt.indirectsymoff, info->swap);
      dt.nindirectsyms = swap32_if(dt.nindirectsyms, info->swap);
      dt.extreloff = swap32_if(dt.extreloff, info->swap);
      dt.nextrel = swap32_if(dt.nextrel, info->swap);
      dt.locreloff = swap32_if(dt.locreloff, info->swap);
      dt.nlocrel = swap32_if(dt.nlocrel, info->swap);
      info->dysymtab = dt;
    }
    else if (cmd == LC_DYLD_INFO || cmd == LC_DYLD_INFO_ONLY)
    {
      struct dyld_info_command di;
      memcpy(&di, lc, sizeof(di));
      di.cmd = cmd;
      di.cmdsize = cmdsize;
      di.export_off = swap32_if(di.export_off, info->swap);
      di.export_size = swap32_if(di.export_size, info->swap);
      info->dyld_info = di;
    }
    else if (cmd == LC_DYLD_EXPORTS_TRIE)
    {
      struct linkedit_data_command le;
      memcpy(&le, lc, sizeof(le));
      le.cmd = cmd;
      le.cmdsize = cmdsize;
      le.dataoff = swap32_if(le.dataoff, info->swap);
      le.datasize = swap32_if(le.datasize, info->swap);
      info->exports_trie = le;
    }
    else if (cmd == LC_FUNCTION_STARTS)
    {
      struct linkedit_data_command le;
      memcpy(&le, lc, sizeof(le));
      le.cmd = cmd;
      le.cmdsize = cmdsize;
      le.dataoff = swap32_if(le.dataoff, info->swap);
      le.datasize = swap32_if(le.datasize, info->swap);
      info->function_starts = le;
    }

    cursor += cmdsize;
  }

  free(cmds);
  return info->symtab.cmd == LC_SYMTAB;
}

static int read_symtab_data(int fd, uint32_t fileoffset, const MachOInfo *info,
                            unsigned char **symtab, size_t *symtab_size,
                            unsigned char **strtab, size_t *strtab_size)
{
  if (!info->symtab.symoff || !info->symtab.nsyms || !info->symtab.stroff || !info->symtab.strsize)
    return 0;

  size_t nlist_size = info->is64 ? sizeof(struct nlist_64) : sizeof(struct nlist);
  size_t symtab_bytes = info->symtab.nsyms * nlist_size;
  size_t strtab_bytes = info->symtab.strsize;

  *symtab = (unsigned char *)malloc(symtab_bytes);
  *strtab = (unsigned char *)malloc(strtab_bytes);
  if (!*symtab || !*strtab)
  {
    free(*symtab);
    free(*strtab);
    *symtab = NULL;
    *strtab = NULL;
    return 0;
  }

  if (!read_at(fd, (uint64_t)fileoffset + info->symtab.symoff, *symtab, symtab_bytes))
  {
    free(*symtab);
    free(*strtab);
    *symtab = NULL;
    *strtab = NULL;
    return 0;
  }
  if (!read_at(fd, (uint64_t)fileoffset + info->symtab.stroff, *strtab, strtab_bytes))
  {
    free(*symtab);
    free(*strtab);
    *symtab = NULL;
    *strtab = NULL;
    return 0;
  }

  *symtab_size = symtab_bytes;
  *strtab_size = strtab_bytes;
  return 1;
}

static int get_nlist_entry(const unsigned char *symtab, size_t nsyms, size_t index,
                           int is64, int swap, struct nlist_64 *out)
{
  if (index >= nsyms)
    return 0;

  if (is64)
  {
    struct nlist_64 n;
    memcpy(&n, symtab + index * sizeof(struct nlist_64), sizeof(n));
    n.n_strx = swap32_if(n.n_strx, swap);
    n.n_desc = swap16_if(n.n_desc, swap);
    n.n_value = swap64_if(n.n_value, swap);
    *out = n;
    return 1;
  }
  else
  {
    struct nlist n32;
    memcpy(&n32, symtab + index * sizeof(struct nlist), sizeof(n32));
    struct nlist_64 n;
    memset(&n, 0, sizeof(n));
    n.n_strx = swap32_if(n32.n_strx, swap);
    n.n_type = n32.n_type;
    n.n_sect = n32.n_sect;
    n.n_desc = swap16_if(n32.n_desc, swap);
    n.n_value = swap32_if(n32.n_value, swap);
    *out = n;
    return 1;
  }
}

static const char *get_symbol_name(const unsigned char *strtab, size_t strtab_size, uint32_t strx)
{
  if (!strtab || strx >= strtab_size)
    return NULL;
  return (const char *)&strtab[strx];
}

static int parse_exports_trie(const unsigned char *data, size_t size, size_t node_offset,
                              char **namebuf, size_t *name_cap, size_t name_len,
                              uint64_t text_base, int is_arm,
                              SymbolList *symbols, AddrSet *addrset,
                              uint64_t base_vmaddr, int isexe)
{
  if (node_offset >= size)
    return 1;

  char *name = *namebuf;
  size_t cap = *name_cap;

  size_t offset = node_offset;
  uint64_t terminal_size = 0;
  if (!read_uleb(data, size, &offset, &terminal_size))
    return 0;

  size_t children_offset = offset + (size_t)terminal_size;
  if (children_offset > size)
    return 0;

  if (terminal_size)
  {
    uint64_t flags = 0;
    if (!read_uleb(data, size, &offset, &flags))
      return 0;

    const char *import_name = NULL;
    uint64_t address = 0;
    if (flags & EXPORT_SYMBOL_FLAGS_REEXPORT)
    {
      uint64_t ordinal = 0;
      if (!read_uleb(data, size, &offset, &ordinal))
        return 0;
      import_name = read_cstr(data, size, &offset);
      (void)ordinal;
    }
    else
    {
      if (!read_uleb(data, size, &offset, &address))
        return 0;
      address += text_base;
      if (flags & EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER)
      {
        uint64_t resolver = 0;
        if (!read_uleb(data, size, &offset, &resolver))
          return 0;
        (void)resolver;
      }
      if (is_arm && (address & 1))
        address &= 0xfffffffffffffffeULL;
    }

    if (name_len > 1 && (flags == 0 || (flags & EXPORT_SYMBOL_FLAGS_REEXPORT)))
    {
      const char *final_name = name;
      if (final_name[0] == '_')
        final_name++;

      if (!(flags & EXPORT_SYMBOL_FLAGS_REEXPORT))
      {
        uint64_t adj = adjust_address(address, base_vmaddr, isexe);
        if (!addrset_contains(addrset, adj))
        {
          if (symbol_list_append(symbols, adj, 0, (uint32_t)flags, final_name))
            addrset_insert(addrset, adj);
        }
      }
      (void)import_name;
    }
  }

  if (children_offset >= size)
    return 1;

  uint8_t child_count = data[children_offset++];
  for (uint8_t i = 0; i < child_count; i++)
  {
    const char *edge = read_cstr(data, size, &children_offset);
    if (!edge)
      return 0;

    size_t edge_len = strlen(edge);
    if (name_len + edge_len + 1 > cap)
    {
      size_t newcap = cap * 2;
      while (name_len + edge_len + 1 > newcap)
        newcap *= 2;
      char *newbuf = (char *)realloc(name, newcap);
      if (!newbuf)
        return 0;
      name = newbuf;
      cap = newcap;
      *namebuf = newbuf;
      *name_cap = newcap;
    }

    memcpy(name + name_len, edge, edge_len + 1);
    size_t next_len = name_len + edge_len;

    uint64_t child_node = 0;
    if (!read_uleb(data, size, &children_offset, &child_node))
      return 0;

    if (child_node)
    {
      if (!parse_exports_trie(data, size, (size_t)child_node, namebuf, name_cap, next_len,
                              text_base, is_arm, symbols, addrset, base_vmaddr, isexe))
        return 0;
    }

    name = *namebuf;
    name[name_len] = 0;
  }

  return 1;
}

static int build_uncompressed_buffer(const SymbolList *list, unsigned char **out, size_t *out_size)
{
  size_t total = 0;
  for (size_t i = 0; i < list->count; i++)
  {
    size_t name_len = strlen(list->items[i].name);
    if (name_len > 255)
      name_len = 255;
    total += sizeof(symbolinfo) + name_len;
  }

  if (total == 0)
    return 0;

  unsigned char *buf = (unsigned char *)malloc(total);
  if (!buf)
    return 0;

  size_t pos = 0;
  for (size_t i = 0; i < list->count; i++)
  {
    size_t name_len = strlen(list->items[i].name);
    if (name_len > 255)
      name_len = 255;

    symbolinfo si;
    si.address = list->items[i].addr;
    si.size = (int)list->items[i].size;
    si.type = (int)list->items[i].type;
    si.namelength = (unsigned char)name_len;

    memcpy(&buf[pos], &si, sizeof(si));
    pos += sizeof(si);
    memcpy(&buf[pos], list->items[i].name, name_len);
    pos += name_len;
  }

  *out = buf;
  *out_size = total;
  return 1;
}

static int cmp_u64(const void *a, const void *b)
{
  uint64_t va = *(const uint64_t *)a;
  uint64_t vb = *(const uint64_t *)b;
  if (va < vb)
    return -1;
  if (va > vb)
    return 1;
  return 0;
}

static int compress_symbol_list(const SymbolList *list, int isexe, unsigned char **output)
{
  unsigned char *uncompressed = NULL;
  size_t uncompressed_size = 0;
  if (!build_uncompressed_buffer(list, &uncompressed, &uncompressed_size))
    return -1;

  uLongf bound = compressBound((uLong)uncompressed_size);
  if (bound + (3 * sizeof(uint32_t)) > UINT32_MAX)
  {
    free(uncompressed);
    return -1;
  }

  unsigned char *out = (unsigned char *)malloc(bound + (3 * sizeof(uint32_t)));
  if (!out)
  {
    free(uncompressed);
    return -1;
  }

  uLongf comp_size = bound;
  int z = compress2(out + (3 * sizeof(uint32_t)), &comp_size, uncompressed, (uLong)uncompressed_size, 9);
  free(uncompressed);
  if (z != Z_OK)
  {
    free(out);
    return -1;
  }

  *(uint32_t *)&out[0] = (uint32_t)isexe;
  *(uint32_t *)&out[4] = (uint32_t)(comp_size + (3 * sizeof(uint32_t)));
  *(uint32_t *)&out[8] = (uint32_t)uncompressed_size;

  *output = out;
  return 0;
}

int GetSymbolListFromFile(char *filename, uint32_t fileoffset, unsigned char **output)
{
  int fd;
  MachOInfo info;
  unsigned char *symtab = NULL;
  unsigned char *strtab = NULL;
  size_t symtab_size = 0;
  size_t strtab_size = 0;

  *output = NULL;

  fd = open(filename, O_RDONLY);
  if (fd == -1)
    return -1;

  uint32_t slice_offset = 0;
  uint32_t slice_size = 0;
  if (!parse_fat_slice(fd, fileoffset, &slice_offset, &slice_size))
  {
    close(fd);
    return -1;
  }

  if (!parse_macho_header(fd, slice_offset, &info))
  {
    section_list_free(&info.sections);
    close(fd);
    return -1;
  }

  if (info.text_vmaddr == 0)
    info.text_vmaddr = info.base_vmaddr;
  if (info.base_vmaddr == 0)
    info.base_vmaddr = info.text_vmaddr;

  if (!read_symtab_data(fd, slice_offset, &info, &symtab, &symtab_size, &strtab, &strtab_size))
  {
    section_list_free(&info.sections);
    close(fd);
    free(symtab);
    free(strtab);
    return -1;
  }

  int isexe = (info.filetype == MH_EXECUTE && (info.flags & MH_PIE) == 0);

  SymbolList list;
  memset(&list, 0, sizeof(list));

  AddrSet addrset;
  memset(&addrset, 0, sizeof(addrset));
  addrset_init(&addrset, 16384);

  size_t nsyms = info.symtab.nsyms;
  for (size_t i = 0; i < nsyms; i++)
  {
    struct nlist_64 n;
    if (!get_nlist_entry(symtab, nsyms, i, info.is64, info.swap, &n))
      continue;

    if (n.n_value == 0)
      continue;

    const char *name = get_symbol_name(strtab, strtab_size, n.n_strx);
    if (!name || !name[0])
      continue;

    uint64_t addr = adjust_address(n.n_value, info.base_vmaddr, isexe);
    symbol_list_append(&list, addr, 0, n.n_type, name);
    addrset_insert(&addrset, addr);
  }


  uint32_t trie_off = 0;
  uint32_t trie_size = 0;
  if (info.exports_trie.dataoff && info.exports_trie.datasize)
  {
    trie_off = info.exports_trie.dataoff;
    trie_size = info.exports_trie.datasize;
  }
  else if (info.dyld_info.export_off && info.dyld_info.export_size)
  {
    trie_off = info.dyld_info.export_off;
    trie_size = info.dyld_info.export_size;
  }

  if (trie_off && trie_size)
  {
    unsigned char *trie_data = (unsigned char *)malloc(trie_size);
    if (trie_data && read_at(fd, (uint64_t)slice_offset + trie_off, trie_data, trie_size))
    {
      size_t name_cap = 256;
      char *namebuf = (char *)malloc(name_cap);
      if (namebuf)
      {
        namebuf[0] = 0;
        parse_exports_trie(trie_data, trie_size, 0, &namebuf, &name_cap, 0, info.text_vmaddr,
                           0, &list, &addrset, info.base_vmaddr, isexe);
        free(namebuf);
      }
    }
    free(trie_data);
  }


  if (info.function_starts.dataoff && info.function_starts.datasize && info.text_vmaddr)
  {
    unsigned char *fs_data = (unsigned char *)malloc(info.function_starts.datasize);
    if (fs_data && read_at(fd, (uint64_t)slice_offset + info.function_starts.dataoff, fs_data,
                           info.function_starts.datasize))
    {
      size_t fs_count = 0;
      size_t fs_cap = 256;
      uint64_t *fs_addrs = (uint64_t *)malloc(fs_cap * sizeof(uint64_t));
      if (fs_addrs)
      {
        size_t off = 0;
        uint64_t addr = info.text_vmaddr;
        while (off < info.function_starts.datasize)
        {
          uint64_t delta = 0;
          if (!read_uleb(fs_data, info.function_starts.datasize, &off, &delta))
            break;
          if (delta == 0)
            break;
          addr += delta;
          uint64_t rel = adjust_address(addr, info.base_vmaddr, isexe);
          if (fs_count >= fs_cap)
          {
            size_t newcap = fs_cap * 2;
            uint64_t *newp = (uint64_t *)realloc(fs_addrs, newcap * sizeof(uint64_t));
            if (!newp)
              break;
            fs_addrs = newp;
            fs_cap = newcap;
          }
          fs_addrs[fs_count++] = rel;
        }

        if (fs_count > 1)
        {
          qsort(fs_addrs, fs_count, sizeof(uint64_t), cmp_u64);

          for (size_t i = 0; i + 1 < fs_count; i++)
          {
            uint64_t start = fs_addrs[i];
            uint64_t end = fs_addrs[i + 1];
            uint64_t size = (end > start) ? (end - start) : 0;
            if (size == 0)
              continue;
            for (size_t s = 0; s < list.count; s++)
            {
              if (list.items[s].addr == start && list.items[s].size == 0)
                list.items[s].size = (uint32_t)size;
            }
          }
        }

        free(fs_addrs);
      }
    }
    free(fs_data);
  }


  {
    MachSection eh_sec;
    if (find_section_by_name(&info, "__eh_frame", &eh_sec) && eh_sec.size > 0)
    {
      unsigned char *eh_data = (unsigned char *)malloc((size_t)eh_sec.size);
      if (eh_data && read_at(fd, (uint64_t)slice_offset + eh_sec.fileoff, eh_data, (size_t)eh_sec.size))
        apply_eh_frame_sizes(eh_data, (size_t)eh_sec.size, &eh_sec, &info, &list);
      free(eh_data);
    }
  }


  if (info.dysymtab.nindirectsyms && info.dysymtab.indirectsymoff && info.sections.count)
  {
    size_t indirect_count = info.dysymtab.nindirectsyms;
    size_t indirect_bytes = indirect_count * sizeof(uint32_t);
    uint32_t *indirect = (uint32_t *)malloc(indirect_bytes);
    if (indirect && read_at(fd, (uint64_t)slice_offset + info.dysymtab.indirectsymoff, indirect, indirect_bytes))
    {
      for (size_t i = 0; i < indirect_count; i++)
        indirect[i] = swap32_if(indirect[i], info.swap);

      for (size_t s = 0; s < info.sections.count; s++)
      {
        MachSection *sec = &info.sections.items[s];
        if ((sec->flags & SECTION_TYPE) != S_SYMBOL_STUBS)
          continue;
        if (sec->reserved2 == 0)
          continue;

        uint32_t stub_size = sec->reserved2;
        uint32_t num_stubs = (uint32_t)(sec->size / stub_size);
        uint32_t index_offset = sec->reserved1;

        for (uint32_t j = 0; j < num_stubs; j++)
        {
          uint32_t idx = index_offset + j;
          if (idx >= indirect_count)
            break;

          uint32_t sym_index = indirect[idx];
          if (sym_index & (INDIRECT_SYMBOL_ABS | INDIRECT_SYMBOL_LOCAL))
            continue;

          struct nlist_64 n;
          if (!get_nlist_entry(symtab, nsyms, sym_index, info.is64, info.swap, &n))
            continue;

          const char *name = get_symbol_name(strtab, strtab_size, n.n_strx);
          if (!name || !name[0])
            continue;

          uint64_t stub_addr = sec->addr + (uint64_t)j * stub_size;
          uint64_t addr = adjust_address(stub_addr, info.base_vmaddr, isexe);
          if (addrset_contains(&addrset, addr))
            continue;

          if (symbol_list_append(&list, addr, stub_size, N_SECT, name))
            addrset_insert(&addrset, addr);
        }
      }
    }
    free(indirect);
  }

  int r = compress_symbol_list(&list, isexe, output);

  addrset_free(&addrset);
  symbol_list_free(&list);
  section_list_free(&info.sections);
  free(symtab);
  free(strtab);
  close(fd);

  return r;
}

typedef struct _fsc
{
  uintptr_t modulebase;
  symcallback originalCallback;
  void *originalContext;
} FindSymbolContext, *PFindSymbolContext;

void FindSymbol_internal(uintptr_t address, char *symbolname, PFindSymbolContext context)
{
  context->originalCallback(context->modulebase + address, symbolname, context->originalContext);
}

int FindSymbol(HANDLE hProcess, char *symbolname, symcallback cb, void *context)
{
  HANDLE ths;
  ModuleListEntry mle;

  if (GetHandleType(hProcess) == htProcesHandle)
  {
    FindSymbolContext c;
    c.originalCallback = cb;
    c.originalContext = context;
    PProcessData p = (PProcessData)GetPointerFromHandle(hProcess);
    if (p == NULL)
      return FALSE;

    ths = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, p->pid);

    if (Module32First(ths, &mle))
      do
      {
        if (mle.part == 0)
        {
          int fd;
          uint32_t fileoffset = mle.fileOffset;

          c.modulebase = (uintptr_t)mle.baseAddress;

          fd = open(mle.moduleName, O_RDONLY);
          if (fd == -1)
            continue;

          unsigned char *symtab = NULL;
          unsigned char *strtab = NULL;
          size_t symtab_size = 0;
          size_t strtab_size = 0;
          MachOInfo info;
          uint32_t slice_offset = 0;
          uint32_t slice_size = 0;

          if (!parse_fat_slice(fd, fileoffset, &slice_offset, &slice_size))
          {
            close(fd);
            continue;
          }

          if (!parse_macho_header(fd, slice_offset, &info))
          {
            close(fd);
            continue;
          }

          if (read_symtab_data(fd, slice_offset, &info, &symtab, &symtab_size, &strtab, &strtab_size))
          {
            size_t nsyms = info.symtab.nsyms;
            for (size_t i = 0; i < nsyms; i++)
            {
              struct nlist_64 n;
              if (!get_nlist_entry(symtab, nsyms, i, info.is64, info.swap, &n))
                continue;
              if (n.n_value == 0)
                continue;
              const char *name = get_symbol_name(strtab, strtab_size, n.n_strx);
              if (!name)
                continue;
              if (strcmp(name, symbolname) == 0)
              {
                uint64_t addr = adjust_address(n.n_value, info.base_vmaddr, 0);
                FindSymbol_internal((uintptr_t)addr, (char *)name, &c);
                break;
              }
            }
          }

          free(symtab);
          free(strtab);
          section_list_free(&info.sections);
          close(fd);
        }
      } while (Module32Next(ths, &mle));

    CloseHandle(ths);
  }

  return 0;
}

```

`ceserver-ios/jailed/symbols.h`:

```h
#ifndef SYMBOLS_H_
#define SYMBOLS_H_

#include "api.h"

typedef void (*symcallback)(uintptr_t address, char *symbolname, void *context);

int GetSymbolListFromFile(char *filename, uint32_t fileoffset, unsigned char **output);
int FindSymbol(HANDLE hProcess, char *symbolname, symcallback cb, void *context);

#endif

```

`plugin/ios_rtti/Makefile`:

```
CXX = x86_64-w64-mingw32-g++

CXXFLAGS = -shared -static -static-libgcc -static-libstdc++ -s -std=c++17 -Ice_sdk -Illvm/include

TARGET = ios_rtti_plugin.dll

SRC = ios_rtti_plugin.cpp llvm/lib/Demangle/ItaniumDemangle.cpp

all: $(TARGET)

$(TARGET): $(SRC)
	$(CXX) $(CXXFLAGS) -o $@ $^

clean:
	rm -f $(TARGET) *.o

.PHONY: all clean

```

`plugin/ios_rtti/ce_sdk/cepluginsdk.h`:

```h
/*
 cepluginsdk.h
 Updated July 4, 2017

 v5.0.0
*/
#ifndef CEPLUGINSDK_H
#define CEPLUGINSDK_H

#include <windows.h>
#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"


#define CESDK_VERSION 6

typedef enum {ptAddressList=0, ptMemoryView=1, ptOnDebugEvent=2, ptProcesswatcherEvent=3, ptFunctionPointerchange=4, ptMainMenu=5, ptDisassemblerContext=6, ptDisassemblerRenderLine=7, ptAutoAssembler=8} PluginType;
typedef enum {aaInitialize=0, aaPhase1=1, aaPhase2=2, aaFinalize=3} AutoAssemblerPhase;

typedef struct _PluginVersion
{
  unsigned int version; //write here the minimum version this dll is compatible with (Current supported version: 1 and 2: this SDK only describes 2)
  char *pluginname;  //make this point to a 0-terminated string (allocated memory or static addressin your dll, not stack)
} PluginVersion, *PPluginVersion;

typedef struct _PLUGINTYPE0_RECORD
{
  char *interpretedaddress; //pointer to a 255 bytes long string (0 terminated)
  UINT_PTR address;//this is a read-only representaion of the address. Change interpretedaddress if you want to change this
  BOOL ispointer; //readonly
  int countoffsets; //readonly
  ULONG *offsets; //array of dwords ranging from 0 to countoffsets-1 (readonly)
  char *description; //pointer to a 255 bytes long string
  char valuetype; //0=byte, 1=word, 2=dword, 3=float, 4=double, 5=bit, 6=int64, 7=string
  char size; //stringlength or bitlength;
} PLUGINTYPE0_RECORD, ADDRESSLIST_RECORD, *PPLUGINTYPE0_RECORD, *PADDRESSLIST_RECORD;

//callback routines efinitions for registered plugin functions:
typedef BOOL (__stdcall *CEP_PLUGINTYPE0)(PPLUGINTYPE0_RECORD SelectedRecord);
typedef BOOL (__stdcall *CEP_PLUGINTYPE1)(UINT_PTR *disassembleraddress, UINT_PTR *selected_disassembler_address, UINT_PTR *hexviewaddress);
typedef int (__stdcall *CEP_PLUGINTYPE2)(LPDEBUG_EVENT DebugEvent);
typedef void (__stdcall *CEP_PLUGINTYPE3)(ULONG processid, ULONG peprocess, BOOL Created);
typedef void (__stdcall *CEP_PLUGINTYPE4)(int reserved);
typedef void (__stdcall *CEP_PLUGINTYPE5)(void);
typedef BOOL (__stdcall *CEP_PLUGINTYPE6ONPOPUP)(UINT_PTR selectedAddress, char **addressofname, BOOL *show);
typedef BOOL (__stdcall *CEP_PLUGINTYPE6)(UINT_PTR *selectedAddress);
typedef void (__stdcall *CEP_PLUGINTYPE7)(UINT_PTR address, char **addressStringPointer, char **bytestringpointer, char **opcodestringpointer, char **specialstringpointer, ULONG *textcolor);
typedef void (__stdcall *CEP_PLUGINTYPE8)(char **line, AutoAssemblerPhase phase, int id);



typedef struct _PLUGINTYPE0_INIT
{
  char* name; //0 terminated string describing the name for the user's menu item
  CEP_PLUGINTYPE0 callbackroutine; //pointer to a callback routine of the type 0 plugin  
} PLUGINTYPE0_INIT, ADDRESSLISTPLUGIN_INIT, *PPLUGINTYPE0_INIT, *PADDRESSLISTPLUGIN_INIT;

typedef struct _PLUGINTYPE1_INIT
{
  char* name; //0 terminated string describing the name for the user's menu item
  CEP_PLUGINTYPE1 callbackroutine; //pointer to a callback routine of the type 1 plugin
  char* shortcut; //0 terminated string containing the shortcut in textform. CE will try it's best to parse it to a valid shortcut
} PLUGINTYPE1_INIT, MEMORYVIEWPLUGIN_INIT, *PPLUGINTYPE1_INIT, *PMEMORYVIEWPLUGIN_INIT;

typedef struct _PLUGINTYPE2_INIT
{
  CEP_PLUGINTYPE2 callbackroutine; //pointer to a callback routine of the type 2 plugin
} PLUGINTYPE2_INIT, DEBUGEVENTPLUGIN_INIT, *PPLUGINTYPE2_INIT, *PDEBUGEVENTPLUGIN_INIT;

typedef struct _PLUGINTYPE3_INIT
{
  CEP_PLUGINTYPE3 callbackroutine; //pointer to a callback routine of the type 3 plugin
} PLUGINTYPE3_INIT, PROCESSWATCHERPLUGIN_INIT, *PPLUGINTYPE3_INIT, *PPROCESSWATCHERPLUGIN_INIT;

typedef struct _PLUGINTYPE4_INIT
{
  CEP_PLUGINTYPE4 callbackroutine; //pointer to a callback routine of the type 4 plugin
} PLUGINTYPE4_INIT, POINTERREASSIGNMENTPLUGIN_INIT, *PPLUGINTYPE4_INIT, *PPOINTERREASSIGNMENTPLUGIN_INIT; 

typedef struct _PLUGINTYPE5_INIT
{
  char* name; //0 terminated string describing the name for the user's menu item
  CEP_PLUGINTYPE5 callbackroutine; 
  char* shortcut; //0 terminated string containing the shortcut in textform. CE will try it's best to parse it to a valid shortcut
} PLUGINTYPE5_INIT, MAINMENUPLUGIN_INIT, *PPLUGINTYPE5_INIT, *PMAINMENUPLUGIN_INIT;

typedef struct _PLUGINTYPE6_INIT
{
  char* name; //0 terminated string describing the name for the user's menu item
  CEP_PLUGINTYPE6 callbackroutine; 
  CEP_PLUGINTYPE6ONPOPUP callbackroutineOnPopup; 
  char* shortcut; //0 terminated string containing the shortcut in textform. CE will try it's best to parse it to a valid shortcut
} PLUGINTYPE6_INIT, DISASSEMBLERCONTEXT_INIT, *PPLUGINTYPE6_INIT, *PDISASSEMBLERCONTEXT_INIT;

typedef struct _PLUGINTYPE7_INIT
{
  CEP_PLUGINTYPE7 callbackroutine; //pointer to a callback routine of the type 7 plugin
} PLUGINTYPE7_INIT, DISASSEMBLERLINEPLUGIN_INIT, *PPLUGINTYPE7_INIT, *PDISASSEMBLERLINEPLUGIN_INIT; 

typedef struct _PLUGINTYPE8_INIT
{
  CEP_PLUGINTYPE8 callbackroutine; //pointer to a callback routine of the type 8 plugin
} PLUGINTYPE8_INIT, AUTOASSEMBLERPLUGIN_INIT, *PPLUGINTYPE8_INIT, *PAUTOASSEMBLERPLUGIN_INIT; 

typedef struct _REGISTERMODIFICATIONINFO
{
  UINT_PTR address; //addres to break on
  BOOL change_eax;
  BOOL change_ebx;
  BOOL change_ecx;
  BOOL change_edx;
  BOOL change_esi;
  BOOL change_edi;
  BOOL change_ebp;
  BOOL change_esp;
  BOOL change_eip;
#ifdef _AMD64_
  BOOL change_r8;
  BOOL change_r9;
  BOOL change_r10;
  BOOL change_r11;
  BOOL change_r12;
  BOOL change_r13;
  BOOL change_r14;
  BOOL change_r15;
#endif
  BOOL change_cf;
  BOOL change_pf;
  BOOL change_af;
  BOOL change_zf;
  BOOL change_sf;
  BOOL change_of;
  UINT_PTR new_eax;
  UINT_PTR new_ebx;
  UINT_PTR new_ecx;
  UINT_PTR new_edx;
  UINT_PTR new_esi;
  UINT_PTR new_edi;
  UINT_PTR new_ebp;
  UINT_PTR new_esp;
  UINT_PTR new_eip;
#ifdef _AMD64_
  UINT_PTR new_r8;
  UINT_PTR new_r9;
  UINT_PTR new_r10;
  UINT_PTR new_r11;
  UINT_PTR new_r12;
  UINT_PTR new_r13;
  UINT_PTR new_r14;
  UINT_PTR new_r15;
#endif
	 

  BOOL new_cf;
  BOOL new_pf;
  BOOL new_af;
  BOOL new_zf;
  BOOL new_sf;
  BOOL new_of;
} REGISTERMODIFICATIONINFO, *PREGISTERMODIFICATIONINFO;

//the __stdcall stuff isn't really needed since I've set compiler options to force stdcall, but this makes it clear that stdcall is used to the reader
typedef void (__stdcall *CEP_SHOWMESSAGE)(char* message);
typedef int (__stdcall *CEP_REGISTERFUNCTION) (int pluginid, PluginType functiontype, PVOID init);
typedef BOOL (__stdcall *CEP_UNREGISTERFUNCTION) (int pluginid, int functionid);
typedef HANDLE (__stdcall *CEP_GETMAINWINDOWHANDLE) (void);
typedef BOOL (__stdcall *CEP_AUTOASSEMBLE) (char *script);
typedef BOOL (__stdcall *CEP_ASSEMBLER) (UINT_PTR address, char* instruction, BYTE *output, int maxlength, int *returnedsize);
typedef BOOL (__stdcall *CEP_DISASSEMBLER) (UINT_PTR address, char* output, int maxsize);
typedef BOOL (__stdcall *CEP_CHANGEREGATADDRESS) (UINT_PTR address,PREGISTERMODIFICATIONINFO changereg);
typedef BOOL (__stdcall *CEP_INJECTDLL) (char *dllname, char *functiontocall);
typedef int (__stdcall *CEP_FREEZEMEM) (UINT_PTR address, int size);
typedef BOOL (__stdcall *CEP_UNFREEZEMEM) (int freezeID);
typedef BOOL (__stdcall *CEP_FIXMEM) (void);
typedef BOOL (__stdcall *CEP_PROCESSLIST) (char *listbuffer, int listsize);
typedef BOOL (__stdcall *CEP_RELOADSETTINGS) (void);
typedef UINT_PTR (__stdcall *CEP_GETADDRESSFROMPOINTER) (UINT_PTR baseaddress, int offsetcount, int* offsets);  
typedef BOOL (__stdcall *CEP_GENERATEAPIHOOKSCRIPT) (char *address, char *addresstojumpto, char *addresstogetnewcalladdress, char *script, int maxscriptsize);
typedef BOOL (__stdcall *CEP_ADDRESSTONAME) (UINT_PTR address, char *name, int maxnamesize);
typedef BOOL (__stdcall *CEP_NAMETOADDRESS) (char *name, UINT_PTR *address);

typedef VOID (__stdcall *CEP_LOADDBK32)(void);
typedef BOOL (__stdcall *CEP_LOADDBVMIFNEEDED)(void);
typedef DWORD (__stdcall *CEP_PREVIOUSOPCODE)(UINT_PTR address);
typedef DWORD (__stdcall *CEP_NEXTOPCODE)(UINT_PTR address);
typedef BOOL (__stdcall *CEP_LOADMODULE)(char *modulepath, char *exportlist, int *maxsize);
typedef BOOL (__stdcall *CEP_DISASSEMBLEEX)(UINT_PTR address, char *output, int maxsize);
typedef VOID (__stdcall *CEP_AA_ADDCOMMAND)(char *command);
typedef VOID (__stdcall *CEP_AA_DELCOMMAND)(char *command);

typedef PVOID (__stdcall *CEP_CREATETABLEENTRY)(void);
typedef PVOID (__stdcall *CEP_GETTABLEENTRY)(char *description);
typedef BOOL (__stdcall *CEP_MEMREC_SETDESCRIPTION)(PVOID memrec, char *description);
typedef PCHAR (__stdcall *CEP_MEMREC_GETDESCRIPTION)(PVOID memrec);
typedef BOOL (__stdcall *CEP_MEMREC_GETADDRESS)(PVOID memrec, UINT_PTR *address, DWORD *offsets, int maxoffsets, int *neededOffsets);
typedef BOOL (__stdcall *CEP_MEMREC_SETADDRESS)(PVOID memrec, char *address, DWORD *offsets, int offsetcount);
typedef int (__stdcall *CEP_MEMREC_GETTYPE)(PVOID memrec);
typedef BOOL (__stdcall *CEP_MEMREC_SETTYPE)(PVOID memrec, int vtype);
typedef BOOL (__stdcall *CEP_MEMREC_GETVALUETYPE)(PVOID memrec, char *value, int maxsize);
typedef BOOL (__stdcall *CEP_MEMREC_SETVALUETYPE)(PVOID memrec, char *value);
typedef char* (__stdcall *CEP_MEMREC_GETSCRIPT)(PVOID memrec);
typedef BOOL (__stdcall *CEP_MEMREC_SETSCRIPT)(PVOID memrec, char *script);
typedef BOOL (__stdcall *CEP_MEMREC_ISFROZEN)(PVOID memrec);
typedef BOOL (__stdcall *CEP_MEMREC_FREEZE)(PVOID memrec, int direction);
typedef BOOL (__stdcall *CEP_MEMREC_UNFREEZE)(PVOID memrec);
typedef BOOL (__stdcall *CEP_MEMREC_SETCOLOR)(PVOID memrec, DWORD color);
typedef BOOL (__stdcall *CEP_MEMREC_APPENDTOENTRY)(PVOID memrec1, PVOID memrec2);
typedef BOOL (__stdcall *CEP_MEMREC_DELETE)(PVOID memrec);

typedef DWORD (__stdcall *CEP_GETPROCESSIDFROMPROCESSNAME)(char *name);
typedef DWORD (__stdcall *CEP_OPENPROCESS)(DWORD pid);
typedef DWORD (__stdcall *CEP_DEBUGPROCESS)(int debuggerinterface);
typedef VOID (__stdcall *CEP_PAUSE)(void);
typedef VOID (__stdcall *CEP_UNPAUSE)(void);
typedef BOOL (__stdcall *CEP_DEBUG_SETBREAKPOINT)(UINT_PTR address, int size, int trigger);
typedef BOOL (__stdcall *CEP_DEBUG_REMOVEBREAKPOINT)(UINT_PTR address);
typedef BOOL (__stdcall *CEP_DEBUG_CONTINUEFROMBREAKPOINT)(int continueoption);

typedef VOID (__stdcall *CEP_CLOSECE)(void);
typedef VOID (__stdcall *CEP_HIDEALLCEWINDOWS)(void);
typedef VOID (__stdcall *CEP_UNHIDEMAINCEWINDOW)(void);

typedef PVOID (__stdcall *CEP_CREATEFORM)(void);
typedef void (__stdcall *CEP_FORM_CENTERSCREEN)(PVOID form);
typedef void (__stdcall *CEP_FORM_HIDE)(PVOID form);
typedef void (__stdcall *CEP_FORM_SHOW)(PVOID form);
typedef void (__stdcall *CEP_FORM_ONCLOSE)(PVOID form, PVOID function);

typedef PVOID (__stdcall *CEP_CREATEPANEL)(PVOID owner);
typedef PVOID (__stdcall *CEP_CREATEGROUPBOX)(PVOID owner);
typedef PVOID (__stdcall *CEP_CREATEBUTTON)(PVOID owner);
typedef PVOID (__stdcall *CEP_CREATEIMAGE)(PVOID owner);

typedef BOOL (__stdcall *CEP_IMAGE_LOADIMAGEFROMFILE)(PVOID image, char *filename);
typedef VOID (__stdcall *CEP_IMAGE_TRANSPARENT)(PVOID image, BOOL transparent);
typedef VOID (__stdcall *CEP_IMAGE_STRETCH)(PVOID image, BOOL stretch);

typedef PVOID (__stdcall *CEP_CREATELABEL)(PVOID owner);
typedef PVOID (__stdcall *CEP_CREATEEDIT)(PVOID owner);
typedef PVOID (__stdcall *CEP_CREATEMEMO)(PVOID owner);
typedef PVOID (__stdcall *CEP_CREATETIMER)(PVOID owner);

typedef VOID (__stdcall *CEP_TIMER_SETINTERVAL)(PVOID timer, int interval);
typedef VOID (__stdcall *CEP_TIMER_ONTIMER)(PVOID timer, PVOID function);

typedef VOID (__stdcall *CEP_CONTROL_SETCAPTION)(PVOID control, char *caption);
typedef BOOL (__stdcall *CEP_CONTROL_GETCAPTION)(PVOID control, char *caption, int maxsize);

typedef VOID (__stdcall *CEP_CONTROL_SETPOSITION)(PVOID control, int x, int y);
typedef int (__stdcall *CEP_CONTROL_GETX)(PVOID control);
typedef int (__stdcall *CEP_CONTROL_GETY)(PVOID control);

typedef VOID (__stdcall *CEP_CONTROL_SETSIZE)(PVOID control, int width, int height);
typedef int (__stdcall *CEP_CONTROL_GETWIDTH)(PVOID control);
typedef int (__stdcall *CEP_CONTROL_GETHEIGHT)(PVOID control);

typedef VOID (__stdcall *CEP_CONTROL_SETALIGN)(PVOID control, int align);
typedef VOID (__stdcall *CEP_CONTROL_ONCLICK)(PVOID control, PVOID function);

typedef VOID (__stdcall *CEP_OBJECT_DESTROY)(PVOID object);

typedef int (__stdcall *CEP_MESSAGEDIALOG)(char *massage, int messagetype, int buttoncombination);
typedef BOOL (__stdcall *CEP_SPEEDHACK_SETSPEED)(float speed);
typedef lua_State *(__fastcall *CEP_GETLUASTATE)();


typedef BOOL(__stdcall **CEP_READPROCESSMEMORY)(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T * lpNumberOfBytesRead);

/*
function ce_messageDialog(message: pchar; messagetype: integer; buttoncombination: integer): integer; stdcall;
function ce_speedhack_setSpeed(speed: single): BOOL; stdcall;       
*/

typedef struct _ExportedFunctions
{
  int sizeofExportedFunctions;
  CEP_SHOWMESSAGE ShowMessage; //Pointer to the ce showmessage function
  CEP_REGISTERFUNCTION RegisterFunction; //Use this to register a specific type of plugin
  CEP_UNREGISTERFUNCTION UnregisterFunction; //unregisters a function registered with registerfunction
  PULONG OpenedProcessID; //pointer to the currently selected processid
  PHANDLE OpenedProcessHandle; //pointer to the currently selected processhandle

  CEP_GETMAINWINDOWHANDLE GetMainWindowHandle; //returns the handle of the main window (for whatever reason, it is recommended to use delphi to make a real userinterface upgrade)
  CEP_AUTOASSEMBLE AutoAssemble; //Pointer to the AutoAssemble function
  CEP_ASSEMBLER Assembler; //pointer to the assembler function
  CEP_DISASSEMBLER Disassembler; //pointer to the disassembler function
  CEP_CHANGEREGATADDRESS ChangeRegistersAtAddress; //pointer to the ChangeRegAtBP function
  CEP_INJECTDLL InjectDLL; //pointer to ce's Inject DLL function
  CEP_FREEZEMEM FreezeMem; //pointer to the FreezeMem routine
  CEP_UNFREEZEMEM UnfreezeMem; //pointer to the UnfreezeMem routine (use this to undo freezes with FreezeMem)
  CEP_FIXMEM FixMem; //pointer to the fixmem routine
  CEP_PROCESSLIST ProcessList; //pointer to the processlist routine
  CEP_RELOADSETTINGS ReloadSettings; //pointer to the ReloadSettings routine
  CEP_GETADDRESSFROMPOINTER GetAddressFromPointer; //pointer to the GetAddressFromPointer routine

  //pointers to the address that contains the pointers to the functions
  //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  CEP_READPROCESSMEMORY ReadProcessMemory;			//pointer to the pointer of ReadProcessMemory (Change it to hook that api, or use it yourself)
  PVOID WriteProcessMemory;			//pointer to the pointer of WriteProcessMemory (Change it to hook that api, or use it yourself)
  PVOID GetThreadContext;			//   ...
  PVOID SetThreadContext;			//   ...
  PVOID SuspendThread;				//   ...
  PVOID ResumeThread;				//   ...
  PVOID OpenProcess;				//   ...
  PVOID WaitForDebugEvent;			//   ...
  PVOID ContinueDebugEvent;			//   ...
  PVOID DebugActiveProcess;			//   ...
  PVOID StopDebugging;				//   ...
  PVOID StopRegisterChange;			//   ...
  PVOID VirtualProtect;				//   ...
  PVOID VirtualProtectEx;			//   ...
  PVOID VirtualQueryEx;				//   ...
  PVOID VirtualAllocEx;				//   ...
  PVOID CreateRemoteThread;			//   ...
  PVOID OpenThread;					//   ...
  PVOID GetPEProcess;				//   ...
  PVOID GetPEThread;				//   ...
  PVOID GetThreadsProcessOffset;	//   ...
  PVOID GetThreadListEntryOffset;	//   ...
  PVOID GetProcessnameOffset;		//   ...
  PVOID GetDebugportOffset;			//   ...
  PVOID GetPhysicalAddress;			//   ...
  PVOID ProtectMe;					//   ...
  PVOID GetCR4;						//   ...
  PVOID GetCR3;						//   ...
  PVOID SetCR3;						//   ...
  PVOID GetSDT;						//   ...
  PVOID GetSDTShadow;				//   ...
  PVOID setAlternateDebugMethod;	//   ...
  PVOID getAlternateDebugMethod;	//   ...
  PVOID DebugProcess;				//   ...
  PVOID ChangeRegOnBP;				//   ...
  PVOID RetrieveDebugData;			//   ...
  PVOID StartProcessWatch;			//   ...
  PVOID WaitForProcessListData;		//   ...
  PVOID GetProcessNameFromID;		//   ...
  PVOID GetProcessNameFromPEProcess;//   ...
  PVOID KernelOpenProcess;			//   ...
  PVOID KernelReadProcessMemory;	//   ...
  PVOID KernelWriteProcessMemory;	//   ...
  PVOID KernelVirtualAllocEx;		//   ...
  PVOID IsValidHandle;				//   ...
  PVOID GetIDTCurrentThread;		//   ...
  PVOID GetIDTs;					//   ...
  PVOID MakeWritable;				//   ...
  PVOID GetLoadedState;				//   ...
  PVOID DBKSuspendThread;			//   ...
  PVOID DBKResumeThread;			//   ...
  PVOID DBKSuspendProcess;			//   ...
  PVOID DBKResumeProcess;			//   ...
  PVOID KernelAlloc;				//   ...
  PVOID GetKProcAddress;			//   ...
  PVOID CreateToolhelp32Snapshot;	//   ...
  PVOID Process32First;          	//   ...
  PVOID Process32Next;           	//   ...
  PVOID Thread32First;           	//   ...
  PVOID Thread32Next;            	//   ...
  PVOID Module32First;           	//   ...
  PVOID Module32Next;            	//   ...
  PVOID Heap32ListFirst;         	//   ...
  PVOID Heap32ListNext;          	//   ...
  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  //advanced for delphi 7 enterprise dll programmers only
  PVOID mainform; //pointer to the Tmainform object.
  PVOID memorybrowser; //pointer to the TMemoryBrowser object (memory view windows), same as mainform

  //Plugin Version 2+
  CEP_NAMETOADDRESS sym_nameToAddress;
  CEP_ADDRESSTONAME sym_addressToName;
  CEP_GENERATEAPIHOOKSCRIPT sym_generateAPIHookScript;

  //Plugin version 3+
  CEP_LOADDBK32 loadDBK32;
  CEP_LOADDBVMIFNEEDED loaddbvmifneeded;
  CEP_PREVIOUSOPCODE previousOpcode;
  CEP_NEXTOPCODE nextOpcode;
  CEP_DISASSEMBLEEX disassembleEx;
  CEP_LOADMODULE loadModule;
  CEP_AA_ADDCOMMAND aa_AddExtraCommand;
  CEP_AA_DELCOMMAND aa_RemoveExtraCommand;

  //version 4 extension
  CEP_CREATETABLEENTRY createTableEntry;
  CEP_GETTABLEENTRY getTableEntry;
  CEP_MEMREC_SETDESCRIPTION memrec_setDescription;
  CEP_MEMREC_GETDESCRIPTION memrec_getDescription;
  CEP_MEMREC_GETADDRESS memrec_getAddress;
  CEP_MEMREC_SETADDRESS memrec_setAddress;
  CEP_MEMREC_GETTYPE memrec_getType;
  CEP_MEMREC_SETTYPE memrec_setType;
  CEP_MEMREC_GETVALUETYPE memrec_getValue;
  CEP_MEMREC_SETVALUETYPE memrec_setValue;
  CEP_MEMREC_GETSCRIPT memrec_getScript;
  CEP_MEMREC_SETSCRIPT memrec_setScript;
  CEP_MEMREC_ISFROZEN memrec_isfrozen;
  CEP_MEMREC_FREEZE memrec_freeze;
  CEP_MEMREC_UNFREEZE memrec_unfreeze;
  CEP_MEMREC_SETCOLOR memrec_setColor;
  CEP_MEMREC_APPENDTOENTRY memrec_appendtoentry;
  CEP_MEMREC_DELETE memrec_delete;

  CEP_GETPROCESSIDFROMPROCESSNAME getProcessIDFromProcessName;
  CEP_OPENPROCESS openProcessEx;
  CEP_DEBUGPROCESS debugProcessEx;
  CEP_PAUSE pause;
  CEP_UNPAUSE unpause;

  CEP_DEBUG_SETBREAKPOINT debug_setBreakpoint;
  CEP_DEBUG_REMOVEBREAKPOINT debug_removeBreakpoint;
  CEP_DEBUG_CONTINUEFROMBREAKPOINT debug_continueFromBreakpoint;

  CEP_CLOSECE closeCE;
  CEP_HIDEALLCEWINDOWS hideAllCEWindows;
  CEP_UNHIDEMAINCEWINDOW unhideMainCEwindow;
  CEP_CREATEFORM createForm;
  CEP_FORM_CENTERSCREEN form_centerScreen;
  CEP_FORM_HIDE form_hide;
  CEP_FORM_SHOW form_show;
  CEP_FORM_ONCLOSE form_onClose;

  CEP_CREATEPANEL createPanel;
  CEP_CREATEGROUPBOX createGroupBox;
  CEP_CREATEBUTTON createButton;
  CEP_CREATEIMAGE createImage;
  CEP_IMAGE_LOADIMAGEFROMFILE image_loadImageFromFile;
  CEP_IMAGE_TRANSPARENT image_transparent;
  CEP_IMAGE_STRETCH image_stretch;

  CEP_CREATELABEL createLabel;
  CEP_CREATEEDIT createEdit;
  CEP_CREATEMEMO createMemo;
  CEP_CREATETIMER createTimer;
  CEP_TIMER_SETINTERVAL timer_setInterval;
  CEP_TIMER_ONTIMER timer_onTimer;
  CEP_CONTROL_SETCAPTION control_setCaption;
  CEP_CONTROL_GETCAPTION control_getCaption;
  CEP_CONTROL_SETPOSITION control_setPosition;
  CEP_CONTROL_GETX control_getX;
  CEP_CONTROL_GETY control_getY;
  CEP_CONTROL_SETSIZE control_setSize;
  CEP_CONTROL_GETWIDTH control_getWidth;
  CEP_CONTROL_GETHEIGHT control_getHeight;
  CEP_CONTROL_SETALIGN control_setAlign;
  CEP_CONTROL_ONCLICK control_onClick;

  CEP_OBJECT_DESTROY object_destroy;
  CEP_MESSAGEDIALOG messageDialog;
  CEP_SPEEDHACK_SETSPEED speedhack_setSpeed;  

//V5: Todo, implement function declarations
  VOID *ExecuteKernelCode;
  VOID *UserdefinedInterruptHook;
  CEP_GETLUASTATE GetLuaState;
  VOID *MainThreadCall;

} ExportedFunctions, *PExportedFunctions;


BOOL __stdcall CEPlugin_GetVersion(PPluginVersion pv , int sizeofpluginversion);
BOOL __stdcall CEPlugin_InitializePlugin(PExportedFunctions ef , int pluginid);
BOOL __stdcall CEPlugin_DisablePlugin(void);
//old versions without CEPlugin_ in front also work but are not recommended due to bugbrained compilers...


#endif //CEPLUGINSDK_H

```

`plugin/ios_rtti/ce_sdk/lauxlib.h`:

```h
/*
** $Id: lauxlib.h,v 1.128 2014/10/29 16:11:17 roberto Exp $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/


#ifndef lauxlib_h
#define lauxlib_h


#include <stddef.h>
#include <stdio.h>

#include "lua.h"



/* extra error code for 'luaL_load' */
#define LUA_ERRFILE     (LUA_ERRERR+1)


typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;


#define LUAL_NUMSIZES	(sizeof(lua_Integer)*16 + sizeof(lua_Number))

LUALIB_API void (luaL_checkversion_) (lua_State *L, lua_Number ver, size_t sz);
#define luaL_checkversion(L)  \
	  luaL_checkversion_(L, LUA_VERSION_NUM, LUAL_NUMSIZES)

LUALIB_API int (luaL_getmetafield) (lua_State *L, int obj, const char *e);
LUALIB_API int (luaL_callmeta) (lua_State *L, int obj, const char *e);
LUALIB_API const char *(luaL_tolstring) (lua_State *L, int idx, size_t *len);
LUALIB_API int (luaL_argerror) (lua_State *L, int arg, const char *extramsg);
LUALIB_API const char *(luaL_checklstring) (lua_State *L, int arg,
                                                          size_t *l);
LUALIB_API const char *(luaL_optlstring) (lua_State *L, int arg,
                                          const char *def, size_t *l);
LUALIB_API lua_Number (luaL_checknumber) (lua_State *L, int arg);
LUALIB_API lua_Number (luaL_optnumber) (lua_State *L, int arg, lua_Number def);

LUALIB_API lua_Integer (luaL_checkinteger) (lua_State *L, int arg);
LUALIB_API lua_Integer (luaL_optinteger) (lua_State *L, int arg,
                                          lua_Integer def);

LUALIB_API void (luaL_checkstack) (lua_State *L, int sz, const char *msg);
LUALIB_API void (luaL_checktype) (lua_State *L, int arg, int t);
LUALIB_API void (luaL_checkany) (lua_State *L, int arg);

LUALIB_API int   (luaL_newmetatable) (lua_State *L, const char *tname);
LUALIB_API void  (luaL_setmetatable) (lua_State *L, const char *tname);
LUALIB_API void *(luaL_testudata) (lua_State *L, int ud, const char *tname);
LUALIB_API void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);

LUALIB_API void (luaL_where) (lua_State *L, int lvl);
LUALIB_API int (luaL_error) (lua_State *L, const char *fmt, ...);

LUALIB_API int (luaL_checkoption) (lua_State *L, int arg, const char *def,
                                   const char *const lst[]);

LUALIB_API int (luaL_fileresult) (lua_State *L, int stat, const char *fname);
LUALIB_API int (luaL_execresult) (lua_State *L, int stat);

/* pre-defined references */
#define LUA_NOREF       (-2)
#define LUA_REFNIL      (-1)

LUALIB_API int (luaL_ref) (lua_State *L, int t);
LUALIB_API void (luaL_unref) (lua_State *L, int t, int ref);

LUALIB_API int (luaL_loadfilex) (lua_State *L, const char *filename,
                                               const char *mode);

#define luaL_loadfile(L,f)	luaL_loadfilex(L,f,NULL)

LUALIB_API int (luaL_loadbufferx) (lua_State *L, const char *buff, size_t sz,
                                   const char *name, const char *mode);
LUALIB_API int (luaL_loadstring) (lua_State *L, const char *s);

LUALIB_API lua_State *(luaL_newstate) (void);

LUALIB_API lua_Integer (luaL_len) (lua_State *L, int idx);

LUALIB_API const char *(luaL_gsub) (lua_State *L, const char *s, const char *p,
                                                  const char *r);

LUALIB_API void (luaL_setfuncs) (lua_State *L, const luaL_Reg *l, int nup);

LUALIB_API int (luaL_getsubtable) (lua_State *L, int idx, const char *fname);

LUALIB_API void (luaL_traceback) (lua_State *L, lua_State *L1,
                                  const char *msg, int level);

LUALIB_API void (luaL_requiref) (lua_State *L, const char *modname,
                                 lua_CFunction openf, int glb);

/*
** ===============================================================
** some useful macros
** ===============================================================
*/


#define luaL_newlibtable(L,l)	\
  lua_createtable(L, 0, sizeof(l)/sizeof((l)[0]) - 1)

#define luaL_newlib(L,l)  \
  (luaL_checkversion(L), luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))

#define luaL_argcheck(L, cond,arg,extramsg)	\
		((void)((cond) || luaL_argerror(L, (arg), (extramsg))))
#define luaL_checkstring(L,n)	(luaL_checklstring(L, (n), NULL))
#define luaL_optstring(L,n,d)	(luaL_optlstring(L, (n), (d), NULL))

#define luaL_typename(L,i)	lua_typename(L, lua_type(L,(i)))

#define luaL_dofile(L, fn) \
	(luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))

#define luaL_dostring(L, s) \
	(luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))

#define luaL_getmetatable(L,n)	(lua_getfield(L, LUA_REGISTRYINDEX, (n)))

#define luaL_opt(L,f,n,d)	(lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))

#define luaL_loadbuffer(L,s,sz,n)	luaL_loadbufferx(L,s,sz,n,NULL)


/*
** {======================================================
** Generic Buffer manipulation
** =======================================================
*/

typedef struct luaL_Buffer {
  char *b;  /* buffer address */
  size_t size;  /* buffer size */
  size_t n;  /* number of characters in buffer */
  lua_State *L;
  char initb[LUAL_BUFFERSIZE];  /* initial buffer */
} luaL_Buffer;


#define luaL_addchar(B,c) \
  ((void)((B)->n < (B)->size || luaL_prepbuffsize((B), 1)), \
   ((B)->b[(B)->n++] = (c)))

#define luaL_addsize(B,s)	((B)->n += (s))

LUALIB_API void (luaL_buffinit) (lua_State *L, luaL_Buffer *B);
LUALIB_API char *(luaL_prepbuffsize) (luaL_Buffer *B, size_t sz);
LUALIB_API void (luaL_addlstring) (luaL_Buffer *B, const char *s, size_t l);
LUALIB_API void (luaL_addstring) (luaL_Buffer *B, const char *s);
LUALIB_API void (luaL_addvalue) (luaL_Buffer *B);
LUALIB_API void (luaL_pushresult) (luaL_Buffer *B);
LUALIB_API void (luaL_pushresultsize) (luaL_Buffer *B, size_t sz);
LUALIB_API char *(luaL_buffinitsize) (lua_State *L, luaL_Buffer *B, size_t sz);

#define luaL_prepbuffer(B)	luaL_prepbuffsize(B, LUAL_BUFFERSIZE)

/* }====================================================== */



/*
** {======================================================
** File handles for IO library
** =======================================================
*/

/*
** A file handle is a userdata with metatable 'LUA_FILEHANDLE' and
** initial structure 'luaL_Stream' (it may contain other fields
** after that initial structure).
*/

#define LUA_FILEHANDLE          "FILE*"


typedef struct luaL_Stream {
  FILE *f;  /* stream (NULL for incompletely created streams) */
  lua_CFunction closef;  /* to close stream (NULL for closed streams) */
} luaL_Stream;

/* }====================================================== */



/* compatibility with old module system */
#if defined(LUA_COMPAT_MODULE)

LUALIB_API void (luaL_pushmodule) (lua_State *L, const char *modname,
                                   int sizehint);
LUALIB_API void (luaL_openlib) (lua_State *L, const char *libname,
                                const luaL_Reg *l, int nup);

#define luaL_register(L,n,l)	(luaL_openlib(L,(n),(l),0))

#endif


/*
** {==================================================================
** "Abstraction Layer" for basic report of messages and errors
** ===================================================================
*/

/* print a string */
#if !defined(lua_writestring)
#define lua_writestring(s,l)   fwrite((s), sizeof(char), (l), stdout)
#endif

/* print a newline and flush the output */
#if !defined(lua_writeline)
#define lua_writeline()        (lua_writestring("\n", 1), fflush(stdout))
#endif

/* print an error message */
#if !defined(lua_writestringerror)
#define lua_writestringerror(s,p) \
        (fprintf(stderr, (s), (p)), fflush(stderr))
#endif

/* }================================================================== */


/*
** {============================================================
** Compatibility with deprecated conversions
** =============================================================
*/
#if defined(LUA_COMPAT_APIINTCASTS)

#define luaL_checkunsigned(L,a)	((lua_Unsigned)luaL_checkinteger(L,a))
#define luaL_optunsigned(L,a,d)	\
	((lua_Unsigned)luaL_optinteger(L,a,(lua_Integer)(d)))

#define luaL_checkint(L,n)	((int)luaL_checkinteger(L, (n)))
#define luaL_optint(L,n,d)	((int)luaL_optinteger(L, (n), (d)))

#define luaL_checklong(L,n)	((long)luaL_checkinteger(L, (n)))
#define luaL_optlong(L,n,d)	((long)luaL_optinteger(L, (n), (d)))

#endif
/* }============================================================ */



#endif



```

`plugin/ios_rtti/ce_sdk/lua.h`:

```h
/*
** $Id: lua.h,v 1.325 2014/12/26 17:24:27 roberto Exp $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/


#ifndef lua_h
#define lua_h

#include <stdarg.h>
#include <stddef.h>


#include "luaconf.h"


#define LUA_VERSION_MAJOR	"5"
#define LUA_VERSION_MINOR	"3"
#define LUA_VERSION_NUM		503
#define LUA_VERSION_RELEASE	"0"

#define LUA_VERSION	"Lua " LUA_VERSION_MAJOR "." LUA_VERSION_MINOR
#define LUA_RELEASE	LUA_VERSION "." LUA_VERSION_RELEASE
#define LUA_COPYRIGHT	LUA_RELEASE "  Copyright (C) 1994-2015 Lua.org, PUC-Rio"
#define LUA_AUTHORS	"R. Ierusalimschy, L. H. de Figueiredo, W. Celes"


/* mark for precompiled code ('<esc>Lua') */
#define LUA_SIGNATURE	"\x1bLua"

/* option for multiple returns in 'lua_pcall' and 'lua_call' */
#define LUA_MULTRET	(-1)


/*
** pseudo-indices
*/
#define LUA_REGISTRYINDEX	LUAI_FIRSTPSEUDOIDX
#define lua_upvalueindex(i)	(LUA_REGISTRYINDEX - (i))


/* thread status */
#define LUA_OK		0
#define LUA_YIELD	1
#define LUA_ERRRUN	2
#define LUA_ERRSYNTAX	3
#define LUA_ERRMEM	4
#define LUA_ERRGCMM	5
#define LUA_ERRERR	6


typedef struct lua_State lua_State;


/*
** basic types
*/
#define LUA_TNONE		(-1)

#define LUA_TNIL		0
#define LUA_TBOOLEAN		1
#define LUA_TLIGHTUSERDATA	2
#define LUA_TNUMBER		3
#define LUA_TSTRING		4
#define LUA_TTABLE		5
#define LUA_TFUNCTION		6
#define LUA_TUSERDATA		7
#define LUA_TTHREAD		8

#define LUA_NUMTAGS		9



/* minimum Lua stack available to a C function */
#define LUA_MINSTACK	20


/* predefined values in the registry */
#define LUA_RIDX_MAINTHREAD	1
#define LUA_RIDX_GLOBALS	2
#define LUA_RIDX_LAST		LUA_RIDX_GLOBALS


/* type of numbers in Lua */
typedef LUA_NUMBER lua_Number;


/* type for integer functions */
typedef LUA_INTEGER lua_Integer;

/* unsigned integer type */
typedef LUA_UNSIGNED lua_Unsigned;

/* type for continuation-function contexts */
typedef LUA_KCONTEXT lua_KContext;


/*
** Type for C functions registered with Lua
*/
typedef int (*lua_CFunction) (lua_State *L);

/*
** Type for continuation functions
*/
typedef int (*lua_KFunction) (lua_State *L, int status, lua_KContext ctx);


/*
** Type for functions that read/write blocks when loading/dumping Lua chunks
*/
typedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);

typedef int (*lua_Writer) (lua_State *L, const void *p, size_t sz, void *ud);


/*
** Type for memory-allocation functions
*/
typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);



/*
** generic extra include file
*/
#if defined(LUA_USER_H)
#include LUA_USER_H
#endif


/*
** RCS ident string
*/
extern const char lua_ident[];


/*
** state manipulation
*/
LUA_API lua_State *(lua_newstate) (lua_Alloc f, void *ud);
LUA_API void       (lua_close) (lua_State *L);
LUA_API lua_State *(lua_newthread) (lua_State *L);

LUA_API lua_CFunction (lua_atpanic) (lua_State *L, lua_CFunction panicf);


LUA_API const lua_Number *(lua_version) (lua_State *L);


/*
** basic stack manipulation
*/
LUA_API int   (lua_absindex) (lua_State *L, int idx);
LUA_API int   (lua_gettop) (lua_State *L);
LUA_API void  (lua_settop) (lua_State *L, int idx);
LUA_API void  (lua_pushvalue) (lua_State *L, int idx);
LUA_API void  (lua_rotate) (lua_State *L, int idx, int n);
LUA_API void  (lua_copy) (lua_State *L, int fromidx, int toidx);
LUA_API int   (lua_checkstack) (lua_State *L, int n);

LUA_API void  (lua_xmove) (lua_State *from, lua_State *to, int n);


/*
** access functions (stack -> C)
*/

LUA_API int             (lua_isnumber) (lua_State *L, int idx);
LUA_API int             (lua_isstring) (lua_State *L, int idx);
LUA_API int             (lua_iscfunction) (lua_State *L, int idx);
LUA_API int             (lua_isinteger) (lua_State *L, int idx);
LUA_API int             (lua_isuserdata) (lua_State *L, int idx);
LUA_API int             (lua_type) (lua_State *L, int idx);
LUA_API const char     *(lua_typename) (lua_State *L, int tp);

LUA_API lua_Number      (lua_tonumberx) (lua_State *L, int idx, int *isnum);
LUA_API lua_Integer     (lua_tointegerx) (lua_State *L, int idx, int *isnum);
LUA_API int             (lua_toboolean) (lua_State *L, int idx);
LUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);
LUA_API size_t          (lua_rawlen) (lua_State *L, int idx);
LUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);
LUA_API void	       *(lua_touserdata) (lua_State *L, int idx);
LUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);
LUA_API const void     *(lua_topointer) (lua_State *L, int idx);


/*
** Comparison and arithmetic functions
*/

#define LUA_OPADD	0	/* ORDER TM, ORDER OP */
#define LUA_OPSUB	1
#define LUA_OPMUL	2
#define LUA_OPMOD	3
#define LUA_OPPOW	4
#define LUA_OPDIV	5
#define LUA_OPIDIV	6
#define LUA_OPBAND	7
#define LUA_OPBOR	8
#define LUA_OPBXOR	9
#define LUA_OPSHL	10
#define LUA_OPSHR	11
#define LUA_OPUNM	12
#define LUA_OPBNOT	13

LUA_API void  (lua_arith) (lua_State *L, int op);

#define LUA_OPEQ	0
#define LUA_OPLT	1
#define LUA_OPLE	2

LUA_API int   (lua_rawequal) (lua_State *L, int idx1, int idx2);
LUA_API int   (lua_compare) (lua_State *L, int idx1, int idx2, int op);


/*
** push functions (C -> stack)
*/
LUA_API void        (lua_pushnil) (lua_State *L);
LUA_API void        (lua_pushnumber) (lua_State *L, lua_Number n);
LUA_API void        (lua_pushinteger) (lua_State *L, lua_Integer n);
LUA_API const char *(lua_pushlstring) (lua_State *L, const char *s, size_t len);
LUA_API const char *(lua_pushstring) (lua_State *L, const char *s);
LUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt,
                                                      va_list argp);
LUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...);
LUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);
LUA_API void  (lua_pushboolean) (lua_State *L, int b);
LUA_API void  (lua_pushlightuserdata) (lua_State *L, void *p);
LUA_API int   (lua_pushthread) (lua_State *L);


/*
** get functions (Lua -> stack)
*/
LUA_API int (lua_getglobal) (lua_State *L, const char *name);
LUA_API int (lua_gettable) (lua_State *L, int idx);
LUA_API int (lua_getfield) (lua_State *L, int idx, const char *k);
LUA_API int (lua_geti) (lua_State *L, int idx, lua_Integer n);
LUA_API int (lua_rawget) (lua_State *L, int idx);
LUA_API int (lua_rawgeti) (lua_State *L, int idx, lua_Integer n);
LUA_API int (lua_rawgetp) (lua_State *L, int idx, const void *p);

LUA_API void  (lua_createtable) (lua_State *L, int narr, int nrec);
LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz);
LUA_API int   (lua_getmetatable) (lua_State *L, int objindex);
LUA_API int  (lua_getuservalue) (lua_State *L, int idx);


/*
** set functions (stack -> Lua)
*/
LUA_API void  (lua_setglobal) (lua_State *L, const char *name);
LUA_API void  (lua_settable) (lua_State *L, int idx);
LUA_API void  (lua_setfield) (lua_State *L, int idx, const char *k);
LUA_API void  (lua_seti) (lua_State *L, int idx, lua_Integer n);
LUA_API void  (lua_rawset) (lua_State *L, int idx);
LUA_API void  (lua_rawseti) (lua_State *L, int idx, lua_Integer n);
LUA_API void  (lua_rawsetp) (lua_State *L, int idx, const void *p);
LUA_API int   (lua_setmetatable) (lua_State *L, int objindex);
LUA_API void  (lua_setuservalue) (lua_State *L, int idx);


/*
** 'load' and 'call' functions (load and run Lua code)
*/
LUA_API void  (lua_callk) (lua_State *L, int nargs, int nresults,
                           lua_KContext ctx, lua_KFunction k);
#define lua_call(L,n,r)		lua_callk(L, (n), (r), 0, NULL)

LUA_API int   (lua_pcallk) (lua_State *L, int nargs, int nresults, int errfunc,
                            lua_KContext ctx, lua_KFunction k);
#define lua_pcall(L,n,r,f)	lua_pcallk(L, (n), (r), (f), 0, NULL)

LUA_API int   (lua_load) (lua_State *L, lua_Reader reader, void *dt,
                          const char *chunkname, const char *mode);

LUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data, int strip);


/*
** coroutine functions
*/
LUA_API int  (lua_yieldk)     (lua_State *L, int nresults, lua_KContext ctx,
                               lua_KFunction k);
LUA_API int  (lua_resume)     (lua_State *L, lua_State *from, int narg);
LUA_API int  (lua_status)     (lua_State *L);
LUA_API int (lua_isyieldable) (lua_State *L);

#define lua_yield(L,n)		lua_yieldk(L, (n), 0, NULL)


/*
** garbage-collection function and options
*/

#define LUA_GCSTOP		0
#define LUA_GCRESTART		1
#define LUA_GCCOLLECT		2
#define LUA_GCCOUNT		3
#define LUA_GCCOUNTB		4
#define LUA_GCSTEP		5
#define LUA_GCSETPAUSE		6
#define LUA_GCSETSTEPMUL	7
#define LUA_GCISRUNNING		9

LUA_API int (lua_gc) (lua_State *L, int what, int data);


/*
** miscellaneous functions
*/

LUA_API int   (lua_error) (lua_State *L);

LUA_API int   (lua_next) (lua_State *L, int idx);

LUA_API void  (lua_concat) (lua_State *L, int n);
LUA_API void  (lua_len)    (lua_State *L, int idx);

LUA_API size_t   (lua_stringtonumber) (lua_State *L, const char *s);

LUA_API lua_Alloc (lua_getallocf) (lua_State *L, void **ud);
LUA_API void      (lua_setallocf) (lua_State *L, lua_Alloc f, void *ud);



/*
** {==============================================================
** some useful macros
** ===============================================================
*/

#define lua_getextraspace(L)	((void *)((char *)(L) - LUA_EXTRASPACE))

#define lua_tonumber(L,i)	lua_tonumberx(L,(i),NULL)
#define lua_tointeger(L,i)	lua_tointegerx(L,(i),NULL)

#define lua_pop(L,n)		lua_settop(L, -(n)-1)

#define lua_newtable(L)		lua_createtable(L, 0, 0)

#define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))

#define lua_pushcfunction(L,f)	lua_pushcclosure(L, (f), 0)

#define lua_isfunction(L,n)	(lua_type(L, (n)) == LUA_TFUNCTION)
#define lua_istable(L,n)	(lua_type(L, (n)) == LUA_TTABLE)
#define lua_islightuserdata(L,n)	(lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
#define lua_isnil(L,n)		(lua_type(L, (n)) == LUA_TNIL)
#define lua_isboolean(L,n)	(lua_type(L, (n)) == LUA_TBOOLEAN)
#define lua_isthread(L,n)	(lua_type(L, (n)) == LUA_TTHREAD)
#define lua_isnone(L,n)		(lua_type(L, (n)) == LUA_TNONE)
#define lua_isnoneornil(L, n)	(lua_type(L, (n)) <= 0)

#define lua_pushliteral(L, s)	\
	lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)

#define lua_pushglobaltable(L)  \
	lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS)

#define lua_tostring(L,i)	lua_tolstring(L, (i), NULL)


#define lua_insert(L,idx)	lua_rotate(L, (idx), 1)

#define lua_remove(L,idx)	(lua_rotate(L, (idx), -1), lua_pop(L, 1))

#define lua_replace(L,idx)	(lua_copy(L, -1, (idx)), lua_pop(L, 1))

/* }============================================================== */


/*
** {==============================================================
** compatibility macros for unsigned conversions
** ===============================================================
*/
#if defined(LUA_COMPAT_APIINTCASTS)

#define lua_pushunsigned(L,n)	lua_pushinteger(L, (lua_Integer)(n))
#define lua_tounsignedx(L,i,is)	((lua_Unsigned)lua_tointegerx(L,i,is))
#define lua_tounsigned(L,i)	lua_tounsignedx(L,(i),NULL)

#endif
/* }============================================================== */

/*
** {======================================================================
** Debug API
** =======================================================================
*/


/*
** Event codes
*/
#define LUA_HOOKCALL	0
#define LUA_HOOKRET	1
#define LUA_HOOKLINE	2
#define LUA_HOOKCOUNT	3
#define LUA_HOOKTAILCALL 4


/*
** Event masks
*/
#define LUA_MASKCALL	(1 << LUA_HOOKCALL)
#define LUA_MASKRET	(1 << LUA_HOOKRET)
#define LUA_MASKLINE	(1 << LUA_HOOKLINE)
#define LUA_MASKCOUNT	(1 << LUA_HOOKCOUNT)

typedef struct lua_Debug lua_Debug;  /* activation record */


/* Functions to be called by the debugger in specific events */
typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);


LUA_API int (lua_getstack) (lua_State *L, int level, lua_Debug *ar);
LUA_API int (lua_getinfo) (lua_State *L, const char *what, lua_Debug *ar);
LUA_API const char *(lua_getlocal) (lua_State *L, const lua_Debug *ar, int n);
LUA_API const char *(lua_setlocal) (lua_State *L, const lua_Debug *ar, int n);
LUA_API const char *(lua_getupvalue) (lua_State *L, int funcindex, int n);
LUA_API const char *(lua_setupvalue) (lua_State *L, int funcindex, int n);

LUA_API void *(lua_upvalueid) (lua_State *L, int fidx, int n);
LUA_API void  (lua_upvaluejoin) (lua_State *L, int fidx1, int n1,
                                               int fidx2, int n2);

LUA_API void (lua_sethook) (lua_State *L, lua_Hook func, int mask, int count);
LUA_API lua_Hook (lua_gethook) (lua_State *L);
LUA_API int (lua_gethookmask) (lua_State *L);
LUA_API int (lua_gethookcount) (lua_State *L);


struct lua_Debug {
  int event;
  const char *name;	/* (n) */
  const char *namewhat;	/* (n) 'global', 'local', 'field', 'method' */
  const char *what;	/* (S) 'Lua', 'C', 'main', 'tail' */
  const char *source;	/* (S) */
  int currentline;	/* (l) */
  int linedefined;	/* (S) */
  int lastlinedefined;	/* (S) */
  unsigned char nups;	/* (u) number of upvalues */
  unsigned char nparams;/* (u) number of parameters */
  char isvararg;        /* (u) */
  char istailcall;	/* (t) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  struct CallInfo *i_ci;  /* active function */
};

/* }====================================================================== */


/******************************************************************************
* Copyright (C) 1994-2015 Lua.org, PUC-Rio.
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
******************************************************************************/


#endif

```

`plugin/ios_rtti/ce_sdk/luaconf.h`:

```h
/*
** $Id: luaconf.h,v 1.238 2014/12/29 13:27:55 roberto Exp $
** Configuration file for Lua
** See Copyright Notice in lua.h
*/


#ifndef luaconf_h
#define luaconf_h

#include <limits.h>
#include <stddef.h>


/*
** ===================================================================
** Search for "@@" to find all configurable definitions.
** ===================================================================
*/


/*
** {====================================================================
** System Configuration: macros to adapt (if needed) Lua to some
** particular platform, for instance compiling it with 32-bit numbers or
** restricting it to C89.
** =====================================================================
*/

/*
@@ LUA_32BITS enables Lua with 32-bit integers and 32-bit floats. You
** can also define LUA_32BITS in the make file, but changing here you
** ensure that all software connected to Lua will be compiled with the
** same configuration.
*/
/* #define LUA_32BITS */


/*
@@ LUA_USE_C89 controls the use of non-ISO-C89 features.
** Define it if you want Lua to avoid the use of a few C99 features
** or Windows-specific features on Windows.
*/
/* #define LUA_USE_C89 */


/*
** By default, Lua on Windows use (some) specific Windows features
*/
#if !defined(LUA_USE_C89) && defined(_WIN32) && !defined(_WIN32_WCE)
#define LUA_USE_WINDOWS  /* enable goodies for regular Windows */
#endif


#if defined(LUA_USE_WINDOWS)
#define LUA_DL_DLL	/* enable support for DLL */
#define LUA_USE_C89	/* broadly, Windows is C89 */
#endif


#if defined(LUA_USE_LINUX)
#define LUA_USE_POSIX
#define LUA_USE_DLOPEN		/* needs an extra library: -ldl */
#define LUA_USE_READLINE	/* needs some extra libraries */
#endif


#if defined(LUA_USE_MACOSX)
#define LUA_USE_POSIX
#define LUA_USE_DLOPEN		/* MacOS does not need -ldl */
#define LUA_USE_READLINE	/* needs an extra library: -lreadline */
#endif


/*
@@ LUA_C89_NUMBERS ensures that Lua uses the largest types available for
** C89 ('long' and 'double'); Windows always has '__int64', so it does
** not need to use this case.
*/
#if defined(LUA_USE_C89) && !defined(LUA_USE_WINDOWS)
#define LUA_C89_NUMBERS
#endif



/*
@@ LUAI_BITSINT defines the (minimum) number of bits in an 'int'.
*/
/* avoid undefined shifts */
#if ((INT_MAX >> 15) >> 15) >= 1
#define LUAI_BITSINT	32
#else
/* 'int' always must have at least 16 bits */
#define LUAI_BITSINT	16
#endif


/*
@@ LUA_INT_INT / LUA_INT_LONG / LUA_INT_LONGLONG defines the type for
** Lua integers.
@@ LUA_REAL_FLOAT / LUA_REAL_DOUBLE / LUA_REAL_LONGDOUBLE defines
** the type for Lua floats.
** Lua should work fine with any mix of these options (if supported
** by your C compiler). The usual configurations are 64-bit integers
** and 'double' (the default), 32-bit integers and 'float' (for
** restricted platforms), and 'long'/'double' (for C compilers not
** compliant with C99, which may not have support for 'long long').
*/

#if defined(LUA_32BITS)		/* { */
/*
** 32-bit integers and 'float'
*/
#if LUAI_BITSINT >= 32  /* use 'int' if big enough */
#define LUA_INT_INT
#else  /* otherwise use 'long' */
#define LUA_INT_LONG
#endif
#define LUA_REAL_FLOAT

#elif defined(LUA_C89_NUMBERS)	/* }{ */
/*
** largest types available for C89 ('long' and 'double')
*/
#define LUA_INT_LONG
#define LUA_REAL_DOUBLE

#else				/* }{ */
/*
** default configuration for 64-bit Lua ('long long' and 'double')
*/
#define LUA_INT_LONGLONG
#define LUA_REAL_DOUBLE

#endif								/* } */

/* }================================================================== */




/*
** {==================================================================
** Configuration for Paths.
** ===================================================================
*/

/*
@@ LUA_PATH_DEFAULT is the default path that Lua uses to look for
** Lua libraries.
@@ LUA_CPATH_DEFAULT is the default path that Lua uses to look for
** C libraries.
** CHANGE them if your machine has a non-conventional directory
** hierarchy or if you want to install your libraries in
** non-conventional directories.
*/
#define LUA_VDIR	LUA_VERSION_MAJOR "." LUA_VERSION_MINOR
#if defined(_WIN32) 	/* { */
/*
** In Windows, any exclamation mark ('!') in the path is replaced by the
** path of the directory of the executable file of the current process.
*/
#define LUA_LDIR	"!\\lua\\"
#define LUA_CDIR	"!\\"
#define LUA_SHRDIR	"!\\..\\share\\lua\\" LUA_VDIR "\\"
#define LUA_PATH_DEFAULT  \
		LUA_LDIR"?.lua;"  LUA_LDIR"?\\init.lua;" \
		LUA_CDIR"?.lua;"  LUA_CDIR"?\\init.lua;" \
		LUA_SHRDIR"?.lua;" LUA_SHRDIR"?\\init.lua;" \
		".\\?.lua;" ".\\?\\init.lua"
#define LUA_CPATH_DEFAULT \
		LUA_CDIR"?.dll;" \
		LUA_CDIR"..\\lib\\lua\\" LUA_VDIR "\\?.dll;" \
		LUA_CDIR"loadall.dll;" ".\\?.dll" \
    LUA_CDIR"?53.dll;" ".\\?53.dll"

#else			/* }{ */

#define LUA_ROOT	"/usr/local/"
#define LUA_LDIR	LUA_ROOT "share/lua/" LUA_VDIR "/"
#define LUA_CDIR	LUA_ROOT "lib/lua/" LUA_VDIR "/"
#define LUA_PATH_DEFAULT  \
		LUA_LDIR"?.lua;"  LUA_LDIR"?/init.lua;" \
		LUA_CDIR"?.lua;"  LUA_CDIR"?/init.lua;" \
		"./?.lua;" "./?/init.lua"
#define LUA_CPATH_DEFAULT \
		LUA_CDIR"?.so;" LUA_CDIR"loadall.so;" "./?.so" \
    LUA_CDIR"lib?53.so;" "./lib?53.so"
#endif			/* } */


/*
@@ LUA_DIRSEP is the directory separator (for submodules).
** CHANGE it if your machine does not use "/" as the directory separator
** and is not Windows. (On Windows Lua automatically uses "\".)
*/
#if defined(_WIN32)
#define LUA_DIRSEP	"\\"
#else
#define LUA_DIRSEP	"/"
#endif

/* }================================================================== */


/*
** {==================================================================
** Marks for exported symbols in the C code
** ===================================================================
*/

/*
@@ LUA_API is a mark for all core API functions.
@@ LUALIB_API is a mark for all auxiliary library functions.
@@ LUAMOD_API is a mark for all standard library opening functions.
** CHANGE them if you need to define those functions in some special way.
** For instance, if you want to create one Windows DLL with the core and
** the libraries, you may want to use the following definition (define
** LUA_BUILD_AS_DLL to get it).
*/
#if defined(LUA_BUILD_AS_DLL)	/* { */

#if defined(LUA_CORE) || defined(LUA_LIB)	/* { */
#define LUA_API __declspec(dllexport)
#else						/* }{ */
#define LUA_API __declspec(dllimport)
#endif						/* } */

#else				/* }{ */

#define LUA_API		extern

#endif				/* } */


/* more often than not the libs go together with the core */
#define LUALIB_API	LUA_API
#define LUAMOD_API	LUALIB_API


/*
@@ LUAI_FUNC is a mark for all extern functions that are not to be
** exported to outside modules.
@@ LUAI_DDEF and LUAI_DDEC are marks for all extern (const) variables
** that are not to be exported to outside modules (LUAI_DDEF for
** definitions and LUAI_DDEC for declarations).
** CHANGE them if you need to mark them in some special way. Elf/gcc
** (versions 3.2 and later) mark them as "hidden" to optimize access
** when Lua is compiled as a shared library. Not all elf targets support
** this attribute. Unfortunately, gcc does not offer a way to check
** whether the target offers that support, and those without support
** give a warning about it. To avoid these warnings, change to the
** default definition.
*/
#if defined(__GNUC__) && ((__GNUC__*100 + __GNUC_MINOR__) >= 302) && \
    defined(__ELF__)		/* { */
#define LUAI_FUNC	__attribute__((visibility("hidden"))) extern
#else				/* }{ */
#define LUAI_FUNC	extern
#endif				/* } */

#define LUAI_DDEC	LUAI_FUNC
#define LUAI_DDEF	/* empty */

/* }================================================================== */


/*
** {==================================================================
** Compatibility with previous versions
** ===================================================================
*/

/*
@@ LUA_COMPAT_5_2 controls other macros for compatibility with Lua 5.2.
@@ LUA_COMPAT_5_1 controls other macros for compatibility with Lua 5.1.
** You can define it to get all options, or change specific options
** to fit your specific needs.
*/
#if defined(LUA_COMPAT_5_2)	/* { */

/*
@@ LUA_COMPAT_MATHLIB controls the presence of several deprecated
** functions in the mathematical library.
*/
#define LUA_COMPAT_MATHLIB

/*
@@ LUA_COMPAT_BITLIB controls the presence of library 'bit32'.
*/
#define LUA_COMPAT_BITLIB

/*
@@ LUA_COMPAT_IPAIRS controls the effectiveness of the __ipairs metamethod.
*/
#define LUA_COMPAT_IPAIRS

/*
@@ LUA_COMPAT_APIINTCASTS controls the presence of macros for
** manipulating other integer types (lua_pushunsigned, lua_tounsigned,
** luaL_checkint, luaL_checklong, etc.)
*/
#define LUA_COMPAT_APIINTCASTS


/*
@@ LUA_COMPAT_FLOATSTRING makes Lua format integral floats without a
@@ a float mark ('.0').
** This macro is not on by default even in compatibility mode,
** because this is not really an incompatibility.
*/
/* #define LUA_COMPAT_FLOATSTRING */

#endif				/* } */


#if defined(LUA_COMPAT_5_1)	/* { */

/*
@@ LUA_COMPAT_UNPACK controls the presence of global 'unpack'.
** You can replace it with 'table.unpack'.
*/
#define LUA_COMPAT_UNPACK

/*
@@ LUA_COMPAT_LOADERS controls the presence of table 'package.loaders'.
** You can replace it with 'package.searchers'.
*/
#define LUA_COMPAT_LOADERS

/*
@@ macro 'lua_cpcall' emulates deprecated function lua_cpcall.
** You can call your C function directly (with light C functions).
*/
#define lua_cpcall(L,f,u)  \
	(lua_pushcfunction(L, (f)), \
	 lua_pushlightuserdata(L,(u)), \
	 lua_pcall(L,1,0,0))


/*
@@ LUA_COMPAT_LOG10 defines the function 'log10' in the math library.
** You can rewrite 'log10(x)' as 'log(x, 10)'.
*/
#define LUA_COMPAT_LOG10

/*
@@ LUA_COMPAT_LOADSTRING defines the function 'loadstring' in the base
** library. You can rewrite 'loadstring(s)' as 'load(s)'.
*/
#define LUA_COMPAT_LOADSTRING

/*
@@ LUA_COMPAT_MAXN defines the function 'maxn' in the table library.
*/
#define LUA_COMPAT_MAXN

/*
@@ The following macros supply trivial compatibility for some
** changes in the API. The macros themselves document how to
** change your code to avoid using them.
*/
#define lua_strlen(L,i)		lua_rawlen(L, (i))

#define lua_objlen(L,i)		lua_rawlen(L, (i))

#define lua_equal(L,idx1,idx2)		lua_compare(L,(idx1),(idx2),LUA_OPEQ)
#define lua_lessthan(L,idx1,idx2)	lua_compare(L,(idx1),(idx2),LUA_OPLT)

/*
@@ LUA_COMPAT_MODULE controls compatibility with previous
** module functions 'module' (Lua) and 'luaL_register' (C).
*/
#define LUA_COMPAT_MODULE

#endif				/* } */

/* }================================================================== */



/*
** {==================================================================
** Configuration for Numbers.
** Change these definitions if no predefined LUA_REAL_* / LUA_INT_*
** satisfy your needs.
** ===================================================================
*/

/*
@@ LUA_NUMBER is the floating-point type used by Lua.
**
@@ LUAI_UACNUMBER is the result of an 'usual argument conversion'
@@ over a floating number.
**
@@ LUA_NUMBER_FRMLEN is the length modifier for writing floats.
@@ LUA_NUMBER_FMT is the format for writing floats.
@@ lua_number2str converts a float to a string.
**
@@ l_mathop allows the addition of an 'l' or 'f' to all math operations.
**
@@ lua_str2number converts a decimal numeric string to a number.
*/

#if defined(LUA_REAL_FLOAT)		/* { single float */

#define LUA_NUMBER	float

#define LUAI_UACNUMBER	double

#define LUA_NUMBER_FRMLEN	""
#define LUA_NUMBER_FMT		"%.7g"

#define l_mathop(op)		op##f

#define lua_str2number(s,p)	strtof((s), (p))


#elif defined(LUA_REAL_LONGDOUBLE)	/* }{ long double */

#define LUA_NUMBER	long double

#define LUAI_UACNUMBER	long double

#define LUA_NUMBER_FRMLEN	"L"
#define LUA_NUMBER_FMT		"%.19Lg"

#define l_mathop(op)		op##l

#define lua_str2number(s,p)	strtold((s), (p))

#elif defined(LUA_REAL_DOUBLE)		/* }{ double */

#define LUA_NUMBER	double

#define LUAI_UACNUMBER	double

#define LUA_NUMBER_FRMLEN	""
#define LUA_NUMBER_FMT		"%.14g"

#define l_mathop(op)		op

#define lua_str2number(s,p)	strtod((s), (p))

#else					/* }{ */

#error "numeric real type not defined"

#endif					/* } */


#define l_floor(x)		(l_mathop(floor)(x))

#define lua_number2str(s,n)	sprintf((s), LUA_NUMBER_FMT, (n))


/*
@@ lua_numbertointeger converts a float number to an integer, or
** returns 0 if float is not within the range of a lua_Integer.
** (The range comparisons are tricky because of rounding. The tests
** here assume a two-complement representation, where MININTEGER always
** has an exact representation as a float; MAXINTEGER may not have one,
** and therefore its conversion to float may have an ill-defined value.)
*/
#define lua_numbertointeger(n,p) \
  ((n) >= (LUA_NUMBER)(LUA_MININTEGER) && \
   (n) < -(LUA_NUMBER)(LUA_MININTEGER) && \
      (*(p) = (LUA_INTEGER)(n), 1))


/*
@@ The luai_num* macros define the primitive operations over numbers.
** They should work for any size of floating numbers.
*/

/* the following operations need the math library */
#if defined(lobject_c) || defined(lvm_c)
#include <math.h>

/* floor division (defined as 'floor(a/b)') */
#define luai_numidiv(L,a,b)	((void)L, l_mathop(floor)(luai_numdiv(L,a,b)))

/*
** module: defined as 'a - floor(a/b)*b'; the previous definition gives
** NaN when 'b' is huge, but the result should be 'a'. 'fmod' gives the
** result of 'a - trunc(a/b)*b', and therefore must be corrected when
** 'trunc(a/b) ~= floor(a/b)'. That happens when the division has a
** non-integer negative result, which is equivalent to the test below
*/
#define luai_nummod(L,a,b,m)  \
  { (m) = l_mathop(fmod)(a,b); if ((m)*(b) < 0) (m) += (b); }

/* exponentiation */
#define luai_numpow(L,a,b)	((void)L, l_mathop(pow)(a,b))

#endif

/* these are quite standard operations */
#if defined(LUA_CORE)
#define luai_numadd(L,a,b)	((a)+(b))
#define luai_numsub(L,a,b)	((a)-(b))
#define luai_nummul(L,a,b)	((a)*(b))
#define luai_numdiv(L,a,b)	((a)/(b))
#define luai_numunm(L,a)	(-(a))
#define luai_numeq(a,b)		((a)==(b))
#define luai_numlt(a,b)		((a)<(b))
#define luai_numle(a,b)		((a)<=(b))
#define luai_numisnan(a)	(!luai_numeq((a), (a)))
#endif


/*
@@ LUA_INTEGER is the integer type used by Lua.
**
@@ LUA_UNSIGNED is the unsigned version of LUA_INTEGER.
**
@@ LUAI_UACINT is the result of an 'usual argument conversion'
@@ over a lUA_INTEGER.
@@ LUA_INTEGER_FRMLEN is the length modifier for reading/writing integers.
@@ LUA_INTEGER_FMT is the format for writing integers.
@@ LUA_MAXINTEGER is the maximum value for a LUA_INTEGER.
@@ LUA_MININTEGER is the minimum value for a LUA_INTEGER.
@@ lua_integer2str converts an integer to a string.
*/


/* The following definitions are good for most cases here */

#define LUA_INTEGER_FMT		"%" LUA_INTEGER_FRMLEN "d"
#define lua_integer2str(s,n)	sprintf((s), LUA_INTEGER_FMT, (n))

#define LUAI_UACINT		LUA_INTEGER

/*
** use LUAI_UACINT here to avoid problems with promotions (which
** can turn a comparison between unsigneds into a signed comparison)
*/
#define LUA_UNSIGNED		unsigned LUAI_UACINT


/* now the variable definitions */

#if defined(LUA_INT_INT)		/* { int */

#define LUA_INTEGER		int
#define LUA_INTEGER_FRMLEN	""

#define LUA_MAXINTEGER		INT_MAX
#define LUA_MININTEGER		INT_MIN

#elif defined(LUA_INT_LONG)	/* }{ long */

#define LUA_INTEGER		long
#define LUA_INTEGER_FRMLEN	"l"

#define LUA_MAXINTEGER		LONG_MAX
#define LUA_MININTEGER		LONG_MIN

#elif defined(LUA_INT_LONGLONG)	/* }{ long long */

#if defined(LLONG_MAX)		/* { */
/* use ISO C99 stuff */

#define LUA_INTEGER		long long
#define LUA_INTEGER_FRMLEN	"ll"

#define LUA_MAXINTEGER		LLONG_MAX
#define LUA_MININTEGER		LLONG_MIN

#elif defined(LUA_USE_WINDOWS) /* }{ */
/* in Windows, can use specific Windows types */

#define LUA_INTEGER		__int64
#define LUA_INTEGER_FRMLEN	"I64"

#define LUA_MAXINTEGER		_I64_MAX
#define LUA_MININTEGER		_I64_MIN

#else				/* }{ */

#error "Compiler does not support 'long long'. Use option '-DLUA_32BITS' \
  or '-DLUA_C89_NUMBERS' (see file 'luaconf.h' for details)"

#endif				/* } */

#else				/* }{ */

#error "numeric integer type not defined"

#endif				/* } */

/* }================================================================== */


/*
** {==================================================================
** Dependencies with C99
** ===================================================================
*/

/*
@@ lua_strx2number converts an hexadecimal numeric string to a number.
** In C99, 'strtod' does both conversions. Otherwise, you can
** leave 'lua_strx2number' undefined and Lua will provide its own
** implementation.
*/
#if !defined(LUA_USE_C89)
#define lua_strx2number(s,p)	lua_str2number(s,p)
#endif


/*
@@ LUA_USE_AFORMAT allows '%a'/'%A' specifiers in 'string.format'
** Enable it if the C function 'printf' supports these specifiers.
** (C99 demands it and Windows also supports it.)
*/
#if !defined(LUA_USE_C89) || defined(LUA_USE_WINDOWS)
#define LUA_USE_AFORMAT
#endif


/*
** 'strtof' and 'opf' variants for math functions are not valid in
** C89. Otherwise, the macro 'HUGE_VALF' is a good proxy for testing the
** availability of these variants. ('math.h' is already included in
** all files that use these macros.)
*/
#if defined(LUA_USE_C89) || (defined(HUGE_VAL) && !defined(HUGE_VALF))
#undef l_mathop  /* variants not available */
#undef lua_str2number
#define l_mathop(op)		(lua_Number)op  /* no variant */
#define lua_str2number(s,p)	((lua_Number)strtod((s), (p)))
#endif


/*
@@ LUA_KCONTEXT is the type of the context ('ctx') for continuation
** functions.  It must be a numerical type; Lua will use 'intptr_t' if
** available, otherwise it will use 'ptrdiff_t' (the nearest thing to
** 'intptr_t' in C89)
*/
#define LUA_KCONTEXT	ptrdiff_t

#if !defined(LUA_USE_C89) && defined(__STDC_VERSION__) && \
    __STDC_VERSION__ >= 199901L
#include <stdint.h>
#if defined (INTPTR_MAX)  /* even in C99 this type is optional */
#undef LUA_KCONTEXT
#define LUA_KCONTEXT	intptr_t
#endif
#endif

/* }================================================================== */


/*
** {==================================================================
** Macros that affect the API and must be stable (that is, must be the
** same when you compile Lua and when you compile code that links to
** Lua). You probably do not want/need to change them.
** =====================================================================
*/

/*
@@ LUAI_MAXSTACK limits the size of the Lua stack.
** CHANGE it if you need a different limit. This limit is arbitrary;
** its only purpose is to stop Lua from consuming unlimited stack
** space (and to reserve some numbers for pseudo-indices).
*/
#if LUAI_BITSINT >= 32
#define LUAI_MAXSTACK		1000000
#else
#define LUAI_MAXSTACK		15000
#endif

/* reserve some space for error handling */
#define LUAI_FIRSTPSEUDOIDX	(-LUAI_MAXSTACK - 1000)


/*
@@ LUA_EXTRASPACE defines the size of a raw memory area associated with
** a Lua state with very fast access.
** CHANGE it if you need a different size.
*/
#define LUA_EXTRASPACE		(sizeof(void *))


/*
@@ LUA_IDSIZE gives the maximum size for the description of the source
@@ of a function in debug information.
** CHANGE it if you want a different size.
*/
#define LUA_IDSIZE	60


/*
@@ LUAI_MAXSHORTLEN is the maximum length for short strings, that is,
** strings that are internalized. (Cannot be smaller than reserved words
** or tags for metamethods, as these strings must be internalized;
** #("function") = 8, #("__newindex") = 10.)
*/
#define LUAI_MAXSHORTLEN        40


/*
@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.
** CHANGE it if it uses too much C-stack space.
*/
#define LUAL_BUFFERSIZE	((int)(0x80 * sizeof(void*) * sizeof(lua_Integer)))

/* }================================================================== */


/*
@@ LUA_QL describes how error messages quote program elements.
** Lua does not use these macros anymore; they are here for
** compatibility only.
*/
#define LUA_QL(x)	"'" x "'"
#define LUA_QS		LUA_QL("%s")




/* =================================================================== */

/*
** Local configuration. You can use this space to add your redefinitions
** without modifying the main part of the file.
*/





#endif


```

`plugin/ios_rtti/ce_sdk/lualib.h`:

```h
/*
** $Id: lualib.h,v 1.44 2014/02/06 17:32:33 roberto Exp $
** Lua standard libraries
** See Copyright Notice in lua.h
*/


#ifndef lualib_h
#define lualib_h

#include "lua.h"



LUAMOD_API int (luaopen_base) (lua_State *L);

#define LUA_COLIBNAME	"coroutine"
LUAMOD_API int (luaopen_coroutine) (lua_State *L);

#define LUA_TABLIBNAME	"table"
LUAMOD_API int (luaopen_table) (lua_State *L);

#define LUA_IOLIBNAME	"io"
LUAMOD_API int (luaopen_io) (lua_State *L);

#define LUA_OSLIBNAME	"os"
LUAMOD_API int (luaopen_os) (lua_State *L);

#define LUA_STRLIBNAME	"string"
LUAMOD_API int (luaopen_string) (lua_State *L);

#define LUA_UTF8LIBNAME	"utf8"
LUAMOD_API int (luaopen_utf8) (lua_State *L);

#define LUA_BITLIBNAME	"bit32"
LUAMOD_API int (luaopen_bit32) (lua_State *L);

#define LUA_MATHLIBNAME	"math"
LUAMOD_API int (luaopen_math) (lua_State *L);

#define LUA_DBLIBNAME	"debug"
LUAMOD_API int (luaopen_debug) (lua_State *L);

#define LUA_LOADLIBNAME	"package"
LUAMOD_API int (luaopen_package) (lua_State *L);


/* open all previous libraries */
LUALIB_API void (luaL_openlibs) (lua_State *L);



#if !defined(lua_assert)
#define lua_assert(x)	((void)0)
#endif


#endif

```

`plugin/ios_rtti/ios_rtti_plugin.cpp`:

```cpp
#include <windows.h>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cstddef>
#include <string>
#include <vector>
#include <set>

#include "itanium_abi_rtti.h"
#include "llvm/Demangle/Demangle.h"

extern "C" {
#include "cepluginsdk.h"
}

static_assert(sizeof(void*) == 8, " build as x64.");

typedef BOOL (__stdcall *ReadProcessMemory_FuncType)(HANDLE hProcess, LPCVOID lpBaseAddress,
                                                     LPVOID lpBuffer, SIZE_T nSize,
                                                     SIZE_T *lpNumberOfBytesRead);

typedef void* (*TPluginFunc)(void* parameters);

typedef intptr_t lua_KContext;
typedef int (*lua_KFunction)(lua_State* L, int status, lua_KContext ctx);

typedef void (*P_lua_getglobal)(lua_State *L, const char *name);
typedef void (*P_lua_setglobal)(lua_State *L, const char *name);
typedef void (*P_lua_pushcclosure)(lua_State *L, lua_CFunction f, int n);
typedef void (*P_lua_pushstring)(lua_State *L, const char *s);
typedef void (*P_lua_pushboolean)(lua_State *L, int b);
typedef void (*P_lua_pushinteger)(lua_State *L, lua_Integer n);
typedef void (*P_lua_settop)(lua_State *L, int idx);
typedef int  (*P_luaL_loadstring)(lua_State *L, const char *s);

typedef int  (*P_lua_pcall)(lua_State *L, int nargs, int nresults, int errfunc);
typedef int  (*P_lua_pcallk)(lua_State *L, int nargs, int nresults, int errfunc,
                            lua_KContext ctx, lua_KFunction k);

typedef lua_Integer (*P_lua_tointegerx)(lua_State *L, int idx, int *isnum);
typedef lua_Integer (*P_lua_tointeger)(lua_State *L, int idx);

static HANDLE* g_OpenedProcessHandlePtr = nullptr;
static ReadProcessMemory_FuncType* g_ReadProcessMemoryPtr = nullptr;
static bool g_Initialized = false;

static P_lua_getglobal g_lua_getglobal = nullptr;
static P_lua_setglobal g_lua_setglobal = nullptr;
static P_lua_pushcclosure g_lua_pushcclosure = nullptr;
static P_lua_pushstring g_lua_pushstring = nullptr;
static P_lua_pushboolean g_lua_pushboolean = nullptr;
static P_lua_pushinteger g_lua_pushinteger = nullptr;
static P_lua_settop g_lua_settop = nullptr;
static P_luaL_loadstring g_luaL_loadstring = nullptr;
static P_lua_pcall g_lua_pcall = nullptr;
static P_lua_pcallk g_lua_pcallk = nullptr;
static P_lua_tointegerx g_lua_tointegerx = nullptr;
static P_lua_tointeger g_lua_tointeger = nullptr;

static lua_State* g_L = nullptr;
static CEP_REGISTERFUNCTION g_RegisterFunction = nullptr;
static CEP_UNREGISTERFUNCTION g_UnregisterFunction = nullptr;
static int g_plugin_id = -1;
static int g_menu_id = -1;

static int My_lua_pcall(lua_State *L, int nargs, int nresults, int errfunc) {
  if (g_lua_pcall) {
    return g_lua_pcall(L, nargs, nresults, errfunc);
  }
  if (g_lua_pcallk) {
    return g_lua_pcallk(L, nargs, nresults, errfunc, (lua_KContext)0, nullptr);
  }
  return -1;
}

static lua_Integer My_lua_tointeger(lua_State *L, int idx, bool *isnum) {
  if (g_lua_tointegerx) {
    int ok = 0;
    lua_Integer v = g_lua_tointegerx(L, idx, &ok);
    if (isnum) *isnum = (ok != 0);
    return v;
  }
  if (g_lua_tointeger) {
    if (isnum) *isnum = true;
    return g_lua_tointeger(L, idx);
  }
  if (isnum) *isnum = false;
  return 0;
}

static void lua_pop_all(lua_State *L) {
  if (g_lua_settop) g_lua_settop(L, 0);
}

static bool exported_struct_valid(const ExportedFunctions* f) {
  const size_t sz = (size_t)f->sizeofExportedFunctions;
  if (sz < offsetof(ExportedFunctions, OpenedProcessHandle) + sizeof(f->OpenedProcessHandle)) return false;
  if (sz < offsetof(ExportedFunctions, ReadProcessMemory) + sizeof(f->ReadProcessMemory)) return false;
  if (sz < offsetof(ExportedFunctions, GetLuaState) + sizeof(f->GetLuaState)) return false;
  if (sz < offsetof(ExportedFunctions, MainThreadCall) + sizeof(f->MainThreadCall)) return false;
  if (sz < offsetof(ExportedFunctions, RegisterFunction) + sizeof(f->RegisterFunction)) return false;
  if (sz < offsetof(ExportedFunctions, UnregisterFunction) + sizeof(f->UnregisterFunction)) return false;
  return true;
}

static uint64_t strip_pac(uint64_t p) {
  return p & 0x0000007FFFFFFFFFULL;
}

static bool read_mem(uint64_t address, void* buffer, size_t size) {
  if (!g_Initialized) return false;
  if (!g_OpenedProcessHandlePtr || !g_ReadProcessMemoryPtr) return false;

  HANDLE hToUse = *g_OpenedProcessHandlePtr;
  if (!hToUse) return false;

  ReadProcessMemory_FuncType rpmFunc = *g_ReadProcessMemoryPtr;
  if (!rpmFunc) return false;

  SIZE_T bytesRead = 0;
  BOOL res = rpmFunc(hToUse, (LPCVOID)address, buffer, size, &bytesRead);
  if (!res || bytesRead != size) return false;
  return true;
}

static bool read_string_safe(uint64_t address, char* buf, size_t size) {
  size_t bytes_read = 0;
  const size_t chunk_size = 64;
  char chunk[64];

  while (bytes_read < size - 1) {
    size_t to_read = (size - 1 - bytes_read) < chunk_size ? (size - 1 - bytes_read) : chunk_size;
    if (!read_mem(address + bytes_read, chunk, to_read)) {
      if (bytes_read == 0) return false;
      break;
    }

    bool found_null = false;
    for (size_t i = 0; i < to_read; i++) {
      buf[bytes_read + i] = chunk[i];
      if (chunk[i] == '\0') {
        found_null = true;
        break;
      }
    }

    bytes_read += to_read;
    if (found_null) return true;
  }

  buf[bytes_read] = '\0';
  return bytes_read > 0;
}

static std::string demangle_name(const char* raw) {
  if (!raw) return std::string();
  char* demangled = llvm::itaniumDemangle(raw);
  if (demangled) {
    std::string res = demangled;
    std::free(demangled);
    return res;
  }
  return std::string(raw);
}

static bool read_typename_from_typeinfo(uint64_t typeinfo_ptr, std::string &raw, std::string &demangled) {
  if (typeinfo_ptr == 0) return false;

  itanium_abi_rtti::Remote_TypeInfo typeInfoLocal;
  if (!read_mem(typeinfo_ptr, &typeInfoLocal, sizeof(typeInfoLocal))) return false;

  uint64_t name_ptr = strip_pac(typeInfoLocal.name_ptr);
  if (name_ptr == 0) return false;

  char name_buf[512] = {0};
  if (!read_string_safe(name_ptr, name_buf, sizeof(name_buf))) return false;

  raw = name_buf;
  demangled = demangle_name(name_buf);
  return true;
}

struct RTTIObjectInfo {
  uint64_t object_addr;
  uint64_t vtable_raw;
  uint64_t vtable;
  uint64_t typeinfo_raw;
  uint64_t typeinfo_ptr;
  int64_t offset_to_top;
  bool offset_to_top_valid;
  uint64_t top_addr;
};

static bool read_object_rtti_info(uint64_t object_addr, RTTIObjectInfo &info, std::string *error) {
  memset(&info, 0, sizeof(info));
  info.object_addr = object_addr;
  if (object_addr == 0) {
    if (error) *error = "Object address is 0";
    return false;
  }

  if (!read_mem(object_addr, &info.vtable_raw, sizeof(info.vtable_raw))) {
    if (error) *error = "Failed to read vtable";
    return false;
  }

  info.vtable = strip_pac(info.vtable_raw);
  if (info.vtable == 0) {
    if (error) *error = "VTable is 0";
    return false;
  }

  info.offset_to_top = 0;
  info.offset_to_top_valid = read_mem(info.vtable - (int64_t)(sizeof(uint64_t) * 2),
                                      &info.offset_to_top, sizeof(info.offset_to_top));
  info.top_addr = object_addr;
  if (info.offset_to_top_valid) {
    info.top_addr = (uint64_t)((int64_t)object_addr + info.offset_to_top);
  }

  if (!read_mem(info.vtable - sizeof(uint64_t), &info.typeinfo_raw, sizeof(info.typeinfo_raw))) {
    if (error) *error = "Failed to read typeinfo";
    return false;
  }

  info.typeinfo_ptr = strip_pac(info.typeinfo_raw);
  if (info.typeinfo_ptr == 0) {
    if (error) *error = "TypeInfo is 0";
    return false;
  }

  return true;
}

static bool get_rtti_name_only(uint64_t object_addr, std::string &demangled) {
  RTTIObjectInfo info;
  if (!read_object_rtti_info(object_addr, info, nullptr)) return false;
  std::string raw;
  if (!read_typename_from_typeinfo(info.typeinfo_ptr, raw, demangled)) return false;
  return !demangled.empty();
}

static int RTTI_Name_Lookup_Lua(lua_State* L) {
  if (!g_lua_pushstring || !g_lua_pushboolean) return 0;

  bool isnum = false;
  uint64_t addr = (uint64_t)My_lua_tointeger(L, 1, &isnum);
  if (!isnum || addr == 0) {
    g_lua_pushboolean(L, 0);
    return 1;
  }

  std::string demangled;
  if (get_rtti_name_only(addr, demangled)) {
    g_lua_pushstring(L, demangled.c_str());
    return 1;
  }

  g_lua_pushboolean(L, 0);
  return 1;
}

static bool read_rtti_kind(uint64_t typeinfo_ptr, std::string &raw, std::string &demangled) {
  uint64_t meta_vtable_raw = 0;
  if (!read_mem(typeinfo_ptr, &meta_vtable_raw, sizeof(meta_vtable_raw))) return false;
  uint64_t meta_vtable = strip_pac(meta_vtable_raw);
  if (meta_vtable == 0) return false;

  uint64_t meta_typeinfo_raw = 0;
  if (!read_mem(meta_vtable - sizeof(uint64_t), &meta_typeinfo_raw, sizeof(meta_typeinfo_raw))) return false;
  uint64_t meta_typeinfo = strip_pac(meta_typeinfo_raw);

  return read_typename_from_typeinfo(meta_typeinfo, raw, demangled);
}

static std::string hex_u64(uint64_t v) {
  char buf[32];
  snprintf(buf, sizeof(buf), "0x%llX", (unsigned long long)v);
  return std::string(buf);
}

static const int kDefaultTreeDepth = 8;
static const uint32_t kMaxBaseCount = 64;
static const char* kKeyError = "Error";
static const char* kKeyTree = "Tree";
static const char* kKeyInputAddress = "Input Address";
static const char* kKeyOffsetToTop = "Offset-to-top";
static const char* kKeyCompleteObjectTop = "Complete Object Top";
static const char* kKeyInputRole = "Input Role";
static const char* kKeyVTableStrip = "VTable (strip)";
static const char* kKeyVTableRaw = "VTable (raw)";
static const char* kKeyTypeInfoStrip = "TypeInfo (strip)";
static const char* kKeyTypeInfoRaw = "TypeInfo (raw)";
static const char* kKeyRttiKind = "RTTI Kind";
static const char* kKeyRttiKindRaw = "RTTI Kind (raw)";
static const char* kKeyName = "Name";
static const char* kKeyMangled = "Mangled";
static const char* kKeyVmiFlags = "VMI Flags";
static const char* kKeyVmiFlagsRaw = "VMI Flags (raw)";
static const char* kKeyVmiBaseCount = "VMI Base Count";
static const char* kKeyPBaseFlags = "PBase Flags";
static const char* kKeyPointee = "Pointee";
static const char* kKeyPointeeRaw = "Pointee (raw)";
static const char* kKeyContext = "Context";
static const char* kKeyContextRaw = "Context (raw)";
static const char* kKeyTreeDepthLimit = "Tree Depth Limit";
static const char* kKeyVTableModule = "VTable Module";
static const char* kKeyVTableRva = "VTable RVA";
static const char* kKeyTypeInfoModule = "TypeInfo Module";
static const char* kKeyTypeInfoRva = "TypeInfo RVA";

static const char* kSummaryOrder[] = {
  kKeyInputAddress,
  kKeyOffsetToTop,
  kKeyCompleteObjectTop,
  kKeyInputRole,
  kKeyName,
  kKeyMangled,
  kKeyRttiKind,
  kKeyRttiKindRaw,
  kKeyVmiFlags,
  kKeyVmiFlagsRaw,
  kKeyVmiBaseCount,
  kKeyPBaseFlags,
  kKeyPointee,
  kKeyPointeeRaw,
  kKeyContext,
  kKeyContextRaw,
  kKeyVTableStrip,
  kKeyVTableRaw,
  kKeyVTableModule,
  kKeyVTableRva,
  kKeyTypeInfoStrip,
  kKeyTypeInfoRaw,
  kKeyTypeInfoModule,
  kKeyTypeInfoRva,
  kKeyTreeDepthLimit,
};
static const size_t kSummaryOrderCount = sizeof(kSummaryOrder) / sizeof(kSummaryOrder[0]);

static const char* kBaseFieldName = "Name";
static const char* kBaseFieldAccess = "Access";
static const char* kBaseFieldVirtual = "Virtual";
static const char* kBaseFieldOffTop = "OffTop";
static const char* kBaseFieldOffEdge = "OffEdge";
static const char* kBaseFieldBaseAddr = "BaseAddr";
static const char* kBaseFieldVTableSlot = "VTableSlot";
static const char* kBaseFieldVBaseOffset = "VBaseOffset";
static const char* kBaseFieldOrder[] = {
  kBaseFieldName,
  kBaseFieldAccess,
  kBaseFieldVirtual,
  kBaseFieldOffTop,
  kBaseFieldOffEdge,
  kBaseFieldBaseAddr,
  kBaseFieldVTableSlot,
  kBaseFieldVBaseOffset,
};
static const size_t kBaseFieldOrderCount = sizeof(kBaseFieldOrder) / sizeof(kBaseFieldOrder[0]);

static std::string build_csv(const char* const* items, size_t count) {
  std::string out;
  for (size_t i = 0; i < count; ++i) {
    if (i) out += ",";
    out += items[i];
  }
  return out;
}

static std::string format_signed_hex_dec(int64_t v) {
  char buf[64];
  uint64_t abs = (v < 0) ? (uint64_t)(-(v + 1)) + 1 : (uint64_t)v;
  if (v < 0) {
    snprintf(buf, sizeof(buf), "-0x%llX (%lld)", (unsigned long long)abs, (long long)v);
  } else {
    snprintf(buf, sizeof(buf), "0x%llX (%lld)", (unsigned long long)abs, (long long)v);
  }
  return std::string(buf);
}

static std::string format_vtable_slot(int64_t byte_offset) {
  int64_t slot = byte_offset / (int64_t)sizeof(uint64_t);
  char buf[96];
  snprintf(buf, sizeof(buf), "slot=%lld (off=%s)",
           (long long)slot, format_signed_hex_dec(byte_offset).c_str());
  return std::string(buf);
}

static void append_line(std::string &out, const std::string &key, const std::string &value) {
  out += key;
  out += "\t";
  out += value;
  out += "\n";
}

static std::string vmi_flags_to_string(uint32_t flags) {
  std::string res;
  if (flags & itanium_abi_rtti::Remote_VmiClassTypeInfo::non_diamond_repeat_mask) {
    if (!res.empty()) res += ", ";
    res += "non_diamond_repeat";
  }
  if (flags & itanium_abi_rtti::Remote_VmiClassTypeInfo::diamond_shaped_mask) {
    if (!res.empty()) res += ", ";
    res += "diamond_shaped";
  }
  if (res.empty()) res = "none";
  return res;
}

static std::string pbase_flags_to_string(uint32_t flags) {
  std::string res;
  auto add = [&res](const char* s) {
    if (!res.empty()) res += " | ";
    res += s;
  };

  if (flags & itanium_abi_rtti::Remote_PBaseTypeInfo::const_mask) add("const");
  if (flags & itanium_abi_rtti::Remote_PBaseTypeInfo::volatile_mask) add("volatile");
  if (flags & itanium_abi_rtti::Remote_PBaseTypeInfo::restrict_mask) add("restrict");
  if (flags & itanium_abi_rtti::Remote_PBaseTypeInfo::incomplete_mask) add("incomplete");
  if (flags & itanium_abi_rtti::Remote_PBaseTypeInfo::incomplete_class_mask) add("incomplete_class");
  if (flags & itanium_abi_rtti::Remote_PBaseTypeInfo::transaction_safe_mask) add("transaction_safe");
  if (flags & itanium_abi_rtti::Remote_PBaseTypeInfo::noexcept_mask) add("noexcept");

  if (res.empty()) res = "none";
  return res;
}

struct BaseEntry {
  uint64_t typeinfo_ptr;
  std::string raw_name;
  std::string demangled;
  int64_t offset;
  int64_t base_offset;
  bool base_offset_valid;
  int64_t edge_offset;
  bool edge_offset_valid;
  uint64_t base_addr;
  bool base_addr_valid;
  int64_t vtable_slot;
  int64_t vbase_offset;
  bool vbase_valid;
  bool is_public;
  bool is_virtual;
};

static void decode_base_offset(int64_t offset_flags, int64_t &offset, bool &is_virtual, bool &is_public) {
  is_virtual = (offset_flags & itanium_abi_rtti::Remote_BaseClassTypeInfo::virtual_mask) != 0;
  is_public = (offset_flags & itanium_abi_rtti::Remote_BaseClassTypeInfo::public_mask) != 0;

  uint64_t offset_raw = (uint64_t)offset_flags >> 8;
  int64_t signed_offset = (int64_t)offset_raw;
  if (signed_offset & (1LL << 55)) {
    signed_offset |= 0xFF00000000000000ULL;
  }
  offset = signed_offset;
}

static bool read_bases(uint64_t typeinfo_ptr, const std::string &kind_raw, std::vector<BaseEntry> &bases, uint32_t &vmi_flags, uint32_t &vmi_count) {
  vmi_flags = 0;
  vmi_count = 0;
  bases.clear();

  if (kind_raw.find("vmi_class_type_info") != std::string::npos) {
    itanium_abi_rtti::Remote_VmiClassTypeInfo vmiInfo;
    if (!read_mem(typeinfo_ptr, &vmiInfo, sizeof(vmiInfo))) return false;

    vmi_flags = vmiInfo.flags;
    vmi_count = vmiInfo.base_count;
    if (vmi_count == 0 || vmi_count > kMaxBaseCount) return true;

    uint64_t base_array_addr = typeinfo_ptr + sizeof(itanium_abi_rtti::Remote_VmiClassTypeInfo);
    for (uint32_t i = 0; i < vmi_count; i++) {
      itanium_abi_rtti::Remote_BaseClassTypeInfo baseEntry;
      uint64_t entry_addr = base_array_addr + (i * sizeof(itanium_abi_rtti::Remote_BaseClassTypeInfo));
      if (!read_mem(entry_addr, &baseEntry, sizeof(baseEntry))) continue;

      uint64_t base_ptr = strip_pac(baseEntry.base_type_ptr);
      std::string raw, dem;
      if (!read_typename_from_typeinfo(base_ptr, raw, dem)) continue;

      BaseEntry b;
      b.typeinfo_ptr = base_ptr;
      b.raw_name = raw;
      b.demangled = dem;
      decode_base_offset(baseEntry.offset_flags, b.offset, b.is_virtual, b.is_public);
      b.base_offset = 0;
      b.base_offset_valid = false;
      b.edge_offset = 0;
      b.edge_offset_valid = false;
      b.base_addr = 0;
      b.base_addr_valid = false;
      b.vtable_slot = 0;
      b.vbase_offset = 0;
      b.vbase_valid = false;
      bases.push_back(b);
    }
    return true;
  }

  if (kind_raw.find("si_class_type_info") != std::string::npos) {
    itanium_abi_rtti::Remote_SiClassTypeInfo siInfo;
    if (!read_mem(typeinfo_ptr, &siInfo, sizeof(siInfo))) return false;

    uint64_t base_ptr = strip_pac(siInfo.base_type_ptr);
    std::string raw, dem;
    if (read_typename_from_typeinfo(base_ptr, raw, dem)) {
      BaseEntry b;
      b.typeinfo_ptr = base_ptr;
      b.raw_name = raw;
      b.demangled = dem;
      b.offset = 0;
      b.is_public = true;
      b.is_virtual = false;
      b.base_offset = 0;
      b.base_offset_valid = true;
      b.edge_offset = 0;
      b.edge_offset_valid = true;
      b.base_addr = 0;
      b.base_addr_valid = false;
      b.vtable_slot = 0;
      b.vbase_offset = 0;
      b.vbase_valid = false;
      bases.push_back(b);
    }
    return true;
  }

  return true;
}

static void compute_base_details(uint64_t top_addr, uint64_t vtable, int64_t current_offset, BaseEntry &b) {
  b.base_offset_valid = false;
  b.edge_offset_valid = false;
  b.base_addr_valid = false;
  b.vbase_valid = false;
  b.base_offset = 0;
  b.edge_offset = 0;
  b.base_addr = 0;
  b.vtable_slot = 0;
  b.vbase_offset = 0;

  if (b.is_virtual) {
    b.vtable_slot = b.offset;
    int64_t vbase_offset = 0;
    uint64_t vbase_addr = (uint64_t)((int64_t)vtable + b.vtable_slot);
    if (read_mem(vbase_addr, &vbase_offset, sizeof(vbase_offset))) {
      b.vbase_offset = vbase_offset;
      b.vbase_valid = true;
      b.base_offset = vbase_offset;
      b.base_offset_valid = true;
      b.base_addr = (uint64_t)((int64_t)top_addr + b.base_offset);
      b.base_addr_valid = true;
      b.edge_offset = b.base_offset - current_offset;
      b.edge_offset_valid = true;
    }
  } else {
    b.base_offset = current_offset + b.offset;
    b.base_offset_valid = true;
    b.base_addr = (uint64_t)((int64_t)top_addr + b.base_offset);
    b.base_addr_valid = true;
    b.edge_offset = b.base_offset - current_offset;
    b.edge_offset_valid = true;
  }
}

static void build_tree(uint64_t typeinfo_ptr, uint64_t top_addr, uint64_t vtable, int64_t current_offset,
                       int depth, int depth_limit, const BaseEntry* edge,
                       std::set<uint64_t> &visited, std::string &out) {
  if (typeinfo_ptr == 0) return;
  if (depth > depth_limit) {
    append_line(out, kKeyTree, std::string(depth * 2, ' ') + "[d=" + std::to_string(depth) + "] <max depth>");
    return;
  }

  std::string raw, dem;
  if (!read_typename_from_typeinfo(typeinfo_ptr, raw, dem)) return;

  std::string line = std::string(depth * 2, ' ') + "[d=" + std::to_string(depth) + "] " + dem;
  if (edge) {
    line += " [" + std::string(edge->is_public ? "public" : "non-public") + "]";
    if (edge->is_virtual) line += " [virtual]";
    if (edge->base_offset_valid) {
      line += " off_top=" + format_signed_hex_dec(edge->base_offset);
    }
    if (edge->edge_offset_valid) {
      line += " off_edge=" + format_signed_hex_dec(edge->edge_offset);
    }
    if (edge->is_virtual) {
      line += " vslot=" + format_vtable_slot(edge->vtable_slot);
      if (edge->vbase_valid) {
        line += " vbase=" + format_signed_hex_dec(edge->vbase_offset);
      }
    }
    if (edge->base_addr_valid) {
      line += " addr=" + hex_u64(edge->base_addr);
    } else if (edge->is_virtual) {
      line += " addr=unresolved";
    }
  } else {
    line += " [root] off_top=" + format_signed_hex_dec(current_offset) + " addr=" + hex_u64((uint64_t)((int64_t)top_addr + current_offset));
  }

  if (visited.count(typeinfo_ptr)) {
    line += " (seen)";
    append_line(out, kKeyTree, line);
    return;
  }
  visited.insert(typeinfo_ptr);

  append_line(out, kKeyTree, line);

  std::string kind_raw, kind_dem;
  if (!read_rtti_kind(typeinfo_ptr, kind_raw, kind_dem)) return;

  std::vector<BaseEntry> bases;
  uint32_t vmi_flags = 0;
  uint32_t vmi_count = 0;
  if (!read_bases(typeinfo_ptr, kind_raw, bases, vmi_flags, vmi_count)) return;

  for (auto &b : bases) {
    compute_base_details(top_addr, vtable, current_offset, b);
    int64_t next_offset = b.base_offset_valid ? b.base_offset : current_offset;
    build_tree(b.typeinfo_ptr, top_addr, vtable, next_offset, depth + 1, depth_limit, &b, visited, out);
  }
}

static bool build_rtti_report(uint64_t object_addr, int depth_limit, std::string &out) {
  out.clear();
  RTTIObjectInfo info;
  std::string err;
  if (!read_object_rtti_info(object_addr, info, &err)) {
    append_line(out, kKeyError, err);
    return false;
  }

  std::string type_raw, type_dem;
  if (!read_typename_from_typeinfo(info.typeinfo_ptr, type_raw, type_dem)) {
    append_line(out, kKeyError, "Failed to read type name");
    return false;
  }

  std::string kind_raw, kind_dem;
  read_rtti_kind(info.typeinfo_ptr, kind_raw, kind_dem);

  append_line(out, kKeyInputAddress, hex_u64(object_addr));
  append_line(out, kKeyOffsetToTop, info.offset_to_top_valid ? format_signed_hex_dec(info.offset_to_top) : "n/a");
  append_line(out, kKeyCompleteObjectTop, info.offset_to_top_valid ? hex_u64(info.top_addr) : "n/a");
  append_line(out, kKeyInputRole, info.offset_to_top_valid ? (info.offset_to_top == 0 ? "top" : "subobject") : "unknown");
  append_line(out, kKeyVTableStrip, hex_u64(info.vtable));
  append_line(out, kKeyVTableRaw, hex_u64(info.vtable_raw));
  append_line(out, kKeyTypeInfoStrip, hex_u64(info.typeinfo_ptr));
  append_line(out, kKeyTypeInfoRaw, hex_u64(info.typeinfo_raw));
  append_line(out, kKeyRttiKind, kind_dem.empty() ? "unknown" : kind_dem);
  append_line(out, kKeyRttiKindRaw, kind_raw.empty() ? "unknown" : kind_raw);
  append_line(out, kKeyName, type_dem);
  append_line(out, kKeyMangled, type_raw);

  if (kind_raw.find("vmi_class_type_info") != std::string::npos) {
    itanium_abi_rtti::Remote_VmiClassTypeInfo vmiInfo;
    if (read_mem(info.typeinfo_ptr, &vmiInfo, sizeof(vmiInfo))) {
      append_line(out, kKeyVmiFlags, vmi_flags_to_string(vmiInfo.flags));
      append_line(out, kKeyVmiFlagsRaw, hex_u64(vmiInfo.flags));
      append_line(out, kKeyVmiBaseCount, std::to_string(vmiInfo.base_count));
    }
  }

  std::vector<BaseEntry> bases;
  uint32_t vmi_flags = 0;
  uint32_t vmi_count = 0;
  if (read_bases(info.typeinfo_ptr, kind_raw, bases, vmi_flags, vmi_count)) {
    for (size_t i = 0; i < bases.size(); i++) {
      auto &b = bases[i];
      compute_base_details(info.top_addr, info.vtable, 0, b);
      std::string line;
      line += std::string(kBaseFieldName) + "=" + b.demangled;
      line += ";" + std::string(kBaseFieldAccess) + "=" + std::string(b.is_public ? "public" : "non-public");
      line += ";" + std::string(kBaseFieldVirtual) + "=" + std::string(b.is_virtual ? "virtual" : "");
      line += ";" + std::string(kBaseFieldOffTop) + "=" + std::string(b.base_offset_valid ? format_signed_hex_dec(b.base_offset) : "unresolved");
      line += ";" + std::string(kBaseFieldOffEdge) + "=" + std::string(b.edge_offset_valid ? format_signed_hex_dec(b.edge_offset) : "unresolved");
      line += ";" + std::string(kBaseFieldBaseAddr) + "=" + std::string(b.base_addr_valid ? hex_u64(b.base_addr) : "unresolved");
      line += ";" + std::string(kBaseFieldVTableSlot) + "=" + std::string(b.is_virtual ? format_vtable_slot(b.vtable_slot) : "");
      line += ";" + std::string(kBaseFieldVBaseOffset) + "=" + std::string(b.vbase_valid ? format_signed_hex_dec(b.vbase_offset) : "unresolved");
      append_line(out, "Base[" + std::to_string(i) + "]", line);
    }
  }

  if (kind_raw.find("pbase_type_info") != std::string::npos ||
      kind_raw.find("pointer_type_info") != std::string::npos ||
      kind_raw.find("pointer_to_member_type_info") != std::string::npos) {
    itanium_abi_rtti::Remote_PBaseTypeInfo pbase;
    if (read_mem(info.typeinfo_ptr, &pbase, sizeof(pbase))) {
      append_line(out, kKeyPBaseFlags, pbase_flags_to_string(pbase.flags));
      uint64_t pointee_ptr = strip_pac(pbase.pointee_type_ptr);
      std::string pointee_raw, pointee_dem;
      if (read_typename_from_typeinfo(pointee_ptr, pointee_raw, pointee_dem)) {
        append_line(out, kKeyPointee, pointee_dem);
        append_line(out, kKeyPointeeRaw, pointee_raw);
      }
    }
  }

  if (kind_raw.find("pointer_to_member_type_info") != std::string::npos) {
    uint64_t context_ptr = 0;
    uint64_t context_addr = info.typeinfo_ptr + sizeof(itanium_abi_rtti::Remote_PBaseTypeInfo);
    if (read_mem(context_addr, &context_ptr, sizeof(context_ptr))) {
      context_ptr = strip_pac(context_ptr);
      std::string ctx_raw, ctx_dem;
      if (read_typename_from_typeinfo(context_ptr, ctx_raw, ctx_dem)) {
        append_line(out, kKeyContext, ctx_dem);
        append_line(out, kKeyContextRaw, ctx_raw);
      }
    }
  }

  if (depth_limit <= 0) depth_limit = kDefaultTreeDepth;
  append_line(out, kKeyTreeDepthLimit, std::to_string(depth_limit));
  std::set<uint64_t> visited;
  build_tree(info.typeinfo_ptr, info.top_addr, info.vtable, 0, 0, depth_limit, nullptr, visited, out);
  return true;
}

static int RTTI_Report_Lua(lua_State* L) {
  if (!g_lua_pushstring || !g_lua_pushboolean) return 0;

  bool isnum = false;
  uint64_t addr = (uint64_t)My_lua_tointeger(L, 1, &isnum);
  if (!isnum || addr == 0) {
    g_lua_pushboolean(L, 0);
    return 1;
  }

  bool isdepth = false;
  int depth = (int)My_lua_tointeger(L, 2, &isdepth);
  if (!isdepth || depth <= 0) depth = kDefaultTreeDepth;

  std::string report;
  build_rtti_report(addr, depth, report);
  g_lua_pushstring(L, report.c_str());
  return 1;
}

static const char* kLuaScript = R"CE(
local ios_rtti_ui = {}

local function ios_rtti_parse_addr(s)
  if s == nil then return nil end
  s = string.gsub(s, "^%s+", "")
  s = string.gsub(s, "%s+$", "")
  if s == "" then return nil end
  if string.sub(s, 1, 2) == "0x" or string.sub(s, 1, 2) == "0X" then
    return tonumber(s)
  end
  if string.find(s, "[a-fA-F]") then
    return tonumber("0x" .. s)
  end
  return tonumber(s)
end

local function ios_rtti_render(report)
  local ui = ios_rtti_ui
  if ui.listSummary == nil or ui.listBases == nil or ui.memoTree == nil then return end

  ui.listSummary.Items.Clear()
  ui.listBases.Items.Clear()
  ui.memoTree.Lines.Text = ''
  if report == nil then return end

  local function tohex(v)
    if v == nil then return '' end
    return string.format('0x%X', v)
  end

  local function parse_hex(s)
    return ios_rtti_parse_addr(s)
  end

  local function find_module(addr)
    if addr == nil or addr == 0 then return nil end
    if enumModules == nil or getModuleSize == nil then return nil end
    local mods = enumModules()
    if mods == nil then return nil end
    for i = 1, #mods do
      local m = mods[i]
      if m ~= nil and m.Address ~= nil and m.Name ~= nil then
        local base = m.Address
        local size = getModuleSize(m.Name)
        if base ~= nil and size ~= nil and addr >= base and addr < (base + size) then
          return m.Name, base, size
        end
      end
    end
    return nil
  end

  local kv = {}
  local bases = {}
  local tree = {}
  local vtable_strip = nil
  local typeinfo_strip = nil

  for line in string.gmatch(report, "[^\r\n]+") do
    local key, value = string.match(line, "^(.-)\t(.*)$")
    if key == nil then
      key = line
      value = ""
    end

    if key == "Tree" then
      table.insert(tree, value)
    elseif string.sub(key, 1, 5) == "Base[" then
      local fields = {}
      for kvpair in string.gmatch(value, "([^;]+)") do
        local k, v = string.match(kvpair, "^(.-)=(.*)$")
        if k ~= nil then fields[k] = v end
      end
      table.insert(bases, fields)
    else
      if key == "VTable (strip)" then
        vtable_strip = parse_hex(value)
      elseif key == "TypeInfo (strip)" then
        typeinfo_strip = parse_hex(value)
      end
      kv[key] = value
    end
  end

  if vtable_strip ~= nil then
    local name, base, size = find_module(vtable_strip)
    if name ~= nil and base ~= nil then
      kv["VTable Module"] = name
      kv["VTable RVA"] = tohex(vtable_strip - base)
    end
  end

  if typeinfo_strip ~= nil then
    local name, base, size = find_module(typeinfo_strip)
    if name ~= nil and base ~= nil then
      kv["TypeInfo Module"] = name
      kv["TypeInfo RVA"] = tohex(typeinfo_strip - base)
    end
  end

  local function raw_equals_strip(strip_key, raw_key)
    if kv[strip_key] == nil or kv[raw_key] == nil then return false end
    return kv[strip_key] == kv[raw_key]
  end

  local function build_csv_table(csv)
    if csv == nil or csv == '' then return {} end
    local t = {}
    for token in string.gmatch(csv, '([^,]+)') do
      token = string.gsub(token, '^%s+', '')
      token = string.gsub(token, '%s+$', '')
      if token ~= '' then table.insert(t, token) end
    end
    return t
  end
  local summary_order = build_csv_table(ios_rtti_summary_order_csv)
  local base_fields = build_csv_table(ios_rtti_base_fields_csv)

  for i = 1, #summary_order do
    local key = summary_order[i]
    local value = kv[key]
    if value ~= nil and value ~= '' then
      if key == "VTable (raw)" and raw_equals_strip("VTable (strip)", "VTable (raw)") then
        value = nil
      elseif key == "TypeInfo (raw)" and raw_equals_strip("TypeInfo (strip)", "TypeInfo (raw)") then
        value = nil
      end
    end
    if value ~= nil and value ~= '' then
      local item = ui.listSummary.Items.Add()
      item.Caption = key
      item.SubItems.Add(value)
    end
  end

  for i, b in ipairs(bases) do
    local item = ui.listBases.Items.Add()
    if #base_fields > 0 then
      item.Caption = b[base_fields[1]] or ""
      for col = 2, #base_fields do
        item.SubItems.Add(b[base_fields[col]] or "")
      end
    end
  end

  if #tree > 0 then
    ui.memoTree.Lines.Text = table.concat(tree, "\n")
  end
end

function ios_rtti_ui_analyze()
  local ui = ios_rtti_ui
  if ui.edtAddr == nil then return end
  local addr = ios_rtti_parse_addr(ui.edtAddr.Text)
  if addr == nil or addr == 0 then return end
  local default_depth = ios_rtti_default_depth
  local depth = nil
  if ui.edtDepth ~= nil then
    local s = ui.edtDepth.Text
    if s ~= nil then
      s = string.gsub(s, "^%s+", "")
      s = string.gsub(s, "%s+$", "")
      if s ~= "" then
        depth = tonumber(s)
      end
    end
  end
  if depth ~= nil and depth <= 0 then
    depth = nil
  end
  if depth == nil or depth <= 0 then
    depth = default_depth
  end
  local report = ios_rtti_report(addr, depth)
  ios_rtti_render(report)
end

function ios_rtti_open()
  local ui = ios_rtti_ui
  if ui.form == nil then
    local f = createForm(false)
    f.Caption = 'RTTI Viewer'
    f.BorderStyle = 'bsSizeable'
    f.BorderIcons = '[biSystemMenu, biMinimize, biMaximize]'
    f.Width = 920
    f.Height = 580

    local top = createPanel(f)
    top.Align = 'alTop'
    top.Height = 30

    local lbl = createLabel(top)
    lbl.Caption = 'Address:'
    lbl.Left = 8
    lbl.Top = 7

    local edt = createEdit(top)
    edt.Left = 70
    edt.Top = 4
    edt.Width = 260

    local lblDepth = createLabel(top)
    lblDepth.Caption = 'Depth:'
    lblDepth.Left = 340
    lblDepth.Top = 7

    local edtDepth = createEdit(top)
    edtDepth.Left = 390
    edtDepth.Top = 4
    edtDepth.Width = 60

    local btn = createButton(top)
    btn.Caption = 'Analyze'
    btn.Left = 460
    btn.Top = 3
    btn.OnClick = ios_rtti_ui_analyze

    local body = createPanel(f)
    body.Align = 'alClient'

    local right = createPanel(body)
    right.Align = 'alRight'
    right.Width = 420

    local splitRight = createSplitter(body)
    splitRight.Align = 'alRight'
    splitRight.Width = 6

    local left = createPanel(body)
    left.Align = 'alClient'

    local grpSummary = createGroupBox(left)
    grpSummary.Caption = 'Summary'
    grpSummary.Align = 'alTop'
    grpSummary.Height = 200

    local lvSummary = createListView(grpSummary)
    lvSummary.Align = 'alClient'
    lvSummary.ViewStyle = 'vsReport'
    lvSummary.ReadOnly = true
    lvSummary.RowSelect = true
    lvSummary.HideSelection = false
    lvSummary.GridLines = true
    lvSummary.Font.Name = 'Consolas'
    lvSummary.Font.Size = 9

    local c = lvSummary.Columns.add()
    c.Caption = 'Field'
    c.Width = 200
    c = lvSummary.Columns.add()
    c.Caption = 'Value'
    c.AutoSize = true

    local splitSummary = createSplitter(left)
    splitSummary.Align = 'alTop'
    splitSummary.Height = 12

    local grpBases = createGroupBox(left)
    grpBases.Caption = 'Bases'
    grpBases.Align = 'alClient'

    local lvBases = createListView(grpBases)
    lvBases.Align = 'alClient'
    lvBases.ViewStyle = 'vsReport'
    lvBases.ReadOnly = true
    lvBases.RowSelect = true
    lvBases.HideSelection = false
    lvBases.GridLines = true
    lvBases.Font.Name = 'Consolas'
    lvBases.Font.Size = 9

    c = lvBases.Columns.add()
    c.Caption = 'Base'
    c.Width = 220
    c = lvBases.Columns.add()
    c.Caption = 'Access'
    c.Width = 70
    c = lvBases.Columns.add()
    c.Caption = 'Virtual'
    c.Width = 60
    c = lvBases.Columns.add()
    c.Caption = 'OffTop'
    c.Width = 160
    c = lvBases.Columns.add()
    c.Caption = 'OffEdge'
    c.Width = 160
    c = lvBases.Columns.add()
    c.Caption = 'BaseAddr'
    c.Width = 150
    c = lvBases.Columns.add()
    c.Caption = 'VTableSlot'
    c.Width = 170
    c = lvBases.Columns.add()
    c.Caption = 'VBaseOff'
    c.AutoSize = true


    local grpTree = createGroupBox(right)
    grpTree.Caption = 'Inheritance Tree'
    grpTree.Align = 'alClient'

    local memo = createMemo(grpTree)
    memo.Align = 'alClient'
    memo.ScrollBars = 'ssBoth'
    memo.ReadOnly = true
    memo.Font.Name = 'Consolas'
    memo.Font.Size = 9

    local function copy_selected(lv, subindex)
      if lv == nil then return end
      local item = lv.Selected
      if item == nil then return end
      local v = item.Caption
      if subindex ~= nil then
        v = item.SubItems[subindex] or item.Caption
      end
      if writeToClipboard ~= nil then
        writeToClipboard(v)
      end
    end

    lvSummary.OnDblClick = function() copy_selected(lvSummary, 0) end
    lvBases.OnDblClick = function() copy_selected(lvBases, 4) end

    f.OnClose = function(sender)
      ios_rtti_ui.form = nil
      ios_rtti_ui.listSummary = nil
      ios_rtti_ui.listBases = nil
      ios_rtti_ui.memoTree = nil
      ios_rtti_ui.edtAddr = nil
      ios_rtti_ui.edtDepth = nil
      return caFree
    end

    ios_rtti_ui.form = f
    ios_rtti_ui.listSummary = lvSummary
    ios_rtti_ui.listBases = lvBases
    ios_rtti_ui.memoTree = memo
    ios_rtti_ui.edtAddr = edt
    ios_rtti_ui.edtDepth = edtDepth
  end

  ios_rtti_ui.form.show()
end
)CE";

static void run_lua_script(lua_State *L, const char *script) {
  if (!g_luaL_loadstring) return;
  if (g_luaL_loadstring(L, script) != 0) {
    lua_pop_all(L);
    return;
  }
  My_lua_pcall(L, 0, 0, 0);
  lua_pop_all(L);
}

static BOOL __stdcall OnMainMenu() {
  if (!g_L || !g_lua_getglobal) return FALSE;
  g_lua_getglobal(g_L, "ios_rtti_open");
  My_lua_pcall(g_L, 0, 0, 0);
  lua_pop_all(g_L);
  return TRUE;
}

static void* RegisterCallbackSafe(void* parameters) {
  lua_State* L = (lua_State*)parameters;
  g_L = L;

  HMODULE hLua = GetModuleHandleA("lua53-64.dll");
  if (!hLua) hLua = GetModuleHandleA("lua53-32.dll");
  if (!hLua) hLua = GetModuleHandleA("lua53.dll");
  if (!hLua) {
    return nullptr;
  }

  g_lua_getglobal = (P_lua_getglobal)GetProcAddress(hLua, "lua_getglobal");
  g_lua_setglobal = (P_lua_setglobal)GetProcAddress(hLua, "lua_setglobal");
  g_lua_pushcclosure = (P_lua_pushcclosure)GetProcAddress(hLua, "lua_pushcclosure");
  g_lua_pushstring = (P_lua_pushstring)GetProcAddress(hLua, "lua_pushstring");
  g_lua_pushboolean = (P_lua_pushboolean)GetProcAddress(hLua, "lua_pushboolean");
  g_lua_pushinteger = (P_lua_pushinteger)GetProcAddress(hLua, "lua_pushinteger");
  g_lua_settop = (P_lua_settop)GetProcAddress(hLua, "lua_settop");
  g_luaL_loadstring = (P_luaL_loadstring)GetProcAddress(hLua, "luaL_loadstring");

  g_lua_pcall = (P_lua_pcall)GetProcAddress(hLua, "lua_pcall");
  if (!g_lua_pcall) {
    g_lua_pcallk = (P_lua_pcallk)GetProcAddress(hLua, "lua_pcallk");
  }

  g_lua_tointegerx = (P_lua_tointegerx)GetProcAddress(hLua, "lua_tointegerx");
  if (!g_lua_tointegerx) {
    g_lua_tointeger = (P_lua_tointeger)GetProcAddress(hLua, "lua_tointeger");
  }

  if (!g_lua_getglobal || !g_lua_pushcclosure || !g_lua_pushstring || !g_lua_pushboolean ||
      (!g_lua_pcall && !g_lua_pcallk) || (!g_lua_tointegerx && !g_lua_tointeger) || !g_luaL_loadstring) {
    return nullptr;
  }

  g_lua_getglobal(L, "registerStructureNameLookup");
  g_lua_pushcclosure(L, RTTI_Name_Lookup_Lua, 0);
  if (My_lua_pcall(L, 1, 0, 0) != 0) {
    lua_pop_all(L);
  }

  g_lua_pushcclosure(L, RTTI_Report_Lua, 0);
  g_lua_setglobal(L, "ios_rtti_report");

  g_lua_pushinteger(L, kDefaultTreeDepth);
  g_lua_setglobal(L, "ios_rtti_default_depth");
  std::string summary_csv = build_csv(kSummaryOrder, kSummaryOrderCount);
  g_lua_pushstring(L, summary_csv.c_str());
  g_lua_setglobal(L, "ios_rtti_summary_order_csv");
  std::string base_fields_csv = build_csv(kBaseFieldOrder, kBaseFieldOrderCount);
  g_lua_pushstring(L, base_fields_csv.c_str());
  g_lua_setglobal(L, "ios_rtti_base_fields_csv");

  run_lua_script(L, kLuaScript);
  return nullptr;
}

extern "C" __attribute__((dllexport)) BOOL __stdcall CEPlugin_GetVersion(PPluginVersion pv, int cbsize) {
  if (cbsize != sizeof(PluginVersion)) return FALSE;
  pv->version = CESDK_VERSION;
  pv->pluginname = (char*)"iOS-RTTI-Viewer";
  return TRUE;
}

extern "C" __attribute__((dllexport)) BOOL __stdcall CEPlugin_InitializePlugin(PExportedFunctions cefuncs_ptr, int pluginid) {
  if (!cefuncs_ptr) return FALSE;
  if (!exported_struct_valid(cefuncs_ptr)) return FALSE;

  g_plugin_id = pluginid;
  g_RegisterFunction = cefuncs_ptr->RegisterFunction;
  g_UnregisterFunction = cefuncs_ptr->UnregisterFunction;

  g_OpenedProcessHandlePtr = cefuncs_ptr->OpenedProcessHandle;
  g_ReadProcessMemoryPtr = (ReadProcessMemory_FuncType*)cefuncs_ptr->ReadProcessMemory;

  if (!g_OpenedProcessHandlePtr || !g_ReadProcessMemoryPtr) return FALSE;

  if (!cefuncs_ptr->GetLuaState) return TRUE;
  lua_State* L = cefuncs_ptr->GetLuaState();
  if (!L) return TRUE;

  if (cefuncs_ptr->MainThreadCall) {
    typedef void (__stdcall *CEP_MAINTHREADCALL)(TPluginFunc func, void* parameters);
    ((CEP_MAINTHREADCALL)cefuncs_ptr->MainThreadCall)(RegisterCallbackSafe, L);
  } else {
    RegisterCallbackSafe(L);
  }

  g_Initialized = true;

  if (g_RegisterFunction) {
    PLUGINTYPE5_INIT mi;
    memset(&mi, 0, sizeof(mi));
    mi.name = (char*)"iOS-RTTI-Viewer";
    mi.callbackroutine = (CEP_PLUGINTYPE5)OnMainMenu;
    mi.shortcut = (char*)"";
    g_menu_id = g_RegisterFunction(pluginid, ptMainMenu, &mi);
  }

  return TRUE;
}

extern "C" __attribute__((dllexport)) BOOL __stdcall CEPlugin_DisablePlugin() {
  if (g_UnregisterFunction && g_menu_id >= 0 && g_plugin_id >= 0) {
    g_UnregisterFunction(g_plugin_id, g_menu_id);
  }
  g_Initialized = false;
  g_OpenedProcessHandlePtr = nullptr;
  g_ReadProcessMemoryPtr = nullptr;

  g_lua_getglobal = nullptr;
  g_lua_setglobal = nullptr;
  g_lua_pushcclosure = nullptr;
  g_lua_pushstring = nullptr;
  g_lua_pushboolean = nullptr;
  g_lua_pushinteger = nullptr;
  g_lua_settop = nullptr;
  g_luaL_loadstring = nullptr;
  g_lua_pcall = nullptr;
  g_lua_pcallk = nullptr;
  g_lua_tointegerx = nullptr;
  g_lua_tointeger = nullptr;
  g_L = nullptr;
  g_RegisterFunction = nullptr;
  g_UnregisterFunction = nullptr;
  g_plugin_id = -1;
  g_menu_id = -1;
  return TRUE;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
  return TRUE;
}

```

`plugin/ios_rtti/itanium_abi_rtti.h`:

```h
#ifndef ITANIUM_ABI_RTTI_H
#define ITANIUM_ABI_RTTI_H

// Reference: llvm-project-main/libcxxabi/src/private_typeinfo.h

#include <cstdint>

namespace itanium_abi_rtti {

// __shim_type_info
struct Remote_TypeInfo {
    uint64_t vtable_ptr;
    uint64_t name_ptr;
};

// __fundamental_type_info
struct Remote_FundamentalTypeInfo : public Remote_TypeInfo {
};

// __class_type_info
struct Remote_ClassTypeInfo : public Remote_TypeInfo {
};

// __si_class_type_info
struct Remote_SiClassTypeInfo : public Remote_ClassTypeInfo {
    uint64_t base_type_ptr;
};

// __base_class_type_info
struct Remote_BaseClassTypeInfo {
    uint64_t base_type_ptr;
    int64_t offset_flags;   // LP64

    static const int64_t virtual_mask = 0x1;
    static const int64_t public_mask  = 0x2;
    static const int64_t offset_shift = 8;
};

// __vmi_class_type_info
struct Remote_VmiClassTypeInfo : public Remote_ClassTypeInfo {
    uint32_t flags;
    uint32_t base_count;

    enum Flags {
        non_diamond_repeat_mask = 0x1,
        diamond_shaped_mask = 0x2
    };
};

// __pbase_type_info
struct Remote_PBaseTypeInfo : public Remote_TypeInfo {
    uint32_t flags;
    uint32_t _padding;
    uint64_t pointee_type_ptr;

    enum Masks {
        const_mask = 0x1,
        volatile_mask = 0x2,
        restrict_mask = 0x4,
        incomplete_mask = 0x8,
        incomplete_class_mask = 0x10,
        transaction_safe_mask = 0x20,
        noexcept_mask = 0x40
    };
};

} // namespace itanium_abi_rtti

#endif 

```

`plugin/ios_rtti/llvm/include/llvm/Config/llvm-config.h`:

```h
#define LLVM_ENABLE_LLVM_EXPORT_ANNOTATIONS 0

```

`plugin/ios_rtti/llvm/include/llvm/Demangle/Demangle.h`:

```h
//===--- Demangle.h ---------------------------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_DEMANGLE_DEMANGLE_H
#define LLVM_DEMANGLE_DEMANGLE_H

#include "llvm/Demangle/DemangleConfig.h"
#include <cstddef>
#include <optional>
#include <string>
#include <string_view>

namespace llvm {
/// This is a llvm local version of __cxa_demangle. Other than the name and
/// being in the llvm namespace it is identical.
///
/// The mangled_name is demangled into buf and returned. If the buffer is not
/// large enough, realloc is used to expand it.
///
/// The *status will be set to a value from the following enumeration
enum : int {
  demangle_unknown_error = -4,
  demangle_invalid_args = -3,
  demangle_invalid_mangled_name = -2,
  demangle_memory_alloc_failure = -1,
  demangle_success = 0,
};

/// Returns a non-NULL pointer to a NUL-terminated C style string
/// that should be explicitly freed, if successful. Otherwise, may return
/// nullptr if mangled_name is not a valid mangling or is nullptr.
DEMANGLE_ABI char *itaniumDemangle(std::string_view mangled_name,
                                   bool ParseParams = true);

enum MSDemangleFlags {
  MSDF_None = 0,
  MSDF_DumpBackrefs = 1 << 0,
  MSDF_NoAccessSpecifier = 1 << 1,
  MSDF_NoCallingConvention = 1 << 2,
  MSDF_NoReturnType = 1 << 3,
  MSDF_NoMemberType = 1 << 4,
  MSDF_NoVariableType = 1 << 5,
};

/// Demangles the Microsoft symbol pointed at by mangled_name and returns it.
/// Returns a pointer to the start of a null-terminated demangled string on
/// success, or nullptr on error.
/// If n_read is non-null and demangling was successful, it receives how many
/// bytes of the input string were consumed.
/// status receives one of the demangle_ enum entries above if it's not nullptr.
/// Flags controls various details of the demangled representation.
DEMANGLE_ABI char *microsoftDemangle(std::string_view mangled_name,
                                     size_t *n_read, int *status,
                                     MSDemangleFlags Flags = MSDF_None);

DEMANGLE_ABI std::optional<size_t>
getArm64ECInsertionPointInMangledName(std::string_view MangledName);

// Demangles a Rust v0 mangled symbol.
DEMANGLE_ABI char *rustDemangle(std::string_view MangledName);

// Demangles a D mangled symbol.
DEMANGLE_ABI char *dlangDemangle(std::string_view MangledName);

/// Attempt to demangle a string using different demangling schemes.
/// The function uses heuristics to determine which demangling scheme to use.
/// \param MangledName - reference to string to demangle.
/// \returns - the demangled string, or a copy of the input string if no
/// demangling occurred.
DEMANGLE_ABI std::string demangle(std::string_view MangledName);

DEMANGLE_ABI bool nonMicrosoftDemangle(std::string_view MangledName,
                                       std::string &Result,
                                       bool CanHaveLeadingDot = true,
                                       bool ParseParams = true);

/// "Partial" demangler. This supports demangling a string into an AST
/// (typically an intermediate stage in itaniumDemangle) and querying certain
/// properties or partially printing the demangled name.
struct ItaniumPartialDemangler {
  DEMANGLE_ABI ItaniumPartialDemangler();

  DEMANGLE_ABI ItaniumPartialDemangler(ItaniumPartialDemangler &&Other);
  DEMANGLE_ABI ItaniumPartialDemangler &
  operator=(ItaniumPartialDemangler &&Other);

  /// Demangle into an AST. Subsequent calls to the rest of the member functions
  /// implicitly operate on the AST this produces.
  /// \return true on error, false otherwise
  DEMANGLE_ABI bool partialDemangle(const char *MangledName);

  /// Just print the entire mangled name into Buf. Buf and N behave like the
  /// second and third parameters to __cxa_demangle.
  DEMANGLE_ABI char *finishDemangle(char *Buf, size_t *N) const;

  /// See \ref finishDemangle
  ///
  /// \param[in] OB A llvm::itanium_demangle::OutputBuffer that the demangled
  /// name will be printed into.
  ///
  DEMANGLE_ABI char *finishDemangle(void *OB) const;

  /// Get the base name of a function. This doesn't include trailing template
  /// arguments, ie for "a::b<int>" this function returns "b".
  DEMANGLE_ABI char *getFunctionBaseName(char *Buf, size_t *N) const;

  /// Get the context name for a function. For "a::b::c", this function returns
  /// "a::b".
  DEMANGLE_ABI char *getFunctionDeclContextName(char *Buf, size_t *N) const;

  /// Get the entire name of this function.
  DEMANGLE_ABI char *getFunctionName(char *Buf, size_t *N) const;

  /// Get the parameters for this function.
  DEMANGLE_ABI char *getFunctionParameters(char *Buf, size_t *N) const;
  DEMANGLE_ABI char *getFunctionReturnType(char *Buf, size_t *N) const;

  /// If this function has any cv or reference qualifiers. These imply that
  /// the function is a non-static member function.
  DEMANGLE_ABI bool hasFunctionQualifiers() const;

  /// If this symbol describes a constructor or destructor.
  DEMANGLE_ABI bool isCtorOrDtor() const;

  /// If this symbol describes a function.
  DEMANGLE_ABI bool isFunction() const;

  /// If this symbol describes a variable.
  DEMANGLE_ABI bool isData() const;

  /// If this symbol is a <special-name>. These are generally implicitly
  /// generated by the implementation, such as vtables and typeinfo names.
  DEMANGLE_ABI bool isSpecialName() const;

  DEMANGLE_ABI ~ItaniumPartialDemangler();

private:
  void *RootNode;
  void *Context;
};
} // namespace llvm

#endif

```

`plugin/ios_rtti/llvm/include/llvm/Demangle/DemangleConfig.h`:

```h
//===--- DemangleConfig.h ---------------------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file contains a variety of feature test macros copied from
// include/llvm/Support/Compiler.h so that LLVMDemangle does not need to take
// a dependency on LLVMSupport.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_DEMANGLE_DEMANGLECONFIG_H
#define LLVM_DEMANGLE_DEMANGLECONFIG_H

// Removed external config dependency for standalone build
// #include "llvm/Config/llvm-config.h"

#ifndef __has_feature
#define __has_feature(x) 0
#endif

#ifndef __has_cpp_attribute
#define __has_cpp_attribute(x) 0
#endif

#ifndef __has_attribute
#define __has_attribute(x) 0
#endif

#ifndef __has_builtin
#define __has_builtin(x) 0
#endif

#ifndef DEMANGLE_GNUC_PREREQ
#if defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)
#define DEMANGLE_GNUC_PREREQ(maj, min, patch)                           \
  ((__GNUC__ << 20) + (__GNUC_MINOR__ << 10) + __GNUC_PATCHLEVEL__ >=          \
   ((maj) << 20) + ((min) << 10) + (patch))
#elif defined(__GNUC__) && defined(__GNUC_MINOR__)
#define DEMANGLE_GNUC_PREREQ(maj, min, patch)                           \
  ((__GNUC__ << 20) + (__GNUC_MINOR__ << 10) >= ((maj) << 20) + ((min) << 10))
#else
#define DEMANGLE_GNUC_PREREQ(maj, min, patch) 0
#endif
#endif

#if __has_attribute(used) || DEMANGLE_GNUC_PREREQ(3, 1, 0)
#define DEMANGLE_ATTRIBUTE_USED __attribute__((__used__))
#else
#define DEMANGLE_ATTRIBUTE_USED
#endif

#if __has_builtin(__builtin_unreachable) || DEMANGLE_GNUC_PREREQ(4, 5, 0)
#define DEMANGLE_UNREACHABLE __builtin_unreachable()
#elif defined(_MSC_VER)
#define DEMANGLE_UNREACHABLE __assume(false)
#else
#define DEMANGLE_UNREACHABLE
#endif

#if __has_attribute(noinline) || DEMANGLE_GNUC_PREREQ(3, 4, 0)
#define DEMANGLE_ATTRIBUTE_NOINLINE __attribute__((noinline))
#elif defined(_MSC_VER)
#define DEMANGLE_ATTRIBUTE_NOINLINE __declspec(noinline)
#else
#define DEMANGLE_ATTRIBUTE_NOINLINE
#endif

#if !defined(NDEBUG)
#define DEMANGLE_DUMP_METHOD DEMANGLE_ATTRIBUTE_NOINLINE DEMANGLE_ATTRIBUTE_USED
#else
#define DEMANGLE_DUMP_METHOD DEMANGLE_ATTRIBUTE_NOINLINE
#endif

#if __cplusplus > 201402L && __has_cpp_attribute(fallthrough)
#define DEMANGLE_FALLTHROUGH [[fallthrough]]
#elif __has_cpp_attribute(gnu::fallthrough)
#define DEMANGLE_FALLTHROUGH [[gnu::fallthrough]]
#elif !__cplusplus
// Workaround for llvm.org/PR23435, since clang 3.6 and below emit a spurious
// error when __has_cpp_attribute is given a scoped attribute in C mode.
#define DEMANGLE_FALLTHROUGH
#elif __has_cpp_attribute(clang::fallthrough)
#define DEMANGLE_FALLTHROUGH [[clang::fallthrough]]
#else
#define DEMANGLE_FALLTHROUGH
#endif

#ifndef DEMANGLE_ASSERT
#include <cassert>
#define DEMANGLE_ASSERT(__expr, __msg) assert((__expr) && (__msg))
#endif

#define DEMANGLE_NAMESPACE_BEGIN namespace llvm { namespace itanium_demangle {
#define DEMANGLE_NAMESPACE_END } }

// Force empty ABI macro for static build (removes dllexport/dllimport)
#define DEMANGLE_ABI

#endif


```

`plugin/ios_rtti/llvm/include/llvm/Demangle/ItaniumDemangle.h`:

```h
//===--- ItaniumDemangle.h -----------*- mode:c++;eval:(read-only-mode) -*-===//
//       Do not edit! See README.txt.
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// Generic itanium demangler library.
// There are two copies of this file in the source tree.  The one under
// libcxxabi is the original and the one under llvm is the copy.  Use
// cp-to-llvm.sh to update the copy.  See README.txt for more details.
//
//===----------------------------------------------------------------------===//

#ifndef DEMANGLE_ITANIUMDEMANGLE_H
#define DEMANGLE_ITANIUMDEMANGLE_H

#include "DemangleConfig.h"
#include "StringViewExtras.h"
#include "Utility.h"
#include <algorithm>
#include <cctype>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <limits>
#include <new>
#include <string_view>
#include <type_traits>
#include <utility>

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-template"
#endif

DEMANGLE_NAMESPACE_BEGIN

template <class T, size_t N> class PODSmallVector {
  static_assert(std::is_trivially_copyable<T>::value,
                "T is required to be a trivially copyable type");
  static_assert(std::is_trivially_default_constructible<T>::value,
                "T is required to be trivially default constructible");
  T *First = nullptr;
  T *Last = nullptr;
  T *Cap = nullptr;
  T Inline[N] = {};

  bool isInline() const { return First == Inline; }

  void clearInline() {
    First = Inline;
    Last = Inline;
    Cap = Inline + N;
  }

  void reserve(size_t NewCap) {
    size_t S = size();
    if (isInline()) {
      auto *Tmp = static_cast<T *>(std::malloc(NewCap * sizeof(T)));
      if (Tmp == nullptr)
        std::abort();
      std::copy(First, Last, Tmp);
      First = Tmp;
    } else {
      First = static_cast<T *>(std::realloc(First, NewCap * sizeof(T)));
      if (First == nullptr)
        std::abort();
    }
    Last = First + S;
    Cap = First + NewCap;
  }

public:
  PODSmallVector() : First(Inline), Last(First), Cap(Inline + N) {}

  PODSmallVector(const PODSmallVector &) = delete;
  PODSmallVector &operator=(const PODSmallVector &) = delete;

  PODSmallVector(PODSmallVector &&Other) : PODSmallVector() {
    if (Other.isInline()) {
      std::copy(Other.begin(), Other.end(), First);
      Last = First + Other.size();
      Other.clear();
      return;
    }

    First = Other.First;
    Last = Other.Last;
    Cap = Other.Cap;
    Other.clearInline();
  }

  PODSmallVector &operator=(PODSmallVector &&Other) {
    if (Other.isInline()) {
      if (!isInline()) {
        std::free(First);
        clearInline();
      }
      std::copy(Other.begin(), Other.end(), First);
      Last = First + Other.size();
      Other.clear();
      return *this;
    }

    if (isInline()) {
      First = Other.First;
      Last = Other.Last;
      Cap = Other.Cap;
      Other.clearInline();
      return *this;
    }

    std::swap(First, Other.First);
    std::swap(Last, Other.Last);
    std::swap(Cap, Other.Cap);
    Other.clear();
    return *this;
  }

  // NOLINTNEXTLINE(readability-identifier-naming)
  void push_back(const T &Elem) {
    if (Last == Cap)
      reserve(size() * 2);
    *Last++ = Elem;
  }

  // NOLINTNEXTLINE(readability-identifier-naming)
  void pop_back() {
    DEMANGLE_ASSERT(Last != First, "Popping empty vector!");
    --Last;
  }

  void shrinkToSize(size_t Index) {
    DEMANGLE_ASSERT(Index <= size(), "shrinkToSize() can't expand!");
    Last = First + Index;
  }

  T *begin() { return First; }
  T *end() { return Last; }

  bool empty() const { return First == Last; }
  size_t size() const { return static_cast<size_t>(Last - First); }
  T &back() {
    DEMANGLE_ASSERT(Last != First, "Calling back() on empty vector!");
    return *(Last - 1);
  }
  T &operator[](size_t Index) {
    DEMANGLE_ASSERT(Index < size(), "Invalid access!");
    return *(begin() + Index);
  }
  void clear() { Last = First; }

  ~PODSmallVector() {
    if (!isInline())
      std::free(First);
  }
};

class NodeArray;

// Base class of all AST nodes. The AST is built by the parser, then is
// traversed by the printLeft/Right functions to produce a demangled string.
class Node {
public:
  enum Kind : uint8_t {
#define NODE(NodeKind) K##NodeKind,
#include "ItaniumNodes.def"
  };

  /// Three-way bool to track a cached value. Unknown is possible if this node
  /// has an unexpanded parameter pack below it that may affect this cache.
  enum class Cache : uint8_t { Yes, No, Unknown, };

  /// Operator precedence for expression nodes. Used to determine required
  /// parens in expression emission.
  enum class Prec : uint8_t {
    Primary,
    Postfix,
    Unary,
    Cast,
    PtrMem,
    Multiplicative,
    Additive,
    Shift,
    Spaceship,
    Relational,
    Equality,
    And,
    Xor,
    Ior,
    AndIf,
    OrIf,
    Conditional,
    Assign,
    Comma,
    Default,
  };

private:
  Kind K;

  Prec Precedence : 6;

protected:
  /// Tracks if this node has a component on its right side, in which case we
  /// need to call printRight.
  Cache RHSComponentCache : 2;

  /// Track if this node is a (possibly qualified) array type. This can affect
  /// how we format the output string.
  Cache ArrayCache : 2;

  /// Track if this node is a (possibly qualified) function type. This can
  /// affect how we format the output string.
  Cache FunctionCache : 2;

public:
  Node(Kind K_, Prec Precedence_ = Prec::Primary,
       Cache RHSComponentCache_ = Cache::No, Cache ArrayCache_ = Cache::No,
       Cache FunctionCache_ = Cache::No)
      : K(K_), Precedence(Precedence_), RHSComponentCache(RHSComponentCache_),
        ArrayCache(ArrayCache_), FunctionCache(FunctionCache_) {}
  Node(Kind K_, Cache RHSComponentCache_, Cache ArrayCache_ = Cache::No,
       Cache FunctionCache_ = Cache::No)
      : Node(K_, Prec::Primary, RHSComponentCache_, ArrayCache_,
             FunctionCache_) {}

  /// Visit the most-derived object corresponding to this object.
  template<typename Fn> void visit(Fn F) const;

  // The following function is provided by all derived classes:
  //
  // Call F with arguments that, when passed to the constructor of this node,
  // would construct an equivalent node.
  //template<typename Fn> void match(Fn F) const;

  bool hasRHSComponent(OutputBuffer &OB) const {
    if (RHSComponentCache != Cache::Unknown)
      return RHSComponentCache == Cache::Yes;
    return hasRHSComponentSlow(OB);
  }

  bool hasArray(OutputBuffer &OB) const {
    if (ArrayCache != Cache::Unknown)
      return ArrayCache == Cache::Yes;
    return hasArraySlow(OB);
  }

  bool hasFunction(OutputBuffer &OB) const {
    if (FunctionCache != Cache::Unknown)
      return FunctionCache == Cache::Yes;
    return hasFunctionSlow(OB);
  }

  Kind getKind() const { return K; }

  Prec getPrecedence() const { return Precedence; }
  Cache getRHSComponentCache() const { return RHSComponentCache; }
  Cache getArrayCache() const { return ArrayCache; }
  Cache getFunctionCache() const { return FunctionCache; }

  virtual bool hasRHSComponentSlow(OutputBuffer &) const { return false; }
  virtual bool hasArraySlow(OutputBuffer &) const { return false; }
  virtual bool hasFunctionSlow(OutputBuffer &) const { return false; }

  // Dig through "glue" nodes like ParameterPack and ForwardTemplateReference to
  // get at a node that actually represents some concrete syntax.
  virtual const Node *getSyntaxNode(OutputBuffer &) const { return this; }

  // Print this node as an expression operand, surrounding it in parentheses if
  // its precedence is [Strictly] weaker than P.
  void printAsOperand(OutputBuffer &OB, Prec P = Prec::Default,
                      bool StrictlyWorse = false) const {
    bool Paren =
        unsigned(getPrecedence()) >= unsigned(P) + unsigned(StrictlyWorse);
    if (Paren)
      OB.printOpen();
    print(OB);
    if (Paren)
      OB.printClose();
  }

  void print(OutputBuffer &OB) const {
    OB.printLeft(*this);
    if (RHSComponentCache != Cache::No)
      OB.printRight(*this);
  }

  // Print an initializer list of this type. Returns true if we printed a custom
  // representation, false if nothing has been printed and the default
  // representation should be used.
  virtual bool printInitListAsType(OutputBuffer &, const NodeArray &) const {
    return false;
  }

  virtual std::string_view getBaseName() const { return {}; }

  // Silence compiler warnings, this dtor will never be called.
  virtual ~Node() = default;

#ifndef NDEBUG
  DEMANGLE_DUMP_METHOD void dump() const;
#endif

private:
  friend class OutputBuffer;

  // Print the "left" side of this Node into OutputBuffer.
  //
  // Note, should only be called from OutputBuffer implementations.
  // Call \ref OutputBuffer::printLeft instead.
  virtual void printLeft(OutputBuffer &) const = 0;

  // Print the "right". This distinction is necessary to represent C++ types
  // that appear on the RHS of their subtype, such as arrays or functions.
  // Since most types don't have such a component, provide a default
  // implementation.
  //
  // Note, should only be called from OutputBuffer implementations.
  // Call \ref OutputBuffer::printRight instead.
  virtual void printRight(OutputBuffer &) const {}
};

class NodeArray {
  Node **Elements;
  size_t NumElements;

public:
  NodeArray() : Elements(nullptr), NumElements(0) {}
  NodeArray(Node **Elements_, size_t NumElements_)
      : Elements(Elements_), NumElements(NumElements_) {}

  bool empty() const { return NumElements == 0; }
  size_t size() const { return NumElements; }

  Node **begin() const { return Elements; }
  Node **end() const { return Elements + NumElements; }

  Node *operator[](size_t Idx) const { return Elements[Idx]; }

  void printWithComma(OutputBuffer &OB) const {
    bool FirstElement = true;
    for (size_t Idx = 0; Idx != NumElements; ++Idx) {
      size_t BeforeComma = OB.getCurrentPosition();
      if (!FirstElement)
        OB += ", ";
      size_t AfterComma = OB.getCurrentPosition();
      Elements[Idx]->printAsOperand(OB, Node::Prec::Comma);

      // Elements[Idx] is an empty parameter pack expansion, we should erase the
      // comma we just printed.
      if (AfterComma == OB.getCurrentPosition()) {
        OB.setCurrentPosition(BeforeComma);
        continue;
      }

      FirstElement = false;
    }
  }

  // Print an array of integer literals as a string literal. Returns whether we
  // could do so.
  bool printAsString(OutputBuffer &OB) const;
};

struct NodeArrayNode : Node {
  NodeArray Array;
  NodeArrayNode(NodeArray Array_) : Node(KNodeArrayNode), Array(Array_) {}

  template<typename Fn> void match(Fn F) const { F(Array); }

  void printLeft(OutputBuffer &OB) const override { Array.printWithComma(OB); }
};

class DotSuffix final : public Node {
  const Node *Prefix;
  const std::string_view Suffix;

public:
  DotSuffix(const Node *Prefix_, std::string_view Suffix_)
      : Node(KDotSuffix), Prefix(Prefix_), Suffix(Suffix_) {}

  template<typename Fn> void match(Fn F) const { F(Prefix, Suffix); }

  void printLeft(OutputBuffer &OB) const override {
    Prefix->print(OB);
    OB += " (";
    OB += Suffix;
    OB += ")";
  }
};

class VendorExtQualType final : public Node {
  const Node *Ty;
  std::string_view Ext;
  const Node *TA;

public:
  VendorExtQualType(const Node *Ty_, std::string_view Ext_, const Node *TA_)
      : Node(KVendorExtQualType), Ty(Ty_), Ext(Ext_), TA(TA_) {}

  const Node *getTy() const { return Ty; }
  std::string_view getExt() const { return Ext; }
  const Node *getTA() const { return TA; }

  template <typename Fn> void match(Fn F) const { F(Ty, Ext, TA); }

  void printLeft(OutputBuffer &OB) const override {
    Ty->print(OB);
    OB += " ";
    OB += Ext;
    if (TA != nullptr)
      TA->print(OB);
  }
};

enum FunctionRefQual : unsigned char {
  FrefQualNone,
  FrefQualLValue,
  FrefQualRValue,
};

enum Qualifiers {
  QualNone = 0,
  QualConst = 0x1,
  QualVolatile = 0x2,
  QualRestrict = 0x4,
};

inline Qualifiers operator|=(Qualifiers &Q1, Qualifiers Q2) {
  return Q1 = static_cast<Qualifiers>(Q1 | Q2);
}

class QualType final : public Node {
protected:
  const Qualifiers Quals;
  const Node *Child;

  void printQuals(OutputBuffer &OB) const {
    if (Quals & QualConst)
      OB += " const";
    if (Quals & QualVolatile)
      OB += " volatile";
    if (Quals & QualRestrict)
      OB += " restrict";
  }

public:
  QualType(const Node *Child_, Qualifiers Quals_)
      : Node(KQualType, Child_->getRHSComponentCache(), Child_->getArrayCache(),
             Child_->getFunctionCache()),
        Quals(Quals_), Child(Child_) {}

  Qualifiers getQuals() const { return Quals; }
  const Node *getChild() const { return Child; }

  template<typename Fn> void match(Fn F) const { F(Child, Quals); }

  bool hasRHSComponentSlow(OutputBuffer &OB) const override {
    return Child->hasRHSComponent(OB);
  }
  bool hasArraySlow(OutputBuffer &OB) const override {
    return Child->hasArray(OB);
  }
  bool hasFunctionSlow(OutputBuffer &OB) const override {
    return Child->hasFunction(OB);
  }

  void printLeft(OutputBuffer &OB) const override {
    OB.printLeft(*Child);
    printQuals(OB);
  }

  void printRight(OutputBuffer &OB) const override { OB.printRight(*Child); }
};

class ConversionOperatorType final : public Node {
  const Node *Ty;

public:
  ConversionOperatorType(const Node *Ty_)
      : Node(KConversionOperatorType), Ty(Ty_) {}

  template<typename Fn> void match(Fn F) const { F(Ty); }

  void printLeft(OutputBuffer &OB) const override {
    OB += "operator ";
    Ty->print(OB);
  }
};

class PostfixQualifiedType final : public Node {
  const Node *Ty;
  const std::string_view Postfix;

public:
  PostfixQualifiedType(const Node *Ty_, std::string_view Postfix_)
      : Node(KPostfixQualifiedType), Ty(Ty_), Postfix(Postfix_) {}

  template<typename Fn> void match(Fn F) const { F(Ty, Postfix); }

  void printLeft(OutputBuffer &OB) const override {
    OB.printLeft(*Ty);
    OB += Postfix;
  }
};

class NameType final : public Node {
  const std::string_view Name;

public:
  NameType(std::string_view Name_) : Node(KNameType), Name(Name_) {}

  template<typename Fn> void match(Fn F) const { F(Name); }

  std::string_view getName() const { return Name; }
  std::string_view getBaseName() const override { return Name; }

  void printLeft(OutputBuffer &OB) const override { OB += Name; }
};

class BitIntType final : public Node {
  const Node *Size;
  bool Signed;

public:
  BitIntType(const Node *Size_, bool Signed_)
      : Node(KBitIntType), Size(Size_), Signed(Signed_) {}

  template <typename Fn> void match(Fn F) const { F(Size, Signed); }

  void printLeft(OutputBuffer &OB) const override {
    if (!Signed)
      OB += "unsigned ";
    OB += "_BitInt";
    OB.printOpen();
    Size->printAsOperand(OB);
    OB.printClose();
  }
};

class ElaboratedTypeSpefType : public Node {
  std::string_view Kind;
  Node *Child;
public:
  ElaboratedTypeSpefType(std::string_view Kind_, Node *Child_)
      : Node(KElaboratedTypeSpefType), Kind(Kind_), Child(Child_) {}

  template<typename Fn> void match(Fn F) const { F(Kind, Child); }

  void printLeft(OutputBuffer &OB) const override {
    OB += Kind;
    OB += ' ';
    Child->print(OB);
  }
};

class TransformedType : public Node {
  std::string_view Transform;
  Node *BaseType;
public:
  TransformedType(std::string_view Transform_, Node *BaseType_)
      : Node(KTransformedType), Transform(Transform_), BaseType(BaseType_) {}

  template<typename Fn> void match(Fn F) const { F(Transform, BaseType); }

  void printLeft(OutputBuffer &OB) const override {
    OB += Transform;
    OB += '(';
    BaseType->print(OB);
    OB += ')';
  }
};

struct AbiTagAttr : Node {
  Node *Base;
  std::string_view Tag;

  AbiTagAttr(Node *Base_, std::string_view Tag_)
      : Node(KAbiTagAttr, Base_->getRHSComponentCache(), Base_->getArrayCache(),
             Base_->getFunctionCache()),
        Base(Base_), Tag(Tag_) {}

  template<typename Fn> void match(Fn F) const { F(Base, Tag); }

  std::string_view getBaseName() const override { return Base->getBaseName(); }

  void printLeft(OutputBuffer &OB) const override {
    OB.printLeft(*Base);
    OB += "[abi:";
    OB += Tag;
    OB += "]";
  }
};

class EnableIfAttr : public Node {
  NodeArray Conditions;
public:
  EnableIfAttr(NodeArray Conditions_)
      : Node(KEnableIfAttr), Conditions(Conditions_) {}

  template<typename Fn> void match(Fn F) const { F(Conditions); }

  void printLeft(OutputBuffer &OB) const override {
    OB += " [enable_if:";
    Conditions.printWithComma(OB);
    OB += ']';
  }
};

class ObjCProtoName : public Node {
  const Node *Ty;
  std::string_view Protocol;

public:
  ObjCProtoName(const Node *Ty_, std::string_view Protocol_)
      : Node(KObjCProtoName), Ty(Ty_), Protocol(Protocol_) {}

  template<typename Fn> void match(Fn F) const { F(Ty, Protocol); }

  bool isObjCObject() const {
    return Ty->getKind() == KNameType &&
           static_cast<const NameType *>(Ty)->getName() == "objc_object";
  }

  std::string_view getProtocol() const { return Protocol; }

  void printLeft(OutputBuffer &OB) const override {
    Ty->print(OB);
    OB += "<";
    OB += Protocol;
    OB += ">";
  }
};

class PointerType final : public Node {
  const Node *Pointee;

public:
  PointerType(const Node *Pointee_)
      : Node(KPointerType, Pointee_->getRHSComponentCache()),
        Pointee(Pointee_) {}

  const Node *getPointee() const { return Pointee; }

  template<typename Fn> void match(Fn F) const { F(Pointee); }

  bool hasRHSComponentSlow(OutputBuffer &OB) const override {
    return Pointee->hasRHSComponent(OB);
  }

  void printLeft(OutputBuffer &OB) const override {
    // We rewrite objc_object<SomeProtocol>* into id<SomeProtocol>.
    if (Pointee->getKind() != KObjCProtoName ||
        !static_cast<const ObjCProtoName *>(Pointee)->isObjCObject()) {
      OB.printLeft(*Pointee);
      if (Pointee->hasArray(OB))
        OB += " ";
      if (Pointee->hasArray(OB) || Pointee->hasFunction(OB))
        OB += "(";
      OB += "*";
    } else {
      const auto *objcProto = static_cast<const ObjCProtoName *>(Pointee);
      OB += "id<";
      OB += objcProto->getProtocol();
      OB += ">";
    }
  }

  void printRight(OutputBuffer &OB) const override {
    if (Pointee->getKind() != KObjCProtoName ||
        !static_cast<const ObjCProtoName *>(Pointee)->isObjCObject()) {
      if (Pointee->hasArray(OB) || Pointee->hasFunction(OB))
        OB += ")";
      OB.printRight(*Pointee);
    }
  }
};

enum class ReferenceKind {
  LValue,
  RValue,
};

// Represents either a LValue or an RValue reference type.
class ReferenceType : public Node {
  const Node *Pointee;
  ReferenceKind RK;

  mutable bool Printing = false;

  // Dig through any refs to refs, collapsing the ReferenceTypes as we go. The
  // rule here is rvalue ref to rvalue ref collapses to a rvalue ref, and any
  // other combination collapses to a lvalue ref.
  //
  // A combination of a TemplateForwardReference and a back-ref Substitution
  // from an ill-formed string may have created a cycle; use cycle detection to
  // avoid looping forever.
  std::pair<ReferenceKind, const Node *> collapse(OutputBuffer &OB) const {
    auto SoFar = std::make_pair(RK, Pointee);
    // Track the chain of nodes for the Floyd's 'tortoise and hare'
    // cycle-detection algorithm, since getSyntaxNode(S) is impure
    PODSmallVector<const Node *, 8> Prev;
    for (;;) {
      const Node *SN = SoFar.second->getSyntaxNode(OB);
      if (SN->getKind() != KReferenceType)
        break;
      auto *RT = static_cast<const ReferenceType *>(SN);
      SoFar.second = RT->Pointee;
      SoFar.first = std::min(SoFar.first, RT->RK);

      // The middle of Prev is the 'slow' pointer moving at half speed
      Prev.push_back(SoFar.second);
      if (Prev.size() > 1 && SoFar.second == Prev[(Prev.size() - 1) / 2]) {
        // Cycle detected
        SoFar.second = nullptr;
        break;
      }
    }
    return SoFar;
  }

public:
  ReferenceType(const Node *Pointee_, ReferenceKind RK_)
      : Node(KReferenceType, Pointee_->getRHSComponentCache()),
        Pointee(Pointee_), RK(RK_) {}

  template<typename Fn> void match(Fn F) const { F(Pointee, RK); }

  bool hasRHSComponentSlow(OutputBuffer &OB) const override {
    return Pointee->hasRHSComponent(OB);
  }

  void printLeft(OutputBuffer &OB) const override {
    if (Printing)
      return;
    ScopedOverride<bool> SavePrinting(Printing, true);
    std::pair<ReferenceKind, const Node *> Collapsed = collapse(OB);
    if (!Collapsed.second)
      return;
    OB.printLeft(*Collapsed.second);
    if (Collapsed.second->hasArray(OB))
      OB += " ";
    if (Collapsed.second->hasArray(OB) || Collapsed.second->hasFunction(OB))
      OB += "(";

    OB += (Collapsed.first == ReferenceKind::LValue ? "&" : "&&");
  }
  void printRight(OutputBuffer &OB) const override {
    if (Printing)
      return;
    ScopedOverride<bool> SavePrinting(Printing, true);
    std::pair<ReferenceKind, const Node *> Collapsed = collapse(OB);
    if (!Collapsed.second)
      return;
    if (Collapsed.second->hasArray(OB) || Collapsed.second->hasFunction(OB))
      OB += ")";
    OB.printRight(*Collapsed.second);
  }
};

class PointerToMemberType final : public Node {
  const Node *ClassType;
  const Node *MemberType;

public:
  PointerToMemberType(const Node *ClassType_, const Node *MemberType_)
      : Node(KPointerToMemberType, MemberType_->getRHSComponentCache()),
        ClassType(ClassType_), MemberType(MemberType_) {}

  template<typename Fn> void match(Fn F) const { F(ClassType, MemberType); }

  bool hasRHSComponentSlow(OutputBuffer &OB) const override {
    return MemberType->hasRHSComponent(OB);
  }

  void printLeft(OutputBuffer &OB) const override {
    OB.printLeft(*MemberType);
    if (MemberType->hasArray(OB) || MemberType->hasFunction(OB))
      OB += "(";
    else
      OB += " ";
    ClassType->print(OB);
    OB += "::*";
  }

  void printRight(OutputBuffer &OB) const override {
    if (MemberType->hasArray(OB) || MemberType->hasFunction(OB))
      OB += ")";
    OB.printRight(*MemberType);
  }
};

class ArrayType final : public Node {
  const Node *Base;
  Node *Dimension;

public:
  ArrayType(const Node *Base_, Node *Dimension_)
      : Node(KArrayType,
             /*RHSComponentCache=*/Cache::Yes,
             /*ArrayCache=*/Cache::Yes),
        Base(Base_), Dimension(Dimension_) {}

  template<typename Fn> void match(Fn F) const { F(Base, Dimension); }

  bool hasRHSComponentSlow(OutputBuffer &) const override { return true; }
  bool hasArraySlow(OutputBuffer &) const override { return true; }

  void printLeft(OutputBuffer &OB) const override { OB.printLeft(*Base); }

  void printRight(OutputBuffer &OB) const override {
    if (OB.back() != ']')
      OB += " ";
    OB += "[";
    if (Dimension)
      Dimension->print(OB);
    OB += "]";
    OB.printRight(*Base);
  }

  bool printInitListAsType(OutputBuffer &OB,
                           const NodeArray &Elements) const override {
    if (Base->getKind() == KNameType &&
        static_cast<const NameType *>(Base)->getName() == "char") {
      return Elements.printAsString(OB);
    }
    return false;
  }
};

class FunctionType final : public Node {
  const Node *Ret;
  NodeArray Params;
  Qualifiers CVQuals;
  FunctionRefQual RefQual;
  const Node *ExceptionSpec;

public:
  FunctionType(const Node *Ret_, NodeArray Params_, Qualifiers CVQuals_,
               FunctionRefQual RefQual_, const Node *ExceptionSpec_)
      : Node(KFunctionType,
             /*RHSComponentCache=*/Cache::Yes, /*ArrayCache=*/Cache::No,
             /*FunctionCache=*/Cache::Yes),
        Ret(Ret_), Params(Params_), CVQuals(CVQuals_), RefQual(RefQual_),
        ExceptionSpec(ExceptionSpec_) {}

  template<typename Fn> void match(Fn F) const {
    F(Ret, Params, CVQuals, RefQual, ExceptionSpec);
  }

  bool hasRHSComponentSlow(OutputBuffer &) const override { return true; }
  bool hasFunctionSlow(OutputBuffer &) const override { return true; }

  // Handle C++'s ... quirky decl grammar by using the left & right
  // distinction. Consider:
  //   int (*f(float))(char) {}
  // f is a function that takes a float and returns a pointer to a function
  // that takes a char and returns an int. If we're trying to print f, start
  // by printing out the return types's left, then print our parameters, then
  // finally print right of the return type.
  void printLeft(OutputBuffer &OB) const override {
    OB.printLeft(*Ret);
    OB += " ";
  }

  void printRight(OutputBuffer &OB) const override {
    OB.printOpen();
    Params.printWithComma(OB);
    OB.printClose();
    OB.printRight(*Ret);

    if (CVQuals & QualConst)
      OB += " const";
    if (CVQuals & QualVolatile)
      OB += " volatile";
    if (CVQuals & QualRestrict)
      OB += " restrict";

    if (RefQual == FrefQualLValue)
      OB += " &";
    else if (RefQual == FrefQualRValue)
      OB += " &&";

    if (ExceptionSpec != nullptr) {
      OB += ' ';
      ExceptionSpec->print(OB);
    }
  }
};

class NoexceptSpec : public Node {
  const Node *E;
public:
  NoexceptSpec(const Node *E_) : Node(KNoexceptSpec), E(E_) {}

  template<typename Fn> void match(Fn F) const { F(E); }

  void printLeft(OutputBuffer &OB) const override {
    OB += "noexcept";
    OB.printOpen();
    E->printAsOperand(OB);
    OB.printClose();
  }
};

class DynamicExceptionSpec : public Node {
  NodeArray Types;
public:
  DynamicExceptionSpec(NodeArray Types_)
      : Node(KDynamicExceptionSpec), Types(Types_) {}

  template<typename Fn> void match(Fn F) const { F(Types); }

  void printLeft(OutputBuffer &OB) const override {
    OB += "throw";
    OB.printOpen();
    Types.printWithComma(OB);
    OB.printClose();
  }
};

/// Represents the explicitly named object parameter.
/// E.g.,
/// \code{.cpp}
///   struct Foo {
///     void bar(this Foo && self);
///   };
/// \endcode
class ExplicitObjectParameter final : public Node {
  Node *Base;

public:
  ExplicitObjectParameter(Node *Base_)
      : Node(KExplicitObjectParameter), Base(Base_) {
    DEMANGLE_ASSERT(
        Base != nullptr,
        "Creating an ExplicitObjectParameter without a valid Base Node.");
  }

  template <typename Fn> void match(Fn F) const { F(Base); }

  void printLeft(OutputBuffer &OB) const override {
    OB += "this ";
    Base->print(OB);
  }
};

class FunctionEncoding final : public Node {
  const Node *Ret;
  const Node *Name;
  NodeArray Params;
  const Node *Attrs;
  const Node *Requires;
  Qualifiers CVQuals;
  FunctionRefQual RefQual;

public:
  FunctionEncoding(const Node *Ret_, const Node *Name_, NodeArray Params_,
                   const Node *Attrs_, const Node *Requires_,
                   Qualifiers CVQuals_, FunctionRefQual RefQual_)
      : Node(KFunctionEncoding,
             /*RHSComponentCache=*/Cache::Yes, /*ArrayCache=*/Cache::No,
             /*FunctionCache=*/Cache::Yes),
        Ret(Ret_), Name(Name_), Params(Params_), Attrs(Attrs_),
        Requires(Requires_), CVQuals(CVQuals_), RefQual(RefQual_) {}

  template<typename Fn> void match(Fn F) const {
    F(Ret, Name, Params, Attrs, Requires, CVQuals, RefQual);
  }

  Qualifiers getCVQuals() const { return CVQuals; }
  FunctionRefQual getRefQual() const { return RefQual; }
  NodeArray getParams() const { return Params; }
  const Node *getReturnType() const { return Ret; }
  const Node *getAttrs() const { return Attrs; }
  const Node *getRequires() const { return Requires; }

  bool hasRHSComponentSlow(OutputBuffer &) const override { return true; }
  bool hasFunctionSlow(OutputBuffer &) const override { return true; }

  const Node *getName() const { return Name; }

  void printLeft(OutputBuffer &OB) const override {
    if (Ret) {
      OB.printLeft(*Ret);
      if (!Ret->hasRHSComponent(OB))
        OB += " ";
    }

    Name->print(OB);
  }

  void printRight(OutputBuffer &OB) const override {
    OB.printOpen();
    Params.printWithComma(OB);
    OB.printClose();

    if (Ret)
      OB.printRight(*Ret);

    if (CVQuals & QualConst)
      OB += " const";
    if (CVQuals & QualVolatile)
      OB += " volatile";
    if (CVQuals & QualRestrict)
      OB += " restrict";

    if (RefQual == FrefQualLValue)
      OB += " &";
    else if (RefQual == FrefQualRValue)
      OB += " &&";

    if (Attrs != nullptr)
      Attrs->print(OB);

    if (Requires != nullptr) {
      OB += " requires ";
      Requires->print(OB);
    }
  }
};

class LiteralOperator : public Node {
  const Node *OpName;

public:
  LiteralOperator(const Node *OpName_)
      : Node(KLiteralOperator), OpName(OpName_) {}

  template<typename Fn> void match(Fn F) const { F(OpName); }

  void printLeft(OutputBuffer &OB) const override {
    OB += "operator\"\" ";
    OpName->print(OB);
  }
};

class SpecialName final : public Node {
  const std::string_view Special;
  const Node *Child;

public:
  SpecialName(std::string_view Special_, const Node *Child_)
      : Node(KSpecialName), Special(Special_), Child(Child_) {}

  template<typename Fn> void match(Fn F) const { F(Special, Child); }

  void printLeft(OutputBuffer &OB) const override {
    OB += Special;
    Child->print(OB);
  }
};

class CtorVtableSpecialName final : public Node {
  const Node *FirstType;
  const Node *SecondType;

public:
  CtorVtableSpecialName(const Node *FirstType_, const Node *SecondType_)
      : Node(KCtorVtableSpecialName),
        FirstType(FirstType_), SecondType(SecondType_) {}

  template<typename Fn> void match(Fn F) const { F(FirstType, SecondType); }

  void printLeft(OutputBuffer &OB) const override {
    OB += "construction vtable for ";
    FirstType->print(OB);
    OB += "-in-";
    SecondType->print(OB);
  }
};

struct NestedName : Node {
  Node *Qual;
  Node *Name;

  NestedName(Node *Qual_, Node *Name_)
      : Node(KNestedName), Qual(Qual_), Name(Name_) {}

  template<typename Fn> void match(Fn F) const { F(Qual, Name); }

  std::string_view getBaseName() const override { return Name->getBaseName(); }

  void printLeft(OutputBuffer &OB) const override {
    Qual->print(OB);
    OB += "::";
    Name->print(OB);
  }
};

struct MemberLikeFriendName : Node {
  Node *Qual;
  Node *Name;

  MemberLikeFriendName(Node *Qual_, Node *Name_)
      : Node(KMemberLikeFriendName), Qual(Qual_), Name(Name_) {}

  template<typename Fn> void match(Fn F) const { F(Qual, Name); }

  std::string_view getBaseName() const override { return Name->getBaseName(); }

  void printLeft(OutputBuffer &OB) const override {
    Qual->print(OB);
    OB += "::friend ";
    Name->print(OB);
  }
};

struct ModuleName : Node {
  ModuleName *Parent;
  Node *Name;
  bool IsPartition;

  ModuleName(ModuleName *Parent_, Node *Name_, bool IsPartition_ = false)
      : Node(KModuleName), Parent(Parent_), Name(Name_),
        IsPartition(IsPartition_) {}

  template <typename Fn> void match(Fn F) const {
    F(Parent, Name, IsPartition);
  }

  void printLeft(OutputBuffer &OB) const override {
    if (Parent)
      Parent->print(OB);
    if (Parent || IsPartition)
      OB += IsPartition ? ':' : '.';
    Name->print(OB);
  }
};

struct ModuleEntity : Node {
  ModuleName *Module;
  Node *Name;

  ModuleEntity(ModuleName *Module_, Node *Name_)
      : Node(KModuleEntity), Module(Module_), Name(Name_) {}

  template <typename Fn> void match(Fn F) const { F(Module, Name); }

  std::string_view getBaseName() const override { return Name->getBaseName(); }

  void printLeft(OutputBuffer &OB) const override {
    Name->print(OB);
    OB += '@';
    Module->print(OB);
  }
};

struct LocalName : Node {
  Node *Encoding;
  Node *Entity;

  LocalName(Node *Encoding_, Node *Entity_)
      : Node(KLocalName), Encoding(Encoding_), Entity(Entity_) {}

  template<typename Fn> void match(Fn F) const { F(Encoding, Entity); }

  void printLeft(OutputBuffer &OB) const override {
    Encoding->print(OB);
    OB += "::";
    Entity->print(OB);
  }
};

class QualifiedName final : public Node {
  // qualifier::name
  const Node *Qualifier;
  const Node *Name;

public:
  QualifiedName(const Node *Qualifier_, const Node *Name_)
      : Node(KQualifiedName), Qualifier(Qualifier_), Name(Name_) {}

  template<typename Fn> void match(Fn F) const { F(Qualifier, Name); }

  std::string_view getBaseName() const override { return Name->getBaseName(); }

  void printLeft(OutputBuffer &OB) const override {
    Qualifier->print(OB);
    OB += "::";
    Name->print(OB);
  }
};

class VectorType final : public Node {
  const Node *BaseType;
  const Node *Dimension;

public:
  VectorType(const Node *BaseType_, const Node *Dimension_)
      : Node(KVectorType), BaseType(BaseType_), Dimension(Dimension_) {}

  const Node *getBaseType() const { return BaseType; }
  const Node *getDimension() const { return Dimension; }

  template<typename Fn> void match(Fn F) const { F(BaseType, Dimension); }

  void printLeft(OutputBuffer &OB) const override {
    BaseType->print(OB);
    OB += " vector[";
    if (Dimension)
      Dimension->print(OB);
    OB += "]";
  }
};

class PixelVectorType final : public Node {
  const Node *Dimension;

public:
  PixelVectorType(const Node *Dimension_)
      : Node(KPixelVectorType), Dimension(Dimension_) {}

  template<typename Fn> void match(Fn F) const { F(Dimension); }

  void printLeft(OutputBuffer &OB) const override {
    // FIXME: This should demangle as "vector pixel".
    OB += "pixel vector[";
    Dimension->print(OB);
    OB += "]";
  }
};

class BinaryFPType final : public Node {
  const Node *Dimension;

public:
  BinaryFPType(const Node *Dimension_)
      : Node(KBinaryFPType), Dimension(Dimension_) {}

  template<typename Fn> void match(Fn F) const { F(Dimension); }

  void printLeft(OutputBuffer &OB) const override {
    OB += "_Float";
    Dimension->print(OB);
  }
};

enum class TemplateParamKind { Type, NonType, Template };

/// An invented name for a template parameter for which we don't have a
/// corresponding template argument.
///
/// This node is created when parsing the <lambda-sig> for a lambda with
/// explicit template arguments, which might be referenced in the parameter
/// types appearing later in the <lambda-sig>.
class SyntheticTemplateParamName final : public Node {
  TemplateParamKind Kind;
  unsigned Index;

public:
  SyntheticTemplateParamName(TemplateParamKind Kind_, unsigned Index_)
      : Node(KSyntheticTemplateParamName), Kind(Kind_), Index(Index_) {}

  template<typename Fn> void match(Fn F) const { F(Kind, Index); }

  void printLeft(OutputBuffer &OB) const override {
    switch (Kind) {
    case TemplateParamKind::Type:
      OB += "$T";
      break;
    case TemplateParamKind::NonType:
      OB += "$N";
      break;
    case TemplateParamKind::Template:
      OB += "$TT";
      break;
    }
    if (Index > 0)
      OB << Index - 1;
  }
};

class TemplateParamQualifiedArg final : public Node {
  Node *Param;
  Node *Arg;

public:
  TemplateParamQualifiedArg(Node *Param_, Node *Arg_)
      : Node(KTemplateParamQualifiedArg), Param(Param_), Arg(Arg_) {}

  template <typename Fn> void match(Fn F) const { F(Param, Arg); }

  Node *getArg() { return Arg; }

  void printLeft(OutputBuffer &OB) const override {
    // Don't print Param to keep the output consistent.
    Arg->print(OB);
  }
};

/// A template type parameter declaration, 'typename T'.
class TypeTemplateParamDecl final : public Node {
  Node *Name;

public:
  TypeTemplateParamDecl(Node *Name_)
      : Node(KTypeTemplateParamDecl, Cache::Yes), Name(Name_) {}

  template<typename Fn> void match(Fn F) const { F(Name); }

  void printLeft(OutputBuffer &OB) const override { OB += "typename "; }

  void printRight(OutputBuffer &OB) const override { Name->print(OB); }
};

/// A constrained template type parameter declaration, 'C<U> T'.
class ConstrainedTypeTemplateParamDecl final : public Node {
  Node *Constraint;
  Node *Name;

public:
  ConstrainedTypeTemplateParamDecl(Node *Constraint_, Node *Name_)
      : Node(KConstrainedTypeTemplateParamDecl, Cache::Yes),
        Constraint(Constraint_), Name(Name_) {}

  template<typename Fn> void match(Fn F) const { F(Constraint, Name); }

  void printLeft(OutputBuffer &OB) const override {
    Constraint->print(OB);
    OB += " ";
  }

  void printRight(OutputBuffer &OB) const override { Name->print(OB); }
};

/// A non-type template parameter declaration, 'int N'.
class NonTypeTemplateParamDecl final : public Node {
  Node *Name;
  Node *Type;

public:
  NonTypeTemplateParamDecl(Node *Name_, Node *Type_)
      : Node(KNonTypeTemplateParamDecl, Cache::Yes), Name(Name_), Type(Type_) {}

  template<typename Fn> void match(Fn F) const { F(Name, Type); }

  void printLeft(OutputBuffer &OB) const override {
    OB.printLeft(*Type);
    if (!Type->hasRHSComponent(OB))
      OB += " ";
  }

  void printRight(OutputBuffer &OB) const override {
    Name->print(OB);
    OB.printRight(*Type);
  }
};

/// A template template parameter declaration,
/// 'template<typename T> typename N'.
class TemplateTemplateParamDecl final : public Node {
  Node *Name;
  NodeArray Params;
  Node *Requires;

public:
  TemplateTemplateParamDecl(Node *Name_, NodeArray Params_, Node *Requires_)
      : Node(KTemplateTemplateParamDecl, Cache::Yes), Name(Name_),
        Params(Params_), Requires(Requires_) {}

  template <typename Fn> void match(Fn F) const { F(Name, Params, Requires); }

  void printLeft(OutputBuffer &OB) const override {
    ScopedOverride<bool> LT(OB.TemplateTracker.InsideTemplate, true);
    OB += "template<";
    Params.printWithComma(OB);
    OB += "> typename ";
  }

  void printRight(OutputBuffer &OB) const override {
    Name->print(OB);
    if (Requires != nullptr) {
      OB += " requires ";
      Requires->print(OB);
    }
  }
};

/// A template parameter pack declaration, 'typename ...T'.
class TemplateParamPackDecl final : public Node {
  Node *Param;

public:
  TemplateParamPackDecl(Node *Param_)
      : Node(KTemplateParamPackDecl, Cache::Yes), Param(Param_) {}

  template<typename Fn> void match(Fn F) const { F(Param); }

  void printLeft(OutputBuffer &OB) const override {
    OB.printLeft(*Param);
    OB += "...";
  }

  void printRight(OutputBuffer &OB) const override { OB.printRight(*Param); }
};

/// An unexpanded parameter pack (either in the expression or type context). If
/// this AST is correct, this node will have a ParameterPackExpansion node above
/// it.
///
/// This node is created when some <template-args> are found that apply to an
/// <encoding>, and is stored in the TemplateParams table. In order for this to
/// appear in the final AST, it has to referenced via a <template-param> (ie,
/// T_).
class ParameterPack final : public Node {
  NodeArray Data;

  // Setup OutputBuffer for a pack expansion, unless we're already expanding
  // one.
  void initializePackExpansion(OutputBuffer &OB) const {
    if (OB.CurrentPackMax == std::numeric_limits<unsigned>::max()) {
      OB.CurrentPackMax = static_cast<unsigned>(Data.size());
      OB.CurrentPackIndex = 0;
    }
  }

public:
  ParameterPack(NodeArray Data_) : Node(KParameterPack), Data(Data_) {
    ArrayCache = FunctionCache = RHSComponentCache = Cache::Unknown;
    if (std::all_of(Data.begin(), Data.end(),
                    [](Node *P) { return P->getArrayCache() == Cache::No; }))
      ArrayCache = Cache::No;
    if (std::all_of(Data.begin(), Data.end(),
                    [](Node *P) { return P->getFunctionCache() == Cache::No; }))
      FunctionCache = Cache::No;
    if (std::all_of(Data.begin(), Data.end(), [](Node *P) {
          return P->getRHSComponentCache() == Cache::No;
        }))
      RHSComponentCache = Cache::No;
  }

  template<typename Fn> void match(Fn F) const { F(Data); }

  bool hasRHSComponentSlow(OutputBuffer &OB) const override {
    initializePackExpansion(OB);
    size_t Idx = OB.CurrentPackIndex;
    return Idx < Data.size() && Data[Idx]->hasRHSComponent(OB);
  }
  bool hasArraySlow(OutputBuffer &OB) const override {
    initializePackExpansion(OB);
    size_t Idx = OB.CurrentPackIndex;
    return Idx < Data.size() && Data[Idx]->hasArray(OB);
  }
  bool hasFunctionSlow(OutputBuffer &OB) const override {
    initializePackExpansion(OB);
    size_t Idx = OB.CurrentPackIndex;
    return Idx < Data.size() && Data[Idx]->hasFunction(OB);
  }
  const Node *getSyntaxNode(OutputBuffer &OB) const override {
    initializePackExpansion(OB);
    size_t Idx = OB.CurrentPackIndex;
    return Idx < Data.size() ? Data[Idx]->getSyntaxNode(OB) : this;
  }

  void printLeft(OutputBuffer &OB) const override {
    initializePackExpansion(OB);
    size_t Idx = OB.CurrentPackIndex;
    if (Idx < Data.size())
      OB.printLeft(*Data[Idx]);
  }
  void printRight(OutputBuffer &OB) const override {
    initializePackExpansion(OB);
    size_t Idx = OB.CurrentPackIndex;
    if (Idx < Data.size())
      OB.printRight(*Data[Idx]);
  }
};

/// A variadic template argument. This node represents an occurrence of
/// J<something>E in some <template-args>. It isn't itself unexpanded, unless
/// one of its Elements is. The parser inserts a ParameterPack into the
/// TemplateParams table if the <template-args> this pack belongs to apply to an
/// <encoding>.
class TemplateArgumentPack final : public Node {
  NodeArray Elements;
public:
  TemplateArgumentPack(NodeArray Elements_)
      : Node(KTemplateArgumentPack), Elements(Elements_) {}

  template<typename Fn> void match(Fn F) const { F(Elements); }

  NodeArray getElements() const { return Elements; }

  void printLeft(OutputBuffer &OB) const override {
    Elements.printWithComma(OB);
  }
};

/// A pack expansion. Below this node, there are some unexpanded ParameterPacks
/// which each have Child->ParameterPackSize elements.
class ParameterPackExpansion final : public Node {
  const Node *Child;

public:
  ParameterPackExpansion(const Node *Child_)
      : Node(KParameterPackExpansion), Child(Child_) {}

  template<typename Fn> void match(Fn F) const { F(Child); }

  const Node *getChild() const { return Child; }

  void printLeft(OutputBuffer &OB) const override {
    constexpr unsigned Max = std::numeric_limits<unsigned>::max();
    ScopedOverride<unsigned> SavePackIdx(OB.CurrentPackIndex, Max);
    ScopedOverride<unsigned> SavePackMax(OB.CurrentPackMax, Max);
    size_t StreamPos = OB.getCurrentPosition();

    // Print the first element in the pack. If Child contains a ParameterPack,
    // it will set up S.CurrentPackMax and print the first element.
    Child->print(OB);

    // No ParameterPack was found in Child. This can occur if we've found a pack
    // expansion on a <function-param>.
    if (OB.CurrentPackMax == Max) {
      OB += "...";
      return;
    }

    // We found a ParameterPack, but it has no elements. Erase whatever we may
    // of printed.
    if (OB.CurrentPackMax == 0) {
      OB.setCurrentPosition(StreamPos);
      return;
    }

    // Else, iterate through the rest of the elements in the pack.
    for (unsigned I = 1, E = OB.CurrentPackMax; I < E; ++I) {
      OB += ", ";
      OB.CurrentPackIndex = I;
      Child->print(OB);
    }
  }
};

class TemplateArgs final : public Node {
  NodeArray Params;
  Node *Requires;

public:
  TemplateArgs(NodeArray Params_, Node *Requires_)
      : Node(KTemplateArgs), Params(Params_), Requires(Requires_) {}

  template<typename Fn> void match(Fn F) const { F(Params, Requires); }

  NodeArray getParams() { return Params; }

  void printLeft(OutputBuffer &OB) const override {
    ScopedOverride<bool> LT(OB.TemplateTracker.InsideTemplate, true);
    OB += "<";
    Params.printWithComma(OB);
    OB += ">";
    // Don't print the requires clause to keep the output simple.
  }
};

/// A forward-reference to a template argument that was not known at the point
/// where the template parameter name was parsed in a mangling.
///
/// This is created when demangling the name of a specialization of a
/// conversion function template:
///
/// \code
/// struct A {
///   template<typename T> operator T*();
/// };
/// \endcode
///
/// When demangling a specialization of the conversion function template, we
/// encounter the name of the template (including the \c T) before we reach
/// the template argument list, so we cannot substitute the parameter name
/// for the corresponding argument while parsing. Instead, we create a
/// \c ForwardTemplateReference node that is resolved after we parse the
/// template arguments.
struct ForwardTemplateReference : Node {
  size_t Index;
  Node *Ref = nullptr;

  // If we're currently printing this node. It is possible (though invalid) for
  // a forward template reference to refer to itself via a substitution. This
  // creates a cyclic AST, which will stack overflow printing. To fix this, bail
  // out if more than one print* function is active.
  mutable bool Printing = false;

  ForwardTemplateReference(size_t Index_)
      : Node(KForwardTemplateReference, Cache::Unknown, Cache::Unknown,
             Cache::Unknown),
        Index(Index_) {}

  // We don't provide a matcher for these, because the value of the node is
  // not determined by its construction parameters, and it generally needs
  // special handling.
  template<typename Fn> void match(Fn F) const = delete;

  bool hasRHSComponentSlow(OutputBuffer &OB) const override {
    if (Printing)
      return false;
    ScopedOverride<bool> SavePrinting(Printing, true);
    return Ref->hasRHSComponent(OB);
  }
  bool hasArraySlow(OutputBuffer &OB) const override {
    if (Printing)
      return false;
    ScopedOverride<bool> SavePrinting(Printing, true);
    return Ref->hasArray(OB);
  }
  bool hasFunctionSlow(OutputBuffer &OB) const override {
    if (Printing)
      return false;
    ScopedOverride<bool> SavePrinting(Printing, true);
    return Ref->hasFunction(OB);
  }
  const Node *getSyntaxNode(OutputBuffer &OB) const override {
    if (Printing)
      return this;
    ScopedOverride<bool> SavePrinting(Printing, true);
    return Ref->getSyntaxNode(OB);
  }

  void printLeft(OutputBuffer &OB) const override {
    if (Printing)
      return;
    ScopedOverride<bool> SavePrinting(Printing, true);
    OB.printLeft(*Ref);
  }
  void printRight(OutputBuffer &OB) const override {
    if (Printing)
      return;
    ScopedOverride<bool> SavePrinting(Printing, true);
    OB.printRight(*Ref);
  }
};

struct NameWithTemplateArgs : Node {
  // name<template_args>
  Node *Name;
  Node *TemplateArgs;

  NameWithTemplateArgs(Node *Name_, Node *TemplateArgs_)
      : Node(KNameWithTemplateArgs), Name(Name_), TemplateArgs(TemplateArgs_) {}

  template<typename Fn> void match(Fn F) const { F(Name, TemplateArgs); }

  std::string_view getBaseName() const override { return Name->getBaseName(); }

  void printLeft(OutputBuffer &OB) const override {
    Name->print(OB);
    TemplateArgs->print(OB);
  }
};

class GlobalQualifiedName final : public Node {
  Node *Child;

public:
  GlobalQualifiedName(Node* Child_)
      : Node(KGlobalQualifiedName), Child(Child_) {}

  template<typename Fn> void match(Fn F) const { F(Child); }

  std::string_view getBaseName() const override { return Child->getBaseName(); }

  void printLeft(OutputBuffer &OB) const override {
    OB += "::";
    Child->print(OB);
  }
};

enum class SpecialSubKind {
  allocator,
  basic_string,
  string,
  istream,
  ostream,
  iostream,
};

class SpecialSubstitution;
class ExpandedSpecialSubstitution : public Node {
protected:
  SpecialSubKind SSK;

  ExpandedSpecialSubstitution(SpecialSubKind SSK_, Kind K_)
      : Node(K_), SSK(SSK_) {}
public:
  ExpandedSpecialSubstitution(SpecialSubKind SSK_)
      : ExpandedSpecialSubstitution(SSK_, KExpandedSpecialSubstitution) {}
  inline ExpandedSpecialSubstitution(SpecialSubstitution const *);

  template<typename Fn> void match(Fn F) const { F(SSK); }

protected:
  bool isInstantiation() const {
    return unsigned(SSK) >= unsigned(SpecialSubKind::string);
  }

  std::string_view getBaseName() const override {
    switch (SSK) {
    case SpecialSubKind::allocator:
      return {"allocator"};
    case SpecialSubKind::basic_string:
      return {"basic_string"};
    case SpecialSubKind::string:
      return {"basic_string"};
    case SpecialSubKind::istream:
      return {"basic_istream"};
    case SpecialSubKind::ostream:
      return {"basic_ostream"};
    case SpecialSubKind::iostream:
      return {"basic_iostream"};
    }
    DEMANGLE_UNREACHABLE;
  }

private:
  void printLeft(OutputBuffer &OB) const override {
    OB << "std::" << getBaseName();
    if (isInstantiation()) {
      OB << "<char, std::char_traits<char>";
      if (SSK == SpecialSubKind::string)
        OB << ", std::allocator<char>";
      OB << ">";
    }
  }
};

class SpecialSubstitution final : public ExpandedSpecialSubstitution {
public:
  SpecialSubstitution(SpecialSubKind SSK_)
      : ExpandedSpecialSubstitution(SSK_, KSpecialSubstitution) {}

  template<typename Fn> void match(Fn F) const { F(SSK); }

  std::string_view getBaseName() const override {
    std::string_view SV = ExpandedSpecialSubstitution::getBaseName();
    if (isInstantiation()) {
      // The instantiations are typedefs that drop the "basic_" prefix.
      DEMANGLE_ASSERT(starts_with(SV, "basic_"), "");
      SV.remove_prefix(sizeof("basic_") - 1);
    }
    return SV;
  }

  void printLeft(OutputBuffer &OB) const override {
    OB << "std::" << getBaseName();
  }
};

inline ExpandedSpecialSubstitution::ExpandedSpecialSubstitution(
    SpecialSubstitution const *SS)
    : ExpandedSpecialSubstitution(SS->SSK) {}

class CtorDtorName final : public Node {
  const Node *Basename;
  const bool IsDtor;
  const int Variant;

public:
  CtorDtorName(const Node *Basename_, bool IsDtor_, int Variant_)
      : Node(KCtorDtorName), Basename(Basename_), IsDtor(IsDtor_),
        Variant(Variant_) {}

  template<typename Fn> void match(Fn F) const { F(Basename, IsDtor, Variant); }

  void printLeft(OutputBuffer &OB) const override {
    if (IsDtor)
      OB += "~";
    OB += Basename->getBaseName();
  }
};

class DtorName : public Node {
  const Node *Base;

public:
  DtorName(const Node *Base_) : Node(KDtorName), Base(Base_) {}

  template<typename Fn> void match(Fn F) const { F(Base); }

  void printLeft(OutputBuffer &OB) const override {
    OB += "~";
    OB.printLeft(*Base);
  }
};

class UnnamedTypeName : public Node {
  const std::string_view Count;

public:
  UnnamedTypeName(std::string_view Count_)
      : Node(KUnnamedTypeName), Count(Count_) {}

  template<typename Fn> void match(Fn F) const { F(Count); }

  void printLeft(OutputBuffer &OB) const override {
    OB += "'unnamed";
    OB += Count;
    OB += "\'";
  }
};

class ClosureTypeName : public Node {
  NodeArray TemplateParams;
  const Node *Requires1;
  NodeArray Params;
  const Node *Requires2;
  std::string_view Count;

public:
  ClosureTypeName(NodeArray TemplateParams_, const Node *Requires1_,
                  NodeArray Params_, const Node *Requires2_,
                  std::string_view Count_)
      : Node(KClosureTypeName), TemplateParams(TemplateParams_),
        Requires1(Requires1_), Params(Params_), Requires2(Requires2_),
        Count(Count_) {}

  template<typename Fn> void match(Fn F) const {
    F(TemplateParams, Requires1, Params, Requires2, Count);
  }

  void printDeclarator(OutputBuffer &OB) const {
    if (!TemplateParams.empty()) {
      ScopedOverride<bool> LT(OB.TemplateTracker.InsideTemplate, true);
      OB += "<";
      TemplateParams.printWithComma(OB);
      OB += ">";
    }
    if (Requires1 != nullptr) {
      OB += " requires ";
      Requires1->print(OB);
      OB += " ";
    }
    OB.printOpen();
    Params.printWithComma(OB);
    OB.printClose();
    if (Requires2 != nullptr) {
      OB += " requires ";
      Requires2->print(OB);
    }
  }

  void printLeft(OutputBuffer &OB) const override {
    // FIXME: This demangling is not particularly readable.
    OB += "\'lambda";
    OB += Count;
    OB += "\'";
    printDeclarator(OB);
  }
};

class StructuredBindingName : public Node {
  NodeArray Bindings;
public:
  StructuredBindingName(NodeArray Bindings_)
      : Node(KStructuredBindingName), Bindings(Bindings_) {}

  template<typename Fn> void match(Fn F) const { F(Bindings); }

  void printLeft(OutputBuffer &OB) const override {
    OB.printOpen('[');
    Bindings.printWithComma(OB);
    OB.printClose(']');
  }
};

// -- Expression Nodes --

class BinaryExpr : public Node {
  const Node *LHS;
  const std::string_view InfixOperator;
  const Node *RHS;

public:
  BinaryExpr(const Node *LHS_, std::string_view InfixOperator_,
             const Node *RHS_, Prec Prec_)
      : Node(KBinaryExpr, Prec_), LHS(LHS_), InfixOperator(InfixOperator_),
        RHS(RHS_) {}

  template <typename Fn> void match(Fn F) const {
    F(LHS, InfixOperator, RHS, getPrecedence());
  }

  void printLeft(OutputBuffer &OB) const override {
    // If we're printing a '<' inside of a template argument, and we haven't
    // yet parenthesized the expression, do so now.
    bool ParenAll = !OB.isInParensInTemplateArgs() &&
                    (InfixOperator == ">" || InfixOperator == ">>");
    if (ParenAll)
      OB.printOpen();
    // Assignment is right associative, with special LHS precedence.
    bool IsAssign = getPrecedence() == Prec::Assign;
    LHS->printAsOperand(OB, IsAssign ? Prec::OrIf : getPrecedence(), !IsAssign);
    // No space before comma operator
    if (!(InfixOperator == ","))
      OB += " ";
    OB += InfixOperator;
    OB += " ";
    RHS->printAsOperand(OB, getPrecedence(), IsAssign);
    if (ParenAll)
      OB.printClose();
  }
};

class ArraySubscriptExpr : public Node {
  const Node *Op1;
  const Node *Op2;

public:
  ArraySubscriptExpr(const Node *Op1_, const Node *Op2_, Prec Prec_)
      : Node(KArraySubscriptExpr, Prec_), Op1(Op1_), Op2(Op2_) {}

  template <typename Fn> void match(Fn F) const {
    F(Op1, Op2, getPrecedence());
  }

  void printLeft(OutputBuffer &OB) const override {
    Op1->printAsOperand(OB, getPrecedence());
    OB.printOpen('[');
    Op2->printAsOperand(OB);
    OB.printClose(']');
  }
};

class PostfixExpr : public Node {
  const Node *Child;
  const std::string_view Operator;

public:
  PostfixExpr(const Node *Child_, std::string_view Operator_, Prec Prec_)
      : Node(KPostfixExpr, Prec_), Child(Child_), Operator(Operator_) {}

  template <typename Fn> void match(Fn F) const {
    F(Child, Operator, getPrecedence());
  }

  void printLeft(OutputBuffer &OB) const override {
    Child->printAsOperand(OB, getPrecedence(), true);
    OB += Operator;
  }
};

class ConditionalExpr : public Node {
  const Node *Cond;
  const Node *Then;
  const Node *Else;

public:
  ConditionalExpr(const Node *Cond_, const Node *Then_, const Node *Else_,
                  Prec Prec_)
      : Node(KConditionalExpr, Prec_), Cond(Cond_), Then(Then_), Else(Else_) {}

  template <typename Fn> void match(Fn F) const {
    F(Cond, Then, Else, getPrecedence());
  }

  void printLeft(OutputBuffer &OB) const override {
    Cond->printAsOperand(OB, getPrecedence());
    OB += " ? ";
    Then->printAsOperand(OB);
    OB += " : ";
    Else->printAsOperand(OB, Prec::Assign, true);
  }
};

class MemberExpr : public Node {
  const Node *LHS;
  const std::string_view Kind;
  const Node *RHS;

public:
  MemberExpr(const Node *LHS_, std::string_view Kind_, const Node *RHS_,
             Prec Prec_)
      : Node(KMemberExpr, Prec_), LHS(LHS_), Kind(Kind_), RHS(RHS_) {}

  template <typename Fn> void match(Fn F) const {
    F(LHS, Kind, RHS, getPrecedence());
  }

  void printLeft(OutputBuffer &OB) const override {
    LHS->printAsOperand(OB, getPrecedence(), true);
    OB += Kind;
    RHS->printAsOperand(OB, getPrecedence(), false);
  }
};

class SubobjectExpr : public Node {
  const Node *Type;
  const Node *SubExpr;
  std::string_view Offset;
  NodeArray UnionSelectors;
  bool OnePastTheEnd;

public:
  SubobjectExpr(const Node *Type_, const Node *SubExpr_,
                std::string_view Offset_, NodeArray UnionSelectors_,
                bool OnePastTheEnd_)
      : Node(KSubobjectExpr), Type(Type_), SubExpr(SubExpr_), Offset(Offset_),
        UnionSelectors(UnionSelectors_), OnePastTheEnd(OnePastTheEnd_) {}

  template<typename Fn> void match(Fn F) const {
    F(Type, SubExpr, Offset, UnionSelectors, OnePastTheEnd);
  }

  void printLeft(OutputBuffer &OB) const override {
    SubExpr->print(OB);
    OB += ".<";
    Type->print(OB);
    OB += " at offset ";
    if (Offset.empty()) {
      OB += "0";
    } else if (Offset[0] == 'n') {
      OB += "-";
      OB += std::string_view(Offset.data() + 1, Offset.size() - 1);
    } else {
      OB += Offset;
    }
    OB += ">";
  }
};

class EnclosingExpr : public Node {
  const std::string_view Prefix;
  const Node *Infix;
  const std::string_view Postfix;

public:
  EnclosingExpr(std::string_view Prefix_, const Node *Infix_,
                Prec Prec_ = Prec::Primary)
      : Node(KEnclosingExpr, Prec_), Prefix(Prefix_), Infix(Infix_) {}

  template <typename Fn> void match(Fn F) const {
    F(Prefix, Infix, getPrecedence());
  }

  void printLeft(OutputBuffer &OB) const override {
    OB += Prefix;
    OB.printOpen();
    Infix->print(OB);
    OB.printClose();
    OB += Postfix;
  }
};

class CastExpr : public Node {
  // cast_kind<to>(from)
  const std::string_view CastKind;
  const Node *To;
  const Node *From;

public:
  CastExpr(std::string_view CastKind_, const Node *To_, const Node *From_,
           Prec Prec_)
      : Node(KCastExpr, Prec_), CastKind(CastKind_), To(To_), From(From_) {}

  template <typename Fn> void match(Fn F) const {
    F(CastKind, To, From, getPrecedence());
  }

  void printLeft(OutputBuffer &OB) const override {
    OB += CastKind;
    {
      ScopedOverride<bool> LT(OB.TemplateTracker.InsideTemplate, true);
      OB += "<";
      OB.printLeft(*To);
      OB += ">";
    }
    OB.printOpen();
    From->printAsOperand(OB);
    OB.printClose();
  }
};

class SizeofParamPackExpr : public Node {
  const Node *Pack;

public:
  SizeofParamPackExpr(const Node *Pack_)
      : Node(KSizeofParamPackExpr), Pack(Pack_) {}

  template<typename Fn> void match(Fn F) const { F(Pack); }

  void printLeft(OutputBuffer &OB) const override {
    OB += "sizeof...";
    OB.printOpen();
    ParameterPackExpansion PPE(Pack);
    PPE.printLeft(OB);
    OB.printClose();
  }
};

class CallExpr : public Node {
  const Node *Callee;
  NodeArray Args;
  bool IsParen; // (func)(args ...) ?

public:
  CallExpr(const Node *Callee_, NodeArray Args_, bool IsParen_, Prec Prec_)
      : Node(KCallExpr, Prec_), Callee(Callee_), Args(Args_),
        IsParen(IsParen_) {}

  template <typename Fn> void match(Fn F) const {
    F(Callee, Args, IsParen, getPrecedence());
  }

  void printLeft(OutputBuffer &OB) const override {
    if (IsParen)
      OB.printOpen();
    Callee->print(OB);
    if (IsParen)
      OB.printClose();
    OB.printOpen();
    Args.printWithComma(OB);
    OB.printClose();
  }
};

class NewExpr : public Node {
  // new (expr_list) type(init_list)
  NodeArray ExprList;
  Node *Type;
  NodeArray InitList;
  bool IsGlobal; // ::operator new ?
  bool IsArray;  // new[] ?
public:
  NewExpr(NodeArray ExprList_, Node *Type_, NodeArray InitList_, bool IsGlobal_,
          bool IsArray_, Prec Prec_)
      : Node(KNewExpr, Prec_), ExprList(ExprList_), Type(Type_),
        InitList(InitList_), IsGlobal(IsGlobal_), IsArray(IsArray_) {}

  template<typename Fn> void match(Fn F) const {
    F(ExprList, Type, InitList, IsGlobal, IsArray, getPrecedence());
  }

  void printLeft(OutputBuffer &OB) const override {
    if (IsGlobal)
      OB += "::";
    OB += "new";
    if (IsArray)
      OB += "[]";
    if (!ExprList.empty()) {
      OB.printOpen();
      ExprList.printWithComma(OB);
      OB.printClose();
    }
    OB += " ";
    Type->print(OB);
    if (!InitList.empty()) {
      OB.printOpen();
      InitList.printWithComma(OB);
      OB.printClose();
    }
  }
};

class DeleteExpr : public Node {
  Node *Op;
  bool IsGlobal;
  bool IsArray;

public:
  DeleteExpr(Node *Op_, bool IsGlobal_, bool IsArray_, Prec Prec_)
      : Node(KDeleteExpr, Prec_), Op(Op_), IsGlobal(IsGlobal_),
        IsArray(IsArray_) {}

  template <typename Fn> void match(Fn F) const {
    F(Op, IsGlobal, IsArray, getPrecedence());
  }

  void printLeft(OutputBuffer &OB) const override {
    if (IsGlobal)
      OB += "::";
    OB += "delete";
    if (IsArray)
      OB += "[]";
    OB += ' ';
    Op->print(OB);
  }
};

class PrefixExpr : public Node {
  std::string_view Prefix;
  Node *Child;

public:
  PrefixExpr(std::string_view Prefix_, Node *Child_, Prec Prec_)
      : Node(KPrefixExpr, Prec_), Prefix(Prefix_), Child(Child_) {}

  template <typename Fn> void match(Fn F) const {
    F(Prefix, Child, getPrecedence());
  }

  void printLeft(OutputBuffer &OB) const override {
    OB += Prefix;
    Child->printAsOperand(OB, getPrecedence());
  }
};

class FunctionParam : public Node {
  std::string_view Number;

public:
  FunctionParam(std::string_view Number_)
      : Node(KFunctionParam), Number(Number_) {}

  template<typename Fn> void match(Fn F) const { F(Number); }

  void printLeft(OutputBuffer &OB) const override {
    OB += "fp";
    OB += Number;
  }
};

class ConversionExpr : public Node {
  const Node *Type;
  NodeArray Expressions;

public:
  ConversionExpr(const Node *Type_, NodeArray Expressions_, Prec Prec_)
      : Node(KConversionExpr, Prec_), Type(Type_), Expressions(Expressions_) {}

  template <typename Fn> void match(Fn F) const {
    F(Type, Expressions, getPrecedence());
  }

  void printLeft(OutputBuffer &OB) const override {
    OB.printOpen();
    Type->print(OB);
    OB.printClose();
    OB.printOpen();
    Expressions.printWithComma(OB);
    OB.printClose();
  }
};

class PointerToMemberConversionExpr : public Node {
  const Node *Type;
  const Node *SubExpr;
  std::string_view Offset;

public:
  PointerToMemberConversionExpr(const Node *Type_, const Node *SubExpr_,
                                std::string_view Offset_, Prec Prec_)
      : Node(KPointerToMemberConversionExpr, Prec_), Type(Type_),
        SubExpr(SubExpr_), Offset(Offset_) {}

  template <typename Fn> void match(Fn F) const {
    F(Type, SubExpr, Offset, getPrecedence());
  }

  void printLeft(OutputBuffer &OB) const override {
    OB.printOpen();
    Type->print(OB);
    OB.printClose();
    OB.printOpen();
    SubExpr->print(OB);
    OB.printClose();
  }
};

class InitListExpr : public Node {
  const Node *Ty;
  NodeArray Inits;
public:
  InitListExpr(const Node *Ty_, NodeArray Inits_)
      : Node(KInitListExpr), Ty(Ty_), Inits(Inits_) {}

  template<typename Fn> void match(Fn F) const { F(Ty, Inits); }

  void printLeft(OutputBuffer &OB) const override {
    if (Ty) {
      if (Ty->printInitListAsType(OB, Inits))
        return;
      Ty->print(OB);
    }
    OB += '{';
    Inits.printWithComma(OB);
    OB += '}';
  }
};

class BracedExpr : public Node {
  const Node *Elem;
  const Node *Init;
  bool IsArray;
public:
  BracedExpr(const Node *Elem_, const Node *Init_, bool IsArray_)
      : Node(KBracedExpr), Elem(Elem_), Init(Init_), IsArray(IsArray_) {}

  template<typename Fn> void match(Fn F) const { F(Elem, Init, IsArray); }

  void printLeft(OutputBuffer &OB) const override {
    if (IsArray) {
      OB += '[';
      Elem->print(OB);
      OB += ']';
    } else {
      OB += '.';
      Elem->print(OB);
    }
    if (Init->getKind() != KBracedExpr && Init->getKind() != KBracedRangeExpr)
      OB += " = ";
    Init->print(OB);
  }
};

class BracedRangeExpr : public Node {
  const Node *First;
  const Node *Last;
  const Node *Init;
public:
  BracedRangeExpr(const Node *First_, const Node *Last_, const Node *Init_)
      : Node(KBracedRangeExpr), First(First_), Last(Last_), Init(Init_) {}

  template<typename Fn> void match(Fn F) const { F(First, Last, Init); }

  void printLeft(OutputBuffer &OB) const override {
    OB += '[';
    First->print(OB);
    OB += " ... ";
    Last->print(OB);
    OB += ']';
    if (Init->getKind() != KBracedExpr && Init->getKind() != KBracedRangeExpr)
      OB += " = ";
    Init->print(OB);
  }
};

class FoldExpr : public Node {
  const Node *Pack, *Init;
  std::string_view OperatorName;
  bool IsLeftFold;

public:
  FoldExpr(bool IsLeftFold_, std::string_view OperatorName_, const Node *Pack_,
           const Node *Init_)
      : Node(KFoldExpr), Pack(Pack_), Init(Init_), OperatorName(OperatorName_),
        IsLeftFold(IsLeftFold_) {}

  template<typename Fn> void match(Fn F) const {
    F(IsLeftFold, OperatorName, Pack, Init);
  }

  void printLeft(OutputBuffer &OB) const override {
    auto PrintPack = [&] {
      OB.printOpen();
      ParameterPackExpansion(Pack).print(OB);
      OB.printClose();
    };

    OB.printOpen();
    // Either '[init op ]... op pack' or 'pack op ...[ op init]'
    // Refactored to '[(init|pack) op ]...[ op (pack|init)]'
    // Fold expr operands are cast-expressions
    if (!IsLeftFold || Init != nullptr) {
      // '(init|pack) op '
      if (IsLeftFold)
        Init->printAsOperand(OB, Prec::Cast, true);
      else
        PrintPack();
      OB << " " << OperatorName << " ";
    }
    OB << "...";
    if (IsLeftFold || Init != nullptr) {
      // ' op (init|pack)'
      OB << " " << OperatorName << " ";
      if (IsLeftFold)
        PrintPack();
      else
        Init->printAsOperand(OB, Prec::Cast, true);
    }
    OB.printClose();
  }
};

class ThrowExpr : public Node {
  const Node *Op;

public:
  ThrowExpr(const Node *Op_) : Node(KThrowExpr), Op(Op_) {}

  template<typename Fn> void match(Fn F) const { F(Op); }

  void printLeft(OutputBuffer &OB) const override {
    OB += "throw ";
    Op->print(OB);
  }
};

class BoolExpr : public Node {
  bool Value;

public:
  BoolExpr(bool Value_) : Node(KBoolExpr), Value(Value_) {}

  template<typename Fn> void match(Fn F) const { F(Value); }

  void printLeft(OutputBuffer &OB) const override {
    OB += Value ? std::string_view("true") : std::string_view("false");
  }
};

class StringLiteral : public Node {
  const Node *Type;

public:
  StringLiteral(const Node *Type_) : Node(KStringLiteral), Type(Type_) {}

  template<typename Fn> void match(Fn F) const { F(Type); }

  void printLeft(OutputBuffer &OB) const override {
    OB += "\"<";
    Type->print(OB);
    OB += ">\"";
  }
};

class LambdaExpr : public Node {
  const Node *Type;

public:
  LambdaExpr(const Node *Type_) : Node(KLambdaExpr), Type(Type_) {}

  template<typename Fn> void match(Fn F) const { F(Type); }

  void printLeft(OutputBuffer &OB) const override {
    OB += "[]";
    if (Type->getKind() == KClosureTypeName)
      static_cast<const ClosureTypeName *>(Type)->printDeclarator(OB);
    OB += "{...}";
  }
};

class EnumLiteral : public Node {
  // ty(integer)
  const Node *Ty;
  std::string_view Integer;

public:
  EnumLiteral(const Node *Ty_, std::string_view Integer_)
      : Node(KEnumLiteral), Ty(Ty_), Integer(Integer_) {}

  template<typename Fn> void match(Fn F) const { F(Ty, Integer); }

  void printLeft(OutputBuffer &OB) const override {
    OB.printOpen();
    Ty->print(OB);
    OB.printClose();

    if (Integer[0] == 'n')
      OB << '-' << std::string_view(Integer.data() + 1, Integer.size() - 1);
    else
      OB << Integer;
  }
};

class IntegerLiteral : public Node {
  std::string_view Type;
  std::string_view Value;

public:
  IntegerLiteral(std::string_view Type_, std::string_view Value_)
      : Node(KIntegerLiteral), Type(Type_), Value(Value_) {}

  template<typename Fn> void match(Fn F) const { F(Type, Value); }

  void printLeft(OutputBuffer &OB) const override {
    if (Type.size() > 3) {
      OB.printOpen();
      OB += Type;
      OB.printClose();
    }

    if (Value[0] == 'n')
      OB << '-' << std::string_view(Value.data() + 1, Value.size() - 1);
    else
      OB += Value;

    if (Type.size() <= 3)
      OB += Type;
  }

  std::string_view value() const { return Value; }
};

class RequiresExpr : public Node {
  NodeArray Parameters;
  NodeArray Requirements;
public:
  RequiresExpr(NodeArray Parameters_, NodeArray Requirements_)
      : Node(KRequiresExpr), Parameters(Parameters_),
        Requirements(Requirements_) {}

  template<typename Fn> void match(Fn F) const { F(Parameters, Requirements); }

  void printLeft(OutputBuffer &OB) const override {
    OB += "requires";
    if (!Parameters.empty()) {
      OB += ' ';
      OB.printOpen();
      Parameters.printWithComma(OB);
      OB.printClose();
    }
    OB += ' ';
    OB.printOpen('{');
    for (const Node *Req : Requirements) {
      Req->print(OB);
    }
    OB += ' ';
    OB.printClose('}');
  }
};

class ExprRequirement : public Node {
  const Node *Expr;
  bool IsNoexcept;
  const Node *TypeConstraint;
public:
  ExprRequirement(const Node *Expr_, bool IsNoexcept_,
                  const Node *TypeConstraint_)
      : Node(KExprRequirement), Expr(Expr_), IsNoexcept(IsNoexcept_),
        TypeConstraint(TypeConstraint_) {}

  template <typename Fn> void match(Fn F) const {
    F(Expr, IsNoexcept, TypeConstraint);
  }

  void printLeft(OutputBuffer &OB) const override {
    OB += " ";
    if (IsNoexcept || TypeConstraint)
      OB.printOpen('{');
    Expr->print(OB);
    if (IsNoexcept || TypeConstraint)
      OB.printClose('}');
    if (IsNoexcept)
      OB += " noexcept";
    if (TypeConstraint) {
      OB += " -> ";
      TypeConstraint->print(OB);
    }
    OB += ';';
  }
};

class TypeRequirement : public Node {
  const Node *Type;
public:
  TypeRequirement(const Node *Type_)
      : Node(KTypeRequirement), Type(Type_) {}

  template <typename Fn> void match(Fn F) const { F(Type); }

  void printLeft(OutputBuffer &OB) const override {
    OB += " typename ";
    Type->print(OB);
    OB += ';';
  }
};

class NestedRequirement : public Node {
  const Node *Constraint;
public:
  NestedRequirement(const Node *Constraint_)
      : Node(KNestedRequirement), Constraint(Constraint_) {}

  template <typename Fn> void match(Fn F) const { F(Constraint); }

  void printLeft(OutputBuffer &OB) const override {
    OB += " requires ";
    Constraint->print(OB);
    OB += ';';
  }
};

template <class Float> struct FloatData;

namespace float_literal_impl {
constexpr Node::Kind getFloatLiteralKind(float *) {
  return Node::KFloatLiteral;
}
constexpr Node::Kind getFloatLiteralKind(double *) {
  return Node::KDoubleLiteral;
}
constexpr Node::Kind getFloatLiteralKind(long double *) {
  return Node::KLongDoubleLiteral;
}
}

template <class Float> class FloatLiteralImpl : public Node {
  const std::string_view Contents;

  static constexpr Kind KindForClass =
      float_literal_impl::getFloatLiteralKind((Float *)nullptr);

public:
  FloatLiteralImpl(std::string_view Contents_)
      : Node(KindForClass), Contents(Contents_) {}

  template<typename Fn> void match(Fn F) const { F(Contents); }

  void printLeft(OutputBuffer &OB) const override {
    const size_t N = FloatData<Float>::mangled_size;
    if (Contents.size() >= N) {
      union {
        Float value;
        char buf[sizeof(Float)];
      };
      const char *t = Contents.data();
      const char *last = t + N;
      char *e = buf;
      for (; t != last; ++t, ++e) {
        unsigned d1 = isdigit(*t) ? static_cast<unsigned>(*t - '0')
                                  : static_cast<unsigned>(*t - 'a' + 10);
        ++t;
        unsigned d0 = isdigit(*t) ? static_cast<unsigned>(*t - '0')
                                  : static_cast<unsigned>(*t - 'a' + 10);
        *e = static_cast<char>((d1 << 4) + d0);
      }
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      std::reverse(buf, e);
#endif
      char num[FloatData<Float>::max_demangled_size] = {0};
      int n = snprintf(num, sizeof(num), FloatData<Float>::spec, value);
      OB += std::string_view(num, n);
    }
  }
};

using FloatLiteral = FloatLiteralImpl<float>;
using DoubleLiteral = FloatLiteralImpl<double>;
using LongDoubleLiteral = FloatLiteralImpl<long double>;

/// Visit the node. Calls \c F(P), where \c P is the node cast to the
/// appropriate derived class.
template<typename Fn>
void Node::visit(Fn F) const {
  switch (K) {
#define NODE(X)                                                                \
  case K##X:                                                                   \
    return F(static_cast<const X *>(this));
#include "ItaniumNodes.def"
  }
  DEMANGLE_ASSERT(0, "unknown mangling node kind");
}

/// Determine the kind of a node from its type.
template<typename NodeT> struct NodeKind;
#define NODE(X)                                                                \
  template <> struct NodeKind<X> {                                             \
    static constexpr Node::Kind Kind = Node::K##X;                             \
    static constexpr const char *name() { return #X; }                         \
  };
#include "ItaniumNodes.def"

inline bool NodeArray::printAsString(OutputBuffer &OB) const {
  auto StartPos = OB.getCurrentPosition();
  auto Fail = [&OB, StartPos] {
    OB.setCurrentPosition(StartPos);
    return false;
  };

  OB += '"';
  bool LastWasNumericEscape = false;
  for (const Node *Element : *this) {
    if (Element->getKind() != Node::KIntegerLiteral)
      return Fail();
    int integer_value = 0;
    for (char c : static_cast<const IntegerLiteral *>(Element)->value()) {
      if (c < '0' || c > '9' || integer_value > 25)
        return Fail();
      integer_value *= 10;
      integer_value += c - '0';
    }
    if (integer_value > 255)
      return Fail();

    // Insert a `""` to avoid accidentally extending a numeric escape.
    if (LastWasNumericEscape) {
      if ((integer_value >= '0' && integer_value <= '9') ||
          (integer_value >= 'a' && integer_value <= 'f') ||
          (integer_value >= 'A' && integer_value <= 'F')) {
        OB += "\"\"";
      }
    }

    LastWasNumericEscape = false;

    // Determine how to print this character.
    switch (integer_value) {
    case '\a':
      OB += "\\a";
      break;
    case '\b':
      OB += "\\b";
      break;
    case '\f':
      OB += "\\f";
      break;
    case '\n':
      OB += "\\n";
      break;
    case '\r':
      OB += "\\r";
      break;
    case '\t':
      OB += "\\t";
      break;
    case '\v':
      OB += "\\v";
      break;

    case '"':
      OB += "\\\"";
      break;
    case '\\':
      OB += "\\\\";
      break;

    default:
      // We assume that the character is ASCII, and use a numeric escape for all
      // remaining non-printable ASCII characters.
      if (integer_value < 32 || integer_value == 127) {
        constexpr char Hex[] = "0123456789ABCDEF";
        OB += '\\';
        if (integer_value > 7)
          OB += 'x';
        if (integer_value >= 16)
          OB += Hex[integer_value >> 4];
        OB += Hex[integer_value & 0xF];
        LastWasNumericEscape = true;
        break;
      }

      // Assume all remaining characters are directly printable.
      OB += (char)integer_value;
      break;
    }
  }
  OB += '"';
  return true;
}

template <typename Derived, typename Alloc> struct AbstractManglingParser {
  const char *First;
  const char *Last;

  // Name stack, this is used by the parser to hold temporary names that were
  // parsed. The parser collapses multiple names into new nodes to construct
  // the AST. Once the parser is finished, names.size() == 1.
  PODSmallVector<Node *, 32> Names;

  // Substitution table. Itanium supports name substitutions as a means of
  // compression. The string "S42_" refers to the 44nd entry (base-36) in this
  // table.
  PODSmallVector<Node *, 32> Subs;

  // A list of template argument values corresponding to a template parameter
  // list.
  using TemplateParamList = PODSmallVector<Node *, 8>;

  class ScopedTemplateParamList {
    AbstractManglingParser *Parser;
    size_t OldNumTemplateParamLists;
    TemplateParamList Params;

  public:
    ScopedTemplateParamList(AbstractManglingParser *TheParser)
        : Parser(TheParser),
          OldNumTemplateParamLists(TheParser->TemplateParams.size()) {
      Parser->TemplateParams.push_back(&Params);
    }
    ~ScopedTemplateParamList() {
      DEMANGLE_ASSERT(Parser->TemplateParams.size() >= OldNumTemplateParamLists,
                      "");
      Parser->TemplateParams.shrinkToSize(OldNumTemplateParamLists);
    }
    TemplateParamList *params() { return &Params; }
  };

  // Template parameter table. Like the above, but referenced like "T42_".
  // This has a smaller size compared to Subs and Names because it can be
  // stored on the stack.
  TemplateParamList OuterTemplateParams;

  // Lists of template parameters indexed by template parameter depth,
  // referenced like "TL2_4_". If nonempty, element 0 is always
  // OuterTemplateParams; inner elements are always template parameter lists of
  // lambda expressions. For a generic lambda with no explicit template
  // parameter list, the corresponding parameter list pointer will be null.
  PODSmallVector<TemplateParamList *, 4> TemplateParams;

  class SaveTemplateParams {
    AbstractManglingParser *Parser;
    decltype(TemplateParams) OldParams;
    decltype(OuterTemplateParams) OldOuterParams;

  public:
    SaveTemplateParams(AbstractManglingParser *TheParser) : Parser(TheParser) {
      OldParams = std::move(Parser->TemplateParams);
      OldOuterParams = std::move(Parser->OuterTemplateParams);
      Parser->TemplateParams.clear();
      Parser->OuterTemplateParams.clear();
    }
    ~SaveTemplateParams() {
      Parser->TemplateParams = std::move(OldParams);
      Parser->OuterTemplateParams = std::move(OldOuterParams);
    }
  };

  // Set of unresolved forward <template-param> references. These can occur in a
  // conversion operator's type, and are resolved in the enclosing <encoding>.
  PODSmallVector<ForwardTemplateReference *, 4> ForwardTemplateRefs;

  bool TryToParseTemplateArgs = true;
  bool PermitForwardTemplateReferences = false;
  bool HasIncompleteTemplateParameterTracking = false;
  size_t ParsingLambdaParamsAtLevel = (size_t)-1;

  unsigned NumSyntheticTemplateParameters[3] = {};

  Alloc ASTAllocator;

  AbstractManglingParser(const char *First_, const char *Last_)
      : First(First_), Last(Last_) {}

  Derived &getDerived() { return static_cast<Derived &>(*this); }

  void reset(const char *First_, const char *Last_) {
    First = First_;
    Last = Last_;
    Names.clear();
    Subs.clear();
    TemplateParams.clear();
    ParsingLambdaParamsAtLevel = (size_t)-1;
    TryToParseTemplateArgs = true;
    PermitForwardTemplateReferences = false;
    for (int I = 0; I != 3; ++I)
      NumSyntheticTemplateParameters[I] = 0;
    ASTAllocator.reset();
  }

  template <class T, class... Args> Node *make(Args &&... args) {
    return ASTAllocator.template makeNode<T>(std::forward<Args>(args)...);
  }

  template <class It> NodeArray makeNodeArray(It begin, It end) {
    size_t sz = static_cast<size_t>(end - begin);
    void *mem = ASTAllocator.allocateNodeArray(sz);
    Node **data = new (mem) Node *[sz];
    std::copy(begin, end, data);
    return NodeArray(data, sz);
  }

  NodeArray popTrailingNodeArray(size_t FromPosition) {
    DEMANGLE_ASSERT(FromPosition <= Names.size(), "");
    NodeArray res =
        makeNodeArray(Names.begin() + (long)FromPosition, Names.end());
    Names.shrinkToSize(FromPosition);
    return res;
  }

  bool consumeIf(std::string_view S) {
    if (starts_with(std::string_view(First, Last - First), S)) {
      First += S.size();
      return true;
    }
    return false;
  }

  bool consumeIf(char C) {
    if (First != Last && *First == C) {
      ++First;
      return true;
    }
    return false;
  }

  char consume() { return First != Last ? *First++ : '\0'; }

  char look(unsigned Lookahead = 0) const {
    if (static_cast<size_t>(Last - First) <= Lookahead)
      return '\0';
    return First[Lookahead];
  }

  size_t numLeft() const { return static_cast<size_t>(Last - First); }

  std::string_view parseNumber(bool AllowNegative = false);
  Qualifiers parseCVQualifiers();
  bool parsePositiveInteger(size_t *Out);
  std::string_view parseBareSourceName();

  bool parseSeqId(size_t *Out);
  Node *parseSubstitution();
  Node *parseTemplateParam();
  Node *parseTemplateParamDecl(TemplateParamList *Params);
  Node *parseTemplateArgs(bool TagTemplates = false);
  Node *parseTemplateArg();

  bool isTemplateParamDecl() {
    return look() == 'T' &&
           std::string_view("yptnk").find(look(1)) != std::string_view::npos;
  }

  /// Parse the <expression> production.
  Node *parseExpr();
  Node *parsePrefixExpr(std::string_view Kind, Node::Prec Prec);
  Node *parseBinaryExpr(std::string_view Kind, Node::Prec Prec);
  Node *parseIntegerLiteral(std::string_view Lit);
  Node *parseExprPrimary();
  template <class Float> Node *parseFloatingLiteral();
  Node *parseFunctionParam();
  Node *parseConversionExpr();
  Node *parseBracedExpr();
  Node *parseFoldExpr();
  Node *parsePointerToMemberConversionExpr(Node::Prec Prec);
  Node *parseSubobjectExpr();
  Node *parseConstraintExpr();
  Node *parseRequiresExpr();

  /// Parse the <type> production.
  Node *parseType();
  Node *parseFunctionType();
  Node *parseVectorType();
  Node *parseDecltype();
  Node *parseArrayType();
  Node *parsePointerToMemberType();
  Node *parseClassEnumType();
  Node *parseQualifiedType();

  Node *parseEncoding(bool ParseParams = true);
  bool parseCallOffset();
  Node *parseSpecialName();

  /// Holds some extra information about a <name> that is being parsed. This
  /// information is only pertinent if the <name> refers to an <encoding>.
  struct NameState {
    bool CtorDtorConversion = false;
    bool EndsWithTemplateArgs = false;
    Qualifiers CVQualifiers = QualNone;
    FunctionRefQual ReferenceQualifier = FrefQualNone;
    size_t ForwardTemplateRefsBegin;
    bool HasExplicitObjectParameter = false;

    NameState(AbstractManglingParser *Enclosing)
        : ForwardTemplateRefsBegin(Enclosing->ForwardTemplateRefs.size()) {}
  };

  bool resolveForwardTemplateRefs(NameState &State) {
    size_t I = State.ForwardTemplateRefsBegin;
    size_t E = ForwardTemplateRefs.size();
    for (; I < E; ++I) {
      size_t Idx = ForwardTemplateRefs[I]->Index;
      if (TemplateParams.empty() || !TemplateParams[0] ||
          Idx >= TemplateParams[0]->size())
        return true;
      ForwardTemplateRefs[I]->Ref = (*TemplateParams[0])[Idx];
    }
    ForwardTemplateRefs.shrinkToSize(State.ForwardTemplateRefsBegin);
    return false;
  }

  /// Parse the <name> production>
  Node *parseName(NameState *State = nullptr);
  Node *parseLocalName(NameState *State);
  Node *parseOperatorName(NameState *State);
  bool parseModuleNameOpt(ModuleName *&Module);
  Node *parseUnqualifiedName(NameState *State, Node *Scope, ModuleName *Module);
  Node *parseUnnamedTypeName(NameState *State);
  Node *parseSourceName(NameState *State);
  Node *parseUnscopedName(NameState *State, bool *isSubstName);
  Node *parseNestedName(NameState *State);
  Node *parseCtorDtorName(Node *&SoFar, NameState *State);

  Node *parseAbiTags(Node *N);

  struct OperatorInfo {
    enum OIKind : unsigned char {
      Prefix,      // Prefix unary: @ expr
      Postfix,     // Postfix unary: expr @
      Binary,      // Binary: lhs @ rhs
      Array,       // Array index:  lhs [ rhs ]
      Member,      // Member access: lhs @ rhs
      New,         // New
      Del,         // Delete
      Call,        // Function call: expr (expr*)
      CCast,       // C cast: (type)expr
      Conditional, // Conditional: expr ? expr : expr
      NameOnly,    // Overload only, not allowed in expression.
      // Below do not have operator names
      NamedCast, // Named cast, @<type>(expr)
      OfIdOp,    // alignof, sizeof, typeid

      Unnameable = NamedCast,
    };
    char Enc[2];      // Encoding
    OIKind Kind;      // Kind of operator
    bool Flag : 1;    // Entry-specific flag
    Node::Prec Prec : 7; // Precedence
    const char *Name; // Spelling

  public:
    constexpr OperatorInfo(const char (&E)[3], OIKind K, bool F, Node::Prec P,
                           const char *N)
        : Enc{E[0], E[1]}, Kind{K}, Flag{F}, Prec{P}, Name{N} {}

  public:
    bool operator<(const OperatorInfo &Other) const {
      return *this < Other.Enc;
    }
    bool operator<(const char *Peek) const {
      return Enc[0] < Peek[0] || (Enc[0] == Peek[0] && Enc[1] < Peek[1]);
    }
    bool operator==(const char *Peek) const {
      return Enc[0] == Peek[0] && Enc[1] == Peek[1];
    }
    bool operator!=(const char *Peek) const { return !this->operator==(Peek); }

  public:
    std::string_view getSymbol() const {
      std::string_view Res = Name;
      if (Kind < Unnameable) {
        DEMANGLE_ASSERT(starts_with(Res, "operator"),
                        "operator name does not start with 'operator'");
        Res.remove_prefix(sizeof("operator") - 1);
        if (starts_with(Res, ' '))
          Res.remove_prefix(1);
      }
      return Res;
    }
    std::string_view getName() const { return Name; }
    OIKind getKind() const { return Kind; }
    bool getFlag() const { return Flag; }
    Node::Prec getPrecedence() const { return Prec; }
  };
  static const OperatorInfo Ops[];
  static const size_t NumOps;
  const OperatorInfo *parseOperatorEncoding();

  /// Parse the <unresolved-name> production.
  Node *parseUnresolvedName(bool Global);
  Node *parseSimpleId();
  Node *parseBaseUnresolvedName();
  Node *parseUnresolvedType();
  Node *parseDestructorName();

  /// Top-level entry point into the parser.
  Node *parse(bool ParseParams = true);
};

DEMANGLE_ABI const char *parse_discriminator(const char *first,
                                             const char *last);

// <name> ::= <nested-name> // N
//        ::= <local-name> # See Scope Encoding below  // Z
//        ::= <unscoped-template-name> <template-args>
//        ::= <unscoped-name>
//
// <unscoped-template-name> ::= <unscoped-name>
//                          ::= <substitution>
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseName(NameState *State) {
  if (look() == 'N')
    return getDerived().parseNestedName(State);
  if (look() == 'Z')
    return getDerived().parseLocalName(State);

  Node *Result = nullptr;
  bool IsSubst = false;

  Result = getDerived().parseUnscopedName(State, &IsSubst);
  if (!Result)
    return nullptr;

  if (look() == 'I') {
    //        ::= <unscoped-template-name> <template-args>
    if (!IsSubst)
      // An unscoped-template-name is substitutable.
      Subs.push_back(Result);
    Node *TA = getDerived().parseTemplateArgs(State != nullptr);
    if (TA == nullptr)
      return nullptr;
    if (State)
      State->EndsWithTemplateArgs = true;
    Result = make<NameWithTemplateArgs>(Result, TA);
  } else if (IsSubst) {
    // The substitution case must be followed by <template-args>.
    return nullptr;
  }

  return Result;
}

// <local-name> := Z <function encoding> E <entity name> [<discriminator>]
//              := Z <function encoding> E s [<discriminator>]
//              := Z <function encoding> Ed [ <parameter number> ] _ <entity name>
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseLocalName(NameState *State) {
  if (!consumeIf('Z'))
    return nullptr;
  Node *Encoding = getDerived().parseEncoding();
  if (Encoding == nullptr || !consumeIf('E'))
    return nullptr;

  if (consumeIf('s')) {
    First = parse_discriminator(First, Last);
    auto *StringLitName = make<NameType>("string literal");
    if (!StringLitName)
      return nullptr;
    return make<LocalName>(Encoding, StringLitName);
  }

  // The template parameters of the inner name are unrelated to those of the
  // enclosing context.
  SaveTemplateParams SaveTemplateParamsScope(this);

  if (consumeIf('d')) {
    parseNumber(true);
    if (!consumeIf('_'))
      return nullptr;
    Node *N = getDerived().parseName(State);
    if (N == nullptr)
      return nullptr;
    return make<LocalName>(Encoding, N);
  }

  Node *Entity = getDerived().parseName(State);
  if (Entity == nullptr)
    return nullptr;
  First = parse_discriminator(First, Last);
  return make<LocalName>(Encoding, Entity);
}

// <unscoped-name> ::= <unqualified-name>
//                 ::= St <unqualified-name>   # ::std::
// [*] extension
template <typename Derived, typename Alloc>
Node *
AbstractManglingParser<Derived, Alloc>::parseUnscopedName(NameState *State,
                                                          bool *IsSubst) {

  Node *Std = nullptr;
  if (consumeIf("St")) {
    Std = make<NameType>("std");
    if (Std == nullptr)
      return nullptr;
  }

  Node *Res = nullptr;
  ModuleName *Module = nullptr;
  if (look() == 'S') {
    Node *S = getDerived().parseSubstitution();
    if (!S)
      return nullptr;
    if (S->getKind() == Node::KModuleName)
      Module = static_cast<ModuleName *>(S);
    else if (IsSubst && Std == nullptr) {
      Res = S;
      *IsSubst = true;
    } else {
      return nullptr;
    }
  }

  if (Res == nullptr || Std != nullptr) {
    Res = getDerived().parseUnqualifiedName(State, Std, Module);
  }

  return Res;
}

// <unqualified-name> ::= [<module-name>] F? L? <operator-name> [<abi-tags>]
//                    ::= [<module-name>] <ctor-dtor-name> [<abi-tags>]
//                    ::= [<module-name>] F? L? <source-name> [<abi-tags>]
//                    ::= [<module-name>] L? <unnamed-type-name> [<abi-tags>]
//			# structured binding declaration
//                    ::= [<module-name>] L? DC <source-name>+ E
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseUnqualifiedName(
    NameState *State, Node *Scope, ModuleName *Module) {
  if (getDerived().parseModuleNameOpt(Module))
    return nullptr;

  bool IsMemberLikeFriend = Scope && consumeIf('F');

  consumeIf('L');

  Node *Result;
  if (look() >= '1' && look() <= '9') {
    Result = getDerived().parseSourceName(State);
  } else if (look() == 'U') {
    Result = getDerived().parseUnnamedTypeName(State);
  } else if (consumeIf("DC")) {
    // Structured binding
    size_t BindingsBegin = Names.size();
    do {
      Node *Binding = getDerived().parseSourceName(State);
      if (Binding == nullptr)
        return nullptr;
      Names.push_back(Binding);
    } while (!consumeIf('E'));
    Result = make<StructuredBindingName>(popTrailingNodeArray(BindingsBegin));
  } else if (look() == 'C' || look() == 'D') {
    // A <ctor-dtor-name>.
    if (Scope == nullptr || Module != nullptr)
      return nullptr;
    Result = getDerived().parseCtorDtorName(Scope, State);
  } else {
    Result = getDerived().parseOperatorName(State);
  }

  if (Result != nullptr && Module != nullptr)
    Result = make<ModuleEntity>(Module, Result);
  if (Result != nullptr)
    Result = getDerived().parseAbiTags(Result);
  if (Result != nullptr && IsMemberLikeFriend)
    Result = make<MemberLikeFriendName>(Scope, Result);
  else if (Result != nullptr && Scope != nullptr)
    Result = make<NestedName>(Scope, Result);

  return Result;
}

// <module-name> ::= <module-subname>
// 	 	 ::= <module-name> <module-subname>
//		 ::= <substitution>  # passed in by caller
// <module-subname> ::= W <source-name>
//		    ::= W P <source-name>
template <typename Derived, typename Alloc>
bool AbstractManglingParser<Derived, Alloc>::parseModuleNameOpt(
    ModuleName *&Module) {
  while (consumeIf('W')) {
    bool IsPartition = consumeIf('P');
    Node *Sub = getDerived().parseSourceName(nullptr);
    if (!Sub)
      return true;
    Module =
        static_cast<ModuleName *>(make<ModuleName>(Module, Sub, IsPartition));
    Subs.push_back(Module);
  }

  return false;
}

// <unnamed-type-name> ::= Ut [<nonnegative number>] _
//                     ::= <closure-type-name>
//
// <closure-type-name> ::= Ul <lambda-sig> E [ <nonnegative number> ] _
//
// <lambda-sig> ::= <template-param-decl>* [Q <requires-clause expression>]
//                  <parameter type>+  # or "v" if the lambda has no parameters
template <typename Derived, typename Alloc>
Node *
AbstractManglingParser<Derived, Alloc>::parseUnnamedTypeName(NameState *State) {
  // <template-params> refer to the innermost <template-args>. Clear out any
  // outer args that we may have inserted into TemplateParams.
  if (State != nullptr)
    TemplateParams.clear();

  if (consumeIf("Ut")) {
    std::string_view Count = parseNumber();
    if (!consumeIf('_'))
      return nullptr;
    return make<UnnamedTypeName>(Count);
  }
  if (consumeIf("Ul")) {
    ScopedOverride<size_t> SwapParams(ParsingLambdaParamsAtLevel,
                                      TemplateParams.size());
    ScopedTemplateParamList LambdaTemplateParams(this);

    size_t ParamsBegin = Names.size();
    while (getDerived().isTemplateParamDecl()) {
      Node *T =
          getDerived().parseTemplateParamDecl(LambdaTemplateParams.params());
      if (T == nullptr)
        return nullptr;
      Names.push_back(T);
    }
    NodeArray TempParams = popTrailingNodeArray(ParamsBegin);

    // FIXME: If TempParams is empty and none of the function parameters
    // includes 'auto', we should remove LambdaTemplateParams from the
    // TemplateParams list. Unfortunately, we don't find out whether there are
    // any 'auto' parameters until too late in an example such as:
    //
    //   template<typename T> void f(
    //       decltype([](decltype([]<typename T>(T v) {}),
    //                   auto) {})) {}
    //   template<typename T> void f(
    //       decltype([](decltype([]<typename T>(T w) {}),
    //                   int) {})) {}
    //
    // Here, the type of v is at level 2 but the type of w is at level 1. We
    // don't find this out until we encounter the type of the next parameter.
    //
    // However, compilers can't actually cope with the former example in
    // practice, and it's likely to be made ill-formed in future, so we don't
    // need to support it here.
    //
    // If we encounter an 'auto' in the function parameter types, we will
    // recreate a template parameter scope for it, but any intervening lambdas
    // will be parsed in the 'wrong' template parameter depth.
    if (TempParams.empty())
      TemplateParams.pop_back();

    Node *Requires1 = nullptr;
    if (consumeIf('Q')) {
      Requires1 = getDerived().parseConstraintExpr();
      if (Requires1 == nullptr)
        return nullptr;
    }

    if (!consumeIf("v")) {
      do {
        Node *P = getDerived().parseType();
        if (P == nullptr)
          return nullptr;
        Names.push_back(P);
      } while (look() != 'E' && look() != 'Q');
    }
    NodeArray Params = popTrailingNodeArray(ParamsBegin);

    Node *Requires2 = nullptr;
    if (consumeIf('Q')) {
      Requires2 = getDerived().parseConstraintExpr();
      if (Requires2 == nullptr)
        return nullptr;
    }

    if (!consumeIf('E'))
      return nullptr;

    std::string_view Count = parseNumber();
    if (!consumeIf('_'))
      return nullptr;
    return make<ClosureTypeName>(TempParams, Requires1, Params, Requires2,
                                 Count);
  }
  if (consumeIf("Ub")) {
    (void)parseNumber();
    if (!consumeIf('_'))
      return nullptr;
    return make<NameType>("'block-literal'");
  }
  return nullptr;
}

// <source-name> ::= <positive length number> <identifier>
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseSourceName(NameState *) {
  size_t Length = 0;
  if (parsePositiveInteger(&Length))
    return nullptr;
  if (numLeft() < Length || Length == 0)
    return nullptr;
  std::string_view Name(First, Length);
  First += Length;
  if (starts_with(Name, "_GLOBAL__N"))
    return make<NameType>("(anonymous namespace)");
  return make<NameType>(Name);
}

// Operator encodings
template <typename Derived, typename Alloc>
const typename AbstractManglingParser<
    Derived, Alloc>::OperatorInfo AbstractManglingParser<Derived,
                                                         Alloc>::Ops[] = {
    // Keep ordered by encoding
    {"aN", OperatorInfo::Binary, false, Node::Prec::Assign, "operator&="},
    {"aS", OperatorInfo::Binary, false, Node::Prec::Assign, "operator="},
    {"aa", OperatorInfo::Binary, false, Node::Prec::AndIf, "operator&&"},
    {"ad", OperatorInfo::Prefix, false, Node::Prec::Unary, "operator&"},
    {"an", OperatorInfo::Binary, false, Node::Prec::And, "operator&"},
    {"at", OperatorInfo::OfIdOp, /*Type*/ true, Node::Prec::Unary, "alignof "},
    {"aw", OperatorInfo::NameOnly, false, Node::Prec::Primary,
     "operator co_await"},
    {"az", OperatorInfo::OfIdOp, /*Type*/ false, Node::Prec::Unary, "alignof "},
    {"cc", OperatorInfo::NamedCast, false, Node::Prec::Postfix, "const_cast"},
    {"cl", OperatorInfo::Call, /*Paren*/ false, Node::Prec::Postfix,
     "operator()"},
    {"cm", OperatorInfo::Binary, false, Node::Prec::Comma, "operator,"},
    {"co", OperatorInfo::Prefix, false, Node::Prec::Unary, "operator~"},
    {"cp", OperatorInfo::Call, /*Paren*/ true, Node::Prec::Postfix,
     "operator()"},
    {"cv", OperatorInfo::CCast, false, Node::Prec::Cast, "operator"}, // C Cast
    {"dV", OperatorInfo::Binary, false, Node::Prec::Assign, "operator/="},
    {"da", OperatorInfo::Del, /*Ary*/ true, Node::Prec::Unary,
     "operator delete[]"},
    {"dc", OperatorInfo::NamedCast, false, Node::Prec::Postfix, "dynamic_cast"},
    {"de", OperatorInfo::Prefix, false, Node::Prec::Unary, "operator*"},
    {"dl", OperatorInfo::Del, /*Ary*/ false, Node::Prec::Unary,
     "operator delete"},
    {"ds", OperatorInfo::Member, /*Named*/ false, Node::Prec::PtrMem,
     "operator.*"},
    {"dt", OperatorInfo::Member, /*Named*/ false, Node::Prec::Postfix,
     "operator."},
    {"dv", OperatorInfo::Binary, false, Node::Prec::Assign, "operator/"},
    {"eO", OperatorInfo::Binary, false, Node::Prec::Assign, "operator^="},
    {"eo", OperatorInfo::Binary, false, Node::Prec::Xor, "operator^"},
    {"eq", OperatorInfo::Binary, false, Node::Prec::Equality, "operator=="},
    {"ge", OperatorInfo::Binary, false, Node::Prec::Relational, "operator>="},
    {"gt", OperatorInfo::Binary, false, Node::Prec::Relational, "operator>"},
    {"ix", OperatorInfo::Array, false, Node::Prec::Postfix, "operator[]"},
    {"lS", OperatorInfo::Binary, false, Node::Prec::Assign, "operator<<="},
    {"le", OperatorInfo::Binary, false, Node::Prec::Relational, "operator<="},
    {"ls", OperatorInfo::Binary, false, Node::Prec::Shift, "operator<<"},
    {"lt", OperatorInfo::Binary, false, Node::Prec::Relational, "operator<"},
    {"mI", OperatorInfo::Binary, false, Node::Prec::Assign, "operator-="},
    {"mL", OperatorInfo::Binary, false, Node::Prec::Assign, "operator*="},
    {"mi", OperatorInfo::Binary, false, Node::Prec::Additive, "operator-"},
    {"ml", OperatorInfo::Binary, false, Node::Prec::Multiplicative,
     "operator*"},
    {"mm", OperatorInfo::Postfix, false, Node::Prec::Postfix, "operator--"},
    {"na", OperatorInfo::New, /*Ary*/ true, Node::Prec::Unary,
     "operator new[]"},
    {"ne", OperatorInfo::Binary, false, Node::Prec::Equality, "operator!="},
    {"ng", OperatorInfo::Prefix, false, Node::Prec::Unary, "operator-"},
    {"nt", OperatorInfo::Prefix, false, Node::Prec::Unary, "operator!"},
    {"nw", OperatorInfo::New, /*Ary*/ false, Node::Prec::Unary, "operator new"},
    {"oR", OperatorInfo::Binary, false, Node::Prec::Assign, "operator|="},
    {"oo", OperatorInfo::Binary, false, Node::Prec::OrIf, "operator||"},
    {"or", OperatorInfo::Binary, false, Node::Prec::Ior, "operator|"},
    {"pL", OperatorInfo::Binary, false, Node::Prec::Assign, "operator+="},
    {"pl", OperatorInfo::Binary, false, Node::Prec::Additive, "operator+"},
    {"pm", OperatorInfo::Member, /*Named*/ true, Node::Prec::PtrMem,
     "operator->*"},
    {"pp", OperatorInfo::Postfix, false, Node::Prec::Postfix, "operator++"},
    {"ps", OperatorInfo::Prefix, false, Node::Prec::Unary, "operator+"},
    {"pt", OperatorInfo::Member, /*Named*/ true, Node::Prec::Postfix,
     "operator->"},
    {"qu", OperatorInfo::Conditional, false, Node::Prec::Conditional,
     "operator?"},
    {"rM", OperatorInfo::Binary, false, Node::Prec::Assign, "operator%="},
    {"rS", OperatorInfo::Binary, false, Node::Prec::Assign, "operator>>="},
    {"rc", OperatorInfo::NamedCast, false, Node::Prec::Postfix,
     "reinterpret_cast"},
    {"rm", OperatorInfo::Binary, false, Node::Prec::Multiplicative,
     "operator%"},
    {"rs", OperatorInfo::Binary, false, Node::Prec::Shift, "operator>>"},
    {"sc", OperatorInfo::NamedCast, false, Node::Prec::Postfix, "static_cast"},
    {"ss", OperatorInfo::Binary, false, Node::Prec::Spaceship, "operator<=>"},
    {"st", OperatorInfo::OfIdOp, /*Type*/ true, Node::Prec::Unary, "sizeof "},
    {"sz", OperatorInfo::OfIdOp, /*Type*/ false, Node::Prec::Unary, "sizeof "},
    {"te", OperatorInfo::OfIdOp, /*Type*/ false, Node::Prec::Postfix,
     "typeid "},
    {"ti", OperatorInfo::OfIdOp, /*Type*/ true, Node::Prec::Postfix, "typeid "},
};
template <typename Derived, typename Alloc>
const size_t AbstractManglingParser<Derived, Alloc>::NumOps = sizeof(Ops) /
                                                              sizeof(Ops[0]);

// If the next 2 chars are an operator encoding, consume them and return their
// OperatorInfo.  Otherwise return nullptr.
template <typename Derived, typename Alloc>
const typename AbstractManglingParser<Derived, Alloc>::OperatorInfo *
AbstractManglingParser<Derived, Alloc>::parseOperatorEncoding() {
  if (numLeft() < 2)
    return nullptr;

  // We can't use lower_bound as that can link to symbols in the C++ library,
  // and this must remain independent of that.
  size_t lower = 0u, upper = NumOps - 1; // Inclusive bounds.
  while (upper != lower) {
    size_t middle = (upper + lower) / 2;
    if (Ops[middle] < First)
      lower = middle + 1;
    else
      upper = middle;
  }
  if (Ops[lower] != First)
    return nullptr;

  First += 2;
  return &Ops[lower];
}

//   <operator-name> ::= See parseOperatorEncoding()
//                   ::= li <source-name>  # operator ""
//                   ::= v <digit> <source-name>  # vendor extended operator
template <typename Derived, typename Alloc>
Node *
AbstractManglingParser<Derived, Alloc>::parseOperatorName(NameState *State) {
  if (const auto *Op = parseOperatorEncoding()) {
    if (Op->getKind() == OperatorInfo::CCast) {
      //              ::= cv <type>    # (cast)
      ScopedOverride<bool> SaveTemplate(TryToParseTemplateArgs, false);
      // If we're parsing an encoding, State != nullptr and the conversion
      // operators' <type> could have a <template-param> that refers to some
      // <template-arg>s further ahead in the mangled name.
      ScopedOverride<bool> SavePermit(PermitForwardTemplateReferences,
                                      PermitForwardTemplateReferences ||
                                          State != nullptr);
      Node *Ty = getDerived().parseType();
      if (Ty == nullptr)
        return nullptr;
      if (State) State->CtorDtorConversion = true;
      return make<ConversionOperatorType>(Ty);
    }

    if (Op->getKind() >= OperatorInfo::Unnameable)
      /* Not a nameable operator.  */
      return nullptr;
    if (Op->getKind() == OperatorInfo::Member && !Op->getFlag())
      /* Not a nameable MemberExpr */
      return nullptr;

    return make<NameType>(Op->getName());
  }

  if (consumeIf("li")) {
    //                   ::= li <source-name>  # operator ""
    Node *SN = getDerived().parseSourceName(State);
    if (SN == nullptr)
      return nullptr;
    return make<LiteralOperator>(SN);
  }

  if (consumeIf('v')) {
    // ::= v <digit> <source-name>        # vendor extended operator
    if (look() >= '0' && look() <= '9') {
      First++;
      Node *SN = getDerived().parseSourceName(State);
      if (SN == nullptr)
        return nullptr;
      return make<ConversionOperatorType>(SN);
    }
    return nullptr;
  }

  return nullptr;
}

// <ctor-dtor-name> ::= C1  # complete object constructor
//                  ::= C2  # base object constructor
//                  ::= C3  # complete object allocating constructor
//   extension      ::= C4  # gcc old-style "[unified]" constructor
//   extension      ::= C5  # the COMDAT used for ctors
//                  ::= D0  # deleting destructor
//                  ::= D1  # complete object destructor
//                  ::= D2  # base object destructor
//   extension      ::= D4  # gcc old-style "[unified]" destructor
//   extension      ::= D5  # the COMDAT used for dtors
template <typename Derived, typename Alloc>
Node *
AbstractManglingParser<Derived, Alloc>::parseCtorDtorName(Node *&SoFar,
                                                          NameState *State) {
  if (SoFar->getKind() == Node::KSpecialSubstitution) {
    // Expand the special substitution.
    SoFar = make<ExpandedSpecialSubstitution>(
        static_cast<SpecialSubstitution *>(SoFar));
    if (!SoFar)
      return nullptr;
  }

  if (consumeIf('C')) {
    bool IsInherited = consumeIf('I');
    if (look() != '1' && look() != '2' && look() != '3' && look() != '4' &&
        look() != '5')
      return nullptr;
    int Variant = look() - '0';
    ++First;
    if (State) State->CtorDtorConversion = true;
    if (IsInherited) {
      if (getDerived().parseName(State) == nullptr)
        return nullptr;
    }
    return make<CtorDtorName>(SoFar, /*IsDtor=*/false, Variant);
  }

  if (look() == 'D' && (look(1) == '0' || look(1) == '1' || look(1) == '2' ||
                        look(1) == '4' || look(1) == '5')) {
    int Variant = look(1) - '0';
    First += 2;
    if (State) State->CtorDtorConversion = true;
    return make<CtorDtorName>(SoFar, /*IsDtor=*/true, Variant);
  }

  return nullptr;
}

// <nested-name> ::= N [<CV-Qualifiers>] [<ref-qualifier>] <prefix>
// 			<unqualified-name> E
//               ::= N [<CV-Qualifiers>] [<ref-qualifier>] <template-prefix>
//               	<template-args> E
//
// <prefix> ::= <prefix> <unqualified-name>
//          ::= <template-prefix> <template-args>
//          ::= <template-param>
//          ::= <decltype>
//          ::= # empty
//          ::= <substitution>
//          ::= <prefix> <data-member-prefix>
// [*] extension
//
// <data-member-prefix> := <member source-name> [<template-args>] M
//
// <template-prefix> ::= <prefix> <template unqualified-name>
//                   ::= <template-param>
//                   ::= <substitution>
template <typename Derived, typename Alloc>
Node *
AbstractManglingParser<Derived, Alloc>::parseNestedName(NameState *State) {
  if (!consumeIf('N'))
    return nullptr;

  // 'H' specifies that the encoding that follows
  // has an explicit object parameter.
  if (!consumeIf('H')) {
    Qualifiers CVTmp = parseCVQualifiers();
    if (State)
      State->CVQualifiers = CVTmp;

    if (consumeIf('O')) {
      if (State)
        State->ReferenceQualifier = FrefQualRValue;
    } else if (consumeIf('R')) {
      if (State)
        State->ReferenceQualifier = FrefQualLValue;
    } else {
      if (State)
        State->ReferenceQualifier = FrefQualNone;
    }
  } else if (State) {
    State->HasExplicitObjectParameter = true;
  }

  Node *SoFar = nullptr;
  while (!consumeIf('E')) {
    if (State)
      // Only set end-with-template on the case that does that.
      State->EndsWithTemplateArgs = false;

    if (look() == 'T') {
      //          ::= <template-param>
      if (SoFar != nullptr)
        return nullptr; // Cannot have a prefix.
      SoFar = getDerived().parseTemplateParam();
    } else if (look() == 'I') {
      //          ::= <template-prefix> <template-args>
      if (SoFar == nullptr)
        return nullptr; // Must have a prefix.
      Node *TA = getDerived().parseTemplateArgs(State != nullptr);
      if (TA == nullptr)
        return nullptr;
      if (SoFar->getKind() == Node::KNameWithTemplateArgs)
        // Semantically <template-args> <template-args> cannot be generated by a
        // C++ entity.  There will always be [something like] a name between
        // them.
        return nullptr;
      if (State)
        State->EndsWithTemplateArgs = true;
      SoFar = make<NameWithTemplateArgs>(SoFar, TA);
    } else if (look() == 'D' && (look(1) == 't' || look(1) == 'T')) {
      //          ::= <decltype>
      if (SoFar != nullptr)
        return nullptr; // Cannot have a prefix.
      SoFar = getDerived().parseDecltype();
    } else {
      ModuleName *Module = nullptr;

      if (look() == 'S') {
        //          ::= <substitution>
        Node *S = nullptr;
        if (look(1) == 't') {
          First += 2;
          S = make<NameType>("std");
        } else {
          S = getDerived().parseSubstitution();
        }
        if (!S)
          return nullptr;
        if (S->getKind() == Node::KModuleName) {
          Module = static_cast<ModuleName *>(S);
        } else if (SoFar != nullptr) {
          return nullptr; // Cannot have a prefix.
        } else {
          SoFar = S;
          continue; // Do not push a new substitution.
        }
      }

      //          ::= [<prefix>] <unqualified-name>
      SoFar = getDerived().parseUnqualifiedName(State, SoFar, Module);
    }

    if (SoFar == nullptr)
      return nullptr;
    Subs.push_back(SoFar);

    // No longer used.
    // <data-member-prefix> := <member source-name> [<template-args>] M
    consumeIf('M');
  }

  if (SoFar == nullptr || Subs.empty())
    return nullptr;

  Subs.pop_back();
  return SoFar;
}

// <simple-id> ::= <source-name> [ <template-args> ]
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseSimpleId() {
  Node *SN = getDerived().parseSourceName(/*NameState=*/nullptr);
  if (SN == nullptr)
    return nullptr;
  if (look() == 'I') {
    Node *TA = getDerived().parseTemplateArgs();
    if (TA == nullptr)
      return nullptr;
    return make<NameWithTemplateArgs>(SN, TA);
  }
  return SN;
}

// <destructor-name> ::= <unresolved-type>  # e.g., ~T or ~decltype(f())
//                   ::= <simple-id>        # e.g., ~A<2*N>
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseDestructorName() {
  Node *Result;
  if (std::isdigit(look()))
    Result = getDerived().parseSimpleId();
  else
    Result = getDerived().parseUnresolvedType();
  if (Result == nullptr)
    return nullptr;
  return make<DtorName>(Result);
}

// <unresolved-type> ::= <template-param>
//                   ::= <decltype>
//                   ::= <substitution>
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseUnresolvedType() {
  if (look() == 'T') {
    Node *TP = getDerived().parseTemplateParam();
    if (TP == nullptr)
      return nullptr;
    Subs.push_back(TP);
    return TP;
  }
  if (look() == 'D') {
    Node *DT = getDerived().parseDecltype();
    if (DT == nullptr)
      return nullptr;
    Subs.push_back(DT);
    return DT;
  }
  return getDerived().parseSubstitution();
}

// <base-unresolved-name> ::= <simple-id>                                # unresolved name
//          extension     ::= <operator-name>                            # unresolved operator-function-id
//          extension     ::= <operator-name> <template-args>            # unresolved operator template-id
//                        ::= on <operator-name>                         # unresolved operator-function-id
//                        ::= on <operator-name> <template-args>         # unresolved operator template-id
//                        ::= dn <destructor-name>                       # destructor or pseudo-destructor;
//                                                                         # e.g. ~X or ~X<N-1>
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseBaseUnresolvedName() {
  if (std::isdigit(look()))
    return getDerived().parseSimpleId();

  if (consumeIf("dn"))
    return getDerived().parseDestructorName();

  consumeIf("on");

  Node *Oper = getDerived().parseOperatorName(/*NameState=*/nullptr);
  if (Oper == nullptr)
    return nullptr;
  if (look() == 'I') {
    Node *TA = getDerived().parseTemplateArgs();
    if (TA == nullptr)
      return nullptr;
    return make<NameWithTemplateArgs>(Oper, TA);
  }
  return Oper;
}

// <unresolved-name>
//  extension        ::= srN <unresolved-type> [<template-args>] <unresolved-qualifier-level>* E <base-unresolved-name>
//                   ::= [gs] <base-unresolved-name>                     # x or (with "gs") ::x
//                   ::= [gs] sr <unresolved-qualifier-level>+ E <base-unresolved-name>
//                                                                       # A::x, N::y, A<T>::z; "gs" means leading "::"
// [gs] has been parsed by caller.
//                   ::= sr <unresolved-type> <base-unresolved-name>     # T::x / decltype(p)::x
//  extension        ::= sr <unresolved-type> <template-args> <base-unresolved-name>
//                                                                       # T::N::x /decltype(p)::N::x
//  (ignored)        ::= srN <unresolved-type>  <unresolved-qualifier-level>+ E <base-unresolved-name>
//
// <unresolved-qualifier-level> ::= <simple-id>
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseUnresolvedName(bool Global) {
  Node *SoFar = nullptr;

  // srN <unresolved-type> [<template-args>] <unresolved-qualifier-level>* E <base-unresolved-name>
  // srN <unresolved-type>                   <unresolved-qualifier-level>+ E <base-unresolved-name>
  if (consumeIf("srN")) {
    SoFar = getDerived().parseUnresolvedType();
    if (SoFar == nullptr)
      return nullptr;

    if (look() == 'I') {
      Node *TA = getDerived().parseTemplateArgs();
      if (TA == nullptr)
        return nullptr;
      SoFar = make<NameWithTemplateArgs>(SoFar, TA);
      if (!SoFar)
        return nullptr;
    }

    while (!consumeIf('E')) {
      Node *Qual = getDerived().parseSimpleId();
      if (Qual == nullptr)
        return nullptr;
      SoFar = make<QualifiedName>(SoFar, Qual);
      if (!SoFar)
        return nullptr;
    }

    Node *Base = getDerived().parseBaseUnresolvedName();
    if (Base == nullptr)
      return nullptr;
    return make<QualifiedName>(SoFar, Base);
  }

  // [gs] <base-unresolved-name>                     # x or (with "gs") ::x
  if (!consumeIf("sr")) {
    SoFar = getDerived().parseBaseUnresolvedName();
    if (SoFar == nullptr)
      return nullptr;
    if (Global)
      SoFar = make<GlobalQualifiedName>(SoFar);
    return SoFar;
  }

  // [gs] sr <unresolved-qualifier-level>+ E   <base-unresolved-name>
  if (std::isdigit(look())) {
    do {
      Node *Qual = getDerived().parseSimpleId();
      if (Qual == nullptr)
        return nullptr;
      if (SoFar)
        SoFar = make<QualifiedName>(SoFar, Qual);
      else if (Global)
        SoFar = make<GlobalQualifiedName>(Qual);
      else
        SoFar = Qual;
      if (!SoFar)
        return nullptr;
    } while (!consumeIf('E'));
  }
  //      sr <unresolved-type>                 <base-unresolved-name>
  //      sr <unresolved-type> <template-args> <base-unresolved-name>
  else {
    SoFar = getDerived().parseUnresolvedType();
    if (SoFar == nullptr)
      return nullptr;

    if (look() == 'I') {
      Node *TA = getDerived().parseTemplateArgs();
      if (TA == nullptr)
        return nullptr;
      SoFar = make<NameWithTemplateArgs>(SoFar, TA);
      if (!SoFar)
        return nullptr;
    }
  }

  DEMANGLE_ASSERT(SoFar != nullptr, "");

  Node *Base = getDerived().parseBaseUnresolvedName();
  if (Base == nullptr)
    return nullptr;
  return make<QualifiedName>(SoFar, Base);
}

// <abi-tags> ::= <abi-tag> [<abi-tags>]
// <abi-tag> ::= B <source-name>
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseAbiTags(Node *N) {
  while (consumeIf('B')) {
    std::string_view SN = parseBareSourceName();
    if (SN.empty())
      return nullptr;
    N = make<AbiTagAttr>(N, SN);
    if (!N)
      return nullptr;
  }
  return N;
}

// <number> ::= [n] <non-negative decimal integer>
template <typename Alloc, typename Derived>
std::string_view
AbstractManglingParser<Alloc, Derived>::parseNumber(bool AllowNegative) {
  const char *Tmp = First;
  if (AllowNegative)
    consumeIf('n');
  if (numLeft() == 0 || !std::isdigit(*First))
    return std::string_view();
  while (numLeft() != 0 && std::isdigit(*First))
    ++First;
  return std::string_view(Tmp, First - Tmp);
}

// <positive length number> ::= [0-9]*
template <typename Alloc, typename Derived>
bool AbstractManglingParser<Alloc, Derived>::parsePositiveInteger(size_t *Out) {
  *Out = 0;
  if (look() < '0' || look() > '9')
    return true;
  while (look() >= '0' && look() <= '9') {
    *Out *= 10;
    *Out += static_cast<size_t>(consume() - '0');
  }
  return false;
}

template <typename Alloc, typename Derived>
std::string_view AbstractManglingParser<Alloc, Derived>::parseBareSourceName() {
  size_t Int = 0;
  if (parsePositiveInteger(&Int) || numLeft() < Int)
    return {};
  std::string_view R(First, Int);
  First += Int;
  return R;
}

// <function-type> ::= [<CV-qualifiers>] [<exception-spec>] [Dx] F [Y] <bare-function-type> [<ref-qualifier>] E
//
// <exception-spec> ::= Do                # non-throwing exception-specification (e.g., noexcept, throw())
//                  ::= DO <expression> E # computed (instantiation-dependent) noexcept
//                  ::= Dw <type>+ E      # dynamic exception specification with instantiation-dependent types
//
// <ref-qualifier> ::= R                   # & ref-qualifier
// <ref-qualifier> ::= O                   # && ref-qualifier
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseFunctionType() {
  Qualifiers CVQuals = parseCVQualifiers();

  Node *ExceptionSpec = nullptr;
  if (consumeIf("Do")) {
    ExceptionSpec = make<NameType>("noexcept");
    if (!ExceptionSpec)
      return nullptr;
  } else if (consumeIf("DO")) {
    Node *E = getDerived().parseExpr();
    if (E == nullptr || !consumeIf('E'))
      return nullptr;
    ExceptionSpec = make<NoexceptSpec>(E);
    if (!ExceptionSpec)
      return nullptr;
  } else if (consumeIf("Dw")) {
    size_t SpecsBegin = Names.size();
    while (!consumeIf('E')) {
      Node *T = getDerived().parseType();
      if (T == nullptr)
        return nullptr;
      Names.push_back(T);
    }
    ExceptionSpec =
      make<DynamicExceptionSpec>(popTrailingNodeArray(SpecsBegin));
    if (!ExceptionSpec)
      return nullptr;
  }

  consumeIf("Dx"); // transaction safe

  if (!consumeIf('F'))
    return nullptr;
  consumeIf('Y'); // extern "C"
  Node *ReturnType = getDerived().parseType();
  if (ReturnType == nullptr)
    return nullptr;

  FunctionRefQual ReferenceQualifier = FrefQualNone;
  size_t ParamsBegin = Names.size();
  while (true) {
    if (consumeIf('E'))
      break;
    if (consumeIf('v'))
      continue;
    if (consumeIf("RE")) {
      ReferenceQualifier = FrefQualLValue;
      break;
    }
    if (consumeIf("OE")) {
      ReferenceQualifier = FrefQualRValue;
      break;
    }
    Node *T = getDerived().parseType();
    if (T == nullptr)
      return nullptr;
    Names.push_back(T);
  }

  NodeArray Params = popTrailingNodeArray(ParamsBegin);
  return make<FunctionType>(ReturnType, Params, CVQuals,
                            ReferenceQualifier, ExceptionSpec);
}

// extension:
// <vector-type>           ::= Dv <positive dimension number> _ <extended element type>
//                         ::= Dv [<dimension expression>] _ <element type>
// <extended element type> ::= <element type>
//                         ::= p # AltiVec vector pixel
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseVectorType() {
  if (!consumeIf("Dv"))
    return nullptr;
  if (look() >= '1' && look() <= '9') {
    Node *DimensionNumber = make<NameType>(parseNumber());
    if (!DimensionNumber)
      return nullptr;
    if (!consumeIf('_'))
      return nullptr;
    if (consumeIf('p'))
      return make<PixelVectorType>(DimensionNumber);
    Node *ElemType = getDerived().parseType();
    if (ElemType == nullptr)
      return nullptr;
    return make<VectorType>(ElemType, DimensionNumber);
  }

  if (!consumeIf('_')) {
    Node *DimExpr = getDerived().parseExpr();
    if (!DimExpr)
      return nullptr;
    if (!consumeIf('_'))
      return nullptr;
    Node *ElemType = getDerived().parseType();
    if (!ElemType)
      return nullptr;
    return make<VectorType>(ElemType, DimExpr);
  }
  Node *ElemType = getDerived().parseType();
  if (!ElemType)
    return nullptr;
  return make<VectorType>(ElemType, /*Dimension=*/nullptr);
}

// <decltype>  ::= Dt <expression> E  # decltype of an id-expression or class member access (C++0x)
//             ::= DT <expression> E  # decltype of an expression (C++0x)
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseDecltype() {
  if (!consumeIf('D'))
    return nullptr;
  if (!consumeIf('t') && !consumeIf('T'))
    return nullptr;
  Node *E = getDerived().parseExpr();
  if (E == nullptr)
    return nullptr;
  if (!consumeIf('E'))
    return nullptr;
  return make<EnclosingExpr>("decltype", E);
}

// <array-type> ::= A <positive dimension number> _ <element type>
//              ::= A [<dimension expression>] _ <element type>
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseArrayType() {
  if (!consumeIf('A'))
    return nullptr;

  Node *Dimension = nullptr;

  if (std::isdigit(look())) {
    Dimension = make<NameType>(parseNumber());
    if (!Dimension)
      return nullptr;
    if (!consumeIf('_'))
      return nullptr;
  } else if (!consumeIf('_')) {
    Node *DimExpr = getDerived().parseExpr();
    if (DimExpr == nullptr)
      return nullptr;
    if (!consumeIf('_'))
      return nullptr;
    Dimension = DimExpr;
  }

  Node *Ty = getDerived().parseType();
  if (Ty == nullptr)
    return nullptr;
  return make<ArrayType>(Ty, Dimension);
}

// <pointer-to-member-type> ::= M <class type> <member type>
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parsePointerToMemberType() {
  if (!consumeIf('M'))
    return nullptr;
  Node *ClassType = getDerived().parseType();
  if (ClassType == nullptr)
    return nullptr;
  Node *MemberType = getDerived().parseType();
  if (MemberType == nullptr)
    return nullptr;
  return make<PointerToMemberType>(ClassType, MemberType);
}

// <class-enum-type> ::= <name>     # non-dependent type name, dependent type name, or dependent typename-specifier
//                   ::= Ts <name>  # dependent elaborated type specifier using 'struct' or 'class'
//                   ::= Tu <name>  # dependent elaborated type specifier using 'union'
//                   ::= Te <name>  # dependent elaborated type specifier using 'enum'
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseClassEnumType() {
  std::string_view ElabSpef;
  if (consumeIf("Ts"))
    ElabSpef = "struct";
  else if (consumeIf("Tu"))
    ElabSpef = "union";
  else if (consumeIf("Te"))
    ElabSpef = "enum";

  Node *Name = getDerived().parseName();
  if (Name == nullptr)
    return nullptr;

  if (!ElabSpef.empty())
    return make<ElaboratedTypeSpefType>(ElabSpef, Name);

  return Name;
}

// <qualified-type>     ::= <qualifiers> <type>
// <qualifiers> ::= <extended-qualifier>* <CV-qualifiers>
// <extended-qualifier> ::= U <source-name> [<template-args>] # vendor extended type qualifier
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseQualifiedType() {
  if (consumeIf('U')) {
    std::string_view Qual = parseBareSourceName();
    if (Qual.empty())
      return nullptr;

    // extension            ::= U <objc-name> <objc-type>  # objc-type<identifier>
    if (starts_with(Qual, "objcproto")) {
      constexpr size_t Len = sizeof("objcproto") - 1;
      std::string_view ProtoSourceName(Qual.data() + Len, Qual.size() - Len);
      std::string_view Proto;
      {
        ScopedOverride<const char *> SaveFirst(First, ProtoSourceName.data()),
            SaveLast(Last, &*ProtoSourceName.rbegin() + 1);
        Proto = parseBareSourceName();
      }
      if (Proto.empty())
        return nullptr;
      Node *Child = getDerived().parseQualifiedType();
      if (Child == nullptr)
        return nullptr;
      return make<ObjCProtoName>(Child, Proto);
    }

    Node *TA = nullptr;
    if (look() == 'I') {
      TA = getDerived().parseTemplateArgs();
      if (TA == nullptr)
        return nullptr;
    }

    Node *Child = getDerived().parseQualifiedType();
    if (Child == nullptr)
      return nullptr;
    return make<VendorExtQualType>(Child, Qual, TA);
  }

  Qualifiers Quals = parseCVQualifiers();
  Node *Ty = getDerived().parseType();
  if (Ty == nullptr)
    return nullptr;
  if (Quals != QualNone)
    Ty = make<QualType>(Ty, Quals);
  return Ty;
}

// <type>      ::= <builtin-type>
//             ::= <qualified-type>
//             ::= <function-type>
//             ::= <class-enum-type>
//             ::= <array-type>
//             ::= <pointer-to-member-type>
//             ::= <template-param>
//             ::= <template-template-param> <template-args>
//             ::= <decltype>
//             ::= P <type>        # pointer
//             ::= R <type>        # l-value reference
//             ::= O <type>        # r-value reference (C++11)
//             ::= C <type>        # complex pair (C99)
//             ::= G <type>        # imaginary (C99)
//             ::= <substitution>  # See Compression below
// extension   ::= U <objc-name> <objc-type>  # objc-type<identifier>
// extension   ::= <vector-type> # <vector-type> starts with Dv
//
// <objc-name> ::= <k0 number> objcproto <k1 number> <identifier>  # k0 = 9 + <number of digits in k1> + k1
// <objc-type> ::= <source-name>  # PU<11+>objcproto 11objc_object<source-name> 11objc_object -> id<source-name>
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseType() {
  Node *Result = nullptr;

  switch (look()) {
  //             ::= <qualified-type>
  case 'r':
  case 'V':
  case 'K': {
    unsigned AfterQuals = 0;
    if (look(AfterQuals) == 'r') ++AfterQuals;
    if (look(AfterQuals) == 'V') ++AfterQuals;
    if (look(AfterQuals) == 'K') ++AfterQuals;

    if (look(AfterQuals) == 'F' ||
        (look(AfterQuals) == 'D' &&
         (look(AfterQuals + 1) == 'o' || look(AfterQuals + 1) == 'O' ||
          look(AfterQuals + 1) == 'w' || look(AfterQuals + 1) == 'x'))) {
      Result = getDerived().parseFunctionType();
      break;
    }
    DEMANGLE_FALLTHROUGH;
  }
  case 'U': {
    Result = getDerived().parseQualifiedType();
    break;
  }
  // <builtin-type> ::= v    # void
  case 'v':
    ++First;
    return make<NameType>("void");
  //                ::= w    # wchar_t
  case 'w':
    ++First;
    return make<NameType>("wchar_t");
  //                ::= b    # bool
  case 'b':
    ++First;
    return make<NameType>("bool");
  //                ::= c    # char
  case 'c':
    ++First;
    return make<NameType>("char");
  //                ::= a    # signed char
  case 'a':
    ++First;
    return make<NameType>("signed char");
  //                ::= h    # unsigned char
  case 'h':
    ++First;
    return make<NameType>("unsigned char");
  //                ::= s    # short
  case 's':
    ++First;
    return make<NameType>("short");
  //                ::= t    # unsigned short
  case 't':
    ++First;
    return make<NameType>("unsigned short");
  //                ::= i    # int
  case 'i':
    ++First;
    return make<NameType>("int");
  //                ::= j    # unsigned int
  case 'j':
    ++First;
    return make<NameType>("unsigned int");
  //                ::= l    # long
  case 'l':
    ++First;
    return make<NameType>("long");
  //                ::= m    # unsigned long
  case 'm':
    ++First;
    return make<NameType>("unsigned long");
  //                ::= x    # long long, __int64
  case 'x':
    ++First;
    return make<NameType>("long long");
  //                ::= y    # unsigned long long, __int64
  case 'y':
    ++First;
    return make<NameType>("unsigned long long");
  //                ::= n    # __int128
  case 'n':
    ++First;
    return make<NameType>("__int128");
  //                ::= o    # unsigned __int128
  case 'o':
    ++First;
    return make<NameType>("unsigned __int128");
  //                ::= f    # float
  case 'f':
    ++First;
    return make<NameType>("float");
  //                ::= d    # double
  case 'd':
    ++First;
    return make<NameType>("double");
  //                ::= e    # long double, __float80
  case 'e':
    ++First;
    return make<NameType>("long double");
  //                ::= g    # __float128
  case 'g':
    ++First;
    return make<NameType>("__float128");
  //                ::= z    # ellipsis
  case 'z':
    ++First;
    return make<NameType>("...");

  // <builtin-type> ::= u <source-name>    # vendor extended type
  case 'u': {
    ++First;
    std::string_view Res = parseBareSourceName();
    if (Res.empty())
      return nullptr;
    // Typically, <builtin-type>s are not considered substitution candidates,
    // but the exception to that exception is vendor extended types (Itanium C++
    // ABI 5.9.1).
    if (consumeIf('I')) {
      Node *BaseType = parseType();
      if (BaseType == nullptr)
        return nullptr;
      if (!consumeIf('E'))
        return nullptr;
      Result = make<TransformedType>(Res, BaseType);
    } else
      Result = make<NameType>(Res);
    break;
  }
  case 'D':
    switch (look(1)) {
    //                ::= Dd   # IEEE 754r decimal floating point (64 bits)
    case 'd':
      First += 2;
      return make<NameType>("decimal64");
    //                ::= De   # IEEE 754r decimal floating point (128 bits)
    case 'e':
      First += 2;
      return make<NameType>("decimal128");
    //                ::= Df   # IEEE 754r decimal floating point (32 bits)
    case 'f':
      First += 2;
      return make<NameType>("decimal32");
    //                ::= Dh   # IEEE 754r half-precision floating point (16 bits)
    case 'h':
      First += 2;
      return make<NameType>("half");
    //       ::= DF16b         # C++23 std::bfloat16_t
    //       ::= DF <number> _ # ISO/IEC TS 18661 binary floating point (N bits)
    case 'F': {
      First += 2;
      if (consumeIf("16b"))
        return make<NameType>("std::bfloat16_t");
      Node *DimensionNumber = make<NameType>(parseNumber());
      if (!DimensionNumber)
        return nullptr;
      if (!consumeIf('_'))
        return nullptr;
      return make<BinaryFPType>(DimensionNumber);
    }
    //                ::= [DS] DA  # N1169 fixed-point [_Sat] T _Accum
    //                ::= [DS] DR  # N1169 fixed-point [_Sat] T _Frac
    // <fixed-point-size>
    //                ::= s # short
    //                ::= t # unsigned short
    //                ::= i # plain
    //                ::= j # unsigned
    //                ::= l # long
    //                ::= m # unsigned long
    case 'A': {
      char c = look(2);
      First += 3;
      switch (c) {
      case 's':
        return make<NameType>("short _Accum");
      case 't':
        return make<NameType>("unsigned short _Accum");
      case 'i':
        return make<NameType>("_Accum");
      case 'j':
        return make<NameType>("unsigned _Accum");
      case 'l':
        return make<NameType>("long _Accum");
      case 'm':
        return make<NameType>("unsigned long _Accum");
      default:
        return nullptr;
      }
    }
    case 'R': {
      char c = look(2);
      First += 3;
      switch (c) {
      case 's':
        return make<NameType>("short _Fract");
      case 't':
        return make<NameType>("unsigned short _Fract");
      case 'i':
        return make<NameType>("_Fract");
      case 'j':
        return make<NameType>("unsigned _Fract");
      case 'l':
        return make<NameType>("long _Fract");
      case 'm':
        return make<NameType>("unsigned long _Fract");
      default:
        return nullptr;
      }
    }
    case 'S': {
      First += 2;
      if (look() != 'D')
        return nullptr;
      if (look(1) == 'A') {
        char c = look(2);
        First += 3;
        switch (c) {
        case 's':
          return make<NameType>("_Sat short _Accum");
        case 't':
          return make<NameType>("_Sat unsigned short _Accum");
        case 'i':
          return make<NameType>("_Sat _Accum");
        case 'j':
          return make<NameType>("_Sat unsigned _Accum");
        case 'l':
          return make<NameType>("_Sat long _Accum");
        case 'm':
          return make<NameType>("_Sat unsigned long _Accum");
        default:
          return nullptr;
        }
      }
      if (look(1) == 'R') {
        char c = look(2);
        First += 3;
        switch (c) {
        case 's':
          return make<NameType>("_Sat short _Fract");
        case 't':
          return make<NameType>("_Sat unsigned short _Fract");
        case 'i':
          return make<NameType>("_Sat _Fract");
        case 'j':
          return make<NameType>("_Sat unsigned _Fract");
        case 'l':
          return make<NameType>("_Sat long _Fract");
        case 'm':
          return make<NameType>("_Sat unsigned long _Fract");
        default:
          return nullptr;
        }
      }
      return nullptr;
    }
    //                ::= DB <number> _                             # C23 signed _BitInt(N)
    //                ::= DB <instantiation-dependent expression> _ # C23 signed _BitInt(N)
    //                ::= DU <number> _                             # C23 unsigned _BitInt(N)
    //                ::= DU <instantiation-dependent expression> _ # C23 unsigned _BitInt(N)
    case 'B':
    case 'U': {
      bool Signed = look(1) == 'B';
      First += 2;
      Node *Size = std::isdigit(look()) ? make<NameType>(parseNumber())
                                        : getDerived().parseExpr();
      if (!Size)
        return nullptr;
      if (!consumeIf('_'))
        return nullptr;
      // The front end expects this to be available for Substitution
      Result = make<BitIntType>(Size, Signed);
      break;
    }
    //                ::= Di   # char32_t
    case 'i':
      First += 2;
      return make<NameType>("char32_t");
    //                ::= Ds   # char16_t
    case 's':
      First += 2;
      return make<NameType>("char16_t");
    //                ::= Du   # char8_t (C++2a, not yet in the Itanium spec)
    case 'u':
      First += 2;
      return make<NameType>("char8_t");
    //                ::= Da   # auto (in dependent new-expressions)
    case 'a':
      First += 2;
      return make<NameType>("auto");
    //                ::= Dc   # decltype(auto)
    case 'c':
      First += 2;
      return make<NameType>("decltype(auto)");
    //                ::= Dk <type-constraint> # constrained auto
    //                ::= DK <type-constraint> # constrained decltype(auto)
    case 'k':
    case 'K': {
      std::string_view Kind = look(1) == 'k' ? " auto" : " decltype(auto)";
      First += 2;
      Node *Constraint = getDerived().parseName();
      if (!Constraint)
        return nullptr;
      return make<PostfixQualifiedType>(Constraint, Kind);
    }
    //                ::= Dn   # std::nullptr_t (i.e., decltype(nullptr))
    case 'n':
      First += 2;
      return make<NameType>("std::nullptr_t");

    //             ::= <decltype>
    case 't':
    case 'T': {
      Result = getDerived().parseDecltype();
      break;
    }
    // extension   ::= <vector-type> # <vector-type> starts with Dv
    case 'v': {
      Result = getDerived().parseVectorType();
      break;
    }
    //           ::= Dp <type>       # pack expansion (C++0x)
    case 'p': {
      First += 2;
      Node *Child = getDerived().parseType();
      if (!Child)
        return nullptr;
      Result = make<ParameterPackExpansion>(Child);
      break;
    }
    // Exception specifier on a function type.
    case 'o':
    case 'O':
    case 'w':
    // Transaction safe function type.
    case 'x':
      Result = getDerived().parseFunctionType();
      break;
    }
    break;
  //             ::= <function-type>
  case 'F': {
    Result = getDerived().parseFunctionType();
    break;
  }
  //             ::= <array-type>
  case 'A': {
    Result = getDerived().parseArrayType();
    break;
  }
  //             ::= <pointer-to-member-type>
  case 'M': {
    Result = getDerived().parsePointerToMemberType();
    break;
  }
  //             ::= <template-param>
  case 'T': {
    // This could be an elaborate type specifier on a <class-enum-type>.
    if (look(1) == 's' || look(1) == 'u' || look(1) == 'e') {
      Result = getDerived().parseClassEnumType();
      break;
    }

    Result = getDerived().parseTemplateParam();
    if (Result == nullptr)
      return nullptr;

    // Result could be either of:
    //   <type>        ::= <template-param>
    //   <type>        ::= <template-template-param> <template-args>
    //
    //   <template-template-param> ::= <template-param>
    //                             ::= <substitution>
    //
    // If this is followed by some <template-args>, and we're permitted to
    // parse them, take the second production.

    if (TryToParseTemplateArgs && look() == 'I') {
      Subs.push_back(Result);
      Node *TA = getDerived().parseTemplateArgs();
      if (TA == nullptr)
        return nullptr;
      Result = make<NameWithTemplateArgs>(Result, TA);
    }
    break;
  }
  //             ::= P <type>        # pointer
  case 'P': {
    ++First;
    Node *Ptr = getDerived().parseType();
    if (Ptr == nullptr)
      return nullptr;
    Result = make<PointerType>(Ptr);
    break;
  }
  //             ::= R <type>        # l-value reference
  case 'R': {
    ++First;
    Node *Ref = getDerived().parseType();
    if (Ref == nullptr)
      return nullptr;
    Result = make<ReferenceType>(Ref, ReferenceKind::LValue);
    break;
  }
  //             ::= O <type>        # r-value reference (C++11)
  case 'O': {
    ++First;
    Node *Ref = getDerived().parseType();
    if (Ref == nullptr)
      return nullptr;
    Result = make<ReferenceType>(Ref, ReferenceKind::RValue);
    break;
  }
  //             ::= C <type>        # complex pair (C99)
  case 'C': {
    ++First;
    Node *P = getDerived().parseType();
    if (P == nullptr)
      return nullptr;
    Result = make<PostfixQualifiedType>(P, " complex");
    break;
  }
  //             ::= G <type>        # imaginary (C99)
  case 'G': {
    ++First;
    Node *P = getDerived().parseType();
    if (P == nullptr)
      return P;
    Result = make<PostfixQualifiedType>(P, " imaginary");
    break;
  }
  //             ::= <substitution>  # See Compression below
  case 'S': {
    if (look(1) != 't') {
      bool IsSubst = false;
      Result = getDerived().parseUnscopedName(nullptr, &IsSubst);
      if (!Result)
        return nullptr;

      // Sub could be either of:
      //   <type>        ::= <substitution>
      //   <type>        ::= <template-template-param> <template-args>
      //
      //   <template-template-param> ::= <template-param>
      //                             ::= <substitution>
      //
      // If this is followed by some <template-args>, and we're permitted to
      // parse them, take the second production.

      if (look() == 'I' && (!IsSubst || TryToParseTemplateArgs)) {
        if (!IsSubst)
          Subs.push_back(Result);
        Node *TA = getDerived().parseTemplateArgs();
        if (TA == nullptr)
          return nullptr;
        Result = make<NameWithTemplateArgs>(Result, TA);
      } else if (IsSubst) {
        // If all we parsed was a substitution, don't re-insert into the
        // substitution table.
        return Result;
      }
      break;
    }
    DEMANGLE_FALLTHROUGH;
  }
  //        ::= <class-enum-type>
  default: {
    Result = getDerived().parseClassEnumType();
    break;
  }
  }

  // If we parsed a type, insert it into the substitution table. Note that all
  // <builtin-type>s and <substitution>s have already bailed out, because they
  // don't get substitutions.
  if (Result != nullptr)
    Subs.push_back(Result);
  return Result;
}

template <typename Derived, typename Alloc>
Node *
AbstractManglingParser<Derived, Alloc>::parsePrefixExpr(std::string_view Kind,
                                                        Node::Prec Prec) {
  Node *E = getDerived().parseExpr();
  if (E == nullptr)
    return nullptr;
  return make<PrefixExpr>(Kind, E, Prec);
}

template <typename Derived, typename Alloc>
Node *
AbstractManglingParser<Derived, Alloc>::parseBinaryExpr(std::string_view Kind,
                                                        Node::Prec Prec) {
  Node *LHS = getDerived().parseExpr();
  if (LHS == nullptr)
    return nullptr;
  Node *RHS = getDerived().parseExpr();
  if (RHS == nullptr)
    return nullptr;
  return make<BinaryExpr>(LHS, Kind, RHS, Prec);
}

template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseIntegerLiteral(
    std::string_view Lit) {
  std::string_view Tmp = parseNumber(true);
  if (!Tmp.empty() && consumeIf('E'))
    return make<IntegerLiteral>(Lit, Tmp);
  return nullptr;
}

// <CV-Qualifiers> ::= [r] [V] [K]
template <typename Alloc, typename Derived>
Qualifiers AbstractManglingParser<Alloc, Derived>::parseCVQualifiers() {
  Qualifiers CVR = QualNone;
  if (consumeIf('r'))
    CVR |= QualRestrict;
  if (consumeIf('V'))
    CVR |= QualVolatile;
  if (consumeIf('K'))
    CVR |= QualConst;
  return CVR;
}

// <function-param> ::= fp <top-level CV-Qualifiers> _                                     # L == 0, first parameter
//                  ::= fp <top-level CV-Qualifiers> <parameter-2 non-negative number> _   # L == 0, second and later parameters
//                  ::= fL <L-1 non-negative number> p <top-level CV-Qualifiers> _         # L > 0, first parameter
//                  ::= fL <L-1 non-negative number> p <top-level CV-Qualifiers> <parameter-2 non-negative number> _   # L > 0, second and later parameters
//                  ::= fpT      # 'this' expression (not part of standard?)
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseFunctionParam() {
  if (consumeIf("fpT"))
    return make<NameType>("this");
  if (consumeIf("fp")) {
    parseCVQualifiers();
    std::string_view Num = parseNumber();
    if (!consumeIf('_'))
      return nullptr;
    return make<FunctionParam>(Num);
  }
  if (consumeIf("fL")) {
    if (parseNumber().empty())
      return nullptr;
    if (!consumeIf('p'))
      return nullptr;
    parseCVQualifiers();
    std::string_view Num = parseNumber();
    if (!consumeIf('_'))
      return nullptr;
    return make<FunctionParam>(Num);
  }
  return nullptr;
}

// cv <type> <expression>                               # conversion with one argument
// cv <type> _ <expression>* E                          # conversion with a different number of arguments
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseConversionExpr() {
  if (!consumeIf("cv"))
    return nullptr;
  Node *Ty;
  {
    ScopedOverride<bool> SaveTemp(TryToParseTemplateArgs, false);
    Ty = getDerived().parseType();
  }

  if (Ty == nullptr)
    return nullptr;

  if (consumeIf('_')) {
    size_t ExprsBegin = Names.size();
    while (!consumeIf('E')) {
      Node *E = getDerived().parseExpr();
      if (E == nullptr)
        return E;
      Names.push_back(E);
    }
    NodeArray Exprs = popTrailingNodeArray(ExprsBegin);
    return make<ConversionExpr>(Ty, Exprs);
  }

  Node *E[1] = {getDerived().parseExpr()};
  if (E[0] == nullptr)
    return nullptr;
  return make<ConversionExpr>(Ty, makeNodeArray(E, E + 1));
}

// <expr-primary> ::= L <type> <value number> E                          # integer literal
//                ::= L <type> <value float> E                           # floating literal
//                ::= L <string type> E                                  # string literal
//                ::= L <nullptr type> E                                 # nullptr literal (i.e., "LDnE")
//                ::= L <lambda type> E                                  # lambda expression
// FIXME:         ::= L <type> <real-part float> _ <imag-part float> E   # complex floating point literal (C 2000)
//                ::= L <mangled-name> E                                 # external name
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseExprPrimary() {
  if (!consumeIf('L'))
    return nullptr;
  switch (look()) {
  case 'w':
    ++First;
    return getDerived().parseIntegerLiteral("wchar_t");
  case 'b':
    if (consumeIf("b0E"))
      return make<BoolExpr>(0);
    if (consumeIf("b1E"))
      return make<BoolExpr>(1);
    return nullptr;
  case 'c':
    ++First;
    return getDerived().parseIntegerLiteral("char");
  case 'a':
    ++First;
    return getDerived().parseIntegerLiteral("signed char");
  case 'h':
    ++First;
    return getDerived().parseIntegerLiteral("unsigned char");
  case 's':
    ++First;
    return getDerived().parseIntegerLiteral("short");
  case 't':
    ++First;
    return getDerived().parseIntegerLiteral("unsigned short");
  case 'i':
    ++First;
    return getDerived().parseIntegerLiteral("");
  case 'j':
    ++First;
    return getDerived().parseIntegerLiteral("u");
  case 'l':
    ++First;
    return getDerived().parseIntegerLiteral("l");
  case 'm':
    ++First;
    return getDerived().parseIntegerLiteral("ul");
  case 'x':
    ++First;
    return getDerived().parseIntegerLiteral("ll");
  case 'y':
    ++First;
    return getDerived().parseIntegerLiteral("ull");
  case 'n':
    ++First;
    return getDerived().parseIntegerLiteral("__int128");
  case 'o':
    ++First;
    return getDerived().parseIntegerLiteral("unsigned __int128");
  case 'f':
    ++First;
    return getDerived().template parseFloatingLiteral<float>();
  case 'd':
    ++First;
    return getDerived().template parseFloatingLiteral<double>();
  case 'e':
    ++First;
#if defined(__powerpc__) || defined(__s390__)
    // Handle cases where long doubles encoded with e have the same size
    // and representation as doubles.
    return getDerived().template parseFloatingLiteral<double>();
#else
    return getDerived().template parseFloatingLiteral<long double>();
#endif
  case '_':
    if (consumeIf("_Z")) {
      Node *R = getDerived().parseEncoding();
      if (R != nullptr && consumeIf('E'))
        return R;
    }
    return nullptr;
  case 'A': {
    Node *T = getDerived().parseType();
    if (T == nullptr)
      return nullptr;
    // FIXME: We need to include the string contents in the mangling.
    if (consumeIf('E'))
      return make<StringLiteral>(T);
    return nullptr;
  }
  case 'D':
    if (consumeIf("Dn") && (consumeIf('0'), consumeIf('E')))
      return make<NameType>("nullptr");
    return nullptr;
  case 'T':
    // Invalid mangled name per
    //   http://sourcerytools.com/pipermail/cxx-abi-dev/2011-August/002422.html
    return nullptr;
  case 'U': {
    // FIXME: Should we support LUb... for block literals?
    if (look(1) != 'l')
      return nullptr;
    Node *T = parseUnnamedTypeName(nullptr);
    if (!T || !consumeIf('E'))
      return nullptr;
    return make<LambdaExpr>(T);
  }
  default: {
    // might be named type
    Node *T = getDerived().parseType();
    if (T == nullptr)
      return nullptr;
    std::string_view N = parseNumber(/*AllowNegative=*/true);
    if (N.empty())
      return nullptr;
    if (!consumeIf('E'))
      return nullptr;
    return make<EnumLiteral>(T, N);
  }
  }
}

// <braced-expression> ::= <expression>
//                     ::= di <field source-name> <braced-expression>    # .name = expr
//                     ::= dx <index expression> <braced-expression>     # [expr] = expr
//                     ::= dX <range begin expression> <range end expression> <braced-expression>
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseBracedExpr() {
  if (look() == 'd') {
    switch (look(1)) {
    case 'i': {
      First += 2;
      Node *Field = getDerived().parseSourceName(/*NameState=*/nullptr);
      if (Field == nullptr)
        return nullptr;
      Node *Init = getDerived().parseBracedExpr();
      if (Init == nullptr)
        return nullptr;
      return make<BracedExpr>(Field, Init, /*isArray=*/false);
    }
    case 'x': {
      First += 2;
      Node *Index = getDerived().parseExpr();
      if (Index == nullptr)
        return nullptr;
      Node *Init = getDerived().parseBracedExpr();
      if (Init == nullptr)
        return nullptr;
      return make<BracedExpr>(Index, Init, /*isArray=*/true);
    }
    case 'X': {
      First += 2;
      Node *RangeBegin = getDerived().parseExpr();
      if (RangeBegin == nullptr)
        return nullptr;
      Node *RangeEnd = getDerived().parseExpr();
      if (RangeEnd == nullptr)
        return nullptr;
      Node *Init = getDerived().parseBracedExpr();
      if (Init == nullptr)
        return nullptr;
      return make<BracedRangeExpr>(RangeBegin, RangeEnd, Init);
    }
    }
  }
  return getDerived().parseExpr();
}

// (not yet in the spec)
// <fold-expr> ::= fL <binary-operator-name> <expression> <expression>
//             ::= fR <binary-operator-name> <expression> <expression>
//             ::= fl <binary-operator-name> <expression>
//             ::= fr <binary-operator-name> <expression>
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseFoldExpr() {
  if (!consumeIf('f'))
    return nullptr;

  bool IsLeftFold = false, HasInitializer = false;
  switch (look()) {
  default:
    return nullptr;
  case 'L':
    IsLeftFold = true;
    HasInitializer = true;
    break;
  case 'R':
    HasInitializer = true;
    break;
  case 'l':
    IsLeftFold = true;
    break;
  case 'r':
    break;
  }
  ++First;

  const auto *Op = parseOperatorEncoding();
  if (!Op)
    return nullptr;
  if (!(Op->getKind() == OperatorInfo::Binary
        || (Op->getKind() == OperatorInfo::Member
            && Op->getName().back() == '*')))
    return nullptr;

  Node *Pack = getDerived().parseExpr();
  if (Pack == nullptr)
    return nullptr;

  Node *Init = nullptr;
  if (HasInitializer) {
    Init = getDerived().parseExpr();
    if (Init == nullptr)
      return nullptr;
  }

  if (IsLeftFold && Init)
    std::swap(Pack, Init);

  return make<FoldExpr>(IsLeftFold, Op->getSymbol(), Pack, Init);
}

// <expression> ::= mc <parameter type> <expr> [<offset number>] E
//
// Not yet in the spec: https://github.com/itanium-cxx-abi/cxx-abi/issues/47
template <typename Derived, typename Alloc>
Node *
AbstractManglingParser<Derived, Alloc>::parsePointerToMemberConversionExpr(
    Node::Prec Prec) {
  Node *Ty = getDerived().parseType();
  if (!Ty)
    return nullptr;
  Node *Expr = getDerived().parseExpr();
  if (!Expr)
    return nullptr;
  std::string_view Offset = getDerived().parseNumber(true);
  if (!consumeIf('E'))
    return nullptr;
  return make<PointerToMemberConversionExpr>(Ty, Expr, Offset, Prec);
}

// <expression> ::= so <referent type> <expr> [<offset number>] <union-selector>* [p] E
// <union-selector> ::= _ [<number>]
//
// Not yet in the spec: https://github.com/itanium-cxx-abi/cxx-abi/issues/47
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseSubobjectExpr() {
  Node *Ty = getDerived().parseType();
  if (!Ty)
    return nullptr;
  Node *Expr = getDerived().parseExpr();
  if (!Expr)
    return nullptr;
  std::string_view Offset = getDerived().parseNumber(true);
  size_t SelectorsBegin = Names.size();
  while (consumeIf('_')) {
    Node *Selector = make<NameType>(parseNumber());
    if (!Selector)
      return nullptr;
    Names.push_back(Selector);
  }
  bool OnePastTheEnd = consumeIf('p');
  if (!consumeIf('E'))
    return nullptr;
  return make<SubobjectExpr>(
      Ty, Expr, Offset, popTrailingNodeArray(SelectorsBegin), OnePastTheEnd);
}

template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseConstraintExpr() {
  // Within this expression, all enclosing template parameter lists are in
  // scope.
  ScopedOverride<bool> SaveIncompleteTemplateParameterTracking(
      HasIncompleteTemplateParameterTracking, true);
  return getDerived().parseExpr();
}

template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseRequiresExpr() {
  NodeArray Params;
  if (consumeIf("rQ")) {
    // <expression> ::= rQ <bare-function-type> _ <requirement>+ E
    size_t ParamsBegin = Names.size();
    while (!consumeIf('_')) {
      Node *Type = getDerived().parseType();
      if (Type == nullptr)
        return nullptr;
      Names.push_back(Type);
    }
    Params = popTrailingNodeArray(ParamsBegin);
  } else if (!consumeIf("rq")) {
    // <expression> ::= rq <requirement>+ E
    return nullptr;
  }

  size_t ReqsBegin = Names.size();
  do {
    Node *Constraint = nullptr;
    if (consumeIf('X')) {
      // <requirement> ::= X <expression> [N] [R <type-constraint>]
      Node *Expr = getDerived().parseExpr();
      if (Expr == nullptr)
        return nullptr;
      bool Noexcept = consumeIf('N');
      Node *TypeReq = nullptr;
      if (consumeIf('R')) {
        TypeReq = getDerived().parseName();
        if (TypeReq == nullptr)
          return nullptr;
      }
      Constraint = make<ExprRequirement>(Expr, Noexcept, TypeReq);
    } else if (consumeIf('T')) {
      // <requirement> ::= T <type>
      Node *Type = getDerived().parseType();
      if (Type == nullptr)
        return nullptr;
      Constraint = make<TypeRequirement>(Type);
    } else if (consumeIf('Q')) {
      // <requirement> ::= Q <constraint-expression>
      //
      // FIXME: We use <expression> instead of <constraint-expression>. Either
      // the requires expression is already inside a constraint expression, in
      // which case it makes no difference, or we're in a requires-expression
      // that might be partially-substituted, where the language behavior is
      // not yet settled and clang mangles after substitution.
      Node *NestedReq = getDerived().parseExpr();
      if (NestedReq == nullptr)
        return nullptr;
      Constraint = make<NestedRequirement>(NestedReq);
    }
    if (Constraint == nullptr)
      return nullptr;
    Names.push_back(Constraint);
  } while (!consumeIf('E'));

  return make<RequiresExpr>(Params, popTrailingNodeArray(ReqsBegin));
}

// <expression> ::= <unary operator-name> <expression>
//              ::= <binary operator-name> <expression> <expression>
//              ::= <ternary operator-name> <expression> <expression> <expression>
//              ::= cl <expression>+ E                                   # call
//              ::= cp <base-unresolved-name> <expression>* E            # (name) (expr-list), call that would use argument-dependent lookup but for the parentheses
//              ::= cv <type> <expression>                               # conversion with one argument
//              ::= cv <type> _ <expression>* E                          # conversion with a different number of arguments
//              ::= [gs] nw <expression>* _ <type> E                     # new (expr-list) type
//              ::= [gs] nw <expression>* _ <type> <initializer>         # new (expr-list) type (init)
//              ::= [gs] na <expression>* _ <type> E                     # new[] (expr-list) type
//              ::= [gs] na <expression>* _ <type> <initializer>         # new[] (expr-list) type (init)
//              ::= [gs] dl <expression>                                 # delete expression
//              ::= [gs] da <expression>                                 # delete[] expression
//              ::= pp_ <expression>                                     # prefix ++
//              ::= mm_ <expression>                                     # prefix --
//              ::= ti <type>                                            # typeid (type)
//              ::= te <expression>                                      # typeid (expression)
//              ::= dc <type> <expression>                               # dynamic_cast<type> (expression)
//              ::= sc <type> <expression>                               # static_cast<type> (expression)
//              ::= cc <type> <expression>                               # const_cast<type> (expression)
//              ::= rc <type> <expression>                               # reinterpret_cast<type> (expression)
//              ::= st <type>                                            # sizeof (a type)
//              ::= sz <expression>                                      # sizeof (an expression)
//              ::= at <type>                                            # alignof (a type)
//              ::= az <expression>                                      # alignof (an expression)
//              ::= nx <expression>                                      # noexcept (expression)
//              ::= <template-param>
//              ::= <function-param>
//              ::= dt <expression> <unresolved-name>                    # expr.name
//              ::= pt <expression> <unresolved-name>                    # expr->name
//              ::= ds <expression> <expression>                         # expr.*expr
//              ::= sZ <template-param>                                  # size of a parameter pack
//              ::= sZ <function-param>                                  # size of a function parameter pack
//              ::= sP <template-arg>* E                                 # sizeof...(T), size of a captured template parameter pack from an alias template
//              ::= sp <expression>                                      # pack expansion
//              ::= tw <expression>                                      # throw expression
//              ::= tr                                                   # throw with no operand (rethrow)
//              ::= <unresolved-name>                                    # f(p), N::f(p), ::f(p),
//                                                                       # freestanding dependent name (e.g., T::x),
//                                                                       # objectless nonstatic member reference
//              ::= fL <binary-operator-name> <expression> <expression>
//              ::= fR <binary-operator-name> <expression> <expression>
//              ::= fl <binary-operator-name> <expression>
//              ::= fr <binary-operator-name> <expression>
//              ::= <expr-primary>
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseExpr() {
  bool Global = consumeIf("gs");

  const auto *Op = parseOperatorEncoding();
  if (Op) {
    auto Sym = Op->getSymbol();
    switch (Op->getKind()) {
    case OperatorInfo::Binary:
      // Binary operator: lhs @ rhs
      return getDerived().parseBinaryExpr(Sym, Op->getPrecedence());
    case OperatorInfo::Prefix:
      // Prefix unary operator: @ expr
      return getDerived().parsePrefixExpr(Sym, Op->getPrecedence());
    case OperatorInfo::Postfix: {
      // Postfix unary operator: expr @
      if (consumeIf('_'))
        return getDerived().parsePrefixExpr(Sym, Op->getPrecedence());
      Node *Ex = getDerived().parseExpr();
      if (Ex == nullptr)
        return nullptr;
      return make<PostfixExpr>(Ex, Sym, Op->getPrecedence());
    }
    case OperatorInfo::Array: {
      // Array Index:  lhs [ rhs ]
      Node *Base = getDerived().parseExpr();
      if (Base == nullptr)
        return nullptr;
      Node *Index = getDerived().parseExpr();
      if (Index == nullptr)
        return nullptr;
      return make<ArraySubscriptExpr>(Base, Index, Op->getPrecedence());
    }
    case OperatorInfo::Member: {
      // Member access lhs @ rhs
      Node *LHS = getDerived().parseExpr();
      if (LHS == nullptr)
        return nullptr;
      Node *RHS = getDerived().parseExpr();
      if (RHS == nullptr)
        return nullptr;
      return make<MemberExpr>(LHS, Sym, RHS, Op->getPrecedence());
    }
    case OperatorInfo::New: {
      // New
      // # new (expr-list) type [(init)]
      // [gs] nw <expression>* _ <type> [pi <expression>*] E
      // # new[] (expr-list) type [(init)]
      // [gs] na <expression>* _ <type> [pi <expression>*] E
      size_t Exprs = Names.size();
      while (!consumeIf('_')) {
        Node *Ex = getDerived().parseExpr();
        if (Ex == nullptr)
          return nullptr;
        Names.push_back(Ex);
      }
      NodeArray ExprList = popTrailingNodeArray(Exprs);
      Node *Ty = getDerived().parseType();
      if (Ty == nullptr)
        return nullptr;
      bool HaveInits = consumeIf("pi");
      size_t InitsBegin = Names.size();
      while (!consumeIf('E')) {
        if (!HaveInits)
          return nullptr;
        Node *Init = getDerived().parseExpr();
        if (Init == nullptr)
          return Init;
        Names.push_back(Init);
      }
      NodeArray Inits = popTrailingNodeArray(InitsBegin);
      return make<NewExpr>(ExprList, Ty, Inits, Global,
                           /*IsArray=*/Op->getFlag(), Op->getPrecedence());
    }
    case OperatorInfo::Del: {
      // Delete
      Node *Ex = getDerived().parseExpr();
      if (Ex == nullptr)
        return nullptr;
      return make<DeleteExpr>(Ex, Global, /*IsArray=*/Op->getFlag(),
                              Op->getPrecedence());
    }
    case OperatorInfo::Call: {
      // Function Call
      Node *Callee = getDerived().parseExpr();
      if (Callee == nullptr)
        return nullptr;
      size_t ExprsBegin = Names.size();
      while (!consumeIf('E')) {
        Node *E = getDerived().parseExpr();
        if (E == nullptr)
          return nullptr;
        Names.push_back(E);
      }
      return make<CallExpr>(Callee, popTrailingNodeArray(ExprsBegin),
                            /*IsParen=*/Op->getFlag(), Op->getPrecedence());
    }
    case OperatorInfo::CCast: {
      // C Cast: (type)expr
      Node *Ty;
      {
        ScopedOverride<bool> SaveTemp(TryToParseTemplateArgs, false);
        Ty = getDerived().parseType();
      }
      if (Ty == nullptr)
        return nullptr;

      size_t ExprsBegin = Names.size();
      bool IsMany = consumeIf('_');
      while (!consumeIf('E')) {
        Node *E = getDerived().parseExpr();
        if (E == nullptr)
          return E;
        Names.push_back(E);
        if (!IsMany)
          break;
      }
      NodeArray Exprs = popTrailingNodeArray(ExprsBegin);
      if (!IsMany && Exprs.size() != 1)
        return nullptr;
      return make<ConversionExpr>(Ty, Exprs, Op->getPrecedence());
    }
    case OperatorInfo::Conditional: {
      // Conditional operator: expr ? expr : expr
      Node *Cond = getDerived().parseExpr();
      if (Cond == nullptr)
        return nullptr;
      Node *LHS = getDerived().parseExpr();
      if (LHS == nullptr)
        return nullptr;
      Node *RHS = getDerived().parseExpr();
      if (RHS == nullptr)
        return nullptr;
      return make<ConditionalExpr>(Cond, LHS, RHS, Op->getPrecedence());
    }
    case OperatorInfo::NamedCast: {
      // Named cast operation, @<type>(expr)
      Node *Ty = getDerived().parseType();
      if (Ty == nullptr)
        return nullptr;
      Node *Ex = getDerived().parseExpr();
      if (Ex == nullptr)
        return nullptr;
      return make<CastExpr>(Sym, Ty, Ex, Op->getPrecedence());
    }
    case OperatorInfo::OfIdOp: {
      // [sizeof/alignof/typeid] ( <type>|<expr> )
      Node *Arg =
          Op->getFlag() ? getDerived().parseType() : getDerived().parseExpr();
      if (!Arg)
        return nullptr;
      return make<EnclosingExpr>(Sym, Arg, Op->getPrecedence());
    }
    case OperatorInfo::NameOnly: {
      // Not valid as an expression operand.
      return nullptr;
    }
    }
    DEMANGLE_UNREACHABLE;
  }

  if (numLeft() < 2)
    return nullptr;

  if (look() == 'L')
    return getDerived().parseExprPrimary();
  if (look() == 'T')
    return getDerived().parseTemplateParam();
  if (look() == 'f') {
    // Disambiguate a fold expression from a <function-param>.
    if (look(1) == 'p' || (look(1) == 'L' && std::isdigit(look(2))))
      return getDerived().parseFunctionParam();
    return getDerived().parseFoldExpr();
  }
  if (consumeIf("il")) {
    size_t InitsBegin = Names.size();
    while (!consumeIf('E')) {
      Node *E = getDerived().parseBracedExpr();
      if (E == nullptr)
        return nullptr;
      Names.push_back(E);
    }
    return make<InitListExpr>(nullptr, popTrailingNodeArray(InitsBegin));
  }
  if (consumeIf("mc"))
    return parsePointerToMemberConversionExpr(Node::Prec::Unary);
  if (consumeIf("nx")) {
    Node *Ex = getDerived().parseExpr();
    if (Ex == nullptr)
      return Ex;
    return make<EnclosingExpr>("noexcept ", Ex, Node::Prec::Unary);
  }
  if (look() == 'r' && (look(1) == 'q' || look(1) == 'Q'))
    return parseRequiresExpr();
  if (consumeIf("so"))
    return parseSubobjectExpr();
  if (consumeIf("sp")) {
    Node *Child = getDerived().parseExpr();
    if (Child == nullptr)
      return nullptr;
    return make<ParameterPackExpansion>(Child);
  }
  if (consumeIf("sZ")) {
    if (look() == 'T') {
      Node *R = getDerived().parseTemplateParam();
      if (R == nullptr)
        return nullptr;
      return make<SizeofParamPackExpr>(R);
    }
    Node *FP = getDerived().parseFunctionParam();
    if (FP == nullptr)
      return nullptr;
    return make<EnclosingExpr>("sizeof... ", FP);
  }
  if (consumeIf("sP")) {
    size_t ArgsBegin = Names.size();
    while (!consumeIf('E')) {
      Node *Arg = getDerived().parseTemplateArg();
      if (Arg == nullptr)
        return nullptr;
      Names.push_back(Arg);
    }
    auto *Pack = make<NodeArrayNode>(popTrailingNodeArray(ArgsBegin));
    if (!Pack)
      return nullptr;
    return make<EnclosingExpr>("sizeof... ", Pack);
  }
  if (consumeIf("tl")) {
    Node *Ty = getDerived().parseType();
    if (Ty == nullptr)
      return nullptr;
    size_t InitsBegin = Names.size();
    while (!consumeIf('E')) {
      Node *E = getDerived().parseBracedExpr();
      if (E == nullptr)
        return nullptr;
      Names.push_back(E);
    }
    return make<InitListExpr>(Ty, popTrailingNodeArray(InitsBegin));
  }
  if (consumeIf("tr"))
    return make<NameType>("throw");
  if (consumeIf("tw")) {
    Node *Ex = getDerived().parseExpr();
    if (Ex == nullptr)
      return nullptr;
    return make<ThrowExpr>(Ex);
  }
  if (consumeIf('u')) {
    Node *Name = getDerived().parseSourceName(/*NameState=*/nullptr);
    if (!Name)
      return nullptr;
    // Special case legacy __uuidof mangling. The 't' and 'z' appear where the
    // standard encoding expects a <template-arg>, and would be otherwise be
    // interpreted as <type> node 'short' or 'ellipsis'. However, neither
    // __uuidof(short) nor __uuidof(...) can actually appear, so there is no
    // actual conflict here.
    bool IsUUID = false;
    Node *UUID = nullptr;
    if (Name->getBaseName() == "__uuidof") {
      if (consumeIf('t')) {
        UUID = getDerived().parseType();
        IsUUID = true;
      } else if (consumeIf('z')) {
        UUID = getDerived().parseExpr();
        IsUUID = true;
      }
    }
    size_t ExprsBegin = Names.size();
    if (IsUUID) {
      if (UUID == nullptr)
        return nullptr;
      Names.push_back(UUID);
    } else {
      while (!consumeIf('E')) {
        Node *E = getDerived().parseTemplateArg();
        if (E == nullptr)
          return E;
        Names.push_back(E);
      }
    }
    return make<CallExpr>(Name, popTrailingNodeArray(ExprsBegin),
                          /*IsParen=*/false, Node::Prec::Postfix);
  }

  // Only unresolved names remain.
  return getDerived().parseUnresolvedName(Global);
}

// <call-offset> ::= h <nv-offset> _
//               ::= v <v-offset> _
//
// <nv-offset> ::= <offset number>
//               # non-virtual base override
//
// <v-offset>  ::= <offset number> _ <virtual offset number>
//               # virtual base override, with vcall offset
template <typename Alloc, typename Derived>
bool AbstractManglingParser<Alloc, Derived>::parseCallOffset() {
  // Just scan through the call offset, we never add this information into the
  // output.
  if (consumeIf('h'))
    return parseNumber(true).empty() || !consumeIf('_');
  if (consumeIf('v'))
    return parseNumber(true).empty() || !consumeIf('_') ||
           parseNumber(true).empty() || !consumeIf('_');
  return true;
}

// <special-name> ::= TV <type>    # virtual table
//                ::= TT <type>    # VTT structure (construction vtable index)
//                ::= TI <type>    # typeinfo structure
//                ::= TS <type>    # typeinfo name (null-terminated byte string)
//                ::= Tc <call-offset> <call-offset> <base encoding>
//                    # base is the nominal target function of thunk
//                    # first call-offset is 'this' adjustment
//                    # second call-offset is result adjustment
//                ::= T <call-offset> <base encoding>
//                    # base is the nominal target function of thunk
//                # Guard variable for one-time initialization
//                ::= GV <object name>
//                                     # No <type>
//                ::= TW <object name> # Thread-local wrapper
//                ::= TH <object name> # Thread-local initialization
//                ::= GR <object name> _             # First temporary
//                ::= GR <object name> <seq-id> _    # Subsequent temporaries
//                # construction vtable for second-in-first
//      extension ::= TC <first type> <number> _ <second type>
//      extension ::= GR <object name> # reference temporary for object
//      extension ::= GI <module name> # module global initializer
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseSpecialName() {
  switch (look()) {
  case 'T':
    switch (look(1)) {
    // TA <template-arg>    # template parameter object
    //
    // Not yet in the spec: https://github.com/itanium-cxx-abi/cxx-abi/issues/63
    case 'A': {
      First += 2;
      Node *Arg = getDerived().parseTemplateArg();
      if (Arg == nullptr)
        return nullptr;
      return make<SpecialName>("template parameter object for ", Arg);
    }
    // TV <type>    # virtual table
    case 'V': {
      First += 2;
      Node *Ty = getDerived().parseType();
      if (Ty == nullptr)
        return nullptr;
      return make<SpecialName>("vtable for ", Ty);
    }
    // TT <type>    # VTT structure (construction vtable index)
    case 'T': {
      First += 2;
      Node *Ty = getDerived().parseType();
      if (Ty == nullptr)
        return nullptr;
      return make<SpecialName>("VTT for ", Ty);
    }
    // TI <type>    # typeinfo structure
    case 'I': {
      First += 2;
      Node *Ty = getDerived().parseType();
      if (Ty == nullptr)
        return nullptr;
      return make<SpecialName>("typeinfo for ", Ty);
    }
    // TS <type>    # typeinfo name (null-terminated byte string)
    case 'S': {
      First += 2;
      Node *Ty = getDerived().parseType();
      if (Ty == nullptr)
        return nullptr;
      return make<SpecialName>("typeinfo name for ", Ty);
    }
    // Tc <call-offset> <call-offset> <base encoding>
    case 'c': {
      First += 2;
      if (parseCallOffset() || parseCallOffset())
        return nullptr;
      Node *Encoding = getDerived().parseEncoding();
      if (Encoding == nullptr)
        return nullptr;
      return make<SpecialName>("covariant return thunk to ", Encoding);
    }
    // extension ::= TC <first type> <number> _ <second type>
    //               # construction vtable for second-in-first
    case 'C': {
      First += 2;
      Node *FirstType = getDerived().parseType();
      if (FirstType == nullptr)
        return nullptr;
      if (parseNumber(true).empty() || !consumeIf('_'))
        return nullptr;
      Node *SecondType = getDerived().parseType();
      if (SecondType == nullptr)
        return nullptr;
      return make<CtorVtableSpecialName>(SecondType, FirstType);
    }
    // TW <object name> # Thread-local wrapper
    case 'W': {
      First += 2;
      Node *Name = getDerived().parseName();
      if (Name == nullptr)
        return nullptr;
      return make<SpecialName>("thread-local wrapper routine for ", Name);
    }
    // TH <object name> # Thread-local initialization
    case 'H': {
      First += 2;
      Node *Name = getDerived().parseName();
      if (Name == nullptr)
        return nullptr;
      return make<SpecialName>("thread-local initialization routine for ", Name);
    }
    // T <call-offset> <base encoding>
    default: {
      ++First;
      bool IsVirt = look() == 'v';
      if (parseCallOffset())
        return nullptr;
      Node *BaseEncoding = getDerived().parseEncoding();
      if (BaseEncoding == nullptr)
        return nullptr;
      if (IsVirt)
        return make<SpecialName>("virtual thunk to ", BaseEncoding);
      else
        return make<SpecialName>("non-virtual thunk to ", BaseEncoding);
    }
    }
  case 'G':
    switch (look(1)) {
    // GV <object name> # Guard variable for one-time initialization
    case 'V': {
      First += 2;
      Node *Name = getDerived().parseName();
      if (Name == nullptr)
        return nullptr;
      return make<SpecialName>("guard variable for ", Name);
    }
    // GR <object name> # reference temporary for object
    // GR <object name> _             # First temporary
    // GR <object name> <seq-id> _    # Subsequent temporaries
    case 'R': {
      First += 2;
      Node *Name = getDerived().parseName();
      if (Name == nullptr)
        return nullptr;
      size_t Count;
      bool ParsedSeqId = !parseSeqId(&Count);
      if (!consumeIf('_') && ParsedSeqId)
        return nullptr;
      return make<SpecialName>("reference temporary for ", Name);
    }
    // GI <module-name> v
    case 'I': {
      First += 2;
      ModuleName *Module = nullptr;
      if (getDerived().parseModuleNameOpt(Module))
        return nullptr;
      if (Module == nullptr)
        return nullptr;
      return make<SpecialName>("initializer for module ", Module);
    }
    }
  }
  return nullptr;
}

// <encoding> ::= <function name> <bare-function-type>
//                    [`Q` <requires-clause expr>]
//            ::= <data name>
//            ::= <special-name>
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseEncoding(bool ParseParams) {
  // The template parameters of an encoding are unrelated to those of the
  // enclosing context.
  SaveTemplateParams SaveTemplateParamsScope(this);

  if (look() == 'G' || look() == 'T')
    return getDerived().parseSpecialName();

  auto IsEndOfEncoding = [&] {
    // The set of chars that can potentially follow an <encoding> (none of which
    // can start a <type>). Enumerating these allows us to avoid speculative
    // parsing.
    return numLeft() == 0 || look() == 'E' || look() == '.' || look() == '_';
  };

  NameState NameInfo(this);
  Node *Name = getDerived().parseName(&NameInfo);
  if (Name == nullptr)
    return nullptr;

  if (resolveForwardTemplateRefs(NameInfo))
    return nullptr;

  if (IsEndOfEncoding())
    return Name;

  // ParseParams may be false at the top level only, when called from parse().
  // For example in the mangled name _Z3fooILZ3BarEET_f, ParseParams may be
  // false when demangling 3fooILZ3BarEET_f but is always true when demangling
  // 3Bar.
  if (!ParseParams) {
    while (consume())
      ;
    return Name;
  }

  Node *Attrs = nullptr;
  if (consumeIf("Ua9enable_ifI")) {
    size_t BeforeArgs = Names.size();
    while (!consumeIf('E')) {
      Node *Arg = getDerived().parseTemplateArg();
      if (Arg == nullptr)
        return nullptr;
      Names.push_back(Arg);
    }
    Attrs = make<EnableIfAttr>(popTrailingNodeArray(BeforeArgs));
    if (!Attrs)
      return nullptr;
  }

  Node *ReturnType = nullptr;
  if (!NameInfo.CtorDtorConversion && NameInfo.EndsWithTemplateArgs) {
    ReturnType = getDerived().parseType();
    if (ReturnType == nullptr)
      return nullptr;
  }

  NodeArray Params;
  if (!consumeIf('v')) {
    size_t ParamsBegin = Names.size();
    do {
      Node *Ty = getDerived().parseType();
      if (Ty == nullptr)
        return nullptr;

      const bool IsFirstParam = ParamsBegin == Names.size();
      if (NameInfo.HasExplicitObjectParameter && IsFirstParam)
        Ty = make<ExplicitObjectParameter>(Ty);

      if (Ty == nullptr)
        return nullptr;

      Names.push_back(Ty);
    } while (!IsEndOfEncoding() && look() != 'Q');
    Params = popTrailingNodeArray(ParamsBegin);
  }

  Node *Requires = nullptr;
  if (consumeIf('Q')) {
    Requires = getDerived().parseConstraintExpr();
    if (!Requires)
      return nullptr;
  }

  return make<FunctionEncoding>(ReturnType, Name, Params, Attrs, Requires,
                                NameInfo.CVQualifiers,
                                NameInfo.ReferenceQualifier);
}

template <class Float>
struct FloatData;

template <>
struct FloatData<float>
{
    static const size_t mangled_size = 8;
    static const size_t max_demangled_size = 24;
    static constexpr const char* spec = "%af";
};

template <>
struct FloatData<double>
{
    static const size_t mangled_size = 16;
    static const size_t max_demangled_size = 32;
    static constexpr const char* spec = "%a";
};

template <>
struct FloatData<long double>
{
#if __LDBL_MANT_DIG__ == 113 || __LDBL_MANT_DIG__ == 106
  static const size_t mangled_size = 32;
#elif __LDBL_MANT_DIG__ == 53 || defined(_MSC_VER)
  // MSVC doesn't define __LDBL_MANT_DIG__, but it has long double equal to
  // regular double on all current architectures.
  static const size_t mangled_size = 16;
#elif __LDBL_MANT_DIG__ == 64
  static const size_t mangled_size = 20;
#else
#error Unknown size for __LDBL_MANT_DIG__
#endif
    // `-0x1.ffffffffffffffffffffffffffffp+16383` + 'L' + '\0' == 42 bytes.
    // 28 'f's * 4 bits == 112 bits, which is the number of mantissa bits.
    // Negatives are one character longer than positives.
    // `0x1.` and `p` are constant, and exponents `+16383` and `-16382` are the
    // same length. 1 sign bit, 112 mantissa bits, and 15 exponent bits == 128.
    static const size_t max_demangled_size = 42;
    static constexpr const char *spec = "%LaL";
};

template <typename Alloc, typename Derived>
template <class Float>
Node *AbstractManglingParser<Alloc, Derived>::parseFloatingLiteral() {
  const size_t N = FloatData<Float>::mangled_size;
  if (numLeft() <= N)
    return nullptr;
  std::string_view Data(First, N);
  for (char C : Data)
    if (!(C >= '0' && C <= '9') && !(C >= 'a' && C <= 'f'))
      return nullptr;
  First += N;
  if (!consumeIf('E'))
    return nullptr;
  return make<FloatLiteralImpl<Float>>(Data);
}

// <seq-id> ::= <0-9A-Z>+
template <typename Alloc, typename Derived>
bool AbstractManglingParser<Alloc, Derived>::parseSeqId(size_t *Out) {
  if (!(look() >= '0' && look() <= '9') &&
      !(look() >= 'A' && look() <= 'Z'))
    return true;

  size_t Id = 0;
  while (true) {
    if (look() >= '0' && look() <= '9') {
      Id *= 36;
      Id += static_cast<size_t>(look() - '0');
    } else if (look() >= 'A' && look() <= 'Z') {
      Id *= 36;
      Id += static_cast<size_t>(look() - 'A') + 10;
    } else {
      *Out = Id;
      return false;
    }
    ++First;
  }
}

// <substitution> ::= S <seq-id> _
//                ::= S_
// <substitution> ::= Sa # ::std::allocator
// <substitution> ::= Sb # ::std::basic_string
// <substitution> ::= Ss # ::std::basic_string < char,
//                                               ::std::char_traits<char>,
//                                               ::std::allocator<char> >
// <substitution> ::= Si # ::std::basic_istream<char,  std::char_traits<char> >
// <substitution> ::= So # ::std::basic_ostream<char,  std::char_traits<char> >
// <substitution> ::= Sd # ::std::basic_iostream<char, std::char_traits<char> >
// The St case is handled specially in parseNestedName.
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseSubstitution() {
  if (!consumeIf('S'))
    return nullptr;

  if (look() >= 'a' && look() <= 'z') {
    SpecialSubKind Kind;
    switch (look()) {
    case 'a':
      Kind = SpecialSubKind::allocator;
      break;
    case 'b':
      Kind = SpecialSubKind::basic_string;
      break;
    case 'd':
      Kind = SpecialSubKind::iostream;
      break;
    case 'i':
      Kind = SpecialSubKind::istream;
      break;
    case 'o':
      Kind = SpecialSubKind::ostream;
      break;
    case 's':
      Kind = SpecialSubKind::string;
      break;
    default:
      return nullptr;
    }
    ++First;
    auto *SpecialSub = make<SpecialSubstitution>(Kind);
    if (!SpecialSub)
      return nullptr;

    // Itanium C++ ABI 5.1.2: If a name that would use a built-in <substitution>
    // has ABI tags, the tags are appended to the substitution; the result is a
    // substitutable component.
    Node *WithTags = getDerived().parseAbiTags(SpecialSub);
    if (WithTags != SpecialSub) {
      Subs.push_back(WithTags);
      SpecialSub = WithTags;
    }
    return SpecialSub;
  }

  //                ::= S_
  if (consumeIf('_')) {
    if (Subs.empty())
      return nullptr;
    return Subs[0];
  }

  //                ::= S <seq-id> _
  size_t Index = 0;
  if (parseSeqId(&Index))
    return nullptr;
  ++Index;
  if (!consumeIf('_') || Index >= Subs.size())
    return nullptr;
  return Subs[Index];
}

// <template-param> ::= T_    # first template parameter
//                  ::= T <parameter-2 non-negative number> _
//                  ::= TL <level-1> __
//                  ::= TL <level-1> _ <parameter-2 non-negative number> _
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseTemplateParam() {
  const char *Begin = First;
  if (!consumeIf('T'))
    return nullptr;

  size_t Level = 0;
  if (consumeIf('L')) {
    if (parsePositiveInteger(&Level))
      return nullptr;
    ++Level;
    if (!consumeIf('_'))
      return nullptr;
  }

  size_t Index = 0;
  if (!consumeIf('_')) {
    if (parsePositiveInteger(&Index))
      return nullptr;
    ++Index;
    if (!consumeIf('_'))
      return nullptr;
  }

  // We don't track enclosing template parameter levels well enough to reliably
  // substitute them all within a <constraint-expression>, so print the
  // parameter numbering instead for now.
  // TODO: Track all enclosing template parameters and substitute them here.
  if (HasIncompleteTemplateParameterTracking) {
    return make<NameType>(std::string_view(Begin, First - 1 - Begin));
  }

  // If we're in a context where this <template-param> refers to a
  // <template-arg> further ahead in the mangled name (currently just conversion
  // operator types), then we should only look it up in the right context.
  // This can only happen at the outermost level.
  if (PermitForwardTemplateReferences && Level == 0) {
    Node *ForwardRef = make<ForwardTemplateReference>(Index);
    if (!ForwardRef)
      return nullptr;
    DEMANGLE_ASSERT(ForwardRef->getKind() == Node::KForwardTemplateReference,
                    "");
    ForwardTemplateRefs.push_back(
        static_cast<ForwardTemplateReference *>(ForwardRef));
    return ForwardRef;
  }

  if (Level >= TemplateParams.size() || !TemplateParams[Level] ||
      Index >= TemplateParams[Level]->size()) {
    // Itanium ABI 5.1.8: In a generic lambda, uses of auto in the parameter
    // list are mangled as the corresponding artificial template type parameter.
    if (ParsingLambdaParamsAtLevel == Level && Level <= TemplateParams.size()) {
      // This will be popped by the ScopedTemplateParamList in
      // parseUnnamedTypeName.
      if (Level == TemplateParams.size())
        TemplateParams.push_back(nullptr);
      return make<NameType>("auto");
    }

    return nullptr;
  }

  return (*TemplateParams[Level])[Index];
}

// <template-param-decl> ::= Ty                          # type parameter
//                       ::= Tk <concept name> [<template-args>] # constrained type parameter
//                       ::= Tn <type>                   # non-type parameter
//                       ::= Tt <template-param-decl>* E # template parameter
//                       ::= Tp <template-param-decl>    # parameter pack
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseTemplateParamDecl(
    TemplateParamList *Params) {
  auto InventTemplateParamName = [&](TemplateParamKind Kind) {
    unsigned Index = NumSyntheticTemplateParameters[(int)Kind]++;
    Node *N = make<SyntheticTemplateParamName>(Kind, Index);
    if (N && Params)
      Params->push_back(N);
    return N;
  };

  if (consumeIf("Ty")) {
    Node *Name = InventTemplateParamName(TemplateParamKind::Type);
    if (!Name)
      return nullptr;
    return make<TypeTemplateParamDecl>(Name);
  }

  if (consumeIf("Tk")) {
    // We don't track enclosing template parameter levels well enough to
    // reliably demangle template parameter substitutions, so print an arbitrary
    // string in place of a parameter for now.
    // TODO: Track all enclosing template parameters and demangle substitutions.
    ScopedOverride<bool> SaveIncompleteTemplateParameterTrackingExpr(
        HasIncompleteTemplateParameterTracking, true);
    Node *Constraint = getDerived().parseName();
    if (!Constraint)
      return nullptr;
    Node *Name = InventTemplateParamName(TemplateParamKind::Type);
    if (!Name)
      return nullptr;
    return make<ConstrainedTypeTemplateParamDecl>(Constraint, Name);
  }

  if (consumeIf("Tn")) {
    Node *Name = InventTemplateParamName(TemplateParamKind::NonType);
    if (!Name)
      return nullptr;
    Node *Type = parseType();
    if (!Type)
      return nullptr;
    return make<NonTypeTemplateParamDecl>(Name, Type);
  }

  if (consumeIf("Tt")) {
    Node *Name = InventTemplateParamName(TemplateParamKind::Template);
    if (!Name)
      return nullptr;
    size_t ParamsBegin = Names.size();
    ScopedTemplateParamList TemplateTemplateParamParams(this);
    Node *Requires = nullptr;
    while (!consumeIf('E')) {
      Node *P = parseTemplateParamDecl(TemplateTemplateParamParams.params());
      if (!P)
        return nullptr;
      Names.push_back(P);
      if (consumeIf('Q')) {
        Requires = getDerived().parseConstraintExpr();
        if (Requires == nullptr || !consumeIf('E'))
          return nullptr;
        break;
      }
    }
    NodeArray InnerParams = popTrailingNodeArray(ParamsBegin);
    return make<TemplateTemplateParamDecl>(Name, InnerParams, Requires);
  }

  if (consumeIf("Tp")) {
    Node *P = parseTemplateParamDecl(Params);
    if (!P)
      return nullptr;
    return make<TemplateParamPackDecl>(P);
  }

  return nullptr;
}

// <template-arg> ::= <type>                    # type or template
//                ::= X <expression> E          # expression
//                ::= <expr-primary>            # simple expressions
//                ::= J <template-arg>* E       # argument pack
//                ::= LZ <encoding> E           # extension
//                ::= <template-param-decl> <template-arg>
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parseTemplateArg() {
  switch (look()) {
  case 'X': {
    ++First;
    Node *Arg = getDerived().parseExpr();
    if (Arg == nullptr || !consumeIf('E'))
      return nullptr;
    return Arg;
  }
  case 'J': {
    ++First;
    size_t ArgsBegin = Names.size();
    while (!consumeIf('E')) {
      Node *Arg = getDerived().parseTemplateArg();
      if (Arg == nullptr)
        return nullptr;
      Names.push_back(Arg);
    }
    NodeArray Args = popTrailingNodeArray(ArgsBegin);
    return make<TemplateArgumentPack>(Args);
  }
  case 'L': {
    //                ::= LZ <encoding> E           # extension
    if (look(1) == 'Z') {
      First += 2;
      Node *Arg = getDerived().parseEncoding();
      if (Arg == nullptr || !consumeIf('E'))
        return nullptr;
      return Arg;
    }
    //                ::= <expr-primary>            # simple expressions
    return getDerived().parseExprPrimary();
  }
  case 'T': {
    // Either <template-param> or a <template-param-decl> <template-arg>.
    if (!getDerived().isTemplateParamDecl())
      return getDerived().parseType();
    Node *Param = getDerived().parseTemplateParamDecl(nullptr);
    if (!Param)
      return nullptr;
    Node *Arg = getDerived().parseTemplateArg();
    if (!Arg)
      return nullptr;
    return make<TemplateParamQualifiedArg>(Param, Arg);
  }
  default:
    return getDerived().parseType();
  }
}

// <template-args> ::= I <template-arg>* [Q <requires-clause expr>] E
//     extension, the abi says <template-arg>+
template <typename Derived, typename Alloc>
Node *
AbstractManglingParser<Derived, Alloc>::parseTemplateArgs(bool TagTemplates) {
  if (!consumeIf('I'))
    return nullptr;

  // <template-params> refer to the innermost <template-args>. Clear out any
  // outer args that we may have inserted into TemplateParams.
  if (TagTemplates) {
    TemplateParams.clear();
    TemplateParams.push_back(&OuterTemplateParams);
    OuterTemplateParams.clear();
  }

  size_t ArgsBegin = Names.size();
  Node *Requires = nullptr;
  while (!consumeIf('E')) {
    if (TagTemplates) {
      Node *Arg = getDerived().parseTemplateArg();
      if (Arg == nullptr)
        return nullptr;
      Names.push_back(Arg);
      Node *TableEntry = Arg;
      if (Arg->getKind() == Node::KTemplateParamQualifiedArg) {
        TableEntry =
            static_cast<TemplateParamQualifiedArg *>(TableEntry)->getArg();
      }
      if (Arg->getKind() == Node::KTemplateArgumentPack) {
        TableEntry = make<ParameterPack>(
            static_cast<TemplateArgumentPack*>(TableEntry)->getElements());
        if (!TableEntry)
          return nullptr;
      }
      OuterTemplateParams.push_back(TableEntry);
    } else {
      Node *Arg = getDerived().parseTemplateArg();
      if (Arg == nullptr)
        return nullptr;
      Names.push_back(Arg);
    }
    if (consumeIf('Q')) {
      Requires = getDerived().parseConstraintExpr();
      if (!Requires || !consumeIf('E'))
        return nullptr;
      break;
    }
  }
  return make<TemplateArgs>(popTrailingNodeArray(ArgsBegin), Requires);
}

// <mangled-name> ::= _Z <encoding>
//                ::= <type>
// extension      ::= ___Z <encoding> _block_invoke
// extension      ::= ___Z <encoding> _block_invoke<decimal-digit>+
// extension      ::= ___Z <encoding> _block_invoke_<decimal-digit>+
template <typename Derived, typename Alloc>
Node *AbstractManglingParser<Derived, Alloc>::parse(bool ParseParams) {
  if (consumeIf("_Z") || consumeIf("__Z")) {
    Node *Encoding = getDerived().parseEncoding(ParseParams);
    if (Encoding == nullptr)
      return nullptr;
    if (look() == '.') {
      Encoding =
          make<DotSuffix>(Encoding, std::string_view(First, Last - First));
      First = Last;
    }
    if (numLeft() != 0)
      return nullptr;
    return Encoding;
  }

  if (consumeIf("___Z") || consumeIf("____Z")) {
    Node *Encoding = getDerived().parseEncoding(ParseParams);
    if (Encoding == nullptr || !consumeIf("_block_invoke"))
      return nullptr;
    bool RequireNumber = consumeIf('_');
    if (parseNumber().empty() && RequireNumber)
      return nullptr;
    if (look() == '.')
      First = Last;
    if (numLeft() != 0)
      return nullptr;
    return make<SpecialName>("invocation function for block in ", Encoding);
  }

  Node *Ty = getDerived().parseType();
  if (numLeft() != 0)
    return nullptr;
  return Ty;
}

template <typename Alloc>
struct ManglingParser : AbstractManglingParser<ManglingParser<Alloc>, Alloc> {
  using AbstractManglingParser<ManglingParser<Alloc>,
                               Alloc>::AbstractManglingParser;
};

inline void OutputBuffer::printLeft(const Node &N) { N.printLeft(*this); }

inline void OutputBuffer::printRight(const Node &N) { N.printRight(*this); }

DEMANGLE_NAMESPACE_END

#if defined(__clang__)
#pragma clang diagnostic pop
#endif

#endif // DEMANGLE_ITANIUMDEMANGLE_H

```

`plugin/ios_rtti/llvm/include/llvm/Demangle/ItaniumNodes.def`:

```def
//===--- ItaniumNodes.def ------------*- mode:c++;eval:(read-only-mode) -*-===//
//       Do not edit! See README.txt.
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// Define the demangler's node names

#ifndef NODE
#error Define NODE to handle nodes
#endif

NODE(NodeArrayNode)
NODE(DotSuffix)
NODE(VendorExtQualType)
NODE(QualType)
NODE(ConversionOperatorType)
NODE(PostfixQualifiedType)
NODE(ElaboratedTypeSpefType)
NODE(TransformedType)
NODE(NameType)
NODE(AbiTagAttr)
NODE(EnableIfAttr)
NODE(ObjCProtoName)
NODE(PointerType)
NODE(ReferenceType)
NODE(PointerToMemberType)
NODE(ArrayType)
NODE(FunctionType)
NODE(NoexceptSpec)
NODE(DynamicExceptionSpec)
NODE(FunctionEncoding)
NODE(LiteralOperator)
NODE(SpecialName)
NODE(CtorVtableSpecialName)
NODE(QualifiedName)
NODE(NestedName)
NODE(MemberLikeFriendName)
NODE(LocalName)
NODE(ModuleName)
NODE(ModuleEntity)
NODE(VectorType)
NODE(PixelVectorType)
NODE(BinaryFPType)
NODE(BitIntType)
NODE(SyntheticTemplateParamName)
NODE(TemplateParamQualifiedArg)
NODE(TypeTemplateParamDecl)
NODE(ConstrainedTypeTemplateParamDecl)
NODE(NonTypeTemplateParamDecl)
NODE(TemplateTemplateParamDecl)
NODE(TemplateParamPackDecl)
NODE(ParameterPack)
NODE(TemplateArgumentPack)
NODE(ParameterPackExpansion)
NODE(TemplateArgs)
NODE(ForwardTemplateReference)
NODE(NameWithTemplateArgs)
NODE(GlobalQualifiedName)
NODE(ExpandedSpecialSubstitution)
NODE(SpecialSubstitution)
NODE(CtorDtorName)
NODE(DtorName)
NODE(UnnamedTypeName)
NODE(ClosureTypeName)
NODE(StructuredBindingName)
NODE(BinaryExpr)
NODE(ArraySubscriptExpr)
NODE(PostfixExpr)
NODE(ConditionalExpr)
NODE(MemberExpr)
NODE(SubobjectExpr)
NODE(EnclosingExpr)
NODE(CastExpr)
NODE(SizeofParamPackExpr)
NODE(CallExpr)
NODE(NewExpr)
NODE(DeleteExpr)
NODE(PrefixExpr)
NODE(FunctionParam)
NODE(ConversionExpr)
NODE(PointerToMemberConversionExpr)
NODE(InitListExpr)
NODE(FoldExpr)
NODE(ThrowExpr)
NODE(BoolExpr)
NODE(StringLiteral)
NODE(LambdaExpr)
NODE(EnumLiteral)
NODE(IntegerLiteral)
NODE(FloatLiteral)
NODE(DoubleLiteral)
NODE(LongDoubleLiteral)
NODE(BracedExpr)
NODE(BracedRangeExpr)
NODE(RequiresExpr)
NODE(ExprRequirement)
NODE(TypeRequirement)
NODE(NestedRequirement)
NODE(ExplicitObjectParameter)

#undef NODE

```

`plugin/ios_rtti/llvm/include/llvm/Demangle/StringViewExtras.h`:

```h
//===--- StringViewExtras.h ----------*- mode:c++;eval:(read-only-mode) -*-===//
//       Do not edit! See README.txt.
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// There are two copies of this file in the source tree.  The one under
// libcxxabi is the original and the one under llvm is the copy.  Use
// cp-to-llvm.sh to update the copy.  See README.txt for more details.
//
//===----------------------------------------------------------------------===//

#ifndef DEMANGLE_STRINGVIEW_H
#define DEMANGLE_STRINGVIEW_H

#include "DemangleConfig.h"

#include <string_view>

DEMANGLE_NAMESPACE_BEGIN

inline bool starts_with(std::string_view self, char C) noexcept {
  return !self.empty() && *self.begin() == C;
}

inline bool starts_with(std::string_view haystack,
                        std::string_view needle) noexcept {
  if (needle.size() > haystack.size())
    return false;
  haystack.remove_suffix(haystack.size() - needle.size());
  return haystack == needle;
}

DEMANGLE_NAMESPACE_END

#endif

```

`plugin/ios_rtti/llvm/include/llvm/Demangle/Utility.h`:

```h
//===--- Utility.h -------------------*- mode:c++;eval:(read-only-mode) -*-===//
//       Do not edit! See README.txt.
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// Provide some utility classes for use in the demangler.
// There are two copies of this file in the source tree.  The one in libcxxabi
// is the original and the one in llvm is the copy.  Use cp-to-llvm.sh to update
// the copy.  See README.txt for more details.
//
//===----------------------------------------------------------------------===//

#ifndef DEMANGLE_UTILITY_H
#define DEMANGLE_UTILITY_H

#include "DemangleConfig.h"

#include <array>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <limits>
#include <string_view>

DEMANGLE_NAMESPACE_BEGIN

class Node;

// Stream that AST nodes write their string representation into after the AST
// has been parsed.
class OutputBuffer {
  char *Buffer = nullptr;
  size_t CurrentPosition = 0;
  size_t BufferCapacity = 0;

  // Ensure there are at least N more positions in the buffer.
  void grow(size_t N) {
    size_t Need = N + CurrentPosition;
    if (Need > BufferCapacity) {
      // Reduce the number of reallocations, with a bit of hysteresis. The
      // number here is chosen so the first allocation will more-than-likely not
      // allocate more than 1K.
      Need += 1024 - 32;
      BufferCapacity *= 2;
      if (BufferCapacity < Need)
        BufferCapacity = Need;
      Buffer = static_cast<char *>(std::realloc(Buffer, BufferCapacity));
      if (Buffer == nullptr)
        std::abort();
    }
  }

  OutputBuffer &writeUnsigned(uint64_t N, bool isNeg = false) {
    std::array<char, 21> Temp;
    char *TempPtr = Temp.data() + Temp.size();

    // Output at least one character.
    do {
      *--TempPtr = char('0' + N % 10);
      N /= 10;
    } while (N);

    // Add negative sign.
    if (isNeg)
      *--TempPtr = '-';

    return operator+=(
        std::string_view(TempPtr, Temp.data() + Temp.size() - TempPtr));
  }

public:
  OutputBuffer(char *StartBuf, size_t Size)
      : Buffer(StartBuf), BufferCapacity(Size) {}
  OutputBuffer(char *StartBuf, size_t *SizePtr)
      : OutputBuffer(StartBuf, StartBuf ? *SizePtr : 0) {}
  OutputBuffer() = default;
  // Non-copyable
  OutputBuffer(const OutputBuffer &) = delete;
  OutputBuffer &operator=(const OutputBuffer &) = delete;

  virtual ~OutputBuffer() = default;

  operator std::string_view() const {
    return std::string_view(Buffer, CurrentPosition);
  }

  /// Called by the demangler when printing the demangle tree. By
  /// default calls into \c Node::print{Left|Right} but can be overriden
  /// by clients to track additional state when printing the demangled name.
  virtual void printLeft(const Node &N);
  virtual void printRight(const Node &N);

  /// Called when we write to this object anywhere other than the end.
  virtual void notifyInsertion(size_t /*Position*/, size_t /*Count*/) {}

  /// Called when we make the \c CurrentPosition of this object smaller.
  virtual void notifyDeletion(size_t /*OldPos*/, size_t /*NewPos*/) {}

  /// If a ParameterPackExpansion (or similar type) is encountered, the offset
  /// into the pack that we're currently printing.
  unsigned CurrentPackIndex = std::numeric_limits<unsigned>::max();
  unsigned CurrentPackMax = std::numeric_limits<unsigned>::max();

  struct {
    /// The depth of '(' and ')' inside the currently printed template
    /// arguments.
    unsigned ParenDepth = 0;

    /// True if we're currently printing a template argument.
    bool InsideTemplate = false;
  } TemplateTracker;

  /// Returns true if we're currently between a '(' and ')' when printing
  /// template args.
  bool isInParensInTemplateArgs() const {
    return TemplateTracker.ParenDepth > 0;
  }

  /// Returns true if we're printing template args.
  bool isInsideTemplateArgs() const { return TemplateTracker.InsideTemplate; }

  void printOpen(char Open = '(') {
    if (isInsideTemplateArgs())
      TemplateTracker.ParenDepth++;
    *this += Open;
  }
  void printClose(char Close = ')') {
    if (isInsideTemplateArgs())
      TemplateTracker.ParenDepth--;
    *this += Close;
  }

  OutputBuffer &operator+=(std::string_view R) {
    if (size_t Size = R.size()) {
      grow(Size);
      std::memcpy(Buffer + CurrentPosition, &*R.begin(), Size);
      CurrentPosition += Size;
    }
    return *this;
  }

  OutputBuffer &operator+=(char C) {
    grow(1);
    Buffer[CurrentPosition++] = C;
    return *this;
  }

  OutputBuffer &prepend(std::string_view R) {
    size_t Size = R.size();
    if (!Size)
      return *this;

    grow(Size);
    std::memmove(Buffer + Size, Buffer, CurrentPosition);
    std::memcpy(Buffer, &*R.begin(), Size);
    CurrentPosition += Size;

    notifyInsertion(/*Position=*/0, /*Count=*/Size);

    return *this;
  }

  OutputBuffer &operator<<(std::string_view R) { return (*this += R); }

  OutputBuffer &operator<<(char C) { return (*this += C); }

  OutputBuffer &operator<<(long long N) {
    return writeUnsigned(static_cast<unsigned long long>(std::abs(N)), N < 0);
  }

  OutputBuffer &operator<<(unsigned long long N) {
    return writeUnsigned(N, false);
  }

  OutputBuffer &operator<<(long N) {
    return this->operator<<(static_cast<long long>(N));
  }

  OutputBuffer &operator<<(unsigned long N) {
    return this->operator<<(static_cast<unsigned long long>(N));
  }

  OutputBuffer &operator<<(int N) {
    return this->operator<<(static_cast<long long>(N));
  }

  OutputBuffer &operator<<(unsigned int N) {
    return this->operator<<(static_cast<unsigned long long>(N));
  }

  void insert(size_t Pos, const char *S, size_t N) {
    DEMANGLE_ASSERT(Pos <= CurrentPosition, "");
    if (N == 0)
      return;

    grow(N);
    std::memmove(Buffer + Pos + N, Buffer + Pos, CurrentPosition - Pos);
    std::memcpy(Buffer + Pos, S, N);
    CurrentPosition += N;

    notifyInsertion(Pos, N);
  }

  size_t getCurrentPosition() const { return CurrentPosition; }
  void setCurrentPosition(size_t NewPos) {
    notifyDeletion(CurrentPosition, NewPos);
    CurrentPosition = NewPos;
  }

  char back() const {
    DEMANGLE_ASSERT(CurrentPosition, "");
    return Buffer[CurrentPosition - 1];
  }

  bool empty() const { return CurrentPosition == 0; }

  char *getBuffer() { return Buffer; }
  char *getBufferEnd() { return Buffer + CurrentPosition - 1; }
  size_t getBufferCapacity() const { return BufferCapacity; }
};

template <class T> class ScopedOverride {
  T &Loc;
  T Original;

public:
  ScopedOverride(T &Loc_) : ScopedOverride(Loc_, Loc_) {}

  ScopedOverride(T &Loc_, T NewVal) : Loc(Loc_), Original(Loc_) {
    Loc_ = std::move(NewVal);
  }
  ~ScopedOverride() { Loc = std::move(Original); }

  ScopedOverride(const ScopedOverride &) = delete;
  ScopedOverride &operator=(const ScopedOverride &) = delete;
};

DEMANGLE_NAMESPACE_END

#endif

```

`plugin/ios_rtti/llvm/lib/Demangle/ItaniumDemangle.cpp`:

```cpp
//===------------------------- ItaniumDemangle.cpp ------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

// FIXME: (possibly) incomplete list of features that clang mangles that this
// file does not yet support:
//   - C++ modules TS

#include "llvm/Demangle/Demangle.h"
#include "llvm/Demangle/ItaniumDemangle.h"

#include <cassert>
#include <cctype>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <exception>
#include <functional>
#include <utility>

using namespace llvm;
using namespace llvm::itanium_demangle;

// <discriminator> := _ <non-negative number>      # when number < 10
//                 := __ <non-negative number> _   # when number >= 10
//  extension      := decimal-digit+               # at the end of string
const char *itanium_demangle::parse_discriminator(const char *first,
                                                  const char *last) {
  // parse but ignore discriminator
  if (first != last) {
    if (*first == '_') {
      const char *t1 = first + 1;
      if (t1 != last) {
        if (std::isdigit(*t1))
          first = t1 + 1;
        else if (*t1 == '_') {
          for (++t1; t1 != last && std::isdigit(*t1); ++t1)
            ;
          if (t1 != last && *t1 == '_')
            first = t1 + 1;
        }
      }
    } else if (std::isdigit(*first)) {
      const char *t1 = first + 1;
      for (; t1 != last && std::isdigit(*t1); ++t1)
        ;
      if (t1 == last)
        first = last;
    }
  }
  return first;
}

#ifndef NDEBUG
namespace {
struct DumpVisitor {
  unsigned Depth = 0;
  bool PendingNewline = false;

  template<typename NodeT> static constexpr bool wantsNewline(const NodeT *) {
    return true;
  }
  static bool wantsNewline(NodeArray A) { return !A.empty(); }
  static constexpr bool wantsNewline(...) { return false; }

  template<typename ...Ts> static bool anyWantNewline(Ts ...Vs) {
    for (bool B : {wantsNewline(Vs)...})
      if (B)
        return true;
    return false;
  }

  void printStr(const char *S) { fprintf(stderr, "%s", S); }
  void print(std::string_view SV) {
    fprintf(stderr, "\"%.*s\"", (int)SV.size(), SV.data());
  }
  void print(const Node *N) {
    if (N)
      N->visit(std::ref(*this));
    else
      printStr("<null>");
  }
  void print(NodeArray A) {
    ++Depth;
    printStr("{");
    bool First = true;
    for (const Node *N : A) {
      if (First)
        print(N);
      else
        printWithComma(N);
      First = false;
    }
    printStr("}");
    --Depth;
  }

  // Overload used when T is exactly 'bool', not merely convertible to 'bool'.
  void print(bool B) { printStr(B ? "true" : "false"); }

  template <class T> std::enable_if_t<std::is_unsigned<T>::value> print(T N) {
    fprintf(stderr, "%llu", (unsigned long long)N);
  }

  template <class T> std::enable_if_t<std::is_signed<T>::value> print(T N) {
    fprintf(stderr, "%lld", (long long)N);
  }

  void print(ReferenceKind RK) {
    switch (RK) {
    case ReferenceKind::LValue:
      return printStr("ReferenceKind::LValue");
    case ReferenceKind::RValue:
      return printStr("ReferenceKind::RValue");
    }
  }
  void print(FunctionRefQual RQ) {
    switch (RQ) {
    case FunctionRefQual::FrefQualNone:
      return printStr("FunctionRefQual::FrefQualNone");
    case FunctionRefQual::FrefQualLValue:
      return printStr("FunctionRefQual::FrefQualLValue");
    case FunctionRefQual::FrefQualRValue:
      return printStr("FunctionRefQual::FrefQualRValue");
    }
  }
  void print(Qualifiers Qs) {
    if (!Qs) return printStr("QualNone");
    struct QualName { Qualifiers Q; const char *Name; } Names[] = {
      {QualConst, "QualConst"},
      {QualVolatile, "QualVolatile"},
      {QualRestrict, "QualRestrict"},
    };
    for (QualName Name : Names) {
      if (Qs & Name.Q) {
        printStr(Name.Name);
        Qs = Qualifiers(Qs & ~Name.Q);
        if (Qs) printStr(" | ");
      }
    }
  }
  void print(SpecialSubKind SSK) {
    switch (SSK) {
    case SpecialSubKind::allocator:
      return printStr("SpecialSubKind::allocator");
    case SpecialSubKind::basic_string:
      return printStr("SpecialSubKind::basic_string");
    case SpecialSubKind::string:
      return printStr("SpecialSubKind::string");
    case SpecialSubKind::istream:
      return printStr("SpecialSubKind::istream");
    case SpecialSubKind::ostream:
      return printStr("SpecialSubKind::ostream");
    case SpecialSubKind::iostream:
      return printStr("SpecialSubKind::iostream");
    }
  }
  void print(TemplateParamKind TPK) {
    switch (TPK) {
    case TemplateParamKind::Type:
      return printStr("TemplateParamKind::Type");
    case TemplateParamKind::NonType:
      return printStr("TemplateParamKind::NonType");
    case TemplateParamKind::Template:
      return printStr("TemplateParamKind::Template");
    }
  }
  void print(Node::Prec P) {
    switch (P) {
    case Node::Prec::Primary:
      return printStr("Node::Prec::Primary");
    case Node::Prec::Postfix:
      return printStr("Node::Prec::Postfix");
    case Node::Prec::Unary:
      return printStr("Node::Prec::Unary");
    case Node::Prec::Cast:
      return printStr("Node::Prec::Cast");
    case Node::Prec::PtrMem:
      return printStr("Node::Prec::PtrMem");
    case Node::Prec::Multiplicative:
      return printStr("Node::Prec::Multiplicative");
    case Node::Prec::Additive:
      return printStr("Node::Prec::Additive");
    case Node::Prec::Shift:
      return printStr("Node::Prec::Shift");
    case Node::Prec::Spaceship:
      return printStr("Node::Prec::Spaceship");
    case Node::Prec::Relational:
      return printStr("Node::Prec::Relational");
    case Node::Prec::Equality:
      return printStr("Node::Prec::Equality");
    case Node::Prec::And:
      return printStr("Node::Prec::And");
    case Node::Prec::Xor:
      return printStr("Node::Prec::Xor");
    case Node::Prec::Ior:
      return printStr("Node::Prec::Ior");
    case Node::Prec::AndIf:
      return printStr("Node::Prec::AndIf");
    case Node::Prec::OrIf:
      return printStr("Node::Prec::OrIf");
    case Node::Prec::Conditional:
      return printStr("Node::Prec::Conditional");
    case Node::Prec::Assign:
      return printStr("Node::Prec::Assign");
    case Node::Prec::Comma:
      return printStr("Node::Prec::Comma");
    case Node::Prec::Default:
      return printStr("Node::Prec::Default");
    }
  }

  void newLine() {
    printStr("\n");
    for (unsigned I = 0; I != Depth; ++I)
      printStr(" ");
    PendingNewline = false;
  }

  template<typename T> void printWithPendingNewline(T V) {
    print(V);
    if (wantsNewline(V))
      PendingNewline = true;
  }

  template<typename T> void printWithComma(T V) {
    if (PendingNewline || wantsNewline(V)) {
      printStr(",");
      newLine();
    } else {
      printStr(", ");
    }

    printWithPendingNewline(V);
  }

  struct CtorArgPrinter {
    DumpVisitor &Visitor;

    template<typename T, typename ...Rest> void operator()(T V, Rest ...Vs) {
      if (Visitor.anyWantNewline(V, Vs...))
        Visitor.newLine();
      Visitor.printWithPendingNewline(V);
      int PrintInOrder[] = { (Visitor.printWithComma(Vs), 0)..., 0 };
      (void)PrintInOrder;
    }
  };

  template<typename NodeT> void operator()(const NodeT *Node) {
    Depth += 2;
    fprintf(stderr, "%s(", itanium_demangle::NodeKind<NodeT>::name());
    Node->match(CtorArgPrinter{*this});
    fprintf(stderr, ")");
    Depth -= 2;
  }

  void operator()(const ForwardTemplateReference *Node) {
    Depth += 2;
    fprintf(stderr, "ForwardTemplateReference(");
    if (Node->Ref && !Node->Printing) {
      Node->Printing = true;
      CtorArgPrinter{*this}(Node->Ref);
      Node->Printing = false;
    } else {
      CtorArgPrinter{*this}(Node->Index);
    }
    fprintf(stderr, ")");
    Depth -= 2;
  }
};
}

void itanium_demangle::Node::dump() const {
  DumpVisitor V;
  visit(std::ref(V));
  V.newLine();
}
#endif

namespace {
class BumpPointerAllocator {
  struct BlockMeta {
    BlockMeta* Next;
    size_t Current;
  };

  static constexpr size_t AllocSize = 4096;
  static constexpr size_t UsableAllocSize = AllocSize - sizeof(BlockMeta);

  alignas(long double) char InitialBuffer[AllocSize];
  BlockMeta* BlockList = nullptr;

  void grow() {
    char* NewMeta = static_cast<char *>(std::malloc(AllocSize));
    if (NewMeta == nullptr)
      std::terminate();
    BlockList = new (NewMeta) BlockMeta{BlockList, 0};
  }

  void* allocateMassive(size_t NBytes) {
    NBytes += sizeof(BlockMeta);
    BlockMeta* NewMeta = reinterpret_cast<BlockMeta*>(std::malloc(NBytes));
    if (NewMeta == nullptr)
      std::terminate();
    BlockList->Next = new (NewMeta) BlockMeta{BlockList->Next, 0};
    return static_cast<void*>(NewMeta + 1);
  }

public:
  BumpPointerAllocator()
      : BlockList(new (InitialBuffer) BlockMeta{nullptr, 0}) {}

  void* allocate(size_t N) {
    N = (N + 15u) & ~15u;
    if (N + BlockList->Current >= UsableAllocSize) {
      if (N > UsableAllocSize)
        return allocateMassive(N);
      grow();
    }
    BlockList->Current += N;
    return static_cast<void*>(reinterpret_cast<char*>(BlockList + 1) +
                              BlockList->Current - N);
  }

  void reset() {
    while (BlockList) {
      BlockMeta* Tmp = BlockList;
      BlockList = BlockList->Next;
      if (reinterpret_cast<char*>(Tmp) != InitialBuffer)
        std::free(Tmp);
    }
    BlockList = new (InitialBuffer) BlockMeta{nullptr, 0};
  }

  ~BumpPointerAllocator() { reset(); }
};

class DefaultAllocator {
  BumpPointerAllocator Alloc;

public:
  void reset() { Alloc.reset(); }

  template<typename T, typename ...Args> T *makeNode(Args &&...args) {
    return new (Alloc.allocate(sizeof(T)))
        T(std::forward<Args>(args)...);
  }

  void *allocateNodeArray(size_t sz) {
    return Alloc.allocate(sizeof(Node *) * sz);
  }
};
}  // unnamed namespace

//===----------------------------------------------------------------------===//
// Code beyond this point should not be synchronized with libc++abi.
//===----------------------------------------------------------------------===//

using Demangler = itanium_demangle::ManglingParser<DefaultAllocator>;

char *llvm::itaniumDemangle(std::string_view MangledName, bool ParseParams) {
  if (MangledName.empty())
    return nullptr;

  Demangler Parser(MangledName.data(),
                   MangledName.data() + MangledName.length());
  Node *AST = Parser.parse(ParseParams);
  if (!AST)
    return nullptr;

  OutputBuffer OB;
  assert(Parser.ForwardTemplateRefs.empty());
  AST->print(OB);
  OB += '\0';
  return OB.getBuffer();
}

ItaniumPartialDemangler::ItaniumPartialDemangler()
    : RootNode(nullptr), Context(new Demangler{nullptr, nullptr}) {}

ItaniumPartialDemangler::~ItaniumPartialDemangler() {
  delete static_cast<Demangler *>(Context);
}

ItaniumPartialDemangler::ItaniumPartialDemangler(
    ItaniumPartialDemangler &&Other)
    : RootNode(Other.RootNode), Context(Other.Context) {
  Other.Context = Other.RootNode = nullptr;
}

ItaniumPartialDemangler &ItaniumPartialDemangler::
operator=(ItaniumPartialDemangler &&Other) {
  std::swap(RootNode, Other.RootNode);
  std::swap(Context, Other.Context);
  return *this;
}

// Demangle MangledName into an AST, storing it into this->RootNode.
bool ItaniumPartialDemangler::partialDemangle(const char *MangledName) {
  Demangler *Parser = static_cast<Demangler *>(Context);
  size_t Len = std::strlen(MangledName);
  Parser->reset(MangledName, MangledName + Len);
  RootNode = Parser->parse();
  return RootNode == nullptr;
}
static char *printNode(const Node *RootNode, OutputBuffer &OB, size_t *N) {
  RootNode->print(OB);
  OB += '\0';
  if (N != nullptr)
    *N = OB.getCurrentPosition();
  return OB.getBuffer();
}

static char *printNode(const Node *RootNode, char *Buf, size_t *N) {
  OutputBuffer OB(Buf, N);
  return printNode(RootNode, OB, N);
}

char *ItaniumPartialDemangler::getFunctionBaseName(char *Buf, size_t *N) const {
  if (!isFunction())
    return nullptr;

  const Node *Name = static_cast<const FunctionEncoding *>(RootNode)->getName();

  while (true) {
    switch (Name->getKind()) {
    case Node::KAbiTagAttr:
      Name = static_cast<const AbiTagAttr *>(Name)->Base;
      continue;
    case Node::KModuleEntity:
      Name = static_cast<const ModuleEntity *>(Name)->Name;
      continue;
    case Node::KNestedName:
      Name = static_cast<const NestedName *>(Name)->Name;
      continue;
    case Node::KLocalName:
      Name = static_cast<const LocalName *>(Name)->Entity;
      continue;
    case Node::KNameWithTemplateArgs:
      Name = static_cast<const NameWithTemplateArgs *>(Name)->Name;
      continue;
    default:
      return printNode(Name, Buf, N);
    }
  }
}

char *ItaniumPartialDemangler::getFunctionDeclContextName(char *Buf,
                                                          size_t *N) const {
  if (!isFunction())
    return nullptr;
  const Node *Name = static_cast<const FunctionEncoding *>(RootNode)->getName();

  OutputBuffer OB(Buf, N);

 KeepGoingLocalFunction:
  while (true) {
    if (Name->getKind() == Node::KAbiTagAttr) {
      Name = static_cast<const AbiTagAttr *>(Name)->Base;
      continue;
    }
    if (Name->getKind() == Node::KNameWithTemplateArgs) {
      Name = static_cast<const NameWithTemplateArgs *>(Name)->Name;
      continue;
    }
    break;
  }

  if (Name->getKind() == Node::KModuleEntity)
    Name = static_cast<const ModuleEntity *>(Name)->Name;

  switch (Name->getKind()) {
  case Node::KNestedName:
    static_cast<const NestedName *>(Name)->Qual->print(OB);
    break;
  case Node::KLocalName: {
    auto *LN = static_cast<const LocalName *>(Name);
    LN->Encoding->print(OB);
    OB += "::";
    Name = LN->Entity;
    goto KeepGoingLocalFunction;
  }
  default:
    break;
  }
  OB += '\0';
  if (N != nullptr)
    *N = OB.getCurrentPosition();
  return OB.getBuffer();
}

char *ItaniumPartialDemangler::getFunctionName(char *Buf, size_t *N) const {
  if (!isFunction())
    return nullptr;
  auto *Name = static_cast<FunctionEncoding *>(RootNode)->getName();
  return printNode(Name, Buf, N);
}

char *ItaniumPartialDemangler::getFunctionParameters(char *Buf,
                                                     size_t *N) const {
  if (!isFunction())
    return nullptr;
  NodeArray Params = static_cast<FunctionEncoding *>(RootNode)->getParams();

  OutputBuffer OB(Buf, N);

  OB += '(';
  Params.printWithComma(OB);
  OB += ')';
  OB += '\0';
  if (N != nullptr)
    *N = OB.getCurrentPosition();
  return OB.getBuffer();
}

char *ItaniumPartialDemangler::getFunctionReturnType(
    char *Buf, size_t *N) const {
  if (!isFunction())
    return nullptr;

  OutputBuffer OB(Buf, N);

  if (const Node *Ret =
          static_cast<const FunctionEncoding *>(RootNode)->getReturnType())
    Ret->print(OB);

  OB += '\0';
  if (N != nullptr)
    *N = OB.getCurrentPosition();
  return OB.getBuffer();
}

char *ItaniumPartialDemangler::finishDemangle(char *Buf, size_t *N) const {
  assert(RootNode != nullptr && "must call partialDemangle()");
  return printNode(static_cast<Node *>(RootNode), Buf, N);
}

char *ItaniumPartialDemangler::finishDemangle(void *OB) const {
  assert(RootNode != nullptr && "must call partialDemangle()");
  assert(OB != nullptr && "valid OutputBuffer argument required");
  return printNode(static_cast<Node *>(RootNode),
                   *static_cast<OutputBuffer *>(OB),
                   /*N=*/nullptr);
}

bool ItaniumPartialDemangler::hasFunctionQualifiers() const {
  assert(RootNode != nullptr && "must call partialDemangle()");
  if (!isFunction())
    return false;
  auto *E = static_cast<const FunctionEncoding *>(RootNode);
  return E->getCVQuals() != QualNone || E->getRefQual() != FrefQualNone;
}

bool ItaniumPartialDemangler::isCtorOrDtor() const {
  const Node *N = static_cast<const Node *>(RootNode);
  while (N) {
    switch (N->getKind()) {
    default:
      return false;
    case Node::KCtorDtorName:
      return true;

    case Node::KAbiTagAttr:
      N = static_cast<const AbiTagAttr *>(N)->Base;
      break;
    case Node::KFunctionEncoding:
      N = static_cast<const FunctionEncoding *>(N)->getName();
      break;
    case Node::KLocalName:
      N = static_cast<const LocalName *>(N)->Entity;
      break;
    case Node::KNameWithTemplateArgs:
      N = static_cast<const NameWithTemplateArgs *>(N)->Name;
      break;
    case Node::KNestedName:
      N = static_cast<const NestedName *>(N)->Name;
      break;
    case Node::KModuleEntity:
      N = static_cast<const ModuleEntity *>(N)->Name;
      break;
    }
  }
  return false;
}

bool ItaniumPartialDemangler::isFunction() const {
  assert(RootNode != nullptr && "must call partialDemangle()");
  return static_cast<const Node *>(RootNode)->getKind() ==
         Node::KFunctionEncoding;
}

bool ItaniumPartialDemangler::isSpecialName() const {
  assert(RootNode != nullptr && "must call partialDemangle()");
  auto K = static_cast<const Node *>(RootNode)->getKind();
  return K == Node::KSpecialName || K == Node::KCtorVtableSpecialName;
}

bool ItaniumPartialDemangler::isData() const {
  return !isFunction() && !isSpecialName();
}

```

`plugin/ios_stacktrace/Makefile`:

```
CXX = x86_64-w64-mingw32-g++

TARGET := ios_stacktrace_plugin.dll
SRC := ios_stacktrace_plugin.cpp

CPPFLAGS := -Ice_sdk
CXXFLAGS := -std=c++17 -O2
LDFLAGS := -shared -static -static-libgcc -static-libstdc++ -s

all: $(TARGET)

$(TARGET): $(SRC)
	$(CXX) $(CPPFLAGS) $(CXXFLAGS) $(LDFLAGS) -o $@ $^

clean:
	rm -f $(TARGET) *.o

.PHONY: all clean

```

`plugin/ios_stacktrace/ce_sdk/cepluginsdk.h`:

```h
/*
 cepluginsdk.h
 Updated July 4, 2017

 v5.0.0
*/
#ifndef CEPLUGINSDK_H
#define CEPLUGINSDK_H

#include <windows.h>
#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"


#define CESDK_VERSION 6

typedef enum {ptAddressList=0, ptMemoryView=1, ptOnDebugEvent=2, ptProcesswatcherEvent=3, ptFunctionPointerchange=4, ptMainMenu=5, ptDisassemblerContext=6, ptDisassemblerRenderLine=7, ptAutoAssembler=8} PluginType;
typedef enum {aaInitialize=0, aaPhase1=1, aaPhase2=2, aaFinalize=3} AutoAssemblerPhase;

typedef struct _PluginVersion
{
  unsigned int version; //write here the minimum version this dll is compatible with (Current supported version: 1 and 2: this SDK only describes 2)
  char *pluginname;  //make this point to a 0-terminated string (allocated memory or static addressin your dll, not stack)
} PluginVersion, *PPluginVersion;

typedef struct _PLUGINTYPE0_RECORD
{
  char *interpretedaddress; //pointer to a 255 bytes long string (0 terminated)
  UINT_PTR address;//this is a read-only representaion of the address. Change interpretedaddress if you want to change this
  BOOL ispointer; //readonly
  int countoffsets; //readonly
  ULONG *offsets; //array of dwords ranging from 0 to countoffsets-1 (readonly)
  char *description; //pointer to a 255 bytes long string
  char valuetype; //0=byte, 1=word, 2=dword, 3=float, 4=double, 5=bit, 6=int64, 7=string
  char size; //stringlength or bitlength;
} PLUGINTYPE0_RECORD, ADDRESSLIST_RECORD, *PPLUGINTYPE0_RECORD, *PADDRESSLIST_RECORD;

//callback routines efinitions for registered plugin functions:
typedef BOOL (__stdcall *CEP_PLUGINTYPE0)(PPLUGINTYPE0_RECORD SelectedRecord);
typedef BOOL (__stdcall *CEP_PLUGINTYPE1)(UINT_PTR *disassembleraddress, UINT_PTR *selected_disassembler_address, UINT_PTR *hexviewaddress);
typedef int (__stdcall *CEP_PLUGINTYPE2)(LPDEBUG_EVENT DebugEvent);
typedef void (__stdcall *CEP_PLUGINTYPE3)(ULONG processid, ULONG peprocess, BOOL Created);
typedef void (__stdcall *CEP_PLUGINTYPE4)(int reserved);
typedef void (__stdcall *CEP_PLUGINTYPE5)(void);
typedef BOOL (__stdcall *CEP_PLUGINTYPE6ONPOPUP)(UINT_PTR selectedAddress, char **addressofname, BOOL *show);
typedef BOOL (__stdcall *CEP_PLUGINTYPE6)(UINT_PTR *selectedAddress);
typedef void (__stdcall *CEP_PLUGINTYPE7)(UINT_PTR address, char **addressStringPointer, char **bytestringpointer, char **opcodestringpointer, char **specialstringpointer, ULONG *textcolor);
typedef void (__stdcall *CEP_PLUGINTYPE8)(char **line, AutoAssemblerPhase phase, int id);



typedef struct _PLUGINTYPE0_INIT
{
  char* name; //0 terminated string describing the name for the user's menu item
  CEP_PLUGINTYPE0 callbackroutine; //pointer to a callback routine of the type 0 plugin  
} PLUGINTYPE0_INIT, ADDRESSLISTPLUGIN_INIT, *PPLUGINTYPE0_INIT, *PADDRESSLISTPLUGIN_INIT;

typedef struct _PLUGINTYPE1_INIT
{
  char* name; //0 terminated string describing the name for the user's menu item
  CEP_PLUGINTYPE1 callbackroutine; //pointer to a callback routine of the type 1 plugin
  char* shortcut; //0 terminated string containing the shortcut in textform. CE will try it's best to parse it to a valid shortcut
} PLUGINTYPE1_INIT, MEMORYVIEWPLUGIN_INIT, *PPLUGINTYPE1_INIT, *PMEMORYVIEWPLUGIN_INIT;

typedef struct _PLUGINTYPE2_INIT
{
  CEP_PLUGINTYPE2 callbackroutine; //pointer to a callback routine of the type 2 plugin
} PLUGINTYPE2_INIT, DEBUGEVENTPLUGIN_INIT, *PPLUGINTYPE2_INIT, *PDEBUGEVENTPLUGIN_INIT;

typedef struct _PLUGINTYPE3_INIT
{
  CEP_PLUGINTYPE3 callbackroutine; //pointer to a callback routine of the type 3 plugin
} PLUGINTYPE3_INIT, PROCESSWATCHERPLUGIN_INIT, *PPLUGINTYPE3_INIT, *PPROCESSWATCHERPLUGIN_INIT;

typedef struct _PLUGINTYPE4_INIT
{
  CEP_PLUGINTYPE4 callbackroutine; //pointer to a callback routine of the type 4 plugin
} PLUGINTYPE4_INIT, POINTERREASSIGNMENTPLUGIN_INIT, *PPLUGINTYPE4_INIT, *PPOINTERREASSIGNMENTPLUGIN_INIT; 

typedef struct _PLUGINTYPE5_INIT
{
  char* name; //0 terminated string describing the name for the user's menu item
  CEP_PLUGINTYPE5 callbackroutine; 
  char* shortcut; //0 terminated string containing the shortcut in textform. CE will try it's best to parse it to a valid shortcut
} PLUGINTYPE5_INIT, MAINMENUPLUGIN_INIT, *PPLUGINTYPE5_INIT, *PMAINMENUPLUGIN_INIT;

typedef struct _PLUGINTYPE6_INIT
{
  char* name; //0 terminated string describing the name for the user's menu item
  CEP_PLUGINTYPE6 callbackroutine; 
  CEP_PLUGINTYPE6ONPOPUP callbackroutineOnPopup; 
  char* shortcut; //0 terminated string containing the shortcut in textform. CE will try it's best to parse it to a valid shortcut
} PLUGINTYPE6_INIT, DISASSEMBLERCONTEXT_INIT, *PPLUGINTYPE6_INIT, *PDISASSEMBLERCONTEXT_INIT;

typedef struct _PLUGINTYPE7_INIT
{
  CEP_PLUGINTYPE7 callbackroutine; //pointer to a callback routine of the type 7 plugin
} PLUGINTYPE7_INIT, DISASSEMBLERLINEPLUGIN_INIT, *PPLUGINTYPE7_INIT, *PDISASSEMBLERLINEPLUGIN_INIT; 

typedef struct _PLUGINTYPE8_INIT
{
  CEP_PLUGINTYPE8 callbackroutine; //pointer to a callback routine of the type 8 plugin
} PLUGINTYPE8_INIT, AUTOASSEMBLERPLUGIN_INIT, *PPLUGINTYPE8_INIT, *PAUTOASSEMBLERPLUGIN_INIT; 

typedef struct _REGISTERMODIFICATIONINFO
{
  UINT_PTR address; //addres to break on
  BOOL change_eax;
  BOOL change_ebx;
  BOOL change_ecx;
  BOOL change_edx;
  BOOL change_esi;
  BOOL change_edi;
  BOOL change_ebp;
  BOOL change_esp;
  BOOL change_eip;
#ifdef _AMD64_
  BOOL change_r8;
  BOOL change_r9;
  BOOL change_r10;
  BOOL change_r11;
  BOOL change_r12;
  BOOL change_r13;
  BOOL change_r14;
  BOOL change_r15;
#endif
  BOOL change_cf;
  BOOL change_pf;
  BOOL change_af;
  BOOL change_zf;
  BOOL change_sf;
  BOOL change_of;
  UINT_PTR new_eax;
  UINT_PTR new_ebx;
  UINT_PTR new_ecx;
  UINT_PTR new_edx;
  UINT_PTR new_esi;
  UINT_PTR new_edi;
  UINT_PTR new_ebp;
  UINT_PTR new_esp;
  UINT_PTR new_eip;
#ifdef _AMD64_
  UINT_PTR new_r8;
  UINT_PTR new_r9;
  UINT_PTR new_r10;
  UINT_PTR new_r11;
  UINT_PTR new_r12;
  UINT_PTR new_r13;
  UINT_PTR new_r14;
  UINT_PTR new_r15;
#endif
	 

  BOOL new_cf;
  BOOL new_pf;
  BOOL new_af;
  BOOL new_zf;
  BOOL new_sf;
  BOOL new_of;
} REGISTERMODIFICATIONINFO, *PREGISTERMODIFICATIONINFO;

//the __stdcall stuff isn't really needed since I've set compiler options to force stdcall, but this makes it clear that stdcall is used to the reader
typedef void (__stdcall *CEP_SHOWMESSAGE)(char* message);
typedef int (__stdcall *CEP_REGISTERFUNCTION) (int pluginid, PluginType functiontype, PVOID init);
typedef BOOL (__stdcall *CEP_UNREGISTERFUNCTION) (int pluginid, int functionid);
typedef HANDLE (__stdcall *CEP_GETMAINWINDOWHANDLE) (void);
typedef BOOL (__stdcall *CEP_AUTOASSEMBLE) (char *script);
typedef BOOL (__stdcall *CEP_ASSEMBLER) (UINT_PTR address, char* instruction, BYTE *output, int maxlength, int *returnedsize);
typedef BOOL (__stdcall *CEP_DISASSEMBLER) (UINT_PTR address, char* output, int maxsize);
typedef BOOL (__stdcall *CEP_CHANGEREGATADDRESS) (UINT_PTR address,PREGISTERMODIFICATIONINFO changereg);
typedef BOOL (__stdcall *CEP_INJECTDLL) (char *dllname, char *functiontocall);
typedef int (__stdcall *CEP_FREEZEMEM) (UINT_PTR address, int size);
typedef BOOL (__stdcall *CEP_UNFREEZEMEM) (int freezeID);
typedef BOOL (__stdcall *CEP_FIXMEM) (void);
typedef BOOL (__stdcall *CEP_PROCESSLIST) (char *listbuffer, int listsize);
typedef BOOL (__stdcall *CEP_RELOADSETTINGS) (void);
typedef UINT_PTR (__stdcall *CEP_GETADDRESSFROMPOINTER) (UINT_PTR baseaddress, int offsetcount, int* offsets);  
typedef BOOL (__stdcall *CEP_GENERATEAPIHOOKSCRIPT) (char *address, char *addresstojumpto, char *addresstogetnewcalladdress, char *script, int maxscriptsize);
typedef BOOL (__stdcall *CEP_ADDRESSTONAME) (UINT_PTR address, char *name, int maxnamesize);
typedef BOOL (__stdcall *CEP_NAMETOADDRESS) (char *name, UINT_PTR *address);

typedef VOID (__stdcall *CEP_LOADDBK32)(void);
typedef BOOL (__stdcall *CEP_LOADDBVMIFNEEDED)(void);
typedef DWORD (__stdcall *CEP_PREVIOUSOPCODE)(UINT_PTR address);
typedef DWORD (__stdcall *CEP_NEXTOPCODE)(UINT_PTR address);
typedef BOOL (__stdcall *CEP_LOADMODULE)(char *modulepath, char *exportlist, int *maxsize);
typedef BOOL (__stdcall *CEP_DISASSEMBLEEX)(UINT_PTR address, char *output, int maxsize);
typedef VOID (__stdcall *CEP_AA_ADDCOMMAND)(char *command);
typedef VOID (__stdcall *CEP_AA_DELCOMMAND)(char *command);

typedef PVOID (__stdcall *CEP_CREATETABLEENTRY)(void);
typedef PVOID (__stdcall *CEP_GETTABLEENTRY)(char *description);
typedef BOOL (__stdcall *CEP_MEMREC_SETDESCRIPTION)(PVOID memrec, char *description);
typedef PCHAR (__stdcall *CEP_MEMREC_GETDESCRIPTION)(PVOID memrec);
typedef BOOL (__stdcall *CEP_MEMREC_GETADDRESS)(PVOID memrec, UINT_PTR *address, DWORD *offsets, int maxoffsets, int *neededOffsets);
typedef BOOL (__stdcall *CEP_MEMREC_SETADDRESS)(PVOID memrec, char *address, DWORD *offsets, int offsetcount);
typedef int (__stdcall *CEP_MEMREC_GETTYPE)(PVOID memrec);
typedef BOOL (__stdcall *CEP_MEMREC_SETTYPE)(PVOID memrec, int vtype);
typedef BOOL (__stdcall *CEP_MEMREC_GETVALUETYPE)(PVOID memrec, char *value, int maxsize);
typedef BOOL (__stdcall *CEP_MEMREC_SETVALUETYPE)(PVOID memrec, char *value);
typedef char* (__stdcall *CEP_MEMREC_GETSCRIPT)(PVOID memrec);
typedef BOOL (__stdcall *CEP_MEMREC_SETSCRIPT)(PVOID memrec, char *script);
typedef BOOL (__stdcall *CEP_MEMREC_ISFROZEN)(PVOID memrec);
typedef BOOL (__stdcall *CEP_MEMREC_FREEZE)(PVOID memrec, int direction);
typedef BOOL (__stdcall *CEP_MEMREC_UNFREEZE)(PVOID memrec);
typedef BOOL (__stdcall *CEP_MEMREC_SETCOLOR)(PVOID memrec, DWORD color);
typedef BOOL (__stdcall *CEP_MEMREC_APPENDTOENTRY)(PVOID memrec1, PVOID memrec2);
typedef BOOL (__stdcall *CEP_MEMREC_DELETE)(PVOID memrec);

typedef DWORD (__stdcall *CEP_GETPROCESSIDFROMPROCESSNAME)(char *name);
typedef DWORD (__stdcall *CEP_OPENPROCESS)(DWORD pid);
typedef DWORD (__stdcall *CEP_DEBUGPROCESS)(int debuggerinterface);
typedef VOID (__stdcall *CEP_PAUSE)(void);
typedef VOID (__stdcall *CEP_UNPAUSE)(void);
typedef BOOL (__stdcall *CEP_DEBUG_SETBREAKPOINT)(UINT_PTR address, int size, int trigger);
typedef BOOL (__stdcall *CEP_DEBUG_REMOVEBREAKPOINT)(UINT_PTR address);
typedef BOOL (__stdcall *CEP_DEBUG_CONTINUEFROMBREAKPOINT)(int continueoption);

typedef VOID (__stdcall *CEP_CLOSECE)(void);
typedef VOID (__stdcall *CEP_HIDEALLCEWINDOWS)(void);
typedef VOID (__stdcall *CEP_UNHIDEMAINCEWINDOW)(void);

typedef PVOID (__stdcall *CEP_CREATEFORM)(void);
typedef void (__stdcall *CEP_FORM_CENTERSCREEN)(PVOID form);
typedef void (__stdcall *CEP_FORM_HIDE)(PVOID form);
typedef void (__stdcall *CEP_FORM_SHOW)(PVOID form);
typedef void (__stdcall *CEP_FORM_ONCLOSE)(PVOID form, PVOID function);

typedef PVOID (__stdcall *CEP_CREATEPANEL)(PVOID owner);
typedef PVOID (__stdcall *CEP_CREATEGROUPBOX)(PVOID owner);
typedef PVOID (__stdcall *CEP_CREATEBUTTON)(PVOID owner);
typedef PVOID (__stdcall *CEP_CREATEIMAGE)(PVOID owner);

typedef BOOL (__stdcall *CEP_IMAGE_LOADIMAGEFROMFILE)(PVOID image, char *filename);
typedef VOID (__stdcall *CEP_IMAGE_TRANSPARENT)(PVOID image, BOOL transparent);
typedef VOID (__stdcall *CEP_IMAGE_STRETCH)(PVOID image, BOOL stretch);

typedef PVOID (__stdcall *CEP_CREATELABEL)(PVOID owner);
typedef PVOID (__stdcall *CEP_CREATEEDIT)(PVOID owner);
typedef PVOID (__stdcall *CEP_CREATEMEMO)(PVOID owner);
typedef PVOID (__stdcall *CEP_CREATETIMER)(PVOID owner);

typedef VOID (__stdcall *CEP_TIMER_SETINTERVAL)(PVOID timer, int interval);
typedef VOID (__stdcall *CEP_TIMER_ONTIMER)(PVOID timer, PVOID function);

typedef VOID (__stdcall *CEP_CONTROL_SETCAPTION)(PVOID control, char *caption);
typedef BOOL (__stdcall *CEP_CONTROL_GETCAPTION)(PVOID control, char *caption, int maxsize);

typedef VOID (__stdcall *CEP_CONTROL_SETPOSITION)(PVOID control, int x, int y);
typedef int (__stdcall *CEP_CONTROL_GETX)(PVOID control);
typedef int (__stdcall *CEP_CONTROL_GETY)(PVOID control);

typedef VOID (__stdcall *CEP_CONTROL_SETSIZE)(PVOID control, int width, int height);
typedef int (__stdcall *CEP_CONTROL_GETWIDTH)(PVOID control);
typedef int (__stdcall *CEP_CONTROL_GETHEIGHT)(PVOID control);

typedef VOID (__stdcall *CEP_CONTROL_SETALIGN)(PVOID control, int align);
typedef VOID (__stdcall *CEP_CONTROL_ONCLICK)(PVOID control, PVOID function);

typedef VOID (__stdcall *CEP_OBJECT_DESTROY)(PVOID object);

typedef int (__stdcall *CEP_MESSAGEDIALOG)(char *massage, int messagetype, int buttoncombination);
typedef BOOL (__stdcall *CEP_SPEEDHACK_SETSPEED)(float speed);
typedef lua_State *(__fastcall *CEP_GETLUASTATE)();


typedef BOOL(__stdcall **CEP_READPROCESSMEMORY)(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T * lpNumberOfBytesRead);

/*
function ce_messageDialog(message: pchar; messagetype: integer; buttoncombination: integer): integer; stdcall;
function ce_speedhack_setSpeed(speed: single): BOOL; stdcall;       
*/

typedef struct _ExportedFunctions
{
  int sizeofExportedFunctions;
  CEP_SHOWMESSAGE ShowMessage; //Pointer to the ce showmessage function
  CEP_REGISTERFUNCTION RegisterFunction; //Use this to register a specific type of plugin
  CEP_UNREGISTERFUNCTION UnregisterFunction; //unregisters a function registered with registerfunction
  PULONG OpenedProcessID; //pointer to the currently selected processid
  PHANDLE OpenedProcessHandle; //pointer to the currently selected processhandle

  CEP_GETMAINWINDOWHANDLE GetMainWindowHandle; //returns the handle of the main window (for whatever reason, it is recommended to use delphi to make a real userinterface upgrade)
  CEP_AUTOASSEMBLE AutoAssemble; //Pointer to the AutoAssemble function
  CEP_ASSEMBLER Assembler; //pointer to the assembler function
  CEP_DISASSEMBLER Disassembler; //pointer to the disassembler function
  CEP_CHANGEREGATADDRESS ChangeRegistersAtAddress; //pointer to the ChangeRegAtBP function
  CEP_INJECTDLL InjectDLL; //pointer to ce's Inject DLL function
  CEP_FREEZEMEM FreezeMem; //pointer to the FreezeMem routine
  CEP_UNFREEZEMEM UnfreezeMem; //pointer to the UnfreezeMem routine (use this to undo freezes with FreezeMem)
  CEP_FIXMEM FixMem; //pointer to the fixmem routine
  CEP_PROCESSLIST ProcessList; //pointer to the processlist routine
  CEP_RELOADSETTINGS ReloadSettings; //pointer to the ReloadSettings routine
  CEP_GETADDRESSFROMPOINTER GetAddressFromPointer; //pointer to the GetAddressFromPointer routine

  //pointers to the address that contains the pointers to the functions
  //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  CEP_READPROCESSMEMORY ReadProcessMemory;			//pointer to the pointer of ReadProcessMemory (Change it to hook that api, or use it yourself)
  PVOID WriteProcessMemory;			//pointer to the pointer of WriteProcessMemory (Change it to hook that api, or use it yourself)
  PVOID GetThreadContext;			//   ...
  PVOID SetThreadContext;			//   ...
  PVOID SuspendThread;				//   ...
  PVOID ResumeThread;				//   ...
  PVOID OpenProcess;				//   ...
  PVOID WaitForDebugEvent;			//   ...
  PVOID ContinueDebugEvent;			//   ...
  PVOID DebugActiveProcess;			//   ...
  PVOID StopDebugging;				//   ...
  PVOID StopRegisterChange;			//   ...
  PVOID VirtualProtect;				//   ...
  PVOID VirtualProtectEx;			//   ...
  PVOID VirtualQueryEx;				//   ...
  PVOID VirtualAllocEx;				//   ...
  PVOID CreateRemoteThread;			//   ...
  PVOID OpenThread;					//   ...
  PVOID GetPEProcess;				//   ...
  PVOID GetPEThread;				//   ...
  PVOID GetThreadsProcessOffset;	//   ...
  PVOID GetThreadListEntryOffset;	//   ...
  PVOID GetProcessnameOffset;		//   ...
  PVOID GetDebugportOffset;			//   ...
  PVOID GetPhysicalAddress;			//   ...
  PVOID ProtectMe;					//   ...
  PVOID GetCR4;						//   ...
  PVOID GetCR3;						//   ...
  PVOID SetCR3;						//   ...
  PVOID GetSDT;						//   ...
  PVOID GetSDTShadow;				//   ...
  PVOID setAlternateDebugMethod;	//   ...
  PVOID getAlternateDebugMethod;	//   ...
  PVOID DebugProcess;				//   ...
  PVOID ChangeRegOnBP;				//   ...
  PVOID RetrieveDebugData;			//   ...
  PVOID StartProcessWatch;			//   ...
  PVOID WaitForProcessListData;		//   ...
  PVOID GetProcessNameFromID;		//   ...
  PVOID GetProcessNameFromPEProcess;//   ...
  PVOID KernelOpenProcess;			//   ...
  PVOID KernelReadProcessMemory;	//   ...
  PVOID KernelWriteProcessMemory;	//   ...
  PVOID KernelVirtualAllocEx;		//   ...
  PVOID IsValidHandle;				//   ...
  PVOID GetIDTCurrentThread;		//   ...
  PVOID GetIDTs;					//   ...
  PVOID MakeWritable;				//   ...
  PVOID GetLoadedState;				//   ...
  PVOID DBKSuspendThread;			//   ...
  PVOID DBKResumeThread;			//   ...
  PVOID DBKSuspendProcess;			//   ...
  PVOID DBKResumeProcess;			//   ...
  PVOID KernelAlloc;				//   ...
  PVOID GetKProcAddress;			//   ...
  PVOID CreateToolhelp32Snapshot;	//   ...
  PVOID Process32First;          	//   ...
  PVOID Process32Next;           	//   ...
  PVOID Thread32First;           	//   ...
  PVOID Thread32Next;            	//   ...
  PVOID Module32First;           	//   ...
  PVOID Module32Next;            	//   ...
  PVOID Heap32ListFirst;         	//   ...
  PVOID Heap32ListNext;          	//   ...
  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

  //advanced for delphi 7 enterprise dll programmers only
  PVOID mainform; //pointer to the Tmainform object.
  PVOID memorybrowser; //pointer to the TMemoryBrowser object (memory view windows), same as mainform

  //Plugin Version 2+
  CEP_NAMETOADDRESS sym_nameToAddress;
  CEP_ADDRESSTONAME sym_addressToName;
  CEP_GENERATEAPIHOOKSCRIPT sym_generateAPIHookScript;

  //Plugin version 3+
  CEP_LOADDBK32 loadDBK32;
  CEP_LOADDBVMIFNEEDED loaddbvmifneeded;
  CEP_PREVIOUSOPCODE previousOpcode;
  CEP_NEXTOPCODE nextOpcode;
  CEP_DISASSEMBLEEX disassembleEx;
  CEP_LOADMODULE loadModule;
  CEP_AA_ADDCOMMAND aa_AddExtraCommand;
  CEP_AA_DELCOMMAND aa_RemoveExtraCommand;

  //version 4 extension
  CEP_CREATETABLEENTRY createTableEntry;
  CEP_GETTABLEENTRY getTableEntry;
  CEP_MEMREC_SETDESCRIPTION memrec_setDescription;
  CEP_MEMREC_GETDESCRIPTION memrec_getDescription;
  CEP_MEMREC_GETADDRESS memrec_getAddress;
  CEP_MEMREC_SETADDRESS memrec_setAddress;
  CEP_MEMREC_GETTYPE memrec_getType;
  CEP_MEMREC_SETTYPE memrec_setType;
  CEP_MEMREC_GETVALUETYPE memrec_getValue;
  CEP_MEMREC_SETVALUETYPE memrec_setValue;
  CEP_MEMREC_GETSCRIPT memrec_getScript;
  CEP_MEMREC_SETSCRIPT memrec_setScript;
  CEP_MEMREC_ISFROZEN memrec_isfrozen;
  CEP_MEMREC_FREEZE memrec_freeze;
  CEP_MEMREC_UNFREEZE memrec_unfreeze;
  CEP_MEMREC_SETCOLOR memrec_setColor;
  CEP_MEMREC_APPENDTOENTRY memrec_appendtoentry;
  CEP_MEMREC_DELETE memrec_delete;

  CEP_GETPROCESSIDFROMPROCESSNAME getProcessIDFromProcessName;
  CEP_OPENPROCESS openProcessEx;
  CEP_DEBUGPROCESS debugProcessEx;
  CEP_PAUSE pause;
  CEP_UNPAUSE unpause;

  CEP_DEBUG_SETBREAKPOINT debug_setBreakpoint;
  CEP_DEBUG_REMOVEBREAKPOINT debug_removeBreakpoint;
  CEP_DEBUG_CONTINUEFROMBREAKPOINT debug_continueFromBreakpoint;

  CEP_CLOSECE closeCE;
  CEP_HIDEALLCEWINDOWS hideAllCEWindows;
  CEP_UNHIDEMAINCEWINDOW unhideMainCEwindow;
  CEP_CREATEFORM createForm;
  CEP_FORM_CENTERSCREEN form_centerScreen;
  CEP_FORM_HIDE form_hide;
  CEP_FORM_SHOW form_show;
  CEP_FORM_ONCLOSE form_onClose;

  CEP_CREATEPANEL createPanel;
  CEP_CREATEGROUPBOX createGroupBox;
  CEP_CREATEBUTTON createButton;
  CEP_CREATEIMAGE createImage;
  CEP_IMAGE_LOADIMAGEFROMFILE image_loadImageFromFile;
  CEP_IMAGE_TRANSPARENT image_transparent;
  CEP_IMAGE_STRETCH image_stretch;

  CEP_CREATELABEL createLabel;
  CEP_CREATEEDIT createEdit;
  CEP_CREATEMEMO createMemo;
  CEP_CREATETIMER createTimer;
  CEP_TIMER_SETINTERVAL timer_setInterval;
  CEP_TIMER_ONTIMER timer_onTimer;
  CEP_CONTROL_SETCAPTION control_setCaption;
  CEP_CONTROL_GETCAPTION control_getCaption;
  CEP_CONTROL_SETPOSITION control_setPosition;
  CEP_CONTROL_GETX control_getX;
  CEP_CONTROL_GETY control_getY;
  CEP_CONTROL_SETSIZE control_setSize;
  CEP_CONTROL_GETWIDTH control_getWidth;
  CEP_CONTROL_GETHEIGHT control_getHeight;
  CEP_CONTROL_SETALIGN control_setAlign;
  CEP_CONTROL_ONCLICK control_onClick;

  CEP_OBJECT_DESTROY object_destroy;
  CEP_MESSAGEDIALOG messageDialog;
  CEP_SPEEDHACK_SETSPEED speedhack_setSpeed;  

//V5: Todo, implement function declarations
  VOID *ExecuteKernelCode;
  VOID *UserdefinedInterruptHook;
  CEP_GETLUASTATE GetLuaState;
  VOID *MainThreadCall;

} ExportedFunctions, *PExportedFunctions;


BOOL __stdcall CEPlugin_GetVersion(PPluginVersion pv , int sizeofpluginversion);
BOOL __stdcall CEPlugin_InitializePlugin(PExportedFunctions ef , int pluginid);
BOOL __stdcall CEPlugin_DisablePlugin(void);
//old versions without CEPlugin_ in front also work but are not recommended due to bugbrained compilers...


#endif //CEPLUGINSDK_H

```

`plugin/ios_stacktrace/ce_sdk/lauxlib.h`:

```h
/*
** $Id: lauxlib.h,v 1.128 2014/10/29 16:11:17 roberto Exp $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/


#ifndef lauxlib_h
#define lauxlib_h


#include <stddef.h>
#include <stdio.h>

#include "lua.h"



/* extra error code for 'luaL_load' */
#define LUA_ERRFILE     (LUA_ERRERR+1)


typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;


#define LUAL_NUMSIZES	(sizeof(lua_Integer)*16 + sizeof(lua_Number))

LUALIB_API void (luaL_checkversion_) (lua_State *L, lua_Number ver, size_t sz);
#define luaL_checkversion(L)  \
	  luaL_checkversion_(L, LUA_VERSION_NUM, LUAL_NUMSIZES)

LUALIB_API int (luaL_getmetafield) (lua_State *L, int obj, const char *e);
LUALIB_API int (luaL_callmeta) (lua_State *L, int obj, const char *e);
LUALIB_API const char *(luaL_tolstring) (lua_State *L, int idx, size_t *len);
LUALIB_API int (luaL_argerror) (lua_State *L, int arg, const char *extramsg);
LUALIB_API const char *(luaL_checklstring) (lua_State *L, int arg,
                                                          size_t *l);
LUALIB_API const char *(luaL_optlstring) (lua_State *L, int arg,
                                          const char *def, size_t *l);
LUALIB_API lua_Number (luaL_checknumber) (lua_State *L, int arg);
LUALIB_API lua_Number (luaL_optnumber) (lua_State *L, int arg, lua_Number def);

LUALIB_API lua_Integer (luaL_checkinteger) (lua_State *L, int arg);
LUALIB_API lua_Integer (luaL_optinteger) (lua_State *L, int arg,
                                          lua_Integer def);

LUALIB_API void (luaL_checkstack) (lua_State *L, int sz, const char *msg);
LUALIB_API void (luaL_checktype) (lua_State *L, int arg, int t);
LUALIB_API void (luaL_checkany) (lua_State *L, int arg);

LUALIB_API int   (luaL_newmetatable) (lua_State *L, const char *tname);
LUALIB_API void  (luaL_setmetatable) (lua_State *L, const char *tname);
LUALIB_API void *(luaL_testudata) (lua_State *L, int ud, const char *tname);
LUALIB_API void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);

LUALIB_API void (luaL_where) (lua_State *L, int lvl);
LUALIB_API int (luaL_error) (lua_State *L, const char *fmt, ...);

LUALIB_API int (luaL_checkoption) (lua_State *L, int arg, const char *def,
                                   const char *const lst[]);

LUALIB_API int (luaL_fileresult) (lua_State *L, int stat, const char *fname);
LUALIB_API int (luaL_execresult) (lua_State *L, int stat);

/* pre-defined references */
#define LUA_NOREF       (-2)
#define LUA_REFNIL      (-1)

LUALIB_API int (luaL_ref) (lua_State *L, int t);
LUALIB_API void (luaL_unref) (lua_State *L, int t, int ref);

LUALIB_API int (luaL_loadfilex) (lua_State *L, const char *filename,
                                               const char *mode);

#define luaL_loadfile(L,f)	luaL_loadfilex(L,f,NULL)

LUALIB_API int (luaL_loadbufferx) (lua_State *L, const char *buff, size_t sz,
                                   const char *name, const char *mode);
LUALIB_API int (luaL_loadstring) (lua_State *L, const char *s);

LUALIB_API lua_State *(luaL_newstate) (void);

LUALIB_API lua_Integer (luaL_len) (lua_State *L, int idx);

LUALIB_API const char *(luaL_gsub) (lua_State *L, const char *s, const char *p,
                                                  const char *r);

LUALIB_API void (luaL_setfuncs) (lua_State *L, const luaL_Reg *l, int nup);

LUALIB_API int (luaL_getsubtable) (lua_State *L, int idx, const char *fname);

LUALIB_API void (luaL_traceback) (lua_State *L, lua_State *L1,
                                  const char *msg, int level);

LUALIB_API void (luaL_requiref) (lua_State *L, const char *modname,
                                 lua_CFunction openf, int glb);

/*
** ===============================================================
** some useful macros
** ===============================================================
*/


#define luaL_newlibtable(L,l)	\
  lua_createtable(L, 0, sizeof(l)/sizeof((l)[0]) - 1)

#define luaL_newlib(L,l)  \
  (luaL_checkversion(L), luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))

#define luaL_argcheck(L, cond,arg,extramsg)	\
		((void)((cond) || luaL_argerror(L, (arg), (extramsg))))
#define luaL_checkstring(L,n)	(luaL_checklstring(L, (n), NULL))
#define luaL_optstring(L,n,d)	(luaL_optlstring(L, (n), (d), NULL))

#define luaL_typename(L,i)	lua_typename(L, lua_type(L,(i)))

#define luaL_dofile(L, fn) \
	(luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))

#define luaL_dostring(L, s) \
	(luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))

#define luaL_getmetatable(L,n)	(lua_getfield(L, LUA_REGISTRYINDEX, (n)))

#define luaL_opt(L,f,n,d)	(lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))

#define luaL_loadbuffer(L,s,sz,n)	luaL_loadbufferx(L,s,sz,n,NULL)


/*
** {======================================================
** Generic Buffer manipulation
** =======================================================
*/

typedef struct luaL_Buffer {
  char *b;  /* buffer address */
  size_t size;  /* buffer size */
  size_t n;  /* number of characters in buffer */
  lua_State *L;
  char initb[LUAL_BUFFERSIZE];  /* initial buffer */
} luaL_Buffer;


#define luaL_addchar(B,c) \
  ((void)((B)->n < (B)->size || luaL_prepbuffsize((B), 1)), \
   ((B)->b[(B)->n++] = (c)))

#define luaL_addsize(B,s)	((B)->n += (s))

LUALIB_API void (luaL_buffinit) (lua_State *L, luaL_Buffer *B);
LUALIB_API char *(luaL_prepbuffsize) (luaL_Buffer *B, size_t sz);
LUALIB_API void (luaL_addlstring) (luaL_Buffer *B, const char *s, size_t l);
LUALIB_API void (luaL_addstring) (luaL_Buffer *B, const char *s);
LUALIB_API void (luaL_addvalue) (luaL_Buffer *B);
LUALIB_API void (luaL_pushresult) (luaL_Buffer *B);
LUALIB_API void (luaL_pushresultsize) (luaL_Buffer *B, size_t sz);
LUALIB_API char *(luaL_buffinitsize) (lua_State *L, luaL_Buffer *B, size_t sz);

#define luaL_prepbuffer(B)	luaL_prepbuffsize(B, LUAL_BUFFERSIZE)

/* }====================================================== */



/*
** {======================================================
** File handles for IO library
** =======================================================
*/

/*
** A file handle is a userdata with metatable 'LUA_FILEHANDLE' and
** initial structure 'luaL_Stream' (it may contain other fields
** after that initial structure).
*/

#define LUA_FILEHANDLE          "FILE*"


typedef struct luaL_Stream {
  FILE *f;  /* stream (NULL for incompletely created streams) */
  lua_CFunction closef;  /* to close stream (NULL for closed streams) */
} luaL_Stream;

/* }====================================================== */



/* compatibility with old module system */
#if defined(LUA_COMPAT_MODULE)

LUALIB_API void (luaL_pushmodule) (lua_State *L, const char *modname,
                                   int sizehint);
LUALIB_API void (luaL_openlib) (lua_State *L, const char *libname,
                                const luaL_Reg *l, int nup);

#define luaL_register(L,n,l)	(luaL_openlib(L,(n),(l),0))

#endif


/*
** {==================================================================
** "Abstraction Layer" for basic report of messages and errors
** ===================================================================
*/

/* print a string */
#if !defined(lua_writestring)
#define lua_writestring(s,l)   fwrite((s), sizeof(char), (l), stdout)
#endif

/* print a newline and flush the output */
#if !defined(lua_writeline)
#define lua_writeline()        (lua_writestring("\n", 1), fflush(stdout))
#endif

/* print an error message */
#if !defined(lua_writestringerror)
#define lua_writestringerror(s,p) \
        (fprintf(stderr, (s), (p)), fflush(stderr))
#endif

/* }================================================================== */


/*
** {============================================================
** Compatibility with deprecated conversions
** =============================================================
*/
#if defined(LUA_COMPAT_APIINTCASTS)

#define luaL_checkunsigned(L,a)	((lua_Unsigned)luaL_checkinteger(L,a))
#define luaL_optunsigned(L,a,d)	\
	((lua_Unsigned)luaL_optinteger(L,a,(lua_Integer)(d)))

#define luaL_checkint(L,n)	((int)luaL_checkinteger(L, (n)))
#define luaL_optint(L,n,d)	((int)luaL_optinteger(L, (n), (d)))

#define luaL_checklong(L,n)	((long)luaL_checkinteger(L, (n)))
#define luaL_optlong(L,n,d)	((long)luaL_optinteger(L, (n), (d)))

#endif
/* }============================================================ */



#endif



```

`plugin/ios_stacktrace/ce_sdk/lua.h`:

```h
/*
** $Id: lua.h,v 1.325 2014/12/26 17:24:27 roberto Exp $
** Lua - A Scripting Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/


#ifndef lua_h
#define lua_h

#include <stdarg.h>
#include <stddef.h>


#include "luaconf.h"


#define LUA_VERSION_MAJOR	"5"
#define LUA_VERSION_MINOR	"3"
#define LUA_VERSION_NUM		503
#define LUA_VERSION_RELEASE	"0"

#define LUA_VERSION	"Lua " LUA_VERSION_MAJOR "." LUA_VERSION_MINOR
#define LUA_RELEASE	LUA_VERSION "." LUA_VERSION_RELEASE
#define LUA_COPYRIGHT	LUA_RELEASE "  Copyright (C) 1994-2015 Lua.org, PUC-Rio"
#define LUA_AUTHORS	"R. Ierusalimschy, L. H. de Figueiredo, W. Celes"


/* mark for precompiled code ('<esc>Lua') */
#define LUA_SIGNATURE	"\x1bLua"

/* option for multiple returns in 'lua_pcall' and 'lua_call' */
#define LUA_MULTRET	(-1)


/*
** pseudo-indices
*/
#define LUA_REGISTRYINDEX	LUAI_FIRSTPSEUDOIDX
#define lua_upvalueindex(i)	(LUA_REGISTRYINDEX - (i))


/* thread status */
#define LUA_OK		0
#define LUA_YIELD	1
#define LUA_ERRRUN	2
#define LUA_ERRSYNTAX	3
#define LUA_ERRMEM	4
#define LUA_ERRGCMM	5
#define LUA_ERRERR	6


typedef struct lua_State lua_State;


/*
** basic types
*/
#define LUA_TNONE		(-1)

#define LUA_TNIL		0
#define LUA_TBOOLEAN		1
#define LUA_TLIGHTUSERDATA	2
#define LUA_TNUMBER		3
#define LUA_TSTRING		4
#define LUA_TTABLE		5
#define LUA_TFUNCTION		6
#define LUA_TUSERDATA		7
#define LUA_TTHREAD		8

#define LUA_NUMTAGS		9



/* minimum Lua stack available to a C function */
#define LUA_MINSTACK	20


/* predefined values in the registry */
#define LUA_RIDX_MAINTHREAD	1
#define LUA_RIDX_GLOBALS	2
#define LUA_RIDX_LAST		LUA_RIDX_GLOBALS


/* type of numbers in Lua */
typedef LUA_NUMBER lua_Number;


/* type for integer functions */
typedef LUA_INTEGER lua_Integer;

/* unsigned integer type */
typedef LUA_UNSIGNED lua_Unsigned;

/* type for continuation-function contexts */
typedef LUA_KCONTEXT lua_KContext;


/*
** Type for C functions registered with Lua
*/
typedef int (*lua_CFunction) (lua_State *L);

/*
** Type for continuation functions
*/
typedef int (*lua_KFunction) (lua_State *L, int status, lua_KContext ctx);


/*
** Type for functions that read/write blocks when loading/dumping Lua chunks
*/
typedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);

typedef int (*lua_Writer) (lua_State *L, const void *p, size_t sz, void *ud);


/*
** Type for memory-allocation functions
*/
typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);



/*
** generic extra include file
*/
#if defined(LUA_USER_H)
#include LUA_USER_H
#endif


/*
** RCS ident string
*/
extern const char lua_ident[];


/*
** state manipulation
*/
LUA_API lua_State *(lua_newstate) (lua_Alloc f, void *ud);
LUA_API void       (lua_close) (lua_State *L);
LUA_API lua_State *(lua_newthread) (lua_State *L);

LUA_API lua_CFunction (lua_atpanic) (lua_State *L, lua_CFunction panicf);


LUA_API const lua_Number *(lua_version) (lua_State *L);


/*
** basic stack manipulation
*/
LUA_API int   (lua_absindex) (lua_State *L, int idx);
LUA_API int   (lua_gettop) (lua_State *L);
LUA_API void  (lua_settop) (lua_State *L, int idx);
LUA_API void  (lua_pushvalue) (lua_State *L, int idx);
LUA_API void  (lua_rotate) (lua_State *L, int idx, int n);
LUA_API void  (lua_copy) (lua_State *L, int fromidx, int toidx);
LUA_API int   (lua_checkstack) (lua_State *L, int n);

LUA_API void  (lua_xmove) (lua_State *from, lua_State *to, int n);


/*
** access functions (stack -> C)
*/

LUA_API int             (lua_isnumber) (lua_State *L, int idx);
LUA_API int             (lua_isstring) (lua_State *L, int idx);
LUA_API int             (lua_iscfunction) (lua_State *L, int idx);
LUA_API int             (lua_isinteger) (lua_State *L, int idx);
LUA_API int             (lua_isuserdata) (lua_State *L, int idx);
LUA_API int             (lua_type) (lua_State *L, int idx);
LUA_API const char     *(lua_typename) (lua_State *L, int tp);

LUA_API lua_Number      (lua_tonumberx) (lua_State *L, int idx, int *isnum);
LUA_API lua_Integer     (lua_tointegerx) (lua_State *L, int idx, int *isnum);
LUA_API int             (lua_toboolean) (lua_State *L, int idx);
LUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);
LUA_API size_t          (lua_rawlen) (lua_State *L, int idx);
LUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);
LUA_API void	       *(lua_touserdata) (lua_State *L, int idx);
LUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);
LUA_API const void     *(lua_topointer) (lua_State *L, int idx);


/*
** Comparison and arithmetic functions
*/

#define LUA_OPADD	0	/* ORDER TM, ORDER OP */
#define LUA_OPSUB	1
#define LUA_OPMUL	2
#define LUA_OPMOD	3
#define LUA_OPPOW	4
#define LUA_OPDIV	5
#define LUA_OPIDIV	6
#define LUA_OPBAND	7
#define LUA_OPBOR	8
#define LUA_OPBXOR	9
#define LUA_OPSHL	10
#define LUA_OPSHR	11
#define LUA_OPUNM	12
#define LUA_OPBNOT	13

LUA_API void  (lua_arith) (lua_State *L, int op);

#define LUA_OPEQ	0
#define LUA_OPLT	1
#define LUA_OPLE	2

LUA_API int   (lua_rawequal) (lua_State *L, int idx1, int idx2);
LUA_API int   (lua_compare) (lua_State *L, int idx1, int idx2, int op);


/*
** push functions (C -> stack)
*/
LUA_API void        (lua_pushnil) (lua_State *L);
LUA_API void        (lua_pushnumber) (lua_State *L, lua_Number n);
LUA_API void        (lua_pushinteger) (lua_State *L, lua_Integer n);
LUA_API const char *(lua_pushlstring) (lua_State *L, const char *s, size_t len);
LUA_API const char *(lua_pushstring) (lua_State *L, const char *s);
LUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt,
                                                      va_list argp);
LUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...);
LUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);
LUA_API void  (lua_pushboolean) (lua_State *L, int b);
LUA_API void  (lua_pushlightuserdata) (lua_State *L, void *p);
LUA_API int   (lua_pushthread) (lua_State *L);


/*
** get functions (Lua -> stack)
*/
LUA_API int (lua_getglobal) (lua_State *L, const char *name);
LUA_API int (lua_gettable) (lua_State *L, int idx);
LUA_API int (lua_getfield) (lua_State *L, int idx, const char *k);
LUA_API int (lua_geti) (lua_State *L, int idx, lua_Integer n);
LUA_API int (lua_rawget) (lua_State *L, int idx);
LUA_API int (lua_rawgeti) (lua_State *L, int idx, lua_Integer n);
LUA_API int (lua_rawgetp) (lua_State *L, int idx, const void *p);

LUA_API void  (lua_createtable) (lua_State *L, int narr, int nrec);
LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz);
LUA_API int   (lua_getmetatable) (lua_State *L, int objindex);
LUA_API int  (lua_getuservalue) (lua_State *L, int idx);


/*
** set functions (stack -> Lua)
*/
LUA_API void  (lua_setglobal) (lua_State *L, const char *name);
LUA_API void  (lua_settable) (lua_State *L, int idx);
LUA_API void  (lua_setfield) (lua_State *L, int idx, const char *k);
LUA_API void  (lua_seti) (lua_State *L, int idx, lua_Integer n);
LUA_API void  (lua_rawset) (lua_State *L, int idx);
LUA_API void  (lua_rawseti) (lua_State *L, int idx, lua_Integer n);
LUA_API void  (lua_rawsetp) (lua_State *L, int idx, const void *p);
LUA_API int   (lua_setmetatable) (lua_State *L, int objindex);
LUA_API void  (lua_setuservalue) (lua_State *L, int idx);


/*
** 'load' and 'call' functions (load and run Lua code)
*/
LUA_API void  (lua_callk) (lua_State *L, int nargs, int nresults,
                           lua_KContext ctx, lua_KFunction k);
#define lua_call(L,n,r)		lua_callk(L, (n), (r), 0, NULL)

LUA_API int   (lua_pcallk) (lua_State *L, int nargs, int nresults, int errfunc,
                            lua_KContext ctx, lua_KFunction k);
#define lua_pcall(L,n,r,f)	lua_pcallk(L, (n), (r), (f), 0, NULL)

LUA_API int   (lua_load) (lua_State *L, lua_Reader reader, void *dt,
                          const char *chunkname, const char *mode);

LUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data, int strip);


/*
** coroutine functions
*/
LUA_API int  (lua_yieldk)     (lua_State *L, int nresults, lua_KContext ctx,
                               lua_KFunction k);
LUA_API int  (lua_resume)     (lua_State *L, lua_State *from, int narg);
LUA_API int  (lua_status)     (lua_State *L);
LUA_API int (lua_isyieldable) (lua_State *L);

#define lua_yield(L,n)		lua_yieldk(L, (n), 0, NULL)


/*
** garbage-collection function and options
*/

#define LUA_GCSTOP		0
#define LUA_GCRESTART		1
#define LUA_GCCOLLECT		2
#define LUA_GCCOUNT		3
#define LUA_GCCOUNTB		4
#define LUA_GCSTEP		5
#define LUA_GCSETPAUSE		6
#define LUA_GCSETSTEPMUL	7
#define LUA_GCISRUNNING		9

LUA_API int (lua_gc) (lua_State *L, int what, int data);


/*
** miscellaneous functions
*/

LUA_API int   (lua_error) (lua_State *L);

LUA_API int   (lua_next) (lua_State *L, int idx);

LUA_API void  (lua_concat) (lua_State *L, int n);
LUA_API void  (lua_len)    (lua_State *L, int idx);

LUA_API size_t   (lua_stringtonumber) (lua_State *L, const char *s);

LUA_API lua_Alloc (lua_getallocf) (lua_State *L, void **ud);
LUA_API void      (lua_setallocf) (lua_State *L, lua_Alloc f, void *ud);



/*
** {==============================================================
** some useful macros
** ===============================================================
*/

#define lua_getextraspace(L)	((void *)((char *)(L) - LUA_EXTRASPACE))

#define lua_tonumber(L,i)	lua_tonumberx(L,(i),NULL)
#define lua_tointeger(L,i)	lua_tointegerx(L,(i),NULL)

#define lua_pop(L,n)		lua_settop(L, -(n)-1)

#define lua_newtable(L)		lua_createtable(L, 0, 0)

#define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))

#define lua_pushcfunction(L,f)	lua_pushcclosure(L, (f), 0)

#define lua_isfunction(L,n)	(lua_type(L, (n)) == LUA_TFUNCTION)
#define lua_istable(L,n)	(lua_type(L, (n)) == LUA_TTABLE)
#define lua_islightuserdata(L,n)	(lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
#define lua_isnil(L,n)		(lua_type(L, (n)) == LUA_TNIL)
#define lua_isboolean(L,n)	(lua_type(L, (n)) == LUA_TBOOLEAN)
#define lua_isthread(L,n)	(lua_type(L, (n)) == LUA_TTHREAD)
#define lua_isnone(L,n)		(lua_type(L, (n)) == LUA_TNONE)
#define lua_isnoneornil(L, n)	(lua_type(L, (n)) <= 0)

#define lua_pushliteral(L, s)	\
	lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)

#define lua_pushglobaltable(L)  \
	lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS)

#define lua_tostring(L,i)	lua_tolstring(L, (i), NULL)


#define lua_insert(L,idx)	lua_rotate(L, (idx), 1)

#define lua_remove(L,idx)	(lua_rotate(L, (idx), -1), lua_pop(L, 1))

#define lua_replace(L,idx)	(lua_copy(L, -1, (idx)), lua_pop(L, 1))

/* }============================================================== */


/*
** {==============================================================
** compatibility macros for unsigned conversions
** ===============================================================
*/
#if defined(LUA_COMPAT_APIINTCASTS)

#define lua_pushunsigned(L,n)	lua_pushinteger(L, (lua_Integer)(n))
#define lua_tounsignedx(L,i,is)	((lua_Unsigned)lua_tointegerx(L,i,is))
#define lua_tounsigned(L,i)	lua_tounsignedx(L,(i),NULL)

#endif
/* }============================================================== */

/*
** {======================================================================
** Debug API
** =======================================================================
*/


/*
** Event codes
*/
#define LUA_HOOKCALL	0
#define LUA_HOOKRET	1
#define LUA_HOOKLINE	2
#define LUA_HOOKCOUNT	3
#define LUA_HOOKTAILCALL 4


/*
** Event masks
*/
#define LUA_MASKCALL	(1 << LUA_HOOKCALL)
#define LUA_MASKRET	(1 << LUA_HOOKRET)
#define LUA_MASKLINE	(1 << LUA_HOOKLINE)
#define LUA_MASKCOUNT	(1 << LUA_HOOKCOUNT)

typedef struct lua_Debug lua_Debug;  /* activation record */


/* Functions to be called by the debugger in specific events */
typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);


LUA_API int (lua_getstack) (lua_State *L, int level, lua_Debug *ar);
LUA_API int (lua_getinfo) (lua_State *L, const char *what, lua_Debug *ar);
LUA_API const char *(lua_getlocal) (lua_State *L, const lua_Debug *ar, int n);
LUA_API const char *(lua_setlocal) (lua_State *L, const lua_Debug *ar, int n);
LUA_API const char *(lua_getupvalue) (lua_State *L, int funcindex, int n);
LUA_API const char *(lua_setupvalue) (lua_State *L, int funcindex, int n);

LUA_API void *(lua_upvalueid) (lua_State *L, int fidx, int n);
LUA_API void  (lua_upvaluejoin) (lua_State *L, int fidx1, int n1,
                                               int fidx2, int n2);

LUA_API void (lua_sethook) (lua_State *L, lua_Hook func, int mask, int count);
LUA_API lua_Hook (lua_gethook) (lua_State *L);
LUA_API int (lua_gethookmask) (lua_State *L);
LUA_API int (lua_gethookcount) (lua_State *L);


struct lua_Debug {
  int event;
  const char *name;	/* (n) */
  const char *namewhat;	/* (n) 'global', 'local', 'field', 'method' */
  const char *what;	/* (S) 'Lua', 'C', 'main', 'tail' */
  const char *source;	/* (S) */
  int currentline;	/* (l) */
  int linedefined;	/* (S) */
  int lastlinedefined;	/* (S) */
  unsigned char nups;	/* (u) number of upvalues */
  unsigned char nparams;/* (u) number of parameters */
  char isvararg;        /* (u) */
  char istailcall;	/* (t) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  struct CallInfo *i_ci;  /* active function */
};

/* }====================================================================== */


/******************************************************************************
* Copyright (C) 1994-2015 Lua.org, PUC-Rio.
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
******************************************************************************/


#endif

```

`plugin/ios_stacktrace/ce_sdk/luaconf.h`:

```h
/*
** $Id: luaconf.h,v 1.238 2014/12/29 13:27:55 roberto Exp $
** Configuration file for Lua
** See Copyright Notice in lua.h
*/


#ifndef luaconf_h
#define luaconf_h

#include <limits.h>
#include <stddef.h>


/*
** ===================================================================
** Search for "@@" to find all configurable definitions.
** ===================================================================
*/


/*
** {====================================================================
** System Configuration: macros to adapt (if needed) Lua to some
** particular platform, for instance compiling it with 32-bit numbers or
** restricting it to C89.
** =====================================================================
*/

/*
@@ LUA_32BITS enables Lua with 32-bit integers and 32-bit floats. You
** can also define LUA_32BITS in the make file, but changing here you
** ensure that all software connected to Lua will be compiled with the
** same configuration.
*/
/* #define LUA_32BITS */


/*
@@ LUA_USE_C89 controls the use of non-ISO-C89 features.
** Define it if you want Lua to avoid the use of a few C99 features
** or Windows-specific features on Windows.
*/
/* #define LUA_USE_C89 */


/*
** By default, Lua on Windows use (some) specific Windows features
*/
#if !defined(LUA_USE_C89) && defined(_WIN32) && !defined(_WIN32_WCE)
#define LUA_USE_WINDOWS  /* enable goodies for regular Windows */
#endif


#if defined(LUA_USE_WINDOWS)
#define LUA_DL_DLL	/* enable support for DLL */
#define LUA_USE_C89	/* broadly, Windows is C89 */
#endif


#if defined(LUA_USE_LINUX)
#define LUA_USE_POSIX
#define LUA_USE_DLOPEN		/* needs an extra library: -ldl */
#define LUA_USE_READLINE	/* needs some extra libraries */
#endif


#if defined(LUA_USE_MACOSX)
#define LUA_USE_POSIX
#define LUA_USE_DLOPEN		/* MacOS does not need -ldl */
#define LUA_USE_READLINE	/* needs an extra library: -lreadline */
#endif


/*
@@ LUA_C89_NUMBERS ensures that Lua uses the largest types available for
** C89 ('long' and 'double'); Windows always has '__int64', so it does
** not need to use this case.
*/
#if defined(LUA_USE_C89) && !defined(LUA_USE_WINDOWS)
#define LUA_C89_NUMBERS
#endif



/*
@@ LUAI_BITSINT defines the (minimum) number of bits in an 'int'.
*/
/* avoid undefined shifts */
#if ((INT_MAX >> 15) >> 15) >= 1
#define LUAI_BITSINT	32
#else
/* 'int' always must have at least 16 bits */
#define LUAI_BITSINT	16
#endif


/*
@@ LUA_INT_INT / LUA_INT_LONG / LUA_INT_LONGLONG defines the type for
** Lua integers.
@@ LUA_REAL_FLOAT / LUA_REAL_DOUBLE / LUA_REAL_LONGDOUBLE defines
** the type for Lua floats.
** Lua should work fine with any mix of these options (if supported
** by your C compiler). The usual configurations are 64-bit integers
** and 'double' (the default), 32-bit integers and 'float' (for
** restricted platforms), and 'long'/'double' (for C compilers not
** compliant with C99, which may not have support for 'long long').
*/

#if defined(LUA_32BITS)		/* { */
/*
** 32-bit integers and 'float'
*/
#if LUAI_BITSINT >= 32  /* use 'int' if big enough */
#define LUA_INT_INT
#else  /* otherwise use 'long' */
#define LUA_INT_LONG
#endif
#define LUA_REAL_FLOAT

#elif defined(LUA_C89_NUMBERS)	/* }{ */
/*
** largest types available for C89 ('long' and 'double')
*/
#define LUA_INT_LONG
#define LUA_REAL_DOUBLE

#else				/* }{ */
/*
** default configuration for 64-bit Lua ('long long' and 'double')
*/
#define LUA_INT_LONGLONG
#define LUA_REAL_DOUBLE

#endif								/* } */

/* }================================================================== */




/*
** {==================================================================
** Configuration for Paths.
** ===================================================================
*/

/*
@@ LUA_PATH_DEFAULT is the default path that Lua uses to look for
** Lua libraries.
@@ LUA_CPATH_DEFAULT is the default path that Lua uses to look for
** C libraries.
** CHANGE them if your machine has a non-conventional directory
** hierarchy or if you want to install your libraries in
** non-conventional directories.
*/
#define LUA_VDIR	LUA_VERSION_MAJOR "." LUA_VERSION_MINOR
#if defined(_WIN32) 	/* { */
/*
** In Windows, any exclamation mark ('!') in the path is replaced by the
** path of the directory of the executable file of the current process.
*/
#define LUA_LDIR	"!\\lua\\"
#define LUA_CDIR	"!\\"
#define LUA_SHRDIR	"!\\..\\share\\lua\\" LUA_VDIR "\\"
#define LUA_PATH_DEFAULT  \
		LUA_LDIR"?.lua;"  LUA_LDIR"?\\init.lua;" \
		LUA_CDIR"?.lua;"  LUA_CDIR"?\\init.lua;" \
		LUA_SHRDIR"?.lua;" LUA_SHRDIR"?\\init.lua;" \
		".\\?.lua;" ".\\?\\init.lua"
#define LUA_CPATH_DEFAULT \
		LUA_CDIR"?.dll;" \
		LUA_CDIR"..\\lib\\lua\\" LUA_VDIR "\\?.dll;" \
		LUA_CDIR"loadall.dll;" ".\\?.dll" \
    LUA_CDIR"?53.dll;" ".\\?53.dll"

#else			/* }{ */

#define LUA_ROOT	"/usr/local/"
#define LUA_LDIR	LUA_ROOT "share/lua/" LUA_VDIR "/"
#define LUA_CDIR	LUA_ROOT "lib/lua/" LUA_VDIR "/"
#define LUA_PATH_DEFAULT  \
		LUA_LDIR"?.lua;"  LUA_LDIR"?/init.lua;" \
		LUA_CDIR"?.lua;"  LUA_CDIR"?/init.lua;" \
		"./?.lua;" "./?/init.lua"
#define LUA_CPATH_DEFAULT \
		LUA_CDIR"?.so;" LUA_CDIR"loadall.so;" "./?.so" \
    LUA_CDIR"lib?53.so;" "./lib?53.so"
#endif			/* } */


/*
@@ LUA_DIRSEP is the directory separator (for submodules).
** CHANGE it if your machine does not use "/" as the directory separator
** and is not Windows. (On Windows Lua automatically uses "\".)
*/
#if defined(_WIN32)
#define LUA_DIRSEP	"\\"
#else
#define LUA_DIRSEP	"/"
#endif

/* }================================================================== */


/*
** {==================================================================
** Marks for exported symbols in the C code
** ===================================================================
*/

/*
@@ LUA_API is a mark for all core API functions.
@@ LUALIB_API is a mark for all auxiliary library functions.
@@ LUAMOD_API is a mark for all standard library opening functions.
** CHANGE them if you need to define those functions in some special way.
** For instance, if you want to create one Windows DLL with the core and
** the libraries, you may want to use the following definition (define
** LUA_BUILD_AS_DLL to get it).
*/
#if defined(LUA_BUILD_AS_DLL)	/* { */

#if defined(LUA_CORE) || defined(LUA_LIB)	/* { */
#define LUA_API __declspec(dllexport)
#else						/* }{ */
#define LUA_API __declspec(dllimport)
#endif						/* } */

#else				/* }{ */

#define LUA_API		extern

#endif				/* } */


/* more often than not the libs go together with the core */
#define LUALIB_API	LUA_API
#define LUAMOD_API	LUALIB_API


/*
@@ LUAI_FUNC is a mark for all extern functions that are not to be
** exported to outside modules.
@@ LUAI_DDEF and LUAI_DDEC are marks for all extern (const) variables
** that are not to be exported to outside modules (LUAI_DDEF for
** definitions and LUAI_DDEC for declarations).
** CHANGE them if you need to mark them in some special way. Elf/gcc
** (versions 3.2 and later) mark them as "hidden" to optimize access
** when Lua is compiled as a shared library. Not all elf targets support
** this attribute. Unfortunately, gcc does not offer a way to check
** whether the target offers that support, and those without support
** give a warning about it. To avoid these warnings, change to the
** default definition.
*/
#if defined(__GNUC__) && ((__GNUC__*100 + __GNUC_MINOR__) >= 302) && \
    defined(__ELF__)		/* { */
#define LUAI_FUNC	__attribute__((visibility("hidden"))) extern
#else				/* }{ */
#define LUAI_FUNC	extern
#endif				/* } */

#define LUAI_DDEC	LUAI_FUNC
#define LUAI_DDEF	/* empty */

/* }================================================================== */


/*
** {==================================================================
** Compatibility with previous versions
** ===================================================================
*/

/*
@@ LUA_COMPAT_5_2 controls other macros for compatibility with Lua 5.2.
@@ LUA_COMPAT_5_1 controls other macros for compatibility with Lua 5.1.
** You can define it to get all options, or change specific options
** to fit your specific needs.
*/
#if defined(LUA_COMPAT_5_2)	/* { */

/*
@@ LUA_COMPAT_MATHLIB controls the presence of several deprecated
** functions in the mathematical library.
*/
#define LUA_COMPAT_MATHLIB

/*
@@ LUA_COMPAT_BITLIB controls the presence of library 'bit32'.
*/
#define LUA_COMPAT_BITLIB

/*
@@ LUA_COMPAT_IPAIRS controls the effectiveness of the __ipairs metamethod.
*/
#define LUA_COMPAT_IPAIRS

/*
@@ LUA_COMPAT_APIINTCASTS controls the presence of macros for
** manipulating other integer types (lua_pushunsigned, lua_tounsigned,
** luaL_checkint, luaL_checklong, etc.)
*/
#define LUA_COMPAT_APIINTCASTS


/*
@@ LUA_COMPAT_FLOATSTRING makes Lua format integral floats without a
@@ a float mark ('.0').
** This macro is not on by default even in compatibility mode,
** because this is not really an incompatibility.
*/
/* #define LUA_COMPAT_FLOATSTRING */

#endif				/* } */


#if defined(LUA_COMPAT_5_1)	/* { */

/*
@@ LUA_COMPAT_UNPACK controls the presence of global 'unpack'.
** You can replace it with 'table.unpack'.
*/
#define LUA_COMPAT_UNPACK

/*
@@ LUA_COMPAT_LOADERS controls the presence of table 'package.loaders'.
** You can replace it with 'package.searchers'.
*/
#define LUA_COMPAT_LOADERS

/*
@@ macro 'lua_cpcall' emulates deprecated function lua_cpcall.
** You can call your C function directly (with light C functions).
*/
#define lua_cpcall(L,f,u)  \
	(lua_pushcfunction(L, (f)), \
	 lua_pushlightuserdata(L,(u)), \
	 lua_pcall(L,1,0,0))


/*
@@ LUA_COMPAT_LOG10 defines the function 'log10' in the math library.
** You can rewrite 'log10(x)' as 'log(x, 10)'.
*/
#define LUA_COMPAT_LOG10

/*
@@ LUA_COMPAT_LOADSTRING defines the function 'loadstring' in the base
** library. You can rewrite 'loadstring(s)' as 'load(s)'.
*/
#define LUA_COMPAT_LOADSTRING

/*
@@ LUA_COMPAT_MAXN defines the function 'maxn' in the table library.
*/
#define LUA_COMPAT_MAXN

/*
@@ The following macros supply trivial compatibility for some
** changes in the API. The macros themselves document how to
** change your code to avoid using them.
*/
#define lua_strlen(L,i)		lua_rawlen(L, (i))

#define lua_objlen(L,i)		lua_rawlen(L, (i))

#define lua_equal(L,idx1,idx2)		lua_compare(L,(idx1),(idx2),LUA_OPEQ)
#define lua_lessthan(L,idx1,idx2)	lua_compare(L,(idx1),(idx2),LUA_OPLT)

/*
@@ LUA_COMPAT_MODULE controls compatibility with previous
** module functions 'module' (Lua) and 'luaL_register' (C).
*/
#define LUA_COMPAT_MODULE

#endif				/* } */

/* }================================================================== */



/*
** {==================================================================
** Configuration for Numbers.
** Change these definitions if no predefined LUA_REAL_* / LUA_INT_*
** satisfy your needs.
** ===================================================================
*/

/*
@@ LUA_NUMBER is the floating-point type used by Lua.
**
@@ LUAI_UACNUMBER is the result of an 'usual argument conversion'
@@ over a floating number.
**
@@ LUA_NUMBER_FRMLEN is the length modifier for writing floats.
@@ LUA_NUMBER_FMT is the format for writing floats.
@@ lua_number2str converts a float to a string.
**
@@ l_mathop allows the addition of an 'l' or 'f' to all math operations.
**
@@ lua_str2number converts a decimal numeric string to a number.
*/

#if defined(LUA_REAL_FLOAT)		/* { single float */

#define LUA_NUMBER	float

#define LUAI_UACNUMBER	double

#define LUA_NUMBER_FRMLEN	""
#define LUA_NUMBER_FMT		"%.7g"

#define l_mathop(op)		op##f

#define lua_str2number(s,p)	strtof((s), (p))


#elif defined(LUA_REAL_LONGDOUBLE)	/* }{ long double */

#define LUA_NUMBER	long double

#define LUAI_UACNUMBER	long double

#define LUA_NUMBER_FRMLEN	"L"
#define LUA_NUMBER_FMT		"%.19Lg"

#define l_mathop(op)		op##l

#define lua_str2number(s,p)	strtold((s), (p))

#elif defined(LUA_REAL_DOUBLE)		/* }{ double */

#define LUA_NUMBER	double

#define LUAI_UACNUMBER	double

#define LUA_NUMBER_FRMLEN	""
#define LUA_NUMBER_FMT		"%.14g"

#define l_mathop(op)		op

#define lua_str2number(s,p)	strtod((s), (p))

#else					/* }{ */

#error "numeric real type not defined"

#endif					/* } */


#define l_floor(x)		(l_mathop(floor)(x))

#define lua_number2str(s,n)	sprintf((s), LUA_NUMBER_FMT, (n))


/*
@@ lua_numbertointeger converts a float number to an integer, or
** returns 0 if float is not within the range of a lua_Integer.
** (The range comparisons are tricky because of rounding. The tests
** here assume a two-complement representation, where MININTEGER always
** has an exact representation as a float; MAXINTEGER may not have one,
** and therefore its conversion to float may have an ill-defined value.)
*/
#define lua_numbertointeger(n,p) \
  ((n) >= (LUA_NUMBER)(LUA_MININTEGER) && \
   (n) < -(LUA_NUMBER)(LUA_MININTEGER) && \
      (*(p) = (LUA_INTEGER)(n), 1))


/*
@@ The luai_num* macros define the primitive operations over numbers.
** They should work for any size of floating numbers.
*/

/* the following operations need the math library */
#if defined(lobject_c) || defined(lvm_c)
#include <math.h>

/* floor division (defined as 'floor(a/b)') */
#define luai_numidiv(L,a,b)	((void)L, l_mathop(floor)(luai_numdiv(L,a,b)))

/*
** module: defined as 'a - floor(a/b)*b'; the previous definition gives
** NaN when 'b' is huge, but the result should be 'a'. 'fmod' gives the
** result of 'a - trunc(a/b)*b', and therefore must be corrected when
** 'trunc(a/b) ~= floor(a/b)'. That happens when the division has a
** non-integer negative result, which is equivalent to the test below
*/
#define luai_nummod(L,a,b,m)  \
  { (m) = l_mathop(fmod)(a,b); if ((m)*(b) < 0) (m) += (b); }

/* exponentiation */
#define luai_numpow(L,a,b)	((void)L, l_mathop(pow)(a,b))

#endif

/* these are quite standard operations */
#if defined(LUA_CORE)
#define luai_numadd(L,a,b)	((a)+(b))
#define luai_numsub(L,a,b)	((a)-(b))
#define luai_nummul(L,a,b)	((a)*(b))
#define luai_numdiv(L,a,b)	((a)/(b))
#define luai_numunm(L,a)	(-(a))
#define luai_numeq(a,b)		((a)==(b))
#define luai_numlt(a,b)		((a)<(b))
#define luai_numle(a,b)		((a)<=(b))
#define luai_numisnan(a)	(!luai_numeq((a), (a)))
#endif


/*
@@ LUA_INTEGER is the integer type used by Lua.
**
@@ LUA_UNSIGNED is the unsigned version of LUA_INTEGER.
**
@@ LUAI_UACINT is the result of an 'usual argument conversion'
@@ over a lUA_INTEGER.
@@ LUA_INTEGER_FRMLEN is the length modifier for reading/writing integers.
@@ LUA_INTEGER_FMT is the format for writing integers.
@@ LUA_MAXINTEGER is the maximum value for a LUA_INTEGER.
@@ LUA_MININTEGER is the minimum value for a LUA_INTEGER.
@@ lua_integer2str converts an integer to a string.
*/


/* The following definitions are good for most cases here */

#define LUA_INTEGER_FMT		"%" LUA_INTEGER_FRMLEN "d"
#define lua_integer2str(s,n)	sprintf((s), LUA_INTEGER_FMT, (n))

#define LUAI_UACINT		LUA_INTEGER

/*
** use LUAI_UACINT here to avoid problems with promotions (which
** can turn a comparison between unsigneds into a signed comparison)
*/
#define LUA_UNSIGNED		unsigned LUAI_UACINT


/* now the variable definitions */

#if defined(LUA_INT_INT)		/* { int */

#define LUA_INTEGER		int
#define LUA_INTEGER_FRMLEN	""

#define LUA_MAXINTEGER		INT_MAX
#define LUA_MININTEGER		INT_MIN

#elif defined(LUA_INT_LONG)	/* }{ long */

#define LUA_INTEGER		long
#define LUA_INTEGER_FRMLEN	"l"

#define LUA_MAXINTEGER		LONG_MAX
#define LUA_MININTEGER		LONG_MIN

#elif defined(LUA_INT_LONGLONG)	/* }{ long long */

#if defined(LLONG_MAX)		/* { */
/* use ISO C99 stuff */

#define LUA_INTEGER		long long
#define LUA_INTEGER_FRMLEN	"ll"

#define LUA_MAXINTEGER		LLONG_MAX
#define LUA_MININTEGER		LLONG_MIN

#elif defined(LUA_USE_WINDOWS) /* }{ */
/* in Windows, can use specific Windows types */

#define LUA_INTEGER		__int64
#define LUA_INTEGER_FRMLEN	"I64"

#define LUA_MAXINTEGER		_I64_MAX
#define LUA_MININTEGER		_I64_MIN

#else				/* }{ */

#error "Compiler does not support 'long long'. Use option '-DLUA_32BITS' \
  or '-DLUA_C89_NUMBERS' (see file 'luaconf.h' for details)"

#endif				/* } */

#else				/* }{ */

#error "numeric integer type not defined"

#endif				/* } */

/* }================================================================== */


/*
** {==================================================================
** Dependencies with C99
** ===================================================================
*/

/*
@@ lua_strx2number converts an hexadecimal numeric string to a number.
** In C99, 'strtod' does both conversions. Otherwise, you can
** leave 'lua_strx2number' undefined and Lua will provide its own
** implementation.
*/
#if !defined(LUA_USE_C89)
#define lua_strx2number(s,p)	lua_str2number(s,p)
#endif


/*
@@ LUA_USE_AFORMAT allows '%a'/'%A' specifiers in 'string.format'
** Enable it if the C function 'printf' supports these specifiers.
** (C99 demands it and Windows also supports it.)
*/
#if !defined(LUA_USE_C89) || defined(LUA_USE_WINDOWS)
#define LUA_USE_AFORMAT
#endif


/*
** 'strtof' and 'opf' variants for math functions are not valid in
** C89. Otherwise, the macro 'HUGE_VALF' is a good proxy for testing the
** availability of these variants. ('math.h' is already included in
** all files that use these macros.)
*/
#if defined(LUA_USE_C89) || (defined(HUGE_VAL) && !defined(HUGE_VALF))
#undef l_mathop  /* variants not available */
#undef lua_str2number
#define l_mathop(op)		(lua_Number)op  /* no variant */
#define lua_str2number(s,p)	((lua_Number)strtod((s), (p)))
#endif


/*
@@ LUA_KCONTEXT is the type of the context ('ctx') for continuation
** functions.  It must be a numerical type; Lua will use 'intptr_t' if
** available, otherwise it will use 'ptrdiff_t' (the nearest thing to
** 'intptr_t' in C89)
*/
#define LUA_KCONTEXT	ptrdiff_t

#if !defined(LUA_USE_C89) && defined(__STDC_VERSION__) && \
    __STDC_VERSION__ >= 199901L
#include <stdint.h>
#if defined (INTPTR_MAX)  /* even in C99 this type is optional */
#undef LUA_KCONTEXT
#define LUA_KCONTEXT	intptr_t
#endif
#endif

/* }================================================================== */


/*
** {==================================================================
** Macros that affect the API and must be stable (that is, must be the
** same when you compile Lua and when you compile code that links to
** Lua). You probably do not want/need to change them.
** =====================================================================
*/

/*
@@ LUAI_MAXSTACK limits the size of the Lua stack.
** CHANGE it if you need a different limit. This limit is arbitrary;
** its only purpose is to stop Lua from consuming unlimited stack
** space (and to reserve some numbers for pseudo-indices).
*/
#if LUAI_BITSINT >= 32
#define LUAI_MAXSTACK		1000000
#else
#define LUAI_MAXSTACK		15000
#endif

/* reserve some space for error handling */
#define LUAI_FIRSTPSEUDOIDX	(-LUAI_MAXSTACK - 1000)


/*
@@ LUA_EXTRASPACE defines the size of a raw memory area associated with
** a Lua state with very fast access.
** CHANGE it if you need a different size.
*/
#define LUA_EXTRASPACE		(sizeof(void *))


/*
@@ LUA_IDSIZE gives the maximum size for the description of the source
@@ of a function in debug information.
** CHANGE it if you want a different size.
*/
#define LUA_IDSIZE	60


/*
@@ LUAI_MAXSHORTLEN is the maximum length for short strings, that is,
** strings that are internalized. (Cannot be smaller than reserved words
** or tags for metamethods, as these strings must be internalized;
** #("function") = 8, #("__newindex") = 10.)
*/
#define LUAI_MAXSHORTLEN        40


/*
@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.
** CHANGE it if it uses too much C-stack space.
*/
#define LUAL_BUFFERSIZE	((int)(0x80 * sizeof(void*) * sizeof(lua_Integer)))

/* }================================================================== */


/*
@@ LUA_QL describes how error messages quote program elements.
** Lua does not use these macros anymore; they are here for
** compatibility only.
*/
#define LUA_QL(x)	"'" x "'"
#define LUA_QS		LUA_QL("%s")




/* =================================================================== */

/*
** Local configuration. You can use this space to add your redefinitions
** without modifying the main part of the file.
*/





#endif


```

`plugin/ios_stacktrace/ce_sdk/lualib.h`:

```h
/*
** $Id: lualib.h,v 1.44 2014/02/06 17:32:33 roberto Exp $
** Lua standard libraries
** See Copyright Notice in lua.h
*/


#ifndef lualib_h
#define lualib_h

#include "lua.h"



LUAMOD_API int (luaopen_base) (lua_State *L);

#define LUA_COLIBNAME	"coroutine"
LUAMOD_API int (luaopen_coroutine) (lua_State *L);

#define LUA_TABLIBNAME	"table"
LUAMOD_API int (luaopen_table) (lua_State *L);

#define LUA_IOLIBNAME	"io"
LUAMOD_API int (luaopen_io) (lua_State *L);

#define LUA_OSLIBNAME	"os"
LUAMOD_API int (luaopen_os) (lua_State *L);

#define LUA_STRLIBNAME	"string"
LUAMOD_API int (luaopen_string) (lua_State *L);

#define LUA_UTF8LIBNAME	"utf8"
LUAMOD_API int (luaopen_utf8) (lua_State *L);

#define LUA_BITLIBNAME	"bit32"
LUAMOD_API int (luaopen_bit32) (lua_State *L);

#define LUA_MATHLIBNAME	"math"
LUAMOD_API int (luaopen_math) (lua_State *L);

#define LUA_DBLIBNAME	"debug"
LUAMOD_API int (luaopen_debug) (lua_State *L);

#define LUA_LOADLIBNAME	"package"
LUAMOD_API int (luaopen_package) (lua_State *L);


/* open all previous libraries */
LUALIB_API void (luaL_openlibs) (lua_State *L);



#if !defined(lua_assert)
#define lua_assert(x)	((void)0)
#endif


#endif

```

`plugin/ios_stacktrace/ios_stacktrace_plugin.cpp`:

```cpp
#include <windows.h>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cstddef>
#include <vector>

extern "C" {
#include "cepluginsdk.h"
}

static_assert(sizeof(void*) == 8, "built as x64.");

typedef BOOL (__stdcall *ReadProcessMemory_FuncType)(HANDLE hProcess, LPCVOID lpBaseAddress,
                                                     LPVOID lpBuffer, SIZE_T nSize,
                                                     SIZE_T *lpNumberOfBytesRead);

typedef void* (*TPluginFunc)(void* parameters);

// Lua function pointer types
typedef intptr_t lua_KContext;
typedef int (*lua_KFunction)(lua_State* L, int status, lua_KContext ctx);

typedef void (*P_lua_getglobal)(lua_State *L, const char *name);
typedef void (*P_lua_setglobal)(lua_State *L, const char *name);
typedef void (*P_lua_pushcclosure)(lua_State *L, lua_CFunction f, int n);
typedef void (*P_lua_pushstring)(lua_State *L, const char *s);
typedef void (*P_lua_pushboolean)(lua_State *L, int b);
typedef void (*P_lua_pushinteger)(lua_State *L, lua_Integer n);
typedef void (*P_lua_settop)(lua_State *L, int idx);
typedef void (*P_lua_createtable)(lua_State *L, int narr, int nrec);
typedef void (*P_lua_rawseti)(lua_State *L, int idx, lua_Integer n);
typedef int  (*P_lua_toboolean)(lua_State *L, int idx);
typedef void (*P_lua_settable)(lua_State *L, int idx);
typedef int  (*P_luaL_loadstring)(lua_State *L, const char *s);

typedef int  (*P_lua_pcall)(lua_State *L, int nargs, int nresults, int errfunc);
typedef int  (*P_lua_pcallk)(lua_State *L, int nargs, int nresults, int errfunc,
                            lua_KContext ctx, lua_KFunction k);

typedef lua_Integer (*P_lua_tointegerx)(lua_State *L, int idx, int *isnum);
typedef lua_Integer (*P_lua_tointeger)(lua_State *L, int idx);

static HANDLE* g_OpenedProcessHandlePtr = nullptr;
static ReadProcessMemory_FuncType* g_ReadProcessMemoryPtr = nullptr;
static bool g_Initialized = false;

static P_lua_getglobal g_lua_getglobal = nullptr;
static P_lua_setglobal g_lua_setglobal = nullptr;
static P_lua_pushcclosure g_lua_pushcclosure = nullptr;
static P_lua_pushstring g_lua_pushstring = nullptr;
static P_lua_pushboolean g_lua_pushboolean = nullptr;
static P_lua_pushinteger g_lua_pushinteger = nullptr;
static P_lua_settop g_lua_settop = nullptr;
static P_lua_createtable g_lua_createtable = nullptr;
static P_lua_rawseti g_lua_rawseti = nullptr;
static P_lua_toboolean g_lua_toboolean = nullptr;
static P_lua_settable g_lua_settable = nullptr;
static P_luaL_loadstring g_luaL_loadstring = nullptr;
static P_lua_pcall g_lua_pcall = nullptr;
static P_lua_pcallk g_lua_pcallk = nullptr;
static P_lua_tointegerx g_lua_tointegerx = nullptr;
static P_lua_tointeger g_lua_tointeger = nullptr;

static lua_State* g_L = nullptr;
static CEP_REGISTERFUNCTION g_RegisterFunction = nullptr;
static CEP_UNREGISTERFUNCTION g_UnregisterFunction = nullptr;
static int g_plugin_id = -1;
static int g_menu_id = -1;

static const int kDefaultMaxFrames = 64;
static const int kMaxFramesLimit = 2048;

static int My_lua_pcall(lua_State *L, int nargs, int nresults, int errfunc) {
  if (g_lua_pcall) {
    return g_lua_pcall(L, nargs, nresults, errfunc);
  }
  if (g_lua_pcallk) {
    return g_lua_pcallk(L, nargs, nresults, errfunc, (lua_KContext)0, nullptr);
  }
  return -1;
}

static lua_Integer My_lua_tointeger(lua_State *L, int idx, bool *isnum) {
  if (g_lua_tointegerx) {
    int ok = 0;
    lua_Integer v = g_lua_tointegerx(L, idx, &ok);
    if (isnum) *isnum = (ok != 0);
    return v;
  }
  if (g_lua_tointeger) {
    if (isnum) *isnum = true;
    return g_lua_tointeger(L, idx);
  }
  if (isnum) *isnum = false;
  return 0;
}

static void lua_pop_all(lua_State *L) {
  if (g_lua_settop) g_lua_settop(L, 0);
}

static bool exported_struct_valid(const ExportedFunctions* f) {
  const size_t sz = (size_t)f->sizeofExportedFunctions;
  if (sz < offsetof(ExportedFunctions, OpenedProcessHandle) + sizeof(f->OpenedProcessHandle)) return false;
  if (sz < offsetof(ExportedFunctions, ReadProcessMemory) + sizeof(f->ReadProcessMemory)) return false;
  if (sz < offsetof(ExportedFunctions, GetLuaState) + sizeof(f->GetLuaState)) return false;
  if (sz < offsetof(ExportedFunctions, MainThreadCall) + sizeof(f->MainThreadCall)) return false;
  if (sz < offsetof(ExportedFunctions, RegisterFunction) + sizeof(f->RegisterFunction)) return false;
  if (sz < offsetof(ExportedFunctions, UnregisterFunction) + sizeof(f->UnregisterFunction)) return false;
  return true;
}

static uint64_t strip_pac(uint64_t p) {
  return p & 0x0000007FFFFFFFFFULL;
}

static int clamp_max_frames(lua_State *L, int idx, int fallback) {
  bool isnum = false;
  if (g_lua_tointegerx || g_lua_tointeger) {
    lua_Integer v = My_lua_tointeger(L, idx, &isnum);
    if (isnum && v > 0 && v < kMaxFramesLimit) return (int)v;
  }
  return fallback;
}

static bool read_mem(uint64_t address, void* buffer, size_t size) {
  if (!g_Initialized) return false;
  if (!g_OpenedProcessHandlePtr || !g_ReadProcessMemoryPtr) return false;

  HANDLE hToUse = *g_OpenedProcessHandlePtr;
  if (!hToUse) return false;

  ReadProcessMemory_FuncType rpmFunc = *g_ReadProcessMemoryPtr;
  if (!rpmFunc) return false;

  SIZE_T bytesRead = 0;
  BOOL res = rpmFunc(hToUse, (LPCVOID)address, buffer, size, &bytesRead);
  if (!res || bytesRead != size) return false;
  return true;
}

static bool read_mem_mapped(uint64_t address, void* buffer, size_t size,
                            bool use_shadow, uint64_t shadow_orig,
                            uint64_t shadow_new, uint64_t shadow_size) {
  if (use_shadow && shadow_size > 0) {
    uint64_t shadow_end = shadow_orig + shadow_size;
    if (address >= shadow_orig && address < shadow_end) {
      address = shadow_new + (address - shadow_orig);
    }
  }
  return read_mem(address, buffer, size);
}

static bool read_frame_pair(uint64_t fp, uint64_t* prev_fp, uint64_t* ret_addr,
                            bool use_shadow, uint64_t shadow_orig,
                            uint64_t shadow_new, uint64_t shadow_size) {
  if (!prev_fp || !ret_addr) return false;
  if (!read_mem_mapped(fp, prev_fp, sizeof(*prev_fp), use_shadow, shadow_orig, shadow_new, shadow_size)) return false;
  if (!read_mem_mapped(fp + sizeof(uint64_t), ret_addr, sizeof(*ret_addr), use_shadow, shadow_orig, shadow_new, shadow_size)) return false;
  return true;
}

struct FrameEntry {
  uint64_t pc;
  uint64_t sp;
  uint64_t fp;
  uint64_t ret;
};

static void unwind_frames(std::vector<FrameEntry>& out, uint64_t pc, uint64_t sp, uint64_t fp,
                          int max_frames, bool use_shadow, uint64_t shadow_orig,
                          uint64_t shadow_new, uint64_t shadow_size) {
  out.clear();

  uint64_t cur_pc = strip_pac(pc);
  uint64_t cur_sp = sp;
  uint64_t cur_fp = strip_pac(fp);

  for (int i = 0; i < max_frames; i++) {
    uint64_t prev_fp = 0;
    uint64_t ret_addr = 0;
    bool has_fp = (cur_fp != 0 && (cur_fp & 0xF) == 0);
    if (has_fp) {
      if (!read_frame_pair(cur_fp, &prev_fp, &ret_addr, use_shadow, shadow_orig, shadow_new, shadow_size)) {
        break;
      }
    }

    prev_fp = strip_pac(prev_fp);
    ret_addr = strip_pac(ret_addr);

    FrameEntry entry;
    entry.pc = cur_pc;
    entry.sp = cur_sp;
    entry.fp = cur_fp;
    entry.ret = ret_addr;
    out.push_back(entry);

    if (ret_addr == 0) break;
    if (prev_fp == 0 || prev_fp <= cur_fp) break;

    cur_pc = ret_addr;
    cur_sp = cur_fp;
    cur_fp = prev_fp;
  }
}

static bool call_debug_get_context(lua_State *L) {
  if (!g_lua_getglobal || !g_lua_settop) return false;

  g_lua_getglobal(L, "debug_getContext");
  if (My_lua_pcall(L, 0, 1, 0) == 0) {
    bool ok = false;
    if (g_lua_toboolean) {
      ok = (g_lua_toboolean(L, -1) != 0);
    } else {
      bool isnum = false;
      lua_Integer v = My_lua_tointeger(L, -1, &isnum);
      if (isnum) ok = (v != 0);
    }
    lua_pop_all(L);
    return ok;
  }

  lua_pop_all(L);
  g_lua_getglobal(L, "getDebugContext");
  if (My_lua_pcall(L, 0, 1, 0) == 0) {
    bool ok = false;
    if (g_lua_toboolean) {
      ok = (g_lua_toboolean(L, -1) != 0);
    } else {
      bool isnum = false;
      lua_Integer v = My_lua_tointeger(L, -1, &isnum);
      if (isnum) ok = (v != 0);
    }
    lua_pop_all(L);
    return ok;
  }

  lua_pop_all(L);
  return false;
}

static bool lua_get_u64_global(lua_State *L, const char *name, uint64_t *out) {
  if (!g_lua_getglobal || !g_lua_settop) return false;
  g_lua_getglobal(L, name);

  bool isnum = false;
  lua_Integer v = My_lua_tointeger(L, -1, &isnum);
  lua_pop_all(L);

  if (!isnum) return false;
  *out = (uint64_t)v;
  return true;
}

static void push_frame(lua_State *L, int index, uint64_t pc) {
  char buf[64];
  _snprintf_s(buf, sizeof(buf), _TRUNCATE, "0x%llX", (unsigned long long)pc);
  g_lua_pushstring(L, buf);
  g_lua_rawseti(L, -2, index);
}

static void set_field_u64(lua_State *L, const char *name, uint64_t value) {
  if (!g_lua_settable || !g_lua_pushstring || !g_lua_pushinteger) return;
  g_lua_pushstring(L, name);
  g_lua_pushinteger(L, (lua_Integer)value);
  g_lua_settable(L, -3);
}

static void push_frame_table(lua_State *L, uint64_t pc, uint64_t sp, uint64_t fp, uint64_t ret) {
  g_lua_createtable(L, 0, 4);
  set_field_u64(L, "pc", pc);
  set_field_u64(L, "sp", sp);
  set_field_u64(L, "fp", fp);
  set_field_u64(L, "ret", ret);
}

static int IOS_Stacktrace_GetDefaults_Lua(lua_State* L) {
  if (!g_Initialized || !g_lua_createtable || !g_lua_settable) {
    if (g_lua_pushboolean) g_lua_pushboolean(L, 0);
    return 1;
  }

  if (!call_debug_get_context(L)) {
    if (g_lua_pushboolean) g_lua_pushboolean(L, 0);
    return 1;
  }

  uint64_t sp = 0;
  uint64_t fp = 0;
  uint64_t pc = 0;
  if (!lua_get_u64_global(L, "SP", &sp)) sp = 0;
  if (!lua_get_u64_global(L, "X29", &fp)) fp = 0;
  if (!lua_get_u64_global(L, "PC", &pc)) pc = 0;

  g_lua_createtable(L, 0, 3);
  set_field_u64(L, "pc", pc);
  set_field_u64(L, "sp", sp);
  set_field_u64(L, "fp", fp);
  return 1;
}

static int IOS_Stacktrace_Lua(lua_State* L) {
  if (!g_Initialized || !g_lua_createtable || !g_lua_rawseti) {
    if (g_lua_pushboolean) g_lua_pushboolean(L, 0);
    return 1;
  }

  int max_frames = clamp_max_frames(L, 1, kDefaultMaxFrames);

  if (!call_debug_get_context(L)) {
    if (g_lua_pushboolean) g_lua_pushboolean(L, 0);
    return 1;
  }

  uint64_t sp = 0;
  uint64_t fp = 0;
  uint64_t pc = 0;

  if (!lua_get_u64_global(L, "SP", &sp)) sp = 0;
  if (!lua_get_u64_global(L, "X29", &fp)) fp = 0;
  if (!lua_get_u64_global(L, "PC", &pc)) pc = 0;

  std::vector<FrameEntry> frames;
  unwind_frames(frames, pc, sp, fp, max_frames, false, 0, 0, 0);

  g_lua_createtable(L, (int)frames.size(), 0);
  int out_index = 1;
  for (const auto& f : frames) {
    if (f.pc == 0) continue;
    push_frame(L, out_index++, f.pc);
  }

  return 1;
}

static int IOS_Stacktrace_FramesFrom_Lua(lua_State* L) {
  if (!g_Initialized || !g_lua_createtable || !g_lua_rawseti) {
    if (g_lua_pushboolean) g_lua_pushboolean(L, 0);
    return 1;
  }

  int max_frames = kDefaultMaxFrames;
  uint64_t pc = 0;
  uint64_t sp = 0;
  uint64_t fp = 0;
  uint64_t shadow_orig = 0;
  uint64_t shadow_new = 0;
  uint64_t shadow_size = 0;
  bool ok = false;

  if (g_lua_tointegerx || g_lua_tointeger) {
    lua_Integer v = My_lua_tointeger(L, 1, &ok);
    if (ok) pc = (uint64_t)v;
    v = My_lua_tointeger(L, 2, &ok);
    if (ok) sp = (uint64_t)v;
    v = My_lua_tointeger(L, 3, &ok);
    if (ok) fp = (uint64_t)v;
    max_frames = clamp_max_frames(L, 4, kDefaultMaxFrames);
    v = My_lua_tointeger(L, 5, &ok);
    if (ok) shadow_orig = (uint64_t)v;
    v = My_lua_tointeger(L, 6, &ok);
    if (ok) shadow_new = (uint64_t)v;
    v = My_lua_tointeger(L, 7, &ok);
    if (ok) shadow_size = (uint64_t)v;
  }

  bool use_shadow = (shadow_size > 0 && shadow_orig != 0 && shadow_new != 0);
  std::vector<FrameEntry> frames;
  unwind_frames(frames, pc, sp, fp, max_frames, use_shadow, shadow_orig, shadow_new, shadow_size);

  g_lua_createtable(L, (int)frames.size(), 0);
  for (size_t i = 0; i < frames.size(); i++) {
    const auto& f = frames[i];
    push_frame_table(L, f.pc, f.sp, f.fp, f.ret);
    g_lua_rawseti(L, -2, (int)i + 1);
  }

  return 1;
}

static int IOS_Stacktrace_Frames_Lua(lua_State* L) {
  if (!g_Initialized || !g_lua_createtable || !g_lua_rawseti) {
    if (g_lua_pushboolean) g_lua_pushboolean(L, 0);
    return 1;
  }

  int max_frames = clamp_max_frames(L, 1, kDefaultMaxFrames);

  if (!call_debug_get_context(L)) {
    if (g_lua_pushboolean) g_lua_pushboolean(L, 0);
    return 1;
  }

  uint64_t sp = 0;
  uint64_t fp = 0;
  uint64_t pc = 0;

  if (!lua_get_u64_global(L, "SP", &sp)) sp = 0;
  if (!lua_get_u64_global(L, "X29", &fp)) fp = 0;
  if (!lua_get_u64_global(L, "PC", &pc)) pc = 0;

  std::vector<FrameEntry> frames;
  unwind_frames(frames, pc, sp, fp, max_frames, false, 0, 0, 0);

  g_lua_createtable(L, (int)frames.size(), 0);
  for (size_t i = 0; i < frames.size(); i++) {
    const auto& f = frames[i];
    push_frame_table(L, f.pc, f.sp, f.fp, f.ret);
    g_lua_rawseti(L, -2, (int)i + 1);
  }

  return 1;
}

static const char kLuaScript[] = R"Lua(
if ios_stacktrace_ui==nil then
  ios_stacktrace_ui={}
end

local ui_text = {
  main_title = 'Stacktrace',
  manual_title = 'Manual stacktrace config',
  refresh = 'Refresh',
  manual = 'Manual input',
  pc = 'PC',
  sp = 'SP',
  fp = 'FP (X29)',
  shadow = 'Use shadow copy',
  orig = 'Original base',
  new = 'New copy',
  size = 'Size',
  ok = 'OK',
  cancel = 'Cancel',
  arrow = '->',
}

local default_max_frames = ios_stacktrace_default_max_frames or 64

local function ios_hex(v)
  if v==nil then return '' end
  if v==0 then return '0' end
  return string.format('%X', v)
end

local function ios_parse_addr(s)
  if s==nil then return nil end
  s=string.gsub(s,'^%s+','')
  s=string.gsub(s,'%s+$','')
  if s=='' then return nil end
  local v=getAddressSafe(s)
  if v==nil then
    v=tonumber(s,16) or tonumber(s)
  end
  return v
end

local function ios_get_defaults()
  if ios_stacktrace_get_defaults~=nil then
    local t=ios_stacktrace_get_defaults()
    if type(t)=='table' then
      return t.pc or 0, t.sp or 0, t.fp or 0
    end
  end
  return 0, 0, 0
end

local function ios_build_params(n)
  if n==nil or n<=0 then return '' end
  local t={}
  for r=0,n-1 do
    local v=_G['X'..r]
    if v~=nil then
      table.insert(t, 'X'..r..'='..ios_hex(v))
    end
  end
  return table.concat(t, ', ')
end

local function ios_stacktrace_frames_from_safe(pc, sp, fp, max_frames, shadow_orig, shadow_new, shadow_size)
  local raw = ios_stacktrace_frames_from
  if raw==nil then return {} end
  if type(pc)=='string' then pc=ios_parse_addr(pc) end
  if type(sp)=='string' then sp=ios_parse_addr(sp) end
  if type(fp)=='string' then fp=ios_parse_addr(fp) end
  if type(shadow_orig)=='string' then shadow_orig=ios_parse_addr(shadow_orig) end
  if type(shadow_new)=='string' then shadow_new=ios_parse_addr(shadow_new) end
  if type(shadow_size)=='string' then shadow_size=tonumber(shadow_size) end

  pc = pc or 0
  sp = sp or 0
  fp = fp or 0
  shadow_orig = shadow_orig or 0
  shadow_new = shadow_new or 0
  shadow_size = shadow_size or 0
  max_frames = max_frames or default_max_frames
  return raw(pc, sp, fp, max_frames, shadow_orig, shadow_new, shadow_size)
end

local function ios_stacktrace_ui_render(frames)
  local ui=ios_stacktrace_ui
  if ui.list==nil then return end
  if ui.param_count==nil then ui.param_count=4 end
  local params_first=ios_build_params(ui.param_count)
  ui.list.Items.clear()
  if type(frames)~='table' then return end
  for i,fr in ipairs(frames) do
    local pc=fr.pc or fr[1]
    local sp=fr.sp or fr[2]
    local fp=fr.fp or fr[3]
    local ret=fr.ret or fr[4]

    local li=ui.list.Items.add()
    li.Data=pc or 0

    if pc~=nil and pc~=0 then
      li.Caption=getNameFromAddress(pc)
    else
      li.Caption=''
    end

    li.SubItems.add(ios_hex(sp))
    li.SubItems.add(ios_hex(fp))

    if ret~=nil and ret~=0 then
      li.SubItems.add(getNameFromAddress(ret))
    else
      li.SubItems.add('')
    end

    local params = (i==1) and params_first or ''
    li.SubItems.add(params)
  end
end

function ios_stacktrace_ui_refresh()
  local ui=ios_stacktrace_ui
  if ui.list==nil then return end
  local frames=ios_stacktrace_frames(ui.maxframes or default_max_frames)
  ios_stacktrace_ui_render(frames)
end

local function ios_stacktrace_manual_form()
  local ui=ios_stacktrace_ui
  if ui.manual_form~=nil then return ui.manual_form end

  local f=createForm(false)
  f.Caption=ui_text.manual_title
  f.BorderStyle='bsSizeable'
  f.BorderIcons='[biSystemMenu, biMinimize, biMaximize]'
  f.Width=360
  f.Height=230

  local lblPC=createLabel(f)
  lblPC.Caption=ui_text.pc
  lblPC.Left=8
  lblPC.Top=4

  local edtPC=createEdit(f)
  edtPC.Left=8
  edtPC.Top=20
  edtPC.Width=170

  local lblSP=createLabel(f)
  lblSP.Caption=ui_text.sp
  lblSP.Left=8
  lblSP.Top=46

  local edtSP=createEdit(f)
  edtSP.Left=8
  edtSP.Top=62
  edtSP.Width=170

  local lblFP=createLabel(f)
  lblFP.Caption=ui_text.fp
  lblFP.Left=8
  lblFP.Top=88

  local edtFP=createEdit(f)
  edtFP.Left=8
  edtFP.Top=104
  edtFP.Width=170

  local cbShadow=createCheckBox(f)
  cbShadow.Caption=ui_text.shadow
  cbShadow.Left=8
  cbShadow.Top=132

  local lblOrig=createLabel(f)
  lblOrig.Caption=ui_text.orig
  lblOrig.Left=8
  lblOrig.Top=156

  local edtShadowOrig=createEdit(f)
  edtShadowOrig.Left=8
  edtShadowOrig.Top=172
  edtShadowOrig.Width=120

  local lblArrow=createLabel(f)
  lblArrow.Caption=ui_text.arrow
  lblArrow.Left=134
  lblArrow.Top=176

  local lblNew=createLabel(f)
  lblNew.Caption=ui_text.new
  lblNew.Left=150
  lblNew.Top=156

  local edtShadowNew=createEdit(f)
  edtShadowNew.Left=150
  edtShadowNew.Top=172
  edtShadowNew.Width=100

  local lblSize=createLabel(f)
  lblSize.Caption=ui_text.size
  lblSize.Left=260
  lblSize.Top=156

  local edtShadowSize=createEdit(f)
  edtShadowSize.Left=260
  edtShadowSize.Top=172
  edtShadowSize.Width=80
  edtShadowSize.Text='4096'

  local panel=createPanel(f)
  panel.Left=100
  panel.Top=200
  panel.Width=160
  panel.Height=26

  local btnOK=createButton(panel)
  btnOK.Caption=ui_text.ok
  btnOK.Left=0
  btnOK.Top=0
  btnOK.Width=75
  btnOK.OnClick=function() f.ModalResult=1 end

  local btnCancel=createButton(panel)
  btnCancel.Caption=ui_text.cancel
  btnCancel.Left=82
  btnCancel.Top=0
  btnCancel.Width=75
  btnCancel.OnClick=function() f.ModalResult=2 end

  ui.manual_form=f
  ui.edtPC=edtPC
  ui.edtSP=edtSP
  ui.edtFP=edtFP
  ui.cbShadow=cbShadow
  ui.edtShadowOrig=edtShadowOrig
  ui.edtShadowNew=edtShadowNew
  ui.edtShadowSize=edtShadowSize
  return f
end

function ios_stacktrace_ui_manual()
  local ui=ios_stacktrace_ui
  if ui.list==nil then return end

  local f=ios_stacktrace_manual_form()
  local pc0, sp0, fp0 = ios_get_defaults()
  ui.edtPC.Text=pc0~=0 and ios_hex(pc0) or ''
  ui.edtSP.Text=sp0~=0 and ios_hex(sp0) or ''
  ui.edtFP.Text=fp0~=0 and ios_hex(fp0) or ''

  local res=f.showModal()
  if res~=1 then return end

  local pc = ios_parse_addr(ui.edtPC.Text) or 0
  local sp = ios_parse_addr(ui.edtSP.Text) or 0
  local fp = ios_parse_addr(ui.edtFP.Text) or 0

  local shadow_orig = ios_parse_addr(ui.edtShadowOrig.Text) or 0
  local shadow_new = ios_parse_addr(ui.edtShadowNew.Text) or 0
  local shadow_size = tonumber(ui.edtShadowSize.Text) or 0
  if ui.cbShadow.Checked~=true then
    shadow_orig = 0
    shadow_new = 0
    shadow_size = 0
  end

  local frames = ios_stacktrace_frames_from_safe(pc, sp, fp, ui.maxframes or default_max_frames, shadow_orig, shadow_new, shadow_size)
  ios_stacktrace_ui_render(frames)
end

function ios_stacktrace_ui_dblclick(sender)
  local ui=ios_stacktrace_ui
  if ui.list==nil then return end
  local item=ui.list.Selected
  if item==nil then return end
  local addr=item.Data
  if addr==nil or addr==0 then return end
  local mv=getMemoryViewForm()
  if mv and mv.DisassemblerView then
    mv.DisassemblerView.TopAddress=addr
  end
end

function ios_stacktrace_open()
  local ui=ios_stacktrace_ui
  if ui.form==nil then
    local f=createForm(false)
    f.Caption=ui_text.main_title
    f.BorderStyle='bsSizeable'
    f.BorderIcons='[biSystemMenu, biMinimize, biMaximize]'
    f.Width=700
    f.Height=280

    local top=createPanel(f)
    top.Align='alTop'
    top.Height=26

    local btnRefresh=createButton(top)
    btnRefresh.Caption=ui_text.refresh
    btnRefresh.Left=6
    btnRefresh.Top=2
    btnRefresh.OnClick=ios_stacktrace_ui_refresh

    local btnManual=createButton(top)
    btnManual.Caption=ui_text.manual
    btnManual.Left=90
    btnManual.Top=2
    btnManual.OnClick=ios_stacktrace_ui_manual

    local lv=createListView(f)
    lv.Align='alClient'
    lv.ViewStyle='vsReport'
    lv.ReadOnly=true
    lv.RowSelect=true
    lv.HideSelection=false
    lv.AutoWidthLastColumn=true

    local c=lv.Columns.add()
    c.Caption='PC'
    c.Width=120
    c=lv.Columns.add()
    c.Caption='Stack'
    c.Width=120
    c=lv.Columns.add()
    c.Caption='Frame'
    c.Width=120
    c=lv.Columns.add()
    c.Caption='Return'
    c.Width=120
    c=lv.Columns.add()
    c.Caption='Parameters'
    c.AutoSize=true

    local pm=createPopupMenu(f)
    local miRefresh=createMenuItem(pm)
    miRefresh.Caption=ui_text.refresh
    miRefresh.OnClick=ios_stacktrace_ui_refresh
    pm.Items.add(miRefresh)

    local miManual=createMenuItem(pm)
    miManual.Caption=ui_text.manual
    miManual.OnClick=ios_stacktrace_ui_manual
    pm.Items.add(miManual)

    lv.PopupMenu=pm
    lv.OnDblClick=ios_stacktrace_ui_dblclick

    f.OnClose=function(sender)
      ui.form=nil
      ui.list=nil
      return caFree
    end

    ui.form=f
    ui.list=lv
  end

  ui.form.show()
  ios_stacktrace_ui_refresh()
end
)Lua";

static void run_lua_script(lua_State *L, const char *script) {
  if (!g_luaL_loadstring) return;
  if (g_luaL_loadstring(L, script) != 0) {
    lua_pop_all(L);
    return;
  }
  My_lua_pcall(L, 0, 0, 0);
  lua_pop_all(L);
}

static BOOL __stdcall OnMainMenu() {
  if (!g_L || !g_lua_getglobal) return FALSE;
  g_lua_getglobal(g_L, "ios_stacktrace_open");
  My_lua_pcall(g_L, 0, 0, 0);
  lua_pop_all(g_L);
  return TRUE;
}

static void* RegisterCallbackSafe(void* parameters) {
  lua_State* L = (lua_State*)parameters;
  g_L = L;

  HMODULE hLua = GetModuleHandleA("lua53-64.dll");
  if (!hLua) hLua = GetModuleHandleA("lua53-32.dll");
  if (!hLua) hLua = GetModuleHandleA("lua53.dll");

  if (!hLua) return nullptr;

  g_lua_getglobal = (P_lua_getglobal)GetProcAddress(hLua, "lua_getglobal");
  g_lua_setglobal = (P_lua_setglobal)GetProcAddress(hLua, "lua_setglobal");
  g_lua_pushcclosure = (P_lua_pushcclosure)GetProcAddress(hLua, "lua_pushcclosure");
  g_lua_pushstring = (P_lua_pushstring)GetProcAddress(hLua, "lua_pushstring");
  g_lua_pushboolean = (P_lua_pushboolean)GetProcAddress(hLua, "lua_pushboolean");
  g_lua_pushinteger = (P_lua_pushinteger)GetProcAddress(hLua, "lua_pushinteger");
  g_lua_settop = (P_lua_settop)GetProcAddress(hLua, "lua_settop");
  g_lua_createtable = (P_lua_createtable)GetProcAddress(hLua, "lua_createtable");
  g_lua_rawseti = (P_lua_rawseti)GetProcAddress(hLua, "lua_rawseti");
  g_lua_toboolean = (P_lua_toboolean)GetProcAddress(hLua, "lua_toboolean");
  g_lua_settable = (P_lua_settable)GetProcAddress(hLua, "lua_settable");
  g_luaL_loadstring = (P_luaL_loadstring)GetProcAddress(hLua, "luaL_loadstring");

  g_lua_pcall = (P_lua_pcall)GetProcAddress(hLua, "lua_pcall");
  if (!g_lua_pcall) {
    g_lua_pcallk = (P_lua_pcallk)GetProcAddress(hLua, "lua_pcallk");
  }

  g_lua_tointegerx = (P_lua_tointegerx)GetProcAddress(hLua, "lua_tointegerx");
  if (!g_lua_tointegerx) {
    g_lua_tointeger = (P_lua_tointeger)GetProcAddress(hLua, "lua_tointeger");
  }

  if (!g_lua_getglobal || !g_lua_setglobal || !g_lua_pushcclosure || !g_lua_pushstring ||
      !g_lua_settop || !g_lua_createtable || !g_lua_rawseti || !g_lua_toboolean ||
      !g_lua_settable || !g_luaL_loadstring || (!g_lua_pcall && !g_lua_pcallk) ||
      (!g_lua_tointegerx && !g_lua_tointeger)) {
    return nullptr;
  }

  g_lua_pushcclosure(L, IOS_Stacktrace_Lua, 0);
  g_lua_setglobal(L, "ios_stacktrace");

  g_lua_pushcclosure(L, IOS_Stacktrace_Frames_Lua, 0);
  g_lua_setglobal(L, "ios_stacktrace_frames");

  g_lua_pushcclosure(L, IOS_Stacktrace_FramesFrom_Lua, 0);
  g_lua_setglobal(L, "ios_stacktrace_frames_from");

  g_lua_pushcclosure(L, IOS_Stacktrace_GetDefaults_Lua, 0);
  g_lua_setglobal(L, "ios_stacktrace_get_defaults");

  g_lua_pushinteger(L, kDefaultMaxFrames);
  g_lua_setglobal(L, "ios_stacktrace_default_max_frames");

  run_lua_script(L, kLuaScript);

  return nullptr;
}

extern "C" __attribute__((dllexport)) BOOL __stdcall CEPlugin_GetVersion(PPluginVersion pv, int cbsize) {
  if (cbsize != sizeof(PluginVersion)) return FALSE;
  pv->version = CESDK_VERSION;
  pv->pluginname = (char*)"iOS-Stacktrace";
  return TRUE;
}

extern "C" __attribute__((dllexport)) BOOL __stdcall CEPlugin_InitializePlugin(PExportedFunctions cefuncs_ptr, int pluginid) {
  if (!cefuncs_ptr) return FALSE;
  if (!exported_struct_valid(cefuncs_ptr)) return FALSE;

  g_plugin_id = pluginid;
  g_RegisterFunction = cefuncs_ptr->RegisterFunction;
  g_UnregisterFunction = cefuncs_ptr->UnregisterFunction;

  g_OpenedProcessHandlePtr = cefuncs_ptr->OpenedProcessHandle;
  g_ReadProcessMemoryPtr = (ReadProcessMemory_FuncType*)cefuncs_ptr->ReadProcessMemory;

  if (!g_OpenedProcessHandlePtr || !g_ReadProcessMemoryPtr) return FALSE;

  if (!cefuncs_ptr->GetLuaState) return TRUE;
  lua_State* L = cefuncs_ptr->GetLuaState();
  if (!L) return TRUE;

  if (cefuncs_ptr->MainThreadCall) {
    typedef void (__stdcall *CEP_MAINTHREADCALL)(TPluginFunc func, void* parameters);
    ((CEP_MAINTHREADCALL)cefuncs_ptr->MainThreadCall)(RegisterCallbackSafe, L);
  } else {
    RegisterCallbackSafe(L);
  }

  g_Initialized = true;

  if (g_RegisterFunction) {
    PLUGINTYPE5_INIT mi;
    memset(&mi, 0, sizeof(mi));
    mi.name = (char*)"iOS-Stacktrace";
    mi.callbackroutine = (CEP_PLUGINTYPE5)OnMainMenu;
    mi.shortcut = (char*)"";
    g_menu_id = g_RegisterFunction(pluginid, ptMainMenu, &mi);
  }

  return TRUE;
}

extern "C" __attribute__((dllexport)) BOOL __stdcall CEPlugin_DisablePlugin() {
  if (g_UnregisterFunction && g_menu_id >= 0 && g_plugin_id >= 0) {
    g_UnregisterFunction(g_plugin_id, g_menu_id);
  }
  g_Initialized = false;
  g_OpenedProcessHandlePtr = nullptr;
  g_ReadProcessMemoryPtr = nullptr;

  g_lua_getglobal = nullptr;
  g_lua_setglobal = nullptr;
  g_lua_pushcclosure = nullptr;
  g_lua_pushstring = nullptr;
  g_lua_pushboolean = nullptr;
  g_lua_pushinteger = nullptr;
  g_lua_settop = nullptr;
  g_lua_createtable = nullptr;
  g_lua_rawseti = nullptr;
  g_lua_pcall = nullptr;
  g_lua_pcallk = nullptr;
  g_lua_tointegerx = nullptr;
  g_lua_tointeger = nullptr;
  g_lua_settable = nullptr;
  g_luaL_loadstring = nullptr;
  g_L = nullptr;
  g_RegisterFunction = nullptr;
  g_UnregisterFunction = nullptr;
  g_plugin_id = -1;
  g_menu_id = -1;
  return TRUE;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
  return TRUE;
}

```