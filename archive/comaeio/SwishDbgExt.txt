Project Path: arc_comaeio_SwishDbgExt_7dzdoq06

Source Tree:

```txt
arc_comaeio_SwishDbgExt_7dzdoq06
├── Documents
│   ├── Hivelist.gif
│   ├── SwishDbgExt.pdf
│   ├── Windbg_Template.WEW
│   └── windbg_template.reg
├── LICENSE
├── README.md
├── SwishDbgExt
│   ├── Azure.cpp
│   ├── Azure.h
│   ├── CNdiskd
│   │   ├── CAdapters.cpp
│   │   ├── CAdapters.h
│   │   ├── CMinidriver.cpp
│   │   ├── CMinidriver.h
│   │   ├── CNdiskd.cpp
│   │   ├── CNdiskd.h
│   │   ├── COpenblock.cpp
│   │   ├── COpenblock.h
│   │   ├── CProtocols.cpp
│   │   ├── CProtocols.h
│   │   ├── CReport.cpp
│   │   ├── CReport.h
│   │   ├── utils.cpp
│   │   └── utils.h
│   ├── Checks
│   │   ├── Codecave.cpp
│   │   └── Codecave.h
│   ├── Common.cpp
│   ├── Common.h
│   ├── Credentials.cpp
│   ├── Credentials.h
│   ├── DbgHelpEx.cpp
│   ├── DbgHelpEx.h
│   ├── Drivers.cpp
│   ├── Drivers.h
│   ├── EngExpCppEx.h
│   ├── EngExtCppEx.cpp
│   ├── Lxss.cpp
│   ├── Lxss.h
│   ├── Md5.cpp
│   ├── Md5.h
│   ├── Network.cpp
│   ├── Network.h
│   ├── NtDef.h
│   ├── Objects.cpp
│   ├── Objects.h
│   ├── Output.cpp
│   ├── Output.h
│   ├── Process.cpp
│   ├── Process.h
│   ├── Registry.cpp
│   ├── Registry.h
│   ├── Security.cpp
│   ├── Security.h
│   ├── Storage.cpp
│   ├── Storage.h
│   ├── SwishDbgExt.cpp
│   ├── SwishDbgExt.def
│   ├── SwishDbgExt.h
│   ├── SwishDbgExt.rc
│   ├── SwishDbgExt.vcxproj
│   ├── SwishDbgExt.vcxproj.filters
│   ├── System.cpp
│   ├── System.h
│   ├── UntypedData.cpp
│   ├── UntypedData.h
│   ├── Version.rc
│   ├── Version.txt
│   ├── VirusTotal.cpp
│   ├── VirusTotal.h
│   ├── Yara.cpp
│   ├── Yara.h
│   ├── engextcpp.cpp
│   ├── engextcpp.hpp
│   ├── packages.config
│   ├── resource.h
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
└── SwishDbgExt.sln

```

`Documents/windbg_template.reg`:

```reg
Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\Software\Microsoft\Windbg\Workspaces]
"Default"=hex:57,44,57,53,01,00,00,00,33,00,00,00,68,00,5c,00,f3,ff,ff,ff,00,\
  00,00,00,00,00,00,00,00,00,00,00,90,01,00,00,00,00,00,00,03,02,01,31,43,00,\
  6f,00,6e,00,73,00,6f,00,6c,00,61,00,73,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,02,00,10,00,04,00,19,\
  19,19,00,00,00,00,00,01,00,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,02,00,\
  02,00,10,00,04,00,6f,6d,7e,00,00,00,00,00,03,00,02,00,10,00,04,00,cf,ce,9a,\
  00,00,00,00,00,08,00,02,00,10,00,04,00,80,31,3a,00,00,00,00,00,09,00,02,00,\
  10,00,04,00,6f,6d,7e,00,00,00,00,00,0a,00,00,00,10,00,04,00,20,00,00,00,00,\
  00,00,00,12,00,00,00,10,00,04,00,01,00,00,00,00,00,00,00,0a,00,02,00,10,00,\
  04,00,e6,1e,3c,00,00,00,00,00,0b,00,02,00,10,00,04,00,52,54,58,00,00,00,00,\
  00,10,00,02,00,10,00,04,00,cf,69,4b,00,00,00,00,00,11,00,02,00,10,00,04,00,\
  75,a6,87,00,00,00,00,00,12,00,02,00,10,00,04,00,75,a6,87,00,00,00,00,00,13,\
  00,02,00,10,00,04,00,75,87,a6,00,00,00,00,00,18,00,02,00,10,00,04,00,af,c4,\
  db,00,00,00,00,00,19,00,02,00,10,00,04,00,33,99,ff,00,00,00,00,00,23,00,02,\
  00,10,00,04,00,52,54,58,00,00,00,00,00,00,ff,02,00,10,00,04,00,cf,ce,9a,00,\
  00,00,00,00,01,ff,02,00,10,00,04,00,19,19,19,00,00,00,00,00,02,ff,02,00,10,\
  00,04,00,80,31,3a,00,00,00,00,00,03,ff,02,00,10,00,04,00,19,19,19,00,00,00,\
  00,00,08,ff,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,09,ff,02,00,10,00,04,\
  00,19,19,19,00,00,00,00,00,0a,ff,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,\
  0b,ff,02,00,10,00,04,00,19,19,19,00,00,00,00,00,10,ff,02,00,10,00,04,00,cf,\
  ce,9a,00,00,00,00,00,11,ff,02,00,10,00,04,00,19,19,19,00,00,00,00,00,12,ff,\
  02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,13,ff,02,00,10,00,04,00,19,19,19,\
  00,00,00,00,00,38,ff,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,39,ff,02,00,\
  10,00,04,00,19,19,19,00,00,00,00,00,3a,ff,02,00,10,00,04,00,cf,ce,9a,00,00,\
  00,00,00,40,ff,02,00,10,00,04,00,cf,ce,9a,00,21,06,00,00,41,ff,02,00,10,00,\
  04,00,19,19,19,00,25,06,00,00,23,00,00,00,10,00,02,00,00,00,00,00,00,00,00,\
  00,30,00,00,00,b8,00,ae,00,22,00,43,00,3a,00,5c,00,55,00,73,00,65,00,72,00,\
  73,00,5c,00,62,00,75,00,72,00,6c,00,79,00,5c,00,44,00,6f,00,63,00,75,00,6d,\
  00,65,00,6e,00,74,00,73,00,5c,00,56,00,69,00,73,00,75,00,61,00,6c,00,20,00,\
  53,00,74,00,75,00,64,00,69,00,6f,00,20,00,32,00,30,00,31,00,30,00,5c,00,50,\
  00,72,00,6f,00,6a,00,65,00,63,00,74,00,73,00,5c,00,50,00,72,00,6f,00,63,00,\
  65,00,73,00,73,00,49,00,6e,00,6a,00,65,00,63,00,74,00,69,00,6f,00,6e,00,5c,\
  00,62,00,69,00,6e,00,5c,00,57,00,69,00,6e,00,33,00,32,00,5c,00,44,00,65,00,\
  62,00,75,00,67,00,00,00,00,00,22,00,00,00,80,00,74,00,73,00,72,00,76,00,2a,\
  00,43,00,3a,00,5c,00,53,00,79,00,6d,00,62,00,6f,00,6c,00,73,00,2a,00,68,00,\
  74,00,74,00,70,00,3a,00,2f,00,2f,00,6d,00,73,00,64,00,6c,00,2e,00,6d,00,69,\
  00,63,00,72,00,6f,00,73,00,6f,00,66,00,74,00,2e,00,63,00,6f,00,6d,00,2f,00,\
  64,00,6f,00,77,00,6e,00,6c,00,6f,00,61,00,64,00,2f,00,73,00,79,00,6d,00,62,\
  00,6f,00,6c,00,73,00,00,00,43,00,3a,00,20,00,00,00,c0,00,b2,00,4c,01,00,00,\
  00,00,00,00,09,00,08,00,07,00,06,00,0e,00,0a,00,05,00,04,00,0b,00,52,00,51,\
  00,50,00,4f,00,4e,00,4d,00,4b,00,4a,00,4c,00,02,00,0c,00,0f,00,03,00,01,00,\
  00,00,1e,00,30,00,31,00,32,00,33,00,34,00,35,00,36,00,37,00,10,00,11,00,12,\
  00,13,00,14,00,15,00,16,00,17,00,18,00,19,00,1a,00,1b,00,1c,00,1d,00,1f,00,\
  20,00,21,00,22,00,23,00,24,00,25,00,26,00,27,00,28,00,29,00,2a,00,2b,00,2c,\
  00,2d,00,2e,00,2f,00,38,00,39,00,3a,00,3b,00,3c,00,3d,00,3e,00,3f,00,40,00,\
  41,00,42,00,43,00,44,00,45,00,46,00,47,00,48,00,49,00,53,00,54,00,0d,00,65,\
  00,73,00,73,00,04,00,02,00,10,00,04,00,80,31,3a,00,63,00,00,00,3d,00,00,00,\
  10,00,04,00,00,00,00,00,72,00,73,00,0c,00,00,00,10,00,04,00,01,00,00,00,5c,\
  00,44,00,3c,00,00,00,10,00,04,00,01,00,00,00,74,00,73,00,3f,00,00,00,10,00,\
  04,00,01,00,00,00,6c,00,20,00,24,00,00,00,78,00,6a,00,43,00,3a,00,5c,00,55,\
  00,73,00,65,00,72,00,73,00,5c,00,62,00,75,00,72,00,6c,00,79,00,5c,00,44,00,\
  6f,00,63,00,75,00,6d,00,65,00,6e,00,74,00,73,00,5c,00,56,00,69,00,73,00,75,\
  00,61,00,6c,00,20,00,53,00,74,00,75,00,64,00,69,00,6f,00,20,00,32,00,30,00,\
  31,00,30,00,5c,00,50,00,72,00,6f,00,6a,00,65,00,63,00,74,00,73,00,00,00,00,\
  00,00,00,00,00,05,00,02,00,10,00,04,00,f8,f8,f8,00,00,00,00,00,06,00,02,00,\
  10,00,04,00,e6,1e,3c,00,00,00,00,00,07,00,02,00,10,00,04,00,f8,f8,f8,00,00,\
  00,00,00,0d,00,02,00,10,00,04,00,f8,f8,f8,00,00,00,00,00,0e,00,02,00,10,00,\
  04,00,33,99,ff,00,00,00,00,00,0f,00,02,00,10,00,04,00,f8,f8,f8,00,00,00,00,\
  00,14,00,02,00,10,00,04,00,cd,a8,69,00,00,00,00,00,15,00,02,00,10,00,04,00,\
  f8,f8,f8,00,00,00,00,00,16,00,02,00,10,00,04,00,6f,6d,7e,00,00,00,00,00,17,\
  00,02,00,10,00,04,00,af,c4,db,00,00,00,00,00,24,00,02,00,10,00,04,00,33,99,\
  ff,00,00,00,00,00,04,ff,02,00,10,00,04,00,d2,d2,3a,00,00,00,00,00,05,ff,02,\
  00,10,00,04,00,19,19,19,00,00,00,00,00,06,ff,02,00,10,00,04,00,f8,f8,f8,00,\
  00,00,00,00,07,ff,02,00,10,00,04,00,19,19,19,00,00,00,00,00,0c,ff,02,00,10,\
  00,04,00,d2,d2,3a,00,00,00,00,00,0d,ff,02,00,10,00,04,00,19,19,19,00,00,00,\
  00,00,0e,ff,02,00,10,00,04,00,f8,f8,f8,00,00,00,00,00,0f,ff,02,00,10,00,04,\
  00,19,19,19,00,00,00,00,00,3b,ff,02,00,10,00,04,00,19,19,19,00,00,00,00,00,\
  3c,ff,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,3d,ff,02,00,10,00,04,00,19,\
  19,19,00,00,00,00,00,3e,ff,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,3f,ff,\
  02,00,10,00,04,00,19,19,19,00,00,00,00,00,2c,00,00,00,80,00,74,00,43,00,3a,\
  00,5c,00,50,00,72,00,6f,00,67,00,72,00,61,00,6d,00,20,00,46,00,69,00,6c,00,\
  65,00,73,00,5c,00,44,00,65,00,62,00,75,00,67,00,67,00,69,00,6e,00,67,00,20,\
  00,54,00,6f,00,6f,00,6c,00,73,00,20,00,66,00,6f,00,72,00,20,00,57,00,69,00,\
  6e,00,64,00,6f,00,77,00,73,00,20,00,28,00,78,00,36,00,34,00,29,00,5c,00,74,\
  00,68,00,65,00,6d,00,65,00,73,00,00,00,00,00,00,00,04,00,03,00,10,00,04,00,\
  00,00,00,00,00,00,00,00,04,00,01,00,70,02,68,02,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,ff,ff,\
  ff,0f,00,00,00,00,00,00,00,00,01,00,00,00,01,00,00,00,01,00,00,00,fc,ff,ff,\
  ff,43,00,00,00,eb,03,00,00,5f,01,00,00,05,00,00,00,ff,ff,ff,0f,01,00,00,00,\
  00,00,00,00,02,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,ff,ff,ff,0f,00,00,00,00,00,00,00,00,03,00,\
  00,00,01,00,00,00,01,00,00,00,4e,04,00,00,5c,02,00,00,84,07,00,00,71,03,00,\
  00,05,00,00,00,07,00,00,00,0b,00,00,00,00,00,00,00,04,00,00,00,01,00,00,00,\
  01,00,00,00,68,03,00,00,95,02,00,00,99,06,00,00,89,03,00,00,05,00,00,00,07,\
  00,00,00,0b,00,00,00,00,00,00,00,05,00,00,00,01,00,00,00,01,00,00,00,01,01,\
  00,00,07,01,00,00,bd,03,00,00,97,02,00,00,02,00,00,00,ff,ff,ff,0f,06,00,00,\
  00,00,00,00,00,06,00,00,00,01,00,00,00,01,00,00,00,81,00,00,00,50,01,00,00,\
  2d,03,00,00,d0,02,00,00,01,00,00,00,00,00,00,80,00,00,00,00,00,00,00,00,07,\
  00,00,00,01,00,00,00,01,00,00,00,50,00,00,00,7a,00,00,00,0c,03,00,00,0a,02,\
  00,00,02,00,00,00,ff,ff,ff,0f,04,00,00,00,00,00,00,00,08,00,00,00,01,00,00,\
  00,01,00,00,00,10,00,00,00,3a,00,00,00,cc,02,00,00,ca,01,00,00,03,00,00,00,\
  ff,ff,ff,0f,06,00,00,00,00,00,00,00,09,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,ff,ff,ff,0f,00,00,\
  00,00,00,00,00,00,0a,00,00,00,01,00,00,00,01,00,00,00,40,00,00,00,6a,00,00,\
  00,fc,02,00,00,fa,01,00,00,05,00,00,00,04,00,00,00,03,00,00,00,00,00,00,00,\
  0b,00,00,00,01,00,00,00,01,00,00,00,60,00,00,00,8a,00,00,00,1c,03,00,00,1a,\
  02,00,00,05,00,00,00,05,00,00,00,0a,00,00,00,00,00,00,00,0c,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,ff,ff,ff,0f,00,00,00,00,00,00,00,00,0d,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,ff,ff,ff,0f,00,\
  00,00,00,00,00,00,00,00,00,03,00,10,00,08,00,09,00,00,00,f8,0c,00,00,01,00,\
  01,00,38,00,2c,00,2c,00,00,00,02,00,00,00,03,00,00,00,ff,ff,ff,ff,ff,ff,ff,\
  ff,ff,ff,ff,ff,ff,ff,ff,ff,00,00,00,00,d4,00,00,00,00,06,00,00,10,04,00,00,\
  67,00,69,00,03,00,03,00,78,00,6e,00,07,00,00,00,06,00,00,00,64,00,00,00,14,\
  00,00,00,00,00,00,80,06,00,00,40,06,00,00,00,e7,03,00,00,00,00,00,00,78,07,\
  00,00,16,01,00,00,07,00,00,00,01,00,00,00,01,00,00,00,50,00,00,00,7a,00,00,\
  00,0c,03,00,00,0a,02,00,00,02,00,00,00,01,00,00,00,04,00,00,00,00,00,00,00,\
  00,00,00,80,02,00,00,40,06,00,00,00,01,00,00,40,02,00,00,00,00,00,62,00,03,\
  00,03,00,80,00,78,00,05,00,00,00,03,00,00,00,64,00,00,00,14,00,00,00,00,00,\
  00,80,08,00,00,40,07,00,00,00,00,00,00,00,14,01,00,00,e7,03,00,00,be,02,00,\
  00,05,00,00,00,01,00,00,00,01,00,00,00,01,01,00,00,07,01,00,00,bd,03,00,00,\
  97,02,00,00,02,00,00,00,00,00,00,00,06,00,00,00,00,00,00,00,00,00,00,80,02,\
  00,00,40,08,00,00,40,00,00,00,00,02,00,00,00,01,00,00,00,00,00,00,00,01,00,\
  00,00,03,00,03,00,78,00,6c,00,0b,00,00,00,07,00,00,00,64,00,00,00,14,00,00,\
  00,00,00,00,80,04,00,00,40,06,00,00,00,1e,05,00,00,16,01,00,00,78,07,00,00,\
  bd,02,00,00,0b,00,00,00,01,00,00,00,01,00,00,00,60,00,00,00,8a,00,00,00,1c,\
  03,00,00,1a,02,00,00,05,00,00,00,05,00,00,00,0a,00,00,00,00,00,00,00,00,00,\
  00,80,01,00,00,40,01,00,00,00,05,00,00,40,01,00,00,00,00,00,00,00,03,00,03,\
  00,78,00,6c,00,04,00,00,00,01,00,00,00,64,00,00,00,14,00,00,00,00,00,00,80,\
  07,00,00,40,07,00,00,00,e7,03,00,00,16,01,00,00,1e,05,00,00,bd,02,00,00,04,\
  00,00,00,01,00,00,00,01,00,00,00,68,03,00,00,95,02,00,00,99,06,00,00,89,03,\
  00,00,05,00,00,00,07,00,00,00,0b,00,00,00,00,00,00,00,00,00,00,80,06,00,00,\
  40,07,00,00,40,02,00,00,00,02,00,00,00,10,00,04,00,03,00,03,00,80,00,74,00,\
  03,00,00,00,04,00,00,00,64,00,00,00,14,00,00,00,00,00,00,80,04,00,00,40,07,\
  00,00,00,1e,05,00,00,16,01,00,00,78,07,00,00,bd,02,00,00,03,00,00,00,01,00,\
  00,00,01,00,00,00,4e,04,00,00,5c,02,00,00,84,07,00,00,71,03,00,00,05,00,00,\
  00,07,00,00,00,0b,00,00,00,00,00,00,00,00,00,00,80,05,00,00,40,04,00,00,00,\
  07,00,00,00,05,00,00,00,00,00,00,00,00,00,00,00,10,00,04,00,03,00,03,00,80,\
  00,74,00,0a,00,00,00,05,00,00,00,64,00,00,00,14,00,00,00,00,00,00,80,05,00,\
  00,40,07,00,00,00,1e,05,00,00,16,01,00,00,78,07,00,00,bd,02,00,00,0a,00,00,\
  00,01,00,00,00,01,00,00,00,40,00,00,00,6a,00,00,00,fc,02,00,00,fa,01,00,00,\
  05,00,00,00,04,00,00,00,03,00,00,00,00,00,00,00,00,00,00,80,07,00,00,40,05,\
  00,00,00,04,00,00,40,05,00,00,00,00,00,00,00,14,00,00,00,10,00,04,00,03,00,\
  03,00,90,00,86,00,08,00,00,00,02,00,00,00,64,00,00,00,14,00,00,00,00,00,00,\
  80,01,00,00,40,07,00,00,00,e7,03,00,00,bd,02,00,00,78,07,00,00,22,04,00,00,\
  08,00,00,00,01,00,00,00,01,00,00,00,10,00,00,00,3a,00,00,00,cc,02,00,00,ca,\
  01,00,00,03,00,00,00,00,00,00,00,06,00,00,00,00,00,00,00,00,00,00,80,ff,ff,\
  ff,0f,03,00,00,40,06,00,00,40,01,00,00,00,00,00,00,00,11,00,00,00,01,00,00,\
  00,01,00,00,00,40,00,65,00,73,00,70,00,00,00,50,00,03,00,03,00,80,00,74,00,\
  06,00,00,00,00,00,00,00,64,00,00,00,14,00,00,00,00,00,00,80,03,00,00,40,06,\
  00,00,00,00,00,00,00,be,02,00,00,e7,03,00,00,22,04,00,00,06,00,00,00,01,00,\
  00,00,01,00,00,00,81,00,00,00,50,01,00,00,2d,03,00,00,d0,02,00,00,01,00,00,\
  00,00,00,00,80,00,00,00,00,00,00,00,00,ff,ff,ff,0f,ff,ff,ff,0f,ff,ff,ff,0f,\
  ff,ff,ff,0f,00,00,00,00,ec,ff,ff,ff,00,00,00,00,00,00,00,00,03,00,03,00,10,\
  01,06,01,01,00,00,00,08,00,00,00,64,00,00,00,14,00,00,00,00,00,00,80,08,00,\
  00,40,06,00,00,00,00,00,00,00,00,00,00,00,e7,03,00,00,14,01,00,00,01,00,00,\
  00,01,00,00,00,01,00,00,00,fc,ff,ff,ff,43,00,00,00,eb,03,00,00,5f,01,00,00,\
  05,00,00,00,ff,ff,ff,0f,01,00,00,00,00,00,00,00,00,00,00,80,03,00,00,40,08,\
  00,00,00,03,00,00,00,02,00,00,00,43,00,3a,00,5c,00,50,00,72,00,6f,00,67,00,\
  72,00,61,00,6d,00,20,00,46,00,69,00,6c,00,65,00,73,00,5c,00,44,00,65,00,62,\
  00,75,00,67,00,67,00,69,00,6e,00,67,00,20,00,54,00,6f,00,6f,00,6c,00,73,00,\
  20,00,66,00,6f,00,72,00,20,00,57,00,69,00,6e,00,64,00,6f,00,77,00,73,00,20,\
  00,28,00,78,00,36,00,34,00,29,00,5c,00,74,00,68,00,65,00,6d,00,65,00,73,00,\
  5c,00,70,00,6c,00,61,00,63,00,65,00,68,00,6f,00,6c,00,64,00,31,00,2e,00,63,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,00,01,00,03,00,10,00,04,00,\
  09,00,00,00,10,00,04,00,29,00,00,00,a8,00,9c,00,01,00,00,00,43,00,3a,00,5c,\
  00,50,00,72,00,6f,00,67,00,72,00,61,00,6d,00,20,00,46,00,69,00,6c,00,65,00,\
  73,00,5c,00,44,00,65,00,62,00,75,00,67,00,67,00,69,00,6e,00,67,00,20,00,54,\
  00,6f,00,6f,00,6c,00,73,00,20,00,66,00,6f,00,72,00,20,00,57,00,69,00,6e,00,\
  64,00,6f,00,77,00,73,00,20,00,28,00,78,00,36,00,34,00,29,00,5c,00,74,00,68,\
  00,65,00,6d,00,65,00,73,00,5c,00,70,00,6c,00,61,00,63,00,65,00,68,00,6f,00,\
  6c,00,64,00,31,00,2e,00,63,00,00,00,02,00,10,00,04,00,19,19,19,00,00,00,00,\
  00

[HKEY_CURRENT_USER\Software\Microsoft\Windbg\Workspaces\Dump]
"Default"=hex:57,44,57,53,01,00,00,00,33,00,00,00,68,00,5c,00,f3,ff,ff,ff,00,\
  00,00,00,00,00,00,00,00,00,00,00,90,01,00,00,00,00,00,00,03,02,01,31,43,00,\
  6f,00,6e,00,73,00,6f,00,6c,00,61,00,73,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,02,00,10,00,04,00,19,\
  19,19,00,00,00,00,00,01,00,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,02,00,\
  02,00,10,00,04,00,6f,6d,7e,00,00,00,00,00,03,00,02,00,10,00,04,00,cf,ce,9a,\
  00,00,00,00,00,08,00,02,00,10,00,04,00,80,31,3a,00,00,00,00,00,09,00,02,00,\
  10,00,04,00,6f,6d,7e,00,00,00,00,00,0a,00,00,00,10,00,04,00,20,00,00,00,00,\
  00,00,00,12,00,00,00,10,00,04,00,01,00,00,00,00,00,00,00,0a,00,02,00,10,00,\
  04,00,e6,1e,3c,00,00,00,00,00,0b,00,02,00,10,00,04,00,52,54,58,00,00,00,00,\
  00,10,00,02,00,10,00,04,00,cf,69,4b,00,00,00,00,00,11,00,02,00,10,00,04,00,\
  75,a6,87,00,00,00,00,00,12,00,02,00,10,00,04,00,75,a6,87,00,00,00,00,00,13,\
  00,02,00,10,00,04,00,75,87,a6,00,00,00,00,00,18,00,02,00,10,00,04,00,af,c4,\
  db,00,00,00,00,00,19,00,02,00,10,00,04,00,33,99,ff,00,00,00,00,00,23,00,02,\
  00,10,00,04,00,52,54,58,00,00,00,00,00,00,ff,02,00,10,00,04,00,cf,ce,9a,00,\
  00,00,00,00,01,ff,02,00,10,00,04,00,19,19,19,00,00,00,00,00,02,ff,02,00,10,\
  00,04,00,80,31,3a,00,00,00,00,00,03,ff,02,00,10,00,04,00,19,19,19,00,00,00,\
  00,00,08,ff,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,09,ff,02,00,10,00,04,\
  00,19,19,19,00,00,00,00,00,0a,ff,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,\
  0b,ff,02,00,10,00,04,00,19,19,19,00,00,00,00,00,10,ff,02,00,10,00,04,00,cf,\
  ce,9a,00,00,00,00,00,11,ff,02,00,10,00,04,00,19,19,19,00,00,00,00,00,12,ff,\
  02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,13,ff,02,00,10,00,04,00,19,19,19,\
  00,00,00,00,00,38,ff,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,39,ff,02,00,\
  10,00,04,00,19,19,19,00,00,00,00,00,3a,ff,02,00,10,00,04,00,cf,ce,9a,00,00,\
  00,00,00,40,ff,02,00,10,00,04,00,cf,ce,9a,00,21,06,00,00,41,ff,02,00,10,00,\
  04,00,19,19,19,00,25,06,00,00,23,00,00,00,10,00,02,00,00,00,00,00,00,00,00,\
  00,30,00,00,00,b8,00,ae,00,22,00,43,00,3a,00,5c,00,55,00,73,00,65,00,72,00,\
  73,00,5c,00,62,00,75,00,72,00,6c,00,79,00,5c,00,44,00,6f,00,63,00,75,00,6d,\
  00,65,00,6e,00,74,00,73,00,5c,00,56,00,69,00,73,00,75,00,61,00,6c,00,20,00,\
  53,00,74,00,75,00,64,00,69,00,6f,00,20,00,32,00,30,00,31,00,30,00,5c,00,50,\
  00,72,00,6f,00,6a,00,65,00,63,00,74,00,73,00,5c,00,50,00,72,00,6f,00,63,00,\
  65,00,73,00,73,00,49,00,6e,00,6a,00,65,00,63,00,74,00,69,00,6f,00,6e,00,5c,\
  00,62,00,69,00,6e,00,5c,00,57,00,69,00,6e,00,33,00,32,00,5c,00,44,00,65,00,\
  62,00,75,00,67,00,00,00,00,00,22,00,00,00,80,00,74,00,73,00,72,00,76,00,2a,\
  00,43,00,3a,00,5c,00,53,00,79,00,6d,00,62,00,6f,00,6c,00,73,00,2a,00,68,00,\
  74,00,74,00,70,00,3a,00,2f,00,2f,00,6d,00,73,00,64,00,6c,00,2e,00,6d,00,69,\
  00,63,00,72,00,6f,00,73,00,6f,00,66,00,74,00,2e,00,63,00,6f,00,6d,00,2f,00,\
  64,00,6f,00,77,00,6e,00,6c,00,6f,00,61,00,64,00,2f,00,73,00,79,00,6d,00,62,\
  00,6f,00,6c,00,73,00,00,00,43,00,3a,00,20,00,00,00,c0,00,b2,00,4c,01,00,00,\
  00,00,00,00,09,00,08,00,07,00,06,00,0e,00,0a,00,05,00,04,00,0b,00,52,00,51,\
  00,50,00,4f,00,4e,00,4d,00,4b,00,4a,00,4c,00,02,00,0c,00,0f,00,03,00,01,00,\
  00,00,1e,00,30,00,31,00,32,00,33,00,34,00,35,00,36,00,37,00,10,00,11,00,12,\
  00,13,00,14,00,15,00,16,00,17,00,18,00,19,00,1a,00,1b,00,1c,00,1d,00,1f,00,\
  20,00,21,00,22,00,23,00,24,00,25,00,26,00,27,00,28,00,29,00,2a,00,2b,00,2c,\
  00,2d,00,2e,00,2f,00,38,00,39,00,3a,00,3b,00,3c,00,3d,00,3e,00,3f,00,40,00,\
  41,00,42,00,43,00,44,00,45,00,46,00,47,00,48,00,49,00,53,00,54,00,0d,00,65,\
  00,73,00,73,00,04,00,02,00,10,00,04,00,80,31,3a,00,63,00,00,00,3d,00,00,00,\
  10,00,04,00,00,00,00,00,72,00,73,00,0c,00,00,00,10,00,04,00,01,00,00,00,5c,\
  00,44,00,3c,00,00,00,10,00,04,00,01,00,00,00,74,00,73,00,3f,00,00,00,10,00,\
  04,00,01,00,00,00,6c,00,20,00,24,00,00,00,78,00,6a,00,43,00,3a,00,5c,00,55,\
  00,73,00,65,00,72,00,73,00,5c,00,62,00,75,00,72,00,6c,00,79,00,5c,00,44,00,\
  6f,00,63,00,75,00,6d,00,65,00,6e,00,74,00,73,00,5c,00,56,00,69,00,73,00,75,\
  00,61,00,6c,00,20,00,53,00,74,00,75,00,64,00,69,00,6f,00,20,00,32,00,30,00,\
  31,00,30,00,5c,00,50,00,72,00,6f,00,6a,00,65,00,63,00,74,00,73,00,00,00,00,\
  00,00,00,00,00,05,00,02,00,10,00,04,00,f8,f8,f8,00,00,00,00,00,06,00,02,00,\
  10,00,04,00,e6,1e,3c,00,00,00,00,00,07,00,02,00,10,00,04,00,f8,f8,f8,00,00,\
  00,00,00,0d,00,02,00,10,00,04,00,f8,f8,f8,00,00,00,00,00,0e,00,02,00,10,00,\
  04,00,33,99,ff,00,00,00,00,00,0f,00,02,00,10,00,04,00,f8,f8,f8,00,00,00,00,\
  00,14,00,02,00,10,00,04,00,cd,a8,69,00,00,00,00,00,15,00,02,00,10,00,04,00,\
  f8,f8,f8,00,00,00,00,00,16,00,02,00,10,00,04,00,6f,6d,7e,00,00,00,00,00,17,\
  00,02,00,10,00,04,00,af,c4,db,00,00,00,00,00,24,00,02,00,10,00,04,00,33,99,\
  ff,00,00,00,00,00,04,ff,02,00,10,00,04,00,d2,d2,3a,00,00,00,00,00,05,ff,02,\
  00,10,00,04,00,19,19,19,00,00,00,00,00,06,ff,02,00,10,00,04,00,f8,f8,f8,00,\
  00,00,00,00,07,ff,02,00,10,00,04,00,19,19,19,00,00,00,00,00,0c,ff,02,00,10,\
  00,04,00,d2,d2,3a,00,00,00,00,00,0d,ff,02,00,10,00,04,00,19,19,19,00,00,00,\
  00,00,0e,ff,02,00,10,00,04,00,f8,f8,f8,00,00,00,00,00,0f,ff,02,00,10,00,04,\
  00,19,19,19,00,00,00,00,00,3b,ff,02,00,10,00,04,00,19,19,19,00,00,00,00,00,\
  3c,ff,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,3d,ff,02,00,10,00,04,00,19,\
  19,19,00,00,00,00,00,3e,ff,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,3f,ff,\
  02,00,10,00,04,00,19,19,19,00,00,00,00,00,2c,00,00,00,80,00,74,00,43,00,3a,\
  00,5c,00,50,00,72,00,6f,00,67,00,72,00,61,00,6d,00,20,00,46,00,69,00,6c,00,\
  65,00,73,00,5c,00,44,00,65,00,62,00,75,00,67,00,67,00,69,00,6e,00,67,00,20,\
  00,54,00,6f,00,6f,00,6c,00,73,00,20,00,66,00,6f,00,72,00,20,00,57,00,69,00,\
  6e,00,64,00,6f,00,77,00,73,00,20,00,28,00,78,00,36,00,34,00,29,00,5c,00,74,\
  00,68,00,65,00,6d,00,65,00,73,00,00,00,00,00,00,00,04,00,03,00,10,00,04,00,\
  00,00,00,00,00,00,00,00,04,00,01,00,70,02,68,02,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,ff,ff,\
  ff,0f,00,00,00,00,00,00,00,00,01,00,00,00,01,00,00,00,01,00,00,00,fc,ff,ff,\
  ff,43,00,00,00,eb,03,00,00,5f,01,00,00,05,00,00,00,ff,ff,ff,0f,01,00,00,00,\
  00,00,00,00,02,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,ff,ff,ff,0f,00,00,00,00,00,00,00,00,03,00,\
  00,00,01,00,00,00,01,00,00,00,4e,04,00,00,5c,02,00,00,84,07,00,00,71,03,00,\
  00,05,00,00,00,07,00,00,00,0b,00,00,00,00,00,00,00,04,00,00,00,01,00,00,00,\
  01,00,00,00,68,03,00,00,95,02,00,00,99,06,00,00,89,03,00,00,05,00,00,00,07,\
  00,00,00,0b,00,00,00,00,00,00,00,05,00,00,00,01,00,00,00,01,00,00,00,01,01,\
  00,00,07,01,00,00,bd,03,00,00,97,02,00,00,02,00,00,00,ff,ff,ff,0f,06,00,00,\
  00,00,00,00,00,06,00,00,00,01,00,00,00,01,00,00,00,81,00,00,00,50,01,00,00,\
  2d,03,00,00,d0,02,00,00,01,00,00,00,00,00,00,80,00,00,00,00,00,00,00,00,07,\
  00,00,00,01,00,00,00,01,00,00,00,50,00,00,00,7a,00,00,00,0c,03,00,00,0a,02,\
  00,00,02,00,00,00,ff,ff,ff,0f,04,00,00,00,00,00,00,00,08,00,00,00,01,00,00,\
  00,01,00,00,00,10,00,00,00,3a,00,00,00,cc,02,00,00,ca,01,00,00,03,00,00,00,\
  ff,ff,ff,0f,06,00,00,00,00,00,00,00,09,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,ff,ff,ff,0f,00,00,\
  00,00,00,00,00,00,0a,00,00,00,01,00,00,00,01,00,00,00,40,00,00,00,6a,00,00,\
  00,fc,02,00,00,fa,01,00,00,05,00,00,00,04,00,00,00,03,00,00,00,00,00,00,00,\
  0b,00,00,00,01,00,00,00,01,00,00,00,60,00,00,00,8a,00,00,00,1c,03,00,00,1a,\
  02,00,00,05,00,00,00,05,00,00,00,0a,00,00,00,00,00,00,00,0c,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,ff,ff,ff,0f,00,00,00,00,00,00,00,00,0d,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,ff,ff,ff,0f,00,\
  00,00,00,00,00,00,00,00,00,03,00,10,00,08,00,09,00,00,00,f8,0c,00,00,01,00,\
  01,00,38,00,2c,00,2c,00,00,00,02,00,00,00,03,00,00,00,ff,ff,ff,ff,ff,ff,ff,\
  ff,ff,ff,ff,ff,ff,ff,ff,ff,00,00,00,00,d4,00,00,00,00,06,00,00,10,04,00,00,\
  67,00,69,00,03,00,03,00,78,00,6e,00,07,00,00,00,06,00,00,00,64,00,00,00,14,\
  00,00,00,00,00,00,80,06,00,00,40,06,00,00,00,e7,03,00,00,00,00,00,00,78,07,\
  00,00,16,01,00,00,07,00,00,00,01,00,00,00,01,00,00,00,50,00,00,00,7a,00,00,\
  00,0c,03,00,00,0a,02,00,00,02,00,00,00,01,00,00,00,04,00,00,00,00,00,00,00,\
  00,00,00,80,02,00,00,40,06,00,00,00,01,00,00,40,02,00,00,00,00,00,62,00,03,\
  00,03,00,80,00,78,00,05,00,00,00,03,00,00,00,64,00,00,00,14,00,00,00,00,00,\
  00,80,08,00,00,40,07,00,00,00,00,00,00,00,14,01,00,00,e7,03,00,00,be,02,00,\
  00,05,00,00,00,01,00,00,00,01,00,00,00,01,01,00,00,07,01,00,00,bd,03,00,00,\
  97,02,00,00,02,00,00,00,00,00,00,00,06,00,00,00,00,00,00,00,00,00,00,80,02,\
  00,00,40,08,00,00,40,00,00,00,00,02,00,00,00,01,00,00,00,00,00,00,00,01,00,\
  00,00,03,00,03,00,78,00,6c,00,0b,00,00,00,07,00,00,00,64,00,00,00,14,00,00,\
  00,00,00,00,80,04,00,00,40,06,00,00,00,1e,05,00,00,16,01,00,00,78,07,00,00,\
  bd,02,00,00,0b,00,00,00,01,00,00,00,01,00,00,00,60,00,00,00,8a,00,00,00,1c,\
  03,00,00,1a,02,00,00,05,00,00,00,05,00,00,00,0a,00,00,00,00,00,00,00,00,00,\
  00,80,01,00,00,40,01,00,00,00,05,00,00,40,01,00,00,00,00,00,00,00,03,00,03,\
  00,78,00,6c,00,04,00,00,00,01,00,00,00,64,00,00,00,14,00,00,00,00,00,00,80,\
  07,00,00,40,07,00,00,00,e7,03,00,00,16,01,00,00,1e,05,00,00,bd,02,00,00,04,\
  00,00,00,01,00,00,00,01,00,00,00,68,03,00,00,95,02,00,00,99,06,00,00,89,03,\
  00,00,05,00,00,00,07,00,00,00,0b,00,00,00,00,00,00,00,00,00,00,80,06,00,00,\
  40,07,00,00,40,02,00,00,00,02,00,00,00,10,00,04,00,03,00,03,00,80,00,74,00,\
  03,00,00,00,04,00,00,00,64,00,00,00,14,00,00,00,00,00,00,80,04,00,00,40,07,\
  00,00,00,1e,05,00,00,16,01,00,00,78,07,00,00,bd,02,00,00,03,00,00,00,01,00,\
  00,00,01,00,00,00,4e,04,00,00,5c,02,00,00,84,07,00,00,71,03,00,00,05,00,00,\
  00,07,00,00,00,0b,00,00,00,00,00,00,00,00,00,00,80,05,00,00,40,04,00,00,00,\
  07,00,00,00,05,00,00,00,00,00,00,00,00,00,00,00,10,00,04,00,03,00,03,00,80,\
  00,74,00,0a,00,00,00,05,00,00,00,64,00,00,00,14,00,00,00,00,00,00,80,05,00,\
  00,40,07,00,00,00,1e,05,00,00,16,01,00,00,78,07,00,00,bd,02,00,00,0a,00,00,\
  00,01,00,00,00,01,00,00,00,40,00,00,00,6a,00,00,00,fc,02,00,00,fa,01,00,00,\
  05,00,00,00,04,00,00,00,03,00,00,00,00,00,00,00,00,00,00,80,07,00,00,40,05,\
  00,00,00,04,00,00,40,05,00,00,00,00,00,00,00,14,00,00,00,10,00,04,00,03,00,\
  03,00,90,00,86,00,08,00,00,00,02,00,00,00,64,00,00,00,14,00,00,00,00,00,00,\
  80,01,00,00,40,07,00,00,00,e7,03,00,00,bd,02,00,00,78,07,00,00,22,04,00,00,\
  08,00,00,00,01,00,00,00,01,00,00,00,10,00,00,00,3a,00,00,00,cc,02,00,00,ca,\
  01,00,00,03,00,00,00,00,00,00,00,06,00,00,00,00,00,00,00,00,00,00,80,ff,ff,\
  ff,0f,03,00,00,40,06,00,00,40,01,00,00,00,00,00,00,00,11,00,00,00,01,00,00,\
  00,01,00,00,00,40,00,65,00,73,00,70,00,00,00,50,00,03,00,03,00,80,00,74,00,\
  06,00,00,00,00,00,00,00,64,00,00,00,14,00,00,00,00,00,00,80,03,00,00,40,06,\
  00,00,00,00,00,00,00,be,02,00,00,e7,03,00,00,22,04,00,00,06,00,00,00,01,00,\
  00,00,01,00,00,00,81,00,00,00,50,01,00,00,2d,03,00,00,d0,02,00,00,01,00,00,\
  00,00,00,00,80,00,00,00,00,00,00,00,00,ff,ff,ff,0f,ff,ff,ff,0f,ff,ff,ff,0f,\
  ff,ff,ff,0f,00,00,00,00,ec,ff,ff,ff,00,00,00,00,00,00,00,00,03,00,03,00,10,\
  01,06,01,01,00,00,00,08,00,00,00,64,00,00,00,14,00,00,00,00,00,00,80,08,00,\
  00,40,06,00,00,00,00,00,00,00,00,00,00,00,e7,03,00,00,14,01,00,00,01,00,00,\
  00,01,00,00,00,01,00,00,00,fc,ff,ff,ff,43,00,00,00,eb,03,00,00,5f,01,00,00,\
  05,00,00,00,ff,ff,ff,0f,01,00,00,00,00,00,00,00,00,00,00,80,03,00,00,40,08,\
  00,00,00,03,00,00,00,02,00,00,00,43,00,3a,00,5c,00,50,00,72,00,6f,00,67,00,\
  72,00,61,00,6d,00,20,00,46,00,69,00,6c,00,65,00,73,00,5c,00,44,00,65,00,62,\
  00,75,00,67,00,67,00,69,00,6e,00,67,00,20,00,54,00,6f,00,6f,00,6c,00,73,00,\
  20,00,66,00,6f,00,72,00,20,00,57,00,69,00,6e,00,64,00,6f,00,77,00,73,00,20,\
  00,28,00,78,00,36,00,34,00,29,00,5c,00,74,00,68,00,65,00,6d,00,65,00,73,00,\
  5c,00,70,00,6c,00,61,00,63,00,65,00,68,00,6f,00,6c,00,64,00,31,00,2e,00,63,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,00,01,00,03,00,10,00,04,00,\
  09,00,00,00,10,00,04,00,29,00,00,00,a8,00,9c,00,01,00,00,00,43,00,3a,00,5c,\
  00,50,00,72,00,6f,00,67,00,72,00,61,00,6d,00,20,00,46,00,69,00,6c,00,65,00,\
  73,00,5c,00,44,00,65,00,62,00,75,00,67,00,67,00,69,00,6e,00,67,00,20,00,54,\
  00,6f,00,6f,00,6c,00,73,00,20,00,66,00,6f,00,72,00,20,00,57,00,69,00,6e,00,\
  64,00,6f,00,77,00,73,00,20,00,28,00,78,00,36,00,34,00,29,00,5c,00,74,00,68,\
  00,65,00,6d,00,65,00,73,00,5c,00,70,00,6c,00,61,00,63,00,65,00,68,00,6f,00,\
  6c,00,64,00,31,00,2e,00,63,00,00,00,02,00,10,00,04,00,19,19,19,00,00,00,00,\
  00

[HKEY_CURRENT_USER\Software\Microsoft\Windbg\Workspaces\Explicit]
"Default"=hex:57,44,57,53,01,00,00,00,44,00,00,00,10,00,04,00,01,00,00,00,0d,\
  f0,ad,ba,04,00,03,00,10,00,04,00,00,00,00,00,0d,f0,ad,ba,04,00,01,00,70,02,\
  68,02,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,ff,ff,ff,0f,00,00,00,00,00,00,00,00,01,00,00,00,\
  01,00,00,00,01,00,00,00,fc,ff,ff,ff,43,00,00,00,eb,03,00,00,5f,01,00,00,05,\
  00,00,00,ff,ff,ff,0f,01,00,00,00,00,00,00,00,02,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,ff,ff,ff,\
  0f,00,00,00,00,00,00,00,00,03,00,00,00,01,00,00,00,01,00,00,00,4e,04,00,00,\
  5c,02,00,00,84,07,00,00,71,03,00,00,05,00,00,00,07,00,00,00,0b,00,00,00,00,\
  00,00,00,04,00,00,00,01,00,00,00,01,00,00,00,68,03,00,00,95,02,00,00,99,06,\
  00,00,89,03,00,00,05,00,00,00,07,00,00,00,0b,00,00,00,00,00,00,00,05,00,00,\
  00,01,00,00,00,01,00,00,00,01,01,00,00,07,01,00,00,bd,03,00,00,97,02,00,00,\
  02,00,00,00,ff,ff,ff,0f,06,00,00,00,00,00,00,00,06,00,00,00,01,00,00,00,01,\
  00,00,00,81,00,00,00,50,01,00,00,2d,03,00,00,d0,02,00,00,01,00,00,00,00,00,\
  00,80,00,00,00,00,00,00,00,00,07,00,00,00,01,00,00,00,01,00,00,00,fe,ff,ff,\
  ff,45,00,00,00,3e,06,00,00,bd,01,00,00,02,00,00,00,00,00,00,80,00,00,00,00,\
  00,00,00,00,08,00,00,00,01,00,00,00,01,00,00,00,1a,03,00,00,da,00,00,00,3e,\
  06,00,00,69,01,00,00,03,00,00,00,03,00,00,00,05,00,00,00,00,00,00,00,09,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,ff,ff,ff,0f,00,00,00,00,00,00,00,00,0a,00,00,00,01,00,00,00,\
  01,00,00,00,40,00,00,00,6a,00,00,00,fc,02,00,00,fa,01,00,00,05,00,00,00,04,\
  00,00,00,03,00,00,00,00,00,00,00,0b,00,00,00,01,00,00,00,01,00,00,00,60,00,\
  00,00,8a,00,00,00,1c,03,00,00,1a,02,00,00,05,00,00,00,05,00,00,00,0a,00,00,\
  00,00,00,00,00,0c,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,ff,ff,ff,0f,00,00,00,00,00,00,00,00,0d,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,ff,ff,ff,0f,00,00,00,00,00,00,00,00,00,00,03,00,10,00,08,\
  00,08,00,00,00,f8,0c,00,00,01,00,01,00,38,00,2c,00,2c,00,00,00,02,00,00,00,\
  03,00,00,00,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,ff,00,00,00,00,d4,\
  00,00,00,00,06,00,00,10,04,00,00,0d,f0,ad,ba,03,00,03,00,78,00,6c,00,04,00,\
  00,00,01,00,00,00,64,00,00,00,14,00,00,00,ff,ff,ff,0f,ff,ff,ff,0f,05,01,00,\
  00,74,04,00,00,bf,00,00,00,24,05,00,00,17,02,00,00,04,00,00,00,01,00,00,00,\
  01,00,00,00,68,03,00,00,95,02,00,00,99,06,00,00,89,03,00,00,05,00,00,00,07,\
  00,00,00,0b,00,00,00,00,00,00,00,ff,ff,ff,0f,ff,ff,ff,0f,ff,ff,ff,0f,ff,ff,\
  ff,0f,00,00,00,00,0d,f0,ad,ba,03,00,03,00,80,00,74,00,0a,00,00,00,05,00,00,\
  00,64,00,00,00,14,00,00,00,ff,ff,ff,0f,ff,ff,ff,0f,05,01,00,00,74,04,00,00,\
  bf,00,00,00,3c,06,00,00,17,02,00,00,0a,00,00,00,01,00,00,00,01,00,00,00,40,\
  00,00,00,6a,00,00,00,fc,02,00,00,fa,01,00,00,05,00,00,00,04,00,00,00,03,00,\
  00,00,00,00,00,00,ff,ff,ff,0f,ff,ff,ff,0f,ff,ff,ff,0f,ff,ff,ff,0f,00,00,00,\
  00,00,00,00,00,14,00,00,00,0d,f0,ad,ba,03,00,03,00,80,00,74,00,03,00,00,00,\
  04,00,00,00,64,00,00,00,14,00,00,00,ff,ff,ff,0f,ff,ff,ff,0f,05,01,00,00,74,\
  04,00,00,bf,00,00,00,3c,06,00,00,17,02,00,00,03,00,00,00,01,00,00,00,01,00,\
  00,00,4e,04,00,00,5c,02,00,00,84,07,00,00,71,03,00,00,05,00,00,00,07,00,00,\
  00,0b,00,00,00,00,00,00,00,ff,ff,ff,0f,ff,ff,ff,0f,ff,ff,ff,0f,ff,ff,ff,0f,\
  00,00,00,00,00,00,00,00,00,00,00,00,0d,f0,ad,ba,03,00,03,00,78,00,6c,00,0b,\
  00,00,00,07,00,00,00,64,00,00,00,14,00,00,00,ff,ff,ff,0f,ff,ff,ff,0f,04,01,\
  00,00,74,04,00,00,bf,00,00,00,3c,06,00,00,17,02,00,00,0b,00,00,00,01,00,00,\
  00,01,00,00,00,60,00,00,00,8a,00,00,00,1c,03,00,00,1a,02,00,00,05,00,00,00,\
  05,00,00,00,0a,00,00,00,00,00,00,00,ff,ff,ff,0f,ff,ff,ff,0f,ff,ff,ff,0f,ff,\
  ff,ff,0f,00,00,00,00,0d,f0,ad,ba,03,00,03,00,80,00,78,00,05,00,00,00,03,00,\
  00,00,64,00,00,00,14,00,00,00,00,00,00,80,02,00,00,40,07,00,00,00,00,00,00,\
  00,91,00,00,00,1c,03,00,00,48,01,00,00,05,00,00,00,01,00,00,00,01,00,00,00,\
  01,01,00,00,07,01,00,00,bd,03,00,00,97,02,00,00,02,00,00,00,00,00,00,00,06,\
  00,00,00,00,00,00,00,00,00,00,80,06,00,00,40,02,00,00,40,00,00,00,00,02,00,\
  00,00,01,00,00,00,00,00,00,00,01,00,00,00,03,00,03,00,90,00,86,00,08,00,00,\
  00,02,00,00,00,64,00,00,00,14,00,00,00,00,00,00,80,02,00,00,40,07,00,00,00,\
  1c,03,00,00,91,00,00,00,3c,06,00,00,48,01,00,00,08,00,00,00,01,00,00,00,01,\
  00,00,00,1a,03,00,00,da,00,00,00,3e,06,00,00,69,01,00,00,03,00,00,00,03,00,\
  00,00,05,00,00,00,00,00,00,00,00,00,00,80,03,00,00,40,03,00,00,00,02,00,00,\
  00,01,00,00,00,00,00,00,00,11,00,00,00,01,00,00,00,01,00,00,00,40,00,65,00,\
  73,00,70,00,00,00,ad,ba,03,00,03,00,80,00,74,00,06,00,00,00,00,00,00,00,64,\
  00,00,00,14,00,00,00,00,00,00,80,03,00,00,40,06,00,00,00,00,00,00,00,48,01,\
  00,00,3c,06,00,00,e4,02,00,00,06,00,00,00,01,00,00,00,01,00,00,00,81,00,00,\
  00,50,01,00,00,2d,03,00,00,d0,02,00,00,01,00,00,00,00,00,00,80,00,00,00,00,\
  00,00,00,00,ff,ff,ff,0f,ff,ff,ff,0f,ff,ff,ff,0f,ff,ff,ff,0f,00,00,00,00,ec,\
  ff,ff,ff,00,00,00,00,0d,f0,ad,ba,03,00,03,00,78,00,6e,00,07,00,00,00,06,00,\
  00,00,64,00,00,00,14,00,00,00,00,00,00,80,06,00,00,40,06,00,00,00,00,00,00,\
  00,00,00,00,00,3c,06,00,00,91,00,00,00,07,00,00,00,01,00,00,00,01,00,00,00,\
  fe,ff,ff,ff,45,00,00,00,3e,06,00,00,bd,01,00,00,02,00,00,00,00,00,00,80,00,\
  00,00,00,00,00,00,00,00,00,00,80,ff,ff,ff,0f,06,00,00,00,03,00,00,40,02,00,\
  00,00,00,00,ad,ba,01,00,03,00,10,00,04,00,08,00,00,00,0d,f0,ad,ba,35,00,00,\
  00,b8,00,aa,00,2e,00,6c,00,6f,00,61,00,64,00,20,00,4a,00,3a,00,5c,00,43,00,\
  6f,00,64,00,65,00,5c,00,67,00,6f,00,6d,00,6f,00,72,00,72,00,61,00,68,00,5c,\
  00,6d,00,6f,00,6f,00,6e,00,73,00,6f,00,6c,00,73,00,5c,00,77,00,69,00,6e,00,\
  5c,00,74,00,6f,00,6f,00,6c,00,73,00,5c,00,4d,00,6f,00,6f,00,6e,00,53,00,6f,\
  00,6c,00,73,00,44,00,62,00,67,00,45,00,78,00,74,00,5c,00,52,00,65,00,6c,00,\
  65,00,61,00,73,00,65,00,5c,00,4d,00,6f,00,6f,00,6e,00,53,00,6f,00,6c,00,73,\
  00,44,00,62,00,67,00,45,00,78,00,74,00,2e,00,64,00,6c,00,6c,00,0a,00,00,00,\
  00,00,0d,f0,ad,ba

[HKEY_CURRENT_USER\Software\Microsoft\Windbg\Workspaces\Kernel]
"Default"=hex:57,44,57,53,01,00,00,00,33,00,00,00,68,00,5c,00,f3,ff,ff,ff,00,\
  00,00,00,00,00,00,00,00,00,00,00,90,01,00,00,00,00,00,00,03,02,01,31,43,00,\
  6f,00,6e,00,73,00,6f,00,6c,00,61,00,73,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,02,00,10,00,04,00,19,\
  19,19,00,00,00,00,00,01,00,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,02,00,\
  02,00,10,00,04,00,6f,6d,7e,00,00,00,00,00,03,00,02,00,10,00,04,00,cf,ce,9a,\
  00,00,00,00,00,08,00,02,00,10,00,04,00,80,31,3a,00,00,00,00,00,09,00,02,00,\
  10,00,04,00,6f,6d,7e,00,00,00,00,00,0a,00,00,00,10,00,04,00,20,00,00,00,00,\
  00,00,00,12,00,00,00,10,00,04,00,01,00,00,00,00,00,00,00,0a,00,02,00,10,00,\
  04,00,e6,1e,3c,00,00,00,00,00,0b,00,02,00,10,00,04,00,52,54,58,00,00,00,00,\
  00,10,00,02,00,10,00,04,00,cf,69,4b,00,00,00,00,00,11,00,02,00,10,00,04,00,\
  75,a6,87,00,00,00,00,00,12,00,02,00,10,00,04,00,75,a6,87,00,00,00,00,00,13,\
  00,02,00,10,00,04,00,75,87,a6,00,00,00,00,00,18,00,02,00,10,00,04,00,af,c4,\
  db,00,00,00,00,00,19,00,02,00,10,00,04,00,33,99,ff,00,00,00,00,00,23,00,02,\
  00,10,00,04,00,52,54,58,00,00,00,00,00,00,ff,02,00,10,00,04,00,cf,ce,9a,00,\
  00,00,00,00,01,ff,02,00,10,00,04,00,19,19,19,00,00,00,00,00,02,ff,02,00,10,\
  00,04,00,80,31,3a,00,00,00,00,00,03,ff,02,00,10,00,04,00,19,19,19,00,00,00,\
  00,00,08,ff,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,09,ff,02,00,10,00,04,\
  00,19,19,19,00,00,00,00,00,0a,ff,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,\
  0b,ff,02,00,10,00,04,00,19,19,19,00,00,00,00,00,10,ff,02,00,10,00,04,00,cf,\
  ce,9a,00,00,00,00,00,11,ff,02,00,10,00,04,00,19,19,19,00,00,00,00,00,12,ff,\
  02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,13,ff,02,00,10,00,04,00,19,19,19,\
  00,00,00,00,00,38,ff,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,39,ff,02,00,\
  10,00,04,00,19,19,19,00,00,00,00,00,3a,ff,02,00,10,00,04,00,cf,ce,9a,00,00,\
  00,00,00,40,ff,02,00,10,00,04,00,cf,ce,9a,00,21,06,00,00,41,ff,02,00,10,00,\
  04,00,19,19,19,00,25,06,00,00,23,00,00,00,10,00,02,00,00,00,00,00,00,00,00,\
  00,30,00,00,00,b8,00,ae,00,22,00,43,00,3a,00,5c,00,55,00,73,00,65,00,72,00,\
  73,00,5c,00,62,00,75,00,72,00,6c,00,79,00,5c,00,44,00,6f,00,63,00,75,00,6d,\
  00,65,00,6e,00,74,00,73,00,5c,00,56,00,69,00,73,00,75,00,61,00,6c,00,20,00,\
  53,00,74,00,75,00,64,00,69,00,6f,00,20,00,32,00,30,00,31,00,30,00,5c,00,50,\
  00,72,00,6f,00,6a,00,65,00,63,00,74,00,73,00,5c,00,50,00,72,00,6f,00,63,00,\
  65,00,73,00,73,00,49,00,6e,00,6a,00,65,00,63,00,74,00,69,00,6f,00,6e,00,5c,\
  00,62,00,69,00,6e,00,5c,00,57,00,69,00,6e,00,33,00,32,00,5c,00,44,00,65,00,\
  62,00,75,00,67,00,00,00,00,00,22,00,00,00,80,00,74,00,73,00,72,00,76,00,2a,\
  00,43,00,3a,00,5c,00,53,00,79,00,6d,00,62,00,6f,00,6c,00,73,00,2a,00,68,00,\
  74,00,74,00,70,00,3a,00,2f,00,2f,00,6d,00,73,00,64,00,6c,00,2e,00,6d,00,69,\
  00,63,00,72,00,6f,00,73,00,6f,00,66,00,74,00,2e,00,63,00,6f,00,6d,00,2f,00,\
  64,00,6f,00,77,00,6e,00,6c,00,6f,00,61,00,64,00,2f,00,73,00,79,00,6d,00,62,\
  00,6f,00,6c,00,73,00,00,00,43,00,3a,00,20,00,00,00,c0,00,b2,00,4c,01,00,00,\
  00,00,00,00,09,00,08,00,07,00,06,00,0e,00,0a,00,05,00,04,00,0b,00,52,00,51,\
  00,50,00,4f,00,4e,00,4d,00,4b,00,4a,00,4c,00,02,00,0c,00,0f,00,03,00,01,00,\
  00,00,1e,00,30,00,31,00,32,00,33,00,34,00,35,00,36,00,37,00,10,00,11,00,12,\
  00,13,00,14,00,15,00,16,00,17,00,18,00,19,00,1a,00,1b,00,1c,00,1d,00,1f,00,\
  20,00,21,00,22,00,23,00,24,00,25,00,26,00,27,00,28,00,29,00,2a,00,2b,00,2c,\
  00,2d,00,2e,00,2f,00,38,00,39,00,3a,00,3b,00,3c,00,3d,00,3e,00,3f,00,40,00,\
  41,00,42,00,43,00,44,00,45,00,46,00,47,00,48,00,49,00,53,00,54,00,0d,00,65,\
  00,73,00,73,00,04,00,02,00,10,00,04,00,80,31,3a,00,63,00,00,00,3d,00,00,00,\
  10,00,04,00,00,00,00,00,72,00,73,00,0c,00,00,00,10,00,04,00,01,00,00,00,5c,\
  00,44,00,3c,00,00,00,10,00,04,00,01,00,00,00,74,00,73,00,3f,00,00,00,10,00,\
  04,00,01,00,00,00,6c,00,20,00,24,00,00,00,78,00,6a,00,43,00,3a,00,5c,00,55,\
  00,73,00,65,00,72,00,73,00,5c,00,62,00,75,00,72,00,6c,00,79,00,5c,00,44,00,\
  6f,00,63,00,75,00,6d,00,65,00,6e,00,74,00,73,00,5c,00,56,00,69,00,73,00,75,\
  00,61,00,6c,00,20,00,53,00,74,00,75,00,64,00,69,00,6f,00,20,00,32,00,30,00,\
  31,00,30,00,5c,00,50,00,72,00,6f,00,6a,00,65,00,63,00,74,00,73,00,00,00,00,\
  00,00,00,00,00,05,00,02,00,10,00,04,00,f8,f8,f8,00,00,00,00,00,06,00,02,00,\
  10,00,04,00,e6,1e,3c,00,00,00,00,00,07,00,02,00,10,00,04,00,f8,f8,f8,00,00,\
  00,00,00,0d,00,02,00,10,00,04,00,f8,f8,f8,00,00,00,00,00,0e,00,02,00,10,00,\
  04,00,33,99,ff,00,00,00,00,00,0f,00,02,00,10,00,04,00,f8,f8,f8,00,00,00,00,\
  00,14,00,02,00,10,00,04,00,cd,a8,69,00,00,00,00,00,15,00,02,00,10,00,04,00,\
  f8,f8,f8,00,00,00,00,00,16,00,02,00,10,00,04,00,6f,6d,7e,00,00,00,00,00,17,\
  00,02,00,10,00,04,00,af,c4,db,00,00,00,00,00,24,00,02,00,10,00,04,00,33,99,\
  ff,00,00,00,00,00,04,ff,02,00,10,00,04,00,d2,d2,3a,00,00,00,00,00,05,ff,02,\
  00,10,00,04,00,19,19,19,00,00,00,00,00,06,ff,02,00,10,00,04,00,f8,f8,f8,00,\
  00,00,00,00,07,ff,02,00,10,00,04,00,19,19,19,00,00,00,00,00,0c,ff,02,00,10,\
  00,04,00,d2,d2,3a,00,00,00,00,00,0d,ff,02,00,10,00,04,00,19,19,19,00,00,00,\
  00,00,0e,ff,02,00,10,00,04,00,f8,f8,f8,00,00,00,00,00,0f,ff,02,00,10,00,04,\
  00,19,19,19,00,00,00,00,00,3b,ff,02,00,10,00,04,00,19,19,19,00,00,00,00,00,\
  3c,ff,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,3d,ff,02,00,10,00,04,00,19,\
  19,19,00,00,00,00,00,3e,ff,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,3f,ff,\
  02,00,10,00,04,00,19,19,19,00,00,00,00,00,2c,00,00,00,80,00,74,00,43,00,3a,\
  00,5c,00,50,00,72,00,6f,00,67,00,72,00,61,00,6d,00,20,00,46,00,69,00,6c,00,\
  65,00,73,00,5c,00,44,00,65,00,62,00,75,00,67,00,67,00,69,00,6e,00,67,00,20,\
  00,54,00,6f,00,6f,00,6c,00,73,00,20,00,66,00,6f,00,72,00,20,00,57,00,69,00,\
  6e,00,64,00,6f,00,77,00,73,00,20,00,28,00,78,00,36,00,34,00,29,00,5c,00,74,\
  00,68,00,65,00,6d,00,65,00,73,00,00,00,00,00,00,00,04,00,03,00,10,00,04,00,\
  00,00,00,00,00,00,00,00,04,00,01,00,70,02,68,02,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,ff,ff,\
  ff,0f,00,00,00,00,00,00,00,00,01,00,00,00,01,00,00,00,01,00,00,00,fc,ff,ff,\
  ff,43,00,00,00,eb,03,00,00,5f,01,00,00,05,00,00,00,ff,ff,ff,0f,01,00,00,00,\
  00,00,00,00,02,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,ff,ff,ff,0f,00,00,00,00,00,00,00,00,03,00,\
  00,00,01,00,00,00,01,00,00,00,4e,04,00,00,5c,02,00,00,84,07,00,00,71,03,00,\
  00,05,00,00,00,07,00,00,00,0b,00,00,00,00,00,00,00,04,00,00,00,01,00,00,00,\
  01,00,00,00,68,03,00,00,95,02,00,00,99,06,00,00,89,03,00,00,05,00,00,00,07,\
  00,00,00,0b,00,00,00,00,00,00,00,05,00,00,00,01,00,00,00,01,00,00,00,01,01,\
  00,00,07,01,00,00,bd,03,00,00,97,02,00,00,02,00,00,00,ff,ff,ff,0f,06,00,00,\
  00,00,00,00,00,06,00,00,00,01,00,00,00,01,00,00,00,81,00,00,00,50,01,00,00,\
  2d,03,00,00,d0,02,00,00,01,00,00,00,00,00,00,80,00,00,00,00,00,00,00,00,07,\
  00,00,00,01,00,00,00,01,00,00,00,50,00,00,00,7a,00,00,00,0c,03,00,00,0a,02,\
  00,00,02,00,00,00,ff,ff,ff,0f,04,00,00,00,00,00,00,00,08,00,00,00,01,00,00,\
  00,01,00,00,00,10,00,00,00,3a,00,00,00,cc,02,00,00,ca,01,00,00,03,00,00,00,\
  ff,ff,ff,0f,06,00,00,00,00,00,00,00,09,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,ff,ff,ff,0f,00,00,\
  00,00,00,00,00,00,0a,00,00,00,01,00,00,00,01,00,00,00,40,00,00,00,6a,00,00,\
  00,fc,02,00,00,fa,01,00,00,05,00,00,00,04,00,00,00,03,00,00,00,00,00,00,00,\
  0b,00,00,00,01,00,00,00,01,00,00,00,60,00,00,00,8a,00,00,00,1c,03,00,00,1a,\
  02,00,00,05,00,00,00,05,00,00,00,0a,00,00,00,00,00,00,00,0c,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,ff,ff,ff,0f,00,00,00,00,00,00,00,00,0d,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,ff,ff,ff,0f,00,\
  00,00,00,00,00,00,00,00,00,03,00,10,00,08,00,09,00,00,00,f8,0c,00,00,01,00,\
  01,00,38,00,2c,00,2c,00,00,00,02,00,00,00,03,00,00,00,ff,ff,ff,ff,ff,ff,ff,\
  ff,ff,ff,ff,ff,ff,ff,ff,ff,00,00,00,00,d4,00,00,00,00,06,00,00,10,04,00,00,\
  67,00,69,00,03,00,03,00,78,00,6e,00,07,00,00,00,06,00,00,00,64,00,00,00,14,\
  00,00,00,00,00,00,80,06,00,00,40,06,00,00,00,e7,03,00,00,00,00,00,00,78,07,\
  00,00,16,01,00,00,07,00,00,00,01,00,00,00,01,00,00,00,50,00,00,00,7a,00,00,\
  00,0c,03,00,00,0a,02,00,00,02,00,00,00,01,00,00,00,04,00,00,00,00,00,00,00,\
  00,00,00,80,02,00,00,40,06,00,00,00,01,00,00,40,02,00,00,00,00,00,62,00,03,\
  00,03,00,80,00,78,00,05,00,00,00,03,00,00,00,64,00,00,00,14,00,00,00,00,00,\
  00,80,08,00,00,40,07,00,00,00,00,00,00,00,14,01,00,00,e7,03,00,00,be,02,00,\
  00,05,00,00,00,01,00,00,00,01,00,00,00,01,01,00,00,07,01,00,00,bd,03,00,00,\
  97,02,00,00,02,00,00,00,00,00,00,00,06,00,00,00,00,00,00,00,00,00,00,80,02,\
  00,00,40,08,00,00,40,00,00,00,00,02,00,00,00,01,00,00,00,00,00,00,00,01,00,\
  00,00,03,00,03,00,78,00,6c,00,0b,00,00,00,07,00,00,00,64,00,00,00,14,00,00,\
  00,00,00,00,80,04,00,00,40,06,00,00,00,1e,05,00,00,16,01,00,00,78,07,00,00,\
  bd,02,00,00,0b,00,00,00,01,00,00,00,01,00,00,00,60,00,00,00,8a,00,00,00,1c,\
  03,00,00,1a,02,00,00,05,00,00,00,05,00,00,00,0a,00,00,00,00,00,00,00,00,00,\
  00,80,01,00,00,40,01,00,00,00,05,00,00,40,01,00,00,00,00,00,00,00,03,00,03,\
  00,78,00,6c,00,04,00,00,00,01,00,00,00,64,00,00,00,14,00,00,00,00,00,00,80,\
  07,00,00,40,07,00,00,00,e7,03,00,00,16,01,00,00,1e,05,00,00,bd,02,00,00,04,\
  00,00,00,01,00,00,00,01,00,00,00,68,03,00,00,95,02,00,00,99,06,00,00,89,03,\
  00,00,05,00,00,00,07,00,00,00,0b,00,00,00,00,00,00,00,00,00,00,80,06,00,00,\
  40,07,00,00,40,02,00,00,00,02,00,00,00,10,00,04,00,03,00,03,00,80,00,74,00,\
  03,00,00,00,04,00,00,00,64,00,00,00,14,00,00,00,00,00,00,80,04,00,00,40,07,\
  00,00,00,1e,05,00,00,16,01,00,00,78,07,00,00,bd,02,00,00,03,00,00,00,01,00,\
  00,00,01,00,00,00,4e,04,00,00,5c,02,00,00,84,07,00,00,71,03,00,00,05,00,00,\
  00,07,00,00,00,0b,00,00,00,00,00,00,00,00,00,00,80,05,00,00,40,04,00,00,00,\
  07,00,00,00,05,00,00,00,00,00,00,00,00,00,00,00,10,00,04,00,03,00,03,00,80,\
  00,74,00,0a,00,00,00,05,00,00,00,64,00,00,00,14,00,00,00,00,00,00,80,05,00,\
  00,40,07,00,00,00,1e,05,00,00,16,01,00,00,78,07,00,00,bd,02,00,00,0a,00,00,\
  00,01,00,00,00,01,00,00,00,40,00,00,00,6a,00,00,00,fc,02,00,00,fa,01,00,00,\
  05,00,00,00,04,00,00,00,03,00,00,00,00,00,00,00,00,00,00,80,07,00,00,40,05,\
  00,00,00,04,00,00,40,05,00,00,00,00,00,00,00,14,00,00,00,10,00,04,00,03,00,\
  03,00,90,00,86,00,08,00,00,00,02,00,00,00,64,00,00,00,14,00,00,00,00,00,00,\
  80,01,00,00,40,07,00,00,00,e7,03,00,00,bd,02,00,00,78,07,00,00,22,04,00,00,\
  08,00,00,00,01,00,00,00,01,00,00,00,10,00,00,00,3a,00,00,00,cc,02,00,00,ca,\
  01,00,00,03,00,00,00,00,00,00,00,06,00,00,00,00,00,00,00,00,00,00,80,ff,ff,\
  ff,0f,03,00,00,40,06,00,00,40,01,00,00,00,00,00,00,00,11,00,00,00,01,00,00,\
  00,01,00,00,00,40,00,65,00,73,00,70,00,00,00,50,00,03,00,03,00,80,00,74,00,\
  06,00,00,00,00,00,00,00,64,00,00,00,14,00,00,00,00,00,00,80,03,00,00,40,06,\
  00,00,00,00,00,00,00,be,02,00,00,e7,03,00,00,22,04,00,00,06,00,00,00,01,00,\
  00,00,01,00,00,00,81,00,00,00,50,01,00,00,2d,03,00,00,d0,02,00,00,01,00,00,\
  00,00,00,00,80,00,00,00,00,00,00,00,00,ff,ff,ff,0f,ff,ff,ff,0f,ff,ff,ff,0f,\
  ff,ff,ff,0f,00,00,00,00,ec,ff,ff,ff,00,00,00,00,00,00,00,00,03,00,03,00,10,\
  01,06,01,01,00,00,00,08,00,00,00,64,00,00,00,14,00,00,00,00,00,00,80,08,00,\
  00,40,06,00,00,00,00,00,00,00,00,00,00,00,e7,03,00,00,14,01,00,00,01,00,00,\
  00,01,00,00,00,01,00,00,00,fc,ff,ff,ff,43,00,00,00,eb,03,00,00,5f,01,00,00,\
  05,00,00,00,ff,ff,ff,0f,01,00,00,00,00,00,00,00,00,00,00,80,03,00,00,40,08,\
  00,00,00,03,00,00,00,02,00,00,00,43,00,3a,00,5c,00,50,00,72,00,6f,00,67,00,\
  72,00,61,00,6d,00,20,00,46,00,69,00,6c,00,65,00,73,00,5c,00,44,00,65,00,62,\
  00,75,00,67,00,67,00,69,00,6e,00,67,00,20,00,54,00,6f,00,6f,00,6c,00,73,00,\
  20,00,66,00,6f,00,72,00,20,00,57,00,69,00,6e,00,64,00,6f,00,77,00,73,00,20,\
  00,28,00,78,00,36,00,34,00,29,00,5c,00,74,00,68,00,65,00,6d,00,65,00,73,00,\
  5c,00,70,00,6c,00,61,00,63,00,65,00,68,00,6f,00,6c,00,64,00,31,00,2e,00,63,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,00,01,00,03,00,10,00,04,00,\
  09,00,00,00,10,00,04,00,29,00,00,00,a8,00,9c,00,01,00,00,00,43,00,3a,00,5c,\
  00,50,00,72,00,6f,00,67,00,72,00,61,00,6d,00,20,00,46,00,69,00,6c,00,65,00,\
  73,00,5c,00,44,00,65,00,62,00,75,00,67,00,67,00,69,00,6e,00,67,00,20,00,54,\
  00,6f,00,6f,00,6c,00,73,00,20,00,66,00,6f,00,72,00,20,00,57,00,69,00,6e,00,\
  64,00,6f,00,77,00,73,00,20,00,28,00,78,00,36,00,34,00,29,00,5c,00,74,00,68,\
  00,65,00,6d,00,65,00,73,00,5c,00,70,00,6c,00,61,00,63,00,65,00,68,00,6f,00,\
  6c,00,64,00,31,00,2e,00,63,00,00,00,02,00,10,00,04,00,19,19,19,00,00,00,00,\
  00

[HKEY_CURRENT_USER\Software\Microsoft\Windbg\Workspaces\User]
"Default"=hex:57,44,57,53,01,00,00,00,33,00,00,00,68,00,5c,00,f3,ff,ff,ff,00,\
  00,00,00,00,00,00,00,00,00,00,00,90,01,00,00,00,00,00,00,03,02,01,31,43,00,\
  6f,00,6e,00,73,00,6f,00,6c,00,61,00,73,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,02,00,10,00,04,00,19,\
  19,19,00,00,00,00,00,01,00,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,02,00,\
  02,00,10,00,04,00,6f,6d,7e,00,00,00,00,00,03,00,02,00,10,00,04,00,cf,ce,9a,\
  00,00,00,00,00,08,00,02,00,10,00,04,00,80,31,3a,00,00,00,00,00,09,00,02,00,\
  10,00,04,00,6f,6d,7e,00,00,00,00,00,0a,00,00,00,10,00,04,00,20,00,00,00,00,\
  00,00,00,12,00,00,00,10,00,04,00,01,00,00,00,00,00,00,00,0a,00,02,00,10,00,\
  04,00,e6,1e,3c,00,00,00,00,00,0b,00,02,00,10,00,04,00,52,54,58,00,00,00,00,\
  00,10,00,02,00,10,00,04,00,cf,69,4b,00,00,00,00,00,11,00,02,00,10,00,04,00,\
  75,a6,87,00,00,00,00,00,12,00,02,00,10,00,04,00,75,a6,87,00,00,00,00,00,13,\
  00,02,00,10,00,04,00,75,87,a6,00,00,00,00,00,18,00,02,00,10,00,04,00,af,c4,\
  db,00,00,00,00,00,19,00,02,00,10,00,04,00,33,99,ff,00,00,00,00,00,23,00,02,\
  00,10,00,04,00,52,54,58,00,00,00,00,00,00,ff,02,00,10,00,04,00,cf,ce,9a,00,\
  00,00,00,00,01,ff,02,00,10,00,04,00,19,19,19,00,00,00,00,00,02,ff,02,00,10,\
  00,04,00,80,31,3a,00,00,00,00,00,03,ff,02,00,10,00,04,00,19,19,19,00,00,00,\
  00,00,08,ff,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,09,ff,02,00,10,00,04,\
  00,19,19,19,00,00,00,00,00,0a,ff,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,\
  0b,ff,02,00,10,00,04,00,19,19,19,00,00,00,00,00,10,ff,02,00,10,00,04,00,cf,\
  ce,9a,00,00,00,00,00,11,ff,02,00,10,00,04,00,19,19,19,00,00,00,00,00,12,ff,\
  02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,13,ff,02,00,10,00,04,00,19,19,19,\
  00,00,00,00,00,38,ff,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,39,ff,02,00,\
  10,00,04,00,19,19,19,00,00,00,00,00,3a,ff,02,00,10,00,04,00,cf,ce,9a,00,00,\
  00,00,00,40,ff,02,00,10,00,04,00,cf,ce,9a,00,21,06,00,00,41,ff,02,00,10,00,\
  04,00,19,19,19,00,25,06,00,00,23,00,00,00,10,00,02,00,00,00,00,00,00,00,00,\
  00,30,00,00,00,b8,00,ae,00,22,00,43,00,3a,00,5c,00,55,00,73,00,65,00,72,00,\
  73,00,5c,00,62,00,75,00,72,00,6c,00,79,00,5c,00,44,00,6f,00,63,00,75,00,6d,\
  00,65,00,6e,00,74,00,73,00,5c,00,56,00,69,00,73,00,75,00,61,00,6c,00,20,00,\
  53,00,74,00,75,00,64,00,69,00,6f,00,20,00,32,00,30,00,31,00,30,00,5c,00,50,\
  00,72,00,6f,00,6a,00,65,00,63,00,74,00,73,00,5c,00,50,00,72,00,6f,00,63,00,\
  65,00,73,00,73,00,49,00,6e,00,6a,00,65,00,63,00,74,00,69,00,6f,00,6e,00,5c,\
  00,62,00,69,00,6e,00,5c,00,57,00,69,00,6e,00,33,00,32,00,5c,00,44,00,65,00,\
  62,00,75,00,67,00,00,00,00,00,22,00,00,00,80,00,74,00,73,00,72,00,76,00,2a,\
  00,43,00,3a,00,5c,00,53,00,79,00,6d,00,62,00,6f,00,6c,00,73,00,2a,00,68,00,\
  74,00,74,00,70,00,3a,00,2f,00,2f,00,6d,00,73,00,64,00,6c,00,2e,00,6d,00,69,\
  00,63,00,72,00,6f,00,73,00,6f,00,66,00,74,00,2e,00,63,00,6f,00,6d,00,2f,00,\
  64,00,6f,00,77,00,6e,00,6c,00,6f,00,61,00,64,00,2f,00,73,00,79,00,6d,00,62,\
  00,6f,00,6c,00,73,00,00,00,43,00,3a,00,20,00,00,00,c0,00,b2,00,4c,01,00,00,\
  00,00,00,00,09,00,08,00,07,00,06,00,0e,00,0a,00,05,00,04,00,0b,00,52,00,51,\
  00,50,00,4f,00,4e,00,4d,00,4b,00,4a,00,4c,00,02,00,0c,00,0f,00,03,00,01,00,\
  00,00,1e,00,30,00,31,00,32,00,33,00,34,00,35,00,36,00,37,00,10,00,11,00,12,\
  00,13,00,14,00,15,00,16,00,17,00,18,00,19,00,1a,00,1b,00,1c,00,1d,00,1f,00,\
  20,00,21,00,22,00,23,00,24,00,25,00,26,00,27,00,28,00,29,00,2a,00,2b,00,2c,\
  00,2d,00,2e,00,2f,00,38,00,39,00,3a,00,3b,00,3c,00,3d,00,3e,00,3f,00,40,00,\
  41,00,42,00,43,00,44,00,45,00,46,00,47,00,48,00,49,00,53,00,54,00,0d,00,65,\
  00,73,00,73,00,04,00,02,00,10,00,04,00,80,31,3a,00,63,00,00,00,3d,00,00,00,\
  10,00,04,00,00,00,00,00,72,00,73,00,0c,00,00,00,10,00,04,00,01,00,00,00,5c,\
  00,44,00,3c,00,00,00,10,00,04,00,01,00,00,00,74,00,73,00,3f,00,00,00,10,00,\
  04,00,01,00,00,00,6c,00,20,00,24,00,00,00,78,00,6a,00,43,00,3a,00,5c,00,55,\
  00,73,00,65,00,72,00,73,00,5c,00,62,00,75,00,72,00,6c,00,79,00,5c,00,44,00,\
  6f,00,63,00,75,00,6d,00,65,00,6e,00,74,00,73,00,5c,00,56,00,69,00,73,00,75,\
  00,61,00,6c,00,20,00,53,00,74,00,75,00,64,00,69,00,6f,00,20,00,32,00,30,00,\
  31,00,30,00,5c,00,50,00,72,00,6f,00,6a,00,65,00,63,00,74,00,73,00,00,00,00,\
  00,00,00,00,00,05,00,02,00,10,00,04,00,f8,f8,f8,00,00,00,00,00,06,00,02,00,\
  10,00,04,00,e6,1e,3c,00,00,00,00,00,07,00,02,00,10,00,04,00,f8,f8,f8,00,00,\
  00,00,00,0d,00,02,00,10,00,04,00,f8,f8,f8,00,00,00,00,00,0e,00,02,00,10,00,\
  04,00,33,99,ff,00,00,00,00,00,0f,00,02,00,10,00,04,00,f8,f8,f8,00,00,00,00,\
  00,14,00,02,00,10,00,04,00,cd,a8,69,00,00,00,00,00,15,00,02,00,10,00,04,00,\
  f8,f8,f8,00,00,00,00,00,16,00,02,00,10,00,04,00,6f,6d,7e,00,00,00,00,00,17,\
  00,02,00,10,00,04,00,af,c4,db,00,00,00,00,00,24,00,02,00,10,00,04,00,33,99,\
  ff,00,00,00,00,00,04,ff,02,00,10,00,04,00,d2,d2,3a,00,00,00,00,00,05,ff,02,\
  00,10,00,04,00,19,19,19,00,00,00,00,00,06,ff,02,00,10,00,04,00,f8,f8,f8,00,\
  00,00,00,00,07,ff,02,00,10,00,04,00,19,19,19,00,00,00,00,00,0c,ff,02,00,10,\
  00,04,00,d2,d2,3a,00,00,00,00,00,0d,ff,02,00,10,00,04,00,19,19,19,00,00,00,\
  00,00,0e,ff,02,00,10,00,04,00,f8,f8,f8,00,00,00,00,00,0f,ff,02,00,10,00,04,\
  00,19,19,19,00,00,00,00,00,3b,ff,02,00,10,00,04,00,19,19,19,00,00,00,00,00,\
  3c,ff,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,3d,ff,02,00,10,00,04,00,19,\
  19,19,00,00,00,00,00,3e,ff,02,00,10,00,04,00,cf,ce,9a,00,00,00,00,00,3f,ff,\
  02,00,10,00,04,00,19,19,19,00,00,00,00,00,2c,00,00,00,80,00,74,00,43,00,3a,\
  00,5c,00,50,00,72,00,6f,00,67,00,72,00,61,00,6d,00,20,00,46,00,69,00,6c,00,\
  65,00,73,00,5c,00,44,00,65,00,62,00,75,00,67,00,67,00,69,00,6e,00,67,00,20,\
  00,54,00,6f,00,6f,00,6c,00,73,00,20,00,66,00,6f,00,72,00,20,00,57,00,69,00,\
  6e,00,64,00,6f,00,77,00,73,00,20,00,28,00,78,00,36,00,34,00,29,00,5c,00,74,\
  00,68,00,65,00,6d,00,65,00,73,00,00,00,00,00,00,00,04,00,03,00,10,00,04,00,\
  00,00,00,00,00,00,00,00,04,00,01,00,70,02,68,02,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,ff,ff,\
  ff,0f,00,00,00,00,00,00,00,00,01,00,00,00,01,00,00,00,01,00,00,00,fc,ff,ff,\
  ff,43,00,00,00,eb,03,00,00,5f,01,00,00,05,00,00,00,ff,ff,ff,0f,01,00,00,00,\
  00,00,00,00,02,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,ff,ff,ff,0f,00,00,00,00,00,00,00,00,03,00,\
  00,00,01,00,00,00,01,00,00,00,4e,04,00,00,5c,02,00,00,84,07,00,00,71,03,00,\
  00,05,00,00,00,07,00,00,00,0b,00,00,00,00,00,00,00,04,00,00,00,01,00,00,00,\
  01,00,00,00,68,03,00,00,95,02,00,00,99,06,00,00,89,03,00,00,05,00,00,00,07,\
  00,00,00,0b,00,00,00,00,00,00,00,05,00,00,00,01,00,00,00,01,00,00,00,01,01,\
  00,00,07,01,00,00,bd,03,00,00,97,02,00,00,02,00,00,00,ff,ff,ff,0f,06,00,00,\
  00,00,00,00,00,06,00,00,00,01,00,00,00,01,00,00,00,81,00,00,00,50,01,00,00,\
  2d,03,00,00,d0,02,00,00,01,00,00,00,00,00,00,80,00,00,00,00,00,00,00,00,07,\
  00,00,00,01,00,00,00,01,00,00,00,50,00,00,00,7a,00,00,00,0c,03,00,00,0a,02,\
  00,00,02,00,00,00,ff,ff,ff,0f,04,00,00,00,00,00,00,00,08,00,00,00,01,00,00,\
  00,01,00,00,00,10,00,00,00,3a,00,00,00,cc,02,00,00,ca,01,00,00,03,00,00,00,\
  ff,ff,ff,0f,06,00,00,00,00,00,00,00,09,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,ff,ff,ff,0f,00,00,\
  00,00,00,00,00,00,0a,00,00,00,01,00,00,00,01,00,00,00,40,00,00,00,6a,00,00,\
  00,fc,02,00,00,fa,01,00,00,05,00,00,00,04,00,00,00,03,00,00,00,00,00,00,00,\
  0b,00,00,00,01,00,00,00,01,00,00,00,60,00,00,00,8a,00,00,00,1c,03,00,00,1a,\
  02,00,00,05,00,00,00,05,00,00,00,0a,00,00,00,00,00,00,00,0c,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,ff,ff,ff,0f,00,00,00,00,00,00,00,00,0d,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,ff,ff,ff,0f,00,\
  00,00,00,00,00,00,00,00,00,03,00,10,00,08,00,09,00,00,00,f8,0c,00,00,01,00,\
  01,00,38,00,2c,00,2c,00,00,00,02,00,00,00,03,00,00,00,ff,ff,ff,ff,ff,ff,ff,\
  ff,ff,ff,ff,ff,ff,ff,ff,ff,00,00,00,00,d4,00,00,00,00,06,00,00,10,04,00,00,\
  67,00,69,00,03,00,03,00,78,00,6e,00,07,00,00,00,06,00,00,00,64,00,00,00,14,\
  00,00,00,00,00,00,80,06,00,00,40,06,00,00,00,e7,03,00,00,00,00,00,00,78,07,\
  00,00,16,01,00,00,07,00,00,00,01,00,00,00,01,00,00,00,50,00,00,00,7a,00,00,\
  00,0c,03,00,00,0a,02,00,00,02,00,00,00,01,00,00,00,04,00,00,00,00,00,00,00,\
  00,00,00,80,02,00,00,40,06,00,00,00,01,00,00,40,02,00,00,00,00,00,62,00,03,\
  00,03,00,80,00,78,00,05,00,00,00,03,00,00,00,64,00,00,00,14,00,00,00,00,00,\
  00,80,08,00,00,40,07,00,00,00,00,00,00,00,14,01,00,00,e7,03,00,00,be,02,00,\
  00,05,00,00,00,01,00,00,00,01,00,00,00,01,01,00,00,07,01,00,00,bd,03,00,00,\
  97,02,00,00,02,00,00,00,00,00,00,00,06,00,00,00,00,00,00,00,00,00,00,80,02,\
  00,00,40,08,00,00,40,00,00,00,00,02,00,00,00,01,00,00,00,00,00,00,00,01,00,\
  00,00,03,00,03,00,78,00,6c,00,0b,00,00,00,07,00,00,00,64,00,00,00,14,00,00,\
  00,00,00,00,80,04,00,00,40,06,00,00,00,1e,05,00,00,16,01,00,00,78,07,00,00,\
  bd,02,00,00,0b,00,00,00,01,00,00,00,01,00,00,00,60,00,00,00,8a,00,00,00,1c,\
  03,00,00,1a,02,00,00,05,00,00,00,05,00,00,00,0a,00,00,00,00,00,00,00,00,00,\
  00,80,01,00,00,40,01,00,00,00,05,00,00,40,01,00,00,00,00,00,00,00,03,00,03,\
  00,78,00,6c,00,04,00,00,00,01,00,00,00,64,00,00,00,14,00,00,00,00,00,00,80,\
  07,00,00,40,07,00,00,00,e7,03,00,00,16,01,00,00,1e,05,00,00,bd,02,00,00,04,\
  00,00,00,01,00,00,00,01,00,00,00,68,03,00,00,95,02,00,00,99,06,00,00,89,03,\
  00,00,05,00,00,00,07,00,00,00,0b,00,00,00,00,00,00,00,00,00,00,80,06,00,00,\
  40,07,00,00,40,02,00,00,00,02,00,00,00,10,00,04,00,03,00,03,00,80,00,74,00,\
  03,00,00,00,04,00,00,00,64,00,00,00,14,00,00,00,00,00,00,80,04,00,00,40,07,\
  00,00,00,1e,05,00,00,16,01,00,00,78,07,00,00,bd,02,00,00,03,00,00,00,01,00,\
  00,00,01,00,00,00,4e,04,00,00,5c,02,00,00,84,07,00,00,71,03,00,00,05,00,00,\
  00,07,00,00,00,0b,00,00,00,00,00,00,00,00,00,00,80,05,00,00,40,04,00,00,00,\
  07,00,00,00,05,00,00,00,00,00,00,00,00,00,00,00,10,00,04,00,03,00,03,00,80,\
  00,74,00,0a,00,00,00,05,00,00,00,64,00,00,00,14,00,00,00,00,00,00,80,05,00,\
  00,40,07,00,00,00,1e,05,00,00,16,01,00,00,78,07,00,00,bd,02,00,00,0a,00,00,\
  00,01,00,00,00,01,00,00,00,40,00,00,00,6a,00,00,00,fc,02,00,00,fa,01,00,00,\
  05,00,00,00,04,00,00,00,03,00,00,00,00,00,00,00,00,00,00,80,07,00,00,40,05,\
  00,00,00,04,00,00,40,05,00,00,00,00,00,00,00,14,00,00,00,10,00,04,00,03,00,\
  03,00,90,00,86,00,08,00,00,00,02,00,00,00,64,00,00,00,14,00,00,00,00,00,00,\
  80,01,00,00,40,07,00,00,00,e7,03,00,00,bd,02,00,00,78,07,00,00,22,04,00,00,\
  08,00,00,00,01,00,00,00,01,00,00,00,10,00,00,00,3a,00,00,00,cc,02,00,00,ca,\
  01,00,00,03,00,00,00,00,00,00,00,06,00,00,00,00,00,00,00,00,00,00,80,ff,ff,\
  ff,0f,03,00,00,40,06,00,00,40,01,00,00,00,00,00,00,00,11,00,00,00,01,00,00,\
  00,01,00,00,00,40,00,65,00,73,00,70,00,00,00,50,00,03,00,03,00,80,00,74,00,\
  06,00,00,00,00,00,00,00,64,00,00,00,14,00,00,00,00,00,00,80,03,00,00,40,06,\
  00,00,00,00,00,00,00,be,02,00,00,e7,03,00,00,22,04,00,00,06,00,00,00,01,00,\
  00,00,01,00,00,00,81,00,00,00,50,01,00,00,2d,03,00,00,d0,02,00,00,01,00,00,\
  00,00,00,00,80,00,00,00,00,00,00,00,00,ff,ff,ff,0f,ff,ff,ff,0f,ff,ff,ff,0f,\
  ff,ff,ff,0f,00,00,00,00,ec,ff,ff,ff,00,00,00,00,00,00,00,00,03,00,03,00,10,\
  01,06,01,01,00,00,00,08,00,00,00,64,00,00,00,14,00,00,00,00,00,00,80,08,00,\
  00,40,06,00,00,00,00,00,00,00,00,00,00,00,e7,03,00,00,14,01,00,00,01,00,00,\
  00,01,00,00,00,01,00,00,00,fc,ff,ff,ff,43,00,00,00,eb,03,00,00,5f,01,00,00,\
  05,00,00,00,ff,ff,ff,0f,01,00,00,00,00,00,00,00,00,00,00,80,03,00,00,40,08,\
  00,00,00,03,00,00,00,02,00,00,00,43,00,3a,00,5c,00,50,00,72,00,6f,00,67,00,\
  72,00,61,00,6d,00,20,00,46,00,69,00,6c,00,65,00,73,00,5c,00,44,00,65,00,62,\
  00,75,00,67,00,67,00,69,00,6e,00,67,00,20,00,54,00,6f,00,6f,00,6c,00,73,00,\
  20,00,66,00,6f,00,72,00,20,00,57,00,69,00,6e,00,64,00,6f,00,77,00,73,00,20,\
  00,28,00,78,00,36,00,34,00,29,00,5c,00,74,00,68,00,65,00,6d,00,65,00,73,00,\
  5c,00,70,00,6c,00,61,00,63,00,65,00,68,00,6f,00,6c,00,64,00,31,00,2e,00,63,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,00,01,00,03,00,10,00,04,00,\
  09,00,00,00,10,00,04,00,29,00,00,00,a8,00,9c,00,01,00,00,00,43,00,3a,00,5c,\
  00,50,00,72,00,6f,00,67,00,72,00,61,00,6d,00,20,00,46,00,69,00,6c,00,65,00,\
  73,00,5c,00,44,00,65,00,62,00,75,00,67,00,67,00,69,00,6e,00,67,00,20,00,54,\
  00,6f,00,6f,00,6c,00,73,00,20,00,66,00,6f,00,72,00,20,00,57,00,69,00,6e,00,\
  64,00,6f,00,77,00,73,00,20,00,28,00,78,00,36,00,34,00,29,00,5c,00,74,00,68,\
  00,65,00,6d,00,65,00,73,00,5c,00,70,00,6c,00,61,00,63,00,65,00,68,00,6f,00,\
  6c,00,64,00,31,00,2e,00,63,00,00,00,02,00,10,00,04,00,19,19,19,00,00,00,00,\
  00


```

`LICENSE`:

```
GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    {one line to give the program's name and a brief idea of what it does.}
    Copyright (C) {year}  {name of author}

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    {project}  Copyright (C) {year}  {fullname}
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.


```

`README.md`:

```md
#SwishDbgExt
===========

SwishDbgExt is a Microsoft WinDbg debugging extension that expands the set of available commands by Microsoft WinDbg, but also fixes and improves existing commands.
This extension has been developed by Matt Suiche (@msuiche) – feel free to reach out on support@comae.io ask for more features, offer to contribute and/or report bugs.

SwishDbgExt aims at making life easier for kernel developers, troubleshooters and security experts with a series of debugging, incident response and memory forensics commands.
Because SwishDbgExt is a WinDbg debugging extension, it means it can be used on local or remote kernel debugging session, live sessions generated by Microsoft LiveKd, but also on Microsoft crash dumps generated to a Blue Screen of Death or hybrid utilities such as Comae DumpIt.

## 2016 Contest
More information on https://blog.comae.io/comae-2016-contest-swishdbgext-features-3c9a63c62209#.tnt1b9usx

## Installation
You can either copy the WinDbg extension in the corresponding (x86 or x64) WinDbg folder or load it manually using the !load command such as below. Please note you can’t have spaces or quotes in the full path to the target dll to be loaded.
`!load X:\FullPath\SwishDbgExt.dll`

###Example:
```
kd> !load E:\projects\labs\SwishDbgExt\bin\x64\SwishDbgExt.dll;
       SwishDbgExt v0.7.0 (Nov  2 2016) - Incident Response & Digital Forensics Debugging Extension
       SwishDbgExt Copyright (C) 2016 Comae Technologies FZE - http://www.comae.io
       SwishDbgExt Copyright (C) 2014-2016 Matthieu Suiche (@msuiche)

       This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
       This is free software, and you are welcome to redistribute it
       under certain conditions; type `show c' for details.
```
	   
If you wish to update your WinDbg template with a more DML-friendly template, you can directly import windbg_template.reg file joined to the package.

## TODO
- [ ] Define structures
- [ ] Define Commands
- [ ] Announce feature contest.

## Commands
### !SwishDbgExt.help
Displays information on available extension commands.

This command will give you the list of all commands if you specify no argument, will give you the list of parameters for an existing command if specified as an argument.

### !ms_callbacks     
Display callback functions

### !ms_checkcodecave 
Look for used code cave

### !ms_consoles      
Display console command's history 

### !ms_credentials
Display user's credentials (based on gentilwiki's mimikatz) 
### !ms_drivers
Display list of drivers.
!ms_drivers will go ahead and display a list of drivers that are currently loaded.
In this example, here’s a few of the drivers loaded at the time of the crash in this kernel-dump:
With this command, we can also view in-depth IRP information regarding a driver:
In the above image we can see the driver-specific I/O stack location within e1cexpress.sys’ IRP. Here we can see function codes such as IRP_MJ_CREATE which opens the target device object, indicating that it is present and available for I/O operations.

### !ms_dump
Dump memory space on disk

### !ms_exqueue
Display Ex queued workers.

`!exqueue` doesn’t work properly on Windows 8, so a working version needed to be implemented. Just like the original command this one dispaly the working threads queue.

### !ms_fixit
Reset segmentation in WinDbg (Fix "16.kd>")

### !ms_gdt
Display GDT.

!ms_gdt displays the Global Descriptor Table. Note on x64 that every selector is flat (0x0000000000000000 to 0xFFFFFFFFFFFFFFFF). This command can be extra helpful to check for any suspected hooking of the GDT, as attempting to do so on x64 will call a bug check. This is because x64 forbids hooking of the GDT.

### !ms_hivelist
Display list of registry hives.

`ms_hivelist` displays a list of registry hives.
We can look directly into a hive (\Registry\Machine\Software for example) to see its subkeys, values, etc:

![Alt text](Documents/Hivelist.gif?raw=true "Hive List")

### !ms_idt
Display IDT.

`!ms_idt` displays the Interrupt descriptor table. Very much like the GDT, if the IDT is hooked on an x64 system, it will call a bug check. This is due to the fact that Microsoft implemented (programmatically) a prevention of hooking the IDT with a kernel-mode driver that would normally intercept calls to the IDT and then add in its own processing. This is why in the above image, there is ‘No’ as far as the eye can see.

### !ms_malscore
Analyze a memory space and returns a Malware Score Index (MSI) - (based on Frank Boldewin's work)

### !ms_mbr
Scan Master Boot Record (MBR)

### !ms_netstat
Display network information (sockets, connections, ...)

### !ms_object
Display list of object

### !ms_process
Display list of processes.
`!ms_process` is an improved version of `!process` and `!dml_proc`..
One of the nice thing as you can notice below is the usage of DML (Debugger Markup Language) with the commands. All the underline commands are in fact links to commands.
As an example below, you can see the output of /vads /scan, to scan VAD (Virtual Address Descriptors). You can notice that one column gives the “Malware Score Index” which can be useful to detect shellcodes or heap-spray.
In the screenshot below, you can see an abnormally high score in several VADs – due to usage of heap spray. Just by clicking on the score it will run the scanning algorithm.
The scanning algorithm is based on Frank Boldewin’s OfficeMalScanner utility.
And returns you information about where the shellcode is:
`/scan` option can also be used on exported functions to know if the EAT (Export Address Table) has been patched or if the prolog of the function modified.

Similar tests are available for the SSDT (`!ms_ssdt`).

### !ms_readkcb
Read key control block

### !ms_readknode
Read key node.
`!reg` WinDbg command has been a frustration for a long time, due to some bugs. This is why SwishDbgExt, has its own registry explorer functions to try to make access to registry data as simple as possible.

### !ms_readkvalue
Read key value

### !ms_scanndishook
Scan and display suspicious NDIS hooks

### !ms_services
Display list of services

### !ms_ssdt
Display service descriptor table (SDT) functions.
`!ms_ssdt` displays the System Service Dispatch Table. This command is extremely helpful in the investigation of suspected rootkit hooks through what is known as Direct Kernel Object Manipulation (DKOM). If you see a low level routine here that is hooked (such as nt!NtEnumerateKey), this can aid you in your analysis regarding a possible rootkit infection.

### !ms_store
Display information related to the Store Manager (ReadyBoost).

The present command allows to list the current ReadyBoost (requires USB 3.0) cache used by the Operating System, but also to display the logs of the memory pages managed by the store manager.
Parameter: /cache

### !ms_timers
Display list of KTIMER.

!ms_timers displays the KTIMER structure, which is an opaque structure that represents and contains various timer objects. This command can be helpful to figure out what drivers created what timer objects, what drivers called what routines, etc.

### !ms_vacbs
Display list of cached VACBs

### !ms_verbose
Turn verbose mode on/off

### !ms_lxss
The following is based on the research published by Alex Ionescu and available here: https://github.com/ionescu007/lxss/

This feature is available on Windows 10+ O.S. as an optional feature installable via the following PowerShell command:
```
Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
```

You can read more about the Windows Subsystem for Linux at the following links:
- https://blogs.msdn.microsoft.com/wsl/2016/04/22/windows-subsystem-for-linux-overview/
- https://channel9.msdn.com/Blogs/Seth-Juarez/Windows-Subsystem-for-Linux-Architectural-Overview
- https://msdn.microsoft.com/en-us/commandline/wsl/install_guide

```
	Windows Subsystem for Linux Overview.
	Instance 0xFFFFE704EEB8F010
	GUID: {E29032FD-35D3-4C53-AB68-6BCEBDA7176F}
	State:            (1) [STARTED]
	Creation Flags:   00000001
	GlobalData:       0xFFFFF802ED4138A0
	Root Handle:      80000834
	Temp Handle:      80000838
	Job Handle:       8000083c
	Token:            80000818
	Event Handle:     800008bc

	Map Paths (0):    0xFFFFE704EF437920
	VFS Context:      0xFFFFE704EEFC4710
	Memory Flags:     0x2

	Last PID:         35
	Thread Groups:    3
		Session 0xFFFFE704EDB79EC0
		Instance:         0xFFFFE704EEB8F010
		Console inode:    0x0
		Foreground PID:   -1
			Process Group 0xFFFFE704EDB79AE0
			Instance:      0xFFFFE704EEB8F010
			Session:       0xFFFFE704EDB79EC0
				Thread Group 0xFFFFE704EF4F8000
				Binary Path:           /init
				Thread(s):             1
				Owner Process Group:   0xFFFFE704EDB79AE0
				Flags:                 0x00000000
				Main Thread:           0xFFFFE704EF5CC010
				Arguments (006 bytes): 0x00007FFFC081D6E0
					Process 0xFFFFE704EF2F1D70
					Instance:            0xFFFFE704EEB8F010
					NT Process Object:   0xFFFFAE05E84EF800
					NT Process Handle:   0xFFFFFFFF80000F58
					VDSO Address:        0x00007FFFC0849000
					Stack Address:       0x00007FFFC001E000
		Session 0xFFFFE704EF5DB830
		Instance:         0xFFFFE704EEB8F010
		Console inode:    0xFFFFE704EF32D7A0
		Foreground PID:   2
			Process Group 0xFFFFE704EF5EF970
			Instance:      0xFFFFE704EEB8F010
			Session:       0xFFFFE704EF5DB830
				Thread Group 0xFFFFE704EF5EE000
				Binary Path:           /bin/bash
				Thread(s):             1
				Owner Process Group:   0xFFFFE704EF5EF970
				Flags:                 0x0000000C
				Main Thread:           0xFFFFE704EF5F8010
				Arguments (010 bytes): 0x00007FFFDF34E418
					Process 0xFFFFE704EDEF6EC0
					Instance:            0xFFFFE704EEB8F010
					NT Process Object:   0xFFFFAE05E84E6800
					NT Process Handle:   0xFFFFFFFF80000D9C
					VDSO Address:        0x00007FFFDF883000
					Stack Address:       0x00007FFFDEB4F000
		Session 0xFFFFE704EF0A8ED0
		Instance:         0xFFFFE704EEB8F010
		Console inode:    0xFFFFE704EF06B9C0
		Foreground PID:   19
			Process Group 0xFFFFE704F059CBC0
			Instance:      0xFFFFE704EEB8F010
			Session:       0xFFFFE704EF0A8ED0
				Thread Group 0xFFFFE704EDE51000
				Binary Path:           /bin/bash
				Thread(s):             1
				Owner Process Group:   0xFFFFE704F059CBC0
				Flags:                 0x0000000C
				Main Thread:           0xFFFFE704EDC78090
				Arguments (010 bytes): 0x00007FFFF78CFB78
					Process 0xFFFFE704F06389B0
					Instance:            0xFFFFE704EEB8F010
					NT Process Object:   0xFFFFAE05E618D800
					NT Process Handle:   0xFFFFFFFF80001650
					VDSO Address:        0x00007FFFF7C99000
					Stack Address:       0x00007FFFF70D0000
```

### !ms_yarascan

Scan a process memory with yara rules.

Scan a process memory.
```
!ms_yarascan /pid 0x228 /yarafile /yarafile C:\Rules.yar
```

Scan all processes memory.
```
!for_each_process "r? @$t0 = (nt!_EPROCESS *) @#Process; .process /r /p @$t0; !ms_yarascan /pid @@C++(@$t0->UniqueProcessId) /yarafile C:\\Rules.yar"
```

## Classes
### PEFile
`MsPEImageFile` contains the basic common information used by Windows binaries (PE) and has been derivated into three different classes:

- MsProcessObject
- MsDllObject
- MsDriverObject

```

`SwishDbgExt.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SwishDbgExt", "SwishDbgExt\SwishDbgExt.vcxproj", "{3DEADBA0-BE78-43B7-A17A-027F185957E6}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3DEADBA0-BE78-43B7-A17A-027F185957E6}.Debug|x64.ActiveCfg = Debug|x64
		{3DEADBA0-BE78-43B7-A17A-027F185957E6}.Debug|x64.Build.0 = Debug|x64
		{3DEADBA0-BE78-43B7-A17A-027F185957E6}.Debug|x86.ActiveCfg = Debug|Win32
		{3DEADBA0-BE78-43B7-A17A-027F185957E6}.Debug|x86.Build.0 = Debug|Win32
		{3DEADBA0-BE78-43B7-A17A-027F185957E6}.Debug|x86.Deploy.0 = Debug|Win32
		{3DEADBA0-BE78-43B7-A17A-027F185957E6}.Release|x64.ActiveCfg = Release|x64
		{3DEADBA0-BE78-43B7-A17A-027F185957E6}.Release|x64.Build.0 = Release|x64
		{3DEADBA0-BE78-43B7-A17A-027F185957E6}.Release|x86.ActiveCfg = Release|Win32
		{3DEADBA0-BE78-43B7-A17A-027F185957E6}.Release|x86.Build.0 = Release|Win32
		{3DEADBA0-BE78-43B7-A17A-027F185957E6}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`SwishDbgExt/Azure.cpp`:

```cpp
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Azure.cpp

Abstract:

    - http://msdn.microsoft.com/en-us/windows/ff553536(v=vs.71).aspx

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

//
// HYPERV functions from MoonSols LiveCloudKd
//

#include "stdafx.h"
```

`SwishDbgExt/Azure.h`:

```h
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Azure.h

Abstract:

    - http://msdn.microsoft.com/en-us/windows/ff553536(v=vs.71).aspx


Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/
```

`SwishDbgExt/CNdiskd/CAdapters.cpp`:

```cpp
/*++
    A NDIS hook scan extension to existing Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 wLcY (@x9090)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
--*/

#include "stdafx.h"
#include "CNdiskd.h"

// CAdapters constructor
CAdapters::CAdapters()
{
    // Initialize handler function address
    m_ptrPacketIndicateHandler = 0;
    m_ptrSendCompleteHandler = 0;
    m_ptrResetCompleteHandler = 0;
    m_ptrStatusHandler = 0;
    m_ptrStatusCompleteHandler = 0;
    m_ptrWanSendCompleteHandler = 0;
    m_ptrWanRcvHandler = 0;
    m_ptrWanRcvCompleteHandler = 0;
    m_ptrSendNetBufferListsCompleteHandler = 0;
    // Initialize NDIS start and end address
    m_ndisStartAddr = 0;
    m_ndisEndAddr = 0;
    // Initialize minidriver start and end address
    m_minidrvStartAddr = 0;
    m_minidrvEndAddr = 0;
    // Initialize heap to store protocol's information
    m_adaptername = (PWSTR)malloc(MAX_ADAPTER_NAME*sizeof(WCHAR));

}

// CAdapters destructor
CAdapters::~CAdapters()
{
    // Cleanup
    free(m_adaptername);

}

VOID WINAPI CAdapters::SetAdapterName(PWSTR AdatperName)
{
    StringCchCopyW(m_adaptername, MAX_ADAPTER_NAME, AdatperName);
}

PWSTR WINAPI CAdapters::GetAdapterName()
{
    return m_adaptername;
}

BOOL WINAPI CAdapters::IsNdisFuncHandlerHooked(ULONG64 PtrHandler)
{
    BOOL boolIsHooked = (PtrHandler < m_ndisStartAddr) && (PtrHandler > m_ndisEndAddr);

    if (boolIsHooked)
        return true;
    else
        return false;
}

std::map<PCSTR, ULONG64>* WINAPI CAdapters::GetFunctionHandlers(std::map<PCSTR, ULONG64> *PtrHandlers)
{
    PtrHandlers->insert(std::make_pair("PacketIndicateHandler", m_ptrPacketIndicateHandler));
    PtrHandlers->insert(std::make_pair("ResetCompleteHandler", m_ptrResetCompleteHandler));
    PtrHandlers->insert(std::make_pair("WanRcvHandler", m_ptrWanRcvHandler));
    PtrHandlers->insert(std::make_pair("WanRcvCompleteHandler", m_ptrWanRcvCompleteHandler));
    PtrHandlers->insert(std::make_pair("WanSendCompleteHandler", m_ptrWanSendCompleteHandler));
    PtrHandlers->insert(std::make_pair("SendCompleteHandler", m_ptrSendCompleteHandler));
    PtrHandlers->insert(std::make_pair("SendNetBufferListsCompleteHandler", m_ptrSendNetBufferListsCompleteHandler));
    PtrHandlers->insert(std::make_pair("StatusCompleteHandler", m_ptrStatusCompleteHandler));
    PtrHandlers->insert(std::make_pair("StatusHandler", m_ptrStatusHandler));

    return PtrHandlers;
}
```

`SwishDbgExt/CNdiskd/CAdapters.h`:

```h
/*++
    A NDIS hook scan extension to existing Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 wLcY (@x9090)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    --*/
#ifndef _CADAPTERS_H_
#define _CADAPTERS_H_

#define MAX_ADAPTER_NAME 500

class CAdapters
{
public:
    CAdapters();
    ~CAdapters();
    BOOL WINAPI IsNdisFuncHandlerHooked(ULONG64);
    VOID WINAPI SetAdapterName(PWSTR);
    PWSTR WINAPI GetAdapterName();
    std::map<PCSTR, ULONG64>* WINAPI GetFunctionHandlers(std::map<PCSTR, ULONG64>*);
    ULONG64 m_ndisStartAddr;
    ULONG64 m_ndisEndAddr;
    ULONG64 m_minidrvStartAddr;
    ULONG64 m_minidrvEndAddr;
    // Only partial handler functions that are known to be targeted on NDIS library
    ULONG64 m_ptrPacketIndicateHandler;
    ULONG64 m_ptrSendCompleteHandler;
    ULONG64 m_ptrResetCompleteHandler;
    ULONG64 m_ptrStatusHandler;
    ULONG64 m_ptrStatusCompleteHandler;
    ULONG64 m_ptrWanSendCompleteHandler;
    ULONG64 m_ptrWanRcvHandler;
    ULONG64 m_ptrWanRcvCompleteHandler;
    ULONG64 m_ptrSendNetBufferListsCompleteHandler;
private:
    PWSTR m_adaptername;
};

#endif // _CADAPTERS_H_
```

`SwishDbgExt/CNdiskd/CMinidriver.cpp`:

```cpp
/*++
    A NDIS hook scan extension to existing Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 wLcY (@x9090)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
--*/

#include "stdafx.h"
#include "CNdiskd.h"

// CMinidriver constructor
CMinidriver::CMinidriver(ULONG64 MinidriverAddr)
{
    // Initialize minidriver ptr
    m_minidrvaddr = MinidriverAddr;

    // Initialize handler function address
    m_ptrCheckForHangHandler = 0;
    m_ptrDisableInterruptHandler = 0;
    m_ptrEnableInterruptHandler = 0;
    m_ptrHaltHandler = 0;
    m_ptrHandleInterruptHandler = 0;
    m_ptrInitializeHandler = 0;
    m_ptrIsrHandler = 0;
    m_ptrQueryInformationHandler = 0;
    m_ptrReconfigureHandler = 0;
    m_ptrResetHandler = 0;
    m_ptrSendHandler = 0;
    m_ptrWanSendHandler = 0;
    m_ptrSetInformationHandler = 0;
    m_ptrTransferDataHandler = 0;
    m_ptrWanTransferDataHandler = 0;
    m_ptrReturnPacketHandler = 0;
    m_ptrSendPacketsHandler = 0;
    m_ptrAllocateCompleteHandler = 0;
    m_ptrCancelSendPacketsHandler = 0;
    m_ptrPnpEventNotifyHandler = 0;
    m_ptrAdapterShutdownHandler = 0;

    // Initialize mini-driver start and end address
    m_drvstartaddr = 0;
    m_drvendaddr = 0;

    // Initialize heap to store minidriver's name
    m_drivername = (PWSTR)malloc(MAX_MINIDRV_NAME*sizeof(WCHAR));

}

// CMinidriver destructor
CMinidriver::~CMinidriver()
{
    free(m_drivername);
}

PWSTR WINAPI CMinidriver::GetMDriverName()
{
    ExtRemoteTyped miniDrv("(ndis!_NDIS_M_DRIVER_BLOCK*)@$extin", m_minidrvaddr);

    // NDIS6.X
    if (utils::IsVistaOrAbove())
    {
        WCHAR wDriverName[MAX_MINIDRV_NAME*sizeof(WCHAR)] = { 0 };
        ExtRemoteTyped minidrvName("(nt!_UNICODE_STRING*)@$extin", miniDrv.Field("ServiceName").m_Offset);
        utils::getUnicodeString(minidrvName, wDriverName, MAX_MINIDRV_NAME*sizeof(WCHAR));

        // ServiceName field might be empty
        // Get minidriver name from DriverObject->DriverName
        if (wcslen(wDriverName) == 0)
        {

            ULONG64 ptrMiniDrvObject = miniDrv.Field("DriverObject").GetPtr();
            ExtRemoteTyped miniDrvObject("(nt!_DRIVER_OBJECT*)@$extin", ptrMiniDrvObject);

            // Get minidriver name (eg: "\Driver\NdisWan")
            ExtRemoteTyped minidrvName2("(nt!_UNICODE_STRING*)@$extin", miniDrvObject.Field("DriverName").m_Offset);
            utils::getUnicodeString(minidrvName2, wDriverName, MAX_MINIDRV_NAME*sizeof(WCHAR));
        }

        // Get minidriver name
        PWSTR drvName = wcsrchr(wDriverName, L'\\');

        if (drvName != NULL)
        {
            StringCchCopyW(m_drivername, MAX_MINIDRV_NAME, drvName + 1);
        }
        else
        {
            StringCchCopyW(m_drivername, MAX_MINIDRV_NAME, wDriverName);
        }
    }
    // NDIS5.X
    else
    {
        ExtRemoteTyped minidrvInfo("(ndis!_NDIS_WRAPPER_HANDLE*)@$extin", miniDrv.Field("NdisDriverInfo").GetPtr());
        ExtRemoteTyped minidrvName("(nt!_UNICODE_STRING*)@$extin", minidrvInfo.Field("ServiceRegPath").m_Offset);

        // Get service registry path
        WCHAR wRegPath[MAX_MINIDRV_NAME*sizeof(WCHAR)] = { 0 };
        utils::getUnicodeString(minidrvName, wRegPath, MAX_MINIDRV_NAME*sizeof(WCHAR));

        // Get minidriver name
        PWSTR drvName = wcsrchr(wRegPath, L'\\');

        if (drvName != NULL)
        {
            StringCchCopyW(m_drivername, MAX_MINIDRV_NAME, drvName + 1);
        }
        else
        {
            StringCchCopyW(m_drivername, MAX_MINIDRV_NAME, wRegPath);
        }

    }

    return m_drivername;
}

BOOL WINAPI CMinidriver::IsHandlerHooked(ULONG64 PtrHandler)
{
    BOOL boolIsHooked = (PtrHandler < m_drvstartaddr) && (m_drvendaddr > PtrHandler);

    if (boolIsHooked)
        return true;
    else
        return false;
}

ULONG64 WINAPI CMinidriver::GetDriverStartAddr()
{
    ExtRemoteTyped miniDrv("(ndis!_NDIS_M_DRIVER_BLOCK*)@$extin", m_minidrvaddr);
    BOOLEAN Is64Bit = (g_Ext->m_Control->IsPointer64Bit() == S_OK) ? TRUE : FALSE;
    ExtRemoteTyped drvObj;

    // NDIS6.X
    if (utils::IsVistaOrAbove())
    {
        drvObj = ExtRemoteTyped("(nt!_DRIVER_OBJECT*)@$extin", miniDrv.Field("DriverObject").GetPtr());
    }
    // NDIS5.X
    else
    {
        ExtRemoteTyped minidrvInfo("(ndis!_NDIS_WRAPPER_HANDLE*)@$extin", miniDrv.Field("NdisDriverInfo").GetPtr());
        drvObj = ExtRemoteTyped("(nt!_DRIVER_OBJECT*)@$extin", minidrvInfo.Field("DriverObject").GetPtr());
    }

    m_drvstartaddr = Is64Bit ? drvObj.Field("DriverStart").GetUlong64() : drvObj.Field("DriverStart").GetUlong();
    return m_drvstartaddr;
}

ULONG64 WINAPI CMinidriver::GetDriverEndAddr()
{
    return (m_drvendaddr = utils::getModuleSize(m_drvstartaddr) + m_drvstartaddr);
}

std::map<PCSTR, ULONG64>* WINAPI CMinidriver::GetFunctionHandlers(std::map<PCSTR, ULONG64> *PtrHandlers)
{
    PtrHandlers->insert(std::make_pair("CheckForHangHandler", m_ptrCheckForHangHandler));
    PtrHandlers->insert(std::make_pair("DisableInterruptHandler", m_ptrDisableInterruptHandler));
    PtrHandlers->insert(std::make_pair("EnableInterruptHandler", m_ptrEnableInterruptHandler));
    PtrHandlers->insert(std::make_pair("HaltHandler", m_ptrHaltHandler));
    PtrHandlers->insert(std::make_pair("HandleInterruptHandler", m_ptrHandleInterruptHandler));
    PtrHandlers->insert(std::make_pair("InitializeHandler", m_ptrInitializeHandler));
    PtrHandlers->insert(std::make_pair("ISRHandler", m_ptrIsrHandler));
    PtrHandlers->insert(std::make_pair("QueryInformationHandler", m_ptrQueryInformationHandler));
    PtrHandlers->insert(std::make_pair("ReconfigureHandler", m_ptrReconfigureHandler));
    PtrHandlers->insert(std::make_pair("ResetHandler", m_ptrResetHandler));
    PtrHandlers->insert(std::make_pair("SendHandler", m_ptrSendHandler));
    PtrHandlers->insert(std::make_pair("WanSendHandler", m_ptrWanSendHandler));
    PtrHandlers->insert(std::make_pair("SetInformationHandler", m_ptrSetInformationHandler));
    PtrHandlers->insert(std::make_pair("TransferDataHandler", m_ptrTransferDataHandler));
    PtrHandlers->insert(std::make_pair("WanTransferDataHandler", m_ptrWanTransferDataHandler));
    PtrHandlers->insert(std::make_pair("ReturnPacketHandler", m_ptrReturnPacketHandler));
    PtrHandlers->insert(std::make_pair("SendPacketsHandler", m_ptrSendPacketsHandler));
    PtrHandlers->insert(std::make_pair("AllocateCompleteHandler", m_ptrAllocateCompleteHandler));
    PtrHandlers->insert(std::make_pair("CancelSendPacketsHandler", m_ptrCancelSendPacketsHandler));
    PtrHandlers->insert(std::make_pair("PnpEventNotifyHandler", m_ptrPnpEventNotifyHandler));
    PtrHandlers->insert(std::make_pair("AdapterShutdownHandler", m_ptrAdapterShutdownHandler));

    return PtrHandlers;
}
```

`SwishDbgExt/CNdiskd/CMinidriver.h`:

```h
/*++
    A NDIS hook scan extension to existing Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 wLcY (@x9090)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
--*/

#ifndef _CMINIDRIVER_H_
#define _CMINIDRIVER_H_

#define MAX_MINIDRV_NAME 100

class CMinidriver
{
public:
    CMinidriver(ULONG64);
    ~CMinidriver();
    BOOL WINAPI IsHandlerHooked(ULONG64);
    PWSTR WINAPI GetMDriverName();
    ULONG64 WINAPI GetDriverStartAddr();
    ULONG64 WINAPI GetDriverEndAddr();
    std::map<PCSTR, ULONG64>* WINAPI GetFunctionHandlers(std::map<PCSTR, ULONG64>*);
    ULONG64 m_minidrvaddr;

    // Only partial handler functions that are known to be targeted on Minidriver
    ULONG64 m_ptrCheckForHangHandler;
    ULONG64 m_ptrDisableInterruptHandler;
    ULONG64 m_ptrEnableInterruptHandler;
    ULONG64 m_ptrHaltHandler;
    ULONG64 m_ptrHandleInterruptHandler;
    ULONG64 m_ptrInitializeHandler;
    ULONG64 m_ptrIsrHandler;
    ULONG64 m_ptrQueryInformationHandler;
    ULONG64 m_ptrReconfigureHandler;
    ULONG64 m_ptrResetHandler;
    ULONG64 m_ptrSendHandler;
    ULONG64 m_ptrWanSendHandler;
    ULONG64 m_ptrSetInformationHandler;
    ULONG64 m_ptrTransferDataHandler;
    ULONG64 m_ptrWanTransferDataHandler;
    ULONG64 m_ptrReturnPacketHandler;
    ULONG64 m_ptrSendPacketsHandler;
    ULONG64 m_ptrAllocateCompleteHandler;
    ULONG64 m_ptrCancelSendPacketsHandler;
    ULONG64 m_ptrPnpEventNotifyHandler;
    ULONG64 m_ptrAdapterShutdownHandler;
private:
    PWSTR m_drivername;
    ULONG64 m_drvstartaddr;
    ULONG64 m_drvendaddr;
};

#endif // _CMINIDRIVER_H_
```

`SwishDbgExt/CNdiskd/CNdiskd.cpp`:

```cpp
/*++
    A NDIS hook scan extension to existing Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 wLcY (@x9090)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
--*/

#include "stdafx.h"
#include "..\SwishDbgExt.h"
#include "CNdiskd.h"

// CNdisKd constructor
CNdiskd::CNdiskd()
{
    // Initialize heap to store Ndis build information
    m_ndiskdBuildDate = (PWSTR)LocalAlloc(LMEM_ZEROINIT, MAX_PROTOCOL_NAME*sizeof(WCHAR));
    m_ndiskdBuildTime = (PWSTR)LocalAlloc(LMEM_ZEROINIT, MAX_PROTOCOL_NAME*sizeof(WCHAR));
    m_ndiskdBuiltBy = (PWSTR)LocalAlloc(LMEM_ZEROINIT, MAX_PROTOCOL_NAME*sizeof(WCHAR));
}

// CNdiskd destructor
CNdiskd::~CNdiskd()
{
    // Cleanup
    LocalFree(m_ndiskdBuildDate);
    LocalFree(m_ndiskdBuildTime);
    LocalFree(m_ndiskdBuiltBy);
}

BOOL WINAPI CNdiskd::IsWhitelistedNdisModule(CHAR *moduleName)
{
    if (strstr(moduleName, "ndi") == NULL && strstr(moduleName, "tcp") == NULL &&
        strstr(moduleName, "npf") == NULL && strstr(moduleName, "ndp") == NULL &&
        strstr(moduleName, "wan") == NULL && strstr(moduleName, "psc") == NULL &&
        strstr(moduleName, "ras") == NULL && strstr(moduleName, "vmx") == NULL &&		/* Vmxnet driver name */
        strstr(moduleName, "xxx") == NULL && strstr(moduleName, "asy") == NULL &&		/* Asyncmac miniport driver */
        strstr(moduleName, "agi") == NULL && strstr(moduleName, "e1g") == NULL &&
        strstr(moduleName, "tun") == NULL && strstr(moduleName, "rsp") == NULL &&
        strstr(moduleName, "llt") == NULL &&
        strstr(moduleName, "neo_003") == NULL && /* VPNGate miniport driver */
        strstr(moduleName, "vmnetad") == NULL && /* VMnetAdapter miniport driver */
        strstr(moduleName, "e1c62x6") == NULL && /* E1cexpress miniport driver */
        strstr(moduleName, "vmnetbr") == NULL)   /* VMNet bridge miniport driver */
        return false;
    else
        return true;
}

BOOL WINAPI CNdiskd::IsNdisHook(ULONG64 PtrHandler)
{
    CHAR moduleName[MAX_MODULE_NAME] = { 0 };
    BOOL boolIsHooked, boolWhitelisted = false;

    do
    {
        if (utils::getNameByOffset(PtrHandler, moduleName) == NULL)
            break;

        if (strlen(moduleName) > 0)
        {
            // Convert to lower case
            _strlwr_s(moduleName, sizeof(moduleName));
#if VVERBOSE_MODE
            DbgPrint("DEBUG: %s:%d:%s Checking integrity of module name \"%s\"\n", __FILE__, __LINE__, __FUNCTION__, moduleName);
#endif
            // Check white-listed NDIS module name
            if (CNdiskd::IsWhitelistedNdisModule(moduleName))
            {
                boolWhitelisted = true;
            }
            else
            {
                DbgPrint("DEBUG: %s:%d:%s Module name %s is not whitelisted!\n", __FILE__, __LINE__, __FUNCTION__, moduleName);
            }
        }
    } while (false);

    if (boolWhitelisted)
        boolIsHooked = false;
    else
        boolIsHooked = (PtrHandler < m_ndisBaseAddress) && (m_ndisEndAddress > PtrHandler);

#if VVERBOSE_MODE
    DbgPrint("DEBUG: %s:%d:%s %#I64x vs (%#I64x-%#I64x)\n", __FILE__, __LINE__, __FUNCTION__, PtrHandler, m_ndisBaseAddress, m_ndisEndAddress);
#endif

    if (boolIsHooked)
        return true;
    else
        return false;
}

BOOL WINAPI CNdiskd::HeuristicHookCheck(ULONG64 PtrHandler, int &RuleNo)
{
    BOOL boolIsHooked = false;

    RuleNo = 0;

    do
    {
        //
        // #1 heuristic hook check
        // The handler belong to unamed module
        //
        CHAR moduleName[MAX_MODULE_NAME] = { 0 };

        if (utils::getNameByOffset(PtrHandler, moduleName) == NULL)
        {
            boolIsHooked = true;
            RuleNo = 1;
            break;
        }

        // Convert to lower case
        _strlwr_s(moduleName, sizeof(moduleName));

        if (strlen(moduleName) == 0)
        {
            boolIsHooked = true;
            RuleNo = 1;
            break;
        }

        //
        // #2 heuristic hook check
        // The handler belong to non-whitelisted modules
        //
        if (!CNdiskd::IsWhitelistedNdisModule(moduleName))
        {
            DbgPrint("DEBUG: %s:%d:%s Module name %s is not whitelisted!\n", __FILE__, __LINE__, __FUNCTION__, moduleName);
            boolIsHooked = true;
            RuleNo = 2;
            break;
        }

        //
        // #3 heuristic hook check
        // The prolog of the handler function start with "jmp" instruction
        //
        HRESULT     hres;
        CHAR        buffer[0x100];
        ULONG       disasmSize = 0;
        ULONG64     nextOffset = 0;

        hres =
            g_Ext->m_Control->Disassemble(
            PtrHandler,
            DEBUG_DISASM_EFFECTIVE_ADDRESS,
            buffer,
            sizeof(buffer),
            &disasmSize,
            &nextOffset);

        if (FAILED(hres))
        {
            g_Ext->m_Control->Output(DEBUG_OUTPUT_ERROR, __FUNCTION__ " : IDebugControl::Disassemble failed\n");
        }
        else
        {
            if (strstr(buffer, "jmp") != NULL)
            {
                boolIsHooked = true;
                RuleNo = 3;
                break;
            }
        }

    } while (false);

    if (boolIsHooked)
        return true;
    else
        return false;
}

CHAR* WINAPI CNdiskd::GetHookType(int RuleNo)
{
    switch (RuleNo)
    {
    case 0:
        return "\"Function handler hijacking\"";
    case 1:
        return "\"Unnamed NDIS module\"";
    case 2:
        return "\"Non-whitelisted NDIS module\"";
    case 3:
        return "\"Function handler detour\"";
    default:
        return "\"\"";
    }
}

//////////////////////////////////////////////////////////////////////////
/*
    Get protocol list:
    *Protocol*<--->Binder<--->Adapter
    */
//////////////////////////////////////////////////////////////////////////
std::list<CProtocols*>* WINAPI
CNdiskd::GetProtocolList(std::list<CProtocols*> *protocolList)
{
    ULONG cbBytesReturned;
    ULONG64 Address;

    // Start parsing ndisProtocolList
    Address = GetExpression("ndis!ndisProtocolList");

    if (Address)
    {
        // Obtain the first protocol from the list
        cbBytesReturned = 0;
        Address = utils::getPointerFromAddress(Address, &cbBytesReturned);

        if (cbBytesReturned > 0)
        {

            DbgPrint("DEBUG: %s:%d:%s Ptr to first protocol (NDIS_PROTOCOL_BLOCK) in the list: %p\n", __FILE__, __LINE__, __FUNCTION__, Address);
            ExtRemoteTyped ndisProtocolList("(ndis!_NDIS_PROTOCOL_BLOCK*)@$extin", Address);

            // Enumerating all protocols, starting from first protocol
            do{
                CProtocols *protocol = new CProtocols();
                ULONG64 addrName = utils::getNdisFieldData(Address, ndisProtocolList, "Name");
                ULONG64 addrNextProtocol = utils::getNdisFieldData(Address, ndisProtocolList, "NextProtocol");

                // Set protocol's information
                ExtRemoteTyped protocolName("(nt!_UNICODE_STRING*)@$extin", addrName);

                // Get current protocol name's heap
                PWSTR Name = protocol->GetProtocolName();

                // Save protocol name
                utils::getUnicodeString(protocolName, Name, MAX_PROTOCOL_NAME*sizeof(WCHAR));
                protocol->SetProtocolName(Name);

                // Save protocol version
                protocol->m_majorversion = (UCHAR)utils::getNdisFieldData(0, ndisProtocolList, "MajorNdisVersion");
                protocol->m_minorversion = (UCHAR)utils::getNdisFieldData(0, ndisProtocolList, "MinorNdisVersion");

                // Save handler functions
                protocol->m_ptrReceiveHandler = utils::getNdisFieldData(0, ndisProtocolList, "ReceiveHandler");
                protocol->m_ptrReceivePacketHandler = utils::getNdisFieldData(0, ndisProtocolList, "ReceivePacketHandler");
                protocol->m_ptrReceiveCompleteHandler = utils::getNdisFieldData(0, ndisProtocolList, "ReceiveCompleteHandler");
                protocol->m_ptrWanReceiveHandler = utils::getNdisFieldData(0, ndisProtocolList, "WanReceiveHandler");
                protocol->m_ptrResetCompleteHandler = utils::getNdisFieldData(0, ndisProtocolList, "ResetCompleteHandler");
                protocol->m_ptrWanTransferDataCompleteHandler = utils::getNdisFieldData(0, ndisProtocolList, "WanTransferDataCompleteHandler");
                protocol->m_ptrTransferDataCompleteHandler = utils::getNdisFieldData(0, ndisProtocolList, "TransferDataCompleteHandler");
                protocol->m_ptrWanSendCompleteHandler = utils::getNdisFieldData(0, ndisProtocolList, "WanSendCompleteHandler");
                protocol->m_ptrSendCompleteHandler = utils::getNdisFieldData(0, ndisProtocolList, "SendCompleteHandler");
                protocol->m_ptrCloseAdapterCompleteHandler = utils::getNdisFieldData(0, ndisProtocolList, "CloseAdapterCompleteHandler");
                protocol->m_ptrOpenAdapterCompleteHandler = utils::getNdisFieldData(0, ndisProtocolList, "OpenAdapterCompleteHandler");
                protocol->m_ptrStatusCompleteHandler = utils::getNdisFieldData(0, ndisProtocolList, "StatusCompleteHandler");
                protocol->m_ptrStatusHandler = utils::getNdisFieldData(0, ndisProtocolList, "StatusHandler");
                protocol->m_ptrRequestCompleteHandler = utils::getNdisFieldData(0, ndisProtocolList, "RequestCompleteHandler");
                if (utils::IsVistaOrAbove())
                {
                    protocol->m_ptrSendNetBufferListsCompleteHandler = utils::getNdisFieldData(0, ndisProtocolList, "SendNetBufferListsCompleteHandler");
                    protocol->m_ptrReceiveNetBufferListsHandler = utils::getNdisFieldData(0, ndisProtocolList, "ReceiveNetBufferListsHandler");
                    protocol->m_ptrStatusHandlerEx = utils::getNdisFieldData(0, ndisProtocolList, "StatusHandlerEx");
                }

                // Save protocol start and end address
                // Pick a handler that most likely will not be hooked
                ULONG64 Base;
                ULONG64 addrHandler = utils::getNdisFieldData(0, ndisProtocolList, "PnPEventHandler");

                // Sanity check
                if (addrHandler != NULL)
                {
                    protocol->m_protocolStartAddr = Base = utils::findModuleBase(addrHandler);
                    protocol->m_protocolEndAddr = Base + utils::getModuleSize(Base);
                }

                // Get the module name for the protocol's handler
                CHAR moduleName[MAX_MODULE_NAME] = { 0 };
                utils::getNameByOffset(addrHandler, moduleName);

                StringCchCopyA(protocol->m_ModuleName, MAX_MODULE_NAME, moduleName);

                // For debugging purposes
                DbgPrint("DEBUG: %s:%d:%s Protocol address: %p (%I64x-%I64x [%s]), Protocol name: %msu (v%d.%d)\n",
                    __FILE__, __LINE__, __FUNCTION__, Address, protocol->m_protocolStartAddr, protocol->m_protocolEndAddr,
                    protocol->m_ModuleName, addrName, protocol->m_majorversion, protocol->m_minorversion);
                // Done setting protocol's information, save protocol ptr to vector
                protocolList->push_back(protocol);

                // Next protocol
                Address = utils::getPointerFromAddress(addrNextProtocol, &cbBytesReturned);
                ndisProtocolList = ndisProtocolList.Field("NextProtocol");
            } while (Address != NULL);
        }

    }
    else
    {
        g_Ext->m_Control->Output(DEBUG_OUTPUT_ERROR, __FUNCTION__ ": Unable to find expression ndisProtocolList\n");
    }

    return protocolList;
}// GetProtocolList

//////////////////////////////////////////////////////////////////////////
/*
    Get adapter list:
    Protocol<--->Binder<--->*Adapter*
    */
//////////////////////////////////////////////////////////////////////////
std::list<CAdapters*>* WINAPI
CNdiskd::GetAdapterList(std::list<CAdapters*> *adapterList)
{
    ULONG cbBytesReturned;
    ULONG64 Address;

    // Start parsing Miniport list
    Address = GetExpression("ndis!ndisMiniportList");

    if (Address)
    {
        // Obtain the first protocol from the list
        cbBytesReturned = 0;
        Address = utils::getPointerFromAddress(Address, &cbBytesReturned);

        if (cbBytesReturned > 0)
        {
            DbgPrint("DEBUG: %s:%d:%s Ptr to first adapter (NDIS_MINIPORT_BLOCK) in the list: %p\n", __FILE__, __LINE__, __FUNCTION__, Address);

            ExtRemoteTyped ndisMiniportList("(ndis!_NDIS_MINIPORT_BLOCK*)@$extin", Address);

            // Enumerating all protocols, starting from first protocol
            do{
                CAdapters *adapter = new CAdapters();
                ULONG64 pAdatperName = ndisMiniportList.Field("pAdapterInstanceName").GetPtr();
                ULONG64 addrNextMiniport = utils::getNdisFieldData(Address, ndisMiniportList, "NextGlobalMiniport");

                // Set adapter's information
                ExtRemoteTyped apdaterName("(nt!_UNICODE_STRING*)@$extin", pAdatperName);

                // Get current adapter name's heap
                PWSTR Name = adapter->GetAdapterName();

                // Save adapter name
                utils::getUnicodeString(apdaterName, Name, MAX_ADAPTER_NAME*sizeof(WCHAR));
                adapter->SetAdapterName(Name);

                // Save handler functions
                adapter->m_ptrPacketIndicateHandler = utils::getNdisFieldData(0, ndisMiniportList, "PacketIndicateHandler");
                adapter->m_ptrResetCompleteHandler = utils::getNdisFieldData(0, ndisMiniportList, "ResetCompleteHandler");
                adapter->m_ptrWanSendCompleteHandler = utils::getNdisFieldData(0, ndisMiniportList, "WanSendCompleteHandler");
                adapter->m_ptrSendCompleteHandler = utils::getNdisFieldData(0, ndisMiniportList, "SendCompleteHandler");
                adapter->m_ptrWanRcvHandler = utils::getNdisFieldData(0, ndisMiniportList, "WanRcvHandler");
                adapter->m_ptrWanRcvCompleteHandler = utils::getNdisFieldData(0, ndisMiniportList, "WanRcvCompleteHandler");
                adapter->m_ptrStatusCompleteHandler = utils::getNdisFieldData(0, ndisMiniportList, "StatusCompleteHandler");
                adapter->m_ptrStatusHandler = utils::getNdisFieldData(0, ndisMiniportList, "StatusHandler");

                if (utils::IsVistaOrAbove())
                {
                    adapter->m_ptrSendNetBufferListsCompleteHandler = utils::getNdisFieldData(0, ndisMiniportList, "SendNetBufferListsCompleteHandler");
                }

                // Save adapter start and end address
                // Pick a handler that most likely will not be hooked
                ULONG64 Base;
                ULONG64 addrHandler = utils::getNdisFieldData(0, ndisMiniportList, "SendResourcesHandler");

                // Sanity check
                if (addrHandler != NULL)
                {
                    adapter->m_ndisStartAddr = Base = utils::findModuleBase(addrHandler);
                    adapter->m_ndisEndAddr = Base + utils::getModuleSize(Base);
                }

                // For debugging purposes
                DbgPrint("DEBUG: %s:%d:%s Adapter address: %p, Adapter name: %msu\n", __FILE__, __LINE__, __FUNCTION__, Address, pAdatperName);

                // Done setting protocol's information, save protocol ptr to vector
                adapterList->push_back(adapter);

                // Next protocol
                Address = utils::getPointerFromAddress(addrNextMiniport, &cbBytesReturned);
                ndisMiniportList = ndisMiniportList.Field("NextGlobalMiniport");
            } while (Address != NULL);
        }

    }
    else
    {
        g_Ext->m_Control->Output(DEBUG_OUTPUT_ERROR, __FUNCTION__ ": Unable to find expression ndisMiniportList\n");
    }

    return adapterList;
}// GetAdapterList

//////////////////////////////////////////////////////////////////////////
/*
    Get open binder list:
    Protocol<--->*Binder*<--->Adapter
    */
//////////////////////////////////////////////////////////////////////////
std::list<COpenblock*>* WINAPI
CNdiskd::GetOpenblockList(std::list<COpenblock*> *openblockList)
{
    ULONG cbBytesReturned;
    ULONG64 Address;

    // Start parsing open block list
    Address = GetExpression("ndis!ndisGlobalOpenList");

    if (Address)
    {
        // Obtain the first open block from the list
        cbBytesReturned = 0;
        Address = utils::getPointerFromAddress(Address, &cbBytesReturned);

        if (cbBytesReturned > 0)
        {
            DbgPrint("DEBUG: %s:%d:%s Ptr to first adapter (NDIS_OPEN_BLOCK) in the list: %p\n", __FILE__, __LINE__, __FUNCTION__, Address);

            ExtRemoteTyped ndisOpenblockList("(ndis!_NDIS_OPEN_BLOCK*)@$extin", Address);

            // Enumerating all binders, starting from first binder
            do{
                COpenblock *binder = new COpenblock(Address);
                ULONG64 addrName = ndisOpenblockList.Field("BindDeviceName").GetPtr();
                ULONG64 addrNextOpenBlock = utils::getNdisFieldData(Address, ndisOpenblockList, "NextGlobalOpen");

                // Set binder's information
                ExtRemoteTyped usbinderName("(nt!_UNICODE_STRING*)@$extin", addrName);

                // Get current binder name's heap
                PWSTR Name = binder->GetBinderName();

                // Save binder name
                utils::getUnicodeString(usbinderName, Name, MAX_BINDING_NAME*sizeof(WCHAR));
                binder->SetBinderName(Name);

                // Get protocol associated with the binder
                PWSTR protName = binder->GetProtocolName();

                // Get adapter associated with the binder
                PWSTR adaptName = binder->GetAdpaterName();

                // Save handler functions
                binder->m_ptrSendHandler = utils::getNdisFieldData(0, ndisOpenblockList, "SendHandler");
                binder->m_ptrResetCompleteHandler = utils::getNdisFieldData(0, ndisOpenblockList, "ResetCompleteHandler");
                binder->m_ptrSendCompleteHandler = utils::getNdisFieldData(0, ndisOpenblockList, "SendCompleteHandler");
                binder->m_ptrSendPacketsHandler = utils::getNdisFieldData(0, ndisOpenblockList, "SendPacketsHandler");
                binder->m_ptrReceiveHandler = utils::getNdisFieldData(0, ndisOpenblockList, "ReceiveHandler");
                binder->m_ptrReceiveCompleteHandler = utils::getNdisFieldData(0, ndisOpenblockList, "ReceiveCompleteHandler");
                binder->m_ptrWanReceiveHandler = utils::getNdisFieldData(0, ndisOpenblockList, "WanReceiveHandler");
                binder->m_ptrRequestCompleteHandler = utils::getNdisFieldData(0, ndisOpenblockList, "RequestCompleteHandler");
                binder->m_ptrReceivePacketHandler = utils::getNdisFieldData(0, ndisOpenblockList, "ReceivePacketHandler");
                binder->m_ptrWanSendHandler = utils::getNdisFieldData(0, ndisOpenblockList, "WanSendHandler");
                binder->m_ptrStatusCompleteHandler = utils::getNdisFieldData(0, ndisOpenblockList, "StatusCompleteHandler");
                binder->m_ptrStatusHandler = utils::getNdisFieldData(0, ndisOpenblockList, "StatusHandler");

                if (utils::IsVistaOrAbove())
                {
                    binder->m_ptrReceiveNetBufferLists = utils::getNdisFieldData(0, ndisOpenblockList, "ReceiveNetBufferLists");
                }

                // Save NDIS module start and end address that will be later used to check if the 
                // function handlers have been hooked
                binder->m_ndisStartAddr = m_ndisBaseAddress;
                binder->m_ndisEndAddr = m_ndisEndAddress;

                // Save bounding protocol module start and end address
                // Pick a handler that most likely will not be hooked
                ULONG64 Base;
                ULONG64 addrHandler = utils::getNdisFieldData(0, ndisOpenblockList.Field("ProtocolHandle"), "PnPEventHandler");

                // Sanity check
                if (addrHandler != NULL)
                {
                    binder->m_bindProtocolHandlerStartAddr = Base = utils::findModuleBase(addrHandler);
                    binder->m_bindProtocolHandlerEndAddr = Base + utils::getModuleSize(Base);
                }

                // Save bounding adapter module start and end address
                binder->m_bindAdapterHandlerStartAddr = binder->GetMiniDriverStartAddr();
                binder->m_bindAdapterHandlerEndAddr = binder->GetMiniDriverEndAddr();

                // For debugging purposes
                DbgPrint("DEBUG: %s:%d:%s Binder address: %p, Protocol: %ls<-->Binder: %msu<-->Adapter: %ls\n", __FILE__, __LINE__, __FUNCTION__, Address, protName, addrName, adaptName);

                // Done setting binder's information, save binder's ptr to vector
                openblockList->push_back(binder);

                // Next binder
                Address = utils::getPointerFromAddress(addrNextOpenBlock, &cbBytesReturned);
                ndisOpenblockList = ndisOpenblockList.Field("NextGlobalOpen");
            } while (Address != NULL);
        }

    }
    else
    {
        g_Ext->m_Control->Output(DEBUG_OUTPUT_ERROR, __FUNCTION__ ": Unable to find expression ndisGlobalOpenList\n");
    }

    return openblockList;
}// GetOpenblockList

std::list<CMinidriver*>* WINAPI
CNdiskd::GetMDriverList(std::list<CMinidriver*> *mDrvList)
{
    ULONG cbBytesReturned;
    ULONG64 Address;

    // Start parsing Miniport list
    Address = GetExpression("ndis!ndisMinidriverList");

    if (Address)
    {
        // Obtain the first protocol from the list
        cbBytesReturned = 0;
        Address = utils::getPointerFromAddress(Address, &cbBytesReturned);

        if (cbBytesReturned > 0)
        {
            DbgPrint("DEBUG: %s:%d:%s Ptr to first minidriver (NDIS_M_DRIVER_BLOCK) in the list: %p\n", __FILE__, __LINE__, __FUNCTION__, Address);

            ExtRemoteTyped ndisMiniDrvList("(ndis!_NDIS_M_DRIVER_BLOCK*)@$extin", Address);

            // Enumerating all mini-drivers, starting from first mini-driver
            do{
                CMinidriver *minidriver = new CMinidriver(Address);
                ULONG64 addrNextMDrv = utils::getNdisFieldData(Address, ndisMiniDrvList, "NextDriver");

                // Save handler functions
                minidriver->m_ptrCheckForHangHandler = utils::getNdisFieldData(0, ndisMiniDrvList, "MiniportCharacteristics.CheckForHangHandler");
                minidriver->m_ptrDisableInterruptHandler = utils::getNdisFieldData(0, ndisMiniDrvList, "MiniportCharacteristics.DisableInterruptHandler");
                minidriver->m_ptrEnableInterruptHandler = utils::getNdisFieldData(0, ndisMiniDrvList, "MiniportCharacteristics.EnableInterruptHandler");
                minidriver->m_ptrHaltHandler = utils::getNdisFieldData(0, ndisMiniDrvList, "MiniportCharacteristics.HaltHandler");
                minidriver->m_ptrHandleInterruptHandler = utils::getNdisFieldData(0, ndisMiniDrvList, "MiniportCharacteristics.HandleInterruptHandler");
                minidriver->m_ptrInitializeHandler = utils::getNdisFieldData(0, ndisMiniDrvList, "MiniportCharacteristics.InitializeHandler");
                minidriver->m_ptrIsrHandler = utils::getNdisFieldData(0, ndisMiniDrvList, "MiniportCharacteristics.ISRHandler");
                minidriver->m_ptrQueryInformationHandler = utils::getNdisFieldData(0, ndisMiniDrvList, "MiniportCharacteristics.QueryInformationHandler");
                minidriver->m_ptrReconfigureHandler = utils::getNdisFieldData(0, ndisMiniDrvList, "MiniportCharacteristics.ReconfigureHandler");
                minidriver->m_ptrResetHandler = utils::getNdisFieldData(0, ndisMiniDrvList, "MiniportCharacteristics.ResetHandler");
                minidriver->m_ptrSendHandler = utils::getNdisFieldData(0, ndisMiniDrvList, "MiniportCharacteristics.SendHandler");
                minidriver->m_ptrWanSendHandler = utils::getNdisFieldData(0, ndisMiniDrvList, "MiniportCharacteristics.WanSendHandler");
                minidriver->m_ptrSetInformationHandler = utils::getNdisFieldData(0, ndisMiniDrvList, "MiniportCharacteristics.SetInformationHandler");
                minidriver->m_ptrTransferDataHandler = utils::getNdisFieldData(0, ndisMiniDrvList, "MiniportCharacteristics.TransferDataHandler");
                minidriver->m_ptrWanTransferDataHandler = utils::getNdisFieldData(0, ndisMiniDrvList, "MiniportCharacteristics.WanTransferDataHandler");
                minidriver->m_ptrReturnPacketHandler = utils::getNdisFieldData(0, ndisMiniDrvList, "MiniportCharacteristics.ReturnPacketHandler");
                minidriver->m_ptrSendPacketsHandler = utils::getNdisFieldData(0, ndisMiniDrvList, "MiniportCharacteristics.SendPacketsHandler");
                minidriver->m_ptrAllocateCompleteHandler = utils::getNdisFieldData(0, ndisMiniDrvList, "MiniportCharacteristics.AllocateCompleteHandler");
                minidriver->m_ptrCancelSendPacketsHandler = utils::getNdisFieldData(0, ndisMiniDrvList, "MiniportCharacteristics.CancelSendPacketsHandler");
                minidriver->m_ptrPnpEventNotifyHandler = utils::getNdisFieldData(0, ndisMiniDrvList, "MiniportCharacteristics.PnPEventNotifyHandler");
                minidriver->m_ptrAdapterShutdownHandler = utils::getNdisFieldData(0, ndisMiniDrvList, "MiniportCharacteristics.AdapterShutdownHandler");

                // For debugging purposes
                PWSTR MDrvName = minidriver->GetMDriverName();
                DbgPrint("DEBUG: %s:%d:%s Mini-driver address: %p, Mini-driver name: %ls\n", __FILE__, __LINE__, __FUNCTION__, Address, MDrvName);

                // Done setting protocol's information, save protocol ptr to vector
                mDrvList->push_back(minidriver);

                // Next protocol
                Address = utils::getPointerFromAddress(addrNextMDrv, &cbBytesReturned);
                ndisMiniDrvList = ndisMiniDrvList.Field("NextDriver");
            } while (Address != NULL);
        }

    }
    else
    {
        g_Ext->m_Control->Output(DEBUG_OUTPUT_ERROR, __FUNCTION__ ": Unable to find expression ndisMinidriverList\n");
    }

    return mDrvList;
}// GetMDriverList
```

`SwishDbgExt/CNdiskd/CNdiskd.h`:

```h
/*++
    A NDIS hook scan extension to existing Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 wLcY (@x9090)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
--*/

#ifndef _CNDISKD_H_
#define _CNDISKD_H_

#ifdef _DEBUG
#define DBG 1
#else
#define DBG 0
#endif

#include <windows.h>
#include <intsafe.h>
#include <string.h>
#include <list>
#include <strsafe.h>
#include <map>
#include <vector>
#include <stdio.h>
#include <stdarg.h>
#define KDEXT_64BIT  
#include "CProtocols.h"
#include "CAdapters.h"
#include "COpenblock.h"
#include "CMinidriver.h"
#include "CReport.h"
#include "utils.h"

#define SIGN_EXTEND(_x_) (ULONG64)(LONG)(_x_)
#define NDIS_NAME "ndis"
#define NDIS_DRV_NAME "ndis.sys"

class CNdiskd
{
public:
    CNdiskd();
    ~CNdiskd();
    BOOL WINAPI IsNdisHook(ULONG64);
    BOOL WINAPI HeuristicHookCheck(ULONG64, int&);
    CHAR* WINAPI GetHookType(int);
    ULONG64 m_ndisBaseAddress;
    ULONG64 m_ndisEndAddress;
    ULONG m_ndiskdChecked;
    PWSTR m_ndiskdBuildDate;
    PWSTR m_ndiskdBuildTime;
    PWSTR m_ndiskdBuiltBy;
    std::list<CProtocols*>* WINAPI GetProtocolList(std::list<CProtocols*> *protocolList);
    std::list<CAdapters*>* WINAPI GetAdapterList(std::list<CAdapters*> *adapterList);
    std::list<COpenblock*>* WINAPI GetOpenblockList(std::list<COpenblock*> *openblockList);
    std::list<CMinidriver*>* WINAPI GetMDriverList(std::list<CMinidriver*> *mDrvList);
private:
    BOOL WINAPI IsWhitelistedNdisModule(CHAR*);
};

#endif
```

`SwishDbgExt/CNdiskd/COpenblock.cpp`:

```cpp
/*++
    A NDIS hook scan extension to existing Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 wLcY (@x9090)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
--*/

#include "stdafx.h"
#include "CNdiskd.h"


// COpenblock constructor
COpenblock::COpenblock(ULONG64 OpenBlockAddr)
{
    // Initialize binder address
    m_binderAddress = OpenBlockAddr;

    // Initialize NDIS module start and end address
    m_ndisStartAddr = 0;
    m_ndisEndAddr = 0;

    // Initialize the bounding protocol module start and end address
    m_bindProtocolHandlerStartAddr = 0;
    m_bindProtocolHandlerEndAddr = 0;

    // Initialize the bounding adapter module start and end address
    m_bindAdapterHandlerStartAddr = 0;
    m_bindAdapterHandlerEndAddr = 0;

    // Initialize handler function address
    m_ptrSendHandler = 0;
    m_ptrSendCompleteHandler = 0;
    m_ptrSendPacketsHandler = 0;
    m_ptrReceiveHandler = 0;
    m_ptrReceiveCompleteHandler = 0;
    m_ptrResetCompleteHandler = 0;
    m_ptrStatusHandler = 0;
    m_ptrStatusCompleteHandler = 0;
    m_ptrWanReceiveHandler = 0;
    m_ptrRequestCompleteHandler = 0;
    m_ptrReceivePacketHandler = 0;
    m_ptrWanSendHandler = 0;
    m_ptrReceiveNetBufferLists = 0;

    // Initialize heap to store protocol's information
    m_bindingname = (PWSTR)malloc(MAX_BINDING_NAME*sizeof(WCHAR));
    m_protocolname = (PWSTR)malloc(MAX_PROTOCOL_NAME*sizeof(WCHAR));
    m_adaptername = (PWSTR)malloc(MAX_ADAPTER_NAME*sizeof(WCHAR));
}

// COpenblock destructor
COpenblock::~COpenblock()
{
    // Cleanup
    free(m_bindingname);
    free(m_protocolname);
    free(m_adaptername);

}

BOOL WINAPI COpenblock::IsHandlerHooked(ULONG64 PtrHandler)
{
    // If the binder's handler not belong to/within:
    // - Miniport (eg: NDIS) address range
    // - Protocol (eg: NDISWAN or PSCHED [XP]) address range
    /*
        **** NDIS6.X ****
        kd> !ndiskd.mopen

        Open fffffa800271d8d0
        Miniport: fffffa800210a1a0 - Intel(R) PRO/1000 MT Network Connection
        Protocol: fffffa800198d3b0 - TCPIP

        kd> dt _ndis_open_block SendHandler WanSendHandler  ReceiveHandler  ReceivePacketHandler fffffa800271d8d0
        ndis!_NDIS_OPEN_BLOCK
        +0x060 SendHandler          : 0xfffff880`01589cd0     int  ndis!ndisMSend+0
        +0x060 WanSendHandler       : 0xfffff880`01589cd0     int  ndis!ndisMSend+0
        +0x080 ReceiveHandler       : (null)
        +0x0a0 ReceivePacketHandler : (null)

        **** NDIS5.X ****
        kd> !ndiskd.mopen

        Open 81a681c0
        Miniport: 8185c378 - VMware Accelerated AMD PCNet Adapter
        Protocol: 81a0a220 - PSCHED

        Open 81a80160
        Miniport: 81a07130 - WAN Miniport (L2TP)
        Protocol: 81a60008 - NDISWAN

        kd> dt _ndis_open_block SendHandler WanSendHandler  ReceiveHandler  ReceivePacketHandler  81a681c0
        NDIS!_NDIS_OPEN_BLOCK
        +0x030 SendHandler          : 0xf96f687b     int  NDIS!ndisMSendX+0
        +0x030 WanSendHandler       : 0xf96f687b     int  NDIS!ndisMSendX+0
        +0x040 ReceiveHandler       : 0xf95dc3bc     int  psched!ClReceiveIndication+0
        +0x050 ReceivePacketHandler : 0xf95dc1c8     int  psched!ClReceivePacket+0
        kd> dt _ndis_open_block SendHandler WanSendHandler  ReceiveHandler  ReceivePacketHandler  81a80160
        NDIS!_NDIS_OPEN_BLOCK
        +0x030 SendHandler          : 0xf96f687b     int  NDIS!ndisMSendX+0
        +0x030 WanSendHandler       : 0xf96f687b     int  NDIS!ndisMSendX+0
        +0x040 ReceiveHandler       : 0xf95f0d4b     int  ndiswan!ProtoWanReceiveIndication+0
        +0x050 ReceivePacketHandler : (null)

        */
    BOOL boolIsValid = ((PtrHandler >= m_ndisStartAddr) && (PtrHandler <= m_ndisEndAddr)) || \
        ((PtrHandler >= m_bindProtocolHandlerStartAddr) && (PtrHandler <= m_bindProtocolHandlerEndAddr)) || \
        ((PtrHandler >= m_bindAdapterHandlerStartAddr) && (PtrHandler <= m_bindAdapterHandlerEndAddr));

    if (!boolIsValid)
        return true;
    else
        return false;
}

ULONG64 WINAPI COpenblock::GetMiniDriverStartAddr()
{
    ExtRemoteTyped openBlock("(ndis!_NDIS_OPEN_BLOCK*)@$extin", m_binderAddress);
    BOOLEAN Is64Bit = (g_Ext->m_Control->IsPointer64Bit() == S_OK) ? TRUE : FALSE;
    ExtRemoteTyped miniportBlock, devObj, drvObj;

    miniportBlock = ExtRemoteTyped("(ndis!_NDIS_MINIPORT_BLOCK*)@$extin", openBlock.Field("MiniportHandle").GetPtr());
    devObj = ExtRemoteTyped("(nt!_DEVICE_OBJECT*)@$extin", miniportBlock.Field("DeviceObject").GetPtr());
    drvObj = ExtRemoteTyped("(nt!_DRIVER_OBJECT*)@$extin", devObj.Field("DriverObject").GetPtr());


    m_bindAdapterHandlerStartAddr = Is64Bit ? drvObj.Field("DriverStart").GetUlong64() : drvObj.Field("DriverStart").GetUlong();
    return m_bindAdapterHandlerStartAddr;
}

ULONG64 WINAPI COpenblock::GetMiniDriverEndAddr()
{
    return (m_bindAdapterHandlerEndAddr = utils::getModuleSize(m_bindAdapterHandlerStartAddr) + m_bindAdapterHandlerStartAddr);
}

VOID WINAPI COpenblock::SetBinderName(PWSTR AdatperName)
{
    StringCchCopyW(m_bindingname, MAX_BINDING_NAME, AdatperName);
}

PWSTR WINAPI COpenblock::GetBinderName()
{
    return m_bindingname;
}

PWSTR  WINAPI COpenblock::GetProtocolName()
{
    ExtRemoteTyped openBlock("(ndis!_NDIS_OPEN_BLOCK*)@$extin", m_binderAddress);
    ExtRemoteTyped protBlock("(ndis!_NDIS_PROTOCOL_BLOCK*)@$extin", openBlock.Field("ProtocolHandle").GetPtr());
    ExtRemoteTyped protName("(nt!_UNICODE_STRING*)@$extin", utils::getNdisFieldData(openBlock.Field("ProtocolHandle").GetPtr(), protBlock, "Name"));
    // Get protocol name in m_protocolName
    utils::getUnicodeString(protName, m_protocolname, MAX_PROTOCOL_NAME*sizeof(WCHAR));

    return m_protocolname;
}

PWSTR  WINAPI COpenblock::GetAdpaterName()
{
    ExtRemoteTyped openBlock("(ndis!_NDIS_OPEN_BLOCK*)@$extin", m_binderAddress);
    ExtRemoteTyped miniBlock("(ndis!_NDIS_MINIPORT_BLOCK*)@$extin", openBlock.Field("MiniportHandle").GetPtr());
    ExtRemoteTyped adapterName("(nt!_UNICODE_STRING*)@$extin", miniBlock.Field("pAdapterInstanceName").GetPtr());
    // Get adapter name in m_adaptername
    utils::getUnicodeString(adapterName, m_adaptername, MAX_ADAPTER_NAME*sizeof(WCHAR));

    return m_adaptername;
}

std::map<PCSTR, ULONG64>* WINAPI COpenblock::GetFunctionHandlers(std::map<PCSTR, ULONG64> *PtrHandlers)
{
    PtrHandlers->insert(std::make_pair("SendHandler", m_ptrSendHandler));
    PtrHandlers->insert(std::make_pair("SendCompleteHandler", m_ptrSendCompleteHandler));
    PtrHandlers->insert(std::make_pair("ResetCompleteHandler", m_ptrResetCompleteHandler));
    PtrHandlers->insert(std::make_pair("SendPacketsHandler", m_ptrSendPacketsHandler));
    PtrHandlers->insert(std::make_pair("ReceiveHandler", m_ptrReceiveHandler));
    PtrHandlers->insert(std::make_pair("ReceiveCompleteHandler", m_ptrReceiveCompleteHandler));
    PtrHandlers->insert(std::make_pair("WanReceiveHandler", m_ptrWanReceiveHandler));
    PtrHandlers->insert(std::make_pair("RequestCompleteHandler", m_ptrRequestCompleteHandler));
    PtrHandlers->insert(std::make_pair("ReceivePacketHandler", m_ptrReceivePacketHandler));
    PtrHandlers->insert(std::make_pair("StatusCompleteHandler", m_ptrStatusCompleteHandler));
    PtrHandlers->insert(std::make_pair("StatusHandler", m_ptrStatusHandler));
    PtrHandlers->insert(std::make_pair("WanSendHandler", m_ptrWanSendHandler));
    PtrHandlers->insert(std::make_pair("ReceiveNetBufferLists", m_ptrReceiveNetBufferLists));

    return PtrHandlers;
}
```

`SwishDbgExt/CNdiskd/COpenblock.h`:

```h
/*++
    A NDIS hook scan extension to existing Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 wLcY (@x9090)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
--*/

#ifndef _COPENBLOCKS_H_
#define _COPENBLOCKS_H_

#define MAX_PROTOCOL_NAME 100
#define MAX_ADAPTER_NAME 500
#define MAX_BINDING_NAME 1000

class COpenblock
{
public:
    COpenblock(ULONG64);
    ~COpenblock();
    BOOL WINAPI IsHandlerHooked(ULONG64);
    ULONG64 WINAPI GetMiniDriverStartAddr();
    ULONG64 WINAPI GetMiniDriverEndAddr();
    VOID WINAPI SetBinderName(PWSTR);
    PWSTR WINAPI GetBinderName();
    PWSTR WINAPI GetProtocolName();
    PWSTR WINAPI GetAdpaterName();
    std::map<PCSTR, ULONG64>* WINAPI GetFunctionHandlers(std::map<PCSTR, ULONG64>*);
    ULONG64 m_binderAddress;
    // Will be used in IsHandlerHooked
    ULONG64 m_ndisStartAddr;
    ULONG64 m_ndisEndAddr;
    ULONG64 m_bindProtocolHandlerStartAddr;
    ULONG64 m_bindProtocolHandlerEndAddr;
    ULONG64 m_bindAdapterHandlerStartAddr;
    ULONG64 m_bindAdapterHandlerEndAddr;
    // Only partial handler functions that are known to be targeted on NDIS library
    ULONG64 m_ptrSendHandler;
    ULONG64 m_ptrSendCompleteHandler;
    ULONG64 m_ptrSendPacketsHandler;
    ULONG64 m_ptrReceiveHandler;
    ULONG64 m_ptrReceiveCompleteHandler;
    ULONG64 m_ptrWanReceiveHandler;
    ULONG64 m_ptrRequestCompleteHandler;
    ULONG64 m_ptrResetCompleteHandler;
    ULONG64 m_ptrReceivePacketHandler;
    ULONG64 m_ptrStatusHandler;
    ULONG64 m_ptrStatusCompleteHandler;
    ULONG64 m_ptrWanSendHandler;
    // Available on NDIS6.x
    ULONG64 m_ptrReceiveNetBufferLists;
private:
    PWSTR m_bindingname;
    PWSTR m_protocolname;
    PWSTR m_adaptername;
};

#endif // _COPENBLOCKS_H_
```

`SwishDbgExt/CNdiskd/CProtocols.cpp`:

```cpp
/*++
    A NDIS hook scan extension to existing Incident Response & Digital Forensics Debugging Extension

	Copyright (C) 2014 wLcY (@x9090)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
--*/

#include "stdafx.h"
#include "CNdiskd.h"

// CProtocols constructor
CProtocols::CProtocols()
{
	m_majorversion = 0;
	m_minorversion = 0;
	m_protocolStartAddr = 0;
	m_protocolEndAddr = 0;
	m_ptrReceiveHandler = 0;
	m_ptrReceivePacketHandler = 0;
	m_ptrReceiveCompleteHandler = 0;
	m_ptrWanReceiveHandler = 0;
	m_ptrResetCompleteHandler = 0;
	m_ptrWanTransferDataCompleteHandler = 0;
	m_ptrTransferDataCompleteHandler = 0;
	m_ptrWanSendCompleteHandler = 0;
	m_ptrSendCompleteHandler = 0;
	m_ptrCloseAdapterCompleteHandler = 0;
	m_ptrOpenAdapterCompleteHandler = 0;
	m_ptrSendNetBufferListsCompleteHandler = 0;
	m_ptrReceiveNetBufferListsHandler = 0;
	m_ptrStatusCompleteHandler = 0;
	m_ptrStatusHandler = 0;
	m_ptrStatusHandlerEx = 0;
	m_ptrRequestCompleteHandler = 0;
	// Initialize heap to store protocol's information
	m_protocolname = (PWSTR)malloc(MAX_PROTOCOL_NAME*sizeof(WCHAR));
	m_ModuleName = (PSTR)malloc(MAX_MODULE_NAME);
}

// CProtocols destructor
CProtocols::~CProtocols()
{
	// Cleanup
	free(m_protocolname);
	free(m_ModuleName);
}

VOID WINAPI CProtocols::SetProtocolName(PWSTR ProtocolName)
{
	StringCchCopyW(m_protocolname, MAX_PROTOCOL_NAME, ProtocolName);
}

PWSTR WINAPI CProtocols::GetProtocolName()
{
	return m_protocolname;
}

VOID WINAPI CProtocols::SetPtrHandler(ULONG64 Handler)
{
    UNREFERENCED_PARAMETER(Handler);
}

BOOL WINAPI CProtocols::IsProtocolFuncHandlerHooked(ULONG64 PtrHandler)
{
	BOOL boolIsHooked = (PtrHandler < m_protocolStartAddr) && (PtrHandler > m_protocolEndAddr);

	if (boolIsHooked)
		return true;
	else
		return false;
}

std::map<PCSTR, ULONG64>* WINAPI CProtocols::GetFunctionHandlers(std::map<PCSTR, ULONG64> *PtrHandlers)
{
	PtrHandlers->insert(std::make_pair("ReceiveHandler", m_ptrReceiveHandler));
	PtrHandlers->insert(std::make_pair("ReceivePacketHandler", m_ptrReceivePacketHandler));
	PtrHandlers->insert(std::make_pair("ReceiveCompleteHandler", m_ptrReceiveCompleteHandler));
	PtrHandlers->insert(std::make_pair("WanReceiveHandler", m_ptrWanReceiveHandler));
	PtrHandlers->insert(std::make_pair("ResetCompleteHandler", m_ptrResetCompleteHandler));
	PtrHandlers->insert(std::make_pair("WanTransferDataCompleteHandler", m_ptrWanTransferDataCompleteHandler));
	PtrHandlers->insert(std::make_pair("TransferDataCompleteHandler", m_ptrTransferDataCompleteHandler));
	PtrHandlers->insert(std::make_pair("WanSendCompleteHandler", m_ptrWanSendCompleteHandler));
	PtrHandlers->insert(std::make_pair("SendCompleteHandler", m_ptrSendCompleteHandler));
	PtrHandlers->insert(std::make_pair("CloseAdapterCompleteHandler", m_ptrCloseAdapterCompleteHandler));
	PtrHandlers->insert(std::make_pair("OpenAdapterCompleteHandler", m_ptrOpenAdapterCompleteHandler));
	PtrHandlers->insert(std::make_pair("SendNetBufferListsCompleteHandler", m_ptrSendNetBufferListsCompleteHandler));
	PtrHandlers->insert(std::make_pair("ReceiveNetBufferListsHandler", m_ptrReceiveNetBufferListsHandler));
	PtrHandlers->insert(std::make_pair("StatusCompleteHandler", m_ptrStatusCompleteHandler));
	PtrHandlers->insert(std::make_pair("StatusHandler", m_ptrStatusHandler));
	PtrHandlers->insert(std::make_pair("StatusHandlerEx", m_ptrStatusHandlerEx));
	PtrHandlers->insert(std::make_pair("RequestCompleteHandler", m_ptrRequestCompleteHandler));

	return PtrHandlers;
}
```

`SwishDbgExt/CNdiskd/CProtocols.h`:

```h
/*++
    A NDIS hook scan extension to existing Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 wLcY (@x9090)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
--*/

#ifndef _CPROTOCOLS_H_
#define _CPROTOCOLS_H_

#define MAX_PROTOCOL_NAME 100
#define MAX_MODULE_NAME 256

class CProtocols
{
public:
    CProtocols();
    ~CProtocols();
    BOOL WINAPI IsProtocolFuncHandlerHooked(ULONG64);
    VOID WINAPI SetProtocolName(PWSTR);
    PWSTR WINAPI GetProtocolName();
    VOID WINAPI SetPtrHandler(ULONG64);
    ULONG64 WINAPI GetPtrHandler();
    std::map<PCSTR, ULONG64>* WINAPI GetFunctionHandlers(std::map<PCSTR, ULONG64>*);
    UCHAR m_majorversion;
    UCHAR m_minorversion;
    ULONG64 m_protocolStartAddr;
    ULONG64 m_protocolEndAddr;
    PSTR m_ModuleName;
    // Only partial handler functions that are known to be targeted
    ULONG64 m_ptrReceiveHandler;
    ULONG64 m_ptrReceivePacketHandler;
    ULONG64 m_ptrReceiveCompleteHandler;
    ULONG64 m_ptrWanReceiveHandler;
    ULONG64 m_ptrResetCompleteHandler;
    ULONG64 m_ptrWanTransferDataCompleteHandler;
    ULONG64 m_ptrTransferDataCompleteHandler;
    ULONG64 m_ptrWanSendCompleteHandler;
    ULONG64 m_ptrSendCompleteHandler;
    ULONG64 m_ptrCloseAdapterCompleteHandler;
    ULONG64 m_ptrOpenAdapterCompleteHandler;
    ULONG64 m_ptrSendNetBufferListsCompleteHandler;
    ULONG64 m_ptrReceiveNetBufferListsHandler;
    ULONG64 m_ptrStatusCompleteHandler;
    ULONG64 m_ptrStatusHandler;
    ULONG64 m_ptrStatusHandlerEx;
    ULONG64 m_ptrRequestCompleteHandler;

private:
    PWSTR m_protocolname;
};

#endif // _CPROTOCOLS_H_
```

`SwishDbgExt/CNdiskd/CReport.cpp`:

```cpp
/*++
    A NDIS hook scan extension to existing Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 wLcY (@x9090)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
--*/

#include "stdafx.h"
#include "CNdiskd.h"

CReport::CReport(ExtCheckedPointer<ExtExtension> gExt) : m_gExt(gExt)
{
    // Constructor
}

//////////////////////////////////////////////////////////////////////////
// Output hooks report in using Debugger Markup Language
// @Param: None
// @Return: None
//////////////////////////////////////////////////////////////////////////
VOID WINAPI CReport::ReportHooks(PCSTR Format, ...)
{

    CHAR Buffer[1024] = { 0 };
    va_list Args;

    va_start(Args, Format);

    vsnprintf_s(Buffer, _countof(Buffer), _TRUNCATE, Format, Args);

    m_gExt->Dml(Buffer);

    va_end(Args);
}

```

`SwishDbgExt/CNdiskd/CReport.h`:

```h
/*++
    A NDIS hook scan extension to existing Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 wLcY (@x9090)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
--*/

#ifndef _CREPORT_H_
#define _CREPORT_H_
#pragma once
#include "../engextcpp.hpp"

class CReport
{
public:
    CReport(ExtCheckedPointer<ExtExtension>);
    ~CReport();
    VOID WINAPI ReportHooks(PCSTR, ...);
private:
    ExtCheckedPointer<ExtExtension> m_gExt;
};
#endif // _CREPORT_H_
```

`SwishDbgExt/CNdiskd/utils.cpp`:

```cpp
/*++
    A NDIS hook scan extension to existing Incident Response & Digital Forensics Debugging Extension

	Copyright (C) 2014 wLcY (@x9090)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
--*/

#include "stdafx.h"
#include <intsafe.h>
#include "..\SwishDbgExt.h" // DbgPrint macro
#include "CNdiskd.h"

#define SIGN_EXTEND(_x_) (ULONG64)(LONG)(_x_)

//////////////////////////////////////////////////////////////////////////
// Documented structure definitions
//////////////////////////////////////////////////////////////////////////
typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR   Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

namespace utils {

	BOOL IsVistaOrAbove()
	{
		BOOL bIsWindowsVistaOrLater = false;
		ULONG PlatformId, Win32Major, Win32Minor;
		HRESULT hres;

		hres = g_Ext->m_Control4->GetSystemVersionValues(&PlatformId, &Win32Major, &Win32Minor, NULL, NULL);

		if ( FAILED( hres )  )
			g_Ext->ThrowRemote(hres, "IDebugControl4::GetSystemVersionValues" );

		bIsWindowsVistaOrLater = Win32Major == 6;

		if (bIsWindowsVistaOrLater)
			return true;
		else
			return false;
	}

	ULONG64 findModuleBase(PCSTR moduleName)
	{
		HRESULT     hres;
		ULONG64     base;

		hres = g_Ext->m_Symbols->GetModuleByModuleName(moduleName, 0, NULL, &base);

		if ( FAILED( hres ) )
			g_Ext->ThrowRemote(hres, "IDebugSymbol::GetModuleByModuleName");

		return base;
	}

	ULONG64 findModuleBase(PWSTR moduleName)
	{
		HRESULT     hres;
		ULONG64     base;

		hres = g_Ext->m_Symbols3->GetModuleByModuleNameWide(moduleName, 0, NULL, &base);

		if ( FAILED( hres ) )
			g_Ext->ThrowRemote(hres, "IDebugSymbol3::GetModuleByModuleName");

		return base;
	}

	ULONG64 findModuleBase(ULONG64 offset)
	{
		HRESULT     hres;
		ULONG64     base;
		ULONG       moduleIndex;

		// 32-bit
		if (g_Ext->IsMachine32(g_Ext->m_ActualMachine))
			hres = g_Ext->m_Symbols->GetModuleByOffset(SIGN_EXTEND(offset), 0, &moduleIndex, &base);
		// 64-bit
		else
			hres = g_Ext->m_Symbols->GetModuleByOffset(offset, 0, &moduleIndex, &base);

		if ( FAILED( hres ) )
			g_Ext->ThrowRemote(hres, "IDebugSymbol::GetModuleByOffset. Try reloading symbols (.reload /f)");

		return base;
	}

	ULONG64 getNdisFieldData(ULONG64 Base, ExtRemoteTyped TypedObj, PSTR FieldName)
	{
		CHAR NewFieldName[100] = {0};
		ULONG64 Address;

		// Is object type NDIS_PROTOCOL_BLOCK?
		if (strstr(TypedObj.GetTypeName(), "_NDIS_PROTOCOL_BLOCK") != NULL)
		{
			// Ndis6x does not have ProtocolCharaterisitics
			if (utils::IsVistaOrAbove())
			{
				StringCchCopyA(NewFieldName, _countof(NewFieldName), FieldName);
			}
			// Ndis5x has a union structure ProtocolCharaterisitics
			else 
			{
				if(strcmp(FieldName, "MajorNdisVersion") == 0 || 
					strcmp(FieldName, "MinorNdisVersion") == 0 ||
					strcmp(FieldName, "Name") == 0 ||
					strcmp(FieldName, "Filler") == 0 ||
					strcmp(FieldName, "Reserved") == 0 ||
					strcmp(FieldName, "Flags") == 0 ||
					strstr(FieldName, "Handler") != NULL)
				{
					StringCchCopyA(NewFieldName, _countof(NewFieldName), "ProtocolCharacteristics.");
					StringCchCatA(NewFieldName, _countof(NewFieldName), FieldName);
				}
				else
				{
					StringCchCopyA(NewFieldName, _countof(NewFieldName), FieldName);
				}
			}
		}
		else
		{
			StringCchCopyA(NewFieldName, _countof(NewFieldName), FieldName);
		}

		if (Base > 0)
		{
			Address = Base + TypedObj.GetFieldOffset(NewFieldName);
			return Address;
		}
		else
		{
			switch(TypedObj.Field(NewFieldName).GetTypeSize())
			{
			case 8:
				return TypedObj.Field(NewFieldName).GetLong64();
			case 4:
				return TypedObj.Field(NewFieldName).GetLong();
			case 2:
				return TypedObj.Field(NewFieldName).GetUshort();
			case 1:
				return TypedObj.Field(NewFieldName).GetUchar();
			default:
				return TypedObj.Field(NewFieldName).GetBoolean();
			}
		}
	}

	ULONG64 getPointerFromAddress(ULONG64 Address, PULONG cbBytesRead)
	{
		ULONG Status;
		ULONG64 Result;

		Result = 0;
		if (g_Ext->IsMachine32(g_Ext->m_ActualMachine))
		{
			// SIGN_EXTEND: To mitigate ReadVirtual: xxxxxxxx not properly sign extended warning
			Status = ReadMemory(SIGN_EXTEND(Address), &Result, 4, cbBytesRead);
		}
		else
		{
			Status = ReadMemory(Address, &Result, 8, cbBytesRead);
		}

		if (Status == FALSE)
		{
			g_Ext->m_Control->Output(DEBUG_OUTPUT_ERROR, "Failed to read pointer from 0x%I64x.\n", Address);
		}

		return Result;
	}

	ULONG getUlongFromAddress(ULONG64 Address, PULONG cbBytesRead)
	{
		ULONG Status;
		ULONG Result;

		Result = 0;
		*cbBytesRead = 0;
		Status = ReadMemory(Address, &Result, sizeof(ULONG), cbBytesRead);

		if(Status == FALSE)
		{
			g_Ext->m_Control->Output(DEBUG_OUTPUT_ERROR, "Failed to read value from 0x%I64x.", Address);
		}
		else if(*cbBytesRead != sizeof(ULONG))
		{
			g_Ext->m_Control->Output(DEBUG_OUTPUT_ERROR, "Something wrong when reading value from 0x%I64x.", Address);
		}

		return Result;
	}

	namespace {

		ULONG getModuleSizeImpl( ULONG64 baseOffset )
		{
			HRESULT  hres;
			DEBUG_MODULE_PARAMETERS     moduleParam = { 0 };

			hres = g_Ext->m_Symbols->GetModuleParameters(1, &baseOffset, 0, &moduleParam);
			if ( FAILED( hres ) )
				g_Ext->ThrowRemote(hres, "IDebugSymbol::GetModuleParameters");

			return moduleParam.Size;
		}
	}

	ULONG getModuleSize( ULONG64 baseOffset )
	{
		// 32-bit
		if (g_Ext->IsMachine32(g_Ext->m_ActualMachine))
			return getModuleSizeImpl( SIGN_EXTEND(baseOffset) );
		// 64-bit
		else
			return getModuleSizeImpl( baseOffset );
	}

	PSTR getNameByOffset(ULONG64 addr, PSTR symbolName)
	{
		HRESULT	hres;
		ULONG64	displace = 0;

		RtlZeroMemory(symbolName, sizeof(symbolName));

		// 32-bit
		if (g_Ext->IsMachine32(g_Ext->m_ActualMachine))
			hres = g_Ext->m_Symbols->GetNameByOffset(SIGN_EXTEND(addr), symbolName, sizeof(symbolName), NULL, &displace);
		// 64-bit
		else
			hres = g_Ext->m_Symbols->GetNameByOffset(addr, symbolName, sizeof(symbolName), NULL, &displace);

		if ( FAILED( hres ) )
		{
			//g_Ext->ThrowRemote(hres, "IDebugSymbol::GetNameByOffset failed at 0x%I64x.", addr);
			return NULL;
		}

		return symbolName;
	}

	PSTR getModuleNameByOffset(ULONG64 addr, PSTR moduleName)
	{
		HRESULT	hres;
		ULONG	moduleIndex;
		ULONG64	moduleBase;

		RtlZeroMemory(moduleName, sizeof(moduleName));

		// 32-bit
		if (g_Ext->IsMachine32(g_Ext->m_ActualMachine))
			hres = g_Ext->m_Symbols->GetModuleByOffset(SIGN_EXTEND(addr), 0, &moduleIndex, &moduleBase);
		// 64-bit
		else
			hres = g_Ext->m_Symbols->GetModuleByOffset(addr, 0, &moduleIndex, &moduleBase);

		if ( FAILED( hres ) )
		{
			//g_Ext->ThrowRemote(hres, "IDebugSymbol::GetModuleByOffset failed at 0x%I64x.", addr);
			return NULL;
		}

		hres = g_Ext->m_Symbols2->GetModuleNameString(DEBUG_MODNAME_LOADED_IMAGE, moduleIndex, moduleBase, moduleName, sizeof(moduleName), NULL);

		if ( FAILED( hres ) )
		{
			//g_Ext->ThrowRemote(hres, "IDebugSymbol::GetNameByOffset  failed" );
			return NULL;
		}

		return moduleName;
	}

	PWSTR getUnicodeString(
		IN ExtRemoteTyped TypedObject,
		OUT PWSTR Buffer,
		IN ULONG MaxChars)
	{
		UNICODE_STRING SavedUnicodeString = {0};

		RtlZeroMemory(Buffer, MaxChars);

		SavedUnicodeString.Length = TypedObject.Field("Length").GetUshort();
		SavedUnicodeString.MaximumLength = TypedObject.Field("MaximumLength").GetUshort();
		SavedUnicodeString.Buffer = (PWCH)TypedObject.Field("Buffer").GetPtr();

		if (SavedUnicodeString.Buffer && SavedUnicodeString.Length)
		{
			ExtRemoteData usData((ULONG64)SavedUnicodeString.Buffer, SavedUnicodeString.Length);

			if (SavedUnicodeString.Length > MaxChars)
			{
				g_Ext->ThrowRemote(HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW),
					"String at %p overflows buffer, need 0x%x chars",
					TypedObject.m_Offset, SavedUnicodeString.Length);
			}

#if VVERBOSE_MODE
			ULONG64 ptrBuffer = (ULONG64)SavedUnicodeString.Buffer;
			DbgPrint("DEBUG: %s:%d:%s Get string from %#I64x with length %d to %#p\n", __FILE__, __LINE__, __FUNCTION__, ptrBuffer, SavedUnicodeString.Length, Buffer);
#endif
			usData.GetString(Buffer, SavedUnicodeString.Length, SavedUnicodeString.MaximumLength, false, NULL);
		}

		// Some string is not NULL terminated
		Buffer[SavedUnicodeString.MaximumLength/sizeof(WCHAR)] = '\0';
		return Buffer;
	}


}
```

`SwishDbgExt/CNdiskd/utils.h`:

```h
/*++
    A NDIS hook scan extension to existing Incident Response & Digital Forensics Debugging Extension

	Copyright (C) 2014 wLcY (@x9090)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
--*/
#pragma once
#include "../engextcpp.hpp"

namespace utils {

ULONG64 findModuleBase(PCSTR);
ULONG64 findModuleBase(PWSTR);
ULONG64 findModuleBase(ULONG64);
ULONG64 getNdisFieldData(ULONG64, ExtRemoteTyped, PSTR);
ULONG64 getPointerFromAddress(ULONG64, PULONG);
ULONG getUlongFromAddress(ULONG64, PULONG);
ULONG getModuleSize(ULONG64);
BOOL IsVistaOrAbove();
PSTR getNameByOffset(ULONG64, PSTR);
PSTR getModuleNameByOffset(ULONG64, PSTR);
PWSTR getUnicodeString(ExtRemoteTyped, PWSTR, ULONG);

}
```

`SwishDbgExt/Checks/Codecave.cpp`:

```cpp
                                                                                                                  /*++
    Comae Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2016 Comae Technologies FZE.
    Copyright (C) 2016 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Codecave.cpp

Abstract:

    - https ://breakingmalware.com/injection-techniques/atombombing-brand-new-code-injection-for-windows/

Environment:

    - User mode

Revision History:

    - Matthieu Suiche (m)

--*/

#include "stdafx.h"
#include "../SwishDbgExt.h"

#define VERBOSE FALSE

ULONG
HasUsedCodeCave(
    ULONG64 ImageBase,
    vector<MsPEImageFile::CACHED_SECTION_INFO> *Sections,
    MsPEImageFile::PCACHED_SECTION_INFO SectionHeader,
    PULONG Score
)
{
    ULONG Result = FALSE;
    PUCHAR Buffer = NULL;
    ULONG CorruptionScore = 0;

    ULONG CodeCaveVirtualOffset = SectionHeader->VaBase + min(SectionHeader->VaSize, SectionHeader->RawSize);

    ULONG DeadSpace = TRUE;
    for each (MsPEImageFile::CACHED_SECTION_INFO current in *Sections) {
        if (current.VaBase == CodeCaveVirtualOffset) {

            if (g_Verbose) g_Ext->Dml("[%s!%S!%d] '%s' ends right before '%s' .\n", __FILE__, __FUNCTIONW__, __LINE__, SectionHeader->Name, current.Name);
            DeadSpace = FALSE;
            goto CleanUp;
        }
    }

    ULONG BytesLeft = PAGE_SIZE - (CodeCaveVirtualOffset & (PAGE_SIZE - 1));
    if (!BytesLeft) goto CleanUp;

    Buffer = (LPBYTE)malloc(BytesLeft);
    if (Buffer == NULL) goto CleanUp;

    ULONG64 TargetVa = SIGN_EXTEND(ImageBase + CodeCaveVirtualOffset);

    if (ExtRemoteTypedEx::ReadVirtual(TargetVa, Buffer, BytesLeft, NULL) != S_OK) {
        goto CleanUp;
    }

    //
    // Simple check, to know if the code space null or did someone wrote something into it ?
    //
    for (ULONG i = 0; i < min(BytesLeft, 0x10); i += 1) {
        if ((Buffer[i] != '\xff') && (Buffer[i] != '\0')) {
            CorruptionScore += 1;
        }
    }

    if (CorruptionScore) {
        if (g_Verbose) {
            g_Ext->Dml("            0x%llx + 0x%x + 0x%x = 0x%llx\n", ImageBase, SectionHeader->VaBase, SectionHeader->RawSize, ImageBase + SectionHeader->VaBase + SectionHeader->RawSize);
            g_Ext->Dml("            Data[0] = 0x%02X, Data[1] = 0x%02X, Data[2] = 0x%02X, Data[3] = 0x%02X, \n", Buffer[0], Buffer[1], Buffer[2], Buffer[3]);
            g_Ext->Execute("u 0x%I64X", TargetVa);
        }

        Result = CodeCaveVirtualOffset;
        goto CleanUp;
    }

CleanUp:
    *Score = CorruptionScore;
    if (Buffer) free(Buffer);

    return Result;
}
```

`SwishDbgExt/Checks/Codecave.h`:

```h
/*++
    Comae Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2016 Comae Technologies FZE.
    Copyright (C) 2016 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Codecave.h

Abstract:

    - https ://breakingmalware.com/injection-techniques/atombombing-brand-new-code-injection-for-windows/

Environment:

    - User mode

Revision History:

    - Matthieu Suiche (m)

--*/

#ifndef __CODECAVE_H__
#define __CODECAVE_H__

ULONG
HasUsedCodeCave(
    ULONG64 ImageBase,
    vector<MsPEImageFile::CACHED_SECTION_INFO> *Sections,
    MsPEImageFile::PCACHED_SECTION_INFO SectionHeader,
    PULONG Score
);

#endif
```

`SwishDbgExt/Common.cpp`:

```cpp
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2016 Comae Technologies FZE
    Copyright (C) 2014-2016 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Common.cpp

Abstract:


Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#include "stdafx.h"
#include "SwishDbgExt.h"

PSTR
GetISO8601Date(
    _Out_writes_(Length) PSTR Buffer,
    _In_ ULONG Length,
    _In_ PFILETIME FileTime
    )
{
    SYSTEMTIME SystemTime;

    Buffer[0] = '\0';

    if ((FileTime->dwHighDateTime || FileTime->dwLowDateTime) && FileTimeToSystemTime(FileTime, &SystemTime)) {

        StringCchPrintfA(Buffer,
                         Length,
                         "%i-%02i-%02iT%02i:%02i:%02i.%03iZ",
                         SystemTime.wYear,
                         SystemTime.wMonth,
                         SystemTime.wDay,
                         SystemTime.wHour,
                         SystemTime.wMinute,
                         SystemTime.wSecond,
                         SystemTime.wMilliseconds);
    }

    return Buffer;
}

ULONGLONG
GetTimeStamp(
    VOID
    )
{
    FILETIME ft = {0};
    LARGE_INTEGER li = {0};

    GetSystemTimeAsFileTime(&ft);

    li.HighPart = ft.dwHighDateTime;
    li.LowPart = ft.dwLowDateTime;

    return li.QuadPart;
}

PSTR
GetArchitectureType(
    VOID
    )
{
    switch (g_Ext->m_ActualMachine) {

    case IMAGE_FILE_MACHINE_I386:  return "x86";
    case IMAGE_FILE_MACHINE_AMD64: return "x64";
    default:                       return "Unknown";
    }
}

PSTR
GetDumpType(
    _In_ ULONG Class,
    _In_ ULONG Qualifier
    )
{
    if (Class == DEBUG_CLASS_KERNEL) {

        switch (Qualifier) {

        case DEBUG_KERNEL_CONNECTION:  return "Kernel Connection";
        case DEBUG_KERNEL_LOCAL:       return "Kernel Local";
        case DEBUG_KERNEL_EXDI_DRIVER: return "Kernel EXDI Driver";
        case DEBUG_KERNEL_SMALL_DUMP:  return "Kernel Small Dump";
        case DEBUG_KERNEL_DUMP:        return "Kernel Dump";
        case DEBUG_KERNEL_FULL_DUMP:   return "Kernel Full Dump";
        default:                       return "";
        }
    }

    return "";
}

PSTR
GetTargetName(
    _Out_writes_(Length) PSTR Buffer,
    _In_ ULONG Length
    )
{
    ULONG64 Address;
    WCHAR UnicodeString[MAX_PATH];

    if ((g_Ext->m_Symbols->GetOffsetByName("srv!SrvComputerName", &Address) == S_OK)) {

        ExtRemoteTypedEx::GetUnicodeStringEx(Address, UnicodeString, sizeof(UnicodeString));

        StringCchPrintf(Buffer, Length, "%S", UnicodeString);
    }

    return Buffer;
}

PSTR
GetIpAddressString(
    _Out_writes_(Length) PSTR Buffer,
    _In_ ULONG Length,
    _In_ PBYTE Address,
    _In_ ULONG SizeOfAddress
    )
{
    Buffer[0] = '\0';

    if (SizeOfAddress == sizeof(IN_ADDR)) {

        StringCchPrintf(Buffer,
                        Length,
                        "%d.%d.%d.%d",
                        Address[0],
                        Address[1],
                        Address[2],
                        Address[3]);
    }
    else {

        StringCchPrintf(Buffer,
                        Length,
                        "%x:%x:%x:%x:%x:%x:%x:%x",
                        _byteswap_ushort(((PUSHORT)Address)[0]),
                        _byteswap_ushort(((PUSHORT)Address)[1]),
                        _byteswap_ushort(((PUSHORT)Address)[2]),
                        _byteswap_ushort(((PUSHORT)Address)[3]),
                        _byteswap_ushort(((PUSHORT)Address)[4]),
                        _byteswap_ushort(((PUSHORT)Address)[5]),
                        _byteswap_ushort(((PUSHORT)Address)[6]),
                        _byteswap_ushort(((PUSHORT)Address)[7]));
    }

    return Buffer;
}

PSTR
GetGuidString(
    _Out_writes_(Length) PSTR Buffer,
    _In_ ULONG Length,
    _In_ GUID *Guid
    )
{
    Buffer[0] = '\0';

    StringCchPrintfA(Buffer,
                     Length,
                     "%08lX-%04hX-%04hX-%02hhX%02hhX-%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX",
                     Guid->Data1,
                     Guid->Data2,
                     Guid->Data3,
                     Guid->Data4[0],
                     Guid->Data4[1],
                     Guid->Data4[2],
                     Guid->Data4[3],
                     Guid->Data4[4],
                     Guid->Data4[5],
                     Guid->Data4[6],
                     Guid->Data4[7]);

    return Buffer;
}

PSTR
GetHashString(
    _Out_writes_(Length) PSTR Buffer,
    _In_ ULONG Length,
    _In_ PBYTE Hash,
    _In_ ULONG HashLength
    )
{
    Buffer[0] = '\0';

    CryptBinaryToStringA(Hash, HashLength, CRYPT_STRING_HEXRAW | CRYPT_STRING_NOCRLF, Buffer, &Length);

    return Buffer;
}

_Check_return_
BOOL
GetFileSize(
    _In_ PTSTR FileName,
    _Out_ PLARGE_INTEGER FileSize
    )
{
    BOOL IsOk = FALSE;
    HANDLE hFile;
    OFSTRUCT of;

    hFile = (HANDLE)(ULONG_PTR)OpenFile(FileName, &of, OF_READ);

    if (hFile) {

        if (GetFileSizeEx(hFile, FileSize)) {

            IsOk = TRUE;
        }

        CloseHandle(hFile);
    }

    return IsOk;
}

_Check_return_
BOOL
GetFileHash(
    _Out_writes_(Length) PTSTR Buffer,
    _In_ ULONG Length,
    _In_ PTSTR FileName,
    _In_ DWORD ProviderType,
    _In_ ALG_ID AlgId
    )
{
    HCRYPTPROV hCryptProvider;
    HCRYPTHASH hHash;
    LARGE_INTEGER FileSize;
    LONGLONG TotalNumberOfBytesRead = 0;
    FILE *File;
    PBYTE Data;
    PBYTE Hash;
    DWORD HashLength;
    DWORD NumberOfBytesRead;
    BOOL Status = FALSE;

    Buffer[0] = '\0';

    if (0 == _tfopen_s(&File, FileName, "rb")) {

        if (GetFileSize(FileName, &FileSize)) {

            Data = (PBYTE)calloc(BUFFER_SIZE, sizeof(BYTE));

            if (Data) {

                if (CryptAcquireContext(&hCryptProvider, NULL, NULL, ProviderType, CRYPT_VERIFYCONTEXT)) {

                    if (CryptCreateHash(hCryptProvider, AlgId, NULL, 0, &hHash)) {

                        while ((NumberOfBytesRead = (DWORD)fread(Data, sizeof(BYTE), BUFFER_SIZE, File)) != 0) {

                            TotalNumberOfBytesRead += NumberOfBytesRead;

                            if (!CryptHashData(hHash, (PBYTE)Data, NumberOfBytesRead, 0)) {

                                break;
                            }
                        }

                        if (TotalNumberOfBytesRead == FileSize.QuadPart) {

                            if (CryptGetHashParam(hHash, HP_HASHVAL, NULL, &HashLength, 0)) {

                                Hash = (PBYTE)calloc(HashLength, sizeof(BYTE));

                                if (Hash) {

                                    if (CryptGetHashParam(hHash, HP_HASHVAL, Hash, &HashLength, 0)) {

                                        if (CryptBinaryToString(Hash, HashLength, CRYPT_STRING_HEXRAW | CRYPT_STRING_NOCRLF, Buffer, &Length)) {

                                            Status = TRUE;
                                        }
                                    }

                                    free(Hash);
                                }
                            }
                        }

                        CryptDestroyHash(hHash);
                    }

                    CryptReleaseContext(hCryptProvider, 0);
                }

                free(Data);
            }
        }

        fclose(File);
    }

    return Status;
}

```

`SwishDbgExt/Common.h`:

```h
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2016 Comae Technologies FZE
    Copyright (C) 2014-2016 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Common.h

Abstract:


Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/


#pragma once


#define BUFFER_SIZE 64 * 1024

#define MD5_HASH_LENGTH       16
#define SHA256_HASH_LENGTH    32


PSTR
GetISO8601Date(
    _Out_writes_(Length) PSTR Buffer,
    _In_ ULONG Length,
    _In_ PFILETIME FileTime
    );

ULONGLONG
GetTimeStamp(
    VOID
    );

PSTR
GetArchitectureType(
    VOID
    );

PSTR
GetDumpType(
    _In_ ULONG Class,
    _In_ ULONG Qualifier
    );

PSTR
GetTargetName(
    _Out_writes_(Length) PSTR Buffer,
    _In_ ULONG Length
    );

PSTR
GetIpAddressString(
    _Out_writes_(Length) PSTR Buffer,
    _In_ ULONG Length,
    _In_ PBYTE Address,
    _In_ ULONG SizeOfAddress
    );

PSTR
GetGuidString(
    _Out_writes_(Length) PSTR Buffer,
    _In_ ULONG Length,
    _In_ GUID *Guid
    );

PSTR
GetHashString(
    _Out_writes_(Length) PSTR Buffer,
    _In_ ULONG Length,
    _In_ PBYTE Hash,
    _In_ ULONG HashLength
    );

_Check_return_
BOOL
GetFileSize(
    _In_ PTSTR FileName,
    _Out_ PLARGE_INTEGER FileSize
    );

_Check_return_
BOOL
GetFileHash(
    _Out_writes_(Length) PTSTR Buffer,
    _In_ ULONG Length,
    _In_ PTSTR FileName,
    _In_ DWORD ProviderType,
    _In_ ALG_ID AlgId
    );

```

`SwishDbgExt/Credentials.cpp`:

```cpp
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Credentials.cpp

Abstract:

    - http://msdn.microsoft.com/en-us/windows/ff553536(v=vs.71).aspx

    - Thanks to Benjamin Delpy (@mimikatz) for open sourcing his project.

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#include "stdafx.h"
#include "SwishDbgExt.h"

#define SECURITY_WIN32
#include <ntsecapi.h>
#include <sspi.h>
#include <sddl.h>
#include <wincred.h>
#include <ntsecapi.h>
#include <ntsecpkg.h>

// ULONG g_ProcessorType;
// ULONG g_Ext->m_Machine, g_Major, g_Ext->m_Minor, g_ServicePackNumber;

HMODULE kuhl_m_sekurlsa_nt6_hBCrypt = NULL;

PBCRYPT_OPEN_ALGORITHM_PROVIDER K_BCryptOpenAlgorithmProvider = NULL;
PBCRYPT_SET_PROPERTY K_BCryptSetProperty = NULL;
PBCRYPT_GET_PROPERTY K_BCryptGetProperty = NULL;
PBCRYPT_GENERATE_SYMMETRIC_KEY K_BCryptGenerateSymmetricKey = NULL;
PBCRYPT_ENCRYPT	K_BCryptEncrypt = NULL, K_BCryptDecrypt = NULL;
PBCRYPT_DESTROY_KEY K_BCryptDestroyKey = NULL;
PBCRYPT_CLOSE_ALGORITHM_PROVIDER K_BCryptCloseAlgorithmProvider = NULL;

BCRYPT_GEN_KEY k3Des, kAes;
BYTE InitializationVector[16];

NTSTATUS kuhl_m_sekurlsa_nt6_KeyInit = STATUS_NOT_FOUND;

BOOL
kull_m_string_getDbgUnicodeString(
    _In_ PUNICODE_STRING string
)
/*++

Routine Description:
    Description.

Arguments:
    string - 

Return Value:

    BOOLEAN

--*/
{
    BOOL status = FALSE;
    ULONG_PTR buffer = (ULONG_PTR)string->Buffer;
    string->Buffer = NULL;
    if (buffer && string->MaximumLength)
    {
        string->Buffer = (PWSTR)LocalAlloc(LPTR, string->MaximumLength);

        if (string->Buffer)
        {
            status = ReadMemory(buffer, string->Buffer, string->MaximumLength, NULL);

            if (!status)
            {
                LocalFree(string->Buffer);
                string->Buffer = NULL;
            }
        }
    }
    return status;
}

VOID
WINAPI
kuhl_m_sekurlsa_nt6_LsaUnprotectMemory(
    _In_ PVOID Buffer,
    _In_ ULONG BufferSize
)
/*++

Routine Description:
    Description.

Arguments:
    Buffer - 
    BufferSize - 

Return Value:

    None.

--*/
{
    BCRYPT_KEY_HANDLE *hKey;
    BYTE LocalInitializationVector[16];
    ULONG cbIV, cbResult;
    RtlCopyMemory(LocalInitializationVector, InitializationVector, sizeof(InitializationVector));

    if (BufferSize % 8)
    {
        hKey = &kAes.hKey;
        cbIV = sizeof(InitializationVector);
    }
    else
    {
        hKey = &k3Des.hKey;
        cbIV = sizeof(InitializationVector) / 2;
    }

    K_BCryptDecrypt(*hKey, (PUCHAR)Buffer, BufferSize, 0, LocalInitializationVector, cbIV, (PUCHAR)Buffer, BufferSize, &cbResult, 0);
}

void kuhl_m_sekurlsa_utils_NlpMakeRelativeOrAbsoluteString(
    _In_ PVOID BaseAddress,
    _In_ PLSA_UNICODE_STRING String,
    _In_ BOOLEAN relative
)
/*++

Routine Description:

    Description.

Arguments:

    BaseAddress - 
    String - 
    relative - 

Return Value:

    None.

--*/
{
    if (String->Buffer)
    {
        String->Buffer = (PWSTR)((ULONG_PTR)(String->Buffer) + ((relative ? -1 : 1) * (ULONG_PTR)(BaseAddress)));
    }
}

const char * PRINTF_TYPES[] =
{
    "%02x", // WPRINTF_HEX_SHORT
    "%02x ", // WPRINTF_HEX_SPACE
    "0x%02x, ", // WPRINTF_HEX_C
    "\\x%02x", // WPRINTF_HEX_PYTHON
};

void
kull_m_string_dprintf_hex(
    _In_ LPCVOID lpData,
    _In_ DWORD cbData,
    _In_ DWORD flags
)
/*++

Routine Description:

    Description.

Arguments:

    lpData - 
    cbData - 
    flags - 

Return Value:

    None.

--*/
{
    DWORD i;
    const char * pType = PRINTF_TYPES[flags & 0x0000000f];

    for (i = 0; i < cbData; i++)
    {
        g_Ext->Dml(pType, ((const PBYTE)lpData)[i]);
    }
}

BOOL
kull_m_string_suspectUnicodeString(
    _In_ PUNICODE_STRING pUnicodeString
)
/*++

Routine Description:

    Description.

Arguments:

    pUnicodeString - 

Return Value:

    None.

--*/
{
    int unicodeTestFlags = IS_TEXT_UNICODE_ODD_LENGTH | IS_TEXT_UNICODE_STATISTICS;
    return IsTextUnicode(pUnicodeString->Buffer, pUnicodeString->Length, &unicodeTestFlags);
}

VOID
kuhl_m_sekurlsa_genericKeyOutput(
    _In_ PMARSHALL_KEY key,
    _Inout_ PVOID * dirtyBase
)
/*++

Routine Description:

    Description.

Arguments:

    key - 
    dirtyBase - 

Return Value:

    None.

--*/
{
    switch (key->unkId)
    {
        case 0x00010002:
        case 0x00010003:
            dprintf("\n\t * NTLM     : ");
            break;
        case 0x00020002:
            dprintf("\n\t * SHA1     : ");
            break;
        case 0x00030002:
        case 0x00030003:
            dprintf("\n\t * RootKey  : ");
            break;
        case 0x00040002:
        case 0x00040003:
            dprintf("\n\t * DPAPI    : ");
            break;
        default:
            dprintf("\n\t * %08x : ", key->unkId);
    }

    kull_m_string_dprintf_hex((PBYTE)*dirtyBase + sizeof(ULONG), key->length, 0);
    *dirtyBase = (PBYTE)*dirtyBase + sizeof(ULONG)+*(PULONG)*dirtyBase;
}

void
CALLBACK
kuhl_m_sekurlsa_enum_logon_callback_msv(
    _In_ ULONG64 reserved,
    _In_ PKIWI_BASIC_SECURITY_LOGON_SESSION_DATA pData
)
/*++

Routine Description:

    Description.

Arguments:

    reserved - 
    pData - 

Return Value:

    None.

--*/
{
    // KIWI_MSV1_0_PRIMARY_CREDENTIALS_X64 primaryCredentials;
    vector<ULONG64> Nodes1;
    vector<ULONG64> Nodes2;
    ULONG64 NodeOffset;
    DWORD flags;
    ULONG SizeOfMsv1_0_Credentials;
    ULONG SizeOfMsv1_0_Primary_Credentials;
    ULONG Offset_Cedentials_PrimaryCredentials;
    ULONG Offset_PrimaryCedentials_Credentials;
    ULONG Offset_PrimaryCedentials_Primary;

    UNREFERENCED_PARAMETER(reserved);

    if (g_Ext->m_Machine == IMAGE_FILE_MACHINE_I386)
    {
        SizeOfMsv1_0_Credentials = sizeof(KIWI_MSV1_0_CREDENTIALS_X86);
        SizeOfMsv1_0_Primary_Credentials = sizeof(KIWI_MSV1_0_PRIMARY_CREDENTIALS_X86);

        Offset_Cedentials_PrimaryCredentials = FIELD_OFFSET(KIWI_MSV1_0_CREDENTIALS_X86, PrimaryCredentials);

        Offset_PrimaryCedentials_Credentials = FIELD_OFFSET(KIWI_MSV1_0_PRIMARY_CREDENTIALS_X86, Credentials);
        Offset_PrimaryCedentials_Primary = FIELD_OFFSET(KIWI_MSV1_0_PRIMARY_CREDENTIALS_X86, Primary);
    }
    else
    {
        SizeOfMsv1_0_Credentials = sizeof(KIWI_MSV1_0_CREDENTIALS_X64);
        SizeOfMsv1_0_Primary_Credentials = sizeof(KIWI_MSV1_0_PRIMARY_CREDENTIALS_X64);

        Offset_Cedentials_PrimaryCredentials = FIELD_OFFSET(KIWI_MSV1_0_CREDENTIALS_X64, PrimaryCredentials);

        Offset_PrimaryCedentials_Credentials = FIELD_OFFSET(KIWI_MSV1_0_PRIMARY_CREDENTIALS_X64, Credentials);
        Offset_PrimaryCedentials_Primary = FIELD_OFFSET(KIWI_MSV1_0_PRIMARY_CREDENTIALS_X64, Primary);
    }

    ExtRemoteTypedList CredList(pData->pCredentials, "nt!_SINGLE_LIST_ENTRY", "Next");
    for (CredList.StartHead(); CredList.HasNode(); CredList.Next())
    {
        ULONG64 pPrimary;

        NodeOffset = CredList.GetNodeOffset();

        if (find(Nodes1.rbegin(), Nodes1.rend(), NodeOffset) != Nodes1.rend()) {

            break;
        }

        Nodes1.push_back(NodeOffset);

        if (ReadPointersVirtual(1, NodeOffset + Offset_Cedentials_PrimaryCredentials, &pPrimary) != S_OK) goto CleanUp;

        ExtRemoteTypedList PrimaryCredList(pPrimary, "nt!_SINGLE_LIST_ENTRY", "Next");
        for (PrimaryCredList.StartHead(); PrimaryCredList.HasNode(); PrimaryCredList.Next())
        {
            WCHAR Credential[128] = { 0 };
            WCHAR Primary[128] = { 0 };

            pPrimary = PrimaryCredList.GetNodeOffset();

            if (find(Nodes2.rbegin(), Nodes2.rend(), pPrimary) != Nodes2.rend()) {

                break;
            }

            Nodes2.push_back(pPrimary);

#if 0
            if (g_Ext->m_Data->ReadVirtual(PrimaryCredList.GetNodeOffset(),
                                           &primaryCredentials,
                                           sizeof(primaryCredentials),
                                           NULL) != S_OK) continue;
#endif

            if (!ExtRemoteTypedEx::GetUnicodeStringEx(pPrimary + Offset_PrimaryCedentials_Credentials, (LPWSTR)&Credential, sizeof(Credential))) continue;

            if (!ExtRemoteTypedEx::GetUnicodeStringEx(pPrimary + Offset_PrimaryCedentials_Primary, (LPWSTR)&Primary, sizeof(Primary))) continue;

            // g_Ext->Dml("\n\t [%08x] %S", credentials.AuthenticationPackageId, &Primary);

            if (_wcsicmp(Primary, L"Primary") == 0) flags = KUHL_SEKURLSA_CREDS_DISPLAY_PRIMARY;
            else if (_wcsicmp(Primary, L"CredentialKeys") == 0) flags = KUHL_SEKURLSA_CREDS_DISPLAY_CREDENTIALKEY;
            else flags = 0;

            // NOT IMPLEMENTED
            // kuhl_m_sekurlsa_genericCredsOutput((PKIWI_GENERIC_PRIMARY_CREDENTIAL)&primaryCredentials.Credentials, pData->LogonId, KUHL_SEKURLSA_CREDS_DISPLAY_CREDENTIAL | flags);
        }
    }

CleanUp:
    return;
}

ULONG64
kuhl_m_sekurlsa_utils_pFromAVLByLuidRec(
    _Inout_ ULONG64 pTable,
    _In_ ULONG LUIDoffset,
    _In_ PLUID luidToFind
)
/*++

Routine Description:

    Description.

Arguments:

    pTable - 
    LUIDoffset - 
    luidToFind - 

Return Value:

    None.

--*/
{
    ULONG64 Result = 0;

    LUID Luid;

    ExtRemoteTyped AvlTable("(nt!_RTL_AVL_TABLE *)@$extin", (ULONG64)pTable);
    ULONG64 OrderedPointer = AvlTable.Field("OrderedPointer").GetPtr();

    if (OrderedPointer)
    {
        if (g_Ext->m_Data->ReadVirtual(OrderedPointer + LUIDoffset, &Luid, sizeof(Luid), NULL) != S_OK) goto CleanUp;

        if (RtlEqualLuid(luidToFind, &Luid)) Result = OrderedPointer;
    }

    pTable = AvlTable.Field("BalancedRoot").Field("LeftChild").GetPtr();

    if (!Result && pTable) {

        Result = kuhl_m_sekurlsa_utils_pFromAVLByLuidRec(pTable, LUIDoffset, luidToFind);
    }

    pTable = AvlTable.Field("BalancedRoot").Field("RightChild").GetPtr();

    if (!Result && pTable) {

        Result = kuhl_m_sekurlsa_utils_pFromAVLByLuidRec(pTable, LUIDoffset, luidToFind);
    }

CleanUp:

    return Result;
}

ULONG64
kuhl_m_sekurlsa_utils_pFromAVLByLuid(
    _Inout_ ULONG64 pTable,
    _In_ ULONG LUIDoffset,
    _In_ PLUID luidToFind
)
/*++

Routine Description:

    Description.

Arguments:

    pTable - 
    LUIDoffset - 
    luidToFind - 

Return Value:

    None.

--*/
{
    ULONG64 Result = 0;

    ExtRemoteTyped AvlTable("(nt!_RTL_AVL_TABLE *)@$extin", (ULONG64)pTable);

    ULONG64 RightChild = AvlTable.Field("BalancedRoot").Field("RightChild").GetPtr();

    Result = kuhl_m_sekurlsa_utils_pFromAVLByLuidRec(RightChild, LUIDoffset, luidToFind);

    return Result;
}

void
CALLBACK
kuhl_m_sekurlsa_enum_logon_callback_tspkg(
    _In_ ULONG64 pTSGlobalCredTable,
    _In_ PKIWI_BASIC_SECURITY_LOGON_SESSION_DATA pData
)
/*++

Routine Description:

    Description.

Arguments:

    pTSGlobalCredTable - 
    pData - 

Return Value:

    None.

--*/
{
    ULONG64 Pointer;

    ULONG LuidOffset;
    ULONG TsPrimaryOffset;
    ULONG CredentialsOffset;

    LPWSTR UserNameStr = NULL;
    LPWSTR DomainStr = NULL;
    LPWSTR PasswordStr = NULL;

    ExtRemoteTyped UserName;
    ExtRemoteTyped Domain;
    ExtRemoteTyped Password;

    if (g_Ext->m_Machine == IMAGE_FILE_MACHINE_I386)
    {
        LuidOffset = FIELD_OFFSET(KIWI_TS_CREDENTIAL_X86, LocallyUniqueIdentifier);
        TsPrimaryOffset = FIELD_OFFSET(KIWI_TS_CREDENTIAL_X86, pTsPrimary);
        CredentialsOffset = FIELD_OFFSET(KIWI_TS_PRIMARY_CREDENTIAL_X86, credentials);
    }
    else
    {
        LuidOffset = FIELD_OFFSET(KIWI_TS_CREDENTIAL_X64, LocallyUniqueIdentifier);
        TsPrimaryOffset = FIELD_OFFSET(KIWI_TS_CREDENTIAL_X64, pTsPrimary);
        CredentialsOffset = FIELD_OFFSET(KIWI_TS_PRIMARY_CREDENTIAL_X64, credentials);
    }

    Pointer = kuhl_m_sekurlsa_utils_pFromAVLByLuid(pTSGlobalCredTable, LuidOffset, &pData->LogonId);
    if (!Pointer) goto CleanUp;

    ULONG64 pTsPrimary;

    if (ReadPointersVirtual(1, Pointer + TsPrimaryOffset, &pTsPrimary) != S_OK) goto CleanUp;

    ULONG UnicodeString_Size = GetTypeSize("nt!_UNICODE_STRING");

    //
    // PRIMARY_CREDENTIALS:
    //  LSA_UNICODE_STRING_X86 Domain;
    //  LSA_UNICODE_STRING_X86 UserName;
    //  LSA_UNICODE_STRING_X86 Password;
    //

    Domain = ExtRemoteTyped("(nt!_UNICODE_STRING *)@$extin", (ULONG64)pTsPrimary + CredentialsOffset);
    UserName = ExtRemoteTyped("(nt!_UNICODE_STRING *)@$extin", (ULONG64)pTsPrimary + CredentialsOffset + (UnicodeString_Size * 1));
    Password = ExtRemoteTyped("(nt!_UNICODE_STRING *)@$extin", (ULONG64)pTsPrimary + CredentialsOffset + (UnicodeString_Size * 2));

    UserNameStr = ExtRemoteTypedEx::GetUnicodeString2(UserName);
    DomainStr = ExtRemoteTypedEx::GetUnicodeString2(Domain);

    ULONG PwdMaxLen = Password.Field("MaximumLength").GetUshort();

    PasswordStr = (PWSTR)malloc(PwdMaxLen + sizeof(WCHAR));

    if (PasswordStr) {

        if (g_Ext->m_Data->ReadVirtual(Password.Field("Buffer").GetPtr(), PasswordStr, PwdMaxLen, NULL) != S_OK) goto CleanUp;
        kuhl_m_sekurlsa_nt6_LsaUnprotectMemory(PasswordStr, PwdMaxLen);

        USHORT PwdLen = Password.Field("Length").GetUshort();
        if (PwdLen <= PwdMaxLen)
        {
            PasswordStr[PwdLen / sizeof(PasswordStr[0])] = L'\0';
        }

        g_Ext->Dml("    User: <col fg=\"changed\">%S\\%S</col> = \"<col fg=\"emphfg\">%S</col>\" (Len=%d, MaxLen=%d)\n",
            DomainStr, UserNameStr, PasswordStr,
            PwdLen,
            PwdMaxLen);
    }

CleanUp:
    if (UserNameStr) free(UserNameStr);
    if (DomainStr) free(DomainStr);
    if (PasswordStr) free(PasswordStr);

    return;
}

const CREDMAN_INFOS credhelper[] = {
    {
        sizeof(KIWI_CREDMAN_LIST_ENTRY_60_X86),
        FIELD_OFFSET(KIWI_CREDMAN_LIST_ENTRY_60_X86, List.Flink),
        FIELD_OFFSET(KIWI_CREDMAN_LIST_ENTRY_60_X86, user),
        FIELD_OFFSET(KIWI_CREDMAN_LIST_ENTRY_60_X86, server2),
        FIELD_OFFSET(KIWI_CREDMAN_LIST_ENTRY_60_X86, cbEncPassword),
        FIELD_OFFSET(KIWI_CREDMAN_LIST_ENTRY_60_X86, encPassword),
    },
    {
        sizeof(KIWI_CREDMAN_LIST_ENTRY_X86),
        FIELD_OFFSET(KIWI_CREDMAN_LIST_ENTRY_X86, List1.Flink),
        FIELD_OFFSET(KIWI_CREDMAN_LIST_ENTRY_X86, user),
        FIELD_OFFSET(KIWI_CREDMAN_LIST_ENTRY_X86, server2),
        FIELD_OFFSET(KIWI_CREDMAN_LIST_ENTRY_X86, cbEncPassword),
        FIELD_OFFSET(KIWI_CREDMAN_LIST_ENTRY_X86, encPassword),
    },
    {
        sizeof(KIWI_CREDMAN_LIST_ENTRY_60_X64),
        FIELD_OFFSET(KIWI_CREDMAN_LIST_ENTRY_60_X64, List.Flink),
        FIELD_OFFSET(KIWI_CREDMAN_LIST_ENTRY_60_X64, user),
        FIELD_OFFSET(KIWI_CREDMAN_LIST_ENTRY_60_X64, server2),
        FIELD_OFFSET(KIWI_CREDMAN_LIST_ENTRY_60_X64, cbEncPassword),
        FIELD_OFFSET(KIWI_CREDMAN_LIST_ENTRY_60_X64, encPassword),
    },
    {
        sizeof(KIWI_CREDMAN_LIST_ENTRY_X64),
        FIELD_OFFSET(KIWI_CREDMAN_LIST_ENTRY_X64, List1.Flink),
        FIELD_OFFSET(KIWI_CREDMAN_LIST_ENTRY_X64, user),
        FIELD_OFFSET(KIWI_CREDMAN_LIST_ENTRY_X64, server2),
        FIELD_OFFSET(KIWI_CREDMAN_LIST_ENTRY_X64, cbEncPassword),
        FIELD_OFFSET(KIWI_CREDMAN_LIST_ENTRY_X64, encPassword),
    },
};

void
CALLBACK
kuhl_m_sekurlsa_enum_logon_callback_credman(
    _In_ ULONG64 reserved,
    _In_ PKIWI_BASIC_SECURITY_LOGON_SESSION_DATA pData
)
/*++

Routine Description:

    Description.

Arguments:

    reserved - 
    pData - 

Return Value:

    None.

--*/
{
    //KIWI_CREDMAN_SET_LIST_ENTRY setList;
    //KIWI_CREDMAN_LIST_STARTER listStarter;
    DWORD nbCred = 0;
    ULONG CredOffsetIndex = 0;
    ULONG64 pCur, pRef;

    ULONG list1Offset;
    ULONG startOffset;

    LPWSTR UserNameStr = NULL;
    LPWSTR DomainStr = NULL;
    LPWSTR PasswordStr = NULL;

    UNREFERENCED_PARAMETER(reserved);

    if (g_Ext->m_Machine == IMAGE_FILE_MACHINE_I386)
    {
        list1Offset = FIELD_OFFSET(KIWI_CREDMAN_SET_LIST_ENTRY_X86, list1);
        startOffset = FIELD_OFFSET(KIWI_CREDMAN_LIST_STARTER_X86, start);
        CredOffsetIndex = 0;
    }
    else
    {
        list1Offset = FIELD_OFFSET(KIWI_CREDMAN_SET_LIST_ENTRY_X64, list1);
        startOffset = FIELD_OFFSET(KIWI_CREDMAN_LIST_STARTER_X64, start);
        CredOffsetIndex = 2;
    }


    if (g_Ext->m_Minor < KULL_M_WIN_BUILD_7) CredOffsetIndex += 0;
    else CredOffsetIndex += 1;

    if (!pData->pCredentialManager) goto CleanUp;

    ULONG64 list1;

    if (ReadPointersVirtual(1, pData->pCredentialManager + list1Offset, &list1) != S_OK) goto CleanUp;

    if (!list1) goto CleanUp;

    pRef = list1 + startOffset;

    ULONG64 start;
    if (ReadPointersVirtual(1, list1 + startOffset, &start) != S_OK) goto CleanUp;

    pCur = start;
    while (pCur != pRef)
    {
        pCur -= credhelper[CredOffsetIndex].offsetFLink;

        // kuhl_m_sekurlsa_genericCredsOutput(&kiwiCreds, pData->LogonId, KUHL_SEKURLSA_CREDS_DISPLAY_CREDMANPASS);

        //
        // PRIMARY_CREDENTIALS:
        //  LSA_UNICODE_STRING_X86 UserName;
        //  LSA_UNICODE_STRING_X86 Domaine;
        //  LSA_UNICODE_STRING_X86 Password;
        //

        ExtRemoteTyped UserName("(nt!_UNICODE_STRING *)@$extin", (ULONG64)pCur + credhelper[CredOffsetIndex].offsetUsername);
        ExtRemoteTyped Domain("(nt!_UNICODE_STRING *)@$extin", (ULONG64)pCur + credhelper[CredOffsetIndex].offsetDomain);

        if (UserNameStr) free(UserNameStr);
        if (DomainStr) free(DomainStr);
        if (PasswordStr) free(PasswordStr);

        UserNameStr = ExtRemoteTypedEx::GetUnicodeString2(UserName);
        DomainStr = ExtRemoteTypedEx::GetUnicodeString2(Domain);

        USHORT PwdMaxLen = 0;
        if (g_Ext->m_Data->ReadVirtual(pCur + credhelper[CredOffsetIndex].offsetCbPassword, &PwdMaxLen, sizeof(PwdMaxLen), NULL) != S_OK) goto CleanUp;
        ULONG64 PwdBuffer;
        if (ReadPointersVirtual(1, pCur + credhelper[CredOffsetIndex].offsetPassword, &PwdBuffer) != S_OK) goto CleanUp;

        PasswordStr = (PWSTR)malloc(PwdMaxLen + sizeof(WCHAR));

        if (PasswordStr) {

            RtlZeroMemory(PasswordStr, PwdMaxLen);

            if (g_Ext->m_Data->ReadVirtual(PwdBuffer, PasswordStr, PwdMaxLen, NULL) != S_OK) goto CleanUp;

            kuhl_m_sekurlsa_nt6_LsaUnprotectMemory(PasswordStr, PwdMaxLen);

            PasswordStr[PwdMaxLen / sizeof(PasswordStr[0])] = L'\0';

            g_Ext->Dml("    [%08x] ", nbCred);
            g_Ext->Dml("<col fg=\"changed\">User</col> = \"<col fg=\"emphfg\">%S</col>\", "
                       "<col fg=\"changed\">Domain</col> = \"<col fg=\"emphfg\">%S</col>\", "
                       "<col fg=\"changed\">Password</col> = \"<col fg=\"emphfg\">%S</col>\" (PwdMaxLen=%d)\n",
                       UserNameStr, DomainStr, PasswordStr, PwdMaxLen);
        }

        if (ReadPointersVirtual(1, pCur + credhelper[CredOffsetIndex].offsetFLink, &pCur) != S_OK) goto CleanUp;

        nbCred++;
    }

CleanUp :
    if (UserNameStr) free(UserNameStr);
    if (DomainStr) free(DomainStr);
    if (PasswordStr) free(PasswordStr);

    return;
}


#if 0
void CALLBACK kuhl_m_sekurlsa_enum_logon_callback_kerberos(_In_ ULONG_PTR pKerbGlobalLogonSessionTable, _In_ PKIWI_BASIC_SECURITY_LOGON_SESSION_DATA pData)
{
    KIWI_KERBEROS_LOGON_SESSION session;
    UNICODE_STRING pinCode;
    ULONG_PTR ptr;
    if (ptr = kuhl_m_sekurlsa_utils_pFromAVLByLuid(pKerbGlobalLogonSessionTable, FIELD_OFFSET(KIWI_KERBEROS_LOGON_SESSION, LocallyUniqueIdentifier), pData->LogonId))
    {
        if (ReadMemory(ptr, &session, sizeof(KIWI_KERBEROS_LOGON_SESSION), NULL))
        {
            kuhl_m_sekurlsa_genericCredsOutput(&session.credentials, pData->LogonId, 0);
            if (session.pinCode)
            if (ReadMemory((ULONG_PTR)session.pinCode, &pinCode, sizeof(UNICODE_STRING), NULL))
                kuhl_m_sekurlsa_genericCredsOutput((PKIWI_GENERIC_PRIMARY_CREDENTIAL)&pinCode, pData->LogonId, KUHL_SEKURLSA_CREDS_DISPLAY_PINCODE);
        }
    }
    else g_Ext->Dml("KO");
}

void CALLBACK kuhl_m_sekurlsa_enum_logon_callback_livessp(_In_ ULONG_PTR pLiveGlobalLogonSessionList, _In_ PKIWI_BASIC_SECURITY_LOGON_SESSION_DATA pData)
{
    KIWI_LIVESSP_LIST_ENTRY credentials;
    KIWI_LIVESSP_PRIMARY_CREDENTIAL primaryCredential;
    ULONG_PTR ptr;
    if (ptr = kuhl_m_sekurlsa_utils_pFromLinkedListByLuid(pLiveGlobalLogonSessionList, FIELD_OFFSET(KIWI_LIVESSP_LIST_ENTRY, LocallyUniqueIdentifier), pData->LogonId))
    {
        if (ReadMemory(ptr, &credentials, sizeof(KIWI_LIVESSP_LIST_ENTRY), NULL))
        if (ptr = (ULONG_PTR)credentials.suppCreds)
        if (ReadMemory(ptr, &primaryCredential, sizeof(KIWI_LIVESSP_PRIMARY_CREDENTIAL), NULL))
            kuhl_m_sekurlsa_genericCredsOutput(&primaryCredential.credentials, pData->LogonId, (NtBuildNumber != 9431) ? 0 : KUHL_SEKURLSA_CREDS_DISPLAY_NODECRYPT);
    }
    else g_Ext->Dml("KO");
}

void CALLBACK kuhl_m_sekurlsa_enum_logon_callback_wdigest(_In_ ULONG_PTR pl_LogSessList, _In_ PKIWI_BASIC_SECURITY_LOGON_SESSION_DATA pData)
{
    ULONG_PTR ptr;
    BYTE buffer[offsetWDigestPrimary + sizeof(KIWI_GENERIC_PRIMARY_CREDENTIAL)];
    if (ptr = kuhl_m_sekurlsa_utils_pFromLinkedListByLuid(pl_LogSessList, FIELD_OFFSET(KIWI_WDIGEST_LIST_ENTRY, LocallyUniqueIdentifier), pData->LogonId))
    {
        if (ReadMemory(ptr, buffer, sizeof(buffer), NULL))
            kuhl_m_sekurlsa_genericCredsOutput((PKIWI_GENERIC_PRIMARY_CREDENTIAL)(buffer + offsetWDigestPrimary), pData->LogonId, 0);
    }
    else g_Ext->Dml("KO");
}

void CALLBACK kuhl_m_sekurlsa_enum_logon_callback_ssp(_In_ ULONG_PTR pSspCredentialList, _In_ PKIWI_BASIC_SECURITY_LOGON_SESSION_DATA pData)
{
    KIWI_SSP_CREDENTIAL_LIST_ENTRY mesCredentials;
    ULONG_PTR ptr;
    ULONG monNb = 0;
    if (ReadMemory(pSspCredentialList, &mesCredentials, sizeof(LIST_ENTRY), NULL))
    {
        ptr = (ULONG_PTR)mesCredentials.Flink;
        while (ptr != pSspCredentialList)
        {
            if (ReadMemory(ptr, &mesCredentials, sizeof(KIWI_SSP_CREDENTIAL_LIST_ENTRY), NULL))
            {
                if (RtlEqualLuid(pData->LogonId, &mesCredentials.LogonId) && (mesCredentials.credentials.UserName.Buffer || mesCredentials.credentials.Domaine.Buffer || mesCredentials.credentials.Password.Buffer))
                {
                    g_Ext->Dml("\n\t [%08x]", monNb++);
                    kuhl_m_sekurlsa_genericCredsOutput(&mesCredentials.credentials, pData->LogonId, KUHL_SEKURLSA_CREDS_DISPLAY_SSP | KUHL_SEKURLSA_CREDS_DISPLAY_DOMAIN);
                }
                ptr = (ULONG_PTR)mesCredentials.Flink;
            }
            else break;
        }
    }
    else g_Ext->Dml("KO");
}

void CALLBACK kuhl_m_sekurlsa_enum_logon_callback_masterkeys(_In_ ULONG_PTR pMasterKeyCacheList, _In_ PKIWI_BASIC_SECURITY_LOGON_SESSION_DATA pData)
{
    KIWI_MASTERKEY_CACHE_ENTRY mesCredentials;
    ULONG_PTR ptr;
    ULONG monNb = 0;
    PBYTE buffer;

    if (ReadMemory(pMasterKeyCacheList, &mesCredentials, sizeof(LIST_ENTRY), NULL))
    {
        ptr = (ULONG_PTR)mesCredentials.Flink;
        while (ptr != pMasterKeyCacheList)
        {
            if (ReadMemory(ptr, &mesCredentials, sizeof(KIWI_MASTERKEY_CACHE_ENTRY), NULL))
            {
                if (RtlEqualLuid(pData->LogonId, &mesCredentials.LogonId))
                {
                    g_Ext->Dml("\n\t [%08x]\n\t * GUID :\t", monNb++);
                    kull_m_string_displayGUID(&mesCredentials.KeyUid);
                    g_Ext->Dml("\n\t * Time :\t"); kull_m_string_displayFileTime(&mesCredentials.insertTime);

                    if (buffer = (PBYTE)LocalAlloc(LPTR, mesCredentials.keySize))
                    {
                        if (ReadMemory(ptr + FIELD_OFFSET(KIWI_MASTERKEY_CACHE_ENTRY, key), buffer, mesCredentials.keySize, NULL))
                        {
                            kuhl_m_sekurlsa_nt6_LsaUnprotectMemory(buffer, mesCredentials.keySize);
                            g_Ext->Dml("\n\t * Key :\t"); kull_m_string_dprintf_hex(buffer, mesCredentials.keySize, 0);
                        }
                        LocalFree(buffer);
                    }
                }
                ptr = (ULONG_PTR)mesCredentials.Flink;
            }
            else break;
        }
    }
    else g_Ext->Dml("KO");
}
#endif


KUHL_M_SEKURLSA_PACKAGE packages[] = {
   // { "msv", NULL, 0, kuhl_m_sekurlsa_enum_logon_callback_msv }, // kuhl_m_sekurlsa_enum_logon_callback_msv },
   { "tspkg", "tspkg!TSGlobalCredTable", 0, kuhl_m_sekurlsa_enum_logon_callback_tspkg }, // kuhl_m_sekurlsa_enum_logon_callback_tspkg },
    //{ "wdigest", "wdigest!l_LogSessList", 0, NULL }, // kuhl_m_sekurlsa_enum_logon_callback_wdigest },
    //{ "livessp", "livessp!LiveGlobalLogonSessionList", 0, NULL }, // kuhl_m_sekurlsa_enum_logon_callback_livessp },
    //{ "kerberos", "kerberos!KerbGlobalLogonSessionTable", 0, NULL }, // kuhl_m_sekurlsa_enum_logon_callback_kerberos },
    //{ "ssp", "msv1_0!SspCredentialList", 0, NULL }, // kuhl_m_sekurlsa_enum_logon_callback_ssp },
    //{ "masterkey", "lsasrv!g_MasterKeyCacheList", 0, NULL }, // kuhl_m_sekurlsa_enum_logon_callback_masterkeys },
    //{ "masterkey", "dpapisrv!g_MasterKeyCacheList", 0, NULL }, // kuhl_m_sekurlsa_enum_logon_callback_masterkeys },
    { "credman", NULL, 0, kuhl_m_sekurlsa_enum_logon_callback_credman }, // kuhl_m_sekurlsa_enum_logon_callback_credman },
};

NTSTATUS
kuhl_m_sekurlsa_nt6_acquireKey(
    _In_ ULONG64 phKey,
    _In_ PBCRYPT_GEN_KEY pGenKey
)
/*++

Routine Description:

    Description.

Arguments:

    phKey - 
    pGenKey - 

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    ULONG64 hKey;
    PKIWI_HARD_KEY pHardKey;
    PVOID BcryptKey, BufferHardKey = NULL;
    ULONG64 Ptr;

    ULONG BcryptSize;
    ULONG HardKeyOffset;
    ULONG KeyOffset;
    ULONG HandleKeyTagOffset;
    ULONG BcryptTagOffset;
    ULONG HardKeyDataOffset;

#if VERBOSE_MODE
    g_Ext->Dml("g_Ext->m_Minor = %d g_Ext->m_Machine = %x\n", g_Ext->m_Minor, g_Ext->m_Machine);
#endif

    if (g_Ext->m_Machine == IMAGE_FILE_MACHINE_I386)
    {
        if (g_Ext->m_Minor < 8000)
        {
            BcryptSize = sizeof(KIWI_BCRYPT_KEY_X86);
            HardKeyOffset = FIELD_OFFSET(KIWI_BCRYPT_KEY_X86, hardkey);
        }
        else if (g_Ext->m_Minor < 9400)
        {
            BcryptSize = sizeof(KIWI_BCRYPT_KEY8_X86);
            HardKeyOffset = FIELD_OFFSET(KIWI_BCRYPT_KEY8_X86, hardkey);
        }
        else
        {
            BcryptSize = sizeof(KIWI_BCRYPT_KEY81_X86);
            HardKeyOffset = FIELD_OFFSET(KIWI_BCRYPT_KEY81_X86, hardkey);
        }

        KeyOffset = FIELD_OFFSET(KIWI_BCRYPT_HANDLE_KEY_X86, key);
        HandleKeyTagOffset = FIELD_OFFSET(KIWI_BCRYPT_HANDLE_KEY_X86, tag);
        BcryptTagOffset = FIELD_OFFSET(KIWI_BCRYPT_KEY_X86, tag);
    }
    else
    {
        if (g_Ext->m_Minor < 8000)
        {
            BcryptSize = sizeof(KIWI_BCRYPT_KEY_X64);
            HardKeyOffset = FIELD_OFFSET(KIWI_BCRYPT_KEY_X64, hardkey);
        }
        else if (g_Ext->m_Minor < 9400)
        {
            BcryptSize = sizeof(KIWI_BCRYPT_KEY8_X64);
            HardKeyOffset = FIELD_OFFSET(KIWI_BCRYPT_KEY8_X64, hardkey);
        }
        else
        {
            BcryptSize = sizeof(KIWI_BCRYPT_KEY81_X64);
            HardKeyOffset = FIELD_OFFSET(KIWI_BCRYPT_KEY81_X64, hardkey);
        }

        KeyOffset = FIELD_OFFSET(KIWI_BCRYPT_HANDLE_KEY_X64, key);
        HandleKeyTagOffset = FIELD_OFFSET(KIWI_BCRYPT_HANDLE_KEY_X64, tag);
        BcryptTagOffset = FIELD_OFFSET(KIWI_BCRYPT_KEY_X64, tag);
    }

    HardKeyDataOffset = FIELD_OFFSET(KIWI_HARD_KEY, data);

    BcryptKey = malloc(BcryptSize);
    if (!BcryptKey) goto CleanUp;

    if (ReadPointersVirtual(1, phKey, &Ptr) != S_OK) goto CleanUp;

    ULONG Tag;
    if (ReadPointersVirtual(1, Ptr + KeyOffset, &hKey) != S_OK) goto CleanUp;
    if (g_Ext->m_Data->ReadVirtual(Ptr + HandleKeyTagOffset, &Tag, sizeof(ULONG), NULL) != S_OK) goto CleanUp;
    if (Tag != 'UUUR') goto CleanUp;

    if (g_Ext->m_Data->ReadVirtual(hKey + BcryptTagOffset, &Tag, sizeof(ULONG), NULL) != S_OK) goto CleanUp;
    if (Tag != 'MSSK') goto CleanUp;// same as 8

    if (g_Ext->m_Data->ReadVirtual(hKey, BcryptKey, BcryptSize, NULL) != S_OK) goto CleanUp;

    pHardKey = (PKIWI_HARD_KEY)((PBYTE)BcryptKey + HardKeyOffset);
    BufferHardKey = malloc(pHardKey->cbSecret);
    if (!BufferHardKey) goto CleanUp;

    if (g_Ext->m_Data->ReadVirtual(hKey + HardKeyOffset + FIELD_OFFSET(KIWI_HARD_KEY, data), BufferHardKey, pHardKey->cbSecret, NULL) != S_OK) goto CleanUp;
    NtStatus = K_BCryptGenerateSymmetricKey(pGenKey->hProvider, &pGenKey->hKey, pGenKey->pKey, pGenKey->cbKey, (PUCHAR)BufferHardKey, pHardKey->cbSecret, 0);

CleanUp:
    if (BcryptKey) free(BcryptKey);
    if (BufferHardKey) free(BufferHardKey);

    return NtStatus;
}

NTSTATUS
kuhl_m_sekurlsa_nt6_acquireKeys(
    _In_ ULONG64 pInitializationVector,
    _In_ ULONG64 phAesKey,
    _In_ ULONG64 ph3DesKey
)
/*++

Routine Description:

    Description.

Arguments:

    pInitializationVector - 
    phAesKey - 
    ph3DesKey - 

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus = STATUS_NOT_FOUND;

    if (g_Ext->m_Data->ReadVirtual(pInitializationVector, &InitializationVector, sizeof(InitializationVector), NULL) != S_OK) goto CleanUp;

    NtStatus = kuhl_m_sekurlsa_nt6_acquireKey(ph3DesKey, &k3Des);
#if VERBOSE_MODE
    g_Ext->Dml("-> kuhl_m_sekurlsa_nt6_acquireKey(Des) = %X\n", NtStatus);
#endif
    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = kuhl_m_sekurlsa_nt6_acquireKey(phAesKey, &kAes);
#if VERBOSE_MODE
        g_Ext->Dml("-> kuhl_m_sekurlsa_nt6_acquireKey(Aes) = %X\n", NtStatus);
#endif
    }

CleanUp:
    return NtStatus;
}

NTSTATUS
kuhl_m_sekurlsa_nt6_LsaInitializeProtectedMemory(
)
/*++

Routine Description:

    Description.

Arguments:

    - 

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus;
    ULONG dwSizeNeeded;

    NtStatus = K_BCryptOpenAlgorithmProvider(&k3Des.hProvider, BCRYPT_3DES_ALGORITHM, NULL, 0);
    if (!NT_SUCCESS(NtStatus)) goto CleanUp;

    NtStatus = K_BCryptSetProperty(k3Des.hProvider, BCRYPT_CHAINING_MODE, (PBYTE)BCRYPT_CHAIN_MODE_CBC, sizeof(BCRYPT_CHAIN_MODE_CBC), 0);
    if (!NT_SUCCESS(NtStatus)) goto CleanUp;

    NtStatus = K_BCryptGetProperty(k3Des.hProvider, BCRYPT_OBJECT_LENGTH, (PBYTE)&k3Des.cbKey, sizeof(k3Des.cbKey), &dwSizeNeeded, 0);
    if (!NT_SUCCESS(NtStatus)) goto CleanUp;
    k3Des.pKey = (PBYTE)malloc(k3Des.cbKey);

    NtStatus = K_BCryptOpenAlgorithmProvider(&kAes.hProvider, BCRYPT_AES_ALGORITHM, NULL, 0);
    if (!NT_SUCCESS(NtStatus)) goto CleanUp;

    NtStatus = K_BCryptSetProperty(kAes.hProvider, BCRYPT_CHAINING_MODE, (PBYTE)BCRYPT_CHAIN_MODE_CFB, sizeof(BCRYPT_CHAIN_MODE_CFB), 0);
    if (!NT_SUCCESS(NtStatus)) goto CleanUp;

    NtStatus = K_BCryptGetProperty(kAes.hProvider, BCRYPT_OBJECT_LENGTH, (PBYTE)&kAes.cbKey, sizeof(kAes.cbKey), &dwSizeNeeded, 0);
    if (!NT_SUCCESS(NtStatus)) goto CleanUp; 
    kAes.pKey = (PBYTE)malloc(kAes.cbKey);

CleanUp:
    // g_Ext->Dml("kuhl_m_sekurlsa_nt6_LsaInitializeProtectedMemory(): NtStatus = 0x%X\n", NtStatus);

    return NtStatus;
}

NTSTATUS
kuhl_m_sekurlsa_nt6_init(
)
/*++

Routine Description:

    Description.

Arguments:

    - 

Return Value:

    NTSTATUS.

--*/
{
    if (NT_SUCCESS(kuhl_m_sekurlsa_nt6_KeyInit)) goto CleanUp;

    kuhl_m_sekurlsa_nt6_hBCrypt = LoadLibraryW(L"bcrypt");
    if (!kuhl_m_sekurlsa_nt6_hBCrypt) goto CleanUp;

    K_BCryptOpenAlgorithmProvider = (PBCRYPT_OPEN_ALGORITHM_PROVIDER)GetProcAddress(kuhl_m_sekurlsa_nt6_hBCrypt, "BCryptOpenAlgorithmProvider");
    K_BCryptSetProperty = (PBCRYPT_SET_PROPERTY)GetProcAddress(kuhl_m_sekurlsa_nt6_hBCrypt, "BCryptSetProperty");
    K_BCryptGetProperty = (PBCRYPT_GET_PROPERTY)GetProcAddress(kuhl_m_sekurlsa_nt6_hBCrypt, "BCryptGetProperty");
    K_BCryptGenerateSymmetricKey = (PBCRYPT_GENERATE_SYMMETRIC_KEY)GetProcAddress(kuhl_m_sekurlsa_nt6_hBCrypt, "BCryptGenerateSymmetricKey");
    K_BCryptEncrypt = (PBCRYPT_ENCRYPT)GetProcAddress(kuhl_m_sekurlsa_nt6_hBCrypt, "BCryptEncrypt");
    K_BCryptDecrypt = (PBCRYPT_ENCRYPT)GetProcAddress(kuhl_m_sekurlsa_nt6_hBCrypt, "BCryptDecrypt");
    K_BCryptDestroyKey = (PBCRYPT_DESTROY_KEY)GetProcAddress(kuhl_m_sekurlsa_nt6_hBCrypt, "BCryptDestroyKey");
    K_BCryptCloseAlgorithmProvider = (PBCRYPT_CLOSE_ALGORITHM_PROVIDER)GetProcAddress(kuhl_m_sekurlsa_nt6_hBCrypt, "BCryptCloseAlgorithmProvider");

    if (!kuhl_m_sekurlsa_nt6_hBCrypt || !K_BCryptOpenAlgorithmProvider || !K_BCryptSetProperty ||
        !K_BCryptGetProperty || !K_BCryptGenerateSymmetricKey || !K_BCryptEncrypt ||
        !K_BCryptDecrypt || !K_BCryptDestroyKey || !K_BCryptCloseAlgorithmProvider)
    {
        g_Ext->Dml("One null pointer.\n");
        goto CleanUp;
    }

    kuhl_m_sekurlsa_nt6_KeyInit = kuhl_m_sekurlsa_nt6_LsaInitializeProtectedMemory();

CleanUp:
    // g_Ext->Dml("kuhl_m_sekurlsa_nt6_init(): NtStatus = 0x%X\n", kuhl_m_sekurlsa_nt6_KeyInit);
    return kuhl_m_sekurlsa_nt6_KeyInit;
}

const KUHL_M_SEKURLSA_ENUM_HELPER lsassEnumHelpers_X86[] = {
    { sizeof(KIWI_MSV1_0_LIST_60_X86), FIELD_OFFSET(KIWI_MSV1_0_LIST_60_X86, LocallyUniqueIdentifier), FIELD_OFFSET(KIWI_MSV1_0_LIST_60_X86, LogonType), FIELD_OFFSET(KIWI_MSV1_0_LIST_60_X86, Session), FIELD_OFFSET(KIWI_MSV1_0_LIST_60_X86, UserName), FIELD_OFFSET(KIWI_MSV1_0_LIST_60_X86, Domaine), FIELD_OFFSET(KIWI_MSV1_0_LIST_60_X86, Credentials), FIELD_OFFSET(KIWI_MSV1_0_LIST_60_X86, pSid), FIELD_OFFSET(KIWI_MSV1_0_LIST_60_X86, CredentialManager) },
    { sizeof(KIWI_MSV1_0_LIST_61_X86), FIELD_OFFSET(KIWI_MSV1_0_LIST_61_X86, LocallyUniqueIdentifier), FIELD_OFFSET(KIWI_MSV1_0_LIST_61_X86, LogonType), FIELD_OFFSET(KIWI_MSV1_0_LIST_61_X86, Session), FIELD_OFFSET(KIWI_MSV1_0_LIST_61_X86, UserName), FIELD_OFFSET(KIWI_MSV1_0_LIST_61_X86, Domaine), FIELD_OFFSET(KIWI_MSV1_0_LIST_61_X86, Credentials), FIELD_OFFSET(KIWI_MSV1_0_LIST_61_X86, pSid), FIELD_OFFSET(KIWI_MSV1_0_LIST_61_X86, CredentialManager) },
    { sizeof(KIWI_MSV1_0_LIST_62_X86), FIELD_OFFSET(KIWI_MSV1_0_LIST_62_X86, LocallyUniqueIdentifier), FIELD_OFFSET(KIWI_MSV1_0_LIST_62_X86, LogonType), FIELD_OFFSET(KIWI_MSV1_0_LIST_62_X86, Session), FIELD_OFFSET(KIWI_MSV1_0_LIST_62_X86, UserName), FIELD_OFFSET(KIWI_MSV1_0_LIST_62_X86, Domaine), FIELD_OFFSET(KIWI_MSV1_0_LIST_62_X86, Credentials), FIELD_OFFSET(KIWI_MSV1_0_LIST_62_X86, pSid), FIELD_OFFSET(KIWI_MSV1_0_LIST_62_X86, CredentialManager) },
    { sizeof(KIWI_MSV1_0_LIST_63_X86), FIELD_OFFSET(KIWI_MSV1_0_LIST_63_X86, LocallyUniqueIdentifier), FIELD_OFFSET(KIWI_MSV1_0_LIST_63_X86, LogonType), FIELD_OFFSET(KIWI_MSV1_0_LIST_63_X86, Session), FIELD_OFFSET(KIWI_MSV1_0_LIST_63_X86, UserName), FIELD_OFFSET(KIWI_MSV1_0_LIST_63_X86, Domaine), FIELD_OFFSET(KIWI_MSV1_0_LIST_63_X86, Credentials), FIELD_OFFSET(KIWI_MSV1_0_LIST_63_X86, pSid), FIELD_OFFSET(KIWI_MSV1_0_LIST_63_X86, CredentialManager) },
};

const KUHL_M_SEKURLSA_ENUM_HELPER lsassEnumHelpers_X64[] = {
    { sizeof(KIWI_MSV1_0_LIST_60_X64), FIELD_OFFSET(KIWI_MSV1_0_LIST_60_X64, LocallyUniqueIdentifier), FIELD_OFFSET(KIWI_MSV1_0_LIST_60_X64, LogonType), FIELD_OFFSET(KIWI_MSV1_0_LIST_60_X64, Session), FIELD_OFFSET(KIWI_MSV1_0_LIST_60_X64, UserName), FIELD_OFFSET(KIWI_MSV1_0_LIST_60_X64, Domaine), FIELD_OFFSET(KIWI_MSV1_0_LIST_60_X64, Credentials), FIELD_OFFSET(KIWI_MSV1_0_LIST_60_X64, pSid), FIELD_OFFSET(KIWI_MSV1_0_LIST_60_X64, CredentialManager) },
    { sizeof(KIWI_MSV1_0_LIST_61_X64), FIELD_OFFSET(KIWI_MSV1_0_LIST_61_X64, LocallyUniqueIdentifier), FIELD_OFFSET(KIWI_MSV1_0_LIST_61_X64, LogonType), FIELD_OFFSET(KIWI_MSV1_0_LIST_61_X64, Session), FIELD_OFFSET(KIWI_MSV1_0_LIST_61_X64, UserName), FIELD_OFFSET(KIWI_MSV1_0_LIST_61_X64, Domaine), FIELD_OFFSET(KIWI_MSV1_0_LIST_61_X64, Credentials), FIELD_OFFSET(KIWI_MSV1_0_LIST_61_X64, pSid), FIELD_OFFSET(KIWI_MSV1_0_LIST_61_X64, CredentialManager) },
    { sizeof(KIWI_MSV1_0_LIST_62_X64), FIELD_OFFSET(KIWI_MSV1_0_LIST_62_X64, LocallyUniqueIdentifier), FIELD_OFFSET(KIWI_MSV1_0_LIST_62_X64, LogonType), FIELD_OFFSET(KIWI_MSV1_0_LIST_62_X64, Session), FIELD_OFFSET(KIWI_MSV1_0_LIST_62_X64, UserName), FIELD_OFFSET(KIWI_MSV1_0_LIST_62_X64, Domaine), FIELD_OFFSET(KIWI_MSV1_0_LIST_62_X64, Credentials), FIELD_OFFSET(KIWI_MSV1_0_LIST_62_X64, pSid), FIELD_OFFSET(KIWI_MSV1_0_LIST_62_X64, CredentialManager) },
    { sizeof(KIWI_MSV1_0_LIST_63_X64), FIELD_OFFSET(KIWI_MSV1_0_LIST_63_X64, LocallyUniqueIdentifier), FIELD_OFFSET(KIWI_MSV1_0_LIST_63_X64, LogonType), FIELD_OFFSET(KIWI_MSV1_0_LIST_63_X64, Session), FIELD_OFFSET(KIWI_MSV1_0_LIST_63_X64, UserName), FIELD_OFFSET(KIWI_MSV1_0_LIST_63_X64, Domaine), FIELD_OFFSET(KIWI_MSV1_0_LIST_63_X64, Credentials), FIELD_OFFSET(KIWI_MSV1_0_LIST_63_X64, pSid), FIELD_OFFSET(KIWI_MSV1_0_LIST_63_X64, CredentialManager) },
};

const char * KUHL_M_SEKURLSA_LOGON_TYPE[] = {
    "UndefinedLogonType", "Unknown !", "Interactive", "Network",
    "Batch", "Service", "Proxy", "Unlock", "NetworkCleartext",
    "NewCredentials", "RemoteInteractive", "CachedInteractive",
    "CachedRemoteInteractive", "CachedUnlock",
};

void
Mimikatz(
)
/*++

Routine Description:

    Description.

Arguments:

    - 

Return Value:

    None.

--*/
{
    vector<ULONG64> Nodes;
    ULONG64 pInitializationVector, phAesKey, ph3DesKey, pLogonSessionList, pLogonSessionListCount;
    PULONG64 LogonSessionList = NULL;
    ULONG LogonSessionListCount, i, j;
    PBYTE Buffer = NULL;

    const KUHL_M_SEKURLSA_ENUM_HELPER *Helper;

    KIWI_BASIC_SECURITY_LOGON_SESSION_DATA SessionData;

    MsProcessObject ProcessObject = FindProcessByName("lsass.exe");

    ProcessObject.SwitchContext();

    g_Ext->ExecuteSilent(".process /p /r 0x%I64X", ProcessObject.m_CcProcessObject.ProcessObjectPtr);

    // if (g_Ext->m_Control->GetActualProcessorType(&g_ProcessorType) != S_OK) goto CleanUp;
    // if (g_Ext->m_Control->GetSystemVersion(&g_Ext->m_Machine, &g_Major, &g_Ext->m_Minor, NULL, NULL, NULL, &g_ServicePackNumber, NULL, NULL, NULL) != S_OK) goto CleanUp;

    if (g_Ext->m_Machine == IMAGE_FILE_MACHINE_I386)
    {
        if (g_Ext->m_Minor < KULL_M_WIN_MIN_BUILD_7) Helper = &lsassEnumHelpers_X86[0];
        else if (g_Ext->m_Minor < KULL_M_WIN_MIN_BUILD_8) Helper = &lsassEnumHelpers_X86[1];
        else if (g_Ext->m_Minor < KULL_M_WIN_MIN_BUILD_BLUE) Helper = &lsassEnumHelpers_X86[2];
        else Helper = &lsassEnumHelpers_X86[3];
    }
    else
    {
        if (g_Ext->m_Minor < KULL_M_WIN_MIN_BUILD_7) Helper = &lsassEnumHelpers_X64[0];
        else if (g_Ext->m_Minor < KULL_M_WIN_MIN_BUILD_8) Helper = &lsassEnumHelpers_X64[1];
        else if (g_Ext->m_Minor < KULL_M_WIN_MIN_BUILD_BLUE) Helper = &lsassEnumHelpers_X64[2];
        else Helper = &lsassEnumHelpers_X64[3];
    }

#if VERBOSE_MODE
    g_Ext->Dml("Get variables..\n");
#endif

    if (g_Ext->m_Symbols->GetOffsetByName("lsasrv!InitializationVector", &pInitializationVector) != S_OK) goto CleanUp;
    if (g_Ext->m_Symbols->GetOffsetByName("lsasrv!hAesKey", &phAesKey) != S_OK) goto CleanUp;
    if (g_Ext->m_Symbols->GetOffsetByName("lsasrv!h3DesKey", &ph3DesKey) != S_OK) goto CleanUp;

    if (g_Ext->m_Symbols->GetOffsetByName("lsasrv!LogonSessionList", &pLogonSessionList) != S_OK) goto CleanUp;
    if (g_Ext->m_Symbols->GetOffsetByName("lsasrv!LogonSessionListCount", &pLogonSessionListCount) != S_OK) goto CleanUp;

#if VERBOSE_MODE
    g_Ext->Dml("Got variables..\n");
#endif

    if (!pInitializationVector || !phAesKey || !ph3DesKey) goto CleanUp;
    if (!pLogonSessionListCount || !pLogonSessionList) goto CleanUp;


    for (j = 0; j < sizeof(packages) / sizeof(KUHL_M_SEKURLSA_PACKAGE); j++)
    {
        if (packages[j].symbolName) g_Ext->m_Symbols->GetOffsetByName(packages[j].symbolName, &packages[j].symbolPtr);
    }

#if VERBOSE_MODE
    g_Ext->Dml("One\n");
#endif

    if (!NT_SUCCESS(kuhl_m_sekurlsa_nt6_init())) goto CleanUp;

#if VERBOSE_MODE
    g_Ext->Dml("Two\n");
#endif

    if (!NT_SUCCESS(kuhl_m_sekurlsa_nt6_acquireKeys(pInitializationVector, phAesKey, ph3DesKey))) goto CleanUp;

#if VERBOSE_MODE
    g_Ext->Dml("Three\n");
#endif

    if (g_Ext->m_Data->ReadVirtual(pLogonSessionListCount, &LogonSessionListCount, sizeof(ULONG), NULL) != S_OK) goto CleanUp;

#if VERBOSE_MODE
    g_Ext->Dml("Four\n");
#endif

    ULONG NumberOfPointers = 2 /* Flink + Blink */ * LogonSessionListCount;

    ULONG ListEntrySize = GetTypeSize("nt!_LIST_ENTRY");
    LogonSessionList = (PULONG64)malloc(sizeof(ULONG64)* NumberOfPointers);
    if (!LogonSessionList) goto CleanUp;

    if (ReadPointersVirtual(NumberOfPointers, pLogonSessionList, (PULONG64)LogonSessionList) != S_OK) goto CleanUp;

    Buffer = (PBYTE)malloc(Helper->tailleStruct);
    if (!Buffer) goto CleanUp;

    g_Ext->Dml("LogonSessionListCount: %d\n", LogonSessionListCount);
    for (i = 0; i < LogonSessionListCount; i++)
    {
        ULONG64 Flink = LogonSessionList[i * 2]; // Flink;

        // g_Ext->Dml("Flink = %I64X\n", Flink);
        ExtRemoteTypedList SessionList(pLogonSessionList + ListEntrySize * i, "nt!_LIST_ENTRY", "Flink");

        for (SessionList.StartHead();
            SessionList.HasNode();
            SessionList.Next())
        {
            Flink = SessionList.GetNodeOffset();

            if (find(Nodes.rbegin(), Nodes.rend(), Flink) != Nodes.rend()) {

                break;
            }

            Nodes.push_back(Flink);

            g_Ext->Dml("Flink2 = %I64X\n", Flink);

            if (g_Ext->m_Data->ReadVirtual(Flink, Buffer, Helper->tailleStruct, NULL) != S_OK) break;

            // g_Ext->Dml("Flink + Helper->offsetToLuid = [0x%I64X] = ", Flink + Helper->offsetToLuid);
            if (ReadPointersVirtual(1, Flink + Helper->offsetToLuid, (PULONG64)&SessionData.LogonId) != S_OK) goto CleanUp;
            //g_Ext->Dml("0x%I64X \n", LogonIdAddr);

            //if (g_Ext->m_Data->ReadVirtual(LogonIdAddr, &SessionData.LogonId, sizeof(SessionData.LogonId), NULL) != S_OK) break;

            // g_Ext->Dml("Luid = 0x%08X0x%08X \n", SessionData.LogonId.HighPart, SessionData.LogonId.LowPart);

            SessionData.LogonType = *((PULONG)(Buffer + Helper->offsetToLogonType));
            SessionData.Session = *((PULONG)(Buffer + Helper->offsetToSession));
            SessionData.UserName = Flink + Helper->offsetToUsername;
            SessionData.LogonDomain = Flink + Helper->offsetToDomain;

            if (ReadPointersVirtual(1, Flink + Helper->offsetToCredentials, (PULONG64)&SessionData.pCredentials) != S_OK) goto CleanUp;
            if (ReadPointersVirtual(1, Flink + Helper->offsetToPSid, (PULONG64)&SessionData.pSid) != S_OK) goto CleanUp;
            if (ReadPointersVirtual(1, Flink + Helper->offsetToCredentialManager, (PULONG64)&SessionData.pCredentialManager) != S_OK) goto CleanUp;

            if ((SessionData.LogonType != Network) /*&& (sessionData.LogonType != UndefinedLogonType)*/)
            {
                WCHAR UserName[128];
                WCHAR LogonDomain[128];

                ExtRemoteTyped UserNameTyped("(nt!_UNICODE_STRING *)@$extin", (ULONG64)SessionData.UserName);
                ExtRemoteTypedEx::GetUnicodeString(UserNameTyped, UserName, sizeof(UserName));
                ExtRemoteTyped LogonDomainTyped("(nt!_UNICODE_STRING *)@$extin", (ULONG64)SessionData.LogonDomain);
                ExtRemoteTypedEx::GetUnicodeString(LogonDomainTyped, LogonDomain, sizeof(LogonDomain));

                // kuhl_m_sekurlsa_utils_getSid(&sessionData.pSid);
                g_Ext->Dml("\n"
                            "    Authentication Id  : 0x%08X%08X\n"
                            "    Session            : %s from %u\n"
                            "    <col fg=\"changed\">User Name</col>          : <col fg=\"emphfg\">%S</col>\n"
                            "    <col fg=\"changed\">Domain</col>             : <col fg=\"emphfg\">%S</col>\n"
                            "    SID                : <link cmd=\"!sid 0x%I64X\">0x%I64X</link>\n",
                    SessionData.LogonId.HighPart, SessionData.LogonId.LowPart,
                    KUHL_M_SEKURLSA_LOGON_TYPE[SessionData.LogonType], SessionData.Session,
                    UserName, LogonDomain, SessionData.pSid, SessionData.pSid);

                for (j = 0; j < sizeof(packages) / sizeof(KUHL_M_SEKURLSA_PACKAGE); j++)
                {
                    if (packages[j].symbolPtr || !packages[j].symbolName)
                    {
                        // g_Ext->Dml("    %s : \n", packages[j].name);
                        packages[j].callback(packages[j].symbolPtr, &SessionData);
                        // g_Ext->Dml("\n");
                    }
                }
            }
        }
    }

CleanUp:
    ProcessObject.RestoreContext();

    if (LogonSessionList) free(LogonSessionList);
    if (Buffer) free(Buffer);

    return;
}
```

`SwishDbgExt/Credentials.h`:

```h
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Credentials.h

Abstract:

    - http://msdn.microsoft.com/en-us/windows/ff553536(v=vs.71).aspx

    Thanks to Benjamin Delpy (@mimikatz) for open sourcing his project.


Environment:

    - User mode

Revision History:

    - Matthieu Suiche

    --*/

#include "SwishDbgExt.h"

#ifndef __CREDENTIALS_H__
#define __CREDENTIALS_H__

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS ((NTSTATUS)0x00000000)
#endif

#define STATUS_NOT_FOUND ((NTSTATUS)0xC0000225)
#define STATUS_UNSUCCESSFUL ((NTSTATUS)0xC0000001)

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#endif

#define RtlEqualLuid(L1, L2) (((L1)->LowPart == (L2)->LowPart) && ((L1)->HighPart == (L2)->HighPart))

#define KUHL_SEKURLSA_CREDS_DISPLAY_RAW 0x00000000
#define KUHL_SEKURLSA_CREDS_DISPLAY_LINE 0x00000001
#define KUHL_SEKURLSA_CREDS_DISPLAY_NEWLINE 0x00000002

#define KUHL_SEKURLSA_CREDS_DISPLAY_CREDENTIAL 0x08000000
#define KUHL_SEKURLSA_CREDS_DISPLAY_PRIMARY 0x01000000
#define KUHL_SEKURLSA_CREDS_DISPLAY_CREDENTIALKEY 0x02000000
#define KUHL_SEKURLSA_CREDS_DISPLAY_CREDENTIAL_MASK 0x07000000

#define KUHL_SEKURLSA_CREDS_DISPLAY_CREDMANPASS 0x00400000
#define KUHL_SEKURLSA_CREDS_DISPLAY_PINCODE 0x00800000

#define KUHL_SEKURLSA_CREDS_DISPLAY_NODECRYPT 0x10000000
#define KUHL_SEKURLSA_CREDS_DISPLAY_WPASSONLY 0x20000000
#define KUHL_SEKURLSA_CREDS_DISPLAY_DOMAIN 0x40000000
#define KUHL_SEKURLSA_CREDS_DISPLAY_SSP 0x80000000

#define LM_NTLM_HASH_LENGTH 16
#define SHA_DIGEST_LENGTH 20

typedef struct _CREDMAN_INFOS {
    ULONG structSize;
    ULONG offsetFLink;
    ULONG offsetUsername;
    ULONG offsetDomain;
    ULONG offsetCbPassword;
    ULONG offsetPassword;
} CREDMAN_INFOS, *PCREDMAN_INFOS;

template <class T>
struct LIST_ENTRY_T
{
    T Flink;
    T Blink;
};

template <class T>
struct UNICODE_STRING_T
{
    union
    {
        struct
        {
            WORD Length;
            WORD MaximumLength;
        };
        T dummy;
    };
    T Buffer;
};

template <class T>
struct ANSI_STRING_T
{
    USHORT Length;
    USHORT MaximumLength;
    T Buffer;
};

typedef struct ANSI_STRING_T<ULONG32> ANSI_STRING_X86, *PANSI_STRING_X86;
typedef struct ANSI_STRING_T<ULONG64> ANSI_STRING_X6, *PANSI_STRING_X64;

#if 0
typedef struct _MSV1_0_PRIMARY_CREDENTIAL {
    LSA_UNICODE_STRING LogonDomainName;
    LSA_UNICODE_STRING UserName;
    BYTE NtOwfPassword[LM_NTLM_HASH_LENGTH];
    BYTE LmOwfPassword[LM_NTLM_HASH_LENGTH];
    BYTE ShaOwPassword[SHA_DIGEST_LENGTH];
    BOOLEAN isNtOwfPassword;
    BOOLEAN isLmOwfPassword;
    BOOLEAN isShaOwPassword;
    /* buffer */
} MSV1_0_PRIMARY_CREDENTIAL, *PMSV1_0_PRIMARY_CREDENTIAL;
#endif

typedef struct _RPCE_COMMON_TYPE_HEADER {
    UCHAR Version;
    UCHAR Endianness;
    USHORT CommonHeaderLength;
    ULONG Filler;
} RPCE_COMMON_TYPE_HEADER, *PRPCE_COMMON_TYPE_HEADER;

typedef struct _RPCE_PRIVATE_HEADER {
    ULONG ObjectBufferLength;
    ULONG Filler;
} RPCE_PRIVATE_HEADER, *PRPCE_PRIVATE_HEADER;

typedef ULONG32 RPCEID;

typedef struct _MARSHALL_KEY {
    DWORD unkId;
    USHORT unk0;
    USHORT length;
    RPCEID ElementId;
} MARSHALL_KEY, *PMARSHALL_KEY;

typedef struct _RPCE_CREDENTIAL_KEYCREDENTIAL {
    RPCE_COMMON_TYPE_HEADER typeHeader;
    RPCE_PRIVATE_HEADER privateHeader;
    RPCEID RootElementId;
    DWORD unk0;
    DWORD unk1;
    MARSHALL_KEY key[ANYSIZE_ARRAY];
} RPCE_CREDENTIAL_KEYCREDENTIAL, *PRPCE_CREDENTIAL_KEYCREDENTIAL;

template <class T>
struct KIWI_GENERIC_PRIMARY_CREDENTIAL_T
{
    UNICODE_STRING_T<T> UserName;
    UNICODE_STRING_T<T> Domaine;
    UNICODE_STRING_T<T> Password;
};

typedef KIWI_GENERIC_PRIMARY_CREDENTIAL_T<ULONG32> KIWI_GENERIC_PRIMARY_CREDENTIAL_X86, *PKIWI_GENERIC_PRIMARY_CREDENTIAL_X86;
typedef KIWI_GENERIC_PRIMARY_CREDENTIAL_T<ULONG64> KIWI_GENERIC_PRIMARY_CREDENTIAL_X64, *PKIWI_GENERIC_PRIMARY_CREDENTIAL_X64;

typedef struct _KUHL_M_SEKURLSA_ENUM_HELPER {
    ULONG tailleStruct;
    ULONG offsetToLuid;
    ULONG offsetToLogonType;
    ULONG offsetToSession;
    ULONG offsetToUsername;
    ULONG offsetToDomain;
    ULONG offsetToCredentials;
    ULONG offsetToPSid;
    ULONG offsetToCredentialManager;
} KUHL_M_SEKURLSA_ENUM_HELPER, *PKUHL_M_SEKURLSA_ENUM_HELPER;

typedef struct _KIWI_BASIC_SECURITY_LOGON_SESSION_DATA {
    LUID LogonId;
    ULONG64 UserName;
    ULONG64 LogonDomain;
    ULONG LogonType;
    ULONG Session;
    ULONG64 pCredentials;
    ULONG64 pSid;
    ULONG64 pCredentialManager;
} KIWI_BASIC_SECURITY_LOGON_SESSION_DATA, *PKIWI_BASIC_SECURITY_LOGON_SESSION_DATA;
typedef void (CALLBACK * PKUHL_M_SEKURLSA_PACKAGE_CALLBACK) (_In_ ULONG64 pKerbGlobalLogonSessionTable,_In_ PKIWI_BASIC_SECURITY_LOGON_SESSION_DATA pData);

typedef struct _KUHL_M_SEKURLSA_PACKAGE {
    const char * name;
    const char * symbolName;
    ULONG64 symbolPtr;
    const PKUHL_M_SEKURLSA_PACKAGE_CALLBACK callback;
} KUHL_M_SEKURLSA_PACKAGE, *PKUHL_M_SEKURLSA_PACKAGE;

typedef NTSTATUS(WINAPI * PBCRYPT_OPEN_ALGORITHM_PROVIDER)  (__out BCRYPT_ALG_HANDLE  *phAlgorithm, __in LPCWSTR pszAlgId, __in_opt LPCWSTR pszImplementation, __in ULONG dwFlags);
typedef NTSTATUS(WINAPI * PBCRYPT_SET_PROPERTY) (__inout BCRYPT_HANDLE hObject, __in LPCWSTR pszProperty, __in_bcount(cbInput) PUCHAR pbInput, __in ULONG cbInput, __in ULONG dwFlags);
typedef NTSTATUS(WINAPI * PBCRYPT_GET_PROPERTY) (__in BCRYPT_HANDLE hObject, __in LPCWSTR pszProperty, __out_bcount_part_opt(cbOutput, *pcbResult) PUCHAR pbOutput, __in ULONG cbOutput, __out ULONG *pcbResult, __in ULONG dwFlags);
typedef NTSTATUS(WINAPI * PBCRYPT_GENERATE_SYMMETRIC_KEY) (__inout BCRYPT_ALG_HANDLE hAlgorithm, __out BCRYPT_KEY_HANDLE *phKey, __out_bcount_full_opt(cbKeyObject) PUCHAR pbKeyObject, __in ULONG cbKeyObject, __in_bcount(cbSecret) PUCHAR pbSecret, __in ULONG cbSecret, __in ULONG dwFlags);
typedef NTSTATUS(WINAPI * PBCRYPT_DESTROY_KEY) (__inout BCRYPT_KEY_HANDLE hKey);
typedef NTSTATUS(WINAPI * PBCRYPT_CLOSE_ALGORITHM_PROVIDER) (__inout BCRYPT_ALG_HANDLE hAlgorithm, __in ULONG dwFlags);
typedef NTSTATUS(WINAPI * PBCRYPT_ENCRYPT) (__inout BCRYPT_KEY_HANDLE hKey, __in_bcount_opt(cbInput) PUCHAR pbInput, __in ULONG cbInput, __in_opt VOID *pPaddingInfo, __inout_bcount_opt(cbIV) PUCHAR pbIV, __in ULONG cbIV, __out_bcount_part_opt(cbOutput, *pcbResult) PUCHAR pbOutput, __in ULONG cbOutput, __out ULONG *pcbResult, __in ULONG dwFlags);

typedef struct _KIWI_HARD_KEY {
    ULONG cbSecret;
    BYTE data[ANYSIZE_ARRAY]; // etc...
} KIWI_HARD_KEY, *PKIWI_HARD_KEY;

#define KULL_M_WIN_BUILD_XP 2600
#define KULL_M_WIN_BUILD_2K3 3790
#define KULL_M_WIN_BUILD_VISTA 6000
#define KULL_M_WIN_BUILD_7 7600
#define KULL_M_WIN_BUILD_8 9200
#define KULL_M_WIN_BUILD_BLUE 9600

#define KULL_M_WIN_MIN_BUILD_XP 2500
#define KULL_M_WIN_MIN_BUILD_2K3 3000
#define KULL_M_WIN_MIN_BUILD_VISTA 6000
#define KULL_M_WIN_MIN_BUILD_7 7000
#define KULL_M_WIN_MIN_BUILD_8 8000
#define KULL_M_WIN_MIN_BUILD_BLUE 9400

//
// 32bits
//
template <class T>
struct _KIWI_BCRYPT_KEY_T {
    ULONG size;
    ULONG tag; // 'MSSK'
    ULONG type;
    ULONG unk0;
    ULONG unk1;
    ULONG unk2;
    KIWI_HARD_KEY hardkey;
};

template <class T>
struct _KIWI_BCRYPT_KEY8_T {
    ULONG size;
    ULONG tag; // 'MSSK'
    ULONG type;
    ULONG unk0;
    ULONG unk1;
    ULONG unk2;
    ULONG unk3;
    T unk4; // before, align_In_x64
    KIWI_HARD_KEY hardkey;
};

template <class T>
struct _KIWI_BCRYPT_KEY81_T {
    ULONG size;
    ULONG tag; // 'MSSK'
    ULONG type;
    ULONG unk0;
    ULONG unk1;
    ULONG unk2;
    ULONG unk3;
    ULONG unk4;
    T unk5; // before, align_In_x64
    ULONG unk6;
    ULONG unk7;
    ULONG unk8;
    ULONG unk9;
    KIWI_HARD_KEY hardkey;
};

template <class T>
struct _KIWI_BCRYPT_HANDLE_KEY_T {
    ULONG size;
    ULONG tag; // 'UUUR'
    T hAlgorithm;
    T key; // PKIWI_BCRYPT_KEY
    T unk0;
};

typedef struct _BCRYPT_GEN_KEY {
    BCRYPT_ALG_HANDLE hProvider; // BCRYPT_ALG_HANDLE
    BCRYPT_KEY_HANDLE hKey; // BCRYPT_KEY_HANDLE
    PUCHAR pKey; // PUCHAR
    ULONG cbKey;
} BCRYPT_GEN_KEY, *PBCRYPT_GEN_KEY;

typedef struct _KIWI_BCRYPT_KEY_T<ULONG32> KIWI_BCRYPT_KEY_X86, *PKIWI_BCRYPT_KEY_X86;
typedef struct _KIWI_BCRYPT_KEY8_T<ULONG32> KIWI_BCRYPT_KEY8_X86, *PKIWI_BCRYPT_KEY8_X86;
typedef struct _KIWI_BCRYPT_KEY81_T<ULONG32> KIWI_BCRYPT_KEY81_X86, *PKIWI_BCRYPT_KEY81_X86;
typedef struct _KIWI_BCRYPT_HANDLE_KEY_T<ULONG32> KIWI_BCRYPT_HANDLE_KEY_X86, *PKIWI_BCRYPT_HANDLE_KEY_X86;

typedef struct _KIWI_BCRYPT_KEY_T<ULONG64> KIWI_BCRYPT_KEY_X64, *PKIWI_BCRYPT_KEY_X64;
typedef struct _KIWI_BCRYPT_KEY8_T<ULONG64> KIWI_BCRYPT_KEY8_X64, *PKIWI_BCRYPT_KEY8_X64;
typedef struct _KIWI_BCRYPT_KEY81_T<ULONG64> KIWI_BCRYPT_KEY81_X64, *PKIWI_BCRYPT_KEY81_X64;
typedef struct _KIWI_BCRYPT_HANDLE_KEY_T<ULONG64> KIWI_BCRYPT_HANDLE_KEY_X64, *PKIWI_BCRYPT_HANDLE_KEY_X64;
//
// 32-bits
//

template <class T>
struct _KIWI_MSV1_0_LIST_60_T {
    LIST_ENTRY_T<T> List;
    T unk0;
    ULONG unk1;
    T unk2;
    ULONG unk3;
    ULONG unk4;
    ULONG unk5;
    T hSemaphore6;
    T unk7;
    T hSemaphore8;
    T unk9;
    T unk10;
    ULONG unk11;
    ULONG unk12;
    T unk13;
    LUID LocallyUniqueIdentifier;
    LUID SecondaryLocallyUniqueIdentifier;
    UNICODE_STRING_T<T> UserName;
    UNICODE_STRING_T<T >Domaine;
    T unk14;
    T unk15;
    T  pSid;
    ULONG LogonType;
    ULONG Session;
    LARGE_INTEGER LogonTime; // autoalign x86
    UNICODE_STRING_T<T> LogonServer;
    T Credentials; // PKIWI_MSV1_0_CREDENTIALS_
    ULONG unk19;
    T unk20;
    T unk21;
    T unk22;
    ULONG unk23;
    T CredentialManager;
};

template <class T>
struct _KIWI_MSV1_0_LIST_61_T {
    LIST_ENTRY_T<T> List;
    T unk0;
    ULONG unk1;
    T unk2;
    ULONG unk3;
    ULONG unk4;
    ULONG unk5;
    T hSemaphore6;
    T unk7;
    T hSemaphore8;
    T unk9;
    T unk10;
    ULONG unk11;
    ULONG unk12;
    T unk13;
    LUID LocallyUniqueIdentifier;
    LUID SecondaryLocallyUniqueIdentifier;
    UNICODE_STRING_T<T> UserName;
    UNICODE_STRING_T<T> Domaine;
    T unk14;
    T unk15;
    T  pSid;
    ULONG LogonType;
    ULONG Session;
    LARGE_INTEGER LogonTime; // autoalign x86
    UNICODE_STRING_T<T> LogonServer;
    T Credentials; // PKIWI_MSV1_0_CREDENTIALS
    T unk19;
    T unk20;
    T unk21;
    ULONG unk22;
    T CredentialManager;
};

template <class T>
struct _KIWI_MSV1_0_LIST_62_T {
    LIST_ENTRY_T<T> List;
    T unk0;
    ULONG unk1;
    T unk2;
    ULONG unk3;
    ULONG unk4;
    ULONG unk5;
    T hSemaphore6;
    T unk7;
    T hSemaphore8;
    T unk9;
    T unk10;
    ULONG unk11;
    ULONG unk12;
    T unk13;
    LUID LocallyUniqueIdentifier;
    LUID SecondaryLocallyUniqueIdentifier;
    UNICODE_STRING_T<T> UserName;
    UNICODE_STRING_T<T> Domaine;
    T unk14;
    T unk15;
    UNICODE_STRING_T<T> Type;
    T  pSid;
    ULONG LogonType;
    T unk18;
    ULONG Session;
    LARGE_INTEGER LogonTime; // autoalign x86
    UNICODE_STRING_T<T> LogonServer;
    T Credentials; // PKIWI_MSV1_0_CREDENTIALS
    T unk19;
    T unk20;
    T unk21;
    ULONG unk22;
    ULONG unk23;
    ULONG unk24;
    ULONG unk25;
    ULONG unk26;
    T unk27;
    T unk28;
    T unk29;
    T CredentialManager;
};

template <class T>
struct _KIWI_MSV1_0_LIST_63_T {
    LIST_ENTRY_T<T> List;
    T unk0; // unk_2C0AC8
    ULONG unk1; // 0FFFFFFFFh
    T unk2; // 0
    ULONG unk3; // 0
    ULONG unk4; // 0
    ULONG unk5; // 0A0007D0h
    T hSemaphore6; // 0F9Ch HANDLE
    T unk7; // 0
    T hSemaphore8; // 0FB8h HANDLE
    T unk9; // 0
    T unk10; // 0
    ULONG unk11; // 0
    ULONG unk12; // 0 
    T unk13; // unk_2C0A28
    LUID LocallyUniqueIdentifier;
    LUID SecondaryLocallyUniqueIdentifier;
    BYTE waza[12]; /// to do (maybe align)
    UNICODE_STRING_T<T> UserName;
    UNICODE_STRING_T<T> Domaine;
    T unk14;
    T unk15;
    UNICODE_STRING_T<T> Type;
    T  pSid; // PSID
    ULONG LogonType;
    T unk18;
    ULONG Session;
    LARGE_INTEGER LogonTime; // autoalign x86
    UNICODE_STRING_T<T> LogonServer;
    T Credentials; // PKIWI_MSV1_0_CREDENTIALS
    T unk19;
    T unk20;
    T unk21;
    ULONG unk22;
    ULONG unk23;
    ULONG unk24;
    ULONG unk25;
    ULONG unk26;
    T unk27;
    T unk28;
    T unk29;
    T CredentialManager;
};

typedef struct _KIWI_MSV1_0_LIST_60_T<ULONG32> KIWI_MSV1_0_LIST_60_X86, *PKIWI_MSV1_0_LIST_60_X86;
typedef struct _KIWI_MSV1_0_LIST_61_T<ULONG32> KIWI_MSV1_0_LIST_61_X86, *PKIWI_MSV1_0_LIST_61_X86;
typedef struct _KIWI_MSV1_0_LIST_62_T<ULONG32> KIWI_MSV1_0_LIST_62_X86, *PKIWI_MSV1_0_LIST_62_X86;
typedef struct _KIWI_MSV1_0_LIST_63_T<ULONG32> KIWI_MSV1_0_LIST_63_X86, *PKIWI_MSV1_0_LIST_63_X86;

typedef struct _KIWI_MSV1_0_LIST_60_T<ULONG64> KIWI_MSV1_0_LIST_60_X64, *PKIWI_MSV1_0_LIST_60_X64;
typedef struct _KIWI_MSV1_0_LIST_61_T<ULONG64> KIWI_MSV1_0_LIST_61_X64, *PKIWI_MSV1_0_LIST_61_X64;
typedef struct _KIWI_MSV1_0_LIST_62_T<ULONG64> KIWI_MSV1_0_LIST_62_X64, *PKIWI_MSV1_0_LIST_62_X64;
typedef struct _KIWI_MSV1_0_LIST_63_T<ULONG64> KIWI_MSV1_0_LIST_63_X64, *PKIWI_MSV1_0_LIST_63_X64;

//
// 32-bits
//
template <class T>
struct KIWI_MSV1_0_PRIMARY_CREDENTIALS_T {
    T next;
    ANSI_STRING_T<T> Primary;
    UNICODE_STRING_T<T> Credentials;
};

template <class T>
struct KIWI_MSV1_0_CREDENTIALS_T {
    T next;
    DWORD AuthenticationPackageId;
    T PrimaryCredentials;
};

typedef struct KIWI_MSV1_0_PRIMARY_CREDENTIALS_T<ULONG32> KIWI_MSV1_0_PRIMARY_CREDENTIALS_X86, *PKIWI_MSV1_0_PRIMARY_CREDENTIALS_X86;
typedef struct KIWI_MSV1_0_PRIMARY_CREDENTIALS_T<ULONG64> KIWI_MSV1_0_PRIMARY_CREDENTIALS_X64, *PKIWI_MSV1_0_PRIMARY_CREDENTIALS_X64;

typedef struct KIWI_MSV1_0_CREDENTIALS_T<ULONG32> KIWI_MSV1_0_CREDENTIALS_X86, *PKIWI_MSV1_0_CREDENTIALS_X86;
typedef struct KIWI_MSV1_0_CREDENTIALS_T<ULONG64> KIWI_MSV1_0_CREDENTIALS_X64, *PKIWI_MSV1_0_CREDENTIALS_X64;

template <class T>
struct KIWI_TS_CREDENTIAL_T {
    BYTE unk0[64];
    LUID LocallyUniqueIdentifier;
    T unk1;
    T unk2;
    T pTsPrimary; //PKIWI_TS_PRIMARY_CREDENTIAL
};

typedef struct KIWI_TS_CREDENTIAL_T<ULONG32> KIWI_TS_CREDENTIAL_X86, *PKIWI_TS_CREDENTIAL_X86;
typedef struct KIWI_TS_CREDENTIAL_T<ULONG64> KIWI_TS_CREDENTIAL_X64, *PKIWI_TS_CREDENTIAL_X64;

template <class T>
struct KIWI_TS_PRIMARY_CREDENTIAL_T {
    T unk0; // lock ?
    KIWI_GENERIC_PRIMARY_CREDENTIAL_T<T> credentials;
};

typedef struct KIWI_TS_PRIMARY_CREDENTIAL_T<ULONG32> KIWI_TS_PRIMARY_CREDENTIAL_X86, *PKIWI_TS_PRIMARY_CREDENTIAL_X86;
typedef struct KIWI_TS_PRIMARY_CREDENTIAL_T<ULONG64> KIWI_TS_PRIMARY_CREDENTIAL_X64, *PKIWI_TS_PRIMARY_CREDENTIAL_X64;

//
// 32bits
//
template <class T>
struct KIWI_CREDMAN_LIST_ENTRY_60_T {
    ULONG cbEncPassword;
    T encPassword; // PWSTR
    ULONG unk0;
    ULONG unk1;
    T unk2;
    T unk3;
    T UserName; // PWSTR
    ULONG cbUserName;
    LIST_ENTRY_T<T> List; // struct _KIWI_CREDMAN_LIST_ENTRY_X86 *
    UNICODE_STRING_T<T> type;
    T unk5; // PVOID
    UNICODE_STRING_T<T> server1;
    T unk6;
    T unk7;
    T unk8;
    T unk9;
    T unk10;
    UNICODE_STRING_T<T> user;
    ULONG unk11;
    UNICODE_STRING_T<T> server2;
};

template <class T>
struct KIWI_CREDMAN_LIST_ENTRY_T {
    ULONG cbEncPassword;
    T encPassword; // PWSTR
    ULONG unk0;
    ULONG unk1;
    T unk2; // PVOID
    T unk3;
    T UserName; // LPWSTR
    ULONG cbUserName;
    LIST_ENTRY_T<T> List1; // _KIWI_CREDMAN_LIST_ENTRY *
    LIST_ENTRY_T<T> List2;
    UNICODE_STRING_T<T> type;
    T unk5;
    UNICODE_STRING_T<T> server1;
    T unk6;
    T unk7;
    T unk8;
    T unk9;
    T unk10;
    UNICODE_STRING_T<T> user;
    ULONG unk11;
    UNICODE_STRING_T<T> server2;
};

template <class T>
struct KIWI_CREDMAN_LIST_STARTER_T {
    ULONG unk0;
    T start; // PKIWI_CREDMAN_LIST_ENTRY
    //...
};

template <class T>
struct KIWI_CREDMAN_SET_LIST_ENTRY_T {
    LIST_ENTRY_T<T> List; // _KIWI_CREDMAN_SET_LIST_ENTRY_X86
    ULONG unk0;
    T list1; // PKIWI_CREDMAN_LIST_STARTER_X86
    T list2; // PKIWI_CREDMAN_LIST_STARTER_X86
    // ...
};

typedef struct KIWI_CREDMAN_LIST_ENTRY_60_T<ULONG32> KIWI_CREDMAN_LIST_ENTRY_60_X86, *PKIWI_CREDMAN_LIST_ENTRY_60_X86;
typedef struct KIWI_CREDMAN_LIST_ENTRY_T<ULONG32> KIWI_CREDMAN_LIST_ENTRY_X86, *PKIWI_CREDMAN_LIST_ENTRY_X86;
typedef struct KIWI_CREDMAN_LIST_STARTER_T<ULONG32> KIWI_CREDMAN_LIST_STARTER_X86, *PKIWI_CREDMAN_LIST_STARTER_X86;
typedef struct KIWI_CREDMAN_SET_LIST_ENTRY_T<ULONG32> KIWI_CREDMAN_SET_LIST_ENTRY_X86, *PKIWI_CREDMAN_SET_LIST_ENTRY_X86;

typedef struct KIWI_CREDMAN_LIST_ENTRY_60_T<ULONG64> KIWI_CREDMAN_LIST_ENTRY_60_X64, *PKIWI_CREDMAN_LIST_ENTRY_60_X64;
typedef struct KIWI_CREDMAN_LIST_ENTRY_T<ULONG64> KIWI_CREDMAN_LIST_ENTRY_X64, *PKIWI_CREDMAN_LIST_ENTRY_X64;
typedef struct KIWI_CREDMAN_LIST_STARTER_T<ULONG64> KIWI_CREDMAN_LIST_STARTER_X64, *PKIWI_CREDMAN_LIST_STARTER_X64;
typedef struct KIWI_CREDMAN_SET_LIST_ENTRY_T<ULONG64> KIWI_CREDMAN_SET_LIST_ENTRY_X64, *PKIWI_CREDMAN_SET_LIST_ENTRY_X64;

void
Mimikatz(
);
#endif
```

`SwishDbgExt/DbgHelpEx.cpp`:

```cpp
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - DbgHelpEx.cpp

Abstract:

    - http://msdn.microsoft.com/en-us/windows/ff553536(v=vs.71).aspx

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

    --*/

#include "stdafx.h"
#include "SwishDbgExt.h"

//
// PE functions
//


BOOL
MsPEImageFile::IsAddressValid(
    _In_ ULONG_PTR Address
    )
{
    ULONG_PTR ImageBase = (ULONG_PTR)m_Image.Image;

    if (Address >= ImageBase && Address < (ImageBase + m_ImageSize)) {

        return TRUE;
    }

    return FALSE;
}

VOID
MsPEImageFile::GetAddressInfo(
    _In_ ULONG64 Address,
    _Out_ PADDRESS_INFO AddressInfo
    )
{
    AddressInfo->Address = Address;
    AddressInfo->HookType = GetPointerHookType(Address);

    if (Address && m_ImageBase && m_ImageSize) {

        AddressInfo->IsTablePatched = (Address >= m_ImageBase && Address < (m_ImageBase + m_ImageSize)) ? FALSE : TRUE;
    }
}

PVOID
MsPEImageFile::RtlGetRessourceData(
    ULONG Name,
    ULONG Type
)
/*++

Routine Description:

    Description.

Arguments:

    - Name
    - Type

Return Value:

    PVOID.

--*/
{
    PIMAGE_RESOURCE_DIRECTORY ImgResDir;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ImgResDirEntry;
    PIMAGE_RESOURCE_DATA_ENTRY ImgResDataEntry;
    PVOID RessourceData = NULL;
    ExtRemoteTyped BaseImage;
    ULONG TableRva, TableSize;
    ULONG Index;

    try {

        if (m_Image.Initialized) {

            //
            // Points to Data Directory Table.
            //

            TableRva = m_Image.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;
            TableSize = m_Image.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size;

            if (TableRva && TableSize) {

                //
                // Category.Type
                //

                ImgResDir = (PIMAGE_RESOURCE_DIRECTORY)((PUCHAR)m_Image.Image + TableRva);

                if (IsAddressValid((ULONG_PTR)ImgResDir) &&
                    IsAddressValid((ULONG_PTR)(ImgResDir + 1))) {

                    ImgResDirEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(ImgResDir + 1);

                    if (IsAddressValid((ULONG_PTR)ImgResDirEntry) &&
                        IsAddressValid((ULONG_PTR)(ImgResDirEntry + 1))) {

                        if (ImgResDir->NumberOfIdEntries > 26) {

                            ImgResDir->NumberOfIdEntries = 26;
                        }

                        for (Index = 0; Index < ImgResDir->NumberOfIdEntries; Index++) {

                            if (ImgResDirEntry[Index].Name == Type) {

                                break;
                            }
                        }

                        if ((Index != ImgResDir->NumberOfIdEntries) || ImgResDirEntry[Index].DataIsDirectory) {

                            //
                            // Sub-category.Name
                            //

                            ImgResDir = (PIMAGE_RESOURCE_DIRECTORY)((PUCHAR)m_Image.Image + TableRva + ImgResDirEntry[Index].OffsetToDirectory);

                            if (IsAddressValid((ULONG_PTR)ImgResDir) &&
                                IsAddressValid((ULONG_PTR)(ImgResDir + 1))) {

                                ImgResDirEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(ImgResDir + 1);

                                if (IsAddressValid((ULONG_PTR)ImgResDirEntry) &&
                                    IsAddressValid((ULONG_PTR)(ImgResDirEntry + 1))) {

                                    if (ImgResDir->NumberOfIdEntries > 26) {

                                        ImgResDir->NumberOfIdEntries = 26;
                                    }

                                    for (Index = 0; Index < ImgResDir->NumberOfIdEntries; Index++) {

                                        if (ImgResDirEntry[Index].Name == Name) {

                                            break;
                                        }
                                    }

                                    if ((Index != ImgResDir->NumberOfIdEntries) || ImgResDirEntry[Index].DataIsDirectory) {

                                        //
                                        // Read first entry by default.
                                        //

                                        ImgResDir = (PIMAGE_RESOURCE_DIRECTORY)((PUCHAR)m_Image.Image + TableRva + ImgResDirEntry[Index].OffsetToDirectory);

                                        if (IsAddressValid((ULONG_PTR)ImgResDir) &&
                                            IsAddressValid((ULONG_PTR)(ImgResDir + 1))) {

                                            ImgResDirEntry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(ImgResDir + 1);

                                            if (IsAddressValid((ULONG_PTR)ImgResDirEntry) &&
                                                IsAddressValid((ULONG_PTR)(ImgResDirEntry + 1))) {

                                                if (!ImgResDirEntry[0].DataIsDirectory) {

                                                    ImgResDataEntry = (PIMAGE_RESOURCE_DATA_ENTRY)((PUCHAR)m_Image.Image + TableRva + ImgResDirEntry[0].OffsetToDirectory);

                                                    if (IsAddressValid((ULONG_PTR)ImgResDataEntry) &&
                                                        IsAddressValid((ULONG_PTR)(ImgResDataEntry + 1))) {

                                                        RessourceData = malloc(ImgResDataEntry->Size);

                                                        if (RessourceData) {

                                                            if (IsAddressValid((ULONG_PTR)((PUCHAR)m_Image.Image + ImgResDataEntry->OffsetToData)) &&
                                                                IsAddressValid((ULONG_PTR)((PUCHAR)m_Image.Image + ImgResDataEntry->OffsetToData + ImgResDataEntry->Size))) {

                                                                memcpy_s(RessourceData, ImgResDataEntry->Size, (PUCHAR)m_Image.Image + ImgResDataEntry->OffsetToData, ImgResDataEntry->Size);
                                                            }
                                                            else {

                                                                free(RessourceData);

                                                                RessourceData = NULL;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    catch (...) {

    }

    return RessourceData;
}

BOOLEAN
MsPEImageFile::RtlGetPdbInfo(
    VOID
    )
/*++

Routine Description:

    Description.

Arguments:

    - 

Return Value:

    BOOLEAN.

--*/
{
    PIMAGE_DEBUG_DIRECTORY DbgDir;
    PCV_INFO_PDB70 PdbInfo;
    ULONG_PTR ImageBase;
    ULONG TableRva, TableSize;

    try {

        if (m_Image.Initialized) {

            TableRva = m_Image.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
            TableSize = m_Image.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size;

            if (TableRva && TableSize) {

                ImageBase = (ULONG_PTR)m_Image.Image;

                DbgDir = (PIMAGE_DEBUG_DIRECTORY)(ImageBase + TableRva);

                if (IsAddressValid((ULONG_PTR)DbgDir) &&
                    IsAddressValid((ULONG_PTR)(DbgDir + 1))) {

                    if (IsAddressValid(ImageBase + DbgDir->AddressOfRawData) &&
                        IsAddressValid(ImageBase + DbgDir->AddressOfRawData + DbgDir->SizeOfData)) {

                        PdbInfo = (PCV_INFO_PDB70)(ImageBase + DbgDir->AddressOfRawData);

                        if (PdbInfo->Signature == CV_SIGNATURE_RSDS) {

                            m_PdbInfo.Guid = PdbInfo->Guid;
                            m_PdbInfo.Age = PdbInfo->Age;

                            StringCchCopyA(m_PdbInfo.PdbName, _countof(m_PdbInfo.PdbName), PdbInfo->PdbFileName);

                            return TRUE;
                        }
                    }
                }
            }
        }
    }
    catch (...) {

    }

    return FALSE;
}

BOOLEAN
MsPEImageFile::RtlGetImports(
    vector<MsDllObject> &DllList
    )
/*++

Routine Description:

    Description.

Arguments:

    -

Return Value:

    BOOLEAN.

--*/
{
    PIMAGE_IMPORT_DESCRIPTOR ImageImportDescriptor;
    WCHAR DllName[MAX_PATH];
    ULONG_PTR ImageBase;
    ULONG64 Address;
    ULONG ImportDescriptorIndex = 0;
    BOOL Is64BitTarget;
    BOOL Is32BitImage;

    ASSERTDBG(m_Image.Initialized);

    Is64BitTarget = (g_Ext->m_Control->IsPointer64Bit() == S_OK) ? TRUE : FALSE;
    Is32BitImage = m_Image.NtHeader32 ? TRUE : FALSE;

    if (m_Image.Initialized) {

        ImageBase = (ULONG_PTR)m_Image.Image;

        if (m_Image.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress && m_Image.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size) {

            ImageImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(ImageBase + m_Image.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

            if (IsAddressValid((ULONG_PTR)ImageImportDescriptor)) {

                try {

                    while(ImageImportDescriptor->OriginalFirstThunk ||
                          ImageImportDescriptor->TimeDateStamp ||
                          ImageImportDescriptor->ForwarderChain ||
                          ImageImportDescriptor->Name ||
                          ImageImportDescriptor->FirstThunk) {

                        IMPORT_DESCRIPTOR ImportDescriptor;
                        IMPORT_INFO ImportInfo = {0};
                        ULONG_PTR DllNameAddress;
                        ULONG64 DllImageBase = 0;
                        ULONG64 DllImageEnd = 0;

                        if (!IsAddressValid(ImageBase + ImageImportDescriptor->Name) ||
                            !IsAddressValid(ImageBase + ImageImportDescriptor->FirstThunk) ||
                            !IsAddressValid(ImageBase + ImageImportDescriptor->OriginalFirstThunk)) {

                            break;
                        }

                        DllNameAddress = ImageBase + ImageImportDescriptor->Name;

                        StringCchPrintfW(DllName, _countof(DllName), L"%S", (PSTR)DllNameAddress);

                        if (wcslen(DllName)) {

                            for (size_t i = 0; i < DllList.size(); i++) {

                                MsDllObject DllObject = DllList[i];

                                if (Is64BitTarget && Is32BitImage && !DllObject.mm_CcDllObject.IsWow64) {

                                    continue;
                                }

                                if (0 == _wcsicmp(DllName, DllObject.mm_CcDllObject.DllName)) {

                                    DllImageBase = DllObject.m_ImageBase;
                                    DllImageEnd = DllObject.m_ImageBase + DllObject.m_ImageSize;

                                    break;
                                }
                            }

                            StringCchCopy(ImportDescriptor.DllName, _countof(ImportDescriptor.DllName), (PSTR)DllNameAddress);
                        }
                        else {

                            StringCchPrintf(ImportDescriptor.DllName, _countof(ImportDescriptor.DllName), "%d", ImportDescriptorIndex);
                        }

                        if (ImageImportDescriptor->FirstThunk && ImageImportDescriptor->OriginalFirstThunk) {

                            ULONG_PTR ImportAddressTable = (ULONG_PTR)(ImageBase + ImageImportDescriptor->FirstThunk);
                            ULONG_PTR ImportNameTable = (ULONG_PTR)(ImageBase + ImageImportDescriptor->OriginalFirstThunk);

                            if (Is32BitImage) {

                                PULONG ImportAddressTable32 = (PULONG)ImportAddressTable;
                                PIMAGE_THUNK_DATA32 ImageThunkData32 = (PIMAGE_THUNK_DATA32)ImportNameTable;

                                while (*ImportAddressTable32) {

                                    Address = *ImportAddressTable32;

                                    if (!Is64BitTarget) {

                                        Address = DEBUG_EXTEND64(Address);
                                    }

                                    ImportInfo.AddressInfo.Address = Address;
                                    ImportInfo.AddressInfo.HookType = GetPointerHookType(Address);

                                    if (Address && DllImageBase && DllImageEnd) {

                                        ImportInfo.AddressInfo.IsTablePatched = (Address >= DllImageBase && Address < DllImageEnd) ? FALSE : TRUE;
                                    }

                                    if (g_Ext->m_Symbols->GetNameByOffset(Address, ImportInfo.Name, _countof(ImportInfo.Name), NULL, NULL) != S_OK) {

                                        if (ImageThunkData32->u1.Ordinal & IMAGE_ORDINAL_FLAG32) {

                                            StringCchPrintf(ImportInfo.Name, _countof(ImportInfo.Name), "Ordinal %04X", (WORD)ImageThunkData32->u1.Ordinal);
                                        }
                                        else {

                                            PIMAGE_IMPORT_BY_NAME ImageImportByName = (PIMAGE_IMPORT_BY_NAME)(ImageBase + ImageThunkData32->u1.AddressOfData);

                                            if (IsAddressValid((ULONG_PTR)ImageImportByName)) {

                                                StringCchCopy(ImportInfo.Name, _countof(ImportInfo.Name), ImageImportByName->Name);
                                            }
                                        }
                                    }

                                    if (ImportInfo.AddressInfo.IsTablePatched || ImportInfo.AddressInfo.HookType) {

                                        m_NumberOfHookedAPIs++;
                                    }

                                    ImportDescriptor.m_Imports.push_back(ImportInfo);

                                    m_NumberOfImportedFunctions++;

                                    ImportAddressTable32++;
                                    ImageThunkData32++;
                                }
                            }
                            else {

                                PULONG64 ImportAddressTable64 = (PULONG64)ImportAddressTable;
                                PIMAGE_THUNK_DATA64 ImageThunkData64 = (PIMAGE_THUNK_DATA64)ImportNameTable;

                                while (*ImportAddressTable64) {

                                    Address = *ImportAddressTable64;

                                    ImportInfo.AddressInfo.Address = Address;
                                    ImportInfo.AddressInfo.HookType = GetPointerHookType(Address);

                                    if (Address && DllImageBase && DllImageEnd) {

                                        ImportInfo.AddressInfo.IsTablePatched = (Address >= DllImageBase && Address < DllImageEnd) ? FALSE : TRUE;
                                    }

                                    if (g_Ext->m_Symbols->GetNameByOffset(Address, ImportInfo.Name, _countof(ImportInfo.Name), NULL, NULL) != S_OK) {

                                        if (ImageThunkData64->u1.Ordinal & IMAGE_ORDINAL_FLAG64) {

                                            StringCchPrintf(ImportInfo.Name, _countof(ImportInfo.Name), "Ordinal %04X", (WORD)ImageThunkData64->u1.Ordinal);
                                        }
                                        else {

                                            PIMAGE_IMPORT_BY_NAME ImageImportByName = (PIMAGE_IMPORT_BY_NAME)(ImageBase + ImageThunkData64->u1.AddressOfData);

                                            if (IsAddressValid((ULONG_PTR)ImageImportByName)) {

                                                StringCchCopy(ImportInfo.Name, _countof(ImportInfo.Name), ImageImportByName->Name);
                                            }
                                        }
                                    }

                                    if (ImportInfo.AddressInfo.IsTablePatched || ImportInfo.AddressInfo.HookType) {

                                        m_NumberOfHookedAPIs++;
                                    }

                                    ImportDescriptor.m_Imports.push_back(ImportInfo);

                                    m_NumberOfImportedFunctions++;

                                    ImportAddressTable64++;
                                    ImageThunkData64++;
                                }
                            }
                        }

                        m_ImportDescriptors.push_back(ImportDescriptor);

                        ImageImportDescriptor++;
                        ImportDescriptorIndex++;
                    }

                    return TRUE;
                }
                catch (...) {

                }
            }
        }
    }

    return FALSE;
}

BOOLEAN
MsPEImageFile::RtlGetExports(
    VOID
    )
/*++

Routine Description:

    Description.

Arguments:

    -

Return Value:

    BOOLEAN.

--*/
{
    PIMAGE_EXPORT_DIRECTORY ExportDir;
    ULONG_PTR ImageBase;
    PULONG AddressOfNames;
    PULONG AddressOfFunctions;
    PUSHORT AddressOfNameOrdinals;
    ULONG TableRva, TableSize;
    ULONG NumberOfHookedAPIs = 0;
    ULONG i;

    try {

        if (m_Image.Initialized) {

            TableRva = m_Image.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
            TableSize = m_Image.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

            if (TableRva && TableSize) {

                ImageBase = (ULONG_PTR)m_Image.Image;

                if (IsAddressValid(ImageBase + TableRva) &&
                    IsAddressValid(ImageBase + TableRva + TableSize)) {

                    ExportDir = (PIMAGE_EXPORT_DIRECTORY)(ImageBase + TableRva);

                    if ((ExportDir->AddressOfNames >= TableRva && ExportDir->AddressOfNames < (TableRva + TableSize)) &&
                        (ExportDir->AddressOfNameOrdinals >= TableRva && ExportDir->AddressOfNameOrdinals < (TableRva + TableSize)) &&
                        (ExportDir->AddressOfFunctions >= TableRva && ExportDir->AddressOfFunctions < (TableRva + TableSize))) {

                        AddressOfNames = (PULONG)(ImageBase + ExportDir->AddressOfNames);
                        AddressOfFunctions = (PULONG)(ImageBase + ExportDir->AddressOfFunctions);
                        AddressOfNameOrdinals = (PUSHORT)(ImageBase + ExportDir->AddressOfNameOrdinals);

#if VERBOSE_MODE
                        g_Ext->Dml("(%s) ExportDir->NumberOfName: %d, ExportDir->NumberOfFunctions: %d\n",
                                   m_PdbInfo.PdbName,
                                   ExportDir->NumberOfNames,
                                   ExportDir->NumberOfFunctions);
#endif

                        if (IsAddressValid((ULONG_PTR)AddressOfNames) &&
                            IsAddressValid((ULONG_PTR)AddressOfNames + ExportDir->NumberOfNames * sizeof(DWORD)) &&
                            IsAddressValid((ULONG_PTR)AddressOfFunctions) &&
                            IsAddressValid((ULONG_PTR)AddressOfFunctions + ExportDir->NumberOfFunctions * sizeof(DWORD)) &&
                            IsAddressValid((ULONG_PTR)AddressOfNameOrdinals) &&
                            IsAddressValid((ULONG_PTR)AddressOfNameOrdinals + ExportDir->NumberOfNames * sizeof(DWORD))) {

                            m_NumberOfExportedFunctions = ExportDir->NumberOfNames;

                            for (i = 0; i < ExportDir->NumberOfNames; i++) {

                                if (AddressOfNameOrdinals[i] >= ExportDir->NumberOfNames) {

                                    continue;
                                }

                                if (IsAddressValid((ULONG_PTR)(AddressOfFunctions + AddressOfNameOrdinals[i])) &&
                                    IsAddressValid((ULONG_PTR)(AddressOfFunctions + AddressOfNameOrdinals[i] + sizeof(ULONG)))) {

                                    EXPORT_INFO ExportInfo = {0};

                                    ExportInfo.Index = i;
                                    ExportInfo.Ordinal = AddressOfNameOrdinals[i];

                                    GetAddressInfo(m_ImageBase + AddressOfFunctions[AddressOfNameOrdinals[i]], &ExportInfo.AddressInfo);

                                    if (ExportInfo.AddressInfo.IsTablePatched || ExportInfo.AddressInfo.HookType) {

                                        NumberOfHookedAPIs++;
                                    }

                                    if (IsAddressValid(ImageBase + AddressOfNames[i])) {

                                        try {

                                            StringCchCopyA(ExportInfo.Name, _countof(ExportInfo.Name), (PCSTR)(ImageBase + AddressOfNames[i]));
                                        }
                                        catch (...) {

                                        }
                                    }

                                    m_Exports.push_back(ExportInfo);
                                }
                            }

                            m_NumberOfHookedAPIs = NumberOfHookedAPIs;

                            return TRUE;
                        }
                    }
                }
            }
        }
    }
    catch (...) {

    }

    return FALSE;
}

BOOLEAN
MsPEImageFile::RtlGetFileVersion(
    VOID
    )
/*++

Routine Description:

    Description.

Arguments:

    - 

Return Value:

    BOOLEAN.

--*/
{
    PVOID RessourceData = NULL;
    PVOID Description;
    PLANGANDCODEPAGE Translation;
    WCHAR MagicLine[MAX_PATH];
    UINT TranslateSize;
    UINT DescriptionSize;
    BOOL Result = TRUE;

    try {

        RessourceData = RtlGetRessourceData(VS_VERSION_INFO, (ULONG)((ULONG_PTR)RT_VERSION));

        if (RessourceData == NULL) goto CleanUp;

        //
        // Read the list of languages and code pages.
        //

        Result = VerQueryValueW(RessourceData,
                                L"\\VarFileInfo\\Translation",
                                (LPVOID*)&Translation,
                                &TranslateSize);

        if (!Result || Translation == NULL) goto CleanUp;

        //
        // Product Version
        //

        swprintf_s(MagicLine,
                   _countof(MagicLine),
                   L"\\StringFileInfo\\%04x%04x\\ProductVersion",
                   Translation->wLanguage,
                   Translation->wCodePage);

        VerQueryValueW(RessourceData, MagicLine, &Description, &DescriptionSize);

        if (DescriptionSize) {

            swprintf_s(m_FileVersion.ProductVersion, _countof(m_FileVersion.ProductVersion), L"%s", (PWSTR)Description);
        }

        //
        // File Version
        //

        swprintf_s(MagicLine,
                   _countof(MagicLine),
                   L"\\StringFileInfo\\%04x%04x\\FileVersion",
                   Translation->wLanguage,
                   Translation->wCodePage);

        VerQueryValueW(RessourceData, MagicLine, &Description, &DescriptionSize);

        if (DescriptionSize) {

            swprintf_s(m_FileVersion.FileVersion, _countof(m_FileVersion.FileVersion), L"%s", (PWSTR)Description);
        }

        //
        // Company Name
        //

        swprintf_s(MagicLine,
                   _countof(MagicLine),
                   L"\\StringFileInfo\\%04x%04x\\CompanyName",
                   Translation->wLanguage,
                   Translation->wCodePage);

        VerQueryValueW(RessourceData, MagicLine, &Description, &DescriptionSize);

        if (DescriptionSize) {

            swprintf_s(m_FileVersion.CompanyName, _countof(m_FileVersion.CompanyName), L"%s", (PWSTR)Description);
        }

        //
        // File Description
        //

        swprintf_s(MagicLine,
                   _countof(MagicLine),
                   L"\\StringFileInfo\\%04x%04x\\FileDescription",
                   Translation->wLanguage,
                   Translation->wCodePage);

        VerQueryValueW(RessourceData, MagicLine, &Description, &DescriptionSize);

        if (DescriptionSize) {

            swprintf_s(m_FileVersion.FileDescription, _countof(m_FileVersion.FileDescription), L"%s", (PWSTR)Description);
        }

    #if VERBOSE_MODE
        // g_Ext->Dml("FileDesc: %S\n", ProcessObject.m_CcProcessObject.FileDescription);
    #endif

        Result = TRUE;
    }
    catch (...) {

    }

CleanUp:

    if (RessourceData) free(RessourceData);

    return (BOOLEAN)Result;
}

BOOLEAN
MsPEImageFile::RtlGetSections(
    VOID
    )
/*++

Routine Description:

    Description.

Arguments:

    - 

Return Value:

    BOOLEAN.

--*/
{
    ULONG_PTR ImageBase;
    ULONG_PTR Address;
    ULONG Index;

    for (Index = 0; Index < m_Image.NumberOfSections; Index++) {

        CACHED_SECTION_INFO SectionInfo = {0};
        MD5_CONTEXT Md5Context = {0};

        try {

            memcpy_s(SectionInfo.Name, sizeof(SectionInfo.Name), m_Image.Sections[Index].Name, sizeof(m_Image.Sections[Index].Name));

            SectionInfo.VaBase = m_Image.Sections[Index].VirtualAddress;
            SectionInfo.VaSize = m_Image.Sections[Index].Misc.VirtualSize;
            SectionInfo.RawSize = m_Image.Sections[Index].SizeOfRawData;
            SectionInfo.Characteristics = m_Image.Sections[Index].Characteristics;

            if (m_Image.Sections[Index].Characteristics & IMAGE_SCN_MEM_EXECUTE) {

                SectionInfo.IsExecutable = TRUE;
            }

            if (g_Verbose) g_Ext->Dml("[%d][%s] Base = 0x%I64X Size = 0x%x RawSize = 0x%x\n", Index, SectionInfo.Name, SectionInfo.VaBase, SectionInfo.VaSize, SectionInfo.RawSize);

            ImageBase = (ULONG_PTR)m_Image.Image;

            Address = ImageBase + SectionInfo.VaBase;

            if (IsAddressValid(Address)) {

                Address = ImageBase + SectionInfo.VaBase + SectionInfo.VaSize;

                if (IsAddressValid(Address)) {

                    MD5Init(&Md5Context);
                    MD5Update(&Md5Context, (PUCHAR)(ImageBase + SectionInfo.VaBase), SectionInfo.VaSize);
                    MD5Final(&Md5Context);

                    memcpy_s(SectionInfo.VaMd5Hash, sizeof(SectionInfo.VaMd5Hash), Md5Context.Digest, sizeof(Md5Context.Digest));

#if VERBOSE_MODE
                    g_Ext->Dml("Md5: ");
                    for (UINT i = 0; i < 16; i++) g_Ext->Dml("%02x", Md5Context.Digest[i]);
                    g_Ext->Dml("\n");
#endif
                }

                Address = ImageBase + SectionInfo.VaBase + SectionInfo.RawSize;

                if (IsAddressValid(Address)) {

                    MD5Init(&Md5Context);
                    MD5Update(&Md5Context, (PUCHAR)(ImageBase + SectionInfo.VaBase), SectionInfo.RawSize);
                    MD5Final(&Md5Context);

                    memcpy_s(SectionInfo.RawMd5Hash, sizeof(SectionInfo.RawMd5Hash), Md5Context.Digest, sizeof(Md5Context.Digest));

#if VERBOSE_MODE
                    g_Ext->Dml("Md5: ");
                    for (UINT i = 0; i < 16; i++) g_Ext->Dml("%02x", Md5Context.Digest[i]);
                    g_Ext->Dml("\n");
#endif
                }
            }

            // VirusTotal::GetReport(Md5Context.Digest);

            m_CcSections.push_back(SectionInfo);
        }
        catch (...) {

        }
    }

    return TRUE;
}

BOOLEAN
MsPEImageFile::InitImage(
    VOID
    )
/*++

Routine Description:

    Description.

Arguments:

    - 

Return Value:

    BOOLEAN.

--*/
{
    PIMAGE_DOS_HEADER Header = NULL;
    PVOID Image = NULL;
    ULONG BytesRead = 0;
    ULONG64 BaseImageAddress = m_ImageBase;
    PIMAGE_NT_HEADERS32 NtHeader32 = NULL;
    PIMAGE_NT_HEADERS64 NtHeader64 = NULL;
    ExtRemoteTyped BaseImage;
    BOOLEAN Result = FALSE;
    HRESULT Status;

    try {

        if (m_Image.Initialized)
        {
            // g_Ext->Dml("b_Initialized already set to TRUE\n");
            Result = TRUE;
            goto CleanUp;
        }

        BaseImage = ExtRemoteTyped("(nt!_IMAGE_DOS_HEADER *)@$extin", BaseImageAddress);

        if (BaseImage.Field("e_magic").GetUshort() != IMAGE_DOS_SIGNATURE) {

            goto CleanUp;
        }

        if (!m_ImageSize)
        {
            Header = (PIMAGE_DOS_HEADER)malloc(PAGE_SIZE);
            if (Header == NULL) goto CleanUp;
            RtlZeroMemory(Header, PAGE_SIZE);

            if (g_Ext->m_Data->ReadVirtual(BaseImageAddress, Header, PAGE_SIZE, &BytesRead) != S_OK)
            {
#if VERBOSE_MODE
            g_Ext->Dml("Error: Can't read 0x%I64x bytes at %I64x.\n", PAGE_SIZE, BaseImageAddress);
#endif
                goto CleanUp;
            }

            NtHeader32 = (PIMAGE_NT_HEADERS32)((PUCHAR)Header + BaseImage.Field("e_lfanew").GetUlong());

            if (NtHeader32->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
            {
                m_ImageSize = NtHeader32->OptionalHeader.SizeOfImage;
            }
            else if (NtHeader32->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
            {
                NtHeader64 = (PIMAGE_NT_HEADERS64)NtHeader32;
                NtHeader32 = NULL;
                m_ImageSize = NtHeader64->OptionalHeader.SizeOfImage;
            }
            else
            {
#if VERBOSE_MODE
            g_Ext->Dml("Error: Invalid signature.\n");
#endif
                goto CleanUp;
            }
        }

        Image = malloc(m_ImageSize);
        if (Image == NULL) goto CleanUp;
        RtlZeroMemory(Image, (ULONG)m_ImageSize);

        Status = ExtRemoteTypedEx::ReadImageMemory(BaseImageAddress, Image, (ULONG)m_ImageSize, &BytesRead);

        if (Status == E_ACCESSDENIED) {

            m_IsPagedOut = TRUE;
        }
        else if (Status != S_OK)
        {
#if VERBOSE_MODE
        g_Ext->Dml("Error: Can't read 0x%I64x bytes at %I64x.\n", m_ImageSize, BaseImageAddress);
#endif
            goto CleanUp;
        }

        m_Image.Image = (PIMAGE_DOS_HEADER)Image;
        REF_POINTER(m_Image.Image);

        m_Image.NtHeader32 = (PIMAGE_NT_HEADERS32)((PUCHAR)Image + m_Image.Image->e_lfanew);
        NtHeader32 = m_Image.NtHeader32;

        if (NtHeader32->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
        {
            m_Image.NtHeader32 = NULL;
            m_Image.NtHeader64 = (PIMAGE_NT_HEADERS64)((PUCHAR)Image + m_Image.Image->e_lfanew);
            m_Image.DataDirectory = (PIMAGE_DATA_DIRECTORY)m_Image.NtHeader64->OptionalHeader.DataDirectory;
            m_Image.Sections = (PIMAGE_SECTION_HEADER)(m_Image.NtHeader64 + 1);

            m_Image.NumberOfSections = m_Image.NtHeader64->FileHeader.NumberOfSections;
        }
        else if (NtHeader32->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
        {
            m_Image.NtHeader64 = NULL;
            m_Image.DataDirectory = (PIMAGE_DATA_DIRECTORY)m_Image.NtHeader32->OptionalHeader.DataDirectory;
            m_Image.Sections = (PIMAGE_SECTION_HEADER)(m_Image.NtHeader32 + 1);
            m_Image.NumberOfSections = m_Image.NtHeader32->FileHeader.NumberOfSections;
        }
        else
        {
            goto CleanUp;
        }

	    m_IsSigned = ((PIMAGE_DATA_DIRECTORY)m_Image.DataDirectory)[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress ? TRUE : FALSE;

#if VERBOSE_MODE
    g_Ext->Dml("m_Image = %p\n"
        "m_NtHeader32 = %p\n"
        "m_DataDirectory = %p\n"
        "m_Sections = %p\n", m_Image.Image, m_Image.NtHeader32, m_Image.DataDirectory, m_Image.Sections);

    g_Ext->Dml("m_NumberOfSections = %x\n", m_Image.NumberOfSections);
#endif

        Result = TRUE;
    }
    catch (...) {

    }

CleanUp:
    if (Header) free(Header);

    m_Image.Initialized = Result;

    return Result;
}

BOOLEAN
MsPEImageFile::GetInfoFull(
    VOID
    )
/*++

Routine Description:

    Description.

Arguments:

    - 

Return Value:

    BOOLEAN.

--*/
{
    BOOLEAN Result = FALSE;

    Result = InitImage();
    if (Result == FALSE) goto CleanUp;

    RtlGetFileVersion();
    // if (Result == FALSE) goto CleanUp;

    RtlGetPdbInfo();

    RtlGetSections();
    //if (Result == FALSE) goto CleanUp;

    //
    // Dlls
    //
    // ExtNtOsInformation::GetUserLoadedModuleListHead(_In_ bool NativeOnly)
    // ExtNtOsInformation::GetUserLoadedModuleList(_In_ bool NativeOnly)

    Result = TRUE;

CleanUp:
    return Result;
}

```

`SwishDbgExt/DbgHelpEx.h`:

```h
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - DbgHelpEx.h

Abstract:

    - http://msdn.microsoft.com/en-us/windows/ff553536(v=vs.71).aspx


Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#include "SwishDbgExt.h"

#ifndef __DBGHELPEX_H__
#define __DBGHELPEX_H__

#define CV_SIGNATURE_RSDS 'SDSR'

typedef struct _CV_INFO_PDB70
{
    DWORD Signature;
    GUID Guid; // unique identifier 
    DWORD Age; // an always-incrementing value 
    CHAR PdbFileName[1]; // zero terminated string with the name of the PDB file 
} CV_INFO_PDB70, *PCV_INFO_PDB70;

class MsDllObject;

class MsPEImageFile {
public:
    typedef enum _IMAGE_TYPE {
        ImageInvalidType = 0,
        ImageProcessType = 1,
        ImageDllType = 2,
        ImageModuleType = 3
    } IMAGE_TYPE, *PIMAGE_TYPE;

    typedef struct _IMAGE_DATA {
        PIMAGE_DOS_HEADER Image;
        PIMAGE_NT_HEADERS32 NtHeader32;
        PIMAGE_NT_HEADERS64 NtHeader64;
        PIMAGE_DATA_DIRECTORY DataDirectory;
        PIMAGE_SECTION_HEADER Sections;

        ULONG NumberOfSections;

        BOOLEAN Initialized;
    } IMAGE_DATA, *PIMAGE_DATA;

    typedef struct _CACHED_SECTION_INFO {
        ULONG Index;

        CHAR Name[9];

        ULONG VaBase;
        ULONG VaSize;
        CHAR VaMd5Hash[16];

        ULONG RawBase;
        ULONG RawSize;
        CHAR RawMd5Hash[16];

        BOOLEAN IsExecutable;
        ULONG32 Characteristics;
    } CACHED_SECTION_INFO, *PCACHED_SECTION_INFO;

    typedef struct _PDB_INFO {
        GUID Guid;
        ULONG Age;
        CHAR PdbName[MAX_PATH];
    } PDB_INFO, *PPDB_INFO;

    typedef struct _LANGANDCODEPAGE {
        WORD wLanguage;
        WORD wCodePage;
    } LANGANDCODEPAGE, *PLANGANDCODEPAGE;

    typedef struct _FILE_VERSION {
        WCHAR ProductVersion[256];
        WCHAR FileVersion[256];
        WCHAR CompanyName[256];
        WCHAR FileDescription[256];
    } FILE_VERSION, *PFILE_VERSION;

    typedef struct _ADDRESS_INFO {
        ULONG64 Address;
        HOOK_TYPE HookType;
        BOOL IsTablePatched;
    } ADDRESS_INFO, *PADDRESS_INFO;

    typedef struct _IMPORT_INFO {
        ADDRESS_INFO AddressInfo;
        CHAR Name[MAX_PATH];
    } IMPORT_INFO, *PIMPORT_INFO;

    typedef struct _IMPORT_DESCRIPTOR {
        vector<IMPORT_INFO> m_Imports;
        CHAR DllName[MAX_PATH];
    } IMPORT_DESCRIPTOR, *PIMPORT_DESCRIPTOR;

    typedef struct _EXPORT_INFO {
        ADDRESS_INFO AddressInfo;
        ULONG Index;
        ULONG Ordinal;
        CHAR Name[128];
    } EXPORT_INFO, *PEXPORT_INFO;

    ULONG64 m_ImageBase;
    ULONG m_ImageSize;

    BOOL m_IsPagedOut;
    BOOL m_IsSigned;

    vector<CACHED_SECTION_INFO> m_CcSections;
    FILE_VERSION m_FileVersion;
    IMAGE_DATA m_Image;
    PDB_INFO m_PdbInfo;

    ULONG64 m_ObjectPtr;
    ULONG m_NumberOfHookedAPIs;

    //
    // Imports
    //

    vector<IMPORT_DESCRIPTOR> m_ImportDescriptors;
    ULONG m_NumberOfImportedFunctions;

    //
    // Exports
    //

    vector<EXPORT_INFO> m_Exports;
    ULONG m_NumberOfExportedFunctions;

    VOID GetAddressInfo(
        _In_ ULONG64 Address,
        _Inout_ PADDRESS_INFO AddressInfo
        );

    PVOID
    RtlGetRessourceData(
       _In_ ULONG Name,
       _In_ ULONG Type
    );

    BOOLEAN
    RtlGetImports(
        vector<MsDllObject> &DllList
    );

    BOOLEAN
    RtlGetExports(
        VOID
        );

    BOOLEAN
    InitImage(
        VOID
        );

    BOOLEAN
    RtlGetSections(
        VOID
        );

    BOOLEAN
    RtlGetFileVersion(
        VOID
        );

    BOOLEAN
    RtlGetPdbInfo(
        VOID
        );

    BOOLEAN
    GetInfoFull(
        VOID
        );

    BOOL
    IsAddressValid(
        _In_ ULONG_PTR Address
        );

    void Free(void);

protected:
    void Clear(void)
    {
        Free();

        m_Image.Initialized = FALSE;
        m_ImageSize = 0;
        m_ImageBase = 0ULL;
    }
};

#endif
```

`SwishDbgExt/Drivers.cpp`:

```cpp
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Ob.cpp

Abstract:

    - http://msdn.microsoft.com/en-us/windows/ff553536(v=vs.71).aspx

Environment:

    - User mode

Revision History:

    - Matthieu Suiche
--*/

#include "stdafx.h"
#include "SwishDbgExt.h"

VOID
MsDriverObject::Set(
)
/*++

Routine Description:

    Description.

Arguments:

    - 

Return Value:

    None.

--*/
{
    ULONG64 MajorFunction[_countof(mm_DriverInfo.MajorFunction)];

    try {

        m_ObjectPtr = m_TypedObject.GetPtr();

        mm_DriverInfo.DeviceObject = m_TypedObject.Field("DeviceObject").GetPtr();
        mm_DriverInfo.DriverStart = m_TypedObject.Field("DriverStart").GetPtr();
        mm_DriverInfo.DriverSize = m_TypedObject.Field("DriverSize").GetUlong();
        mm_DriverInfo.DriverSection = m_TypedObject.Field("DriverSection").GetPtr();
        mm_DriverInfo.DriverExtension = m_TypedObject.Field("DriverExtension").GetPtr();
        mm_DriverInfo.DriverInit = m_TypedObject.Field("DriverInit").GetPtr();
        mm_DriverInfo.DriverStartIo = m_TypedObject.Field("DriverStartIo").GetPtr();
        mm_DriverInfo.DriverUnload = m_TypedObject.Field("DriverUnload").GetPtr();

        ExtRemoteTypedEx::GetUnicodeString(m_TypedObject.Field("DriverName"), (PWSTR)&mm_DriverInfo.DriverName, sizeof(mm_DriverInfo.DriverName));

        if (mm_DriverInfo.DriverSection) {

            ExtRemoteTyped LdrData("(nt!_LDR_DATA_TABLE_ENTRY *)@$extin", mm_DriverInfo.DriverSection);

            ExtRemoteTypedEx::GetUnicodeString(LdrData.Field("FullDllName"), (PWSTR)&mm_DriverInfo.FullDllName, sizeof(mm_DriverInfo.FullDllName));
            ExtRemoteTypedEx::GetUnicodeString(LdrData.Field("BaseDllName"), (PWSTR)&mm_DriverInfo.DllName, sizeof(mm_DriverInfo.DllName));

            m_ImageBase = LdrData.Field("DllBase").GetPtr();
            m_ImageSize = LdrData.Field("SizeOfImage").GetUlong();
        }

        if (m_TypedObject.Field("FastIoDispatch").GetPtr()) {

            ExtRemoteTyped FastIoDispatch = m_TypedObject.Field("FastIoDispatch");

            GetAddressInfo(FastIoDispatch.Field("FastIoCheckIfPossible").GetPtr(), &mm_DriverInfo.FastIoDispatch.FastIoCheckIfPossible);
            GetAddressInfo(FastIoDispatch.Field("FastIoRead").GetPtr(), &mm_DriverInfo.FastIoDispatch.FastIoRead);
            GetAddressInfo(FastIoDispatch.Field("FastIoWrite").GetPtr(), &mm_DriverInfo.FastIoDispatch.FastIoWrite);
            GetAddressInfo(FastIoDispatch.Field("FastIoQueryBasicInfo").GetPtr(), &mm_DriverInfo.FastIoDispatch.FastIoQueryBasicInfo);
            GetAddressInfo(FastIoDispatch.Field("FastIoQueryStandardInfo").GetPtr(), &mm_DriverInfo.FastIoDispatch.FastIoQueryStandardInfo);
            GetAddressInfo(FastIoDispatch.Field("FastIoLock").GetPtr(), &mm_DriverInfo.FastIoDispatch.FastIoLock);
            GetAddressInfo(FastIoDispatch.Field("FastIoUnlockSingle").GetPtr(), &mm_DriverInfo.FastIoDispatch.FastIoUnlockSingle);
            GetAddressInfo(FastIoDispatch.Field("FastIoUnlockAll").GetPtr(), &mm_DriverInfo.FastIoDispatch.FastIoUnlockAll);
            GetAddressInfo(FastIoDispatch.Field("FastIoUnlockAllByKey").GetPtr(), &mm_DriverInfo.FastIoDispatch.FastIoUnlockAllByKey);
            GetAddressInfo(FastIoDispatch.Field("FastIoDeviceControl").GetPtr(), &mm_DriverInfo.FastIoDispatch.FastIoDeviceControl);
            GetAddressInfo(FastIoDispatch.Field("AcquireFileForNtCreateSection").GetPtr(), &mm_DriverInfo.FastIoDispatch.AcquireFileForNtCreateSection);
            GetAddressInfo(FastIoDispatch.Field("ReleaseFileForNtCreateSection").GetPtr(), &mm_DriverInfo.FastIoDispatch.ReleaseFileForNtCreateSection);
            GetAddressInfo(FastIoDispatch.Field("FastIoDetachDevice").GetPtr(), &mm_DriverInfo.FastIoDispatch.FastIoDetachDevice);
            GetAddressInfo(FastIoDispatch.Field("FastIoQueryNetworkOpenInfo").GetPtr(), &mm_DriverInfo.FastIoDispatch.FastIoQueryNetworkOpenInfo);
            GetAddressInfo(FastIoDispatch.Field("AcquireForModWrite").GetPtr(), &mm_DriverInfo.FastIoDispatch.AcquireForModWrite);
            GetAddressInfo(FastIoDispatch.Field("MdlRead").GetPtr(), &mm_DriverInfo.FastIoDispatch.MdlRead);
            GetAddressInfo(FastIoDispatch.Field("MdlReadComplete").GetPtr(), &mm_DriverInfo.FastIoDispatch.MdlReadComplete);
            GetAddressInfo(FastIoDispatch.Field("PrepareMdlWrite").GetPtr(), &mm_DriverInfo.FastIoDispatch.PrepareMdlWrite);
            GetAddressInfo(FastIoDispatch.Field("MdlWriteComplete").GetPtr(), &mm_DriverInfo.FastIoDispatch.MdlWriteComplete);
            GetAddressInfo(FastIoDispatch.Field("FastIoReadCompressed").GetPtr(), &mm_DriverInfo.FastIoDispatch.FastIoReadCompressed);
            GetAddressInfo(FastIoDispatch.Field("FastIoWriteCompressed").GetPtr(), &mm_DriverInfo.FastIoDispatch.FastIoWriteCompressed);
            GetAddressInfo(FastIoDispatch.Field("MdlReadCompleteCompressed").GetPtr(), &mm_DriverInfo.FastIoDispatch.MdlReadCompleteCompressed);
            GetAddressInfo(FastIoDispatch.Field("MdlWriteCompleteCompressed").GetPtr(), &mm_DriverInfo.FastIoDispatch.MdlWriteCompleteCompressed);
            GetAddressInfo(FastIoDispatch.Field("FastIoQueryOpen").GetPtr(), &mm_DriverInfo.FastIoDispatch.FastIoQueryOpen);
            GetAddressInfo(FastIoDispatch.Field("ReleaseForModWrite").GetPtr(), &mm_DriverInfo.FastIoDispatch.ReleaseForModWrite);
            GetAddressInfo(FastIoDispatch.Field("AcquireForCcFlush").GetPtr(), &mm_DriverInfo.FastIoDispatch.AcquireForCcFlush);
            GetAddressInfo(FastIoDispatch.Field("ReleaseForCcFlush").GetPtr(), &mm_DriverInfo.FastIoDispatch.ReleaseForCcFlush);
        }

        ReadPointersVirtual(_countof(MajorFunction), m_TypedObject.Field("MajorFunction").GetPointerTo().GetPtr(), MajorFunction);

        for (ULONG i = 0; i < _countof(mm_DriverInfo.MajorFunction); i++) {

            GetAddressInfo(MajorFunction[i], &mm_DriverInfo.MajorFunction[i]);
        }
    }
    catch (...) {

    }
}

MsDriverObject::~MsDriverObject(
)
/*++

Routine Description:

    Description.

Arguments:

    - 

Return Value:

    None.

--*/
{
    Clear();
    /*
    if (m_Image)
    {
    // free(m_Image);
    // m_Image = NULL;
    // http://stackoverflow.com/questions/9331561/why-does-my-classs-destructor-get-called-when-i-add-instances-to-a-vector
    // http://stackoverflow.com/questions/15277606/c-vector-of-objects-and-excessive-calls-to-destructor

    Clear();
    }
    */
}


vector<MsDriverObject>
GetDrivers(
)
/*++

Routine Description:

    Description.

Arguments:

    - 

Return Value:

    vector<MsDriverObject>.

--*/
{
    vector<HANDLE_OBJECT> DriverObjects = ObOpenObjectDirectory(ObGetDriverObject());
    vector<MsDriverObject> Drivers;
    vector<MsDllObject> DllList;
    vector<ULONG64> Nodes;
    ULONG64 Head = ExtNtOsInformation::GetKernelLoadedModuleListHead();

    if (IsValid(Head)) {

        try {

            ModuleIterator Dlls(Head);

            for (Dlls.First(); !Dlls.IsDone(); Dlls.Next()) {

                MsDllObject DllObject = Dlls.Current();

                if (find(Nodes.rbegin(), Nodes.rend(), DllObject.m_ImageBase) != Nodes.rend()) {

                    break;
                }

                Nodes.push_back(DllObject.m_ImageBase);

                DllList.push_back(DllObject);
            }
        }
        catch (...) {

        }
    }

    for each (HANDLE_OBJECT DriverObject in DriverObjects) {

        MsDriverObject Driver(DriverObject.ObjectPtr);

        Driver.GetInfoFull();
        Driver.RtlGetExports();
        Driver.RtlGetImports(DllList);

        Drivers.push_back(Driver);
    }

    DriverObjects = ObOpenObjectDirectory(ObGetFileSystemObject());

    for each (HANDLE_OBJECT DriverObject in DriverObjects) {

        if (0 == wcscmp(DriverObject.Type, L"Driver")) {

            MsDriverObject Driver(DriverObject.ObjectPtr);

            Driver.GetInfoFull();
            Driver.RtlGetExports();
            Driver.RtlGetImports(DllList);

            Drivers.push_back(Driver);
        }
    }

    return Drivers;
}

```

`SwishDbgExt/Drivers.h`:

```h
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

- Driver.h

Abstract:

- ExtRemoteData Pointer(GetExpression("'htsxxxxx!gRingBuffer"), m_PtrSize); // <<< works just fine



Environment:

- User mode

Revision History:

- Matthieu Suiche

--*/

#ifndef __DRIVERS_H__
#define __DRIVERS_H__

class MsDriverObject : public MsPEImageFile {
public:
    typedef struct _FAST_IO_DISPATCH
    {
        ADDRESS_INFO FastIoCheckIfPossible;
        ADDRESS_INFO FastIoRead;
        ADDRESS_INFO FastIoWrite;
        ADDRESS_INFO FastIoQueryBasicInfo;
        ADDRESS_INFO FastIoQueryStandardInfo;
        ADDRESS_INFO FastIoLock;
        ADDRESS_INFO FastIoUnlockSingle;
        ADDRESS_INFO FastIoUnlockAll;
        ADDRESS_INFO FastIoUnlockAllByKey;
        ADDRESS_INFO FastIoDeviceControl;
        ADDRESS_INFO AcquireFileForNtCreateSection;
        ADDRESS_INFO ReleaseFileForNtCreateSection;
        ADDRESS_INFO FastIoDetachDevice;
        ADDRESS_INFO FastIoQueryNetworkOpenInfo;
        ADDRESS_INFO AcquireForModWrite;
        ADDRESS_INFO MdlRead;
        ADDRESS_INFO MdlReadComplete;
        ADDRESS_INFO PrepareMdlWrite;
        ADDRESS_INFO MdlWriteComplete;
        ADDRESS_INFO FastIoReadCompressed;
        ADDRESS_INFO FastIoWriteCompressed;
        ADDRESS_INFO MdlReadCompleteCompressed;
        ADDRESS_INFO MdlWriteCompleteCompressed;
        ADDRESS_INFO FastIoQueryOpen;
        ADDRESS_INFO ReleaseForModWrite;
        ADDRESS_INFO AcquireForCcFlush;
        ADDRESS_INFO ReleaseForCcFlush;
    } FAST_IO_DISPATCH, *PFAST_IO_DISPATCH;

    typedef struct _DRIVER_INFO {
        IMAGE_TYPE ImageType; // Always in first position.

        ULONG64 DeviceObject;
        ULONG64 DriverStart;
        ULONG DriverSize;
        ULONG64 DriverSection;
        ULONG64 DriverExtension;

        WCHAR DriverName[MAX_PATH];

        FAST_IO_DISPATCH FastIoDispatch;
        ULONG64 DriverInit;
        ULONG64 DriverStartIo;
        ULONG64 DriverUnload;

        ADDRESS_INFO MajorFunction[28];

        ULONG64 LoadTime;
        WCHAR DllName[MAX_PATH + 1];
        WCHAR FullDllName[MAX_PATH + 1];

    } DRIVER_INFO, *PDRIVER_INFO;

    MsDriverObject()
    {
        Clear();
    }

    MsDriverObject(ULONG64 Object)
    {
        Clear();

        m_TypedObject = ExtRemoteTyped("(nt!_DRIVER_OBJECT *)@$extin", Object);
        Set();
    }

    MsDriverObject(ExtRemoteTyped Object)
    {
        Clear();
        m_TypedObject = Object;
        Set();
    }
    ~MsDriverObject();

    VOID Set();

    BOOLEAN Init(VOID);

    DRIVER_INFO mm_DriverInfo;

    ExtRemoteTyped m_TypedObject;
};

vector<MsDriverObject>
GetDrivers(
);

#endif
```

`SwishDbgExt/EngExpCppEx.h`:

```h
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - EngExtCppEx.h

Abstract:

    - http://msdn.microsoft.com/en-us/windows/ff553536(v=vs.71).aspx


Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/


typedef enum _HOOK_TYPE {
	NoHook = 0,
	JmpHook = 1,
	CallHook = 2,
	MovEaxEdxCallPtrHook = 3,
	NtSyscallHook = MovEaxEdxCallPtrHook,
	PushRetHook = 4,
	JmpDwordPtrHook = 5,
	CallDwordPtrHook = 6
} HOOK_TYPE;

BOOLEAN
IsValid(
    ULONG64 Pointer
);

PSTR
GetNameByOffset(
    _In_ ULONG64 Offset,
    _Out_writes_(Length) PSTR Buffer,
    _In_ ULONG Length
    );

HOOK_TYPE
GetPointerHookType(
    _In_ ULONG64 Pointer
    );

ULONG64
GetFastRefPointer(
ULONG64 Pointer
);

ULONG
ReadPointersVirtual(
ULONG PointerCount,
ULONG64 Pointer,
PULONG64 OutPtrTable
);

class ExtRemoteTypedEx
{
public:
    typedef struct _UNICODE_STRING {
        USHORT Length;
        USHORT MaxLength;
        ULONG64 Buffer;
    } UNICODE_STRING, *PUNICODE_STRING;

    static LPWSTR GetUnicodeString(
        ExtRemoteTyped TypedObject,
        _Out_writes_opt_(BufferChars) PWSTR Buffer,
        _In_ ULONG MaxChars
    );

    static LPWSTR
        ExtRemoteTypedEx::GetUnicodeString2(
        ExtRemoteTyped TypedObject
    );

    static LPWSTR
        GetUnicodeStringEx(
        ULONG64 UntypedObject,
        _Out_writes_opt_(BufferChars) PWSTR Buffer,
        _In_ ULONG MaxChars
    );

    static LPWSTR ExtRemoteTypedEx::GetString(
        ULONG64 Address,
        _Out_writes_opt_(BufferChars) LPWSTR Buffer,
        _In_ ULONG MaxChars
    );

    static ULONG64 GetPointer(
        ULONG64 Address
    );

    static ULONG GetPointerSize(
    );

    static HRESULT ReadVirtual(
        ULONG64 BaseAddress,
        PVOID Buffer,
        ULONG BufferSize,
       _Out_ PULONG OutBytesRead
    );

    static
    HRESULT
    ReadImageMemory(
        _In_ ULONG64 BaseAddress,
        _Out_writes_(BufferSize) PVOID Buffer,
        _In_ ULONG BufferSize,
        _Out_opt_ PULONG OutBytesRead
        );

private:
};
```

`SwishDbgExt/EngExtCppEx.cpp`:

```cpp
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - EngExtCppEx.cpp

Abstract:

    - http://msdn.microsoft.com/en-us/windows/ff553536(v=vs.71).aspx

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#include "stdafx.h"
#include "SwishDbgExt.h"

LPWSTR
ExtRemoteTypedEx::GetUnicodeString2(
ExtRemoteTyped TypedObject
)
/*++

Routine Description:

    Description.

Arguments:

    - 

Return Value:

    LPWSTR.

--*/
{
    LPWSTR String = NULL;
    USHORT MaxLen = 0;
    USHORT Len = 0;

#if VERBOSE_MODE
    // TypedObject.OutFullValue();
#endif

    try {

        MaxLen = TypedObject.Field("MaximumLength").GetUshort();
        Len = TypedObject.Field("Length").GetUshort();
    }
    catch (...) {

    }

    if ((MaxLen == 0) || (Len == 0)) return NULL;

    MaxLen = max(MaxLen, Len);
    MaxLen += sizeof(WCHAR);

    String = (LPWSTR)malloc(MaxLen);
    if (!String) return NULL;

    return GetUnicodeString(TypedObject, String, MaxLen);
}

LPWSTR
ExtRemoteTypedEx::GetUnicodeString(
    ExtRemoteTyped TypedObject,
    _Out_writes_(MaxChars) PWSTR Buffer,
    _In_ ULONG MaxChars
)
/*++

Routine Description:

    Description.

Arguments:

    TypedObject - 
    Buffer - 
    MaxChars - 

Return Value:

    LPWSTR.

--*/
{
    UNICODE_STRING SavedUnicodeString = {0};

    RtlZeroMemory(Buffer, MaxChars);

    try {

        SavedUnicodeString.Length = TypedObject.Field("Length").GetUshort();
        SavedUnicodeString.MaxLength = TypedObject.Field("MaximumLength").GetUshort();
        SavedUnicodeString.Buffer = TypedObject.Field("Buffer").GetPtr();

        if (SavedUnicodeString.Buffer && IsValid(SavedUnicodeString.Buffer) && SavedUnicodeString.Length)
        {
            if (SavedUnicodeString.Length > MaxChars)
            {
                /*
                g_Ext->ThrowRemote(HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW),
                                   "(%s): String at %I64X overflows buffer, need 0x%x (Max = 0x%x) chars",
                                   __FUNCTION__, TypedObject.m_Offset, SavedUnicodeString.Length, MaxChars);
                */
                SavedUnicodeString.Length = (USHORT)MaxChars;
                SavedUnicodeString.MaxLength = (USHORT)MaxChars;
            }

            if (g_Ext->m_Data->ReadVirtual(SavedUnicodeString.Buffer,
                                           (PWSTR)Buffer,
                                           SavedUnicodeString.Length,
                                           NULL) != S_OK)
            {
                // g_Ext->Dml("Error: Can't read buffer at 0x%I64X\n", SavedUnicodeString.Buffer);
                StringCchCopyW(Buffer, MaxChars / sizeof(Buffer[0]), L"#ERROR#"); // _countof
            }
        }
    }
    catch (...) {

    }

    return Buffer;
}

LPWSTR
ExtRemoteTypedEx::GetUnicodeStringEx(
    ULONG64 UntypedObject,
    _Out_writes_opt_(MaxChars) PWSTR Buffer,
    _In_ ULONG MaxChars
)
/*++

Routine Description:

    Description.

Arguments:

    UntypedObject - 
    Buffer - 
    MaxChars - 

Return Value:

    LPWSTR.

--*/
{
    ExtRemoteTyped TypedObject("(nt!_UNICODE_STRING *)@$extin", UntypedObject);

    return ExtRemoteTypedEx::GetUnicodeString(TypedObject, Buffer, MaxChars);
}

LPWSTR
ExtRemoteTypedEx::GetString(
    ULONG64 Address,
    _Out_writes_(MaxChars) LPWSTR Buffer,
    _In_ ULONG MaxChars
)
/*++

Routine Description:

    Description.

Arguments:

    - Address
    - Buffer
    - MaxChars

Return Value:

    LPWSTR.

--*/
{
    RtlZeroMemory(Buffer, MaxChars);

    if (IsValid(Address))
    {
        ExtRemoteData usData(Address, MaxChars);
        usData.GetString(Buffer, MaxChars / sizeof(*Buffer));
    }

    return Buffer;
}

BOOLEAN
IsValid(
    _In_ ULONG64 Pointer
)
/*++

Routine Description:

    Description.

Arguments:

    Pointer - 

Return Value:

    BOOLEAN.

--*/
{
    UCHAR Buffer[4];
    ULONG BytesRead;

    HRESULT hResult = g_Ext->m_Data->ReadVirtual(Pointer, Buffer, sizeof(Buffer), &BytesRead);
    if (hResult != S_OK) return FALSE;

    return TRUE;
}

HRESULT
ExtRemoteTypedEx::ReadVirtual(
    _In_ ULONG64 BaseAddress,
    _Out_writes_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG OutBytesRead
)
/*++

Routine Description:

    Description.

Arguments:

    BaseAddress - 
    Buffer - 
    BufferSize - 
    OutBytesRead - 

Return Value:

    None.

--*/
{
    HRESULT Result = S_FALSE;
    ULONG Index = 0;
    ULONG TotalBytesRead = 0;
    ULONG BytesRead = 0;
    ULONG BytesToRead;

    RtlZeroMemory(Buffer, BufferSize);

    for (Index = 0; TotalBytesRead < BufferSize; Index += 1) {

        BytesToRead = min(PAGE_SIZE, BufferSize - TotalBytesRead);

        Result = g_Ext->m_Data->ReadVirtual(BaseAddress + (Index * PAGE_SIZE),
                                            (PUCHAR)Buffer + (Index * PAGE_SIZE),
                                            BytesToRead,
                                            &BytesRead);
        if (Result != S_OK) {

            //
            // Check if base address is valid or not.
            //

            if (Index == 0) goto CleanUp;

            // g_Ext->Dml("Error: [%d] Can't read 0x%I64x bytes at %I64x.\n",
            //     Index, BytesToRead, BaseAddress + (Index * PAGE_SIZE));
            // goto CleanUp;
        }

        TotalBytesRead += BytesToRead;
    }

CleanUp:

    if (TotalBytesRead == BufferSize) Result = S_OK;

    if (OutBytesRead) *OutBytesRead = TotalBytesRead;

    return Result;
}

HRESULT
ExtRemoteTypedEx::ReadImageMemory(
    _In_ ULONG64 BaseAddress,
    _Out_writes_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG OutBytesRead
    )
/*++

Routine Description:

    Description.

Arguments:

    BaseAddress - 
    Buffer - 
    BufferSize - 
    OutBytesRead - 

Return Value:

    None.

--*/
{
    HRESULT Result = S_FALSE;
    ULONG Index = 0;
    ULONG TotalBytesRead = 0;
    ULONG BytesRead = 0;
    ULONG BytesToRead;
    BOOL IsOk = TRUE;

    RtlZeroMemory(Buffer, BufferSize);

    for (Index = 0; TotalBytesRead < BufferSize; Index += 1) {

        BytesToRead = min(PAGE_SIZE, BufferSize - TotalBytesRead);

        Result = g_Ext->m_Data->ReadVirtual(BaseAddress + (Index * PAGE_SIZE),
                                            (PUCHAR)Buffer + (Index * PAGE_SIZE),
                                            BytesToRead,
                                            &BytesRead);
        if (Result != S_OK) {

            IsOk = FALSE;

            //
            // Check if base address is valid or not.
            //

            if (Index == 0) goto CleanUp;
        }

        TotalBytesRead += BytesToRead;
    }

CleanUp:

    if (TotalBytesRead == BufferSize) {

        Result = (IsOk == FALSE) ? E_ACCESSDENIED : S_OK;
    }

    if (OutBytesRead) *OutBytesRead = TotalBytesRead;

    return Result;
}

ULONG
ExtRemoteTypedEx::GetPointerSize(
)
/*++

Routine Description:

    Description.

Arguments:

     

Return Value:

    ULONG.

--*/
{
    ULONG PointerSize;

    if (g_Ext->m_Control->IsPointer64Bit() == S_OK) PointerSize = sizeof(ULONG64);
    else PointerSize = sizeof(ULONG32);

    return PointerSize;
}

ULONG64
ExtRemoteTypedEx::GetPointer(
    _In_ ULONG64 Address
)
/*++

Routine Description:

    Description.

Arguments:

    Address - 

Return Value:

    None.

--*/
{
    ULONG64 Pointer = 0;
    // ULONG BytesRead;
    // ULONG PointerSize;

    // if (g_Ext->m_Control->IsPointer64Bit() == S_OK) PointerSize = sizeof(ULONG64);
    // else PointerSize = sizeof(ULONG32);

    ReadPointer(Address, &Pointer);
    return Pointer;

    // g_Ext->m_Data->ReadVirtual(SIGN_EXTEND(Address), (PUCHAR)&Pointer, PointerSize, &BytesRead);
    // return SIGN_EXTEND(Pointer);
}

PSTR
GetNameByOffset(
    _In_ ULONG64 Offset,
    _Out_writes_(Length) PSTR Buffer,
    _In_ ULONG Length
    )
/*++

Routine Description:

    Description.

Arguments:

    Offset - 
    Name - 
    NameSize - 

Return Value:

    LPSTR.

--*/
{
    CHAR DisplacementString[MAX_PATH];
    ULONG64 Displacement;
    ULONG BytesRead;

    Buffer[0] = '\0';

    if (Offset) {

        if (g_Ext->m_Symbols->GetNameByOffset(Offset, (PSTR)Buffer, Length, &BytesRead, &Displacement) == S_OK) {

            if (Displacement != 0) {

                StringCchPrintf(DisplacementString, _countof(DisplacementString), "+0x%x", Displacement);

                StringCchCat(Buffer, Length, DisplacementString);
            }
        }
    }

    return Buffer;
}

HOOK_TYPE
GetPointerHookType(
    _In_ ULONG64 Pointer
    )
/*++

Routine Description:

    Description.

Arguments:

    Ptr - 

Return Value:

    BOOLEAN.

--*/
{
    BYTE ByteCode[0x20] = {0};
    HOOK_TYPE HookType = NoHook;

    if (g_Ext->m_Data->ReadVirtual(Pointer, ByteCode, sizeof(ByteCode), NULL) == S_OK) {

        if (ByteCode[0] == 0xe9 ||
            ByteCode[0] == 0xeb) // jmp
        {
            HookType = JmpHook;
        }
        else if (ByteCode[0] == 0xe8) // call
        {
            HookType = CallHook;
        }
        else if ((ByteCode[0] == 0xb8) && // mov eax, XXXXXXXX
            (ByteCode[5] == 0xba) && // mov edx, XXXXXXXX
            (ByteCode[0xa] == 0xff) && (ByteCode[0xb] == 0x12) && // call [edx]
            (ByteCode[0xc] == 0xc2)) // retn
        {
            // NT Syscall
            ULONG Edx = ByteCode[6] | (ByteCode[7] << 8) | (ByteCode[8] << 16) | (ByteCode[9] << 24);

            if (Edx != 0x7ffe0300)
            {
                HookType = MovEaxEdxCallPtrHook;
            }
        }
        else if ((ByteCode[0] == 0x68) && // push XXXXXXX
                 (ByteCode[5] == 0xc3)) // ret
        {
            HookType = PushRetHook;
        }
        else if ((ByteCode[0] == 0xff) && (ByteCode[1] == 0x25)) // jmp dword ptr [XXXXXXXX]
        {
            HookType = JmpDwordPtrHook;
        }
        else if ((ByteCode[0] == 0xff) && (ByteCode[1] == 0x15)) // call dword ptr [XXXXXXXX]
        {
            HookType = CallDwordPtrHook;
        }
    }

    return HookType;
}


ULONG64
GetFastRefPointer(
    _In_ ULONG64 Pointer
)
/*++

Routine Description:

    Description.

Arguments:

    Pointer - 

Return Value:

    ULONG64.

--*/
{
    ULONG64 ExRefMask = (g_Ext->m_Control->IsPointer64Bit() == S_OK) ? ~0xF : ~0x7;

    Pointer &= ExRefMask;

    return (Pointer & ExRefMask);
}

ULONG
ReadPointersVirtual(
    _In_ ULONG PointerCount,
    _In_ ULONG64 Pointer,
    _Deref_out_range_(0, PointerCount) PULONG64 OutPtrTable
)
/*++

Routine Description:

    Description.

Arguments:

    PointerCount - 
    Pointer - 
    OutPtrTable -

Return Value:

    ULONG.

--*/
{
    ULONG i;
    ULONG Result = TRUE;

    for (i = 0; i < PointerCount; i += 1)
    {
        Result = ReadPointer(Pointer + (i * g_Ext->m_PtrSize), &OutPtrTable[i]);
        if (!Result) goto Exit;
    }

Exit:
    if (Result) Result = S_OK;
    else Result = S_FALSE;

    return Result;
}

```

`SwishDbgExt/Lxss.cpp`:

```cpp
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Process.cpp

Abstract:

    - http://msdn.microsoft.com/en-us/windows/ff553536(v=vs.71).aspx

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#include "stdafx.h"
#include "SwishDbgExt.h"
#include "Process.h"

VOID
GetLX(
    VOID
) {
    vector<ULONG64> ListNodes;
    vector<ULONG64> SessionListNodes;
    vector<ULONG64> LxProcessGroupListNodes;
    vector<ULONG64> LxThreadGroupListNodes;
    ULONG64 ListNodeOffset;
    ULONG64 SessionListNodeOffset;
    ULONG64 LxProcessGroupListNodeOffset;
    ULONG64 LxThreadGroupListNodeOffset;
    ULONG64 LxGlobal;
    ULONG ProcessorType;
    ULONG PlateformId, Major, Minor, ServicePackNumber;

    if (g_Ext->m_Control->GetActualProcessorType(&ProcessorType) != S_OK) goto CleanUp;
    if (g_Ext->m_Control->GetSystemVersion(&PlateformId, &Major, &Minor, NULL, NULL, NULL, &ServicePackNumber, NULL, NULL, NULL) != S_OK) goto CleanUp;

    if ((Minor < 14393) && (ProcessorType != IMAGE_FILE_MACHINE_AMD64)) {
        g_Ext->Dml("This platform does not have Linux Subsystem.\n");
        goto CleanUp;
    }

    if (g_Ext->m_Symbols->GetOffsetByName("lxcore!LxGlobal", &LxGlobal) != S_OK) goto CleanUp;
    if (!LxGlobal) goto CleanUp;

    g_Ext->Dml("\n\tWindows Subsystem for Linux Overview.\n");

    {
        ExtRemoteUnTyped GlobalData(LxGlobal, "lx!_LX_GLOBAL_DATA");

        USHORT NTCS = GlobalData.Field("NTCSignature").GetUshort();
        if (NTCS != 0x15c1) {
            g_Ext->Warn("WARNING: NTCS is different than 0x15c1 (value = 0x%x)\n", NTCS);
        }

        DbgPrint("LxGlobal = 0x%I64X...\n", LxGlobal);
        DbgPrint("InstanceListOffset = 0x%I64X (Flink = 0x%I64X)\n", GlobalData.Field("InstanceListOffset").GetPointerTo(), GlobalData.Field("InstanceListOffset.Flink").GetPtr());

        ExtRemoteTypedList List(GlobalData.Field("InstanceListOffset").GetPointerTo(), "nt!_LIST_ENTRY", "Flink");

        for (List.StartHead(); List.HasNode(); List.Next())
        {
            GUID Guid = { 0 };

            ListNodeOffset = List.GetNodeOffset();

            DbgPrint("\tLX_INSTANCE = 0x%p\n", ListNodeOffset);

            if (find(ListNodes.rbegin(), ListNodes.rend(), ListNodeOffset) != ListNodes.rend()) {

                break;
            }

            ListNodes.push_back(ListNodeOffset);

            ULONG64 LxInstanceHead = ListNodeOffset - GetFieldOffset("lx!_LX_INSTANCE", "I_ListOffset.Flink");
            ExtRemoteUnTyped Instance(LxInstanceHead, "lx!_LX_INSTANCE");
            g_Ext->Dml("\t<b><u>Instance 0x%I64X</u></b>\n", Instance.GetPointerTo());

            if (g_Ext->m_Data->ReadVirtual(Instance.Field("I_GuidOffset").GetPointerTo(), &Guid, sizeof(GUID), NULL) != S_OK) goto CleanUp;
            g_Ext->Dml("\tGUID: {%08lX-%04hX-%04hX-%02hhX%02hhX-%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX}\n",
                Guid.Data1, Guid.Data2, Guid.Data3,
                Guid.Data4[0], Guid.Data4[1], Guid.Data4[2], Guid.Data4[3],
                Guid.Data4[4], Guid.Data4[5], Guid.Data4[6], Guid.Data4[7]);

            g_Ext->Dml("\tState:            (%d) %s\n", Instance.Field("I_StateOffset").GetPtr(), !Instance.Field("I_StateOffset").GetPtr() ? "[CREATED]" : "[STARTED]");
            g_Ext->Dml("\tCreation Flags:   %08lX\n", Instance.Field("I_FlagsOffset").GetUlong());
            g_Ext->Dml("\tGlobalData:       0x%I64X\n", Instance.Field("I_GlobalDataOffset").GetPtr());

            g_Ext->Dml("\tRoot Handle:      <link cmd=\"!handle %lx 2 4\">%lx</link>\n", Instance.Field("I_RootHandleOffset").GetPtr(), Instance.Field("I_RootHandleOffset").GetPtr());
            g_Ext->Dml("\tTemp Handle:      <link cmd=\"!handle %lx 2 4\">%lx</link>\n", Instance.Field("I_TempHandleOffset").GetPtr(), Instance.Field("I_TempHandleOffset").GetPtr());
            g_Ext->Dml("\tJob Handle:       <link cmd=\"!handle %lx 2 4\">%lx</link>\n", Instance.Field("I_JobHandleOffset").GetPtr(), Instance.Field("I_JobHandleOffset").GetPtr());

            g_Ext->Dml("\tToken:            <link cmd=\".foreach /pS 0n28 /ps 1000 (place { !handle %lx 2 4 }) { !token place -n }\">%lx</link>\n", Instance.Field("I_TokenHandleOffset").GetPtr(), Instance.Field("I_TokenHandleOffset").GetPtr());
            g_Ext->Dml("\tEvent Handle:     <link cmd=\"!handle %lx 2 4\">%lx</link>\n\n", Instance.Field("I_EventHandleOffset").GetPtr(), Instance.Field("I_EventHandleOffset").GetPtr());
            g_Ext->Dml("\tMap Paths (%d):    0x%P\n", Instance.Field("I_PathCountOffset").GetUlong(), Instance.Field("I_PathsOffset").GetPtr());

            g_Ext->Dml("\tVFS Context:      0x%P\n", Instance.Field("I_VfsContextOffset").GetPtr());
            g_Ext->Dml("\tMemory Flags:     0x%llX\n\n", Instance.Field("I_MemoryFlagsOffset").GetPtr());
            g_Ext->Dml("\tLast PID:         %d\n", Instance.Field("I_LastPidOffset").GetPtr());
            g_Ext->Dml("\tThread Groups:    %d\n", Instance.Field("I_GroupCountOffset").GetPtr());

            ExtRemoteTypedList SessionList(Instance.Field("I_SessionListOffset").GetPointerTo(), "nt!_LIST_ENTRY", "Flink");

            for (SessionList.StartHead(); SessionList.HasNode(); SessionList.Next()) {

                SessionListNodeOffset = SessionList.GetNodeOffset();

                if (find(SessionListNodes.rbegin(), SessionListNodes.rend(), SessionListNodeOffset) != SessionListNodes.rend()) {

                    break;
                }

                SessionListNodes.push_back(SessionListNodeOffset);

                DbgPrint("\t\t_LX_SESSION = 0x%p\n", SessionListNodeOffset);
                ULONG64 LxSessionHead = SessionListNodeOffset - GetFieldOffset("lx!_LX_SESSION", "S_ListOffset.Flink");
                DbgPrint("\t\tLxSessionHead = 0x%I64X\n", LxSessionHead);
                ExtRemoteUnTyped LxSession(LxSessionHead, "lx!_LX_SESSION");
                g_Ext->Dml("\t\t<b><u>Session 0x%I64X</u></b>\n", LxSession.GetPointerTo());

                g_Ext->Dml("\t\tInstance:         0x%I64X\n", LxSession.Field("S_InstanceOffset").GetPtr());
                g_Ext->Dml("\t\tConsole inode:    0x%I64X\n", LxSession.Field("S_ConInodeOffset").GetPtr());
                g_Ext->Dml("\t\tForeground PID:   %d\n", (ULONG)LxSession.Field("S_FgPidOffset").GetPtr());

                ExtRemoteTypedList LxProcessGroupList(LxSession.Field("S_GroupListOffset").GetPointerTo(), "nt!_LIST_ENTRY", "Flink");

                for (LxProcessGroupList.StartHead(); LxProcessGroupList.HasNode(); LxProcessGroupList.Next()) {

                    LxProcessGroupListNodeOffset = LxProcessGroupList.GetNodeOffset();

                    if (find(LxProcessGroupListNodes.rbegin(), LxProcessGroupListNodes.rend(), LxProcessGroupListNodeOffset) != LxProcessGroupListNodes.rend()) {

                        break;
                    }

                    LxProcessGroupListNodes.push_back(LxProcessGroupListNodeOffset);

                    DbgPrint("\t\t\t_LX_PROCESSGROUP = 0x%p\n", LxProcessGroupListNodeOffset);
                    ULONG64 LxProcessGroupHead = LxProcessGroupListNodeOffset - GetFieldOffset("lx!_LX_PROCESSGROUP", "PG_ListOffset.Flink");
                    DbgPrint("\t\t\tLxProcessGroupHead = 0x%I64X\n", LxProcessGroupHead);
                    ExtRemoteUnTyped LxProcessGroup(LxProcessGroupHead, "lx!_LX_PROCESSGROUP");
                    g_Ext->Dml("\t\t\t<b><u>Process Group 0x%I64X</u></b>\n", LxProcessGroup.GetPointerTo());
                    g_Ext->Dml("\t\t\tInstance:      0x%P\n", LxProcessGroup.Field("PG_InstanceOffset").GetPtr());
                    g_Ext->Dml("\t\t\tSession:       0x%P\n", LxProcessGroup.Field("PG_SessionOffset").GetPtr());

                    ExtRemoteTypedList LxThreadGroupList(LxProcessGroup.Field("PG_GroupListOffset").GetPointerTo(), "nt!_LIST_ENTRY", "Flink");

                    for (LxThreadGroupList.StartHead(); LxThreadGroupList.HasNode(); LxThreadGroupList.Next()) {

                        LxThreadGroupListNodeOffset = LxThreadGroupList.GetNodeOffset();

                        if (find(LxThreadGroupListNodes.rbegin(), LxThreadGroupListNodes.rend(), LxThreadGroupListNodeOffset) != LxThreadGroupListNodes.rend()) {

                            break;
                        }

                        LxThreadGroupListNodes.push_back(LxThreadGroupListNodeOffset);

                        DbgPrint("\t\t\t\t_LX_THREADGROUP = 0x%p\n", LxThreadGroupListNodeOffset);
                        ULONG64 LxThreadGroupHead = LxThreadGroupListNodeOffset - GetFieldOffset("lx!_LX_THREADGROUP", "TG_ListOffset.Flink");
                        DbgPrint("\t\t\t\tLxProcessGroupHead = 0x%I64X\n", LxThreadGroupHead);
                        ExtRemoteUnTyped LxThreadGroup(LxThreadGroupHead, "lx!_LX_THREADGROUP");
                        g_Ext->Dml("\t\t\t\t<b><u>Thread Group 0x%I64X</u></b>\n", LxThreadGroup.GetPointerTo());

                        WCHAR BinaryPath[MAX_PATH] = { 0 };
                        ExtRemoteTyped BinaryPathTyped("(nt!_UNICODE_STRING*)@$extin", LxThreadGroup.Field("TG_PathOffset").GetPointerTo());
                        ExtRemoteTypedEx::GetUnicodeString(BinaryPathTyped, (PWSTR)BinaryPath, sizeof(BinaryPath));
                        g_Ext->Dml("\t\t\t\tBinary Path:           %S\n", BinaryPath);
                        g_Ext->Dml("\t\t\t\tThread(s):             %d\n", LxThreadGroup.Field("TG_ThreadCountOffset").GetUlong());
                        g_Ext->Dml("\t\t\t\tOwner Process Group:   0x%P\n", LxThreadGroup.Field("TG_ProcGroupOffset").GetPtr());
                        g_Ext->Dml("\t\t\t\tFlags:                 0x%08lX\n", LxThreadGroup.Field("TG_FlagsOffset").GetUlong());
                        g_Ext->Dml("\t\t\t\tMain Thread:           0x%P\n", LxThreadGroup.Field("TG_MainThreadOffset").GetPtr());
                        ULONG FileHandle = 0;
                        if (g_Ext->m_Data->ReadVirtual(Instance.Field("TG_FileOffset").GetPtr(), &FileHandle, sizeof(ULONG), NULL) == S_OK) {
                            g_Ext->Dml("\t\t\t\tFile Handle:           0x%08lX\n", Instance.Field("TG_FileOffset").GetPtr());
                        }
                        ULONG ArgLen = LxThreadGroup.Field("TG_ArgsSizeOffset").GetUlong();
                        ULONG64 ArgPtr = LxThreadGroup.Field("TG_ArgumentsOffset").GetPtr();
                        g_Ext->Dml("\t\t\t\tArguments (%03d bytes): 0x%P\n", ArgLen, ArgPtr);
                        if (ArgLen) {
                            CHAR Arguments[MAX_PATH] = { 0 };
                            if (g_Ext->m_Data->ReadVirtual(ArgPtr, Arguments, min(ArgLen, sizeof(Arguments)) , NULL) == S_OK) {
                                g_Ext->Dml("\t\t\t\tArguments (string):     %s\n", Arguments);
                            }
                        }

                        ULONG64 LxProcessHead = LxThreadGroup.Field("TG_ProcOffset").GetPtr();
                        DbgPrint("\t\t\t\t\t_LX_PROCESS = 0x%p\n", LxProcessHead);

                        ExtRemoteUnTyped LxProcess(LxProcessHead, "lx!_LX_PROCESS");
                        g_Ext->Dml("\t\t\t\t\t<b><u>Process 0x%I64X</u></b>\n", LxProcess.GetPointerTo());
                        g_Ext->Dml("\t\t\t\t\tInstance:            0x%P\n", LxProcess.Field("P_InstanceOffset").GetPtr());
                        g_Ext->Dml("\t\t\t\t\tNT Process Object:   0x%P\n", LxProcess.Field("P_ProcObjectOffset").GetPtr());
                        g_Ext->Dml("\t\t\t\t\tNT Process Handle:   0x%P\n", LxProcess.Field("P_ProcHandleOffset").GetPtr());
                        g_Ext->Dml("\t\t\t\t\tVDSO Address:        0x%P\n", LxProcess.Field("P_VdsoOffset").GetPtr());
                        g_Ext->Dml("\t\t\t\t\tStack Address:       0x%P\n", LxProcess.Field("P_StackOffset").GetPtr());
                    }
                }
            }
        }
    }

CleanUp:
    return;
}
```

`SwishDbgExt/Lxss.h`:

```h
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2017 Comae Technologies
    Copyright (C) 2017 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Lxss.h

Abstract:

    - 

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#ifndef __LXSS_H__
#define __LXSS_H__

VOID
GetLX(
    VOID
);

#endif
```

`SwishDbgExt/Md5.cpp`:

```cpp
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Md5.c

Abstract:

    - 

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#include "stdafx.h"
#include "SwishDbgExt.h"


/* F, G and H are basic MD5 functions: selection, majority, parity */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z))) 

/* ROTATE_LEFT rotates x left n bits */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s, ac) \
  {(a) += F ((b), (c), (d)) + (x) + (UINT32)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) \
  {(a) += G ((b), (c), (d)) + (x) + (UINT32)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) \
  {(a) += H ((b), (c), (d)) + (x) + (UINT32)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) \
  {(a) += I ((b), (c), (d)) + (x) + (UINT32)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }

/*
 **********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved. **
 **                                                                  **
 ** License to copy and use this software is granted provided that   **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message     **
 ** Digest Algorithm" In all material mentionIng or referencIng this **
 ** software or this function.                                       **
 **                                                                  **
 ** License is also granted to make and use derivative works         **
 ** provided that such works are identified as "derived from the RSA **
 ** Data Security, Inc. MD5 Message Digest Algorithm" In all         **
 ** material mentionIng or referencIng the derived work.             **
 **                                                                  **
 ** RSA Data Security, Inc. makes no representations concernIng      **
 ** either the merchantability of this software or the suitability   **
 ** of this software for any particular purpose.  It is provided "as **
 ** is" without express or implied warranty of any kInd.             **
 **                                                                  **
 ** These notices must be retaIned In any copies of any part of this **
 ** documentation and/or software.                                   **
 **********************************************************************
 */

UCHAR PADDING[64] = {
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* Basic MD5 step. Transform Buffer based on In.
*/
VOID
Transform(
    _Inout_ ULONG *Buffer,
    _Inout_ ULONG *In
)
/*++

Routine Description:

    Description.

Arguments:

    Buffer - 
    In -

Return Value:

    VOID.

--*/
{
    ULONG a = Buffer[0], b = Buffer[1], c = Buffer[2], d = Buffer[3];

    /* Round 1 */
    #define S11 7
    #define S12 12
    #define S13 17
    #define S14 22
    FF ( a, b, c, d, In[ 0], S11, 3614090360); /* 1 */
    FF ( d, a, b, c, In[ 1], S12, 3905402710); /* 2 */
    FF ( c, d, a, b, In[ 2], S13,  606105819); /* 3 */
    FF ( b, c, d, a, In[ 3], S14, 3250441966); /* 4 */
    FF ( a, b, c, d, In[ 4], S11, 4118548399); /* 5 */
    FF ( d, a, b, c, In[ 5], S12, 1200080426); /* 6 */
    FF ( c, d, a, b, In[ 6], S13, 2821735955); /* 7 */
    FF ( b, c, d, a, In[ 7], S14, 4249261313); /* 8 */
    FF ( a, b, c, d, In[ 8], S11, 1770035416); /* 9 */
    FF ( d, a, b, c, In[ 9], S12, 2336552879); /* 10 */
    FF ( c, d, a, b, In[10], S13, 4294925233); /* 11 */
    FF ( b, c, d, a, In[11], S14, 2304563134); /* 12 */
    FF ( a, b, c, d, In[12], S11, 1804603682); /* 13 */
    FF ( d, a, b, c, In[13], S12, 4254626195); /* 14 */
    FF ( c, d, a, b, In[14], S13, 2792965006); /* 15 */
    FF ( b, c, d, a, In[15], S14, 1236535329); /* 16 */

    /* Round 2 */
    #define S21 5
    #define S22 9
    #define S23 14
    #define S24 20
    GG ( a, b, c, d, In[ 1], S21, 4129170786); /* 17 */
    GG ( d, a, b, c, In[ 6], S22, 3225465664); /* 18 */
    GG ( c, d, a, b, In[11], S23,  643717713); /* 19 */
    GG ( b, c, d, a, In[ 0], S24, 3921069994); /* 20 */
    GG ( a, b, c, d, In[ 5], S21, 3593408605); /* 21 */
    GG ( d, a, b, c, In[10], S22,   38016083); /* 22 */
    GG ( c, d, a, b, In[15], S23, 3634488961); /* 23 */
    GG ( b, c, d, a, In[ 4], S24, 3889429448); /* 24 */
    GG ( a, b, c, d, In[ 9], S21,  568446438); /* 25 */
    GG ( d, a, b, c, In[14], S22, 3275163606); /* 26 */
    GG ( c, d, a, b, In[ 3], S23, 4107603335); /* 27 */
    GG ( b, c, d, a, In[ 8], S24, 1163531501); /* 28 */
    GG ( a, b, c, d, In[13], S21, 2850285829); /* 29 */
    GG ( d, a, b, c, In[ 2], S22, 4243563512); /* 30 */
    GG ( c, d, a, b, In[ 7], S23, 1735328473); /* 31 */
    GG ( b, c, d, a, In[12], S24, 2368359562); /* 32 */

    /* Round 3 */
    #define S31 4
    #define S32 11
    #define S33 16
    #define S34 23
    HH ( a, b, c, d, In[ 5], S31, 4294588738); /* 33 */
    HH ( d, a, b, c, In[ 8], S32, 2272392833); /* 34 */
    HH ( c, d, a, b, In[11], S33, 1839030562); /* 35 */
    HH ( b, c, d, a, In[14], S34, 4259657740); /* 36 */
    HH ( a, b, c, d, In[ 1], S31, 2763975236); /* 37 */
    HH ( d, a, b, c, In[ 4], S32, 1272893353); /* 38 */
    HH ( c, d, a, b, In[ 7], S33, 4139469664); /* 39 */
    HH ( b, c, d, a, In[10], S34, 3200236656); /* 40 */
    HH ( a, b, c, d, In[13], S31,  681279174); /* 41 */
    HH ( d, a, b, c, In[ 0], S32, 3936430074); /* 42 */
    HH ( c, d, a, b, In[ 3], S33, 3572445317); /* 43 */
    HH ( b, c, d, a, In[ 6], S34,   76029189); /* 44 */
    HH ( a, b, c, d, In[ 9], S31, 3654602809); /* 45 */
    HH ( d, a, b, c, In[12], S32, 3873151461); /* 46 */
    HH ( c, d, a, b, In[15], S33,  530742520); /* 47 */
    HH ( b, c, d, a, In[ 2], S34, 3299628645); /* 48 */

    /* Round 4 */
    #define S41 6
    #define S42 10
    #define S43 15
    #define S44 21
    II ( a, b, c, d, In[ 0], S41, 4096336452); /* 49 */
    II ( d, a, b, c, In[ 7], S42, 1126891415); /* 50 */
    II ( c, d, a, b, In[14], S43, 2878612391); /* 51 */
    II ( b, c, d, a, In[ 5], S44, 4237533241); /* 52 */
    II ( a, b, c, d, In[12], S41, 1700485571); /* 53 */
    II ( d, a, b, c, In[ 3], S42, 2399980690); /* 54 */
    II ( c, d, a, b, In[10], S43, 4293915773); /* 55 */
    II ( b, c, d, a, In[ 1], S44, 2240044497); /* 56 */
    II ( a, b, c, d, In[ 8], S41, 1873313359); /* 57 */
    II ( d, a, b, c, In[15], S42, 4264355552); /* 58 */
    II ( c, d, a, b, In[ 6], S43, 2734768916); /* 59 */
    II ( b, c, d, a, In[13], S44, 1309151649); /* 60 */
    II ( a, b, c, d, In[ 4], S41, 4149444226); /* 61 */
    II ( d, a, b, c, In[11], S42, 3174756917); /* 62 */
    II ( c, d, a, b, In[ 2], S43,  718787259); /* 63 */
    II ( b, c, d, a, In[ 9], S44, 3951481745); /* 64 */

    Buffer[0] += a;
    Buffer[1] += b;
    Buffer[2] += c;
    Buffer[3] += d;
}

VOID
MD5Init(
    _Inout_ PMD5_CONTEXT Md5Context
)
/*++

Routine Description:

    Description.

Arguments:

    Md5Context - 

Return Value:

    VOID.

--*/
{
    Md5Context->i[0] = Md5Context->i[1] = (UINT32)0;

    /* Load magic Initialization constants.
     */
    Md5Context->Buffer[0] = (UINT32)0x67452301;
    Md5Context->Buffer[1] = (UINT32)0xefcdab89;
    Md5Context->Buffer[2] = (UINT32)0x98badcfe;
    Md5Context->Buffer[3] = (UINT32)0x10325476;
}

VOID
MD5Update(
    _Inout_ PMD5_CONTEXT Md5Context,
    _In_ PUCHAR InBuf,
    _In_ ULONG InLen
)
/*++

Routine Description:

    Description.

Arguments:

    Md5Context - 
    InBuf - 
    InLen - 

Return Value:

    ULONG64.

--*/
{
    ULONG In[16];
    int Mdi;
    ULONG i, ii;

    /* compute number of bytes mod 64 */
    Mdi = (int)((Md5Context->i[0] >> 3) & 0x3F);

    /* update number of bits */
    if ((Md5Context->i[0] + ((ULONG)InLen << 3)) < Md5Context->i[0])
    Md5Context->i[1]++;
    Md5Context->i[0] += ((ULONG)InLen << 3);
    Md5Context->i[1] += ((ULONG)InLen >> 29);

    while (InLen--)
    {
        /* add new character to Bufferfer, Increment Mdi */
        Md5Context->In[Mdi++] = *InBuf++;

        /* transform if necessary */
        if (Mdi == 0x40)
        {
          for (i = 0, ii = 0; i < 16; i++, ii += 4)
            In[i] = (((ULONG)Md5Context->In[ii+3]) << 24) |
                    (((ULONG)Md5Context->In[ii+2]) << 16) |
                    (((ULONG)Md5Context->In[ii+1]) << 8) |
                    ((ULONG)Md5Context->In[ii]);
          Transform (Md5Context->Buffer, In);
          Mdi = 0;
        }
    }
}

VOID
MD5Final(
    _Inout_ MD5_CONTEXT *Md5Context
)
/*++

Routine Description:

    Description.

Arguments:

    Md5Context - 

Return Value:

    VOID.

--*/
{
    ULONG In[16];
    int Mdi;
    ULONG i, ii;
    ULONG PadLen;

    /* save number of bits */
    In[14] = Md5Context->i[0];
    In[15] = Md5Context->i[1];

    /* compute number of bytes mod 64 */
    Mdi = (int)((Md5Context->i[0] >> 3) & 0x3F);

    /* pad out to 56 mod 64 */
    PadLen = (Mdi < 56) ? (56 - Mdi) : (120 - Mdi);
    MD5Update (Md5Context, PADDING, PadLen);

    /* append length In bits and transform */
    for (i = 0, ii = 0; i < 14; i++, ii += 4)
    In[i] = (((ULONG)Md5Context->In[ii+3]) << 24) |
            (((ULONG)Md5Context->In[ii+2]) << 16) |
            (((ULONG)Md5Context->In[ii+1]) << 8) |
            ((ULONG)Md5Context->In[ii]);
    Transform (Md5Context->Buffer, In);

    /* store Bufferfer In Digest */
    for (i = 0, ii = 0; i < 4; i++, ii += 4)
    {
        Md5Context->Digest[ii] = (UCHAR)(Md5Context->Buffer[i] & 0xFF);
        Md5Context->Digest[ii+1] =
          (UCHAR)((Md5Context->Buffer[i] >> 8) & 0xFF);
        Md5Context->Digest[ii+2] =
          (UCHAR)((Md5Context->Buffer[i] >> 16) & 0xFF);
        Md5Context->Digest[ii+3] =
          (UCHAR)((Md5Context->Buffer[i] >> 24) & 0xFF);
    }
}
```

`SwishDbgExt/Md5.h`:

```h
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Md5.h

Abstract:

    - ExtRemoteData Pointer(GetExpression("'htsxxxxx!gRingBuffer"), m_PtrSize); // <<< works just fine

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/


#ifndef __MD5_H__
#define __MD5_H__

//
// Data structure for MD5 (Message Digest) computation 
//
typedef struct _MD5_CONTEXT {
    ULONG i[2]; /* number of _bits_ handled mod 2^64 */
    ULONG Buffer[4]; /* scratch Bufferfer */
    UCHAR In[64]; /* Input Bufferfer */
    UCHAR Digest[16]; /* actual Digest after MD5FInal call */
} MD5_CONTEXT, *PMD5_CONTEXT;

void
MD5Init(
    MD5_CONTEXT *Md5Context
);

void
MD5Update(
    MD5_CONTEXT *Md5Context,
    unsigned char *InBuf,
    unsigned long InLen
);

void
MD5Final(
    MD5_CONTEXT *Md5Context
);

#endif
```

`SwishDbgExt/Network.cpp`:

```cpp
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Network.cpp

    - SMB 

Abstract:

    - http://msdn.microsoft.com/en-us/windows/ff553536(v=vs.71).aspx


Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

//
// TCPIP
// SMB
// NETBIOS
//

#include "stdafx.h"
#include "SwishDbgExt.h"

PSTR
GetProtocolType(
    _In_ ULONG Type
)
/*++

Routine Description:

    Description.

Arguments:

    Type - 

Return Value:

    PSTR.

--*/
{
    switch (Type)
    {
    case PROTOCOL_AH:
        return "AH";
            break;
        case PROTOCOL_ESP:
            return "ESP";
            break;
        case PROTOCOL_COMP:
            return "COMP";
            break;
        case PROTOCOL_TCP:
            return "TCP";
            break;
        case PROTOCOL_UDP:
            return "UDP";
            break;
        case PROTOCOL_RSVP:
            return "RSVP";
            break;
        case PROTOCOL_ICMP:
            return "ICMP";
            break;
    }

    return "UKNWN";
}

LPSTR
GetTcbState(
    _In_ ULONG State
)
/*++

Routine Description:

    Description.

Arguments:

    State - 

Return Value:

    LPSTR.

--*/
{
    LPSTR TcbState[] = {
        "CLOSED",
        "LISTEN",
        "SYN SENT",
        "SYN RCVD",
        "ESTABLISHED",
        "FIN WAIT1",
        "FIN WAIT2",
        "CLOSE WAIT",
        "CLOSING",
        "LACK ACK",
        "TIME WAIT",
        NULL
    };

    if (State >= TcbMaximumState) return "UN";

    return TcbState[State];
}

vector<NETWORK_ENTRY>
GetSockets(
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    vector<NETWORK_ENTRY>.

--*/
{
    ULONG64 TableAddr;
    ULONG64 TableCountAddr;

    PULONG64 Table = NULL;
    ULONG TableCount;

    vector<NETWORK_ENTRY> NetworkEntries;
    vector<ULONG64> Nodes;

    ULONG ProcessorType;
    ULONG PlateformId, Major, Minor, ServicePackNumber;

    if (g_Ext->m_Control->GetActualProcessorType(&ProcessorType) != S_OK) goto CleanUp;
    if (g_Ext->m_Control->GetSystemVersion(&PlateformId, &Major, &Minor, NULL, NULL, NULL, &ServicePackNumber, NULL, NULL, NULL) != S_OK) goto CleanUp;

    // g_Ext->Dml("Major: %d, Minor: %d, ProcessorType = %x\n", Major, Minor, ProcessorType);

    if ((Minor < 6000) && (ProcessorType == IMAGE_FILE_MACHINE_I386))
    {
        if (g_Ext->m_Symbols->GetOffsetByName("tcpip!AddrObjTable", &TableAddr) != S_OK) goto CleanUp;
        if (g_Ext->m_Symbols->GetOffsetByName("tcpip!AddrObjTableSize", &TableCountAddr) != S_OK) goto CleanUp;

        if (ReadPointersVirtual(1, TableAddr, &TableAddr) != S_OK) goto CleanUp;
        if (g_Ext->m_Data->ReadVirtual(TableCountAddr, &TableCount, sizeof(ULONG), NULL) != S_OK) goto CleanUp;

        Table = (PULONG64)malloc(TableCount * sizeof(ULONG64));
        if (ReadPointersVirtual(TableCount, TableAddr, Table) != S_OK) goto CleanUp;

        for (UINT i = 0; i < TableCount; i += 1)
        {
            Network::OBJECT_ENTRY_X86 ObjectEntry = { 0 };

            NETWORK_ENTRY NetworkEntry = { 0 };

            if (Table[i] == 0) continue;

            if (g_Ext->m_Data->ReadVirtual(Table[i], &ObjectEntry, sizeof(Network::OBJECT_ENTRY_X86), NULL) != S_OK) goto CleanUp;

            NetworkEntry.ObjectPtr = Table[i];
            NetworkEntry.CreationTime = ObjectEntry.CreationTime;

            NetworkEntry.ProcessId = ObjectEntry.ProcessId;
            NetworkEntry.Protocol = ObjectEntry.Protocol;

            NetworkEntry.Local.Port = (ObjectEntry.Port[1] << 8) | ObjectEntry.Port[0];
            NetworkEntry.Local.IPv4_Addr[3] = ObjectEntry.LocalAddress[3];
            NetworkEntry.Local.IPv4_Addr[2] = ObjectEntry.LocalAddress[2];
            NetworkEntry.Local.IPv4_Addr[1] = ObjectEntry.LocalAddress[1];
            NetworkEntry.Local.IPv4_Addr[0] = ObjectEntry.LocalAddress[0];

            NetworkEntry.State = TcbListenState;

            NetworkEntries.push_back(NetworkEntry);
        }
    }
    else if (Minor > 6000)
    {
        if (g_Ext->m_Symbols->GetOffsetByName("tcpip!PartitionCount", &TableCountAddr) != S_OK) goto CleanUp;

        ReadPointer(GetExpression("tcpip!PartitionTable"), &TableAddr);
        if (!TableAddr) goto CleanUp;
        if (g_Ext->m_Data->ReadVirtual(TableCountAddr, &TableCount, sizeof(ULONG), NULL) != S_OK) goto CleanUp;

        ULONG ListEntrySize = GetTypeSize("nt!_LIST_ENTRY");
        ULONG PoolHeaderSize = GetTypeSize("nt!_POOL_HEADER");

        ExtRemoteUnTyped PartitionTable(TableAddr, "tcpip!_PARTITION_TABLE");

        for (UINT PartitionIndex = 0; PartitionIndex < TableCount; PartitionIndex += 1)
        {
            NETWORK_ENTRY NetworkEntry = { 0 };

            // g_Ext->Dml("    -> Partition[%d].HashTables = 0x%I64X\n", PartitionIndex, Partition->HashTables);
            ExtRemoteTyped HashTable("(nt!_RTL_DYNAMIC_HASH_TABLE *)@$extin", PartitionTable.ArrayElement(PartitionIndex).Field("HashTables").GetPtr());

            ULONG64 Directory = HashTable.Field("Directory").GetPtr();
            ULONG TableEntries = HashTable.Field("TableSize").GetUlong();

            for (UINT i = 0; i < TableEntries; i += 1)
            {
                ExtRemoteTypedList List(Directory + i * ListEntrySize, "nt!_LIST_ENTRY", "Flink");

                for (List.StartHead(); List.HasNode(); List.Next())
                {
                    ULONG64 Current = List.GetNodeOffset();
                    if (!IsValid(Current)) break;

                    if (find(Nodes.rbegin(), Nodes.rend(), Current) != Nodes.rend()) {

                        break;
                    }

                    Nodes.push_back(Current);

                    ExtRemoteUnTyped Tcb(Current, "tcpip!_TCB");
                    Tcb.SubtractOffset("HashTableEntry");

                    ExtRemoteTyped PoolHeader("(nt!_POOL_HEADER *)@$extin", Tcb.GetPointerTo() - PoolHeaderSize);
                    if (PoolHeader.Field("PoolTag").GetUlong() != 'EpcT') continue;

                    //# Seen as 0x1f0 on Vista SP0, 0x1f8 on Vista SP2 and 0x210 on 7
                    //# Seen as 0x320 on Win7 SP0 x64
                    ULONG PoolSize;
                    if (PoolHeader.Field("BlockSize").GetTypeSize() == sizeof(USHORT))
                    {
                        PoolSize = PoolHeader.Field("BlockSize").GetUshort() * 0x10;
                    }
                    else
                    {
                        PoolSize = PoolHeader.Field("BlockSize").GetUlong() * 0x10;
                    }

                    if (PoolSize < 0x100) continue;

                    ULONG64 SrcAddress = 0;
                    ULONG64 DstAddress = 0;

                    NetworkEntry.Protocol = PROTOCOL_TCP;
                    NetworkEntry.State = Tcb.Field("State").GetUlong();
                    NetworkEntry.Local.Port = Tcb.Field("LocalPort").GetUshort();
                    NetworkEntry.Remote.Port = Tcb.Field("RemotePort").GetUshort();

                    DstAddress = Tcb.Field("Path", TRUE).Field("DestinationAddress").GetPtr();
                    if (IsValid(Tcb.Field("Path").GetPtr() &&
                        IsValid(Tcb.Field("Path", TRUE).Field("SourceAddress").GetPtr()) &&
                        IsValid(Tcb.Field("Path", TRUE).Field("SourceAddress", TRUE).Field("Identifier").GetPtr()) &&
                        IsValid(Tcb.Field("Path", TRUE).Field("SourceAddress", TRUE).Field("Identifier", TRUE).Field("Address").GetPtr())))
                    {
                        SrcAddress = Tcb.Field("Path", TRUE).Field("SourceAddress", TRUE).Field("Identifier", TRUE).Field("Address").GetPtr();
                    }

                    if (DstAddress && g_Ext->m_Data->ReadVirtual(DstAddress, &NetworkEntry.Remote.IPv4_Addr, sizeof(NetworkEntry.Remote.IPv4_Addr), NULL) != S_OK) goto CleanUp;
                    if (SrcAddress && g_Ext->m_Data->ReadVirtual(SrcAddress, &NetworkEntry.Local.IPv4_Addr, sizeof(NetworkEntry.Local.IPv4_Addr), NULL) != S_OK) goto CleanUp;

                    ExtRemoteTyped OwningProcess("(nt!_EPROCESS *)@$extin", Tcb.Field("OwningProcess").GetPtr());

                    NetworkEntry.ProcessId = OwningProcess.Field("UniqueProcessId").GetPtr();
                    OwningProcess.Field("ImageFileName").GetString((LPSTR)NetworkEntry.ProcessName, sizeof(NetworkEntry.ProcessName));
                    NetworkEntries.push_back(NetworkEntry);
                }
            }
        }
    }

CleanUp:
    if (Table) free(Table);

    return NetworkEntries;
}
```

`SwishDbgExt/Network.h`:

```h
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Network.h

Abstract:

    - http://msdn.microsoft.com/en-us/windows/ff553536(v=vs.71).aspx


Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#include "SwishDbgExt.h"

#ifndef __NETWORK_H__
#define __NETWORK_H__

#define PROTOCOL_AH     51
#define PROTOCOL_ESP    50
#define PROTOCOL_COMP   108
#define PROTOCOL_TCP    6
#define PROTOCOL_UDP    17
#define PROTOCOL_RSVP   46
#define PROTOCOL_ICMP   1

/* Dynamic hash table */
typedef struct _RTL_DYNAMIC_HASH_TABLE {
    ULONG   Flags;
    ULONG   Shift;
    ULONG   TableSize;
    ULONG   Pivot;
    ULONG   DivisorMask;
    ULONG   NumEntries;
    ULONG   NonEmptyBuckets;
    ULONG   NumEnumerators;
    ULONG64   Directory;
} RTL_DYNAMIC_HASH_TABLE, *PRTL_DYNAMIC_HASH_TABLE;

//
// TCP_HASH_TABLES
//
//typedef struct DECLSPEC_CACHEALIGN _TCP_HASH_TABLES {
//    RTL_DYNAMIC_HASH_TABLE TcbTable;
//    RTL_DYNAMIC_HASH_TABLE TimeWaitTcbTable;
//    RTL_DYNAMIC_HASH_TABLE StandbyTcbTable;
//    RTL_DYNAMIC_HASH_TABLE SynTcbTable;
//} TCP_HASH_TABLES, *PTCP_HASH_TABLES;

//
// TCP_PARTITION
//
// Maintains a partition of TCP connection hash-tables.
//

typedef struct _TCP_PARTITION {
    ULONG64 Lock;
    ULONG64 HashTables;
    ULONG64 IpHashTables;
    ULONG64 TimerWheels;
    LIST_ENTRY ReassemblyListHead;
    SINGLE_LIST_ENTRY DelayQueueEntry;
} TCP_PARTITION, *PTCP_PARTITION;

typedef enum {
    TcbClosedState,
    TcbListenState,
    TcbSynSentState,
    TcbSynRcvdState,
    TcbEstablishedState,
    TcbFinWait1State,
    TcbFinWait2State,
    TcbCloseWaitState,
    TcbClosingState,
    TcbLastAckState,
    TcbTimeWaitState,
    TcbMaximumState
} TCB_STATE, *PTCB_STATE;

typedef enum _NETIO_DISPATCH_ID {
    NetIoDispatchIpsec = 0,
    NetIoDispatchKfd = 1,
    NetIoDispatchAle = 2,
    NetIoDispatchEQOS = 3,
    NetIoDispatchIDP = 4,
    NetIoDispatchMax = 5
} NETIO_DISPATCH_ID;

typedef struct _NETWORK_ENTRY {
    ULONG64 ObjectPtr;

    ULONG Protocol;
    ULONG State;
    LARGE_INTEGER CreationTime;

    struct {
        union {
            UCHAR IPv6_Addr[16];
            UCHAR IPv4_Addr[4];
        };
        ULONG Port;
    } Local;

    struct {
        union {
            UCHAR IPv6_Addr[16];
            UCHAR IPv4_Addr[4];
        };
        ULONG Port;
    } Remote;

    union {
        ULONG64 ProcessObject;
        ULONG64 ProcessId;
    };

    CHAR ProcessName[16];
} NETWORK_ENTRY, *PNETWORK_ENTRY;

class Network {
public:
    typedef struct _OBJECT_ENTRY_X86 {
        ULONG32 Next;
        UCHAR Unknow04[0x08];
        UCHAR Unknow0C[0x20];
        UCHAR LocalAddress[4];
        UCHAR Port[2];
        USHORT Protocol;
        UCHAR Unknow34[0x114];
        ULONG ProcessId;
        UCHAR Unknow14C[0xC];
        LARGE_INTEGER CreationTime;
    } OBJECT_ENTRY_X86, *POBJECT_ENTRY_X86;
};

vector<NETWORK_ENTRY>
GetSockets(
);

PSTR
GetProtocolType(
ULONG Type
);

LPSTR
GetTcbState(
    ULONG State
);

#endif
```

`SwishDbgExt/NtDef.h`:

```h
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Credentials.h

Abstract:

    - http://msdn.microsoft.com/en-us/windows/ff553536(v=vs.71).aspx

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#ifndef __NTDEF_H__
#define __NTDEF_H__

/*
typedef struct _LIST_ENTRY32 {
    ULONG32 Flink;
    ULONG32 Blink;
} LIST_ENTRY32, *PLIST_ENTRY32;
*/

typedef struct _UNICODE_STRING32 {
    USHORT Length;
    USHORT MaximumLength;
    ULONG32 Buffer;
} UNICODE_STRING32, *PUNICODE_STRING32;

typedef struct _PEB_LDR_DATA32
{
    /*0x000*/     ULONG32 Length;
    /*0x004*/     UINT8 Initialized;
    /*0x005*/     UINT8 _PADDING0_[0x3];
    /*0x008*/     ULONG32 SsHandle;
    /*0x00C*/     LIST_ENTRY32 InLoadOrderModuleList;
    /*0x014*/     LIST_ENTRY32 InMemoryOrderModuleList;
    /*0x01C*/     LIST_ENTRY32 InInitializationOrderModuleList;
    /*0x024*/     ULONG32 EntryInProgress;
    /*0x028*/     UINT8 ShutdownInProgress;
    /*0x029*/     UINT8 _PADDING1_[0x3];
    /*0x02C*/     ULONG32 ShutdownThreadId;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _LDR_DATA_TABLE_ENTRY32
{
    /*0x000*/     LIST_ENTRY32 InLoadOrderLinks;
    /*0x008*/     LIST_ENTRY32 InMemoryOrderLinks;
    /*0x010*/     LIST_ENTRY32 InInitializationOrderLinks;
    /*0x018*/     ULONG32 DllBase;
    /*0x01C*/     ULONG32 EntryPoint;
    /*0x020*/     ULONG32 SizeOfImage;
    /*0x024*/     UNICODE_STRING32 FullDllName;
    /*0x02C*/     UNICODE_STRING32 BaseDllName;
    /*0x034*/     ULONG32 Flags;
    /*0x038*/     UINT16 LoadCount;
    /*0x03A*/     UINT16 TlsIndex;
    union
    {
        LIST_ENTRY32 HashLinks;
        struct
        {
            ULONG32 SectionPointer;
            ULONG32 CheckSum;
        };
    };
    union
    {
        ULONG32 TimeDateStamp;
        ULONG32 LoadedImports;
    };
    /*0x048*/     ULONG32 EntryPointActivationContext;
    /*0x04C*/     ULONG32        PatchInformation;
    /*0x050*/     LIST_ENTRY32 ForwarderLinks;                       // 2 elements, 0x8 bytes (sizeof)
    /*0x058*/     LIST_ENTRY32 ServiceTagLinks;                      // 2 elements, 0x8 bytes (sizeof)
    /*0x060*/     LIST_ENTRY32 StaticLinks;                          // 2 elements, 0x8 bytes (sizeof)
    /*0x068*/     ULONG32        ContextInformation;
    /*0x06C*/     ULONG32      OriginalBase;
    /*0x070*/     LARGE_INTEGER LoadTime;                           // 4 elements, 0x8 bytes (sizeof)
} LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;

#endif
```

`SwishDbgExt/Objects.cpp`:

```cpp
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Ob.cpp

Abstract:

    - http://msdn.microsoft.com/en-us/windows/ff553536(v=vs.71).aspx


Environment:

    - User mode

Revision History:

    - Matthieu Suiche
--*/

#include "stdafx.h"
#include "SwishDbgExt.h"

BOOLEAN ObTypeInit = FALSE;
ExtRemoteTyped ObjTypeTable;


BOOLEAN
ObReadObject(
    _In_ ULONG64 Object,
    _Out_ PHANDLE_OBJECT HandleObj
)
/*++

Routine Description:

    Description.

Arguments:

    Object - 
    HandleObj - 

Return Value:

    BOOLEAN.

--*/
{
    BOOLEAN Result = FALSE;
    PWSTR ObjectName = NULL;
    WCHAR TypeStr[64] = {0};
    ULONG BodyOffset = 0;

    GetFieldOffset("nt!_OBJECT_HEADER", "Body", &BodyOffset);

    try {

        ZeroMemory(HandleObj, sizeof(HANDLE_OBJECT));

        if ((!Object) || (!IsValid(Object))) return FALSE;

        if (!ObTypeInit)
        {
            ObjTypeTable = ExtRemoteTyped("(nt!_OBJECT_TYPE **)@$extin", ObTypeIndexTableAddress);
            ObTypeInit = TRUE;
        }

        ULONG64 ObjHeaderAddr = Object - BodyOffset;

        if (!IsValid(ObjHeaderAddr)) return FALSE;

        ExtRemoteTyped ObjHeader("(nt!_OBJECT_HEADER *)@$extin", ObjHeaderAddr);
        HandleObj->ObjectPtr = Object; // ObjHeader.Field("Body").GetPointerTo().GetPtr();

        if (ObjHeader.HasField("TypeIndex"))
        {
            BYTE HeaderCookie;

            HandleObj->ObjectTypeIndex = ObjHeader.Field("TypeIndex").GetUchar();

            if (g_Ext->m_Data->ReadVirtual(ObHeaderCookieAddress, &HeaderCookie, sizeof(HeaderCookie), NULL) == S_OK) {

                HandleObj->ObjectTypeIndex = (((ObjHeaderAddr >> 8) & 0xff) ^ HandleObj->ObjectTypeIndex) ^ HeaderCookie;
            }

            ExtRemoteTypedEx::GetUnicodeString(ObjTypeTable.ArrayElement(HandleObj->ObjectTypeIndex).Field("Name"), TypeStr, sizeof(TypeStr));

            StringCchCopyW(HandleObj->Type, _countof(HandleObj->Type), TypeStr);
        }
        else
        {
            if (!IsValid(ObjHeader.Field("Type").GetPtr())) goto CleanUp;

            ExtRemoteTypedEx::GetUnicodeString(ObjHeader.Field("Type").Field("Name"), TypeStr, sizeof(TypeStr));

            StringCchCopyW(HandleObj->Type, _countof(HandleObj->Type), TypeStr);
        }

        if (_wcsicmp(TypeStr, L"File") == 0)
        {
            ExtRemoteTyped FileObject("(nt!_FILE_OBJECT *)@$extin", HandleObj->ObjectPtr);
            ObjectName = ExtRemoteTypedEx::GetUnicodeString2(FileObject.Field("FileName"));
        }
        else if (_wcsicmp(TypeStr, L"Driver") == 0)
        {
            ExtRemoteTyped DrvObject("(nt!_DRIVER_OBJECT *)@$extin", HandleObj->ObjectPtr);
            ObjectName = ExtRemoteTypedEx::GetUnicodeString2(DrvObject.Field("DriverName"));
        }
        else if (_wcsicmp(TypeStr, L"Process") == 0)
        {
            CHAR Buffer[MAX_PATH] = {0};

            ExtRemoteTyped ProcessObj("(nt!_EPROCESS *)@$extin", HandleObj->ObjectPtr);

            ProcessObj.Field("ImageFileName").GetString(Buffer, ProcessObj.Field("ImageFileName").GetTypeSize());

            if (strlen(Buffer)) {

                StringCchPrintfW(HandleObj->Name, _countof(HandleObj->Name), L"%S", Buffer);
            }
        }
        //else if (_wcsicmp(TypeStr, L"ALPC Port") == 0)
        //{
        //    // dt nt!_ALPC_PORT
        //}
        //else if (_wcsicmp(TypeStr, L"EtwRegistration") == 0)
        //{
        //    // dt nt!_ETW_?
        //}
        else if (_wcsicmp(TypeStr, L"Thread") == 0)
        {
            // dt nt!_ETHREAD
        }
        //else if (_wcsicmp(TypeStr, L"Event") == 0)
        //{
        //    // dt nt!_KTHREAD
        //}
        else if (_wcsicmp(TypeStr, L"Key") == 0)
        {
            ExtRemoteTyped KeyObject("(nt!_CM_KEY_BODY *)@$extin", HandleObj->ObjectPtr);
            HandleObj->ObjectKcb = KeyObject.Field("KeyControlBlock").GetPtr();
            ObjectName = RegGetKeyName(HandleObj->ObjectKcb);
            // dt nt!_CM_KEY_BODY -> nt!_CM_KEY_CONTROL_BLOCK
        }
        else
        {
            ULONG Offset = 0;
            UCHAR InfoMask = 0;

            if (ObjHeader.HasField("InfoMask"))
            {
                InfoMask = ObjHeader.Field("InfoMask").GetUchar();

                if (InfoMask & OBP_NAME_INFO_BIT)
                {
                    if (InfoMask & OBP_CREATOR_INFO_BIT) {
                        ExtRemoteTyped HeaderCreatorInfo("(nt!_OBJECT_HEADER_CREATOR_INFO *)@$extin", Offset);
                        HandleObj->CreatorUniquePid = HeaderCreatorInfo.Field("CreatorUniqueProcess").GetPtr();
                        Offset += GetTypeSize("nt!_OBJECT_HEADER_CREATOR_INFO");
                    }
                    Offset += GetTypeSize("nt!_OBJECT_HEADER_NAME_INFO");
                }
            }
            else
            {
                Offset = ObjHeader.Field("NameInfoOffset").GetUchar();
            }

            if (Offset)
            {
                ExtRemoteTyped ObjNameInfo("(nt!_OBJECT_HEADER_NAME_INFO *)@$extin", ObjHeaderAddr - Offset);
                ObjectName = ExtRemoteTypedEx::GetUnicodeString2(ObjNameInfo.Field("Name"));
            }
        }
    }
    catch (...) {

    }

    if (ObjectName)
    {
        StringCchCopyW(HandleObj->Name, _countof(HandleObj->Name), ObjectName);

        free(ObjectName);
        ObjectName = NULL;
    }

    Result = TRUE;

CleanUp:

    return Result;
}

vector<HANDLE_OBJECT>
ObOpenObjectDirectory(
    _In_ ULONG64 InputObject
)
/*++

Routine Description:

    Description.

Arguments:

    InputObject - 

Return Value:

    vector<HANDLE_OBJECT>.

--*/
{
    vector<HANDLE_OBJECT> Handles;
    vector<ULONG64> Nodes;
    HANDLE_OBJECT Handle = {0};
    ExtRemoteTyped Directory;
    ULONG64 ObjectDir = InputObject;

    try {

        if (!ObjectDir) {

            ReadPointer(ObpRootDirectoryObjectAddress, &ObjectDir);
        }

        Directory = ExtRemoteTyped("(nt!_OBJECT_DIRECTORY *)@$extin", ObjectDir);

        ObReadObject(ObjectDir, &Handle);

        for (UINT i = 0; i < 37; i += 1) {

            ULONG64 Entry = Directory.Field("HashBuckets").ArrayElement(i).GetPointerTo().GetPtr();

            if (!Entry) {

                continue;
            }

            //
            // ExtRemoteTypedList requires a POINTER to the first entry. Not the offset of the first entry.
            //

            ExtRemoteTypedList EntryList(Entry, "nt!_OBJECT_DIRECTORY_ENTRY", "ChainLink");

            for (EntryList.StartHead(); EntryList.HasNode(); EntryList.Next()) {

                ULONG64 Object = EntryList.GetTypedNode().Field("Object").GetPtr();

                if (find(Nodes.rbegin(), Nodes.rend(), Object) != Nodes.rend()) {

                    break;
                }

                Nodes.push_back(Object);

                ObReadObject(Object, &Handle);

                Handles.push_back(Handle);
            }
        }
    }
    catch (...) {

    }

    return Handles;
}

BOOLEAN
ObOpenChildren(
    _In_opt_ ULONG64 Root,
    _In_ LPWSTR ObjName,
    _Out_ PHANDLE_OBJECT OutHandle
)
/*++

Routine Description:

    Description.

Arguments:

    Root - 
    ObjName -
    OutHandle -

Return Value:

    BOOLEAN.

--*/
{
    vector<HANDLE_OBJECT> Dir = ObOpenObjectDirectory(Root);
    BOOLEAN Result = FALSE;

    ZeroMemory(OutHandle, sizeof(HANDLE_OBJECT));

    for each (HANDLE_OBJECT Handle in Dir)
    {
        if (_wcsicmp(Handle.Name, ObjName) == 0)
        {
            *OutHandle = Handle;
            Result = TRUE;
            break;
        }
    }

    return Result;
}

ULONG64
ObGetFileSystemObject(
    VOID
    )
/*++

Routine Description:

Description.

Arguments:

-

Return Value:

ULONG64.

--*/
{
    ULONG64 Object = 0;

    HANDLE_OBJECT Handle;
    if (ObOpenChildren(0, L"FileSystem", &Handle)) Object = Handle.ObjectPtr;

    return Object;
}

ULONG64
ObGetObjectTypesObject(
    VOID
)
/*++

Routine Description:

Description.

Arguments:

-

Return Value:

ULONG64.

--*/
{
    ULONG64 Object = 0;

    HANDLE_OBJECT Handle;
    if (ObOpenChildren(0, L"ObjectTypes", &Handle)) Object = Handle.ObjectPtr;

    return Object;
}

ULONG64
ObGetDriverObject(
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    ULONG64.

--*/
{
    ULONG64 Object = 0;;

    HANDLE_OBJECT Handle;
    if (ObOpenChildren(0, L"Driver", &Handle)) Object = Handle.ObjectPtr;

    return Object;
}

VOID
ReleaseObjectTypeTable(
    VOID
    )
{
    if (ObTypeInit) {

        ObjTypeTable.Release();

        ObTypeInit = FALSE;
    }
}

```

`SwishDbgExt/Objects.h`:

```h
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
Module Name:

- Objects.h

Abstract:

- ExtRemoteData Pointer(GetExpression("'htsxxxxx!gRingBuffer"), m_PtrSize); // <<< works just fine



Environment:

- User mode

Revision History:

- Matthieu Suiche

--*/

#ifndef __OBJECTS_H__
#define __OBJECTS_H__

BOOLEAN
ObReadObject(
   _In_ ULONG64 Object,
   _Out_ PHANDLE_OBJECT HandleObj
);

vector<HANDLE_OBJECT>
ObOpenObjectDirectory(
   _In_ ULONG64 ObjectDir
);

BOOLEAN
ObOpenChildren(
    _In_opt_ ULONG64 Root,
   _In_ LPWSTR ObjName,
   _Out_ PHANDLE_OBJECT OutHandle
);

ULONG64
ObGetDriverObject(
);

ULONG64
ObGetFileSystemObject(
    VOID
);

ULONG64
ObGetObjectTypesObject(
    VOID
);

#endif
```

`SwishDbgExt/Output.cpp`:

```cpp
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Output.cpp

Abstract:

    - http://msdn.microsoft.com/en-us/windows/ff553536(v=vs.71).aspx
    - TODO: set symbols noisy

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#include "stdafx.h"
#include "SwishDbgExt.h"

VOID
OutThread(
    _In_ PTHREAD_OBJECT Thread
)
/*++

Routine Description:

    Description.

Arguments:

    Thread - 

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(Thread);
}

VOID
OutHandles(
    _In_ PHANDLE_OBJECT Handle
)
/*++

Routine Description:

    Description.

Arguments:

    Handle - 

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(Handle);
}

LPSTR IrpMajor[] = {
    "IRP_MJ_CREATE",
    "IRP_MJ_CREATE_NAMED_PIPE",
    "IRP_MJ_CLOSE",
    "IRP_MJ_READ",
    "IRP_MJ_WRITE",
    "IRP_MJ_QUERY_INFORMATION",
    "IRP_MJ_SET_INFORMATION",
    "IRP_MJ_QUERY_EA",
    "IRP_MJ_SET_EA",
    "IRP_MJ_FLUSH_BUFFERS",
    "IRP_MJ_QUERY_VOLUME_INFORMATION",
    "IRP_MJ_SET_VOLUME_INFORMATION",
    "IRP_MJ_DIRECTORY_CONTROL",
    "IRP_MJ_FILE_SYSTEM_CONTROL",
    "IRP_MJ_DEVICE_CONTROL",
    "IRP_MJ_INTERNAL_DEVICE_CONTROL",
    "IRP_MJ_SHUTDOWN",
    "IRP_MJ_LOCK_CONTROL",
    "IRP_MJ_CLEANUP",
    "IRP_MJ_CREATE_MAILSLOT",
    "IRP_MJ_QUERY_SECURITY",
    "IRP_MJ_SET_SECURITY",
    "IRP_MJ_POWER",
    "IRP_MJ_SYSTEM_CONTROL",
    "IRP_MJ_DEVICE_CHANGE",
    "IRP_MJ_QUERY_QUOTA",
    "IRP_MJ_SET_QUOTA",
    "IRP_MJ_PNP",
    NULL };

VOID
OutDriver(
    _In_ MsDriverObject *Driver,
    _In_ ULONG ExpandFlag
)
/*++

Routine Description:

    Description.

Arguments:

    Driver - 
    ExpandFlag -

Return Value:

    ULONG64.

--*/
{
    MsDriverObject::PFAST_IO_DISPATCH FastIo = NULL;
    UCHAR Name[512] = { 0 };

    g_Ext->Dml("    | <col fg=\"emphfg\">%-32S</col> | <link cmd=\"!ms_drivers /object 0x%016I64X\">0x%016I64x</link> | 0x%08X | %S\n",
        Driver->mm_DriverInfo.DriverName, Driver->m_ObjectPtr,
        Driver->m_ImageBase, Driver->m_ImageSize,
        Driver->mm_DriverInfo.FullDllName);

    if (!ExpandFlag) return;

    if (strlen(Driver->m_PdbInfo.PdbName)) g_Ext->Dml("    <col fg=\"emphfg\">PDB:           </col> %s\n", Driver->m_PdbInfo.PdbName);
    if (wcslen(Driver->m_FileVersion.CompanyName)) g_Ext->Dml("    <col fg=\"emphfg\">Vendor:        </col> %S\n", Driver->m_FileVersion.CompanyName);
    if (wcslen(Driver->m_FileVersion.FileVersion)) g_Ext->Dml("    <col fg=\"emphfg\">Version:       </col> %S\n", Driver->m_FileVersion.FileVersion);
    if (wcslen(Driver->m_FileVersion.FileDescription)) g_Ext->Dml("    <col fg=\"emphfg\">Description:   </col> %S\n", Driver->m_FileVersion.FileDescription);

    for (UINT i = 0; IrpMajor[i]; i += 1)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   IrpMajor[i], Driver->mm_DriverInfo.MajorFunction[i].Address,
                   GetPointerHookType(Driver->mm_DriverInfo.MajorFunction[i].Address) ? "Hooked" : "",
                   GetNameByOffset(Driver->mm_DriverInfo.MajorFunction[i].Address, (LPSTR)Name, _countof(Name)));
    }

    FastIo = &Driver->mm_DriverInfo.FastIoDispatch;

    if (FastIo->FastIoCheckIfPossible.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "FastIoCheckIfPossible",
                   FastIo->FastIoCheckIfPossible.Address,
                   GetPointerHookType(FastIo->FastIoCheckIfPossible.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->FastIoCheckIfPossible.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->FastIoRead.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "FastIoRead",
                   FastIo->FastIoRead.Address,
                   GetPointerHookType(FastIo->FastIoRead.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->FastIoRead.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->FastIoWrite.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "FastIoWrite",
                   FastIo->FastIoWrite.Address,
                   GetPointerHookType(FastIo->FastIoWrite.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->FastIoWrite.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->FastIoQueryBasicInfo.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "FastIoQueryBasicInfo",
                   FastIo->FastIoQueryBasicInfo.Address,
                   GetPointerHookType(FastIo->FastIoQueryBasicInfo.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->FastIoQueryBasicInfo.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->FastIoQueryStandardInfo.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "FastIoQueryStandardInfo",
                   FastIo->FastIoQueryStandardInfo.Address,
                   GetPointerHookType(FastIo->FastIoQueryStandardInfo.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->FastIoQueryStandardInfo.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->FastIoLock.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "FastIoLock",
                   FastIo->FastIoLock.Address,
                   GetPointerHookType(FastIo->FastIoLock.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->FastIoLock.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->FastIoUnlockSingle.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "FastIoUnlockSingle",
                   FastIo->FastIoUnlockSingle.Address,
                   GetPointerHookType(FastIo->FastIoUnlockSingle.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->FastIoUnlockSingle.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->FastIoUnlockAll.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "FastIoUnlockAll",
                   FastIo->FastIoUnlockAll.Address,
                   GetPointerHookType(FastIo->FastIoUnlockAll.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->FastIoUnlockAll.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->FastIoUnlockAllByKey.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "FastIoUnlockAllByKey",
                   FastIo->FastIoUnlockAllByKey.Address,
                   GetPointerHookType(FastIo->FastIoUnlockAllByKey.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->FastIoUnlockAllByKey.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->FastIoDeviceControl.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "FastIoDeviceControl",
                   FastIo->FastIoDeviceControl.Address,
                   GetPointerHookType(FastIo->FastIoDeviceControl.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->FastIoDeviceControl.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->AcquireFileForNtCreateSection.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "AcquireFileForNtCreateSection",
                   FastIo->AcquireFileForNtCreateSection.Address,
                   GetPointerHookType(FastIo->AcquireFileForNtCreateSection.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->AcquireFileForNtCreateSection.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->AcquireFileForNtCreateSection.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "AcquireFileForNtCreateSection",
                   FastIo->AcquireFileForNtCreateSection.Address,
                   GetPointerHookType(FastIo->AcquireFileForNtCreateSection.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->AcquireFileForNtCreateSection.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->ReleaseFileForNtCreateSection.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "ReleaseFileForNtCreateSection",
                   FastIo->ReleaseFileForNtCreateSection.Address,
                   GetPointerHookType(FastIo->ReleaseFileForNtCreateSection.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->ReleaseFileForNtCreateSection.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->FastIoDetachDevice.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "FastIoDetachDevice",
                   FastIo->FastIoDetachDevice.Address,
                   GetPointerHookType(FastIo->FastIoDetachDevice.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->FastIoDetachDevice.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->FastIoQueryNetworkOpenInfo.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "FastIoQueryNetworkOpenInfo",
                   FastIo->FastIoQueryNetworkOpenInfo.Address,
                   GetPointerHookType(FastIo->FastIoQueryNetworkOpenInfo.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->FastIoQueryNetworkOpenInfo.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->AcquireForModWrite.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "AcquireForModWrite",
                   FastIo->AcquireForModWrite.Address,
                   GetPointerHookType(FastIo->AcquireForModWrite.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->AcquireForModWrite.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->MdlRead.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "MdlRead",
                   FastIo->MdlRead.Address,
                   GetPointerHookType(FastIo->MdlRead.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->MdlRead.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->MdlReadComplete.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "MdlReadComplete",
                   FastIo->MdlReadComplete.Address,
                   GetPointerHookType(FastIo->MdlReadComplete.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->MdlReadComplete.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->PrepareMdlWrite.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "PrepareMdlWrite",
                   FastIo->PrepareMdlWrite.Address,
                   GetPointerHookType(FastIo->PrepareMdlWrite.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->PrepareMdlWrite.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->MdlWriteComplete.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "MdlWriteComplete",
                   FastIo->MdlWriteComplete.Address,
                   GetPointerHookType(FastIo->MdlWriteComplete.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->MdlWriteComplete.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->FastIoReadCompressed.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "FastIoReadCompressed",
                   FastIo->FastIoReadCompressed.Address,
                   GetPointerHookType(FastIo->FastIoReadCompressed.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->FastIoReadCompressed.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->FastIoWriteCompressed.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "FastIoWriteCompressed",
                   FastIo->FastIoWriteCompressed.Address,
                   GetPointerHookType(FastIo->FastIoWriteCompressed.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->FastIoWriteCompressed.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->MdlReadCompleteCompressed.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "MdlReadCompleteCompressed",
                   FastIo->MdlReadCompleteCompressed.Address,
                   GetPointerHookType(FastIo->MdlReadCompleteCompressed.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->MdlReadCompleteCompressed.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->MdlWriteCompleteCompressed.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "MdlWriteCompleteCompressed",
                   FastIo->MdlWriteCompleteCompressed.Address,
                   GetPointerHookType(FastIo->MdlWriteCompleteCompressed.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->MdlWriteCompleteCompressed.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->FastIoQueryOpen.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "FastIoQueryOpen",
                   FastIo->FastIoQueryOpen.Address,
                   GetPointerHookType(FastIo->FastIoQueryOpen.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->FastIoQueryOpen.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->ReleaseForModWrite.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "ReleaseForModWrite",
                   FastIo->ReleaseForModWrite.Address,
                   GetPointerHookType(FastIo->ReleaseForModWrite.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->ReleaseForModWrite.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->AcquireForCcFlush.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "AcquireForCcFlush",
                   FastIo->AcquireForCcFlush.Address,
                   GetPointerHookType(FastIo->AcquireForCcFlush.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->AcquireForCcFlush.Address, (LPSTR)Name, _countof(Name)));
    }

    if (FastIo->ReleaseForCcFlush.Address)
    {
        g_Ext->Dml("    \\---| %-32s | 0x%I64X | <col fg=\"changed\">%-6s</col> | %s\n",
                   "ReleaseForCcFlush",
                   FastIo->ReleaseForCcFlush.Address,
                   GetPointerHookType(FastIo->ReleaseForCcFlush.Address) ? "Hooked" : "",
                   GetNameByOffset(FastIo->ReleaseForCcFlush.Address, (LPSTR)Name, _countof(Name)));
    }
}

LPSTR
GetLastWriteTime(
    PFILETIME ftWrite,
    LPSTR Buffer, 
    ULONG dwSize
)
{
    
    SYSTEMTIME stUTC, stLocal;

    if (Buffer && dwSize) {
        RtlZeroMemory(Buffer, dwSize);

        // Convert the last-write time to local time.
        FileTimeToSystemTime(ftWrite, &stUTC);
        SystemTimeToTzSpecificLocalTime(NULL, &stUTC, &stLocal);

        // Build a string showing the date and time.
        sprintf_s(Buffer, dwSize,
            "%02d/%02d/%d  %02d:%02d UTC",
            stLocal.wMonth, stLocal.wDay, stLocal.wYear,
            stLocal.wHour, stLocal.wMinute);
    }
    return Buffer;
}
```

`SwishDbgExt/Output.h`:

```h
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Output.h

Abstract:

    - ExtRemoteData Pointer(GetExpression("'htsxxxxx!gRingBuffer"), m_PtrSize); // <<< works just fine

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#ifndef __OUTPUT_H__
#define __OUTPUT_H__

extern LPSTR IrpMajor[];

VOID
OutThread(
PTHREAD_OBJECT Thread
);

VOID
OutHandles(
PHANDLE_OBJECT Handle
);

VOID
OutDriver(
    MsDriverObject *Driver,
    ULONG ExpandFlag
);

LPSTR
GetLastWriteTime(
    PFILETIME ftWrite,
    LPSTR Buffer,
    ULONG dwSize
);

#endif
```

`SwishDbgExt/Process.cpp`:

```cpp
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Process.cpp

Abstract:

    - http://msdn.microsoft.com/en-us/windows/ff553536(v=vs.71).aspx

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#include "stdafx.h"
#include "SwishDbgExt.h"
#include "Process.h"

map<PVOID, ULONG> g_References;

//
// User-Mode Modules (DLLs)
//
ModuleIterator::ModuleIterator(
    ULONG64 ModuleHead
    ) :
    m_ModuleListHead(ModuleHead),
    m_ModuleList(m_ModuleListHead, "nt!_LDR_DATA_TABLE_ENTRY", "InLoadOrderLinks")
{
    m_ModuleList.StartHead();
}

VOID
ModuleIterator::First()
{
    m_ModuleList.StartHead();
}

ExtRemoteTyped
ModuleIterator::Current(
VOID
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    None.

--*/
{
    return m_ModuleList.GetTypedNodePtr();
}

VOID
ModuleIterator::Next(
VOID
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    None.

--*/
{
    //
    // Could also use something like:
    // m_Current = m_Current.Field("MmProcessLinks");
    // 

    m_ModuleList.Next();
}

VOID
ModuleIterator::Prev(
VOID
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    None.

--*/
{
    m_ModuleList.Prev();
}

BOOLEAN
ModuleIterator::IsDone(
VOID
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    None.

--*/
{
    if (g_Verbose) g_Ext->Dml("[%s!%S!%d] Current().GetPtr() = 0x%llX\n", __FILE__, __FUNCTIONW__, __LINE__, Current().GetPtr());

    return !m_ModuleList.HasNode();
}

VOID
MsDllObject::Set(
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    None.

--*/
{
    try {

        RtlZeroMemory(&mm_CcDllObject, sizeof(mm_CcDllObject));

        if (m_TypedObject.GetPtr()) {

            m_ImageBase = m_TypedObject.Field("DllBase").GetPtr();
            m_ImageSize = m_TypedObject.Field("SizeOfImage").GetUlong();

            ExtRemoteTypedEx::GetUnicodeString(m_TypedObject.Field("FullDllName"), (PWSTR)&mm_CcDllObject.FullDllName, sizeof(mm_CcDllObject.FullDllName));
            ExtRemoteTypedEx::GetUnicodeString(m_TypedObject.Field("BaseDllName"), (PWSTR)&mm_CcDllObject.DllName, sizeof(mm_CcDllObject.DllName));

            if (m_TypedObject.HasField("LoadTime")) {

                mm_CcDllObject.LoadTime.QuadPart = m_TypedObject.Field("LoadTime.QuadPart").GetUlong64();
            }
        }
    }
    catch (...) {

    }
}

//
// Process
//
ProcessIterator::ProcessIterator(
    PROCESS_LINKS_TYPE ProcessLinksType
    )
    : m_ProcessHead(ExtNtOsInformation::GetKernelProcessListHead()),
    m_ProcessList(m_ProcessHead,
    "nt!_EPROCESS",
    "ActiveProcessLinks")
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    None.

--*/
{
    m_LinksType = ProcessLinksType;

    m_ProcessList.StartHead();

    if (g_Verbose) g_Ext->Dml("[%s!%S!%d] m_ProcessHead = 0x%llX\n", __FILE__, __FUNCTIONW__, __LINE__, m_ProcessHead);
    if (g_Verbose) g_Ext->Dml("[%s!%S!%d] Process List Node = 0x%llX\n", __FILE__, __FUNCTIONW__, __LINE__, m_ProcessList.GetNodeOffset());

    if (ProcessLinksType == ProcessLinksMmType)
    {
        if ((m_ProcessList.GetTypedNodePtr().HasField("MmProcessLinks")))
        {
            ExtRemoteTypedList m_MmProcessList(m_ProcessList.GetTypedNodePtr().Field("MmProcessLinks").GetPointerTo().GetPtr(),
                "nt!_EPROCESS",
                "MmProcessLinks");

            m_ProcessList = m_MmProcessList;

            m_ProcessList.StartHead();
        }
    }
}

VOID
ProcessIterator::First(
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    None.

--*/
{
    m_ProcessList.StartHead();
}

ExtRemoteTyped
ProcessIterator::Current(
VOID
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    None.

--*/
{
    return m_ProcessList.GetTypedNodePtr();
}

ExtRemoteTyped
ProcessIterator::CurrentNode(
VOID
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    None.

--*/
{
    return m_ProcessList.GetTypedNode();
}

VOID
ProcessIterator::Next(
    VOID
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    None.

--*/
{
    //
    // Could also use something like:
    // m_Current = m_Current.Field("MmProcessLinks");
    // 

    m_ProcessList.Next();
}

VOID
ProcessIterator::Prev(
    VOID
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    None.

--*/
{
    m_ProcessList.Prev();
}

BOOLEAN
ProcessIterator::IsDone(
    VOID
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    None.

--*/
{
    BOOLEAN bIsDone = TRUE;

    // Pcb.Header.Type == 3 (Process)

    // if (g_Verbose) g_Ext->Dml("Current().m_Offset = 0x%llX\n", Current().m_Offset);
    // if (g_Verbose) g_Ext->Dml("Get Node Offset = 0x%llX\n", m_ProcessList.GetNodeOffset());
    // if (g_Verbose) g_Ext->Dml("Get Node Offset = 0x%llX\n", Current().GetPtr());

    if (Current().GetPtr()) {
        // if (g_Verbose) g_Ext->Dml("Current().Field(Pcb).Field(Header).Field(Type) = 0x%d\n", Current().Field("Pcb").Field("Header").Field("Type").GetChar());
        // if (g_Verbose) g_Ext->Dml("Current().Field(UniqueProcessId).GetPtr() = 0x%llX\n", Current().Field("UniqueProcessId").GetPtr());
        // if (g_Verbose) g_Ext->Dml("m_ProcessList.HasNode() %d\n", m_ProcessList.HasNode());

        bIsDone = (Current().Field("Pcb").Field("Header").Field("Type").GetChar() != 3) || (Current().Field("UniqueProcessId").GetPtr() == 0) || !m_ProcessList.HasNode();
    }

    if (g_Verbose) g_Ext->Dml("[%s!%S!%d] Leaving... (Return value = %d)\n", __FILE__, __FUNCTIONW__, __LINE__, bIsDone);

    return bIsDone;
}

BOOLEAN
MsProcessObject::RestoreContext(
    VOID
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    None.

--*/
{
    BOOLEAN Result = FALSE;

    if (m_ProcessDataOffset) g_Ext->m_System2->SetImplicitProcessDataOffset(m_ProcessDataOffset);
    m_ProcessDataOffset = 0; // Synchronous, so we don't need a lock.

    Result = TRUE;

    return Result;
}

BOOLEAN
MsProcessObject::SwitchContext(
    VOID
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    None.

--*/
{
    BOOLEAN Result = FALSE;

    //
    // Save, and change the current process.
    //
    if (g_Ext->m_System2->GetImplicitProcessDataOffset(&m_ProcessDataOffset) != S_OK) goto CleanUp;
    if (g_Ext->m_System2->SetImplicitProcessDataOffset(m_CcProcessObject.ProcessObjectPtr) != S_OK) goto CleanUp;

    Result = TRUE;

CleanUp:
    return Result;
}

BOOLEAN
MsProcessObject::GetEnvironmentVariableValue(
    _In_ PWSTR Buffer,
    _In_ SIZE_T BufferSize,
    _In_ PWSTR VariableName
    )
{
    PWSTR Name;
    PWSTR Value;

    Buffer[0] = L'\0';

    for (size_t i = 0; i < m_EnvVars.size(); i++) {

        if (m_EnvVars[i].Variable) {

            Name = m_EnvVars[i].Variable;
            Value = wcschr(m_EnvVars[i].Variable, L'=');

            if (Value && (Value != Name)) {

                if (0 == _wcsnicmp(Name, VariableName, Value - Name)) {

                    StringCchCopyW(Buffer, BufferSize, Value + 1);

                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}

BOOLEAN
MsProcessObject::GetDlls(
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    None.

--*/
{
    vector<ULONG64> Nodes;
    BOOLEAN Result = TRUE;

    if (m_CcProcessObject.ProcessId == 4) {

        ULONG64 Head = ExtNtOsInformation::GetKernelLoadedModuleListHead();

        if (IsValid(Head)) {

            try {

                ModuleIterator Dlls(Head);

                for (Dlls.First(); !Dlls.IsDone(); Dlls.Next()) {

                    MsDllObject Object = Dlls.Current();

                    if (find(Nodes.rbegin(), Nodes.rend(), Object.m_ImageBase) != Nodes.rend()) {

                        break;
                    }

                    Nodes.push_back(Object.m_ImageBase);

                    Object.mm_CcDllObject.LoadTime.QuadPart = 0;

                    m_DllList.push_back(Object);
                }
            }
            catch (...) {

            }
        }
    }
    else {

        try {

            ULONG64 Peb = m_TypedObject.Field("Peb").GetPtr();

            if (Peb && IsValid(Peb) && IsValid(m_TypedObject.Field("Peb").Field("Ldr").GetPtr())) {

                ULONG64 Head = m_TypedObject.Field("Peb").Field("Ldr").Field("InLoadOrderModuleList").GetPointerTo().GetPtr();

                if (IsValid(Head)) {

                    ModuleIterator Dlls(Head);

                    for (Dlls.First(); !Dlls.IsDone(); Dlls.Next()) {

                        MsDllObject Object = Dlls.Current();

                        if (find(Nodes.rbegin(), Nodes.rend(), Object.m_ImageBase) != Nodes.rend()) {

                            break;
                        }

                        Nodes.push_back(Object.m_ImageBase);

                        m_DllList.push_back(Object);
                    }
                }
            }
        }
        catch (...) {

        }

        //
        // Wow64
        //
        
        try {

            if (m_TypedObject.HasField("Wow64Process") && (m_TypedObject.Field("Wow64Process").GetPtr() != 0)) {

                PEB_LDR_DATA PebLdrData = {0};
                LDR_DATA_TABLE_ENTRY32 LdrDataTableEntry = {0};
                ExtRemoteTyped Peb32("(nt!_PEB32 *)@$extin", m_TypedObject.Field("Wow64Process").GetPtr());

                if (IsValid(Peb32.GetPtr())) {

                    ULONG64 Ldr = Peb32.Field("Ldr").GetUlong();

                    if (g_Ext->m_Data->ReadVirtual(Ldr, &PebLdrData, sizeof(PebLdrData), NULL) != S_OK) goto CleanUp;

                    if (g_Ext->m_Data->ReadVirtual(PebLdrData.InLoadOrderModuleList.Flink, &LdrDataTableEntry, sizeof(LdrDataTableEntry), NULL) != S_OK) goto CleanUp;

                    Nodes.clear();

                    while (PebLdrData.InLoadOrderModuleList.Flink != LdrDataTableEntry.InLoadOrderLinks.Flink)
                    {
                        MsDllObject Object;

                        if (find(Nodes.rbegin(), Nodes.rend(), LdrDataTableEntry.InLoadOrderLinks.Flink) != Nodes.rend()) {

                            break;
                        }

                        Nodes.push_back(LdrDataTableEntry.InLoadOrderLinks.Flink);

                        if (LdrDataTableEntry.InLoadOrderLinks.Flink == 0) break;
                        if (LdrDataTableEntry.DllBase == 0) break;
                        if (LdrDataTableEntry.SizeOfImage == 0) break;

                        Object.mm_CcDllObject.IsWow64 = TRUE;

                        Object.m_ImageBase = LdrDataTableEntry.DllBase;
                        Object.m_ImageSize = LdrDataTableEntry.SizeOfImage;

                        if (g_Ext->m_Data->ReadVirtual(LdrDataTableEntry.BaseDllName.Buffer,
                                                       (PWSTR)&Object.mm_CcDllObject.DllName,
                                                       LdrDataTableEntry.BaseDllName.Length,
                                                       NULL) != S_OK) break;

                        if (g_Ext->m_Data->ReadVirtual(LdrDataTableEntry.FullDllName.Buffer,
                                                       (PWSTR)&Object.mm_CcDllObject.FullDllName,
                                                       LdrDataTableEntry.FullDllName.Length,
                                                       NULL) != S_OK) break;

                        m_DllList.push_back(Object);

                        if (g_Ext->m_Data->ReadVirtual(LdrDataTableEntry.InLoadOrderLinks.Flink, &LdrDataTableEntry, sizeof(LdrDataTableEntry), NULL) != S_OK) goto CleanUp;
                    }
                }
            }
        }
        catch (...) {

        }
    }

CleanUp:
    return Result;
}

BOOLEAN
MsProcessObject::GetHandles(
    ULONG64 InTableCode
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    None.

--*/
{
    BOOLEAN Result = FALSE;
    PWSTR ObjName = NULL;

    try {

        ULONG64 TableCode = 0;
    
        if (InTableCode) TableCode = InTableCode;
        else TableCode = m_TypedObject.Field("ObjectTable").Field("TableCode").GetPtr();

        ULONG Level = (ULONG)(TableCode & 3);
        ULONG64 Table = TableCode & ~3;

        ULONG PtrSize = g_Ext->m_PtrSize;

        ULONG HandleTableEntrySize = GetTypeSize("nt!_HANDLE_TABLE_ENTRY");

        ULONG HandleIndex = 4;

        ULONG BodyOffset = 0;
        GetFieldOffset("nt!_OBJECT_HEADER", "Body", &BodyOffset);

        BOOLEAN Is64Bit = (g_Ext->m_Control->IsPointer64Bit() == S_OK) ? TRUE : FALSE;

        USHORT SystemVersion = g_Ext->m_SystemVersion;
        ULONG64 ObjectPtrMask = (SystemVersion == _WIN32_WINNT_WIN8) ? 0xffffe00000000000 : 0xffff000000000000;

        switch (Level) {

        case 0:
        {
            for (UINT i = 1; i < (PAGE_SIZE / HandleTableEntrySize); i += 1, HandleIndex += 4) {

                HANDLE_OBJECT HandleObj = {0};
                ULONG64 Object;

                try {

                    ExtRemoteTyped TableEntry("(nt!_HANDLE_TABLE_ENTRY *)@$extin", Table + (i * HandleTableEntrySize));

                    if (SystemVersion < _WIN32_WINNT_WIN8) {

                        Object = (TableEntry.Field("Object").GetPtr() & ~7);
                    }
                    else {

                        Object = (TableEntry.Field("ObjectPointerBits").GetPtr());

                        if (Object) {

                            Object = Is64Bit ? (Object << 4) | ObjectPtrMask : DEBUG_EXTEND64(Object << 3);
                        }
                    }

                    if (!Object) continue;
                    Object += BodyOffset;

                    ObReadObject(Object, &HandleObj);
                    HandleObj.Handle = HandleIndex;

                    m_Handles.push_back(HandleObj);
                }
                catch (...) {

                }
            }

            break;
        }
        case 1:
        {
            for (UINT j = 0; j < (PAGE_SIZE / PtrSize); j += 1, HandleIndex += 4) {

                ULONG64 Ptr;
                if (ReadPointersVirtual(1, Table + (j * PtrSize), &Ptr) != S_OK) goto CleanUp;
                if (!Ptr) continue;

                for (UINT i = 1; i < (PAGE_SIZE / HandleTableEntrySize); i += 1, HandleIndex += 4) {

                    HANDLE_OBJECT HandleObj = {0};
                    ULONG64 Object;

                    try {

                        ExtRemoteTyped TableEntry("(nt!_HANDLE_TABLE_ENTRY *)@$extin", Ptr + (i * HandleTableEntrySize));

                        if (SystemVersion < _WIN32_WINNT_WIN8) {

                            Object = (TableEntry.Field("Object").GetPtr() & ~7);
                        }
                        else {

                            Object = (TableEntry.Field("ObjectPointerBits").GetPtr());

                            if (Object) {

                                Object = Is64Bit ? (Object << 4) | ObjectPtrMask : DEBUG_EXTEND64(Object << 3);
                            }
                        }

                        if (!Object) continue;
                        Object += BodyOffset;

                        ObReadObject(Object, &HandleObj);
                        HandleObj.Handle = HandleIndex;

                        m_Handles.push_back(HandleObj);
                    }
                    catch (...) {

                    }
                }
            }

            break;
        }
        case 2:
        {
            for (UINT k = 0; k < (PAGE_SIZE / PtrSize); k += 1) {

                ULONG64 Ptr1;
                if (ReadPointersVirtual(1, TableCode + (k * PtrSize), &Ptr1) != S_OK) goto CleanUp;
                if (!Ptr1) continue;

                for (UINT j = 0; j < (PAGE_SIZE / PtrSize); j += 1, HandleIndex += 4) {

                    ULONG64 Ptr;
                    if (ReadPointersVirtual(1, Ptr1 + (j * PtrSize), &Ptr) != S_OK) goto CleanUp;
                    if (!Ptr) continue;

                    for (UINT i = 1; i < (PAGE_SIZE / HandleTableEntrySize); i += 1, HandleIndex += 4) {

                        HANDLE_OBJECT HandleObj = {0};
                        ULONG64 Object;

                        try {

                            ExtRemoteTyped TableEntry("(nt!_HANDLE_TABLE_ENTRY *)@$extin", Ptr + (i * HandleTableEntrySize));

                            if (SystemVersion < _WIN32_WINNT_WIN8) {

                                Object = (TableEntry.Field("Object").GetPtr() & ~7);
                            }
                            else {

                                Object = (TableEntry.Field("ObjectPointerBits").GetPtr());

                                if (Object) {

                                    Object = Is64Bit ? (Object << 4) | ObjectPtrMask : DEBUG_EXTEND64(Object << 3);
                                }
                            }

                            if (!Object) continue;
                            Object += BodyOffset;

                            ObReadObject(Object, &HandleObj);
                            HandleObj.Handle = HandleIndex;

                            m_Handles.push_back(HandleObj);
                        }
                        catch (...) {

                        }
                    }
                }
            }

            break;
        }
        }

        Result = TRUE;
    }
    catch (...) {

    }

CleanUp:

    if (ObjName) free(ObjName);

    ReleaseObjectTypeTable();

    return Result;
}

VOID
MsProcessObject::Set(
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    None.

--*/
{
    ULONG64 Peb;
    ULONG64 Address;
    WCHAR UserName[MAX_PATH];
    WCHAR DomainName[MAX_PATH];

    RtlZeroMemory(&m_CcProcessObject, sizeof(m_CcProcessObject));

    try {

        m_CcProcessObject.ProcessId = m_TypedObject.Field("UniqueProcessId").GetPtr();
        m_CcProcessObject.ParentProcessId = m_TypedObject.Field("InheritedFromUniqueProcessId").GetPtr();
        m_CcProcessObject.Token = GetFastRefPointer(m_TypedObject.Field("Token.Object").GetPtr());
        m_ImageBase = m_TypedObject.Field("SectionBaseAddress").GetPtr();

        if ((m_ImageBase == 0ULL) && (m_CcProcessObject.ProcessId == 4)) {

            //
            // System Process
            //

            m_ImageBase = ExtNtOsInformation::GetNtDebuggerData(DEBUG_DATA_KernBase, "nt", 0);
        }

        m_CcProcessObject.ProcessObjectPtr = m_TypedObject.GetPtr();

        m_TypedObject.Field("ImageFileName").GetString((PTSTR)&m_CcProcessObject.ImageFileName, sizeof(m_CcProcessObject.ImageFileName));

        ExtRemoteTypedEx::GetUnicodeString(m_TypedObject.Field("SeAuditProcessCreationInfo.ImageFileName").Field("Name"),
                                           (PWSTR)&m_CcProcessObject.FullPath,
                                           sizeof(m_CcProcessObject.FullPath));

        m_CcProcessObject.CreateTime.QuadPart = m_TypedObject.Field("CreateTime.QuadPart").GetUlong64();
        m_CcProcessObject.ExitTime.QuadPart = m_TypedObject.Field("ExitTime.QuadPart").GetUlong64();

        Peb = m_TypedObject.Field("Peb").GetPtr();

        if (Peb)
        {
            ULONG64 ProcessParameters;

            SwitchContext();

            if (IsValid(Peb))
            {
                ProcessParameters = m_TypedObject.Field("Peb").Field("ProcessParameters").GetPtr();

                if (ProcessParameters && IsValid(ProcessParameters))
                {
                    ULONG EnvironmentSize;

                    m_CcProcessObject.DllPath = ExtRemoteTypedEx::GetUnicodeString2(m_TypedObject.Field("Peb").Field("ProcessParameters").Field("DllPath"));
                    REF_POINTER(m_CcProcessObject.DllPath);

                    m_CcProcessObject.ImagePathName = ExtRemoteTypedEx::GetUnicodeString2(m_TypedObject.Field("Peb").Field("ProcessParameters").Field("ImagePathName"));
                    REF_POINTER(m_CcProcessObject.ImagePathName);

                    m_CcProcessObject.CommandLine = ExtRemoteTypedEx::GetUnicodeString2(m_TypedObject.Field("Peb").Field("ProcessParameters").Field("CommandLine"));
                    REF_POINTER(m_CcProcessObject.CommandLine);

                    ULONG64 Environment = m_TypedObject.Field("Peb").Field("ProcessParameters").Field("Environment").GetPtr();
                    if (m_TypedObject.Field("Peb").Field("ProcessParameters").HasField("EnvironmentSize"))
                    {
                        EnvironmentSize = (ULONG)m_TypedObject.Field("Peb").Field("ProcessParameters").Field("EnvironmentSize").GetPtr();
                    }
                    else
                    {
                        EnvironmentSize = 0x1000;
                    }

                    m_EnvVarsBuffer = (PWSTR)calloc(EnvironmentSize, sizeof(BYTE));

                    if (m_EnvVarsBuffer) {

                        REF_POINTER(m_EnvVarsBuffer);

                        if (g_Ext->m_Data->ReadVirtual(Environment, m_EnvVarsBuffer, EnvironmentSize, NULL) == S_OK)
                        {
                            for (UINT Index = 0; Index < (EnvironmentSize / sizeof(WCHAR)); Index += 1)
                            {
                                ENV_VAR_OBJECT EnvVar = {0};

                                if (m_EnvVarsBuffer[Index] == L'\0') continue;

                                ULONG Len = (ULONG)wcslen(&m_EnvVarsBuffer[Index]);

                                EnvVar.Variable = &m_EnvVarsBuffer[Index];
                                m_EnvVars.push_back(EnvVar);
                                Index += Len;
                            }
                        }
                    }
                }
            }

            RestoreContext();
        }

        if (m_CcProcessObject.Token) {

            ExtRemoteTyped Token("(nt!_TOKEN *)@$extin", m_CcProcessObject.Token);

            Address = Token.Field("UserAndGroups").GetPtr();

            if (Address) {

                ExtRemoteTyped SidAndAttributes("(nt!_SID_AND_ATTRIBUTES *)@$extin", Address);

                Address = SidAndAttributes.Field("Sid").GetPtr();

                if (Address) {

                    ExtRemoteTyped Sid("(nt!_SID *)@$extin", Address);

                    ULONG SubAuthorityOffset = Sid.GetFieldOffset("SubAuthority");
                    UCHAR SubAuthorityCount = Sid.Field("SubAuthorityCount").GetUchar();

                    if (SubAuthorityOffset && SubAuthorityCount) {

                        ULONG BufferSize = SubAuthorityOffset + SubAuthorityCount * sizeof(ULONG);

                        PBYTE Buffer = (PBYTE)calloc(BufferSize, sizeof(BYTE));

                        if (Buffer) {

                            if (g_Ext->m_Data->ReadVirtual(Address, Buffer, BufferSize, NULL) == S_OK) {

                                ULONG UserNameLength = _countof(UserName);
                                ULONG DomainNameLength = _countof(DomainName);
                                SID_NAME_USE SidNameUse;

                                if (LookupAccountSidW(NULL, Buffer, UserName, &UserNameLength, DomainName, &DomainNameLength, &SidNameUse)) {

                                    StringCchPrintfW(m_CcProcessObject.UserName, _countof(m_CcProcessObject.UserName), L"%s\\%s", DomainName, UserName);
                                }
                            }

                            free(Buffer);
                        }
                    }
                }
            }

            if (!wcslen(m_CcProcessObject.UserName)) {

                ExtRemoteTypedEx::GetUnicodeString(Token.Field("LogonSession").Field("AccountName"), UserName, sizeof(UserName));
                ExtRemoteTypedEx::GetUnicodeString(Token.Field("LogonSession").Field("AuthorityName"), DomainName, sizeof(DomainName));

                StringCchPrintfW(m_CcProcessObject.UserName, _countof(m_CcProcessObject.UserName), L"%s\\%s", DomainName, UserName);
            }
        }

        if (!wcslen(m_CcProcessObject.UserName)) {

            if (GetEnvironmentVariableValue(DomainName, _countof(DomainName), L"USERDOMAIN") &&
                GetEnvironmentVariableValue(UserName, _countof(UserName), L"USERNAME")) {

                StringCchPrintfW(m_CcProcessObject.UserName, _countof(m_CcProcessObject.UserName), L"%s\\%s", DomainName, UserName);
            }
        }
    }
    catch (...) {

    }
}

MsDllObject::MsDllObject(
    const MsDllObject& other
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    None.

--*/
{
    *this = other;

    REF_POINTER(m_Image.Image);
}


MsDllObject::~MsDllObject(
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    None.

--*/
{
    Clear();
}

MsProcessObject::MsProcessObject(const MsProcessObject& other)
{
    REF_POINTER(other.m_CcProcessObject.CommandLine);
    REF_POINTER(other.m_CcProcessObject.DllPath);
    REF_POINTER(other.m_CcProcessObject.ImagePathName);

    REF_POINTER(other.m_Image.Image);

    REF_POINTER(other.m_EnvVarsBuffer);

    *this = other;
}

VOID
MsProcessObject::Release(
) throw(...)
/*++

Routine Description:

Description.

Arguments:

-

Return Value:

None.

--*/
{
    DEREF_POINTER(m_CcProcessObject.CommandLine);
    DEREF_POINTER(m_CcProcessObject.DllPath);
    DEREF_POINTER(m_CcProcessObject.ImagePathName);
    DEREF_POINTER(m_EnvVarsBuffer);
}

MsProcessObject::~MsProcessObject(
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    None.

--*/
{
    try
    {
        Release();
    }
    catch (...)
    {

    }

    Clear();
}

VOID
MsPEImageFile::Free(
    VOID
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    None.

--*/
{
    if (m_Image.Initialized)
    {
        DEREF_POINTER(m_Image.Image);
    }

    RtlZeroMemory(&m_Image, sizeof(m_Image));
}

ProcessArray
GetProcesses(
    _In_opt_ ULONG64 Pid,
    _In_ ULONG Flags
    )
/*++

Routine Description:

    Description.

Arguments:

     Pid - 
     Flags - 

Return Value:

    None.

--*/
{
    vector<ULONG64> Nodes;
    ProcessArray ProcessList;
    ProcessArray MmProcessList;
    ProcessIterator Processes;

    if (g_Verbose) g_Ext->Dml("[%s!%S!%d] Entering...\n", __FILE__, __FUNCTIONW__, __LINE__);

    try {

        for (Processes.First(); !Processes.IsDone(); Processes.Next())
        {
            MsProcessObject ProcObject = Processes.Current();

            if (find(Nodes.rbegin(), Nodes.rend(), ProcObject.m_CcProcessObject.ProcessObjectPtr) != Nodes.rend()) {

                break;
            }

            Nodes.push_back(ProcObject.m_CcProcessObject.ProcessObjectPtr);

            if (g_Verbose) g_Ext->Dml("[%s!%S!%d] Current process %s\n", __FILE__, __FUNCTIONW__, __LINE__, ProcObject.m_CcProcessObject.ImageFileName);

            if (!Pid || (Pid == ProcObject.m_CcProcessObject.ProcessId))
            {
                ProcessList.push_back(ProcObject);
            }
        }
    }
    catch (...) {

    }

    if (!Pid)
    {
        try {

            ProcessIterator MmProcesses(ProcessLinksMmType);

            Nodes.clear();

            for (MmProcesses.First(); !MmProcesses.IsDone(); MmProcesses.Next())
            {
                MsProcessObject ProcObject = MmProcesses.Current();

                if (find(Nodes.rbegin(), Nodes.rend(), ProcObject.m_CcProcessObject.ProcessObjectPtr) != Nodes.rend()) {

                    break;
                }

                Nodes.push_back(ProcObject.m_CcProcessObject.ProcessObjectPtr);

                MmProcessList.push_back(ProcObject);
            }
        }
        catch (...) {

        }

        //
        // Note: MmProcessList doesn't contain System process (PID = 4).
        // Retrieve hidden process.
        //
        for each (MsProcessObject MmProcObject in MmProcessList)
        {
            BOOLEAN Found = FALSE;

            for each (MsProcessObject ProcObject in ProcessList)
            {
                if (MmProcObject.m_CcProcessObject.ProcessId == ProcObject.m_CcProcessObject.ProcessId) Found = TRUE;
            }

            if (Found == FALSE)
            {
                //
                // MmObject can't be founded. It means it had been removed from the ActiveProcess linked-list (DKOM Attack).
                //
                MmProcObject.m_CcProcessObject.HiddenProcess = TRUE;

                ProcessList.push_back(MmProcObject);
            }
        }
    }


    //
    // Security Tokens, Protected, BreakOnTermination
    //

    //
    // We initialize the structure (allocate buffer etc.), once we don't need any further push_back() in the vector.
    // to avoid memory leaks etc. Because of the destructor.
    //
    //
    // Process + Dlls
    //
    for (ULONG i = 0; i < ProcessList.size(); i++)
    {
        BOOLEAN Initialized = FALSE;
        MsProcessObject& ProcObj = ProcessList[i];

        g_Ext->ExecuteSilent(".process /p /r 0x%I64X", ProcObj.m_CcProcessObject.ProcessObjectPtr);

        Initialized = ProcObj.GetInfoFull();

        if ((Flags & PROCESS_DLLS_FLAG) || (Flags & PROCESS_IMPORTS_FLAG)) {
            if (g_Verbose) g_Ext->Dml("[%s!%S!%d] Get DLL list for %s (Pid=0x%llx)\n", __FILE__, __FUNCTIONW__, __LINE__, ProcObj.m_CcProcessObject.ImageFileName, ProcObj.m_CcProcessObject.ProcessId);
            ProcObj.GetDlls();
        }

        if (Initialized) {

            if (Flags & PROCESS_EXPORTS_FLAG) {

                ProcObj.RtlGetExports();
            }

            if (Flags & PROCESS_IMPORTS_FLAG) {

                ProcObj.RtlGetImports(ProcObj.m_DllList);
            }
        }

        if (Flags & PROCESS_DLLS_FLAG)
        {
            for (ULONG j = 0; j < ProcObj.m_DllList.size(); j++)
            {
                MsDllObject& DllObj = ProcObj.m_DllList[j];

                if (g_Verbose) {

                    g_Ext->Dml("[%s!%S!%d] Get DLL information for %s!%S\n", __FILE__, __FUNCTIONW__, __LINE__, ProcObj.m_CcProcessObject.ImageFileName, DllObj.mm_CcDllObject.DllName);
                }

                DllObj.GetInfoFull();

                if (Flags & PROCESS_DLL_EXPORTS_FLAG) {

                    DllObj.RtlGetExports();
                }

                if (Flags & PROCESS_DLL_IMPORTS_FLAG) {

                    DllObj.RtlGetImports(ProcObj.m_DllList);
                }

                DllObj.Free();
            }
        }

        ProcObj.Free();
    }

    //
    // Strings
    //
    return ProcessList;
}

MsProcessObject
FindProcessByName(
    _In_ PSTR ProcessName
    )
/*++

Routine Description:

    Description.

Arguments:

     ProcessName -

Return Value:

    None.

--*/
{
    vector<ULONG64> Nodes;

    try {

        ProcessIterator Processes;

        for (Processes.First(); !Processes.IsDone(); Processes.Next()) {

            MsProcessObject ProcessObject = Processes.Current();

            if (0 == _stricmp(ProcessObject.m_CcProcessObject.ImageFileName, ProcessName)) {

                //
                // Save, and change the current process.
                //

                ProcessObject.SwitchContext();

                ProcessObject.GetInfoFull();

                ProcessObject.RestoreContext();

                return ProcessObject;
            }

            if (find(Nodes.rbegin(), Nodes.rend(), ProcessObject.m_CcProcessObject.ProcessObjectPtr) != Nodes.rend()) {

                break;
            }

            Nodes.push_back(ProcessObject.m_CcProcessObject.ProcessObjectPtr);
        }
    }
    catch (...) {

    }

    return MsProcessObject();
}

MsProcessObject
FindProcessByPid(
    _In_ ULONG64 ProcessId
    )
/*++

Routine Description:

    Description.

Arguments:

     ProcessId - 

Return Value:

    None.

--*/
{
    vector<ULONG64> Nodes;

    try {

        ProcessIterator Processes;

        for (Processes.First(); !Processes.IsDone(); Processes.Next()) {

            MsProcessObject ProcessObject = Processes.Current();

            if (ProcessObject.m_CcProcessObject.ProcessId == ProcessId) {

                //
                // Save, and change the current process.
                //

                ProcessObject.SwitchContext();

                ProcessObject.GetInfoFull();

                ProcessObject.RestoreContext();

                return ProcessObject;
            }

            if (find(Nodes.rbegin(), Nodes.rend(), ProcessObject.m_CcProcessObject.ProcessObjectPtr) != Nodes.rend()) {

                break;
            }

            Nodes.push_back(ProcessObject.m_CcProcessObject.ProcessObjectPtr);
        }
    }
    catch (...) {

    }

    return MsProcessObject();
}

BOOLEAN
MsProcessObject::MmGetFirstVad(
    _Inout_ PVAD_OBJECT VadInfo
)
{
    ULONG64 First = 0, LeftChild = 0;
    ExtRemoteTyped MmVad;
    vector<ULONG64> Nodes;

    try {

        if (m_TypedObject.Field("VadRoot").GetTypeSize() > GetPtrSize())
        {
            First = m_TypedObject.Field("VadRoot.BalancedRoot.RightChild").GetPtr();
            if (g_Verbose) g_Ext->Dml("[%s!%S!%d] VadRoot.BalancedRoot.RightChild = 0x%llx\n", __FILE__, __FUNCTIONW__, __LINE__, First);
            if (!First) return FALSE;
        }
        else
        {
            if (m_TypedObject.Field("VadRoot").HasField("Root")) {
                First = m_TypedObject.Field("VadRoot").Field("Root").GetPtr();
            } else {
                First = m_TypedObject.Field("VadRoot").GetPtr();
            }
            if (g_Verbose) g_Ext->Dml("[%s!%S!%d] VadRoot = 0x%llx\n", __FILE__, __FUNCTIONW__, __LINE__, First);
            if (!First) return FALSE;
        }

        while (First)
        {
            LeftChild = First;

            if (find(Nodes.rbegin(), Nodes.rend(), LeftChild) != Nodes.rend()) {

                return FALSE;
            }

            Nodes.push_back(LeftChild);

            MmVad = ExtRemoteTyped("(nt!_MMVAD *)@$extin", LeftChild);

            if (MmVad.HasField("Core")) {

                if (g_Verbose) g_Ext->Dml("[%s!%S!%d] [Left] LeftChild = 0x%llx\n", __FILE__, __FUNCTIONW__, __LINE__, LeftChild);

                if (MmVad.Field("Core").Field("VadNode").HasField("LeftChild")) {

                    First = MmVad.Field("Core").Field("VadNode").Field("LeftChild").GetPtr();
                }
                else {

                    First = MmVad.Field("Core").Field("VadNode").Field("Left").GetPtr();
                }
            }
            else {

                First = MmVad.Field("LeftChild").GetPtr();
            }

            if (g_Verbose) g_Ext->Dml("[%s!%S!%d] VadRoot.First = 0x%llx\n", __FILE__, __FUNCTIONW__, __LINE__, First);
        }

        First = LeftChild;
        VadInfo->FirstNode = First;
        VadInfo->CurrentNode = VadInfo->FirstNode;

        MmVad = ExtRemoteTyped("(nt!_MMVAD *)@$extin", VadInfo->CurrentNode);

        if (MmVad.HasField("Core")) {

            VadInfo->StartingVpn = MmVad.Field("Core").Field("StartingVpn").GetUlong();
            VadInfo->EndingVpn = MmVad.Field("Core").Field("EndingVpn").GetUlong();

            VadInfo->VadType = (ULONG)MmVad.Field("Core").Field("u.VadFlags.VadType").GetUlong();
            VadInfo->Protection = (ULONG)MmVad.Field("Core").Field("u.VadFlags.Protection").GetUlong();
            VadInfo->PrivateMemory = (ULONG)MmVad.Field("Core").Field("u.VadFlags.PrivateMemory").GetUlong();
            VadInfo->MemCommit = (ULONG)MmVad.Field("Core").Field("u1.VadFlags1.MemCommit").GetUlong();

            if (MmVad.HasField("Core.StartingVpnHigh") && MmVad.HasField("Core.EndingVpnHigh")) {

                ULONG64 StartingVpnHigh;
                ULONG64 EndingVpnHigh;

                StartingVpnHigh = MmVad.Field("Core").Field("StartingVpnHigh").GetUchar();
                EndingVpnHigh = MmVad.Field("Core").Field("EndingVpnHigh").GetUchar();

                VadInfo->StartingVpn = VadInfo->StartingVpn | (StartingVpnHigh << 32);
                VadInfo->EndingVpn = VadInfo->EndingVpn | (EndingVpnHigh << 32);
            }
        }
        else {
            VadInfo->StartingVpn = MmVad.Field("StartingVpn").GetPtr();
            VadInfo->EndingVpn = MmVad.Field("EndingVpn").GetPtr();

            if (MmVad.HasField("u.VadFlags.VadType"))
            {
                VadInfo->VadType = (ULONG)MmVad.Field("u.VadFlags.VadType").GetPtr();
            }
            VadInfo->Protection = (ULONG)MmVad.Field("u.VadFlags.Protection").GetPtr();
            VadInfo->PrivateMemory = (ULONG)MmVad.Field("u.VadFlags.PrivateMemory").GetPtr();
            VadInfo->MemCommit = (ULONG)MmVad.Field("u.VadFlags.MemCommit").GetPtr();
        }

        VadInfo->EndingVpn += 1;

        if (MmVad.HasField("ControlArea"))
        {
            // NT 5
            ULONG64 ControlArea = 0;
            ULONG64 FilePointer = 0;

            ControlArea = MmVad.Field("ControlArea").GetPtr();
            if (ControlArea && IsValid(ControlArea)) FilePointer = MmVad.Field("ControlArea").Field("FilePointer").GetPtr();

            VadInfo->FileObject = FilePointer;
        }
        else if (MmVad.HasField("Subsection"))
        {
            ULONG64 Subsection = MmVad.Field("Subsection").GetPtr();
            if (Subsection && !VadInfo->PrivateMemory)
            {
                ExtRemoteTyped MmSubSection("(nt!_SUBSECTION *)@$extin", Subsection);

                if (MmSubSection.Field("ControlArea").GetPtr())
                {
                    VadInfo->FileObject = MmSubSection.Field("ControlArea").Field("FilePointer").Field("Object").GetPtr();
                }
            }
        }

        if (GetPtrSize() == sizeof(ULONG64))  VadInfo->FileObject &= ~0xF;
        else if (GetPtrSize() == sizeof(ULONG32)) VadInfo->FileObject &= ~0x7;
    }
    catch (...) {

    }

    return TRUE;
}

BOOLEAN
MsProcessObject::MmGetNextVad(
    _Inout_ PVAD_OBJECT VadInfo
)
/*++

Routine Description:

    Description.

Arguments:

     VadInfo - 

Return Value:

    BOOLEAN.

--*/
{
    ULONG64 Parent, Next;
    ULONG64 LeftChild = 0, RightChild;
    ExtRemoteTyped MmVad;
    vector<ULONG64> Nodes;

    try {

        if (g_Verbose) g_Ext->Dml("[%s!%S!%d] Entering...\n", __FILE__, __FUNCTIONW__, __LINE__);

        VadInfo->StartingVpn = 0;
        VadInfo->EndingVpn = 0;
        VadInfo->FileObject = 0;

        if (!VadInfo->CurrentNode) {

            if (g_Verbose) g_Ext->Dml("[%s!%S!%d] CurrentNode is null. Exiting.\n", __FILE__, __FUNCTIONW__, __LINE__);
            return FALSE;
        }

        Next = VadInfo->CurrentNode;

        MmVad = ExtRemoteTyped("(nt!_MMVAD *)@$extin", VadInfo->CurrentNode);

        if (MmVad.HasField("Core")) {

            if (MmVad.Field("Core").Field("VadNode").HasField("RightChild")) {

                RightChild = MmVad.Field("Core").Field("VadNode").Field("RightChild").GetPtr();
            }
            else {

                RightChild = MmVad.Field("Core").Field("VadNode").Field("Right").GetPtr();
            }
        }
        else {

            RightChild = MmVad.Field("RightChild").GetPtr();
        }

        if (!RightChild)
        {
            if (g_Verbose) g_Ext->Dml("[%s!%S!%d] Looking for parent node.\n", __FILE__, __FUNCTIONW__, __LINE__);

            while (TRUE)
            {
                if (MmVad.HasField("u1.Parent"))
                {
                    Parent = MmVad.Field("u1.Parent").GetPtr();
                }
                else if (MmVad.HasField("Parent"))
                {
                    Parent = MmVad.Field("Parent").GetPtr();
                }
                else if (MmVad.HasField("Core.VadNode.u1.Parent")) {

                    Parent = MmVad.Field("Core").Field("VadNode.u1.Parent").GetPtr();
                }
                else if (MmVad.HasField("Core.VadNode.ParentValue")) {

                    Parent = MmVad.Field("Core").Field("VadNode.ParentValue").GetPtr();
                }
                else return FALSE;

                //
                // Sanitize
                //
                Parent &= ~0x3;
                if (!Parent) return FALSE;

                if (Parent == Next)
                {
                    VadInfo->CurrentNode = 0;
                    return FALSE;
                }

                if (g_Verbose) g_Ext->Dml("[%s!%S!%d] Trying to access VadInfo->CurrentNode = 0x%llx\n",
                    __FILE__, __FUNCTIONW__, __LINE__, VadInfo->CurrentNode);

                MmVad = ExtRemoteTyped("(nt!_MMVAD *)@$extin", Parent);

                if (MmVad.HasField("Core")) {

                    if (MmVad.Field("Core").Field("VadNode").HasField("LeftChild")) {

                        LeftChild = MmVad.Field("Core").Field("VadNode").Field("LeftChild").GetPtr();
                    }
                    else {

                        LeftChild = MmVad.Field("Core").Field("VadNode").Field("Left").GetPtr();
                    }
                }
                else {

                    LeftChild = MmVad.Field("LeftChild").GetPtr();
                }

                if (LeftChild == Next)
                {
                    VadInfo->CurrentNode = Parent;
                    break;
                }

                if (find(Nodes.rbegin(), Nodes.rend(), Parent) != Nodes.rend()) {

                    return FALSE;
                }

                Nodes.push_back(Parent);

                Next = Parent;
            }
        }
        else
        {
            Next = RightChild;

            while (Next)
            {
                LeftChild = Next;
                if (g_Verbose) g_Ext->Dml("[%s!%S!%d] Trying to access [0x%llX] Node\n",
                    __FILE__, __FUNCTIONW__, __LINE__, LeftChild);

                if (!IsValid(LeftChild)) {
                    if (g_Verbose) g_Ext->Err("[%s!%S!%d] Unable to get LeftChild of nt!_MMVAD_SHORT at 0x%llX\n", __FILE__, __FUNCTIONW__, __LINE__, LeftChild);
                    return FALSE;
                }

                MmVad = ExtRemoteTyped("(nt!_MMVAD *)@$extin", LeftChild);

                if (MmVad.HasField("Core")) {

                    if (g_Verbose) g_Ext->Dml("[%s!%S!%d] Trying to access [0x%llX].Core.VadNode.Left\n", __FILE__, __FUNCTIONW__, __LINE__, LeftChild);

                    if (MmVad.Field("Core").Field("VadNode").HasField("LeftChild")) {

                        Next = MmVad.Field("Core").Field("VadNode").Field("LeftChild").GetPtr();
                    }
                    else {

                        Next = MmVad.Field("Core").Field("VadNode").Field("Left").GetPtr();
                    }
                }
                else {

                    Next = MmVad.Field("LeftChild").GetPtr();
                }

                if (find(Nodes.rbegin(), Nodes.rend(), Next) != Nodes.rend()) {

                    return FALSE;
                }

                Nodes.push_back(Next);
            }

            VadInfo->CurrentNode = LeftChild;

            if (!LeftChild) return FALSE;
        }

        if (g_Verbose) g_Ext->Dml("[%s!%S!%d] Current Node [0x%llX]\n", __FILE__, __FUNCTIONW__, __LINE__, VadInfo->CurrentNode);

        MmVad = ExtRemoteTyped("(nt!_MMVAD *)@$extin", VadInfo->CurrentNode);

        if (MmVad.HasField("Core")) {

            VadInfo->StartingVpn = MmVad.Field("Core").Field("StartingVpn").GetUlong();
            VadInfo->EndingVpn = MmVad.Field("Core").Field("EndingVpn").GetUlong();

            VadInfo->VadType = (ULONG)MmVad.Field("Core").Field("u.VadFlags.VadType").GetUlong();
            VadInfo->Protection = (ULONG)MmVad.Field("Core").Field("u.VadFlags.Protection").GetUlong();
            VadInfo->PrivateMemory = (ULONG)MmVad.Field("Core").Field("u.VadFlags.PrivateMemory").GetUlong();
            VadInfo->MemCommit = (ULONG)MmVad.Field("Core").Field("u1.VadFlags1.MemCommit").GetUlong();

            if (MmVad.HasField("Core.StartingVpnHigh") && MmVad.HasField("Core.EndingVpnHigh")) {

                ULONG64 StartingVpnHigh;
                ULONG64 EndingVpnHigh;

                StartingVpnHigh = MmVad.Field("Core").Field("StartingVpnHigh").GetUchar();
                EndingVpnHigh = MmVad.Field("Core").Field("EndingVpnHigh").GetUchar();

                VadInfo->StartingVpn = VadInfo->StartingVpn | (StartingVpnHigh << 32);
                VadInfo->EndingVpn = VadInfo->EndingVpn | (EndingVpnHigh << 32);
            }
        }
        else {
            VadInfo->StartingVpn = MmVad.Field("StartingVpn").GetPtr();
            VadInfo->EndingVpn = MmVad.Field("EndingVpn").GetPtr();

            if (MmVad.HasField("u.VadFlags.VadType"))
            {
                VadInfo->VadType = (ULONG)MmVad.Field("u.VadFlags.VadType").GetPtr();
            }
            VadInfo->Protection = (ULONG)MmVad.Field("u.VadFlags.Protection").GetPtr();
            VadInfo->PrivateMemory = (ULONG)MmVad.Field("u.VadFlags.PrivateMemory").GetPtr();
            VadInfo->MemCommit = (ULONG)MmVad.Field("u.VadFlags.MemCommit").GetPtr();
        }
        VadInfo->EndingVpn += 1;

        if (MmVad.HasField("ControlArea"))
        {
            // NT 5
            ULONG64 ControlArea = 0;
            ULONG64 FilePointer = 0;

            ControlArea = MmVad.Field("ControlArea").GetPtr();
            if (ControlArea && IsValid(ControlArea)) FilePointer = MmVad.Field("ControlArea").Field("FilePointer").GetPtr();

            VadInfo->FileObject = FilePointer;
        }
        else if (MmVad.HasField("Subsection"))
        {
            ULONG64 Subsection = MmVad.Field("Subsection").GetPtr();
            if (Subsection && !VadInfo->PrivateMemory)
            {
                ExtRemoteTyped MmSubSection("(nt!_SUBSECTION *)@$extin", Subsection);

                if (MmSubSection.Field("ControlArea").GetPtr())
                {
                    VadInfo->FileObject = MmSubSection.Field("ControlArea").Field("FilePointer").Field("Object").GetPtr();
                }
            }
        }

        if (GetPtrSize() == sizeof(ULONG64))  VadInfo->FileObject &= ~0xF;
        else if (GetPtrSize() == sizeof(ULONG32)) VadInfo->FileObject &= ~0x7;

        if (g_Verbose) g_Ext->Dml("[%s!%S!%d] Leaving.\n", __FILE__, __FUNCTIONW__, __LINE__);
    }
    catch (...) {

    }

    return TRUE;
}

BOOLEAN
MsProcessObject::MmGetVads(
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    BOOLEAN.

--*/
{
    VAD_OBJECT VadInfo = {0};
    vector<ULONG64> Nodes;
    BOOLEAN Result;

    Result = MmGetFirstVad(&VadInfo);

    while (Result) {

        if (find(Nodes.rbegin(), Nodes.rend(), VadInfo.CurrentNode) != Nodes.rend()) {

            break;
        }

        Nodes.push_back(VadInfo.CurrentNode);

        m_Vads.push_back(VadInfo);

        Result = MmGetNextVad(&VadInfo);
    }

    return TRUE;
}

BOOLEAN
MsProcessObject::GetThreads(
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    BOOLEAN.

--*/
{
    vector<ULONG64> Nodes;
    ULONG64 ThreadListHead = m_TypedObject.Field("ThreadListHead").GetPointerTo().GetPtr();

    ExtRemoteTypedList ThreadList(ThreadListHead, "nt!_ETHREAD", "ThreadListEntry");

    try {

        for (ThreadList.StartHead(); ThreadList.HasNode(); ThreadList.Next()) {

            THREAD_OBJECT ThreadObject = {0};

            ThreadObject.ObjectPtr = ThreadList.GetNodeOffset();

            if (find(Nodes.rbegin(), Nodes.rend(), ThreadObject.ObjectPtr) != Nodes.rend()) {

                break;
            }

            Nodes.push_back(ThreadObject.ObjectPtr);

            if (ThreadList.GetTypedNode().Field("Tcb.Header.Type").GetUchar() != 6) {

                break;
            }

            ThreadObject.CrossThreadFlags = ThreadList.GetTypedNode().Field("CrossThreadFlags").GetUlong();

            if (ThreadList.GetTypedNode().HasField("Tcb.ThreadFlags")) {

                ThreadObject.ThreadFlags = ThreadList.GetTypedNode().Field("Tcb.ThreadFlags").GetUlong();
            }

            ThreadObject.StartAddress = ThreadList.GetTypedNode().Field("StartAddress").GetPtr();
            ThreadObject.Win32StartAddress = ThreadList.GetTypedNode().Field("Win32StartAddress").GetPtr();

            if (!ThreadObject.Win32StartAddress) {

                ThreadObject.Win32StartAddress = ThreadObject.StartAddress;
            }

            ThreadObject.ProcessId = ThreadList.GetTypedNode().Field("Cid.UniqueProcess").GetPtr();
            ThreadObject.ThreadId = ThreadList.GetTypedNode().Field("Cid.UniqueThread").GetPtr();

            ThreadObject.CreateTime.QuadPart = ThreadList.GetTypedNode().Field("CreateTime.QuadPart").GetUlong64();
            ThreadObject.ExitTime.QuadPart = ThreadList.GetTypedNode().Field("ExitTime.QuadPart").GetUlong64();

            if (ThreadList.GetTypedNode().HasField("Tcb.ServiceTable")) {

                ThreadObject.ServiceTable = ThreadList.GetTypedNode().Field("Tcb.ServiceTable").GetPtr();
            }

            m_Threads.push_back(ThreadObject);
        }
    }
    catch (...) {

    }

    return TRUE;
}

```

`SwishDbgExt/Process.h`:

```h
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Process.h

Abstract:

    - ExtRemoteData Pointer(GetExpression("'htsxxxxx!gRingBuffer"), m_PtrSize); // <<< works just fine

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#ifndef __PROCESS_H__
#define __PROCESS_H__

#define DEREF_POINTER(Ptr) { \
if (Ptr && (g_References[Ptr] >= 1)) \
    { \
        g_References[Ptr] -= 1; \
        /* g_Ext->Dml("(%s:%d::%s) [%d] ", __FILE__, __LINE__, __FUNCTION__, g_References[Ptr]); */ \
        if (g_References[Ptr] == 0) \
        {\
            /* g_Ext->Dml("free(Ptr) = %p", Ptr); */ \
            free(Ptr); \
        } \
        Ptr = NULL; \
        /* g_Ext->Dml("\n"); */\
    } \
}

#define REF_POINTER(Ptr) { \
if (Ptr) \
    { \
        if (g_References.find(Ptr) == g_References.end()) \
        { \
            g_References.insert(pair<PVOID, ULONG>(Ptr, 1)); \
        } \
        else \
        { \
            g_References[Ptr] += 1; \
        } \
        /* g_Ext->Dml("(%s:%d::%s) [%d] Ref(%p) \n", __FILE__, __LINE__, __FUNCTION__, g_References[Ptr], Ptr); */ \
    } \
}

#define MM_READONLY            1
#define MM_EXECUTE             2
#define MM_EXECUTE_READ        3
#define MM_READWRITE           4  // bit 2 is set if this is writable.
#define MM_WRITECOPY           5
#define MM_EXECUTE_READWRITE   6
#define MM_EXECUTE_WRITECOPY   7

#define PROCESS_DLLS_FLAG            (1 << 0)
#define PROCESS_EXPORTS_FLAG         (1 << 1)
#define PROCESS_DLL_EXPORTS_FLAG     (1 << 2)
#define PROCESS_SCAN_MALICIOUS_FLAG  (1 << 3)
#define PROCESS_HANDLES_FLAG         (1 << 4)
#define PROCESS_VADS_FLAG            (1 << 5)
#define PROCESS_THREADS_FLAG         (1 << 6)
#define PROCESS_ENVVAR_FLAG          (1 << 7)
#define PROCESS_IMPORTS_FLAG         (1 << 8)
#define PROCESS_DLL_IMPORTS_FLAG     (1 << 9)

#define OBP_CREATOR_INFO_BIT 0x1
#define OBP_NAME_INFO_BIT 0x2
#define OBP_HANDLE_INFO_BIT 0x4
#define OBP_QUOTA_INFO_BIT 0x8
#define OBP_PROCESS_INFO_BIT 0x10

typedef struct _THREAD_OBJECT {
    ULONG64 StartAddress;
    ULONG64 ServiceTable;

    ULONG ThreadFlags;
    ULONG CrossThreadFlags;
    ULONG64 OwningProcess;
    ULONG64 AttachedProcess;

    ULONG64 ProcessId;
    ULONG64 ThreadId;

    LARGE_INTEGER CreateTime;
    LARGE_INTEGER ExitTime;

    ULONG64 Win32StartAddress;
    ULONG64 ObjectPtr;
} THREAD_OBJECT, *PTHREAD_OBJECT;

typedef struct _HANDLE_OBJECT {
    ULONG Handle;
    WCHAR Name[MAX_PATH];
    WCHAR Type[32];
    ULONG ObjectTypeIndex;
    ULONG64 ObjectPtr;
    ULONG64 ObjectKcb; // Only for Keys
    ULONG64 CreatorUniquePid;
} HANDLE_OBJECT, *PHANDLE_OBJECT;

typedef struct _VAD_OBJECT {
    ULONG64 ProcessObject;
    ULONG64 FirstNode;
    ULONG64 CurrentNode;
    ULONG64 StartingVpn;
    ULONG64 EndingVpn;

    ULONG32 VadType;
    ULONG32 Protection;
    ULONG32 PrivateMemory;
    ULONG32 MemCommit;

    ULONG64 FileObject;
} VAD_OBJECT, *PVAD_OBJECT;

class ModuleIterator {
public:
    ModuleIterator(ULONG64 ModuleHead);
    BOOLEAN IsDone(VOID);
    VOID First(VOID);
    ExtRemoteTyped Current(VOID);
    // ExtRemoteTyped CurrentNode(VOID);
    VOID Next(VOID);
    VOID Prev(VOID);

private:
    ULONG64 m_ModuleListHead;
    ExtRemoteTypedList m_ModuleList;
};

typedef enum _PROCESS_LINKS_TYPE {
    ProcessLinksDefaultType = 0,
    ProcessLinksMmType = 1
} PROCESS_LINKS_TYPE;

class ProcessIterator {
public:
    ProcessIterator(PROCESS_LINKS_TYPE Type = ProcessLinksDefaultType);
    BOOLEAN IsDone(VOID);
    VOID First(VOID);
    ExtRemoteTyped Current(VOID);
    ExtRemoteTyped CurrentNode(VOID);
    VOID Next(VOID);
    VOID Prev(VOID);

private:
    PROCESS_LINKS_TYPE m_LinksType;
    ULONG64 m_ProcessHead;
    ExtRemoteTypedList m_ProcessList;
};

class MsDllObject : public MsPEImageFile {
public:
    typedef struct DLL_INFO {
        IMAGE_TYPE ImageType; // Always in first position.

        BOOLEAN IsWow64;

        ULONG64 ProcessOwner;
        ULONG64 DirectoryTableBase;
        ULONG64 DllEntry;

        LARGE_INTEGER LoadTime;
        WCHAR DllName[MAX_PATH + 1];
        WCHAR FullDllName[MAX_PATH + 1];
    } DLL_INFO, *PDLL_INFO;

    MsDllObject()
    {
        Clear();
    }

    MsDllObject(ExtRemoteTyped Object)
    {
        Clear();
        m_TypedObject = Object;
        Set();
    }
    ~MsDllObject();

    MsDllObject::MsDllObject(const MsDllObject& other);

    VOID Set();

    //BOOLEAN Init(VOID);

    DLL_INFO mm_CcDllObject;

    ExtRemoteTyped m_TypedObject;
};

class MsProcessObject : public MsPEImageFile {
public:
    typedef struct _ENV_VAR_OBJECT {
        LPWSTR Variable;
    } ENV_VAR_OBJECT, *PENV_VAR_OBJECT;

    typedef struct _CACHED_PROCESS_OBJECT {
        IMAGE_TYPE ImageType; // Always in first position.

        ULONG64 ProcessObjectPtr;

        LARGE_INTEGER CreateTime;
        LARGE_INTEGER ExitTime;

        ULONG64 ParentProcessId;
        ULONG64 ProcessId;

        ULONG64 Token;

        ULONG64 VirtualSize;

        //
        // Additional information
        //
        BOOLEAN HiddenProcess;

        ULONG32 ProtectedProcess;
        ULONG32 BreakOnTermination;

        CHAR ImageFileName[16];
        WCHAR FullPath[MAX_PATH + 1];
        WCHAR UserName[MAX_PATH];

        LPWSTR CommandLine;
        WCHAR WindowTitle[256];
        LPWSTR DllPath;
        LPWSTR ImagePathName;
    } CACHED_PROCESS_OBJECT, *PCACHED_PROCESS_OBJECT;

    MsProcessObject()
    {
        Clear();
    }

    /*
    MsProcessObject(MsProcessObject &other)
    {
        m_DllList = other.m_DllList;
        m_CcProcessObject = other.m_CcProcessObject;
        m_Image = other.m_Image;
        m_ProcessDataOffset = other.m_ProcessDataOffset;
        m_TypedObject = other.m_TypedObject;
    }*/
    MsProcessObject(const MsProcessObject& other); // copy constructor

    MsProcessObject(ExtRemoteTyped Object)
    {
        Clear();
        m_EnvVarsBuffer = NULL;
        m_TypedObject = Object;
        Set();
    }
    ~MsProcessObject();

    VOID Set();
    VOID Release() throw(...);

    BOOLEAN GetDlls();
    BOOLEAN GetHandles(ULONG64 InTableCode);

    BOOLEAN
    MsProcessObject::GetEnvironmentVariableValue(
        _In_ PWSTR Buffer,
        _In_ SIZE_T BufferSize,
        _In_ PWSTR VariableName
    );

    BOOLEAN SwitchContext(VOID);
    BOOLEAN RestoreContext(VOID);

    BOOLEAN MmGetFirstVad(
        PVAD_OBJECT VadInfo
    );
    BOOLEAN MmGetNextVad(
        PVAD_OBJECT VadInfo
    );
    BOOLEAN MmGetVads();
    BOOLEAN GetThreads();

    CACHED_PROCESS_OBJECT m_CcProcessObject;

    vector<ENV_VAR_OBJECT> m_EnvVars;

    vector<MsDllObject> m_DllList;
    vector<HANDLE_OBJECT> m_Handles;
    vector<VAD_OBJECT> m_Vads;
    vector<THREAD_OBJECT> m_Threads;

    ULONG64 m_ProcessDataOffset;

    ExtRemoteTyped m_TypedObject;
    LPWSTR m_EnvVarsBuffer;
};

typedef vector<MsProcessObject> ProcessArray;

ProcessArray
GetProcesses(
    _In_opt_ ULONG64 Pid,
    _In_ ULONG Flags
    );

MsProcessObject
FindProcessByName(
    _In_ PSTR ProcessName
    );

MsProcessObject
FindProcessByPid(
    _In_ ULONG64 ProcessId
    );

extern map<PVOID, ULONG> g_References;

#endif
```

`SwishDbgExt/Registry.cpp`:

```cpp
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Registry.cpp

Abstract:

    - 

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#include "stdafx.h"
#include "SwishDbgExt.h"


vector<HIVE_OBJECT> g_Hives;


PWSTR
GetRegistryValueTypeName(
    _In_ ULONG ValueType
    )     
{
    switch (ValueType) {

    case REG_NONE:                          return L"REG_NONE";
    case REG_SZ:                            return L"REG_SZ";
    case REG_EXPAND_SZ:                     return L"REG_EXPAND_SZ";
    case REG_BINARY:                        return L"REG_BINARY";
    case REG_DWORD:                         return L"REG_DWORD";
    case REG_DWORD_BIG_ENDIAN:              return L"REG_DWORD_BIG_ENDIAN";
    case REG_LINK:                          return L"REG_LINK";
    case REG_MULTI_SZ:                      return L"REG_MULTI_SZ";
    case REG_RESOURCE_LIST:                 return L"REG_RESOURCE_LIST";
    case REG_FULL_RESOURCE_DESCRIPTOR:      return L"REG_FULL_RESOURCE_DESCRIPTOR";
    case REG_RESOURCE_REQUIREMENTS_LIST:    return L"REG_RESOURCE_REQUIREMENTS_LIST";
    case REG_QWORD:                         return L"REG_QWORD";
    default:                                return L"Unknown";
    }
}

vector<KEY_NAME>
GetKeysNames(
    _In_ PWSTR FullKeyPath
    )
{
    vector<KEY_NAME> SubKeysNames;
    KEY_NAME KeyName;
    PWSTR CurrentName;
    PWSTR RemainingName;
    ULONG Length;

    CurrentName = FullKeyPath;
    RemainingName = FullKeyPath;

    while (*CurrentName) {

        CurrentName++;
        RemainingName++;

        while (*RemainingName && (*RemainingName != L'\\')) {

            RemainingName++;
        }

        Length = (ULONG)(RemainingName - CurrentName);

        if (Length) {

            StringCchCopyNW(KeyName.Name, _countof(KeyName.Name), CurrentName, Length);

            SubKeysNames.push_back(KeyName);
        }

        CurrentName = RemainingName;
    }

    return SubKeysNames;
}

vector<KEY_NODE>
GetSubKeys(
    _In_ ExtRemoteTyped KeyHive,
    _In_ ExtRemoteTyped KeyNode
    )
{
    vector<KEY_NODE> SubKeys;
    ULONG SubKeysStableCount;
    ULONG SubKeysVolatileCount;

    SubKeysStableCount = KeyNode.Field("SubKeyCounts").ArrayElement(0).GetUlong();

    if (SubKeysStableCount && !(SubKeysStableCount & ~0xFFFF)) {

        ULONG SubKeysStableIndex = KeyNode.Field("SubKeyLists").ArrayElement(0).GetUlong();
        ULONG64 SubKeysStableTableAddress = RegGetCellPaged(KeyHive, SubKeysStableIndex);

        ULONG MaxSize = sizeof(CM_KEY_FAST_INDEX) + SubKeysStableCount * sizeof(CM_INDEX);

        PULONG SubKeysStableTable = (PULONG)calloc(MaxSize, sizeof(BYTE));

        if (SubKeysStableTable) {

            if (ExtRemoteTypedEx::ReadVirtual(SubKeysStableTableAddress, SubKeysStableTable, MaxSize, NULL) == S_OK) {
                        
                PCM_KEY_INDEX CmKeyIndex = (PCM_KEY_INDEX)SubKeysStableTable;

                for (UINT i = 0; i < SubKeysStableCount; i++) {

                    try {

                        ULONG64 Address = 0;
                        KEY_NODE SubKey = {0};

                        if ((CmKeyIndex->Signature == CM_INDEX_ROOT_SIGNATURE) || (CmKeyIndex->Signature == CM_INDEX_LEAF_SIGNATURE)) {

                            Address = RegGetCellPaged(KeyHive, CmKeyIndex->CellIndex[i]);
                        }
                        else if ((CmKeyIndex->Signature == CM_FAST_LEAF_SIGNATURE) || (CmKeyIndex->Signature == CM_HASH_LEAF_SIGNATURE)) {

                            PCM_KEY_FAST_INDEX CmKeyFastIndex = (PCM_KEY_FAST_INDEX)CmKeyIndex;
                            Address = RegGetCellPaged(KeyHive, CmKeyFastIndex->Index[i].CellIndex);
                        }

                        ExtRemoteTyped ChildKeyNode("(nt!_CM_KEY_NODE *)@$extin", Address);

                        SubKey.KeyNode = ChildKeyNode;

                        USHORT NameLength = ChildKeyNode.Field("NameLength").GetUshort();

                        if (NameLength) {

                            CHAR Name[MAX_PATH] = {0};

                            Address = ChildKeyNode.Field("Name").GetPointerTo().GetPtr();

                            ExtRemoteTypedEx::ReadVirtual(Address, Name, min(NameLength, sizeof(Name) - 1), NULL);

                            StringCchPrintfW(SubKey.Name, _countof(SubKey.Name), L"%S", Name);

                            SubKeys.push_back(SubKey);
                        }
                    }
                    catch (...) {

                    }
                }
            }

            free(SubKeysStableTable);
        }
    }

    SubKeysVolatileCount = KeyNode.Field("SubKeyCounts").ArrayElement(1).GetUlong();

    if (SubKeysVolatileCount && !(SubKeysVolatileCount & ~0xFFFF)) {

        ULONG SubKeysVolatileIndex = KeyNode.Field("SubKeyLists").ArrayElement(1).GetUlong();
        ULONG64 SubKeysVolatileTableAddress = RegGetCellPaged(KeyHive, SubKeysVolatileIndex);

        ULONG MaxSize = sizeof(CM_KEY_FAST_INDEX) + SubKeysVolatileCount * sizeof(CM_INDEX);

        PULONG SubKeysVolatileTable = (PULONG)calloc(MaxSize, sizeof(BYTE));

        if (SubKeysVolatileTable) {

            if (ExtRemoteTypedEx::ReadVirtual(SubKeysVolatileTableAddress, SubKeysVolatileTable, MaxSize, NULL) == S_OK) {

                PCM_KEY_INDEX CmKeyIndex = (PCM_KEY_INDEX)SubKeysVolatileTable;

                for (UINT i = 0; i < SubKeysVolatileCount; i++) {

                    try {

                        ULONG64 Address = 0;
                        KEY_NODE SubKey = {0};

                        if ((CmKeyIndex->Signature == CM_INDEX_ROOT_SIGNATURE) || (CmKeyIndex->Signature == CM_INDEX_LEAF_SIGNATURE)) {

                            Address = RegGetCellPaged(KeyHive, CmKeyIndex->CellIndex[i]);
                        }
                        else if ((CmKeyIndex->Signature == CM_FAST_LEAF_SIGNATURE) || (CmKeyIndex->Signature == CM_HASH_LEAF_SIGNATURE)) {

                            PCM_KEY_FAST_INDEX CmKeyFastIndex = (PCM_KEY_FAST_INDEX)CmKeyIndex;
                            Address = RegGetCellPaged(KeyHive, CmKeyFastIndex->Index[i].CellIndex);
                        }

                        ExtRemoteTyped ChildKeyNode("(nt!_CM_KEY_NODE *)@$extin", Address);

                        SubKey.KeyNode = ChildKeyNode;

                        USHORT NameLength = ChildKeyNode.Field("NameLength").GetUshort();

                        if (NameLength) {

                            CHAR Name[MAX_PATH] = {0};

                            Address = ChildKeyNode.Field("Name").GetPointerTo().GetPtr();

                            ExtRemoteTypedEx::ReadVirtual(Address, Name, min(NameLength, sizeof(Name) - 1), NULL);

                            StringCchPrintfW(SubKey.Name, _countof(SubKey.Name), L"%S", Name);

                            SubKeys.push_back(SubKey);
                        }
                    }
                    catch (...) {

                    }
                }
            }

            free(SubKeysVolatileTable);
        }
    }

    return SubKeys;
}

ExtRemoteTyped
GetKeyNode(
    _In_ PWSTR FullKeyPath
    )
{
    ULONG64 CmpMasterHive;
    ULONG64 CmpRegistryRootObject;
    ExtRemoteTyped KeyNode;

    try {

        ReadPointer(CmpMasterHiveAddress, &CmpMasterHive);
        ReadPointer(CmpRegistryRootObjectAddress, &CmpRegistryRootObject);

        ExtRemoteTyped KeyHive("(nt!_HHIVE *)@$extin", CmpMasterHive);
        ExtRemoteTyped KeyBody("(nt!_CM_KEY_BODY *)@$extin", CmpRegistryRootObject);
        ExtRemoteTyped KeyControlBlock("(nt!_CM_KEY_CONTROL_BLOCK *)@$extin", KeyBody.Field("KeyControlBlock").GetPtr());

        ULONG KeyCell = KeyControlBlock.Field("KeyCell").GetUlong();

        KeyNode = ExtRemoteTyped("(nt!_CM_KEY_NODE *)@$extin", RegGetCellPaged(KeyHive, KeyCell));

        vector<KEY_NAME> KeysNames = GetKeysNames(FullKeyPath);

        for (size_t i = 1; i < KeysNames.size(); i++) {

            BOOL IsFound = FALSE;

            vector<KEY_NODE> SubKeys = GetSubKeys(KeyHive, KeyNode);

            for (size_t j = 0; j < SubKeys.size(); j++) {

                if (0 == _wcsicmp(KeysNames[i].Name, SubKeys[j].Name)) {

                    KeyNode = SubKeys[j].KeyNode;

                    if (KeyNode.Field("Signature").GetUshort() == CM_LINK_NODE_SIGNATURE) {

                        KeyHive = ExtRemoteTyped("(nt!_HHIVE *)@$extin", KeyNode.Field("ChildHiveReference.KeyHive").GetPtr());
                        KeyCell = KeyNode.Field("ChildHiveReference.KeyCell").GetUlong();
                        KeyNode = ExtRemoteTyped("(nt!_CM_KEY_NODE *)@$extin", RegGetCellPaged(KeyHive, KeyCell));
                    }

                    IsFound = TRUE;
                    break;
                }
            }

            if (!IsFound) {

                KeyNode = ExtRemoteTyped("(nt!_CM_KEY_NODE *)@$extin", NULL);
                break;
            }
        }
    }
    catch (...) {

    }

    return KeyNode;
}

ExtRemoteTyped
GetHive(
    _In_ PWSTR FullKeyPath
    )
{
    PHIVE_OBJECT Hive = NULL;
    ULONG64 HiveAddress = NULL;
    ULONG HiveRootLength;
    ULONG KeyPathLength;

    if (g_Hives.size()) {

        KeyPathLength = (ULONG)wcslen(FullKeyPath);

        for (size_t i = 0; i < g_Hives.size(); i++) {

            HiveRootLength = (ULONG)wcslen(g_Hives[i].HiveRootPath);

            if (HiveRootLength && (HiveRootLength <= KeyPathLength) && (0 == _wcsnicmp(g_Hives[i].HiveRootPath, FullKeyPath, HiveRootLength))) {

                Hive = &g_Hives[i];
                break;
            }
        }

        if (!Hive) {

            Hive = &g_Hives[0];
        }

        HiveAddress = Hive->HivePtr;
    }

    return ExtRemoteTyped("(nt!_HHIVE *)@$extin", HiveAddress);
}

BOOL
RegGetKeyValue(
    _In_ PWSTR FullKeyPath,
    _In_ PWSTR ValueName,
    _Out_writes_bytes_to_(DataLength, *pDataLength) PVOID Data,
    _In_ ULONG DataLength,
    _Out_range_(0, DataLength) PULONG pValueLength
)
{
    BOOL Status = FALSE;
	ULONG ValueLength = 0;

    ZeroMemory(Data, DataLength);

    try {

        ExtRemoteTyped CmHive = GetHive(FullKeyPath);
        ExtRemoteTyped KeyNode = GetKeyNode(FullKeyPath);

        ULONG ValuesCount = KeyNode.Field("ValueList").Field("Count").GetUlong();

        if (ValuesCount && !(ValuesCount & ~0xFFFF)) {

            PULONG ValuesTable = (PULONG)calloc(ValuesCount, sizeof(ULONG));

            if (ValuesTable) {

                ULONG ValuesIndex = KeyNode.Field("ValueList").Field("List").GetUlong();
                ULONG64 ValuesTableAddress = RegGetCellPaged(CmHive, ValuesIndex);

                if (ExtRemoteTypedEx::ReadVirtual(ValuesTableAddress, ValuesTable, ValuesCount * sizeof(ULONG), NULL) == S_OK) {

                    PCHAR ValueNameAnsi = (PCHAR)calloc(MAX_VALUE_NAME, sizeof(CHAR));

                    if (ValueNameAnsi) {

                        PWCHAR ValueNameWide = (PWCHAR)calloc(MAX_VALUE_NAME, sizeof(WCHAR));

                        if (ValueNameWide) {

                            for (UINT j = 0; j < ValuesCount; j++) {

                                ULONG64 KeyValueAddress = RegGetCellPaged(CmHive, ValuesTable[j]);

                                ExtRemoteTyped KeyValue("(nt!_CM_KEY_VALUE *)@$extin", KeyValueAddress);

                                USHORT NameLength = KeyValue.Field("NameLength").GetUshort();

                                if (NameLength) {

                                    ZeroMemory(ValueNameAnsi, MAX_VALUE_NAME * sizeof(CHAR));

                                    ULONG64 NameAddress = KeyValue.Field("Name").GetPointerTo().GetPtr();

                                    ExtRemoteTypedEx::ReadVirtual(NameAddress, ValueNameAnsi, min(NameLength, sizeof(ValueNameAnsi) - 1), NULL);

                                    StringCchPrintfW(ValueNameWide, MAX_VALUE_NAME, L"%S", ValueNameAnsi);

                                    if (0 == wcscmp(ValueName, ValueNameWide)) {

                                        if (KeyValue.Field("Signature").GetUshort() == CM_KEY_VALUE_SIGNATURE) {

                                        	ValueLength = (KeyValue.Field("DataLength").GetUlong()) & 0x7FFFFFFF;

                                            if (ValueLength <= DataLength) {

                                                switch (KeyValue.Field("Type").GetUlong()) {

                                                case REG_SZ:
                                                case REG_EXPAND_SZ:
                                                case REG_MULTI_SZ:
                                                case REG_LINK:
                                                {
                                                    ULONG64 ValueAddress = RegGetCellPaged(CmHive, KeyValue.Field("Data").GetUlong());

                                                    ValueLength = min(ValueLength, DataLength - sizeof(WCHAR));

                                                    if (ExtRemoteTypedEx::ReadVirtual(ValueAddress, Data, ValueLength, NULL) == S_OK) {

                                                        Status = TRUE;
                                                    }

                                                    break;
                                                }
                                                case REG_BINARY:
                                                {
                                                    ULONG64 ValueAddress = RegGetCellPaged(CmHive, KeyValue.Field("Data").GetUlong());

                                                    if (ExtRemoteTypedEx::ReadVirtual(ValueAddress, Data, ValueLength, NULL) == S_OK) {

                                                        Status = TRUE;
                                                    }

                                                    break;
                                                }
                                                case REG_DWORD:
                                                case REG_DWORD_BIG_ENDIAN:
                                                {
                                                    *(PDWORD)Data = KeyValue.Field("Data").GetUlong();

                                                    Status = TRUE;

                                                    break;
                                                }
                                                case REG_QWORD:
                                                {
                                                    *(PDWORD64)Data = KeyValue.Field("Data").GetLong64();

                                                    Status = TRUE;

                                                    break;
                                                }
                                                }
                                            }
                                        }

                                        break;
                                    }
                                }
                            }

                            free(ValueNameWide);
                        }

                        free(ValueNameAnsi);
                    }
                }

                free(ValuesTable);
            }
        }
    }
    catch (...) {

    }
	
	if (pValueLength) *pValueLength = ValueLength;

    return Status;
}

vector<KEY_NAME>
RegGetKeyValuesNames(
    _In_ PWSTR FullKeyPath
    )
{
    vector<KEY_NAME> KeyValuesNames;
    KEY_NAME ValueName;

    try {

        ExtRemoteTyped CmHive = GetHive(FullKeyPath);
        ExtRemoteTyped KeyNode = GetKeyNode(FullKeyPath);

        ULONG ValuesCount = KeyNode.Field("ValueList").Field("Count").GetUlong();

        if (ValuesCount && !(ValuesCount & ~0xFFFF)) {

            PULONG ValuesTable = (PULONG)calloc(ValuesCount, sizeof(ULONG));

            if (ValuesTable) {

                ULONG ValuesIndex = KeyNode.Field("ValueList").Field("List").GetUlong();
                ULONG64 ValuesTableAddress = RegGetCellPaged(CmHive, ValuesIndex);

                if (ExtRemoteTypedEx::ReadVirtual(ValuesTableAddress, ValuesTable, ValuesCount * sizeof(ULONG), NULL) == S_OK) {

                    PCHAR ValueNameAnsi = (PCHAR)calloc(MAX_VALUE_NAME, sizeof(CHAR));

                    if (ValueNameAnsi) {

                        PWCHAR ValueNameWide = (PWCHAR)calloc(MAX_VALUE_NAME, sizeof(WCHAR));

                        if (ValueNameWide) {

                            for (UINT j = 0; j < ValuesCount; j++) {

                                ULONG64 KeyValueAddress = RegGetCellPaged(CmHive, ValuesTable[j]);

                                ExtRemoteTyped KeyValue("(nt!_CM_KEY_VALUE *)@$extin", KeyValueAddress);

                                USHORT NameLength = KeyValue.Field("NameLength").GetUshort();

                                if (NameLength) {

                                    ZeroMemory(ValueNameAnsi, MAX_VALUE_NAME * sizeof(CHAR));

                                    ULONG64 NameAddress = KeyValue.Field("Name").GetPointerTo().GetPtr();

                                    ExtRemoteTypedEx::ReadVirtual(NameAddress, ValueNameAnsi, min(NameLength, sizeof(ValueNameAnsi) - 1), NULL);

                                    StringCchPrintfW(ValueNameWide, MAX_VALUE_NAME, L"%S", ValueNameAnsi);

                                    StringCchCopyW(ValueName.Name, _countof(ValueName.Name), ValueNameWide);

                                    KeyValuesNames.push_back(ValueName);
                                }
                            }

                            free(ValueNameWide);
                        }

                        free(ValueNameAnsi);
                    }
                }

                free(ValuesTable);
            }
        }
    }
    catch (...) {

    }

    return KeyValuesNames;
}

vector<KEY_NODE>
RegGetSubKeys(
    _In_ PWSTR FullKeyPath
    )
{
    vector<KEY_NODE> SubKeys;

    try {

        ExtRemoteTyped KeyHive = GetHive(FullKeyPath);
        ExtRemoteTyped KeyNode = GetKeyNode(FullKeyPath);

        SubKeys = GetSubKeys(KeyHive, KeyNode);
    }
    catch (...) {

    }

    return SubKeys;
}

ULONG64
RegGetCellPaged(
    _In_ ExtRemoteTyped KeyHive,
    _In_ ULONG CellIndex
)
/*++

Routine Description:

    Description.

Arguments:

     KeyHive - 
     CellIndex - 

Return Value:

    None.

--*/
{
    ULONG Type, Table, Block, Offset;
    ULONG64 CellAddr;

    Type = ((ULONG)((CellIndex & HCELL_TYPE_MASK) >> HCELL_TYPE_SHIFT));
    Table = (ULONG)((CellIndex & HCELL_TABLE_MASK) >> HCELL_TABLE_SHIFT);
    Block = (ULONG)((CellIndex & HCELL_BLOCK_MASK) >> HCELL_BLOCK_SHIFT);
    Offset = (ULONG)(CellIndex & HCELL_OFFSET_MASK);

    // g_Ext->Dml("Hive: %I64X, CellIndex = %x, Type = %x, Table = %x, Block = %x, Offset = %x\n",
    //    KeyHive.GetPtr(), CellIndex, Type, Table, Block, Offset);

    ExtRemoteTyped DirMap = KeyHive.Field("Storage").ArrayElement(Type).Field("Map");
    ExtRemoteTyped MapTable = DirMap.Field("Directory").ArrayElement(Table);

    if (MapTable.Field("Table").ArrayElement(Block).HasField("BlockAddress")) {

        CellAddr = MapTable.Field("Table").ArrayElement(Block).Field("BlockAddress").GetPtr();
    }
    else {

        CellAddr = MapTable.Field("Table").ArrayElement(Block).Field("PermanentBinAddress").GetPtr() & ~0xF;
    }

    CellAddr += Offset;
    if (KeyHive.Field("Version").GetUlong() == 1) CellAddr += sizeof(LONG)+sizeof(ULONG);
    else CellAddr += sizeof(LONG);

    return CellAddr;
}

VOID
RegReadKeyNode(
    _In_ ExtRemoteTyped KeyHive,
    _In_ ExtRemoteTyped KeyNode
)
/*++

Routine Description:

    Description.

Arguments:

     KeyHive - 
     KeyNode -

Return Value:

    None.

--*/
{
    CHAR Name[512] = {0};
    PULONG ValuesTable = NULL;
    PVOID SubKeysStableTable = NULL;
    PVOID SubKeysVolatileTable = NULL;
    ULONG64 SubKeysStableTableAddress;
    ULONG64 SubKeysVolatileTableAddress;
    ULONG64 ValuesTableAddress;
    ULONG64 NameAddress;
    USHORT NameLength;

    if (KeyNode.Field("Signature").GetUshort() == CM_LINK_NODE_SIGNATURE) {

        KeyHive = ExtRemoteTyped("(nt!_HHIVE *)@$extin", KeyNode.Field("ChildHiveReference.KeyHive").GetPtr());

        ULONG KeyCell = KeyNode.Field("ChildHiveReference.KeyCell").GetUlong();
        ULONG64 KeyNodeAddress = RegGetCellPaged(KeyHive, KeyCell);
        KeyNode = ExtRemoteTyped("(nt!_CM_KEY_NODE *)@$extin", KeyNodeAddress);
    }

    ULONG ValuesCount = KeyNode.Field("ValueList").Field("Count").GetUlong();
    ULONG ValuesIndex = KeyNode.Field("ValueList").Field("List").GetUlong();

    ULONG SubKeysStableCount = KeyNode.Field("SubKeyCounts").ArrayElement(0).GetUlong();
    ULONG SubKeysVolatileCount = KeyNode.Field("SubKeyCounts").ArrayElement(1).GetUlong();

    RtlZeroMemory(Name, sizeof(Name));

    NameLength = KeyNode.Field("NameLength").GetUshort();

    if (NameLength) {

        NameAddress = KeyNode.Field("Name").GetPointerTo().GetPtr();

        ExtRemoteTypedEx::ReadVirtual(NameAddress, Name, min(NameLength, sizeof(Name) - 1), NULL);
    }

    g_Ext->Dml(" Key node <col fg=\"changed\">%s</col> contains %d key values and %d subkeys.\n\n",
               Name,
               ValuesCount,
               SubKeysStableCount + SubKeysVolatileCount);

    if (SubKeysStableCount + SubKeysVolatileCount) g_Ext->Dml(" [*] Subkeys (%d):\n", SubKeysStableCount + SubKeysVolatileCount);

    if (SubKeysStableCount && !(SubKeysStableCount & ~0xFFFF))
    {
        ULONG SubKeysStableIndex = KeyNode.Field("SubKeyLists").ArrayElement(0).GetUlong();

        SubKeysStableTableAddress = RegGetCellPaged(KeyHive, SubKeysStableIndex);

        ULONG MaxSize = sizeof(CM_KEY_FAST_INDEX) + SubKeysStableCount * sizeof(CM_INDEX);

        SubKeysStableTable = (PULONG)calloc(MaxSize, sizeof(BYTE));

        if (SubKeysStableTable) {

            if (ExtRemoteTypedEx::ReadVirtual(SubKeysStableTableAddress, SubKeysStableTable, MaxSize, NULL) == S_OK) {

                PCM_KEY_INDEX CmKeyIndex = (PCM_KEY_INDEX)SubKeysStableTable;

                for (UINT i = 0; i < SubKeysStableCount; i++) {

                    ULONG64 Address = 0;
                    CHAR TimeBuffer[128] = {0};
                    FILETIME LastWriteTime = {0};

                    try {

                        if ((CmKeyIndex->Signature == CM_INDEX_ROOT_SIGNATURE) || (CmKeyIndex->Signature == CM_INDEX_LEAF_SIGNATURE)) {

                            Address = RegGetCellPaged(KeyHive, CmKeyIndex->CellIndex[i]);
                        }
                        else if ((CmKeyIndex->Signature == CM_FAST_LEAF_SIGNATURE) || (CmKeyIndex->Signature == CM_HASH_LEAF_SIGNATURE)) {

                            PCM_KEY_FAST_INDEX CmKeyFastIndex = (PCM_KEY_FAST_INDEX)CmKeyIndex;
                            Address = RegGetCellPaged(KeyHive, CmKeyFastIndex->Index[i].CellIndex);
                        }

                        ExtRemoteTyped LocalKeyNode("(nt!_CM_KEY_NODE *)@$extin", Address);

                        LastWriteTime.dwLowDateTime = LocalKeyNode.Field("LastWriteTime.LowPart").GetUlong();
                        LastWriteTime.dwHighDateTime = LocalKeyNode.Field("LastWriteTime.HighPart").GetUlong();

                        RtlZeroMemory(Name, sizeof(Name));

                        NameLength = LocalKeyNode.Field("NameLength").GetUshort();

                        if (NameLength) {

                            NameAddress = LocalKeyNode.Field("Name").GetPointerTo().GetPtr();

                            ExtRemoteTypedEx::ReadVirtual(NameAddress, Name, min(NameLength, sizeof(Name) - 1), NULL);
                        }

                        g_Ext->Dml("   [%2d] <link cmd=\"!ms_readknode 0x%I64X 0x%I64X\">0x%I64X</link> | <col fg=\"changed\">%-50s</col> | LastWriteTime: %s\n",
                                   i,
                                   KeyHive.GetPtr(),
                                   Address,
                                   Address,
                                   Name,
                                   GetLastWriteTime(&LastWriteTime, TimeBuffer, sizeof(TimeBuffer)));
                    }
                    catch (...) {

                    }
                }
            }

            free(SubKeysStableTable);
        }
    }

    if (SubKeysVolatileCount && !(SubKeysVolatileCount & ~0xFFFF))
    {
        ULONG SubKeysVolatileIndex = KeyNode.Field("SubKeyLists").ArrayElement(1).GetUlong();

        SubKeysVolatileTableAddress = RegGetCellPaged(KeyHive, SubKeysVolatileIndex);

        ULONG MaxSize = sizeof(CM_KEY_FAST_INDEX) + SubKeysVolatileCount * sizeof(CM_INDEX);

        SubKeysVolatileTable = (PULONG)calloc(MaxSize, sizeof(BYTE));

        if (SubKeysVolatileTable) {

            if (ExtRemoteTypedEx::ReadVirtual(SubKeysVolatileTableAddress, SubKeysVolatileTable, MaxSize, NULL) == S_OK) {

                PCM_KEY_INDEX CmKeyIndex = (PCM_KEY_INDEX)SubKeysVolatileTable;

                for (UINT i = 0; i < SubKeysVolatileCount; i++) {

                    ULONG64 Address = 0;

                    try {

                        if ((CmKeyIndex->Signature == CM_INDEX_ROOT_SIGNATURE) || (CmKeyIndex->Signature == CM_INDEX_LEAF_SIGNATURE)) {

                            Address = RegGetCellPaged(KeyHive, CmKeyIndex->CellIndex[i]);
                        }
                        else if ((CmKeyIndex->Signature == CM_FAST_LEAF_SIGNATURE) || (CmKeyIndex->Signature == CM_HASH_LEAF_SIGNATURE)) {

                            PCM_KEY_FAST_INDEX CmKeyFastIndex = (PCM_KEY_FAST_INDEX)CmKeyIndex;
                            Address = RegGetCellPaged(KeyHive, CmKeyFastIndex->Index[i].CellIndex);
                        }

                        ExtRemoteTyped LocalKeyNode("(nt!_CM_KEY_NODE *)@$extin", Address);

                        RtlZeroMemory(Name, sizeof(Name));

                        NameLength = LocalKeyNode.Field("NameLength").GetUshort();

                        if (NameLength) {

                            NameAddress = LocalKeyNode.Field("Name").GetPointerTo().GetPtr();

                            ExtRemoteTypedEx::ReadVirtual(NameAddress, Name, min(NameLength, sizeof(Name) - 1), NULL);
                        }

                        g_Ext->Dml("   [%2d] <link cmd=\"!ms_readknode 0x%I64X 0x%I64X\">0x%I64X</link> | <col fg=\"changed\">%-32s</col>\n",
                                   i,
                                   KeyHive.GetPtr(),
                                   Address,
                                   Address,
                                   Name);
                    }
                    catch (...) {

                    }
                }
            }

            free(SubKeysVolatileTable);
        }
    }

    g_Ext->Dml("\n");

    if (ValuesCount && !(ValuesCount & ~0xFFFF)) {

        ValuesTableAddress = RegGetCellPaged(KeyHive, ValuesIndex);

        ValuesTable = (PULONG)calloc(ValuesCount * sizeof(ULONG), sizeof(BYTE));

        if (ValuesTable) {

            if (ExtRemoteTypedEx::ReadVirtual(ValuesTableAddress, ValuesTable, ValuesCount * sizeof(ULONG), NULL) == S_OK) {

                g_Ext->Dml(" [*] Values (%d):\n", ValuesCount);

                for (UINT i = 0; i < ValuesCount; i++) {

                    try {

                        ULONG64 Address = RegGetCellPaged(KeyHive, ValuesTable[i]);

                        ExtRemoteTyped KeyValue("(nt!_CM_KEY_VALUE *)@$extin", Address);

                        NameLength = 0;

                        RtlZeroMemory(Name, sizeof(Name));

                        if (KeyValue.GetPtr()) {

                            NameLength = KeyValue.Field("NameLength").GetUshort();

                            if (NameLength) {

                                NameAddress = KeyValue.Field("Name").GetPointerTo().GetPtr();

                                ExtRemoteTypedEx::ReadVirtual(NameAddress, Name, min(NameLength, sizeof(Name) - 1), NULL);
                            }
                        }

                        g_Ext->Dml("   [%2d] <link cmd=\"!ms_readkvalue 0x%I64X 0x%I64X\">0x%I64X</link> | <col fg=\"changed\">%-32s</col> | ",
                                   i,
                                   KeyHive.GetPtr(),
                                   Address,
                                   Address,
                                   NameLength ? Name : "(Default)");

                        g_Ext->Dml("        ");

                        RegReadKeyValue(KeyHive, KeyValue);
                    }
                    catch (...) {

                    }
                }

                g_Ext->Dml("\n");
            }

            free(ValuesTable);
        }
    }
}

PWSTR
RegGetKeyName(
    _In_ ULONG64 KeyControlBlock
    )
/*++

Routine Description:

    Description.

Arguments:

     KeyControlBlock - 

Return Value:

    LPWSTR.

--*/
{
    ExtRemoteTyped Kcb;
    vector<KEY_NAME> KeyNames;
    KEY_NAME KeyName;
    ULONG64 Address;
    CHAR Name[MAX_PATH] = {0};
    USHORT NameLength;
    PWSTR FullName = NULL;
    ULONG FullNameLength = 0;

    if (!KeyControlBlock) {

        return NULL;
    }

    try {

        Address = KeyControlBlock;

        while (Address) {

            Kcb = ExtRemoteTyped("(nt!_CM_KEY_CONTROL_BLOCK *)@$extin", Address);

            NameLength = Kcb.Field("NameBlock").Field("NameLength").GetUshort();

            if (!NameLength || (NameLength >= sizeof(Name))) {

                break;
            }

            ZeroMemory(Name, sizeof(Name));

            if (g_Ext->m_Data->ReadVirtual(Kcb.Field("NameBlock").Field("Name").GetPointerTo().GetPtr(), Name, NameLength, NULL) != S_OK) {

                break;
            }

            FullNameLength += (ULONG)strlen(Name) + 1;

            StringCchPrintfW(KeyName.Name, _countof(KeyName.Name), L"%S", Name);

            KeyNames.push_back(KeyName);

            Address = Kcb.Field("ParentKcb").GetPtr();
        }
    }
    catch (...) {

    }

    if (FullNameLength) {

        FullNameLength += 1;

        FullName = (PWSTR)calloc(FullNameLength, sizeof(WCHAR));

        if (FullName) {

            for (size_t i = KeyNames.size(); i > 0 ; i--) {

                StringCchCatW(FullName, FullNameLength, L"\\");
                StringCchCatW(FullName, FullNameLength, KeyNames[i - 1].Name);
            }
        }
    }

    return FullName;
}

VOID
RegReadKeyValue(
    _In_ ExtRemoteTyped KeyHive,
    _In_ ExtRemoteTyped KeyValue
    )
/*++

Routine Description:

    Description.

Arguments:

    KeyHive - 
    KeyValue - 

Return Value:

    None.

--*/
{
    PUCHAR Buffer = NULL;
    ULONG64 Data;
    UINT i;

    if (KeyValue.Field("Signature").GetUshort() != CM_KEY_VALUE_SIGNATURE)
    {
        g_Ext->Err("Error: Invalid object (o=%I64X) signature.\n", KeyValue.GetPtr());
        goto CleanUp;
    }

    ULONG DataLength = (KeyValue.Field("DataLength").GetUlong()) & 0x7FFFFFFF;

    if (DataLength && !(DataLength & ~0xFFFFF)) {

        Buffer = (PUCHAR)calloc(DataLength + sizeof(WCHAR), sizeof(BYTE));

        if (Buffer) {

            switch (KeyValue.Field("Type").GetUlong())
            {
                case REG_BINARY:
                    Data = RegGetCellPaged(KeyHive, KeyValue.Field("Data").GetUlong());
                    if (ExtRemoteTypedEx::ReadVirtual(Data, Buffer, DataLength, NULL) != S_OK) goto CleanUp;

                    g_Ext->Dml("\n        REG_BINARY: \n        ");
                    for (i = 0; i < DataLength; i += 1)
                    {
                        UINT j;
                        for (j = 0; (i + j < DataLength) && (j < 0x10); j += 1)
                        {
                            g_Ext->Dml("0x%02x ", Buffer[i + j]);
                        }

                        for (; j < 0x10; j += 1) g_Ext->Dml("     ");

                        g_Ext->Dml(" | ");
                        for (j = 0; (i + j < DataLength) && (j < 0x10); j += 1)
                        {
                            g_Ext->Dml("%c ", ((Buffer[i + j] >= ' ') && (Buffer[i + j] <= 'Z')) ? Buffer[i + j] : '.');
                        }

                        g_Ext->Dml("\n        ");

                        i += j;
                    }
                    if (((i + 1) % 0x10) != 0) g_Ext->Dml("\n");
                break;
                case REG_DWORD:
                    g_Ext->Dml("0x%08X (REG_DWORD)\n", KeyValue.Field("Data").GetUlong());
                    break;
                case REG_DWORD_BIG_ENDIAN:
                    g_Ext->Dml("0x%08X (REG_DWORD_BIG_ENDIAN)\n", KeyValue.Field("Data").GetUlong());
                    break;
                case REG_EXPAND_SZ:
                    Data = RegGetCellPaged(KeyHive, KeyValue.Field("Data").GetUlong());
                    if (ExtRemoteTypedEx::ReadVirtual(Data, Buffer, DataLength, NULL) != S_OK) goto CleanUp;

                    g_Ext->Dml("%S (REG_EXPAND_SZ)\n", Buffer);
                    break;
                case REG_LINK:
                    Data = RegGetCellPaged(KeyHive, KeyValue.Field("Data").GetUlong());
                    if (ExtRemoteTypedEx::ReadVirtual(Data, Buffer, DataLength, NULL) != S_OK) goto CleanUp;

                    g_Ext->Dml("%S (REG_LINK)\n", Buffer);
                    break;
                case REG_MULTI_SZ:
                    Data = RegGetCellPaged(KeyHive, KeyValue.Field("Data").GetUlong());
                    if (ExtRemoteTypedEx::ReadVirtual(Data, Buffer, DataLength, NULL) != S_OK) goto CleanUp;

                    g_Ext->Dml("%S (REG_MULTI_SZ)\n", Buffer);
                    break;
                case REG_NONE:
                    break;
                case REG_QWORD:
                    g_Ext->Dml("0x%I64X (REG_QWORD)\n", KeyValue.Field("Data").GetLong64());
                    break;
                case REG_SZ:
                    Data = RegGetCellPaged(KeyHive, KeyValue.Field("Data").GetUlong());
                    if (ExtRemoteTypedEx::ReadVirtual(Data, Buffer, DataLength, NULL) != S_OK) goto CleanUp;

                    g_Ext->Dml("%S (REG_SZ)\n", Buffer);
                break;
            }
        }
    }

CleanUp:
    if (Buffer) free(Buffer);
}

vector<HIVE_OBJECT>
GetHives(
)
/*++

Routine Description:

    Description.

Arguments:

     - 

Return Value:

    vector<HIVE_OBJECT>.

--*/
{
    ULONG64 CmpHiveListHead;
    vector<HIVE_OBJECT> Hives;
    vector<ULONG64> Nodes;

    CmpHiveListHead = GetExpression("nt!CmpHiveListHead");

    ExtRemoteTypedList HiveList(CmpHiveListHead, "nt!_CMHIVE", "HiveList");

    try {

        for (HiveList.StartHead(); HiveList.HasNode(); HiveList.Next()) {

            HIVE_OBJECT HiveObject = {0};

            HiveObject.HivePtr = HiveList.GetNodeOffset();

            if (find(Nodes.rbegin(), Nodes.rend(), HiveObject.HivePtr) != Nodes.rend()) {

                break;
            }

            Nodes.push_back(HiveObject.HivePtr);

            if (HiveList.GetTypedNode().Field("Hive.Signature").GetUlong() != CM_HIVE_SIGNATURE) break;

            ExtRemoteTypedEx::GetUnicodeString(HiveList.GetTypedNode().Field("FileUserName"), (PWSTR)&HiveObject.FileUserName, sizeof(HiveObject.FileUserName));
            ExtRemoteTypedEx::GetUnicodeString(HiveList.GetTypedNode().Field("HiveRootPath"), (PWSTR)&HiveObject.HiveRootPath, sizeof(HiveObject.HiveRootPath));

            HiveObject.KeyNodePtr = GetKeyNode(HiveObject.HiveRootPath).m_Data;
            HiveObject.GetCellRoutine = HiveList.GetTypedNode().Field("Hive.GetCellRoutine").GetPtr();
            HiveObject.Allocate = HiveList.GetTypedNode().Field("Hive.Allocate").GetPtr();
            HiveObject.Free = HiveList.GetTypedNode().Field("Hive.Free").GetPtr();
            HiveObject.FileWrite = HiveList.GetTypedNode().Field("Hive.FileWrite").GetPtr();
            HiveObject.FileRead = HiveList.GetTypedNode().Field("Hive.FileRead").GetPtr();

            if (HiveList.GetTypedNode().HasField("Flags")) {

                HiveObject.Flags = HiveList.GetTypedNode().Field("Flags").GetUlong();
            }

            if (HiveList.GetTypedNode().HasField("Hive.ReleaseCellRoutine")) {

                HiveObject.ReleaseCellRoutine = HiveList.GetTypedNode().Field("Hive.ReleaseCellRoutine").GetPtr();
            }

            if (HiveList.GetTypedNode().HasField("Hive.FileSetSize")) {

                HiveObject.FileSetSize = HiveList.GetTypedNode().Field("Hive.FileSetSize").GetPtr();
            }

            if (HiveList.GetTypedNode().HasField("Hive.FileFlush")) {

                HiveObject.FileFlush = HiveList.GetTypedNode().Field("Hive.FileFlush").GetPtr();
            }

            Hives.push_back(HiveObject);
        }
    }
    catch (...) {

    }

    return Hives;
}

BOOL
RegInitialize(
    VOID
    )
{
    g_Hives = GetHives();

    return g_Hives.size() ? TRUE : FALSE;
}

```

`SwishDbgExt/Registry.h`:

```h
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Registry.h

Abstract:

    - 

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#ifndef __REGISTRY_H__
#define __REGISTRY_H__

#define HCELL_TYPE_MASK 0x80000000
#define HCELL_TYPE_SHIFT 31

#define HCELL_TABLE_MASK 0x7fe00000
#define HCELL_TABLE_SHIFT 21

#define HCELL_BLOCK_MASK 0x001ff000
#define HCELL_BLOCK_SHIFT 12

#define HCELL_OFFSET_MASK 0x00000fff

#define CM_FAST_LEAF_SIGNATURE 'fl'
#define CM_HASH_LEAF_SIGNATURE 'hl'
#define CM_INDEX_ROOT_SIGNATURE 'ir'
#define CM_INDEX_LEAF_SIGNATURE 'il'

#define CM_KEY_NODE_SIGNATURE 'kn'
#define CM_LINK_NODE_SIGNATURE 'kl'
#define CM_KEY_VALUE_SIGNATURE 'kv'

#define CM_FLAG_UNTRUSTED 0x1

#define CM_HIVE_SIGNATURE 0xbee0bee0

#define MAX_VALUE_NAME 16383

typedef struct _CM_INDEX {
    ULONG CellIndex;
    CHAR NameHint[4];
} CM_INDEX, *PCM_INDEX;

typedef struct _CM_KEY_FAST_INDEX {
    USHORT Signature;
    USHORT Count;
    CM_INDEX Index[1];
} CM_KEY_FAST_INDEX, *PCM_KEY_FAST_INDEX;

typedef struct _CM_KEY_INDEX {
    USHORT Signature;
    USHORT Count;
    ULONG CellIndex[1];
} CM_KEY_INDEX, *PCM_KEY_INDEX;

typedef struct _HIVE_OBJECT {
    ULONG64 HivePtr;
    ULONG64 KeyNodePtr;

    ULONG Flags;

    WCHAR FileUserName[MAX_PATH];
    WCHAR HiveRootPath[MAX_PATH];

    ULONG64 GetCellRoutine;
    ULONG64 ReleaseCellRoutine;
    ULONG64 Allocate;
    ULONG64 Free;
    ULONG64 FileSetSize;
    ULONG64 FileWrite;
    ULONG64 FileRead;
    ULONG64 FileFlush;
} HIVE_OBJECT, *PHIVE_OBJECT;

typedef struct _KEY_NAME {
    WCHAR Name[MAX_PATH];
} KEY_NAME, *PKEY_NAME ;

typedef struct _KEY_NODE {
    WCHAR Name[MAX_PATH];
    ExtRemoteTyped KeyNode;
} KEY_NODE, *PKEY_NODE;

typedef struct _REG_CHECK {
    PWSTR KeyName;
    PWSTR ValueName;
    ULONG ValueType;
} REG_CHECK, *PREG_CHECK;


PWSTR
GetRegistryValueTypeName(
    _In_ ULONG ValueType
    );

ULONG64
RegGetCellPaged(
    _In_ ExtRemoteTyped KeyHive,
    _In_ ULONG CellIndex
    );

VOID
RegReadKeyNode(
    _In_ ExtRemoteTyped KeyHive,
    _In_ ExtRemoteTyped KeyNode
    );

VOID
RegReadKeyValue(
    _In_ ExtRemoteTyped KeyHive,
    _In_ ExtRemoteTyped KeyValue
);

PWSTR
RegGetKeyName(
    _In_ ULONG64 KeyControlBlock
);

BOOL
RegGetKeyValue(
    _In_ PWSTR FullKeyPath,
    _In_ PWSTR ValueName,
    _Out_writes_bytes_to_(DataLength, *pDataLength) PVOID Data,
    _In_ ULONG DataLength,
    _Out_range_(0, DataLength) PULONG pValueLength
);

vector<KEY_NAME>
RegGetKeyValuesNames(
    _In_ PWSTR FullKeyPath
    );

vector<KEY_NODE>
RegGetSubKeys(
    _In_ PWSTR FullKeyPath
    );

BOOL
RegInitialize(
    VOID
    );

vector<HIVE_OBJECT>
GetHives(
);
#endif
```

`SwishDbgExt/Security.cpp`:

```cpp
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Security.cpp

Abstract:

    - Thanks to Frank Boldewin for sharing his code.

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#include "stdafx.h"
#include "SwishDbgExt.h"


const char *Blacklist_Functions[] = {
    "UrlDownloadToFile",
    "GetTempPath",
    "GetWindowsDirectory",
    "GetSystemDirectory",
    "WinExec",
    "ShellExecute",
    "IsBadReadPtr",
    "IsBadWritePtr",
    "CreateFile",
    "CloseHandle",
    "ReadFile",
    "WriteFile",
    "SetFilePointer",
    "VirtualAlloc",
    "GetProcAddr",
    "LoadLibrary",
    NULL
};

typedef struct _PATTERN_DATA {
    BOOLEAN Initialized;
    ULONG PatternBitMask;
    UCHAR Pattern[12]; // Max Size 12
} PATTERN_DATA, *PPATTERN_DATA;

typedef void (CALLBACK *DISPLAY_CALLBACK)(_In_ BOOLEAN Verbose, _In_ ULONG64 Base, _In_ ULONG Offset);

typedef struct _PATTERN_ENTRY {
    ULONG Type;
    CHAR *Pattern;
    ULONG PatternSize;

    DISPLAY_CALLBACK CallbackRoutine;

    PATTERN_DATA Data; // PatternCustomType only
} PATTERN_ENTRY, *PPATTERN_ENTRY;

typedef enum _PATTERN_TYPE {
    PatternNoneType = 0,
    PatternDataType = 1,
    PatternCustomType = 2
} PATTERN_TYPE;

#define InitPattern(a) {PatternDataType, a, sizeof(a) - 1, NULL, {FALSE, 0, 0}}
#define InitCustomPattern(a) {PatternCustomType, a, 1, NULL, {FALSE, 0, 0}}

#define InitPatternEx(a, b) {PatternDataType, a, sizeof(a) - 1, b, {FALSE, 0, 0}}
#define InitCustomPatternEx(a, b) {PatternCustomType, a, 1, b, {FALSE, 0, 0}}

PATTERN_ENTRY g_PatternLoop[] = {
    InitPattern("\x80\x30"),
    InitPattern("\x80\x31"),
    InitPattern("\x80\x32"),
    InitPattern("\x80\x33"),
    InitPattern("\x80\x34"),
    InitPattern("\x80\x74"),
    InitPattern("\x81\x70"),
    InitPattern("\x81\x71"),
    InitPattern("\x81\x72"),
    InitPattern("\x81\x73"),
    InitPattern("\x81\xF0"),
    InitPattern("\x81\xF2"),
    InitPattern("\x81\xF3"),
    InitPattern("\x81\xF6"),
    InitPattern("\x81\xF7"),
    InitPattern("\xC0\xC0"),
    InitPattern("\xC0\xC1"),
    InitPattern("\xC0\xC2"),
    InitPattern("\xC0\xC3"),
    InitPattern("\x30\x04\x0A"),
    InitPattern("\x30\x04\x0B"),
    InitPattern("\x30\x04\x0E"),
    InitPattern("\x30\x04\x0F"),
    InitPattern("\x30\x04\x11"),
    InitPattern("\x30\x04\x19"),
    InitPattern("\x30\x04\x1A"),
    InitPattern("\x30\x04\x31"),
    InitPattern("\x30\x04\x39"),
    InitPattern("\x35"),

    { 0 }
};

// check for xor ecx,ecx  or  mov ecx, [esp] or mov ecx, 0xnnnnnn00
PATTERN_ENTRY g_InitEcx[] = {
    InitPattern("\x33\xC9"),
    InitPattern("\x31\xC9"),
    InitPattern("\x8B\x0C\x24"),
    InitPattern("\xB9\x00"),

    { 0 }
};

VOID
CALLBACK
call_pop_signature_callback(
    BOOLEAN Verbose,
    ULONG64 Base,
    ULONG Offset
)
/*++

Routine Description:

    Description.

Arguments:

    Verbose - 
    Base - 
    Offset - 

Return Value:

    None.

--*/
{
    ULONG64 Va = SIGN_EXTEND(Base + Offset);
    if (Verbose) g_Ext->Dml("    CALL next/POP signature @ <link cmd=\"u 0x%I64X\">0x%llX</link> [offset = 0x%x]\n", Va, Va, Offset);
}

VOID
CALLBACK
fpu_signature_callback(
    BOOLEAN Verbose,
    ULONG64 Base,
    ULONG Offset
)
/*++

Routine Description:

    Description.

Arguments:

    Verbose - 
    Base - 
    Offset -

Return Value:

    None.

--*/
{
    ULONG64 Va = SIGN_EXTEND(Base + Offset);
    if (Verbose) g_Ext->Dml("    FLDZ/FSTENV [esp-12] signature @ <link cmd=\"u 0x%I64X\">0x%llX</link> [offset = 0x%x]\n", Va, Va, Offset);
}

VOID
CALLBACK
push_call_signature_callback(
    BOOLEAN Verbose,
    ULONG64 Base,
    ULONG Offset
)
/*++

Routine Description:

    Description.

Arguments:

    Verbose - 
    Base -
    Offset -

Return Value:

    None.

--*/
{
    ULONG64 Va = SIGN_EXTEND(Base + Offset);
    if (Verbose) g_Ext->Dml("    PUSH DWORD[]/CALL[] signature @ <link cmd=\"u 0x%I64X\">0x%llX</link> [offset = 0x%x]\n", Va, Va, Offset);
}

VOID
CALLBACK
function_prolog_signature_callback(
    BOOLEAN Verbose,
    ULONG64 Base,
    ULONG Offset
)
/*++

Routine Description:

    Description.

Arguments:

    Verbose - 
    Base -
    Offset -

Return Value:

    None.

--*/
{
    ULONG64 Va = SIGN_EXTEND(Base + Offset);
    if (Verbose) g_Ext->Dml("    Function prolog signature @ <link cmd=\"u 0x%I64X\">0x%llX</link> [offset = 0x%x]\n", Va, Va, Offset);
}

VOID
CALLBACK
api_hashing_signature_callback(
    BOOLEAN Verbose,
    ULONG64 Base,
    ULONG Offset
)
/*++

Routine Description:

    Description.

Arguments:

    Verbose - 
    Base -
    Offset -

Return Value:

    None.

--*/
{
    ULONG64 Va = SIGN_EXTEND(Base + Offset);
    if (Verbose) g_Ext->Dml("    API-Hashing signature @ <link cmd=\"u 0x%I64X\">0x%llX</link> [offset = 0x%x]\n", Va, Va, Offset);
}

VOID
CALLBACK
peb2_access_signature_callback(
    BOOLEAN Verbose,
    ULONG64 Base,
    ULONG Offset
)
/*++

Routine Description:

    Description.

Arguments:

    Verbose - 
    Base -
    Offset -

Return Value:

    None.

--*/
{
    ULONG64 Va = SIGN_EXTEND(Base + Offset);
    if (Verbose) g_Ext->Dml("    FS:[00h] signature @ <link cmd=\"u 0x%I64X\">0x%llX</link> [offset = 0x%x]\n", Va, Va, Offset);
}

VOID
CALLBACK
peb_access_signature_callback(
    BOOLEAN Verbose,
    ULONG64 Base,
    ULONG Offset
)
/*++

Routine Description:

    Description.

Arguments:

    Verbose - 
    Base -
    Offset -

Return Value:

    None.

--*/
{
    ULONG64 Va = SIGN_EXTEND(Base + Offset);
    if (Verbose) g_Ext->Dml("    FS:[30h] signature @ <link cmd=\"u 0x%I64X\">0x%llX</link> [offset = 0x%x]\n", Va, Va, Offset);
}

PATTERN_ENTRY g_PatternTable[] = {
    // FS:[30h] signature
    InitPatternEx("\x64\xA1\x30\x00\x00", peb_access_signature_callback),
    InitPatternEx("\x64\x8B\x40\x30", peb_access_signature_callback),
    InitPatternEx("\x64\x8B\x1D\x30\x00", peb_access_signature_callback),
    InitPatternEx("\x64\x8B\x0D\x30\x00", peb_access_signature_callback),
    InitPatternEx("\x64\x8B\x15\x30\x00", peb_access_signature_callback),
    InitPatternEx("\x64\x8B\x35\x30\x00", peb_access_signature_callback),
    InitPatternEx("\x64\x8B\x3D\x30\x00", peb_access_signature_callback),
    InitPatternEx("\x67\x64\xA1\x30\x00", peb_access_signature_callback),

    InitCustomPatternEx("6a30??648b", peb_access_signature_callback),
    InitCustomPatternEx("33????b3648b", peb_access_signature_callback),
    InitCustomPatternEx("6a8b??308b", peb_access_signature_callback),

    InitPatternEx("\x64\xFF\x35\x30", peb_access_signature_callback),

    // FS:[00h] signature found
    InitPatternEx("\x64\xA1\x00\x00\x00", peb2_access_signature_callback),
    InitPatternEx("\x64\x8B\x1D\x00\x00", peb2_access_signature_callback),
    InitPatternEx("\x64\x8B\x0D\x00\x00", peb2_access_signature_callback),
    InitPatternEx("\x64\x8B\x15\x00\x00", peb2_access_signature_callback),
    InitPatternEx("\x64\x8B\x35\x00\x00", peb2_access_signature_callback),
    InitPatternEx("\x64\x8B\x3D\x00\x00", peb2_access_signature_callback),

    // API-Hashing signature

    InitCustomPatternEx("74??c1??0d", api_hashing_signature_callback),
    InitCustomPatternEx("74??c1??07", api_hashing_signature_callback),
    InitCustomPatternEx("74??c1??0b03", api_hashing_signature_callback),

    // Function prolog signature

    InitPatternEx("\x55\x8b\xec\x83\xc4", function_prolog_signature_callback),

    InitPatternEx("\x55\x8b\xec\x81\xec", function_prolog_signature_callback),
    InitPatternEx("\x55\x8b\xec\xeb", function_prolog_signature_callback),
    InitPatternEx("\x55\x8b\xec\xe8", function_prolog_signature_callback),
    InitPatternEx("\x55\x8b\xec\xe9", function_prolog_signature_callback),

    // PUSH DWORD[]/CALL[] signature

    InitCustomPatternEx("ff75??ff55", push_call_signature_callback),
    InitCustomPatternEx("ff77??ff57", push_call_signature_callback),
    InitCustomPatternEx("ffb7????????ff57", push_call_signature_callback),

    // FLDZ/FSTENV [esp-12] signature
    InitPatternEx("\xD9\xEE\xD9\x74\x24\xF4", fpu_signature_callback),

    InitPatternEx("\xD9\x74\x24\xF4\x58", fpu_signature_callback),
    InitPatternEx("\xD9\x74\x24\xF4\x59", fpu_signature_callback),
    InitPatternEx("\xD9\x74\x24\xF4\x5a", fpu_signature_callback),
    InitPatternEx("\xD9\x74\x24\xF4\x5b", fpu_signature_callback),

    // CALL next/POP signature
    InitPatternEx("\xE8\x00\x00\x00\x00\x58", call_pop_signature_callback),
    InitPatternEx("\xE8\x00\x00\x00\x00\x59", call_pop_signature_callback),
    InitPatternEx("\xE8\x00\x00\x00\x00\x5A", call_pop_signature_callback),
    InitPatternEx("\xE8\x00\x00\x00\x00\x5B", call_pop_signature_callback),
    InitPatternEx("\xE8\x00\x00\x00\x00\x5E", call_pop_signature_callback),
    InitPatternEx("\xE8\x00\x00\x00\x00\x5F", call_pop_signature_callback),

    InitPatternEx("\xE8\x00\x00\x00\x00\x5D", call_pop_signature_callback),

    { 0 }
};

ULONG
GetMaxPatternLen(
)
/*++

Routine Description:

    Description.

Arguments:

    -

Return Value:

    ULONG.

--*/
{
    ULONG MaxLen = 0;

    for (UINT i = 0; g_PatternTable[i].PatternSize; i += 1)
    {
        if (g_PatternTable[i].PatternSize > MaxLen) MaxLen = g_PatternTable[i].PatternSize;
    }

    return MaxLen;
}

ULONG
GetMaxBlacklistedLen(
)
/*++

Routine Description:

    Description.

Arguments:

    -

Return Value:

    ULONG.

--*/
{
    ULONG MaxLen = 0;

    for (UINT i = 0; Blacklist_Functions[i]; i += 1)
    {
        ULONG Len = (ULONG)strlen(Blacklist_Functions[i]);
        if (Len > MaxLen) MaxLen = Len;
    }

    return MaxLen;
}

BOOLEAN
InitPatternTable(
    _Inout_ PPATTERN_ENTRY PatternTable
)
/*++

Routine Description:

    Description.

Arguments:

   PatternTable -

Return Value:

    BOOLEAN.

--*/
{
    for (UINT i = 0; PatternTable[i].PatternSize; i += 1)
    {
        if ((PatternTable[i].Type == PatternCustomType) && (PatternTable[i].Data.Initialized == FALSE))
        {
            UINT j;
            ULONG Len = (ULONG)strlen(PatternTable[i].Pattern);

            for (j = 0; j < Len / 2; j += 1)
            {
                if (memcmp(&PatternTable[i].Pattern[2 * j], "??", 2) != 0)
                {
                    sscanf_s(&PatternTable[i].Pattern[2 * j], "%02x", (PUINT)&PatternTable[i].Data.Pattern[j]);
                    // g_Ext->Dml("PatternTable[i].Data.Pattern[%d] = 0x%x\n", j, PatternTable[i].Data.Pattern[j]);
                    PatternTable[i].Data.PatternBitMask |= (1 << j);
                }
                else
                {
                    PatternTable[i].Data.Pattern[j] = 0;
                }
            }

            PatternTable[i].PatternSize = j;
            PatternTable[i].Data.Initialized = TRUE;

            // g_Ext->Dml("Len = %d, Mask = 0x%x\n", j, PatternTable[i].Data.PatternBitMask);
        }
    }

    return TRUE;
}

BOOLEAN
MatchPattern(
    _In_ BOOLEAN Verbose,
    _In_ PUCHAR Input,
    _In_ ULONG64 VirtualAddress,
    _In_ ULONG Offset,
    _In_ PPATTERN_ENTRY PatternTable
)
/*++

Routine Description:

    Description.

Arguments:

    Verbose -
    Input - 
    VirtualAddress -
    Offset -
    PatternTable - 

Return Value:

    BOOLEAN.

--*/
{
    BOOLEAN Matched = FALSE;

    for (UINT i = 0; PatternTable[i].PatternSize; i += 1)
    {
        if (PatternTable[i].Type == PatternDataType)
        {
            if (memcmp(PatternTable[i].Pattern, Input, PatternTable[i].PatternSize) == 0)
            {
                Matched = TRUE;
                if (PatternTable[i].CallbackRoutine)
                {
                    // g_Ext->Dml("DataLen = %d, Signature Id = %d\n", PatternTable[i].PatternSize, i);
                    PatternTable[i].CallbackRoutine(Verbose, VirtualAddress, Offset);
                }

                break;
            }
        }
        else if ((PatternTable[i].Type == PatternCustomType) && PatternTable[i].Data.Initialized)
        {
            UINT j;
            for (j = 0; j < PatternTable[i].PatternSize; j += 1)
            {
                if (PatternTable[i].Data.PatternBitMask & (1 << j))
                {
                    if (PatternTable[i].Data.Pattern[j] != Input[j]) break;
                }
            }

            if ((j == PatternTable[i].PatternSize) && (PatternTable[i].Data.PatternBitMask))
            {
                Matched = TRUE;

                if (PatternTable[i].CallbackRoutine)
                {
                    // g_Ext->Dml("Custom::DataLen = %d, Signature Id = %d, BitMask = %x\n", PatternTable[i].PatternSize, i, PatternTable[i].Data.PatternBitMask);
                    PatternTable[i].CallbackRoutine(Verbose, VirtualAddress, Offset);
                }
                break;
            }
        }
    }

    return Matched;
}

ULONG
GetMalScore(
    BOOLEAN Verbose,
    ULONG64 VirtualAddress,
    LPBYTE Buffer,
    ULONG BufferLen
)
/*++

Routine Description:

    Description.

Arguments:

    Verbose - 
    VirtualAddress -
    Buffer -
    BufferLen - 

Return Value:

    ULONG.

--*/
{
    ULONG i;
    ULONG64 val = 0, val2 = 0, addr = 0;

    InitPatternTable(g_PatternTable);
    ULONG MaxPatternLen = GetMaxPatternLen();

    //ULONG MaxBlLen = GetMaxBlacklistedLen();

    UINT MalScoreIndex = 0;

    BOOLEAN bHeapSpray = FALSE;

    for (UINT a = 0; a < BufferLen - MaxPatternLen; a++)
    {
        if (MatchPattern(Verbose, Buffer + a, VirtualAddress, a, g_PatternTable))
        {
            MalScoreIndex = MalScoreIndex + 10;
        }
        else if (Buffer[a] == 0xEB && (Buffer[a + 1] < BufferLen) && Buffer[a + 2 + Buffer[a + 1]] == 0xE8) // JMP + CALL
        {
            // addr = (DWORD)((Buffer + a + 2 + *(Buffer + a + 1)) - Buffer);
            addr = a + 2 + Buffer[a + 1];
            val = (Buffer[addr + 1]) | (Buffer[addr + 2] << 8) | (Buffer[addr + 3] << 16) | (Buffer[addr + 4] << 24);

            if ((addr + val + 5) >= BufferLen) continue; // Invalid range

            switch (Buffer[addr + val + 5])
            {
            case 0x58:
            case 0x59:
            case 0x5A:
            case 0x5B:
                if (Verbose) g_Ext->Dml("    JMP [0xEB]/CALL/POP signature found @ <link cmd=\"u 0x%I64X\">0x%X</link>\n",
                                        VirtualAddress + a, a);
                // if (DEBUG == 1) Disasm(Buffer + a);
                MalScoreIndex = MalScoreIndex + 10;
                break;

            case 0x5E:
            case 0x5f:
                if (Verbose) g_Ext->Dml("    JMP [0xEB]/CALL/POP signature found @ <link cmd=\"u 0x%I64X\">0x%X</link>\n",
                    VirtualAddress + a, a);
                // if (DEBUG == 1) Disasm(Buffer + a);
                MalScoreIndex = MalScoreIndex + 10;
                break;

            case 0x33:
            case 0xc9:
                if (Verbose) g_Ext->Dml("    JMP [0xEB]/CALL signature found @ <link cmd=\"u 0x%I64X\">0x%X</link>\n",
                    VirtualAddress + a, a);
                // if (DEBUG == 1) Disasm(Buffer + a);
                MalScoreIndex = MalScoreIndex + 10;
                break;
            }
        }
        else if (Buffer[a] == 0xE9)
        {
            val = (Buffer[a + 1]) | (Buffer[a + 2] << 8) | (Buffer[a + 3] << 16) | (Buffer[a + 4] << 24);

            if ((a + val + 5) >= BufferLen) continue; // Invalid range

            if (Buffer[a + val + 5] == 0xE8)
            {
                val2 = (Buffer[a + val + 1]) | (Buffer[a + val + 2] << 8) | (Buffer[a + val + 3] << 16) | (Buffer[a + val + 4] << 24);

                char Opcode = 0;
                if (val2 == 0)
                {
                    if ((a + val + 5 + 5) >= BufferLen) continue; // Invalid range

                    Opcode = Buffer[a + val + 5 + 5];
                }
                else
                {
                    val2 ^= 0xffffffff;

                    if ((a + val + 5 - val2 + 4) >= BufferLen) continue; // Invalid range

                    Opcode = Buffer[a + val + 5 - val2 + 4];
                }

                switch (Opcode)
                {
                case 0x58:
                case 0x59:
                case 0x5A:
                case 0x5B:
                    if (Verbose) g_Ext->Dml("    JMP [0xE9]/CALL/POP signature found @ <link cmd=\"u 0x%I64X\">0x%X</link>\n",
                        VirtualAddress + a, a);
                    // if (DEBUG == 1) Disasm(Buffer + a);
                    MalScoreIndex = MalScoreIndex + 10;
                    break;

                case 0x5D:
                case 0x5E:
                case 0x5F:
                    if (Verbose) g_Ext->Dml("    JMP [0xE9]/CALL/POP signature found @ <link cmd=\"u 0x%I64X\">0x%X</link>\n",
                        VirtualAddress + a, a);
                    // if (DEBUG == 1) Disasm(Buffer + a);
                    MalScoreIndex = MalScoreIndex + 10;
                    break;
                }
            }
        }
        else if ((Buffer[a] == 0x75) || (Buffer[a] == 0xE2) || (Buffer[a] == 0x72))
        {
            unsigned int loopinitstart = 0, p = 0, r = 0, loinitdist = 0x20;
            BYTE LO = 0;
            unsigned long base = 0, lostart = 0;

            base = a; //  address of loop opcode
            LO = *(Buffer + a + 1) + 1;
            LO ^= 0xff; // loop length
            lostart = base - LO; // address of loop start

            // is loop length not longer 0x30 ?
            if ((LO < 0x30) && (base > LO))
            {
                // loinitdist is the distance length from lostart. from here we scan 0x20 bytes for a loop init via ECX
                for (p = 0; p <= loinitdist; p++)
                {
                    if (MatchPattern(Verbose, Buffer + lostart - loinitdist + p, VirtualAddress, lostart - loinitdist + p, g_InitEcx))
                    {
                        // variable loopinitstart stores start of loop init via ECX register
                        loopinitstart = p;

                        for (r = 0; r <= LO; r++)
                        {
                            // scan for several XORs and ROLs (ADD missing currently)
                            if (MatchPattern(Verbose, Buffer + base - LO + r, VirtualAddress, base - LO + r, g_PatternLoop))
                            {
                                if (Verbose) g_Ext->Dml("    Decryption loop detected at offset <link cmd=\"u 0x%I64X\">0x%08x</link>\n\n",
                                                        VirtualAddress + lostart - loinitdist + loopinitstart,
                                                        lostart - loinitdist + loopinitstart);
                                // Disasm(Buffer + lostart - loinitdist + loopinitstart);
                                // if (Verbose) g_Ext->Dml("<link cmd=\"u 0x%I64X\">Disass detected loop @ 0x%X</link>\n", VirtualAddress + lostart - loinitdist + loopinitstart);
                                MalScoreIndex = MalScoreIndex + 10;
                                a = base + 2;
                                break;
                            }
                        }
                    }
                }
            }
        }
        else if (Buffer[a] == 0x90)
        {
            ULONG PatternLength = 0x900;
            for (i = 0; i < PatternLength; i += 1)
            {
                if (Buffer[a + i] != 0x90) break;
            }

            if (i == PatternLength)
            {
                if (Verbose && !bHeapSpray)
                {
                    g_Ext->Dml("    Heap-spray signature detected @ <link cmd=\"u 0x%I64X\">0x%X</link>\n", VirtualAddress + a, a);
                    bHeapSpray = TRUE;
                }
                MalScoreIndex += 2000;
                a += i;
            }
        }
        else
        {
            for (i = 0; Blacklist_Functions[i]; i++)
            {
                if (memcmp(Blacklist_Functions[i], Buffer + a, strlen(Blacklist_Functions[i])) == 0)
                {
                    if (Verbose) g_Ext->Dml("    API-Name \"%s\" string found at offset: 0x%x\n", Blacklist_Functions[i], a);
                    // if (DEBUG == 1) HexDump("PE-File", Buffer + a, 256);
                    MalScoreIndex = MalScoreIndex + 2;
                }
            }
        }
    }

    return MalScoreIndex;
}

ULONG
GetMalScoreEx(
    BOOLEAN Verbose,
    MsProcessObject *ProcObj,
    ULONG64 BaseAddress,
    ULONG Length
)
/*++

Routine Description:

    Description.

Arguments:

    Verbose -
    ProcObj -
    BaseAddress -
    Length -

Return Value:

    ULONG.

--*/
{
    PBYTE Buffer = NULL;
    ULONG MalScore = 0;

    if (!Length) {

        return 0;
    }

    Buffer = (PBYTE)calloc(Length, sizeof(BYTE));

    if (Buffer) {

        if (ProcObj) ProcObj->SwitchContext();

        if (ExtRemoteTypedEx::ReadVirtual(BaseAddress, Buffer, Length, NULL) == S_OK) {

            MalScore = GetMalScore(Verbose, BaseAddress, Buffer, Length);
        }

        if (ProcObj) ProcObj->RestoreContext();

        free(Buffer);
    }

    return MalScore;
}

BOOLEAN
IsImageInMemoryEx(
    MsProcessObject *ProcObj,
    ULONG64 Offset,
    PUSHORT Sig
) {
    BOOLEAN Status = FALSE;

    if (ProcObj) ProcObj->SwitchContext();

    Status = IsImageInMemory(Offset, Sig);

    if (ProcObj) ProcObj->RestoreContext();

    return Status;
}

BOOLEAN
IsImageInMemory(
    ULONG64 Offset,
    PUSHORT Sig

) {
    UCHAR Data[0x100] = { 0 };
    ULONG BytesRead = 0;

    BOOLEAN Status = FALSE;

    if (g_Ext->m_Data->ReadVirtual(Offset, Data, sizeof(Data), &BytesRead) == S_OK) {

        USHORT Signature = *(PUSHORT)Data;
        if (Sig) *Sig = Signature;

        if (Signature == IMAGE_DOS_SIGNATURE) {
            Status = TRUE;
        }
        else if (memcmp(&Data[0x4e], "Is this program", strlen("Is this program")) == 0) {
            Status = TRUE;
        }
        else if (memcmp(&Data[0x4e], "This program cannot be run", strlen("This program cannot be run")) == 0) {
            Status = TRUE;
        }
    }

    return Status;
}

ULONG64
GetPteFromAddress(
    ULONG64 Va
) {
    ULONG Levels = 0;

    ULONG64 Tables[10];

    HRESULT Result = g_Ext->m_Data3->GetVirtualTranslationPhysicalOffsets(Va, Tables, 10, &Levels);
    if (Result != S_OK) return FALSE;

    ULONG64 PteAddress = Tables[Levels - 2];
    ULONG64 PteEntry = 0;
    Result = g_Ext->m_Data3->ReadPhysical(PteAddress, &PteEntry, sizeof(ULONG64), NULL);

    return PteEntry;
}
```

`SwishDbgExt/Security.h`:

```h
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Security.h

Abstract:

    - Thanks to Frank Boldewin for sharing his code.

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#ifndef __SECURITY_H__
#define __SECURITY_H__

ULONG
GetMalScore(
    BOOLEAN Verbose,
    ULONG64 VirtualAddress,
    LPBYTE Buffer,
    ULONG BufferLen
);

ULONG
GetMalScoreEx(
    BOOLEAN Verbose,
    MsProcessObject *ProcObj,
    ULONG64 BaseAddress,
    ULONG Length
);

BOOLEAN
IsImageInMemory(
    ULONG64 Offset,
    PUSHORT Sig

);

BOOLEAN
IsImageInMemoryEx(
    MsProcessObject *ProcObj,
    ULONG64 Offset,
    PUSHORT Sig
);

ULONG64
GetPteFromAddress(
    ULONG64 Va
);

#define IS_PTE_OWNER_USERMODE(x) ((x >> 2) & 1)
#endif
```

`SwishDbgExt/Storage.cpp`:

```cpp
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - Storage.cpp

    - Store Manager (Sm*) is pretty new under Windows 7/Windows 2008 R2 kernel, this is a new management system to deal with both virtual
    and physical stores. ReadyBoost (cache/files/logs, …) is one exemple. Even through ReadyBoost had been firstly introduced into Windows
    Vista and Windows 2008 (Refer to Mark Russinovich writeup about Windows Vista Kernel for more information about ReadyBoost), Microsoft
    kernel developpers implemented ReadyBoost feature inside the Store Manager to make it more efficient.
    http://www.msuiche.net/2009/12/06/sminfo-inside-store-manager-of-windows-7-and-windows-2008-r2-with-windd/

Abstract:

    - http://msdn.microsoft.com/en-us/windows/ff553536(v=vs.71).aspx

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

//
// Store Manager (sminfo, ReadyBoost, etc..)
// MountMgr
//

#include "stdafx.h"
#include "SwishDbgExt.h"

StoreManager::StoreManager(
)
/*++

Routine Description:

    Description.

Arguments:

    -

Return Value:

    None.

--*/
{
    m_SmLogCtxOffset = GetFieldOffset("nt!_SM_GLOBALS", "StoreMgr.Log");
    m_SmcCacheMgrOffset = GetFieldOffset("nt!_SM_GLOBALS", "CacheMgr");

    if (!m_SmLogCtxOffset || !m_SmcCacheMgrOffset)
    {
        g_Ext->Dml("Error: Can't retrieve Store and Cache offsets.\n");
    }

    m_SmGlobalsAddress = 0;

    if (g_Ext->m_Control->IsPointer64Bit() == S_OK)
    {
        m_SmpLogBufferSize = sizeof(SMP_LOG_BUFFER64);
        m_SmLogEntrySize = sizeof(SM_LOG_ENTRY64);
    }
    else
    {
        m_SmpLogBufferSize = sizeof(SMP_LOG_BUFFER32);
        m_SmLogEntrySize = sizeof(SM_LOG_ENTRY32);
    }

    g_Ext->m_Symbols->GetOffsetByName("nt!SmGlobals", &m_SmGlobalsAddress);
}

LPSTR LogEntryType[] = { "Add",
                        "Remove",
                        "Full",
                        "Update" };

BOOLEAN
StoreManager::GetSmLogEntries(
)
/*++

Routine Description:

    Description.

Arguments:

    -

Return Value:

    BOOLEAN.

--*/
{
//    SMP_LOG_BUFFER32 Log32;
    SMP_LOG_BUFFER64 Log64;
    ULONG64 SmLogBuffer = ExtRemoteTypedEx::GetPointer(m_SmGlobalsAddress + m_SmLogCtxOffset);
    ULONG64 SmLogBufferNext;
    ULONG BytesRead;

    PSM_LOG_ENTRY32 pLogEntry32 = NULL, le32 = NULL;
    PSM_LOG_ENTRY64 pLogEntry64 = NULL, le64 = NULL;

    SM_LOG_ENTRY64 LogEntry;

    BOOLEAN Is64Bit = (g_Ext->m_Control->IsPointer64Bit() == S_OK) ? TRUE : FALSE;

    BOOLEAN Result = FALSE;

    if (!SmLogBuffer)
    {
        goto CleanUp;
    }

    g_Ext->Dml("<col fg=\"changed\">"
               "  ID # Action    EPROCESS             Application Name  Page Count  Priority  Virtual Address Range"
               "</col>\n"
               "   ---- ------   ------------------   ----------------  ----------  --------  -------------------------------------\n");

    while (SmLogBuffer)
    {
        ULONG EntryCount, EntryMax;

        // g_Ext->Dml("SmLogBuffer = 0x%I64X m_SmpLogBufferSize = 0x%x\n", SmLogBuffer, m_SmpLogBufferSize);

        if (ExtRemoteTypedEx::ReadVirtual(SmLogBuffer, &Log64, m_SmpLogBufferSize, &BytesRead) != S_OK)
        {
            g_Ext->Err("Error1: Failed to read log.\n");
            goto CleanUp;
        }

        if (Is64Bit)
        {
            EntryCount = Log64.EntryCount;
            EntryMax = Log64.EntryMax;
            SmLogBufferNext = Log64.Link;
        }
        else
        {
            EntryCount = ((PSMP_LOG_BUFFER32)&Log64)->EntryCount;
            SmLogBufferNext = ((PSMP_LOG_BUFFER32)&Log64)->Link;
        }

        if (EntryCount == 0)
        {
            // g_Ext->DmlWarn("Store Manager logs are empty.\n");
            goto CleanUp;
        }

        // g_Ext->Dml("SmLogBuffer = %I64X, EntryCount = %d, EntryMax = %d\n", EntryCount, EntryMax);

        pLogEntry64 = (PSM_LOG_ENTRY64)malloc(EntryCount * m_SmLogEntrySize);
        if (pLogEntry64 == NULL) goto CleanUp;

        if (!Is64Bit)
        {
            pLogEntry32 = (PSM_LOG_ENTRY32)pLogEntry64;
            pLogEntry64 = NULL;
        }

        if (ExtRemoteTypedEx::ReadVirtual(SmLogBuffer + m_SmpLogBufferSize,
                                          (pLogEntry64) ? (PVOID)pLogEntry64 : (PVOID)pLogEntry32,
                                          EntryCount * m_SmLogEntrySize,
                                          &BytesRead) != S_OK)
        {
            g_Ext->Err("Error2: Failed to read log. (p = %I64X, 0x%x)\n",
                        SmLogBuffer + m_SmpLogBufferSize,
                        EntryCount * m_SmLogEntrySize);
            goto CleanUp;
        }

        for (ULONG Index = 0; Index < EntryCount; Index += 1)
        {
            if (pLogEntry64) le64 = &pLogEntry64[Index];
            else le32 = &pLogEntry32[Index];

            RtlZeroMemory(&LogEntry, sizeof(LogEntry));

            if (le32)
            {
                LogEntry.PageCount = le32->PageCount;
                LogEntry.AllFlags = le32->AllFlags;
                LogEntry.KeyDescriptor.ProcessKey = le32->KeyDescriptor.ProcessKey;
                LogEntry.KeyDescriptor.VirtualAddress = le32->KeyDescriptor.VirtualAddress;
            }
            else
            {
                LogEntry = *le64;
            }

            if ((LogEntry.KeyDescriptor.Flags.PageType == SmPageTypeProcess) &&
                IsValid(LogEntry.KeyDescriptor.ProcessKey))
            {
                CHAR ImageName[17] = { 0 };

                ExtRemoteTyped OwningProcess("(nt!_EPROCESS *)@$extin", LogEntry.KeyDescriptor.ProcessKey);

                OwningProcess.Field("ImageFileName").GetString((LPSTR)ImageName, sizeof(ImageName));

                g_Ext->Dml("   %4d %-8s <link cmd=\"!dml_proc 0x%I64X\">0x%016I64X</link>   <col fg=\"emphfg\">%-16s</col>  %10d  P%-8d 0x%016I64X-0x%016I64X\n",
                    Index,
                    LogEntryType[LogEntry.Flags.Type],
                    LogEntry.KeyDescriptor.ProcessKey,
                    LogEntry.KeyDescriptor.ProcessKey,
                    ImageName,
                    LogEntry.PageCount,
                    LogEntry.Flags.Priority,
                    LogEntry.KeyDescriptor.VirtualAddress * PAGE_SIZE,
                    (LogEntry.KeyDescriptor.VirtualAddress + LogEntry.PageCount) * PAGE_SIZE);

            }

            SmLogEntries.push_back(LogEntry);

            SmLogBuffer = SmLogBufferNext;
        }

        // SmLogBuffer initialized above.
    }

    Result = TRUE;

CleanUp:
    if (Result == FALSE)
    {
        g_Ext->Warn("-> Storage manager logs are empty!\n");
    }

    if (pLogEntry64) free(pLogEntry64);
    if (pLogEntry32) free(pLogEntry32);

    return Result;
}

BOOL
StoreManager::SmiDisplayCacheInformation(
    _In_ ULONG64 CacheManager,
    _In_ ULONG CacheIndex
)
/*++

Routine Description:

    Description.

Arguments:

    CacheManager -
    CacheIndex - 

Return Value:

    BOOLEAN.

--*/
{
    WCHAR UniqueId[256 + 1] = { 0 };

    ExtRemoteUnTyped CacheRef(CacheManager, "nt!_SMC_CACHE_REF");
    ULONG64 CachePtr = CacheRef.ArrayElement(CacheIndex).Field("Cache").GetPtr();
    if (CachePtr == 0) return FALSE;

    if (!IsValid(CachePtr)) return FALSE;

    ExtRemoteUnTyped CacheEntry(CachePtr, "nt!_SMC_CACHE");

    g_Ext->Dml("<col fg=\"changed\">Cache @ 0x%I64X</col>\n", CachePtr);

    ULONG64 CacheFileSize = CacheEntry.Field("CacheParams.CacheFileSize").GetUlong64();
    ULONG64 FileHandle = CacheEntry.Field("FileInfo.FileHandle").GetPtr();
    ULONG64 FileObject = CacheEntry.Field("FileInfo.FileObject").GetPtr();

    g_Ext->Dml("    CacheIndex: %d# Store Manager cache file size = %I64d bytes (%d Mb) (%d Gb)\n",
        CacheIndex,
        CacheFileSize,
        CacheFileSize / (1024 * 1024),
        CacheFileSize / (1024 * 1024 * 1024));
    g_Ext->Dml("    Handle: <link cmd=\"!handle 0x%I64X\">0x%I64X</link>\n"
               "    FileObject: <link cmd=\"!fileobj 0x%I64X\">0x%I64X</link> (<link cmd=\"dt nt!_FILE_OBJECT 0x%I64X -b\">more</link>)\n",
               FileHandle, FileHandle,
               FileObject, FileObject, FileObject);
    g_Ext->Dml("    ID: %ws\n\n", CacheEntry.Field("UniqueId").GetString(UniqueId, _countof(UniqueId)));

    return TRUE;
}

VOID
StoreManager::SmiEnumCaches(
    ULONG CacheIndex
)
/*++

Routine Description:

    Description.

Arguments:

    CacheIndex - 

Return Value:

    None.

--*/
{
    ULONG Index;

    if (CacheIndex == (ULONG)-1)
    {
        for (Index = 0; Index < SM_STORES_MAX; Index += 1)
        {
            SmiDisplayCacheInformation(m_SmGlobalsAddress + m_SmcCacheMgrOffset, Index);
        }
    }
    else
    {
        if (SmiDisplayCacheInformation(m_SmGlobalsAddress + m_SmcCacheMgrOffset, CacheIndex) == FALSE)
        {
            g_Ext->Warn("-> No Store Manager associated to this ID.\n");
        }
    }
}

```

`SwishDbgExt/Storage.h`:

```h
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    Module Name:

    - Storage.h

    Abstract:

    - http://msdn.microsoft.com/en-us/windows/ff553536(v=vs.71).aspx

    Environment:

    - User mode

    Revision History:

    - Matthieu Suiche

--*/

class StoreManager {
public:
    #define SM_LOG_CTX_OFFSET_X64 0x880
    #define SMC_CACHE_MGR_OFFSET_X64 0x9a0

    #define SM_LOG_CTX_OFFSET_X86 0x510
    #define SMC_CACHE_MGR_OFFSET_X86 0x5b4

    #define SM_LOG_ENTRY32_PAGECOUNT_BITS ((sizeof(ULONG32) * 8) - 16)
    #define SM_LOG_ENTRY64_PAGECOUNT_BITS ((sizeof(ULONG64) * 8) - 16)

    #define SM_STORES_MAX (1 << 3)

    //
    // Structures
    //

    #define SMP_LB_ENTRY_COUNT_BITS 16

    typedef struct _SMC_CACHE {
        ULONG CacheId;
        ULONG u000[3];
        ULONG CacheFileSize;
        ULONG u014[5];
        ULONG FileHandle;
        ULONG FileObject;
        UCHAR u030[0x14c];
        WCHAR UniqueId[256];
    } SMC_CACHE, *PSMC_CACHE;

    typedef struct _SMC_CACHE_REF {
        ULONG_PTR Cache;
        ULONG_PTR RefCount; // not used in sminfo.
        ULONG_PTR AddRemoveLock; // not used in sminfo.
        ULONG SeqNumber; // not used in sminfo.
    } SMC_CACHE_REF, *PSMC_CACHE_REF;

    typedef struct _SMP_LOG_BUFFER32 {
        ULONG32 Link; // SINGLE_LIST_ENTRY
        ULONG EntryCount:SMP_LB_ENTRY_COUNT_BITS;
        ULONG EntryMax:SMP_LB_ENTRY_COUNT_BITS;
    } SMP_LOG_BUFFER32, *PSMP_LOG_BUFFER32;

    typedef struct _SMP_LOG_BUFFER64 {
        ULONG64 Link; // SINGLE_LIST_ENTRY
        ULONG EntryCount:SMP_LB_ENTRY_COUNT_BITS;
        ULONG EntryMax:SMP_LB_ENTRY_COUNT_BITS;
    } SMP_LOG_BUFFER64, *PSMP_LOG_BUFFER64;

    typedef enum _SM_LOG_ENTRY_TYPE {
        SmLogAdd,
        SmLogRemove,
        SmLogFull,
        SmLogStoreUpdate,
        SmLogEntryTypeMax
    } SM_LOG_ENTRY_TYPE, *PSM_LOG_ENTRY_TYPE;

    typedef union _SM_LOG_ENTRY_FLAGS {
        struct {
            ULONG Type:2;
            ULONG Priority:3;
            ULONG DidNotCompress:1;
            ULONG Spare:2;
            ULONG StoreSet:SM_STORES_MAX;
        };

        struct {
            ULONG OverlapsWithType:2;
            ULONG Empty:1;
            ULONG Spare1:5;
            ULONG OverlapsWithStoreSet:SM_STORES_MAX;
        };
    } SM_LOG_ENTRY_FLAGS, *PSM_LOG_ENTRY_FLAGS;

    typedef enum _SM_PAGE_TYPE {
        SmPageTypeProcess = 0,
        SmPageTypeSession,
        SmPageTypeSystem,
        SmPageTypeSection,
        SmPageTypeMax
    } SM_PAGE_TYPE, *PSM_PAGE_TYPE;

    typedef struct _SM_PAGE_KEY_DESCRIPTOR32 {
        union {
            struct {
                ULONG32 ProcessKey;
                ULONG32 VirtualAddress;
            };
            struct {
                ULONG32 PageType:2;
                ULONG32 Spare:1;
            } Flags;
        };
    } SM_PAGE_KEY_DESCRIPTOR32, *PSM_PAGE_KEY_DESCRIPTOR32;

    typedef struct _SM_LOG_ENTRY32 {
        SM_PAGE_KEY_DESCRIPTOR32 KeyDescriptor;
        union {
            SM_LOG_ENTRY_FLAGS Flags;
            struct {
                ULONG32 AllFlags:16;
                ULONG32 PageCount:SM_LOG_ENTRY32_PAGECOUNT_BITS;
            };
        };
    } SM_LOG_ENTRY32, *PSM_LOG_ENTRY32;

    typedef struct _SM_PAGE_KEY_DESCRIPTOR64 {
        union {
            struct {
                ULONG64 ProcessKey;
                ULONG64 VirtualAddress;
            };

            struct {
                ULONG PageType:2;
                ULONG Spare:1;
            } Flags;
        };
    } SM_PAGE_KEY_DESCRIPTOR64, *PSM_PAGE_KEY_DESCRIPTOR64;

    typedef struct _SM_LOG_ENTRY64 {
        SM_PAGE_KEY_DESCRIPTOR64 KeyDescriptor;
        union {
            SM_LOG_ENTRY_FLAGS Flags;
            struct {
                ULONG64 AllFlags:16;
                ULONG64 PageCount:SM_LOG_ENTRY64_PAGECOUNT_BITS;
            };
        };
    } SM_LOG_ENTRY64, *PSM_LOG_ENTRY64;

    vector<SM_LOG_ENTRY64> SmLogEntries;

    StoreManager();

    BOOLEAN GetSmLogEntries();
    BOOL
    SmiDisplayCacheInformation(
        ULONG64 CacheManager,
        ULONG CacheIndex
    );

    VOID
    SmiEnumCaches(
        ULONG CacheIndex
    );

    ULONG m_SmLogCtxOffset;
    ULONG m_SmcCacheMgrOffset;
    ULONG m_SmpLogBufferSize;
    ULONG m_SmLogEntrySize;
    ULONG64 m_SmGlobalsAddress;
};
```

`SwishDbgExt/SwishDbgExt.cpp`:

```cpp
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2018 Comae Technologies DMCC
    Copyright (C) 2014-2018 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - SwishDbgExt.cpp
    - Codename: SOCOTRA

Abstract:

    - http://msdn.microsoft.com/en-us/windows/ff553536(v=vs.71).aspx
    - TODO: set symbols noisy


Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#include "stdafx.h"
#include "SwishDbgExt.h"

#ifdef _VERBOSE
BOOLEAN g_Verbose = TRUE;
#else
BOOLEAN g_Verbose = FALSE;
#endif


ULONG64 KeNumberProcessorsAddress;
ULONG64 KiProcessorBlockAddress;
ULONG64 ObpRootDirectoryObjectAddress;
ULONG64 ObTypeIndexTableAddress;
ULONG64 ObHeaderCookieAddress;
ULONG64 CmpRegistryRootObjectAddress;
ULONG64 CmpMasterHiveAddress;


class EXT_CLASS : public ExtExtension
{
public:
    EXT_COMMAND_METHOD(ms_dump);
    EXT_COMMAND_METHOD(ms_readkcb);
    EXT_COMMAND_METHOD(ms_readknode);
    EXT_COMMAND_METHOD(ms_readkvalue);

    EXT_COMMAND_METHOD(ms_netstat);

    EXT_COMMAND_METHOD(ms_object);

    EXT_COMMAND_METHOD(ms_timers);
    EXT_COMMAND_METHOD(ms_vacbs);

    EXT_COMMAND_METHOD(ms_hivelist);
    EXT_COMMAND_METHOD(ms_drivers);

    EXT_COMMAND_METHOD(ms_process);
    // EXT_COMMAND_METHOD(ms_handles);
    // EXT_COMMAND_METHOD(ms_dlls);
    // EXT_COMMAND_METHOD(ms_vads);
    // EXT_COMMAND_METHOD(ms_iat);
    // EXT_COMMAND_METHOD(ms_eat);


    EXT_COMMAND_METHOD(ms_credentials);

    EXT_COMMAND_METHOD(ms_consoles);

    EXT_COMMAND_METHOD(ms_ssdt);
    EXT_COMMAND_METHOD(ms_idt);
    EXT_COMMAND_METHOD(ms_gdt);
    EXT_COMMAND_METHOD(ms_mbr);

    EXT_COMMAND_METHOD(ms_callbacks);
    // EXT_COMMAND_METHOD(ms_drivers);
    // EXT_COMMAND_METHOD(ms_irp);
    // EXT_COMMAND_METHOD(ms_timers);

    EXT_COMMAND_METHOD(ms_services);

    // EXT_COMMAND_METHOD(ms_smlog);
    // EXT_COMMAND_METHOD(ms_smcache);
    EXT_COMMAND_METHOD(ms_sockets);

    EXT_COMMAND_METHOD(ms_malscore);

    EXT_COMMAND_METHOD(ms_exqueue);

    EXT_COMMAND_METHOD(ms_store);

    EXT_COMMAND_METHOD(ms_scanndishook);

    // EXT_COMMAND_METHOD(ms_strings);

    // EXT_COMMAND_METHOD(ms_virustotal);

    // EXT_COMMAND_METHOD(ms_analyze); // !ms_analyze -v

    EXT_COMMAND_METHOD(ms_checkcodecave);
    EXT_COMMAND_METHOD(ms_verbose);
    EXT_COMMAND_METHOD(ms_fixit);

    EXT_COMMAND_METHOD(ms_lxss);

    EXT_COMMAND_METHOD(ms_yarascan);
    EXT_COMMAND_METHOD(ms_regcheck);
    EXT_COMMAND_METHOD(ms_pools);

    HRESULT
    Initialize(void)
    {
        PDEBUG_CLIENT DebugClient;
        PDEBUG_CONTROL DebugControl;
        HRESULT Result = S_OK;

        DebugCreate(__uuidof(IDebugClient), (void **)&DebugClient);

        DebugClient->QueryInterface(__uuidof(IDebugControl), (void **)&DebugControl);

        ExtensionApis.nSize = sizeof (ExtensionApis);
        DebugControl->GetWindbgExtensionApis64(&ExtensionApis);

        dprintf("       SwishDbgExt %s - Incident Response & Digital Forensics Debugging Extension\n"
                "       SwishDbgExt Copyright (C) 2018 Comae Technologies DMCC - www.comae.com\n"
                "       SwishDbgExt Copyright (C) 2014-2018 Matthieu Suiche (@msuiche)\n\n"
                "       This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n"
                "       This is free software, and you are welcome to redistribute it\n"
                "       under certain conditions; type `show c' for details.\n",
                COMAE_TOOLKIT_VERSION);

        KeNumberProcessorsAddress = GetExpression("nt!KeNumberProcessors");
        KiProcessorBlockAddress = GetExpression("nt!KiProcessorBlock");

        ObpRootDirectoryObjectAddress = GetExpression("nt!ObpRootDirectoryObject");
        ObTypeIndexTableAddress = GetExpression("nt!ObTypeIndexTable");
        ObHeaderCookieAddress = GetExpression("nt!ObHeaderCookie");

        CmpRegistryRootObjectAddress = GetExpression("nt!CmpRegistryRootObject");
        CmpMasterHiveAddress = GetExpression("nt!CmpMasterHive");

        DebugControl->Release();
        DebugClient->Release();

        return Result;
    }
};

EXT_DECLARE_GLOBALS();

EXT_COMMAND(ms_process,
    "Display list of processes",
    "{;e,o;;}"
    "{pid;ed,o;pid;Display process information for a given Process Id}"
    "{handletype;s,o;handletype;Display handles belonging to process\ntype (optional) - Object type to filter (e.g. Mutant or Key)}"
    "{handletable;ed,d=0;handletable;Handle table \ntype (optional)}"
    "{dlls;b,o;dlls;Display dlls belonging to process}"
    // "{dlls_exports;b,o;dlls exports;Display exports belonging to each dlls}"
    "{handles;b,o;handles;Display handles belonging to process}"
    "{threads;b,o;threads;Display threads belonging to process}"
    "{vads;b,o;vads;Display VADs belonging to process}"
    "{vars;b,o;vars;Display environment variables}"
    "{exports;b,o;exports;Display exports belonging to process}"
    "{all;b,o;all;Display or scan all}"
    "{scan;b,o;scan;Display only malicious artifacts}"
    )
{
    ULONG Flags = 0;
    ULONG64 Pid;
    BOOLEAN bScan = FALSE;

    Pid = GetArgU64("pid", FALSE);
    LPCSTR HandlesArg = GetArgStr("handletype", FALSE);
    ULONG64 HandleTable = GetArgU64("handletable", FALSE);

    if (HandlesArg || HandleTable) Flags |= PROCESS_HANDLES_FLAG;

    if (HasArg("vars"))    Flags |= PROCESS_ENVVAR_FLAG;
    if (HasArg("threads")) Flags |= PROCESS_THREADS_FLAG;
    if (HasArg("vads"))    Flags |= PROCESS_VADS_FLAG;
    if (HasArg("dlls"))    Flags |= PROCESS_DLLS_FLAG;
    if (HasArg("handles")) Flags |= PROCESS_HANDLES_FLAG;

    // if (HasArg("dlls_exports")) Flags |= PROCESS_DLLS_FLAG | PROCESS_DLL_EXPORTS_FLAG;

    if (HasArg("exports"))
    {
        Flags |= PROCESS_EXPORTS_FLAG;
        if (Flags & PROCESS_DLLS_FLAG) Flags |= PROCESS_DLL_EXPORTS_FLAG;
    }

    if (HasArg("all"))
    {
        Flags |= PROCESS_EXPORTS_FLAG | PROCESS_DLLS_FLAG | PROCESS_DLL_EXPORTS_FLAG | PROCESS_VADS_FLAG;
        Flags |= PROCESS_ENVVAR_FLAG;
        Flags |= PROCESS_THREADS_FLAG;
        Flags |= PROCESS_HANDLES_FLAG;
    }

    if (HasArg("scan"))
    {
        bScan = TRUE;
        Flags |= PROCESS_SCAN_MALICIOUS_FLAG;

        Flags &= ~PROCESS_ENVVAR_FLAG;
        Flags &= ~PROCESS_THREADS_FLAG;
        Flags &= ~PROCESS_HANDLES_FLAG;
    }

    ProcessArray CachedProcessList = GetProcesses(Pid, Flags);

    for each (MsProcessObject ProcObj in CachedProcessList) {

        Dml("\n<col fg=\"changed\">Process:</col>       <link cmd=\"!process %p 1\">%-20s</link> (PID=0x%04x [%d]) | "
            "[<link cmd=\"!ms_process /pid 0x%I64X /dlls\">+Dlls</link>] "
            "[<link cmd=\"!ms_process /pid 0x%I64X /dlls /exports\">+Exports</link>] "
            "[<link cmd=\"!ms_process /pid 0x%I64X /handles\">+Handles</link>] "
            "[<link cmd=\"!ms_process /pid 0x%I64X /threads\">+Threads</link>] "
            "[<link cmd=\"!ms_process /pid 0x%I64X /vads\">+VADs</link>] "
            "[<link cmd=\"!ms_process /pid 0x%I64X /all /scan\">+Scan</link>] "
            "[<link cmd=\".process /p /r 0x%016I64X \">+Select context</link>] "
            "\n",
            ProcObj.m_CcProcessObject.ProcessObjectPtr, ProcObj.m_CcProcessObject.ImageFileName,
            (ULONG)ProcObj.m_CcProcessObject.ProcessId, (ULONG)ProcObj.m_CcProcessObject.ProcessId,
            ProcObj.m_CcProcessObject.ProcessId,
            ProcObj.m_CcProcessObject.ProcessId,
            ProcObj.m_CcProcessObject.ProcessId,
            ProcObj.m_CcProcessObject.ProcessId,
            ProcObj.m_CcProcessObject.ProcessId,
            ProcObj.m_CcProcessObject.ProcessId,
            ProcObj.m_CcProcessObject.ProcessObjectPtr);

		Dml("    <col fg=\"emphfg\">ImageBase:</col> 0x%I64X <col fg=\"emphfg\">ImageSize:</col> 0x%I64X (IsPagedOut = %s, IsSigned = %d)\n",
			ProcObj.m_ImageBase, ProcObj.m_ImageSize, ProcObj.m_IsPagedOut ? "True" : "False", ProcObj.m_IsSigned ? "True" : "False");

        if (wcslen(ProcObj.m_CcProcessObject.FullPath)) Dml("    <col fg=\"emphfg\">Path:          </col> %S\n", ProcObj.m_CcProcessObject.FullPath);
        if (strlen(ProcObj.m_PdbInfo.PdbName)) Dml("    <col fg=\"emphfg\">PDB:           </col> %s\n", ProcObj.m_PdbInfo.PdbName);
        if (wcslen(ProcObj.m_FileVersion.CompanyName)) Dml("    <col fg=\"emphfg\">Vendor:        </col> %S\n", ProcObj.m_FileVersion.CompanyName);
        if (wcslen(ProcObj.m_FileVersion.FileVersion)) Dml("    <col fg=\"emphfg\">Version:       </col> %S\n", ProcObj.m_FileVersion.FileVersion);
        if (wcslen(ProcObj.m_FileVersion.FileDescription)) Dml("    <col fg=\"emphfg\">Description:   </col> %S\n", ProcObj.m_FileVersion.FileDescription);
        if (ProcObj.m_CcProcessObject.CommandLine) Dml("    <col fg=\"emphfg\">Commandline:   </col> %S\n", ProcObj.m_CcProcessObject.CommandLine);

        Dml("    <col fg=\"emphfg\">Sections:</col>      ");

        for each (MsPEImageFile::CACHED_SECTION_INFO Section in ProcObj.m_CcSections) {

            Dml("%s, ", Section.Name);
        }

        Dml("\n");

        if (ProcObj.m_TypedObject.HasField("Flags2.ProtectedProcess")) {

            // Windows Vista+
        }
        else if (ProcObj.m_TypedObject.HasField("Protection")) {

            // Windows 8.1
        }

        if (Flags & PROCESS_ENVVAR_FLAG) {

            for each (MsProcessObject::ENV_VAR_OBJECT EnvVar in ProcObj.m_EnvVars) {

                Dml("    %S\n", EnvVar.Variable);
            }
        }

        if ((Flags & PROCESS_EXPORTS_FLAG) && (
            ((Flags & PROCESS_SCAN_MALICIOUS_FLAG) && ProcObj.m_NumberOfHookedAPIs) ||
            (!(Flags & PROCESS_SCAN_MALICIOUS_FLAG) && ProcObj.m_NumberOfExportedFunctions))) {

            Dml("    |------|------|--------------------|----------------------------------------------------|---------|\n"
                "    | <col fg=\"emphfg\">%-4s</col> | <col fg=\"emphfg\">%-4s</col> | <col fg=\"emphfg\">%-18s</col> | <col fg=\"emphfg\">%-50s</col> | <col fg=\"emphfg\">%-7s</col> | <col fg=\"emphfg\">%-6s</col> |\n"
                "    |------|------|--------------------|----------------------------------------------------|---------|\n",
                "Indx", "Ord", "Addr", "Name", "Patched", "Hooked");

            for each (MsPEImageFile::EXPORT_INFO ExportInfo in ProcObj.m_Exports) {

                ULONG64 Ptr = ExportInfo.AddressInfo.Address;

                if (!(Flags & PROCESS_SCAN_MALICIOUS_FLAG) ||
                    ((Flags & PROCESS_SCAN_MALICIOUS_FLAG) && (ExportInfo.AddressInfo.IsTablePatched || ExportInfo.AddressInfo.HookType))) {

                    Dml((ExportInfo.AddressInfo.IsTablePatched || ExportInfo.AddressInfo.HookType) ?
                        "    | %4d | %4d | <link cmd=\"u 0x%016I64X L1\">0x%016I64X</link> | <col fg=\"changed\">%-50s</col> | <col fg=\"changed\">%-7s</col> | <col fg=\"changed\">%-6s</col>\n" :
                        "    | %4d | %4d | <link cmd=\"u 0x%016I64X L1\">0x%016I64X</link> | %-50s | <col fg=\"changed\">%-7s</col> | <col fg=\"changed\">%-6s</col>\n",
                        ExportInfo.Index, ExportInfo.Ordinal,
                        Ptr, Ptr, ExportInfo.Name,
                        ExportInfo.AddressInfo.IsTablePatched ? "Yes" : "",
                        ExportInfo.AddressInfo.HookType ? "Yes" : "");
                }
            }

            g_Ext->Dml("\n");
        }

        int i = 0;

        for each (MsDllObject DllObj in ProcObj.m_DllList) {

            Dml("    -> [%3d]: (%s) %S (ImageBase: 0x%I64X, ImageSize: 0x%I64X)\n",
                i,
                DllObj.mm_CcDllObject.IsWow64 ? "<col fg=\"changed\">Wow64</col>" : "     ",
                DllObj.mm_CcDllObject.FullDllName,
				DllObj.m_ImageBase, DllObj.m_ImageSize);

            i += 1;

            if ((Flags & PROCESS_DLL_EXPORTS_FLAG) && (
                ((Flags & PROCESS_SCAN_MALICIOUS_FLAG) && DllObj.m_NumberOfHookedAPIs) ||
                (!(Flags & PROCESS_SCAN_MALICIOUS_FLAG) && DllObj.m_NumberOfExportedFunctions))) {

                Dml("    |------|------|--------------------|----------------------------------------------------|---------|\n"
                    "    | <col fg=\"emphfg\">%-4s</col> | <col fg=\"emphfg\">%-4s</col> | <col fg=\"emphfg\">%-18s</col> | <col fg=\"emphfg\">%-50s</col> | <col fg=\"emphfg\">%-7s</col> | <col fg=\"emphfg\">%-6s</col> |\n"
                    "    |------|------|--------------------|----------------------------------------------------|---------|\n",
                    "Indx", "Ord", "Addr", "Name", "Patched", "Hooked");

                for each (MsPEImageFile::EXPORT_INFO ExportInfo in DllObj.m_Exports) {

                    ULONG64 Ptr = ExportInfo.AddressInfo.Address;

                    if (!(Flags & PROCESS_SCAN_MALICIOUS_FLAG) ||
                        ((Flags & PROCESS_SCAN_MALICIOUS_FLAG) && (ExportInfo.AddressInfo.IsTablePatched || ExportInfo.AddressInfo.HookType))) {

                        Dml((ExportInfo.AddressInfo.IsTablePatched || ExportInfo.AddressInfo.HookType) ?
                            "    | %4d | %4d | <link cmd=\"u 0x%016I64X L1\">0x%016I64X</link> | <col fg=\"changed\">%-50s</col> | <col fg=\"changed\">%-7s</col> | <col fg=\"changed\">%-6s</col>\n" :
                            "    | %4d | %4d | <link cmd=\"u 0x%016I64X L1\">0x%016I64X</link> | %-50s | <col fg=\"changed\">%-7s</col> | <col fg=\"changed\">%-6s</col>\n",
                            ExportInfo.Index, ExportInfo.Ordinal,
                            Ptr, Ptr, ExportInfo.Name,
                            ExportInfo.AddressInfo.IsTablePatched ? "Yes" : "",
                            ExportInfo.AddressInfo.HookType ? "Yes" : "");

                        if ((Flags & PROCESS_SCAN_MALICIOUS_FLAG) && ExportInfo.AddressInfo.HookType) {

                            ExecuteSilent(".process /p /r 0x%I64X", ProcObj.m_CcProcessObject.ProcessObjectPtr);
                            Execute("u 0x%I64X L3", Ptr);
                        }
                    }
                }

                Dml("\n");
            }
        }

        if (Flags & PROCESS_HANDLES_FLAG) {

            ProcObj.GetHandles(HandleTable);

            WCHAR ArgType[64] = {0};

            Dml("\n"
                "    |------|----------------------|--------------------|---------------------------------------------------------------------------|\n"
                "    | <col fg=\"emphfg\">%-4s</col> | <col fg=\"emphfg\">%-20s</col> | <col fg=\"emphfg\">%-18s</col> | <col fg=\"emphfg\">%-256s</col> |\n"
                "    |------|----------------------|--------------------|---------------------------------------------------------------------------|\n",
                "Hdle", "Object Type", "Addr", "Name");

            if (HandlesArg) {

                StringCchPrintfW(ArgType, _countof(ArgType), L"%S", HandlesArg);
            }

            for each (HANDLE_OBJECT Handle in ProcObj.m_Handles) {

                if (HandlesArg && wcslen(ArgType) && (_wcsicmp(ArgType, Handle.Type) != 0)) {

                    continue;
                }

                if (_wcsicmp(Handle.Type, L"Key") == 0) {

                    Dml("    | %04x | %-20S | <link cmd=\"!ms_readkcb 0x%016I64X\">0x%016I64X</link> | %-256S | \n",
                        Handle.Handle, Handle.Type, Handle.ObjectKcb, Handle.ObjectPtr, Handle.Name);
                }
                else if (_wcsicmp(Handle.Type, L"Directory") == 0) {

                    Dml("    | %04x | %-20S | <link cmd=\"!ms_object 0x%016I64X\">0x%016I64X</link> | %-256S | \n",
                        Handle.Handle, Handle.Type, Handle.ObjectPtr, Handle.ObjectPtr, Handle.Name);
                }
                else {

                    Dml("    | %04x | %-20S | <link cmd=\"!object 0x%016I64X\">0x%016I64X</link> | %-256S | \n",
                        Handle.Handle, Handle.Type, Handle.ObjectPtr, Handle.ObjectPtr, Handle.Name);
                }
            }

            Dml("\n");
        }

        if (Flags & PROCESS_VADS_FLAG) {

            ProcObj.MmGetVads();

            Dml("\n"
                "    |----------------------|----------|--------------------|--------------------|---------------------------------------------------------------------------|\n"
                "    | <col fg=\"emphfg\">%-20s</col> | <col fg=\"emphfg\">%-8s</col> | <col fg=\"emphfg\">%-18s</col> | <col fg=\"emphfg\">%-18s</col> | <col fg=\"emphfg\">%-256s</col> |\n"
                "    |----------------------|----------|--------------------|--------------------|---------------------------------------------------------------------------|\n",
                "Protection", "MalScore", "Start range", "End range", "FileObject");

            for each (VAD_OBJECT Vad in ProcObj.m_Vads) {

                HANDLE_OBJECT Handle = {0};
                CHAR Protection[22] = {0};
                ULONG MalScore = 0;
                BOOLEAN FoResult = ObReadObject(Vad.FileObject, &Handle);

                switch (Vad.Protection) {

                case MM_READONLY:
                    StringCchCopyA(Protection, _countof(Protection), "MM_READONLY");
                    break;
                case MM_EXECUTE:
                    StringCchCopyA(Protection, _countof(Protection), "MM_EXECUTE");
                    break;
                case MM_EXECUTE_READ:
                    StringCchCopyA(Protection, _countof(Protection), "MM_EXECUTE_READ");
                    break;
                case MM_READWRITE:
                    StringCchCopyA(Protection, _countof(Protection), "MM_READWRITE");
                    break;
                case MM_WRITECOPY:
                    StringCchCopyA(Protection, _countof(Protection), "MM_WRITECOPY");
                    break;
                case MM_EXECUTE_READWRITE:
                    StringCchCopyA(Protection, _countof(Protection), "MM_EXECUTE_READWRITE");
                    break;
                case MM_EXECUTE_WRITECOPY:
                    StringCchCopyA(Protection, _countof(Protection), "MM_EXECUTE_WRITECOPY");
                    break;
                }

                ULONG VadSize = (ULONG)((Vad.EndingVpn - Vad.StartingVpn) * PAGE_SIZE);
                ULONG64 BaseAddress = Vad.StartingVpn * PAGE_SIZE;

                if (bScan) {

                    MalScore = GetMalScoreEx(FALSE, &ProcObj, BaseAddress, VadSize);
                }

                Dml("    | %-20s | <link cmd=\"!ms_malscore 0x%016I64X 0x%X\">%8d</link> | 0x%016I64X | 0x%016I64X | (0x%016I64X) %S |\n",
                    Protection,
                    BaseAddress, VadSize, MalScore,
                    Vad.StartingVpn * PAGE_SIZE,
                    Vad.EndingVpn * PAGE_SIZE,
                    Vad.FileObject,
                    FoResult ? Handle.Name : L"");
            }

            ReleaseObjectTypeTable();
        }

        if (Flags & PROCESS_THREADS_FLAG) {

            ProcObj.GetThreads();

            Dml("    |--------|--------|--------------------|----------------------------------------------------|---------------------|---------------------|\n"
                "    | <col fg=\"emphfg\">%-6s</col> | <col fg=\"emphfg\">%-6s</col> | <col fg=\"emphfg\">%-18s</col> | <col fg=\"emphfg\">%-50s</col> | Create time         | Exit time           |\n"
                "    |--------|--------|--------------------|----------------------------------------------------|---------------------|---------------------|\n",
                "Proc", "Thrd", "Addr", "Name");

            for each (THREAD_OBJECT Thread in ProcObj.m_Threads) {

                UCHAR Name[512] = {0};
                SYSTEMTIME CreateTime = {0}, ExitTime = {0};

                if (Thread.Win32StartAddress) {

                    g_Ext->ExecuteSilent(".process /p /r 0x%I64X", ProcObj.m_CcProcessObject.ProcessObjectPtr);

                    FileTimeToSystemTime((FILETIME *)&Thread.CreateTime, &CreateTime);
                    FileTimeToSystemTime((FILETIME *)&Thread.ExitTime, &ExitTime);

                    Dml("    | 0x%04x | 0x%04x | <link cmd=\"u 0x%016I64X L3\">0x%016I64X</link> | %-50s | %02d/%02d/%4d %02d:%02d:%02d | %02d/%02d/%4d %02d:%02d:%02d |\n",
                        (ULONG)Thread.ProcessId, (ULONG)Thread.ThreadId, Thread.Win32StartAddress, Thread.Win32StartAddress,
                        GetNameByOffset(Thread.Win32StartAddress, (PSTR)Name, _countof(Name)),
                        CreateTime.wDay, CreateTime.wMonth, CreateTime.wYear, CreateTime.wHour, CreateTime.wMinute, CreateTime.wSecond,
                        ExitTime.wDay, ExitTime.wMonth, ExitTime.wYear, ExitTime.wHour, ExitTime.wMinute, ExitTime.wSecond);
                }
            }
        }
    }
}

EXT_COMMAND(ms_object,
           "Display list of object",
           "{;ed,d=0;object;Object directory}")
{
    ULONG64 Object = GetUnnamedArgU64(0);
    HANDLE_OBJECT Handle = {0};

    vector<HANDLE_OBJECT> Handles = ObOpenObjectDirectory(Object);

    if (Object)
    {
        ObReadObject(Object, &Handle);
        Dml("\n    Object: %S (%S)", Handle.Name, Handle.Type);

        if (_wcsicmp(Handle.Type, L"Directory") != 0) return;
    }
    else
    {
        Dml("\n    Object: \\ (Directory)");
    }

    Dml("\n"
        "    |------|----------------------|--------------------|---------------------------------------------------------------------------|\n"
        "    | <col fg=\"emphfg\">%-4s</col> | <col fg=\"emphfg\">%-20s</col> | <col fg=\"emphfg\">%-18s</col> | <col fg=\"emphfg\">%-256s</col> |\n"
        "    |------|----------------------|--------------------|---------------------------------------------------------------------------|\n",
        "Hdle", "Object Type", "Addr", "Name");

    for each (Handle in Handles)
    {
        if (_wcsicmp(Handle.Type, L"Key") == 0)
        {
            Dml("    | %04x | %-20S | <link cmd=\"!ms_readkcb 0x%016I64X\">0x%016I64X</link> | %-256S | \n",
                Handle.Handle, Handle.Type, Handle.ObjectKcb, Handle.ObjectPtr, Handle.Name);
        }
        else if (_wcsicmp(Handle.Type, L"Directory") == 0)
        {
            Dml("    | %04x | %-20S | <link cmd=\"!ms_object 0x%016I64X\">0x%016I64X</link> | %-256S | \n",
                Handle.Handle, Handle.Type, Handle.ObjectPtr, Handle.ObjectPtr, Handle.Name);
        }
        else if (_wcsicmp(Handle.Type, L"File") == 0)
        {
            Dml("    | %04x | %-20S | <link cmd=\"!fileobj 0x%016I64X\">0x%016I64X</link> | %-256S | \n",
                Handle.Handle, Handle.Type, Handle.ObjectPtr, Handle.ObjectPtr, Handle.Name);
        }
        else
        {
            Dml("    | %04x | %-20S | <link cmd=\"!object 0x%016I64X\">0x%016I64X</link> | %-256S | \n",
                Handle.Handle, Handle.Type, Handle.ObjectPtr, Handle.ObjectPtr, Handle.Name);
        }
    }
    Dml("    |------|----------------------|--------------------|---------------------------------------------------------------------------|\n");
    Dml("\n");

    ReleaseObjectTypeTable();
}

EXT_COMMAND(ms_drivers,
    "Display list of drivers",
    "{;e,o;;}"
    "{object;ed,o;drvobj;Display driver information for a given driven object}"
    "{scan;b,o;scan;Display only malicious artifacts}")
{
    ULONG64 DrvObj = GetArgU64("object", FALSE);
    BOOLEAN Scan = HasArg("scan");

    vector<MsDriverObject> Drivers = GetDrivers();

    for each (MsDriverObject Driver in Drivers)
    {
        if (DrvObj && (Driver.m_ObjectPtr != DrvObj)) continue;

        OutDriver(&Driver, (DrvObj || Scan) ? TRUE : FALSE);
    }

    ReleaseObjectTypeTable();
}

EXT_COMMAND(ms_services,
    "Display list of services",
    "{;e,o;;}")
{
    vector<SERVICE_ENTRY> Services = GetServices();
    UINT Index = 0;

    Dml("   Additional information (Registry): <link cmd=\"!reg findkcb %s\">%s</link> (Use KCB addr with \"!ms_readkcb\")\n",
        "\\REGISTRY\\MACHINE\\SYSTEM\\CONTROLSET001\\SERVICES",
        "\\REGISTRY\\MACHINE\\SYSTEM\\CONTROLSET001\\SERVICES");

    for each (SERVICE_ENTRY ServiceEntry in Services) {

        if (ServiceEntry.ServiceStatus.dwServiceType == SERVICE_KERNEL_DRIVER) {

            Dml("\n[%3d] | 0x%02X |           | <col fg=\"changed\">%-32S</col> | %-50S | %-20s | %-16s | %-30S | %-128S",
                Index,
                ServiceEntry.ServiceStatus.dwServiceType,
                ServiceEntry.Name,
                ServiceEntry.Desc,
                GetServiceStartType(ServiceEntry.StartType),
                GetServiceState(ServiceEntry.ServiceStatus.dwCurrentState),
                ServiceEntry.AccountName,
                ServiceEntry.CommandLine);
        }
        else if ((ServiceEntry.ServiceStatus.dwServiceType == SERVICE_WIN32_OWN_PROCESS) ||
                 (ServiceEntry.ServiceStatus.dwServiceType == SERVICE_WIN32_SHARE_PROCESS)) {

            Dml("\n[%3d] | 0x%02X | <link cmd=\"!process %x 1\">Pid=0x%x</link> | <col fg=\"changed\">%-32S</col> | %-50S | %-20s | %-16s | %-30S | %-128S",
                Index,
                ServiceEntry.ServiceStatus.dwServiceType,
                ServiceEntry.ProcessId,
                ServiceEntry.ProcessId,
                ServiceEntry.Name,
                ServiceEntry.Desc,
                GetServiceStartType(ServiceEntry.StartType),
                GetServiceState(ServiceEntry.ServiceStatus.dwCurrentState),
                ServiceEntry.AccountName,
                ServiceEntry.CommandLine);
        }

        Index += 1;
    }

    Dml("\n");
}

EXT_COMMAND(ms_callbacks,
            "Display callback functions",
            "{;e,o;;}")
{
    ULONG64 Offset;
    ULONG BuildNumber;
    ULONG64 ObjectTypesPtr = 0;

    CHAR Buffer[256] = {0};

    if (g_Ext->m_Symbols->GetOffsetByName("nt!NtBuildNumber", &Offset) != S_OK) goto Exit;
    if (g_Ext->m_Data->ReadVirtual(Offset, (PUCHAR)&BuildNumber, sizeof(BuildNumber), NULL) != S_OK) goto Exit;

    if (g_Ext->m_Symbols->GetOffsetByName("nt!IopFsNotifyChangeQueueHead", &Offset) == S_OK)
    {
        // typedef struct _FS_CHANGE_NOTIFY_ENTRY
        // {
        //      LIST_ENTRY FsChangeNotifyList;
        //      PDRIVER_OBJECT DriverObject;
        //      PDRIVER_FS_NOTIFICATION FSDNotificationProc;
        // } FS_CHANGE_NOTIFY_ENTRY, *PFS_CHANGE_NOTIFY_ENTRY;

        ExtRemoteTypedList IopFsNotifyChangeQueueHead(Offset, "nt!_LIST_ENTRY", "Flink");

        Dml("\n<col fg=\"changed\">[*] IopFsNotifyChangeQueueHead:</col>\n");

        for (IopFsNotifyChangeQueueHead.StartHead();
             IopFsNotifyChangeQueueHead.HasNode();
             IopFsNotifyChangeQueueHead.Next())
        {
            ULONG64 Node = IopFsNotifyChangeQueueHead.GetNodeOffset();
            ULONG TypeSize;
            ULONG64 DrvObj, NotificationProc;

            TypeSize = GetTypeSize("nt!_LIST_ENTRY");

            ReadPointer(Node + TypeSize, &DrvObj);
            ReadPointer(Node + TypeSize + m_PtrSize, &NotificationProc);

            Dml("     Object: 0x%016I64X "
                "Driver Object: <link cmd=\"dt nt!_DRIVER_OBJECT 0x%016I64X\">0x%016I64X</link> "
                "Procedure: <link cmd=\"u 0x%016I64X L5\">0x%016I64X</link> (%s) \n",
                Node, DrvObj, DrvObj, NotificationProc, NotificationProc,
                GetNameByOffset(NotificationProc, (PSTR)Buffer, _countof(Buffer)));
        }
    }

    if ((g_Ext->m_Symbols->GetOffsetByName("nt!PnpProfileNotifyList", &Offset) == S_OK) ||
        (g_Ext->m_Symbols->GetOffsetByName("nt!IopProfileNotifyList", &Offset) == S_OK))
    {
        //typedef struct _NOTIFY_ENTRY_HEADER {
        //    LIST_ENTRY ListEntry;
        //    IO_NOTIFICATION_EVENT_CATEGORY EventCategory;
        //    ULONG SessionId;
        //    HANDLE SessionHandle;
        //    PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine;
        //    PVOID Context;
        //    PDRIVER_OBJECT DriverObject;
        // (...)
        ExtRemoteTypedList PnpProfileNotifyList(Offset, "nt!_LIST_ENTRY", "Flink");

        Dml("\n<col fg=\"changed\">[*] PnpProfileNotifyList:</col>\n");

        for (PnpProfileNotifyList.StartHead();
            PnpProfileNotifyList.HasNode();
            PnpProfileNotifyList.Next())
        {
            ULONG64 Node = PnpProfileNotifyList.GetNodeOffset();
            ULONG FieldOffset;
            ULONG64 SessionHandle;
            ULONG64 NotificationProc;
            ULONG64 DrvObj;

            FieldOffset = GetTypeSize("nt!_LIST_ENTRY");
            FieldOffset += sizeof(ULONG);
            FieldOffset += sizeof(ULONG);

            ReadPointer(Node + FieldOffset, &SessionHandle);
            FieldOffset += m_PtrSize;

            ReadPointer(Node + FieldOffset, &NotificationProc);
            FieldOffset += m_PtrSize *2;
            ReadPointer(Node + FieldOffset, &DrvObj);

            Dml("     Object: 0x%016I64X "
                "Driver Object: <link cmd=\"dt nt!_DRIVER_OBJECT 0x%016I64X\">0x%016I64X</link> "
                "Session: <link cmd=\"!session 0x%I64X\">0x%I64X</link> "
                "Procedure: <link cmd=\"u 0x%016I64X L5\">0x%016I64X</link> (%s) \n",
                Node, DrvObj, DrvObj, SessionHandle, SessionHandle, NotificationProc, NotificationProc,
                GetNameByOffset(NotificationProc, (PSTR)Buffer, _countof(Buffer)));
        }
    }

    // TODO: IopNotifyShutdownQueueHead
    // TODO: IopCdRomFileSystemQueueHead
    // TODO: IopDiskFileSystemQueueHead
    // TODO: IopTapeFileSystemQueueHead
    // TODO: IopNetworkFileSystemQueueHead

    if (g_Ext->m_Symbols->GetOffsetByName("nt!PspCreateProcessNotifyRoutine", &Offset) == S_OK)
    {
        // typedef struct _EX_CALLBACK_ROUTINE_BLOCK
        // {
        //      EX_RUNDOWN_REF RundownProtect;
        //      PEX_CALLBACK_FUNCTION Function;
        //      PVOID Context;
        // } EX_CALLBACK_ROUTINE_BLOCK, *PEX_CALLBACK_ROUTINE_BLOCK;

        ULONG PspCreateProcessNotifyRoutineCount = 0;
        ULONG PspCreateProcessNotifyRoutineExCount = 0;
        ULONG64 ExRefMask = (g_Ext->m_Control->IsPointer64Bit() == S_OK) ? ~0xF : ~0x7;
        ULONG64 Offset2;

        if (g_Ext->m_Symbols->GetOffsetByName("nt!PspCreateProcessNotifyRoutineCount", &Offset2) == S_OK)
        {
            g_Ext->m_Data->ReadVirtual(Offset2, (PUCHAR)&PspCreateProcessNotifyRoutineCount, sizeof(PspCreateProcessNotifyRoutineCount), NULL);
        }

        if (g_Ext->m_Symbols->GetOffsetByName("nt!PspCreateProcessNotifyRoutineExCount", &Offset2) == S_OK)
        {
            g_Ext->m_Data->ReadVirtual(Offset2, (PUCHAR)&PspCreateProcessNotifyRoutineExCount, sizeof(PspCreateProcessNotifyRoutineExCount), NULL);
        }

        Dml("\n<col fg=\"changed\">[*] PspCreateProcessNotifyRoutine:</col>\n");

        for (ULONG Index = 0;
            Index < (PspCreateProcessNotifyRoutineCount + PspCreateProcessNotifyRoutineExCount);
            Index += 1)
        {
            ULONG64 NotificationProc;
            ReadPointer(Offset + (Index * m_PtrSize), &NotificationProc);
            NotificationProc &= ExRefMask;

            ULONG TypeSize = GetTypeSize("nt!EX_RUNDOWN_REF");
            if (!TypeSize) TypeSize = m_PtrSize;

            ReadPointer(NotificationProc + TypeSize, &NotificationProc);

                Dml("     Procedure: <link cmd=\"u 0x%016I64X L5\">0x%016I64X</link> (%s) \n",
                    NotificationProc, NotificationProc,
                    GetNameByOffset(NotificationProc, (PSTR)Buffer, _countof(Buffer)));
        }
    }

    if (g_Ext->m_Symbols->GetOffsetByName("nt!PspLoadImageNotifyRoutine", &Offset) == S_OK)
    {
        // typedef struct _EX_CALLBACK_ROUTINE_BLOCK
        // {
        //      EX_RUNDOWN_REF RundownProtect;
        //      PEX_CALLBACK_FUNCTION Function;
        //      PVOID Context;
        // } EX_CALLBACK_ROUTINE_BLOCK, *PEX_CALLBACK_ROUTINE_BLOCK;
        ULONG64 ExRefMask = (g_Ext->m_Control->IsPointer64Bit() == S_OK) ? ~0xF : ~0x7;
        ULONG64 Offset2;
        ULONG Count = 0;

        if (g_Ext->m_Symbols->GetOffsetByName("nt!PspLoadImageNotifyRoutineCount", &Offset2) == S_OK)
        {
            g_Ext->m_Data->ReadVirtual(Offset2, (PUCHAR)&Count, sizeof(Count), NULL);
        }

        Dml("\n<col fg=\"changed\">[*] PspLoadImageNotifyRoutine:</col>\n");

        for (ULONG Index = 0;
            Index < Count;
            Index += 1)
        {
            ULONG64 NotificationProc;
            ReadPointer(Offset + (Index * m_PtrSize), &NotificationProc);
            NotificationProc &= ExRefMask;

            ULONG ProcOffset = GetTypeSize("nt!EX_RUNDOWN_REF");
            if (!ProcOffset) ProcOffset = m_PtrSize;

            ReadPointer(NotificationProc + ProcOffset, &NotificationProc);

            Dml("     Procedure: <link cmd=\"u 0x%016I64X L5\">0x%016I64X</link> (%s) \n",
                NotificationProc, NotificationProc,
                GetNameByOffset(NotificationProc, (PSTR)Buffer, _countof(Buffer)));
         }
    }

    if (g_Ext->m_Symbols->GetOffsetByName("nt!PspCreateThreadNotifyRoutine", &Offset) == S_OK)
    {
        // typedef struct _EX_CALLBACK_ROUTINE_BLOCK
        // {
        //      EX_RUNDOWN_REF RundownProtect;
        //      PEX_CALLBACK_FUNCTION Function;
        //      PVOID Context;
        // } EX_CALLBACK_ROUTINE_BLOCK, *PEX_CALLBACK_ROUTINE_BLOCK;
        ULONG64 ExRefMask = (g_Ext->m_Control->IsPointer64Bit() == S_OK) ? ~0xF : ~0x7;
        ULONG64 pPspCreateThreadNotifyRoutineCount;
        ULONG Count = 0;

        pPspCreateThreadNotifyRoutineCount = GetExpression("nt!PspCreateThreadNotifyRoutineCount");

        if (pPspCreateThreadNotifyRoutineCount)
        {
            g_Ext->m_Data->ReadVirtual(pPspCreateThreadNotifyRoutineCount, (PUCHAR)&Count, sizeof(Count), NULL);
        }

        Dml("\n<col fg=\"changed\">[*] PspCreateThreadNotifyRoutine:</col>\n");
        for (ULONG Index = 0;
            Index < Count;
            Index += 1)
        {
            ULONG64 NotificationProc;

            ReadPointer(Offset + (Index * m_PtrSize), &NotificationProc);
            NotificationProc &= ExRefMask;

            ULONG ProcOffset = GetTypeSize("nt!EX_RUNDOWN_REF");
            if (!ProcOffset) ProcOffset = m_PtrSize;

            ReadPointer(NotificationProc + ProcOffset, &NotificationProc);

            Dml("     Procedure: <link cmd=\"u 0x%016I64X L5\">0x%016I64X</link> (%s) \n",
                NotificationProc, NotificationProc,
                GetNameByOffset(NotificationProc, (PSTR)Buffer, _countof(Buffer)));
        }
    }

    if (g_Ext->m_Symbols->GetOffsetByName("nt!CmpCallBackVector", &Offset) == S_OK)
    {
        // typedef struct _EX_CALLBACK_ROUTINE_BLOCK
        // {
        //      EX_RUNDOWN_REF RundownProtect;
        //      PEX_CALLBACK_FUNCTION Function;
        //      PVOID Context;
        // } EX_CALLBACK_ROUTINE_BLOCK, *PEX_CALLBACK_ROUTINE_BLOCK;
        ULONG64 ExRefMask = (g_Ext->m_Control->IsPointer64Bit() == S_OK) ? ~0xF : ~0x7;
        ULONG64 pCmpCallBackCount;
        ULONG Count = 0;

        Dml("\n<col fg=\"changed\">[*] CmpCallBackVector:</col>\n");

        pCmpCallBackCount = GetExpression("nt!CmpCallBackCount");

        if (pCmpCallBackCount)
        {
            g_Ext->m_Data->ReadVirtual(pCmpCallBackCount, (PUCHAR)&Count, sizeof(Count), NULL);
        }

        for (ULONG Index = 0;
            Index < Count;
            Index += 1)
        {
            ULONG64 NotificationProc;
            ReadPointer(Offset + (Index * m_PtrSize), &NotificationProc);
            NotificationProc &= ExRefMask;

            ULONG ProcOffset = GetTypeSize("nt!EX_RUNDOWN_REF");
            if (!ProcOffset) ProcOffset = m_PtrSize;

            ReadPointer(NotificationProc + ProcOffset, &NotificationProc);

            Dml("     Procedure: <link cmd=\"u 0x%016I64X L5\">0x%016I64X</link> (%s) \n",
                NotificationProc, NotificationProc,
                GetNameByOffset(NotificationProc, (PSTR)Buffer, _countof(Buffer)));
        }
    }

    if (g_Ext->m_Symbols->GetOffsetByName("nt!CallbackListHead", &Offset) == S_OK)
    {
        //typedef struct _CM_CALLBACK_CONTEXT_BLOCK {
        //    LIST_ENTRY                  CallbackListEntry;      // List of all the callbacks registered in the system
        //    LONG                        PreCallListCount;       // Number of already active pre callbacks
        //    LARGE_INTEGER               Cookie;                 // to identify a specific callback for deregistration purposes
        //    PVOID                       CallerContext;
        //    PEX_CALLBACK_FUNCTION       Function;               // the actual callback routine
        //    UNICODE_STRING              Altitude;
        //    LIST_ENTRY                  ObjectContextListHead;  // Links together object contexts for this callback
        //} CM_CALLBACK_CONTEXT_BLOCK, *PCM_CALLBACK_CONTEXT_BLOCK;
        ExtRemoteTypedList CallbackListHead(Offset, "nt!_LIST_ENTRY", "Flink");

        Dml("\n<col fg=\"changed\">[*] CallbackListHead:</col>\n");

        for (CallbackListHead.StartHead();
            CallbackListHead.HasNode();
            CallbackListHead.Next())
        {
            ULONG64 Node = CallbackListHead.GetNodeOffset();
            ULONG64 NotificationProc;

            ULONG ProcOffset = GetTypeSize("nt!_LIST_ENTRY");
            ProcOffset += m_PtrSize;// sizeof(ULONG); // ULONG but 8-bytes aligned.
            ProcOffset += sizeof(LARGE_INTEGER);
            ProcOffset += m_PtrSize;

            if (!ReadPointer(Node + ProcOffset, &NotificationProc)) continue;

            Dml("     Procedure: <link cmd=\"u 0x%016I64X L5\">0x%016I64X</link> (%s) \n",
                NotificationProc, NotificationProc,
                GetNameByOffset(NotificationProc, (PSTR)Buffer, _countof(Buffer)));
        }
    }

    if (g_Ext->m_Symbols->GetOffsetByName("nt!KeBugCheckCallbackListHead", &Offset) == S_OK)
    {
        // typedef struct _KBUGCHECK_REASON_CALLBACK_RECORD {
        //   LIST_ENTRY Entry;
        //   PKBUGCHECK_REASON_CALLBACK_ROUTINE CallbackRoutine;
        //   PUCHAR Component;
        //   ULONG_PTR Checksum;
        //   KBUGCHECK_CALLBACK_REASON Reason;
        //   UCHAR State;
        // } KBUGCHECK_REASON_CALLBACK_RECORD, *PKBUGCHECK_REASON_CALLBACK_RECORD;

        ExtRemoteTypedList CallbackListHead(Offset, "nt!_LIST_ENTRY", "Flink");

        Dml("\n<col fg=\"changed\">[*] KeBugCheckCallbackListHead:</col>\n");

        for (CallbackListHead.StartHead();
            CallbackListHead.HasNode();
            CallbackListHead.Next())
        {
            ULONG64 Node = CallbackListHead.GetNodeOffset();
            ULONG64 NotificationProc;

            ULONG ProcOffset = GetTypeSize("nt!_LIST_ENTRY");

            ReadPointer(Node + ProcOffset, &NotificationProc);

            Dml("     Procedure: <link cmd=\"u 0x%016I64X L5\">0x%016I64X</link> (%s) \n",
                NotificationProc, NotificationProc,
                GetNameByOffset(NotificationProc, (PSTR)Buffer, _countof(Buffer)));
        }
    }

    if (g_Ext->m_Symbols->GetOffsetByName("nt!KeBugCheckAddPagesCallbackListHead", &Offset) == S_OK)
    {
        // typedef struct _KBUGCHECK_REASON_CALLBACK_RECORD {
        //   LIST_ENTRY Entry;
        //   PKBUGCHECK_REASON_CALLBACK_ROUTINE CallbackRoutine;
        //   PUCHAR Component;
        //   ULONG_PTR Checksum;
        //   KBUGCHECK_CALLBACK_REASON Reason;
        //   UCHAR State;
        // } KBUGCHECK_REASON_CALLBACK_RECORD, *PKBUGCHECK_REASON_CALLBACK_RECORD;

        ExtRemoteTypedList CallbackListHead(Offset, "nt!_LIST_ENTRY", "Flink");

        Dml("\n<col fg=\"changed\">[*] KeBugCheckAddPagesCallbackListHead:</col>\n");

        for (CallbackListHead.StartHead();
            CallbackListHead.HasNode();
            CallbackListHead.Next())
        {
            ULONG64 Node = CallbackListHead.GetNodeOffset();
            ULONG64 NotificationProc;

            ULONG ProcOffset = GetTypeSize("nt!_LIST_ENTRY");

            ReadPointer(Node + ProcOffset, &NotificationProc);

            Dml("     Procedure: <link cmd=\"u 0x%016I64X L5\">0x%016I64X</link> (%s) \n",
                NotificationProc, NotificationProc,
                GetNameByOffset(NotificationProc, (PSTR)Buffer, _countof(Buffer)));
        }
    }

    if (g_Ext->m_Symbols->GetOffsetByName("nt!KiNmiCallbackListHead", &Offset) == S_OK)
    {
        // typedef struct _KNMI_HANDLER_CALLBACK {
        //     struct _KNMI_HANDLER_CALLBACK * Next;
        //     PNMI_CALLBACK Callback;
        //     PVOID Context;
        //     PVOID Handle;
        // } KNMI_HANDLER_CALLBACK, *PKNMI_HANDLER_CALLBACK;

        ExtRemoteTypedList CallbackListHead(Offset, "nt!_SINGLE_LIST_ENTRY", "Next");

        Dml("\n<col fg=\"changed\">[*] KiNmiCallbackListHead:</col>\n");

        for (CallbackListHead.StartHead();
            CallbackListHead.HasNode();
            CallbackListHead.Next())
        {
            ULONG64 Node = CallbackListHead.GetNodeOffset();
            ULONG64 NotificationProc;

            ULONG ProcOffset = GetTypeSize("nt!_SINGLE_LIST_ENTRY");

            ReadPointer(Node + ProcOffset, &NotificationProc);

            Dml("     Procedure: <link cmd=\"u 0x%016I64X L5\">0x%016I64X</link> (%s) \n",
                NotificationProc, NotificationProc,
                GetNameByOffset(NotificationProc, (PSTR)Buffer, _countof(Buffer)));
        }
    }

    if (g_Ext->m_Symbols->GetOffsetByName("nt!AlpcpLogCallbackListHead", &Offset) == S_OK)
    {
        // typedef struct _ALPC_PRIVATE_LOG_CALLBACK {
        //     LIST_ENTRY Entry;
        //     PVOID LogRoutine;
        // } ALPC_PRIVATE_LOG_CALLBACK, *PALPC_PRIVATE_LOG_CALLBACK;

        ExtRemoteTypedList CallbackListHead(Offset, "nt!_LIST_ENTRY", "Flink");

        Dml("\n<col fg=\"changed\">[*] AlpcpLogCallbackListHead:</col>\n");

        for (CallbackListHead.StartHead();
            CallbackListHead.HasNode();
            CallbackListHead.Next())
        {
            ULONG64 Node = CallbackListHead.GetNodeOffset();
            ULONG64 NotificationProc;

            ULONG ProcOffset = GetTypeSize("nt!_LIST_ENTRY");

            ReadPointer(Node + ProcOffset, &NotificationProc);

            Dml("     Procedure: <link cmd=\"u 0x%016I64X L5\">0x%016I64X</link> (%s) \n",
                NotificationProc, NotificationProc,
                GetNameByOffset(NotificationProc, (PSTR)Buffer, _countof(Buffer)));
        }
    }

    if (g_Ext->m_Symbols->GetOffsetByName("nt!EmpCallbackListHead", &Offset) == S_OK)
    {
        // struct _EMP_CALLBACK {
        // GUID CallbackId;
        // PVOID CallbackFunc;
        // LONG CallbackFuncReference;
        // PVOID Context;
        // SINGLE_LIST_ENTRY List;
        // ...
        // };

        ExtRemoteTypedList CallbackListHead(Offset, "nt!_SINGLE_LIST_ENTRY", "Next");

        Dml("\n<col fg=\"changed\">[*] EmpCallbackListHead:</col>\n");

        for (CallbackListHead.StartHead();
            CallbackListHead.HasNode();
            CallbackListHead.Next())
        {
            GUID Guid = {0};
            ULONG64 NotificationProc;
            ULONG64 Node = CallbackListHead.GetNodeOffset();

            ULONG ProcOffset = m_PtrSize * 2 + m_PtrSize; // ULONG but 8 bytes aligned. sizeof(ULONG);

            ReadPointer(Node - ProcOffset, &NotificationProc);

            g_Ext->m_Data->ReadVirtual(Node - ProcOffset - sizeof(GUID), &Guid, sizeof(GUID), NULL);

            Dml("     GUID: {%08lX-%04hX-%04hX-%02hhX%02hhX-%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX} "
                "Procedure: <link cmd = \"u 0x%016I64X L5\">0x%016I64X</link> (%s) \n",
                Guid.Data1, Guid.Data2, Guid.Data3,
                Guid.Data4[0], Guid.Data4[1], Guid.Data4[2], Guid.Data4[3],
                Guid.Data4[4], Guid.Data4[5], Guid.Data4[6], Guid.Data4[7],
                NotificationProc, NotificationProc, 
                GetNameByOffset(NotificationProc, (PSTR)Buffer, _countof(Buffer)));
        }
    }

    // TODO: NmrRegisterProvider() http://wenku.baidu.com/view/c79f672acfc789eb172dc8a5.html

    if (g_Ext->m_Symbols->GetOffsetByName("tcpip!IOCtlDispatchTable", &Offset) == S_OK)
    {
        //
        // typedef struct _IOCTL_DISPATCH_ENTRY {
        // PDEVICE_OBJECT DeviceObject;
        // PVOID DeviceControlDispatchFunction;
        // } IOCTL_DISPATCH_ENTRY;
        // 

        ULONG64 DeviceObjectDispatchEntry[2 * NetIoDispatchMax];
        LPSTR TcpipDispatchId[] = {
            "IPSEC",
            "KFD",
            "ALE",
            "EQOS",
            "IDP",
            NULL
        };

        if (ReadPointersVirtual(NetIoDispatchMax * 2, Offset, (PULONG64)&DeviceObjectDispatchEntry) != S_OK) goto Exit;

        Dml("\n<col fg=\"changed\">[*] Tcpip driver IOCTL dispatch table:</col>\n");

        for (UINT i = 0; i < NetIoDispatchMax; i += 1)
        {
            Dml("   | %5s |  DevObj: <link cmd = \"!devobj 0x%016I64X f\">0x%016I64X</link> | IoctlDispatch: <link cmd = \"u 0x%016I64X L5\">0x%016I64X</link> | %s | <col fg=\"changed\">%s</col> \n",
                TcpipDispatchId[i],
                DeviceObjectDispatchEntry[i * 2],
                DeviceObjectDispatchEntry[i * 2],
                DeviceObjectDispatchEntry[(i * 2) + 1],
                DeviceObjectDispatchEntry[(i * 2) + 1],
                GetNameByOffset(DeviceObjectDispatchEntry[(i * 2) + 1], (PSTR)Buffer, _countof(Buffer)),
                GetPointerHookType(DeviceObjectDispatchEntry[(i * 2) + 1]) ? "Hooked" : "");
        }
    }

    // TODO: LKMD_CALLBACK DbgkpLkmdDataCollectionCallbacks[8]

    /*
     DBG_LKMD_CALLBACK {
        EX_CALLBACK Callback;
        EX_FAST_REF RoutineBlock;
        PVOID Object;
        // ...
     }

    16.kd : x86> ? ? sizeof(nt!_LKMD_CALLBACK)
        unsigned int 0x10

    16.kd:x86> dt nt!_EX_CALLBACK
        + 0x000 RoutineBlock     : _EX_FAST_REF
        16.kd : x86> dt nt!_EX_FAST_REF
        16.kd:x86> dt nt!_EX_FAST_REF
        + 0x000 Object           : Ptr64 Void
        + 0x000 RefCnt : Pos 0, 4 Bits
        + 0x000 Value : Uint8B
        16.kd : x86> dt nt!_EX_CALLBACK_ROUTINE_BLOCK
        16.kd:x86> dt nt!_EX_CALLBACK_ROUTINE_BLOCK
        + 0x000 RundownProtect   : _EX_RUNDOWN_REF
        + 0x008 Function : Ptr64     long
        + 0x010 Context : Ptr64 Void
        */

    if (g_Ext->m_Symbols->GetOffsetByName("nt!DbgkpLkmdDataCollectionCallbacks", &Offset) == S_OK)
    {
        #define MAX_DBG_LKMD_CALLBACKS 8 
        ULONG64 DbgLkmdCallbacks[2 * MAX_DBG_LKMD_CALLBACKS];

        Dml("\n<col fg=\"changed\">[*] DbgkpLkmdDataCollectionCallbacks:</col>\n");

        if (ReadPointersVirtual(MAX_DBG_LKMD_CALLBACKS * 2, Offset, (PULONG64)&DbgLkmdCallbacks) != S_OK) goto Exit;

        for (UINT i = 0; i < MAX_DBG_LKMD_CALLBACKS; i += 1)
        {
            ULONG64 CallbackRoutine = GetFastRefPointer(DbgLkmdCallbacks[i * 2]);
            if (CallbackRoutine)
            {
                Dml("     Procedure: <link cmd=\"u 0x%016I64X L5\">0x%016I64X</link> (%s) \n",
                    CallbackRoutine, CallbackRoutine,
                    GetNameByOffset(CallbackRoutine, (PSTR)Buffer, _countof(Buffer)));
            }
        }
    }

    ObjectTypesPtr = ObGetObjectTypesObject();

    if (ObjectTypesPtr) {
        // Dml("ObjectTypes.ObjectPtr = %I64X\n", ObjectTypes.ObjectPtr);
        vector<HANDLE_OBJECT> Handles = ObOpenObjectDirectory(ObjectTypesPtr);
        for each (HANDLE_OBJECT Handle in Handles) {
            ExtRemoteTyped currentType("(nt!_OBJECT_TYPE *)@$extin", Handle.ObjectPtr);
            ULONG64 FieldOffset = 0;
			ULONG64 Head = 0;

			if (currentType.HasField("CallbackList")) {
				FieldOffset = currentType.GetFieldOffset("CallbackList.Flink");
				Head = currentType.Field("CallbackList.Flink").GetPtr();
			}
			else {
				FieldOffset = currentType.GetFieldOffset("TypeList.Flink");
				Head = currentType.Field("TypeList.Flink").GetPtr();
			}

            if (Head == (Handle.ObjectPtr + FieldOffset)) continue;

            // Dml("ObjectType @ 0x%I64X Entry = 0x%I64X\n", Handle.ObjectPtr, Head);

            ExtRemoteTyped pouet("(nt!_LIST_ENTRY *)@$extin", Handle.ObjectPtr + FieldOffset);
            // Dml("Flink = 0x%I64X Blink = 0x%I64X\n", pouet.Field("Flink").GetPtr(), pouet.Field("Blink").GetPtr());

            if (TRUE) { // (wstring(Handle.Name) == L"Process") || (wstring(Handle.Name) == L"Thread")) {
                ExtRemoteTypedList EntryList(Handle.ObjectPtr + FieldOffset, "nt!_LIST_ENTRY", "Flink");

                Dml("\n<col fg=\"changed\">[*] %S Object Callbacks:</col>\n", Handle.Name);
                for (EntryList.StartHead(); EntryList.HasNode(); EntryList.Next()) {

                    ULONG64 Object = EntryList.GetNodeOffset();
                    // Dml("Entry @ 0x%I64X\n", Object);
                    ULONG64 ObjectTypeCallbackOffset = Object + m_PtrSize * 4;
                    ULONG64 PreCallbackOffset = Object + m_PtrSize * 5;
                    ULONG64 PostCallbackOffset = Object + m_PtrSize * 6;

                    // Dml("[entry] Object = 0x%I64X\n", Object);
                    // Dml("ObjectTypeCallbackOffset = 0x%I64X\n", ObjectTypeCallbackOffset);
                    ULONG64 ObjectTypePtr = 0;
                    ReadPointer(ObjectTypeCallbackOffset, &ObjectTypePtr);
                    // Dml("ObjectTypePtr = 0x%I64X (Handle.ObjectPtr = 0x%I64X)\n", ObjectTypePtr, Handle.ObjectPtr);
                    // Sanity check
                    if (ObjectTypePtr == Handle.ObjectPtr) {
                        ULONG64 Pre, Post;
                        ReadPointer(PreCallbackOffset, &Pre);
                        ReadPointer(PostCallbackOffset, &Post);

                        if (Pre) {
                            Dml("PreCallback Procedure: <link cmd = \"u 0x%016I64X L5\">0x%016I64X</link> (%s) \n",
                                Pre, Pre,
                                GetNameByOffset(Pre, (PSTR)Buffer, _countof(Buffer)));
                        }
                        if (Post) {
                            Dml("PostCallback Procedure: <link cmd = \"u 0x%016I64X L5\">0x%016I64X</link> (%s) \n",
                                Post, Post,
                                GetNameByOffset(Post, (PSTR)Buffer, _countof(Buffer)));
                        }
                    }
                }
            }
        }
    }

	ULONG64 PspSiloMonitorList = 0;
	
	// Credit aionescu: https://twitter.com/aionescu/status/1069738308924780545
	if (g_Ext->m_Symbols->GetOffsetByName("nt!PspSiloMonitorList", &PspSiloMonitorList) == S_OK) {
		ULONG64 FieldOffset = 0;

		FieldOffset = GetTypeSize("nt!_LIST_ENTRY");
		FieldOffset += sizeof(ULONG);
		FieldOffset += sizeof(ULONG);

		ULONG64 entry = 0;
		ReadPointer(PspSiloMonitorList, &entry);

		Dml("\n<col fg=\"changed\">[*] PspSiloMonitorList Callbacks:</col>\n");
		
		while (entry) {

			ULONG64 CreateCallback = 0, DestroyCallback = 0;
			ULONG64 SiloIndex = 0;

			ReadPointer(entry + FieldOffset, &CreateCallback);
			ReadPointer(entry + FieldOffset + GetPtrSize(), &DestroyCallback);

			ReadPointer(entry + FieldOffset - sizeof(ULONG), &SiloIndex);
			SiloIndex = (ULONG)(SiloIndex & 0xFFFFFFFF);

			if (CreateCallback) {
				Dml("     [0x%04x] CreateCallback  Procedure: <link cmd = \"u 0x%016I64X L5\">0x%016I64X</link> (%s) \n",
					SiloIndex,
					CreateCallback, CreateCallback,
					GetNameByOffset(CreateCallback, (PSTR)Buffer, _countof(Buffer)));
			}
			if (DestroyCallback) {
				Dml("     [0x%04x] DestroyCallback Procedure: <link cmd = \"u 0x%016I64X L5\">0x%016I64X</link> (%s) \n",
					SiloIndex,
					DestroyCallback, DestroyCallback,
					GetNameByOffset(DestroyCallback, (PSTR)Buffer, _countof(Buffer)));
			}

			ULONG64 prev = entry;
			ReadPointer(prev, &entry);
			if ((entry == PspSiloMonitorList) || (prev == entry)) break;
		}
	}
	
Exit:
    ReleaseObjectTypeTable();

    return;
}

EXT_COMMAND(ms_ssdt,
    "Display service descriptor table (SDT) functions",
    "{;e,o;;}")
{
    vector<SSDT_ENTRY> Table = GetServiceDescriptorTable();

    Dml("    |-------|--------------------|--------------------------------------------------------|---------|--------|\n"
        "    | <col fg=\"emphfg\">%-5s</col> | <col fg=\"emphfg\">%-18s</col> | <col fg=\"emphfg\">%-54s</col> | <col fg=\"emphfg\">%-7s</col> | <col fg=\"emphfg\">%-6s</col> |\n"
        "    |-------|--------------------|--------------------------------------------------------|---------|--------|\n",
        "Index", "Address", "Name", "Patched", "Hooked");

    for each (SSDT_ENTRY Entry in Table) {

        CHAR Name[512] = {0};

        Dml((Entry.Address.IsTablePatched || Entry.Address.HookType) ?
            "    | %5d | <link cmd=\"u 0x%016I64X L1\">0x%016I64X</link> | <col fg=\"changed\">%-54s</col> | <col fg=\"changed\">%-7s</col> | <col fg=\"changed\">%-6s</col> |\n" :
            "    | %5d | <link cmd=\"u 0x%016I64X L1\">0x%016I64X</link> | %-54s | <col fg=\"changed\">%-7s</col> | <col fg=\"changed\">%-6s</col> |\n",
            Entry.Index,
            Entry.Address.Address,
            Entry.Address.Address,
            GetNameByOffset(Entry.Address.Address, (PSTR)Name, _countof(Name)),
            Entry.Address.IsTablePatched ? "Yes" : "",
            Entry.Address.HookType ? "Yes" : "");
    }
}

EXT_COMMAND(ms_dump,
            "Dump memory space on disk",
            "{;s;outputfile;Output file}{;ed;base;Base address}{;ed;size;Memory space size}")
{
    PCSTR Output = GetUnnamedArgStr(0);
    ULONG64 BaseAddress = GetUnnamedArgU64(1);
    ULONG Size = (ULONG)GetUnnamedArgU64(2);

    ULONG WrittenBytes = 0;

    Dml("   [ <col fg=\"changed\">File:</col> <col fg=\"emphfg\">%s</col>\n"
        "   [ <col fg=\"changed\">Base:</col> <col fg=\"emphfg\">0x%016I64X</col>\n"
        "   [ <col fg=\"changed\">Size:</col> <col fg=\"emphfg\">0x%X</col>\n",
        Output, BaseAddress, Size);

    PVOID Buffer = malloc(Size);

    if (!Buffer) {

        goto CleanUp;
    }

    if (ExtRemoteTypedEx::ReadVirtual(BaseAddress, Buffer, Size, NULL) != S_OK)
    {
        Err("Error: Failed to read the memory buffer.\n");
        goto CleanUp;
    }

    Dml("   -> Dumping memory address space in file... ",
        Output, BaseAddress, Size);
    HANDLE hOutput = CreateFile(Output,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
    if (hOutput == INVALID_HANDLE_VALUE)
    {
        g_Ext->Dml("<col fg=\"emphfg\">Failed</col>\n");
        goto CleanUp;
    }

    BOOL Ret = WriteFile(hOutput, Buffer, Size, &WrittenBytes, NULL);

    if ((Ret == FALSE) && (GetLastError() == ERROR_IO_PENDING))
    {
        DWORD Status;

        do
        {
            Status = WaitForSingleObjectEx(hOutput, INFINITE, TRUE);
        } while (Status == WAIT_IO_COMPLETION);
    }

    CloseHandle(hOutput);

    g_Ext->Dml("<col fg=\"emphfg\">Success</col>\n");

CleanUp:
    if (Buffer) free(Buffer);
}

EXT_COMMAND(ms_readknode,
    "Read key node",
    "{;ed;hive;Key hive}{;ed;knode;Key Node}")
{
    ULONG64 KeyHiveAddr = GetUnnamedArgU64(0);
    ULONG64 KeyNodeAddr = GetUnnamedArgU64(1);

    ExtRemoteTyped KeyHive("(nt!_HHIVE *)@$extin", KeyHiveAddr);
    ExtRemoteTyped KeyNode("(nt!_CM_KEY_NODE *)@$extin", KeyNodeAddr);

    RegReadKeyNode(KeyHive, KeyNode);
}

EXT_COMMAND(ms_readkvalue,
    "Read key value",
    "{;ed;hive;Key hive}{;ed;kvalue;Key Value}")
{
    ULONG64 KeyHiveAddr = GetUnnamedArgU64(0);
    ULONG64 KeyValueAddr = GetUnnamedArgU64(1);

    ExtRemoteTyped KeyHive("(nt!_HHIVE *)@$extin", KeyHiveAddr);
    ExtRemoteTyped KeyValue("(nt!_CM_KEY_VALUE *)@$extin", KeyValueAddr);

    RegReadKeyValue(KeyHive, KeyValue);
}


EXT_COMMAND(ms_readkcb,
    "Read key control block",
    "{;ed;kcb;Key Control Block}")
{
    ULONG64 KCB = GetUnnamedArgU64(0);
    ExtRemoteTyped CmKcb("(nt!_CM_KEY_CONTROL_BLOCK *)@$extin", KCB);

    ExtRemoteTyped KeyHive = CmKcb.Field("KeyHive");
    ULONG CellIndex = CmKcb.Field("KeyCell").GetUlong();

    // !reg findkcb \REGISTRY\MACHINE\SYSTEM\MountedDevices
    // !reg findkcb \REGISTRY\MACHINE\SYSTEM

    if (KeyHive.Field("Flat").GetUchar())
    {
        Err("Error: Unsupported/Unexpected mapping (Flat cell)");
        return;
    }

    ULONG64 KeyNodeAddr = RegGetCellPaged(KeyHive, CellIndex);
    ExtRemoteTyped KeyNode("(nt!_CM_KEY_NODE *)@$extin", KeyNodeAddr);

    RegReadKeyNode(KeyHive, KeyNode);

    return;
}

EXT_COMMAND(ms_netstat,
    "Display network information (sockets, connections, ...)",
    "{;e,o;;}")
{
    vector<NETWORK_ENTRY> Sockets = GetSockets();

    Dml("    | <col fg=\"changed\">%-5s</col> | <col fg=\"changed\">%-25s</col> | <col fg=\"changed\">%-25s</col> | "
        "<col fg=\"changed\">%-11s</col> | <col fg=\"changed\">%-16s</col> | <col fg=\"changed\">%-6s</col> | <col fg=\"changed\">%s</col>\n"
        "    |--------------------------------------------------------------------------------------------------------\n",
        "Proto", "Local Address", "Foreign address", "State", "Process Name", "Pid", "Creation time");
    for each (NETWORK_ENTRY Socket in Sockets)
    {
        SYSTEMTIME SystemTime = { 0 };
        CHAR SrcIpAddress[32];
        CHAR DstIpAddress[32];

        sprintf_s(SrcIpAddress, "%d.%d.%d.%d:%d",
            (ULONG)Socket.Local.IPv4_Addr[0],
            (ULONG)Socket.Local.IPv4_Addr[1],
            (ULONG)Socket.Local.IPv4_Addr[2],
            (ULONG)Socket.Local.IPv4_Addr[3],
            Socket.Local.Port);
        sprintf_s(DstIpAddress, "%d.%d.%d.%d:%d",
            (ULONG)Socket.Remote.IPv4_Addr[0],
            (ULONG)Socket.Remote.IPv4_Addr[1],
            (ULONG)Socket.Remote.IPv4_Addr[2],
            (ULONG)Socket.Remote.IPv4_Addr[3],
            Socket.Remote.Port);

        FileTimeToSystemTime((PFILETIME)&Socket.CreationTime, &SystemTime);
        Dml("    | <col fg=\"emphfg\">%-5s</col> | %25s | %25s | %-11s | %-16s | <link cmd=\"!process %x 1\">0x%04x</link> | %2d/%2d/%4d %2d:%2d:%2d (UTC) |\n",
            GetProtocolType(Socket.Protocol),
            SrcIpAddress, DstIpAddress,
            GetTcbState(Socket.State),
            Socket.ProcessName,
            (ULONG)Socket.ProcessId,
            (ULONG)Socket.ProcessId,
            SystemTime.wDay,
            SystemTime.wMonth,
            SystemTime.wYear,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond);
    }
}

EXT_COMMAND(ms_mbr,
    "Scan Master Boot Record (MBR)",
    "{;ed;phys;MBR Physical Address}")
{
    PARTITION_TABLE PartitionTable;
    ULONG BytesRead = 0;

    ULONG64 MBRAddr = GetUnnamedArgU64(0);

    HRESULT hResult = m_Data->ReadPhysical(MBRAddr, &PartitionTable, sizeof(PARTITION_TABLE), &BytesRead);
    if (hResult != S_OK)
    {
        Err("Error: Unable to read BIOS page.\n");
        return;
    }

    Dml("   Disk Signature: {%02x}-{%02x}-{%02x}-{%02x}\n\n",
        PartitionTable.DiskSignature[0],
        PartitionTable.DiskSignature[1],
        PartitionTable.DiskSignature[2],
        PartitionTable.DiskSignature[3]);

    for (UINT i = 0; i < 4; i += 1)
    {
        Dml("   [ Partition %d]\n"
            "     Boot flag:                0x%x\n"
            "     Type:                     0x%x (%s)\n"
            "     Starting Sector(LBA):     0x%x\n"
            "     Starting CHS:             Cylinder=%d, Head=%d, Sector=%d\n"
            "     Ending CHS:               Cylinder=%d, Head=%d, Sector=%d\n"
            "     Size in sectors:          0x%x\n\n",
            i,
            PartitionTable.Entry[i].BootableFlag,
            PartitionTable.Entry[i].PartitionType, GetPartitionType(PartitionTable.Entry[i].PartitionType),
            PartitionTable.Entry[i].StartingLBA,
            PartitionTable.Entry[i].StartingCHS[0], PartitionTable.Entry[i].StartingCHS[1], PartitionTable.Entry[i].StartingCHS[2],
            PartitionTable.Entry[i].EndingCHS[0], PartitionTable.Entry[i].EndingCHS[1], PartitionTable.Entry[i].EndingCHS[2],
            PartitionTable.Entry[i].SizeInSectors);
    }
}

EXT_COMMAND(ms_consoles,
    "Display console command's history ",
    "{;e,o;;}")
{
    ProcessIterator Processes;
    MsProcessObject ProcObject;

    ULONG NumberOfConsoleHandles;

    vector<ULONG64> ConsoleHandles;

    for (Processes.First(); !Processes.IsDone(); Processes.Next())
    {

        ProcObject = Processes.Current();

        // TODO: csrss.exe XP/2003/Vista/
        // csrss.exe

        if (m_Minor >= 7600)
        {
            if (_stricmp(ProcObject.m_CcProcessObject.ImageFileName, "conhost.exe") != 0) continue;

            Dml("   [*] <col fg=\"changed\">Found conhost.exe</col> process (Pid = 0x%x).</col>\n", ProcObject.m_CcProcessObject.ProcessId);

            ProcObject.SwitchContext();
            Execute(".process /p /r 0x%I64X", ProcObject.m_CcProcessObject.ProcessObjectPtr);

            NumberOfConsoleHandles = 1;
            ConsoleHandles.push_back(GetExpression("conhost!gConsoleInformation"));
        }
        else
        {
            if (_stricmp(ProcObject.m_CcProcessObject.ImageFileName, "csrss.exe") != 0) continue;
            Dml("   [*] <col fg=\"changed\">Found csrss.exe</col> process (Pid = 0x%x).</col>\n", ProcObject.m_CcProcessObject.ProcessId);

            ProcObject.SwitchContext();
            Execute(".process /p /r 0x%I64X", ProcObject.m_CcProcessObject.ProcessObjectPtr);

            ULONG64 pNumberOfConsoleHandles = GetExpression("winsrv!NumberOfConsoleHandles");
            ULONG64 pConsoleHandles = GetExpression("winsrv!ConsoleHandles");

            if (!pConsoleHandles || !pNumberOfConsoleHandles) continue;

            if (g_Ext->m_Data->ReadVirtual(pNumberOfConsoleHandles, &NumberOfConsoleHandles, sizeof(ULONG), NULL) != S_OK) continue;

            for (UINT i = 0; i < NumberOfConsoleHandles; i += 1)
            {
                ULONG64 Ptr;
                ReadPointer(pConsoleHandles + (i * m_PtrSize), &Ptr);
                ConsoleHandles.push_back(Ptr);
            }
        }

        for each (ULONG64 gConsoleInformation in ConsoleHandles)
        {
            WCHAR Title[MAX_PATH];

            USHORT HistoryBufferCount, HistoryBufferMax;

            if (!gConsoleInformation) continue;

            ExtRemoteUnTyped ConsoleInfo(gConsoleInformation, "conhost!_CONSOLE_INFORMATION");

            ConsoleInfo.Field("OriginalTitle", TRUE).GetString((PSTR)&Title, sizeof(Title));
            Dml("   -> OriginalTitle = <col fg=\"emphfg\">%S</col>\n", Title);

            ConsoleInfo.Field("Title", TRUE).GetString((PSTR)&Title, sizeof(Title));
            Dml("   -> Title = <col fg=\"emphfg\">%S</col>\n", Title);

            HistoryBufferCount = ConsoleInfo.Field("HistoryBufferCount").GetUshort();
            HistoryBufferMax = ConsoleInfo.Field("HistoryBufferMax").GetUshort();

            Dml("   -> HistoryBufferCount = %x\n", HistoryBufferCount);
            Dml("   -> HistoryBufferMax = %x\n", HistoryBufferMax);

            ULONG64 Rows;
            USHORT ScreenY, ScreenX;

            ScreenY = ConsoleInfo.Field("CurrentScreenBuffer", TRUE).Field("ScreenY").GetUshort();
            ScreenX = ConsoleInfo.Field("CurrentScreenBuffer", TRUE).Field("ScreenX").GetUshort();
            Rows = ConsoleInfo.Field("CurrentScreenBuffer", TRUE).Field("Rows", TRUE).Field("Chars").GetPtr();

            PWSTR Buffer = (LPWSTR)malloc(ScreenY * ScreenX * sizeof(WCHAR));

            if (Buffer) {

                if (g_Ext->m_Data->ReadVirtual(Rows, Buffer, ScreenY * ScreenX * sizeof(WCHAR), NULL) != S_OK) continue;

                ULONG SpaceLinesCount = 0;
                for (UINT y = 0; y < ScreenY; y += 1)
                {
                    BOOLEAN isSpaceLine = TRUE;
                    for (UINT x = 0; x < ScreenX; x += 1)
                    {
                        if (Buffer[(y * ScreenX) + x] != ' ') isSpaceLine = FALSE;
                        Dml("%c", Buffer[(y * ScreenX) + x]);
                    }

                    Dml("\n");

                    if (isSpaceLine) SpaceLinesCount += 1;
                    else SpaceLinesCount = 0;

                    if (SpaceLinesCount > 3) break;
                }
            }
        }

        ProcObject.RestoreContext();
    }

    return;
}

EXT_COMMAND(ms_credentials,
    "Display user's credentials (based on gentilwiki's mimikatz) ",
    "{;e,o;;}")
{
    Mimikatz();
}

EXT_COMMAND(ms_timers,
    "Display list of KTIMER",
    "{;e,o;;}")
{
    Dml("\n"
        "    |----------------------------|--------------------|--------------------|----------|--------------------|------------------------------------------------------|\n"
        "    | <col fg=\"emphfg\">%-26s</col> | <col fg=\"emphfg\">%-18s</col> | <col fg=\"emphfg\">%-18s</col> | <col fg=\"emphfg\">%-8s</col> | <col fg=\"emphfg\">%-18s</col> | <col fg=\"emphfg\">%-6s</col> | <col fg=\"emphfg\">%s</col> |\n"
        "    |----------------------------|--------------------|--------------------|----------|--------------------|------------------------------------------------------|\n",
        "Timer Type", "Timer", "Dpc", "Period", "Deferred Routine", "Hooked", "Module");

    vector<KTIMER> Timers = GetTimers();

    for each (KTIMER Timer in Timers)
    {
        UCHAR Name[512] = { 0 };
        UCHAR TimerType[32] = { 0 };

        switch (Timer.Type)
        {
            case TimerSynchronizationObject:
                StringCchCopyA((LPSTR)TimerType, _countof(TimerType), "TimerSynchronizationObject");
                break;
            case TimerNotificationObject:
                StringCchCopyA((LPSTR)TimerType, _countof(TimerType), "TimerNotificationObject");
                break;
        }
        Dml("    | %-26s | 0x%016I64X | 0x%016I64X | %8d | 0x%016I64X | <col fg=\"changed\">%-6s</col> | %s\n",
            TimerType, Timer.Timer, Timer.Dpc, Timer.Period, Timer.DeferredRoutine,
            GetPointerHookType(Timer.DeferredRoutine) ? "Hooked" : "",
            GetNameByOffset(Timer.DeferredRoutine, (PSTR)Name, _countof(Name)));
    }
}

EXT_COMMAND(ms_vacbs,
    "Display list of cached VACBs",
    "{;e,o;;}")
{
    vector<VACB_OBJECT> Vacbs = GetVacbs();

    Dml("\n"
        "    |--------------------|--------------------|---|--------------------|\n"
        "    | <col fg=\"emphfg\">%-18s</col> | <col fg=\"emphfg\">%-18s</col> | <col fg=\"emphfg\">%s</col> | <col fg=\"emphfg\">%-18s</col> |\n"
        "    |--------------------|--------------------|---|--------------------|\n",
        "VACB", "Base Address", "V", "Shared Cache Map");

    for each (VACB_OBJECT Vacb in Vacbs)
    {
        Dml("    | 0x%016I64X | 0x%016I64X | %s | 0x%016I64X |\n",
            Vacb.Vacb, Vacb.BaseAddress, Vacb.ValidBase ? "Y" : "-", Vacb.SharedCacheMap);
    }
}

EXT_COMMAND(ms_hivelist,
    "Display list of registry hives",
    "{;e,o;;}"
    "{hive;ed,o;hive;Display information for a given registry hive}"
    "{scan;b,o;scan;Display additional information}")
{
    vector<HIVE_OBJECT> Hives = GetHives();

    BOOLEAN Scan = HasArg("scan");
    CHAR Buffer[128] = { 0 };

    Dml("\n"
        "    |------------------------|--------------------|----------------------------------------------------------------------------|------------------------------------------------------------------------\n"
        "    | <col fg=\"emphfg\">%-22s</col> | <col fg=\"emphfg\">%-18s</col> | <col fg=\"emphfg\">%-74s</col> | <col fg=\"emphfg\">%-64s</col>\n"
        "    |------------------------|--------------------|----------------------------------------------------------------------------|------------------------------------------------------------------------\n",
        "Hive ('U' = Untrusted)", "Key Node", "Hive Root Path", "File User Name");

    for each (HIVE_OBJECT Hive in Hives)
    {
        Dml("    | <link cmd = \"!reg openkeys 0x%I64X\">0x%I64X</link> (%s) | <link cmd = \"!ms_readknode 0x%I64X 0x%I64X\">0x%I64X</link> | %-74S | %-64S\n",
            Hive.HivePtr,
            Hive.HivePtr,
            Hive.Flags & CM_FLAG_UNTRUSTED ? "U" : "T",
            Hive.HivePtr,
            Hive.KeyNodePtr,
            Hive.KeyNodePtr,
            Hive.HiveRootPath,
            Hive.FileUserName);

        if (!Scan) continue;

        if (Hive.GetCellRoutine)
        {
            Dml("    \\---| %-24s | %I64X | <col fg=\"changed\">%-6s</col> | <col fg=\"changed\">%s</col> \n",
                "GetCellRoutine", Hive.GetCellRoutine,
                GetPointerHookType(Hive.GetCellRoutine) ? "Hooked" : "",
                GetNameByOffset(Hive.GetCellRoutine, (PSTR)Buffer, _countof(Buffer)));
        }

        if (Hive.ReleaseCellRoutine)
        {
            Dml("    \\---| %-24s | %I64X | <col fg=\"changed\">%-6s</col> | <col fg=\"changed\">%s</col> \n",
                "ReleaseCellRoutine", Hive.ReleaseCellRoutine,
                GetPointerHookType(Hive.GetCellRoutine) ? "Hooked" : "",
                GetNameByOffset(Hive.ReleaseCellRoutine, (PSTR)Buffer, _countof(Buffer)));
        }

        if (Hive.Allocate)
        {
            Dml("    \\---| %-24s | %I64X | <col fg=\"changed\">%-6s</col> | <col fg=\"changed\">%s</col> \n",
                "Allocate", Hive.Allocate,
                GetPointerHookType(Hive.Allocate) ? "Hooked" : "",
                GetNameByOffset(Hive.Allocate, (PSTR)Buffer, _countof(Buffer)));
        }

        if (Hive.Free)
        {
            Dml("    \\---| %-24s | %I64X | <col fg=\"changed\">%-6s</col> | <col fg=\"changed\">%s</col> \n",
                "Free", Hive.Free,
                GetPointerHookType(Hive.Free) ? "Hooked" : "",
                GetNameByOffset(Hive.Free, (PSTR)Buffer, _countof(Buffer)));
        }

        if (Hive.FileSetSize)
        {
            Dml("    \\---| %-24s | %I64X | <col fg=\"changed\">%-6s</col> | <col fg=\"changed\">%s</col> \n",
                "FileSetSize", Hive.FileSetSize,
                GetPointerHookType(Hive.FileSetSize) ? "Hooked" : "",
                GetNameByOffset(Hive.FileSetSize, (PSTR)Buffer, _countof(Buffer)));
        }

        if (Hive.FileWrite)
        {
            Dml("    \\---| %-24s | %I64X | <col fg=\"changed\">%-6s</col> | <col fg=\"changed\">%s</col> \n",
                "FileWrite", Hive.FileWrite,
                GetPointerHookType(Hive.FileWrite) ? "Hooked" : "",
                GetNameByOffset(Hive.FileWrite, (PSTR)Buffer, _countof(Buffer)));
        }

        if (Hive.FileRead)
        {
            Dml("    \\---| %-24s | %I64X | <col fg=\"changed\">%-6s</col> | <col fg=\"changed\">%s</col> \n",
                "FileRead", Hive.FileRead,
                GetPointerHookType(Hive.FileRead) ? "Hooked" : "",
                GetNameByOffset(Hive.FileRead, (PSTR)Buffer, _countof(Buffer)));
        }

        if (Hive.FileFlush)
        {
            Dml("    \\---| %-24s | %I64X | <col fg=\"changed\">%-6s</col> | <col fg=\"changed\">%s</col> \n",
                "FileFlush", Hive.FileFlush,
                GetPointerHookType(Hive.FileFlush) ? "Hooked" : "",
                GetNameByOffset(Hive.FileFlush, (PSTR)Buffer, _countof(Buffer)));
        }
    }

    Dml("\n");
}

EXT_COMMAND(ms_idt,
    "Display IDT",
    "{;e,o;;}"
    "{base;ed,o;base;Display information for a given idt}")
{
    ULONG64 IdtBase = GetArgU64("base", FALSE);
    vector<IDT_ENTRY> IdtEntries = GetInterrupts(IdtBase);

    Dml("    |-----|-----|--------------------|--------------------------------------------------------|---------|--------|\n"
        "    | <col fg=\"emphfg\">%-3s</col> | <col fg=\"emphfg\">%-3s</col> | <col fg=\"emphfg\">%-18s</col> | <col fg=\"emphfg\">%-54s</col> | <col fg=\"emphfg\">%-7s</col> | <col fg=\"emphfg\">%-6s</col> |\n"
        "    |-----|-----|--------------------|--------------------------------------------------------|---------|--------|\n",
        "Cre", "Idx", "Address", "Name", "Patched", "Hooked");

    for each (IDT_ENTRY IdtEntry in IdtEntries) {

        CHAR Name[MAX_PATH] = {0};

        if (IdtEntry.Address) {

            Dml("    | %3d | %3d | <link cmd = \"u 0x%016I64X L5\">0x%016I64X</link> | %-54s | <col fg=\"changed\">%-7s</col> | <col fg=\"changed\">%-6s</col> |\n",
                IdtEntry.CoreIndex,
                IdtEntry.Index,
                IdtEntry.Address,
                IdtEntry.Address,
                GetNameByOffset(IdtEntry.Address, (PSTR)Name, _countof(Name)),
                IdtEntry.Address ? "" : "",
                GetPointerHookType(IdtEntry.Address) ? "Yes" : "");
        }
    }
}

LPSTR GdtType[] = {
    "Data RO",
    "Data RO Ac",
    "Data RW",
    "Data RW Ac",
    "Data RO E",
    "Data RO EA",
    "Data RW E",
    "Data RW EA",
    "Code EO",
    "Code EO Ac",
    "Code RE",
    "Code RE Ac",
    "Code EO C",
    "Code EO CA",
    "Code RE C",
    "Code RE CA",
    "<Reserved>",
    "TSS16 Avl",
    "LDT",
    "TSS16 Busy",
    "CallGate16",
    "TaskGate",
    "Int Gate16",
    "TrapGate16",
    "<Reserved>",
    "TSS32 Avl",
    "<Reserved>",
    "TSS32 Busy",
    "CallGate32",
    "<Reserved>",
    "Int Gate32",
    "TrapGate32",
    NULL
};

EXT_COMMAND(ms_gdt,
    "Display GDT",
    "{;e,o;;}"
    "{base;ed,o;base;Display information for a given gdt}")
{
    ULONG64 GdtBase = GetArgU64("base", FALSE);
    vector<GDT_OBJECT> Gdts = GetDescriptors(GdtBase);

    Dml("    |-----|-----|--------------------|--------------------------------------------------------|\n"
        "    | <col fg=\"emphfg\">%-3s</col> | <col fg=\"emphfg\">%-3s</col> | <col fg=\"emphfg\">%-32s</col> | <col fg=\"emphfg\">%-18s</col> | <col fg=\"emphfg\">%-54s</col> |\n"
        "    |-----|-----|--------------------|--------------------------------------------------------|\n",
        "Cre", "Idx", "Type", "Address", "Name");

    for each (GDT_OBJECT Gdt in Gdts)
    {
        Dml("    | %3d | %3x | %-32s | 0x%016I64X | %-54s |\n",
            Gdt.CoreIndex,
            Gdt.Index,
            GdtType[Gdt.Type],
            Gdt.Base,
            "None");
    }
}

EXT_COMMAND(ms_malscore,
    "Analyze a memory space and returns a Malware Score Index (MSI) - (based on Frank Boldewin's work)",
    "{;ed;base;Base address}{;ed;size;Memory space size}")
{
    ULONG64 BaseAddress = GetUnnamedArgU64(0);
    ULONG Size = (ULONG)GetUnnamedArgU64(1);

    LPBYTE Buffer = NULL;

    Dml("   [ <col fg=\"changed\">Base:</col> <col fg=\"emphfg\">0x%016I64X</col>\n"
        "   [ <col fg=\"changed\">Size:</col> <col fg=\"emphfg\">0x%X</col>\n",
        BaseAddress, Size);

    Buffer = (LPBYTE)malloc(Size);

    if (!Buffer) {

        goto CleanUp;
    }

    if (ExtRemoteTypedEx::ReadVirtual(BaseAddress, Buffer, Size, NULL) != S_OK)
    {
        Err("Error: Failed to read the memory buffer.\n");
        goto CleanUp;
    }

    ULONG MalwareScoreIndex = GetMalScore(TRUE, BaseAddress, Buffer, Size);

    Dml("   -> <col fg=\"changed\">Malware Score Index (MSI)</col> = <col fg=\"emphfg\">%d</col>\n", MalwareScoreIndex);

CleanUp:

    if (Buffer) free(Buffer);
}

EXT_COMMAND(ms_exqueue,
    "Display Ex queued workers",
    "{;e,o;;}")
{
    GetExQueue();
}

EXT_COMMAND(ms_store,
    "Display information related to the Store Manager (ReadyBoost)",
    "{cache;b,o;cache;Display process information for a cache index}"
    "{log;b,o;log;Display ReadyBoost log}")
{

    StoreManager StrMgr;


    if (HasArg("log"))
    {
        // g_Ext->Dml("Show logs !\n");

        StrMgr.GetSmLogEntries();
    }
    else if (HasArg("cache"))
    {
        ULONG CacheIndex = (ULONG)-1;
        // g_Ext->Dml("Show cache !\n");

        StrMgr.SmiEnumCaches(CacheIndex);
    }
}

EXT_COMMAND(ms_scanndishook,
    "Scan and display suspicious NDIS hooks",
    "")
{
    ULONG64 Address;
    ULONG ulNdisChecked;
    ULONG Status;
    ULONG cbBytesReturned;

    // Create instance of our NDISKD class object
    CNdiskd *myNdiskd = new CNdiskd;

    // Get the WinDBG-style extension APIS.   
    ExtensionApis.nSize = sizeof(ExtensionApis);

    // Initialize ExtensionsApis
    g_Ext->m_Control->GetWindbgExtensionApis64(&ExtensionApis);

    // Get NDIS module base address
    ULONG moduleIdx = 0;
    ULONG64 Base = 0;
    Status = g_Ext->m_Symbols->GetModuleByModuleName(NDIS_NAME, 0, &moduleIdx, &Base);

    // If not loaded then execute ".reload" command to reload ndis.sys symbol
    if (Status == E_INVALIDARG)
    {
        CHAR szCommand[256] = { 0 };

        g_Ext->m_Control->Output(DEBUG_OUTPUT_NORMAL, "%s symbol not found. Reloading (.reload) %s\n", NDIS_NAME, NDIS_DRV_NAME);

        sprintf_s(szCommand, _countof(szCommand), ".reload /f %s", NDIS_DRV_NAME);

        // Execute reload command
        g_Ext->m_Control->Execute(DEBUG_OUTCTL_IGNORE | DEBUG_OUTCTL_NOT_LOGGED, szCommand, DEBUG_EXECUTE_NOT_LOGGED);

        // Make sure the NDIS symbol has been loaded
        Status = g_Ext->m_Symbols->GetModuleByModuleName(NDIS_NAME, 0, &moduleIdx, &Base);

        // NDIS symbol reload failed again?
        if (Status == E_INVALIDARG)
        {
            g_Ext->m_Control->Output(DEBUG_OUTPUT_NORMAL, "%s symbol loaded failed!\n", NDIS_NAME);
        }
    }

    if (Base > 0)
    {
        // Save NDIS address range
        myNdiskd->m_ndisBaseAddress = Base;
        myNdiskd->m_ndisEndAddress = Base + utils::getModuleSize(Base);
        g_Ext->m_Control->Output(DEBUG_OUTPUT_NORMAL, "%s image: %I64x-%I64x\n", NDIS_NAME, myNdiskd->m_ndisBaseAddress, myNdiskd->m_ndisEndAddress);
    }

    // Read address of ndis!ndisChecked
    Address = GetExpression("ndis!ndisChecked");

    // Got ndisChecked address
    if (Address)
    {
        cbBytesReturned = 0;
        ulNdisChecked = utils::getUlongFromAddress(Address, &cbBytesReturned);

        if (cbBytesReturned == sizeof(ULONG))
        {
            if (ulNdisChecked == 1)
            {
                g_Ext->m_Control->Output(DEBUG_OUTPUT_NORMAL, "Ndis build: Checked\n");
            }
            else if (ulNdisChecked == 0)
            {
                g_Ext->m_Control->Output(DEBUG_OUTPUT_NORMAL, "Ndis build: Free\n");
            }

            // Store ndisChecked value
            myNdiskd->m_ndiskdChecked = ulNdisChecked;
        }
    }

    // Read ndis!ndisBuildDate
    Address = GetExpression("ndis!ndisBuildDate");

    // Got ndisBuildDate address
    if (Address)
    {
        ExtRemoteTyped ndisBuildDate("(nt!_UNICODE_STRING*)@$extin", Address);

        // Get the build date in wide character
        utils::getUnicodeString(ndisBuildDate, myNdiskd->m_ndiskdBuildDate, MAX_PROTOCOL_NAME*sizeof(WCHAR));

    }

    // Read ndis!ndisBuildTime
    Address = GetExpression("ndis!ndisBuildTime");

    // Got ndisBuildTime address
    if (Address)
    {
        ExtRemoteTyped ndisBuildTime("(nt!_UNICODE_STRING*)@$extin", Address);

        // Get the build time in wide character
        utils::getUnicodeString(ndisBuildTime, myNdiskd->m_ndiskdBuildTime, MAX_PROTOCOL_NAME*sizeof(WCHAR));
    }

    // Read ndis!ndisBuiltBy
    Address = GetExpression("ndis!ndisBuiltBy");

    // Got ndisBuiltBy address
    if (Address)
    {
        ExtRemoteTyped ndisBuitBy("(nt!_UNICODE_STRING*)@$extin", Address);

        // Get Ndis's author in wide character
        utils::getUnicodeString(ndisBuitBy, myNdiskd->m_ndiskdBuiltBy, MAX_PROTOCOL_NAME*sizeof(WCHAR));
    }

    if (wcslen(myNdiskd->m_ndiskdBuildDate) > 0)
    {
        g_Ext->m_Control->Output(DEBUG_OUTPUT_NORMAL, "Ndis build date: %ls\n", myNdiskd->m_ndiskdBuildDate);
    }

    if (wcslen(myNdiskd->m_ndiskdBuildTime) > 0)
    {
        g_Ext->m_Control->Output(DEBUG_OUTPUT_NORMAL, "Ndis build time: %ls\n", myNdiskd->m_ndiskdBuildTime);
    }

    if (wcslen(myNdiskd->m_ndiskdBuiltBy) > 0)
    {
        g_Ext->m_Control->Output(DEBUG_OUTPUT_NORMAL, "Ndis built by: %ls\n", myNdiskd->m_ndiskdBuiltBy);
    }

    // Instantiate report object
    CReport *reporter = new CReport(g_Ext);

    // Get protocol list
    std::list<CProtocols*> protocolList;
    Dml("<col fg=\"srccmnt\">Scanning network protocol list...</col>\n");
    myNdiskd->GetProtocolList(&protocolList);

    // Walk through protocol list and check the function handlers
    for (std::list<CProtocols*>::iterator it = protocolList.begin(); it != protocolList.end(); ++it)
    {
        std::map<PCSTR, ULONG64> listHandlers;

        (*it)->GetFunctionHandlers(&listHandlers);

        //g_Ext->m_Control->Output(DEBUG_OUTPUT_NORMAL, "Protocol: %ls\n", (*it)->GetProtocolName());

        // Walk through each function handlers
        for (std::map<PCSTR, ULONG64>::iterator it2 = listHandlers.begin(); it2 != listHandlers.end(); ++it2)
        {
            if (it2->second != NULL)
            {
                DbgPrint("DEBUG: %s:%d:%s Function handler: %s (%I64x)\n", __FILE__, __LINE__, __FUNCTION__, it2->first, it2->second);

                int rule = 0;

                if (/*myNdiskd->IsNdisHook(it2->second) ||*/ myNdiskd->HeuristicHookCheck(it2->second, rule))
                {
                    reporter->ReportHooks("<col fg=\"emphfg\">   Hooked handler:</col> %s (<link cmd=\"u %I64x\">0x%I64X</link>) from protocol <b>%ls</b> (Rule #%d - %s)\n", it2->first, it2->second, it2->second, (*it)->GetProtocolName(), rule, myNdiskd->GetHookType(rule));
                }
            }
        }
    }

    // Get miniport list
    std::list<CAdapters*> miniportlist;
    Dml("<col fg=\"srccmnt\">Scanning network adapter list...\n</col>");
    myNdiskd->GetAdapterList(&miniportlist);

    // Walk through all the adapters and look for hook handlers
    for (std::list<CAdapters*>::iterator it = miniportlist.begin(); it != miniportlist.end(); ++it)
    {
        std::map<PCSTR, ULONG64> listHandlers;

        (*it)->GetFunctionHandlers(&listHandlers);
        //g_Ext->m_Control->Output(DEBUG_OUTPUT_NORMAL, "Adapter: %ls\n", (*it)->GetAdapterName());

        // Walk through each function handlers
        for (std::map<PCSTR, ULONG64>::iterator it2 = listHandlers.begin(); it2 != listHandlers.end(); ++it2)
        {
            if (it2->second != NULL)
            {
                DbgPrint("DEBUG: %s:%d:%s Function handler: %s (%I64x)\n", __FILE__, __LINE__, __FUNCTION__, it2->first, it2->second);

                int rule = 0;

                if (myNdiskd->IsNdisHook(it2->second) /*|| myNdiskd->HeuristicHookCheck(it2->second, rule)*/)
                {
                    reporter->ReportHooks("<col fg=\"emphfg\">   Hooked handler:</col> %s (<link cmd=\"u %I64x\">0x%I64X</link>) from adapter <b>%ls</b> (Rule #%d - %s)\n", it2->first, it2->second, it2->second, (*it)->GetAdapterName(), rule, myNdiskd->GetHookType(rule));
                }
            }
        }
    }

    // Get open bindings between protocol (eg: TCPIP) and miniport (eg: NIC adapter Intel(R) Gigabit Network Connection)
    std::list<COpenblock*> openblocklist;
    Dml("<col fg=\"srccmnt\">Scanning network binder list...\n</col>");
    myNdiskd->GetOpenblockList(&openblocklist);

    // Walk through all the binders and look for hook handlers
    for (std::list<COpenblock*>::iterator it = openblocklist.begin(); it != openblocklist.end(); ++it)
    {
        std::map<PCSTR, ULONG64> listHandlers;

        (*it)->GetFunctionHandlers(&listHandlers);

        //g_Ext->m_Control->Output(DEBUG_OUTPUT_NORMAL, "Binder: %ls\n", (*it)->GetBinderName());

        // Walk through each function handlers
        for (std::map<PCSTR, ULONG64>::iterator it2 = listHandlers.begin(); it2 != listHandlers.end(); ++it2)
        {
            if (it2->second != NULL)
            {
                int rule = 0;

                DbgPrint("DEBUG: %s:%d:%s Function handler: %s (%I64x)\n", __FILE__, __LINE__, __FUNCTION__, it2->first, it2->second);

                if ((*it)->IsHandlerHooked(it2->second) || myNdiskd->HeuristicHookCheck(it2->second, rule))
                {
                    reporter->ReportHooks("<col fg=\"emphfg\">   Hooked handler:</col> %s (<link cmd=\"u %I64x\">0x%I64X</link>) from binder <b>%ls</b> (Rule #%d - %s)\n", it2->first, it2->second, it2->second, (*it)->GetBinderName(), rule, myNdiskd->GetHookType(rule));
                }
            }
        }
    }

    // Get minidriver list
    std::list<CMinidriver*> miniDrvList;
    Dml("<col fg=\"srccmnt\">Scanning network mini-driver list...</col>\n");
    myNdiskd->GetMDriverList(&miniDrvList);

    // Walk through all the mini-drivers and look for hook handlers
    for (std::list<CMinidriver*>::iterator it = miniDrvList.begin(); it != miniDrvList.end(); ++it)
    {
        std::map<PCSTR, ULONG64> listHandlers;

        (*it)->GetFunctionHandlers(&listHandlers);

        //g_Ext->m_Control->Output(DEBUG_OUTPUT_NORMAL, "Mini-driver: %ls\n", (*it)->GetMDriverName());

        // Walk through each function handlers
        for (std::map<PCSTR, ULONG64>::iterator it2 = listHandlers.begin(); it2 != listHandlers.end(); ++it2)
        {
            if (it2->second != NULL)
            {
                int rule = 0;

                DbgPrint("DEBUG: %s:%d:%s Function handler: %s (%I64x)\n", __FILE__, __LINE__, __FUNCTION__, it2->first, it2->second);

                if ((*it)->IsHandlerHooked(it2->second) || myNdiskd->HeuristicHookCheck(it2->second, rule))
                {
                    reporter->ReportHooks("<col fg=\"emphfg\">   Hooked handler:</col> %s (<link cmd=\"u %I64x\">0x%I64X</link>) from adapter <b>%ls</b> (Rule #%d - %s)\n", it2->first, it2->second, it2->second, (*it)->GetMDriverName(), rule, myNdiskd->GetHookType(rule));
                }
            }
        }
    }

    // Object instances cleanup here
    // Cleanup Ndiskd object.
    delete myNdiskd;

    // Cleanup protocols object
    for (std::list<CProtocols*>::iterator it = protocolList.begin(); it != protocolList.end(); ++it)
    {
        delete *it;
    }

    // Cleanup adapters object
    for (std::list<CAdapters*>::iterator it = miniportlist.begin(); it != miniportlist.end(); ++it)
    {
        delete *it;
    }

    // Cleanup binder object
    for (std::list<COpenblock*>::iterator it = openblocklist.begin(); it != openblocklist.end(); ++it)
    {
        delete *it;
    }

    // Cleanup mini-driver object
    for (std::list<CMinidriver*>::iterator it = miniDrvList.begin(); it != miniDrvList.end(); ++it)
    {
        delete *it;
    }
}

EXT_COMMAND(ms_fixit,
    "Reset segmentation in WinDbg (Fix \"16.kd>\")",
    "{;e,o;;}")
{
    switch (g_Ext->m_ActualMachine) {

    case IMAGE_FILE_MACHINE_I386:
    {
        Execute(".segmentation -X");

        break;
    }
    case IMAGE_FILE_MACHINE_AMD64:
    {
        Execute(".segmentation -X -a;.effmach amd64");

        g_Ext->m_PtrSize = sizeof(ULONG64);

        break;
    }
    }
}

EXT_COMMAND(ms_verbose,
    "Turn verbose mode on/off",
    "{;e,o;;}")
{
    g_Verbose = !g_Verbose;
}

EXT_COMMAND(ms_checkcodecave,
            "Look for used code cave",
            "{;e,o;;}"
            "{pid;ed,d=0;pid;Process Id}")
{
    ULONG64 ProcessId = GetArgU64("pid", FALSE);
    ProcessArray CachedProcessList = GetProcesses(ProcessId, PROCESS_DLLS_FLAG | PROCESS_DLL_EXPORTS_FLAG);

    if (ProcessId) {
        Dml(" [-] Checking process id: 0x%llX\n", ProcessId);
    }
    else {
        Dml(" [-] Checking all available processes.\n");
    }

    if (g_Verbose) Dml("Head: 0x%llX\n", ExtNtOsInformation::GetKernelProcessListHead());

    for each (MsProcessObject ProcObject in CachedProcessList)
    {
        if (ProcessId) {
            if (ProcessId != ProcObject.m_CcProcessObject.ProcessId) continue;
        }

        if (!ProcObject.SwitchContext()) {
            if (g_Verbose) Dml(" [-] Can't switch context.\n");
            continue;
        }

        if (g_Verbose) Dml("Looking inside the executable sections...\n");
        for each (MsPEImageFile::CACHED_SECTION_INFO SectionHeader in ProcObject.m_CcSections) {
            if (g_Verbose)  Dml(" [!] Section: %s\n", SectionHeader.Name);
            ULONG CorruptionScore = 0;
            if (ULONG Offset = HasUsedCodeCave(ProcObject.m_ImageBase, &ProcObject.m_CcSections, &SectionHeader, &CorruptionScore)) {
                Dml(" [!][Score = %5d] (Pid=0x%llX, Name=%s) corruptioned detected at 0x%llX (0x%x) inside \"%s\" section.\n",
                    CorruptionScore,
                    ProcObject.m_CcProcessObject.ProcessId,
                    ProcObject.m_CcProcessObject.ImageFileName,
                    ProcObject.m_ImageBase + Offset,
                    Offset,
                    SectionHeader.Name);
            }
        }

        if (g_Verbose) Dml("Looking inside the dlls sections...\n");
        for each (MsDllObject DllObj in ProcObject.m_DllList) {
            if (g_Verbose)  Dml("   [!] Dll: %S\n", DllObj.mm_CcDllObject.DllName);
            for each (MsPEImageFile::CACHED_SECTION_INFO SectionHeader in DllObj.m_CcSections) {
                if (g_Verbose)  Dml("   [!] Dll: %S (section: %s)\n", DllObj.mm_CcDllObject.DllName, SectionHeader.Name);
                ULONG CorruptionScore = 0;
                if (ULONG Offset = HasUsedCodeCave(DllObj.m_ImageBase, &DllObj.m_CcSections, &SectionHeader, &CorruptionScore)) {
                    if (CorruptionScore > 8) {
                        Dml(" [!][Score = %5d] (Pid=0x%llX, Name=%s, Dll=%S) corruption detected at <link cmd=\"db %I64x\">0x%I64X</link> (0x%x) inside \"%s\" section.\n",
                            CorruptionScore,
                            ProcObject.m_CcProcessObject.ProcessId,
                            ProcObject.m_CcProcessObject.ImageFileName,
                            DllObj.mm_CcDllObject.DllName,
                            DllObj.m_ImageBase + Offset,
                            DllObj.m_ImageBase + Offset,
                            Offset,
                            SectionHeader.Name);
                    }
                }
            }
        }

        ProcObject.RestoreContext();
    }
}

EXT_COMMAND(ms_lxss,
    "Display lsxx entries",
    "{;e,o;;}")
{
    GetLX();
}

EXT_COMMAND(ms_yarascan,
    "Scan process memory using yara rules",
    "{;e,o;;}"
    "{pid;ed,o;pid;Process Id}"
    "{yarafile;s;yarafile;Yara rules file}"
    )
{
    ULONG64 Pid;
    PCSTR FileName;

    Pid = GetArgU64("pid", FALSE);
    FileName = GetArgStr("yarafile", FALSE);

    ProcessArray CachedProcessList = GetProcesses(Pid, 0);

    if (CachedProcessList.size()) {

        MsProcessObject ProcObj = CachedProcessList[0];

        Dml("\n<col fg=\"changed\">Process:</col> <link cmd=\"!process %p 1\">%s</link>, Pid: 0x%x\n\n",
            ProcObj.m_CcProcessObject.ProcessObjectPtr,
            ProcObj.m_CcProcessObject.ImageFileName,
            ProcObj.m_CcProcessObject.ProcessId);

        YaraScan(&ProcObj, FileName);
    }
}

EXT_COMMAND(ms_regcheck,
    "Scan for suspicious registry entries",
    "{;e,o;;}"
    )
{
    BYTE KeyValue[MAX_PATH * 8];
    ULONG DataLength;
    static REG_CHECK RegChecks[] = {
        L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\StandardProfile\\GloballyOpenPorts\\List", L"3389:TCP", REG_SZ,
        L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\DomainProfile\\GloballyOpenPorts\\List", L"3389:TCP", REG_SZ,
        L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server", L"fDenyTSConnections", REG_DWORD,
        L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server", L"fSingleSessionPerUser", REG_DWORD,
        L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Licensing Core", L"EnableConcurrentSessions", REG_DWORD,
        L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", L"EnableConcurrentSessions", REG_DWORD,
        L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", L"AllowMultipleTSSessions", REG_DWORD,
        L"\\REGISTRY\\MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\Terminal Services", L"MaxInstanceCount", REG_DWORD,
        L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\SpecialAccounts\\UserList", L"MS_BACKUP", REG_DWORD,
        L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies\\system", L"dontdisplaylastusername", REG_DWORD,
        L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies\\system", L"LocalAccountTokenFilterPolicy", REG_DWORD,
        L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest", L"UseLogonCredential", REG_DWORD
    };

    if (RegInitialize()) {

        for (size_t i = 0; i < _countof(RegChecks); i++) {

            Dml("\n%S\n", RegChecks[i].KeyName);
            Dml("%S    %S    ", RegChecks[i].ValueName, GetRegistryValueTypeName(RegChecks[i].ValueType));

            if (RegGetKeyValue(RegChecks[i].KeyName, RegChecks[i].ValueName, KeyValue, sizeof(KeyValue), &DataLength)) {

                switch (RegChecks[i].ValueType) {

                case REG_BINARY:
                {
                    size_t k;

                    g_Ext->Dml("\n        ");

                    for (size_t j = 0; j < DataLength; j++) {

                        for (k = 0; ((j + k) < DataLength) && (k < 0x10); k++) {

                            g_Ext->Dml("0x%02x ", KeyValue[j + k]);
                        }

                        for ( ; k < 0x10; k++) {

                            g_Ext->Dml("     ");
                        }

                        g_Ext->Dml(" | ");

                        for (k = 0; ((j + k) < DataLength) && (k < 0x10); k++) {

                            g_Ext->Dml("%c ", ((KeyValue[j + k] >= ' ') && (KeyValue[j + k] <= 'Z')) ? KeyValue[j + k] : '.');
                        }

                        g_Ext->Dml("\n        ");

                        j += k;
                    }

                    break;
                }
                case REG_SZ:
                case REG_EXPAND_SZ:
                case REG_LINK:
                case REG_MULTI_SZ:
                {
                    g_Ext->Dml("%S", (PWSTR)KeyValue);

                    break;
                }
                case REG_DWORD:
                {
                    g_Ext->Dml("0x%08x", *(PULONG)KeyValue);

                    break;
                }
                case REG_QWORD:
                {
                    g_Ext->Dml("0x%I64x", *(PULONG64)KeyValue);

                    break;
                }
                }
            }

            Dml("\n");
        }
    }
}

// Great article from aionescu on this: https://www.crowdstrike.com/blog/sheep-year-kernel-heap-fengshui-spraying-big-kids-pool/
EXT_COMMAND(ms_pools,
    "Display list of big pools for suspicious allocations",
    "{;e,o;;}"
    "{scan;b,o;scan;Display only malicious artifacts}")
{
    ULONG64 Offset = 0;
    ULONG64 PoolBigPageTablePtr = 0;
    ULONG PoolBigPageTableSize = 0;

    BOOLEAN bScan = FALSE;

    if (HasArg("scan"))
    {
        bScan = TRUE;
    }
    
    if (g_Ext->m_Symbols->GetOffsetByName("nt!PoolBigPageTable", &Offset) != S_OK) goto Exit;
    if (!ReadPointer(Offset, &PoolBigPageTablePtr)) goto Exit;

    if (g_Ext->m_Symbols->GetOffsetByName("nt!PoolBigPageTableSize", &Offset) != S_OK) goto Exit;
    if (g_Ext->m_Data->ReadVirtual(Offset, (PUCHAR)&PoolBigPageTableSize, sizeof(PoolBigPageTableSize), NULL) != S_OK) goto Exit;

    ULONG sizePoolTrackerBigPages = GetTypeSize("nt!_POOL_TRACKER_BIG_PAGES");
    ULONG maxEntries = PoolBigPageTableSize / sizePoolTrackerBigPages;

    for (ULONG i = 0; i < maxEntries; i++) {
        UCHAR Key[5] = { 0 };
        ULONG Key32 = 0;

        ULONG64 TableEntryOffset = PoolBigPageTablePtr + (i * sizePoolTrackerBigPages);
        ExtRemoteTyped TableEntry("(nt!_POOL_TRACKER_BIG_PAGES *)@$extin", TableEntryOffset);

        ULONG64 Va = TableEntry.Field("Va").GetPtr();
        Va = Va & ~1;

        Key32 = TableEntry.Field("Key").GetUlong();

        Key[0] = (Key32 >> 0 & 0xFF);
        Key[1] = (Key32 >> 8 & 0xFF);
        Key[2] = (Key32 >> 16 & 0xFF);
        Key[3] = (Key32 >> 24 & 0xFF);

        ULONG NumberOfBytes = (ULONG)TableEntry.Field("NumberOfBytes").GetPtr();

        ULONG CodeScore = 0;
        BOOLEAN IsImage = FALSE;
        USHORT Sig = 0;

        ULONG64 Pte = 0;
        BOOLEAN IsUserMode = FALSE;

        if (Va) {
            CHAR executableCmd[128] = { 0 };
            CHAR cmd[128] = { 0 };

            if (TRUE) { // bScan) {
                CodeScore = GetMalScoreEx(FALSE, NULL, Va, NumberOfBytes);
                IsImage = IsImageInMemory(Va, &Sig);
                Pte = GetPteFromAddress(Va);
                IsUserMode = IS_PTE_OWNER_USERMODE(Pte);
            }

            sprintf_s(cmd, sizeof(cmd), "0x%I64X", Va);
            sprintf_s(executableCmd, sizeof(executableCmd), "<link cmd=\"!dh 0x%I64X\">0x%I64X</link>", Va, Va);

            if ((bScan && (IsImage || CodeScore || IsUserMode)) || (!bScan)) {
                Dml("<link cmd=\"dt nt!_POOL_TRACKER_BIG_PAGES 0x%I64X\">[%05d]</link> VA: %s Size: 0x%06lx Tag: %c%c%c%c PoolType: 0x%04x CodeScore: <col fg=\"%s\">%d</col> IsImage: <col fg=\"%s\">%s</col> Mode: <col fg=\"%s\">%s</col>\n",
                    TableEntryOffset,
                    i,
                    IsImage ? executableCmd : cmd,
                    NumberOfBytes,
                    Key[0], Key[1], Key[2], Key[3],
                    TableEntry.Field("PoolType").GetLong(),
                    CodeScore ? "changed" : "", CodeScore,
                    IsImage ? "changed" : "", IsImage ? "Yes" : "No",
                    IsUserMode ? "changed" : "", IsUserMode ? "User-Mode" : "Kernel-Mode");
            }
        }
    }

Exit:
    return;
}
```

`SwishDbgExt/SwishDbgExt.def`:

```def
EXPORTS

;--------------------------------------------------------------------
; Core exports provided by the ExtCpp framework.
;--------------------------------------------------------------------

    DebugExtensionInitialize
    DebugExtensionUninitialize
    DebugExtensionNotify

;--------------------------------------------------------------------
; Extension commands.
;--------------------------------------------------------------------

    ms_dump
    ms_hivelist
    ms_readkcb
    ms_readknode
    ms_readkvalue

    ms_consoles

    ms_object

    ms_credentials

    ms_netstat
    ms_mbr

    ms_drivers

    ms_timers
    ms_vacbs

    ms_process
    ms_services
    ms_callbacks
    ms_ssdt

    ms_idt
    ms_gdt

    ms_malscore

    ms_exqueue

    ms_store

    ms_scanndishook

    ms_checkcodecave
    ms_verbose
    ms_fixit
	
	ms_lxss

    ms_yarascan
    ms_regcheck
    ms_pools

    help
```

`SwishDbgExt/SwishDbgExt.h`:

```h
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)
	Copyright (C) 2014 wLcY (@x9090)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - SwishDbgExt.c

Abstract:

    - 


Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#define VERBOSE_MODE FALSE
#define VVERBOSE_MODE FALSE
#define JSON_SUPPORT FALSE

using namespace std;

#if JSON_SUPPORT
#include <json.h>
#include <http_client.h>

using namespace web;
using namespace web::http;
using namespace web::http::client;
#endif

#pragma once

#include "engextcpp.hpp"
#include "EngExpCppEx.h"
#include "UntypedData.h"

#include "NtDef.h"
#include "DbgHelpEx.h"

#include "Credentials.h"
#include "Process.h"
#include "Drivers.h"
#include "Registry.h"
#include "Network.h"
#include "System.h"
#include "Storage.h"
#include "VirusTotal.h"
#include "Checks\Codecave.h"
#include "Lxss.h"
#include "Yara.h"

#include "Security.h"
#include "Objects.h"
#include "Md5.h"
#include "Output.h"
#include "Common.h"
#include "CNdiskd\CNdiskd.h"

#pragma comment(lib, "version.lib")
#if JSON_SUPPORT
#pragma comment(lib, "cpprest120_1_4.lib")
#endif

#ifndef COMAE_TOOLKIT_VERSION
#define COMAE_TOOLKIT_VERSION ""
#endif

#define API_EXPORT __declspec(dllexport)
#define SIGN_EXTEND(_x_) (ULONG64)(LONG)(_x_) 
#define PAGE_SIZE 0x1000

#if VERBOSE_MODE
#define ASSERTDBG(exp) if (!(exp)) g_Ext->Dml("ASSERT: %s:%d:%s %s\n", __FILE__, __LINE__, __FUNCTION__, #exp);
#define ASSERT(exp) if (!(exp)) g_Ext->Dml("ASSERT: %s:%d:%s %s\n", __FILE__, __LINE__, __FUNCTION__, #exp);
#else
#define ASSERTDBG(exp) ((void)0)
#define ASSERT(exp) exp;
#endif

#define GetPtrSize() (g_Ext->m_PtrSize)
#define DbgPrint(fmt,...) if (g_Verbose) g_Ext->Dml(fmt, __VA_ARGS__);

#ifdef __cplusplus
extern "C" {
#endif

//
// Definition
//

extern BOOLEAN g_Verbose;
extern ULONG64 KeNumberProcessorsAddress;
extern ULONG64 KiProcessorBlockAddress;
extern ULONG64 ObpRootDirectoryObjectAddress;
extern ULONG64 ObTypeIndexTableAddress;
extern ULONG64 ObHeaderCookieAddress;
extern ULONG64 CmpRegistryRootObjectAddress;
extern ULONG64 CmpMasterHiveAddress;

VOID
ReleaseObjectTypeTable(
    VOID
    );

#ifdef __cplusplus
}
#endif
```

`SwishDbgExt/SwishDbgExt.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENG)
LANGUAGE LANG_ENGLISH, SUBLANG_DEFAULT

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "#include ""Version.rc""\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#include "Version.rc"

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`SwishDbgExt/SwishDbgExt.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3DEADBA0-BE78-43B7-A17A-027F185957E6}</ProjectGuid>
    <RootNamespace>SwishDbgExt</RootNamespace>
    <ProjectName>SwishDbgExt</ProjectName>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)$(Configuration)\$(PlatformTarget)\</OutDir>
    <IntDir>$(Configuration)\$(PlatformTarget)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)$(Configuration)\$(PlatformTarget)\</OutDir>
    <IntDir>$(Configuration)\$(PlatformTarget)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)$(Configuration)\$(PlatformTarget)\</OutDir>
    <IntDir>$(Configuration)\$(PlatformTarget)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)$(Configuration)\$(PlatformTarget)\</OutDir>
    <IntDir>$(Configuration)\$(PlatformTarget)\</IntDir>
    <ExcludePath>$(ExcludePath);$(SystemRoot)</ExcludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <DisableSpecificWarnings>4201</DisableSpecificWarnings>
      <ExceptionHandling>Async</ExceptionHandling>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>SwishDbgExt.def</ModuleDefinitionFile>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <ForcedIncludeFiles>
      </ForcedIncludeFiles>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <DisableSpecificWarnings>4201</DisableSpecificWarnings>
      <ExceptionHandling>Async</ExceptionHandling>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>SwishDbgExt.def</ModuleDefinitionFile>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <DisableSpecificWarnings>4201</DisableSpecificWarnings>
      <ExceptionHandling>Async</ExceptionHandling>
      <AdditionalOptions>/Qspectre</AdditionalOptions>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <ModuleDefinitionFile>SwishDbgExt.def</ModuleDefinitionFile>
      <SubSystem>Windows</SubSystem>
      <SetChecksum>true</SetChecksum>
      <AdditionalOptions>/PDBALTPATH:%_PDB% %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <PostBuildEvent />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <DisableSpecificWarnings>4201</DisableSpecificWarnings>
      <ExceptionHandling>Async</ExceptionHandling>
      <AdditionalOptions>/Qspectre</AdditionalOptions>
      <ControlFlowGuard>Guard</ControlFlowGuard>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <ModuleDefinitionFile>SwishDbgExt.def</ModuleDefinitionFile>
      <SubSystem>Windows</SubSystem>
      <SetChecksum>true</SetChecksum>
      <AdditionalOptions>/PDBALTPATH:%_PDB% %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <PostBuildEvent />
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Azure.cpp" />
    <ClCompile Include="Checks\Codecave.cpp" />
    <ClCompile Include="CNdiskd\CAdapters.cpp" />
    <ClCompile Include="CNdiskd\CMinidriver.cpp" />
    <ClCompile Include="CNdiskd\CNdiskd.cpp" />
    <ClCompile Include="CNdiskd\COpenblock.cpp" />
    <ClCompile Include="CNdiskd\CProtocols.cpp" />
    <ClCompile Include="CNdiskd\CReport.cpp" />
    <ClCompile Include="CNdiskd\utils.cpp" />
    <ClCompile Include="Drivers.cpp" />
    <ClCompile Include="engextcpp.cpp" />
    <ClCompile Include="Credentials.cpp" />
    <ClCompile Include="DbgHelpEx.cpp" />
    <ClCompile Include="EngExtCppEx.cpp" />
    <ClCompile Include="Lxss.cpp" />
    <ClCompile Include="Md5.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="SwishDbgExt.cpp" />
    <ClCompile Include="Network.cpp" />
    <ClCompile Include="Objects.cpp" />
    <ClCompile Include="Output.cpp" />
    <ClCompile Include="Process.cpp" />
    <ClCompile Include="Registry.cpp" />
    <ClCompile Include="Security.cpp" />
    <ClCompile Include="Storage.cpp" />
    <ClCompile Include="System.cpp" />
    <ClCompile Include="UntypedData.cpp" />
    <ClCompile Include="VirusTotal.cpp" />
    <ClCompile Include="Yara.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Azure.h" />
    <ClInclude Include="Checks\Codecave.h" />
    <ClInclude Include="CNdiskd\CAdapters.h" />
    <ClInclude Include="CNdiskd\CMinidriver.h" />
    <ClInclude Include="CNdiskd\CNdiskd.h" />
    <ClInclude Include="CNdiskd\COpenblock.h" />
    <ClInclude Include="CNdiskd\CProtocols.h" />
    <ClInclude Include="CNdiskd\CReport.h" />
    <ClInclude Include="CNdiskd\utils.h" />
    <ClInclude Include="Credentials.h" />
    <ClInclude Include="DbgHelpEx.h" />
    <ClInclude Include="Drivers.h" />
    <ClInclude Include="EngExpCppEx.h" />
    <ClInclude Include="engextcpp.hpp" />
    <ClInclude Include="Lxss.h" />
    <ClInclude Include="Md5.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="SwishDbgExt.h" />
    <ClInclude Include="Network.h" />
    <ClInclude Include="NtDef.h" />
    <ClInclude Include="Objects.h" />
    <ClInclude Include="Output.h" />
    <ClInclude Include="Process.h" />
    <ClInclude Include="Registry.h" />
    <ClInclude Include="Security.h" />
    <ClInclude Include="Storage.h" />
    <ClInclude Include="System.h" />
    <ClInclude Include="targetver.h" />
    <ClInclude Include="UntypedData.h" />
    <ClInclude Include="VirusTotal.h" />
    <ClInclude Include="Yara.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="packages.config" />
    <None Include="SwishDbgExt.def" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="SwishDbgExt.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="..\packages\yara-vs2015-binary-dependencies.0.0.1\build\native\yara-vs2015-binary-dependencies.targets" Condition="Exists('..\packages\yara-vs2015-binary-dependencies.0.0.1\build\native\yara-vs2015-binary-dependencies.targets')" />
    <Import Project="..\packages\libyara_vs2015.3.5.1\build\native\libyara_vs2015.targets" Condition="Exists('..\packages\libyara_vs2015.3.5.1\build\native\libyara_vs2015.targets')" />
  </ImportGroup>
  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>This project references NuGet package(s) that are missing on this computer. Use NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
    </PropertyGroup>
    <Error Condition="!Exists('..\packages\yara-vs2015-binary-dependencies.0.0.1\build\native\yara-vs2015-binary-dependencies.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\yara-vs2015-binary-dependencies.0.0.1\build\native\yara-vs2015-binary-dependencies.targets'))" />
    <Error Condition="!Exists('..\packages\libyara_vs2015.3.5.1\build\native\libyara_vs2015.targets')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\libyara_vs2015.3.5.1\build\native\libyara_vs2015.targets'))" />
  </Target>
</Project>
```

`SwishDbgExt/SwishDbgExt.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Azure.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DbgHelpEx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Drivers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="engextcpp.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="EngExtCppEx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Md5.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Network.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Output.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Objects.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Process.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Registry.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Security.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Storage.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SwishDbgExt.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="System.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="UntypedData.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="VirusTotal.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="CNdiskd\CAdapters.cpp">
      <Filter>Source Files\CNdiskd</Filter>
    </ClCompile>
    <ClCompile Include="CNdiskd\CMinidriver.cpp">
      <Filter>Source Files\CNdiskd</Filter>
    </ClCompile>
    <ClCompile Include="CNdiskd\CNdiskd.cpp">
      <Filter>Source Files\CNdiskd</Filter>
    </ClCompile>
    <ClCompile Include="CNdiskd\COpenblock.cpp">
      <Filter>Source Files\CNdiskd</Filter>
    </ClCompile>
    <ClCompile Include="CNdiskd\CProtocols.cpp">
      <Filter>Source Files\CNdiskd</Filter>
    </ClCompile>
    <ClCompile Include="Credentials.cpp">
      <Filter>Source Files\CNdiskd</Filter>
    </ClCompile>
    <ClCompile Include="CNdiskd\CReport.cpp">
      <Filter>Source Files\CNdiskd</Filter>
    </ClCompile>
    <ClCompile Include="CNdiskd\utils.cpp">
      <Filter>Source Files\CNdiskd</Filter>
    </ClCompile>
    <ClCompile Include="Checks\Codecave.cpp">
      <Filter>Source Files\Checks</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Lxss.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Yara.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Azure.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Credentials.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DbgHelpEx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Drivers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="EngExpCppEx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="engextcpp.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Md5.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Network.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="NtDef.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Objects.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Output.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Process.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Registry.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Security.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Storage.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="SwishDbgExt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="System.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="UntypedData.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="VirusTotal.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CNdiskd\CAdapters.h">
      <Filter>Header Files\CNdiskd</Filter>
    </ClInclude>
    <ClInclude Include="CNdiskd\CMinidriver.h">
      <Filter>Header Files\CNdiskd</Filter>
    </ClInclude>
    <ClInclude Include="CNdiskd\CNdiskd.h">
      <Filter>Header Files\CNdiskd</Filter>
    </ClInclude>
    <ClInclude Include="CNdiskd\COpenblock.h">
      <Filter>Header Files\CNdiskd</Filter>
    </ClInclude>
    <ClInclude Include="CNdiskd\CProtocols.h">
      <Filter>Header Files\CNdiskd</Filter>
    </ClInclude>
    <ClInclude Include="CNdiskd\CReport.h">
      <Filter>Header Files\CNdiskd</Filter>
    </ClInclude>
    <ClInclude Include="CNdiskd\utils.h">
      <Filter>Header Files\CNdiskd</Filter>
    </ClInclude>
    <ClInclude Include="Checks\Codecave.h">
      <Filter>Header Files\Checks</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Lxss.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Yara.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{0dd35a99-cf9a-4c06-80dc-f9137415e551}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{4bd195dd-04d9-4c34-a26f-c3b74cc24af8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{d9eb326a-f029-4c13-8fc8-d2ca4fa39c7d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\CNdiskd">
      <UniqueIdentifier>{df22e224-3691-48dc-b5a0-65f333c891b3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\CNdiskd">
      <UniqueIdentifier>{822445e7-508c-4279-bb47-5ee64b8e6109}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Checks">
      <UniqueIdentifier>{fbea9e81-02e3-4742-abae-834a8d90ed83}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Checks">
      <UniqueIdentifier>{9bf4bc88-0021-49ec-9470-f45c4cf74534}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <None Include="SwishDbgExt.def">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="packages.config" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="SwishDbgExt.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`SwishDbgExt/System.cpp`:

```cpp
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - System.cpp

Abstract:

    - 


Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#include "stdafx.h"
#include "SwishDbgExt.h"

//
// SSDT
// IDT
// GDT
// KTIMER
// Objects
// Drivers
// -> Callbacks
//

vector<SSDT_ENTRY>
GetServiceDescriptorTable(
)
/*++

Routine Description:

    Description.

Arguments:

    -

Return Value:

    vector<SSDT_ENTRY>.

--*/
{
    vector<SSDT_ENTRY> SDT;
    IMAGE_NT_HEADERS64 ImageNtHeaders;
    ULONG64 KiServiceTable;
    ULONG64 Address;
    ULONG64 ServiceAddress;
    ULONG64 KernelBase = NULL;
    ULONG64 KernelEnd = NULL;
    ULONG Limit;
    BOOLEAN Status = FALSE;

    ReadPointer(GetExpression("nt!KeServiceDescriptorTable"), &KiServiceTable);
    if (g_Ext->m_Data->ReadVirtual(GetExpression("nt!KiServiceLimit"), &Limit, sizeof(ULONG), NULL) != S_OK) goto Exit;

    if (!KiServiceTable) goto Exit;

    KernelBase = ExtNtOsInformation::GetNtDebuggerData(DEBUG_DATA_KernBase, "nt", 0);

    if (KernelBase) {

        g_Ext->m_Data4->ReadImageNtHeaders(KernelBase, &ImageNtHeaders);

        KernelEnd = KernelBase + ImageNtHeaders.OptionalHeader.SizeOfImage;
    }

    Address = KiServiceTable;

    if (g_Ext->m_ActualMachine == IMAGE_FILE_MACHINE_I386) {

        for (UINT i = 0; i < Limit; i++, Address += sizeof(ULONG)) {

            SSDT_ENTRY Entry = {0};

            ReadPointer(Address, &ServiceAddress);
            if (!ServiceAddress) break;

            Entry.Index = i;
            Entry.Address.Address = ServiceAddress;
            Entry.Address.HookType = GetPointerHookType(ServiceAddress);

            if ((KernelBase && KernelEnd) && !(ServiceAddress >= KernelBase && ServiceAddress < KernelEnd)) {

                Entry.Address.IsTablePatched = TRUE;
            }

            SDT.push_back(Entry);
        }
    }
    else {

        LONG Offset;

        for (UINT i = 0; i < Limit; i++, Address += sizeof(ULONG)) {

            SSDT_ENTRY Entry = {0};

            if (g_Ext->m_Data->ReadVirtual(Address, &Offset, sizeof(Offset), NULL) != S_OK) break;

            if (g_Ext->m_Minor < 6000) Offset &= ~0xF;
            else Offset >>= 4;

            ServiceAddress = KiServiceTable + Offset;

            Entry.Index = i;
            Entry.Address.Address = ServiceAddress;
            Entry.Address.HookType = GetPointerHookType(ServiceAddress);

            if ((KernelBase && KernelEnd) && !(ServiceAddress >= KernelBase && ServiceAddress < KernelEnd)) {

                Entry.Address.IsTablePatched = TRUE;
            }

            SDT.push_back(Entry);
        }
    }

    Status = TRUE;

Exit:
    return SDT;
}

PSTR
GetServiceStartType(
    _In_ ULONG StartType
    )
{
    switch (StartType) {

    case SERVICE_BOOT_START:        return "SERVICE_BOOT_START";
    case SERVICE_SYSTEM_START:      return "SERVICE_SYSTEM_START";
    case SERVICE_AUTO_START:        return "SERVICE_AUTO_START";
    case SERVICE_DEMAND_START:      return "SERVICE_DEMAND_START";
    case SERVICE_DISABLED:          return "SERVICE_DISABLED";
    default:                        return "UNKNOWN";
    }
}

PSTR
GetServiceState(
    _In_ ULONG State
    )
{
    switch (State) {

    case SERVICE_STOPPED:           return "SERVICE_STOPPED";
    case SERVICE_START_PENDING:     return "SERVICE_START_PENDING";
    case SERVICE_STOP_PENDING:      return "SERVICE_STOP_PENDING";
    case SERVICE_RUNNING:           return "SERVICE_RUNNING";
    case SERVICE_CONTINUE_PENDING:  return "SERVICE_CONTINUE_PENDING";
    case SERVICE_PAUSE_PENDING:     return "SERVICE_PAUSE_PENDING";
    case SERVICE_PAUSED:            return "SERVICE_PAUSED";
    default:                        return "UNKNOWN";
    }
}

vector<SERVICE_ENTRY>
GetServices(
    VOID
    )
/*++

Routine Description:

    Description.

Arguments:

    -

Return Value:

    vector<SERVICE_ENTRY>.

--*/
{
    MsProcessObject ProcessObject = FindProcessByName("services.exe");
    vector<SERVICE_ENTRY> Services;
    SERVICE_ENTRY ServiceEntry;
    ULONG64 RangeStart;
    ULONG64 RangeEnd;
    ULONG64 Offset;
    PULONG Buffer;
    ULONG BufferSize;
    ULONG Signature;
    ULONG SignatureOffset = 0;
    USHORT SystemVersion;

    if (!ProcessObject.m_CcProcessObject.ProcessObjectPtr) {

        return Services;
    }

    BufferSize = g_Ext->m_PageSize ? g_Ext->m_PageSize : PAGE_SIZE;

    Buffer = (PULONG)calloc(BufferSize * 2, sizeof(BYTE));

    if (Buffer) {

        SystemVersion = g_Ext->m_SystemVersion;

        if (SystemVersion == _WIN32_WINNT_VISTA || SystemVersion == _WIN32_WINNT_WIN7) {

            Signature = HANDLE_SIGNATURE;
        }
        else {

            Signature = SERVICE_SIGNATURE;
        }

        if (SystemVersion < _WIN32_WINNT_VISTA) {

            if (g_Ext->m_ActualMachine == IMAGE_FILE_MACHINE_I386) {

                SignatureOffset = 0x14;
            }
            else {

                SignatureOffset = 0x20;
            }
        }

        ProcessObject.SwitchContext();

        g_Ext->Execute(".process /p /r 0x%I64X", ProcessObject.m_CcProcessObject.ProcessObjectPtr);

        ProcessObject.MmGetVads();

        for each (VAD_OBJECT Vad in ProcessObject.m_Vads) {

            //
            // Check if VAD's range is valid.
            //

            if ((Vad.StartingVpn & ~0xFFFFFFFFFF) || (Vad.EndingVpn & ~0xFFFFFFFFFF)) {

                continue;
            }

            if (Vad.PrivateMemory) {

                RangeStart = Vad.StartingVpn * BufferSize;
                RangeEnd = Vad.EndingVpn * BufferSize;

                for (Offset = RangeStart; Offset < RangeEnd; Offset += BufferSize) {

                    RtlZeroMemory(Buffer, BufferSize);

                    if (ExtRemoteTypedEx::ReadVirtual(Offset, Buffer, BufferSize, NULL) != S_OK) {

                        continue;
                    }

                    for (UINT i = 0; i < (BufferSize / sizeof(ULONG)); i += 1) {

                        try {

                            if (Buffer[i] == Signature) {

                                ULONG64 Address;
                                ULONG64 ServiceRecordAddress;

                                Address = Offset + i * sizeof(ULONG);

                                if (Signature == HANDLE_SIGNATURE) {

                                    ExtRemoteUnTyped ServiceHandle(Address, "services!_SERVICE_HANDLE");

                                    ServiceRecordAddress = ServiceHandle.Field("ServiceRecord").GetPtr();
                                }
                                else {

                                    ServiceRecordAddress = Address - SignatureOffset;
                                }

                                ExtRemoteUnTyped ServiceRecord(ServiceRecordAddress, "services!_SERVICE_RECORD");

                                ULONG64 ServiceName = ServiceRecord.Field("ServiceName").GetPtr();
                                ULONG64 DisplayName = ServiceRecord.Field("DisplayName").GetPtr();

                                if (!IsValid(ServiceName) ||
                                    !IsValid(DisplayName)) {

                                    continue;
                                }

                                RtlZeroMemory(&ServiceEntry, sizeof(ServiceEntry));

                                ExtRemoteTypedEx::GetString(ServiceName, ServiceEntry.Name, sizeof(ServiceEntry.Name));
                                ExtRemoteTypedEx::GetString(DisplayName, ServiceEntry.Desc, sizeof(ServiceEntry.Desc));

                                ServiceEntry.UseCount = ServiceRecord.Field("UseCount").GetUlong();
                                ServiceEntry.StartType = ServiceRecord.Field("StartType").GetUlong();

                                ServiceEntry.ServiceStatus.dwServiceType = ServiceRecord.Field("ServiceStatus.dwServiceType").GetUlong();
                                ServiceEntry.ServiceStatus.dwCurrentState = ServiceRecord.Field("ServiceStatus.dwCurrentState").GetUlong();

                                if ((ServiceEntry.ServiceStatus.dwServiceType == SERVICE_WIN32_OWN_PROCESS) ||
                                    (ServiceEntry.ServiceStatus.dwServiceType == SERVICE_WIN32_SHARE_PROCESS)) {

                                    ULONG64 ImageRecordAddress = ServiceRecord.Field("ImageRecord").GetPtr();

                                    if (!ImageRecordAddress) {

                                        continue;
                                    }

                                    ExtRemoteUnTyped ImageRecord(ImageRecordAddress, "services!_IMAGE_RECORD");

                                    ServiceEntry.ProcessId = ImageRecord.Field("Pid").GetUlong();
                                    ServiceEntry.ServiceCount = ImageRecord.Field("ServiceCount").GetUlong();
                                    ServiceEntry.ProcessHandle = ImageRecord.Field("ProcessHandle").GetUlong();
                                    ServiceEntry.TokenHandle = ImageRecord.Field("TokenHandle").GetUlong();

                                    ULONG64 ImageName = ImageRecord.Field("ImageName").GetPtr();

                                    ExtRemoteTypedEx::GetString(ImageName, ServiceEntry.CommandLine, sizeof(ServiceEntry.CommandLine));

                                    ULONG64 AccountName = ImageRecord.Field("AccountName").GetPtr();

                                    if (AccountName) {

                                        ExtRemoteTypedEx::GetString(AccountName, ServiceEntry.AccountName, sizeof(ServiceEntry.AccountName));
                                    }
                                    else {

                                        StringCchCopyW(ServiceEntry.AccountName, _countof(ServiceEntry.AccountName), L"NT AUTHORITY\\System");
                                    }
                                }
                                else if (ServiceEntry.ServiceStatus.dwServiceType == SERVICE_KERNEL_DRIVER) {

                                    ULONG64 ObjectName = ServiceRecord.Field("ObjectName").GetPtr();

                                    ExtRemoteTypedEx::GetString(ObjectName, ServiceEntry.CommandLine, sizeof(ServiceEntry.CommandLine));
                                }

                                Services.push_back(ServiceEntry);
                            }
                        }
                        catch (...) {

                        }
                    }
                }
            }
        }

        ProcessObject.RestoreContext();

        free(Buffer);
    }

    return Services;
}

PSTR
GetPartitionType(
    _In_ ULONG Type
)
/*++

Routine Description:

    Description.

Arguments:

    Type -

Return Value:

    LPSTR.

--*/
{
    switch (Type)
    {
        case 0x00: return "Empty"; break;
        case 0x01: return "FAT12; break;CHS"; break;
        case 0x04: return "FAT16 16-32MB; break;CHS"; break;
        case 0x05: return "Microsoft Extended"; break;
        case 0x06: return "FAT16 32MB; break;CHS"; break;
        case 0x07: return "NTFS"; break;
        case 0x0b: return "FAT32; break;CHS"; break;
        case 0x0c: return "FAT32; break;LBA"; break;
        case 0x0e: return "FAT16; break; 32MB-2GB; break;LBA"; break;
        case 0x0f: return "Microsoft Extended; break; LBA"; break;
        case 0x11: return "Hidden FAT12; break;CHS"; break;
        case 0x14: return "Hidden FAT16; break;16-32MB; break;CHS"; break;
        case 0x16: return "Hidden FAT16; break;32MB-2GB; break;CHS"; break;
        case 0x18: return "AST SmartSleep Partition"; break;
        case 0x1b: return "Hidden FAT32; break;CHS"; break;
        case 0x1c: return "Hidden FAT32; break;LBA"; break;
        case 0x1e: return "Hidden FAT16; break;32MB-2GB; break;LBA"; break;
        case 0x27: return "PQservice"; break;
        case 0x39: return "Plan 9 partition"; break;
        case 0x3c: return "PartitionMagic recovery partition"; break;
        case 0x42: return "Microsoft MBR; break;Dynamic Disk"; break;
        case 0x44: return "GoBack partition"; break;
        case 0x51: return "Novell"; break;
        case 0x52: return "CP/M"; break;
        case 0x63: return "Unix System V"; break;
        case 0x64: return "PC-ARMOUR protected partition"; break;
        case 0x82: return "Solaris x86 or Linux Swap"; break;
        case 0x83: return "Linux"; break;
        case 0x84: return "Hibernation"; break;
        case 0x85: return "Linux Extended"; break;
        case 0x86: return "NTFS Volume Set"; break;
        case 0x87: return "NTFS Volume Set"; break;
        case 0x9f: return "BSD/OS"; break;
        case 0xa0: return "Hibernation"; break;
        case 0xa1: return "Hibernation"; break;
        case 0xa5: return "FreeBSD"; break;
        case 0xa6: return "OpenBSD"; break;
        case 0xa8: return "Mac OSX"; break;
        case 0xa9: return "NetBSD"; break;
        case 0xab: return "Mac OSX Boot"; break;
        case 0xaf: return "MacOS X HFS"; break;
        case 0xb7: return "BSDI"; break;
        case 0xb8: return "BSDI Swap"; break;
        case 0xbb: return "Boot Wizard hidden"; break;
        case 0xbe: return "Solaris 8 boot partition"; break;
        case 0xd8: return "CP/M-86"; break;
        case 0xde: return "Dell PowerEdge Server utilities (FAT fs)"; break;
        case 0xdf: return "DG/UX virtual disk manager partition"; break;
        case 0xeb: return "BeOS BFS"; break;
        case 0xee: return "EFI GPT Disk"; break;
        case 0xef: return "EFI System Parition"; break;
        case 0xfb: return "VMWare File System"; break;
        case 0xfc: return "VMWare Swap"; break;
    }

    return "Unknown";
}

ULONG64
KiDecodePointer(
    _In_ ULONG64 Pointer,
    _In_ ULONG64 Salt
)
/*++

Routine Description:

    Description.

Arguments:

    Pointer -
    Salt - 

Return Value:

    ULONG64.

--*/
{
    ULONG64 Value = (ULONG64)Pointer;

    // g_Ext->Dml("in => 0x%I64X\n", Pointer);

    if (g_Ext->IsCurMachine64())
    {
        ULONG64 Bias = (ULONG64)Salt;
        ULONG64 KiWaitNever = GetExpression("nt!KiWaitNever");
        ULONG64 KiWaitAlways = GetExpression("nt!KiWaitAlways");

        // g_Ext->Dml("KiWaitNever = %I64X | KiWaitAlways = %I64X\n", KiWaitNever, KiWaitAlways);

        ReadPointer(KiWaitNever, &KiWaitNever);
        ReadPointer(KiWaitAlways, &KiWaitAlways);

        Value = RotateLeft64(Value ^ KiWaitNever, (int)KiWaitNever);
        Value = _byteswap_uint64(Value ^ Bias) ^ KiWaitAlways;
    }

    return Value;
}

vector<KTIMER>
GetTimers(
)
/*++

Routine Description:

    Description.

Arguments:

    -

Return Value:

    vector<KTIMER>.

--*/
{
    vector<KTIMER> Timers;
    vector<ULONG64> Nodes;
    ULONG KeNumberProcessors;
    PULONG64 KiProcessorBlock;
    ULONG64 NodeOffset;

    ULONG64 KiTimerTableListHead = GetExpression("nt!KiTimerTableListHead");

    if (KiTimerTableListHead)
    {
        ExtRemoteTyped TimerTable;
        ExtRemoteUnTyped UntypedTimerTable;
        ULONG MaxEntries = 256; // default

        TimerTable = ExtRemoteTyped("(nt!_LIST_ENTRY *)@$extin", KiTimerTableListHead);

        // ULONG MaxEntries = GetTypeSize("nt!KiTimerTableListHead") / KTimerEntrySize;
        // g_Ext->Dml("MaxEntries = %d / TimerTableListSize = %x\n", MaxEntries, GetTypeSize("nt!KiTimerTableListHead"));

        if (g_Ext->m_Minor < 3790) MaxEntries = 256;// XP x86 and Win2003 SP0
        else if ((g_Ext->m_Minor >= 3790) && (g_Ext->m_Minor < 7600)) MaxEntries = 512; // XP x64, Vista
        else
        {
            g_Ext->Dml("Unsupported version for ktimers. (%d)\n", g_Ext->m_Minor);
        }

        for (UINT i = 0; i < MaxEntries; i += 1)
        {
            ULONG64 FirstEntry;

            FirstEntry = TimerTable.ArrayElement(i).Field("Flink").GetPointerTo().GetPtr();
            if (!FirstEntry) continue;

            if (!IsValid(FirstEntry)) continue;

            ExtRemoteTypedList TimerList(FirstEntry, "nt!_KTIMER", "TimerListEntry");

            for (TimerList.StartHead(); TimerList.HasNode(); TimerList.Next())
            {
                KTIMER Timer = {0};

                NodeOffset = TimerList.GetNodeOffset();

                if (!IsValid(NodeOffset)) {

                    break;
                }

                if (find(Nodes.rbegin(), Nodes.rend(), NodeOffset) != Nodes.rend()) {

                    break;
                }

                Nodes.push_back(NodeOffset);

                UCHAR Type = TimerList.GetTypedNode().Field("Header.Type").GetUchar();
                if ((Type != TimerNotificationObject) && (Type != TimerSynchronizationObject)) continue;
                Timer.Type = Type;

                Timer.Timer = NodeOffset;
                Timer.Dpc = TimerList.GetTypedNode().Field("Dpc").GetPtr();

                Timer.DueTime.HighPart = TimerList.GetTypedNode().Field("DueTime.HighPart").GetUlong();
                Timer.DueTime.LowPart = TimerList.GetTypedNode().Field("DueTime.LowPart").GetUlong();

                Timer.Period = TimerList.GetTypedNode().Field("Period").GetUlong();

                if (IsValid(Timer.Dpc))
                {
                    Timer.DeferredRoutine = TimerList.GetTypedNode().Field("Dpc").Field("DeferredRoutine").GetPtr();
                }

                Timers.push_back(Timer);
            }
        }
    }
    else
    {
        if (g_Ext->m_Data->ReadVirtual(KeNumberProcessorsAddress, &KeNumberProcessors, sizeof(KeNumberProcessors), NULL) != S_OK) goto CleanUp;

        KiProcessorBlock = (PULONG64)malloc(KeNumberProcessors * sizeof(ULONG64));
        if (!KiProcessorBlock) goto CleanUp;

        if (ReadPointersVirtual(KeNumberProcessors, KiProcessorBlockAddress, KiProcessorBlock) != S_OK) goto CleanUp;

        for (UINT i = 0; KiProcessorBlock[i] && (i < KeNumberProcessors); i += 1)
        {
            ULONG MaxEntries = 0;
            ExtRemoteTyped Pcr("(nt!_KPCR *)@$extin", KiProcessorBlock[i]);

            MaxEntries = Pcr.Field("Prcb.TimerTable.TimerEntries").GetTypeSize() / GetTypeSize("nt!_KTIMER_TABLE_ENTRY");
            // g_Ext->Dml("MaxEntries = %d\n", MaxEntries);

            for (UINT j = 0; j < MaxEntries; j += 1)
            {
                ULONG64 ListHead;

                if (Pcr.HasField("PrcbData"))
                {
                    ListHead = Pcr.Field("PrcbData.TimerTable.TimerEntries").ArrayElement(j).Field("Entry.Flink").GetPtr();
                }
                else
                {
                    ListHead = Pcr.Field("Prcb.TimerTable.TimerEntries").ArrayElement(j).Field("Entry.Flink").GetPtr();
                }
                // g_Ext->Dml("[%d][%d] ListHead =%I64X\n", i, j, ListHead);
                if (!ListHead) continue;
                if (!IsValid(ListHead)) continue;

                ExtRemoteTypedList TimerList(ListHead, "nt!_KTIMER", "TimerListEntry");

                for (TimerList.StartHead(); TimerList.HasNode(); TimerList.Next())
                {
                    KTIMER Timer = {0};

                    NodeOffset = TimerList.GetNodeOffset();

                    if (!IsValid(NodeOffset)) {

                        break;
                    }

                    if (find(Nodes.rbegin(), Nodes.rend(), NodeOffset) != Nodes.rend()) {

                        break;
                    }

                    Nodes.push_back(NodeOffset);

                    UCHAR Type = TimerList.GetTypedNode().Field("Header.Type").GetUchar();
                    if ((Type != TimerNotificationObject) && (Type != TimerSynchronizationObject)) continue;

                    Timer.Type = Type;

                    Timer.CoreId = i;
                    Timer.Timer = NodeOffset;
                    Timer.Dpc = TimerList.GetTypedNode().Field("Dpc").GetPtr();

                    Timer.Dpc = KiDecodePointer(Timer.Dpc, Timer.Timer);
                    // g_Ext->Dml("Timer.Timer = %I64X Timer.Dpc = %I64X\n", Timer.Timer, Timer.Dpc);

                    Timer.DueTime.HighPart = TimerList.GetTypedNode().Field("DueTime.HighPart").GetUlong();
                    Timer.DueTime.LowPart = TimerList.GetTypedNode().Field("DueTime.LowPart").GetUlong();

                    Timer.Period = TimerList.GetTypedNode().Field("Period").GetUlong();

                    if (IsValid(Timer.Dpc))
                    {
                        ExtRemoteTyped Dpc("(nt!_KDPC *)@$extin", Timer.Dpc);
                        ULONG DpcType = Dpc.Field("Type").GetUchar();

                        if ((DpcType == ApcObject) || (DpcType == DpcObject))
                        {
                            //Dpc.OutFullValue();
                            Timer.DpcType = DpcType;
                            Timer.DeferredRoutine = Dpc.Field("DeferredRoutine").GetPtr();
                        }
                    }

                    Timers.push_back(Timer);
                }

                //g_Ext->Dml("Done\n");
            }
            //g_Ext->Dml("Core done\n");
        }
    }

CleanUp:
    return Timers;
}

vector<VACB_OBJECT>
GetVacbs(
)
/*++

Routine Description:

    Description.

Arguments:

    -

Return Value:

    vector<VACB_OBJECT>.

--*/
{
    vector<VACB_OBJECT> Vacbs;

    ULONG64 VacbArrayBase = GetExpression("nt!CcVacbArrays");
    ULONG64 pData;
    ULONG CcVacbArraysHighestUsedIndex;
    PULONG64 VacbArray = NULL;

    vector<ULONG64> ReadedVacbs(1024);

    if (!VacbArrayBase) goto CleanUp;
    ReadPointer(VacbArrayBase, &VacbArrayBase);
    ReadPointer(GetExpression("nt!CcVacbArraysHighestUsedIndex"), &pData);

    CcVacbArraysHighestUsedIndex = (ULONG)pData;

    // g_Ext->Dml("CcVacbArraysHighestUsedIndex = %d\n", CcVacbArraysHighestUsedIndex);

    VacbArray = (PULONG64)malloc(CcVacbArraysHighestUsedIndex * sizeof(ULONG64));
    if (VacbArray == NULL) goto CleanUp;

    // g_Ext->Dml("VacbArrayBase = %I64X\n", VacbArrayBase);
    if (ReadPointersVirtual(CcVacbArraysHighestUsedIndex, VacbArrayBase, VacbArray) != S_OK) goto CleanUp;

    for (UINT VacbIndex = 0; VacbIndex < CcVacbArraysHighestUsedIndex; VacbIndex += 1)
    {
        ULONG VacbArrayHeaderSize = GetTypeSize("nt!_VACB_ARRAY_HEADER");

        // g_Ext->Dml("VacbArray[%d] = 0x%I64X\n", VacbIndex, VacbArray[VacbIndex]);
        ExtRemoteTyped Vacb("(nt!_VACB *)@$extin", VacbArray[VacbIndex] + VacbArrayHeaderSize);

        ULONG64 ListHead = Vacb.Field("Links.Flink").GetPointerTo().GetPtr();
        ExtRemoteTypedList VacbList(ListHead, "nt!_VACB", "Links.Flink");

        for (VacbList.StartHead(); VacbList.HasNode(); VacbList.Next())
        {
            for each (ULONG64 Ptr in ReadedVacbs)
            {
                if (Ptr == VacbList.GetNodeOffset()) goto CleanUp;
            }

            ReadedVacbs.push_back(VacbList.GetNodeOffset());

            ULONG64 BaseAddress = VacbList.GetTypedNode().Field("BaseAddress").GetPtr();
            ULONG64 SharedCacheMap = VacbList.GetTypedNode().Field("SharedCacheMap").GetPtr();

            if (BaseAddress || SharedCacheMap)
            {
                VACB_OBJECT VacbObject = { 0 };

                // VacbList.GetTypedNode().OutFullValue();
                VacbObject.Vacb = VacbList.GetNodeOffset();
                VacbObject.BaseAddress = BaseAddress;
                VacbObject.ValidBase = IsValid(BaseAddress);
                VacbObject.SharedCacheMap = SharedCacheMap;

                Vacbs.push_back(VacbObject);
            }
        }
    }

CleanUp:
    if (VacbArray) free(VacbArray);

    return Vacbs;
}

vector<IDT_ENTRY>
GetInterrupts(
    _In_opt_ ULONG64 InIdtBase
    )
/*++

Routine Description:

    Description.

Arguments:

    InIdtBase -

Return Value:

    vector<IDT_OBJECT>.

--*/
{
    vector<IDT_TABLE> IdtTables;
    vector<IDT_ENTRY> IdtEntries;
    vector<ULONG64> Nodes;
    PULONG64 KiProcessorBlock;
    ULONG64 Address;
    ULONG64 InterruptAddress;
    ULONG64 NodeOffset;
    ULONG ActualMachine;
    ULONG DispatchCodeOffset;
    ULONG CoreIndex = 0;
    PSTR IdtEntryString;
    BYTE KeNumberProcessors;

    ActualMachine = g_Ext->m_ActualMachine;

    if (!InIdtBase) {

        if (g_Ext->m_Data->ReadVirtual(KeNumberProcessorsAddress, &KeNumberProcessors, sizeof(KeNumberProcessors), NULL) == S_OK) {

            KiProcessorBlock = (PULONG64)calloc(KeNumberProcessors, sizeof(ULONG64));

            if (KiProcessorBlock) {

                if (ReadPointersVirtual(KeNumberProcessors, KiProcessorBlockAddress, KiProcessorBlock) == S_OK) {

                    ULONG64 IdtBase;
                    ULONG PrcbOffset;
                    ULONG IdtOffset;

                    if (GetFieldOffset("nt!_KPCR", "PrcbData", &PrcbOffset) != S_OK) {

                        GetFieldOffset("nt!_KPCR", "Prcb", &PrcbOffset);
                    }

                    if (GetFieldOffset("nt!_KPCR", "IDT", &IdtOffset) != S_OK) {

                        GetFieldOffset("nt!_KPCR", "IdtBase", &IdtOffset);
                    }

                    for (UINT i = 0; KiProcessorBlock[i] && (i < KeNumberProcessors); i++) {

                        ReadPointer(KiProcessorBlock[i] - PrcbOffset + IdtOffset, &IdtBase);

                        if (IdtBase) {

                            IDT_TABLE IdtTable;

                            IdtTable.IdtAddress = IdtBase;
                            IdtTable.PrcbAddress = KiProcessorBlock[i];

                            IdtTables.push_back(IdtTable);
                        }
                    }
                }

                free(KiProcessorBlock);
            }
        }
    }
    else {

        PROCESSORINFO ProcessorInfo;
        IDT_TABLE IdtTable = {0};
        ULONG64 PrcbAddress;

        GetKdContext(&ProcessorInfo);

        IdtTable.IdtAddress = InIdtBase;

        if (g_Ext->m_Data4->ReadProcessorSystemData(ProcessorInfo.Processor, DEBUG_DATA_KPRCB_OFFSET, &PrcbAddress, sizeof(PrcbAddress), NULL) == S_OK) {

            IdtTable.PrcbAddress = PrcbAddress;
        }

        IdtTables.push_back(IdtTable);
    }

    IdtEntryString = (ActualMachine == IMAGE_FILE_MACHINE_I386) ? "(nt!_KIDTENTRY *)@$extin" : "(nt!_KIDTENTRY64 *)@$extin";

    if (0 == GetFieldOffset("nt!_KINTERRUPT", "DispatchCode", &DispatchCodeOffset)) {

        for each (IDT_TABLE IdtTable in IdtTables) {

            IDT_ENTRY IdtEntry = {0};

            ExtRemoteTyped Idt(IdtEntryString, IdtTable.IdtAddress);

            for (ULONG i = 0; i < 256; i++) {

                try {

                    if (ActualMachine == IMAGE_FILE_MACHINE_I386) {

                        USHORT Access = Idt.ArrayElement(i).Field("Access").GetUshort();

                        IdtEntry.Dpl = (Access & IDT_ACCESS_DPL_MASK) >> 13;
                        IdtEntry.Type = (Access & IDT_ACCESS_TYPE_MASK) >> 8;
                        IdtEntry.Present = (Access & IDT_ACCESS_PRESENT_MASK) >> 15;

                        Address = (Idt.ArrayElement(i).Field("ExtendedOffset").GetUshort() << 16) |
                                  (Idt.ArrayElement(i).Field("Offset").GetUshort());
                    }
                    else {

                        IdtEntry.Dpl = Idt.ArrayElement(i).Field("Dpl").GetUshort();
                        IdtEntry.Type = Idt.ArrayElement(i).Field("Type").GetUshort();
                        IdtEntry.Present = Idt.ArrayElement(i).Field("Present").GetUshort();

                        Address = (((ULONG64)Idt.ArrayElement(i).Field("OffsetHigh").GetUlong() << 32) |
                                   ((ULONG64)Idt.ArrayElement(i).Field("OffsetMiddle").GetUshort() << 16) |
                                   ((ULONG64)Idt.ArrayElement(i).Field("OffsetLow").GetUshort()));
                    }

                    if (Address) {

                        InterruptAddress = Address - DispatchCodeOffset;

                        ExtRemoteTyped Interrupt("(nt!_KINTERRUPT *)@$extin", InterruptAddress);

                        if (IsValid(InterruptAddress) && (Interrupt.Field("Type").GetUshort() == INTERRUPT_OBJECT_TYPE)) {

                            IdtEntry.Address = Interrupt.Field("ServiceRoutine").GetPtr();
                            IdtEntry.Index = i;
                            IdtEntry.CoreIndex = CoreIndex;

                            IdtEntries.push_back(IdtEntry);

                            ExtRemoteTypedList InterruptList(Interrupt.Field("InterruptListEntry").GetPointerTo().GetPtr(), "nt!_KINTERRUPT", "InterruptListEntry");

                            for (InterruptList.StartHead(); InterruptList.HasNode(); InterruptList.Next()) {

                                NodeOffset = InterruptList.GetNodeOffset();

                                if (find(Nodes.rbegin(), Nodes.rend(), NodeOffset) != Nodes.rend()) {

                                    break;
                                }

                                Nodes.push_back(NodeOffset);

                                IdtEntry.Address = InterruptList.GetTypedNode().Field("ServiceRoutine").GetPtr();
                                IdtEntry.Index = i;
                                IdtEntry.CoreIndex = CoreIndex;

                                IdtEntries.push_back(IdtEntry);
                            }
                        }
                        else {

                            IdtEntry.Address = Address;
                            IdtEntry.Index = i;
                            IdtEntry.CoreIndex = CoreIndex;

                            IdtEntries.push_back(IdtEntry);
                        }
                    }
                }
                catch (...) {

                }
            }

            CoreIndex++;
        }
    }
    else {

        for each (IDT_TABLE IdtTable in IdtTables) {

            IDT_ENTRY IdtEntry = {0};

            ExtRemoteTyped Idt(IdtEntryString, IdtTable.IdtAddress);

            for (ULONG i = 0; i < 256; i++) {

                try {

                    ExtRemoteTyped InterruptObject;

                    ExtRemoteTyped Prcb("(nt!_KPRCB *)@$extin", IdtTable.PrcbAddress);

                    if (ActualMachine == IMAGE_FILE_MACHINE_I386) {

                        InterruptObject = Prcb.Field("VectorToInterruptObject").GetPointerTo();

                        USHORT Access = Idt.ArrayElement(i).Field("Access").GetUshort();

                        IdtEntry.Dpl = (Access & IDT_ACCESS_DPL_MASK) >> 13;
                        IdtEntry.Type = (Access & IDT_ACCESS_TYPE_MASK) >> 8;
                        IdtEntry.Present = (Access & IDT_ACCESS_PRESENT_MASK) >> 15;

                        Address = (Idt.ArrayElement(i).Field("ExtendedOffset").GetUshort() << 16) |
                                  (Idt.ArrayElement(i).Field("Offset").GetUshort());
                    }
                    else {

                        InterruptObject = Prcb.Field("InterruptObject").GetPointerTo();

                        IdtEntry.Dpl = Idt.ArrayElement(i).Field("Dpl").GetUshort();
                        IdtEntry.Type = Idt.ArrayElement(i).Field("Type").GetUshort();
                        IdtEntry.Present = Idt.ArrayElement(i).Field("Present").GetUshort();

                        Address = (((ULONG64)Idt.ArrayElement(i).Field("OffsetHigh").GetUlong() << 32) |
                                   ((ULONG64)Idt.ArrayElement(i).Field("OffsetMiddle").GetUshort() << 16) |
                                   ((ULONG64)Idt.ArrayElement(i).Field("OffsetLow").GetUshort()));
                    }

                    if (Address) {

                        if (i >= 0x30) {

                            ULONG InterruptIndex = (ActualMachine == IMAGE_FILE_MACHINE_I386) ?  i - 0x30 : i;

                            InterruptAddress = InterruptObject.ArrayElement(InterruptIndex).GetPtr();
                        }
                        else {

                            InterruptAddress = NULL;
                        }

                        ExtRemoteTyped Interrupt("(nt!_KINTERRUPT *)@$extin", InterruptAddress);

                        if (IsValid(InterruptAddress) && (Interrupt.Field("Type").GetUshort() == INTERRUPT_OBJECT_TYPE)) {

                            IdtEntry.Address = Interrupt.Field("ServiceRoutine").GetPtr();
                            IdtEntry.Index = i;
                            IdtEntry.CoreIndex = CoreIndex;

                            IdtEntries.push_back(IdtEntry);

                            ExtRemoteTypedList InterruptList(Interrupt.Field("InterruptListEntry").GetPointerTo().GetPtr(), "nt!_KINTERRUPT", "InterruptListEntry");

                            for (InterruptList.StartHead(); InterruptList.HasNode(); InterruptList.Next()) {

                                NodeOffset = InterruptList.GetNodeOffset();

                                if (find(Nodes.rbegin(), Nodes.rend(), NodeOffset) != Nodes.rend()) {

                                    break;
                                }

                                Nodes.push_back(NodeOffset);

                                IdtEntry.Address = InterruptList.GetTypedNode().Field("ServiceRoutine").GetPtr();
                                IdtEntry.Index = i;
                                IdtEntry.CoreIndex = CoreIndex;

                                IdtEntries.push_back(IdtEntry);
                            }
                        }
                        else {

                            IdtEntry.Address = Address;
                            IdtEntry.Index = i;
                            IdtEntry.CoreIndex = CoreIndex;

                            IdtEntries.push_back(IdtEntry);
                        }
                    }
                }
                catch (...) {

                }
            }

            CoreIndex++;
        }
    }

    return IdtEntries;
}

vector<GDT_OBJECT>
GetDescriptors(
    _In_opt_ ULONG64 InGdtBase
)
/*++

Routine Description:

    Description.

Arguments:

    InGdtBase

Return Value:

    vector<GDT_OBJECT>.

--*/
{
    vector<GDT_OBJECT> Gdts;
    ULONG KeNumberProcessors;
    PULONG64 KiProcessorBlock;

    vector<ULONG64> GdtBases;

    if (!InGdtBase)
    {
        if (g_Ext->m_Data->ReadVirtual(KeNumberProcessorsAddress, &KeNumberProcessors, sizeof(KeNumberProcessors), NULL) != S_OK) goto CleanUp;

        KiProcessorBlock = (PULONG64)malloc(KeNumberProcessors * sizeof(ULONG64));
        if (!KiProcessorBlock) goto CleanUp;

        if (ReadPointersVirtual(KeNumberProcessors, KiProcessorBlockAddress, KiProcessorBlock) != S_OK) goto CleanUp;

        ULONG PrcbOffset;

        if (GetFieldOffset("nt!_KPCR", "PrcbData", &PrcbOffset) != S_OK) GetFieldOffset("nt!_KPCR", "Prcb", &PrcbOffset);

        for (UINT i = 0; KiProcessorBlock[i] && (i < KeNumberProcessors); i += 1)
        {
            ULONG64 GdtBase;
            ULONG GdtOffset;

            ExtRemoteTyped Pcr("(nt!_KPCR *)@$extin", KiProcessorBlock[i] - PrcbOffset);

            // if (Pcr.HasField("GdtBase")) GdtBase = Pcr.Field("GdtBase").GetPtr();
            // else if (Pcr.HasField("GDT")) GdtBase = Pcr.Field("GDT").GetPtr();

            if (GetFieldOffset("nt!_KPCR", "GdtBase", &GdtOffset) != S_OK) GetFieldOffset("nt!_KPCR", "GDT", &GdtOffset);

            ReadPointer(KiProcessorBlock[i] - PrcbOffset + GdtOffset, &GdtBase);

            if (!GdtBase) continue;

            GdtBases.push_back(GdtBase);
        }
    }
    else
    {
        GdtBases.push_back(InGdtBase);
    }

    UINT i = 0;
    for each (ULONG64 GdtBase in GdtBases)
    {
        if (g_Ext->m_ActualMachine == IMAGE_FILE_MACHINE_I386)
        {
            ExtRemoteTyped Gdt("(nt!_KGDTENTRY *)@$extin", GdtBase);
            ULONG64 Entry = 0;

            for (UINT j = 0; j < 256; j += 1)
            {
                GDT_OBJECT GdtEntry = { 0 };
                Entry = (Gdt.ArrayElement(j).Field("HighWord.Bytes.BaseHi").GetUchar() << 24) |
                                (Gdt.ArrayElement(j).Field("HighWord.Bytes.BaseMid").GetUchar() << 16) |
                                (Gdt.ArrayElement(j).Field("BaseLow").GetUshort());
                GdtEntry.Limit = (Gdt.ArrayElement(j).Field("HighWord.Bits.LimitHi").GetUlong() << 16) |
                                 (Gdt.ArrayElement(j).Field("LimitLow").GetUshort());

                GdtEntry.Dpl = Gdt.ArrayElement(j).Field("HighWord.Bits.Dpl").GetUlong();
                GdtEntry.Present = Gdt.ArrayElement(j).Field("HighWord.Bits.Pres").GetUlong();
                GdtEntry.Type = Gdt.ArrayElement(j).Field("HighWord.Bits.Type").GetUlong();

                if (GdtEntry.Type == CallGate32)
                {
                    CALL_GATE CallGate = { 0 };

                    ULONG64 Ptr = Gdt.ArrayElement(j).GetPointerTo().GetPtr();

                    if (g_Ext->m_Data->ReadVirtual(Ptr, &CallGate, sizeof(CallGate), NULL) == S_OK)
                    {
                        Entry = (CallGate.OffsetHigh << 16) | CallGate.OffsetLow;
                    }
                }

                GdtEntry.Base = Entry;

                GdtEntry.Index = j;
                GdtEntry.CoreIndex = i;

                Gdts.push_back(GdtEntry);
            }
        }
        else
        {
            for (UINT j = 0; j < 256; j += 1)
            {
                KGDTENTRY64 GdtEntry64 = { 0 };
                GDT_OBJECT GdtEntry = { 0 };

                if (g_Ext->m_Data->ReadVirtual(GdtBase + j * sizeof(KGDTENTRY64),
                    &GdtEntry64,
                    sizeof(GdtEntry64), NULL) != S_OK) goto CleanUp;

                ULONG64 Entry = GdtEntry64.BaseUpper;
                Entry <<= 32;
                Entry |= GdtEntry64.Bytes.BaseHigh << 24;
                Entry |= GdtEntry64.Bytes.BaseMiddle << 16;
                Entry |= GdtEntry64.BaseLow;


                if (GdtEntry.Type == CallGate32)
                {
                    CALL_GATE CallGate = { 0 };

                    ULONG64 Ptr = GdtBase + j * sizeof(KGDTENTRY64);

                    if (g_Ext->m_Data->ReadVirtual(Ptr, &CallGate, sizeof(CallGate), NULL) == S_OK)
                    {
                        Entry = (CallGate.OffsetHigh << 16) | CallGate.OffsetLow;
                    }
                }

                GdtEntry.Base = Entry;
                GdtEntry.Dpl = GdtEntry64.Bits.Dpl;
                GdtEntry.Present = GdtEntry64.Bits.Present;
                GdtEntry.Type = GdtEntry64.Bits.Type;
                GdtEntry.Limit = (GdtEntry64.Bits.LimitHigh << 16) | (GdtEntry64.LimitLow);

                GdtEntry.Index = j;
                GdtEntry.CoreIndex = i;

                Gdts.push_back(GdtEntry);
            }
        }
        i += 1;
    }

CleanUp:
    return Gdts;
}

LPSTR WorkQueueType[] = {
    "CriticalWorkQueue",
    "DelayedWorkQueue",
    "HyperCriticalWorkQueue",
    "NormalWorkQueue",
    "BackgroundWorkQueue",
    "RealTimeWorkQueue",
    "SuperCriticalWorkQueue",
    NULL
};

void
GetExQueue(
)
/*++

Routine Description:

    Description.

Arguments:

    -

Return Value:

    None.

--*/
{
    // KeNodeBlock[i < KeNumberNodes] ENODE/KNODE
    // ExWorkerQueue = &ExGetNodeByNumber(i)->ExWorkerQueues[EXQUEUEINDEX_MAX];

    // ULONG ExCriticalWorkerThreads;
    // ULONG ExDelayedWorkerThreads;

    ExtRemoteTyped Nodes;
    vector<ULONG64> ThreadListNodes;
    ULONG64 NodeOffset;

    if (g_Ext->m_Minor < 9200)
    {
        g_Ext->Execute("!exqueue");
        goto Exit;
    }

    USHORT KeNumberNodes = 0;
    ULONG64 KeNodeBlock;
    // ULONG MaxWorkQueue = 0;
    // GetFieldOffset("nt!_WORK_QUEUE_TYPE", "MaximumWorkQueue", &MaxWorkQueue);
    // g_Ext->Dml("MaxWorkQueue = %x\n", MaxWorkQueue);

    if (g_Ext->m_Data->ReadVirtual(GetExpression("nt!KeNumberNodes"), &KeNumberNodes, sizeof(KeNumberNodes), NULL) != S_OK) goto Exit;
    ReadPointer(GetExpression("nt!KeNodeBlock"), &KeNodeBlock);

    // g_Ext->Dml("KeNumberNodes = %x\nKeNodeBlock = %I64X\n", KeNumberNodes, KeNodeBlock);

    Nodes = ExtRemoteTyped("(nt!_ENODE *)@$extin", KeNodeBlock);

    for (ULONG i = 0; i < KeNumberNodes; i += 1)
    {
        ULONG64 ThreadPtr = Nodes.ArrayElement(i).Field("ExpWorkerThreadBalanceManagerPtr").GetPtr();
        g_Ext->Dml("ExpWorkerThreadBalanceManager = <link cmd=\"!thread 0x%I64X\">0x%I64X</link>\n\n",
            ThreadPtr, ThreadPtr);

        // g_Ext->Dml("Node = 0x%I64X\n", Nodes.GetPtr());
        // Nodes.ArrayElement(i).OutFullValue();

        for (ULONG j = 0; j < MaximumWorkQueue; j += 1)
        {
            ExtRemoteTyped WorkerQueue = Nodes.ArrayElement(i).Field("ExWorkerQueues").ArrayElement(j).Field("WorkerQueue");

            ULONG64 ThreadListHead = WorkerQueue.Field("ThreadListHead").GetPointerTo().GetPtr();

            ExtRemoteTypedList ThreadList(ThreadListHead, "nt!_ETHREAD", "Tcb.QueueListEntry");

            g_Ext->Dml("**** NUMA Node %d %-24s \n", i, WorkQueueType[j]);

            for (ThreadList.StartHead(); ThreadList.HasNode(); ThreadList.Next()) {

                NodeOffset = ThreadList.GetNodeOffset();

                if (find(ThreadListNodes.rbegin(), ThreadListNodes.rend(), NodeOffset) != ThreadListNodes.rend()) {

                    break;
                }

                ThreadListNodes.push_back(NodeOffset);

                g_Ext->Dml("THREAD <link cmd=\"!thread 0x%I64X\">0x%I64X</link> Cid %04X.%04X Teb: 0x%I64X Win32Thread: 0x%I64X \n",
                           NodeOffset, NodeOffset,
                           (USHORT)ThreadList.GetTypedNode().Field("Cid.UniqueProcess").GetPtr(),
                           (USHORT)ThreadList.GetTypedNode().Field("Cid.UniqueThread").GetPtr(),
                           ThreadList.GetTypedNode().Field("Tcb.Teb").GetPtr(),
                           ThreadList.GetTypedNode().Field("Tcb.Win32Thread").GetPtr());
            }

            g_Ext->Dml("\n");
        }
    }

Exit:
    return;
}
```

`SwishDbgExt/System.h`:

```h
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - System.h

Abstract:

    - 

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/


#ifndef __SYSTEM_H__
#define __SYSTEM_H__

typedef struct _SSDT_ENTRY {
    ULONG Index;
    MsPEImageFile::ADDRESS_INFO Address;
    BOOLEAN InlineHooking;
    BOOLEAN PatchedEntry;
} SSDT_ENTRY, *PSSDT_ENTRY;

#define SC_SIGNATURE_NT6           0x48726373 // "scrH" in ASCII.
#define HANDLE_SIGNATURE           0x48726573 // "serH" in ASCII.

#define SC_SIGNATURE_NT5           0x6E4F6373  // "scOn" in ASCII.
#define SERVICE_SIGNATURE          0x76724573  // "sErv" in ASCII.

#define INTERRUPT_OBJECT_TYPE      22

#define IDT_ACCESS_TYPE_MASK       0x0F00
#define IDT_ACCESS_DPL_MASK        0x6000
#define IDT_ACCESS_PRESENT_MASK    0x8000

typedef struct _SERVICE_ENTRY {
    WCHAR Name[MAX_PATH];
    WCHAR Desc[MAX_PATH];
    WCHAR CommandLine[MAX_PATH];
    WCHAR AccountName[MAX_PATH];

    ULONG64 TokenHandle;
    ULONG64 ProcessHandle;
    ULONG ProcessId;

    ULONG ServiceCount; // number of services running in the process
    ULONG UseCount; // how many handles open to service

    SERVICE_STATUS ServiceStatus;
    ULONG StartType;
} SERVICE_ENTRY, *PSERVICE_ENTRY;

typedef struct _PARTITION_ENTRY
{
    UCHAR BootableFlag;
    UCHAR StartingCHS[3];
    UCHAR PartitionType;
    UCHAR EndingCHS[3];
    ULONG StartingLBA;
    ULONG SizeInSectors;
} PARTITION_ENTRY, *PPARTITION_ENTRY;

typedef struct _PARTITION_TABLE
{
    UCHAR u00[0x1b8];
    UCHAR DiskSignature[4]; // Boot code
    USHORT u1bc;
    PARTITION_ENTRY Entry[4];
    ULONG Signature;
} PARTITION_TABLE, *PPARTITION_TABLE;

typedef struct _VACB_OBJECT
{
    ULONG64 Vacb;
    ULONG64 BaseAddress;
    BOOLEAN ValidBase;
    ULONG64 SharedCacheMap;
} VACB_OBJECT, *PVACB_OBJECT;

typedef struct _IDT_ENTRY {
    ULONG CoreIndex;
    ULONG Index;
    ULONG64 Address;

    USHORT Dpl;
    USHORT Present;
    USHORT Type;
} IDT_ENTRY, *PIDT_ENTRY;

typedef struct _IDT_TABLE {
    ULONG64 IdtAddress;
    ULONG64 PrcbAddress;
} IDT_TABLE, *PIDT_TABLE;

typedef struct _GDT_OBJECT
{
    ULONG CoreIndex;
    ULONG Index;

    ULONG Selector;
    ULONG64 Base;
    ULONG64 Limit;
    ULONG Present;
    ULONG Type;
    ULONG Dpl;
    ULONG64 Entry;
} GDT_OBJECT, *PGDT_OBJECT;

typedef enum _KOBJECTS
{
    EventNotificationObject = 0,
    EventSynchronizationObject = 1,
    MutantObject = 2,
    ProcessObject = 3,
    QueueObject = 4,
    SemaphoreObject = 5,
    ThreadObject = 6,
    GateObject = 7,
    TimerNotificationObject = 8,
    TimerSynchronizationObject = 9,
    Spare2Object = 10,
    Spare3Object = 11,
    Spare4Object = 12,
    Spare5Object = 13,
    Spare6Object = 14,
    Spare7Object = 15,
    Spare8Object = 16,
    Spare9Object = 17,
    ApcObject = 18,
    DpcObject = 19,
    DeviceQueueObject = 20,
    EventPairObject = 21,
    InterruptObject = 22,
    ProfileObject = 23,
    ThreadedDpcObject = 24,
    MaximumKernelObject = 25
} KOBJECTS;

typedef struct _KTIMER {
    ULONG CoreId;
    ULONG64 Timer;
    ULONG64 Dpc;
    ULONG Type;
    ULONG DpcType;
    LARGE_INTEGER DueTime;
    ULONG Period;
    ULONG64 DeferredRoutine;
} KTIMER, *PKTIMER;

typedef union _KGDTENTRY64
{
    struct
    {
        USHORT LimitLow;
        USHORT BaseLow;
        union
        {
            struct {
                USHORT BaseHigh;
            };
            struct
            {
                UCHAR BaseMiddle;
                UCHAR Flags1;
                UCHAR Flags2;
                UCHAR BaseHigh;
            } Bytes;
            struct
            {
                ULONG BaseMiddle : 8;
                ULONG Type : 5;
                ULONG Dpl : 2;
                ULONG Present : 1;
                ULONG LimitHigh : 4;
                ULONG System : 1;
                ULONG LongMode : 1;
                ULONG DefaultBig : 1;
                ULONG Granularity : 1;
                ULONG BaseHigh : 8;
            } Bits;
        };
        ULONG BaseUpper;
        ULONG MustBeZero;
    };
    UINT64 Alignment;
} KGDTENTRY64, *PKGDTENTRY64;

typedef struct _CALL_GATE
{
    USHORT OffsetLow;
    USHORT Selector;
    UCHAR NumberOfArguments : 5;
    UCHAR Reserved : 3;
    UCHAR Type : 5;
    UCHAR Dpl : 2;
    UCHAR Present : 1;
    USHORT OffsetHigh;
} CALL_GATE, *PCALL_GATE;

enum GDTSystemType32
{
    TaskStateSegment16Available = 1,
    LocalDescriptorTable32 = 2,
    TaskStateSegment16Busy = 3,
    CallGate16 = 4,
    TaskGate = 5,
    InterruptGate16 = 6,
    TrapGate16 = 7,
    TaskStateSegment32Available = 9,
    TaskStateSegment32Busy = 11,
    CallGate32 = 12,
    InterruptGate32 = 14,
    TrapGate32 = 15,
    Invalid32 = 255
};

enum GDTSystemType64
{
    UpperHalf16 = 0,
    LocalDescriptorTable64 = 2,
    TaskStateSegment64Available = 9,
    TaskStateSegment64Busy = 11,
    CallGate64 = 12,
    InterruptGate64 = 14,
    TrapGate64 = 15,
    Invalid64 = 255
};

enum GDTType
{
    System = 0,
    Data = 1,
    Code = 2
};


typedef enum _WORK_QUEUE_TYPE {
    CriticalWorkQueue,
    DelayedWorkQueue,
    HyperCriticalWorkQueue,
    NormalWorkQueue,
    BackgroundWorkQueue,
    RealTimeWorkQueue,
    SuperCriticalWorkQueue,
    MaximumWorkQueue,
    CustomPriorityWorkQueue = 32
} WORK_QUEUE_TYPE;

vector<VACB_OBJECT>
GetVacbs(
    VOID
    );

vector<KTIMER>
GetTimers(
    VOID
    );

vector<SSDT_ENTRY>
GetServiceDescriptorTable(
    VOID
    );

PSTR
GetServiceStartType(
    _In_ ULONG StartType
    );

PSTR
GetServiceState(
    _In_ ULONG State
    );

vector<SERVICE_ENTRY>
GetServices(
    VOID
    );

PSTR
GetPartitionType(
    _In_ ULONG Type
    );

vector<IDT_ENTRY>
GetInterrupts(
    _In_opt_ ULONG64 InIdtBase
    );

vector<GDT_OBJECT>
GetDescriptors(
    _In_opt_ ULONG64 InGdtBase
    );

void
GetExQueue(
);
#endif
```

`SwishDbgExt/UntypedData.cpp`:

```cpp
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - UntypedData.h

Abstract:

- http://msdn.microsoft.com/en-us/windows/ff553536(v=vs.71).aspx
    - TODO: set symbols noisy

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#include "stdafx.h"
#include "SwishDbgExt.h"

#define InitField(a, b, c) {a, b, c}
#define InitPlatform(Platform, Minor, Major, d, Size, Type) {Platform, Minor, Major, d, Size, (ExtRemoteUnTyped::TYPED_DATA_FIELD *)Type}
#define InitType(TypeName, Type) {TypeName, (ExtRemoteUnTyped::TYPED_DATA_VERSION *)Type}

ExtRemoteUnTyped::TYPED_DATA_FIELD Lx_LX_AMD64_14393[] = {
    // Courtesy of the coolest kernel dev in the World (aionescu): https://github.com/ionescu007/lxss/tree/master/lx
    // LX_GLOBAL_DATA
    InitField("NTCSignature", 0x0, sizeof(USHORT)),
    InitField("HeaderSize", 0x2, sizeof(USHORT)),
    InitField("InstanceListOffset", 0x8, sizeof(ULONG64) * 2),
    InitField("InstanceListOffset.Flink", 0x8, sizeof(ULONG64)),
    InitField("InstanceListOffset.Blink", 0x10, sizeof(ULONG64)),

    // LX_INSTANCE
    InitField("I_HeaderSize", 0x0, sizeof(ULONG64)),
    InitField("I_ListOffset.Flink", 0x8, sizeof(ULONG64)),
    InitField("I_ListOffset.Blink", 0x10, sizeof(ULONG64)),
    InitField("I_RefCountOffset", 0x18, 0x10),
    InitField("I_GlobalDataOffset", 0x28, sizeof(ULONG64)),
    InitField("I_GuidOffset", 0x30, sizeof(GUID)),
    InitField("I_UnknownTimeOffset", 0x40, sizeof(ULONG64)),
    InitField("I_OtherTimeOffset", 0x48, sizeof(ULONG64)),
    InitField("I_StateOffset", 0x60, sizeof(ULONG64)),
    InitField("I_RootHandleOffset", 0x68, sizeof(ULONG64)),
    InitField("I_TempHandleOffset", 0x70, sizeof(ULONG64)),
    InitField("I_JobHandleOffset", 0x78, sizeof(ULONG64)),
    InitField("I_FlagsOffset", 0x80, 0x4),
    InitField("I_TokenHandleOffset", 0x88, sizeof(ULONG64)),
    InitField("I_EventHandleOffset", 0x98, sizeof(ULONG64)),
    InitField("I_PathCountOffset", 0xa0, 0x4),
    InitField("I_PathsOffset", 0xa8, sizeof(ULONG64)),
    InitField("I_VfsContextOffset", 0xb0, sizeof(ULONG64)),
    InitField("I_MemoryFlagsOffset", 0xb8, sizeof(ULONG64)),
    InitField("I_LastPidOffset", 0xd8, sizeof(ULONG64)),
    InitField("I_SessionListOffset", 0xe0, sizeof(ULONG64) * 2),
    InitField("I_SessionListOffset.Flink", 0xe0, sizeof(ULONG64)),
    InitField("I_SessionListOffset.Blink", 0xe8, sizeof(ULONG64)),
    InitField("I_GroupCountOffset", 0xf0, sizeof(ULONG64)),

    // LX_SESSION
    InitField("S_HeaderSize", 0x0, 0x68),
    InitField("S_ListOffset", 0x68, sizeof(ULONG64) * 2),
    InitField("S_ListOffset.Flink", 0x68, sizeof(ULONG64)),
    InitField("S_ListOffset.Blink", 0x70, sizeof(ULONG64)),
    InitField("S_InstanceOffset", 0x78, sizeof(ULONG64)),
    InitField("S_ConInodeOffset", 0x80, sizeof(ULONG64)),
    InitField("S_FgPidOffset", 0x88, sizeof(ULONG64)),
    InitField("S_GroupListOffset", 0x90, sizeof(ULONG64) * 2),
    InitField("S_GroupListOffset.Flink", 0x90, sizeof(ULONG64)),
    InitField("S_GroupListOffset.Blink", 0x98, sizeof(ULONG64)),

    // LX_PROCESSGROUP
    InitField("PG_HeaderSize", 0x0, 0x68),
    InitField("PG_ListOffset", 0x68, sizeof(ULONG64) * 2),
    InitField("PG_ListOffset.Flink", 0x68, sizeof(ULONG64)),
    InitField("PG_ListOffset.Blink", 0x70, sizeof(ULONG64)),
    InitField("PG_InstanceOffset", 0x78, sizeof(ULONG64)),
    InitField("PG_GroupListOffset", 0x80, sizeof(ULONG64) * 2),
    InitField("PG_GroupListOffset.Flink", 0x80, sizeof(ULONG64)),
    InitField("PG_GroupListOffset.Blink", 0x88, sizeof(ULONG64)),
    InitField("PG_SessionOffset", 0x90, sizeof(ULONG64)),

    // LX_THREADGROUP
    InitField("TG_HeaderSize", 0x0, 0x68),
    InitField("TG_ProcOffset", 0x68, sizeof(ULONG64)),
    InitField("TG_RusageOffset", 0x70, 0x90),
    InitField("TG_ListOffset.Flink", 0x100, sizeof(ULONG64)),
    InitField("TG_ListOffset.Blink", 0x108, sizeof(ULONG64)),
    InitField("TG_FlagsOffset", 0x110, 0x4),
    InitField("TG_ProcGroupOffset", 0x118, sizeof(ULONG64)),
    InitField("TG_ThreadListOffset.Flink", 0x138, sizeof(ULONG64)),
    InitField("TG_ThreadListOffset.Blink", 0x140, sizeof(ULONG64)),
    InitField("TG_ThreadCountOffset", 0x148, 0x4),
    InitField("TG_MainThreadOffset", 0x150, sizeof(ULONG64)),
    InitField("TG_FileOffset", 0x170, sizeof(ULONG64)),
    InitField("TG_PathOffset", 0x178, 0x10), // sizeof(nt!_UNICODE_STRING)
    InitField("TG_SigactionOffset", 0x1c8, 0x800),
    InitField("TG_SiginfoOffset", 0x9c8, 0xc00),
    InitField("TG_ArgumentsOffset", 0x15d0, sizeof(ULONG64)),
    InitField("TG_ArgsSizeOffset", 0x15d8, 0x4),

    // LX_PROCESS
    InitField("P_InstanceOffset", 0x0, sizeof(ULONG64)),
    InitField("P_ProcObjectOffset", 0x8, sizeof(ULONG64)),
    InitField("P_ProcHandleOffset", 0x10, sizeof(ULONG64)),
    InitField("P_VdsoOffset", 0x18, sizeof(ULONG64)),
    InitField("P_StackOffset", 0x20, sizeof(ULONG64)),


    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Nt_Smc_Cache_Ref_AMD64_7600[] = {
    // SMC_CACHE_REF
    InitField("Cache", 0x0, sizeof(ULONG64)), // Ptr SMC_CACHE
    InitField("RefCount", 0x8, sizeof(ULONG64)),
    InitField("AddRemoveLock", 0x10, sizeof(ULONG64)),
    InitField("SeqNumber", 0x18, sizeof(ULONG)),

    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Nt_Sm_AMD64_7600[] = {
    // SMC_CACHE
    InitField("CacheId", 0x0, sizeof(ULONG32)),
    InitField("DeviceSectorSize", 0x4, sizeof(ULONG32)),
    InitField("RegionCount", 0x8, sizeof(ULONG32)),
    // SMC_CACHE.PARAMETERS
    InitField("CacheParams.CacheFileSize", 0x10, sizeof(ULONG64)),
    // SMC_CACHE.FILE_INFO
    InitField("FileInfo.FileHandle", 0x28 + 0x0, sizeof(ULONG64)), // Ptr
    InitField("FileInfo.FileObject", 0x28 + 0x8, sizeof(ULONG64)), // Ptr32 _FILE_OBJECT
    InitField("FileInfo.VolumeFileObject", 0x28 + 0x10, sizeof(ULONG64)), // Ptr32 _FILE_OBJECT
    InitField("FileInfo.VolumeDeviceObject", 0x28 + 0x18, sizeof(ULONG64)), // Ptr32 _DEVICE_OBJECT
    InitField("FileInfo.VolumePnpHandle", 0x28 + 0x20, sizeof(ULONG64)), // Ptr32 
    InitField("FileInfo.UsageNotificationIrp", 0x28 + 0x28, sizeof(ULONG64)), // Ptr32 _IRP
    InitField("UniqueId", 0x1a8, sizeof(WCHAR)* 256),

    // SM_GLOBALS
    /*
    .text:000000014019DA0D                 lea     rcx, [rdi+880h]
    .text:000000014019DA26                 call    SmLogRetrieve
    */
    InitField("StoreMgr.Log", 0x880, 0x58),
    InitField("CacheMgr", 0x9a0, 0x118),

    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Nt_Smc_Cache_Ref_I386_7600[] = {
    // SMC_CACHE_REF
    InitField("Cache", 0x0, sizeof(ULONG32)),
    InitField("RefCount", 0x4, sizeof(ULONG32)),
    InitField("AddRemoveLock", 0x8, sizeof(ULONG32)),
    InitField("SeqNumber", 0xC, sizeof(ULONG)),
    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Nt_Sm_I386_7600[] = {
    // SMC_CACHE
    InitField("CacheId", 0x0, sizeof(ULONG32)),
    InitField("DeviceSectorSize", 0x4, sizeof(ULONG32)),
    InitField("RegionCount", 0x8, sizeof(ULONG32)),
    // SMC_CACHE.PARAMETERS
    InitField("CacheParams.CacheFileSize", 0x10, sizeof(ULONG64)),
    // SMC_CACHE.FILE_INFO
    InitField("FileInfo.FileHandle", 0x28 + 0x0, sizeof(ULONG32)), // Ptr
    InitField("FileInfo.FileObject", 0x28 + 0x4, sizeof(ULONG32)), // Ptr32 _FILE_OBJECT
    InitField("FileInfo.VolumeFileObject", 0x28 + 0x8, sizeof(ULONG32)), // Ptr32 _FILE_OBJECT
    InitField("FileInfo.VolumeDeviceObject", 0x28 + 0xc, sizeof(ULONG32)), // Ptr32 _DEVICE_OBJECT
    InitField("FileInfo.VolumePnpHandle", 0x28 + 0x10, sizeof(ULONG32)), // Ptr32 
    InitField("FileInfo.UsageNotificationIrp", 0x28 + 0x14, sizeof(ULONG32)), // Ptr32 _IRP
    InitField("UniqueId", 0x17c, sizeof(WCHAR) * 256),

    // SM_GLOBALS
    InitField("StoreMgr.Log", 0x510, 0x58), // _SM_LOG_CTX
    InitField("CacheMgr", 0x5b4, 0x118), // _SMC_CACHE_MANAGER

    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_VERSION Nt_Sm[] = {
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 7600, 15, 0, 0x1c, &Nt_Sm_AMD64_7600),
    InitPlatform(IMAGE_FILE_MACHINE_I386, 7600, 15, 0, 0x10, &Nt_Sm_I386_7600),
    InitPlatform(0, 0, 0, 0, 0, NULL)
};

ExtRemoteUnTyped::TYPED_DATA_VERSION Nt_LX[] = {
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 1433, 15, 0, 0x20, &Lx_LX_AMD64_14393),
    InitPlatform(0, 0, 0, 0, 0, NULL)
};

ExtRemoteUnTyped::TYPED_DATA_VERSION Nt_Smc_Cache_ref[] = {
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 7600, 15, 0, 0x1c, &Nt_Smc_Cache_Ref_AMD64_7600),
    InitPlatform(IMAGE_FILE_MACHINE_I386, 7600, 15, 0, 0x10, &Nt_Smc_Cache_Ref_I386_7600),
    InitPlatform(0, 0, 0, 0, 0, NULL)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD TcpIp_ParitionTable_AMD64_7600[] = {
    InitField("HashTables", 0x8, sizeof(ULONG64)),
    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD TcpIp_ParitionTable_I386_7600[] = {
    InitField("HashTables", 0x4, sizeof(ULONG32)),
    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_VERSION TcpIp_PartitionTable[] = {
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 7600, 15, 0, 0x78, &TcpIp_ParitionTable_AMD64_7600),
    InitPlatform(IMAGE_FILE_MACHINE_I386, 7600, 15, 0, 0x48, &TcpIp_ParitionTable_I386_7600),
    InitPlatform(0, 0, 0, 0, 0, NULL)
};

// We group all the structures in one variable.
ExtRemoteUnTyped::TYPED_DATA_FIELD TcpIp_Tcb_AMD64_7600[] = {
    // TCB
    InitField("Client", 0x010, sizeof(ULONG64)), // Ptr64 _TCP_CLIENT
    InitField("Path", 0x20, sizeof(ULONG64)),
    InitField("HashTableEntry", 0x28, 0x18), // RTL_DYNAMIC_HASH_TABLE_ENTRY
    InitField("State", 0x68, sizeof(ULONG)),
    InitField("LocalPort", 0x6c, sizeof(USHORT)),
    InitField("RemotePort", 0x6e, sizeof(USHORT)),
    InitField("OwningProcess", 0x238, sizeof(ULONG64)), // Ptr64 _EPROCESS

    // NL_PATH
    InitField("SourceAddress", 0x00, sizeof(ULONG64)), // Ptr64 _NL_LOCAL_ADDRESS
    InitField("DestinationAddress", 0x10, sizeof(ULONG64)), // Ptr64 UChar

    // _NL_LOCAL_ADDRESS
    InitField("Identifier", 0x10, sizeof(ULONG64)), // _NL_ADDRESS_IDENTIFIER
    
    // _NL_ADDRESS_IDENTIFIER
    InitField("Address", 0x00, sizeof(ULONG64)), // Ptr64 UChar

    //tcpip!_TCP_CLIENT
    InitField("Family", 0x014, sizeof(USHORT)),
    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD TcpIp_Tcb_I386_7600[] = {
    // TCB
    InitField("Client", 0x008, sizeof(ULONG64)), // Ptr64 _TCP_CLIENT
    InitField("Path", 0x010, sizeof(ULONG32)),
    InitField("HashTableEntry", 0x014, 0xc), // RTL_DYNAMIC_HASH_TABLE_ENTRY
    InitField("State", 0x034, sizeof(ULONG)),
    InitField("LocalPort", 0x038, sizeof(USHORT)),
    InitField("RemotePort", 0x03a, sizeof(USHORT)),
    InitField("OwningProcess", 0x174, sizeof(ULONG32)), // Ptr64 _EPROCESS

    // NL_PATH
    InitField("SourceAddress", 0x00, sizeof(ULONG32)), // Ptr64 _NL_LOCAL_ADDRESS
    InitField("DestinationAddress", 0x08, sizeof(ULONG32)), // Ptr64 UChar

    // _NL_LOCAL_ADDRESS
    InitField("Identifier", 0x00c, sizeof(ULONG32)), // _NL_ADDRESS_IDENTIFIER

    // _NL_ADDRESS_IDENTIFIER
    InitField("Address", 0x00, sizeof(ULONG32)), // Ptr64 UChar

    // _TCP_CLIENT
    InitField("Family", 0x00c, sizeof(USHORT)),

    InitField(NULL, 0, 0)
};


// We group all the structures in one variable.
ExtRemoteUnTyped::TYPED_DATA_FIELD TcpIp_Tcb_AMD64_6000[] = {
    // TCB
    InitField("Client", 0x010, sizeof(ULONG64)), // Ptr64 _TCP_CLIENT
    InitField("Path", 0x20, sizeof(ULONG64)),
    InitField("HashTableEntry", 0x28, 0x18), // RTL_DYNAMIC_HASH_TABLE_ENTRY
    InitField("State", 0x50, sizeof(ULONG)),
    InitField("LocalPort", 0x54, sizeof(USHORT)),
    InitField("RemotePort", 0x56, sizeof(USHORT)),
    InitField("OwningProcess", 0x208, sizeof(ULONG64)), // Ptr64 _EPROCESS

    // NL_PATH
    InitField("SourceAddress", 0x00, sizeof(ULONG64)), // Ptr64 _NL_LOCAL_ADDRESS
    InitField("DestinationAddress", 0x10, sizeof(ULONG64)), // Ptr64 UChar

    // _NL_LOCAL_ADDRESS
    InitField("Identifier", 0x10, sizeof(ULONG64)), // _NL_ADDRESS_IDENTIFIER

    // _NL_ADDRESS_IDENTIFIER
    InitField("Address", 0x00, sizeof(ULONG64)), // Ptr64 UChar

    //tcpip!_TCP_CLIENT
    InitField("Family", 0x014, sizeof(USHORT)),
    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD TcpIp_Tcb_I386_6000[] = {
    // TCB
    InitField("Client", 0x008, sizeof(ULONG64)), // Ptr64 _TCP_CLIENT
    InitField("Path", 0x010, sizeof(ULONG32)),
    InitField("HashTableEntry", 0x014, 0xc), // RTL_DYNAMIC_HASH_TABLE_ENTRY
    InitField("State", 0x028, sizeof(ULONG)),
    InitField("LocalPort", 0x02c, sizeof(USHORT)),
    InitField("RemotePort", 0x02e, sizeof(USHORT)),
    InitField("OwningProcess", 0x160, sizeof(ULONG32)), // Ptr64 _EPROCESS

    // NL_PATH
    InitField("SourceAddress", 0x00, sizeof(ULONG32)), // Ptr64 _NL_LOCAL_ADDRESS
    InitField("DestinationAddress", 0x08, sizeof(ULONG32)), // Ptr64 UChar

    // _NL_LOCAL_ADDRESS
    InitField("Identifier", 0x00c, sizeof(ULONG32)), // _NL_ADDRESS_IDENTIFIER

    // _NL_ADDRESS_IDENTIFIER
    InitField("Address", 0x00, sizeof(ULONG32)), // Ptr64 UChar

    //tcpip!_TCP_CLIENT
    InitField("Family", 0x00c, sizeof(USHORT)),

    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_VERSION TcpIp_Tcb[] = {
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 7600, 15, 0, 0x310, &TcpIp_Tcb_AMD64_7600),
    InitPlatform(IMAGE_FILE_MACHINE_I386, 7600, 15, 0, 0x208, &TcpIp_Tcb_I386_7600),
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 6000, 5, 0, 0x310, &TcpIp_Tcb_AMD64_6000),
    InitPlatform(IMAGE_FILE_MACHINE_I386, 6000, 5, 0, 0x208, &TcpIp_Tcb_I386_6000),
    InitPlatform(0, 0, 0, 0, 0, NULL)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Conhost_ConsoleInformation_AMD64_7600[] = {
    // _CONSOLE_INFORMATION
    InitField("ProcessList", 0x28, sizeof(ULONG64)), // _LIST_ENTRY
    InitField("CurrentScreenBuffer", 0xE0, sizeof(ULONG64)), // Ptr _SCREEN_INFORMATION
    InitField("ScreenBuffer", 0xE8, sizeof(ULONG64)), // Ptr _SCREEN_INFORMATION
    InitField("HistoryList", 0x148, sizeof(ULONG64)), // _LIST_ENTRY
    InitField("ExeAliasList", 0x158, sizeof(ULONG64)), // _LIST_ENTRY
    InitField("HistoryBufferCount", 0x168, sizeof(USHORT)),
    InitField("HistoryBufferMax", 0x16A, sizeof(USHORT)),
    InitField("CommandHistorySize", 0x16C, sizeof(USHORT)),
    InitField("OriginalTitle", 0x170, sizeof(ULONG64)), // Ptr String[256]
    InitField("Title", 0x178, sizeof(ULONG64)), // Ptr String[256]

    // _COMMAND_HISTORY
    InitField("ListEntry", 0x00, sizeof(ULONG64)), // _LIST_ENTRY
    InitField("Flags", 0x10, sizeof(ULONG)), // ('Allocated'=0, 'Reset' = 1)
    InitField("Application", 0x18, sizeof(ULONG64)), // Ptr String[256]
    InitField("CommandCount", 0x20, sizeof(USHORT)),
    InitField("LastAdded", 0x22, sizeof(USHORT)),
    InitField("LastDisplayed", 0x24, sizeof(USHORT)),
    InitField("FirstCommand", 0x26, sizeof(USHORT)),
    InitField("CommandCountMax", 0x28, sizeof(USHORT)),
    InitField("ProcessHandle", 0x30, sizeof(ULONG64)), // -HANDLE
    InitField("PopupList", 0x38, sizeof(ULONG64)), // _LIST_ENTRY
    InitField("CommandBucket", 0x48, sizeof(ULONG64)), // ptr _COMMAND[CommandCount]

    // _COMMAND
    InitField("CmdLength", 0x0, sizeof(USHORT)),
    InitField("Cmd", 0x2, sizeof(UCHAR)),

    // _SCREEN_INFORMATION
    InitField("ScreenX", 0x8, sizeof(USHORT)),
    InitField("ScreenY", 0xA, sizeof(USHORT)),
    InitField("Rows", 0x48, sizeof(ULONG64)), // Ptr _ROW
    InitField("Next", 0x128, sizeof(ULONG64)), // Ptr _SCREEN_INFORMATION

    // _ROW
    InitField("Chars", 0x8, sizeof(ULONG64)), // Ptr String[256]

    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Conhost_ConsoleInformation_I386_7600[] = {
    // _CONSOLE_INFORMATION
    InitField("ProcessList", 0x18, sizeof(ULONG32)), // _LIST_ENTRY
    InitField("CurrentScreenBuffer", 0x98, sizeof(ULONG32)), // Ptr _SCREEN_INFORMATION
    InitField("ScreenBuffer", 0x9c, sizeof(ULONG32)), // Ptr _SCREEN_INFORMATION
    InitField("HistoryList", 0xd4, sizeof(ULONG32)), // _LIST_ENTRY
    InitField("ExeAliasList", 0xdc, sizeof(ULONG32)), // _LIST_ENTRY
    InitField("HistoryBufferCount", 0xe4, sizeof(USHORT)),
    InitField("HistoryBufferMax", 0xe6, sizeof(USHORT)),
    InitField("CommandHistorySize", 0xe8, sizeof(USHORT)),
    InitField("OriginalTitle", 0xec, sizeof(ULONG32)), // Ptr String[256]
    InitField("Title", 0xf0, sizeof(ULONG32)), // Ptr String[256]

    // _COMMAND_HISTORY
    InitField("ListEntry", 0x00, sizeof(ULONG32)), // _LIST_ENTRY
    InitField("Flags", 0x8, sizeof(ULONG)), // ('Allocated'=0, 'Reset' = 1)
    InitField("Application", 0xc, sizeof(ULONG32)), // Ptr String[256]
    InitField("CommandCount", 0x10, sizeof(USHORT)),
    InitField("LastAdded", 0x12, sizeof(USHORT)),
    InitField("LastDisplayed", 0x14, sizeof(USHORT)),
    InitField("FirstCommand", 0x16, sizeof(USHORT)),
    InitField("CommandCountMax", 0x18, sizeof(USHORT)),
    InitField("ProcessHandle", 0x1c, sizeof(ULONG32)), // -HANDLE
    InitField("PopupList", 0x20, sizeof(ULONG32)), // _LIST_ENTRY
    InitField("CommandBucket", 0x28, sizeof(ULONG32)), // ptr _COMMAND[CommandCount]

    // _COMMAND
    InitField("CmdLength", 0x0, sizeof(USHORT)),
    InitField("Cmd", 0x2, sizeof(UCHAR)),

    // _SCREEN_INFORMATION
    InitField("ScreenX", 0x8, sizeof(USHORT)),
    InitField("ScreenY", 0xA, sizeof(USHORT)),
    InitField("Rows", 0x3c, sizeof(ULONG32)), // Ptr _ROW
    InitField("Next", 0xdc, sizeof(ULONG32)), // Ptr _SCREEN_INFORMATION

    // _ROW
    InitField("Chars", 0x8, sizeof(ULONG32)), // Ptr String[256]

    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Conhost_ConsoleInformation_I386_2600[] = {
    // _CONSOLE_INFORMATION
    InitField("ProcessList", 0x100, sizeof(ULONG32)), // _LIST_ENTRY
    InitField("CurrentScreenBuffer", 0xb0, sizeof(ULONG32)), // Ptr _SCREEN_INFORMATION
    InitField("ScreenBuffer", 0xb4, sizeof(ULONG32)), // Ptr _SCREEN_INFORMATION
    InitField("HistoryList", 0x108, sizeof(ULONG32)), // _LIST_ENTRY
    InitField("ExeAliasList", 0x110, sizeof(ULONG32)), // _LIST_ENTRY
    InitField("HistoryBufferCount", 0x118, sizeof(USHORT)),
    InitField("HistoryBufferMax", 0x11a, sizeof(USHORT)),
    InitField("CommandHistorySize", 0x11c, sizeof(USHORT)),
    InitField("OriginalTitle", 0x124, sizeof(ULONG32)), // Ptr String[256]
    InitField("Title", 0x128, sizeof(ULONG32)), // Ptr String[256]

    // _COMMAND_HISTORY
    InitField("ListEntry", 0x04, sizeof(ULONG32)), // _LIST_ENTRY
    InitField("Flags", 0x0, sizeof(ULONG)), // ('Allocated'=0, 'Reset' = 1)
    InitField("Application", 0xc, sizeof(ULONG32)), // Ptr String[256]
    InitField("CommandCount", 0x10, sizeof(USHORT)),
    InitField("LastAdded", 0x12, sizeof(USHORT)),
    InitField("LastDisplayed", 0x14, sizeof(USHORT)),
    InitField("FirstCommand", 0x16, sizeof(USHORT)),
    InitField("CommandCountMax", 0x18, sizeof(USHORT)),
    InitField("ProcessHandle", 0x1c, sizeof(ULONG32)), // -HANDLE
    InitField("PopupList", 0x20, sizeof(ULONG32)), // _LIST_ENTRY
    InitField("CommandBucket", 0x28, sizeof(ULONG32)), // ptr _COMMAND[CommandCount]

    // _COMMAND
    InitField("CmdLength", 0x0, sizeof(USHORT)),
    InitField("Cmd", 0x2, sizeof(UCHAR)),

    // _SCREEN_INFORMATION
    InitField("ScreenX", 0x24, sizeof(USHORT)),
    InitField("ScreenY", 0x26, sizeof(USHORT)),
    InitField("Rows", 0x58, sizeof(ULONG32)), // Ptr _ROW
    InitField("Next", 0xf8, sizeof(ULONG32)), // Ptr _SCREEN_INFORMATION

    // _ROW
    InitField("Chars", 0x8, sizeof(ULONG32)), // Ptr String[256]

    InitField(NULL, 0, 0)
};


ExtRemoteUnTyped::TYPED_DATA_FIELD Conhost_ConsoleInformation_AMD64_2600[] = {
    // _CONSOLE_INFORMATION
    InitField("CurrentScreenBuffer", 0xe8, sizeof(ULONG64)), // Ptr _SCREEN_INFORMATION
    InitField("ScreenBuffer", 0xf0, sizeof(ULONG64)), // Ptr _SCREEN_INFORMATION
    InitField("ProcessList", 0x178, sizeof(ULONG64)), // _LIST_ENTRY
    InitField("HistoryList", 0x188, sizeof(ULONG64)), // _LIST_ENTRY
    InitField("ExeAliasList", 0x198, sizeof(ULONG64)), // _LIST_ENTRY
    InitField("HistoryBufferCount", 0x1a8, sizeof(USHORT)),
    InitField("HistoryBufferMax", 0x1aa, sizeof(USHORT)),
    InitField("CommandHistorySize", 0x1ac, sizeof(USHORT)),
    InitField("OriginalTitle", 0x1b0, sizeof(ULONG64)), // Ptr String[256]
    InitField("Title", 0x1b8, sizeof(ULONG64)), // Ptr String[256]

    // _COMMAND_HISTORY
    InitField("Flags", 0x0, sizeof(ULONG)), // ('Allocated'=0, 'Reset' = 1)
    InitField("ListEntry", 0x08, sizeof(ULONG64)), // _LIST_ENTRY
    InitField("Application", 0x18, sizeof(ULONG64)), // Ptr String[256]
    InitField("CommandCount", 0x20, sizeof(USHORT)),
    InitField("LastAdded", 0x22, sizeof(USHORT)),
    InitField("LastDisplayed", 0x24, sizeof(USHORT)),
    InitField("FirstCommand", 0x26, sizeof(USHORT)),
    InitField("CommandCountMax", 0x28, sizeof(USHORT)),
    InitField("ProcessHandle", 0x30, sizeof(ULONG64)), // -HANDLE
    InitField("PopupList", 0x38, sizeof(ULONG64)), // _LIST_ENTRY
    InitField("CommandBucket", 0x48, sizeof(ULONG64)), // ptr _COMMAND[CommandCount]

    // _COMMAND
    InitField("CmdLength", 0x0, sizeof(USHORT)),
    InitField("Cmd", 0x2, sizeof(UCHAR)),

    // _SCREEN_INFORMATION
    InitField("ScreenX", 0x28, sizeof(USHORT)),
    InitField("ScreenY", 0x2A, sizeof(USHORT)),
    InitField("Rows", 0x68, sizeof(ULONG64)), // Ptr _ROW
    InitField("Next", 0x128, sizeof(ULONG64)), // Ptr _SCREEN_INFORMATION

    // _ROW
    InitField("Chars", 0x8, sizeof(ULONG64)), // Ptr String[256]

    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Nt_Misc_I386_2600[] = {
    // KTIMER_TABLE_ENTRY
    InitField("Entry.Flink", 0x0, sizeof(ULONG32)), // _LIST_ENTRY
    InitField("Entry.Blink", 0x4, sizeof(ULONG32)), // _LIST_ENTRY
    InitField("Time", 0x8, sizeof(ULONG64)), // _ULARGE_INTEGER
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Nt_Misc_AMD64_2600[] = {
    // KTIMER_TABLE_ENTRY
    InitField("Entry.Flink", 0x0, sizeof(ULONG64)), // _LIST_ENTRY
    InitField("Entry.Blink", 0x8, sizeof(ULONG64)), // _LIST_ENTRY
    InitField("Time", 0x8, sizeof(ULONG64)), // _ULARGE_INTEGER
};

//
// SERVICE_HANDLE
//

ExtRemoteUnTyped::TYPED_DATA_FIELD Service_Handle_I386_6000[] = {
    InitField("Signature", 0x0, sizeof(ULONG)),
    InitField("Flags", 0x4, sizeof(ULONG)),
    InitField("AccessGranted", 0x8, sizeof(ULONG)),
    InitField("ServiceRecord", 0xC, sizeof(ULONG)),
    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Service_Handle_AMD64_6000[] = {
    InitField("Signature", 0x0, sizeof(ULONG)),
    InitField("Flags", 0x4, sizeof(ULONG)),
    InitField("AccessGranted", 0x8, sizeof(ULONG)),
    InitField("ServiceRecord", 0x10, sizeof(ULONG64)),
    InitField(NULL, 0, 0)
};

//
// SERVICE_RECORD
//

ExtRemoteUnTyped::TYPED_DATA_FIELD Service_Record_I386_2600[] = {
    InitField("Previous", 0x0, sizeof(ULONG)),
    InitField("ServiceName", 0x4, sizeof(ULONG)),
    InitField("DisplayName", 0x8, sizeof(ULONG)),
    InitField("UseCount", 0x18, sizeof(ULONG)),
    InitField("ImageRecord", 0x20, sizeof(ULONG)),
    InitField("ObjectName", 0x20, sizeof(ULONG)),
    InitField("ServiceStatus.dwServiceType", 0x24, sizeof(ULONG)),
    InitField("ServiceStatus.dwCurrentState", 0x28, sizeof(ULONG)),
    InitField("StartType", 0x40, sizeof(ULONG)),
    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Service_Record_AMD64_2600[] = {
    InitField("Previous", 0x0, sizeof(ULONG64)),
    InitField("ServiceName", 0x8, sizeof(ULONG64)),
    InitField("DisplayName", 0x10, sizeof(ULONG64)),
    InitField("UseCount", 0x24, sizeof(ULONG)),
    InitField("ImageRecord", 0x30, sizeof(ULONG64)),
    InitField("ObjectName", 0x30, sizeof(ULONG64)),
    InitField("ServiceStatus.dwServiceType", 0x38, sizeof(ULONG)),
    InitField("ServiceStatus.dwCurrentState", 0x3C, sizeof(ULONG)),
    InitField("StartType", 0x54, sizeof(ULONG)),
    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Service_Record_I386_6000[] = {
    InitField("Previous", 0x0, sizeof(ULONG)),
    InitField("ServiceName", 0x4, sizeof(ULONG)),
    InitField("DisplayName", 0x8, sizeof(ULONG)),
    InitField("UseCount", 0x14, sizeof(ULONG)),
    InitField("ImageRecord", 0x1C, sizeof(ULONG)),
    InitField("ObjectName", 0x1C, sizeof(ULONG)),
    InitField("ServiceStatus.dwServiceType", 0x20, sizeof(ULONG)),
    InitField("ServiceStatus.dwCurrentState", 0x24, sizeof(ULONG)),
    InitField("StartType", 0x3C, sizeof(ULONG)),
    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Service_Record_AMD64_6000[] = {
    InitField("Previous", 0x0, sizeof(ULONG64)),
    InitField("ServiceName", 0x8, sizeof(ULONG64)),
    InitField("DisplayName", 0x10, sizeof(ULONG64)),
    InitField("UseCount", 0x20, sizeof(ULONG)),
    InitField("ImageRecord", 0x28, sizeof(ULONG64)),
    InitField("ObjectName", 0x28, sizeof(ULONG64)),
    InitField("ServiceStatus.dwServiceType", 0x30, sizeof(ULONG)),
    InitField("ServiceStatus.dwCurrentState", 0x34, sizeof(ULONG)),
    InitField("StartType", 0x4C, sizeof(ULONG)),
    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Service_Record_I386_9200[] = {
    InitField("Signature", 0x0, sizeof(ULONG)),
    InitField("Previous", 0x4, sizeof(ULONG)),
    InitField("ServiceName", 0x8, sizeof(ULONG)),
    InitField("DisplayName", 0xC, sizeof(ULONG)),
    InitField("UseCount", 0x18, sizeof(ULONG)),
    InitField("ImageRecord", 0x24, sizeof(ULONG)),
    InitField("ObjectName", 0x24, sizeof(ULONG)),
    InitField("ServiceStatus.dwServiceType", 0x28, sizeof(ULONG)),
    InitField("ServiceStatus.dwCurrentState", 0x2C, sizeof(ULONG)),
    InitField("StartType", 0x44, sizeof(ULONG)),
    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Service_Record_AMD64_9200[] = {
    InitField("Signature", 0x0, sizeof(ULONG)),
    InitField("Previous", 0x8, sizeof(ULONG64)),
    InitField("ServiceName", 0x10, sizeof(ULONG64)),
    InitField("DisplayName", 0x18, sizeof(ULONG64)),
    InitField("UseCount", 0x28, sizeof(ULONG)),
    InitField("ImageRecord", 0x38, sizeof(ULONG64)),
    InitField("ObjectName", 0x38, sizeof(ULONG64)),
    InitField("ServiceStatus.dwServiceType", 0x40, sizeof(ULONG)),
    InitField("ServiceStatus.dwCurrentState", 0x44, sizeof(ULONG)),
    InitField("StartType", 0x5C, sizeof(ULONG)),
    InitField(NULL, 0, 0)
};

//
// IMAGE_RECORD
//

ExtRemoteUnTyped::TYPED_DATA_FIELD Image_Record_I386_2600[] = {
    InitField("Prev", 0x0, sizeof(ULONG)),
    InitField("Next", 0x4, sizeof(ULONG)),
    InitField("ImageName", 0x8, sizeof(ULONG)),
    InitField("Pid", 0xC, sizeof(ULONG)),
    InitField("ServiceCount", 0x10, sizeof(ULONG)),
    InitField("ProcessHandle", 0x18, sizeof(ULONG)),
    InitField("TokenHandle", 0x20, sizeof(ULONG)),
    InitField("AccountName", 0x30, sizeof(ULONG)),
    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Image_Record_AMD64_2600[] = {
    InitField("Prev", 0x0, sizeof(ULONG64)),
    InitField("Next", 0x8, sizeof(ULONG64)),
    InitField("ImageName", 0x10, sizeof(ULONG64)),
    InitField("Pid", 0x18, sizeof(ULONG)),
    InitField("ServiceCount", 0x1C, sizeof(ULONG)),
    InitField("ProcessHandle", 0x20, sizeof(ULONG)),
    InitField("TokenHandle", 0x24, sizeof(ULONG)),
    InitField("AccountName", 0x50, sizeof(ULONG64)),
    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Image_Record_I386_6000[] = {
    InitField("Prev", 0x0, sizeof(ULONG)),
    InitField("Next", 0x4, sizeof(ULONG)),
    InitField("ImageName", 0x8, sizeof(ULONG)),
    InitField("Pid", 0xC, sizeof(ULONG)),
    InitField("ServiceCount", 0x10, sizeof(ULONG)),
    InitField("ProcessHandle", 0x18, sizeof(ULONG)),
    InitField("TokenHandle", 0x20, sizeof(ULONG)),
    InitField("AccountName", 0x30, sizeof(ULONG)),
    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Image_Record_AMD64_6000[] = {
    InitField("Prev", 0x0, sizeof(ULONG64)),
    InitField("Next", 0x8, sizeof(ULONG64)),
    InitField("ImageName", 0x10, sizeof(ULONG64)),
    InitField("Pid", 0x18, sizeof(ULONG)),
    InitField("ServiceCount", 0x1C, sizeof(ULONG)),
    InitField("ProcessHandle", 0x20, sizeof(ULONG)),
    InitField("TokenHandle", 0x28, sizeof(ULONG)),
    InitField("AccountName", 0x50, sizeof(ULONG64)),
    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Image_Record_I386_7600[] = {
    InitField("Prev", 0x0, sizeof(ULONG)),
    InitField("Next", 0x4, sizeof(ULONG)),
    InitField("ImageName", 0x8, sizeof(ULONG)),
    InitField("Pid", 0xC, sizeof(ULONG)),
    InitField("ServiceCount", 0x10, sizeof(ULONG)),
    InitField("ProcessHandle", 0x14, sizeof(ULONG)),
    InitField("TokenHandle", 0x1C, sizeof(ULONG)),
    InitField("AccountName", 0x2C, sizeof(ULONG)),
    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Image_Record_AMD64_7600[] = {
    InitField("Prev", 0x0, sizeof(ULONG64)),
    InitField("Next", 0x8, sizeof(ULONG64)),
    InitField("ImageName", 0x10, sizeof(ULONG64)),
    InitField("Pid", 0x18, sizeof(ULONG)),
    InitField("ServiceCount", 0x1C, sizeof(ULONG)),
    InitField("ProcessHandle", 0x20, sizeof(ULONG)),
    InitField("TokenHandle", 0x30, sizeof(ULONG)),
    InitField("AccountName", 0x48, sizeof(ULONG64)),
    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Image_Record_I386_9200[] = {
    InitField("Signature", 0x0, sizeof(ULONG)),
    InitField("ServiceName", 0x4, sizeof(ULONG)),
    InitField("DisplayName", 0x8, sizeof(ULONG)),
    InitField("ImageName", 0xC, sizeof(ULONG)),
    InitField("Pid", 0x10, sizeof(ULONG)),
    InitField("ServiceCount", 0x14, sizeof(ULONG)),
    InitField("ProcessHandle", 0x18, sizeof(ULONG)),
    InitField("TokenHandle", 0x20, sizeof(ULONG)),
    InitField("AccountName", 0x30, sizeof(ULONG)),
    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_FIELD Image_Record_AMD64_9200[] = {
    InitField("Signature", 0x0, sizeof(ULONG)),
    InitField("ServiceName", 0x8, sizeof(ULONG64)),
    InitField("DisplayName", 0x10, sizeof(ULONG64)),
    InitField("ImageName", 0x18, sizeof(ULONG64)),
    InitField("Pid", 0x20, sizeof(ULONG)),
    InitField("ServiceCount", 0x24, sizeof(ULONG)),
    InitField("ProcessHandle", 0x28, sizeof(ULONG)),
    InitField("TokenHandle", 0x38, sizeof(ULONG)),
    InitField("AccountName", 0x50, sizeof(ULONG64)),
    InitField(NULL, 0, 0)
};

ExtRemoteUnTyped::TYPED_DATA_VERSION Conhost_ConsoleInformation[] = {
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 7600, 15, 0, 0x400 /* Unknown */, &Conhost_ConsoleInformation_AMD64_7600),
    InitPlatform(IMAGE_FILE_MACHINE_I386, 7600, 15, 0, 0x400 /* Unknonw */, &Conhost_ConsoleInformation_I386_7600),
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 2600, 15, 0, 0x400 /* Unknown */, &Conhost_ConsoleInformation_AMD64_2600),
    InitPlatform(IMAGE_FILE_MACHINE_I386, 2600, 15, 0, 0x400 /* Unknonw */, &Conhost_ConsoleInformation_I386_2600),

    InitPlatform(0, 0, 0, 0, 0, NULL)
};

ExtRemoteUnTyped::TYPED_DATA_VERSION Nt_Misc[] = {
    InitPlatform(IMAGE_FILE_MACHINE_I386, 2600, 15, 0, 0x10, &Nt_Misc_I386_2600),
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 2600, 15, 0, 0x18, &Nt_Misc_AMD64_2600),

    InitPlatform(0, 0, 0, 0, 0, NULL)
};

ExtRemoteUnTyped::TYPED_DATA_VERSION Service_Handle[] = {
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 6000, 15, 0, 0x400, &Service_Handle_AMD64_6000),
    InitPlatform(IMAGE_FILE_MACHINE_I386,  6000, 15, 0, 0x400, &Service_Handle_I386_6000),
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 7600, 15, 0, 0x400, &Service_Handle_AMD64_6000),
    InitPlatform(IMAGE_FILE_MACHINE_I386,  7600, 15, 0, 0x400, &Service_Handle_I386_6000),
    InitPlatform(0, 0, 0, 0, 0, NULL)
};

ExtRemoteUnTyped::TYPED_DATA_VERSION Service_Record[] = {
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 14393, 15, 0, 0x400, &Service_Record_AMD64_9200),
    InitPlatform(IMAGE_FILE_MACHINE_I386,  14393, 15, 0, 0x400, &Service_Record_I386_9200),
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 10586, 15, 0, 0x400, &Service_Record_AMD64_9200),
    InitPlatform(IMAGE_FILE_MACHINE_I386,  10586, 15, 0, 0x400, &Service_Record_I386_9200),
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 10240, 15, 0, 0x400, &Service_Record_AMD64_9200),
    InitPlatform(IMAGE_FILE_MACHINE_I386,  10240, 15, 0, 0x400, &Service_Record_I386_9200),
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 9600, 15, 0, 0x400, &Service_Record_AMD64_9200),
    InitPlatform(IMAGE_FILE_MACHINE_I386,  9600, 15, 0, 0x400, &Service_Record_I386_9200),
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 9200, 15, 0, 0x400, &Service_Record_AMD64_9200),
    InitPlatform(IMAGE_FILE_MACHINE_I386,  9200, 15, 0, 0x400, &Service_Record_I386_9200),
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 7600, 15, 0, 0x400, &Service_Record_AMD64_6000),
    InitPlatform(IMAGE_FILE_MACHINE_I386,  7600, 15, 0, 0x400, &Service_Record_I386_6000),
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 6000, 15, 0, 0x400, &Service_Record_AMD64_6000),
    InitPlatform(IMAGE_FILE_MACHINE_I386,  6000, 15, 0, 0x400, &Service_Record_I386_6000),
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 3790, 15, 0, 0x400, &Service_Record_AMD64_2600),
    InitPlatform(IMAGE_FILE_MACHINE_I386,  3790, 15, 0, 0x400, &Service_Record_I386_2600),
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 2600, 15, 0, 0x400, &Service_Record_AMD64_2600),
    InitPlatform(IMAGE_FILE_MACHINE_I386,  2600, 15, 0, 0x400, &Service_Record_I386_2600),
    InitPlatform(0, 0, 0, 0, 0, NULL)
};

ExtRemoteUnTyped::TYPED_DATA_VERSION Image_Record[] = {
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 14393, 15, 0, 0x400, &Image_Record_AMD64_9200),
    InitPlatform(IMAGE_FILE_MACHINE_I386,  14393, 15, 0, 0x400, &Image_Record_I386_9200),
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 10586, 15, 0, 0x400, &Image_Record_AMD64_9200),
    InitPlatform(IMAGE_FILE_MACHINE_I386,  10586, 15, 0, 0x400, &Image_Record_I386_9200),
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 10240, 15, 0, 0x400, &Image_Record_AMD64_9200),
    InitPlatform(IMAGE_FILE_MACHINE_I386,  10240, 15, 0, 0x400, &Image_Record_I386_9200),
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 9600, 15, 0, 0x400, &Image_Record_AMD64_9200),
    InitPlatform(IMAGE_FILE_MACHINE_I386,  9600, 15, 0, 0x400, &Image_Record_I386_9200),
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 9200, 15, 0, 0x400, &Image_Record_AMD64_9200),
    InitPlatform(IMAGE_FILE_MACHINE_I386,  9200, 15, 0, 0x400, &Image_Record_I386_9200),
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 7600, 15, 0, 0x400, &Image_Record_AMD64_7600),
    InitPlatform(IMAGE_FILE_MACHINE_I386,  7600, 15, 0, 0x400, &Image_Record_I386_7600),
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 6000, 15, 0, 0x400, &Image_Record_AMD64_6000),
    InitPlatform(IMAGE_FILE_MACHINE_I386,  6000, 15, 0, 0x400, &Image_Record_I386_6000),
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 3790, 15, 0, 0x400, &Image_Record_AMD64_2600),
    InitPlatform(IMAGE_FILE_MACHINE_I386,  3790, 15, 0, 0x400, &Image_Record_I386_2600),
    InitPlatform(IMAGE_FILE_MACHINE_AMD64, 2600, 15, 0, 0x400, &Image_Record_AMD64_2600),
    InitPlatform(IMAGE_FILE_MACHINE_I386,  2600, 15, 0, 0x400, &Image_Record_I386_2600),
    InitPlatform(0, 0, 0, 0, 0, NULL)
};

ExtRemoteUnTyped::TYPED_DATA g_UntypedData[] = {
    InitType("tcpip!_PARTITION_TABLE", &TcpIp_PartitionTable),
    InitType("tcpip!_TCB", &TcpIp_Tcb),
    InitType("conhost!_CONSOLE_INFORMATION", &Conhost_ConsoleInformation),
    InitType("nt!_KTIMER_TABLE_ENTRY", &Nt_Misc),
    InitType("nt!_SMC_CACHE_REF", &Nt_Smc_Cache_ref),
    InitType("nt!_SMC_CACHE", &Nt_Sm),
    InitType("nt!_SM_GLOBALS", &Nt_Sm),
    InitType("lx!_LX_GLOBAL_DATA", &Nt_LX),
    InitType("lx!_LX_INSTANCE", &Nt_LX),
    InitType("lx!_LX_SESSION", &Nt_LX),
    InitType("lx!_LX_PROCESSGROUP", &Nt_LX),
    InitType("lx!_LX_THREADGROUP", &Nt_LX),
    InitType("lx!_LX_PROCESS", &Nt_LX),
    InitType("services!_SERVICE_HANDLE", &Service_Handle),
    InitType("services!_SERVICE_RECORD", &Service_Record),
    InitType("services!_IMAGE_RECORD", &Image_Record),
    InitType(NULL, NULL)
};

VOID
ExtRemoteUnTyped::Set(
    _In_ ULONG64 Ptr,
    _In_ PCSTR TypeName
)
/*++

Routine Description:

    Description.

Arguments:

    Ptr - 
    TypeName -

Return Value:

    VOID.

--*/
{
    m_UntypedDataPtr = Ptr;

    RtlZeroMemory(m_TypeName, sizeof(m_TypeName));
    RtlZeroMemory(m_Field, sizeof(m_Field));

    StringCchCopyA(m_TypeName, _countof(m_TypeName), TypeName);

    PTYPED_DATA_VERSION ReturnType = NULL;

    for (UINT i = 0; g_UntypedData[i].TypeName; i += 1)
    {
        if (_stricmp(g_UntypedData[i].TypeName, m_TypeName) == 0)
        {
            for (UINT j = 0; g_UntypedData[i].Type[j].MachineType; j += 1)
            {
                if ((g_UntypedData[i].Type[j].MachineType == g_Ext->m_ActualMachine) &&
                    (g_Ext->m_Minor >= g_UntypedData[i].Type[j].MinorVersion))
                {
                    if ((ReturnType && (ReturnType->MinorVersion < g_UntypedData[i].Type[j].MinorVersion)) || !ReturnType)
                    {
                        ReturnType = &g_UntypedData[i].Type[j];
                    }
                }
            }

            break;
        }
    }

    if (ReturnType)
    {
        m_TypedData = ReturnType;
        m_Initialized = TRUE;
    }
}

ULONG
GetUntypedTypeSize(
    _In_ PCSTR TypeName
)
/*++

Routine Description:

    Description.

Arguments:

    TypeName -

Return Value:

    ULONG.

--*/
{
    for (UINT i = 0; g_UntypedData[i].TypeName; i++) {

        if (0 == _stricmp(g_UntypedData[i].TypeName, TypeName)) {

            for (UINT j = 0; g_UntypedData[i].Type[j].MachineType; j++) {

                if ((g_UntypedData[i].Type[j].MachineType == g_Ext->m_ActualMachine) &&
                    (g_Ext->m_Minor >= g_UntypedData[i].Type[j].MinorVersion)) {

                    return g_UntypedData[i].Type[j].TypeSize;
                }
            }
        }
    }

    return 0;
}

ExtRemoteUnTyped::PTYPED_DATA_FIELD
ExtRemoteUnTyped::GetField(
    _In_ PCSTR Field
)
/*++

Routine Description:

    Description.

Arguments:

    Field -

Return Value:

    PTYPED_DATA_FIELD.

--*/
{
    PTYPED_DATA_FIELD ReturnResult = NULL;
    if (!m_Initialized) return FALSE;

    for (UINT i = 0; m_TypedData->Fields[i].FieldName; i += 1)
    {
        if (_stricmp(m_TypedData->Fields[i].FieldName, Field) == 0)
        {
            ReturnResult = &m_TypedData->Fields[i];
            goto CleanUp;
        }
    }

CleanUp:
    return ReturnResult;
}

ULONG
GetFieldOffset(
    _In_ PCSTR TypeName,
    _In_ PCSTR Field
)
/*++

Routine Description:

    Description.

Arguments:

    TypeName -
    Field -

Return Value:

    ULONG.

--*/
{
    ExtRemoteUnTyped Tmp(TypeName);

    return Tmp.GetFieldOffset(Field);
}

BOOLEAN
ExtRemoteUnTyped::HasField(
    _In_ PCSTR Field
)
/*++

Routine Description:

    Description.

Arguments:

    Field -

Return Value:

    BOOLEAN.

--*/
{
    if (!m_Initialized) return FALSE;

    BOOLEAN Result = FALSE;

    if (GetField(Field)) Result = TRUE;

    return Result;
}

ULONG
ExtRemoteUnTyped::GetFieldOffset(
    _In_ PCSTR Field
)
/*++

Routine Description:

    Description.

Arguments:

    Field -

Return Value:

    ULONG.

--*/
{
    ULONG Offset = 0;

    PTYPED_DATA_FIELD TypedField = GetField(Field);
    if (TypedField) Offset = TypedField->Offset;

    return Offset;
}

VOID
ExtRemoteUnTyped::SubtractOffset(
    _In_ PCSTR Field
)
/*++

Routine Description:

    Description.

Arguments:

    Field -

Return Value:

    VOID.

--*/
{
    ULONG Offset = GetFieldOffset(Field);
    m_UntypedDataPtr -= Offset;

    ExtRemoteData::Clear();
    ExtRemoteData::Set(m_UntypedDataPtr, m_TypedData->TypeSize);
}

ULONG64
ExtRemoteUnTyped::GetPointerTo(
    VOID
)
/*++

Routine Description:

    Description.

Arguments:

    -

Return Value:

    ULONG64.

--*/
{
    return m_UntypedDataPtr;
}

ExtRemoteUnTyped
ExtRemoteUnTyped::Field(
    _In_ PCSTR Field,
    _In_ BOOLEAN IsPtr
)
/*++

Routine Description:

    Description.

Arguments:

    Field -
    IsPtr - 

Return Value:

    ExtRemoteUntyped.

--*/
{
    PTYPED_DATA_FIELD TypedField = GetField(Field);

    ULONG64 Ptr = m_UntypedDataPtr + TypedField->Offset;

    if (IsPtr) ReadPointer(Ptr, &Ptr);

    return ExtRemoteUnTyped(Ptr,
                            m_TypeName,
                            m_Field, // Field
                            TypedField->Size);
}

ExtRemoteUnTyped
ExtRemoteUnTyped::Field(
    _In_ PCSTR Field
)
/*++

Routine Description:

    Description.

Arguments:

    Field - 

Return Value:

    ExtRemoteUnTyped.

--*/
{
    PTYPED_DATA_FIELD TypedField = GetField(Field);

    // g_Ext->Dml("m_TypeName = \"%s\", Offset = 0x%I64X m_Field = \"%s\" or \"%s\", Size = 0x%x\n",
    //    m_TypeName, m_UntypedDataPtr + TypedField->Offset, m_Field, Field, TypedField->Size);

    return ExtRemoteUnTyped(m_UntypedDataPtr + TypedField->Offset,
                            m_TypeName,
                            m_Field, // Field
                            TypedField->Size);
}

ExtRemoteUnTyped
ExtRemoteUnTyped::ArrayElement(
    _In_ LONG64 Index
)
/*++

Routine Description:

    Description.

Arguments:

    Index -

Return Value:

    ExtRemoteUnTyped.

--*/
{
    ULONG ArrayOffset;

    if (m_FieldSize) ArrayOffset = m_FieldSize * (ULONG)Index;
    else ArrayOffset = m_TypedData->TypeSize * (ULONG)Index;
    return ExtRemoteUnTyped(m_UntypedDataPtr + ArrayOffset, m_TypeName);
}

```

`SwishDbgExt/UntypedData.h`:

```h
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - UntypedData.cpp

Abstract:

    - http://msdn.microsoft.com/en-us/windows/ff553536(v=vs.71).aspx
    - TODO: set symbols noisy

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#ifndef __UNTYPED_DATA_H__
#define __UNTYPED_DATA_H__

class ExtRemoteUnTyped : public ExtRemoteData {
public:
    typedef struct _TYPED_DATA_FIELD {
        LPSTR FieldName;
        ULONG Offset;
        ULONG Size;
    } TYPED_DATA_FIELD, *PTYPED_DATA_FIELD;

    typedef struct _TYPED_DATA_VERSION {
        ULONG MachineType;
        ULONG MinorVersion;
        ULONG MajorVersion;
        ULONG ServicePack;

        ULONG TypeSize;
        PTYPED_DATA_FIELD Fields;
    } TYPED_DATA_VERSION, *PTYPED_DATA_VERSION;

    typedef struct _TYPED_DATA {
        LPSTR TypeName;
        PTYPED_DATA_VERSION Type;
    } TYPED_DATA, *PTYPED_DATA;

    ExtRemoteUnTyped(
    ) throw(...)
    {
    }

    ExtRemoteUnTyped(
        PCSTR TypeName
        )  throw(...)
    {
        Set(0, TypeName);
        // ExtRemoteData::Set(Ptr, m_TypedData->TypeSize);
    }

    ExtRemoteUnTyped(
        ULONG64 Ptr,
        PCSTR TypeName
    )  throw(...)
    {
        Set(Ptr, TypeName);
        ExtRemoteData::Set(Ptr, m_TypedData->TypeSize);
    }

    ExtRemoteUnTyped(
        ULONG64 Ptr,
        PCSTR TypeName,
        PCSTR Field,
        ULONG Size) throw(...)
    {
        Set(Ptr, TypeName); // We keep the same structure name. TODO: Links

        StringCchCopyA(m_Field, _countof(m_Field), Field);
        m_FieldSize = Size;
        ExtRemoteData::Set(Ptr, Size);
    }

    ExtRemoteUnTyped operator[](_In_ LONG Index) throw(...)
    {
        return ArrayElement(Index);
    }
    ExtRemoteUnTyped operator[](_In_ ULONG Index) throw(...)
    {
        return ArrayElement((LONG64)Index);
    }
    ExtRemoteUnTyped operator[](_In_ LONG64 Index) throw(...)
    {
        return ArrayElement(Index);
    }
    ExtRemoteUnTyped operator[](_In_ ULONG64 Index) throw(...)
    {
        if (Index > 0x7fffffffffffffffUI64)
        {
            g_Ext->ThrowRemote
                (HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW),
                "Array index too large");
        }
        return ArrayElement((LONG64)Index);
    }

    VOID Set(ULONG64 Ptr, PCSTR TypeName) throw(...);

    ULONG64 GetPointerTo(void) throw(...);
    PTYPED_DATA_FIELD GetField(_In_ PCSTR Field) throw(...);
    BOOLEAN HasField(_In_ PCSTR Field) throw(...);
    ULONG GetFieldOffset(_In_ PCSTR Field) throw(...);
    VOID SubtractOffset(_In_ PCSTR Field) throw(...);
    ExtRemoteUnTyped Field(_In_ PCSTR Field) throw(...);
    ExtRemoteUnTyped Field(_In_ PCSTR Field, BOOLEAN IsPtr) throw(...);

    ExtRemoteUnTyped ArrayElement(_In_ LONG64 Index) throw(...);

    BOOLEAN m_Initialized;
    ULONG64 m_UntypedDataPtr;
    PTYPED_DATA_VERSION m_TypedData;

    CHAR m_TypeName[MAX_PATH];
    CHAR m_Field[MAX_PATH];
    ULONG m_FieldSize;
};

ULONG
GetUntypedTypeSize(
_In_ PCSTR TypeName
);

ULONG
GetFieldOffset(
_In_ PCSTR TypeName,
_In_ PCSTR Field
);

#endif
```

`SwishDbgExt/Version.rc`:

```rc
#include "Version.txt"

VS_VERSION_INFO VERSIONINFO
 FILEVERSION BINVERSION
 PRODUCTVERSION BINVERSION
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x0L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "Comae Technologies FZE"
            VALUE "FileDescription", "Incident Response & Digital Forensics Debugging Extension"
            VALUE "FileVersion", STRVERSION
            VALUE "LegalCopyright", "Copyright © " YEAR " Comae Technologies FZE"
            VALUE "OriginalFilename", "SwishDbgExt.dll"
            VALUE "ProductName", "SwishDbgExt"
            VALUE "ProductVersion", STRVERSION
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

```

`SwishDbgExt/Version.txt`:

```txt
#define BINVERSION 3,0,0,0
#define STRVERSION "3.0"
#define YEAR "2017"

```

`SwishDbgExt/VirusTotal.cpp`:

```cpp
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - VirusTotal.cpp

Abstract:

    -

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

//
// TODO: ? :-)
//

#include "stdafx.h"
```

`SwishDbgExt/VirusTotal.h`:

```h
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2014 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Module Name:

    - VirusTotal.h

Abstract:

    - 

Environment:

    - User mode

Revision History:

    - Matthieu Suiche

--*/

#ifndef __VIRUSTOTAL_H__
#define __VIRUSTOTAL_H__

#include "SwishDbgExt.h"

#if JSON_SUPPORT
class VirusTotal {
public:
    static pplx::task<void> GetReport(PUCHAR Md5Section);

};
#endif

#endif
```

`SwishDbgExt/Yara.cpp`:

```cpp
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2016 Comae Technologies FZE
    Copyright (C) 2014-2016 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

--*/


#include "stdafx.h"
#include "SwishDbgExt.h"
#include <yara.h>


INT
YaraCallback(
    _In_ INT Message,
    _In_ PVOID MessageData,
    _In_ PVOID UserData
    )
{
    YR_RULE *Rule;
    YR_STRING *String;
    YR_MATCH *Match;
    ULONG64 BaseAddress;

    switch (Message) {

    case CALLBACK_MSG_RULE_MATCHING:
    {
        Rule = (YR_RULE *)MessageData;

        BaseAddress = *(PULONG64)UserData;

        g_Ext->Dml("<col fg=\"changed\">Rule:</col> %s\n\n", Rule->identifier);

        yr_rule_strings_foreach(Rule, String) {

            yr_string_matches_foreach(String, Match) {

                g_Ext->Execute("db %p", BaseAddress + Match->offset);
                g_Ext->Dml("\n");
            }
        }

        break;
    }
    }

    return CALLBACK_CONTINUE;
}

VOID
YaraScan(
    _In_ MsProcessObject *ProcObj,
    _In_ PCSTR FileName
    )
{
    YR_COMPILER *Compiler;
    YR_RULES *Rules;
    FILE *File;
    PBYTE Buffer = NULL;
    ULONG64 RangeStart;
    ULONG64 RangeEnd;
    ULONG64 Offset;

    if (yr_initialize() == ERROR_SUCCESS) {

        if (yr_compiler_create(&Compiler) == ERROR_SUCCESS) {

            if (fopen_s(&File, FileName, "r") == ERROR_SUCCESS) {

                if (yr_compiler_add_file(Compiler, File, NULL, NULL) == 0) {

                    if (yr_compiler_get_rules(Compiler, &Rules) == ERROR_SUCCESS) {

                        Buffer = (PBYTE)calloc(PAGE_SIZE, sizeof(BYTE));

                        if (Buffer) {

                            ProcObj->MmGetVads();

                            ProcObj->SwitchContext();

                            for each (VAD_OBJECT Vad in ProcObj->m_Vads) {

                                //
                                // Check if VAD's range is valid.
                                //

                                if ((Vad.StartingVpn & ~0xFFFFFFFFFF) || (Vad.EndingVpn & ~0xFFFFFFFFFF)) {

                                    continue;
                                }

                                RangeStart = Vad.StartingVpn * PAGE_SIZE;
                                RangeEnd = Vad.EndingVpn * PAGE_SIZE;

                                for (Offset = RangeStart; Offset < RangeEnd; Offset += PAGE_SIZE) {

                                    if (ExtRemoteTypedEx::ReadVirtual(Offset, Buffer, PAGE_SIZE, NULL) != S_OK) {

                                        continue;
                                    }

                                    yr_rules_scan_mem(Rules, Buffer, PAGE_SIZE, 0, YaraCallback, &Offset, 0);
                                }
                            }

                            ProcObj->RestoreContext();

                            free(Buffer);
                        }
                    }
                }

                fclose(File);
            }

            yr_compiler_destroy(Compiler);
        }

        yr_finalize();
    }
}

```

`SwishDbgExt/Yara.h`:

```h
/*++
    Incident Response & Digital Forensics Debugging Extension

    Copyright (C) 2014 MoonSols Ltd.
    Copyright (C) 2016 Comae Technologies FZE
    Copyright (C) 2014-2016 Matthieu Suiche (@msuiche)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

--*/

#ifndef __YARA_H__
#define __YARA_H__


VOID
YaraScan(
    _In_ MsProcessObject *ProcObj,
    _In_ PCSTR FileName
    );

#endif

```

`SwishDbgExt/engextcpp.cpp`:

```cpp
//----------------------------------------------------------------------------
//
// C++ dbgeng extension framework.
//
// Copyright (C) Microsoft Corporation, 2005-2009.
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "engextcpp.hpp"
#include <strsafe.h>
#include <dbghelp.h>

#if defined(_PREFAST_) || defined(_PREFIX_)
#define PRE_ASSUME(_Cond) _Analysis_assume_(_Cond)
#else
#define PRE_ASSUME(_Cond)
#endif

#define IsSpace(_Char) isspace((UCHAR)(_Char))

PEXT_DLL_MAIN g_ExtDllMain;

WINDBG_EXTENSION_APIS64 ExtensionApis;
ExtCheckedPointer<ExtExtension>
    g_Ext("g_Ext not set, used outside of a command");

//----------------------------------------------------------------------------
//
// ExtException family.
//
//----------------------------------------------------------------------------

void WINAPI
ExtException::PrintMessageVa(_In_reads_(BufferChars) PSTR Buffer,
                             _In_ ULONG BufferChars,
                             _In_ PCSTR Format,
                             _In_ va_list Args)
{
    StringCchVPrintfA(Buffer, BufferChars, Format, Args);
    m_Message = Buffer;
}

void WINAPIV
ExtException::PrintMessage(_In_reads_(BufferChars) PSTR Buffer,
                           _In_ ULONG BufferChars,
                           _In_ PCSTR Format,
                           ...)
{
    va_list Args;

    va_start(Args, Format);
    PrintMessageVa(Buffer, BufferChars, Format, Args);
    va_end(Args);
}

//----------------------------------------------------------------------------
//
// Holders.
//
//----------------------------------------------------------------------------

void WINAPI
ExtCurrentThreadHolder::Refresh(void)
{
    HRESULT Status;
    
    if ((Status = g_Ext->m_System->
         GetCurrentThreadId(&m_ThreadId)) != S_OK)
    {
        throw ExtStatusException(Status,
                                 "ExtCurrentThreadHolder::Refresh failed");
    }
}

void WINAPI
ExtCurrentThreadHolder::Restore(void)
{
    if (m_ThreadId != DEBUG_ANY_ID)
    {
        PRE_ASSUME(g_Ext.IsSet());
        if (g_Ext.IsSet())
        {
            // Ensure that g_Ext-> operator will not throw exception.
            g_Ext->m_System->SetCurrentThreadId(m_ThreadId);
        }
        m_ThreadId = DEBUG_ANY_ID;
    }
}

void WINAPI
ExtCurrentProcessHolder::Refresh(void)
{
    HRESULT Status;
    
    if ((Status = g_Ext->m_System->
         GetCurrentProcessId(&m_ProcessId)) != S_OK)
    {
        throw ExtStatusException(Status,
                                 "ExtCurrentProcessHolder::Refresh failed");
    }
}

void WINAPI
ExtCurrentProcessHolder::Restore(void)
{
    if (m_ProcessId != DEBUG_ANY_ID)
    {
        PRE_ASSUME(g_Ext.IsSet());
        if (g_Ext.IsSet())
        {
            // Ensure that g_Ext-> operator will not throw exception.
            g_Ext->m_System->SetCurrentProcessId(m_ProcessId);
        }
        m_ProcessId = DEBUG_ANY_ID;
    }
}

void WINAPI
ExtEffectiveProcessorTypeHolder::Refresh(void)
{
    HRESULT Status;
    
    if ((Status = g_Ext->m_Control->
         GetEffectiveProcessorType(&m_ProcType)) != S_OK)
    {
        throw ExtStatusException(Status,
                                 "ExtEffectiveProcessorTypeHolder::"
                                 "Refresh failed");
    }
}

void WINAPI
ExtEffectiveProcessorTypeHolder::Restore(void)
{
    if (m_ProcType != DEBUG_ANY_ID)
    {
        PRE_ASSUME(g_Ext.IsSet());
        if (g_Ext.IsSet())
        {
            // Ensure that g_Ext-> operator will not throw exception.
            g_Ext->SetEffectiveProcessor(m_ProcType);
        }
        m_ProcType = DEBUG_ANY_ID;
    }
}

void WINAPI
ExtRadixHolder::Refresh(void)
{
    HRESULT Status;
    
    if ((Status = g_Ext->m_Control->
         GetRadix(&m_Radix)) != S_OK)
    {
        throw ExtStatusException(Status,
                                 "ExtRadixHolder::Refresh failed");
    }
}

void WINAPI
ExtRadixHolder::Restore(void)
{
    if (m_Radix != DEBUG_ANY_ID)
    {
        PRE_ASSUME(g_Ext.IsSet());
        if (g_Ext.IsSet())
        {
            // Ensure that g_Ext-> operator will not throw exception.
            g_Ext->m_Control->SetRadix(m_Radix);
        }
        m_Radix = DEBUG_ANY_ID;
    }
}

//----------------------------------------------------------------------------
//
// ExtCommandDesc.
//
//----------------------------------------------------------------------------

ExtCommandDesc* ExtCommandDesc::s_Commands;
ULONG ExtCommandDesc::s_LongestCommandName;

WINAPI
ExtCommandDesc::ExtCommandDesc(_In_ PCSTR Name,
                               _In_ ExtCommandMethod Method,
                               _In_ PCSTR Desc,
                               _In_opt_ PCSTR Args)
{
    m_Name = Name;
    m_Method = Method;
    m_Desc = Desc;
    m_ArgDescStr = Args;

    ClearArgs();

    //
    // Add into command list sorted by name.
    //

    ExtCommandDesc* Cur, *Prev;

    Prev = NULL;
    for (Cur = s_Commands; Cur; Cur = Cur->m_Next)
    {
        if (strcmp(Name, Cur->m_Name) < 0)
        {
            break;
        }

        Prev = Cur;
    }

    if (Prev)
    {
        Prev->m_Next = this;
    }
    else
    {
        s_Commands = this;
    }
    m_Next = Cur;

    if (strlen(Name) > s_LongestCommandName)
    {
        s_LongestCommandName = (ULONG)strlen(Name);
    }
}

WINAPI
ExtCommandDesc::~ExtCommandDesc(void)
{
    DeleteArgs();
}

void WINAPI
ExtCommandDesc::ClearArgs(void)
{
    m_ArgsInitialized = false;
    m_CustomArgParsing = false;
    m_CustomArgDescLong = NULL;
    m_CustomArgDescShort = NULL;
    m_OptionChars = "/-";
    m_ArgStrings = NULL;
    m_NumArgs = 0;
    m_NumUnnamedArgs = 0;
    m_Args = NULL;
}

void WINAPI
ExtCommandDesc::DeleteArgs(void)
{
    free(m_ArgStrings);
    delete [] m_Args;
    ClearArgs();
}

PSTR WINAPI
ExtCommandDesc::ParseDirective(_In_ PSTR Scan)
{
    //
    // Scan to collect the directive name.
    //

    PSTR Name = Scan;
    while (*Scan != ':' && *Scan != '}')
    {
        if (!*Scan)
        {
            m_Ext->ThrowInvalidArg("ArgDesc: Improper directive "
                                   "name termination");
        }

        Scan++;
    }

    //
    // Scan to collect the directive value.
    //

    PSTR Value = "";
    
    if (*Scan == ':')
    {
        *Scan++ = 0;
        Value = Scan;

        while (*Scan != '}' ||
               *(Scan + 1) != '}')
        {
            if (!*Scan)
            {
                m_Ext->ThrowInvalidArg("ArgDesc: Improper directive "
                                       "value termination");
            }

            Scan++;
        }
    }
    else if (*(Scan + 1) != '}')
    {
        m_Ext->ThrowInvalidArg("ArgDesc: Improper directive }} closure");
    }
    
    // Terminate name or value.
    *Scan = 0;
    Scan += 2;

    //
    // Process directive.
    //

    bool NoValue = false;
    bool NeedValue = false;

    if (!strcmp(Name, "custom"))
    {
        m_CustomArgParsing = true;
        NoValue = true;
    }
    else if (!strcmp(Name, "l"))
    {
        m_CustomArgDescLong = Value;
        NeedValue = true;
    }
    else if (!strcmp(Name, "opt"))
    {
        m_OptionChars = Value;
    }
    else if (!strcmp(Name, "s"))
    {
        m_CustomArgDescShort = Value;
        NeedValue = true;
    }
    else
    {
        m_Ext->ThrowInvalidArg("ArgDesc: Unknown directive '%s'", Name);
    }

    if (!Value[0] && NeedValue)
    {
        m_Ext->ThrowInvalidArg("ArgDesc: {{%s}} requires an argument", Name);
    }
    if (Value[0] && NoValue)
    {
        m_Ext->ThrowInvalidArg("ArgDesc: {{%s}} does not have an argument",
                               Name);
    }
    
    return Scan;
}

void WINAPI
ExtCommandDesc::ParseArgDesc(void)
{
    //
    // Parse the argument description.
    //

    if (!m_ArgDescStr ||
        !m_ArgDescStr[0])
    {
        // No arguments.
        return;
    }
    
    // First copy the string so we can chop it up.
    m_ArgStrings = _strdup(m_ArgDescStr);
    if (! m_ArgStrings)
    {
        m_Ext->ThrowOutOfMemory();
    }

    // 
    // Each argument description is
    //   {<optname>;<type,flags>;<argname>;<descstr>}
    //

    ArgDesc Args[ExtExtension::s_MaxArgs];
    ArgDesc* Arg = Args - 1;
    ULONG NumUnOptArgs = 0;
    bool RemainderUsed = false;
    
    PSTR Scan = m_ArgStrings;
    
    while (*Scan)
    {
        if (*Scan != '{')
        {
            m_Ext->ThrowInvalidArg("ArgDesc: Missing { at '%s'", Scan);
        }
        Scan++;

        if (*Scan == '{')
        {
            // This is a {{directive}} and not an argument.
            Scan = ParseDirective(++Scan);
            continue;
        }
        
        if (m_NumArgs >= EXT_DIMA(Args))
        {
            m_Ext->ThrowInvalidArg("ArgDesc: Argument count "
                                   "overflow at '%s'", Scan);
        }
        m_NumArgs++;
        Arg++;
        
        //
        // Check for an argument name.
        // Arguments can be unnamed.
        //
        
        if (*Scan == '}' ||
            *Scan == ';')
        {
            Arg->Name = NULL;
            m_NumUnnamedArgs++;
            if (*Scan == ';')
            {
                Scan++;
            }
        }
        else
        {
            Arg->Name = Scan;
            while (*Scan != '}' &&
                   *Scan != ';')
            {
                if (!*Scan)
                {
                    m_Ext->ThrowInvalidArg("ArgDesc: Improper argument "
                                           "name termination for '%s'",
                                           Arg->Name);
                }
                
                Scan++;
            }
            if (*Scan != '}')
            {
                *Scan++ = 0;
            }

            if (Arg->Name[0] == '?' &&
                !Arg->Name[1])
            {
                m_Ext->ThrowInvalidArg("ArgDesc: /? is automatically "
                                       "provided by the framework");
            }
        }

        //
        // Check for a type.
        // Type defaults to string.
        //

        PCSTR TypeName = "ERROR";
        
        Arg->Boolean = false;
        Arg->Expression = false;
        Arg->String = false;
        Arg->StringRemainder = false;
        
        switch(*Scan)
        {
        case 'x':
            Arg->StringRemainder = true;
            __fallthrough;
        case 's':
            Scan++;
            __fallthrough;
        case '}':
        case ';':
        case ',':
            TypeName = "string";
            Arg->String = true;
            break;
        case 'b':
            Scan++;
            Arg->Boolean = true;
            break;
        case 'e':
            Scan++;
            TypeName = "expr";
            Arg->Expression = true;
            Arg->ExpressionBits = 64;
            Arg->ExpressionSigned = false;
            Arg->ExpressionDelimited = false;
            Arg->ExpressionEvaluator = NULL;
            Arg->ExpressionRadix = 0;
            for (;;)
            {
                if (*Scan == 'd')
                {
                    Arg->ExpressionDelimited = true;
                }
                else if (*Scan == 'n')
                {
                    if (Scan[1] != '=' ||
                        Scan[2] != '(')
                    {
                        m_Ext->ThrowInvalidArg("ArgDesc: "
                                               "Invalid input radix argument");
                    }
                    Scan += 3;
                    Arg->ExpressionRadix = strtoul(Scan, &Scan, 0);
                    if (Arg->ExpressionRadix < 1 ||
                        Arg->ExpressionRadix > 36)
                    {
                        m_Ext->ThrowInvalidArg("ArgDesc: "
                                               "Invalid input radix %u",
                                               Arg->ExpressionRadix);
                    }
                    if (*Scan != ')')
                    {
                        m_Ext->ThrowInvalidArg("ArgDesc: "
                                               "Invalid input radix argument");
                    }
                }
                else if (*Scan == 's')
                {
                    Arg->ExpressionSigned = true;
                }
                else if (*Scan == 'v')
                {
                    if (Scan[1] != '=' ||
                        Scan[2] != '(')
                    {
                        m_Ext->ThrowInvalidArg("ArgDesc: "
                                               "Invalid evaluator argument");
                    }
                    Scan += 3;
                    Arg->ExpressionEvaluator = Scan;
                    while (*Scan &&
                           *Scan != ')')
                    {
                        Scan++;
                    }
                    if (Scan == Arg->ExpressionEvaluator ||
                        !*Scan)
                    {
                        m_Ext->ThrowInvalidArg("ArgDesc: "
                                               "Invalid evaluator argument");
                    }
                    *Scan = 0;
                }
                else
                {
                    break;
                }

                Scan++;
            }
            if (*Scan >= '0' && *Scan <= '9')
            {
                Arg->ExpressionBits = strtoul(Scan, &Scan, 10);
                if (Arg->ExpressionBits < 1 ||
                    Arg->ExpressionBits > 64)
                {
                    m_Ext->ThrowInvalidArg("ArgDesc: "
                                           "Invalid expression bit count %u",
                                           Arg->ExpressionBits);
                }
            }
            break;
        default:
            m_Ext->ThrowInvalidArg("ArgDesc: Unknown argument type at '%s'",
                                   Scan);
            break;
        }

        //
        // Check for flags.
        //

        PSTR NeedTerm = NULL;
        
        Arg->Default = NULL;
        Arg->DefaultSilent = false;
        
        // Unnamed arguments default to
        // required as a required argument
        // tail is a very common pattern.
        Arg->Required = Arg->Name == NULL;

        while (*Scan == ',')
        {
            if (NeedTerm)
            {
                *NeedTerm = 0;
                NeedTerm = NULL;
            }
                
            Scan++;
            switch(*Scan)
            {
            case 'd':
                Scan++;
                switch(*Scan)
                {
                case '=':
                    if (Arg->Boolean)
                    {
                        m_Ext->ThrowInvalidArg("ArgDesc: boolean arguments "
                                               "cannot have defaults");
                    }

                    Arg->Default = ++Scan;
                    while (*Scan &&
                           *Scan != ',' &&
                           *Scan != ';' &&
                           *Scan != '}')
                    {
                        Scan++;
                    }
                    if (*Scan != '}')
                    {
                        NeedTerm = Scan;
                    }
                    break;
                case 's':
                    Scan++;
                    Arg->DefaultSilent = true;
                    break;
                default:
                    m_Ext->ThrowInvalidArg("ArgDesc: "
                                           "Unknown 'd' argument flag at '%s'",
                                           Scan);
                }
                break;
            case 'o':
                Scan++;
                Arg->Required = false;
                break;
            case 'r':
                Scan++;
                Arg->Required = true;
                break;
            default:
                m_Ext->ThrowInvalidArg("ArgDesc: "
                                       "Unknown argument flag at '%s'",
                                       Scan);
            }
        }
        if (*Scan == ';')
        {
            Scan++;
        }
        else if (*Scan != '}')
        {
            m_Ext->ThrowInvalidArg("ArgDesc: Improper argument "
                                   "type/flags termination at '%s'",
                                   Scan);
        }

        if (NeedTerm)
        {
            *NeedTerm = 0;
            NeedTerm = NULL;
        }
                
        if (!Arg->Name)
        {
            if (Arg->Boolean)
            {
                // Not possible to have an unnamed flag
                // since the presence/absence of the flag
                // is what a boolean is for.
                m_Ext->ThrowInvalidArg("ArgDesc: Boolean arguments "
                                       "must be named");
            }

            // Given the lack of placement identification (a name),
            // unnamed arguments are filled in the
            // order they appear in the argument string.
            // That means that a required argument cannot
            // follow an optional argument since there's
            // no way of knowing that the optional argument
            // should be skipped.
            if (!Arg->Required)
            {
                NumUnOptArgs++;
            }
            else
            {
                if (NumUnOptArgs > 0)
                {
                    m_Ext->ThrowInvalidArg("ArgDesc: "
                                           "Required unnamed arguments "
                                           "cannot follow optional "
                                           "unnamed arguments");
                }
            }
        
            if (RemainderUsed)
            {
                m_Ext->ThrowInvalidArg("ArgDesc: "
                                       "Unnamed arguments "
                                       "cannot follow remainder usage");
            }

            if (Arg->StringRemainder)
            {
                RemainderUsed = true;
            }
        }
        
        //
        // Check for a short descriptive argument name.
        //

        if (*Scan == '}' ||
            *Scan == ';')
        {
            // Use a default name so there's always
            // some short description.
            Arg->DescShort = TypeName;
            if (*Scan == ';')
            {
                Scan++;
            }
        }
        else
        {
            Arg->DescShort = Scan;
            while (*Scan != '}' &&
                   *Scan != ';')
            {
                if (!*Scan)
                {
                    m_Ext->ThrowInvalidArg("ArgDesc: "
                                           "Improper short description "
                                           "termination for '%s'",
                                           Arg->Name ?
                                           Arg->Name : "<unnamed>");
                }
                
                Scan++;
            }
            if (*Scan != '}')
            {
                *Scan++ = 0;
            }
        }

        //
        // Check for a long argument description.
        //
        
        if (*Scan == '}')
        {
            Arg->DescLong = NULL;
        }
        else
        {
            Arg->DescLong = Scan;
            while (*Scan != '}')
            {
                if (!*Scan)
                {
                    m_Ext->ThrowInvalidArg("ArgDesc: "
                                           "Improper long description "
                                           "termination for '%s'",
                                           Arg->Name ?
                                           Arg->Name : "<unnamed>");
                }
                
                Scan++;
            }
        }

        //
        // Finished.
        // Terminate whatever was the last string
        // in the description.
        //
        
        if (*Scan != '}')
        {
            m_Ext->ThrowInvalidArg("ArgDesc: Expecting } at '%s'", Scan);
        }

        *Scan++ = 0;
    }

    // Copy temporary array to permanent storage.
    if (m_NumArgs)
    {
        m_Args = new ArgDesc[m_NumArgs];
        if (! m_Args)
        {
            m_Ext->ThrowOutOfMemory();
        }
        memcpy(m_Args, Args, m_NumArgs * sizeof(m_Args[0]));
    }
    
    m_ArgsInitialized = true;
}

void WINAPI
ExtCommandDesc::ExInitialize(_In_ ExtExtension* Ext)
{
    m_Ext = Ext;

    if (!m_ArgsInitialized)
    {
        try
        {
            ParseArgDesc();
        }
        catch(...)
        {
            DeleteArgs();
            throw;
        }
    }
}

ExtCommandDesc::ArgDesc* WINAPI
ExtCommandDesc::FindArg(_In_ PCSTR Name)
{
    ArgDesc* Check = m_Args;
    for (ULONG i = 0; i < m_NumArgs; i++, Check++)
    {
        if (Check->Name &&
            !strcmp(Name, Check->Name))
        {
            return Check;
        }
    }
    return NULL;
}
    
ExtCommandDesc::ArgDesc* WINAPI
ExtCommandDesc::FindUnnamedArg(_In_ ULONG Index)
{
    ArgDesc* Check = m_Args;
    for (ULONG i = 0; i < m_NumArgs; i++, Check++)
    {
        if (!Check->Name &&
            Index-- == 0)
        {
            return Check;
        }
    }
    return NULL;
}

void WINAPI
ExtCommandDesc::Transfer(_Out_ ExtCommandDesc** Commands,
                         _Out_ PULONG LongestName)
{
    *Commands = s_Commands;
    s_Commands = NULL;
    *LongestName = ExtCommandDesc::s_LongestCommandName;
    s_LongestCommandName = 0;
}

//----------------------------------------------------------------------------
//
// ExtExtension.
//
//----------------------------------------------------------------------------

HMODULE ExtExtension::s_Module;
char ExtExtension::s_String[2000];
char ExtExtension::s_CircleStringBuffer[2000];
char* ExtExtension::s_CircleString = s_CircleStringBuffer;

WINAPI
ExtExtension::ExtExtension(void)
    : m_Advanced("The extension did not initialize properly."),
      m_Client("The extension did not initialize properly."),
      m_Control("The extension did not initialize properly."),
      m_Data("The extension did not initialize properly."),
      m_Registers("The extension did not initialize properly."),
      m_Symbols("The extension did not initialize properly."),
      m_System("The extension did not initialize properly."),
      m_Advanced2("The extension requires IDebugAdvanced2."),
      m_Advanced3("The extension requires IDebugAdvanced3."),
      m_Client2("The extension requires IDebugClient2."),
      m_Client3("The extension requires IDebugClient3."),
      m_Client4("The extension requires IDebugClient4."),
      m_Client5("The extension requires IDebugClient5."),
      m_Control2("The extension requires IDebugControl2."),
      m_Control3("The extension requires IDebugControl3."),
      m_Control4("The extension requires IDebugControl4."),
      m_Control5("The extension requires IDebugControl5."),
      m_Control6("The extension requires IDebugControl6."),
      m_Data2("The extension requires IDebugDataSpaces2."),
      m_Data3("The extension requires IDebugDataSpaces3."),
      m_Data4("The extension requires IDebugDataSpaces4."),
      m_Registers2("The extension requires IDebugRegisters2."),
      m_Symbols2("The extension requires IDebugSymbols2."),
      m_Symbols3("The extension requires IDebugSymbols3."),
      m_System2("The extension requires IDebugSystemObjects2."),
      m_System3("The extension requires IDebugSystemObjects3."),
      m_System4("The extension requires IDebugSystemObjects4.")
{
    m_ExtMajorVersion = 1;
    m_ExtMinorVersion = 0;
    m_ExtInitFlags = DEBUG_EXTINIT_HAS_COMMAND_HELP;

    m_KnownStructs = NULL;
    m_ProvidedValues = NULL;
    
    m_ExInitialized = false;
    m_OutMask = DEBUG_OUTPUT_NORMAL;
    m_CurChar = 0;
    m_LeftIndent = 0;
    m_AllowWrap = true;
    m_TestWrap = 0;

    m_CurCommand = NULL;
    
    m_AppendBuffer = NULL;
    m_AppendBufferChars = 0;
    m_AppendAt = NULL;

    m_DbgHelp = NULL;
    m_SymMatchStringA = NULL;
}

HRESULT WINAPI
ExtExtension::BaseInitialize(_In_ HMODULE ExtDllModule,
                             _Out_ PULONG Version,
                             _Out_ PULONG Flags)
{
    HRESULT Status;

    // Set up our global state.
    s_Module = ExtDllModule;
    g_ExtInstancePtr = this;
    g_Ext = this;
    
    // Pass registered commands to the extension
    // so that further references are confined to
    // extension class data.
    ExtCommandDesc::Transfer(&m_Commands,
                             &m_LongestCommandName);
    
    if ((Status = Initialize()) != S_OK)
    {
        return Status;
    }

    *Version = DEBUG_EXTENSION_VERSION(m_ExtMajorVersion,
                                       m_ExtMinorVersion);
    *Flags = m_ExtInitFlags;
    return S_OK;
}

HRESULT
ExtExtension::Initialize(void)
{
    return S_OK;
}

void
ExtExtension::Uninitialize(void)
{
    if (m_DbgHelp)
    {
        FreeLibrary(m_DbgHelp);
        m_DbgHelp = NULL;
        m_SymMatchStringA = NULL;
    }
}

void
ExtExtension::OnSessionActive(_In_ ULONG64 Argument)
{
    UNREFERENCED_PARAMETER(Argument);
    // Empty.
}

void
ExtExtension::OnSessionInactive(_In_ ULONG64 Argument)
{
    UNREFERENCED_PARAMETER(Argument);
    // Empty.
}

void
ExtExtension::OnSessionAccessible(_In_ ULONG64 Argument)
{
    UNREFERENCED_PARAMETER(Argument);
    // Empty.
}

void
ExtExtension::OnSessionInaccessible(_In_ ULONG64 Argument)
{
    UNREFERENCED_PARAMETER(Argument);
    // Empty.
}

void WINAPIV
ExtExtension::Out(_In_ PCSTR Format,
                  ...)
{
    va_list Args;

    va_start(Args, Format);
    m_Control->OutputVaList(m_OutMask, Format, Args);
    va_end(Args);
}

void WINAPIV
ExtExtension::Warn(_In_ PCSTR Format,
                   ...)
{
    va_list Args;

    va_start(Args, Format);
    m_Control->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

void WINAPIV
ExtExtension::Err(_In_ PCSTR Format,
                  ...)
{
    va_list Args;

    va_start(Args, Format);
    m_Control->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

void WINAPIV
ExtExtension::Verb(_In_ PCSTR Format,
                   ...)
{
    va_list Args;

    va_start(Args, Format);
    m_Control->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}

void WINAPIV
ExtExtension::Out(_In_ PCWSTR Format,
                  ...)
{
    va_list Args;

    va_start(Args, Format);
    m_Control4->OutputVaListWide(m_OutMask, Format, Args);
    va_end(Args);
}

void WINAPIV
ExtExtension::Warn(_In_ PCWSTR Format,
                   ...)
{
    va_list Args;

    va_start(Args, Format);
    m_Control4->OutputVaListWide(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

void WINAPIV
ExtExtension::Err(_In_ PCWSTR Format,
                  ...)
{
    va_list Args;

    va_start(Args, Format);
    m_Control4->OutputVaListWide(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

void WINAPIV
ExtExtension::Verb(_In_ PCWSTR Format,
                   ...)
{
    va_list Args;

    va_start(Args, Format);
    m_Control4->OutputVaListWide(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}

void WINAPIV
ExtExtension::Dml(_In_ PCSTR Format,
                  ...)
{
    va_list Args;

    va_start(Args, Format);
    m_Control->ControlledOutputVaList(DEBUG_OUTCTL_AMBIENT_DML,
                                      m_OutMask, Format, Args);
    va_end(Args);
}

void WINAPIV
ExtExtension::DmlWarn(_In_ PCSTR Format,
                      ...)
{
    va_list Args;

    va_start(Args, Format);
    m_Control->ControlledOutputVaList(DEBUG_OUTCTL_AMBIENT_DML,
                                      DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

void WINAPIV
ExtExtension::DmlErr(_In_ PCSTR Format,
                     ...)
{
    va_list Args;

    va_start(Args, Format);
    m_Control->ControlledOutputVaList(DEBUG_OUTCTL_AMBIENT_DML,
                                      DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

void WINAPIV
ExtExtension::DmlVerb(_In_ PCSTR Format,
                      ...)
{
    va_list Args;

    va_start(Args, Format);
    m_Control->ControlledOutputVaList(DEBUG_OUTCTL_AMBIENT_DML,
                                      DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}

void WINAPIV
ExtExtension::Dml(_In_ PCWSTR Format,
                  ...)
{
    va_list Args;

    va_start(Args, Format);
    m_Control4->ControlledOutputVaListWide(DEBUG_OUTCTL_AMBIENT_DML,
                                           m_OutMask,
                                           Format,
                                           Args);
    va_end(Args);
}

void WINAPIV
ExtExtension::DmlWarn(_In_ PCWSTR Format,
                      ...)
{
    va_list Args;

    va_start(Args, Format);
    m_Control4->ControlledOutputVaListWide(DEBUG_OUTCTL_AMBIENT_DML,
                                           DEBUG_OUTPUT_WARNING,
                                           Format,
                                           Args);
    va_end(Args);
}

void WINAPIV
ExtExtension::DmlErr(_In_ PCWSTR Format,
                     ...)
{
    va_list Args;

    va_start(Args, Format);
    m_Control4->ControlledOutputVaListWide(DEBUG_OUTCTL_AMBIENT_DML,
                                           DEBUG_OUTPUT_ERROR,
                                           Format,
                                           Args);
    va_end(Args);
}

void WINAPIV
ExtExtension::DmlVerb(_In_ PCWSTR Format,
                      ...)
{
    va_list Args;

    va_start(Args, Format);
    m_Control4->ControlledOutputVaListWide(DEBUG_OUTCTL_AMBIENT_DML,
                                           DEBUG_OUTPUT_VERBOSE,
                                           Format,
                                           Args);
    va_end(Args);
}

void WINAPI
ExtExtension::WrapLine(void)
{
    if (m_LeftIndent)
    {
        m_Control->Output(m_OutMask, "\n%*c", m_LeftIndent, ' ');
    }
    else
    {
        m_Control->Output(m_OutMask, "\n");
    }
    m_CurChar = m_LeftIndent;
}

void WINAPI
ExtExtension::OutWrapStr(_In_ PCSTR String)
{
    if (m_TestWrap)
    {
        m_TestWrapChars += (ULONG)strlen(String);
        return;
    }
    
    while (*String)
    {
        //
        // Collect characters until the end or
        // until we run out of output width.
        //

        PCSTR Scan = String;
        PCSTR LastSpace = NULL;
        while (*Scan &&
               *Scan != '\n' &&
               (!m_AllowWrap ||
                !LastSpace ||
                m_CurChar < m_OutputWidth))
        {
            if (*Scan == ' ')
            {
                LastSpace = Scan;
            }
            
            m_CurChar++;
            Scan++;
        }

        if (m_AllowWrap &&
            LastSpace &&
            ((*Scan && *Scan != '\n') ||
             m_CurChar >= m_OutputWidth))
        {
            // We ran out of room, so dump output up
            // to the last space.
            Scan = LastSpace;
        }

        m_Control->Output(m_OutMask, "%.*s", (int)(Scan - String), String);

        if (!*Scan)
        {
            break;
        }

        //
        // Wrap to the next line.
        //
        
        WrapLine();
        String = Scan + 1;
        while (*String == ' ')
        {
            String++;
        }
    }
}

void WINAPIV
ExtExtension::OutWrapVa(_In_ PCSTR Format,
                        _In_ va_list Args)
{
    StringCbVPrintf(s_String, sizeof(s_String), Format, Args);
    OutWrapStr(s_String);
}

void WINAPIV
ExtExtension::OutWrap(_In_ PCSTR Format,
                      ...)
{
    va_list Args;
    
    va_start(Args, Format);
    OutWrapVa(Format, Args);
    va_end(Args);
}

PSTR WINAPI
ExtExtension::RequestCircleString(_In_ ULONG Chars)
{
    if (Chars > EXT_DIMA(s_CircleStringBuffer))
    {
        ThrowInvalidArg("Circle string buffer overflow, %u chars", Chars);
    }

    if ((ULONG_PTR)(s_CircleString - s_CircleStringBuffer) >
        EXT_DIMA(s_CircleStringBuffer) - Chars)
    {
        // String is too long to fit in the remainder, wrap around.
        s_CircleString = s_CircleStringBuffer;
    }

    PSTR Str = s_CircleString;
    s_CircleString += Chars;
    return Str;
}

PSTR WINAPI
ExtExtension::CopyCircleString(_In_ PCSTR Str)
{
    PSTR Buf;
    ULONG Chars;
    
    Chars = (ULONG)strlen(Str) + 1;
    Buf = RequestCircleString(Chars);
    memcpy(Buf, Str, Chars * sizeof(*Str));
    return Buf;
}

PSTR WINAPI
ExtExtension::PrintCircleStringVa(_In_ PCSTR Format,
                                  _In_ va_list Args)
{
    StringCbVPrintf(s_String, sizeof(s_String), Format, Args);
    return CopyCircleString(s_String);
}

PSTR WINAPIV
ExtExtension::PrintCircleString(_In_ PCSTR Format,
                                ...)
{
    PSTR Str;
    va_list Args;

    va_start(Args, Format);
    Str = PrintCircleStringVa(Format, Args);
    va_end(Args);
    return Str;
}
    
void WINAPI
ExtExtension::SetAppendBuffer(_In_reads_(BufferChars) PSTR Buffer,
                              _In_ ULONG BufferChars)
{
    m_AppendBuffer = Buffer;
    m_AppendBufferChars = BufferChars;
    m_AppendAt = Buffer;
}

void WINAPI
ExtExtension::AppendBufferString(_In_ PCSTR Str)
{
    ULONG Chars;
    
    Chars = (ULONG)strlen(Str) + 1;
    if (Chars > m_AppendBufferChars ||
        (ULONG_PTR)(m_AppendAt - m_AppendBuffer) > m_AppendBufferChars - Chars)
    {
        ThrowStatus(HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW),
                    "Append string overflowed");
    }

    memcpy(m_AppendAt, Str, Chars * sizeof(*Str));
    // Position next append where it will overwrite the terminator
    // to continue the existing string.
    m_AppendAt += Chars - 1;
}

void WINAPI
ExtExtension::AppendStringVa(_In_ PCSTR Format,
                             _In_ va_list Args)
{
    if (m_AppendBuffer >= s_String &&
        m_AppendBuffer <= s_String + (EXT_DIMA(s_String) - 1))
    {
        ThrowInvalidArg("Append string buffer cannot use s_String");
    }
    
    StringCbVPrintf(s_String, sizeof(s_String), Format, Args);
    AppendBufferString(s_String);
}

void WINAPIV
ExtExtension::AppendString(_In_ PCSTR Format,
                           ...)
{
    va_list Args;

    va_start(Args, Format);
    AppendStringVa(Format, Args);
    va_end(Args);
}
    
void WINAPI
ExtExtension::SetCallStatus(_In_ HRESULT Status)
{
    // If an error has already been saved don't override it.
    if (!FAILED(m_CallStatus))
    {
        m_CallStatus = Status;
    }
}

ULONG WINAPI
ExtExtension::GetEffectiveProcessor(void)
{
    ULONG CurType;

    EXT_STATUS(m_Control->GetEffectiveProcessorType(&CurType));
    return CurType;
}

void WINAPI
ExtExtension::SetEffectiveProcessor(_In_ ULONG ProcType,
                                    _Inout_opt_ ExtEffectiveProcessorTypeHolder* Holder)
{
    if (Holder &&
        !Holder->IsHolding())
    {
        Holder->Refresh();
    }

    EXT_STATUS(m_Control->SetEffectiveProcessorType(ProcType));

    EXT_STATUS(QueryMachineInfo());
}

ULONG WINAPI
ExtExtension::GetCachedSymbolTypeId(_Inout_ PULONG64 Cookie,
                                    _In_ PCSTR Symbol,
                                    _Out_ PULONG64 ModBase)
{
    HRESULT Status;
    DEBUG_CACHED_SYMBOL_INFO Info;

    //
    // Check for an existing cache entry.
    //
        
    if ((Status = m_Advanced2->
         Request(DEBUG_REQUEST_GET_CACHED_SYMBOL_INFO,
                 Cookie,
                 sizeof(*Cookie),
                 &Info,
                 sizeof(Info),
                 NULL)) == S_OK)
    {
        *ModBase = Info.ModBase;
        return Info.Id;
    }

    //
    // No entry in cache, find the data the hard way.
    //

    ZeroMemory(&Info, sizeof(Info));
    
    if ((Status = m_Symbols->
         GetSymbolTypeId(Symbol, 
                         &Info.Id,
                         &Info.ModBase)) != S_OK)
    {
        ThrowStatus(Status, "Unable to get type ID of '%s'",
                    Symbol);
    }

    *ModBase = Info.ModBase;
    
    //
    // Add recovered info to cache.
    // We don't care if this fails as
    // cache addition is not required,
    // we just zero the cookie.
    //

    if (m_Advanced2->
        Request(DEBUG_REQUEST_ADD_CACHED_SYMBOL_INFO,
                &Info,
                sizeof(Info),
                Cookie,
                sizeof(*Cookie),
                NULL) != S_OK)
    {
        *Cookie = 0;
    }

    return Info.Id;
}

ULONG WINAPI
ExtExtension::GetCachedFieldOffset(_Inout_ PULONG64 Cookie,
                                   _In_ PCSTR Type,
                                   _In_ PCSTR Field,
                                   _Out_opt_ PULONG64 TypeModBase,
                                   _Out_opt_ PULONG TypeId)
{
    HRESULT Status;
    DEBUG_CACHED_SYMBOL_INFO Info;

    //
    // Check for an existing cache entry.
    //
        
    if ((Status = m_Advanced2->
         Request(DEBUG_REQUEST_GET_CACHED_SYMBOL_INFO,
                 Cookie,
                 sizeof(*Cookie),
                 &Info,
                 sizeof(Info),
                 NULL)) == S_OK)
    {
        if (TypeModBase)
        {
            *TypeModBase = Info.ModBase;
        }
        if (TypeId)
        {
            *TypeId = Info.Id;
        }
        return Info.Arg3;
    }

    //
    // No entry in cache, find the data the hard way.
    //

    ZeroMemory(&Info, sizeof(Info));
    
    if ((Status = m_Symbols->
         GetSymbolTypeId(Type, 
                         &Info.Id,
                         &Info.ModBase)) != S_OK)
    {
        ThrowStatus(Status, "Unable to get type ID of '%s'",
                    Type);
    }
    if ((Status = m_Symbols->
         GetFieldOffset(Info.ModBase,
                        Info.Id,
                        Field,
                        &Info.Arg3)) != S_OK)
    {
        ThrowStatus(Status, "Unable to get field '%s.%s'",
                    Type, Field);
    }
    
    if (TypeModBase)
    {
        *TypeModBase = Info.ModBase;
    }
    if (TypeId)
    {
        *TypeId = Info.Id;
    }

    //
    // Add recovered info to cache.
    // We don't care if this fails as
    // cache addition is not required,
    // we just zero the cookie.
    //

    if (m_Advanced2->
        Request(DEBUG_REQUEST_ADD_CACHED_SYMBOL_INFO,
                &Info,
                sizeof(Info),
                Cookie,
                sizeof(*Cookie),
                NULL) != S_OK)
    {
        *Cookie = 0;
    }

    return Info.Arg3;
}

bool WINAPI
ExtExtension::GetCachedSymbolInfo(_In_ ULONG64 Cookie,
                                  _Out_ PDEBUG_CACHED_SYMBOL_INFO Info)
{
    HRESULT Status;
    
    if ((Status = m_Advanced2->
         Request(DEBUG_REQUEST_GET_CACHED_SYMBOL_INFO,
                 &Cookie,
                 sizeof(Cookie),
                 Info,
                 sizeof(*Info),
                 NULL)) == S_OK)
    {
        return true;
    }
    
    return false;
}

bool WINAPI
ExtExtension::AddCachedSymbolInfo(_In_ PDEBUG_CACHED_SYMBOL_INFO Info,
                                  _In_ bool ThrowFailure,
                                  _Out_ PULONG64 Cookie)
{
    HRESULT Status;
    
    if ((Status = m_Advanced2->
         Request(DEBUG_REQUEST_ADD_CACHED_SYMBOL_INFO,
                 Info,
                 sizeof(*Info),
                 Cookie,
                 sizeof(*Cookie),
                 NULL)) == S_OK)
    {
        return true;
    }
    
    if (ThrowFailure)
    {
        ThrowStatus(Status, "Unable to cache symbol info");
    }

    return false;
}

void WINAPI
ExtExtension::FindSymMatchStringA(void)
{
    m_DbgHelp = LoadLibraryA("dbghelp.dll");
    if (!m_DbgHelp)
    {
        ThrowLastError("Unable to load dbghelp.dll");
    }

    m_SymMatchStringA = (PFN_SymMatchStringA)
        GetProcAddress(m_DbgHelp, "SymMatchStringA");
    if (!m_SymMatchStringA)
    {
        HRESULT Status = HRESULT_FROM_WIN32(GetLastError());
        FreeLibrary(m_DbgHelp);
        m_DbgHelp = NULL;
        ThrowStatus(Status, "Unable to find SymMatchStringA in dbghelp.dll");
    }
}

bool WINAPI
ExtExtension::GetOffsetSymbol(_In_ ULONG64 Offs,
                              _Inout_ ExtBuffer<char>* Name,
                              _Out_opt_ PULONG64 Displacement,
                              _In_ bool AddDisp) throw(...)
{
    HRESULT Status;
    ULONG Need;
    ULONG64 LocalDisp;

    for (UINT i = 0; i < 2; i++)
    {
        Status = m_Symbols->GetNameByOffset(Offs,
                                            Name->GetRawBuffer(),
                                            Name->GetEltsAlloc(),
                                            &Need,
                                            &LocalDisp);
        if (Status == E_NOINTERFACE)
        {
            return false;
        }
        else if (Status == S_OK &&
                 Name->GetRawBuffer())
        {
            Name->SetEltsUsed(Need);
            if (Displacement)
            {
                *Displacement = LocalDisp;
            }
            if (AddDisp)
            {
                const ULONG DispChars = 19;
                
                Name->Require(Need, DispChars);
                StringCchPrintf(Name->GetBuffer() + (Need - 1),
                                DispChars,
                                "+0x%I64x",
                                LocalDisp);
            }
            return true;
        }
        else if (FAILED(Status))
        {
            ThrowStatus(Status,
                        "Failed during symbol resolution for 0x%p",
                        Offs);
        }

        Name->Require(Need);
    }

    ThrowStatus(E_FAIL, "Invalid loop when resolving 0x%p");
}

ULONG WINAPI
ExtExtension::FindFirstModule(_In_ PCSTR Pattern,
                              _Inout_opt_ ExtBuffer<char>* Name,
                              _In_ ULONG StartIndex) throw(...)
{
    HRESULT Status;
    ULONG Need;
    ExtDeclBuffer<char, 100> LocalName;

    for (;;)
    {
        Status = m_Symbols->GetModuleNames(StartIndex,
                                           0,
                                           NULL,
                                           0,
                                           NULL,
                                           LocalName.GetRawBuffer(),
                                           LocalName.GetEltsAlloc(),
                                           &Need,
                                           NULL,
                                           0,
                                           NULL);
        if (Status == S_OK)
        {
            if (!MatchPattern(LocalName, Pattern))
            {
                StartIndex++;
                continue;
            }
            
            if (Name)
            {
                LocalName.SetEltsUsed(Need);
                Name->Copy(&LocalName);
            }
            return StartIndex;
        }
        else if (Status != S_FALSE)
        {
            ThrowStatus(Status,
                        "Unable to find any module matches for '%s'",
                        Pattern);
        }

        LocalName.RequireRounded(Need, 20);
    }
}

void WINAPI
ExtExtension::GetModuleImagehlpInfo(_In_ ULONG64 ModBase,
                                    _Out_ struct _IMAGEHLP_MODULEW64* Info)
{
    HRESULT Status;

    ZeroMemory(Info, sizeof(*Info));
    Info->SizeOfStruct = sizeof(*Info);
    
    if ((Status = m_Advanced2->
         GetSymbolInformation(DEBUG_SYMINFO_IMAGEHLP_MODULEW64,
                              ModBase,
                              0,
                              Info,
                              Info->SizeOfStruct,
                              NULL,
                              NULL,
                              0,
                              NULL)) != S_OK)
    {
        ThrowStatus(Status, "Unable to retrieve module info");
    }
}

bool WINAPI
ExtExtension::ModuleHasGlobalSymbols(_In_ ULONG64 ModBase)
{
    IMAGEHLP_MODULEW64 Info;

    GetModuleImagehlpInfo(ModBase, &Info);
    return Info.GlobalSymbols != FALSE;
}

bool WINAPI
ExtExtension::ModuleHasTypeInfo(_In_ ULONG64 ModBase)
{
    IMAGEHLP_MODULEW64 Info;
    
    GetModuleImagehlpInfo(ModBase, &Info);
    return Info.TypeInfo != FALSE;
}

ULONG64 WINAPI
ExtExtension::CallDebuggeeBase(_In_ PCSTR CommandString,
                               _In_ ULONG TimeoutMilliseconds)
{
    HRESULT Status;
    ExtDeclBuffer<char, 300> Cmd;
    ExtCaptureOutputA IgnoreOut;

    Cmd.Copy(".call ", 6);
    Cmd.Append(CommandString, (ULONG)strlen(CommandString) + 1);

    if (FAILED(Status = m_Control->
               Execute(DEBUG_OUTCTL_IGNORE,
                       Cmd,
                       DEBUG_EXECUTE_NOT_LOGGED |
                       DEBUG_EXECUTE_NO_REPEAT)))
    {
        ThrowStatus(Status, "Unable to execute '%s'", Cmd);
    }

    // Capture output just so we can throw away the
    // automatic retval output from .call when execution completes.
    // This isn't ideal since it won't hide output to
    // other clients but it's the best we can do.
    // Eventually .call will get a quiet mode and then
    // at least the return value output can be hidden.
    IgnoreOut.Start();
    
    if ((Status = m_Control->SetExecutionStatus(DEBUG_STATUS_GO)) == S_OK)
    {
        Status = m_Control->WaitForEvent(DEBUG_WAIT_DEFAULT,
                                         TimeoutMilliseconds);
    }

    IgnoreOut.Delete();

    if (FAILED(Status))
    {
        // Try and revert our .call setup.
        m_Control->Execute(DEBUG_OUTCTL_IGNORE,
                           ".call -c",
                           DEBUG_EXECUTE_NOT_LOGGED |
                           DEBUG_EXECUTE_NO_REPEAT);
        
        ThrowStatus(Status, "Unable to wait for debuggee to run");
    }
    else if (Status != S_OK)
    {
        // Try and get control back.
        m_Control->SetInterrupt(DEBUG_INTERRUPT_ACTIVE);
        
        ThrowStatus(E_FAIL,
                    "DANGEROUS FAILURE: "
                    "Debuggee took longer than %g seconds to run "
                    "and is still running.\n"
                    "A break-in request has been made but the debuggee "
                    "may be dead.\n"
                    "If the debuggee does come back validate that its "
                    "state has not be corrupted.",
                    (double)TimeoutMilliseconds / 1000);
    }

    ULONG64 RetVal;
    
    GetExprU64("@$callret", (ULONG64)-1, &RetVal);
    return RetVal;
}

ULONG WINAPI
ExtExtension::FindRegister(_In_ PCSTR Name,
                           _Inout_opt_ PULONG IndexCache)
{
    HRESULT Status;
    ULONG Index;
    
    if (IndexCache != NULL &&
        *IndexCache != DEBUG_ANY_ID)
    {
        return *IndexCache;
    }

    if ((Status = m_Registers->GetIndexByName(Name,
                                              &Index)) != S_OK)
    {
        ThrowStatus(Status, "Unable to find register '%s'", Name);
    }

    if (IndexCache != NULL)
    {
        *IndexCache = Index;
    }

    return Index;
}

ULONG64 WINAPI
ExtExtension::GetRegisterU64(_In_ PCSTR Name,
                             _Inout_opt_ PULONG IndexCache)
{
    HRESULT Status;
    ULONG Index = FindRegister(Name, IndexCache);
    DEBUG_VALUE RegVal, RegVal64;

    if ((Status = m_Registers->GetValue(Index,
                                        &RegVal)) != S_OK ||
        (Status = m_Control->CoerceValue(&RegVal,
                                         DEBUG_VALUE_INT64,
                                         &RegVal64)) != S_OK)
    {
        ThrowStatus(Status, "Unable to get value for '%s'", Name);
    }

    return RegVal64.I64;
}

void WINAPI
ExtExtension::SetRegisterU64(_In_ PCSTR Name,
                             _In_ ULONG64 Val,
                             _Inout_opt_ PULONG IndexCache)
{
    HRESULT Status;
    ULONG Index = FindRegister(Name, IndexCache);
    DEBUG_VALUE RegVal64;

    RegVal64.Type = DEBUG_VALUE_INT64;
    RegVal64.I64 = Val;
    if ((Status = m_Registers->SetValue(Index,
                                        &RegVal64)) != S_OK)
    {
        ThrowStatus(Status, "Unable to set value for '%s'", Name);
    }
}

ULONG WINAPI
ExtExtension::FindPseudoRegister(_In_ PCSTR Name,
                                 _Inout_opt_ PULONG IndexCache)
{
    HRESULT Status;
    ULONG Index;
    
    if (IndexCache != NULL &&
        *IndexCache != DEBUG_ANY_ID)
    {
        return *IndexCache;
    }

    if ((Status = m_Registers2->GetPseudoIndexByName(Name,
                                                     &Index)) != S_OK)
    {
        ThrowStatus(Status, "Unable to find pseudo-register '%s'", Name);
    }

    if (IndexCache != NULL)
    {
        *IndexCache = Index;
    }

    return Index;
}

ULONG64 WINAPI
ExtExtension::GetPseudoRegisterU64(_In_ PCSTR Name,
                                   _Inout_opt_ PULONG IndexCache)
{
    HRESULT Status;
    ULONG Index = FindPseudoRegister(Name, IndexCache);
    DEBUG_VALUE RegVal, RegVal64;

    if ((Status = m_Registers2->GetPseudoValues(DEBUG_REGSRC_DEBUGGEE,
                                                1,
                                                &Index,
                                                0,
                                                &RegVal)) != S_OK ||
        (Status = m_Control->CoerceValue(&RegVal,
                                         DEBUG_VALUE_INT64,
                                         &RegVal64)) != S_OK)
    {
        ThrowStatus(Status, "Unable to get value for '%s'", Name);
    }

    return RegVal64.I64;
}

void WINAPI
ExtExtension::SetPseudoRegisterU64(_In_ PCSTR Name,
                                   _In_ ULONG64 Val,
                                   _Inout_opt_ PULONG IndexCache)
{
    HRESULT Status;
    ULONG Index = FindPseudoRegister(Name, IndexCache);
    DEBUG_VALUE RegVal64;

    RegVal64.Type = DEBUG_VALUE_INT64;
    RegVal64.I64 = Val;
    if ((Status = m_Registers2->SetPseudoValues(DEBUG_REGSRC_DEBUGGEE,
                                                1,
                                                &Index,
                                                0,
                                                &RegVal64)) != S_OK)
    {
        ThrowStatus(Status, "Unable to set value for '%s'", Name);
    }
}

PCSTR WINAPI
ExtExtension::GetUnnamedArgStr(_In_ ULONG Index)
{
    if (Index >= m_NumUnnamedArgs)
    {
        ThrowInvalidArg("Invalid unnamed argument index %u, only given %u",
                        Index + 1, m_NumUnnamedArgs);
    }
    if (!m_Args[Index].StrVal)
    {
        ThrowInvalidArg("Unnamed argument index %u is not a string",
                        Index + 1);
    }

    return m_Args[Index].StrVal;
}

ULONG64 WINAPI
ExtExtension::GetUnnamedArgU64(_In_ ULONG Index)
{
    if (Index >= m_NumUnnamedArgs)
    {
        ThrowInvalidArg("Invalid unnamed argument index %u, only given %u",
                        Index + 1, m_NumUnnamedArgs);
    }
    if (m_Args[Index].StrVal)
    {
        ThrowInvalidArg("Unnamed argument index %u is not a number",
                        Index + 1);
    }

    return m_Args[Index].NumVal;
}

PCSTR WINAPI
ExtExtension::GetArgStr(_In_ PCSTR Name,
                        _In_ bool Required)
{
    ArgVal* Arg = FindArg(Name, Required);
    if (!Arg)
    {
        return NULL;
    }
    if (!Arg->StrVal)
    {
        ThrowInvalidArg("Argument /%s is not a string",
                        Name);
    }
    return Arg->StrVal;
}

ULONG64 WINAPI
ExtExtension::GetArgU64(_In_ PCSTR Name,
                        _In_ bool Required)
{
    ArgVal* Arg = FindArg(Name, Required);
    if (!Arg)
    {
        return 0;
    }
    if (Arg->StrVal)
    {
        ThrowInvalidArg("Argument /%s is not a number",
                        Name);
    }
    return Arg->NumVal;
}

bool WINAPI
ExtExtension::SetUnnamedArg(_In_ ULONG Index,
                            _In_opt_ PCSTR StrArg,
                            _In_ ULONG64 NumArg,
                            _In_ bool OnlyIfUnset)
{
    ExtCommandDesc::ArgDesc* Check = m_CurCommand->FindUnnamedArg(Index);
    if (!Check)
    {
        ThrowInvalidArg("Unnamed argument index %u too large", Index);
    }

    ArgVal* Val = NULL;
    
    if (HasUnnamedArg(Index))
    {
        if (OnlyIfUnset)
        {
            return false;
        }

        Val = &m_Args[Index];
    }

    SetRawArgVal(Check, Val, true, StrArg, false, NumArg);
    return true;
}

bool WINAPI
ExtExtension::SetArg(_In_ PCSTR Name,
                     _In_opt_ PCSTR StrArg,
                     _In_ ULONG64 NumArg,
                     _In_ bool OnlyIfUnset)
{
    ExtCommandDesc::ArgDesc* Check = m_CurCommand->FindArg(Name);
    if (!Check)
    {
        ThrowInvalidArg("No argument named '%s'", Name);
    }

    ArgVal* Val = FindArg(Name, false);

    if (Val)
    {
        if (OnlyIfUnset)
        {
            return false;
        }
    }

    SetRawArgVal(Check, Val, true, StrArg, false, NumArg);
    return true;
}

PCSTR WINAPI
ExtExtension::GetExpr64(_In_ PCSTR Str,
                        _In_ bool Signed,
                        _In_ ULONG64 Limit,
                        _Out_ PULONG64 Val)
{
    HRESULT Status;
    DEBUG_VALUE FullVal;
    ULONG EndIdx;

    if ((Status = m_Control->
         Evaluate(Str, DEBUG_VALUE_INT64, &FullVal, &EndIdx)) != S_OK)
    {
        ExtStatusException Ex(Status);

        Ex.PrintMessage(s_String, EXT_DIMA(s_String),
                        "Unable to evaluate expression '%s'", Str);
        throw Ex;
    }
    if ((!Signed &&
         FullVal.I64 > Limit) ||
        (Signed &&
         ((LONG64)FullVal.I64 < -(LONG64)Limit ||
          (LONG64)FullVal.I64 > (LONG64)Limit)))
    {
        ThrowInvalidArg("Result overflow in expression '%s'", Str);
    }

    *Val = FullVal.I64;
    Str += EndIdx;

    while (IsSpace(*Str))
    {
        Str++;
    }

    return Str;
}

void WINAPIV
ExtExtension::ThrowInvalidArg(_In_ PCSTR Format,
                              ...)
{
    ExtInvalidArgumentException Ex("");
    va_list Args;

    va_start(Args, Format);
    Ex.PrintMessageVa(s_String, EXT_DIMA(s_String),
                      Format, Args);
    va_end(Args);
    throw Ex;
}

void WINAPIV
ExtExtension::ThrowRemote(_In_ HRESULT Status,
                          _In_ PCSTR Format,
                          ...)
{
    ExtRemoteException Ex(Status, "");
    va_list Args;

    va_start(Args, Format);
    Ex.PrintMessageVa(s_String, EXT_DIMA(s_String),
                      Format, Args);
    va_end(Args);
    throw Ex;
}

void WINAPIV
ExtExtension::ThrowStatus(_In_ HRESULT Status,
                          _In_ PCSTR Format,
                          ...)
{
    ExtStatusException Ex(Status);
    va_list Args;

    va_start(Args, Format);
    Ex.PrintMessageVa(s_String, EXT_DIMA(s_String),
                      Format, Args);
    va_end(Args);
    throw Ex;
}

void WINAPI
ExtExtension::ExInitialize(void)
{
    if (m_ExInitialized)
    {
        return;
    }

    m_ExInitialized = true;

    //
    // Special initialization pass that
    // is done when output can be produced
    // and exceptions thrown.
    // This pass allows verbose feedback on
    // errors, as opposed to the DLL-load Initialize().
    //
}

HRESULT WINAPI
ExtExtension::QueryMachineInfo(void)
{
    HRESULT Status;

    if ((Status = m_Control->
         GetEffectiveProcessorType(&m_Machine)) != S_OK ||
        (Status = m_Control->
         GetPageSize(&m_PageSize)) != S_OK ||
        // IsPointer64Bit check must be last as Status
        // is used to compute the pointer size below.
        FAILED(Status = m_Control->
               IsPointer64Bit()))
    {
        return Status;
    }
    if (Status == S_OK)
    {
        m_PtrSize = 8;
        m_OffsetMask = 0xffffffffffffffffUI64;
    }
    else
    {
        m_PtrSize = 4;
        m_OffsetMask = 0xffffffffUI64;
    }

    m_ExtRetIndex = DEBUG_ANY_ID;
    for (ULONG i = 0; i < EXT_DIMA(m_TempRegIndex); i++)
    {
        m_TempRegIndex[i] = DEBUG_ANY_ID;
    }
    
    return S_OK;
}

#define REQ_IF(_If, _Member) \
    if ((Status = Start->QueryInterface(__uuidof(_If), \
                                        (PVOID*)&_Member)) != S_OK) \
    { \
        goto Exit; \
    }
#define OPT_IF(_If, _Member) \
    if ((Status = Start->QueryInterface(__uuidof(_If), \
                                        (PVOID*)&_Member)) != S_OK) \
    { \
        _Member.Set(NULL); \
    }

HRESULT WINAPI
ExtExtension::Query(_In_ PDEBUG_CLIENT Start)
{
    HRESULT Status;
    ULONG64 Address = 0;
    ULONG CSDVersion = 0;

    // We don't support nested queries.
    if (*&m_Advanced != NULL)
    {
        return E_UNEXPECTED;
    }

    m_ArgCopy = NULL;
    
    REQ_IF(IDebugAdvanced, m_Advanced);
    REQ_IF(IDebugClient, m_Client);
    REQ_IF(IDebugControl, m_Control);
    REQ_IF(IDebugDataSpaces, m_Data);
    REQ_IF(IDebugRegisters, m_Registers);
    REQ_IF(IDebugSymbols, m_Symbols);
    REQ_IF(IDebugSystemObjects, m_System);
    
    OPT_IF(IDebugAdvanced2, m_Advanced2);
    OPT_IF(IDebugAdvanced3, m_Advanced3);
    OPT_IF(IDebugClient2, m_Client2);
    OPT_IF(IDebugClient3, m_Client3);
    OPT_IF(IDebugClient4, m_Client4);
    OPT_IF(IDebugClient5, m_Client5);
    OPT_IF(IDebugControl2, m_Control2);
    OPT_IF(IDebugControl3, m_Control3);
    OPT_IF(IDebugControl4, m_Control4);
    OPT_IF(IDebugControl5, m_Control5);
    OPT_IF(IDebugControl6, m_Control6);
    OPT_IF(IDebugDataSpaces2, m_Data2);
    OPT_IF(IDebugDataSpaces3, m_Data3);
    OPT_IF(IDebugDataSpaces4, m_Data4);
    OPT_IF(IDebugRegisters2, m_Registers2);
    OPT_IF(IDebugSymbols2, m_Symbols2);
    OPT_IF(IDebugSymbols3, m_Symbols3);
    OPT_IF(IDebugSystemObjects2, m_System2);
    OPT_IF(IDebugSystemObjects3, m_System3);
    OPT_IF(IDebugSystemObjects4, m_System4);

    // If this isn't a dump target GetDumpFormatFlags
    // will fail, so just zero the flags.  People
    // checking should check the class and qualifier
    // first so having them zeroed is not a problem.
    if (!m_Control2.IsSet() ||
        m_Control2->GetDumpFormatFlags(&m_DumpFormatFlags) != S_OK)
    {
        m_DumpFormatFlags = 0;
    }
    
    if ((Status = m_Control->
         GetDebuggeeType(&m_DebuggeeClass,
                         &m_DebuggeeQual)) != S_OK ||
        (Status = m_Client->
         GetOutputWidth(&m_OutputWidth)) != S_OK ||
        (Status = m_Control->
         GetActualProcessorType(&m_ActualMachine)) != S_OK ||
        (Status = QueryMachineInfo()) != S_OK)
    {
        goto Exit;
    }

    // User targets may fail a processor count request.
    if (m_Control->GetNumberProcessors(&m_NumProcessors) != S_OK)
    {
        m_NumProcessors = 0;
    }

    ExtensionApis.nSize = sizeof(ExtensionApis);
    Status = m_Control->GetWindbgExtensionApis64(&ExtensionApis);
    if (Status == RPC_E_CALL_REJECTED)
    {
        // GetWindbgExtensionApis64 is not remotable,
        // and this particular failure means we
        // are running remotely.  Go on without any
        // wdbgexts support.
        ZeroMemory(&ExtensionApis, sizeof(ExtensionApis));
        m_IsRemote = true;
        Status = S_OK;
    }
    else
    {
        m_IsRemote = false;
    }

    m_Control->GetSystemVersion(&m_PlatformId,
                                &m_Major,
                                &m_Minor,
                                NULL, NULL, NULL,
                                &m_ServicePackNumber,
                                NULL, NULL, NULL);

    m_Control6->GetSystemVersionValues(&m_PlatformId,
                                       &m_MajorVersion,
                                       &m_MinorVersion,
                                       NULL,
                                       NULL);

    m_SystemVersion = MAKEWORD(m_MinorVersion, m_MajorVersion);

    m_Data4->ReadDebuggerData(DEBUG_DATA_CmNtCSDVersionAddr, &Address, sizeof(Address), NULL);

    if (S_OK == m_Data4->ReadVirtual(Address, &CSDVersion, sizeof(CSDVersion), NULL)) {

        m_ServicePackMajor = (CSDVersion >> 8) & 0xFF;
        m_ServicePackMinor = CSDVersion & 0xFF;
    }

    m_Data4->ReadDebuggerData(DEBUG_DATA_ProductType, &m_ProductType, sizeof(m_ProductType), NULL);
    m_Data4->ReadDebuggerData(DEBUG_DATA_SuiteMask, &m_SuiteMask, sizeof(m_SuiteMask), NULL);

    m_Data4->ReadDebuggerData(DEBUG_DATA_MmNumberOfPhysicalPagesAddr, &Address, sizeof(Address), NULL);
    m_Data4->ReadVirtual(Address, &m_NumberOfPhysicalPages, sizeof(m_NumberOfPhysicalPages), NULL);

    if (m_Data4->ReadDebuggerData(DEBUG_DATA_SharedUserData, &Address, sizeof(Address), NULL) == S_OK) {

        try {

            ExtRemoteTyped SharedData = ExtRemoteTyped("(nt!_KUSER_SHARED_DATA *)@$extin", Address);
            SharedData.Field("SystemTime").ReadBuffer(&m_SystemTime, sizeof(m_SystemTime));
        }
        catch (...) {

        }
    }

    RefreshOutputCallbackFlags();

 Exit:
    if (Status != S_OK)
    {
        if (*&m_Control != NULL)
        {
            m_Control->Output(DEBUG_OUTPUT_ERROR,
                              "ERROR: Unable to query interfaces, 0x%08x\n",
                              Status);
        }
        Release();
    }
    return Status;
}

void WINAPI
ExtExtension::Release(void)
{
    EXT_RELEASE(m_Advanced);
    EXT_RELEASE(m_Client);
    EXT_RELEASE(m_Control);
    EXT_RELEASE(m_Data);
    EXT_RELEASE(m_Registers);
    EXT_RELEASE(m_Symbols);
    EXT_RELEASE(m_System);
    EXT_RELEASE(m_Advanced2);
    EXT_RELEASE(m_Advanced3);
    EXT_RELEASE(m_Client2);
    EXT_RELEASE(m_Client3);
    EXT_RELEASE(m_Client4);
    EXT_RELEASE(m_Client5);
    EXT_RELEASE(m_Control2);
    EXT_RELEASE(m_Control3);
    EXT_RELEASE(m_Control4);
    EXT_RELEASE(m_Control5);
    EXT_RELEASE(m_Control6);
    EXT_RELEASE(m_Data2);
    EXT_RELEASE(m_Data3);
    EXT_RELEASE(m_Data4);
    EXT_RELEASE(m_Registers2);
    EXT_RELEASE(m_Symbols2);
    EXT_RELEASE(m_Symbols3);
    EXT_RELEASE(m_System2);
    EXT_RELEASE(m_System3);
    EXT_RELEASE(m_System4);
    ZeroMemory(&ExtensionApis, sizeof(ExtensionApis));
    free(m_ArgCopy);
    m_ArgCopy = NULL;
    m_CurCommand = NULL;
}

HRESULT WINAPI
ExtExtension::CallExtCodeCEH(_In_opt_ ExtCommandDesc* Desc,
                             _In_opt_ PCSTR Args,
                             _In_opt_ ExtRawMethod RawMethod,
                             _In_opt_ ExtRawFunction RawFunction,
                             _In_opt_ PVOID Context,
                             _In_opt_ PCSTR RawName)
{
    HRESULT Status;
    PCSTR PreName;
    PCSTR Name;

    PreName = "";

    if (RawName)
    {
        Name = RawName;
    }
    else if (Desc)
    {
        PreName = "!";
        Name = Desc->m_Name;
    }
    else
    {
        Name = NULL;
    }
    
    try
    {
        ExInitialize();

        if (Desc)
        {
            Desc->ExInitialize(this);
            ParseArgs(Desc, Args);
        }
        
        m_CallStatus = S_OK;
        // Release NULLs this out.
        m_CurCommand = Desc;

        if (RawFunction)
        {
            Status = RawFunction(Context);
        }
        else if (RawMethod)
        {
            Status = (this->*RawMethod)(Context);
        }
        else if (Desc)
        {
            (this->*Desc->m_Method)();
            Status = m_CallStatus;
        }
        else
        {
            // This should never happen.
            Status = E_INVALIDARG;
        }
    }
    catch(ExtInterruptException Ex)
    {
        if (Name)
        {
            m_Control->Output(DEBUG_OUTPUT_ERROR, "%s%s: %s.\n",
                              PreName, Name, Ex.GetMessage());
        }
        Status = Ex.GetStatus();
    }
    catch(ExtException Ex)
    {
        if (Name &&
            Ex.GetMessage())
        {
            if (FAILED(Ex.GetStatus()))
            {
                m_Control->
                    Output(DEBUG_OUTPUT_ERROR,
                           "ERROR: %s%s: extension exception "
                           "0x%08x.\n    \"%s\"\n",
                           PreName, Name,
                           Ex.GetStatus(), Ex.GetMessage());
            }
            else
            {
                m_Control->Output(DEBUG_OUTPUT_NORMAL, "%s%s: %s\n",
                                  PreName, Name, Ex.GetMessage());
            }
        }
        else if (Name &&
                 Ex.GetStatus() != DEBUG_EXTENSION_CONTINUE_SEARCH &&
                 Ex.GetStatus() != DEBUG_EXTENSION_RELOAD_EXTENSION &&
                 FAILED(Ex.GetStatus()))
        {
            m_Control->
                Output(DEBUG_OUTPUT_ERROR,
                       "ERROR: %s%s: extension exception 0x%08x.\n",
                       PreName, Name, Ex.GetStatus());
        }
        
        Status = Ex.GetStatus();
    }

    return Status;
}

HRESULT WINAPI
ExtExtension::CallExtCodeSEH(_In_opt_ ExtCommandDesc* Desc,
                             _In_ PDEBUG_CLIENT Client,
                             _In_opt_ PCSTR Args,
                             _In_opt_ ExtRawMethod RawMethod,
                             _In_opt_ ExtRawFunction RawFunction,
                             _In_opt_ PVOID Context,
                             _In_opt_ PCSTR RawName)
{
    HRESULT Status = Query(Client);
    if (Status != S_OK)
    {
        return Status;
    }

    // Use a hard SEH try/finally to guarantee that
    // Release always occurs.
    __try
    {
        Status = CallExtCodeCEH(Desc, Args,
                                RawMethod, RawFunction, Context, RawName);
    }
    __finally
    {
        Release();
    }

    return Status;
}

HRESULT WINAPI
ExtExtension::CallKnownStructMethod(_In_ ExtKnownStruct* Struct,
                                    _In_ ULONG Flags,
                                    _In_ ULONG64 Offset,
                                    _Out_writes_(*BufferChars) PSTR Buffer,
                                    _Inout_ PULONG BufferChars)
{
    HRESULT Status;
    
    try
    {
        ExInitialize();
        SetAppendBuffer(Buffer, *BufferChars);
        
        m_CallStatus = S_OK;

        (this->*Struct->Method)(Struct->TypeName, Flags, Offset);

        Status = m_CallStatus;
    }
    catch(ExtException Ex)
    {
        Status = Ex.GetStatus();
    }

    return Status;
}

HRESULT WINAPI
ExtExtension::CallKnownStruct(_In_ PDEBUG_CLIENT Client,
                              _In_ ExtKnownStruct* Struct,
                              _In_ ULONG Flags,
                              _In_ ULONG64 Offset,
                              _Out_writes_(*BufferChars) PSTR Buffer,
                              _Inout_ PULONG BufferChars)
{
    HRESULT Status = Query(Client);
    if (Status != S_OK)
    {
        return Status;
    }

    // Use a hard SEH try/finally to guarantee that
    // Release always occurs.
    __try
    {
        Status = CallKnownStructMethod(Struct, Flags, Offset,
                                       Buffer, BufferChars);
    }
    __finally
    {
        Release();
    }

    return Status;
}

HRESULT WINAPI
ExtExtension::HandleKnownStruct(_In_ PDEBUG_CLIENT Client,
                                _In_ ULONG Flags,
                                _In_ ULONG64 Offset,
                                _In_opt_ PCSTR TypeName,
                                _Out_writes_opt_(*BufferChars) PSTR Buffer,
                                _Inout_opt_ PULONG BufferChars)
{
    HRESULT Status;
    ExtKnownStruct* Struct = m_KnownStructs;
    
    if (Flags == DEBUG_KNOWN_STRUCT_GET_NAMES &&
        Buffer != NULL &&
        *BufferChars > 0)
    {
        ULONG CharsNeeded;
        
        //
        // Return names of known structs packed in
        // the output buffer.
        //

        // Save a character for the double terminator.
        (*BufferChars)--;
        CharsNeeded = 1;

        Status = S_OK;
        while (Struct && Struct->TypeName)
        {
            ULONG Chars = (ULONG)strlen(Struct->TypeName) + 1;
            CharsNeeded += Chars;
            
            if (Status != S_OK || *BufferChars < Chars)
            {
                Status = S_FALSE;
            }
            else
            {
                memcpy(Buffer, Struct->TypeName, Chars * sizeof(*Buffer));
                Buffer += Chars;
                (*BufferChars) -= Chars;
            }
            
            Struct++;
        }

        *Buffer = 0;
        *BufferChars = CharsNeeded;
    }
    else if (Flags == DEBUG_KNOWN_STRUCT_GET_SINGLE_LINE_OUTPUT &&
             Buffer != NULL &&
             BufferChars > 0)
    {
        //
        // Dispatch request to method.
        //

        Status = E_NOINTERFACE;
        while (Struct && Struct->TypeName)
        {
            if (!strcmp(TypeName, Struct->TypeName))
            {
                Status = CallKnownStruct(Client, Struct, Flags, Offset,
                                         Buffer, BufferChars);
                break;
            }

            Struct++;
        }
    }
    else if (Flags == DEBUG_KNOWN_STRUCT_SUPPRESS_TYPE_NAME)
    {
        //
        // Determine if formatting method suppresses the type name.
        //

        Status = E_NOINTERFACE;
        while (Struct && Struct->TypeName)
        {
            if (!strcmp(TypeName, Struct->TypeName))
            {
                Status = Struct->SuppressesTypeName ? S_OK : S_FALSE;
                break;
            }

            Struct++;
        }
    }
    else
    {
        Status = E_INVALIDARG;
    }

    return Status;
}

HRESULT WINAPI
ExtExtension::HandleQueryValueNames(_In_ PDEBUG_CLIENT Client,
                                    _In_ ULONG Flags,
                                    _Out_writes_(BufferChars) PWSTR Buffer,
                                    _In_ ULONG BufferChars,
                                    _Out_ PULONG BufferNeeded)
{
    HRESULT Status;

    UNREFERENCED_PARAMETER(Client);
    UNREFERENCED_PARAMETER(Flags);

    if (Buffer == NULL ||
        BufferChars < 1)
    {
        return E_INVALIDARG;
    }
    
    ExtProvidedValue* ExtVal = m_ProvidedValues;
    ULONG CharsNeeded;
        
    //
    // Return names of values packed in
    // the output buffer.
    //

    // Save a character for the double terminator.
    BufferChars--;
    CharsNeeded = 1;

    Status = S_OK;
    while (ExtVal && ExtVal->ValueName)
    {
        ULONG Chars = (ULONG)wcslen(ExtVal->ValueName) + 1;
        CharsNeeded += Chars;
            
        if (Status != S_OK || BufferChars < Chars)
        {
            Status = S_FALSE;
        }
        else
        {
            memcpy(Buffer, ExtVal->ValueName, Chars * sizeof(*Buffer));
            Buffer += Chars;
            BufferChars -= Chars;
        }
            
        ExtVal++;
    }

    *Buffer = 0;
    *BufferNeeded = CharsNeeded;

    return Status;
}

HRESULT WINAPI
ExtExtension::CallProvideValueMethod(_In_ ExtProvidedValue* ExtVal,
                                     _In_ ULONG Flags,
                                     _Out_ PULONG64 Value,
                                     _Out_ PULONG64 TypeModBase,
                                     _Out_ PULONG TypeId,
                                     _Out_ PULONG TypeFlags)
{
    HRESULT Status;
    
    try
    {
        ExInitialize();
        
        m_CallStatus = S_OK;

        (this->*ExtVal->Method)(Flags, ExtVal->ValueName,
                                Value, TypeModBase, TypeId, TypeFlags);

        Status = m_CallStatus;
    }
    catch(ExtException Ex)
    {
        Status = Ex.GetStatus();
    }

    return Status;
}

HRESULT WINAPI
ExtExtension::HandleProvideValue(_In_ PDEBUG_CLIENT Client,
                                 _In_ ULONG Flags,
                                 _In_ PCWSTR Name,
                                 _Out_ PULONG64 Value,
                                 _Out_ PULONG64 TypeModBase,
                                 _Out_ PULONG TypeId,
                                 _Out_ PULONG TypeFlags)
{
    HRESULT Status = Query(Client);
    if (Status != S_OK)
    {
        return Status;
    }

    // Use a hard SEH try/finally to guarantee that
    // Release always occurs.
    __try
    {
        ExtProvidedValue* ExtVal = m_ProvidedValues;
        while (ExtVal && ExtVal->ValueName)
        {
            if (wcscmp(Name, ExtVal->ValueName) == 0)
            {
                break;
            }

            ExtVal++;
        }
        if (!ExtVal)
        {
            Status = E_UNEXPECTED;
        }
        else
        {
            Status = CallProvideValueMethod(ExtVal, Flags,
                                            Value, TypeModBase,
                                            TypeId, TypeFlags);
        }
    }
    __finally
    {
        Release();
    }

    return Status;
}

ExtExtension::ArgVal* WINAPI
ExtExtension::FindArg(_In_ PCSTR Name,
                      _In_ bool Required)
{
    ULONG i;

    for (i = m_FirstNamedArg; i < m_FirstNamedArg + m_NumNamedArgs; i++)
    {
        if (!strcmp(Name, m_Args[i].Name))
        {
            return &m_Args[i];
        }
    }

    if (Required)
    {
        ThrowInvalidArg("No argument /%s was provided", Name);
    }
    
    return NULL;
}

PCSTR WINAPI
ExtExtension::SetRawArgVal(_In_ ExtCommandDesc::ArgDesc* Check,
                           _In_opt_ ArgVal* Val,
                           _In_ bool ExplicitVal,
                           _In_opt_ PCSTR StrVal,
                           _In_ bool StrWritable,
                           _In_ ULONG64 NumVal)
{
    if (!Val)
    {
        if (Check->Name)
        {
            if (m_NumNamedArgs + m_FirstNamedArg >= EXT_DIMA(m_Args))
            {
                ThrowInvalidArg("Argument overflow on '%s'",
                                Check->Name);
            }

            Val = &m_Args[m_NumNamedArgs + m_FirstNamedArg];
            m_NumArgs++;
            m_NumNamedArgs++;
        }
        else
        {
            Val = &m_Args[m_NumUnnamedArgs];
            m_NumArgs++;
            m_NumUnnamedArgs++;
        }
    }

    Check->Present = true;
    Val->Name = Check->Name;
    Val->StrVal = NULL;
    Val->NumVal = 0;

    if (Check->Boolean)
    {
        return StrVal;
    }

    if (StrVal)
    {
        while (IsSpace(*StrVal))
        {
            StrVal++;
        }
        if (!*StrVal &&
            !ExplicitVal)
        {
            ThrowInvalidArg("Missing value for argument '%s'",
                            Check->Name);
        }

        if (Check->String)
        {
            if (strchr("+/-", *StrVal) == NULL) // check if it is an argument.
            {
                Val->StrVal = StrVal;
                if (Check->StringRemainder)
                {
                    StrVal += strlen(StrVal);
                }
                else
                {
                    while (*StrVal && !IsSpace(*StrVal))
                    {
                        StrVal++;
                    }
                }
            }
            else
            {
                Val->StrVal = "";
                return --StrVal;
            }
        }
        else if (Check->Expression)
        {
            PSTR StrEnd = NULL;
            char StrEndChar = 0;
            
            if (Check->ExpressionDelimited)
            {
                StrEnd = (PSTR)StrVal;
                while (*StrEnd && !IsSpace(*StrEnd))
                {
                    StrEnd++;
                }
                if (IsSpace(*StrEnd))
                {
                    //
                    // We found some trailing text so we need
                    // to force a terminator to delimit the
                    // expression.  We can only do this if
                    // we make a copy of the string or have
                    // a writable string.  As any case where a
                    // non-writable string is passed in involves
                    // a caller setting an argument explicitly they
                    // can provide a properly-terminated expression,
                    // so don't support copying.
                    //
                    
                    if (!StrWritable)
                    {
                        ThrowInvalidArg("Delimited expressions can "
                                        "only be parsed from extension "
                                        "command arguments");
                    }

                    StrEndChar = *StrEnd;
                    *StrEnd = 0;
                }
                else
                {
                    // No trailing text so no need to force
                    // termination.
                    StrEnd = NULL;
                }
            }

            ExtRadixHolder HoldRadix;
            
            if (Check->ExpressionRadix != 0)
            {
                HoldRadix.Refresh();
                EXT_STATUS(m_Control->SetRadix(Check->ExpressionRadix));
            }

            if (Check->ExpressionEvaluator != NULL)
            {
                StrVal = PrintCircleString("@@%s(%s)",
                                           Check->ExpressionEvaluator,
                                           StrVal);
            }
            
            StrVal = GetExpr64(StrVal,
                               Check->ExpressionSigned != 0,
                               (0xffffffffffffffffUI64 >>
                                (64 - Check->ExpressionBits)),
                               &Val->NumVal);

            if (StrEnd)
            {
                *StrEnd = StrEndChar;
            }
        }
    }
    else if (Check->String)
    {
        ThrowInvalidArg("Missing value for argument '%s'",
                        Check->Name);
    }
    else
    {
        Val->NumVal = NumVal;
    }

    return StrVal;
}

void WINAPI
ExtExtension::ParseArgs(_In_ ExtCommandDesc* Desc,
                        _In_opt_ PCSTR Args)
{
    if (!Args)
    {
        Args = "";
    }

    m_RawArgStr = Args;
    m_NumArgs = 0;
    m_NumNamedArgs = 0;
    m_NumUnnamedArgs = 0;
    m_FirstNamedArg = Desc->m_NumUnnamedArgs;

    //
    // First make a copy of the argument string as
    // we will need to chop it up when parsing.
    // Release() automatically cleans this up.
    //

    m_ArgCopy = _strdup(Args);
    if (!m_ArgCopy)
    {
        ThrowOutOfMemory();
    }

    if (Desc->m_CustomArgParsing)
    {
        return;
    }
    
    PSTR Scan = m_ArgCopy;
    bool ImplicitNamedArg = false;
    ULONG i;
    ExtCommandDesc::ArgDesc* Check;
    
    Check = Desc->m_Args;
    for (i = 0; i < Desc->m_NumArgs; i++, Check++)
    {
        Check->Present = false;
    }

    for (;;)
    {
        while (IsSpace(*Scan))
        {
            ImplicitNamedArg = false;
            Scan++;
        }
        if (!*Scan)
        {
            break;
        }

        if (ImplicitNamedArg ||
            strchr(Desc->m_OptionChars, *Scan) != NULL)
        {
            //
            // Named argument.  Collect name and
            // see if this is a valid argument.
            //

            if (!ImplicitNamedArg)
            {
                Scan++;

                // If /? is given at any point immediately
                // go help for the command and exit.
                if (*Scan == '?' &&
                    (!*(Scan + 1) || IsSpace(*(Scan + 1))))
                {
                    HelpCommand(Desc);
                    throw ExtStatusException(S_OK);
                }
            }
            
            PSTR Start = Scan++;
            while (*Scan && !IsSpace(*Scan))
            {
                Scan++;
            }
            char Save = *Scan;
            *Scan = 0;

            //
            // First check for a full name match.
            //

            if (!ImplicitNamedArg)
            {
                Check = Desc->m_Args;
                for (i = 0; i < Desc->m_NumArgs; i++, Check++)
                {
                    if (!Check->Name)
                    {
                        continue;
                    }

                    if (!strcmp(Start, Check->Name))
                    {
                        break;
                    }
                }
            }
            else
            {
                i = Desc->m_NumArgs;
            }
            if (i >= Desc->m_NumArgs)
            {
                //
                // Didn't find it with a full name match,
                // so check for a single-character match.
                // This is only allowed for single-character
                // boolean options.
                //

                ImplicitNamedArg = false;

                Check = Desc->m_Args;
                for (i = 0; i < Desc->m_NumArgs; i++, Check++)
                {
                    if (!Check->Name ||
                        !Check->Boolean)
                    {
                        continue;
                    }
                
                    if (*Start == Check->Name[0] &&
                        !Check->Name[1])
                    {
                        // Multiple single-character options
                        // can be combined with a single slash,
                        // so the next character should be
                        // checked as a named option.
                        ImplicitNamedArg = true;
                        break;
                    }
                }
            }
            if (i >= Desc->m_NumArgs)
            {
                ThrowInvalidArg("Unrecognized argument '%s'",
                                Start);
            }

            //
            // Found the argument.  Validate it.
            //

            if (Check->Present)
            {
                ThrowInvalidArg("Duplicate argument '%s'",
                                Start);
            }
            
            //
            // Argument is valid, fix up the scan string
            // and move to value processing.
            //
            
            *Scan = Save;
            if (ImplicitNamedArg)
            {
                Scan = Start + 1;
            }
        }
        else
        {
            //
            // Unnamed argument.
            // Find the n'th unnamed argument description
            // and use it.
            //

            Check = Desc->FindUnnamedArg(m_NumUnnamedArgs);
            if (! Check)
            {
                ThrowInvalidArg("Extra unnamed argument at '%s'",
                                Scan);
            }
        }

        //
        // We have an argument description, so
        // look for any appropriate value.
        //
        Scan = (PSTR)SetRawArgVal(Check, NULL, true, Scan, true, 0);
        if (Check->String && Scan && *Scan)
        {
            *Scan++ = 0;
        }
    }

    //
    // Fill in default values where needed.
    //
    
    Check = Desc->m_Args;
    for (i = 0; i < Desc->m_NumArgs; i++, Check++)
    {
        if (!Check->Present &&
            Check->Default)
        {
            SetRawArgVal(Check, NULL, true, Check->Default, false, 0);
        }
    }

    //
    // Verify that all required arguments are present.
    //

    ULONG NumUnPresent = 0;
    Check = Desc->m_Args;
    for (i = 0; i < Desc->m_NumArgs; i++, Check++)
    {
        if (!Check->Name)
        {
            NumUnPresent++;
        }
        
        if (Check->Required &&
            !Check->Present)
        {
            if (Check->Name)
            {
                ThrowInvalidArg("Missing required argument '%s'",
                                Check->Name);
            }
            else if (Check->DescShort)
            {
                ThrowInvalidArg("Missing required argument '<%s>'",
                                Check->DescShort);
            }
            else
            {
                ThrowInvalidArg("Missing unnamed argument %u",
                                NumUnPresent);
            }
        }
    }
}

void WINAPI
ExtExtension::OutCommandArg(_In_ ExtCommandDesc::ArgDesc* Arg,
                            _In_ bool Separate)
{
    if (Arg->Name)
    {
        if (Separate)
        {
            OutWrapStr("/");
        }
        
        OutWrapStr(Arg->Name);

        if (!Arg->Boolean)
        {
            OutWrapStr(" ");
        }
    }

    if (!Arg->Boolean)
    {
        OutWrap("<%s>", Arg->DescShort);
    }
}

void WINAPI
ExtExtension::HelpCommandArgsSummary(_In_ ExtCommandDesc* Desc)
{
    ULONG i;
    ExtCommandDesc::ArgDesc* Arg;
    bool Hit;

    if (Desc->m_CustomArgDescShort)
    {
        OutWrapStr(Desc->m_CustomArgDescShort);
        return;
    }
    
    //
    // In order to try and make things pretty we make
    // several passes over the arguments.
    //

    //
    // Display all optional single-char booleans as a collection.
    //

    Hit = false;
    Arg = Desc->m_Args;
    for (i = 0; i < Desc->m_NumArgs; i++, Arg++)
    {
        if (Arg->Boolean && !Arg->Required && !Arg->Name[1])
        {
            if (!Hit)
            {
                OutWrapStr(" [/");
                Hit = true;
                AllowWrap(false);
            }

            OutWrapStr(Arg->Name);
        }
    }
    if (Hit)
    {
        OutWrapStr("]");
        AllowWrap(true);
    }
    
    //
    // Display all optional multi-char booleans.
    //

    Arg = Desc->m_Args;
    for (i = 0; i < Desc->m_NumArgs; i++, Arg++)
    {
        if (Arg->Boolean && !Arg->Required && Arg->Name[1])
        {
            OutWrap(" [/%s]", Arg->Name);
        }
    }
    
    //
    // Display all required single-char booleans as a collection.
    //

    Hit = false;
    Arg = Desc->m_Args;
    for (i = 0; i < Desc->m_NumArgs; i++, Arg++)
    {
        if (Arg->Boolean && Arg->Required && !Arg->Name[1])
        {
            if (!Hit)
            {
                OutWrapStr(" /");
                Hit = true;
                AllowWrap(false);
            }

            OutWrapStr(Arg->Name);
        }
    }
    AllowWrap(true);

    //
    // Display all required multi-char booleans.
    //

    Arg = Desc->m_Args;
    for (i = 0; i < Desc->m_NumArgs; i++, Arg++)
    {
        if (Arg->Boolean && Arg->Required && Arg->Name[1])
        {
            OutWrap(" /%s", Arg->Name);
        }
    }

    //
    // Display all optional named non-booleans.
    //

    Arg = Desc->m_Args;
    for (i = 0; i < Desc->m_NumArgs; i++, Arg++)
    {
        if (!Arg->Boolean && !Arg->Required && Arg->Name)
        {
            TestWrap(true);
            OutCommandArg(Arg, true);
            TestWrap(false);
            if (!DemandWrap(m_TestWrapChars + 3))
            {
                OutWrapStr(" ");
            }
            OutWrapStr("[");
            AllowWrap(false);
            OutCommandArg(Arg, true);
            OutWrapStr("]");
            AllowWrap(true);
        }
    }

    //
    // Display all required named non-booleans.
    //

    Arg = Desc->m_Args;
    for (i = 0; i < Desc->m_NumArgs; i++, Arg++)
    {
        if (!Arg->Boolean && Arg->Required && Arg->Name)
        {
            TestWrap(true);
            OutCommandArg(Arg, true);
            TestWrap(false);
            if (!DemandWrap(m_TestWrapChars + 1))
            {
                OutWrapStr(" ");
            }
            AllowWrap(false);
            OutCommandArg(Arg, true);
            AllowWrap(true);
        }
    }

    //
    // Display all unnamed arguments.  As any optional
    // unnamed argument must be last we can handle both
    // optional and required in a single pass.
    //

    Arg = Desc->m_Args;
    for (i = 0; i < Desc->m_NumArgs; i++, Arg++)
    {
        if (!Arg->Boolean && !Arg->Name)
        {
            TestWrap(true);
            OutCommandArg(Arg, true);
            TestWrap(false);
            if (!Arg->Required)
            {
                m_TestWrapChars += 2;
            }
            if (!DemandWrap(m_TestWrapChars + 1))
            {
                OutWrapStr(" ");
            }
            if (!Arg->Required)
            {
                OutWrapStr("[");
            }
            AllowWrap(false);
            OutCommandArg(Arg, true);
            if (!Arg->Required)
            {
                OutWrapStr("]");
            }
            AllowWrap(true);
        }
    }
}

void WINAPI
ExtExtension::OutArgDescOptions(_In_ ExtCommandDesc::ArgDesc* Arg)
{
    bool First = true;
    
    if (Arg->Default &&
        !Arg->DefaultSilent)
    {
        OutWrapStr("defaults to ");
        OutWrapStr(Arg->Default);
        First = false;
    }

    if (Arg->Expression)
    {
        if (Arg->ExpressionSigned)
        {
            if (!First)
            {
                OutWrapStr(", ");
            }
            
            OutWrapStr("signed");
            First = false;
        }
        if (Arg->ExpressionDelimited)
        {
            if (!First)
            {
                OutWrapStr(", ");
            }
            
            OutWrapStr("space-delimited");
            First = false;
        }
        if (Arg->ExpressionBits != 64)
        {
            if (!First)
            {
                OutWrapStr(", ");
            }
            
            OutWrap("%u-bit max", Arg->ExpressionBits);
            First = false;
        }
        if (Arg->ExpressionRadix)
        {
            if (!First)
            {
                OutWrapStr(", ");
            }
            
            OutWrap("base %u", Arg->ExpressionRadix);
            First = false;
        }
        if (Arg->ExpressionEvaluator)
        {
            if (!First)
            {
                OutWrapStr(", ");
            }
            
            OutWrapStr(Arg->ExpressionEvaluator);
            OutWrapStr(" syntax");
            First = false;
        }
    }

    if (Arg->String)
    {
        if (Arg->StringRemainder)
        {
            if (!First)
            {
                OutWrapStr(", ");
            }
            
            OutWrapStr("consumes remainder of input string");
            First = false;
        }
    }
}

void WINAPI
ExtExtension::HelpCommand(_In_ ExtCommandDesc* Desc)
{
    ULONG i;

    Desc->ExInitialize(this);
    
    m_CurChar = 0;
    OutWrap("!%s", Desc->m_Name);
    m_LeftIndent = m_CurChar + 1;
    HelpCommandArgsSummary(Desc);
    m_LeftIndent = 0;
    OutWrapStr("\n");

    if (Desc->m_CustomArgDescLong)
    {
        OutWrapStr("  ");
        m_LeftIndent = m_CurChar;
        OutWrapStr(Desc->m_CustomArgDescLong);
        m_LeftIndent = 0;
        OutWrapStr("\n");
    }
    else
    {
        ExtCommandDesc::ArgDesc* Arg = Desc->m_Args;
        for (i = 0; i < Desc->m_NumArgs; i++)
        {
            OutWrapStr("  ");
            OutCommandArg(Arg, true);
            
            if (Arg->DescLong)
            {
                OutWrapStr(" - ");
                m_LeftIndent = m_CurChar;
                
                OutWrapStr(Arg->DescLong);

                if (Arg->NeedsOptionsOutput())
                {
                    OutWrapStr(" (");
                    OutArgDescOptions(Arg);
                    OutWrapStr(")");
                }
            }
            else if (Arg->NeedsOptionsOutput())
            {
                OutWrapStr(" - ");
                m_LeftIndent = m_CurChar;
                OutArgDescOptions(Arg);
            }
            
            m_LeftIndent = 0;
            OutWrapStr("\n");
            Arg++;
        }
    }
    
    OutWrapStr(Desc->m_Desc);
    Out("\n");
}

void WINAPI
ExtExtension::HelpCommandName(_In_ PCSTR Name)
{
    ExtCommandDesc* Desc = m_Commands;
    while (Desc)
    {
        if (!strcmp(Name, Desc->m_Name))
        {
            break;
        }

        Desc = Desc->m_Next;
    }
    if (!Desc)
    {
        ThrowInvalidArg("No command named '%s'", Name);
    }

    HelpCommand(Desc);
}

void WINAPI
ExtExtension::HelpAll(void)
{
    char ModName[2 * MAX_PATH];

    if (!GetModuleFileName(s_Module, ModName, EXT_DIMA(ModName)))
    {
        StringCbCopyA(ModName, sizeof(ModName),
                      "<Unable to get DLL name>");
    }

    Out("Commands for %s:\n", ModName);
    m_CurChar = 0;
    
    ExtCommandDesc* Desc = m_Commands;
    while (Desc)
    {
        ULONG NameLen = (ULONG)strlen(Desc->m_Name);
        OutWrap("  !%s%*c- ",
                Desc->m_Name,
                m_LongestCommandName - NameLen + 1, ' ');
        m_LeftIndent = m_CurChar;
        OutWrapStr(Desc->m_Desc);
        m_LeftIndent = 0;

        OutWrapStr("\n");

        Desc = Desc->m_Next;
    }

    Out("!help <cmd> will give more information for a particular command\n");
}

EXT_CLASS_COMMAND(ExtExtension,
                  help,
                  "Displays information on available extension commands",
                  "{;s,o;command;Command to get information on}")
{
    if (HasUnnamedArg(0))
    {
        HelpCommandName(GetUnnamedArgStr(0));
    }
    else
    {
        HelpAll();
        SetCallStatus(DEBUG_EXTENSION_CONTINUE_SEARCH);
    }
}

//----------------------------------------------------------------------------
//
// Global forwarders for common methods.
//
//----------------------------------------------------------------------------

void WINAPIV
ExtOut(_In_ PCSTR Format, ...)
{
    g_Ext.Throw();

    va_list Args;

    va_start(Args, Format);
    g_Ext->m_Control->
        OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

void WINAPIV
ExtWarn(_In_ PCSTR Format, ...)
{
    g_Ext.Throw();

    va_list Args;

    va_start(Args, Format);
    g_Ext->m_Control->
        OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

void WINAPIV
ExtErr(_In_ PCSTR Format, ...)
{
    g_Ext.Throw();

    va_list Args;

    va_start(Args, Format);
    g_Ext->m_Control->
        OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

void WINAPIV
ExtVerb(_In_ PCSTR Format, ...)
{
    g_Ext.Throw();

    va_list Args;

    va_start(Args, Format);
    g_Ext->m_Control->
        OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}

//----------------------------------------------------------------------------
//
// ExtRemoteData.
//
//----------------------------------------------------------------------------

void WINAPI
ExtRemoteData::Set(_In_ const DEBUG_TYPED_DATA* Typed)
{
    m_Offset = Typed->Offset;
    m_ValidOffset = (Typed->Flags & DEBUG_TYPED_DATA_IS_IN_MEMORY) != 0;
    m_Bytes = Typed->Size;
    m_Data = Typed->Data;
    m_ValidData = Typed->Size > 0 && Typed->Size <= sizeof(m_Data);
}

void WINAPI
ExtRemoteData::Read(void)
{
    g_Ext->ThrowInterrupt();
    
    // Zero data so that unread bytes have a known state.
    ULONG64 NewData = 0;

#pragma prefast(suppress:__WARNING_REDUNDANTTEST, "valid redundancy")
    if (m_Bytes > sizeof(m_Data) ||
        m_Bytes > sizeof(NewData))
    {
        g_Ext->ThrowRemote(E_INVALIDARG,
                           "ExtRemoteData::Read too large");
    }

    ReadBuffer(&NewData, m_Bytes);
    m_Data = NewData;
    m_ValidData = true;
}

void WINAPI
ExtRemoteData::Write(void)
{
    g_Ext->ThrowInterrupt();
    
    if (m_Bytes > sizeof(m_Data))
    {
        g_Ext->ThrowRemote(E_INVALIDARG,
                           "ExtRemoteData::Write too large");
    }
    if (!m_ValidData)
    {
        g_Ext->ThrowRemote(E_INVALIDARG,
                           "ExtRemoteData does not have valid data");
    }

    WriteBuffer(&m_Data, m_Bytes);
}

ULONG64 WINAPI
ExtRemoteData::GetData(_In_ ULONG Request)
{
    g_Ext->ThrowInterrupt();
    
    if (m_Bytes != Request)
    {
        g_Ext->ThrowRemote(E_INVALIDARG,
            "Invalid ExtRemoteData size (m_Offset = 0x%I64X, m_Bytes = %d, Request = %d)", m_Offset, m_Bytes, Request);
    }
    if (!m_ValidData)
    {
        g_Ext->ThrowRemote(E_INVALIDARG,
                           "ExtRemoteData does not have valid data");
    }

    return m_Data;
}

void WINAPI
ExtRemoteData::SetData(_In_ ULONG64 Data,
                       _In_ ULONG Request,
                       _In_ bool NoWrite) throw(...)
{
    g_Ext->ThrowInterrupt();
    
    if (m_Bytes != Request)
    {
        g_Ext->ThrowRemote(E_INVALIDARG,
                           "Invalid ExtRemoteData size");
    }

    m_Data = Data;
    m_ValidData = true;

    if (!NoWrite)
    {
        Write();
    }
}

ULONG WINAPI
ExtRemoteData::ReadBuffer(_Out_writes_bytes_(Bytes) PVOID Buffer,
                          _In_ ULONG Bytes,
                          _In_ bool MustReadAll)
{
    HRESULT Status;
    ULONG Done;

    g_Ext->ThrowInterrupt();
    
    if (!Bytes)
    {
        g_Ext->ThrowRemote(E_INVALIDARG,
                           "Zero-sized ExtRemoteData");
    }
    if (!m_ValidOffset)
    {
        g_Ext->ThrowRemote(E_INVALIDARG,
                           "ExtRemoteData does not have a valid address");
    }

    if (m_Physical)
    {
        Status = g_Ext->m_Data4->
            ReadPhysical2(m_Offset, m_SpaceFlags, Buffer, Bytes, &Done);
    }
    else
    {
        Status = g_Ext->m_Data->
            ReadVirtual(m_Offset, Buffer, Bytes, &Done);
    }
    if (Status == S_OK && Done != Bytes && MustReadAll)
    {
        Status = HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }
    if (Status != S_OK)
    {
        if (m_Name)
        {
            g_Ext->ThrowRemote(Status, "Unable to read %s at %p",
                               m_Name, m_Offset);
        }
        else
        {
            g_Ext->ThrowRemote(Status, "Unable to read 0x%x bytes at %p",
                               Bytes, m_Offset);
        }
    }

    return Done;
}

ULONG WINAPI
ExtRemoteData::WriteBuffer(_In_reads_bytes_(Bytes) PVOID Buffer,
                           _In_ ULONG Bytes,
                           _In_ bool MustWriteAll)
{
    HRESULT Status;
    ULONG Done;

    UNREFERENCED_PARAMETER(Buffer);

    g_Ext->ThrowInterrupt();

    if (!Bytes)
    {
        g_Ext->ThrowRemote(E_INVALIDARG,
                           "Zero-sized ExtRemoteData");
    }
    if (!m_ValidOffset)
    {
        g_Ext->ThrowRemote(E_INVALIDARG,
                           "ExtRemoteData does not have a valid address");
    }

    if (m_Physical)
    {
        Status = g_Ext->m_Data4->
            WritePhysical2(m_Offset, m_SpaceFlags, Buffer, Bytes, &Done);
    }
    else
    {
        Status = g_Ext->m_Data->
            WriteVirtual(m_Offset, Buffer, Bytes, &Done);
    }
    if (Status == S_OK && Done != Bytes && MustWriteAll)
    {
        Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
    }
    if (Status != S_OK)
    {
        if (m_Name)
        {
            g_Ext->ThrowRemote(Status, "Unable to write %s at %p",
                               m_Name, m_Offset);
        }
        else
        {
            g_Ext->ThrowRemote(Status, "Unable to write 0x%x bytes at %p",
                               Bytes, m_Offset);
        }
    }

    return Done;
}

PSTR WINAPI
ExtRemoteData::GetString(_Out_writes_opt_(BufferChars) PSTR Buffer,
                         _In_ ULONG BufferChars,
                         _In_ ULONG MaxChars,
                         _In_ bool MustFit,
                         _Out_opt_ PULONG NeedChars)
{
    HRESULT Status;
    
    g_Ext->ThrowInterrupt();
    
    if (!m_ValidOffset)
    {
        g_Ext->ThrowRemote(E_INVALIDARG,
                           "ExtRemoteData does not have a valid address");
    }
    if (m_Physical)
    {
        g_Ext->ThrowRemote(E_NOTIMPL,
                           "ExtRemoteData cannot read strings "
                           "from physical memory");
    }

    ULONG Need;
    
    if (FAILED(Status = g_Ext->m_Data4->
               ReadMultiByteStringVirtual(m_Offset, MaxChars * sizeof(*Buffer),
                                          Buffer, BufferChars, &Need)))
    {
        g_Ext->ThrowRemote(Status, "Unable to read string at %p",
                           m_Offset);
    }
    if (Status != S_OK && MustFit)
    {
        g_Ext->ThrowRemote(HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW),
            "(%s): String at %p overflows buffer, need 0x%x chars",
            __FUNCTION__, m_Offset, Need);
    }

    if (NeedChars)
    {
        *NeedChars = Need;
    }
    return Buffer;
}

PWSTR WINAPI
ExtRemoteData::GetString(_Out_writes_opt_(BufferChars) PWSTR Buffer,
                         _In_ ULONG BufferChars,
                         _In_ ULONG MaxChars,
                         _In_ bool MustFit,
                         _Out_opt_ PULONG NeedChars)
{
    HRESULT Status;
    
    g_Ext->ThrowInterrupt();
    
    if (!m_ValidOffset)
    {
        g_Ext->ThrowRemote(E_INVALIDARG,
                           "ExtRemoteData does not have a valid address");
    }
    if (m_Physical)
    {
        g_Ext->ThrowRemote(E_NOTIMPL,
                           "ExtRemoteData cannot read strings "
                           "from physical memory");
    }

    ULONG Need;
    
    if (FAILED(Status = g_Ext->m_Data4->
               ReadUnicodeStringVirtualWide(m_Offset,
                                            MaxChars * sizeof(*Buffer),
                                            Buffer, BufferChars, &Need)))
    {
        g_Ext->ThrowRemote(Status, "Unable to read string at %p",
                           m_Offset);
    }
    if (Status != S_OK && MustFit)
    {
        g_Ext->ThrowRemote(HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW),
                           "String at %p overflows buffer, need 0x%x chars",
                           m_Offset, Need);
    }

    if (NeedChars)
    {
        *NeedChars = Need;
    }
    return Buffer;
}

PSTR WINAPI
ExtRemoteData::GetString(_Inout_ ExtBuffer<char>* Buffer,
                         _In_ ULONG MaxChars)
{
    ULONG Need;

    for (ULONG i = 0; i < 2; i++)
    {
        GetString(Buffer->GetRawBuffer(),
                  Buffer->GetEltsAlloc(),
                  MaxChars,
                  false,
                  &Need);
        if (Need <= Buffer->GetEltsAlloc())
        {
            Buffer->SetEltsUsed(Need);
            return Buffer->GetBuffer();
        }

        Buffer->Require(Need);
    }

    g_Ext->ThrowRemote(E_INVALIDARG, "Unable to read string at %p",
                       m_Offset);
}

PWSTR WINAPI
ExtRemoteData::GetString(_Inout_ ExtBuffer<WCHAR>* Buffer,
                         _In_ ULONG MaxChars)
{
    ULONG Need;

    for (ULONG i = 0; i < 2; i++)
    {
        GetString(Buffer->GetRawBuffer(),
                  Buffer->GetEltsAlloc(),
                  MaxChars,
                  false,
                  &Need);
        if (Need <= Buffer->GetEltsAlloc())
        {
            Buffer->SetEltsUsed(Need);
            return Buffer->GetBuffer();
        }

        Buffer->Require(Need);
    }

    g_Ext->ThrowRemote(E_INVALIDARG, "Unable to read string at %p",
                       m_Offset);
}

//----------------------------------------------------------------------------
//
// ExtRemoteTyped.
//
//----------------------------------------------------------------------------

void WINAPI
ExtRemoteTyped::Copy(_In_ const DEBUG_TYPED_DATA* Source)
{
    m_Typed = *Source;
    ErtIoctl("Copy", EXT_TDOP_COPY, ErtUncheckedIn | ErtOut);
}

void WINAPI
ExtRemoteTyped::Set(_In_ PCSTR Expr)
{
    EXT_TDOP Op;
    ULONG Flags = ErtOut;
    
    // If we have a valid value let it be used
    // in the expression if desired.
    if (m_Release)
    {
        Op = EXT_TDOP_EVALUATE;
        Flags |= ErtIn;
    }
    else
    {
        Op = EXT_TDOP_SET_FROM_EXPR;
    }

    PSTR Msg = g_Ext->
        PrintCircleString("Set: unable to evaluate '%s'", Expr);
    ErtIoctl(Msg, Op, Flags, Expr);
}

void WINAPI
ExtRemoteTyped::Set(_In_ PCSTR Expr,
                    _In_ ULONG64 Offset)
{
    m_Typed.Offset = Offset;
    PSTR Msg = g_Ext->
        PrintCircleString("Set: unable to evaluate '%s' for 0x%I64x",
                          Expr, Offset);
    ErtIoctl(Msg, EXT_TDOP_SET_FROM_U64_EXPR, ErtUncheckedIn | ErtOut, Expr);
}

void WINAPI
ExtRemoteTyped::Set(_In_ bool PtrTo,
                    _In_ ULONG64 TypeModBase,
                    _In_ ULONG TypeId,
                    _In_ ULONG64 Offset)
{
    HRESULT Status;
    EXT_TYPED_DATA ExtData;

    g_Ext->ThrowInterrupt();

    ZeroMemory(&ExtData, sizeof(ExtData));
    ExtData.Operation = PtrTo ?
        EXT_TDOP_SET_PTR_FROM_TYPE_ID_AND_U64 :
        EXT_TDOP_SET_FROM_TYPE_ID_AND_U64;
    if (m_Physical)
    {
        ExtData.Flags |= (m_SpaceFlags + 1) << 1;
    }
    ExtData.InData.ModBase = TypeModBase;
    ExtData.InData.TypeId = TypeId;
    ExtData.InData.Offset = Offset;
    
    Status = g_Ext->m_Advanced2->
        Request(DEBUG_REQUEST_EXT_TYPED_DATA_ANSI,
                &ExtData, sizeof(ExtData),
                &ExtData, sizeof(ExtData),
                NULL);
    if (SUCCEEDED(Status))
    {
        Status = ExtData.Status;
    }

    if (FAILED(Status))
    {
        g_Ext->ThrowRemote(Status,
                           "ExtRemoteTyped::Set from type and offset");
    }

    Release();
    m_Typed = ExtData.OutData;
    ExtRemoteData::Set(&m_Typed);
    m_Release = true;
}

void WINAPI
ExtRemoteTyped::Set(_In_ PCSTR Type,
                    _In_ ULONG64 Offset,
                    _In_ bool PtrTo,
                    _Inout_opt_ PULONG64 CacheCookie,
                    _In_opt_ PCSTR LinkField)
{
    HRESULT Status;
    ULONG64 TypeModBase;
    ULONG TypeId;
    
    if (!CacheCookie)
    {
        if ((Status = g_Ext->m_Symbols->
             GetSymbolTypeId(Type, 
                             &TypeId,
                             &TypeModBase)) != S_OK)
        {
            g_Ext->ThrowStatus(Status, "Unable to get type ID of '%s'",
                               Type);
        }
    }
    else
    {
        if (LinkField)
        {
            // We don't really need the field offset
            // here but it allows us to use cache
            // entries that were created for list
            // usage and so do have it.
            g_Ext->GetCachedFieldOffset(CacheCookie,
                                        Type,
                                        LinkField,
                                        &TypeModBase,
                                        &TypeId);
        }
        else
        {
            TypeId = g_Ext->GetCachedSymbolTypeId(CacheCookie,
                                                  Type,
                                                  &TypeModBase);
        }
    }
        
    Set(PtrTo, TypeModBase, TypeId, Offset);
}

void WINAPIV
ExtRemoteTyped::SetPrint(_In_ PCSTR Format,
                         ...)
{
    HRESULT Status;
    va_list Args;
    
    va_start(Args, Format);
    Status = StringCbVPrintfA(g_Ext->s_String, sizeof(g_Ext->s_String),
                              Format, Args);
    va_end(Args);
    if (Status != S_OK)
    {
        g_Ext->ThrowRemote(Status,
                           "ExtRemoteTyped::SetPrint: overflow on '%s'",
                           Format);
    }
    Set(g_Ext->CopyCircleString(g_Ext->s_String));
}

ULONG WINAPI
ExtRemoteTyped::GetFieldOffset(_In_ PCSTR Field) throw(...)
{
    ULONG Offset;
    PSTR Msg = g_Ext->
        PrintCircleString("GetFieldOffset: no field '%s'",
                          Field);
    ErtIoctl(Msg, EXT_TDOP_GET_FIELD_OFFSET, ErtIn, Field, 0, NULL,
             NULL, 0, &Offset);
    return Offset;
}

ExtRemoteTyped WINAPI
ExtRemoteTyped::Field(_In_ PCSTR Field)
{
    ExtRemoteTyped Ret;
    
    PSTR Msg = g_Ext->
        PrintCircleString("Field: unable to retrieve field '%s' at %I64x",
                          Field, m_Offset);
    ErtIoctl(Msg, EXT_TDOP_GET_FIELD, ErtIn | ErtOut, Field, 0, &Ret);
    return Ret;
}

ExtRemoteTyped WINAPI
ExtRemoteTyped::ArrayElement(_In_ LONG64 Index)
{
    ExtRemoteTyped Ret;

    PSTR Msg = g_Ext->
        PrintCircleString("ArrayElement: unable to retrieve element %I64d",
                          Index);
    ErtIoctl(Msg, EXT_TDOP_GET_ARRAY_ELEMENT,
             ErtIn | ErtOut, NULL, Index, &Ret);
    return Ret;
}

ExtRemoteTyped WINAPI
ExtRemoteTyped::Dereference(void)
{
    ExtRemoteTyped Ret;

    ErtIoctl("Dereference", EXT_TDOP_GET_DEREFERENCE,
             ErtIn | ErtOut, NULL, 0, &Ret);
    return Ret;
}

ExtRemoteTyped WINAPI
ExtRemoteTyped::GetPointerTo(void)
{
    ExtRemoteTyped Ret;

    ErtIoctl("GetPointerTo", EXT_TDOP_GET_POINTER_TO,
             ErtIn | ErtOut, NULL, 0, &Ret);
    return Ret;
}

ExtRemoteTyped WINAPI
ExtRemoteTyped::Eval(_In_ PCSTR Expr)
{
    ExtRemoteTyped Ret;
    
    PSTR Msg = g_Ext->
        PrintCircleString("Eval: unable to evaluate '%s'",
                          Expr);
    ErtIoctl(Msg, EXT_TDOP_EVALUATE, ErtIn | ErtOut, Expr, 0, &Ret);
    return Ret;
}

PSTR WINAPI
ExtRemoteTyped::GetTypeName(void)
{
    ErtIoctl("GetTypeName", EXT_TDOP_GET_TYPE_NAME, ErtIn, NULL, 0, NULL,
             g_Ext->s_String, EXT_DIMA(g_Ext->s_String));
    return g_Ext->CopyCircleString(g_Ext->s_String);
}

PSTR WINAPI
ExtRemoteTyped::GetSimpleValue(void)
{
    ExtCaptureOutputA Capture;

    Capture.Start();

    OutSimpleValue();

    Capture.Stop();
    return g_Ext->CopyCircleString(Capture.GetTextNonNull());
}

ULONG WINAPI
ExtRemoteTyped::GetTypeFieldOffset(_In_ PCSTR Type,
                                   _In_ PCSTR Field)
{
    HRESULT Status;
    DEBUG_VALUE Data;
    PSTR Expr;

    Expr = g_Ext->PrintCircleString("@@c++(#FIELD_OFFSET(%s, %s))",
                                    Type, Field);
    if (FAILED(Status = g_Ext->m_Control->
               Evaluate(Expr, DEBUG_VALUE_INT64, &Data, NULL)))
    {
        g_Ext->ThrowRemote(Status,
                           "Could not find type field %s.%s",
                           Type, Field);
    }

    return (ULONG)Data.I64;
}

HRESULT WINAPI
ExtRemoteTyped::ErtIoctl(_In_ PCSTR Message,
                         _In_ EXT_TDOP Op,
                         _In_ ULONG Flags,
                         _In_opt_ PCSTR InStr,
                         _In_ ULONG64 In64,
                         _Out_opt_ ExtRemoteTyped* Ret,
                         _Out_writes_opt_(StrBufferChars) PSTR StrBuffer,
                         _In_ ULONG StrBufferChars,
                         _Out_opt_ PULONG Out32)
{
    HRESULT Status;
    ExtDeclAlignedBuffer<BYTE, sizeof(EXT_TYPED_DATA) +
                               10 * sizeof(ULONG64)> DataHolder;
    EXT_TYPED_DATA* ExtData;
    ULONG ExtDataBytes;
    PBYTE ExtraData;

    C_ASSERT(EXT_TDF_PHYSICAL_MEMORY == DEBUG_TYPED_DATA_PHYSICAL_MEMORY);

    // Check for a user interrupt, but don't do that
    // when we're in a cleanup path since we don't
    // want to prevent orderly shutdown of objects.
    if (Op != EXT_TDOP_RELEASE)
    {
        g_Ext->ThrowInterrupt();
    }

    ExtDataBytes = sizeof(*ExtData) +
        StrBufferChars * sizeof(*StrBuffer);
    if (InStr)
    {
        ExtDataBytes += ((ULONG)strlen(InStr) + 1) * sizeof(*InStr);
    }

    ExtData = (EXT_TYPED_DATA*)DataHolder.Get(ExtDataBytes);
    ExtraData = (PBYTE)(ExtData + 1);
    
    ZeroMemory(ExtData, sizeof(*ExtData));
    ExtData->Operation = Op;
    if (m_Physical)
    {
        ExtData->Flags |= (m_SpaceFlags + 1) << 1;
    }
    if (InStr)
    {
        ExtData->InStrIndex = (ULONG)(ExtraData - (PBYTE)ExtData);
        memcpy(ExtraData, InStr,
               (strlen(InStr) + 1) * sizeof(*InStr));
        ExtraData += (strlen(InStr) + 1) * sizeof(*InStr);
    }
    ExtData->In64 = In64;
    if (StrBuffer)
    {
        ExtData->StrBufferIndex = (ULONG)(ExtraData - (PBYTE)ExtData);
        ExtData->StrBufferChars = StrBufferChars;
        ExtraData += StrBufferChars * sizeof(*StrBuffer);
    }
    
    if ((Flags & (ErtIn | ErtUncheckedIn)) != 0)
    {
        if ((Flags & ErtIn) != 0 && !m_Release)
        {
            g_Ext->ThrowRemote(E_INVALIDARG,
                               "ExtRemoteTyped::%s", Message);
        }

        ExtData->InData = m_Typed;
    }

    Status = g_Ext->m_Advanced2->
        Request(DEBUG_REQUEST_EXT_TYPED_DATA_ANSI,
                ExtData, ExtDataBytes,
                ExtData, ExtDataBytes,
                NULL);
    if (SUCCEEDED(Status))
    {
        Status = ExtData->Status;
    }

    if ((Flags & ErtIgnoreError) == 0 &&
        FAILED(Status))
    {
        g_Ext->ThrowRemote(Status,
                           "ExtRemoteTyped::%s", Message);
    }

    if ((Flags & ErtOut) != 0)
    {
        if (!Ret)
        {
            Ret = this;
        }

        Ret->Release();
        Ret->m_Typed = ExtData->OutData;
        Ret->ExtRemoteData::Set(&Ret->m_Typed);
        Ret->m_Release = true;
    }

    if (StrBuffer)
    {
        memcpy(StrBuffer, (PBYTE)ExtData + ExtData->StrBufferIndex,
               StrBufferChars * sizeof(*StrBuffer));
    }
    
    if (Out32)
    {
        *Out32 = ExtData->Out32;
    }

    return Status;
}

void WINAPI
ExtRemoteTyped::Clear(void)
{
    ZeroMemory(&m_Typed, sizeof(m_Typed));
    m_Release = false;
    ExtRemoteData::Clear();
}

//----------------------------------------------------------------------------
//
// Helpers for handling well-known NT data and types.
//
//----------------------------------------------------------------------------

ULONG64 ExtNtOsInformation::s_KernelLoadedModuleBaseInfoCookie;
ULONG64 ExtNtOsInformation::s_KernelProcessBaseInfoCookie;
ULONG64 ExtNtOsInformation::s_KernelThreadBaseInfoCookie;
ULONG64 ExtNtOsInformation::s_KernelProcessThreadListFieldCookie;
ULONG64 ExtNtOsInformation::s_UserOsLoadedModuleBaseInfoCookie;
ULONG64 ExtNtOsInformation::s_UserAltLoadedModuleBaseInfoCookie;
ULONG64 ExtNtOsInformation::s_OsPebBaseInfoCookie;
ULONG64 ExtNtOsInformation::s_AltPebBaseInfoCookie;
ULONG64 ExtNtOsInformation::s_OsTebBaseInfoCookie;
ULONG64 ExtNtOsInformation::s_AltTebBaseInfoCookie;

ULONG64 WINAPI
ExtNtOsInformation::GetKernelLoadedModuleListHead(void)
{
    return GetNtDebuggerData(DEBUG_DATA_PsLoadedModuleListAddr,
                             "nt!PsLoadedModuleList",
                             0);
}

ExtRemoteTypedList WINAPI
ExtNtOsInformation::GetKernelLoadedModuleList(void)
{
    ExtRemoteTypedList List(GetKernelLoadedModuleListHead(),
                            "nt!_KLDR_DATA_TABLE_ENTRY",
                            "InLoadOrderLinks",
                            0,
                            0,
                            &s_KernelLoadedModuleBaseInfoCookie,
                            true);
    List.m_MaxIter = 1000;
    return List;
}
    
ExtRemoteTyped WINAPI
ExtNtOsInformation::GetKernelLoadedModule(_In_ ULONG64 Offset)
{
    // We are caching both type and link information
    // so provide a link field here to keep the
    // cache properly filled out.
    return ExtRemoteTyped("nt!_KLDR_DATA_TABLE_ENTRY",
                          Offset,
                          true,
                          &s_KernelLoadedModuleBaseInfoCookie,
                          "InLoadOrderLinks");
}

ULONG64 WINAPI
ExtNtOsInformation::GetKernelProcessListHead(void)
{
    return GetNtDebuggerData(DEBUG_DATA_PsActiveProcessHeadAddr,
                             "nt!PsActiveProcessHead",
                             0);
}

ExtRemoteTypedList WINAPI
ExtNtOsInformation::GetKernelProcessList(void)
{
    ExtRemoteTypedList List(GetKernelProcessListHead(),
                            "nt!_EPROCESS",
                            "ActiveProcessLinks",
                            0,
                            0,
                            &s_KernelProcessBaseInfoCookie,
                            true);
    List.m_MaxIter = 4000;
    return List;
}

ExtRemoteTyped WINAPI
ExtNtOsInformation::GetKernelProcess(_In_ ULONG64 Offset)
{
    // We are caching both type and link information
    // so provide a link field here to keep the
    // cache properly filled out.
    return ExtRemoteTyped("nt!_EPROCESS",
                          Offset,
                          true,
                          &s_KernelProcessBaseInfoCookie,
                          "ActiveProcessLinks");
}

ULONG64 WINAPI
ExtNtOsInformation::GetKernelProcessThreadListHead(_In_ ULONG64 Process)
{
    return Process +
        g_Ext->GetCachedFieldOffset(&s_KernelProcessThreadListFieldCookie,
                                    "nt!_EPROCESS",
                                    "Pcb.ThreadListHead");
}

ExtRemoteTypedList WINAPI
ExtNtOsInformation::GetKernelProcessThreadList(_In_ ULONG64 Process)
{
    ExtRemoteTypedList List(GetKernelProcessThreadListHead(Process),
                            "nt!_ETHREAD",
                            "Tcb.ThreadListEntry",
                            0,
                            0,
                            &s_KernelThreadBaseInfoCookie,
                            true);
    List.m_MaxIter = 15000;
    return List;
}

ExtRemoteTyped WINAPI
ExtNtOsInformation::GetKernelThread(_In_ ULONG64 Offset)
{
    // We are caching both type and link information
    // so provide a link field here to keep the
    // cache properly filled out.
    return ExtRemoteTyped("nt!_ETHREAD",
                          Offset,
                          true,
                          &s_KernelThreadBaseInfoCookie,
                          "Tcb.ThreadListEntry");
}

ULONG64 WINAPI
ExtNtOsInformation::GetUserLoadedModuleListHead(_In_ bool NativeOnly)
{
    HRESULT Status;

    if (NativeOnly ||
        !g_Ext->Is32On64())
    {
        DEBUG_VALUE Data;
    
        if (FAILED(Status = g_Ext->m_Control->
                   Evaluate("@@c++(&@$peb->Ldr->InLoadOrderModuleList)",
                            DEBUG_VALUE_INT64, &Data, NULL)))
        {
            g_Ext->ThrowRemote(Status,
                               "Unable to get loader list head from PEB");
        }

        return Data.I64;
    }
    else
    {
        // We're looking at a 32-bit structure so only
        // pull out a 32-bit pointer value.  We do
        // not sign-extend as this is a UM pointer and
        // should not get sign-extended.
        return GetAltPeb().
            Eval("&@$extin->Ldr->InLoadOrderModuleList").GetUlong();
    }
}

ExtRemoteTypedList WINAPI
ExtNtOsInformation::GetUserLoadedModuleList(_In_ bool NativeOnly)
{
    if (NativeOnly ||
        !g_Ext->Is32On64())
    {
        ExtRemoteTypedList List(GetUserLoadedModuleListHead(NativeOnly),
                                "${$ntnsym}!_LDR_DATA_TABLE_ENTRY",
                                "InLoadOrderLinks",
                                0,
                                0,
                                &s_UserOsLoadedModuleBaseInfoCookie,
                                true);
        List.m_MaxIter = 1000;
        return List;
    }
    else
    {
        ExtRemoteTypedList List(GetUserLoadedModuleListHead(NativeOnly),
                                "${$ntwsym}!_LDR_DATA_TABLE_ENTRY",
                                "InLoadOrderLinks",
                                0,
                                0,
                                &s_UserAltLoadedModuleBaseInfoCookie,
                                true);
        List.m_MaxIter = 1000;
        return List;
    }
}

ExtRemoteTyped WINAPI
ExtNtOsInformation::GetUserLoadedModule(_In_ ULONG64 Offset,
                                        _In_ bool NativeOnly)
{
    // We are caching both type and link information
    // so provide a link field here to keep the
    // cache properly filled out.
    if (NativeOnly ||
        !g_Ext->Is32On64())
    {
        return ExtRemoteTyped("${$ntnsym}!_LDR_DATA_TABLE_ENTRY",
                              Offset,
                              true,
                              &s_UserOsLoadedModuleBaseInfoCookie,
                              "InLoadOrderLinks");
    }
    else
    {
        return ExtRemoteTyped("${$ntwsym}!_LDR_DATA_TABLE_ENTRY",
                              Offset,
                              true,
                              &s_UserAltLoadedModuleBaseInfoCookie,
                              "InLoadOrderLinks");
    }
}

ULONG64 WINAPI
ExtNtOsInformation::GetOsPebPtr(void)
{
    HRESULT Status;
    ULONG64 Offset;

    if ((Status = g_Ext->m_System->
         GetCurrentProcessPeb(&Offset)) != S_OK)
    {
        g_Ext->ThrowRemote(Status,
                           "Unable to get OS PEB pointer");
    }

    return Offset;
}

ExtRemoteTyped WINAPI
ExtNtOsInformation::GetOsPeb(_In_ ULONG64 Offset)
{
    return ExtRemoteTyped("${$ntnsym}!_PEB",
                          Offset,
                          true,
                          &s_OsPebBaseInfoCookie);
}

ULONG64 WINAPI
ExtNtOsInformation::GetOsTebPtr(void)
{
    HRESULT Status;
    ULONG64 Offset;

    if ((Status = g_Ext->m_System->
         GetCurrentThreadTeb(&Offset)) != S_OK)
    {
        g_Ext->ThrowRemote(Status,
                           "Unable to get OS TEB pointer");
    }

    return Offset;
}

ExtRemoteTyped WINAPI
ExtNtOsInformation::GetOsTeb(_In_ ULONG64 Offset)
{
    return ExtRemoteTyped("${$ntnsym}!_TEB",
                          Offset,
                          true,
                          &s_OsTebBaseInfoCookie);
}

ULONG64 WINAPI
ExtNtOsInformation::GetAltPebPtr(void)
{
    ExtRemoteTyped AltTeb = GetAltTeb();
    return AltTeb.Field("ProcessEnvironmentBlock").GetUlong();
}

ExtRemoteTyped WINAPI
ExtNtOsInformation::GetAltPeb(_In_ ULONG64 Offset)
{
    return ExtRemoteTyped("${$ntwsym}!_PEB",
                          Offset,
                          true,
                          &s_AltPebBaseInfoCookie);
}

ULONG64 WINAPI
ExtNtOsInformation::GetAltTebPtr(void)
{
    // If this is a 32-bit machine there's no
    // WOW64 TEB.
    if (!g_Ext->IsMachine64(g_Ext->m_ActualMachine))
    {
        g_Ext->ThrowRemote(E_INVALIDARG,
                           "No alternate TEB available");
    }

    //
    // The pointer to the WOW64 TEB is the first pointer of
    // the 64-bit TEB.
    //

    ExtRemoteData OsTeb(GetOsTebPtr(), sizeof(ULONG64));
    return OsTeb.GetUlong64();
}

ExtRemoteTyped WINAPI
ExtNtOsInformation::GetAltTeb(_In_ ULONG64 Offset)
{
    return ExtRemoteTyped("${$ntwsym}!_TEB",
                          Offset,
                          true,
                          &s_AltTebBaseInfoCookie);
}

ULONG64 WINAPI
ExtNtOsInformation::GetCurPebPtr(void)
{
    return g_Ext->Is32On64() ?
        GetAltPebPtr() : GetOsPebPtr();
}

ExtRemoteTyped WINAPI
ExtNtOsInformation::GetCurPeb(_In_ ULONG64 Offset)
{
    return g_Ext->Is32On64() ?
        GetAltPeb(Offset) : GetOsPeb(Offset);
}

ULONG64 WINAPI
ExtNtOsInformation::GetCurTebPtr(void)
{
    return g_Ext->Is32On64() ?
        GetAltTebPtr() : GetOsTebPtr();
}

ExtRemoteTyped WINAPI
ExtNtOsInformation::GetCurTeb(_In_ ULONG64 Offset)
{
    return g_Ext->Is32On64() ?
        GetAltTeb(Offset) : GetOsTeb(Offset);
}
    
ULONG64 WINAPI
ExtNtOsInformation::GetNtDebuggerData(_In_ ULONG DataOffset,
                                      _In_ PCSTR Symbol,
                                      _In_ ULONG Flags)
{
    ULONG64 Data;

    UNREFERENCED_PARAMETER(Flags);

    //
    // First check the kernel's data block.
    //
    
    if (g_Ext->m_Data->
        ReadDebuggerData(DataOffset, &Data, sizeof(Data), NULL) == S_OK)
    {
        return Data;
    }

    //
    // Fall back on symbols.
    //

    if (g_Ext->m_Symbols->
        GetOffsetByName(Symbol, &Data) != S_OK)
    {
        g_Ext->ThrowRemote(E_INVALIDARG,
                           "Unable to find '%s', check your NT kernel symbols",
                           Symbol);
    }

    return Data;
}

//----------------------------------------------------------------------------
//
// Number-to-string helpers for things like #define translations.
//
//----------------------------------------------------------------------------

ExtDefine* WINAPI
ExtDefineMap::Map(_In_ ULONG64 Value)
{
    if ((m_Flags & Bitwise) != 0)
    {
        for (ExtDefine* Define = m_Defines; Define->Name; Define++)
        {
            if ((Define->Value & Value) == Define->Value)
            {
                return Define;
            }
        }
    }
    else
    {
        for (ExtDefine* Define = m_Defines; Define->Name; Define++)
        {
            if (Define->Value == Value)
            {
                return Define;
            }
        }
    }

    return NULL;
}

PCSTR WINAPI
ExtDefineMap::MapStr(_In_ ULONG64 Value,
                     _In_opt_ PCSTR InvalidStr)
{
    ExtDefine* Define = Map(Value);
    if (Define)
    {
        return Define->Name;
    }
    if (InvalidStr)
    {
        return InvalidStr;
    }
    else
    {
        return g_Ext->PrintCircleString("<0x%I64x>", Value);
    }
}

void WINAPI
ExtDefineMap::Out(_In_ ULONG64 Value,
                  _In_ ULONG Flags,
                  _In_opt_ PCSTR InvalidStr)
{
    ULONG OldIndent = g_Ext->m_LeftIndent;
    g_Ext->m_LeftIndent = g_Ext->m_CurChar;

    if ((Flags & OutValue) != 0)
    {
        g_Ext->OutWrap("%I64x", Value);
    }
    else if ((Flags & OutValue32) != 0)
    {
        g_Ext->OutWrap("%08I64x", Value);
    }
    else if ((Flags & OutValue64) != 0)
    {
        g_Ext->OutWrap("%016I64x", Value);
    }
    
    if ((m_Flags & Bitwise) != 0)
    {
        if (!Value)
        {
            if ((Flags & ValueAny) == 0)
            {
                g_Ext->OutWrapStr("<zero>");
            }
        }
        else
        {
            bool First = true;
            
            while (Value)
            {
                ExtDefine* Define = Map(Value);

                if (!Define &&
                    (Flags & ValueAny) != 0 &&
                    !InvalidStr)
                {
                    // Value already displayed.
                    break;
                }
                    
                if (!First)
                {
                    g_Ext->OutWrapStr(" | ");
                }
                else
                {
                    if ((Flags & OutValueAny) != 0)
                    {
                        g_Ext->OutWrapStr(" ");
                    }
                    
                    First = false;
                }
                
                if (Define)
                {
                    g_Ext->OutWrapStr(Define->Name);
                    Value &= ~Define->Value;
                }
                else
                {
                    if (InvalidStr)
                    {
                        g_Ext->OutWrapStr(InvalidStr);
                    }
                    else
                    {
                        g_Ext->OutWrap("<0x%I64x>", Value);
                    }
                    break;
                }
            }
        }
    }
    else
    {
        if ((Flags & ValueAny) == 0 ||
            InvalidStr)
        {
            if ((Flags & OutValueAny) != 0)
            {
                g_Ext->OutWrapStr(" ");
            }
            
            g_Ext->OutWrapStr(MapStr(Value, InvalidStr));
        }
        else
        {
            ExtDefine* Define = Map(Value);
            if (Define)
            {
                InvalidStr = Define->Name;
            }
            if (InvalidStr)
            {
                if ((Flags & OutValueAny) != 0)
                {
                    g_Ext->OutWrapStr(" ");
                }
                
                g_Ext->OutWrapStr(InvalidStr);
            }
        }
    }

    g_Ext->m_LeftIndent = OldIndent;
}

//----------------------------------------------------------------------------
//
// Extension DLL exports.
//
//----------------------------------------------------------------------------

EXTERN_C BOOL WINAPI
DllMain(HANDLE Instance, ULONG Reason, PVOID Reserved)
{
    switch(Reason)
    {
    case DLL_PROCESS_ATTACH:
        ExtExtension::s_Module = (HMODULE)Instance;
        break;
    }

    if (g_ExtDllMain)
    {
        return g_ExtDllMain(Instance, Reason, Reserved);
    }
    
    return TRUE;
}

EXTERN_C HRESULT CALLBACK
DebugExtensionInitialize(_Out_ PULONG Version,
                         _Out_ PULONG Flags)
{
    HRESULT Result;

    Result = g_ExtInstancePtr->BaseInitialize(ExtExtension::s_Module,
                                              Version,
                                              Flags);

    return Result;
}

EXTERN_C void CALLBACK
DebugExtensionUninitialize(void)
{
    if (!g_Ext.IsSet())
    {
        return;
    }

    g_Ext->Uninitialize();
}

EXTERN_C void CALLBACK
DebugExtensionNotify(_In_ ULONG Notify,
                     _In_ ULONG64 Argument)
{
    if (!g_Ext.IsSet())
    {
        return;
    }

    ExtExtension* Inst = g_Ext;

    switch(Notify)
    {
    case DEBUG_NOTIFY_SESSION_ACTIVE:
        Inst->OnSessionActive(Argument);
        break;
    case DEBUG_NOTIFY_SESSION_INACTIVE:
        Inst->OnSessionInactive(Argument);
        break;
    case DEBUG_NOTIFY_SESSION_ACCESSIBLE:
        Inst->OnSessionAccessible(Argument);
        break;
    case DEBUG_NOTIFY_SESSION_INACCESSIBLE:
        Inst->OnSessionInaccessible(Argument);
        break;
    }
}

EXTERN_C HRESULT CALLBACK
KnownStructOutputEx(_In_ PDEBUG_CLIENT Client,
                    _In_ ULONG Flags,
                    _In_ ULONG64 Offset,
                    _In_opt_ PCSTR TypeName,
                    _Out_writes_opt_(*BufferChars) PSTR Buffer,
                    _Inout_opt_ PULONG BufferChars)
{
    if (!g_Ext.IsSet())
    {
        return E_UNEXPECTED;
    }

    return g_Ext->HandleKnownStruct(Client, Flags, Offset, TypeName,
                                    Buffer, BufferChars);
}

EXTERN_C HRESULT CALLBACK
DebugExtensionQueryValueNames(_In_ PDEBUG_CLIENT Client,
                              _In_ ULONG Flags,
                              _Out_writes_(BufferChars) PWSTR Buffer,
                              _In_ ULONG BufferChars,
                              _Out_ PULONG BufferNeeded)
{
    if (!g_Ext.IsSet())
    {
        return E_UNEXPECTED;
    }

    return g_Ext->HandleQueryValueNames(Client, Flags,
                                        Buffer, BufferChars, BufferNeeded);
}

EXTERN_C HRESULT CALLBACK
DebugExtensionProvideValue(_In_ PDEBUG_CLIENT Client,
                           _In_ ULONG Flags,
                           _In_ PCWSTR Name,
                           _Out_ PULONG64 Value,
                           _Out_ PULONG64 TypeModBase,
                           _Out_ PULONG TypeId,
                           _Out_ PULONG TypeFlags)
{
    if (!g_Ext.IsSet())
    {
        return E_UNEXPECTED;
    }

    return g_Ext->HandleProvideValue(Client, Flags, Name,
                                     Value, TypeModBase, TypeId, TypeFlags);
}

```

`SwishDbgExt/engextcpp.hpp`:

```hpp
//----------------------------------------------------------------------------
//
// C++ dbgeng extension framework.
//
// The framework makes it easy to write dbgeng extension
// DLLs by wrapping the inconvenient parts of the extension API.
// Boilerplate code is provided as base implementations,
// removing the need to put in empty or skeleton code.
// Error handling is done via exceptions, removing most
// error path code.
//
// The framework assumes async exception handling compilation.
//
// Copyright (C) Microsoft Corporation, 2005-2009.
//
//----------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __ENGEXTCPP_HPP__
#define __ENGEXTCPP_HPP__

#ifndef __cplusplus
#error engextcpp.hpp requires C++.
#endif

#include <windows.h>
#include <dbgeng.h>
#define KDEXT_64BIT
#include <wdbgexts.h>

#include <pshpack8.h>

#pragma comment(lib,"dbgeng.lib")

#if _MSC_VER >= 800
#pragma warning(disable:4121)
#endif
      
// This will be an engine extension DLL so the wdbgexts
// APIs are not appropriate.
#undef DECLARE_API
#undef DECLARE_API32
#undef DECLARE_API64

//
// If you need to see DllMain-style notifications in
// your extension DLL code you can set this global
// function pointer and the DllMain provided by EngExtCpp
// will pass on all calls it receives.  Declaring a global
// ExtSetDllMain class instance will set the pointer
// prior to the C runtime calling DllMain.
//
// If you are writing a hybrid dbgeng/EngExtCpp extension
// and you want to override the global dbgeng extension
// functions like DebugExtensionInitialize you can do
// so by using .def file renaming of the exports.  For
// example, instead of
//
// EXPORTS
//     DebugEngineInitialize
//
// use
//
// EXPORTS
//     DebugEngineInitialize=MyDebugEngineInitialize
//
// The export will then refer to MyDebugEngineInitialize
// instead of the EngExtCpp-provided DebugEngineInitialize.
// If you do override the provided DebugEngineInitialize you
// must call ExtExtension::BaseInitialize exactly once on
// your EngExtCpp class instance before any use of EngExtCpp
// functionality.
//

typedef BOOL (WINAPI *PEXT_DLL_MAIN)
    (HANDLE Instance, ULONG Reason, PVOID Reserved);

extern PEXT_DLL_MAIN g_ExtDllMain;

class ExtSetDllMain
{
public:
    WINAPI ExtSetDllMain(_In_ PEXT_DLL_MAIN Func)
    {
        g_ExtDllMain = Func;
    }
};

//----------------------------------------------------------------------------
//
// Basic utilities needed later.
//
//----------------------------------------------------------------------------

#define EXT_RELEASE(_Unk) \
    ((_Unk) != NULL ? ((_Unk)->Release(), (void)((_Unk) = NULL)) : (void)NULL)

#define EXT_DIMAT(_Array, _EltType) (sizeof(_Array) / sizeof(_EltType))
#define EXT_DIMA(_Array) EXT_DIMAT(_Array, (_Array)[0])

class ExtExtension;
class ExtCommandDesc;

//----------------------------------------------------------------------------
//
// All errors from this framework are handled by exceptions.
// The exception hierarchy allows various conditions to
// be handled separately, but generally extensions should
// not need to do any exception handling.  The framework
// automatically wraps extensions with try/catch to absorb
// errors properly.
//
//----------------------------------------------------------------------------

class ExtException
{
public:
    ExtException(_In_ HRESULT Status,
                 _In_opt_ PCSTR Message)
    {
        m_Status = Status;
        m_Message = Message;
    }

    HRESULT GetStatus(void) const
    {
        return m_Status;
    }
    HRESULT SetStatus(_In_ HRESULT Status)
    {
        m_Status = Status;
        return Status;
    }
    
    PCSTR GetMessage(void) const
    {
        return m_Message;
    }
    void SetMessage(_In_opt_ PCSTR Message)
    {
        m_Message = Message;
    }
    
    void WINAPI PrintMessageVa(_In_reads_(BufferChars) PSTR Buffer,
                        _In_ ULONG BufferChars,
                        _In_ PCSTR Format,
                        _In_ va_list Args);
    void WINAPIV PrintMessage(_In_reads_(BufferChars) PSTR Buffer,
                              _In_ ULONG BufferChars,
                              _In_ PCSTR Format,
                              ...);
    
protected:
    HRESULT m_Status;
    PCSTR m_Message;
};

class ExtRemoteException : public ExtException
{
public:
    ExtRemoteException(_In_ HRESULT Status,
                       _In_ PCSTR Message)
        : ExtException(Status, Message) { }
};

class ExtStatusException : public ExtException
{
public:
    ExtStatusException(_In_ HRESULT Status,
                       _In_opt_ PCSTR Message = NULL)
        : ExtException(Status, Message) { }
};

class ExtInterruptException : public ExtException
{
public:
    ExtInterruptException(void)
        : ExtException(HRESULT_FROM_NT(STATUS_CONTROL_C_EXIT),
                       "Operation interrupted by request") { }
};

class ExtCheckedPointerException : public ExtException
{
public:
    ExtCheckedPointerException(_In_ PCSTR Message)
        : ExtException(E_INVALIDARG, Message) { }
};

class ExtInvalidArgumentException : public ExtException
{
public:
    ExtInvalidArgumentException(_In_ PCSTR Message)
        : ExtException(E_INVALIDARG, Message) { }
};

//----------------------------------------------------------------------------
//
// A checked pointer ensures that its value is non-NULL.
// This kind of wrapper is used for engine interface pointers
// so that extensions can simply use whatever interface they
// prefer with soft failure against engines that don't support
// the desired interfaces.
//
//----------------------------------------------------------------------------

template<typename _T>
class ExtCheckedPointer
{
public:
    ExtCheckedPointer(_In_ PCSTR Message)
    {
        m_Message = Message;
        m_Ptr = NULL;
    }

    bool IsSet(void) const
    {
        return m_Ptr != NULL;
    }
    void Throw(void) const throw(...)
    {
        if (!m_Ptr)
        {
            throw ExtCheckedPointerException(m_Message);
        }
    }
    _T* Get(void) const throw(...)
    {
        Throw();
        return m_Ptr;
    }
    void Set(_In_opt_ _T* Ptr)
    {
        m_Ptr = Ptr;
    }

    bool operator==(const _T* Ptr) const
    {
        return m_Ptr == Ptr;
    }
    bool operator!=(const _T* Ptr) const
    {
        return !(*this == Ptr);
    }

    operator _T*(void) throw(...)
    {
        return Get();
    }
    operator const _T*(void) const throw(...)
    {
        return Get();
    }
    _T* operator->(void) const throw(...)
    {
        return Get();
    }
    _T** operator&(void)
    {
        return &m_Ptr;
    }
    ExtCheckedPointer<_T>& operator=(ExtCheckedPointer<_T>& Ptr)
    {
        Set(Ptr.m_Ptr);
        return *this;
    }
    ExtCheckedPointer<_T>& operator=(_In_opt_ _T* Ptr)
    {
        Set(Ptr);
        return *this;
    }

protected:
    PCSTR m_Message;
    _T* m_Ptr;
};

//----------------------------------------------------------------------------
//
// An unknown holder is a safe pointer for an IUnknown.
// It automatically checks for NULL usage and calls
// Release on destruction.
//
//----------------------------------------------------------------------------

template<typename _T>
class ExtUnknownHolder
{
public:
    ExtUnknownHolder(void)
    {
        m_Unk = NULL;
    }
    ~ExtUnknownHolder(void)
    {
        EXT_RELEASE(m_Unk);
    }
    
    _T* Get(void) const throw(...)
    {
        if (!m_Unk)
        {
            throw ExtStatusException(E_NOINTERFACE,
                                     "ExtUnknownHolder NULL reference");
        }
        return m_Unk;
    }
    void Set(_In_opt_ _T* Unk)
    {
        EXT_RELEASE(m_Unk);
        m_Unk = Unk;
    }
    _T* Relinquish(void)
    {
        _T* Ret = m_Unk;
        m_Unk = NULL;
        return m_Unk;
    }

    bool operator==(const _T* Unk) const
    {
        return m_Unk == Unk;
    }
    bool operator!=(const _T* Unk) const
    {
        return !(*this == Unk);
    }
    
    operator _T*(void) throw(...)
    {
        return Get();
    }
    _T* operator->(void) throw(...)
    {
        return Get();
    }
    _T** operator&(void)
    {
        if (m_Unk)
        {
            throw ExtStatusException(E_NOINTERFACE,
                                     "ExtUnknownHolder non-NULL & reference");
        }
        return &m_Unk;
    }
    ExtUnknownHolder<_T>& operator=(ExtUnknownHolder<_T>& Unk)
    {
        if (Unk.m_Unk)
        {
            Unk.m_Unk->AddRef();
        }
        Set(Unk.m_Unk);
        return *this;
    }
    ExtUnknownHolder<_T>& operator=(_T* Unk)
    {
        Set(Unk);
        return *this;
    }

protected:
    _T* m_Unk;
};

//----------------------------------------------------------------------------
//
// A delete holder is a safe pointer for a dynamic object.
// It automatically checks for NULL usage and calls
// delete on destruction.
//
//----------------------------------------------------------------------------

template<typename _T, bool _Vector = false>
class ExtDeleteHolder
{
public:
    ExtDeleteHolder(void)
    {
        m_Ptr = NULL;
    }
    ~ExtDeleteHolder(void)
    {
        Delete();
    }

    _T* New(void) throw(...)
    {
        if (_Vector)
        {
            throw ExtInvalidArgumentException
                ("Scalar New used on vector ExtDeleteHolder");
        }
        _T* Ptr = new _T;
        if (!Ptr)
        {
            throw ExtStatusException(E_OUTOFMEMORY);
        }
        Set(Ptr);
        return Ptr;
    }
    _T* New(_In_ ULONG Elts) throw(...)
    {
        if (Elts > (ULONG_PTR)-1 / sizeof(_T))
        {
            throw ExtStatusException
                (HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW),
                 "ExtDeleteHolder::New count overflow");
        }
        if (!_Vector)
        {
            throw ExtInvalidArgumentException
                ("Vector New used on scalar ExtDeleteHolder");
        }
        _T* Ptr = new _T[Elts];
        if (!Ptr)
        {
            throw ExtStatusException(E_OUTOFMEMORY);
        }
        Set(Ptr);
        return Ptr;
    }
    void Delete(void)
    {
        if (_Vector)
        {
            delete [] m_Ptr;
        }
        else
        {
            delete m_Ptr;
        }
        m_Ptr = NULL;
    }
        
    _T* Get(void) const throw(...)
    {
        if (!m_Ptr)
        {
            throw ExtStatusException(E_INVALIDARG,
                                     "ExtDeleteHolder NULL reference");
        }
        return m_Ptr;
    }
    void Set(_In_opt_ _T* Ptr)
    {
        Delete();
        m_Ptr = Ptr;
    }
    _T* Relinquish(void)
    {
        _T* Ret = m_Ptr;
        m_Ptr = NULL;
        return Ret;
    }

    bool operator==(_In_opt_ const _T* Ptr) const
    {
        return m_Ptr == Ptr;
    }
    bool operator!=(_In_opt_ const _T* Ptr) const
    {
        return !(*this == Ptr);
    }
    
    operator _T*(void) throw(...)
    {
        return Get();
    }
    operator const _T*(void) const throw(...)
    {
        return Get();
    }
    _T* operator->(void) const throw(...)
    {
        return Get();
    }
    _T** operator&(void)
    {
        if (m_Ptr)
        {
            throw ExtStatusException(E_INVALIDARG,
                                     "ExtDeleteHolder non-NULL & reference");
        }
        return &m_Ptr;
    }
    ExtDeleteHolder<_T, _Vector>& operator=(_In_ ExtDeleteHolder<_T, _Vector>& Ptr)
    {
        Set(Ptr.Relinquish());
        return *this;
    }
    ExtDeleteHolder<_T, _Vector>& operator=(_In_opt_ _T* Ptr)
    {
        Set(Ptr);
        return *this;
    }

protected:
    _T* m_Ptr;
};

//----------------------------------------------------------------------------
//
// A current-thread holder is an auto-cleanup holder
// for restoring the debugger's current thread.
//
//----------------------------------------------------------------------------

class ExtCurrentThreadHolder
{
public:
    ExtCurrentThreadHolder(void)
    {
        m_ThreadId = DEBUG_ANY_ID;
    }
    ExtCurrentThreadHolder(_In_ ULONG Id)
    {
        m_ThreadId = Id;
    }
    ExtCurrentThreadHolder(_In_ bool DoRefresh)
    {
        if (DoRefresh)
        {
            Refresh();
        }
    }
    ~ExtCurrentThreadHolder(void)
    {
        Restore();
    }

    void WINAPI Refresh(void) throw(...);
    void WINAPI Restore(void);

    ULONG m_ThreadId;
};

//----------------------------------------------------------------------------
//
// A current-process holder is an auto-cleanup holder
// for restoring the debugger's current process.
//
//----------------------------------------------------------------------------

class ExtCurrentProcessHolder
{
public:
    ExtCurrentProcessHolder(void)
    {
        m_ProcessId = DEBUG_ANY_ID;
    }
    ExtCurrentProcessHolder(_In_ ULONG Id)
    {
        m_ProcessId = Id;
    }
    ExtCurrentProcessHolder(_In_ bool DoRefresh)
    {
        if (DoRefresh)
        {
            Refresh();
        }
    }
    ~ExtCurrentProcessHolder(void)
    {
        Restore();
    }

    void WINAPI Refresh(void) throw(...);
    void WINAPI Restore(void);

    ULONG m_ProcessId;
};

//----------------------------------------------------------------------------
//
// An effective-processor-type holder is an auto-cleanup holder
// for restoring the debugger's effective processor type.
//
//----------------------------------------------------------------------------

class ExtEffectiveProcessorTypeHolder
{
public:
    ExtEffectiveProcessorTypeHolder(void)
    {
        m_ProcType = DEBUG_ANY_ID;
    }
    ExtEffectiveProcessorTypeHolder(_In_ ULONG Type)
    {
        m_ProcType = Type;
    }
    ExtEffectiveProcessorTypeHolder(_In_ bool DoRefresh)
    {
        if (DoRefresh)
        {
            Refresh();
        }
    }
    ~ExtEffectiveProcessorTypeHolder(void)
    {
        Restore();
    }

    void WINAPI Refresh(void) throw(...);
    void WINAPI Restore(void);

    bool IsHolding(void)
    {
        return m_ProcType != DEBUG_ANY_ID;
    }
    
    ULONG m_ProcType;
};

//----------------------------------------------------------------------------
//
// A radix holder is an auto-cleanup holder
// for restoring the debugger's current radix.
//
//----------------------------------------------------------------------------

class ExtRadixHolder
{
public:
    ExtRadixHolder(void)
    {
        m_Radix = DEBUG_ANY_ID;
    }
    ExtRadixHolder(_In_ ULONG Radix)
    {
        m_Radix = Radix;
    }
    ExtRadixHolder(_In_ bool DoRefresh)
    {
        if (DoRefresh)
        {
            Refresh();
        }
    }
    ~ExtRadixHolder(void)
    {
        Restore();
    }

    void WINAPI Refresh(void) throw(...);
    void WINAPI Restore(void);

    ULONG m_Radix;
};

//----------------------------------------------------------------------------
//
// Simple dynamic buffers.  These are primarily intended to
// make it easy to come up with arrays for out parameters
// and aren't intended to be general dynamic vector classes.
//
//----------------------------------------------------------------------------

template<typename _T>
class ExtBuffer
{
public:
    ExtBuffer(void)
    {
        Clear();
    }
    ExtBuffer(_In_reads_(Elts) _T* Ptr,
              _In_ ULONG Elts,
              _In_ bool Owned,
              _In_ ULONG Used)
    {
        Clear();
        Set(Ptr, Elts, Owned, Used);
    }
    ~ExtBuffer(void)
    {
        Delete();
    }

    void Set(_In_reads_(Elts) _T* Ptr,
             _In_ ULONG Elts,
             _In_ bool Owned,
             _In_ ULONG Used)
    {
        Delete();
        m_Ptr = Ptr;
        m_EltsAlloc = Elts;
        m_Owned = Owned;
        m_EltsUsed = Used;
    }
    void SetUsed(_In_reads_(Elts) _T* Ptr,
                 _In_ ULONG Elts,
                 _In_ bool Owned)
    {
        Set(Ptr, Elts, Owned, Elts);
    }
    void SetUnused(_In_reads_(Elts) _T* Ptr,
                   _In_ ULONG Elts,
                   _In_ bool Owned)
    {
        Set(Ptr, Elts, Owned, 0);
    }
    void SetEltsUsed(_In_ ULONG Elts) throw(...)
    {
        if (Elts > m_EltsAlloc)
        {
            throw ExtStatusException(E_INVALIDARG,
                                     "ExtBuffer::SetEltsUsed "
                                     "illegal elt count");
        }

        m_EltsUsed = Elts;
    }

    void Resize(_In_ ULONG Elts) throw(...)
    {
        if (Elts > (ULONG_PTR)-1 / sizeof(_T))
        {
            throw ExtStatusException
                (HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW),
                 "ExtBuffer::Resize count overflow");
        }
        
        _T* Ptr = new _T[Elts];
        if (!Ptr)
        {
            throw ExtStatusException(E_OUTOFMEMORY);
        }
        
        ULONG Used = m_EltsUsed;
        if (Elts < Used)
        {
            Used = Elts;
        }

        if (m_Ptr)
        {
            for (ULONG i = 0; i < Used; i++)
            {
                Ptr[i] = m_Ptr[i];
            }
        }
        
        Set(Ptr, Elts, true, Used);
    }

    // The 'Extra' parameter is just a convenience for
    // adding to a count so that the integer overflow checks
    // can be done for the caller here.  The request
    // is for Elts+Extra slots to be available for use.
    void Require(_In_ ULONG Elts,
                 _In_ ULONG Extra = 0) throw(...)
    {
        if (Elts > (ULONG)-1 - Extra)
        {
            throw ExtStatusException
                (HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW),
                 "ExtBuffer::Require count overflow");
        }
        Elts += Extra;

        if (Elts > m_EltsAlloc)
        {
            Resize(Elts);
        }
    }
    void RequireRounded(_In_ ULONG Elts,
                        _In_ ULONG Round) throw(...)
    {
        if (Round < 2 ||
            Elts > (ULONG)-1 - Round)
        {
            throw ExtStatusException
                (HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW),
                 "ExtBuffer::RequireRounded count overflow");
        }
        Elts += Round - 1;
        Elts -= Elts % Round;

        Require(Elts);
    }

    void Delete(void)
    {
        if (m_Owned)
        {
            delete [] m_Ptr;
        }
        Clear();
    }
    _T* Relinquish(void)
    {
        _T* Ret = m_Ptr;
        Clear();
        return Ret;
    }
    void Empty(void)
    {
        m_EltsUsed = 0;
    }
    void Clear(void)
    {
        m_Ptr = NULL;
        m_EltsAlloc = 0;
        m_EltsUsed = 0;
        m_Owned = false;
    }

    _T* Get(_In_ ULONG Use) throw(...)
    {
        Require(Use);
        m_EltsUsed = Use;
        return m_Ptr;
    }
    _T* GetBuffer(void) const throw(...)
    {
        if (!m_Ptr)
        {
            throw ExtStatusException(E_INVALIDARG,
                                     "ExtBuffer NULL reference");
        }
        return m_Ptr;
    }
    _T* GetRawBuffer(void) const
    {
        return m_Ptr;
    }
    operator _T*(void) throw(...)
    {
        return GetBuffer();
    }
    operator const _T*(void) const throw(...)
    {
        return GetBuffer();
    }

    _T* Copy(_In_reads_(Elts) const _T* Src,
             _In_ ULONG Elts = 1)
    {
        _T* Dst = Get(Elts);
        for (ULONG i = 0; i < Elts; i++)
        {
            Dst[i] = Src[i];
        }
        return Dst;
    }
    _T* Copy(_In_ const ExtBuffer* Other)
    {
        return Copy(Other->GetRawBuffer(), Other->GetEltsUsed());
    }

    _T* Append(_In_reads_(Elts) const _T* Src,
               _In_ ULONG Elts = 1)
    {
        Require(m_EltsUsed, Elts);
        for (ULONG i = 0; i < Elts; i++)
        {
            m_Ptr[m_EltsUsed++] = Src[i];
        }
        return m_Ptr;
    }
    _T* Append(_In_ const ExtBuffer* Other)
    {
        return Append(Other->GetRawBuffer(), Other->GetEltsUsed());
    }
    
    ULONG GetEltsUsed(void) const
    {
        return m_EltsUsed;
    }
    ULONG GetEltsAlloc(void) const
    {
        return m_EltsAlloc;
    }
    bool GetOwned(void) const
    {
        return m_Owned;
    }
    
    ExtBuffer<_T>& operator=(_In_ ExtBuffer<_T>& Ptr)
    {
        Set(Ptr.m_Ptr, Ptr.m_EltsAlloc, Ptr.m_Owned, Ptr.m_EltsUsed);
        Ptr.Clear();
        return *this;
    }
    ExtBuffer<_T>& operator=(_In_opt_ _T* Ptr)
    {
        throw ExtStatusException(E_INVALIDARG,
                                 "ExtBuffer can't be assigned "
                                 "an unsized pointer");
        return *this;
    }

protected:
    _T* m_Ptr;
    ULONG m_EltsUsed;
    ULONG m_EltsAlloc;
    bool m_Owned;
};

// Variant which adds an initial amount of locally-declared storage space.
template<typename _T, size_t _DeclElts>
class ExtDeclBuffer : public ExtBuffer<_T>
{
public:
    ExtDeclBuffer(void) :
        ExtBuffer(m_Decl, _DeclElts, false, 0)
    {
    };

    ExtDeclBuffer& operator=(_In_ ExtDeclBuffer& Ptr)
    {
        throw ExtStatusException(E_INVALIDARG,
                                 "ExtDeclBuffer can't be assigned a buffer");
        return *this;
    }
    ExtDeclBuffer& operator=(_In_opt_ _T* Ptr)
    {
        throw ExtStatusException(E_INVALIDARG,
                                 "ExtDeclBuffer can't be assigned a buffer");
        return *this;
    }

protected:
    _T m_Decl[_DeclElts];
};

// Variant which adds an initial amount of locally-declared storage space,
// but in this case the declaration is always done with a 64-bit
// buffer so that you can assume 64-bit alignment.
// This is useful for cases where you're allocating a buffer of
// mixed data as a BYTE buffer, but you need to ensure that
// the data buffer will have alignment large enough for any
// of the mixed data elements.
template<typename _T, size_t _DeclElts>
class ExtDeclAlignedBuffer : public ExtBuffer<_T>
{
public:
    ExtDeclAlignedBuffer(void) :
        ExtBuffer((_T*)m_Decl, _DeclElts, false, 0)
    {
    };

    ExtDeclAlignedBuffer& operator=(_In_ ExtDeclAlignedBuffer& Ptr)
    {
        throw ExtStatusException(E_INVALIDARG,
                                 "ExtDeclAlignedBuffer "
                                 "can't be assigned a buffer");
        return *this;
    }
    ExtDeclAlignedBuffer& operator=(_In_opt_ _T* Ptr)
    {
        throw ExtStatusException(E_INVALIDARG,
                                 "ExtDeclAlignedBuffer "
                                 "can't be assigned a buffer");
        return *this;
    }

protected:
    ULONG64 m_Decl[(_DeclElts * sizeof(_T) + sizeof(ULONG64) - 1) /
                   sizeof(ULONG64)];
};

//----------------------------------------------------------------------------
//
// Descriptive information kept for all extension commands.
// Automatic help and parameter parsing are built on top
// of this descriptive info.
//
// The argument format is described below with EXT_COMMAND.
//
//----------------------------------------------------------------------------

typedef void (__thiscall ExtExtension::*ExtCommandMethod)(void);
typedef HRESULT (ExtExtension::*ExtRawMethod)(_In_opt_ PVOID Context);
typedef HRESULT (CALLBACK *ExtRawFunction)(_In_opt_ PVOID Context);

class ExtCommandDesc
{
public:
    WINAPI ExtCommandDesc(_In_ PCSTR Name,
                   _In_ ExtCommandMethod Method,
                   _In_ PCSTR Desc,
                   _In_opt_ PCSTR Args);
    WINAPI ~ExtCommandDesc(void);

    ExtExtension* m_Ext;
    ExtCommandDesc* m_Next;
    PCSTR m_Name;
    ExtCommandMethod m_Method;
    PCSTR m_Desc;
    PCSTR m_ArgDescStr;
    bool m_ArgsInitialized;

    //
    // Derived by parsing the argument description string.
    //

    struct ArgDesc
    {
        PCSTR Name;
        PCSTR DescShort;
        PCSTR DescLong;
        PCSTR Default;
        PCSTR ExpressionEvaluator;
        ULONG Boolean:1;
        ULONG Expression:1;
        ULONG ExpressionSigned:1;
        ULONG ExpressionDelimited:1;
        ULONG String:1;
        ULONG StringRemainder:1;
        ULONG Required:1;
        ULONG Present:1;
        ULONG DefaultSilent:1;
        ULONG ExpressionBits;
        ULONG ExpressionRadix;

        bool NeedsOptionsOutput(void)
        {
            return
                (Default && !DefaultSilent) ||
                (Expression &&
                 (ExpressionSigned ||
                  ExpressionDelimited ||
                  ExpressionBits != 64 ||
                  ExpressionRadix != 0 ||
                  ExpressionEvaluator != NULL)) ||
                (String &&
                 StringRemainder);
        }
    };

    bool m_CustomArgParsing;
    PSTR m_CustomArgDescShort;
    PSTR m_CustomArgDescLong;
    PSTR m_OptionChars;
    PSTR m_ArgStrings;
    ULONG m_NumArgs;
    ULONG m_NumUnnamedArgs;
    ArgDesc* m_Args;

    void WINAPI ClearArgs(void);
    void WINAPI DeleteArgs(void);
    PSTR WINAPI ParseDirective(_In_ PSTR Scan) throw(...);
    void WINAPI ParseArgDesc(void) throw(...);
    void WINAPI ExInitialize(_In_ ExtExtension* Ext) throw(...);

    ArgDesc* WINAPI FindArg(_In_ PCSTR Name);
    ArgDesc* WINAPI FindUnnamedArg(_In_ ULONG Index);
    
    static void WINAPI Transfer(_Out_ ExtCommandDesc** Commands,
                                _Out_ PULONG LongestName);

    static ExtCommandDesc* s_Commands;
    static ULONG s_LongestCommandName;
};

//----------------------------------------------------------------------------
//
// Known-struct formatting support.
// In order to automatically advertise known structs for
// formatting an extension should point ExtExtension::m_KnownStructs
// at an array of descriptors.  Callbacks will then be sent
// automatically to the formatting methods when necessary.
//
// The final array entry should have TypeName == NULL.
//
//----------------------------------------------------------------------------

// Data formatting callback for known structs.
// On entry the append buffer will be set to the target buffer.
typedef void (ExtExtension::*ExtKnownStructMethod)
    (_In_ PCSTR TypeName,
     _In_ ULONG Flags,
     _In_ ULONG64 Offset);

struct ExtKnownStruct
{
    PCSTR TypeName;
    ExtKnownStructMethod Method;
    bool SuppressesTypeName;
};

//----------------------------------------------------------------------------
//
// Pseudo-register value provider support.
// In order to automatically advertise extended values
// an extension should point ExtExtension::m_ProvidedValues
// at an array of descriptors.  Callbacks will then be sent
// automatically to the provider methods when necessary.
//
// The final array entry should have ValueName == NULL.
//
//----------------------------------------------------------------------------

// Value retrieval callback.
typedef void (ExtExtension::*ExtProvideValueMethod)
    (_In_ ULONG Flags,
     _In_ PCWSTR ValueName,
     _Out_ PULONG64 Value,
     _Out_ PULONG64 TypeModBase,
     _Out_ PULONG TypeId,
     _Out_ PULONG TypeFlags);

struct ExtProvidedValue
{
    PCWSTR ValueName;
    ExtProvideValueMethod Method;
};

//----------------------------------------------------------------------------
//
// Base class for all extensions.  An extension DLL will
// have a single instance of a derivation of this class.
// The instance global is automatically declared by macros.
// As the instance is a global the initialization and uninitialization
// is explicit instead of driven through construction and destruction.
//
//----------------------------------------------------------------------------

class ExtExtension
{
public:
    WINAPI ExtExtension(void);

    //
    // Initialization and uninitialization.
    //

    // BaseInitialize does one-time initialization
    // for EngExtCpp.  EngExtCpp's DebugExtensionInitialize
    // calls this, so if you are doing a hybrid dbgeng/EngExtCpp
    // extension and using your own DebugExtensionInitialize you
    // can call this to get EngExtCpp's initial state set up.
    HRESULT WINAPI BaseInitialize(_In_ HMODULE ExtDllModule,
                                  _Out_ PULONG Version,
                                  _Out_ PULONG Flags);
    
    virtual HRESULT __thiscall Initialize(void);
    virtual void __thiscall Uninitialize(void);

    //
    // Notifications.
    //

    virtual void __thiscall OnSessionActive(_In_ ULONG64 Argument);
    virtual void __thiscall OnSessionInactive(_In_ ULONG64 Argument);
    virtual void __thiscall OnSessionAccessible(_In_ ULONG64 Argument);
    virtual void __thiscall OnSessionInaccessible(_In_ ULONG64 Argument);

    //
    // Overridable initialization state.
    //
    
    USHORT m_ExtMajorVersion;
    USHORT m_ExtMinorVersion;
    ULONG m_ExtInitFlags;

    ExtKnownStruct* m_KnownStructs;
    ExtProvidedValue* m_ProvidedValues;
    
    //
    // Interface and callback pointers.  These
    // interfaces are retrieved on entry to an extension.
    //

    ExtCheckedPointer<IDebugAdvanced> m_Advanced;
    ExtCheckedPointer<IDebugClient> m_Client;
    ExtCheckedPointer<IDebugControl> m_Control;
    ExtCheckedPointer<IDebugDataSpaces> m_Data;
    ExtCheckedPointer<IDebugRegisters> m_Registers;
    ExtCheckedPointer<IDebugSymbols> m_Symbols;
    ExtCheckedPointer<IDebugSystemObjects> m_System;

    // These derived interfaces may be NULL on
    // older engines which do not support them.
    // The checked pointers will automatically
    // protect access.
    ExtCheckedPointer<IDebugAdvanced2> m_Advanced2;
    ExtCheckedPointer<IDebugAdvanced3> m_Advanced3;
    ExtCheckedPointer<IDebugClient2> m_Client2;
    ExtCheckedPointer<IDebugClient3> m_Client3;
    ExtCheckedPointer<IDebugClient4> m_Client4;
    ExtCheckedPointer<IDebugClient5> m_Client5;
    ExtCheckedPointer<IDebugControl2> m_Control2;
    ExtCheckedPointer<IDebugControl3> m_Control3;
    ExtCheckedPointer<IDebugControl4> m_Control4;
    ExtCheckedPointer<IDebugControl5> m_Control5;
    ExtCheckedPointer<IDebugControl6> m_Control6;
    ExtCheckedPointer<IDebugDataSpaces2> m_Data2;
    ExtCheckedPointer<IDebugDataSpaces3> m_Data3;
    ExtCheckedPointer<IDebugDataSpaces4> m_Data4;
    ExtCheckedPointer<IDebugRegisters2> m_Registers2;
    ExtCheckedPointer<IDebugSymbols2> m_Symbols2;
    ExtCheckedPointer<IDebugSymbols3> m_Symbols3;
    ExtCheckedPointer<IDebugSystemObjects2> m_System2;
    ExtCheckedPointer<IDebugSystemObjects3> m_System3;
    ExtCheckedPointer<IDebugSystemObjects4> m_System4;

    //
    // Interesting information about the session.
    // These values are retrieved on entry to an extension.
    //

    ULONG m_OutputWidth;
    
    // Actual processor type.
    ULONG m_ActualMachine;

    // Current machine mode values, not actual
    // machine mode values.  Generally these are
    // the ones you want to look at.
    // If you care about mixed CPU code, such as WOW64,
    // you may need to also get the actual values.
    ULONG m_Machine;
    ULONG m_PageSize;
    ULONG m_PtrSize;
    ULONG m_NumProcessors;
    ULONG64 m_OffsetMask;

    ULONG m_PlatformId;
    ULONG m_Major;
    ULONG m_Minor;
    ULONG m_MajorVersion;
    ULONG m_MinorVersion;
    ULONG m_ServicePackNumber;
    ULONG m_ServicePackMajor;
    ULONG m_ServicePackMinor;
    USHORT m_SystemVersion;
    ULONG m_ProductType;
    ULONG m_SuiteMask;

    ULONG m_NumberOfPhysicalPages;

    LARGE_INTEGER m_SystemTime;

    //
    // Queries about the current debuggee information available.
    // The type and qualifier are automatically retrieved.
    //
    
    ULONG m_DebuggeeClass;
    ULONG m_DebuggeeQual;
    ULONG m_DumpFormatFlags;

    bool m_IsRemote;
    bool m_OutCallbacksDmlAware;
    
    bool IsUserMode(void)
    {
        return m_DebuggeeClass == DEBUG_CLASS_USER_WINDOWS;
    }
    bool IsKernelMode(void)
    {
        return m_DebuggeeClass == DEBUG_CLASS_KERNEL;
    }
    bool IsLiveLocalUser(void)
    {
        return
            m_DebuggeeClass == DEBUG_CLASS_USER_WINDOWS &&
            m_DebuggeeQual == DEBUG_USER_WINDOWS_PROCESS;
    }
    bool IsMachine32(_In_ ULONG Machine)
    {
        return
            Machine == IMAGE_FILE_MACHINE_I386 ||
            Machine == IMAGE_FILE_MACHINE_ARM ||
            Machine == IMAGE_FILE_MACHINE_THUMB ||
            Machine == IMAGE_FILE_MACHINE_ARMNT;
    }
    bool IsCurMachine32(void)
    {
        return IsMachine32(m_Machine);
    }
    bool IsMachine64(_In_ ULONG Machine)
    {
        return
            Machine == IMAGE_FILE_MACHINE_AMD64 ||
            Machine == IMAGE_FILE_MACHINE_IA64;
    }
    bool IsCurMachine64(void)
    {
        return IsMachine64(m_Machine);
    }
    bool Is32On64(void)
    {
        return IsCurMachine32() && IsMachine64(m_ActualMachine);
    }
    bool CanQueryVirtual(void)
    {
        return
            m_DebuggeeClass == DEBUG_CLASS_USER_WINDOWS ||
            m_DebuggeeClass == DEBUG_CLASS_IMAGE_FILE;
    }
    bool HasFullMemBasic(void)
    {
        return
            m_DebuggeeClass == DEBUG_CLASS_USER_WINDOWS &&
            (m_DebuggeeQual == DEBUG_USER_WINDOWS_PROCESS ||
             m_DebuggeeQual == DEBUG_USER_WINDOWS_PROCESS_SERVER ||
             m_DebuggeeQual == DEBUG_USER_WINDOWS_DUMP ||
             (m_DebuggeeQual == DEBUG_USER_WINDOWS_SMALL_DUMP &&
              (m_DumpFormatFlags &
               DEBUG_FORMAT_USER_SMALL_FULL_MEMORY_INFO) != 0));
    }
    bool IsExtensionRemote(void)
    {
        return m_IsRemote;
    }
    bool AreOutputCallbacksDmlAware(void)
    {
        // Applies to callbacks present in client
        // at the start of the extension command.
        // If the extension changes the output callbacks
        // the value does not automatically update.
        // RefreshOutputCallbackFlags can be used
        // to update this flag after unknown output
        // callbacks are installed.
        return m_OutCallbacksDmlAware;
    }

    //
    // Common mode checks which throw on mismatches.
    //

    void RequireUserMode(void)
    {
        if (!IsUserMode())
        {
            throw ExtStatusException(S_OK, "user-mode only");
        }
    }
    void RequireKernelMode(void)
    {
        if (!IsKernelMode())
        {
            throw ExtStatusException(S_OK, "kernel-mode only");
        }
    }
    
    //
    // Output through m_Control.
    //

    // Defaults to DEBUG_OUTPUT_NORMAL, but can
    // be overridden to produce different output.
    // Warn, Err and Verb are convenience routines for
    // the warning, error and verbose cases.
    ULONG m_OutMask;
    
    void WINAPIV Out(_In_ PCSTR Format,
                     ...);
    void WINAPIV Warn(_In_ PCSTR Format,
                      ...);
    void WINAPIV Err(_In_ PCSTR Format,
                     ...);
    void WINAPIV Verb(_In_ PCSTR Format,
                      ...);
    void WINAPIV Out(_In_ PCWSTR Format,
                     ...);
    void WINAPIV Warn(_In_ PCWSTR Format,
                      ...);
    void WINAPIV Err(_In_ PCWSTR Format,
                     ...);
    void WINAPIV Verb(_In_ PCWSTR Format,
                      ...);

    void WINAPIV Dml(_In_ PCSTR Format,
                     ...);
    void WINAPIV DmlWarn(_In_ PCSTR Format,
                         ...);
    void WINAPIV DmlErr(_In_ PCSTR Format,
                        ...);
    void WINAPIV DmlVerb(_In_ PCSTR Format,
                         ...);
    void WINAPIV Dml(_In_ PCWSTR Format,
                     ...);
    void WINAPIV DmlWarn(_In_ PCWSTR Format,
                         ...);
    void WINAPIV DmlErr(_In_ PCWSTR Format,
                        ...);
    void WINAPIV DmlVerb(_In_ PCWSTR Format,
                         ...);

    void DmlCmdLink(_In_ PCSTR Text,
                    _In_ PCSTR Cmd)
    {
        Dml("<link cmd=\"%s\">%s</link>", Cmd, Text);
    }
    void DmlCmdExec(_In_ PCSTR Text,
                    _In_ PCSTR Cmd)
    {
        Dml("<exec cmd=\"%s\">%s</exec>", Cmd, Text);
    }

    void RefreshOutputCallbackFlags(void)
    {
        m_OutCallbacksDmlAware = false;
        if (m_Advanced2.IsSet() &&
            m_Advanced2->
            Request(DEBUG_REQUEST_CURRENT_OUTPUT_CALLBACKS_ARE_DML_AWARE,
                    NULL, 0, NULL, 0, NULL) == S_OK)
        {
            m_OutCallbacksDmlAware = true;
        }
    }

    //
    // Wrapped text output support.
    //

    ULONG m_CurChar;
    ULONG m_LeftIndent;
    bool m_AllowWrap;
    bool m_TestWrap;
    ULONG m_TestWrapChars;
    // m_OutputWidth is also used.
    
    // OutWrap takes the given string and displays it
    // wrapped in the appropriate space.  It doesn't
    // account for tabs, backspaces, internal returns, etc.
    // Uses all wrapping state and updates m_CurChar.
    void WINAPI WrapLine(void);
    void WINAPI OutWrapStr(_In_ PCSTR String);
    void WINAPIV OutWrapVa(_In_ PCSTR Format,
                           _In_ va_list Args);
    void WINAPIV OutWrap(_In_ PCSTR Format,
                         ...);

    void ClearWrap(void)
    {
        m_LeftIndent = 0;
        m_CurChar = 0;
    }
    
    void MarkWrapPoint(void)
    {
        m_LeftIndent = m_CurChar;
    }
    
    // Wraps if the given number of characters wouldn't
    // fit on the current line.
    bool DemandWrap(_In_ ULONG Chars)
    {
        if (m_CurChar + Chars >= m_OutputWidth)
        {
            WrapLine();
            return true;
        }

        return false;
    }
    
    // Wrapping can be suppressed to allow blocks of
    // output to be unsplit but to still get cur char
    // tracking.
    void AllowWrap(_In_ bool Allow)
    {
        m_AllowWrap = Allow;
    }

    // Output can be suppressed, allowing collection
    // of character counts as a way to pre-test whether
    // a set of output will wrap.
    void TestWrap(_In_ bool Test)
    {
        m_TestWrap = Test;
        if (Test)
        {
            m_TestWrapChars = 0;
        }
    }

    //
    // A circular string buffer is available for
    // handing out multiple static strings.
    //

    PSTR WINAPI RequestCircleString(_In_ ULONG Chars) throw(...);
    PSTR WINAPI CopyCircleString(_In_ PCSTR Str) throw(...);
    PSTR WINAPI PrintCircleStringVa(_In_ PCSTR Format,
                             _In_ va_list Args) throw(...);
    PSTR WINAPIV PrintCircleString(_In_ PCSTR Format,
                                   ...) throw(...);

    //
    // String buffer with append support.
    // Throws on buffer overflow.
    //

    PSTR m_AppendBuffer;
    ULONG m_AppendBufferChars;
    PSTR m_AppendAt;
    
    void WINAPI SetAppendBuffer(_In_reads_(BufferChars) PSTR Buffer,
                         _In_ ULONG BufferChars);
    void WINAPI AppendBufferString(_In_ PCSTR Str) throw(...);
    void WINAPI AppendStringVa(_In_ PCSTR Format,
                        _In_ va_list Args) throw(...);
    void WINAPIV AppendString(_In_ PCSTR Format,
                              ...) throw(...);

    bool IsAppendStart(void)
    {
        return m_AppendAt == m_AppendBuffer;
    }
    
    //
    // Set the return status for an extension call
    // if a specific non-S_OK status needs to be returned.
    //

    void WINAPI SetCallStatus(_In_ HRESULT Status);

    //
    // Change the effective processor type.
    // This will refresh the cached ExtExtension machine info
    // and optionally initialize an effective processor holder.
    //

    ULONG WINAPI GetEffectiveProcessor(void) throw(...);
    void WINAPI SetEffectiveProcessor(_In_ ULONG ProcType,
                                      _Inout_opt_ ExtEffectiveProcessorTypeHolder* Holder = NULL) throw(...);

    //
    // Cached symbol info.  The cache is
    // automatically flushed when the backing
    // symbol info changes.
    //

    ULONG WINAPI GetCachedSymbolTypeId(_Inout_ PULONG64 Cookie,
                                _In_ PCSTR Symbol,
                                _Out_ PULONG64 ModBase);
    ULONG WINAPI GetCachedFieldOffset(_Inout_ PULONG64 Cookie,
                               _In_ PCSTR Type,
                               _In_ PCSTR Field,
                               _Out_opt_ PULONG64 ModBase = NULL,
                               _Out_opt_ PULONG TypeId = NULL);
    bool WINAPI GetCachedSymbolInfo(_In_ ULONG64 Cookie,
                             _Out_ PDEBUG_CACHED_SYMBOL_INFO Info);
    bool WINAPI AddCachedSymbolInfo(_In_ PDEBUG_CACHED_SYMBOL_INFO Info,
                             _In_ bool ThrowFailure,
                             _Out_ PULONG64 Cookie);

    //
    // Symbol helpers.
    //

    void WINAPI FindSymMatchStringA(void) throw(...);
    
    // Matches patterns using the same code as dbgeng/dbghelp.
    bool MatchPattern(_In_ PCSTR ArbitraryString,
                      _In_ PCSTR Pattern,
                      _In_ bool CaseSensitive = false)
    {
        if (!m_SymMatchStringA)
        {
            FindSymMatchStringA();
        }
        return m_SymMatchStringA(ArbitraryString, Pattern,
                                 CaseSensitive) != FALSE;
    }
    
    bool GetSymbolOffset(_In_ PCSTR Symbol,
                         _In_ bool RetZero,
                         _Out_ ULONG64* Offs)
    {
        HRESULT Status;

        if ((Status = m_Symbols->GetOffsetByName(Symbol, Offs)) != S_OK)
        {
            if (!RetZero)
            {
                if (Status == S_FALSE)
                {
                    ThrowInvalidArg("'%s' has multiple offsets", Symbol);
                }
                else
                {
                    ThrowStatus(Status, "Unable to resolve '%s'", Symbol);
                }
            }
            else
            {
                *Offs = 0;
            }

            return false;
        }

        return true;
    }
    bool CanResolveSymbol(_In_ PCSTR Symbol)
    {
        ULONG64 Offs;
        return GetSymbolOffset(Symbol, true, &Offs);
    }

    // Note that if you're just retrieving the symbol
    // name to output it it's easier to use %y
    // or IDebugSymbols3::OutputSymbolByOffset.
    bool WINAPI GetOffsetSymbol(_In_ ULONG64 Offs,
                               _Inout_ ExtBuffer<char>* Name,
                               _Out_opt_ PULONG64 Displacement = NULL,
                               _In_ bool AddDisp = false) throw(...);
    
    // Returns index of the first module whose name
    // matches the given pattern.  The scan starts
    // at the given module list index and only
    // looks at loaded modules.
    ULONG WINAPI FindFirstModule(_In_ PCSTR Pattern,
                                 _Inout_opt_ ExtBuffer<char>* Name = NULL,
                                 _In_ ULONG StartIndex = 0) throw(...);

    //
    // Module information helpers.
    //

    void WINAPI GetModuleImagehlpInfo(_In_ ULONG64 ModBase,
                               _Out_ struct _IMAGEHLP_MODULEW64* Info);
    bool WINAPI ModuleHasGlobalSymbols(_In_ ULONG64 ModBase);
    bool WINAPI ModuleHasTypeInfo(_In_ ULONG64 ModBase);

    //
    // Command execution helpers.
    //

    // Uses a circle string.
    void ExecuteVa(_In_ ULONG OutCtl,
                   _In_ ULONG ExecFlags,
                   _In_ PCSTR Format,
                   _In_ va_list Args) throw(...)
    {
        HRESULT Status;
        PSTR Cmd = PrintCircleStringVa(Format, Args);
        
        if (FAILED(Status = m_Control->
                   Execute(OutCtl, Cmd, ExecFlags)))
        {
            ThrowStatus(Status, "Unable to execute '%s'", Cmd);
        }
    }
    void Execute(_In_ ULONG OutCtl,
                 _In_ ULONG ExecFlags,
                 _In_ PCSTR Format,
                 ...) throw(...)
    {
        va_list Args;

        va_start(Args, Format);
        ExecuteVa(OutCtl, ExecFlags, Format, Args);
        va_end(Args);
    }
    void Execute(_In_ PCSTR Format,
                 ...) throw(...)
    {
        va_list Args;

        va_start(Args, Format);
        ExecuteVa(DEBUG_OUTCTL_AMBIENT, DEBUG_EXECUTE_DEFAULT, Format, Args);
        va_end(Args);
    }
    void ExecuteSilent(_In_ PCSTR Format,
                       ...) throw(...)
    {
        va_list Args;

        va_start(Args, Format);
        ExecuteVa(DEBUG_OUTCTL_IGNORE,
                  DEBUG_EXECUTE_NOT_LOGGED |
                  DEBUG_EXECUTE_NO_REPEAT,
                  Format,
                  Args);
        va_end(Args);
    }

    //
    // Invoke a routine in the debuggee.  This is a wrapper
    // for the debugger's .call command.
    // The return value is the raw 64-bit value from @$callret,
    // but you can access richer information by constructing
    // an ExtRemoteTyped on "@$callret".
    //
    // CAUTION: .call hijacks the current thread for the invocation
    // and thus can be unsafe if the invoked code does things
    // which requires a particular thread or program state.
    //
    // CAUTION on EXECUTION: Calling code in the debuggee requires
    // that the debuggee run so using these routines will result
    // in the debuggee running for some period of time.
    // It also means that this will fail on non-executable targets.
    //

    ULONG64 WINAPI CallDebuggeeBase(_In_ PCSTR CommandString,
                                   _In_ ULONG TimeoutMilliseconds);
    // Uses a circle string.
    ULONG64 CallDebuggeeVa(_In_ PCSTR Format,
                           _In_ va_list Args,
                           _In_ ULONG TimeoutMilliseconds = 60000)
    {
        return CallDebuggeeBase(PrintCircleStringVa(Format, Args),
                                TimeoutMilliseconds);
    }
    ULONG64 CallDebuggee(_In_ PCSTR Format,
                         ...)
    {
        va_list Args;
        ULONG64 Ret;

        va_start(Args, Format);
        Ret = CallDebuggeeVa(Format, Args);
        va_end(Args);
        return Ret;
    }

    //
    // Register and pseudo-register access helpers.
    // If an index cache is used it should be initialized
    // to DEBUG_ANY_ID.
    //

    ULONG WINAPI FindRegister(_In_ PCSTR Name,
                       _Inout_opt_ PULONG IndexCache = NULL);
    ULONG64 WINAPI GetRegisterU64(_In_ PCSTR Name,
                           _Inout_opt_ PULONG IndexCache = NULL);
    void WINAPI SetRegisterU64(_In_ PCSTR Name,
                        _In_ ULONG64 Val,
                        _Inout_opt_ PULONG IndexCache = NULL);
    
    ULONG WINAPI FindPseudoRegister(_In_ PCSTR Name,
                             _Inout_opt_ PULONG IndexCache = NULL);
    ULONG64 WINAPI GetPseudoRegisterU64(_In_ PCSTR Name,
                                 _Inout_opt_ PULONG IndexCache = NULL);
    void WINAPI SetPseudoRegisterU64(_In_ PCSTR Name,
                              _In_ ULONG64 Val,
                              _Inout_opt_ PULONG IndexCache = NULL);

    ULONG64 GetExtRetU64(void)
    {
        return GetPseudoRegisterU64("$extret", &m_ExtRetIndex);
    }
    void SetExtRetU64(_In_ ULONG64 Val)
    {
        return SetPseudoRegisterU64("$extret", Val, &m_ExtRetIndex);
    }

    PSTR GetTempRegName(_In_ ULONG Index,
                        _Out_writes_(NameChars) PSTR Name,
                        _In_ ULONG NameChars)
    {
        if (NameChars < 5)
        {
            ThrowInvalidArg("Insufficient temp register name buffer");
        }
        
        Name[0] = '$';
        Name[1] = 't';
        if (Index < 10)
        {
            Name[2] = (char)('0' + Index);
            Name[3] = 0;
        }
        else if (Index < EXT_DIMA(m_TempRegIndex))
        {
            Name[2] = (char)('0' + (Index / 10));
            Name[3] = (char)('0' + (Index % 10));
            Name[4] = 0;
        }
        else
        {
            ThrowInvalidArg("Invalid temp register index %u", Index);
        }
        
        return Name;
    }
    ULONG64 GetTempRegU64(_In_ ULONG Index)
    {
        char Name[5];

        GetTempRegName(Index, Name, EXT_DIMA(Name));
        return GetPseudoRegisterU64(Name, &m_TempRegIndex[Index]);
    }
    void SetTempRegU64(_In_ ULONG Index,
                       _In_ ULONG64 Val)
    {
        char Name[5];

        GetTempRegName(Index, Name, EXT_DIMA(Name));
        return SetPseudoRegisterU64(Name, Val, &m_TempRegIndex[Index]);
    }

    //
    // Incoming argument parsing results.
    // Results are guaranteed to obey the form
    // of the argument description for a command.
    // Mismatched usage, such as a string retrieval
    // for a numeric argument, will result in an exception.
    //

    ULONG GetNumUnnamedArgs(void)
    {
        return m_NumUnnamedArgs;
    }
    
    PCSTR WINAPI GetUnnamedArgStr(_In_ ULONG Index) throw(...);
    ULONG64 WINAPI GetUnnamedArgU64(_In_ ULONG Index) throw(...);
    bool HasUnnamedArg(_In_ ULONG Index)
    {
        return Index < m_NumUnnamedArgs;
    }

    PCSTR WINAPI GetArgStr(_In_ PCSTR Name,
                    _In_ bool Required = true) throw(...);
    ULONG64 WINAPI GetArgU64(_In_ PCSTR Name,
                      _In_ bool Required = true) throw(...);
    bool HasArg(_In_ PCSTR Name)
    {
        return FindArg(Name, false) != NULL;
    }
    bool HasCharArg(_In_ CHAR Name)
    {
        CHAR NameStr[2] = {Name, 0};
        return FindArg(NameStr, false) != NULL;
    }

    bool WINAPI SetUnnamedArg(_In_ ULONG Index,
                              _In_opt_ PCSTR StrArg,
                              _In_ ULONG64 NumArg,
                              _In_ bool OnlyIfUnset = false) throw(...);
    bool SetUnnamedArgStr(_In_ ULONG Index,
                          _In_ PCSTR Arg,
                          _In_ bool OnlyIfUnset = false) throw(...)
    {
        return SetUnnamedArg(Index, Arg, 0, OnlyIfUnset);
    }
    bool SetUnnamedArgU64(_In_ ULONG Index,
                          _In_ ULONG64 Arg,
                          _In_ bool OnlyIfUnset = false) throw(...)
    {
        return SetUnnamedArg(Index, NULL, Arg, OnlyIfUnset);
    }

    bool WINAPI SetArg(_In_ PCSTR Name,
                       _In_opt_ PCSTR StrArg,
                       _In_ ULONG64 NumArg,
                       _In_ bool OnlyIfUnset = false) throw(...);
    bool SetArgStr(_In_ PCSTR Name,
                   _In_ PCSTR Arg,
                   _In_ bool OnlyIfUnset = false) throw(...)
    {
        return SetArg(Name, Arg, 0, OnlyIfUnset);
    }
    bool SetArgU64(_In_ PCSTR Name,
                   _In_ ULONG64 Arg,
                   _In_ bool OnlyIfUnset = false) throw(...)
    {
        return SetArg(Name, NULL, Arg, OnlyIfUnset);
    }

    PCSTR GetRawArgStr(void)
    {
        return m_RawArgStr;
    }
    PSTR GetRawArgCopy(void)
    {
        // This string may be chopped up if
        // the default argument parsing occurred.
        return m_ArgCopy;
    }
    
    PCSTR WINAPI GetExpr64(_In_ PCSTR Str,
                           _In_ bool Signed,
                           _In_ ULONG64 Limit,
                           _Out_ PULONG64 Val) throw(...);
    PCSTR GetExprU64(_In_ PCSTR Str,
                     _In_ ULONG64 Limit,
                     _Out_ PULONG64 Val) throw(...)
    {
        return GetExpr64(Str, false, Limit, Val);
    }
    PCSTR GetExprS64(_In_ PCSTR Str,
                     _In_ LONG64 Limit,
                     _Out_ PLONG64 Val) throw(...)
    {
        return GetExpr64(Str, true, (ULONG64)Limit, (PULONG64)Val);
    }

    ULONG64 EvalExprU64(_In_ PCSTR Str)
    {
        HRESULT Status;
        DEBUG_VALUE FullVal;
        
        if ((Status = m_Control->
             Evaluate(Str, DEBUG_VALUE_INT64, &FullVal, NULL)) != S_OK)
        {
            ThrowStatus(Status, "Unable to evaluate '%s'", Str);
        }

        return FullVal.I64;
    }

    void DECLSPEC_NORETURN ThrowCommandHelp(void) throw(...)
    {
        if (m_CurCommand)
        {
            HelpCommand(m_CurCommand);
        }
        throw ExtStatusException(E_INVALIDARG);
    }
    void ThrowInterrupt(void) throw(...)
    {
        if (m_Control->GetInterrupt() == S_OK)
        {
            throw ExtInterruptException();
        }
    }
    void DECLSPEC_NORETURN ThrowOutOfMemory(void) throw(...)
    {
        throw ExtStatusException(E_OUTOFMEMORY);
    }
    void DECLSPEC_NORETURN ThrowContinueSearch(void) throw(...)
    {
        throw ExtStatusException(DEBUG_EXTENSION_CONTINUE_SEARCH);
    }
    void DECLSPEC_NORETURN ThrowReloadExtension(void) throw(...)
    {
        throw ExtStatusException(DEBUG_EXTENSION_RELOAD_EXTENSION);
    }
    void DECLSPEC_NORETURN WINAPIV ThrowInvalidArg(_In_ PCSTR Format,
                                                    ...) throw(...);
    void DECLSPEC_NORETURN WINAPIV ThrowRemote(_In_ HRESULT Status,
                                               _In_ PCSTR Format,
                                               ...) throw(...);
    void DECLSPEC_NORETURN WINAPIV ThrowStatus(_In_ HRESULT Status,
                                               _In_ PCSTR Format,
                                               ...) throw(...);
    void DECLSPEC_NORETURN WINAPIV
        ThrowLastError(_In_opt_ PCSTR Message = NULL) throw(...)
        {
            ExtStatusException Ex(HRESULT_FROM_WIN32(GetLastError()),
                                  Message);
            throw Ex;
        }

    // Given a full EngExtCpp command method this
    // invokes the method with appropriate argument
    // parsing, Query/Release calls and exception handling.
    HRESULT CallCommand(_In_ ExtCommandDesc* Desc,
                        _In_ PDEBUG_CLIENT Client,
                        _In_opt_ PCSTR Args)
    {
        return CallExtCodeSEH(Desc, Client, Args,
                              NULL, NULL, NULL, NULL);
    }
    // If you're doing a hybrid dbgeng/EngExtCpp extension
    // and you have plain dbgeng code that wants to
    // call an EXT_CLASS method to do some work
    // this will invoke the method with appropriate
    // Query/Release calls and exception handling.
    // No argument parsing is done.
    // If a name is provided then normal failure/exception
    // error messages will be produced, just as
    // is done for a full extension method.
    HRESULT CallRawMethod(_In_ PDEBUG_CLIENT Client,
                          _In_ ExtRawMethod Method,
                          _In_opt_ PVOID Context,
                          _In_opt_ PCSTR Name = NULL)
    {
        return CallExtCodeSEH(NULL, Client, NULL,
                              Method, NULL, Context, Name);
    }
    // Similar to CallRawMethod except that the
    // code invoked is a plain function.
    HRESULT CallRawFunction(_In_ PDEBUG_CLIENT Client,
                            _In_ ExtRawFunction Function,
                            _In_opt_ PVOID Context,
                            _In_opt_ PCSTR Name = NULL)
    {
        return CallExtCodeSEH(NULL, Client, NULL,
                              NULL, Function, Context, Name);
    }

    //
    // Internal data.
    //

    static HMODULE s_Module;
    static char s_String[2000];
    static char s_CircleStringBuffer[2000];
    static char* s_CircleString;
    
    ExtCommandDesc* m_Commands;
    ULONG m_LongestCommandName;
    HRESULT m_CallStatus;
    HRESULT m_MacroStatus;

    typedef BOOL (WINAPI *PFN_SymMatchStringA)(_In_ PCSTR string,
                                               _In_ PCSTR expression,
                                               _In_ BOOL fCase);
    HMODULE m_DbgHelp;
    PFN_SymMatchStringA m_SymMatchStringA;
    
    struct ArgVal
    {
        PCSTR Name;
        PCSTR StrVal;
        ULONG64 NumVal;
    };
    static const ULONG s_MaxArgs = 64;

    ExtCommandDesc* m_CurCommand;
    PCSTR m_RawArgStr;
    PSTR m_ArgCopy;
    ULONG m_NumArgs;
    ULONG m_NumNamedArgs;
    ULONG m_NumUnnamedArgs;
    ULONG m_FirstNamedArg;
    // Unnamed args are packed in the front.
    ArgVal m_Args[s_MaxArgs];

    // Register index caches are cleared in QueryMachineInfo.
    ULONG m_ExtRetIndex;
    ULONG m_TempRegIndex[20];
    
    bool m_ExInitialized;
    
    void WINAPI ExInitialize(void) throw(...);

    HRESULT WINAPI QueryMachineInfo(void);
    HRESULT WINAPI Query(_In_ PDEBUG_CLIENT Start);
    void WINAPI Release(void);

    HRESULT WINAPI CallExtCodeCEH(_In_opt_ ExtCommandDesc* Desc,
                                  _In_opt_ PCSTR Args,
                                  _In_opt_ ExtRawMethod RawMethod,
                                  _In_opt_ ExtRawFunction RawFunction,
                                  _In_opt_ PVOID Context,
                                  _In_opt_ PCSTR RawName);
    HRESULT WINAPI CallExtCodeSEH(_In_opt_ ExtCommandDesc* Desc,
                                  _In_ PDEBUG_CLIENT Client,
                                  _In_opt_ PCSTR Args,
                                  _In_opt_ ExtRawMethod RawMethod,
                                  _In_opt_ ExtRawFunction RawFunction,
                                  _In_opt_ PVOID Context,
                                  _In_opt_ PCSTR RawName);
    
    HRESULT WINAPI CallKnownStructMethod(_In_ ExtKnownStruct* Struct,
                                         _In_ ULONG Flags,
                                         _In_ ULONG64 Offset,
                                         _Out_writes_(*BufferChars) PSTR Buffer,
                                         _Inout_ PULONG BufferChars);
    HRESULT WINAPI CallKnownStruct(_In_ PDEBUG_CLIENT Client,
                                   _In_ ExtKnownStruct* Struct,
                                   _In_ ULONG Flags,
                                   _In_ ULONG64 Offset,
                                   _Out_writes_(*BufferChars) PSTR Buffer,
                                   _Inout_ PULONG BufferChars);
    HRESULT WINAPI HandleKnownStruct(_In_ PDEBUG_CLIENT Client,
                                     _In_ ULONG Flags,
                                     _In_ ULONG64 Offset,
                                     _In_opt_ PCSTR TypeName,
                                     _Out_writes_(*BufferChars) PSTR Buffer,
                                     _Inout_ PULONG BufferChars);

    HRESULT WINAPI HandleQueryValueNames(_In_ PDEBUG_CLIENT Client,
                                         _In_ ULONG Flags,
                                         _Out_writes_(BufferChars) PWSTR Buffer,
                                         _In_ ULONG BufferChars,
                                         _Out_ PULONG BufferNeeded);
    HRESULT WINAPI CallProvideValueMethod(_In_ ExtProvidedValue* ExtVal,
                                          _In_ ULONG Flags,
                                          _Out_ PULONG64 Value,
                                          _Out_ PULONG64 TypeModBase,
                                          _Out_ PULONG TypeId,
                                          _Out_ PULONG TypeFlags);
    HRESULT WINAPI HandleProvideValue(_In_ PDEBUG_CLIENT Client,
                                      _In_ ULONG Flags,
                                      _In_ PCWSTR Name,
                                      _Out_ PULONG64 Value,
                                      _Out_ PULONG64 TypeModBase,
                                      _Out_ PULONG TypeId,
                                      _Out_ PULONG TypeFlags);

    ArgVal* WINAPI FindArg(_In_ PCSTR Name,
                           _In_ bool Required) throw(...);
    PCSTR WINAPI SetRawArgVal(_In_ ExtCommandDesc::ArgDesc* Check,
                              _In_opt_ ArgVal* Val,
                              _In_ bool ExplicitVal,
                              _In_opt_ PCSTR StrVal,
                              _In_ bool StrWritable,
                              _In_ ULONG64 NumVal) throw(...);
    void WINAPI ParseArgs(_In_ ExtCommandDesc* Desc,
                          _In_opt_ PCSTR Args) throw(...);

    void WINAPI OutCommandArg(_In_ ExtCommandDesc::ArgDesc* Arg,
                              _In_ bool Separate);
    void WINAPI HelpCommandArgsSummary(_In_ ExtCommandDesc* Desc);
    void WINAPI OutArgDescOptions(_In_ ExtCommandDesc::ArgDesc* Arg);
    void WINAPI HelpCommand(_In_ ExtCommandDesc* Desc);
    void WINAPI HelpCommandName(_In_ PCSTR Name);
    void WINAPI HelpAll(void);
    void __thiscall help(void);
};

//----------------------------------------------------------------------------
//
// Global forwarders for common methods.
//
//----------------------------------------------------------------------------

#if !defined(EXT_NO_OUTPUT_FUNCTIONS)

void WINAPIV ExtOut(_In_ PCSTR Format, ...);
void WINAPIV ExtWarn(_In_ PCSTR Format, ...);
void WINAPIV ExtErr(_In_ PCSTR Format, ...);
void WINAPIV ExtVerb(_In_ PCSTR Format, ...);

#endif // #if !defined(EXT_NO_OUTPUT_FUNCTIONS)

//----------------------------------------------------------------------------
//
// Supporting macros and utilities.
//
//----------------------------------------------------------------------------

// If you wish to override the class name that is used
// as the derivation from ExtExtension define it
// before including this file.  Otherwise the class
// will be named 'Extension'.
#ifndef EXT_CLASS
#define EXT_CLASS Extension
#endif

extern ExtCheckedPointer<ExtExtension> g_Ext;
extern ExtExtension* g_ExtInstancePtr;

// Put a single use of this macro in one source file.
#define EXT_DECLARE_GLOBALS() \
EXT_CLASS g_ExtInstance; \
ExtExtension* g_ExtInstancePtr = &g_ExtInstance

// Use this macro to forward-declare a command method in your class
// declaration.
#define EXT_COMMAND_METHOD(_Name) \
void _Name(void)

//----------------------------------------------------------------------------
//
// Use this macro to declare an extension command implementation.  It
// will declare the base function that will be exported and
// will start a method on your class for the command
// implementation.
//
// The description string given will automatically be wrapped to
// fit the space it is being displayed in.  Newlines can be embedded
// to force a new line but are not necessary for formatting.
//
// The argument string describes the arguments expected by the
// command.  It is a sequence of the following two major components.
//
// Directives: {{<directive>}}
//
// Indicates a special non-argument directive.  Directives are:
//   custom - Extension does its own argument parsing.
//            Default parsing is disabled.
//   l:<str> - Custom long argument description.  The
//             long argument description is a full description
//             for each argument.
//   opt:<str> - Defines the option prefix characters for
//               commands that don't want to use the default
//               / and -.
//   s:<str> - Custom short argument description.  The
//             short argument description is the argument summary
//             shown with the command name.
//
// Examples:
//
//   {{custom}}{{s:<arg1> <arg2>}}{{l:arg1 - Argument 1\narg2 - Argument 2}}
//
// This defines an extension command that parses its own arguments.
// Such a command should give custom help strings so that the automatic
// !help support has something to display, such as the short and
// long descriptions given here.
//
//   {{opt:+:}}
//
// This changes the argument option prefix characters to + and :,
// so that +arg and :arg can be used instead of /arg and -arg.
//
// Arguments: {[<optname>];[<type>[,<flags>]];[<argname>];[<argdesc>]}
//
// Defines an argument for the extension.  An argument
// has several parts.
//
//   <optname> - Gives the argument's option name that is given
//               in an argument string to pass the argument.
//               Arguments can be unnamed if they are going
//               to be handed positionally.  Unnamed arguments
//               are processed in the order given.
//
//   <type> - Indicates the type of the argument.  The possibilities are:
//            b - Boolean (present/not-present) argument, for flags.
//            e[d][n=(<radix>)][s][v=(<eval>)][<bits>] -
//                Expression argument for getting numeric values.
//                d - Indicates that the expression should be limited
//                    to the next space-delimited subset of the overall
//                    argument string.  This prevents accidental evaluation
//                    of other data following the expression and so
//                    can avoid otherwise unnecessary symbol resolution.
//                n=(<radix>) - Gives a default radix for
//                              expression evaluation.
//                s - Indicates the value is signed and a
//                    bit-size limit can be given for values
//                    that are less than 64-bit.
//                v=(<eval>) - Names an expression evaluator to use
//                             for the expression.
//            s - Space-delimited string argument.
//            x - String-to-end-of-args string argument.
//
//   <flags> - Modifies argument behavior.
//             d=<expr> - Sets default value for argument.
//             ds - Indicates that the default value should not be
//                  displayed in an argument description.
//             o - Argument is optional (default for named arguments).
//             r - Argument is required (default for unnamed arguments).
//
//   <argname> - Argument name to show for the value in help output.
//               This is separate from the option name for non-boolean
//               arguments since they can have both a name and a value.
//               For boolean arguments the argument name is not used.
//
//   <argdesc> - Long argument description to show in help output.
//
// Examples:
//
//   {;en=(10)32,o,d=0x100;flags;Flags to control command}
//
// This defines a command with a single optional expression argument.  The
// argument value will be interpreted in base 10 and must fit in 32 bits.
// If the argument isn't specified the default value of 0x100 will be used.
//
//   {v;b;;Verbose mode}{;s;name;Name of object}
//
// This defines a command with an optional boolean /v and a required
// unnamed string argument.
//
//   {oname;e;expr;Address of object}{eol;x;str;Commands to use}
//
// This defines a command which has an optional expression argument
// /oname <expr> and an optional end-of-string argument /eol <str>.
// If /eol is present it will get the remainder of the command string
// and no further arguments will be parsed.
// 
// /? is automatically provided for all commands unless custom
// argument parsing is indicated.
//
// A NULL or empty argument string indicates no arguments.
// Commands are currently limited to a maximum of 64 arguments.
//
//----------------------------------------------------------------------------

// If your extension has direct dbgeng-style extensions that
// do not use the EngExtCpp entry wrappers you can still create command
// descriptions for them so that the auto-help implementation
// can display help for them along with EngExtCpp methods.
// These descs must always be global.
#define EXT_EXPLICIT_COMMAND_DESC(_Name, _Desc, _Args)                        \
ExtCommandDesc g_##_Name##Desc(#_Name,                                        \
                               NULL,                                          \
                               _Desc,                                         \
                               _Args)

#define EXT_CLASS_COMMAND(_Class, _Name, _Desc, _Args)                        \
ExtCommandDesc g_##_Name##Desc(#_Name,                                        \
                               (ExtCommandMethod)&_Class::_Name,              \
                               _Desc,                                         \
                               _Args);                                        \
EXTERN_C HRESULT CALLBACK                                                     \
_Name(_In_ PDEBUG_CLIENT Client,                                              \
      _In_opt_ PCSTR Args)                                                    \
{                                                                             \
    if (!g_Ext.IsSet())                                                       \
    {                                                                         \
        return E_UNEXPECTED;                                                  \
    }                                                                         \
    return g_Ext->CallCommand(&g_##_Name##Desc, Client, Args);                \
}                                                                             \
void _Class::_Name(void)
#define EXT_COMMAND(_Name, _Desc, _Args) \
    EXT_CLASS_COMMAND(EXT_CLASS, _Name, _Desc, _Args)

// Checks for success and throws an exception for failure.
#define EXT_STATUS(_Expr)                                                     \
    if (FAILED(m_MacroStatus = (_Expr)))                                      \
    {                                                                         \
        throw ExtStatusException(m_MacroStatus);                              \
    } else 0
#define EXT_STATUS_MSG(_Expr, _Msg)                                           \
    if (FAILED(m_MacroStatus = (_Expr)))                                      \
    {                                                                         \
        throw ExtStatusException(m_MacroStatus, _Msg);                        \
    } else 0
#define EXT_STATUS_EMSG(_Expr)                                                \
    if (FAILED(m_MacroStatus = (_Expr)))                                      \
    {                                                                         \
        throw ExtStatusException(m_MacroStatus, #_Expr);                      \
    } else 0

//----------------------------------------------------------------------------
//
// ExtRemoteData is a simple wrapper for a piece of debuggee memory.
// It automatically retrieves small data items and wraps
// other common requests with throwing methods.
//
// Data can be named for more meaningful error messages.
//
//----------------------------------------------------------------------------

class ExtRemoteData
{
public:
    ExtRemoteData(void)
    {
        Clear();
    }
    ExtRemoteData(_In_ ULONG64 Offset,
                  _In_ ULONG Bytes) throw(...)
    {
        Clear();
        Set(Offset, Bytes);
    }
    ExtRemoteData(_In_opt_ PCSTR Name,
                  _In_ ULONG64 Offset,
                  _In_ ULONG Bytes) throw(...)
    {
        Clear();
        m_Name = Name;
        Set(Offset, Bytes);
    }
    
    void Set(_In_ ULONG64 Offset,
             _In_ ULONG Bytes) throw(...)
    {
        m_Offset = Offset;
        m_ValidOffset = true;
        m_Bytes = Bytes;
        if (Bytes <= sizeof(m_Data))
        {
            Read();
        }
        else
        {
            m_ValidData = false;
            m_Data = 0;
        }
    }
    void WINAPI Set(_In_ const DEBUG_TYPED_DATA* Typed);

    void WINAPI Read(void) throw(...);
    void WINAPI Write(void) throw(...);

    ULONG64 WINAPI GetData(_In_ ULONG Request) throw(...);
    void WINAPI SetData(_In_ ULONG64 Data,
                        _In_ ULONG Request,
                        _In_ bool NoWrite = false) throw(...);

    //
    // Fixed-size primitive type accesses.
    // Accesses are validated against the known data size.
    //
    
    CHAR GetChar(void) throw(...)
    {
        return (CHAR)GetData(sizeof(CHAR));
    }
    UCHAR GetUchar(void) throw(...)
    {
        return (UCHAR)GetData(sizeof(UCHAR));
    }
    BOOLEAN GetBoolean(void) throw(...)
    {
        return (BOOLEAN)GetData(sizeof(BOOLEAN));
    }
    bool GetStdBool(void) throw(...)
    {
        return GetData(sizeof(bool)) != 0;
    }
    BOOL GetW32Bool(void) throw(...)
    {
        return (BOOL)GetData(sizeof(BOOL));
    }
    SHORT GetShort(void) throw(...)
    {
        return (SHORT)GetData(sizeof(SHORT));
    }
    USHORT GetUshort(void) throw(...)
    {
        return (USHORT)GetData(sizeof(USHORT));
    }
    LONG GetLong(void) throw(...)
    {
        return (LONG)GetData(sizeof(LONG));
    }
    ULONG GetUlong(void) throw(...)
    {
        return (ULONG)GetData(sizeof(ULONG));
    }
    LONG64 GetLong64(void) throw(...)
    {
        return (LONG64)GetData(sizeof(LONG64));
    }
    ULONG64 GetUlong64(void) throw(...)
    {
        return (ULONG64)GetData(sizeof(ULONG64));
    }
    float GetFloat(void) throw(...)
    {
        GetData(sizeof(float));
        return *(float *)&m_Data;
    }
    double GetDouble(void) throw(...)
    {
        GetData(sizeof(double));
        return *(double *)&m_Data;
    }
    
    void SetChar(_In_ CHAR Data) throw(...)
    {
        SetData(Data, sizeof(CHAR));
    }
    void SetUchar(_In_ UCHAR Data) throw(...)
    {
        SetData(Data, sizeof(UCHAR));
    }
    void SetBoolean(_In_ BOOLEAN Data) throw(...)
    {
        SetData(Data, sizeof(BOOLEAN));
    }
    void SetStdBool(_In_ bool Data) throw(...)
    {
        SetData(Data, sizeof(bool));
    }
    void SetW32Bool(_In_ BOOL Data) throw(...)
    {
        SetData(Data, sizeof(BOOL));
    }
    void SetShort(_In_ SHORT Data) throw(...)
    {
        SetData(Data, sizeof(SHORT));
    }
    void SetUshort(_In_ USHORT Data) throw(...)
    {
        SetData(Data, sizeof(USHORT));
    }
    void SetLong(_In_ LONG Data) throw(...)
    {
        SetData(Data, sizeof(LONG));
    }
    void SetUlong(_In_ ULONG Data) throw(...)
    {
        SetData(Data, sizeof(ULONG));
    }
    void SetLong64(_In_ LONG64 Data) throw(...)
    {
        SetData(Data, sizeof(LONG64));
    }
    void SetUlong64(_In_ ULONG64 Data) throw(...)
    {
        SetData(Data, sizeof(ULONG64));
    }
    void SetFloat(_In_ float Data) throw(...)
    {
        SetData(*(ULONG*)&Data, sizeof(float));
    }
    void SetDouble(_In_ double Data) throw(...)
    {
        SetData(*(ULONG64*)&Data, sizeof(double));
    }
    
    //
    // Pointer-size primitive type queries.
    // The data is always promoted to the largest size.
    // Accesses are validated against the known data size.
    //
    
    LONG64 GetLongPtr(void) throw(...)
    {
        return g_Ext->m_PtrSize == 8 ?
            (LONG64)GetData(g_Ext->m_PtrSize) :
            (LONG)GetData(g_Ext->m_PtrSize);
    }
    ULONG64 GetUlongPtr(void) throw(...)
    {
        return (ULONG64)GetData(g_Ext->m_PtrSize);
    }

    //
    // Pointer-size primitive type wries.
    // The data is always written with the current pointer size.
    // Accesses are validated against the known data size.
    //
    
    void SetLongPtr(_In_ LONG64 Data) throw(...)
    {
        SetData(Data, g_Ext->m_PtrSize);
    }
    void SetUlongPtr(_In_ ULONG64 Data) throw(...)
    {
        SetData(Data, g_Ext->m_PtrSize);
    }

    //
    // Pointer data read, with automatic sign extension.
    //
    
    ULONG64 GetPtr(void) throw(...)
    {
        return g_Ext->m_PtrSize == 8 ?
            GetData(g_Ext->m_PtrSize) :
            (LONG)GetData(g_Ext->m_PtrSize);
    }

    //
    // Pointer data write, using the current pointer size.
    //
    
    void SetPtr(_In_ ULONG64 Data) throw(...)
    {
        SetData(Data, g_Ext->m_PtrSize);
    }

    //
    // Buffer reads for larger data.
    //

    ULONG WINAPI ReadBuffer(_Out_writes_bytes_(Bytes) PVOID Buffer,
                            _In_ ULONG Bytes,
                            _In_ bool MustReadAll = true) throw(...);
    ULONG WINAPI WriteBuffer(_In_reads_bytes_(Bytes) PVOID Buffer,
                             _In_ ULONG Bytes,
                             _In_ bool MustWriteAll = true) throw(...);
    
    //
    // String reads.
    // If you are only reading the string in order
    // to output it it's easier to use %ma/%mu in
    // your Out() call so that dbgeng handles the
    // string read for you.
    //

    PSTR WINAPI GetString(_Out_writes_opt_(BufferChars) PSTR Buffer,
                          _In_ ULONG BufferChars,
                          _In_ ULONG MaxChars = 1024,
                          _In_ bool MustFit = false,
                          _Out_opt_ PULONG NeedChars = NULL) throw(...);
    PWSTR WINAPI GetString(_Out_writes_opt_(BufferChars) PWSTR Buffer,
                           _In_ ULONG BufferChars,
                           _In_ ULONG MaxChars = 1024,
                           _In_ bool MustFit = false,
                           _Out_opt_ PULONG NeedChars = NULL) throw(...);
    PSTR WINAPI GetString(_Inout_ ExtBuffer<char>* Buffer,
                          _In_ ULONG MaxChars = 1024) throw(...);
    PWSTR WINAPI GetString(_Inout_ ExtBuffer<WCHAR>* Buffer,
                           _In_ ULONG MaxChars = 1024) throw(...);
    
    PCSTR m_Name;
    ULONG64 m_Offset;
    bool m_ValidOffset;
    ULONG m_Bytes;
    ULONG64 m_Data;
    bool m_ValidData;
    bool m_Physical;
    ULONG m_SpaceFlags;

protected:
    void Clear(void)
    {
        m_Name = NULL;
        m_Offset = 0;
        m_ValidOffset = false;
        m_Bytes = 0;
        m_Data = 0;
        m_ValidData = false;
        m_Physical = false;
        m_SpaceFlags = 0;
    }
};

//----------------------------------------------------------------------------
//
// ExtRemoteTyped is an enhanced remote data object that understands
// data typed with type information from symbols.  It is initialized
// to a particular object by symbol or cast, after which it can
// be used like an object of the given type.
//
// All expressions are C++ syntax by default.
//
//----------------------------------------------------------------------------

class ExtRemoteTyped : public ExtRemoteData
{
public:
    ExtRemoteTyped(void)
    {
        Clear();
    }
    ExtRemoteTyped(_In_ PCSTR Expr) throw(...)
    {
        m_Release = false;
        Set(Expr);
    }
    ExtRemoteTyped(_In_ const DEBUG_TYPED_DATA* Typed) throw(...)
    {
        m_Release = false;
        Copy(Typed);
    }
    ExtRemoteTyped(_In_ const ExtRemoteTyped& Typed) throw(...)
    {
        m_Release = false;
        Copy(Typed);
    }
    ExtRemoteTyped(_In_ PCSTR Expr,
                   _In_ ULONG64 Offset) throw(...)
    {
        m_Release = false;
        Set(Expr, Offset);
    }
    ExtRemoteTyped(_In_ PCSTR Type,
                   _In_ ULONG64 Offset,
                   _In_ bool PtrTo,
                   _Inout_opt_ PULONG64 CacheCookie = NULL,
                   _In_opt_ PCSTR LinkField = NULL) throw(...)
    {
        m_Release = false;
        Set(Type, Offset, PtrTo, CacheCookie, LinkField);
    }
    ~ExtRemoteTyped(void)
    {
        Release();
    }

    ExtRemoteTyped& operator=(_In_ const DEBUG_TYPED_DATA* Typed) throw(...)
    {
        Copy(Typed);
        return *this;
    }
    ExtRemoteTyped& operator=(_In_ const ExtRemoteTyped& Typed) throw(...)
    {
        Copy(Typed);
        return *this;
    }
    
    void WINAPI Copy(_In_ const DEBUG_TYPED_DATA* Typed) throw(...);
    void Copy(_In_ const ExtRemoteTyped& Typed) throw(...)
    {
        if (Typed.m_Release)
        {
            Copy(&Typed.m_Typed);
        }
        else
        {
            Clear();
        }
    }
    
    void WINAPI Set(_In_ PCSTR Expr) throw(...);
    void WINAPI Set(_In_ PCSTR Expr,
                    _In_ ULONG64 Offset) throw(...);
    void WINAPI Set(_In_ bool PtrTo,
                    _In_ ULONG64 TypeModBase,
                    _In_ ULONG TypeId,
                    _In_ ULONG64 Offset) throw(...);
    void WINAPI Set(_In_ PCSTR Type,
                    _In_ ULONG64 Offset,
                    _In_ bool PtrTo,
                    _Inout_opt_ PULONG64 CacheCookie = NULL,
                    _In_opt_ PCSTR LinkField = NULL) throw(...);

    // Uses a circle string.
    void WINAPIV SetPrint(_In_ PCSTR Format,
                          ...) throw(...);

    bool HasField(_In_ PCSTR Field)
    {
        return ErtIoctl("HasField",
                        EXT_TDOP_HAS_FIELD,
                        ErtIn | ErtIgnoreError,
                        Field) == S_OK;
    }

    ULONG GetTypeSize(void) throw(...)
    {
        ULONG Size;
        
        ErtIoctl("GetTypeSize", EXT_TDOP_GET_TYPE_SIZE, ErtIn,
                 NULL, 0, NULL, NULL, 0, &Size);
        return Size;
    }
    
    ULONG WINAPI GetFieldOffset(_In_ PCSTR Field) throw(...);
    
    ExtRemoteTyped WINAPI Field(_In_ PCSTR Field) throw(...);
    ExtRemoteTyped WINAPI ArrayElement(_In_ LONG64 Index) throw(...);
    ExtRemoteTyped WINAPI Dereference(void) throw(...);
    ExtRemoteTyped WINAPI GetPointerTo(void) throw(...);
    ExtRemoteTyped WINAPI Eval(_In_ PCSTR Expr) throw(...);

    ExtRemoteTyped operator[](_In_ LONG Index)
    {
        return ArrayElement(Index);
    }
    ExtRemoteTyped operator[](_In_ ULONG Index)
    {
        return ArrayElement((LONG64)Index);
    }
    ExtRemoteTyped operator[](_In_ LONG64 Index)
    {
        return ArrayElement(Index);
    }
    ExtRemoteTyped operator[](_In_ ULONG64 Index)
    {
        if (Index > 0x7fffffffffffffffUI64)
        {
            g_Ext->ThrowRemote
                (HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW),
                 "Array index too large");
        }
        return ArrayElement((LONG64)Index);
    }
    ExtRemoteTyped operator*(void)
    {
        return Dereference();
    }
    
    // Uses the circular string buffer.
    PSTR WINAPI GetTypeName(void) throw(...);
    // Uses the circular string buffer.
    PSTR WINAPI GetSimpleValue(void) throw(...);
    
    void OutTypeName(void) throw(...)
    {
        ErtIoctl("OutTypeName", EXT_TDOP_OUTPUT_TYPE_NAME, ErtIn);
    }
    void OutSimpleValue(void) throw(...)
    {
        ErtIoctl("OutSimpleValue", EXT_TDOP_OUTPUT_SIMPLE_VALUE, ErtIn);
    }
    void OutFullValue(void) throw(...)
    {
        ErtIoctl("OutFullValue", EXT_TDOP_OUTPUT_FULL_VALUE, ErtIn);
    }
    void OutTypeDefinition(void) throw(...)
    {
        ErtIoctl("OutTypeDefinition", EXT_TDOP_OUTPUT_TYPE_DEFINITION, ErtIn);
    }
    
    void Release(void)
    {
        if (m_Release)
        {
            ErtIoctl("Release", EXT_TDOP_RELEASE, ErtIn | ErtIgnoreError);
            Clear();
        }
    }

    static ULONG WINAPI GetTypeFieldOffset(_In_ PCSTR Type,
                                           _In_ PCSTR Field) throw(...);

    DEBUG_TYPED_DATA m_Typed;
    bool m_Release;

protected:
    static const ULONG ErtIn          = 0x00000001;
    static const ULONG ErtOut         = 0x00000002;
    static const ULONG ErtUncheckedIn = 0x00000004;
    static const ULONG ErtIgnoreError = 0x00000008;
    
    HRESULT WINAPI ErtIoctl(_In_ PCSTR Message,
                            _In_ EXT_TDOP Op,
                            _In_ ULONG Flags,
                            _In_opt_ PCSTR InStr = NULL,
                            _In_ ULONG64 In64 = 0,
                            _Out_opt_ ExtRemoteTyped* Ret = NULL,
                            _Out_writes_opt_(StrBufferChars) PSTR StrBuffer = NULL,
                            _In_ ULONG StrBufferChars = 0,
                            _Out_opt_ PULONG Out32 = NULL);
    void WINAPI Clear(void);
};

//----------------------------------------------------------------------------
//
// ExtRemoteList wraps a basic singly- or double-linked list.
// It can iterate over the list and retrieve nodes both
// forwards and backwards.  It handles both NULL-terminated
// and lists that are circular through a head pointer (NT-style).
//
// When doubly-linked it is assumed that the previous
// pointer immediately follows the next pointer.
//
//----------------------------------------------------------------------------

class ExtRemoteList
{
public:
    ExtRemoteList(_In_ ULONG64 Head,
                  _In_ ULONG LinkOffset,
                  _In_ bool Double = false)
    {
        m_Head = Head;
        m_LinkOffset = LinkOffset;
        m_Double = Double;
        m_MaxIter = 65536;
    }
    ExtRemoteList(_In_ ExtRemoteData& Head,
                  _In_ ULONG LinkOffset,
                  _In_ bool Double = false)
    {
        m_Head = Head.m_Offset;
        m_LinkOffset = LinkOffset;
        m_Double = Double;
        m_MaxIter = 65536;
    }

    void StartHead(void)
    {
        m_Node.Set(m_Head, g_Ext->m_PtrSize);
        m_CurIter = 0;
    }
    void StartTail(void)
    {
        if (!m_Double)
        {
            g_Ext->ThrowRemote(E_INVALIDARG,
                               "ExtRemoteList is singly-linked");
        }
        
        m_Node.Set(m_Head + g_Ext->m_PtrSize, g_Ext->m_PtrSize);
        m_CurIter = 0;
    }

    bool
    IsValid(
        ULONG64 Pointer
    )
    {
            UCHAR Buffer[4];
            ULONG BytesRead;

            HRESULT hResult = g_Ext->m_Data->ReadVirtual(Pointer, Buffer, sizeof(Buffer), &BytesRead);
            if (hResult != S_OK) return FALSE;

            return TRUE;
    }

    bool HasNode(void)
    {
        g_Ext->ThrowInterrupt();
        ULONG64 NodeOffs = m_Node.GetPtr();
        return NodeOffs != 0 && NodeOffs != m_Head && IsValid(NodeOffs);
    }
    ULONG64 GetNodeOffset(void)
    {
        return m_Node.GetPtr() - m_LinkOffset;
    }
    void Next(void)
    {
        if (++m_CurIter > m_MaxIter)
        {
            g_Ext->ThrowRemote(E_INVALIDARG,
                               "List iteration count exceeded, loop assumed");
        }
        
        m_Node.Set(m_Node.GetPtr(), g_Ext->m_PtrSize);
    }
    void Prev(void)
    {
        g_Ext->ThrowInterrupt();

        if (!m_Double)
        {
            g_Ext->ThrowRemote(E_INVALIDARG,
                               "ExtRemoteList is singly-linked");
        }
        
        if (++m_CurIter > m_MaxIter)
        {
            g_Ext->ThrowRemote(E_INVALIDARG,
                               "List iteration count exceeded, loop assumed");
        }
        
        m_Node.Set(m_Node.GetPtr() + g_Ext->m_PtrSize, g_Ext->m_PtrSize);
    }
    
    ULONG64 m_Head;
    ULONG m_LinkOffset;
    bool m_Double;
    ULONG m_MaxIter;
    ExtRemoteData m_Node;
    ULONG m_CurIter;
};

//----------------------------------------------------------------------------
//
// ExtRemoteTypedList enhances the basic ExtRemoteList to
// understand the type of the nodes in the list and to
// automatically determine link offsets from type information.
//
//----------------------------------------------------------------------------

class ExtRemoteTypedList : public ExtRemoteList
{
public:
    ExtRemoteTypedList(_In_ ULONG64 Head,
                       _In_ PCSTR Type,
                       _In_ PCSTR LinkField,
                       _In_ ULONG64 TypeModBase = 0,
                       _In_ ULONG TypeId = 0,
                       _Inout_opt_ PULONG64 CacheCookie = NULL,
                       _In_ bool Double = false) throw(...)
        : ExtRemoteList(Head, 0, Double)
    {
        SetTypeAndLink(Type, LinkField, TypeModBase, TypeId, CacheCookie);
    }
    ExtRemoteTypedList(_In_ ExtRemoteData& Head,
                       _In_ PCSTR Type,
                       _In_ PCSTR LinkField,
                       _In_ ULONG64 TypeModBase = 0,
                       _In_ ULONG TypeId = 0,
                       _Inout_opt_ PULONG64 CacheCookie = NULL,
                       _In_ bool Double = false) throw(...)
        : ExtRemoteList(Head, 0, Double)
    {
        SetTypeAndLink(Type, LinkField, TypeModBase, TypeId, CacheCookie);
    }

    void SetTypeAndLink(_In_ PCSTR Type,
                        _In_ PCSTR LinkField,
                        _In_ ULONG64 TypeModBase = 0,
                        _In_ ULONG TypeId = 0,
                        _Inout_opt_ PULONG64 CacheCookie = NULL) throw(...)
    {
        m_Type = Type;
        m_TypeModBase = TypeModBase;
        m_TypeId = TypeId;
        if (CacheCookie)
        {
            m_LinkOffset = g_Ext->GetCachedFieldOffset(CacheCookie,
                                                       Type,
                                                       LinkField,
                                                       &m_TypeModBase,
                                                       &m_TypeId);
        }
        else
        {
            m_LinkOffset = ExtRemoteTyped::GetTypeFieldOffset(Type, LinkField);
        }
    }

    ExtRemoteTyped GetTypedNodePtr(void) throw(...)
    {
        ExtRemoteTyped Typed;

        if (m_TypeId)
        {
            Typed.Set(true, m_TypeModBase, m_TypeId,
                      m_Node.GetPtr() - m_LinkOffset);
        }
        else
        {
            Typed.SetPrint("(%s*)0x%I64x",
                           m_Type, m_Node.GetPtr() - m_LinkOffset);

            // Save the type info so that future nodes
            // can be resolved without needing
            // expression evaluation.
            ExtRemoteTyped Deref = Typed.Dereference();
            m_TypeModBase = Deref.m_Typed.ModBase;
            m_TypeId = Deref.m_Typed.TypeId;
        }
        return Typed;
    }
    ExtRemoteTyped GetTypedNode(void) throw(...)
    {
        ExtRemoteTyped Typed;
        
        if (m_TypeId)
        {
            Typed.Set(false, m_TypeModBase, m_TypeId,
                      m_Node.GetPtr() - m_LinkOffset);
        }
        else
        {
            Typed.SetPrint("*(%s*)0x%I64x",
                           m_Type, m_Node.GetPtr() - m_LinkOffset);

            // Save the type info so that future nodes
            // can be resolved without needing
            // expression evaluation.
            m_TypeModBase = Typed.m_Typed.ModBase;
            m_TypeId = Typed.m_Typed.TypeId;
        }
        return Typed;
    }

    PCSTR m_Type;
    ULONG64 m_TypeModBase;
    ULONG m_TypeId;
};

//----------------------------------------------------------------------------
//
// Helpers for handling well-known NT data and types.
//
//----------------------------------------------------------------------------

class ExtNtOsInformation
{
public:
    //
    // Kernel mode.
    //
    
    static ULONG64 WINAPI GetKernelLoadedModuleListHead(void);
    static ExtRemoteTypedList WINAPI GetKernelLoadedModuleList(void);
    static ExtRemoteTyped WINAPI GetKernelLoadedModule(_In_ ULONG64 Offset);
    
    static ULONG64 WINAPI GetKernelProcessListHead(void);
    static ExtRemoteTypedList WINAPI GetKernelProcessList(void);
    static ExtRemoteTyped WINAPI GetKernelProcess(_In_ ULONG64 Offset);

    static ULONG64 WINAPI GetKernelProcessThreadListHead(_In_ ULONG64 Process);
    static ExtRemoteTypedList WINAPI GetKernelProcessThreadList(_In_ ULONG64 Process);
    static ExtRemoteTyped WINAPI GetKernelThread(_In_ ULONG64 Offset);
    
    //
    // User mode.
    //

    static ULONG64 WINAPI GetUserLoadedModuleListHead(_In_ bool NativeOnly = false);
    static ExtRemoteTypedList
        WINAPI GetUserLoadedModuleList(_In_ bool NativeOnly = false);
    static ExtRemoteTyped WINAPI GetUserLoadedModule(_In_ ULONG64 Offset,
                                              _In_ bool NativeOnly = false);

    //
    // PEB and TEB.
    //
    // The alternate PEB and TEB are secondary PEB and TEB
    // data, such as the 32-bit PEB and TEB in a WOW64
    // debugging session.  They may or may not be defined
    // depending on the session.
    //

    static ULONG64 WINAPI GetOsPebPtr(void);
    static ExtRemoteTyped WINAPI GetOsPeb(_In_ ULONG64 Offset);
    static ExtRemoteTyped GetOsPeb(void)
    {
        return GetOsPeb(GetOsPebPtr());
    }
    
    static ULONG64 WINAPI GetOsTebPtr(void);
    static ExtRemoteTyped WINAPI GetOsTeb(_In_ ULONG64 Offset);
    static ExtRemoteTyped GetOsTeb(void)
    {
        return GetOsTeb(GetOsTebPtr());
    }
    
    static ULONG64 WINAPI GetAltPebPtr(void);
    static ExtRemoteTyped WINAPI GetAltPeb(_In_ ULONG64 Offset);
    static ExtRemoteTyped GetAltPeb(void)
    {
        return GetAltPeb(GetAltPebPtr());
    }
    
    static ULONG64 WINAPI GetAltTebPtr(void);
    static ExtRemoteTyped WINAPI GetAltTeb(_In_ ULONG64 Offset);
    static ExtRemoteTyped GetAltTeb(void)
    {
        return GetAltTeb(GetAltTebPtr());
    }
    
    static ULONG64 WINAPI GetCurPebPtr(void);
    static ExtRemoteTyped WINAPI GetCurPeb(_In_ ULONG64 Offset);
    static ExtRemoteTyped GetCurPeb(void)
    {
        return GetCurPeb(GetCurPebPtr());
    }
    
    static ULONG64 WINAPI GetCurTebPtr(void);
    static ExtRemoteTyped WINAPI GetCurTeb(_In_ ULONG64 Offset);
    static ExtRemoteTyped GetCurTeb(void)
    {
        return GetCurTeb(GetCurTebPtr());
    }
    
    //
    // Utilities.
    //

    static ULONG64 WINAPI GetNtDebuggerData(_In_ ULONG DataOffset,
                                            _In_ PCSTR Symbol,
                                            _In_ ULONG Flags);

protected:
    static ULONG64 s_KernelLoadedModuleBaseInfoCookie;
    static ULONG64 s_KernelProcessBaseInfoCookie;
    static ULONG64 s_KernelThreadBaseInfoCookie;
    static ULONG64 s_KernelProcessThreadListFieldCookie;
    static ULONG64 s_UserOsLoadedModuleBaseInfoCookie;
    static ULONG64 s_UserAltLoadedModuleBaseInfoCookie;
    static ULONG64 s_OsPebBaseInfoCookie;
    static ULONG64 s_AltPebBaseInfoCookie;
    static ULONG64 s_OsTebBaseInfoCookie;
    static ULONG64 s_AltTebBaseInfoCookie;
};

//----------------------------------------------------------------------------
//
// Number-to-string helpers for things like #define translations.
//
//----------------------------------------------------------------------------

//
// Convenience macros for filling define declarations.
//

#define EXT_DEFINE_DECL(_Def) \
    { #_Def, _Def },
#define EXT_DEFINE_END { NULL, 0 }

// In order to avoid #define replacement on the names
// these macros cannot be nested macros.
#define EXT_DEFINE_DECL2(_Def1, _Def2) \
    { #_Def1, _Def1 }, { #_Def2, _Def2 }
#define EXT_DEFINE_DECL3(_Def1, _Def2, _Def3) \
    { #_Def1, _Def1 }, { #_Def2, _Def2 }, { #_Def3, _Def3 }
#define EXT_DEFINE_DECL4(_Def1, _Def2, _Def3, _Def4) \
    { #_Def1, _Def1 }, { #_Def2, _Def2 }, { #_Def3, _Def3 }, { #_Def4, _Def4 }
#define EXT_DEFINE_DECL5(_Def1, _Def2, _Def3, _Def4, _Def5) \
    { #_Def1, _Def1 }, { #_Def2, _Def2 }, { #_Def3, _Def3 },\
    { #_Def4, _Def4 }, { #_Def5, _Def5 }
#define EXT_DEFINE_DECL6(_Def1, _Def2, _Def3, _Def4, _Def5, _Def6) \
    { #_Def1, _Def1 }, { #_Def2, _Def2 }, { #_Def3, _Def3 },\
    { #_Def4, _Def4 }, { #_Def5, _Def5 }, { #_Def6, _Def6 }
#define EXT_DEFINE_DECL7(_Def1, _Def2, _Def3, _Def4, _Def5, _Def6, _Def7) \
    { #_Def1, _Def1 }, { #_Def2, _Def2 }, { #_Def3, _Def3 },\
    { #_Def4, _Def4 }, { #_Def5, _Def5 }, { #_Def6, _Def6 }, { #_Def7, _Def7 }

//
// Convenience macros for declaring global maps.
//

#define EXT_DEFINE_MAP_DECL(_Name, _Flags) \
ExtDefineMap g_##_Name##DefineMap(g_##_Name##Defines, _Flags)

#define EXT_DEFINE_MAP1(_Name, _Flags, _Def1) \
ExtDefine g_##_Name##Defines[] = { \
    { #_Def1, _Def1 }, EXT_DEFINE_END \
}; EXT_DEFINE_MAP_DECL(_Name, _Flags)
#define EXT_DEFINE_MAP2(_Name, _Flags, _Def1, _Def2) \
ExtDefine g_##_Name##Defines[] = { \
    { #_Def1, _Def1 }, { #_Def2, _Def2 }, EXT_DEFINE_END \
}; EXT_DEFINE_MAP_DECL(_Name, _Flags)
#define EXT_DEFINE_MAP3(_Name, _Flags, _Def1, _Def2, _Def3) \
ExtDefine g_##_Name##Defines[] = { \
    { #_Def1, _Def1 }, { #_Def2, _Def2 }, { #_Def3, _Def3 },\
    EXT_DEFINE_END \
}; EXT_DEFINE_MAP_DECL(_Name, _Flags)
#define EXT_DEFINE_MAP4(_Name, _Flags, _Def1, _Def2, _Def3, _Def4) \
ExtDefine g_##_Name##Defines[] = { \
    { #_Def1, _Def1 }, { #_Def2, _Def2 }, { #_Def3, _Def3 },\
    { #_Def4, _Def4 }, EXT_DEFINE_END \
}; EXT_DEFINE_MAP_DECL(_Name, _Flags)
#define EXT_DEFINE_MAP5(_Name, _Flags, _Def1, _Def2, _Def3, _Def4, _Def5) \
ExtDefine g_##_Name##Defines[] = { \
    { #_Def1, _Def1 }, { #_Def2, _Def2 }, { #_Def3, _Def3 },\
    { #_Def4, _Def4 }, { #_Def5, _Def5 }, EXT_DEFINE_END \
}; EXT_DEFINE_MAP_DECL(_Name, _Flags)
#define EXT_DEFINE_MAP6(_Name, _Flags, _Def1, _Def2, _Def3, _Def4, _Def5, _Def6) \
ExtDefine g_##_Name##Defines[] = { \
    { #_Def1, _Def1 }, { #_Def2, _Def2 }, { #_Def3, _Def3 },\
    { #_Def4, _Def4 }, { #_Def5, _Def5 }, { #_Def6, _Def6 },\
    EXT_DEFINE_END \
}; EXT_DEFINE_MAP_DECL(_Name, _Flags)
#define EXT_DEFINE_MAP7(_Name, _Flags, _Def1, _Def2, _Def3, _Def4, _Def5, _Def6, _Def7) \
ExtDefine g_##_Name##Defines[] = { \
    { #_Def1, _Def1 }, { #_Def2, _Def2 }, { #_Def3, _Def3 },\
    { #_Def4, _Def4 }, { #_Def5, _Def5 }, { #_Def6, _Def6 },\
    { #_Def7, _Def7 }, EXT_DEFINE_END \
}; EXT_DEFINE_MAP_DECL(_Name, _Flags)

#define EXT_DEFINE_MAP_BEGIN(_Name) \
ExtDefine g_##_Name##Defines[] = {

#define EXT_DEFINE_MAP_END(_Name, _Flags) \
    EXT_DEFINE_END \
}; EXT_DEFINE_MAP_DECL(_Name, _Flags);

struct ExtDefine
{
    PCSTR Name;
    ULONG64 Value;
};

class ExtDefineMap
{
public:
    ExtDefineMap(_In_ ExtDefine* Defines,
                 _In_ ULONG Flags)
    {
        m_Defines = Defines;
        m_Flags = Flags;
    };

    static const ULONG Bitwise         = 0x00000001;
    static const ULONG OutValue        = 0x00000002;
    static const ULONG OutValue32      = 0x00000004;
    static const ULONG OutValue64      = 0x00000008;
    static const ULONG OutValueAny     = OutValue | OutValue32 | OutValue64;
    static const ULONG OutValueAlready = 0x00000010;
    static const ULONG ValueAny        = OutValueAny | OutValueAlready;
    
    // Defines are searched in the order given for
    // defines where the full value of the define is
    // included in the argument value.  Multi-bit
    // defines should come before single-bit defines
    // so that they take priority for bitwise maps.
    ExtDefine* WINAPI Map(_In_ ULONG64 Value);
    PCSTR WINAPI MapStr(_In_ ULONG64 Value,
                        _In_opt_ PCSTR InvalidStr = NULL);

    // For a bitwise map, outputs all defines
    // that can be found in the value.
    // For non-bitwise, outputs the matching define.
    // Uses wrapped output.
    void WINAPI Out(_In_ ULONG64 Value,
                    _In_ ULONG Flags = 0,
                    _In_opt_ PCSTR InvalidStr = NULL);
    
    ExtDefine* m_Defines;
    ULONG m_Flags;
};

//----------------------------------------------------------------------------
//
// Output capture helper class.
//
//----------------------------------------------------------------------------

template<typename _CharType, typename _BaseClass>
class ExtCaptureOutput : public _BaseClass
{
public:
    ExtCaptureOutput(void)
    {
        m_Started = false;
        m_Text = NULL;
        m_CharTypeSize = (ULONG) sizeof(_CharType);
        Delete();
    }
    ~ExtCaptureOutput(void)
    {
        Delete();
    }
    
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        _In_ REFIID InterfaceId,
        _Out_ PVOID* Interface
        )
    {
        *Interface = NULL;

        if (IsEqualIID(InterfaceId, __uuidof(IUnknown)) ||
            IsEqualIID(InterfaceId, __uuidof(_BaseClass)))
        {
            *Interface = (_BaseClass *)this;
            AddRef();
            return S_OK;
        }
        else
        {
            return E_NOINTERFACE;
        }
    }
    STDMETHOD_(ULONG, AddRef)(
        THIS
        )
    {
        // This class is designed to be non-dynamic so
        // there's no true refcount.
        return 1;
    }
    STDMETHOD_(ULONG, Release)(
        THIS
        )
    {
        // This class is designed to be non-dynamic so
        // there's no true refcount.
        return 0;
    }
    
    // IDebugOutputCallbacks*.
    STDMETHOD(Output)(
        THIS_
        _In_ ULONG Mask,
        _In_ const _CharType* Text
        )
    {
        ULONG Chars;
        ULONG CharTypeSize = (ULONG) sizeof(_CharType);

        UNREFERENCED_PARAMETER(Mask);
        
        if (CharTypeSize == sizeof(char))
        {
            Chars = (ULONG) strlen((PSTR)Text) + 1;
        }
        else
        {
            Chars = (ULONG) wcslen((PWSTR)Text) + 1;
        }
        if (Chars < 2)
        {
            return S_OK;
        }

        if (0xffffffff / CharTypeSize - m_UsedChars < Chars)
        {
            return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);
        }

        if (m_UsedChars + Chars > m_AllocChars)
        {
            ULONG NewBytes;

            // Overallocate when growing to prevent
            // continuous allocation.
            if (0xffffffff / CharTypeSize - m_UsedChars - Chars > 256)
            {
                NewBytes = (m_UsedChars + Chars + 256) * CharTypeSize;
            }
            else
            {
                NewBytes = (m_UsedChars + Chars) * CharTypeSize;
            }
            PVOID NewMem = realloc(m_Text, NewBytes);
            if (!NewMem)
            {
                return E_OUTOFMEMORY;
            }

            m_Text = (_CharType*)NewMem;
            m_AllocChars = NewBytes / CharTypeSize;
        }

        memcpy(m_Text + m_UsedChars, Text,
               Chars * CharTypeSize);
        // Advance up to but not past the terminator
        // so that it gets overwritten by the next text.
        m_UsedChars += Chars - 1;
        return S_OK;
    }

    void Start(void)
    {
        HRESULT Status;

        if (m_CharTypeSize == sizeof(char))
        {
            if ((Status = g_Ext->m_Client->
                 GetOutputCallbacks((IDebugOutputCallbacks**)
                                    &m_OldOutCb)) != S_OK)
            {
                g_Ext->ThrowStatus(Status,
                                   "Unable to get previous output callback");
            }
            if ((Status = g_Ext->m_Client->
                 SetOutputCallbacks((IDebugOutputCallbacks*)
                                    this)) != S_OK)
            {
                g_Ext->ThrowStatus(Status,
                                   "Unable to set capture output callback");
            }
        }
        else
        {
            if ((Status = g_Ext->m_Client5->
                 GetOutputCallbacksWide((IDebugOutputCallbacksWide**)
                                        &m_OldOutCb)) != S_OK)
            {
                g_Ext->ThrowStatus(Status,
                                   "Unable to get previous output callback");
            }
            if ((Status = g_Ext->m_Client5->
                 SetOutputCallbacksWide((IDebugOutputCallbacksWide*)
                                        this)) != S_OK)
            {
                g_Ext->ThrowStatus(Status,
                                   "Unable to set capture output callback");
            }
        }
            
        m_UsedChars = 0;
        m_Started = true;
    }
    
    void Stop(void)
    {
        HRESULT Status;
        
        m_Started = false;

        if (m_CharTypeSize == sizeof(char))
        {
            if ((Status = g_Ext->m_Client->
                 SetOutputCallbacks((IDebugOutputCallbacks*)
                                    m_OldOutCb)) != S_OK)
            {
                g_Ext->ThrowStatus(Status,
                                   "Unable to restore output callback");
            }
        }
        else
        {
            if ((Status = g_Ext->m_Client5->
                 SetOutputCallbacksWide((IDebugOutputCallbacksWide*)
                                        m_OldOutCb)) != S_OK)
            {
                g_Ext->ThrowStatus(Status,
                                   "Unable to restore output callback");
            }
        }

        m_OldOutCb = NULL;
    }

    void Delete(void)
    {
        if (m_Started)
        {
            Stop();
        }

        free(m_Text);
        m_Text = NULL;
        m_AllocChars = 0;
        m_UsedChars = 0;
    }

    void Execute(_In_ PCSTR Command)
    {
        Start();
        
        // Hide all output from the execution
        // and don't save the command.
        g_Ext->m_Control->Execute(DEBUG_OUTCTL_THIS_CLIENT |
                                  DEBUG_OUTCTL_OVERRIDE_MASK |
                                  DEBUG_OUTCTL_NOT_LOGGED,
                                  Command,
                                  DEBUG_EXECUTE_NOT_LOGGED |
                                  DEBUG_EXECUTE_NO_REPEAT);

        Stop();
    }
    
    const _CharType* GetTextNonNull(void)
    {
        if (m_CharTypeSize == sizeof(char))
        {
            return (_CharType*)(m_Text ? (PCSTR)m_Text : "");
        }
        else
        {
            return (_CharType*)(m_Text ? (PCWSTR)m_Text : L"");
        }
    }
    
    bool m_Started;
    ULONG m_AllocChars;
    ULONG m_UsedChars;
    ULONG m_CharTypeSize;
    _CharType* m_Text;

    _BaseClass* m_OldOutCb;
};
    
typedef ExtCaptureOutput<char, IDebugOutputCallbacks> ExtCaptureOutputA;
typedef ExtCaptureOutput<WCHAR, IDebugOutputCallbacksWide> ExtCaptureOutputW;

#if _MSC_VER >= 800
#pragma warning(default:4121)
#endif
      
#include <poppack.h>

#endif // #ifndef __ENGEXTCPP_HPP__

```

`SwishDbgExt/packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="libyara_vs2015" version="3.5.1" targetFramework="native" />
  <package id="yara-vs2015-binary-dependencies" version="0.0.1" targetFramework="native" />
</packages>
```

`SwishDbgExt/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by SwishDbgExt.rc

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`SwishDbgExt/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// dll.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`SwishDbgExt/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
#define KDEXT_64BIT

#include <dbgeng.h>
#include <wdbgexts.h>

#include <Windows.h>
#include <winver.h>
#include <winsock.h>
#include <bcrypt.h>
#include <WinCrypt.h>

#include <stdio.h>
#include <Strsafe.h>
#include <stdlib.h>
#include <tchar.h>

#include <iostream>
#include <vector>
#include <map>
#include <fstream>

```

`SwishDbgExt/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```