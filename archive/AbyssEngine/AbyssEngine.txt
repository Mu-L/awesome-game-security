Project Path: arc_AbyssEngine_AbyssEngine_cz215cy8

Source Tree:

```txt
arc_AbyssEngine_AbyssEngine_cz215cy8
├── CMakeLists.txt
├── LICENSE
├── README.md
├── cmake
│   └── FindFFMPEG.cmake
├── content
│   └── abyss.ini
├── extra
│   ├── CMakeDMGSetup.scp
│   ├── abyssbadge.ico
│   ├── abysslogo.png
│   ├── dmg-background.png
│   ├── icon.ico
│   ├── icon.png
│   └── macos
│       ├── MacOSXBundleInfo.plist.in
│       └── icon.icns
├── src
│   ├── AbyssEngine.c
│   ├── CMakeLists.txt
│   ├── audio
│   │   ├── AudioStream.c
│   │   ├── AudioStream.h
│   │   └── CMakeLists.txt
│   ├── common
│   │   ├── AbyssConfiguration.c
│   │   ├── AbyssConfiguration.h
│   │   ├── CMakeLists.txt
│   │   ├── FileManager.c
│   │   ├── FileManager.h
│   │   ├── Globals.c
│   │   ├── Globals.h
│   │   ├── Logging.c
│   │   ├── Logging.h
│   │   ├── MemoryStream.c
│   │   ├── MemoryStream.h
│   │   ├── MpqStream.c
│   │   ├── MpqStream.h
│   │   ├── ResourcePaths.h
│   │   ├── RingBuffer.c
│   │   └── RingBuffer.h
│   ├── drawing
│   │   ├── CMakeLists.txt
│   │   ├── Cursor.c
│   │   ├── Cursor.h
│   │   ├── Label.c
│   │   ├── Label.h
│   │   ├── Sprite.c
│   │   └── Sprite.h
│   ├── managers
│   │   ├── AudioManager.c
│   │   ├── AudioManager.h
│   │   ├── CMakeLists.txt
│   │   ├── InputManager.c
│   │   ├── InputManager.h
│   │   ├── VideoManager.c
│   │   └── VideoManager.h
│   ├── scenes
│   │   ├── CMakeLists.txt
│   │   ├── Scene.c
│   │   ├── Scene.h
│   │   ├── SceneIntroVideos.c
│   │   ├── SceneIntroVideos.h
│   │   ├── SceneMainMenu.c
│   │   └── SceneMainMenu.h
│   ├── types
│   │   ├── CMakeLists.txt
│   │   ├── DC6.c
│   │   ├── DC6.h
│   │   ├── DC6Frame.c
│   │   ├── DC6Frame.h
│   │   ├── Font.c
│   │   ├── Font.h
│   │   ├── MPQ.c
│   │   ├── MPQ.h
│   │   ├── MPQBlock.c
│   │   ├── MPQBlock.h
│   │   ├── MPQHash.c
│   │   ├── MPQHash.h
│   │   ├── MPQHeader.c
│   │   ├── MPQHeader.h
│   │   ├── Palette.c
│   │   └── Palette.h
│   └── util
│       ├── BitReader.c
│       ├── BitReader.h
│       ├── CMakeLists.txt
│       ├── Crypto.c
│       ├── Crypto.h
│       ├── Huffman.c
│       ├── Huffman.h
│       ├── Implode.c
│       ├── Implode.h
│       ├── Mutex.c
│       ├── Mutex.h
│       ├── WavDecompress.c
│       └── WavDecompress.h
├── tests
│   ├── CMakeLists.txt
│   └── RingBufferTest.c
└── vcpkg.json

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.20)

list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake")

project(AbyssEngine)

enable_testing()

set(BUILD_SHARED_LIBS OFF)
set(CMAKE_DISABLE_SOURCE_CHANGES ON)
set(CMAKE_DISABLE_IN_SOURCE_BUILD ON)
set(CMAKE_BUILD_TYPE Debug)
set(CMAKE_C_STANDARD 99)
set(CMAKE_DISABLE_SOURCE_CHANGES ON)
set(CMAKE_DISABLE_IN_SOURCE_BUILD ON)

set_property(GLOBAL PROPERTY USE_FOLDERS ON)

function(setup_source_groups curdir)
    file(GLOB children RELATIVE ${CMAKE_CURRENT_SOURCE_DIR}/${curdir} ${curdir}/*)
    foreach (child ${children})
        if (IS_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/${curdir}/${child})
            setup_source_groups(${curdir}/${child})
        else ()
            string(REPLACE "/" "\\" group_name ${curdir})
            source_group(${group_name} FILES ${curdir}/${child})
        endif ()
    endforeach ()
endfunction()

if (NOT CMAKE_BUILD_TYPE)
    message(STATUS "No build type selected, defaulting to Release")
    set(CMAKE_BUILD_TYPE Release)
endif ()

#turn on all warnings
if (CMAKE_C_COMPILER_ID MATCHES "Clang" OR CMAKE_C_COMPILER_ID MATCHES "GNU")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Wextra -Wpedantic")
endif ()

if (CMAKE_C_COMPILER_ID MATCHES "MSVC")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /W4")
endif ()

if (CMAKE_C_COMPILER_ID MATCHES "Clang")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wno-gnu-zero-variadic-macro-arguments")
endif ()

if (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
    # Homebrew ships libarchive keg only, include dirs have to be set manually
    execute_process(
            COMMAND brew --prefix libarchive
            OUTPUT_VARIABLE LIBARCHIVE_PREFIX
            OUTPUT_STRIP_TRAILING_WHITESPACE
            COMMAND_ERROR_IS_FATAL ANY
    )
    set(LibArchive_INCLUDE_DIR "${LIBARCHIVE_PREFIX}/include")
endif ()

find_package(SDL2 REQUIRED)
include_directories(${SDL2_INCLUDE_DIRS})

find_package(ZLIB REQUIRED)
include_directories(${ZLIB_INCLUDE_DIRS})

find_package(LibArchive REQUIRED)
include_directories(${LibArchive_INCLUDE_DIR})

find_package(FFMPEG COMPONENTS AVCODEC AVFORMAT AVUTIL SWSCALE SWRESAMPLE REQUIRED)
include_directories(${FFMPEG_INCLUDE_DIRS})

#add_compile_options(-fsanitize=address -g)
#add_link_options(-fsanitize=address)

add_executable(${PROJECT_NAME} WIN32)
target_sources(${PROJECT_NAME} PRIVATE src/AbyssEngine.c)
add_subdirectory(src)
setup_source_groups(src)


# if WIN32 then SDL2::SDL2main needs to be linked
if (WIN32)
    set(ADDITIONAL_LIBRARIES SDL2::SDL2 SDL2::SDL2main)
endif ()

if (APPLE)
    find_library(OSX_VIDEOTOOLBOX VideoToolbox)
    find_library(OSX_COREMEDIA CoreMedia)
    find_library(OSX_SECURITY Security)
    set(ADDITIONAL_LIBRARIES
            ${OSX_VIDEOTOOLBOX}
            ${OSX_COREMEDIA}
            ${OSX_SECURITY}
    )
elseif (UNIX)
    set(ADDITIONAL_LIBRARIES "m")
endif ()

target_link_libraries(AbyssEngine
        ${SDL2_LIBRARIES}
        ${ZLIB_LIBRARIES}
        ${LibArchive_LIBRARIES}
        ${FFMPEG_LIBRARIES}
        ${ADDITIONAL_LIBRARIES}
)

if (NOT DEFINED GITHUB_ACTIONS)
    if (UNIX)
        # Find clang-format executable
        find_program(CLANG_FORMAT_EXECUTABLE NAMES clang-format)

        # Check if clang-format executable is found
        if (NOT CLANG_FORMAT_EXECUTABLE)
            message(FATAL_ERROR "clang-format not found. Please install clang-format or specify its path manually.")
        endif ()

        # Find all C and H files in the src directory
        file(GLOB_RECURSE ALL_SOURCE_FILES "${CMAKE_SOURCE_DIR}/src/*.c" "${CMAKE_SOURCE_DIR}/src/*.h")

        # Define a custom target and command to run clang-format
        add_custom_target(
                clang-format
                COMMAND ${CLANG_FORMAT_EXECUTABLE} -i ${ALL_SOURCE_FILES}
                COMMENT "Running clang-format on all C and H files"
                VERBATIM
        )
    endif ()
endif ()

if (APPLE)
    if (NOT DEFINED GITHUB_ACTIONS)
        # Add the clang-format target as a dependency for Xcode
        add_dependencies(${PROJECT_NAME} clang-format)
    endif ()

    file(COPY "${CMAKE_CURRENT_SOURCE_DIR}/extra/macos/" DESTINATION "${CMAKE_CURRENT_BINARY_DIR}/AbyssEngine.app/Contents/Resources")
    set_target_properties(AbyssEngine PROPERTIES
            MACOSX_BUNDLE TRUE
            MACOSX_BUNDLE_BUNDLE_NAME "Abyss Engine"
            MACOSX_BUNDLE_BUNDLE_VERSION "0.1"
            PRODUCT_BUNDLE_IDENTIFIER "com.abyssengine"
            MACOSX_BUNDLE_GUI_IDENTIFIER "com.abyssengine"
            MACOSX_BUNDLE_ICON_FILE "icon.icns"
            #MACOSX_BUNDLE_INFO_PLIST "${CMAKE_SOURCE_DIR}/extra/macos/MacOSXBundleInfo.plist.in"
            MACOSX_BUNDLE_COPYRIGHT "(c) 2023 Timothy Sarbin"
    )

    set_source_files_properties("extra/macos/icon.icns" PROPERTIES
            MACOSX_PACKAGE_LOCATION "Resources"
    )

    set(CMAKE_INSTALL_PREFIX "${CMAKE_BINARY_DIR}/install" CACHE PATH "Install path prefix, prepended onto install directories" FORCE)
else ()
    add_custom_command(TARGET AbyssEngine POST_BUILD
            COMMAND ${CMAKE_COMMAND} -E copy_directory
            ${CMAKE_SOURCE_DIR}/content $<TARGET_FILE_DIR:AbyssEngine>)
endif ()


add_subdirectory(tests)

#include(InstallRequiredSystemLibraries)
#
#install(TARGETS AbyssEngine
#        RUNTIME DESTINATION dist
#        BUNDLE DESTINATION ../MacOS
#)
#
#set(CPACK_PACKAGE_NAME "AbyssEngine")
#set(CPACK_BUNDLE_NAME "AbyssEngine")
#set(CPACK_BUNDLE_PLIST "${CMAKE_SOURCE_DIR}/extra/macos/MacOSXBundleInfo.plist.in")
#set(CPACK_BUNDLE_ICON "${CMAKE_SOURCE_DIR}/extra/macos/icon.icns")
#set(CPACK_PACKAGE_VENDOR "AbyssEngine Developers")
#set(CPACK_PACKAGE_VERSION_MAJOR 0)
#set(CPACK_PACKAGE_VERSION_MINOR 1)
#set(CPACK_PACKAGE_VERSION_PATCH 0)
#set(CPACK_NSIS_MUI_ICON "@CMake_SOURCE_DIR@/extra/icon.ico")
#include(CPack)

```

`LICENSE`:

```
MIT License

Copyright (c) 2024 Timothy Sarbin

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Abyss Engine

Abyss Engine clean-room reimplementation of **Diablo 2**, written in C.
The goal is to recreate the original game engine, but on a portable platform that can also easily be modded and
extended.

This is **not** a reverse-engineering project, and no original code from the game is used. It will also not be
compaible with the original game's save files or multiplayer systems.

Before running the engine, make sure it is [configured](#configuration) properly.

You can hang out with the developers and other community members on `#AbyssEngine` at `irc.libera.chat`.
We no longer maintain a Discord presence. Any such servers are not affiliated with this project.

## Supported Platforms

* Windows 10+ (x64, Arm64)
* macOS (Arm64)
* Linux (x64, Arm64)

Other platforms may work, but are not officially supported.

## Building

### Prerequisites

* CMake 3.20 or later
* A C99 compliant compiler (GCC, Clang, MSVC)

Please make sure you recursively pull the submodules when cloning the repository:

```bash
git submodule update --init --recursive
```

### Compiling

#### Visual Studio 2022 / Clion / VSCode (with CMake Tools extensions)

Open the root project folder in the IDE and build the solution.

#### XCode

Generate an XCode project with cmake:

```bash
mkdir build
cd build
cmake .. -G Xcode
```

Then load the generated Xcode project and build it.

#### Command Line

```bash
mkdir build
cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
```

### Running

On **Linux** and **Windows**, you can run the engine by executing the `abyss` executable in the build directory.

For **macOS**, you can run the engine by executing the `Abyss Engine.app` bundle in the build directory.

Please note that the engine requires the `abyss.ini` configuration file. If you haven't set it,
please refer to the [Configuration](#configuration) section below.

### Output Logs

If you run AbyssEngine from the command line, it will output logs to the console.
On **macOS**, you will need to run the binary directly by executing the binary inside
of the app bundle on the command line:

```bash
./AbyssEngine.app/Contents/MacOS/AbyssEngine
```

## Configuration

### MPQ files

This engine requires the original Diablo 2+LOD MPQ files to run. These files are not included in the repository.
You can legally obtain them by purchasing a physical copy of the game, or from a digital distribution platform
such as battle.net.

There are a lot of pirated versions of the game available online, but we do not condone piracy, and most of them
are modded in a way that is not supported by the engine. Please don't waste developer resources by reporting issues
while using pirated versions of the game.

### abyss.ini

In order for Abyss Engine to run, it needs to load abyss.ini. A template of this file is located at
`/content/abyss.ini` in the source repo, and should be placed in the local settings folder for abyss
based on the platform:

- Windows: `%APPDATA%/abyss/abyss.ini`
- Linux: `~/.config/abyss/abyss.ini`
- MacOS: `~/Library/Application Support/abyss/abyss.ini`

Please make sure that you have copied the template file into that location, and updated it to match your system.
```

`cmake/FindFFMPEG.cmake`:

```cmake
# vim: ts=2 sw=2
# - Try to find the required FFMPEG components(default: AVFORMAT, AVUTIL, AVCODEC)
#
# Once done this will define
#  FFMPEG_FOUND         - System has the all required components.
#  FFMPEG_INCLUDE_DIRS  - Include directory necessary for using the required components headers.
#  FFMPEG_LIBRARIES     - Link these to use the required FFMPEG components.
#  FFMPEG_DEFINITIONS   - Compiler switches required for using the required FFMPEG components.
#
# For each of the components it will additionally set.
#   - AVCODEC
#   - AVDEVICE
#   - AVFORMAT
#   - AVFILTER
#   - AVUTIL
#   - SWSCALE
# the following variables will be defined
#  <component>_FOUND        - System has <component>
#  <component>_INCLUDE_DIRS - Include directory necessary for using the <component> headers
#  <component>_LIBRARIES    - Link these to use <component>
#  <component>_DEFINITIONS  - Compiler switches required for using <component>
#  <component>_VERSION      - The components version
#
# Copyright (c) 2006, Matthias Kretz, <kretz@kde.org>
# Copyright (c) 2008, Alexander Neundorf, <neundorf@kde.org>
# Copyright (c) 2011, Michael Jansen, <kde@michael-jansen.biz>
#
# Redistribution and use is allowed according to the terms of the BSD license.
# For details see the accompanying COPYING-CMAKE-SCRIPTS file.

include(FindPackageHandleStandardArgs)

# The default components were taken from a survey over other FindFFMPEG.cmake files
if (NOT FFMPEG_FIND_COMPONENTS)
    set(FFMPEG_FIND_COMPONENTS AVCODEC AVFORMAT AVUTIL)
endif ()

#
### Macro: set_component_found
#
# Marks the given component as found if both *_LIBRARIES AND *_INCLUDE_DIRS is present.
#
macro(set_component_found _component)
    if (${_component}_LIBRARIES AND ${_component}_INCLUDE_DIRS)
        # message(STATUS "  - ${_component} found.")
        set(${_component}_FOUND TRUE)
    else ()
        # message(STATUS "  - ${_component} not found.")
    endif ()
endmacro()

#
### Macro: find_component
#
# Checks for the given component by invoking pkgconfig and then looking up the libraries and
# include directories.
#
macro(find_component _component _pkgconfig _library _header)

    if (NOT WIN32)
        # use pkg-config to get the directories and then use these values
        # in the FIND_PATH() and FIND_LIBRARY() calls
        find_package(PkgConfig)
        if (PKG_CONFIG_FOUND)
            pkg_check_modules(PC_${_component} ${_pkgconfig})
        endif ()
    endif (NOT WIN32)

    find_path(${_component}_INCLUDE_DIRS ${_header}
            HINTS
            ${PC_${_component}_INCLUDEDIR}
            ${PC_${_component}_INCLUDE_DIRS}
            PATH_SUFFIXES
            ffmpeg
    )

    find_library(${_component}_LIBRARIES NAMES ${_library}
            HINTS
            ${PC_${_component}_LIBDIR}
            ${PC_${_component}_LIBRARY_DIRS}
    )

    set(${_component}_DEFINITIONS ${PC_${_component}_CFLAGS_OTHER} CACHE STRING "The ${_component} CFLAGS.")
    set(${_component}_VERSION ${PC_${_component}_VERSION} CACHE STRING "The ${_component} version number.")

    set_component_found(${_component})

    mark_as_advanced(
            ${_component}_INCLUDE_DIRS
            ${_component}_LIBRARIES
            ${_component}_DEFINITIONS
            ${_component}_VERSION)

endmacro()


# Check for cached results. If there are skip the costly part.
if (NOT FFMPEG_LIBRARIES)

    # Check for all possible component.
    find_component(AVCODEC libavcodec avcodec libavcodec/avcodec.h)
    find_component(AVFORMAT libavformat avformat libavformat/avformat.h)
    find_component(AVDEVICE libavdevice avdevice libavdevice/avdevice.h)
    find_component(AVUTIL libavutil avutil libavutil/avutil.h)
    find_component(AVFILTER libavfilter avfilter libavfilter/avfilter.h)
    find_component(SWSCALE libswscale swscale libswscale/swscale.h)
    find_component(SWRESAMPLE libswresample swresample libswresample/swresample.h)

    # Check if the required components were found and add their stuff to the FFMPEG_* vars.
    foreach (_component ${FFMPEG_FIND_COMPONENTS})
        if (${_component}_FOUND)
            # message(STATUS "Required component ${_component} present.")
            set(FFMPEG_LIBRARIES ${FFMPEG_LIBRARIES} ${${_component}_LIBRARIES})
            set(FFMPEG_DEFINITIONS ${FFMPEG_DEFINITIONS} ${${_component}_DEFINITIONS})
            list(APPEND FFMPEG_INCLUDE_DIRS ${${_component}_INCLUDE_DIRS})
        else ()
            # message(STATUS "Required component ${_component} missing.")
        endif ()
    endforeach ()

    # Build the include path with duplicates removed.
    if (FFMPEG_INCLUDE_DIRS)
        list(REMOVE_DUPLICATES FFMPEG_INCLUDE_DIRS)
    endif ()

    # cache the vars.
    set(FFMPEG_INCLUDE_DIRS ${FFMPEG_INCLUDE_DIRS} CACHE STRING "The FFMPEG include directories." FORCE)
    set(FFMPEG_LIBRARIES ${FFMPEG_LIBRARIES} CACHE STRING "The FFMPEG libraries." FORCE)
    set(FFMPEG_DEFINITIONS ${FFMPEG_DEFINITIONS} CACHE STRING "The FFMPEG cflags." FORCE)

    mark_as_advanced(FFMPEG_INCLUDE_DIRS
            FFMPEG_LIBRARIES
            FFMPEG_DEFINITIONS)

endif ()

# Now set the noncached _FOUND vars for the components.
foreach (_component AVCODEC AVDEVICE AVFORMAT AVUTIL SWSCALE)
    set_component_found(${_component})
endforeach ()

# Compile the list of required vars
set(_FFMPEG_REQUIRED_VARS FFMPEG_LIBRARIES FFMPEG_INCLUDE_DIRS)
foreach (_component ${FFMPEG_FIND_COMPONENTS})
    list(APPEND _FFMPEG_REQUIRED_VARS ${_component}_LIBRARIES ${_component}_INCLUDE_DIRS)
endforeach ()

# Give a nice error message if some of the required vars are missing.
find_package_handle_standard_args(FFMPEG DEFAULT_MSG ${_FFMPEG_REQUIRED_VARS})
```

`content/abyss.ini`:

```ini
[General]
BasePath = /you/didnt/read/the/readme/
Locale = latin

[Graphics]
# The scaling quality when the window is stretched. Possible values: nearest, linear, best
ScaleQuality = nearest
InitialScale = 1.0
FullScreen = false

[Audio]
MasterVolume = 0.5
MusicVolume = 1.0
SfxVolume = 1.0
UIVolume = 1.0

[MPQs]
d2exp.MPQ
d2xmusic.MPQ
d2xtalk.MPQ
d2xvideo.MPQ
d2data.MPQ
d2char.MPQ
d2music.MPQ
d2sfx.MPQ
d2video.MPQ
d2speech.MPQ

```

`extra/CMakeDMGSetup.scp`:

```scp
on run argv
  set image_name to item 1 of argv

  tell application "Finder"
  tell disk image_name

    -- wait for the image to finish mounting
    set open_attempts to 0
    repeat while open_attempts < 4
      try
        open
          delay 1
          set open_attempts to 5
        close
      on error errStr number errorNumber
        set open_attempts to open_attempts + 1
        delay 10
      end try
    end repeat
    delay 5

    -- open the image the first time and save a DS_Store with just
    -- background and icon setup
    open
      set current view of container window to icon view
      set theViewOptions to the icon view options of container window
      set background picture of theViewOptions to file ".background:background.png"
      set arrangement of theViewOptions to not arranged
      set icon size of theViewOptions to 128
      delay 5
    close

    -- next setup the position of the app and Applications symlink
    -- plus hide all the window decoration
    open
      update without registering applications
      tell container window
        set sidebar width to 0
        set statusbar visible to false
        set toolbar visible to false
        set the bounds to { 400, 100, 1000, 600 }
        set position of item "OpenDiablo2.app" to { 160, 330 }
        set position of item "Applications" to { 440, 330 }
      end tell
      update without registering applications
      delay 5
    close

    -- one last open and close so you can see everything looks correct
    open
      delay 5
    close

  end tell
  delay 1
end tell
end run

```

`extra/macos/MacOSXBundleInfo.plist.in`:

```in
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleName</key>
    <string>Abyss Engine</string>
    <key>CFBundleExecutable</key>
    <string>AbyssEngine</string>
    <key>CFBundleIdentifier</key>
    <string>com.abyssengine</string>
    <key>CFBundleVersion</key>
    <string>0.1</string>
    <key>CFBundleShortVersionString</key>
    <string>0.1</string>
    <key>CFBundleIconFile</key>
    <string>icon.icns</string>
    <key>CFBundlePackageType</key>
    <string>APPL</string>
    <key>CFBundleDevelopmentRegion</key>
    <string>English</string>
</dict>
</plist>

```

`src/AbyssEngine.c`:

```c
#include "common/AbyssConfiguration.h"
#include "common/FileManager.h"
#include "common/Globals.h"
#include "common/Logging.h"
#include "drawing/Cursor.h"
#include "drawing/Label.h"
#include "managers/AudioManager.h"
#include "managers/InputManager.h"
#include "managers/VideoManager.h"
#include "scenes/Scene.h"
#include "scenes/SceneIntroVideos.h"
#include "types/Palette.h"
#include "util/Crypto.h"
#include <libavutil/log.h>

int main(int argc, char **argv) {
    (void)(argc);
    (void)(argv);

    Log_SetLevel(LOG_LEVEL_EVERYTHING);
    av_log_set_level(AV_LOG_FATAL);
    LOG_INFO("Abyss Engine");

    LOG_DEBUG("Initializing SDL...");
    if (SDL_Init(SDL_INIT_EVERYTHING) != 0) {
        FATAL(SDL_GetError());
    }

    LOG_DEBUG("Initializing crypto...");
    crypto_init();

    LOG_DEBUG("Loading configuration...");
    char config_path[4096];
    memset(config_path, 0, 4096);
#ifdef _WIN32
    snprintf(config_path, 4096, "%s\\abyss\\abyss.ini", getenv("APPDATA"));
#elif __APPLE__
    snprintf(config_path, 4096, "%s/Library/Application Support/abyss/abyss.ini", getenv("HOME"));
#else
    snprintf(config_path, 4096, "%s/.config/abyss/abyss.ini", getenv("HOME"));
#endif
    AbyssConfiguration_LoadSingleton(config_path);

    LOG_DEBUG("Initializing file manager...");
    FileManager_CreateSingleton();

    LOG_DEBUG("Creating window...");
    sdl_window = SDL_CreateWindow("Abyss Engine", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
                                  (int)((float)800 * AbyssConfiguration_GetInitialScale()),
                                  (int)((float)600 * AbyssConfiguration_GetInitialScale()),
                                  SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);

    if (sdl_window == NULL) {
        FATAL(SDL_GetError());
    }

    LOG_DEBUG("Creating renderer...");
    sdl_renderer = SDL_CreateRenderer(sdl_window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);

    if (sdl_renderer == NULL) {
        FATAL(SDL_GetError());
    }

    SDL_RenderSetLogicalSize(sdl_renderer, 800, 600);
    SDL_ShowCursor(false);
    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, AbyssConfiguration_GetScaleQuality());

    if (AbyssConfiguration_GetFullScreen()) {
        SDL_SetWindowFullscreen(sdl_window, SDL_WINDOW_FULLSCREEN_DESKTOP);
    }

    Palette_Initialize();
    Cursor_CreateSingleton();
    Scene_InitializeManager();
    Cursor_SetType(CURSOR_STANDARD);
    Scene_Set(SCENE_REF(IntroVideos));
    Label_InitializeCaches();
    AudioManager_InitSingleton();
    InputManager_InitializeSingleton();
    VideoManager_InitializeSingleton();

    SDL_Event sdl_event;
    running             = true;
    uint64_t last_ticks = SDL_GetTicks64();

    while (running) {
        while (SDL_PollEvent(&sdl_event)) {
            if (InputManager_ProcessSdlEvent(&sdl_event)) {
                continue;
            }

            switch (sdl_event.type) {
            case SDL_QUIT:
                running = false;
                break;
            }
        }

        if (!running) {
            break;
        }

        const uint64_t current_ticks = SDL_GetTicks64();
        const uint64_t tick_delta    = current_ticks - last_ticks;

        if (tick_delta == 0) {
            SDL_Delay(1);
            continue;
        }

        last_ticks = current_ticks;

        VideoManager_IsPlayingVideo() ? VideoManager_Update(tick_delta) : Scene_UpdateCurrentScene(tick_delta);
        AudioManager_Update();

        SDL_RenderClear(sdl_renderer);
        if (VideoManager_IsPlayingVideo()) {
            VideoManager_Render();
        } else {
            Scene_RenderCurrentScene();
            Cursor_Draw();
        }
        SDL_RenderPresent(sdl_renderer);
    }

    AudioManager_DestroySingleton(); // Destroy this first as it reaches into things via threads
    VideoManager_DestroySingleton();
    InputManager_DestroySingleton();
    Label_FinalizeCaches();
    Scene_DestroyManager();
    Cursor_Destroy();
    Palette_Finalize();
    AbyssConfiguration_DestroySingleton();
    FileManager_DestroySingleton();

    SDL_DestroyRenderer(sdl_renderer);
    SDL_DestroyWindow(sdl_window);
    SDL_Quit();
    return 0;
}

```

`src/CMakeLists.txt`:

```txt
add_subdirectory(audio)
add_subdirectory(common)
add_subdirectory(drawing)
add_subdirectory(managers)
add_subdirectory(scenes)
add_subdirectory(types)
add_subdirectory(util)

```

`src/audio/AudioStream.c`:

```c
#include "AudioStream.h"

#include "../common/FileManager.h"
#include "../common/Logging.h"
#include "../managers/AudioManager.h"
#include <libavutil/opt.h>
#include <stdio.h>

struct AudioStream {
    bool                    is_playing;
    bool                    is_paused;
    bool                    loop;
    int                     audio_stream_index;
    struct MpqStream       *stream;
    unsigned char          *av_buffer;
    struct AVIOContext     *avio_context;
    struct AVFormatContext *av_format_context;
    struct AVCodecContext  *audio_codec_context;
    struct SwrContext      *av_resample_context;
    struct AVFrame         *av_frame;
    struct RingBuffer      *ring_buffer;
    struct Mutex           *mutex;
    uint8_t                *audio_out_buffer;
};

void AudioStream__ReadFrame(const struct AudioStream *audio_stream);

#define AUDIO_STREAM_DECODE_BUFFER_SIZE (1024 * 8)
#define AUDIO_STREAM_MAX_BUFF_SIZE      (1024 * 10)
#define AUDIO_RING_BUFFER_SIZE          (1024 * 1024)

int audio_stream_read_callback(void *opaque, unsigned char *buffer, const int size) {
    const AudioStream *audio_stream = (AudioStream *)opaque;

    const int result = MpqStream_Read(audio_stream->stream, buffer, 0, size);
    return result;
}

int64_t audio_stream_seek_callback(void *opaque, const int64_t offset, const int whence) {
    const AudioStream *audio_stream = (AudioStream *)opaque;
    if (whence == AVSEEK_SIZE) {
        return MpqStream_GetSize(audio_stream->stream);
    }

    MpqStream_Seek(audio_stream->stream, offset, whence);
    return MpqStream_Tell(audio_stream->stream);
}

AudioStream *AudioStream_Create(const char *path) {
    AudioStream *result = malloc(sizeof(AudioStream));
    memset(result, 0, sizeof(AudioStream));

    result->ring_buffer      = RingBuffer_Create(AUDIO_RING_BUFFER_SIZE);
    result->stream           = FileManager_OpenFile(path);
    result->mutex            = Mutex_Create();
    result->audio_out_buffer = malloc(AUDIO_STREAM_DECODE_BUFFER_SIZE);

    const uint32_t stream_size = MpqStream_GetSize(result->stream);

    const size_t decode_buffer_size =
        stream_size < AUDIO_STREAM_MAX_BUFF_SIZE ? stream_size : AUDIO_STREAM_MAX_BUFF_SIZE;

    result->av_buffer    = av_malloc(decode_buffer_size);
    result->avio_context = avio_alloc_context(result->av_buffer, decode_buffer_size, 0, result,
                                              audio_stream_read_callback, NULL, audio_stream_seek_callback);

    result->av_format_context         = avformat_alloc_context();
    result->av_format_context->pb     = result->avio_context;
    result->av_format_context->flags |= AVFMT_FLAG_CUSTOM_IO;

    int av_error;

    if ((av_error = avformat_open_input(&result->av_format_context, "", NULL, NULL)) < 0) {
        LOG_FATAL("Failed to open audio stream: %s", av_err2str(av_error));
    }

    if ((av_error = avformat_find_stream_info(result->av_format_context, NULL)) < 0) {
        LOG_FATAL("Failed to find stream info: %s", av_err2str(av_error));
    }

    result->audio_stream_index = -1;
    for (uint32_t i = 0; i < result->av_format_context->nb_streams; i++) {
        if (result->av_format_context->streams[i]->codecpar->codec_type != AVMEDIA_TYPE_AUDIO) {
            continue;
        }

        result->audio_stream_index = (int)i;
        break;
    }

    if (result->audio_stream_index == -1) {
        LOG_FATAL("No audio stream found for '%s'!", path);
    }

    const struct AVCodecParameters *audio_codec_par =
        result->av_format_context->streams[result->audio_stream_index]->codecpar;

    const struct AVCodec *audio_decoder = avcodec_find_decoder(audio_codec_par->codec_id);

    if (audio_decoder == NULL) {
        LOG_FATAL("Missing audio codec for '%s'!", path);
    }

    LOG_DEBUG("Using %s to decode %s", audio_decoder->long_name, path);

    result->audio_codec_context = avcodec_alloc_context3(audio_decoder);
    if ((av_error = avcodec_parameters_to_context(result->audio_codec_context, audio_codec_par)) < 0) {
        LOG_FATAL("Failed to copy codec parameters to decoder context: %s", av_err2str(av_error));
    }

    if ((av_error = avcodec_open2(result->audio_codec_context, audio_decoder, NULL)) < 0) {
        LOG_FATAL("Failed to open the audio codec: ", av_err2str(av_error));
    }

    AVChannelLayout channel_layout = AudioManager_GetChannelLayout();

    result->av_resample_context = swr_alloc();
    av_opt_set_int(result->av_resample_context, "in_sample_rate", audio_codec_par->sample_rate, 0);
    av_opt_set_chlayout(result->av_resample_context, "in_chlayout", &result->audio_codec_context->ch_layout, 0);
    av_opt_set_sample_fmt(result->av_resample_context, "in_sample_fmt", audio_codec_par->format, 0);

    av_opt_set_int(result->av_resample_context, "out_sample_rate", AudioManager_GetAudioSpec().freq, 0);
    av_opt_set_chlayout(result->av_resample_context, "out_chlayout", &channel_layout, 0);
    av_opt_set_sample_fmt(result->av_resample_context, "out_sample_fmt", AudioManager_GetSampleFormat(), 0);

    if ((av_error = swr_init(result->av_resample_context)) < 0) {
        LOG_FATAL("Failed to set re-sampler options: %s", av_err2str(av_error));
    }

    if ((av_error = swr_init(result->av_resample_context)) < 0) {
        LOG_FATAL("Failed to initialize re-sampler: %s", av_err2str(av_error));
    }

    result->av_frame = av_frame_alloc();

    return result;
}

void AudioStream_Destroy(struct AudioStream **audio_stream) {
    Mutex_Destroy(&(*audio_stream)->mutex);
    RingBuffer_Destroy(&(*audio_stream)->ring_buffer);
    av_free((*audio_stream)->avio_context->buffer);
    avio_context_free(&(*audio_stream)->avio_context);

    if ((*audio_stream)->audio_stream_index >= 0) {
        avcodec_free_context(&(*audio_stream)->audio_codec_context);
        swr_free(&(*audio_stream)->av_resample_context);
    }

    av_frame_free(&(*audio_stream)->av_frame);

    avformat_close_input(&(*audio_stream)->av_format_context);
    avformat_free_context((*audio_stream)->av_format_context);

    MpqStream_Destroy(&(*audio_stream)->stream);

    free((*audio_stream)->audio_out_buffer);
    free((*audio_stream));
    *audio_stream = NULL;
}

void AudioStream__ReadFrame(const struct AudioStream *audio_stream) {
    if (audio_stream->av_format_context == NULL) {
        return;
    }

    struct AVPacket *packet = av_packet_alloc();
    int              av_error;

    if ((av_error = av_read_frame(audio_stream->av_format_context, packet)) < 0) {
        LOG_FATAL("Error reading audio frame: ", av_err2str(av_error));
    }

    if (packet->stream_index != audio_stream->audio_stream_index) {
        av_packet_free(&packet);
        return;
    }

    if ((av_error = avcodec_send_packet(audio_stream->audio_codec_context, packet)) < 0) {
        LOG_FATAL("Error decoding packet: ", av_err2str(av_error));
    }

    av_packet_free(&packet);

    while (true) {
        if ((av_error = avcodec_receive_frame(audio_stream->audio_codec_context, audio_stream->av_frame)) < 0) {
            if (av_error == AVERROR(EAGAIN) || av_error == AVERROR_EOF) {
                return;
            }

            LOG_FATAL("Failed to receive frame: ", av_err2str(av_error));
        }

        const size_t sample_size = av_get_bytes_per_sample(AudioManager_GetSampleFormat());
        const int    total_samples =
            AUDIO_STREAM_DECODE_BUFFER_SIZE / (sample_size * AudioManager_GetChannelLayout().nb_channels);

        uint8_t  *ptr[1] = {audio_stream->audio_out_buffer};
        const int result =
            swr_convert(audio_stream->av_resample_context, ptr, total_samples,
                        (const uint8_t **)audio_stream->av_frame->data, audio_stream->av_frame->nb_samples);
        RingBuffer_Write(audio_stream->ring_buffer, (char *)audio_stream->audio_out_buffer, result * 4);
    }
}

int16_t AudioStream_GetSample(struct AudioStream *audio_stream) {
    Mutex_Lock(audio_stream->mutex);

    if (!audio_stream->is_playing || audio_stream->is_paused) {
        Mutex_Unlock(audio_stream->mutex);
        return 0;
    }

    if (MpqStream_GetIsEof(audio_stream->stream)) {
        avcodec_flush_buffers(audio_stream->audio_codec_context);
        av_seek_frame(audio_stream->av_format_context, audio_stream->audio_stream_index, 0, AVSEEK_FLAG_FRAME);
        audio_stream->is_playing = audio_stream->loop;

        if (!audio_stream->is_playing) {
            Mutex_Unlock(audio_stream->mutex);
            return 0;
        }
    }

    if (RingBuffer_GetRemainingToRead(audio_stream->ring_buffer) < 2) {
        AudioStream__ReadFrame(audio_stream);
    }

    if (RingBuffer_GetRemainingToRead(audio_stream->ring_buffer) < 2) {
        Mutex_Unlock(audio_stream->mutex);
        return 0;
    }

    int16_t sample;
    RingBuffer_Read(audio_stream->ring_buffer, (char *)&sample, sizeof(int16_t));

    Mutex_Unlock(audio_stream->mutex);

    return sample;
}
bool AudioStream_IsLooping(const AudioStream *audio_stream) {
    Mutex_Lock(audio_stream->mutex);
    bool result = audio_stream->loop;
    Mutex_Unlock(audio_stream->mutex);
    return result;
}

void AudioStream_SetLoop(AudioStream *audio_stream, bool loop) {
    Mutex_Lock(audio_stream->mutex);
    audio_stream->loop = loop;
    Mutex_Unlock(audio_stream->mutex);
}

void AudioStream_Play(AudioStream *audio_stream) {
    Mutex_Lock(audio_stream->mutex);
    audio_stream->is_playing = true;
    Mutex_Unlock(audio_stream->mutex);
}

bool AudioStream_IsPlaying(const AudioStream *audio_stream) {
    Mutex_Lock(audio_stream->mutex);
    bool result = audio_stream->is_playing;
    Mutex_Unlock(audio_stream->mutex);
    return result;
}

void AudioStream_Stop(AudioStream *audio_stream) {
    Mutex_Lock(audio_stream->mutex);
    audio_stream->is_playing = false;
    Mutex_Unlock(audio_stream->mutex);
}

```

`src/audio/AudioStream.h`:

```h
#ifndef ABYSS_AUDIO_STREAM_H
#define ABYSS_AUDIO_STREAM_H

#include "../common/MpqStream.h"
#include "../common/RingBuffer.h"
#include "../util/Mutex.h"
#include <libavcodec/avcodec.h>
#include <libavformat/avformat.h>
#include <libswresample/swresample.h>

typedef struct AudioStream AudioStream;

AudioStream *AudioStream_Create(const char *path);
void         AudioStream_Destroy(AudioStream **audio_stream);
int16_t      AudioStream_GetSample(AudioStream *audio_stream);
bool         AudioStream_IsLooping(const AudioStream *audio_stream);
void         AudioStream_SetLoop(AudioStream *audio_stream, bool loop);
void         AudioStream_Play(AudioStream *audio_stream);
bool         AudioStream_IsPlaying(const AudioStream *audio_stream);
void         AudioStream_Stop(AudioStream *audio_stream);

#endif // ABYSS_AUDIO_STREAM_H

```

`src/audio/CMakeLists.txt`:

```txt
target_sources(${PROJECT_NAME}
        PRIVATE
        AudioStream.c AudioStream.h
)
```

`src/common/AbyssConfiguration.c`:

```c
#include "AbyssConfiguration.h"
#include "Logging.h"
#include <ctype.h>
#include <stdbool.h>
#include <stdio.h>

#ifdef _WIN32
#include <direct.h>
#else
#include <unistd.h>
#endif

typedef struct AbyssConfiguration {
    char  *base_path;
    char  *locale;
    char **mpqs;
    int    num_mpqs;
    struct {
        char *scale_quality;
        float initial_scale;
        bool  fullscreen;
    } graphics;
    struct {
        float master_volume;
        float music_volume;
        float sfx_volume;
        float ui_volume;
    } audio;
} AbyssConfiguration;

void AbyssConfiguration__SetSaneDefaults(void);
void AbyssConfiguration_SetValue(const char *category, const char *key, const char *value);

struct AbyssConfiguration abyss_configuration;
bool                      added_mpq = false;

static const char *default_mpqs[] = {"d2exp.MPQ",   "d2xmusic.MPQ", "d2xtalk.MPQ", "d2xvideo.MPQ",
                                     "d2data.MPQ",  "d2char.MPQ",   "d2music.MPQ", "d2sfx.MPQ",
                                     "d2video.MPQ", "d2speech.MPQ", NULL};

#define MAX_LINE_LEN       4096
#define IS_STR_EQUAL(X, Y) (strcmp(X, Y) == 0)

#define SET_PARAM_STR(X, Y)                                                                                            \
    if ((X) != NULL) {                                                                                                 \
        free(X);                                                                                                       \
    }                                                                                                                  \
    (X) = malloc(sizeof(char) * (strlen(Y) + 1));                                                                      \
    if ((X) == NULL) {                                                                                                 \
        LOG_FATAL("Failed to allocate memory.");                                                                       \
    }                                                                                                                  \
    memset(X, 0, sizeof(char) * (strlen(Y) + 1));                                                                      \
    strcat(X, Y)

static const char *valid_categories[] = {"general", "mpqs", "graphics", "audio", NULL};

char *trim_str(char *str) {
    size_t       len   = strlen(str);
    const size_t index = strcspn(str, "\r\n");

    if (index < len) {
        str[index] = '\0';
    }

    char *result = str;
    while (isspace(*result) || *result == '\t') {
        result++;
    }

    len       = strlen(result);
    char *end = result + len;

    while (end >= result && (isspace(*end) || *end == '\t')) {
        end--;
    }
    *(end + 1) = '\0';

    return result;
}

bool is_category(const char *str) {
    const size_t str_len = strlen(str);
    return (str_len >= 3) && (str[0] == '[') && (str[str_len - 1] == ']');
}

bool is_valid_category(const char *category) {
    for (int idx = 0; valid_categories[idx] != NULL; idx++) {
        if (strcmp(valid_categories[idx], category) != 0) {
            continue;
        }
        return true;
    }
    return false;
}

void extract_category(const char *str, char *out) {
    strcat(out, str + 1);
    out[strlen(str) - 2] = '\0';

    for (char *ch = out; *ch != '\0'; ch++) {
        *ch = (char)tolower(*ch);
    }
}

void extract_key_value(const char *str, char *key, char *value) {
    char *equal_ptr = strchr(str, '=');

    if (equal_ptr == NULL) {
        strcat(value, str);
        return;
    }

    *equal_ptr = '\0';
    strcat(key, str);

    const char *val_start = str + strlen(key) + 1;
    while (isspace(*val_start) || *val_start == '\t') {
        val_start++;
    }
    strcat(value, val_start);

    for (char *ch = key; *ch != '\0'; ch++) {
        if (isspace(*ch) || *ch == '\t') {
            *ch = '\0';
            break;
        }
        *ch = (char)tolower(*ch);
    }

    const size_t len = strlen(value);
    char        *end = value + len;
    while (end >= value && (isspace(*end) || *end == '\t')) {
        end--;
    }
    *(end + 1) = '\0';
}

void AbyssConfiguration_SetValue(const char *category, const char *key, const char *value) {
    if (IS_STR_EQUAL(category, "general")) {
        if (IS_STR_EQUAL(key, "basepath")) {
            if (strlen(abyss_configuration.base_path) != 0) {
                memset(abyss_configuration.base_path, 0, sizeof(char) * strlen(abyss_configuration.base_path));
            }
            SET_PARAM_STR(abyss_configuration.base_path, value);
            LOG_DEBUG("Setting base path to '%s'", abyss_configuration.base_path);
        } else if (IS_STR_EQUAL(key, "locale")) {
            if (strlen(abyss_configuration.locale) != 0) {
                memset(abyss_configuration.locale, 0, sizeof(char) * strlen(abyss_configuration.locale));
            }
            SET_PARAM_STR(abyss_configuration.locale, value);
            LOG_DEBUG("Setting locale to '%s'", abyss_configuration.locale);
        } else {
            LOG_FATAL("Invalid key '%s' in the configuration file!", key);
        }
    } else if (IS_STR_EQUAL(category, "graphics")) {
        if (IS_STR_EQUAL(key, "scalequality")) {
            if (strlen(abyss_configuration.graphics.scale_quality) != 0) {
                memset(abyss_configuration.graphics.scale_quality, 0,
                       sizeof(char) * strlen(abyss_configuration.graphics.scale_quality));
            }
            SET_PARAM_STR(abyss_configuration.graphics.scale_quality, value);
            LOG_DEBUG("Setting scale quality to '%s'", abyss_configuration.graphics.scale_quality);
        } else if (IS_STR_EQUAL(key, "initialscale")) {
            abyss_configuration.graphics.initial_scale = strtof(value, NULL);
            if (abyss_configuration.graphics.initial_scale <= 0.0f) {
                LOG_FATAL("Invalid value '%s' for key '%s' in the configuration file!", value, key);
            }
            LOG_DEBUG("Setting initial scale to '%f'", abyss_configuration.graphics.initial_scale);
        } else if (IS_STR_EQUAL(key, "fullscreen")) {
            if (IS_STR_EQUAL(value, "true")) {
                abyss_configuration.graphics.fullscreen = true;
            } else if (IS_STR_EQUAL(value, "false")) {
                abyss_configuration.graphics.fullscreen = false;
            } else {
                LOG_FATAL("Invalid value '%s' for key '%s' in the configuration file!", value, key);
            }
            LOG_DEBUG("Setting fullscreen to '%s'", abyss_configuration.graphics.fullscreen ? "true" : "false");
        } else {
            LOG_FATAL("Invalid key '%s' in the configuration file!", key);
        }
    } else if (IS_STR_EQUAL(category, "audio")) {
        if (IS_STR_EQUAL(key, "mastervolume")) {
            abyss_configuration.audio.master_volume = strtof(value, NULL);
            if (abyss_configuration.audio.master_volume < 0.0f || abyss_configuration.audio.master_volume > 1.0f) {
                LOG_FATAL("Invalid value '%s' for key '%s' in the configuration file!", value, key);
            }
            LOG_DEBUG("Setting master volume to '%f'", abyss_configuration.audio.master_volume);
        } else if (IS_STR_EQUAL(key, "musicvolume")) {
            abyss_configuration.audio.music_volume = strtof(value, NULL);
            if (abyss_configuration.audio.music_volume < 0.0f || abyss_configuration.audio.music_volume > 1.0f) {
                LOG_FATAL("Invalid value '%s' for key '%s' in the configuration file!", value, key);
            }
            LOG_DEBUG("Setting music volume to '%f'", abyss_configuration.audio.music_volume);
        } else if (IS_STR_EQUAL(key, "sfxvolume")) {
            abyss_configuration.audio.sfx_volume = strtof(value, NULL);
            if (abyss_configuration.audio.sfx_volume < 0.0f || abyss_configuration.audio.sfx_volume > 1.0f) {
                LOG_FATAL("Invalid value '%s' for key '%s' in the configuration file!", value, key);
            }
            LOG_DEBUG("Setting sfx volume to '%f'", abyss_configuration.audio.sfx_volume);
        } else if (IS_STR_EQUAL(key, "uivolume")) {
            abyss_configuration.audio.ui_volume = strtof(value, NULL);
            if (abyss_configuration.audio.ui_volume < 0.0f || abyss_configuration.audio.ui_volume > 1.0f) {
                LOG_FATAL("Invalid value '%s' for key '%s' in the configuration file!", value, key);
            }
            LOG_DEBUG("Setting ui volume to '%f'", abyss_configuration.audio.ui_volume);
        } else {
            LOG_FATAL("Invalid key '%s' in the configuration file!", key);
        }
    } else if (IS_STR_EQUAL(category, "mpqs")) {
        if (strlen(key) != 0) {
            LOG_FATAL("Key/Value pair for '%s' not allowed in the MPQ "
                      "category in the configuration file!",
                      key);
        }

        if (!added_mpq) {
            added_mpq = true;
            for (int i = 0; i < abyss_configuration.num_mpqs; i++) {
                free(abyss_configuration.mpqs[i]);
            }
            free(abyss_configuration.mpqs);
            abyss_configuration.num_mpqs = 0;
            abyss_configuration.mpqs     = calloc(0, sizeof(char *));
        }

        AbyssConfiguration_AddMpq(value);
    } else if (strlen(category) == 0) {
        LOG_FATAL("Invalid key '%s' outside of a category in the configuration file!", key);
    } else {
        LOG_FATAL("Invalid category '%s' in the configuration file!", category);
    }
}

void AbyssConfiguration_LoadSingleton(const char *file_path) {
    memset(&abyss_configuration, 0, sizeof(struct AbyssConfiguration));
    abyss_configuration.mpqs     = calloc(0, sizeof(char *));
    abyss_configuration.num_mpqs = 0;

    AbyssConfiguration__SetSaneDefaults();

    char category[MAX_LINE_LEN];
    char key[MAX_LINE_LEN];
    char value[MAX_LINE_LEN];

    memset(category, 0, sizeof(char) * MAX_LINE_LEN);
    memset(key, 0, sizeof(char) * MAX_LINE_LEN);
    memset(value, 0, sizeof(char) * MAX_LINE_LEN);

    FILE *ini_file = fopen(file_path, "r");
    if (ini_file == NULL) {
        LOG_FATAL("Could not find file '%s'!", file_path);
    }

    while (true) {
        char line[MAX_LINE_LEN];
        memset(line, 0, sizeof(char) * MAX_LINE_LEN);
        if (fgets(line, MAX_LINE_LEN, ini_file) == NULL) {
            break;
        }

        char *comment_ptr = strchr(line, '#');
        if (comment_ptr != NULL) {
            *comment_ptr = '\0';
        }

        const char *trimmed_line = trim_str(line);

        if (strlen(trimmed_line) == 0) {
            continue;
        }

        if (is_category(trimmed_line)) {
            memset(category, 0, sizeof(char) * MAX_LINE_LEN);
            extract_category(trimmed_line, category);
            if (!is_valid_category(category)) {
                LOG_FATAL("Invalid category '%s' in '%s'!", category, file_path);
            }
            continue;
        }

        memset(key, 0, sizeof(char) * MAX_LINE_LEN);
        memset(value, 0, sizeof(char) * MAX_LINE_LEN);
        extract_key_value(trimmed_line, key, value);

        if ((strlen(key) == 0) && (strlen(value) == 0)) {
            continue;
        }

        AbyssConfiguration_SetValue(category, key, value);
    }

    fclose(ini_file);
}

void AbyssConfiguration_DestroySingleton(void) {
    free(abyss_configuration.base_path);
    free(abyss_configuration.locale);
    free(abyss_configuration.graphics.scale_quality);

    for (int i = 0; i < abyss_configuration.num_mpqs; i++) {
        free(abyss_configuration.mpqs[i]);
    }

    free(abyss_configuration.mpqs);
}

void AbyssConfiguration_AddMpq(const char *mpq_file) {
    abyss_configuration.num_mpqs++;

    abyss_configuration.mpqs = realloc(abyss_configuration.mpqs, abyss_configuration.num_mpqs * sizeof(char *));
    FAIL_IF_NULL(abyss_configuration.mpqs);

    abyss_configuration.mpqs[abyss_configuration.num_mpqs - 1] = malloc(sizeof(char) * MAX_LINE_LEN);
    FAIL_IF_NULL(abyss_configuration.mpqs[abyss_configuration.num_mpqs - 1]);

    memset(abyss_configuration.mpqs[abyss_configuration.num_mpqs - 1], 0, sizeof(char) * MAX_LINE_LEN);
    strcat(abyss_configuration.mpqs[abyss_configuration.num_mpqs - 1], abyss_configuration.base_path);
    strcat(abyss_configuration.mpqs[abyss_configuration.num_mpqs - 1], mpq_file);
}
const char *AbyssConfiguration_GetLocale(void) { return abyss_configuration.locale; }

size_t AbyssConfiguration_GetMpqCount(void) { return abyss_configuration.num_mpqs; }

const char *AbyssConfiguration_GetMpqFileName(size_t index) { return abyss_configuration.mpqs[index]; }

float AbyssConfiguration_GetInitialScale(void) { return abyss_configuration.graphics.initial_scale; }

const char *AbyssConfiguration_GetScaleQuality(void) { return abyss_configuration.graphics.scale_quality; }

bool AbyssConfiguration_GetFullScreen(void) { return abyss_configuration.graphics.fullscreen; }

void AbyssConfiguration_SetFullScreen(const bool fullscreen) { abyss_configuration.graphics.fullscreen = fullscreen; }

float AbyssConfiguration_GetMasterVolume(void) { return abyss_configuration.audio.master_volume; }

float AbyssConfiguration_GetMusicVolume(void) { return abyss_configuration.audio.music_volume; }

float AbyssConfiguration_GetSfxVolume(void) { return abyss_configuration.audio.sfx_volume; }

float AbyssConfiguration_GetUiVolume(void) { return abyss_configuration.audio.ui_volume; }

void AbyssConfiguration__SetSaneDefaults(void) {
    char base_path[4096];
    memset(base_path, 0, sizeof(char) * 4096);
    getcwd(base_path, 4096);
    SET_PARAM_STR(abyss_configuration.base_path, base_path);

    added_mpq = false;
    for (const char **mpq_path = default_mpqs; *mpq_path != NULL; mpq_path++) {
        AbyssConfiguration_AddMpq(*mpq_path);
    }

    SET_PARAM_STR(abyss_configuration.graphics.scale_quality, "nearest");
    abyss_configuration.graphics.initial_scale = 1.0f;
    abyss_configuration.graphics.fullscreen    = false;

    abyss_configuration.audio.master_volume = 0.8f;
    abyss_configuration.audio.music_volume  = 1.0f;
    abyss_configuration.audio.sfx_volume    = 1.0f;
    abyss_configuration.audio.ui_volume     = 1.0f;

    SET_PARAM_STR(abyss_configuration.locale, "latin");
}

```

`src/common/AbyssConfiguration.h`:

```h
#ifndef ABYSS_CONFIG_H
#define ABYSS_CONFIG_H

#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

void        AbyssConfiguration_LoadSingleton(const char *file_path);
void        AbyssConfiguration_DestroySingleton(void);
void        AbyssConfiguration_AddMpq(const char *mpq_file);
const char *AbyssConfiguration_GetLocale(void);
size_t      AbyssConfiguration_GetMpqCount(void);
const char *AbyssConfiguration_GetMpqFileName(size_t index);
float       AbyssConfiguration_GetInitialScale(void);
const char *AbyssConfiguration_GetScaleQuality(void);
bool        AbyssConfiguration_GetFullScreen(void);
void        AbyssConfiguration_SetFullScreen(bool fullscreen);
float       AbyssConfiguration_GetMasterVolume(void);
float       AbyssConfiguration_GetMusicVolume(void);
float       AbyssConfiguration_GetSfxVolume(void);
float       AbyssConfiguration_GetUiVolume(void);

#endif // ABYSS_CONFIG_H

```

`src/common/CMakeLists.txt`:

```txt
target_sources(${PROJECT_NAME}
        PRIVATE
        AbyssConfiguration.c AbyssConfiguration.h
        FileManager.c FileManager.h
        Globals.c Globals.h
        Logging.c Logging.h
        MemoryStream.c MemoryStream.h
        MpqStream.c MpqStream.h
        ResourcePaths.h
        RingBuffer.c RingBuffer.h
)
```

`src/common/FileManager.c`:

```c
#include "FileManager.h"
#include "../util/Crypto.h"
#include "AbyssConfiguration.h"
#include "Logging.h"
#include <assert.h>
#include <ctype.h>
#include <stdlib.h>

typedef struct FileEntry {
    uint64_t    hash;
    struct MPQ *MPQ;
} FileEntry;

typedef struct FileManager {
    struct FileEntry *files;
    uint32_t          file_count;
    struct MPQ      **mpqs;
    uint32_t          mpq_count;
} FileManager;

FileManager *file_manager = NULL;

char *fix_path(const char *path) {
    assert(path != NULL);

    char *result = strdup(path);
    for (char *ch = result; *ch != '\0'; ch++) {
        *ch = (char)tolower((int)*ch);
        if (*ch == '/') {
            *ch = '\\';
        }
    }

    if (result[0] == '\\') {
        const int len = (int)strlen(result);
        for (int i = 0; i < len - 1; i++) {
            result[i] = result[i + 1];
        }
        result[len - 1] = '\0';
    }

    return result;
}

void FileManager_CreateSingleton(void) {
    assert(file_manager == NULL);

    file_manager = malloc(sizeof(FileManager));
    FAIL_IF_NULL(file_manager);

    memset(file_manager, 0, sizeof(FileManager));

    file_manager->mpqs  = calloc(0, sizeof(struct MPQ *));
    file_manager->files = calloc(0, sizeof(FileEntry));

    FAIL_IF_NULL(file_manager->mpqs);
    FAIL_IF_NULL(file_manager->files);

    for (size_t mpq_idx = 0; mpq_idx < AbyssConfiguration_GetMpqCount(); mpq_idx++) {
        FileManager_AddMpq(AbyssConfiguration_GetMpqFileName(mpq_idx));
    }
}

void FileManager_DestroySingleton(void) {
    assert(file_manager != NULL);

    free(file_manager->files);

    for (uint32_t mpq_idx = 0; mpq_idx < file_manager->mpq_count; mpq_idx++) {
        MPQ_Destroy(file_manager->mpqs[mpq_idx]);
    }

    free(file_manager->mpqs);
    free(file_manager);

    file_manager = NULL;
}

void FileManager_AddMpq(const char *mpq_path) {
    assert(file_manager != NULL);
    assert(mpq_path != NULL);

    file_manager->mpqs = realloc(file_manager->mpqs, sizeof(struct MPQ *) * ++file_manager->mpq_count);
    file_manager->mpqs[file_manager->mpq_count - 1] = MPQ_Load(mpq_path);
}

MpqStream *FileManager_OpenFile(const char *file_path) {
    assert(file_manager != NULL);
    assert(file_path != NULL);

    char          *path_fixed = fix_path(file_path);
    const uint64_t file_hash  = crypto_hash_file_name(path_fixed);
    FileEntry     *file_entry = NULL;

    for (uint32_t i = 0; i < file_manager->file_count; i++) {
        if (file_manager->files[i].hash != file_hash) {
            continue;
        }
        file_entry = &file_manager->files[i];
        break;
    }

    if (file_entry == NULL) {
        for (uint32_t mpq_idx = 0; mpq_idx < file_manager->mpq_count; mpq_idx++) {
            if (!MPQ_FileExists(file_manager->mpqs[mpq_idx], path_fixed)) {
                continue;
            }

            file_manager->files = realloc(file_manager->files, sizeof(FileEntry) * ++file_manager->file_count);
            file_entry          = &file_manager->files[file_manager->file_count - 1];

            file_entry->hash = file_hash;
            file_entry->MPQ  = file_manager->mpqs[mpq_idx];
        }

        if (file_entry == NULL) {
            LOG_FATAL("Could not find '%s'", file_path);
        }
    }

    MpqStream *MpqStream = MpqStream_Create(file_entry->MPQ, path_fixed);
    free(path_fixed);
    return MpqStream;
}

```

`src/common/FileManager.h`:

```h
#ifndef ABYSS_FILEMAN_H
#define ABYSS_FILEMAN_H

#include "../types/MPQ.h"
#include "MpqStream.h"

void       FileManager_CreateSingleton(void);
void       FileManager_DestroySingleton(void);
void       FileManager_AddMpq(const char *mpq_path);
MpqStream *FileManager_OpenFile(const char *file_path);

#endif // ABYSS_FILEMAN_H

```

`src/common/Globals.c`:

```c
#include "Globals.h"

SDL_Window   *sdl_window   = NULL;
SDL_Renderer *sdl_renderer = NULL;
bool          running      = false;

```

`src/common/Globals.h`:

```h
#ifndef ABYSS_GLOBALS_H
#define ABYSS_GLOBALS_H

#include "ResourcePaths.h"
#include <SDL2/SDL.h>
#include <stdbool.h>

#define FATAL(MSG)                                                                                                     \
    SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR, "Fatal Error", MSG, sdl_window);                                    \
    exit(-1)

extern SDL_Window   *sdl_window;
extern SDL_Renderer *sdl_renderer;
extern bool          running;

#endif // ABYSS_GLOBALS_H

```

`src/common/Logging.c`:

```c
#include "Logging.h"
#include "Globals.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef _WIN32
#include <Windows.h>
#endif // _WIN32

#define MAX_LOG_LINE_LENGTH 4096
enum LogLevel log_level = LOG_LEVEL_ERROR;

static const char *log_level_strings[] = {"", "DEBUG", "INFO ", "WARN ", "ERROR", "FATAL"};

void Log_SetLevel(const enum LogLevel level) { log_level = level; }

void Log_Message(enum LogLevel level, const char *file, const int line, const char *format, ...) {
    char    msg[MAX_LOG_LINE_LENGTH];
    va_list args;

    if (level < log_level) {
        return;
    }

#ifdef _WIN32
    printf("[%s] %s:%i - ", log_level_strings[level], strrchr(file, '\\') + 1, line);
    if (IsDebuggerPresent()) {
        memset(msg, 0, sizeof(char) * MAX_LOG_LINE_LENGTH);
        snprintf(msg, MAX_LOG_LINE_LENGTH, "%s(%i): [%s] ", file, line, log_level_strings[level]);
        va_start(args, format);
        const int len = strchr(msg, '\0') - msg;
        vsnprintf(strchr(msg, '\0'), len, format, args);
        va_end(args);
        strcat(msg, "\n");
        OutputDebugString(msg);
    }
#else
    printf("[%s] %s:%i - ", log_level_strings[level], strrchr(file, '/') + 1, line);
#endif
    va_start(args, format);
    vprintf(format, args);
    va_end(args);
    printf("\n");

    if (level == LOG_LEVEL_FATAL) {
        memset(msg, 0, sizeof(char) * MAX_LOG_LINE_LENGTH);
        va_start(args, format);
        vsnprintf(msg, MAX_LOG_LINE_LENGTH, format, args);
        va_end(args);

        SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR, "Error", msg, sdl_window);
        exit(-1);
    }
}

```

`src/common/Logging.h`:

```h
#ifndef ABYSS_LOG_H
#define ABYSS_LOG_H

#include <stdarg.h>

#define LOG_DEBUG(...) Log_Message(LOG_LEVEL_DEBUG, __FILE__, __LINE__, __VA_ARGS__)
#define LOG_INFO(...)  Log_Message(LOG_LEVEL_INFO, __FILE__, __LINE__, __VA_ARGS__)
#define LOG_WARN(...)  Log_Message(LOG_LEVEL_WARN, __FILE__, __LINE__, __VA_ARGS__)
#define LOG_ERROR(...) Log_Message(LOG_LEVEL_ERROR, __FILE__, __LINE__, __VA_ARGS__)
#define LOG_FATAL(...)                                                                                                 \
    Log_Message(LOG_LEVEL_FATAL, __FILE__, __LINE__, __VA_ARGS__);                                                     \
    exit(-1)

#define FAIL_IF_NULL(ptr)                                                                                              \
    if ((ptr) == NULL) {                                                                                               \
        LOG_FATAL("Failed to allocate memory.");                                                                       \
    }

enum LogLevel {
    LOG_LEVEL_EVERYTHING,
    LOG_LEVEL_DEBUG,
    LOG_LEVEL_INFO,
    LOG_LEVEL_WARN,
    LOG_LEVEL_ERROR,
    LOG_LEVEL_FATAL
};

extern enum LogLevel log_level;

void Log_SetLevel(enum LogLevel level);
void Log_Message(enum LogLevel level, const char *file, int line, const char *format, ...);

#endif // ABYSS_LOG_H

```

`src/common/MemoryStream.c`:

```c
#include "MemoryStream.h"

#include "Logging.h"
#include <assert.h>
#include <string.h>

#define MEMORY_STREAM_INITIAL_CAPACITY 1024

struct MemoryStream {
    uint8_t *buffer;
    size_t   write_position;
    size_t   read_position;
    size_t   capacity;
    bool     preserve_buffer;
    bool     read_only;
};

MemoryStream *MemoryStream_Create(bool preserve_buffer) {
    MemoryStream *memory_stream = malloc(sizeof(MemoryStream));
    memset(memory_stream, 0, sizeof(MemoryStream));

    memory_stream->buffer          = calloc(MEMORY_STREAM_INITIAL_CAPACITY, sizeof(uint8_t));
    memory_stream->preserve_buffer = preserve_buffer;
    memory_stream->read_only       = false;
    memory_stream->capacity        = MEMORY_STREAM_INITIAL_CAPACITY;
    return memory_stream;
}

MemoryStream *MemoryStream_CreateFromExistingBuffer(void *buffer, const size_t buffer_len) {
    assert(buffer != NULL);
    assert(buffer_len > 0);

    MemoryStream *memory_stream = malloc(sizeof(MemoryStream));
    memset(memory_stream, 0, sizeof(MemoryStream));

    memory_stream->buffer          = (uint8_t *)buffer;
    memory_stream->preserve_buffer = true;
    memory_stream->read_only       = true;
    memory_stream->capacity        = buffer_len;
    memory_stream->write_position  = buffer_len;

    return memory_stream;
}

void MemoryStream_Destroy(MemoryStream **memory_stream) {
    assert(*memory_stream != NULL);

    if (!(*memory_stream)->preserve_buffer) {
        free((*memory_stream)->buffer);
    }
    free(*memory_stream);

    memory_stream = NULL;
}

void MemoryStream_Resize(MemoryStream *memory_stream, const size_t new_size) {
    assert(memory_stream != NULL);
    assert(new_size > 0);

    if (memory_stream->read_only) {
        LOG_FATAL("Attempted to resize a read-only memory stream!");
    }

    if (new_size < memory_stream->write_position) {
        LOG_FATAL("Attempted to make memory stream smaller than it currently is!");
    }

    while (new_size > memory_stream->capacity) {
        if (memory_stream->capacity >= (SIZE_MAX / 2)) {
            // If you get here, something went _terribly_ wrong...
            LOG_FATAL("Attempted to allocate memory greater than the max size of size_t!");
        }

        memory_stream->capacity *= 2;
    }

    memory_stream->buffer =
        realloc(memory_stream->buffer, memory_stream->capacity); // NOLINT(*-suspicious-realloc-usage)
    if (memory_stream->buffer == NULL) {
        LOG_FATAL("Failed to allocate memory for memory stream!");
    }
}

void MemoryStream_WriteUint8(MemoryStream *memory_stream, const uint8_t value) {
    assert(memory_stream != NULL);

    MemoryStream_Resize(memory_stream, memory_stream->write_position + sizeof(uint8_t));
    *(uint8_t *)&memory_stream->buffer[memory_stream->write_position] = value;

    memory_stream->write_position += sizeof(uint8_t);
}

void MemoryStream_WriteInt8(MemoryStream *memory_stream, const int8_t value) {
    assert(memory_stream != NULL);

    MemoryStream_Resize(memory_stream, memory_stream->write_position + sizeof(int8_t));
    *(int8_t *)&memory_stream->buffer[memory_stream->write_position] = value;

    memory_stream->write_position += sizeof(int8_t);
}

void MemoryStream_WriteUint16(MemoryStream *memory_stream, const uint16_t value) {
    assert(memory_stream != NULL);

    MemoryStream_Resize(memory_stream, memory_stream->write_position + sizeof(uint16_t));
    *(uint16_t *)&memory_stream->buffer[memory_stream->write_position] = value;

    memory_stream->write_position += sizeof(uint16_t);
}

void MemoryStream_WriteInt16(MemoryStream *memory_stream, const int16_t value) {
    assert(memory_stream != NULL);

    MemoryStream_Resize(memory_stream, memory_stream->write_position + sizeof(int16_t));
    *(int16_t *)&memory_stream->buffer[memory_stream->write_position] = value;

    memory_stream->write_position += sizeof(int16_t);
}

void MemoryStream_WriteUint32(MemoryStream *memory_stream, const uint32_t value) {
    assert(memory_stream != NULL);

    MemoryStream_Resize(memory_stream, memory_stream->write_position + sizeof(uint32_t));
    *(uint32_t *)&memory_stream->buffer[memory_stream->write_position] = value;

    memory_stream->write_position += sizeof(uint32_t);
}

void MemoryStream_WriteInt32(MemoryStream *memory_stream, const int32_t value) {
    assert(memory_stream != NULL);

    MemoryStream_Resize(memory_stream, memory_stream->write_position + sizeof(int32_t));
    *(int32_t *)&memory_stream->buffer[memory_stream->write_position] = value;

    memory_stream->write_position += sizeof(int32_t);
}

void MemoryStream_WriteDouble(MemoryStream *memory_stream, const double value) {
    assert(memory_stream != NULL);

    MemoryStream_Resize(memory_stream, memory_stream->write_position + sizeof(double));
    *(double *)&memory_stream->buffer[memory_stream->write_position] = value;

    memory_stream->write_position += sizeof(double);
}

void MemoryStream_WriteFloat(MemoryStream *memory_stream, const float value) {
    assert(memory_stream != NULL);

    MemoryStream_Resize(memory_stream, memory_stream->write_position + sizeof(float));
    *(float *)&memory_stream->buffer[memory_stream->write_position] = value;

    memory_stream->write_position += sizeof(float);
}

int MemoryStream_Seek(MemoryStream *memory_stream, const size_t position) {
    assert(memory_stream != NULL);

    if (position > memory_stream->write_position) {
        memory_stream->read_position = memory_stream->write_position;
        return -1;
    }

    memory_stream->read_position = position;
    return 0;
}

uint8_t MemoryStream_ReadUint8(MemoryStream *memory_stream) {
    assert(memory_stream != NULL);

    if (memory_stream->write_position - memory_stream->read_position < sizeof(uint8_t)) {
        LOG_ERROR("Attempted to read past end of stream!");
    }

    uint8_t result = *(uint8_t *)&memory_stream->buffer[memory_stream->read_position];

    memory_stream->read_position += sizeof(uint8_t);
    return result;
}

int8_t MemoryStream_ReadInt8(MemoryStream *memory_stream) {
    assert(memory_stream != NULL);

    if (memory_stream->write_position - memory_stream->read_position < sizeof(int8_t)) {
        LOG_ERROR("Attempted to read past end of stream!");
    }

    int8_t result = *(int8_t *)&memory_stream->buffer[memory_stream->read_position];

    memory_stream->read_position += sizeof(int8_t);
    return result;
}

uint16_t MemoryStream_ReadUint16(MemoryStream *memory_stream) {
    assert(memory_stream != NULL);

    if (memory_stream->write_position - memory_stream->read_position < sizeof(uint16_t)) {
        LOG_ERROR("Attempted to read past end of stream!");
    }

    uint16_t result = *(uint16_t *)&memory_stream->buffer[memory_stream->read_position];

    memory_stream->read_position += sizeof(uint16_t);
    return result;
}

int16_t MemoryStream_ReadInt16(MemoryStream *memory_stream) {
    assert(memory_stream != NULL);

    if (memory_stream->write_position - memory_stream->read_position < sizeof(int16_t)) {
        LOG_ERROR("Attempted to read past end of stream!");
    }

    int16_t result = *(int16_t *)&memory_stream->buffer[memory_stream->read_position];

    memory_stream->read_position += sizeof(int16_t);
    return result;
}

uint32_t MemoryStream_ReadUint32(MemoryStream *memory_stream) {
    assert(memory_stream != NULL);

    if (memory_stream->write_position - memory_stream->read_position < sizeof(uint32_t)) {
        LOG_ERROR("Attempted to read past end of stream!");
    }

    uint32_t result = *(uint32_t *)&memory_stream->buffer[memory_stream->read_position];

    memory_stream->read_position += sizeof(uint32_t);
    return result;
}

int32_t MemoryStream_ReadInt32(MemoryStream *memory_stream) {
    assert(memory_stream != NULL);

    if (memory_stream->write_position - memory_stream->read_position < sizeof(int32_t)) {
        LOG_ERROR("Attempted to read past end of stream!");
    }

    int32_t result = *(int32_t *)&memory_stream->buffer[memory_stream->read_position];

    memory_stream->read_position += sizeof(int32_t);
    return result;
}

double MemoryStream_ReadDouble(MemoryStream *memory_stream) {
    assert(memory_stream != NULL);

    if (memory_stream->write_position - memory_stream->read_position < sizeof(double)) {
        LOG_ERROR("Attempted to read past end of stream!");
    }

    double result = *(double *)&memory_stream->buffer[memory_stream->read_position];

    memory_stream->read_position += sizeof(double);
    return result;
}

float MemoryStream_ReadFloat(MemoryStream *memory_stream) {
    assert(memory_stream != NULL);

    if (memory_stream->write_position - memory_stream->read_position < sizeof(float)) {
        LOG_ERROR("Attempted to read past end of stream!");
    }

    float result = *(float *)&memory_stream->buffer[memory_stream->read_position];

    memory_stream->read_position += sizeof(float);
    return result;
}

void MemoryStream_SkipBytes(MemoryStream *memory_stream, const size_t bytes) {
    assert(memory_stream != NULL);

    if (memory_stream->write_position - memory_stream->read_position < bytes) {
        LOG_ERROR("Attempted to read past end of stream!");
    }
    memory_stream->read_position += bytes;
}

size_t MemoryStream_GetBytesAvailableToRead(const MemoryStream *memory_stream) {
    assert(memory_stream != NULL);

    return memory_stream->write_position - memory_stream->read_position;
}

uint8_t *MemoryStream_GetBuffer(const MemoryStream *memory_stream) {
    assert(memory_stream != NULL);

    return memory_stream->buffer;
}

size_t MemoryStream_GetTotalBytesWritten(const MemoryStream *memory_stream) {
    assert(memory_stream != NULL);

    return memory_stream->write_position;
}

```

`src/common/MemoryStream.h`:

```h
#ifndef ABYSS_MEMORY_STREAM_H
#define ABYSS_MEMORY_STREAM_H

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

typedef struct MemoryStream MemoryStream;

MemoryStream *MemoryStream_Create(bool preserve_buffer);
MemoryStream *MemoryStream_CreateFromExistingBuffer(void *buffer, size_t buffer_len);
void          MemoryStream_Destroy(MemoryStream **memory_stream);
void          MemoryStream_Resize(MemoryStream *memory_stream, size_t new_size);
void          MemoryStream_WriteUint8(MemoryStream *memory_stream, uint8_t value);
void          MemoryStream_WriteInt8(MemoryStream *memory_stream, int8_t value);
void          MemoryStream_WriteUint16(MemoryStream *memory_stream, uint16_t value);
void          MemoryStream_WriteInt16(MemoryStream *memory_stream, int16_t value);
void          MemoryStream_WriteUint32(MemoryStream *memory_stream, uint32_t value);
void          MemoryStream_WriteInt32(MemoryStream *memory_stream, int32_t value);
void          MemoryStream_WriteDouble(MemoryStream *memory_stream, double value);
void          MemoryStream_WriteFloat(MemoryStream *memory_stream, float value);
int           MemoryStream_Seek(MemoryStream *memory_stream, size_t position);
uint8_t       MemoryStream_ReadUint8(MemoryStream *memory_stream);
int8_t        MemoryStream_ReadInt8(MemoryStream *memory_stream);
uint16_t      MemoryStream_ReadUint16(MemoryStream *memory_stream);
int16_t       MemoryStream_ReadInt16(MemoryStream *memory_stream);
uint32_t      MemoryStream_ReadUint32(MemoryStream *memory_stream);
int32_t       MemoryStream_ReadInt32(MemoryStream *memory_stream);
double        MemoryStream_ReadDouble(MemoryStream *memory_stream);
float         MemoryStream_ReadFloat(MemoryStream *memory_stream);
void          MemoryStream_SkipBytes(MemoryStream *memory_stream, size_t bytes);
size_t        MemoryStream_GetBytesAvailableToRead(const MemoryStream *memory_stream);
uint8_t      *MemoryStream_GetBuffer(const MemoryStream *memory_stream);
size_t        MemoryStream_GetTotalBytesWritten(const MemoryStream *memory_stream);

#endif // ABYSS_MEMORY_STREAM_H

```

`src/common/MpqStream.c`:

```c
#include "MpqStream.h"

#include "../util/Crypto.h"
#include "../util/Huffman.h"
#include "../util/Implode.h"
#include "../util/WavDecompress.h"
#include "Logging.h"
#include "zlib.h"
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define COMPRESSION_TYPE_HUFFMAN                 0x01
#define COMPRESSION_TYPE_ZLIB_DEFLATE            0x02
#define COMPRESSION_TYPE_PKLIB_IMPLODE           0x08
#define COMPRESSION_TYPE_BZIP2                   0x10
#define COMPRESSION_TYPE_LZMA                    0x12
#define COMPRESSION_TYPE_SPARSE_THEN_ZLIB        0x22
#define COMPRESSION_TYPE_SPARSE_THEN_BZIP2       0x30
#define COMPRESSION_TYPE_IMA_ADPCM_MONO          0x40
#define COMPRESSION_TYPE_HUFFMAN_THEN_ADPCM_MONO 0x41
#define COMPRESSION_TYPE_IMA_ADPCM_STEREO        0x80
#define COMPRESSION_TYPE_HUFFMAN_THEN_WAV_STEREO 0x81

#define MIN(a, b) (((a) < (b)) ? (a) : (b))

struct MpqStream {
    char            *file_name;
    struct MPQ      *mpq;
    struct MPQHash  *hash;
    struct MPQBlock *block;
    uint64_t         size;
    uint32_t        *block_offsets;
    uint32_t         block_offset_count;
    void            *data_buffer;
    uint32_t         data_buffer_size;
    uint32_t         position;
    uint32_t         block_index;
};

struct pk_info {
    void    *buff_in;
    void    *buff_out;
    uint32_t out_pos;
    uint32_t in_pos;
    uint32_t to_read;
    uint32_t to_write;
};

void     MpqStream__LoadBlockOffset(MpqStream *mpq_stream);
uint32_t MpqStream__ReadInternal(MpqStream *mpq_stream, void *buffer, uint32_t offset, uint32_t to_read);
void     MpqStream__BufferData(MpqStream *mpq_stream);
void    *MpqStream__LoadBlock(MpqStream *mpq_stream, uint32_t block_index, uint32_t expected_length);
uint32_t MpqStream__Copy(MpqStream *mpq_stream, void *buffer, uint32_t offset, uint32_t position, uint32_t count);
void    *MpqStream__DecompressMulti(void *buffer, uint32_t to_read, uint32_t expected_length);

unsigned int explode_read(char *buf, unsigned int *size, void *param) {
    assert(buf != NULL);
    assert(*size > 0);
    assert(param != NULL);

    struct pk_info *pk_info = param;
    const uint32_t  to_read = MIN(*size, pk_info->to_read);
    memcpy(buf, (char *)pk_info->buff_in + pk_info->in_pos, to_read);
    pk_info->in_pos  += to_read;
    pk_info->to_read -= to_read;

    *size = to_read;
    return *size;
}

void explode_write(char *buf, unsigned int *size, void *param) { // NOLINT(*-non-const-parameter)
    assert(buf != NULL);
    assert(param != NULL);

    struct pk_info *pk_info = param;

    if (*size > pk_info->to_write) {
        LOG_ERROR("Attempted to write past end of stream for PkWare Explode decompression.");
    }

    memcpy((char *)pk_info->buff_out + pk_info->out_pos, buf, *size);
    pk_info->out_pos  += *size;
    pk_info->to_write -= *size;
}

MpqStream *MpqStream_Create(struct MPQ *mpq, const char *file_name) {
    assert(mpq != NULL);
    assert(file_name != NULL);

    LOG_DEBUG("Loading '%s'", file_name);

    MpqStream *result = malloc(sizeof(MpqStream));
    FAIL_IF_NULL(result);

    memset(result, 0, sizeof(MpqStream));

    result->mpq         = mpq;
    result->file_name   = strdup(file_name);
    result->block_index = 0xFFFFFFFF;
    result->size        = MPQ_GetBlockSize(mpq);

    if ((result->hash = MPQ_GetFileHash(mpq, file_name)) == NULL) {
        LOG_FATAL("Failed to load '%s'!", file_name);
    }

    result->block = MPQ_GetBlock(mpq, result->hash->block_index);

    if (result->block->flags & FILE_FLAG_FIX_KEY) {
        MPQBlock_CalculateEncryptionSeed(result->block, file_name);
    }

    if (result->block->flags & FILE_FLAG_PATCH_FILE) {
        LOG_FATAL("TODO: Patch Files");
    }

    if (((result->block->flags & FILE_FLAG_COMPRESS) || (result->block->flags & FILE_FLAG_IMPLODE)) &&
        !(result->block->flags & FILE_FLAG_SINGLE_UNIT)) {
        MpqStream__LoadBlockOffset(result);
    }

    return result;
}

void MpqStream__LoadBlockOffset(MpqStream *mpq_stream) {
    assert(mpq_stream != NULL);
    FILE *file = MPQ_AcquireFileHandle(mpq_stream->mpq);

    fseek(file, mpq_stream->block->file_position, SEEK_SET);

    mpq_stream->block_offset_count =
        (uint32_t)((mpq_stream->block->size_uncompressed + mpq_stream->size - 1) / mpq_stream->size) + 1;

    const uint32_t offset_file_load_size = sizeof(uint32_t) * mpq_stream->block_offset_count;

    mpq_stream->block_offsets = malloc(offset_file_load_size);
    FAIL_IF_NULL(mpq_stream->block_offsets);

    memset(mpq_stream->block_offsets, 0, offset_file_load_size);

    if (fread(mpq_stream->block_offsets, sizeof(uint32_t), mpq_stream->block_offset_count, file) !=
        mpq_stream->block_offset_count) {
        LOG_FATAL("Failed to load block offsets for '%s'", mpq_stream->file_name);
    }

    if (mpq_stream->block->flags & FILE_FLAG_ENCRYPTED) {
        crypto_decrypt(mpq_stream->block_offsets, mpq_stream->block_offset_count,
                       mpq_stream->block->encryption_seed - 1);

        uint64_t block_pos_size = mpq_stream->block_offset_count << 2;

        if (mpq_stream->block_offsets[0] != block_pos_size) {
            LOG_FATAL("Decryption of MPQ failed");
        }

        if (mpq_stream->block_offsets[1] > mpq_stream->block->size_uncompressed + block_pos_size) {
            LOG_FATAL("Decryption of MPQ failed");
        }
    }

    MPQ_ReleaseFileHandle(mpq_stream->mpq);
}

uint32_t MpqStream_Read(MpqStream *mpq_stream, void *buffer, uint32_t offset, uint32_t size) {
    assert(mpq_stream != NULL);
    assert(buffer != NULL);
    assert(size > 0);

    if (mpq_stream->block->flags & FILE_FLAG_SINGLE_UNIT) {
        LOG_FATAL("TODO: Single unit loads");
    }

    uint32_t to_read    = size;
    uint32_t read_total = 0;

    while (to_read > 0) {
        const uint32_t read = MpqStream__ReadInternal(mpq_stream, (char *)buffer, offset, to_read);
        if (read == 0) {
            break;
        }

        read_total += read;
        offset     += read;
        to_read    -= read;
    }

    return read_total;
}

uint32_t MpqStream__ReadInternal(MpqStream *mpq_stream, void *buffer, uint32_t offset, uint32_t to_read) {
    assert(mpq_stream != NULL);
    assert(buffer != NULL);
    assert(to_read > 0);

    MpqStream__BufferData(mpq_stream);
    const uint32_t local_position = mpq_stream->position % mpq_stream->size;
    return MpqStream__Copy(mpq_stream, buffer, offset, local_position, to_read);
}

void MpqStream__BufferData(MpqStream *mpq_stream) {
    assert(mpq_stream != NULL);

    const uint32_t block_index = mpq_stream->position / mpq_stream->size;

    if (block_index == mpq_stream->block_index) {
        return;
    }

    if (mpq_stream->data_buffer != NULL) {
        free(mpq_stream->data_buffer);
    }

    const uint32_t expected_length = (uint32_t)MIN(
        (uint64_t)mpq_stream->block->size_uncompressed - (block_index * mpq_stream->size), mpq_stream->size);
    mpq_stream->data_buffer      = MpqStream__LoadBlock(mpq_stream, block_index, expected_length);
    mpq_stream->data_buffer_size = expected_length;
    mpq_stream->block_index      = block_index;
}

void MpqStream_Destroy(MpqStream **mpq_stream) {
    assert(mpq_stream != NULL);

    if ((*mpq_stream)->block_offsets != NULL) {
        free((*mpq_stream)->block_offsets);
    }

    if ((*mpq_stream)->data_buffer != NULL) {
        free((*mpq_stream)->data_buffer);
    }
    free((*mpq_stream)->file_name);
    free((*mpq_stream));
    *mpq_stream = NULL;
}

uint32_t MpqStream__Copy(MpqStream *mpq_stream, void *buffer, uint32_t offset, uint32_t position, uint32_t count) {
    assert(mpq_stream != NULL);
    assert(buffer != NULL);
    assert(count > 0);

    const uint32_t bytes_to_copy = MIN(mpq_stream->data_buffer_size - position, count);

    if (bytes_to_copy <= 0) {
        //        LOG_FATAL("Tried reading past end of stream!");
        return 0;
    }

    memcpy((char *)buffer + offset, (char *)mpq_stream->data_buffer + position, bytes_to_copy);
    mpq_stream->position += bytes_to_copy;

    return bytes_to_copy;
}

void *MpqStream__LoadBlock(MpqStream *mpq_stream, uint32_t block_index, uint32_t expected_length) {
    assert(mpq_stream != NULL);
    assert(expected_length > 0);

    uint32_t offset;
    uint32_t to_read;

    if ((mpq_stream->block->flags & FILE_FLAG_COMPRESS) || (mpq_stream->block->flags & FILE_FLAG_IMPLODE)) {
        offset  = mpq_stream->block_offsets[block_index];
        to_read = mpq_stream->block_offsets[block_index + 1] - offset;
    } else {
        offset  = block_index * (uint32_t)mpq_stream->size;
        to_read = expected_length;
    }

    offset += mpq_stream->block->file_position;

    void *data = malloc(to_read);
    FAIL_IF_NULL(data);

    FILE *file = MPQ_AcquireFileHandle(mpq_stream->mpq);
    fseek(file, offset, SEEK_SET);
    if (fread(data, to_read, 1, file) != 1) {
        LOG_FATAL("Error loading file block data.");
    }

    if ((mpq_stream->block->flags & FILE_FLAG_ENCRYPTED) && mpq_stream->block->size_uncompressed > 3) {
        if (mpq_stream->block->encryption_seed == 0) {
            LOG_FATAL("Unable to determine encryption key for file block load.");
        }

        crypto_decrypt_bytes(data, to_read, block_index + mpq_stream->block->encryption_seed);
    }

    if ((mpq_stream->block->flags & FILE_FLAG_COMPRESS) && (to_read != expected_length)) {
        if (mpq_stream->block->flags & FILE_FLAG_SINGLE_UNIT) {
            LOG_FATAL("TODO: PK Decompression");
        }

        void *result = MpqStream__DecompressMulti(data, to_read, expected_length);
        MPQ_ReleaseFileHandle(mpq_stream->mpq);
        return result;
    }

    if ((mpq_stream->block->flags & FILE_FLAG_IMPLODE) && (to_read != expected_length)) {
        LOG_FATAL("TODO: PK decompress");
    }

    MPQ_ReleaseFileHandle(mpq_stream->mpq);
    return data;
}

void *MpqStream__DecompressMulti(void *buffer, uint32_t to_read, uint32_t expected_length) {
    assert(buffer != NULL);
    assert(to_read > 0);
    assert(expected_length > 0);

    const uint8_t compression_type = ((uint8_t *)buffer)[0];

    switch (compression_type) {
    case COMPRESSION_TYPE_ZLIB_DEFLATE: {
        void *out_buffer = malloc(expected_length + 1);
        FAIL_IF_NULL(out_buffer);

        memset(out_buffer, 0, expected_length + 1);
        z_stream inflate_stream;
        inflate_stream.zalloc    = Z_NULL;
        inflate_stream.zfree     = Z_NULL;
        inflate_stream.opaque    = Z_NULL;
        inflate_stream.avail_in  = to_read - 1;
        inflate_stream.next_in   = (Bytef *)buffer + 1;
        inflate_stream.avail_out = expected_length;
        inflate_stream.next_out  = (Bytef *)out_buffer;
        inflateInit(&inflate_stream);
        inflate(&inflate_stream, Z_NO_FLUSH);
        inflateEnd(&inflate_stream);

        if (inflate_stream.msg != NULL) {
            LOG_FATAL("ZLIB Deflate Error: %s", inflate_stream.msg);
        }

        free(buffer);
        return out_buffer;
    }
    case COMPRESSION_TYPE_PKLIB_IMPLODE: {
        void *out_buffer = malloc(expected_length + 1);
        FAIL_IF_NULL(out_buffer);

        struct pk_info pk_info;
        memset(&pk_info, 0, sizeof(struct pk_info));
        pk_info.buff_out = out_buffer;
        pk_info.buff_in  = (char *)buffer + 1;
        pk_info.to_read  = to_read - 1;
        pk_info.to_write = expected_length;

        char *work_buff = malloc(15000);
        FAIL_IF_NULL(work_buff);

        memset(work_buff, 0, 15000);
        memset(out_buffer, 0, expected_length + 1);
        const int pk_result = explode(explode_read, explode_write, work_buff, &pk_info);

        if (pk_result != CMP_NO_ERROR) {
            LOG_FATAL("Failed to decompress using PkWare Explode: %d.", pk_result);
        }

        if (pk_info.out_pos != expected_length) {
            LOG_FATAL("Decompression failed. Expected %d bytes but got %d instead!", expected_length, pk_info.out_pos);
        }

        free(work_buff);
        free(buffer);
        return out_buffer;
    }
    case COMPRESSION_TYPE_HUFFMAN_THEN_ADPCM_MONO: {
        uint32_t huffman_buffer_size = 0;
        uint8_t *huffman_buffer      = huffman_decompress((uint8_t *)buffer + 1, to_read - 1, &huffman_buffer_size);

        uint32_t wav_size   = 0;
        uint8_t *wav_buffer = WAV_Decompress(huffman_buffer, huffman_buffer_size, 1, &wav_size);
        if (wav_size != expected_length) {
            LOG_FATAL("Decompression failed: Expected WAV buffer of %d bytes, but got %d instead!", expected_length,
                      wav_size);
        }
        free(huffman_buffer);
        free(buffer);
        return wav_buffer;
    }
    case COMPRESSION_TYPE_HUFFMAN_THEN_WAV_STEREO: {
        uint32_t huffman_buffer_size = 0;
        uint8_t *huffman_buffer      = huffman_decompress((uint8_t *)buffer + 1, to_read - 1, &huffman_buffer_size);

        uint32_t wav_size   = 0;
        uint8_t *wav_buffer = WAV_Decompress(huffman_buffer, huffman_buffer_size, 2, &wav_size);
        if (wav_size != expected_length) {
            LOG_FATAL("Decompression failed: Expected WAV buffer of %d bytes, but got %d instead!", expected_length,
                      wav_size);
        }
        free(huffman_buffer);
        free(buffer);
        return wav_buffer;
    }
    default:
        LOG_FATAL("Compression Type $%02X not supported!", compression_type);
    }
}

uint32_t MpqStream_GetSize(const MpqStream *mpq_stream) {
    assert(mpq_stream != NULL);

    return mpq_stream->block->size_uncompressed;
}

bool MpqStream_GetIsEof(const MpqStream *mpq_stream) {
    assert(mpq_stream != NULL);

    return mpq_stream->position >= mpq_stream->block->size_uncompressed;
}

void MpqStream_Seek(MpqStream *mpq_stream, int64_t position, int32_t origin) {
    assert(mpq_stream != NULL);

    switch (origin) {
    case SEEK_SET:
        mpq_stream->position = (uint32_t)position;
        break;
    case SEEK_CUR:
        mpq_stream->position += (uint32_t)position;
        break;
    case SEEK_END:
        mpq_stream->position = mpq_stream->block->size_uncompressed + (uint32_t)position;
        break;
    default:
        LOG_FATAL("Invalid origin for seek: %d", origin);
    }

    if (mpq_stream->position >= mpq_stream->block->size_uncompressed) {
        mpq_stream->position = mpq_stream->block->size_uncompressed;
    }
}

uint32_t MpqStream_Tell(const MpqStream *mpq_stream) {
    assert(mpq_stream != NULL);

    return mpq_stream->position;
}

```

`src/common/MpqStream.h`:

```h
#ifndef ABYSS_MPQ_STREAM_H
#define ABYSS_MPQ_STREAM_H

#include "../types/MPQ.h"
#include <stdint.h>

typedef struct MpqStream MpqStream;

MpqStream *MpqStream_Create(struct MPQ *mpq, const char *file_name);
void       MpqStream_Destroy(MpqStream **mpq_stream);
uint32_t   MpqStream_GetSize(const MpqStream *MpqStream);
uint32_t   MpqStream_Read(MpqStream *mpq_stream, void *buffer, uint32_t offset, uint32_t size);
bool       MpqStream_GetIsEof(const MpqStream *MpqStream);
void       MpqStream_Seek(MpqStream *mpq_stream, int64_t position, int32_t origin);
uint32_t   MpqStream_Tell(const MpqStream *mpq_stream);

#endif // ABYSS_MPQ_STREAM_H

```

`src/common/ResourcePaths.h`:

```h
#ifndef ABYSS_RESOURCEPATHS_H
#define ABYSS_RESOURCEPATHS_H

#define CURSOR_DEFAULT "/data/global/ui/CURSOR/ohand.DC6"

// -- Main Menu
#define TRADEMARK_SCREEN   "/data/global/ui/FrontEnd/trademarkscreenEXP.DC6"
#define GAME_SELECT_SCREEN "/data/global/ui/FrontEnd/gameselectscreenEXP.DC6"
#define D2LOGO_BLACK_LEFT  "/data/global/ui/FrontEnd/D2logoBlackLeft.DC6"
#define D2LOGO_BLACK_RIGHT "/data/global/ui/FrontEnd/D2logoBlackRight.DC6"
#define D2LOGO_FIRE_LEFT   "/data/global/ui/FrontEnd/D2logoFireLeft.DC6"
#define D2LOGO_FIRE_RIGHT  "/data/global/ui/FrontEnd/D2logoFireRight.DC6"

// --- Credits ---

#define RESOURCE_PATH_CREDITS_TEXT = "/data/local/ui/%s/ExpansionCredits.txt"

// --

#define LOADING_SCREEN "/data/global/ui/loading/loadingscreen.DC6"

// -- Palettes
#define PALETTE_PATH       "/data/global/Palette/%s/pal.dat"
#define PALETTE_ACT_1      "act1"
#define PALETTE_ACT_2      "act2"
#define PALETTE_ACT_3      "act3"
#define PALETTE_ACT_4      "act4"
#define PALETTE_ACT_5      "act5"
#define PALETTE_END_GAME   "endgame"
#define PALETTE_END_GAME_2 "endgame2"
#define PALETTE_FECHAR     "fechar"
#define PALETTE_LOADING    "loading"
#define PALETTE_MENU_0     "menu0"
#define PALETTE_MENU_1     "menu1"
#define PALETTE_MENU_2     "menu2"
#define PALETTE_MENU_3     "menu3"
#define PALETTE_MENU_4     "menu4"
#define PALETTE_SKY        "sky"
#define PALETTE_STATIC     "static"
#define PALETTE_TRADEMARK  "trademark"
#define PALETTE_UNITS      "units"

// -- Fonts
#define FONTS_FONT6          "/data/local/FONT/%s/font6"
#define FONTS_FONT8          "/data/local/FONT/%s/font8"
#define FONTS_FONT16         "/data/local/FONT/%s/font16"
#define FONTS_FONT24         "/data/local/FONT/%s/font24"
#define FONTS_FONT30         "/data/local/FONT/%s/font30"
#define FONTS_FONT42         "/data/local/FONT/%s/font42"
#define FONTS_FONTFORMAL10   "/data/local/FONT/%s/fontformal10"
#define FONTS_FONTFORMAL11   "/data/local/FONT/%s/fontformal11"
#define FONTS_FONTFORMAL12   "/data/local/FONT/%s/fontformal12"
#define FONTS_FONTEXOCET8    "/data/local/FONT/%s/fontexocet8"
#define FONTS_FONTEXOCET10   "/data/local/FONT/%s/fontexocet10"
#define FONTS_FONTSUCKER     "/data/local/FONT/%s/ReallyTheLastSucker"
#define FONTS_FONTREDICULOUS "/data/local/FONT/%s/fontridiculous"

// -- Music
#define MUSIC_TITLE                     "/data/global/music/introedit.wav"
#define MUSIC_OPTIONS                   "/data/global/music/Common/options.wav"
#define MUSIC_ACT1_ANDARIELACTION       "/data/global/music/Act1/andarielaction.wav"
#define MUSIC_ACT1_BLOODRAVENRESOLUTION "/data/global/music/Act1/bloodravenresolution.wav"
#define MUSIC_ACT1_CAVES                "/data/global/music/Act1/caves.wav"
#define MUSIC_ACT1_CRYPT                "/data/global/music/Act1/crypt.wav"
#define MUSIC_ACT1_DENOFEVILACTION      "/data/global/music/Act1/denofevilaction.wav"
#define MUSIC_ACT1_MONASTERY            "/data/global/music/Act1/monastery.wav"
#define MUSIC_ACT1_TOWN1                "/data/global/music/Act1/town1.wav"
#define MUSIC_ACT1_TRISTRAM             "/data/global/music/Act1/tristram.wav"
#define MUSIC_ACT1_WILD                 "/data/global/music/Act1/wild.wav"
#define MUSIC_ACT2_DESERT               "/data/global/music/Act2/desert.wav"
#define MUSIC_ACT2_HAREM                "/data/global/music/Act2/harem.wav"
#define MUSIC_ACT2_HORADRICACTION       "/data/global/music/Act2/horadricaction.wav"
#define MUSIC_ACT2_LAIR                 "/data/global/music/Act2/lair.wav"
#define MUSIC_ACT2_RADAMENTRESOLUTION   "/data/global/music/Act2/radamentresolution.wav"
#define MUSIC_ACT2_SANCTUARY            "/data/global/music/Act2/sanctuary.wav"
#define MUSIC_ACT2_SEWER                "/data/global/music/Act2/sewer.wav"
#define MUSIC_ACT2_TAINTEDSUNACTION     "/data/global/music/Act2/taintedsunaction.wav"
#define MUSIC_ACT2_TOMBS                "/data/global/music/Act2/tombs.wav"
#define MUSIC_ACT2_TOWN2                "/data/global/music/Act2/town2.wav"
#define MUSIC_ACT2_VALLEY               "/data/global/music/Act2/valley.wav"
#define MUSIC_ACT3_JUNGLE               "/data/global/music/Act3/jungle.wav"
#define MUSIC_ACT3_KURAST               "/data/global/music/Act3/kurast.wav"
#define MUSIC_ACT3_KURASTSEWER          "/data/global/music/Act3/kurastsewer.wav"
#define MUSIC_ACT3_MEFDEATHACTION       "/data/global/music/Act3/mefdeathaction.wav"
#define MUSIC_ACT3_ORBACTION            "/data/global/music/Act3/orbaction.wav"
#define MUSIC_ACT3_SPIDER               "/data/global/music/Act3/spider.wav"
#define MUSIC_ACT3_TOWN3                "/data/global/music/Act3/town3.wav"
#define MUSIC_ACT4_DIABLO               "/data/global/music/Act4/diablo.wav"
#define MUSIC_ACT4_DIABLOACTION         "/data/global/music/Act4/diabloaction.wav"
#define MUSIC_ACT4_FORGEACTION          "/data/global/music/Act4/forgeaction.wav"
#define MUSIC_ACT4_IZUALACTION          "/data/global/music/Act4/izualaction.wav"
#define MUSIC_ACT4_MESA                 "/data/global/music/Act4/mesa.wav"
#define MUSIC_ACT4_TOWN4                "/data/global/music/Act4/town4.wav"
#define MUSIC_ACT5_BAAL                 "/data/global/music/Act5/baal.wav"
#define MUSIC_ACT5_SIEGE                "/data/global/music/Act5/siege.wav"
#define MUSIC_ACT5_SHENK                "/data/global/music/Act5/shenkmusic.wav"
#define MUSIC_ACT5_XTOWN                "/data/global/music/Act5/xtown.wav"
#define MUSIC_ACT5_XTEMPLE              "/data/global/music/Act5/xtemple.wav"
#define MUSIC_ACT5_ICECAVES             "/data/global/music/Act5/icecaves.wav"
#define MUSIC_ACT5_NIHLATHAK            "/data/global/music/Act5/nihlathakmusic.wav"

// -- Videos
#define VIDEO_BLIZZARD_STARTUP_1 "/data/local/video/New_Bliz640x480.bik"
#define VIDEO_BLIZZARD_STARTUP_2 "/data/local/video/BlizNorth640x480.bik"
#endif // ABYSS_RESOURCEPATHS_H

```

`src/common/RingBuffer.c`:

```c
#include "RingBuffer.h"
#include <assert.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#ifdef NO_LOGGING
#undef FAIL_IF_NULL
#define FAIL_IF_NULL(ptr)                                                                                              \
    if (ptr == NULL) {                                                                                                 \
        LOG_FATAL("Failed to allocate memory.");                                                                       \
    }
#define LOG_FATAL(...) assert(0)
#else
#include "Logging.h"
#endif

struct RingBuffer {
    uint32_t size;
    uint32_t read_position;
    uint32_t write_position;
    uint32_t remaining_to_read;
    uint32_t remaining_to_write;
    char    *buffer;
    Mutex   *mutex;
};

RingBuffer *RingBuffer_Create(uint32_t size) {
    assert(size > 0);

    RingBuffer *result = malloc(sizeof(RingBuffer));

    result->size               = size;
    result->read_position      = 0;
    result->write_position     = 0;
    result->remaining_to_read  = 0;
    result->remaining_to_write = size;
    result->buffer             = malloc(size);
    result->mutex              = Mutex_Create();

    memset(result->buffer, 0, size);

    FAIL_IF_NULL(result->buffer);
    return result;
}

void RingBuffer_Destroy(RingBuffer **ring_buffer) {
    Mutex_Destroy(&(*ring_buffer)->mutex);
    free((*ring_buffer)->buffer);
    free(*ring_buffer);

    *ring_buffer = NULL;
}

void RingBuffer_Write(RingBuffer *ring_buffer, const char *data, uint32_t length) {
    Mutex_Lock(ring_buffer->mutex);

    assert(data != NULL);
    assert(length > 0);

    if (ring_buffer->remaining_to_write < length) {
        LOG_FATAL("Not enough space in ring buffer to write %d bytes", length);
    }

    const uint32_t write_position = ring_buffer->write_position;
    const uint32_t size           = ring_buffer->size;
    const uint32_t remaining      = size - write_position;

    if (remaining >= length) {
        memcpy(ring_buffer->buffer + write_position, data, length);
    } else {
        memcpy(ring_buffer->buffer + write_position, data, remaining);
        memcpy(ring_buffer->buffer, data + remaining, length - remaining);
    }

    ring_buffer->write_position      = (write_position + length) % size;
    ring_buffer->remaining_to_read  += length;
    ring_buffer->remaining_to_write -= length;

    Mutex_Unlock(ring_buffer->mutex);
}

uint32_t RingBuffer_Read(RingBuffer *ring_buffer, char *buffer, uint32_t length) {
    assert(ring_buffer != NULL);
    assert(buffer != NULL);
    assert(length > 0);

    Mutex_Lock(ring_buffer->mutex);
    if (ring_buffer->remaining_to_read < length) {
        LOG_FATAL("Not enough data in ring buffer to read %d bytes", length);
    }

    const uint32_t read_position = ring_buffer->read_position;
    const uint32_t size          = ring_buffer->size;
    const uint32_t remaining     = size - read_position;

    if (remaining >= length) {
        memcpy(buffer, ring_buffer->buffer + read_position, length);
    } else {
        memcpy(buffer, ring_buffer->buffer + read_position, remaining);
        memcpy(buffer + remaining, ring_buffer->buffer, length - remaining);
    }

    ring_buffer->read_position       = (read_position + length) % size;
    ring_buffer->remaining_to_read  -= length;
    ring_buffer->remaining_to_write += length;

    Mutex_Unlock(ring_buffer->mutex);
    return length;
}
size_t RingBuffer_GetRemainingToRead(RingBuffer *ring_buffer) {
    Mutex_Lock(ring_buffer->mutex);
    size_t result = ring_buffer->remaining_to_read;
    Mutex_Unlock(ring_buffer->mutex);
    return result;
}

```

`src/common/RingBuffer.h`:

```h
#ifndef ABYSS_RING_BUFFER_H
#define ABYSS_RING_BUFFER_H

#include "../util/Mutex.h"
#include <stdint.h>
#include <stdlib.h>

typedef struct RingBuffer RingBuffer;

RingBuffer *RingBuffer_Create(uint32_t size);
void        RingBuffer_Destroy(RingBuffer **ring_buffer);
void        RingBuffer_Write(RingBuffer *ring_buffer, const char *data, uint32_t length);
uint32_t    RingBuffer_Read(RingBuffer *ring_buffer, char *buffer, uint32_t length);
size_t      RingBuffer_GetRemainingToRead(RingBuffer *ring_buffer);

#endif // ABYSS_RING_BUFFER_H

```

`src/drawing/CMakeLists.txt`:

```txt
target_sources(${PROJECT_NAME}
        PRIVATE
        Cursor.c Cursor.h
        Label.c Label.h
        Sprite.c Sprite.h
)
```

`src/drawing/Cursor.c`:

```c
#include "Cursor.h"

#include "../common/Globals.h"
#include "../managers/InputManager.h"
#include "Sprite.h"

#define CURSOR_FRAME_NORMAL  0
#define CURSOR_FRAME_PRESSED 5
#define CURSOR_FRAME_HAND    6

struct Sprite  *cursor_sprite;
enum CursorType cursor_sprite_type;
bool            cursor_visible;

void Cursor_CreateSingleton(void) {
    cursor_sprite  = Sprite_Create(CURSOR_DEFAULT, PALETTE_UNITS);
    cursor_visible = true;
    Cursor_SetType(CURSOR_STANDARD);

    Sprite_SetBlendMode(cursor_sprite, SDL_BLENDMODE_BLEND);
}

void Cursor_Destroy(void) { Sprite_Destroy(&cursor_sprite); }

void Cursor_Draw(void) {
    if (!cursor_visible) {
        return;
    }
    int mouse_x;
    int mouse_y;
    InputManager_GetMousePosition(&mouse_x, &mouse_y);

    Sprite_Draw(cursor_sprite, cursor_sprite_type, mouse_x, mouse_y + 2);
}

void Cursor_SetType(enum CursorType cursor_type) { cursor_sprite_type = cursor_type; }

void Cursor_SetVisible(bool visible) { cursor_visible = visible; }

```

`src/drawing/Cursor.h`:

```h
#ifndef ABYSS_CURSOR_H
#define ABYSS_CURSOR_H

#include <stdbool.h>

enum CursorType { CURSOR_STANDARD, CURSOR_PRESSED };

void Cursor_CreateSingleton(void);
void Cursor_Destroy(void);
void Cursor_Draw(void);
void Cursor_SetType(enum CursorType cursor_type);
void Cursor_SetVisible(bool visible);

#endif // ABYSS_CURSOR_H

```

`src/drawing/Label.c`:

```c
#include "Label.h"
#include "../common/AbyssConfiguration.h"
#include "../common/Globals.h"
#include "../common/Logging.h"

struct Label {
    DC6           *DC6;
    Font          *Font;
    const Palette *Palette;
    SDL_Texture   *texture;
    uint16_t       width;
    uint16_t       height;
    label_align_t  horizontal_align;
    label_align_t  vertical_align;
    int            offset_x;
    int            offset_y;
    char          *text;
};

void Label__UpdateOffsets(Label *Label);

Label *Label_Create(const char *font_path, const char *palette_name) {
    char dc6_path[4096];

    Label *result = malloc(sizeof(Label));
    FAIL_IF_NULL(result);
    memset(result, 0, sizeof(Label));

    memset(dc6_path, 0, sizeof(dc6_path));
    snprintf(dc6_path, sizeof(dc6_path), font_path, AbyssConfiguration_GetLocale());
    strncat(dc6_path, ".DC6", sizeof(dc6_path) - strlen(dc6_path) - 1);

    result->Font    = Font_Load(font_path);
    result->DC6     = DC6_Load(dc6_path);
    result->Palette = Palette_Get(palette_name);

    return result;
}

void Label_Destroy(Label **label) {
    if ((*label)->texture != NULL) {
        SDL_DestroyTexture((*label)->texture);
    }

    if ((*label)->text != NULL) {
        free((*label)->text);
    }

    Font_Destroy((*label)->Font);
    DC6_Destroy(&(*label)->DC6);

    free((*label));
    *label = NULL;
}

void Label_InitializeCaches(void) { LOG_DEBUG("Initializing Label caches..."); }

void Label_FinalizeCaches(void) { LOG_DEBUG("Finalizing Label caches..."); }

void Label_SetText(Label *label, const char *text) {
    if (label->texture != NULL) {
        SDL_DestroyTexture(label->texture);
    }

    if (label->text != NULL) {
        if (strcmp(label->text, text) == 0) {
            return;
        }

        free(label->text);
    }

    if (text == NULL || text[0] == '\0') {
        label->width  = 0;
        label->height = 0;

        if (label->texture != NULL) {
            SDL_DestroyTexture(label->texture);
            label->texture = NULL;
        }

        return;
    }

    label->text   = strdup(text);
    label->width  = 0;
    label->height = 0;

    for (const char *ch = text; *ch; ch++) {
        uint16_t frame_index;
        uint8_t  frame_width;
        uint32_t frame_height;

        Font_GetGlyphMetrics(label->Font, *ch, &frame_index, &frame_width, NULL);
        DC6_GetFrameSize(label->DC6, frame_index, NULL, &frame_height);

        label->width  += frame_width;
        label->height  = label->height > frame_height ? label->height : frame_height;
    }

    if (label->width == 0 || label->height == 0) {
        return;
    }

    label->texture = SDL_CreateTexture(sdl_renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_STATIC, label->width,
                                       label->height);
    FAIL_IF_NULL(label->texture);

    uint32_t *pixels = malloc((label->width * label->height) * sizeof(uint32_t));
    FAIL_IF_NULL(pixels);
    memset(pixels, 0, (label->width * label->height) * sizeof(uint32_t));

    int offset_x = 0;
    for (const char *ch = text; *ch; ch++) {
        uint16_t frame_index;
        uint32_t frame_width;
        uint8_t  glyph_width;
        uint32_t frame_height;

        Font_GetGlyphMetrics(label->Font, *ch, &frame_index, &glyph_width, NULL);
        DC6_GetFrameSize(label->DC6, frame_index, &frame_width, &frame_height);

        const uint8_t *frame_pixel_data = DC6_GetFramePixelData(label->DC6, frame_index);

        for (uint32_t y = 0; y < frame_height; y++) {
            if (y >= label->height) {
                break;
            }
            for (uint32_t x = 0; x < frame_width; x++) {
                if (x + offset_x >= label->width) {
                    break;
                }
                const uint8_t  palette_index = frame_pixel_data[(y * frame_width) + x];
                const uint32_t pixel_index   = (y * label->width) + x + offset_x;

                if (palette_index == 0) {
                    continue;
                }

                pixels[pixel_index] = label->Palette->entries[palette_index];
            }
        }

        offset_x += glyph_width;
    }

    SDL_UpdateTexture(label->texture, NULL, pixels, label->width * 4);
    SDL_SetTextureBlendMode(label->texture, SDL_BLENDMODE_BLEND);
    free(pixels);

    Label__UpdateOffsets(label);
}

void Label_Draw(const Label *Label, int x, int y) {
    if (Label->texture == NULL) {
        return;
    }

    const SDL_Rect dest = {x + Label->offset_x, y + Label->offset_y, Label->width, Label->height};
    SDL_RenderCopy(sdl_renderer, Label->texture, NULL, &dest);
}

void Label_SetColor(Label *label, uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
    SDL_SetTextureColorMod(label->texture, r, g, b);
    SDL_SetTextureAlphaMod(label->texture, a);
}

void Label_SetAlignment(Label *label, label_align_t horizontal, label_align_t vertical) {
    label->horizontal_align = horizontal;
    label->vertical_align   = vertical;
    Label__UpdateOffsets(label);
}
void Label__UpdateOffsets(Label *label) {
    switch (label->horizontal_align) {
    case LABEL_ALIGN_BEGIN:
        label->offset_x = 0;
        break;
    case LABEL_ALIGN_CENTER:
        label->offset_x = -label->width / 2;
        break;
    case LABEL_ALIGN_END:
        label->offset_x = -label->width;
        break;
    default:
        LOG_FATAL("Invalid horizontal alignment value: %d", label->horizontal_align);
    }

    switch (label->vertical_align) {
    case LABEL_ALIGN_BEGIN:
        label->offset_y = 0;
        break;
    case LABEL_ALIGN_CENTER:
        label->offset_y = -label->height / 2;
        break;
    case LABEL_ALIGN_END:
        label->offset_y = -label->height;
        break;
    default:
        LOG_FATAL("Invalid vertical alignment value: %d", label->vertical_align);
    }
}

```

`src/drawing/Label.h`:

```h
#ifndef ABYSS_LABEL_H
#define ABYSS_LABEL_H

#include "../types/DC6.h"
#include "../types/Font.h"
#include "../types/Palette.h"
#include <SDL2/SDL.h>

typedef uint8_t label_align_t;
#define LABEL_ALIGN_BEGIN  (label_align_t)0
#define LABEL_ALIGN_CENTER (label_align_t)1
#define LABEL_ALIGN_END    (label_align_t)2

typedef struct Label Label;

void Label_InitializeCaches(void);
void Label_FinalizeCaches(void);

Label *Label_Create(const char *font_path, const char *palette_name);
void   Label_Destroy(Label **Label);
void   Label_SetText(Label *Label, const char *text);
void   Label_Draw(const Label *Label, int x, int y);
void   Label_SetColor(Label *Label, uint8_t r, uint8_t g, uint8_t b, uint8_t a);
void   Label_SetAlignment(Label *Label, label_align_t horizontal, label_align_t vertical);

#endif // ABYSS_LABEL_H

```

`src/drawing/Sprite.c`:

```c
#include "Sprite.h"
#include "../common/Globals.h"
#include "../common/Logging.h"
#include "../types/DC6.h"
#include "../types/Palette.h"
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

typedef struct SpriteFrame {
    SDL_Texture *texture;
    uint32_t     width;
    uint32_t     height;
    int32_t      offset_x;
    int32_t      offset_y;
} SpriteFrame;

struct Sprite {
    struct SpriteFrame *frames;
    uint32_t            frame_count;
    double              play_length;
    uint32_t            ticks_per_frame;
    uint64_t            last_ticks;
    uint32_t            animation_index;
};

void Sprite__LoadDC6(Sprite *sprite, const char *path, const char *palette_name);

char *get_extension(const char *path) {
    const char *ext = strrchr(path, '.') + 1;
    if (strlen(path) <= (size_t)(ext - path)) {
        LOG_FATAL("Invalid path extension for '%s'.", path);
    }

    char *result = strdup(ext);
    for (char *ch = result; *ch; ch++) {
        *ch = (char)tolower((int)*ch);
    }

    return result;
}

Sprite *Sprite_Create(const char *path, const char *palette_name) {
    Sprite *result = malloc(sizeof(Sprite));
    FAIL_IF_NULL(result);

    memset(result, 0, sizeof(Sprite));

    char *file_ext = get_extension(path);

    if (strcmp(file_ext, "dc6") == 0) {
        Sprite__LoadDC6(result, path, palette_name);
    } else {
        LOG_FATAL("Could not load Sprite: '%s' is an unsupported file extension.", file_ext);
    }

    free(file_ext);
    return result;
}

void Sprite__LoadDC6(Sprite *sprite, const char *path, const char *palette_name) {
    struct DC6           *dc6     = DC6_Load(path);
    const struct Palette *Palette = Palette_Get(palette_name);

    sprite->frame_count     = DC6_GetTotalFrameCount(dc6);
    sprite->frames          = malloc(sizeof(SpriteFrame) * sprite->frame_count);
    sprite->last_ticks      = SDL_GetTicks64();
    sprite->animation_index = 0;

    FAIL_IF_NULL(sprite->frames);

    Sprite_SetPlayLength(sprite, 1.0f);

    for (uint32_t i = 0; i < sprite->frame_count; i++) {
        SpriteFrame   *spr_frame        = &sprite->frames[i];
        const uint8_t *frame_pixel_data = DC6_GetFramePixelData(dc6, i);

        DC6_GetFrameSize(dc6, i, &spr_frame->width, &spr_frame->height);
        DC6_GetFrameOffset(dc6, i, &spr_frame->offset_x, &spr_frame->offset_y);

        spr_frame->texture = SDL_CreateTexture(sdl_renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_STATIC,
                                               (int)spr_frame->width, (int)spr_frame->height);

        uint32_t *pixels = malloc((size_t)spr_frame->width * spr_frame->height * 4);
        FAIL_IF_NULL(pixels);
        memset(pixels, 0, (size_t)spr_frame->width * spr_frame->height * 4);

        for (uint32_t idx = 0; idx < (spr_frame->width * spr_frame->height); idx++) {
            pixels[idx] = Palette->entries[frame_pixel_data[idx]];
        }

        SDL_UpdateTexture(spr_frame->texture, NULL, pixels, (int)spr_frame->width * 4);
        free(pixels);
    }

    DC6_Destroy(&dc6);
}

void Sprite_Destroy(Sprite **sprite) {
    for (uint32_t i = 0; i < (*sprite)->frame_count; i++) {
        SDL_DestroyTexture((*sprite)->frames[i].texture);
    }

    free((*sprite)->frames);

    free(*sprite);
    *sprite = NULL;
}

void Sprite_Draw(const Sprite *sprite, uint8_t frame_index, int x, int y) {
    const SpriteFrame *frame = &sprite->frames[frame_index];

    const SDL_Rect dest = {x + frame->offset_x, y - (int)frame->height + frame->offset_y, (int)frame->width,
                           (int)frame->height};

    SDL_RenderCopy(sdl_renderer, frame->texture, NULL, &dest);
}

void Sprite_DrawAnimated(Sprite *sprite, int x, int y) {
    if (sprite->ticks_per_frame == 0) {
        LOG_FATAL("Attempted to animate a Sprite with no ticks per frame!");
    }

    const uint64_t cur_ticks  = SDL_GetTicks64();
    uint64_t       tick_delta = cur_ticks - sprite->last_ticks;

    while (tick_delta >= sprite->ticks_per_frame) {
        sprite->last_ticks += sprite->ticks_per_frame;
        tick_delta         -= sprite->ticks_per_frame;
        if (++sprite->animation_index >= sprite->frame_count) {
            sprite->animation_index = 0;
        }
    }

    Sprite_Draw(sprite, (uint8_t)sprite->animation_index, x, y);
}

void Sprite_DrawMulti(const Sprite *sprite, uint8_t frame_index, int x, int y, int frames_x, int frames_y) {
    int cur_x     = x;
    int cur_y     = y;
    int cur_frame = frame_index;

    for (int py = 0; py < frames_y; py++) {
        for (int px = 0; px < frames_x; px++) {
            const SpriteFrame *frame = &sprite->frames[cur_frame++];
            SDL_Rect           dest  = {cur_x, cur_y, (int)frame->width, (int)frame->height};
            SDL_RenderCopy(sdl_renderer, frame->texture, NULL, &dest);
            cur_x += (int)sprite->frames[cur_frame - 1].width;
        }
        cur_x  = x;
        cur_y += (int)sprite->frames[cur_frame - 1].height;
    }
}

void Sprite_SetBlendMode(const Sprite *sprite, SDL_BlendMode blend_mode) {
    for (uint32_t frame_idx = 0; frame_idx < sprite->frame_count; frame_idx++) {
        SDL_SetTextureBlendMode(sprite->frames[frame_idx].texture, blend_mode);
    }
}

void Sprite_SetPlayLength(Sprite *sprite, const double play_length) {
    sprite->play_length     = play_length;
    sprite->ticks_per_frame = (uint32_t)((1000 * play_length) / (double)sprite->frame_count);
}

```

`src/drawing/Sprite.h`:

```h
#ifndef ABYSS_SPRITE_H
#define ABYSS_SPRITE_H

#include <SDL2/SDL.h>
#include <stdbool.h>
#include <stdint.h>

typedef struct Sprite Sprite;

Sprite *Sprite_Create(const char *path, const char *palette_name);
void    Sprite_Destroy(Sprite **sprite);
void    Sprite_SetBlendMode(const Sprite *sprite, SDL_BlendMode blend_mode);
void    Sprite_SetPlayLength(Sprite *sprite, double play_length);
void    Sprite_Draw(const Sprite *sprite, uint8_t frame_index, int x, int y);
void    Sprite_DrawMulti(const Sprite *sprite, uint8_t frame_index, int x, int y, int frames_x, int frames_y);
void    Sprite_DrawAnimated(Sprite *sprite, int x, int y);

#endif // ABYSS_SPRITE_H

```

`src/managers/AudioManager.c`:

```c
#include "AudioManager.h"
#include "../common/AbyssConfiguration.h"
#include "../common/Logging.h"
#include "../managers/VideoManager.h"

typedef struct AudioManager {
    bool                audio_available;
    bool                audio_mute;
    SDL_AudioDeviceID   audio_device_id;
    SDL_AudioSpec       audio_spec;
    enum AVSampleFormat out_sample_format;
    AVChannelLayout     channel_layout;
    struct AudioStream *background_music;
    float               volume[AUDIO_SET_VOLUME_TYPE_MAX];
    float               volume_actual[AUDIO_SET_VOLUME_TYPE_MAX];
} AudioManager;

AudioManager *audio_manager;

void AudioManager_FillBuffer(void *userdata, Uint8 *stream, int len) {
    memset(stream, 0, len);

    if (len & 1) {
        LOG_WARN("Audio buffer length is not even, dropping samples...");
        return;
    }

    AudioManager *manager = (AudioManager *)userdata;

    if (audio_manager->audio_mute) {
        return;
    }

    float volume_bgm    = audio_manager->volume_actual[AUDIO_SET_VOLUME_TYPE_MUSIC];
    float volume_master = audio_manager->volume_actual[AUDIO_SET_VOLUME_TYPE_MASTER];

    for (int i = 0; i < len; i += 2) {
        int32_t sample = 0;

        if (VideoManager_IsPlayingVideo()) {
            sample = VideoManager_GetAudioSample();
        } else {
            if (manager->background_music != NULL) {
                sample += (int32_t)((double)AudioStream_GetSample(manager->background_music) * volume_bgm);
            }
        }

        if (sample < -32768) {
            sample = -32768;
        } else if (sample > 32767) {
            sample = 32767;
        }

        *(int16_t *)&stream[i] = (int16_t)((float)sample * volume_master);
    }
}

void AudioManager_InitSingleton(void) {
    LOG_INFO("Initializing audio...");

    audio_manager = malloc(sizeof(AudioManager));
    memset(audio_manager, 0, sizeof(AudioManager));

    audio_manager->audio_mute = false;

    SDL_AudioSpec want = {.freq     = 48000,
                          .format   = AUDIO_S16,
                          .channels = 2,
                          .samples  = 512,
                          .callback = AudioManager_FillBuffer,
                          .userdata = audio_manager};

    LOG_DEBUG("Requested audio spec: %d Hz, %d channels, %d samples", want.freq, want.channels, want.samples);

    if ((audio_manager->audio_device_id =
             SDL_OpenAudioDevice(NULL, 0, &want, &audio_manager->audio_spec,
                                 SDL_AUDIO_ALLOW_FREQUENCY_CHANGE | SDL_AUDIO_ALLOW_SAMPLES_CHANGE)) < 2) {
        LOG_WARN("Failed to open audio: %s", SDL_GetError());
        audio_manager->audio_available = false;
        return;
    }

    audio_manager->audio_available = true;

    LOG_DEBUG("Obtained audio spec: %d Hz, %d channels, %d samples", audio_manager->audio_spec.freq,
              audio_manager->audio_spec.channels, audio_manager->audio_spec.samples);

    switch (audio_manager->audio_spec.format) {
    case AUDIO_U8:
        audio_manager->out_sample_format = AV_SAMPLE_FMT_U8;
        break;
    case AUDIO_S16SYS:
        audio_manager->out_sample_format = AV_SAMPLE_FMT_S16;
        break;
    case AUDIO_S32SYS:
        audio_manager->out_sample_format = AV_SAMPLE_FMT_S32;
        break;
    case AUDIO_F32SYS:
        audio_manager->out_sample_format = AV_SAMPLE_FMT_FLT;
        break;
    default:
        LOG_FATAL("Invalid audio spec format: 0x%04X", audio_manager->audio_spec.format);
    }

    AudioManager_SetVolume(AUDIO_SET_VOLUME_TYPE_MASTER, AbyssConfiguration_GetMasterVolume());
    AudioManager_SetVolume(AUDIO_SET_VOLUME_TYPE_MUSIC, AbyssConfiguration_GetMusicVolume());
    AudioManager_SetVolume(AUDIO_SET_VOLUME_TYPE_SFX, AbyssConfiguration_GetSfxVolume());
    AudioManager_SetVolume(AUDIO_SET_VOLUME_TYPE_UI, AbyssConfiguration_GetUiVolume());

    av_channel_layout_default(&audio_manager->channel_layout, audio_manager->audio_spec.channels);
    SDL_PauseAudioDevice(audio_manager->audio_device_id, SDL_FALSE);
}

void AudioManager_DestroySingleton(void) {
    LOG_INFO("Finalizing audio...");

    if (audio_manager->audio_available) {
        SDL_PauseAudioDevice(audio_manager->audio_device_id, SDL_TRUE);
        SDL_CloseAudioDevice(audio_manager->audio_device_id);
    }

    if (audio_manager->background_music != NULL) {
        AudioStream_Destroy(&audio_manager->background_music);
    }

    free(audio_manager);
}

void AudioManager_Update(void) {}

void AudioManager_PlayMusic(const char *path, const bool loop) {
    if (audio_manager->background_music != NULL) {
        AudioStream_Destroy(&audio_manager->background_music);
    }

    audio_manager->background_music = AudioStream_Create(path);
    AudioStream_SetLoop(audio_manager->background_music, loop);
    AudioStream_Play(audio_manager->background_music);
}
void AudioManager_SetVolume(enum AudioSetVolumeType audio_set_volume_type, float volume) {
    audio_manager->volume[audio_set_volume_type]        = volume;
    audio_manager->volume_actual[audio_set_volume_type] = powf(volume, 2.0f);

    if (audio_manager->volume[audio_set_volume_type] > 1.0f) {
        audio_manager->volume[audio_set_volume_type] = 1.0f;
    } else if (audio_manager->volume[audio_set_volume_type] < 0.0f) {
        audio_manager->volume[audio_set_volume_type] = 0.0f;
    }

    if (audio_manager->volume_actual[audio_set_volume_type] > 1.0f) {
        audio_manager->volume_actual[audio_set_volume_type] = 1.0f;
    } else if (audio_manager->volume_actual[audio_set_volume_type] < 0.0f) {
        audio_manager->volume_actual[audio_set_volume_type] = 0.0f;
    }
}

SDL_AudioSpec AudioManager_GetAudioSpec(void) { return audio_manager->audio_spec; }

AVChannelLayout AudioManager_GetChannelLayout(void) { return audio_manager->channel_layout; }

enum AVSampleFormat AudioManager_GetSampleFormat(void) { return audio_manager->out_sample_format; }

```

`src/managers/AudioManager.h`:

```h
#ifndef ABYSS_AUDIOMAN_H
#define ABYSS_AUDIOMAN_H

#include "../audio/AudioStream.h"
#include <SDL2/SDL.h>
#include <stdbool.h>

enum AudioSetVolumeType {
    AUDIO_SET_VOLUME_TYPE_MASTER,
    AUDIO_SET_VOLUME_TYPE_MUSIC,
    AUDIO_SET_VOLUME_TYPE_SFX,
    AUDIO_SET_VOLUME_TYPE_UI,
    AUDIO_SET_VOLUME_TYPE_MAX
};

void                AudioManager_InitSingleton(void);
void                AudioManager_DestroySingleton(void);
void                AudioManager_Update(void);
void                AudioManager_PlayMusic(const char *path, bool loop);
void                AudioManager_SetVolume(enum AudioSetVolumeType audio_set_volume_type, float volume);
void                AudioManager_FillBuffer(void *userdata, Uint8 *stream, int len);
SDL_AudioSpec       AudioManager_GetAudioSpec(void);
AVChannelLayout     AudioManager_GetChannelLayout(void);
enum AVSampleFormat AudioManager_GetSampleFormat(void);

#endif // ABYSS_AUDIOMAN_H

```

`src/managers/CMakeLists.txt`:

```txt
target_sources(${PROJECT_NAME}
        PRIVATE
        AudioManager.c AudioManager.h
        InputManager.c InputManager.h
        VideoManager.c VideoManager.h
)
```

`src/managers/InputManager.c`:

```c
#include "InputManager.h"
#include "../common/AbyssConfiguration.h"
#include "../common/Globals.h"
#include <assert.h>
#include <string.h>

#define MAX_TEXT_INPUT_LENGTH 100

typedef struct InputManager {
    int     mouse_x;
    int     mouse_y;
    bool    key_pressed[SDL_NUM_SCANCODES];
    char    text_input[MAX_TEXT_INPUT_LENGTH + 1];
    uint8_t mouse_buttons;
} InputManager;

InputManager *input_manager;

void InputManager_InitializeSingleton(void) {
    input_manager = malloc(sizeof(InputManager));
    memset(input_manager, 0, sizeof(InputManager));
}

void InputManager_DestroySingleton(void) {
    assert(input_manager != NULL);

    free(input_manager);
}

bool InputManager_ProcessSdlEvent(SDL_Event *sdl_event) {
    switch (sdl_event->type) {
    case SDL_MOUSEMOTION:
        input_manager->mouse_x = sdl_event->motion.x;
        input_manager->mouse_y = sdl_event->motion.y;
        return true;
    case SDL_MOUSEBUTTONDOWN:
        input_manager->mouse_x        = sdl_event->button.x;
        input_manager->mouse_y        = sdl_event->button.y;
        input_manager->mouse_buttons |= sdl_event->button.button;
        return true;
    case SDL_MOUSEBUTTONUP:
        input_manager->mouse_x        = sdl_event->button.x;
        input_manager->mouse_y        = sdl_event->button.y;
        input_manager->mouse_buttons &= ~sdl_event->button.button;
        return true;
    case SDL_KEYDOWN:
        if (sdl_event->key.keysym.sym == SDLK_RETURN &&
            (sdl_event->key.keysym.mod == KMOD_LALT || sdl_event->key.keysym.mod == KMOD_RALT)) {
            const bool is_fullscreen = AbyssConfiguration_GetFullScreen();
            SDL_SetWindowFullscreen(sdl_window, is_fullscreen ? 0 : SDL_WINDOW_FULLSCREEN_DESKTOP);
            AbyssConfiguration_SetFullScreen(!is_fullscreen);
        }
        // if in text input, handle backspace
        if (strlen(input_manager->text_input) > 0 && sdl_event->key.keysym.sym == SDLK_BACKSPACE) {
            input_manager->text_input[strlen(input_manager->text_input) - 1] = '\0';
        }
        input_manager->key_pressed[sdl_event->key.keysym.scancode] = true;

        return true;
    case SDL_KEYUP:
        input_manager->key_pressed[sdl_event->key.keysym.scancode] = false;
        return true;
    case SDL_TEXTINPUT:
        if (strlen(input_manager->text_input) + strlen(sdl_event->text.text) < MAX_TEXT_INPUT_LENGTH) {
            strcat(input_manager->text_input, sdl_event->text.text);
        }
        return true;
    default:
        return false;
    }
}

void InputManager_StartTextInput(void) {
    memset(input_manager->text_input, 0, sizeof(input_manager->text_input));
    SDL_StartTextInput();
}

void InputManager_StopTextInput(void) {
    memset(input_manager->text_input, 0, sizeof(input_manager->text_input));
    SDL_StopTextInput();
}

bool InputManager_IsTextInputActive(void) { return SDL_IsTextInputActive(); }

void InputManager_GetMousePosition(int *mouse_x, int *mouse_y) {
    if (mouse_x != NULL) {
        *mouse_x = input_manager->mouse_x;
    }

    if (mouse_y != NULL) {
        *mouse_y = input_manager->mouse_y;
    }
}

void InputManager_GetMouseButtons(bool *left, bool *middle, bool *right) {
    if (left != NULL) {
        *left = (input_manager->mouse_buttons & SDL_BUTTON_LEFT) > 0;
    }

    if (middle != NULL) {
        *middle = (input_manager->mouse_buttons & SDL_BUTTON_MIDDLE) > 0;
    }

    if (right != NULL) {
        *right = (input_manager->mouse_buttons & SDL_BUTTON_RIGHT) > 0;
    }
}

void InputManager_ResetMouseButtons(void) { input_manager->mouse_buttons = 0; }

```

`src/managers/InputManager.h`:

```h
#ifndef ABYSS_INPUT_MANAGER_H
#define ABYSS_INPUT_MANAGER_H

#include <SDL2/SDL.h>
#include <stdbool.h>
#include <stdint.h>

void InputManager_InitializeSingleton(void);
void InputManager_DestroySingleton(void);
bool InputManager_ProcessSdlEvent(SDL_Event *sdl_event);
void InputManager_StartTextInput(void);
void InputManager_StopTextInput(void);
bool InputManager_IsTextInputActive(void);
void InputManager_GetMousePosition(int *mouse_x, int *mouse_y);
void InputManager_GetMouseButtons(bool *left, bool *middle, bool *right);
void InputManager_ResetMouseButtons(void);

#endif // ABYSS_INPUT_MANAGER_H

```

`src/managers/VideoManager.c`:

```c
#include "VideoManager.h"

#include "../common/FileManager.h"
#include "../common/Globals.h"
#include "../common/Logging.h"
#include "../common/RingBuffer.h"
#include "../util/Mutex.h"
#include "AudioManager.h"
#include "InputManager.h"
#include <assert.h>
#include <libavcodec/avcodec.h>
#include <libavformat/avformat.h>
#include <libavutil/opt.h>
#include <libavutil/time.h>
#include <libswresample/swresample.h>
#include <libswscale/swscale.h>
#include <stdlib.h>
#include <string.h>

#define AUDIO_RING_BUFFER_SIZE          (1024 * 1024)
#define DECODE_BUFFER_SIZE              (1024 * 8)
#define AUDIO_STREAM_DECODE_BUFFER_SIZE (1024 * 8)
#define AUDIO_STREAM_MAX_BUFF_SIZE      (1024 * 10)
#define AUDIO_RING_BUFFER_SIZE          (1024 * 1024)

typedef struct VideoManager {
    MpqStream         *mpq_stream;
    RingBuffer        *ring_buffer;
    AVFormatContext   *av_format_context;
    AVIOContext       *avio_context;
    SwrContext        *resample_context;
    AVCodecContext    *video_codec_context;
    AVCodecContext    *audio_codec_context;
    AVFrame           *av_frame;
    unsigned char     *av_buffer;
    int                video_stream_index;
    int                audio_stream_index;
    uint64_t           micros_per_frame;
    SDL_Rect           src_rect;
    SDL_Rect           dest_rect;
    SDL_Texture       *texture;
    uint8_t           *y_plane;
    uint8_t           *u_plane;
    uint8_t           *v_plane;
    struct SwsContext *sws_context;
    int                uv_pitch;
    uint64_t           video_timestamp;
    uint64_t           total_ticks;
    bool               is_playing;
    bool               frames_ready;
    uint8_t           *audio_out_buffer;
    Mutex             *mutex;
} VideoManager;

VideoManager *video_manager;

int     VideoManager__StreamRead(void *opaque, uint8_t *buf, int buf_size);
int64_t VideoManager__StreamSeek(void *opaque, int64_t offset, int whence);
bool    VideoManager__ProcessFrame(void);

void VideoManager_InitializeSingleton(void) {
    video_manager = malloc(sizeof(VideoManager));
    memset(video_manager, 0, sizeof(VideoManager));
    video_manager->mutex = Mutex_Create();
}

void VideoManager_DestroySingleton(void) {
    VideoManager_StopVideo();
    Mutex_Destroy(&video_manager->mutex);
    free(video_manager);
}

bool VideoManager_IsPlayingVideo(void) {
    Mutex_Lock(video_manager->mutex);
    bool result = video_manager->is_playing;
    Mutex_Unlock(video_manager->mutex);

    return result;
}

void VideoManager_Update(uint64_t delta) {
    Mutex_Lock(video_manager->mutex);

    bool mouse_button_left;
    InputManager_GetMouseButtons(&mouse_button_left, NULL, NULL);
    if (mouse_button_left) {
        Mutex_Unlock(video_manager->mutex);
        VideoManager_StopVideo();
        InputManager_ResetMouseButtons();
        return;
    }

    video_manager->total_ticks += delta;

    while (video_manager->is_playing) {
        const uint64_t diff = av_gettime() - video_manager->video_timestamp;
        if (diff < video_manager->micros_per_frame) {
            break;
        }

        video_manager->video_timestamp += video_manager->micros_per_frame;
        while (VideoManager__ProcessFrame()) {
        }
    }
    Mutex_Unlock(video_manager->mutex);
}

void VideoManager_Render(void) {
    Mutex_Lock(video_manager->mutex);
    if (!video_manager->frames_ready) {
        Mutex_Unlock(video_manager->mutex);
        return;
    }
    SDL_RenderCopy(sdl_renderer, video_manager->texture, &video_manager->src_rect, &video_manager->dest_rect);
    Mutex_Unlock(video_manager->mutex);
}

void VideoManager_PlayVideo(const char *path) {
    assert(video_manager != NULL);
    Mutex_Lock(video_manager->mutex);

    if (video_manager->is_playing) {
        VideoManager_StopVideo();
    }

    if ((video_manager->mpq_stream = FileManager_OpenFile(path)) == NULL) {
        LOG_FATAL("Failed to load video file '%s'!", path);
    }

    video_manager->is_playing       = true;
    video_manager->frames_ready     = false;
    video_manager->ring_buffer      = RingBuffer_Create(AUDIO_RING_BUFFER_SIZE);
    video_manager->audio_out_buffer = malloc(AUDIO_STREAM_DECODE_BUFFER_SIZE);
    video_manager->av_buffer        = av_malloc(DECODE_BUFFER_SIZE);
    video_manager->avio_context     = avio_alloc_context(video_manager->av_buffer, DECODE_BUFFER_SIZE, 0, video_manager,
                                                         VideoManager__StreamRead, NULL, VideoManager__StreamSeek);

    video_manager->av_format_context        = avformat_alloc_context();
    video_manager->av_format_context->pb    = video_manager->avio_context;
    video_manager->av_format_context->flags = AVFMT_FLAG_CUSTOM_IO;

    int av_error;
    if ((av_error = avformat_open_input(&video_manager->av_format_context, "", NULL, NULL)) < 0) {
        LOG_FATAL("Failed to open AV format context: %s", av_err2str(av_error));
    }

    if ((av_error = avformat_find_stream_info(video_manager->av_format_context, NULL)) < 0) {
        LOG_FATAL("Failed to find video stream info: %s", av_err2str(av_error));
    }

    video_manager->video_stream_index = -1;
    for (uint32_t i = 0; i < video_manager->av_format_context->nb_streams; i++) {
        if (video_manager->av_format_context->streams[i]->codecpar->codec_type != AVMEDIA_TYPE_VIDEO) {
            continue;
        }

        video_manager->video_stream_index = (int)i;
        break;
    }

    if (video_manager->video_stream_index == -1) {
        LOG_FATAL("Unable to find video stream index.");
    }

    video_manager->audio_stream_index = -1;
    for (uint32_t i = 0; i < video_manager->av_format_context->nb_streams; i++) {
        if (video_manager->av_format_context->streams[i]->codecpar->codec_type != AVMEDIA_TYPE_AUDIO) {
            continue;
        }

        video_manager->audio_stream_index = (int)i;
        break;
    }

    if (video_manager->audio_stream_index == -1) {
        LOG_FATAL("Unable to find audio stream index.");
    }

    video_manager->micros_per_frame =
        (uint64_t)(1000000.0f / ((float)video_manager->av_format_context->streams[video_manager->video_stream_index]
                                     ->r_frame_rate.num /
                                 (float)video_manager->av_format_context->streams[video_manager->video_stream_index]
                                     ->r_frame_rate.den));

    const AVCodecParameters *video_codec_parameters =
        video_manager->av_format_context->streams[video_manager->video_stream_index]->codecpar;
    const AVCodec *video_decoder = avcodec_find_decoder(video_codec_parameters->codec_id);

    if (video_decoder == NULL) {
        LOG_FATAL("Unable to find video decoder.");
    }

    video_manager->video_codec_context = avcodec_alloc_context3(video_decoder);
    if ((av_error = avcodec_parameters_to_context(video_manager->video_codec_context, video_codec_parameters)) < 0) {
        LOG_FATAL("Failed to apply parameters to video context: %s", av_err2str(av_error));
    }

    if ((av_error = avcodec_open2(video_manager->video_codec_context, video_decoder, NULL)) < 0) {
        LOG_FATAL("Failed to open video context: %s", av_err2str(av_error));
    }

    const AVCodecParameters *audio_codec_parameters =
        video_manager->av_format_context->streams[video_manager->audio_stream_index]->codecpar;
    const AVCodec *audio_decoder = avcodec_find_decoder(audio_codec_parameters->codec_id);

    if (audio_decoder == NULL) {
        LOG_FATAL("Unable to find audio decoder.");
    }

    video_manager->audio_codec_context = avcodec_alloc_context3(audio_decoder);
    if ((av_error = avcodec_parameters_to_context(video_manager->audio_codec_context, audio_codec_parameters)) < 0) {
        LOG_FATAL("Failed to apply parameters to audio context: %s", av_err2str(av_error));
    }

    if ((av_error = avcodec_open2(video_manager->audio_codec_context, audio_decoder, NULL)) < 0) {
        LOG_FATAL("Failed to open audio context: %s", av_err2str(av_error));
    }

    AVChannelLayout channel_layout = AudioManager_GetChannelLayout();

    video_manager->resample_context = swr_alloc();
    av_opt_set_int(video_manager->resample_context, "in_sample_rate", video_manager->audio_codec_context->sample_rate,
                   0);
    av_opt_set_chlayout(video_manager->resample_context, "in_chlayout", &video_manager->audio_codec_context->ch_layout,
                        0);
    av_opt_set_sample_fmt(video_manager->resample_context, "in_sample_fmt",
                          video_manager->audio_codec_context->sample_fmt, 0);
    av_opt_set_int(video_manager->resample_context, "out_sample_rate", AudioManager_GetAudioSpec().freq, 0);
    av_opt_set_chlayout(video_manager->resample_context, "out_chlayout", &channel_layout, 0);
    av_opt_set_sample_fmt(video_manager->resample_context, "out_sample_fmt", AudioManager_GetSampleFormat(), 0);

    if ((av_error = swr_init(video_manager->resample_context)) < 0) {
        LOG_FATAL("Failed to initialize resample context: %s", av_err2str(av_error));
    }

    const float ratio =
        (float)video_manager->video_codec_context->height / (float)video_manager->video_codec_context->width;

    video_manager->src_rect.x = 0;
    video_manager->src_rect.y = 0;
    video_manager->src_rect.w = video_manager->video_codec_context->width;
    video_manager->src_rect.h = video_manager->video_codec_context->height;

    video_manager->dest_rect.x = 0;
    video_manager->dest_rect.y = (600 / 2) - (int)(800 * ratio / 2);
    video_manager->dest_rect.w = 800;
    video_manager->dest_rect.h = (int)(800 * ratio);

    video_manager->texture =
        SDL_CreateTexture(sdl_renderer, SDL_PIXELFORMAT_IYUV, SDL_TEXTUREACCESS_STREAMING,
                          video_manager->video_codec_context->width, video_manager->video_codec_context->height);

    video_manager->sws_context =
        sws_getContext(video_manager->video_codec_context->width, video_manager->video_codec_context->height,
                       video_manager->video_codec_context->pix_fmt, video_manager->video_codec_context->width,
                       video_manager->video_codec_context->height, AV_PIX_FMT_YUV420P, SWS_POINT, NULL, NULL, NULL);

    const size_t y_plane_size =
        (size_t)video_manager->video_codec_context->width * video_manager->video_codec_context->height;
    const size_t uv_plane_size =
        (size_t)video_manager->video_codec_context->width * video_manager->video_codec_context->height / 4;

    video_manager->y_plane  = malloc(y_plane_size);
    video_manager->u_plane  = malloc(uv_plane_size);
    video_manager->v_plane  = malloc(uv_plane_size);
    video_manager->uv_pitch = video_manager->video_codec_context->width / 2;

    video_manager->av_frame        = av_frame_alloc();
    video_manager->video_timestamp = av_gettime();

    Mutex_Unlock(video_manager->mutex);
}

int16_t VideoManager_GetAudioSample(void) {
    Mutex_Lock(video_manager->mutex);
    if (RingBuffer_GetRemainingToRead(video_manager->ring_buffer) < 2) {
        Mutex_Unlock(video_manager->mutex);
        return 0;
    }
    int16_t sample;
    RingBuffer_Read(video_manager->ring_buffer, (char *)&sample, sizeof(int16_t));

    Mutex_Unlock(video_manager->mutex);
    return sample;
}
void VideoManager_StopVideo(void) {
    Mutex_Lock(video_manager->mutex);

    if (!video_manager->is_playing) {
        Mutex_Unlock(video_manager->mutex);
        return;
    }
    video_manager->is_playing = false;

    av_free(video_manager->avio_context->buffer);
    avio_context_free(&video_manager->avio_context);
    avcodec_free_context(&video_manager->video_codec_context);
    sws_freeContext(video_manager->sws_context);
    avcodec_free_context(&video_manager->audio_codec_context);
    swr_free(&video_manager->resample_context);
    av_frame_free(&video_manager->av_frame);
    avformat_close_input(&video_manager->av_format_context);
    avformat_free_context(video_manager->av_format_context);

    SDL_DestroyTexture(video_manager->texture);
    video_manager->texture = NULL;
    MpqStream_Destroy(&video_manager->mpq_stream);

    free(video_manager->y_plane);
    free(video_manager->u_plane);
    free(video_manager->v_plane);
    free(video_manager->audio_out_buffer);

    RingBuffer_Destroy(&video_manager->ring_buffer);

    Mutex_Unlock(video_manager->mutex);
}

int VideoManager__StreamRead(void *opaque, uint8_t *buf, int buf_size) {
    VideoManager *vm = (VideoManager *)opaque;

    return vm->is_playing ? (int)MpqStream_Read(vm->mpq_stream, buf, 0, buf_size) : 0;
}

int64_t VideoManager__StreamSeek(void *opaque, int64_t offset, int whence) {
    VideoManager *vm = (VideoManager *)opaque;

    if (!vm->is_playing) {
        return -1;
    }

    if (whence == AVSEEK_SIZE) {
        int64_t result = (int)MpqStream_GetSize(vm->mpq_stream);
        return result;
    }

    int64_t result = MpqStream_Tell(vm->mpq_stream);
    return result;
}

bool VideoManager__ProcessFrame(void) {
    if (video_manager->av_format_context == NULL || !video_manager->is_playing) {
        return false;
    }

    AVPacket *packet = av_packet_alloc();

    if (av_read_frame(video_manager->av_format_context, packet) < 0) {
        video_manager->is_playing = false;
        av_packet_free(&packet);

        return true;
    }

    if (packet->stream_index == video_manager->video_stream_index) {
        int av_error;

        if ((av_error = avcodec_send_packet(video_manager->video_codec_context, packet)) < 0) {
            LOG_FATAL("Error sending video packet: %s", av_err2str(av_error));
        }

        if ((av_error = avcodec_receive_frame(video_manager->video_codec_context, video_manager->av_frame)) < 0) {
            LOG_FATAL("Error receiving video packet: %s", av_err2str(av_error));
        }

        uint8_t *data[AV_NUM_DATA_POINTERS];
        memset(data, 0, sizeof(uint8_t *) * AV_NUM_DATA_POINTERS);
        data[0] = video_manager->y_plane;
        data[1] = video_manager->u_plane;
        data[2] = video_manager->v_plane;

        int line_size[AV_NUM_DATA_POINTERS];
        memset(line_size, 0, sizeof(int) * AV_NUM_DATA_POINTERS);
        line_size[0] = video_manager->video_codec_context->width;
        line_size[1] = video_manager->uv_pitch;
        line_size[2] = video_manager->uv_pitch;

        video_manager->frames_ready = true;

        sws_scale(video_manager->sws_context, (const uint8_t *const *)video_manager->av_frame->data,
                  video_manager->av_frame->linesize, 0, video_manager->video_codec_context->height, data, line_size);

        if (SDL_UpdateYUVTexture(video_manager->texture, NULL, video_manager->y_plane,
                                 video_manager->video_codec_context->width, video_manager->u_plane,
                                 video_manager->uv_pitch, video_manager->v_plane, video_manager->uv_pitch) < 0) {
            LOG_FATAL("Cannot set YUV data");
        }
        av_packet_free(&packet);

        return true;
    }

    if (packet->stream_index == video_manager->audio_stream_index) {
        int av_error;

        if ((av_error = avcodec_send_packet(video_manager->audio_codec_context, packet))) {
            LOG_FATAL("Error sending audio packet: %s", av_err2str(av_error));
        }

        while (true) {
            if ((av_error = avcodec_receive_frame(video_manager->audio_codec_context, video_manager->av_frame)) < 0) {
                if (av_error == AVERROR(EAGAIN) || av_error == AVERROR_EOF) {
                    break;
                }
                LOG_FATAL("Error receiving audio packet: %s", av_err2str(av_error));
            }

            const size_t sample_size = av_get_bytes_per_sample(AudioManager_GetSampleFormat());
            const int    total_samples =
                AUDIO_STREAM_DECODE_BUFFER_SIZE / (sample_size * AudioManager_GetChannelLayout().nb_channels);

            uint8_t  *ptr[1] = {video_manager->audio_out_buffer};
            const int result =
                swr_convert(video_manager->resample_context, ptr, total_samples,
                            (const uint8_t **)video_manager->av_frame->data, video_manager->av_frame->nb_samples);

            RingBuffer_Write(video_manager->ring_buffer, (char *)video_manager->audio_out_buffer, result * 4);
        }

        av_packet_free(&packet);
        return false;
    }

    av_packet_free(&packet);
    return false;
}

```

`src/managers/VideoManager.h`:

```h
#ifndef ABYSS_VIDEO_MANAGER_H
#define ABYSS_VIDEO_MANAGER_H

#include <stdbool.h>
#include <stdint.h>

void    VideoManager_InitializeSingleton(void);
void    VideoManager_DestroySingleton(void);
void    VideoManager_Update(uint64_t delta);
void    VideoManager_Render(void);
bool    VideoManager_IsPlayingVideo(void);
void    VideoManager_PlayVideo(const char *path);
int16_t VideoManager_GetAudioSample(void);
void    VideoManager_StopVideo(void);

#endif // ABYSS_VIDEO_MANAGER_H

```

`src/scenes/CMakeLists.txt`:

```txt
target_sources(${PROJECT_NAME}
        PRIVATE
        Scene.c Scene.h
        SceneMainMenu.c SceneMainMenu.h
        SceneIntroVideos.c SceneIntroVideos.h
)
```

`src/scenes/Scene.c`:

```c
#include "Scene.h"
#include "../common/Logging.h"
#include "../managers/InputManager.h"
#include <stdlib.h>

void  *current_scene_ptr;
Scene *current_scene;
Scene *next_scene;

void Scene_InitializeManager(void) {
    current_scene     = NULL;
    next_scene        = NULL;
    current_scene_ptr = NULL;
}

void Scene_DestroyManager(void) {
    if (current_scene != NULL) {
        current_scene->free(&current_scene_ptr);
    }

    current_scene_ptr = NULL;
    current_scene     = NULL;
    next_scene        = NULL;
}

void Scene_RenderCurrentScene(void) {
    if (current_scene == NULL) {
        return;
    }

    current_scene->render(current_scene_ptr);
}

void Scene_UpdateCurrentScene(uint64_t delta) {
    if (next_scene != NULL) {
        if (current_scene != NULL) {
            current_scene->free(&current_scene_ptr);
        }

        InputManager_ResetMouseButtons();

        current_scene     = next_scene;
        next_scene        = NULL;
        current_scene_ptr = current_scene->create();
    }

    if (current_scene == NULL) {
        return;
    }

    current_scene->update(current_scene_ptr, delta);
}

void Scene_Set(Scene *scene) {
    if (next_scene != NULL) {
        LOG_FATAL("Attempted to set a new Scene when one was already queued!");
    }

    next_scene = scene;
}

```

`src/scenes/Scene.h`:

```h
#ifndef ABYSS_SCENE_H
#define ABYSS_SCENE_H

#include <stddef.h>
#include <stdint.h>

typedef struct Scene {
    void *(*create)(void);
    void (*render)(void *scene_ref);
    void (*update)(void *scene_ref, uint64_t delta);
    void (*free)(void **scene_ref);
} Scene;

void Scene_InitializeManager(void);
void Scene_DestroyManager(void);
void Scene_RenderCurrentScene(void);
void Scene_UpdateCurrentScene(uint64_t delta);
void Scene_Set(Scene *scene);

#define DESCRIBE_SCENE_CALLBACKS(C) extern Scene C
#define DEFINE_SCENE_CALLBACKS(C)   Scene C = {C##_Create, C##_Render, C##_Update, C##_Free}
#define SCENE_REF(C)                &C

#endif // ABYSS_SCENE_H

```

`src/scenes/SceneIntroVideos.c`:

```c
#include "SceneIntroVideos.h"

#include "../common/ResourcePaths.h"
#include "../drawing/Cursor.h"
#include "../managers/VideoManager.h"
#include "SceneMainMenu.h"
#include <stdlib.h>
#include <string.h>

enum IntroVideoState { INTRO_VIDEO_STATE_STARTUP_1, INTRO_VIDEO_STATE_STARTUP_2, INTRO_VIDEO_STATE_TRANSITION_TO_GAME };

typedef struct SceneIntroVideos {
    int                  bla;
    enum IntroVideoState intro_video_state;
} SceneIntroVideos;

#ifndef ABYSS_VERSION_TEXT
#define ABYSS_VERSION_TEXT "local build"
#endif // ABYSS_VERSION_TEXT

DEFINE_SCENE_CALLBACKS(IntroVideos);

void *IntroVideos_Create(void) {
    SceneIntroVideos *result = malloc(sizeof(SceneIntroVideos));

    Cursor_SetVisible(false);

    result->intro_video_state = INTRO_VIDEO_STATE_STARTUP_1;

    memset(result, 0, sizeof(SceneIntroVideos));
    return result;
}

void IntroVideos_Render(void *scene_ref) {
    SceneIntroVideos *scene = (SceneIntroVideos *)scene_ref;
    //
}

void IntroVideos_Update(void *scene_ref, uint64_t delta) {
    SceneIntroVideos *scene = (SceneIntroVideos *)scene_ref;

    switch (scene->intro_video_state++) {
    case INTRO_VIDEO_STATE_STARTUP_1:
        VideoManager_PlayVideo(VIDEO_BLIZZARD_STARTUP_1);
        return;
    case INTRO_VIDEO_STATE_STARTUP_2:
        VideoManager_PlayVideo(VIDEO_BLIZZARD_STARTUP_2);
        return;
    default:
        Scene_Set(SCENE_REF(MainMenu));
        return;
    }
}

void IntroVideos_Free(void **scene_ref) {
    SceneIntroVideos *scene = (SceneIntroVideos *)*scene_ref;
    free(scene);

    *scene_ref = NULL;
}

```

`src/scenes/SceneIntroVideos.h`:

```h
#ifndef ABYSS_SCENE_INTRO_VIDEOS_H
#define ABYSS_SCENE_INTRO_VIDEOS_H

#include "Scene.h"

DESCRIBE_SCENE_CALLBACKS(IntroVideos);

void *IntroVideos_Create(void);
void  IntroVideos_Render(void *scene_ref);
void  IntroVideos_Update(void *scene_ref, uint64_t delta);
void  IntroVideos_Free(void **scene_ref);

#endif // ABYSS_SCENE_INTRO_VIDEOS_H

```

`src/scenes/SceneMainMenu.c`:

```c
#include "SceneMainMenu.h"
#include "../common/Globals.h"
#include "../common/Logging.h"
#include "../drawing/Cursor.h"
#include "../managers/AudioManager.h"
#include <stdlib.h>
#include <string.h>

typedef struct SceneMainMenu {
    Sprite *background_sprite;
    Sprite *d2logo_black_left_sprite;
    Sprite *d2logo_black_right_sprite;
    Sprite *d2logo_fire_left_sprite;
    Sprite *d2logo_fire_right_sprite;
    Label  *copyright_label;
    Label  *build_label;
} SceneMainMenu;

#ifndef ABYSS_VERSION_TEXT
#define ABYSS_VERSION_TEXT "local build"
#endif // ABYSS_VERSION_TEXT

DEFINE_SCENE_CALLBACKS(MainMenu);

void *MainMenu_Create(void) {
    Cursor_SetVisible(true);

    AudioManager_PlayMusic(MUSIC_TITLE, true);

    SceneMainMenu *result = malloc(sizeof(SceneMainMenu));
    FAIL_IF_NULL(result);
    memset(result, 0, sizeof(SceneMainMenu));

    result->background_sprite         = Sprite_Create(GAME_SELECT_SCREEN, PALETTE_SKY);
    result->d2logo_black_left_sprite  = Sprite_Create(D2LOGO_BLACK_LEFT, PALETTE_UNITS);
    result->d2logo_black_right_sprite = Sprite_Create(D2LOGO_BLACK_RIGHT, PALETTE_UNITS);
    result->d2logo_fire_left_sprite   = Sprite_Create(D2LOGO_FIRE_LEFT, PALETTE_UNITS);
    result->d2logo_fire_right_sprite  = Sprite_Create(D2LOGO_FIRE_RIGHT, PALETTE_UNITS);

    Sprite_SetBlendMode(result->d2logo_black_left_sprite, SDL_BLENDMODE_BLEND);
    Sprite_SetBlendMode(result->d2logo_black_right_sprite, SDL_BLENDMODE_BLEND);
    Sprite_SetBlendMode(result->d2logo_fire_left_sprite, SDL_BLENDMODE_ADD);
    Sprite_SetBlendMode(result->d2logo_fire_right_sprite, SDL_BLENDMODE_ADD);

    result->copyright_label = Label_Create(FONTS_FONTFORMAL10, PALETTE_SKY);
    Label_SetText(
        result->copyright_label,
        "Abyss Engine is neither developed by, nor endorsed by Blizzard/Activision or its parent company Microsoft.");
    Label_SetColor(result->copyright_label, 0xFF, 0xFF, 0x8C, 0xFF);
    Label_SetAlignment(result->copyright_label, LABEL_ALIGN_CENTER, LABEL_ALIGN_CENTER);

    result->build_label = Label_Create(FONTS_FONT8, PALETTE_STATIC);
    Label_SetText(result->build_label, ABYSS_VERSION_TEXT);
    Label_SetColor(result->build_label, 0xFF, 0xFF, 0xFF, 0xFF);
    Label_SetAlignment(result->build_label, LABEL_ALIGN_END, LABEL_ALIGN_BEGIN);
    return result;
}

void MainMenu_Render(void *scene_ref) {
    const SceneMainMenu *mainmenu = (SceneMainMenu *)scene_ref;

    Sprite_DrawMulti(mainmenu->background_sprite, 0, 0, 0, 4, 3);
    Sprite_DrawAnimated(mainmenu->d2logo_black_left_sprite, 400, 120);
    Sprite_DrawAnimated(mainmenu->d2logo_black_right_sprite, 400, 120);
    Sprite_DrawAnimated(mainmenu->d2logo_fire_left_sprite, 400, 120);
    Sprite_DrawAnimated(mainmenu->d2logo_fire_right_sprite, 400, 120);

    Label_Draw(mainmenu->copyright_label, 400, 590);
    Label_Draw(mainmenu->build_label, 797, 1);
}

void MainMenu_Update(void *scene_ref, uint64_t delta) {
    (void)(scene_ref);
    (void)(delta);
}

void MainMenu_Free(void **scene_ref) {
    SceneMainMenu *mainmenu = *((SceneMainMenu **)scene_ref);

    Label_Destroy(&mainmenu->copyright_label);
    Sprite_Destroy(&mainmenu->d2logo_black_left_sprite);
    Sprite_Destroy(&mainmenu->d2logo_black_right_sprite);
    Sprite_Destroy(&mainmenu->d2logo_fire_left_sprite);
    Sprite_Destroy(&mainmenu->d2logo_fire_right_sprite);
    Sprite_Destroy(&mainmenu->background_sprite);

    free(*scene_ref);
    *scene_ref = NULL;
}

```

`src/scenes/SceneMainMenu.h`:

```h
#ifndef ABYSS_SCENE_MAINMENU_H
#define ABYSS_SCENE_MAINMENU_H

#include "../drawing/Label.h"
#include "../drawing/Sprite.h"
#include "Scene.h"

DESCRIBE_SCENE_CALLBACKS(MainMenu);

void *MainMenu_Create(void);
void  MainMenu_Render(void *scene_ref);
void  MainMenu_Update(void *scene_ref, uint64_t delta);
void  MainMenu_Free(void **scene_ref);

#endif // ABYSS_SCENE_MAINMENU_H

```

`src/types/CMakeLists.txt`:

```txt
target_sources(${PROJECT_NAME}
        PRIVATE
        DC6.c DC6.h
        DC6Frame.c DC6.h
        Font.c Font.h
        MPQ.c MPQ.h
        MPQBlock.c MPQBlock.h
        MPQHash.c MPQHash.h
        MPQHeader.c MPQHeader.h
        Palette.c Palette.h
)
```

`src/types/DC6.c`:

```c
#include "DC6.h"
#include "../common/FileManager.h"
#include "../common/Logging.h"
#include "DC6Frame.h"

#include <assert.h>
#include <stdlib.h>
#include <string.h>

typedef struct DC6Header {
    int32_t  version;
    uint32_t flags;
    uint32_t encoding;
    uint8_t  termination[4];
    uint32_t directions;
    uint32_t frames_per_direction;
} DC6Header;

struct DC6 {
    struct DC6Header header;
    uint32_t        *frame_pointers;
    DC6Frame       **dc6_frames;
};

DC6 *DC6_Load(const char *path) {
    DC6 *result = malloc(sizeof(DC6));
    FAIL_IF_NULL(result);

    MpqStream *stream = FileManager_OpenFile(path);
    MpqStream_Read(stream, &result->header, 0, sizeof(DC6Header));

    const uint32_t total_frames = result->header.directions * result->header.frames_per_direction;
    result->frame_pointers      = malloc(sizeof(uint32_t) * total_frames);

    FAIL_IF_NULL(result->frame_pointers);

    MpqStream_Read(stream, result->frame_pointers, 0, sizeof(uint32_t) * total_frames);

    result->dc6_frames = malloc(sizeof(DC6Frame *) * total_frames);
    FAIL_IF_NULL(result->dc6_frames);

    for (uint32_t i = 0; i < total_frames; i++) {
        result->dc6_frames[i] = DC6Frame_Create(stream);
    }

    MpqStream_Destroy(&stream);

    return result;
}

void DC6_Destroy(struct DC6 **dc6) {
    assert(dc6 != NULL);

    const uint32_t total_frames = DC6_GetTotalFrameCount(*dc6);
    for (uint32_t i = 0; i < total_frames; i++) {
        DC6Frame_Destroy(&(*dc6)->dc6_frames[i]);
    }

    free((*dc6)->dc6_frames);
    free((*dc6)->frame_pointers);

    free(*dc6);
    *dc6 = NULL;
}

uint32_t DC6_GetTotalFrameCount(const DC6 *dc6) { return dc6->header.directions * dc6->header.frames_per_direction; }

void DC6_GetFrameSize(const DC6 *dc6, uint32_t frame_index, uint32_t *width, uint32_t *height) {
    assert(dc6 != NULL);
    assert(frame_index < (dc6->header.directions * dc6->header.frames_per_direction));

    DC6Frame_GetFrameSize(dc6->dc6_frames[frame_index], width, height);
}

const uint8_t *DC6_GetFramePixelData(const DC6 *dc6, uint32_t frame_index) {
    assert(dc6 != NULL);
    assert(frame_index < (dc6->header.directions * dc6->header.frames_per_direction));

    return DC6Frame_GetPixelData(dc6->dc6_frames[frame_index]);
}

void DC6_GetFrameOffset(const DC6 *dc6, uint32_t frame_index, int32_t *offset_x, int32_t *offset_y) {
    assert(dc6 != NULL);
    assert(frame_index < (dc6->header.directions * dc6->header.frames_per_direction));

    DC6Frame_GetFrameOffset(dc6->dc6_frames[frame_index], offset_x, offset_y);
}

```

`src/types/DC6.h`:

```h
#ifndef ABYSS_DC6_H
#define ABYSS_DC6_H

#include <stdint.h>

typedef struct DC6 DC6;

DC6           *DC6_Load(const char *path);
void           DC6_Destroy(DC6 **dc6);
uint32_t       DC6_GetTotalFrameCount(const DC6 *dc6);
void           DC6_GetFrameSize(const DC6 *dc6, uint32_t frame_index, uint32_t *width, uint32_t *height);
void           DC6_GetFrameOffset(const DC6 *dc6, uint32_t frame_index, int32_t *offset_x, int32_t *offset_y);
const uint8_t *DC6_GetFramePixelData(const DC6 *dc6, uint32_t frame_index);

#endif // ABYSS_DC6_H

```

`src/types/DC6Frame.c`:

```c
#include "DC6Frame.h"
#include "../common/Logging.h"
#include <assert.h>
#include <stdlib.h>
#include <string.h>

typedef struct DC6FrameHeader {
    uint32_t flipped;
    uint32_t width;
    uint32_t height;
    int32_t  offset_x;
    int32_t  offset_y;
    uint32_t unknown;
    uint32_t next_block;
    uint32_t data_length;
} DC6FrameHeader;

struct DC6Frame {
    DC6FrameHeader header;
    uint8_t       *frame_data;
    char           terminator[3];
    uint8_t       *indexed_pixel_data;
};

void DC6Frame__Decode(DC6Frame *dc6_frame);

DC6Frame *DC6Frame_Create(MpqStream *mpq_stream) {
    DC6Frame *result = malloc(sizeof(DC6Frame));
    memset(result, 0, sizeof(DC6Frame));
    FAIL_IF_NULL(result);

    MpqStream_Read(mpq_stream, &result->header, 0, sizeof(DC6FrameHeader));
    result->frame_data = malloc(result->header.data_length);

    FAIL_IF_NULL(result->frame_data);

    MpqStream_Read(mpq_stream, result->frame_data, 0, result->header.data_length);
    MpqStream_Read(mpq_stream, result->terminator, 0, 3);

    DC6Frame__Decode(result);

    return result;
}

void DC6Frame_Destroy(DC6Frame **dc6_frame) {
    free((*dc6_frame)->indexed_pixel_data);
    free((*dc6_frame)->frame_data);
    free(*dc6_frame);
    *dc6_frame = NULL;
}

void DC6Frame_GetFrameSize(const DC6Frame *dc6_frame, uint32_t *width, uint32_t *height) {
    assert((width != NULL) || (height != NULL));

    if (width != NULL) {
        *width = dc6_frame->header.width;
    }

    if (height != NULL) {
        *height = dc6_frame->header.height;
    }
}

const uint8_t *DC6Frame_GetPixelData(const DC6Frame *dc6_frame) { return dc6_frame->indexed_pixel_data; }

void DC6Frame_GetFrameOffset(const DC6Frame *dc6_frame, int32_t *offset_x, int32_t *offset_y) {
    if (offset_x != NULL) {
        *offset_x = dc6_frame->header.offset_x;
    }

    if (offset_y != NULL) {
        *offset_y = dc6_frame->header.offset_y;
    }
}

void DC6Frame__Decode(DC6Frame *dc6_frame) {
    assert(dc6_frame != NULL);
    assert(dc6_frame->frame_data != NULL);

    uint32_t frame_width;
    uint32_t frame_height;
    DC6Frame_GetFrameSize(dc6_frame, &frame_width, &frame_height);
    const uint32_t total_pixels = frame_height * frame_width;

    dc6_frame->indexed_pixel_data = malloc((size_t)total_pixels);
    FAIL_IF_NULL(dc6_frame->indexed_pixel_data);
    memset(dc6_frame->indexed_pixel_data, 0, (size_t)total_pixels);

    uint32_t x      = 0;
    uint32_t y      = frame_height - 1;
    int      offset = 0;

    for (;;) {
        const int b = dc6_frame->frame_data[offset++];

        if (b == 0x80) {
            if (y == 0) {
                return;
            }
            --y;
            x = 0;
            continue;
        }

        if ((b & 0x80) > 0) {
            x += b & 0x7F;
            continue;
        }

        for (int i = 0; i < b; i++) {
            dc6_frame->indexed_pixel_data[x + (y * frame_width) + i] = dc6_frame->frame_data[offset++];
        }

        x += b;
    }
}

```

`src/types/DC6Frame.h`:

```h
#ifndef ABYSS_DC6FRAME_H
#define ABYSS_DC6FRAME_H

#include "../common/MpqStream.h"
#include <stdint.h>

typedef struct DC6Frame DC6Frame;

DC6Frame      *DC6Frame_Create(MpqStream *mpq_stream);
void           DC6Frame_Destroy(DC6Frame **dc6_frame);
void           DC6Frame_GetFrameSize(const DC6Frame *dc6_frame, uint32_t *width, uint32_t *height);
void           DC6Frame_GetFrameOffset(const DC6Frame *dc6_frame, int32_t *offset_x, int32_t *offset_y);
const uint8_t *DC6Frame_GetPixelData(const DC6Frame *dc6_frame);

#endif // ABYSS_DC6FRAME_H

```

`src/types/Font.c`:

```c
#include "Font.h"

#include "../common/AbyssConfiguration.h"
#include "../common/FileManager.h"
#include "../common/Logging.h"
#include <stdlib.h>
#include <string.h>

typedef struct FontGlyph {
    uint16_t code;
    uint16_t frame_index;
    uint8_t  width;
    uint8_t  height;
} FontGlyph;

struct Font {
    FontGlyph *glyphs;
    uint32_t   glyph_count;
};

const struct FontGlyph *Font__GetGlyph(const struct Font *font, uint16_t code);

struct Font *Font_Load(const char *path) {
    char path_fixed[4096];
    memset(path_fixed, 0, 4096);

    snprintf(path_fixed, 4096, path, AbyssConfiguration_GetLocale());
    strcat(path_fixed, ".tbl");
    struct MpqStream *stream = FileManager_OpenFile(path_fixed);

    struct Font *result = malloc(sizeof(struct Font));
    FAIL_IF_NULL(result);
    memset(result, 0, sizeof(struct Font));
    result->glyphs = calloc(0, sizeof(struct FontGlyph));

    char       magic[5];
    const char test[5] = "Woo!\x01";
    MpqStream_Read(stream, magic, 0, 5);
    if (memcmp(magic, test, 5) != 0) {
        LOG_FATAL("Failed to load Font '%s' due to invalid header.", path);
    }

    MpqStream_Seek(stream, 7, SEEK_CUR); // skip 7 unknown bytes

    while (!MpqStream_GetIsEof(stream)) {
        result->glyphs = realloc(result->glyphs, sizeof(struct FontGlyph) * (++result->glyph_count));
        FAIL_IF_NULL(result->glyphs);
        struct FontGlyph *glyph = &result->glyphs[result->glyph_count - 1];

        MpqStream_Read(stream, &glyph->code, 0, 2);
        MpqStream_Seek(stream, 1, SEEK_CUR); // skip 1 unknown byte
        MpqStream_Read(stream, &glyph->width, 0, 1);
        MpqStream_Read(stream, &glyph->height, 0, 1);
        MpqStream_Seek(stream, 3, SEEK_CUR); // skip 3 unknown bytes
        MpqStream_Read(stream, &glyph->frame_index, 0, 2);

        if (glyph->frame_index == 0xFFFF) {
            // TODO: What is this about? -1?
            glyph->frame_index = 1;
            LOG_WARN("Font '%s' has a glyph with frame index 0xFFFF for glyph %d.", path, result->glyph_count - 1);
        }

        MpqStream_Seek(stream, 4, SEEK_CUR); // skip 4 unknown bytes
    }

    MpqStream_Destroy(&stream);

    return result;
}

void Font_Destroy(struct Font *font) {
    free(font->glyphs);
    free(font);
}

void Font_GetGlyphMetrics(const Font *font, uint16_t code, uint16_t *frame_index, uint8_t *width, uint8_t *height) {
    const struct FontGlyph *glyph = Font__GetGlyph(font, code);
    if (glyph == NULL) {
        glyph = Font__GetGlyph(font, '?');
        if (glyph == NULL) {
            LOG_FATAL("Failed to get glyph metrics for code %d.", code);
        }
    }

    if (frame_index != NULL) {
        *frame_index = glyph->frame_index;
    }

    if (width != NULL) {
        *width = glyph->width;
    }

    if (height != NULL) {
        *height = glyph->height;
    }
}

const struct FontGlyph *Font__GetGlyph(const struct Font *font, uint16_t code) {
    for (uint32_t i = 0; i < font->glyph_count; i++) {
        if (font->glyphs[i].code == code) {
            return &font->glyphs[i];
        }
    }
    return NULL;
}

```

`src/types/Font.h`:

```h
#ifndef ABYSS_FONT_H
#define ABYSS_FONT_H

#include <stdint.h>

typedef struct Font Font;

Font *Font_Load(const char *path);
void  Font_Destroy(Font *font);
void  Font_GetGlyphMetrics(const Font *font, uint16_t code, uint16_t *frame_index, uint8_t *width, uint8_t *height);

#endif // ABYSS_FONT_H

```

`src/types/MPQ.c`:

```c
#include "MPQ.h"
#include "../common/Logging.h"
#include "../util/Crypto.h"
#include "../util/Mutex.h"
#include <assert.h>
#include <stdlib.h>
#include <string.h>

struct MPQ {
    char                *path;
    FILE                *file;
    struct MPQHeader     header;
    struct MPQHashEntry *hashes;
    struct MPQBlock     *blocks;
    int                  hashes_count;
    struct Mutex        *mutex;
};

struct MPQBlock *MPQ__LoadBlocks(FILE *file, const MPQ *mpq);

struct MPQ *MPQ_Load(const char *mpq_path) {
    LOG_DEBUG("Loading '%s'...", mpq_path);

    struct MPQ *result = malloc(sizeof(struct MPQ));
    FAIL_IF_NULL(result);
    memset(result, 0, sizeof(struct MPQ));

    result->path = strdup(mpq_path);

    result->file = fopen(mpq_path, "rb");
    if (result->file == NULL) {
        LOG_FATAL("Failed to load MPQ '%s'!", mpq_path);
    }

    MPQHeader_Read(result->file, mpq_path, &result->header);
    result->hashes = MPQ_LoadHashTable(result->file, &result->header);
    result->blocks = MPQ__LoadBlocks(result->file, result);

    result->mutex = Mutex_Create();

    return result;
}

void MPQ_Destroy(MPQ *mpq) {
    LOG_DEBUG("Unloading '%s'...", mpq->path);

    Mutex_Lock(mpq->mutex); // Ensure we have don't have dangling access open somewhere else...

    fclose(mpq->file);
    free(mpq->path);
    free(mpq->blocks);
    free(mpq->hashes);
    Mutex_Destroy(&mpq->mutex);

    free(mpq);
}

bool MPQ_FileExists(const MPQ *mpq, const char *file_path) { return MPQ_GetFileHash(mpq, file_path) != NULL; }

struct MPQHash *MPQ_GetFileHash(const MPQ *mpq, const char *file_path) {
    const uint64_t file_hash = crypto_hash_file_name(file_path);

    for (uint32_t i = 0; i < mpq->header.hash_table_entries; i++) {
        if (mpq->hashes[i].key != file_hash) {
            continue;
        }

        return &mpq->hashes[i].hash;
    }
    return NULL;
}

struct MPQBlock *MPQ_GetBlock(const MPQ *mpq, uint32_t block_index) {
    assert(mpq != NULL);

    if (block_index >= mpq->header.hash_table_entries) {
        LOG_FATAL("Invalid block index!");
    }

    return &mpq->blocks[block_index];
}

uint64_t MPQ_GetBlockSize(const MPQ *mpq) {
    assert(mpq != NULL);

    return 0x200 << mpq->header.block_size;
}

FILE *MPQ_AcquireFileHandle(MPQ *mpq) {
    Mutex_Lock(mpq->mutex);
    return mpq->file;
}

void MPQ_ReleaseFileHandle(MPQ *mpq) { Mutex_Unlock(mpq->mutex); }

struct MPQBlock *MPQ__LoadBlocks(FILE *file, const MPQ *mpq) {
    struct MPQBlock *result = calloc(sizeof(struct MPQBlock), mpq->header.block_table_entries);
    fseek(file, mpq->header.block_table_offset, SEEK_SET);

    uint32_t *block_data = crypto_decrypt_table(file, mpq->header.block_table_entries, "(block table)");

    uint32_t n;
    uint32_t i;

    for (n = 0, i = 0; i < mpq->header.block_table_entries; n += 4, i++) {
        struct MPQBlock *entry   = &result[i];
        entry->file_position     = block_data[n];
        entry->size_compressed   = block_data[n + 1];
        entry->size_uncompressed = block_data[n + 2];
        entry->flags             = block_data[n + 3];
    }

    free(block_data);

    return result;
}

```

`src/types/MPQ.h`:

```h
#ifndef ABYSS_MPQ_H
#define ABYSS_MPQ_H

#include "MPQBlock.h"
#include "MPQHash.h"
#include "MPQHeader.h"
#include <stdbool.h>
#include <stdio.h>

typedef struct MPQ MPQ;

MPQ             *MPQ_Load(const char *mpq_path);
void             MPQ_Destroy(MPQ *mpq);
bool             MPQ_FileExists(const MPQ *mpq, const char *file_path);
struct MPQHash  *MPQ_GetFileHash(const MPQ *mpq, const char *file_path);
struct MPQBlock *MPQ_GetBlock(const MPQ *mpq, uint32_t block_index);
uint64_t         MPQ_GetBlockSize(const MPQ *mpq);
FILE            *MPQ_AcquireFileHandle(MPQ *mpq);
void             MPQ_ReleaseFileHandle(MPQ *mpq);

#endif // ABYSS_MPQ_H

```

`src/types/MPQBlock.c`:

```c
#include "MPQBlock.h"
#include "../common/Logging.h"
#include "../util/Crypto.h"
#include <stdlib.h>
#include <string.h>

void MPQBlock_CalculateEncryptionSeed(struct MPQBlock *block, const char *file_name) {
    const char *name       = strrchr(file_name, '\\') + 1;
    uint32_t    seed       = crypto_hash_string(name, 3);
    block->encryption_seed = (seed + block->file_position) ^ block->size_uncompressed;
}

```

`src/types/MPQBlock.h`:

```h
#ifndef ABYSS_MPQ_BLOCK_H
#define ABYSS_MPQ_BLOCK_H

#include <stdint.h>

typedef uint32_t file_flag;

#define FILE_FLAG_IMPLODE       ((file_flag)0x00000100)
#define FILE_FLAG_COMPRESS      ((file_flag)0x00000200)
#define FILE_FLAG_ENCRYPTED     ((file_flag)0x00010000)
#define FILE_FLAG_FIX_KEY       ((file_flag)0x00020000)
#define FILE_FLAG_PATCH_FILE    ((file_flag)0x00100000)
#define FILE_FLAG_SINGLE_UNIT   ((file_flag)0x01000000)
#define FILE_FLAG_DELETE_MARKER ((file_flag)0x02000000)
#define FILE_FLAG_SECTOR_CRC    ((file_flag)0x04000000)
#define FILE_FLAG_EXISTS        ((file_flag)0x80000000)

typedef struct MPQBlock {
    uint32_t  file_position;
    uint32_t  size_compressed;
    uint32_t  size_uncompressed;
    file_flag flags;
    uint32_t  encryption_seed;
} MPQBlock;

void MPQBlock_CalculateEncryptionSeed(struct MPQBlock *block, const char *file_name);

#endif // ABYSS_MPQ_BLOCK_H

```

`src/types/MPQHash.c`:

```c
#include "MPQHash.h"
#include "../util/Crypto.h"
#include <stdlib.h>

MPQHashEntry *MPQ_LoadHashTable(FILE *file, const MPQHeader *mpq_header) {
    MPQHashEntry *result = calloc(sizeof(MPQHashEntry), mpq_header->hash_table_entries);
    fseek(file, mpq_header->hash_table_offset, SEEK_SET);

    uint32_t *hash_data = crypto_decrypt_table(file, mpq_header->hash_table_entries, "(hash table)");

    uint32_t n;
    uint32_t i;
    for (n = 0, i = 0; i < mpq_header->hash_table_entries; n += 4, i++) {
        MPQHash *entry = &result[i].hash;

        entry->a           = hash_data[n];
        entry->b           = hash_data[n + 1];
        entry->locale      = (uint16_t)(hash_data[n + 2] >> 16);
        entry->platform    = (uint16_t)(hash_data[n + 2] & 0xFFFF);
        entry->block_index = hash_data[n + 3];

        result[i].key = (uint64_t)entry->a << 32 | (uint64_t)entry->b;
    }

    free(hash_data);

    return result;
}

```

`src/types/MPQHash.h`:

```h
#ifndef ABYSS_MPQ_HASH_H
#define ABYSS_MPQ_HASH_H

#include "MPQHeader.h"
#include <stdint.h>

typedef struct MPQHash {
    uint32_t a;
    uint32_t b;
    uint16_t locale;
    uint16_t platform;
    uint32_t block_index;
} MPQHash;

typedef struct MPQHashEntry {
    uint64_t key;
    MPQHash  hash;
} MPQHashEntry;

MPQHashEntry *MPQ_LoadHashTable(FILE *file, const MPQHeader *mpq_header);

#endif // ABYSS_MPQ_HASH_H

```

`src/types/MPQHeader.c`:

```c
#include "MPQHeader.h"
#include "../common/Logging.h"
#include <stdlib.h>

static const char mpq_magic[4] = {'M', 'P', 'Q', 0x1A};

void MPQHeader_Read(FILE *file, const char *mpq_path, MPQHeader *header) {
    fseek(file, 0, SEEK_SET);
    fread(header, sizeof(MPQHeader), 1, file);

    for (int i = 0; i < 4; i++) {
        if (header->magic[i] != mpq_magic[i]) {
            LOG_FATAL("Failed to load '%s' due to invalid header.", mpq_path);
        }
    }
}

```

`src/types/MPQHeader.h`:

```h
#ifndef ABYSS_MPQ_HEADER_H
#define ABYSS_MPQ_HEADER_H

#include <stdint.h>
#include <stdio.h>

typedef struct MPQHeader {
    uint8_t  magic[4];
    uint32_t header_size;
    uint32_t archive_size;
    uint16_t format_version;
    uint16_t block_size;
    uint32_t hash_table_offset;
    uint32_t block_table_offset;
    uint32_t hash_table_entries;
    uint32_t block_table_entries;
} MPQHeader;

void MPQHeader_Read(FILE *file, const char *mpq_path, MPQHeader *header);

#endif // ABYSS_MPQ_HEADER_H

```

`src/types/Palette.c`:

```c
#include "Palette.h"
#include "../common/FileManager.h"
#include "../common/Globals.h"
#include "../common/Logging.h"
#include <stdlib.h>
#include <string.h>

struct Palette **palettes;
int              palette_count;

void Palette_Initialize(void) {
    palettes      = calloc(0, sizeof(struct Palette *));
    palette_count = 0;
}

void Palette_Finalize(void) {
    for (int i = 0; i < palette_count; i++) {
        free(palettes[i]->name);
        free(palettes[i]);
    }
    free(palettes);
}

const Palette *Palette_Get(const char *palette_name) {
    for (int i = 0; i < palette_count; i++) {
        if (strcmp(palette_name, palettes[i]->name) != 0) {
            continue;
        }

        return palettes[i];
    }

    Palette *result = malloc(sizeof(Palette));
    FAIL_IF_NULL(result);

    result->name = strdup(palette_name);
    FAIL_IF_NULL(result->name);

    char path_buff[4096];
    memset(path_buff, 0, 4096);
    snprintf(path_buff, 4096, PALETTE_PATH, palette_name);

    MpqStream *stream = FileManager_OpenFile(path_buff);

    if (MpqStream_GetSize(stream) != 256 * 3) {
        LOG_ERROR("Invalid Palette file size. Expected %d but %d was returned.", 256 * 3, MpqStream_GetSize(stream));
    }

    for (int i = 0; i < 256; i++) {
        uint8_t record[3];
        MpqStream_Read(stream, record, 0, 3);
        result->entries[i] = (uint32_t)record[2] << 24 | (uint32_t)record[1] << 16 | (uint32_t)record[0] << 8 | 0xFF;
    }

    MpqStream_Destroy(&stream);

    result->entries[0]          &= 0xFFFFFF00;
    palettes                     = realloc(palettes, sizeof(Palette *) * ++palette_count);
    palettes[palette_count - 1]  = result;

    return result;
}

```

`src/types/Palette.h`:

```h
#ifndef ABYSS_PALETTE_H
#define ABYSS_PALETTE_H

#include <stdint.h>

typedef struct Palette {
    uint32_t entries[256];
    char    *name;
} Palette;

void           Palette_Initialize(void);
void           Palette_Finalize(void);
const Palette *Palette_Get(const char *palette_name);

#endif // ABYSS_PALETTE_H

```

`src/util/BitReader.c`:

```c
#include "BitReader.h"
#include "../common/Logging.h"
#include <stdlib.h>
#include <string.h>

#define TWOS_COMPLIMENT_NEGATIVE_ONE 4294967295

struct BitReader {
    uint8_t *data_buffer;
    size_t   buffer_len;
    int      offset;
    int      bits_read;
};

struct BitReader *BitReader_Create(uint8_t *data_buffer, size_t buffer_len) {
    struct BitReader *bit_reader = malloc(sizeof(struct BitReader));
    memset(bit_reader, 0, sizeof(struct BitReader));
    FAIL_IF_NULL(bit_reader);

    bit_reader->data_buffer = data_buffer;
    bit_reader->buffer_len  = buffer_len;
    return bit_reader;
}

void BitReader_Destroy(BitReader *br) { free(br); }

uint32_t BitReader_ReadBit(BitReader *br) {
    uint32_t result = (uint32_t)(br->data_buffer[br->offset >> 3] >> (uint32_t)(br->offset & 7)) & 1;
    br->offset++;
    br->bits_read++;

    return result;
}

uint32_t BitReader_ReadBits(BitReader *br, int number_of_bits) {
    if (number_of_bits == 0) {
        return 0;
    }

    uint32_t result = 0;

    for (int i = 0; i < number_of_bits; i++) {
        result |= BitReader_ReadBit(br) << i;
    }

    return result;
}

```

`src/util/BitReader.h`:

```h
#ifndef ABYSS_BIT_READER_H
#define ABYSS_BIT_READER_H

#include <stddef.h>
#include <stdint.h>

typedef struct BitReader BitReader;

BitReader *BitReader_Create(uint8_t *data_buffer, size_t buffer_len);
void       BitReader_Destroy(BitReader *br);
uint32_t   BitReader_ReadBit(BitReader *br);
uint32_t   BitReader_ReadBits(BitReader *br, int number_of_bits);

#endif // ABYSS_BIT_READER_H

```

`src/util/CMakeLists.txt`:

```txt
target_sources(${PROJECT_NAME}
        PRIVATE
        BitReader.c BitReader.h
        Crypto.c Crypto.h
        Huffman.c Huffman.h
        Implode.c Implode.h
        Mutex.c Mutex.h
        WavDecompress.c WavDecompress.h
)
```

`src/util/Crypto.c`:

```c
#include "Crypto.h"
#include "../common/Logging.h"
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

uint32_t crypto_buffer[0x500];

void crypto_init(void) {
    LOG_DEBUG("Initializing cryptographic table.");
    uint32_t seed = 0x00100001;

    for (int index1 = 0; index1 < 0x100; index1++) {
        int index2 = index1;
        for (int i = 0; i < 5; i++) {
            seed                   = (seed * 125 + 3) % 0x2AAAAB;
            const uint32_t temp1   = (seed & 0xFFFF) << 0x10;
            seed                   = (seed * 125 + 3) % 0x2AAAAB;
            const uint32_t temp2   = (seed & 0xFFFF);
            crypto_buffer[index2]  = temp1 | temp2;
            index2                += 0x100;
        }
    }
}

uint32_t crypto_hash_string(const char *key, const uint32_t hash_type) {
    uint32_t seed1 = 0x7FED7FED;
    uint32_t seed2 = 0xEEEEEEEE;

    const size_t len = strlen(key);
    for (size_t i = 0; i < len; i++) {
        const char ch = (const char)toupper(key[i]);
        seed1         = crypto_buffer[(hash_type * 0x100) + (uint32_t)ch] ^ (seed1 + seed2);
        seed2         = (uint32_t)ch + seed1 + seed2 + (seed2 << 5) + 3;
    }

    return seed1;
}

uint32_t *crypto_decrypt_table(FILE *file, uint32_t size, const char *name) {
    size *= 4;

    uint32_t  seed  = crypto_hash_string(name, 3);
    uint32_t  seed2 = 0xEEEEEEEE;
    uint32_t *table = malloc(sizeof(uint32_t) * size);

    FAIL_IF_NULL(table);
    uint8_t buff[4];

    for (uint32_t i = 0; i < size; i++) {
        seed2 += crypto_buffer[0x400 + (seed & 0xFF)];

        if (fread(&buff, sizeof(uint8_t), 4, file) != 4) {
            LOG_FATAL("Error decrypting table!");
        }
        uint32_t result  = buff[0] | (buff[1] << 8) | (buff[2] << 16) | (buff[3] << 24);
        result          ^= seed + seed2;

        seed     = ((~seed << 21) + 0x11111111) | (seed >> 11);
        seed2    = result + seed2 + (seed2 << 5) + 3;
        table[i] = result;
    }

    return table;
}

uint64_t crypto_hash_file_name(const char *file_name) {
    const uint32_t a = crypto_hash_string(file_name, 1);
    const uint32_t b = crypto_hash_string(file_name, 2);
    return (((uint64_t)a) << 32) | (uint64_t)b;
}

void crypto_decrypt(uint32_t *buffer, uint32_t size, uint32_t seed) {
    uint32_t seed2 = 0xEEEEEEEE;

    for (uint32_t i = 0; i < size; i++) {
        seed2           += crypto_buffer[0x400 + (seed & 0xFF)];
        uint32_t result  = buffer[i] ^ (seed + seed2);
        seed             = ((~seed << 21) + 0x11111111) | (seed >> 11);
        seed2            = result + seed2 + (seed2 << 5) + 3;
        buffer[i]        = result;
    }
}

void crypto_decrypt_bytes(char *buffer, uint32_t size, uint32_t seed) {
    uint32_t seed2 = 0xEEEEEEEE;

    for (uint32_t i = 0; i < size - 3; i += 4) {
        seed2                     += crypto_buffer[0x400 + (seed & 0xFF)];
        uint32_t result            = *((uint32_t *)(buffer + i)) ^ (seed + seed2);
        seed                       = ((~seed << 21) + 0x11111111) | (seed >> 11);
        seed2                      = result + seed2 + (seed2 << 5) + 3;
        *(uint32_t *)(buffer + i)  = result;
    }
}

```

`src/util/Crypto.h`:

```h
#ifndef ABYSS_CRYPTO_H
#define ABYSS_CRYPTO_H

#include <stdint.h>
#include <stdio.h>

extern uint32_t crypto_buffer[0x500];

void      crypto_init(void);
uint32_t  crypto_hash_string(const char *key, uint32_t hash_type);
uint32_t *crypto_decrypt_table(FILE *file, uint32_t size, const char *name);
uint64_t  crypto_hash_file_name(const char *file_name);
void      crypto_decrypt(uint32_t *buffer, uint32_t size, uint32_t seed);
void      crypto_decrypt_bytes(char *buffer, uint32_t size, uint32_t seed);
#endif // ABYSS_CRYPTO_H

```

`src/util/Huffman.c`:

```c
#include "Huffman.h"
#include "../common/Logging.h"
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

#define DECOMP_VAL_1 256
#define DECOMP_VAL_2 257

static uint8_t primes_0[256] = { // Compression type 0
    0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02};
static uint8_t primes_1[256] = { // Compression type 1
    0x54, 0x16, 0x16, 0x0D, 0x0C, 0x08, 0x06, 0x05, 0x06, 0x05, 0x06, 0x03, 0x04, 0x04, 0x03, 0x05, 0x0E, 0x0B, 0x14,
    0x13, 0x13, 0x09, 0x0B, 0x06, 0x05, 0x04, 0x03, 0x02, 0x03, 0x02, 0x02, 0x02, 0x0D, 0x07, 0x09, 0x06, 0x06, 0x04,
    0x03, 0x02, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x02, 0x02, 0x09, 0x06, 0x04, 0x04, 0x04, 0x04, 0x03, 0x02, 0x03,
    0x02, 0x02, 0x02, 0x02, 0x03, 0x02, 0x04, 0x08, 0x03, 0x04, 0x07, 0x09, 0x05, 0x03, 0x03, 0x03, 0x03, 0x02, 0x02,
    0x02, 0x03, 0x02, 0x02, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02,
    0x02, 0x06, 0x0A, 0x08, 0x08, 0x06, 0x07, 0x04, 0x03, 0x04, 0x04, 0x02, 0x02, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03,
    0x07, 0x07, 0x09, 0x06, 0x04, 0x03, 0x03, 0x02, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0A, 0x02, 0x02, 0x03, 0x02,
    0x02, 0x01, 0x01, 0x02, 0x02, 0x02, 0x06, 0x03, 0x05, 0x02, 0x03, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x04, 0x04, 0x04,
    0x07, 0x09, 0x08, 0x0C, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01,
    0x01, 0x03, 0x04, 0x01, 0x02, 0x04, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x04,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x02, 0x02, 0x01, 0x01, 0x02, 0x02, 0x02, 0x06, 0x4B};
static uint8_t primes_2[127] = { // Compression type 2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x27, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x02, 0x02, 0x01, 0x01, 0x06, 0x0E, 0x10, 0x04, 0x06, 0x08, 0x05, 0x04, 0x04, 0x03, 0x03, 0x02, 0x02,
    0x03, 0x03, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x04, 0x02, 0x04, 0x02, 0x02, 0x02, 0x01, 0x01, 0x04, 0x01, 0x01,
    0x02, 0x03, 0x03, 0x02, 0x03, 0x01, 0x03, 0x06, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x01,
    0x01, 0x01, 0x29, 0x07, 0x16, 0x12, 0x40, 0x0A, 0x0A, 0x11, 0x25, 0x01, 0x03, 0x17, 0x10, 0x26, 0x2A, 0x10, 0x01,
    0x23, 0x23, 0x2F, 0x10, 0x06, 0x07, 0x02, 0x09, 0x01, 0x01, 0x01, 0x01, 0x01};

static uint8_t primes_3[256] = { // Compression type 3
    0xFF, 0x0B, 0x07, 0x05, 0x0B, 0x02, 0x02, 0x02, 0x06, 0x02, 0x02, 0x01, 0x04, 0x02, 0x01, 0x03, 0x09, 0x01, 0x01,
    0x01, 0x03, 0x04, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x05, 0x01, 0x01, 0x01, 0x0D, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x0A, 0x04, 0x02, 0x01, 0x06, 0x03, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x03, 0x01, 0x01, 0x01, 0x05, 0x02, 0x03, 0x04, 0x03, 0x03, 0x03, 0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x03,
    0x03, 0x01, 0x03, 0x01, 0x01, 0x02, 0x05, 0x01, 0x01, 0x04, 0x03, 0x05, 0x01, 0x03, 0x01, 0x03, 0x03, 0x02, 0x01,
    0x04, 0x03, 0x0A, 0x06, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x0A, 0x02,
    0x05, 0x01, 0x01, 0x02, 0x07, 0x02, 0x17, 0x01, 0x05, 0x01, 0x01, 0x0E, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x06, 0x02, 0x01, 0x04, 0x05, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x11};

static uint8_t primes_4[16] = { // Compression type 4
    0xFF, 0xFB, 0x98, 0x9A, 0x84, 0x85, 0x63, 0x64, 0x3E, 0x3E, 0x22, 0x22, 0x13, 0x13, 0x18, 0x17};

static uint8_t primes_5[64] = { // Compression type 5
    0xFF, 0xF1, 0x9D, 0x9E, 0x9A, 0x9B, 0x9A, 0x97, 0x93, 0x93, 0x8C, 0x8E, 0x86, 0x88, 0x80, 0x82,
    0x7C, 0x7C, 0x72, 0x73, 0x69, 0x6B, 0x5F, 0x60, 0x55, 0x56, 0x4A, 0x4B, 0x40, 0x41, 0x37, 0x37,
    0x2F, 0x2F, 0x27, 0x27, 0x21, 0x21, 0x1B, 0x1C, 0x17, 0x17, 0x13, 0x13, 0x10, 0x10, 0x0D, 0x0D,
    0x0B, 0x0B, 0x09, 0x09, 0x08, 0x08, 0x07, 0x07, 0x06, 0x05, 0x05, 0x04, 0x04, 0x04, 0x19, 0x18};

static uint8_t primes_6[130] = { // Compression type 6
    0xC3, 0xCB, 0xF5, 0x41, 0xFF, 0x7B, 0xF7, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBF, 0xCC, 0xF2, 0x40, 0xFD, 0x7C, 0xF7, 0x22, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7A, 0x46};

static uint8_t primes_7[130] = { // Compression type 7
    0xC3, 0xD9, 0xEF, 0x3D, 0xF9, 0x7C, 0xE9, 0x1E, 0xFD, 0xAB, 0xF1, 0x2C, 0xFC, 0x5B, 0xFE, 0x17, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBD, 0xD9, 0xEC, 0x3D, 0xF5, 0x7D, 0xE8, 0x1D, 0xFB, 0xAE, 0xF0, 0x2C,
    0xFB, 0x5C, 0xFF, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x6C};

static uint8_t primes_8[130] = { // Compression type 8
    0xBA, 0xC5, 0xDA, 0x33, 0xE3, 0x6D, 0xD8, 0x18, 0xE5, 0x94, 0xDA, 0x23, 0xDF, 0x4A, 0xD1, 0x10, 0xEE, 0xAF, 0xE4,
    0x2C, 0xEA, 0x5A, 0xDE, 0x15, 0xF4, 0x87, 0xE9, 0x21, 0xF6, 0x43, 0xFC, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 0xC7, 0xD8, 0x33, 0xE3, 0x6B, 0xD6, 0x18, 0xE7, 0x95, 0xD8, 0x23,
    0xDB, 0x49, 0xD0, 0x11, 0xE9, 0xB2, 0xE2, 0x2B, 0xE8, 0x5C, 0xDD, 0x15, 0xF1, 0x87, 0xE7, 0x20, 0xF7, 0x44, 0xFF,
    0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F, 0x9E};

static uint8_t *primes[] = {primes_0, primes_1, primes_2, primes_3, primes_4, primes_5, primes_6, primes_7, primes_8};
static int primes_len[]  = {sizeof(primes_0), sizeof(primes_1), sizeof(primes_2), sizeof(primes_3), sizeof(primes_4),
                            sizeof(primes_5), sizeof(primes_6), sizeof(primes_7), sizeof(primes_8)};

struct LinkedNode *huffman_create_linked_node(int decompressed_value, int weight) {
    struct LinkedNode *node = malloc(sizeof(struct LinkedNode));
    FAIL_IF_NULL(node);
    memset(node, 0, sizeof(struct LinkedNode));

    node->decompressed_value = decompressed_value;
    node->weight             = weight;

    return node;
}

struct LinkedNode *huffman_get_child1(struct LinkedNode *node) { return node->child_0->prev; }

struct LinkedNode *huffman_insert(struct LinkedNode *node, struct LinkedNode *other) {
    if (other->weight <= node->weight) {
        if (node->next != NULL) {
            node->next->prev = other;
            other->next      = node->next;
        }

        node->next  = other;
        other->prev = node;

        return other;
    }

    if (node->prev == NULL) {
        other->prev = NULL;
        node->prev  = other;
        other->next = node;
    } else {
        huffman_insert(node->prev, other);
    }

    return node;
}

struct LinkedNode *huffman_decode(struct BitReader *bit_reader, struct LinkedNode *head) {
    struct LinkedNode *node = head;

    while (node->child_0 != NULL) {
        int bit = BitReader_ReadBits(bit_reader, 1);
        if (bit == -1) {
            LOG_FATAL("Failed to decode huffman table!");
        }

        if (bit == 0) {
            node = node->child_0;
            continue;
        }

        node = huffman_get_child1(node);
    }

    return node;
}

struct LinkedNode *huffman_build_list(uint8_t *prime_table, int prime_len) {
    struct LinkedNode *root;

    root = huffman_create_linked_node(DECOMP_VAL_1, 1);
    root = huffman_insert(root, huffman_create_linked_node(DECOMP_VAL_2, 1));

    for (int i = 0; i < prime_len; i++) {
        if (prime_table[i] != 0) {
            root = huffman_insert(root, huffman_create_linked_node(i, prime_table[i]));
        }
    }

    return root;
}

struct LinkedNode *huffman_insert_node(struct LinkedNode *tail, int decomp) {
    struct LinkedNode *parent = tail;
    struct LinkedNode *result = tail->prev;

    struct LinkedNode *temp = huffman_create_linked_node(parent->decompressed_value, parent->weight);
    temp->parent            = parent;

    struct LinkedNode *new_node = huffman_create_linked_node(decomp, 0);
    new_node->parent            = parent;

    parent->child_0 = new_node;

    tail->next     = temp;
    temp->prev     = tail;
    new_node->prev = temp;
    temp->next     = new_node;

    huffman_adjust_tree(new_node);

    // NOTE: For compression type 0, adjust_tree should only be called once
    // for every value written, and only once here.
    huffman_adjust_tree(new_node);

    return result;
}
void huffman_adjust_tree(struct LinkedNode *new_node) {
    struct LinkedNode *current = new_node;

    while (current != NULL) {
        current->weight++;

        struct LinkedNode *insert_point;
        struct LinkedNode *prev;

        insert_point = current;

        while (true) {
            prev = insert_point->prev;
            if (prev == NULL) {
                break;
            }

            if (prev->weight >= current->weight) {
                break;
            }

            insert_point = prev;
        }

        if (insert_point == current) {
            current = current->parent;
            continue;
        }

        if (insert_point->prev != NULL) {
            insert_point->prev->next = insert_point->next;
        }

        insert_point->next->prev = insert_point->prev;
        insert_point->next       = current->next;
        insert_point->prev       = current;

        if (current->next != NULL) {
            current->next->prev = insert_point;
        }

        current->next = insert_point;

        current->prev->next = current->next;
        current->next->prev = current->prev;

        if (prev == NULL) {
            LOG_FATAL("Previous frame is undefined while adjusting huffman tree!");
        }

        struct LinkedNode *temp = prev->next;

        current->next = temp;
        current->prev = prev;
        temp->prev    = current;
        prev->next    = current;

        struct LinkedNode *current_parent = current->parent;
        struct LinkedNode *insert_parent  = insert_point->parent;

        if (current_parent->child_0 == current) {
            current_parent->child_0 = insert_point;
        }

        if (current_parent != insert_parent && insert_parent->child_0 == insert_point) {
            insert_parent->child_0 = current;
        }

        current->parent      = insert_parent;
        insert_point->parent = current_parent;

        current = current->parent;
    }
}
struct LinkedNode *huffman_build_tree(struct LinkedNode *tail) {
    struct LinkedNode *current = tail;

    while (current != NULL) {
        struct LinkedNode *child_0 = current;
        struct LinkedNode *child_1 = current->prev;

        if (child_1 == NULL) {
            break;
        }

        struct LinkedNode *parent = huffman_create_linked_node(0, child_0->weight + child_1->weight);

        parent->child_0 = child_0;
        child_0->parent = parent;
        child_1->parent = parent;

        huffman_insert(current, parent);
        current = current->prev->prev;
    }

    return current;
}
void huffman_free_linked_node(struct LinkedNode *node) {
    struct LinkedNode *next = node->next;
    free(node);
    node = next;
    while (node != NULL) {
        next = node->next;
        free(node);
        node = next;
    }
}

uint8_t *huffman_decompress(uint8_t *buffer, uint32_t buffer_len, uint32_t *result_size) {

    uint8_t comp_type = *buffer;
    buffer++;
    buffer_len--;

    if (comp_type < 1 || comp_type > 8) {
        LOG_FATAL("Invalid data while decompressing huffman table!");
    }

    struct LinkedNode *tail = huffman_build_list(primes[comp_type], primes_len[comp_type]);
    struct LinkedNode *head = huffman_build_tree(tail);

    *result_size = 0;

    uint32_t          current_result_capacity = 8;
    uint8_t          *result                  = calloc(current_result_capacity, 1);
    struct BitReader *bit_reader              = BitReader_Create(buffer, buffer_len);
    int               decoded;

    bool do_loop = true;
    while (do_loop) {
        struct LinkedNode *node = huffman_decode(bit_reader, head);
        decoded                 = node->decompressed_value;

        switch (decoded) {
        case DECOMP_VAL_1:
            do_loop = false;
            break;
        case DECOMP_VAL_2: {
            int new_value = BitReader_ReadBits(bit_reader, 8);
            if (new_value < 0) {
                LOG_FATAL("Failed to decompression huffman tree!");
            }
            *result_size += 1;
            if (*result_size >= current_result_capacity) {
                current_result_capacity <<= 1;
                result                    = realloc(result, current_result_capacity);
            }
            result[*result_size - 1] = new_value;
            tail                     = huffman_insert_node(tail, (uint8_t)new_value);
        } break;
        default:
            *result_size += 1;
            if (*result_size >= current_result_capacity) {
                current_result_capacity <<= 1;
                result                    = realloc(result, current_result_capacity);
            }

            result[*result_size - 1] = decoded;
        }
    }

    BitReader_Destroy(bit_reader);
    huffman_free_linked_node(head);
    return result;
}

```

`src/util/Huffman.h`:

```h
#ifndef ABYSS_HUFFMAN_H
#define ABYSS_HUFFMAN_H

#include "BitReader.h"

struct LinkedNode {
    int                decompressed_value;
    int                weight;
    struct LinkedNode *parent;
    struct LinkedNode *child_0;
    struct LinkedNode *prev;
    struct LinkedNode *next;
};

struct LinkedNode *huffman_create_linked_node(int decompressed_value, int weight);
struct LinkedNode *huffman_get_child1(struct LinkedNode *node);
struct LinkedNode *huffman_insert(struct LinkedNode *node, struct LinkedNode *other);
struct LinkedNode *huffman_decode(struct BitReader *bit_reader, struct LinkedNode *head);
struct LinkedNode *huffman_build_list(uint8_t *prime_table, int prime_len);
struct LinkedNode *huffman_insert_node(struct LinkedNode *tail, int decomp);
void               huffman_adjust_tree(struct LinkedNode *new_node);
struct LinkedNode *huffman_build_tree(struct LinkedNode *tail);
void               huffman_free_linked_node(struct LinkedNode *node);
uint8_t           *huffman_decompress(uint8_t *buffer, uint32_t buffer_len, uint32_t *result_size);
#endif // ABYSS_HUFFMAN_H

```

`src/util/Implode.c`:

```c
#include "Implode.h"
#include <stdlib.h>
#include <string.h>

//-----------------------------------------------------------------------------
// Local structures

// Compression structure (Size 12596 bytes)
typedef struct {
    unsigned long offs0000;   // 0000
    unsigned long ctype;      // 0004 - Compression type (CMP_BINARY or CMP_ASCII)
    unsigned long outputPos;  // 0008 - Position in output buffer
    unsigned long dsize_bits; // 000C - Dict size (4, 5, 6 for 0x400, 0x800, 0x1000)
    unsigned long dsize_mask; // 0010 - Dict size bitmask (0x0F, 0x1F, 0x3F for 0x400, 0x800, 0x1000)
    unsigned long bit_buff;   // 0014 - 16-bit buffer for processing input data
    unsigned long extra_bits; // 0018 - Number of extra (above 8) bits in bit buffer
    unsigned int  in_pos;     // 001C - Position in in_buff
    unsigned long in_bytes;   // 0020 - Number of bytes in input buffer
    void         *param;      // 0024 - Custom parameter
    unsigned int (*read_buf)(char *buf, unsigned int *size, void *param); // 0028
    void (*write_buf)(char *buf, unsigned int *size, void *param);        // 002C
    unsigned char  out_buff[0x2000]; // 0030 - Output circle buffer. Starting position is 0x1000
    unsigned char  offs2030[0x204];  // 2030 - ???
    unsigned char  in_buff[0x800];   // 2234 - Buffer for data to be decompressed
    unsigned char  position1[0x100]; // 2A34 - Positions in buffers
    unsigned char  position2[0x100]; // 2B34 - Positions in buffers
    unsigned char  offs2C34[0x100];  // 2C34 - Buffer for
    unsigned char  offs2D34[0x100];  // 2D34 - Buffer for
    unsigned char  offs2E34[0x80];   // 2EB4 - Buffer for
    unsigned char  offs2EB4[0x100];  // 2EB4 - Buffer for
    unsigned char  ChBitsAsc[0x100]; // 2FB4 - Buffer for
    unsigned char  DistBits[0x40];   // 30B4 - Numbers of bytes to skip copied block length
    unsigned char  LenBits[0x10];    // 30F4 - Numbers of bits for skip copied block length
    unsigned char  ExLenBits[0x10];  // 3104 - Number of valid bits for copied block
    unsigned short LenBase[0x10];    // 3114 - Buffer for
} TDcmpStruct;

//-----------------------------------------------------------------------------
// Tables

static unsigned char DistBits[] = {0x02, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
                                   0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07,
                                   0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
                                   0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x08,
                                   0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08};

static unsigned char DistCode[] = {0x03, 0x0D, 0x05, 0x19, 0x09, 0x11, 0x01, 0x3E, 0x1E, 0x2E, 0x0E, 0x36, 0x16,
                                   0x26, 0x06, 0x3A, 0x1A, 0x2A, 0x0A, 0x32, 0x12, 0x22, 0x42, 0x02, 0x7C, 0x3C,
                                   0x5C, 0x1C, 0x6C, 0x2C, 0x4C, 0x0C, 0x74, 0x34, 0x54, 0x14, 0x64, 0x24, 0x44,
                                   0x04, 0x78, 0x38, 0x58, 0x18, 0x68, 0x28, 0x48, 0x08, 0xF0, 0x70, 0xB0, 0x30,
                                   0xD0, 0x50, 0x90, 0x10, 0xE0, 0x60, 0xA0, 0x20, 0xC0, 0x40, 0x80, 0x00};

static unsigned char ExLenBits[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};

static unsigned short LenBase[] = {0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
                                   0x0008, 0x000A, 0x000E, 0x0016, 0x0026, 0x0046, 0x0086, 0x0106};

static unsigned char LenBits[] = {0x03, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05,
                                  0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07};

static unsigned char LenCode[] = {0x05, 0x03, 0x01, 0x06, 0x0A, 0x02, 0x0C, 0x14,
                                  0x04, 0x18, 0x08, 0x30, 0x10, 0x20, 0x40, 0x00};

static unsigned char ChBitsAsc[] = {
    0x0B, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x08, 0x07, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
    0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x04, 0x0A, 0x08, 0x0C, 0x0A, 0x0C,
    0x0A, 0x08, 0x07, 0x07, 0x08, 0x09, 0x07, 0x06, 0x07, 0x08, 0x07, 0x06, 0x07, 0x07, 0x07, 0x07, 0x08, 0x07, 0x07,
    0x08, 0x08, 0x0C, 0x0B, 0x07, 0x09, 0x0B, 0x0C, 0x06, 0x07, 0x06, 0x06, 0x05, 0x07, 0x08, 0x08, 0x06, 0x0B, 0x09,
    0x06, 0x07, 0x06, 0x06, 0x07, 0x0B, 0x06, 0x06, 0x06, 0x07, 0x09, 0x08, 0x09, 0x09, 0x0B, 0x08, 0x0B, 0x09, 0x0C,
    0x08, 0x0C, 0x05, 0x06, 0x06, 0x06, 0x05, 0x06, 0x06, 0x06, 0x05, 0x0B, 0x07, 0x05, 0x06, 0x05, 0x05, 0x06, 0x0A,
    0x05, 0x05, 0x05, 0x05, 0x08, 0x07, 0x08, 0x08, 0x0A, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
    0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
    0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
    0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
    0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
    0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0C, 0x0D, 0x0D,
    0x0D, 0x0C, 0x0D, 0x0D, 0x0D, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D, 0x0C, 0x0D, 0x0D, 0x0D, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D,
    0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D};

static unsigned short ChCodeAsc[] = {
    0x0490, 0x0FE0, 0x07E0, 0x0BE0, 0x03E0, 0x0DE0, 0x05E0, 0x09E0, 0x01E0, 0x00B8, 0x0062, 0x0EE0, 0x06E0, 0x0022,
    0x0AE0, 0x02E0, 0x0CE0, 0x04E0, 0x08E0, 0x00E0, 0x0F60, 0x0760, 0x0B60, 0x0360, 0x0D60, 0x0560, 0x1240, 0x0960,
    0x0160, 0x0E60, 0x0660, 0x0A60, 0x000F, 0x0250, 0x0038, 0x0260, 0x0050, 0x0C60, 0x0390, 0x00D8, 0x0042, 0x0002,
    0x0058, 0x01B0, 0x007C, 0x0029, 0x003C, 0x0098, 0x005C, 0x0009, 0x001C, 0x006C, 0x002C, 0x004C, 0x0018, 0x000C,
    0x0074, 0x00E8, 0x0068, 0x0460, 0x0090, 0x0034, 0x00B0, 0x0710, 0x0860, 0x0031, 0x0054, 0x0011, 0x0021, 0x0017,
    0x0014, 0x00A8, 0x0028, 0x0001, 0x0310, 0x0130, 0x003E, 0x0064, 0x001E, 0x002E, 0x0024, 0x0510, 0x000E, 0x0036,
    0x0016, 0x0044, 0x0030, 0x00C8, 0x01D0, 0x00D0, 0x0110, 0x0048, 0x0610, 0x0150, 0x0060, 0x0088, 0x0FA0, 0x0007,
    0x0026, 0x0006, 0x003A, 0x001B, 0x001A, 0x002A, 0x000A, 0x000B, 0x0210, 0x0004, 0x0013, 0x0032, 0x0003, 0x001D,
    0x0012, 0x0190, 0x000D, 0x0015, 0x0005, 0x0019, 0x0008, 0x0078, 0x00F0, 0x0070, 0x0290, 0x0410, 0x0010, 0x07A0,
    0x0BA0, 0x03A0, 0x0240, 0x1C40, 0x0C40, 0x1440, 0x0440, 0x1840, 0x0840, 0x1040, 0x0040, 0x1F80, 0x0F80, 0x1780,
    0x0780, 0x1B80, 0x0B80, 0x1380, 0x0380, 0x1D80, 0x0D80, 0x1580, 0x0580, 0x1980, 0x0980, 0x1180, 0x0180, 0x1E80,
    0x0E80, 0x1680, 0x0680, 0x1A80, 0x0A80, 0x1280, 0x0280, 0x1C80, 0x0C80, 0x1480, 0x0480, 0x1880, 0x0880, 0x1080,
    0x0080, 0x1F00, 0x0F00, 0x1700, 0x0700, 0x1B00, 0x0B00, 0x1300, 0x0DA0, 0x05A0, 0x09A0, 0x01A0, 0x0EA0, 0x06A0,
    0x0AA0, 0x02A0, 0x0CA0, 0x04A0, 0x08A0, 0x00A0, 0x0F20, 0x0720, 0x0B20, 0x0320, 0x0D20, 0x0520, 0x0920, 0x0120,
    0x0E20, 0x0620, 0x0A20, 0x0220, 0x0C20, 0x0420, 0x0820, 0x0020, 0x0FC0, 0x07C0, 0x0BC0, 0x03C0, 0x0DC0, 0x05C0,
    0x09C0, 0x01C0, 0x0EC0, 0x06C0, 0x0AC0, 0x02C0, 0x0CC0, 0x04C0, 0x08C0, 0x00C0, 0x0F40, 0x0740, 0x0B40, 0x0340,
    0x0300, 0x0D40, 0x1D00, 0x0D00, 0x1500, 0x0540, 0x0500, 0x1900, 0x0900, 0x0940, 0x1100, 0x0100, 0x1E00, 0x0E00,
    0x0140, 0x1600, 0x0600, 0x1A00, 0x0E40, 0x0640, 0x0A40, 0x0A00, 0x1200, 0x0200, 0x1C00, 0x0C00, 0x1400, 0x0400,
    0x1800, 0x0800, 0x1000, 0x0000};

//-----------------------------------------------------------------------------
// Local variables

// static char copyright[] = "PKWARE Data Compression Library for Win32\r\n"
//                           "Copyright 1989-1995 PKWARE Inc.  All Rights Reserved\r\n"
//                           "Patent No. 5,051,745\r\n"
//                           "PKWARE Data Compression Library Reg. U.S. Pat. and Tm. Off.\r\n"
//                           "Version 1.11";

//-----------------------------------------------------------------------------
// Local functions

static void gen_decode_tabs(const long count, const unsigned char *bits, const unsigned char *p_code,
                            unsigned char *buffer2) {

    for (long i = count - 1; i >= 0; i--) // EBX - count
    {
        unsigned long       idx1 = p_code[i];
        const unsigned long idx2 = 1 << bits[i];

        do {
            buffer2[idx1]  = (unsigned char)i;
            idx1          += idx2;
        } while (idx1 < 0x100);
    }
}

static void gen_asc_tabs(TDcmpStruct *p_work) {
    unsigned short *p_ch_code_asc = &ChCodeAsc[0xFF];
    unsigned long   acc, add;

    for (unsigned short count = 0x00FF; p_ch_code_asc >= ChCodeAsc; p_ch_code_asc--, count--) {
        unsigned char *p_ch_bits_asc = p_work->ChBitsAsc + count;
        unsigned char  bits_asc      = *p_ch_bits_asc;

        if (bits_asc <= 8) {
            add = (1 << bits_asc);
            acc = *p_ch_code_asc;

            do {
                p_work->offs2C34[acc]  = (unsigned char)count;
                acc                   += add;
            } while (acc < 0x100);
        } else if ((acc = (*p_ch_code_asc & 0xFF)) != 0) {
            p_work->offs2C34[acc] = 0xFF;

            if (*p_ch_code_asc & 0x3F) {
                bits_asc       -= 4;
                *p_ch_bits_asc  = bits_asc;

                add = (1 << bits_asc);
                acc = *p_ch_code_asc >> 4;
                do {
                    p_work->offs2D34[acc]  = (unsigned char)count;
                    acc                   += add;
                } while (acc < 0x100);
            } else {
                bits_asc       -= 6;
                *p_ch_bits_asc  = bits_asc;

                add = (1 << bits_asc);
                acc = *p_ch_code_asc >> 6;
                do {
                    p_work->offs2E34[acc]  = (unsigned char)count;
                    acc                   += add;
                } while (acc < 0x80);
            }
        } else {
            bits_asc       -= 8;
            *p_ch_bits_asc  = bits_asc;

            add = (1 << bits_asc);
            acc = *p_ch_code_asc >> 8;
            do {
                p_work->offs2EB4[acc]  = (unsigned char)count;
                acc                   += add;
            } while (acc < 0x100);
        }
    }
}

//-----------------------------------------------------------------------------
// Skips given number of bits in bit buffer. Result is stored in pWork->bit_buff
// If no data in input buffer, returns true

static int WasteBits(TDcmpStruct *pWork, const unsigned long nBits) {
    // If number of bits required is less than number of (bits in the buffer) ?
    if (nBits <= pWork->extra_bits) {
        pWork->extra_bits  -= nBits;
        pWork->bit_buff   >>= nBits;
        return 0;
    }

    // Load input buffer if necessary
    pWork->bit_buff >>= pWork->extra_bits;
    if (pWork->in_pos == pWork->in_bytes) {
        pWork->in_pos = sizeof(pWork->in_buff);
        if ((pWork->in_bytes = pWork->read_buf((char *)pWork->in_buff, &pWork->in_pos, pWork->param)) == 0)
            return 1;
        pWork->in_pos = 0;
    }

    // Update bit buffer
    pWork->bit_buff    |= (pWork->in_buff[pWork->in_pos++] << 8);
    pWork->bit_buff   >>= (nBits - pWork->extra_bits);
    pWork->extra_bits   = (pWork->extra_bits - nBits) + 8;
    return 0;
}

//-----------------------------------------------------------------------------
// Returns : 0x000 - 0x0FF : One byte from compressed file.
//           0x100 - 0x305 : Copy previous block (0x100 = 1 byte)
//           0x306         : Out of buffer (?)

static unsigned long DecodeLit(TDcmpStruct *pWork) {
    unsigned long value; // Position in buffers

    // Test the current bit in byte buffer. If is not set, simply return the next byte.
    if (pWork->bit_buff & 1) {
        unsigned long nBits; // Number of bits to skip

        // Skip current bit in the buffer
        if (WasteBits(pWork, 1))
            return 0x306;

        // The next bits are position in buffers
        value = pWork->position2[(pWork->bit_buff & 0xFF)];

        // Get number of bits to skip
        if (WasteBits(pWork, pWork->LenBits[value]))
            return 0x306;

        if ((nBits = pWork->ExLenBits[value]) != 0) {
            const unsigned long val2 = pWork->bit_buff & ((1 << nBits) - 1);

            if (WasteBits(pWork, nBits)) {
                if ((value + val2) != 0x10E)
                    return 0x306;
            }
            value = pWork->LenBase[value] + val2;
        }
        return value + 0x100; // Return number of bytes to repeat
    }

    // Waste one bit
    if (WasteBits(pWork, 1))
        return 0x306;

    // If the binary compression type, read 8 bits and return them as one byte.
    if (pWork->ctype == CMP_BINARY) {
        value = pWork->bit_buff & 0xFF;
        if (WasteBits(pWork, 8))
            return 0x306;
        return value;
    }

    // When ASCII compression ...
    if (pWork->bit_buff & 0xFF) {
        value = pWork->offs2C34[pWork->bit_buff & 0xFF];

        if (value == 0xFF) {
            if (pWork->bit_buff & 0x3F) {
                if (WasteBits(pWork, 4))
                    return 0x306;

                value = pWork->offs2D34[pWork->bit_buff & 0xFF];
            } else {
                if (WasteBits(pWork, 6))
                    return 0x306;

                value = pWork->offs2E34[pWork->bit_buff & 0x7F];
            }
        }
    } else {
        if (WasteBits(pWork, 8))
            return 0x306;

        value = pWork->offs2EB4[pWork->bit_buff & 0xFF];
    }

    return WasteBits(pWork, pWork->ChBitsAsc[value]) ? 0x306 : value;
}

//-----------------------------------------------------------------------------
// Retrieves the number of bytes to move back

static unsigned long DecodeDist(TDcmpStruct *pWork, const unsigned long dwLength) {
    unsigned long       pos   = pWork->position1[(pWork->bit_buff & 0xFF)];
    const unsigned long nSkip = pWork->DistBits[pos]; // Number of bits to skip

    // Skip the appropriate number of bits
    if (WasteBits(pWork, nSkip) == 1)
        return 0;

    if (dwLength == 2) {
        pos = (pos << 2) | (pWork->bit_buff & 0x03);

        if (WasteBits(pWork, 2) == 1)
            return 0;
    } else {
        pos = (pos << pWork->dsize_bits) | (pWork->bit_buff & pWork->dsize_mask);

        // Skip the bits
        if (WasteBits(pWork, pWork->dsize_bits) == 1)
            return 0;
    }
    return pos + 1;
}

static unsigned long Expand(TDcmpStruct *pWork) {
    unsigned int  copyBytes; // Number of bytes to copy
    unsigned long oneByte;   // One byte from compressed file
    unsigned long dwResult;

    pWork->outputPos = 0x1000; // Initialize output buffer position

    // If end of data or error, terminate decompress
    while ((dwResult = oneByte = DecodeLit(pWork)) < 0x305) {
        // If one byte is greater than 0x100, means "Repeat n - 0xFE bytes"
        if (oneByte >= 0x100) {
            // ECX
            // EDX
            unsigned long copy_length = oneByte - 0xFE;
            unsigned long move_back;

            // Get length of data to copy
            if ((move_back = DecodeDist(pWork, copy_length)) == 0) {
                dwResult = 0x306;
                break;
            }

            // Target and source pointer
            unsigned char       *target  = &pWork->out_buff[pWork->outputPos];
            const unsigned char *source  = target - move_back;
            pWork->outputPos            += copy_length;

            while (copy_length-- > 0)
                *target++ = *source++;
        } else
            pWork->out_buff[pWork->outputPos++] = (unsigned char)oneByte;

        // If number of extracted bytes has reached 1/2 of output buffer,
        // flush output buffer.
        if (pWork->outputPos >= 0x2000) {
            // Copy decompressed data into user buffer
            copyBytes = 0x1000;
            pWork->write_buf((char *)&pWork->out_buff[0x1000], &copyBytes, pWork->param);

            // If there are some data left, keep them alive
            memcpy(pWork->out_buff, &pWork->out_buff[0x1000], pWork->outputPos - 0x1000);
            pWork->outputPos -= 0x1000;
        }
    }

    copyBytes = (unsigned int)pWork->outputPos - 0x1000;
    pWork->write_buf((char *)&pWork->out_buff[0x1000], &copyBytes, pWork->param);
    return dwResult;
}

//-----------------------------------------------------------------------------
// Main exploding function.

unsigned int explode(unsigned int (*read_buf)(char *buf, unsigned int *size, void *param),
                     void (*write_buf)(char *buf, unsigned int *size, void *param), char *work_buf, void *param) {
    TDcmpStruct *pWork = (TDcmpStruct *)work_buf;

    // Initialize work struct and load compressed data
    pWork->read_buf  = read_buf;
    pWork->write_buf = write_buf;
    pWork->param     = param;
    pWork->in_pos    = sizeof(pWork->in_buff);
    pWork->in_bytes  = pWork->read_buf((char *)pWork->in_buff, &pWork->in_pos, pWork->param);
    if (pWork->in_bytes <= 4)
        return CMP_BAD_DATA;

    pWork->ctype      = pWork->in_buff[0]; // Get the compression type
    pWork->dsize_bits = pWork->in_buff[1]; // Get the dictionary size
    pWork->bit_buff   = pWork->in_buff[2]; // Initialize 16-bit bit buffer
    pWork->extra_bits = 0;                 // Extra (over 8) bits
    pWork->in_pos     = 3;                 // Position in input buffer

    // Test for the valid dictionary size
    if (4 > pWork->dsize_bits || pWork->dsize_bits > 6)
        return CMP_INVALID_DICTSIZE;

    pWork->dsize_mask = 0xFFFF >> (0x10 - pWork->dsize_bits); // Shifted by 'sar' instruction

    if (pWork->ctype != CMP_BINARY) {
        if (pWork->ctype != CMP_ASCII)
            return CMP_INVALID_MODE;

        memcpy(pWork->ChBitsAsc, ChBitsAsc, sizeof(pWork->ChBitsAsc));
        gen_asc_tabs(pWork);
    }

    memcpy(pWork->LenBits, LenBits, sizeof(pWork->LenBits));
    gen_decode_tabs(0x10, pWork->LenBits, LenCode, pWork->position2);
    memcpy(pWork->ExLenBits, ExLenBits, sizeof(pWork->ExLenBits));
    memcpy(pWork->LenBase, LenBase, sizeof(pWork->LenBase));
    memcpy(pWork->DistBits, DistBits, sizeof(pWork->DistBits));
    gen_decode_tabs(0x40, pWork->DistBits, DistCode, pWork->position1);
    if (Expand(pWork) != 0x306)
        return CMP_NO_ERROR;

    return CMP_ABORT;
}

// static char copy_right[] = "PKWARE Data Compression Library for Win32\r\n"
//                            "Copyright 1989-1995 PKWARE Inc.  All Rights Reserved\r\n"
//                            "Patent No. 5,051,745\r\n"
//                            "PKWARE Data Compression Library Reg. U.S. Pat. and Tm. Off.\r\n"
//                            "Version 1.11\r\n";

static unsigned long crc_table[] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832,
    0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A,
    0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3,
    0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB,
    0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4,
    0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074,
    0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525,
    0x206F85B3, 0xB966D409, 0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615,
    0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76,
    0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6,
    0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7,
    0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7,
    0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278,
    0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330,
    0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D};

unsigned long crc32_pk(const char *buffer, const unsigned int *psize, const unsigned long *old_crc) {
    unsigned int  size      = *psize;
    unsigned long crc_value = *old_crc;

    while (size-- != 0) {
        const unsigned long ch   = *buffer++ ^ (char)crc_value;
        crc_value              >>= 8;

        crc_value = crc_table[ch & 0x0FF] ^ crc_value;
    }
    return crc_value;
}

```

`src/util/Implode.h`:

```h
/*****************************************************************************/
/* implode                                Copyright (c) Ladislav Zezula 2003 */
/*---------------------------------------------------------------------------*/
/* Implode function of PKWARE Data Compression library                       */
/*---------------------------------------------------------------------------*/
/*   Date    Ver   Who              Comment                                  */
/* --------  ----  ---              -------                                  */
/* 11.04.03  1.00  Ladislav Zezula  First version of implode.c               */
/* 02.05.03  1.00  Ladislav Zezula  Stress test done                         */
/* 12.06.03  1.00  ShadowFlare      Fixed error in WriteCmpData that caused  */
/*                                  different output to be produced          */
/*****************************************************************************/

#ifndef ABYSS_IMPLODE_H
#define ABYSS_IMPLODE_H

//-----------------------------------------------------------------------------
// Defines

#define CMP_BUFFER_SIZE 36312 // Size of compression buffer
#define EXP_BUFFER_SIZE 12596 // Size of decompress buffer

#define CMP_BINARY 0 // Binary compression
#define CMP_ASCII  1 // Ascii compression

#define CMP_NO_ERROR         0
#define CMP_INVALID_DICTSIZE 1
#define CMP_INVALID_MODE     2
#define CMP_BAD_DATA         3
#define CMP_ABORT            4

//-----------------------------------------------------------------------------
// Define calling convention

#define PKEXPORT

//-----------------------------------------------------------------------------
// Public functions

#ifdef __cplusplus
extern "C" {
#endif

unsigned int explode(unsigned int (*read_buf)(char *buf, unsigned int *size, void *param),
                     void (*write_buf)(char *buf, unsigned int *size, void *param), char *work_buf, void *param);

// The original name "crc32" was changed to "crc32pk" due
// to compatibility with zlib
unsigned long crc32_pk(const char *buffer, const unsigned int *size, const unsigned long *old_crc);

#endif // ABYSS_IMPLODE_H

```

`src/util/Mutex.c`:

```c
#include "Mutex.h"

#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#define WINDOWS_LEAN_AND_MEAN
#include <windows.h>
#else // _WIN32
#include <pthread.h>
#endif // _WINDOWS_

struct Mutex {
#ifdef _WIN32
    HANDLE mutex;
#else  // _WIN32
    pthread_mutex_t mutex;
#endif // _WINDOWS_
};

struct Mutex *Mutex_Create(void) {
    struct Mutex *result = malloc(sizeof(Mutex));
    memset(result, 0, sizeof(Mutex));
#ifdef _WIN32
    result->mutex = CreateMutex(NULL, FALSE, NULL);
#else
    pthread_mutex_init(&result->mutex, NULL);
#endif
    return result;
}
void Mutex_Destroy(Mutex **mutex) {
#ifdef _WIN32
    CloseHandle((*mutex)->mutex);
#else
    pthread_mutex_destroy(&(*mutex)->mutex);
#endif
    free(*mutex);
    *mutex = NULL;
}

void Mutex_Lock(Mutex *mutex) {
#if _WIN32
    WaitForSingleObject(mutex->mutex, INFINITE);
#else  // _WIN32
    pthread_mutex_lock(&mutex->mutex);
#endif // _WIN32
}

void Mutex_Unlock(Mutex *mutex) {
#if _WIN32
    ReleaseMutex(mutex->mutex);
#else  // _WIN32
    pthread_mutex_unlock(&mutex->mutex);
#endif // _WIN32
}

```

`src/util/Mutex.h`:

```h
#ifndef ABYSS_MUTEX_H
#define ABYSS_MUTEX_H

typedef struct Mutex Mutex;

struct Mutex *Mutex_Create(void);
void          Mutex_Destroy(Mutex **mutex);
void          Mutex_Lock(Mutex *mutex);
void          Mutex_Unlock(Mutex *mutex);

#endif // ABYSS_MUTEX_H

```

`src/util/WavDecompress.c`:

```c
#include "WavDecompress.h"

#include "../common/Logging.h"
#include "../common/MemoryStream.h"
#include <stdlib.h>
#include <string.h>

const int lookup[] = {0x0007, 0x0008, 0x0009, 0x000A, 0x000B, 0x000C, 0x000D, 0x000E, 0x0010, 0x0011, 0x0013, 0x0015,
                      0x0017, 0x0019, 0x001C, 0x001F, 0x0022, 0x0025, 0x0029, 0x002D, 0x0032, 0x0037, 0x003C, 0x0042,
                      0x0049, 0x0050, 0x0058, 0x0061, 0x006B, 0x0076, 0x0082, 0x008F, 0x009D, 0x00AD, 0x00BE, 0x00D1,
                      0x00E6, 0x00FD, 0x0117, 0x0133, 0x0151, 0x0173, 0x0198, 0x01C1, 0x01EE, 0x0220, 0x0256, 0x0292,
                      0x02D4, 0x031C, 0x036C, 0x03C3, 0x0424, 0x048E, 0x0502, 0x0583, 0x0610, 0x06AB, 0x0756, 0x0812,
                      0x08E0, 0x09C3, 0x0ABD, 0x0BD0, 0x0CFF, 0x0E4C, 0x0FBA, 0x114C, 0x1307, 0x14EE, 0x1706, 0x1954,
                      0x1BDC, 0x1EA5, 0x21B6, 0x2515, 0x28CA, 0x2CDF, 0x315B, 0x364B, 0x3BB9, 0x41B2, 0x4844, 0x4F7E,
                      0x5771, 0x602F, 0x69CE, 0x7462, 0x7FFF};

const int lookup2[] = {-1, 0, -1, 4, -1, 2, -1, 6, -1, 1, -1, 5, -1, 3, -1, 7,
                       -1, 1, -1, 5, -1, 3, -1, 7, -1, 2, -1, 4, -1, 6, -1, 8};

uint8_t *WAV_Decompress(uint8_t *data, uint32_t buffer_len, int channel_count, uint32_t *result_size) {
    int  array1[] = {0x2C, 0x2C};
    int *array2   = malloc(sizeof(int) * channel_count);
    FAIL_IF_NULL(array2);
    memset(array2, 0, sizeof(int) * channel_count);

    struct MemoryStream *memory_stream_in  = MemoryStream_CreateFromExistingBuffer(data, buffer_len);
    struct MemoryStream *memory_stream_out = MemoryStream_Create(true);

    // Skip the first byte
    MemoryStream_SkipBytes(memory_stream_in, 1);

    uint8_t shift = MemoryStream_ReadUint8(memory_stream_in);

    for (int i = 0; i < channel_count; i++) {
        int16_t temp = MemoryStream_ReadInt16(memory_stream_in);
        array2[i]    = (int)temp;
        MemoryStream_WriteInt16(memory_stream_out, temp);
    }

    int channel = channel_count - 1;

    while (MemoryStream_GetBytesAvailableToRead(memory_stream_in)) {
        uint8_t value = MemoryStream_ReadUint8(memory_stream_in);

        if (channel_count == 2) {
            channel = 1 - channel;
        }

        if (channel > 1) {
            LOG_FATAL("Failure decoding WAV: Invalid channel index.");
        }

        if ((value & 0x80) != 0) {
            switch (value & 0x7F) {
            case 0:
                if (array1[channel] != 0) {
                    array1[channel]--;
                }
                MemoryStream_WriteInt16(memory_stream_out, (int16_t)array2[channel]);
                break;
            case 1:
                array1[channel] += 8;
                if (array1[channel] > 0x58) {
                    array1[channel] = 0x58;
                }

                if (channel_count == 2) {
                    channel = 1 - channel;
                }
                break; // <-- It took 3 full afternoons to figure out I forgot this break...
            case 2:
            default:
                array1[channel] -= 8;
                if (array1[channel] < 0) {
                    array1[channel] = 0;
                }

                if (channel_count == 2) {
                    channel = 1 - channel;
                }
            }

            continue;
        }

        if ((channel > 1) || (unsigned long)array1[channel] >= sizeof(lookup)) {
            LOG_FATAL("Failure decoding WAV: Attempted lookup outside of range!");
        }
        int temp1 = lookup[array1[channel]];
        int temp2 = temp1 >> shift;

        if (value & 1) {
            temp2 += temp1 >> 0;
        }
        if (value & 2) {
            temp2 += temp1 >> 1;
        }
        if (value & 4) {
            temp2 += temp1 >> 2;
        }
        if (value & 8) {
            temp2 += temp1 >> 3;
        }
        if (value & 0x10) {
            temp2 += temp1 >> 4;
        }
        if (value & 0x20) {
            temp2 += temp1 >> 5;
        }

        int temp3 = array2[channel];
        if (value & 0x40) {
            temp3 -= temp2;
            if (temp3 < -32768) {
                temp3 = -32768;
            }
        } else {
            temp3 += temp2;
            if (temp3 > 32767) {
                temp3 = 32767;
            }
        }

        array2[channel] = temp3;
        MemoryStream_WriteInt16(memory_stream_out, (int16_t)temp3);
        array1[channel] += lookup2[value & 0x1F];

        if (array1[channel] < 0) {
            array1[channel] = 0;
        } else if (array1[channel] > 0x58) {
            array1[channel] = 0x58;
        }
    }

    free(array2);

    uint8_t *result_buffer = MemoryStream_GetBuffer(memory_stream_out);
    *result_size           = (uint32_t)MemoryStream_GetTotalBytesWritten(memory_stream_out);

    MemoryStream_Destroy(&memory_stream_in);
    MemoryStream_Destroy(&memory_stream_out);
    return result_buffer;
}

```

`src/util/WavDecompress.h`:

```h
#ifndef ABYSS_WAV_DECOMPRESS
#define ABYSS_WAV_DECOMPRESS

#include <stdint.h>

uint8_t *WAV_Decompress(uint8_t *data, uint32_t buffer_len, int channel_count, uint32_t *result_size);

#endif // ABYSS_WAV_DECOMPRESS

```

`tests/CMakeLists.txt`:

```txt
add_executable(ring_buffer_test ./RingBufferTest.c ../src/common/RingBuffer.c ../src/util/Mutex.c)
target_link_libraries(ring_buffer_test)
target_compile_definitions(ring_buffer_test PRIVATE NO_LOGGING)

add_test(NAME ring_buffer_test COMMAND $<TARGET_FILE:ring_buffer_test>)

```

`tests/RingBufferTest.c`:

```c
#include "../src/common/RingBuffer.h"
#include <assert.h>
#include <string.h>

int main(int argc, char **argv) {
    (void)(argc);
    (void)(argv);

    char buffer_in[27] = "abcdefghijklmnopqrstuvwxyz";
    char buffer_out[50];

    struct RingBuffer *rb = RingBuffer_Create(8);
    assert(rb != NULL);

    RingBuffer_Write(rb, buffer_in, 5);

    memset(buffer_out, 0, 50);
    RingBuffer_Read(rb, buffer_out, 3);
    assert(strcmp(buffer_out, "abc") == 0);

    memset(buffer_out, 0, 50);
    RingBuffer_Read(rb, buffer_out, 2);
    assert(strcmp(buffer_out, "de") == 0);

    memset(buffer_out, 0, 50);
    RingBuffer_Write(rb, buffer_in, 7);
    RingBuffer_Read(rb, buffer_out, 7);
    assert(strcmp(buffer_out, "abcdefg") == 0);

    memset(buffer_out, 0, 50);
    RingBuffer_Write(rb, buffer_in, 7);
    RingBuffer_Read(rb, buffer_out, 7);
    assert(strcmp(buffer_out, "abcdefg") == 0);

    RingBuffer_Destroy(&rb);
    assert(rb == NULL);
    return 0;
}

```

`vcpkg.json`:

```json
{
  "name" : "abyssengine",
  "version" : "0.0.1",
  "description" : "An open-source implementation of Diablo 2:LOD",
  "license" : "MIT",
  "builtin-baseline" : "b4a3d89125e45bc8f80fb94bef9761d4f4e14fb9",
  "overrides" : [ ],
  "dependencies" : [ {
    "name" : "libarchive",
    "version>=" : "3.6.2"
  }, {
    "name" : "zlib",
    "version>=" : "1.3"
  }, {
    "name" : "ffmpeg",
    "version>=" : "6.1#2"
  }, {
    "name" : "sdl2",
    "version>=" : "2.30.1"
  } ]
}
```