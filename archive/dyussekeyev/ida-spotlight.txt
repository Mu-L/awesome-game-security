Project Path: arc_dyussekeyev_ida-spotlight_ugac_ogi

Source Tree:

```txt
arc_dyussekeyev_ida-spotlight_ugac_ogi
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ ida-plugin.json
â”œâ”€â”€ ida-plugin.png
â”œâ”€â”€ screenshots
â”‚   â”œâ”€â”€ inspect.gif
â”‚   â”œâ”€â”€ inspect.png
â”‚   â”œâ”€â”€ view.gif
â”‚   â””â”€â”€ view.png
â”œâ”€â”€ spotlight.json
â”œâ”€â”€ spotlight.py
â”œâ”€â”€ spotlight_actions.py
â”œâ”€â”€ spotlight_config.py
â”œâ”€â”€ spotlight_kb.py
â”œâ”€â”€ spotlight_kb_index.py
â”œâ”€â”€ spotlight_scanner.py
â”œâ”€â”€ spotlight_ui.py
â””â”€â”€ spotlight_utils.py

```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
# ğŸ”¦ IDA Spotlight

> **Triage 1000s of functions in seconds, not hours.**

**IDA Spotlight** is an intelligent function triage plugin for IDA Pro that helps malware analysts and reverse engineers quickly identify high-value functions in large binaries using configurable signal patterns and historical sample correlation.

[![IDA Pro](https://img.shields.io/badge/IDA%20Pro-9.2+-blue)](https://hex-rays.com/)
[![License](https://img.shields.io/badge/License-Apache%202.0-green.svg)](https://www.apache.org/licenses/LICENSE-2.0)
[![Python](https://img.shields.io/badge/Python-3.x-yellow)](https://www.python.org/)

---

## ğŸ¯ The Problem

Modern malware samples often contain **thousands of functions**. Reverse engineers spend hours manually scanning through code, trying to identify interesting functions that warrant deeper analysis. This creates a significant bottleneck in malware analysis workflows.

## ğŸ’¡ The Solution

IDA Spotlight automatically **scores and prioritizes functions** based on:

- **API calls** â€” Detects calls to suspicious APIs (networking, injection, persistence, crypto)
- **String references** â€” Matches strings against known malicious patterns (URLs, registry keys, commands)
- **Context relationships** â€” Boosts functions that call other high-scoring functions
- **Historical correlation** â€” Links current sample to previously analyzed IDBs

Instead of manually reviewing 5,000+ functions, analysts can focus on the **top 50 that matter**.

---

## âœ¨ Key Features

### ğŸ“Š Smart Function Scoring

Functions are scored across **7 signal categories**:

| Category | Example Signals |
|----------|----------------|
| **Networking** | `WSAStartup`, `InternetOpenUrl`, `curl_easy_perform`, HTTP headers |
| **Persistence** | `RegSetValueEx`, `CreateService`, registry Run keys, schtasks |
| **Injection** | `VirtualAllocEx`, `WriteProcessMemory`, `CreateRemoteThread`, shellcode patterns |
| **Crypto** | `CryptEncrypt`, `BCryptDecrypt`, `CryptProtectData`, AES/RSA strings |
| **Anti-Analysis** | `IsDebuggerPresent`, `NtQueryInformationProcess`, sandbox detection |
| **Files** | `CreateFile`, `DeleteFile`, shadow copy deletion, ransomware markers |
| **Other** | Privilege escalation, clipboard access, process enumeration |

Each signal has a configurable **weight** (1-10) that contributes to the final score.

### ğŸš¦ Priority Tiers

Functions are automatically classified into priority tiers:

- ğŸ”´ **Critical** â€” Top 10% of scored functions (immediate attention)
- ğŸŸ  **High** â€” Top 30% of scored functions (review soon)
- ğŸŸ¡ **Medium** â€” Remaining scored functions (worth checking)
- âšª **Low** â€” No signals detected

### ğŸ“š Library Function Awareness

- Detects library functions using IDA's **FLIRT** signatures
- Library functions are **automatically deprioritized**
- Priority tiers are calculated **only for non-library code**
- Visual distinction with colored rows

### ğŸ”— Context Bonus

Functions that **call high-scoring functions** receive a context bonus:

```
final_score = base_score + (best_callee_score Ã— 0.15)
```

This ensures wrapper functions and orchestration code don't get lost.

### ğŸ’¾ Knowledge Base (KB)

IDA Spotlight maintains a **SQLite knowledge base** of previously analyzed samples. When you scan a new binary, it correlates against historical data using:

- **Import fingerprints** â€” MD5 of normalized import list
- **Import function overlap** â€” Shared imported APIs
- **Section name profiles** â€” Unusual section patterns
- **Function name matching** â€” User-defined function names

This enables rapid identification of **related samples** and **malware families**.

### ğŸ–¥ï¸ Dual-View Workflow

**IDA Spotlight View** â€” Main results table
- Sortable columns (Function, Score, Priority, Categories)
- Search filtering by function name
- Toggle visibility of low-priority and library functions
- Context menu with copy, jump, and export actions

**IDA Spotlight Quick Inspector** â€” Synchronized detail panel
- Syncs with `IDA View-A/B/C` or `Pseudocode-A/B/C`
- Follows cursor movement like native IDA subviews
- Shows full score breakdown with reasons
- Back/Forward navigation history
- Pin to freeze current function

### ğŸ“¤ Export & Reporting

Export results for external tools and reports:

- **CSV** â€” For spreadsheets and data analysis
- **JSON** â€” For automation and integration

Exports include: function name, address, length, score, priority, library flag, top reason, and all categories.

---

## ğŸš€ Quick Start

### Installation

1. Copy the plugin directory to your IDA plugins folder:
   ```
   %APPDATA%\Hex-Rays\IDA Pro\plugins\ida-spotlight\
   ```

2. Ensure all files are present:
   ```
   ida-spotlight/
   â”œâ”€â”€ spotlight.py            # Main plugin entry point
   â”œâ”€â”€ spotlight_actions.py    # IDA action handlers
   â”œâ”€â”€ spotlight_config.py     # Configuration and constants
   â”œâ”€â”€ spotlight_kb.py         # Knowledge base operations
   â”œâ”€â”€ spotlight_kb_index.py   # KB indexing
   â”œâ”€â”€ spotlight_scanner.py    # Function scanning and scoring
   â”œâ”€â”€ spotlight_ui.py         # PySide6 UI components
   â”œâ”€â”€ spotlight_utils.py      # Utility functions
   â”œâ”€â”€ spotlight.json          # Signal patterns config
   â””â”€â”€ ida-plugin.json         # IDA metadata
   ```

3. Install `idalib` using this [guide](https://docs.hex-rays.com/user-guide/idalib)

4. Launch IDA Pro 9.2

### Indexing

1. Run following command:
```
C:\Users\User>python "C:\Program Files\IDA Professional 9.2\plugins\ida-spotlight-0.1.2\spotlight_kb_index.py" --idb Z:\idb
Using Python: C:\Program Files\Python311\python.exe
KB database: C:\Users\User\AppData\Roaming\Hex-Rays\Ida Pro\IDA Spotlight\ida-spotlight-kb.sqlite
[1/2] Indexing Z:\idb\ktControl_Panel.exe.i64
[2/2] Indexing Z:\idb\ktControl_Panel_Tools.exe.i64
Spotlight KB indexing complete
```

### Usage

1. Open a binary in IDA Pro
2. Navigate to: `View â†’ Open subviews â†’ IDA Spotlight â†’ IDA Spotlight View`
3. Click **Scan** to analyze all functions
4. Review results sorted by score
5. Double-click or press Enter to jump to a function
6. Right-click for context menu options

### Keyboard Shortcuts

| Action | Description |
|--------|-------------|
| `Enter` | Jump to selected function |
| `Double-click` | Jump to selected function |

---

## âš™ï¸ Configuration

### Signal Patterns (`spotlight.json`)

Customize scoring rules by editing `spotlight.json`:

```json
{
  "signals": {
    "networking": {
      "functions": {
        "WSAStartup": 2,
        "connect": 6,
        "InternetOpenUrlA": 6
      },
      "strings": {
        "https?://": 8,
        "User-Agent:": 5
      }
    }
  }
}
```

- **functions** â€” Maps API names to weights
- **strings** â€” Maps regex patterns to weights

### Filters

Exclude noise from analysis:

```json
{
  "filters": {
    "functions": ["^sub_[0-9a-fA-F]+$"],
    "sections": [".text", ".data", ".rdata"],
    "dlls": ["kernel32.dll", "ntdll.dll"]
  }
}
```

### Scoring Parameters

Fine-tune scoring behavior:

```json
{
  "context_bonus_factor": 0.15,
  "library_score_penalty": 3.0
}
```

---

## ğŸ“‹ Requirements

- **IDA Pro** 9.2 or later
- **Python** 3.x (bundled with IDA)
- **PySide6** and **shiboken6** (auto-installed by IDA or via pip)
- **Windows** x86_64 (primary platform)

---

## ğŸ—ï¸ Architecture

```
spotlight.py              # Plugin entry point
â”œâ”€â”€ spotlight_config.py   # Configuration and constants
â”œâ”€â”€ spotlight_utils.py    # Utility functions
â”œâ”€â”€ spotlight_scanner.py  # Function scanning and scoring
â”œâ”€â”€ spotlight_ui.py       # PySide6 UI components
â”œâ”€â”€ spotlight_actions.py  # IDA action handlers
â”œâ”€â”€ spotlight_kb.py       # Knowledge base operations
â””â”€â”€ spotlight_kb_index.py # KB batch indexing script
```

---

## ğŸ¤ Use Cases

### Malware Triage
> "I have 300 samples to analyze this week. IDA Spotlight helps me identify the 10 functions worth reversing in each sample."

### Threat Intelligence
> "When I find a new sample, Spotlight correlates it with our historical KB to identify malware family relationships."

### Vulnerability Research
> "Quickly locate functions handling network input, file operations, or crypto â€” the most likely targets for vulnerabilities."

### CTF Competitions
> "During time-limited competitions, Spotlight immediately highlights interesting functions instead of manual searching."

---

## ğŸ“ˆ Roadmap

- [ ] Cross-platform support (macOS, Linux)
- [ ] Yara rule generation from high-scoring functions
- [ ] Team KB sharing via remote database
- [ ] Machine learning-based signal suggestions
- [ ] Integration with threat intelligence feeds

---

## Demo

![Spotlight View](screenshots/view.gif)
![Spotlight Inspect](screenshots/inspect.gif)

---

## Screenshots

![Spotlight View](screenshots/view.png)
![Spotlight Inspect](screenshots/inspect.png)

---


## ğŸ‘¤ Author

**Askar Dyussekeyev**  
ğŸ“§ dyussekeyev@yandex.kz  
ğŸ”— [github.com/dyussekeyev](https://github.com/dyussekeyev)

---

## ğŸ“„ License

This project is licensed under the **Apache License 2.0** â€” see the full license text at [apache.org/licenses/LICENSE-2.0](https://www.apache.org/licenses/LICENSE-2.0).

---

## ğŸ™ Acknowledgments

- **Hex-Rays** for IDA Pro and the IDAPython API
- The reverse engineering community for inspiring signal patterns
- All malware analysts who shared their workflows and pain points

---

<p align="center">
  <b>â­ Star this repository if IDA Spotlight helps your workflow! â­</b>
</p>

```

`ida-plugin.json`:

```json
{
  "IDAMetadataDescriptorVersion": 1,
  "plugin": {
    "name": "IDA-Spotlight",
    "entryPoint": "spotlight.py",
    "version": "0.1.2",
    "description": "Workflow-centric function triage and prioritization plugin for IDA Pro",
    "urls": {
      "repository": "https://github.com/dyussekeyev/ida-spotlight"
    },
    "authors": [
      {
        "name": "Askar Dyussekeyev",
        "email": "dyussekeyev@yandex.kz"
      }
    ],
    "idaVersions": [
      "9.2"
    ],
    "platforms": ["windows-x86_64"],
    "license": "Apache-2.0",
    "logoPath": "ida-plugin.png",
    "categories": [
      "malware-analysis",
      "ui-ux-and-visualization"
    ],
    "keywords": [
      "malware",
      "malware analysis",
      "focus",
      "spotlight"
    ],
    "pythonDependencies": [
      "PySide6",
      "shiboken6"
    ]
  }
}

```

`spotlight.json`:

```json
{
    "context_bonus_factor": 0.15,
    "library_score_penalty": 3.0,

    "kb_limits": {
        "strong": 25,
        "import_overlap": 50,
        "section_overlap": 25,
        "name_recall": 50,
        "callee_recall_per_callee": 5,
        "callee_recall_max_callees": 25,
        "max_query_import_funcs": 200,
        "max_query_sections": 100
    },

    "filters": {
        "functions": [
            "^sub_[0-9a-fA-F]+$",
            "^unknown_libname_\\d+$",
            "^nullsub_\\d+$"
        ],

        "sections": [
            ".text",
            ".data",
            ".rdata",
            ".bss",
            ".idata",
            ".edata",
            ".rsrc",
            ".reloc"
        ],

        "dlls": [
            "ntdll.dll",
            "kernel32.dll",
            "kernelbase.dll",
            "user32.dll",
            "gdi32.dll",
            "gdi32full.dll",
            "advapi32.dll",
            "ws2_32.dll",
            "wininet.dll",
            "winhttp.dll",
            "crypt32.dll",
            "bcrypt.dll",
            "secur32.dll",
            "rpcrt4.dll",
            "ole32.dll",
            "oleaut32.dll",
            "combase.dll",
            "shell32.dll",
            "shlwapi.dll",
            "comdlg32.dll",
            "urlmon.dll",
            "msvcrt.dll",
            "ucrtbase.dll",
            "vcruntime140.dll",
            "vcruntime140_1.dll",
            "comctl32.dll",
            "uxtheme.dll",
            "imm32.dll",
            "winmm.dll",
            "winscard.dll",
            "msi.dll",
            "gdiplus.dll",
            "oleacc.dll",
            "winspool.drv"
        ]
    },

    "signals": {
        "networking": {
            "functions": {
                "WSAStartup": 2,
                "WSASocketA": 4,
                "WSASocketW": 4,
                "socket": 4,
                "bind": 3,
                "listen": 3,
                "accept": 3,
                "connect": 6,
                "closesocket": 2,
                "send": 3,
                "recv": 3,
                "sendto": 3,
                "recvfrom": 3,
                "setsockopt": 3,
                "select": 3,
                "getaddrinfo": 3,
                "freeaddrinfo": 1,
                "gethostbyname": 3,
                "inet_addr": 2,
                "InetPtonA": 2,
                "InetPtonW": 2,
                "InternetOpenA": 4,
                "InternetOpenW": 4,
                "InternetConnectA": 5,
                "InternetConnectW": 5,
                "InternetOpenUrlA": 6,
                "InternetOpenUrlW": 6,
                "HttpOpenRequestA": 6,
                "HttpOpenRequestW": 6,
                "HttpSendRequestA": 6,
                "HttpSendRequestW": 6,
                "HttpAddRequestHeadersA": 4,
                "HttpAddRequestHeadersW": 4,
                "InternetReadFile": 5,
                "InternetWriteFile": 5,
                "InternetSetOptionA": 4,
                "InternetSetOptionW": 4,
                "InternetCloseHandle": 1,
                "WinHttpOpen": 5,
                "WinHttpConnect": 5,
                "WinHttpOpenRequest": 6,
                "WinHttpAddRequestHeaders": 4,
                "WinHttpSendRequest": 6,
                "WinHttpReceiveResponse": 5,
                "WinHttpReadData": 5,
                "WinHttpQueryHeaders": 4,
                "WinHttpSetOption": 4,
                "WinHttpCloseHandle": 1,
                "URLDownloadToFileA": 7,
                "URLDownloadToFileW": 7,
                "URLOpenBlockingStreamA": 6,
                "URLOpenBlockingStreamW": 6,
                "DnsQuery_A": 5,
                "DnsQuery_W": 5,
                "DnsQueryEx": 6,
                "OpenInternet": 3,
                "curl_easy_init": 5,
                "curl_easy_setopt": 5,
                "curl_easy_perform": 6,
                "curl_easy_cleanup": 1
            },
            "strings": {
                "https?://[a-zA-Z0-9\\-\\.]+(:\\d+)?(/[\\w\\-\\./?%&=]*)?": 8,
                "http[s]?://[0-9]{1,3}(\\.[0-9]{1,3}){3}(:\\d+)?(/[\\w\\-\\./?%&=]*)?": 8,
                "User-Agent:\\s*": 5,
                "Host:\\s*": 5,
                "Accept:\\s*\\*/\\*": 3,
                "Connection:\\s*keep-alive": 3,
                "Content-Type:\\s*application/json": 5,
                "Content-Type:\\s*application/x-www-form-urlencoded": 5,
                "Authorization:\\s*Bearer\\s+[A-Za-z0-9\\-_\\.]+": 6,
                "Cookie:\\s*": 4,
                "POST\\s+/": 5,
                "GET\\s+/": 4,
                "PUT\\s+/": 5,
                "api/v[0-9]+/": 4,
                "\\bwebhook\\b": 6,
                "pastebin\\.com": 6,
                "raw\\.githubusercontent\\.com": 6,
                "discord(app)?\\.com/api/webhooks/": 8,
                "t\\.me/": 6,
                "\\btelegram\\b": 5,
                "\\bTOR\\b": 6,
                "\\bSocks5\\b": 5,
                "\\bproxy\\b": 4,
                "\\bbeacon\\b": 6,
                "\\bcallback\\b": 5,
                "\\bC2\\b": 6,
                "User-Agent\\x00": 4,
                "Mozilla/5\\.0": 3
            }
          },
        "persistence": {
            "functions": {
                "RegCreateKeyExA": 7,
                "RegCreateKeyExW": 7,
                "RegOpenKeyExA": 5,
                "RegOpenKeyExW": 5,
                "RegSetValueExA": 8,
                "RegSetValueExW": 8,
                "RegDeleteValueA": 6,
                "RegDeleteValueW": 6,
                "RegDeleteKeyA": 6,
                "RegDeleteKeyW": 6,
                "RegEnumKeyExA": 4,
                "RegEnumKeyExW": 4,
                "RegEnumValueA": 4,
                "RegEnumValueW": 4,
                "OpenSCManagerA": 6,
                "OpenSCManagerW": 6,
                "CreateServiceA": 9,
                "CreateServiceW": 9,
                "ChangeServiceConfigA": 8,
                "ChangeServiceConfigW": 8,
                "StartServiceA": 8,
                "StartServiceW": 8,
                "ControlService": 7,
                "DeleteService": 7,
                "CreateProcessA": 5,
                "CreateProcessW": 5,
                "CreateProcessAsUserA": 7,
                "CreateProcessAsUserW": 7,
                "ShellExecuteA": 4,
                "ShellExecuteW": 4,
                "WinExec": 5,
                "CreateTask": 8,
                "CoCreateInstance": 4,
                "WTSRegisterSessionNotification": 3,
                "ExitWindowsEx": 4
            },
            "strings": {
                "Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run": 9,
                "Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\RunOnce": 8,
                "Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon\\\\Shell": 9,
                "Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon\\\\Userinit": 9,
                "Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\Explorer\\\\Run": 8,
                "HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Services": 8,
                "ServiceDll": 8,
                "\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run": 9,
                "\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run": 9,
                "schtasks(\\.exe)?\\s+/create": 9,
                "schtasks(\\.exe)?\\s+/run": 7,
                "\\bTask Scheduler\\b": 5,
                "at(\\.exe)?\\s+\\d\\d?:\\d\\d": 6,
                "sc(\\.exe)?\\s+create\\s+": 9,
                "sc(\\.exe)?\\s+start\\s+": 7,
                "reg(\\.exe)?\\s+add\\s+HK": 8,
                "\\bautorun\\b": 6,
                "\\bpersistence\\b": 5,
                "StartupFolder": 5,
                "\\\\Start Menu\\\\Programs\\\\Startup\\\\": 7
            }
        },
        "injection": {
            "functions": {
                "OpenProcess": 6,
                "NtOpenProcess": 7,
                "OpenThread": 6,
                "VirtualAlloc": 4,
                "VirtualAllocEx": 10,
                "VirtualProtect": 5,
                "VirtualProtectEx": 8,
                "WriteProcessMemory": 10,
                "ReadProcessMemory": 6,
                "CreateRemoteThread": 10,
                "CreateRemoteThreadEx": 10,
                "NtCreateThreadEx": 10,
                "RtlCreateUserThread": 9,
                "QueueUserAPC": 8,
                "NtQueueApcThread": 9,
                "NtQueueApcThreadEx": 9,
                "SuspendThread": 6,
                "ResumeThread": 6,
                "GetThreadContext": 7,
                "SetThreadContext": 9,
                "CreateProcessInternalW": 8,
                "CreateProcessA": 5,
                "CreateProcessW": 5,
                "NtMapViewOfSection": 9,
                "NtUnmapViewOfSection": 9,
                "CreateFileMappingA": 6,
                "CreateFileMappingW": 6,
                "MapViewOfFile": 6,
                "MapViewOfFileEx": 8,
                "UnmapViewOfFile": 3,
                "ZwAllocateVirtualMemory": 9,
                "NtAllocateVirtualMemory": 9,
                "NtWriteVirtualMemory": 10,
                "NtReadVirtualMemory": 7,
                "NtProtectVirtualMemory": 8,
                "LdrLoadDll": 8,
                "LoadLibraryA": 4,
                "LoadLibraryW": 4,
                "GetProcAddress": 4,
                "SetWindowsHookExA": 7,
                "SetWindowsHookExW": 7,
                "UnhookWindowsHookEx": 4,
                "CallNextHookEx": 3,
                "GetWindowThreadProcessId": 6,
                "CreateToolhelp32Snapshot": 3,
                "Process32First": 2,
                "Process32Next": 2
            },
            "strings": {
                "\\bshellcode\\b": 9,
                "\\breflective\\b": 8,
                "ReflectiveLoader": 9,
                "ReflectiveDLL": 8,
                "\\bprocess injection\\b": 9,
                "\\bAPC injection\\b": 8,
                "\\bCreateRemoteThread\\b": 7,
                "\\bNtCreateThreadEx\\b": 8,
                "\\bWriteProcessMemory\\b": 7,
                "\\bVirtualAllocEx\\b": 7,
                "rundll32\\.exe": 6,
                "regsvr32\\.exe": 6,
                "cmd\\.exe\\s*/c": 7,
                "powershell\\s+(-|/)?[a-zA-Z]": 7,
                "\\bmshta\\.exe\\b": 7,
                "\\bSetWindowsHookEx\\b": 7,
                "\\bUnmapViewOfSection\\b": 7,
                "\\bprocess hollow(ing)?\\b": 9,
                "\\bhollow\\b": 6
            }
        },
        "crypto": {
            "functions": {
                "CryptAcquireContextA": 7,
                "CryptAcquireContextW": 7,
                "CryptReleaseContext": 2,
                "CryptGenRandom": 6,
                "CryptGenKey": 7,
                "CryptDeriveKey": 6,
                "CryptImportKey": 7,
                "CryptExportKey": 6,
                "CryptCreateHash": 5,
                "CryptHashData": 5,
                "CryptDestroyHash": 2,
                "CryptEncrypt": 8,
                "CryptDecrypt": 8,
                "CryptBinaryToStringA": 5,
                "CryptBinaryToStringW": 5,
                "CryptStringToBinaryA": 5,
                "CryptStringToBinaryW": 5,
                "BCryptOpenAlgorithmProvider": 6,
                "BCryptCloseAlgorithmProvider": 2,
                "BCryptSetProperty": 5,
                "BCryptGetProperty": 4,
                "BCryptGenRandom": 7,
                "BCryptGenerateSymmetricKey": 7,
                "BCryptImportKey": 7,
                "BCryptExportKey": 6,
                "BCryptEncrypt": 8,
                "BCryptDecrypt": 8,
                "BCryptCreateHash": 6,
                "BCryptHashData": 6,
                "BCryptFinishHash": 6,
                "BCryptDestroyHash": 2,
                "BCryptDeriveKeyPBKDF2": 7,
                "NCryptOpenStorageProvider": 7,
                "NCryptCreatePersistedKey": 9,
                "NCryptOpenKey": 8,
                "NCryptImportKey": 8,
                "NCryptExportKey": 7,
                "NCryptSetProperty": 5,
                "NCryptGetProperty": 4,
                "NCryptFinalizeKey": 7,
                "NCryptEncrypt": 8,
                "NCryptDecrypt": 8,
                "NCryptSignHash": 8,
                "NCryptVerifySignature": 6,
                "NCryptSecretAgreement": 8,
                "NCryptDeriveKey": 7,
                "NCryptDeleteKey": 7,
                "NCryptFreeObject": 2,
                "CryptProtectData": 9,
                "CryptUnprotectData": 9,
                "EVP_EncryptInit": 6,
                "EVP_EncryptUpdate": 6,
                "EVP_EncryptFinal": 6,
                "EVP_DecryptInit": 6,
                "EVP_DecryptUpdate": 6,
                "EVP_DecryptFinal": 6,
                "RAND_bytes": 5
            },
            "strings": {
                "\\bAES\\b": 6,
                "\\bRSA\\b": 6,
                "\\bECDH\\b": 6,
                "\\bECDSA\\b": 6,
                "\\bChaCha20\\b": 5,
                "\\bRC4\\b": 7,
                "\\bxor\\b": 6,
                "\\bbase64\\b": 5,
                "\\bencrypt(ion)?\\b": 5,
                "\\bdecrypt(ion)?\\b": 5,
                "\\bkey\\b": 3,
                "\\biv\\b": 3,
                "\\bnonce\\b": 4,
                "-----BEGIN RSA PRIVATE KEY-----": 9,
                "-----BEGIN PRIVATE KEY-----": 8,
                "-----BEGIN EC PRIVATE KEY-----": 8,
                "RSA_FULLPRIVATE_BLOB": 8,
                "BCRYPT_AES_ALGORITHM": 7,
                "BCRYPT_RSA_ALGORITHM": 7,
                "BCRYPT_ECDH_P256_ALGORITHM": 7,
                "bcrypt\\.dll": 6,
                "ncrypt\\.dll": 7,
                "Microsoft Primitive Provider": 6,
                "Microsoft Software Key Storage Provider": 7,
                "DPAPI": 8,
                "CryptProtectData": 8,
                "CryptUnprotectData": 8,
                "wallet": 7,
                "\\bseed phrase\\b": 9,
                "\\bmnemonic\\b": 8,
                "\\bstealer\\b": 6
            }
        },
        "anti-analysis": {
            "functions": {
                "IsDebuggerPresent": 8,
                "CheckRemoteDebuggerPresent": 8,
                "OutputDebugStringA": 5,
                "OutputDebugStringW": 5,
                "NtQueryInformationProcess": 7,
                "NtSetInformationThread": 7,
                "NtQueryObject": 7,
                "ZwQuerySystemInformation": 7,
                "NtQueryVirtualMemory": 7,
                "CreateToolhelp32Snapshot": 5,
                "Process32First": 4,
                "Process32Next": 4,
                "EnumProcesses": 5,
                "EnumProcessModules": 5,
                "GetModuleBaseNameA": 4,
                "GetModuleBaseNameW": 4,
                "QueryPerformanceCounter": 4,
                "GetTickCount": 3,
                "GetTickCount64": 3,
                "Sleep": 1,
                "NtDelayExecution": 4,
                "IsProcessorFeaturePresent": 4,
                "GetSystemInfo": 2,
                "GetNativeSystemInfo": 2,
                "GetSystemFirmwareTable": 6,
                "GetAdaptersInfo": 4,
                "GetAdaptersAddresses": 4,
                "WMIEnumDevices": 4,
                "CoInitializeEx": 2,
                "CoCreateInstance": 3,
                "AddVectoredExceptionHandler": 6,
                "SetUnhandledExceptionFilter": 5,
                "GetForegroundWindow": 2,
                "GetLastInputInfo": 5
            },
            "strings": {
                "\\bsandbox\\b": 7,
                "SbieDll\\.dll": 8,
                "\\bvmware\\b": 6,
                "\\bvirtualbox\\b": 6,
                "\\bvboxservice\\b": 7,
                "\\bvboxmouse\\.sys\\b": 7,
                "\\bqemu\\b": 6,
                "\\bxen\\b": 5,
                "\\bwireshark\\b": 5,
                "\\bfiddler\\b": 5,
                "\\bprocmon\\b": 5,
                "\\bprocesshacker\\b": 6,
                "\\bdebugger\\b": 6,
                "\\banti.?debug\\b": 7,
                "amsi\\.dll": 9,
                "AmsiScanBuffer": 9,
                "\\bAMSI\\b": 8,
                "\\bETW\\b": 6,
                "EtwEventWrite": 8,
                "ntdll\\.dll": 3,
                "\\bSleep\\s*\\(": 2,
                "\\bNtDelayExecution\\b": 4,
                "\\bVIRTUAL\\b": 2,
                "\\bhypervisor\\b": 6
            }
        },
        "files": {
            "functions": {
                "CreateFileA": 4,
                "CreateFileW": 4,
                "ReadFile": 3,
                "WriteFile": 4,
                "SetFilePointer": 3,
                "SetFilePointerEx": 3,
                "GetFileSize": 3,
                "GetFileSizeEx": 3,
                "SetEndOfFile": 4,
                "FlushFileBuffers": 3,
                "CloseHandle": 1,
                "DeleteFileA": 5,
                "DeleteFileW": 5,
                "MoveFileA": 4,
                "MoveFileW": 4,
                "MoveFileExA": 6,
                "MoveFileExW": 6,
                "CopyFileA": 3,
                "CopyFileW": 3,
                "ReplaceFileA": 6,
                "ReplaceFileW": 6,
                "CreateDirectoryA": 3,
                "CreateDirectoryW": 3,
                "RemoveDirectoryA": 3,
                "RemoveDirectoryW": 3,
                "FindFirstFileA": 3,
                "FindFirstFileW": 3,
                "FindNextFileA": 2,
                "FindNextFileW": 2,
                "GetFileAttributesA": 2,
                "GetFileAttributesW": 2,
                "SetFileAttributesA": 4,
                "SetFileAttributesW": 4,
                "GetTempPathA": 3,
                "GetTempPathW": 3,
                "GetTempFileNameA": 4,
                "GetTempFileNameW": 4,
                "SHGetFolderPathA": 4,
                "SHGetFolderPathW": 4,
                "SHGetKnownFolderPath": 4,
                "CreateFileMappingA": 5,
                "CreateFileMappingW": 5,
                "MapViewOfFile": 5,
                "UnmapViewOfFile": 2,
                "NtCreateFile": 7,
                "NtReadFile": 5,
                "NtWriteFile": 6,
                "NtSetInformationFile": 7,
                "GetFinalPathNameByHandleW": 4
            },
            "strings": {
                "%TEMP%": 3,
                "%APPDATA%": 4,
                "%LOCALAPPDATA%": 4,
                "%PROGRAMDATA%": 4,
                "%USERPROFILE%": 3,
                "\\\\Users\\\\[^\\\\]+\\\\AppData\\\\Roaming\\\\": 5,
                "\\\\Users\\\\[^\\\\]+\\\\AppData\\\\Local\\\\Temp\\\\": 5,
                "\\\\Windows\\\\System32\\\\": 4,
                "\\\\Windows\\\\SysWOW64\\\\": 4,
                "\\.exe\\b": 2,
                "\\.dll\\b": 2,
                "\\.dat\\b": 3,
                "\\.tmp\\b": 3,
                "\\bbackup\\b": 4,
                "\\bshadow\\b": 7,
                "vssadmin\\.exe\\s+delete\\s+shadows": 10,
                "wmic\\.exe\\s+shadowcopy\\s+delete": 9,
                "bcdedit\\.exe\\s+/set\\s+\\{default\\}\\s+recoveryenabled\\s+No": 9,
                "\\breadme\\b": 6,
                "\\bhow_to_decrypt\\b": 10,
                "\\bdecrypt_files\\b": 9,
                "\\byour files are encrypted\\b": 10,
                "\\bransom\\b": 9,
                "\\bUPX!\\b": 7,
                "\\bMPRESS\\b": 6,
                "\\bASPack\\b": 6,
                "\\bself-delete\\b": 7,
                "\\bdel\\s+/f\\s+/q\\b": 7
            }
        },
        "other": {
            "functions": {
                "GetCommandLineA": 2,
                "GetCommandLineW": 2,
                "GetModuleFileNameA": 2,
                "GetModuleFileNameW": 2,
                "GetEnvironmentVariableA": 3,
                "GetEnvironmentVariableW": 3,
                "SetEnvironmentVariableA": 4,
                "SetEnvironmentVariableW": 4,
                "OpenProcessToken": 6,
                "LookupPrivilegeValueA": 6,
                "LookupPrivilegeValueW": 6,
                "AdjustTokenPrivileges": 8,
                "ImpersonateLoggedOnUser": 7,
                "RevertToSelf": 4,
                "CreateMutexA": 4,
                "CreateMutexW": 4,
                "OpenMutexA": 3,
                "OpenMutexW": 3,
                "CreateNamedPipeA": 6,
                "CreateNamedPipeW": 6,
                "ConnectNamedPipe": 5,
                "CallNamedPipeA": 6,
                "CallNamedPipeW": 6,
                "CreateToolhelp32Snapshot": 3,
                "GetComputerNameA": 2,
                "GetComputerNameW": 2,
                "GetUserNameA": 3,
                "GetUserNameW": 3,
                "GetClipboardData": 7,
                "OpenClipboard": 6,
                "SetClipboardData": 8,
                "CloseClipboard": 2,
                "NetUserEnum": 5,
                "NetLocalGroupEnum": 5,
                "NetShareEnum": 5,
                "WNetAddConnection2A": 6,
                "WNetAddConnection2W": 6,
                "CreateProcessA": 5,
                "CreateProcessW": 5,
                "ShellExecuteA": 4,
                "ShellExecuteW": 4,
                "WinExec": 5,
                "system": 6,
                "_popen": 6,
                "_wpopen": 6,
                "RtlDecompressBuffer": 7,
                "RtlCompressBuffer": 5,
                "FindResourceA": 4,
                "FindResourceW": 4,
                "LoadResource": 4,
                "LockResource": 3,
                "memcpy": 1,
                "memmove": 1,
                "malloc": 1,
                "free": 1,
                "strstr": 1,
                "strcpy": 1,
                "sprintf": 1,
                "NtCreateUserProcess": 8,
                "NtTerminateProcess": 6,
                "TerminateProcess": 5,
                "ShellExecuteExW": 10
            },
            "strings": {
                  "\\bSeDebugPrivilege\\b": 9,
                  "\\bSeImpersonatePrivilege\\b": 8,
                  "\\bSeLoadDriverPrivilege\\b": 8,
                  "\\bSeTcbPrivilege\\b": 9,
                  "\\btoken\\b": 4,
                  "\\bimpersonat(e|ion)\\b": 6,
                  "\\bstealer\\b": 7,
                  "\\bgrabber\\b": 6,
                  "\\bclipper\\b": 8,
                  "\\bclipboard\\b": 6,
                  "\\bwallet\\b": 7,
                  "\\bexfil\\b": 7,
                  "\\bdiscord\\b": 5,
                  "discord(app)?\\.com/api/webhooks/": 8,
                  "\\btelegram\\b": 5,
                  "\\banti-virus\\b": 5,
                  "\\bdefender\\b": 5,
                  "\\bamsi\\b": 9,
                  "\\betw\\b": 7,
                  "\\bwhoami\\b": 5,
                  "\\bipconfig\\b": 4,
                  "\\bnet\\s+user\\b": 6,
                  "\\bnet\\s+localgroup\\b": 6,
                  "\\bnetsh\\b": 5,
                  "\\bsc\\s+query\\b": 4,
                  "\\bmshta\\.exe\\b": 7,
                  "\\bwscript\\.exe\\b": 6,
                  "\\bcscript\\.exe\\b": 6,
                  "\\bregsvr32\\.exe\\b": 6,
                  "\\brundll32\\.exe\\b": 6,
                  "\\bpacked\\b": 5,
                  "\\bunpack\\b": 5,
                  "\\bloader\\b": 6,
                  "\\bstub\\b": 3
            }
        }
    }
}

```

`spotlight.py`:

```py
# SPDX-License-Identifier: Apache-2.0
"""
IDA Spotlight â€” Function triage for IDA 9.2+ (IDAPython / PySide6)

Main plugin entry point. This module provides the IDA plugin interface
and delegates to the modular components for actual functionality.

Modules:
    spotlight_config: Configuration handling and constants
    spotlight_utils: Utility functions
    spotlight_kb: Knowledge base database operations
    spotlight_scanner: Function scanning and scoring
    spotlight_ui: UI components
    spotlight_actions: IDA action handlers
"""

import idaapi
import ida_kernwin

from spotlight_scanner import CTX
from spotlight_actions import (
    OpenViewHandler,
    register_actions,
    attach_menu_actions,
    install_ui_hooks,
    uninstall_ui_hooks,
)


# ----------------------------------------------------------------------
# Plugin Class
# ----------------------------------------------------------------------

class IDASpotlightPlugin(idaapi.plugin_t):
    """
    Main IDA plugin class for IDA Spotlight.

    Handles plugin initialization, menu registration, and cleanup.
    """

    flags = idaapi.PLUGIN_KEEP
    wanted_name = "IDA Spotlight"

    def init(self) -> int:
        """
        Initialize the plugin and register all actions.

        Returns:
            PLUGIN_KEEP to keep the plugin loaded.
        """
        try:
            idaapi.msg(
                f"[IDA Spotlight] Loaded spotlight.json (categories={len(CTX.categories)})\n"
            )
        except Exception as e:
            CTX.signals, CTX.categories = {}, []
            ida_kernwin.warning(f"IDA Spotlight: failed to load spotlight.json: {e}")

        try:
            ida_kernwin.create_menu(
                "IDASpotlightMenu", "IDA Spotlight", "View/Open subviews/Strings"
            )
        except Exception:
            ida_kernwin.warning("IDA Spotlight: failed to create IDASpotlightMenu")

        register_actions()
        attach_menu_actions()
        install_ui_hooks()

        return idaapi.PLUGIN_KEEP

    def run(self, arg: int) -> None:
        """
        Open the main Spotlight view when plugin is run.

        Args:
            arg: Plugin argument (unused).
        """
        OpenViewHandler().activate(None)

    def term(self) -> None:
        """Clean up when plugin is unloaded."""
        uninstall_ui_hooks()


def PLUGIN_ENTRY() -> IDASpotlightPlugin:
    """
    Plugin entry point for IDA.

    Returns:
        The plugin instance.
    """
    return IDASpotlightPlugin()


```

`spotlight_actions.py`:

```py
# SPDX-License-Identifier: Apache-2.0
"""
IDA action handlers for IDA Spotlight.

This module contains all IDA action handlers and the global UI state including:
- OpenViewHandler: Opens the main Spotlight view
- OpenInspectHandler: Opens the quick inspector
- InspectSyncHereHandler: Syncs inspector to current view
- KBConfigureHandler: Opens KB settings dialog
- Global form references and UI hooks
"""

from typing import Optional

import idaapi
import ida_kernwin

from spotlight_utils import (
    qt_alive,
    is_code_widget,
    widget_title,
    paired_view_titles,
    get_qt_parent,
)
from spotlight_ui import (
    SpotlightViewForm,
    SpotlightInspectForm,
    SpotlightKBSettingsDialog,
)


__all__ = [
    # Form references
    "VIEW_FORM",
    "INSPECT_FORM",
    # Form management
    "ensure_inspect_view",
    # Action handlers
    "OpenViewHandler",
    "OpenInspectHandler",
    "InspectSyncHereHandler",
    "KBConfigureHandler",
    # Registration helpers
    "register_actions",
    "attach_menu_actions",
    "install_ui_hooks",
    "uninstall_ui_hooks",
]


# ----------------------------------------------------------------------
# Global Form References
# ----------------------------------------------------------------------

VIEW_FORM: Optional[SpotlightViewForm] = None
INSPECT_FORM: Optional[SpotlightInspectForm] = None


def _clear_inspect_form() -> None:
    """Clear the global inspect form reference when form closes."""
    global INSPECT_FORM
    INSPECT_FORM = None


def _inspect_at_ea(ea: int) -> None:
    """
    Open the inspector and navigate to the given EA.

    Args:
        ea: The effective address to inspect.
    """
    ensure_inspect_view().update_for_ea(ea, push_history=True)


# Set the callbacks on the classes to avoid circular imports
SpotlightInspectForm.on_close_callback = _clear_inspect_form
SpotlightViewForm.inspect_callback = _inspect_at_ea


def ensure_inspect_view() -> SpotlightInspectForm:
    """
    Get or create the quick inspector form.

    Returns:
        The SpotlightInspectForm instance.
    """
    global INSPECT_FORM
    if INSPECT_FORM is not None and qt_alive(getattr(INSPECT_FORM, "inspector", None)):
        return INSPECT_FORM
    INSPECT_FORM = SpotlightInspectForm()
    INSPECT_FORM.Show("IDA Spotlight Quick Inspector")
    return INSPECT_FORM


# ----------------------------------------------------------------------
# UI Hooks
# ----------------------------------------------------------------------

class SpotlightUIHooks(ida_kernwin.UI_Hooks):
    """Global UI hooks for tracking cursor movement and populating menus."""

    def screen_ea_changed(self, ea: int, *args) -> None:
        """
        Handle screen EA changes to update the inspector.

        Args:
            ea: The new effective address.
            *args: Additional arguments (unused).
        """
        if INSPECT_FORM is None:
            return
        if not qt_alive(getattr(INSPECT_FORM, "inspector", None)):
            return

        try:
            widget = ida_kernwin.get_current_widget()
        except Exception:
            widget = None

        title = widget_title(widget) if widget is not None else ""
        INSPECT_FORM.on_screen_ea_changed(title, int(ea))

    def finish_populating_widget_popup(
        self,
        widget: object,
        popup: object,
        ctx: object,
    ) -> None:
        """
        Add Spotlight menu items to code view context menus.

        Args:
            widget: The widget being populated.
            popup: The popup menu handle.
            ctx: The context object.
        """
        try:
            widget_type = ida_kernwin.get_widget_type(widget)
        except Exception:
            return

        if widget_type not in (ida_kernwin.BWN_DISASM, ida_kernwin.BWN_PSEUDOCODE):
            return

        ida_kernwin.attach_action_to_popup(
            widget, popup, "ida_spotlight:inspect_sync_here", "IDA Spotlight/"
        )
        ida_kernwin.attach_action_to_popup(
            widget, popup, "ida_spotlight:view_open", "IDA Spotlight/"
        )
        ida_kernwin.attach_action_to_popup(
            widget, popup, "ida_spotlight:inspect_open", "IDA Spotlight/"
        )


# Global hooks instance
_UI_HOOKS: Optional[SpotlightUIHooks] = None


# ----------------------------------------------------------------------
# Action Handlers
# ----------------------------------------------------------------------

class OpenViewHandler(ida_kernwin.action_handler_t):
    """Action handler to open the main Spotlight view."""

    def activate(self, ctx: object) -> int:
        """
        Activate the action to open the main view.

        Args:
            ctx: The action context (unused).

        Returns:
            1 to indicate successful activation.
        """
        global VIEW_FORM
        if VIEW_FORM is None:
            VIEW_FORM = SpotlightViewForm()
        VIEW_FORM.Show("IDA Spotlight View")
        return 1

    def update(self, ctx: object) -> int:
        """
        Update the action state.

        Args:
            ctx: The action context (unused).

        Returns:
            AST_ENABLE_ALWAYS to keep the action always enabled.
        """
        return ida_kernwin.AST_ENABLE_ALWAYS


class OpenInspectHandler(ida_kernwin.action_handler_t):
    """Action handler to open the quick inspector."""

    def activate(self, ctx: object) -> int:
        """
        Activate the action to open the inspector.

        Args:
            ctx: The action context (unused).

        Returns:
            1 to indicate successful activation.
        """
        ensure_inspect_view()
        return 1

    def update(self, ctx: object) -> int:
        """
        Update the action state.

        Args:
            ctx: The action context (unused).

        Returns:
            AST_ENABLE_ALWAYS to keep the action always enabled.
        """
        return ida_kernwin.AST_ENABLE_ALWAYS


class InspectSyncHereHandler(ida_kernwin.action_handler_t):
    """Action handler to sync the inspector to the current view."""

    def activate(self, ctx: object) -> int:
        """
        Activate the action to sync the inspector.

        Args:
            ctx: The action context.

        Returns:
            1 to indicate successful activation.
        """
        try:
            source_widget = getattr(ctx, "widget", None) or ida_kernwin.get_current_widget()
        except Exception:
            source_widget = None

        title = widget_title(source_widget) if source_widget is not None else ""
        titles = paired_view_titles(title)

        inspector = ensure_inspect_view()
        inspector.sync_with_titles(titles)
        return 1

    def update(self, ctx: object) -> int:
        """
        Update the action state.

        Args:
            ctx: The action context (unused).

        Returns:
            AST_ENABLE_ALWAYS to keep the action always enabled.
        """
        return ida_kernwin.AST_ENABLE_ALWAYS


class KBConfigureHandler(ida_kernwin.action_handler_t):
    """Action handler to open the KB settings dialog."""

    def activate(self, ctx: object) -> int:
        """
        Activate the action to open KB settings.

        Args:
            ctx: The action context (unused).

        Returns:
            1 to indicate successful activation.
        """
        dialog = SpotlightKBSettingsDialog(get_qt_parent())
        dialog.exec_()
        return 1

    def update(self, ctx: object) -> int:
        """
        Update the action state.

        Args:
            ctx: The action context (unused).

        Returns:
            AST_ENABLE_ALWAYS to keep the action always enabled.
        """
        return ida_kernwin.AST_ENABLE_ALWAYS


# ----------------------------------------------------------------------
# Plugin Registration Helpers
# ----------------------------------------------------------------------

def register_actions() -> None:
    """Register all IDA actions for the plugin."""
    # Main view action
    ida_kernwin.register_action(
        ida_kernwin.action_desc_t(
            "ida_spotlight:view",
            "IDA Spotlight View",
            OpenViewHandler(),
            None,
        )
    )

    # Main inspector action
    ida_kernwin.register_action(
        ida_kernwin.action_desc_t(
            "ida_spotlight:inspect",
            "IDA Spotlight Inspect",
            OpenInspectHandler(),
            None,
        )
    )

    # Context menu: sync inspector
    ida_kernwin.register_action(
        ida_kernwin.action_desc_t(
            "ida_spotlight:inspect_sync_here",
            "Sync IDA Spotlight Inspect to this view",
            InspectSyncHereHandler(),
            None,
        )
    )

    # Context menu: open view
    ida_kernwin.register_action(
        ida_kernwin.action_desc_t(
            "ida_spotlight:view_open",
            "IDA Spotlight View",
            OpenViewHandler(),
            None,
        )
    )

    # Context menu: open inspector
    ida_kernwin.register_action(
        ida_kernwin.action_desc_t(
            "ida_spotlight:inspect_open",
            "IDA Spotlight Inspect",
            OpenInspectHandler(),
            None,
        )
    )

    # KB configuration action
    ida_kernwin.register_action(
        ida_kernwin.action_desc_t(
            "ida_spotlight:kb_configure",
            "Configure Spotlight KB",
            KBConfigureHandler(),
            None,
        )
    )


def attach_menu_actions() -> None:
    """Attach actions to the IDA menu."""
    menu_path = "View/Open subviews/IDA Spotlight/"
    ida_kernwin.attach_action_to_menu(
        menu_path,
        "ida_spotlight:kb_configure",
        ida_kernwin.SETMENU_APP,
    )
    ida_kernwin.attach_action_to_menu(
        menu_path,
        "ida_spotlight:view",
        ida_kernwin.SETMENU_APP,
    )
    ida_kernwin.attach_action_to_menu(
        menu_path,
        "ida_spotlight:inspect",
        ida_kernwin.SETMENU_APP,
    )


def install_ui_hooks() -> None:
    """Install global UI hooks."""
    global _UI_HOOKS
    if _UI_HOOKS is None:
        _UI_HOOKS = SpotlightUIHooks()
        _UI_HOOKS.hook()


def uninstall_ui_hooks() -> None:
    """Uninstall global UI hooks."""
    global _UI_HOOKS
    if _UI_HOOKS is not None:
        try:
            _UI_HOOKS.unhook()
        except Exception:
            pass
        _UI_HOOKS = None

```

`spotlight_config.py`:

```py
# SPDX-License-Identifier: Apache-2.0
"""
Configuration handling and constants for IDA Spotlight.

This module provides centralized configuration management including:
- Loading and validating the JSON configuration
- Global constants for KB limits and scoring
- Netnode-based per-IDB settings storage
"""

import json
import os
import re
from typing import Any, Dict, List, Pattern, Set, Tuple

import ida_netnode


__all__ = [
    # Configuration loading
    "load_config",
    "default_kb_db_path",
    # Module-level configuration
    "BASE_DIR",
    "SIGNALS",
    "CONFIG",
    "IGNORED_FUNCTIONS",
    "IGNORED_SECTIONS",
    "IGNORED_DLLS",
    # Scoring parameters
    "CONTEXT_BONUS_FACTOR",
    "LIBRARY_SCORE_PENALTY",
    # KB Limits
    "KB_LIMITS",
    "KB_LIMIT_STRONG",
    "KB_LIMIT_IMPORT_OVERLAP",
    "KB_LIMIT_SECTION_OVERLAP",
    "KB_LIMIT_NAME_RECALL",
    "KB_LIMIT_CALLEE_RECALL_PER_CALLEE",
    "KB_LIMIT_CALLEE_RECALL_MAX_CALLEES",
    "KB_LIMIT_MAX_QUERY_IMPORT_FUNCS",
    "KB_LIMIT_MAX_QUERY_SECTIONS",
    # Per-IDB settings
    "KB_NODE_NAME",
    "kb_node",
    "kb_get_setting",
    "kb_set_setting",
    "kb_db_path",
]


# ----------------------------------------------------------------------
# Config loading helpers
# ----------------------------------------------------------------------

def _safe_regex(pattern: str) -> bool:
    """
    Check if a regex pattern is valid.

    Args:
        pattern: The regex pattern string to validate.

    Returns:
        True if the pattern is valid, False otherwise.
    """
    try:
        re.compile(pattern)
        return True
    except re.error:
        return False


def _normalize_name(name: str) -> str:
    """
    Normalize a name to lowercase for comparison.

    Args:
        name: The name string to normalize.

    Returns:
        The normalized lowercase string.
    """
    return (name or "").strip().lower()


def _normalize_dll_name(name_raw: str) -> str:
    """
    Normalize a DLL name, adding .dll extension if missing.

    Args:
        name_raw: The raw DLL name string.

    Returns:
        The normalized DLL name with extension.
    """
    normalized = _normalize_name(name_raw)
    if not normalized:
        return ""
    if "." in os.path.basename(normalized):
        return normalized
    return normalized + ".dll"


def load_config(base_dir: str) -> Tuple[Dict[str, Any], Dict[str, Any]]:
    """
    Load and parse the spotlight configuration file.

    Args:
        base_dir: The directory containing the config file.

    Returns:
        A tuple of (signals, config) dictionaries.

    Raises:
        FileNotFoundError: If the configuration file is not found.
        json.JSONDecodeError: If the configuration file is invalid JSON.
    """
    config_path = os.path.join(base_dir, "spotlight.json")
    if not os.path.exists(config_path):
        raise FileNotFoundError(f"Missing {config_path}")

    with open(config_path, "r", encoding="utf-8") as config_file:
        raw_config = json.load(config_file)

    filters = raw_config.get("filters", {}) or {}

    config: Dict[str, Any] = {
        "context_bonus_factor": float(raw_config.get("context_bonus_factor", 0.15)),
        "library_score_penalty": float(raw_config.get("library_score_penalty", 3.0)),
        "ignored_functions": [
            re.compile(pattern)
            for pattern in filters.get("functions", [])
            if _safe_regex(pattern)
        ],
        "ignored_sections": {
            _normalize_name(section)
            for section in filters.get("sections", [])
            if section
        },
        "ignored_dlls": {
            _normalize_dll_name(dll)
            for dll in filters.get("dlls", [])
            if dll
        },
    }

    kb_limits_raw = raw_config.get("kb_limits", {}) or {}
    config["kb_limits"] = {
        "strong": int(kb_limits_raw.get("strong", 25)),
        "import_overlap": int(kb_limits_raw.get("import_overlap", 50)),
        "section_overlap": int(kb_limits_raw.get("section_overlap", 25)),
        "name_recall": int(kb_limits_raw.get("name_recall", 50)),
        "callee_recall_per_callee": int(kb_limits_raw.get("callee_recall_per_callee", 5)),
        "callee_recall_max_callees": int(kb_limits_raw.get("callee_recall_max_callees", 25)),
        "max_query_import_funcs": int(kb_limits_raw.get("max_query_import_funcs", 200)),
        "max_query_sections": int(kb_limits_raw.get("max_query_sections", 100)),
    }

    signals = raw_config.get("signals", {}) or {}

    return signals, config


def default_kb_db_path() -> str:
    """
    Get the default KB database path.

    Returns:
        The path to the default KB SQLite database.
    """
    appdata = os.environ.get("APPDATA", os.path.expanduser("~"))
    kb_base_dir = os.path.join(appdata, "Hex-Rays", "Ida Pro", "IDA Spotlight")
    os.makedirs(kb_base_dir, exist_ok=True)
    return os.path.join(kb_base_dir, "ida-spotlight-kb.sqlite")


# ----------------------------------------------------------------------
# Module-level configuration
# ----------------------------------------------------------------------

BASE_DIR: str = os.path.dirname(__file__)
SIGNALS: Dict[str, Any]
CONFIG: Dict[str, Any]
SIGNALS, CONFIG = load_config(BASE_DIR)

# Extracted configuration values
IGNORED_FUNCTIONS: List[Pattern[str]] = CONFIG["ignored_functions"]
IGNORED_SECTIONS: Set[str] = CONFIG["ignored_sections"]
IGNORED_DLLS: Set[str] = CONFIG["ignored_dlls"]

# Scoring parameters
CONTEXT_BONUS_FACTOR: float = CONFIG["context_bonus_factor"]
LIBRARY_SCORE_PENALTY: float = CONFIG["library_score_penalty"]

# ----------------------------------------------------------------------
# KB Limits Configuration
# ----------------------------------------------------------------------

KB_LIMITS: Dict[str, int] = CONFIG["kb_limits"]

KB_LIMIT_STRONG: int = KB_LIMITS["strong"]
KB_LIMIT_IMPORT_OVERLAP: int = KB_LIMITS["import_overlap"]
KB_LIMIT_SECTION_OVERLAP: int = KB_LIMITS["section_overlap"]
KB_LIMIT_NAME_RECALL: int = KB_LIMITS["name_recall"]
KB_LIMIT_CALLEE_RECALL_PER_CALLEE: int = KB_LIMITS["callee_recall_per_callee"]
KB_LIMIT_CALLEE_RECALL_MAX_CALLEES: int = KB_LIMITS["callee_recall_max_callees"]
KB_LIMIT_MAX_QUERY_IMPORT_FUNCS: int = KB_LIMITS["max_query_import_funcs"]
KB_LIMIT_MAX_QUERY_SECTIONS: int = KB_LIMITS["max_query_sections"]

# Netnode name for per-IDB settings
KB_NODE_NAME: str = "$ ida_spotlight_kb"


# ----------------------------------------------------------------------
# Per-IDB Settings (via netnode)
# ----------------------------------------------------------------------

def kb_node() -> ida_netnode.netnode:
    """
    Get or create the netnode for KB settings.

    Returns:
        The netnode instance for storing KB settings.
    """
    return ida_netnode.netnode(KB_NODE_NAME, ida_netnode.NETNODE_CREATE)


def kb_get_setting(key: str, default: str = "") -> str:
    """
    Retrieve a string setting from the KB netnode.

    Args:
        key: The setting key name.
        default: Default value if key not found or on error.

    Returns:
        The stored string value or the default.
    """
    try:
        value = kb_node().get(key)
        if value is None:
            return default
        return value.decode("utf-8")
    except Exception:
        return default


def kb_set_setting(key: str, value: str) -> None:
    """
    Store a string setting in the KB netnode.

    Args:
        key: The setting key name.
        value: The string value to store.
    """
    try:
        kb_node().set(key, value.encode("utf-8"))
    except Exception:
        pass


def kb_db_path() -> str:
    """
    Get the KB database path from per-IDB settings.

    Falls back to the default path if no custom path is set.

    Returns:
        The path to the KB SQLite database.
    """
    stored_path = kb_get_setting("db_path", "").strip()
    return stored_path if stored_path else default_kb_db_path()

```

`spotlight_kb.py`:

```py
# SPDX-License-Identifier: Apache-2.0
"""
Knowledge Base database operations for IDA Spotlight.

This module handles all SQLite database interactions for the KB including:
- Database connection management
- Database readiness checks and diagnostics
- Sample profile extraction for correlation
- Query functions for various recall types
"""

import os
import sqlite3
from typing import Any, Dict, List

import idaapi

from spotlight_utils import (
    fingerprint_md5,
    build_import_items,
    normalize_name,
    is_filtered_func,
    collect_import_modules,
    iter_segments,
)
from spotlight_config import (
    kb_db_path,
    IGNORED_DLLS,
    IGNORED_SECTIONS,
    IGNORED_FUNCTIONS,
    KB_LIMIT_STRONG,
    KB_LIMIT_IMPORT_OVERLAP,
    KB_LIMIT_SECTION_OVERLAP,
    KB_LIMIT_NAME_RECALL,
    KB_LIMIT_MAX_QUERY_IMPORT_FUNCS,
    KB_LIMIT_MAX_QUERY_SECTIONS,
)


__all__ = [
    # Database connection
    "kb_db_connect",
    "kb_db_ready",
    "kb_db_diagnose",
    # Sample profile
    "extract_sample_profile_for_kb",
    # KB queries
    "kb_paths_by_import_fingerprint",
    "kb_paths_by_section_norms",
    "kb_paths_by_import_func_norms",
    "kb_paths_for_function_name_raw",
    # Correlation logging
    "log_kb_sample_correlation",
]


# ----------------------------------------------------------------------
# Database Connection
# ----------------------------------------------------------------------

def kb_db_connect() -> sqlite3.Connection:
    """
    Create a connection to the KB database.

    Returns:
        A SQLite connection with row_factory set to sqlite3.Row.
    """
    connection = sqlite3.connect(kb_db_path())
    connection.row_factory = sqlite3.Row
    return connection


def kb_db_ready() -> bool:
    """
    Check if the KB database is ready for use.

    Verifies that the database file exists and contains the expected schema.

    Returns:
        True if the database is ready, False otherwise.
    """
    db_path = kb_db_path()
    if not os.path.exists(db_path):
        return False
    try:
        with kb_db_connect() as connection:
            cursor = connection.execute(
                "SELECT 1 FROM sqlite_master WHERE type='table' AND name='idb'"
            )
            return cursor.fetchone() is not None
    except Exception:
        return False


def kb_db_diagnose(path: str) -> str:
    """
    Diagnose issues with the KB database.

    Args:
        path: The path to the database file.

    Returns:
        An empty string if OK, or a diagnostic message describing the problem.
    """
    if not path:
        return "database path is empty"

    if not os.path.exists(path):
        return "file does not exist"

    try:
        connection = sqlite3.connect(path)
    except sqlite3.Error as e:
        return f"sqlite open failed: {e}"

    try:
        cursor = connection.execute(
            "SELECT name FROM sqlite_master WHERE type='table' AND name='idb'"
        )
        if cursor.fetchone() is None:
            return "sqlite opened, but Spotlight schema missing (table 'idb')"
    except sqlite3.Error as e:
        return f"schema check failed: {e}"
    finally:
        connection.close()

    return ""  # OK


# ----------------------------------------------------------------------
# Sample Profile Extraction
# ----------------------------------------------------------------------

def _iter_section_norms_filtered() -> List[str]:
    """
    Iterate over section names, excluding ignored ones.

    Returns:
        A list of normalized section names.
    """
    return [
        name_norm
        for _, name_norm, _, _ in iter_segments(IGNORED_SECTIONS, keep_common=False)
    ]


def extract_sample_profile_for_kb(keep_common_imports: bool) -> Dict[str, Any]:
    """
    Extract the current sample's profile for KB correlation.

    Args:
        keep_common_imports: If True, include common imports in the fingerprint.

    Returns:
        A dictionary containing import fingerprint, dll norms,
        import function norms, and section norms.
    """
    import_modules = collect_import_modules()

    import_items = build_import_items(
        import_modules=import_modules,
        common_import_dlls=IGNORED_DLLS,
        keep_common_imports=keep_common_imports,
    )

    import_fingerprint = fingerprint_md5(import_items)

    dll_norms = sorted({item.split("!", 1)[0] for item in import_items})
    import_func_norms = sorted({item.split("!", 1)[1] for item in import_items})

    section_norms = sorted(set(_iter_section_norms_filtered()))

    return {
        "import_items": import_items,
        "import_fingerprint": import_fingerprint,
        "dll_norms": dll_norms,
        "import_func_norms": import_func_norms,
        "section_norms": section_norms,
    }


# ----------------------------------------------------------------------
# KB Queries
# ----------------------------------------------------------------------

def kb_paths_by_import_fingerprint(fingerprint: str) -> List[str]:
    """
    Find IDB paths matching an import fingerprint.

    Args:
        fingerprint: The MD5 import fingerprint.

    Returns:
        A list of matching IDB paths.
    """
    fingerprint = (fingerprint or "").strip()
    if not fingerprint:
        return []
    with kb_db_connect() as connection:
        rows = connection.execute(
            """
            SELECT path
            FROM idb
            WHERE import_fingerprint = ?
            ORDER BY path
            LIMIT ?
            """,
            (fingerprint, KB_LIMIT_STRONG + 1),
        ).fetchall()
        return [row["path"] for row in rows]


def kb_paths_by_section_norms(section_norms: List[str]) -> List[str]:
    """
    Find IDB paths containing any of the specified sections.

    Args:
        section_norms: A list of normalized section names.

    Returns:
        A list of matching IDB paths.
    """
    section_norms = [s for s in (section_norms or []) if s]
    if not section_norms:
        return []
    placeholders = ",".join(["?"] * len(section_norms))
    with kb_db_connect() as connection:
        rows = connection.execute(
            f"""
            SELECT DISTINCT idb.path AS path
            FROM feat_section s
            JOIN idb ON idb.id = s.idb_id
            WHERE s.name_norm IN ({placeholders})
            ORDER BY path
            LIMIT ?
            """,
            (*section_norms, KB_LIMIT_SECTION_OVERLAP + 1),
        ).fetchall()
        return [row["path"] for row in rows]


def kb_paths_by_import_func_norms(import_func_norms: List[str]) -> List[str]:
    """
    Find IDB paths containing any of the specified import functions.

    Args:
        import_func_norms: A list of normalized import function names.

    Returns:
        A list of matching IDB paths.
    """
    import_func_norms = [s for s in (import_func_norms or []) if s]
    if not import_func_norms:
        return []
    placeholders = ",".join(["?"] * len(import_func_norms))
    with kb_db_connect() as connection:
        rows = connection.execute(
            f"""
            SELECT DISTINCT idb.path AS path
            FROM feat_import_func f
            JOIN idb ON idb.id = f.idb_id
            WHERE f.func_norm IN ({placeholders})
            ORDER BY path
            LIMIT ?
            """,
            (*import_func_norms, KB_LIMIT_IMPORT_OVERLAP + 1),
        ).fetchall()
        return [row["path"] for row in rows]


def kb_paths_for_function_name_raw(name_raw: str) -> List[str]:
    """
    Find IDB paths containing a function with the given name.

    Args:
        name_raw: The raw function name.

    Returns:
        A list of matching IDB paths.
    """
    name = (name_raw or "").strip()
    if not name:
        return []
    if is_filtered_func(name, IGNORED_FUNCTIONS):
        return []
    name_norm = normalize_name(name)
    with kb_db_connect() as connection:
        rows = connection.execute(
            """
            SELECT DISTINCT idb.path AS path
            FROM func
            JOIN idb ON idb.id = func.idb_id
            WHERE func.name_norm = ?
            ORDER BY path
            LIMIT ?
            """,
            (name_norm, KB_LIMIT_NAME_RECALL + 1),
        ).fetchall()
        return [row["path"] for row in rows]


# ----------------------------------------------------------------------
# KB Correlation Logging
# ----------------------------------------------------------------------

def log_kb_sample_correlation() -> None:
    """
    Log the KB correlation summary to the IDA output window.

    Prints information about samples matching the current IDB via:
    - Import fingerprint (strict and loose)
    - Import function overlap
    - Section overlap
    """
    if not kb_db_ready():
        idaapi.msg("[IDA Spotlight] KB not ready\n")
        return

    idaapi.msg("\n[IDA Spotlight] KB correlation summary\n")
    idaapi.msg("-------------------------------------\n")

    profile_strict = extract_sample_profile_for_kb(keep_common_imports=False)
    profile_loose = extract_sample_profile_for_kb(keep_common_imports=True)

    strict_matches = kb_paths_by_import_fingerprint(profile_strict["import_fingerprint"])
    loose_matches = kb_paths_by_import_fingerprint(profile_loose["import_fingerprint"])

    if strict_matches:
        idaapi.msg("Strong (strict import fingerprint):\n")
        for path in strict_matches:
            idaapi.msg(f"  - {path}\n")
    elif loose_matches:
        idaapi.msg("Strong (loose import fingerprint):\n")
        for path in loose_matches:
            idaapi.msg(f"  - {path}\n")

    import_matches = kb_paths_by_import_func_norms(
        profile_strict["import_func_norms"][:KB_LIMIT_MAX_QUERY_IMPORT_FUNCS]
    )
    section_matches = kb_paths_by_section_norms(
        profile_strict["section_norms"][:KB_LIMIT_MAX_QUERY_SECTIONS]
    )

    if import_matches:
        idaapi.msg("\nMedium (import overlap):\n")
        for path in import_matches:
            idaapi.msg(f"  - {path}\n")

    if section_matches:
        idaapi.msg("\nMedium (section overlap):\n")
        for path in section_matches:
            idaapi.msg(f"  - {path}\n")

```

`spotlight_kb_index.py`:

```py
# SPDX-License-Identifier: Apache-2.0
"""
IDA Spotlight KB Indexer.

This standalone script indexes IDB/I64 files into a SQLite knowledge base
for cross-sample correlation and function recall.

Usage:
    idat -A -S"spotlight_kb_index.py --idb-dir=/path/to/idbs" dummy.idb
"""

import argparse
import glob
import math
import os
import sqlite3
import sys
import time
from typing import List, Pattern, Set

import idapro
import ida_bytes
import ida_funcs
import ida_nalt
import ida_segment
import idautils

from spotlight_config import (
    load_config,
    default_kb_db_path,
)
from spotlight_utils import (
    fingerprint_md5,
    build_import_items,
    normalize_name,
    normalize_dll_name,
    is_filtered_func,
    collect_import_modules,
    iter_segments,
)


# Load configuration
_BASE_DIR: str = os.path.dirname(__file__)
_, _CONFIG = load_config(_BASE_DIR)

_IGNORED_FUNCTIONS: List[Pattern[str]] = _CONFIG["ignored_functions"]
_IGNORED_SECTIONS: Set[str] = _CONFIG["ignored_sections"]
_IGNORED_DLLS: Set[str] = _CONFIG["ignored_dlls"]


# ----------------------------------------------------------------------
# SQLite schema
# ----------------------------------------------------------------------

_SCHEMA_SQL = """
PRAGMA journal_mode=WAL;
PRAGMA synchronous=NORMAL;
PRAGMA foreign_keys=ON;

CREATE TABLE IF NOT EXISTS idb (
  id INTEGER PRIMARY KEY,
  path TEXT UNIQUE,
  mtime INTEGER,
  indexed_at INTEGER,
  import_fingerprint TEXT
);

CREATE TABLE IF NOT EXISTS func (
  id INTEGER PRIMARY KEY,
  idb_id INTEGER,
  name_raw TEXT,
  name_norm TEXT,
  ea INTEGER,
  FOREIGN KEY(idb_id) REFERENCES idb(id)
);

CREATE TABLE IF NOT EXISTS feat_import_dll (
  id INTEGER PRIMARY KEY,
  idb_id INTEGER,
  name_raw TEXT,
  name_norm TEXT,
  UNIQUE(idb_id, name_norm),
  FOREIGN KEY(idb_id) REFERENCES idb(id)
);

CREATE TABLE IF NOT EXISTS feat_import_func (
  id INTEGER PRIMARY KEY,
  idb_id INTEGER,
  import_dll_id INTEGER,
  func_raw TEXT,
  func_norm TEXT,
  FOREIGN KEY(idb_id) REFERENCES idb(id),
  FOREIGN KEY(import_dll_id) REFERENCES feat_import_dll(id)
);

CREATE TABLE IF NOT EXISTS feat_section (
  id INTEGER PRIMARY KEY,
  idb_id INTEGER,
  name_raw TEXT,
  name_norm TEXT,
  entropy REAL,
  FOREIGN KEY(idb_id) REFERENCES idb(id)
);

CREATE INDEX IF NOT EXISTS idx_func_norm ON func(name_norm);
CREATE INDEX IF NOT EXISTS idx_import_dll_norm ON feat_import_dll(name_norm);
CREATE INDEX IF NOT EXISTS idx_import_func_norm ON feat_import_func(func_norm);
CREATE INDEX IF NOT EXISTS idx_section_norm ON feat_section(name_norm);
"""


# ----------------------------------------------------------------------
# Database Helpers
# ----------------------------------------------------------------------

def _db_connect(path: str) -> sqlite3.Connection:
    """
    Create a database connection.

    Args:
        path: Path to the SQLite database.

    Returns:
        A SQLite connection with foreign keys enabled.
    """
    connection = sqlite3.connect(path)
    connection.execute("PRAGMA foreign_keys=ON;")
    return connection


def _db_init(connection: sqlite3.Connection) -> None:
    """
    Initialize the database schema.

    Args:
        connection: The database connection.
    """
    connection.executescript(_SCHEMA_SQL)
    connection.commit()


def _upsert_idb(connection: sqlite3.Connection, idb_path: str) -> int:
    """
    Insert or update an IDB record.

    Args:
        connection: The database connection.
        idb_path: Path to the IDB file.

    Returns:
        The IDB record ID.
    """
    mtime = int(os.path.getmtime(idb_path))
    now = int(time.time())
    connection.execute(
        """
        INSERT INTO idb(path, mtime, indexed_at)
        VALUES(?,?,?)
        ON CONFLICT(path)
        DO UPDATE SET mtime=excluded.mtime, indexed_at=excluded.indexed_at
        """,
        (idb_path, mtime, now),
    )
    return connection.execute(
        "SELECT id FROM idb WHERE path=?", (idb_path,)
    ).fetchone()[0]


def _clear_idb_rows(connection: sqlite3.Connection, idb_id: int) -> None:
    """
    Clear all feature rows for an IDB.

    Args:
        connection: The database connection.
        idb_id: The IDB record ID.
    """
    for table in ("func", "feat_import_func", "feat_import_dll", "feat_section"):
        connection.execute(f"DELETE FROM {table} WHERE idb_id=?", (idb_id,))


def _segment_entropy(start: int, end: int, limit: int = 1_000_000) -> float:
    """
    Calculate the entropy of a segment.

    Args:
        start: Segment start address.
        end: Segment end address.
        limit: Maximum bytes to analyze.

    Returns:
        The entropy value (0.0 to 8.0).
    """
    size = max(0, end - start)
    if size <= 0:
        return 0.0
    data = ida_bytes.get_bytes(start, min(size, limit)) or b""
    if not data:
        return 0.0
    freq = [0] * 256
    for byte in data:
        freq[byte] += 1
    entropy = 0.0
    data_len = len(data)
    for count in freq:
        if count:
            prob = count / data_len
            entropy -= prob * math.log(prob, 2)
    return entropy


def _iter_idbs(root: str) -> List[str]:
    """
    Iterate over all IDB/I64 files in a directory tree.

    Args:
        root: The root directory to search.

    Returns:
        A list of IDB file paths.
    """
    results: List[str] = []
    for pattern in ("**/*.idb", "**/*.i64"):
        for path in glob.glob(os.path.join(root, pattern), recursive=True):
            if os.path.isfile(path):
                results.append(path)
    return results


# ----------------------------------------------------------------------
# Indexing Logic
# ----------------------------------------------------------------------

def _index_current_idb(
    connection: sqlite3.Connection,
    idb_path: str,
    keep_auto_named_funcs: bool,
    keep_library_funcs: bool,
    keep_common_sections: bool,
    keep_common_imports: bool,
) -> None:
    """
    Index the currently open IDB into the database.

    Args:
        connection: The database connection.
        idb_path: Path to the IDB file.
        keep_auto_named_funcs: Whether to keep auto-named functions.
        keep_library_funcs: Whether to keep library functions.
        keep_common_sections: Whether to keep common sections.
        keep_common_imports: Whether to keep common imports.
    """
    idb_id = _upsert_idb(connection, idb_path)

    with connection:
        _clear_idb_rows(connection, idb_id)

        # ---------------- Functions ----------------
        for func_ea in idautils.Functions():
            func = ida_funcs.get_func(func_ea)
            if not func:
                continue

            if not keep_library_funcs and (func.flags & ida_funcs.FUNC_LIB):
                continue

            name_raw = ida_funcs.get_func_name(func_ea)
            if not name_raw:
                continue

            if not keep_auto_named_funcs and is_filtered_func(name_raw, _IGNORED_FUNCTIONS):
                continue

            connection.execute(
                "INSERT INTO func(idb_id, name_raw, name_norm, ea) VALUES(?,?,?,?)",
                (idb_id, name_raw, normalize_name(name_raw), int(func_ea)),
            )

        # ---------------- Imports ----------------
        import_modules = collect_import_modules()

        import_items = build_import_items(
            import_modules=import_modules,
            common_import_dlls=_IGNORED_DLLS,
            keep_common_imports=keep_common_imports,
        )

        import_fingerprint = fingerprint_md5(import_items)

        connection.execute(
            "UPDATE idb SET import_fingerprint=? WHERE id=?",
            (import_fingerprint, idb_id),
        )

        for dll_raw, entries in import_modules:
            dll_norm = normalize_dll_name(dll_raw)
            if not dll_norm:
                continue

            if not keep_common_imports and dll_norm in _IGNORED_DLLS:
                continue

            connection.execute(
                """
                INSERT INTO feat_import_dll(idb_id, name_raw, name_norm)
                VALUES(?,?,?)
                ON CONFLICT(idb_id, name_norm) DO NOTHING
                """,
                (idb_id, dll_raw, dll_norm),
            )

            dll_id = connection.execute(
                "SELECT id FROM feat_import_dll WHERE idb_id=? AND name_norm=?",
                (idb_id, dll_norm),
            ).fetchone()[0]

            for name, ordinal in entries:
                if name:
                    func_raw = str(name)
                    func_norm = normalize_name(func_raw)
                elif ordinal is not None:
                    func_raw = f"ord{int(ordinal)}"
                    func_norm = normalize_name(func_raw)
                else:
                    continue

                connection.execute(
                    """
                    INSERT INTO feat_import_func(idb_id, import_dll_id, func_raw, func_norm)
                    VALUES(?,?,?,?)
                    """,
                    (idb_id, dll_id, func_raw, func_norm),
                )

        # ---------------- Sections ----------------
        for name_raw, name_norm, start_ea, end_ea in iter_segments(
            _IGNORED_SECTIONS, keep_common_sections
        ):
            connection.execute(
                """
                INSERT INTO feat_section(idb_id, name_raw, name_norm, entropy)
                VALUES(?,?,?,?)
                """,
                (idb_id, name_raw, name_norm, _segment_entropy(start_ea, end_ea)),
            )


# ----------------------------------------------------------------------
# Main
# ----------------------------------------------------------------------

def main() -> None:
    """Main entry point for the KB indexer."""
    print("Using Python:", sys.executable)

    parser = argparse.ArgumentParser(
        description="IDA Spotlight KB indexer"
    )

    parser.add_argument("--idb-dir", required=True, help="Directory containing IDB files")
    parser.add_argument("--db", default=None, help="Path to KB database")
    parser.add_argument("--limit", type=int, default=0, help="Limit number of IDBs to index")
    parser.add_argument("--keep-auto-named-funcs", action="store_true", help="Keep auto-named functions")
    parser.add_argument("--keep-library-funcs", action="store_true", help="Keep library functions")
    parser.add_argument("--keep-common-sections", action="store_true", help="Keep common sections")
    parser.add_argument("--keep-common-imports", action="store_true", help="Keep common imports")

    args = parser.parse_args()

    db_path = args.db if args.db else default_kb_db_path()
    print("KB database:", db_path)

    with _db_connect(db_path) as connection:
        _db_init(connection)
        idbs = _iter_idbs(args.idb_dir)

        if not idbs:
            print("No IDB/I64 files found in:", args.idb_dir)
            return

        if args.limit:
            idbs = idbs[: args.limit]

        total = len(idbs)
        for index, idb_path in enumerate(idbs, 1):
            print(f"[{index}/{total}] Indexing {idb_path}")
            try:
                idapro.open_database(idb_path, True)
                _index_current_idb(
                    connection,
                    idb_path,
                    keep_auto_named_funcs=args.keep_auto_named_funcs,
                    keep_library_funcs=args.keep_library_funcs,
                    keep_common_sections=args.keep_common_sections,
                    keep_common_imports=args.keep_common_imports,
                )
            except Exception as e:
                print(f"[!] Failed to index {idb_path}: {e}")
            finally:
                try:
                    idapro.close_database()
                except Exception:
                    pass

    print("Spotlight KB indexing complete")


if __name__ == "__main__":
    main()

```

`spotlight_scanner.py`:

```py
# SPDX-License-Identifier: Apache-2.0
"""
Function scanning and scoring logic for IDA Spotlight.

This module contains the core analysis logic including:
- Function call and string extraction
- Base scoring against signal patterns
- Context bonus calculation
- Priority tier computation
- Inspector rendering
"""

import math
import time
from typing import Any, Callable, Dict, List, Optional

import idaapi
import idautils
import ida_funcs
import ida_name
import ida_ua
import ida_lines
import ida_bytes
import idc

from PySide6 import QtCore

from spotlight_utils import fmt_ea, safe_regex_search, sanitize_operand_name, is_filtered_func
from spotlight_config import (
    SIGNALS,
    IGNORED_FUNCTIONS,
    CONTEXT_BONUS_FACTOR,
    LIBRARY_SCORE_PENALTY,
    KB_LIMIT_NAME_RECALL,
    KB_LIMIT_CALLEE_RECALL_PER_CALLEE,
    KB_LIMIT_CALLEE_RECALL_MAX_CALLEES,
)
from spotlight_kb import (
    kb_db_ready,
    kb_db_path,
    kb_db_diagnose,
    kb_paths_for_function_name_raw,
)


__all__ = [
    # Global context
    "SpotlightContext",
    "CTX",
    # Extraction
    "extract_calls",
    "extract_strings_by_xrefs",
    # Result helpers
    "init_func_result",
    "add_reason",
    "top_reason_str",
    "categories_str",
    # Scoring
    "score_function_base",
    "apply_library_penalty",
    "apply_context_bonus",
    # Priority tiers
    "PRIORITY_CRITICAL_PERCENT",
    "PRIORITY_HIGH_PERCENT",
    "compute_priority_tiers",
    # Inspector rendering
    "render_inspector",
    "render_function_recall",
    # Scanner
    "ChunkedScanner",
]


# ----------------------------------------------------------------------
# Constants
# ----------------------------------------------------------------------

# Minimum score threshold for context bonus
CONTEXT_BONUS_THRESHOLD: float = 4.0

# Priority tier percentages
PRIORITY_CRITICAL_PERCENT: float = 0.10
PRIORITY_HIGH_PERCENT: float = 0.30


# ----------------------------------------------------------------------
# Global Scanning Context
# ----------------------------------------------------------------------

class SpotlightContext:
    """
    Global context for storing scanning results and configuration.

    Attributes:
        signals: The signal patterns loaded from configuration.
        categories: Sorted list of signal category names.
        results: Dictionary mapping function EAs to their analysis results.
        last_scan_seconds: Time taken by the last scan operation.
    """

    def __init__(self) -> None:
        """Initialize the context with empty values."""
        self.signals: Dict[str, Dict[str, Dict[str, float]]] = {}
        self.categories: List[str] = []
        self.results: Dict[int, Dict[str, Any]] = {}
        self.last_scan_seconds: float = 0.0


# Global context instance
CTX = SpotlightContext()
CTX.signals = SIGNALS
CTX.categories = sorted(SIGNALS.keys())


# ----------------------------------------------------------------------
# Extraction Functions
# ----------------------------------------------------------------------

def extract_calls(func_start_ea: int) -> List[str]:
    """
    Extract all function calls from a function.

    Args:
        func_start_ea: The start address of the function.

    Returns:
        A list of callee names.
    """
    calls: List[str] = []
    for insn_ea in idautils.FuncItems(int(func_start_ea)):
        if not idaapi.is_call_insn(insn_ea):
            continue

        insn = ida_ua.insn_t()
        if not ida_ua.decode_insn(insn, insn_ea):
            continue

        try:
            target = int(idc.get_operand_value(insn_ea, 0))
        except Exception:
            target = 0

        name = ida_name.get_name(target) if target else ""
        if not name or name.startswith("?"):
            operand = ida_ua.print_operand(insn_ea, 0)
            name = ida_lines.tag_remove(operand) if operand else ""

        name = sanitize_operand_name(name)

        if name:
            calls.append(name)

    return calls


def extract_strings_by_xrefs(func_start_ea: int) -> List[str]:
    """
    Extract all strings referenced by a function via cross-references.

    Args:
        func_start_ea: The start address of the function.

    Returns:
        A list of string literals referenced by the function.
    """
    strings: set[str] = set()
    func = ida_funcs.get_func(int(func_start_ea))
    if not func:
        return []

    for insn_ea in idautils.FuncItems(int(func.start_ea)):
        try:
            refs = idautils.DataRefsFrom(insn_ea)
        except Exception:
            continue

        for ref in refs:
            try:
                if not ida_bytes.is_strlit(ida_bytes.get_full_flags(ref)):
                    continue
                raw = ida_bytes.get_strlit_contents(ref)
                if raw:
                    strings.add(raw.decode(errors="ignore"))
            except Exception:
                continue

    return list(strings)


# ----------------------------------------------------------------------
# Result Helpers
# ----------------------------------------------------------------------

def init_func_result(start_ea: int, name: str, length: int) -> Dict[str, Any]:
    """
    Initialize a function analysis result dictionary.

    Args:
        start_ea: The function start address.
        name: The function name.
        length: The function length in bytes.

    Returns:
        A dictionary with initialized result fields.
    """
    return {
        "ea": int(start_ea),
        "name": name or f"sub_{int(start_ea):x}",
        "length": int(length),
        "is_library": False,
        "base_score": 0.0,
        "context_bonus": 0.0,
        "final_score": 0.0,
        "category_hits": {category: 0 for category in CTX.categories},
        "reasons": [],
    }


def add_reason(result: Dict[str, Any], category: str, text: str, weight: float) -> None:
    """
    Add a scoring reason to a function result.

    Args:
        result: The function result dictionary.
        category: The category name.
        text: The descriptive text for the reason.
        weight: The score contribution.
    """
    result["reasons"].append({
        "category": category,
        "text": text,
        "weight": float(weight),
    })


def top_reason_str(result: Dict[str, Any]) -> str:
    """
    Get the highest-weighted reason as a string.

    Args:
        result: The function result dictionary.

    Returns:
        The text of the top reason, or empty string.
    """
    reasons = result.get("reasons", [])
    if not reasons:
        return ""
    try:
        top = max(reasons, key=lambda x: float(x.get("weight", 0.0)))
        return top.get("text", "")
    except Exception:
        return ""


def categories_str(result: Dict[str, Any]) -> str:
    """
    Get a comma-separated string of hit categories.

    Args:
        result: The function result dictionary.

    Returns:
        A sorted, comma-separated list of category names with hits.
    """
    categories = [key for key, value in result.get("category_hits", {}).items() if value]
    categories.sort()
    return ", ".join(categories)


# ----------------------------------------------------------------------
# Scoring Functions
# ----------------------------------------------------------------------

def score_function_base(
    result: Dict[str, Any],
    calls: List[str],
    strings: List[str],
) -> None:
    """
    Calculate the base score for a function based on calls and strings.

    Matches calls and strings against the configured signal patterns
    and updates the result dictionary with scores and reasons.

    Args:
        result: The function result dictionary (modified in place).
        calls: List of function calls.
        strings: List of string references.
    """
    # Score function calls
    for category, rules in CTX.signals.items():
        function_map = rules.get("functions", {})
        for call in calls:
            if call in function_map:
                weight = function_map[call]
                result["base_score"] += weight
                result["category_hits"][category] += 1
                add_reason(result, category, f"Calls {call}", weight)

    # Score string references
    for category, rules in CTX.signals.items():
        string_map = rules.get("strings", {})
        for string in strings:
            for pattern, weight in string_map.items():
                if safe_regex_search(pattern, string):
                    result["base_score"] += weight
                    result["category_hits"][category] += 1
                    add_reason(result, category, f"String matches /{pattern}/", weight)

    result["final_score"] = result["base_score"]


def apply_library_penalty(result: Dict[str, Any]) -> None:
    """
    Apply a score penalty to library functions.

    Args:
        result: The function result dictionary (modified in place).
    """
    if not result.get("is_library"):
        return
    penalty = float(LIBRARY_SCORE_PENALTY)
    result["base_score"] -= penalty
    result["final_score"] -= penalty
    add_reason(result, "Library", "Library function penalty", -penalty)


def apply_context_bonus(results: Dict[int, Dict[str, Any]]) -> None:
    """
    Apply context bonuses based on calls to high-scoring functions.

    Functions that call high-scoring functions receive a bonus
    proportional to the callee's score.

    Args:
        results: Dictionary of all function results (modified in place).
    """
    base_scores = {ea: r["base_score"] for ea, r in results.items()}

    for ea, result in results.items():
        best_score = 0.0
        best_ea: Optional[int] = None

        for insn_ea in idautils.FuncItems(int(ea)):
            if not idaapi.is_call_insn(insn_ea):
                continue

            try:
                target = int(idc.get_operand_value(insn_ea, 0))
            except Exception:
                target = 0

            callee = ida_funcs.get_func(target) if target else None
            if not callee:
                continue

            score = base_scores.get(int(callee.start_ea), 0.0)
            if score > best_score:
                best_score = score
                best_ea = int(callee.start_ea)

        if best_score >= CONTEXT_BONUS_THRESHOLD and best_ea is not None:
            bonus = best_score * float(CONTEXT_BONUS_FACTOR)
            result["context_bonus"] = bonus
            result["final_score"] += bonus
            callee_name = ida_funcs.get_func_name(best_ea)
            add_reason(result, "Context", f"Adjacent to {callee_name}", bonus)


# ----------------------------------------------------------------------
# Priority Tiers
# ----------------------------------------------------------------------

def compute_priority_tiers(rows_sorted: List[Dict[str, Any]]) -> Dict[int, str]:
    """
    Compute priority tiers for functions based on their scores.

    Assigns critical/high/medium tiers to functions with positive scores.

    Args:
        rows_sorted: List of function results, sorted by score descending.

    Returns:
        A dictionary mapping function EAs to priority tier names.
    """
    tiers: Dict[int, str] = {}
    positives = [
        r for r in rows_sorted
        if float(r.get("final_score", 0.0)) > 0.0 and not r.get("is_library", False)
    ]
    if not positives:
        return tiers

    total = len(positives)
    critical_count = max(1, int(math.ceil(PRIORITY_CRITICAL_PERCENT * total)))
    high_count = max(1, int(math.ceil(PRIORITY_HIGH_PERCENT * total)))

    critical_count = min(critical_count, total)
    high_count = min(max(high_count, critical_count), total)

    for index, result in enumerate(positives):
        ea = int(result["ea"])
        if index < critical_count:
            tiers[ea] = "critical"
        elif index < high_count:
            tiers[ea] = "high"
        else:
            tiers[ea] = "medium"

    return tiers


# ----------------------------------------------------------------------
# Inspector Rendering
# ----------------------------------------------------------------------

def render_inspector(result: Dict[str, Any], priority_name: Optional[str] = None) -> str:
    """
    Render the inspector panel content for a function.

    Args:
        result: The function result dictionary.
        priority_name: Optional priority tier name.

    Returns:
        A formatted string for display in the inspector panel.
    """
    lines: List[str] = []
    lines.append(f"Function: {result.get('name', '')}")
    lines.append(f"Start: {fmt_ea(result.get('ea', 0))}")

    length = int(result.get("length", 0))
    lines.append(f"Length: {hex(length)} ({length})")
    lines.append(f"Library: {'yes' if result.get('is_library') else 'no'}")

    if priority_name is not None:
        lines.append(f"Priority: {priority_name}")
    lines.append("")

    lines.append(f"Base score: {float(result.get('base_score', 0.0)):.2f}")
    lines.append(f"Context bonus: {float(result.get('context_bonus', 0.0)):.2f}")
    lines.append(f"Final score: {float(result.get('final_score', 0.0)):.2f}")
    lines.append("")

    # Display reasons for the score
    lines.append("Reasons:")
    reasons = result.get("reasons", [])
    if not reasons:
        lines.append("  (none)")
    else:
        for reason in sorted(reasons, key=lambda x: float(x.get("weight", 0.0)), reverse=True):
            category = reason.get("category", "")
            text = reason.get("text", "")
            weight = float(reason.get("weight", 0.0))
            lines.append(f"  - [{category}] {text}: {weight:+.2f}")
    lines.append("")

    calls = result.get("calls", [])
    recall = render_function_recall(result["name"], calls)

    if recall:
        lines.append(recall)
        lines.append("")

    return "\n".join(lines)


def render_function_recall(func_name: str, calls: List[str]) -> str:
    """
    Render KB recall information for a function.

    Shows which other IDBs contain similar function names or callees.

    Args:
        func_name: The function name.
        calls: List of callee names.

    Returns:
        A formatted string showing KB recall matches.
    """
    lines: List[str] = []

    if not kb_db_ready():
        reason = kb_db_diagnose(kb_db_path())
        lines.append("KB not ready")
        if reason:
            lines.append(f"Reason: {reason}")
        lines.append(f"Path: {kb_db_path()}")
        return "\n".join(lines)

    # Function name recall
    func_paths = kb_paths_for_function_name_raw(func_name)
    if func_paths:
        lines.append("Function name recall:")
        for path in func_paths[:KB_LIMIT_NAME_RECALL]:
            lines.append(f"- {path}")

    # Callee recall - deduplicate and filter
    unique_callees: List[str] = []
    seen: set[str] = set()
    for callee in calls:
        if not callee or is_filtered_func(callee, IGNORED_FUNCTIONS):
            continue
        callee_lower = callee.lower()
        if callee_lower in seen:
            continue
        seen.add(callee_lower)
        unique_callees.append(callee)

    if unique_callees:
        lines.append("Callee recall:")
        for callee in unique_callees[:KB_LIMIT_CALLEE_RECALL_MAX_CALLEES]:
            paths = kb_paths_for_function_name_raw(callee)
            if not paths:
                continue
            lines.append(f"- {callee}:")
            for path in paths[:KB_LIMIT_CALLEE_RECALL_PER_CALLEE]:
                lines.append(f"  - {path}")
        lines.append("")

    return "\n".join(lines)


# ----------------------------------------------------------------------
# Chunked Scanner
# ----------------------------------------------------------------------

class ChunkedScanner(QtCore.QObject):
    """
    A Qt-based scanner that processes functions in chunks.

    This allows the UI to remain responsive during scanning by
    processing functions in batches with timer-based scheduling.

    Signals:
        progress: Emits progress percentage (0-100).
        finished: Emits an error string (empty on success).
    """

    progress = QtCore.Signal(int)
    finished = QtCore.Signal(str)

    def __init__(self, chunk_size: int = 100) -> None:
        """
        Initialize the scanner.

        Args:
            chunk_size: Number of functions to process per tick.
        """
        super().__init__()
        self._chunk_size = int(chunk_size)
        self._funcs: List[int] = list(idautils.Functions())
        self._total = len(self._funcs)
        self._index = 0
        self._results: Dict[int, Dict[str, Any]] = {}
        self._timer = QtCore.QTimer()
        self._timer.timeout.connect(self._tick)
        self._start_time = 0.0

    def start(self) -> None:
        """Start the scanning process."""
        self._index = 0
        self._results = {}
        self._start_time = time.time()
        self.progress.emit(0)
        self._timer.start(1)

    def _tick(self) -> None:
        """Process one chunk of functions."""
        try:
            if self._total <= 0:
                self._finish_scan()
                return

            processed = 0
            while processed < self._chunk_size and self._index < self._total:
                ea = self._funcs[self._index]
                self._index += 1
                processed += 1

                func = ida_funcs.get_func(ea)
                if not func:
                    continue

                start = int(func.start_ea)
                end = int(func.end_ea)
                length = max(0, end - start)
                name = (
                    ida_funcs.get_func_name(start)
                    or ida_name.get_name(start)
                    or f"sub_{start:x}"
                )

                result = init_func_result(start, name, length)

                # Check library flag
                try:
                    flags = idc.get_func_flags(start)
                    if flags & ida_funcs.FUNC_LIB:
                        result["is_library"] = True
                except Exception:
                    pass

                # Score the function
                try:
                    calls = extract_calls(start)
                    result["calls"] = calls
                    strings = extract_strings_by_xrefs(start)
                    score_function_base(result, calls, strings)
                    apply_library_penalty(result)
                except Exception as e:
                    add_reason(result, "Error", f"Scan error: {e}", 0.0)

                self._results[start] = result

            if self._index < self._total:
                percent = int((self._index * 100) / self._total)
                self.progress.emit(min(percent, 99))
                return

            self._finish_scan()

        except Exception as fatal:
            self._timer.stop()
            idaapi.msg(f"[IDA Spotlight] Fatal scan error: {fatal}\n")
            self.progress.emit(100)
            self.finished.emit(str(fatal))

    def _finish_scan(self) -> None:
        """Finalize the scan and emit results."""
        self._timer.stop()

        if self._total > 0:
            try:
                apply_context_bonus(self._results)
            except Exception as e:
                idaapi.msg(f"[IDA Spotlight] Context bonus failed: {e}\n")

        CTX.results = self._results
        CTX.last_scan_seconds = time.time() - self._start_time
        self.progress.emit(100)
        self.finished.emit("")
```

`spotlight_ui.py`:

```py
# SPDX-License-Identifier: Apache-2.0
"""
UI components for IDA Spotlight.

This module contains all UI-related classes including:
- SpotlightInspectForm: The quick inspector panel
- SpotlightViewForm: The main results view
- SpotlightKBSettingsDialog: KB configuration dialog
- SpotlightTableWidget: Custom table with Enter key handling
- Priority colors and helpers
"""

import csv
import json
from typing import Any, Callable, Dict, List, Optional

import ida_kernwin

from PySide6 import QtCore, QtGui, QtWidgets

from spotlight_utils import (
    qt_alive,
    fmt_ea,
    widget_title,
    find_code_widget_by_title,
    func_start_from_any_ea,
)
from spotlight_config import (
    kb_get_setting,
    kb_set_setting,
    kb_db_path,
    default_kb_db_path,
)
from spotlight_scanner import (
    CTX,
    ChunkedScanner,
    compute_priority_tiers,
    render_inspector,
    top_reason_str,
    categories_str,
)
from spotlight_kb import log_kb_sample_correlation


__all__ = [
    # Colors
    "priority_color",
    # Dialogs
    "SpotlightKBSettingsDialog",
    # Widgets
    "SpotlightTableWidget",
    # Forms
    "SpotlightInspectForm",
    "SpotlightViewForm",
]


# ----------------------------------------------------------------------
# Priority Colors
# ----------------------------------------------------------------------

# Priority color mapping
_PRIORITY_COLORS: Dict[str, QtGui.QColor] = {
    "critical": QtGui.QColor(255, 90, 90),
    "high": QtGui.QColor(255, 170, 70),
    "medium": QtGui.QColor(255, 235, 120),
}


def priority_color(priority: str) -> Optional[QtGui.QColor]:
    """
    Get the background color for a priority tier.

    Args:
        priority: One of "critical", "high", "medium", or "low".

    Returns:
        A QColor for the tier, or None for "low" priority.
    """
    return _PRIORITY_COLORS.get(priority)


# ----------------------------------------------------------------------
# KB Settings Dialog
# ----------------------------------------------------------------------

class SpotlightKBSettingsDialog(QtWidgets.QDialog):
    """Dialog for configuring KB database path."""

    def __init__(self, parent: Optional[QtWidgets.QWidget] = None) -> None:
        """
        Initialize the KB settings dialog.

        Args:
            parent: Optional parent widget.
        """
        super().__init__(parent)
        self.setWindowTitle("IDA Spotlight â€“ KB Settings")
        self.setMinimumWidth(650)

        # Load current path (empty => default)
        current_path = kb_get_setting("db_path", "").strip()
        self._db_edit = QtWidgets.QLineEdit(current_path)
        self._db_edit.setPlaceholderText(default_kb_db_path())

        form_layout = QtWidgets.QFormLayout()
        form_layout.addRow("KB database (SQLite):", self._db_edit)

        btn_ok = QtWidgets.QPushButton("OK")
        btn_ok.clicked.connect(self.accept)

        btn_cancel = QtWidgets.QPushButton("Cancel")
        btn_cancel.clicked.connect(self.reject)

        button_layout = QtWidgets.QHBoxLayout()
        button_layout.addStretch()
        button_layout.addWidget(btn_ok)
        button_layout.addWidget(btn_cancel)

        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.addLayout(form_layout)
        main_layout.addLayout(button_layout)

    def accept(self) -> None:
        """Save the KB path setting and close."""
        kb_set_setting("db_path", self._db_edit.text().strip())
        super().accept()


# ----------------------------------------------------------------------
# Custom Table Widget
# ----------------------------------------------------------------------

class SpotlightTableWidget(QtWidgets.QTableWidget):
    """Table widget with custom Enter key handling."""

    enter_pressed = QtCore.Signal()

    def keyPressEvent(self, event: QtGui.QKeyEvent) -> None:
        """
        Handle key press events, emitting signal on Enter/Return.

        Args:
            event: The key press event.
        """
        if event.key() in (QtCore.Qt.Key_Return, QtCore.Qt.Key_Enter):
            self.enter_pressed.emit()
            return
        super().keyPressEvent(event)


# ----------------------------------------------------------------------
# Inspect Form
# ----------------------------------------------------------------------

class SpotlightInspectForm(ida_kernwin.PluginForm):
    """
    Quick inspector panel for viewing function details.

    Can be synced to code views to automatically update
    when the cursor moves to different functions.

    Attributes:
        on_close_callback: Optional callback invoked when form closes.
    """

    # Callback to notify when form closes (set externally to avoid circular imports)
    on_close_callback: Optional[Callable[[], None]] = None

    def __init__(self) -> None:
        """Initialize the inspect form."""
        super().__init__()
        self._sync_titles: List[str] = []
        self._pinned: bool = False
        self._history: List[int] = []
        self._hist_idx: int = -1

        self._widget: Optional[QtWidgets.QWidget] = None
        self._header: Optional[QtWidgets.QLabel] = None
        self.inspector: Optional[QtWidgets.QPlainTextEdit] = None
        self._last_func_start: Optional[int] = None

    def OnCreate(self, form: object) -> None:
        """
        Initialize the UI components.

        Args:
            form: The IDA form handle.
        """
        self._widget = self.FormToPyQtWidget(form)
        layout = QtWidgets.QVBoxLayout(self._widget)

        self._header = QtWidgets.QLabel("Not synced")
        font = self._header.font()
        font.setBold(True)
        self._header.setFont(font)
        layout.addWidget(self._header)

        self.inspector = QtWidgets.QPlainTextEdit()
        self.inspector.setReadOnly(True)
        self.inspector.setPlainText(
            "Use context menu in IDA View / Pseudocode to sync.\n"
        )
        layout.addWidget(self.inspector, 1)

        self.inspector.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.inspector.customContextMenuRequested.connect(self._open_menu)

        self._update_header()

    def OnClose(self, form: object) -> None:
        """
        Clean up when form closes.

        Args:
            form: The IDA form handle.
        """
        self._sync_titles = []
        self._history = []
        self._hist_idx = -1
        self._header = None
        self.inspector = None
        self._widget = None
        # Notify callback to clear global reference
        if SpotlightInspectForm.on_close_callback is not None:
            SpotlightInspectForm.on_close_callback()

    def _update_header(self) -> None:
        """Update the header label text."""
        if self._header is None:
            return
        if not self._sync_titles:
            status = "Not synced"
        else:
            status = "Synced: " + ", ".join(self._sync_titles)
        if self._pinned:
            status += " (Pinned)"
        self._header.setText(status)

    def sync_with_titles(self, titles: List[str]) -> None:
        """
        Sync the inspector with the specified view titles.

        Args:
            titles: List of view titles to sync with.
        """
        titles = [t for t in titles if t]

        # Verify at least one valid code widget exists
        found_valid = False
        for title in titles:
            if find_code_widget_by_title(title) is not None:
                found_valid = True
                break

        if not found_valid:
            ida_kernwin.warning("No matching code widgets found to sync.")
            return

        self._sync_titles = titles
        self._update_header()

        ea = ida_kernwin.get_screen_ea()
        self.update_for_ea(int(ea), push_history=True)

    def unsync(self) -> None:
        """Remove sync association."""
        self._sync_titles = []
        self._update_header()

    def toggle_pin(self) -> None:
        """Toggle the pinned state."""
        self._pinned = not self._pinned
        self._update_header()

    def history_back(self) -> None:
        """Navigate back in history."""
        if self._hist_idx > 0:
            self._hist_idx -= 1
            ea = self._history[self._hist_idx]
            self.update_for_ea(ea, push_history=False)

    def history_forward(self) -> None:
        """Navigate forward in history."""
        if self._hist_idx + 1 < len(self._history):
            self._hist_idx += 1
            ea = self._history[self._hist_idx]
            self.update_for_ea(ea, push_history=False)

    def _open_menu(self, pos: QtCore.QPoint) -> None:
        """
        Show the context menu.

        Args:
            pos: The position where the menu was requested.
        """
        menu = QtWidgets.QMenu(self.inspector)

        act_unsync = QtGui.QAction("Unsync", self.inspector)
        act_unsync.triggered.connect(self.unsync)
        menu.addAction(act_unsync)

        menu.addSeparator()

        act_pin = QtGui.QAction("Pin / Unpin", self.inspector)
        act_pin.triggered.connect(self.toggle_pin)
        menu.addAction(act_pin)

        menu.addSeparator()

        act_back = QtGui.QAction("Back", self.inspector)
        act_back.triggered.connect(self.history_back)
        menu.addAction(act_back)

        act_fwd = QtGui.QAction("Forward", self.inspector)
        act_fwd.triggered.connect(self.history_forward)
        menu.addAction(act_fwd)

        menu.exec_(self.inspector.mapToGlobal(pos))

    def on_screen_ea_changed(self, title: str, ea: int) -> None:
        """
        Handle screen EA change events.

        Called by UI hooks when the cursor moves in a synced view.

        Args:
            title: The view title where the change occurred.
            ea: The new cursor address.
        """
        if self._pinned:
            return
        if title not in self._sync_titles:
            return
        self.update_for_ea(ea, push_history=True)

    def _push_history(self, start_ea: int) -> None:
        """
        Add an address to the navigation history.

        Args:
            start_ea: The function start address to add.
        """
        if (
            self._hist_idx >= 0
            and self._history
            and self._history[self._hist_idx] == start_ea
        ):
            return
        if self._hist_idx < len(self._history) - 1:
            self._history = self._history[: self._hist_idx + 1]
        self._history.append(start_ea)
        self._hist_idx = len(self._history) - 1

    def update_for_ea(self, ea: int, push_history: bool) -> None:
        """
        Update the inspector for a given address.

        Args:
            ea: The address to inspect.
            push_history: Whether to add to navigation history.
        """
        if not qt_alive(self.inspector):
            return

        start = func_start_from_any_ea(ea)
        if start is None:
            self.inspector.setPlainText("No function at cursor.")
            return

        if self._last_func_start == start and push_history:
            return
        self._last_func_start = start

        result = CTX.results.get(start)
        if not result:
            self.inspector.setPlainText(
                f"Function {fmt_ea(start)} not scored.\nRun Scan in IDA Spotlight View."
            )
            return

        rows_all = sorted(
            list(CTX.results.values()),
            key=lambda r: (-float(r.get("final_score", 0.0)), int(r.get("length", 0))),
        )
        tiers = compute_priority_tiers(rows_all)
        priority = tiers.get(start, "low")

        text = render_inspector(result, priority_name=priority)
        self.inspector.setPlainText(text)

        if push_history:
            self._push_history(start)


# ----------------------------------------------------------------------
# View Form
# ----------------------------------------------------------------------

# Table column indices
_COL_FUNCTION: int = 0
_COL_START: int = 1
_COL_LENGTH: int = 2
_COL_SCORE: int = 3
_COL_REASON: int = 4
_COL_CATEGORIES: int = 5
_NUM_COLUMNS: int = 6


class SpotlightViewForm(ida_kernwin.PluginForm):
    """
    Main IDA Spotlight results view.

    Shows a sortable table of scored functions with filtering,
    export capabilities, and an integrated inspector panel.

    Attributes:
        inspect_callback: Optional callback to open inspector for a given EA.
    """

    # Callback to open inspector for a given EA (set externally to avoid circular imports)
    inspect_callback: Optional[Callable[[int], None]] = None

    def __init__(self) -> None:
        """Initialize the view form."""
        super().__init__()
        self._rows: List[Dict[str, Any]] = []
        self._tiers: Dict[int, str] = {}
        self._hide_low_priority: bool = True
        self._hide_library: bool = True
        self._scanner: Optional[ChunkedScanner] = None

        # UI components (initialized in OnCreate)
        self._widget: Optional[QtWidgets.QWidget] = None
        self._btn_scan: Optional[QtWidgets.QPushButton] = None
        self._btn_export: Optional[QtWidgets.QPushButton] = None
        self._progress: Optional[QtWidgets.QProgressBar] = None
        self._lbl_status: Optional[QtWidgets.QLabel] = None
        self._table: Optional[SpotlightTableWidget] = None
        self._search_edit: Optional[QtWidgets.QLineEdit] = None
        self._inspector: Optional[QtWidgets.QPlainTextEdit] = None

    def OnCreate(self, form: object) -> None:
        """
        Initialize the UI components.

        Args:
            form: The IDA form handle.
        """
        self._widget = self.FormToPyQtWidget(form)
        root_layout = QtWidgets.QVBoxLayout(self._widget)

        # Top toolbar
        toolbar = QtWidgets.QHBoxLayout()

        self._btn_scan = QtWidgets.QPushButton("Scan")
        self._btn_scan.clicked.connect(self.start_scan)
        toolbar.addWidget(self._btn_scan)

        self._btn_export = QtWidgets.QPushButton("Exportâ€¦")
        self._btn_export.clicked.connect(self._export_dialog)
        toolbar.addWidget(self._btn_export)

        self._progress = QtWidgets.QProgressBar()
        self._progress.setRange(0, 100)
        self._progress.setValue(0)
        toolbar.addWidget(self._progress, 1)

        self._lbl_status = QtWidgets.QLabel("Ready")
        toolbar.addWidget(self._lbl_status)

        root_layout.addLayout(toolbar)

        # Main splitter (table + inspector)
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        root_layout.addWidget(splitter, 1)

        # Left panel (table + search)
        left_panel = QtWidgets.QWidget()
        left_layout = QtWidgets.QVBoxLayout(left_panel)
        left_layout.setContentsMargins(0, 0, 0, 0)

        self._table = SpotlightTableWidget(0, _NUM_COLUMNS)
        self._table.setHorizontalHeaderLabels([
            "Function", "Start", "Length", "Score", "Top reason", "Categories"
        ])
        self._table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self._table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self._table.setSortingEnabled(False)
        self._table.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self._table.customContextMenuRequested.connect(self._table_menu)
        self._table.itemSelectionChanged.connect(self._on_row_selected)
        self._table.doubleClicked.connect(self._on_double_click)
        self._table.enter_pressed.connect(self._jump_selected)
        left_layout.addWidget(self._table, 1)

        # Configure column widths
        self._table.setColumnWidth(_COL_FUNCTION, 240)
        self._table.setColumnWidth(_COL_START, 90)
        self._table.setColumnWidth(_COL_LENGTH, 90)
        self._table.setColumnWidth(_COL_SCORE, 80)
        self._table.setColumnWidth(_COL_REASON, 260)
        self._table.setColumnWidth(_COL_CATEGORIES, 220)
        self._table.horizontalHeader().setStretchLastSection(True)

        # Search bar
        search_layout = QtWidgets.QHBoxLayout()
        search_layout.addWidget(QtWidgets.QLabel("Search:"))
        self._search_edit = QtWidgets.QLineEdit()
        self._search_edit.setPlaceholderText("Filter by function name (substring)â€¦")
        self._search_edit.textChanged.connect(self._populate)
        search_layout.addWidget(self._search_edit, 1)
        left_layout.addLayout(search_layout)

        splitter.addWidget(left_panel)

        # Right panel (inspector)
        right_panel = QtWidgets.QWidget()
        right_layout = QtWidgets.QVBoxLayout(right_panel)
        right_layout.setContentsMargins(0, 0, 0, 0)

        title_label = QtWidgets.QLabel("Quick Inspector")
        font = title_label.font()
        font.setBold(True)
        title_label.setFont(font)
        right_layout.addWidget(title_label)

        self._inspector = QtWidgets.QPlainTextEdit()
        self._inspector.setReadOnly(True)
        self._inspector.setPlainText("Select a function to see details.")
        right_layout.addWidget(self._inspector, 1)

        splitter.addWidget(right_panel)
        splitter.setStretchFactor(0, 3)
        splitter.setStretchFactor(1, 2)

    def start_scan(self) -> None:
        """Start scanning all functions."""
        if not CTX.signals:
            ida_kernwin.warning("IDA Spotlight: spotlight.json not loaded.")
            return

        self._btn_scan.setEnabled(False)
        self._progress.setValue(0)
        self._lbl_status.setText("Scanningâ€¦")
        self._inspector.setPlainText("Scanningâ€¦")

        self._scanner = ChunkedScanner(chunk_size=100)
        self._scanner.progress.connect(self._progress.setValue)
        self._scanner.finished.connect(self._scan_done)
        self._scanner.start()

    def _scan_done(self, err: str) -> None:
        """
        Handle scan completion.

        Args:
            err: Error message, empty on success.
        """
        self._btn_scan.setEnabled(True)
        if err:
            self._lbl_status.setText("Error")
            self._inspector.setPlainText(f"Scan failed:\n{err}")
            return
        self._lbl_status.setText(f"Done in {CTX.last_scan_seconds:.1f}s")
        self._populate()
        log_kb_sample_correlation()

    def _get_rows(self) -> List[Dict[str, Any]]:
        """
        Get filtered and sorted rows for display.

        Returns:
            A list of function result dictionaries.
        """
        rows = list(CTX.results.values())
        rows.sort(
            key=lambda r: (-float(r.get("final_score", 0.0)), int(r.get("length", 0)))
        )

        if self._hide_low_priority:
            rows = [r for r in rows if float(r.get("final_score", 0.0)) > 0.0]

        if self._hide_library:
            rows = [r for r in rows if not r.get("is_library", False)]

        query = (self._search_edit.text() or "").strip().lower()
        if query:
            rows = [r for r in rows if query in r.get("name", "").lower()]

        return rows

    def _populate(self) -> None:
        """Populate the table with current results."""
        rows = self._get_rows()
        tiers = compute_priority_tiers(rows)

        self._rows = rows
        self._tiers = tiers

        self._table.setRowCount(len(rows))

        for index, result in enumerate(rows):
            ea = int(result["ea"])
            length = int(result.get("length", 0))
            score = float(result.get("final_score", 0.0))

            # Determine row color
            if result.get("is_library", False):
                color = QtGui.QColor(160, 220, 255)
            else:
                priority = tiers.get(ea, "low")
                color = priority_color(priority)

            # Create table items
            item_func = QtWidgets.QTableWidgetItem(result.get("name", ""))
            item_func.setToolTip(result.get("name", ""))
            item_start = QtWidgets.QTableWidgetItem(fmt_ea(ea))
            item_len = QtWidgets.QTableWidgetItem(hex(length))
            item_score = QtWidgets.QTableWidgetItem(f"{score:.2f}")
            item_reason = QtWidgets.QTableWidgetItem(top_reason_str(result))
            item_cats = QtWidgets.QTableWidgetItem(categories_str(result))

            items = [item_func, item_start, item_len, item_score, item_reason, item_cats]
            for col, item in enumerate(items):
                item.setData(QtCore.Qt.UserRole, ea)
                if color is not None:
                    item.setBackground(QtGui.QBrush(color))
                self._table.setItem(index, col, item)

        if not rows:
            self._inspector.setPlainText("No results.")
        else:
            self._inspector.setPlainText("Select a function to see details.")

    def _selected_start_ea(self) -> Optional[int]:
        """
        Get the EA of the currently selected row.

        Returns:
            The function start EA, or None if no selection.
        """
        row = self._table.currentRow()
        if row < 0:
            return None
        item = self._table.item(row, 0)
        if not item:
            return None
        ea = item.data(QtCore.Qt.UserRole)
        try:
            return int(ea)
        except Exception:
            return None

    def _on_row_selected(self) -> None:
        """Update inspector when row selection changes."""
        start_ea = self._selected_start_ea()
        if start_ea is None:
            return
        result = CTX.results.get(start_ea)
        if not result:
            return
        priority = self._tiers.get(start_ea, "low")
        self._inspector.setPlainText(render_inspector(result, priority_name=priority))

    def _jump_selected(self) -> None:
        """Jump to the selected function in IDA."""
        start_ea = self._selected_start_ea()
        if start_ea is None:
            return
        ida_kernwin.jumpto(start_ea)

    def _inspect_here(self) -> None:
        """Open the standalone inspector for the selected function."""
        start_ea = self._selected_start_ea()
        if start_ea is None:
            return
        if SpotlightViewForm.inspect_callback is not None:
            SpotlightViewForm.inspect_callback(start_ea)

    def _on_double_click(self, index: QtCore.QModelIndex) -> None:
        """
        Handle double-click on a row.

        Args:
            index: The clicked model index.
        """
        self._jump_selected()

    def _current_cell_text(self) -> str:
        """
        Get text from the current cell.

        Returns:
            The cell text, or empty string.
        """
        row = self._table.currentRow()
        col = self._table.currentColumn()
        item = self._table.item(row, col) if (row >= 0 and col >= 0) else None
        return item.text() if item else ""

    def _current_row_text(self, row: int) -> str:
        """
        Get tab-separated text from a row.

        Args:
            row: The row index.

        Returns:
            Tab-separated cell values.
        """
        cells = []
        for col in range(self._table.columnCount()):
            item = self._table.item(row, col)
            cells.append(item.text() if item else "")
        return "\t".join(cells)

    def _selected_rows_text(self) -> str:
        """
        Get newline-separated text from selected rows.

        Returns:
            Newline-separated row values.
        """
        rows = sorted({idx.row() for idx in self._table.selectionModel().selectedRows()})
        return "\n".join(self._current_row_text(r) for r in rows)

    def _table_menu(self, pos: QtCore.QPoint) -> None:
        """
        Show the table context menu.

        Args:
            pos: The position where the menu was requested.
        """
        menu = QtWidgets.QMenu()

        # Filter toggles
        act_hide_low = menu.addAction("Hide Low Priority")
        act_hide_low.setCheckable(True)
        act_hide_low.setChecked(self._hide_low_priority)

        act_hide_lib = menu.addAction("Hide Library Functions")
        act_hide_lib.setCheckable(True)
        act_hide_lib.setChecked(self._hide_library)

        act_inspect_here = menu.addAction("Inspect here")

        menu.addSeparator()

        # Copy submenu
        copy_menu = menu.addMenu("Copy")
        act_copy_cell = copy_menu.addAction("Copy cell")
        act_copy_row = copy_menu.addAction("Copy row")
        act_copy_rows = copy_menu.addAction("Copy selected rows")

        menu.addSeparator()

        act_jump = menu.addAction("Jump to function")

        menu.addSeparator()

        # Export submenu
        export_menu = menu.addMenu("Export")
        act_export_csv = export_menu.addAction("Export CSVâ€¦")
        act_export_json = export_menu.addAction("Export JSONâ€¦")

        action = menu.exec_(self._table.mapToGlobal(pos))
        if not action:
            return

        # Handle menu actions
        if action == act_hide_low:
            self._hide_low_priority = not self._hide_low_priority
            self._populate()
        elif action == act_hide_lib:
            self._hide_library = not self._hide_library
            self._populate()
        elif action == act_inspect_here:
            self._inspect_here()
        elif action == act_copy_cell:
            QtWidgets.QApplication.clipboard().setText(self._current_cell_text())
        elif action == act_copy_row:
            row = self._table.currentRow()
            if row >= 0:
                QtWidgets.QApplication.clipboard().setText(self._current_row_text(row))
        elif action == act_copy_rows:
            text = self._selected_rows_text()
            if text:
                QtWidgets.QApplication.clipboard().setText(text)
        elif action == act_jump:
            self._jump_selected()
        elif action == act_export_csv:
            self._export_csv()
        elif action == act_export_json:
            self._export_json()

    def _export_dialog(self) -> None:
        """Show the export format selection dialog."""
        menu = QtWidgets.QMenu()
        act_csv = menu.addAction("Export CSVâ€¦")
        act_json = menu.addAction("Export JSONâ€¦")
        action = menu.exec_(QtGui.QCursor.pos())
        if action == act_csv:
            self._export_csv()
        elif action == act_json:
            self._export_json()

    def _export_csv(self) -> None:
        """Export results to CSV file."""
        file_path, _ = QtWidgets.QFileDialog.getSaveFileName(
            self._widget, "Export CSV", "", "CSV (*.csv)"
        )
        if not file_path:
            return

        rows = self._rows if self._rows else self._get_rows()
        tiers = compute_priority_tiers(rows)

        with open(file_path, "w", newline="", encoding="utf-8") as csv_file:
            writer = csv.writer(csv_file)
            writer.writerow([
                "Function", "Start", "Length", "Score",
                "Priority", "Library", "Top reason", "Categories"
            ])
            for result in rows:
                ea = int(result["ea"])
                writer.writerow([
                    result.get("name", ""),
                    fmt_ea(ea),
                    hex(int(result.get("length", 0))),
                    f"{float(result.get('final_score', 0.0)):.2f}",
                    tiers.get(ea, "low"),
                    "yes" if result.get("is_library") else "no",
                    top_reason_str(result),
                    categories_str(result),
                ])

    def _export_json(self) -> None:
        """Export results to JSON file."""
        file_path, _ = QtWidgets.QFileDialog.getSaveFileName(
            self._widget, "Export JSON", "", "JSON (*.json)"
        )
        if not file_path:
            return

        rows = self._rows if self._rows else self._get_rows()
        tiers = compute_priority_tiers(rows)

        output: List[Dict[str, Any]] = []
        for result in rows:
            ea = int(result["ea"])
            output.append({
                "name": result.get("name", ""),
                "start_ea": ea,
                "start_ea_hex": fmt_ea(ea),
                "length": int(result.get("length", 0)),
                "length_hex": hex(int(result.get("length", 0))),
                "is_library": bool(result.get("is_library", False)),
                "base_score": float(result.get("base_score", 0.0)),
                "context_bonus": float(result.get("context_bonus", 0.0)),
                "final_score": float(result.get("final_score", 0.0)),
                "priority": tiers.get(ea, "low"),
                "top_reason": top_reason_str(result),
                "categories": [
                    key for key, value in result.get("category_hits", {}).items() if value
                ],
                "reasons": list(result.get("reasons", [])),
            })

        with open(file_path, "w", encoding="utf-8") as json_file:
            json.dump(output, json_file, indent=2)

```

`spotlight_utils.py`:

```py
# SPDX-License-Identifier: Apache-2.0
"""
Utility functions for IDA Spotlight.

This module provides common helper functions including:
- Qt widget validation helpers
- Address formatting utilities
- Regex pattern matching
- String sanitization
- Function lookups
- Widget introspection
- Normalization helpers
- Fingerprint helpers
- IDB collection helpers
"""

import hashlib
import os
import re
from typing import Iterable, List, Optional, Pattern, Set, Tuple

import ida_funcs
import ida_kernwin

import shiboken6


__all__ = [
    # Normalization
    "normalize_name",
    "normalize_dll_name",
    # Fingerprinting
    "fingerprint_md5",
    "build_import_items",
    # Filters
    "is_filtered_func",
    # IDB collection
    "collect_import_modules",
    "iter_segments",
    # Qt helpers
    "qt_alive",
    "get_qt_parent",
    # Address formatting
    "fmt_ea",
    # Pattern matching
    "safe_regex_search",
    # String processing
    "sanitize_operand_name",
    # Function lookups
    "func_start_from_any_ea",
    # Widget introspection
    "is_code_widget",
    "widget_title",
    "extract_view_letter_from_title",
    "paired_view_titles",
    "find_code_widget_by_title",
]


# ----------------------------------------------------------------------
# Normalization helpers
# ----------------------------------------------------------------------

def normalize_name(name: str) -> str:
    """
    Normalize a name to lowercase for comparison.

    Args:
        name: The name string to normalize.

    Returns:
        The normalized lowercase string.
    """
    return (name or "").strip().lower()


def normalize_dll_name(name_raw: str) -> str:
    """
    Normalize a DLL name, adding .dll extension if missing.

    Args:
        name_raw: The raw DLL name string.

    Returns:
        The normalized DLL name with extension.
    """
    normalized = normalize_name(name_raw)
    if not normalized:
        return ""
    if "." in os.path.basename(normalized):
        return normalized
    return normalized + ".dll"


# ----------------------------------------------------------------------
# Fingerprint helpers
# ----------------------------------------------------------------------

def fingerprint_md5(items: Iterable[str]) -> str:
    """
    Compute MD5 fingerprint of sorted items.

    Args:
        items: An iterable of strings to fingerprint.

    Returns:
        The MD5 hexdigest of the sorted, comma-separated items.
    """
    sorted_items = ",".join(sorted(item for item in items if item))
    return hashlib.md5(sorted_items.encode("utf-8", errors="ignore")).hexdigest()


def build_import_items(
    import_modules: List[Tuple[str, List[Tuple[Optional[str], Optional[int]]]]],
    common_import_dlls: Set[str],
    keep_common_imports: bool,
) -> List[str]:
    """
    Build a list of import items in 'dll!func' format.

    Args:
        import_modules: List of (dll_name, [(func_name, ordinal), ...]) tuples.
        common_import_dlls: Set of DLL names to filter out.
        keep_common_imports: If True, include common imports.

    Returns:
        A list of 'dll!func' strings.
    """
    result: List[str] = []
    for dll_raw, entries in import_modules:
        dll_norm = normalize_dll_name(dll_raw)
        if not dll_norm:
            continue
        if not keep_common_imports and dll_norm in common_import_dlls:
            continue

        for name, ordinal in entries:
            if name:
                func_norm = normalize_name(str(name))
            elif ordinal is not None:
                func_norm = normalize_name(f"ord{int(ordinal)}")
            else:
                continue
            result.append(f"{dll_norm}!{func_norm}")
    return result


# ----------------------------------------------------------------------
# Filters
# ----------------------------------------------------------------------

def is_filtered_func(name: str, filters: List[Pattern[str]]) -> bool:
    """
    Check if a function name matches any filter pattern.

    Args:
        name: The function name to check.
        filters: A list of compiled regex patterns.

    Returns:
        True if the name matches any filter pattern, False otherwise.
    """
    for pattern in filters:
        if pattern.match(name):
            return True
    return False


# ----------------------------------------------------------------------
# IDB Collection Helpers
# ----------------------------------------------------------------------

def collect_import_modules() -> List[Tuple[str, List[Tuple[Optional[str], Optional[int]]]]]:
    """
    Collect all import modules and their entries from the current IDB.

    Returns:
        A list of tuples: (dll_name, [(func_name, ordinal), ...])
    """
    import ida_nalt

    modules: List[Tuple[str, List[Tuple[Optional[str], Optional[int]]]]] = []
    try:
        module_count = ida_nalt.get_import_module_qty()
    except Exception:
        return modules

    for index in range(module_count):
        dll_raw = ida_nalt.get_import_module_name(index) or ""
        entries: List[Tuple[Optional[str], Optional[int]]] = []

        def callback(ea: int, name: Optional[str], ordinal: Optional[int]) -> bool:
            entries.append((name, ordinal))
            return True

        try:
            ida_nalt.enum_import_names(index, callback)
        except Exception:
            continue

        modules.append((dll_raw, entries))

    return modules


def iter_segments(
    ignored_sections: Set[str],
    keep_common: bool = False,
) -> List[Tuple[str, str, int, int]]:
    """
    Iterate over segments from current IDB with optional filtering.

    Args:
        ignored_sections: Set of normalized section names to filter out.
        keep_common: If True, include sections from ignored_sections set.

    Returns:
        A list of tuples: (name_raw, name_norm, start_ea, end_ea)
    """
    import ida_segment

    result: List[Tuple[str, str, int, int]] = []
    try:
        segment_count = ida_segment.get_segm_qty()
        for index in range(segment_count):
            segment = ida_segment.getnseg(index)
            if not segment:
                continue

            name_raw = ida_segment.get_segm_name(segment) or ""
            name_norm = normalize_name(name_raw)

            if not keep_common and name_norm in ignored_sections:
                continue

            result.append((name_raw, name_norm, segment.start_ea, segment.end_ea))
    except Exception:
        pass

    return result


# ----------------------------------------------------------------------
# Qt Helpers
# ----------------------------------------------------------------------

def qt_alive(obj: object) -> bool:
    """
    Check if a Qt object is still valid.

    Args:
        obj: A Qt object to check.

    Returns:
        True if the object exists and is valid, False otherwise.
    """
    try:
        return obj is not None and shiboken6.isValid(obj)
    except Exception:
        return False


def get_qt_parent() -> Optional[object]:
    """
    Get a suitable Qt parent widget from the current IDA widget.

    Returns:
        A PyQt widget suitable as a parent, or None.
    """
    try:
        widget = ida_kernwin.get_current_widget()
        return ida_kernwin.PluginForm.FormToPyQtWidget(widget)
    except Exception:
        return None


# ----------------------------------------------------------------------
# Address Formatting
# ----------------------------------------------------------------------

def fmt_ea(ea: int) -> str:
    """
    Format an effective address as a hex string.

    Args:
        ea: The address to format.

    Returns:
        A string like "0x12345678".
    """
    return f"0x{int(ea):x}"


# ----------------------------------------------------------------------
# Pattern Matching
# ----------------------------------------------------------------------

def safe_regex_search(pattern: str, text: str) -> bool:
    """
    Perform a safe regex search that won't raise exceptions.

    Args:
        pattern: The regex pattern to search for.
        text: The text to search in.

    Returns:
        True if the pattern matches, False otherwise or on error.
    """
    try:
        return re.search(pattern, text, re.IGNORECASE) is not None
    except Exception:
        return False


# ----------------------------------------------------------------------
# String Processing
# ----------------------------------------------------------------------

def sanitize_operand_name(name: str) -> str:
    """
    Clean up an operand name by removing segment prefixes.

    Args:
        name: The raw operand name (may contain "seg:name" format).

    Returns:
        The cleaned name with segment prefix removed.
    """
    if not name:
        return ""
    if ":" in name:
        name = name.split(":")[-1]
    return name.strip()


# ----------------------------------------------------------------------
# Function Lookups
# ----------------------------------------------------------------------

def func_start_from_any_ea(ea: int) -> Optional[int]:
    """
    Get the start address of the function containing a given address.

    Args:
        ea: Any address that might be within a function.

    Returns:
        The start address of the containing function, or None.
    """
    func = ida_funcs.get_func(int(ea))
    return int(func.start_ea) if func else None


# ----------------------------------------------------------------------
# Widget Introspection
# ----------------------------------------------------------------------

def is_code_widget(widget: object) -> bool:
    """
    Check if a widget is a code view (disassembly or pseudocode).

    Args:
        widget: An IDA widget handle.

    Returns:
        True if the widget shows code, False otherwise.
    """
    try:
        widget_type = ida_kernwin.get_widget_type(widget)
        return widget_type in (ida_kernwin.BWN_DISASM, ida_kernwin.BWN_PSEUDOCODE)
    except Exception:
        return False


def widget_title(widget: object) -> str:
    """
    Get the title of an IDA widget.

    Args:
        widget: An IDA widget handle.

    Returns:
        The widget title, or empty string on error.
    """
    try:
        return ida_kernwin.get_widget_title(widget) or ""
    except Exception:
        return ""


def extract_view_letter_from_title(title: str) -> Optional[str]:
    """
    Extract the view letter (A, B, etc.) from an IDA view title.

    Expected formats: "IDA View-A", "Pseudocode-A"

    Args:
        title: The widget title string.

    Returns:
        The letter suffix (e.g., "A") or None if not matched.
    """
    match = re.match(r"^(IDA View|Pseudocode)-([A-Z])$", (title or "").strip())
    if not match:
        return None
    return match.group(2)


def paired_view_titles(title: str) -> List[str]:
    """
    Get both paired view titles for a given view.

    For "IDA View-A", returns ["IDA View-A", "Pseudocode-A"].

    Args:
        title: The current view title.

    Returns:
        A list of paired view titles.
    """
    letter = extract_view_letter_from_title(title)
    if not letter:
        return [title]
    return [f"IDA View-{letter}", f"Pseudocode-{letter}"]


def find_code_widget_by_title(title: str) -> Optional[object]:
    """
    Find a code widget (disassembly/pseudocode) by its title.

    Args:
        title: The widget title to search for.

    Returns:
        The widget handle, or None if not found or not a code widget.
    """
    try:
        widget = ida_kernwin.find_widget(title)
    except Exception:
        widget = None
    if widget is None:
        return None
    if not is_code_widget(widget):
        return None
    return widget

```