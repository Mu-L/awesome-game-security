Project Path: arc_kvnxiao_storytime_8a5qquvl

Source Tree:

```txt
arc_kvnxiao_storytime_8a5qquvl
├── README.md
├── android
│   ├── AndroidManifest.xml
│   ├── assets
│   │   ├── Base pack
│   │   │   ├── Tiles
│   │   │   │   ├── tiles_spritesheet.png
│   │   │   │   └── tiles_spritesheet.xml
│   │   │   ├── bg.png
│   │   │   └── bg_castle.png
│   │   ├── blank.png
│   │   ├── fonts
│   │   │   ├── bandera.fnt
│   │   │   └── bandera.png
│   │   ├── general.txt
│   │   ├── highScore.dat
│   │   ├── keys
│   │   │   └── SavedLayout.txt
│   │   ├── levels
│   │   │   ├── levels.txt
│   │   │   ├── survival_grass.tmx
│   │   │   ├── survival_hell.tmx
│   │   │   └── survival_moon.tmx
│   │   ├── menus
│   │   │   ├── LoadMenu.xml
│   │   │   ├── MainMenu.xml
│   │   │   ├── ModeMenu.xml
│   │   │   ├── OptionsMenu.xml
│   │   │   ├── PauseMenu.xml
│   │   │   ├── PlayMenu.xml
│   │   │   ├── SaveMenu.xml
│   │   │   ├── SelectCharMenu.xml
│   │   │   ├── SelectMapMenu.xml
│   │   │   ├── loading_screen.txt
│   │   │   └── main_menu.txt
│   │   ├── music
│   │   │   ├── alpen_rose.mp3
│   │   │   ├── peaceful_forest.mp3
│   │   │   └── tale_east.mp3
│   │   ├── sfx
│   │   │   ├── generic
│   │   │   │   ├── cast1.wav
│   │   │   │   └── cast2.wav
│   │   │   ├── jump.wav
│   │   │   ├── menu
│   │   │   │   ├── menu_hit.wav
│   │   │   │   └── menu_hover.wav
│   │   │   ├── monsters
│   │   │   │   ├── alien
│   │   │   │   │   ├── alien_attack.wav
│   │   │   │   │   ├── alien_chardmg.wav
│   │   │   │   │   ├── alien_die.wav
│   │   │   │   │   └── alien_hit.wav
│   │   │   │   ├── plateon
│   │   │   │   │   ├── plateon_die.wav
│   │   │   │   │   └── plateon_hit.wav
│   │   │   │   ├── slime
│   │   │   │   │   ├── slime_die.wav
│   │   │   │   │   └── slime_hit.wav
│   │   │   │   └── zombie
│   │   │   │       ├── zombie_die.wav
│   │   │   │       └── zombie_hit.wav
│   │   │   ├── pickups
│   │   │   │   ├── pill.wav
│   │   │   │   └── potion.wav
│   │   │   └── player_death.wav
│   │   ├── shaders
│   │   │   ├── passthrough.fsh
│   │   │   ├── passthrough.vsh
│   │   │   ├── vignette.fsh
│   │   │   └── vignette.vsh
│   │   └── textures
│   │       ├── debug.png
│   │       ├── entities
│   │       │   ├── monsters
│   │       │   │   ├── alien
│   │       │   │   │   ├── alien.pack
│   │       │   │   │   ├── alien.png
│   │       │   │   │   └── alien.xml
│   │       │   │   └── grey_slime
│   │       │   │       ├── grey_slime.pack
│   │       │   │       ├── grey_slime.png
│   │       │   │       └── grey_slime.xml
│   │       │   ├── pickups
│   │       │   │   ├── pickups.pack
│   │       │   │   └── pickups.png
│   │       │   ├── player
│   │       │   │   ├── Alice.pack
│   │       │   │   ├── Alice.png
│   │       │   │   ├── Alice.xml
│   │       │   │   ├── fabulous.pack
│   │       │   │   ├── fabulous.png
│   │       │   │   ├── fabulous.xml
│   │       │   │   ├── fabulous2.png
│   │       │   │   ├── kirito.pack
│   │       │   │   ├── kirito.png
│   │       │   │   ├── kirito.xml
│   │       │   │   ├── player.pack
│   │       │   │   ├── player.png
│   │       │   │   ├── player.xml
│   │       │   │   ├── tombstone.pack
│   │       │   │   └── tombstone.png
│   │       │   └── projectiles
│   │       │       ├── explosion
│   │       │       │   ├── explosion.pack
│   │       │       │   └── explosion.png
│   │       │       ├── iceball
│   │       │       │   ├── iceball.pack
│   │       │       │   └── iceball.png
│   │       │       ├── icespike
│   │       │       │   ├── icespike.pack
│   │       │       │   └── icespike.png
│   │       │       ├── magicbolt
│   │       │       │   ├── magicbolt.pack
│   │       │       │   └── magicbolt.png
│   │       │       ├── swing
│   │       │       │   ├── swing.pack
│   │       │       │   └── swing.png
│   │       │       └── swirlingmoon
│   │       │           ├── swirlingmoon.pack
│   │       │           ├── swirlingmoon.png
│   │       │           ├── swirlingmoon10.png
│   │       │           ├── swirlingmoon11.png
│   │       │           ├── swirlingmoon12.png
│   │       │           ├── swirlingmoon13.png
│   │       │           ├── swirlingmoon2.png
│   │       │           ├── swirlingmoon3.png
│   │       │           ├── swirlingmoon4.png
│   │       │           ├── swirlingmoon5.png
│   │       │           ├── swirlingmoon6.png
│   │       │           ├── swirlingmoon7.png
│   │       │           ├── swirlingmoon8.png
│   │       │           └── swirlingmoon9.png
│   │       ├── hud
│   │       │   ├── bars
│   │       │   │   ├── hud_bars.pack
│   │       │   │   └── hud_bars.png
│   │       │   └── damage
│   │       │       ├── hitMonster
│   │       │       │   ├── hitMonster.pack
│   │       │       │   └── hitMonster.png
│   │       │       ├── hitMonsterCrit
│   │       │       │   ├── hitMonsterCrit.pack
│   │       │       │   └── hitMonsterCrit.png
│   │       │       └── hitPlayer
│   │       │           ├── hitPlayer.pack
│   │       │           └── hitPlayer.png
│   │       ├── levels
│   │       │   ├── blue.png
│   │       │   ├── fuji.png
│   │       │   ├── hell_back.png
│   │       │   ├── hell_rocks.png
│   │       │   ├── night_back.png
│   │       │   ├── sakuracanopy.png
│   │       │   ├── sakuratrees.png
│   │       │   ├── survival_forest_image.png
│   │       │   ├── survival_hell_image.png
│   │       │   ├── survival_moon_image.png
│   │       │   └── tileset.png
│   │       └── menu
│   │           ├── background
│   │           │   └── background.png
│   │           ├── buttons
│   │           │   ├── menu_buttons.pack
│   │           │   └── menu_buttons.png
│   │           ├── loadingbar
│   │           │   ├── menu_loadingbar.pack
│   │           │   └── menu_loadingbar.png
│   │           └── misc
│   │               └── highscore_header.png
│   ├── build.gradle
│   ├── ic_launcher-web.png
│   ├── proguard-project.txt
│   ├── project.properties
│   ├── res
│   │   ├── drawable-hdpi
│   │   │   └── ic_launcher.png
│   │   ├── drawable-mdpi
│   │   │   └── ic_launcher.png
│   │   ├── drawable-xhdpi
│   │   │   └── ic_launcher.png
│   │   ├── drawable-xxhdpi
│   │   │   └── ic_launcher.png
│   │   └── values
│   │       ├── strings.xml
│   │       └── styles.xml
│   └── src
│       └── com
│           └── jxz
│               └── notcontra
│                   └── game
│                       └── android
│                           └── AndroidLauncher.java
├── build.gradle
├── core
│   ├── build.gradle
│   └── src
│       └── com
│           └── jxz
│               └── notcontra
│                   ├── animation
│                   │   ├── AnimationEx.java
│                   │   └── SpriteEx.java
│                   ├── buff
│                   │   ├── Buff.java
│                   │   ├── CastingBuff.java
│                   │   ├── ForceBuff.java
│                   │   └── FrozenBuff.java
│                   ├── camera
│                   │   └── PlayerCamera.java
│                   ├── effect
│                   │   ├── Effect.java
│                   │   └── SpriteEffect.java
│                   ├── entity
│                   │   ├── Alien.java
│                   │   ├── AnimatedEntity.java
│                   │   ├── AttachedHitbox.java
│                   │   ├── BossMonster.java
│                   │   ├── ChildObject.java
│                   │   ├── DynamicHitbox.java
│                   │   ├── Entity.java
│                   │   ├── EntityFactory.java
│                   │   ├── GruntMonster.java
│                   │   ├── LivingEntity.java
│                   │   ├── Monster.java
│                   │   ├── PhysicsProjectile.java
│                   │   ├── Player.java
│                   │   ├── PlayerSave.java
│                   │   ├── Projectile.java
│                   │   ├── RangedMonster.java
│                   │   ├── Slime.java
│                   │   ├── StaticEntity.java
│                   │   ├── Tombstone.java
│                   │   └── pickups
│                   │       ├── DropChance.java
│                   │       ├── HealthPotion.java
│                   │       └── Pickups.java
│                   ├── game
│                   │   └── Game.java
│                   ├── handlers
│                   │   ├── AssetHandler.java
│                   │   ├── AudioHelper.java
│                   │   ├── BuffInventory.java
│                   │   ├── EntityManager.java
│                   │   ├── GameStateManager.java
│                   │   ├── HighScoreHandler.java
│                   │   ├── InputManager.java
│                   │   ├── KeyLayoutHelper.java
│                   │   ├── ParticleManager.java
│                   │   ├── SaveGameHandler.java
│                   │   ├── SkillInventory.java
│                   │   └── SkillManager.java
│                   ├── hud
│                   │   ├── HealthBar.java
│                   │   ├── OSHealthBar.java
│                   │   └── PlayerStatusBar.java
│                   ├── menu
│                   │   ├── AbstractBars.java
│                   │   ├── AnimatedScrollPane.java
│                   │   ├── GeneralSettingsMenu.java
│                   │   ├── HighScoreMenu.java
│                   │   ├── KeyLayoutMenu.java
│                   │   ├── LoadingBar.java
│                   │   ├── Menu.java
│                   │   ├── ParseMenu.java
│                   │   ├── SaveLoadScrollPane.java
│                   │   ├── ScreenshotFactory.java
│                   │   ├── ScrollPane.java
│                   │   └── buttons
│                   │       ├── Button.java
│                   │       ├── SpriteButton.java
│                   │       ├── TextLabel.java
│                   │       └── ToggleButton.java
│                   ├── particles
│                   │   ├── DamageNumber.java
│                   │   ├── Particle.java
│                   │   └── ParticleFactory.java
│                   ├── shaders
│                   │   └── Shaders.java
│                   ├── skill
│                   │   ├── BuffSkill.java
│                   │   ├── CastingBuffSkill.java
│                   │   ├── ExplosionSkill.java
│                   │   ├── ForceBuffSkill.java
│                   │   ├── LinearProjectileSkill.java
│                   │   ├── MeleeAttackSkill.java
│                   │   ├── RainProjectileSkill.java
│                   │   ├── Skill.java
│                   │   └── SpawnSkill.java
│                   ├── states
│                   │   ├── GameState.java
│                   │   ├── LoadState.java
│                   │   ├── MenuState.java
│                   │   └── PlayState.java
│                   └── world
│                       ├── Level.java
│                       ├── LevelRenderer.java
│                       └── SpawnPointList.java
├── desktop
│   ├── build.gradle
│   └── src
│       └── com
│           └── jxz
│               └── notcontra
│                   └── game
│                       └── desktop
│                           └── DesktopLauncher.java
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
├── ios
│   ├── Info.plist.xml
│   ├── build.gradle
│   ├── data
│   │   ├── Default-375w-667h@2x.png
│   │   ├── Default-414w-736h@3x.png
│   │   ├── Default-568h@2x.png
│   │   ├── Default.png
│   │   ├── Default@2x.png
│   │   ├── Default@2x~ipad.png
│   │   ├── Default~ipad.png
│   │   ├── Icon-72.png
│   │   ├── Icon-72@2x.png
│   │   ├── Icon.png
│   │   └── Icon@2x.png
│   ├── robovm.properties
│   ├── robovm.xml
│   └── src
│       └── com
│           └── jxz
│               └── notcontra
│                   └── game
│                       └── IOSLauncher.java
└── settings.gradle

```

`README.md`:

```md
![storytime.png](https://bitbucket.org/repo/oX9rLp/images/1026898476-storytime.png)

StoryTime is a 'lite' remake of the popular MMORPG game MapleStory. Although written in Java, it also incorporates JSON, XML, and Java Internal Reflection techniques.

In simple terms, the game is a survival 2D singleplayer platformer. The player controls a character and must attempt to survive for as long as possible against waves of enemies.

**DOWNLOAD PRE-COMPILED GAME (v1.00):** [StoryTime.jar - DropBox Link](https://dl.dropboxusercontent.com/u/36132405/Projects/storytimev100_runnable.zip)

# Why? #
The goal of this project was purely for educational purposes, that is, to develop an understanding of game design and the game development process. LibGDX (an open source Java-based game development framework) was used as the underlying graphics engine.

# Features #
* **Currently supports keyboard and mouse input only** (can still be compiled on other devices thanks to LibGDX's cross compatibility)
* Wave based survival
* Customizable key input in Options menu
* Double jumping / drop down from thin platforms (hold DOWN and press JUMP on thin platforms)
* Fall damage from high heights
* Highscores and game saves / load saves on startup
* Parallax camera (three layers of background)
* Utilizes the Tiled Map Editor for the creation and storage of 2D platformer maps
* Asset Handler parses a customized text file to dynamically load game assets
* Entity pooling for monsters and particle effects

# Legal #
* As previously stated, this project was purely made for educational purposes. Since this is a remake of an already existing game, it utilizes some assets that were not created by us. Namely, the character sprites were extracted directly from MapleStory and the music files were borrowed from both MapleStory and Ragnarok Online. We do not claim any rights to these assets. On the occurrence that you are a creator of any of the assets used in this game and would like to have your assets removed, please feel free to contact us.

# Screenshots #
[mainmenu.jpg](https://bitbucket.org/repo/oX9rLp/images/2742762888-mainmenu.jpg)

[ingame1.jpg](https://bitbucket.org/repo/oX9rLp/images/1668187096-ingame1.jpg)
```

`android/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="com.jxz.notcontra.game.android"
          android:versionCode="1"
          android:versionName="1.0">

    <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="22"/>

    <application
            android:allowBackup="true"
            android:icon="@drawable/ic_launcher"
            android:label="@string/app_name"
            android:theme="@style/GdxTheme">
        <activity
                android:name="com.jxz.notcontra.game.android.AndroidLauncher"
                android:label="@string/app_name"
                android:screenOrientation="landscape"
                android:configChanges="keyboard|keyboardHidden|orientation|screenSize">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
    </application>

</manifest>

```

`android/assets/Base pack/Tiles/tiles_spritesheet.xml`:

```xml
<TextureAtlas imagePath="sheet.png">
    <SubTexture name="box.png" x="0" y="864" width="70" height="70"/>
    <SubTexture name="boxAlt.png" x="0" y="792" width="70" height="70"/>
    <SubTexture name="boxCoin.png" x="0" y="720" width="70" height="70"/>
    <SubTexture name="boxCoinAlt.png" x="0" y="576" width="70" height="70"/>
    <SubTexture name="boxCoinAlt_disabled.png" x="0" y="504" width="70" height="70"/>
    <SubTexture name="boxCoin_disabled.png" x="0" y="648" width="70" height="70"/>
    <SubTexture name="boxEmpty.png" x="0" y="432" width="70" height="70"/>
    <SubTexture name="boxExplosive.png" x="0" y="360" width="70" height="70"/>
    <SubTexture name="boxExplosiveAlt.png" x="0" y="216" width="70" height="70"/>
    <SubTexture name="boxExplosive_disabled.png" x="0" y="288" width="70" height="70"/>
    <SubTexture name="boxItem.png" x="0" y="144" width="70" height="70"/>
    <SubTexture name="boxItemAlt.png" x="0" y="0" width="70" height="70"/>
    <SubTexture name="boxItemAlt_disabled.png" x="432" y="432" width="70" height="70"/>
    <SubTexture name="boxItem_disabled.png" x="0" y="72" width="70" height="70"/>
    <SubTexture name="boxWarning.png" x="72" y="648" width="70" height="70"/>
    <SubTexture name="brickWall.png" x="216" y="0" width="70" height="70"/>
    <SubTexture name="bridge.png" x="216" y="72" width="70" height="70"/>
    <SubTexture name="bridgeLogs.png" x="288" y="720" width="70" height="70"/>
    <SubTexture name="castle.png" x="288" y="792" width="70" height="70"/>
    <SubTexture name="castleCenter.png" x="504" y="288" width="70" height="70"/>
    <SubTexture name="castleCenter_rounded.png" x="504" y="720" width="70" height="70"/>
    <SubTexture name="castleCliffLeft.png" x="504" y="792" width="70" height="70"/>
    <SubTexture name="castleCliffLeftAlt.png" x="648" y="720" width="70" height="70"/>
    <SubTexture name="castleCliffRight.png" x="648" y="792" width="70" height="70"/>
    <SubTexture name="castleCliffRightAlt.png" x="792" y="288" width="70" height="70"/>
    <SubTexture name="castleHalf.png" x="792" y="360" width="70" height="70"/>
    <SubTexture name="castleHalfLeft.png" x="432" y="720" width="70" height="70"/>
    <SubTexture name="castleHalfMid.png" x="648" y="648" width="70" height="70"/>
    <SubTexture name="castleHalfRight.png" x="792" y="648" width="70" height="70"/>
    <SubTexture name="castleHillLeft.png" x="648" y="576" width="70" height="70"/>
    <SubTexture name="castleHillLeft2.png" x="792" y="576" width="70" height="70"/>
    <SubTexture name="castleHillRight.png" x="792" y="504" width="70" height="70"/>
    <SubTexture name="castleHillRight2.png" x="792" y="432" width="70" height="70"/>
    <SubTexture name="castleLedgeLeft.png" x="856" y="868" width="5" height="22"/>
    <SubTexture name="castleLedgeRight.png" x="842" y="868" width="5" height="22"/>
    <SubTexture name="castleLeft.png" x="792" y="216" width="70" height="70"/>
    <SubTexture name="castleMid.png" x="792" y="144" width="70" height="70"/>
    <SubTexture name="castleRight.png" x="792" y="72" width="70" height="70"/>
    <SubTexture name="dirt.png" x="792" y="0" width="70" height="70"/>
    <SubTexture name="dirtCenter.png" x="720" y="864" width="70" height="70"/>
    <SubTexture name="dirtCenter_rounded.png" x="720" y="792" width="70" height="70"/>
    <SubTexture name="dirtCliffLeft.png" x="720" y="720" width="70" height="70"/>
    <SubTexture name="dirtCliffLeftAlt.png" x="720" y="648" width="70" height="70"/>
    <SubTexture name="dirtCliffRight.png" x="720" y="576" width="70" height="70"/>
    <SubTexture name="dirtCliffRightAlt.png" x="720" y="504" width="70" height="70"/>
    <SubTexture name="dirtHalf.png" x="720" y="432" width="70" height="70"/>
    <SubTexture name="dirtHalfLeft.png" x="720" y="360" width="70" height="70"/>
    <SubTexture name="dirtHalfMid.png" x="720" y="288" width="70" height="70"/>
    <SubTexture name="dirtHalfRight.png" x="720" y="216" width="70" height="70"/>
    <SubTexture name="dirtHillLeft.png" x="720" y="144" width="70" height="70"/>
    <SubTexture name="dirtHillLeft2.png" x="720" y="72" width="70" height="70"/>
    <SubTexture name="dirtHillRight.png" x="720" y="0" width="70" height="70"/>
    <SubTexture name="dirtHillRight2.png" x="648" y="864" width="70" height="70"/>
    <SubTexture name="dirtLedgeLeft.png" x="842" y="892" width="5" height="18"/>
    <SubTexture name="dirtLedgeRight.png" x="842" y="912" width="5" height="18"/>
    <SubTexture name="dirtLeft.png" x="504" y="432" width="70" height="70"/>
    <SubTexture name="dirtMid.png" x="504" y="360" width="70" height="70"/>
    <SubTexture name="dirtRight.png" x="648" y="504" width="70" height="70"/>
    <SubTexture name="door_closedMid.png" x="648" y="432" width="70" height="70"/>
    <SubTexture name="door_closedTop.png" x="648" y="360" width="70" height="70"/>
    <SubTexture name="door_openMid.png" x="648" y="288" width="70" height="70"/>
    <SubTexture name="door_openTop.png" x="648" y="216" width="70" height="70"/>
    <SubTexture name="fence.png" x="648" y="144" width="70" height="70"/>
    <SubTexture name="fenceBroken.png" x="648" y="72" width="70" height="70"/>
    <SubTexture name="grass.png" x="648" y="0" width="70" height="70"/>
    <SubTexture name="grassCenter.png" x="576" y="864" width="70" height="70"/>
    <SubTexture name="grassCenter_rounded.png" x="576" y="792" width="70" height="70"/>
    <SubTexture name="grassCliffLeft.png" x="576" y="720" width="70" height="70"/>
    <SubTexture name="grassCliffLeftAlt.png" x="576" y="648" width="70" height="70"/>
    <SubTexture name="grassCliffRight.png" x="576" y="576" width="70" height="70"/>
    <SubTexture name="grassCliffRightAlt.png" x="576" y="504" width="70" height="70"/>
    <SubTexture name="grassHalf.png" x="576" y="432" width="70" height="70"/>
    <SubTexture name="grassHalfLeft.png" x="576" y="360" width="70" height="70"/>
    <SubTexture name="grassHalfMid.png" x="576" y="288" width="70" height="70"/>
    <SubTexture name="grassHalfRight.png" x="576" y="216" width="70" height="70"/>
    <SubTexture name="grassHillLeft.png" x="576" y="144" width="70" height="70"/>
    <SubTexture name="grassHillLeft2.png" x="576" y="72" width="70" height="70"/>
    <SubTexture name="grassHillRight.png" x="576" y="0" width="70" height="70"/>
    <SubTexture name="grassHillRight2.png" x="504" y="864" width="70" height="70"/>
    <SubTexture name="grassLedgeLeft.png" x="849" y="868" width="5" height="24"/>
    <SubTexture name="grassLedgeRight.png" x="849" y="894" width="5" height="24"/>
    <SubTexture name="grassLeft.png" x="504" y="648" width="70" height="70"/>
    <SubTexture name="grassMid.png" x="504" y="576" width="70" height="70"/>
    <SubTexture name="grassRight.png" x="504" y="504" width="70" height="70"/>
    <SubTexture name="hill_large.png" x="842" y="720" width="48" height="146"/>
    <SubTexture name="hill_largeAlt.png" x="864" y="0" width="48" height="146"/>
    <SubTexture name="hill_small.png" x="792" y="828" width="48" height="106"/>
    <SubTexture name="hill_smallAlt.png" x="792" y="720" width="48" height="106"/>
    <SubTexture name="ladder_mid.png" x="504" y="144" width="70" height="70"/>
    <SubTexture name="ladder_top.png" x="504" y="72" width="70" height="70"/>
    <SubTexture name="liquidLava.png" x="504" y="0" width="70" height="70"/>
    <SubTexture name="liquidLavaTop.png" x="432" y="864" width="70" height="70"/>
    <SubTexture name="liquidLavaTop_mid.png" x="432" y="792" width="70" height="70"/>
    <SubTexture name="liquidWater.png" x="504" y="216" width="70" height="70"/>
    <SubTexture name="liquidWaterTop.png" x="432" y="648" width="70" height="70"/>
    <SubTexture name="liquidWaterTop_mid.png" x="432" y="576" width="70" height="70"/>
    <SubTexture name="lock_blue.png" x="432" y="504" width="70" height="70"/>
    <SubTexture name="lock_green.png" x="72" y="576" width="70" height="70"/>
    <SubTexture name="lock_red.png" x="432" y="360" width="70" height="70"/>
    <SubTexture name="lock_yellow.png" x="432" y="288" width="70" height="70"/>
    <SubTexture name="rockHillLeft.png" x="432" y="216" width="70" height="70"/>
    <SubTexture name="rockHillRight.png" x="432" y="144" width="70" height="70"/>
    <SubTexture name="ropeAttached.png" x="432" y="72" width="70" height="70"/>
    <SubTexture name="ropeHorizontal.png" x="432" y="0" width="70" height="70"/>
    <SubTexture name="ropeVertical.png" x="360" y="864" width="70" height="70"/>
    <SubTexture name="sand.png" x="360" y="792" width="70" height="70"/>
    <SubTexture name="sandCenter.png" x="576" y="864" width="70" height="70"/>
    <SubTexture name="sandCenter_rounded.png" x="576" y="792" width="70" height="70"/>
    <SubTexture name="sandCliffLeft.png" x="360" y="720" width="70" height="70"/>
    <SubTexture name="sandCliffLeftAlt.png" x="360" y="648" width="70" height="70"/>
    <SubTexture name="sandCliffRight.png" x="360" y="576" width="70" height="70"/>
    <SubTexture name="sandCliffRightAlt.png" x="360" y="504" width="70" height="70"/>
    <SubTexture name="sandHalf.png" x="360" y="432" width="70" height="70"/>
    <SubTexture name="sandHalfLeft.png" x="360" y="360" width="70" height="70"/>
    <SubTexture name="sandHalfMid.png" x="360" y="288" width="70" height="70"/>
    <SubTexture name="sandHalfRight.png" x="360" y="216" width="70" height="70"/>
    <SubTexture name="sandHillLeft.png" x="360" y="144" width="70" height="70"/>
    <SubTexture name="sandHillLeft2.png" x="360" y="72" width="70" height="70"/>
    <SubTexture name="sandHillRight.png" x="360" y="0" width="70" height="70"/>
    <SubTexture name="sandHillRight2.png" x="288" y="864" width="70" height="70"/>
    <SubTexture name="sandLedgeLeft.png" x="856" y="892" width="5" height="18"/>
    <SubTexture name="sandLedgeRight.png" x="856" y="912" width="5" height="18"/>
    <SubTexture name="sandLeft.png" x="288" y="648" width="70" height="70"/>
    <SubTexture name="sandMid.png" x="288" y="576" width="70" height="70"/>
    <SubTexture name="sandRight.png" x="288" y="504" width="70" height="70"/>
    <SubTexture name="sign.png" x="288" y="432" width="70" height="70"/>
    <SubTexture name="signExit.png" x="288" y="360" width="70" height="70"/>
    <SubTexture name="signLeft.png" x="288" y="288" width="70" height="70"/>
    <SubTexture name="signRight.png" x="288" y="216" width="70" height="70"/>
    <SubTexture name="snow.png" x="288" y="144" width="70" height="70"/>
    <SubTexture name="snowCenter.png" x="720" y="864" width="70" height="70"/>
    <SubTexture name="snowCenter_rounded.png" x="288" y="72" width="70" height="70"/>
    <SubTexture name="snowCliffLeft.png" x="288" y="0" width="70" height="70"/>
    <SubTexture name="snowCliffLeftAlt.png" x="216" y="864" width="70" height="70"/>
    <SubTexture name="snowCliffRight.png" x="216" y="792" width="70" height="70"/>
    <SubTexture name="snowCliffRightAlt.png" x="216" y="720" width="70" height="70"/>
    <SubTexture name="snowHalf.png" x="216" y="648" width="70" height="70"/>
    <SubTexture name="snowHalfLeft.png" x="216" y="576" width="70" height="70"/>
    <SubTexture name="snowHalfMid.png" x="216" y="504" width="70" height="70"/>
    <SubTexture name="snowHalfRight.png" x="216" y="432" width="70" height="70"/>
    <SubTexture name="snowHillLeft.png" x="216" y="360" width="70" height="70"/>
    <SubTexture name="snowHillLeft2.png" x="216" y="288" width="70" height="70"/>
    <SubTexture name="snowHillRight.png" x="216" y="216" width="70" height="70"/>
    <SubTexture name="snowHillRight2.png" x="216" y="144" width="70" height="70"/>
    <SubTexture name="snowLedgeLeft.png" x="863" y="868" width="5" height="18"/>
    <SubTexture name="snowLedgeRight.png" x="863" y="888" width="5" height="18"/>
    <SubTexture name="snowLeft.png" x="144" y="864" width="70" height="70"/>
    <SubTexture name="snowMid.png" x="144" y="792" width="70" height="70"/>
    <SubTexture name="snowRight.png" x="144" y="720" width="70" height="70"/>
    <SubTexture name="stone.png" x="144" y="648" width="70" height="70"/>
    <SubTexture name="stoneCenter.png" x="144" y="576" width="70" height="70"/>
    <SubTexture name="stoneCenter_rounded.png" x="144" y="504" width="70" height="70"/>
    <SubTexture name="stoneCliffLeft.png" x="144" y="432" width="70" height="70"/>
    <SubTexture name="stoneCliffLeftAlt.png" x="144" y="360" width="70" height="70"/>
    <SubTexture name="stoneCliffRight.png" x="144" y="288" width="70" height="70"/>
    <SubTexture name="stoneCliffRightAlt.png" x="144" y="216" width="70" height="70"/>
    <SubTexture name="stoneHalf.png" x="144" y="144" width="70" height="70"/>
    <SubTexture name="stoneHalfLeft.png" x="144" y="72" width="70" height="70"/>
    <SubTexture name="stoneHalfMid.png" x="144" y="0" width="70" height="70"/>
    <SubTexture name="stoneHalfRight.png" x="72" y="864" width="70" height="70"/>
    <SubTexture name="stoneHillLeft2.png" x="72" y="792" width="70" height="70"/>
    <SubTexture name="stoneHillRight2.png" x="72" y="720" width="70" height="70"/>
    <SubTexture name="stoneLedgeLeft.png" x="863" y="908" width="5" height="24"/>
    <SubTexture name="stoneLedgeRight.png" x="864" y="148" width="5" height="24"/>
    <SubTexture name="stoneLeft.png" x="72" y="504" width="70" height="70"/>
    <SubTexture name="stoneMid.png" x="72" y="432" width="70" height="70"/>
    <SubTexture name="stoneRight.png" x="72" y="360" width="70" height="70"/>
    <SubTexture name="stoneWall.png" x="72" y="288" width="70" height="70"/>
    <SubTexture name="tochLit.png" x="72" y="216" width="70" height="70"/>
    <SubTexture name="tochLit2.png" x="72" y="144" width="70" height="70"/>
    <SubTexture name="torch.png" x="72" y="72" width="70" height="70"/>
    <SubTexture name="window.png" x="72" y="0" width="70" height="70"/>
</TextureAtlas>
```

`android/assets/fonts/bandera.fnt`:

```fnt
info face="BanderaProMedium" size=32 bold=0 italic=0 charset="" unicode=0 stretchH=100 smooth=1 aa=1 padding=0,0,0,0 spacing=0,0
common lineHeight=33 base=27 scaleW=512 scaleH=512 pages=1 packed=0
page id=0 file="bandera.png"
chars count=95
char id=32   x=0     y=0     width=0     height=0     xoffset=0     yoffset=27    xadvance=9     page=0  chnl=0 
char id=92   x=0     y=0     width=19     height=34     xoffset=-1     yoffset=2    xadvance=16     page=0  chnl=0 
char id=47   x=19     y=0     width=19     height=34     xoffset=-1     yoffset=2    xadvance=16     page=0  chnl=0 
char id=124   x=38     y=0     width=6     height=34     xoffset=4     yoffset=2    xadvance=12     page=0  chnl=0 
char id=106   x=44     y=0     width=14     height=32     xoffset=-3     yoffset=4    xadvance=9     page=0  chnl=0 
char id=125   x=58     y=0     width=12     height=31     xoffset=0     yoffset=3    xadvance=14     page=0  chnl=0 
char id=123   x=70     y=0     width=12     height=31     xoffset=3     yoffset=3    xadvance=14     page=0  chnl=0 
char id=41   x=82     y=0     width=10     height=31     xoffset=1     yoffset=3    xadvance=12     page=0  chnl=0 
char id=40   x=92     y=0     width=9     height=31     xoffset=3     yoffset=3    xadvance=12     page=0  chnl=0 
char id=64   x=101     y=0     width=31     height=29     xoffset=1     yoffset=6    xadvance=32     page=0  chnl=0 
char id=81   x=132     y=0     width=24     height=28     xoffset=1     yoffset=5    xadvance=25     page=0  chnl=0 
char id=93   x=156     y=0     width=12     height=26     xoffset=0     yoffset=4    xadvance=13     page=0  chnl=0 
char id=91   x=168     y=0     width=11     height=26     xoffset=3     yoffset=4    xadvance=13     page=0  chnl=0 
char id=63   x=179     y=0     width=15     height=26     xoffset=0     yoffset=2    xadvance=15     page=0  chnl=0 
char id=33   x=194     y=0     width=7     height=26     xoffset=3     yoffset=2    xadvance=12     page=0  chnl=0 
char id=121   x=201     y=0     width=20     height=26     xoffset=-1     yoffset=10    xadvance=17     page=0  chnl=0 
char id=113   x=221     y=0     width=19     height=26     xoffset=1     yoffset=10    xadvance=19     page=0  chnl=0 
char id=112   x=240     y=0     width=20     height=26     xoffset=1     yoffset=10    xadvance=20     page=0  chnl=0 
char id=108   x=260     y=0     width=9     height=26     xoffset=1     yoffset=2    xadvance=10     page=0  chnl=0 
char id=107   x=269     y=0     width=19     height=26     xoffset=1     yoffset=2    xadvance=19     page=0  chnl=0 
char id=104   x=288     y=0     width=19     height=26     xoffset=1     yoffset=2    xadvance=20     page=0  chnl=0 
char id=103   x=307     y=0     width=17     height=26     xoffset=1     yoffset=10    xadvance=17     page=0  chnl=0 
char id=102   x=324     y=0     width=15     height=26     xoffset=1     yoffset=2    xadvance=12     page=0  chnl=0 
char id=100   x=339     y=0     width=19     height=26     xoffset=1     yoffset=2    xadvance=20     page=0  chnl=0 
char id=98   x=358     y=0     width=20     height=26     xoffset=0     yoffset=2    xadvance=19     page=0  chnl=0 
char id=36   x=378     y=0     width=16     height=25     xoffset=0     yoffset=5    xadvance=15     page=0  chnl=0 
char id=53   x=394     y=0     width=16     height=24     xoffset=1     yoffset=4    xadvance=17     page=0  chnl=0 
char id=105   x=410     y=0     width=9     height=24     xoffset=1     yoffset=4    xadvance=10     page=0  chnl=0 
char id=38   x=419     y=0     width=22     height=23     xoffset=1     yoffset=5    xadvance=23     page=0  chnl=0 
char id=37   x=441     y=0     width=30     height=23     xoffset=1     yoffset=5    xadvance=31     page=0  chnl=0 
char id=48   x=471     y=0     width=19     height=23     xoffset=2     yoffset=5    xadvance=21     page=0  chnl=0 
char id=57   x=490     y=0     width=19     height=23     xoffset=1     yoffset=5    xadvance=20     page=0  chnl=0 
char id=56   x=0     y=34     width=19     height=23     xoffset=1     yoffset=5    xadvance=20     page=0  chnl=0 
char id=55   x=19     y=34     width=17     height=23     xoffset=0     yoffset=5    xadvance=16     page=0  chnl=0 
char id=54   x=36     y=34     width=17     height=23     xoffset=2     yoffset=5    xadvance=20     page=0  chnl=0 
char id=51   x=53     y=34     width=16     height=23     xoffset=1     yoffset=5    xadvance=18     page=0  chnl=0 
char id=50   x=69     y=34     width=17     height=23     xoffset=1     yoffset=5    xadvance=18     page=0  chnl=0 
char id=49   x=86     y=34     width=12     height=23     xoffset=1     yoffset=5    xadvance=14     page=0  chnl=0 
char id=116   x=98     y=34     width=12     height=23     xoffset=1     yoffset=5    xadvance=13     page=0  chnl=0 
char id=90   x=110     y=34     width=19     height=23     xoffset=1     yoffset=5    xadvance=20     page=0  chnl=0 
char id=89   x=129     y=34     width=25     height=23     xoffset=-1     yoffset=5    xadvance=21     page=0  chnl=0 
char id=88   x=154     y=34     width=25     height=23     xoffset=-1     yoffset=5    xadvance=23     page=0  chnl=0 
char id=87   x=179     y=34     width=36     height=23     xoffset=-1     yoffset=5    xadvance=33     page=0  chnl=0 
char id=86   x=215     y=34     width=25     height=23     xoffset=-1     yoffset=5    xadvance=22     page=0  chnl=0 
char id=85   x=240     y=34     width=25     height=23     xoffset=0     yoffset=5    xadvance=24     page=0  chnl=0 
char id=84   x=265     y=34     width=21     height=23     xoffset=-1     yoffset=5    xadvance=18     page=0  chnl=0 
char id=83   x=286     y=34     width=17     height=23     xoffset=1     yoffset=5    xadvance=18     page=0  chnl=0 
char id=82   x=303     y=34     width=22     height=23     xoffset=0     yoffset=5    xadvance=21     page=0  chnl=0 
char id=80   x=325     y=34     width=20     height=23     xoffset=0     yoffset=5    xadvance=19     page=0  chnl=0 
char id=79   x=345     y=34     width=24     height=23     xoffset=1     yoffset=5    xadvance=25     page=0  chnl=0 
char id=78   x=369     y=34     width=26     height=23     xoffset=0     yoffset=5    xadvance=25     page=0  chnl=0 
char id=77   x=395     y=34     width=33     height=23     xoffset=0     yoffset=5    xadvance=33     page=0  chnl=0 
char id=76   x=428     y=34     width=19     height=23     xoffset=1     yoffset=5    xadvance=19     page=0  chnl=0 
char id=75   x=447     y=34     width=24     height=23     xoffset=1     yoffset=5    xadvance=24     page=0  chnl=0 
char id=74   x=471     y=34     width=15     height=23     xoffset=0     yoffset=5    xadvance=15     page=0  chnl=0 
char id=73   x=486     y=34     width=11     height=23     xoffset=1     yoffset=5    xadvance=12     page=0  chnl=0 
char id=72   x=0     y=57     width=24     height=23     xoffset=1     yoffset=5    xadvance=25     page=0  chnl=0 
char id=70   x=24     y=57     width=19     height=23     xoffset=1     yoffset=5    xadvance=19     page=0  chnl=0 
char id=69   x=43     y=57     width=19     height=23     xoffset=1     yoffset=5    xadvance=20     page=0  chnl=0 
char id=68   x=62     y=57     width=24     height=23     xoffset=1     yoffset=5    xadvance=25     page=0  chnl=0 
char id=67   x=86     y=57     width=21     height=23     xoffset=1     yoffset=5    xadvance=21     page=0  chnl=0 
char id=66   x=107     y=57     width=21     height=23     xoffset=0     yoffset=5    xadvance=21     page=0  chnl=0 
char id=65   x=128     y=57     width=26     height=23     xoffset=-1     yoffset=5    xadvance=23     page=0  chnl=0 
char id=52   x=154     y=57     width=19     height=22     xoffset=0     yoffset=6    xadvance=19     page=0  chnl=0 
char id=71   x=173     y=57     width=21     height=22     xoffset=1     yoffset=6    xadvance=23     page=0  chnl=0 
char id=59   x=194     y=57     width=7     height=21     xoffset=2     yoffset=12    xadvance=10     page=0  chnl=0 
char id=35   x=201     y=57     width=17     height=18     xoffset=1     yoffset=8    xadvance=18     page=0  chnl=0 
char id=122   x=218     y=57     width=15     height=18     xoffset=1     yoffset=10    xadvance=16     page=0  chnl=0 
char id=120   x=233     y=57     width=20     height=18     xoffset=0     yoffset=10    xadvance=19     page=0  chnl=0 
char id=119   x=253     y=57     width=29     height=18     xoffset=-1     yoffset=10    xadvance=26     page=0  chnl=0 
char id=118   x=282     y=57     width=20     height=18     xoffset=-1     yoffset=10    xadvance=17     page=0  chnl=0 
char id=117   x=302     y=57     width=20     height=18     xoffset=0     yoffset=10    xadvance=20     page=0  chnl=0 
char id=115   x=322     y=57     width=16     height=18     xoffset=0     yoffset=10    xadvance=15     page=0  chnl=0 
char id=114   x=338     y=57     width=14     height=18     xoffset=1     yoffset=10    xadvance=15     page=0  chnl=0 
char id=111   x=352     y=57     width=19     height=18     xoffset=1     yoffset=10    xadvance=19     page=0  chnl=0 
char id=110   x=371     y=57     width=20     height=18     xoffset=1     yoffset=10    xadvance=20     page=0  chnl=0 
char id=109   x=391     y=57     width=28     height=18     xoffset=1     yoffset=10    xadvance=29     page=0  chnl=0 
char id=101   x=419     y=57     width=17     height=18     xoffset=1     yoffset=10    xadvance=17     page=0  chnl=0 
char id=99   x=436     y=57     width=16     height=18     xoffset=1     yoffset=10    xadvance=16     page=0  chnl=0 
char id=97   x=452     y=57     width=17     height=18     xoffset=1     yoffset=10    xadvance=17     page=0  chnl=0 
char id=127   x=469     y=57     width=18     height=17     xoffset=2     yoffset=9    xadvance=21     page=0  chnl=0 
char id=58   x=487     y=57     width=5     height=16     xoffset=3     yoffset=12    xadvance=10     page=0  chnl=0 
char id=42   x=492     y=57     width=16     height=15     xoffset=0     yoffset=3    xadvance=15     page=0  chnl=0 
char id=43   x=0     y=80     width=16     height=15     xoffset=0     yoffset=11    xadvance=15     page=0  chnl=0 
char id=62   x=16     y=80     width=12     height=15     xoffset=1     yoffset=10    xadvance=14     page=0  chnl=0 
char id=60   x=28     y=80     width=12     height=15     xoffset=2     yoffset=10    xadvance=14     page=0  chnl=0 
char id=44   x=40     y=80     width=7     height=11     xoffset=1     yoffset=22    xadvance=8     page=0  chnl=0 
char id=61   x=47     y=80     width=17     height=10     xoffset=1     yoffset=13    xadvance=18     page=0  chnl=0 
char id=39   x=64     y=80     width=5     height=9     xoffset=1     yoffset=3    xadvance=7     page=0  chnl=0 
char id=34   x=69     y=80     width=11     height=9     xoffset=1     yoffset=3    xadvance=13     page=0  chnl=0 
char id=126   x=80     y=80     width=22     height=8     xoffset=0     yoffset=12    xadvance=22     page=0  chnl=0 
char id=94   x=102     y=80     width=12     height=8     xoffset=1     yoffset=5    xadvance=13     page=0  chnl=0 
char id=96   x=114     y=80     width=9     height=6     xoffset=-1     yoffset=4    xadvance=8     page=0  chnl=0 
char id=46   x=123     y=80     width=5     height=5     xoffset=3     yoffset=23    xadvance=10     page=0  chnl=0 
char id=95   x=128     y=80     width=23     height=4     xoffset=1     yoffset=29    xadvance=24     page=0  chnl=0 
char id=45   x=151     y=80     width=11     height=4     xoffset=1     yoffset=16    xadvance=11     page=0  chnl=0 

```

`android/assets/general.txt`:

```txt
# FORMAT:
# var name		path to file													type of file

# Music
bgmusic			music/peaceful_forest.mp3										Music

# SFX
jump			sfx/jump.wav													Sound
player_death	sfx/player_death.wav											Sound

slime_hit		sfx/monsters/slime/slime_hit.wav								Sound
slime_die		sfx/monsters/slime/slime_die.wav								Sound
alien_attack	sfx/monsters/alien/alien_attack.wav								Sound
alien_chardmg	sfx/monsters/alien/alien_chardmg.wav							Sound
alien_hit		sfx/monsters/alien/alien_hit.wav								Sound
alien_die		sfx/monsters/alien/alien_die.wav								Sound
zombie_hit	sfx/monsters/zombie/zombie_hit.wav							Sound
zombie_die	sfx/monsters/zombie/zombie_die.wav							Sound
plateon_hit	sfx/monsters/plateon/plateon_hit.wav							Sound
plateon_die	sfx/monsters/plateon/plateon_die.wav							Sound

genericCast	sfx/generic/cast1.wav	Sound
genericCast2 	sfx/generic/cast2.wav	Sound

pill			sfx/pickups/pill.wav											Sound
potion			sfx/pickups/potion.wav											Sound

# Projectiles
iceball			textures/entities/projectiles/iceball/iceball.pack				TextureAtlas
swing			textures/entities/projectiles/swing/swing.pack					TextureAtlas
explosion		textures/entities/projectiles/explosion/explosion.pack				TextureAtlas
magicbolt		textures/entities/projectiles/magicbolt/magicbolt.pack				TextureAtlas
swirlingmoon		textures/entities/projectiles/swirlingmoon/swirlingmoon.pack			TextureAtlas
icespike		textures/entities/projectiles/icespike/icespike.pack				TextureAtlas

# HUD Stuff
hud_bars		textures/hud/bars/hud_bars.pack									TextureAtlas
hitMonster		textures/hud/damage/hitMonster/hitMonster.pack					TextureAtlas
hitMonsterCrit	textures/hud/damage/hitMonsterCrit/hitMonsterCrit.pack			TextureAtlas
hitPlayer		textures/hud/damage/hitPlayer/hitPlayer.pack					TextureAtlas

# Debug Rendering Hitbox
hitbox			textures/debug.png     											Texture

#Pickup Items
pickups			textures/entities/pickups/pickups.pack							TextureAtlas
```

`android/assets/highScore.dat`:

```dat
[
{
	"name": "Kevin Xiao",
	"score": 9001
},
{
	"name": "Andrew Jiang",
	"score": 1337
},
{
	"name": "Samuel Zhou",
	"score": 420
},
{
	"name": "",
	"score": 0
},
{
	"name": "",
	"score": 0
}
]
```

`android/assets/keys/SavedLayout.txt`:

```txt
# Example of custom config
melee	N
```

`android/assets/levels/levels.txt`:

```txt
tombstone	textures/entities/player/tombstone.pack		TextureAtlas
grey_slime    textures/entities/monsters/grey_slime/grey_slime.pack    TextureAtlas
alien		textures/entities/monsters/alien/alien.pack	TextureAtlas


# Level tile map
su_grass  	levels/survival_grass.tmx    	TiledMap
su_hell		levels/survival_hell.tmx		TiledMap
su_moon		levels/survival_moon.tmx		TiledMap

# Level Background
background_sky      textures/levels/blue.png    Texture
background_fuji     textures/levels/fuji.png     Texture
background_sakura     textures/levels/sakuratrees.png      Texture

background_hell			textures/levels/hell_back.png		Texture
background_hell_rock	textures/levels/hell_rocks.png		Texture

background_night		textures/levels/night_back.png		Texture
```

`android/assets/levels/survival_grass.tmx`:

```tmx
<?xml version="1.0" encoding="UTF-8"?>
<map version="1.0" orientation="orthogonal" renderorder="right-down" width="64" height="48" tilewidth="32" tileheight="32" nextobjectid="44">
 <properties>
  <property name="mapName" value="su_grass" />
  <property name="defaultMobLevel" value="0"/>
  <property name="defaultSpawnAmount" value="5"/>
  <property name="levelName" value="Forest Survival"/>
  <property name="parallaxBackground" value="background_sky"/>
  <property name="parallaxForeground" value="background_sakura"/>
  <property name="parallaxMidground" value="background_fuji"/>
  <property name="spawnX" value="24"/>
  <property name="spawnY" value="6"/>
  <property name="theme" value="grass"/>
 </properties>
 <tileset firstgid="1" name="tileset" tilewidth="32" tileheight="32" spacing="1">
  <image source="../textures/levels/tileset.png" width="858" height="32"/>
  <tile id="3">
   <properties>
    <property name="climbable" value=""/>
   </properties>
  </tile>
  <tile id="5">
   <properties>
    <property name="climbable" value=""/>
   </properties>
  </tile>
  <tile id="6">
   <properties>
    <property name="slope" value="1"/>
   </properties>
  </tile>
  <tile id="8">
   <properties>
    <property name="slope" value="-1"/>
   </properties>
  </tile>
  <tile id="10">
   <properties>
    <property name="interactable" value="nextLevel"/>
    <property name="nextLevel" value="su_hell"/>
   </properties>
  </tile>
  <tile id="11">
   <properties>
    <property name="platform" value=""/>
   </properties>
  </tile>
  <tile id="14">
   <properties>
    <property name="slope" value="1"/>
   </properties>
  </tile>
  <tile id="16">
   <properties>
    <property name="slope" value="-1"/>
   </properties>
  </tile>
  <tile id="18">
   <properties>
    <property name="platform" value=""/>
   </properties>
  </tile>
  <tile id="21">
   <properties>
    <property name="slope" value="1"/>
   </properties>
  </tile>
  <tile id="23">
   <properties>
    <property name="slope" value="-1"/>
   </properties>
  </tile>
  <tile id="25">
   <properties>
    <property name="platform" value=""/>
   </properties>
  </tile>
 </tileset>
 <layer name="Static Map" width="64" height="48">
  <data encoding="base64" compression="zlib">
   eJzt0sEJACAMBMHo0/4L9mUHSjicgS3gQqoAAAAAAAAAAAAAIMcM6oUR1Pp8/7nBzZ/q3qPeNuBpAWg=
  </data>
 </layer>
 <layer name="Dynamic Map" width="64" height="48">
  <data encoding="base64" compression="zlib">
   eJzt1jEKwDAMBEG7DOT/780L3MU6gWbAvTBX7FoAAGdvkwcAcEu6c7QQ1eyLyewf8l2jhahmT0xm/5DvGD1ENdthMvunuyd9QAP+gD/t9AFhH9J8CSw=
  </data>
 </layer>
 <layer name="Trigger Tile" width="64" height="48">
  <data encoding="base64" compression="zlib">
   eJzt0MEJgEAQBEEFf+afryGoCC5HV0UwPdsGADxxTg9Y3DE9YJj+Nv1t+tv0c6f+kf42/W362/SvbfX9X+lv09+mv00/f6t/rr9Nf5v+tno/8M4+PWDYBTsGAJk=
  </data>
 </layer>
 <layer name="Foreground" width="64" height="48">
  <data encoding="base64" compression="zlib">
   eJztz7EJAAAIA0Et3H9lG3cQ9A6+TyIAAAAAAAAAAAAA7qrpq+//gVtye8CyBq9oABY=
  </data>
 </layer>
 <objectgroup name="Spawn">
  <object id="33" x="250.667" y="1366.67">
   <polyline points="5.33333,9.33333 1061.33,9.33333"/>
  </object>
  <object id="35" x="384" y="256">
   <polyline points="0,0 1024,0"/>
  </object>
  <object id="37" x="1504" y="544">
   <polyline points="0,0 -1248,0"/>
  </object>
  <object id="38" x="224" y="832">
   <polyline points="0,0 1376,0"/>
  </object>
  <object id="39" x="128" y="928">
   <polyline points="0,0 64,0"/>
  </object>
  <object id="40" x="160" y="640">
   <polyline points="0,0 64,0"/>
  </object>
  <object id="41" x="96" y="1312">
   <polyline points="0,0 64,0"/>
  </object>
  <object id="42" x="1472" y="1440">
   <polyline points="0,0 544,0"/>
  </object>
  <object id="43" x="1728" y="1120">
   <polyline points="0,0 -1536,0"/>
  </object>
 </objectgroup>
</map>

```

`android/assets/levels/survival_hell.tmx`:

```tmx
<?xml version="1.0" encoding="UTF-8"?>
<map version="1.0" orientation="orthogonal" renderorder="right-down" width="64" height="48" tilewidth="32" tileheight="32" nextobjectid="54">
 <properties>
  <property name="mapName" value="su_hell" />
  <property name="defaultMobLevel" value="0"/>
  <property name="defaultSpawnAmount" value="5"/>
  <property name="levelName" value="Welcome to Hell"/>
  <property name="parallaxBackground" value="background_hell"/>
  <property name="parallaxForeground" value="blank"/>
  <property name="parallaxMidground" value="background_hell_rock"/>
  <property name="spawnX" value="3"/>
  <property name="spawnY" value="5"/>
  <property name="theme" value="hell"/>
 </properties>
 <tileset firstgid="1" name="tileset" tilewidth="32" tileheight="32" spacing="1">
  <image source="../textures/levels/tileset.png" width="858" height="32"/>
  <tile id="3">
   <properties>
    <property name="climbable" value=""/>
   </properties>
  </tile>
  <tile id="5">
   <properties>
    <property name="climbable" value=""/>
   </properties>
  </tile>
  <tile id="6">
   <properties>
    <property name="slope" value="1"/>
   </properties>
  </tile>
  <tile id="8">
   <properties>
    <property name="slope" value="-1"/>
   </properties>
  </tile>
  <tile id="10">
   <properties>
    <property name="interactable" value="nextLevel"/>
    <property name="nextLevel" value="level1"/>
   </properties>
  </tile>
  <tile id="11">
   <properties>
    <property name="platform" value=""/>
   </properties>
  </tile>
  <tile id="14">
   <properties>
    <property name="slope" value="1"/>
   </properties>
  </tile>
  <tile id="16">
   <properties>
    <property name="slope" value="-1"/>
   </properties>
  </tile>
  <tile id="18">
   <properties>
    <property name="platform" value=""/>
   </properties>
  </tile>
  <tile id="21">
   <properties>
    <property name="slope" value="1"/>
   </properties>
  </tile>
  <tile id="23">
   <properties>
    <property name="slope" value="-1"/>
   </properties>
  </tile>
  <tile id="25">
   <properties>
    <property name="platform" value=""/>
   </properties>
  </tile>
 </tileset>
 <layer name="Static Map" width="64" height="48">
  <data encoding="base64" compression="zlib">
   eJzt1DEOgCAQRUEuoDHe/7BqZwcIZBVnklfL38KUAAAAAAAAAAAYac00s+1sybSHvW6sku2z3qBm+2w3eLL9DTfI/adKatl+v0HNN3vo8e6o/ry9df/Xt7fsn2H7VdR/SpKiOwDcch/l
  </data>
 </layer>
 <layer name="Dynamic Map" width="64" height="48">
  <data encoding="base64" compression="zlib">
   eJzt1kEOgCAMRFEuYIzx/nc1Lrq2QqG0/S9hRwIzYKQ1AAAAAAAAoKY70IANuoTgLtTDmUPL+58/+z3At1BPxjPPmGmFjL1FynQq5lzGa+7Sjya7+Opgl0xaf7IL63vw8uitJ7uY0cFKI9lFbwcj70qLfUdF9prIDgCxHd4bcPYA0DYIng==
  </data>
 </layer>
 <layer name="Trigger Tile" width="64" height="48">
  <data encoding="base64" compression="zlib">
   eJztz7ENwDAAw7AMWfP/u32igAaTuwHrHAAAAADgD7c+ENO/Tf82/dv0t/ua/nZf09/ua/q36d+mHwCA2qsPxD65OQBy
  </data>
 </layer>
 <layer name="Foreground" width="64" height="48">
  <data encoding="base64" compression="zlib">
   eJztz7kNACAMBEEa4Om/WiAmxsJiRrrU1pYCAAAAAAAAAAAAAKe+1h5chN0+gn69RvufsrTXCzeztG8T4XACvg==
  </data>
 </layer>
 <objectgroup name="Spawn">
  <object id="46" x="608" y="1216">
   <polyline points="0,0 480,0"/>
  </object>
  <object id="47" x="1280" y="1056">
   <polyline points="0,0 256,0"/>
  </object>
  <object id="48" x="1696" y="1216">
   <polyline points="0,0 320,0"/>
  </object>
  <object id="50" x="512" y="864">
   <polyline points="0,0 1184,0"/>
  </object>
  <object id="51" x="1568" y="608">
   <polyline points="0,0 -1312,0"/>
  </object>
  <object id="52" x="352" y="1216">
   <polyline points="0,0 -96,0"/>
  </object>
  <object id="53" x="192" y="1216">
   <polyline points="0,0 -96,0"/>
  </object>
 </objectgroup>
</map>

```

`android/assets/levels/survival_moon.tmx`:

```tmx
<?xml version="1.0" encoding="UTF-8"?>
<map version="1.0" orientation="orthogonal" renderorder="right-down" width="64" height="48" tilewidth="32" tileheight="32" nextobjectid="67">
 <properties>
  <property name="mapName" value="su_moon" />
  <property name="defaultMobLevel" value="0"/>
  <property name="defaultSpawnAmount" value="5"/>
  <property name="levelName" value="Moon Survival"/>
  <property name="parallaxBackground" value="background_night"/>
  <property name="parallaxForeground" value="blank"/>
  <property name="parallaxMidground" value="blank"/>
  <property name="spawnX" value="31"/>
  <property name="spawnY" value="6"/>
  <property name="theme" value="space"/>
 </properties>
 <tileset firstgid="1" name="tileset" tilewidth="32" tileheight="32" spacing="1">
  <image source="../textures/levels/tileset.png" width="858" height="32"/>
  <tile id="3">
   <properties>
    <property name="climbable" value=""/>
   </properties>
  </tile>
  <tile id="5">
   <properties>
    <property name="climbable" value=""/>
   </properties>
  </tile>
  <tile id="6">
   <properties>
    <property name="slope" value="1"/>
   </properties>
  </tile>
  <tile id="8">
   <properties>
    <property name="slope" value="-1"/>
   </properties>
  </tile>
  <tile id="10">
   <properties>
    <property name="interactable" value="nextLevel"/>
    <property name="nextLevel" value="level1"/>
   </properties>
  </tile>
  <tile id="11">
   <properties>
    <property name="platform" value=""/>
   </properties>
  </tile>
  <tile id="14">
   <properties>
    <property name="slope" value="1"/>
   </properties>
  </tile>
  <tile id="16">
   <properties>
    <property name="slope" value="-1"/>
   </properties>
  </tile>
  <tile id="18">
   <properties>
    <property name="platform" value=""/>
   </properties>
  </tile>
  <tile id="21">
   <properties>
    <property name="slope" value="1"/>
   </properties>
  </tile>
  <tile id="23">
   <properties>
    <property name="slope" value="-1"/>
   </properties>
  </tile>
  <tile id="25">
   <properties>
    <property name="platform" value=""/>
   </properties>
  </tile>
 </tileset>
 <layer name="Static Map" width="64" height="48">
  <data encoding="base64" compression="zlib">
   eJzt1EEKgDAMBMA8QhH//1GvvUUhVlNmYM/tLtUIAAAAAAAAAACgqz1Jd1m/Lck5/8pljsj73UnHDaq6d9yguvu4QfY9Vf8/np73Vvcv3s3fuszcYJXu4wZd37CIrJkLxjgrEw==
  </data>
 </layer>
 <layer name="Dynamic Map" width="64" height="48">
  <data encoding="base64" compression="zlib">
   eJzt1MsNgCAQBUCKMMbYf6GeKEBcfutMwpXwHgulAAAAAAAAf3RvugCIMfof9u/n4v7IYPQcz3w3V6d9RziD9tmxg6jsVY8Oes1tdPZqhznolb3Vl85Wy9KqpYMs2as3HWTLDqzpmH2AyR664wwb
  </data>
 </layer>
 <layer name="Trigger Tile" width="64" height="48">
  <data encoding="base64" compression="zlib">
   eJztz6ERACAQA8EXlED/teIRCARhYLeB5KoAAAAAAIDftfSBhRPf9N9L/xsbu/QDAAAAMOvpA2EDNJwARQ==
  </data>
 </layer>
 <layer name="Foreground" width="64" height="48">
  <data encoding="base64" compression="zlib">
   eJztz6ERAEAIA0EMHXz/tWJo4FUEuzPnkyoAAAAAAAAAAIB/vV11/T8AQMJLDwgbIDcAKQ==
  </data>
 </layer>
 <objectgroup name="Spawn">
  <object id="55" x="768" y="960">
   <polyline points="0,0 -384,0"/>
  </object>
  <object id="56" x="1280" y="960">
   <polyline points="0,0 384,0"/>
  </object>
  <object id="57" x="1344" y="1120">
   <polyline points="0,0 256,0"/>
  </object>
  <object id="58" x="1152" y="1024">
   <polyline points="0,0 -256,0"/>
  </object>
  <object id="59" x="704" y="1120">
   <polyline points="0,0 -256,0"/>
  </object>
  <object id="61" x="32" y="1152">
   <polyline points="0,0 224,0"/>
  </object>
  <object id="62" x="384" y="1280">
   <polyline points="0,0 384,0"/>
  </object>
  <object id="63" x="864" y="1376">
   <polyline points="0,0 320,0"/>
  </object>
  <object id="64" x="1280" y="1280">
   <polyline points="0,0 384,0"/>
  </object>
  <object id="65" x="1792" y="1152">
   <polyline points="0,0 224,0"/>
  </object>
  <object id="66" x="320" y="768">
   <polyline points="0,0 1408,0"/>
  </object>
 </objectgroup>
</map>

```

`android/assets/menus/LoadMenu.xml`:

```xml
<menu>
    <scrollPane type="save" x="150" y="500" height="300" width="900">
        <directory>saves</directory>
    </scrollPane>
    <button x="centre-left" y="75">
        <name>Back</name>
        <textureName>button_back</textureName>
        <onClick type="setMenu">Previous</onClick>
    </button>
    <button x="centre-right" y="75">
        <name>Load</name>
        <textureName>button_load</textureName>
        <onClick type="getScrollPaneParam"/>
    </button>
</menu>
```

`android/assets/menus/MainMenu.xml`:

```xml
<menu>
    <button x="centre" y="375">
        <name>Play</name>
        <textureName>button_play</textureName>
        <onClick type="setMenu" prevCmd="play">PlayMenu</onClick>
    </button>
    <button x="centre" y="275">
        <name>Options</name>
        <textureName>button_options</textureName>
        <onClick type="setMenu">OptionsMenu</onClick>
    </button>
    <button x="centre" y="175">
        <name>Highscore</name>
        <textureName>button_highscore</textureName>
        <onClick type="setMenuInternal">HighScoreMenu</onClick>
    </button>
    <button x="centre" y="75">
        <name>Quit</name>
        <textureName>button_quit</textureName>
        <onClick type="cmd">Quit</onClick>
    </button>
</menu>
```

`android/assets/menus/ModeMenu.xml`:

```xml
<menu>
    <button x="centre" y="275">
        <name>Story</name>
        <textureName>button_story</textureName>
        <onClick type="setMenu" prevCmd="standard">SelectCharMenu</onClick>
    </button>
    <button x="centre" y="175">
        <name>Survival</name>
        <textureName>button_survival</textureName>
        <onClick type="setMenu" prevCmd="survival">SelectCharMenu</onClick>
    </button>
    <button x="centre" y="75">
        <name>Back</name>
        <textureName>button_back</textureName>
        <onClick type="setMenu">Previous</onClick>
    </button>
</menu>
```

`android/assets/menus/OptionsMenu.xml`:

```xml
<menu>
    <button x="centre" y="275">
        <name>General</name>
        <textureName>button_general</textureName>
        <onClick type="setMenuInternal">GeneralSettingsMenu</onClick>
    </button>
    <button x="centre" y="175">
        <name>Key Layout</name>
        <textureName>button_layout</textureName>
        <onClick type="setMenuInternal">KeyLayoutMenu</onClick>
    </button>
    <button x="centre" y="75">
        <name>Back</name>
        <textureName>button_back</textureName>
        <onClick type="setMenu">Previous</onClick>
    </button>
</menu>
```

`android/assets/menus/PauseMenu.xml`:

```xml
<menu>
    <button x="centre" y="375">
        <name>Back</name>
        <textureName>button_back</textureName>
        <onClick type="cmd">unPauseGame</onClick>
    </button>
    <button x="centre" y="275">
        <name>Save</name>
        <textureName>button_save</textureName>
        <onClick type="setMenu">SaveMenu</onClick>
    </button>
    <button x="centre" y="175">
        <name>Options</name>
        <textureName>button_options</textureName>
        <onClick type="setMenuInternal">KeyLayoutMenu</onClick>
    </button>
    <button x="centre" y="75">
        <name>Quit</name>
        <textureName>button_mainmenu</textureName>
        <onClick type="setMenu">MainMenu</onClick>
    </button>
</menu>
```

`android/assets/menus/PlayMenu.xml`:

```xml
<menu>
    <button x="centre" y="275">
        <name>New</name>
        <textureName>button_new</textureName>
        <onClick type="setMenu" prevCmd="new,survival">SelectCharMenu</onClick>
    </button>
    <button x="centre" y="175">
        <name>Load</name>
        <textureName>button_load</textureName>
        <onClick type="setMenu" prevCmd="load">LoadMenu</onClick>
    </button>
    <button x="centre" y="75">
        <name>Back</name>
        <textureName>button_back</textureName>
        <onClick type="setMenu">Previous</onClick>
    </button>
</menu>
```

`android/assets/menus/SaveMenu.xml`:

```xml
<menu>
    <scrollPane type="save" x="150" y="500" height="300" width="900">
        <directory>saves</directory>
    </scrollPane>
    <button x="centre-left" y="75">
        <name>Back</name>
        <textureName>button_back</textureName>
        <onClick type="setMenu">Previous</onClick>
    </button>
    <button x="centre" y="75">
        <name>New Save</name>
        <textureName>button_new</textureName>
        <onClick type="cmd">saveGame,new</onClick>
    </button>
    <button x="centre-right" y="75">
        <name>Overwrite Save</name>
        <textureName>button_overwrite</textureName>
        <onClick type="getScrollPaneParam">saveGame,overwrite</onClick>
    </button>
</menu>
```

`android/assets/menus/SelectCharMenu.xml`:

```xml
<menu>
    <scrollPane type="animated" playAnim="true" x="215" y="500" width="850">
        <idleAnimName duration=".667">stand1</idleAnimName>
        <activeAnimName duration=".167">walk1</activeAnimName>
        <values prettyName="Icy" type="TextureAtlas">player</values>
        <values prettyName="Fabulous HotDog Man" type="TextureAtlas">fabulous</values>
        <values prettyName="Kirito" type="TextureAtlas">kirito</values>
    </scrollPane>
    <button x="150" y="100">
        <name>Back</name>
        <textureName>button_back</textureName>
        <onClick type="setMenu">previous</onClick>
    </button>
    <button x="975" y="100">
        <name>Next</name>
        <textureName>button_next</textureName>
        <onClick type="setMenu" prevCmd="getScrollPaneParam">SelectMapMenu</onClick>
    </button>
</menu>
```

`android/assets/menus/SelectMapMenu.xml`:

```xml
<menu>
    <scrollPane type="animated" playAnim="false" x="215" y="500" width="850">
        <idleAnimName duration=".667">stand2</idleAnimName>
        <activeAnimName duration=".167">walk1</activeAnimName>
        <values prettyName="Grass" type="Texture">su_grass</values>
        <values prettyName="Hell" type="Texture">su_hell</values>
        <values prettyName="Moon" type="Texture">su_moon</values>
    </scrollPane>
    <button x="150" y="100">
        <name>Back</name>
        <textureName>button_back</textureName>
        <onClick type="setMenu">previous</onClick>
    </button>
    <button x="975" y="100">
        <name>Start</name>
        <textureName>button_start</textureName>
        <onClick type="getScrollPaneParam" />
    </button>
</menu>
```

`android/assets/menus/loading_screen.txt`:

```txt
menu_loadingbar    textures/menu/loadingbar/menu_loadingbar.pack    TextureAtlas
```

`android/assets/menus/main_menu.txt`:

```txt
menu_buttons	textures/menu/buttons/menu_buttons.pack							TextureAtlas
menu_background		textures/menu/background/background.png						Texture
highscore_header	textures/menu/misc/highscore_header.png						Texture

su_grass_image		textures/levels/survival_forest_image.png					Texture
su_hell_image		textures/levels/survival_hell_image.png						Texture
su_moon_image		textures/levels/survival_moon_image.png						Texture

# Fonts
font_bandera		fonts/bandera.fnt	BitmapFont

# Atlas for player
player    textures/entities/player/player.pack    TextureAtlas
Alice    textures/entities/player/Alice.pack    TextureAtlas
fabulous	textures/entities/player/fabulous.pack    TextureAtlas
kirito    textures/entities/player/kirito.pack    TextureAtlas


#Sounds
menu_music		music/tale_east.mp3												Music
menu_hit		sfx/menu/menu_hit.wav											Sound
menu_hover		sfx/menu/menu_hover.wav											Sound

#blank png
blank			blank.png										Texture
```

`android/assets/shaders/passthrough.fsh`:

```fsh
varying vec4 v_color;
varying vec2 v_texCoord0;

uniform sampler2D u_sampler2D;

void main() {
	gl_FragColor = texture2D(u_sampler2D, v_texCoord0) * v_color;
}

```

`android/assets/shaders/passthrough.vsh`:

```vsh
attribute vec4 a_color;
attribute vec3 a_position;
attribute vec2 a_texCoord0;

uniform mat4 u_projTrans;

varying vec4 v_color;
varying vec2 v_texCoord0;

void main() {
	v_color = a_color;
	v_texCoord0 = a_texCoord0;
	gl_Position =  u_projTrans * vec4(a_position, 1.);
}

```

`android/assets/shaders/vignette.fsh`:

```fsh
varying vec4 v_color;
varying vec2 v_texCoord0;

uniform vec2 u_resolution;
uniform sampler2D u_sampler2D;

const float OUTER_RADIUS = .6;
const float INNER_RADIUS = .3;
const float INTENSITY = .5;

void main() {
	vec4 color = texture2D(u_sampler2D, v_texCoord0) * v_color;

	vec2 relativePosition = gl_FragCoord.xy / u_resolution - 0.5;
	float len = length(relativePosition);
	float vignette = smoothstep(OUTER_RADIUS, INNER_RADIUS, len);
	color.rgb = mix(color.rgb, color.rgb * vignette, INTENSITY);

	gl_FragColor = color;
}
```

`android/assets/shaders/vignette.vsh`:

```vsh
attribute vec4 a_color;
attribute vec3 a_position;
attribute vec2 a_texCoord0;

uniform mat4 u_projTrans;

varying vec4 v_color;
varying vec2 v_texCoord0;

void main() {
	v_color = a_color;
	v_texCoord0 = a_texCoord0;
	gl_Position =  u_projTrans * vec4(a_position, 1.0);
}
```

`android/assets/textures/entities/monsters/alien/alien.pack`:

```pack

alien.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
attack1
  rotate: false
  xy: 1, 367
  size: 157, 120
  orig: 157, 120
  offset: 0, 0
  index: 0
attack1
  rotate: false
  xy: 1, 367
  size: 157, 120
  orig: 157, 120
  offset: 0, 0
  index: 10
attack1
  rotate: false
  xy: 1, 245
  size: 157, 120
  orig: 157, 120
  offset: 0, 0
  index: 1
attack1
  rotate: false
  xy: 1, 245
  size: 157, 120
  orig: 157, 120
  offset: 0, 0
  index: 9
attack1
  rotate: false
  xy: 160, 367
  size: 157, 120
  orig: 157, 120
  offset: 0, 0
  index: 2
attack1
  rotate: false
  xy: 160, 367
  size: 157, 120
  orig: 157, 120
  offset: 0, 0
  index: 8
attack1
  rotate: false
  xy: 1, 123
  size: 157, 120
  orig: 157, 120
  offset: 0, 0
  index: 3
attack1
  rotate: false
  xy: 160, 245
  size: 157, 120
  orig: 157, 120
  offset: 0, 0
  index: 4
attack1
  rotate: false
  xy: 319, 367
  size: 157, 120
  orig: 157, 120
  offset: 0, 0
  index: 5
attack1
  rotate: false
  xy: 1, 1
  size: 157, 120
  orig: 157, 120
  offset: 0, 0
  index: 6
attack1
  rotate: false
  xy: 160, 123
  size: 157, 120
  orig: 157, 120
  offset: 0, 0
  index: 7
move
  rotate: false
  xy: 319, 256
  size: 86, 109
  orig: 86, 109
  offset: 0, 0
  index: 0
move
  rotate: false
  xy: 478, 378
  size: 86, 109
  orig: 86, 109
  offset: 0, 0
  index: 1
move
  rotate: false
  xy: 160, 12
  size: 86, 109
  orig: 86, 109
  offset: 0, 0
  index: 2
move
  rotate: false
  xy: 319, 145
  size: 86, 109
  orig: 86, 109
  offset: 0, 0
  index: 3
jump
  rotate: false
  xy: 407, 251
  size: 70, 114
  orig: 70, 114
  offset: 0, 0
  index: 0
die1
  rotate: false
  xy: 566, 389
  size: 74, 98
  orig: 74, 98
  offset: 0, 0
  index: 0
die1
  rotate: false
  xy: 642, 389
  size: 74, 98
  orig: 74, 98
  offset: 0, 0
  index: 1
die1
  rotate: false
  xy: 718, 389
  size: 74, 98
  orig: 74, 98
  offset: 0, 0
  index: 2
die1
  rotate: false
  xy: 794, 389
  size: 74, 98
  orig: 74, 98
  offset: 0, 0
  index: 3
die1
  rotate: false
  xy: 870, 389
  size: 74, 98
  orig: 74, 98
  offset: 0, 0
  index: 4
die1
  rotate: false
  xy: 946, 389
  size: 74, 98
  orig: 74, 98
  offset: 0, 0
  index: 5
die1
  rotate: false
  xy: 407, 151
  size: 74, 98
  orig: 74, 98
  offset: 0, 0
  index: 6
stand
  rotate: false
  xy: 248, 10
  size: 59, 111
  orig: 59, 111
  offset: 0, 0
  index: 0
stand
  rotate: false
  xy: 248, 10
  size: 59, 111
  orig: 59, 111
  offset: 0, 0
  index: 11
stand
  rotate: false
  xy: 248, 10
  size: 59, 111
  orig: 59, 111
  offset: 0, 0
  index: 14
die1
  rotate: false
  xy: 479, 278
  size: 74, 98
  orig: 74, 98
  offset: 0, 0
  index: 7
stand
  rotate: false
  xy: 483, 165
  size: 59, 111
  orig: 59, 111
  offset: 0, 0
  index: 1
stand
  rotate: false
  xy: 483, 165
  size: 59, 111
  orig: 59, 111
  offset: 0, 0
  index: 12
stand
  rotate: false
  xy: 544, 165
  size: 59, 111
  orig: 59, 111
  offset: 0, 0
  index: 10
stand
  rotate: false
  xy: 544, 165
  size: 59, 111
  orig: 59, 111
  offset: 0, 0
  index: 8
stand
  rotate: false
  xy: 309, 10
  size: 59, 111
  orig: 59, 111
  offset: 0, 0
  index: 13
stand
  rotate: false
  xy: 309, 10
  size: 59, 111
  orig: 59, 111
  offset: 0, 0
  index: 2
stand
  rotate: false
  xy: 370, 32
  size: 59, 111
  orig: 59, 111
  offset: 0, 0
  index: 3
stand
  rotate: false
  xy: 431, 38
  size: 59, 111
  orig: 59, 111
  offset: 0, 0
  index: 4
stand
  rotate: false
  xy: 492, 52
  size: 59, 111
  orig: 59, 111
  offset: 0, 0
  index: 5
stand
  rotate: false
  xy: 553, 52
  size: 59, 111
  orig: 59, 111
  offset: 0, 0
  index: 6
hit1
  rotate: false
  xy: 555, 291
  size: 82, 85
  orig: 82, 85
  offset: 0, 0
  index: 0
stand
  rotate: false
  xy: 639, 276
  size: 59, 111
  orig: 59, 111
  offset: 0, 0
  index: 7
stand
  rotate: false
  xy: 639, 276
  size: 59, 111
  orig: 59, 111
  offset: 0, 0
  index: 9
attack1.info.hit
  rotate: false
  xy: 700, 312
  size: 79, 75
  orig: 79, 75
  offset: 0, 0
  index: 0
attack1.info.hit
  rotate: false
  xy: 700, 312
  size: 79, 75
  orig: 79, 75
  offset: 0, 0
  index: 3
attack1.info.hit
  rotate: false
  xy: 781, 312
  size: 79, 75
  orig: 79, 75
  offset: 0, 0
  index: 1
attack1.info.hit
  rotate: false
  xy: 781, 312
  size: 79, 75
  orig: 79, 75
  offset: 0, 0
  index: 4
attack1.info.hit
  rotate: false
  xy: 862, 312
  size: 79, 75
  orig: 79, 75
  offset: 0, 0
  index: 2
attack1.info.hit
  rotate: false
  xy: 862, 312
  size: 79, 75
  orig: 79, 75
  offset: 0, 0
  index: 5

```

`android/assets/textures/entities/monsters/alien/alien.xml`:

```xml
<offset>
  <move delay="120" x="-52" y="-109"/>
  <move delay="120" x="-52" y="-109"/>
  <move delay="120" x="-52" y="-109"/>
  <move delay="120" x="-52" y="-109"/>
  <stand delay="400" x="-25" y="-111"/>
  <stand delay="70" x="-25" y="-111"/>
  <stand delay="50" x="-25" y="-111"/>
  <stand delay="120" x="-25" y="-111"/>
  <stand delay="120" x="-25" y="-111"/>
  <stand delay="70" x="-25" y="-111"/>
  <stand delay="120" x="-25" y="-111"/>
  <stand delay="120" x="-25" y="-111"/>
  <stand delay="120" x="-25" y="-111"/>
  <stand delay="120" x="-25" y="-111"/>
  <stand delay="120" x="-25" y="-111"/>
  <stand delay="400" x="-25" y="-111"/>
  <stand delay="70" x="-25" y="-111"/>
  <stand delay="50" x="-25" y="-111"/>
  <stand delay="400" x="-25" y="-111"/>
  <jump delay="100" x="-36" y="-114"/>
  <attack1.info.hit delay="100" x="-39" y="-59"/>
  <attack1.info.hit delay="100" x="-39" y="-59"/>
  <attack1.info.hit delay="100" x="-39" y="-59"/>
  <attack1.info.hit delay="100" x="-39" y="-59"/>
  <attack1.info.hit delay="100" x="-39" y="-59"/>
  <attack1.info.hit delay="100" x="-39" y="-59"/>
  <attack1 delay="150" x="-90" y="-115"/>
  <attack1 delay="150" x="-90" y="-115"/>
  <attack1 delay="150" x="-90" y="-115"/>
  <attack1 delay="150" x="-90" y="-115"/>
  <attack1 delay="150" x="-90" y="-115"/>
  <attack1 delay="150" x="-90" y="-115"/>
  <attack1 delay="150" x="-90" y="-115"/>
  <attack1 delay="150" x="-90" y="-115"/>
  <attack1 delay="150" x="-90" y="-115"/>
  <attack1 delay="150" x="-90" y="-115"/>
  <attack1 delay="150" x="-90" y="-115"/>
  <hit1 delay="600" x="-37" y="-85"/>
  <die1 delay="120" x="-36" y="-97"/>
  <die1 delay="120" x="-36" y="-97"/>
  <die1 delay="120" x="-36" y="-97"/>
  <die1 delay="120" x="-36" y="-97"/>
  <die1 delay="120" x="-36" y="-97"/>
  <die1 delay="120" x="-36" y="-97"/>
  <die1 delay="120" x="-36" y="-97"/>
  <die1 delay="300" x="-36" y="-97"/>
</offset>
```

`android/assets/textures/entities/monsters/grey_slime/grey_slime.pack`:

```pack

grey_slime.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
move
  rotate: false
  xy: 1, 26
  size: 72, 94
  orig: 72, 94
  offset: 0, 0
  index: 0
move
  rotate: false
  xy: 75, 26
  size: 72, 94
  orig: 72, 94
  offset: 0, 0
  index: 1
move
  rotate: false
  xy: 149, 26
  size: 72, 94
  orig: 72, 94
  offset: 0, 0
  index: 2
move
  rotate: false
  xy: 223, 26
  size: 72, 94
  orig: 72, 94
  offset: 0, 0
  index: 3
move
  rotate: false
  xy: 297, 26
  size: 72, 94
  orig: 72, 94
  offset: 0, 0
  index: 4
move
  rotate: false
  xy: 371, 26
  size: 72, 94
  orig: 72, 94
  offset: 0, 0
  index: 5
move
  rotate: false
  xy: 445, 26
  size: 72, 94
  orig: 72, 94
  offset: 0, 0
  index: 6
jump
  rotate: false
  xy: 519, 53
  size: 63, 67
  orig: 63, 67
  offset: 0, 0
  index: 0
hit1
  rotate: false
  xy: 584, 54
  size: 63, 66
  orig: 63, 66
  offset: 0, 0
  index: 0
die1
  rotate: false
  xy: 649, 60
  size: 65, 60
  orig: 65, 60
  offset: 0, 0
  index: 0
die1
  rotate: false
  xy: 716, 60
  size: 65, 60
  orig: 65, 60
  offset: 0, 0
  index: 1
die1
  rotate: false
  xy: 783, 60
  size: 65, 60
  orig: 65, 60
  offset: 0, 0
  index: 2
die1
  rotate: false
  xy: 850, 60
  size: 65, 60
  orig: 65, 60
  offset: 0, 0
  index: 3
stand
  rotate: false
  xy: 917, 70
  size: 69, 50
  orig: 69, 50
  offset: 0, 0
  index: 0
stand
  rotate: false
  xy: 519, 1
  size: 69, 50
  orig: 69, 50
  offset: 0, 0
  index: 1
stand
  rotate: false
  xy: 590, 2
  size: 69, 50
  orig: 69, 50
  offset: 0, 0
  index: 2

```

`android/assets/textures/entities/monsters/grey_slime/grey_slime.xml`:

```xml
<offset>
	<move delay="200" x="-41" y="-94"/>
	<move delay="50" x="-41" y="-94"/>
	<move delay="150" x="-41" y="-94"/>
	<move delay="150" x="-41" y="-94"/>
	<move delay="100" x="-41" y="-94"/>
	<move delay="100" x="-41" y="-94"/>
	<move delay="300" x="-41" y="-94"/>
	<stand delay="200" x="-41" y="-50"/>
	<stand delay="300" x="-41" y="-50"/>
	<stand delay="250" x="-41" y="-50"/>
	<jump delay="150" x="-36" y="-54"/>
	<hit1 delay="600" x="-40" y="-66"/>
	<die1 delay="180" x="-35" y="-60"/>
	<die1 delay="180" x="-35" y="-60"/>
	<die1 delay="180" x="-35" y="-60"/>
	<die1 delay="300" x="-35" y="-60"/>
</offset>
```

`android/assets/textures/entities/pickups/pickups.pack`:

```pack

pickups.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
elixir_purple
  rotate: false
  xy: 1, 26
  size: 32, 31
  orig: 32, 31
  offset: 0, 0
  index: -1
pill_orange
  rotate: false
  xy: 1, 1
  size: 33, 23
  orig: 33, 23
  offset: 0, 0
  index: -1
potion_red
  rotate: false
  xy: 35, 30
  size: 27, 27
  orig: 27, 27
  offset: 0, 0
  index: -1

```

`android/assets/textures/entities/player/Alice.pack`:

```pack

Alice.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
swingPF
  rotate: false
  xy: 1, 883
  size: 90, 102
  orig: 90, 102
  offset: 0, 0
  index: 0
swingPF
  rotate: false
  xy: 1, 779
  size: 90, 102
  orig: 90, 102
  offset: 0, 0
  index: 1
swingPF
  rotate: false
  xy: 93, 883
  size: 90, 102
  orig: 90, 102
  offset: 0, 0
  index: 2
swingPF
  rotate: false
  xy: 1, 675
  size: 90, 102
  orig: 90, 102
  offset: 0, 0
  index: 3
swingOF
  rotate: false
  xy: 185, 896
  size: 97, 89
  orig: 97, 89
  offset: 0, 0
  index: 0
swingOF
  rotate: false
  xy: 284, 896
  size: 97, 89
  orig: 97, 89
  offset: 0, 0
  index: 1
swingOF
  rotate: false
  xy: 383, 896
  size: 97, 89
  orig: 97, 89
  offset: 0, 0
  index: 2
swingOF
  rotate: false
  xy: 482, 896
  size: 97, 89
  orig: 97, 89
  offset: 0, 0
  index: 3
stabTF
  rotate: false
  xy: 93, 779
  size: 77, 102
  orig: 77, 102
  offset: 0, 0
  index: 0
stabTF
  rotate: false
  xy: 1, 571
  size: 77, 102
  orig: 77, 102
  offset: 0, 0
  index: 1
stabTF
  rotate: false
  xy: 93, 675
  size: 77, 102
  orig: 77, 102
  offset: 0, 0
  index: 2
stabTF
  rotate: false
  xy: 1, 467
  size: 77, 102
  orig: 77, 102
  offset: 0, 0
  index: 3
stabOF
  rotate: false
  xy: 581, 911
  size: 93, 74
  orig: 93, 74
  offset: 0, 0
  index: 0
stabOF
  rotate: false
  xy: 676, 911
  size: 93, 74
  orig: 93, 74
  offset: 0, 0
  index: 1
stabOF
  rotate: false
  xy: 771, 911
  size: 93, 74
  orig: 93, 74
  offset: 0, 0
  index: 2
swingTF
  rotate: false
  xy: 80, 596
  size: 86, 77
  orig: 86, 77
  offset: 0, 0
  index: 0
swingTF
  rotate: false
  xy: 80, 517
  size: 86, 77
  orig: 86, 77
  offset: 0, 0
  index: 1
swingTF
  rotate: false
  xy: 866, 908
  size: 86, 77
  orig: 86, 77
  offset: 0, 0
  index: 2
swingTF
  rotate: false
  xy: 1, 388
  size: 86, 77
  orig: 86, 77
  offset: 0, 0
  index: 3
swingO1
  rotate: false
  xy: 1, 311
  size: 81, 75
  orig: 81, 75
  offset: 0, 0
  index: 0
swingO1
  rotate: false
  xy: 1, 234
  size: 81, 75
  orig: 81, 75
  offset: 0, 0
  index: 1
swingO1
  rotate: false
  xy: 1, 157
  size: 81, 75
  orig: 81, 75
  offset: 0, 0
  index: 2
swingP1
  rotate: false
  xy: 1, 79
  size: 77, 76
  orig: 77, 76
  offset: 0, 0
  index: 0
swingP1
  rotate: false
  xy: 1, 1
  size: 77, 76
  orig: 77, 76
  offset: 0, 0
  index: 1
stabO1
  rotate: false
  xy: 954, 912
  size: 67, 73
  orig: 67, 73
  offset: 0, 0
  index: 0
proneStab
  rotate: false
  xy: 80, 467
  size: 66, 48
  orig: 66, 48
  offset: 0, 0
  index: 0
prone
  rotate: false
  xy: 80, 467
  size: 66, 48
  orig: 66, 48
  offset: 0, 0
  index: 0
ladder
  rotate: false
  xy: 89, 388
  size: 56, 77
  orig: 56, 77
  offset: 0, 0
  index: 0
stabO2
  rotate: false
  xy: 84, 310
  size: 70, 76
  orig: 70, 76
  offset: 0, 0
  index: 0
stabO2
  rotate: false
  xy: 84, 232
  size: 70, 76
  orig: 70, 76
  offset: 0, 0
  index: 1
stabT2
  rotate: false
  xy: 84, 157
  size: 71, 73
  orig: 71, 73
  offset: 0, 0
  index: 0
swingP1
  rotate: false
  xy: 80, 79
  size: 77, 76
  orig: 77, 76
  offset: 0, 0
  index: 2
swingT1
  rotate: false
  xy: 80, 79
  size: 77, 76
  orig: 77, 76
  offset: 0, 0
  index: 2
swingT1
  rotate: false
  xy: 80, 1
  size: 77, 76
  orig: 77, 76
  offset: 0, 0
  index: 0
fly
  rotate: false
  xy: 172, 800
  size: 48, 81
  orig: 48, 81
  offset: 0, 0
  index: 0
swingT1
  rotate: false
  xy: 222, 818
  size: 77, 76
  orig: 77, 76
  offset: 0, 0
  index: 1
swingT2
  rotate: false
  xy: 301, 820
  size: 77, 74
  orig: 77, 74
  offset: 0, 0
  index: 0
swingT2
  rotate: false
  xy: 380, 820
  size: 77, 74
  orig: 77, 74
  offset: 0, 0
  index: 1
swingT2
  rotate: false
  xy: 459, 820
  size: 77, 74
  orig: 77, 74
  offset: 0, 0
  index: 2
fly
  rotate: false
  xy: 172, 717
  size: 48, 81
  orig: 48, 81
  offset: 0, 0
  index: 1
stabT1
  rotate: false
  xy: 222, 744
  size: 78, 72
  orig: 78, 72
  offset: 0, 0
  index: 0
stabT1
  rotate: false
  xy: 302, 746
  size: 78, 72
  orig: 78, 72
  offset: 0, 0
  index: 1
stabT1
  rotate: false
  xy: 382, 746
  size: 78, 72
  orig: 78, 72
  offset: 0, 0
  index: 2
swingO3
  rotate: false
  xy: 462, 746
  size: 77, 72
  orig: 77, 72
  offset: 0, 0
  index: 0
jump
  rotate: false
  xy: 538, 820
  size: 48, 74
  orig: 48, 74
  offset: 0, 0
  index: 0
swingO3
  rotate: false
  xy: 588, 837
  size: 77, 72
  orig: 77, 72
  offset: 0, 0
  index: 1
swingO3
  rotate: false
  xy: 667, 837
  size: 77, 72
  orig: 77, 72
  offset: 0, 0
  index: 2
swingP2
  rotate: false
  xy: 746, 833
  size: 73, 76
  orig: 73, 76
  offset: 0, 0
  index: 0
alert
  rotate: false
  xy: 541, 743
  size: 48, 75
  orig: 48, 75
  offset: 0, 0
  index: 0
alert
  rotate: false
  xy: 541, 743
  size: 48, 75
  orig: 48, 75
  offset: 0, 0
  index: 4
swingP2
  rotate: false
  xy: 591, 759
  size: 73, 76
  orig: 73, 76
  offset: 0, 0
  index: 1
swingP2
  rotate: false
  xy: 666, 759
  size: 73, 76
  orig: 73, 76
  offset: 0, 0
  index: 2
stabT2
  rotate: false
  xy: 741, 758
  size: 71, 73
  orig: 71, 73
  offset: 0, 0
  index: 1
stabT2
  rotate: false
  xy: 821, 833
  size: 71, 73
  orig: 71, 73
  offset: 0, 0
  index: 2
stabO1
  rotate: false
  xy: 814, 758
  size: 67, 73
  orig: 67, 73
  offset: 0, 0
  index: 1
swingO2
  rotate: false
  xy: 894, 830
  size: 61, 76
  orig: 61, 76
  offset: 0, 0
  index: 0
proneStab
  rotate: false
  xy: 957, 862
  size: 66, 48
  orig: 66, 48
  offset: 0, 0
  index: 1
swingT3
  rotate: false
  xy: 883, 754
  size: 64, 74
  orig: 64, 74
  offset: 0, 0
  index: 0
swingT3
  rotate: false
  xy: 957, 786
  size: 64, 74
  orig: 64, 74
  offset: 0, 0
  index: 1
swingT3
  rotate: false
  xy: 222, 668
  size: 64, 74
  orig: 64, 74
  offset: 0, 0
  index: 2
alert
  rotate: false
  xy: 172, 640
  size: 48, 75
  orig: 48, 75
  offset: 0, 0
  index: 1
alert
  rotate: false
  xy: 172, 640
  size: 48, 75
  orig: 48, 75
  offset: 0, 0
  index: 3
rope
  rotate: false
  xy: 168, 560
  size: 53, 78
  orig: 53, 78
  offset: 0, 0
  index: 0
swingO2
  rotate: false
  xy: 223, 590
  size: 61, 76
  orig: 61, 76
  offset: 0, 0
  index: 1
heal
  rotate: false
  xy: 168, 482
  size: 55, 76
  orig: 55, 76
  offset: 0, 0
  index: 0
swingO2
  rotate: false
  xy: 225, 512
  size: 61, 76
  orig: 61, 76
  offset: 0, 0
  index: 2
alert
  rotate: false
  xy: 288, 667
  size: 48, 75
  orig: 48, 75
  offset: 0, 0
  index: 2
ladder
  rotate: false
  xy: 338, 667
  size: 56, 77
  orig: 56, 77
  offset: 0, 0
  index: 1
heal
  rotate: false
  xy: 396, 668
  size: 55, 76
  orig: 55, 76
  offset: 0, 0
  index: 1
heal
  rotate: false
  xy: 453, 668
  size: 55, 76
  orig: 55, 76
  offset: 0, 0
  index: 2
shoot2
  rotate: false
  xy: 286, 590
  size: 49, 75
  orig: 49, 75
  offset: 0, 0
  index: 0
rope
  rotate: false
  xy: 337, 587
  size: 53, 78
  orig: 53, 78
  offset: 0, 0
  index: 1
shootF
  rotate: false
  xy: 510, 665
  size: 52, 76
  orig: 52, 76
  offset: 0, 0
  index: 0
shoot1
  rotate: false
  xy: 564, 665
  size: 48, 76
  orig: 48, 76
  offset: 0, 0
  index: 0
shootF
  rotate: false
  xy: 614, 681
  size: 52, 76
  orig: 52, 76
  offset: 0, 0
  index: 1
shootF
  rotate: false
  xy: 614, 681
  size: 52, 76
  orig: 52, 76
  offset: 0, 0
  index: 2
shoot1
  rotate: false
  xy: 668, 681
  size: 48, 76
  orig: 48, 76
  offset: 0, 0
  index: 1
shoot1
  rotate: false
  xy: 668, 681
  size: 48, 76
  orig: 48, 76
  offset: 0, 0
  index: 2
shoot2
  rotate: false
  xy: 718, 681
  size: 49, 75
  orig: 49, 75
  offset: 0, 0
  index: 1
shoot2
  rotate: false
  xy: 769, 681
  size: 49, 75
  orig: 49, 75
  offset: 0, 0
  index: 2
shoot2
  rotate: false
  xy: 820, 681
  size: 49, 75
  orig: 49, 75
  offset: 0, 0
  index: 3
shoot2
  rotate: false
  xy: 871, 677
  size: 49, 75
  orig: 49, 75
  offset: 0, 0
  index: 4
stand1
  rotate: false
  xy: 922, 676
  size: 48, 76
  orig: 48, 76
  offset: 0, 0
  index: 0
stand1
  rotate: false
  xy: 922, 676
  size: 48, 76
  orig: 48, 76
  offset: 0, 0
  index: 4
stand1
  rotate: false
  xy: 972, 708
  size: 48, 76
  orig: 48, 76
  offset: 0, 0
  index: 1
stand1
  rotate: false
  xy: 972, 708
  size: 48, 76
  orig: 48, 76
  offset: 0, 0
  index: 3
sit
  rotate: false
  xy: 972, 637
  size: 48, 69
  orig: 48, 69
  offset: 0, 0
  index: 0
stand1
  rotate: false
  xy: 392, 589
  size: 48, 76
  orig: 48, 76
  offset: 0, 0
  index: 2
stand2
  rotate: false
  xy: 442, 590
  size: 48, 76
  orig: 48, 76
  offset: 0, 0
  index: 0
stand2
  rotate: false
  xy: 442, 590
  size: 48, 76
  orig: 48, 76
  offset: 0, 0
  index: 4
stand2
  rotate: false
  xy: 492, 587
  size: 48, 76
  orig: 48, 76
  offset: 0, 0
  index: 1
stand2
  rotate: false
  xy: 492, 587
  size: 48, 76
  orig: 48, 76
  offset: 0, 0
  index: 3
stand2
  rotate: false
  xy: 542, 587
  size: 48, 76
  orig: 48, 76
  offset: 0, 0
  index: 2
walk1
  rotate: false
  xy: 592, 587
  size: 48, 76
  orig: 48, 76
  offset: 0, 0
  index: 0
walk1
  rotate: false
  xy: 642, 603
  size: 48, 76
  orig: 48, 76
  offset: 0, 0
  index: 1
walk1
  rotate: false
  xy: 692, 603
  size: 48, 76
  orig: 48, 76
  offset: 0, 0
  index: 2
walk1
  rotate: false
  xy: 742, 603
  size: 48, 76
  orig: 48, 76
  offset: 0, 0
  index: 3
walk2
  rotate: false
  xy: 792, 603
  size: 48, 76
  orig: 48, 76
  offset: 0, 0
  index: 0
walk2
  rotate: false
  xy: 842, 599
  size: 48, 76
  orig: 48, 76
  offset: 0, 0
  index: 1
walk2
  rotate: false
  xy: 892, 598
  size: 48, 76
  orig: 48, 76
  offset: 0, 0
  index: 2
walk2
  rotate: false
  xy: 225, 434
  size: 48, 76
  orig: 48, 76
  offset: 0, 0
  index: 3

```

`android/assets/textures/entities/player/Alice.xml`:

```xml
<offset>
  <walk1 delay="180" x="-17" y="-76"/>
  <walk1 delay="180" x="-17" y="-76"/>
  <walk1 delay="180" x="-17" y="-76"/>
  <walk1 delay="180" x="-17" y="-76"/>
  <walk2 delay="180" x="-17" y="-76"/>
  <walk2 delay="180" x="-17" y="-76"/>
  <walk2 delay="180" x="-17" y="-76"/>
  <walk2 delay="180" x="-17" y="-76"/>
  <stand1 delay="500" x="-17" y="-76"/>
  <stand1 delay="500" x="-17" y="-76"/>
  <stand1 delay="500" x="-17" y="-76"/>
  <stand1 delay="500" x="-17" y="-76"/>
  <stand1 delay="500" x="-17" y="-76"/>
  <stand2 delay="500" x="-17" y="-76"/>
  <stand2 delay="500" x="-17" y="-76"/>
  <stand2 delay="500" x="-17" y="-76"/>
  <stand2 delay="500" x="-17" y="-76"/>
  <stand2 delay="500" x="-17" y="-76"/>
  <alert delay="500" x="-17" y="-75"/>
  <alert delay="500" x="-17" y="-75"/>
  <alert delay="500" x="-17" y="-75"/>
  <alert delay="500" x="-17" y="-75"/>
  <alert delay="500" x="-17" y="-75"/>
  <swingO1 delay="300" x="-17" y="-75"/>
  <swingO1 delay="150" x="-17" y="-75"/>
  <swingO1 delay="350" x="-17" y="-75"/>
  <swingO2 delay="300" x="-17" y="-76"/>
  <swingO2 delay="150" x="-17" y="-76"/>
  <swingO2 delay="350" x="-17" y="-76"/>
  <swingO3 delay="300" x="-16" y="-72"/>
  <swingO3 delay="150" x="-16" y="-72"/>
  <swingO3 delay="350" x="-16" y="-72"/>
  <swingOF delay="200" x="-18" y="-87"/>
  <swingOF delay="100" x="-18" y="-87"/>
  <swingOF delay="100" x="-18" y="-87"/>
  <swingOF delay="300" x="-18" y="-87"/>
  <swingT1 delay="300" x="-17" y="-76"/>
  <swingT1 delay="150" x="-17" y="-76"/>
  <swingT1 delay="350" x="-17" y="-76"/>
  <swingT2 delay="300" x="-17" y="-74"/>
  <swingT2 delay="150" x="-17" y="-74"/>
  <swingT2 delay="350" x="-17" y="-74"/>
  <swingT3 delay="300" x="-17" y="-74"/>
  <swingT3 delay="150" x="-17" y="-74"/>
  <swingT3 delay="350" x="-17" y="-74"/>
  <swingTF delay="200" x="-22" y="-77"/>
  <swingTF delay="150" x="-22" y="-77"/>
  <swingTF delay="150" x="-22" y="-77"/>
  <swingTF delay="200" x="-22" y="-77"/>
  <swingP1 delay="300" x="-17" y="-76"/>
  <swingP1 delay="150" x="-17" y="-76"/>
  <swingP1 delay="350" x="-17" y="-76"/>
  <swingP2 delay="300" x="-17" y="-76"/>
  <swingP2 delay="150" x="-17" y="-76"/>
  <swingP2 delay="350" x="-17" y="-76"/>
  <swingPF delay="100" x="-15" y="-102"/>
  <swingPF delay="200" x="-15" y="-102"/>
  <swingPF delay="200" x="-15" y="-102"/>
  <swingPF delay="200" x="-15" y="-102"/>
  <stabO1 delay="350" x="-17" y="-73"/>
  <stabO1 delay="450" x="-17" y="-73"/>
  <stabO2 delay="350" x="-17" y="-76"/>
  <stabO2 delay="450" x="-17" y="-76"/>
  <stabOF delay="250" x="-16" y="-74"/>
  <stabOF delay="150" x="-16" y="-74"/>
  <stabOF delay="300" x="-16" y="-74"/>
  <stabT1 delay="300" x="-16" y="-72"/>
  <stabT1 delay="100" x="-16" y="-72"/>
  <stabT1 delay="350" x="-16" y="-72"/>
  <stabT2 delay="300" x="-16" y="-73"/>
  <stabT2 delay="100" x="-16" y="-73"/>
  <stabT2 delay="350" x="-16" y="-73"/>
  <stabTF delay="100" x="-15" y="-102"/>
  <stabTF delay="200" x="-15" y="-102"/>
  <stabTF delay="200" x="-15" y="-102"/>
  <stabTF delay="200" x="-15" y="-102"/>
  <shoot1 delay="300" x="-17" y="-76"/>
  <shoot1 delay="150" x="-17" y="-76"/>
  <shoot1 delay="350" x="-17" y="-76"/>
  <shoot2 delay="160" x="-17" y="-75"/>
  <shoot2 delay="160" x="-17" y="-75"/>
  <shoot2 delay="250" x="-17" y="-75"/>
  <shoot2 delay="100" x="-17" y="-75"/>
  <shoot2 delay="150" x="-17" y="-75"/>
  <shootF delay="300" x="-18" y="-76"/>
  <shootF delay="150" x="-18" y="-76"/>
  <shootF delay="250" x="-18" y="-76"/>
  <proneStab delay="300" x="-16" y="-48"/>
  <proneStab delay="400" x="-16" y="-48"/>
  <prone delay="100" x="-16" y="-48"/>
  <heal delay="300" x="-17" y="-76"/>
  <heal delay="150" x="-17" y="-76"/>
  <heal delay="350" x="-17" y="-76"/>
  <fly delay="300" x="-17" y="-81"/>
  <fly delay="300" x="-17" y="-81"/>
  <jump delay="200" x="-17" y="-74"/>
  <sit delay="100" x="-20" y="-72"/>
  <ladder delay="250" x="-29" y="-75"/>
  <ladder delay="250" x="-29" y="-75"/>
  <rope delay="250" x="-28" y="-78"/>
  <rope delay="250" x="-28" y="-78"/>
  <dead1 delay="250" x="-25" y="-69"/>
  <dead1 delay="250" x="-25" y="-69"/>
  <dead1 delay="250" x="-25" y="-69"/>
  <dead1 delay="250" x="-25" y="-69"/>
  <dead1 delay="250" x="-25" y="-69"/>
</offset>
```

`android/assets/textures/entities/player/fabulous.pack`:

```pack

fabulous.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
stabOF
  rotate: false
  xy: 1, 937
  size: 197, 86
  orig: 197, 86
  offset: 0, 0
  index: 0
stabOF
  rotate: false
  xy: 200, 937
  size: 197, 86
  orig: 197, 86
  offset: 0, 0
  index: 1
stabOF
  rotate: false
  xy: 399, 937
  size: 197, 86
  orig: 197, 86
  offset: 0, 0
  index: 2
swingOF
  rotate: false
  xy: 598, 881
  size: 190, 142
  orig: 190, 142
  offset: 0, 0
  index: 0
swingOF
  rotate: false
  xy: 790, 881
  size: 190, 142
  orig: 190, 142
  offset: 0, 0
  index: 1
swingOF
  rotate: false
  xy: 1, 793
  size: 190, 142
  orig: 190, 142
  offset: 0, 0
  index: 2
swingOF
  rotate: false
  xy: 193, 793
  size: 190, 142
  orig: 190, 142
  offset: 0, 0
  index: 3
swingO1
  rotate: false
  xy: 385, 807
  size: 179, 128
  orig: 179, 128
  offset: 0, 0
  index: 0
swingO1
  rotate: false
  xy: 566, 751
  size: 179, 128
  orig: 179, 128
  offset: 0, 0
  index: 1
swingO1
  rotate: false
  xy: 385, 677
  size: 179, 128
  orig: 179, 128
  offset: 0, 0
  index: 2
swingT1
  rotate: false
  xy: 747, 751
  size: 179, 128
  orig: 179, 128
  offset: 0, 0
  index: 0
prone
  rotate: false
  xy: 928, 809
  size: 91, 70
  orig: 91, 70
  offset: 0, 0
  index: 0
heal
  rotate: false
  xy: 928, 731
  size: 88, 76
  orig: 88, 76
  offset: 0, 0
  index: 0
swingT1
  rotate: false
  xy: 566, 621
  size: 179, 128
  orig: 179, 128
  offset: 0, 0
  index: 1
swingT1
  rotate: false
  xy: 747, 621
  size: 179, 128
  orig: 179, 128
  offset: 0, 0
  index: 2
heal
  rotate: false
  xy: 928, 653
  size: 88, 76
  orig: 88, 76
  offset: 0, 0
  index: 1
heal
  rotate: false
  xy: 928, 575
  size: 88, 76
  orig: 88, 76
  offset: 0, 0
  index: 2
stabO2
  rotate: false
  xy: 1, 711
  size: 170, 80
  orig: 170, 80
  offset: 0, 0
  index: 0
stabO2
  rotate: false
  xy: 173, 711
  size: 170, 80
  orig: 170, 80
  offset: 0, 0
  index: 1
swingTF
  rotate: false
  xy: 1, 573
  size: 165, 136
  orig: 165, 136
  offset: 0, 0
  index: 0
swingTF
  rotate: false
  xy: 168, 573
  size: 165, 136
  orig: 165, 136
  offset: 0, 0
  index: 1
swingTF
  rotate: false
  xy: 335, 539
  size: 165, 136
  orig: 165, 136
  offset: 0, 0
  index: 2
ladder
  rotate: false
  xy: 502, 598
  size: 54, 77
  orig: 54, 77
  offset: 0, 0
  index: 0
swingTF
  rotate: false
  xy: 1, 435
  size: 165, 136
  orig: 165, 136
  offset: 0, 0
  index: 3
stabT1
  rotate: false
  xy: 168, 477
  size: 162, 94
  orig: 162, 94
  offset: 0, 0
  index: 0
stabT1
  rotate: false
  xy: 558, 525
  size: 162, 94
  orig: 162, 94
  offset: 0, 0
  index: 1
ladder
  rotate: false
  xy: 502, 519
  size: 54, 77
  orig: 54, 77
  offset: 0, 0
  index: 1
stabT1
  rotate: false
  xy: 332, 443
  size: 162, 94
  orig: 162, 94
  offset: 0, 0
  index: 2
stabTF
  rotate: false
  xy: 168, 350
  size: 154, 125
  orig: 154, 125
  offset: 0, 0
  index: 0
stabTF
  rotate: false
  xy: 1, 308
  size: 154, 125
  orig: 154, 125
  offset: 0, 0
  index: 1
stabTF
  rotate: false
  xy: 722, 494
  size: 154, 125
  orig: 154, 125
  offset: 0, 0
  index: 2
stabT2
  rotate: false
  xy: 878, 477
  size: 145, 96
  orig: 145, 96
  offset: 0, 0
  index: 0
stabTF
  rotate: false
  xy: 558, 398
  size: 154, 125
  orig: 154, 125
  offset: 0, 0
  index: 3
dead1
  rotate: false
  xy: 496, 439
  size: 52, 78
  orig: 52, 78
  offset: 0, 0
  index: 0
dead1
  rotate: false
  xy: 496, 439
  size: 52, 78
  orig: 52, 78
  offset: 0, 0
  index: 4
swingT2
  rotate: false
  xy: 714, 368
  size: 151, 124
  orig: 151, 124
  offset: 0, 0
  index: 0
swingT2
  rotate: false
  xy: 867, 351
  size: 151, 124
  orig: 151, 124
  offset: 0, 0
  index: 1
swingT2
  rotate: false
  xy: 324, 317
  size: 151, 124
  orig: 151, 124
  offset: 0, 0
  index: 2
stabT2
  rotate: false
  xy: 157, 252
  size: 145, 96
  orig: 145, 96
  offset: 0, 0
  index: 1
stabT2
  rotate: false
  xy: 1, 210
  size: 145, 96
  orig: 145, 96
  offset: 0, 0
  index: 2
dead1
  rotate: false
  xy: 477, 359
  size: 52, 78
  orig: 52, 78
  offset: 0, 0
  index: 1
dead1
  rotate: false
  xy: 477, 359
  size: 52, 78
  orig: 52, 78
  offset: 0, 0
  index: 3
swingO2
  rotate: false
  xy: 531, 271
  size: 137, 125
  orig: 137, 125
  offset: 0, 0
  index: 0
dead1
  rotate: false
  xy: 477, 279
  size: 52, 78
  orig: 52, 78
  offset: 0, 0
  index: 2
swingO2
  rotate: false
  xy: 304, 190
  size: 137, 125
  orig: 137, 125
  offset: 0, 0
  index: 1
stand1
  rotate: false
  xy: 443, 197
  size: 85, 80
  orig: 85, 80
  offset: 0, 0
  index: 0
stand1
  rotate: false
  xy: 443, 197
  size: 85, 80
  orig: 85, 80
  offset: 0, 0
  index: 4
swingO2
  rotate: false
  xy: 148, 125
  size: 137, 125
  orig: 137, 125
  offset: 0, 0
  index: 2
stabO1
  rotate: false
  xy: 1, 123
  size: 136, 85
  orig: 136, 85
  offset: 0, 0
  index: 0
walk1
  rotate: false
  xy: 1, 25
  size: 99, 96
  orig: 99, 96
  offset: 0, 0
  index: 0
walk1
  rotate: false
  xy: 102, 25
  size: 99, 96
  orig: 99, 96
  offset: 0, 0
  index: 1
walk1
  rotate: false
  xy: 203, 27
  size: 99, 96
  orig: 99, 96
  offset: 0, 0
  index: 2
stabO1
  rotate: false
  xy: 670, 281
  size: 136, 85
  orig: 136, 85
  offset: 0, 0
  index: 1
rope
  rotate: false
  xy: 808, 288
  size: 51, 78
  orig: 51, 78
  offset: 0, 0
  index: 0
swingT3
  rotate: false
  xy: 861, 225
  size: 134, 124
  orig: 134, 124
  offset: 0, 0
  index: 0
rope
  rotate: false
  xy: 808, 208
  size: 51, 78
  orig: 51, 78
  offset: 0, 0
  index: 1
swingT3
  rotate: false
  xy: 670, 155
  size: 134, 124
  orig: 134, 124
  offset: 0, 0
  index: 1
swingT3
  rotate: false
  xy: 530, 145
  size: 134, 124
  orig: 134, 124
  offset: 0, 0
  index: 2
stand1
  rotate: false
  xy: 443, 115
  size: 85, 80
  orig: 85, 80
  offset: 0, 0
  index: 1
stand1
  rotate: false
  xy: 443, 115
  size: 85, 80
  orig: 85, 80
  offset: 0, 0
  index: 3
walk1
  rotate: false
  xy: 304, 17
  size: 99, 96
  orig: 99, 96
  offset: 0, 0
  index: 3
proneStab
  rotate: false
  xy: 304, 118
  size: 112, 70
  orig: 112, 70
  offset: 0, 0
  index: 0
fly
  rotate: false
  xy: 405, 24
  size: 84, 89
  orig: 84, 89
  offset: 0, 0
  index: 0
fly
  rotate: false
  xy: 491, 24
  size: 84, 89
  orig: 84, 89
  offset: 0, 0
  index: 1
proneStab
  rotate: false
  xy: 861, 153
  size: 112, 70
  orig: 112, 70
  offset: 0, 0
  index: 1
sit
  rotate: false
  xy: 806, 137
  size: 49, 69
  orig: 49, 69
  offset: 0, 0
  index: 0
alert
  rotate: false
  xy: 666, 78
  size: 88, 75
  orig: 88, 75
  offset: 0, 0
  index: 0
alert
  rotate: false
  xy: 666, 78
  size: 88, 75
  orig: 88, 75
  offset: 0, 0
  index: 4
walk2
  rotate: false
  xy: 577, 60
  size: 87, 83
  orig: 87, 83
  offset: 0, 0
  index: 0
alert
  rotate: false
  xy: 666, 1
  size: 88, 75
  orig: 88, 75
  offset: 0, 0
  index: 1
alert
  rotate: false
  xy: 666, 1
  size: 88, 75
  orig: 88, 75
  offset: 0, 0
  index: 3
walk2
  rotate: false
  xy: 756, 52
  size: 87, 83
  orig: 87, 83
  offset: 0, 0
  index: 1
walk2
  rotate: false
  xy: 845, 52
  size: 87, 83
  orig: 87, 83
  offset: 0, 0
  index: 2
alert
  rotate: false
  xy: 934, 76
  size: 88, 75
  orig: 88, 75
  offset: 0, 0
  index: 2

fabulous2.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
walk2
  rotate: false
  xy: 1, 167
  size: 87, 83
  orig: 87, 83
  offset: 0, 0
  index: 3
jump
  rotate: false
  xy: 1, 83
  size: 84, 82
  orig: 84, 82
  offset: 0, 0
  index: 0
stand1
  rotate: false
  xy: 1, 1
  size: 85, 80
  orig: 85, 80
  offset: 0, 0
  index: 2

```

`android/assets/textures/entities/player/fabulous.xml`:

```xml
<offset>
  <walk1 delay="180" x="-37" y="-76"/>
  <walk1 delay="180" x="-37" y="-76"/>
  <walk1 delay="180" x="-37" y="-76"/>
  <walk1 delay="180" x="-37" y="-76"/>
  <walk2 delay="180" x="-58" y="-83"/>
  <walk2 delay="180" x="-58" y="-83"/>
  <walk2 delay="180" x="-58" y="-83"/>
  <walk2 delay="180" x="-58" y="-83"/>
  <stand1 delay="500" x="-56" y="-80"/>
  <stand1 delay="500" x="-56" y="-80"/>
  <stand1 delay="500" x="-56" y="-80"/>
  <stand1 delay="500" x="-56" y="-80"/>
  <stand1 delay="500" x="-56" y="-80"/>
  <alert delay="500" x="-24" y="-75"/>
  <alert delay="500" x="-24" y="-75"/>
  <alert delay="500" x="-24" y="-75"/>
  <alert delay="500" x="-24" y="-75"/>
  <alert delay="500" x="-24" y="-75"/>
  <swingT1 delay="300" x="-66" y="-98"/>
  <swingT1 delay="150" x="-66" y="-98"/>
  <swingT1 delay="350" x="-66" y="-98"/>
  <swingT2 delay="300" x="-56" y="-96"/>
  <swingT2 delay="150" x="-56" y="-96"/>
  <swingT2 delay="350" x="-56" y="-96"/>
  <swingT3 delay="300" x="-67" y="-99"/>
  <swingT3 delay="150" x="-67" y="-99"/>
  <swingT3 delay="350" x="-67" y="-99"/>
  <swingTF delay="200" x="-34" y="-104"/>
  <swingTF delay="150" x="-34" y="-104"/>
  <swingTF delay="150" x="-34" y="-104"/>
  <swingTF delay="200" x="-34" y="-104"/>
  <swingO1 delay="300" x="-62" y="-96"/>
  <swingO1 delay="150" x="-62" y="-96"/>
  <swingO1 delay="350" x="-62" y="-96"/>
  <swingO2 delay="300" x="-41" y="-96"/>
  <swingO2 delay="150" x="-41" y="-96"/>
  <swingO2 delay="350" x="-41" y="-96"/>
  <swingOF delay="100" x="-47" y="-110"/>
  <swingOF delay="200" x="-47" y="-110"/>
  <swingOF delay="200" x="-47" y="-110"/>
  <swingOF delay="200" x="-47" y="-110"/>
  <stabO1 delay="350" x="-36" y="-73"/>
  <stabO1 delay="450" x="-36" y="-73"/>
  <stabO2 delay="350" x="-34" y="-76"/>
  <stabO2 delay="450" x="-34" y="-76"/>
  <stabOF delay="250" x="-38" y="-74"/>
  <stabOF delay="150" x="-38" y="-74"/>
  <stabOF delay="300" x="-38" y="-74"/>
  <stabT1 delay="300" x="-26" y="-72"/>
  <stabT1 delay="100" x="-26" y="-72"/>
  <stabT1 delay="350" x="-26" y="-72"/>
  <stabT2 delay="300" x="-24" y="-73"/>
  <stabT2 delay="100" x="-24" y="-73"/>
  <stabT2 delay="350" x="-24" y="-73"/>
  <stabTF delay="100" x="-18" y="-102"/>
  <stabTF delay="200" x="-18" y="-102"/>
  <stabTF delay="200" x="-18" y="-102"/>
  <stabTF delay="200" x="-18" y="-102"/>
  <proneStab delay="300" x="-16" y="-48"/>
  <proneStab delay="400" x="-16" y="-48"/>
  <prone delay="100" x="-16" y="-48"/>
  <heal delay="300" x="-24" y="-76"/>
  <heal delay="150" x="-24" y="-76"/>
  <heal delay="350" x="-24" y="-76"/>
  <fly delay="300" x="-55" y="-89"/>
  <fly delay="300" x="-55" y="-89"/>
  <jump delay="200" x="-55" y="-82"/>
  <sit delay="100" x="-23" y="-72"/>
  <ladder delay="250" x="-28" y="-75"/>
  <ladder delay="250" x="-28" y="-75"/>
  <rope delay="250" x="-27" y="-78"/>
  <rope delay="250" x="-27" y="-78"/>
    <dead1 delay="250" x="-26" y="-79"/>
	<dead1 delay="250" x="-26" y="-79"/>
	<dead1 delay="250" x="-26" y="-79"/>
	<dead1 delay="250" x="-26" y="-79"/>
	<dead1 delay="250" x="-26" y="-79"/>
</offset>
```

`android/assets/textures/entities/player/kirito.pack`:

```pack

kirito.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
stabOF
  rotate: false
  xy: 1, 432
  size: 206, 71
  orig: 206, 71
  offset: 0, 0
  index: 0
stabOF
  rotate: false
  xy: 1, 359
  size: 206, 71
  orig: 206, 71
  offset: 0, 0
  index: 1
stabOF
  rotate: false
  xy: 209, 432
  size: 206, 71
  orig: 206, 71
  offset: 0, 0
  index: 2
swingO3
  rotate: false
  xy: 1, 258
  size: 174, 99
  orig: 174, 99
  offset: 0, 0
  index: 0
swingO3
  rotate: false
  xy: 1, 157
  size: 174, 99
  orig: 174, 99
  offset: 0, 0
  index: 1
swingO3
  rotate: false
  xy: 1, 56
  size: 174, 99
  orig: 174, 99
  offset: 0, 0
  index: 2
stabO2
  rotate: false
  xy: 209, 358
  size: 174, 72
  orig: 174, 72
  offset: 0, 0
  index: 0
stabO2
  rotate: false
  xy: 417, 431
  size: 174, 72
  orig: 174, 72
  offset: 0, 0
  index: 1
stabO1
  rotate: false
  xy: 593, 434
  size: 174, 69
  orig: 174, 69
  offset: 0, 0
  index: 0
stabO1
  rotate: false
  xy: 769, 434
  size: 174, 69
  orig: 174, 69
  offset: 0, 0
  index: 1
swingOF
  rotate: false
  xy: 177, 266
  size: 171, 90
  orig: 171, 90
  offset: 0, 0
  index: 0
swingOF
  rotate: false
  xy: 177, 174
  size: 171, 90
  orig: 171, 90
  offset: 0, 0
  index: 1
swingOF
  rotate: false
  xy: 177, 82
  size: 171, 90
  orig: 171, 90
  offset: 0, 0
  index: 2
swingOF
  rotate: false
  xy: 385, 339
  size: 171, 90
  orig: 171, 90
  offset: 0, 0
  index: 3
swingO2
  rotate: false
  xy: 350, 221
  size: 108, 116
  orig: 108, 116
  offset: 0, 0
  index: 0
swingO2
  rotate: false
  xy: 350, 103
  size: 108, 116
  orig: 108, 116
  offset: 0, 0
  index: 1
swingO2
  rotate: false
  xy: 460, 221
  size: 108, 116
  orig: 108, 116
  offset: 0, 0
  index: 2
swingO1
  rotate: false
  xy: 460, 131
  size: 129, 88
  orig: 129, 88
  offset: 0, 0
  index: 0
proneStab
  rotate: false
  xy: 1, 6
  size: 130, 48
  orig: 130, 48
  offset: 0, 0
  index: 0
proneStab
  rotate: false
  xy: 460, 81
  size: 130, 48
  orig: 130, 48
  offset: 0, 0
  index: 1
prone
  rotate: false
  xy: 177, 32
  size: 114, 48
  orig: 114, 48
  offset: 0, 0
  index: 0
dead1
  rotate: false
  xy: 945, 425
  size: 62, 78
  orig: 62, 78
  offset: 0, 0
  index: 0
dead1
  rotate: false
  xy: 945, 425
  size: 62, 78
  orig: 62, 78
  offset: 0, 0
  index: 4
swingO1
  rotate: false
  xy: 593, 344
  size: 129, 88
  orig: 129, 88
  offset: 0, 0
  index: 1
swingO1
  rotate: false
  xy: 724, 344
  size: 129, 88
  orig: 129, 88
  offset: 0, 0
  index: 2
heal
  rotate: false
  xy: 570, 262
  size: 100, 80
  orig: 100, 80
  offset: 0, 0
  index: 0
heal
  rotate: false
  xy: 672, 262
  size: 100, 80
  orig: 100, 80
  offset: 0, 0
  index: 1
heal
  rotate: false
  xy: 774, 262
  size: 100, 80
  orig: 100, 80
  offset: 0, 0
  index: 2
dead1
  rotate: false
  xy: 855, 354
  size: 62, 78
  orig: 62, 78
  offset: 0, 0
  index: 1
dead1
  rotate: false
  xy: 855, 354
  size: 62, 78
  orig: 62, 78
  offset: 0, 0
  index: 3
alert
  rotate: false
  xy: 919, 351
  size: 94, 72
  orig: 94, 72
  offset: 0, 0
  index: 0
alert
  rotate: false
  xy: 919, 351
  size: 94, 72
  orig: 94, 72
  offset: 0, 0
  index: 4
fly
  rotate: false
  xy: 591, 183
  size: 94, 77
  orig: 94, 77
  offset: 0, 0
  index: 0
fly
  rotate: false
  xy: 687, 183
  size: 94, 77
  orig: 94, 77
  offset: 0, 0
  index: 1
alert
  rotate: false
  xy: 783, 188
  size: 94, 72
  orig: 94, 72
  offset: 0, 0
  index: 1
alert
  rotate: false
  xy: 783, 188
  size: 94, 72
  orig: 94, 72
  offset: 0, 0
  index: 3
stand1
  rotate: false
  xy: 876, 277
  size: 96, 72
  orig: 96, 72
  offset: 0, 0
  index: 0
stand1
  rotate: false
  xy: 876, 277
  size: 96, 72
  orig: 96, 72
  offset: 0, 0
  index: 4
alert
  rotate: false
  xy: 879, 203
  size: 94, 72
  orig: 94, 72
  offset: 0, 0
  index: 2
stand1
  rotate: false
  xy: 592, 109
  size: 96, 72
  orig: 96, 72
  offset: 0, 0
  index: 1
stand1
  rotate: false
  xy: 592, 109
  size: 96, 72
  orig: 96, 72
  offset: 0, 0
  index: 3
stand1
  rotate: false
  xy: 690, 109
  size: 96, 72
  orig: 96, 72
  offset: 0, 0
  index: 2
walk1
  rotate: false
  xy: 788, 114
  size: 94, 72
  orig: 94, 72
  offset: 0, 0
  index: 0
walk1
  rotate: false
  xy: 884, 129
  size: 94, 72
  orig: 94, 72
  offset: 0, 0
  index: 1
jump
  rotate: false
  xy: 592, 37
  size: 94, 70
  orig: 94, 70
  offset: 0, 0
  index: 0
walk1
  rotate: false
  xy: 688, 35
  size: 94, 72
  orig: 94, 72
  offset: 0, 0
  index: 2
walk1
  rotate: false
  xy: 350, 29
  size: 94, 72
  orig: 94, 72
  offset: 0, 0
  index: 3
rope
  rotate: false
  xy: 974, 277
  size: 47, 72
  orig: 47, 72
  offset: 0, 0
  index: 0
rope
  rotate: false
  xy: 975, 203
  size: 47, 72
  orig: 47, 72
  offset: 0, 0
  index: 1
dead1
  rotate: false
  xy: 446, 1
  size: 62, 78
  orig: 62, 78
  offset: 0, 0
  index: 2
ladder
  rotate: false
  xy: 510, 8
  size: 50, 71
  orig: 50, 71
  offset: 0, 0
  index: 0
ladder
  rotate: false
  xy: 293, 9
  size: 50, 71
  orig: 50, 71
  offset: 0, 0
  index: 1
sit
  rotate: false
  xy: 784, 41
  size: 50, 66
  orig: 50, 66
  offset: 0, 0
  index: 0

```

`android/assets/textures/entities/player/kirito.xml`:

```xml
<offset>
  <walk1 delay="180" x="-48" y="-71"/>
  <walk1 delay="180" x="-48" y="-71"/>
  <walk1 delay="180" x="-48" y="-71"/>
  <walk1 delay="180" x="-48" y="-71"/>
  <stand1 delay="500" x="-49" y="-71"/>
  <stand1 delay="500" x="-49" y="-71"/>
  <stand1 delay="500" x="-49" y="-71"/>
  <stand1 delay="500" x="-49" y="-71"/>
  <stand1 delay="500" x="-49" y="-71"/>
  <alert delay="500" x="-50" y="-70"/>
  <alert delay="500" x="-50" y="-70"/>
  <alert delay="500" x="-50" y="-70"/>
  <alert delay="500" x="-50" y="-70"/>
  <alert delay="500" x="-50" y="-70"/>
  <swingO1 delay="300" x="-67" y="-84"/>
  <swingO1 delay="150" x="-67" y="-84"/>
  <swingO1 delay="350" x="-67" y="-84"/>
  <swingO2 delay="300" x="-56" y="-71"/>
  <swingO2 delay="150" x="-56" y="-71"/>
  <swingO2 delay="350" x="-56" y="-71"/>
  <swingO3 delay="300" x="-50" y="-98"/>
  <swingO3 delay="150" x="-50" y="-98"/>
  <swingO3 delay="350" x="-50" y="-98"/>
  <swingOF delay="200" x="-54" y="-81"/>
  <swingOF delay="100" x="-54" y="-81"/>
  <swingOF delay="100" x="-54" y="-81"/>
  <swingOF delay="300" x="-54" y="-81"/>
  <stabO1 delay="350" x="-53" y="-68"/>
  <stabO1 delay="450" x="-53" y="-68"/>
  <stabO2 delay="350" x="-55" y="-71"/>
  <stabO2 delay="450" x="-55" y="-71"/>
  <stabOF delay="250" x="-62" y="-69"/>
  <stabOF delay="150" x="-62" y="-69"/>
  <stabOF delay="300" x="-62" y="-69"/>
  <proneStab delay="300" x="-17" y="-43"/>
  <proneStab delay="400" x="-17" y="-43"/>
  <prone delay="100" x="-17" y="-43"/>
  <heal delay="300" x="-50" y="-71"/>
  <heal delay="150" x="-50" y="-71"/>
  <heal delay="350" x="-50" y="-71"/>
  <fly delay="300" x="-49" y="-76"/>
  <fly delay="300" x="-49" y="-76"/>
  <jump delay="200" x="-49" y="-69"/>
  <sit delay="100" x="-24" y="-67"/>
  <ladder delay="250" x="-26" y="-69"/>
  <ladder delay="250" x="-26" y="-69"/>
  <rope delay="250" x="-25" y="-72"/>
  <rope delay="250" x="-25" y="-72"/>
    <dead1 delay="250" x="-26" y="-79"/>
	<dead1 delay="250" x="-26" y="-79"/>
	<dead1 delay="250" x="-26" y="-79"/>
	<dead1 delay="250" x="-26" y="-79"/>
	<dead1 delay="250" x="-26" y="-79"/>
</offset>
```

`android/assets/textures/entities/player/player.pack`:

```pack

player.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
swingPF
  rotate: false
  xy: 1, 910
  size: 91, 94
  orig: 91, 94
  offset: 0, 0
  index: 0
swingPF
  rotate: false
  xy: 1, 814
  size: 91, 94
  orig: 91, 94
  offset: 0, 0
  index: 1
swingPF
  rotate: false
  xy: 94, 910
  size: 91, 94
  orig: 91, 94
  offset: 0, 0
  index: 2
swingPF
  rotate: false
  xy: 1, 718
  size: 91, 94
  orig: 91, 94
  offset: 0, 0
  index: 3
stabTF
  rotate: false
  xy: 94, 813
  size: 78, 95
  orig: 78, 95
  offset: 0, 0
  index: 0
stabTF
  rotate: false
  xy: 1, 621
  size: 78, 95
  orig: 78, 95
  offset: 0, 0
  index: 1
stabTF
  rotate: false
  xy: 1, 524
  size: 78, 95
  orig: 78, 95
  offset: 0, 0
  index: 2
stabTF
  rotate: false
  xy: 1, 427
  size: 78, 95
  orig: 78, 95
  offset: 0, 0
  index: 3
swingOF
  rotate: false
  xy: 187, 924
  size: 92, 80
  orig: 92, 80
  offset: 0, 0
  index: 0
swingOF
  rotate: false
  xy: 281, 924
  size: 92, 80
  orig: 92, 80
  offset: 0, 0
  index: 1
swingOF
  rotate: false
  xy: 375, 924
  size: 92, 80
  orig: 92, 80
  offset: 0, 0
  index: 2
swingOF
  rotate: false
  xy: 94, 731
  size: 92, 80
  orig: 92, 80
  offset: 0, 0
  index: 3
swingP2
  rotate: false
  xy: 1, 355
  size: 86, 70
  orig: 86, 70
  offset: 0, 0
  index: 0
swingP2
  rotate: false
  xy: 1, 283
  size: 86, 70
  orig: 86, 70
  offset: 0, 0
  index: 1
swingP2
  rotate: false
  xy: 1, 211
  size: 86, 70
  orig: 86, 70
  offset: 0, 0
  index: 2
stabOF
  rotate: false
  xy: 1, 141
  size: 98, 68
  orig: 98, 68
  offset: 0, 0
  index: 0
stabOF
  rotate: false
  xy: 1, 71
  size: 98, 68
  orig: 98, 68
  offset: 0, 0
  index: 1
stabOF
  rotate: false
  xy: 1, 1
  size: 98, 68
  orig: 98, 68
  offset: 0, 0
  index: 2
swingO1
  rotate: false
  xy: 187, 855
  size: 88, 67
  orig: 88, 67
  offset: 0, 0
  index: 0
swingO1
  rotate: false
  xy: 277, 855
  size: 88, 67
  orig: 88, 67
  offset: 0, 0
  index: 1
swingO1
  rotate: false
  xy: 367, 855
  size: 88, 67
  orig: 88, 67
  offset: 0, 0
  index: 2
swingT2
  rotate: false
  xy: 188, 785
  size: 85, 68
  orig: 85, 68
  offset: 0, 0
  index: 0
swingT2
  rotate: false
  xy: 275, 785
  size: 85, 68
  orig: 85, 68
  offset: 0, 0
  index: 1
swingT2
  rotate: false
  xy: 362, 785
  size: 85, 68
  orig: 85, 68
  offset: 0, 0
  index: 2
swingTF
  rotate: false
  xy: 188, 713
  size: 83, 70
  orig: 83, 70
  offset: 0, 0
  index: 0
swingTF
  rotate: false
  xy: 273, 713
  size: 83, 70
  orig: 83, 70
  offset: 0, 0
  index: 1
swingTF
  rotate: false
  xy: 358, 713
  size: 83, 70
  orig: 83, 70
  offset: 0, 0
  index: 2
swingTF
  rotate: false
  xy: 94, 659
  size: 83, 70
  orig: 83, 70
  offset: 0, 0
  index: 3
stabT2
  rotate: false
  xy: 81, 592
  size: 78, 65
  orig: 78, 65
  offset: 0, 0
  index: 0
stabT2
  rotate: false
  xy: 81, 525
  size: 78, 65
  orig: 78, 65
  offset: 0, 0
  index: 1
stabT2
  rotate: false
  xy: 81, 458
  size: 78, 65
  orig: 78, 65
  offset: 0, 0
  index: 2
stabT1
  rotate: false
  xy: 179, 647
  size: 76, 64
  orig: 76, 64
  offset: 0, 0
  index: 0
stabT1
  rotate: false
  xy: 257, 647
  size: 76, 64
  orig: 76, 64
  offset: 0, 0
  index: 1
stabT1
  rotate: false
  xy: 335, 647
  size: 76, 64
  orig: 76, 64
  offset: 0, 0
  index: 2
swingP1
  rotate: false
  xy: 161, 577
  size: 75, 68
  orig: 75, 68
  offset: 0, 0
  index: 0
swingP1
  rotate: false
  xy: 161, 507
  size: 75, 68
  orig: 75, 68
  offset: 0, 0
  index: 1
swingP1
  rotate: false
  xy: 238, 577
  size: 75, 68
  orig: 75, 68
  offset: 0, 0
  index: 2
swingT1
  rotate: false
  xy: 238, 507
  size: 74, 68
  orig: 74, 68
  offset: 0, 0
  index: 0
swingT1
  rotate: false
  xy: 315, 577
  size: 74, 68
  orig: 74, 68
  offset: 0, 0
  index: 1
swingT1
  rotate: false
  xy: 314, 507
  size: 74, 68
  orig: 74, 68
  offset: 0, 0
  index: 2
swingO3
  rotate: false
  xy: 161, 441
  size: 74, 64
  orig: 74, 64
  offset: 0, 0
  index: 0
swingO3
  rotate: false
  xy: 237, 441
  size: 74, 64
  orig: 74, 64
  offset: 0, 0
  index: 1
swingO3
  rotate: false
  xy: 313, 441
  size: 74, 64
  orig: 74, 64
  offset: 0, 0
  index: 2
stabO1
  rotate: false
  xy: 89, 390
  size: 66, 66
  orig: 66, 66
  offset: 0, 0
  index: 0
stabO2
  rotate: false
  xy: 89, 319
  size: 71, 69
  orig: 71, 69
  offset: 0, 0
  index: 0
stabO2
  rotate: false
  xy: 89, 248
  size: 71, 69
  orig: 71, 69
  offset: 0, 0
  index: 1
proneStab
  rotate: false
  xy: 157, 397
  size: 63, 42
  orig: 63, 42
  offset: 0, 0
  index: 0
prone
  rotate: false
  xy: 157, 397
  size: 63, 42
  orig: 63, 42
  offset: 0, 0
  index: 0
swingO2
  rotate: false
  xy: 162, 327
  size: 61, 68
  orig: 61, 68
  offset: 0, 0
  index: 0
swingO2
  rotate: false
  xy: 162, 257
  size: 61, 68
  orig: 61, 68
  offset: 0, 0
  index: 1
proneStab
  rotate: false
  xy: 222, 397
  size: 63, 42
  orig: 63, 42
  offset: 0, 0
  index: 1
swingO2
  rotate: false
  xy: 225, 327
  size: 61, 68
  orig: 61, 68
  offset: 0, 0
  index: 2
swingT3
  rotate: false
  xy: 225, 258
  size: 64, 67
  orig: 64, 67
  offset: 0, 0
  index: 0
alert
  rotate: false
  xy: 413, 644
  size: 47, 67
  orig: 47, 67
  offset: 0, 0
  index: 0
alert
  rotate: false
  xy: 413, 644
  size: 47, 67
  orig: 47, 67
  offset: 0, 0
  index: 4
stabO1
  rotate: false
  xy: 391, 576
  size: 66, 66
  orig: 66, 66
  offset: 0, 0
  index: 1
shootF
  rotate: false
  xy: 459, 572
  size: 52, 70
  orig: 52, 70
  offset: 0, 0
  index: 0
swingT3
  rotate: false
  xy: 390, 507
  size: 64, 67
  orig: 64, 67
  offset: 0, 0
  index: 1
swingT3
  rotate: false
  xy: 389, 438
  size: 64, 67
  orig: 64, 67
  offset: 0, 0
  index: 2
shootF
  rotate: false
  xy: 456, 500
  size: 52, 70
  orig: 52, 70
  offset: 0, 0
  index: 1
shootF
  rotate: false
  xy: 456, 500
  size: 52, 70
  orig: 52, 70
  offset: 0, 0
  index: 2
walk1
  rotate: false
  xy: 455, 430
  size: 52, 68
  orig: 52, 68
  offset: 0, 0
  index: 0
ladder
  rotate: false
  xy: 443, 713
  size: 49, 70
  orig: 49, 70
  offset: 0, 0
  index: 0
alert
  rotate: false
  xy: 462, 644
  size: 47, 67
  orig: 47, 67
  offset: 0, 0
  index: 1
alert
  rotate: false
  xy: 462, 644
  size: 47, 67
  orig: 47, 67
  offset: 0, 0
  index: 3
dead1
  rotate: false
  xy: 449, 785
  size: 49, 68
  orig: 49, 68
  offset: 0, 0
  index: 0
dead1
  rotate: false
  xy: 449, 785
  size: 49, 68
  orig: 49, 68
  offset: 0, 0
  index: 4
alert
  rotate: false
  xy: 457, 855
  size: 47, 67
  orig: 47, 67
  offset: 0, 0
  index: 2
heal
  rotate: false
  xy: 101, 178
  size: 57, 68
  orig: 57, 68
  offset: 0, 0
  index: 0
heal
  rotate: false
  xy: 101, 108
  size: 57, 68
  orig: 57, 68
  offset: 0, 0
  index: 1
heal
  rotate: false
  xy: 101, 38
  size: 57, 68
  orig: 57, 68
  offset: 0, 0
  index: 2
fly
  rotate: false
  xy: 288, 366
  size: 49, 73
  orig: 49, 73
  offset: 0, 0
  index: 0
shoot2
  rotate: false
  xy: 339, 370
  size: 48, 69
  orig: 48, 69
  offset: 0, 0
  index: 0
walk1
  rotate: false
  xy: 389, 368
  size: 52, 68
  orig: 52, 68
  offset: 0, 0
  index: 1
walk1
  rotate: false
  xy: 443, 360
  size: 52, 68
  orig: 52, 68
  offset: 0, 0
  index: 2
fly
  rotate: false
  xy: 291, 291
  size: 49, 73
  orig: 49, 73
  offset: 0, 0
  index: 1
sit
  rotate: false
  xy: 342, 306
  size: 45, 62
  orig: 45, 62
  offset: 0, 0
  index: 0
walk1
  rotate: false
  xy: 389, 298
  size: 52, 68
  orig: 52, 68
  offset: 0, 0
  index: 3
walk2
  rotate: false
  xy: 443, 290
  size: 52, 68
  orig: 52, 68
  offset: 0, 0
  index: 0
dead1
  rotate: false
  xy: 291, 221
  size: 49, 68
  orig: 49, 68
  offset: 0, 0
  index: 1
dead1
  rotate: false
  xy: 291, 221
  size: 49, 68
  orig: 49, 68
  offset: 0, 0
  index: 3
shoot1
  rotate: false
  xy: 342, 226
  size: 51, 70
  orig: 51, 70
  offset: 0, 0
  index: 0
rope
  rotate: false
  xy: 395, 225
  size: 46, 71
  orig: 46, 71
  offset: 0, 0
  index: 0
walk2
  rotate: false
  xy: 443, 220
  size: 52, 68
  orig: 52, 68
  offset: 0, 0
  index: 1
rope
  rotate: false
  xy: 160, 175
  size: 46, 71
  orig: 46, 71
  offset: 0, 0
  index: 1
ladder
  rotate: false
  xy: 160, 103
  size: 49, 70
  orig: 49, 70
  offset: 0, 0
  index: 1
dead1
  rotate: false
  xy: 160, 33
  size: 49, 68
  orig: 49, 68
  offset: 0, 0
  index: 2
shoot1
  rotate: false
  xy: 208, 185
  size: 51, 70
  orig: 51, 70
  offset: 0, 0
  index: 1
shoot1
  rotate: false
  xy: 211, 113
  size: 51, 70
  orig: 51, 70
  offset: 0, 0
  index: 2
walk2
  rotate: false
  xy: 211, 43
  size: 52, 68
  orig: 52, 68
  offset: 0, 0
  index: 2
walk2
  rotate: false
  xy: 264, 151
  size: 52, 68
  orig: 52, 68
  offset: 0, 0
  index: 3
shoot2
  rotate: false
  xy: 318, 150
  size: 48, 69
  orig: 48, 69
  offset: 0, 0
  index: 1
jump
  rotate: false
  xy: 368, 157
  size: 51, 66
  orig: 51, 66
  offset: 0, 0
  index: 0
stand1
  rotate: false
  xy: 421, 150
  size: 49, 68
  orig: 49, 68
  offset: 0, 0
  index: 0
stand1
  rotate: false
  xy: 421, 150
  size: 49, 68
  orig: 49, 68
  offset: 0, 0
  index: 4
shoot2
  rotate: false
  xy: 265, 80
  size: 48, 69
  orig: 48, 69
  offset: 0, 0
  index: 2
stand1
  rotate: false
  xy: 315, 80
  size: 49, 68
  orig: 49, 68
  offset: 0, 0
  index: 1
stand1
  rotate: false
  xy: 315, 80
  size: 49, 68
  orig: 49, 68
  offset: 0, 0
  index: 3
stand1
  rotate: false
  xy: 265, 10
  size: 49, 68
  orig: 49, 68
  offset: 0, 0
  index: 2
shoot2
  rotate: false
  xy: 316, 9
  size: 48, 69
  orig: 48, 69
  offset: 0, 0
  index: 3
shoot2
  rotate: false
  xy: 366, 79
  size: 48, 69
  orig: 48, 69
  offset: 0, 0
  index: 4
stand2
  rotate: false
  xy: 366, 9
  size: 49, 68
  orig: 49, 68
  offset: 0, 0
  index: 0
stand2
  rotate: false
  xy: 366, 9
  size: 49, 68
  orig: 49, 68
  offset: 0, 0
  index: 4
stand2
  rotate: false
  xy: 416, 80
  size: 49, 68
  orig: 49, 68
  offset: 0, 0
  index: 1
stand2
  rotate: false
  xy: 416, 80
  size: 49, 68
  orig: 49, 68
  offset: 0, 0
  index: 3
stand2
  rotate: false
  xy: 417, 10
  size: 49, 68
  orig: 49, 68
  offset: 0, 0
  index: 2

```

`android/assets/textures/entities/player/player.xml`:

```xml
<offset>
  <walk1 delay="180" x="-24" y="-68"/>
  <walk1 delay="180" x="-24" y="-68"/>
  <walk1 delay="180" x="-24" y="-68"/>
  <walk1 delay="180" x="-24" y="-68"/>
  <walk2 delay="180" x="-24" y="-68"/>
  <walk2 delay="180" x="-24" y="-68"/>
  <walk2 delay="180" x="-24" y="-68"/>
  <walk2 delay="180" x="-24" y="-68"/>
  <stand1 delay="500" x="-21" y="-68"/>
  <stand1 delay="500" x="-21" y="-68"/>
  <stand1 delay="500" x="-21" y="-68"/>
  <stand1 delay="500" x="-21" y="-68"/>
  <stand1 delay="500" x="-21" y="-68"/>
  <stand2 delay="500" x="-21" y="-68"/>
  <stand2 delay="500" x="-21" y="-68"/>
  <stand2 delay="500" x="-21" y="-68"/>
  <stand2 delay="500" x="-21" y="-68"/>
  <stand2 delay="500" x="-21" y="-68"/>
  <alert delay="500" x="-19" y="-67"/>
  <alert delay="500" x="-19" y="-67"/>
  <alert delay="500" x="-19" y="-67"/>
  <alert delay="500" x="-19" y="-67"/>
  <alert delay="500" x="-19" y="-67"/>
  <swingO1 delay="300" x="-27" y="-67"/>
  <swingO1 delay="150" x="-27" y="-67"/>
  <swingO1 delay="350" x="-27" y="-67"/>
  <swingO2 delay="300" x="-20" y="-68"/>
  <swingO2 delay="150" x="-20" y="-68"/>
  <swingO2 delay="350" x="-20" y="-68"/>
  <swingO3 delay="300" x="-16" y="-64"/>
  <swingO3 delay="150" x="-16" y="-64"/>
  <swingO3 delay="350" x="-16" y="-64"/>
  <swingOF delay="200" x="-16" y="-78"/>
  <swingOF delay="100" x="-16" y="-78"/>
  <swingOF delay="100" x="-16" y="-78"/>
  <swingOF delay="300" x="-16" y="-78"/>
  <swingT1 delay="300" x="-17" y="-68"/>
  <swingT1 delay="150" x="-17" y="-68"/>
  <swingT1 delay="350" x="-17" y="-68"/>
  <swingT2 delay="300" x="-28" y="-66"/>
  <swingT2 delay="150" x="-28" y="-66"/>
  <swingT2 delay="350" x="-28" y="-66"/>
  <swingT3 delay="300" x="-20" y="-66"/>
  <swingT3 delay="150" x="-20" y="-66"/>
  <swingT3 delay="350" x="-20" y="-66"/>
  <swingTF delay="200" x="-22" y="-69"/>
  <swingTF delay="150" x="-22" y="-69"/>
  <swingTF delay="150" x="-22" y="-69"/>
  <swingTF delay="200" x="-22" y="-69"/>
  <swingP1 delay="300" x="-18" y="-68"/>
  <swingP1 delay="150" x="-18" y="-68"/>
  <swingP1 delay="350" x="-18" y="-68"/>
  <swingP2 delay="300" x="-33" y="-68"/>
  <swingP2 delay="150" x="-33" y="-68"/>
  <swingP2 delay="350" x="-33" y="-68"/>
  <swingPF delay="100" x="-19" y="-94"/>
  <swingPF delay="200" x="-19" y="-94"/>
  <swingPF delay="200" x="-19" y="-94"/>
  <swingPF delay="200" x="-19" y="-94"/>
  <stabO1 delay="350" x="-19" y="-65"/>
  <stabO1 delay="450" x="-19" y="-65"/>
  <stabO2 delay="350" x="-21" y="-68"/>
  <stabO2 delay="450" x="-21" y="-68"/>
  <stabOF delay="250" x="-24" y="-66"/>
  <stabOF delay="150" x="-24" y="-66"/>
  <stabOF delay="300" x="-24" y="-66"/>
  <stabT1 delay="300" x="-17" y="-64"/>
  <stabT1 delay="100" x="-17" y="-64"/>
  <stabT1 delay="350" x="-17" y="-64"/>
  <stabT2 delay="300" x="-26" y="-65"/>
  <stabT2 delay="100" x="-26" y="-65"/>
  <stabT2 delay="350" x="-26" y="-65"/>
  <stabTF delay="100" x="-19" y="-94"/>
  <stabTF delay="200" x="-19" y="-94"/>
  <stabTF delay="200" x="-19" y="-94"/>
  <stabTF delay="200" x="-19" y="-94"/>
  <shoot1 delay="300" x="-20" y="-68"/>
  <shoot1 delay="150" x="-20" y="-68"/>
  <shoot1 delay="350" x="-20" y="-68"/>
  <shoot2 delay="160" x="-19" y="-67"/>
  <shoot2 delay="160" x="-19" y="-67"/>
  <shoot2 delay="250" x="-19" y="-67"/>
  <shoot2 delay="100" x="-19" y="-67"/>
  <shoot2 delay="150" x="-19" y="-67"/>
  <shootF delay="300" x="-18" y="-68"/>
  <shootF delay="150" x="-18" y="-68"/>
  <shootF delay="250" x="-18" y="-68"/>
  <proneStab delay="300" x="-16" y="-40"/>
  <proneStab delay="400" x="-16" y="-40"/>
  <prone delay="100" x="-16" y="-40"/>
  <heal delay="300" x="-22" y="-68"/>
  <heal delay="150" x="-22" y="-68"/>
  <heal delay="350" x="-22" y="-68"/>
  <fly delay="300" x="-21" y="-73"/>
  <fly delay="300" x="-21" y="-73"/>
  <jump delay="200" x="-23" y="-66"/>
  <sit delay="100" x="-20" y="-64"/>
  <ladder delay="250" x="-26" y="-66"/>
  <ladder delay="250" x="-26" y="-66"/>
  <rope delay="250" x="-25" y="-69"/>
  <rope delay="250" x="-25" y="-69"/>
  <dead1 delay="250" x="-25" y="-69"/>
  <dead1 delay="250" x="-25" y="-69"/>
  <dead1 delay="250" x="-25" y="-69"/>
  <dead1 delay="250" x="-25" y="-69"/>
  <dead1 delay="250" x="-25" y="-69"/>
 </offset>
```

`android/assets/textures/entities/player/tombstone.pack`:

```pack

tombstone.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
fall
  rotate: false
  xy: 1, 50
  size: 101, 47
  orig: 101, 47
  offset: 0, 0
  index: 0
fall
  rotate: false
  xy: 1, 1
  size: 101, 47
  orig: 101, 47
  offset: 0, 0
  index: 1
fall
  rotate: false
  xy: 1, 1
  size: 101, 47
  orig: 101, 47
  offset: 0, 0
  index: 19
fall
  rotate: false
  xy: 104, 50
  size: 101, 47
  orig: 101, 47
  offset: 0, 0
  index: 10
fall
  rotate: false
  xy: 104, 1
  size: 101, 47
  orig: 101, 47
  offset: 0, 0
  index: 11
fall
  rotate: false
  xy: 207, 50
  size: 101, 47
  orig: 101, 47
  offset: 0, 0
  index: 12
fall
  rotate: false
  xy: 207, 1
  size: 101, 47
  orig: 101, 47
  offset: 0, 0
  index: 13
fall
  rotate: false
  xy: 310, 50
  size: 101, 47
  orig: 101, 47
  offset: 0, 0
  index: 14
fall
  rotate: false
  xy: 310, 1
  size: 101, 47
  orig: 101, 47
  offset: 0, 0
  index: 15
fall
  rotate: false
  xy: 310, 1
  size: 101, 47
  orig: 101, 47
  offset: 0, 0
  index: 16
fall
  rotate: false
  xy: 413, 50
  size: 101, 47
  orig: 101, 47
  offset: 0, 0
  index: 17
fall
  rotate: false
  xy: 413, 1
  size: 101, 47
  orig: 101, 47
  offset: 0, 0
  index: 18
fall
  rotate: false
  xy: 516, 50
  size: 101, 47
  orig: 101, 47
  offset: 0, 0
  index: 2
fall
  rotate: false
  xy: 516, 1
  size: 101, 47
  orig: 101, 47
  offset: 0, 0
  index: 3
fall
  rotate: false
  xy: 619, 50
  size: 101, 47
  orig: 101, 47
  offset: 0, 0
  index: 4
fall
  rotate: false
  xy: 619, 1
  size: 101, 47
  orig: 101, 47
  offset: 0, 0
  index: 5
fall
  rotate: false
  xy: 722, 50
  size: 101, 47
  orig: 101, 47
  offset: 0, 0
  index: 6
fall
  rotate: false
  xy: 722, 1
  size: 101, 47
  orig: 101, 47
  offset: 0, 0
  index: 7
fall
  rotate: false
  xy: 825, 50
  size: 101, 47
  orig: 101, 47
  offset: 0, 0
  index: 8
fall
  rotate: false
  xy: 825, 1
  size: 101, 47
  orig: 101, 47
  offset: 0, 0
  index: 9

```

`android/assets/textures/entities/projectiles/explosion/explosion.pack`:

```pack

explosion.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
end
  rotate: false
  xy: 1, 659
  size: 345, 327
  orig: 345, 327
  offset: 0, 0
  index: 0
end
  rotate: false
  xy: 1, 330
  size: 345, 327
  orig: 345, 327
  offset: 0, 0
  index: 1
end
  rotate: false
  xy: 348, 659
  size: 345, 327
  orig: 345, 327
  offset: 0, 0
  index: 2
end
  rotate: false
  xy: 1, 1
  size: 345, 327
  orig: 345, 327
  offset: 0, 0
  index: 3
end
  rotate: false
  xy: 348, 330
  size: 345, 327
  orig: 345, 327
  offset: 0, 0
  index: 4
end
  rotate: false
  xy: 348, 1
  size: 345, 327
  orig: 345, 327
  offset: 0, 0
  index: 5

```

`android/assets/textures/entities/projectiles/iceball/iceball.pack`:

```pack

iceball.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
effect
  rotate: false
  xy: 1, 784
  size: 257, 192
  orig: 257, 192
  offset: 0, 0
  index: 0
effect
  rotate: false
  xy: 1, 590
  size: 257, 192
  orig: 257, 192
  offset: 0, 0
  index: 1
effect
  rotate: false
  xy: 260, 784
  size: 257, 192
  orig: 257, 192
  offset: 0, 0
  index: 10
effect
  rotate: false
  xy: 1, 396
  size: 257, 192
  orig: 257, 192
  offset: 0, 0
  index: 11
effect
  rotate: false
  xy: 260, 590
  size: 257, 192
  orig: 257, 192
  offset: 0, 0
  index: 12
effect
  rotate: false
  xy: 519, 784
  size: 257, 192
  orig: 257, 192
  offset: 0, 0
  index: 13
effect
  rotate: false
  xy: 1, 202
  size: 257, 192
  orig: 257, 192
  offset: 0, 0
  index: 2
effect
  rotate: false
  xy: 260, 396
  size: 257, 192
  orig: 257, 192
  offset: 0, 0
  index: 3
effect
  rotate: false
  xy: 519, 590
  size: 257, 192
  orig: 257, 192
  offset: 0, 0
  index: 4
effect
  rotate: false
  xy: 1, 8
  size: 257, 192
  orig: 257, 192
  offset: 0, 0
  index: 5
effect
  rotate: false
  xy: 260, 202
  size: 257, 192
  orig: 257, 192
  offset: 0, 0
  index: 6
effect
  rotate: false
  xy: 519, 396
  size: 257, 192
  orig: 257, 192
  offset: 0, 0
  index: 7
effect
  rotate: false
  xy: 260, 8
  size: 257, 192
  orig: 257, 192
  offset: 0, 0
  index: 8
effect
  rotate: false
  xy: 519, 202
  size: 257, 192
  orig: 257, 192
  offset: 0, 0
  index: 9
ball
  rotate: false
  xy: 778, 873
  size: 184, 103
  orig: 184, 103
  offset: 0, 0
  index: 0
ball
  rotate: false
  xy: 519, 97
  size: 184, 103
  orig: 184, 103
  offset: 0, 0
  index: 1
ball
  rotate: false
  xy: 778, 768
  size: 184, 103
  orig: 184, 103
  offset: 0, 0
  index: 2
ball
  rotate: false
  xy: 778, 663
  size: 184, 103
  orig: 184, 103
  offset: 0, 0
  index: 3
hit.0
  rotate: false
  xy: 778, 567
  size: 109, 94
  orig: 109, 94
  offset: 0, 0
  index: 0
hit.0
  rotate: false
  xy: 778, 471
  size: 109, 94
  orig: 109, 94
  offset: 0, 0
  index: 1
hit.0
  rotate: false
  xy: 778, 375
  size: 109, 94
  orig: 109, 94
  offset: 0, 0
  index: 2
hit.0
  rotate: false
  xy: 778, 279
  size: 109, 94
  orig: 109, 94
  offset: 0, 0
  index: 3
hit.0
  rotate: false
  xy: 519, 1
  size: 109, 94
  orig: 109, 94
  offset: 0, 0
  index: 4
2221003
  rotate: false
  xy: 964, 944
  size: 32, 32
  orig: 32, 32
  offset: 0, 0
  index: 0
2221003
  rotate: false
  xy: 705, 168
  size: 32, 32
  orig: 32, 32
  offset: 0, 0
  index: 1
2221003
  rotate: false
  xy: 889, 629
  size: 32, 32
  orig: 32, 32
  offset: 0, 0
  index: 2

```

`android/assets/textures/entities/projectiles/icespike/icespike.pack`:

```pack

icespike.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
start
  rotate: false
  xy: 1, 1
  size: 60, 180
  orig: 60, 180
  offset: 0, 0
  index: 0
start
  rotate: false
  xy: 63, 1
  size: 60, 180
  orig: 60, 180
  offset: 0, 0
  index: 1
start
  rotate: false
  xy: 125, 1
  size: 60, 180
  orig: 60, 180
  offset: 0, 0
  index: 2
start
  rotate: false
  xy: 187, 1
  size: 60, 180
  orig: 60, 180
  offset: 0, 0
  index: 3
start
  rotate: false
  xy: 249, 1
  size: 60, 180
  orig: 60, 180
  offset: 0, 0
  index: 4
start
  rotate: false
  xy: 311, 1
  size: 60, 180
  orig: 60, 180
  offset: 0, 0
  index: 5
start
  rotate: false
  xy: 373, 1
  size: 60, 180
  orig: 60, 180
  offset: 0, 0
  index: 6
start
  rotate: false
  xy: 435, 1
  size: 60, 180
  orig: 60, 180
  offset: 0, 0
  index: 7
end
  rotate: false
  xy: 497, 1
  size: 56, 180
  orig: 56, 180
  offset: 0, 0
  index: 0
ing
  rotate: false
  xy: 497, 1
  size: 56, 180
  orig: 56, 180
  offset: 0, 0
  index: 0
end
  rotate: false
  xy: 555, 1
  size: 56, 180
  orig: 56, 180
  offset: 0, 0
  index: 1
ing
  rotate: false
  xy: 555, 1
  size: 56, 180
  orig: 56, 180
  offset: 0, 0
  index: 1
end
  rotate: false
  xy: 613, 1
  size: 56, 180
  orig: 56, 180
  offset: 0, 0
  index: 2
ing
  rotate: false
  xy: 613, 1
  size: 56, 180
  orig: 56, 180
  offset: 0, 0
  index: 2
end
  rotate: false
  xy: 671, 1
  size: 56, 180
  orig: 56, 180
  offset: 0, 0
  index: 3
ing
  rotate: false
  xy: 671, 1
  size: 56, 180
  orig: 56, 180
  offset: 0, 0
  index: 3
end
  rotate: false
  xy: 729, 1
  size: 56, 180
  orig: 56, 180
  offset: 0, 0
  index: 4
ing
  rotate: false
  xy: 729, 1
  size: 56, 180
  orig: 56, 180
  offset: 0, 0
  index: 4
end
  rotate: false
  xy: 787, 1
  size: 56, 180
  orig: 56, 180
  offset: 0, 0
  index: 5
ing
  rotate: false
  xy: 787, 1
  size: 56, 180
  orig: 56, 180
  offset: 0, 0
  index: 5
end
  rotate: false
  xy: 845, 1
  size: 56, 180
  orig: 56, 180
  offset: 0, 0
  index: 6
ing
  rotate: false
  xy: 845, 1
  size: 56, 180
  orig: 56, 180
  offset: 0, 0
  index: 6

```

`android/assets/textures/entities/projectiles/magicbolt/magicbolt.pack`:

```pack

magicbolt.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
hit.0
  rotate: false
  xy: 1, 36
  size: 71, 67
  orig: 71, 67
  offset: 0, 0
  index: 0
hit.0
  rotate: false
  xy: 74, 36
  size: 71, 67
  orig: 71, 67
  offset: 0, 0
  index: 1
hit.0
  rotate: false
  xy: 147, 36
  size: 71, 67
  orig: 71, 67
  offset: 0, 0
  index: 2
hit.1
  rotate: false
  xy: 220, 39
  size: 73, 64
  orig: 73, 64
  offset: 0, 0
  index: 0
hit.1
  rotate: false
  xy: 295, 39
  size: 73, 64
  orig: 73, 64
  offset: 0, 0
  index: 1
hit.1
  rotate: false
  xy: 370, 39
  size: 73, 64
  orig: 73, 64
  offset: 0, 0
  index: 2
ball
  rotate: false
  xy: 1, 1
  size: 33, 33
  orig: 33, 33
  offset: 0, 0
  index: 0
ball
  rotate: false
  xy: 445, 70
  size: 33, 33
  orig: 33, 33
  offset: 0, 0
  index: 1
ball
  rotate: false
  xy: 445, 70
  size: 33, 33
  orig: 33, 33
  offset: 0, 0
  index: 3
ball
  rotate: false
  xy: 36, 1
  size: 33, 33
  orig: 33, 33
  offset: 0, 0
  index: 2
2001004
  rotate: false
  xy: 71, 2
  size: 32, 32
  orig: 32, 32
  offset: 0, 0
  index: 0
2001004
  rotate: false
  xy: 105, 2
  size: 32, 32
  orig: 32, 32
  offset: 0, 0
  index: 1
2001004
  rotate: false
  xy: 139, 2
  size: 32, 32
  orig: 32, 32
  offset: 0, 0
  index: 2

```

`android/assets/textures/entities/projectiles/swing/swing.pack`:

```pack

swing.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
0.swingOF.3
  rotate: false
  xy: 1, 54
  size: 144, 57
  orig: 144, 57
  offset: 0, 0
  index: 0
0.swingD1.1
  rotate: false
  xy: 147, 22
  size: 98, 89
  orig: 98, 89
  offset: 0, 0
  index: 0
0.swingD1.1
  rotate: false
  xy: 247, 22
  size: 98, 89
  orig: 98, 89
  offset: 0, 0
  index: 1
0.swingD1.1
  rotate: false
  xy: 347, 22
  size: 98, 89
  orig: 98, 89
  offset: 0, 0
  index: 2
0.swingD1.1
  rotate: false
  xy: 447, 22
  size: 98, 89
  orig: 98, 89
  offset: 0, 0
  index: 3
0.swingD2.1
  rotate: false
  xy: 547, 25
  size: 97, 86
  orig: 97, 86
  offset: 0, 0
  index: 0
0.swingD2.1
  rotate: false
  xy: 646, 25
  size: 97, 86
  orig: 97, 86
  offset: 0, 0
  index: 1
0.swingO2.2
  rotate: false
  xy: 745, 29
  size: 88, 82
  orig: 88, 82
  offset: 0, 0
  index: 0
0.swingO1.2
  rotate: false
  xy: 835, 43
  size: 79, 68
  orig: 79, 68
  offset: 0, 0
  index: 0
0.swingO3.2
  rotate: false
  xy: 1, 1
  size: 93, 51
  orig: 93, 51
  offset: 0, 0
  index: 0

```

`android/assets/textures/entities/projectiles/swirlingmoon/swirlingmoon.pack`:

```pack

swirlingmoon.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
effect
  rotate: false
  xy: 1, 400
  size: 623, 535
  orig: 623, 535
  offset: 0, 0
  index: 0
hit.0
  rotate: false
  xy: 1, 88
  size: 310, 310
  orig: 310, 310
  offset: 0, 0
  index: 0
hit.0
  rotate: false
  xy: 626, 625
  size: 310, 310
  orig: 310, 310
  offset: 0, 0
  index: 1
hit.0
  rotate: false
  xy: 313, 88
  size: 310, 310
  orig: 310, 310
  offset: 0, 0
  index: 2
hit.0
  rotate: false
  xy: 626, 313
  size: 310, 310
  orig: 310, 310
  offset: 0, 0
  index: 3
hit.0
  rotate: false
  xy: 625, 1
  size: 310, 310
  orig: 310, 310
  offset: 0, 0
  index: 4
11121101
  rotate: false
  xy: 938, 894
  size: 41, 41
  orig: 41, 41
  offset: 0, 0
  index: 0
11121101
  rotate: false
  xy: 1, 45
  size: 41, 41
  orig: 41, 41
  offset: 0, 0
  index: 1
11121101
  rotate: false
  xy: 938, 851
  size: 41, 41
  orig: 41, 41
  offset: 0, 0
  index: 2

swirlingmoon2.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
effect
  rotate: false
  xy: 1, 313
  size: 623, 535
  orig: 623, 535
  offset: 0, 0
  index: 1
hit.0
  rotate: false
  xy: 1, 1
  size: 310, 310
  orig: 310, 310
  offset: 0, 0
  index: 5
hit.0
  rotate: false
  xy: 626, 538
  size: 310, 310
  orig: 310, 310
  offset: 0, 0
  index: 6
hit.0
  rotate: false
  xy: 313, 1
  size: 310, 310
  orig: 310, 310
  offset: 0, 0
  index: 7

swirlingmoon3.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
effect
  rotate: false
  xy: 1, 1
  size: 623, 535
  orig: 623, 535
  offset: 0, 0
  index: 10

swirlingmoon4.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
effect
  rotate: false
  xy: 1, 1
  size: 623, 535
  orig: 623, 535
  offset: 0, 0
  index: 11

swirlingmoon5.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
effect
  rotate: false
  xy: 1, 1
  size: 623, 535
  orig: 623, 535
  offset: 0, 0
  index: 12

swirlingmoon6.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
effect
  rotate: false
  xy: 1, 1
  size: 623, 535
  orig: 623, 535
  offset: 0, 0
  index: 2

swirlingmoon7.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
effect
  rotate: false
  xy: 1, 1
  size: 623, 535
  orig: 623, 535
  offset: 0, 0
  index: 3

swirlingmoon8.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
effect
  rotate: false
  xy: 1, 1
  size: 623, 535
  orig: 623, 535
  offset: 0, 0
  index: 4

swirlingmoon9.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
effect
  rotate: false
  xy: 1, 1
  size: 623, 535
  orig: 623, 535
  offset: 0, 0
  index: 5

swirlingmoon10.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
effect
  rotate: false
  xy: 1, 1
  size: 623, 535
  orig: 623, 535
  offset: 0, 0
  index: 6

swirlingmoon11.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
effect
  rotate: false
  xy: 1, 1
  size: 623, 535
  orig: 623, 535
  offset: 0, 0
  index: 7

swirlingmoon12.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
effect
  rotate: false
  xy: 1, 1
  size: 623, 535
  orig: 623, 535
  offset: 0, 0
  index: 8

swirlingmoon13.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
effect
  rotate: false
  xy: 1, 1
  size: 623, 535
  orig: 623, 535
  offset: 0, 0
  index: 9

```

`android/assets/textures/hud/bars/hud_bars.pack`:

```pack

hud_bars.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
hud_hp_frame
  rotate: false
  xy: 1, 1
  size: 402, 55
  orig: 402, 55
  offset: 0, 0
  index: -1
hud_hp_bar
  rotate: false
  xy: 405, 44
  size: 391, 12
  orig: 391, 12
  offset: 0, 0
  index: -1
hud_mp_bar
  rotate: false
  xy: 405, 30
  size: 391, 12
  orig: 391, 12
  offset: 0, 0
  index: -1
oshp_bar
  rotate: false
  xy: 798, 47
  size: 52, 9
  orig: 52, 9
  offset: 0, 0
  index: -1
oshp_frame
  rotate: false
  xy: 405, 19
  size: 52, 9
  orig: 52, 9
  offset: 0, 0
  index: -1

```

`android/assets/textures/hud/damage/hitMonster/hitMonster.pack`:

```pack

hitMonster.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
hitMonster
  rotate: false
  xy: 1, 2
  size: 107, 38
  orig: 107, 38
  offset: 0, 0
  index: 21
hitMonster
  rotate: false
  xy: 110, 2
  size: 98, 38
  orig: 98, 38
  offset: 0, 0
  index: 20
hitMonster
  rotate: false
  xy: 210, 2
  size: 37, 38
  orig: 37, 38
  offset: 0, 0
  index: 10
hitMonster
  rotate: false
  xy: 249, 2
  size: 36, 38
  orig: 36, 38
  offset: 0, 0
  index: 16
hitMonster
  rotate: false
  xy: 287, 1
  size: 36, 39
  orig: 36, 39
  offset: 0, 0
  index: 18
hitMonster
  rotate: false
  xy: 325, 2
  size: 36, 38
  orig: 36, 38
  offset: 0, 0
  index: 19
hitMonster
  rotate: false
  xy: 363, 3
  size: 36, 37
  orig: 36, 37
  offset: 0, 0
  index: 14
hitMonster
  rotate: false
  xy: 401, 2
  size: 34, 38
  orig: 34, 38
  offset: 0, 0
  index: 12
hitMonster
  rotate: false
  xy: 437, 2
  size: 34, 38
  orig: 34, 38
  offset: 0, 0
  index: 15
hitMonster
  rotate: false
  xy: 473, 2
  size: 33, 38
  orig: 33, 38
  offset: 0, 0
  index: 13
hitMonster
  rotate: false
  xy: 508, 2
  size: 33, 38
  orig: 33, 38
  offset: 0, 0
  index: 17
hitMonster
  rotate: false
  xy: 543, 7
  size: 31, 33
  orig: 31, 33
  offset: 0, 0
  index: 0
hitMonster
  rotate: false
  xy: 576, 7
  size: 31, 33
  orig: 31, 33
  offset: 0, 0
  index: 4
hitMonster
  rotate: false
  xy: 609, 7
  size: 31, 33
  orig: 31, 33
  offset: 0, 0
  index: 6
hitMonster
  rotate: false
  xy: 642, 7
  size: 31, 33
  orig: 31, 33
  offset: 0, 0
  index: 8
hitMonster
  rotate: false
  xy: 675, 7
  size: 31, 33
  orig: 31, 33
  offset: 0, 0
  index: 9
hitMonster
  rotate: false
  xy: 708, 7
  size: 29, 33
  orig: 29, 33
  offset: 0, 0
  index: 2
hitMonster
  rotate: false
  xy: 739, 8
  size: 29, 32
  orig: 29, 32
  offset: 0, 0
  index: 5
hitMonster
  rotate: false
  xy: 770, 8
  size: 29, 32
  orig: 29, 32
  offset: 0, 0
  index: 7
hitMonster
  rotate: false
  xy: 801, 8
  size: 28, 32
  orig: 28, 32
  offset: 0, 0
  index: 3
hitMonster
  rotate: false
  xy: 831, 3
  size: 25, 37
  orig: 25, 37
  offset: 0, 0
  index: 11
hitMonster
  rotate: false
  xy: 858, 8
  size: 22, 32
  orig: 22, 32
  offset: 0, 0
  index: 1

```

`android/assets/textures/hud/damage/hitMonsterCrit/hitMonsterCrit.pack`:

```pack

hitMonsterCrit.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
hitMonsterCrit
  rotate: false
  xy: 1, 1
  size: 62, 57
  orig: 62, 57
  offset: 0, 0
  index: 20
hitMonsterCrit
  rotate: false
  xy: 65, 10
  size: 43, 48
  orig: 43, 48
  offset: 0, 0
  index: 10
hitMonsterCrit
  rotate: false
  xy: 110, 13
  size: 43, 45
  orig: 43, 45
  offset: 0, 0
  index: 14
hitMonsterCrit
  rotate: false
  xy: 155, 13
  size: 43, 45
  orig: 43, 45
  offset: 0, 0
  index: 16
hitMonsterCrit
  rotate: false
  xy: 200, 12
  size: 42, 46
  orig: 42, 46
  offset: 0, 0
  index: 19
hitMonsterCrit
  rotate: false
  xy: 244, 12
  size: 41, 46
  orig: 41, 46
  offset: 0, 0
  index: 18
hitMonsterCrit
  rotate: false
  xy: 287, 12
  size: 40, 46
  orig: 40, 46
  offset: 0, 0
  index: 13
hitMonsterCrit
  rotate: false
  xy: 329, 13
  size: 40, 45
  orig: 40, 45
  offset: 0, 0
  index: 12
hitMonsterCrit
  rotate: false
  xy: 371, 13
  size: 40, 45
  orig: 40, 45
  offset: 0, 0
  index: 17
hitMonsterCrit
  rotate: false
  xy: 413, 12
  size: 39, 46
  orig: 39, 46
  offset: 0, 0
  index: 15
hitMonsterCrit
  rotate: false
  xy: 454, 20
  size: 37, 38
  orig: 37, 38
  offset: 0, 0
  index: 0
hitMonsterCrit
  rotate: false
  xy: 493, 20
  size: 37, 38
  orig: 37, 38
  offset: 0, 0
  index: 4
hitMonsterCrit
  rotate: false
  xy: 532, 20
  size: 37, 38
  orig: 37, 38
  offset: 0, 0
  index: 6
hitMonsterCrit
  rotate: false
  xy: 571, 20
  size: 36, 38
  orig: 36, 38
  offset: 0, 0
  index: 9
hitMonsterCrit
  rotate: false
  xy: 609, 20
  size: 34, 38
  orig: 34, 38
  offset: 0, 0
  index: 2
hitMonsterCrit
  rotate: false
  xy: 645, 19
  size: 34, 39
  orig: 34, 39
  offset: 0, 0
  index: 8
hitMonsterCrit
  rotate: false
  xy: 681, 20
  size: 33, 38
  orig: 33, 38
  offset: 0, 0
  index: 3
hitMonsterCrit
  rotate: false
  xy: 716, 20
  size: 33, 38
  orig: 33, 38
  offset: 0, 0
  index: 5
hitMonsterCrit
  rotate: false
  xy: 751, 20
  size: 33, 38
  orig: 33, 38
  offset: 0, 0
  index: 7
hitMonsterCrit
  rotate: false
  xy: 786, 14
  size: 29, 44
  orig: 29, 44
  offset: 0, 0
  index: 11
hitMonsterCrit
  rotate: false
  xy: 817, 20
  size: 25, 38
  orig: 25, 38
  offset: 0, 0
  index: 1

```

`android/assets/textures/hud/damage/hitPlayer/hitPlayer.pack`:

```pack

hitPlayer.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
hitPlayer
  rotate: false
  xy: 1, 2
  size: 107, 38
  orig: 107, 38
  offset: 0, 0
  index: 21
hitPlayer
  rotate: false
  xy: 110, 2
  size: 98, 38
  orig: 98, 38
  offset: 0, 0
  index: 20
hitPlayer
  rotate: false
  xy: 210, 2
  size: 37, 38
  orig: 37, 38
  offset: 0, 0
  index: 10
hitPlayer
  rotate: false
  xy: 249, 2
  size: 36, 38
  orig: 36, 38
  offset: 0, 0
  index: 16
hitPlayer
  rotate: false
  xy: 287, 1
  size: 36, 39
  orig: 36, 39
  offset: 0, 0
  index: 18
hitPlayer
  rotate: false
  xy: 325, 2
  size: 36, 38
  orig: 36, 38
  offset: 0, 0
  index: 19
hitPlayer
  rotate: false
  xy: 363, 3
  size: 36, 37
  orig: 36, 37
  offset: 0, 0
  index: 14
hitPlayer
  rotate: false
  xy: 401, 2
  size: 34, 38
  orig: 34, 38
  offset: 0, 0
  index: 12
hitPlayer
  rotate: false
  xy: 437, 2
  size: 34, 38
  orig: 34, 38
  offset: 0, 0
  index: 15
hitPlayer
  rotate: false
  xy: 473, 2
  size: 33, 38
  orig: 33, 38
  offset: 0, 0
  index: 13
hitPlayer
  rotate: false
  xy: 508, 2
  size: 33, 38
  orig: 33, 38
  offset: 0, 0
  index: 17
hitPlayer
  rotate: false
  xy: 543, 7
  size: 31, 33
  orig: 31, 33
  offset: 0, 0
  index: 0
hitPlayer
  rotate: false
  xy: 576, 7
  size: 31, 33
  orig: 31, 33
  offset: 0, 0
  index: 4
hitPlayer
  rotate: false
  xy: 609, 7
  size: 31, 33
  orig: 31, 33
  offset: 0, 0
  index: 6
hitPlayer
  rotate: false
  xy: 642, 7
  size: 31, 33
  orig: 31, 33
  offset: 0, 0
  index: 8
hitPlayer
  rotate: false
  xy: 675, 7
  size: 31, 33
  orig: 31, 33
  offset: 0, 0
  index: 9
hitPlayer
  rotate: false
  xy: 708, 7
  size: 29, 33
  orig: 29, 33
  offset: 0, 0
  index: 2
hitPlayer
  rotate: false
  xy: 739, 8
  size: 29, 32
  orig: 29, 32
  offset: 0, 0
  index: 5
hitPlayer
  rotate: false
  xy: 770, 8
  size: 29, 32
  orig: 29, 32
  offset: 0, 0
  index: 7
hitPlayer
  rotate: false
  xy: 801, 8
  size: 28, 32
  orig: 28, 32
  offset: 0, 0
  index: 3
hitPlayer
  rotate: false
  xy: 831, 3
  size: 25, 37
  orig: 25, 37
  offset: 0, 0
  index: 11
hitPlayer
  rotate: false
  xy: 858, 8
  size: 22, 32
  orig: 22, 32
  offset: 0, 0
  index: 1

```

`android/assets/textures/menu/buttons/menu_buttons.pack`:

```pack

menu_buttons.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
button_highscore_bg
  rotate: false
  xy: 1, 875
  size: 1000, 144
  orig: 1000, 144
  offset: 0, 0
  index: 0
button_savelabelbg
  rotate: false
  xy: 1, 823
  size: 300, 50
  orig: 300, 50
  offset: 0, 0
  index: 0
button_savelabelbg
  rotate: false
  xy: 1, 771
  size: 300, 50
  orig: 300, 50
  offset: 0, 0
  index: 1
button_savelabelbg
  rotate: false
  xy: 303, 823
  size: 300, 50
  orig: 300, 50
  offset: 0, 0
  index: 2
button_highscore
  rotate: false
  xy: 1, 705
  size: 256, 64
  orig: 256, 64
  offset: 0, 0
  index: 0
button_highscore
  rotate: false
  xy: 1, 639
  size: 256, 64
  orig: 256, 64
  offset: 0, 0
  index: 1
button_highscore
  rotate: false
  xy: 1, 573
  size: 256, 64
  orig: 256, 64
  offset: 0, 0
  index: 2
button_mainmenu
  rotate: false
  xy: 1, 507
  size: 256, 64
  orig: 256, 64
  offset: 0, 0
  index: 0
button_mainmenu
  rotate: false
  xy: 1, 441
  size: 256, 64
  orig: 256, 64
  offset: 0, 0
  index: 1
button_mainmenu
  rotate: false
  xy: 1, 375
  size: 256, 64
  orig: 256, 64
  offset: 0, 0
  index: 2
button_overwrite
  rotate: false
  xy: 1, 309
  size: 256, 64
  orig: 256, 64
  offset: 0, 0
  index: 0
button_overwrite
  rotate: false
  xy: 1, 243
  size: 256, 64
  orig: 256, 64
  offset: 0, 0
  index: 1
button_overwrite
  rotate: false
  xy: 1, 177
  size: 256, 64
  orig: 256, 64
  offset: 0, 0
  index: 2
button_survival
  rotate: false
  xy: 1, 111
  size: 208, 64
  orig: 208, 64
  offset: 0, 0
  index: 0
button_survival
  rotate: false
  xy: 1, 45
  size: 208, 64
  orig: 208, 64
  offset: 0, 0
  index: 1
button_survival
  rotate: false
  xy: 303, 757
  size: 208, 64
  orig: 208, 64
  offset: 0, 0
  index: 2
button_general
  rotate: false
  xy: 605, 809
  size: 192, 64
  orig: 192, 64
  offset: 0, 0
  index: 0
button_general
  rotate: false
  xy: 799, 809
  size: 192, 64
  orig: 192, 64
  offset: 0, 0
  index: 1
button_general
  rotate: false
  xy: 259, 691
  size: 192, 64
  orig: 192, 64
  offset: 0, 0
  index: 2
button_layout
  rotate: false
  xy: 259, 625
  size: 192, 64
  orig: 192, 64
  offset: 0, 0
  index: 0
button_layout
  rotate: false
  xy: 259, 559
  size: 192, 64
  orig: 192, 64
  offset: 0, 0
  index: 1
button_layout
  rotate: false
  xy: 259, 493
  size: 192, 64
  orig: 192, 64
  offset: 0, 0
  index: 2
button_options
  rotate: false
  xy: 259, 427
  size: 192, 64
  orig: 192, 64
  offset: 0, 0
  index: 0
button_options
  rotate: false
  xy: 259, 361
  size: 192, 64
  orig: 192, 64
  offset: 0, 0
  index: 1
button_options
  rotate: false
  xy: 259, 295
  size: 192, 64
  orig: 192, 64
  offset: 0, 0
  index: 2
button_story
  rotate: false
  xy: 259, 229
  size: 192, 64
  orig: 192, 64
  offset: 0, 0
  index: 0
button_story
  rotate: false
  xy: 259, 163
  size: 192, 64
  orig: 192, 64
  offset: 0, 0
  index: 1
button_story
  rotate: false
  xy: 211, 97
  size: 192, 64
  orig: 192, 64
  offset: 0, 0
  index: 2
button_reset
  rotate: false
  xy: 211, 31
  size: 160, 64
  orig: 160, 64
  offset: 0, 0
  index: 0
button_arrow_h
  rotate: false
  xy: 453, 659
  size: 64, 96
  orig: 64, 96
  offset: 0, 0
  index: 0
button_arrow_h
  rotate: false
  xy: 453, 561
  size: 64, 96
  orig: 64, 96
  offset: 0, 0
  index: 1
button_arrow_h
  rotate: false
  xy: 453, 463
  size: 64, 96
  orig: 64, 96
  offset: 0, 0
  index: 2
button_back
  rotate: false
  xy: 453, 397
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 0
button_back
  rotate: false
  xy: 453, 331
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 1
button_back
  rotate: false
  xy: 453, 265
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 2
button_blank
  rotate: false
  xy: 453, 199
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 0
button_blank
  rotate: false
  xy: 453, 133
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 1
button_reset
  rotate: false
  xy: 405, 67
  size: 160, 64
  orig: 160, 64
  offset: 0, 0
  index: 1
button_reset
  rotate: false
  xy: 373, 1
  size: 160, 64
  orig: 160, 64
  offset: 0, 0
  index: 2
button_blank
  rotate: false
  xy: 583, 743
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 2
button_load
  rotate: false
  xy: 713, 743
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 0
button_load
  rotate: false
  xy: 843, 743
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 1
button_load
  rotate: false
  xy: 519, 677
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 2
button_new
  rotate: false
  xy: 519, 611
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 0
button_new
  rotate: false
  xy: 649, 677
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 1
button_new
  rotate: false
  xy: 519, 545
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 2
button_next
  rotate: false
  xy: 649, 611
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 0
button_next
  rotate: false
  xy: 779, 677
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 1
button_next
  rotate: false
  xy: 519, 479
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 2
button_play
  rotate: false
  xy: 649, 545
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 0
button_play
  rotate: false
  xy: 779, 611
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 1
button_play
  rotate: false
  xy: 649, 479
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 2
button_quit
  rotate: false
  xy: 779, 545
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 0
button_quit
  rotate: false
  xy: 779, 479
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 1
button_quit
  rotate: false
  xy: 583, 413
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 2
button_save
  rotate: false
  xy: 583, 347
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 0
button_save
  rotate: false
  xy: 713, 413
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 1
button_save
  rotate: false
  xy: 583, 281
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 2
button_start
  rotate: false
  xy: 713, 347
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 0
button_start
  rotate: false
  xy: 583, 215
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 1
button_start
  rotate: false
  xy: 713, 281
  size: 128, 64
  orig: 128, 64
  offset: 0, 0
  index: 2
button_arrow_v
  rotate: false
  xy: 583, 165
  size: 96, 48
  orig: 96, 48
  offset: 0, 0
  index: 0
button_arrow_v
  rotate: false
  xy: 713, 231
  size: 96, 48
  orig: 96, 48
  offset: 0, 0
  index: 1
button_arrow_v
  rotate: false
  xy: 583, 115
  size: 96, 48
  orig: 96, 48
  offset: 0, 0
  index: 2
button_check
  rotate: false
  xy: 513, 773
  size: 48, 48
  orig: 48, 48
  offset: 0, 0
  index: 0
button_check
  rotate: false
  xy: 909, 693
  size: 48, 48
  orig: 48, 48
  offset: 0, 0
  index: 1

```

`android/assets/textures/menu/loadingbar/menu_loadingbar.pack`:

```pack

menu_loadingbar.png
format: RGBA8888
filter: Nearest,Nearest
repeat: none
loadingbar
  rotate: false
  xy: 1, 47
  size: 380, 44
  orig: 380, 44
  offset: 0, 0
  index: -1
loadingframe
  rotate: false
  xy: 1, 1
  size: 380, 44
  orig: 380, 44
  offset: 0, 0
  index: -1
libgdx
  rotate: false
  xy: 383, 41
  size: 300, 50
  orig: 300, 50
  offset: 0, 0
  index: -1

```

`android/build.gradle`:

```gradle
android {
    buildToolsVersion "23.0.2"
    compileSdkVersion 20
    sourceSets {
        main {
            manifest.srcFile 'AndroidManifest.xml'
            java.srcDirs = ['src']
            aidl.srcDirs = ['src']
            renderscript.srcDirs = ['src']
            res.srcDirs = ['res']
            assets.srcDirs = ['assets']
        }

        instrumentTest.setRoot('tests')
    }
}

// needed to add JNI shared libraries to APK when compiling on CLI
tasks.withType(com.android.build.gradle.tasks.PackageApplication) { pkgTask ->
    pkgTask.jniFolders = new HashSet<File>()
    pkgTask.jniFolders.add(new File(projectDir, 'libs'))
}

// called every time gradle gets executed, takes the native dependencies of
// the natives configuration, and extracts them to the proper libs/ folders
// so they get packed with the APK.
task copyAndroidNatives() {
    file("libs/armeabi/").mkdirs();
    file("libs/armeabi-v7a/").mkdirs();
    file("libs/x86/").mkdirs();

    configurations.natives.files.each { jar ->
        def outputDir = null
        if (jar.name.endsWith("natives-armeabi-v7a.jar")) outputDir = file("libs/armeabi-v7a")
        if (jar.name.endsWith("natives-armeabi.jar")) outputDir = file("libs/armeabi")
        if (jar.name.endsWith("natives-x86.jar")) outputDir = file("libs/x86")
        if (outputDir != null) {
            copy {
                from zipTree(jar)
                into outputDir
                include "*.so"
            }
        }
    }
}

task run(type: Exec) {
    def path
    def localProperties = project.file("../local.properties")
    if (localProperties.exists()) {
        Properties properties = new Properties()
        localProperties.withInputStream { instr ->
            properties.load(instr)
        }
        def sdkDir = properties.getProperty('sdk.dir')
        if (sdkDir) {
            path = sdkDir
        } else {
            path = "$System.env.ANDROID_HOME"
        }
    } else {
        path = "$System.env.ANDROID_HOME"
    }

    def adb = path + "/platform-tools/adb"
    commandLine "$adb", 'shell', 'am', 'start', '-n', 'com.jxz.notcontra.game.android/com.jxz.notcontra.game.android.AndroidLauncher'
}

// sets up the Android Eclipse project, using the old Ant based build.
eclipse {
    // need to specify Java source sets explicitely, SpringSource Gradle Eclipse plugin
    // ignores any nodes added in classpath.file.withXml
    sourceSets {
        main {
            java.srcDirs "src", 'gen'
        }
    }

    jdt {
        sourceCompatibility = 1.6
        targetCompatibility = 1.6
    }

    classpath {
        plusConfigurations += [project.configurations.compile]
        containers 'com.android.ide.eclipse.adt.ANDROID_FRAMEWORK', 'com.android.ide.eclipse.adt.LIBRARIES'
    }

    project {
        name = appName + "-android"
        natures 'com.android.ide.eclipse.adt.AndroidNature'
        buildCommands.clear();
        buildCommand "com.android.ide.eclipse.adt.ResourceManagerBuilder"
        buildCommand "com.android.ide.eclipse.adt.PreCompilerBuilder"
        buildCommand "org.eclipse.jdt.core.javabuilder"
        buildCommand "com.android.ide.eclipse.adt.ApkBuilder"
    }
}

// sets up the Android Idea project, using the old Ant based build.
idea {
    module {
        sourceDirs += file("src");
        scopes = [COMPILE: [plus: [project.configurations.compile]]]

        iml {
            withXml {
                def node = it.asNode()
                def builder = NodeBuilder.newInstance();
                builder.current = node;
                builder.component(name: "FacetManager") {
                    facet(type: "android", name: "Android") {
                        configuration {
                            option(name: "UPDATE_PROPERTY_FILES", value: "true")
                        }
                    }
                }
            }
        }
    }
}

```

`android/proguard-project.txt`:

```txt
# To enable ProGuard in your project, edit project.properties
# to define the proguard.config property as described in that file.
#
# Add project specific ProGuard rules here.
# By default, the flags in this file are appended to flags specified
# in ${sdk.dir}/tools/proguard/proguard-android.txt
# You can edit the include path and order by changing the ProGuard
# include property in project.properties.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# Add any project specific keep options here:

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

-verbose

-dontwarn android.support.**
-dontwarn com.badlogic.gdx.backends.android.AndroidFragmentApplication
-dontwarn com.badlogic.gdx.utils.GdxBuild
-dontwarn com.badlogic.gdx.physics.box2d.utils.Box2DBuild
-dontwarn com.badlogic.gdx.jnigen.BuildTarget*

-keepclassmembers class com.badlogic.gdx.backends.android.AndroidInput* {
   <init>(com.badlogic.gdx.Application, android.content.Context, java.lang.Object, com.badlogic.gdx.backends.android.AndroidApplicationConfiguration);
}

-keepclassmembers class com.badlogic.gdx.physics.box2d.World {
   boolean contactFilter(long, long);
   void    beginContact(long);
   void    endContact(long);
   void    preSolve(long, long);
   void    postSolve(long, long);
   boolean reportFixture(long);
   float   reportRayFixture(long, float, float, float, float, float);
}

```

`android/project.properties`:

```properties
# This file is automatically generated by Android Tools.
# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
#
# This file must be checked in Version Control Systems.
#
# To customize properties used by the Ant build system edit
# "ant.properties", and override values to adapt the script to your
# project structure.
#
# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt

# Project target.
target=android-19

```

`android/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <string name="app_name">notcontra</string>

</resources>

```

`android/res/values/styles.xml`:

```xml
<resources>

    <style name="GdxTheme" parent="android:Theme">
        <item name="android:windowBackground">@android:color/transparent</item>
        <item name="android:colorBackgroundCacheHint">@null</item>
        <item name="android:windowAnimationStyle">@android:style/Animation</item>
        <item name="android:windowNoTitle">true</item>
        <item name="android:windowContentOverlay">@null</item>
        <item name="android:windowFullscreen">true</item>
    </style>

</resources>

```

`android/src/com/jxz/notcontra/game/android/AndroidLauncher.java`:

```java
package com.jxz.notcontra.game.android;

import android.os.Bundle;
import com.badlogic.gdx.backends.android.AndroidApplication;
import com.badlogic.gdx.backends.android.AndroidApplicationConfiguration;
import com.jxz.notcontra.game.Game;

public class AndroidLauncher extends AndroidApplication {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        AndroidApplicationConfiguration config = new AndroidApplicationConfiguration();
        initialize(new Game(), config);
    }
}

```

`build.gradle`:

```gradle
buildscript {
    repositories {
        mavenCentral()
        maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:1.0.0'
        classpath 'org.robovm:robovm-gradle-plugin:1.0.0'
    }
}

allprojects {
    apply plugin: "eclipse"
    apply plugin: "idea"

    version = '1.0'
    ext {
        appName = 'notcontra'
        gdxVersion = '1.8.0'
        roboVMVersion = '1.12.0'
        box2DLightsVersion = '1.4'
        ashleyVersion = '1.7.0'
        aiVersion = '1.7.0'
    }

    repositories {
        mavenCentral()
        maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
        maven { url "https://oss.sonatype.org/content/repositories/releases/" }
    }
}

project(":desktop") {
    apply plugin: "java"


    dependencies {
        compile project(":core")
        compile "com.badlogicgames.gdx:gdx-backend-lwjgl:$gdxVersion"
        compile "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-desktop"
        compile "com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-desktop"
        compile "com.badlogicgames.gdx:gdx-freetype-platform:$gdxVersion:natives-desktop"
        compile "com.badlogicgames.gdx:gdx-tools:$gdxVersion"
        compile "com.badlogicgames.gdx:gdx-controllers-desktop:$gdxVersion"
        compile "com.badlogicgames.gdx:gdx-controllers-platform:$gdxVersion:natives-desktop"
    }
}

project(":android") {
    apply plugin: "android"

    configurations { natives }

    dependencies {
        compile project(":core")
        compile "com.badlogicgames.gdx:gdx-backend-android:$gdxVersion"
        natives "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-armeabi"
        natives "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-armeabi-v7a"
        natives "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-x86"
        compile "com.badlogicgames.gdx:gdx-box2d:$gdxVersion"
        natives "com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-armeabi"
        natives "com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-armeabi-v7a"
        natives "com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-x86"
        compile "com.badlogicgames.box2dlights:box2dlights:$box2DLightsVersion"
        compile "com.badlogicgames.ashley:ashley:$ashleyVersion"
        compile "com.badlogicgames.gdx:gdx-freetype:$gdxVersion"
        natives "com.badlogicgames.gdx:gdx-freetype-platform:$gdxVersion:natives-armeabi"
        natives "com.badlogicgames.gdx:gdx-freetype-platform:$gdxVersion:natives-armeabi-v7a"
        natives "com.badlogicgames.gdx:gdx-freetype-platform:$gdxVersion:natives-x86"
        compile "com.badlogicgames.gdx:gdx-ai:$aiVersion"
        compile "com.badlogicgames.gdx:gdx-controllers:$gdxVersion"
        compile "com.badlogicgames.gdx:gdx-controllers-android:$gdxVersion"
    }
}

project(":ios") {
    apply plugin: "java"
    apply plugin: "robovm"

    configurations { natives }

    dependencies {
        compile project(":core")
        compile "org.robovm:robovm-rt:${roboVMVersion}"
        compile "org.robovm:robovm-cocoatouch:${roboVMVersion}"
        compile "com.badlogicgames.gdx:gdx-backend-robovm:$gdxVersion"
        natives "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-ios"
        natives "com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-ios"
        natives "com.badlogicgames.gdx:gdx-freetype-platform:$gdxVersion:natives-ios"
    }
}

project(":core") {
    apply plugin: "java"


    dependencies {
        compile "com.badlogicgames.gdx:gdx:$gdxVersion"
        compile "com.badlogicgames.gdx:gdx-box2d:$gdxVersion"
        compile "com.badlogicgames.box2dlights:box2dlights:$box2DLightsVersion"
        compile "com.badlogicgames.ashley:ashley:$ashleyVersion"
        compile "com.badlogicgames.gdx:gdx-freetype:$gdxVersion"
        compile "com.badlogicgames.gdx:gdx-ai:$aiVersion"
        compile "com.badlogicgames.gdx:gdx-controllers:$gdxVersion"
    }
}

tasks.eclipse.doLast {
    delete ".project"
}
```

`core/build.gradle`:

```gradle
apply plugin: "java"

sourceCompatibility = 1.6
[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'

sourceSets.main.java.srcDirs = ["src/"]


eclipse.project {
    name = appName + "-core"
}

```

`core/src/com/jxz/notcontra/animation/AnimationEx.java`:

```java
package com.jxz.notcontra.animation;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.XmlReader;
import com.jxz.notcontra.handlers.AssetHandler;

/**
 * Created by Kevin Xiao on 2015-06-02.
 */
public class AnimationEx extends Animation {

    private Vector2[] offset;
    private String animType;

    /**
     * IMPORTANT: Using this constructor will not attempt to load any xml files that contain offset values
     *
     * This constructor is no different than the libgdx Animation class implementation that this class extends
     * The animation type will be null, to which the animation offset will return (0, 0) unless manually set.
     */
    public AnimationEx(float frameDuration, Array<? extends TextureRegion> keyFrames) {
        super(frameDuration, keyFrames);
        animType = null;
    }

    /**
     * Calls super constructor to set up animations (stores frame duration and key frames), and then sets up
     * offset values for each different frame by parsing an XML file
     *
     * @param frameDuration the time between frames in seconds.
     * @param animType the String value for the set of animation frames
     *                 must be identical in the .xml file as well as in the TextureAtlas .pack file
     * @param texAtlasName the key name of the TextureAtlas to be loaded by the AssetManager
     *                     must be the exact same name as the TextureAtlas .pack and offset .xml files
     */
    public AnimationEx(float frameDuration, String animType, String texAtlasName) {
        super(frameDuration, ((TextureAtlas) AssetHandler.getInstance().getByName(texAtlasName)).findRegions(animType));
        this.animType = animType;
        this.offset = new Vector2[super.getKeyFrames().length];
        parseOffsetFile(AssetHandler.getInstance().getFilePath(texAtlasName) + ".xml");
    }

    public void parseOffsetFile(String fileDir) {
        try {
            XmlReader.Element root = new XmlReader().parse(Gdx.files.internal(fileDir));
            Array<XmlReader.Element> animTypeElements = root.getChildrenByName(animType);
            for (int i = 0; i < animTypeElements.size; i++) {
                offset[i] = new Vector2(animTypeElements.get(i).getFloat("x"), animTypeElements.get(i).getFloat("y"));
            }
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("Error! XML info not found for offsets");
            animType = null;
        }
    }

    public Vector2 getAnimOffset(float animStateTime) {
        if (animType == null) {
            return new Vector2(0, 0);
        }
        return offset[getKeyFrameIndex(animStateTime)];
    }

}

```

`core/src/com/jxz/notcontra/animation/SpriteEx.java`:

```java
package com.jxz.notcontra.animation;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;

/**
 * Created by Kevin Xiao on 2015-06-02.
 */
public class SpriteEx extends Sprite {

    private Vector2 offset = new Vector2(0, 0);

    public SpriteEx(TextureRegion region) {
        super(region);
    }

    public SpriteEx(Sprite sprite) {
        super(sprite);
    }

    public Vector2 getOffset() {
        return offset;
    }

    public void setOffset(float x, float y) {
        offset.set(x, y);
    }

    public void setRegion(TextureRegion region, Vector2 offset) {
        super.setRegion(region);
        this.offset = offset;
    }

}

```

`core/src/com/jxz/notcontra/buff/Buff.java`:

```java
package com.jxz.notcontra.buff;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.utils.Pool;
import com.badlogic.gdx.utils.Pools;
import com.jxz.notcontra.entity.LivingEntity;

/**
 * Created by Samuel on 03/06/2015.
 * Basic buff class.
 */
public abstract class Buff implements Pool.Poolable {
    // Field
    protected String name;
    protected float duration;
    protected LivingEntity afflicted;
    protected boolean disable; // Whether or not the buff is a disabling buff. Does not affect bosses or players.

    public Buff(String name) {
        this.name = name;
    }

    public void update() {
        // All buffs tick down. Further functionality can be overridden. Children should call super.update(); whenever.
        duration -= Gdx.graphics.getDeltaTime();

        // Remove inactive buffs
        if (duration <= 0) {
            expire();
        }
    }

    // Method is called on first cast of buff. Used to set values. Children should call super.cast(afflicted) at the BEGINNING of the method.
    public void cast(LivingEntity afflicted) {
        this.afflicted = afflicted;
        afflicted.getBuffList().addBuff(this);
    }

    // Method is called when duration is 0. Used to remove buffed values. Children should call super.expire(); at the END of the method.
    public void expire() {
        afflicted.getBuffList().removeBuff(this);
        Pools.free(this);
    }

    @Override
    public void reset() {
        afflicted = null;
        duration = 0;
    }

    public String getName() {
        return this.name;
    }

    public float getDuration() {
        return this.duration;
    }

    public void setDuration(float duration) {
        this.duration = duration;
    }

    public boolean isDisable() {
        return disable;
    }
}

```

`core/src/com/jxz/notcontra/buff/CastingBuff.java`:

```java
package com.jxz.notcontra.buff;

import com.badlogic.gdx.Gdx;
import com.jxz.notcontra.skill.Skill;

/**
 * Created by Samuel on 03/06/2015.
 * Allows continuous casting of skill, given a buff.
 */
public class CastingBuff extends Buff {
    protected Skill skill;
    protected float interval;
    protected float timeSinceLast;

    public CastingBuff() {
        super("CastingBuff");
        timeSinceLast = 0;
    }

    @Override
    public void update() {
        timeSinceLast += Gdx.graphics.getDeltaTime();

        if (timeSinceLast > interval) {
            skill.preCast(afflicted);
            timeSinceLast = 0;
        }
        super.update();
    }

    @Override
    public void expire() {
        timeSinceLast = 0;
        super.expire();
    }

    public void setInterval(float interval) {
        this.interval = interval;
    }

    public void setSkill(Skill skill) {
        this.skill = skill;
    }
}

```

`core/src/com/jxz/notcontra/buff/ForceBuff.java`:

```java
package com.jxz.notcontra.buff;

import com.badlogic.gdx.math.Vector2;
import com.jxz.notcontra.entity.LivingEntity;
import com.jxz.notcontra.entity.Player;

/**
 * Created by Samuel on 03/06/2015.
 * Forces movement state in a certain direction, as well as changing speed
 */
public class ForceBuff extends Buff {
    // Fields
    protected Vector2 direction;
    protected float additionalSpeed;

    public ForceBuff() {
        super("ForceBuff");
    }

    @Override
    public void update() {
        afflicted.getMovementState().set(direction);
        afflicted.setIsRooted(true);
        super.update();
    }

    @Override
    public void cast(LivingEntity afflicted) {
        super.cast(afflicted);
        afflicted.getMovementState().set(direction);
        afflicted.setAdditionalSpeed(afflicted.isGrounded() ? additionalSpeed : additionalSpeed * 0.8f);
    }

    @Override
    public void expire() {
        afflicted.setIsRooted(false);
        if (afflicted instanceof Player) {
            ((Player) afflicted).updateMovementState();
        }
        afflicted.setAdditionalSpeed(0);
        super.expire();
    }

    public void setDirection(Vector2 direction) {
        this.direction = direction;
    }

    public void setAdditionalSpeed(float additionalSpeed) {
        this.additionalSpeed = additionalSpeed;
    }
}

```

`core/src/com/jxz/notcontra/buff/FrozenBuff.java`:

```java
package com.jxz.notcontra.buff;

import com.jxz.notcontra.entity.LivingEntity;
import com.jxz.notcontra.entity.Player;

/**
 * Created by Samuel on 03/06/2015.
 * Frozen buffs. Afflicted cannot move or be animated.
 */
public class FrozenBuff extends Buff{
    public FrozenBuff() {
        super("FrozenBuff");
        disable = true;
    }

    @Override
    public void cast(LivingEntity afflicted) {
        super.cast(afflicted);
        afflicted.getMovementState().setZero();
    }

    @Override
    public void update() {
        afflicted.setIsRooted(true);
        afflicted.setAnimationPaused(true);
        super.update();
    }

    @Override
    public void expire() {
        afflicted.setIsRooted(false);
        if (afflicted instanceof Player) {
            ((Player) afflicted).updateMovementState();
        }
        afflicted.setAnimationPaused(false);
        super.expire();
    }
}

```

`core/src/com/jxz/notcontra/camera/PlayerCamera.java`:

```java
package com.jxz.notcontra.camera;

import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Matrix4;
import com.badlogic.gdx.math.Vector3;
import com.jxz.notcontra.entity.Player;
import com.jxz.notcontra.game.Game;

/**
 * Created by Samuel on 17/04/2015.
 * Camera will follow player
 */
public class PlayerCamera extends OrthographicCamera {

    // Parallax fields
    Matrix4 parallaxView = new Matrix4();
    Matrix4 parallaxCombined = new Matrix4();
    Vector3 tmp = new Vector3();
    Vector3 tmp2 = new Vector3();

    public PlayerCamera(float viewportWidth, float viewportHeight) {
        super(viewportWidth, viewportHeight);
    }

    public Matrix4 calculateParallaxMatrix (float parallaxX, float parallaxY) {
        update();
        tmp.set(position);
        tmp.x *= parallaxX;
        tmp.y *= parallaxY;

        parallaxView.setToLookAt(tmp, tmp2.set(tmp).add(direction), up);
        parallaxCombined.set(projection);
        Matrix4.mul(parallaxCombined.val, parallaxView.val);
        return parallaxCombined;
    }

    // Player Camera Fields
    private Player player;
    private boolean isTracking = false;

    public void setPlayer(Player player) {
        this.player = player;
    }

    public void track() {
        // X-position
        position.x = (player.getPosition().x + Math.round(player.getAABB().getWidth() / 2)) * Game.UNIT_SCALE;

        // Y-position
        float deltaY = position.y - player.getTilePosition().y + player.getAABB().getHeight() * Game.UNIT_SCALE;
        if (!isTracking) {
            // Enables tracking when player is more than 1/6 screen height away
            if (Math.abs(deltaY) > Game.VIEW_HEIGHT / 6) {
                isTracking = true;
            }
        } else {
            // Moves camera closer to the player until within 0.01 tiles
            if (Math.abs(deltaY) > 0.01 && position.y >= Game.VIEW_HEIGHT / 2f && position.y <= player.getCurrentLevel().getHeight() - Game.VIEW_HEIGHT / 2f) {
                position.y += (deltaY > 0 ? -1 : 1) * Math.pow(deltaY, 2) * Game.UNIT_SCALE * Game.getFpsTimer();
            } else {
                isTracking = false;
            }
        }

        // Clamp positions to map boundaries
        position.x = MathUtils.clamp(position.x, Game.VIEW_WIDTH / 2f, player.getCurrentLevel().getWidth() - Game.VIEW_WIDTH / 2f);
        position.y = MathUtils.clamp(position.y, Game.VIEW_HEIGHT / 2f, player.getCurrentLevel().getHeight() - Game.VIEW_HEIGHT / 2f);
    }



}

```

`core/src/com/jxz/notcontra/effect/Effect.java`:

```java
package com.jxz.notcontra.effect;

import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Pool;
import com.jxz.notcontra.entity.ChildObject;
import com.jxz.notcontra.entity.Entity;

/**
 * Created by Samuel on 09/05/2015.
 * Abstract effect class.
 */
public abstract class Effect implements Pool.Poolable, ChildObject {
    protected Entity parent;
    protected Vector2 position;
    protected Vector2 offset;
    protected Vector2 direction;
    protected float stateTime;
    protected boolean isFlipped;

    public Effect() {
        position = new Vector2();
        offset = new Vector2();
        direction = new Vector2();
    }

    public abstract void draw(Batch batch);

    public abstract void update();

    public void init() {
        stateTime = 0;
    }

    public void reset() {
        stateTime = 0;
    }

    public void setOffset(float x, float y) {
        offset.set(x, y);
    }

    public void setPosition(float x, float y) {
        position.set(x, y);
    }

    public void setDirection(Vector2 direction) {
        this.direction = direction.nor();
        isFlipped = (direction.x < 0);
    }

    public void setParent(Entity parent) {
        this.parent = parent;
    }

    public Entity getParent() {
        return parent;
    }

    public abstract boolean isActive();
}

```

`core/src/com/jxz/notcontra/effect/SpriteEffect.java`:

```java
package com.jxz.notcontra.effect;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Pools;
import com.jxz.notcontra.game.Game;

/**
 * Created by Samuel on 09/05/2015.
 * Effects rendered via animated sprites.
 */
public class SpriteEffect extends Effect {
    // Sprite-based animation
    protected Sprite sprite;
    protected Animation animation;

    public SpriteEffect() {
        super();
    }

    @Override
    public void draw(Batch batch) {
        // Draw with rotational support
        batch.draw(sprite.getTexture(),
                this.position.x * Game.UNIT_SCALE,
                this.position.y * Game.UNIT_SCALE,
                sprite.getWidth() / 2 * Game.UNIT_SCALE,
                sprite.getHeight() / 2 * Game.UNIT_SCALE,
                this.sprite.getWidth() * Game.UNIT_SCALE,
                this.sprite.getHeight() * Game.UNIT_SCALE,
                1.0f,
                1.0f,
                direction.angle(),
                sprite.getRegionX(),
                sprite.getRegionY(),
                sprite.getRegionWidth(),
                sprite.getRegionHeight(),
                false, false
        );
    }

    @Override
    public void update() {
        //isFlipped = !parent.isFlipped();
        setCenterPosition(parent.getCenterPosition());
        position.add(direction.cpy().scl(parent.getSprite().getWidth()));
        animate();
    }

    @Override
    public void init() {
        super.init();
    }

    @Override
    public void reset() {
        super.reset();
    }

    public void animate() {
        stateTime += Gdx.graphics.getDeltaTime();
        sprite.setRegion(animation.getKeyFrame(stateTime, false));
        if (animation.isAnimationFinished(stateTime)) {
            parent.removeChild(this);
            Pools.free(this);
        }
    }

    public void setSprite(Sprite sprite) {
        this.sprite = sprite;
    }

    public Sprite getSprite() {
        return sprite;
    }

    public Animation getAnimation() {
        return animation;
    }

    public void setAnimation(Animation animation) {
        this.animation = animation;
    }

    public void setCenterPosition(Vector2 position) {
        this.position.set(position.x - sprite.getRegionWidth() / 2, position.y - sprite.getRegionHeight() / 2);
    }

    public boolean isActive() {
        return !animation.isAnimationFinished(stateTime);
    }
}

```

`core/src/com/jxz/notcontra/entity/Alien.java`:

```java
package com.jxz.notcontra.entity;

import com.badlogic.gdx.math.MathUtils;
import com.jxz.notcontra.animation.AnimationEx;
import com.jxz.notcontra.animation.SpriteEx;
import com.jxz.notcontra.handlers.AudioHelper;

/**
 * Created by Samuel on 01/06/2015.
 * First ranged AI monster.
 */
public class Alien extends RangedMonster {

    // Animation frame name values
    private final String TEXTURE_ATLAS_NAME = "alien";
    private final String ANIM_WALK = "move";
    private final String ANIM_IDLE = "stand";
    private final String ANIM_JUMP = "jump";
    private final String ANIM_HURT = "hit1";
    private final String ANIM_ATTACK = "attack1";
    private final String ANIM_DEATH = "die1";

    public Alien() {
        super("alien", 1);
        // Set up score
        deathScore = 10;
        // Set up animations
        animIdle = new AnimationEx(1 / 6f, ANIM_IDLE, TEXTURE_ATLAS_NAME);
        animWalk = new AnimationEx(1 / 6f, ANIM_WALK, TEXTURE_ATLAS_NAME);
        animHurt = new AnimationEx(1 / 6f, ANIM_HURT, TEXTURE_ATLAS_NAME);
        animJump = new AnimationEx(1 / 6f, ANIM_JUMP, TEXTURE_ATLAS_NAME);
        animDeath = new AnimationEx(1 / 10f, ANIM_DEATH, TEXTURE_ATLAS_NAME);
        animCast = new AnimationEx[1];
        animCast[0] = new AnimationEx(1 / 10f, ANIM_ATTACK, TEXTURE_ATLAS_NAME);

        hitboxOffset.set(-aabb.getWidth() / 2f, 0);
        renderOffset = 0;

        // Initialize sprite stuff
        this.sprite = new SpriteEx(animIdle.getKeyFrame(animStateTime, true));

        // Knock back values
        kbDuration = 0.4f;
        kbDistance = 25f;
        kbThreshold = 15;

        // Combat stats
        baseDamage = 10;
        baseHealth = 75;
        speed = 2 + MathUtils.random(-0.5f, 0.5f);
        damageMultiplier = 1;
        aimRadius = 95;
        attackRange = 500;

        // Jump parameters
        maxJumps = 1;
        jumpCounter = 0;
        jumpState = 0;
        jumpMultiplier = 1.2f;
        jumpTime = 3f;

        // Speed parameters
        patrolSpeed = 2.0f;
        chaseSpeed = 3.0f;

        // Sound
        dieSnd = "alien_die";
        hitSnd = "alien_hit";

        // Magic skills and stuff
        skills.setInventory(0, "iceball");
    }

}

```

`core/src/com/jxz/notcontra/entity/AnimatedEntity.java`:

```java
package com.jxz.notcontra.entity;

import com.jxz.notcontra.handlers.AssetHandler;

/**
 * Created by Samuel on 25/04/2015.
 * Animated entity class.
 */
public abstract class AnimatedEntity extends Entity {
    protected float animStateTime;
    protected boolean animationPaused = false;
    protected AssetHandler assetHandler = AssetHandler.getInstance();

    public AnimatedEntity(String name) {
        super(name);
    }

    public abstract void animate();

    public boolean isAnimationPaused() {
        return animationPaused;
    }

    public void setAnimationPaused(boolean animationPaused) {
        this.animationPaused = animationPaused;
    }
}

```

`core/src/com/jxz/notcontra/entity/AttachedHitbox.java`:

```java
package com.jxz.notcontra.entity;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.math.Vector2;
import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.skill.Skill;

import java.util.ArrayList;

/**
 * Created by Samuel on 25/04/2015.
 * Attached hitboxes update their position relative to the caster. Used for melee.
 */
public class AttachedHitbox extends DynamicHitbox {

    public AttachedHitbox() {
        super("AttachedHitbox");
    }

    @Override
    public void update() {
        if (time > 0) {
            // Update visual with regards to caster
            isFlipped = !caster.isFlipped();
            setCenterPosition(caster.getCenterPosition().cpy());
            aabb.setPosition(position.x, position.y);
            position.add(hitboxOffset.x, hitboxOffset.y);
            animate();

            // Update lifespan
            time -= Gdx.graphics.getDeltaTime();

            // Check collisions
            if (isCollidable) {
                ArrayList<Entity> target = collisionCheck();
                if (!target.isEmpty()) {
                    parent.hit(target);
                }
            }
        } else {
            // Free hitbox is time runs out
            EntityFactory.free(this);
        }
    }

    // Only attached hitboxes need to worry about being flipped
    public void init(Skill parent, LivingEntity caster, boolean needsFlipping) {
        super.init(parent, caster, 0, 0);
        if (needsFlipping) {
            isFlipped = !caster.isFlipped();
        }
    }

    @Override
    public void reset() {
        isActive = false;
        isVisible = false;
        sprite.setRegion(animTravel.getKeyFrame(0));
        hitEntities.clear();
    }

    @Override
    public void draw(Batch batch) {
        // Draw with rotational support
        batch.draw(sprite.getTexture(),
                this.position.x * Game.UNIT_SCALE,
                this.position.y * Game.UNIT_SCALE,
                sprite.getWidth() / 2 * Game.UNIT_SCALE,
                sprite.getHeight() / 2 * Game.UNIT_SCALE,
                this.sprite.getWidth() * Game.UNIT_SCALE,
                this.sprite.getHeight() * Game.UNIT_SCALE,
                1.0f,
                1.0f,
                0,
                sprite.getRegionX(),
                sprite.getRegionY(),
                sprite.getRegionWidth(),
                sprite.getRegionHeight(),
                isFlipped, false
        );

        if (Game.getDebugMode()) {
            batch.draw(debug.getTexture(),
                    this.position.x * Game.UNIT_SCALE,
                    this.position.y * Game.UNIT_SCALE,
                    aabb.getWidth() / 2 * Game.UNIT_SCALE,
                    aabb.getHeight() / 2 * Game.UNIT_SCALE,
                    this.aabb.getWidth() * Game.UNIT_SCALE,
                    this.aabb.getHeight() * Game.UNIT_SCALE,
                    1.0f,
                    1.0f,
                    0,
                    sprite.getRegionX(),
                    sprite.getRegionY(),
                    sprite.getRegionWidth(),
                    sprite.getRegionHeight(),
                    isFlipped, false
            );
        }
    }
}

```

`core/src/com/jxz/notcontra/entity/BossMonster.java`:

```java
package com.jxz.notcontra.entity;

import com.badlogic.gdx.graphics.OrthographicCamera;
import com.jxz.notcontra.handlers.GameStateManager;

/**
 * Created by Samuel on 03/06/2015.
 * Boss monster class. Most implementation will be done in subclass, as bosses are unique.
 */
public abstract class BossMonster extends RangedMonster {

    // Each boss has access to the hudcam for drawing their healthbar
    protected static OrthographicCamera hudCam;

    public BossMonster(String name, int skillCapacity) {
        super(name, skillCapacity);

        // Set HUD cam for drawing health bar
        if (hudCam == null) {
            hudCam = GameStateManager.getInstance().getGame().getHudCam();
        }
    }
}

```

`core/src/com/jxz/notcontra/entity/ChildObject.java`:

```java
package com.jxz.notcontra.entity;

import com.badlogic.gdx.graphics.g2d.Batch;

/**
 * Created by Samuel on 09/05/2015.
 * Defines objects that are updated via another Entity.
 */
public interface ChildObject {
    public void draw(Batch batch);
    public void update();
    public Entity getParent();
    public void setParent(Entity parent);
    public boolean isActive();
}

```

`core/src/com/jxz/notcontra/entity/DynamicHitbox.java`:

```java
package com.jxz.notcontra.entity;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.math.Intersector;
import com.badlogic.gdx.utils.Pool;
import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.handlers.EntityManager;
import com.jxz.notcontra.handlers.SkillManager;
import com.jxz.notcontra.skill.ExplosionSkill;
import com.jxz.notcontra.skill.Skill;

import java.util.ArrayList;

/**
 * Created by Samuel on 25/04/2015.
 * Dynamic hitboxes for use with skill collision checks.
 */
public abstract class DynamicHitbox extends AnimatedEntity implements Pool.Poolable {
    // Hitbox Fields
    protected float time;   // Limited by time
    protected Animation animTravel; // Animation to use while moving
    protected Skill parent; // Source of skill
    protected LivingEntity caster;  // Caster of source
    protected ArrayList<Entity> hitEntities;    // Keeps track of entities hit
    protected boolean isCollidable; // If collisions should be handled
    protected boolean targetLimited;    // Whether or not the hitbox should be disabled after targets are hit
    protected float explosionRadius;    // If it is greater than 0, explosion of radius explosionRadius will occur on hit
    public DynamicHitbox() {
        super("dynHitbox");
    }

    public DynamicHitbox(String name){
        super(name);
        hitEntities = new ArrayList<Entity>();
        isCollidable = true;
    }

    // Initialization upon retrieving from pool
    public void init(Skill parent, LivingEntity caster, float x, float y) {
        isActive = true;
        isVisible = true;
        currentLevel = caster.getCurrentLevel();
        animStateTime = 0;
        position.x = x + hitboxOffset.x;
        position.y = y + hitboxOffset.y;
        setPosition(position);
        aabb.setPosition(position);
        aabb.setWidth(sprite.getWidth() * sprite.getScaleX());
        aabb.setHeight(sprite.getHeight() * sprite.getScaleY());
        this.parent = parent;
        this.caster = caster;
    }

    // Returns a list of non-self targets that intersect with the projectile
    public ArrayList<Entity> collisionCheck() {
        ArrayList<Entity> targets = new ArrayList<Entity>();
        for (Entity e : EntityManager.getInstance().getEntitiesListIteration()) {
            if (!(e.equals(caster)) && e.isActive() && !e.equals(this) && e.getCurrentLevel().equals(caster.getCurrentLevel())) {
                if (!hitEntities.contains(e)) {
                    if (Intersector.overlaps(e.getAABB(), aabb)) {
                        targets.add(e);
                        hitEntities.add(e);
                        if (Game.getDebugMode()) System.out.println(e.getName() + e.getId() + " was hit");
                    }
                }
            }
        }
        return targets;
    }

    // Resets the state of the projectile to put it back in the pool
    public void reset() {
        isActive = false;
        isVisible = false;
        sprite.setRegion(animTravel.getKeyFrame(0));
        hitEntities.clear();

        if (explosionRadius > 0) {
            ExplosionSkill explosion = (ExplosionSkill) SkillManager.getSkill("Explosion");
            explosion.setRadius(explosionRadius);
            explosion.use(caster, getPosition());
        }
        explosionRadius = 0;
    }

    @Override
    public void animate() {
        animStateTime += Gdx.graphics.getDeltaTime();
        sprite.setRegion(animTravel.getKeyFrame(animStateTime, false));
    }

    public void setAnimTravel(Animation animTravel) {
        this.animTravel = animTravel;
    }

    public void setTime(float time) {
        this.time = time;
    }

    public void setSize(float width, float height) {
        aabb.setSize(width, height);
    }

    public void setHitboxOffset(float x, float y) {
        hitboxOffset.set(x, y);
    }

    public void setExplosionRadius(float radius) {
        this.explosionRadius = radius;
    }
}

```

`core/src/com/jxz/notcontra/entity/Entity.java`:

```java
package com.jxz.notcontra.entity;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Array;
import com.jxz.notcontra.animation.SpriteEx;
import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.handlers.AssetHandler;
import com.jxz.notcontra.handlers.EntityManager;
import com.jxz.notcontra.world.Level;

/**
 * Created by Samuel on 2015-03-27.
 * Entity abstract class
 */
public abstract class Entity {
    // Base Entity fields
    protected int id = 0;
    protected String name;
    protected SpriteEx sprite;
    protected Vector2 position;
    protected boolean isVisible;
    protected boolean isActive;
    protected boolean isFlipped;
    protected Level currentLevel;
    protected EntityManager manager = EntityManager.getInstance();
    protected Rectangle aabb;
    protected Vector2 hitboxOffset;
    protected int renderOffset;
    protected Sprite debug;

    // Child object list -> Effects, health bars, etc.
    protected Array<ChildObject> childObjects;

    // Constructor - all entities must be registered through manager
    public Entity(String entityName) {
        name = entityName;
        id = EntityManager.id;
        manager.register(this);
        position = new Vector2(0, 0);
        hitboxOffset = new Vector2(0, 0);
        aabb = new Rectangle(0, 0, 0, 0);
        isActive = true;
        isVisible = true;
        isFlipped = false;
        childObjects = new Array<ChildObject>();
        debug = new Sprite((Texture) AssetHandler.getInstance().getByName("hitbox"));
        renderOffset = 0;
    }

    public Entity(String entityName, float x, float y) {
        this(entityName);
        this.position = new Vector2(x, y);
    }

    public Entity(String entityName, Vector2 position) {
        this(entityName);
        this.position = position;
    }

    public boolean isFlipped() {
        return isFlipped;
    }

    public void setIsFlipped(boolean isFlipped) {
        this.isFlipped = isFlipped;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name + id;
    }

    public Sprite getSprite() {
        return sprite;
    }

    public void setSprite(SpriteEx sprite) {
        this.sprite = sprite;
    }

    public void update() {
        updateChildren();
    };

    public boolean isVisible() {
        return isVisible;
    }

    public void setVisible(boolean isVisible) {
        this.isVisible = isVisible;
    }

    public Vector2 getPosition() {
        return position;
    }

    public Level getCurrentLevel() {
        return currentLevel;
    }

    public void setCurrentLevel(Level currentMap) {
        this.currentLevel = currentMap;
    }

    public Rectangle getAABB() {
        return aabb;
    }

    public Vector2 getTilePosition() {
        return new Vector2(position.x * Game.UNIT_SCALE, position.y * Game.UNIT_SCALE);
    }

    public Vector2 getCenterPosition() {
        return position.cpy().add(aabb.getWidth() / 2, aabb.getHeight() / 2);
    }

    public void setCenterPosition(Vector2 position) {
        setCenterPosition(position.x, position.y);
    }

    public void setCenterPosition(float x, float y) {
        this.position.set(x - aabb.getWidth() / 2, y - aabb.getHeight() / 2);
    }

    public void setPosition(Vector2 position) {
        this.position = position;
    }

    public void setPosition(float x, float y) {
        this.position.set(x, y);
    }

    public boolean isActive() {
        return isActive;
    }

    public void addChild(ChildObject o) {
        childObjects.add(o);
    }

    public void updateChildren() {
        if (childObjects.size > 0) {
            for (ChildObject co : childObjects) {
                co.update();
            }
        }
    }

    public void removeChild(ChildObject co) {
        childObjects.removeValue(co, true);
    }

    public void draw(Batch batch) {
        batch.draw(sprite,
                isFlipped ? (sprite.getX() - sprite.getOffset().x + renderOffset) * Game.UNIT_SCALE :(sprite.getX() + sprite.getOffset().x + renderOffset) * Game.UNIT_SCALE,
                (sprite.getY() - sprite.getHeight() - sprite.getOffset().y) * Game.UNIT_SCALE,
                isFlipped ? -sprite.getWidth() * Game.UNIT_SCALE : sprite.getWidth() * Game.UNIT_SCALE,
                sprite.getHeight() * Game.UNIT_SCALE);
        if (Game.getDebugMode()) {
            batch.draw(debug, position.x * Game.UNIT_SCALE, position.y * Game.UNIT_SCALE, aabb.getWidth() * Game.UNIT_SCALE, aabb.getHeight() * Game.UNIT_SCALE);
        }
    }
}

```

`core/src/com/jxz/notcontra/entity/EntityFactory.java`:

```java
package com.jxz.notcontra.entity;

import com.badlogic.gdx.utils.Pools;

/**
 * Created by Samuel on 23/04/2015.
 * Static instance to manage pools of entities.
 */
public class EntityFactory {

    // Spawn method
    public static Entity spawn(Class type) {
        return (Entity) Pools.obtain(type);

    }

    // Overloaded spawn method - contains coordinates
    public static Entity spawn(Class type, float x, float y) {
        Entity e = spawn(type);
        e.setPosition(x, y);
        return e;
    }

    // Frees the object from the pool
    public static void free(Object o) {
        Pools.free(o);
    }

    // Static method called to assign pools to pool map
    public static void init() {
      //  entityPool.set(Slime.class, slimePool);
       // entityPool.set(Projectile.class, projectilePool);
    }

}

```

`core/src/com/jxz/notcontra/entity/GruntMonster.java`:

```java
package com.jxz.notcontra.entity;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.maps.tiled.TiledMapTile;
import com.badlogic.gdx.math.MathUtils;
import com.jxz.notcontra.world.Level;

/**
 * Created by Samuel on 31/05/2015.
 * Basic AI. Updates every update interval. No skills.
 */
public abstract class GruntMonster extends Monster {

    public GruntMonster(String name) {
        super(name);
    }

    @Override
    public void cast(int skill) {
        isCasting = true;
    }

    @Override
    public void preCollisionAiUpdate() {
        switch (state) {
            // Pre-movement checks
            case SPAWNING:
                if (aiStateTime <= 0) {
                    if (target != null) {
                        state = AIState.CHASING;
                    } else {
                        state = AIState.PATROLLING;
                    }
                }
            case IDLE:
                // Idle. Don't move.
                movementState.set(0, 0);
                break;
            case CHASING:
                // Approach target if not rooted
                speed = chaseSpeed;
                if (!isRooted) {
                    // Only recalculate at update intervals
                    if (lastUpdateTime > UPDATE_INTERVAL) {
                        distToTarget = target.getCenterPosition().cpy().sub(this.getCenterPosition());
                        if (Math.abs(distToTarget.x) > aabb.getWidth() / 4) {
                            movementState.set(distToTarget.x, 0).nor();
                        } else {
                            movementState.set(0, 0);
                        }
                        lastUpdateTime = 0;
                    }
                    // If you're going to run yourself off a platform, at least jump.
                    if (isOnPlatform) {
                        float boundingEdgeDelta = (movementState.x > 0 ? 1 : -1) * aabb.getWidth() / 2;
                        TiledMapTile targetTile = currentLevel.getTileAt(position.x + aabb.getWidth() / 2 + boundingEdgeDelta + (movementState.x * (speed + additionalSpeed)), position.y - 1, Level.DYNAMIC_LAYER);
                        if (targetTile == null) {
                            jump();
                        }
                    }
                }
                break;
            case PATROLLING:
                // Reduce speed when patrolling
                speed = patrolSpeed;
                if (aiStateTime <= 0) {
                    if (movementState.isZero()) {
                        // New patrol route
                        movementState.set(MathUtils.randomSign(), 0);
                        aiStateTime = MathUtils.random(2.0f, 4.0f);
                    } else {
                        // Pause between patrol points
                        movementState.set(0, 0);
                        aiStateTime = MathUtils.random(0.5f, 2.5f);
                    }
                } else {
                    // Turn around if the slime is going to run off the platform
                    if (isOnPlatform) {
                        float boundingEdgeDelta = (movementState.x > 0 ? 1 : -1) * aabb.getWidth() / 2;
                        TiledMapTile targetTile = currentLevel.getTileAt(position.x + aabb.getWidth() / 2 + boundingEdgeDelta + (movementState.x * (speed + additionalSpeed)), position.y - 1, Level.DYNAMIC_LAYER);
                        if (targetTile == null) {
                            movementState.set(-movementState.x, 0);
                        }
                    }
                }
                break;
        }
    }

    // Grunt monsters have no special animations, so no cast statements are needed
    public void animate() {
        // Update animation time
        if (!isAnimationPaused()) {
            animStateTime += Gdx.graphics.getDeltaTime();
        }

        // Hurt > Death > Movement/Idle
        if (forceDuration > 0) {
            if (currentAnimation != animHurt) {
                animStateTime = 0;
            }
            forceDuration -= Gdx.graphics.getDeltaTime();
            sprite.setRegion(animHurt.getKeyFrame(animStateTime, true), animHurt.getAnimOffset(animStateTime));
            currentAnimation = animHurt;
        } else if (state == AIState.DYING) {
            if (currentAnimation != animDeath) {
                animStateTime = 0;
            }
            sprite.setRegion(animDeath.getKeyFrame(animStateTime, true), animDeath.getAnimOffset(animStateTime));
            currentAnimation = animDeath;
            if (animStateTime > animDeath.getAnimationDuration()) {
                die();
            }
        } else if (movementState.isZero()) {
            if (currentAnimation != animIdle) {
                animStateTime = 0;
            }
            sprite.setRegion(animIdle.getKeyFrame(animStateTime, true), animIdle.getAnimOffset(animStateTime));
            currentAnimation = animIdle;
        } else {
            if (currentAnimation != animWalk) {
                animStateTime = 0;
            }
            sprite.setRegion(animWalk.getKeyFrame(animStateTime, true), animWalk.getAnimOffset(animStateTime));
            currentAnimation = animWalk;
        }

        if (movementState.x < 0) {
            isFlipped = true;
        } else if (movementState.x > 0) {
            isFlipped = false;
        }

        this.sprite.setSize(this.sprite.getRegionWidth(), this.sprite.getRegionHeight());
    }
}

```

`core/src/com/jxz/notcontra/entity/LivingEntity.java`:

```java
package com.jxz.notcontra.entity;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.maps.tiled.TiledMapTile;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Pools;
import com.jxz.notcontra.animation.AnimationEx;
import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.handlers.AudioHelper;
import com.jxz.notcontra.handlers.BuffInventory;
import com.jxz.notcontra.handlers.SkillInventory;
import com.jxz.notcontra.skill.Skill;
import com.jxz.notcontra.world.Level;

/**
 * Created by Samuel on 2015-03-27.
 */
public abstract class LivingEntity extends AnimatedEntity {
    // Fields specific to living entities
    protected int health;
    protected int maxHealth;
    protected int baseHealth;
    protected int mana;
    protected int maxMana;
    protected float speed;
    protected float additionalSpeed;
    protected float damageMultiplier;
    protected float baseDamage;
    protected float additionalDamage;
    protected float criticalChance;

    private final float DAMAGE_RANGE_PERCENTAGE = 0.15f;

    // Sprite fields
    protected float centerX, centerY;
    protected AnimationEx animWalk;
    protected AnimationEx animIdle;
    protected AnimationEx animJump;
    protected AnimationEx animRope;
    protected AnimationEx animLadder;
    protected AnimationEx[] animCast;
    protected AnimationEx animHurt;
    protected AnimationEx animDeath;
    protected AnimationEx currentAnimation;
    protected float climbingStateTime;
    protected float castStateTime;
    protected int castType;

    // Jumping Parameters
    protected int maxJumps;
    protected int jumpCounter;
    protected float jumpState;
    protected float jumpMultiplier;
    protected float jumpTime;
    protected float currentGravity = 0f;

    // Movement Vectors
    protected Vector2 movementState;
    protected float deltaX, deltaY;
    protected Vector2 forceVector;
    protected float forceDuration;
    protected boolean rootingForce = false;

    // Living entity states
    protected boolean isSprinting = false;
    protected boolean isGrounded = false;
    protected boolean isOnPlatform = false;
    protected boolean isOnSlope = false;
    protected boolean isJumping = false;
    protected boolean canClimb = false;
    protected boolean isClimbing = false;
    protected boolean isCasting = false;
    protected boolean canCast = true;
    protected boolean isRooted = false;
    protected boolean skillCasted = false;

    // Sound fields
    protected String hitSnd;
    protected String dieSnd;
    protected String jumpSnd;

    // Skill Inventory
    SkillInventory skills;
    Skill currentSkill;

    // Buff Inventory
    BuffInventory buffs;

    // Constructor - start with no movement in either direction
    public LivingEntity(String entityName) {
        super(entityName);
        movementState = new Vector2(0, 0);
        forceVector = new Vector2(0, 0);
        forceDuration = 0;
        buffs = Pools.obtain(BuffInventory.class);

        jumpSnd = "jump";
    }

    @Override
    public void update() {
        // Update Buffs
        buffs.update();

        // Update Collision
        /** Declare local variables */
        float slopeLeft, slopeRight;
        deltaX = 0;
        deltaY = 0;

        // Previous State storage
        boolean prevGrounded = isGrounded;

        // Update pre-positional fields
        centerX = position.x + aabb.getWidth() / 2;
        centerY = position.y + aabb.getHeight() / 2;

        int height = (int) Math.ceil(aabb.getHeight() * Game.UNIT_SCALE); // Tile height, rounded up
        int width = (int) Math.ceil(aabb.getWidth() * Game.UNIT_SCALE); // Gets tile width, rounded up, of the entity
        float widthOffset, heightOffset;

        /** Step X coordinate */
        // Step X for static tile data
        if (movementState.x != 0) {
            // Add effective speed to delta X
            float effectiveSpeed = (speed + additionalSpeed) * (isSprinting ? 2 : 1) * (isOnSlope ? 0.75f : 1);
            deltaX += effectiveSpeed * movementState.x;
        }

        // Apply Force Vector
        if (forceDuration > 0) {
            deltaX += forceVector.x * forceDuration;
        }

        // Check collision bounds
        float boundingEdgeDelta = (deltaX > 0 ? 1 : -1) * aabb.getWidth() / 2;
        float dist;

        // Low FPS check - ensure collisions are checked properly if FPS < 60
        if (Game.getFpsTimer() > 1) {
            deltaX *= Game.getFpsTimer();
        }

        // X collision check
        float maxDist = Math.abs(deltaX);
        for (int i = 0; i <= height; i++) {
            if (i == width) {
                heightOffset = aabb.getHeight();
            } else {
                heightOffset = i / Game.UNIT_SCALE;
            }
            dist = currentLevel.distToObstacle(centerX + boundingEdgeDelta, position.y + heightOffset, deltaX, false);
            if (dist < maxDist) {
                maxDist = dist;
            }
        }

        deltaX = (deltaX > 0 ? 1 : -1) * maxDist;

        // Lock horizontal movement when climbing
        if (isClimbing && !isGrounded) {
            deltaX = 0;
        }

        // Update x
        position.x += (Game.getFpsTimer() > 1) ? deltaX : deltaX * Game.getFpsTimer();

        // Update Y if on slope
        if (isOnSlope) {
            slopeLeft = currentLevel.getSlopeOfTile(position.x, position.y - 1);
            slopeRight = currentLevel.getSlopeOfTile(position.x + aabb.getWidth(), position.y - 1);
            float currentSlope = (Math.abs(slopeLeft) > Math.abs(slopeRight) ? slopeLeft : slopeRight);
            if (currentLevel.getTileAt(position.x, position.y, Level.DYNAMIC_LAYER) == currentLevel.getTileAt(position.x + aabb.getWidth(), position.y, Level.DYNAMIC_LAYER)) {
                //deltaY += currentSlope;
            }
            position.y += ((Game.getFpsTimer() > 1) ? deltaX : deltaX * Game.getFpsTimer()) * currentSlope;
        }

        // Player can grab onto a ladder if the center of the player is within a ladder tile
        TiledMapTile bottomTile = currentLevel.getTileAt(centerX, position.y + aabb.getHeight(), Level.TRIGGER_LAYER);
        TiledMapTile topTile = currentLevel.getTileAt(centerX, position.y, Level.TRIGGER_LAYER);

        if (topTile != null && bottomTile != null) {
            canClimb = topTile.getProperties().containsKey("climbable") || bottomTile.getProperties().containsKey("climbable");
        } else if (bottomTile != null) {
            canClimb = bottomTile.getProperties().containsKey("climbable");
        } else if (topTile != null) {
            canClimb = topTile.getProperties().containsKey("climbable");
        } else {
            canClimb = false;
            isClimbing = false;
        }

        /** Step Y coordinate */
        if (movementState.y != 0 && canClimb) {
            // Lock X-position to center of ladder and start climbing, disabling any persisting jump velocity
            if (movementState.y < 0 && isGrounded && !isOnPlatform) {
                isClimbing = false;
            } else {
                isClimbing = true;
                position.x = (float) Math.floor(centerX * Game.UNIT_SCALE) / Game.UNIT_SCALE + (0.5f / Game.UNIT_SCALE - aabb.getWidth() / 2);
            }
            jumpState = 0;
            deltaY += (speed + additionalSpeed) * 0.8 * movementState.y;
        } else if (movementState.y < 0 && isOnPlatform) {
            // Allows stepping down from one way platforms with a downwards jump
            if (jumpState == jumpTime) {
                jumpState = 0;
                position.y -= 1;
                isOnPlatform = false;
            }
            // Downward jumps are not needed if player is above a climbable tile
            bottomTile = currentLevel.getTileAt(centerX, position.y - 1, Level.TRIGGER_LAYER);
            if (bottomTile != null) {
                System.out.println(currentLevel.getTileAt(centerX, position.y - 1, Level.TRIGGER_LAYER).getProperties().containsKey("climbable"));
                if (bottomTile.getProperties().containsKey("climbable")) {
                    position.y -= 1;
                    isOnPlatform = false;
                    isClimbing = true;
                }
            }
        }

        float currentDist, currentSlope; // local variables
        currentGravity += currentLevel.getGravity() * Gdx.graphics.getDeltaTime(); // Step gravity
        //System.out.println(currentGravity);
        maxDist = 9999; // Reset max distance
        // Iterates through all intersecting Y tiles
        for (int i = 0; i <= width; i++) {
            if (i == width) {
                widthOffset = aabb.getWidth();
            } else {
                widthOffset = i / Game.UNIT_SCALE;
            }

            // Jump if jump time is not zero
            if (jumpState > 0) {
                float jumpDist = jumpMultiplier * (float) Math.pow(jumpState, 2);
                currentDist = currentLevel.distToObstacle(position.x + widthOffset, position.y + height / Game.UNIT_SCALE, jumpDist, true);
                if (currentDist < Math.floor(jumpDist)) {
                    jumpState = 0;
                } else {
                    jumpState -= Gdx.graphics.getDeltaTime() * 2;
                }
                deltaY += currentDist;
            } else if (jumpState < 0) {
                jumpState = 0;
            }

            // Updates position due to gravity, if applicable (not climbing)
            if (!isGrounded && !isClimbing) {
                deltaY -= currentGravity;
            } else {
                // Resets jump counter if player is already grounded
                jumpCounter = 0;
                currentGravity = 0;
            }

            // Stick player to slope
            if (deltaX != 0 && isOnSlope && jumpState == 0) {
                deltaY -= Math.abs(deltaX) * currentLevel.getGravity();
            }

            // Apply Force Vector
            if (forceDuration > 0) {
                deltaY += forceVector.y * forceDuration;
            }

            // Low fps check - ensures collisions are handled properly when FPS < 60
            if (Game.getFpsTimer() > 1) {
                deltaY *= Game.getFpsTimer();
            }

            // Y-check
            // Static Collision Check:
            boundingEdgeDelta = (deltaY > 0 ? 1 : -1) * aabb.getHeight() / 2; // Defines either the top edge of the AABB or bottom edge, depending on direction
            dist = currentLevel.distToObstacle(position.x + widthOffset, centerY + boundingEdgeDelta, deltaY, true);

            // Dynamic collision check
            // Slope / One way platform check only applies if player is moving down
            if (deltaY <= 0) {
                // One way platform check
                currentDist = currentLevel.distToPlatform(position.x + widthOffset, position.y, Math.abs(deltaY));
                if (currentDist < dist) {
                    dist = currentDist;
                }
            }

            // Update max possible distance travelled
            if (dist < maxDist) {
                maxDist = dist;
            }
        }

        // Slope Check
        if (deltaY <= 0) {
            float leftDist, rightDist;
            // Slope Check - scan downwards until a slope tile is found
            leftDist = currentLevel.distToObstacle(position.x, position.y, deltaY, true, Level.DYNAMIC_LAYER, "slope");
            rightDist = currentLevel.distToObstacle(position.x + aabb.getWidth(), position.y, deltaY, true, Level.DYNAMIC_LAYER, "slope");

            // Get y-coordinate of nearest slope to the left and right sides
            slopeLeft = currentLevel.getSlopePosition(position.x, position.y - leftDist);
            slopeRight = currentLevel.getSlopePosition(position.x + aabb.getWidth(), position.y - rightDist);

            // Calculate differences
            leftDist = position.y - slopeLeft;
            rightDist = position.y - slopeRight;

            // Current slope is the closest edge
            if (leftDist > rightDist) {
                currentSlope = rightDist;
                currentDist = slopeRight;
            } else {
                currentSlope = leftDist;
                currentDist = slopeLeft;
            }

            // If player is within correcting distance under the slope, correct them onto the slope
            if (currentSlope < 0 && currentSlope > -3) {
                maxDist = 0;
                position.y = currentDist;
            } else if (currentSlope < maxDist) {
                // If not, get the maximum distance that can be travelled
                maxDist = currentSlope;
            }
        }

        // Finalize delta Y based on lowest distance
        deltaY = (deltaY > 0 ? 1 : -1) * maxDist;
        position.y += (Game.getFpsTimer() > 1) ? deltaY : deltaY * Game.getFpsTimer();

        // Fix Y so that player is on a uniform y-level when not moving
        if (aabb.getY() - position.y == 0) {
            if (position.y % (1 / Game.UNIT_SCALE) < 1 || (1 / Game.UNIT_SCALE) - (position.y % (1 / Game.UNIT_SCALE)) < 1) {
                position.y = Math.round(position.y * Game.UNIT_SCALE) / Game.UNIT_SCALE;
            }
            // Makes sure player doesn't stick to ceilings
            topTile = currentLevel.getTileAt(position.x, position.y + 1, Level.STATIC_LAYER);
            bottomTile = currentLevel.getTileAt(position.x + aabb.getWidth(), position.y + 1, Level.STATIC_LAYER);
            if (topTile != null || bottomTile != null) {
                if (forceVector.y > 0) {
                    forceVector.y = 0;
                    resetGravity();
                }
            }
        }


        /** Update boolean states **/
        // Check if player is on static ground
        isGrounded = currentLevel.distToObstacle(position.x, position.y, -1, true) == 0 || currentLevel.distToObstacle(position.x + aabb.getWidth(), position.y, -1, true) == 0;

        // Check if player is on dynamic ground (platform)
        isOnPlatform = currentLevel.distToPlatform(position.x, position.y, 1) == 0 || currentLevel.distToPlatform(position.x + aabb.getWidth(), position.y, 1) == 0;

        // If player is in a slope tile, they are also grounded if they are in the proper y-position
        if (currentLevel.getSlopeOfTile(position.x, position.y) != 0 || currentLevel.getSlopeOfTile(position.x + aabb.getWidth(), position.y) != 0) {
            slopeLeft = currentLevel.getSlopePosition(position.x, position.y);
            slopeRight = currentLevel.getSlopePosition(position.x + aabb.getWidth(), position.y);
            isOnSlope = (position.y == slopeLeft) || (position.y == slopeRight);
        } else {
            // Check edge case where player is technically not on slope tile, but is still on the slope
            if (isOnSlope) {
                slopeLeft = currentLevel.getSlopePosition(position.x, position.y - 1);
                slopeRight = currentLevel.getSlopePosition(position.x + aabb.getWidth(), position.y - 1);
                isOnSlope = (position.y == slopeLeft || position.y == slopeRight);
            } else {
                isOnSlope = false;
            }
        }

        // If player is not grounded on static ground, isGrounded is updated based on platform ground or slope ground
        if (!isGrounded && deltaY <= 0) {
            if (movementState.y < 0 && isOnPlatform) {
                // TODO: Fix the damn ladder + platform bug for real
                bottomTile = currentLevel.getTileAt(centerX, position.y - 1, Level.TRIGGER_LAYER);
                if (bottomTile != null) {
                    if (bottomTile.getProperties().containsKey("climbable")) {
                        position.y -= 1;
                        isOnPlatform = false;
                        isClimbing = true;
                    }
                }
            }
            isGrounded = isOnPlatform;
        }

        if (!isGrounded) {
            isGrounded = isOnSlope;
        }

        // If grounded state changes, make sure jump is reset
        if (!prevGrounded && isGrounded) {
            jumpState = 0;
            if (isCasting && currentSkill.isRootWhileCasting()) {
                movementState.set(0, 0);
            }
            if (forceDuration > 0 && forceVector.y > 0) {
                forceDuration = 0;
            }
        }

        // Update force vector status
        if (forceDuration > 0) {
            forceDuration -= Gdx.graphics.getDeltaTime();
            if (rootingForce) {
                isRooted = true;
            }
        } else if (forceDuration < 0) {
            forceDuration = 0;
        }

        // If casting, player is rooted
        if (isCasting && currentSkill.isRootWhileCasting()) {
            isRooted = true;
        } else if (forceDuration == 0 && rootingForce) {
            isRooted = false;
            rootingForce = false;
        }

        /** Update final positions */
        sprite.setPosition(position.x - hitboxOffset.x, position.y - hitboxOffset.y);
        aabb.setPosition(position);
        super.update();

        this.animate();
    }

    public void damage(float dmg, Entity source) {
        this.health -= dmg;
    }

    public boolean calculateCrit(LivingEntity source) {
        return MathUtils.randomBoolean(source.getCriticalChance());
    }

    public int calculateDamage(float dmg) {
        return MathUtils.ceil(MathUtils.random(dmg - (dmg * DAMAGE_RANGE_PERCENTAGE), dmg + (dmg * DAMAGE_RANGE_PERCENTAGE)));
    }

    public void die() {
        isActive = false;
        isVisible = false;
        Pools.free(buffs);
        if (Game.getDebugMode()) System.out.println(name + id + " has been slain.");
    }

    public void jump() {
        if (!isRooted) {
            if (jumpCounter < maxJumps) {
                if (isClimbing) {
                    isClimbing = false;
                    jumpState = jumpTime * 0.75f;
                    jumpCounter = maxJumps;
                } else {
                    jumpState = jumpTime;
                    if (this instanceof Player) {
                        AudioHelper.playSoundEffect(jumpSnd);
                    }
                }
                resetGravity();
                jumpCounter += 1;
                isGrounded = false;
                isJumping = true;
            }
        }
    }

    @Override
    public void draw(Batch batch) {
        super.draw(batch);
        if (childObjects.size > 0) {
            for (ChildObject co : childObjects) {
                if (co.isActive()) {
                    co.draw(batch);
                }
            }
        }
    }

    public boolean isOnSlope() {
        return isOnSlope;
    }

    public float getJumpState() {
        return jumpState;
    }

    public int getJumpCounter() {
        return jumpCounter;
    }

    public int getMaxJumps() {
        return maxJumps;
    }

    public void resetGravity() {
        this.currentGravity = 0;
    }

    public void changeHealth(int change) {
        if (this.maxHealth - this.health <= change) {
            this.health = maxHealth;
        } else {
            this.health += change;
        }
    }

    public void changeMana(int change) {
        if (this.maxHealth - this.health <= change) {
            this.mana = maxMana;
        } else {
            this.mana += change;
        }

        if (mana < 0) {
            mana = 0;
        }
    }

    public int getHealth() {
        return health;
    }

    public int getMaxHealth() {
        return maxHealth;
    }

    public int getMana() {
        return mana;
    }

    public int getMaxMana() {
        return maxMana;
    }

    public void setSpeed(float speed) {
        this.speed = speed;
    }

    public Vector2 getMovementState() {
        return movementState;
    }

    public void setSprinting(boolean sprinting) {
        this.isSprinting = sprinting;
    }

    public boolean isGrounded() {
        return isGrounded;
    }

    public boolean isJumping() {
        return isJumping;
    }

    public void setIsJumping(boolean isJumping) {
        this.isJumping = isJumping;
    }

    public abstract void cast(int skill);

    public boolean canClimb() {
        return canClimb;
    }

    public boolean isClimbing() {
        return isClimbing;
    }

    public boolean isOnPlatform() {
        return isOnPlatform;
    }

    public boolean isRooted() {
        return isRooted;
    }

    public void applyForce(Vector2 forceVector, float duration) {
        applyForce(forceVector, duration, false);
    }

    public void applyForce(Vector2 forceVector, float duration, boolean rootingForce) {
        this.forceVector = forceVector;
        this.forceDuration = duration;
        this.rootingForce = rootingForce;
    }

    public SkillInventory getSkills() {
        return this.skills;
    }

    public float getCriticalChance() {
        return criticalChance;
    }

    public BuffInventory getBuffList() {
        return this.buffs;
    }

    public boolean getCanCast() {
        return canCast;
    }

    public void setCanCast(boolean canCast) {
        this.canCast = canCast;
    }

    public void setIsRooted(boolean isRooted) {
        this.isRooted = isRooted;
    }

    public void setAdditionalSpeed(float speed) {
        this.additionalSpeed = speed;
    }

    public float getAdditionalSpeed() {
        return this.additionalSpeed;
    }


}

```

`core/src/com/jxz/notcontra/entity/Monster.java`:

```java
package com.jxz.notcontra.entity;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Pool;
import com.jxz.notcontra.entity.pickups.DropChance;
import com.jxz.notcontra.entity.pickups.Pickups;
import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.handlers.AudioHelper;
import com.jxz.notcontra.handlers.GameStateManager;
import com.jxz.notcontra.hud.OSHealthBar;
import com.jxz.notcontra.particles.DamageNumber;
import com.jxz.notcontra.particles.ParticleFactory;
import com.jxz.notcontra.world.Level;

/**
 * Created by Kevin Xiao on 2015-04-23.
 */
public abstract class Monster extends LivingEntity implements Pool.Poolable {

    public static final float UPDATE_INTERVAL = 1.0f; // Constant for AI update tick rate
    protected AIState state;
    protected OSHealthBar healthbar;
    protected float aimRadius;
    protected float aiStateTime;
    protected float lastUpdateTime;
    protected float damage;
    protected float kbDuration, kbDistance, kbThreshold;
    protected float patrolSpeed, chaseSpeed;
    protected Vector2 distToTarget;
    protected Entity target;
    protected float deathLerp;
    protected int deathScore;
    protected Class[] itemDrops;

    public enum AIState {
        IDLE, PATROLLING, CHASING, DYING, SPAWNING
    }

    public Monster(String entityName) {
        super(entityName);
        this.healthbar = new OSHealthBar(this);
        addChild(healthbar);
        distToTarget = new Vector2(0, 0);
        lastUpdateTime = UPDATE_INTERVAL;
    }

    public void init() {
        aabb.set(position.x, position.y, sprite.getWidth(), sprite.getHeight());
        maxHealth = Math.round(baseHealth * Game.getDifficultyMultiplier());
        health = maxHealth;
        damage = Math.round(baseDamage * Game.getDifficultyMultiplier());
        isVisible = true;
        isActive = true;
        hitboxOffset.set(-aabb.getWidth() / 2f, 0);
        state = AIState.SPAWNING;
        aiStateTime = 0.5f; // Start off idle for 0.5 seconds
        currentAnimation = animIdle;
    }

    public abstract void cast(int skill);

    public AIState getAIState() {
        return state;
    }

    public void setAIState(AIState state) {
        this.state = state;
    }

    @Override
    public void update() {
        preCollisionAiUpdate();
        super.update();
        postCollisionAiUpdate();
    }

    public abstract void preCollisionAiUpdate();

    public void postCollisionAiUpdate() {
        // Post Movement Checks
        switch (state) {
            case CHASING:
                // If slime is blocked on the x axis for some reason, try jumping
                // Although, don't jump if player is beneath the slime. That doesn't make sense.
                if (deltaX == 0 && distToTarget.y >= 0 && forceDuration == 0) {
                    jump();
                }
                // If target is dead, stop chasing them
                if (target instanceof LivingEntity) {
                    LivingEntity le = (LivingEntity) target;
                    if (le.getHealth() <= 0) {
                        target = null;
                        state = AIState.PATROLLING;
                    }
                }
                break;
            case PATROLLING:
                // If slime is blocked, stop for a bit
                if (deltaX == 0 && movementState.x != 0) {
                    aiStateTime = MathUtils.random(0.5f, 2.5f);
                    movementState.set(0, 0);
                }
                break;
        }

        // Update states:
        if (health <= 0 && state != AIState.DYING) {
            // Play death sound and drop items
            AudioHelper.playSoundEffect(dieSnd);
            dropItems();
            health = 0;
            animationPaused = false;
            buffs.reset();
            state = AIState.DYING;
            movementState.set(0, 0);
        }

        // Update state time
        aiStateTime -= Gdx.graphics.getDeltaTime();
        lastUpdateTime += Gdx.graphics.getDeltaTime();
    }

    @Override
    public void die() {
        super.die();
        target = null;
        GameStateManager.getInstance().getPlayState().getPlayer().addScore(deathScore);
        currentLevel.decMonsterCount();
        EntityFactory.free(this);
    }

    @Override
    public void draw(Batch batch) {
        if (state == AIState.DYING) {
            batch.setColor(1f, 1f, 1f, 1 - (animStateTime / animDeath.getAnimationDuration()));
        }

        if (state == AIState.SPAWNING) {
            batch.setColor(1f, 1f, 1f, 1 - (aiStateTime / 0.5f));
        }

        super.draw(batch);
        batch.setColor(1f, 1f, 1f, 1f);
    }

    @Override
    public void damage(float dmg, Entity source) {
        boolean doCrit = false;
        float newDmg;

        // Play sound
        AudioHelper.playSoundEffect(hitSnd);
        // Calculate critical hit and display damage numbers
        if (source instanceof Player) {
            doCrit = calculateCrit((LivingEntity) source);
        }

        DamageNumber damageNumber = (DamageNumber) ParticleFactory.spawn(DamageNumber.class);

        if (doCrit) {
            newDmg = this.calculateDamage(dmg * 2f);
            damageNumber.init("hitMonsterCrit", newDmg, this);
        } else {
            newDmg = this.calculateDamage(dmg);
            damageNumber.init("hitMonster", newDmg, this);
        }
        super.damage(newDmg, source);

        // If monster isn't already dying, proc hit animation
        if (state != AIState.DYING) {
            if (newDmg > kbThreshold) {
                forceVector = this.position.cpy().sub(source.getPosition()).nor();
                forceVector.set(forceVector.x, 0);
                forceVector.scl(kbDistance);
                applyForce(forceVector, kbDuration, true);
                movementState.set(0, 0);
                resetGravity();
            }
            if (state != AIState.CHASING) {
                state = AIState.CHASING;
                target = source;
            }
        }
    }

    @Override
    public void setCurrentLevel(Level level) {
        this.currentLevel = level;
        level.incMonsterCount();
    }

    public void reset() {
        isVisible = false;
        isActive = false;
        position.set(-1336, 1339);
    }

    public float getTouchDamage() {
        return damage;
    }

    public Entity getTarget() {
        return target;
    }

    public void setTarget(Entity target) {
        this.target = target;
    }

    public float getAimRadius() {
        return aimRadius;
    }

    public void setAimRadius(float aimRadius) {
        this.aimRadius = aimRadius;
    }

    public void dropItems() {
        float chance;
        if (itemDrops != null) {
            for (Class p : itemDrops) {
                chance = DropChance.getDropChance(p);
                if (MathUtils.random(0f, 1f) <= chance) {
                    Pickups drop = (Pickups) EntityFactory.spawn(p);
                    drop.setCurrentLevel(currentLevel);
                    drop.init(this.position.x, this.position.y);
                }
            }
        }
    }
}



```

`core/src/com/jxz/notcontra/entity/PhysicsProjectile.java`:

```java
package com.jxz.notcontra.entity;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.maps.tiled.TiledMapTile;
import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.skill.LinearProjectileSkill;
import com.jxz.notcontra.skill.Skill;
import com.jxz.notcontra.world.Level;

import java.util.ArrayList;

/**
 * Created by Samuel on 2015-06-04.
 */
public class PhysicsProjectile extends Projectile {
    protected float currentGravity;
    protected float gravityScaling = 1.0f;
    protected boolean ignorePlatforms;
    protected boolean explodeOnGround = false;
    protected boolean isOnSlope, isGrounded, isOnPlatform;

    @Override
    public void update() {
        // Projectile is out of life
        if (time < 0 || (targets == 0 && targetLimited)) {
            EntityFactory.free(this);
        } else {
            // Move projectile forwards
            // Update Collision
            /** Declare local variables */
            float slopeLeft, slopeRight;
            float centerX, centerY;
            float deltaX, deltaY;
            deltaX = 0;
            deltaY = 0;

            // Previous State storage
            boolean prevGrounded = isGrounded;

            // Update pre-positional fields
            centerX = position.x + aabb.getWidth() / 2;
            centerY = position.y + aabb.getHeight() / 2;

            int height = (int) Math.ceil(aabb.getHeight() * Game.UNIT_SCALE); // Tile height, rounded up
            int width = (int) Math.ceil(aabb.getWidth() * Game.UNIT_SCALE); // Gets tile width, rounded up, of the entity
            float widthOffset, heightOffset;

            /** Step X coordinate */
            // Step X for static tile data
            if (direction.x != 0) {
                // Add effective speed to delta X
                float effectiveSpeed = speed * (isOnSlope ? 0.75f : 1);
                deltaX += effectiveSpeed * direction.x;
            }

            // Check collision bounds
            float boundingEdgeDelta = (deltaX > 0 ? 1 : -1) * aabb.getWidth() / 2;
            float dist;

            // Low FPS check - ensure collisions are checked properly if FPS < 60
            if (Game.getFpsTimer() > 1) {
                deltaX *= Game.getFpsTimer();
            }

            // X collision check
            float maxDist = Math.abs(deltaX);
            for (int i = 0; i <= height; i++) {
                if (i == width) {
                    heightOffset = aabb.getHeight();
                } else {
                    heightOffset = i / Game.UNIT_SCALE;
                }
                dist = currentLevel.distToObstacle(centerX + boundingEdgeDelta, position.y + heightOffset, deltaX, false);
                if (dist < maxDist) {
                    maxDist = dist;
                }
            }

            deltaX = (deltaX > 0 ? 1 : -1) * maxDist;

            // Update x
            position.x += (Game.getFpsTimer() > 1) ? deltaX : deltaX * Game.getFpsTimer();

            // Step upwards movement
            deltaY += speed * direction.y;
            // Update Y if on slope
            if (isOnSlope) {
                slopeLeft = currentLevel.getSlopeOfTile(position.x, position.y - 1);
                slopeRight = currentLevel.getSlopeOfTile(position.x + aabb.getWidth(), position.y - 1);
                float currentSlope = (Math.abs(slopeLeft) > Math.abs(slopeRight) ? slopeLeft : slopeRight);
                if (currentLevel.getTileAt(position.x, position.y, Level.DYNAMIC_LAYER) == currentLevel.getTileAt(position.x + aabb.getWidth(), position.y, Level.DYNAMIC_LAYER)) {
                    //deltaY += currentSlope;
                }
                position.y += ((Game.getFpsTimer() > 1) ? deltaX : deltaX * Game.getFpsTimer()) * currentSlope;
            }

            float currentDist, currentSlope; // local variables
            currentGravity += currentLevel.getGravity() * Gdx.graphics.getDeltaTime() * gravityScaling; // Step gravity
            //System.out.println(currentGravity);
            maxDist = 9999; // Reset max distance
            // Iterates through all intersecting Y tiles
            for (int i = 0; i <= width; i++) {
                if (i == width) {
                    widthOffset = aabb.getWidth();
                } else {
                    widthOffset = i / Game.UNIT_SCALE;
                }

                // Updates position due to gravity, if applicable (not climbing)
                if (!isGrounded) {
                    deltaY -= currentGravity;
                } else {
                    // Resets jump counter if player is already grounded
                    currentGravity = 0;
                }

                // Stick player to slope
                if (deltaX != 0 && isOnSlope) {
                    deltaY -= Math.abs(deltaX) * currentLevel.getGravity() * gravityScaling;
                }

                // Low fps check - ensures collisions are handled properly when FPS < 60
                if (Game.getFpsTimer() > 1) {
                    deltaY *= Game.getFpsTimer();
                }

                // Y-check
                // Static Collision Check:
                boundingEdgeDelta = (deltaY > 0 ? 1 : -1) * aabb.getHeight() / 2; // Defines either the top edge of the AABB or bottom edge, depending on direction
                dist = currentLevel.distToObstacle(position.x + widthOffset, centerY + boundingEdgeDelta, deltaY, true);

                // Dynamic collision check
                // Slope / One way platform check only applies if player is moving down
                if (deltaY <= 0) {
                    // One way platform check
                    if (!ignorePlatforms) {
                        currentDist = currentLevel.distToPlatform(position.x + widthOffset, position.y, Math.abs(deltaY));
                        if (currentDist < dist) {
                            dist = currentDist;
                        }
                    }

                }

                // Update max possible distance travelled
                if (dist < maxDist) {
                    maxDist = dist;
                }
            }

            // Slope Check
            if (deltaY <= 0) {
                float leftDist, rightDist;
                // Slope Check - scan downwards until a slope tile is found
                leftDist = currentLevel.distToObstacle(position.x, position.y, deltaY, true, Level.DYNAMIC_LAYER, "slope");
                rightDist = currentLevel.distToObstacle(position.x + aabb.getWidth(), position.y, deltaY, true, Level.DYNAMIC_LAYER, "slope");

                // Get y-coordinate of nearest slope to the left and right sides
                slopeLeft = currentLevel.getSlopePosition(position.x, position.y - leftDist);
                slopeRight = currentLevel.getSlopePosition(position.x + aabb.getWidth(), position.y - rightDist);

                // Calculate differences
                leftDist = position.y - slopeLeft;
                rightDist = position.y - slopeRight;

                // Current slope is the closest edge
                if (leftDist > rightDist) {
                    currentSlope = rightDist;
                    currentDist = slopeRight;
                } else {
                    currentSlope = leftDist;
                    currentDist = slopeLeft;
                }

                // If player is within correcting distance under the slope, correct them onto the slope
                if (currentSlope < 0 && currentSlope > -3) {
                    maxDist = 0;
                    position.y = currentDist;
                } else if (currentSlope < maxDist) {
                    // If not, get the maximum distance that can be travelled
                    maxDist = currentSlope;
                }
            }

            // Finalize delta Y based on lowest distance
            deltaY = (deltaY > 0 ? 1 : -1) * maxDist;
            position.y += (Game.getFpsTimer() > 1) ? deltaY : deltaY * Game.getFpsTimer();


            /** Update boolean states **/
            // Check if player is on static ground
            isGrounded = currentLevel.distToObstacle(position.x, position.y, -1, true) == 0 || currentLevel.distToObstacle(position.x + aabb.getWidth(), position.y, -1, true) == 0;

            // Check if player is on dynamic ground (platform)
            isOnPlatform = currentLevel.distToPlatform(position.x, position.y, 1) == 0 || currentLevel.distToPlatform(position.x + aabb.getWidth(), position.y, 1) == 0;

            // If player is in a slope tile, they are also grounded if they are in the proper y-position
            if (currentLevel.getSlopeOfTile(position.x, position.y) != 0 || currentLevel.getSlopeOfTile(position.x + aabb.getWidth(), position.y) != 0) {
                slopeLeft = currentLevel.getSlopePosition(position.x, position.y);
                slopeRight = currentLevel.getSlopePosition(position.x + aabb.getWidth(), position.y);
                isOnSlope = (position.y == slopeLeft) || (position.y == slopeRight);
            } else {
                // Check edge case where player is technically not on slope tile, but is still on the slope
                if (isOnSlope) {
                    slopeLeft = currentLevel.getSlopePosition(position.x, position.y - 1);
                    slopeRight = currentLevel.getSlopePosition(position.x + aabb.getWidth(), position.y - 1);
                    isOnSlope = (position.y == slopeLeft || position.y == slopeRight);
                } else {
                    isOnSlope = false;
                }
            }

            if (!isGrounded) {
                isGrounded = isOnSlope;
            }

            /** Update final positions */
            aabb.setPosition(position);
            animate();

            // Update lifespan
            time -= Gdx.graphics.getDeltaTime();

            // Check collisions
            if (isCollidable) {
                ArrayList<Entity> target = collisionCheck();
                if (!target.isEmpty()) {
                    for (Entity e : target) {
                        if (targets > 0 && targetLimited) {
                            targets--;
                        }
                        parent.hit(e);
                    }
                }
            }

            if (isGrounded && explodeOnGround) {
                EntityFactory.free(this);
            }
        }
    }

    public void setGravityScaling(float gravityScaling) {
        this.gravityScaling = gravityScaling;
    }

    public void setIgnorePlatforms(boolean ignorePlatforms) {
        this.ignorePlatforms = ignorePlatforms;
    }

    @Override
    public void reset() {
        currentGravity = 0;
        super.reset();
    }

    public void setExplodeOnGround(boolean explodeOnGround) {
        this.explodeOnGround = explodeOnGround;
    }

}

```

`core/src/com/jxz/notcontra/entity/Player.java`:

```java
package com.jxz.notcontra.entity;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Preferences;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.maps.tiled.TiledMapTile;
import com.badlogic.gdx.math.Intersector;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.jxz.notcontra.animation.AnimationEx;
import com.jxz.notcontra.animation.SpriteEx;
import com.jxz.notcontra.camera.PlayerCamera;
import com.jxz.notcontra.entity.pickups.Pickups;
import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.handlers.AudioHelper;
import com.jxz.notcontra.handlers.EntityManager;
import com.jxz.notcontra.handlers.GameStateManager;
import com.jxz.notcontra.handlers.SkillInventory;
import com.jxz.notcontra.hud.PlayerStatusBar;
import com.jxz.notcontra.particles.DamageNumber;
import com.jxz.notcontra.particles.ParticleFactory;
import com.jxz.notcontra.skill.Skill;
import com.jxz.notcontra.states.PlayState;
import com.jxz.notcontra.world.Level;

/**
 * Created by Samuel on 2015-03-27.
 * The one and only player
 */
public class Player extends LivingEntity {
    // Player camera
    private PlayerCamera camera;
    private PlayState playState;
    private PlayerStatusBar healthBar;
    private PlayerState state;
    private float flickerTimer;
    private int flickerCount;
    private int score;
    private PlayerSave playerSave;
    private AnimationEx animDeath;
    private float fallDamage = 0;

    // Constants
    private final float FALL_DMG_GRAVITY_MIN = 11.5f;
    private final float FLICKER_SECONDS = 1.5f;
    private final int FLICKER_COUNT = 8;
    private final int MANA_REGEN = 1;

    // Animation frame name values
    private final String ANIM_WALK = "walk1";
    private final String ANIM_IDLE = "stand1";
    private final String ANIM_JUMP = "jump";
    private final String ANIM_ROPE = "rope";
    private final String ANIM_LADDER = "ladder";
    private final String ANIM_CAST_0 = "swingO1";
    private final String ANIM_CAST_1 = "swingO2";
    private final String ANIM_CAST_2 = "swingOF";
    private final String ANIM_DEATH = "dead1";

    // Constructor
    public Player(PlayState playState) {
        super(GameStateManager.getInstance().getGame().getPlayerSpriteName());
        playerSave = GameStateManager.getInstance().getGame().getLoadSaveObject();
        if (playerSave != null) {
            this.health = playerSave.health;
            this.mana = playerSave.mana;
            this.score = playerSave.score;
            this.setPosition(playerSave.x, playerSave.y);
            GameStateManager.getInstance().getGame().resetSaveObject();
        } else {
            this.health = 100;
            this.mana = 100;
            this.score = 0;
        }
        // Set up animations
        animWalk = new AnimationEx(1 / 6f, ANIM_WALK, name);
        animIdle = new AnimationEx(1 / 1.5f, ANIM_IDLE, name);
        animJump = new AnimationEx(1f, ANIM_JUMP, name);
        animRope = new AnimationEx(1 / 2f, ANIM_ROPE, name);
        animLadder = new AnimationEx(1 / 4f, ANIM_LADDER, name);
        animCast = new AnimationEx[3];
        animCast[0] = new AnimationEx(1 / 4.2f, ANIM_CAST_0, name);
        animCast[1] = new AnimationEx(1 / 5f, ANIM_CAST_1, name);
        animCast[2] = new AnimationEx(1 / 7f, ANIM_CAST_2, name);
        animDeath = new AnimationEx(1 / 2f, ANIM_DEATH, name);

        movementState = new Vector2(0, 0);

        // Sound strings
        dieSnd = "player_death";


        // Setup Hitbox
        aabb.set(position.x, position.y, 30, 50);
        hitboxOffset.set(-aabb.getWidth() / 2f, 0);
        speed = 3;
        renderOffset = 0;

        // Player stats setup
        maxHealth = 100;
        maxMana = 100;
        state = PlayerState.ALIVE;
        flickerTimer = 0f;
        flickerCount = 0;
        baseDamage = 30;
        damageMultiplier = 1;
        criticalChance = 0.2f; // Percentage in decimal form

        // Jump parameters
        maxJumps = 2;
        jumpCounter = 0;
        jumpState = 0;
        jumpMultiplier = 1;
        jumpTime = 3;

        // Setup Skill
        skills = new SkillInventory(5);
        name = GameStateManager.getInstance().getGame().getPlayerSpriteName();
        if (name.equalsIgnoreCase("Player")) {
            // Mage
            skills.setInventory(0, "iceball");
            skills.setInventory(1, "icespike");
        } else if (name.equalsIgnoreCase("Kirito")) {
            // Warrior
            skills.setInventory(0, "swirlingmoon");
            skills.setInventory(1, "dash");
        } else if (name.equalsIgnoreCase("Hotdog")) {
            // Not sure
            skills.setInventory(0, "hotdogspam");
            skills.setInventory(1, "dash");
        } else {
            skills.setInventory(0, "iceballSpam");
            skills.setInventory(1, "iceball");
        }

        // Initialize animated sprite for player
        this.sprite = new SpriteEx(animIdle.getKeyFrame(animStateTime, true));
        this.playState = playState;
        this.healthBar = new PlayerStatusBar(this);
    }

    public enum PlayerState {
        ALIVE, HURT, DEAD,
    }

    @Override
    public void update() {
        boolean prevRooted = isRooted;

        // Iterate through active skills to check what to cast
        for (int i = 0; i < 5; i++) {
            if (skills.getSkill(i) != null) {
                if (skills.getActive(i) && skills.getCooldown(i) == 0 && canCast) {
                    cast(i);
                }
                skills.decreaseCooldown(i, Gdx.graphics.getDeltaTime());
            }
        }

        // Regen Mana
        changeMana(Math.round(MANA_REGEN * Game.getFpsTimer()));

        // Iterate through entities to check collision
        if (forceDuration == 0) {
            for (Entity e : EntityManager.getInstance().getEntitiesListIteration()) {
                if (e.isActive()) {
                    if (e.getCurrentLevel().equals(currentLevel)) {
                        if (e instanceof Monster && !e.equals(this)) {
                            // Check touch damage
                            Monster m = (Monster) e;
                            if (m.getAIState() != Monster.AIState.DYING && m.getAIState() != Monster.AIState.SPAWNING) {
                                if (Intersector.overlaps(aabb, e.getAABB())) {
                                    if (buffs.hasBuff("ForceBuff")) {
                                        // Cannot be damaged while force buff'd
                                        m.damage(15, this);
                                    } else {
                                        damage(m.getTouchDamage(), e);
                                    }
                                    break;
                                }
                            }
                        } else if (e instanceof Pickups) {
                            // Check pickups
                            if (Intersector.overlaps(aabb, e.getAABB())) {
                                Pickups p = (Pickups) e;
                                p.giveEffect(this);
                                p.reset();
                            }
                        }
                    }
                }
            }
        }

        super.update();

        // Calculate fall damage
        fallDamage();

        // Re-poll for movement if root state updated
        if (prevRooted && !isRooted) {
            updateMovementState();
        }

        // Update health bar
        healthBar.update();

        if (state == PlayerState.HURT) {
            flickerTimer += Gdx.graphics.getDeltaTime();
        }
        if (flickerTimer >= FLICKER_SECONDS / FLICKER_COUNT) {
            flickerTimer = 0;
            flickerCount += 1;
        }
        if (flickerCount >= FLICKER_COUNT) {
            state = PlayerState.ALIVE;
            flickerTimer = 0;
            flickerCount = 0;
        }

        // Kill player after coming to rest from taking damage
        if (state != PlayerState.DEAD && health <= 0 && forceDuration <= 0 && isGrounded) {
            health = 0;
            movementState.set(0, 0);
            state = PlayerState.DEAD;
            Tombstone tombstone = (Tombstone) EntityFactory.spawn(Tombstone.class);
            tombstone.setCurrentLevel(currentLevel);
            tombstone.setTombStone(this.position.x - (tombstone.getSprite().getWidth() - this.sprite.getWidth()) / 2 - 10, this.position.y + tombstone.getSprite().getHeight());
            AudioHelper.playSoundEffect(dieSnd);
        }
    }

    public void fallDamage() {
        // Sets fall damage value over a certain gravity threshold
        if (!isGrounded && !isClimbing) {
            if (currentGravity > FALL_DMG_GRAVITY_MIN) {
                fallDamage = currentGravity - FALL_DMG_GRAVITY_MIN;
            }
        }
        // Damages player only when grounded after fall
        if (isGrounded && fallDamage > 0.0f) {
            this.damage(MathUtils.ceil(15f + fallDamage * 8f), this);
            fallDamage = 0;
        }

    }

    @Override
    public void damage(float dmg, Entity source) {
        float newDmg = this.calculateDamage(dmg);
        // Player takes damage first
        if (state == PlayerState.ALIVE) {
            super.damage(newDmg, source);
            // Display damage
            DamageNumber damageNumber = (DamageNumber) ParticleFactory.spawn(DamageNumber.class);
            damageNumber.init("hitPlayer", newDmg, this);

            // Knock back player
            forceVector = this.getCenterPosition().cpy().sub(source.getCenterPosition()).nor();
            forceVector.set(forceVector.x, 0.6f);
            forceVector.scl(8);
            applyForce(forceVector, 0.8f);
            state = PlayerState.HURT;

            // Reset movement states
            if (isSprinting) {
                isSprinting = false;
            }

            if (jumpState > 0) {
                jumpState = 0;
            }
            resetGravity();
        }
    }

    public void setCamera(PlayerCamera camera) {
        this.camera = camera;
    }

    public void cast(int index) {
        Skill skill = skills.getSkill(index);
        if (mana > skill.getCost()) {
            // Check if the player is casting already
            if (skill.isPriorityCast()) {
                if (!isClimbing() && !isCasting) {
                    isCasting = true;
                    skillCasted = false;
                    currentSkill = skills.getSkill(index);
                    currentSkill.preCast(this);

                    if (index != castType) {
                        castType = index;
                        castStateTime = 0;
                    }
                    if (isGrounded && currentSkill.isRootWhileCasting()) {
                        // No motions persist through casting, unless one is already in the air
                        movementState.set(0, 0);
                    }
                }
            } else {
                // Skill can be cast during other skills
                skill.use(this);
                skills.setCooldown(index, skill.getMaxCooldown());
            }
            mana -= skill.getCost();
        }
    }

    public void animate() {
        // Animation stuff
        if (!animationPaused) {
            animStateTime += Gdx.graphics.getDeltaTime();
        }

        // Changes animation based on current frame time
        if (isAlive()) {
            if (isGrounded && !isCasting) {
                climbingStateTime = 0;
                if (movementState.x == 0) {
                    this.sprite.setRegion(animIdle.getKeyFrame(animStateTime, true), animIdle.getAnimOffset(animStateTime));
                } else {
                    this.sprite.setRegion(animWalk.getKeyFrame(animStateTime, true), animWalk.getAnimOffset(animStateTime));
                }
            } else if (!isGrounded && isClimbing) {
                animStateTime = 0;
                if (movementState.y != 0) {
                    climbingStateTime += Gdx.graphics.getDeltaTime();
                }
                this.sprite.setRegion(animLadder.getKeyFrame(climbingStateTime, true), animLadder.getAnimOffset(climbingStateTime));
            } else {
                this.sprite.setRegion(animJump.getKeyFrame(animStateTime, true), animJump.getAnimOffset(animStateTime));
            }

            // Attack
            if (isCasting && !isClimbing) {
                castStateTime += Gdx.graphics.getDeltaTime();
                this.sprite.setRegion(animCast[castType].getKeyFrame(castStateTime, false), animCast[castType].getAnimOffset(castStateTime));
                // Only spawns skill after casting animation is finished
                if (animCast[castType].getKeyFrameIndex(castStateTime) == animCast[castType].getKeyFrameIndex(animCast[castType].getAnimationDuration()) && !skillCasted) {
                    if (!buffs.hasBuff("CastingBuff") && !buffs.hasBuff("ForceBuff")) {
                        currentSkill.use(this);
                    }
                    skillCasted = true;
                }
                if (animCast[castType].isAnimationFinished(castStateTime)) {
                    isCasting = false;
                    castStateTime = 0;
                    if (currentSkill.isRootWhileCasting()) {
                        isRooted = false;
                    }
                    updateMovementState();
                }
            }
        } else {
            this.sprite.setRegion(animDeath.getKeyFrame(animStateTime, true), animDeath.getAnimOffset(animStateTime));
        }

        // Flip sprite if facing left
        if (movementState.x < 0 && !isClimbing) {
            isFlipped = true;
        } else if (movementState.x > 0 && !isClimbing) {
            isFlipped = false;
        }
        this.sprite.setSize(this.sprite.getRegionWidth(), this.sprite.getRegionHeight());
    }

    // Polls keys to update movement state. Used from resuming lapses in motion updating.
    public void updateMovementState() {
        Preferences keyPreferences = Gdx.app.getPreferences("InputManager");
        // Reset movement state
        movementState.set(0, 0);

        // Poll movement keys for updated movement state
        if (Gdx.input.isKeyPressed(keyPreferences.getInteger("left", Input.Keys.A))) {
            movementState.add(-1, 0);
        }
        if (Gdx.input.isKeyPressed(keyPreferences.getInteger("right", Input.Keys.D))) {
            movementState.add(1, 0);
        }
        if (Gdx.input.isKeyPressed(keyPreferences.getInteger("up", Input.Keys.W))) {
            movementState.add(0, 1);
        }
        if (Gdx.input.isKeyPressed(keyPreferences.getInteger("down", Input.Keys.S))) {
            movementState.add(0, -1);
        }

        isSprinting = Gdx.input.isKeyPressed(keyPreferences.getInteger("sprint", Input.Keys.SHIFT_LEFT));
    }


    @Override
    public void setCurrentLevel(Level level) {
        if (playerSave != null && currentLevel == null) {
            position.set(playerSave.x, playerSave.y);
            level.setCurrentWave(playerSave.wave);
        } else {
            float spawnX = Float.parseFloat(level.getMap().getProperties().get("spawnX", String.class));
            float spawnY = Float.parseFloat(level.getMap().getProperties().get("spawnY", String.class));
            level.setCurrentWave(1);
            position.set(spawnX / Game.UNIT_SCALE, spawnY / Game.UNIT_SCALE);
        }
        aabb.setPosition(position.x + hitboxOffset.x, position.y + hitboxOffset.y);
        currentLevel = level;

    }

    public void interact() {
        // Interacts with target center tile (and eventually entities)
        TiledMapTile target = currentLevel.getTileAt(position.x + aabb.getWidth() / 2, position.y + aabb.getHeight() / 2, Level.TRIGGER_LAYER);
        if (target != null) {
            if (target.getProperties().containsKey("interactable")) {
                String command = target.getProperties().get("interactable", String.class);
                if (command.equalsIgnoreCase("nextLevel")) {
                    if (currentLevel.isComplete()) {
                        playState.load(target.getProperties().get("nextLevel", String.class));
                    }
                }
            }
        }
    }

    public PlayerStatusBar getHealthBar() {
        return healthBar;
    }

    @Override
    public void draw(Batch batch) {
        if (state == PlayerState.HURT && flickerCount % 2 == 0) {
            batch.setColor(1f, 1f, 1f, 0.4f);
        } else if (!isAlive()) {
            batch.setColor(1f, 1f, 1f, 1f);
        }
        super.draw(batch);
        batch.setColor(1f, 1f, 1f, 1f);
    }

    public boolean isAlive() {
        return state != PlayerState.DEAD;
    }

    public void setScore(int score) {
        this.score = score;
    }

    public int getScore() {
        return score;
    }

    public void addScore(int score) {
        this.score += score;
    }

    public void subtractScore(int score) {
        this.score -= score;
    }
}

```

`core/src/com/jxz/notcontra/entity/PlayerSave.java`:

```java
package com.jxz.notcontra.entity;

import com.badlogic.gdx.math.Vector2;

/**
 * Created by Andrew on 2015-05-07.
 * Prototype for saving crucial player object information
 */
public class PlayerSave {

    public String name;
    public int score;
    public float x;
    public float y;
    public int health;
    public int mana;
    public String mode;
    public String level;
    public float timeSurvived;
    public int wave;

    public PlayerSave() {

    }

    public void setName(String name) {
        this.name = name;
    }

    public void setScore(int score) {
        this.score = score;
    }

    public void setPosition(Vector2 position) {
        this.x = position.x;
        this.y = position.y;
    }

    public void setPosition(float x, float y) {
        this.x = x;
        this.y = y;
    }

    public void setHealth(int health) {
        this.health = health;
    }

    public void setMana(int mana) {
        this.mana = mana;
    }

    public void setMode(String mode) {
        this.mode = mode;
    }

    public void setLevel(String level) {
        this.level = level;
    }

    public void setWave(int wave) {
        this.wave = wave;
    }

    public void setTimeSurvived(float timeSurvived) {
        this.timeSurvived = timeSurvived;
    }

    public int getWave() {
        return wave;
    }
}

```

`core/src/com/jxz/notcontra/entity/Projectile.java`:

```java
package com.jxz.notcontra.entity;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.math.Vector2;
import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.skill.LinearProjectileSkill;
import com.jxz.notcontra.skill.Skill;

import java.util.ArrayList;

/**
 * Created by Samuel on 23/04/2015.
 * Projectiles are travelling hitboxes.
 */
public class Projectile extends DynamicHitbox {
    // Projectile Specific
    protected int targets;
    protected Vector2 direction;
    protected float speed;

    public Projectile() {
        super("projectile");
        direction = new Vector2(0, 0);
    }

    @Override
    public void update() {
        // Projectile is out of life
        if (time < 0 || (targets == 0 && targetLimited)) {
            EntityFactory.free(this);
        } else {
            // Move projectile forwards
            position.add(direction.x * speed * Game.getFpsTimer(), direction.y * speed * Game.getFpsTimer());
            aabb.setPosition(position.cpy().add(hitboxOffset));
            animate();

            // Update lifespan
            time -= Gdx.graphics.getDeltaTime();

            // Check collisions
            if (isCollidable) {
                ArrayList<Entity> target = collisionCheck();
                if (!target.isEmpty()) {
                    for (Entity e : target) {
                        if (targets > 0 && targetLimited) {
                            targets--;
                        }
                        if (e instanceof LivingEntity) {
                            LivingEntity le = (LivingEntity) e;
                            if (le.getBuffList().hasBuff("ForceBuff")) {
                                // Deflect projectile with force
                                caster = le;
                                parent.setCaster(le);
                                if (parent instanceof LinearProjectileSkill) {
                                    LinearProjectileSkill lps = (LinearProjectileSkill) parent;
                                    time = lps.getRange() / lps.getSpeed();
                                } else {
                                    time = 1.5f;
                                }
                                hitEntities.clear();
                                direction = direction.scl(-1);
                            } else {
                                parent.hit(e);
                            }
                        } else {
                            parent.hit(e);
                        }
                    }
                }
            }
        }
    }

    // Initialization upon retrieving from pool
    public void init(Skill parent, LivingEntity caster, float x, float y, float targetX, float targetY) {
        super.init(parent, caster, x, y);
        direction.set(targetX - x, targetY - y).nor();
        sprite.setOriginCenter();
    }

    @Override
    public void reset() {
        super.reset();
        direction.set(0, 0);
        speed = 0;
    }

    @Override
    public void animate() {
        animStateTime += Gdx.graphics.getDeltaTime();
        sprite.setRegion(animTravel.getKeyFrame(animStateTime, true));
    }

    @Override
    public void draw(Batch batch) {
        // Draw with rotational support
        batch.draw(sprite.getTexture(),
                this.position.x * Game.UNIT_SCALE,
                this.position.y * Game.UNIT_SCALE,
                sprite.getWidth() / 2 * Game.UNIT_SCALE,
                sprite.getHeight() / 2 * Game.UNIT_SCALE,
                this.sprite.getWidth() * Game.UNIT_SCALE,
                this.sprite.getHeight() * Game.UNIT_SCALE,
                1.0f,
                1.0f,
                direction.angle(),
                sprite.getRegionX(),
                sprite.getRegionY(),
                sprite.getRegionWidth(),
                sprite.getRegionHeight(),
                false, isFlipped
        );

        if (Game.getDebugMode()) {
            batch.draw(debug.getTexture(),
                    this.position.x * Game.UNIT_SCALE,
                    this.position.y * Game.UNIT_SCALE,
                    aabb.getWidth() / 2 * Game.UNIT_SCALE,
                    aabb.getHeight() / 2 * Game.UNIT_SCALE,
                    this.aabb.getWidth() * Game.UNIT_SCALE,
                    this.aabb.getHeight() * Game.UNIT_SCALE,
                    1.0f,
                    1.0f,
                    direction.angle(),
                    sprite.getRegionX(),
                    sprite.getRegionY(),
                    sprite.getRegionWidth(),
                    sprite.getRegionHeight(),
                    false, isFlipped);
        }
    }


    public void setDirection(Vector2 direction) {
        this.direction = direction.nor();
        isFlipped = (direction.x < 0);
    }

    public void setDirection(float x, float y) {
        direction.set(x, y).nor();
    }

    public void setRange(float units) {
        time = units / speed;
    }

    public void setTargets(int amount) {
        targets = amount;
    }

    public void setSpeed(float speed) {
        this.speed = speed;
    }

    public void setTime(float units) {
        time = units;
    }
}

```

`core/src/com/jxz/notcontra/entity/RangedMonster.java`:

```java
package com.jxz.notcontra.entity;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.maps.tiled.TiledMapTile;
import com.badlogic.gdx.math.MathUtils;
import com.jxz.notcontra.handlers.SkillInventory;
import com.jxz.notcontra.skill.Skill;
import com.jxz.notcontra.world.Level;

/**
 * Created by Samuel on 31/05/2015.
 * Ranged monster AI. Any AI that can cast.
 */
public abstract class RangedMonster extends Monster {

    protected float attackRange; // Effective range of the monster, it will approach until in this range
    protected int skillCount;

    public RangedMonster(String name, int skillCount) {
        super(name);
        this.skillCount = skillCount;
        skills = new SkillInventory(skillCount);
    }

    @Override
    public void cast(int index) {
        // Cast type is constant in AI, since we're only dealing with 1 cast animation
        Skill skill = skills.getSkill(index);
        // Check if the player is casting already
        if (skill.isPriorityCast()) {
            if (!isCasting) {
                isCasting = true;
                skillCasted = false;
                currentSkill = skills.getSkill(index);
                currentSkill.preCast(this);
                castType = 0;
                castStateTime = 0;

                if (currentSkill.isHasCastEffect()) {
                    animCast[0].setFrameDuration(currentSkill.getAnimation().getAnimationDuration() / currentSkill.getAnimation().getKeyFrames().length);
                }

                if (isGrounded && currentSkill.isRootWhileCasting()) {
                    // No motions persist through casting, unless one is already in the air
                    movementState.set(0, 0);
                }
            }
        } else {
            // Skill can be cast during other skills
            skill.use(this);
            skills.setCooldown(index, skill.getMaxCooldown());
        }
    }

    @Override
    public void preCollisionAiUpdate() {
       boolean skillsAvailable = false;

        // Iterate through active skills to check what to cast
        for (int i = 0; i < skillCount; i++) {
            if (skills.getSkill(i) != null) {
                if (skills.getCooldown(i) == 0) {
                    skillsAvailable = true;
                }
                skills.decreaseCooldown(i, Gdx.graphics.getDeltaTime());
            }
        }

        if (!skillsAvailable) {
            canCast = false;
        }

        switch (state) {
            // Pre-movement checks
            case SPAWNING:
                if (aiStateTime <= 0) {
                    if (target != null) {
                        state = AIState.CHASING;
                    } else {
                        state = AIState.PATROLLING;
                    }
                }
            case IDLE:
                // Idle. Don't move.
                movementState.set(0, 0);
                break;
            case CHASING:
                // Approach target if not rooted
                speed = chaseSpeed;
                if (!isRooted) {
                    // Only recalculate at update intervals
                    if (lastUpdateTime > UPDATE_INTERVAL) {
                        distToTarget = target.getCenterPosition().cpy().sub(this.getCenterPosition());
                        if (Math.abs(distToTarget.len2()) > attackRange * attackRange || !canCast) {
                            // Approach attack range if out of attack range, or if spells are on cooldown
                            movementState.set(distToTarget.x, 0).nor();
                        } else {
                            // Cast a spell here
                            cast(skills.getAvailableSkillIndex());
                            movementState.set(0, 0);
                        }
                        lastUpdateTime = 0;
                    }
                    // If you're going to run yourself off a platform, at least jump.
                    if (isOnPlatform && !isCasting) {
                        float boundingEdgeDelta = (movementState.x > 0 ? 1 : -1) * aabb.getWidth() / 2;
                        TiledMapTile targetTile = currentLevel.getTileAt(position.x + aabb.getWidth() / 2 + boundingEdgeDelta + (movementState.x * (speed + additionalSpeed)), position.y - 1, Level.DYNAMIC_LAYER);
                        if (targetTile == null) {
                            jump();
                        }
                    }
                }
                break;
            case PATROLLING:
                // Reduce speed when patrolling
                speed = patrolSpeed;
                if (aiStateTime <= 0) {
                    if (movementState.isZero()) {
                        // New patrol route
                        movementState.set(MathUtils.randomSign(), 0);
                        aiStateTime = MathUtils.random(2.0f, 4.0f);
                    } else {
                        // Pause between patrol points
                        movementState.set(0, 0);
                        aiStateTime = MathUtils.random(0.5f, 2.5f);
                    }
                } else {
                    // Turn around if the slime is going to run off the platform
                    if (isOnPlatform) {
                        float boundingEdgeDelta = (movementState.x > 0 ? 1 : -1) * aabb.getWidth() / 2;
                        TiledMapTile targetTile = currentLevel.getTileAt(position.x + aabb.getWidth() / 2 + boundingEdgeDelta + (movementState.x * (speed + additionalSpeed)), position.y - 1, Level.DYNAMIC_LAYER);
                        if (targetTile == null) {
                            movementState.set(-movementState.x, 0);
                        }
                    }
                }
                break;
        }
    }

    public void animate() {
        // Update animation time
        if (!isAnimationPaused()) {
            animStateTime += Gdx.graphics.getDeltaTime();
        }

        // Casting > Hurt > Death > Movement/Idle
        if (isCasting) {
            castStateTime += Gdx.graphics.getDeltaTime();
            this.sprite.setRegion(animCast[castType].getKeyFrame(castStateTime, false), animCast[castType].getAnimOffset(castStateTime));
            // Only spawns skill after casting animation is finished
            if (animCast[castType].getKeyFrameIndex(castStateTime) == animCast[castType].getKeyFrameIndex(animCast[castType].getAnimationDuration()) && !skillCasted) {
                if (!buffs.hasBuff("CastingBuff") && !buffs.hasBuff("ForceBuff")) {
                    currentSkill.use(this);
                }
                skillCasted = true;
            }
            if (animCast[castType].isAnimationFinished(castStateTime)) {
                isCasting = false;
                castStateTime = 0;
                if (currentSkill.isRootWhileCasting()) {
                    isRooted = false;
                }
            }
        } else if (forceDuration > 0) {
            if (currentAnimation != animHurt) {
                animStateTime = 0;
            }
            forceDuration -= Gdx.graphics.getDeltaTime();
            sprite.setRegion(animHurt.getKeyFrame(animStateTime, true), animHurt.getAnimOffset(animStateTime));
            currentAnimation = animHurt;
        } else if (state == AIState.DYING) {
            if (currentAnimation != animDeath) {
                animStateTime = 0;
            }
            sprite.setRegion(animDeath.getKeyFrame(animStateTime, true), animDeath.getAnimOffset(animStateTime));
            currentAnimation = animDeath;
            if (animStateTime > animDeath.getAnimationDuration()) {
                die();
            }
        } else if (movementState.isZero()) {
            if (currentAnimation != animIdle) {
                animStateTime = 0;
            }
            sprite.setRegion(animIdle.getKeyFrame(animStateTime, true), animIdle.getAnimOffset(animStateTime));
            currentAnimation = animIdle;
        } else {
            if (currentAnimation != animWalk) {
                animStateTime = 0;
            }
            sprite.setRegion(animWalk.getKeyFrame(animStateTime, true), animWalk.getAnimOffset(animStateTime));
            currentAnimation = animWalk;
        }

        if (movementState.x < 0) {
            isFlipped = true;
        } else if (movementState.x > 0) {
            isFlipped = false;
        }

        this.sprite.setSize(this.sprite.getRegionWidth(), this.sprite.getRegionHeight());
    }
}

```

`core/src/com/jxz/notcontra/entity/Slime.java`:

```java
package com.jxz.notcontra.entity;

import com.badlogic.gdx.math.MathUtils;
import com.jxz.notcontra.animation.AnimationEx;
import com.jxz.notcontra.animation.SpriteEx;
import com.jxz.notcontra.entity.pickups.HealthPotion;
import com.jxz.notcontra.handlers.AudioHelper;

/**
 * Created by Kevin Xiao on 2015-04-23.
 * Slime. Exemplifies "grunt" AI.
 */
public class Slime extends GruntMonster {

    // Animation frame name values
    private final String TEXTURE_ATLAS_NAME = "grey_slime";
    private final String ANIM_WALK = "move";
    private final String ANIM_IDLE = "stand";
    private final String ANIM_JUMP = "jump";
    private final String ANIM_HURT = "hit1";
    private final String ANIM_DEATH = "die1";

    public Slime() {
        super("slime");

        // Set up score
        deathScore = 5;
        // Set up animations
        animIdle = new AnimationEx(1 / 6f, ANIM_IDLE, TEXTURE_ATLAS_NAME);
        animWalk = new AnimationEx(1 / 6f, ANIM_WALK, TEXTURE_ATLAS_NAME);
        animHurt = new AnimationEx(1 / 6f, ANIM_HURT, TEXTURE_ATLAS_NAME);
        animJump = new AnimationEx(1 / 6f, ANIM_JUMP, TEXTURE_ATLAS_NAME);
        animDeath = new AnimationEx(1 / 10f, ANIM_DEATH, TEXTURE_ATLAS_NAME);

        hitboxOffset.set(-aabb.getWidth() / 2f, 0);
        renderOffset = 0;

        // Initialize sprite stuff
        this.sprite = new SpriteEx(animIdle.getKeyFrame(animStateTime, true));

        // Knock back values
        kbDuration = 0.4f;
        kbDistance = 25f;
        kbThreshold = 15;

        // Combat stats
        baseDamage = 5;
        baseHealth = 50;
        speed = 3 + MathUtils.random(-0.5f, 0.5f);
        damageMultiplier = 1;

        // Jump parameters
        maxJumps = 1;
        jumpCounter = 0;
        jumpState = 0;
        jumpMultiplier = 0.9f;
        jumpTime = 3f;

        // Speed parameters
        patrolSpeed = 2.0f;
        chaseSpeed = 3.0f;

        // Sound
        dieSnd = "slime_die";
        hitSnd = "slime_hit";

        // Drop chance
        itemDrops = new Class[1];
        itemDrops[0] = HealthPotion.class;
    }

}

```

`core/src/com/jxz/notcontra/entity/StaticEntity.java`:

```java
package com.jxz.notcontra.entity;

/**
 * Created by Samuel on 2015-03-27.
 */
public abstract class StaticEntity extends Entity {
    public StaticEntity(String entityName) {
        super(entityName);
    }
}

```

`core/src/com/jxz/notcontra/entity/Tombstone.java`:

```java
package com.jxz.notcontra.entity;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.math.Interpolation;
import com.badlogic.gdx.math.Vector2;
import com.jxz.notcontra.animation.AnimationEx;
import com.jxz.notcontra.animation.SpriteEx;
import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.handlers.AssetHandler;

/**
 * Created by Kevin Xiao on 2015-05-22.
 */
public class Tombstone extends AnimatedEntity {

    private Vector2 offset = new Vector2(0, 0);
    private AnimationEx animFall;
    private float offsetY;

    public Tombstone() {
        super("tombstone");

        this.animFall = new AnimationEx(1/20f, ((TextureAtlas)AssetHandler.getInstance().getByName("tombstone")).findRegions("fall"));
        isVisible = true;

        // Initialize animated sprite for tombstone
        this.sprite = new SpriteEx(animFall.getKeyFrame(animStateTime, true));
    }

    public void update() {
        super.update();

        offsetY = Interpolation.exp5Out.apply(offsetY, 0, 0.02f);
        sprite.setPosition(position.x, position.y + offsetY);
        this.animate();
    }

    public void setTombStone(float x, float y) {
        position.y = y - 2;
        position.x = x;
        offsetY = Game.VID_HEIGHT;
    }

    public void animate() {
        // Animation stuff
        animStateTime += Gdx.graphics.getDeltaTime();
        this.sprite.setRegion(animFall.getKeyFrame(animStateTime));
    }
}

```

`core/src/com/jxz/notcontra/entity/pickups/DropChance.java`:

```java
package com.jxz.notcontra.entity.pickups;

import com.badlogic.gdx.utils.ObjectMap;

/**
 * Created by Kevin Xiao on 2015-06-03.
 */
public class DropChance {

    private static final ObjectMap<Class, Float> dropTable = createMap();

    private static ObjectMap<Class, Float> createMap(){
        ObjectMap<Class, Float> objectMap = new ObjectMap<Class, Float>();

        // Set up drop chances here for each specific pickup class
        objectMap.put(HealthPotion.class, 0.4f);

        return objectMap;
    }

    public static float getDropChance(Class clazz) {
        return dropTable.get(clazz);
    }

}

```

`core/src/com/jxz/notcontra/entity/pickups/HealthPotion.java`:

```java
package com.jxz.notcontra.entity.pickups;

import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.jxz.notcontra.animation.SpriteEx;
import com.jxz.notcontra.entity.LivingEntity;
import com.jxz.notcontra.handlers.AssetHandler;

/**
 * Created by Kevin Xiao on 2015-06-03.
 */
public class HealthPotion extends Pickups {

    public HealthPotion() {
        super("health_potion");

        // initialize sprite stuff
        this.sprite = new SpriteEx(((TextureAtlas) AssetHandler.getInstance().getByName("pickups")).findRegion("potion_red"));
        aabb.set(position.x, position.y, sprite.getWidth(), sprite.getHeight());
        pickupSnd = "potion";
    }

    public void giveEffect(LivingEntity le) {
        super.giveEffect(le);
        if (le.getHealth() < le.getMaxHealth()) {
            le.changeHealth(10);
            this.reset();
        }
    }

}

```

`core/src/com/jxz/notcontra/entity/pickups/Pickups.java`:

```java
package com.jxz.notcontra.entity.pickups;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.utils.Pool;
import com.jxz.notcontra.entity.LivingEntity;
import com.jxz.notcontra.entity.StaticEntity;
import com.jxz.notcontra.handlers.AudioHelper;

/**
 * Created by Kevin Xiao on 2015-06-03.
 */
public abstract class Pickups extends StaticEntity implements Pool.Poolable {

    private float stateTime;
    private final float BEGIN_FADE_TIME = 10f;
    private final float END_FADE_TIME = 11f;
    protected String pickupSnd;

    public Pickups(String pickupName) {
        super(pickupName);
        this.isVisible = true;
        this.isActive = true;
        stateTime = 0;
    }

    @Override
    public void update() {
        super.update();
        stateTime += Gdx.graphics.getDeltaTime();

        if (stateTime >= END_FADE_TIME) {
            this.reset();
        }
    }

    public void init(float x, float y) {
        stateTime = 0;
        this.isActive = true;
        this.isVisible = true;
        this.position.set(x, y);
        this.sprite.setPosition(x, y + this.sprite.getHeight());
        aabb.set(position.x, position.y, sprite.getWidth(), sprite.getHeight());
    }

    @Override
    public void reset() {
        this.isActive = false;
        this.isVisible = false;
        stateTime = 0;
    }

    @Override
    public void draw(Batch batch) {
        if (stateTime >= BEGIN_FADE_TIME) {
            batch.setColor(1f, 1f, 1f, (END_FADE_TIME - stateTime) / (END_FADE_TIME - BEGIN_FADE_TIME));
        } else {
            batch.setColor(1f, 1f, 1f, 1f);
        }
        super.draw(batch);
        batch.setColor(1f, 1f, 1f, 1f);
    }

    public void giveEffect(LivingEntity le) {
        AudioHelper.playSoundEffect(pickupSnd);
    }
}

```

`core/src/com/jxz/notcontra/game/Game.java`:

```java
package com.jxz.notcontra.game;

import com.badlogic.gdx.ApplicationAdapter;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.glutils.ShaderProgram;
import com.badlogic.gdx.utils.viewport.FitViewport;
import com.jxz.notcontra.camera.PlayerCamera;
import com.jxz.notcontra.entity.PlayerSave;
import com.jxz.notcontra.handlers.AssetHandler;
import com.jxz.notcontra.handlers.GameStateManager;
import com.jxz.notcontra.handlers.InputManager;
import com.jxz.notcontra.handlers.SaveGameHandler;
import com.jxz.notcontra.shaders.Shaders;

public class Game extends ApplicationAdapter {
    // Program Constants
    public static final String TITLE = "StoryTime v1.00";
    public static final int VID_WIDTH = 1280;
    public static final int VID_HEIGHT = 704;
    public static final float REST_DURATION = 10.0f;
    private static boolean debugMode = false;

    private static float fpsTimer;
    private AssetHandler assetHandler = AssetHandler.getInstance();
    // Game-wide managers
    private GameStateManager gsm;
    private PlayerCamera playerCam;
    private FitViewport viewport;
    private OrthographicCamera hudCam;
    private Shaders shaders;

    // String to keep track of loading save files
    private PlayerSave save;
    private String playerSpriteName;
    private String loadLevel;

    public String getPlayerSpriteName() {
        return playerSpriteName;
    }

    // Enum for the mode we are currently in in the game
    public enum PlayMode {
        SURVIVAL, STANDARD, REST
    }

    private PlayMode playMode;
    private static float difficultyMultiplier = 1.0f;

    // Map Render Variables
    public static final float UNIT_SCALE = 1 / 32f; // 1 ingame unit = 32 px (tile size)
    public static final int VIEW_HEIGHT = 22;
    public static final int VIEW_WIDTH = 40;

    @Override
    public void create() {
        // Instantiate viewport and camera for rendering
        ShaderProgram.pedantic = false;
        playerCam = new PlayerCamera(VIEW_WIDTH, VIEW_HEIGHT);
        viewport = new FitViewport(VIEW_WIDTH, VIEW_HEIGHT, playerCam);
        viewport.apply();
        playerCam.setToOrtho(false, VIEW_WIDTH, VIEW_HEIGHT);
        hudCam = new OrthographicCamera();
        hudCam.setToOrtho(false, VID_WIDTH, VID_HEIGHT);
        // Setup singleton manager classes
        gsm = GameStateManager.getInstance();
        gsm.setGameInstance(this); // THIS IS EXTREMELY IMPORTANT.
        gsm.setState(GameStateManager.State.MENU);
        setInputProcessor();
        shaders = new Shaders(VID_WIDTH, VID_HEIGHT);
    }

    @Override
    public void render() {
        fpsTimer = Gdx.graphics.getDeltaTime() * 60;
        gsm.update();
        gsm.render();
    }

    public void resize(int width, int height) {
        viewport.update(width, height);
        shaders.bindShaders(width, height);
        shaders.unbindShaders();
    }

    public void dispose() {
        assetHandler.dispose();
    }

    public void setInputProcessor() {
        // Input handled after player object created
        if (Gdx.input.getInputProcessor() == null) {
            Gdx.input.setInputProcessor(InputManager.getInstance(this));
        }
    }

    public PlayerCamera getPlayerCam() {
        return playerCam;
    }

    public OrthographicCamera getHudCam() {
        return hudCam;
    }

    public static float getFpsTimer() {
        return fpsTimer;
    }

    public FitViewport getViewport() {
        return viewport;
    }

    public static void setDebugMode(boolean debugMode) {
        Game.debugMode = debugMode;
    }

    public static boolean getDebugMode() {
        return debugMode;
    }

    public Shaders getShaders() {
        return shaders;
    }

    public void executeCommand(String cmd) {
        String[] cmds;
        if (cmd.contains(",")) {
            // Assume comma separated chain of commands
            cmds = cmd.split(",");
        } else {
            // Singular command
            cmds = new String[] { cmd };
        }
        if (cmds[0].equalsIgnoreCase("play")) {
            resetLoadSaveObject();
            if (cmds[1].equalsIgnoreCase("new")) {
                playMode = PlayMode.valueOf(cmds[2].toUpperCase());
                playerSpriteName = cmds[3];
                loadLevel = cmds[4];
            } else if (cmds[1].equalsIgnoreCase("load")) {
                save = SaveGameHandler.loadSave(cmds[2]);
                playMode = PlayMode.valueOf(save.mode);
                playerSpriteName = save.name;
                loadLevel = save.level;
            }
            gsm.setState(GameStateManager.State.LOAD);
            GameStateManager.getInstance().getLoadState().load("levels/levels.txt");
        } else if (cmds[0].equalsIgnoreCase("setKeyButton")) {
            InputManager inputManager = InputManager.getInstance();
            inputManager.setChangeKey(cmds[1]);
        } else if (cmds[0].equalsIgnoreCase("unPauseGame")) {
            gsm.getPlayState().setIsPaused(false);
        } else if (cmds[0].equalsIgnoreCase("saveGame")) {
            if (cmds[1].equalsIgnoreCase("overwrite")) {
                System.out.println(cmds[2]);
                SaveGameHandler.saveCurrentStateToFile(cmds[2]);
                gsm.getPlayState().setCurrentMenu(gsm.getPlayState().getPauseMenu());
            } else if (cmds[1].equalsIgnoreCase("new")) {
                Gdx.input.getTextInput(new Input.TextInputListener() {
                    @Override
                    public void input(String text) {
                        SaveGameHandler.saveCurrentStateToFile(text);
                        gsm.getPlayState().setCurrentMenu(gsm.getPlayState().getPauseMenu());
                    }

                    @Override
                    public void canceled() {
                    }
                }, "Save Game", "" ,"File Name");
            }

        } else if (cmds[0].equalsIgnoreCase("Quit")) {
            Gdx.app.exit();
        }
    }

    public PlayerSave getLoadSaveObject() {
        return save;
    }
    public void resetSaveObject() {
        this.save = null;
    }
    private void resetLoadSaveObject() {
        playMode = null;
    }

    public PlayMode getPlayMode() {
        return playMode;
    }

    public void setPlayMode(PlayMode mode) {
        this.playMode = mode;
    }

    public String getLoadLevel() {
        return loadLevel;
    }

    public void resetLoadLevel() {
        loadLevel = null;
    }
    public static float getDifficultyMultiplier() {
        return difficultyMultiplier;
    }

    public static void setDifficultyMultiplier(float difficultyMultiplier) {
        Game.difficultyMultiplier = difficultyMultiplier;
    }
}
```

`core/src/com/jxz/notcontra/handlers/AssetHandler.java`:

```java
package com.jxz.notcontra.handlers;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.assets.AssetDescriptor;
import com.badlogic.gdx.assets.AssetManager;
import com.badlogic.gdx.assets.loaders.resolvers.InternalFileHandleResolver;
import com.badlogic.gdx.audio.Music;
import com.badlogic.gdx.audio.Sound;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.ParticleEffect;
import com.badlogic.gdx.graphics.g2d.PolygonRegion;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.maps.tiled.TiledMap;
import com.badlogic.gdx.maps.tiled.TmxMapLoader;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import com.badlogic.gdx.utils.GdxRuntimeException;
import com.badlogic.gdx.utils.I18NBundle;
import com.badlogic.gdx.utils.ObjectMap;
import com.jxz.notcontra.game.Game;

import java.io.BufferedReader;
import java.io.IOException;
import java.util.regex.Pattern;

/**
 * Written by Andrew Jiang on 2015-04-18
 * Extension of AssetManager using some reflection techniques to read level files
 * All assets will go through here
 */
public class AssetHandler extends AssetManager {

    // This will be a singleton class
    private static AssetHandler assetHandler;

    // Constants for parsing files
    private static final int NAME = 0;
    private static final int PATH = 1;
    private static final int TYPE = 2;

    // Object map which will keep track of all assets
    private static ObjectMap<String, AssetDescriptor> assetMap = new ObjectMap<String, AssetDescriptor>();

    private AssetHandler() {
        super();
        setLoader(TiledMap.class, new TmxMapLoader(new InternalFileHandleResolver()));
    }

    public static AssetHandler getInstance() {
        if (assetHandler == null) {
            assetHandler = new AssetHandler();
        }
        return assetHandler;
    }

    /**
     * @return the internal file path of the given file, excluding file extension type
     * @param name the String key value of the file
     */
    public String getFilePath(String name) {
        return assetMap.get(name).fileName.split(Pattern.quote("."))[0];
    }

    public synchronized void loadFromFile(String filePath) {
        FileHandle fileHandle = Gdx.files.internal(filePath);
        BufferedReader br = new BufferedReader(fileHandle.reader());

        String line;
        String[] tmp;
        try {
            while ((line = br.readLine()) != null) {
                if (Game.getDebugMode()) System.out.println(line);
                // Only parse uncommented lines
                if (!line.trim().startsWith("#") && line.trim().length() > 0) {
                    // Regex for whitespace and tabs
                    tmp = line.split("\\s+");

                    Class clazz = findClass(tmp[TYPE]);
                    // Abandon ship if class cannot be found, we're pretty much screwed if this happens
                    if (clazz == null) throw new GdxRuntimeException("Class " + tmp[TYPE] + " not found!");

                    // Add the asset's descriptor to the map and load the asset
                    assetMap.put(tmp[NAME], new AssetDescriptor(tmp[PATH], clazz));
                    load(assetMap.get(tmp[NAME]));
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public synchronized Object getByName(String name) {
        if (assetMap.containsKey(name)) {
            return get(assetMap.get(name));
        } else {
            System.out.println("Asset not loaded!");
            return null;
        }
    }

    public synchronized boolean isLoadedByName(String name) {
        return assetMap.get(name) != null;
    }

    public void unloadByFile(String filePath) {
        FileHandle fileHandle = Gdx.files.internal(filePath);
        BufferedReader br = new BufferedReader(fileHandle.reader());

        String line;
        String[] tmp;
        try {
            while ((line = br.readLine()) != null) {
                // Only parse uncommented lines
                if (!line.trim().startsWith("#") && line.trim().length() > 0) {
                    // Regex for whitespace and tabs
                    tmp = line.split("\\s+");
                    unload(tmp[PATH]);
                    assetMap.remove(tmp[NAME]);
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Unfortunately, Java does not provide a way to find a class by reflection
    // without providing the full classname as a string. And since these classes
    // are all in different sub-packages, this is the best I've got.
    private Class findClass(String className) {
        if (className.equalsIgnoreCase("BitmapFont")) {
            return BitmapFont.class;
        } else if (className.equalsIgnoreCase("Music")) {
            return Music.class;
        } else if (className.equalsIgnoreCase("Pixmap")) {
            return Pixmap.class;
        } else if (className.equalsIgnoreCase("Sound")) {
            return Sound.class;
        } else if (className.equalsIgnoreCase("TextureAtlas")) {
            return TextureAtlas.class;
        } else if (className.equalsIgnoreCase("Texture")) {
            return Texture.class;
        } else if (className.equalsIgnoreCase("Skin")) {
            return Skin.class;
        } else if (className.equalsIgnoreCase("ParticleEffect")) {
            return ParticleEffect.class;
        } else if (className.equalsIgnoreCase("ParticleEffects3D")) {
            return com.badlogic.gdx.graphics.g3d.particles.ParticleEffect.class;
        } else if (className.equalsIgnoreCase("PolygonRegion")) {
            return PolygonRegion.class;
        } else if (className.equalsIgnoreCase("I18NBundle")) {
            return I18NBundle.class;
        } else if (className.equalsIgnoreCase("TiledMap")) {
            return TiledMap.class;
        }
        return null;
    }

    @Override
    public synchronized void dispose() {
        super.dispose();
        assetMap.clear();
    }

}

```

`core/src/com/jxz/notcontra/handlers/AudioHelper.java`:

```java
package com.jxz.notcontra.handlers;

import com.badlogic.gdx.audio.Music;
import com.badlogic.gdx.audio.Sound;

/**
 * Created by Andrew Jiang on 2015-04-18.
 */
public class AudioHelper {

    private static AssetHandler assetHandler = AssetHandler.getInstance();
    private static Music music;
    private static Sound sound;
    private static float volume = 1f;

    public static void setMusicVolume(float vol) {
        if (vol > 1) {
            vol = 1;
        } else if (vol < 0) {
            vol = 0;
        }
        volume = vol;
        music.setVolume(volume);
    }

    public static float getMusicVolume() {
        return volume;
    }

    public static Music getMusic() {
        return music;
    }

    public static void playBgMusic(boolean play) {
        if (play) {
            music.setLooping(true);
            music.play();
        } else {
            music.pause();
        }
    }

    public static void muteMusic() {
        if (music.getVolume() > 0) {
            volume = music.getVolume();
            music.setVolume(0f);
        } else {
            music.setVolume(volume);
        }
    }

    public static boolean isMusicMuted() {
        return music.getVolume() == 0f;
    }

    public static void setBgMusic(Music newMusic) {
        if (music != null) {
            music.dispose();
        }
        music = newMusic;
    }

    public static boolean isBgMusicPlaying() {
        return music.isPlaying();
    }

    public static void resetBackgroundMusic() {
        if (music != null) {
            music.setPosition(0f);
        }
        music.dispose();
    }

    public static void playSoundEffect(String soundName) {
        sound = (Sound) assetHandler.getByName(soundName);
        sound.play();
    }

}

```

`core/src/com/jxz/notcontra/handlers/BuffInventory.java`:

```java
package com.jxz.notcontra.handlers;

import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Pool;
import com.jxz.notcontra.buff.Buff;

/**
 * Created by Samuel on 03/06/2015.
 * Contains list of active buffs on a living entity.
 */
public class BuffInventory implements Pool.Poolable {
    // Fields
    protected Array<Buff> buffArray;

    public BuffInventory() {
        buffArray = new Array<Buff>();
    }

    public void update() {
        for (Buff b : buffArray) {
            // Step all buffs - inactive buffs will remove themselves
            b.update();
        }
    }

    public void addBuff(Buff buff) {
        buffArray.add(buff);
    }

    public void removeBuff(Buff buff) {
        buffArray.removeValue(buff, true);
    }

    public boolean hasBuff(String name) {
        for (Object o : buffArray.toArray(Buff.class)) {
            Buff b = (Buff) o;
            if (b.getName().equalsIgnoreCase(name)) {
                return true;
            }
        }
        return false;
    }

    @Override
    public void reset() {
        for (int i = 0; i < buffArray.size; i++) {
            buffArray.get(i).expire();
        }
        buffArray.clear();
    }
}

```

`core/src/com/jxz/notcontra/handlers/EntityManager.java`:

```java
package com.jxz.notcontra.handlers;

import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Disposable;
import com.badlogic.gdx.utils.Pool;
import com.badlogic.gdx.utils.Pools;
import com.jxz.notcontra.entity.Entity;
import com.jxz.notcontra.entity.EntityFactory;
import com.jxz.notcontra.entity.Player;
import com.jxz.notcontra.game.Game;

/**
 * Created by Samuel on 2015-03-27.
 */
public class EntityManager implements Disposable {
    // Entity Manager Fields
    private Array<Entity> masterList = new Array<Entity>();
    public static int id;
    private static EntityManager entityManager;

    private EntityManager() {
    }

    public static EntityManager getInstance() {
        if (entityManager == null) {
            entityManager = new EntityManager();
        }
        return entityManager;
    }

    public void register(Entity e) {
        // Add entities to master list, and add the appropriate physics body to the world
        masterList.add(e);
        id++;
        if (Game.getDebugMode()) System.out.println(e.getName() + id + " has registered");
    }

    public Array<Entity> getEntitiesListIteration() {
        // Return a copy of the list for iteration purposes
        return new Array(masterList);
    }

    public Array<Entity> getEntitiesList() {
        return masterList;
    }

    public void unregister(Entity e) {
        masterList.removeValue(e, true);
    }

    @Override
    public void dispose() {
        for (Entity e : masterList) {

            // TODO Determine whether during reset, it's better to free the objects and then clear the free pool, or just leave them be.
            if (e instanceof Pool.Poolable) {
                EntityFactory.free(e);
                Pools.get(e.getClass()).clear();
            }

            // Only dispose the texture if it's not a player texture; We need that for the menu.
            if (!(e instanceof Player)) {
                e.getSprite().getTexture().dispose();
            }
        }

        masterList.clear();
        id = 0;
    }
}

```

`core/src/com/jxz/notcontra/handlers/GameStateManager.java`:

```java
package com.jxz.notcontra.handlers;

import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.states.GameState;
import com.jxz.notcontra.states.LoadState;
import com.jxz.notcontra.states.MenuState;
import com.jxz.notcontra.states.PlayState;

/**
 * Created by Kevin Xiao on 2015-03-24.
 * A singleton class that manages the game states
 */

public class GameStateManager {
    private Game game;
    private static GameStateManager gsm;
    private static GameState currentGameState;
    private static PlayState playState;
    private static LoadState loadState;
    private static MenuState menuState;

    public enum State {
        PLAY, LOAD, MENU
    }

    private GameStateManager() {

    }

    public static GameStateManager getInstance() {
        if (gsm == null) {
            gsm = new GameStateManager();
        }
        return gsm;
    }

    public void setGameInstance(Game game) {
        this.game = game;
    }

    public void update() {
        currentGameState.update();
    }

    public void render() {
        currentGameState.render();
    }

    public Game getGame() {
        return game;
    }

    public PlayState getPlayState() {
        return playState;
    }

    public LoadState getLoadState() {
        return loadState;
    }

    public MenuState getMenuState() {
        return menuState;
    }

    public void setState(State state) {
        if (state == State.PLAY) {
            if (playState == null) {
                playState = new PlayState(game);
                playState.load(game.getLoadLevel());
                game.resetLoadLevel();
            }
            currentGameState = playState;
        } else if (state == State.LOAD) {
            if (loadState == null) {
                loadState = new LoadState(game);
            }
            currentGameState = loadState;
        } else if (state == State.MENU) {
            if (menuState == null) {
                menuState = new MenuState(game);
            }
            currentGameState = menuState;
        }
        currentGameState.setMusic();
    }

    public GameState getCurrentState() {
        return currentGameState;
    }

    public void resetGameState(State state) {
        if (state == State.PLAY) {
            playState = null;
        } else if (state == State.LOAD) {
            loadState = null;
        } else if (state == State.MENU) {
            menuState = null;
        }
    }
}

```

`core/src/com/jxz/notcontra/handlers/HighScoreHandler.java`:

```java
package com.jxz.notcontra.handlers;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.JsonValue;
import com.badlogic.gdx.utils.JsonWriter;

import java.util.ArrayList;
import java.util.Collections;

/**
 * Created by Andrew on 2015-06-03.
 */
public class HighScoreHandler {

    private static final int SIZE = 5;
    private static ArrayList<HighScore> highScores = new ArrayList<HighScore>(
            Collections.nCopies(5, new HighScore() {{
                setName("");
                setScore(0); }}
            ));
    private static final FileHandle FILE = Gdx.files.local("highScore.dat");

    // Initializing Json as an expression. Double brace syntax FTW.
    private static Json json = new Json() {{
        setTypeName(null);
        setUsePrototypes(false);
        setIgnoreUnknownFields(true);
        setOutputType(JsonWriter.OutputType.json);
    }};

    public static void loadFromDisk() {
        if (FILE.exists()) {
            ArrayList<JsonValue> jsonList = json.fromJson(ArrayList.class, FILE);

            for (int i = 0; i < SIZE; i++) {
                highScores.set(i, json.readValue(HighScore.class, jsonList.get(i)));
            }
        } else {
            System.out.println("High score file does not exist!");
        }
    }

    public static void flushToDisk() {
        FILE.writeString(json.prettyPrint(highScores), false);
    }

    public static boolean addHighScore(String name, int score) {
        for (int i = 0; i < SIZE; i++) {
            if (highScores.get(i).getScore() < score) {
                HighScore tempScore = new HighScore();
                tempScore.setName(name);
                tempScore.setScore(score);
                highScores.add(i, tempScore);
                highScores.subList(5, highScores.size()).clear();
                flushToDisk();
                return true;
            }
        }
        return false;
    }

    public static ArrayList<HighScore> getHighScores() {
        if (highScores.get(0).getScore() == 0 && FILE.exists()) {
            loadFromDisk();
        }
        return highScores;
    }

    public static int getLowestScore() {
        return highScores.get(SIZE - 1).getScore();
    }
    public static class HighScore {
        private String name;
        private int score;

        public HighScore() {
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getName() {
            return name;
        }

        public void setScore(int score) {
            this.score = score;
        }

        public int getScore() {
            return score;
        }
    }
}

```

`core/src/com/jxz/notcontra/handlers/InputManager.java`:

```java
package com.jxz.notcontra.handlers;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.InputProcessor;
import com.badlogic.gdx.Preferences;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.math.Vector3;
import com.jxz.notcontra.entity.Entity;
import com.jxz.notcontra.entity.Monster;
import com.jxz.notcontra.entity.Player;
import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.menu.KeyLayoutMenu;
import com.jxz.notcontra.menu.Menu;
import com.jxz.notcontra.menu.buttons.Button;
import com.jxz.notcontra.menu.buttons.TextLabel;
import com.jxz.notcontra.states.GameState;
import com.jxz.notcontra.states.LoadState;
import com.jxz.notcontra.states.MenuState;
import com.jxz.notcontra.states.PlayState;

import java.io.BufferedReader;
import java.io.IOException;

/**
 * Created by Samuel on 2015-03-27.
 */
public class InputManager implements InputProcessor {

    //    private Preferences keyPreferences = Gdx.app.getPreferences("InputManager");
    private Game game;
    private GameStateManager gsm;
    private static InputManager manager;
    private Player player;
    private Vector2 tempPos;
    private Vector3 tmp;
    private boolean isCtrlPressed;
    private String changeKey;
    private Menu currentMenu;

    private InputManager(Game game) {
        this.game = game;
        tempPos = new Vector2(0, 0);
        tmp = new Vector3(0, 0, 0);
        gsm = GameStateManager.getInstance();
    }

    public static InputManager getInstance(Game game) {
        if (manager == null) {
            manager = new InputManager(game);
        }
        return manager;
    }

    public static InputManager getInstance() {
        return manager;
    }

    @Override
    public boolean keyDown(int keycode) {

        if (changeKey != null && keycode != Input.Keys.ESCAPE) {
            KeyLayoutHelper.setKey(changeKey, keycode);
            if (changeKey != null) {
                GameState state = GameStateManager.getInstance().getCurrentState();
                if (state instanceof MenuState) {
                    if (((MenuState) state).getCurrentMenu() instanceof KeyLayoutMenu) {
                        ((KeyLayoutMenu) ((MenuState) state).getCurrentMenu()).keyChangeComplete(keycode);
                    }
                } else if (state instanceof PlayState) {
                    if (((PlayState) state).getCurrentMenu() instanceof KeyLayoutMenu) {
                        ((KeyLayoutMenu) ((PlayState) state).getCurrentMenu()).keyChangeComplete(keycode);
                    }
                }
            }
            changeKey = null;
            return true;
        }

        // Debug Mode
        if (keycode == KeyLayoutHelper.getKey("setDebug")) {
            Game.setDebugMode(!Game.getDebugMode());
        }

        // Movement controls only operational if in play state
        if (gsm.getCurrentState() instanceof PlayState) {

            if (keycode == Input.Keys.CONTROL_LEFT || keycode == Input.Keys.CONTROL_RIGHT) {
                isCtrlPressed = true;
            }

            player = gsm.getPlayState().getPlayer();
            if (player.isAlive()) {
                if (!player.isRooted()) {
                    // Update sprinting state
                    if (keycode == KeyLayoutHelper.getKey("sprint") && player.getJumpState() == 0) {
                        player.setSprinting(true);
                        return true;
                    }

                    // Standard WASD Movement
                    if (keycode == KeyLayoutHelper.getKey("left")) {
                        player.getMovementState().add(-1, 0);
                    }
                    if (keycode == KeyLayoutHelper.getKey("right")) {
                        player.getMovementState().add(1, 0);
                    }
                    if (keycode == KeyLayoutHelper.getKey("up")) {
                        player.getMovementState().add(0, 1);
                    }
                    if (keycode == KeyLayoutHelper.getKey("down")) {
                        player.getMovementState().add(0, -1);
                    }

                }

                // Jump if max jumps is not reached
                if (keycode == KeyLayoutHelper.getKey("jump") && !player.isJumping() && !gsm.getPlayState().isPaused()) {
                    player.jump();
                }
                // Attack | cast keys
                if (keycode == KeyLayoutHelper.getKey("skill1")) {
                    player.getSkills().setActive(0, true);
                }

                if (keycode == KeyLayoutHelper.getKey("skill2")) {
                    player.getSkills().setActive(1, true);
                }

                // Interact key
                if (keycode == KeyLayoutHelper.getKey("interact")) {
                    player.interact();
                }

//                if (Game.getDebugMode()) {
//                    // K has become the "piss off everything on the map" button
//                    if (keycode == keyPreferences.getInteger("aggroAll", Input.Keys.K)) {
//                        for (Entity e : EntityManager.getInstance().getEntitiesListIteration()) {
//                            if (e instanceof Monster) {
//                                Monster m = (Monster) e;
//                                m.setTarget(player);
//                                m.setAIState(Monster.AIState.CHASING);
//                            }
//                        }
//                    }
//                    if (keycode == keyPreferences.getInteger("spawnMonster", Input.Keys.L)) {
//                        // Spawn some slimes
//                        player.getCurrentLevel().spawn();
//                    }
//
//                }
            }

            // PAUSE GAME FROM PLAY STATE
            if (keycode == Input.Keys.ESCAPE) {
                if (gsm.getPlayState().getCurrentMenu().getPrevMenu() != null) {
                    gsm.getPlayState().setCurrentMenu(gsm.getPlayState().getCurrentMenu().getPrevMenu());
                } else {
                    gsm.getPlayState().setIsPaused(!gsm.getPlayState().isPaused());
                }
                return true;
            }
        }
        // LOAD STATE SWITCH STATE
        if (gsm.getCurrentState() instanceof LoadState) {
            if (keycode == Input.Keys.ESCAPE && gsm.getLoadState().getIsDoneLoading() && gsm.getLoadState().getIsEnteringGame()) {
                gsm.getLoadState().resetLoadingBar();
                gsm.setState(GameStateManager.State.PLAY);
                return true;
            }
        }
        if (gsm.getCurrentState() instanceof MenuState) {
            Menu prevMenu = gsm.getMenuState().getCurrentMenu().getPrevMenu();
            if (keycode == Input.Keys.ESCAPE && prevMenu != null) {
                gsm.getMenuState().setCurrentMenu(prevMenu);
            }
        }
        if (keycode == Input.Keys.P) {
            Gdx.graphics.setVSync(false);
            return true;
        }
        if (keycode == Input.Keys.O) {
            Gdx.graphics.setVSync(true);
            return true;
        }

        if (keycode == Input.Keys.M) {
            AudioHelper.muteMusic();
            return true;
        }

        return false;
    }

    @Override
    public boolean keyUp(int keycode) {
        // Again, movement controls in play mode only
        if (gsm.getCurrentState() instanceof PlayState) {
            player = gsm.getPlayState().getPlayer();
            // Released keys signal end of movement if player is not rooted
            if (player.isAlive()) {
                if (!player.isRooted()) {
                    if (keycode == KeyLayoutHelper.getKey("sprint")) {
                        player.setSprinting(false);
                    }
                    if (keycode == Input.Keys.CONTROL_LEFT || keycode == Input.Keys.CONTROL_RIGHT) {
                        isCtrlPressed = false;
                    }
                    // Standard WASD Movement
                    if (keycode == KeyLayoutHelper.getKey("left")) {
                        player.getMovementState().add(1, 0);
                    }
                    if (keycode == KeyLayoutHelper.getKey("right")) {
                        player.getMovementState().add(-1, 0);
                    }
                    if (keycode == KeyLayoutHelper.getKey("up")) {
                        player.getMovementState().add(0, -1);
                    }
                    if (keycode == KeyLayoutHelper.getKey("down")) {
                        player.getMovementState().add(0, 1);
                    }
                }

                // Resets jump flag if space bar is released - ready to jump again
                if (keycode == KeyLayoutHelper.getKey("jump")) {
                    player.setIsJumping(false);
                }
                // Release active skills
                if (keycode == KeyLayoutHelper.getKey("skill1")) {
                    player.getSkills().setActive(0, false);
                }

                if (keycode == KeyLayoutHelper.getKey("skill2")) {
                    player.getSkills().setActive(1, false);
                }
            }
        }
        return false;

    }

    @Override
    public boolean keyTyped(char character) {
        return false;
    }

    @Override
    public boolean touchDown(int screenX, int screenY, int pointer, int button) {
        if (changeKey != null) {
            GameState state = GameStateManager.getInstance().getCurrentState();
            if (state instanceof MenuState) {
                if (((MenuState) state).getCurrentMenu() instanceof KeyLayoutMenu) {
                    ((KeyLayoutMenu) ((MenuState) state).getCurrentMenu()).keyChangeComplete(-9001);
                }
            } else if (state instanceof PlayState) {
                if (((PlayState) state).getCurrentMenu() instanceof KeyLayoutMenu) {
                    ((KeyLayoutMenu) ((PlayState) state).getCurrentMenu()).keyChangeComplete(-9001);
                }
            }
            changeKey = null;
            return true;
        }

        if (gsm.getCurrentState() instanceof MenuState) {
            currentMenu = gsm.getMenuState().getCurrentMenu();
        } else if (gsm.getCurrentState() instanceof PlayState && gsm.getPlayState().isPaused()) {
            currentMenu = gsm.getPlayState().getCurrentMenu();
        }

        if (currentMenu != null) {
            for (Button i : currentMenu.getButtonList()) {
                if (i.isMouseWithinBoundary(screenX, screenY) && i.getInputListener() != null) {
                    i.setState(Button.ButtonState.CLICK);
                }
            }
        }
        currentMenu = null;
        return true;
    }

    @Override
    public boolean touchUp(int screenX, int screenY, int pointer, int button) {
        if (Game.getDebugMode()) {
            Vector2 position = getCursorInWorld();
            System.out.println("X: " + position.x + "Y: " + position.y);
        }
        if (gsm.getCurrentState() instanceof MenuState) {
            currentMenu = gsm.getMenuState().getCurrentMenu();
        } else if (gsm.getCurrentState() instanceof PlayState && gsm.getPlayState().isPaused()) {
            currentMenu = gsm.getPlayState().getCurrentMenu();
        }

        if (currentMenu != null) {
            for (Button i : currentMenu.getButtonList()) {
                if (i.isMouseWithinBoundary(screenX, screenY) && i.getInputListener() != null) {
                    i.getInputListener().onClick();
                    if (i.getCurrentState() == Button.ButtonState.CLICK && !(i instanceof TextLabel)) {
                        i.setState(Button.ButtonState.HOVER);
                    }
                }
            }
        }
        currentMenu = null;
        return true;
    }

    @Override
    public boolean touchDragged(int screenX, int screenY, int pointer) {
        return false;
    }

    @Override
    public boolean mouseMoved(int screenX, int screenY) {
        if (gsm.getCurrentState() instanceof MenuState) {
            currentMenu = gsm.getMenuState().getCurrentMenu();
        } else if (gsm.getCurrentState() instanceof PlayState && gsm.getPlayState().isPaused()) {
            currentMenu = gsm.getPlayState().getCurrentMenu();
        }

        if (currentMenu != null) {
            for (Button i : currentMenu.getButtonList()) {
                if ((i instanceof TextLabel) && i.getCurrentState() == Button.ButtonState.CLICK) {
                    continue;
                } else {
                    if (i.isMouseWithinBoundary(screenX, screenY) && i.getInputListener() != null) {
                        if (i.getCurrentState() != Button.ButtonState.HOVER) {
                            i.setState(Button.ButtonState.HOVER);
                            i.getInputListener().onHover();
                        }
                    } else {
                        i.setState(Button.ButtonState.DEFAULT);
                    }
                }
            }
        }
        currentMenu = null;
        return true;
    }

    @Override
    public boolean scrolled(int amount) {
        return false;
    }

    public Vector2 getCursorInWorld() {
        tmp.set(Gdx.input.getX(), Gdx.input.getY(), 0);
        game.getPlayerCam().unproject(tmp);
        tmp.scl(1 / Game.UNIT_SCALE);
        tempPos.set(tmp.x, tmp.y);
        return tempPos;
    }

    // Returns the normalized direction vector relative to the player
    public Vector2 getCursorDirection() {
        Vector2 centerPos = player.getPosition().cpy().add(player.getAABB().getWidth() / 2, player.getAABB().getHeight() / 2);
        return getCursorInWorld().sub(centerPos);
    }

    public Vector2 getCursorDirection(Vector2 relativePos) {
        return getCursorInWorld().sub(relativePos);
    }

//    private boolean setSavedKeyPreferences() {
//        String FILENAME = "keys/SavedLayout.txt";
//        FileHandle fileHandle = Gdx.files.internal(FILENAME);
//        BufferedReader br = new BufferedReader(fileHandle.reader());
//
//        String line;
//        String[] tmp;
//        try {
//            while ((line = br.readLine()) != null) {
//                if (Game.getDebugMode()) System.out.println(line);
//                // Only parse uncommented lines
//                if (!line.trim().startsWith("#") && line.trim().length() > 0) {
//                    // Regex for whitespace and tabs
//                    tmp = line.split("\\s+");
//                    keyPreferences.putInteger(tmp[0], Input.Keys.valueOf(tmp[1]));
//                }
//            }
//            keyPreferences.flush();
//            return true;
//        } catch (IOException e) {
//            System.out.println(FILENAME + "does not exist!");
//            return false;
//        }
//    }

    public void setChangeKey(String function) {
        changeKey = function;
    }
}

```

`core/src/com/jxz/notcontra/handlers/KeyLayoutHelper.java`:

```java
package com.jxz.notcontra.handlers;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Preferences;
import com.badlogic.gdx.utils.ArrayMap;

/**
 * Created by Andrew on 2015-06-03.
 */
public class KeyLayoutHelper {

    private static Preferences keyPreferences = Gdx.app.getPreferences("KeyLayout");

    private static final ArrayMap<String, String> KEY_DISPLAY_NAME = new ArrayMap<String, String>() {{
        put("Move Up", "up");
        put("Move Down", "down");
        put("Move Left", "left");
        put("Move Right", "right");
        put("Sprint", "sprint");
        put("Jump", "jump");
        put("Skill 1", "skill1");
        put("Skill 2", "skill2");
        put("Interact", "interact");
        put("Set Debug", "setDebug");
    }};

    private static final ArrayMap<String, Integer> DEFAULT_LAYOUT = new ArrayMap<String, Integer>() {{
        put("up", Input.Keys.W);
        put("down", Input.Keys.S);
        put("left", Input.Keys.A);
        put("right", Input.Keys.D);
        put("sprint", Input.Keys.SHIFT_LEFT);
        put("jump", Input.Keys.SPACE);
        put("skill1", Input.Keys.NUM_1);
        put("skill2", Input.Keys.NUM_2);
        put("skill3", Input.Keys.NUM_3);
        put("skill4", Input.Keys.NUM_4);
        put("interact", Input.Keys.E);
        put("setDebug", Input.Keys.GRAVE);
    }};

    public static int getKey(String keyname) {
        return keyPreferences.getInteger(keyname, DEFAULT_LAYOUT.get(keyname));
    }

    public static void setKey(String keyname, int keycode) {
        keyPreferences.putInteger(keyname, keycode);
        keyPreferences.flush();
    }

    public static void resetToDefault() {
        keyPreferences.clear();
        keyPreferences.flush();
    }

    public static ArrayMap<String, String> getKeyDisplayNameMap() {
        return KEY_DISPLAY_NAME;
    }

    public static ArrayMap<String, Integer> getDefaultLayoutMap() {
        return DEFAULT_LAYOUT;
    }
}

```

`core/src/com/jxz/notcontra/handlers/ParticleManager.java`:

```java
package com.jxz.notcontra.handlers;

import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Disposable;
import com.badlogic.gdx.utils.Pool;
import com.badlogic.gdx.utils.Pools;
import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.particles.Particle;
import com.jxz.notcontra.particles.ParticleFactory;

/**
 * Created by Kevin Xiao on 2015-05-31.
 */
public class ParticleManager implements Disposable {

    private Array<Particle> masterList = new Array<Particle>();
    public static int id;
    private static ParticleManager particleManager;

    private ParticleManager() {
    }

    public static ParticleManager getInstance() {
        if (particleManager == null) {
            particleManager = new ParticleManager();
        }
        return particleManager;
    }

    public void register(Particle p) {
        masterList.add(p);
        id++;
        if (Game.getDebugMode()) System.out.println("particle" + id + "has registered");
    }

    public Array<Particle> getParticlesListIteration() {
        // Return a copy of the list for iteration purposes
        return new Array(masterList);
    }

    public Array<Particle> getParticlesList() {
        return masterList;
    }

    public void unregister(Particle p) {
        masterList.removeValue(p, true);
    }

    @Override
    public void dispose() {
        for (Particle p : masterList) {
            if (p instanceof Pool.Poolable) {
                ParticleFactory.free(p);
                Pools.get(p.getClass()).clear();
            }
        }
        masterList.clear();
        id = 0;
    }

}

```

`core/src/com/jxz/notcontra/handlers/SaveGameHandler.java`:

```java
package com.jxz.notcontra.handlers;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.utils.Json;
import com.badlogic.gdx.utils.JsonWriter;
import com.jxz.notcontra.entity.Player;
import com.jxz.notcontra.entity.PlayerSave;
import com.jxz.notcontra.world.Level;

/**
 * Created by Andrew on 2015-04-19.
 */
public class SaveGameHandler {

    private static EntityManager entityManager = EntityManager.getInstance();

    public static void saveCurrentStateToFile(String filename) {
        FileHandle file = Gdx.files.local("saves/" + filename);

        Player player = GameStateManager.getInstance().getPlayState().getPlayer();
        PlayerSave playerSave = new PlayerSave();
        playerSave.setPosition(player.getPosition());
        playerSave.setHealth(player.getHealth());
        playerSave.setMana(player.getMana());
        playerSave.setName(player.getName());
        playerSave.setScore(player.getScore());
        playerSave.setWave(player.getCurrentLevel().getCurrentWave());
        playerSave.setTimeSurvived(GameStateManager.getInstance().getPlayState().getTimeSurvived());
        playerSave.setLevel(player.getCurrentLevel().getMap().getProperties().get("mapName", String.class));
        playerSave.setMode(GameStateManager.getInstance().getGame().getPlayMode().toString());

        Json json = new Json();
        json.setTypeName(null);
        json.setUsePrototypes(false);
        json.setIgnoreUnknownFields(true);
        json.setOutputType(JsonWriter.OutputType.json);

        file.writeString(json.prettyPrint(playerSave), false);

    }

    public static PlayerSave loadSave(String filename) {
        FileHandle file = Gdx.files.local("saves/" + filename);
        if (file.exists()) {
            Json json = new Json();
            json.setTypeName(null);
            json.setUsePrototypes(false);
            json.setIgnoreUnknownFields(true);
            json.setOutputType(JsonWriter.OutputType.json);

            return json.fromJson(PlayerSave.class, file);
        } else {
            System.out.println("Savefile does not exist!");
        }
        return null;
    }
}

```

`core/src/com/jxz/notcontra/handlers/SkillInventory.java`:

```java
package com.jxz.notcontra.handlers;

import com.jxz.notcontra.entity.DynamicHitbox;
import com.jxz.notcontra.skill.Skill;

/**
 * Created by Samuel on 03/05/2015.
 * A container for entity skills.
 */
public class SkillInventory {
    private Skill[] inventory; // List of skills owned by the caster
    private boolean[] isActive; // Is skill active? Used for toggle/reactivatable skills
    private float[] cooldown;   // Self explanatory. Spells may only be cast upon zero cooldown
    private float[] weighting; // Tendency for AI to fire each skill
    private DynamicHitbox[] projectiles;   // List of active projectiles stored by the caster, if necessary

    public SkillInventory(int capacity) {
        inventory = new Skill[capacity];
        isActive = new boolean[capacity];
        cooldown = new float[capacity];
        weighting = new float[capacity];
        projectiles = new DynamicHitbox[capacity];
    }

    public void setInventory(int index, Skill skill) {
        inventory[index] = skill;
    }

    public void setInventory(int index, String name) {
        inventory[index] = SkillManager.getSkill(name);
    }

    public Skill getSkill(int index) {
        return inventory[index];
    }

    public void setActive(int index, boolean isActive) {
        this.isActive[index] = isActive;
    }

    public boolean getActive(int index) {
        return isActive[index];
    }

    public float getCooldown(int index) {
        return cooldown[index];
    }

    public void decreaseCooldown(int index, float time) {
        cooldown[index] -= time;
        if (cooldown[index] < 0) {
            cooldown[index] = 0;
        }
    }

    public void setCooldown(int index, float cd) {
        cooldown[index] = cd;
    }

    public void setCooldown(Skill skill, float cd) {
        if (getIndex(skill) > 0) {
            cooldown[getIndex(skill)] = cd;
        }
    }

    public int getIndex(Skill skill) {
        for (int i = 0; i < inventory.length; i++) {
            if (skill.equals(inventory[i])) {
                return i;
            }
        }
        return -1;
    }

    public void setWeighting(int index, float weighting) {
        this.weighting[index] = weighting;
    }

    public float getWeighting(int index) {
        return weighting[index];
    }

    public Skill getAvailableSkill() {
        for (int i = 0; i < inventory.length; i++) {
            if (getCooldown(i) == 0) {
                return getSkill(i);
            }
        }

        return null;
    }

    public int getAvailableSkillIndex() {
        for (int i = 0; i < inventory.length; i++) {
            if (getCooldown(i) == 0) {
                return i;
            }
        }

        return -1;
    }
}

```

`core/src/com/jxz/notcontra/handlers/SkillManager.java`:

```java
package com.jxz.notcontra.handlers;

import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.utils.Pools;
import com.jxz.notcontra.buff.Buff;
import com.jxz.notcontra.buff.FrozenBuff;
import com.jxz.notcontra.entity.BossMonster;
import com.jxz.notcontra.entity.LivingEntity;
import com.jxz.notcontra.entity.Player;
import com.jxz.notcontra.skill.*;

import java.util.ArrayList;

/**
 * Created by Samuel on 24/04/2015.
 * Where skills are defined.
 */

public class SkillManager {
    private static ArrayList<Skill> skillList;
    private static ArrayList<Buff> buffList;
    private static AssetHandler assetManager = AssetHandler.getInstance();

    // Gets skill from skill array
    public static Skill getSkill(String name) {
        for (Skill s : skillList) {
            if (s.getName().equals(name)) {
                return s.clone();
            }
        }
        return null;
    }

    public static Buff getBuff(String name) {
        for (Buff b : buffList) {
            if (b.getName().equals(name)) {
                return Pools.obtain(b.getClass());
            }
        }
        return null;
    }

    public static Class getBuffClass(String name) {
        for (Buff b : buffList) {
            if (b.getName().equals(name)) {
                return b.getClass();
            }
        }
        return null;
    }

    public static void applyBuff(Class buffClass, LivingEntity afflicted, float duration) {
        Buff buff = (Buff) Pools.obtain(buffClass);
        // Disables cannot affect players or boss mobs
        if (afflicted instanceof Player || afflicted instanceof BossMonster) {
            if (!buff.isDisable()) {
                buff.setDuration(duration);
                buff.cast(afflicted);
            }
        } else {
            buff.setDuration(duration);
            buff.cast(afflicted);
        }
    }

    public static void applyBuff(Buff buff, LivingEntity afflicted, float duration) {
        // Disables cannot affect players or boss mobs
        if (afflicted instanceof Player || afflicted instanceof BossMonster) {
            if (!buff.isDisable()) {
                buff.setDuration(duration);
                buff.cast(afflicted);
            }
        } else {
            buff.setDuration(duration);
            buff.cast(afflicted);
        }

    }

    public static void applyBuff(String buffName, LivingEntity afflicted, float duration) {
        applyBuff(getBuffClass(buffName), afflicted, duration);
    }

    // Populates skill array - call before using any skills
    public static void init() {
        initBuffs();
        initSkills();
    }

    public static void initSkills() {
        // Initialize list
        skillList = new ArrayList<Skill>();

        // Skill 1: Melee Attack
        MeleeAttackSkill basicMeleeAttack = new MeleeAttackSkill("testmelee");
        basicMeleeAttack.setRootWhileCasting(true);
        TextureAtlas animFrames = (TextureAtlas) assetManager.getByName("swing");
        basicMeleeAttack.setVfx(animFrames);
        basicMeleeAttack.setTime(0.1f);
        basicMeleeAttack.setAnimName("0.swingD1.1");
        basicMeleeAttack.setHitboxSize(98, 89);
        basicMeleeAttack.setHitboxOffset(55, 0);
        basicMeleeAttack.setAnimation(new Animation(1 / 11.0f, animFrames.findRegions("0.swingD1.1")));
        basicMeleeAttack.setDamage(20);
        basicMeleeAttack.setDamageScaling(1.2f);
        skillList.add(basicMeleeAttack);

        // Skill 2: Second Melee Attack
        MeleeAttackSkill secondMeleeAttack = new MeleeAttackSkill("melee2");
        secondMeleeAttack.setRootWhileCasting(true);
        animFrames = (TextureAtlas) assetManager.getByName("swing");
        secondMeleeAttack.setVfx(animFrames);
        secondMeleeAttack.setTime(0.2f);
        secondMeleeAttack.setAnimName("0.swingD2.1");
        secondMeleeAttack.setHitboxSize(98, 89);
        secondMeleeAttack.setHitboxOffset(30, 0);
        secondMeleeAttack.setAnimation(new Animation(1 / 7.0f, animFrames.findRegions("0.swingD2.1")));
        secondMeleeAttack.setDamage(10);
        secondMeleeAttack.setDamageScaling(1.5f);
        skillList.add(secondMeleeAttack);

        // Skill 3: Iceball thing
        LinearProjectileSkill iceball = new LinearProjectileSkill("iceball");
        iceball.setRootWhileCasting(true);
        animFrames = (TextureAtlas) assetManager.getByName("iceball");
        iceball.setVfx(animFrames);
        iceball.setAnimName("ball");
        iceball.setSpeed(8.5f);
        iceball.setRange(8.0f);
        iceball.setHitboxSize(184, 103); // orig 184-103
        iceball.setAnimation(new Animation(1 / 10f, animFrames.findRegions("ball")));
        iceball.setDamage(30);
        iceball.setCastName("effect");
        iceball.setCastAnimation(new Animation(1 / 25f, animFrames.findRegions(iceball.getCastName())));
        iceball.setDamageScaling(2.0f);
        iceball.setHitEffect("hit.0");
        iceball.setHitAnimation(new Animation(1 / 3f, animFrames.findRegion(iceball.getHitEffect())));
        iceball.setStatusEffect("FrozenBuff");
        iceball.setStatusDuration(1.5f);
        iceball.setCost(30);
        skillList.add(iceball);

        // Skill 4: Ice ball spam
        CastingBuffSkill iceballSpam = new CastingBuffSkill("iceballSpam");
        iceballSpam.setRootWhileCasting(false);
        iceballSpam.setBuffName("CastingBuff");
        iceballSpam.setChildSkill(iceball);
        iceballSpam.setInterval(0.2f);
        iceballSpam.setBuffDuration(5.0f);
        skillList.add(iceballSpam);

        // Skill 5: Dash
        ForceBuffSkill dash = new ForceBuffSkill("dash");
        dash.setRootWhileCasting(true);
        dash.setBuffName("ForceBuff");
        dash.setBuffDuration(0.2f);
        dash.setMagnitude(25.0f);
        dash.setCooldown(1.2f);
        dash.setCost(50);
        skillList.add(dash);

        // Skill 6: Explosion
        ExplosionSkill explosion = new ExplosionSkill("Explosion");
        explosion.setDamage(50.0f);
        animFrames = (TextureAtlas) assetManager.getByName("explosion");
        explosion.setVfx(animFrames);
        explosion.setHitboxSize(300, 300);
        explosion.setAnimName("end");
        explosion.setAnimation(new Animation(1 / 10.0f, animFrames.findRegions("end")));
        skillList.add(explosion);

        // Skill 7: Ice Spikes
        RainProjectileSkill icespike = new RainProjectileSkill("icespikeInternal");
        animFrames = (TextureAtlas) assetManager.getByName("icespike");
        icespike.setVfx(animFrames);
        icespike.setAnimName("end");
        icespike.setAnimation(new Animation(1 / 10.0f, animFrames.findRegions("end")));
        icespike.setDamage(15);
        icespike.setStatusEffect("FrozenBuff");
        icespike.setStatusDuration(1.5f);
        icespike.setHitboxSize(60, 180);
        icespike.setCost(5);
        skillList.add(iceball);


        // Skill 7: Ice Spikes
        CastingBuffSkill iceSpikes = new CastingBuffSkill("icespike");
        iceSpikes.setRootWhileCasting(true);
        iceSpikes.setBuffName("CastingBuff");
        iceSpikes.setInterval(0.5f);
        iceSpikes.setBuffDuration(3.0f);
        iceSpikes.setChildSkill(icespike);
        skillList.add(iceSpikes);

        // Skill 8: Swirling moon
        MeleeAttackSkill swirlingMoon = new MeleeAttackSkill("swirlingmoon");
        swirlingMoon.setRootWhileCasting(true);
        animFrames = (TextureAtlas) assetManager.getByName("swirlingmoon");
        swirlingMoon.setVfx(animFrames);
        swirlingMoon.setTime(0.6f);
        swirlingMoon.setAnimName("effect");
        swirlingMoon.setHitboxSize(350, 300);
        swirlingMoon.setHitboxOffset(-100, 0);
        swirlingMoon.setAnimation(new Animation(1 / 20.0f, animFrames.findRegions("effect")));
        swirlingMoon.setDamage(45);
        swirlingMoon.setDamageScaling(1.5f);
        swirlingMoon.setCost(25);
        swirlingMoon.setHitEffect("hit.0");
        swirlingMoon.setHitAnimation(new Animation(1 / 10.0f, animFrames.findRegions(swirlingMoon.getHitEffect())));
        skillList.add(swirlingMoon);

    }

    public static void initBuffs() {
        buffList = new ArrayList<Buff>();

        buffList.add(Pools.obtain(FrozenBuff.class));
    }
}

```

`core/src/com/jxz/notcontra/hud/HealthBar.java`:

```java
package com.jxz.notcontra.hud;

import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.jxz.notcontra.entity.ChildObject;
import com.jxz.notcontra.entity.Entity;
import com.jxz.notcontra.entity.LivingEntity;
import com.jxz.notcontra.menu.AbstractBars;

/**
 * Created by Kevin Xiao on 2015-04-26.
 */
public abstract class HealthBar extends AbstractBars implements ChildObject{

    protected LivingEntity parent;
    protected TextureAtlas hud_bars;
    protected float percentage;

    public HealthBar(LivingEntity le) {
        this.hud_bars = (TextureAtlas) assetHandler.getByName("hud_bars");
        this.parent = le;
        percentage = 1.0f;      // All monsters start at full health
    }

    public abstract void update();

    public abstract void draw(Batch batch);

    public void setPercentage(float percent) {
        this.percentage = percent;
    }

    public void setParent(Entity e) {
        if (e instanceof LivingEntity) {
            parent = (LivingEntity) e;
        }
    }

    public Entity getParent() {
        return parent;
    }

    public boolean isActive() {
        return (parent.getHealth() < parent.getMaxHealth());
    }

}

```

`core/src/com/jxz/notcontra/hud/OSHealthBar.java`:

```java
package com.jxz.notcontra.hud;

import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.math.Interpolation;
import com.jxz.notcontra.entity.LivingEntity;
import com.jxz.notcontra.game.Game;

/**
 * Created by Kevin Xiao on 2015-04-26.
 */
public class OSHealthBar extends HealthBar {

    public OSHealthBar(LivingEntity le) {
        super(le);
        bar = new Sprite(hud_bars.findRegion("oshp_bar"));
        frame = new Sprite(hud_bars.findRegion("oshp_frame"));
    }

    public void update() {
        this.position.x = parent.getTilePosition().x + (parent.getSprite().getWidth() - this.bar.getWidth()) * Game.UNIT_SCALE / 2;
        this.position.y = parent.getTilePosition().y + (parent.getSprite().getHeight() + this.bar.getHeight()) * Game.UNIT_SCALE;
        float currentHealth = ((float) parent.getHealth() / (float) parent.getMaxHealth());
        if (currentHealth < 0) {
            currentHealth = 0;
        }
        percentage = Interpolation.swingOut.apply(percentage, currentHealth, 0.03f);
    }

    public void draw(Batch batch) {
        // Draw frame
        batch.draw(this.frame,
                this.position.x,
                this.position.y,
                this.bar.getWidth() * Game.UNIT_SCALE,
                this.bar.getHeight() * Game.UNIT_SCALE);

        //Draw health bar
        batch.draw(bar.getTexture(),
                this.position.x,
                this.position.y,
                this.frame.getWidth() * percentage * Game.UNIT_SCALE,
                this.frame.getHeight() * Game.UNIT_SCALE,
                this.bar.getRegionX(),
                this.bar.getRegionY(),
                Math.round(this.bar.getRegionWidth() * percentage),
                this.bar.getRegionHeight(), false, false);
    }

}

```

`core/src/com/jxz/notcontra/hud/PlayerStatusBar.java`:

```java
package com.jxz.notcontra.hud;

import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.math.Interpolation;
import com.jxz.notcontra.entity.LivingEntity;
import com.jxz.notcontra.game.Game;

/**
 * Created by Kevin Xiao on 2015-04-26.
 */
public class PlayerStatusBar extends HealthBar {

    private float secondPercentage;
    private Sprite manabar;

    public PlayerStatusBar(LivingEntity le) {
        super(le);
        bar = new Sprite(hud_bars.findRegion("hud_hp_bar"));
        manabar = new Sprite(hud_bars.findRegion("hud_mp_bar"));
        frame = new Sprite(hud_bars.findRegion("hud_hp_frame"));
        this.position.x = Game.VID_WIDTH * 0.01f;
        this.position.y = Game.VID_HEIGHT * 0.01f;
        secondPercentage = 1.0f;
    }

    public void update() {
        percentage = Interpolation.swingOut.apply(percentage, ((float) parent.getHealth() / (float) parent.getMaxHealth()), 0.03f);
        secondPercentage = Interpolation.swingOut.apply(secondPercentage, ((float) parent.getMana() / (float) parent.getMaxMana()), 0.02f);
    }

    public void draw(Batch batch) {
        // Draw frame
        batch.draw(this.frame,
                this.position.x,
                this.position.y,
                this.frame.getWidth(),
                this.frame.getHeight());

        //Draw health bar
        batch.draw(bar.getTexture(),
                this.position.x + 4,
                this.position.y + 29,
                this.bar.getWidth() * percentage,
                this.bar.getHeight(),
                this.bar.getRegionX(),
                this.bar.getRegionY(),
                Math.round(this.bar.getRegionWidth() * percentage),
                this.bar.getRegionHeight(), false, false);

        //Draw secondary bar
        batch.draw(manabar.getTexture(),
                this.position.x + 4,
                this.position.y + 14,
                this.manabar.getWidth() * secondPercentage,
                this.manabar.getHeight(),
                this.manabar.getRegionX(),
                this.manabar.getRegionY(),
                Math.round(this.manabar.getRegionWidth() * secondPercentage),
                this.manabar.getRegionHeight(), false, false);
    }

}

```

`core/src/com/jxz/notcontra/menu/AbstractBars.java`:

```java
package com.jxz.notcontra.menu;

import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.math.Vector2;
import com.jxz.notcontra.handlers.AssetHandler;

/**
 * Created by Kevin Xiao on 2015-04-24.
 */
public abstract class AbstractBars {

    protected AssetHandler assetHandler;
    protected Sprite bar, frame;
    protected Animation animation;
    protected float animStateTime;
    protected TextureAtlas animFrames;
    protected Vector2 position;

    public AbstractBars() {
        assetHandler = AssetHandler.getInstance();
        position = new Vector2();
    }

    public abstract void update();

    public float getPositionX() {
        return position.x;
    }

    public float getPositionY() {
        return position.y;
    }

}

```

`core/src/com/jxz/notcontra/menu/AnimatedScrollPane.java`:

```java
package com.jxz.notcontra.menu;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.*;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.XmlReader;
import com.jxz.notcontra.menu.buttons.Button;
import com.jxz.notcontra.menu.buttons.SpriteButton;

/**
 * Created by Andrew on 2015-05-29.
 */
public class AnimatedScrollPane extends ScrollPane {

    protected Array<ScrollPaneSprite> sprites = new Array<ScrollPaneSprite>();

    protected String activeAnimName;
    protected float activeAnimDuration;
    protected String idleAnimName;
    protected float idleAnimDuration;
    protected float animStateTime = 0f;
    protected boolean playAnim = true;

    public AnimatedScrollPane(XmlReader.Element element) {
        // This special scroll pane is assumed to always be horizontal
        super(true, element.getInt("x"), element.getInt("y"));
        setWidth(element.getInt("width"));
        this.playAnim = element.getBoolean("playAnim");
        if (playAnim) {
            XmlReader.Element e = element.getChildByName("activeAnimName");
            this.activeAnimName = e.getText();
            this.activeAnimDuration = e.getFloat("duration");
            e = element.getChildByName("idleAnimName");
            this.idleAnimName = e.getText();
            this.idleAnimDuration = e.getFloat("duration");
        }
        this.parseSpriteElement(element.getChildrenByName("values"));
        setUpNavButtons();
    }

    protected void parseSpriteElement(Array<XmlReader.Element> values) {
        String prettyName;
        for (XmlReader.Element i : values) {
            prettyName = i.getAttribute("prettyName", i.getText());
            if (i.get("type").equalsIgnoreCase("Texture")) {
                sprites.add(new ScrollPaneSprite(i.getText(), prettyName, (Texture) assetHandler.getByName(i.getText() + "_image")));
            } else {
                sprites.add(new ScrollPaneSprite(i.getText(), prettyName, (TextureAtlas) assetHandler.getByName(i.getText())));
            }
        }
        index = (sprites.size - 1) / 2;
        update();
    }

    protected void update() {
        if (playAnim) {
            sprites.get(index).setCurrentAnimation(activeAnimDuration, activeAnimName);
            if (index - 1 >= 0) {
                sprites.get(index - 1).setCurrentAnimation(idleAnimDuration, idleAnimName);
            }
            if (index + 1 < sprites.size) {
                sprites.get(index + 1).setCurrentAnimation(idleAnimDuration, idleAnimName);
            }
        }
    }

    private class ScrollPaneSprite {
        private String name;
        private String prettyName;
        private TextureAtlas textureAtlas;
        private Texture texture;
        private Animation currentAnim;

        private ScrollPaneSprite(String name, String prettyName, TextureAtlas textureAtlas) {
            this.name = name;
            this.prettyName = prettyName;
            this.textureAtlas = textureAtlas;
        }

        private ScrollPaneSprite(String name, String prettyName, Texture texture) {
            this.name = name;
            this.prettyName = prettyName;
            this.texture = texture;
        }

        private String getName() {
            return name;
        }

        private String getPrettyName() {
            return prettyName != null ? prettyName : name;
        }

        private void setName(String name) {
            this.name = name;
        }

        private TextureAtlas getTextureAtlas() {
            return textureAtlas;
        }

        private void setTextureAtlas(TextureAtlas textureAtlas) {
            this.textureAtlas = textureAtlas;
        }

        private Texture getTexture() {
            return texture;
        }

        private Animation getCurrentAnimation() {
            return currentAnim;
        }

        private void setCurrentAnimation(float duration, String animName) {
            this.currentAnim = new Animation(duration, textureAtlas.findRegions(animName));
        }

        private TextureRegion getCurrentKeyframe() {
            return currentAnim.getKeyFrame(animStateTime, true);
        }
    }

    public void draw(SpriteBatch batch, BitmapFont font) {
        animStateTime += Gdx.graphics.getDeltaTime();
        if (playAnim) {
            batch.draw(sprites.get(index).getCurrentKeyframe(), x + width / 2 - sprites.get(index).getCurrentKeyframe().getRegionWidth() / 2, y);

            if (index - 1 >= 0) {
                batch.draw(sprites.get(index - 1).getCurrentKeyframe(), x + width / 4 - sprites.get(index - 1).getCurrentKeyframe().getRegionWidth() / 2, y);
            }
            if (index + 1 < sprites.size) {
                batch.draw(sprites.get(index + 1).getCurrentKeyframe(), x + width * 3 / 4 - sprites.get(index + 1).getCurrentKeyframe().getRegionWidth() / 2, y);
            }
        } else {
            batch.draw(sprites.get(index).getTexture(), x + width / 2 - sprites.get(index).getTexture().getWidth() / 2, y);

            if (index - 1 >= 0) {
                batch.draw(sprites.get(index - 1).getTexture(), x + width / 4 - sprites.get(index - 1).getTexture().getWidth() / 2, y);
            }
            if (index + 1 < sprites.size) {
                batch.draw(sprites.get(index + 1).getTexture(), x + width * 3 / 4 - sprites.get(index + 1).getTexture().getWidth() / 2, y);
            }
        }
        font.draw(batch, sprites.get(index).getPrettyName(), x + width / 2 - 15, y + 150);
    }

    @Override
    protected void setUpNavButtons() {
        navButtons[0] = new SpriteButton(menuButtons, "button_arrow_h", x, y);
        navButtons[0].flipSprites(true, false);
        navButtons[1] = new SpriteButton(menuButtons, "button_arrow_h", x + width - menuButtons.findRegion("button_arrow_h").getRegionWidth(), y);
        navButtons[0].setInputListener(new Button.InputListener() {
            @Override
            public void onClick() {
                if (index > 0) {
                    index -= 1;
                    update();
                }
            }

            @Override
            public void onHover() {

            }
        });

        navButtons[1].setInputListener(new Button.InputListener() {
            @Override
            public void onClick() {
                if (index < sprites.size - 1) {
                    index += 1;
                    update();
                }
            }

            @Override
            public void onHover() {

            }
        });
    }

    public String getCurrentCmd() {
        return sprites.get(index).getName();
    }
}

```

`core/src/com/jxz/notcontra/menu/GeneralSettingsMenu.java`:

```java
package com.jxz.notcontra.menu;

import com.badlogic.gdx.Audio;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.jxz.notcontra.handlers.AudioHelper;
import com.jxz.notcontra.handlers.GameStateManager;
import com.jxz.notcontra.menu.buttons.Button;
import com.jxz.notcontra.menu.buttons.SpriteButton;
import com.jxz.notcontra.menu.buttons.TextLabel;
import com.jxz.notcontra.menu.buttons.ToggleButton;
import com.jxz.notcontra.states.MenuState;
import com.jxz.notcontra.states.PlayState;

import java.util.ArrayList;

/**
 * Created by Andrew on 2015-06-04.
 */
public class GeneralSettingsMenu extends Menu {

    private final int TEXT_LABEL_HEIGHT = 40;
    private ArrayList<TextLabel> labels = new ArrayList<TextLabel>();
    private BitmapFont font = GameStateManager.getInstance().getCurrentState().getFont();

    public GeneralSettingsMenu() {
        x = 500;
        y = 400;
        height = 400;
        width = 400;
        fillTextLabels();
    }

    public void fillTextLabels() {
        int counter = 0;
        labels.add(new TextLabel(menuButtons, "button_savelabelbg", "Mute Background Music", font, x, y - TEXT_LABEL_HEIGHT * counter, TEXT_LABEL_HEIGHT, width));
        buttons.add(new ToggleButton(menuButtons, x + width - 50, y - TEXT_LABEL_HEIGHT * counter) {{
            setIsOn(AudioHelper.isMusicMuted());
            setInputListener(new InputListener() {
                @Override
                public void onClick() {
                    setIsOn(!getIsOn());
                    AudioHelper.muteMusic();
                }

                @Override
                public void onHover() {

                }
            });
        }});
        counter++;
        labels.add(new TextLabel(menuButtons, "button_savelabelbg", "Music volume adjustment", String.valueOf((int) (AudioHelper.getMusicVolume() * 100)), font, x, y - TEXT_LABEL_HEIGHT * counter, TEXT_LABEL_HEIGHT, width) {{
                        setSecondaryOffset(65, 10);
        }});
        SpriteButton decrease = new SpriteButton(menuButtons, "button_arrow_h", x + width - 100, y - TEXT_LABEL_HEIGHT * counter) {{
            flipSprites(true, false);
            setSize(0.4f);
            setInputListener(new InputListener() {
                @Override
                public void onClick() {
                    if (AudioHelper.isMusicMuted()) {
                        buttons.get(0).getInputListener().onClick();
                    }
                    float newVolume = Math.round(AudioHelper.getMusicVolume() * 100) - 10;
                    if (newVolume >= 0f) {
                        AudioHelper.setMusicVolume(newVolume / 100);
                        labels.get(1).setSecondaryText(String.valueOf((int) newVolume));
                    }
                }

                @Override
                public void onHover() {

                }
            });
        }};
        SpriteButton increase = new SpriteButton(menuButtons, "button_arrow_h", x + width - 28, y - TEXT_LABEL_HEIGHT * counter) {{
            setSize(0.4f);
            setInputListener(new InputListener() {
                @Override
                public void onClick() {
                    if (AudioHelper.isMusicMuted()) {
                        buttons.get(0).getInputListener().onClick();
                    }
                    float newVolume = Math.round(AudioHelper.getMusicVolume() * 100) + 10;
                    if (newVolume <= 100f) {
                        AudioHelper.setMusicVolume(newVolume / 100);
                        labels.get(1).setSecondaryText(String.valueOf((int) newVolume));
                    }
                }

                @Override
                public void onHover() {

                }
            });
        }};
        SpriteButton back = new SpriteButton(menuButtons, "button_back", 150, 100);
        back.setInputListener(new Button.InputListener() {
            @Override
            public void onClick() {
                AudioHelper.playSoundEffect("menu_hit");
                if (GameStateManager.getInstance().getCurrentState() instanceof MenuState) {
                    menuState.setCurrentMenu(GeneralSettingsMenu.this.prevMenu);
                } else if (GameStateManager.getInstance().getCurrentState() instanceof PlayState) {
                    PlayState playstate = GameStateManager.getInstance().getPlayState();
                    playstate.setIsPaused(false);
                    playstate.setCurrentMenu(playstate.getPauseMenu());
                }
            }

            @Override
            public void onHover() {
                AudioHelper.playSoundEffect("menu_hover");
            }
        });
        buttons.add(decrease);
        buttons.add(increase);
        buttons.add(back);
    }

    public void renderMenu(SpriteBatch batch, BitmapFont font) {
        for (TextLabel i : labels) {
            i.draw(batch);
        }
        super.renderMenu(batch, font);
    }
}

```

`core/src/com/jxz/notcontra/menu/HighScoreMenu.java`:

```java
package com.jxz.notcontra.menu;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.handlers.AssetHandler;
import com.jxz.notcontra.handlers.AudioHelper;
import com.jxz.notcontra.handlers.GameStateManager;
import com.jxz.notcontra.handlers.HighScoreHandler;
import com.jxz.notcontra.menu.buttons.Button;
import com.jxz.notcontra.menu.buttons.SpriteButton;
import com.jxz.notcontra.menu.buttons.TextLabel;
import com.jxz.notcontra.states.MenuState;
import com.jxz.notcontra.states.PlayState;

import java.util.ArrayList;

/**
 * Created by Andrew on 2015-06-03.
 */
public class HighScoreMenu extends Menu {

    private ArrayList<HighScoreHandler.HighScore> highScores = HighScoreHandler.getHighScores();
    private Sprite headerImage;

    private BitmapFont font = (BitmapFont) assetHandler.getByName("font_bandera");

    public HighScoreMenu() {
        x = 300;
        y = 400;
        height = 400;
        width = 850;
        setUpTextLabels();
        headerImage = new Sprite((Texture) AssetHandler.getInstance().getByName("highscore_header"));
        SpriteButton back = new SpriteButton(menuButtons, "button_back", 150, 75);
        back.setInputListener(new Button.InputListener() {
            @Override
            public void onClick() {
                AudioHelper.playSoundEffect("menu_hit");
                if (GameStateManager.getInstance().getCurrentState() instanceof MenuState) {
                    menuState.setCurrentMenu(HighScoreMenu.this.prevMenu);
                } else if (GameStateManager.getInstance().getCurrentState() instanceof PlayState) {
                    PlayState playstate = GameStateManager.getInstance().getPlayState();
                    playstate.setIsPaused(false);
                    playstate.setCurrentMenu(playstate.getPauseMenu());
                }
            }

            @Override
            public void onHover() {
                AudioHelper.playSoundEffect("menu_hover");
            }
        });
        buttons.add(back);
    }

    private void setUpTextLabels() {
        for (int i = 0; i < highScores.size(); i++) {
            TextLabel label = new TextLabel(menuButtons.createSprite("button_highscore_bg"), highScores.get(i).getName(),
                    String.valueOf(highScores.get(i).getScore()), font , x, y - i * height / 5, height / 5, width);
            int yOffset = menuButtons.createSprite("button_highscore_bg").getRegionHeight() / 5;
            label.setPrimaryOffset(20, yOffset);
            label.setSecondaryOffset(95, yOffset);
            buttons.add(label);
        }
    }

    public void renderMenu(SpriteBatch batch, BitmapFont font) {
        super.renderMenu(batch, font);
        batch.draw(headerImage, Game.VID_WIDTH / 2 - headerImage.getWidth() / 2, 500);
    }
}

```

`core/src/com/jxz/notcontra/menu/KeyLayoutMenu.java`:

```java
package com.jxz.notcontra.menu;

import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.jxz.notcontra.handlers.AudioHelper;
import com.jxz.notcontra.handlers.GameStateManager;
import com.jxz.notcontra.handlers.KeyLayoutHelper;
import com.jxz.notcontra.menu.buttons.Button;
import com.jxz.notcontra.menu.buttons.SpriteButton;
import com.jxz.notcontra.menu.buttons.TextLabel;
import com.jxz.notcontra.states.MenuState;
import com.jxz.notcontra.states.PlayState;

import java.util.ArrayList;

/**
 * Created by Andrew on 2015-06-03.
 */
public class KeyLayoutMenu extends Menu {
    ArrayList<TextLabel> textLabels = new ArrayList<TextLabel>();
    private final int TEXT_LABEL_HEIGHT = 30;
    private int index;
    private int counter;

    public KeyLayoutMenu() {
        x = 150;
        y = 600;
        width = 800;
        height = 500;
        createTextLabels();
        createClickableTextLabels();
        setUpGeneralButtons();
    }

    private void setUpGeneralButtons() {
        SpriteButton back = new SpriteButton(menuButtons, "button_back", 150, 100);
        SpriteButton reset = new SpriteButton(menuButtons, "button_reset", 975, 100);

        back.setInputListener(new Button.InputListener() {
            @Override
            public void onClick() {
                AudioHelper.playSoundEffect("menu_hit");
                if (GameStateManager.getInstance().getCurrentState() instanceof MenuState) {
                    menuState.setCurrentMenu(KeyLayoutMenu.this.prevMenu);
                } else if (GameStateManager.getInstance().getCurrentState() instanceof PlayState) {
                    PlayState playstate = GameStateManager.getInstance().getPlayState();
                    playstate.setIsPaused(false);
                    playstate.setCurrentMenu(playstate.getPauseMenu());
                }
            }

            @Override
            public void onHover() {
                AudioHelper.playSoundEffect("menu_hover");
            }
        });

        reset.setInputListener(new Button.InputListener() {
            @Override
            public void onClick() {
                AudioHelper.playSoundEffect("menu_hit");
                KeyLayoutHelper.resetToDefault();
                KeyLayoutMenu.this.refreshAllClickableLabels();
            }

            @Override
            public void onHover() {
                AudioHelper.playSoundEffect("menu_hover");
            }
        });
        buttons.add(back);
        buttons.add(reset);
    }

    private void refreshAllClickableLabels() {
        for (String text : KeyLayoutHelper.getKeyDisplayNameMap().values()) {
            if (buttons.get(counter) instanceof TextLabel) {
                ((TextLabel) buttons.get(counter++)).setPrimaryText(Input.Keys.toString(KeyLayoutHelper.getKey(text)));
            }
        }
        counter = 0;
    }

    private void createTextLabels() {
        for (String text : KeyLayoutHelper.getKeyDisplayNameMap().keys()) {
            TextLabel label = new TextLabel(menuButtons, "button_savelabelbg", text,
                    GameStateManager.getInstance().getCurrentState().getFont(),
                    x, y - TEXT_LABEL_HEIGHT * counter++, TEXT_LABEL_HEIGHT, width / 2);
            textLabels.add(label);
        }
        counter = 0;
    }

    private void createClickableTextLabels() {
        for (String text : KeyLayoutHelper.getKeyDisplayNameMap().values()) {
            final String key = text;
            final TextLabel label = new TextLabel(menuButtons, "button_savelabelbg", Input.Keys.toString(KeyLayoutHelper.getKey(text)),
                    GameStateManager.getInstance().getCurrentState().getFont(),
                    x + width / 2 + 5, y - TEXT_LABEL_HEIGHT * counter++, TEXT_LABEL_HEIGHT, width / 2);
            label.setInputListener(new Button.InputListener() {
                @Override
                public void onClick() {
                    KeyLayoutMenu.this.index = buttons.indexOf(label, true);
                    GameStateManager.getInstance().getGame().executeCommand("setKeyButton," + key);
                }

                @Override
                public void onHover() {

                }
            });
            buttons.add(label);
        }
        counter = 0;
    }

    public void keyChangeComplete(int keycode) {
        buttons.get(index).setState(Button.ButtonState.DEFAULT);
        if (keycode >= -1) {
            // Only update button text is keycode is valid.
            // Invalid keycodes are returned when key change has been cancelled.
            ((TextLabel) buttons.get(index)).setPrimaryText(Input.Keys.toString(keycode));
        }
    }

    @Override
    public void renderMenu(SpriteBatch batch, BitmapFont font) {
        for (TextLabel i : textLabels) {
            i.draw(batch);
        }
        super.renderMenu(batch, font);
    }
}

```

`core/src/com/jxz/notcontra/menu/LoadingBar.java`:

```java
package com.jxz.notcontra.menu;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.jxz.notcontra.game.Game;

/**
 * Created by Kevin Xiao on 2015-04-23.
 */
public class LoadingBar extends AbstractBars {

    public LoadingBar() {
        super();
        this.animFrames = (TextureAtlas) assetHandler.getByName("menu_loadingbar");
        this.animation = new Animation(0.05f, this.animFrames.findRegion("loadingbar"));
        animation.setPlayMode(Animation.PlayMode.LOOP_REVERSED);

        bar = new Sprite(animation.getKeyFrame(animStateTime, true));
        frame = new Sprite(this.animFrames.findRegion("loadingframe"));
        position.set(Game.VID_WIDTH / 2 - bar.getWidth() / 2, Game.VID_HEIGHT / 2 - bar.getHeight() / 2);
    }

    public Sprite getFrameSprite() {return frame;}
    public Sprite getBarSprite() {
        return bar;
    }

    public void update() {
        animStateTime += Gdx.graphics.getDeltaTime();
        bar.setRegion(animation.getKeyFrame(animStateTime, true));
    }



}

```

`core/src/com/jxz/notcontra/menu/Menu.java`:

```java
package com.jxz.notcontra.menu;

import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.utils.Array;
import com.jxz.notcontra.handlers.AssetHandler;
import com.jxz.notcontra.menu.buttons.Button;
import com.jxz.notcontra.states.MenuState;

/**
 * Created by Andrew on 2015-05-21.
 */
public abstract class Menu {
    protected AssetHandler assetHandler = AssetHandler.getInstance();
    protected Array<Button> buttons = new Array<Button>();
    protected ScrollPane pane;
    protected Menu prevMenu;
    protected MenuState menuState;
    protected FileHandle file;
    protected TextureAtlas menuButtons = (TextureAtlas) assetHandler.getByName("menu_buttons");
    protected String prevCmd;
    protected int x;
    protected int y;
    protected int height;
    protected int width;

    protected void addButton(String name, Button button) {
        buttons.add(button);
    }

    public Array<Button> getButtonList() {
        return buttons;
    }

    public Menu getPrevMenu() {
        return prevMenu;
    }

    public void setPrevMenu(ParseMenu prevMenu) {
        this.prevMenu = prevMenu;
    }

    public void setPrevCmd(String prevCmd) {
        this.prevCmd = prevCmd;
    }

    public String getPrevCmd() {
        return prevCmd;
    }

    public void setPane(ScrollPane pane) {
        this.pane = pane;
    }

    public ScrollPane getPane() {
        return pane;
    }

    public MenuState getMenuState() {
        return menuState;
    }
    public void setMenuState(MenuState menuState) {
        this.menuState = menuState;
    }

    public void renderMenu(SpriteBatch batch, BitmapFont font) {
        for (Button i : buttons) {
            i.draw(batch);
        }

        if (pane != null) {
            pane.draw(batch, font);
        }
    }
}

```

`core/src/com/jxz/notcontra/menu/ParseMenu.java`:

```java
package com.jxz.notcontra.menu;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.XmlReader;
import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.handlers.AudioHelper;
import com.jxz.notcontra.handlers.GameStateManager;
import com.jxz.notcontra.menu.buttons.Button;
import com.jxz.notcontra.menu.buttons.SpriteButton;
import com.jxz.notcontra.states.MenuState;
import com.jxz.notcontra.states.PlayState;

import java.io.IOException;

/**
 * Created by jiangyi on 09/05/15.
 */
public class ParseMenu extends Menu {

    public ParseMenu(String menuFile) {
        file = Gdx.files.internal("menus/" + menuFile);

        parseFromFile();
    }

    public void parseFromFile() {

        try {
            XmlReader.Element root = new XmlReader().parse(file);
            Array<XmlReader.Element> buttonElements = root.getChildrenByName("button");
            XmlReader.Element paneElement = root.getChildByName("scrollPane");
            if (paneElement != null) {
                if (paneElement.get("type").equalsIgnoreCase("animated")) {
                    pane = new AnimatedScrollPane(paneElement);
                } else if (paneElement.get("type").equalsIgnoreCase("save")) {
                    SaveLoadScrollPane pane = new SaveLoadScrollPane(paneElement, GameStateManager.getInstance().getCurrentState().getFont());
                    buttons.addAll(pane.getList());
                    this.pane = pane;
                }
                buttons.addAll(pane.getNavButtons());
            }

            String name, atlasRegion;

            // Iterate through all buttons
            for (XmlReader.Element i : buttonElements) {
                name = i.getChildByName("name").getText();
                atlasRegion = i.getChildByName("textureName").getText();
                // TODO: Add more name variables than just centre
                if (i.get("x").equalsIgnoreCase("centre")) {
                    x = Game.VID_WIDTH / 2 - menuButtons.findRegion(atlasRegion).getRegionWidth() / 2;
                } else if (i.get("x").equalsIgnoreCase("centre-left")) {
                    x = Game.VID_WIDTH / 4 - menuButtons.findRegion(atlasRegion).getRegionWidth() / 2;
                } else if (i.get("x").equalsIgnoreCase("centre-right")) {
                    x = Game.VID_WIDTH * 3 / 4 - menuButtons.findRegion(atlasRegion).getRegionWidth() / 2;
                } else {
                    // It's going to be a float otherwise
                    x = i.getInt("x");
                }
                y = i.getInt("y");

                // Initialize button
                final SpriteButton button = new SpriteButton(menuButtons, atlasRegion, x, y);
                System.out.println("Name: " + name + " X: " + x + " Y: " + y);
                // Check for inputListener parameters
                final XmlReader.Element onClick = i.getChildByName("onClick");
                final String onClickType = onClick.get("type");

                if (!onClickType.equalsIgnoreCase("null")) {
                    Button.InputListener listener = new Button.InputListener() {
                        @Override
                        public void onClick() {
                            AudioHelper.playSoundEffect("menu_hit");
                            if (onClickType.equalsIgnoreCase("setMenu")) {
                                if (onClick.getText().equalsIgnoreCase("Previous")) {
                                    if (GameStateManager.getInstance().getCurrentState() instanceof MenuState) {
                                        menuState.setCurrentMenu(ParseMenu.this.getPrevMenu());
                                    } else if (GameStateManager.getInstance().getCurrentState() instanceof PlayState) {
                                        GameStateManager.getInstance().getPlayState().setCurrentMenu(ParseMenu.this.getPrevMenu());
                                    }
                                } else if (onClick.getText().equalsIgnoreCase("MainMenu")) {
                                    GameStateManager gsm = GameStateManager.getInstance();
                                    gsm.getMenuState().setCurrentMenu(gsm.getMenuState().getRootMenu());
                                    gsm.setState(GameStateManager.State.MENU);
                                    gsm.getPlayState().dispose();
                                    gsm.resetGameState(GameStateManager.State.PLAY);
                                } else {
                                    ParseMenu menu = new ParseMenu(onClick.getText() + ".xml");
                                    menu.setPrevMenu(ParseMenu.this);
                                    String cmd = onClick.get("prevCmd", null);
                                    if (cmd != null) {
                                        if (cmd.equalsIgnoreCase("getScrollPaneParam")) {
                                            menu.setPrevCmd(prevCmd + "," + pane.getCurrentCmd());
                                        } else if (prevCmd != null) {
                                            menu.setPrevCmd(prevCmd + "," + cmd);
                                        } else {
                                            menu.setPrevCmd(cmd);
                                        }
                                    } else if (prevCmd != null) {
                                        menu.setPrevCmd(prevCmd);
                                    }
                                    menu.setMenuState(menuState);
                                    if (GameStateManager.getInstance().getCurrentState() instanceof MenuState) {
                                        menuState.setCurrentMenu(menu);
                                    } else if (GameStateManager.getInstance().getCurrentState() instanceof PlayState) {
                                        GameStateManager.getInstance().getPlayState().setCurrentMenu(menu);
                                    }
                                }
                            } else if (onClickType.equalsIgnoreCase("setMenuInternal")) {
                                Menu menu;
                                try {
                                    menu = (Menu) Class.forName("com.jxz.notcontra.menu." + onClick.getText()).newInstance();
                                    menu.setMenuState(menuState);
                                    menu.setPrevMenu(ParseMenu.this);
                                    if (GameStateManager.getInstance().getCurrentState() instanceof MenuState) {
                                        menuState.setCurrentMenu(menu);
                                    } else if (GameStateManager.getInstance().getCurrentState() instanceof PlayState) {
                                        GameStateManager.getInstance().getPlayState().setCurrentMenu(menu);
                                    }
                                } catch (Exception e) {
                                    e.printStackTrace();
                                }
                            } else if (onClickType.equalsIgnoreCase("cmd")) {
                                GameStateManager.getInstance().getGame().executeCommand(onClick.getText());
                            } else if (onClickType.equalsIgnoreCase("getScrollPaneParam")) {
                                if (pane != null) {
                                    String cmd = "";
                                    if (pane.getCurrentCmd() != null) {
                                        if (prevCmd != null) {
                                            cmd = prevCmd + "," + pane.getCurrentCmd();
                                        } else if (onClick.getText() != null) {
                                            cmd = onClick.getText() + "," + pane.getCurrentCmd();
                                        }
                                    }
                                    GameStateManager.getInstance().getGame().executeCommand(cmd);
                                }
                            }
                        }

                        @Override
                        public void onHover() {
                            AudioHelper.playSoundEffect("menu_hover");
                        }
                    };
                    button.setInputListener(listener);
                }
                buttons.add(button);

            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```

`core/src/com/jxz/notcontra/menu/SaveLoadScrollPane.java`:

```java
package com.jxz.notcontra.menu;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.XmlReader;
import com.jxz.notcontra.menu.buttons.Button;
import com.jxz.notcontra.menu.buttons.SpriteButton;
import com.jxz.notcontra.menu.buttons.TextLabel;

import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * Created by Andrew on 2015-05-30.
 */
public class SaveLoadScrollPane extends ScrollPane {

    protected Array<TextLabel> list = new Array<TextLabel>();
    protected static final int TEXT_LABEL_HEIGHT = 30;
    protected int NumDisplayed;
    protected int navButtonOffset;
    protected String directory;
    protected BitmapFont font;

    public SaveLoadScrollPane(XmlReader.Element element, BitmapFont font) {
        super(true, element.getInt("x"), element.getInt("y"), element.getInt("height"), element.getInt("width"));
        navButtonOffset = menuButtons.findRegion("button_arrow_v").getRegionWidth();
        this.directory = element.getChildByName("directory").getText();
        this.font = font;
        TextLabel label = new TextLabel(menuButtons, "button_savelabelbg", "File", "Date Modified", font, x, y, TEXT_LABEL_HEIGHT, width - navButtonOffset);
        setLabelOffset(label);
        list.add(label);
        parseDirectory();
    }

    private void setLabelOffset(TextLabel label) {
        label.setPrimaryOffset(45, 5);
        label.setSecondaryOffset(300, 5);
    }

    protected void parseDirectory() {
        FileHandle dirHandle = Gdx.files.internal(directory);
        if (dirHandle.list().length == 0) {
            final TextLabel textLabel =  new TextLabel(menuButtons, "button_savelabelbg", "No saves found!",
                    font, x, y - TEXT_LABEL_HEIGHT, TEXT_LABEL_HEIGHT, width - navButtonOffset);
            setLabelOffset(textLabel);
            list.add(textLabel);
        } else {
            int counter = 0;
            for (FileHandle file : dirHandle.list()) {

                Date date = new Date(file.lastModified());
                SimpleDateFormat dateFormat = new SimpleDateFormat("MMM dd, yyyy HH:mm");
                final TextLabel textLabel = new TextLabel(menuButtons, "button_savelabelbg", file.name(), dateFormat.format(date),
                        font, x, y - TEXT_LABEL_HEIGHT * (counter++ + 1), TEXT_LABEL_HEIGHT, width - navButtonOffset);
                textLabel.setPrimaryOffset(45, 5);
                textLabel.setSecondaryOffset(300, 5);
                textLabel.setInputListener(new Button.InputListener() {
                    @Override
                    public void onClick() {
                        int index = SaveLoadScrollPane.this.list.indexOf(textLabel, true);
                        if (SaveLoadScrollPane.this.index != index) {
                            SaveLoadScrollPane.this.list.get(SaveLoadScrollPane.this.index).setState(Button.ButtonState.DEFAULT);
                            SaveLoadScrollPane.this.index = index;
                        }
                    }

                    @Override
                    public void onHover() {

                    }
                });

                list.add(textLabel);
            }
        }
        index = 1;
        update();
    }

    @Override
    protected void setUpNavButtons() {
        navButtons[0] = new SpriteButton(menuButtons, "button_arrow_v", x + width - navButtonOffset, y);
        navButtons[1] = new SpriteButton(menuButtons, "button_arrow_v", x + width - navButtonOffset, y - height);
        navButtons[1].flipSprites(false, true);
        navButtons[0].setInputListener(new Button.InputListener() {
            @Override
            public void onClick() {
                if (index > 1) {
                    list.get(index).setState(Button.ButtonState.DEFAULT);
                    index -= 1;
                    update();
                }
            }

            @Override
            public void onHover() {

            }
        });

        navButtons[1].setInputListener(new Button.InputListener() {
            @Override
            public void onClick() {
                if (index < list.size - 1) {
                    list.get(index).setState(Button.ButtonState.DEFAULT);
                    index += 1;
                    update();
                }
            }

            @Override
            public void onHover() {

            }
        });
    }

    @Override
    public String getCurrentCmd() {
        String out = list.get(index).getPrimaryText();
        if (out.equalsIgnoreCase("No saves found!")) {
            return null;
        } else {
            return out;
        }
    }

    @Override
    protected void update() {
        list.get(index).setState(Button.ButtonState.CLICK);
    }

    public Array<TextLabel> getList() {
        return list;
    }

    @Override
    protected void draw(SpriteBatch batch, BitmapFont font) {

    }
}

```

`core/src/com/jxz/notcontra/menu/ScreenshotFactory.java`:

```java
package com.jxz.notcontra.menu;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.PixmapIO;
import com.badlogic.gdx.utils.ScreenUtils;

import java.nio.ByteBuffer;

/**
 * Created by Kevin Xiao on 2015-04-27.
 */
public class ScreenshotFactory {

    private static int counter = 1;
    public static void saveScreenshot(){
        try{
            FileHandle fh;
            do{
                fh = new FileHandle("screenshot" + counter++ + ".png");
            }while (fh.exists());
            Pixmap pixmap = getScreenshot(0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), false);
            PixmapIO.writePNG(fh, pixmap);
            pixmap.dispose();
        }catch (Exception e){
        }
    }

    public static Pixmap getScreenshot(int x, int y, int w, int h, boolean yDown){
        final Pixmap pixmap = ScreenUtils.getFrameBufferPixmap(x, y, w, h);

        if (yDown) {
            // Flip the pixmap upside down
            ByteBuffer pixels = pixmap.getPixels();
            int numBytes = w * h * 4;
            byte[] lines = new byte[numBytes];
            int numBytesPerLine = w * 4;
            for (int i = 0; i < h; i++) {
                pixels.position((h - i - 1) * numBytesPerLine);
                pixels.get(lines, i * numBytesPerLine, numBytesPerLine);
            }
            pixels.clear();
            pixels.put(lines);
        }

        return pixmap;
    }
}
```

`core/src/com/jxz/notcontra/menu/ScrollPane.java`:

```java
package com.jxz.notcontra.menu;

import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.jxz.notcontra.handlers.AssetHandler;
import com.jxz.notcontra.menu.buttons.SpriteButton;
/**
 * Created by Andrew on 2015-05-30.
 */
public abstract class ScrollPane {

    protected AssetHandler assetHandler = AssetHandler.getInstance();
    protected SpriteButton[] navButtons = new SpriteButton[2];
    protected int index;
    protected int x, y;
    protected int height, width;
    protected boolean horizontal;

    protected TextureAtlas menuButtons = (TextureAtlas) assetHandler.getByName("menu_buttons");

    protected ScrollPane(boolean horizontal, int x, int y) {
        this.horizontal = horizontal;
        this.x = x;
        this.y = y;
    }
    protected ScrollPane(boolean horizontal, int x, int y, int height, int width) {
        this(horizontal, x, y);
        this.height = height;
        this.width = width;
        setUpNavButtons();
    }

    public abstract String getCurrentCmd();

    protected abstract void setUpNavButtons();

    public int getWidth() {
        return width;
    }

    public void setWidth(int width) {
        this.width = width;
    }

    public int getHeight() {
        return height;
    }

    public void setHeight(int height) {
        this.height = height;
    }

    public SpriteButton[] getNavButtons() {
        return navButtons;
    }

    protected abstract void update();

    protected abstract void draw(SpriteBatch batch, BitmapFont font);
}

```

`core/src/com/jxz/notcontra/menu/buttons/Button.java`:

```java
package com.jxz.notcontra.menu.buttons;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.utils.viewport.Viewport;
import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.handlers.GameStateManager;

/**
 * Created by Samuel on 2015-05-08.
 */
public abstract class Button {

    public enum ButtonState {
        HOVER, CLICK, DEFAULT;
    }

    protected String name;
    protected ButtonState currentState;
    protected InputListener inputListener;
    protected int x, y;
    protected float height;
    protected float width;

    protected Viewport viewport = GameStateManager.getInstance().getGame().getViewport();
    public abstract void draw(Batch batch);

    public interface InputListener {
        public void onClick();

        public void onHover();
    }

    public void setInputListener(InputListener inputListener) {
        this.inputListener = inputListener;
    }

    public InputListener getInputListener() {
        return inputListener;
    }

    public boolean isMouseWithinBoundary(int x, int y) {
        float newY = (Gdx.graphics.getHeight() - y - viewport.getTopGutterHeight()) * (float) Game.VID_HEIGHT / ((float) Gdx.graphics.getHeight() - viewport.getTopGutterHeight() - viewport.getBottomGutterHeight());
        float newX = (x - viewport.getLeftGutterWidth()) * (float) Game.VID_WIDTH / ((float) Gdx.graphics.getWidth() - viewport.getLeftGutterWidth() - viewport.getRightGutterWidth());
//        System.out.println((float)Gdx.graphics.getWidth() / (float)Game.VID_WIDTH);
//        System.out.println("\nX bounds: " + position.x * (float)Gdx.graphics.getWidth() / (float)Game.VID_WIDTH + " - " + (position.x + width) * (float)Gdx.graphics.getWidth() / (float)Game.VID_WIDTH);
//        System.out.println("Y bounds: " + position.y + " - " + (position.y + width));
        // LibGDX goes from top to bottom for y for input management,
        // but bottom to top for y for rendering. Whut.
        return (this.x < newX && newX < (this.x + width) &&
                this.y < newY && newY < (this.y + height));
    }

    public void setState(ButtonState state) {
        currentState = state;
    }

    public ButtonState getCurrentState() {
        return currentState;
    }
}

```

`core/src/com/jxz/notcontra/menu/buttons/SpriteButton.java`:

```java
package com.jxz.notcontra.menu.buttons;

import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;

/**
 * Created by jiangyi on 09/05/15.
 */
public class SpriteButton extends Button {

    protected Sprite onHoverSprite;
    protected Sprite onClickSprite;
    protected Sprite defaultSprite;
    protected boolean isFlipped;

    // Define a non-changing, default sprite button only
    public SpriteButton(TextureAtlas buttonSprites, String atlasRegion, int x, int y) {
        this(buttonSprites.createSprite(atlasRegion, 0), buttonSprites.createSprite(atlasRegion, 1), buttonSprites.createSprite(atlasRegion, 2), x, y);
    }

    public SpriteButton(Sprite defaultRegion, int x, int y) {
        this.currentState = ButtonState.DEFAULT;
        this.x = x;
        this.y = y;
        this.defaultSprite = defaultRegion;
        this.height = defaultSprite.getRegionHeight();
        this.width = defaultSprite.getRegionWidth();
    }
    // Define a button with sprites for all modes
    public SpriteButton(Sprite defaultRegion, Sprite onHoverRegion, Sprite onClickRegion, int x, int y) {
        this(defaultRegion, x, y);
        this.onHoverSprite = onHoverRegion;
        this.onClickSprite = onClickRegion;
    }

    public void setIsFlipped(boolean isFlipped) {
        this.isFlipped = isFlipped;
    }

    public boolean getIsFlipped() {
        return isFlipped;
    }

    public void flipSprites(boolean x, boolean y) {
        defaultSprite.flip(x, y);
        onHoverSprite.flip(x, y);
        onClickSprite.flip(x, y);
    }

    public void setDefaultSprite(Sprite defaultSprite) {
        this.defaultSprite = new Sprite(defaultSprite);
    }

    public void setOnClickSprite(Sprite onClickSprite) {
        this.onClickSprite = new Sprite(onClickSprite);
    }

    public void setOnHoverSprite(Sprite onHoverSprite) {
        this.onHoverSprite = new Sprite(onHoverSprite);
    }

    public Sprite getDefaultSprite() {
        return defaultSprite;
    }

    public Sprite getOnHoverSprite() {
        return onHoverSprite;
    }

    public Sprite getOnClickSprite() {
        return onClickSprite;
    }

    public void setHeight(float height) {
        this.height = height;
    }

    public float getHeight() {
        return height;
    }

    public void setWidth(float width) {
        this.width = width;
    }

    public float getWidth() {
        return width;
    }

    public void setSize(float scale) {
        height *= scale;
        width *= scale;
    }

    @Override
    public void draw(Batch batch) {
        batch.draw(getCurrentStateSprite(), x, y, width, height);
    }

    protected Sprite getCurrentStateSprite() {
       switch (currentState) {
           case CLICK:
               return onClickSprite;
           case HOVER:
               return onHoverSprite;
           default:
               return defaultSprite;
       }
    }


}

```

`core/src/com/jxz/notcontra/menu/buttons/TextLabel.java`:

```java
package com.jxz.notcontra.menu.buttons;

import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;

/**
 * Created by Andrew on 2015-05-30.
 */
public class TextLabel extends SpriteButton {

    protected String primaryText;
    protected String secondaryText;
    protected BitmapFont font;
    protected boolean drawBg = true;
    protected int primaryOffsetX = 5, primaryOffsetY = 5;
    protected int secondaryOffsetX = 30, secondaryOffsetY = 5;

    public TextLabel(TextureAtlas buttonSprites, String spriteRegion, String text, BitmapFont font, int x, int y, int height, int width) {
        super(buttonSprites, spriteRegion, x, y);
        this.primaryText = text;
        this.font = font;
        this.height = height;
        this.width = width;
    }

    public TextLabel(Sprite defaultBgSprite, String text, BitmapFont font, int x, int y, int height, int width) {
        super(defaultBgSprite, x, y);
        this.primaryText = text;
        this.font = font;
        this.height = height;
        this.width = width;
    }

    public TextLabel(Sprite defaultBgSprite, String primaryText, String secondaryText, BitmapFont font, int x, int y, int height, int width) {
        this(defaultBgSprite, primaryText, font, x, y, height, width);
        this.secondaryText = secondaryText;
    }

    public TextLabel(TextureAtlas buttonSprites, String spriteRegion, String primaryText, String secondaryText, BitmapFont font, int x, int y, int height, int width) {
        this(buttonSprites, spriteRegion, primaryText, font, x, y, height, width);
        this.secondaryText = secondaryText;
    }

    public void setPosition(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public void draw(Batch batch) {
        if (drawBg) {
            batch.draw(getCurrentStateSprite(), x, y, width, height);
        }
        font.draw(batch, primaryText, x + primaryOffsetX, y + height - primaryOffsetY);
        if (secondaryText != null) {
            font.draw(batch, secondaryText, x + width - secondaryOffsetX, y + height - secondaryOffsetY);
        }
    }

    public String getPrimaryText() {
        return primaryText;
    }

    public void setPrimaryText(String primaryText) {
        this.primaryText = primaryText;
    }

    public String getSecondaryText() {
        return secondaryText;
    }

    public void setSecondaryText(String secondaryText) {
        this.secondaryText = secondaryText;
    }

    public void setPrimaryOffset(int offsetX, int offsetY) {
        this.primaryOffsetX = offsetX;
        this.primaryOffsetY = offsetY;
    }

    public void setSecondaryOffset(int offsetX, int offsetY) {
        this.secondaryOffsetX = offsetX;
        this.secondaryOffsetY = offsetY;
    }

    public void setDrawBg(boolean drawBg) {
        this.drawBg = drawBg;
    }

    public boolean getDrawBg() {
        return drawBg;
    }
}

```

`core/src/com/jxz/notcontra/menu/buttons/ToggleButton.java`:

```java
package com.jxz.notcontra.menu.buttons;

import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;

/**
 * Created by Andrew on 2015-06-04.
 */
public class ToggleButton extends Button {

    private Sprite offSprite;
    private Sprite onSprite;
    private boolean isOn;

    public ToggleButton(TextureAtlas buttonSprites, int x, int y) {
        this(buttonSprites.createSprite("button_check", 0), buttonSprites.createSprite("button_check", 1), x, y);
    }


    public ToggleButton(Sprite offSprite, Sprite onSprite, int x, int y) {
        this.offSprite = offSprite;
        this.onSprite = onSprite;
        this.x = x;
        this.y = y;
        this.height = offSprite.getRegionHeight();
        this.width = offSprite.getRegionWidth();
    }

    public void setIsOn(boolean on) {
        isOn = on;
    }

    public boolean getIsOn() {
        return isOn;
    }

    @Override
    public void draw(Batch batch) {
        batch.draw(isOn ? onSprite : offSprite, x, y);
    }
}

```

`core/src/com/jxz/notcontra/particles/DamageNumber.java`:

```java
package com.jxz.notcontra.particles;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.utils.Pools;
import com.jxz.notcontra.entity.LivingEntity;
import com.jxz.notcontra.game.Game;

/**
 * Created by Kevin Xiao on 2015-05-25.
 */
public class DamageNumber extends Particle {

    private Sprite[] columnNumber;
    private String hitTextureName;
    private float offset;

    private final float BEGIN_FADE_TIME = 0.3f;
    private final float END_FADE_TIME = 1.5f;

    public DamageNumber() {
        super();
        this.columnNumber = new Sprite[0];
        this.offset = 0;
    }

    public void init(String hitTextureString, float dmg, LivingEntity parent) {
        this.reset();
        this.hitTextureName = hitTextureString;
        this.texturePack = (TextureAtlas) assetHandler.getByName(this.hitTextureName);

        stateTime = 0;
        String str = Integer.toString((int)dmg);
        if (dmg > 0) {
            isActive = true;
            columnNumber = new Sprite[str.length()];

            // Set up damage number sprites
            columnNumber[0] = new Sprite(texturePack.findRegion(hitTextureName, (Character.getNumericValue(str.charAt(0)) + 10)));
            for (int i = 1; i < str.length(); i++) {
                columnNumber[i] = new Sprite(texturePack.findRegion(hitTextureName, Character.getNumericValue(str.charAt(i))));
            }
        }

        // Set up position of particle
        this.position.x = parent.getTilePosition().x + (parent.getSprite().getWidth() - (columnNumber.length * this.columnNumber[0].getWidth())) * Game.UNIT_SCALE / 2;
        this.position.y = parent.getTilePosition().y + (parent.getSprite().getHeight() + this.columnNumber[0].getHeight()) * Game.UNIT_SCALE;
    }

    public void update() {
        if (isActive) {
            stateTime += Gdx.graphics.getDeltaTime();

            if (stateTime >= BEGIN_FADE_TIME) {
                position.y += 1.5f * Gdx.graphics.getDeltaTime();
            }
            // Stop displaying damage after a certain time
            if (stateTime >= END_FADE_TIME) {
                this.reset();
                Pools.free(this);
            }
        }
    }

    public void draw(Batch batch) {
        // Draw damage numbers
        if (stateTime >= BEGIN_FADE_TIME) {
            batch.setColor(1f, 1f, 1f, (END_FADE_TIME - stateTime) / (END_FADE_TIME - BEGIN_FADE_TIME));
        } else {
            batch.setColor(1f, 1f, 1f, 1f);
        }
        for (int i = 0; i < columnNumber.length; i++) {
            batch.draw(columnNumber[i],
                    position.x + offset,
                    position.y,
                    columnNumber[i].getWidth() * Game.UNIT_SCALE,
                    columnNumber[i].getHeight() * Game.UNIT_SCALE);
            offset += columnNumber[i].getWidth() * Game.UNIT_SCALE - columnNumber[i].getWidth() * Game.UNIT_SCALE / 4;
        }
        offset = 0;
        batch.setColor(1f, 1f, 1f, 1f);
    }


    public void reset() {
        isActive = false;
        stateTime = 0;
        columnNumber = new Sprite[0];
        offset = 0;
    }

    public boolean isActive() {
        return isActive;
    }

}

```

`core/src/com/jxz/notcontra/particles/Particle.java`:

```java
package com.jxz.notcontra.particles;

import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Pool;
import com.jxz.notcontra.handlers.AssetHandler;
import com.jxz.notcontra.handlers.ParticleManager;

/**
 * Created by Kevin Xiao on 2015-05-31.
 */

public abstract class Particle implements Pool.Poolable {

    protected ParticleManager manager = ParticleManager.getInstance();
    protected boolean isActive;
    protected AssetHandler assetHandler = AssetHandler.getInstance();
    protected TextureAtlas texturePack;
    protected Vector2 position;
    protected float stateTime;

    public Particle() {
        this.isActive = false;
        this.stateTime = 0;
        this.position = new Vector2();
        manager.register(this);
    }

    public void setPosition(float x, float y) {
        this.position.x = x;
        this.position.y = y;
    }

    public abstract void update();

    public abstract void draw(Batch batch);

    public boolean isVisible() {
        return isActive;
    }
}

```

`core/src/com/jxz/notcontra/particles/ParticleFactory.java`:

```java
package com.jxz.notcontra.particles;

import com.badlogic.gdx.utils.Pools;

/**
 * Created by Kevin Xiao on 2015-05-31.
 */
public class ParticleFactory {

    // Spawn method
    public static Particle spawn(Class type) {
        return (Particle) Pools.obtain(type);
    }

    // Overloaded spawn method - contains coordinates
    public static Particle spawn(Class type, float x, float y) {
        Particle p = spawn(type);
        p.setPosition(x, y);
        return p;
    }

    // Frees the object from the pool
    public static void free(Object o) {
        Pools.free(o);
    }

}


```

`core/src/com/jxz/notcontra/shaders/Shaders.java`:

```java
package com.jxz.notcontra.shaders;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.glutils.ShaderProgram;


/**
 * Created by Kevin Xiao on 2015-04-27.
 */

public class Shaders {

    public enum ShaderType {
        PASSTHROUGH, VIGNETTE
    }

    private ShaderProgram currentShader;
    private ShaderProgram[] shaderArray = new ShaderProgram[2];

    public Shaders(int width, int height) {
        shaderArray[0] = new ShaderProgram(Gdx.files.internal("shaders/passthrough.vsh"), Gdx.files.internal("shaders/passthrough.fsh"));
        shaderArray[1] = new ShaderProgram(Gdx.files.internal("shaders/vignette.vsh"), Gdx.files.internal("shaders/vignette.fsh"));
        currentShader = shaderArray[0];
        bindShaders(width, height);
    }

    public ShaderProgram getShaderType(ShaderType type) {
        if (type == ShaderType.PASSTHROUGH) {
            currentShader = shaderArray[0];
        } else if (type == ShaderType.VIGNETTE) {
            currentShader = shaderArray[1];
        } else {
            currentShader = null;
        }
        return currentShader;
    }

    public void bindShaders(int width, int height) {
        for (ShaderProgram i : shaderArray) {
            i.begin();
            i.setUniformf("u_resolution", width, height);
        }
    }

    public void unbindShaders() {
        for (ShaderProgram i : shaderArray) {
            i.end();
        }
    }
}
```

`core/src/com/jxz/notcontra/skill/BuffSkill.java`:

```java
package com.jxz.notcontra.skill;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Pools;
import com.jxz.notcontra.effect.SpriteEffect;
import com.jxz.notcontra.entity.LivingEntity;
import com.jxz.notcontra.handlers.SkillManager;

/**
 * Created by Samuel on 03/06/2015.
 * Skill that applies a self buff. Pretty self explanatory.
 */
public class BuffSkill extends Skill {

    protected String buffName;
    protected float buffDuration;

    public BuffSkill(String name) {
        super(name);
        requiresCastPriority = false;
        cooldown = 0;
    }

    @Override
    public void use(LivingEntity caster) {
        SkillManager.applyBuff(buffName, caster, buffDuration);
    }

    @Override
    public void use(LivingEntity caster, Vector2 initial) {
        use(caster);
    }

    @Override
    public void preCast(LivingEntity caster) {
        // There is no precast for giving buffs, except for cast effects
        // Spawn cast effect if there is one
        if (hasCastEffect) {
            castEffect = Pools.obtain(SpriteEffect.class);
            castEffect.init();
            castEffect.setParent(caster);
            caster.addChild(castEffect);
            castEffect.setSprite(vfx.createSprite(castName));
            castEffect.setAnimation(castAnimation);
            castEffect.setDirection(Vector2.Zero);
        }
    }

    public void setBuffName(String buffName) {
        this.buffName = buffName;
    }

    public void setBuffDuration(float buffDuration) {
        this.buffDuration = buffDuration;
    }
}

```

`core/src/com/jxz/notcontra/skill/CastingBuffSkill.java`:

```java
package com.jxz.notcontra.skill;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Pools;
import com.jxz.notcontra.buff.CastingBuff;
import com.jxz.notcontra.entity.LivingEntity;
import com.jxz.notcontra.handlers.SkillManager;

/**
 * Created by Samuel on 03/06/2015.
 * Special type of buff skill that prepares to cast spells.
 */
public class CastingBuffSkill extends BuffSkill {
    protected Skill childSkill;
    protected float interval;

    public CastingBuffSkill(String name) {
        super(name);
    }

    @Override
    public void use(LivingEntity caster) {
        CastingBuff buff = Pools.obtain(CastingBuff.class);
        buff.setSkill(childSkill);
        buff.setInterval(interval);
        SkillManager.applyBuff(buff, caster, buffDuration);
    }

    @Override
    public void use(LivingEntity caster, Vector2 initial) {
        use(caster);
    }

    public void setChildSkill(Skill childSkill) {
        this.childSkill = childSkill;
    }

    public void setInterval(float interval) {
        this.interval = interval;
    }
}

```

`core/src/com/jxz/notcontra/skill/ExplosionSkill.java`:

```java
package com.jxz.notcontra.skill;

import com.badlogic.gdx.math.Vector2;
import com.jxz.notcontra.animation.SpriteEx;
import com.jxz.notcontra.entity.EntityFactory;
import com.jxz.notcontra.entity.LivingEntity;
import com.jxz.notcontra.entity.Projectile;

/**
 * Created by Samuel on 2015-06-04.
 * Creates a new explosion with given center and radius.
 */
public class ExplosionSkill extends Skill {
    protected float radius;
    protected Projectile hitbox;
    protected Vector2 centerPosition;

    public ExplosionSkill(String name) {
        super(name);
    }

    @Override
    public void use(LivingEntity caster) {
        this.caster = caster;
        hitbox = (Projectile) EntityFactory.spawn(Projectile.class);
        hitbox.setSprite(new SpriteEx(vfx.createSprite(animName)));
        hitbox.getSprite().setOriginCenter();

        // Initialize hitbox variables
        hitbox.init(this, caster, centerPosition.x, centerPosition.y);
        hitbox.setDirection(0, 0);
        hitbox.setAnimTravel(animation);
        hitbox.setTime(animation.getAnimationDuration() - animation.getFrameDuration());
        hitbox.setSize(hitboxSize.x, hitboxSize.y);
        hitbox.setExplosionRadius(0);
    }

    public void use(LivingEntity caster, Vector2 initial) {
        centerPosition = initial;
        use(caster);
    }


    @Override
    public void preCast(LivingEntity caster) {
        // None.
    }

    public void setCenterPosition(Vector2 centerPosition) {
        this.centerPosition = centerPosition;
    }

    public void setRadius(float radius) {
        this.radius = radius;
    }
}

```

`core/src/com/jxz/notcontra/skill/ForceBuffSkill.java`:

```java
package com.jxz.notcontra.skill;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Pools;
import com.jxz.notcontra.buff.ForceBuff;
import com.jxz.notcontra.entity.LivingEntity;
import com.jxz.notcontra.entity.Player;
import com.jxz.notcontra.handlers.InputManager;
import com.jxz.notcontra.handlers.SkillManager;

/**
 * Created by Samuel on 04/06/2015.
 * Skill that initiates a force buff.
 */
public class ForceBuffSkill extends BuffSkill {
    protected float magnitude;

    public ForceBuffSkill(String name) {
        super(name);
    }

    @Override
    public void use(LivingEntity caster) {
        ForceBuff buff = Pools.obtain(ForceBuff.class);
        buff.setDirection(new Vector2(caster.isFlipped() ? -1 : 1, 0));
        buff.setAdditionalSpeed(magnitude);
        SkillManager.applyBuff(buff, caster, buffDuration);
    }

    @Override
    public void use(LivingEntity caster, Vector2 initial) {
        use(caster);
    }

    @Override
    public void preCast(LivingEntity caster) {
       use(caster);
    }

    public void setMagnitude(float magnitude) {
        this.magnitude = magnitude;
    }

}

```

`core/src/com/jxz/notcontra/skill/LinearProjectileSkill.java`:

```java
package com.jxz.notcontra.skill;

import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Pools;
import com.jxz.notcontra.animation.SpriteEx;
import com.jxz.notcontra.effect.SpriteEffect;
import com.jxz.notcontra.entity.*;
import com.jxz.notcontra.handlers.AudioHelper;
import com.jxz.notcontra.handlers.GameStateManager;
import com.jxz.notcontra.handlers.InputManager;

/**
 * Created by Samuel on 04/05/2015.
 * Basic projectile skill class.
 */
public class LinearProjectileSkill extends Skill {
    protected Projectile hitbox;
    protected float range;
    protected float speed;
    protected Vector2 target;

    public LinearProjectileSkill(String name) {
        super(name);
        requiresCastPriority = true;
        cooldown = 0;
        target = new Vector2(0, 0);
    }

    @Override
    public void use(LivingEntity caster, Vector2 initial) {
        this.caster = caster;
        hitbox = (Projectile) EntityFactory.spawn(Projectile.class);
        hitbox.setSprite(new SpriteEx(vfx.createSprite(animName)));
        hitbox.getSprite().setOriginCenter();
        hitbox.setHitboxOffset(hitboxOffset.x, hitboxOffset.y);
        initial.sub(hitbox.getSprite().getWidth() / 2, hitbox.getSprite().getHeight() / 2);

        // Step the projectile forwards so it comes out properly
        initial.add(target.nor().x * speed * 10, target.nor().y * speed * 10);

        // Initialize hitbox variables
        hitbox.init(this, caster, initial.x, initial.y);
        hitbox.setExplosionRadius(0);
        hitbox.setDirection(target.cpy());
        hitbox.setAnimTravel(animation);
        hitbox.setSpeed(speed);
        hitbox.setRange(range);
        hitbox.setSize(hitboxSize.x, hitboxSize.y);
        caster.getSkills().setCooldown(this, cooldown);
    }

    @Override
    public void preCast(LivingEntity caster) {
        if (caster instanceof Player) {
            // All player casts are towards cursor
            preCast(caster, InputManager.getInstance().getCursorDirection());
        } else if (caster instanceof Monster){
            // Assuming all future casts are towards a certain radius of the player
            Monster m = (Monster) caster;
            target = GameStateManager.getInstance().getPlayState().getPlayer().getCenterPosition().cpy();
            target.add(MathUtils.random(-m.getAimRadius(), m.getAimRadius()), MathUtils.random(-m.getAimRadius(), m.getAimRadius()));
            target.sub(caster.getCenterPosition());
            preCast(caster, target);
        }

        // Bypasses cast effect when using via cast skill
        if (caster.getBuffList().hasBuff("CastingBuff")) {
            use(caster);
        } else {
            AudioHelper.playSoundEffect("genericCast");
        }
    }

    public void preCast(LivingEntity caster, Vector2 target) {
        // Handle flipping of caster - caster should face the way the spell is cast
        this.target = target;
        if (target.x > 0) {
            if (caster.isFlipped()) {
                // Face the right side
                caster.setIsFlipped(false);
            }
        } else {
            if (!caster.isFlipped()) {
                // Face the left side
                caster.setIsFlipped(true);
            }
        }

        // Spawn cast effect if there is one
        if (hasCastEffect) {
            castEffect = Pools.obtain(SpriteEffect.class);
            castEffect.init();
            castEffect.setParent(caster);
            caster.addChild(castEffect);
            castEffect.setSprite(vfx.createSprite(castName));
            castEffect.setOffset(castOffset.x, castOffset.y);
            castEffect.setAnimation(castAnimation);
            castEffect.setDirection(target);
        }
    }

    public void setRange(float range) {
        this.range = range;
    }

    public void setSpeed(float speed) {
        this.speed = speed;
    }

    public float getRange() {
        return range;
    }

    public float getSpeed() {
        return speed;
    }
}


```

`core/src/com/jxz/notcontra/skill/MeleeAttackSkill.java`:

```java
package com.jxz.notcontra.skill;

import com.badlogic.gdx.math.Vector2;
import com.jxz.notcontra.animation.SpriteEx;
import com.jxz.notcontra.entity.AttachedHitbox;
import com.jxz.notcontra.entity.EntityFactory;
import com.jxz.notcontra.entity.LivingEntity;
import com.jxz.notcontra.handlers.AudioHelper;

/**
 * Created by Samuel on 23/04/2015.
 * Basic cast attack skill.
 */
public class MeleeAttackSkill extends Skill {

    protected AttachedHitbox hitbox;

    public MeleeAttackSkill(String name) {
        super(name);
        requiresCastPriority = true;
    }

    @Override
    public void preCast(LivingEntity caster) {
        // Precast stuff. For melees, that would be the swing sound.
        AudioHelper.playSoundEffect("genericCast2");
    }

    @Override
    public void use(LivingEntity caster) {
        this.caster = caster;
        hitbox = (AttachedHitbox) EntityFactory.spawn(AttachedHitbox.class);
        hitbox.setHitboxOffset(hitboxOffset.x, hitboxOffset.y);
        hitbox.setSprite(new SpriteEx(vfx.createSprite(animName)));
        hitbox.getSprite().setOriginCenter();
        hitbox.init(this, caster, true);
        hitbox.setAnimTravel(animation);
        hitbox.setTime(time);
        hitbox.setSize(hitboxSize.x, hitboxSize.y);
        caster.getSkills().setCooldown(this, cooldown);
    }

    @Override
    public void use(LivingEntity caster, Vector2 initial) {
        use(caster);
    }
}

```

`core/src/com/jxz/notcontra/skill/RainProjectileSkill.java`:

```java
package com.jxz.notcontra.skill;

import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.jxz.notcontra.animation.SpriteEx;
import com.jxz.notcontra.entity.*;
import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.handlers.AudioHelper;
import com.jxz.notcontra.handlers.GameStateManager;
import com.jxz.notcontra.handlers.InputManager;

/**
 * Created by Samuel on 2015-06-04.
 */
public class RainProjectileSkill extends LinearProjectileSkill {
    protected PhysicsProjectile hitbox;

    public RainProjectileSkill(String name) {
        super(name);
    }

    @Override
    public void use(LivingEntity caster, Vector2 position) {
        this.caster = caster;
        hitbox = (PhysicsProjectile) EntityFactory.spawn(PhysicsProjectile.class);
        hitbox.setSprite(new SpriteEx(vfx.createSprite(animName)));
        hitbox.getSprite().setOriginCenter();
        hitbox.setHitboxOffset(hitboxOffset.x, hitboxOffset.y);

        // Initialize hitbox variables
        hitbox.init(this, caster, target.x + MathUtils.random(-150, 150), caster.getCurrentLevel().getHeight() / Game.UNIT_SCALE - hitbox.getSprite().getHeight());
        hitbox.setExplosionRadius(1);
        hitbox.setTime(99999);
        hitbox.setIgnorePlatforms(true);
        hitbox.setDirection(target.cpy());
        hitbox.setAnimTravel(animation);
        hitbox.setExplodeOnGround(true);
        hitbox.setSize(hitboxSize.x, hitboxSize.y);
        caster.changeMana(-getCost());
    }

    @Override
    public void preCast(LivingEntity caster) {
        if (caster instanceof Player) {
            // All player casts are towards cursor
            preCast(caster, InputManager.getInstance().getCursorInWorld());
        } else if (caster instanceof Monster) {
            // Assuming all future casts are towards a certain radius of the player
            Monster m = (Monster) caster;
            target = GameStateManager.getInstance().getPlayState().getPlayer().getCenterPosition().cpy();
            preCast(caster, target);
        }

        // Bypasses cast effect when using via cast skill
        if (caster.getBuffList().hasBuff("CastingBuff")) {
            use(caster);
        } else {
            AudioHelper.playSoundEffect("genericCast");
        }
    }
}

```

`core/src/com/jxz/notcontra/skill/Skill.java`:

```java
package com.jxz.notcontra.skill;

import com.badlogic.gdx.assets.AssetManager;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Pools;
import com.jxz.notcontra.effect.SpriteEffect;
import com.jxz.notcontra.entity.Entity;
import com.jxz.notcontra.entity.LivingEntity;
import com.jxz.notcontra.entity.Monster;
import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.handlers.AssetHandler;
import com.jxz.notcontra.handlers.SkillManager;

import java.util.ArrayList;

/**
 * Created by Samuel on 23/04/2015.
 * Base class for skills.
 */
public abstract class Skill implements Cloneable {
    // Statistical Info
    protected String name;
    protected String animName;
    protected String castName;
    protected float time;
    protected int mana;
    protected float cooldown;
    protected float damage;
    protected float damageScaling;
    protected Vector2 hitboxSize;
    protected Vector2 hitboxOffset;
    protected boolean rootWhileCasting;
    protected boolean requiresCastPriority;
    protected String statusEffect;
    protected float statusDuration;
    protected String hitEffect;
    protected SpriteEffect castEffect;
    protected Animation hitAnimation;
    protected Animation animation;
    protected Animation castAnimation;
    protected TextureAtlas vfx;
    protected Entity caster;
    protected Vector2 castOffset;
    protected boolean hasCastEffect;
    protected boolean explodeOnHit;

    // Constructor
    public Skill(String name) {
        this.name = name;
        hitboxOffset = new Vector2(0, 0);
        hitboxSize = new Vector2(0, 0);
        castOffset = new Vector2(0, 0);
        requiresCastPriority = true;
        hasCastEffect = false;
        cooldown = 0;
    }

    public abstract void use(LivingEntity caster, Vector2 position);

    public void use(LivingEntity caster) {
        use(caster, caster.getCenterPosition().cpy());
    }

    public abstract void preCast(LivingEntity caster);

    public void hit(ArrayList<Entity> list) {
        for (Entity e : list) {
            hit(e);
        }
    }

    public void hit(Entity target) {
        if (target instanceof LivingEntity) {
            LivingEntity le = (LivingEntity) target;
            if (!(target instanceof Monster && caster instanceof Monster)) {
                le.damage(damage, caster);
                if (statusEffect != null) {
                    SkillManager.applyBuff(statusEffect, le, statusDuration);
                }
                if (hitEffect != null) {
                    SpriteEffect effect = Pools.obtain(SpriteEffect.class);
                    effect.init();
                    effect.setParent(le);
                    le.addChild(effect);
                    effect.setSprite(vfx.createSprite(hitEffect));
                    effect.setAnimation(hitAnimation);
                    effect.setDirection(Vector2.Zero);
                    effect.setOffset(0, 0);
                }
                if (Game.getDebugMode()) System.out.println(le.getName() + le.getId() + " is now at " + le.getHealth() + " hp.");
            }
        }
    }

    @Override
    public Skill clone() {
        try {
            return (Skill) super.clone();
        } catch (CloneNotSupportedException e) {
            // I'm actually not sure what to do here, since it should never happen.
        }
        return null;
    }

    public boolean isRootWhileCasting() {
        return rootWhileCasting;
    }

    public void setRootWhileCasting(boolean rootWhileCasting) {
        this.rootWhileCasting = rootWhileCasting;
    }

    public void setTime(float time) {
        this.time = time;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setVfx(TextureAtlas vfx) {
        this.vfx = vfx;
    }

    public void setDamage(float damage) {
        this.damage = damage;
    }

    public void setHitboxOffset(float x, float y) {
        hitboxOffset.set(x, y);
    }

    public void setAnimName(String animName) {
        this.animName = animName;
    }

    public void setCastName(String castName) {
        this.castName = castName;
    }

    public String getCastName() {
        return castName;
    }

    public void setAnimation(Animation anim) {
        this.animation = anim;
    }

    public void setCastAnimation(Animation anim) {
        this.castAnimation = anim;
        hasCastEffect = true;
    }

    public Animation getAnimation() {
        if (hasCastEffect) {
            return this.castAnimation;
        }
        return null;
    }

    public boolean isHasCastEffect() {
        return hasCastEffect;
    }

    public void setCastOffset(float x, float y) {
        castOffset.set(x, y);
    }

    public void setHitboxSize(float x, float y) {
        hitboxSize.set(x, y);
    }

    public boolean isPriorityCast() {
        return requiresCastPriority;
    }

    public float getMaxCooldown() {
        return cooldown;
    }

    public float getDamageScaling() {
        return damageScaling;
    }

    public void setDamageScaling(float damageScaling) {
        this.damageScaling = damageScaling;
    }

    public void setStatusEffect(String buffName) {
        statusEffect = buffName;
    }

    public void setStatusDuration(float duration) {
        statusDuration = duration;
    }

    public void setHitAnimation(Animation animation) {
        hitAnimation = animation;
    }

    public void setHitEffect(String hitEffect) {
        this.hitEffect = hitEffect;
    }

    public String getHitEffect() {
        return hitEffect;
    }

    public void setCooldown(float cooldown) {
        this.cooldown = cooldown;
    }

    public void setCaster(Entity caster) {
        this.caster = caster;
    }

    public boolean isExplodeOnHit() {
        return explodeOnHit;
    }

    public void setExplodeOnHit(boolean explodeOnHit) {
        this.explodeOnHit = explodeOnHit;
    }

    public int getCost() {
        return mana;
    }

    public void setCost(int mana) {
        this.mana = mana;
    }
}

```

`core/src/com/jxz/notcontra/skill/SpawnSkill.java`:

```java
package com.jxz.notcontra.skill;

import com.badlogic.gdx.math.Vector2;
import com.jxz.notcontra.entity.EntityFactory;
import com.jxz.notcontra.entity.LivingEntity;
import com.jxz.notcontra.entity.Monster;

/**
 * Created by Samuel on 03/06/2015.
 * Skills that spawn minions. Generally reserved for bosses.
 */
public class SpawnSkill extends Skill {

    protected Class monsterType;
    protected int number;

    public SpawnSkill(String name, Class monsterType, int number) {
        super(name);
        requiresCastPriority = true;
        cooldown = 0;
        this.monsterType = monsterType;
        this.number = number;
    }

    @Override
    public void use(LivingEntity caster) {
        for (int i = 0; i < number; i++) {
            // Spawn monsters
            Monster monster = (Monster) EntityFactory.spawn(monsterType);
            monster.init();
            monster.setPosition(caster.getCurrentLevel().getSpawnPointList().randomSpawn());
            monster.setCurrentLevel(caster.getCurrentLevel());

            // Immediately aggroes the monsters to the caster's target if applicable
            if (caster instanceof Monster) {
                Monster m = (Monster) caster;
                if (m.getTarget() != null) {
                    monster.setTarget(m.getTarget());
                }
            }
        }
    }

    @Override
    public void use(LivingEntity caster, Vector2 initial) {
        use(caster);
    }

    @Override
    public void preCast(LivingEntity caster) {
        // There's no real precast for spawning more mobs
    }


}

```

`core/src/com/jxz/notcontra/states/GameState.java`:

```java
package com.jxz.notcontra.states;

import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.jxz.notcontra.camera.PlayerCamera;
import com.jxz.notcontra.game.Game;

/**
 * Created by Kevin Xiao on 2015-03-24.
 * Game State abstract class
 */
public abstract class GameState {

    protected Game game;

    protected SpriteBatch sb = new SpriteBatch();
    protected PlayerCamera playerCam;
    protected OrthographicCamera hudCam;
    protected BitmapFont font = new BitmapFont();

    protected GameState(Game game) {
        this.game = game;
        this.playerCam = this.game.getPlayerCam();
        this.hudCam = this.game.getHudCam();
    }

    public abstract void update();

    public abstract void render();

    public SpriteBatch getSpriteBatch() {
        return sb;
    }

    public void dispose() {
        sb.dispose();
        font.dispose();
    }
    public BitmapFont getFont() {
        return font;
    }

    public abstract void setMusic();
}

```

`core/src/com/jxz/notcontra/states/LoadState.java`:

```java
package com.jxz.notcontra.states;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.GL30;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.GlyphLayout;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.math.Interpolation;
import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.handlers.AssetHandler;
import com.jxz.notcontra.handlers.GameStateManager;
import com.jxz.notcontra.menu.LoadingBar;

/**
 * Created by Kevin Xiao on 2015-04-09.
 * Load State
 */
public class LoadState extends GameState {

    TextureAtlas loadAtlas;
    private Sprite logo_libgdx;
    private BitmapFont font = new BitmapFont();
    private AssetHandler assetHandler = AssetHandler.getInstance();
    private LoadingBar loadingBar;
    private float progress = 0f;
    private GlyphLayout layout;
    private boolean isEnteringGame;
    private boolean isDoneLoading;

    private final String LOADING = "Loading Game: ";
    private final String DONE_LOADING = "Done Loading! Press ESC to enter game.";


    public LoadState(Game game) {
        super(game);
        // Load and parse assets
        loadingBar = new LoadingBar();
        loadAtlas = (TextureAtlas) assetHandler.getByName("menu_loadingbar");
        logo_libgdx = loadAtlas.createSprite("libgdx");
        layout = new GlyphLayout();
    }

    public void load(String... filePaths) {
        isEnteringGame = true;
        // Load general level file
        assetHandler.loadFromFile("general.txt");
        for (String i : filePaths) {
            assetHandler.loadFromFile(i);
        }
    }

    public void update() {
        loadingBar.update();
        isDoneLoading = assetHandler.update();
        if (isDoneLoading && !isEnteringGame) {
            GameStateManager.getInstance().setState(GameStateManager.State.MENU);
        }
    }

    public void render() {
        Gdx.gl.glClearColor(0.3f, 0.3f, 0.3f, 1);
        Gdx.gl.glBlendFunc(GL30.GL_SRC_ALPHA, GL30.GL_ONE_MINUS_SRC_ALPHA);
        Gdx.gl.glClear(GL30.GL_COLOR_BUFFER_BIT);

        assetHandler.update();
        progress = Interpolation.swingOut.apply(progress, assetHandler.getProgress(), 0.06f);

        sb.setProjectionMatrix(hudCam.combined);
        sb.begin();
        //Draw libgdx logo
        sb.draw(logo_libgdx, Gdx.graphics.getWidth() - logo_libgdx.getWidth() / 2 - 5, 5, 150, 25);
        // Drawing loading frame and bar
        sb.draw(loadingBar.getFrameSprite(), loadingBar.getPositionX(), loadingBar.getPositionY(), loadingBar.getBarSprite().getWidth(), loadingBar.getBarSprite().getHeight());
        sb.draw(loadingBar.getBarSprite().getTexture(),
                loadingBar.getPositionX(),
                loadingBar.getPositionY(),
                (progress > 0.995f ? loadingBar.getBarSprite().getWidth() : loadingBar.getBarSprite().getWidth() * progress),
                loadingBar.getBarSprite().getHeight(),
                loadingBar.getBarSprite().getRegionX(),
                loadingBar.getBarSprite().getRegionY(),
                (progress > 0.995f ? (loadingBar.getBarSprite().getRegionWidth()) : Math.round(loadingBar.getBarSprite().getRegionWidth() * progress)),
                loadingBar.getBarSprite().getRegionHeight(), false, false);
        // Draw fonts
        layout.setText(font, LOADING + Math.round(progress * 100) + "%");
        font.draw(sb, layout, Game.VID_WIDTH / 2 - layout.width / 2, Game.VID_HEIGHT / 2 + 45);
        layout.setText(font, DONE_LOADING);
        if (Math.round(progress * 100) == 100) {
            font.draw(sb, layout, Game.VID_WIDTH / 2 - layout.width / 2, Game.VID_HEIGHT / 2 - (45 - layout.height));
        }

        sb.end();
    }

    @Override
    public void setMusic() {
        // Do nothing
    }

    public void resetLoadingBar() {
        progress = 0f;
    }

    public boolean getIsDoneLoading() {
        return isDoneLoading;
    }

    public boolean getIsEnteringGame() {
        return isEnteringGame;
    }
}
```

`core/src/com/jxz/notcontra/states/MenuState.java`:

```java
package com.jxz.notcontra.states;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.audio.Music;
import com.badlogic.gdx.graphics.GL30;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.handlers.AssetHandler;
import com.jxz.notcontra.handlers.AudioHelper;
import com.jxz.notcontra.menu.Menu;
import com.jxz.notcontra.menu.ParseMenu;

/**
 * Created by Samuel on 2015-05-08.
 */
public class MenuState extends GameState {

    private AssetHandler assetHandler = AssetHandler.getInstance();
    private Menu currentMenu;
    private TextureAtlas menuButtonTextures;
    private Menu rootMenu;
    private Texture background;
    private Music music;

    public MenuState(Game game) {
        super(game);
        assetHandler.loadFromFile("menus/main_menu.txt");
        assetHandler.loadFromFile("menus/loading_screen.txt");
        while (!assetHandler.update()) ; // Load stuff for main menu and loading screen
        this.background = (Texture) assetHandler.getByName("menu_background");
        rootMenu = new ParseMenu("MainMenu.xml");
        rootMenu.setMenuState(this);
        setCurrentMenu(rootMenu);
    }

    public void update() {
    }

    public void render() {
        Gdx.gl.glClearColor(0.8f, 0.8f, 0.8f, 1);
        //Gdx.gl.glBlendFunc(GL30.GL_SRC_ALPHA, GL30.GL_ONE_MINUS_SRC_ALPHA);
        Gdx.gl.glClear(GL30.GL_COLOR_BUFFER_BIT);
        sb.setProjectionMatrix(hudCam.combined);
        sb.begin();
        sb.draw(this.background, 0, 0);
        currentMenu.renderMenu(sb, font);
        if (Game.getDebugMode()) {
            font.draw(sb, "MENU STATE... FPS: " + Gdx.graphics.getFramesPerSecond(), 100, 100);
            font.draw(sb, "DELTA TIME IN SECONDS: " + Gdx.graphics.getDeltaTime(), 100, 75);
        }
        sb.end();
    }

    public Menu getCurrentMenu() {
        return currentMenu;
    }

    public void setCurrentMenu(Menu menu) {
        currentMenu = menu;
    }

    public Menu getRootMenu() {
        return rootMenu;
    }

    public void setRootMenu(Menu menu) {
        rootMenu = menu;
    }

    public TextureAtlas getMenuButtonTextures() {
        return menuButtonTextures;
    }

    public void setMenuButtonTextures(TextureAtlas menuButtonTextures) {
        this.menuButtonTextures = menuButtonTextures;
    }

    public void setMusic() {
        // Music setup
        music = Gdx.audio.newMusic(Gdx.files.internal(assetHandler.getFilePath("menu_music") + ".mp3"));
        AudioHelper.setBgMusic(this.music);
        AudioHelper.resetBackgroundMusic();
        AudioHelper.playBgMusic(true);
    }
}


```

`core/src/com/jxz/notcontra/states/PlayState.java`:

```java
package com.jxz.notcontra.states;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.audio.Music;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL30;
import com.badlogic.gdx.maps.tiled.TiledMap;
import com.jxz.notcontra.entity.Player;
import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.handlers.*;
import com.jxz.notcontra.menu.HighScoreMenu;
import com.jxz.notcontra.menu.Menu;
import com.jxz.notcontra.menu.ParseMenu;
import com.jxz.notcontra.shaders.Shaders;
import com.jxz.notcontra.world.Level;
import com.jxz.notcontra.world.LevelRenderer;

import java.util.concurrent.TimeUnit;

/**
 * Created by Kevin Xiao on 2015-03-24.
 * Play State
 */
public class PlayState extends GameState {

    private AssetHandler assetHandler = AssetHandler.getInstance();

    private Player player;
    private Level currentLevel;
    private LevelRenderer currentMapRenderer;
    private TiledMap map;
    private boolean isPaused;
    private Menu pauseMenu;
    private Menu currentMenu;
    private float timeSurvived;
    private boolean highScoreShown;
    private Music music;
    private String levelName;

    private int killCounter;

    public PlayState(Game game) {
        super(game);
        // Initialize for the first time
        isPaused = false;
        SkillManager.init();
        if (game.getLoadSaveObject() != null) {
            timeSurvived = game.getLoadSaveObject().timeSurvived;
        }
        // Initialize player
        player = new Player(this);
        player.setCamera(playerCam);
        playerCam.setPlayer(player);
        pauseMenu = new ParseMenu("PauseMenu.xml");
        pauseMenu.setMenuState(GameStateManager.getInstance().getMenuState());
        currentMenu = pauseMenu;
    }

    public void load(String levelName) {
        map = (TiledMap) assetHandler.getByName(levelName);
        currentLevel = Level.getLevel(map);
        currentMapRenderer = new LevelRenderer(currentLevel, Game.UNIT_SCALE);
        currentMapRenderer.setView(playerCam);
        LevelRenderer.setCamera(playerCam);

        // Initialize Player object
        player.setCurrentLevel(currentLevel);
    }

    public void load() {
        load("su_grass");
    }

    public void update() {
        if (!player.isAlive() && !highScoreShown) {
            HighScoreHandler.loadFromDisk();
            highScoreShown = true;
            if (player.getScore() > HighScoreHandler.getLowestScore()) {
                Gdx.input.getTextInput(new Input.TextInputListener() {
                    @Override
                    public void input(String text) {
                        HighScoreHandler.addHighScore(text, player.getScore());
                        setCurrentMenu(new HighScoreMenu() {{
                            setMenuState(GameStateManager.getInstance().getMenuState());
                        }});
                        setIsPaused(true);
                    }

                    @Override
                    public void canceled() {
                    }
                }, "New high score!", "", "Please enter your name:");
            }
        }

        if (game.getPlayMode() == Game.PlayMode.SURVIVAL && !isPaused && player.isAlive()) {
            timeSurvived += Gdx.graphics.getDeltaTime();
        }

        if (!isPaused) {
            sb.setShader(game.getShaders().getShaderType(Shaders.ShaderType.PASSTHROUGH));
            currentMapRenderer.getBatch().setShader(player.isAlive() ? game.getShaders().getShaderType(Shaders.ShaderType.PASSTHROUGH) : game.getShaders().getShaderType(Shaders.ShaderType.VIGNETTE));
            currentMapRenderer.update();
            if (!AudioHelper.isBgMusicPlaying()) {
                AudioHelper.playBgMusic(true);
            }
            // Update camera position
            playerCam.track();
        } else {
            sb.setShader(game.getShaders().getShaderType(Shaders.ShaderType.VIGNETTE));
            currentMapRenderer.getBatch().setShader(player.isAlive() ? game.getShaders().getShaderType(Shaders.ShaderType.VIGNETTE) : game.getShaders().getShaderType(Shaders.ShaderType.VIGNETTE));
            if (AudioHelper.isBgMusicPlaying()) {
                AudioHelper.playBgMusic(false);
            }
        }
    }

    public void render() {
        // Clear screen
        Gdx.gl.glClearColor(0.8f, 0.8f, 0.8f, 1);
        Gdx.gl.glBlendFunc(GL30.GL_SRC_ALPHA, GL30.GL_ONE_MINUS_SRC_ALPHA);
        Gdx.gl.glClear(GL30.GL_COLOR_BUFFER_BIT);

        // Update projection matrices
        playerCam.update();
        sb.setProjectionMatrix(hudCam.combined);

        // Render map
        currentMapRenderer.render();
        currentMapRenderer.setView(playerCam);

        sb.begin();
        font.setColor(Color.WHITE);

        if (!player.isAlive()) {
            font.draw(sb, "YOU ARE DEAD.", 600, 550);
        }
        font.draw(sb, "Score: " + player.getScore(), 1100, 680);
        if (!isPaused()) {
            player.getHealthBar().draw(sb);

            if (game.getPlayMode() == Game.PlayMode.REST) {
                font.draw(sb, "Time to next spawn: " + (currentLevel.getSpawnTimer()), 600, 50);
            }
            if (game.getPlayMode() == Game.PlayMode.SURVIVAL || game.getPlayMode() == Game.PlayMode.REST) {
                long minutes = TimeUnit.SECONDS.toMinutes((long) timeSurvived);
                font.draw(sb, "Time survived: " + String.format("%02d:%02d", minutes, TimeUnit.SECONDS.toSeconds((long) timeSurvived - minutes * 60)), 1100, 700);
                font.draw(sb, "Current Wave: " + currentLevel.getCurrentWave() + " Diff: " + Game.getDifficultyMultiplier(), 850, 50);
            }

            if (Game.getDebugMode()) {
                // Debug text - drawn to HUD Camera
                font.draw(sb, "PLAY STATE... FPS: " + Gdx.graphics.getFramesPerSecond(), 100, 100);
                font.draw(sb, "X-position: " + player.getPosition().x, 500, 75);
                font.draw(sb, "Y-position: " + player.getPosition().y, 500, 50);
                //font.draw(sb, "X tile: " + player.getPosition().x * Game.UNIT_SCALE, 300, 75);
                //font.draw(sb, "Y tile: " + player.getPosition().y * Game.UNIT_SCALE, 300, 50);
                //font.draw(sb, "MovementStateX: " + player.getMovementState().x, 500, 50);
                font.draw(sb, "Delta Time (from last frame) " + Gdx.graphics.getDeltaTime(), 500, 100);
                font.draw(sb, "Slimes: " + currentLevel.getMonsterCount(), 500, 25);
                font.draw(sb, "isClimbing: " + player.isClimbing() + "    isOnPlatform: " + player.isOnPlatform() + "    isGrounded: " + player.isGrounded() + "    jumpState: " + player.getJumpState() + "     isOnSlope: " + player.isOnSlope(), 500, 125);
                font.draw(sb, "MovementStateY: " + player.getMovementState().y, 1100, 25);
            }
        } else {
            currentMenu.renderMenu(sb, font);
            if (Game.getDebugMode()) {
                font.draw(sb, "GAME PAUSED... FPS: " + Gdx.graphics.getFramesPerSecond(), 100, 100);
                font.draw(sb, "Delta Time (from last frame) " + Gdx.graphics.getDeltaTime(), 500, 100);
            }
        }

        sb.end();
    }

    public Player getPlayer() {
        return player;
    }

    public boolean isPaused() {
        return isPaused;
    }

    public void setIsPaused(boolean pause) {
        isPaused = pause;
    }

    public void dispose() {
        assetHandler.unloadByFile("levels/levels.txt");
        assetHandler.unloadByFile("general.txt");
        currentLevel.dispose();
        EntityManager.getInstance().dispose();
    }

    public Menu getPauseMenu() {
        return pauseMenu;
    }

    public Menu getCurrentMenu() {
        return currentMenu;
    }

    public void setCurrentMenu(Menu menu) {
        currentMenu = menu;
    }

    public int getKills() {
        return killCounter;
    }

    public void incKills() {
        killCounter++;
    }

    public void setKills(int kills) {
        killCounter = kills;
    }

    public void setTimeSurvived(float timeSurvived) {
        this.timeSurvived = timeSurvived;
    }

    public float getTimeSurvived() {
        return timeSurvived;
    }

    public void setMusic() {
        // Music setup
        music = Gdx.audio.newMusic(Gdx.files.internal(assetHandler.getFilePath("bgmusic") + ".mp3"));
        AudioHelper.setBgMusic(this.music);
        AudioHelper.resetBackgroundMusic();
        AudioHelper.playBgMusic(true);
    }
}

```

`core/src/com/jxz/notcontra/world/Level.java`:

```java
package com.jxz.notcontra.world;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.maps.MapObject;
import com.badlogic.gdx.maps.objects.PolylineMapObject;
import com.badlogic.gdx.maps.tiled.TiledMap;
import com.badlogic.gdx.maps.tiled.TiledMapTile;
import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Array;
import com.jxz.notcontra.entity.Alien;
import com.jxz.notcontra.entity.EntityFactory;
import com.jxz.notcontra.entity.Monster;
import com.jxz.notcontra.entity.Slime;
import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.handlers.AssetHandler;
import com.jxz.notcontra.handlers.GameStateManager;

/**
 * Created by Samuel on 04/04/2015.
 * Level
 */
public class Level {

    // Background
    public Texture[] layers = new Texture[3];
    private AssetHandler assetHandler = AssetHandler.getInstance();

    // Class constants
    public static final String STATIC_LAYER = "Static Map";     // Name of static collision map layer
    public static final String DYNAMIC_LAYER = "Dynamic Map";   // Name of dynamic collision layers (platforms and slopes)
    public static final String TRIGGER_LAYER = "Trigger Tile";  // Name of trigger layer (ladders/ropes)
    public static final String SPAWN_LAYER = "Spawn";            // Name of spawn point poly-line layer

    public static final float MAX_SECONDS_TO_SPAWN = 5.0f;
    public static final float MIN_SECONDS_TO_SPAWN = 2.0f;

    // Class Variables
    private static Array<Level> loadedMaps = new Array<Level>();    // Static list of Levels to avoid duplicates
    private SpawnPointList spawnPointList;
    private TiledMap map;
    private int height, width;
    private float gravity = 0.25f / Game.UNIT_SCALE;
    private boolean firstLoad;
    private Game game;
    private String theme;

    // Survival Variables
    private int monsterCount;
    private int currentWave;
    private int subWavesRemaining;
    private int monstersPerWave;
    private float spawnTimer;
    private float[] spawnPercentage;

    // Story Variables
    private boolean levelComplete;
    private boolean bossLevel;

    protected Level(TiledMap map) {
        // Map Property setup
        this.map = map;
        height = map.getProperties().get("height", int.class);
        width = map.getProperties().get("width", int.class);
        game = GameStateManager.getInstance().getGame();
        theme = map.getProperties().get("theme", String.class);

        // Survival Setup
        subWavesRemaining = 3;
        spawnTimer = 5;
        monstersPerWave = 5;
        spawnPercentage = new float[3];

        // Story initialization
        levelComplete = false;
        bossLevel = false;

        // Load parallax backgrounds from map file
        layers[0] = (Texture) assetHandler.getByName(map.getProperties().get("parallaxBackground", String.class));
        layers[1] = (Texture) assetHandler.getByName(map.getProperties().get("parallaxMidground", String.class));
        layers[2] = (Texture) assetHandler.getByName(map.getProperties().get("parallaxForeground", String.class));
        layers[2].setWrap(Texture.TextureWrap.Repeat, Texture.TextureWrap.Repeat);

        // Load array of polyline spawn points
        spawnPointList = new SpawnPointList();
        for (MapObject object : map.getLayers().get(SPAWN_LAYER).getObjects()) {
            if (object instanceof PolylineMapObject) {
                spawnPointList.addLine((PolylineMapObject) object);
            }
        }

        // Add map to static array
        loadedMaps.add(this);
        firstLoad = true;

        // Spawn mobs if necessary; story mode only
        if (game.getPlayMode() == Game.PlayMode.STANDARD) {
            if (map.getProperties().containsKey("defaultSpawnAmount") && map.getProperties().containsKey("defaultMobLevel")) {
                spawn(Integer.parseInt(map.getProperties().get("defaultSpawnAmount", String.class)), Integer.parseInt(map.getProperties().get("defaultMobLevel", String.class)));
            }

            // Spawns boss on boss levels
            if (map.getProperties().containsKey("bossMode")) {
                bossLevel = true;
                spawn(1, 3);
            }
        }
    }

    /**
     * Returns a level instance, given a TiledMap. Prevents duplicate levels from existing.
     *
     * @param map TiledMap for the level.
     * @return A reference to the Level object corresponding to the map.
     */
    public static Level getLevel(TiledMap map) {
        for (Level l : loadedMaps) {
            if (l.getMap().equals(map)) {
                l.firstLoad = false;
                return l;
            }
        }
        return new Level(map);
    }

    /**
     * Update method called to handle respawns
     */
    public void update() {
        // Updates spawn timers and behaviour based on game mode
        switch (game.getPlayMode()) {
            case STANDARD:
                // Standard game mode: Respawns don't occur, unless specifically triggered.
                // The next level is ready when monster count is equal to zero
                if (monsterCount == 0) {
                    levelComplete = true;
                }
                break;
            case SURVIVAL:
                // Survival game mode: Waves respawn occur after each wave is dead
                // Sub waves spawn every 5 seconds, decreasing by 0.5 seconds every 2 waves, down to a minimum of 2.0
                if (subWavesRemaining > 1) {
                    if (monsterCount == 0 || spawnTimer <= 0) {
                        spawnPercentage[0] = MathUtils.clamp(1.0f - 0.05f * (currentWave - 1), 0.1f, 1.0f);  // Spawn grunts, 5% less grunts per wave
                        spawnPercentage[1] = MathUtils.clamp(0.05f * (currentWave - 1), 0, 0.9f); // Spawn ranged, 5% more per wave
                        spawnPercentage[2] =  (currentWave % 5 == 0) ?  0.05f : 0; // Spawn 5% elite mobs every 5 waves

                        // Actually spawn mobs
                        for (int i = 0; i < spawnPercentage.length; i++) {
                            if (spawnPercentage[i] > 0) {
                                spawn(MathUtils.ceil(monstersPerWave * spawnPercentage[i]), i);
                            }
                        }

                        spawnTimer = MathUtils.clamp(MAX_SECONDS_TO_SPAWN - 0.5f * (currentWave / 2), MIN_SECONDS_TO_SPAWN, MAX_SECONDS_TO_SPAWN);
                        subWavesRemaining--;
                    }
                } else if (monsterCount == 0) {
                    // Subwaves complete. Next wave.
                    currentWave++;
                    // Monsters per subwave increases by 1 every 3 waves, up to 25
                    monstersPerWave = MathUtils.clamp(5 + (currentWave / 3), 5, 25);
                    // Number of subwaves start at 3, increasing by 1 every 4 waves
                    subWavesRemaining = 3 + (currentWave / 4);
                    // Increase difficulty value by 5% every wave
                    Game.setDifficultyMultiplier(1 + 0.05f * (currentWave - 1));
                    spawnTimer = Game.REST_DURATION;
                    game.setPlayMode(Game.PlayMode.REST);
                    // Show some sort of image here, saying wave x complete
                }
                break;
            case REST:
                // If rest is complete, return to survival
                if (spawnTimer < 0) {
                    game.setPlayMode(Game.PlayMode.SURVIVAL);
                    // Show some sort of image here, saying Wave x has started
                }
                break;
        }
        // Update internal level timer
        spawnTimer -= Gdx.graphics.getDeltaTime();
    }

    /**
     * Spawns stuff based on random line
     */
    public void spawn() {
        spawn(currentWave);
    }

    public void spawn(Class type) {
        spawn(type, spawnPointList.randomSpawn());
    }

    public void spawn(Class type, Vector2 position) {
        Monster monster = (Monster) EntityFactory.spawn(type);
        monster.init();
        monster.setPosition(position);
        monster.setCurrentLevel(this);

        // Automatically aggro to players in survival, or if its a boss
        if (GameStateManager.getInstance().getGame().getPlayMode() == Game.PlayMode.SURVIVAL || bossLevel) {
            monster.setTarget(GameStateManager.getInstance().getPlayState().getPlayer());
        }
    }

    public void spawn(int monsters) {
        for (int i = 0; i < monsters; i++) {
            spawn(Alien.class);
        }
    }

    /**
     * Method to spawn monsters based on monster hierarchy.
     *
     * @param monsters Number of monsters to spawn.
     * @param monsterLevel Rank of monster. 0 - grunt, 1 - basic, 2 - elite, 3 - boss.
     */
    public void spawn(int monsters, int monsterLevel) {
        // List of valid monster classes
        Array<Class> validMonsterType = new Array<Class>();

        // Add appropriate monster classes to the array
        switch (monsterLevel) {
            case 0:
                if (theme.equals("grass")) {
                    validMonsterType.add(Slime.class);
                } else if (theme.equals("space")) {
                    validMonsterType.add(Slime.class);
                } else if (theme.equals("hell")) {
                    validMonsterType.add(Slime.class);
                }
                break;
            case 1:
                if (theme.equals("grass")) {
                    validMonsterType.add(Alien.class);
                } else if (theme.equals("space")) {
                    validMonsterType.add(Alien.class);
                } else if (theme.equals("hell")) {
                    validMonsterType.add(Alien.class);
                }
                break;
            case 2:
                if (theme.equals("grass")) {

                } else if (theme.equals("space")) {

                } else if (theme.equals("hell")) {

                }
            case 3:
                if (theme.equals("grass")) {
                } else if (theme.equals("space")) {

                } else if (theme.equals("hell")) {

                }
        }

        // Spawns random monsters from selected class
        if (validMonsterType.size > 0) {
            for (int i = 0; i < monsters; i++) {
                spawn(validMonsterType.random());
            }
        }
    }

    /**
     * Checks for a tile at target pixel coordinates. Defaults to static tile without layer parameter.
     *
     * @param x     X-coordinate of the target tile in pixels.
     * @param y     Y-coordinate of the target tile in pixels.
     * @param layer Layer to check. See constants for more information.
     * @return Returns null if there is no tile. Returns tile(0,0) if out of bounds. In any other case, returns the target tile.
     */
    public TiledMapTile getTileAt(float x, float y, String layer) {
        int tileX = pixelToTile(x);
        int tileY = pixelToTile(y);
        TiledMapTileLayer tileLayer = (TiledMapTileLayer) map.getLayers().get(layer);
        TiledMapTileLayer.Cell cell = tileLayer.getCell(tileX, tileY);

        // Treats out of bounds tiles as tile(0,0), to represent a static tile.
        // NOTE: There better be a tile at 0,0.
        if (cell == null) {
            if (tileX < 0 || tileX >= tileLayer.getWidth() || tileY < 0 || tileY > tileLayer.getHeight()) {
                return tileLayer.getCell(0, 0).getTile();
            }
            return null;
        }

        return cell.getTile();
    }

    /**
     * Returns the maximum distance the player can travel before bumping into an static obstacle, given direction.
     *
     * @param x        Initial x coordinate.
     * @param y        Initial y coordinate.
     * @param dir      Direction to scan. Negative indicates left/down.
     * @param vertical True when scanning for vertical.
     * @param layer    The layer to scan. Defaults to Level.STATIC_LAYER without parameter.
     * @param tileType The tile property key to search for. Defaults to none.
     * @return Distance to closest obstacle on specified layer.
     */
    public float distToObstacle(float x, float y, float dir, boolean vertical, String layer, String tileType) {
        float dist = 0;
        for (int i = 0; i <= Math.abs(dir); i++) {
            TiledMapTile target = getTileAt(x + (vertical ? 0 : (dir > 0 ? 1 : -1)) * i, y + (vertical ? (dir > 0 ? 1 : -1) : 0) * i, layer);
            if (target == null) {
                dist++;
            } else {
                if (tileType.equals("") || target.getProperties().containsKey(tileType)) {
                    break;
                } else {
                    dist++;
                }
            }
        }

        if (dist > 0) {
            dist--;
        }

        return dist;
    }

    public float distToObstacle(float x, float y, float dir, boolean vertical) {
        return distToObstacle(x, y, dir, vertical, STATIC_LAYER, "");
    }

    /**
     * Returns the distance downwards (in pixels) to the nearest one-way platform.
     *
     * @param x        X-coordinate of the check, in pixels.
     * @param y        Y-coordinate of the initial check, in pixels.
     * @param distance Distance downwards to scan, in pixels.
     * @return Returns the whole number of pixels away from the nearest platform.
     */
    public float distToPlatform(float x, float y, float distance) {
        float dist = 0;
        float tileY = 0;
        for (int i = 0; i <= distance; i++) {
            TiledMapTile target = getTileAt(x, y - i, DYNAMIC_LAYER);
            if (target == null) {
                dist++;
            } else {
                // Makes sure tile detected is a platform
                if (target.getProperties().containsKey("platform")) {
                    tileY = pixelToTile(y - i) / Game.UNIT_SCALE;
                    break;
                } else {
                    dist++;
                }
            }
        }

        if (dist > 0) {
            // Collision only applies if player is completely above platform
            if (y >= tileY) {
                return --dist;
            }
        }

        // Return if no obstacle found
        return 9999;
    }

    /**
     * Returns the slope of the target tile. For use when computing slopes.
     *
     * @param x X-coordinate (in pixels) of the tile to check.
     * @param y Y-coordinate (in pixels) of the tile to check.
     * @return Returns the slope as a function of x. 1.00 would denote an upwards slope of 1 Y-unit per 1 X-unit.
     */
    public float getSlopeOfTile(float x, float y) {
        TiledMapTile tile = getTileAt(x, y, DYNAMIC_LAYER);
        if (tile != null) {
            if (tile.getProperties().containsKey("slope")) {
                return Float.valueOf((String) tile.getProperties().get("slope"));
            }
        }

        // Tile is not sloped
        return 0;
    }

    /**
     * Convenience method to find the target y-position of a sloped tile, given an x value.
     *
     * @param x X-coordinate (in pixels) of the tile to check.
     * @param y Y-coordinate (in pixels) of the tile to check.
     * @return Returns the calculated y-position of the slope at the desired x-y coordinate pair.
     */
    public float getSlopePosition(float x, float y) {
        float slope = getSlopeOfTile(x, y);
        if (slope == 0) {
            // Return absurd value if there is no slope
            return -99999;
        }
        float deltaX = x % (1 / Game.UNIT_SCALE);
        float deltaY = deltaX * slope; // y = mx
        // Negative slopes start at the top of the tile, and so, 1 tile needs to be added to the result
        if (slope < 0) {
            deltaY += (1 / Game.UNIT_SCALE) * Math.abs(slope); // + b if necessary
        }
        return (float) Math.floor(y * Game.UNIT_SCALE) / Game.UNIT_SCALE + deltaY;
    }


    /**
     * Convenience method to convert pixel coordinates to tile coordinates.
     *
     * @param px The pixel quantity to convert.
     * @return The corresponding integer tile coordinate.
     */
    public int pixelToTile(float px) {
        return (int) Math.floor(px * Game.UNIT_SCALE);
    }

    public float getGravity() {
        return gravity;
    }

    public int getWidth() {
        return width;
    }

    public int getHeight() {
        return height;
    }

    public TiledMap getMap() {
        return map;
    }

    public Texture[] getBackground() {
        return layers;
    }

    public boolean isFirstLoad() {
        return firstLoad;
    }

    public int getMonsterCount() {
        return monsterCount;
    }

    public void incMonsterCount() {
        monsterCount++;
    }

    public void decMonsterCount() {
        monsterCount--;
    }

    public void dispose() {
        for (Texture i : layers) {
            i.dispose();
        }
        for (Level i : loadedMaps) {
            i.map.dispose();
        }
        loadedMaps.clear();

    }

    public float getSpawnTimer() {
        return spawnTimer;
    }

    public int getCurrentWave() {
        return currentWave;
    }

    public void setCurrentWave(int currentWave) {
        this.currentWave = currentWave;
        Game.setDifficultyMultiplier(1 + 0.05f * (currentWave - 1));
    }

    public SpawnPointList getSpawnPointList() {
        return spawnPointList;
    }

    public boolean isComplete() {
        return levelComplete;
    }
}
```

`core/src/com/jxz/notcontra/world/LevelRenderer.java`:

```java
package com.jxz.notcontra.world;

import com.badlogic.gdx.maps.MapLayer;
import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
import com.badlogic.gdx.maps.tiled.renderers.OrthogonalTiledMapRenderer;
import com.jxz.notcontra.camera.PlayerCamera;
import com.jxz.notcontra.entity.Entity;
import com.jxz.notcontra.game.Game;
import com.jxz.notcontra.handlers.EntityManager;
import com.jxz.notcontra.handlers.ParticleManager;
import com.jxz.notcontra.particles.Particle;

/**
 * Created by Samuel on 15/04/2015.
 */
public class LevelRenderer extends OrthogonalTiledMapRenderer {

    // Constants
    private final int SPRITE_LAYER = 3;

    // Fields
    Level currentLevel;
    private static PlayerCamera playerCam;

    public LevelRenderer(Level level, float unitScale) {
        super(level.getMap(), unitScale);
        currentLevel = level;
    }

    public void update() {
        // Update all active entities in renderer
        for (Entity e : EntityManager.getInstance().getEntitiesListIteration()) {
            if (e.getCurrentLevel() == currentLevel) {
                if (e.isActive()) {
                    e.update();
                }
            }
        }

        // Update all particles in renderer
        for (Particle p : ParticleManager.getInstance().getParticlesListIteration()) {
            if (p.isVisible()) {
                p.update();
            }
        }

        // Update level timers
        currentLevel.update();
    }

    @Override
    public void render() {
        beginRender();

        batch.setProjectionMatrix(playerCam.calculateParallaxMatrix(1f, 1f));
        batch.draw(currentLevel.getBackground()[0], playerCam.position.x - playerCam.viewportWidth / 2, playerCam.position.y - playerCam.viewportHeight / 2f,
                Game.VIEW_WIDTH, Game.VIEW_HEIGHT);


        // Middle layer
        batch.setProjectionMatrix(playerCam.calculateParallaxMatrix(1.1f, 1.03f));
        batch.draw(currentLevel.getBackground()[1], playerCam.position.x - playerCam.viewportWidth / 2, playerCam.position.y - playerCam.viewportHeight / 1.5f,
                currentLevel.getBackground()[1].getWidth() / Game.VIEW_WIDTH * 2, currentLevel.getBackground()[1].getHeight() / Game.VIEW_HEIGHT * 1.2f);

        // Front layer
        batch.setProjectionMatrix(playerCam.calculateParallaxMatrix(1.6f, 1.3f));
        batch.draw(currentLevel.getBackground()[2], playerCam.position.x - playerCam.viewportWidth / 2, playerCam.position.y - playerCam.viewportHeight / 3,
                currentLevel.getBackground()[2].getWidth() / Game.VIEW_WIDTH * 12, currentLevel.getBackground()[2].getHeight() / Game.VIEW_HEIGHT, 0, 1, 10, 0);

        batch.setProjectionMatrix(playerCam.combined);

        int currentLayer = 0;
        for (MapLayer layer : map.getLayers()) {
            if (layer.isVisible()) {
                if (layer instanceof TiledMapTileLayer) {
                    renderTileLayer((TiledMapTileLayer) layer);
                    currentLayer++;

                    if (currentLayer == SPRITE_LAYER) {
                        for (Entity e : EntityManager.getInstance().getEntitiesListIteration()) {
                            if (e.getCurrentLevel() == currentLevel) {
                                if (e.isVisible()) {
                                    e.draw(batch);
                                }
                            }
                        }
                    }
                }
            }

        }

        for (Particle p : ParticleManager.getInstance().getParticlesListIteration()) {
            if (p.isVisible()) {
                p.draw(batch);
            }
        }

        endRender();

    }

    public static void setCamera(PlayerCamera cam) {
        playerCam = cam;
    }

}

```

`core/src/com/jxz/notcontra/world/SpawnPointList.java`:

```java
package com.jxz.notcontra.world;


import com.badlogic.gdx.maps.objects.PolylineMapObject;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Polyline;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Array;

/**
 * Created by Samuel on 15/05/2015.
 * Holds list of polylines for spawning purposes.
 */
public class SpawnPointList {
    // Local data structure for spawn points
    private class SpawnPointLine {
        public SpawnPointLine(Polyline line, float currentIndex) {
            this.line = line;
            index = currentIndex;
        }
        public Polyline line;
        public float index;
    }

    // Fields
    private Array<SpawnPointLine> spawnList;
    private float currentIndex;
    private Vector2 tmp; // Temporary vector used for calculations, so that a new instance doesn't need to be declared per calculation

    // Constructor
    public SpawnPointList() {
        spawnList = new Array<SpawnPointLine>();
        currentIndex = 0;
        tmp = new Vector2();
    }

    public void addLine(PolylineMapObject line) {
        SpawnPointLine spawnLine = new SpawnPointLine(line.getPolyline(), currentIndex);
        spawnList.add(spawnLine);
        currentIndex += spawnLine.line.getLength();
    }

    public Vector2 randomSpawn() {
        // Randomize target line, weighted by length
        float lineIndex = MathUtils.random(0, currentIndex);
        SpawnPointLine targetLine = spawnList.get(spawnList.size - 1);

        // Iterate through lines to find the proper line
        for (int i = 0; i < spawnList.size; i++) {
            if (i < spawnList.size - 1) {
                if (lineIndex > spawnList.get(i).index && lineIndex < spawnList.get(i + 1).index) {
                    targetLine = spawnList.get(i);
                }
            }
        }

        tmp.set(MathUtils.random(targetLine.line.getTransformedVertices()[0], targetLine.line.getTransformedVertices()[2]), MathUtils.random(targetLine.line.getTransformedVertices()[1], targetLine.line.getTransformedVertices()[3]));
        // Return a random position between the two vertices of the line
        return tmp.cpy();
    }
}

```

`desktop/build.gradle`:

```gradle
apply plugin: "java"

sourceCompatibility = 1.6
sourceSets.main.java.srcDirs = ["src/"]

project.ext.mainClassName = "com.jxz.notcontra.game.desktop.DesktopLauncher"
project.ext.assetsDir = new File("../android/assets");

task run(dependsOn: classes, type: JavaExec) {
    main = project.mainClassName
    classpath = sourceSets.main.runtimeClasspath
    standardInput = System.in
    workingDir = project.assetsDir
    ignoreExitValue = true
}

task dist(type: Jar) {
    from files(sourceSets.main.output.classesDir)
    from files(sourceSets.main.output.resourcesDir)
    from { configurations.compile.collect { zipTree(it) } }
    from files(project.assetsDir);

    manifest {
        attributes 'Main-Class': project.mainClassName
    }
}

dist.dependsOn classes

eclipse {
    project {
        name = appName + "-desktop"
        linkedResource name: 'assets', type: '2', location: 'PARENT-1-PROJECT_LOC/android/assets'
    }
}

task afterEclipseImport(description: "Post processing after project generation", group: "IDE") {
    doLast {
        def classpath = new XmlParser().parse(file(".classpath"))
        new Node(classpath, "classpathentry", [kind: 'src', path: 'assets']);
        def writer = new FileWriter(file(".classpath"))
        def printer = new XmlNodePrinter(new PrintWriter(writer))
        printer.setPreserveWhitespace(true)
        printer.print(classpath)
    }
}
```

`desktop/src/com/jxz/notcontra/game/desktop/DesktopLauncher.java`:

```java
package com.jxz.notcontra.game.desktop;

import com.badlogic.gdx.backends.lwjgl.LwjglApplication;
import com.badlogic.gdx.backends.lwjgl.LwjglApplicationConfiguration;
import com.jxz.notcontra.game.Game;

public class DesktopLauncher {
    public static void main(String[] arg) {
        LwjglApplicationConfiguration config = new LwjglApplicationConfiguration();

        config.title = Game.TITLE;
        config.width = Game.VID_WIDTH;
        config.height = Game.VID_HEIGHT;

        new LwjglApplication(new Game(), config);
    }
}

```

`gradle.properties`:

```properties
org.gradle.daemon=true
org.gradle.jvmargs=-Xms128m -Xmx512m
org.gradle.configureondemand=true
```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
#Sat Sep 21 13:08:26 CEST 2013
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=http\://services.gradle.org/distributions/gradle-2.2-all.zip

```

`gradlew`:

```
#!/usr/bin/env bash

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS=""

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn ( ) {
    echo "$*"
}

die ( ) {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
esac

# For Cygwin, ensure paths are in UNIX format before anything is touched.
if $cygwin ; then
    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
fi

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >&-
APP_HOME="`pwd -P`"
cd "$SAVED" >&-

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin, switch paths to Windows format before running java
if $cygwin ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=$((i+1))
    done
    case $i in
        (0) set -- ;;
        (1) set -- "$args0" ;;
        (2) set -- "$args0" "$args1" ;;
        (3) set -- "$args0" "$args1" "$args2" ;;
        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
function splitJvmOpts() {
    JVM_OPTS=("$@")
}
eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"

exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"

```

`gradlew.bat`:

```bat
@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS=

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto init

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto init

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:init
@rem Get command-line arguments, handling Windowz variants

if not "%OS%" == "Windows_NT" goto win9xME_args
if "%@eval[2+2]" == "4" goto 4NT_args

:win9xME_args
@rem Slurp the command line arguments.
set CMD_LINE_ARGS=
set _SKIP=2

:win9xME_args_slurp
if "x%~1" == "x" goto execute

set CMD_LINE_ARGS=%*
goto execute

:4NT_args
@rem Get arguments from the 4NT Shell from JP Software
set CMD_LINE_ARGS=%$

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar

@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`ios/Info.plist.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
    <dict>
        <key>CFBundleDevelopmentRegion</key>
        <string>en</string>
        <key>CFBundleDisplayName</key>
        <string>${app.name}</string>
        <key>CFBundleExecutable</key>
        <string>${app.executable}</string>
        <key>CFBundleIdentifier</key>
        <string>${app.id}</string>
        <key>CFBundleInfoDictionaryVersion</key>
        <string>6.0</string>
        <key>CFBundleName</key>
        <string>${app.name}</string>
        <key>CFBundlePackageType</key>
        <string>APPL</string>
        <key>CFBundleShortVersionString</key>
        <string>${app.version}</string>
        <key>CFBundleSignature</key>
        <string>????</string>
        <key>CFBundleVersion</key>
        <string>${app.build}</string>
        <key>LSRequiresIPhoneOS</key>
        <true/>
        <key>UIViewControllerBasedStatusBarAppearance</key>
        <false/>
        <key>UIStatusBarHidden</key>
        <true/>
        <key>UIDeviceFamily</key>
        <array>
            <integer>1</integer>
            <integer>2</integer>
        </array>
        <key>UIRequiredDeviceCapabilities</key>
        <array>
            <string>armv7</string>
            <string>opengles-2</string>
        </array>
        <key>UISupportedInterfaceOrientations</key>
        <array>
            <string>UIInterfaceOrientationPortrait</string>
            <string>UIInterfaceOrientationLandscapeLeft</string>
            <string>UIInterfaceOrientationLandscapeRight</string>
        </array>
        <key>CFBundleIcons</key>
        <dict>
            <key>CFBundlePrimaryIcon</key>
            <dict>
                <key>CFBundleIconFiles</key>
                <array>
                    <string>Icon</string>
                    <string>Icon-72</string>
                </array>
            </dict>
        </dict>
    </dict>
</plist>

```

`ios/build.gradle`:

```gradle
sourceSets.main.java.srcDirs = ["src/"]

sourceCompatibility = '1.7'
[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'

ext {
    mainClassName = "com.jxz.notcontra.game.IOSLauncher"
}

// Extracts native libs (*.a) from the native-ios.jar and places them
// under build/libs/ios/.
task copyNatives << {
    file("build/libs/ios/").mkdirs();
    configurations.natives.files.each { jar ->
        def outputDir = null
        if (jar.name.endsWith("natives-ios.jar")) outputDir = file("build/libs/ios")
        if (outputDir != null) {
            copy {
                from zipTree(jar)
                into outputDir
                include "*.a"
            }
        }
    }
}

// Updates a robovm.xml file.
task updateRoboVMXML << {
    def xml = file('robovm.xml')

    if (!xml.exists()) {
        return
    }

    // Find all native (*.a) libraries beneath libs
    def libtree = fileTree(dir: 'build/libs', include: '**/*.a')

    def config = new groovy.util.XmlParser().parse(xml)
    config.libs.each { libs ->
        libs.children().clear()
        libtree.each { File file ->
            libs.appendNode('lib', 'build/libs/ios/' + file.getName())
        }
    }

    def writer = new FileWriter(xml)
    def printer = new XmlNodePrinter(new PrintWriter(writer))
    printer.setPreserveWhitespace true
    printer.print(config)
}

updateRoboVMXML.dependsOn copyNatives
build.dependsOn updateRoboVMXML
tasks.eclipse.dependsOn updateRoboVMXML

launchIPhoneSimulator.dependsOn build
launchIPadSimulator.dependsOn build
launchIOSDevice.dependsOn build
createIPA.dependsOn build


eclipse.project {
    name = appName + "-ios"
    natures 'org.robovm.eclipse.RoboVMNature'
}
```

`ios/robovm.properties`:

```properties
app.version=1.0
app.id=com.jxz.notcontra.game.IOSLauncher
app.mainclass=com.jxz.notcontra.game.IOSLauncher
app.executable=IOSLauncher
app.build=1
app.name=notcontra

```

`ios/robovm.xml`:

```xml
<config>
    <executableName>${app.executable}</executableName>
    <mainClass>${app.mainclass}</mainClass>
    <os>ios</os>
    <arch>thumbv7</arch>
    <target>ios</target>
    <iosInfoPList>Info.plist.xml</iosInfoPList>
    <resources>
        <resource>
            <directory>../android/assets</directory>
            <includes>
                <include>**</include>
            </includes>
            <skipPngCrush>true</skipPngCrush>
        </resource>
        <resource>
            <directory>data</directory>
        </resource>
    </resources>
    <forceLinkClasses>
        <pattern>com.badlogic.gdx.scenes.scene2d.ui.*</pattern>
        <pattern>com.badlogic.gdx.physics.bullet.**</pattern>
        <pattern>com.badlogic.gdx.graphics.g3d.particles.**</pattern>
        <pattern>com.android.okhttp.HttpHandler</pattern>
        <pattern>com.android.okhttp.HttpsHandler</pattern>
        <pattern>com.android.org.conscrypt.**</pattern>
        <pattern>com.android.org.bouncycastle.jce.provider.BouncyCastleProvider</pattern>
        <pattern>com.android.org.bouncycastle.jcajce.provider.keystore.BC$Mappings</pattern>
        <pattern>com.android.org.bouncycastle.jcajce.provider.keystore.bc.BcKeyStoreSpi</pattern>
        <pattern>com.android.org.bouncycastle.jcajce.provider.keystore.bc.BcKeyStoreSpi$Std</pattern>
        <pattern>com.android.org.bouncycastle.jce.provider.PKIXCertPathValidatorSpi</pattern>
        <pattern>com.android.org.bouncycastle.crypto.digests.AndroidDigestFactoryOpenSSL</pattern>
        <pattern>org.apache.harmony.security.provider.cert.DRLCertFactory</pattern>
        <pattern>org.apache.harmony.security.provider.crypto.CryptoProvider</pattern>
    </forceLinkClasses>
    <libs>
    </libs>
    <frameworks>
        <framework>UIKit</framework>
        <framework>OpenGLES</framework>
        <framework>QuartzCore</framework>
        <framework>CoreGraphics</framework>
        <framework>OpenAL</framework>
        <framework>AudioToolbox</framework>
        <framework>AVFoundation</framework>
    </frameworks>
</config>

```

`ios/src/com/jxz/notcontra/game/IOSLauncher.java`:

```java
package com.jxz.notcontra.game;

import com.badlogic.gdx.backends.iosrobovm.IOSApplication;
import com.badlogic.gdx.backends.iosrobovm.IOSApplicationConfiguration;
import org.robovm.apple.foundation.NSAutoreleasePool;
import org.robovm.apple.uikit.UIApplication;

public class IOSLauncher extends IOSApplication.Delegate {
    @Override
    protected IOSApplication createApplication() {
        IOSApplicationConfiguration config = new IOSApplicationConfiguration();
        return new IOSApplication(new Game(), config);
    }

    public static void main(String[] argv) {
        NSAutoreleasePool pool = new NSAutoreleasePool();
        UIApplication.main(argv, null, IOSLauncher.class);
        pool.close();
    }
}
```

`settings.gradle`:

```gradle
include 'desktop', 'android', 'ios', 'core'
```